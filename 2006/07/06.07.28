00:27:02 <lispy> does haskell compare to c++? well, haskell is much less verbose...
00:27:36 <lispy> i read through a 2000 line c++ file today that barely specified the behavior of one dialog in a large program
00:28:24 <lispy> i kept thinking, "Okay the same pattern has been repeated 5+ times, shouldn't someone abstract this?"
01:02:40 <lde> @hoogle (Monad m) => m a -> (a -> m b) -> m b)
01:02:41 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
01:02:41 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
01:02:41 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
01:02:56 <lde> why doesn't it find >>= ?
01:06:44 <dons> ?hoogle >>=
01:06:45 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
01:06:52 <dons> ?hoogle Monad m => m a -> (a -> m b) -> m b
01:06:53 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
01:06:54 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
01:06:54 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
01:06:55 <dons> ?hoogle+
01:06:56 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
01:06:56 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
01:06:56 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
01:06:59 <dons> ?hoogle+
01:06:59 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
01:06:59 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
01:07:02 <lambdabot> Control.Parallel.Strategies.($||) :: (a -> b) -> Strategy a -> a -> b
01:07:09 <dons> no idea. probably a few things match?
01:08:22 <lde> oh, it has a limit of three matches?
01:09:20 <lde> but they doesn't even match :-)
01:10:39 <dons> in irc we limit it
01:10:51 <dons> perhaps try the hoogle web interface?
01:10:55 <dons> ?where hoogle
01:10:56 <lambdabot> http://www.haskell.org/hoogle
01:14:20 <lde> 1 - 25 of 632 :-)
01:14:44 <edwardk> I'm not sure I can make my type AltData.Typeable. It doesn't appear to have the ability to manipulate record based constructors.
01:15:51 <edwardk> functions, tuples, and tycons, no problem.
01:16:23 <int-e> poor dons ... hs-plugins will have to deal with package ids soon.
01:19:08 <edwardk> and it seems that something in the type of the object i'm trying to pass through the plugins interface is causing it to blow up
01:19:29 <edwardk> be it the fixed point, all of the record types, involved, etc.
01:25:28 <dons> int-e, yes :/
01:25:45 <edwardk> package ids?
01:27:21 <edwardk> unsafeEval_ def ["JIT"] [] [] ["."] :: IO (Either [String] (Maybe (P -> P -> P
01:27:21 <edwardk> -> P -> P -> P -> P -> P -> JitM JitR ()))) appears to be crashing
01:27:30 <edwardk> with any sort of function body
01:27:36 <edwardk> the normal one being something like:
01:27:39 <edwardk> let {result a b c d e f g h = seq a $ seq b $ seq c $ seq d $ seq e $ seq f $ seq g $ seq h $ do {let {v = 128};va <- p2a g; unsafeWrite va v g;let {vb = 129};let {vc = 100};vd <- p2a g; unsafeWrite vd vb vc;let {ve = 130};vf <- p2a g; unsafeWrite vf ve vc;let {vg = 131};vh <- p2a g; unsafeWrite vh vg g;let {vi = 4575};vj <- jit g vi;vj a vi vc d e f g h}} in result :: P -> P -> P -> P -> P -> P -> P -> P -> JitM JitR ()
01:28:19 <goltrpoat> [02:27] <lispy> i kept thinking, "Okay the same pattern has been repeated 5+ times, shouldn't someone abstract this?"
01:28:28 <goltrpoat> that's just bad programming though, hardly a reflection on the language
01:28:32 <goltrpoat> pardon the hour late reply.
01:29:18 <edwardk> though i note that rarely are all the regs used. so i think i might change my approach
01:30:11 <edwardk> i'm going to give up on the fixed point and trampoline it, coz this isn't working out so nicely
01:36:22 <dcoutts> dons, ping
01:38:07 <JaffaCake> Igloo: there?
01:39:05 <dcoutts> JaffaCake, can I ask a couple Cabal Qs..
01:39:13 <JaffaCake> sure
01:39:22 <MarcWebe1> When using ghc --keep-tmp-files where are they stored? I want to have a look at a cpp preprocessed file.. Or is this done entirely in cabal? (extension: cpp)
01:39:29 <dcoutts> JaffaCake, We've got a patch to do stuff with profiling & TH but I'd like your opinion
01:39:42 <JaffaCake> MarcWebe1: usually in /tmp, use ghc -v to find out
01:40:12 <dcoutts> JaffaCake, so TH needs vanilla libs even when you build with -prof, right?
01:40:21 <JaffaCake> right
01:40:26 <dcoutts> JaffaCake, it doesn't work atm I hear but it might do in future
01:40:40 <JaffaCake> I fixed it in HEAD recently
01:40:50 <dcoutts> ah ok
01:41:03 <dcoutts> so is it the right behaviour for Cabal to force the building of vanilla libs before building porfiling libs ?
01:41:07 <JaffaCake> back in a mo
01:41:25 <dcoutts> even if the user requested no vanilla libs
01:42:14 <dcoutts> so if TH is in the extensions field, and the user asked for profiling but not vanilla libs then we'd build vanilla libs, then profiling but only install the profiling ones.
01:42:33 <yip> a lot of you guys use darcs right? would it work ok for me if my computer is really old and slow?
01:42:59 <dcoutts> JaffaCake, we've recieved a patch to implement that behaviour and I wanted to double check it's right.
01:43:04 <dcoutts> @seen dons
01:43:05 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 17 minutes and 37 seconds ago.
01:43:38 <JaffaCake> back
01:44:01 <JaffaCake> dcoutts: that sounds right, I guess
01:44:11 <dcoutts> ok, great
01:44:37 <JaffaCake> you need to use -osuf when building the prof way, I hope Cabal does that already
01:44:47 <dcoutts> I assume it does :-)
01:44:57 <dcoutts> the other Q was, can you think of any objection to allowing packages to be registered hidden
01:45:22 <dcoutts> ie allowing users to add exposed : True/False to .cabal files
01:45:30 <dcoutts> the default is True of course
01:45:33 <JaffaCake> don't see a reason why not
01:45:51 <JaffaCake> doesn't affect Cabal, of course, since we use -hide-all-packages
01:45:59 <dcoutts> indeed
01:46:08 <dcoutts> the use case int-e has was for smei-private packages like lambdabit plugins
01:46:14 <musasabi> dcoutts: how should that behave for implementations that don't have expose/hide?
01:46:19 <dcoutts> and then there's hslibs
01:46:23 <dcoutts> musasabi, then it means nothing
01:46:26 <JaffaCake> dcoutts: right
01:46:31 <JaffaCake> and the ghc package too
01:46:36 <dcoutts> true
01:47:09 <JaffaCake> do you know anything about Igloo's recent patch to ghc-pkg/Main.hs?  It is breaking tests for me, and I wondered the reasoning behind it
01:47:27 <dcoutts> I don't
01:47:42 <JaffaCake> ok, no problem
01:48:13 <dcoutts> the one "Be lazier in user config creation, and don't fail on m..."
01:48:54 <dcoutts> so he's trying to avoid creating unnecessary package.conf files
01:49:08 <dcoutts> JaffaCake, when does it cause failures?
01:49:12 <JaffaCake> yes
01:49:24 <dcoutts> or rather what situations
01:49:36 <JaffaCake> eg." ghc-pkg register --user" now fails if you don't already have a user package database
01:50:26 <dcoutts> yeah, his patch doesn't look like it doesn't create the file if it'd be empty
01:50:41 <dcoutts> it just allows you to read a non-existant file as if it were empty
01:50:50 <dcoutts> which is fine for reading...
01:51:14 <JaffaCake> hmmm, I think we might just be missing a createDirectoryIfMissing somewhere...
01:52:00 <dcoutts> there should be just one place in the code where the file is written :-)
01:52:19 <dcoutts> then it'd be easy to check if there's no entries and the file does not already exist
01:52:40 <kosmikus> in TH, how can I reify a data type? something like reify (mkName "Maybe") always results in "`Maybe' is not in scope at reify" ...
01:53:11 <musasabi> kosmikus: reify ''Maybe
01:54:02 <JaffaCake> dcoutts: true, there is now just one place where the file is written
01:54:27 <kosmikus> musasabi: what's that? ;) it works, but is this syntax documented anywhere? what does it do?
01:54:54 <musasabi> in the TH notes postscript files at least.
01:55:07 <kosmikus> ok
01:55:20 <musasabi> 'Maybe = data connstructor called maybe lifted to TH level
01:55:26 <musasabi> ''Maybe = type connstructor called maybe lifted to TH level
01:57:58 <kosmikus> musasabi: thanks a lot. but do you know if it is also possible to generate such a name from a string?
01:58:45 <musasabi> maybe. You need to at least qualify with the correct module.
01:59:16 <kosmikus> that doesn't work
01:59:33 <kosmikus> but anyway, this should be enough for what I need at the moment.
02:08:14 <Pete_I> does haskell have a builtin average function?
02:10:53 <Lemmih> Pete_I: Nope.
02:11:59 <musasabi> > let avg xs = sum xs / length xs in avg [10,20,.. 500]
02:12:00 <lambdabot>  Parse error
02:12:07 <musasabi> > let avg xs = sum xs / length xs in avg [10,20 .. 500]
02:12:09 <lambdabot>  add an instance declaration for (Fractional Int)
02:12:09 <lambdabot>   In the definition of `...
02:12:13 <musasabi> > let avg xs = sum xs / length xs in avg [10,20 .. 500.0]
02:12:14 <lambdabot>  add an instance declaration for (Fractional Int)
02:12:14 <lambdabot>   In an arithmetic seque...
02:12:19 <musasabi> grah.
02:12:23 <musasabi> make it generic length
02:12:59 <musasabi> fromIntegral etc
02:25:53 <xerox> Good morning :)
02:31:56 <goltrpoat> cool.  i just got a 10x speedup from replacing 'and $ f x : map g x' with 'and $ map g x ++ [f x]'
02:32:10 <goltrpoat> may the rest of it be so easy.
02:33:09 <xerox> What about |f x && and (map g x)| no consing!
02:33:40 <dcoutts> goltrpoat, I'd have thought it'd be the other way around
02:33:44 <goltrpoat> eh.. we're talking 1 second vs 10 seconds for that single expression, i don't think removing the cons will help much
02:34:08 <dcoutts> oh you're avoding calling f in most circumstances
02:34:14 <goltrpoat> yeah
02:34:23 <goltrpoat> g gives lots of early outs, not so much for f
02:34:44 <dcoutts> xerox, so you want: all g x && f x
02:35:04 <dcoutts> :type \g -> and . map g
02:35:10 <dcoutts> @type \g -> and . map g
02:35:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:35:16 <dcoutts> @type all
02:35:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:36:04 <dcoutts> @seen dons
02:36:05 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 10 minutes and 36 seconds ago.
02:36:14 <dcoutts> @localtime dons
02:36:17 <lambdabot> Local time for dons is Fri Jul 28 19:29:52 2006
02:36:28 <dcoutts> I always get up too late it seems :-)
02:37:54 <xerox> I always get and and all wrong :)
02:38:08 <goltrpoat> odd.  going to all g x && f x did seem to speed it up a bit (i'm not timing it, it was slow enough to be able to eyeball the optimizations)
02:38:26 <goltrpoat> oh.  crap, that function gets called 1.8 million times.  i thought i was elsewhere.
02:38:41 <goltrpoat> thanks :)
03:11:37 <Igloo> JaffaCake: Here now, if you want to talk further (I've replied to your e-mail)
03:29:28 <MarcWebe1> I've read a tutorial about using StateT (using multible states at once) once.. But I can't find it anymore. Can you point me to an example where either State or Reader monad is used with multiple environments/states or is it common to pass a tuple then?
03:31:09 <musasabi> define an abstract datatype and make just few accessor functions that depend on the monad stack ordering
03:35:40 <joelr1> howdy folks
03:35:44 <joelr1> JaffaCake: ping
03:52:25 <MarcWebe1> musasabi: I'm not quite sure what you mean by monad stack ordering. That's about nested monades, right?
04:08:13 * liyang wonders if the Template Haskell mailing list is broken...
04:10:11 <xerox> musasabi: do you think it's better to stack monads than make a product of states' types?
04:18:09 <musasabi> MarcWebe1: yes.
04:19:00 <musasabi> xerox: usually I just newtype my monad and initially use a quick stack (and a few combinators to hide the stacking order). Then when I need more performance I rewrite the monad implementation to be something more optimal.
04:21:19 <kpreid> @tell dons my intention was that @id x == @. unquote run "x" -- I assumed that if @id's implementation "id" was safe @unquote wouldn't be worse
04:21:19 <lambdabot> Consider it noted.
04:23:19 <kpreid> @tell dons I wanted to be able to have lambdabot say an arbitrary (normal, not CTCP) string (which @id already allows) that was computed.
04:23:20 <lambdabot> Consider it noted.
04:25:46 <roconnor> @seen shapr
04:25:47 <lambdabot> shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 21 hours, 34 minutes and 50 seconds ago.
04:26:23 <ricky_clarkson> The seconds make all the difference.
04:48:14 * Lemmih wonders why darcs thinks his unit test is boring.
04:49:30 <shapr> @yow!
04:49:31 <lambdabot> Am I accompanied by a PARENT or GUARDIAN?
04:49:36 <shapr> roconnor: You called?
04:49:36 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
04:51:39 <shapr> Good afternoon #haskell!
04:51:44 <psi> it appears lambdabot didn't consider your @yow as activity from your side
04:51:48 <JKnecht> hey shae!
04:52:47 <shapr> psi: Good point.
04:52:58 <shapr> hiya JKnecht, what's up?
04:55:16 <JKnecht> nuthin much, on the glide path to my 1st Haskell(ish) apps. Landing gear are in the locked position.
04:57:16 * shapr boings for more Haskell apps!
05:06:47 <dcoutts> @pl (\_ x -> x+9)
05:06:47 <lambdabot> const (9 +)
05:07:02 <dcoutts> @pl (\x _ -> x+9)
05:07:03 <lambdabot> const . (9 +)
05:08:14 * dcoutts fixes his use of foldr' and re-runs the benchmarks
05:08:33 <dcoutts> I had do idea foldr' would be so handy :-)
05:08:53 <dcoutts> you don't get foldr' on lists so people don't know about it
05:09:22 <xerox> What do you mean?
05:09:39 <dcoutts> foldr' is to foldr what foldl' is to foldl'
05:09:43 <dcoutts> err
05:09:46 <dcoutts> foldr' is to foldr what foldl' is to foldl
05:10:44 <dcoutts> so why is there foldl' on lists but no foldr' ?
05:11:10 <dcoutts> (hint: because it makes no sense - but why?)
05:11:28 <xerox> Behavior wrt bottoms?
05:21:52 <malcolm> dcoutts: at a guess, because (:) is non-strict in its tail
05:24:01 <dcoutts> I was thinking because to do an effecient strict foldr' you need to start at the back of the list
05:24:30 <dcoutts> similarly for an effecient foldl you should start at the back of the sequence
05:24:43 <dcoutts> which of course you can't with a list
05:24:47 <dcoutts> but you can with an array
05:25:27 <dcoutts> sequences which can be accessed at either end can support effecient foldl, foldl', foldr, foldr'
05:26:05 <dcoutts> foldl' and foldr go up, foldl and forld' go down
05:33:00 <malcolm> I see, makes sense
05:51:19 * malcolm would like to report to any debian maintainers of nhc98 that the long-standing hi-mem bug has been fixed (patch available from website)
06:01:49 <roconnor> @seen shapr
06:01:50 <lambdabot> shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 1 hour, 4 minutes and 34 seconds ago.
06:04:33 <SamB> uh.
06:05:01 <SamB> > map toLower "#ScannedInAvian"
06:05:02 <lambdabot>  "#scannedinavian"
06:05:17 <SamB> > map toLower "#ScannedInAvian" /= "#scannedinavian"
06:05:19 <lambdabot>  False
06:06:08 * malcolm apologises that it has taken him 5 months since Niklas fixed the nhc98 bug to publish it as a patch.
06:55:51 <Lemmih> shapr: ping.
07:15:54 <falconair_> is there a tutorial for haskell that includes info on threads?
07:17:09 <musasabi> introductory tutorials don't usually touch threading.
07:17:26 <falconair_> any reference for threads other than the api documentation?
07:17:28 <musasabi> in general when one understands IO then threading in Haskell is easy
07:17:50 <musasabi> falconair_: many papers
07:18:00 <Failure02> google for "awkward squad"
07:18:29 <musasabi> forkIO + threadDelay are mostly the only threading primitives.
07:18:40 <falconair_> well, I noticed there is something called MVars, is that related to what other languages call logic variable, data flow variable, sync variable, etc.? (which is used to build futures/promoses)
07:19:26 <musasabi> falconair_: MVar is a "hole". If it is empty you can put something inside it. If it is full you can take the contents out of it.
07:19:55 <falconair_> if it is empty, and some code tried to read it, does it 'block' until something is put in it by a different piece of code?
07:20:26 <musasabi> yes. (there are operations that check whether it is empty and return the result too)
07:22:15 <dcoutts_> falconair_, and similarly, if it's full and you try to write it then it blocks 'til some other thread empties it
07:22:36 <dcoutts_> so it's the primitive you use for mutual exclusion
07:22:41 <dcoutts_> protecting data
07:22:51 <dcoutts_> producer consumer threads
07:23:05 <dcoutts_> and things like unbounded queues are built from those primitives
07:23:38 <falconair_> basically i'm trying to figure out how to make a list which is continuously updated, but is consumable by fold/filter/map/etc....similar to what Mozart/Oz provides....is there something like that already provided?
07:24:02 <falconair_> dcoutts_: i didn't read you last message before I sent mine :)   where can i find such unbounded queues?
07:24:18 <dcoutts_> @hoogle quque
07:24:19 <lambdabot> No matches found
07:24:45 <musasabi> falconair_: so you want to lazily produce a list with other threads giving the values and handle it as an infinite list?
07:24:51 <shapr> roconnor: you called?
07:24:59 <dcoutts_> falconair_, Control.Concurrent.Chan
07:25:13 <musasabi> exactly
07:25:30 <musasabi> there is a function like: Chan a -> IO [a]
07:25:33 * shapr pokes roconnor 
07:25:45 <dcoutts_> falconair_, you may be interested to know that there's a newer set of thread communication primitives that people are excited about called STM
07:25:52 <falconair_> right, specifically i'd like to allow users to use some simple query lang, which could be run against static data as well is streaming data (such as stock quotes)
07:26:45 <dcoutts_> falconair_, the STM stuff replaces all the things based on MVars and has better properties when you try to safely compose operations into actions that are atomic overall.
07:27:04 <falconair_> google shows me "Lock Free Data Structures using STMs in Haskell," is that a good introductory paper?
07:27:16 <dcoutts_> probably the initial STM paper is best
07:27:30 <dcoutts_> not sure what that's called
07:27:46 <musasabi> It is linked from simonpj's page
07:28:19 <jgrimes_> STM papers: http://research.microsoft.com/~simonpj/papers/stm/index.htm
07:28:20 <lambdabot> Title: Papers on transactional memory
07:28:24 <gds> dcoutts_: "Composable Memory Transactions"
07:28:34 <dcoutts_> gds, ah, thanks
07:28:53 <falconair_> great stuff, thanks all, i have a bit of reading to do :)
07:29:18 <falconair_> oh, is a new version of GHC expected any time soon?  installing the existing one is still a pain on OS X
07:29:34 <dcoutts_> falconair_, 6.4.3 and 6.6 are still a ways off
07:30:29 <falconair_> oh well, it'll probably take me long enough understand this stuff any way :)
07:32:00 <emertens> installing the existing one is blindingly easy
07:32:04 <emertens> type: sudo port install ghc
07:32:11 <emertens> ... wait... and done
07:32:35 <falconair_> i try that at least once a week, i happen to have an intel machine, which is not yet supported
07:34:14 <sjanssen> falconair_: yep, you need the development version for an Intel Mac
07:34:38 <falconair_> i don't think the dev version works either...easy enough to check
07:35:06 <sjanssen> I use it every day, not sure why it wouldn't work for you
07:35:10 <falconair_> ghc-devel is not supported on OS X i386 yet
07:35:29 <sjanssen> oh, you mean in the ports
07:35:53 <sjanssen> that shouldn't be too tough to get working, I think
07:35:55 <dcoutts_> sjanssen, btw, how's the SoC hacking going?
07:36:00 <falconair_> yeah, i'm still fairly new to the mac so i try to stick to ports
07:36:07 <dcoutts_> sjanssen, and have you seen the Streams code and the benchmarks?
07:36:41 <sjanssen> dcoutts_: things are going well.  I've looked at the code a bit, but not the benchmarks
07:36:47 <sjanssen> dcoutts_: are they good?
07:37:17 <dcoutts_> falconair_, sjanssen, does OSX come with support to install things from the ports collection by default? I thought OSX had a different installation setup using frameworks or disk images or something.
07:37:23 <dcoutts_> sjanssen, they're very good :-)
07:37:40 <dcoutts_> sjanssen, 2x to 3x times faster in the best cases
07:38:04 <sjanssen> dcoutts_: you have to install darwinports
07:38:12 <dcoutts_> ah right
07:38:26 <dcoutts_> sjanssen, are you using 6.4.2 for your ByteString hacking?
07:38:40 <falconair_> you have to install a small program from darwinports.org for command-line/unix stuff, most apple specific stuff has its own (very nice) installers
07:38:53 <sjanssen> dcoutts_: I've been using 6.5 mostly
07:38:58 <dcoutts_> sjanssen, ah good as recent versions of 6.5 are *much* faster
07:39:35 <dcoutts_> 40% on average over the ByteString benchmarks
07:40:02 <sjanssen> dcoutts_: when do you project the streams stuff to move into the normal fps branch?
07:40:33 <dcoutts_> we'll we're focusing on benchmarking, & comparing & tweaking for our paper
07:40:48 <dcoutts_> we can discuss priorities with dons
07:41:13 <dgoldsmith> One problem I've found building is putting GNU readline somewhere GHC can find it and be happy, while still keeping the native OS X libreadline (really libedit) around in its normal place.
07:41:15 <dcoutts_> I'm sure it'll get in eventually now that we know it's a speedup in almost all cases
07:41:43 <dcoutts_> dgoldsmith, mm, it'd be nice if GHC could use libedit
07:41:51 <dons> hey guys. just popped in on my way to bed..
07:41:51 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:41:53 <dcoutts_> i'm sure it's not that hard
07:41:56 <dcoutts_> dons!
07:42:01 <dons> i think we can get this stuff in soon..
07:42:05 <dons> real soon. 2 weeks or less.
07:42:10 <dcoutts_> aye
07:42:16 <dcoutts_> that seems a reasonable timescale
07:42:30 <jmob> Is there a way to write this is a point free manner?  (\y -> x == (fst y)
07:42:32 <dons> is this 40% figure new, duncan?
07:42:39 <sjanssen> @pl \y -> x == fst y
07:42:39 <lambdabot> (x ==) . fst
07:42:46 <dcoutts_> dons, new in the last two days
07:42:57 <dgoldsmith> dcoutts_: yes, that would make life easier. It wound be nice to just reduce the functionality if libedit is being used, rather than refuse to build.
07:43:00 <jmob> @pl ?
07:43:01 <lambdabot> (line 1, column 1):
07:43:01 <lambdabot> unexpected "?"
07:43:01 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
07:43:01 <dons> ah. ok. so that's with the new rules matches firing
07:43:13 <dons> ?pl \f x -> f x
07:43:13 <lambdabot> id
07:43:19 <dcoutts_> dons, yes and other random improvements
07:43:24 <dcoutts_> dons, it's not all rules
07:43:26 <jmob> Wow, that's cool.
07:43:33 <dons> ok. great news.
07:43:43 <dons> i really didn't expect that much
07:43:58 <dcoutts_> dons, did I mention that Streams is 3x faster on map/map and 2x faster on filter/filter ?
07:44:07 <dcoutts_> compared to the next best system
07:44:08 <dons> oh. no. wow. roman will be happy
07:44:16 <dcoutts_> which is the WrapElimNoAcc
07:44:30 <dons> oh , that's good that the more advanced system still gives a benefit
07:44:36 <dcoutts_> WrapElimNoAcc and WrapElimMapFilter are about the same in performance
07:44:36 <dons> over no wrapper elim
07:44:43 <dons> ok
07:44:44 <jmob> dons: How is @pl implemented?
07:44:51 <dcoutts_> jmob, magic
07:44:55 <dons> jmob, it uses term rewriting :)
07:45:02 <dcoutts_> like I said :-)
07:45:18 <dons> using a large set of equivalences, and some heuristics about what to rewrite next
07:45:33 <dcoutts_> dons, so compared to the original loopU with 6.4.2 we're getting several fold improvements
07:45:39 <dons> its quite sophisticated. wadler was asking about it the other day, in fact.
07:45:53 <dons> dcoutts_: excellent.
07:45:56 <dons> now, patches to send me?
07:46:04 <dons> i want to get the benchmarks run here in the morning
07:46:11 <dcoutts_> dons, as soon as I finnish the latest benchmark run
07:46:27 <dcoutts_> dons, the foldr/foldr' in the benchmark needed fixing
07:46:35 <dons> ah, right. you mentioned that
07:46:53 <dons> sjanssen: i see there's been a bit more buzz on the mailing lists about fps-soc :)
07:47:38 <dcoutts_> dons, 1.116 for map/map with LoopUpDown with 6.4.2 vs 0.200 for map/map with Streams with 6.5
07:47:51 <dons> huh
07:47:57 <sjanssen> dons: yes, apparently I have plenty of potential users
07:48:09 <dcoutts_> dons, seconds
07:48:24 <irc> The libedit/readline issue should be fixed in the next release. I submitted a patch for it. (It detects that libedit is not libreadline and refuses to use it.
07:48:28 <dons> oh, ok. still good :)
07:48:41 <dons> dcoutts_: when are you heading to cambridge?
07:49:10 <dcoutts_> dons, next Thursday or Friday
07:49:16 <dcoutts_> and there 'til sunday
07:49:35 <dons> ok, i /think/ roman will be there from monday or so
07:49:40 <dcoutts_> oh cool
07:49:43 <jgrimes_> can you load code using arrows into ghci?
07:49:50 <dons> jgrimes_: sure.
07:49:56 <dcoutts_> we'll all be at MSR on Friday
07:50:00 <dons> yeah
07:50:31 <jgrimes_> dons: I'm getting a "Could not find module..." error when trying to load a .as file
07:50:43 <dons> Prelude Control.Arrow> (reverse *** (+3)) $ ("foo", 7)
07:50:44 <dons> ("oof",10)
07:50:49 <dcoutts_> dons, as for the folds, so we were doing "foldr (const.(+9)) . " which isn't even a downloop :-) and the (const.(+9)) is not right for a foldr like it is for a foldl, so I changed it to (const (+9)) instead
07:50:59 <dcoutts_> and to use foldr'
07:51:05 <dons> .as? oh, maybe that's not qutie the arrows i wsa thinking of
07:51:10 <dons> is that the arrow dsl?
07:51:19 <dcoutts_> so we ought really to have some foldl and foldr benchmarks too
07:51:30 <xerox> ... -farrows enables the syntactic sugars, I believe.
07:51:30 <dcoutts_> but they wouldn't be the kind that reduce to a single value
07:51:32 <dons> hmm. yep.
07:51:37 <dons> xerox: ah yes, sounds right
07:51:42 <dcoutts_> that's what foldr' and foldl' are fore
07:51:49 <xerox> returnA, -<, <- and friends.
07:51:59 <dcoutts_> so perhaps a foldr (:) []
07:52:02 <dons> yeah, good idea. we should check the folds that produce complicated results
07:52:42 <xerox> Hey people, do you think this is the put program? http://hackage.haskell.org/darcs/cabal-server-install/create-index.hs
07:53:30 <xerox> I am boggled because it is not part of the repository, and that repository is linked in the ticket as "containing the put program"...
07:53:34 <dcoutts_> dons, actually a length . foldr (:) []  would be a good example of where lazyness is good because we don't have to build the whole list before consuming it as the WrapElim systems do with the current fold(l|r)
07:53:44 <dons> yeah
07:53:56 <dcoutts_> dons, although that's just because we never did foldr properly with the previous systems, it's possible to do
07:54:02 <dcoutts_> so perhaps we should do it
07:54:19 <dcoutts_> I'm sure the Streams one will still be faster, because it's simpler
07:54:33 <dons> right. still, its something we can consider.
07:54:45 <dons> the code's in a reasonable state, so we can pursue some asides
07:54:48 <dcoutts_> dons, otherwise it's not fair to compare the non-strict folds
07:55:23 <dons> ok. time for me to get some sleep. i'll try to get up early and catch you, so we can coordinate tomorrow's push
07:55:29 <dcoutts_> dons, ok
07:55:36 <dcoutts_> what time will we both be about?
07:55:57 <dcoutts_> I can be up at around 9:30 your time for an hour or two
07:55:58 * dons does some timezone arithmetic
07:56:19 <dons> dcoutts_: ok. i'll try to make it up by 10 :) otherwise, email.
07:56:26 <dcoutts_> ok :-)
07:56:38 <dcoutts_> otherwise when I get up has more overlap
07:56:44 <dons> yeah
07:57:01 <dons> but i'd like the new code, since i want to run the benchmarks on my boxes
07:57:07 <dcoutts_> right
07:57:12 <dcoutts_> I'll wait up
07:57:18 <dons> so if you can send patches at least
07:57:33 <dons> ok. night!
07:57:40 * dons evaporates
07:58:07 <dcoutts_> g'night dons
07:58:13 <dcoutts_> dons, yep, will do
08:00:25 <jgrimes_> ok, so I missed the "just rename your arrow module as an ordinary Haskell source file and invoke GHC with -farrows" part
08:00:43 <jgrimes_> everything works just fine now :)
08:05:25 <xerox> Anybody has code to walk a hierarchy of directories recursively?
08:05:56 <vincenz> xerox: sort of
08:06:00 <vincenz> xerox: check my darcs-apply
08:06:06 <vincenz> on my wiki under softwaer
08:06:09 <vincenz> @where vincenz
08:06:10 <lambdabot> http://notvincenz.com/
08:06:34 <xerox> Thanks
08:09:14 <dropdrive>  /quit
08:12:39 <dcoutts_> sjanssen, 0.776 for map/map and 2.412 for filter/filter with Streams and 6.4.2, but 0.204 and 0.304 for 6.5
08:13:32 <dcoutts_> so that's doing map f . map g over 50Mb of data in 0.2 seconds
08:13:49 <dcoutts_> which is not too bad I reckon :-)
08:15:11 <sjanssen> that is excellent
08:15:16 <dcoutts_> @hoogle mapAccumL
08:15:17 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
08:15:17 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:16:37 <xerox> dcoutts_: may I disturb you a second with a cabal question?
08:16:42 <dcoutts_> aye
08:17:19 <xerox> Is it yet decided what the put program should do, exactly?
08:17:29 <dcoutts_> not exaclty I think
08:17:32 <vincenz> xerox: that help?
08:17:37 <xerox> In particular, what is this <http://hackage.haskell.org/darcs/cabal-server-install/create-index.hs> ?
08:18:11 <dcoutts_> xerox, iirc, put was just going to be done with ssh
08:18:17 <xerox> I wonder if I should write a program such that it only creates the index, given the hierarchy, or what else.
08:18:42 <dcoutts_> xerox, oh yes, so scp and then re-generating the index
08:18:46 <xerox> http://hackage.haskell.org/trac/hackage/ticket/87
08:18:48 <lambdabot> Title: #87 (robustify &amp; release cabal-get) - Hackage - Trac
08:19:14 <xerox> It says `finish implementing the put program found here' which I believe is that one, could it be anything else?
08:19:26 <dcoutts_> xerox, so a stand-alone program that you run on the server to re-generate the index? don't we already have that?
08:20:01 <xerox> It seems like this program does actually generate an index, and does it wrongly, but the data it starts with is a list at the end of the file, which is ... strange?
08:20:28 <xerox> I can write a program which generates the index, given the hierarchy, for example.
08:20:37 <dcoutts_> sounds good
08:20:39 <xerox> But, do we need a separate program for this task?
08:20:42 <dcoutts_> I don't know much about the index format
08:21:01 <dcoutts_> xerox, presumably we do, as it'd be run after adding a package
08:21:02 <xerox> I don't see scp-ing code anywere, that is what bothers me.
08:21:14 <dcoutts_> xerox, I think that'd be manual to start with
08:21:18 <xerox> OK!
08:21:41 <xerox> So one uploads a tar.gz ?
08:21:45 <dcoutts_> right
08:21:54 <dcoutts_> but ask SyntaxNinja to be sure
08:21:55 <xerox> Sounds good.
08:22:03 <xerox> I did, but I didn't receive reply from days now :-|
08:22:07 <dcoutts_> ah :-(
08:22:22 <dcoutts_> I heard vaugely that that was the initial plan
08:23:18 <xerox> I'd like to understand what to do exacly so to not write unuseful code.
08:23:49 <xerox> create-index is quite simple, I can do it, and then I could test, and put the code online.
08:24:00 <xerox> Test it with cabal-install I mean.
08:24:12 <xerox> I didn't yet checked if the version we have now unrolls the dependencies.
08:24:57 <dcoutts_> xerox, unrolls?
08:25:16 <xerox> Checks for the dependencies and dowlonads&installs them before going on with the program itself
08:25:20 <dcoutts_> right
08:25:39 <dcoutts_> xerox, do you have code yet to do that? to do the dependency chasing?
08:25:51 <xerox> I _think_ actual cabal-install does it
08:26:02 <xerox> Didn't test yet, I only successfully installed helloWorld2 with it
08:26:08 <dcoutts_> xerox, if not, note that kosmikus has some code which does sometime similar and actually more sophisticated
08:26:38 <dcoutts_> more sophisticated in that it works for gentoo packages which are more complex than cabal packages
08:28:56 <xerox> I should first write create-index, then dummy dependent cabalized packages, and test
08:29:05 <xerox> I don't think we have dependent packages "hackaged" now
08:29:08 <xerox> (Do we?)
08:30:32 <dcoutts_> xerox, there's some chains, like xml-rpc, http, crypto, newbinary
08:30:38 <roconnor> shapr: plink
08:31:35 <xerox> Do you know what dependency "lang" is ?
08:31:54 <dcoutts_> xerox, it's one of the old hslibs that come with ghc
08:32:03 <dcoutts_> it's deprecated and should not be used
08:32:16 <xerox> I think "hackaged" packages are very old :)
08:32:25 <dcoutts_> aye :-)
08:32:30 <xerox> I'll put up something more updated!
08:32:35 <dcoutts_> good!
08:32:43 <xerox> Thanks Duncan!
08:32:57 <dcoutts_> np
08:40:46 <shapr> roconnor: y0
08:41:18 <shapr> @seen roconnor
08:41:18 <lambdabot> roconnor is in #haskell-blah and #haskell. I last heard roconnor speak 10 minutes and 39 seconds ago.
08:49:03 <roconnor> shapr: What the status of the Monad Reader?
08:50:04 <roconnor> I want to develop an example of circular programming I implemented last night.
08:52:02 <SamB> roconnor: well, shapr isn't editing it anymore...
08:53:13 <roconnor> what's an appopriate venue for such articles?  The wiki?
08:53:26 <roconnor> or is there another editor?
08:56:01 <tato> circular programming?
08:57:08 <roconnor> tato: let (a,b) = f (b,c) in a
08:57:11 <lispy> meta circular?
08:57:35 <tato> uuuuhhhhhh
08:57:59 <tato> how could that be useful?
08:58:36 <roconnor> it allows you to do one pass on your data to do what normally requires multiple passes.
09:00:09 <roconnor> In my example, I create an assembly language monad where I write jmps to instructions that haven't yet been labeled.
09:00:40 <greenrd> roconnor: cool
09:00:59 <greenrd> roconnor: please ping me when you've published it
09:01:07 <greenrd> I'd like to read it
09:02:34 <musasabi> roconnor: mdo?
09:02:48 <musasabi> or something entirely else?
09:02:49 <roconnor> I don't use mdo
09:03:18 <roconnor> link mc = asm
09:03:18 <roconnor>  where
09:03:19 <roconnor>   ((), _, output) = runRWS mc labels (Location 0,0)
09:03:19 <roconnor>   (asm, labels) = splitEithers output
09:03:26 <roconnor> This is the code that ties the knot.
09:04:19 <musasabi> sounds interesting. My first thought was a variation of: "mdo jump foo; something else; foo <- label; ..."
09:04:53 <roconnor> can you do that?
09:05:04 <roconnor> what are the semantics of mdo?
09:06:49 <roconnor> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/syntax-extns.html
09:06:51 <lambdabot> Title: 7.3. Syntactic extensions
09:08:37 <xerox> dcoutts_: what is the default policy with respect to filesystem incongruences?
09:08:56 <dcoutts_> xerox, huh? what kind of filesystem incongruences?
09:08:56 * roconnor wonders if I can use mdo instead of what I have.
09:09:14 <xerox> dcoutts_: for example if there exist the package's directory, but it is empty, instead of containing the tarball.
09:09:27 <xerox> dcoutts_: or, for example, there are no packages directories.
09:09:27 <dcoutts_> roconnor, the implementation of mdo for IO is quite enlightening
09:09:44 <dcoutts_> xerox, then it's bogus!
09:09:48 <xerox> dcoutts_: moreover, what if the tarball could not be extrated, or the cabal file unreadable, & co.
09:09:53 <shapr> SamB: Actually, I want to restart it...
09:09:57 <shapr> roconnor: You want to write an article?
09:10:07 <SamB> shapr: oh cool
09:10:07 <xerox> What kind of action is one supposed to take? `error' it out? Sometimes it feels too much.
09:10:11 <roconnor> shapr: I think so
09:10:13 <musasabi> roconnor: mdo is a recursive do notation for the monads that support it.
09:10:17 <xerox> `it feels like it's too much.'
09:10:24 <SamB> I should look for the stuff I was writing for my article...
09:10:26 <dcoutts_> xerox, the tool should only add packages to the index that are ok, and report errors for all packages that are not ok
09:10:31 <roconnor> shapr: I was thinking that we might be able to make an ICFP2006 PC special issue.
09:10:33 <sylvan> roconnor: I'd like to read something like that. Laziness used like that is cool, but for more involved examples (e.g. a tree where each node has a "reference" to its parent) I have trouble following it, so I think I'd enjoy reading something about it.
09:10:34 <SamB> I put some in a notebook, I think...
09:10:45 <SamB> (or did I already transcribe all of that?)
09:10:46 <roconnor> if others want to write articles on JIT's or fast UMs
09:10:48 <musasabi> (via a monadic fix-point operator and fancy semantics, that one can mostly ignore)
09:10:52 <xerox> dcoutts_: should it break if there are packages which are not okay? Or should it warn only?
09:11:10 <SamB> roconnor: hold on, we haven't written those yet have we?
09:11:12 <roconnor> sylvan: yeah, I like searching for more and more problems that laziness elegently solves.
09:11:17 <dcoutts_> xerox, it should probably still build and index but exclude the offending packages
09:11:25 <xerox> dcoutts_: OK.
09:11:48 <xerox> Man, there are so many things that can go wrong in real world code.
09:11:52 <dcoutts_> xerox, afterall, suppose you've got an ok index, now you add a new package, we don't want to be left with no index just because the new package is bad
09:11:54 <shapr> roconnor: I like that idea.
09:11:59 <roconnor> SamB: I have faith. ;)
09:12:03 <dcoutts_> xerox, we just want to ignore the bad package
09:12:05 <musasabi> I could do the comonad article - or something similar if the deadline is not in august.
09:12:09 <xerox> dcoutts_: OK!
09:12:23 <SamB> I'm thinking that the C idea is pretty neat, but how well can Haskell interface with the datastructures the generated C code would need?
09:12:25 <sylvan> roconnor: So far  a lot of those examples are clearer in multiple passes though.. Like the normalisation one for example, the "map (/sum xs) xs" solution is cleaner imo
09:12:26 <xerox> I'll make it spit some informations, `catch'y code on the way.
09:12:41 <dcoutts_> xerox, it's not too hard, just wrap it in a exception handler that warns loudly and returns Nothing
09:12:50 <xerox> Right.
09:13:02 <dcoutts_> xerox, so the code that looks at each package just throws an exception
09:13:11 <xerox> dcoutts_: one have to think about how to stack things because there is IO in the middle.
09:13:16 <SamB> which is to say, the global array for the registers?
09:13:17 <dcoutts_> then you collect up all the 'Justs' with catMaybes
09:13:18 <roconnor> shapr: maybe we could set the channel topic asking for interest, or call for sumbissions for such an issue.
09:13:44 <roconnor> sylvan: Although my example is still a toy, I think it is pretty compelling.
09:13:47 <xerox> dcoutts_: but if an exception is thrown, isn't the program interrupted?
09:14:11 <dcoutts_> xerox, okPackages <- fmap catMaybes $ mapM $ \p -> handleException (doPkg p)
09:14:30 <xerox> ... _inside_, gotcha.
09:14:32 <dcoutts_> xerox, not if you put an exception handler round the bit that looks at each package
09:14:37 <sylvan> roconnor: I found a double-linked list a few days ago, didn't have time to really understand it those, but it seemed kind of involved
09:14:43 <roconnor> musasabi, shapr: Perhaps an issue for September, when the results are announced?
09:14:46 <dcoutts_> and returns Nothing and prints a warning
09:14:48 <shapr> Sounds good to me.
09:14:59 <xerox> dcoutts_: perfect, it fits greatly in my code.
09:15:01 <dcoutts_> or return Either Pkg Error
09:15:02 <roconnor> sylvan: I think my example is pretty clear.
09:15:20 <musasabi> shapr: how many articles would be needed (and are there some waiting for an issue)?
09:15:21 <roconnor> It's maybe a little hard to believe it works.
09:15:26 <SamB> I toyed with the idea of doing something with qemu's tool, but realized that that would mean writing an optimizer if you wanted to do much more than avoid dispatch...
09:16:12 <shapr> musasabi: I like to have at least five articles, but with the many months since the last issue, I think that'll be easy.
09:16:41 * SamB wonders if his last change improved the speed of his UM or not
09:16:48 <SamB> I expect it must have, really...
09:16:49 <sylvan> roconnor: I think there was some shootout entry where the GHC one did a bunch of reversions using a circular technique that was pretty clever
09:17:09 <SamB> I mean keeping array 0 in the IntMap with everything else can't be fast...
09:17:21 <shapr> roconnor: Is that circular technique related to value recursion, as in fix, mdo, etc?
09:17:24 <musasabi> roconnor: I believe the most important thing with cyclic programming is usually "how to make the notation so simple that it is easy to read and programmers don't create buggy code with it".
09:17:54 <roconnor> shapr: I don't use mdo, even though I use monads and circular programming. ... I didn't even know about it.
09:18:21 <musasabi> and for that an article explaining how to do things the right way would be very nice.
09:18:38 <shapr> http://www.cse.ogi.edu/PacSoft/projects/rmb/recdo.pdf ?
09:18:42 <roconnor> I use the RWS monad, which isn't a MonadFix AFAIK
09:18:48 <shapr> "A recursive do for Haskell"
09:19:55 <xerox> dcoutts_: each package has exacly one tarball, right?
09:19:59 <SamB> @hoogle RWS
09:20:00 <shapr> anyway, reboot time, brb
09:20:01 <lambdabot> Control.Monad.RWS :: module
09:20:01 <lambdabot> Control.Monad.RWS.RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
09:20:01 <lambdabot> Control.Monad.RWS.RWS :: newtype RWS r w s a
09:20:23 <SamB> @instances-importing Control.Monad.RWS MonadFix
09:20:28 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:20:39 <SamB> roconnor: sure it is!
09:20:50 <dcoutts_> xerox, yes
09:21:13 <SamB> incidentally, what is the point of RWS...
09:21:14 <dcoutts_> xerox, do different versions get their own dirs? or are multiple versions in one file?
09:21:20 <SamB> @docs Control.Monad.RWS
09:21:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html
09:21:32 <dcoutts_> dcoutts_, err I mean multiple versions in one dir
09:21:37 <roconnor> ah, maybe I can improve my code.
09:21:39 <dmhouse> SamB: this:
09:21:45 <xerox> dcoutts_: good questions
09:21:47 <xerox> -s
09:21:48 <dmhouse> @kind Control.Monad.RWS.RWST
09:21:50 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
09:21:52 <dmhouse> SamB: :)
09:22:02 <SamB> um.
09:22:04 <SamB> no.
09:22:08 <dcoutts_> xerox, some file systems do not deal well with 1000's of entries in a directory
09:22:24 <dcoutts_> xerox, so it might be better to split by package/version
09:22:30 <SamB> dcoutts: it depends on the tuning as well, I think
09:22:42 <dcoutts_> though, most modern systems are ok I believe
09:22:47 <dcoutts_> SamB, true
09:22:59 <xerox> dcoutts_: looks like currently there are directories with more than one cabal file, but every directory has exactly one tar.gz
09:23:17 <dcoutts_> xerox, oh, multiple .cabal files, hmm
09:23:26 <xerox> -rw-r--r--   1 paolo  paolo    1576 Jul 28 18:03 HaXml-1.12.cabal
09:23:27 <xerox> -rw-r--r--   1 paolo  paolo    1634 Jul 28 18:03 HaXml-1.13.cabal
09:23:27 <xerox> -rw-r--r--   1 paolo  paolo  435809 Jul 28 18:03 HaXml-1.13.tar.gz
09:23:31 <xerox> I wonder what's the purpose.
09:23:36 <dcoutts_> ah well that's just broken
09:23:48 <xerox> Let's assume 1-to-1 then?
09:23:49 <dcoutts_> it's missing HaXml-1.12.tar.gz
09:23:54 <xerox> No, okay.
09:24:12 <SamB> haddock output looks awful in ELinks...
09:24:15 <xerox> OK, more smartness for the index creator needed.
09:24:50 <xerox> ?hoogle catch
09:24:51 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
09:24:51 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
09:24:51 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
09:26:02 <dcoutts_> xerox, there's also handle which is like catch but with args the other way around
09:26:08 <dcoutts_> which is more convenient sometimes
09:26:12 <xerox> Heh, I was just defining it myself.
09:26:16 <dcoutts_> ?hoogle handle
09:26:17 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
09:26:17 <lambdabot> System.IO.Handle :: data Handle
09:26:17 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
09:26:20 <xerox> ?docs Control.Exception
09:26:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
09:26:24 <xerox> Thanks.
09:26:57 <dcoutts_> catch action handler, or handle handler action
09:27:03 <xerox> Yup.
09:27:11 <roconnor> mdo makes an infinite sequence.
09:27:15 <dcoutts_> handle hander $ do ...
09:27:21 <xerox> handle handles error, right?
09:27:24 <roconnor> sorry
09:27:32 <roconnor> mfix makes an infinite sequence?
09:27:39 <xerox> I'm going to use |handle (return Nothing) $ do ...|.
09:28:03 <xerox> ?type mfix
09:28:05 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
09:28:05 <dcoutts_> xerox, that's ok for now, but you'll want to print/collect errors at some point
09:28:16 <SamB> @where um
09:28:17 <lambdabot> I know nothing about um.
09:28:33 <dmhouse> roconnor: just like fix, yes.
09:28:33 <xerox> dcoutts_: Oh-uhm, this means error "foo" will not BOTH print foo and return Nothing?
09:28:53 <SamB> xerox: what?
09:29:03 <SamB> you expect them to print before you handle them?
09:29:16 <xerox> Point.
09:29:27 <SamB> how would you be able to, e.g., prepend your VM's IP to them if that happened?
09:29:47 <dmhouse> @type let mfix m = do x <- m; mfix (m x) in mfix
09:29:48 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
09:29:48 <lambdabot>    Expected type: t1 -> t
09:29:53 <dcoutts_> xerox, you want to use fail not error
09:30:03 <dcoutts_> or throw
09:30:17 <dcoutts_> throwIO I mean
09:30:47 <xerox> ?type fail
09:30:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:31:07 <xerox> > fail "foo" :: Maybe Int
09:31:09 <lambdabot>  Nothing
09:31:20 <xerox> > handle -- test
09:31:20 <lambdabot>  Not in scope: `handle'
09:31:44 <dcoutts_> handleJust userErrors (return . Right) $ fmap Right $ do ...
09:31:48 <dcoutts_> err
09:31:51 <dcoutts_> handleJust userErrors (return . Right) $ fmap Left $ do ...
09:32:15 <dcoutts_> @type handleJust userErrors (return . Right) $ fmap Left $ return ()
09:32:16 <lambdabot> Not in scope: `handleJust'
09:32:16 <lambdabot>  
09:32:16 <lambdabot> <interactive>:1:11: Not in scope: `userErrors'
09:32:33 <dcoutts_> @type Control.Exception.handleJust Control.Exception.userErrors (return . Right) $ fmap Left $ return ()
09:32:34 <lambdabot> IO (Either () String)
09:32:51 <musasabi> Generally mdo is easier to use than mfix (although mdo is implemented in terms of mfix)
09:33:40 <dcoutts_> xerox, so if you do it like that, then inside you just return the result or fail "message"
09:33:45 <xerox> dcoutts_: would it be alright if I make the handler print warning slike "skipping pakage x, missing tarball" ?
09:34:17 <dcoutts_> xerox, yeah you can print the error then and there, or return the whole list and print the errors later
09:34:31 <dcoutts_> I was thinking you'd get [Either Pkg String]
09:35:11 <xerox> I tought about printing it as the process goes on so one has immediate feedback
09:35:25 <dmhouse> Challenge of the day: write something useful involving mapAndUnzipM.
09:35:45 <xerox> dcoutts_: do you think it's worth it to collect Strings? One could recover something?
09:36:05 <dcoutts_> xerox, doesn't matter, it can report errors as it goes either way
09:36:16 <xerox> OK.
09:36:21 <dcoutts_> do whatever seems simplest
09:42:02 <SamB> how does Data.ByteString.Lazy know the L1 cache size?
09:43:44 <lisppaste2> jgrimes_ pasted "Arrows example compile error" at http://paste.lisp.org/display/23295
09:44:24 <int-e> SamB: it doesn't.
09:45:15 <jgrimes_> if anyone wants to take a look at that and tell me whats going on
09:45:30 <jgrimes_> from my new and very limited understanding of Arrows it looks like it should work fine
09:45:45 <dmhouse> jgrimes_: which is the offending line/>?'
09:45:54 <jgrimes_> dmhouse: 30
09:45:57 <dmhouse> Oh, I see it.
09:46:03 <jgrimes_> the error is at the bottom
09:46:04 <jgrimes_> :D
09:46:10 <dmhouse> Yeah, but there are no line numbers on that paste ;)
09:46:15 <jgrimes_> oh
09:46:28 <jgrimes_> there we go
09:47:10 <dmhouse> Hey, wow, you can turn line numbers on! Cool.
09:47:18 <jgrimes_> dmhouse: it is just one of the examples from the Arrows syntax page
09:47:20 <jgrimes_> dmhouse: yep :)
09:49:35 * dcoutts_ just wrote a 1-line haskell version of dos2unix which is more than twice as fast as the C version
09:49:46 <vincenz> dcoutts_: what's it look like
09:49:52 <SamB> that doesn't surprise me, somehow
09:50:03 <SamB> only it must have been two lines
09:50:11 <SamB> because the first line must have been an import
09:50:17 <vincenz> three
09:50:21 <vincenz> you got module declaration
09:50:21 <dcoutts_> a well ok
09:50:26 <SamB> oh, okay, one for a space too
09:50:26 <dcoutts_> no need for that
09:50:36 <SamB> so three lines ;-)
09:51:18 <dmhouse> dos2unix?
09:51:37 <dcoutts_> actually, I'm cheating because it's using somewhat specialised function in the library
09:51:50 <zarvok> dmhouse: it's a unix command that converts dos style end-of-lines to unix style
09:52:00 <Lemmih> @tell bringert Using the multi-threaded FastCGI API works with lighttpd.
09:52:01 <lambdabot> Consider it noted.
09:52:09 <petekaz> Is it true that Simon Peyton Jones is an "active" ocaml user?
09:52:16 <xerox> Lemmih: cool :-)
09:52:37 <dmhouse> dcoutts_: What was this one line then?
09:52:40 <dcoutts_> though a universal line converter is generally useful so it's not too unfair to add to a string + IO lib
09:52:51 * dmhouse can't think of a pretty way of doing it, and you probably used ByteStrings anyway.
09:53:03 <xerox> dmhouse: use interact :-)
09:53:12 <dmhouse> Huh?
09:53:16 <dmhouse> ?type interact
09:53:17 <lambdabot> (String -> String) -> IO ()
09:53:21 * dmhouse fails to see how that helps
09:53:37 <dcoutts_> main = interact translateEOL
09:53:59 <dcoutts_> where translateEOL is from the lib and converts CR to LF and CRLF to LF
09:54:10 <dcoutts_> which copes with mixed dos/mac/unix text files
09:54:14 <dmhouse> Oh, well that's _definitely_ cheating :)
09:54:15 <dcoutts_> I think
09:54:23 <dcoutts_> well python would do the same
09:54:23 <xerox> Why?
09:54:32 <dcoutts_> it's got such a filter in its standard lib
09:54:44 * dmhouse thought you'd actually written the line endings converter, rather than just wrapped it
09:54:45 <xerox> (I mean, why is that cheating?)
09:54:47 <dmhouse> But hey.
09:55:28 <xerox> It needs some thinking and pattern matching :-)
09:55:37 <dcoutts_> dmhouse, the code in the lib is 10 lines
09:55:55 <dmhouse> @karma+ Haskell
09:55:56 <lambdabot> Haskell's karma raised to 6.
09:56:10 <dmhouse> I'm impressed it's faster than C's.
09:56:26 <dcoutts_> translateEOL = strTransformerUp translateEOLS, where translateEOLS :: Stream -> Stream is the thing that does the buisness
09:56:27 <jgrimes_> one step closer to having a complete set of userland tools written in haskell :)
09:56:53 <dmhouse> And I suppose that's not even using ByteStrings? Or is that a ByteString interact?
09:56:54 <xerox> @where hash
09:56:54 <lambdabot> I know nothing about hash.
09:57:03 <xerox> How's that called...
09:57:04 <dmhouse> @where h4sh
09:57:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
09:57:32 <xerox> Check that out, jgrimes_ :-)
09:59:02 <jgrimes_> xerox: awesome
10:00:31 <dcoutts_> dmhouse, that's with ByteString's interact
10:00:33 <astrolabe> dons is a student ?!
10:00:47 <dcoutts_> astrolabe, a PhD student
10:01:00 <astrolabe> wow
10:01:17 <astrolabe> I assumed he was a professor.
10:01:21 <dcoutts_> hah
10:01:41 <SamB> the difference is not that big, is it?
10:01:43 <dcoutts_> @tell dons astrolabe assumed you were a professor. :-)
10:01:44 <lambdabot> Consider it noted.
10:02:23 <SamB> Isn't a PhD student a professorling?
10:02:27 <zarvok> haha
10:02:59 <astrolabe> I guess I haven't known any PhD students that I know turned into professors, so I don't know if they changed, or were like it all along.
10:04:26 <vincenz> zarvok: you a phd student?
10:04:47 <vincenz> astrolabe: assumed who is a professor?
10:05:00 <vincenz> ah dons
10:05:02 * vincenz missed the line
10:07:36 <zarvok> vincenz: no, an undergrad
10:08:20 <SamB> hey, if the unpacked codex doesn't ever use SMC, couldn't you compile the whole thing to C?
10:08:21 <zarvok> though with some luck maybe I'll be one this time next year :)
10:08:55 <vincenz> zarvok: what field you going for?
10:09:08 <SamB> oh, maybe not.
10:09:11 <zarvok> PL/type theory/logic
10:09:17 <zarvok> somewhere in there
10:09:58 <zarvok> with luck I'll get into the PL group at CMU
10:09:59 <SamB> you'd need to generate a switch statement with as many cases as there are words in the upacked codex...
10:10:07 <zarvok> though that's much easier said than done
10:11:05 <zarvok> vincenz: how about you?
10:11:17 * vincenz is phd student
10:11:22 <vincenz> at least that's what my title says
10:11:28 <zarvok> heh
10:11:39 <zarvok> studying what?
10:11:41 <vincenz> oh
10:11:56 <vincenz> data optimizations for multimedia applications on embedded devices
10:12:06 <SamB> vincenz: did you forget?
10:12:32 <vincenz> SamB: forget what?
10:12:47 <SamB> nevermind, I guess that just takes a while to type
10:12:54 <vincenz> yeah
10:12:55 <vincenz> sorta
10:12:56 <zarvok> haha
10:13:34 <zarvok> vincenz: yeah, I don't know, I have some ins at the CMU POP group now, so I'm hoping to get into grad school here.  I'll apply in the fall
10:13:57 * vincenz would like to work more in the PL field tho
10:14:56 <zarvok> where do you go to school vincenz?
10:15:05 <Numbers> PL?
10:15:13 <zarvok> programming languages
10:15:19 <Numbers> Ahhh
10:15:24 <vincenz> zarvok: well KULeuven, but my researchc is being done at an electronics research center: www.imec.be
10:15:25 <Numbers> We dont' need any more.
10:15:39 * vincenz 's background is EE and slowly he keeps hsifting more and more towards CS
10:15:40 <zarvok> heh
10:15:45 <zarvok> vincenz: cool
10:16:04 <vincenz> I should've done CS :P
10:16:41 <astrolabe> We don't need any more politicians, but we need better ones
10:18:16 <xerox> dcoutts_: normally cabal files are named name.cabal, not name-version.cabal, right?
10:18:25 <dcoutts_> xerox, yes
10:18:49 <xerox> And we need multiple versions of the same package in the index?
10:18:55 <dcoutts_> yes
10:19:19 <xerox> OK.
10:19:26 <dcoutts_> for the server dir layout it'd be ok to have multiple .cabal files in a dir with different version numbers
10:19:39 <xerox> I've to rename them, right.
10:19:45 <dcoutts_> right
10:20:06 <dcoutts_> inside the .tar.gz it'll be without the version since it's annoying to have to rename files when the version changes
10:20:20 <xerox> Makes sense.
10:20:41 <dcoutts_> xerox, it's my personal opinion that hackage should do some minimal QA checks on the .tar.gz
10:20:50 <dcoutts_> for example they should be named consistently
10:21:12 <dcoutts_> and the contents of the .tar.gz should unpack to a dir with the same name
10:21:29 <xerox> Right, I thought that put should check that.
10:21:29 <dcoutts_> eg foo-1.0.tar.gz should unpack to foo-1.0/*
10:21:51 <dcoutts_> and the names should be equal case-sensitively
10:21:58 <xerox> Yes.
10:22:16 <xerox> Should I do this check both in put and create-index ?
10:22:18 <dcoutts_> and the tarball name should match the Cabal package name given inside the .cabal file
10:22:31 <xerox> (Right, again, case-sensitively.)
10:22:37 <dcoutts_> xerox, put it probably enough for checks that need unpacking the .tar.gz
10:22:55 <dcoutts_> you don't want to have to unpack every .tar.gz when generating the index
10:23:08 <xerox> I just want to extract cabal files
10:23:15 <dcoutts_> xerox, eg some packages like to call themselves one thing but the Cabal package is called something else!
10:23:26 <dcoutts_> xerox, eg haxr is actually xml-rpc
10:23:33 <xerox> Oh-uhm.
10:23:43 <dcoutts_> the .cabal file specifies xml-rpc
10:23:55 <dcoutts_> but the tarball is haxr-x.y.tar.gz
10:24:01 <dcoutts_> we should just ban that
10:24:14 <dcoutts_> if it wants to be in the database then it can conform
10:24:38 <xerox> (I started with the assumption that put creates the hierarchy as package/package-version.tar.gz checking names case-sensitively.)
10:24:58 <dcoutts_> right, that's reasonable
10:25:39 <dcoutts_> and then checks that the name inside the .cabal file matches the name of the cabal file and indeed the package and the dir it unpacks to
10:25:42 <xerox> Also, I am extracting the cabal files every time....
10:25:52 <xerox> Is it too much of overhead?
10:25:55 <dcoutts_> ideally only need to do that on put
10:26:07 <xerox> OK.
10:26:14 <dcoutts_> so if the .cabal file for the .tar.gz exists then no need to unpack the .tar.gz
10:26:32 <xerox> This simplifies things, I only have to check for cabal files, not tarballs.
10:26:39 <dcoutts_> or perhaps for safety you should compare timestamps of the .tar.gz and the corresponding .cabal file
10:26:57 <dcoutts_> so the .cabal file is a sort of cache of the info in the .tar.gz
10:27:12 <SamB> wow, I can't believe that worked
10:27:16 <xerox> ....in `put', right?
10:27:23 <SamB> I just solved Puzzle 7 with only two kinds of ants...
10:27:42 <zarvok> which is puzzle 7, samb?
10:27:44 <dcoutts_> xerox, so how are you splitting the work between the reindexing and put
10:27:46 <SamB> and they were getting badly mangled, too!
10:28:01 <SamB> zarvok: puzzle7.ant in /home/gardener
10:28:18 <zarvok> SamB: heh, I know, I meant the name, but never mind
10:28:25 * zarvok goes looking for the reference solution
10:28:30 <SamB> Puzzle 7: Threshing Machine
10:28:34 <SamB> reference solution?
10:28:59 <zarvok> ah, I was on the organizing team, we solved all the ant puzzles ahead of time
10:29:07 <xerox> dcoutts_: create-index uses only cabal files, I might add a check (hence a warning) if the corrisponding tarball is missing.  put checks for naming issues, and extracts the cabal file, renaming it properly.  No idea about the timestamp.
10:29:08 <SamB> oh right
10:29:21 <dcoutts_> xerox, is put a seperate application? I thought you just did scp and then reindex
10:29:33 <dcoutts_> xerox, it could all be done in re-index
10:29:37 <dmhouse> Argh, I just used /me on MSN and didn't even notice that it didn't work.
10:29:52 <dcoutts_> xerox, ie just cp (or scp) and reindex
10:29:54 <xerox> dcoutts_: that was my first trouble, Isaac talks of a "put program, as implemented here"
10:29:59 <zarvok> SamB: haha, our refernece solution was generated by a solver and uses like 9 kinds of ants
10:30:11 <zarvok> could probably be cleaned up, but 2 sounds impressive
10:30:20 <SamB> zarvok: 5 of those are predetermined
10:30:29 <SamB> er, 4
10:30:31 <dcoutts_> xerox, because you can tell when there is a new prog because there is no corresponding .cabal file, or the .cabal file is older than the .tar.gz
10:30:53 <zarvok> ah, right, I remember now
10:31:00 <SamB> I only used 2 out of 5 of the slots for writing your own
10:31:01 <dcoutts_> so you could do the unpacking in reindex if the .cabal file is old or missing
10:31:05 <xerox> dcoutts_: Alright, I see what you mean.
10:31:21 * xerox takes some notes
10:31:26 <dcoutts_> xerox, then put is just cp to the right dir and run re-index
10:31:37 <SamB> let me paste it
10:31:52 <zarvok> SamB: yeah, please do
10:32:02 <zarvok> SamB: I'm guessing a bunch of pairs of the half-speed walkers?
10:32:10 <SamB> zarvok: no
10:32:26 <zarvok> hmm
10:32:30 <dcoutts_> xerox, then put is dead simple and you don't really need a put app, it can be a script or manually or a web upload thingie
10:32:47 <SamB> I tried that but they got tangled up together, plus they went around in circles after colliding with the 1s
10:32:56 <zarvok> ah
10:33:04 <xerox> dcoutts_: the naming issues slow the index recreation, though
10:33:26 <SamB> I suppose I could have tried using some of the predefined ants, but I didn't really think of it
10:33:57 <dcoutts_> xerox, but you only need to unpack the new .tar.gz files, so for existing packages you just read the .cabal files
10:33:58 <SamB> (anyway, isn't it more fun to just write make my own?)
10:34:06 <zarvok> SamB: yeah, I don't know.  The solution I have uses all 9 ant patterns and fills every * with an ant
10:34:09 <xerox> dcoutts_: right, it's incremental!
10:34:13 <dcoutts_> yes
10:34:17 <xerox> Cool :-)
10:34:23 <SamB> heh
10:34:27 <zarvok> well, except for 3 or 4
10:34:30 <vincenz> SamB: paste!
10:35:09 <dcoutts_> xerox, I might even be tempted to only look for new files in a special dir, eg ./incomming/*.tar.gz
10:35:28 <dcoutts_> rather than having 'put' put them in the right place
10:35:30 <lisppaste2> SamB pasted "puzzle 7 solution" at http://paste.lisp.org/display/23299
10:35:35 <xerox> dcoutts_: interesting.
10:35:42 <dcoutts_> xerox, so you only mv the .tar.gz after it's passed the QA tests
10:36:11 <SamB> zarvok: 3 is used in the problem
10:36:47 <dcoutts_> xerox, so that's another possability, that splits it into two phases again,  unpacking,checking,etc and re-indexing
10:37:03 <xerox> dcoutts_: I was thinking about adding command line options now
10:37:07 <zarvok> SamB: I meant to say only 3 or 4 of the * spaces are left without ants :)
10:37:16 <SamB> oh, oh
10:37:19 <xerox> dcoutts_: cabal-server import; cabal-server reindex
10:37:32 <xerox> Or something along the lines.
10:37:57 <dcoutts_> xerox, sounds reasonable
10:38:34 <xerox> I'm liking it.
10:38:40 <dcoutts_> xerox, if I were you, I'd impose another restiction: Cabal packages must be unique comparing names *case-insensitively*. So no "Foo" and "foo".
10:38:56 <SamB> anyway, these are full-speed walkers that turn west or east upon running into an ant going the opposite direction
10:39:04 <dcoutts_> xerox, that's a new restriction but I think in the end we'll need it
10:39:06 <SamB> that is, left or right...
10:39:11 <jgrimes_> is there any way to see what the haskell output would be after desugaring arrows syntax with ghc?
10:39:11 <xerox> dcoutts_: I see.
10:39:11 <zarvok> SamB: yeah, it's pretty
10:39:27 <dcoutts_> xerox, eg many linux distros change package names to lower case, so you'd get clashes
10:39:38 <xerox> Oh, good point.
10:40:03 <dcoutts_> xerox, and also, ghc is probably going to change to using a directory of package files named by the package name, rather than one centeral file with all packages listed
10:40:13 <dcoutts_> and if you do that on windows...
10:40:22 <SamB> if you are wondering why I skipped two slots, I had the half-speed movers there but they somehow killed these guys so I got rid of 'em.
10:40:30 <dcoutts_> xerox, then it requires the names to not clash case-insensitively
10:40:40 <xerox> dcoutts_: OK, noted.
10:40:46 <dcoutts_> so best to make sure people don't start making clasing packages now
10:40:51 <xerox> I've got a lot of post it on the wall now :-)
10:40:56 <dcoutts_> hah
10:40:59 <Maddas> Yow!
10:41:00 * dcoutts_ will shut up now
10:41:23 <xerox> No please, it's wonderful!
10:41:45 <SamB> did everyone solve "Puzzle 5: Basketball" with a couple pairs of the half-speed movers?
10:42:21 <zarvok> SamB: that's how I solved it
10:42:25 * xerox now wants a blackboard
10:42:44 <dcoutts_> xerox, well if you have any more Qs...
10:42:52 <Maddas> What's the discussion about, if I may ask?
10:42:55 <xerox> dcoutts_: I'm trying to reorganize the ideas now
10:42:59 <dcoutts_> I'm happy to spout opinions :-)
10:43:11 <zarvok> Maddas: which one? :)
10:43:13 <xerox> Well, what about the name cabal-server ?
10:43:16 <SamB> how about puzzle 3? did everyone use a pair of half-speeds and an ant set to turn left when it hit them?
10:43:21 <dcoutts_> xerox, sounds fine
10:43:30 <Maddas> zarvok: any :-P
10:43:41 <dcoutts_> xerox, I like cabal-server import; cabal-server (re)index
10:43:43 <Maddas> (Puzzles sound like fun :-)
10:43:45 <xerox> Maddas: we are discussing the server part of the cabal architecture
10:43:58 <xerox> dcoutts_: yeah, I come up with those just now, good.
10:44:00 <Maddas> Ok
10:44:07 * SamB hasn't figured out puzzle 4 yet
10:44:08 <zarvok> Maddas: the puzzles in question are from the recent ICFP contest : www.icfpcontest.org
10:44:13 <zarvok> SamB: I think so
10:44:15 <xerox> (I had to rewrite "good" three times because I was writing "food" ...)
10:44:27 <Maddas> Argh, I missed it again. Thanks.
10:44:33 <SamB> also pick a UM implementation from http://www.cse.unsw.edu.au/~dons/um.html
10:44:33 <lambdabot> Title: Haskell UM
10:44:43 <SamB> (Which also has some C and C++ UMs)
10:45:00 <ski> (falconair_ : 'MVar's are only partially related to logic/dataflow vars,  .. maybe one could say that the former is roughly an updateable variant of the latter)
10:45:10 <SamB> I suggest edwardk's, it doesn't segfault when you don't pass it a codex
10:45:17 <SamB> (mine does)
10:45:26 * Maddas reads up
10:46:02 <xerox> dcoutts_: maybe we could have incoming/ and pub/
10:46:10 <dcoutts_> xerox, aye
10:46:53 <SamB> so, about how many ants does it take to solve puzzle 4?
10:47:00 <dcoutts_> xerox, I'd love for the cabal server to be a QA gateway :-)
10:47:09 <xerox> What does QA mean?
10:47:17 <xerox> Quality Assurance?
10:47:19 <dcoutts_> Quality Asurance
10:47:21 <dcoutts_> yeah
10:47:26 <xerox> Right, I'll do lots of checks
10:47:30 <dcoutts_> xerox, so as a package goes from incoming to pub it gets checked
10:47:34 <xerox> I think I wrote them all up, on the wall, now
10:47:41 * xerox nods
10:47:46 <SamB> oh hmm just got an idea
10:47:47 <dcoutts_> I keep thinking I should do a cabal lint program
10:47:52 <zarvok> SamB: it's no fun if I tell you :)
10:48:11 <dcoutts_> because as a Gentoo packager person I see many dodgy cabal packages
10:48:28 <dcoutts_> many of the mistakes or little annoynaces could be caught automatically
10:48:48 * xerox is reminded of monochrom's task T :-)
10:48:55 <dcoutts_> task T?
10:49:13 <xerox> Let me find it in the logs :-)
10:49:37 <xerox> <monochrom> For every task T that we now all agree should be left to the computer, there exists a time t in the past such that at least half of the people at t thought T was not hard and they did T all the time.
10:50:02 <SamB> zarvok: I'm just trying to think if I need a ton of ants or just two or 3 ;-)
10:50:06 <xerox> :-)
10:50:24 <zarvok> SamB: more than 2 or 3, less than a ton
10:50:48 <dcoutts_> xerox, heh, that's nice
10:51:14 <xerox> @remember monochrom For every task T that we now all agree should be left to the computer, there exists a time t in the past such that at least half of the people at t thought T was not hard and they did T all the time.
10:51:14 <lambdabot> Done.
10:51:20 <xerox> =)
10:51:29 <xerox> dcoutts_: I really like the incoming idea
10:51:34 <xerox> Now I can plan from the grounds what happens
10:51:37 <dcoutts_> cool
10:52:01 <dcoutts_> xerox, it's a good idea to keep unchecked packages seperately from the published ones
10:52:25 <xerox> For this naming issues
10:52:34 <xerox> One could even try to fix them, asking the user....
10:52:58 <dcoutts_> xerox, by untaring and re-taring you mean
10:53:14 <dcoutts_> I think it's better to make the author fix it
10:53:22 <dcoutts_> then the'll do it right in general
10:53:26 <dcoutts_> cabal does make it easy
10:53:29 <xerox> So simply fail on import?
10:53:30 <dcoutts_> setup sdist
10:53:38 <dcoutts_> so there's no excuses I think
10:53:44 <xerox> OK :-)
10:53:49 <dcoutts_> xerox, for now, I'd say yes, just fail
10:54:00 <dcoutts_> for that package at least
10:54:14 <dcoutts_> perhaps move it to rejected/ :-)
10:54:14 <xerox> I always stuck myself in corner cases and I need feedback... does it happen to you when you code? :-|
10:54:25 <dcoutts_> sometimes
10:54:27 <xerox> And print a blue screen of death :-P
10:54:34 <dcoutts_> heh
10:54:59 <dcoutts_> this is a tricky issue since it's so connected to other issues and progs / systems
10:55:56 <xerox> I'm trying to use Distribution.Compat.FilePath whenever possible
10:56:01 <xerox> (For one)
11:01:21 <Maddas> :-)
11:04:03 <Maddas> SamB: heh, it's quite interesting to see the large difference in code size for the various C/C++ implementations
11:08:31 * xerox waves to bringert 
11:08:48 <bringert> morning xerox
11:08:48 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
11:08:49 <xerox> FastCGI works on lighttpd
11:08:53 * xerox beats lambdabot 
11:09:28 <bringert> lemmih just told me through lambdabot
11:09:56 <xerox> hehe, yes, that's why I beat lambdabot =P
11:13:00 <bringert> ah
11:13:51 <bringert> so, does it allow serving multiple requests simultaneously?
11:14:18 * bringert is eating breakfast in microsoft's cafeteria
11:14:25 <xerox> No idea, ask Lemmih :-)
11:14:32 <xerox> Oh.
11:18:23 <alar> I've heard of someone's making fast UM in haskell
11:18:41 <alar> can't wait to see how it is possible
11:18:53 <dmhouse> @where u
11:18:53 <lambdabot> I know nothing about u.
11:18:54 <dmhouse> @where um
11:18:54 <lambdabot> I know nothing about um.
11:19:03 <dmhouse> alar: sjanssen I believe holds the current Haskell record.
11:19:06 <mejja> http://www.cse.unsw.edu.au/~dons/um.html
11:19:07 <lambdabot> Title: Haskell UM
11:19:12 <sjanssen> my ears are burning
11:19:15 <dmhouse> @where+ um http://www.cse.unsw.edu.au/~dons/um.html
11:19:15 <lambdabot> Done.
11:19:41 <sjanssen> I really should clean up that code, people seem interested
11:19:55 <sjanssen> and the sloppiness is slightly embarassing
11:19:55 <zarvok> heh, it is pretty gross
11:20:03 <zarvok> :)
11:20:31 <zarvok> although since it's much faster than the other haskell UMs, I don't think anyone is too worried about it
11:21:58 <dmhouse> I think we should email Bulat Zagawhatshisname, he'd likely be interested.
11:22:53 <alar> dmhouse: thanks, that's exactly what I've heard of
11:23:23 <dmhouse> Ziganshin.
11:23:59 <alar> sjanssen: thanks to you too
11:30:22 <bringert> heh, I just realized that I'm sitting in Microsofts cafeteria, *using a Mac*
11:30:58 <alar> sjanssen: what can
11:30:58 <alar> ghc3990.hc:(.text+0x56): undefined reference to `__stginit_ControlziMonadziState_'
11:31:01 <sjanssen> oh no, somebody got bringert
11:31:01 <alar> mrean?
11:31:02 <edwinb> oops, look like MS spotted it...
11:31:04 <alar> mean
11:31:20 <Igloo> alar: Use -package mtl
11:31:31 <Igloo> (or --make)
11:32:18 <rictic> Any advice on debugging stack overflows with ghc?  I've built a parser that seems to overflow whenever it gets a well formed string
11:32:38 <alar> Igloo: thanks, with --make it works
11:33:02 * Numbers hugs --make
11:33:23 <Numbers> Oh.   Does anyone have a build of wxHaskell at the current ghc version?
11:33:30 <Numbers> The binary on eon tehir site is 6.4.0
11:33:49 <Igloo> rictic: Even a tiny one? If so, you probably have a left recursive grammar, so you will need to eliminate the recursion
11:34:37 <dmhouse> Igloo: shouldn't alar's linking error be caught before the linker?
11:34:38 <Igloo> rictic: e.g.   A = A B | C   if asked to make an A will first try to make an A, will first try to make an A, will ...
11:35:08 <rictic> I have something like that going on, but it's wrapped in a try, which I thought would help
11:35:40 <Igloo> dmhouse: It is a bit inconsistent, yeah
11:36:06 <Cale> chainl is usually helpful in those circumstances
11:37:21 <rictic> http://rafb.net/paste/results/hs1RYy68.html Ok, um, I think I've narrowed it down to the first parser in that series of ors.
11:37:49 <Igloo> try won't help
11:38:17 <rictic> Wait.... ok, I see why
11:38:47 <Igloo> It only increases the amount of work that can be done, by allowing backtracking
11:38:55 <rictic> Heh, I feel dumb, not enough sleep.  Thanks :)
11:39:36 <Igloo> np
11:42:12 <dmhouse> What are some good example usages of continuations? I have exceptions. Anything else?
11:42:49 <dmhouse> I'd like something that is actually useful, not just pedagogical.
11:43:48 <rictic> Why would I ever get an exception thrown by read (no parse) with this code:
11:43:49 <rictic>   do s <- many (oneOf "0123456789")
11:43:49 <rictic>                 return $ read $ s
11:44:15 <rictic> dmhouse: Seaside keeps track of session state in a web app with continuations I think
11:44:24 <dmhouse> rictic: that indentation doesn't look right.
11:44:33 <Igloo> Are you sure the correct type is being inferred?
11:44:40 <dmhouse> do s <- many (oneOf "0123456789")
11:44:41 <rictic> pretend that the indentation is right (pasting error)
11:44:44 <dmhouse>    return (read s)
11:44:57 <Igloo> Oh, you want many1 or something don't you?
11:45:08 <Igloo> (require at least one of them)
11:45:17 <dmhouse> > read []
11:45:22 <lambdabot>  Add a type signature
11:45:23 <rictic> Ahhhhh, yes.  Ok, with that I'll stop asking dumb questions
11:45:29 <dmhouse> > read ""
11:45:30 <lambdabot>  Add a type signature
11:45:30 <Igloo> (or use read ("0" ++ s) if you really want to allow none)
11:45:43 <dmhouse> > read "" :: Int
11:45:45 <lambdabot>  Exception: Prelude.read: no parse
11:45:48 <dmhouse> Yep. :)
11:45:53 <rictic> There it is :)
11:46:17 <dmhouse> rictic: seaside? Is it a Haskell app?
11:46:22 * Igloo new the read would fail, I just can't remember what parsec provides OTTOMH  :-)
11:46:33 <rictic> dmhouse: It's a smalltalk framework I believe
11:46:56 <rictic> dmhouse: There's even a neat and powerful production app using it: dabbledb.com
11:47:01 <dmhouse> Ah, well, I'd prefer Haskell examples, really.
11:47:22 <dmhouse> I gather use of continuations within Haskell is somewhat different to other languages.
11:47:30 <dmhouse> (I.e., they're used less.)
11:47:38 <dmhouse> Also, does Smalltalk even have a call/cc?
11:49:56 <rictic> dmhouse: I couldn't really tell you.  As I understand it, in smalltalk the continuations are objects representing the current state of the whole smalltalk environment, but that's from just skimming.  I've meant to learn Seaside for months now but haven't gotten around to it
11:50:11 <rictic> I do think they have a call/cc
11:51:26 <sjanssen> @keal
11:51:27 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
11:51:32 <Cale> dmhouse: Continuations are usually harmful to the readability of programs.
11:52:13 <Cale> dmhouse: In general, they're like GOTO, but actually worse than that, since you can pass arbitrary data back to wherever you're jumping, and labels are first class.
11:52:18 <dmhouse> Cale: I realise that. Are there _any_ times where they're useful, or indeed elegant?
11:52:39 <dmhouse> Cale: yes, I think I finally understand continuations :) I'm writing the wikibook module on them.
11:53:26 <jgrimes_> the Understanding arrows wikibook module is good
11:53:46 <Cale> Well, there are possibly some nice applications of ContT. I think it's better to not use continuations directly, but dilute their power via some interface.
11:54:15 <zarvok> dmhouse: well, they are certainly interesting theoretically, if nothing else.  First class continuations are basically the difference between constructive and classical logic in terms of curry-howard
11:54:32 <Cale> That is, construct a new monad from ContT, don't derive MonadCont for it, but use the fact that you have the current continuation to get restricted kinds of special effects.
11:54:44 <zarvok> so, for example, we could write a term the proves LEM using continuations in haskell, but not without them
11:55:17 <zarvok> plus they are pretty!
11:55:18 <zarvok> :)
11:55:19 <dmhouse> zarvok: Wow, fun :)
11:55:28 <emertens> LEM?
11:55:32 <dmhouse> Cale: don't suppose you've got some actual code lying around?
11:55:35 <dmhouse> Law of excluded middle.
11:55:40 <Cale> Law of the Excluded Middle
11:55:44 <dmhouse> Something is either true or false.
11:55:48 <emertens> oh, now it's clear ;)
11:55:55 <dmhouse> (Or bottom. :))
11:56:03 <zarvok> heh
11:56:14 <emertens> I'll give the wikipedia article a read
11:56:25 <Cale> dmhouse: I've never used ContT in a particularly constructive way. There are some interesting functions which really should be in the library though which you should see.
11:56:48 <dmhouse> Cale: I've seen your getCC and getCC'.
11:57:09 <dmhouse> (I say 'your' because you first showed them to me.)
11:57:40 <Cale> oh, okay
11:57:42 <dmhouse> They work through sheer black magic, as far as I'm concerned.
11:57:46 <Cale> hehe
11:57:56 <dmhouse> (Finding the fixpoint of the current continuation? Err... Riiight.)
11:58:38 <alar> finding fixpoint of continuation? 8-o
11:59:00 <Cale> getCC = callCC (\c -> let x = c x in return x)
11:59:51 <dmhouse> But then, I haven't taken the time to understand _any_ of Cont's internals. I've only just figured out what it does.
12:01:01 <Cale> It's a little bit like  getCC = callCC (\c -> return c)  except that doesn't typecheck :)
12:01:17 <jgrimes_> are Arrows implemented in any other languages?
12:01:20 <dmhouse> So we throw in a fix for effect.
12:01:33 <musasabi> http://www.cse.ogi.edu/PacSoft/projects/rmb/erkok-thesis.pdf has stuff about about continuations + mfix.
12:01:55 <Cale> dmhouse: If you think about it, it kind of makes sense that a goto is a sort of fixed point.
12:02:34 <dmhouse> Cale: howso?
12:02:56 <Cale> Fixed points are essentially loops
12:03:41 <zarvok> @where djinn
12:03:41 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
12:03:48 <Numbers> @pl getCC = callCC (\c -> return c)
12:03:49 <lambdabot> getCC = callCC return
12:04:12 <dmhouse> @pl getCC = callCC (\c -> let x = c x in return x)
12:04:12 <lambdabot> getCC = callCC (return . fix)
12:04:22 <dmhouse> Ooh, clever @pl :)
12:04:32 <Numbers> Heh
12:06:12 <Cale> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/7688 has some discussion about deriving the correct implementation of getCC from the one which doesn't typecheck
12:06:15 <lambdabot> Title: gmane.comp.lang.haskell.cafe
12:06:44 <emertens> @type callCC (return . fix)
12:06:46 <lambdabot> Not in scope: `callCC'
12:07:00 <Cale> @type Control.Monad.Cont.callCC (return . fix)
12:07:01 <lambdabot> forall (m :: * -> *) b. (Control.Monad.Cont.MonadCont m) => m (m b)
12:08:15 <Numbers> What does the 'forall' stuff at the beginning mean?
12:08:28 <Cale> It's explicitly quantifying the type variables
12:08:35 <Cale> forall a. a -> [a]
12:08:50 <Cale> means that the function will work for all types a.
12:08:52 <musasabi> What is the current dynamic between GADTs and FDs except that they don't work very well together? (and is different in 6.4 and 6.5?)
12:08:52 <emertens> b is a value of any type, m is a constructor that takes one monomorphic type and returns one?
12:08:54 <Numbers> Ahh
12:08:55 <dmhouse> A lot of the time you can just ignore it.
12:09:09 <Numbers> So, it means that m is a function that turns somethig inot something?
12:09:11 <dmhouse> 'a -> [a]' is the same as 'forall. a -> [a]'.
12:09:35 <Cale> Numbers: oh the  m :: * -> *  is a kind declaration for m.
12:09:36 <dmhouse> (Haskell implicitly universally quantifies the type variables.)
12:09:42 <Cale> It means that m is a type constructor
12:09:47 <Numbers> Oooh.
12:09:51 <Cale> takes a type and gives another one
12:09:53 <dmhouse> And it takes one type variable.
12:09:57 <dmhouse> E.g. Maybe.
12:10:04 <Cale> @kind Maybe
12:10:05 <lambdabot> * -> *
12:10:08 <Cale> @kind Integer
12:10:09 <dmhouse> Maybe takes a type (say, Int), and returns another one (in this case, Maybe Int).
12:10:10 <lambdabot> *
12:10:17 <Cale> @kind Maybe Integer
12:10:19 <lambdabot> *
12:10:21 <Numbers> @kind Just
12:10:22 <lambdabot> Not in scope: type constructor or class `Just'
12:10:26 <Numbers> @kind Just Int
12:10:27 <lambdabot> Not in scope: type constructor or class `Just'
12:10:30 <Cale> Just is a data constructor
12:10:34 <Cale> not a type constructor
12:10:35 <musasabi> @kind Maybe
12:10:36 <Numbers> OK..
12:10:36 <lambdabot> * -> *
12:10:37 <emertens> @type Just 1
12:10:38 <lambdabot> forall a. (Num a) => Maybe a
12:10:44 <Cale> @type Just
12:10:45 <Numbers> Ahh.. OK.
12:10:46 <lambdabot> forall a. a -> Maybe a
12:11:01 <xerox> dcoutts_: oh Isaac passed on my first lil patches.
12:11:02 <Numbers> That makes sense now.
12:11:09 <Numbers> @type Nothing
12:11:10 <lambdabot> forall a. Maybe a
12:11:17 <dmhouse> xerox: Yayness!
12:11:44 <dcoutts_> xerox, he's right, email the cabal-devel list! :-)
12:11:50 <emertens> understanding Haskells type system has a learning curve... the kinds, types and classes can be a bit much IMHO
12:12:02 <emertens> and I'm sure I missed a category
12:12:07 <Cale> You can mostly ignore kinds
12:12:28 <xerox> dcoutts_: will do :-)
12:12:41 <Cale> They're generally fairly intuitive, and most things have fairly simple kinds.
12:13:01 <Lemmih> @kind (->)
12:13:02 <lambdabot> ?? -> ? -> *
12:13:02 <xerox> dcoutts_: I wasn't sure about doing it before, I had very near to no code.
12:13:03 <dmhouse> @kind Control.Monad.RWS.RWST
12:13:04 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
12:13:12 <xerox> Oh you discussed callCC, dmhouse ? :)
12:13:16 <dmhouse> Lemmih: well, that's only because of the subkinding.
12:13:22 <dmhouse> xerox: I did indeed. I get it! :)
12:13:22 <dcoutts_> xerox, but it's a good place to ask Qs too
12:13:25 <Cale> those are probably the two worst examples :)
12:13:30 <xerox> dmhouse: please explain!!!
12:13:32 <Numbers> Heh
12:13:41 <dmhouse> xerox: /me is writing the wikibook module as we speak
12:13:49 <Numbers> @hoogle Control.Monad.RWS.RWST
12:13:50 <lambdabot> No matches, try a more general search
12:13:52 <xerox> OK, awesome.
12:13:59 <Numbers> @hoogle RWST
12:13:59 <lambdabot> Control.Monad.RWS.RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
12:13:59 <lambdabot> Control.Monad.RWS.RWST :: newtype RWST r w s m a
12:13:59 <lambdabot> Control.Monad.RWS.evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
12:14:29 <Cale> RWST is a combined Reader, Writer and State monad transformer
12:14:32 <emertens> Cale: what does ?? -> ? -> * mean?
12:14:47 <dmhouse> emertens: read the GHC module on kinds.
12:14:51 <dmhouse> Or let me find it :)
12:15:05 <Cale> emertens: It to do with unboxed values.
12:15:15 <Cale> @kind Int#
12:15:16 <lambdabot> Not in scope: type constructor or class `Int#'
12:15:21 <Cale> er...
12:15:25 <musasabi> Anyone feeling like some shootout coding? The preconverting to Int in fasta got rejected and an alternative Haskell implementation is wanted.
12:15:28 <sjanssen> @kind GHC.Base.Int#
12:15:30 <lambdabot> #
12:15:33 <Cale> yes
12:15:39 <dmhouse> where	*    [LiftedTypeKind]   means boxed type #    [UnboxedTypeKind]  means unboxed type (#)  [UbxTupleKind]     means unboxed tuple ??   [ArgTypeKind]      is the lub of *,# ?    [OpenTypeKind]	means any type at all
12:16:22 <Numbers> Does anyone have a good URL of like Haskell problems for beginners?
12:16:39 <Cale> hmm
12:16:43 <xerox> ?fptools Prelude
12:16:43 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
12:18:35 <Cale> Numbers: anyway, if you ignore unboxed values, you can say that (->) has kind * -> * -> *
12:19:25 <Cale> Note that that's the type constructor (->), and not the kind constructor one -- I don't think anyone bothers with a system of sorts for kinds :)
12:19:40 <xerox> Omega!
12:19:41 <Cale> (At least, not in Haskell)
12:19:51 <xerox> ?type Omega extensible kinds Haskell
12:19:52 <lambdabot> Not in scope: data constructor `Omega'
12:19:52 <lambdabot>  
12:19:52 <lambdabot> <interactive>:1:6: Not in scope: `extensible'
12:20:01 <xerox> Did I really write ?type
12:20:04 <Cale> yes
12:20:07 <xerox> ?google Omega extensible kinds Haskell
12:20:08 <dmhouse> Cale: actually, I read a great paper about 'sorts'. :)
12:20:09 <lambdabot> http://lambda-the-ultimate.org/node/689
12:20:09 <lambdabot> Title: GADTs + Extensible Kinds = Dependent Programming | Lambda the Ultimate
12:20:14 <dmhouse> ^^ that one.
12:20:24 <Cale> yeah
12:20:25 <xerox> That, indeed.
12:20:27 <dmhouse> Well, it wasn't LtU, but it was about a system called 'Omega'.
12:20:27 <Cale> I saw that :)
12:21:12 <xerox> I rememeber a `Nat' kind and megaolegs of fun.
12:23:10 <Cale> dmhouse: Did you see the compose example?
12:23:25 <Cale> or was it you that was writing that page even? I can't recall.
12:23:32 <dmhouse> Cale: it was indeed. :)
12:23:47 <xerox> What compose?
12:23:51 <dmhouse> ?wiki Compose
12:23:51 <lambdabot> http://www.haskell.org/haskellwiki/Compose
12:24:19 <xerox> Eheh, execState . mapM modify, I recall.
12:24:21 <Cale> I wrote some silly code in the continuation monad to compose a list of functions in the least obvious way possible
12:24:29 <dmhouse> I love that page.
12:24:38 <dmhouse> It shows the real spirit of #haskell algorithm golf. :)
12:24:48 <emertens> @djinn [a -> a] -> (a -> a)
12:24:48 <lambdabot> f _ a = a
12:25:01 <emertens> solved!
12:25:18 <Cale> haha
12:25:38 <dmhouse> That command seems very pointless until you consider C-H.
12:25:39 <Numbers> golf = fewest symbols possible?
12:25:46 <xerox> dcoutts_: so it seems cabal-server-install is the put program
12:25:51 <Cale> Yeah, this isn't really golf
12:25:53 <dmhouse> Numbers: 'tennis' is probably a better term.
12:25:57 <xerox> dcoutts_: I didn't really understand that program yet
12:26:02 <Cale> hehe, yeah, tennis
12:26:05 <emertens> @. pl djinn [a -> a] -> (a -> a)
12:26:06 <lambdabot> f = const id
12:26:06 <dcoutts_> xerox, ok, is that different from cabal-server?
12:26:15 <dmhouse> Numbers: one person cranks out an algorithm, another person will improve it or do it in a different way.
12:26:20 <Numbers> Ahhh
12:26:21 <xerox> dcoutts_: I've no idea
12:26:43 <dmhouse> Haskell share's Perl's TMTOWTDI characteristics.
12:26:52 <int-e> @localtime dons
12:26:54 <lambdabot> Local time for dons is Sat Jul 29 05:20:26 2006
12:26:59 <dcoutts_> xerox, heh :-)
12:27:03 * dcoutts_ has to go
12:27:28 <xerox> dcoutts_: I will start cabal-server... I think
12:27:30 <Cale> Well, there's more than one way to do it in every Turing complete language :)
12:27:31 <emertens> @. elite localtime dons
12:27:31 <emertens> ?
12:27:32 <lambdabot> Say again?
12:27:34 <lambdabot> Local time for dons is Sat Jul 29 05:21:05 2006
12:27:35 <emertens> :(
12:27:52 <Cale> But some languages have more than one *fun* way to do it :)
12:27:52 <dcoutts_> xerox, sounds sensible
12:28:03 <Numbers> Atleas tit's doesn't chare Perl's 'I like to look like line noise' ...
12:28:14 <dmhouse> Yeah. Haskell is very pretty.
12:28:40 <xerox> dcoutts_: hmpf, do you think it's rude to propose one own solution without caring understanding the code we have there?
12:28:53 <int-e> fun. can anyone compare http://int-e.home.tlink.de/haskell/um4.hs and http://int-e.home.tlink.de/haskell/um5.hs and tell me why the second is almost 2 times faster than the first with ghc 6.4.2? (note that the array copying code that I changed isn't actually used much.)
12:28:56 <xerox> dcoutts_: if that is the put program, we've got something completely different, i.e. a smart scp
12:29:08 <xerox> dcoutts_: anyway, if you have to go, I'll not keep you here :)
12:29:15 <dcoutts_> xerox, possibly, it'd be nice to know what other people had in mind
12:29:28 <dcoutts_> xerox, we need to discuss this with SyntaxNinja
12:29:34 <dcoutts_> @seen SyntaxNinja
12:29:34 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 3 days, 18 hours, 36 minutes and 7 seconds ago, and .
12:29:51 <int-e> (fwiw, the speed is almost identical with a recent ghc 6.5 snapshot)
12:30:16 * xerox grumbles
12:30:47 <Numbers> Just a guess, but maybe ghc is better at optimization when things are functionalized, rather then monolithic?
12:31:21 <emertens> @type modify
12:31:23 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
12:31:36 <dmhouse> It shouldn't be. Inlining it generally an advantage.
12:31:49 <Numbers> I know python works that way.
12:31:53 <int-e> my guess would be that the strictness analyzer does a slightly better job now. I don't want to dig into core or STG code right now.
12:32:03 <Igloo> So, can anyone beat compose = flip$foldl$flip$id ?
12:32:07 <int-e> oh, ghc inlines very heavily and successfully.
12:32:19 <sjanssen> int-e: the major difference is moving from a state monad to explicit passing?
12:32:53 <dmhouse> Igloo: compose=flip$foldl$flip$id :)
12:33:06 <int-e> sjanssen: the difference between the two programs I'm asking about is that I implemented a proper array copying loop instead of using getElems >>= newListArray. This fixes a stack overflow.
12:33:23 <xerox> audreyt: I was just wondering, cabal-setup-install is a smart scp ?
12:33:27 <Igloo> Yes yes, very good  :-)
12:33:37 <int-e> sjanssen: but apparently it also does something to the optimizer logic that I don't understand :)
12:33:39 <audreyt> xerox: I think so, yes
12:34:08 <xerox> audreyt: we were thinking of a different design, where a tool like 'cabal-server' imports packages and generate indices
12:34:24 <Numbers> What is 'id'?  It says the identity for function composition, so is it just 'f x = x'?
12:34:33 <Igloo> Yes
12:34:42 <Numbers> @pl f x = x
12:34:42 <lambdabot> f = id
12:34:44 <dmhouse> Numbers: it's the identity on anything.
12:34:47 <Numbers> heh
12:35:19 <int-e> > (flip$foldl$flip$id) [('a':),('b':)] ""
12:35:20 <lambdabot>    Expecting a function type, but found `Q Exp'
12:35:20 <lambdabot>    Expected type: ExpQ
12:35:20 <lambdabot>  ...
12:35:34 <int-e> > (flip $ foldl $ flip $ id) [('a':),('b':)] ""
12:35:35 <lambdabot>  "ba"
12:35:45 <int-e> really in that order?
12:36:08 <Igloo> That's what http://www.haskell.org/haskellwiki/Compose does, yes
12:36:10 <lambdabot> Title: Compose - HaskellWiki
12:36:38 <emertens> @hoogle State s a -> s -> a
12:36:40 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
12:36:40 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
12:36:48 <dmhouse> Igloo: add it to the list, if you want. 'Short as possible' or something.
12:37:10 <dmhouse> Igloo: long with commentary as to how it makes sense. Perhaps a reduction trail to show how you arrived at that.
12:37:24 <Numbers> > (flip $ foldl $ flip $ id) [('a':),('b':),('c':)] ""
12:37:25 <lambdabot>  "cba"
12:37:29 <Numbers> Hmm
12:38:14 <dmhouse> > (('c':) . ('b':) . ('a':)) ""
12:38:15 <lambdabot>  "cba"
12:39:30 <xerox> > foldl (.) id [('a':),('b':),('c':)] ""
12:39:31 <lambdabot>  "abc"
12:40:24 <dmhouse> > execState . mapM modify $ [('a':),('b':),('c':)] $ ""
12:40:25 <lambdabot>  Couldn't match `a -> b' against `[a1]'
12:40:36 <dmhouse> > (execState . mapM modify) [('a':),('b':),('c':)] ""
12:40:37 <lambdabot>  "cba"
12:40:51 <int-e> foldr(flip(.))id
12:41:28 <dmhouse> Does that parse?
12:41:30 <int-e> or foldl. does the same thing.
12:41:40 <int-e> > foldr(flip(.))id  [('a':),('b':),('c':)] ""
12:41:41 <lambdabot>  "cba"
12:41:48 <dmhouse> Nice.
12:41:50 <xerox> Perl.
12:42:02 <int-e> > foldl(flip(.))id  [('a':),('b':),('c':)] ""
12:42:03 <lambdabot>  "cba"
12:49:22 <ejt> evening, this is an off topic question, but I think people here are the sort to know the answer:  I'm thinking of subscribing to the 'ACM digital Library'  I was wondering if anyone here has any opinions on it.  eg, How does it compare to CiteSeer ?
12:52:13 <SamB> huh, I did *not* mean for *that* ant to reach the food, but whatever...
12:53:39 <ndm> ejt: can't you get most articles off the authors home pages?
12:53:52 <ejt> that's what I'm wondering
12:54:25 <ejt> I did some searching this afternoon, and ACM seems to save time, and return better citation lists
12:55:21 <ejt> I guess I just wanted a straw poll, if nobody else bothers with it, then it's probably not worth it
12:55:33 <ndm> i have it though uni, so don't even realise when i'm using it
12:55:40 <ejt> ah
12:55:41 <jgrimes_> ejt: I use it every once in a while through my uni
13:01:49 <lisppaste2> SamB annotated #23299 with "puzzle 6 solution" at http://paste.lisp.org/display/23299#1
13:02:51 <zarvok> SamB: that's one of my favorites
13:03:16 <pejo> ejt, scholar.google.com usually has a copy of the paper somewhere too.
13:03:32 <zarvok> google scholar is so nice
13:03:54 <zarvok> whenever I search for a paper, it recognizes that I'm using a CMU IP address and gives me a link to where I can find the paper in our library
13:03:59 <ejt> I only found google scholar a couple of weeks ago; I'll have to look at it some more, thanks
13:04:03 <zarvok> talk about convenient
13:05:00 <ejt> impressive!
13:05:10 <ndm> zarvok: "in your library", as in your hardcopy library, or your local electronic one?
13:05:41 <mnislaih> gm gm
13:06:13 <zarvok> ndm: in the physical CMU library
13:06:15 <mnislaih> funny Compose example dmhouse
13:06:45 <zarvok> it accesses our library's website and finds the volume of the journal that has the paper, and gives me the link to the page that tells me where to find the hardcopy
13:06:51 <mnislaih> reminds me of that 'phases of a Haskell programmer' website
13:07:05 * mnislaih wonders if Lemmih has any patches for him
13:07:22 <mnislaih> has anyone tried to compile ghc with the latest patches for the new package system ?
13:07:25 <emertens> @pl f (u,v) = g u /= g v
13:07:26 <lambdabot> f = uncurry ((. g) . (/=) . g)
13:12:13 <int-e> mnislaih: yep
13:12:38 <mnislaih> did it compile all right ?
13:13:09 <Lemmih> mnislaih: Hi.
13:13:22 <int-e> mnislaih: it did here, but cabal doesn't quite work (it passes a version-less package name to -package-name)
13:13:34 <mnislaih> hey Lemmih
13:14:04 <mnislaih> you are at anglohaskell now I guess ?
13:14:31 <mnislaih> int-e: I can't even get a working stage1 now, but I'm at MacIntel
13:14:32 <Lemmih> I will be next week.
13:14:45 <mnislaih> I mixed up dates
13:15:04 <Lemmih> mnislaih: Issues with 'TH.pkgString'?
13:15:34 <mnislaih> I've been seeing those, but I'm stuck with no Prelude atm
13:16:03 <mnislaih> the new patches break a lot of my code, I just wanted to fix it. I guess I'll wait a bit more
13:16:58 <mnislaih> I thought the issues with TH were because I didn't have a ghc with TH installed for the bootstrap
13:17:56 <mnislaih> eventually I got me a TH enabled ghc and I think that fixed it.
13:25:24 * Lemmih is having issues with TH.pkgString.
13:27:56 <Lemmih> I wonder why JaffaCake didn't notice that it is used at stage1.
13:29:44 <mnislaih> Lemmih, what's the problem with that
13:30:09 <mnislaih> you need a ghc installed anyway to compile stage1. as long as it is TH enabled, it should be fine ?
13:31:33 * mnislaih still doesnt fully grasp the ghc build architecture 
13:32:09 <Lemmih> TH.pkgString was added to the template-haskell package a few days ago.
13:32:13 <musasabi> Why is "newtype Foo = forall a. Foo (T a)" not allowed?
13:33:32 <Cale> because that's not a type isomorphic to an existing type
13:33:51 <palomer> @palomer
13:33:51 <lambdabot> Brump!
13:34:03 <Cale> newtype only creates new types which are implemented with an existing type
13:35:00 <musasabi> ok. Then just have to write a custom list type to handle list with a polymorphically typed parameter (to avoid data overhead)
13:35:32 <Cale> But if it's completely polymorphic, why not just use Nat?
13:35:58 <Cale> Or is there a class constraint?
13:36:14 <Cale> Personally, I wouldn't worry about the data overhead too much
13:36:42 <Cale> It's necessary for storing pointers to any class dictionaries you have around anyway.
13:36:45 <monochrom> the overhead may be necessary for polymorphism.
13:36:54 <musasabi> no class dictionaries.
13:36:59 <Cale> Then use Nat
13:37:07 <musasabi> Nat?
13:37:14 <Cale> Because a list of things which you can't use might as well be a natural number
13:37:17 <mnislaih> Lemmih: got any idea of why my stage1 is Prelude-less ?
13:37:35 <Cale> (or infinity)
13:37:41 <musasabi> Cale: I can use them. Only a phantom type parameter is forall:ed.
13:37:42 <Cale> data Nat = Zero | Succ Nat
13:37:49 <Lemmih> mnislaih: Prelude-less?
13:37:59 <Cale> ah
13:38:11 <Cale> I'd figured you'd meant T to be your list type.
13:38:45 <Cale> Or you could use the type T ()
13:38:48 <Cale> in any event
13:39:08 <Cale> You might as well throw away values which are completely polymorphic because you can't use them.
13:39:17 <musasabi> "[forall phantom. Foo phantom]" was what I wanted. Now just used a polymorphic list instead (free strictness also)
13:39:26 <mnislaih> I cant even compile some Hello.hs with stage1, it complains that it cannot find module 'Prelude'
13:39:37 <musasabi> (where Foo is the real datatype)
13:39:37 <mnislaih> let alone the libraries and stage2...
13:40:18 <Cale> musasabi: Hmm, why not project out the phantom type before putting the values in a list?
13:40:28 <Cale> You're losing that typing information with existentials anyway.
13:41:18 <musasabi> Cale: well it is into a GADT and will become usefull in functions that use it.
13:41:38 <Cale> hmm
13:41:58 <musasabi> Cale: thus functions processing the list nodes will get the correct type for the phantom from matching at the value level
13:42:38 <xerox> Phantom = no constructors?
13:43:00 <Cale> Are you sure that'll work?
13:43:34 <Cale> It seems to me the sort of thing that will result in complaints about lack of polymorphism or similar, but I'm not completely familiar with GADTs.
13:43:45 <Lemmih> mnislaih: Weird. Is the base package built?
13:43:47 <musasabi> Cale: I think it will. Will see.
13:44:15 <musasabi> usually the GADT issues can be fixed with rewriting parts of the functions, GHC is very picky how they are matched.
13:44:25 <Cale> When you apply the data constructor Foo, you're essentially throwing away that phantom parameter. If a function needs to use that type parameter to tell what code to run, you're out of luck.
13:46:43 <musasabi> Cale: but it can match against constructors. And inside those blocks it will make the phantom into a known type. And there one can dispatch on the type.
13:46:58 <ricky_clarkson> Just glancing at this about list comprehensions.. http://www.martinfowler.com/bliki/CollectionClosureMethod.html
13:46:59 <lambdabot> Title: MF Bliki: CollectionClosureMethod
13:47:20 <mnislaih> Lemmih: oh indeed. After so much time running in circles, I lost sight. the actual error is indeed at libraries/base, but somehow make at the top level was ignoring that error. Well, at libraries/base it gives a 'missing indirect symbols...' error
13:47:39 <mnislaih> which must be the culprit. Does it mean anything to you ?
13:48:14 <ricky_clarkson> [Not necessarily a Haskell question]: Does a list comprehension usually make a new collection and copy stuff into it as described there, or work by returning a function on the original list?
13:48:29 <Cale> It creates a new list
13:48:34 <ricky_clarkson> Oh.
13:48:53 <Lemmih> mnislaih: hm, no.
13:48:56 <ricky_clarkson> Is there a name for something that doesn't do that?
13:49:10 <Cale> doesn't do that how?
13:49:35 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]]
13:49:35 <lambdabot>  Parse error
13:49:38 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
13:49:39 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
13:49:58 <Cale> There's a good example of a list comprehension
13:50:00 <ricky_clarkson> I could imagine (and write) an implementation that doesn't copy, but when you look at each element of the returned list, it runs a function to find out what its value should be.
13:50:13 <Cale> Oh, laziness does that for you
13:50:39 <ricky_clarkson> So that's the norm, ok.
13:50:48 <Cale> In Haskell, at least.
13:51:11 <mnislaih> I think it's a MacIntel issue, the error is coming from GHC.Float. I must have broken something when I tried to fix the issue with TH by installing a different ghc-6.5
13:51:12 <Cale> > take 10 [x^2 | x <- [1..]]
13:51:13 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
13:51:32 <Cale> There's an example of an infinite list comprehension
13:51:36 <ricky_clarkson> I see.
13:51:38 <Cale> Here's another :)
13:51:54 <ricky_clarkson> So I'm logically sound in implementing this outside Haskell in a lazy way.
13:52:10 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
13:52:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:52:20 <xerox> A random one eh :)
13:52:48 <ricky_clarkson> Show-off.
13:52:52 <Cale> See if you can work out how that works :)
13:53:53 <Cale> It's not the fastest way to compute the primes, but it's a really nice example because of the way that it uses laziness.
13:54:45 <xerox> > let primes = 2 : 3 : [n | n <- [5,7..], all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)] in primes
13:54:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:55:13 <xerox> That is the one I like most.
13:56:00 <Cale> Nicely convoluted control flow :)
13:56:12 <xerox> %-)
13:56:15 <int-e> > let primep p = all (/=0) [p `mod` q | q <- takeWhile (\q -> q*q <= p) primes]; primes = 2 : filter primep [3, 5..] in primes -- pretty much what xerox just did
13:56:17 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:56:18 <Cale> But easy enough to see what it's doing
13:57:30 <int-e> everyone should have his own favourite haskell prime number generator ;)
13:57:45 <xerox> Yay :-)
13:57:52 <int-e> oh, and fibonacci numbers
13:57:58 <xerox> zipWith!
13:57:59 <julian> Hi
13:58:25 <xerox> Hello julian
13:58:28 <ricky_clarkson> Try a roman numeral to decimal converter.
13:58:44 <int-e> > fix ((0:) . scanl (+) 1)
13:58:44 <xerox> The golfing starts
13:58:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:58:50 <julian> I cant compile lambda bot
13:58:59 <xerox> int-e: I'll wire that one in my brain! Sweet.
13:59:00 <Cale> julian: oh?
13:59:18 <julian> link error
13:59:34 <xerox> @karma+ int-e -- fixed points
13:59:34 <lambdabot> int-e's karma raised to 9.
13:59:43 <Cale> lisppaste2: url
13:59:43 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:59:49 <Cale> julian: paste it
13:59:52 <julian> Linking ...
13:59:52 <julian> /home/julian/lib/fps-0.7/ghc-6.4.2/libHSfps-0.7.a(ByteString.o): En la funcin `shyK_1_alt':
13:59:52 <julian> ghc28403.hc:(.text+0xff99): referencia a `GHCziHandle_lvl94_closure' sin definir
14:00:05 <xerox> int-e: how did you come up with that?
14:00:41 <Cale> julian: hum, perhaps something went wrong with your install of fps?
14:01:02 <xerox> You need very very latest fps for lambdabot.
14:01:09 <xerox> (Not sure about the version number.)
14:01:29 <julian> mmm, i have the latest
14:01:34 <julian> from darcs
14:01:50 <xerox> What architecture?
14:01:55 <julian> x386
14:01:58 <julian> i386
14:02:03 <roconnor> Prelude Control.Monad.Fix> mfix $ \x -> putChar x >> getChar
14:02:03 <roconnor> *** Exception: <<loop>>
14:02:44 <xerox> > map (take 20) (mfix (\s -> [1:s]) :: [[Int]]) -- monochrom (c) yesterday
14:02:45 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
14:03:14 <monochrom> Eh!
14:03:20 <ricky_clarkson> Nobody taking up the roman numeral challenge? ;)
14:03:22 <xerox> (-;
14:03:35 <ndm> ricky_clarkson: to do roman numerals in haskell?
14:03:36 <xerox> Nobody wants to look up how they are defined :-)
14:03:52 <sjanssen> julian: that looks like an odd place to install fps
14:03:53 <ricky_clarkson> ndm: To convert them to decimal.
14:04:06 <ricky_clarkson> ndm: Just while people were doing clever one-liners.
14:04:17 <ndm> ricky_clarkson: ftp://ftp.cs.york.ac.uk/pub/haskell/contrib/Roman.hs
14:04:19 <ricky_clarkson> I did it a few years ago in Java, was about 8 lines.
14:04:37 <ndm> there is the code, not sure about the lines though
14:04:38 <julian> sjanssen: --prefix ??
14:05:10 <roconnor> :type mfix (\x -> 1 `mplus` x)
14:05:16 <roconnor> @type mfix (\x -> 1 `mplus` x)
14:05:17 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
14:05:18 <lambdabot>    Expected type: m (m a)
14:05:24 <julian> :type mfix
14:05:36 <roconnor> @type mfix (\x -> return 1 `mplus` x)
14:05:37 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
14:05:37 <lambdabot>    Expected type: m (m a)
14:05:46 <julian> @type mfix
14:05:47 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
14:06:01 <sjanssen> @type mfix (\x -> return 1 `mplus` return x)
14:06:03 <lambdabot> forall a (m :: * -> *). (MonadPlus m, Num a, MonadFix m) => m a
14:06:30 <roconnor> mfix (\x -> return 1 `mplus` return x) ::[Int]
14:06:44 <roconnor> > mfix (\x -> return 1 `mplus` return x) ::[Int]
14:06:45 <lambdabot>  Exception: <<loop>>
14:08:47 <roconnor> I still don't get mdo
14:09:54 <int-e> xerox: long story, but bascially I found the formulat x_n = x_{n-2} + x_{n-3} + ... + 1 by repetitive expansion of the fibonacci sequence's defintion - which is exactly what scanl (+) does.
14:10:38 <xerox> int-e: that summation has n terms?
14:10:57 <int-e> n-1.
14:11:10 <julian> sjanssen: where I must install fps ? --prefix=??
14:11:30 <musasabi> What was the correct way to get to the max/min value of Double in Haskell?
14:11:50 <sjanssen> julian: I usually just install to /usr (where GHC is), but you probably don't have to do that
14:11:59 <sjanssen> julian: do you know if your install of fps works at all?
14:12:01 <int-e> xerox: x[n] = x[n-2] + x[n-1] = x[n-2] + x[n-3] + x[n-2] = x[n-2] + x[n-3] + x[n-4] + x[n-3] = x[n-2] + ... + x[0] + x[1].
14:12:10 <roconnor> >minbound :: Double
14:12:15 <roconnor> > minBound :: Double
14:12:16 <lambdabot>  add an instance declaration for (Bounded Double)
14:12:16 <lambdabot>   In the expression: min...
14:14:23 <julian> sjanssen: fps/test/make fails
14:14:58 <sjanssen> julian: how does it fail?
14:15:00 <musasabi> One could use floatRange + floatRadix + etc, but there was a better way
14:15:20 <julian> ghc-6.4.2: unable to load package `fps-0.7'
14:15:21 <julian> make: *** [prop] Error 1
14:16:37 <roconnor> Prelude Control.Monad.Fix> mdo { x <- return 'c'; putChar x; }
14:16:37 <roconnor> <interactive>:1:8: parse error on input `<-'
14:17:01 <int-e> why mdo?
14:17:13 <xerox> > fst . foldr (\p (t,s) -> if p>=s then (t+p,p) else (t-p,p)) (0,0) . map (fromJust . flip lookup [('I',1),('V',5),('X',10),('L',50),('C',100),('D',500),('M',1000)]) $ "III"
14:17:15 <lambdabot>  3
14:17:22 <roconnor> I'm trying to understand what mdo does
14:17:25 <xerox> ^- ricky_clarkson
14:17:28 <roconnor> I'm starting simple
14:17:33 <roconnor> very simple
14:17:45 <xerox> Are we sure IO supports mdo?
14:17:46 <sjanssen> roconnor: make sure you have -fglasgow-exts
14:18:32 <roconnor> oh right
14:19:25 <xerox> > let c = fst . foldr (\p (t,s) -> if p>=s then (t+p,p) else (t-p,p)) (0,0) . map (fromJust . flip lookup [('I',1),('V',5),('X',10),('L',50),('C',100),('D',500),('M',1000)]) in (c "IV", c "VI")
14:19:26 <lambdabot>  (4,6)
14:19:52 <ricky_clarkson> xerox: Heh, nice.
14:19:54 <roconnor> @pl c = fst . foldr (\p (t,s) -> if p>=s then (t+p,p) else (t-p,p)) (0,0) . map (fromJust . flip lookup [('I',1),('V',5),('X',10),('L',50),('C',100),('D',500),('M',1000)])
14:19:59 * xerox tips his hat
14:19:59 <lambdabot> c = fst . foldr ((`ap` snd) . (. fst) . ap (ap . (flip .) . ap ((.) . flip . (if' .) . (>=)) (flip =<< ((,) .) . (+))) (flip =<< ((,) .) . subtract)) (0, 0) . map (fromJust . flip lookup [('I', 1), (
14:19:59 <lambdabot> 'V', 5), ('X', 10), ('L', 50), ('C', 100), ('D', 500), ('M', 1000)])
14:19:59 <lambdabot> optimization suspended, use @pl-resume to continue.
14:20:10 <sjanssen> @pl \p (t,s) -> if p>=s then (t+p,p) else (t-p,p)
14:20:11 <lambdabot> (`ap` snd) . (. fst) . ap (ap . (flip .) . ap ((.) . flip . (if' .) . (>=)) (flip =<< ((,) .) . (+))) (flip =<< ((,) .) . subtract)
14:20:13 <int-e> > zip"IVXLCDM"(concat(iterate(map(*10))[1,5]))
14:20:14 <lambdabot>  [('I',1),('V',5),('X',10),('L',50),('C',100),('D',500),('M',1000)]
14:20:29 <xerox> %-)
14:21:01 <int-e> > zip"IVXLCDM"[1,5,10,50,100,500,1000] -- sadly, this is shorter
14:21:02 <lambdabot>  [('I',1),('V',5),('X',10),('L',50),('C',100),('D',500),('M',1000)]
14:21:12 <xerox> hehe
14:21:18 <monochrom> I am thinking of a conversion module in which i, v, m, x, ... are combinators.  You write "m c m x i v" and it evaluates to the desired Num.
14:21:41 <monochrom> Perhaps s/thinking/dreaming/  # I still don't know how to do it
14:22:06 <sjanssen> oh man, I think we need a type level roman numeral converter
14:22:16 <xerox> I saw it coming.
14:22:19 <monochrom> Now I have got you started!
14:22:26 * sjanssen hacks
14:22:32 <ricky_clarkson> > fst . foldr (\p (t,s) -> if p>=s then (t+p,p) else (t-p,p)) (0,0) . map (fromJust . flip lookup [('I',1),('V',5),('X',10),('L',50),('C',100),('D',500),('M',1000)]) $ "MCMXCVIII"
14:22:34 <lambdabot>  1998
14:22:43 <emertens> It *definitely* needs to be type level, because roman numerals must be capitalized
14:22:50 <xerox> hahahaha
14:22:53 <monochrom> class Roman t where ...     data M ??? = M ???     instance Roman M where ...    :)
14:23:12 <lisppaste2> Julian pasted "lambdabot link error" at http://paste.lisp.org/display/23318
14:23:15 <ricky_clarkson> I'm scared.  ;)
14:23:16 <int-e> [10^n*p|n<-[1..],p<-[1,5]] is too long, too.
14:23:20 <xerox> Let's think.
14:23:39 <monochrom> We have done Fibonnaci in types.  Nothing will stop us now!
14:23:44 <xerox> Yess!!!
14:24:15 <roconnor> zip"IVXLCDM"([0..]>>=i->[10^i,5*10^i])
14:24:18 <roconnor> > zip"IVXLCDM"([0..]>>=i->[10^i,5*10^i])
14:24:18 <lambdabot>  Parse error
14:24:25 <xerox> \
14:24:28 <roconnor> > zip"IVXLCDM"([0..]>>=\i->[10^i,5*10^i])
14:24:29 <lambdabot>  Parse error
14:24:33 <xerox> Aww.
14:24:58 <int-e> @pl \i->[10^i,5*10^i]
14:24:59 <lambdabot> liftM2 (:) (10 ^) (return . (5 *) . (10 ^))
14:27:28 <int-e> @pl \a b -> a:b:[]
14:27:28 <lambdabot> (. return) . (:)
14:27:49 <roconnor> >mfix return ::[Int]
14:27:51 <roconnor> > mfix return ::[Int]
14:27:52 <lambdabot>  Exception: <<loop>>
14:27:55 <emertens> > ( (. :[]) . (:) ) 1 2
14:27:55 <lambdabot>  Parse error
14:28:02 <emertens> > ( (. (:[])) . (:) ) 1 2
14:28:04 <lambdabot>  [1,2]
14:28:15 <int-e> take 10 $ [0..]>>=ap((.(:[])).(:))(5*).(10^)
14:28:20 <int-e> > take 10 $ [0..]>>=ap((.(:[])).(:))(5*).(10^)
14:28:21 <lambdabot>  [1,5,10,50,100,500,1000,5000,10000,50000]
14:29:15 <int-e> > take 10 $ [0..]>>=ap(:)((:[]).(5*)).(10^)
14:29:16 <lambdabot>  [1,5,10,50,100,500,1000,5000,10000,50000]
14:30:25 <emertens> > [(+1),(+2)] `ap` [3]
14:30:27 <lambdabot>  [4,5]
14:32:34 <emertens> what does `bind` mean for a rose tree?
14:32:48 <emertens> I'm thinking that it doesn't
14:33:37 <emertens> @hoogle unfoldrM
14:33:38 <lambdabot> No matches found
14:35:19 <xerox> sjanssen: have you got a starter?
14:37:28 <sjanssen> xerox: still thinking about how to tackle this
14:40:01 <emertens> @pl aux (b,a') = b:f a'
14:40:02 <lambdabot> aux = uncurry ((. f) . (:))
14:40:44 <roconnor> what does mfix do for Writer?
14:41:01 <ricky_clarkson> What does lambdabot do if you send it into an infinite loop?
14:41:13 <emertens> << Loop >>
14:41:30 <emertens> or returns the beginning of the infinite list
14:41:30 <sjanssen> ricky_clarkson: there is a time limit of a couple seconds
14:41:43 <emertens> > let x = 1 : x in x
14:41:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:41:52 <ricky_clarkson> Nice..
14:41:56 <sjanssen> emertens: you only get <<loop>> in special cases, when GHC figures out that you're in an infinite loop
14:42:00 <emertens> ah
14:42:04 <emertens> > [0..]
14:42:06 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:42:23 <ricky_clarkson> So how does it terminate the code but still get results?
14:42:23 <emertens> > [0..28]
14:42:25 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]
14:43:08 <emertens> with lazy evalution, if you only ask for the first few elements, it isn't an infinite loop
14:43:33 <julian> ricky_clarkson: lambdabot actually solves the Halt Problem :D
14:45:17 <ricky_clarkson> It looks like with an infinite list, lambdabot just displays a certain number of characters.
14:45:29 <ricky_clarkson> > [200..]
14:45:31 <lambdabot>  [200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218...
14:45:38 <ricky_clarkson> Yes, same length each time.
14:45:43 <emertens> > [200..220]
14:45:45 <lambdabot>  [200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218...
14:46:19 <ricky_clarkson> Do other FP languages implement laziness?
14:46:26 <emertens> > repeat [200..]
14:46:28 <ricky_clarkson> ..in list comprehensions, for example.
14:46:28 <lambdabot>  [[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,21...
14:47:47 <musasabi> How should one fixpoint types?
14:48:06 <emertens> @pl \f -> maybe [] (uncurry ((.(ufldr f)).(:))) . f
14:48:06 <lambdabot> (.) =<< maybe [] . uncurry . (. (:)) . flip (.) . ufldr
14:48:33 <emertens> @pl unfldr = \f -> maybe [] (uncurry ((.(ufldr f)).(:))) . f
14:48:33 <lambdabot> unfldr = (.) =<< maybe [] . uncurry . (. (:)) . flip (.) . ufldr
14:48:58 <musasabi> If there is a heterogenous tree. Which supports moving upwards. Then lower nodes need to include the upper nodes in their type. But the upper nodes need to include the lower nodes in their own type too.
14:50:29 <roconnor> Prelude Control.Monad.Fix> mdo { putChar x; x <- return 'x'; return ();}
14:50:29 <roconnor> *** Exception: <<loop>>
14:52:13 <musasabi> roconnor: do you need examples?
14:52:22 <roconnor> maybe
14:52:32 <roconnor> I thought the above would work
14:54:13 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/network-alt/Network/Alt/impl/epoll.hsc (look for mdo - the rest is irrelevant)
15:00:31 <julian> @type mdo
15:00:32 <lambdabot> Empty 'do' construct
15:01:49 <musasabi> @type (mdo return ())
15:01:50 <lambdabot> forall (m :: * -> *). (MonadFix m) => m ()
15:04:22 <roconnor> cool, this mdo stuff is way better than what I had before
15:04:30 <roconnor> but I still have no idea how it works.
15:06:57 <Lemmih> mfix f = do ref <- newIORef _|_; val <- f (unsafePerformIO (readIORef ref)); writeIORef ref val; return val.
15:09:23 <roconnor> (unsafePerformIO (readIORef ref)) = _|_?
15:09:44 <roconnor> oh wait
15:09:47 <roconnor> that is delayed
15:13:20 <lisppaste2> roconnor pasted "example of mdo" at http://paste.lisp.org/display/23323
15:14:47 <roconnor> where do I find the implementation of mfix for Writer and MonadState?
15:18:26 <SamB> roconnor: um, MonadState is a typeclass
15:18:37 <SamB> also, in their respective modules, most likely
15:18:47 <roconnor> Err, State.
15:19:19 <roconnor>  /usr/lib/hugs/packages/mtl/Control/Monad/State.hs
15:20:19 <roconnor> okay, mfix is slowly starting to make sense to me
15:21:17 <roconnor> and mdo certainly makes my code simpler, even if I don't really understand it anymore.
15:22:21 <SamB> like, "yeah, you can have your value that you will give me soon now, but don't try to look at it before then"
15:22:56 <xerox> ?remember roconnor okay, mfix is slowly starting to make sense to me. and mdo certainly makes my code simpler, even if I don't really understand it anymore.
15:22:56 <lambdabot> Done.
15:22:59 <ndm> How do I catch exceptions?
15:23:07 <ndm> I am trying with Gtk2Hs, and I get guihaskell.exe: Cannot cast object to Container
15:23:08 <xerox> ?hoogle catch
15:23:09 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
15:23:09 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
15:23:09 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
15:23:10 <SamB> ndm: with catch
15:23:24 <ndm>     Control.Exception.catch
15:23:26 <ndm>         (return $ Just $ castToContainer o)
15:23:28 <ndm>         (\e -> return Nothing)
15:23:33 <ndm> thats the code I have, but it still throws an exception
15:23:40 <roconnor> Sigh, this is what it feels like to not understand recursion.
15:23:57 <ndm> i'm wondering if the laziness is causing the value not to be evaluated until i leave the catch
15:24:04 <ndm> but whatever the case, the above doesn't work
15:24:08 <SamB> is that an exception or is that a GTK thing?
15:24:14 <ndm> its castToContainer that is throwing up
15:24:32 <ndm> SamB: the GTK developers said i could catch it, i'm not 100% sure i beleive them
15:24:34 <ndm> @seen dcoutts
15:24:34 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 8 hours, 34 minutes and 32 seconds ago.
15:24:39 <SamB> ndm: me either
15:24:42 <jcreigh> Anybody here who implemented UM for the ICFP contest?
15:24:59 <SamB> ndm: you should have asked them if they had read or used gtk2hs!
15:25:14 <ndm> i meant the gtk2hs developers :)
15:26:12 <SamB> really?
15:26:19 <SamB> you'd think they'd know...
15:26:41 <SamB> (there are more than one?)
15:27:00 <ndm> Axel and dcoutts are joint maintainers, i think
15:27:15 <Numbers> jcreigh: Yes, but not in Haskell
15:28:44 <jcreigh> Numbers: Ah, mine isn't written in Haskell as well. I was just wondering what kind of runtimes you were getting for sandmark.
15:29:04 <Numbers> Mine doesn't run sandmark for some reason.  Well, the python one RUNS it, but never finishes.
15:29:19 <SamB> Numbers: is it too slow?
15:29:25 <stepcut> jcreigh: I think most of the haskell UMs had rather poor performance (compared to C, etc) -- there is a project to fix that though
15:29:47 <SamB> jcreigh: what does runtime tell you?
15:29:54 <SamB> we have various processors...
15:30:11 <Numbers> SamB: Oh baby.
15:30:44 <glauber_sp> guys, does anyone here like or study formal methods, specially algebraic specification methods for software?
15:31:01 <zacch> glauber_sp: what's your question?
15:31:05 <ndm> glauber_sp: to some degree
15:31:49 <jcreigh> Well, my version has been running sandmark for a couple minutes, and has only printed out one line from the stress test. ("100. 12345678.09abcdef"). I was just wondering if that meant my code was wrong, or if sandmark just takes a long time...
15:31:53 <zacch> stepcut: why did the haskell UMs perform so badly? what are the bottlenecks? Hardle the bit twiddling...
15:32:03 <ndm> SamB, solved my exception problem, i needed to be less lazy
15:32:09 <glauber_sp> zacch,  I want to know more about.
15:32:11 <SamB> ndm: oh
15:32:20 <Numbers> jcreigh: I think once you get the 100 line your'e good, it just takes a really long time.
15:32:42 <Numbers> jcreigh: Especially if your array performance degrades noticably over time.
15:33:04 <stepcut> zacch: that is what the post-mortem project aims to figure out -- i think the UM is ideally suited towards mutable arrays or something -- I did not look at the spec
15:33:20 <sjanssen> @um
15:33:20 <lambdabot> Maybe you meant: . id pl run url v wn
15:33:22 <sjanssen> @where um
15:33:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
15:33:24 <glauber_sp> zacch, ndm, I want to start a master course next year. I'm finishing the undergraduate course this year (i hope to). My final work is about algebraic specification of ADT.
15:33:31 <jcreigh> Also, I'm on a PII 400Mhz PC...
15:33:40 <ndm> glauber_sp: links?
15:33:43 <SamB> generally if your code is wrong something should happen before you hit 100
15:33:50 <SamB> jcreigh: which language are you using?
15:33:53 <ndm> and any more details on "algebaric specification"?
15:33:57 <glauber_sp> zacch, ndm , links, books, which "language" to use
15:34:00 <ndm> this is quite closely related to my phd
15:34:09 <ndm> @where catch
15:34:10 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
15:34:15 <SamB> I think C takes about 10 minutes
15:34:18 <SamB> maybe 20...
15:34:20 <SamB> I forget
15:34:24 <ndm> if you ask on #haskell which language to use, the answer is obvious... :)
15:34:35 <SamB> ndm: not necessarily
15:34:38 <Numbers> Lisp.  Duh.
15:34:40 <SamB> it depends on the context
15:34:46 <jcreigh> SamB: C++. I thought about trying haskell, but it seems more natural to map a VM based on mutable updates to a language based on mutable updates.
15:34:48 <SamB> sometimes we might say C
15:34:54 <ndm> but its hardly an impartial forum :)
15:34:54 <SamB> sometimes we might say shell
15:35:01 <Philippa> it's much easier to get an acceptably-performing UM in C++
15:35:03 <glauber_sp> ndm, I know. I want to use haskell. the "problem" is what to study. CASL, OBJ
15:35:03 <ndm> we should NEVER say shell!
15:35:13 <SamB> ndm: come on
15:35:16 <ndm> now that I have no idea on..
15:35:30 <glauber_sp> ndm, I thought about buying the CASL books and study it. there's HasCASL extension
15:35:31 <ndm> SamB, I use Windows, shell is the reason nothing works on windows
15:35:35 <Numbers> Actually, after prototyping it in another language, getting one in C is very easy.
15:35:50 <SamB> oh, well, you can get a shell too
15:35:59 <SamB> Numbers: indeed
15:36:03 <zacch> we did the UM in both C++ and Haskell, and C++ was both shorter and more efficient
15:36:06 <ndm> glauber_sp: yes, that might be worthwhile, i talked to some of the CASL developers, it seemed quite cool
15:36:11 <SamB> though Python isn't exactly what I'd choose for prototyping...
15:36:16 <Numbers> It seems like that's what everyone did.
15:36:32 <Numbers> SamB: I'm very used to OOP programming.  ANd it's my 'goto' language right now.
15:36:51 <SamB> Numbers: it doesn't even *have* goto
15:37:03 * xerox WANTS type (in)equality! NOW!
15:37:06 <Numbers> ...
15:37:15 <SamB> I suppose for such a simple VM, it isn't too bad
15:37:16 <Numbers> As in I turn to it first for solutions.
15:37:22 <SamB> but if the VM had more instructions it would be a PITA
15:37:23 <ndm> SamB: i know loads of people who use Python as a first solution, its quite good
15:37:38 <SamB> ndm: but for a VM?
15:37:46 <zacch> SamB: disagree
15:37:49 <ndm> SamB, for everything
15:37:49 <SamB> I'd want some sort of type-checking
15:37:55 <glauber_sp> ndm, and is it been currently developed? I've read half of the book from Sanella's book
15:37:55 <SamB> and variable-name-checking
15:38:02 <Numbers> SamB: Eh.
15:38:04 <ndm> glauber_sp: as far as i know, yes
15:38:05 <Philippa> ndm: VMs are somewhat special-case, the OO stuff doesn't help much
15:38:11 <Numbers> I haven't every had a problem with that, actually.
15:38:14 <sjanssen> xerox: working on roman numerals?
15:38:26 <Philippa> then again, VMs are a really nasty corner case for performance in Haskell
15:38:30 <SamB> Numbers: I must be more absentminded or something
15:38:45 <zacch> Philippa: but why exactly? we didn't investigate...
15:38:58 <SamB> indeed! why?
15:39:11 <SamB> is it all the array access?
15:39:20 <int-e> @seen dons
15:39:20 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7 hours, 41 minutes and 39 seconds ago.
15:39:23 <glauber_sp> ndm, hum, very interesting =) I guess I'll buy the books, so. And do you know another good book to explain the concepts behind algebraic specification, like institutions, category theory, etc? I saw one in the springer' site.
15:39:32 <zacch> Personally, I think no, not array alone.
15:39:35 <xerox> sjanssen: yes!
15:40:01 <ndm> i want to write a Haskell VM for Yhc, that would be fun :)
15:40:29 <ndm> we already have a Python VM for Yhc, btw, as well as C and Java
15:41:38 <zacch> @seen shapr
15:41:39 <lambdabot> I saw shapr leaving #scannedinavian, #haskell and #ScannedInAvian 6 hours, 21 minutes and 33 seconds ago, and .
15:41:43 <jcreigh> Hmm..I didn't do anything while the contest was in progress, I'm just doing this for fun now...what's with the "decryption key" for codex.umz? I entered one that somebody had posted on their blog, and now it says "decrypting..."
15:42:14 <zacch> jcreigh: they were assigned upon team registration by the organizers
15:42:24 <Numbers> It is going to dump a new UM to use.  It embeds the key into the UM it builds to give you unique 'publications' or solution keys.
15:42:44 <jcreigh> zacch: Hmm...okay, so if I'm just messing around with it, it's fine to use that one that I found?
15:42:49 <Numbers> Also, I sware it's using Rar or 7Zip or somethign to unpack the next UM.
15:42:49 <zacch> sure
15:43:43 <glauber_sp> ndm, your project is interesting =) i'll read it later.
15:43:58 <xerox> sjanssen: I nearly did it :-)
15:43:59 <ndm> glauber_sp: cool, any questions just ask
15:44:06 <glauber_sp> ndm, sure =D
15:44:17 <sjanssen> xerox: what's the problem?
15:44:25 <xerox> *Romans> roman (undefined :: V (I (I (W (I O))))) 0
15:44:26 <xerox> 8
15:44:30 * xerox laughs
15:45:01 <glauber_sp> ndm, I've already though about a topic like design patterns in haskell. I saw there are some in the haskell.org site.. so I guess I need to learn it before hehe
15:45:05 <xerox> (That's VIII, the last W is just a /W/rapper.)
15:45:47 <ndm> glauber_sp: it should be readable without that much haskell, but a bit will help
15:46:41 <xerox> *Romans> roman (undefined :: X (V (I (W (I O))))) 0
15:46:41 <xerox> 17
15:47:02 <Numbers> DOes it do (I (W (X O) ) )
15:47:04 <Numbers> ?
15:47:18 <glauber_sp> ndm, I need to start writing haskell code. I've read a book last year, but the later 3 semesters were full of homework stuff.
15:47:19 <xerox> _That's_ the problem :-)
15:47:19 * dcoutts_ is just back from seeing Pirates of the Caribbean
15:47:23 <dcoutts_> @yarr!
15:47:23 <lambdabot> I'll crush ye barnacles!
15:47:41 <dcoutts_> ndm, that's exatly the problem with your exception handler
15:48:01 <dcoutts_> 'return undefined' raises no exception
15:48:14 <dcoutts_> so it slips past your exception handler
15:48:18 <dcoutts_> @hoogle evaluate
15:48:19 <lambdabot> Control.Exception.evaluate :: a -> IO a
15:48:19 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
15:48:30 <xerox> Numbers: let's see if I can come up with some sensible number of instances to fix
15:48:33 <ndm> dcoutts_, i've fixed it now
15:48:44 <ndm> a handy `seq` in the right place
15:48:48 <ndm> I can now enumerate windows :)
15:49:00 <TheAnonymousFunc> > show "test"
15:49:01 <lambdabot>  "\"test\""
15:49:05 <TheAnonymousFunc> =D
15:49:12 <TheAnonymousFunc> sorry
15:49:31 <xerox> > showString "test" ""
15:49:32 <lambdabot>  "test"
15:49:35 <dcoutts_> ndm, evaluate is the nice way to do it in such cases, or return $! undefined
15:49:53 <dcoutts_> return $! Just $! castToThingie o
15:50:04 <ndm> dcoutts, ok, will do it that way
15:50:10 <TheAnonymousFunc> ?type showString
15:50:12 <lambdabot> String -> ShowS
15:50:22 <glauber_sp> ndm, wow, I made a mistake. I'm finishing my graduate couse, not undergraduate eheh
15:50:31 * ndm doesn't like these horrible impure things...
15:52:02 <dcoutts_> ndm, can you remind me why you need to enumerate the windows rather than looking widgets up by name in the glade file ?
15:52:24 <ndm> dcoutts_, so its pure, in the right way, in the right places
15:52:39 <ndm> its hard to explain, but once i give an example, it should be clear
15:52:43 <dcoutts_> ok :-)
15:52:53 <ndm> I want to change this code:
15:52:56 <ndm>     a <- getTextView window "txtOut"
15:52:58 <ndm>     b <- getStatusBar window "sb"
15:53:00 <ndm>     c <- getToolButton window "tbRun"
15:53:01 <ndm>     d <- getToolButton window "tbOpen"
15:53:03 <ndm>     e <- getToolButton window "tbStop"
15:53:04 <ndm>     f <- getToolButton window "tbRecent"
15:53:06 <ndm>     
15:53:07 <ndm>     let gui = Gui window a b c d e f
15:53:09 <ndm>                   running filename
15:53:11 <ndm> into:
15:53:34 <Pete_I> pastebin.
15:53:35 <ndm> Gui window (getCtrl "txtOut") (getCtrl "sb") (getCtrl "tbRun") (getCtrl "tbOpen") (getCtrl "tbStop") (getCtrl "tbRecent") running filename
15:54:08 <dcoutts_> ndm, so you want a pure getCtrl which looks widgets up by name
15:54:16 <ndm> dcoutts_, yep
15:54:36 <dcoutts_> we can do that with a little unsafePerformIO
15:54:54 <dcoutts_> and we can cast it to the right thing automagically
15:54:54 <ndm> dcoutts_, no, because getTextView returns a "super text view"
15:55:10 <dcoutts_> you want it to return what type?
15:55:18 <ndm> which is wrapped by PropLang
15:55:21 <Numbers> > x <- genRange (mkStdGen 12345)
15:55:21 <lambdabot>  Parse error
15:55:23 <ndm> "the right type"
15:55:25 <Numbers> Hmm.
15:55:26 <ndm> it will be a typeclass
15:55:29 <Numbers> @type genRange
15:55:31 <lambdabot> forall g. (RandomGen g) => g -> (Int, Int)
15:55:56 <ndm> the lifting from Gtk.TextView to PropLang.TextView is very IO based, and probably not unsafePerformIO safe
15:56:14 <Numbers> > mkStdGen 1234
15:56:15 <lambdabot>  1235 1
15:56:29 <dcoutts_> ndm, so how do you do it safely?
15:56:50 <ndm> dcoutts_, enumerate, cache, have get be a no-op
15:56:57 <ndm> or rather a pure lookup
15:57:02 <dcoutts_> we can do that
15:57:12 <ndm> but it will return a Gtk pure object
15:57:16 <ndm> not a PropLang pure object
15:57:24 <ndm> its also important that each object is wrapped only once
15:57:32 <ndm> so this cache is of benefit for that as well
15:57:36 <dcoutts_> hmm, I see
15:58:21 <ndm> anyway, i can do it now
15:58:23 <Numbers> In ghci how can I import a module into the scope?
15:58:24 <dcoutts_> so what IOish stuff do you need to do to wrap a widget?
15:58:42 <ndm> dcoutts_, lots of readIORef/writeIORef for the event notifiers etc
15:59:04 <dcoutts_> Numbers, either :load or :module
15:59:08 <dcoutts_> Numbers, see :help
15:59:12 <ndm> since its very complex, i'd rather not put it in a unsafePerformIO, because i'm not sure if it would work or not
15:59:15 <Numbers> THanks.
15:59:34 <dcoutts_> ndm, aye
15:59:47 <dcoutts_> so what do you need all this state for?
15:59:55 <dcoutts_> perhaps I should just look at the code :-)
16:00:18 <ndm> setting up event mappings between things
16:00:22 <ndm> its very state based, at the moment
16:00:38 <ndm> i'll hopefully have a new version to go on monday
16:00:46 <ndm> i'm developing GuiHaskell and PropLang in tandem
16:03:54 <dcoutts_> ok
16:04:00 * dcoutts_ should depart
16:06:27 <xerox> ricky_clarkson: may you give me sample roman numerals with their arabic counterpart so that I can write a bunch of tests?
16:06:48 <ricky_clarkson> Should I be strict?
16:06:58 <xerox> What do you mean?
16:07:02 <ricky_clarkson> E.g., IM is not 1999, it's an error.
16:07:17 <ricky_clarkson> MCMXCIX is the correct term.
16:07:29 <xerox> Yes, please.
16:08:00 <xerox> Oh-uhm.
16:09:45 <ricky_clarkson> I=1,II=2,IV=4,VIII=8,XVI=16,XXXII=32,LXIV=64,CXXVIII=128,CCLVI=256,MXXIV=1024,MMXLVIII=2048
16:09:59 <xerox> Thanks.
16:10:45 <xerox> I'm having troubles discerning XIV from XI* ...
16:11:57 <SamB> powers of two in roman numerals???
16:11:59 <SamB> crazy.
16:12:04 <Numbers> Evaluate backwards?
16:12:14 <xerox> *Romans> roman (undefined :: (I (V O))) 0
16:12:14 <xerox> 4
16:12:14 <xerox> *Romans> roman (undefined :: I (I (V O))) 0
16:12:15 <xerox> 5
16:12:22 <xerox> Hrrrrmpf.
16:12:30 <xerox> Numbers: I thought so to, but my brain is melting
16:12:33 <xerox> Numbers: would it work?
16:12:37 <Numbers> Yeah.
16:13:01 <Numbers> Keep the bigest value you've seen, then subtract anythign smaller, and add anythign bigger.
16:13:08 <xerox> Numbers: keep in mind I can _only_ use Int -> Int functions
16:13:12 <Numbers> Update biggest, etc.
16:13:21 <xerox> No values "keepable"
16:13:33 <Numbers> Well
16:13:42 <Numbers> if your current number is bigger then the next symbol
16:13:45 <Numbers> Backwards.
16:13:50 <Numbers> Then you need ot subtract.
16:13:56 * xerox 's head explodes
16:14:00 <xerox> Let me think :)
16:14:01 <bolrod> O_O
16:14:04 <bolrod> don't explode in here.
16:14:22 <Numbers> Yeah. :(  THey make the newbies sweep the floor.
16:14:49 <bolrod> yeah... see.. you made someone leave!
16:15:06 <xerox> IIV = V (I (I O))
16:15:17 <bolrod> hm.. that looks like a really fucked up smiley
16:15:18 <xerox> > (+5) . (-1) . (-1) $ 0
16:15:18 <lambdabot>  add an instance declaration for (Num (a -> b))
16:15:21 <bolrod> ;)
16:15:30 <bolrod> what'cha doin with roman numbers?
16:15:38 <xerox> > (+5) . (subtract 1) . (subtract 1) $ 0
16:15:39 <lambdabot>  3
16:15:43 <xerox> Encoding them in the type system, bolrod
16:15:52 <xerox> Numbers: it COULD work!!!
16:15:58 <bolrod> with what purpose?
16:16:04 <xerox> Encoding them in the type system, bolrod
16:16:09 <bolrod> ic
16:16:34 <xerox> > fix ("Encoding them in the type system, bolrod. "++)
16:16:35 <lambdabot>  "Encoding them in the type system, bolrod. Encoding them in the type system,...
16:16:51 <bolrod> iiiiinterestink
16:17:55 <bolrod> and how? :)
16:18:01 <bolrod> how hard can it be..
16:18:51 <xerox> Numbers: it doesn't work.
16:18:56 <Numbers> Ohno?
16:19:08 <xerox> As far as I can tell, no
16:19:17 <Numbers> Hrm.  Sorry.
16:19:21 <xerox> *Romans> roman (undefined :: I (I (V O))) 0
16:19:21 <xerox> 5
16:19:21 <xerox> *Romans> roman (undefined :: V (I (I O))) 0
16:19:22 <xerox> 7
16:19:39 <xerox> I am not 100% sure.
16:19:56 <xerox> OH
16:20:02 <xerox> One of those don't make strictly sense!
16:20:18 <xerox> *Romans> roman (undefined :: V (I (I O))) 0
16:20:18 <xerox> 7
16:20:18 <xerox> *Romans> roman (undefined :: I (V O)) 0
16:20:19 <xerox> 4
16:20:22 <xerox> This seem right
16:20:25 <bolrod> 01:06:40 < ricky_clarkson> E.g., IM is not 1999, it's an error.
16:20:25 <Numbers> Yes
16:20:26 <bolrod> 01:06:55 < ricky_clarkson> MCMXCIX is the correct term.
16:20:32 <bolrod> how weird is that system ;/
16:21:02 <ricky_clarkson> I think that's right, bolrod ;)
16:21:06 <bolrod> so.. 19999 would be? ... ;)
16:21:21 <ricky_clarkson> I don't think there's a numeral for 10000.
16:21:30 <bolrod> no..
16:21:35 <bolrod> but we could use lots of M's
16:21:42 <xerox> *Romans> roman (undefined :: X (I (V O))) 0
16:21:42 <xerox> 14
16:21:42 <xerox> *Romans> roman (undefined :: X (V (I O))) 0
16:21:43 <xerox> 16
16:21:55 <xerox> ricky_clarkson: looking correct?
16:22:29 <ricky_clarkson> xerox: Yes.
16:22:34 <xerox> Cool.
16:22:54 <xerox> I have declared I, V, X only, though
16:23:00 <xerox> I am not sure about the rules for the next ones
16:23:06 <bolrod> quite the same
16:23:13 <bolrod> I guess..
16:23:18 <xerox> Let's try.
16:23:30 <bolrod> but...  49.. is that IL ?
16:23:37 <xerox> What can you do with L, and C ?
16:23:41 <xerox> And M?
16:23:44 <bolrod> C=100
16:23:48 <bolrod> L=50
16:23:51 <bolrod> D=500
16:23:53 <bolrod> M=1000
16:23:59 <Numbers> http://en.wikipedia.org/wiki/Roman_Numerals
16:24:45 <xerox> Be kind to my poor brain :D
16:24:50 <xerox> ?localtime xerox
16:24:53 <lambdabot> Local time for xerox is Sat Jul 29 00:24:28 2006
16:25:03 <xerox> No it's 1:24 ...
16:25:40 <Numbers> ?localtime Numbers
16:25:44 <lambdabot> Local time for Numbers is Fri Jul 28 18:38:29 2006
16:25:58 <xerox> (AM)
16:25:58 <Numbers> Haha, the clock on my machine is very very off.
16:25:59 <bolrod> then why do you reply to lambdabot with the wrong time ;)
16:26:17 <bolrod> Sat Jul 29 01:25:55 CEST 2006
16:28:35 <bolrod> damn.. how hard must multiplication have been with the Roman number system 8)
16:33:13 <xerox> OK, I get them right up to 32.
16:33:54 <Numbers> 33 = XXXIII
16:33:56 <xerox> Does VV make sense in any context?
16:34:02 <SamB> I think they used quisenaire blocks for muliplication
16:34:06 <SamB> er, rods
16:34:08 <Numbers> not really
16:34:18 <xerox> *Romans> roman (undefined :: X (X (X (I (I (I O)))))) 0
16:34:19 <xerox> 33
16:34:35 <xerox> *Romans> roman (undefined :: X (X (X (I (V O))))) 0
16:34:35 <xerox> 34
16:34:38 <xerox> heh.
16:34:41 <bolrod> hmm
16:35:29 <bolrod> ?google
16:35:29 <lambdabot> Empty search.
16:35:35 <bolrod> ? google IV in decimal
16:35:42 <bolrod> ?google IV in decimal
16:35:44 <lambdabot> http://en.wikipedia.org/wiki/Positional_notation
16:35:48 <bolrod> omg -.-  NOE!
16:36:17 <bolrod> doesn't it like the google calculator?
16:36:23 <ricky_clarkson> I used to use base 32.
16:36:48 <ricky_clarkson> 0-9A-V
16:36:56 <ricky_clarkson> Or A-U, I forgot.
16:37:02 <xerox> L can be preceded only by X ?
16:37:38 <bolrod> 49 = XLIX
16:37:40 <bolrod> I guess
16:38:11 <bolrod> that's what google tells me at least.
16:41:10 <ricky_clarkson> Yes.
16:41:25 <xerox> (Yes to whom?)
16:41:36 <ricky_clarkson> Both.
16:41:40 <xerox> Great.
16:43:34 <xerox> *Romans> roman (undefined :: X (L (I (X O)))) 0
16:43:35 <xerox> 49
16:45:35 <bolrod> it's too warm to sleep ...
16:46:10 <xerox> *Romans> roman (undefined :: L (X (I (V O)))) 0
16:46:11 <xerox> 64
16:46:14 <bolrod> lets randomly turn this fan on... that'd make a difference
16:46:17 * xerox giggles uncontrollably
16:46:42 <xerox> So now C can be preceded only by ...
16:46:52 <bolrod> L
16:46:55 <bolrod> and X maybe..
16:46:55 <ricky_clarkson> X
16:46:59 <ricky_clarkson> Not L.
16:47:07 <bolrod> ;o?
16:47:12 <ricky_clarkson> LC would be the same as L ;)
16:47:17 <ricky_clarkson> 100-50=50
16:48:19 <xerox> So true :-)
16:48:21 <lightstep> why not also I and V?
16:48:35 <xerox> Because of the strictness property?
16:48:51 <lightstep> so they did use a decimal system?
16:50:18 <bolrod> because they are stupid.. and didn't use a proper way to write down numbers?
16:50:45 <xerox> *Romans> roman (undefined :: C (X (X (V (I (I (I O))))))) 0
16:50:46 <xerox> 128
16:51:20 <xerox> *Romans> roman (undefined :: C (C (L (V (I O))))) 0
16:51:20 <xerox> 256
16:52:41 <ricky_clarkson> That's why their empire lasted so long.
16:52:44 <mnislaih> xerox excuse me, I'm a latecomer but, are you doing that manually or are you your own lambdabot ?
16:52:49 <xerox> No LD ?
16:53:08 <xerox> mnislaih: what do you mean?
16:53:12 <ricky_clarkson> xerox: 450 would be CDL I think.
16:53:37 <xerox> Google says CCCCL
16:53:39 <xerox> Uh.
16:53:41 <mnislaih> the lines looking like haskell and the lines looking like the result
16:53:58 <xerox> mnislaih: they are copied and pasted from my ghci to the irc client
16:54:20 <int-e> I agree with CDL
16:54:20 <xerox> ricky_clarkson: what do we take for good?
16:54:21 <lightstep> maybe xerox compiles this to the UM and runs it on a sand computer
16:54:28 <xerox> Eeek.
16:54:30 <ricky_clarkson> xerox: What?
16:54:36 <xerox> CDL or CCCCL ?
16:55:06 <ricky_clarkson> Google says CDL.
16:55:12 <ricky_clarkson> http://www.google.com/search?hl=en&lr=&q=450+in+roman+numerals&btnG=Search
16:55:12 <lambdabot> Title: 450 in roman numerals - Google Search
16:55:27 <xerox> Ah, I was doing "CCCL in decimal" and "CDL in decimal"
16:55:34 <xerox> The latter doesn't work
16:55:54 <int-e> works for me
16:55:55 <ricky_clarkson> Neither works for me.
16:56:07 <xerox> Works now!
16:56:09 <ricky_clarkson> Ah, it's case sensitive.
16:56:14 <xerox> Some Googler is spying us?
16:56:18 * xerox feels naked
16:58:22 <ricky_clarkson> xerox: Next you can implement roman numeral addition, without conversion to decimal.
16:58:36 <ricky_clarkson> That should keep your idle loop happy.
16:58:39 <xerox> And then hang myself.
16:58:55 <int-e> don't get ahead of yourself
16:59:29 <Cale> better yet, multiplication :)
17:00:02 <int-e> Minux (I O) (I O)
17:00:05 <int-e> *Minus
17:00:14 <lightstep> these are finite domains (and small ones, too), you can do it with tables
17:01:32 <Cale> not if you allow arbitrarily many M's
17:01:51 <lightstep> but then you'd have to count them, and multiply with (*)
17:02:08 <xerox> *Romans> roman (undefined :: C (D (L O))) 0
17:02:08 <xerox> 450
17:02:11 <xerox> Puff, pant.
17:02:29 <xerox> Only M left.
17:02:29 <ricky_clarkson> Or implement multiplication as a very long add and subtract loop.
17:02:39 <ricky_clarkson> xerox: So how does your code look?
17:02:43 <lightstep> hmm, is there a way to compute xor in decimal notation?
17:02:56 <xerox> 43 lines.
17:03:01 <ricky_clarkson> xerox: Haha.
17:03:02 <xerox> Let me add M and then I'll paste it.
17:03:30 <Cale> You could still use distributivity to make things easier, just like with ordinary multiplication
17:03:35 <ricky_clarkson> I wrote this in Java, converted both ways, when I was a newbie in Java, in 23 lines total.
17:03:36 <Cale> You'd just be careful about it
17:03:47 <xerox> ricky_clarkson: I am not doing anything "sane"
17:03:55 <xerox> ricky_clarkson: I am encoding this in the type system!
17:04:03 <ricky_clarkson> Ah right, yeah.
17:04:09 <xerox> ricky_clarkson: it is _nothing_ like doing it at value level.
17:04:11 <xerox> OK :-)
17:04:23 <xerox> You saw the onliner :-)
17:04:43 <ricky_clarkson> I did.
17:05:10 <xerox> No IM, VM, XM, LM, CM, DM... it seems.
17:05:20 <xerox> Just one line for M, pheeeew.
17:05:35 <ricky_clarkson> So, say, M (I (M O)) will be a compile error?
17:05:39 <ricky_clarkson> There is CM.
17:05:45 <ricky_clarkson> MCMXCVIII
17:05:49 <xerox> Ah, there is, okay.
17:05:53 <xerox> Is it the only one?
17:06:04 <ricky_clarkson> I believe so.
17:06:13 <ricky_clarkson> Is that right, what I just asked?
17:06:36 <xerox> Hmmm
17:06:40 <xerox> I can make it so
17:06:44 <xerox> Should I?
17:06:54 <xerox> It would be 2001 if I don't
17:07:02 <ricky_clarkson> Dunno, just wondered whether that's what you were doing.
17:07:21 <ricky_clarkson> Oh, 2001 would be bad.  MIM, if it parsed at all, would be 1999.
17:07:24 <Cale> xerox: If anything, it should be 1999
17:07:33 <ndm> xerox: i hope this will end up on the wiki page after its done
17:07:35 <xerox> I'll make it error
17:07:42 <xerox> ndm: yes, I'll add it here:
17:07:48 <xerox> ?wiki User:PaoloMartini
17:07:49 <lambdabot> http://www.haskell.org/haskellwiki/User:PaoloMartini
17:08:01 <xerox> (A bunch of type system hackery i did.)
17:11:38 <xerox> M (I (M O)) is an error
17:11:41 <xerox> Good.
17:12:21 <xerox> Oh
17:12:29 <xerox> Maybe it doesn't even need -fglasgow-exts :)
17:14:05 <xerox> Nah, it does.
17:20:36 <lightstep> xerox, how do you count the Is?
17:20:47 <xerox> I don't
17:20:48 <ndm> grr, if i use forkIO and don't link with -threaded the result is, um, NOTHING!
17:21:00 <ndm> should be a warning or something, a runtime crash would be good
17:22:33 * xerox tried to build a list of powers of two...
17:22:35 <xerox> I need HList :-)
17:23:28 <dons> ndm, i had some memory that forkIO without -threaded was like a function call
17:23:49 <ndm> dons: well it seems the behaviour is nothing, at least in my example
17:24:01 <dons> hmm
17:24:05 * dons checks
17:24:18 <vincenz> > repeat "dons"
17:24:19 <ndm> the function is non-terminating, so i guess it doesn't get called, since the program continues after that
17:24:19 <lambdabot>  ["dons","dons","dons","dons","dons","dons","dons","dons","dons","dons","dons...
17:24:26 <vincenz> everyone "take 1"
17:24:41 <dons> hi vincenz
17:24:52 * vincenz grns
17:24:54 <dons> oh. nothing. now that is interesting
17:25:13 <ndm> indeed, and slightly confusing, esp when you're trying to figure out what the hell is going on!
17:25:15 <dons> but with 6.2.2:
17:25:16 <dons> $ ./a.out
17:25:16 <dons> "done"
17:25:16 <dons> "yes"
17:25:23 <dons> for main = do
17:25:23 <dons>     forkIO $ print "yes"
17:25:23 <dons>     print "done"
17:25:33 <int-e> dons: I've fixed the stack leak in my UM. Interestingly it's now almost as fast with ghc 6.4.2 as with ghc 6.5 on my machine. http://int-e.home.tlink.de/haskell/um5.hs
17:25:41 <ndm> thats odd, a complete change in the semantics
17:25:56 <vincenz> ndm: not really?
17:25:57 <dons> ndm, yes, seems like it happened in 6.4
17:26:11 <xerox> *Romans> powersoftwo
17:26:12 <xerox> [2,4,8,16,32,64,128,256,512,1024,2048]
17:26:15 <dons> ndm, its a corner case, so possibly it just slipped under the radar
17:26:16 <xerox> I think I could say it works :-)
17:26:18 <ndm> vincenz: forkIO x = x vs forkIO x = return ()
17:26:30 <ndm> i'll email off to ghc-bugs
17:26:37 <vincenz> ndm: maybe it doesn't have time to finish the thread before the app kills itself
17:26:45 <dons> vincenz: this is without -threaded
17:26:49 <ndm> vincenz: its a GUI, stays around forever
17:26:57 * vincenz hmms
17:27:07 * dons is so happy to see ndm using threads!
17:27:39 <ndm> dons: wait til you see GuiHaskell :)
17:27:47 * xerox yawns and stretches
17:27:52 <vincenz> ndm: what is it
17:28:03 <Sam__> ndm: does it stick to your fingers?
17:28:16 <ndm> @where WinHaskell
17:28:17 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/winhaskell.php
17:28:29 <ndm> that, but in Gtk2Hs and Haskell, instead of Windows and C
17:29:09 <dcoutts> Sam__, heh ;-)
17:29:46 <xerox> http://www.haskell.org/haskellwiki/User:PaoloMartini#Roman_.28type-.29numerals
17:29:48 <lambdabot> Title: User:PaoloMartini - HaskellWiki
17:29:49 <xerox> Check it out!!
17:31:36 <xerox> ricky_clarkson: there we go.
17:37:22 <dons> ?bot
17:37:22 <lambdabot> :)
17:39:06 <Sam__> @snack
17:39:07 <lambdabot> Unknown command, try @list
17:39:10 <Sam__> hmm.
17:39:28 <dons> ?uptime
17:39:28 <lambdabot> uptime: 20 hours, 18 minutes and 5 seconds
17:45:43 <ndm> dcoutts, how do i figure out when an entry widget has changed?
17:46:09 <dcoutts> ndm, some signal I presume
17:46:15 <ndm> dcoutts, oh, is it insertAtCursor - I keep looking for the wrong names
17:46:59 <dcoutts> ndm, it's some signal on the object or a signal on one of it's parent objects, I'm not sure off the top of my head
17:47:03 <dcoutts> I'd have to look it up
17:47:26 <ndm> dcoutts, ok, i think i have an idea where to look now
17:49:35 <xerox> (lightstep: if you want to see how I did it, check the url I pasted above.)
17:49:47 <Numbers> > data Coord = (Int, Int)
17:49:47 <lambdabot>  Parse error
17:49:53 <Numbers> WHat's wrong with that?
17:50:02 <xerox> You can't define new datatypes in GHCi
17:50:23 <lightstep> xerox, i tried parsing them in systematically, but i'm having trouble with IX and such
17:50:39 <Numbers> xerox: I put it into a file and :l ed it, and it still bombs out.
17:50:52 <xerox> Numbers: that's a syntax error
17:51:26 <Numbers> How so?
17:51:41 <Numbers> Hmm.. I think I see.
17:51:54 <kpreid> Numbers: (x, y) is tuple syntax. You can either define Coord as an alias  (type Coord = (Int, Int)), or do: data Coord = Coord Int Int
17:51:56 <xerox> Numbers: data <TypeConstructor> [<type variables>] = [<DataConstructor1> [...] | <DataConstructor2> [...] | ...]
17:52:19 <xerox> Not exactly, but it gives an idea
17:52:46 <kpreid> or, data Coord = (Int `Comma` Int)
17:52:47 <xerox> lightstep: it breaks on overlapping instances?
17:53:03 <xerox> :comma: maybe?
17:53:16 <lightstep> xerox, i want to make a Units class and parse it alone, same with Tens and Hundreds
17:53:27 <lightstep> and i have trouble deciding what to do with (X n)
17:53:39 <xerox> lightstep: you want to do arithmetic afterwards?
17:53:49 <xerox> But yes, you need context.
18:01:02 <lightstep> do we have higher order classes?
18:01:57 <ndm> lightstep: yes, Monad, although they're higher kinded, technically
18:02:41 <lightstep> no, i meant something like class a b => Member b a where
18:03:38 <xerox> class Foo a b => Bar a b ?
18:03:42 <xerox> (Yes.)
18:03:59 <xerox> I've simplified my code, it always is the case that I add too much... let me post it
18:05:46 <ndm> hmm, threadDelay also seems to have wacked out behaviour
18:05:58 <ndm> although that might be my app's fault
18:06:30 <xerox> Updated.
18:17:54 <Numbers> Is there a way for me to define (+) to operate on two other things?
18:18:03 <Numbers> liek two data types I've defined?
18:19:20 <Twanvl> instance Num MyNewDataType where (+) = ...
18:20:04 <int-e> > let a + b = show a ++ b in 3 + " foo"
18:20:05 <lambdabot>  "3 foo"
18:20:33 <int-e> but that's probably not what you want.
18:27:04 <ndm> woohoo, i have a functional GuiHaskell, you can run hugs and execute commands!
18:28:38 <foxy_> @where ghc-api
18:28:38 <lambdabot> http://www.haskell.org/ghc/
18:37:00 <vincenz> you know what would be cool?
18:37:09 <vincenz> ` syntax for applied terms
18:37:11 <vincenz> something like
18:37:15 <vincenz> `flip ap`
18:37:24 <vincenz> so you can do
18:37:28 * vincenz `flip ap` bed
18:37:41 <Sam__> hahaha
18:37:43 <vincenz> @type ap
18:37:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
18:37:52 <Sam__> you can't hoogle that can you?
18:38:01 <vincenz> @hoogle (Monad m) => m a -> m (a -> b) -> m b
18:38:02 <lambdabot> Prelude.asTypeOf :: a -> a -> a
18:38:02 <lambdabot> Prelude.const :: a -> b -> a
18:38:02 <lambdabot> Prelude.seq :: a -> b -> b
18:38:11 <vincenz> hoogle doesn't like monads
18:38:22 <vincenz> but in general
18:38:25 <vincenz> `flip xxx`
18:38:26 <vincenz> would be neat
18:38:42 <vincenz> and if that's possible
18:38:46 <vincenz> any term between ``
18:39:02 <vincenz> > 2 `subtract` 1
18:39:03 <lambdabot>  -1
18:39:06 <vincenz> > 2 `flip subtract` 1
18:39:07 <lambdabot>  Parse error
18:39:40 <vincenz> > let flipsubtract = flip subtract in 2 `flipsubtract` 1
18:39:41 <lambdabot>  1
18:39:44 <vincenz> not exactly orthogonal :(
18:40:27 <Numbers> @hoogle Int -> [Int]
18:40:28 <lambdabot> No matches, try a more general search
18:41:03 <vincenz> > repeat 1
18:41:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:41:17 <Numbers> Heh
18:41:29 <Numbers> Is there anythign that will turn 5 into [0,1,2,3,4] ?
18:41:29 <vincenz> > enumFrom 1
18:41:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:41:36 <vincenz> > enumFromTo 0 5
18:41:37 <lambdabot>  [0,1,2,3,4,5]
18:41:49 <vincenz> > let f n = [0..n] in f 5
18:41:50 <lambdabot>  [0,1,2,3,4,5]
18:42:06 <Numbers> Keen.
18:42:09 <vincenz> > take 5 $ enumFrom 0
18:42:10 <lambdabot>  [0,1,2,3,4]
18:50:30 <dons> ?karma+ vincenz -- answering questions
18:50:31 <lambdabot> vincenz's karma raised to 8.
18:52:27 <dons> oh, we've recently passed our 2 millionth line of text in #haskell
18:52:29 <dons> we missed that :)
18:52:47 <dons> about 10 days ago
18:53:34 <Sam__> dons: you know, there are gaps in logs anyway...
18:53:49 <Dr_Pi> Is there a web site where I can download haste?
18:57:43 <dons> Sam__: well there are.
18:57:45 <dons> ?where haste
18:57:46 <lambdabot> http://haste.dyndns.org:8080/
18:58:03 <dons> Dr_Pi, perhaps? otherwise you'll have to contact the authors via email
19:01:04 <Dr_Pi> dons: Yeah, that web site doesn't work. I wanted to experiment with EclipseFP, but to make a long story short that only works with Mac OS 10.4 and I have 10.3 and I don't feel like upgrading.
19:05:26 <foxy_> I get "cbits/directory.c:3:41: ../../../includes/ghcconfig.h: No such file or directory" when building ghc 6.5 on mingw, anyone building this combination?
19:05:44 <dons> missing -i path?
19:08:15 <foxy_> where?
19:42:59 <dons> ?remember ghc error: unable to find a register to spill in class `GENERAL_REGS'
19:43:00 <lambdabot> Done.
19:43:22 <dons> oh, that's a gcc error !
19:43:31 <dons> ghc breaks gcc, again!
19:43:33 <dons> ?karma+ ghc
19:43:34 <lambdabot> ghc's karma raised to 1.
19:54:46 <Sam__> @quote ghc
19:54:47 <lambdabot>  Exotic pattern inside meta brackets
19:54:52 <Sam__> @ghc
19:54:52 <lambdabot>  Illegal overloaded type signature(s)
19:54:55 <Sam__> @quote ghc
19:54:55 <lambdabot>  Can't splice the polymorphic local variable
19:54:58 <Sam__> @ghc
19:54:59 <lambdabot>  No explicit method nor default method
19:55:02 <Sam__> @ghc
19:55:03 <lambdabot>  Illegal polymorphic type
19:55:04 <Sam__> @ghc
19:55:05 <lambdabot>  Illegal unboxed tuple type as function argument
19:55:15 <Sam__> @ghc
19:55:16 <lambdabot>  Pattern bindings (except simple variables) not allowed in instance declarations
19:55:37 <Sam__> @ghc
19:55:38 <lambdabot>  Exotic pattern inside meta brackets
19:55:47 <Sam__> what is an exotic pattern?
19:56:44 <dons> soemthing weird, I guess
19:57:05 <SamB_XP> dons: well yeah!
19:58:07 <dons> ;)
19:58:50 <SamB> oh, you might be interested in pulling, building and sandmarking my UM again. I think it is faster now...
19:59:25 <dons> ok. yes, i want to rerun them all under identical conditions
19:59:51 <dons> the C one, or haskell one?
20:00:32 <dons> i'm writing a new um too:
20:00:33 <dons>         b  = word 7# & w >.> 3#
20:00:33 <dons>         a  = word 7# & w >.> 6#
20:00:39 <dons> is part of my secret plan
20:00:46 <dons> eval :: [Int] -> Heap -> Addr# -> Addr# -> Int# -> IO ()  -- ;)
20:01:28 <SamB_XP> the Haskell one ;-)
20:01:44 <dons> good!
20:01:52 <dons> that's what I'm really interested in
20:02:29 <SamB_XP> I'm not even going to bother with the C one, I don't even really have a clue why it is apparantly slower than edwardk's. I could chalk it up to noise, or random GCC lameness
20:02:43 <SamB_XP> or maybe structs are faster than icky pointers ;-)
20:03:05 <dons> SamB_XP: I'm a bit suspicious about edwardk now. I can't reproduce the 53s speed
20:03:13 <SamB_XP> oh really?
20:03:17 <dons> I think maybe it was a gcc version I tried, and abandoned
20:03:30 <dons> since ever since it runs around 1% slower than yours and one other
20:03:38 <SamB_XP> really???
20:03:48 <dons> they all come in around 60s
20:04:00 <dons> anyway, i have to rerun them all
20:04:03 <SamB_XP> cool. so maybe that offset I was trying to avoid really *does* cost something ;-)
20:04:09 <dons> and specify precisely the flags
20:13:33 * Numbers is having some trouble here.   I have an data Type 'Coord Int Int' that I want to define scalar multipication for    so I have like instance Num Coord where (*) (Coord x y) a = (Coord (x*a) (y*a))
20:13:37 <Numbers> But it isn't working..
20:15:19 <Cale> Numbers: (*) :: (Num a) => a -> a -> a
20:15:32 <Cale> You'll have to give scalar multiplication another symbol.
20:15:45 <Numbers> Oh.
20:15:47 <Numbers> OK.
20:16:00 <Numbers> (+) (Coord x y) (Coord a b) = (Coord (x+a) (y+b))
20:16:04 <Numbers> That worked good.
20:16:06 <Cale> yeah
20:16:18 <Numbers> So I was confused, I guess.
20:16:23 <Cale> You could do componentwise multiplication, or complex multiplication
20:16:33 <Numbers> I see.
20:16:56 <Cale> (Coord a b) * (Coord c d) = Coord (a * c - b * d) (a * d + b * c)
20:17:13 <Cale> note that you can write (Coord x y) + (Coord a b) = Coord (x+a) (y+b)
20:17:38 <Cale> It's smart enough to determine that you're defining +
20:17:38 <Numbers> Oh yeah?
20:17:43 <Numbers> COol.
20:21:05 <Cale> btw, you could use my definition of multiplication there, and use values of the form Coord a 0 to do scalar multiplication, but this doesn't generalise terribly well to higher dimensions (though you can get things happening for dimensions which are powers of two)
20:21:08 <foxy_> @where Cabal
20:21:08 <lambdabot> http://www.haskell.org/cabal
20:22:09 <foxy_> What Cabal is required to build GHC 6.5?
20:27:51 <Numbers> Cale: You could in theory define a fromInteger as x = Coord x 0 then do the scalar ignoring the 'y', but that's not very.... Good.
20:32:37 <Numbers> @pl wallcoords (Wall wf crd len) = (map (scaleCoord (coorDir (wallDir wf))) (take len $ enumFrom 0))
20:32:37 <lambdabot> (line 1, column 30):
20:32:37 <lambdabot> unexpected "="
20:32:37 <lambdabot> expecting variable, "(", operator or end of input
20:33:09 <Numbers> @pl (map (scaleCoord (coorDir (wallDir wf))) (take len $ enumFrom 0))
20:33:09 <lambdabot> map (scaleCoord (coorDir (wallDir wf))) (take len [0..])
20:34:05 <Cale> Numbers: actually, that would work fine
20:34:31 <Cale> Numbers: It would work exactly the same as the Complex type constructor in the libraries :)
20:34:40 * Numbers laughs.
20:34:47 <Numbers> THis way is fine, it seems.
20:36:16 <Numbers> @pl map ((+) crd) (map (scaleCoord $ coorDir $ wallDir wf) (take len [0..]))
20:36:17 <lambdabot> map (crd +) (map (scaleCoord (coorDir (wallDir wf))) (take len [0..]))
20:43:32 <Numbers> @pl (\x y -> (Coord x y))
20:43:33 <lambdabot> Coord
20:43:38 <Numbers> THought so.
20:48:12 <foxy_> dons, do you want ghc-api to be builtin to Yi or loadable as a plugin?
20:48:48 <foxy_> @seen dons
20:48:48 <lambdabot> I saw dons leaving #haskell-overflow and #haskell 17 minutes and 58 seconds ago, and .
21:43:32 <edwardk> ok.
21:43:39 <edwardk> i finally got the problem with my jit =/
21:44:00 <edwardk> it was just an extra Maybe, because unsafeEval can't fail the cast, so it doesn't return Maybe foo in the unsafeEval_ case =)
21:44:06 <edwardk> @paste
21:44:07 <lambdabot> http://paste.lisp.org/new/haskell
21:44:22 <lisppaste2> edwardk pasted "whee autogenerated code" at http://paste.lisp.org/display/23334
21:55:59 <dons> ah, good :)
21:56:03 <edwardk> heh
21:56:07 <edwardk> its sloooooow though
21:56:10 <edwardk> =)
21:56:32 <dons> i've finally got my fully unboxed um going
21:56:36 <dons> just need to profil
21:56:36 <dons> e
21:56:39 <edwardk> i.e. i am compiling jump #6 of decoded.um =)
21:56:49 <dons> :}
21:56:51 <edwardk> and i've been at it for 40 seconds =)
21:57:08 <dons> yeah, i think perhaps invoking ghc on each jump may not be optimal ;)
21:57:12 <edwardk> heh
21:57:26 <edwardk> well, i have code that can try to speculatively compile
21:57:32 <edwardk> but each compile is pretty dog slow
21:57:51 <edwardk> most of the little ones don't suck
21:58:02 <edwardk> but i think ghc has some non-linear analyses it does.
21:58:11 <edwardk> because the times slow exponentially with the growth of my functions
21:58:31 <edwardk> as you can see from that paste, they tend to be fairly log
21:58:32 <edwardk> er long
22:00:10 <edwardk> sandmark i make pretty handy progress through until i crash.
22:00:35 <edwardk> thats in the init process, but it at least feels speedier
22:01:18 <edwardk> kinda sad that it doesn't compile faster. i've got some slick optimizations generating the code
22:01:59 <dons> looks nice. it could probably do with some strictness, though. to unbox all those values
22:02:06 <edwardk> *nods*
22:02:17 <edwardk> best way to sneak strictness annotations in there?
22:03:45 <edwardk> i do like the fact that i only write the variables to the registers at the end of the loop, etc. but i don't think ghc is designed to deal with 150 local variables in a sugared monadic computation
22:03:54 <edwardk> not efficiently
22:04:06 <dons> well, with ghc 6.5 you could just add ! to the binds
22:04:12 <dons> and then use -funbox-strict-fields
22:04:28 <edwardk> then i have to get hslugins working on 6.5
22:04:34 <edwardk> there is something with AltData.Typeable iirc
22:04:42 <seafood> dons: Is there some documentation about the new ! functionality in ghc 6.5?
22:04:59 <dons> yeah. i think its in the new docs
22:05:12 <dons> edwardk: right. you need to include the 6.4.2 header for Typeable.h
22:05:29 <edwardk> can you send me a copy?
22:05:50 <dons> you don't have 6.4.2?
22:06:05 <dons> add -I/home/dons/l
22:06:07 <edwardk> or is it in a headers dir or something in a binary install?
22:06:32 <dons> add -I/home/dons/lib/ghc-6.4.2/include/
22:06:39 <dons> to your plugins.cabal ghc-options line.
22:06:47 <edwardk> FOUND IT
22:06:48 <dons> and change the includes to have: includes:             Linker.h Typeable.h
22:06:52 <edwardk> er found it
22:06:53 <edwardk> caps
22:06:54 <dons> then rebuild
22:13:06 <edwardk> kinda sad about the compile speed though
22:14:00 <edwardk> half tempted to have it generate NASM or something instead ;)
22:16:19 <edwardk> oh thats a new one
22:16:30 <edwardk> moving to 6.5 my first compile blows up with Main: user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
22:16:53 <dons> that's nice :)
22:17:01 <edwardk> 6.4.2 works fine
22:17:06 <dons> this is the fun part of haskell
22:17:11 <jmob> Is it possible to write a "split" function with takeWhile?  Where split: (split ".:" "123.:456.:789") => ["123", "456", "789"] ?
22:18:09 <edwardk> i just need to figure out why i'm failing the 0-array allocation in sandmark
22:18:25 <edwardk> i think 6.5 is a loss for me for now
22:20:36 <edwardk> are there any flags i can pass to ghc to speed the compilation of eval'd code?
22:22:24 <dons> -fasm -Onot ?
22:22:32 <dons> but these are used by default, I'm pretty sure
22:22:41 <edwardk> shucks
22:23:04 <edwardk> it mostly seems to choke on the long monad computation
22:23:20 <edwardk> coz this stuff is a lot more linear than the average haskell program
22:24:26 <jmob> @pl join x ls = foldr (++) "" (intersperse x ls)
22:24:27 <lambdabot> join = (foldr (++) [] .) . intersperse
22:24:29 <edwardk> the funny part is if i can GET sandmark to run it should run pretty fast once the first iteration is over
22:39:35 <dons> yay, i finally beat sjannsen's haskell um :)
22:39:36 <dons>  just
22:39:45 <edwardk> heh
22:40:25 <dons> but now this method actually works (unboxed, strict everything) i should be able to tune it further
22:40:27 <edwardk> he actually has a bug in there btw
22:40:40 <dons> yeah, someone said
22:40:46 <dons> what was it again?
22:40:50 <Korollary> What is with these haskell programs with bugs...
22:40:56 <dons> heh
22:41:03 <edwardk> if you go to allocate an array of length 0 and get it from the freelist it can blow up
22:41:05 <falconair_> is the STM library available in hugs (not just GHC)?
22:41:11 <Korollary> falconair_: no
22:41:19 <dons> don't think so. falconair_. it needs runtime support, which hugs doesn't have
22:41:29 <falconair_> crap
22:41:50 <dons> falconair_: why do you want hugs?
22:42:00 <Korollary> hugs and concurrent stuff are not a great match anyway
22:42:16 <edwardk> dons: maybe he had a bad day? =)
22:42:32 <falconair_> I'm on OS X (intel), and GHC is not available through the port system ...
22:42:42 <Korollary> right
22:42:45 <dons> oh, you'll just have to build it yourself.
22:42:55 <falconair_> isn't there someone who knows both darwinports and ghc, and quickly put together a port for intel?
22:43:01 <Korollary> I thought ghc osx intel had some build problems.
22:43:12 <dons> theres heaps of mac users though, using ghc under rosetta (is that it?)
22:43:14 <falconair_> I'm new to OS X, ghc, port....basically everything involved :)
22:43:20 <dons> there must be 10 in this channel at least
22:43:27 <Korollary> check haskell-cafe
22:43:27 <dons> seafood: ping?
22:43:36 <edwardk> btw dons, i still can't believe it took me 2-3 days to figure out that i had an extra Maybe in the definition for the unsafeEval return value
22:43:38 <dons> seafood: you use ghc on an x86/osx box?
22:43:43 <dons> edwardk: ah well :)
22:44:12 <edwardk> i actually gutted and rebuilt the thing from the ground up afraid it had something to do with my weird rotated fixed point stuff
22:44:36 <falconair_> darwin ports gets source code then compiles it on a local machine...is there a way to force the compiler to compile to ppc (so it uses rosetta)?
23:08:56 <edwardk> woohoo, it seems content to try to slog through sandmark =)
23:09:28 <edwardk> waiting for it to finish compiling round 1
23:10:13 <edwardk> i almost want to figure out a way to cache all of the compiles in object file some how so subsequent runs get faster
23:10:40 <edwardk> maybe hash the eval source and make a filename off it
23:10:47 <edwardk> check if its there, then load or compile if not
23:13:14 <dons> should be reasonable to cache the objects -- hsp does this
23:13:26 <dons> you get a uniq for each object, and are able to write them to a dir.
23:13:34 <dons> then its a matter of mapping source to filename
23:13:55 <edwardk> yeah
23:14:35 <edwardk> maybe even slap together something to aggregate the loads
23:15:01 <edwardk> if i write out the text i'm compiling to a log file, i could go back afterwords, and prepopulate my jit table =)
23:15:15 <edwardk> might actually run some time this century
23:15:43 <edwardk> i'm still waiting for 100 to show up =)
23:15:46 <edwardk> on the sandmark
23:15:57 <edwardk> its slogging away, working its ass off
23:17:18 <edwardk> its rather funny watching the code go by, because i optimize away so many of the misc. register settings, its actually almost reasonable code
23:17:53 <edwardk> this does make me think twice about wanting to use this for eval behaviors in javascript though
23:18:04 <edwardk> coz this code output is comparatively simple
23:20:03 <edwardk> tempted to try removing the monads from the compiled code and see if that helps
23:20:52 <dons> it shoudl
23:21:19 <edwardk> problem is the resulting compiler won't be any fun =)
23:21:27 <dons> heh
23:23:56 * edwardk twiddles his thumbes waiting for the 100 to popup on his sandmark =)
23:24:28 <edwardk> 15 minutes and i'm still at 'loadprog ok' =)
23:26:15 * edwardk somehow thinks that haskell doesn't have a future as a JIT generator =)
23:27:51 <lisppaste2> edwardk annotated #23334 with "Longest one yet" at http://paste.lisp.org/display/23334#1
23:29:08 <dons> edwardk: hmm. perhaps...
23:29:18 <dons> but then again, if java can do it
23:29:35 <dons> and ghci, for example, spits out bytecode rather nicely
23:29:48 <edwardk> well, they don't go through the whole java parsing process. the jit is all backend stuff
23:29:57 <dons> perhaps 'system ghc' shouldn't be used a jitter
23:30:05 <dons> ;)
23:30:05 <edwardk> its done on the jvm and the jvm is braindead simple.
23:30:09 <edwardk> heh
23:30:11 <edwardk> fair enough
23:30:36 <edwardk> if nothing else, this has made me REALLY comfortable with nested monads, lifting, monad transformers, etc.
23:31:14 <edwardk> and i learned a new trick for me, for how to 'rotate' the fixed point away from the stuff i want once i fixpoint a recursive type
23:32:01 <eivuokko> What are you "JIT"ing?
23:32:31 <dons> i'm not sure you really want to find out ... ;)
23:32:33 <edwardk> the UM =)
23:32:39 <edwardk> from the icfp contest
23:33:01 <eivuokko> And you generate haskell?  Why not asm?
23:33:02 <dons> for FUN!
23:33:11 <edwardk> mostly to see if i can do it
23:33:12 <edwardk> =)
23:33:15 <dons> yeah, asm might be more viable in the longer term
23:33:18 <dons> or just C
23:33:22 <dons> but now there's a prototype!
23:33:26 <eivuokko> I thought about making UM compiler for fun, and as an example of my asm stuff.
23:33:30 <edwardk> and because i'm going to be generating haskell from javascript so i wanted to have something easy to do first
23:33:37 <dons> eivuokko: that would be cool, actually
23:34:32 <lisppaste2> edwardk annotated #23334 with "well, it does sorta run" at http://paste.lisp.org/display/23334#2
23:34:57 <eivuokko> dons, Compiling/code generation always is? ;)
23:35:05 <edwardk> i really just want to see how it runs when it gets to loop
23:35:13 <edwardk> which so far its never been able to do =(
23:35:14 <jgrimes> edwardk, wow that is pretty cool, having a jit produce haskell
23:36:09 <jgrimes> but I am continually amazed by things in fp, so... :)
23:36:51 <edwardk> posting it up so dons can add it to his competition or optimize  it or something ;)
23:37:01 <dons> or something, eh?
23:37:12 <edwardk> wow i don't want to think about the amount of memory this thing is sucking down right now
23:37:17 <edwardk> my web server is dying
23:37:49 <edwardk> 400 meg or so
23:38:06 <edwardk> hovering nice and steady around there
23:41:40 <falconair_> when I try to install GHC on os x intel, using Audrey Tang's build on X86GHC Trac, I get the following error:
23:41:48 <falconair_> "/Library/Frameworks/GMP.framework/Versions/A/GMP: mach-o, but wrong architecture"
23:42:14 <falconair_> i just ran the configure script then did "sudo make install" ... any know what's going on?
23:42:32 <edwardk> http://slipwave.info/index.php now has the JIT code on it
23:43:22 <edwardk> i'd rather generate x86-64 assembly or something. then no register starvation and i can fit the whole um in nicely
23:43:33 <seafood> falconair_:  Do you want an intel binary for GHC 6.5?
23:44:04 <falconair_> seafood: yeah, i just want to run GHC on my OS X intel machine, binary or assistance in compiling from source, doesn't matter
23:44:18 <bdash> falconair_: it sounds like you have a PowerPC version of GMP.framework
23:44:39 <falconair_> i don't know what the GMP framework is, how can I get the intel version?
23:46:08 <bdash> falconair_: what output do you get from `file /Library/Frameworks/GMP.framework/Versions/A/GMP' ?
23:46:52 <seafood> falconair_: http://www.uni-graz.at/imawww/haskell/ghc-6.5.20060409-i386-apple-darwin.tar.bz2
23:47:22 <seafood> And then there's these instructions on the wiki: http://www.haskell.org/hawiki/HaskellOnMac
23:47:24 <lambdabot> Title: HaskellOnMac - The Haskell Wiki
23:47:41 <seafood> I've also had success building it from source but that's a little more difficult.
23:48:10 <falconair_> seafood, i see that file on ghcx86 page as well, according to the page Tang's file is supposed to be simpler, i'll try this one as well i gues
23:48:34 <seafood> falconair_: Good luck
23:48:40 <falconair_> thanks :)
23:48:53 <seafood> I'll be around for help if you need it.
23:49:06 * dons pays careful attention to unboxing, with good results
23:49:15 <dons> oh, and a ghc codegen bug now..
23:50:42 <falconair_> what exactly is the GMP.framework, is it referring to the math library?
23:51:27 <edwardk> GMP == GNU MP, no? its used as part of the arbitrarily larged integer support in haskell.
23:51:38 <edwardk> > 2^88
23:51:39 <lambdabot>  309485009821345068724781056
23:51:47 <bdash> yeah, GNU Multiple Precision Arithmetic Library
23:51:49 <dons> > 2^188
23:51:51 <lambdabot>  392318858461667547739736838950479151006397215279002157056
23:51:54 <edwardk> etc
23:51:54 <dons> yay for gmp
23:51:59 <edwardk> yeah
23:52:10 <edwardk> used it in my own language projects for the same reason
