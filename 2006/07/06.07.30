00:04:46 <paj> Yeah.  I had a similar experience with the permutation parsers.
00:11:14 <Stinger_> dons printscr? :)
00:18:31 <dons> cool, foxy, http://www.cse.unsw.edu.au/~dons/tmp/screenshot.jpg
00:18:48 <vincenz> croikey
00:20:47 <lispy> dons: nice work
00:20:58 <dons> that's all foxy's work :)
00:21:09 <dons> yi on windows, with syntax highlighting :)
00:21:12 <lispy> foxy: nice work
00:21:17 <dons> oh, and tabs?
00:21:22 <lispy> yeah
00:21:24 <lispy> cool!
00:21:55 * lispy had a pretty strong urg to make an angband clone in haskell this weekend but went to the big city instead
00:22:17 <lispy> that's why i wanted an ncurses lib
00:39:07 <foxy_> dons, I can't wait to edit Yi source from within Yi with the help of GOA !!!
00:47:19 <edwardk> ok. well, i can sandmark in 20 seconds now, but i don't think it counts =)
00:47:57 <dons> yes?
00:48:29 <edwardk> it takes at least an hour for the jit to run through the program the first time.
00:48:29 <edwardk> =)
00:48:43 <edwardk> after that, its got all the object files around and loads back up quickly
00:48:53 <dons> 20s is pretty cool though ;)
00:48:57 <edwardk> heh
00:48:58 <edwardk> yeah
00:49:03 <dons> so just turn that into a 'static pass' ;)
00:49:07 <edwardk> heh
00:49:14 <edwardk> claim that is 'compilation'? =)
00:49:27 <edwardk> since its compile time it can't count against me, no? =)
00:49:44 <edwardk> i'm actually doing both jit and evaluation in the code
00:49:48 <dons> yes, i agree with this view
00:49:49 <int-e> hmm. I can do better than that. 'compile': um sandmark.umz > sandmark.o 'run': cat sandmark.o :-P
00:49:51 <edwardk> i jit everything that is used more than x times.
00:50:26 <edwardk> the evaluator keeps track of 'hotspots' in the loaded program
00:50:52 <edwardk> and then when they get too hot it starts a jit on the surrounding chunk of code.
00:51:46 <edwardk> i could probably speed it up a bit more, but i don't want to wait for it to recompile =)
00:52:00 <int-e> how does it invalidate code? or doesn't it?
00:52:11 <edwardk> it doesnt have to, no smc is used =)
00:52:13 <roconnor> edwardk: what do you compile to?
00:52:31 <edwardk> i have perl compiling down to "Inline C" then dynamically load that
00:52:41 <int-e> I see. could as well write an UM2C then :)
00:53:08 <edwardk> the problem is the "Inline C" wrapper is about as snappy as hsplugins while its compiling though =)
00:53:38 <edwardk> the advantage it has is that once it compiles i can use globals to store the registers, etc.
00:54:03 <roconnor> dons: does your SANDmark machine have two processors.  One could compile while the other interperates.
00:54:04 <edwardk> int-e: can't, unfortunately, they load code pages at least once per um file.
00:54:25 <edwardk> int-e: and I can't get a c compiler to compile a full um program =)
00:54:31 <edwardk> they are too big translated word for word into c
00:55:40 * tessier raps with Stephen Hawking o/~ Play times over, I got a job to do. And the world will be less crowded when I'm through. I'll keep rolling as the bullets fly cuz all my shootings be drive-by's. o/~
00:56:09 <edwardk> i want to do that actually, but the perl Inline stuff doesn't play well with multithreading
00:56:18 <edwardk> er multiprocessing
00:56:38 <edwardk> i could manually sync up after it dispatched in one thread and tell the other main thread its ok to try to load that fragment
00:56:48 <edwardk> but thats a load of hoops to jump through
00:57:11 <edwardk> s/thread/process/g
00:58:18 <edwardk> the last major remaining speed up would be to modify new jit fragments to link directly to pre-existing jit fragments rather than trampolining out to a dispatcher.
00:58:41 <edwardk> but then i can't cache as well, because i need to add the list of fragments i depend on to my cache somehow
00:59:30 <edwardk> that and i don't have tail-call optimization in c.
01:00:00 <edwardk> i had to hack up the perl inline c stuff to make this work though. i wrote a 'psychic' parser so it wouldn''t waste all of its time in recursive descent.
01:00:08 <tessier> tail-call optimization in C involves the dreaded GOTO doesn't it?
01:00:12 <edwardk> yeah
01:00:19 <edwardk> i get that within a chunk
01:00:25 <edwardk> but not across chunk boundaries.
01:04:53 <edwardk> i'm also half tempted to simplify the jit a little, and make it just jit when asked (hit ^C to start watching, ^C to stop watching and jit everything seen)
01:05:05 <edwardk> would let it skip things like the preamble to the sandmark =)
01:10:20 <edwardk> http://slipwave.info/icfp/jit/jit.pl etc are up on slipwave.info
01:10:36 <edwardk> i hereby wash my hands of this obsession =)
01:11:13 <edwardk> though, i must admit, there is another cool way to do it
01:11:13 <dons> well done!
01:11:42 <edwardk> i could hard code a new opcode to be 'go to the jitted version'.. and then just replace code as needed.
01:12:11 <edwardk> where that opcode turns the next word into an address to jump to.
01:13:21 <int-e> haha.
01:13:24 <int-e> # and compile in my lifetime
01:13:35 <edwardk> heh
01:13:48 <edwardk> that was part of a running commentary of options that used to be there =)
01:14:48 <edwardk> if nothing else, it serves as a good demonstration of how to (ab)use Inline::C
01:15:10 <edwardk> thought about Inline::ASM, but decided i wanted to be able to walk away from this some day
01:15:38 <edwardk> and the real bottleneck at this point is all the boilerplate crap they use in the Inline::ASM kit.
01:16:22 <edwardk> it could be made faster in pure c generating the source file directly and not spawning several processes that run Makefile.PL, etc to compile everything
01:16:47 <edwardk> woops
01:16:51 <edwardk> i forgot the c header
01:18:32 <edwardk> so now to turn this exercise into an object lesson for my javascript compiler, and learn from it =)
01:26:07 <jmob> :paste
01:26:11 <jmob> @paste
01:26:12 <lambdabot> http://paste.lisp.org/new/haskell
01:26:50 <lisppaste2> jmob pasted "syntax" at http://paste.lisp.org/display/23370
01:27:05 <jmob> Anyone care to explain what's wrong with my syntax there?
01:27:06 <edwardk> the else is outdented too far
01:27:18 <edwardk> its a quirk of the do-syntax
01:27:33 <edwardk> the else has to be intended deeper than the if
01:28:07 <jmob> Hrmm, that's odd
01:28:07 <edwardk> i think with -fglasgow-exts that might get relaxed, but i''m not sure. it was mentioned as something to probably support uniformly in haskell'
01:28:44 <edwardk> thats why when you see if's used in do loops typically they have the then clause down one line and indented and the else clause down and indented the same distance.
01:29:25 <jmob> I wonder if my uber smart emacs could figure that out
01:30:08 <lispy> if  your uber smart emacs uses the normal haskell-mode i don't thnik so
01:30:15 <edwardk> no idea. i stopped using emacs when someone wired it up to a coffee machine to prove a point =)
01:30:25 <dons> here's an example, jmob
01:30:27 <dons> if x == y
01:30:27 <dons>     then do putChar 'x'
01:30:27 <dons>     else do c <- getChar
01:30:27 <dons>             putChar (toUpper c)
01:30:29 <dons>             return ()
01:30:38 <dons> though strictly you don't need the first 'do' there
01:31:11 <dons> ?pretty if x == y  then do putChar 'x' else do z
01:31:11 <lambdabot> "Parse error" at column 1
01:31:14 <dons> ah well
01:31:25 <lispy> we have a pretty printer now?
01:31:36 <dons> ?pretty f x y = if x == y  then do putChar 'x' else do x
01:31:36 <lambdabot>  f x y = if x == y then do putChar 'x' else do x
01:31:40 <dons> heh
01:31:42 <edwardk> ?pretty if x == y then do {putChar 'x'} else do z
01:31:43 <lambdabot> "Parse error" at column 1
01:31:47 <dons> ?pretty f x y = if x == y  then do putChar 'x'; return z else do x
01:31:47 <lambdabot>  f x y  = if x == y then
01:31:48 <lambdabot>          do putChar 'x'
01:31:48 <lambdabot>           return z
01:31:48 <lambdabot>          else do x
01:31:52 <dons> sort of
01:31:52 <edwardk> ah
01:31:57 <dons> but the indenting is a bit munged :/
01:32:04 <lispy> yeah :(
01:32:09 <dons> it just uses Language.Haskell, which isn't the best
01:32:32 <lispy> then on that note i'll go to sleep
01:32:42 <lispy> good night!
01:32:43 <jmob> maybe if I did IRC through emacs I could get syntax hylighting for literate code
01:33:06 <dons> you could install lambdabot locally, and just bind to its ghci interface
01:33:11 <dons> that would be nice
01:33:30 <jmob> ghci wont' run on mac osx unfortunately
01:33:32 <dons> hmm. does emacs/irc do syntax hl?
01:33:39 <dons> jmob: since when?
01:33:45 <dons> its worked in the past.
01:33:53 <jmob> dons: since I tried to compile it and it blew up! :(
01:33:59 <dons> hmm.
01:34:03 <jmob> 6.4.2 would compile out of the box.
01:34:07 <jmob> wouldn't even
01:34:07 <dons> i'm sure we _think_ its supposed to work.
01:34:20 <lispy> jmob: hm...i do use emacs for irc but that idea never occured to me :)
01:34:21 <dons> and i've not heard complaints. hmm. i'll have to investigate a bit
01:34:59 <jmob> dons: building a trunk snapshot got farther, but still bailed on something called genprimopcode
01:35:32 <lispy> i'm not sure if you could get emacs to do syntax highlighting during irc...i think they are both major modes and hence incompatible
01:38:14 <jmob> lispy: yeah, I've never hacked on emacs, so I wouldn't know, I was hopeful that it -should- be possible, one would think that the syntax highlight machinery is modular enough that you could turn it on on line basis
01:40:04 <dmhouse> Good morning, all.
01:41:06 <lokadin_> say what was that funciton that converts String to Numbers?
01:41:22 <jmob> read?
01:41:27 <lokadin_> really?
01:41:33 <lokadin_> kk
01:41:35 <lokadin_> i'll try that
01:41:43 <dmhouse> ?type read
01:41:45 <lambdabot> forall a. (Read a) => String -> a
01:41:53 <dmhouse> And Int is an instance of Read, so it works.
01:42:11 <lokadin_> cool
01:42:26 <lokadin_> hmmm how do i declare PortNumber an instance of Read?
01:42:48 <lokadin_> i can look it up
01:43:18 <jmob> Try (read somestring :: Int)
01:43:34 <dmhouse> @instances Read
01:43:36 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
01:43:45 <dmhouse> @index PortNumber
01:43:46 <lambdabot> Network, Network.Socket, Network.BSD, Network
01:43:52 <dmhouse> @instances-importing Network Read
01:43:54 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
01:48:57 <dons> > map seq [1,2,undefined,3]
01:48:58 <lambdabot>  Add a type signature
01:49:13 <dons> > map (\x -> seq x x) [1,2,undefined,3]
01:49:16 <lambdabot>  Undefined
01:49:25 <dons> > map (id) [1,2,undefined,3]
01:49:27 <lambdabot>  Undefined
01:49:41 <dons> > length [1,2,undefined,3]
01:49:43 <lambdabot>  4
01:49:52 <dons> > take 2 $ map (id) [1,2,undefined,3]
01:49:53 <lambdabot>  [1,2]
01:50:05 <dons> > take 2 $ map (\x -> seq x x) [1,2,undefined,3]
01:50:06 <lambdabot>  [1,2]
01:50:18 <dons> dmhouse: your 'id' question is interesting
01:50:37 <dmhouse> dons: indeed.
01:51:03 <dons> > last $ map (\x -> seq x x) [1,2,undefined,3]
01:51:04 <lambdabot>  3
01:51:37 <dmhouse> That last one's interesting.
01:51:49 <dmhouse> > last $ map id [1,2,undefined,3]
01:51:50 <lambdabot>  3
01:51:54 <int-e> seq x x = x for all purposes, I think.
01:52:05 <dmhouse> int-e: But it evaluates x first, right?
01:52:15 <int-e> only if its result is forced
01:52:22 <dons> ah yes
01:52:36 <int-e> seq x x = force x if forced, then force x (woops, that does nothing)
01:53:07 <dons> ?pl \x -> seq x x
01:53:07 <lambdabot> join seq
01:53:10 <dmhouse> ;)
01:54:59 <dons> id :: a -> a
01:55:02 <dons>   {- Arity: 1 HasNoCafRefs Strictness: S Unfolding:  (\ @ a x :: a -> x) -}
01:55:23 <dmhouse> Where's that from?
01:55:29 <dons> the .hi file for Base.lhs
01:55:45 <dons> ?index seq
01:55:45 <lambdabot> Prelude, Control.Parallel
01:56:01 <dons> export GHC.Prim seq
01:56:07 <dons> :/
01:56:36 <dons> which has no iface to inspect
01:56:37 <dmhouse> Yes, well, ?index isn't going to say 'GHC.Prim', is it.
01:56:52 <dons> well, i guess it makes sense that seq isn't defined in any haskell source..
01:57:02 <dmhouse> Heh, true. seq is _primitive_, after all :)
01:57:21 <dmhouse> But it doesn't have an iface?
01:57:25 <int-e> but maybe it could be done by faking a hi entry with two strict arguments?
01:57:29 * int-e giggles
01:57:45 <dmhouse> I can understand it not having source, but I'd expect it'd still need an iface for imports to work.
01:57:46 <dons> well, I suppose if I wrote f = seq, and exported that..
01:58:26 <int-e> the monomorphism restriction will come and haunt you.
01:58:27 <int-e> :)
01:58:46 <dmhouse> :)
01:58:51 <dmhouse> f x y = seq x y, then.
01:59:04 <dons> ah ha,
01:59:05 <dons> f :: a -> bx -> bx
01:59:06 <dons>   {- Arity: 2 HasNoCafRefs Strictness: SS
01:59:06 <dons>      Unfolding: (\ @ bx @ a tpl :: a tpl1 :: bx ->
01:59:06 <dons>                  case @ bx tpl of tpl2 { DEFAULT -> tpl1 }) -}
01:59:21 <dons> it turned into a case!
01:59:21 <dmhouse> Right, there are different levels of strictness, that's what I expected.
01:59:30 <dons> good old STG semantics
01:59:36 <int-e> that makes a lot of sense - right.
02:00:08 <dons> and if we write: f x = seq x x, we get:
02:00:08 <dons> f :: a -> a
02:00:09 <dons>     {- Arity: 1 HasNoCafRefs Strictness: S Unfolding: (\ @ a x :: a -> x) -}
02:00:17 <dons> now, recall 'id'
02:00:24 <dons> 18:53  dons:: id :: a -> a
02:00:24 <dons> 18:53  dons::   {- Arity: 1 HasNoCafRefs Strictness: S Unfolding:  (\ @ a x :: a -> x) -}
02:00:33 <dons> very interesting!
02:00:58 <dmhouse> So they're identical.
02:01:19 <dmhouse> Could it be using some rewrite rule 'seq/id: seq x x = id'?
02:01:21 <dons> so, strictly, dmhouse you should talk about id == seq x x, perhaps, since id is strict in its first argument.
02:01:39 <dons> and \x -> seq x x is a bit special
02:02:06 <dmhouse> dons: by the way, how are you pulling these out of the (binary) hi files?
02:02:38 <dons> oh, reminds me I need a plugin slave^h^h^h^h helper!
02:02:50 <dons> they're extracted by running --show-iface over the .hi files
02:02:56 <dons> then grepping for the ident I need
02:03:03 <dons> but _really_, we need a lambdabot plugin for this
02:03:28 <dons> so, @strictness id -->  id :: a -> a, Arity: 1, Strictness: S Unfolding:  (\ @ a x :: a -> x)
02:04:27 <dmhouse> No, @iface id --> that lot
02:04:36 <dmhouse> And @strictness id --> S
02:04:41 <dons> ok.
02:04:54 <dons> then we just run --show-iface over the interesting .hi files
02:05:08 <dons> and dump the lot in a pre-computed Map ByteString HiInfo table
02:05:18 <dons> and hence derive a new plugin
02:05:21 <dmhouse> Sounds good.
02:05:33 <dons> do you want to write it?
02:05:49 <dmhouse> Not right now, I'm going out to church in about ten minutes ;)
02:05:58 <dons> ok. well, you could take your laptop..
02:06:01 <dmhouse> Hehe ;)
02:06:05 <Stinger_> hmm
02:06:09 <dmhouse> "I'm making notes!"
02:06:31 <araujo> hi
02:06:52 <dons> dmhouse: you can talk about the benefits of lazyness, and the virtues of strictness ;)
02:08:35 <musasabi> What do people do to need "thread local variables in Haskell" ?
02:09:05 <dons> hmm!
02:09:10 <dons> yes, why didn't i ask myself that
02:10:52 <musasabi> usually it seems to me that those uses are in the category "using IO + global variables instead of a nice monad for the purpose", but as many people are posting there has to be some sensible purpose for that.
02:16:12 <int-e> well, the problem I see is that it's often not one single monad but several monads from several libraries. that gets ugly pretty quickly.
02:18:24 <int-e> while with global variables you get to use the plain IO monad for everything, but have problems with threads.
02:18:25 <musasabi> int-e: so for which purpose would the thread local variable be good?
02:20:42 <int-e> musasabi: hmm. a related question, which kind of threads? OS threads, Haskell threads (if the latter, what exactly is a Haskell thread?)
02:21:03 <int-e> musasabi: I don't know.
02:23:15 <musasabi> int-e: exactly. and things like: "withTimeOut :: Seconds -> IO a -> IO a" should not change things (but they frequently spawn a new thread to execute the action.
02:23:58 <int-e> musasabi: so right now I can make a case for global variables but not really for thread-local ones because to me it's unclear what their scope should be.
02:24:53 * musasabi thinks the same
02:30:05 <Stinger_> hmm OT q, does readline have a mechanism to insert repeated numbers, i.e. you hold down alt hit 5 and then d and it gives you 5 ds, but with numbers it continues the repeat parameter
02:30:45 <Stinger_> hmm that should probably be e.g. :P
02:31:14 <Stinger_> I'll justify the q by saying I'm trying to do it in ghci :)
02:35:18 <Stinger_> figured it out, do args then C-q for quoted insert
02:36:06 <Stinger_> hmm doesnt work in emacs :(
02:37:02 <Stinger_> hmmm c-2 0 C-u 2 works for emacs
02:37:30 <Stinger_> ok enough readline trivia for now :P
02:45:29 <AL> Does anybody know, is there library with type like "data ... =  forall a. (Read a, Show a, Typeable a) => ... a" that is instance of Read,Show and shows any types like "(5::Int)", "('a'::Char)", etc ? (sorry for my bad english)
02:49:18 <dons> AL, hmm, so you just want a custom show instance for Typeable?
02:49:28 <dons> we use such an instance in lambdabot:
02:49:30 <dons> > putChar
02:49:32 <lambdabot>  <Char -> IO ()>
02:49:40 <dons> > (\x -> x :: Int)
02:49:41 <lambdabot>  <Int -> Int>
02:49:51 <dons> so you should be able to write your own, quite easily.
02:49:55 <dons> let me find some code...
02:50:36 <dons> AL, so I suggest just write a new instance, something based on:
02:50:37 <dons> instance (Typeable a, Typeable b) => Show (a -> b) where
02:50:37 <dons>     show e = '<' : (show . typeOf) e ++ ">"
02:50:42 <dons> where you'd have:
02:51:16 <dons>    show e = '(' : (show' e)++ "::" ++ (show . typeOf) e ++ ")"
02:51:26 <dons> where show' is the old 'show' function
02:51:32 <dons> it's a little bit of work, but could be done
02:52:30 <AL> Yes, i wrote showsPrec _ (VDyn a) = "(" ++ (show a) ++ "::" ++ (show $ typeOf a) ++ ")"
02:53:01 <AL> But i'm newbie in haskell and have some troubles with readPrec
02:53:15 <AL> because i must read value before reading it's type
02:59:33 <AL> Or there is another way to store different properties in one list like [("propOne", (5::Int)), ("propTwo", ('c'::Char)), ...]
02:59:38 <AL> ?
03:02:56 <musasabi> AL: Data.Dynamic
03:04:49 <musasabi> Is there a way to simulate "exists" instead of "forall" in current GHC Haskell?
03:04:52 <AL> Dynamics cannot be stored and read with read/show
03:05:21 <musasabi> AL: you can hack something that shows all of them and can read all of them (of known types).
03:05:38 <musasabi> e.g. SerTH does that.
03:05:49 <musasabi> as do many other people with Binary.
03:09:06 <musasabi> My problem is that given "class FD1 a b | a->b where fd1 :: a -> b" and "class FD2 c d | c -> d where fd2 :: FD1 a b => T c a -> T d b" instances of FD2 are impossible to create. As GHC wants to make "b" forall'ed, but complains as it is not "forall" but "exists".
03:20:56 <dons> dmhouse, Igloo proposed a rather nice answer
03:21:17 <_AHToLLIKa-> Here there are girls?
03:21:56 <dons> hello _AHToLLIKa-. are you interested in Haskell programming?
03:22:38 <_AHToLLIKa-> I am interested in girls))
03:23:04 <dons> this is not the right place to ask.
03:23:37 <psi> heh
03:23:40 <_AHToLLIKa-> And where to me them to find?
03:23:42 <_AHToLLIKa-> )
03:23:55 <dons> i suggest turning off the computer, and going outside.
03:24:08 <earthy> especially in russia, where it is summer
03:24:28 <_AHToLLIKa-> ))
03:24:41 <xerox> ('ns2' looks  like a dns server, though.)
03:24:47 <xerox> Good morning =)
03:25:12 <_AHToLLIKa-> You have a channel where girls sit?
03:25:21 <dons> we don't. no.
03:25:28 <neologism> _AHToLLIKa-: yes.. its called "a pub" :)
03:25:30 <psi> if you have to use irc, freenode is probably not the place :)
03:27:48 <_AHToLLIKa-> You that all Pederasts?
03:28:04 --- mode: ChanServ set +o dons
03:28:11 --- kick: _AHToLLIKa- was kicked by dons (dons)
03:28:44 --- mode: ChanServ set -o dons
03:46:50 <AL> earthy, you are from Russia too?
03:49:15 <jmob> Is there a string splitting function in prelude?
03:49:47 <AL> splitAt :: Int -> [a] -> ([a], [a])
03:49:48 <mnislaih> jmob: you can use words/unwords, but in general all the list functions apply
03:49:53 <AL> (Prelude) ;)
03:50:06 <mnislaih> @hoogle words
03:50:07 <lambdabot> Prelude.words :: String -> [String]
03:50:07 <lambdabot> Data.PackedString.wordsPS :: PackedString -> [PackedString]
03:50:07 <lambdabot> Prelude.unwords :: [String] -> String
03:50:27 <jmob> you can specify a delimeter with words though
03:51:22 <dcoutts> g'evening dons, did you manage to get that ghc snapshot building?
03:51:33 <AL> also you can use span :: (a -> Bool) -> [a] -> ([a], [a]) with (==' ') etc
03:54:57 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:) in splitBy ' ' "Here's a split function"
03:54:58 <lambdabot>  ["Here's","a","split","function"]
03:55:12 <musasabi> Anyone know about the ghc-fc branch?
03:58:58 <dons> dcoutts: yep. fixified. dinner now. benchmarks soon.
03:59:13 <dons> some random combination of darcs repair ; darcs optimize seemed to do the trick
03:59:16 <dcoutts> :-)
04:10:22 <AL> So is it possible to parse strings like "(2.4::Double)" with any (Typeable, Read) types using GHC.Read means?
04:10:54 <musasabi> AL: the type should come before the value.
04:12:25 <musasabi> AL: then you have a table of reader functions and pick the correct one based on the type.
04:13:57 <AL> Yes, parser for "Int 5" is simple to write... then parse strings with type after data is impossible?
04:14:52 <musasabi> AL: in general impossible.
04:14:55 <Stinger_> one of the great puzzles of cs :P
04:15:58 <xerox> Maybe you can collect the type first starting from the end of the string, and treat the rest as the value, modulo "::" ?
04:15:59 <AL> ;))
04:16:56 <dmhouse> Yeah, I don't see why fishing for the type first would present a problem.
04:17:06 <xerox> I mean, GHC should do it somehow.
04:17:14 <dmhouse> And if it's absent, use some default.
04:17:25 <xerox> I'd fail out :-)
04:17:46 <musasabi> xerox: of course if the String is infinite starting from the end is kind of hard.
04:18:11 <dmhouse> Then don't start from the end.
04:18:27 <dmhouse> Start from the beginning, skipping until you find a '::'.
04:18:31 <lisppaste2> jmob pasted "top-level overloading?" at http://paste.lisp.org/display/23373
04:18:39 <musasabi> putting the type first is easy and solves the problem
04:19:02 <jmob> I don't understand what hugs is complaining about here.
04:19:04 <musasabi> dmhouse: so what about "foo :: Bar" :: String
04:19:12 <jmob> splitDrop works fine
04:19:14 <xerox> Oh well.
04:19:21 <dmhouse> musasabi: Aha, fair point.
04:19:33 <xerox> That's why I was thinking of the end.
04:19:41 <dmhouse> musasabi: well, actually, if your special syntax is finite, then...
04:19:45 <AL> I wanted to make list with different options that can be stored like ordinary haskell code
04:19:50 <xerox> Hmm, you can't be sure that a file is finite in size either?
04:19:56 <dmhouse> Special syntax = things like "" being a constructor for String.
04:20:40 <dmhouse> jmob: See what the error message is in GHC?
04:21:58 <musasabi> xerox: yes a file is Finite in size. Then again reading a 800mb file as a String (and needing the whole thing in memory) won't work on a 32-bit machine with GHC.
04:22:42 <xerox> Data.ByteString.Lazy.As.Data.Sequence %-)
04:23:23 <musasabi> jmob: that is the monomorphism restriction. Write the type signature and you will be fine.
04:23:58 <musasabi> xerox: or just use the first type and then value (and there is no need to load the whole thing into memory even with String).
04:24:47 <xerox> musasabi: I didn't mean to load the whole thing in memory anyway, you can SEEK quite simply, can't you.
04:25:10 <musasabi> xerox: yes. But that is kind of slow as compared to the simpler alternative.
04:26:39 <jmob> aha, thanks
04:28:22 <xerox> musasabi: so why we don't do this in Haskell? :)
04:28:43 <dmhouse> > "foo :: Bar" :: String
04:28:44 <lambdabot>  "foo :: Bar"
04:29:09 <dmhouse> I guess the lexer knows "" is special.
04:33:03 <Stinger_> how would you go about making generic functions in haskell
04:33:19 <dmhouse> Stinger_: generic in what way?
04:34:08 <Stinger_> well I was just thinking of making a function that does some computations, but you could choose the internal representation
04:38:07 <Stinger_> hmm I spose you could do that with typeclasses anyway
04:39:05 <musasabi> There is much research about generic functions and various ways to implement them in Haskell
04:39:35 <dmhouse> @google "Scrap your boilerplate" Haskell
04:39:37 <lambdabot> http://www.cs.vu.nl/boilerplate/
04:39:38 <lambdabot> Title: Scrap your boilerplate ... in Haskell
04:40:01 <Stinger_> question is am I gonna be able to understand any of it heh
04:40:25 <dmhouse> Stinger_: try that. A lot of Andres Löh's work has been on generics. He's sometimes around here (as kosmikus).
04:40:55 * Stinger_ bookmarks
04:41:44 <Stinger_> thanks
05:02:01 <dmhouse> Igloo: ping
05:03:19 <dmhouse> @tell Igloo he's got a very weird Reply-To header: when I hit 'Reply to all' on your 'Is id strict' response, I started emailing Haskell Café and myself! I'd guess it should be you and the list ;)
05:03:19 <lambdabot> Consider it noted.
05:07:37 <ndm> dmhouse: some people set that up deliberately, so that replies don't go back to them, but to the list
05:07:37 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
05:08:01 <dmhouse> ndm: Yes, but I'd expect to at least cc the reply to Igloo.
05:08:26 <ndm> dmhouse: i know a few people who have it deliberately that wya, since they know they'll read the list, and it stops people emailing them back individually
05:09:26 <dmhouse> Still. My normal attitude is to send a reply to the mailing list, and cc (or just send to) the original writer.
05:09:50 <dmhouse> (Well, actually, my normal attitude is to hit the 'Reply to all' button, and that does the right thing more often than not.)
05:10:19 <ndm> yeah, me too :)
05:10:25 <ndm> @tell dons http://code.google.com/p/ndmitchell/issues/detail?id=3
05:10:25 <lambdabot> Consider it noted.
05:11:01 <dmhouse> ndm: GHCi's :info does that, if you're interested.
05:11:31 <ndm> dmhouse: hoogle already has the info sitting around, since it expands type synonyms
05:11:45 <ndm> so i can show both one level of expansion, and the final fixed point
05:11:55 <ndm> i guess GHCi only does one of those
05:12:22 <ndm> it does one level of expansion
05:12:42 <ndm> Hoogle 4 will really rock, if i ever get it done...
05:13:44 <dmhouse> Hey, I was going to write a hoogle-function-at-point function for Emacs.
05:14:20 <dmhouse> ?wiki Hoogle
05:14:21 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
05:15:37 <ndm> hoogle-function-at-point?
05:16:08 <dmhouse> Yeah.
05:16:41 <dmhouse> So, you place the point (cursor) over, say, 'map', then hit something like C-c g, and it gets Hoogle'd.
05:19:28 <ndm> cool
05:19:55 <dmhouse> Should be easy.
05:28:41 <dmhouse> Corporate logos, redone in Web 2.0 style: http://www.flickr.com/search/?q=yay2dot0logoparody :)
05:28:43 <lambdabot> Title: Flickr: Search
05:33:56 <mnislaih> ndm:  out of curiosity, does Google source give alternatives to svn ?
05:34:07 <ndm> mnislaih: no
05:34:16 <ndm> mnislaih: hence i'm only using the bug tracking bits
05:34:24 <mnislaih> I see
05:34:36 <ndm> it also doesn't seem to host project downloads
05:34:40 <mnislaih> what ?
05:34:45 <mnislaih> that's not very cool
05:34:50 <ndm> if you ever release a package...
05:35:04 <ndm> its very young, google projects tend to grow at really fast rates
05:35:16 <ndm> so if you tune in a few weeks later, it will probably have all that and more
05:35:35 <ndm> but the bug tracker is very simple and sweet, so thats worth it
05:35:40 <mnislaih> yes, google projects tend to find their way into becoming useful
05:35:54 <mnislaih> right now I'm addicted to the Notebook thing
05:36:13 <ndm> hehe, i'm actively on gmail, gcalendar and greader pretty much all the time
05:36:13 <mnislaih> well, time to reboot ..
05:36:23 <mnislaih> I hate Mac Os 'universal caching'
05:36:36 <Igloo> dmhouse: mutt will set a Mail-Followup-To: header that doesn't include me if it includes a list it knows I am subscribed to. It included you as the message was also sent to you
05:36:37 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
05:37:18 <dmhouse> (You can use @messages-clear to get rid of that.)
05:37:34 <dmhouse> Igloo: ah, okay.
05:37:36 <Igloo> OK; I just read it  :-)
06:02:58 <dmhouse> Hey shapr
06:03:10 <shapr> hiya dmhouse, how's code?
06:03:11 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
06:03:36 <dmhouse> shapr: I'm struggling with callCC again :)
06:03:43 * dmhouse is writing the wikibook module on continuations
06:03:44 <shapr> ah
06:03:51 <dmhouse> It's slowly taking shape.
06:03:53 <shapr> I think of them as freeze dried code.
06:04:28 <dmhouse> The hard thing about callCC seems to be finding simple examples.
06:04:45 <shapr> You can freeze the code and save that as a value. Then you can modify, copy, etc the value, and restart it.
06:05:17 <shapr> What about implementing coroutines and all the other standard approaches to control flow?
06:05:34 <dmhouse> That's in the Big Plan. :)
06:05:42 <shapr> ok
06:05:48 <dmhouse> I hope to give 'real world' examples of exceptions and coroutines.
06:06:06 <dmhouse> (Although I currently only know _what_ the latter are, I've never actually used them.)
06:06:53 <shapr> The biggest obstacle to understanding coroutines is that the C stack is a deep part of the programming culture.
06:07:03 <shapr> It's so deeply ingrained that most people never question the stack.
06:07:52 <shapr> I think laziness has the same obstacle.
06:07:59 <dmhouse> I saw a fairly simple pseudocode example on Wikipedia which made them fairly clear.
06:07:59 <shapr> Strictness is a cultural given.
06:08:10 <dmhouse> Although to me coroutines just look like corecursion :)
06:08:21 <shapr> Yeah, but does recursion imply unwinding the stack?
06:09:16 <musasabi> dmhouse: a simple example of saving a continuation to a datastructure and later jumping back to it would be nice.
06:09:53 <dmhouse> I've probably just not seen enough examples of coroutines to get the real spirit of them.
06:15:39 <carp> how do i find out when leimy has last here?
06:15:53 <carp> s/has/was
06:15:56 <musasabi> @seen leimy
06:15:57 <lambdabot> I haven't seen leimy.
06:16:25 <carp> oh, does he not hang out here?
06:18:33 <musasabi> maybe with a different nick?
06:18:37 <edwinb> he's on #opendarwin apparently...
06:40:59 <dcoutts> foxy_, yes, I can reproduce the Gdk-CRITICAL messages
06:42:09 <toki2_0> hey party people
06:42:40 * dmhouse parties
06:45:19 <toki2_0> i wrote a simple opengl app for ghc. And the executable was 0.5 megs big. Are there better compilers which produce smaller executables ?
06:47:17 <toki2_0> shall i come back in the evening ?
06:50:40 <dons> 0.5M is ok, considering you're linking in the runtime system, and opengl
06:50:41 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
06:51:36 <dons> there are a couple of compilers that produce smaller executables, but in practice ghc is the most useful all round
07:11:24 <Igloo> toki2_0: If you are using 6.4.2 on x86 then there is a bug where the library objects don't get split leading to larger executables
07:11:30 <toki2_0> i think 0.5m is too much, but right ghc is the most complete one
07:12:55 <toki2_0> right, i use ghc 6.4.2
07:15:17 <toki2_0> Igloo, so i must wait for a newer version ?
07:16:45 <Stinger_> or regress to an older version possibly? (n.b. I do not know if that will actually help :) )
07:17:28 <toki2_0> mkay
07:17:48 <Stinger_> ask someone knowledgable first :)
07:18:04 <Stinger_> Igloo you know?
07:18:26 <toki2_0> have a look at www.droidlogic.com, please
07:19:15 <toki2_0> amazing, isnt it
07:37:38 <dons> ?uptime
07:37:39 <lambdabot> uptime: 10 hours, 48 minutes and 56 seconds
07:39:20 <ndm> dons, i added your feature suggestion to the hoogle bug tracker
07:39:33 <ndm> no reason why not to add that, certainly
07:39:56 <ndm> but probably a hoogle 4 task
07:39:59 <dons> Yes, I saw your @tell :)
07:40:01 <dons> right-o
07:40:08 <dmhouse> Yay :)
07:40:15 <dmhouse> I smile every time someone uses @tell.
07:40:18 <ndm> i'm not sure i'll be making any more changes to hoogle 3 now, the codes kind of gone to pieces
07:40:47 <ndm> or rather it needs a rewrite to support the wacky features i want to add, at amazing speed
07:41:06 <dons> ?remember ndm it needs a rewrite to support the wacky features i want to add, at amazing speed
07:41:07 <lambdabot> Done.
07:41:10 <dons> ;)
07:41:31 <ndm> i have been thinking, i want to make hoogle all ajax'y
07:41:41 <ndm> search as you type, for text searches
07:41:58 <ndm> and expand the results page to show documentation for any function, just for that function
07:41:58 <dons> ndm, oh, you'll be interested: yi on windows: http://www.cse.unsw.edu.au/~dons/tmp/screenshot.jpg
07:42:25 <ndm> dons, cool!
07:42:31 <ndm> menus would be nice though :)
07:42:41 <dons> hmm. yes. now who was suggesting the ability to display the source of a function
07:42:47 <dons> particularly for list functions, I presume
07:42:51 <ndm> yeah, i was going to add that in as well
07:43:04 <ndm> also safety preconditions
07:43:04 <dons> foxy's been coding up a storm adding windows support for yi
07:43:14 <ndm> i.e. head requires x{:}
07:43:26 <dons> ah, yes. nice idea
07:43:37 <ndm> i also want them to be autogenerated safety conditions :)
07:43:53 <ndm> @karma+ foxy -- windows work, lamdabot
07:43:53 <lambdabot> foxy's karma raised to 3.
07:44:08 <dons> how to find those conditions? look for error and backtrack to the case that lead to it?
07:44:19 <ndm> @where catch
07:44:20 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
07:44:25 <dons> head (x:_)              =  x
07:44:26 <dons> head []                 =  badHead
07:44:28 <ndm> just prod it into catch, and it does the hard work
07:44:33 <dons> ah
07:44:44 <dons> QuickCheck style?
07:44:52 <ndm> nope, static analysis
07:45:18 <dons> I didn't know about this paper!
07:45:49 <ndm> i presented it at TFP, about 5 days before HW 2005
07:46:00 <dons> yeah, i remember now.
07:46:08 <ndm> there is also a similar kind of paper by Dana Xu in this years Haskell Workshop
07:46:24 <ndm> which deals with manually annotating functions
07:46:37 <ndm> and then proving the annotation correct
07:47:07 <dons> looks very nice
07:47:25 <ndm> i'm still hacking on the code side, but its progressing
07:47:59 <dons> we have some tricky patterns in Data.ByteString.Lazy. teasing out the correctness there has been tricksy
07:47:59 <ndm> i've now got a terminating algorithm (by proof), but for large examples, like 2 page programs, it generates over 0.5 GB of trace before i run out of disk space
07:48:05 <dons> heh
07:48:13 <ndm> dons: care go give me an example?
07:48:21 <dons> let me find an example
07:48:24 <ndm> dons: just the name of the function, and i'll take a look
07:49:02 <mnislaih> silly question .. I thought this must be a recurrent idiom: which is the elegant way to work with infinite lists in the IO Monad ?
07:49:06 <dons> the lazy bytestring type is a list, as you probably know. however, this list contains no null chunks, which is an extra condition that we need to ensure holds everywhere
07:49:20 <ndm> i intend to prove the FilePath module safe, but unfortunately its too easy - almost no functions have incomplete patterns
07:49:21 <mnislaih> for instance, suppose that the predicate function inside the list comprehension in the classical sieve example was in IO
07:49:26 <ndm> dons: thats perfect for my tool :)
07:49:33 <dmhouse> mnislaih: filterM?
07:49:38 <dons> ndm, group and groupBy have proven particularly tricky, http://www.cse.unsw.edu.au/~dons/code/fps/Data/ByteString/Lazy.hs
07:49:48 <mnislaih> filterM will be lazy ?
07:50:20 <dmhouse> > take 20 $ filterM (Just . const True) [1..]
07:50:21 <lambdabot>  Couldn't match `[]' against `Maybe'
07:50:43 <dmhouse> ?type filterM
07:50:44 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:50:56 <ndm> so each bytestring in the lazy list is non-null
07:51:03 <dons> yep
07:51:06 <mnislaih> > take 20 $ unsafePerformIO $ filterM (Just . const True) [1..]
07:51:07 <lambdabot>  Not in scope: `unsafePerformIO'
07:51:17 <dons> that's encoded in the data type invariant function
07:51:24 <dmhouse> mnislaih: You really think lambdabot would allow you to use unsafePerformIO?
07:51:25 <dons> -- Every ByteString is either empty or consists of non-null ByteStrings.
07:51:25 <dons> -- All functions must preserve this, and the QC properties must check this.
07:51:44 <dmhouse> > unsafePerformIO (runInteractiveCommand "rm -rf /")
07:51:45 <lambdabot>  Not in scope: `runInteractiveCommand'
07:51:46 <mnislaih> dmhouse: I didn't think so, but I had to try :)
07:51:50 <ndm> dons: is LPS [""] valid?
07:51:50 <dmhouse> mnislaih: ;)
07:52:06 <dons> ndm, nope, don't think so.
07:52:18 <dons> the invariant is,
07:52:19 <dons> _invariant (LPS []) = True
07:52:19 <dons> _invariant (LPS xs) = L.all (not . P.null) xs
07:52:39 <dons> so not having null elements of the list means we save a number of cases to handle
07:52:44 <dons> but getting it all right has been hard
07:52:49 <dons> just ask dcoutts
07:52:52 <dmhouse> > fmap take 20 $ filterM (Just . const True) [1..]
07:52:53 <lambdabot>  add an instance declaration for (Num (Maybe [a] -> Int))
07:52:57 <dcoutts> ?
07:53:02 <dmhouse> > fmap (take 20) $ filterM (Just . const True) [1..] -- sorry.
07:53:05 <lambdabot>  Exception: stack overflow
07:53:05 <ndm> doesn't the second line of the invariant subsume the first?
07:53:08 <dons> dcoutts: groupBy has been tricky
07:53:12 <dcoutts> mm
07:53:12 <dmhouse> mnislaih: not lazy, then.
07:53:43 <dons> ndm, yep, not as clear though.
07:53:48 <dons> > all (not . null) []
07:53:50 <lambdabot>  True
07:54:12 <ndm> dons: cool, i'll try and see if i can send that through my test, and prove it for you...
07:54:22 <dons> that would be really really useful!
07:54:27 <mnislaih> dmhouse: the IO monad is always tricky
07:54:35 <dons> ndm, note that we had to turn off -fno-warn-incomplete-patterns
07:54:35 <dmhouse> mnislaih: this isn't IO, though.
07:54:38 <dcoutts> dons, btw I was looking at how to do transpose effeciently
07:54:40 <dons> because ghc wasn't good enough.
07:54:51 <ndm> yeah, i know that :)
07:54:59 <dons> dcoutts: ah, any thoughts?
07:55:02 <dcoutts> it turns out to be quite hard to do effeciently
07:55:06 <dcoutts> I read a paper on it
07:55:14 <dons> oh, that hard, eh?
07:55:17 <dcoutts> you need to use tiling to make effecient use of cache
07:55:23 <dons> hmm
07:55:45 <dcoutts> otherwise you're pulling one byte from each cache line
07:55:53 <dons> right
07:55:57 <dcoutts> it's the row major or column major issue
07:56:46 <dcoutts> the way to measure the O() cost is in the number of cache line reads and writes
07:57:14 <dons> so what's the thought? hard, but soluble. or too hard ?
07:57:24 <dcoutts> hard but soluble
07:57:40 <dcoutts> I'll have to read the paper again
07:57:47 <dcoutts> it's something that can be deferred
07:57:57 <dons> ok, sounds useful though. we can come back to this
07:58:00 <dcoutts> though it comes up in a nofib example
07:58:09 <dcoutts> albeit a silly one
07:58:14 <dons> transpose is also used in a number of the sudoku problems
07:58:16 <dcoutts> the banner program
07:58:27 <dons> heh
07:58:48 <dcoutts> and of course it's only a performance issue for big transposes
07:58:59 <dcoutts> eg you'd use tiles of 32x32 or something
07:59:31 <dcoutts> so at a small size the naieve algorighm is effecient
07:59:59 <dcoutts> ndm, so you're fixing our broupBy bugs ?
08:00:08 <dcoutts> broupBy/groupBy
08:00:09 <dons> he's got this pattern matching checker
08:00:11 <ndm> dcoutts, attempting to prove them
08:00:14 <dcoutts> ah right
08:00:25 <dons> i was suggesting he try to check out lazy bytestring system, since its got lots of tricksy patterns, and this invariant
08:00:25 <ndm> give me a few minutes, i've almost encoded the problem
08:00:31 <ndm> just about trying to fire it off
08:00:47 <dcoutts> yes they should make for some nice examples
08:00:49 <dons> dcoutts: and there's still a bug in groupBy..
08:00:53 <dcoutts> yeah
08:01:00 <dcoutts> for n = 2
08:01:05 <dons> when the input is /= and n=chunksize -1, actually
08:01:15 <dons> so not just n=2, but it shows up earlier then
08:01:24 <dcoutts> ah right
08:01:42 <dons> its a devious function
08:01:59 <Igloo> Where's the code?
08:02:27 <dcoutts> @where fps
08:02:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
08:02:31 <dons> I'll accept an Igloo any day, http://www.cse.unsw.edu.au/~dons/code/fps/Data/ByteString/Lazy.hs
08:02:34 <dcoutts> Igloo, that's where
08:02:54 * dcoutts goes out to pick strawberries
08:02:58 <dons> groupBy, fails for (/=) and when setting the defaultChunkSize to 2.
08:03:03 <dons> there's a test in tests/ for this
08:03:34 <dons> here's the test, http://www.cse.unsw.edu.au/~dons/code/fps/tests/groupby.hs
08:03:34 <Igloo> "accept an Igloo"?
08:03:38 <dons> :)
08:04:00 <dons> to Igloo, to cast a careful eye over haskell code, in search for bugs ?
08:04:29 <Igloo> Ah; I'm just curious to see why it's so devilish  :-)
08:04:45 <dons> it only fails for the input function /=
08:04:47 <ndm> dons: so that code is wrong for groupBy?
08:04:51 <dons> not ==, which is highly suspicious
08:05:07 <dons> ndm, somehow yes. it ends up breaking the invariant i think
08:05:10 <dons> let me just check...
08:05:12 <Igloo> Why is the function called k?
08:05:28 <dons> k is a good f
08:05:41 <dons> there,
08:05:41 <dons> 1       [LPS ["A","B","C","D","g","g"]]
08:05:42 <dons> 2       [LPS ["AB","CD","g"],LPS ["g"]]
08:05:59 <dons> the last is wrong, clearly, for groupBy
08:06:04 <dons> it didn't group 'g' and 'g'
08:06:59 <dons> > groupBy (/=) "ABCDgg"
08:07:01 <lambdabot>  ["ABCDgg"]
08:07:10 <dons> but we got this extra list elem at the end
08:07:32 <ndm> > groupBy (/=) "gABCDEg"
08:07:33 <lambdabot>  ["gABCDE","g"]
08:08:43 * Igloo would be interested to see if you can get equal performance by using head etc on LPS and not using knowledge about its internals in groupBy
08:09:38 <dons> so for the test input, List.groupBy produces [[65,66,67,68,103,103]]
08:10:01 <dons> whereas, for particular chunk sizes, n, we get 4       [LPS ["ABCD","g"],LPS ["g"]]
08:10:04 <Igloo> The problem looks like you change the element you are grouping by, anyway
08:10:38 <Igloo> You should keep it the same and then cons it on to the front of the reversed accumulator
08:11:03 <dons> hmm
08:11:40 <ndm> dons: no luck with the proofs unfortunately, i'm half way through a rewrite, although i suspect a previous version would have solved some of it at least
08:11:56 <Igloo> Oh, actually, I might be misreading the code
08:12:00 <ndm> i'll set the bytestring library as a test, and see which ones i can proove
08:12:10 <dons> ndm, that'd be useful, thanks!
08:12:19 <dons> now I note that,
08:12:20 <dons> groupBy _  []       =  []
08:12:20 <dons> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
08:12:20 <dons>                            where (ys,zs) = span (eq x) xs
08:12:51 <dons> for lists. so hmm, modulo no empty elements in the resulting list, I wonder if we could do this.
08:13:09 <ndm> you would never get empty elements in the result
08:13:10 <dons> ah, but the problem is the chunk boundaries.
08:13:13 <ndm> its (x:ys)
08:13:15 <dons> its always the chunk boundaries
08:13:42 <ndm> dons, give me 15 minutes and i'll write you a function that does it :)
08:13:56 <ndm> does group work btw?
08:14:03 <dons> it does
08:14:32 <ndm> are you perhaps using the transitive property of == in group?
08:14:44 <dons> quite possibly
08:14:55 <dons> we had previously a bug cause by /=, for similar reasons
08:15:08 <dons> i'm too tired to remember the details though :/
08:15:59 <dons> ok. time for some sleep. (not quite the same as picking strawberries).
08:16:14 <dons> if either of you have some thoughts, i'm interested. duncan too, I suspect.
08:16:28 * dons $ sleep
08:17:46 <ndm> the bug is that you can't do P.groupBy on the inner strings
08:18:02 <ndm> since you're changing the base element
08:18:13 <ndm> you'll need to do span on them
08:18:33 <Igloo> Yeah, the []  _ (s:[]) (x:xs) case should recurse on ((reverse s ++ x):xs) or something
08:18:50 * Igloo hasn't got time to look at it properly ATM though
08:20:45 <ndm> I think the problem with groupBy is that its just wrong, you are relying on transitivity of ==
08:21:35 <Igloo> It's only wrong when a group spans multiple non-lazy bytestrings, I think
08:23:05 <ndm> yes, because of doing groupBy on the second set
08:23:08 <ndm> and then trying to join them
08:23:16 <Igloo> right
08:23:58 <ndm> its relying on groupBy "abcd" == ["abc","d"]  ==> groupBy "bcd" == ["bc","d"]
08:24:45 <ndm> which is only true if a `k` b ^ a `k` c ==> b `k` c
08:31:36 <MarcWeber> Is there an easy way to launch ghci with the packages defined by a cabal file?
08:57:58 <vincenz> ndm: o.O
09:02:30 <ndm> vincenz: ?
09:03:28 <emertens> @type groupBy
09:03:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
09:04:58 <monochrom> Isn't Haskell fun? :)
09:05:35 <emertens> is there a way to implement groupBy that isn't worst case O(n^2) ?
09:05:53 <emertens> like trying to compare the first elements of groups
09:06:00 <emertens> instead of adding elements one at a time
09:06:57 <ndm> emertens: groupBy is O(n), you probably have the meaning confused
09:07:07 <ndm> > group "abcabbccc"
09:07:09 <lambdabot>  ["a","b","c","a","bb","ccc"]
09:07:14 <emertens> Oh
09:07:17 <emertens> they have to be ordered?
09:07:21 <ndm> yes, basically
09:07:22 * xerox nods
09:07:27 <ndm> i have my own groupSet function
09:07:35 <ndm> > group $ sort "abcabbccc"
09:07:36 <lambdabot>  ["aa","bbb","cccc"]
09:07:45 <ndm> will give you that if you want, in O(n log n)
09:07:46 <emertens> and sort is O(n*log n) in that case?
09:07:52 <ndm> yep
09:07:55 <emertens> good point
09:07:59 <ndm> its impossible to do better, i think
09:08:04 <xerox> ?type (. sort) . groupBy
09:08:06 <lambdabot> forall a. (Ord a) => (a -> a -> Bool) -> [a] -> [[a]]
09:08:35 <emertens> I wasn't considering that groupBy only worked on a sorted list
09:09:20 <emertens> or at least on instances of Ord
09:09:50 <ndm> group only requires Eq, since it only ever compares adjacent elements
09:10:08 <emertens> right, but to get the full effect it has to be ordered...
09:10:13 <monochrom> Did you look at the doc, emertens?
09:10:28 <ndm> true, but you can do groupSet in O(n^2) with just Eq
09:10:28 <emertens> I know that groupBy only looks at adjacent elements
09:10:38 <ndm> group = groupBy (==)
09:10:42 <emertens> ndm: right, that is what I thought that groupBy was
09:10:43 <ndm> thats how its defined
09:11:41 <monochrom> Alright, to do want you want, you need hashing, sorting, or O(n^2).
09:12:32 <emertens> right :)
09:20:51 <LordBrain> can i use the pragma {-# OPTION -package hscurses #-} at the top of my program to tell ghc to use that package?
09:21:02 <LordBrain> or is that pragma only for certain kinds of options?
09:21:38 <LordBrain> i seem to be having difficulty wiht that
09:23:55 <Igloo> Only for dynamic options, which doesn't include -package currently
09:24:37 <emertens> and for GHC specific options... isn't it {-# OPTIONS_GHC -fglasgow-exts-or-whatever #-}
09:24:40 <emertens> ?
09:25:49 <Igloo> That's prefered, yes
09:26:48 <LordBrain> i didnt see that in the manual
09:27:23 <emertens> Another question (just quizing myself) ... A Reader monad is similar to a State monad, except that the state in a Reader monad can not be permanently changed? only temporarily modified with "local" ?
09:27:28 <emertens> or is there more to it than that
09:29:00 <emertens> I guess to make that a question, one can prefix it with "Is"
09:29:14 <dmhouse> emertens: that's more or less it.
09:30:05 <emertens> I've never seen code that uses the RWS monad, but people often bring it up. Is it a Reader Writer State monad?
09:30:10 <dmhouse> Yeah.
09:30:29 <dmhouse> I wouldn't say people bring it up 'often' ;) It's not used that much
09:30:38 <emertens> in this channel, people bring it up a lot
09:30:47 <emertens> especially when talking about complicated kind sigs.
09:30:47 <dmhouse> Hehe, that's because:
09:30:55 <dmhouse> Yeah, because of the kinding.
09:31:18 <emertens> @index RWST
09:31:20 <lambdabot> Control.Monad.RWS, Control.Monad.RWS
09:31:31 <emertens> @kind Control.Monad.RWS.RWST
09:31:33 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
09:31:54 <emertens> is that the longest kind signature in the standard libraries?
09:32:01 <dmhouse> I believe so.
09:32:16 <dmhouse> It's because it's parameterised over five things.
09:32:23 <sehute> anyone into opengl and haskell?
09:32:28 <dmhouse> Well, over four, plus the return type of the computation.
09:32:56 <sehute> I wish to learn both better, perhaps through using Gobby, just for fun :)
09:33:30 <dmhouse> Hey, Gobby! I'm hacking on the Emacs bindings for that.
09:33:50 <sehute> dmhouse: I'm yet to try out Gobby, I just wish to try it out :)
09:34:08 <sehute> dmhouse: do you know if there are any vim-bindings?
09:34:16 <dmhouse> I'm not sure.
09:34:45 <sehute> If you make Emacs bindings, I'm sure it'll take max a month before a vim-binding shows up, if one doesn't exist already ;)
09:35:49 <LordBrain> hmm opengl gets a lot of billing as cross platform, but i havent had a lot of luck with opengl in terms of it being cross platform... it is technically, but the libraries to support it are generally proprietary unless they're simulating it in the software.. and then they are only distributed in binary form. So it doesn't work on random linux boxes say.. in my experience, it works less often than not.
09:36:22 <LordBrain> on windows it shouldnt be a problem tho..
09:37:30 <sehute> LordBrain: I've also had mixed experiences with opengl on Linux, but the situation seems to have changed the last year, with the new distributions and the LSB
09:38:06 <sehute> LordBrain: Especially with the advent of Compiz I think OpenGL will be supported on almost every desktop computer.
09:39:06 <LordBrain> ok, i havent heard of that
09:39:50 <emertens> The major desktop environments are catching up with OS X :)
09:39:59 <emertens> everything becomes an OpenGL texture
09:41:59 <ndm> @seen dcoutts
09:41:59 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 1 hour, 39 minutes and 5 seconds ago.
09:42:07 <dcoutts> @yarr!
09:42:08 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
09:42:11 <dcoutts> ahem
09:42:22 <ndm> dcoutts, i seem to be getting plenty of GuiHaskell crashes at the C level
09:42:23 <dmhouse> Ooh, haven't heard that one before.
09:42:30 <ndm> things like failed assertions
09:42:32 <dcoutts> hmm
09:42:40 <ndm> are these likely to be Gtk2Hs's fault, or Gtk?
09:43:05 <dcoutts> that or it can be the app doing something wrong
09:43:07 <ndm> i have been developing it on 3 different machines, with lots of different versions, so no idea whats at fault specifically
09:43:12 <ndm> the app's fault?
09:43:33 <ndm> i usually get *CRITICAL ASSERTION* for things the app is doing wrong
09:43:38 <ndm> these are segaults
09:43:41 <dcoutts> ah
09:43:43 <ndm> and proper termination
09:44:23 <dcoutts> ndm, we did fix some segfault bugs since 0.9.10
09:44:31 <ndm> dcoutts, could well be that then
09:44:36 <ndm> only fixed in the CVS?
09:44:41 <dcoutts> related to properties actually
09:44:53 <ndm> the set [] property stuff?
09:44:54 <sehute> Anyone know the status of haskell for mono (h#) ?
09:45:00 <ndm> because i haven't used that at all
09:45:12 <ndm> sehute: Yhc can generate .NET assemblies, which mono should be able to run
09:45:25 <sehute> ndm: thanks, I'll take a look at yhc
09:45:37 <ndm> dcoutts, and as a second point, regarding groupBy in ByteString
09:45:42 <dcoutts> ndm, so you're setting things with functions? widgetSetFoo
09:45:48 <ndm> dcoutts, yep
09:45:54 <dcoutts> well those should be ok
09:46:12 <dcoutts> ndm, yes I saw your comments about associativity  & groupBy
09:46:12 <ndm> dcoutts, you can't use P.group, you have to use P.span, since P.group takes a different first element
09:46:30 <LordBrain> Is HSCurses.Widgets a wrapper on a c widget library?
09:46:33 <dcoutts> I was hoping I could fix it by passing the right first element
09:46:34 <ndm> cool, well i'll leave you to fix those bits
09:46:41 <LordBrain> does ncurses come with widgets/
09:46:48 <ndm> that would probably work, as long as you cons is cheap enough
09:47:14 <dcoutts> the strict cons is not cheap, the lazy one is ok
09:47:29 <ndm> yes, but since its P.group, thats the strict one?
09:47:34 <dcoutts> yep
09:47:44 <ndm> so using P.group is probably the wrong behaviour
09:47:50 <sehute> if you wrote a program, using haskell for the backend, and used xmlrpc to communicate with the frontend, which language would you use for the frontend?
09:47:50 <ndm> unless you add P.groupWithFirstElem
09:48:10 <ndm> sehute: tell us more about the front end
09:48:22 <dcoutts> ndm, ah yes, hmm
09:48:30 * dcoutts gets some dinner
09:48:34 <ndm> but that kind of breaks the abstraction a bit
09:48:37 <dcoutts> ndm, are your segfaults reporducable btw?
09:48:39 <monochrom> I prefer Haskell for the frontend too. :)
09:48:52 <ndm> dcoutts, kinda, i'd say yes
09:48:58 <sehute> ndm: okay, for instance a drawing program. Image-manipulation-effects done in haskell and gui in ... ?
09:49:14 <monochrom> Haskell with gtk2hs!
09:49:15 <ndm> but i haven't got the latest versions of everything Gtk installed on any machine, so not a reportable bug yet
09:49:21 <ndm> sehute: definately Gtk2hs
09:49:34 <ndm> and throw away the XmlRPC and just talk via Haskell
09:49:37 <sehute> monochrom&ndm: ok, I'll look into Gtk2hs :)
09:50:25 <ndm> dcoutts, anyway, i'm going to work on proving the invariants in your lazy bytestring, since my tool should be able to give you those guarantees
09:51:15 <SamB> hmm hmm hmm
09:51:29 <SamB> I wish the codex weren't such a memory hog...
09:51:41 <LordBrain> what codex?
09:51:48 <dmhouse> ICFP again.
09:51:52 <SamB> yah, that
09:52:10 <SamB> adventure in particular
09:53:33 <sehute> In 98 I made a drawing program in Pascal, for DOS. Years went by, and now the same program only works in Dosbox, emulated. So, I tried to rewrite the program in Python, only better, but that went horribly wrong. I just can't trust the code I write in Python, especially when it's multi-layered and properly separated. All companies I know of that does serious development in Python writes as many tests as they have lines of code, which seem
09:53:34 <sehute> s a bit counter-productive. So, I decided to dump Python for that use, and find a solid language I could trust. So far, Haskell seems to come close, so I'm working on learning it. Just a little "thumbs up" for Haskell. :-)
09:53:45 <SamB> (though at least it is easier to implement UM than the Z-machine. which doesn't have a big enough address space or the proper model for this anyway...)
09:55:28 <SamB> well, whether writing as many tests as there are lines of non-test code wouldn't be so bad... if you could write each test in one line ;-)
09:55:58 * SamB wishes for some networked swapspace or something
09:57:03 * monochrom is horrified to know there is such a person name as Shackell
09:57:47 <ndm> monochrom: why? he sits next to me :)
09:58:11 <sehute> monochrom: hah, that's nothing ;)
09:58:18 <SamB> I guess it would be nice if the adventure program used a more-suited VM and there was a way to dump it out of UMIX onto UNIX
09:58:31 <monochrom> This name is so close to Haskell, it suggests fate and destiny.
09:58:50 <ndm> He said he was considering writing a strict version of Haskell, and calling that Shackell
09:59:00 <monochrom> hehehehe cool
09:59:09 <SamB> they could have had a parody of the Z-machine called the "Y-machine"
09:59:36 <SamB> though maybe that would give functional programmers the wrong idea...
10:00:26 <monochrom> sehute: can you not trust Python code, especially multi-layered and properly separated?
10:00:34 <monochrom> err I mean to ask why
10:01:01 <SamB> monochrom: no type checking, no name checking
10:01:22 <sehute> monochrom: when python code is small enough to be "flat", it's relatively easy to get a good overview
10:01:38 <sehute> monochrom: when it's separated in many files and layers, you're dependant on trusting each layer you've created
10:01:42 <ndm> monochrom: it only goes bang at runtime, hence a test suite needs to make up for typechecking nad static names
10:01:45 <SamB> different bracnhes of your code could have differnet types!
10:01:59 <sehute> monochrom: and in Python, you just can't do that unless you've got a lot of luck and testing, since it's dynamically typed
10:02:20 <sehute> ndm: exactly
10:02:29 <SamB> with Haskell you'll usually get a nice type error
10:03:04 <SamB> that will hopefully even tell you how to fix the problem ;-)
10:03:30 <emertens> has anyone here used "Clean" ?
10:03:39 <SamB> unfortunately when Haskell programs do go bang at runtime you don't get a very nice traceback :-(
10:04:00 <sehute> emertens: I've tried TileStudio that I think is written in Clean. It's a great program.
10:04:09 <sehute> emertens: The Clean example-games also work great.
10:04:10 <ndm> SamB, yet...
10:05:20 <SamB> though unless you hit "Prelude.head: empty list" or the like you can usually figure out what function went wrong
10:05:55 <monochrom> This is sad.  There is much advocacy written on how dynamic ___ helps building complex systems.  You are the first I hear from the field saying it actually doesn't scale, effectively telling me all the dynamic typing advocacy is hogwash.
10:06:28 <ndm> SamB, i am also trying to eliminate that staically as well
10:06:52 <SamB> ... and that, my friends, is why we must work on improving Haskell performance for VM applications ;-)
10:07:01 <ndm> for example I can prove head (reverse (x:xs)) is safe etc.
10:07:02 <SamB> well. sortof.
10:07:27 <SamB> well it helps if you only used Prelude.head twice in your program ;-)
10:08:02 <ndm> I have also defined headNote msg x = case x of [] -> error $ "head " ++ msg ; (x:xs) -> x
10:08:18 <ndm> saves a lot of time once you have a massive program
10:08:37 <sehute> monochrom: it's the truth
10:09:42 <sehute> monochrom: dynamic typing is fantastic for writing small applications and testing out algorithms, though
10:09:49 <SamB> sehute: I know exactly what you mean, even though I haven't written such large programs, I have come close enough to get a taste of the problem ;-)
10:10:08 <SamB> sehute: better than C, anyway
10:10:13 <sehute> SamB: then we are brothers in programming-spirit :D
10:10:41 <SamB> I dunno that dynamic typing is any better for testing algorithms than well-inferred static typing ;-)
10:11:00 <paj> I glanced thru one of Oleg's papers, where he started by creating a type-safe version of head & tail, and then went on to more complex stuff
10:11:08 <sehute> SamB: they are probably equally good :)
10:11:27 <sehute> SamB: although I see that haskell/fp is the king on certain algorithms
10:12:01 <SamB> I just checked my last Haskell program, which is a partial solver for the adventure puzzles in this years ICFP, and found one type signature that wasn't in a type or class definition
10:13:33 <sehute> If I ever start a rock-band, I will name it The Well Inferred
10:14:05 <paj> Not the Strong Types?
10:15:55 <dmhouse> *sigh* I don't think I'll ever be able to write imperative code again.
10:16:01 <monochrom> WIWFWCWHNF
10:16:11 <dmhouse> I'm hacking together some Emacs lisp, and it looks like bastardised Haskell.
10:16:19 <monochrom> well inferred well formed well checked weak head normal form :)
10:17:03 <monochrom> A certain unverified historical scripture claims that that was the original, abandoned name for Haskell.  XD
10:17:10 <dmhouse> Haha :)
10:18:26 <sehute> paj: that one's good too :)
10:18:30 <dcoutts> ndm, ok, sounds great
10:18:41 <dcoutts> ndm, the LPS invariant I mean
10:18:55 <ndm> cool, am just rewriting the core of my checker
10:19:04 <dcoutts> and if you do get reproducable test cases for the gui errors then send me the code
10:19:21 <ndm> will do, although will make sure i upgrade to the latest versions first for everything
10:20:06 <SamB> this thing is so crazy
10:20:16 <SamB> my mouse skipped a beat it is swapping so hard
10:21:42 <SamB> all I did was type "i", too!
10:22:51 <monochrom> I just saw syntaxpolice on haskell-cafe pointing out the counterexample "f _ = f 'a' " to "f bot = bot ⇒
10:23:04 <monochrom> f strict".  My world is undone.
10:24:40 <SamB> well, that only works if "f something_not_bottom = something_else_not_bottom"
10:25:36 <SamB> I meant, const (error "foo") is about the same
10:26:00 <SamB> and you wouldn't even think for an instant that that was strict, would you?
10:26:56 <monochrom> This is very hard!
10:27:14 <monochrom> Haskell is hard
10:27:39 <SamB> \
10:27:40 <SamB> er
10:27:47 <SamB> sometimes it is, yes
10:28:00 <shapr> @YOW!
10:28:01 <lambdabot> Unknown command, try @list
10:28:01 <SamB> but that is because you use it for hard problems, usually
10:28:05 <shapr> @ Y O W !
10:28:11 <SamB> @yow
10:28:12 <lambdabot> TONY RANDALL!  Is YOUR life a PATIO of FUN??
10:30:06 <shapr> @seen bringert
10:30:06 <lambdabot> I saw bringert leaving #haskell.se and #haskell 3 hours, 6 minutes and 58 seconds ago, and .
10:30:09 <shapr> foo
10:30:45 <dmhouse> Grr. Languages with higher-order functions should be lazy.
10:30:53 <jer> dmhouse, why?
10:30:58 <sieni> why?
10:31:07 <dmhouse> I hate Lisp's esoteric series of different quotes.
10:31:19 <sieni> dmhouse: you can always spank the lambda
10:31:51 <jer> dmhouse, okay, so that condemns lisp, what about other languages with higher order functions that are strict? seriously curious, not trying to troll
10:32:04 <dmhouse> jer, can you name any?
10:32:07 <jer> dmhouse, io
10:32:12 <sieni> dmhouse: ml doesn't have any quoting?
10:32:21 <jer> though io is strict but with a lazy feature
10:32:27 <dmhouse> sieni: ah, that's true, I forgot about that one.
10:32:38 <jer> oh right, forgot about ml =]
10:32:42 <monochrom> I hate Lisp :)
10:32:49 <SamB> yeah.
10:32:57 * sieni is reading Lisp In Small Pieces right now <3
10:33:06 * dmhouse was temporarily under the impression that call-by-value languages always had to quote values they didn't want evaluated
10:33:09 <SamB> it is worse tham Python -- the modules don't work and are underused
10:33:14 <dmhouse> monochrom: well, I think I'm starting to get that impression.
10:33:18 <dmhouse> It feels... old.
10:33:35 <sieni> dmhouse: lisp has symbols, and quoting prevents a symbol to be evaluated to its associated value
10:33:48 <dmhouse> It definitely doesn't feel as polished or as thought through as Haskell.
10:33:50 <dmhouse> sieni: yes.
10:34:04 <monochrom> ML has higher-order functions and behaves lazy when you write "fun f () = 1/0".  IMO it is good.
10:34:06 <SamB> never mind that a symbol has at least *two* associated values, some of which are stored in the *symbol itself*
10:35:35 <sieni> monochrom: of course lambda expressions are lazy, whatever that means. The body of the function is not evaluated before the function is applied, which is precisely how laziness is implemented in lisp or ml (i.e. by spanking the lambda)
10:36:22 <SamB> its actually about the same in the end as what Haskell does...
10:36:31 * dmhouse ponders about being able to statically check divide-by-zero errors
10:36:38 <SamB> except of course the end is not where you write programs
10:36:39 <shapr> Epigram?
10:37:10 <sieni> dmhouse: think also about the halting problem
10:37:24 <dmhouse> sieni: ?
10:38:04 <sieni> dmhouse: well, you can always write something like 1 / (if foo then 1 else 0), where foo is arbitrarily complicated.
10:38:26 <dmhouse> That's true.
10:38:31 <dmhouse> And if foo involves IO...
10:38:40 <dmhouse> Well, I suppose it can't.
10:38:41 <SamB> that would be cheating.
10:38:50 <dmhouse> And that means foo's computable at compile-time.
10:39:02 <shapr> sieni: Epigram beats it by not being turing-complete.
10:39:10 <dmhouse> But it's probably a bad idea to do so, because it might diverge, and diverging compilations aren't much fun.
10:39:15 <sieni> shapr: that's a solution, yes
10:39:15 <LordBrain> what is MonadIO for? as opposed to just IO say?
10:39:24 <dmhouse> ?instances MonadIO
10:39:25 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
10:39:25 <sieni> re all
10:39:35 <SamB> foo is only computable at compiletime if the language ain't turing complete
10:39:40 <dmhouse> ?index MonadIO
10:39:41 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:39:51 <dmhouse> SamB: why?
10:39:58 <SamB> which is to say that there is no halting problem
10:40:10 <SamB> well, okay.
10:40:14 <SamB> depending on foo.
10:40:24 <SamB> maybe sometimes the compiler could prove it would halt...
10:42:51 <dmhouse> SamB: well, if you don't care about the fact your compilaton might diverge, then it's computabe.
10:43:01 <SamB> remind me to never hire the people who wrote the codex to write anything performance-critical
10:43:37 <SamB> or anything that must run in finite RAM
10:43:50 <dmhouse> _Finite_ RAM? How boring :)
10:44:02 <shapr> sieni: On the other hand, Epigram is planning to add a fix operation..
10:44:21 <dmhouse> shapr: is Epigram strictly normalising?
10:44:32 <shapr> Yes, for the most part...
10:44:32 <SamB> if you look at the UM spec, you'll see it doesn't make any allowances for running out of platters or indeed for running out of 32-bit identifiers for arrays
10:44:38 <dmhouse> *strongly.
10:44:44 <dmhouse> shapr: the 'most' part? :)
10:44:59 <shapr> Yeah, it'll be strongly normalizing with fix.
10:45:11 <dmhouse> Huh?
10:45:13 <SamB> in fact, it specifically calls for an infinite supply of platters, despite the fact that it can only access up to...
10:45:13 <Philippa> or rather, SN before you use fix, and you can tell when you've used it
10:45:21 <Philippa> you can't be SN *and* have fix *and* be a lambda calculus
10:45:24 <shapr> right
10:45:39 <Philippa> at least, not one worth talking about, as the simply-typed lambda calculus + fix is turing complete
10:45:39 <neologism> what is SN?
10:45:42 <shapr> dmhouse: You'll get to develop code that terminates. Once that works, you can add the looping construct.
10:45:49 <dmhouse> neologism: strongly normalising. No divergence, basically.
10:45:58 <neologism> thnx
10:46:10 <Igloo> ISTR CM saying there will be 3 distinct levels: Everything terminates, types terminate and nothing terminates
10:46:10 <SamB> > (2^32-1)*2^32 -- +n of them, where n is the size of array 0
10:46:12 <lambdabot>  18446744069414584320
10:46:14 <Philippa> neologism: always terminates, always does it "the same way" however you go about it. It's rare to find a lambda calculus that's normalising but not strongly normalising though
10:46:22 <Igloo> (guaranteed to terminate, that is)
10:46:24 <SamB> which in practical terms means no more than:
10:46:28 <SamB> > 2^64
10:46:29 <lambdabot>  18446744073709551616
10:46:41 <shapr> Guaranteed termination has some very nice properties.
10:46:55 <shapr> It's especially handy when your typechecking algorithm does that, for example.
10:47:33 <shapr> iirc, -fglasgow-exts means that GHC's typechecking is no longer guaranteed to terminate. But it usually will :-)
10:47:34 <dmhouse> Philippa: can you have SN and fix? How does being a lambda calculus change things?
10:47:43 <SamB> actually...
10:47:45 <SamB> it would be
10:47:56 <SamB> > 2^32*(2^32-1)
10:47:58 <lambdabot>  18446744069414584320
10:48:08 <SamB> because you can't allocate an array of size 2^32 anyway
10:48:15 <shapr> dmhouse: It's like developing with debug mode on, and then turning off debug mode for the real program.
10:49:14 <dmhouse> Weird.
10:49:16 <monochrom> Rank-unlimited polymorphism is a reason.  GHC makes do by appealing to the S-m-n theorem.
10:49:49 <shapr> Simon-Marlow-never uses rank-unlimited polymorphism?
10:49:58 <dmhouse> :)
10:50:05 <SamB> heh
10:50:06 <monochrom> The S-m-n theorem says that you can always give up after n steps. :)
10:50:24 <SamB> isn't that called the "time out" theorem?
10:50:37 <dmhouse> "In practical terms, the theorem says that, given any programming language and integers m,n>0, there is an algorithm with the following property: given the source code for a function with m+n arguments and values for the first m as input, it outputs the source code for a function that effectively hardcodes the first m arguments to those values."
10:51:06 <monochrom> I probably read old textbooks and they probably tend to use old, intimidating names.  Yes "time out" is a much much better name.
10:51:10 <SamB> what if the programming language does not have functions?
10:51:34 <monochrom> Hmm I misremember the S-m-n theorem?
10:52:37 <SamB> hmmhmmhmm
10:53:01 <SamB> I *really* wish they'd used a proper adventure system for this "adventrue" game...
10:53:07 <SamB> er. "adventure"
10:53:29 <SamB> *this* system uses too much RAM
10:54:24 <SamB> and though it doesn't seem to cut off any from reachability, it also seems not to deallocate it
10:58:19 <cayl> ?Epigram
10:58:19 <lambdabot> Unknown command, try @list
11:02:09 <ndm> @where Epigram
11:02:10 <lambdabot> http://www.e-pig.org/
11:02:54 <ndm> @tell dons @epigram should do a where if there is not a command, or a @quote/@seen if a username
11:02:55 <lambdabot> Consider it noted.
11:04:34 <xerox> Should it?
11:04:55 <xerox> You wouldn't be suggested of the help anymore.
11:07:25 <ndm> xerox, where it perfectly matches a where or a username
11:12:20 <cayl> Is "Epigram" a programming language?
11:12:56 <sylvan> cayl, yes
11:13:23 <sylvan> a very cool one at that, albeit perhaps not immediately useful for boring things lik "real world applications"
11:13:40 <cayl> Oh. yeah. I saw the link... I will browse to it.
11:21:33 <SamB> hmm.
11:22:15 <SamB> I sorta doubt my solver will handle this one... ack...
11:29:33 <therp> there is none on this channel who has a copy of the source to the "Typing Haskell in Haskell" paper? the original papers website seems unavailable
11:30:33 <ndm> therp: i noticed that a few days ago, have it at work, but not at home
11:30:59 <dcoutts> foxy_, so all the problems are with focusing
11:31:13 <therp> ndm: oh neat, do you think it would be possible to send me a copy? I hesitate to bother the author with this
11:31:18 <dcoutts> foxy_, if you make focusGtkWindow do nothing then all the warnings go away
11:31:40 <dcoutts> foxy_, and the reason for the warning is that you're trying to set the focus on a window that is not visible
11:31:56 <therp> ndm: clemens@endorphin.org or in case you lose that, my mail is in my whois
11:32:37 <dcoutts> foxy_, what you want to do instead is to switch which tab of the notebook is currently visible
11:33:04 <dcoutts> once it is visible you may still want to use widgetGrabFocus
11:33:11 <dcoutts> depends on what behaviour you want
11:33:44 <mnislaih> therp: I have it around if you still need it
11:33:49 <emertens> What does the symbol `` |- '' mean?
11:34:01 <therp> mnislaih: yes please. clemens@endorphin.org
11:34:05 <ndm> therp: will do, tomorrow
11:34:12 <cayl> emertens, entails?
11:34:13 <ndm> oh, won't bother if you already have it...
11:34:24 <therp> mnislaih: or dcc or any url I can grab it from?
11:34:31 <SamB> oh, there isn't anything in need of assembly here anyway, heh
11:34:41 <mnislaih> I'll email it
11:34:48 <ndm> therp: the codes also gone, which is more important, i think
11:34:54 <therp> mnislaih: thank you!
11:35:15 <therp> ndm: I was talking about the code, the paper is still available from citeseer
11:35:17 <emertens> cayl: what does that mean in the context of: Gamma `entails` s `is a member of` sigma
11:35:36 <mnislaih> oh, you want the code?
11:35:42 <mnislaih> I dont think I have it
11:35:46 <therp> mnislaih: aehm yes
11:36:06 <mnislaih> sorry :S
11:36:28 <therp> no prob :) .. ndm have you been referring to code or a copy of the paper?
11:37:34 <cayl> emertens, i dont know. i jost read in the book "intermediate logic" (dont remember the author) doesnot seams to be the same context.
11:38:03 <ski> emertens : very roughly, assuming 'Gamma' it follows that 's `is a member of` sigma'
11:38:27 <dmhouse> emertens: is this type theory?
11:38:32 <emertens> ski: is that related to `implies` -->
11:38:33 <ndm> therp: both
11:38:43 <emertens> dmhouse: I saw it in the tutorial to Epigram
11:38:49 <ski> emertens : related, yes
11:38:53 <ndm> therp: will mail it over tomorrow
11:38:59 <cayl> emertens, "related"
11:39:07 <therp> ndm: thank you! :)
11:39:11 <mnislaih> ndm: CC me the code too if you dont mind
11:39:13 <dmhouse> emertens: |- is basically =>. Gamma |- s : S means that 'according to the typing context Gamma, s has type S'.
11:39:30 <ndm> mnislaih: email address?
11:39:39 <therp> I guess the code is reconstructible from the paper but that would involve cutpasting lot's of sniplets out of the pdf, which is usually not working very well for pdfs.
11:39:46 <mnislaih> mnislaih at gmail.com
11:40:03 <ndm> therp: not sure if its complete or not, it crtainly doesn't have all the examples of parsed source in the tarball
11:40:13 <ski> (except '|-' is a meta-level predicate, not an object-level connective)
11:42:30 * therp is reading pierce's nice "types and programming languages" at the moment.
11:43:09 <dmhouse> therp: me too
11:43:21 <therp> learning how to read |- was easy, but learning how to think of fixed points of generating functions on the power of sets to do type checking on infinite type tree's is not that nice
11:43:27 <therp> dmhouse: already at chapter 21?
11:43:43 <dmhouse> therp: no, I'm still in the subtyping chapter.
11:43:54 <dmhouse> therp: why?
11:43:59 <therp> that chapter is taking a bit long, I think I grasped the main idea, but I'm still stuck on how to build a mental modell of coinduction
11:44:00 * mnislaih happens to be reading Pierce's book too
11:44:13 <mnislaih> I'm only in chapter 9
11:44:39 <dmhouse> therp: what's chapter 21 then?
11:44:48 <therp> dmhouse: the subtyping chapter is nice. I'm at the moment implementing a lambda like language (actually just an evaluator, type checker for an AST)
11:44:56 <therp> dmhouse: a meta-theory of recursive types
11:45:03 <dmhouse> Ah.
11:45:44 <therp> I'm a bit confused as chapter 25 (System F) seems to be untypable. that is no type inference. but I'm not sure how haskell's type system is different from system F so I'm looking at the typing haskell in haskell paper at the moment to find out
11:46:48 <therp> dmhouse: pierce's ML implementations are really a great help. I implemented my own type inference thanks to his code that comes handy when the book doesn't give you a clear picture of what to do.
11:47:06 <monochrom> I keep forgetting the definition of System F, but yes there is some powerful thing omitted in Haskell.
11:47:10 <therp> in fact, the whole book is really written very well, I just lend it from my library, but I'm seriously consider buying it
11:47:54 <dmhouse> Hindley-Milner is a restriction of System F, plus fix.
11:48:10 <emertens> Anyone have a good link for examples of what ML code looks like?
11:48:11 <therp> monochrom: I fail to see the difference between typing of for example the identify function \x.x in system F and haskell. both can type it correctly, but the next-less powerful system I know below system F can't do that.
11:48:18 <emertens> Haskell is really the only functional language I've played with
11:48:54 <sieni> emertens: well, you can download e.g. mlton sources from mlton.org
11:49:13 <sehute> emertens: I think Wikipedia has a collection of "hello world", if I remember correctly
11:49:45 <sieni> emertens: one slightly annoying difference between standard ml and haskell is that the meaning of : and :: is inverted ^_^
11:50:10 <dmhouse> And case in ML uses syntax like Haskell's guards.
11:50:14 <emertens> Hello World doesn't really flex what makes a language interesting :)
11:50:17 <therp> dmhouse: so haskell is a "hindley-milner" type system? I still know to less about the classifications type system to know the difference. (just asking to know what to google for)
11:50:28 <sieni> emertens: http://mlton.org/pages/Download/attachments/mlton-20051202-1.src.tgz
11:50:40 <sieni> there's a complete standard ml compiler
11:51:01 <dmhouse> therp: well, it used to be, but we've added so many extensions it's a bit of a loose connection now :)
11:51:12 <monochrom> Ban the Hello World.
11:51:27 <paj> See also http://www.99-bottles-of-beer.net/language-haskell-302.html
11:51:31 <lambdabot> Title: 99 Bottles of Beer | Language Haskell
11:51:42 <therp> dmhouse: I was suspecting that :), but the core is HM?
11:51:47 <SamB> dmhouse: but, but, we have parametric polymorphism still! that must surely count for something!
11:52:25 <dmhouse> therp: yep.
11:52:27 <therp> samb: HM doesn't have parametric polymorphmis?
11:52:44 <SamB> therp: isn't that one of the main features?
11:52:45 <dmhouse> The biggest change from HM is type classes.
11:52:59 <SamB> of HM, I mean
11:53:07 <therp> samb: I thought parametric polymorphism==System F and System F is as far as I know untypable.
11:53:27 <SamB> oh that
11:53:34 <Failure02> what's this syntax: n[a..b]?
11:53:38 <dmhouse> therp: I don't think it's 'untypable'. Terms can have types, but type inference is undecideablr.
11:53:41 <therp> or am I mixing up terms?
11:53:42 <dmhouse> *undecideable.
11:53:49 <SamB> parametric polymorphism is not the same thing as "system F", I'm fairly certain
11:53:52 <Failure02> which can be seen here: http://www.gamedev.net/community/forums/topic.asp?topic_id=406551&whichpage=1&#2704076
11:53:58 <dmhouse> Failure02: [a..b] means all the elements between a and b. No idea what that n's going.
11:54:01 <dmhouse> *doing
11:54:14 <therp> dmhouse: yes, undecideable was the think I meant with untypable.
11:54:26 <monochrom> Perhaps n is a list function. n[a..b] is n [a..b]
11:54:45 <dmhouse> monochrom: read the link, though.
11:54:50 <Failure02> still wouldn't work in that code snippet though
11:54:51 <monochrom> oops
11:54:57 <dmhouse> Failure02: I think that's a typo.
11:55:00 <mnislaih> GHC hackers: is it bad practice or not recommended, to use code from packages other than base?  I am using the State monad from the mtl
11:55:14 <Failure02> hm, he wrote it 5 times...
11:55:29 <ski> Failure02 : pseudo code ?
11:55:41 <SamB> mnislaih: if worst comes to worst you could copy+paste it in
11:55:59 <mnislaih> no I mean, to use code from the mtl in ghc sources
11:55:59 <therp> samb: hm, I thought those things where synonms. I'm not at System F yet, at the moment I'm struggling with recursive types.
11:56:27 <SamB> therp: nah, they aren't synonyms
11:56:28 <Failure02> pseudo code for some list slicing thingy?
11:56:36 <monochrom> Yes.
11:56:54 <SamB> therp: because I know what parametric polymorphism *is*, and I don't know what System F is exactly
11:57:07 <mnislaih> as I couldnt find any evidence in the rest of ghc sources of the use of an 'external' package, it looks like maybe I shouldn't do it (even though the code seems to work fine)
11:57:23 <monochrom> The author doesn't know Haskell.  In particular he doesn't know immutability, cons lists, or the Haskell notation for slicing.
11:57:23 <Failure02> it's weird how he says it's in-place, too.
11:57:39 <SamB> mnislaih: I really don't think it will be a be a problem
11:57:59 <Failure02> well he knew its syntax, so that's why i didn't immediatley jump to that conclusion
11:58:07 <Failure02> -e
11:58:18 <monochrom> Please don't try to understand it.  It's random.
11:59:14 <monochrom> He knows just enough to get everyone confused.
12:00:09 <Failure02> i guess so
12:01:01 <monochrom> If you frequent #math on freenode, you will see it is quite possible to emit incoherence and still lead people to think you are on to something.
12:01:27 <Failure02> :)
12:01:54 <SamB> and on IRC it doesn't even need to be properly typeset
12:02:40 <therp> samb: I just looked it up in the book, and it seems that parametric polymorphism is equal to system F but ML-styled is a less powerful form of parametric polymorphmis called let-polymorphism or "ML-style" polymorphism, which allows on the other type reconstruction
12:03:03 <therp> samb: or let me rephrase it, system F is the most powerful form of parametric polymorphism
12:03:22 <therp> that's at least what the pierce's book says
12:03:24 <SamB> therp: I don't doubt that
12:03:43 <SamB> System F seems a bit overpowered
12:04:24 <therp> I'm right in the middle of comprehending it, but it seems so, because haskell (!= system F) is powerful enough for me
12:04:30 <lightstep> ?where paste
12:04:30 <lambdabot> http://paste.lisp.org/new/haskell
12:04:55 <dmhouse> therp: I'd say Haskell's type system could be more powerful.
12:05:05 <therp> but thanks samb, that clears up a misunderstanding of mine
12:05:26 <SamB> well, in my mind anything with totally undecidable type-checking (in practice as well as in theory) is overpowered.
12:05:31 <lisppaste2> lightstep pasted "problem with instantiation" at http://paste.lisp.org/display/23387
12:05:43 <SamB> that is, assuming it has/is a typesystem
12:05:56 <lightstep> i want to parse types, so i tried a simple example first, but it doesn't work. can anyone help me with this?
12:07:01 <lisppaste2> lightstep annotated #23387 with "the error ghci gives" at http://paste.lisp.org/display/23387#1
12:07:53 <ski> undecidable type-checking /= undecidable type-inference
12:08:04 <emertens> www.99-bottles-of-beer.net has some neat examples, but too many of the submissions attempt to be clever, rather than give a good example of the language
12:08:09 <SamB> ski: oh, right
12:08:22 <emertens> If they would have focused on decent examples, that site could be really interesting
12:08:28 <SamB> okay, so undecideable inference for *certain constructs* is fine by me
12:08:43 <SamB> I mean I never expect the compiler to figure out what type a type constructor has...
12:08:45 <ski> e.g. polymorphic recutsion
12:08:55 <SamB> yeah, stuff like that ;-)
12:08:55 <ski> s/recutsion/recursion/
12:09:10 <SamB> er, data constructor
12:09:11 <ski> and GADTs
12:10:39 <emertens> @type Data.Array.ST.newArray
12:10:41 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
12:17:50 <SamB> @instances-importing Data.Array.ST MArray
12:17:52 <lambdabot> STArray s) e (ST s, STUArray s) Bool (ST s, STUArray s) Char (ST s, STUArray s) Double (ST s, STUArray s) Float (ST s, STUArray s) Int (ST s
12:17:55 <SamB> hmm
12:18:05 <cayl> @where System F
12:18:06 <lambdabot> I know nothing about system.
12:18:07 <SamB> something is wrong here!
12:18:11 <cayl> @where System_F
12:18:12 <lambdabot> I know nothing about system_f.
12:18:17 <SamB> @google "system f"
12:18:21 <dmhouse> SamB: looks like it :)
12:18:21 <lambdabot> http://www.purple-eye.com/
12:18:21 <lambdabot> Title: Purple Eye Entertainment - (Tsunami, Carnal, Tatsumaki, Tremolo, Bomboza, 1969 R ...
12:18:31 <cayl> SamB, thanks.
12:18:31 <SamB> h,,/
12:18:38 <SamB> er.
12:18:39 <SamB> hmm.
12:18:40 <dmhouse> (System F is also the name of a trance group.)
12:18:53 <SamB> apparantly that is *not* the right place
12:18:58 <SamB> @google "system f" type
12:18:59 <cayl> :)
12:19:01 <lambdabot> http://en.wikipedia.org/wiki/System_F
12:21:23 * SamB_XP decides to let "adventure" catch up before doing anything more on that computer
12:21:34 <SamB_XP> (like I have a choice ;-)
12:22:19 * cayl is reading t a p l by Benjamin C. Pierce, too
12:23:01 <lispy> wow, so the fastest haskell UM is still 4x the speed of the fastest C UM
12:23:09 <SamB_XP> is it really?
12:23:14 <SamB_XP> show me!
12:23:23 <lispy> http://www.cse.unsw.edu.au/~dons/um.html
12:23:26 <lambdabot> Title: Haskell UM
12:23:29 <lispy> i think i phrased that poorly
12:23:29 <edwardk> heya
12:23:32 <SamB_XP> I don't suppose that accounts for swapping?
12:23:34 <lispy> the C is much faster
12:23:38 <SamB_XP> oh oh
12:23:39 <edwardk> yeah
12:23:39 <SamB_XP> rats
12:23:40 <Dr_Pi> Oh, so Haskell is a restriction on System F.
12:23:53 <edwardk> well, i have a perl one thats faster still, but only on the second or third run =)
12:23:58 <lispy> with edwardk having the fastest C! (congrats man!)
12:24:00 <SamB_XP> Dr_Pi: does System F have typeclasses?
12:24:18 <SamB_XP> lispy: apparantly that was an anomoly
12:24:20 <lispy> edwardk: hehe yeah i heard about the hour "compile" time :)
12:24:24 <edwardk> dons i don't think has been willing to let it run for the requisite number of hours to get through the jitting stage =)
12:24:55 <SamB_XP> edwardk's being faster than mine, I mean
12:25:02 <edwinb> Haskell (at least GHC) uses something very much like System F as its core language, with typeclasses translated into it.
12:25:15 <SamB_XP> apparantly dons was using a GCC that he has since rejected
12:25:22 <Dr_Pi> SamB_XP: I don't know, I was just reading the Wikipedia entry.
12:25:51 <edwardk> is haskell still using henk internally?
12:25:57 <SamB_XP> henk?
12:26:21 <lispy> edwardk: in that case are you refering to a particular implemenation of haksell?
12:26:25 <lispy> haskell*
12:26:41 <edwardk> 'henk' was the name that simon pj and company named the intermediate representation, after the guy who formalized the lambda cube, henk berendregt.
12:26:43 <edwardk> ghc
12:26:46 <edwardk> my mistake =)
12:26:51 <SamB_XP> hehe
12:26:56 <SamB_XP> how come I knew you meant GHC?
12:27:03 * SamB_XP thinks this may be a bad sign
12:27:12 <edwardk> because other implementations don't exist to me ;)
12:27:27 <lispy> because at times this could be #ghc instead of #haskell :)
12:27:28 <SamB_XP> yeah, exactly the bad sign I meant
12:27:33 <lispy> but i'm feeling pedantic
12:27:50 <edwardk> anyways henk was based on a pure type system model lacking the far side of the lambda cube coz they didnt want to deal with dependant types.
12:28:11 * lispy is sad after finding out that pancakes are in fact very high in fat
12:28:12 <SamB_XP> I suppose it is a sign of the limited size of the Haskell community
12:28:28 <edwardk> yeah, all 12 of us use ghc =)
12:28:44 <lispy> edwardk: 13, one of my friends started learningit :)
12:28:48 <edwardk> except meacham. he's a weirdo =)
12:29:04 <SamB_XP> we do not have enough core hackers to keep multiple implementations at the state-of-the-art
12:29:24 <lispy> we don't have enough core hackers to keep ghc maintained on all of its platforms :)
12:29:29 <edwardk> heh
12:29:38 <SamB_XP> well that is more usual
12:29:43 <SamB_XP> you get that with anything
12:29:47 <lispy> ah
12:29:55 <SamB_XP> to some extent or other
12:30:03 <SamB_XP> unfortunately, in this case one of those is windows...
12:30:06 <lispy> but i don't have a problem with ghc being the de facto standard
12:30:25 <lispy> otoh, competetion helps drive the state of the art...
12:30:44 <SamB_XP> so we need to attract more JohnMeachams
12:30:45 <edwardk> well, then consider it moving to a meta-level competition against other languages ;)
12:31:34 <SamB_XP> at least it isn't the same implementation that is at the state-of-the-art in all areas ;-)
12:31:46 <cayl> @google lambda cube
12:31:49 <lispy> SamB_XP: yeah, from what i gather, if jhc became mainstream ghc would have to produce code with a better footprint in order to stay competetive
12:31:49 <lambdabot> http://en.wikipedia.org/wiki/Lambda_cube
12:32:05 <SamB_XP> lispy: not quite
12:32:08 <edwardk> cayl: you might also look up 'pure type systems'
12:32:17 <edwardk> it gives a much better abstraction than the cube, and contains it
12:32:19 <SamB_XP> not unless jhc can muster hs-plugins
12:32:32 <edwardk> and the rules are short enough to memorizze =)
12:33:18 <lispy> SamB_XP: fwiw there are actually two C implementations ahead of yours
12:33:19 <edwardk> the problem i have with jhc is that it doesn't seem to scale well at all because of that holistic analysis thing
12:33:23 * SamB_XP wonders why Frederick has a vanity mask
12:33:39 <SamB_XP> lispy: oh nice
12:33:47 <SamB_XP> edwardk: yeah
12:33:53 <lispy> SamB_XP: but the stddev is probably large enough to account for the difference in run times
12:33:54 <SamB_XP> I home JohnMeacham is working on that
12:34:07 <Frederick> SamB, I don't grok you
12:34:19 <SamB_XP> if we had more of them, others most likely would
12:34:27 <SamB_XP> s/home/hope/
12:34:33 <SamB_XP> --> Frederick (n=imanewbi@unaffiliated/frederick) has joined #haskell
12:34:44 <wolverian> heh, holistic analysis?
12:34:58 <Frederick> SamB_XP, it is a security measure
12:35:00 <SamB_XP> wolverian: whole-program optimization
12:35:02 <lispy> is taht another way of saying it's based on a lot of special cases?
12:35:07 <lispy> ah
12:35:11 <SamB_XP> Frederick: security?
12:35:31 <Frederick> SamB_XP, so they can't see my IP, ISP or any relevant info
12:35:41 <cayl> edwardk, "pure type systems"... i will remember. thanks.
12:35:41 <SamB_XP> who is "they"?
12:36:51 * SamB wishes for a UM with better locality of reference
12:37:17 <SamB> If I thought it would help, I'd make mine use libgc
12:37:18 <Frederick> SamB, evil script kiddies wich like to play hax00000r using DoS
12:37:29 <Frederick> http://freenode.net/faq.shtml#cloaks
12:37:30 <lambdabot> Title: freenode: frequently-asked questions
12:38:08 <edwardk> the last um i think i want to try is to get one working in javascript
12:38:23 <edwardk> since its the one thing people have emailed me about since i started posting them up on my website
12:38:55 * edwardk starts coding
12:39:09 <cayl> quit .
12:39:45 <emertens> I got my "vanity mask" so that I could get more IRC xp points
12:41:31 <SamB> emertens: XP?
12:41:37 <emertens> experience
12:41:38 <SamB> what level are you?
12:41:43 <emertens> oh, still 1
12:41:50 * SamB didn't know this was an RPG
12:41:55 <SamB> what level am I?
12:42:00 * lispy points at #idlerpg
12:42:09 <emertens> SamB: I couldn't tell you :)
12:42:53 <emertens> @karma SamB
12:42:54 <lambdabot> SamB has a karma of 9
12:42:58 <emertens> @karma emertens
12:43:00 <lambdabot> You have a karma of 1
12:43:06 <lispy> @karma lispy
12:43:06 <lambdabot> You have a karma of 4
12:43:06 <emertens> SamB: Looks like you are doing better than I
12:43:26 <emertens> am
12:43:40 <SamB> well most likely that is related to the huge amount of yacking I do here
12:43:40 * lispy thinks he will hack on a haskell angband clone for a bit
12:43:46 <lispy> hehe
12:43:56 <lispy> SamB: you yacker
12:44:23 <lispy> i find it amusing because it's so similar to hacker
12:44:36 <lispy> #haskell is apparently the home of hackers and yackers
12:44:37 <SamB> if you look at the statistics, you will see that I am in the top ten or twenty of all time and of this year
12:44:51 <lispy> what was the link again?
12:44:56 <lispy> @where stats
12:44:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/tmp/haskell.html
12:45:18 <emertens> 404
12:45:34 <SamB> I remember that not being the latest URL
12:45:42 <SamB> I will find the real URL
12:46:00 <lispy> thanks
12:46:01 <SamB> I will be devious and start at dons' home page!
12:46:59 <lispy> dons: hey, i grew up on a farm too...but yours looks prettier...and more exotic
12:47:02 <SamB> actually...
12:47:13 <SamB> http://www.cse.unsw.edu.au/~dons/irc/ seems to be it
12:47:14 <lambdabot> Title: Haskell IRC Activity
12:47:28 <SamB> though in fact my browser remembered it
12:47:49 <SamB> @help where
12:47:50 <lambdabot> where <key>. Return element associated with key
12:48:01 <SamB> @listmodules
12:48:02 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
12:48:02 <lambdabot> topic type unlambda url version vixen where
12:48:09 <zarvok> you want where+
12:48:11 <SamB> @help help
12:48:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:48:17 <SamB> @listcommands where
12:48:18 <lambdabot> Unknown command, try @list
12:48:52 <lispy> yeah, i don't see the link to it from his website at all
12:49:30 <lispy> oh wow, i'm #18 on the total list
12:49:58 <lispy> lol, i love the autogenerated commentary
12:50:07 <emertens> The "Most used words" list seems the most interesting to me
12:50:08 <lispy> "Is palomer stupid or just asking too many questions? 21.5% lines contained a question! "
12:50:41 <mel-gibson> what sall this about fucntional programming
12:50:53 <mel-gibson> how did people get alogn with c for so logn with this ne fangled crap?
12:51:30 <lispy> "Pseudonym has quite a potty mouth. 0.0% words were foul language. "
12:53:15 <zarvok> @where+ stats http://www.cse.unsw.edu.au/~dons/irc/
12:53:15 <lambdabot> Done.
12:53:22 <zarvok> @where
12:53:22 <lambdabot>  @where <key>, return element associated with key
12:53:26 <zarvok> @where stats
12:53:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
12:53:29 <zarvok> better
12:53:46 <emertens> ought to be a:
12:53:52 <emertens> @what http://www.cse.unsw.edu.au/~dons/irc/
12:53:53 <lambdabot> I know nothing about http://www.cse.unsw.edu.au/~dons/irc/.
12:54:55 <lispy> @type join seq
12:54:57 <lambdabot> forall a. a -> a
12:55:04 <lispy> @type join
12:55:05 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:55:10 <lispy> so what monadis that?
12:55:29 <lispy> > (join seq) 3
12:55:30 <lambdabot>  3
12:55:39 <emertens> @type seq
12:55:41 <lambdabot> forall b a. a -> b -> b
12:56:00 <lispy> Monad (->) ?
12:56:21 <emertens> > join [[1]]
12:56:22 <lambdabot>  [1]
12:56:31 <emertens> > join [[1],[2]]
12:56:32 <lambdabot>  [1,2]
12:57:18 <xerox> lispy: yes.
12:57:28 <lispy> xerox: how is bind defined?
12:57:44 <xerox> ?fptools Control.Monad.Reader
12:57:44 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
12:57:55 <lispy> why is it called reader?
12:57:59 <lightstep>  ?where tmr
12:58:03 <xerox> Because it is the dual of Writer.
12:58:05 <lightstep> ?where tmr
12:58:05 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
12:58:50 <lispy> xerox: this has always confused me :)
12:59:17 <dmhouse> lispy: because computations read from the environment.
12:59:26 <lightstep> lissy, you'd prefer to use Control.Monad.DynamicScope ?
12:59:41 <lispy> instance MonadReader r ((->) r) where
12:59:42 <lispy> ask       = id
12:59:42 <lispy> local f m = m . f
12:59:48 <xerox> lispy - It works like this: Reader = environment monad = (e ->); Writer = log monad = (a,w); State = reader `smooch` writer = s -> (a,s).
12:59:52 <lightstep> and having `local' called `fluidlet'
12:59:55 <edwardk> heh i finally made it into the top 25 on dons' irc logs
13:00:24 <AtnNn> @hoogle smooch
13:00:26 <lambdabot> No matches found
13:00:41 <xerox> AtnNn: it's no Haskell function =)
13:00:59 <AtnNn> just wondering :)
13:01:34 <lispy> xerox: hmm...
13:02:00 <xerox> (Prolly (e ->) is not proper syntax so you'll see ((->) e).)
13:02:30 <SamB> xerox: indeed
13:02:30 <lightstep> ?info ReaderT
13:02:31 <lambdabot> Unknown command, try @list
13:03:25 <SamB> xerox: types aren't allowed to be sectioned, just as you "type Flip a b c = a c b" doesn't do what you might want (at all at all!)
13:03:59 <xerox> Too bad.
13:03:59 <lightstep> type Smooch trans1 trans2 param m a = trans1 param (trans2 param m a); type StateT = ReaderT `Smooch` WriterT
13:04:11 <SamB> it isn't really a bad thing
13:04:22 <xerox> lightstep: this way one needs lifting.
13:04:33 <SamB> maybe Epigram or System F can do it
13:04:36 <lightstep> SamB, what will it do?
13:04:47 <lightstep> oh, it's just not legal?
13:04:52 * ski is surprised he got as high as 6th on most active nicks
13:05:29 <lispy> i'm surprised shapr is so highly ranked...i pretty much never bump into him
13:05:44 <mel-gibson> why bother with this uctial crap?
13:05:48 <mel-gibson> isnt c better?
13:05:54 <mel-gibson> why us efucntinal?
13:06:38 <ski> mel-gibson : are you asking about what functional programming is about, and how it's different from imperative programming ?
13:06:39 <lightstep> mel-gibson, programs in haskell are prettier than in c, in my opinion. this is worth the bother.
13:06:52 * emertens reminds the channel not to feed the trolls
13:07:01 <musasabi> System FC looked very nice, much better than System F.
13:07:12 <sjanssen> @google why functional programming matters
13:07:16 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
13:07:16 <lambdabot> Title: Why Functional Programming Matters
13:08:04 <emertens> I liked that paper in particular
13:08:13 <Cale> That paper should be called "Why Laziness Matters"
13:08:57 <emertens> I liked it because it gave me something to show the co-workers so that they could get a feel for Haskell
13:10:04 <sylvan> emertens, but that paper doesn't use Haskell...
13:10:37 <emertens> sylvan: for people that don't use anything but C# it's close enough
13:10:37 <emertens> to get a feel for what's going on
13:11:02 <emertens> makes it easier to show them other examples of things I was working on
13:11:31 <Cale> Someone should rewrite it just to replace the code examples with examples in actual Haskell code.
13:11:42 <sylvan> maybe someone should translate all the examples to Haskell and mail them to him, perhaps he'll put up a revised version..
13:11:47 <Cale> yeah
13:14:16 <emertens> One of the guys that typically knows what he's talking about, but whom I rarely get a chance to speak with said something about Haskell being a good language, but that it didn't implement Functors correctly. Is this some kind of wildly known "fact" or at leat "opinion" in the functional language community, or probably just his personal take
13:14:34 <Cale> Personal
13:14:48 <Cale> In fact, it might just be that he's using some other definition of functor
13:15:06 <Cale> Functors in Haskell are actually endofuctors on the category of Haskell types and functions
13:15:10 * lightstep nags about his question on type classes: http://paste.lisp.org/display/23387
13:15:39 <lispy> there are two data points that i know of in this discussion...1) every monad is a functor, but monad class doesn't require a Functor instance 2) Functiors in the ML world are totally different
13:16:28 <Cale> endofunctors*
13:16:54 <emertens> so if he was an ML programmer, that opinion might make sense?
13:16:59 <Cale> It might
13:17:10 <Cale> Though it would seem a little ill-informed
13:17:22 <musasabi> emertens: math functor != ML functor != Haskell functor.
13:17:30 <emertens> hmm.. alright
13:17:50 <Cale> but  Haskell functors are a specific kind of mathematical functor :)
13:18:24 <zarvok> In ML, a functor is just a module that can take arguments
13:18:31 <Philippa> indeed the obvious one if you're stuck with single-parm classes
13:18:39 <sjanssen> lightstep: what is the purpose of Copy?
13:19:15 <emertens> assuming that a simple concrete example exists, what is a simple concrete example of what a category is? (represented in Haskell)
13:20:02 <emertens> I realize that this could be a dumb question
13:20:32 <liyang> Functions? :)
13:20:55 <zarvok> heh, nearly anything is a category
13:21:03 <zarvok> I can
13:21:04 <Cale> emertens: Well, (almost) the only category we care about in Haskell is the category where the objects are Haskell types, and the arrows are Haskell-definable functions between them
13:21:09 <zarvok> 't think of a good example in haskell
13:21:58 <liyang> What Cale said. Composition is just function composition. Identity is, um... id :)
13:21:58 <emertens> arrows being the ones in:   f :: a -> b  ?
13:22:05 <emertens> or Control.Arrows
13:22:16 <lightstep> sjanssen, it is a trivial parser for Nat types (i actually want it to divide, but that's harder)
13:22:21 <Cale> emertens: arrows being the ones from the definition of a category
13:22:33 <Cale> emertens: not the ones from Control.Arrow
13:22:35 <emertens> oh
13:22:40 <emertens> the arrow is the function itself?
13:22:44 <Cale> yes
13:22:47 <emertens> ok
13:23:21 <lightstep> sjanssen, and then i'd have a more complex transformation rule, and have a type-class requirement on the remainder, rather than demanding it to be Z
13:23:38 <liyang> Control.Arrow is the same idea though.
13:24:37 * edwardk is somewhat amused to hear Cale repeat the same 'endofunctor' shpiel he gave me when i first showed up griping about the use of the word Functor =)
13:25:12 <psnl> ndm: thanks for your comments
13:25:17 <norpan> functor schmunctor
13:25:47 <Cale> Communism Schmommunism
13:26:11 <edwardk> otoh, I guess it follows the principle of least annoyance. They would rather field the handful of complaints from people who catch the distinction, that try to explain what a TypeEndofunctor object is =)
13:26:15 <Cale> You can dismiss anything with that technique, it's great :)
13:26:23 <norpan> yeah aint it
13:26:35 <Cale> genocide schmenocide
13:26:39 <edwardk> heh
13:26:53 <norpan> well, that's hard to argue
13:26:59 <Peter_Mc> VBasic Schmeebasic
13:27:48 <emertens> so telling me about endofunctors was a way to dismiss my question?
13:27:55 <edwardk> emertens: yeah =)
13:27:57 <emertens> :(
13:28:12 <edwardk> emertens: basically a functor in haskell isn't a mathematical 'functor'
13:28:36 <edwardk> because you can't write a forgetful funtor in haskell. you can only 'add structure'
13:28:45 <edwardk> er functor
13:29:12 <lightstep> edwardk, is that because the extra type variables become phantom?
13:29:57 <ski> edwardk : i don't see why that would mean it's not a math functor
13:30:09 <edwardk> basically. in category theory you could define a functor that takes, say a monoid, and forgets the extra structure for the binary operation and just returns the underlying set.
13:30:53 <edwardk> in haskell, i can only wrap it in something else
13:31:30 <emertens> @index Monoid
13:31:31 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
13:31:36 <edwardk> (a -> b) -> f a -> f b: i can't go the other direction (f a -> f b) -> a -> b   or even (f a -> f b) -> g a -> g b
13:31:50 <Cale> edwardk: Every Haskell functor is a mathematical functor
13:32:17 <Cale> (though the axioms can't be enforced by the compiler, so you do have to check them)
13:32:21 <edwardk> cale: yes. i was stating they aren't equivalent, not indicating which direction containment went =)
13:32:57 <liyang> So where do ML functors go then?
13:34:10 <Cale> They're something completely different
13:34:11 <liyang> And what about C++'s template functors?
13:35:11 <monochrom> That's yet another thing :)
13:35:31 <emertens> Are there (supposed to be) things that are instances of MonadPlus but not Monad?
13:35:38 <dmhouse> No.
13:35:42 <monochrom> This is not surprising.  Even "function" has three different meanings :)
13:35:49 <dmhouse> class Monad m => MonadPlus m where...
13:35:56 <emertens> Ok
13:36:05 <norpan> i find the idea of a non-terminating function appaling!
13:36:07 <sehute> what's the relation between Haskell and Maths, really? In simple terms, please :)
13:36:09 <norpan> function schmunction
13:36:29 <liyang> Haskell schmaskell
13:36:34 <xerox> Haskell \in Maths.
13:36:47 <dmhouse> sehute: different areas of Haskell relate to different mathematical concepts.
13:36:51 <emertens> dmhouse: I guess if something wants MonadPlus semantics without Monad semantics, it isa Monoid...?
13:36:58 <dmhouse> emertens: precisely.
13:37:03 <liyang> Everything \in Maths.
13:37:06 <sehute> dmhouse: can everything in Haskell be explained mathematically?
13:37:07 <liyang> (ZOMG PARADOX.)
13:37:08 <monochrom> Function: (a) referentially transparent, side-effect-free procedure. (b) referentially opague, side-effect-ful procedure. (c) gathering.
13:37:11 <norpan> maths \in everything
13:37:26 <monochrom> everything |= maths
13:37:41 <xerox> Church :-)
13:37:42 <dmhouse> sehute: that's a kind of weird question.
13:37:44 <monochrom> (everything is a model of maths)
13:38:15 <sehute> norpan: chemisists say that there's chemistry in everything, physicians says that there's physics in everything, dentists says that there's dentisism in everything, etc ;P
13:38:15 <dmhouse> sehute: Haskell finds implementations of different mathematical theories, like type theory.
13:38:16 <liyang> everything is an imperfect implementation of maths.
13:38:39 <sehute> dmhouse: I've just got the impression that Haskell is more closely related to maths than other programming languages
13:38:59 <dmhouse> sehute: Haskell is researched from a mathematical standpoint, yes.
13:39:00 <monochrom> Some programmer once complained about some API doc.  "What I want: in plain English, which functions to call, in what order."   I thought, dude, in plain English, functions are not called, functions are held.
13:39:01 <edwardk> sehute: i'd concur
13:39:41 <dmhouse> sehute: Haskell, and in fact functional programming in general, was developed by logicians and mathematicians.
13:39:51 <ndm> psnl: no porblem
13:40:02 <sehute> dmhouse: exactly
13:40:12 <sehute> so, is monads where Haskell differs from maths?
13:40:18 <dmhouse> sehute: what's different about functional prorgamming is that it's easier to _reason_ about how your program will behave.
13:40:22 <monochrom> Was McCarthy a logician/mathematician?
13:40:23 <ndm> psnl: so how many of those things you were prposing were new tools?
13:40:26 <dmhouse> sehute: no, monads came directly from mathematics.
13:40:30 <edwardk> no, monads are a mathematical concept roped into use by haskell
13:40:35 <emertens> This isn't anything "imperative" about the Reader monad... is there
13:40:51 <sehute> okay, so "do" is the dirty non-mathematical part of Haskell?
13:40:54 <dmhouse> emertens: what do you mean?
13:41:01 <monochrom> No, the Reader monad is not very imperative.
13:41:12 <norpan> do is not dirty
13:41:16 <norpan> IO is dirsty
13:41:18 <norpan> dirty
13:41:20 <Cale> sehute: do notation is just syntax sugar
13:41:22 <edwardk> sehute: well, do is just sugar, and because it decomposes down into function composition of pure functions its actually quite clean
13:41:24 <dmhouse> sehute: no, because 'do' can be translated to >>= and return, which are just parts of the monadic interface.
13:41:35 <_Codex> unsafePerformIO is dirty :)
13:41:39 <edwardk> heh
13:41:39 <dmhouse> IO is the dirty non-mathematical part of Haskell. :)
13:41:43 <sehute> okay, so what are the "dirty" parts of Haskell? IO only? :)
13:41:47 <Cale> yes
13:41:48 <norpan> _Codex: don't mention the u* function!
13:42:00 <Cale> and even IO is handled in a relatively clean way
13:42:02 <dmhouse> We kind of pretend we're passing around the state of the universe.
13:42:08 <edwardk> yeah, the IO monad is basically where everyone shoehorns whatever they don't have a clean mathematical abstraction for.
13:42:11 <dmhouse> Cale: 'relatively' being the key word.
13:42:16 <Cale> dmhouse: well, you can, I don't :)
13:42:20 <sehute> so, haskell without IO can be translated directly into maths, that any math-professor might understand? (theoretically)
13:42:26 <Cale> yeah
13:42:32 <sjanssen> sehute: the IO monad has been called the "sin bin"
13:42:35 <Cale> In fact, many mathy people like Haskell
13:42:36 <sehute> sjanssen: :D
13:42:59 <emertens> I saw the slideshow by simonj that called it the sin bin
13:43:00 <sehute> I'm non-mathy, trying to be mathy
13:43:04 <mahogny> sin bin indeed. replacement now kthx
13:43:04 <dmhouse> sehute: sure, you can translate it into the lambda calculus and prove (mathematically, using things like induction) varies things about your program (like, for example, that it's right).
13:43:08 <emertens> (not in person, unfortunately)
13:43:17 <Cale> If you want to learn monads, I wouldn't start with IO, since it's the worst possible example :)
13:43:21 <dmhouse> sehute: but if you're a hardcore pragmatist then Haskell is also for you :)
13:43:31 <sehute> dmhouse: that's cool
13:43:34 <edwardk> sehute: yeah, and in fact the lambda calculus translation is more or less how a haskell compiler actually works.
13:43:49 <edwardk> I really really like the STM monad.
13:43:55 <sehute> dmhouse: I love the idea that everything that's not IO could be directly translated to maths
13:43:59 <monochrom> "The best theory is inspired by practice. The best practice is inspired by theory."  Donald Knuth.
13:44:01 <edwardk> its my favorite monad example by far for showing off haskell.
13:44:13 <sehute> monochrom: that Knuth is some programmer
13:44:29 <emertens> I read "Lock Free DataStrucures using STM in Haskell"...
13:44:32 <emertens> awesome :)
13:44:35 <sehute> edwardk: what does STM do?
13:44:36 <edwardk> yeah, just don't ask knuth about functional programming =)
13:44:50 <sehute> edwardk: he's an oo-fanboy? :)
13:44:59 <emertens> @google "Lock Free Data Structures using STM in Haskell"
13:45:02 <lambdabot> http://research.microsoft.com/~tharris/papers/2006-flops.pdf
13:45:02 <dmhouse> sehute: STM is like concurrent programming on steroids.
13:45:11 <edwardk> software transactional memory is a way to write code that works in a safe multithreaded way but doesn't have to lock everything.
13:45:21 <dmhouse> But then again, a lot of Haskell is like things from other languages on steroids.
13:45:29 <sehute> edwardk: multiprocessors, here we come, in other words?
13:45:29 <emertens> STM reminds me of SQL transactions
13:45:33 <edwardk> it just rolls back what it does in the event of a conflict, and something always progresses.
13:45:45 <emertens> in teh way that you can think of writing them
13:45:53 <emertens> (obviously they are both considered "transactional")
13:46:01 <Cale> The cool thing about STM in Haskell in particular is that we can guarantee via the type system that transactions can be rolled back when they retry
13:46:05 <sehute> so, STM is to computing what SQL is to data?
13:46:13 <edwardk> sehute: yeah, it scales a heck of a lot better than traditional locin models and is compositional, so you can take two transactional pieces and put them together and not get any more deadlock scenarios.
13:46:17 <edwardk> yeah
13:46:25 <edwardk> s/locin/locking/
13:46:33 <Cale> You can't do things like writing to the network inside a transaction
13:46:33 <sehute> that's cool
13:46:41 <sehute> I want my own supercomputer (obviously)
13:46:48 <kuribas> How can I install the Hugs version of ByteString?
13:47:19 <sjanssen> kuribas: use runhugs -98 on the Setup.hs file
13:47:27 <sehute> Cale: well, that sounds sensible, for the good of concurrency, to avoid dirty IO :)
13:47:34 <liyang> (I should point out STM started out as a C library and then later a Java extension...)
13:47:40 <edwardk> I wound up reinventing STM in a database class actually (did a graduate research symposium presentation on the subject, etc), then I wound up coming over here and laughing my ass off to find it was really in use.
13:47:46 <Lemmih> kuribas: And give --hugs to the setup script.
13:47:46 <liyang> (I mean, STM is still a C library.)
13:47:54 <sjanssen> you probably have to do runhugs -98 clean before the standard configure, build, install incantations
13:48:02 <sehute> liyang: so now, finally, it's in programming-nirvana, after being born in both C and Java ;)
13:48:11 <liyang> And Perl 6
13:48:34 <sehute> how is Haskell compared to Lisp in terms of "powerfullness". About equal?
13:48:49 <norpan> superior of course
13:48:49 <ndm> kuribas: isn't Data.ByteString in the latest release of Hugs?
13:48:53 <liyang> sehute: they're both Turing-complete. :)
13:48:53 <norpan> why do you think we hang here
13:49:02 <dmhouse> liyang: gah! That's my joke. :P
13:49:06 <sehute> liyang: just like whitespace ;)
13:49:10 * dmhouse needs to type faster.
13:49:13 <sjanssen> sehute: Haskell is a general purpose programming language, there is all sorts of software written in Haskell
13:49:14 <kuribas> ndm: hmm, I don't know...
13:49:33 <sehute> norpan: :P
13:49:44 <ndm> kuribas: it definately is in the latest WinHugs, and I think it is on all Hugs platforms
13:49:49 <edwardk> anyways, as for the classic ACID properties of a database system, STM provides the A and I, and there is some stuff now to add C.
13:49:51 <ndm> Hugs> :l Data.ByteString should tell you easily
13:49:52 <sehute> dmhouse: every irc-channel should have a set of jokes delegated to its users ;)
13:50:03 <ndm> and a bot to tell them :)#
13:50:09 <sehute> ndm: ;)
13:50:14 <edwardk> I have a way to get D from my graduate symposium stuff, but I haven't figured out how to work it into a haskell context.
13:50:20 <dmhouse> We've got all the jokes we need:
13:50:21 <paj> I'd describe Haskell as higher level than Lisp.  Macros are procedural.  Haskell does the same things with lazy eval and monads, which are declarative
13:50:21 <dmhouse> @keal
13:50:22 <lambdabot> i prove infinity never ends in both directions
13:50:26 <liyang> edwardk: you're referring to 'always' ?
13:50:33 <dmhouse> (Those are _actual_ quotes.)
13:50:44 <dmhouse> paj, and higher-order functions.
13:50:48 <Cale> @keal
13:50:48 <lambdabot> T seems to be haskell, except with a decent interface at this point
13:50:51 <Cale> @keal
13:50:51 <lambdabot> Keal angry @ dons
13:50:53 <ndm> dmhouse: lisp has those
13:50:53 <Cale> @keal
13:50:54 <lambdabot> ghc need to have plugin that allow copy paste in xp
13:51:07 <edwardk> liyang: atomic consistent isolated durable. stm objects aren't durable. once written you aren't sure they stay written if you lose power etc.
13:51:09 <norpan> who is keal
13:51:11 <dmhouse> ndm, yes, but Lisp likes to use macros where a HOF could do.
13:51:20 <Cale> norpan: A crazy person who came here
13:51:20 <ndm> dmhouse: depends on the lisp programmer
13:51:21 <dmhouse> norpan: some guy that was here in... February?
13:51:24 <Cale> @keal
13:51:24 <lambdabot> pork steaks taste like dick
13:51:26 <liyang> edwardk: I mean, for the C bit. :)
13:51:26 <sjanssen> i want to invent white dye
13:51:27 <edwardk> in an orthogonal persistence setting you can get D, but i haven't figured out a good way to do that via haskell
13:51:27 <sehute> dmhouse: what's HOF?
13:51:30 <paj> dmhouse: I thought Lisp had them.  I mean, you can write map in it.
13:51:36 <dmhouse> paj, they do.
13:51:37 <ndm> dmhouse: i would personally still use HO funcs, not macros
13:51:40 <dmhouse> sehute: higher-order function.
13:51:42 <sjanssen> evaluating expressions is ALL haskell does?!
13:51:44 <sehute> dmhouse: ah
13:51:57 <dmhouse> sehute: a function that takes a function as a parameter.
13:52:01 <liyang> edwardk: and for D, sync() <grin>
13:52:02 <sehute> sjanssen: yes, at least according to all tutorials I've read
13:52:08 <edwardk> the c bit comes from the other paper where they added conditions to ensure on stm data
13:52:21 <norpan> dmhouse: ok, i found it in my logs
13:52:21 <xerox> sjanssen: that sounds more like the definition of a Scheme interpreter.
13:52:25 <liyang> edwardk: 'always' or something. :)
13:52:32 <sehute> dmhouse: ah, like map() ?
13:52:41 <dmhouse> sehute: precisely like map.
13:54:05 <kuribas> ndm: It's not there.  I am using debian btw, it normally uses a bit older packages.
13:54:09 <paj> I'm just thinking of Paul Graham's essay "Beating the Averages" at http://www.paulgraham.com/avg.html, or it might have been one of his related ones.
13:54:11 <lambdabot> Title: Beating the Averages
13:54:29 <ndm> kuribas: May 2006 hugs required
13:54:37 <edwardk> liyang: not quite so simple. it could be done by logging transactions out to disk, but if you move to a sasos model or at least something with orthogonal persistence, a weaker form of it comes for free. i have a passing interest in seeing how it could be used to build an oodbms, but databases bore me to tears. =)
13:54:45 <xerox> dmhouse: ...or returns a function as result.
13:54:46 <ndm> the new one has many improvements, i suggest you beat your maintainers :)
13:55:07 <paj> He talked about how most of his program was Lisp macros, and that was why it was so good.  They were using macros to do continuation-based web page serving.  Haskell would do that with a monad, or more recently with arrows.
13:55:12 <dmhouse> xerox: I don't like that definition. Every curried function in more than one parameter fits that.
13:55:24 <liyang> edwardk: it was a flippant answer, I wasn't being serious. :)
13:55:29 <edwardk> heh
13:55:47 <kuribas> ndm: Version: 20050308.  Would it be better to use a freshly compiled Hugs?
13:55:52 <emertens> paj: Lisp does support higher order functions, they just require a little extra sytax
13:56:10 <xerox> dmhouse: there are curried and uncurried functions.
13:56:11 <ndm> kuribas: it would give you Data.ByteString with no extra effort at all, and a few bug fixes
13:56:23 <paj> Yes, thats what I thought.  I think we've got our purposes crossed.
13:56:40 <edwardk> paj: yeah but as i am starting to learn, macro solutions in lisp/scheme tend to run fast. the monad solutions in haskell are not so snappy =/
13:56:51 <edwardk> as much as i dislike paul graham's writing
13:57:04 <ndm> paj: yeah, while i was reading that he says "no one can see the point of any language more powerful than their own" - which explains why he doesn't use haskell
13:57:07 <emertens> and if I remember correctly... the reason that you need the additional syntax is that values and functions in Lisp exist in separate namespaces
13:57:28 <paj> ndm: Absolutley.  I've often wished I could have that conversation with him.
13:57:32 <dmhouse> xerox: yes, I'm saying that saying 'A HOF is a function that returns a function' is too general, because every function that takes more than parameter fits that definition, and I only want to call things like map and filter HOFs.
13:58:03 <ndm> paj: yep, me too! although i don't ever remember him saying haskell was not powerful enough, merely that a lack of macros means its not good enough
13:58:08 <edwardk> how about a function that takes a function as an argument?
13:58:08 <paj> I think of a HOF as a function that acts on functions.  The HO bit is in the arguments, not the results.
13:58:23 <dmhouse> paj: precisely.
13:58:52 <paj> Map takes a function that acts on an element, and returns one that acts on a list.
13:59:02 <xerox> dmhouse: I understand what you mean, but not everybody thinks Haskell, so I like to make it explicit "...which takes or returns one or more functions..."
13:59:46 <ski> what about a function that returns a data-structure containing functions ?
14:00:04 <ndm> ski: thats very rare, but still HO
14:00:13 <xerox> Hmmm.
14:00:17 <ndm> ski: i can't think of a function such as that in the standard libraries
14:00:26 <norpan> do you need to separate higher order functions from other functions?
14:00:49 <roconnor> > replicate 5 id
14:00:50 <lambdabot>  Add a type signature
14:00:55 <xerox> norpan: yes, some languages don't have functions as first-class citizens, hence, no higher-order functions.
14:00:58 <roconnor> > replicate 5 id :: [Int->Int[
14:00:59 <lambdabot>  Parse error
14:01:00 <roconnor> > replicate 5 id :: [Int->Int]
14:01:02 <lambdabot>  [<Int -> Int>,<Int -> Int>,<Int -> Int>,<Int -> Int>,<Int -> Int>]
14:01:07 <norpan> xerox: of course, but i mean in haskell
14:01:16 <ndm> norpan: no
14:01:27 <norpan> some languages have function pointers
14:01:29 <ndm> roconnor: yes, but replicate isn't higher order, becuse its type is polymorphic
14:01:40 <norpan> but not the ability to make arbitrary function closures
14:01:46 <ski> many monads have values containing functions .. but i gues if it's with 'newtype' it probably doesn't count
14:01:57 <edwardk> the main reason i like javascript is that because it has first-class functions and closures (and little else) it has forced a whole generation of programmers to learn how to use them.
14:01:58 <paj> I'd take xerox's defn with one change: "which takes *and* returns one or more functions"
14:01:59 <xerox> return!
14:02:14 <emertens> returning a data structure with existetial types that contains values of those types and functions that act on them to emulate information hiding
14:02:25 <emertens> is not an uncommon example..
14:02:35 <emertens> or at least I've seen it a couple places
14:02:51 <xerox> ?type (return :: a -> Control.Monad.Identity.Identity a)
14:02:52 <lambdabot> forall a. a -> Control.Monad.Identity.Identity a
14:03:04 <ski> paj : fix :: (a -> a) -> a
14:03:16 <xerox> fix is surely an HOF.
14:03:31 <sieni> well, in java you can make a one-method class and let the system garbage collect them. About the same functionality than closures (although too much typing)
14:03:33 <paj> Yes... errr.
14:03:38 <ski> @type ($ 'a')
14:03:38 <emertens> in Haskell... any function with more than 2 arguments is a HOF...
14:03:39 <lambdabot> forall b. (Char -> b) -> b
14:03:48 <emertens> in it's type sig
14:03:51 <roconnor> > fix (1:)
14:03:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:03:56 <ski> @type not . ($ 'a')
14:03:57 <_Codex> id :: (a->b) -> a -> b
14:03:57 <ndm> sieni: but its not a closure, its a simulation
14:03:58 <lambdabot> (Char -> Bool) -> Bool
14:04:06 <_Codex> is id HOF?
14:04:14 <sieni> ndm: what's the difference between a closure and its simulation?
14:04:15 <ndm> sieni: in the same way without HO functions you can always simulate them, its the turing thingy
14:04:27 <ski> _Codex : not really
14:04:28 <ndm> sieni: whats the difference between Haskell and assembly?
14:04:33 <paj> Not necessarily.  Where is the argument function in sum3 a b c = a + b + c?
14:04:41 <ndm> its just a case of how much effort it is
14:04:42 <roconnor> ndm: Types!
14:04:48 <_Codex> ski: but it matches their def of HOF :)
14:05:03 <roconnor> whats the difference between lisp and assembly?
14:05:04 <ski> _Codex : that *specialization* of 'id' is HOF, i'd say
14:05:20 <emertens> sum3::(Num a) => a (a -> (a -> a))
14:05:25 <emertens> errr
14:05:32 <emertens> sum3::(Num a) => a -> (a -> (a -> a))
14:05:36 <Maddas> sieni: How does a one-method class capture its environment?
14:05:37 <ndm> roconnor: not that much, given car/cdr etc, which are assembly code mneumonics
14:05:43 <sieni> but in C or C++ you have to explicitly manage the lifetime of objects, so it's difficult to provide similar functionality
14:05:53 <roconnor> @type Control.Monad.Cont.CallCC
14:05:55 <lambdabot> Not in scope: data constructor `Control.Monad.Cont.CallCC'
14:05:58 <roconnor> @type Control.Monad.Cont.callCC
14:05:59 <ndm> sieni: only if you care about not leaking memory
14:06:00 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => ((a -> m b) -> m a) -> m a
14:06:11 <ndm> sieni: and decide not to use a garbage collector
14:06:11 <shapr> lispy: Just because you and I have such different schedules...
14:06:12 <roconnor> certainly callCC is higher order
14:06:13 <sieni> ndm: computers have finite memories
14:06:14 <paj> emertens: yes it returns functions, but I don't see the argument.  Or am I missing something?
14:06:30 <Maddas> sieni: most programs have finite run-times :-)
14:06:33 <sieni> Maddas: you can do it manually
14:06:37 <emertens> paj: that response was based on the arguemnt that returning a function made it a HOF
14:06:39 <roconnor> @type Control.Monad.Cont.runCont
14:06:41 <lambdabot> forall r a. Control.Monad.Cont.Cont r a -> (a -> r) -> r
14:06:55 <ndm> sieni: i run all my code on a turing machine :)
14:06:56 <emertens> paj: and then I thought you asked me if sum3 was HOF
14:06:58 <Maddas> sieni: Yes, but you can manually emulate closures using C structs, too.
14:07:19 <Maddas> sieni: I'm not saying that one-method Java objects aren't closer to real first-class closures, but they aren't there yet.
14:07:24 <emertens> paj: in response to my suggestion than more than one "->" lead to a "HOF"
14:07:35 <Maddas> (Incidentally, have you ever seen Oleg's C++ implementation of lambda? I found it quite amusing)
14:07:37 <paj> I said it has to *take* and return functions.  But now I'm wondering if it has to return them, with fix and callCC.
14:07:57 <dmhouse> paj, and ($ 5), etc.
14:08:09 <dmhouse> ?type ($ 5)
14:08:11 <lambdabot> forall a b. (Num a) => (a -> b) -> b
14:08:17 <edwardk> i only think take functions, not return
14:08:30 <emertens> seems reasonable at a glance
14:08:40 <kuribas> Doesn't C# have closures?
14:08:55 <emertens> yes it does
14:09:09 <emertens> thanks to it's anonymous delegates
14:09:24 <paj> I can't think of any counterexamples right now.
14:09:55 <paj> Although I wonder about something with the type a -> b -> (a -> b)
14:10:15 <paj> Something like that could be constructed, although I can't imagine why.
14:10:23 <emertens> paj: a -> b -> a -> b === a -> b -> (a -> b)
14:10:26 <ndm> paj: == a -> b -> a -> b
14:10:30 <norpan> .
14:10:33 <paj> ?hoogle a -> b -> (a -> b)
14:10:34 <lambdabot> No matches, try a more general search
14:10:42 <ndm> paj: hoogle just doesn't know it :)
14:10:48 <dmhouse> How about id?
14:10:58 <sjanssen> @djinn a -> b -> (a -> b)
14:10:58 <lambdabot> f _ a _ = a
14:11:19 <sjanssen> @pl f x y z = y
14:11:19 <lambdabot> f = const const
14:11:21 <paj> OK.  I think I'm persuaded.  HOFs take one or more functions as arguments.
14:12:13 <xerox> ?type (id :: (a -> b) -> (a -> b))
14:12:15 <lambdabot> forall a b. (a -> b) -> a -> b
14:12:37 <roconnor> @type Control.Monad.State.get
14:12:38 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
14:12:48 <roconnor> @type Control.Monad.State.modify
14:12:50 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
14:12:52 <lispy> paj: or they could take no functions and return a function
14:13:10 <roconnor> well the usual implementation of Control.Monad.State.modify returns a function.
14:13:16 <paj> That's just a function.
14:13:49 <paj> foo :: a -> (b -> c) === foo :: a -> b -> c
14:15:38 <paj> Anyone here live in the M3 or M27 area in the UK?
14:17:01 <lispy> > let foo x = \y -> y * x + y in foo
14:17:02 <lambdabot>  Add a type signature
14:18:38 <roconnor> what's wrong with modify?
14:18:46 <roconnor> what are we trying to do?
14:18:50 <monochrom> modify is very nice to use.
14:18:51 <roconnor> :)
14:19:32 <paj> Bye all.
14:19:36 <monochrom> Suppose the state "s" is Int.  modify (+ 1)   this will increment the stored number.
14:20:09 <roconnor> monochrom: I like modify succ
14:20:15 <monochrom> Contrast this with manually writing a get/set pair.  get >>= \x -> set (x+1)
14:20:25 <monochrom> succ is even better :)
14:21:46 <roconnor> monochrom: what were we trying to do?
14:23:04 <monochrom> I don't know. I butt in.
14:23:57 <roconnor> :)
14:26:45 <monochrom> Can I do this?  In Linux, I write a haskell program with main, call it x.hs (or whatever works), the first line being whatever works, mark the file as executable (chmod 755), then at a shell prompt I type "x.hs" and it effectively does "runghc x.hs"?
14:27:20 <shapr> Why not just have the top line be #!/bin/env runghc ?
14:27:22 * shapr tries
14:27:24 <roconnor> monochrom: you can make an .lhs file and begin with #! /usr/bin/runhaskell or whatever
14:27:49 <monochrom> Oh! lhs!  Almost forgot that trick! :)
14:28:24 <dmhouse> But then you get the yukkiness of it being a .lhs file.
14:28:39 <shapr> I like .lhs files.
14:28:43 <roconnor> what's so yucky about .lhs?
14:28:47 <dmhouse> I suppose just one \begin{code} and one final \end{code} isn't too bad.
14:28:49 <monochrom> I don't mind the filename.
14:28:54 * lispy can't stand bird style lhs
14:29:15 <shapr> I like LaTeX lhs
14:29:37 <lispy> i like haddock
14:29:38 <roconnor> lispy do you not like quoted email either?
14:29:50 <dmhouse> I find the \begin{code} and \end{code} statements cluttery, and I think with Haddock there's no need.
14:30:08 <lispy> two reasons i dislike bird-style 1) it's annoying to type 2) it is confusing when it shows up in emails
14:30:17 <dmhouse> Unless your document is serving a dual purpose, like being an email to a mailing list. In which case, Bird-style is better.
14:30:24 <dmhouse> lispy: 1: use Emacs :)
14:30:30 <lispy> dmhouse: i do
14:30:33 <roconnor> um, haskell 2-d layout is anoying to type without editor support.
14:30:38 <lispy> i've never had emacs help out with bird style
14:30:44 <dmhouse> I'm sure it can be done.
14:31:00 <edwinb> I get by with bird style in emacs... it's not perfect though.
14:31:13 <edwinb> I mainly use it to remind myself to write comments more often
14:31:14 <lispy> -- is really easy to type and {- -} isn't bad either
14:31:30 <dmhouse> lispy: or just type everything, then do M-< C-SPC M-> C-a C-x r t > SPC RET
14:32:02 <dmhouse> I.e. put the mark at the beginning of the first line, then the point at the beginning of the last, then do a C-x r t, and give it '> '.
14:33:16 <Philippa> roconnor: how much editor support do you want?
14:33:36 <lispy> dmhouse: what do you mean with haddock there is no need?
14:33:44 <Philippa> I mean, it might be a bit tedious in Notepad, but any editor that'll match the previous line's indentation unless told otherwise works for me
14:33:45 <roconnor> Philippa: intent to the last level of indent.
14:34:07 <dmhouse> lispy: I find Haddock comments sufficient to annotate a document.
14:34:08 <Philippa> and that's pretty much any editor I've used that wasn't notepad or edlin
14:34:42 <lispy> dmhouse: yeah, i find haddock produced documentation very handy to have
14:35:01 <roconnor> Philippa: actually I WANT my editor to tell me the types of functions I am using / writing, etc.
14:35:16 <dmhouse> roconnor: Emacs does that.
14:35:26 <roconnor> yes
14:35:35 <dmhouse> Well, not 'writing'. But it recognises Prelude functions in your source.
14:35:44 <lispy> visual haskell has some support for that too (but visual studio costs money and emacs is better overall)
14:35:52 <dmhouse> Even in comments and string literals, which is amusing if you're using words like 'not' or 'and'. :)
14:36:38 <lispy> this is odd
14:37:00 <lispy> darwinports says that ghc 6.4.2 is available but ghc --version says i have 6.4
14:37:31 <lispy> darwinports doesn't want to let me upgrade though
14:40:44 <shapr> I wish Yi did that.
14:41:03 <shapr> alas alack, I have not the focus to make it do such a thing.
14:41:03 * dcoutts curses windows
14:41:16 <lispy> shapr: have you seen the yi + wx?
14:41:19 <shapr> no?
14:41:22 <shapr> Er, maybee
14:41:36 <lispy> shapr: i guess foxy hacked it together with tabs and some syntax highlighting on haskell code
14:41:37 <dcoutts> yi+wx ? I've seen yi+gtk
14:41:45 <shapr> Yeah, I've only seen yi+gtk
14:41:46 <dcoutts> yes that was yigtk
14:42:03 <dcoutts> I've got it working here now
14:42:09 <lispy> dcoutts: i'm pretty sure it was wx, dons was showing it off last night
14:42:13 <shapr> Is there a deb?
14:42:24 <dcoutts> well the one foxy_ was working on is gtk
14:42:31 <lispy> oh okay
14:42:31 <dcoutts> unless he's working on two :-)
14:44:10 <dcoutts> foxy_, ping
14:44:32 <ndm> dcoutts, none of your insults at windows!
14:44:47 <dcoutts> ndm, sorry, I've been reading MSDN :-)
14:44:55 <ndm> lispy, definately GTK, it had the gtk logo in the corner
14:45:07 <dcoutts> it's full of information that doesn't answer one's questions :-)
14:45:16 <lispy> ndm: i don't think i'll finish my half-assed attempt at windows dialogs...although i have enough boiler plate to get you bootstraped if you want me to send it your way
14:45:17 <ndm> dcoutts, i know, i've spent ages on it
14:45:36 <ndm> lispy: for what?
14:45:40 <ndm> Win32 library?
14:45:43 <lispy> yeah
14:45:50 <lispy> oh, it was eivuokko that wal helping me
14:45:54 <ndm> probably best to sent it elsewhere first
14:45:56 <dcoutts> ndm, I was tring to find out if assemblies can be used by non-.net apps/libs
14:46:02 <ndm> dcoutts, as far as i know, no
14:46:19 <ndm> since it using the global assembly cache, which is a .NET managed thing
14:46:25 <dcoutts> right
14:46:34 <dcoutts> so you might need .net installed
14:46:37 <ndm> and no one is answreing on how i send ctrl-c at a console :(
14:46:44 <ndm> dcoutts, which is a far worse dependancy than gtk
14:46:48 <dcoutts> heh
14:46:58 <lispy> ndm: that's because you're crazy ;)
14:47:10 <ndm> and even then, the assembly cache is for the JIT'd version of .NET code, so may not apply to native anyway
14:47:14 <dcoutts> how do you do it with the win32 api, that might tell us how to do it in haskell
14:47:41 <dcoutts> ndm, yeah that's what it looks like at first, but then apparently the latest version of the C lib is an assembly
14:47:43 <ndm> GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, (DWORD) hProcessId);
14:47:56 <ndm> lispy: thats the nicest thing anyones said to me today :)
14:48:12 <lispy> ndm: :)
14:48:34 <ndm> and the purpose is to rewrite C code to Haskell, which is good for the soul
14:48:43 <lispy> indeed
14:48:48 <dcoutts> ndm, and that's the only way? or can one send an escape code down the pipe or something perhaps (possibly via the ms c lib rather than win32)
14:49:03 <lispy> so if you know the api function, can't you just use hsc2hs to create an ffi wrapper and call it from haskell?
14:49:09 <dcoutts> ndm, otherwise, consider extending the win32 package to cover that function
14:49:15 <ndm> dcoutts, escape codes don't go that way, i don't think
14:49:30 <ndm> lispy, you're teh win32 package person :)
14:49:44 <lispy> ;)
14:50:00 <lispy> actually, eivuokko is the person, but i can get you a link to the darcs source if you want to hacke it
14:50:13 <ndm> i don't want to hack it, but i do want that function
14:51:10 <ndm> hmm, its a shame if i have to hack at my beautiful code and shove that in
14:51:29 <ndm> plus its a pain to learn who knows what ffi stuff etc, process casting etc, just for one function...
14:51:41 <ndm> but sending ctrl+c is absolutely essential for GuiHaskell
14:51:43 <lispy> yeah
14:52:02 <lispy> otoh, i bet it would take 3 minutes for someone with Win32 knowledge to add it
14:52:08 <ndm> indeed :)
14:52:10 <lispy> do you have the msdn link for that function?
14:52:21 <ndm> lispy: http://windowssdk.msdn.microsoft.com/en-us/library/ms683155.aspx
14:52:59 <ndm> although maybe it should get added to System.Posix.Signals
14:53:05 <ndm> since its the same functionality
14:53:15 <ndm> and having OS specific stuff in the standard libs is just plain wrong
14:53:34 <dcoutts> hmm
14:53:56 <ndm> not that i have the knowledge to add it there, either, sadly
14:53:56 <liyang> Does anyone remember / can point me towards any references to the Church of the Least Fixpoint?
14:54:26 <liyang> (or something like that. A bit off-topic.)
14:54:30 <ndm> http://www.google.com/url?sa=t&ct=res&cd=2&url=http%3A%2F%2Fwww.springerlink.com%2Findex%2FN4T2V573M58G2755.pdf&ei=dyrNROr2G660RZDOyZsG&sig2=g8aSbPCmwTjmK6D_DNen7A
14:54:34 <lambdabot> Title: SpringerLink - Article
14:54:39 <lispy> ndm: the next time i'm at work i'll look at whipping up a wrapper for that function
14:54:54 <ndm> lispy: would be most appreciated
14:55:06 <ndm> so is there any chance of it ending up in System.Posix?
14:55:16 <ndm> it probably wants to go in the win32 package
14:55:31 <lispy> ndm: would it be okay if i send the patch to you, then when you say it works or not i can forward it to eivuokko
14:55:37 <ndm> and then be called by System.Posix, with the arguments frozen appropriately?
14:55:50 <lispy> i'd say it belongs in System.Win32 which is the Win32 package
14:56:03 <lispy> but i'm far from export
14:56:03 <ndm> lispy: yeah, i guess - havne't build win32 before, is it just a case of cabal etc.
14:56:06 <lispy> er expert
14:56:26 <ndm> given that it provides the same functionality as System.Posix.Signals, its a shame if they don't have a same name
14:56:27 <lispy> ndm: yeah, i think it was pretty easy if you have hsc2hs and iirc that's part of ghc
14:56:40 <ndm> lispy: cool, have all of that
14:56:49 <ndm> yes, send me a patch if you can
14:56:56 <dcoutts> ndm, it's not clear from those docs that the function does what you want
14:57:00 <ndm> ndmitchell -AT-    gmail -dot- com
14:57:01 <lispy> okay, i'll put this down on my todo list
14:57:10 <ndm> dcoutts, i know, but it doesn, i've used it in WinHaskell
14:57:19 <ndm> and it took forever to find, esp with docs which are that helpful :)
14:57:21 <dcoutts> oh, ok then
14:57:34 <lispy> ndm: cool, i think youu're on my google chat list already
14:57:46 <ndm> lispy, yep
15:01:00 <liyang> ndm: ah, cheers.
15:11:14 <eivuokko> ndm, Win32 (from darcs) should build easily enough with Cabal.  And what's it needed to be added there?
15:16:27 <lispy> eivuokko: this function http://windowssdk.msdn.microsoft.com/en-us/library/ms683155.aspx
15:16:38 <lispy> eivuokko: i bet it would take you < 3 min to add it
15:17:11 <lispy> i'd do it right now but i don't want to talk to work where i have a windows dev box setup
15:17:14 <eivuokko> Looks like one enum and one ffi import and one wrapper fun.
15:17:40 <eivuokko> And I think there was a module where it goes naturally as well...
15:17:52 <eivuokko> But testing it...eh, fun :)
15:17:59 <lispy> let ndm test it :)
15:18:49 <eivuokko> I think it might be very suprising function to use, tho.
15:19:07 <lispy> how so?
15:19:15 <lispy> you don't think it will behave as we expect?
15:19:16 <eivuokko> Docs are a bit vague how it works on processes that don't have console.
15:19:21 <lispy> yeah
15:19:28 <lispy> msdn is so bod
15:19:30 <lispy> er bad
15:19:54 <eivuokko> bad?  heh, beats most of the docs for libs/OS I've seen
15:20:12 <eivuokko> In absolute sense, yeah, bad.  In relative sense, pretty good imo :)
15:21:51 <lispy> i perfer man on linux :)
15:22:00 <eivuokko> You're not serious, are you?
15:22:02 <emertens> i prefer man on OpenBSD
15:22:06 <emertens> to man on linux :)
15:22:21 <eivuokko> Ah, well.  Each to his own.
15:22:21 <lispy> i do actually like man
15:22:26 <lispy> on debian it's nice
15:22:45 <eivuokko> Ehm, I don't have anything against man.  I have something against the typical docs written for in it.
15:22:50 <eivuokko> *shown with it
15:53:50 <eivuokko> ndm, lispy, There is a darcs repo at http://tamelambda.net/darcs/Win32/ with a patch that addres generateConsoleCtrlEvent + constants to System.Win32.Console (and re-exported by System.Win32).  Totally untested for now.  I'm off, good night.
15:53:52 <lambdabot> Title: Index of /darcs/Win32
15:54:03 <sehute> Wish there was a documentation-system that could replace man, info, --help and /usr/shared/doc with something better and unified
15:54:17 <sehute> and quicker, smaller and more good-looking
15:57:19 <lispy> eivuokko: thanks!
15:57:39 <lispy> google? ;)
15:58:08 <sehute> ;)
15:59:32 <sehute> good night
16:04:11 <ndm> eivuokko: thanks a lot
16:05:15 <LordBrain> What does T stand for in StateT ?
16:05:32 <lispy> transformer
16:05:36 <LordBrain> ah
16:05:58 <lispy> so it's like, State<More than meets the eyes>
16:06:01 <lispy> ;)
16:06:07 <LordBrain> lol
16:16:34 <ndm> lispy, eivuokko: how do i convert my lovely ProcessHandle to a DWORD for the Win32 API?
16:17:20 <ndm> @where fp
16:17:21 <lambdabot> I know nothing about fp.
16:17:22 <ndm> @where fps
16:17:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
16:19:03 <ndm> @tell dons please tag FPS, I'm getting 394 patches while my housemate is on  bittorrent...
16:19:04 <lambdabot> Consider it noted.
16:19:52 <musasabi> ndm: unsafeCoerce# (evil)
16:20:03 <musasabi> have to test whether it works too.
16:20:15 <ndm> musasabi: just unsafeCoerce# on the ProcessHandle?
16:20:30 <ndm> am just getting FPS so I can build it, in order to test it
16:21:26 <musasabi> ndm: depends how they are implemented but trying whether that works is a quick and dirty solution.
16:21:39 <ndm> musasabi: cool, will do
16:22:59 <ndm> musasabi: i suspect it won't - i have a processhandle, and i need a processid
16:24:56 <ndm> musasabi: i will probably need http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getprocessid.asp as well, to get a processid
16:24:58 <ndm> but will try unsafeCoerce first
16:26:28 <ndm> musasabi: I get: Could not find module `Data.ByteString.Base':
16:27:52 <ndm> musasabi: but by adding fps to the list of cabal build dependancies it works - i guess hte next GHC will have that in base, so no real need
16:28:05 <musasabi> yes next GHC has fps.
16:28:53 <mathewm> can anyone point me to a fast heap or priority queue for haskell?
16:28:55 <int-e> we'll be so happy :)
16:29:25 <ndm> mathewm: Sequence does both, i think
16:29:29 <ndm> Data.Sequence
16:29:40 <ndm> @docs Data.Sequence
16:29:40 <lambdabot> Data.Sequence not available
16:29:47 <ndm> hmm, maybe a GHC 6.6 thing
16:29:53 <ndm> @google Data.Sequence haskell
16:29:56 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html
16:30:02 <mathewm> sweet
16:30:41 <ndm> not entirely surprising, Ross's data structure got into Hugs before GHC :)
16:32:18 <emertens> @index liftIO
16:32:18 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:37:47 <ndm> @hoogle unsafeCoerce
16:37:48 <lambdabot> No matches found
16:39:28 <ndm> @index unsafeCoerce#
16:39:29 <lambdabot> bzzt
16:40:15 <ndm> where is unsafeCoerce?
16:41:03 <ndm> @index unsafeCoerce#
16:41:03 <lambdabot> bzzt
16:41:20 <musasabi> GHC.Base. it converts if they are really equal on the bit level - otherwise you will get garbage with no error.
16:43:44 <ndm> GHC.Exts seems to supply it
16:43:51 <LordBrain> i did some searching and found some
16:45:03 <LordBrain> priority queue code
16:47:08 <ndm> musasabi: guihaskell.exe: user error (generateConsoleCtrlEvent: The parameter is incorrect.  (error code: 57))
16:54:13 <musasabi> ndm: ok. then you probably need a real function to get the right type.
16:54:28 <ndm> musasabi: have added it to Win32, just compiling to test it
16:55:28 <ndm> musasabi: unfortunately i get a linker error with C:\Program Files\Haskell\Win32-1.0\ghc-6.4.2/libHSWin32-1.0.a(Process.o)(.text+0
16:55:29 <ndm> x174):ghc2792.hc: undefined reference to `GetProcessId'
16:56:36 <musasabi> ndm: eivuokko might know the answers.
16:56:53 <musasabi> although it is 3AM in Finland so he might be sleeping.
16:57:18 <ndm> I just added:
16:57:19 <ndm> foreign import stdcall unsafe "windows.h GetProcessId"
16:57:21 <ndm>   getProcessId :: HANDLE -> IO DWORD
16:57:49 <ndm> and exported getProcessId
17:42:44 <dcoutts> @seen foxy_
17:42:45 <lambdabot> foxy_ is in #haskell. I last heard foxy_ speak 17 hours, 3 minutes and 38 seconds ago.
19:13:45 <RyanT5000> i'm still at a loss as to how to design this datastructure
19:13:58 <RyanT5000> or rather, how to make it maintainable
19:14:38 <RyanT5000> the basic structure is a Map Int (Array (Int, Int) ModelID)
19:15:13 <RyanT5000> i.e.: a map from board ID to boards, where each board is an array of squares, each with a model on it
19:15:20 <dons> good morning lambda hackers!
19:15:21 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:15:44 <dons> RyanT5000: use an IntMap (Array (Int, Int) ModelID) -- faster
19:16:02 <RyanT5000> alright, that sounds reasonable, but my main concern is this
19:16:08 <RyanT5000> they both need to be indexed
19:16:24 <RyanT5000> and obviously indices need to be fixed whenever a piece is moved
19:17:04 <RyanT5000> so you can lookup board by boardID and boardID by modelID in a world (which is what i call the containing map)
19:17:23 <RyanT5000> and you can lookup coordinate by modelID in each board
19:18:03 <RyanT5000> is there any reasonable way to make it so that things that don't understand boards can modify boards in worlds?
19:18:42 <SamB> combinator library?
19:19:13 <RyanT5000> that sounds appealing, but i don't really understand that stuff enough as-is
19:19:21 <dons> yes. a set of accessor functions would be a good idea
19:20:27 <RyanT5000> you mean accessors in world for board?
19:20:56 <RyanT5000> i'm pretty sure this kind of stuff applies to nested containers of all kinds
19:21:06 <RyanT5000> it's easy if you don't have to modify them
19:21:18 <RyanT5000> but as soon as you need to make deeply indexed containers, you have an issue
19:21:25 <lispy> RyanT5000: can be you more concrete?  I don't think i get it
19:21:57 <RyanT5000> ok, well let's say we define a class BiMap m a b
19:23:14 <RyanT5000> well, i was writing out function definitions but i think they'll probably just confuse the issue
19:23:23 <RyanT5000> basically it's a map that goes both ways, and keeps in sync
19:23:38 <RyanT5000> so it essentially represents an enumerated reversible function
19:23:45 * lispy nods
19:24:30 <RyanT5000> so now let's say you have a map m :: (BiMap outer a inner, BiMap inner b c)
19:24:50 <RyanT5000> => outer
19:25:05 <dcoutts> morning dons
19:25:46 <RyanT5000> so now you have some function updateInner :: (BiMap m a b) => Stuff -> m -> m
19:26:11 <RyanT5000> oh huh this one doesn't exhibit the problem at all, lol
19:26:23 <RyanT5000> because it's not deeply indexed
19:26:34 <lispy> RyanT5000: heh, i'm lost :)
19:26:42 <RyanT5000> sorry, forget all the stuff i just said in this example
19:27:10 <RyanT5000> let's say you have a map from a's to b's
19:27:24 <RyanT5000> and a map c (map a b)
19:27:42 <RyanT5000> that's the primary function of each of those datastructures
19:27:51 <RyanT5000> but they also have indexes
19:28:13 <RyanT5000> the map a b has an index that functions like a map b (Set a)
19:28:41 <emertens> Is there a good algorithm for maintaining a balanced max heap that I'm not thinking out?
19:29:03 <RyanT5000> the outer map has an index like map b (Set c)
19:32:01 <RyanT5000> unrelated question
19:32:09 <RyanT5000> well, not obviously related anyway
19:32:20 <lispy> > 1 `seq` 2 `seq` 3
19:32:21 <lambdabot>  3
19:32:36 <dons> test (http://haskell.org)
19:32:38 <lambdabot> Title: Haskell - HaskellWiki
19:32:38 <RyanT5000> is there a way to specify that a function within a particular class will return something that is of a particular class?
19:32:57 <RyanT5000> e.g.: like v :: Eq a => a
19:33:11 <lispy> so, join seq = \x -> seq x x, does that mean join seq = id?
19:33:17 <RyanT5000> except that, for any particular instance of the class, v has a particular type (which provides Eq)
19:33:39 <lispy> RyanT5000: i'm not sure but that sounds kinda like GADTs
19:34:13 <RyanT5000> lol damn it, i just want to write a stupid board game; why am i getting so deep into programming language theory?
19:34:25 * lispy shrugs
19:34:28 <RyanT5000> lol
19:34:33 <RyanT5000> ah well i think it's my nature
19:34:38 <lispy> because PL theory is fun too :)
19:34:44 <RyanT5000> yeah
19:35:18 <lispy> i think i'm going to go learn s'more curses...
19:35:22 <lispy> ncurses that is
19:35:58 <dons> lispy: go nuts!
19:36:11 <dons> steal hmp3 and tear it to pieces
19:36:17 <SamB> hehe
19:36:33 <dons> I leave it outside at night, unlocked..
19:36:45 <SamB> dons: but immutable
19:37:13 <dons> well true, unless you're a super evil villain
19:37:24 <dons> @spell villain
19:37:25 <lambdabot> villain
19:37:42 <lispy> dons: heh, i've been leaning towards the Stefan version
19:37:46 <RyanT5000> alright i have a proposition for a language feature; i think it's workable from a theoretical standpoint, although i have no idea how difficult implementation would be
19:37:52 <dons> lispy: ok. that's good too :)
19:37:56 <dons> oh, morning dcoutts
19:38:06 <RyanT5000> default T v where { }
19:38:08 <SamB> lispy: dons has some things built on top of it that might be of interest, though
19:38:16 <RyanT5000> default would be a keyword
19:38:20 <dons> dcoutts: "<ndm> @tell dons please tag FPS, I'm getting 394 patches while my housemate is on  bittorrent"
19:38:21 <RyanT5000> T is a type that is in-scope
19:38:23 <lispy> some of the functions take a Word32 of flags, shouldn't the haskell analog be to give them a list of enums?
19:38:23 <RyanT5000> v is a value of type T
19:38:40 <lispy> SamB: such as?
19:39:02 <SamB> lispy: I don't remember/understand them enough to elaborate
19:39:03 <lispy> SamB: i was going to pretend to make an angband clone as a pet project...so i tihnk i'll need to do my own "widgets" for this guy
19:39:06 <dons> lispy: hmm. you could definitely write some nice candy sugar on top of all the existing curses libs..
19:39:16 <RyanT5000> the where clause creates a new scope; within that scope the type T does not exist; any functions imported into that scope which take a T as an argument have v supplied as that argument
19:39:21 <SamB> except that they look suspiciously like document combinators
19:39:28 <dons> whoa: copyFile: hardware fault
19:39:36 <dons> never seen that one.
19:39:46 <lispy> creepy
19:39:53 <RyanT5000> anyone read my idea?
19:40:08 <lispy> RyanT5000: you're over my head...i don't feel like i can help :(
19:40:23 <RyanT5000> i'm talking about the default idea now
19:40:25 <RyanT5000> not the other stuff
19:40:29 <LordBrain> @index Doc
19:40:29 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
19:40:30 <RyanT5000> :P
19:41:23 <lispy> dons: oh, i bet the CursesHelper module has a bunch of functions that behave like i would expect in haskell
19:42:04 <lispy> convertAttributes :: [Attribute] -> Attr
19:42:26 <SamB> what recreation shall I engage in... considering that I do not feal like doing much of anything?
19:42:58 <dons> SamB, do you feel up to writing a new plugin for the bot? i have a quest, should you accept my challenge...
19:42:58 * SamB wishes he had anime to watch
19:43:13 <SamB> hmm.
19:43:45 <SamB> I don't think I have that compiled, and I really don't think it will help my ./adventure session continue...
19:44:00 <dons> heh
19:44:41 <lispy> dons: what did you have in mind?
19:44:52 <SamB> someone needs to punish those CMU people for this abuse of my RAM
19:45:00 <SamB> (it was CMU, wasn't it?)
19:45:59 <dons> lispy, its the new idea for an @strictness <foo> plugin
19:46:18 <SamB> ouchies
19:46:23 <dons> that uses a database of strictness info extracted from the library .hi files, to return strictness infromation about idents
19:46:26 <dons> i.e.
19:46:30 <SamB> a database?
19:46:37 <lispy> dons: neat
19:46:55 * SamB would have thought the actual .hi files would be more appropriate...
19:47:12 <dons> filter :: (a -> GHC.Base.Bool) -> [a] -> [a]
19:47:18 <dons>   {- Arity: 2 HasNoCafRefs Strictness: LS -}
19:47:36 <dons> SamB, well possibly. though not having to decode the .hi file all the time seems useful..
19:47:56 <dons> so @strictness filter --> something like the above about L and S
19:48:41 <dons> or say,
19:48:42 <dons> foldl :: (a -> b -> a) -> a -> [b] -> a
19:48:42 <dons>   {- Arity: 3 HasNoCafRefs Strictness: LLS
19:49:00 <dons> now, you can get all the strictness info with --show-iface
19:49:14 <dons> then munge that somehow into a Map ByteString Info
19:49:15 <SamB>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
19:49:15 <SamB> 15410 naesten   22   5  237m 132m 1340 D  1.6 52.7   3:42.07 um
19:49:16 <dons> and you're done
19:49:23 <dons> heh
19:49:31 <SamB> too much RAM it uses
19:49:50 <SamB> if it had a swap% column, it would say 100
19:52:24 <SamB> so, yeah, the UM running ./adventure is using more RAM than Firefox is...
19:52:40 <SamB> granted I did just restart firefox recently...
19:54:31 <foxy_> dcoutts, pong
20:10:30 <RyanT5000> question: why do modules include their name at the top? especially, why is it an absolute name?
20:10:43 <RyanT5000> it seems to me rather counterintuitive that a module should know its own place in the hierarchy
20:11:22 <RyanT5000> hm, i guess not doing it that way would cause issues with finding things like Data.Map
20:13:16 <sieni> RyanT5000: you can import them with any name as you wish?
20:13:33 <RyanT5000> no, import would be based on filename and filesystem path, as it already is
20:13:38 <dons> so RyanT5000, you want to write 'module M where'
20:13:39 <sieni> like "import qualified Foo as Bar"
20:13:50 <dons> and have the name worked out from the path?
20:13:56 <RyanT5000> right
20:14:03 <dons> so if M.hs is in Data/ then it becomes an import Data.M
20:14:08 <RyanT5000> right
20:14:15 <RyanT5000> eliminate the redundancy
20:14:17 <dons> perhaps tying the naming to the filesystem isn't so good, though?
20:14:33 <RyanT5000> true, but couldn't that be platform-dependent?
20:14:39 <dons> since some compilers allow you to have Foo.M not in Foo/M.hs
20:15:08 <dons> i suspect this has been discussed when formulating the new hier lib standard
20:15:09 <RyanT5000> yeah, well why not just make that a parameter when compiling the module or something?
20:15:15 <dons> perhaps check that for the discussion?
20:15:30 <RyanT5000> yah if i get some time i will
20:15:31 <dons> my thought is that it is for efficiency, and clarity, to fully name everything
20:15:46 <RyanT5000> yeah, but it concerns me because of libraries
20:15:55 <dons> how so?
20:15:56 <RyanT5000> if a library writer puts his stuff in the wrong place, you have no recourse
20:16:03 <dons> remember, we have this extra concept of packages.
20:16:07 <dons> 'the wrong place'?
20:16:21 <dons> so not in Foo/ ?
20:16:22 <RyanT5000> well let's say two library writers, unbeknownst to each other, write the same module
20:16:52 <lispy> src/Main.hs:1:0:
20:16:52 <lispy>     Failed to load interface for `Prelude':
20:16:52 <lispy>         Could not find module `Prelude':
20:16:53 <lispy>           it is a member of package base-1.0, which is hidden
20:16:53 <dons> ah, but they're in different packages. ghc, at least, can distinguish modules with the same name based on packages
20:16:54 <RyanT5000> or rather, two modules with the same name
20:16:59 <lispy> that seems like a really weird error to me
20:17:14 <dons> lispy: your base is hidden!
20:17:14 <RyanT5000> dons: even if you are compiling with both packages?
20:17:27 <dons> compiling both, what, simultaneously?
20:17:27 <lispy> dons: i wonder why
20:17:42 <dons> you have to compile one first. we don't have mutually recursive packages ;)
20:17:50 <RyanT5000> no, i mean you're linking one executable to both libraries
20:17:54 <RyanT5000> and they both define module A
20:18:00 <RyanT5000> how do you import the one you want?
20:18:03 <dons> anyway, this package thing means: a module name is really: package-name:A/B/C
20:18:17 <RyanT5000> right
20:18:20 <dons> so you can even use differnet versions of the same package in the same app now
20:18:29 <lispy> dons: actually it's not hidden and i'm getting that
20:18:32 <dons> how this will appear to the user i'm not sure yet
20:18:34 <lispy> and a reran configure just in case
20:18:41 <SamB> dons: ooooooh, nice!
20:18:43 <RyanT5000> can you actually do that?
20:18:50 <RyanT5000> like import base:Data.Map?
20:18:55 <dons> RyanT5000: no.
20:19:07 <dons> I suspect it will be in the command line flags, not new syntax ..
20:19:13 <RyanT5000> hm
20:19:23 <dons> this code is just written in ghc, to support package-qualified module names
20:19:31 <SamB> they should add a pragma too!
20:19:32 <dons> as i said, i'm not sure how this will then be exposed to the user
20:19:32 <RyanT5000> ah ok
20:19:43 <dons> int-e, around?
20:19:51 <dons> I think int-e has played with the code, maybe he knows
20:19:52 <RyanT5000> i think haskell's module system needs an overhaul
20:20:03 <dons> anyway, this new system should solve several problems
20:20:12 <RyanT5000> make it more of a metaprogramming language
20:20:12 <dons> one, for exampe, is fps living in an external package, and in base
20:20:13 <SamB> RyanT5000: not as much as CL's does
20:20:15 <dons> won't be an issue anymore
20:21:20 <RyanT5000> does it seem sensible to people to have a class MyContainerR as welll as a class MyContainerW, to split up read and write functionality?
20:21:39 <RyanT5000> (it's not mutable, i was just thinking of putting the update functions separate)
20:21:44 <dons> possibly, if you want to statically disallow some code from being able to write or read)
20:22:11 <RyanT5000> i think i want to do that
20:22:17 <RyanT5000> at least disallow writing
20:22:21 <SamB> or if some containers are not really writable
20:22:27 <RyanT5000> i'm not sure i have a use-case for disallowing reading
20:22:32 <RyanT5000> but it's no harder to split it up that way
20:22:34 <dons> so think about what you're trying to do. do you want to statically verify that some code can't write? if so, then yes, you need that info in the type system.
20:22:43 <RyanT5000> alright
20:22:57 <SamB> or if some data structures can't be written in...
20:23:22 <int-e> hmm. I haven't played with that enough. I think the -package flags are meant to provide the package names used.
20:24:37 <lisppaste2> lispy pasted "really stumped by this cabal error" at http://paste.lisp.org/display/23407
20:25:00 <foxy> does anyone have a binding to Matlab data file formats (.mat) ?
20:26:14 <RyanT5000> foxy: if you only have arrays in them, writing a parser is pretty easy; otherwise, no
20:26:14 <int-e> lispy: I know that effect but it's gone in ghc head (as far as I know). Somehow -hide-all-packages managed to irrecoverably hide the base package in ghc - a later -package base wouldn't bring it back into scope.
20:26:39 <lispy> int-e: hmm
20:26:42 <int-e> lispy: I don't know the effect for ghc 6.4 though
20:26:50 <lispy> i'm using debian, where can i get a recent ghc prebuilt?
20:27:10 <lispy> 6.4.1 is the latest that i can find in apt
20:27:25 <zarvok> I'm getting 6.4.2 from apt
20:27:35 <zarvok> ah, wait
20:27:36 <zarvok> heh, no I'm not
20:27:37 <zarvok> oops
20:27:47 <int-e> lispy: ignore the ghc head comment then.
20:27:58 <dons> hey zarvok
20:28:04 <zarvok> hey dons
20:29:08 <lispy> i'll upgrade apt and add unstable back to my sources and try again
20:29:22 <lispy> i used to have unstable in there but i started getting out of memory crap from apt :(
20:29:32 <RyanT5000> heh i've come up with 4 different "permissions" for my datatype, all of which i think are necessary: Construct, Destruct (turn into well-known datastructures, e.g. Data.Map.Map, arrays, etc.), Read, and Write
20:29:51 <RyanT5000> i can't tell whether this feels clean or dirty
20:30:01 <lispy> sounds like OO
20:30:05 <dons> why not get something working, then see what you need :)
20:30:15 <int-e> lispy: oh, try adding base to the build-depends line
20:30:19 <RyanT5000> dons: good point
20:30:23 <lispy> int-e: ah
20:30:39 <RyanT5000> i wish i had been programming in haskell for 7 years rather than C++
20:30:48 <zarvok> lispy: I just checked, unstable only has 6.4.2, if you need 6.5 you'll have to compile from source
20:30:57 <lispy> int-e: yes, that's it
20:31:04 <int-e> lispy: nice.
20:31:05 <RyanT5000> otoh i'd probably be just as pissed off at haskell now as I am at C++
20:31:17 <sieni> RyanT5000: no you don't. you'll just understand it later
20:31:25 <lispy> int-e: perhaps cabal could issue a warning (or recommendation when base is missing...)
20:31:33 <dons> ?remember RyanT5000 i wish i had been programming in haskell for 7 years rather than C++
20:31:34 <lambdabot> Done.
20:31:40 <RyanT5000> lol
20:31:51 <dons> i've been programming haskell for 7 years :)
20:31:57 <SamB> oh no wonder this thing runs so slow -- apparantly it is being interpreted?
20:32:07 <dons> and i LOVE it :)
20:32:19 <RyanT5000> i guess what i'm trying to say is that i wish i was proficient at haskell, and had an understanding of haskell roughly the same as i do now of C++
20:32:29 <sieni> dons, how old are you? :-)
20:32:36 <dons> 25
20:33:02 <dons> so i was kind of lucky to get haskell on my first day of university :)
20:33:15 <lispy> yeah, i got C
20:33:32 <sieni> maybe I should start to hack as intensively as I juggle, so I could catch up with you boys. :-)
20:33:32 <rob-d> are there any gtk2hs experts on?  specifically regarding setting the vertical height of a tree view widget?
20:33:36 * lispy growls at out of memory bugs in apt
20:33:48 <sieni> rob-d: yell for dcoutts :-)
20:33:59 <dons> he's probably asleep now
20:34:37 <RyanT5000> ah well i started C++ at 12, and both universities i've taken CS at were in C++
20:34:49 <RyanT5000> except for some scheme, prolog, and ML in prog lang
20:34:57 <RyanT5000> stupid scheme
20:35:00 <RyanT5000> i hated that so much
20:35:09 <SamB> this RML stuff is looks suspiciously like ML
20:35:13 <sieni> c++ is not for the faint of heart
20:35:13 <rob-d> thanks.  i'll write his name down (and maybe i won't lose the sheet of paper)
20:36:08 <sieni> I've seen my share of programming, but c++ is really complicated as a language
20:36:12 <RyanT5000> yeah
20:36:17 <RyanT5000> template metaprogramming is ridiculous
20:36:18 <araujo> RyanT5000, not so bad, there are worse things than scheme :-)
20:36:30 <sieni> RyanT5000: what's wrong with scheme?
20:36:45 <RyanT5000> i dunno, the lack of syntax was my main problem at the time
20:36:50 <lispy> sieni: i had a fun thing the other day where my HUGE c++ app didn't link correctly, but adding 'virtual' to the methods made the problem go away :)
20:37:02 <dons> heh
20:37:08 <RyanT5000> i honestly don't enjoy counting parentheses
20:37:09 <araujo> hah, thats what most of the people feel attractive from lisp-likelanguaes.
20:37:15 <sieni> lispy: do you really know what you did? :-)
20:37:23 <sieni> RyanT5000: read http://www.norvig.com/21-days.html
20:37:24 <lambdabot> Title: Teach Yourself Programming in Ten Years
20:37:26 <araujo> attracted*
20:37:26 <emertens> RyanT5000: if you are counting the parentheses, you are using the wrong editor
20:37:28 <SamB> lispy: maybe because they weren't symbols anymore?
20:37:30 <lispy> sieni: i have a vague idea as to why it *might* work
20:37:44 <RyanT5000> emertens: this is probably true, but i was using the one provided by my professor
20:37:56 <araujo> more likely the wron one then :-)
20:38:08 <RyanT5000> probably so
20:38:22 <sieni> I understand what a virtual function call means, but the connection to virtual inheritance is somewhat hazy.
20:38:22 <SamB> Emacs counts parens for you nicely ;-)
20:38:30 * araujo came to haskell through scheme (lisp-like languages)
20:38:36 * lispy too
20:38:41 <SamB> Emacs is probably the best editor for Lisp
20:38:51 <RyanT5000> i was using some stupid Dr. Scheme or something
20:38:52 <lispy> s/for Lisp//
20:38:53 <araujo> and i admit, i still do lisp-like programming too.
20:38:55 <sieni> SamB: the problem is that it uses emacs lisp
20:39:07 <SamB> lispy: well, I like it for other things too
20:39:10 <emertens> sieni: emacs + slime is uber
20:39:11 <SamB> sieni: well...
20:39:18 * lispy hates slime :)
20:39:26 <RyanT5000> i totally can't decide whether i love or hate strong typing either
20:39:32 <SamB> heh
20:39:42 <lispy> i think at one point, #lisp considered me a troll because of my hatered for slime :)
20:39:49 <lispy> RyanT5000: give it time
20:39:53 <sieni> emertens: maybe emacs + slime48, but haven't tried that ;-)
20:39:54 <SamB> what do you prefer?
20:39:57 <RyanT5000> well i love it in some regardss
20:40:00 <RyanT5000> most, in fact
20:40:07 <RyanT5000> but i'm not convinced it needs to be part of the language spec
20:40:20 <RyanT5000> otoh it should definitely be in the standard libraries
20:40:31 <SamB> what should be?
20:40:32 <sieni> I've been reading quite a bit of "Lisp In Small Pieces", which migh count as smoking crack here, but that's an extremely good book
20:40:37 <RyanT5000> strong typing
20:40:42 <SamB> heh
20:40:52 <SamB> I think dynamic typing works better as a library ;-)
20:41:19 <RyanT5000> lol interesting point
20:41:32 <RyanT5000> though what if strong typing was a metaprogramming library?
20:41:43 <jer> umm you guys using strong typing to mean static typing?
20:41:48 <SamB> then it would be GRAFTED ON.
20:42:08 <RyanT5000> samB: that depends on your definition of grafted on doesn't it :P
20:42:16 <SamB> dynamic typing is a lot easier to graft on than static typing, IMO.
20:42:34 <SamB> and leaves less of a mess.
20:42:35 <RyanT5000> SamB: but it requires you to use compiler hacks
20:42:56 <dons> jer, no, strong static typing. C has static typing, but it is weak -- you can subvert it with little effort
20:43:00 <SamB> oh, well, unsafeCoerce# is not particularly messy if you ask me
20:43:17 <jer> dons, right, i came in half way and saw 'strong typing' used in comparison to 'dynamic typing' which is why i asked
20:43:19 <SamB> thats pretty much the extent of the "compiler hacks" employed by Data.Dynamic
20:43:24 <dons> strong (static) typing in this sense is where, once the thing type checks, it won't go wrong at runtime, and end up in an undefined state
20:43:37 <SamB> dons: unless you do
20:43:40 <SamB> > head []
20:43:41 <lambdabot>  Add a type signature
20:43:45 <SamB> > head [] :: ()
20:43:46 <lambdabot>  Exception: Prelude.head: empty list
20:43:48 <dons> that's a defined state :)
20:43:49 <SamB> or something like that
20:43:52 <RyanT5000> what if the library-ness of the typing were invisible to the user?
20:43:57 <SamB> okay, whatever
20:43:59 <RyanT5000> (unless they chose to make it visible)
20:44:02 <dons> undefined like some of the things that happen in C
20:44:23 <SamB> can you do that in Lisp anyway?
20:44:36 <RyanT5000> no idea
20:44:47 <SamB> without messing about with internals and/or FFI?
20:48:28 <lispy> sbcl has static typing for some things
20:48:42 <lispy> it's like an optional thing you can throw into your source code
20:48:55 <jargonjustin> Is it possible to have a Unicode Char with GHC?
20:49:02 <lispy> but it's very rare that you'd get a compile error from it...generally it gives the compiler hints on how to optimize
20:49:03 <emertens> lispy: you aren't talking about (declare) are you?
20:49:04 <RyanT5000> jargonjustin: afaik, they are by default
20:49:15 <RyanT5000> > sizeOf (undefined :: Char)
20:49:16 <lambdabot>  Not in scope: `sizeOf'
20:49:25 <RyanT5000> the answer is 4
20:49:48 <emertens> @hoogle a -> Int
20:49:49 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
20:49:49 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
20:49:49 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
20:49:59 <lispy> emertens: it's been a while, yeah i think it's declare...you give the type of a variable or a function and then sbcl/cmucl can actually use the information intelligently and have some inference
20:50:18 <emertens> lispy: I'm pretty sure that doesn't type-check, but only optimizes
20:50:25 <emertens> lispy: but I could very easily be wrong
20:50:28 <jargonjustin> RyanT5000: I'm getting an error, "lexical error in string/character literal"
20:50:47 <lispy> emertens: well, in sbcl/cmucl they do have a type inference engine...i just don't remember the exact syntax to give it hints
20:50:54 <emertens> ah, okay
20:51:11 <RyanT5000> jargonjustin: i'm not sure if you're allowed to actually put unicode characters in the middle of string literals
20:51:19 <RyanT5000> i.e.: in actual source code
20:51:38 <jargonjustin> RyanT5000: Ah, I was hoping to use unicode characters in a grammar for Parsec
20:51:53 <RyanT5000> jargonjustin: you may be able to; check the lexer spec
20:52:06 <monochrom> http://www.vex.net/~trebla/haskell/random.xhtml   I just wrote the first part (of three).  Also the first valid XHTML 1.1 page I have written. :)
20:52:07 <lispy> i think you're supposed to be able to but the lexer for ghc has issues with it?  (i think someone said that to me once)
20:52:15 <dons> jargonjustin: you can use unicode for all purposes in ghc 6.5
20:52:25 <dons> in 6.4 its a bit more limited, since you can't do unicode IO
20:52:53 <lispy> dons: when 6.5 releases it actually releases as 6.6? is that correct?
20:53:01 <dons> yes
20:53:05 <jargonjustin> dons: Thanks, I'm on 6.4.1 now.
20:53:15 <lispy> ah okay...the haskell world will be a better place when 6.6 arrives :)
20:53:36 <dons> and you can use lambda and forall symbols as keywords in 6.6 :)
20:53:53 <dons> yay!
20:53:57 <lispy> heh
20:54:00 <lispy> go unicode!
20:54:02 <jargonjustin> Not sure Haskell will benefit from becoming APL, but that is pretty cool.
20:54:30 <monochrom> (λa -> a) :: ∀a. a->a   happy happy joy joy
20:55:25 <jargonjustin> dons: Can → be used for -> ?
20:55:34 <lispy> dons: and we get bang patterns
20:55:35 <monochrom> APL did not have unicode.  That makes the difference.  APL = ASCII punctuation language.  Obviously won't work.
20:55:56 <dons> jargonjustin: not sure. i suspect so
20:56:03 <emertens> I don't see how putting unicode characters is good... when people paste it into the channel, I'll see garbage :(
20:56:06 <dons> lispy: and that too
20:56:19 <dons> f  !x = "good"
20:56:37 <dons> f x = x `seq` "bad"
20:56:54 <dons> STRICT1(f) f x = "also bad"
20:56:56 <monochrom> The world needs to move on to unicode.  Please join rather than oppose.
20:56:57 <lispy> so i'm looking at this example ncurses program and the author does something clever i've never seen before.  They define a data type to hold the main state of the program, CMState and then define type CM = StateT CMState IO
20:57:09 <dons> f x | x `seq` False = undefined | otherwise = "bad too"
20:57:20 <lispy> is this a good idea/
20:57:32 <dons> sure.
20:57:38 <dons> is that stefan's code?
20:57:45 <lispy> there's not hidden performance costs or anything?
20:57:45 <lispy> yeah
20:57:56 <emertens> the only effect I will see from all the unicode is wasted harddrive space :)
20:57:57 <dons> he seems to often add a local state over IO monad
20:58:07 <dons> see our original UM for the icfp contest
20:58:18 <monochrom> Yes it's a good idea.  I have even done the forbidden evil of StateT ParserState IO.  ParserState refers to the parser state of Parsec.
20:58:39 <lispy> dons: it seems like a good idea because then you can thread the applications state through a 'main loop'
20:58:41 <emertens> Why is that forbidden evil?
20:58:56 <monochrom> Because it gave me ectasy.
20:58:57 <dons> lispy: right.the alternatives all seem worse
20:59:04 <dons> lispy: lambdabot does this too
20:59:16 * lispy gains 100xp from reading haskell source ;)
20:59:27 <monochrom> haha
20:59:28 <dons> lispy: stefan's a good hacker. you should study his code carefully :)
20:59:38 <lispy> will do
20:59:51 * RyanT5000 attempts to read haskell source
21:00:03 * RyanT5000 is blinded, takes 1d6 force damage
21:00:40 <RyanT5000> is that nethack, d&d, or a combination of the two? i can't keep my RPGs straight anymore
21:01:10 * lispy cals cureLightWounds :: Haskeller -> IO Haskeller
21:01:20 <RyanT5000> lol
21:01:42 <dons> lispy: should that be a Maybe? in case the cure fails?
21:01:47 <emertens> anyone know a better way to implement a priority queue than Data.Set and insert / deleteFindMax?
21:01:48 <dons> or is that just 'fail'
21:01:54 <RyanT5000> lol
21:01:55 <monochrom> IO can throw exceptions too :)
21:02:02 <lispy> dons: heh, typically the 'prays' can't fail
21:02:16 <lispy> depends on the game though...
21:02:27 <dons> emertens: there's an actual priority queue in Edison, if you want it
21:02:31 <dons> ?where edison
21:02:32 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
21:03:27 <emertens> thnx
21:14:53 <RyanT5000> how come class constraints on a datatype don't imply them on signatures the datatype is used in?
21:15:23 <dons> 1
21:15:39 <dons> oops,
21:15:48 <RyanT5000> e.g.:
21:15:48 <RyanT5000> data (Eq a) => D a = D a
21:15:48 <RyanT5000> instance Eq (D a) where
21:15:48 <RyanT5000>     (D a) == (D b) = a == b
21:16:28 <foxy__> when running c2hs it can't find any of the definitions in the header file...  but I'm looking at them!
21:17:04 <RyanT5000> it says it can't deduce Eq a
21:17:13 <RyanT5000> why is that?
21:17:33 <dons> class constraints on data types , on the lhs, don't mean anything
21:17:51 <RyanT5000> i see
21:18:06 <RyanT5000> if they were on the rhs, applying to the constructor would it work?
21:18:31 <dons> data D = forall a. Eq a => D a -- completely different thingamy
21:19:16 <RyanT5000> so why is there no way for me to specify things like this? i realize it's redundant, but it'd cut down on typing so much
21:19:21 <RyanT5000> and change propagation
21:20:11 <dons> well, possibly you do want a context in front of your constructor. as above
21:20:25 <dons> have a snoop around http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
21:20:27 <lambdabot> Title: 7.4. Type system extensions
21:21:23 <sieni> Does the term "typing" come from the fact that if your programming language of choice does not deduce the types by itself, you have to write in the types of all the variables manually.
21:21:27 <sieni> ?
21:21:30 <sieni> rather
21:21:36 <dons> heh.
21:22:02 <sieni> that was really bad joke, I know
21:22:22 <dons> so the compiler saves you a lot of "typing"
21:22:38 <RyanT5000> lol
21:22:46 <RyanT5000> both, in fact
21:25:32 <monochrom> You can write "data (Eq a) => D a = D a".  You still have to repeat "Eq a" in "instance (Eq a) => Eq (D a) where ...".  So what is the benefit?  The benefit is in forbidding "x = D (IO Int)".
21:26:14 <monochrom> err "x = D (putStrLn "hello world")"   correct example
21:26:28 <RyanT5000> yeah
21:27:14 <dons> ah yes. good point
21:27:23 <dons> so it does have some use
21:27:45 <dons> just not what people usually think -- that it'll save you adding constraints
21:28:05 <RyanT5000> why doesn't it save you using constraints?
21:28:17 <RyanT5000> i mean, it can properly be inferred, can't it?
21:28:27 <dons> f :: forall a. (Eq a) => a -> D a
21:28:27 <dons> f x = D x
21:28:29 <dons> sure.
21:28:44 <dons> it can be inferred. but people usually want to avoid writing that Eq at all, I've noticed.
21:29:00 <dons> and that's usually why they try to `factor' the constraint out to the data decl
21:29:17 <RyanT5000> right
21:29:26 <RyanT5000> what would be bad about letting them do that?
21:29:39 <monochrom> Here is a subtlty relating to your question.  Example the Haskell report 98 section 4.2.1.   data (Eq a) => Set a = NilSet | ConSet a (Set a).  ConSet (putStrLn "blah") (whatever) is invalid, as we know.  However...
21:29:47 <dons> well, you still need those dictionaries passed to the function
21:29:52 <monochrom> However, (NilSet :: IO Int)  is still allowed!
21:30:02 <dons> so it would break down the dictionary desugaring
21:30:15 <dons> and you could no longer look at a type to work out its class constraints
21:30:18 <monochrom> Err, (NilSet :: Set (IO Int))
21:30:40 <dons> f x = x ; f :: a -> D -- looks polyymorphic
21:30:48 <dons> but its not, its constraint to Eq
21:30:50 <dons> so avoiding that Eq constraint is bad
21:30:57 <RyanT5000> dons: it should be a -> D a
21:31:04 <dons> oh, typo
21:31:13 <monochrom> Because NilSet :: Set (IO Int) is still allowed, you cannot deduce "Set a  implies  Eq a" anymore.  So in "instance ..." you have to repeat constraints again.
21:31:33 <RyanT5000> why would NilSet :: Set (IO Int) be allowed?
21:31:38 <dons> anyway, it makes bounded polymorphism look like parametric polymorphism, so not good, I think
21:31:44 <RyanT5000> hm
21:32:28 <lispy> is bounded polymorphism the same as ad-hoc polymorphism?
21:32:42 <dons> imagine:
21:32:43 <dons> f :: a -> a
21:32:43 <dons> f x = case D x of D y -> y
21:32:52 <dons> looks like 'id' from the type
21:32:58 <dons> but it isn't.
21:33:08 <dons> now, the type no longer tells you much about what it does
21:33:10 <monochrom> The Haskell 98 Report says, to determine the constraints for a data constructor, look at the type variables needed, then constrain just those and no more.
21:33:17 <RyanT5000> dons: i don't think that should be legal
21:33:27 <emertens> dons : how is what you typed not "id"
21:33:39 <monochrom> So, to constrain the case of ConSet a (Set a), you have the variable a, so you contrain it, and the constraint is Eq a as expected.
21:33:42 <dons> you build a D x, and Eq a => D a
21:33:43 <lispy> emertens: it uses the D type constructor
21:33:48 <RyanT5000> you should only be able to make a class implicit if it can be determined from the datatypes used in the signature
21:33:54 <emertens> lispy: so?
21:33:55 <monochrom> Now, to contrain NilSet, it has no variables!  No constraints.
21:34:06 <RyanT5000> so a -> a is always a -> a
21:34:10 <lispy> emertens: then it's only id on the subset of D
21:34:15 <dons> emertens: we're talking about a magic extension
21:34:19 <emertens> oh
21:34:24 <RyanT5000> but a -> D a has a constraint equal to whatever the constraints on D are
21:34:25 <monochrom> Why the standard specifies this, I don't know.  But too late to change. :)
21:34:29 <dons> where data Cxt c => D c = ...
21:34:29 <dons> would
21:34:37 <dons> let you avoid adding Cxt to functions that use D
21:34:38 <monochrom> So, reading 4.2.1 for real.
21:34:43 <monochrom> s/reading/read/
21:34:44 <RyanT5000> right
21:35:09 <dons> but the result would be that you could no longer tell which functoins would give you theorems for free
21:35:32 <RyanT5000> you'd have to lookup the constraints on the datatypes used
21:35:53 <dons> you'd have to see the source for 'f', for example
21:36:14 <lispy> ah
21:36:17 <dons> since f x = x and f x = case D x of D y -> y have the same type.
21:36:26 <dons> so just looking at the type alone doesn't tell you the type!
21:36:36 <RyanT5000> dons: no, that shouldn't be legal
21:36:38 <dons> and you don't even know about this D, unless you view the source
21:36:51 <dons> why? seems a fairly simple thing to do
21:37:04 <RyanT5000> because it really does obfuscate things
21:37:08 <dons> heh
21:37:20 <RyanT5000> you should be able to completely determine the context of the type of something from the type signature as written
21:37:22 <dons> anyway, i suspect this is why we have no 'implict' contexts
21:37:35 <lispy> RyanT5000: so in the case of f you'd require the constraint but in the case of g :: a -> D a, you'd not require it?
21:37:42 <RyanT5000> right
21:37:43 <emertens> dons: are you suggesting that D is more than a place to put values? that behavior can be associated with it?
21:38:18 <lispy> RyanT5000: what about g x = D (fromFoo x) ?
21:38:26 <dons> data Cxt a => D a = D a, emertens. RyanT5000 suggested that then anything that uses D a not need a Cxt a on its type
21:38:28 <lispy> RyanT5000: then the type might be g :: a -> D b
21:38:41 <RyanT5000> lispy: then that'd be illegal
21:38:49 <RyanT5000> it would have to be Eq a => a -> D b
21:38:51 <dons> I think we'd make it always illegal :)
21:39:03 <dons> and require always having Eq a => .. ;)
21:39:16 <RyanT5000> yeah, but contexts can get big
21:39:26 <dons> ah ,for that though we have other tricks
21:39:29 <emertens> dons: so... what would be gained from the type of your function not being (Cxt a) => a -> a ?
21:39:32 <lispy> so we need context synonyms? ;)
21:39:37 <dons> we have those
21:39:43 <lispy> ?
21:39:46 <emertens> I've obviously missed something important, you can ignore me now
21:39:50 <RyanT5000> lispy: empty classes
21:39:51 <dons> emertens: ok :)
21:40:00 <lispy> ah, nice
21:40:15 <dons> HList uses them all the time
21:41:40 <monochrom> @type sort
21:41:41 <lambdabot> forall a. (Ord a) => [a] -> [a]
21:41:48 <dons> I think I'd probably use an existential for some of what you're trying, RyanT5000
21:42:57 <RyanT5000> dons: nah, i don't need any runtime polymorphism
21:42:58 <RyanT5000> instance (IArray a (Set m), Ix l) => R (Imp a l m) l m where
21:43:03 <RyanT5000> i'm getting an error on that line
21:43:12 <RyanT5000> Non-type variables, or repeated type variables
21:43:23 <RyanT5000> is Set m illegal?
21:43:38 <RyanT5000> no pattern-matching on types in contexts?
21:43:50 <dons> right
21:44:00 <RyanT5000> is there any way to achieve that effect?
21:51:54 <RyanT5000> i had to use -fallow-undecidable-instances
22:11:53 <sjanssen> RyanT5000: I think the problem is using l twice on the RHS
22:12:05 <sjanssen> you can't express type equality
22:12:18 <RyanT5000> hm
22:12:37 <RyanT5000> why not?
22:13:02 <dons> RyanT5000:  why don't we have: f x x  = ... :)
22:13:36 <sjanssen> I can't remember the reason, there is a discussion about it in the HList paper
22:13:41 <RyanT5000> aren't types simpler than values?
22:13:59 <RyanT5000> (in haskell's type system)
22:14:07 <sjanssen> also, which version of GHC are you using?
22:14:20 <dons> though simmply using T a a gives me an error,     Conflicting definitions for `a'
22:14:26 <dons> i.e. for class Eq a => T a a where
22:14:55 <RyanT5000> 6.4.2
22:15:04 <dons> ah, but that's probably what "repeated type variables" was on about
22:16:01 <sjanssen> is there a fundep involved in the R class?
22:16:12 <RyanT5000> no fundeps anywhere
22:22:13 <foxy> @pl \f g x -> f x (g x)
22:22:14 <lambdabot> ap
22:22:25 <foxy> @hoogle ap
22:22:25 <sjanssen> I think I'm wrong, the problem isn't l being repeated
22:22:26 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
22:22:26 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
22:22:26 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
22:23:04 <foxy> i finally found a use for the combinator S in my code :)
22:25:45 <int-e> @pl s x y z = x z (y z)
22:25:46 <lambdabot> s = ap
22:37:37 <u221e> I still can't seem to do anything in haskell :(
22:38:53 <u221e> I tried making a ray tracer... and eventually gave up and used C...
22:39:31 <foxy__> @seen dcoutts
22:39:32 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 3 hours, 14 minutes and 26 seconds ago.
22:39:54 <foxy__> @seen dcoutts_
22:39:55 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
22:40:17 <RyanT5000> could someone give me a simple example of how to use an STArray? just like taking an Array and updating all the cells using runSTArray
22:40:37 <RyanT5000> or any kind of hints or links on using ST would be nice
22:41:28 <sjanssen> @hoogle runSTArray
22:41:28 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
22:41:51 <sjanssen> RyanT5000: look at Data.Array.MArray for the interface
22:43:10 <RyanT5000> well i have been
22:43:30 <RyanT5000> i mostly just don't understand what the first type parameter to ST means
22:50:22 <sjanssen> RyanT5000: it's a phantom type to make sure the imperative state doesn't leak into the pure functional side
22:50:40 <RyanT5000> ah
22:50:49 <RyanT5000> i suppose that would be why i didn't understand it
22:50:58 <sjanssen> @type Control.Monad.ST.runST
22:50:59 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
23:13:55 <goltrpoat> constraint programming question, don't really know where else to ask.  say the variables are x_1, x_2, ..., x_8, they are unordered triples of distinct elements from a set S, where |S|=5, say.  how do i binarize the constraint that each element of S, call it s_i, must appear exactly n_i times?
23:14:27 <goltrpoat> i can obviously put x = {x_1, x_2, ..., x_8} and then it's a unary constraint on x, but that's silly
23:15:29 <goltrpoat> i'm mostly picking this up from web pages and random papers, and they seem to get suspiciously vague when it comes to binarization of n-ary constraints
23:19:57 <RyanT5000>     Inferred type is less polymorphic than expected
23:19:57 <RyanT5000>       Quantified type variable `s' escapes
23:19:57 <RyanT5000>       Expected type: GHC.ST.ST s (GHC.Arr.STArray s i e) -> b
23:19:57 <RyanT5000>       Inferred type: (forall s1. GHC.ST.ST s1 (GHC.Arr.STArray s1 i e))
23:19:57 <RyanT5000>                      -> GHC.Arr.Array i e
23:19:58 <RyanT5000>     In the first argument of `($)', namely `runSTArray'
23:20:09 <RyanT5000> i have no idea what that means
23:20:30 <sjanssen> RyanT5000: try explicit parentheses instead of $
23:25:33 <RyanT5000> sjanssen: that was it
23:25:54 <RyanT5000> i hate putting () around a multiline do expression
23:25:58 <RyanT5000> oh well
23:31:13 <tessier> Inferred type is less polymorphic than expected
23:31:17 <tessier> That is an awesome error message
23:31:28 <tessier> It just sounds cool.
23:32:03 <dfeuer> Haskell typechecker error messages are, by law, completely incomprehensible most of the time.
23:32:17 <RyanT5000> lol
23:32:34 <int-e> not really, once you understand them they usually make sense ;)
23:33:00 <RyanT5000> that's kind of tautological
23:33:03 <tessier> Have you ever understood something that did not make sense?
23:33:06 <tessier> Precisely
23:33:11 <int-e> RyanT5000: I know :)
23:33:20 <tessier> I don't think I really understood the definition of tautological until recently
23:34:04 <int-e> But I might add that I do understand typechecker errors most of the time.
23:45:44 <dons> u221e: did you look at the ray tracers on haskell.org under `libraries and tools' ?
23:45:50 <dons> there's about 15 of them, iirc
23:48:24 <foxy> what does iirc mean?
23:48:43 <dons> if i recall correctly
23:48:50 <foxy> ah... :)
23:48:52 <dons> :)
23:49:10 <foxy> dons, have you used c2hs?
23:49:17 <dons> not really
23:49:24 <dons>  dcoutts has though
23:49:41 <foxy> not getting a pong
23:49:44 <foxy> dcoutts, ping
23:49:50 <dons> sleep time in the uk.
23:49:55 <dons> he'll turn up in a few hours
23:49:57 <foxy> @localtime dcoutts
23:49:58 <lambdabot> Local time for dcoutts is Mon Jul 31 07:47:35
23:50:44 <foxy> dons, what's 'fusion'
23:51:07 <dons> oh, i've got to go. but best to check out the slides on the fps web page.
23:51:09 <dons> ?where fps
23:51:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
23:51:31 <dons> roughly, we deforest intermediate structures in computations, by combining (fusing) maps
23:51:43 <dons> ie. map g . map f ==> map (g.f)
23:52:19 <dons> in particular, if you think about arrays, this corresponds to avoiding a traversal of the array, creating an intermediate result (in a purely functional setting -- no mutation in-place)
23:52:38 <dons> Data.ByteString is written in terms of fuseable combinators, that obey nice rules, like 'map' above
23:53:01 <dons> so that the compiler can take the user's code, and rewrite away intermediate arrays/byte strings
23:53:11 <dons> since there's no side effects, this is almost easy.
23:53:24 <dons> haskell wins out :)
23:54:27 <RyanT5000> dons: wouldn't automatic generation of fusion rules be possible if we had some builtin function descriptors?
23:54:28 <RyanT5000> e.g.:
23:54:42 <RyanT5000> f :: a -> b
23:54:45 <RyanT5000> g :: b -> a
23:54:52 <RyanT5000> then if we could say "g is the inverse of f"
23:55:13 <RyanT5000> possibly the compiler could make use of that
23:55:27 <RyanT5000> simmilarly, f :: a -> a -> b, "f is commutative"
23:55:33 <RyanT5000> "f is associative"
23:56:01 <RyanT5000> seems like we could make metarules for stuff like this
23:56:08 <dons> possibly
23:56:13 <dons> though specifying RULES aren't too hard
23:56:26 <dons> since you encode everything in terms of a single , or a few , combinators
23:56:30 <dons> and inline
23:56:39 <dons> resulting in only a few rules that actually are needed
23:56:47 <dons> i.e. loop f . loop g ==> loop (f.g)
23:56:49 <RyanT5000> hm
23:56:58 <dons> where folds/scans/maps/filters/... are all in terms of 'loop'
23:57:32 <dons> its a matter of finding the combinator that expresses the widest range of iterative patterns
23:57:44 * dons -> out and about
23:57:47 <RyanT5000> i'm just thinking about the situation where you have separate libraries, and you want rules that cover combinators from both interacting
23:58:26 <RyanT5000> or more aggressive rules, like relying on commutativity
