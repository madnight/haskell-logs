00:00:35 <llama32> can haskell [GHC] modules be compiled to shared libraries that i can load at runtime depending on information not available at compile time [plugins]? does this create problems for the garbage collector or anything?
00:00:56 <xerox> Yes, it is possible.
00:01:09 <xerox> Either with dynamic linking or hs-plugins
00:01:28 <xerox> There also is something called GHC-plugins in the workings, I think.
00:01:59 <llama32> excellent
00:02:37 * llama32 thinks he has finally found another language he could be bothered learning
00:03:47 <xerox> Curry is honoured.
00:12:40 <RyanT5000> my room smells like curry right now; i went to the indian grocer today
00:15:09 <pierre-> hello.
00:15:17 <xerox> Ohayou.
00:44:43 <pierre-> Could you help me? i'm using cabal as my build tool. All went good before i tried to all package HDBC-sqlite3 in my build-depends (i can see package in 'ghc-pkg list'). Ghc says "could not find module Database.HDBC.Sqlite3", and it seems cabal didn't even include '-package hdbc-sqlite3' in ghc command line
00:45:06 <dons> did you add hdbc-sqlite3 as a build dep?
00:45:09 <dons> make sure the case is correct
00:45:29 <dons> also, you need to rerun /Setup.hs configure if you change the .cabal file (usually, I think)
00:47:05 <pierre-> dons: thank you much, ./Setup.hs configure did the thing :-)
01:43:55 <dons> @tell dcoutts the build/head thingy seems to be an interacting with unpack. so head . build . unpack -> unpack, and something bad happens. need to investigate further
01:43:56 <lambdabot> Consider it noted.
01:45:19 <Heffalump> how does lambdabot remember users? Just by nickname?
01:46:57 <dons> yep
01:47:15 <dons> so implicitly by the nickserv identify system
01:48:42 <Heffalump> oh yeah, I forgot that
02:29:06 <fasta> Where can I get the "lang" package (NewBinary needs it)?
02:31:56 * basti_ knew.
02:33:24 <dons> its haskell98 pckage now, isn't it?
02:33:31 <dons> or no, it doesn't even exist. i think its just base.
02:33:38 <dons> try removing the dep?
02:36:34 <fasta> dons: then during "build" it says ghc-6.5: unknown package: lang
02:36:48 <fasta> dons: I don't see any reference to it though.
02:36:48 <Manyfold> i import IO into a program but everytime i use putStrLn i get not in scope data constractor putStrLn
02:36:58 <dons> because there must be a a -pckage lang somewhere. but it doesn't exist since ghc 6.2
02:37:12 <dons> Manyfold: import System.IO ?
02:37:17 <dons> @index putStrLn
02:37:18 <lambdabot> System.IO, Prelude
02:37:24 <Manyfold> impot IO
02:37:24 <kosmikus> hi there
02:37:27 <fasta> dons: Isn't anyone doing binary IO in Haskell?
02:37:27 <dons> you shouldn't need to import anything.
02:37:28 <Manyfold> +r
02:37:39 <dons> fasta: sure. they use NewBinary, or many variants on it.
02:37:46 <fasta> dons: It's a dependency of HTTP, so nobody must be doing HTTP either.
02:37:53 <dons> but maybe you've an out of date version?
02:38:14 <fasta> dons: I have the version which is referenced on the HTTP page.
02:38:15 <Igloo> Manyfold: Are you uppercasing the 'p'?
02:38:20 <fasta> dons: a darcs version
02:38:32 <Manyfold> no
02:38:43 <fasta> dons: http://www.n-heptane.com/nhlab/repos/NewBinary/
02:38:45 <lambdabot> Title: "Index of /nhlab/repos/NewBinary"
02:38:52 <Igloo> Manyfold: Can you paste the exact error?
02:38:54 <fasta> dons: Is there a newer version somewhere?
02:39:12 <Manyfold> program
02:39:22 <Manyfold> module Main		
02:39:22 <dons> fasta: yeah, i know. it's unmaintained. perhaps check the libraries and tools page of haskell.org there's a variety of other binary and http libs out there.
02:39:22 <Manyfold>     where
02:39:22 <Manyfold> 	
02:39:22 <Manyfold> import System.IO
02:39:22 <Manyfold> main = do
02:39:23 <Manyfold>   hSetBuffering stdin LineBuffering
02:39:25 <Manyfold>   PutStrLn "Please enter your name: " 
02:39:27 <Manyfold>   name <- getLine
02:39:28 <Manyfold>   putStrLn ("Hello, " + name + ",how aprograre you?")
02:39:34 <Manyfold> error
02:39:36 <Igloo> Manyfold: You are uppercasing the 'p'
02:40:06 <Manyfold> oh yes sorry
02:40:16 <Manyfold> didn't see that :(
02:40:40 <fasta> dons: ok, seems to work now, but it's a pain to wade through all those broken libraries.
02:41:01 <dons> you just happen to be using an unmaintained lib.
02:41:34 <fasta> dons: I only need an XML library. Is there one that is being maintained?
02:42:51 <dons> HaXml?
02:43:20 <fasta> dons: does not compile from darcs, nor from version 1.13, nor 1.14.
02:43:53 <dons> that seems surprising. did you report a bug?
02:44:20 <fasta> dons: yes, I e-mailed Malcolm yesterday. But I spend a lot time before it.
02:44:41 <dons> anyway, the list is here, http://www.haskell.org/haskellwiki/Libraries_and_tools/Web_programming
02:44:42 <lambdabot> Title: "Libraries and tools/Web programming - HaskellWiki"
02:44:43 <fasta> dons: What's a reasonable time "to give up" on getting things to work?
02:45:18 <fasta> dons: Haskell XML Toolbox is also broken
02:45:36 <fasta> dons: thus all the libraries for doing XML on Haskell are currently broken. 
02:46:00 <Igloo> fastaL You shouldn't expect things to work with darcs ghc even if they are being maintained
02:46:12 <dons> also, http://www.haskell.org/haskellwiki/Libraries_and_tools/Data_structures#Serialising_data
02:46:12 <lambdabot> Title: "Libraries and tools/Data structures - HaskellWiki"
02:46:22 <dons> is your binary libs page.
02:46:45 <dons> you're using ghc from darcs?
02:47:14 <fasta> dons: yes, but I first tried with both ghc-6.4.1 and 6.4.2
02:47:27 <dons> 6.4.2 is what to use. 6.5 is going to break for a lot of things
02:47:35 <int-e> NewBinary: the build works for ghc 6.4.2; for ghc 6.5 you need to remove the references to the lang package from the .cabal file
02:47:49 <fasta> int-e: yes, I already got it to build.
02:48:18 <dcoutts_> @yarr!
02:48:18 <lambdabot> Keelhaul the swabs!
02:48:28 * dcoutts_ is back from holiday in France
02:48:51 <dons> @yarr!!
02:48:51 <lambdabot> Unknown command, try @list
02:48:59 <dons> @bah :(
02:48:59 <lambdabot> Maybe you meant: faq map
02:49:06 <dons> hehe
02:50:36 <int-e> @faq
02:50:36 <lambdabot> The answer is: Yes! Haskell can do that.
02:50:40 <int-e> ah.
02:51:02 <dcoutts_> hia dons, any developments in the last week?
02:52:56 <dons> just worked out the bug i was having with rules in 6.5. it was unpack/build interacting with list build/head.
02:53:09 <dons> also, i've just pushed fps Data.ByteString.Lazy into fptools
02:53:27 <dons> so they're back in sync now, fps and base
02:54:13 <dcoutts_> great
02:55:52 <fasta> Is there some way to view all the modules currently available?
02:56:32 <fasta> ghc-pkg list says I have Browser-2006.4.23
02:56:50 <fasta> But HXT-5.5 says it can't find Network.Browser
02:58:19 <mux> yes
02:58:22 <mux> not the same thing
02:58:29 <mux> HXT lacks a dependency in its .cabal file
02:58:37 <mux> I sent a mail to the author but got no answer yet
02:58:49 <fasta> mux: ok, how to correct it?
02:59:00 <mux> just a sec, let me dig this up
03:00:01 <mux> -depends: base, haskell98, parsec, HTTP, HUnit, network
03:00:01 <mux> +depends: base, haskell98, parsec, HTTP, HUnit, network, Browser
03:00:37 <mux> the missing dependency caused the build to fail because it wasn't looking in the directory where Browser actually is installed
03:02:03 * mux wishes the HXT guy wasn't MIA
03:02:13 <fasta> mux: MIA?
03:02:25 <mux> missing in action
03:02:45 <fasta> mux: You could just put his code in a darcs repo.
03:03:03 <fasta> mux: when the author doesn't respond, you will be the new "maintainer".
03:03:14 <mux> yes I could, but that won't solve the problem for people that will look into the "official" HXT place
03:03:20 <mux> plus I have no time to maintain such a thing
03:03:41 <mux> and even if I was willing, I clearly lack the haskell skills
03:04:20 <mux> now if you'll excuse me for a few minutes I need to fill my washing machine up :-)
03:04:36 <fasta> mux: thanks
03:04:46 <mux> welcome, I hope it'll helps
03:05:22 <astrolabe> can I get lambdabot to tell me the associativity of '!'?
03:06:02 <mux> > info (!)
03:06:03 <lambdabot>  Not in scope: `info'
03:06:05 <mux> > info (*)
03:06:06 <lambdabot>  Not in scope: `info'
03:06:10 <mux> err.
03:06:26 <mux> well, GHCi ":info" command works
03:06:32 <lambdabot> infixr 0 $
03:07:38 <astrolabe> Thanks. 
03:08:00 <astrolabe> Why did lambdabot give three replys to two questions?
03:08:18 <dons> just playing games :)
03:08:25 <astrolabe> heh!!!!
03:08:35 <mux> evil dons
03:09:38 <fasta> It seems GHC compiles slower on every release.
03:10:16 <mux> that's a general trend with compilers whose first letter is G and last letter is C :-P
03:11:00 <dons> it does more and more every release
03:11:07 <mux> but I guess it also generates more efficient code
03:11:14 <dons> though, it did get faster between 6.2 and 6.4
03:11:19 <fasta> Yes, I already thought that. 
03:11:21 <dons> the whole backend was rewritten and simplified
03:11:40 <fasta> Ah, well, nothing wrong with broadly generalizing ;)
03:11:55 <dons> yeah, it gets slower, except when it gets faster
03:12:07 <fasta> Yeah, that must be it!
03:12:50 * mux ponders
03:12:55 * mux thinks dons could take HXT over
03:13:30 <dons> could, eh?
03:13:34 <mux> :-)
03:13:46 <mux> you know you want to
03:14:22 <dons> hmm.
03:14:42 <fasta> Yes, I know dons wants to too. 
03:14:48 <fasta> Then it must be true.
03:15:51 <fasta> Ok, HXT is less broken than HaXml. 
03:18:56 <fasta> Haskell should have something like this: http://www.enterpriselisp.com/software/system-check/
03:18:57 <lambdabot> Title: "System-check"
03:27:23 <Stinger_> damn, cant find my chapter of SEP that I photocopied
03:27:38 <Stinger_> oh,spoke too soon
03:40:01 <dcoutts_> xerox, heh, when you finnish the SoC, there's a new cairo 1.2 release out :-)
03:43:15 <neologism> what is xerox's SoC project?
03:43:34 <mux> cairo bindings I guess?
03:44:11 <neologism> :)
03:44:12 <neologism> ok
03:44:12 <dcoutts_> mux, yep
03:44:24 <dcoutts_> mux, oh no, that was last year
03:44:27 <mux> dcoutts_: I thought you had done those already
03:44:36 <mux> ah.
03:44:46 <dcoutts_> neologism, this year xerox is working on Cabal stuff
03:45:03 <neologism> ok
03:50:40 <N1ckH0rr0r> hi
04:07:03 <mnislaih> @seen Lemmih
04:07:03 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I don't know when Lemmih last spoke.
04:07:21 <mnislaih> Lemmih: are you around ?
04:07:41 <dcoutts_> dons, I see you've been doing good work pusing the fps QC tests into the ghc testsuite too
04:07:54 * dcoutts_ is just catcing up on a week of email
04:08:16 <dcoutts_> and I notice that it may be possible that ghc no longer needs gcc on some platforms
04:08:44 <dcoutts_> since ghc can compile the rts using the ncg
04:20:37 <cjay> ?where ngc
04:20:37 <lambdabot> I know nothing about ngc.
04:21:15 <cjay> ?where ncg
04:21:16 <lambdabot> I know nothing about ncg.
04:21:27 <neologism> nhc?
04:21:42 <psykotic> noncommutative geometry? :)
04:22:20 <cjay> lol, found it
04:22:43 <cjay> good morning btw ;)
04:56:45 <dcoutts_> cjay, native code generator
04:57:34 <cjay> thanks :)
08:28:51 <fasta> Does the latest Emacs mode work together with ghci? It appears not to be working, I added the correct hook, but it still calls Hugs. 
08:30:10 <fanopanik> (setq haskell-program-name "ghci")
08:31:25 <araujo> hello
08:31:36 <fasta> fanopanik: It appears to work, (without your fix). But is it possible to load the module I am working on?
08:31:50 <fanopanik> C-c C-l ?
08:32:45 <fasta> fanopanik: yep, I already had it :)
08:33:03 <fasta> fanopanik: It appears I don't even need to save the file, that's nice. 
08:33:10 <fanopanik> it saves for you
08:37:54 <TuringTest> Note that ghci's ":browse" command in emacs is fairly useful, since the buffer is searchable and M-/ can complete on any of the listed symbols.
08:59:51 <petekaz> @hoogle FilePath -> FilePath -> FilePath
08:59:52 <lambdabot> Distribution.Compat.FilePath.dropPrefix :: FilePath -> FilePath -> FilePath
08:59:52 <lambdabot> Distribution.Compat.FilePath.joinPaths :: FilePath -> FilePath -> FilePath
09:00:30 <petekaz> If I try to import 'Distribution.Compat.FilePath', my program barfs.
09:00:50 <petekaz> It says it is hidden in Cabal.
09:01:09 <petekaz> How do I go about using that function?
09:09:14 <petekaz> hello?
09:17:58 <fasta> petekaz: How about you can't?
09:18:24 <petekaz> oh.
09:21:09 <petekaz> I guess I was confused as I had assumed that all the APIs described in the hierarchical libraries was fair game.
09:24:41 <yip> do you guys think that OpenMP could somehow be used with haskell?
09:26:12 <dcoutts> that's the paralelel programming stuff right?
09:26:26 <yip> yes
09:26:31 <dcoutts> perhaps the NDP project could use it
09:26:39 <dcoutts> nested data parallelism
09:28:56 <ihope> @hoogle a -> b
09:28:58 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
09:28:58 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
09:28:58 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
09:29:14 <ihope> "ask" and "tell", eh?
09:29:55 <ihope> @hoogle Monad m => [a] -> (a -> m ()) -> m ()
09:29:56 <lambdabot> No matches, try a more general search
09:30:05 <ihope> @hoogle Monad m => [a] -> (a -> m b) -> m [b]
09:30:06 <lambdabot> No matches, try a more general search
09:30:17 <ihope> Hmm.
09:31:00 <ihope> @type sequence_ . map
09:31:02 <lambdabot>   Expecting a function type, but found `b'
09:31:02 <lambdabot>    Expected type: (a1 -> b) -> [m a]
09:31:10 <ihope> Urb?
09:31:22 <ihope> @type (sequence_ .) . map
09:31:23 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m ()
09:31:56 <ihope> That'll work.
09:51:56 <ihope> > do do [3]
09:51:57 <lambdabot>  [3]
09:52:00 <ihope> :-)
09:52:27 <ihope> > do [3]; do [4]
09:52:28 <lambdabot>  [4]
10:13:46 <petekaz> What is the idiom for using a predicate that returns IO Bool in a list comprehension?  Can I do it?
10:14:23 <petekaz> I.e.  [ process f | f <- files, doesFileExsist f ]
10:14:36 <petekaz> files is a list of FilePaths.
10:14:58 <petekaz> doesFileExist is from System.Directory and returns IO Bool
10:15:13 <apfelmus> @type filterM
10:15:15 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:15:30 <apfelmus> @type mapM_
10:15:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
10:16:38 <petekaz> apfelmus: thank you.
10:16:56 <apfelmus> filterM doesFileExist files >>= mapM_ process
10:17:48 <petekaz> I'm doing this:
10:17:54 <petekaz>   all <- getDirectoryContents dir
10:17:54 <petekaz>   files <- filterM doesFileExist all
10:17:55 <petekaz>   sequence [ liftM parseEmail $ readEmail f | f <- files ]
10:18:15 <petekaz> Is that good form?
10:20:18 <petekaz> I changed that to:
10:20:22 <petekaz>   files <- getDirectoryContents dir >>= filterM doesFileExist
10:20:31 <petekaz> I like that better, thanks for the help.
10:21:23 <apfelmus> petekaz: yes, it ties the existence test to the files
10:25:07 <petekaz> apfelmus: I changed that to: getDirectoryContents dir >>= filterM doesFileExist >>= mapM (liftM parseEmail . readEmail)
10:25:37 <petekaz> I think sometimes I like the non-do form.  (I'm a beginner obviously)
10:37:23 <apfelmus> petekaz: it all depends on your gusto, not on mine :)
10:41:39 <DukeDave> hey gang, I'm having no luck with google on:    removeNothings :: [Maybe a] -> [a]
10:42:01 <DukeDave> it should be a function to drop all the Nothings
10:42:05 <xerox> catMaybes
10:42:12 <xerox> ?type :P
10:42:13 <lambdabot> parse error on input `:'
10:42:16 <xerox> Ops.
10:42:19 <apfelmus> @hoogle [Maybe a] -> [a]
10:42:19 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
10:42:21 <xerox> ?type catMaybes
10:42:22 <lambdabot> forall a. [Maybe a] -> [a]
10:42:49 <DukeDave> mmm, I really need to start using hoogle :)
10:42:52 <DukeDave> cheers :D
10:43:08 <xerox> > (\xs -> [x | (Just x) <- xs]) [Just 1, Nothing, Just 2, Nothing, Just 3]
10:43:09 <lambdabot>  [1,2,3]
10:54:14 <alec> @hoogle String -> [[String]]
10:54:15 <lambdabot> No matches, try a more general search
10:55:24 <xerox> What are you searching for alec ?
10:55:26 <apfelmus> @type map words . lines
10:55:27 <lambdabot> String -> [[String]]
11:01:57 <alec> xerox: just looking to see if there's some code I could look at for doing that
11:02:04 <alec> xerox: just being lazy :)
11:02:05 <fasta> Is there a function which takes a String and returns an XML document in HXT-5.5?
11:02:57 <fasta> I see a function which takes a String argument and uses that as the xml file to read, but I don't want that. 
11:03:14 <petekaz> Can anyone help me with this: http://www.rafb.net/paste/results/mAG3dQ76.html
11:03:56 <petekaz> The commented out line works fine, it basically runs my program with the single value, I was trying to generalize it to work with any number of command line args.
11:08:45 <mathewm> is haddock the last word in haskell documentation?  Seems like there should be something that plays more nicely with lhs
11:10:30 <ihope> fasta: what's the type you want it to return?
11:11:11 <apfelmus> @type mapM
11:11:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
11:11:14 <fasta> ihope: A DOM tree, I am not really sure about the actual type.
11:11:16 <apfelmus> @type mapm_
11:11:18 <lambdabot> Not in scope: `mapm_'
11:11:21 <apfelmus> @type mapM_
11:11:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
11:12:39 <fasta> document :: GenParser Char state XmlTree
11:12:39 <fasta> document' :: GenParser Char state XmlTrees
11:12:49 <fasta> Yeah.... undocumented functions :)
11:13:38 <fasta> Well, at least the type is different 
11:15:00 <fasta> I think I will just use the Source
11:15:10 <ihope> @hoogle String -> XmlTree
11:15:10 <lambdabot> No matches, try a more general search
11:16:02 <fasta> ihope: I already found one. 
11:16:15 <fasta> ihope: I also tried Hoogle before you, but it doesn't index those things. 
11:17:33 <apfelmus> petekaz: mh? it should work, doesn't it?
11:17:44 <petekaz> apfelmus: no.
11:18:17 <petekaz> http://www.rafb.net/paste/results/dqMBAV70.html
11:20:11 <petekaz> Here is the full program: http://www.rafb.net/paste/results/Fi8dsb64.html
11:21:05 <apfelmus> petekaz: ah, its getArgs >>= mapM_ $ \x -> mapM_ pretty =<< processMaildir x
11:21:58 <petekaz> ah .. I was trying some point free stuff.
11:22:01 <petekaz> i guess it didn't work.
11:22:26 <int-e> @pl \x -> mapM_ pretty =<< processMaildir x
11:22:26 <lambdabot> (mapM_ pretty =<<) . processMaildir
11:23:45 <petekaz> ah.
11:26:23 <apfelmus> @type return ["ah","oh"] >>= mapM (return . words) >>= mapM_ (return . length)
11:26:24 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
11:28:07 <apfelmus> @type \x f -> x >>= mapM f
11:28:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m [a] -> (a -> m b) -> m [b]
11:28:16 <petekaz> apfelmus: thanks for the help, I now have my first standalone haskell program.
11:28:50 <petekaz> Just checks for new mail for me.
11:30:26 <palomer> does it do it in style?
11:31:08 <apfelmus> petekaz: next, you should write a program that digests their content and automatically answers them :)
11:31:26 <petekaz> that woudl be perfect.
11:31:37 <petekaz> I could make millions!
11:32:43 <ihope> And it would be easy, with Haskell on your side :-)
11:35:58 <neologism> answerMail _ = mail "sorry, I dont know"
11:36:02 <neologism> this way?
11:37:15 <fasta> <?xml version=\\\"1.0\\\" encoding=\\\"US-ASCII\\\">...\"\" (\
11:37:16 <fasta> line 1, column 6):\nunexpected xml\nexpecting legal XML name character\n") []]
11:37:24 <fasta> What's wrong with that XML?
11:37:26 <apfelmus> anwerMail s = if '$' `elem` s then mail "please send me further information" else ...
11:38:52 <DukeDave> hehe
11:40:45 <apfelmus> answerMail s = let pure = filterspam (filterspam s) in ... -- be extra sure err pure!
11:45:11 <fasta> Could it be an encoding problem?
11:45:34 <fasta> <?xml version="1.0"?>
11:45:35 <fasta> <greeting>Hello, world!</greeting> 
11:45:46 <fasta> It doesn't even parse that when inside a file.
11:47:49 <Cale> Which doesn't parse that? How is the file encoded? Perhaps try removing any byte order mark, if present?
11:48:55 <fasta> Cale: HXT-5.5
11:49:22 <fasta> Cale: I thinl it's UTF-8, (that's what I have set in Emacs)
11:49:44 <Cale> Is it putting a byte order mark into the file?
11:49:48 <fasta> Cale: How do I see whether there is a byte order mark?
11:50:06 <fasta> Cale: open the file in hex mode?
11:50:41 <Cale> od -x file.xml
11:50:54 <Cale> and look at the first 3 bytes
11:51:09 <fasta> 0000000 3f3c 6d78 206c 6576 7372 6f69 3d6e 3122
11:51:19 <Cale> okay, it's not there
11:51:26 <Cale> so I don't know
11:51:33 <Cale> does it give an error?
11:51:59 <fasta> Cale: It gives the error above.
11:52:12 <fasta> Cale: [NTree (XError 2 "\"string: \"<?xml version=\\\"1.0\\\"?>\\n<!-- Edited with X...\"\" (line\ 1, column 6):\nunexpected xml\nexpecting legal XML name character\n") []]
11:52:43 <fasta> Cale: It doesn't come really far... column 6
11:53:14 <fasta> Cale: oh, that's another file, but it happens with test.xml also.
11:53:32 <Cale> hm
11:53:47 <ihope> Oh, boy...
11:54:17 <Cale> > read "\"string: \"<?xml version=\\\"1.0\\\""
11:54:18 <lambdabot>  Add a type signature
11:54:22 <Cale> > read "\"string: \"<?xml version=\\\"1.0\\\"" :: String
11:54:23 <lambdabot>  Exception: Prelude.read: no parse
11:54:28 <Cale> oh, right
11:54:41 <Cale> > read "\"string: \"<?xml version=\\\"1.0\\\" ?>\\n<!-- Edited with X...\"\" (line\ 1, column 6):\nunexpected xml\nexpecting legal XML name character\n" :: String
11:54:42 <lambdabot>  Illegal character in string gap
11:54:54 <fasta> There are a couple of Master Theses written on the thing, and it still doesn't work...
11:56:49 <ihope> Ah, right.
11:57:20 <ihope> Prolog can "fill in the blanks" in something, but Djinn can't.
11:58:01 <fasta> Cale: the string is illegal?
11:58:13 <Cale> I'm not sure, that's just strange
11:58:13 <fasta> Cale: why?
11:58:21 <fasta> Cale: oh
11:58:21 <ihope> Well, Djinn isn't Turing-complete, is it? :-)
11:58:25 <Cale> It's almost certainly a legal string
11:58:56 <fasta> > read "\"string: \""
11:58:56 <lambdabot>  Add a type signature
11:58:58 <Cale> ihope: Djinn doesn't try to deal with recursive data (or recursion at all)
11:59:03 <fasta> > read "\"string: \""::String
11:59:04 <lambdabot>  "string: "
11:59:22 <ihope> > read "<?xml version=\\\"1.0\\\"" :: String
11:59:23 <lambdabot>  Exception: Prelude.read: no parse
11:59:33 <ihope> > read "\\\"1.0\\\"" :: String
11:59:33 <lambdabot>  Exception: Prelude.read: no parse
11:59:48 <fasta> One would think that should work...
11:59:55 <ihope> Wait...
11:59:56 <Igloo> You need to have \" at either end and no other \"s in it
12:00:21 <ihope> Um...
12:00:38 <fasta> Igloo: show please
12:00:49 <ihope> Unless each \" is escaped by a \\? :-)
12:01:02 <Igloo> Right, then it isn't a \" because it's escaped  :-)
12:01:07 <ihope> > read "\"string: \"<?xml version=\\\"1.0\\\"\"" :: String
12:01:08 <lambdabot>  Exception: Prelude.read: no parse
12:01:14 <Igloo> fasta: Do   shot the_string_you_want
12:01:14 <fasta> Igloo: we were way ahead of you ;)
12:01:19 <ihope> > read "\"string: \\\"<?xml version=\\\"1.0\\\"\"" :: String
12:01:20 <lambdabot>  "string: \"<?xml version=\"1.0\""
12:01:33 <Igloo> s/shot/show/
12:01:46 <fasta> Igloo: you mean with my non-existing shot gun of Hell?
12:02:34 <fasta> ihope: what did you do?
12:03:03 <fasta> ihope: Oh, I see.
12:03:14 <ihope> I stuck \" on the end and replaced a \" with a \\\".
12:03:43 <fasta> But this is what comes out of readFile
12:04:02 <fasta> That seems pretty bad to me?
12:10:17 <fasta> read ""::String doesn't work on my local machine.
12:11:04 <int-e> > read "\"\"" :: String
12:11:05 <lambdabot>  ""
12:11:22 <int-e> > id ""
12:11:23 <lambdabot>  ""
12:11:25 <int-e> > ""
12:11:26 <lambdabot>  ""
12:12:01 <fasta> int-e: ok
12:14:48 <ihope> > :: String
12:14:48 <lambdabot>  Parse error
12:14:52 <ihope> :-)
12:18:44 <fasta> It seems to be doing something finally :)
12:21:05 <xerox> > read (show "")
12:21:06 <lambdabot>  Add a type signature
12:21:11 <xerox> > read (show "") :: String
12:21:12 <lambdabot>  ""
12:29:52 <dmhouse> Ich bin in Deutschland!
12:32:03 * dmhouse observes how little the channel cares
12:32:19 <Wallbraker> :-)
12:32:31 <BCoppens> Ich bin nicht in Deutschland!
12:32:54 <Cale> Oh, we care, we just don't show it very well.
12:33:54 <dmhouse> Cale, aww, thanks. :)
12:36:46 <dmhouse> So how is the #haskell community at large?
12:37:27 <ihope> So that string was "\"string: \"<?xml version=\\\"1.0\\\""...
12:37:52 <ihope> That is, "string: "<?xml version=\"1.0\".
12:38:06 <ihope> And "string: "<?xml version=\"1.0\" isn't a valid string.
12:44:05 <mathewm> can I make GHCi tell me about functions that aren't exported by the owning module?
12:46:29 <dmhouse> mathewm: If you interpret that module, yes.
12:46:29 <dmhouse> You can do that by doing ':m *Foo' (notice the asterisk).
12:46:33 <dmhouse> But you'll need the sources around.
12:46:50 <mathewm> thanks
12:46:58 <ihope> Without the sources, do the functions that aren't exported even exist?
12:47:10 <dmhouse> (Obviously. If you just have the .hi file then GHCi can't find out about the hidden functions.)
12:47:16 <dmhouse> ihope, in a weird kind of way, yes.
12:47:34 <dmhouse> E.g. module Foo (bar) where foo = 5; bar = foo + 1
12:47:42 <dmhouse> foo still exists, fsov 'exists'.
12:47:45 <dmhouse> *fsvo
12:48:29 <ihope> fsvo?
12:49:00 <dmhouse> For some value of. It depends on your definition of 'exists'.
12:49:43 <ihope> Ah. So "exists exists. exists" :-P
12:50:29 <dmhouse> More exists valueOfExists. valueOfExists foo
12:54:10 <dmhouse> G'night all.
14:19:38 <zeeeee> hi all, anybody know if/how i can get vim to auto indent my haskell files?
14:23:10 <cjay> zeeeee: afaik there is no way at the moment. dons has written an indent file, but it still needs work (doesn't work at all for me) -> ftp://ftp.cse.unsw.edu.au/pub/users/dons/vim/indent/haskell.vim
14:23:58 <zeeeee> cjay: ok, thanks
14:24:55 <cjay> maybe you can make it work :)
14:28:14 <Janni> Hello.
14:28:29 <|Steve|> Hi.
14:30:05 <Nanar> hi
14:30:18 <Nanar> I am trying to build haskelldb
14:30:25 <Nanar> but I get this:
14:30:26 <Nanar> Setup.hs: cannot satisfy dependency plugins-any
14:30:38 <Nanar> any idea where to find this ?
14:33:30 <Lemmih> @where hs-plugins
14:33:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:33:47 <Nanar> thanks lambdabot ;)
14:33:48 <Lemmih> Haskelldb uses hs-plugins now. Jikes.
14:33:54 <Nanar> thx Lemmih 
14:34:47 <Nanar> btw: I want to make a rpm of haskelldb, will be hard, it need installation of some lib before building the rest :\
14:42:25 <zeeeee> hmm...i'm trying out the haskell mode for emacs, and it gives me coloring, but it doesn't seem to be auto-indenting, and indent-region produces an incorrect indentation. anybody know if i'm missing something or if this emacs mode simply fails to indent (like the one for vim)? (i got it from http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Emacs)
14:42:26 <lambdabot> Title: "Libraries and tools/Program development - HaskellWiki"
14:48:16 <zeeeee> hmm...i guess my search for a haskell indenter is as futile as that of a python indenter due to scoping-by-indentation
14:56:10 <esap> In category theory, does the "collection" of natural transformations between functors F and G satisfy the definition of a functor?
14:57:20 <Cale> esap: in what sense?
14:58:30 <esap> Cale: well, say, if the collection is denoted {F,G}, then set {F,G}(A) = FA -> GA and {F,G}(f) = naturality : {F,G}(A) -> {F,G}(B)
14:58:31 <Cale> If you have a single category C, you can look at the category of endofunctors on C, with the natural transformations as arrows.
14:58:44 <Dino_> I'm having trouble sending output of readFile to lines without using do notation.
14:59:07 <Cale> readFile "filename" >>= return . lines
14:59:08 <Cale> ?
14:59:21 <Cale> or  fmap lines (readFile "filename")
14:59:27 <Cale> esap: hmm
14:59:48 <Dino_> Huh, I didn't think the return in there because that turns it into an IO [String]
15:00:08 <Cale> Dino_: well, it has to be :)
15:00:10 <Dino_> But definitely (readFile "foo") >>= lines doesn't work.
15:00:31 <Cale> esap: which category is that?
15:00:32 <Dino_> But lines :: String -> [String]  NOT IO String -> IO [String]
15:00:49 <Cale> esap: I mean the image of {F,G}
15:00:55 * Dino_ Still struggling.
15:01:04 <Cale> Dino_: fmap :: (a -> b) -> (f a -> f b)
15:01:11 <Cale> (where f is a functor)
15:01:30 <Dino_> Huh, haven't read anything about functors yet.
15:01:41 <Janni> Cale: Stop confusing him with functors.
15:01:44 <Cale> All monads are also functors
15:01:59 <esap> Cale: {F,G} : C -> D, where F, G : C -> D
15:02:51 <esap> Cale: actually, hmm.. maybe that needs some new category
15:03:03 <Dino_> So, the 'return . lines' means do the return after lines has its way with the data. Perhaps it was fine to >>= lines but the ultimate output was wrong from lines.
15:03:32 <astrolabe> I think you can see natural transformations as morphisms of Functors.
15:03:33 <Dino_> Anyway, thanks.
15:03:57 <Cale> by {F,G}(A) = FA -> GA, you mean that {F,G}(A) = Mor(FA, GA) ?
15:04:04 <esap> Cale: I mean, a category whose objects are Hom-set of form FA -> GA and whose arrows are naturality diagrams.
15:04:15 <esap> Cale: yes.
15:04:24 <Cale> hmm
15:05:39 <Cale> yeah
15:06:00 <Cale> Hom(-,-) is a bifunctor from C x C to Set
15:06:22 <Cale> It's contravariant in the first parameter and covariant in the second
15:06:52 <Cale> hmm
15:07:03 <Cale> that's not quite what we're talking about :)
15:07:28 <Cale> but almost...
15:08:33 <astrolabe> I'm not clear what esap means.
15:09:25 <astrolabe> We have catefories C and D
15:09:38 <astrolabe> and functors F,G: C->D
15:09:43 <esap> yes
15:10:06 <Cale> then {F,G}(A) = Hom(FA,GA)
15:10:28 <esap> yes
15:10:39 <astrolabe> What is {F,G}?
15:10:52 <esap> {F,G} is a functor I'm defining
15:11:02 <astrolabe> right
15:11:18 <astrolabe> from C into which category?
15:11:38 <Cale> and {F,G} on maps sends a function A -> B to an arrow Hom(FA,GA) -> Hom(FB,GB) given by the naturality diagram
15:11:51 <esap> Into a category of Hom-sets of form FA -> GA and naturality diagrams
15:11:53 <Cale> for some natural transformation F -> G
15:12:17 <Cale> hmm
15:12:39 <Cale> but such a diagram would have to exist...
15:13:01 <astrolabe> So the objects are sets Hom(FA,GA) for A <- C
15:13:13 <Cale> So we're only considering the {F,G} pairs where there is a natural map F -> G
15:13:43 <astrolabe> What are the morphisms?
15:13:59 <Cale> astrolabe: natural transformation squares
15:14:37 <Cale> really, this is a little improper...
15:14:51 <Cale> It should be something like {F,G,η}
15:15:02 <Cale> where we actually specify the natural map we're talking about
15:15:19 <esap> I'm thinking of {F,G} as a "collection" of natural transformations
15:15:39 <Cale> er
15:15:46 <esap> Except that I think it's a functor :-)
15:15:53 <Cale> I thought it was the hom set?
15:16:00 <Cale> er, I suppose the hom set functor
15:16:20 <Cale> sort of :)
15:16:40 <Cale> It's sort of a pre-composed version of the Hom functor.
15:16:51 <esap> what do you mean by pre-composed?
15:17:08 * joelr1 waves
15:17:13 <joelr1> has anyone used parsec?
15:17:16 <Cale> I mean, you're applying F and G to the parameter before applying the ordinary Hom functor
15:17:33 <cjay> zeeeee: tab should cycle between different indentation levels, if it doesn't work then it's a configuration issue. but don't ask me how to do it, I'm not an emacs expert.
15:17:43 <Cale> So it's like  Hom . first F . second G
15:17:50 <Cale> if you know what I mean
15:17:59 <esap> Cale: right, but {F,G}(A) = Hom(FA, GA) , so in {F,G} the A is not yet there.
15:18:09 <Cale> right
15:18:16 <Cale> I'm talking about what it does to an object
15:19:41 <esap> The thing is, there is pretty standard way of building [C,D] (the functor category, which denotes a collection of functors between categories C and D) from two categories C and D. I'm thinking of similar construction, but for functors.
15:20:28 <esap> .. instead of categories.
15:21:44 <esap> So {F,G} would denote a collection of natural transformations between F and G. Clearly, naturality would need to be generated by the construction.
15:22:42 <Cale> okay
15:22:48 <esap> The problem I see is that how do I figure out whether specific natural transformations exist or not?
15:22:52 <Cale> So it's just Hom(F,G) then
15:23:01 <Cale> in the functor category
15:23:19 <esap> hmm. ah true.
15:24:52 <esap> Actually, I suppose it's the exponential object in the functor category.
15:27:02 <Cale> Well, I was thinking of it as an object in Set
15:27:21 <Cale> you can't really assume exponential objects exist
15:27:32 <Cale> Well, you can
15:27:45 <Cale> but you don't necessarily have to :)
15:28:15 <esap> What kind of constraints are there for assuming that exponentials exist in functor categories?
15:29:52 <Cale> hmm, binary products of functors would have to exist
15:31:01 <esap> hmm.. right. (F /\ G)(A) = FA /\ GA,  (F /\ G)(f) = <Ff,Gf> ?
15:31:34 <Cale> that would do
15:31:51 <Cale> so if binary products exist in the target category, you're okay
15:34:58 <Cale> hmm
15:35:10 <esap> There is no need to assume anything about what kind of natural transformations exist?
15:35:27 <Cale> well, depends
15:36:04 <Cale> I'm still a little unclear about what the objects and arrows really are, given that you started talking about sets of natural maps
15:37:20 <esap> cale: I don't really mean sets. I think it's a functor. But it looks like all natural transformations between two functors.
15:38:27 <esap> cale: Exponential objects are often motivated by describing them as "sets of functions".
15:39:01 <esap> cale: or somehow representing the whole set of arrows between two objects.
15:39:25 <Cale> yeah, provided that there's a specific object in the category which "represents" that
15:39:27 <esap> cale: That is the basis why I described {F,G} as "set" of natural transformations
15:39:35 <Cale> okay
15:40:18 <esap> cale: but of course, since objects of functor category are functors, {F,G} is also a functor.
15:42:46 <Cale> hmm
15:44:02 <Cale> ah
15:44:07 <Cale> I see what you're looking at
15:45:37 <lisppaste2> LordBrain pasted "Simple Network program" at http://paste.lisp.org/display/21972
15:45:44 <Cale> you might even want to try considering all the infranatural transformations which make the diagram commute
15:45:58 <esap> Cale: infranatural?
15:46:15 <Cale> that is, just families of morphisms η_X: FX -> GX
15:46:35 <Cale> without the explicit condition that they be natural already
15:46:58 <Cale> That would give you maps which were "locally natural" in some sense
15:47:49 <Cale> LordBrain: don't ever call hClose on a handle which you've passed to hGetContents
15:47:56 <esap> I'm thinking that I can generate the naturality condition from the construction of [C,D] and {F,G}.
15:48:05 <LordBrain> ok Cale
15:48:06 <Cale> (unless you're really certain that you want to close it)
15:48:12 <LordBrain> but thats not the only problem..
15:48:22 <LordBrain> i dont think
15:48:32 <LordBrain> it wasnt working even before i put that hClose on
15:48:54 <Cale> esap: It's a little boring to just consider natural maps, because they always make the square commute already
15:49:19 <esap> Cale: heh, true.
15:49:19 <Cale> esap: So the arrows between any two objects would always look the same, for fixed F and G
15:50:01 <LordBrain> the last thing it does is echo the "Displaying on screen..." to the standard out and then it sits there frozen until i control-C
15:50:15 <LordBrain> it behaves the same way without the hClose
15:50:26 <Cale> LordBrain: do you receive anything on the handle?
15:50:45 <LordBrain> when i use netcat, i get the contents of the webpage
15:50:53 <Cale> maybe try hPutStrLn instead of hPutStr?
15:51:06 <LordBrain> oh, actually i had it with that at first too
15:51:30 <LordBrain> aaaaaah
15:51:31 <Cale> with LineBuffering on, you're currently not sending anything at all to the server
15:51:44 <esap> Cale: That's actually a very good point, I've been implicitly assuming that I've got a collection of natural transformations.
15:51:46 <LordBrain> you're right..
15:52:02 <LordBrain> it works now, i could sweaar i tried this... 
15:52:18 <LordBrain> anyway, do i really need the LineBuffering?
15:52:48 <LordBrain> hmmmmm
15:52:51 <LordBrain> it seems i do
15:53:58 <LordBrain> hmmm hFlush after the hPutStrLn alleviates that need tho.. :) ok
15:54:03 <LordBrain> thanks for the help Cale
15:55:10 <Cale> LordBrain: no problem
15:55:35 <Cale> LordBrain: I usually just set NoBuffering for convenience ;)
15:55:57 <Cale> well, for things like that anyway
15:56:10 <Cale> it's incredily inconvenient to set it on stdin of course :)
15:57:29 <LordBrain> *nods
16:29:41 <dons> moin
16:30:03 <Pseudonym> G'day.
16:49:08 <dons> kfish is hanging out here now?
16:49:34 <dons> more haskell converts. goody goody
16:50:51 <araujo> hello there
16:51:38 <dons> morning araujo 
16:53:03 <araujo> hello dons , how you doing?
16:53:32 <dons> ok. busy time of the year it seems.
16:59:43 <dfeuer> Grr...  I have a silly question I've asked on #scheme and #algos without success.
17:00:34 <dfeuer> What's the best performance possible for a function that takes a list and returns the list as a sorted stream (so the sorting is incremental)?
17:01:21 <dfeuer> I know it's possible to do it in O(n + k log n) time, where k is the number of elements forced, and I know it's impossible to do it in better than O(n + k log k) time.
17:02:07 <dfeuer> Also, I've come up with an algorithm using a variant of binomial heaps that appears to do better than O(n + k log n), but I don't know how to pin down its bounds.
17:02:10 <dfeuer> Can someone help?
17:03:43 <dfeuer> whoa.....  I think IRC died today.
17:04:15 <dfeuer> PING!
17:17:50 <Pseudonym> dfeuer: Good question.
17:18:12 <Pseudonym> "Best performance possible" is always a difficult thing to get a handle on.
17:18:35 <Pseudonym> I think it's actually O(n + n log k)
17:19:00 <Pseudonym> Errr...
17:19:04 <Pseudonym> O(k + n log k)
17:19:14 <Pseudonym> where n is the number of items in the list and k is the number of items you want.
17:19:21 <Pseudonym> Hmmm.
17:19:30 <Pseudonym> I think I just swapped k and n compared with youi
17:19:32 <Pseudonym> Anyway.
17:19:54 <Pseudonym> Either quick sort or heap sort will do the trick.
17:20:17 <dfeuer> I think it's possible to do better.
17:20:27 <Pseudonym> Or top-down merge sort.
17:20:40 <dfeuer> Are you familiar with binomial heaps?
17:20:41 <Pseudonym> I think top-down merge sort is probably what you want in Haskell.
17:20:49 <Pseudonym> Err... a bit.
17:21:15 <dfeuer> Well, consider using optimal priority queues to hold the children of each node.
17:21:28 <Pseudonym> Yeah, that's heap sort.
17:21:31 <dfeuer> Stick all n items into the priority queue.
17:21:34 <dfeuer> 1 sec!
17:21:52 <dfeuer> Then stick all the trees into a new priority queue.
17:22:29 <Pseudonym> Sorry?
17:22:41 <dfeuer> I _think_ this starts out much better than (n+k log n) and degrades smoothly to (n+k log n) as k approaches n.
17:23:05 <dfeuer> Inserting all the trees that make up the binomial heap into a priority queue takes O(log n) time.
17:23:42 <dfeuer> Deleting the first element of the queue takes O(log (log n)) time, I believe.
17:24:06 <dfeuer> And then the second one takes something like O(log (log n + log (log n)))
17:24:08 <dfeuer> Or so.
17:24:18 <dfeuer> oh.
17:24:21 <dfeuer> I skipped a step.
17:24:24 <dfeuer> hee hee.
17:24:42 <dfeuer> To remove the first k elements, extract the minimal tree from the top-level pqueue.  
17:24:45 <Pseudonym> OK, first comment.
17:24:55 <dfeuer> ?
17:24:59 <Pseudonym> If you have a bunch of heap-ordered trees, you don't need to store them in a priority queue.
17:25:10 <Pseudonym> All you need to do is get the elements out in sorted order.
17:25:17 <Pseudonym> It's sufficient to do a lazy top-down merge.
17:25:27 <dfeuer> how do you store them?
17:25:56 <Pseudonym> Haskell is lazy.  You don't need to store them.  You just make a tree of merge operations.
17:27:11 <int-e> in fact you can just use the builtin sort.
17:27:15 <Pseudonym> Secondly, binomial heaps aren't necessarily optimal in a constant-factor sense.
17:27:36 <Pseudonym> This is especially true if you don't need all of the operations that binomial trees provide.
17:27:37 <Pseudonym> Like meld.
17:27:53 <dfeuer> The way I was going to do it seems quite different....  It extracts the first tree from the top-level pqueue, calls that the first element, then merges its pqueue of children with the top-level pqueue.
17:28:07 <dfeuer> Which is an O(1) merge.
17:28:22 <int-e> (that's for a simple tree of merges - which should be O(n+k log n))
17:28:25 <dfeuer> Pseudonym, I don't care about constant factors at the moment.
17:28:41 <dfeuer> int-e, I'm trying to do better than that.
17:29:43 <dfeuer> In my algorithm, the top-level pqueue [likely] grows as time goes on, degrading performance, but never dropping below O(n+k log n).  
17:29:50 <dfeuer> But for small k, it should do much better, I think.
17:30:09 <dfeuer> (I mean k small relative to n, not absolutely small)
17:30:45 <int-e> Uh, how is O(n+k log n) better than O(n+k log n)?
17:30:46 <dfeuer> Or am I totally delusional?
17:31:21 <dfeuer> What I mean is that I believe the algorithm I gave has a tighter bound than that.
17:32:26 <dfeuer> i.e., that it behaves much better for relatively small k than that would suggest.
17:32:48 <int-e> hmm, for small k it's O(n) anyway.
17:34:04 <dfeuer> Once k gets to be more than around 5, that starts to go wonky, no?
17:34:26 * dfeuer is trying to specify exactly what he means.
17:34:28 <int-e> k = O(n / log n) works (not surprisingly)
17:34:52 <int-e> I.e.if k = O(n / log n) then O(n + k log n) = O(n).
17:34:56 <Pseudonym> I still don't see why this is going to be more efficient than a simple top-down merge.
17:35:14 <dfeuer> I don't know that it will, in reality.
17:35:19 <Pseudonym> A top-down merge effectively IS a priority queue.
17:35:26 <int-e> Pseudonym: me neither. I'm just trying to explain that constant factors will matter a lot for small k.
17:35:26 <Pseudonym> It's just one that doesn't support insertion.
17:35:30 <dfeuer> How does a top-down merge behave for k = 1 or 2 or 3?
17:35:32 <Pseudonym> Right.
17:36:02 <Pseudonym> dfeuer: Basically, for k = 1, you have a tree of streams.
17:36:17 <Pseudonym> Each node compares its two children and passes the smaller up the tree.
17:36:22 <Pseudonym> At the top, you pull one out.
17:36:31 <Pseudonym> So it's O(n).
17:36:34 <int-e> it's O(n) for the first element and O(log n) for every following element, because it's basically a binary heap
17:37:06 <int-e> (by which I mean a binary tree used as a heap - what's the proper name for that?)
17:37:08 <dfeuer> I'm not quite seeing.  Can you describe the whole algorithm?
17:37:25 <dfeuer> int-e, a heap-ordered binary tree?
17:37:28 <int-e> can you access the library sources? it implements a very nice merge sort
17:38:24 <dfeuer> ummm....  probably.... with much digging...
17:39:05 <Pseudonym> int-e: I believe that the built-in merge sort is bottom-up.
17:39:17 <lisppaste2> int-e pasted "mergesort (from Data.List)" at http://paste.lisp.org/display/21974
17:39:48 <int-e> Pseudonym: look what lazy evaluation does to that
17:40:09 <dfeuer> What's wrap do?
17:40:28 <int-e> wrap x = [x]
17:40:48 <Pseudonym> Ah, right.
17:41:53 <int-e> it really comes down to building a heap and removing elements at the top. the internal nodes are unevaluated merge thunks.
17:42:50 <Pseudonym> In fact, you can do it slightly smarter than that, too.
17:43:05 <Pseudonym> By building your runs a bit more intelligently.
17:43:27 <Pseudonym> You can sort a sorted list in O(n) time.
17:44:20 * dfeuer stares at the code and wonders how he could possibly analyze its running time.
17:44:33 <int-e> oh you mean you can wrap chunks that are already ordered correctly.
17:44:49 <int-e> instead of singletons.
17:45:36 <Pseudonym> Yeah.
17:46:19 <dfeuer> I am very, very slowly starting to understand.
17:46:52 <dons> hmm,  International Conference: Tests And Proofs, interesting. http://tap.ethz.ch/
17:47:18 <dons> bjp cites quickcheck as one of the few tools for the convergence of tests and proofs. 
17:47:50 <dfeuer> int-e, you say it's O(log n) for every element but the first.  If that bound is tight, I don't think it's optimal.
17:48:56 <lisppaste2> Pseudonym pasted "Extract runs" at http://paste.lisp.org/display/21977
17:49:09 <Pseudonym> That's the best run extractor I've seen so far.
17:49:09 <int-e> sure you can speed up the process if you spend extra work on balancing the tree
17:49:37 <dfeuer> ...?
17:51:13 <dfeuer> int-e, what do you mean?
17:52:44 <int-e> dfeuer: I'm trying to understand in which sense that bound isn't the best possible.
17:52:59 <dfeuer> int-e, I could be thinking incorrectly.
17:53:40 <Pseudonym> There's a really clever priority queue algorithm, I think it's by Richard O'Keefe.
17:54:06 <Pseudonym> Trying to remember the details.
17:54:16 <dfeuer> int-e, I don't think I understand big-O with more than one variable well enough.
17:55:43 <dfeuer> priority queue algorithm for what?
17:56:02 <Pseudonym> Well, it just uses plain binary trees.
17:56:12 <Pseudonym> No balance information.
17:56:17 <Pseudonym> Heap-ordering.
17:56:28 <dfeuer> is it an algorithm or a data structure?
17:56:30 <Pseudonym> It maintains balance by clever use of swapping of the left and right-hand children of the tree.
17:56:35 <Pseudonym> Well, both, really.
17:56:39 <int-e> I think the problem is that the first O(n) can hide a lot of Omega(log n) for later operations. In the end, after all n elements have been extracted, the algorithm must have used Omega(n log n) time. (O = asymptotic upper bound, Omega = asymptotic lower bound)
17:56:43 <Pseudonym> Data structure with insert/remove algorithms.
17:57:03 <dfeuer> int-e, I think I see what you're saying.
17:57:19 <dfeuer> Pseudonym, what's good about this structure? Is it fast?  Simple?  Both?
17:58:28 <dfeuer> int-e, and then once k starts to be comparable to n, log k and log n get a lot closer....
17:58:36 <Pseudonym> Both.
17:58:45 <Pseudonym> It doesn't support a fast meld, but it doesn't have to.
17:58:46 <dfeuer> i
17:58:49 <dfeuer> I'd love to see it.
17:58:53 <dfeuer> Why doesn't it have to?
17:58:54 <Pseudonym> Yeah, so would I.
17:59:04 <Pseudonym> dfeuer: For heap sort, you don't need meld.
17:59:06 <int-e> dfeuer: indeed. in fact O(n/log n) operations can be hidden and O(log (n/log n)) = O(log n)
17:59:09 <dfeuer> Well yeah.
17:59:47 <dfeuer> uhh
18:00:07 <dfeuer> is that = a subset?
18:00:16 <int-e> no, that one is actually equality
18:00:21 * dfeuer kills whatever computer scientists came up with the notation.
18:01:04 <int-e> people should just write f \in O(...)
18:01:12 <int-e> i.e. admit that the O() are sets.
18:01:17 <dfeuer> exactly.
18:01:29 <int-e> of course I'm not following my own advice ;)
18:01:49 <Pseudonym> Well, they kinda do.
18:01:53 <Pseudonym> They say "f is O(...)".
18:02:06 <dfeuer> I don't see how those two are equal.
18:02:23 <dfeuer> but I should probably study them  a bit more first.
18:02:26 <Pseudonym> "is-a" is a fairly well understood concept in computer science.
18:02:30 <dfeuer> s/probably/certainly/
18:02:36 <int-e> log (n/log n) = log n - log log n. log log n is asymptotically smaller
18:03:12 * dfeuer slaps himself on the head for mixing up his logarithm arithmetic.
18:04:15 <dfeuer> I also wish mathematicians would get their heads out of their asses and use lambda-notation, instead of horrible hacks.
18:05:19 <dfeuer> (generally, I think mathematicians have a lot to learn, notationally, from computer scientists)
18:05:30 <int-e> what would be interesting is: can you find the smallest and the second smallest element of a list with fewer than n + ld n comparisons? (ld = logarithm of base 2)
18:05:48 <dfeuer> I'd always seen that as lg.
18:07:28 <dfeuer> (or, in reality, as log, because base 2 is implied, except when it's not)
18:07:42 <int-e> http://www.swif.uniba.it/lei/foldop/foldoc.cgi?logarithmus+dualis ... well, I didn't invent that ld notation :)
18:07:44 <lambdabot> Title: "logarithmus dualis from FOLDOC"
18:07:48 <int-e> but it's not too common
18:09:04 <dfeuer> Do you think it's possible?
18:09:46 <int-e> no
18:10:03 <dfeuer> Can it be done in   n + log n?
18:10:11 <dfeuer> ( you said less than)
18:10:36 <int-e> yes that can be done
18:11:54 <dfeuer> How?
18:12:30 <int-e> do a knock-out tournament and determine a winner (the maximum element), then find the maximum element of all elements that lost against the winner. There are up to [ld(n)] ([x] = x rounded up) of these, for a total of n - 1 + [ld(n)] - 1 comparisons.
18:14:42 <dfeuer> I see, I think.
18:14:50 <dfeuer> yah.
18:18:33 <dfeuer> Does that extend well/at all?
18:18:51 <dfeuer> hmmm.... would have to look at everything that lost to the first _or_ second....
18:19:01 <dfeuer> meh.
18:20:07 <int-e> it extends well although the analysis becomes more complicated - it's really just a heap again.
18:22:30 <int-e> The tournament relationship is nice though because most people actually understand how that works.
18:23:07 <dfeuer> It looks a lot like bottom-up mergesort.
18:23:17 <dfeuer> except not doing the merges.
18:23:17 <int-e> yep :)
18:54:49 <DukeDave> > id 1
18:54:50 <lambdabot>  1
18:54:54 <DukeDave> right, 
18:55:30 <DukeDave> > foldr1 (-) [3,2,1]
18:55:31 <lambdabot>  2
18:55:40 <DukeDave> > foldr1 (-) [3..1]
18:55:42 <lambdabot>  Exception: Prelude.foldr1: empty list
18:55:47 <dons> ah, thanks be to the gods of lambda calculus -- id is still the identity.
18:55:58 <dons> :)
18:56:07 <DukeDave> can I request a sanity check on those last two statements? :)
18:56:45 <DukeDave> ah, is it constructing the range as  3:2:1:[]
18:57:16 <mathewm> > [3..1]
18:57:17 <lambdabot>  []
18:57:24 <mathewm> > [3,-1..1]
18:57:25 <lambdabot>  [3]
18:57:30 <mathewm> > [3,2..1]
18:57:31 <lambdabot>  [3,2,1]
18:57:42 <DukeDave> >[1..3]
18:57:47 <mathewm> > foldr1 (-) [4,3..1]
18:57:48 <lambdabot>  2
18:58:27 <DukeDave> probably should have checked that
18:58:29 <DukeDave> :)
18:59:12 <mathewm> haskell is an optimistic language, evidently - assumes steps must be positive ;)
18:59:23 <DukeDave> heh, cute :)
19:01:17 <dfeuer> I'm confused.
19:01:25 <dfeuer> I forget the .. notation.
19:01:45 <dfeuer> > [2, 3 .. 10]
19:01:46 <lambdabot>  [2,3,4,5,6,7,8,9,10]
19:01:59 <dfeuer> [10, 9, .. 5]
19:02:05 <dfeuer> >10, 9, .. 5]
19:02:14 <dfeuer> > [10, 9, .. 5]
19:02:14 <lambdabot>  Parse error
19:02:19 <dfeuer> > [10, 9 .. 5]
19:02:20 <lambdabot>  [10,9,8,7,6,5]
19:02:32 <dfeuer> [10,9..11]
19:02:37 <dfeuer> > [10,9..11]
19:02:38 <lambdabot>  []
19:02:42 <dfeuer> mm
19:02:44 <dfeuer> I see
19:02:55 <dfeuer> Maybe.
19:03:11 <dfeuer> [10,9,11.. 15]
19:03:16 <dfeuer> > [10,9,11.. 15]
19:03:16 <lambdabot>  Parse error
19:03:22 <dfeuer> > [10,9,11..15]
19:03:22 <lambdabot>  Parse error
19:03:25 <dfeuer> > [10,9,11 .. 15]
19:03:25 <lambdabot>  Parse error
19:03:33 <dfeuer> Huhh...
19:03:44 * dfeuer fwaps lambdabot 
19:04:50 <DukeDave> ooh, a just thought of a new back-ronym:    Parse = people are really syntactically erroneous  :)
19:06:24 <lorne> [a, b .. c] = enumFromThenTo a b c, iirc
19:08:39 <alec> > [10,9,11,10,12,11..15]
19:08:39 <lambdabot>  Parse error
19:09:07 <alec> oh well, worth a shot
19:18:15 <mathewm> [ n (,n)? .. n ]
19:19:30 <mathewm> oops, looks like the last one is optional too
19:19:35 <mathewm> [ n (,n)? .. n? ]
19:19:45 <mathewm> [10..]
19:19:49 <mathewm> >[10..]
19:19:58 <mathewm> > [10..]
19:19:59 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
19:20:08 <mathewm> > [10,100..]
19:20:09 <lambdabot>  [10,100,190,280,370,460,550,640,730,820,910,1000,1090,1180,1270,1360,1450,15...
19:30:13 <Cale> > [10,100,11]
19:30:14 <lambdabot>  [10,100,11]
19:30:16 <Cale> > [10,100..11]
19:30:17 <lambdabot>  [10]
19:30:27 <Cale> > [10,100..95]
19:30:28 <lambdabot>  [10]
19:30:34 <Cale> > [10.0,100.0..95.0]
19:30:35 <lambdabot>  [10.0,100.0]
19:30:45 <Cale> > [10.0,100.0..5.0]
19:30:45 <lambdabot>  [10.0]
20:18:50 <dons> This week's Weekly News, out now, http://sequence.complete.org/
20:24:16 * Lemmih hurries to a get a copy before they run out of bits.
20:34:13 <roods> what does "nullary data constructors" mean.
20:35:41 <dons> data X
20:35:41 <dons> you have
20:35:44 <dons>  no values of a type
20:36:01 <dons> but the type itself is useful for type hackery
20:36:14 <roods> like an enum.
20:37:29 <dons> i.e. data D0, data D1 .. data D9 -- used to represent decimals on the type level
20:37:42 <skew> nullary data constructor is a constructor that takes no arguments
20:37:59 <audreyt> they are just for people who don't want to use runIO to run programs at compile time ;)
20:38:03 <dons> no, not like an enum. (unless you mean something different to what I think)
20:38:35 <audreyt> (and want instead to encode the said programs so the typecheckr runs it for them.)
20:38:37 <dons> oh, I'm thinking of empty data decls. skew's right
20:38:38 <skew> data types with no constructors are different from a nullary constructor of some data type
20:38:58 <dons> yep, my mistake
20:39:07 <Pseudonym> Either way, the main point of their existence is that to do otherwise would be an arbitrary restriction.
20:39:10 <skew> nullary is just like True or False in data Bool = True | False
20:39:53 <skew> nullary, unary, binary - it's just counting
20:41:20 <dons> yeah, i was thinking of "empty data declarations"
20:41:21 <roods> okay thanks.
20:42:54 <dons> which sounds almost like "nulary data constructors" :S, almost. i.e. nullary types. http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#nullary-types
20:42:56 <lambdabot> Title: "7.4. Type system extensions"
21:32:14 <jgp> hi all
21:32:44 <jgp> i'm wanting to write a helper function that takes two integers, divides them, and returns a double
21:32:55 <jgp> i get type errors if i use /
21:33:02 <Cale> jgp: fromIntegral
21:33:39 <wli> x `myDiv` y = fromIntegral x / fromIntegral y
21:33:55 <Cale> fromIntegral will convert numbers from any integral type (Int, Integer, Int8, Word8, Word16, etc.) to any numeric type at all.
21:34:10 <Cale> @type fromIntegral
21:34:12 <lambdabot> forall b a. (Num b, Integral a) => a -> b
21:35:29 <Cale> @type let x `myDiv` y = fromIntegral x / fromIntegral y in myDiv
21:35:30 <lambdabot> forall a a1 b. (Integral a, Fractional b, Integral a1) => a -> a1 -> b
21:36:57 <jgp> sweetness
21:38:07 <jgp> sorry for the noob question... trying to learn some haskell for the fun of it... nice relief from work related stuff...  but we only brushed over it in school
21:38:19 <Cale> :)
21:38:35 <Cale> no problem, it's mostly what we're here for :)
21:39:07 <jgp> haha
21:40:53 <wli> jgp: write a compiler for a toy language... FP languages are really good for that and it's a big enough project to build familiarity with one shot
21:41:19 <wli> (don't worry about code quality, either -- just turn IR ops into assembly macros)
21:41:43 <Cale> Or just an interpreter :)
21:42:34 <dons> yeah, an interpreter is a good intro task. we use it in a course here.
21:42:34 <dons> for a mini-haskell language
21:42:38 * wli isn't a fan of the "I'm wimping out on compilation so I'm writing an interpreter" tactic. Spewing forth assembly is good.
21:42:53 <wli> No matter how crappy the assembly.
21:43:16 <Cale> yeah, but then you have to care about assembly
21:43:57 <wli> Knowing assembly is good.
21:44:25 <wli> (of course, to get things done fast interpretation is a worthy shortcut)
21:44:56 <jgp> yeah...  i've had that experience with scheme...  compiler class at indiana university is pretty good
21:45:50 <jgp> although it would be a good idea to have to do it all on my own
21:46:28 <Cale> Especially if you're on an intel machine, you'll have to deal with annoying stuff just to get basic functionality. I'd rather at least use C as a target language
21:46:38 <jgp> much different than having templates handed to you by a prof and only having to fill in a few interesting holes
21:47:28 <Cale> Or compile to some nicer assembly language for which there is an interpreter handy, but at that point, you begin to wonder why you didn't just write an interpreter in the first place :)
21:48:14 <wli> Cale: That's usually called "C"
21:48:42 <jsherlock> sounds like the argument for C--
21:49:11 <wli> jsherlock: C-- would be better for such purposes yes.
21:49:15 <Cale> wli: I was thinking of how we wrote compilers which compiled to DLX in the baby compilers course I took.
21:49:37 <wli> Cale: DLX... man that was a foul machine.
21:49:57 <Cale> It's an extremely simple machine though
21:50:21 <wli> Cale: Didn't have that assignment or anything but it was just butt-ugly. I much preferred the R2K -centric materials.
21:51:02 <wli> (the emphasis there was on the hardware end but I later had compilation to R2K asm)
22:10:38 <psykotic> DLX is awesome
22:10:44 <psykotic> even simpler than MIPS, what's not to like
22:10:45 * araujo wonders if it is worthy to choose a specific language for the base system of a distro
22:11:43 <wli> addressing modes yuck
22:12:52 <psykotic> didn't DLX (like MIPS) just have two?
22:13:01 <psykotic> register and register(offset)
22:13:03 * araujo wishes these freespires guys were more open with the distro
22:15:30 <Pseudonym> I wonder if DLX would make a good JIT bytecode format.
22:15:55 <Azmo> if a program consists of several modules, and is compiled with GHC using static linking, then will these modules be optimized after being put together, or will the program be less efficient than if written in a single module?
22:16:46 <dons> ghc does cross module optimisations, via .hi files
22:17:38 <dons> (.hi files contain unfolded defns of .hs code, when compiled with 0O)
22:17:38 <dons> so no, it won't be less efficient
22:18:02 <Azmo> hm.. ok. guess my problem is something else then :]
22:19:36 <dons> -O, I mean. just use profiling to pinpoint your problem?
22:20:51 <Azmo> never used that. trying to find out how. some command line option i suppose?
22:29:20 <skew> Azmo: does the program actually work better if you put everything in one big module?
22:32:53 <skew> jgp, Cale, dons: Staging seems like an interesting compromise between interpreters and compiler. I've been reading about it a bit since I saw the idea in Tim Sheard's work
22:33:52 <Azmo> the structure would be terrible, i probably have like 20-25 modules. some are quite small. in some cases i use them to wrap structures, such that i can import them and access the fields with any module prefix i want by using the 'as' when importing, which makes it convenient to work with whatever set of structures i need.
22:34:57 <skew> do you have any reason to suspect module boundaries are making things slow?
22:35:31 <Azmo> not really, just guessing. trying to get the profiling thing working now.
22:36:32 <skew> Ok, probably not a big deal then. There's a tool somewhere for flattening Haskell programs, which might help testing if module boundaries are a problem, and tons for flags/pragmas GHC supports for tweaking what makes it into .hi files
22:38:24 <Azmo> ok. thanks :]
22:43:40 <Azmo> lol. i usually just run the program in the interpreter, where GHC/GHCI could end up using as much as 200 meg. i had compiled it before, and it seemed a bit slow then, but now it takes less than 3 meg of memory and seems quite quick :]
22:44:48 <Azmo> which is quite good for my program. it does a simple disassembly ping.exe on win2k.
23:31:46 <jargonjustin> Any idea why this gives a type error? zipSum = map (uncurry (+)) . zip
23:33:17 <jargonjustin> It works fine when written as: zipSum x y = map (uncurry (+)) $ zip x y
23:34:33 <Cale> jargonjustin: well, look at the type of zip and the type of map (uncurry (+))
23:34:53 <Cale> also, you can write that as zipWith (+)
23:35:08 <Cale> @type map (uncurry (+))
23:35:10 <lambdabot> forall b. (Num b) => [(b, b)] -> [b]
23:35:18 <Cale> @type zip
23:35:19 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
23:35:45 <Cale> zip takes a list and produces a function from lists to lists of pairs
23:36:01 <Cale> but map (uncurry (+)) doesn't take a function
23:37:08 <Cale> @pl zipSum x y = map (uncurry (+)) (zip x y)
23:37:08 <lambdabot> zipSum = zipWith (+)
23:37:32 <Cale> hehe, clever
23:37:47 <Cale> @pl zipSum x y = map (uc (+)) (zip x y)
23:37:48 <lambdabot> zipSum = zipWith (curry (uc (+)))
23:37:50 <jargonjustin> Cale: I always seem to end up redefining existing functions/
23:37:59 <jargonjustin> Still trying to digest what you said here though.
23:38:35 <jargonjustin> So the reason it doesn't work in the first case is because I'm combining the functions?  I thought that it could be defined as such because the compiler understands that there are arguments not being applied.
23:38:46 <Cale> oh, it's the map/zip thing it's noticing and turning into zipWith
23:39:08 <Cale> Composition is just an ordinary function
23:39:10 <jargonjustin> Cale: I figured that out, I'm just trying to understand why my original one has type issues.
23:39:11 <Cale> @type (.)
23:39:13 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
23:39:37 <Cale> for it to work, we need to figure out what the types a,b, and c are
23:39:54 <jargonjustin> Cale: Oh, so because it works for some cases (the ones I need) but not all, the compiler compains?
23:40:03 <Cale> map (uncurry (+)) :: (Num a) => [(a, a)] -> [a]
23:40:41 <Cale> no, the problem is that the occurrences of b in the type of (.) aren't matching
23:40:53 <Cale> (with the parameters you're giving it)
23:40:55 <jargonjustin> And since zip :: [a] -> [b] -> [(a, b)] has the possibility of different types, that's the issue?
23:41:02 <Cale> no
23:41:17 <Cale> read zip's type as  [a] -> ([b] -> [(a, b)])
23:41:22 <Cale> so
23:41:47 <jargonjustin> :t zip == zip :: [a] -> [b] -> [(a, b)]
23:41:47 <Cale> If we write: map (uncurry (+)) . zip
23:42:33 <Cale> our 'b' (from the type of (.)) will be [(a,a)], based on the type of map (uncurry (+))
23:43:01 <Cale> but based on the type of zip, it's [s] -> [(t, s)]
23:43:21 <Cale> and functions and lists are not the same
23:43:25 <jargonjustin> Okay... I think that makes sense.
23:43:31 <Cale> so the types don't match
23:44:34 <Cale> @type map (uncurry (+)) . uncurry zip
23:44:35 <lambdabot> forall b. (Num b) => ([b], [b]) -> [b]
23:45:03 <Cale> @type curry $ map (uncurry (+)) . uncurry zip
23:45:04 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
23:45:31 <Cale> @pl curry $ map (uncurry (+)) . uncurry zip
23:45:31 <lambdabot> curry (map (uncurry (+)) . uncurry zip)
23:45:42 <Cale> aww :)
23:46:04 <Cale> anyway, zipWith (+)
23:46:25 <jargonjustin> Thanks Cale.
23:46:33 <Cale> no problem
23:50:47 <kosmikus> good morning
23:55:23 <jargonjustin> @type (.)
23:55:24 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
23:56:06 <jargonjustin> When thinking of the output as a function, that's like: (b -> c) -> (a -> b) -> (a -> c), right?
