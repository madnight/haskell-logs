00:07:25 <foxy_> @hoogle CStringLen
00:07:26 <lambdabot> Foreign.C.String.CStringLen :: type CStringLen
00:07:26 <lambdabot> Foreign.C.String.newCStringLen :: String -> IO CStringLen
00:07:26 <lambdabot> Foreign.C.String.peekCStringLen :: CStringLen -> IO String
00:25:14 <zarvok> @where djinn
00:25:14 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
00:32:57 <vincenz> re
00:33:16 <zarvok> shouldn't you be in bed or something? ;)
00:33:52 <vincenz> I'm at the office
00:34:26 <zarvok> ah
00:36:44 <vincenz> boegel: read the thesis?
00:39:29 <dons> ?karma+ int-e spotting a lambdabot bug
00:39:29 <lambdabot> int-e's karma raised to 8.
00:39:35 <boegel> vincenz: heh, no, not yet
00:39:45 <vincenz> ok
00:40:01 <zarvok> @help karma
00:40:01 <lambdabot> karma <nick>. Return a person's karma value
00:40:13 <zarvok> @karma int-e
00:40:13 <lambdabot> int-e has a karma of 8
00:44:18 <shapr> @yow !
00:44:18 <lambdabot> Yow!  Are we laid back yet?
00:44:37 <palomer> @palomer
00:44:37 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
00:44:40 <palomer> @karma palomer
00:44:40 <lambdabot> You have a karma of 5
00:45:29 <shapr> @karma
00:45:29 <lambdabot> You have a karma of 18
00:45:32 <shapr> whoa
00:45:39 <palomer> whoa.
00:46:12 <palomer> 18/5 x (karma palomer) = 5/18 x useless
00:48:20 <dons> i have a little present for you shapr
00:48:25 <dons> give me 5 mins to get it together
00:48:43 <shapr> oh?
00:48:55 * dons types furiously...
00:49:02 * shapr is certainly curious...
00:49:13 <vincenz> dons: is it the page you showed?
00:49:33 <dons> vincenz: sssh!!
00:49:38 <vincenz> shapr: we had an interesting discussion
00:49:43 <vincenz> shapr: do you use vim7?
00:49:50 <shapr> No, I use emacs, why?
00:49:53 <vincenz> oh damn
00:50:02 <vincenz> well the new vim has an omni-completion function that is context sensitive
00:50:09 <shapr> hm
00:50:12 <vincenz> if we could get this attached to a selective hoogle sometime
00:50:17 <vincenz> we could have some nice completion
00:50:21 <vincenz> based on type, imports etc...
00:50:44 * shapr waits for the dons present...
00:50:52 <vincenz> shapr: you'll love it
00:50:55 <shapr> :-)
00:50:59 <dons> perl is too slow
00:51:14 <dons> (i shouldn't say things like that)
00:51:21 <dons> this code is too slow
00:51:23 <shapr> danly: You're on wifi?
00:51:43 <vincenz> dons: you're a CS, right? Then the easiest thing is to blame the cpu
00:51:46 <vincenz> :)
00:51:56 <dons> my cpu is too slow!
00:52:01 <shapr> Mine too!
00:52:14 <shapr> btw, who can I ask about the 1000 foot view of GHC?
00:52:15 <vincenz> yeah, so is CERN's supergrid :/
00:52:16 <dons> hands up if your cpu is too slow
00:52:21 <vincenz> \o/
00:52:24 <shapr> me me!
00:52:28 <dons> me too!
00:52:40 <dons> 1000 foot view of GHC?
00:52:42 <shapr> I want to know how the chunks of GHC all talk to each other internally.
00:52:54 <dons> using monad telepathy?
00:53:07 <shapr> I've discovered that the batch process calls hsc for each file, but I have lots more questions.
00:53:09 <shapr> dons: hah!
00:53:10 <vincenz> shapr: I'd be interested in that as well
00:53:26 <vincenz> shapr: I might be able to push class aliases into ghc if I knew the basics of ghc
00:53:55 <shapr> Chak's GHC intro seems more bottom up to me, but I'll go through it again. I may have missed the top down intro.
00:54:28 <shapr> dons: You think Chilli would let me copy the GHC Commentary to a wiki?
00:54:39 <dons> sure, i'm certain he would
00:55:04 <dons> its a really good idea
00:55:15 <shapr> Cool, I'll email him.
00:55:22 <dons> since it could be filled out during the hackathon..
00:55:35 <dons> whereas its ossified (yes!) in cvs right now
00:55:58 <shapr> Oh hey, I'm no longer the northern most Haskeller! I need to update my location to point to Stockholm.
00:55:58 <dons> i'm so glad i got to use ossified in a sentence today
00:56:03 <vincenz> dons: ugh... I wish I could be at the hackathon
00:56:06 <vincenz> dons: you going?
00:56:14 <shapr> I'm glad Haskell was OSSified from Miranda...
00:56:23 <dons> i don't think so. the pacific is just to oexpensive to cross
00:56:24 <dons> hehe!
00:56:28 <vincenz> dons: yeah
00:56:33 <shapr> Maybe we can do a minor hackathon at AngloHaskell?
00:56:34 <vincenz> dons: I'm hoping for a live-feed
00:56:42 <vincenz> dons: cause I'd really like to hack on ghc a bit
00:56:46 <shapr> Too bad I don't have a laptop.
00:56:47 <vincenz> for instance class aliases
00:56:53 <dons> shapr: that's a good idea. I wonder if Roman will be there to work on ndp stuff
00:56:56 <dons> and fusion rules
00:56:57 <vincenz> shapr: you going to hackathon?
00:57:09 <dons> he's in cambridge Jul 27-Sep 2, I think
00:57:10 <shapr> Depends on whether I have money in time.
00:57:14 <shapr> Oh cool.
00:57:43 <shapr> Also, the Simons might want a warmup Hackathon to see how to organize the one with more people.
00:57:48 <vincenz> dons: you going to anglohhaskell?
00:57:59 <dons> that's even further away!!
00:58:07 <shapr> I thought dons was Oz-bound until further notice?
00:58:17 <vincenz> australipotechaskell?
00:58:18 <dons> yeah, hopefully get to the US for PADL
00:58:25 <dons> we could have .au haskell
00:58:30 <shapr> Yeah, good idea.
00:58:35 * vincenz forgot the name of that other humanoid race
00:58:43 <shapr> OzKell?
00:58:46 <shapr> hm, I dunno
00:58:48 <dons> oooh.
00:59:01 <shapr> Could you say that with the silent H?
00:59:09 <shapr> g'day GeoffSK, coming to OzKell?
00:59:13 <dons> almost done. this present takes forever to bake
00:59:28 <GeoffSK> :) yep
00:59:28 <dons> maybe my oven should be hotter
00:59:34 <shapr> GeoffSK: btw, is the SK in your name from the SKI combinators?
00:59:51 <GeoffSK> no thats far too clever for me
01:00:06 <GeoffSK> it ain't for SupaKewl either!
01:00:07 <shapr> Are you learning Haskell?
01:00:12 <GeoffSK> yep.
01:00:44 <shapr> How far have you gotten so far? Learning for a class or job?
01:01:01 <dons> close your eyes now shapr!
01:01:05 <dons> no peeking!
01:01:08 <dons> are they closed yet?
01:01:13 <vincenz> dons: wait until he /quits
01:01:13 * shapr closes
01:01:20 <dons> ok, here you go,
01:01:21 <dons> http://www.cse.unsw.edu.au/~dons/irc/
01:01:21 <lambdabot> Title: Haskell IRC Activity
01:01:23 <dons> you can open them now
01:01:29 <GeoffSK> neither, i am old (ish) - i am IT manager for a software developement house, so i like to keep learning stuiff
01:01:31 <vincenz> woooot
01:01:38 <dons> someone tell shapr to open his eyes!
01:01:43 * shapr looks
01:01:48 <shapr> oooh!
01:01:56 <shapr> dons: whoa awesome!
01:02:07 <vincenz> dons: can you tell I only started using haskell this year?
01:02:11 * shapr boings furiously
01:02:13 <dons> hehe
01:02:16 <dons> yay!
01:02:42 <shapr> This kicks butt!
01:02:59 <vincenz> woah.... in half a yaer I made up for 6 years, cause I'm ranked 7th in total
01:02:59 <vincenz> o.O
01:03:16 <dons> vincenz talks a lot :)
01:03:25 <dons> though things have got really busy in 05-06
01:03:30 <vincenz> yah
01:03:41 <dons> the curves have flattened out, the channel is active almost all the time
01:03:56 <vincenz> shapr: mind if I ask you something regarding a certain member that was banned ?
01:04:07 <vincenz> dons: globalization
01:04:17 <vincenz> we should trademark haskell by region like parma ham
01:04:42 <shapr> vincenz: Sure, ask me...
01:04:55 <GeoffSK> may be a strange question - but what timezone is it?
01:05:07 <shapr> GeoffSK: I'm oldish too, I think.
01:05:17 <shapr> I started using Haskell just over five years ago.
01:05:28 <GeoffSK> for work?
01:05:36 <dons> not sure GeoffSK. whatever channel the tunes.org site runs on
01:05:46 <vincenz> shapr: dons just mentioned me that I should ask you about hte circumstances surrounding Smerdyakov, cause he came up when we were discussing some people that had recently moved from #ocaml to #haskell, partially cause the atmosphere in #ocaml really sucks due to him
01:06:16 <GeoffSK> - dons - got ya
01:06:25 <dons> ?karma+ shapr the smerdyakov situation was handled well, it seems
01:06:25 <lambdabot> shapr's karma raised to 19.
01:06:41 <shapr> vincenz: Well, what do you want to know about the circumstances?
01:06:45 <shapr> dons: Thanks :-)
01:06:47 <vincenz> just the history
01:06:58 <vincenz> what led to this somewhat drastic action for a channel that is so open
01:07:07 <shapr> vincenz: There's the facts, and there's my opinion... which do you want? :-)
01:07:12 <vincenz> both ?
01:07:32 <vincenz> I personally don't like the guy either, he has a tendency to wingbrowbeat newbies wheneer they ask slightly ambiguous questions instead of answering the obvious case
01:07:58 <shapr> Factually speaking, Smerdyakov is a graduate student in FP, though I forget which uni.. bezerkely? Something in the US at least.
01:08:04 <dons> cmu?
01:08:06 <shapr> Ah yes
01:08:11 <vincenz> no
01:08:12 <vincenz> berkely
01:08:20 <norpan> berzerkely
01:08:23 <vincenz> typed assembly
01:08:23 <shapr> I think he used to be at CMU before.
01:08:39 <vincenz> possibly
01:08:40 <vincenz> I don't know that
01:08:49 <zarvok> Do we know his name?  I know most of the FP grad students here at CMU
01:08:53 <vincenz> just know he works at berkeley onw cause I have talked to him about some stuff
01:08:57 <shapr> Anyway, he seems to know something about FP, and he's written useful libraries for SML. Those are both two big things to his credit.
01:08:58 <vincenz> zarvok: adam chliplala
01:09:24 <vincenz> but he's at berkeley, certain of it, I talked to him about a colleague of his and a c++ parser they have at berkeley
01:09:34 <zarvok> yeah, I don't know him
01:10:03 <norpan> but here in #haskell everyone is so friendly
01:10:13 <shapr> More facts are that I'm the guy who started #haskell, so I'm the one who has to decide what to do to keep the community together.
01:10:23 <vincenz> shapr: more porn
01:10:27 <shapr> eh?
01:10:30 * vincenz shrugs
01:10:33 <vincenz> just a suggestion
01:10:35 <shapr> oh
01:10:35 <vincenz> :P
01:10:36 * shapr grins
01:10:41 <dons> freaky
01:10:53 <vincenz> hey, I'm suffering insomnia, I have an excuse for being wacky
01:11:09 <vincenz> anyways, sorry for the interrup
01:11:10 <shapr> Anyway, Smerdyakov gets on my nerves like a cheese grater on brain tissue, so I cut him a bunch of slack because I'm aware of that.
01:11:30 <dons> oh. bad mental images
01:11:35 <vincenz> 10:11am for anyone who just localtimed me
01:11:38 <shapr> Now we reach the opinion parts :-)
01:11:44 <vincenz> dons: yeah that sounds painful as hell
01:12:07 <shapr> In my opinion, Smerdyakov raised the channel temperature in general, and did not encourage newbies.
01:12:35 <shapr> Or less tactfully, winning an argument seems more important to him than learning.
01:12:55 <shapr> also imho, he seems to want to fit the facts to his conclusion rather than the other way around.
01:12:57 <vincenz> or even less tactfully, he'll make you out for an idiot whenever you ask a question that is not 100% formally correct
01:13:04 <shapr> I agree with that.
01:13:13 <vincenz> at which point a question would seem useless
01:13:59 <shapr> Some of the channel members wanted Smerdyakov to stay, so I let him stay for awhile, but finally banned him when he got on my nerves in world class style.
01:14:19 <dons> but i think, after the ocaml reports, we made the right decision
01:14:29 <vincenz> yeah, #ocaml is a seriously dead channel most of the time
01:14:40 <vincenz> another reason why I stopped idling there
01:14:42 <dons> and might need to consider it again if similar high-temperature/newbie-hassling behaviour appears
01:14:52 <vincenz> dons: a timeproven heuristic?
01:14:58 <shapr> Anyway, I unbanned him months later to give him another chance, but he ended up pissing off a newbie so much that the guy said he would never come back to #haskell specifically because of Smerdyakov
01:14:58 <dons> seems so
01:15:02 <vincenz> dons: we should publish a paper
01:15:09 <shapr> Since newbies are the lifeblood of any community, that was the last straw.
01:15:13 * vincenz nods
01:15:49 <shapr> For weeks after that I got disapproving comments from some #haskell regulars, but hey, I'm the benevolent dictator here... I suggested that another #haskell could be started on OFP.
01:16:04 <vincenz> #oasis :P
01:16:05 <shapr> Also, Smerdyakov tried to get me removed as channel maintainer.
01:16:29 <shapr> Because he has a PhD and I have no education... I told him that #haskell is not academia, if it were I'd get paid for what I do here.
01:16:50 <shapr> Heck I'd be near tenure.
01:17:03 <vincenz> shapr: PhD in #haskellitis
01:17:06 <zarvok> :)
01:17:34 <shapr> Anyway, I was forced to formalize the policy here, so I call it "Steps of the Parthenon" meaning it doesn't matter your age, education, or whatever, if you can discuss intelligently and calmly, you can hang out and chat.
01:17:35 <vincenz> zarvok: btw, if you want contact ot other members of our team, its the previously mentioned channel
01:17:40 <dons> shapr: well, you've written 204,234 words into your client. that's a pretty good thesis
01:17:45 <shapr> hah
01:18:01 <vincenz> what's the policy on OT, cause I know I tend to go OT from time to time
01:18:11 <zarvok> vincenz: thanks, I may check it out at some point
01:18:24 <shapr> vincenz: As long as it doesn't get out of control, it's no problem.
01:18:39 <shapr> The goal of #haskell is to encourage learning and discussion of Haskell, FP, and programming.
01:18:40 <vincenz> zarvok: it will close down during the competition, however, so you'll have to tell me if you want to be in there during the thing
01:19:03 <shapr> OT is bad when it starts to disturb an on-topic discussion, but nobody will mind if you want to chat to yourself at 3am. Make sense?
01:19:08 <vincenz> yep
01:19:11 <vincenz> I tend to be a holefiller
01:19:12 <vincenz> :P
01:19:23 <zarvok> vincenz: I would find it interesting to follow a team's thought process, but the temptation to get involved would be too great
01:19:25 <vincenz> gotta keep those logs filled during offhours
01:19:26 <zarvok> thanks anyway
01:19:30 * vincenz nods at zarvok
01:19:37 <shapr> boegel started #haskell-blah for those discussions that get off-topic and stay there.
01:19:37 <vincenz> zarvok: well... I can moderate it
01:19:40 <vincenz> zarvok: so you can't talk
01:19:43 <zarvok> hahaha
01:19:46 <dons> shapr, I might stick up that on our irc wiki page, so we have some rules we can cite
01:19:59 <vincenz> dons: good idea
01:20:02 <shapr> dons: I can clean it up a bit if you want.
01:20:12 <zarvok> vincens: well, thanks for the offer, we'll see.  For now, it's way past bed time.  Later
01:20:20 <vincenz> zarvok: who needs sleep
01:20:25 <u221e> I'm still having trouble with monads... :(
01:20:34 <vincenz> u221e: have you looked at the tutorials on nomaware?
01:20:37 <vincenz> @where nomaware
01:20:37 <lambdabot> I know nothing about nomaware.
01:20:39 <vincenz> @where monads
01:20:40 <lambdabot> I know nothing about monads.
01:20:43 <boegel> shapr: yeah :)
01:20:47 <vincenz> @google nomads nomaware
01:20:50 <lambdabot> http://lwn.net/Articles/170038/
01:20:50 <lambdabot> Title: LWN: Nomads might make the mathematics *harder*
01:20:52 <zarvok> :) apparently not you.  Good luck getting over the jetlag
01:21:13 <vincenz> @where+ monads http://www.nomaware.com/monads/html/index.html
01:21:14 <lambdabot> Done.
01:21:16 <vincenz> @where monads
01:21:17 <lambdabot> http://www.nomaware.com/monads/html/index.html
01:21:30 <vincenz> u221e: have a look there
01:21:41 <u221e> vincenz, the first part is good but too short.
01:22:10 <vincenz> u221e: personally I found that the best way to get into monads is make one yourself... I also had issues at first getting into them
01:22:22 <vincenz> and ask questions along the eway
01:22:46 <vincenz> try to define a monad and then a monadtransformer
01:22:49 <kosmikus> yes, they're not very conveniently shaped ...
01:23:07 <GeoffSK> shapr: any chance i can ask a simple question?
01:23:11 <vincenz> kosmikus: hehe
01:27:36 <vincenz> GeoffSK: go ahead
01:27:51 <GeoffSK> i need to post a ten line code sample..whats the best way?
01:28:10 <shapr> lisppaste2: @paste
01:28:13 <shapr> hm
01:28:22 <vincenz> @paste
01:28:22 <lambdabot> http://paste.lisp.org/new/haskell
01:28:24 <GeoffSK> i mean - straight to channel is ok?
01:28:26 <vincenz> oy
01:28:27 <vincenz> @where paste
01:28:27 <lambdabot> http://paste.lisp.org/new/haskell
01:28:34 <vincenz> GeoffSK: use that site
01:28:43 <shapr> GeoffSK: Nah, three lines is the max size for direct pastes.
01:28:45 <vincenz> a) it makes it easily readable, b) it does not spam
01:29:03 <vincenz> plus it's easier to refer back to :)
01:29:23 <lisppaste2> GeoffSK pasted "infinite" at http://paste.lisp.org/display/22788
01:29:31 <GeoffSK> oh, cool.
01:30:16 <GeoffSK> when executed it fails to terminate
01:30:46 <vincenz> ah yes :)
01:30:51 <vincenz> haskell is lazy
01:30:54 <vincenz> and does letrec implicitly
01:30:55 <GeoffSK> the 'reuse' of the key is an obvious sin, but i don't understand the effect
01:30:57 <vincenz> (if you know for instance scheme)
01:31:06 <GeoffSK> sorry a little lisp is all
01:31:09 <vincenz> ah
01:31:10 <vincenz> well yeah
01:31:12 <vincenz> you know letrec?
01:31:14 <vincenz> in scheme?
01:31:23 <GeoffSK> nope
01:31:24 <vincenz> I presume it's something similarly named in lisp
01:31:27 <vincenz> recursive let
01:31:39 <vincenz> body can refer to the stuff being defined
01:31:45 <vincenz> that's what's happening
01:32:08 <vincenz> ah, in lisp it's known as "labels"
01:32:10 <GeoffSK> let A = A - does a recusive definition of A?
01:32:13 <vincenz> yes
01:32:22 <vincenz> look
01:32:26 <vincenz> > let ones = 1: ones in ones
01:32:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:32:40 <vincenz> or
01:33:03 <vincenz> > let fib = 1:1:zipWith (+) fib (tail fib) in fib
01:33:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:33:27 <vincenz> it seems the lisp term is "labels"  let in haskell is just like "labels" in lisp
01:33:49 <GeoffSK> got it. I just had put let A=A and A=A in different categories of my newbie brain
01:34:10 <vincenz> :)
01:34:22 <GeoffSK> first assigment second func definition
01:34:54 <vincenz> it's not different
01:34:58 <vincenz> > let f x = x in f 1
01:34:59 <lambdabot>  1
01:35:04 <vincenz> > let x = x  in x
01:35:04 <lambdabot>  Add a type signature
01:35:12 <vincenz> in the first one you're defining f
01:35:13 <vincenz> not x
01:35:23 <vincenz> x is only defined on invocation
01:35:31 <vincenz> erm... ini the body basically
01:36:00 <vincenz> dons: I think that if lambdabot were filtered out the amount of times I get a 5+ liner would increase dramatically
01:36:24 <dons> yep, sure
01:37:27 <GeoffSK> i has seen let x = blah, but the IN BLAH part i haven't used (yet)
01:38:34 <vincenz> oh right
01:38:39 <vincenz> well typically you have let var = exp in exp
01:38:40 <vincenz> or
01:38:44 <vincenz> let pattern = exp in exp
01:38:47 <vincenz> the let pattern = exp
01:38:48 <vincenz> without the in bit
01:38:52 <vincenz> only works in do-notation
01:39:09 <GeoffSK> thats right, kind a like a "where bit =..." for do clauses
01:39:21 <vincenz> no
01:39:26 <GeoffSK> oh
01:39:26 <vincenz> where are generic things
01:39:31 <vincenz> not do-related
01:39:39 <vincenz> they're like let-in-bindings
01:39:41 <vincenz> without hte hassle
01:39:55 <vincenz> and all the stuff can then be used in the rest of the function to which the where belong
01:41:26 <GeoffSK> hmmm, i dont have enough experience to give it meaning.
01:42:15 <GeoffSK> thanks for the explanation.
01:46:07 * shapr boings
01:58:55 * xerox boings in reply
02:02:18 <xerox> @tell esap Does SfM tell about co{algebras,functors,monads} ?
02:02:19 <lambdabot> Consider it noted.
02:03:00 <pejo> Can the bot note anyone, and can one do that in tells too?
02:16:09 <shapr> pejo: try it
02:21:10 <pejo> shapr, I thought i'd avoid filling it with junk, but you provoked me!
02:21:11 <lambdabot> pejo: You have 1 new message. '/msg lambdabot @messages' to read it.
02:26:55 <roconnor> ?help vixin
02:26:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:27:18 <roconnor> ?vixin what is the world coming to?
02:27:19 <lambdabot> i dunno...
02:28:18 <roconnor> ?vixin too many perverts send out sick pictures of themselves. what type of man does that?
02:28:18 <lambdabot> any type will due
02:28:41 <xerox> ?vixen vixen, right, not vixin, I think?
02:28:41 <lambdabot> we all have a little vixen in us
02:42:50 <shapr> @seen JaffaCake
02:42:50 <lambdabot> I saw JaffaCake leaving #haskell 2 days, 13 hours, 13 minutes and 1 second ago, and .
02:43:23 <vincenz> @seen boegel
02:43:23 <lambdabot> I saw boegel leaving #haskell and #haskell-blah 27 minutes and 21 seconds ago, and .
02:43:26 <vincenz> crud
02:44:31 <u221e> Can anyone manage to download yet another haskell tutorial?
02:44:35 <u221e> http://www.isi.edu/~hdaume/htut/tutorial.pdf
02:45:00 <u221e> I keeps stopping at around 20%
02:46:59 <mauke> seems to work here
02:47:49 <u221e> Not for me...
02:50:12 <u221e> wget -T 5
02:50:13 <u221e> ;)
02:50:34 <mauke> file size: 683K
02:51:18 <vincenz> shapr: any update on icfpc
02:51:20 <vincenz> Cale: ping
02:51:38 <mauke> copy: http://rapidshare.de/files/26157241/yaht.pdf.html
02:51:39 <lambdabot> Title: RapidShare Webhosting + Webspace
02:53:44 <u221e> Thanks but I managed to get it using wget with a timeout of 5 seconds above grabbing about 20% of the file each timeout.
02:59:32 <shapr> vincenz: Don't think I'll have time, sorry.
03:18:25 <roconnor> > 0.3335*0.5555
03:18:26 <lambdabot>  0.18525925000000001
03:18:32 <roconnor> > fromRational $ 0.3335*0.5555
03:18:33 <lambdabot>  0.18525925
03:23:15 <kuribas> Is it easy to reverse engineer a program compiled with ghc?
03:23:55 <xerox> shapr: haha, the maemo quote is insane.
03:26:43 <shapr> :-)
03:27:04 <shapr> ski: Greece?
03:27:09 <shapr> kuribas: Probably not
03:28:02 <kuribas> would it be easier than C or more difficult?
03:28:07 <ski> shapr : not physically
03:29:10 <kuribas> I wonder if the executable holds much information of the original sourcefile, since the executables are quite big.
03:30:13 <Adamant> kuribas, does ghc do it's own native compile or compile to C and use gcc?
03:30:16 <shapr> Probably more difficult than C, since GHC often goes through the C compiler.
03:30:27 <shapr> GHC has both native and C backends.
03:30:30 <Adamant> ah
03:31:10 <Adamant> I am not a RE expert, but I would guess the native compile would be significantly harder, and the C compile to gcc not much harder than C
03:32:20 <Adamant> actually, let me look at darcs and see
03:32:51 <kuribas> In that case I probably don't need to rewrite my application in C when it is finished :-)
03:33:43 <Adamant> what are you trying to protect?
03:33:54 <kuribas> The workings of my program.
03:34:00 <Adamant> ah
03:34:20 <Adamant> well, you probably want to do more than just use Haskell
03:34:36 <kuribas> I know it is unethical...
03:34:48 <Adamant> there are a lot of very specific tricks for preventing RE
03:35:10 <kuribas> Adamant: like?
03:35:24 <Adamant> anti-debugging, anti-disssembly, etc
03:35:42 <Killer666> anyway won't it be easier to redevelope the app than reverse-engineer already compiled machine code?
03:35:54 <Adamant> depends
03:36:11 <kuribas> Depens on how well it will work.
03:36:51 <kuribas> Not if my program does better than the existing ones, otherwise yes.
03:37:23 <Adamant> openrce.org
03:37:37 <Adamant> that should give you a start on crackproofing your program
03:38:35 <kuribas> Adamant: thanks
03:39:31 <kuribas> My idea is to write a program that recognises musical scores, and puts them in electronic format.
03:39:49 <kuribas> Ideally it should work with handwritten scores.
03:40:01 <Adamant> ah
03:40:15 <Adamant> you'll need some serious OCR chops
03:40:41 <kuribas> chops?
03:40:42 <shapr> I think that disassembling GHC produced code (native or C) will be a total nightmare.
03:40:45 <Adamant> skills
03:41:03 <Adamant> shapr, probably, but some RE's are crazily talented
03:41:25 <shapr> Yeah, but I bet they're used to disassembling procedural languages...
03:41:46 <shapr> Haskell has a thunk (pointer) for each piece of data by default, that's how it gets its non-strict behaviour.
03:41:50 <Adamant> shapr, very true, but given the junk these guys can wade through, I wouldn't bet against them
03:42:18 <shapr> I think that the less strict your program is, the more trouble REs will have.
03:42:19 <Adamant> kuribas, chops = skills, knowledge
03:42:41 <kuribas> Ah
03:42:47 <Adamant> shapr, I honestly don't know
03:43:12 <shapr> Non-strict behaviour means the memory layout of your program can be dramatically different for each run.
03:43:14 <Adamant> I don't know much about Haskell, and only a moderate amount about RE
03:43:28 <Adamant> Haskell is on my to-do list to really learn
03:43:47 <shapr> Grab it, you'll learn lots :-)
03:44:31 <kuribas> shapr: the nice thing it that if it would work, it would be good publicity for haskell
03:44:43 <kuribas> I don't think many commercial apps use Haskell at the moment.
03:44:55 <shapr> You could use things like region allocation, that would make life even more difficult for REs.
03:44:59 <shapr> You'd be surprised...
03:45:24 <shapr> BlueSpec has BlueSpec, Galois has Cryptol, Aetion has lots of stuff no one will ever hear about.
03:45:35 <Adamant> Cryptol?
03:45:42 <shapr> Xilinx and Intel have been using Haskell for years, not sure how much they're aware of it though.
03:46:23 <shapr> @google cryptol galois
03:46:23 <kuribas> Didn't know about that :)
03:46:25 <lambdabot> http://www.cryptol.net/
03:46:52 <shapr> kuribas: Circuit design & synthesis is really smooth in Haskell. Check out Hawk, Lava, etc
03:48:15 <kuribas> cool
03:49:02 <shapr> There was a freely available version of Lava that generated netlists for Xilinx FPGAs. I wanted to buy a PCI card with a big FPGA and have a Haskell programmable coprocessor :-)
03:49:17 <Adamant> why a BIG card?
03:49:22 <Adamant> pico-computing.com
03:49:35 <Stinger_>  bigger is better
03:49:37 <Adamant> PCMCIA with a Xilinx FGPA on it. :)
03:49:44 <Adamant> but small is beautiful
03:49:47 <Adamant> ;)
03:50:15 <shapr> I thought it might be neat to experiment with graph reduction CPUs and other things that could be done with FPGAs. For example, conway's life done directly on an FPGA would be great... can the array elements directly affect each other?
03:50:17 <Adamant> that cryptol software looks very interesting.
03:50:57 <kuribas> Doing music recognition on a FPGA would be really powerful.
03:51:17 <kuribas> It could do a lot of steps in parallel.
03:51:29 <shapr> I recently read a research paper about music recognition.
03:51:41 <kuribas> shapr: A recent paper?
03:51:51 <shapr> I think it had something to do with derivatives of music.
03:52:09 <shapr> Yeah, this year I think.
03:52:38 <kuribas> I see that a lot of music recognition do things like removing the staff first.  That's evil.
03:53:41 <kuribas> These programs only work with perfectly scanned, published scores.
03:53:52 <kuribas> shapr: Do you remember anything from the paper?
03:58:41 <kuribas> If it is a publicly available paper, I'd be interested to read it :)
04:06:16 <shapr> Sorry, it was audio music recognition :-)
04:06:43 <shapr> They want people to recognize a tune from a few seconds of an mp3
04:10:04 <kuribas> ah :)
04:14:47 <kuribas> I can imagine that's more popular than musical scores.
04:15:13 <petekaz> I just read the paper on Pattern Guards and Transformational Patterns at the gym this morning (oddly enough, I was the only person reading a paper on Haskell, go figure :-), I know that patter guards are implemented, but are transformational patterns implemented as well?
04:18:24 * shapr doesn't know
04:19:28 <petekaz> > let f n!id = n in f 10
04:19:28 <lambdabot>  Parse error in pattern
04:19:31 <petekaz> I guess net.
04:19:36 <petekaz> s/net/not.
04:20:21 <petekaz> Where is the best location to see what new features are in the next version of ghc?
04:20:23 <shapr> Might need -fglasgow-exts ?
04:21:09 <petekaz> Doesn't seem to work.
04:21:39 <petekaz> I really thought the transformational pattern was cool.
04:23:11 <shapr> Doing stuff on the left hand side always seems a bit confusing to me.
04:23:22 <shapr> Like (k + 1) patterns
04:23:38 <petekaz> In the paper, there are a few good examples IMO.
04:24:01 <petekaz> But it seems that they are not implemented.  Boo hoo!
04:25:31 <erider> hi all
04:25:51 <Philippa> not only are they not implemented, but !pat is being used for strict matches now
04:27:40 <petekaz> I wonder why they never were implemented.
04:28:07 <petekaz> I think the paper makes a good case in improving readability of code.
05:07:45 <vincenz> hoi boegel
05:13:25 <boegel> vincenz: hey :) still awake? ;)
05:13:31 <roconnor> @vixin it's too hot in here.
05:13:31 <lambdabot> Crazy little wanker!
05:13:45 <boegel> @vixen I'm sweating my ass off!
05:13:45 <lambdabot> i hate it when i get stuck with chatting with a bot!
05:13:51 <boegel> :D
05:15:31 <shapr> @yow !
05:15:31 <lambdabot> I'm gliding over a NUCLEAR WASTE DUMP near ATLANTA, Georgia!!
05:17:31 <vincenz> boegel: me
05:17:36 <vincenz> boegel: always
05:17:43 <vincenz> boegel: get a chance to look at the thing
05:17:45 <vincenz> ?
05:18:56 <vincenz> @seen cale
05:18:56 <lambdabot> cale is in #haskell and #haskell-overflow. I don't know when cale last spoke.
05:19:03 <vincenz> @seen lightstep
05:19:03 <lambdabot> I saw lightstep leaving #haskell 1 day, 17 hours, 21 minutes and 52 seconds ago, and .
05:19:06 <vincenz> Cale: ping
05:19:11 <vincenz> @seen jethr0
05:19:12 <lambdabot> I saw jethr0 leaving #oasis and #haskell 1 month, 2 days, 13 hours, 13 minutes and 4 seconds ago, and .
05:19:14 <vincenz> @seen oejet
05:19:15 <lambdabot> I saw oejet leaving #haskell 3 days, 21 hours, 11 minutes and 13 seconds ago, and .
05:20:01 <roconnor> @type 0.9
05:20:02 <lambdabot> forall t. (Fractional t) => t
05:20:16 <roconnor> > 0.1234567890123456789
05:20:17 <lambdabot>  0.12345678901234568
05:20:20 <shapr> @seen JaffaCake
05:20:20 <lambdabot> I saw JaffaCake leaving #haskell 2 days, 15 hours, 50 minutes and 32 seconds ago, and .
05:20:28 <roconnor> > 0.12345678901234567890123456789
05:20:29 <lambdabot>  0.12345678901234568
05:20:36 <roconnor> > fromRational 0.12345678901234567890123456789
05:20:37 <lambdabot>  0.12345678901234568
05:20:53 <dcoutts> shapr, so are we sure on the AngloHaskell dates now?
05:20:58 <roconnor> > (0.12345678901234567890123456789)::Rational
05:20:59 <lambdabot>  12345678901234567890123456789%100000000000000000000000000000
05:21:03 <shapr> Not yet, haven't talked to MSR.
05:21:07 <roconnor> oh nice
05:21:51 <roconnor> numbers with a decimal point really are rationals.
05:21:56 <shapr> neat!
05:21:57 <dcoutts> shapr, ok, my parents are pestering me to know, which is reasonable if I'm going to put people up on their floor :-)
05:22:47 <shapr> I can understand that :-)
05:22:59 <boegel> vincenz: hehe, not yet, I'm not at work today, so I'm busy with all kinds of stuff :) but I will check it out
05:25:35 <vincenz> you do that
05:26:02 <vincenz> YOU DO THAT!
05:26:41 * boegel thinks vincenz needs some sleep
05:27:05 * vincenz staples boegel's eyelids open to the front of his forehead
05:28:46 <bortzmeyer> @type map
05:28:47 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
05:32:23 <roconnor> would the sematic problems of seq go away if it did nothing for function types?
05:32:43 <roconnor> > seq (undefined `asType` id) 5
05:32:44 <lambdabot>  Not in scope: `asType'
05:32:49 <roconnor> > seq (undefined `astype` id) 5
05:32:50 <lambdabot>  Not in scope: `astype'
05:32:59 <kpreid> asTypeOf
05:33:02 <roconnor> > seq (undefined `asTypeof` id) 5
05:33:03 <lambdabot>  Not in scope: `asTypeof'
05:33:06 <roconnor> > seq (undefined `asTypeOf` id) 5
05:33:07 <lambdabot>  Undefined
05:33:10 <roconnor> right
05:33:16 <roconnor> so I would suggest that return 5 instead.
05:33:50 <roconnor> seq (\_ -> undefined) 5
05:33:56 <bortzmeyer> @listcommands
05:33:56 <lambdabot> Unknown command, try @list
05:33:56 <roconnor> > seq (\_ -> undefined) 5
05:33:57 <lambdabot>  5
05:34:00 <bortzmeyer> @list
05:34:01 <lambdabot> list [module|command]. Where modules is one of:
05:34:01 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
05:34:01 <lambdabot> topic type unlambda url version vixen where
05:34:15 <bortzmeyer> @hoogle [String] -> String
05:34:16 <lambdabot> Prelude.unlines :: [String] -> String
05:34:16 <lambdabot> Prelude.unwords :: [String] -> String
05:34:16 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
05:38:09 <roconnor> @vixin what do you think?
05:38:09 <lambdabot> let's don't talk about that
05:39:58 <roconnor> > seq (\x -> undefined `asTypeOf` x) 5
05:39:59 <lambdabot>  5
05:42:33 <dblhelix> good afternoon (or pick your own time-zone dependent greeting ;))
05:42:45 <dblhelix> @pl \d -> (d :) . map (d +)
05:42:46 <lambdabot> liftM2 (.) (:) (map . (+))
05:51:16 <shapr> whee
05:52:40 <vincenz> whoo
05:53:43 <vincenz> we scared him
05:54:37 <shapr> hmm "Ping time to shapr is 00:11.19"
06:02:18 <dcoutts> Lemmih, I see you're doing good work in preperation for MSR interview ;-)
06:03:16 <Lemmih> dcoutts: Yeah, I really hope my -1+1 patch will impress them. (:
06:03:21 <dcoutts> heh
06:03:24 <shapr> Is there someway to get C-x C-e style behaviour from Haskell?
06:03:26 <dcoutts> but it was quick
06:04:58 <shapr> This is my first time working on GHC, I still have much to learn.
06:05:38 <dcoutts> shapr, I like this: http://www.scannedinavian.com/hope/entry/52
06:05:41 <vincenz> dcoutts: what patch was this?
06:05:45 <dcoutts> <varis> well, that will limit the performance of your cluster
06:05:58 <Lemmih> dcoutts: I'm looking at an Arrows panic to do for real.
06:06:07 <dcoutts> good good :-)
06:06:14 <vincenz> dcoutts: yeah that's funny
06:06:17 <dcoutts> vincenz, see the ghc-bugs list and ghc-cvs
06:06:21 <shapr> dcoutts: heh, thanks :-)
06:06:22 * vincenz nods
06:06:48 <dcoutts> shapr, some of the CCC people can juggle 5+
06:07:08 <vincenz> dcoutts: where exactly in the cvs?
06:07:10 <shapr> Wow, I'm jealous. They'd have a huge cluster!
06:07:26 <dcoutts> I should find out from my sister what day they meet, we should go along when you're in Cambridge
06:07:39 <dcoutts> vincenz, the ghc cvs commits list
06:07:49 <dcoutts> well these days it's the darcs commit list
06:07:53 <dcoutts> but still called cvs
06:07:54 * vincenz hmms and wonders where it is
06:08:06 <vincenz> ah got it
06:08:54 <dcoutts> Lemmih, I've got a much a harder bug to track down :-) probably one for SPJ though.
06:09:27 <ndm> there is always my compile time performance one, which seems to have been left to rot
06:09:34 <dcoutts> to do with recent ghc-6.5 versions and RULES that have stoped matching
06:09:39 <vincenz> dcoutts: wait... you mean cvs-ghc as in
06:09:40 <vincenz> http://www.haskell.org/mailman/listinfo
06:09:40 <vincenz> ?
06:09:41 <lambdabot> Title: www.haskell.org Mailing Lists
06:09:48 <dcoutts> vincenz, yes
06:10:02 <vincenz> can't find the bugs list on that page
06:10:22 <SamB_XP> Lemmih: you seem to keep fairly irregular hours. or should I say regular?
06:11:53 <vincenz> dcoutts: how do you contribute to ghc?
06:12:05 <dcoutts> vincenz, get the sources with darcs
06:12:13 <vincenz> dcoutts: and then?
06:12:19 <dcoutts> vincenz, then find a bug or feature and start writing patches
06:12:31 <dcoutts> vincenz, there's lots of instructions for how to build the tree
06:12:39 <vincenz> and send the entire patch to the ml?
06:12:48 <dcoutts> darcs send does the right thing
06:12:55 <vincenz> assuming proper email
06:12:58 <dcoutts> yes
06:13:01 * vincenz can't send email from terminal
06:13:10 <dcoutts> install ssmtp
06:13:16 <dcoutts> which just worwards to your isp
06:13:23 <vincenz> alright, thx
06:13:24 <dcoutts> worwards/forwards
06:13:33 <vincenz> warwords
06:13:56 <vincenz> oh last question
06:14:03 <vincenz> do I need to config ssmtp?
06:14:15 <shapr> I can't build GHC because it can't find Cabal, but that isn't mentioned in the docs. What's the fix?
06:14:28 <roconnor> :type maximum
06:14:35 <roconnor> @type maximum
06:14:36 <lambdabot> forall a. (Ord a) => [a] -> a
06:14:49 <shapr> I'm building GHC from the darcs repo.
06:15:30 <roconnor> @doc Prelude.Ord
06:15:30 <lambdabot> Prelude.Ord not available
06:15:34 <roconnor> @doc Ord
06:15:34 <lambdabot> Ord not available
06:15:50 <dcoutts> vincenz, yes you need to change one line in the ssmtp config to tell it your isp's smtp server
06:16:05 * vincenz nods
06:16:07 <dcoutts> shapr, you need all the libs
06:16:18 <dcoutts> shapr, at the top level there is a script ./darcs-all
06:16:25 <dcoutts> shapr, use ./darcs-all get --partial
06:16:34 <shapr> aha
06:16:37 <dcoutts> after that use ./darcs-all pull
06:16:37 <vincenz> dcoutts: can it do gmail
06:16:46 <shapr> This should be in the GHC repo README
06:17:10 <dcoutts> vincenz, no you need an outpund smpt server, your isp or institutions smtp server will do
06:17:16 * shapr sends a patch to the docs
06:17:27 * dcoutts was just about to suggest that :-)
06:18:45 <vincenz> dcoutts: afaik you can do smpt with gmail
06:18:53 <vincenz> after all I use thunderbird with gmail
06:18:56 <vincenz> smtp
06:19:02 <SamB_XP> yes, of course
06:19:05 <vincenz> my institution's is only accessible from work
06:19:12 <shapr> You can send mail via gmail?
06:19:13 <vincenz> and I don't use my isp's
06:19:22 <vincenz> shapr: I meant forward from ssmtp
06:19:25 <vincenz> through gmail
06:19:33 <shapr> oh, ok
06:19:50 <SamB_XP> hmm, I wonder if I have that setup correctly...
06:19:51 <dcoutts> vincenz, you can use your isp's however, it should just work
06:20:09 <dcoutts> just because you don't use it normally doesn't matter
06:20:18 <vincenz> unless people try to reply
06:20:49 <vincenz> nah
06:20:52 <vincenz> gmail has smtp :)
06:21:02 <xerox> No why?
06:21:20 <xerox> You SMTP has nothing to do with receiving emails.
06:21:22 <xerox> *Your
06:21:29 <vincenz> reply-to?
06:21:43 <xerox> It is just an header.
06:22:00 <SamB> indeed
06:22:48 <xerox> (You tell your SMTP of choice about headers.)
06:22:59 * vincenz ponders
06:23:44 <vincenz> hmm
06:23:47 <xerox> Except for authorization purposes, SMTPs don't really check any of the informations you give them.
06:23:49 <vincenz> ssmtp has option "rewriteDomain"
06:23:54 <vincenz> but that's domain only
06:23:56 <dcoutts> vincenz, you can specify your email address independently of what isp you use to send
06:23:56 <vincenz> not username
06:24:10 <dcoutts> vincenz, you tell darcs your email address
06:24:28 <vincenz> oh
06:24:33 <vincenz> and darcs takes care of it?/
06:24:38 <dcoutts> yep
06:24:45 <vincenz> ah good
06:24:49 <vincenz> so all I need to specify is the mailhub
06:24:50 <dcoutts> by using that as the from and/or reply-to
06:24:55 <dcoutts> yes
06:24:58 <vincenz> thx
06:25:14 <xerox> Right. lines "HELO foo.com\nMAIL FROM: foo@bar.com\nRCPT TO: baz@quux.com\nDATA\nfoo\nbar\nbaz\n.\n" `fmap` sendmail
06:25:40 * vincenz is coder not sysadmin
06:25:42 <vincenz> :|
06:25:54 <vincenz> my knowledge of lowlevel linux gadgeterry is serious limited
06:26:28 <SamB> hmm, I forget what my mailserver is
06:26:39 <SamB> what is the virtual package for mailservers in Debian?
06:26:49 <vincenz> I still fail to see what the issue is with using gmail
06:26:55 <SamB> the one they all Provide:
06:27:03 <SamB> there is no problem
06:33:10 * shapr boings
06:33:30 <shapr> Where do I send patches?
06:34:12 <Lemmih> GHC patches?
06:35:32 <shapr> Yup
06:36:13 <xerox> darcs send doesn't choose for you?
06:36:35 <shapr> I don't have outgoing smtp working on this computer, I have to send manually :-(
06:36:47 <shapr> But you have a point, it's probably in prefs.
06:36:58 <xerox> Oh
06:36:59 <xerox> Just do:
06:37:01 <Lemmih> shapr: cvs-ghc@haskell.org
06:37:04 <xerox> darcs send -o /tmp/patch
06:37:20 <xerox> And steal the address from the _darcs/ directory :)
06:37:24 <shapr> thanks
06:37:58 <xerox> Just (do { it; })
06:38:26 <Lemmih> heh
06:38:50 <mauke> can you really have a ; there?
06:39:01 <Philippa> yes
06:39:31 <xerox> > let it = () in Just (do { it; }) :: Maybe [()]
06:39:31 <lambdabot>  Couldn't match `[()]' against `()'
06:39:39 <xerox> Ack!
06:40:15 <xerox> > let it = undefined in Just (do { it; }) :: Maybe [()]
06:40:16 <lambdabot>  Undefined
06:40:21 <xerox> Well.
06:40:41 <beelsebob_> is there a simple GUI haskell app that can draw a graph of a function
06:40:54 <xerox> Yes, I think so.
06:40:58 <xerox> And it is also cairo powered.
06:41:05 <beelsebob_> do you know where?
06:41:11 <xerox> ?google Haskell Cairo graph function
06:41:13 <lambdabot> http://haskell.org/gtk2hs/archives/2006/03/06/introductory-presentation/
06:41:13 <lambdabot> Title: Gtk2Hs » Blog Archive » Gtk2Hs introductory presentation
06:41:18 <xerox> Hmmm.
06:41:19 <dcoutts> not that one
06:42:12 <kuribas> Is it possible that haskell-mode is broken on XEmacs?
06:42:21 <xerox> Can't find it. but I am sure it exist, do you remember, Duncan?
06:42:32 <dcoutts> I remember seeing it
06:42:59 <ihope> Is this quantum stuff just an efficient way of doing mplus in Maybe, or what?
06:43:17 <shapr> Does cvs-all have a gmane group?
06:43:36 <xerox> ihope - You always catch my interest! Right now I am reading `A Brief Survey of Quantum Programming Languages'
06:43:38 <shapr> oh, duh :-)
06:43:57 <dcoutts> http://dockerz.net/software/chart.html
06:43:58 <lambdabot> Title: A haskell chart library
06:43:59 <xerox> I think so shapr.
06:44:06 <dcoutts> beelsebob_, ^^^
06:44:10 <beelsebob_> *g*
06:44:11 <beelsebob_> thanks
06:44:12 <xerox> chart.. :-)
06:44:13 <shapr> xerox: I'm already subscribed :-)
06:44:19 <xerox> hah.
06:45:57 * boegel read that as "I'm already circumsized"
06:46:18 <xerox> ihope - I succedeed in typing your function, by the way, did you see it?
06:47:18 <roconnor> >[3.14,3.24..4]
06:47:29 <xerox> http://fooling.lambdabot -- ihope ~> http://www.haskell.org/haskellwiki/User:PaoloMartini#Experimenting_with_variadic_functions
06:47:30 <ihope> > [3.14,3.24..4]
06:47:32 <lambdabot>  [3.14,3.24,3.3400000000000003,3.4400000000000004,3.5400000000000005,3.640000...
06:47:40 <vincenz> @version
06:47:40 <lambdabot> lambdabot 4p28, GHC 6.5 (OpenBSD i386 )
06:47:40 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:48:04 <shapr> kittenbot: @hello
06:48:18 <shapr> kittenbot: @help
06:48:21 <shapr> hmm
06:48:24 <beelsebob_> kittenbot: @listcommands
06:48:30 <kittenbot> shapr: hello to you too
06:48:35 <shapr> aha
06:48:40 <beelsebob_> slow...
06:48:49 <kittenbot> I'm still formulating my question, please be patient :)
06:48:55 <shapr> Oh, you're not a bot?
06:49:01 <gds> lol
06:49:04 <beelsebob_> lol
06:49:04 <shapr> But you are from Manchester!
06:49:23 <kittenbot> *quack* ?
06:49:28 * shapr boings
06:49:28 <kittenbot> I am from Manchester, yes
06:49:38 * beelsebob_ eats kittenbot 
06:49:40 <shapr> Nice to meet you, I'm from Alabama, but I live in Stockholm.
06:49:50 <beelsebob_> :o
06:50:10 <vincenz> I think kittenbot is a turing bot
06:50:10 <madpickle> i'm a visitor from Omicron Persei-8
06:50:12 * kittenbot gives Beelsebob *heartburn*
06:50:13 <madpickle> but i live in the UK
06:50:15 <shapr> Neato
06:50:30 <ihope> xerox: why not "d f [] = f" instead of "d f (x:[]) = f x"?
06:50:53 <beelsebob_> ihope: because the patern match will fail
06:51:09 <dons> kittenbot, meet lambdabot
06:51:22 <lambdabot> hi!
06:51:29 <kittenbot> Question -- can constructors have guards?
06:52:00 <kittenbot> Can I have something like: data MyNum = MyOdd Int | MyEven Int
06:52:05 <beelsebob_> yes
06:52:07 <dons> nope, but you can wrap the constructor, and guard to your heart's content
06:52:18 <xerox> ihope: typing issues.
06:52:21 <beelsebob_> but they aren't guards
06:52:26 <xerox> ihope: try yourself.
06:52:28 <beelsebob_> it's just an or
06:52:40 <beelsebob_> it says MyNum is either MyOdd Int or it's MyEven Int
06:52:49 <dons> ?gwiki Smart constructors
06:52:51 <lambdabot> No Result Found.
06:52:54 <shapr> gwiki?
06:53:03 <madpickle> gofer?
06:53:09 <dons> uses google to search the wiki
06:53:12 <madpickle> oh
06:53:12 <xerox> I was also asking myself what was that.
06:53:20 <xerox> Ah cool.
06:53:22 <dons> ?gwiki smart constructor
06:53:23 <lambdabot> No Result Found.
06:53:31 <dons> ?gwiki lambda
06:53:32 <lambdabot> No Result Found.
06:53:35 <beelsebob_> :o
06:53:37 <dons> hmm
06:53:38 <madpickle> ?gwiki haskell
06:53:39 <beelsebob_> not very well apparently
06:53:40 <lambdabot> http://www.haskell.org/haskellwiki/Haskell/Pointfree
06:53:40 <lambdabot> Title: Pointfree - HaskellWiki
06:53:42 <ihope_> Hmm...
06:53:45 <beelsebob_> ohh... that's in there
06:53:52 <beelsebob_> ?gwiki pointfree
06:53:53 <xerox> dons - Is there any reason why a new command of the Dummy module works in `sh ghci Main.hs' + main and doesn't appear in ./lambdabot --online ?
06:53:54 <ndm> grr, ran out of heap space....
06:53:55 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
06:53:55 <lambdabot> Title: Pointfree - HaskellWiki
06:53:59 <xerox> (Or even ./lambdabot.)
06:54:01 <beelsebob_> ?gwiki wiki
06:54:02 <lambdabot> No Result Found.
06:54:04 <beelsebob_> :o
06:54:07 <vincenz> ndm: gotta clean your desk more
06:54:14 <beelsebob_> there isn't a wiki in the wiki
06:54:15 <shapr> xerox: Did you export the command?
06:54:32 <beelsebob_> ndm's isn't anywhere near as bad as mine
06:54:39 <roconnor> Um, what is going on here:
06:54:40 <shapr> Like, did you add it to the list of registered commands?
06:54:43 <kittenbot> I'm want to allow pattern matching. Wrapping the constructors does not prevent the original constructs from being used...
06:54:47 <roconnor> > enumFromThenTo 3.14 3.24 4.0 ::[Rational]
06:54:48 <xerox> shapr: the dummy module exports "map fst foo", where foo :: [(String,String -> String)].
06:54:48 <lambdabot>  [157%50,81%25,167%50,86%25,177%50,91%25,187%50,96%25,197%50,101%25]
06:54:50 <ndm> vincenz: my office mate complains i need to tidy my desk all the time - we can't have the fan on anything more than 1 becaues otherwise it blows my papers onto the floor
06:54:56 <roconnor> let enumFromThenTo n n' m = takeWhile (if n' >= n then (<= m) else (>= m)) (enumFromThen n n') in enumFromThenTo 3.14 3.24 4.0 ::[Rational]
06:54:59 <madpickle> ndm: lol
06:55:02 <roconnor> > let enumFromThenTo n n' m = takeWhile (if n' >= n then (<= m) else (>= m)) (enumFromThen n n') in enumFromThenTo 3.14 3.24 4.0 ::[Rational]
06:55:03 <lambdabot>  [157%50,81%25,167%50,86%25,177%50,91%25,187%50,96%25,197%50]
06:55:09 <shapr> ndm: haha
06:55:13 * gds pulls the latest lambdabot patches and gets:
06:55:16 <xerox> shapr: hence I have added a tuple ("foo",function).
06:55:18 <gds> Setup.hs: lambdabot.cabal:15: Unknown field 'exposed'
06:55:19 <madpickle> i get the same thing with my fan
06:55:22 <madpickle> except it's candy wrapper :(
06:55:31 <beelsebob_> kittenbot: yes, that will work
06:55:33 <gds> What version of cabal does lambdabot expect now?
06:55:35 <ndm> the cleaners no longer empty my bin because there is too much crap on the floor, and they can't tell whats rubbish
06:55:43 <shapr> ndm: My easy solution was to move house every few months, motivating me to throw out all my hardcopies and keep several hundred MB of papers on my Nokia 770 for easy access.
06:55:48 <shapr> haha
06:55:51 <roconnor> oh wait
06:56:01 <ndm> shapr, its mainly handwritten notes
06:56:02 <roconnor> The I was reading the Haskell 1.3 report
06:56:05 <kittenbot> Beelsebob: But that means that someone can construct something that contains bad data -- what's to prevent (Odd 6) ?
06:56:12 <ndm> i go through about a notebook every two weeks
06:56:16 <dons> ?google smart constructor haskell wiki
06:56:19 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
06:56:19 <lambdabot> Title: Smart constructors - HaskellWiki
06:56:24 <dons> there!
06:56:38 <dons> kittenbot: ^^ how to restrict constructors to numeric predicates
06:56:44 <dons> in a variety of ways
06:56:49 <shapr> ndm: You need a voice recognition program and some sort of dictation device.
06:56:56 <kittenbot> dons: Thanks, I'm checking it out now :)
06:56:59 <xerox> No well, in fact my unsafeIO-permorning code doesn't...
06:57:22 * xerox scratches head
06:57:25 <shapr> ndm: I've had great results from talking into my iriver and then transcribing the recordings. That tends to turn up even more good ideas.
06:57:37 <shapr> Sadly I bricked my iriver a week ago.
06:57:38 <xerox> dons: got a second?
06:57:52 <roconnor> @hoogle numericEnumFrom
06:57:53 <lambdabot> No matches found
06:58:10 <ihope_> "...and [quantum gates] correspond to unitary transformations over a complex vector space."
06:58:17 <ihope_> Um, that makes no sense :-P
06:58:21 <kittenbot> dons: Erm... how does one pattern-match against the constructed data?
06:58:45 <shapr> hiya hrgh
06:58:46 <dons> one doesn't, you'd provide an elimination form
06:58:55 <dons> i.e. a deconstructor
06:58:58 <kittenbot> ah well
06:59:05 <dons> unless you can code up the property in the typesystem
06:59:18 <hrgh> shapr: hrgh!
06:59:22 <dons> which in your case requires an encoding of even/odd
06:59:41 <dcoutts> dons, any luck with our RULES ?
06:59:42 <dons> so a little tricky, and probably over kill
06:59:51 <xerox> dons - do lambdabot provide any means for nondeterminsm?
07:00:03 <dcoutts> dons, what should I look at now that I've had my tea :-)
07:00:05 <dons> dcoutts, ah, no, didn't get that far today for some reason :/
07:00:13 <xerox> Just trying to avoid an unsafePerformIO $ random.. ...
07:00:20 <dons> xerox: yeah, there's a random lib in Utils
07:00:47 <roconnor> numericEnumFromThenTo has a bizzare definition.
07:00:49 <hrgh> when making a program that has a main loop, do you have to make sure the "repeat" call is tail recursive so that you never run out of stack space?
07:02:13 <hrgh> will something like mainLoop = do { stuff; mainLoop; } work?
07:02:31 <dons> hmm, i'm sure there's a formal defn, but you should just make sure that your function doesn't 'hang on to' any value that it will have to return to, to produce the final value
07:02:47 <dons> you're looking for something iek : f x = ... f (x+1)
07:02:56 <dons> like yours above, yes.
07:03:26 <dons> the cases when this isn't the case are, say, f x = ... y<- f (x+1) ; return y
07:03:45 <dons> it doesn't recurse from the tail
07:03:53 <kittenbot> thank you dons, beelsebob_
07:04:04 <dons> that was it?
07:04:05 <hrgh> yeah, the whole point is that it never should have to return to the "site" of the call to finish some operation before returning a value, as that would require stack space
07:04:10 <dons> but i want to know what he decided to do.
07:04:19 <dons> hrgh: right
07:04:39 <shapr> gwahr
07:05:01 <madpickle> qopdjqwodj
07:05:06 <madpickle> you heard it here first.
07:05:15 <dons> roconnor: i get scared when i see emails titled "the semantics of seq" -- seq is super scary.
07:06:14 <xerox> dons: but with randomElem :: [a] -> IO a I still need to do unsafeperfunsafePerformIO !
07:06:16 <vincenz> dons: it's like "the orthogonality of c++"
07:06:21 <xerox> Is it alright to do it in Dummy.hs?
07:06:38 <roconnor> dons: Yep, I'm trying to understand these issues about bottom a little better.  Coq doesn't have bottom, so I have always ignored it.
07:06:58 <xerox> roconnor: Do you have any good text about bottom?
07:07:04 <roconnor> nope
07:07:06 <ihope_> xerox: [a] -> IO a uses unsafePerformIO?
07:07:08 <vincenz> @join #oasis
07:07:51 <vincenz> ihope_: I doubt that
07:08:24 <jgrimes_> dons: how scary is seq exactly? because I was thinking about using it...
07:08:48 <roconnor> dons: but it seems that seq is pretty useless when applied to function types.
07:08:51 <dons> oh, its ok. it breaks a lot of properties once you try to reason about code though
07:08:59 <jgrimes_> oh ok
07:09:06 <jgrimes_> I could see that
07:09:16 <roconnor> doesn't seq only break properties about bottom?
07:09:17 <dons> xerox, its ok to go nuts with unsafePerformIO
07:09:27 <xerox> I wonder what do I do wrong.
07:09:44 <Philippa> roconnor: a lot of useful properties involve bottoms, or the absence thereof...
07:09:48 <xerox> dons: may I send you in a patch to check? it's very short
07:09:57 <dons> it breaks things like rewrite rules in build/foldr too, relying on laziness..
07:10:07 <roconnor> Philippa: name two
07:10:23 <vincenz> Philippa: procreation?
07:10:29 <vincenz> erm
07:10:33 * vincenz retargets to roconnor
07:10:48 <roconnor> @vixin what is procreation?
07:10:48 <lambdabot> i don't know, what?
07:10:59 <dons> roconnor: for example, ghc uses short-cut fusion, the equational transformations break in the presence of seq
07:11:05 <ihope_> Curry has a bit of weirdness with nondeterminism, just like random values as "normal" ones.
07:11:23 <roconnor> dons: but they are sound for any program that terminates, right?
07:11:32 <dons> no!
07:11:42 <dons> e.g. you migth take the head of a list by doing a foldr
07:11:59 <dons> the fusion will introduce bottoms in the list, which will get forced before you hit the head.
07:12:21 <dons> i oly found this out when i triggered what looked like a ghc bug last week
07:12:32 <dons> but it was really the use of seq, breaking ghc's short cut fusion
07:13:12 <roconnor> dons where is seq used?
07:13:58 <dons> if you slip seq onto a loop that is rewritten with build, you can end up with a strict list containing bottoms. let me find you the papers on the evilness of seq...
07:14:10 <xerox> dons: sent!
07:14:30 <shapr> dons: Wow, this sounds most interesting.
07:15:48 <vincenz> dons: a full list of bottoms? sounds like a pron dream
07:16:47 <Philippa> roconnor: "this function never returns bottom", "this function only returns bottom if its parm evaluates to bottom"
07:17:23 <dons> roconnor: ah, here
07:17:24 <dons> http://haskell.org/haskellwiki/Correctness_of_short_cut_fusion
07:17:25 <lambdabot> Title: Correctness of short cut fusion - HaskellWiki
07:17:29 <Lemmih> @seen JaffaCake
07:17:30 <lambdabot> I saw JaffaCake leaving #haskell 2 days, 17 hours, 47 minutes and 41 seconds ago, and .
07:17:40 <shapr> Oy, I'm no longer subscribed to cvs-all. Time to subscribe and suspend.
07:17:52 <vincenz> anyone got a good team name
07:17:56 <vincenz> for a haskell team for icfpc?
07:17:57 <dons> "In the presence of seq, the foldr/build-rule is not anymore a semantic equivalence."
07:18:40 <dons> "there has been at least one occasion where, as a result, a safely terminating program was turned into
07:18:44 <dons> a failing one "in the wild", with a less artificial example than the ones given above.
07:18:47 <dons> "
07:18:50 <dons> that was my fps test example :)
07:19:07 <xerox> %)
07:19:28 <dons> some refs, P. Johann and J. Voigtlnder. The impact of seq on free theorems-based program transformations
07:19:39 <xerox> I challenge the artificiality of dons' code.
07:19:50 <dons> no! it was real code
07:19:56 <dons> and it started failing in ghc 6.5
07:20:05 <dons> sure, it used peek,poke,inlinePerformIO,seq
07:20:10 <dons> but, heh, don't we all??
07:20:11 <xerox> Ah-ha.
07:20:16 * xerox coughs
07:20:45 <xerox> dons: sorry, the patch should do words, not lines.
07:20:47 <dons> oh, it used 'build' too.
07:20:58 <sjanssen> is there a plan to avoid the fusion/seq trouble?
07:21:26 <dons> yeah, be careful with seq
07:21:30 <sjanssen> is it even possible to avoid it with fold/build fusion?
07:21:41 <dons> and in the longer term, switch to stream-based fusion, which doesn't rely on laziness to force values
07:21:52 <dons> sjanssen: if the _user_ doesn't throw seq around
07:22:27 <roconnor> @what fps
07:22:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
07:22:31 <dons> i'm interested to see if other's code will fail, now that ghc 6.5 matches rules much better ... i.e. more build/foldr fusion interacting with more seqs
07:22:40 <sjanssen> dons: streams like the new ByteString fusion, yeah?  Is that in a published paper?
07:22:47 <dons> not yet ...
07:22:56 * xerox scratches head
07:23:03 <dons> but we had a big discussion about how it avoids seq-sick-iness
07:23:09 <vincenz> :(
07:23:28 <vincenz> dons: that sounds like something else
07:23:40 <vincenz> just remove the ck
07:23:50 * roconnor finds it hard to imagine such an example
07:23:50 <dons> ?
07:23:57 <dons> oh, let me find you an example
07:24:14 <dons> unpackFoldr (PS fp off len) f ch =
07:24:15 <dons>     unsafePerformIO $ withForeignPtr fp $ \p -> do
07:24:15 <dons>         let loop a b c | a `seq` b `seq` False = undefined -- needs the strictness
07:24:17 <dons>             loop _ (-1) acc = return acc
07:24:20 <dons>             loop q n    acc = do
07:24:23 <dons>                a <- peekByteOff q n
07:24:25 <dons>                loop q (n-1) (a `f` acc)
07:24:28 <dons>         loop (p `plusPtr` off) (len-1) ch
07:24:33 <dons> now, ignore the unsafes, they don't hurt
07:24:38 <dons> the problems is the strict accumulator
07:24:59 <dons> which build/foldr rewrites into a list of undefineds, when I take a head of the result of this list
07:25:25 <dons> so, if you're generating strict lists (maybe in a custom fold?) and build/foldr triggers, something could happen
07:25:41 <dons> nonetheless, this has only happened once that we know of
07:25:51 <shapr> ndm: Ah, that's why the buildbot site is broken?
07:26:28 <SamB> dons: I thought if a pattern matched, you had to stick with it even if no guards succeeded?
07:26:29 <dons> oh, the above code is actually the working version. there's a missing `seq` c
07:26:32 <dons> which was in the original
07:26:57 <dons> ? the False branch always fails, and ghc knows this.
07:27:14 <dons> so it just treats it as a verbose bang pattern :)
07:27:35 <SamB> but... since when is that legal Haskell? am I misremembering or something?
07:27:42 <dons> sure.
07:27:59 <SamB> er, I mean, since when is it legal for that Haskell to do what it is supposed to do
07:28:10 <dons> hrm?
07:28:17 <dons> what bit is troubling you?
07:28:27 <SamB> nevermind, I guess I remembered wrong...
07:28:36 <dons> > f a | a `seq` False = undefined | otherwise = 1 in f ()
07:28:36 <lambdabot>  Parse error
07:28:38 <shapr> Is it against the spirit of the bug fixing part of the MSR interview to ask questions and possibly advice from #haskell?
07:28:45 <dons> > let f a | a `seq` False = undefined | otherwise = 1 in f ()
07:28:46 <lambdabot>  1
07:28:56 <SamB> MSR interview?
07:29:04 <shapr> Microsoft Research
07:29:15 <SamB> microsoft loves embrace & extend, don't they?
07:29:26 <shapr> I dunno, if they'll pay me to write Haskell I'll smile and agree.
07:29:36 <SamB> so why wouldn't they like you to get help from #haskell?
07:29:44 <dcoutts> shapr, ah so bug fixing is part of the interview?
07:29:47 <shapr> Since keeping everything BSD licensed is part of the conditions of working on GHC, I won't argue.
07:29:52 <shapr> dcoutts: Yeah it is.
07:29:54 <dcoutts> shapr, or just informally?
07:30:03 <SamB> well, I wasn't being negative
07:30:20 <shapr> The Simons want a developer log of a bugfix from each interviewee.
07:30:25 <dcoutts> shapr, asking Qs is ok if it's what one would do normally in the context of the job I'd say
07:30:25 <SamB> I just think that asking for help on IRC channels matches nicely with MS's ideals of getting something for nothing
07:30:31 <shapr> hah
07:30:38 * Philippa seconds dcoutts
07:31:00 <Philippa> possibly worth mentioning you did so. Having contacts makes you more valuable, no?
07:31:06 <shapr> Yeah, good point.
07:31:13 * dcoutts now understands why Lemmih wanted him to submit that trivial bug report ;-)
07:31:16 <SamB> especially since you are like one of our favorite people ;-)
07:31:25 <shapr> Anyway, I'm working on http://hackage.haskell.org/trac/ghc/ticket/706
07:31:27 <lambdabot> Title: #706 (GHC links _stub.o files regardless of whether any 'foreign import' decls r ...
07:31:32 <Lemmih> dcoutts: (:
07:31:42 <shapr> SamB: :-)
07:31:43 <dons> xerox: how does this code go wrong, that you sent me?
07:32:03 <xerox> dons: ./lambdabot
07:32:09 <xerox> choose a b c "just hangs" here
07:32:28 <SamB> aren't you supposed to type something after ./lambdabot?
07:32:36 <roconnor> dons: where's the list in your example?
07:32:43 <shapr> Anyway, the deal is that ForeignStubs are not passed into DriverPipeline.compile, so $MODULE_stub.o is linked into the binary if there's a $MODULE, even if $MODULE doesn't actually have any ForeignStub code at all.
07:32:43 <SamB> like a command or something?
07:32:47 <dons> roconnor: 'acc'
07:32:53 <xerox> SamB: it answers "botsnack" with a ":)"
07:32:55 <emertens> Does anyone have a recommendation for which ODBC library to use?
07:33:00 <xerox> My command is in the same module
07:33:03 <dons> acc was strict, and the build/foldr rule for head/build rewrote it to something that failed
07:33:05 <emertens> Are any of them more developed or stable than the others?
07:33:18 <dons> roconnor: you want the mail spj sent me explaining the problem?
07:33:19 <dcoutts> emertens, I reccomend HDBC
07:33:23 <xerox> dons: also, my command isn't listed in "list dummy"
07:33:24 <shapr> But I can't quite figure out which of the ADTs should hold ForeignStubs. Possibly it should be Module.Module?
07:33:28 <SamB> xerox: oh
07:33:28 <roconnor> dons: yes
07:33:35 <dons> xerox: did you add it to the moduleCommands?
07:33:52 <xerox> moduleCmds   _ = "eval" : {-"moo" : -} map fst dummylst
07:34:10 <shapr> On the good side, yesterday was the first time I looked at the insides of GHC, and it's much easier to learn than I expected.
07:34:14 <xerox> I've added my tuple (String,String -> String) to the dummylst.
07:34:26 <dcoutts> shapr, just don't look at the typechecker ;-)
07:34:31 <shapr> Ok :-)
07:34:39 <xerox> May it be something like stale object files?
07:34:39 <dcoutts> yeah, other bits are not too bad
07:34:44 <dons> roconnor: i've got a few mails on the topic, i'll fwd them
07:34:51 <SamB> xerox: I was going to ask about that
07:35:07 <xerox> SamB: runhaskell Setup.hs clean ?
07:35:17 <SamB> er, I dunno
07:35:23 <SamB> haven't built lambdabot lateley
07:35:27 <SamB> er, lately
07:35:32 <xerox> Re-trying that way.
07:36:01 <sjanssen> @keal
07:36:02 <lambdabot> i changed my user od
07:36:34 <dons> roconnor, sent
07:37:25 <xerox> "unknown command" now
07:37:27 <xerox> Cool.
07:37:28 <shapr> Ok, so ModIface is info before linking, and ModDetails is info after linking. Sounds like ForeignStubs data should be in ModIface, right?
07:37:37 <SamB> shapr: the Module datastructure does *sound* appropriate, though I'm not sure if it is as simple as it sounds
07:38:09 * SamB doesn't know what he is talking about
07:38:12 <shapr> I just checked, Module.Module is just a FastString, so definitely not there.
07:38:17 <SamB> heh
07:38:34 <SamB> what is this about "after linking"?
07:38:43 <xerox> grep -rn ForeignStubs ghc/ # :)
07:39:12 <sjanssen> dons: should I be able to access your fps-unstable repo?
07:39:38 <SamB> what exactly does GHC ever do after linking?
07:40:16 <dcoutts> sjanssen, yes
07:40:38 <shapr> SamB: Line 304 of HscTypes says that ModIface holds before linking info, and is written to an interface file. ModDetails is after linking, and is the linked form of the mi_decls field.
07:40:57 <sjanssen> looks like dons has permission problems on a few files
07:41:02 <dons> oh, fixing...
07:41:14 <SamB> I still don't get what is this time called "after linking"
07:41:55 <dons> done.
07:42:00 <dons> i wonder how that happened.
07:42:12 <sjanssen> thanks
07:44:28 <dcoutts> dons, I'm getting a stack overflow in the up/up fusion benchmark
07:44:39 <dons> oh, hmm. interesting
07:44:40 <dcoutts> dons, however I think that's jsut because the foldl code is now correct
07:44:42 <dcoutts> :-)
07:44:47 <dons> ah!
07:44:51 <dcoutts> because it's implementing foldl rather than foldl'
07:45:01 <dons> right. sounds fair enough
07:45:11 <dcoutts> ie it does a lazy fold from the end down
07:45:31 <dons> yep
07:45:37 <dcoutts> so we'd expect this to build lots of thunks: P.foldl (const.(+1)) (0::X)
07:46:14 <dons> right
07:46:20 <dcoutts> foldl is a lazy producer and so should be used with a lazy consumer
07:47:32 <roconnor> @type foldl
07:47:33 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:47:50 <roconnor> @type \f n -> foldr (flip f) n
07:47:52 <lambdabot> forall a c. (c -> a -> c) -> c -> [a] -> c
07:47:55 <dcoutts> roconnor, we're taling about folds on ByteString
07:48:03 <roconnor> I know
07:48:23 <roconnor> I'm wondering what the difference between foldl and foldr . flip is.
07:49:15 <roconnor> @type foldr . flip
07:49:17 <lambdabot> forall a c. (c -> a -> c) -> c -> [a] -> c
07:49:40 <roconnor> my guess is that they are the same.
07:49:57 <sjanssen> > foldl (flip (:)) [] [1..10]
07:49:58 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:50:07 <roconnor> or not
07:50:08 <sjanssen> > foldr (flip $ flip (:)) [] [1..10]
07:50:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:50:35 <xerox> Behavior wrt infinite lists?
07:50:42 <vincenz> > foldr (:) [] [1..10]
07:50:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:50:46 <sjanssen> roconnor: they're different
07:51:00 <vincenz> > foldr (:) [] [1..]
07:51:00 <dons> > foldl (flip (:)) [] (undefined:[1..10])
07:51:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:51:01 <lambdabot>  Undefined
07:51:04 <roconnor> all functions of the same type should be the same ;)
07:51:09 <dons> > foldr ((:)) [] (undefined:[1..10])
07:51:10 <lambdabot>  Undefined
07:51:21 <vincenz> roconnor: that's gonna make math hard
07:51:54 * dons is happy to distinguish bottoms
07:52:06 <vincenz> dons: male and female?
07:52:20 <dons> vincenz: always with the pron jokes, you are.
07:52:23 <vincenz> heh
07:52:40 <vincenz> dons: you were asking for it
07:53:34 <vincenz> any suggestions for name for the team?
07:53:43 <edwardk> team?
07:53:51 <xerox> bottoms?
07:53:54 <edwardk> yeah
07:53:54 * xerox runs away
07:53:57 <edwardk> thats where i was going =)
07:54:04 <Lemmih> I like it.
07:54:34 <bortzmeyer> @hoogle String -> Regex
07:54:34 <edwardk> well, you either have to be a bottom or you eventually terminate. I'd rather live forever =)
07:54:35 <lambdabot> Text.Regex.mkRegex :: String -> Regex
07:54:35 <lambdabot> Text.Regex.mkRegexWithOpts :: String -> Bool -> Bool -> Regex
07:54:55 <edwardk> even if it can be a little uncomfortable at times.
07:55:13 <xerox> edwardk!
07:55:21 <bortzmeyer> @hoogle CalendarTime -> String
07:55:21 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
07:55:22 <lambdabot> System.Time.ctTZName :: CalendarTime -> String
07:55:22 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
07:57:17 <vincenz> bbl
07:57:20 <roconnor> dons: was your unpackFoldr producting a list?
07:57:46 <dons> yeah
07:57:52 <dons> which i was then taking the head of
07:58:05 <roconnor> dons: and as a completely separate question do you have bytestrings for Word32 and Word64?
07:58:14 <dons> check the 'unpack.hs' file in tests/ in fps.
07:58:15 * roconnor starts to understand the problem
07:58:19 <dons> sjanssen's working on this
07:58:53 <dons> here, http://www.cse.unsw.edu.au/~dons/code/fps/tests/unpack.hs
07:59:02 <dons> head (my_unpack x)
07:59:07 <dons> would fail with head undefined
07:59:27 <dons> due to the following rule firing
07:59:28 <dons> "head/build"    forall (g::forall b.(a->b->b)->b->b) .
07:59:28 <dons>         head (build g) = g (\x _ -> x) badHead
08:00:01 <dons> dcoutts: a puzzle. if you watch tv on your mobile phone in the uk, do you need a tv license?
08:00:11 <dcoutts> dons, no idea
08:00:26 <dcoutts> dons, I've neither a tv license nor a tv
08:00:35 <dons> ah. very wise.
08:00:44 <sjanssen> "tv license"?
08:00:45 <xerox> TV license
08:00:45 * dcoutts listens to radio 4!
08:00:49 <xerox> O_o
08:01:07 <emertens> Does anyone here know how to set the PATH when building with visual haskell?
08:01:07 <dcoutts> sjanssen, to fund the public broadcaster
08:01:31 <dons> instead of having constant adverts during PBS NewsHour
08:01:43 <dons> encouraging people to donate
08:01:51 <dons> much simpler to just tax everyone, like in .au
08:02:20 <dons> but in the uk, its more targetted, just those with TVs pay
08:02:39 <dcoutts> dons, and it means the get enough dosh to put on decent stuff
08:02:47 * shapr has no TV license, as he does not own a TV
08:02:58 <dons> dcoutts: right.
08:03:00 <dcoutts> yeah I'm a freeloader as I just listen to BBC radio :-)
08:03:05 <dcoutts> no license for that
08:03:06 <dons> ah true!
08:03:14 <dons> so do i.
08:03:19 * dcoutts hugs the BBC
08:03:21 <dons> and i've never got my license.
08:03:28 <tony2> you can watch news 24 online for free also.
08:03:42 * dons thanks all those with tv licenses 
08:03:50 * dcoutts too
08:04:47 <tony2> <-- doesn't know how to do that * thingy that dons and dcoutts just did. I use XChat.
08:05:10 <dcoutts> tony2, use /me bla blah
08:05:13 * dcoutts bla blah
08:05:28 * tony2 horay! 
08:05:36 <dons> hmm, manually entering \1ACTION foo foo \1 probably works, if you can get a 0x1 byte somehow
08:05:50 * dcoutts likes to talk about himself in the 3rd person
08:06:24 <dons> though according to our statistics, shapr and Igloo are the worst at this :)
08:06:30 <dcoutts> heh
08:06:43 <dcoutts> dons, where do you collect these stats?
08:06:50 <dons>  here, for those who weren't here earlier, http://www.cse.unsw.edu.au/~dons/irc/
08:06:50 <lambdabot> Title: Haskell IRC Activity
08:07:29 <xerox> What's that!
08:07:54 <dons> analysis of the #haskell over time
08:08:00 <xerox> Great :D
08:08:05 * dcoutts is worried that he's 6th on the list
08:08:18 <dcoutts> on the list of blabbermouths :-)
08:08:23 <xerox> haha
08:08:34 <madpickle> 200,000 lines?
08:08:40 <madpickle> jesus man, you talk too much
08:08:46 <dons> well, you should look at the Total page,
08:08:54 <dons> there's some 116M of text generated
08:09:20 <xerox> That's crazy
08:09:21 <dons> oh!! we're close to our 2M line..  1993900.
08:09:26 <xerox> But cool nevertheless :D
08:09:26 <madpickle> i used to have 10 years worth of IRC logs
08:09:41 * SamB is 11th
08:09:46 <madpickle> meh
08:09:49 <SamB> and that doesn't include SamB_XP, either
08:09:49 <xerox> Most used words: think
08:09:50 <madpickle> you just had to beat me?
08:09:50 <madpickle> :P
08:10:21 <xerox> <- 9th !
08:10:51 <edwardk> I was saved from the list of blabbermouths by virtual of not having been around for the entire period you collected stats on =)
08:10:53 <SamB> apparantly SamB_XP yells a lot, too
08:11:03 <edwardk> er by virtue
08:11:29 <boegel> Boegel is 21th
08:11:36 <boegel> s/21th/21st
08:12:02 <dons> I find it amusing that i'm lambdabot's faithful follower
08:12:05 <SamB> hmm, I was looking at another list before
08:12:13 * tony2  (n=tony2@212.158.255.107) has left #haskell
08:12:23 <xerox> In 2001 Mandelbrot was the 10th most used word
08:12:23 <dons> SamB: they're regenerated daily. the 2006 and Total page.
08:12:24 <madpickle> heheh
08:12:25 <xerox> That's fun!
08:12:28 <madpickle> sorry tony, but that won't work
08:12:29 * tony2 I'm still here
08:12:44 <SamB> well, last time I was looking at the 2006 one I guess
08:12:45 <boegel> "Boegel isn't a sad person either, smiling 18.7% of the time."
08:12:47 <boegel> :D
08:13:06 <boegel> :/ :| :) :D
08:13:16 <BCoppens> boegel: =P
08:13:52 <SamB> but I'm in #11 on both total and 2006, apparantly
08:14:01 <dons> that's worrying
08:14:10 <xerox> haha
08:14:18 <dons> though vincenz must be the best-improved blabbermouth
08:14:25 <SamB> well, I'm not in 2001
08:14:26 <dons> since almost all his have been this year.
08:14:33 <xerox> Indeed.
08:15:19 <dons> i like that lambdabot has become more and more verbose over the years
08:15:26 <dcoutts> I like the fact that shapr is considered agressive :-)
08:15:32 <SamB> nor 2002, apparantly
08:15:33 <dcoutts> shapr is a very aggressive person. He/She attacked others 74 times.
08:15:33 <dcoutts> For example, like this:
08:15:33 <dcoutts>      * shapr beats an innocent bystander with a lambda
08:15:42 <madpickle> lol
08:15:47 <BCoppens> :D
08:15:48 <dons> well, all those spikey lambdas he throws around
08:15:55 <dcoutts> well quite
08:16:21 <dons> in 04, lambdabot was 6th, 05, 2nd, and now 1st
08:16:23 <SamB> don't see myself in 2003...
08:16:31 <dons> so that'd be the AI kicking in...
08:16:54 <SamB> I'm not in the top list in 2004, but I am mentioned
08:17:56 <SamB> ah, I was #6 in 2005
08:18:16 <SamB> 6 	SamB	508879735113 18445	508879735113	142516	today	"we should add logging to lambdabot ;-)"
08:18:33 <dons> hehe
08:19:13 * SamB owndres where the 5088s come from
08:19:19 <SamB> those numbers are all messed up
08:19:32 <SamB> er, wait
08:19:51 * xerox laughs
08:19:53 <xerox> http://kungens.kemi.fi/%7Eshae/gvr.html
08:19:55 <lambdabot> Title: gvr question list
08:19:55 <SamB> oh, the big huge "numbers" are from jammed-together images
08:20:31 <SamB> heh
08:20:47 <SamB> I like that last one - I would definately reconsider ;-)
08:20:49 <dcoutts> dons, hmm actually it's not that clear, the foldr tests don't run out of stack while the foldl do
08:20:55 <dcoutts> but they should be symetrical
08:21:12 <dcoutts> one working low to high indexes and the other the other way around
08:21:24 <dcoutts> but accumulate lazily tough
08:21:43 <dcoutts> both accumulate lazily though
08:21:53 <dons> hmm
08:21:54 <roconnor> w00t
08:22:04 <roconnor> Prelude Data.Real.CReal Data.Interval Data.Real.Complete> join (supremum (compactInterval (Interval (0,3))) sinCts) 0.01
08:22:04 <roconnor> 1%1
08:22:23 <dcoutts> afoldl f z = strConsumerDn (foldrS (flip f) z)
08:22:24 <dcoutts> afoldr f z = strConsumerUp (foldrS f z)
08:22:25 <dons> ICFP program out, http://icfp06.cs.uchicago.edu/schedule.html
08:22:27 <lambdabot> Title: ICFP 2006 Program
08:23:00 <roconnor> bah, USA
08:23:05 <dons> ?karma+ bringert -- got into icfp!
08:23:05 <lambdabot> bringert's karma raised to 4.
08:23:07 <roconnor> people who travel there get arrested.
08:23:25 <roconnor> and deported to Siria
08:23:30 <roconnor> Syria
08:23:52 <roconnor> or held for interigation by Adobe
08:24:23 <dcoutts> for crimes against the corporation?
08:24:37 <dons> crimes against document preparation
08:25:04 * dons `ap` sleep
08:25:17 <dcoutts> g'night dons
08:25:31 <SamB> how is deciphering ROT13 a crime against document preparation?
08:25:49 <SamB> documents are *supposed* to be printable and viewable in all sorts of viewers...
08:25:56 <dcoutts> because it's an effective technical measure protected bythe DMCA
08:26:12 * xerox sings YMCA
08:26:57 <sjanssen> DMCA! It's fun to violate the D M C A!
08:27:13 <jgrimes_> have any of you read "essentials of programming languages" ? It was suggested as prereading in "Types and Programming Languages"
08:27:28 <SamB> I contend that ROT13 is not very effective
08:27:54 <SamB> in the past, it has always been an ineffective, voluntary protection against spoilers and other things the reader may not wish to see
08:28:17 <dylan> Try ROT26 then ;)
08:28:37 <SamB> that isn't even effective enough to protect the reader from spoilers
08:30:25 <xerox> SamB: agreed
08:30:50 <roconnor> ROT13 is effective in the sense that it is a computable algorithm.
08:31:14 <xerox> That doesn't teach much... lawmakes?
08:31:20 <xerox> lawmakers, even.
08:31:36 <SamB> I was under the impression that "effective" was supposed to mean it actually did something "useful"
08:31:55 <roconnor> xoring data with the binary expansion of the turing probability is not an effective measure.
08:32:00 <roconnor> ;)
08:32:05 <SamB> hmm?
08:32:09 <SamB> oh oh oh
08:32:12 <xerox> Binary expansion?
08:32:18 <roconnor> sorry
08:32:18 <xerox> Oh.
08:32:23 * xerox looks at SamB
08:32:30 <roconnor> binary decimal digits
08:32:46 <roconnor> how do you say that?
08:33:01 <xerox> I think the binary digit expansion of the ...
08:33:10 <SamB> but why would they bother restricting it to computable algorithms?
08:33:31 <roconnor> jking
08:33:32 <SamB> I mean, nobody is going to try to reverse uncomputable algorithms
08:33:49 <SamB> or non-algorithms
08:33:53 <xerox> Yes but that doesn't assure you...
08:33:59 <SamB> yeah, yeah...
08:34:03 <xerox> ...you yourself sending the message, I mean.
08:34:19 <SamB> hmm? message?
08:34:29 * xerox maybe misunderstood
08:34:32 <lispy> BCD? eww.....
08:34:48 <roconnor> oh wait, does effective mean polynomial time?
08:35:01 <SamB> I don't think lawyers no what that *means*, roconnor
08:35:08 <xerox> No way the layers...
08:35:09 <SamB> er, *know
08:35:13 <xerox> <Interrupted by SamB>
08:35:36 <SamB> I think "effective" is supposed to mean it actually does something to prevent copying
08:35:47 <xerox> I agree.
08:36:04 <roconnor> well, encryption doesn't prevent copying
08:36:11 <SamB> indeed
08:36:18 <SamB> it does make it harder to print, though
08:36:22 <xerox> It prevents using.
08:36:34 <SamB> quite so
08:36:38 <roconnor> SamB: cat -v ?
08:36:49 <xerox> Who cares of printing?
08:37:19 <roconnor> anyhow, certainly ROT13 would be implemented in polynomial time.
08:37:27 <roconnor> ;)
08:37:32 <xerox> And why should that matter?
08:38:40 <ndm> shapr: i broke buildbot 10 mins after our build master left on holiday :(
08:38:41 <SamB> the only effective means I know of is to use optical media that has things on it that can't be put on it by ordinary (consumer) means...
08:39:14 <xerox> SamB: anybody uses it?
08:39:21 <SamB> yeah
08:39:23 <lispy> nintendo uses something like that
08:39:47 <SamB> don't DVDs do that too?
08:40:00 <SamB> I know playstation does pretty much does...
08:40:06 <xerox> But the things you read those media with do know...
08:40:10 <lispy> well, that's what the GC uses is dvd's...specially ones developed by...Sony?
08:40:34 <SamB> playstation uses invalid sectors somewhere
08:40:56 <Philippa> PSX CDs're physically different, too
08:41:02 <SamB> if the sectors aren't invalid or not in the right ways, it will refuse to use them...
08:41:12 <SamB> Philippa: I thought that was just to look nice ;-)
08:41:24 <roconnor> Knuth's characterization: Effectiveness: "... all of the operations to be performed in the algorithm must be sufficiently basic that they can in principle be done exactly and in a finite length of time by a man using paper and pencil"
08:41:26 <SamB> in fact, I still do
08:41:40 <Philippa> no, I'm pretty sure the drive can tell the difference. AFAIK you can do a bit-for-bit copy and the PSX'll still ignore it
08:42:09 <SamB> well, I think the problem is that somewhere along the line the sectors get corrected
08:42:09 <Philippa> modern image formats can cover all the invalid sector stuff, you still need to chip or otherwise trick the PSX
08:42:28 <dmhouse> Eurgh. It's too hot.
08:42:33 <SamB> maybe the burner does it
08:42:34 <xerox> "if the sectors are not invalid or not" SamB is crazy
08:42:48 <xerox> "in the right ways"
08:42:51 <Philippa> it might be crazy, but it's an ancient technique
08:42:58 <SamB> if (the sectors are not invalid) or (not in the right ways)
08:43:01 <xerox> I mean, the construction of the phrase :)
08:43:03 <Philippa> mark certain sectors invalid, put data in them anyway...
08:43:14 <xerox> hehe
08:43:55 <xerox> if (sectors == not Invalid) || (not $ right ways) then ..
08:44:02 <SamB> no no
08:44:30 <xerox> if (sectors /= Invalid) || (not $ right ways) then ..
08:44:49 <SamB> if (sectorsValid disc || sectorsDoNotContainSecretHandshake disc)
08:45:05 <lispy> > if (sectors /= Invalid) || (not $ right ways) then True else False
08:45:13 <lispy> er...
08:45:14 <xerox> The secret shake image is creemy.
08:45:30 <lispy> apparently sending commands to lambdabot summons it :)
08:45:35 <ihope_> In a Quantum Haskell, could we have some functions like "zero :: Qubit", "one :: Qubit", "hadamard :: Qubit -> Qubit", "cnot :: Qubit -> Qubit -> (Qubit, Qubit)", etc., then "measure :: Qubit -> Bool"?
08:45:58 <ihope_> Or would some of those have to be in IO?
08:45:59 <SamB> Quantum Haskell... I don't think that works!
08:46:11 <SamB> because Haskell is purely functional and QM is not.
08:46:17 <lispy> ihope_: you'd probably use complex numbers to represent Qubits
08:46:31 <SamB> at least, I don't think it is...
08:46:38 <xerox> SamB: it really depends
08:46:40 <SamB> certainly not deterministic...
08:46:51 <xerox> Well
08:46:59 <lispy> SamB: they have a modified TM for quantum comuting
08:47:00 <xerox> There are functional quantum language
08:47:02 <lispy> computing*
08:47:07 <SamB> maybe it would work
08:47:15 <xerox> "TM" ?
08:47:19 <lispy> turing machine
08:47:21 <SamB> but you couldn't test anything, could you?
08:47:26 <lispy> test?
08:47:31 <lispy> oh
08:47:34 <xerox> Oh the quantum turing machine is not really expectable to great deals
08:47:35 <SamB> well, at least you couldn't loop
08:47:38 <roconnor> lispy: I'd use the standard unit ball representation of a qubit.
08:47:38 <ihope_> Well, it's not like you could measure a qubit and get one value, then measure it again and get a different value... then again, it might be reconstructed each time.
08:47:39 <lispy> if (myQubit) ...
08:47:41 <xerox> SamB wait!
08:47:51 <SamB> or at least you'd have to have funny conditions...
08:47:54 <ihope_> What if measure were Qubit -> IO Bool?
08:47:59 <roconnor> Actually, you need to maintain entanglement between qubits
08:48:05 <roconnor> that's tricky
08:48:19 <xerox> http://lambda-the-ultimate.org/node/1618
08:48:20 <lambdabot> Title: A brief survey of quantum programming languages | Lambda the Ultimate
08:48:20 * lispy leaves for work
08:48:32 <SamB> and you have to avoid collapsing the wave functions or whatever...
08:48:34 <SamB> right?
08:48:37 <xerox> ihope, I am reading too, I want to come up with an own monad.
08:48:51 <edwinb> Is it possible to persuade cabal not to delete intermediate files (like the .hs and .out output from happy)?
08:49:04 <roconnor> Isn't there already a Haskell implementation of this?
08:49:27 <xerox> It's more likely you persuade happy to not do it anymore, and then tell cabal to remind it.
08:50:06 <edwinb> happy wouldn't delete the file it generates...
08:50:27 <xerox> Hmmm.
08:50:57 <xerox> I don't know :-|
08:51:10 <edwinb> oh, actually, I am dumb. It doesn't :)
08:51:21 <edwinb> (cabal doesn't remove it, that is)
08:51:32 <ihope_> Well, if the gates are pure... hmm.
08:52:08 <SamB> I'm pretty sure that loops have to be non-quantum
08:52:12 <ihope_> Well, you can have "measure x", or you can have "measure (hadamard x)", but you can't have both, can you?
08:52:59 <ihope_> Even putting measure into the IO monad won't help.
08:53:17 <SamB> though they need not have to collapse wave functions, depending on whether they need to test results of quantum computations or not
08:53:31 <roconnor> @google Modeling Quantum Computation in Haskell
08:53:37 <lambdabot> http://portal.acm.org/citation.cfm?id=871900&dl=ACM&coll=ACM&CFID=15151515&CFTOKEN=6184618
08:53:37 <lambdabot> Title: Modeling quantum computing in Haskell
08:54:12 <xerox> ACM!
08:54:48 <xerox> Yeeek, why can one read it?
08:54:52 <ihope_> Hmm...
08:54:58 <ihope_> data Cat = Dead | Alive
08:55:10 <xerox> No, more choice.
08:55:19 <xerox> The product in fact?
08:55:31 <dmhouse> data Cat = Dead | Alive | Superposition
08:55:37 <ihope_> No, wait...
08:56:35 <ihope_> schroedinger = do {bit <- zero; hadamard bit; result <- measure bit; if result then Alive else Dead} -- Schroedinger's cat in Haskell
08:56:35 * xerox laughs
09:05:00 <emertens> Is there a trick to installing HDBC-ODBC that might not be in the readme? (on windows)
09:08:58 <xerox> emertens: asking CosmicRay <blink>
09:10:09 <CosmicRay> emertens: yes, there is a thread about this on the libraries list just this week, in fact.
09:10:18 <CosmicRay> let me get you a link.
09:10:58 <CosmicRay> http://article.gmane.org/gmane.comp.lang.haskell.libraries/4909/match=hdbc+odbc
09:11:03 <lambdabot> Title: Gmane -- Mail To News And Back Again
09:11:31 <emertens> sweet
09:14:31 <ihope_> Hmm, there needs to be a way to prevent people from hadamard'ing a qubit after it's been measured.
09:15:10 <vincenz> Anyone regged on yi.org?
09:15:33 <vincenz> secondly
09:15:37 <vincenz> how do I see my ip?
09:16:04 <ihope_> 87.244.185.124 :-)
09:16:39 <ihope_> Either whois yourself, or go to one of the many results of a Google search for "what is my ip address".
09:16:41 <vincenz> \o/
09:16:59 <zarvok> vincenz: Are you subscribed to icfp-discuss?
09:17:43 <zarvok> From my end it looks like the last few messages appeared twice, but I can't figure out what's going on, so I was wondering if everyone else is seeing it too
09:17:57 <palomer> \o/ ftw!
09:18:01 <vincenz> zarvok: I am not
09:18:07 <vincenz> zarvok: where is this?
09:18:19 <vincenz> zarvok: was just cleaning up our team site :)
09:18:23 <zarvok> http://www.icfpcontest.org/contact.shtml
09:18:26 <vincenz> and setting up our network etc
09:18:27 <lambdabot> Title: ICFP Programming Contest, 2006 : Contact
09:18:30 <zarvok> there are mailing lists there
09:19:11 <vincenz> isn't the freeform list dangerous?
09:19:20 <zarvok> perhaps, but it's been fine in past years
09:19:34 <vincenz> I'm regged
09:19:39 <zarvok> We figure it's better to provide a channel for communication we can easily monitor
09:19:59 <zarvok> Otherwise one will just spring up
09:20:27 <ihope_> ...Actually, wouldn't measure just be another operation of qubits? It just changes them; it doesn't render them useless or anything.
09:20:36 <zarvok> Well, looking at the archive, it seems the last two messages only appeared once, maybe it's something on my end.  Ah well
09:20:39 <vincenz> zarvok: point taken
09:21:31 <vincenz> Time to register our team
09:21:45 <zarvok> vincenz: we're up to 305 registrations now
09:21:46 <vincenz> Just one problem... we don't have a name yet!
09:21:50 <zarvok> of course, some are dups
09:22:01 <vincenz> even though we're most likely one of the first to start organizing for this :P
09:22:05 <zarvok> heh
09:22:46 <vincenz> what time are you posting the material?
09:23:00 <vincenz> And what happens if you don't reg?
09:23:00 <zarvok> when it's ready
09:23:24 <zarvok> and you'll need to register at some point, but I can't say more
09:23:28 <vincenz> ok
09:24:41 <zarvok> hmm... I had forgotten my name appears as "Big Chris" on outgoing messages... maybe I should change that for the icfp :)
09:25:17 <zarvok> glad I looked at the archives
09:26:14 <ihope_> @type iterate
09:26:16 <lambdabot> forall a. (a -> a) -> a -> [a]
09:26:24 <ihope_> @hoogle Int -> (a -> a) -> a -> [a]
09:26:26 <lambdabot> No matches, try a more general search
09:29:38 <zarvok> So if I give lambdabot a command like iterate (\x -> x+1) 5, will it do something intelligent or spit out numbers forever?
09:29:46 <vincenz> it's intelligent
09:29:53 <vincenz> a) cuts off long data
09:29:56 <vincenz> b) terminates after x seconds
09:30:02 <vincenz> > iterate (+1) 1
09:30:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:30:04 <zarvok> > iterate (\x -> x+1) 5
09:30:05 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
09:30:21 <dcoutts> > let f x = f x in f 3
09:30:22 <lambdabot>  Add a type signature
09:30:30 <dcoutts> > let f x = f x in f (3 :: Int)
09:30:31 <lambdabot>  Add a type signature
09:30:42 <zarvok> interestingly, if I PM it it spits out enough messages for my IRC client to auto-ignore it
09:30:51 <zarvok> but in the main channel it behaves differently
09:30:54 <dcoutts> > let { f :: Int -> Int; f x = f x } in f 3
09:30:58 <zarvok> feature or bug?
09:30:59 <lambdabot> Terminated
09:31:28 <Cale> zarvok: feature, you can get more output in private :)
09:32:15 <vincenz> Cale: !
09:33:04 <Cale> vincenz: ?
09:35:47 <vincenz> zarvok: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
09:35:49 <lambdabot> Title: Not Vincenz's Wiki | Icfp / Main
09:36:20 <ndm> dcoutts: i just got PropLang to change the value of a variable
09:36:30 <dcoutts> good good
09:36:39 <vincenz> zarvok: the pages that detail progress are of course member only
09:36:55 <zarvok> vincenz: nicely reorganized since the last time I looked
09:37:50 <dcoutts> ndm, you can simulate the binding to a widget property by picking one example where it provides signals (as we don't have the general gobject prop notification bound yet)
09:38:30 <vincenz> zarvok: thx, yeah it needed some cleaning
09:38:39 <dcoutts> ndm, eg a checkbox using onToggled
09:38:41 <ndm> dcoutts: ok, will look into that tomorrow then, haven't hooked up gtk events yet, only mine
09:38:53 <ndm> anyway, gtg, but hopefully should have a demo tomorrow
09:39:07 <dcoutts> ndm, sure, just sugesting an easy example that doesn't need changing gtk2hs yet
09:39:32 <ndm> dcoutts: i have entry.onInsertAtCursor as my example
09:39:38 <dcoutts> ok
09:41:56 <ihope_> @quote lambdabot
09:41:57 <lambdabot>  Of course i'm female
09:42:18 <ihope_> Um.
09:42:24 <dcoutts> it's true
09:42:33 <ihope_> @quote lambdabot
09:42:34 <lambdabot>  tERmIN473d
09:42:39 <ihope_> @quote lambdabot
09:42:40 <lambdabot>  fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
09:43:00 <ihope_> Eh...
09:43:05 <vincenz> LOL
09:43:24 <roconnor> a small team consists of 0-4 people!
09:43:25 <dcoutts> http://www.cse.unsw.edu.au/~dons/images/lambdabot.png
09:43:28 <vincenz> @. @leet @type return
09:43:28 <lambdabot> compose module failed: IRCRaised Parse error: "@leet"
09:43:35 <vincenz> @. leet type return
09:43:35 <lambdabot> compose module failed: IRCRaised Parse error: "leet"
09:43:40 <dcoutts> roconnor, yeah a team of 0 would be interesting
09:43:41 <vincenz> @leet me
09:43:41 <lambdabot> Maybe you meant: last list seen
09:43:44 <vincenz> hmm
09:43:48 <ihope_> @. elite type return
09:43:49 <lambdabot> fOr4Ll (M :: * -> *) a. (moN4d m) => A -> /\/\ 4
09:43:52 <vincenz> thx
09:43:55 <roconnor> @1337
09:43:56 <lambdabot> Unknown command, try @list
09:44:09 <vincenz> @. . . elite elite elite type return
09:44:09 <lambdabot> compose module failed: IRCRaised Parse error: "3lI7e"
09:44:15 <vincenz> @. . elite elite elite type return
09:44:17 <lambdabot> compose module failed: IRCRaised Parse error: "eLIte"
09:44:27 <vincenz> @. . elite . elite type return
09:44:28 <lambdabot> compose module failed: IRCRaised Parse error: "E1it3"
09:44:30 <vincenz> hmm
09:44:37 <vincenz> @. elite . elite type return
09:44:38 <lambdabot> fora|| (/\/\ :: * -> *) a. (MoN4D /\/\) => a -> /\/\ 4
09:45:07 * vincenz shrugs and stop
09:45:45 <ihope_> @elite Is elition idempotent?
09:45:46 <lambdabot> iS e1i7I0n IDEMPo+3Nt?
09:45:53 <ihope_> @elite iS e1i7I0n IDEMPo+3Nt?
09:45:54 <lambdabot> Iz 31i7I0N idEMP0+3NT?
09:45:57 <ihope_> Nope.
09:46:40 <vincenz> @join #oasis
09:49:01 <emertens> just as a quick hdbc question, does anyone know what would stop me from making two quickQueries in a row? (do i have to close the first one somehow?
09:49:14 <xerox> @ . elite type join
09:49:24 <xerox> @. elite type join
09:49:25 <lambdabot> phORa1| 4 (/\/\ :: * -> *). (MONad /\/\) => /\/\ (M a) -> m a
09:49:28 <xerox> hahaha
09:49:32 <xerox> @karma+ vincenz
09:49:32 <lambdabot> vincenz's karma raised to 6.
09:49:41 <xerox> That's parsable Haskell.
09:50:01 <xerox> (I suppose?)
09:50:17 <xerox> Oh no, it screws casing.
09:50:18 <ihope_> > join #esoteric
09:50:19 <lambdabot>  Not in scope: `esoteric'
09:50:23 <ihope_> Aww.
09:50:35 <xerox> ihope the numerologist.
09:52:16 <vincenz> ihope_: it's @join
09:53:05 <ihope_> Yeah, I know.
09:53:32 <emertens> (I guess you have to commit after a SELECT)
09:57:00 * shapr boings
09:57:52 <vincenz> it's a ball! it's a spring! No.... it's ShaprMan!
09:58:16 <zarvok> vincenz:  your sleep deprivation is starting to show :)
09:58:49 <vincenz> thought it already was
09:58:52 <zarvok> heh
09:58:58 <dmhouse> It's so annoyingly hot.
09:59:11 <vincenz> dmhouse: they project even hotter tomorrow
09:59:21 <dmhouse> So I hear.
09:59:29 <dmhouse> And I think I'll be walking home at midday :(
10:02:02 * SamB wonders how you write a multi-architecture code generator
10:03:31 <vincenz> zarvok: anyways, before you think I'm crazy... besides the jetlag I'm experiencing some serious stress over certain issues which contributes to the not falling asleep again after waking up quickly
10:03:55 <vincenz> SamB: typically you choose one intermediate format and then make a few backends
10:04:48 <SamB> vincenz: ah
10:05:03 <vincenz> zarvok: on another note.  I take it you know Harper... Is there an implementation of a miniML compiler?
10:06:09 <vincenz> SamB: IR (intermediate reprentation) is typically a reduced ast... reduced in the sense of the amount of things you can do
10:06:11 <shapr> hiya vincenz!
10:06:18 <vincenz> hey shapr
10:06:23 <dmhouse> shapr: opped up?
10:06:48 <shapr> Oh yeah, someone was ASLing earlier.
10:06:58 <dmhouse> Aha.
10:06:58 <vincenz> lol
10:07:03 <shapr> <kitababe> wats up \n <shapr> Ceilings. \n <kitababe> asl \n <shapr> Are you serious?
10:07:04 <vincenz> in #haskell?
10:07:12 <shapr> Then kitababe left.
10:07:21 <dmhouse> Fun :)
10:07:40 <vincenz> talk about out of context
10:11:14 <zarvok> vincenz: heh, don't worry, I don't think your crazy
10:12:20 <zarvok> vincenz: as far as MinML, I think there are a few interpreters for MinML lying around, which include various language
10:12:23 <xerox> shapr: hahaha what a pun.
10:12:31 <shapr> Ceilings?
10:12:39 <zarvok> vincenz: I have to go to a meeting now, but if you e-mail me (ccasingh@andrew.cmu.edu) I'm happy to dig one up for you
10:12:43 * xerox shakes his fist at shapr 
10:12:46 <zarvok> of course, it will be in SML
10:12:51 <dmhouse> I tend to point upwards and say 'That way'. :)
10:13:22 <xerox> heh
10:13:33 <vincenz> zarvok: thx
10:13:34 <zarvok> that message a few back should have said "include various language features" in case it was unclear
10:13:45 <vincenz> zarvok: I actually have a version of not quite miniml in a compiler I wrote in haskell
10:15:05 <zarvok> vincenz: yes.  Of course, haper use "minml" to refer to a family of similar small ML like languages with different features, so it's hard to pin down exactly what the language has
10:15:17 <tennin> hmm, do Haskell experts transcend time and space such that "age" and "location" no longer apply?
10:15:19 <zarvok> vincenz: I have to run, but drop me an e-mail and I'll send you one
10:15:22 <vincenz> zarvok: okies
10:15:35 <xerox> tennin: indeed.
10:28:59 <shapr> tennin: How so?
10:29:38 <shapr> Is it because some #haskell people are 16 or so, and some are in their thirties?
10:30:51 <Philippa> or possibly because some appear to be older or younger than they actually are?
10:31:19 <bringert> morning
10:31:30 <madpickle> i'm 10!!!!!!!!!111111111111111111111oneoneoneoneeleven
10:32:17 <madpickle> http://news.com.com/Microsoft+buys+Windows+utility+software+maker/2100-1016_3-6095376.html
10:32:18 <madpickle> wow
10:32:19 <lambdabot> Title: Microsoft buys Windows utility software maker | CNET News.com
10:32:33 <jgrimes_> hey bringert
10:32:57 <madpickle> that's good news
10:34:49 <ihope_> 16 or so, pah. I'm 13.
10:35:04 <bringert> shapr: some pre / haskell overflow because of long lines on http://www.scannedinavian.com/hope/entry
10:35:26 <bringert> I wonder what the best way to deal with that would be
10:35:42 <dmhouse> IRC tends to be a fantastic leveller in terms of age.
10:35:45 <bringert> maybe if you get right of the right side bar
10:36:44 <bringert> you could move it to below the navigation bar and change the width of main in the CSS
10:36:53 <bringert> css layout is tricky
10:37:26 <tennin> well, is age referentially transparent?
10:39:23 <edwinb> No, if you evaluate age twice you get a different answer...
10:40:28 <ihope_> dmhouse: leveller?
10:40:32 <emertens> What GUI library would you guys recommend if I need simple windows gui functionality
10:40:32 <tennin> so there you go.  (?)
10:40:38 <emertens> wxHaskell?
10:40:56 <emertens> s/windows/Windows(R)
10:41:06 <dmhouse> edwinb: age is an impure function of time.
10:41:24 <dmhouse> Well, actually, a pure function of time. An impure value.
10:41:57 <dmhouse> ihope_: I.e. it reduces the barrier of an age gap that, if we were all to meet in real life, might be apparent.
10:42:07 <edwinb> it's a function of time and the thing you want the age of...
10:42:18 <edwinb> I suppose that's referentially transparent
10:42:25 <dmhouse> Oh, sure. I was thinking 'The age of a person is a function of time'.
10:42:27 <tennin> and Haskell is a purely functional language.
10:42:43 <tennin> therefore, mastery of Haskell will suspend the aging process.  QED
10:42:45 <ihope_> age :: Condition -> AbsoluteTime -> RelativeTime
10:42:46 <shapr> bringert: I'd call it user error.
10:42:55 <dmhouse> age (Person birth _ _) now = now - birth
10:43:18 <xerox> edwinb imagined that evaluated as an IORef
10:46:12 <emertens>  <div style="float: left; width: 147px; overflow: hidden; padding: 0px 0px 0px 12px">
10:46:15 <emertens>         <cc1:CsSideNavControl ID="sideNav" runat="server" />
10:46:17 <emertens> sorry
10:46:19 <emertens>     </div>
10:46:48 <ihope_> You should indent "sorry" more :-P
10:46:53 <dmhouse> xerox: IORefs still preserve referential transparency, though.
10:47:07 <ihope_> pad x = do {x' <- toQubit x; y <- zero; hadamard y; z <- qxor x' y; return (y, z)} -- quantum one-time padding
10:47:08 <xerox> dmhouse - One can argue about that.
10:47:15 <dmhouse> xerox: How so?
10:47:30 <xerox> At language-level, you're right.
10:47:49 <xerox> But it wasn't me arguing against last time, hehe.
10:51:05 <vincenz> xerox: where did you get your nick?
10:51:32 <ihope_> xerox copied it from someone else, of course.
10:51:32 <LordBrain> anyone know a pretty printer for haskell?
10:51:42 <vincenz> LordBrain: there's a few in stdlib
10:52:13 <vincenz> @where+ stdlib http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
10:52:14 <lambdabot> Done.
10:52:20 <bringert> LordBrain: do you want to pretty print haskell code? or just a pretty printing library written in haskell?
10:52:29 <vincenz> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint.html
10:52:34 <ihope_> pad x y = do {x' <- toQubit x; z <- qxor x' y; return (y, z)} -- "better" one-time padding: use any qubit for padding, preferably one known to both Alice and Bob, so no transmission is necessary.
10:52:41 <vincenz> http://www.haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Pretty.html
10:52:47 <vincenz> LordBrain: check those two links
10:53:00 <vincenz> one is a generic pprinter, the other is one for haskell
10:53:45 <xerox> vincenz: I think it was a printer.
10:53:48 <xerox> It worked.
10:53:53 <LordBrain> thanks
10:55:14 <SyntaxNinja> y0 xerox
10:55:18 <SyntaxNinja> xerox: u still stuck?
10:55:33 <xerox> Yes!
10:55:34 <vincenz> hey SyntaxNinja
10:55:44 <xerox> Howdy SN (:
10:56:04 <SyntaxNinja> xerox: how come?
10:56:06 <SyntaxNinja> vincenz: y0
10:56:17 <LordBrain> @type debugM
10:56:19 <lambdabot> Not in scope: `debugM'
10:56:24 <LordBrain> hmm
10:56:55 <dmhouse> LordBrain: what do you want?
10:57:14 <LordBrain> i'm looking at the source code to the conjure bittorrent client
10:57:28 <vincenz> SyntaxNinja: I got some new and interesting leads for my compiler, namely ANF, a functional alternative to SSA without requiring continuations :)
10:57:30 <xerox> SyntaxNinja: I couldn't figure out cabal-getcabal-get could work with my local repository
10:57:39 <Lemmih> LordBrain: It's from the Conjure.Debug module.
10:57:41 <dmhouse> LordBrain: I presume that's a function defined in Conjure then.
10:57:43 <xerox> I tried file:///.../ and http://localhost// with no success.
10:57:50 <LordBrain> i see
10:57:51 <LordBrain> thanks
10:57:53 <mauke> how do I do bitwise xor in haskell?
10:58:10 <xerox> ?hoogle shiftR
10:58:11 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
10:58:11 <lambdabot> GHC.Exts.shiftRL# :: Word# -> Int# -> Word#
10:58:11 <lambdabot> GHC.Exts.iShiftRA# :: Int# -> Int# -> Int#
10:58:15 <xerox> ?docs Data.Bits
10:58:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
10:58:24 <mauke> ah, thanks
10:58:34 <xerox> Welcome to help :)
10:58:43 <vincenz> time to try this thing called sleep again
10:59:07 <mauke> why isn't Char an instance of Bits?
10:59:18 <vincenz> mauke: unicode
10:59:30 <mauke> yes, so?
10:59:32 <SamB> also, it isn't even treated as a number
11:00:07 <LordBrain> hmmmm i dont see that module in my source Lemmih
11:00:07 <SamB> Prelude> :i Data.Bits.Bits
11:00:07 <SamB> class Num a => Bits a where
11:00:42 <Lemmih> LordBrain: Where did you download the repo from?
11:00:57 <LordBrain> i used a darcs command
11:00:59 <LordBrain> let me see
11:01:01 <SamB> what URL
11:01:03 <sjanssen> why isn't Bool an instance of Bits?
11:01:07 <SamB> cat _darcs/prefs/repos
11:01:31 <mauke> toEnum (fromEnum c `xor` fromEnum '@') :/
11:01:32 <dmhouse> @instances-importing Data.Bits Bit
11:01:32 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
11:01:35 <dmhouse> @instances-importing Data.Bits Bits
11:01:36 <lambdabot> Int, Integer
11:01:40 <LordBrain> darcs get http://j.mongers.org/pub/haskell/darcs/conjure/
11:01:43 <lambdabot> Title: Index of /pub/haskell/darcs/conjure
11:01:52 <SamB> @instances-importing Data.Bits Data.Word Data.Int Bits
11:01:53 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer, Word, Word16, Word32, Word64, Word8
11:02:02 <LordBrain> is that wrong/
11:02:03 <LordBrain> ?
11:02:21 <Lemmih> LordBrain: The new repo's at http://darcs.haskell.org/~lemmih/conjure
11:02:21 <SamB> LordBrain: that is jlouis's repo
11:02:23 <lambdabot> Title: Index of /~lemmih/conjure
11:02:36 <LordBrain> hmm
11:02:55 <SamB> I think jlouis got a job or something
11:03:46 <LordBrain> oh
11:03:52 <LordBrain> good for him...
11:04:18 <LordBrain> did i use the right command otherwise... darcs get?
11:04:22 <SamB> yeah
11:04:27 <LordBrain> cool
11:04:37 <SamB> but you want --partial, I think
11:04:43 <SamB> with this repo
11:05:11 <LordBrain> hmm
11:05:19 <LordBrain> well its too late its already working
11:05:31 <SamB> whatever then
11:05:44 <kuribas> Is there a good xemacs mode for darcs?
11:05:51 <LordBrain> what does --partial do?
11:05:52 <SamB> mode?
11:06:13 <dmhouse> LordBrain: it only pulls the patches since the last 'checkpoint'.
11:06:17 <SamB> it saves you from having to grab the entire history and just grabs the latest checkpoint
11:06:20 <nothingmuch> --partial gets only from the last checkpoint
11:06:27 <nothingmuch> and any tag can be a checkpoint
11:06:29 <SamB> and patches since
11:06:32 <vincenz> too early
11:06:36 <LordBrain> ah i see
11:06:42 <LordBrain> that should speed it up some i imagine
11:06:52 <dmhouse> Quite a lot.
11:07:29 <SamB> Lemmih did some pretty radical reorganization around when he started maintaining it
11:07:42 <SamB> and darcs's algorithms don't seem to like it much...
11:08:37 <LordBrain> darcs doesnt like it?
11:08:45 <LordBrain> does that mean what i checked out is not prestine?
11:08:47 <xerox> How do tags work?
11:08:48 <SamB> no no
11:09:24 <SamB> just that it would take forever to merge anything with at least one patch
11:09:33 <SamB> (at least one particular patch)
11:09:44 <SamB> and I'm not sure it doesn't take a while just to apply to the repo..
11:10:07 <SamB> and if you have dialup it also has to change a bunch of patches...
11:10:23 <LordBrain> well i have cable fortunately
11:10:27 <SamB> er, download...
11:10:36 * SamB is not all here today
11:11:15 <SamB> yeah, I suppose most dialup users aren't crazy enough to be interested in conjure
11:11:16 <SamB> I was
11:11:25 <SamB> I'm not a dialup user anymore, though, happily
11:11:31 <LordBrain> hehe
11:11:58 <monochrom> Most dialup users aren't programmers.
11:12:16 <monochrom> But I don't know the context :)
11:12:18 <LordBrain> bittorrent works really well, it will be when(if ever) debian's apt uses the protocol
11:12:31 <SamB> well, I'm just a student attending community college
11:12:32 <xerox> I know dialup users who are programmers. I was one.
11:12:35 <LordBrain> will be cool im ean
11:12:35 <SamB> anyway it is summer
11:13:43 <monochrom> We need a communist movement towards "everyone should have broadband" :)
11:14:01 <LordBrain> i'm for that
11:14:02 <vincenz> monochrom: yeah global ultrahighbandwidth WIFI mesh
11:14:04 <LordBrain> hehe
11:14:16 * xerox raises his hand
11:15:00 <vincenz> skype are such leachers
11:15:06 <vincenz> there is no way to find out your current skype credit
11:15:23 <xerox> Skype is evil for other reasons as well
11:16:04 <vincenz> yeah
11:16:17 <dmhouse> vincenz: Really?!
11:16:34 <monochrom> What are some other evilness of skype?
11:16:44 <vincenz> dmhouse: oh found it now
11:17:09 <xerox> You route others' traffic, for one, and in a surely _not_ safe manner.
11:17:19 <vincenz> xerox: apparently someone cracked it
11:17:38 <xerox> Yes I know, that's the paper I am referring to.
11:17:58 <xerox> ?google skype blackhat
11:18:00 <lambdabot> http://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-biondi/bh-eu-06-biondi-up.pdf
11:18:10 <vincenz> why is it blackhat
11:18:26 <xerox> Because it was presented at that conference.
11:18:32 <vincenz> ah
11:34:17 <LordBrain> hmmm there's been a lot of changes in conjure since jlouis got a job it seems... i did a diff on Conjure.hs... pretty much a rewrite
11:35:10 <Lemmih> Yeah, a lot have changed.
11:36:17 <monochrom> Nice to eavesdrop.
11:36:18 <SamB> yeh, I told you Lemmih did some massive reorganization around that time
11:36:22 * bringert just submitted a GHC bug report which mentions "looking in the cod"
11:36:44 <bringert> there doesn't seem to be a way to edit the description
11:37:19 <ihope_> Looking in the cod?
11:37:23 <SamB> code?
11:38:11 <jgrimes_> if getContents reads input lazily, when does it stop reading input?
11:38:47 <Lemmih> jgrimes_: at EOF.
11:38:51 <jgrimes_> hm..
11:39:19 <LordBrain> hmmm i think scoping and garbage collection could probably triggor a close of the file handle, right?
11:39:21 <bringert> ihope_, SamD: yes, I meant to write "code" in the bug report, but I happend to write "cod"
11:39:30 <bringert> eh SamB
11:39:54 <monochrom> at EOF, or at read errors (fails silently), or at program termination
11:40:21 <bringert> "Since -fcontext-stack is a static flag at the moment, the user who wants to use a generated module has to look in the generated cod for a comment that says to use for example -fcontext-stack64."
11:40:27 <LordBrain> cod 3. The scrotum. --Dunglison. (1913 Webster)
11:40:27 <monochrom> In the first two cases, what you observe in the program is that the list ends.
11:40:31 <jgrimes_> monochrom, Lemmih: Ok.
11:40:50 <LordBrain> unfortunate typo..
11:41:18 <bringert> well, I think the fish is the more common meaning for "cod"
11:41:43 <LordBrain> yeah thats what i first thought of
11:41:57 <LordBrain> then i looked it up to check on the spelling
11:42:32 <LordBrain> apparently it used to mean a small bag or pouch
11:42:37 <LordBrain> also
11:42:54 <bringert> maybe "looking in the generated cod" means that you have to be psychic: http://www.occultopedia.com/i/ichthyomancy.htm
11:42:56 <lambdabot> Title: Ichthyomancy
11:43:03 <SyntaxNinja> y0
11:43:04 <LordBrain> the old dictionary doesnt even mention the fish
11:43:05 <CosmicRay> Hmm, for .c programs compiled via Cabal, what macro can I use to check on the host OS?
11:43:17 <CosmicRay> #ifdef mingw32_HOST_OS doesn't seem to work there
11:43:23 <SyntaxNinja> xerox: still there?
11:43:56 <SyntaxNinja> CosmicRay: don't know.  maybe check what the cabal soure does, or system.filepath
11:45:00 <ptolomy> I'm working with somebody's option contract theoretical value estimation program that is written in pure C for speed, and I'm having much trouble supressing the urge to mention the Haskell combinator contract papers.
11:45:07 <CosmicRay> SyntaxNinja: you don't appear to have .c programs except under tests
11:45:53 <ptolomy> I would bet $50 that I could write a faster and more reliable version in Haskell or some ML variant in a fraction of the time it took to make the original.
11:45:56 <CosmicRay> what compiles does the mingw32 ghc use anyway?
11:46:18 <SyntaxNinja> CosmicRay: right, but System.FilePath checks if its building on  windows, I'd expect that the macro would be the same, no?
11:46:20 <LordBrain> faster more reliable version of what now?
11:46:42 <CosmicRay> SyntaxNinja: No.  You used #ifdef mingw32_HOST_OS, which I also use in my .hs and .hsc files and it works there.
11:46:44 <CosmicRay> it doesn't work in .c files
11:47:53 <ptolomy> LordBrain: of a financial contract valuation engine.
11:48:02 * ptolomy wonders if 'valuation' is a real word.
11:48:28 <sethk> of course
11:48:35 <sethk> valuation is at least a $10 word
11:49:22 <LordBrain> i found a shakespear quote using valuation
11:49:26 <sethk> has three definitions in my unabridged dictionary
11:49:34 <madpickle> @google valuation
11:49:38 <SyntaxNinja> CosmicRay: strange.
11:49:39 <lambdabot> http://www.voa.gov.uk/
11:49:39 <lambdabot> Title: Valuation Office Agency - homepage
11:49:43 <dmhouse> @spell valuation
11:49:45 <lambdabot> valuation
11:50:14 <LordBrain> "Since of your lives you set/So slight a valuation."
11:50:19 <sethk> five, if you count valuation account and valuation survey
11:51:47 <LordBrain> i confess i dont understand why combinators are fast...
11:52:07 <xerox> SyntaxNinja: yes!
11:52:24 <petekaz> Does anyone recall the mailing list thread (fairly recent) where someone did a nice comparison of GTK bindings vs others?
11:52:25 <norpan> LordBrain is a nice nickname
11:52:41 <LordBrain> thanks norpan
11:52:42 <SyntaxNinja> xerox: did you look at the code?
11:53:15 <xerox> SyntaxNinja: yes, some
11:54:21 <xerox> (I also got carried away by Type Theory and Category Theory discussions, sigh! #haskell is very powerful.)
11:54:58 <ptolomy> LordBrain: Are combinators fast?
11:56:14 <petekaz> nevermind ... I found the thread.
11:56:39 <xerox> ptolomy: in what sense?
11:56:54 <LordBrain> all i know is i have seen it alluded to that such and such version of such and such turns out to be the fastest... for example i saw that about an implementation of the factorial function using combinators.
11:57:15 <ptolomy> xerox: Not sure. I was wondering the same thing of LordBrain's original query.
11:57:26 <LordBrain> there's a lot i dont know
11:57:35 <xerox> ptolomy: sequence . enumFrom -- doesn't even terminate?
11:58:32 <LordBrain> so i meant fast in the sense that you can use them to implement faster algorithms
11:58:51 <xerox> LordBrain: combinators are just points-free code most of the time.
11:58:57 <LordBrain> yeah
11:59:10 <LordBrain> does making it points-free give some advantage in speed?
11:59:12 <dmhouse> The algorithm you write has a bigger impact on speed than how you write the algorithm.
11:59:17 <xerox> Another slightly different meaning of that word is "infix function", which is used sometime.
11:59:34 <dmhouse> I doubt there's anything at all between points-free and not.
11:59:41 <dmhouse> xerox: Really? I think that's
11:59:44 <dmhouse> 'operator'.
11:59:49 <LordBrain> ok.. while i'm displaying my ignorance.. maybe i'll find what i read and let you clear it up for me
11:59:56 <xerox> ?foldoc combinator
11:59:58 <lambdabot> *** "combinator" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
11:59:58 <lambdabot> combinator
11:59:58 <lambdabot>  
11:59:58 <lambdabot>     <theory> A function with no {free variables}.  A term is
11:59:58 <lambdabot>     either a constant, a variable or of the form A B denoting the
12:00:00 <lambdabot> [28 @more lines]
12:00:09 <xerox> ?foldoc operator
12:00:10 <dmhouse> Combinators are often HOFs you use to build bigger and better functions, like those in Parsec.
12:00:11 <lambdabot> *** "operator" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
12:00:11 <lambdabot> operator
12:00:11 <lambdabot>  
12:00:11 <lambdabot>     <programming> A symbol used as a {function}, with {infix
12:00:11 <lambdabot>     syntax} if it has two arguments (e.g. "+") or {prefix syntax} if
12:00:13 <lambdabot> [5 @more lines]
12:00:29 <xerox> No dmhouse, you see?
12:00:46 <ptolomy> the benchmarks I've run on points-free versus not showed no difference.. but it was just one or two functions, so not worth extrapolating.
12:00:51 <dmhouse> xerox: not really. :)
12:01:02 <xerox> Ow.
12:01:57 <LordBrain> here is the first thing i read showing the use of combinators to make a fast implimentation: http://www.willamette.edu/~fruehr/haskell/evolution.html
12:01:59 <lambdabot> Title: The Evolution of a Haskell Programmer
12:02:32 <LordBrain> look at teh section under combinatory haskell programmer
12:02:34 <xerox> I don't think that that page is meant to show a proper kind of evolution :-)
12:02:51 <LordBrain> hehehe i know
12:02:53 <ptolomy> I do like that site, though.
12:02:53 <dmhouse> LordBrain: That page is mostly a joke ;)
12:03:06 <ptolomy> heh. it'd be fun to benchmark those..
12:03:06 <dmhouse> The commentary's worth reading, though.
12:03:11 <LordBrain> but, it happens that that particular version of the factorial function out of all those demonstrated is the fastest
12:03:27 <LordBrain> which surprises me
12:03:32 <LordBrain> and bewilders me
12:03:49 <xerox> Even y, it uses.
12:04:05 <sjanssen> LordBrain: also, those benchmarks are very old.  I doubt the combinator version is the fastest in today's GHC
12:04:34 <LordBrain> hmm well ok
12:05:38 * ptolomy wonders why their accumulating version doesn't bother strictifying.
12:05:54 <xerox> The "List-encoding Haskell programmer" entry is nuts.
12:06:11 <dmhouse> I love that entry!
12:06:21 <vincenz> xerox: linky
12:07:02 <sjanssen> I prefer the Static Haskell programmer
12:07:04 <vincenz> xerox: the combinator one is
12:07:24 <vincenz> and the comonad one.... o.O
12:07:46 <xerox> You understood the List one?
12:07:48 <sjanssen> I wonder how much GHC would freak out if you tried to compute the factorial of 100 with typeclasses
12:07:57 <jgrimes_> for just keep basic state should I use IORef or the State monad?
12:07:58 <ptolomy> when they start going peano, I start feeling uncomfortable.
12:08:01 <vincenz> xerox: sure
12:08:03 <vincenz> xerox: the list one is easy
12:08:05 <xerox> What do you mean by "with typeclasses" ?
12:08:25 <sjanssen> jgrimes_: if State gets the job done, use that
12:08:28 <dmhouse> @seen kowey
12:08:29 <lambdabot> I saw kowey leaving #haskell and #darcs 6 days, 16 hours, 57 minutes and 55 seconds ago, and .
12:08:43 <dmhouse> jgrimes_: Depends how you want to use it.
12:08:59 <sjanssen> xerox: computing at compile time with fundeps.  Like the Static Haskell programmer example on the page
12:09:18 <dmhouse> jgrimes_: Most of the time State, or its restriction, Reader, are better than mutable variables.
12:09:29 <monochrom> For just keeping basic state I recomment the State monad or the ST monad.
12:09:43 <jgrimes_> Hmm, ok.
12:09:46 * ptolomy wonders how the C++ preprocessor factorial function compares to the static haskell one...
12:09:49 <jgrimes_> Maybe I'll try some or all of the above
12:09:51 <xerox> data Zero; data Succ n; what a weird...
12:09:55 <ptolomy> might be faster, but it is less safe. :-P
12:10:10 <monochrom> Note that there is no (IO a -> a)  but there are (State a -> a) and (ST s a -> a)
12:10:10 <dmhouse> I guess IORefs are good when your functions are mostly IO-orientated (so StateT with IO will be a pain to keep lifting everything).
12:10:29 <dmhouse> State s a -> a.
12:10:32 <xerox> State s a -> a and State s a -> s
12:10:35 <jgrimes_> right, which I think was the reasoning of wherever it was that I read about IORef
12:10:41 <xerox> evalState and execState ?
12:10:44 <monochrom> oops, yeah, State s a
12:10:46 <dmhouse> And State s a -> (s, a) :)
12:11:07 <sjanssen> ptolomy: the static one should be pretty bad, because it uses unary numbers which means O(n m) multiplication
12:11:16 <xerox> runState, that one
12:11:26 <monochrom> I would think the presence or absence of (m a -> a) dictates your decision.
12:11:32 <vincenz> I think the best version is the tenured one
12:12:17 <LordBrain> if you're going to end up producing  an infinite amount of state as the program runs.. i suspect it might be better to use IORef... at least i've managed to create overflows and things using State
12:12:28 <xerox> Multiplication in type class is cool.
12:12:30 <monochrom> Don't forget ST
12:12:32 <ptolomy> I'd do it the tenured way, prolly, unless it became an issue.
12:12:57 * xerox pokes SyntaxNinja 
12:13:08 <LordBrain> i made a purely functional  bouncing ball
12:13:09 <monochrom> (State s a) is non-strict.  You can run into the same problem as foldl (+)
12:13:40 <LordBrain> it ran in hugs and ghc.. and in one of those it would run out of memory
12:13:47 <LordBrain> occasionally
12:13:56 <xerox> What's another simple series, like factorials?
12:14:14 * xerox is tempted of doing fibonacci
12:14:37 <jgrimes_> squares?
12:14:45 <LordBrain> how about triangle numbers
12:15:11 <vincenz> LordBrain: only '7' is triangular
12:15:21 <LordBrain> hmm?
12:15:22 <vincenz> look at the shape
12:15:23 <dmhouse> vincenz: ;)
12:15:26 <LordBrain> hahaha
12:15:48 <dmhouse> Well, technically, a triangle is a closed shape, but anyway... ;)
12:15:56 <int-e> 4 :)
12:16:02 <vincenz> dmhouse: so you are a triangle?
12:16:08 <LordBrain> triangle numbers are of the form n(n-1)/2 i believe... they're basicly the number of objects to arrange half the square cut along the diagonal
12:16:20 <vincenz> LordBrain: oh sum [1..n]
12:16:32 <dmhouse> vincenz: That's not what I said. You're interpreting what I said as 'a closed shape is a triangle'.
12:16:33 <vincenz> make that
12:16:34 <vincenz> [1..n-1]
12:16:41 <dmhouse> (And don't foget a lot of people cross their 7s, and that German ones look a bit like non-crossed 7s.)
12:16:43 <vincenz> dmhouse: good point
12:16:55 <LordBrain> lol
12:16:57 <vincenz> dmhouse: I draw my ones like non crossed 6s
12:17:05 <int-e> > filter (\n -> sum [1..n-1] + sum [1..n] == n^2) [1..]
12:17:05 <vincenz> erm 7s
12:17:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:17:55 <dmhouse> vincenz: Yeah, I think that's quite European. In Britain 1s tend to look like Is but with different serifs.
12:18:16 <LordBrain> 2 would not be a triangle number, but 3 would, because the shape .: forms a triangle with 3 dots
12:18:27 <dmhouse> Hey, xerox, points-free what int-e just wrote
12:18:36 * xerox hops
12:18:49 <xerox> I'm doing a crazies thing now, dmhouse %-)
12:18:53 <vincenz> dmhouse: it's got multiple entries
12:19:05 <vincenz> xerox: writing haskell?
12:19:08 <xerox> OK I'll do it :D
12:19:10 <int-e> <|
12:19:20 <dmhouse> LordBrain: Right, a triangular number n has the property that there exists some m with sum [1..m] = n.
12:19:29 <LordBrain> yeah
12:19:49 <vincenz> dmhouse: heh...that's rpetty weak
12:20:04 <int-e> . o O ( (<|) :: bra -> matrix -> bra )
12:20:15 <vincenz> just solve n^2-n-2M and see if n is an integer
12:20:39 <xerox> flip filter [1..] . sum . (== 0) . ap (enumFromTo 1 . subtract 1) ((+) . enumFromTo 1)
12:20:43 <xerox> My first bet.
12:20:53 <dmhouse> vincenz: It's easier to generate the triangular numbers.
12:20:54 <vincenz> xerox: you're like those REALLY good graphical artists
12:21:08 <vincenz> xerox: who in the end just scan something and slowly make it leass realistic until it looks like something handmade that looks pretty realistic
12:21:15 <dmhouse> > take 5 (map (sum . enumFromTo 1) [1..])
12:21:16 <lambdabot>  [1,3,6,10,15]
12:21:31 <xerox> Oh wait
12:21:32 <vincenz> dmhouse: I know, I thought it was detection
12:21:36 <xerox> It's == n^2 not == 0.
12:21:41 <int-e> > take 5 $ scanl (+) 0 [1..]
12:21:42 <lambdabot>  [0,1,3,6,10]
12:21:48 <xerox> vincenz: Thank you very much.
12:21:55 <dmhouse> Gah. I was just typing exactly that, int-e :)
12:22:03 <vincenz> > drop 10000 $ scanl (+) 0 [1..]
12:22:04 <lambdabot>  [50005000,50015001,50025003,50035006,50045010,50055015,50065021,50075028,500...
12:22:04 <vincenz> xerox: ?
12:22:08 <xerox> dmhouse: do you still want me to try?
12:22:21 <vincenz> xerox: I Was referring to the pointsfreeing
12:22:23 <dmhouse> xerox: As you wish.
12:22:32 <vincenz> xerox: you ask lambdabot in privmsg and then add a few mistakes
12:22:33 <xerox> vincenz: is it a positive thing in your opinion?
12:22:42 <xerox> Oh, no. Surely I am not doing it.
12:22:47 <vincenz> no it's not a positive thing
12:22:48 <dmhouse> The colons in the last 6 lines all lined up.
12:22:52 <vincenz> and it was a joke
12:22:58 <xerox> Do you have Subethaedit?
12:23:09 <xerox> Let's do this contest in a collaborative editing environment :-)
12:23:38 <vincenz> xerox: I got one for you
12:23:52 <vincenz> \x -> let y = y in y
12:23:58 <vincenz> points free
12:24:00 <xerox> const undefined
12:24:08 <vincenz> that doesn't blow stack
12:24:18 <xerox> What?
12:24:25 <vincenz> > let x = x in x
12:24:25 <lambdabot>  Add a type signature
12:24:30 <vincenz> > let x = x in x :: Int
12:24:31 <lambdabot>  Exception: <<loop>>
12:24:36 <vincenz> > undefined :: Int
12:24:37 <lambdabot>  Undefined
12:24:51 <xerox> Oh I see.
12:25:09 <xerox> ?type fix id
12:25:11 <lambdabot> forall a. a
12:25:17 <dmhouse> What's the definition of points-free?
12:25:21 <monochrom> const (fix id)    will this do?
12:25:26 <xerox> > const (fix id)
12:25:27 <vincenz> > fix id
12:25:27 <lambdabot>  Add a type signature
12:25:28 <lambdabot>  Add a type signature
12:25:28 <xerox> Yes Indeed
12:25:31 <vincenz> > fix id :: Int
12:25:32 <lambdabot>  Exception: <<loop>>
12:25:33 <xerox> > const (fix id)  :: Int
12:25:34 <lambdabot>    Expecting a function type, but found `Int'
12:25:34 <lambdabot>    Expected type: Int
12:25:34 <lambdabot>   ...
12:25:43 * xerox high-fives monochrom 
12:25:52 * monochrom high-fives xerox
12:25:54 <xerox> More fun!
12:26:01 <vincenz> lazy pure fun!
12:26:27 <LordBrain> dmhouse: you looking for a technical definition?
12:26:32 <dmhouse> LordBrain: Yeah.
12:26:43 <dmhouse> Perhaps 'no bound variables'?
12:26:50 <ptolomy> Is there a haskell equivalent of Duff's Device? I feel like no, because most of the stuff that makes me go, "That works?" is counted as a feature.
12:26:57 <dmhouse> 'All variables free', equivalently?
12:27:07 <dmhouse> ptolomy: Duff's Device?
12:27:18 <vincenz> dmhouse: Hillary Duff's boyfriend
12:27:22 <ptolomy> ?google duff's device
12:27:28 <lambdabot> http://www.lysator.liu.se/c/duffs-device.html
12:27:48 <ptolomy> http://catb.org/jargon/html/D/Duffs-device.html
12:27:49 <lambdabot> Title: Duff's device
12:28:16 <monochrom> Duff's Device is a feature too.
12:29:00 * vincenz shudders
12:30:00 <ptolomy> true.
12:30:10 <ptolomy> I consider it to be an unintentional feature.
12:30:26 <xerox> Can you do fibonacci in typeclasses?
12:30:39 <vincenz> monochrom: duff's device is a nice show of how different language features can combine in such a beautifull unorthogonal way that you wonder what else code might be fucking up
12:31:05 * xerox challenges monochrom 
12:31:32 <monochrom> I am not very imaginative with type-level programming.
12:31:32 <vincenz> xerox: yeah you can
12:31:40 <vincenz> class ...
12:31:50 <vincenz> instance IsFib (Succ Zero)
12:32:07 <vincenz> instance (Add x y z, IsFib x, IsFib y) => IsFib z
12:32:12 <int-e> bad :)
12:32:17 <int-e> you forgot the index
12:32:18 * xerox grins
12:32:25 <vincenz> who says we need an index
12:32:45 <int-e> so you claim 4 = 2+2 = 1+1+1+1 is a fibonacci number?
12:33:01 <vincenz> crud
12:33:09 <vincenz> ok
12:33:13 <dmhouse>  I don't get Duff's Device. What does it do?
12:33:18 <vincenz> instance IsFib (Succ Zero) (Succ Zero)
12:33:27 <vincenz> isntance IsFib (Succ (Succ Zero)) (Succ Zero)
12:33:38 <lispy> any idea how to deal with this?
12:33:39 <lispy> src/Text/PrettyPrint/HughesPJ.hs:1:0:
12:33:39 <lispy>     conflict: module `Text.PrettyPrint.HughesPJ'
12:33:39 <lispy>     belongs to the current program/library and also to package base-1.0
12:33:40 <int-e> dmhouse: it's an unrolled loop with several entry points
12:33:58 <monochrom> My biggest surprise with Duff's Device is that it parses.
12:34:05 <lispy> monochrom: yeah
12:34:38 <vincenz> instance (IsFib ix vx, IsFib iy vy, Add vx vy vz, Adj ix iy, Max ix iy iz) => IsFib (Succ iz) (vz)
12:34:42 <vincenz> there you go :)
12:34:42 <lispy> i'm trying to build HaXml because i wanted to use dtd2haskell
12:34:43 <int-e> vincenz: alternatively you can just do instance (Add x y z, Fib x y) => Fib y z   and  instance (Fib x y) => IsFib x ...
12:35:44 <int-e> vincenz: although I doubt the type checker likes that :)
12:36:04 <lisppaste2> sjanssen pasted "type fibo" at http://paste.lisp.org/display/22807
12:36:36 <sjanssen> now to write one that doesn't have exponential complexity
12:36:58 * xerox shakes head
12:37:26 <emertens> @pl (\x -> map (sum . zipWith (*) x)
12:37:26 <lambdabot> (line 1, column 33):
12:37:27 <lambdabot> unexpected end of input
12:37:27 <lambdabot> expecting variable, "(", operator or ")"
12:37:38 <emertens> @pl (\x -> map (sum . zipWith (*) x))
12:37:39 <lambdabot> map . (sum .) . zipWith (*)
12:37:51 <emertens> hmm... I guess that wouldn't be very clear :)
12:38:05 * vincenz goes off to do something called sleep
12:38:11 <dmhouse> Ah, so with Duff's Device, none of the cases hit?
12:38:17 <vincenz> dmhouse: no the right one hits
12:38:27 <vincenz> dmhouse: so that you don't have to calculate how many elements you need to continue doing
12:38:30 <dmhouse> Must it be 0 on the first time?
12:38:31 <vincenz> given how you unrolled a loop by 8
12:38:35 <vincenz> but might not have 8 xs
12:38:41 <vincenz> dmhouse: no, the switch only fires once
12:38:55 <xerox> No succes here.
12:38:58 <xerox> vincenz: yours work?
12:39:04 <vincenz> xerox: I'm haeding to bed
12:39:09 <vincenz> insomnia is eating my brain
12:39:09 <xerox> Goodnight.
12:39:12 <vincenz> night
12:40:08 * ptolomy coded mostly assembly and C device-level stuff for the beginning of his programming career, so Duff's Device looked unfortunately reasonable to me.
12:40:39 <monochrom> To answer "is there something like Duff's Device in Haskell", we have to narrow down what is 'like'.  I can think of two meanings.  If "like" refers to grammar, I don't think Haskell grammar allows a similar overlapping of lexical scopes.  If "like" refers to strange control flow, I think using continuations you can do even stranger control flow.
12:41:12 <xerox> Yeehee
12:41:16 <xerox> Stack error :D
12:43:32 <xerox> Sky's purple here, what a view.
12:46:34 <palomer> GOTO ftw!
12:48:45 * xerox  laughs
12:48:48 <xerox> I've done it!
12:48:52 <palomer> LIES
12:48:58 <xerox> Let's add it to my page.
12:48:59 <palomer> IVE done it
12:49:05 <xerox> What?
12:49:33 <monochrom> what is ftw?
12:49:45 <xerox> fib (undefined :: Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero))))))) :: Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero))))))))))))
12:49:46 <palomer> for the win
12:49:49 <monochrom> (I only know wtf)
12:50:07 <xerox> fib 7 => 13
12:50:10 <monochrom> > reverse "GOTO ftw"
12:50:11 * xerox jumps up and down
12:50:11 <lambdabot>  "wtf OTOG"
12:50:28 <lisppaste2> sjanssen annotated #22807 with "with an accumulator" at http://paste.lisp.org/display/22807#1
12:50:53 <sjanssen> now, am I dorky enough to go for an O(log n) algorithm?
12:51:09 <xerox> sjanssen: want to see? :-)
12:51:22 <sjanssen> xerox: of course!
12:51:26 <monochrom> Go for an O(log n) algorithm.
12:51:52 <sjanssen> monochrom: don't tempt me
12:51:56 <dmhouse> Wow, Google indexes newsgroup messages from 24 years ago: http://groups.google.com/group/net.lang.c/browse_thread/thread/590be615ce677a1a
12:51:57 <lambdabot> Title: Google Groups: net.lang.c
12:52:17 <SyntaxNinja> y0 xerox
12:52:17 <monochrom> Don't go for an O(log n) algorithm.
12:52:36 <sjanssen> I'd probably go with the matrix exponentiation method, which means writing exponentiation by squaring at the type level . . .
12:52:40 <sjanssen> and multiplication
12:52:51 <sjanssen> so I'd end up changing my numerical representation to binary
12:53:06 <sjanssen> but it does sound kinda fun . . .
12:54:09 <xerox> ?wiki User:PaoloMartini
12:54:10 <lambdabot> http://www.haskell.org/haskellwiki/User:PaoloMartini
12:54:13 <xerox> There.
12:55:47 <monochrom> Who is Paolo Martini and is that Canada's ex-Prime Minister Paul Martin in a Romantic disguise? :)
12:56:01 <xerox> He's me :-)
12:56:13 <xerox> You could say so... O_o
12:56:33 <xerox> (See the last code at the end, by the way. :) )
12:56:53 <monochrom> I look forward to an Alberto Laius.
12:57:19 <xerox> Erhm... ?
12:58:26 <LordBrain> hmm comp.lang.c was started on my birthday
12:58:40 <LordBrain> not the right year tho... pity
12:59:50 <dmhouse> Are newsgroups worth subscribing to these days?
13:00:06 * edwardk waves ello.
13:00:11 <dmhouse> Hey there edwardk.
13:02:37 <SyntaxNinja> audreyt: alive?
13:02:51 <xerox> sjanssen: works? %)
13:03:39 <sjanssen> xerox: looks good to me
13:05:03 <jer> dmhouse, it really depends on the newsgroup. they're mostly as bad as email wrt spam and jackasses. but if that doens't bug you much, you're not likely to be deterred
13:07:07 <mauke> here's a program: http://rafb.net/paste/results/x61MPe78.html
13:07:11 <mauke> does the code look sane?
13:07:49 <dmhouse> mauke: readHex, readOct are in Numeric
13:08:17 <mauke> yes, I use them
13:08:49 <dmhouse> You define them. Why not import them?
13:08:52 <monochrom> Wow, you are doing your own regex library!  At 10 lines per second, I see ok code.
13:09:25 <dmhouse> You might want to talk to ndm, regexes are his thing.
13:09:42 <mauke> it's not really a regex library
13:09:46 <mauke> dmhouse: uh, I do
13:10:08 <monochrom> What does this program do?
13:10:27 <dmhouse> mauke: 34 - 36. You define them.
13:10:41 <mauke> readHex = fromReadS . N.readHex
13:10:44 <mauke> yeah, as wrappers
13:11:01 <dmhouse> Ah, okay.
13:11:06 <mauke> monochrom: it generates strings that would be matched by a given regex
13:11:32 <monochrom> Ah!  It is not a regex lib.
13:12:23 <xerox> mauke: haha that crazy idea got you, eh!
13:12:29 <monochrom> I gave it out as a problem in a programming contest.  I asked for just one string per regex.  Consequently the solutions they submitted were all trivial :)
13:13:16 <xerox> Evil.
13:13:19 <mauke> monochrom: did your definition of regex include assertions?
13:13:28 <monochrom> No.  What are assertions?
13:13:47 <mauke> ^, $, \b, \B, (?= ... ), (?! ... ), ...
13:14:00 <mauke> zero-width look-around thingies
13:16:40 <ihope_> mauke: now can you do the reverse?
13:16:56 <mauke> what, construct a regex from a list of strings?
13:17:25 <ihope_> Yeah.
13:17:32 <ihope_> Two lists: one to match, and one not to match.
13:17:55 <mauke> regexFromStrings = Branch
13:18:24 <mauke> well, Branch . map Literal
13:18:29 <ihope_> Yeah, but can you make really short regexes?
13:18:50 <mauke> there's a perl module for that :-)
13:19:02 <ihope_> What's that?
13:19:03 <edwardk> mauke: missed the beginning of the conversation.
13:19:13 <edwardk> started slapping together a regexp library myself for my current project
13:19:27 <edwardk> how far along are you?
13:19:59 <edwardk> oh
13:20:00 <edwardk> i see
13:20:08 <edwardk> regexp -> language generator
13:20:14 <edwardk> sorry =)
13:20:37 <edwardk> ihope Regexp::Assemble for perl can generate optimized regexps
13:20:51 <edwardk> er that was ihope:
13:20:57 <edwardk> not that i hope it can ;)
13:21:13 <LordBrain> ah cool!
13:21:30 <LordBrain> Regexp::Assemble... had a use for that once... now let me see if i can remember..
13:22:04 <mauke> I wrote a simple regex lib in C once
13:22:29 <mauke> captures were slightly broken, though
13:23:10 * edwardk wrote  simple trie based regexp generator, but didn't generate anything more complicated
13:23:33 <monochrom> Why does everything written in C have to have something slightly broken?
13:23:53 <monochrom> (I'm just kidding!)
13:24:21 <mauke> it could do stream matching, though
13:24:23 <edwardk> i started built a posix level regexp lib in c++ once, and got about that far when i wrote it in javascript so i could get towards perl compatible regexps in javascript when in old flash, but i didn't get around half of the perl extensions.
13:24:23 <zarvok> monochrom: haven't you read K+R?  It's in the language spec
13:24:27 <zarvok> :)
13:24:41 <edwardk> zarvok: hehe
13:26:15 <mauke> the bug was that "ac" =~ /(?>(a))b|c/ would capture "a"
13:26:20 <sethk> monochrom, that's not true.  some things written in C are seriously broken, not just slightly broken.
13:26:58 <monochrom> phooey!
13:28:19 <mauke> features were: reasonably simple matcher; parser running backwards
13:29:35 * edwardk is just using the pcre bindings now in haskell.
13:37:57 <CosmicRay> hmm, why can't I add a package dependency in writeHookedBuildInfo?
13:38:00 <CosmicRay> (in Cabal)
13:38:07 <CosmicRay> SyntaxNinja: you may be able to answer this ;-)
13:40:25 <SyntaxNinja> because dependencies aren't in buildinfo, right?
13:40:41 <CosmicRay> ah.
13:40:46 <CosmicRay> so I have to use a hook.
13:40:47 <CosmicRay> ok.
13:40:51 <SyntaxNinja> buildinfo is for dynamic stuff, and for now dependencies are considered static.
13:40:51 <CosmicRay> why not? ;-)
13:41:05 <SyntaxNinja> I don't even think you can do it w/ a hook. we need configurations.
13:41:05 <CosmicRay> I need to depend on unix on unix platforms, and not on windows platforms.
13:41:53 <SyntaxNinja> CosmicRay: bug simonmar to implement this: http://hackage.haskell.org/trac/hackage/ticket/27
13:41:55 <SyntaxNinja> (or do it!)
13:41:55 <lambdabot> Title: #27 (Configurations) - Hackage - Trac
13:41:58 <SyntaxNinja> whoa!
13:42:10 <SyntaxNinja> oh, it's just reading the title.
13:42:16 <SyntaxNinja> I thought someone hooked up lambdabot to trac
13:42:23 <CosmicRay> heh
13:42:27 <monochrom> The next version will read the html too :)
13:44:02 <bringert> CosmicRay: I want to do similar stuff
13:44:22 <bringert> I e-mailed JaffaCake about the status of that ticket yesterday, no response yet
13:44:44 <bringert> I'd be willing to try to implement it myself
13:48:25 <SyntaxNinja> yay!!
13:48:28 <SyntaxNinja> I will give you candy!
13:48:46 <SyntaxNinja> I will buy you beer!
13:49:09 <bringert> good thing I'm not so far away then
13:49:18 <bringert> fedexing beer is messy
13:49:26 <bringert> I just want to see what JaffaCake is doing with it first
13:54:43 <SyntaxNinja> yeah, I think he maybe even has a prototype implementation.  that would be so 1337. we've been needing this for a while.
13:55:54 * ndm goes to get some candy and beer
13:57:18 <SyntaxNinja> ndm: you get none!
13:57:33 <SyntaxNinja> ndm: you still haven't hacked yhc support into cabal which you promised when you had beer in estonia! ;)
13:58:43 <ndm> SyntaxNinja: i'm still hacking yhc support into yhc!
13:59:05 <ndm> although i have started doing some cabal stuff
13:59:19 <ndm> i have a .cabal file handler that does the right business on windows
13:59:29 <ndm> i.e. "clicky clicky" gives "worky worky"
14:00:22 <SyntaxNinja> heh. ndm's first step in writing yhc, "add clicking support to windows"
14:00:44 <ndm> SyntaxNinja: bug free clicking support ;)
14:01:32 <ndm> with my setup, you just double click the .cabal file and it does evertyhing else
14:01:54 <ndm> no horrible unix configure build stuff
14:06:13 <SyntaxNinja> cool
14:06:40 <SyntaxNinja> you mean it opens the file in a text editor?  or it builds a tarball source dist?  or it installs it?
14:07:03 <inv> hi all
14:08:27 <dmhouse> Hey inv.
14:09:48 <monochrom> Are you invertible?
14:10:18 <edwinb> But I like my horrible unix configure build stuff! :)
14:12:06 <SyntaxNinja> edwinb: then don't clicky-clicky
14:12:20 * edwinb realises he's using a Mac now and shuts up
14:12:39 <edwinb> I had a dumb cabal question, btw...
14:12:49 <ndm> SyntaxNinja: configures, builds and installs
14:12:56 <edwinb> Can I tell it what options to send to happy? I couldn't work out how...
14:21:25 <SyntaxNinja> edwinb: there's no --happy-args option or whatever?
14:25:50 <edwinb> I didn't find one...
14:25:56 <edwinb> maybe i wasn't looking hard enough
14:32:05 <SyntaxNinja> is there an easy csv parser in Haskell that I can use now?
14:43:43 <dmhouse> Hah! Who's seen the latest Motorola PEBL advert?
14:43:47 <dmhouse> It involves a stone being skimmed an extremely long distance over a lake/sea/whatever.
14:43:52 <dmhouse> At at the bottom, the small text reads 'Fictionalisation. The PEBL phone is not water resistant.' :)
14:44:37 <SyntaxNinja> hi Igloo!
14:45:01 <Igloo> 'evening, Mr Jones!
14:45:38 <CosmicRay> hey SyntaxNinja
14:46:57 <SyntaxNinja> heya CosmicRay
14:47:03 <ndm> grr, all the single character operators have been taken!
14:48:43 * Igloo hands ndm the unicode spec
14:49:08 <ndm> Igloo: I have £, but its a bit ugly for my purpose
14:49:21 <ndm> I am tempted to be evil and use - by making my thing a very very bad num instance
15:02:16 <lispy> hmm..it seems that i need xsd2html
15:02:20 <lispy> er
15:02:24 <lispy> not at all what i need
15:02:27 <lispy> i need xsd2haskell
15:03:03 <lispy> i thought maybe i could go xsd -> dtd -> haskell but that route seems ugly at best.  the dtd file generated from the xsd was pathetic
15:06:02 <lispy> unfortunately i don't think i understand xsd enough to write the translation myself or byhand
15:13:59 <lispy> why would i want to use newtype?
15:14:23 <lispy> i'm looking at figures 7-8 on this page and they use a lot of newtype: http://www.cs.york.ac.uk/fp/HaXml/icfp99.html
15:14:24 <lambdabot> Title: Haskell and XML: Generic Combinators or Type-Based Translation?
15:15:15 <greenrd> lispy: Because it's more efficient than data and you can't use type for everything
15:17:17 <lispy> okay
15:17:20 <lispy> thanks
15:39:37 <lispy> well i guess i see a project for someone
15:39:51 <lispy> extend HaXml by adding xsd2haskell
16:18:15 <lispy> glad i'm not using C# http://blogs.msdn.com/brada/archive/2004/08/03/207164.aspx
16:18:17 <lambdabot> Title: Brad Abrams : Fun with Anonymous Methods
16:26:15 <sjanssen> woo, my type level Fibonacci program can find the 2^6th Fibonacci number
16:26:27 <edwardk> heh
16:26:38 <edwardk> i think xerox was doing something with type level fibonacci
16:27:04 <sjanssen> edwardk: yeah, but he used the naive recursion.  And Peano arithmetic
16:27:08 <edwardk> ahh
16:27:21 <sjanssen> mine uses the matrix equation and binary number representation
16:27:31 * edwardk nods.
16:27:41 <xerox> Matrix equation?
16:28:26 <xerox> Give me a typerepresentation of irrational numbers  and I'll work out O(1) fibonacci! :-)
16:28:29 <sjanssen> [[1 1][1 0]]^n
16:28:43 <edwardk> i've been slapping together a lot of standard type level primitives just so i have them. got booleans, comparisons, etc. work, been slapping together different bases to profile them in the type system
16:29:10 <edwardk> so i can see if there is a complexity explosion trade off for going to decimal or hexadecimall vs. binary.
16:29:11 <sjanssen> xerox: that lets you do fibonacci in O(log n) multiplications
16:29:39 <xerox> sjanssen: do you have the code somewhere online?
16:29:54 <sjanssen> xerox: yeah, I'll pastebin it
16:30:08 <sjanssen> it probably won't run in GHC 6.5, maybe it'll run in 6.4
16:30:13 <sjanssen> definitely works in hugs
16:30:31 <sjanssen> lisppaste2: url
16:30:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:31:48 <lisppaste2> sjanssen pasted "fast typefibs!" at http://paste.lisp.org/display/22828
16:32:04 <sjanssen> warning: the code is nasty and long, and probably only makes sense to me
16:32:14 <edwardk> heh
16:32:17 <edwardk> its not so bad
16:33:11 <edwardk> the matrix idea is cute
16:33:43 <ailndx> anyone did any fluid simulation?
16:33:56 <edwardk> several years ago for a 3d rendering company, why?
16:34:23 <xerox> sjanssen: that's crazy - did you find out the binary representation in types somewhere?
16:34:43 <ailndx> interested in material/documents on the subject, especially "new that looks good" and just not real basics
16:34:47 <edwardk> xerox: i can send you a pretty complete binary representation version somewhere
16:34:48 <sjanssen> xerox: I think I've seen it in an Oleg paper before
16:35:23 <glguy> what do the ! and ~ prefixes mean?
16:35:27 <xerox> We all build up from Oleg :-)
16:35:34 <glguy> ~ is strict evaluation... right?
16:35:42 <edwardk> robert dockins has one thats pretty complete for binary
16:35:51 <sjanssen> glguy: ~ means lazy pattern matching
16:35:51 <edwardk> ! = strict ~ = lazy
16:36:12 <glguy> What does it mean to use ! in a data definition
16:36:25 <edwardk> it means that before you can store something in that slot, you have to evaluate it
16:36:35 <glguy> ah
16:36:41 <sjanssen> evaluate to WHNF, that is
16:36:49 <edwardk> yeah
16:37:03 <glguy> and what is the reason you used the lazy evalution on that show function?
16:37:21 <xerox> You Wink-Heads!
16:37:51 <sjanssen> glguy: because the value I want to show is usually bottom, so if you pattern match you just get an error
16:38:21 <sjanssen> so the ~ lets me get at the types of the things inside without actually needing the things
16:39:35 <edwardk> interesting that you chose to put the add and carry as separate classes
16:39:56 <edwardk> rather than merge into one with the carry bit and sum as separate fundeps
16:40:54 <sjanssen> I didn't think this through before I started
16:41:00 * edwardk nods.
16:41:44 <sjanssen> I'm a bit embarrassed by the length of the adder
16:41:52 <sjanssen> bet I could do that better
16:42:16 <glguy> this is kind of like writing a program in C++ template language... isn't it
16:42:28 <sjanssen> glguy: very similar to it
16:42:37 <lisppaste2> edwardk pasted "type booleans" at http://paste.lisp.org/display/22829
16:42:44 <sjanssen> glguy: you'll also see a similarity to prolog if you stare closely
16:42:57 <edwardk> i haven't gone much farther than that with the type programming in haskell
16:43:10 <edwardk> reminds me a lot of the template metaprogramming in c++ though
16:43:10 <glguy> I've seen so little Prolog code that I don't know that I'd make the connection :)
16:43:11 <sjanssen> edwardk: bet I'd save a lot of work moving to an HList of TBools
16:43:34 <edwardk> not sure
16:43:39 <edwardk> HLists can be dog slow
16:44:20 <sjanssen> right, but the HList is nearly the same as my dual type constructor approach
16:44:24 <edwardk> i mostly started this to aim towards completeness, not minimalism
16:44:35 <edwardk> i figured i'd do the same thing with the type naturals when i can get there
16:44:42 <edwardk> i just need to figure out the most efficient radix for speed
16:47:06 <edwardk> the robert dockins code i have for base 2 is basically the same as yours, but fleshed out to like 17k worth of division, and gcd etc.
16:47:18 <xerox> What is your dual type constructor approach, sjanssen ?
16:47:39 <edwardk> that seems like the most likely basis for me to build a solid library on at the moment, unless the decima version blows its doors off compilation wise
16:47:44 <sjanssen> xerox: data O n; data I n;
16:47:49 <edwardk> he uses O x and I x to indicate 0 or 1
16:47:51 <edwardk> and a terminal digit
16:47:59 <edwardk> then you just write the number in binary backward
16:48:01 <edwardk> er backwards
16:48:04 <edwardk> (i presume)
16:48:17 <xerox> Makes sense.
16:48:25 <sjanssen> the terminal digit was really a pain in the ass
16:48:34 <edwardk> if you want you can define types for Ox0... OxF and code it backwards in hexadecimal ;)
16:48:34 <xerox> Why?
16:48:41 <sjanssen> but that might be the best way to do it, I'm undecided
16:48:47 <edwardk> because all you need is a type to alias the existing ones.
16:49:07 <xerox> It's okay as long as the programmer is undecided, it becomse problematic when the program itself is undecidable.
16:49:13 <glguy> type OxF = I I I I I I I I N ?
16:49:20 <edwardk> type Ox0 = O$O$O$O$N; type Ox1 = I$O$O$O$N
16:49:34 <edwardk> er
16:49:36 <edwardk> my bad
16:49:38 <xerox> We don't have type-level application operators ed :)
16:49:44 <sjanssen> xerox: in an instance decl, you can't distinguish between "I x" and "I N"
16:50:04 <edwardk> type Ox0 a = O (O (O (O (a))))
16:50:05 <edwardk> etc
16:50:09 <edwardk> xerox: bah =)
16:50:10 <xerox> Modulo incoherent instances?
16:50:20 <sjanssen> yeah
16:50:26 <xerox> edwardk: "bah" ! it's problematic.
16:50:38 <edwardk> whats incoherent about the instances?
16:51:10 <edwardk> we need a type level application operator, the above is so much cleaner ;)
16:51:11 <xerox> Ask GHC :(
16:51:12 <sjanssen> edwardk: they aren't, but they'd be much shorter if they were
16:51:16 <edwardk> yeah
16:51:26 <sjanssen> don't we have infix tycons?
16:51:33 <xerox> We do.
16:51:47 <edwardk> infix type constructors, yes, but no love for $ in a type expression,eh?
16:51:53 <edwardk> so much for consistent replacement of ()'s
16:52:11 <xerox> ?type ($)
16:52:13 <lambdabot> forall b a. (a -> b) -> a -> b
16:52:18 <glguy> infix type cons with a single argument would just reverse the order... right?
16:52:32 <sjanssen> could we write: type a $ b = a b?
16:52:32 <edwardk> heh, i suppose could write one :$: or something right?
16:52:40 <xerox> I don't think so.
16:52:43 <sjanssen> I guess I want infix type synonyms
16:52:45 <edwardk> i think type constructors have to be : surrounded.
16:53:35 <edwardk> and yeah that would be weird
16:53:57 <sjanssen> sweet, we can!
16:54:03 <edwardk> $ or :$:?
16:54:54 <xerox> Oh wait, it does work.
16:54:59 <edwardk> heh
16:55:02 <edwardk> whew
16:55:08 <xerox> Mumble.
16:55:10 <edwardk> then i don't have to rewrite all that code that i thought compiled =)
16:55:34 <sjanssen> don't think hugs supports that though
16:55:40 <edwardk> who needs hugs ;)
16:55:58 <xerox> data a :$ b = a :$ b
16:56:20 <xerox> {-# OPTIONS_GHC -fglasgow-exts #-}
16:56:47 <sjanssen> does my code run in GHC 6.4, with appropriate options?
16:57:39 <monochrom> type constructors have to begin with :.  No need to surround.
16:58:50 <edwardk> it doesn't like some of your stuff
16:58:53 <edwardk> instance (Mult' (I x) (I y) r) => Mult (I x) (I y) r
16:58:55 <xerox> Does it really work?
16:58:55 <edwardk> for instance
16:59:09 <xerox> I mean, what do we get out of :$ ?
16:59:29 <sjanssen> it may only run in Hugs
16:59:29 <edwardk> no surrounding parens on the far side =)
17:00:11 <monochrom> Wait!  type constructor /= data constructor!  I was sleeping!
17:00:43 <xerox> Ah.
17:00:47 * xerox tries something
17:00:56 <monochrom> infix data constructors have to begin with :.   I only know that one.
17:01:03 <edwardk> http://slipwave.info/haskell/TypeNats.hs has a version that works for ghc
17:01:31 <edwardk> but not the fib part
17:01:37 <edwardk> just the mult stuff that isn't working in yours
17:01:38 <edwardk> =)
17:01:45 <edwardk> you'll note a very similar design
17:03:46 <edwardk> i like his interpretation of Z as an infinite string of 0 digits
17:03:52 <sjanssen> yeah
17:04:05 <edwardk> its very clean, almost seems like a feature =)
17:04:09 <xerox> How do you do binary operations with :$ ?
17:05:11 <sjanssen> edwardk: looks like this code uses the separate add/carry classes
17:05:47 <Pseudonym> G'day.
17:05:49 <Pseudonym> Sorry, afk.
17:05:50 <Pseudonym> Backj now.
17:06:31 <xerox> Howdy Pseudonym.
17:06:33 <edwardk> hadn't gotten down to that part
17:06:39 <edwardk> i had been writing a decimal version
17:06:50 <edwardk> i wanted to have apples to compare with apples for a speed test
17:07:09 <monochrom> data Employer = String :$ Int    -- example
17:08:29 <monochrom> infix type constructors are a ghc extension.  begins with :.
17:09:18 <monochrom> data a :* b = a :+ b   --- the lhs is an extension, the rhs is haskell 98.
17:10:01 <Pseudonym> Infix types are useful.
17:10:18 <monochrom> There are also infix class names in the extension  :)
17:10:18 <Pseudonym> Actually, it'd be cool if (->) were expressible as a Prelude-defined type.
17:10:28 <Pseudonym> Realistically, of course...
17:10:41 <Pseudonym> You could parse function application as the null operator.
17:10:53 <Pseudonym> We did that trick in Mercury.
17:11:05 <Pseudonym> Foo(Bar,Baz) was parsed as ''(Foo,Bar,Baz)
17:11:10 <Pseudonym> where '' is the (quoted) null functor
17:11:50 <xerox> Can you imagine how to do binary arithmetics with data I; data O; data a :$ b = a :$ b ?
17:13:28 <sjanssen> xerox: it'd be largely the same
17:13:56 <xerox> Beats me how do you get it right, but maybe it's just that I'm really rtired.
17:14:13 <bringert> xerox: I remember implementing something like that at some point
17:14:42 <bringert> but I made it easier by using fixed-width binary arithmetic
17:15:51 <xerox> I can imagine so, indeed
17:42:18 <lispy> it always amazing me how quiet the internet seems from 5-6pm in my timezone
17:43:01 <aref> lies
17:43:40 <zarvok> Yes, it seems a disproportionate number of #haskellers are not in the US
17:44:18 <zarvok> which is where I assume  you are, if  it is between 5 and 6 for you now
17:44:33 <glguy> I would assume that most people are eating now
17:44:43 <glguy> in my time zone (CST) at least
17:45:24 <zarvok> well, if you look at, say, google usage stats, there is a huge bump in the 5-7pm bracket for US timezones as people come home from work
17:45:31 <glguy> ah
17:45:54 <zarvok> so it seems strange that the channel is quiet now
17:46:04 <zarvok> what was the link to the #haskell usage stats page?
17:46:31 <bringert> lots of people here are from Europe, so they're sleeping now
17:46:41 * bringert is also from Europe
17:46:43 <zarvok> yes, that's what I was saying
17:47:00 <BCoppens> <.eu going to sleep ;)
17:47:13 <bringert> zarvok: well, you said not in the US :-)
17:47:21 <Kahdloc> i'm in the us.
17:47:23 <zarvok> heh, fair enough
17:47:46 * bringert is also in the US
17:48:03 <bringert> european temporary expatriot
17:48:18 <zarvok> I've observed, since I started idling here a few weeks ago, that many more users seem to be from europe than I would have guessed from general internet usage trends
17:48:20 <Kahdloc> mmm, i live here.
17:48:29 <zarvok> which is interesting to me
17:48:45 <lispy> i'm on the US westcoast, but it seems like a couple of the channels i idle in get quiet this time of day
17:49:00 <bringert> you'd probably have to go by general haskell usage trends, rather than internet usage trends
17:49:13 <Kahdloc> well, you can't go off of the google usage stats for IRC traffic. a lot of people who use google don't know what IRC is.
17:49:29 <lispy> they could google for it :
17:49:31 <zarvok> yes
17:49:38 <Kahdloc> they could, if they'd ever heard of it.
17:49:45 <zarvok> of course, most of the haskell greats (SPJ, wadler) are not in the states
17:49:57 <Kahdloc> google can't help you if you know nothing of what you seek.
17:50:18 <lispy> seek not what you cannot find
17:50:44 <Kahdloc> if you don't seek it, how do you know you can't find it?
17:51:01 <Kahdloc> ok, enough of that. i'm getting confused with the odd manner of talking.
17:51:11 * lispy is grinding out a datatype to match Spreadsheet XML and maybe a tad delirous
17:52:11 <lispy> wish i knew how i was going to convince HaXml to read/show my datatype...
17:52:53 <lispy> i may end up creating my own pretty printer (and reading isn't important for my task)
17:56:25 <headnerd> hello
17:56:59 <Kahdloc> 'lo
17:58:19 <headnerd>  not much going on here just trying to gert my forums populated.
17:59:52 <headnerd>  looks like its time for another round of updates on my windows crox.
18:00:38 <lispy> are you the headnerd at the nerdery?
18:01:39 <lispy> if so that's a coveted title...
18:02:49 <headnerd>  you got it check out http://www.compuporter.net/forums/index.php oh and sign up and send some people over there.
18:02:52 <lambdabot> Title: TechnologyTalk
18:03:04 <headnerd>  yep thats it.
18:23:10 <lispy> headnerd: you need some seed content
18:24:45 <lorne> is that meant to say 'back-rounds'?
18:25:29 * dgoldsmith is also in the US
18:28:42 <headnerd>   well you could provide some seed content i've got to down boot due to a localized brownout.
18:29:59 <headnerd>  doesn't mean i said no to international users.
18:32:17 <headnerd>  yep you got that right lorne.
18:42:54 <Korollary> G'day
18:47:53 <Pseudonym> G'day.
18:48:59 <headnerd> hey Pseudonym
18:49:53 <lispy> down boot?
18:51:22 <headnerd>  I meant my windows box becuse my laptop is my fedora rig.
18:55:28 <lispy> down boot doesn't make sense given the meaning of 'bootstrap'
18:56:25 <headnerd>  I used it to refer to shutting down M$ Window$.
19:17:09 <dibblego> good afternoon
19:17:56 <dons> morning!
19:18:00 <dons> oh, afternoon
19:18:25 <dons> ah, dibblego. same timezone I see :)
19:19:25 <dibblego> :)
19:19:36 <dibblego> yeah mate GMT+10 all round
19:19:50 <dons> heh
19:34:05 <zarvok> \
19:34:08 <zarvok> oops
19:37:37 <Kahdloc> i gotta get another watch...
19:42:17 * johnnowak recommends timex
19:46:36 <Kahdloc> yes, timex is good...i'll have to stop by the store later this week...
19:46:42 <sjanssen> Hugs takes way too long to compute the 256th Fibonacci number at the type level
19:47:12 <dons> heh
19:47:17 <Kahdloc> define 'too long'
19:47:28 <dibblego> are there any functional languages that target the Java VM?
19:47:45 <sjanssen> Kahdloc: I'm not sure, maybe 5 minutes?
19:47:45 <dons> Scala? Or isn't that considered functional.
19:47:53 <johnnowak> dibblego: does scheme count?
19:47:54 <dons> there's a scheme backend, bigloo? that runs on the jvm
19:48:06 <dylan> scala is functional, and also object oriented.
19:48:58 <dons> hey dylan
19:55:57 <dibblego> inc is of type Integer -> Integer
19:56:13 <dibblego> does that mean that it takes an Integer parameter and returns an Integer parameter?
19:56:20 <dibblego> it was Scala that I was thinking of, thanks
19:56:30 <sjanssen> dibblego: yes
19:56:42 <dibblego> sjanssen, what if the function takes two parameters?
19:57:02 <dibblego> is + a function? that takes two Integers doesn't it?
19:57:08 <sjanssen> Integer -> Integer -> Integer -- there's a function that takes two integers and returns another
19:57:28 <sjanssen> dibblego: yeah (+) is a function, and it can take two Integers
19:57:31 <sjanssen> @type (+)
19:57:33 <lambdabot> forall a. (Num a) => a -> a -> a
19:57:46 <dons> > (+) 1 2
19:57:48 <lambdabot>  3
19:58:08 <dibblego> @type (*)
19:58:10 <lambdabot> forall a. (Num a) => a -> a -> a
19:58:13 <dons> > 1 * 2
19:58:14 <lambdabot>  2
19:58:21 <dons> > (*) 3 2
19:58:22 <lambdabot>  6
19:58:36 <dibblego> ok cheers
19:59:08 <dibblego> @type inc
19:59:09 <lambdabot> Not in scope: `inc'
19:59:16 <dons> @type succ -- ?
19:59:17 <lambdabot> forall a. (Enum a) => a -> a
19:59:25 <dons> > succ 5
19:59:26 <lambdabot>  6
19:59:28 <dons> > succ 'x'
19:59:29 <lambdabot>  'y'
19:59:37 <dons> > succ True
19:59:38 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
19:59:46 <dons> > succ False
19:59:47 <lambdabot>  True
19:59:51 <dibblego> what is succ?
20:00:04 <dons> generates the successor, according to the Enum instance
20:00:17 <dons> which works for the following types
20:00:18 <dibblego> so an Enum has an order?
20:00:22 <dons> @instances Enum
20:00:23 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
20:00:31 <dibblego> > succ 'a'
20:00:33 <lambdabot>  'b'
20:00:36 <dibblego> ok
20:00:38 <dons> > pred 'b'
20:00:39 <lambdabot>  'a'
20:00:43 <dons> > succ ()
20:00:44 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
20:01:04 <dons> hmm
20:01:08 <dons> > succ 0.12312
20:01:09 <lambdabot>  1.12312
20:01:11 <dons> ah
20:01:19 <dons> didn't know that
20:01:27 <dons> > succ LT
20:01:28 <sjanssen> > succ 1e100 == 1e100
20:01:29 <lambdabot>  EQ
20:01:30 <lambdabot>  True
20:01:34 <dibblego> > pred 0.0
20:01:36 <lambdabot>  -1.0
20:01:52 <dons> @instances Bounded
20:01:53 <lambdabot> (), (a, b), (a, b, c), Bool, Char, Int, Ordering
20:02:16 <dons> that seems a bit arbitrary
20:02:19 <dons> why not Maybe a
20:02:54 <dibblego> no idea
20:03:01 <dibblego> isn't Ptolemy spelt with an 'e'?
20:03:03 <sjanssen> @instances Ord
20:03:05 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
20:03:12 <sjanssen> @instance Enum
20:03:13 <lambdabot> Maybe you meant: instances instances-importing
20:03:21 <sjanssen> @instances Enum
20:03:22 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
20:04:24 <dons> Either a b. Maybe is left out of the party, it seems
20:04:42 <dibblego> "For example, (forall a)[a] is the family of types consisting of, for every type a, the type of lists of a." - what on earth does that mean?
20:04:43 <dons> i'd think Maybe a should be Ord, as Nothing < Just a
20:05:16 <sjanssen> dons: yeah, Ord and Bounded
20:05:17 <dons> forall a. [a] -- in haskell
20:05:44 <dons> sjanssen: so then we'd have a way to enum types of 1, 2, 3 , 4 ... and so on elements
20:06:13 <dons> > enumFromTo minBound (maxBound :: ())
20:06:14 <lambdabot>  [()]
20:06:22 <dons> > enumFromTo minBound (maxBound :: Bool ) -- 2 elems
20:06:23 <lambdabot>  [False,True]
20:06:34 <dons> > enumFromTo minBound (maxBound :: (Bool,Bool)) -- 4 elems
20:06:35 <lambdabot>  add an instance declaration for (Enum (Bool, Bool))
20:06:35 <lambdabot>   In the definition o...
20:06:37 <dons> ah, missing
20:06:49 <dons> we should be able to Enum (a,b) and Maybe a
20:06:59 <sjanssen> another instance I'd like to see: Storable for tuples
20:07:10 <dons> @instances Storable
20:07:11 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:07:18 <dons> bah
20:07:30 <dons> @help instances-importing
20:07:30 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
20:07:40 <dons> @instances-importing Foreign Storable
20:07:41 <lambdabot> Bool, Char, Double, Float, FunPtr a, Int, Int16, Int32, Int64, Int8, Ptr a, StablePtr a, Word, Word16, Word32, Word64, Word8
20:07:46 <sjanssen> dons: you're talking "instance (Bounded a) => Enum (Maybe a) where ..."?
20:07:55 <dons> yeah
20:08:03 <dons> just push Nothing onto the start of the enum list
20:08:16 <dons> (like a C pointer! at address 0 ;)
20:08:49 <sjanssen> Storable for tuples would follow the same rules as structs, which could be quite nice
20:08:53 <dons> we could almost certainly submit a patch for these.
20:09:11 <dons> mm. yes
20:09:16 * SamB_XP wonders why WcDonalds is such a popular fast food chain in anime
20:09:37 <dons> it's foreign and exotic? ;)
20:10:05 <Kahdloc> i've never seen a mcdonolds in a cartoon.
20:10:09 <SamB_XP> don't want to get sued for trademark infringement if they put the arches right-side up
20:10:14 <SamB_XP> Kahdloc: I said WcDonalds
20:10:21 <Kahdloc> wcdonolds then
20:10:32 <SamB_XP> it is just like McDonalds only the logo is upside down and the colors might be changed
20:10:37 <dylan> To avoid being sued for trademark infringement?
20:10:38 <Kahdloc> come to think of it....i've never seen a fast food join in a cartoon...
20:10:53 <Kahdloc> s/join/joint/
20:11:23 <SamB_XP> I think I saw it in Ranma once, and now I've seen it in "THe Melancholy of Huruhi Suzumiya"
20:11:32 <sjanssen> Kahdloc: never seen a Krusty Burger?
20:12:26 <Kahdloc> nope...
20:12:42 <Kahdloc> come to think of it...i don't watch cartoons much anymore.
20:14:47 * dons hopes for soc-fps patches ...
20:15:24 <dons> bah. only my code.
20:15:26 <dons> sjanssen: !
20:15:30 <dons> get hacking!
20:18:24 <SamB_XP> hmm, I appear to be fresh out of Melancholy, unless I am sorely mistaken
20:24:44 <SamB_XP> I fear I shall have to go to bed, for noone is having interesting conversations and, I am too tired to play wesnoth, and I seem to be out of fresh anime...
20:25:06 <dons> is bed that scary?
20:25:16 <SamB_XP> well no, not really
20:25:34 <SamB_XP> I was just being silly ;-P
20:25:58 <dons> ;)
20:28:21 <SamB_XP> especially with Star Wars™ X-Wing™: Rogue Squadron™ to read ;-)
20:28:46 <SamB_XP> hmm, you know, the character map in XP ain't half bad if you do a text search
20:30:44 <SamB_XP> anyway, off I go now...
20:32:15 <dons> oh, lovely, Object-Oriented PHP
20:32:45 <dons> maybe we should write books on all the wacky idioms we come up with in haskell
20:33:08 <dons> pointfree haskell, ffi haskell, type-level haskell, monadic haskell, typeclass haskell ...
20:33:13 <dons> there's 50 books here
20:35:25 <foxy_> can you mmap files in haskell?
20:35:49 <dons> yep
20:36:05 <dons> since you just call mmap, get a Ptr Word8, then go nuts
20:36:15 <dons> darcs does this extensively
20:36:19 <foxy_> @hoogle mmap
20:36:19 <lambdabot> No matches found
20:36:44 <foxy_> oh, you mean call C mmap through FFI?
20:36:54 <dons> there's no current lib. in the Win32 library we have a mmap, in fps 0.4 and earlier there's an mmap (its commented out currently, since its not portable), and Streams 0.2 has an mmap
20:37:11 <dons> also, i have a tiny mmap lib if you'd like that.
20:38:09 <dons> but year, calling mmap over the ffi ain't too hard, and that's how all the current libs do it.
20:38:35 <foxy_> is that the best approach to read in a Binary File format with header and data?
20:39:18 <dons> oh, I'd just read it in via fps, using the Binary class to do the parsing
20:39:27 <dons> or if its simpler, just fps list functions to parse the header
20:39:34 <dons> there's no special need to mmap, I think
20:40:05 <dons> you do want packed strings/unboxed arrays though, if its large.
20:41:42 <foxy_> OK, thanks
20:41:44 <wli> How do you use the mmap()'d memory once you've got it?
20:41:53 <dons> well, you get back a Ptr Word8
20:41:59 <dibblego> can I define functions with ghci?
20:42:00 <dons> I'd then use that to build a ByteString
20:42:05 <dons> dibblego: yes, with 'let'
20:42:11 <dons> > let f x = x + 1 in f 7
20:42:12 <dibblego> ah
20:42:12 <lambdabot>  8
20:42:21 <dons> in ghci, you don't need the 'in f 7' bit though
20:42:27 <dons> it'll stay in scope
20:42:31 <dibblego> got it thanks
20:43:01 <dons> wli, since a ByteString is a (ForeignPtr Word8) Int Int
20:43:18 <dons> so you just calculate the length, attach a finaliser to unmap when the string goes out of scope, and you're done
20:43:57 <dons> you could convert a Ptr Word8 to a UArray Word8 too
20:44:53 <wli> Not sure how to get values out of ForeignPtr's et al.
20:46:30 <dons> using withForeignPtr $ \ptr -> .. peek ptr
20:47:05 <dons> which you'd then wrap up in a nice inteface for your user.
20:47:31 <dons> e.g.
20:47:32 <dons> unsafeIndex (PS x s l) i = assert (i >= 0 && i < l) $
20:47:32 <dons>     inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+i)
20:47:42 <wli> hmm peek
20:47:43 <dons> so a fast !!
20:47:50 <wli> Reminds me of BASIC.
20:50:47 <dibblego> let double n = n : double (n * 2) in 4
20:50:52 <dibblego> why doesn't this go on forever?
20:51:04 <dibblego> doesn't 'in' apply 4 to the function?
20:51:11 <dons> no!
20:51:14 <dibblego> oh
20:51:20 <dons> > let double n = n : double (n * 2) in double 4
20:51:21 <lambdabot>  [4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26214...
20:51:42 <dons> 'let' and 'in' are a bit like { } in some languages
20:51:42 <dibblego> ah right
20:52:26 <dons> more like ; really. so you were writing:  double n = ... ; 4 ;
20:53:21 <dibblego> yeah I figured that
20:54:08 <Korollary> the "... in 4" is the key. No more is necessary for computation of 4, thus double (n * 2) is not needed to be computed.
20:54:30 <dibblego> I was just taking a stab - I have no idea what I am doing and it was coincidental the function even worked
20:54:38 <dons> :)
20:54:59 <dons> > let x = undefined ; y = [1..] in 7 -- lots of big computations, never computed
20:55:00 <lambdabot>  7
20:55:03 <Korollary> dons: ready for icfp?
20:55:13 <dons> Korollary: getting tuned up, yep.
20:55:24 <dons> got my cabalised repo, and lambdabot running darcsPatchWatch
20:55:33 <dons> just have to tweak my sleeping habits a bit
20:55:50 <Korollary> are you restricted to using stock ghc?
20:56:00 <dons> no. you submit binaries
20:56:04 <Korollary> oh ok
20:56:08 <dons> so you're restricted to something that runs on stock linux
20:56:11 <Korollary> ByteString is legal then
20:56:15 <dons> yes!
20:56:19 <dons> but probably not needed, I suspect
20:56:28 <dons> we only needed base and fgl last year
20:56:45 <dons> but who knows..
20:56:47 <Korollary> you could substitute it in a whim if needed anyway
20:56:51 <dons> yep
20:57:29 <dons> i remember a few people complaining about performance last year (someone encoded a 10M graph in a .hs source file, and wondered why ghc took 2 hours to compile it)
20:57:45 <dons> maybe those people will benefit from fps ... the dumb ideas will still work ;)
20:57:54 <Korollary> it still shouldnt have taken that long.
20:58:14 <Korollary> I remember an email in the lists complaining about unusual compilation times
20:58:18 <dons> it _shouldnt_ but did. and static data is a known issue
20:58:18 <Korollary> for ghc
20:58:24 <Korollary> but not hbc
20:58:32 <Korollary> ah I see
20:58:44 <dibblego> can I tell ghci to forget a function definition?
20:58:51 <dibblego> unlet?
20:59:12 <dons> ah, :reload maybe?
20:59:22 <dons> why have I never needed to do this?
20:59:33 <dons> dibblego: rebind it to something? let f = undefined
20:59:46 <Korollary> that works
21:00:25 <dibblego> is 'undefined' exactly the same as if it were never defined?
21:00:32 <Korollary> no
21:00:33 <dons> no
21:00:36 <dons> > undefined
21:00:37 <lambdabot>  Add a type signature
21:01:00 <dons> its the 'bottom' value. a divergent computation, that is an element of every type
21:01:06 <dons> an interesting property of lazy languages
21:01:16 <dons> > undefined :: ()
21:01:17 <lambdabot>  Undefined
21:01:42 <Korollary> I don't usually define functions at the prompt
21:01:58 <dons> sometimes i do when testing/debugging
21:02:39 <dons> dibblego: you can use 'undefined' in place of any value. its a black hole that immediately fails if evaluated
21:02:48 <dons> but sometimes its useful. often its useful, in fact
21:02:55 <dons> > length [undefined, undefined, undefined]
21:02:56 <dibblego> brb
21:02:57 <lambdabot>  3
21:03:05 <dons> yay for laziness
21:03:34 <dons> we should really know what paper first introduced the idea of a practical use for 'bottom'
21:03:40 <dons> anyone?
21:03:49 <Korollary> there is one?
21:04:00 <dons> i'm sure someone suggested it at some point, yeah?
21:04:16 <dons> it would have appeared in the early Lazy ML papers
21:04:25 * dons greps the haskell@ archives from 1990
21:04:46 <Korollary> dons: I noticed today that ghc comes with HaXml, whose license is gpl/lgpl, but the ghc distribution license is not affected by it.
21:05:11 <dons> oh, interesting.
21:05:26 <dons> well, the're separate packages. you link against them at your own choice
21:05:57 <Korollary> hmm
21:06:20 <lispy> i'm always confused how that works
21:06:32 <lispy> if i use HaXml do i have to distribute my source too?
21:06:36 <dons> The following changes have been proposed (or accepted) for Haskell 1.3.
21:06:38 <Korollary> as long as you dont link against it, the binaries you produce are not affected.
21:06:40 <dons> * Add undefined
21:06:56 <dons>  Undefined
21:06:56 <dons> Add "undefined" to the prelude.  Previous proposals used _ or _|_
21:06:56 <dons> as the name.
21:06:56 <dons> undefined = error "undefined{Prelude}"
21:07:09 <Korollary> so the value existed in another name before
21:07:14 <dons> ah, so that's when the name was chosen. Date: Fri, 8 Sep 1995 23:01:27 -0400
21:07:32 <dons> and the old school guys still write _|_ sometimes
21:08:29 <dons> and the earliest ref to _|_ i have is Date: 13 Oct 91 3:56
21:08:40 <Korollary> isnt this in the haskell history paper?
21:08:46 <dibblego> just playing, I wrote let (+++++) n = map (+n) [1,2,3]
21:08:53 <dibblego> how do I pass the actual list as a parameter?
21:08:58 <dons> Korollary: not sure. didn't see it the other day
21:09:28 <dons> > let  n +++++ xs  = map (+n) xs in 3 +++++ [1..5]
21:09:29 <lambdabot>  [4,5,6,7,8]
21:09:41 <lispy> or even let (+++++) n = map (+n)
21:09:50 <dons> > let  (+++++) n xs  = map (+n) xs in 3 +++++ [1..5]
21:09:51 <lambdabot>  [4,5,6,7,8]
21:10:18 <dons> yes, or you can just partially apply the function in its definition. the type checker takes care of the rest
21:10:52 <dons> > let (+++++) :: Int -> [Int] -> [Int] ;  (+++++) n = map (+n)
21:10:52 <lambdabot>  Parse error
21:10:57 <dons> > let (+++++) :: Int -> [Int] -> [Int] ;  (+++++) n = map (+n)  in (+++++)
21:10:58 <lambdabot>  <Int -> [Int] -> [Int]>
21:11:01 <dons> > let (+++++) :: Int -> [Int] -> [Int] ;  (+++++) n = map (+n)  in (+++++) 2
21:11:02 <lambdabot>  <[Int] -> [Int]>
21:11:06 <dons> > let (+++++) :: Int -> [Int] -> [Int] ;  (+++++) n = map (+n)  in (+++++) 2 [1..3]
21:11:07 <lambdabot>  [3,4,5]
21:11:37 <dons> dibblego: see how we applied each argument one at a time, and got back a valid result on each occasion?
21:11:48 <dibblego> nope, sorry
21:11:52 <hellish> @seen shapr
21:11:53 <lambdabot> I saw shapr leaving #scannedinavian, #haskell.se, #haskell-blah and #haskell 10 hours, 26 minutes and 4 seconds ago, and .
21:11:55 <dons> ah, let's simplify
21:11:59 <dibblego> ok
21:12:02 <dons> > ord
21:12:03 <lambdabot>  <Char -> Int>
21:12:06 <dons> > ord 'x'
21:12:07 <lambdabot>  120
21:12:26 <dons> so in the first case, we evaluated 'ord' to a _function value_
21:12:36 <dons> in the second case, we applied ord to 'x' and got back just an Int
21:12:55 <dons> you can always partialy apply functions in haskell, getting back functions as results
21:12:57 <dibblego> so <Char -> Int> is a function value
21:13:08 <dons> yep, lambdabot just represents functions that way
21:13:23 <dons> > undefined :: Int -> Int -> Int -> Bool
21:13:24 <lambdabot>  <Int -> Int -> Int -> Bool>
21:13:35 <dons> > (undefined :: Int -> Int -> Int -> Bool) 7
21:13:36 <lambdabot>  <Int -> Int -> Bool>
21:13:37 <lispy> dons: i'm not sure the <> are needed, i bet people would get it without them (and they might confuse newbies)
21:13:39 <dons> > (undefined :: Int -> Int -> Int -> Bool) 7 5
21:13:40 <lambdabot>  <Int -> Bool>
21:13:43 <dons> > (undefined :: Int -> Int -> Int -> Bool) 7 5 3
21:13:44 <lambdabot>  Undefined
21:13:59 <dons> once its fully applied (saturated), we get back a value.
21:14:05 <dons> lispy: hmm, perhaps yes
21:14:12 <Korollary> They distinguis between a function value and type signature, tho
21:14:14 <dibblego> I kind of see what you mean
21:14:19 <lispy> well, you get back a value if your program 'demands' it (lazy evaluation)
21:14:24 <jgrimes> ok, I have a function that takes two arguments, and is of type Exp -> Environment -> Int, so it should return an Int. Why when I go to "show" it does it tell me to add an instance declaration for (Show (Environment -> Int)). Shouldn't my function just be evaluating to an Int?
21:14:40 <dons> > let f x y z = x + y + z in let g = f 1 2 in g 3
21:14:41 <lambdabot>  6
21:14:46 <Korollary> jgrimes: too few arguments I think
21:14:58 <jgrimes> ohh..
21:14:59 <jgrimes> ok
21:15:00 <jgrimes> yeah
21:15:09 <jgrimes> I was passing it the second argument everywhere else
21:15:10 <dons> dibblego: see in the example above, i bind 'g' to 'f 1 2', so 'g' is a function waiting for one more argument
21:15:11 <jgrimes> :)
21:15:19 <jgrimes> Korollary, thanks
21:15:26 <Korollary> high five
21:15:33 <dons> dibblego: when i then apply g 3, we get the full computation, x + y + z, evaluated
21:15:54 <dibblego> dons, I see what you mean, for just a second -  Ineed to internalise it now
21:15:56 <dons> so functions 'remember' what arguments they've been applied to
21:16:22 <dons> (they carry around an environment, a "closure", recording this fact)
21:16:33 <dibblego> yep I can see that
21:16:44 <dons> the other aspect is that since functions are just normal values, you can bind them to names
21:16:49 <dons> > let f = ord in f 'x'
21:16:50 <lambdabot>  120
21:16:57 <dons> or stick functions in data structures
21:17:04 <dons> > [ord, ord]
21:17:05 <lambdabot>  [<Char -> Int>,<Char -> Int>]
21:17:07 <jgrimes> Woo. My simple calculator based on the Happy tutorial works.
21:17:17 <jgrimes> With variable replacement
21:17:22 <dons> the above is a list of two functions, each of types Char -> Int
21:17:47 <dibblego> righto, I can see that much for now
21:17:54 <dibblego> thanks for that
21:18:35 <dons> then we have anonymous functions. the infamous lambda
21:18:39 <dons> > (\x -> x + 1)
21:18:40 <lambdabot>  Add a type signature
21:18:42 <dons> > (\x -> x + 1) 2
21:18:43 <lambdabot>  3
21:18:54 <dons> where \x names the arguments
21:19:04 <dons> and -> delimits the body of the function
21:19:35 <dibblego> > (\x -> x * x) 1
21:19:37 <lambdabot>  1
21:19:39 <dibblego> > (\x -> x * x) 2
21:19:41 <lambdabot>  4
21:19:51 <dons> we could stick these in a data structure too
21:19:52 <dons> > [ \x -> x, \x -> x, ord ]
21:19:53 <lambdabot>  Couldn't match `Char' against `Int'
21:19:58 <dons> ah, my mistake
21:20:16 <dons> > [ \x -> x, \x -> (x::Int)]
21:20:18 <lambdabot>  [<Int -> Int>,<Int -> Int>]
21:20:44 <dons> note that from the one type annotation, the compiler inferred the types for the whole structure
21:21:12 <dibblego> yeah I think
21:21:26 <dons> if 'x :: Int' (:: == "has the type"), then \x -> x :: Int -> Int, therefore the whole structure :: [Int -> Int]
21:21:47 <dons> i.e. "list of functions of types Int to Int"
21:22:51 <dons> this shows that, as long as you have type inference, static typing is no notational burden, since all the types can be inferred. no need to write them down
21:23:49 <lispy> but at the same time, it turns out that having key type signatures written down really helps people read your code
21:24:09 <lispy> so we encourage you to write down your type signatures before you define your functions
21:24:18 <dons> yes, since types signatures so accurately describe properties of your code, they act as machine checkable documentation
21:24:41 <lispy> for example
21:24:43 <lispy> @type map
21:24:45 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
21:25:00 <lispy> you can tell a lot about map just from the type signature
21:25:05 <dons> in some cases (theorems-for-free cases) the types uniquely , or close to , define your function
21:25:15 <dons> so there's only 1 non-trivial functoin of types a -> a
21:25:25 <dons> so much so we have tools that can generate this function for us
21:25:28 <dons> ?djinn a -> a
21:25:29 <lambdabot> f a = a
21:25:32 <dons> that's it.
21:26:07 <dons> ?djinn a -> b -> (a,b)
21:26:07 <lambdabot> f a b = (a, b)
21:26:36 * lispy wonders if we scared dibblego away :)
21:26:41 <dons> :)
21:27:07 <dons> well, i suppose we covered heaps of topics just then
21:27:25 <dons> from laziness, to closures, partial application, parametic polymorphism, static typing, type inference
21:27:30 <dons> theorems-for-free
21:27:43 <dons> a few data structures
21:27:50 <lispy> :)
21:27:55 <dons> that's the first 4 weeks of an advanced haskell course :)
21:27:58 <lispy> that's a term of haskell right three
21:28:04 <lispy> yeah
21:28:28 <dons> dibblego: anyway, be sure to ask if you've any questions.
21:28:39 <dibblego> ok thanks a lot
21:28:44 <lispy> dibblego: and you can play with lambdabot here or /msg it
21:28:46 <dibblego> I had to go lift some stuff
21:28:56 <lispy> @type liftM
21:28:57 <dons> ?type lift
21:28:58 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:28:59 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:29:00 <dons> hehe
21:29:05 <dibblego> trying to get FreeBSD on a machine that is a zillion years old and weighs lots
21:29:38 <lispy> hmm..i didn't know about lift
21:29:39 <dons> another consequence of all these strong properties, in particular, the lack of side effects, is that we can mechanically refactor code
21:29:44 <dons> ?pl \x y -> x + y
21:29:44 <lambdabot> (+)
21:29:59 <dons> ?pl map (\x -> x + 1) [1.10]
21:29:59 <lambdabot> [1 . 10 + 1]
21:30:03 <dons> ?pl map (\x -> x + 1) [1..10]
21:30:04 <lambdabot> map (1 +) [1..10]
21:30:28 <lispy> > [ 1 . 10 + 1]
21:30:29 <lambdabot>  add an instance declaration for (Num (a -> c))
21:30:38 <dons> which is fun. i'm not aware of any other code refactoring irc bots out there ;)
21:30:51 <lispy> why didn't that work...
21:30:58 <dons> polymorphic
21:31:12 <dons> > [ (1::Int). 10 + 1 ]
21:31:13 <lambdabot>    Expecting a function type, but found `Int'
21:31:13 <lambdabot>    Expected type: b -> c
21:31:13 <lambdabot>  ...
21:31:27 <dons> anyway, @pl assumed 1.10 was application
21:31:38 <lispy> oh
21:31:40 <lispy> i see
21:31:41 <dons> Num (a -> c)
21:31:42 <lispy> typo
21:31:48 <dons> yup
21:31:54 <lispy> can't really factor broken code :)
21:33:14 <lispy> dons: what are the rules on lambdabot being able to print the functions?
21:33:44 * lispy wonders about making an instance of Num (->) 
21:33:46 <dons> here, (Typeable a, Typeable b) => Show (a -> b)
21:33:55 <dons> that's the rule
21:34:14 <lispy> i'm not familiar with Typeable
21:34:15 <lispy> (yet)
21:34:21 <dons> > toDyn 'x'
21:34:22 <lambdabot>  <<Char>>
21:34:32 <dons> ?type fromDynamic
21:34:34 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
21:34:56 <lispy> i didn't realize we had dynamic types
21:34:59 <dons> > case fromDynamic (toDyn 'x') of Just x -> ord x ; Nothing -> error "dynamic check failed"
21:35:00 <lambdabot>  120
21:35:10 <dons> > case fromDynamic (toDyn "xyz") of Just x -> ord x ; Nothing -> error "dynamic check failed"
21:35:11 <lambdabot>  Exception: dynamic check failed
21:35:15 <dons> sure :)
21:35:24 <dons> dynamic typing is just a degenerate case of static typing
21:35:33 <dons> where you flatten your static types into a single type
21:35:41 <dons> and insert many more checks at runtime
21:35:52 <lispy> well, that's weaking typing isn't it?
21:35:54 <dons> interestingly, that's easier to implement in an interpreter
21:36:00 <lispy> i mean, you could have stronger dynamic typing than that i think
21:36:22 <dons> you could. say perl, and have lists, hashes, functions, scalars
21:36:33 <lispy> for example, i think dynamic typing in lisp is pretty strong compare to say, python or vb
21:36:33 <dons> so you could have a few things staticaly checkable
21:36:52 <dons> oh, how do you mean "strong"
21:37:07 <lispy> i was just wondering that too
21:37:10 <dons> you mean there's no state that can lead to unchecked failure?
21:37:21 <dons> (but this is the same in perl and python, iirc)
21:37:34 <lispy> well, in weak you just have some value you slam around and at the last second you coerce it to something, like turning a string into a number automatically
21:37:51 <dons> but that's not necessarily weak.
21:38:09 <dons> the weak/strong distinction is usually made when comparing C to something.
21:38:19 <dons> where you have types, but not always, and you can break it if you wish
21:38:21 <lispy> well, i think when i was reading the 48hours scheme tutorial they called that weak typing
21:38:59 <dons> so weak typing (either static or dynamic) means you can end up in 'stuck' states from good states
21:39:02 <lispy> because the type conversion is done for you, as needed
21:39:18 <dons> hmm. what happens in lisp then?
21:39:31 <dons> or scheme/
21:39:46 <lispy> i think they differe here quite a bit, but i don't know scheme
21:39:52 <johnnowak> scheme is strongly typed, if that's the question
21:39:56 <lispy> in lisp things have a definite type
21:40:32 <lispy> but unless you're specificly checking for a certain type must things don't care what type the value has
21:40:50 <lispy> for example, #'+ really wants numeric types, so it has to check
21:41:45 <johnnowak> lispy: almost all high level languages are strongly typed... perhaps there are one or two exceptions here and there
21:42:33 <lispy> then what is it called when the lanuage automatically casts things?
21:42:41 <johnnowak> C is weakly typed because you can just proclaim that one piece of data is of a different type by fiat with casts
21:42:59 <jcreigh> lispy: You mean like 1 + "1" yields 2?
21:43:03 <lispy> jcreigh: yeah
21:43:08 <dons> lispy: ah, so in lisp, if the type is wrong at runtime, you don't get a conversion, just (caught) runtime failure?
21:43:18 <dons> s/caught/handled/
21:43:25 <lispy> dons: yeah, with exceptions perhaps
21:43:37 <jcreigh> lispy: I think of that as weakly typed. C is "frikkin-lazy-compiler-writers" typed.
21:43:47 <johnnowak> jcreigh: that's not weakly typed.
21:43:57 <dons> so the issue i have with the automatic conversion is that it seems to end up with a ridiculous number of obscure rules describing the conversions.
21:44:04 <dons> making the semantics _very_ unclear
21:44:11 <lispy> dons: yeah
21:44:16 <dons> even C's promotion mechanism is obscure
21:44:19 <lispy> dons: and sometimes it's just hiding bugs
21:44:56 <lispy> yeah, C's rules about numeric conversions causes so much confusion
21:45:14 <johnnowak> something like 1 + "1" = 2 is just an example of type coercion. it doesn't violate strong typing.
21:45:24 <dons> however, if you don't have a mechanism to deal with these things, then you've got to handle all the type conversions manually, as with say haskell, but you've missed out on the static checks.
21:45:42 <dibblego> > (^) 3 3
21:45:44 <lambdabot>  27
21:45:59 <dibblego> > 3 ^ 3
21:46:01 <lambdabot>  27
21:46:28 * jcreigh reads scrollback
21:46:47 <lispy> dibblego: you can wrap normal function names in `` to make it infix, btw
21:46:56 <lispy> > let f = (+) in 1 `f` 1
21:46:58 <lambdabot>  2
21:46:59 <jcreigh> johnnowak: How are you defining strong typing?
21:47:00 <dons> so then it comes down to whether you consider the obscure conversion rules handing your error at runtime, better than obscure type systems handling your error at compile time (though at least the type system's documented though ;)
21:47:38 <audreyt> coercion rules are documented too :)
21:47:42 <lispy> so, strong typing isn't enough...it's just one aspect of being a better language
21:47:51 <dons> audreyt: good!
21:47:56 <dibblego> this tutorial keeps referring to the "Haskell report" - where is that?
21:48:11 <dons> haskell.org :)
21:48:13 <lispy> @hoogle haskell98 report
21:48:14 <johnnowak> jcreigh: a strongly typed language is a language where the values all have an associated type which cannot be circumvented.
21:48:15 <lambdabot> Did you mean: Haskell98 Report
21:48:15 <lambdabot> Prelude.undefined :: a
21:48:15 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:48:19 <lispy> haah
21:48:22 <dons> lispy: no ;)
21:48:24 <lispy> @google haskell98 report
21:48:26 <lambdabot> http://www.haskell.org/definition/haskell98-report.pdf
21:48:41 <audreyt> http://haskell.org/onlinereport/
21:48:43 <lambdabot> Title: The Haskell 98 Language Report
21:48:47 <dons> ?where h98
21:48:47 <lambdabot> I know nothing about h98.
21:48:49 <johnnowak> jcreigh: it doesn't mean you can't convert it to another type safely, but it doesn't mean you can't ignore it or arbitrarily change it and consequently get undefined behaviour
21:48:52 <dons> ?where haskell
21:48:52 <lambdabot> http://haskell.org/
21:48:55 <dons> ?where haskell98
21:48:56 <lambdabot> http://haskell.org/onlinereport/
21:48:57 <dons> ah
21:48:59 <johnnowak> er. it DOES mean you can't ignore it rather
21:49:06 <dons> ?where+ h98 http://haskell.org/onlinereport/
21:49:06 <lambdabot> Done.
21:49:51 <dons> audreyt: are there proofs (or is it considered) that no stuck state can be reached via runtime type coercions?
21:49:56 <dons> in perl, say.
21:50:05 <dibblego> but there is no Appendix A in that document - which is referred to
21:50:05 <dons> stuck/or undefined
21:50:18 <audreyt> dons: in perl5, sure
21:50:28 <audreyt> because it's defined nonrecursively ;)
21:50:37 <audreyt> i.e. there is at most one coercion attempted
21:50:45 <audreyt> and there is a finite set of target types (all primitive)
21:50:50 <audreyt> you can add user types to it
21:50:58 <audreyt> but it's still finite, and it's still not nested
21:51:00 <dons> right, and there's an exhaustive set of rules?
21:51:04 <audreyt> yup.
21:51:22 <jcreigh> johnnowak: Okay, so you're saying that the reason C is weakly typed is because the C spec is filled with places that say, "if you do this, anything could happen"?
21:51:32 <audreyt> class Coercible a b where coerce :: a -> b
21:51:41 <dons> ah, much better :)
21:51:44 <audreyt> with both a and b being monotypes
21:51:50 <jcreigh> johnnowak: Whereas a strongly typed language says "if you do this, you get this error/exception/whatever"
21:51:52 <audreyt> so yeah.
21:52:11 <johnnowak> jcreigh: it's weakly typed because the values aren't strongly associated with types. they're just bits that can be read however you like depending on what accesses them or how you cast them
21:52:25 <dons> yeah, i just get worried when there's no mechanical check of the coverage of the 'proof', that there might be corners. but this sounds reasonable
21:52:45 <dons> so then the question is, are some of the rules strange or counter-intuitive?
21:52:47 <johnnowak> jcreigh: an example of weak typing is casting a pointer to void* only to later reassign it a useful type
21:52:57 <audreyt> dons: you bet. though in perl6 we fixed most of this
21:53:05 <audreyt> the one notoriously counterintuitive rule is
21:53:18 <audreyt> that a lambda (first-class closure) coerces to an integer
21:53:24 <audreyt> as its memory address(!)
21:53:24 <dons> oh my
21:53:32 <lispy> johnnowak: but if i understand your example correctly that's a violation of the C spec anyway...
21:53:33 <audreyt> which is, wow, maximally broken.
21:53:38 <dons> wow. that's so wacky
21:53:40 <lispy> johnnowak: oh, wait n/m
21:53:41 <audreyt> you can calculate sqrt of the sqrt function.
21:53:45 <johnnowak> jcreigh: in something like haskell, that's not possible. an int is an int. to use it as something else, you need to safely convert it to a different type using a built-in function. you can't just say "this is a string".
21:53:46 <dons> hehe
21:54:03 <audreyt> it's so that it can be used for fast identity comparison of cfunctions and refs
21:54:13 <audreyt> but I won't even attempt to defend the decision :)
21:54:22 <dibblego> how do you write fibonacci?
21:54:23 <dons> yeah, i can imagine why they'd do ti.
21:54:29 <johnnowak> lispy: in C, stripping type information and then later reassigning it is quite common.
21:54:31 <dons> scary behaviour to expose to the user though
21:54:32 <audreyt> (it's a castfail in perl6.)
21:54:57 <dons> cool
21:55:30 <lispy> johnnowak: yeah, i was thinking of something like int i = (float)&(int*)j; (or some such weirdness i saw reading the quake3 source where they cast without changing the bit representation)
21:55:56 <lispy> johnnowak: and it violates the spec and lead to some bugs with never version of gcc that optimize differently...the solution was to use a union
21:56:31 <johnnowak> lispy: ah, gotcha.
21:56:42 <lispy> > let fib = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:56:43 <lambdabot>  Not in scope: `fibs'
21:56:52 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:56:54 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:56:59 <lispy> dibblego: :)
21:57:16 <dibblego> no wonder I couldn't get it
21:57:19 <moonfish> dons: re stack traces, according to the ghc docs the -xc RTS option produces something like that
21:57:45 <lispy> dibblego: that's the 'scare away the newbies' implementation
21:58:09 <lispy> dibblego: there are more intuitive ways for a beginner
21:58:22 <dibblego> I'm just wondering what zipWith means
21:58:28 <lispy> let's look at the type
21:58:31 <lispy> @type zipWith
21:58:33 <dibblego> I also have seen let fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
21:58:33 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
21:58:36 <dons> moonfish: yep
21:58:58 <audreyt> let fib = 1 : 1 : [ a+b | a <- fib | b <- tail fib ]
21:59:00 <dons> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f)
21:59:01 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:59:02 <lispy> looks like it takes a binary function and two lists and produces a single list
21:59:16 <lispy> @type zipWith (+)
21:59:18 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
21:59:26 <moonfish> dons: I can't get my program to link though when I compile with profiling :(
21:59:40 <lispy> > zipWith (+) [1..3] [1..3]
21:59:41 <lambdabot>  [2,4,6]
21:59:42 <dons> you have your prof libs installed?
22:00:01 <lispy> dibblego: can you see why their version of fib is almost identical to mine?
22:00:15 <dibblego> nope
22:00:44 <lispy> they use a parallel list comprehension...hmm...
22:00:47 <dibblego> > zipWith (+) [1,2,3] [1,2,3]
22:00:49 <lispy> that's cheating :)
22:00:49 <lambdabot>  [2,4,6]
22:00:54 <moonfish> dons: I've recompiled the dependent libs with profiling. Linking of my main program fails to find a symbol referenced by one of the dependent libs.
22:00:59 <dons> there are simpler fibs, though, dibblego
22:01:15 <dibblego> I still don't understand zipWith
22:01:31 <dibblego> > zipWith (+) [1,2,3] [3,4,5]
22:01:32 <lambdabot>  [4,6,8]
22:01:36 <dibblego> > zipWith (+) [1,2,3] [3,4,5,7]
22:01:37 <lispy> > zipWith (,) [1..3] [1..3]
22:01:38 <lambdabot>  [4,6,8]
22:01:39 <moonfish> dons: for some reason that symbol is present in the non-p version of the lib, but not the p version.
22:01:39 <lambdabot>  [(1,1),(2,2),(3,3)]
22:01:55 <dibblego> aaah
22:01:58 <lispy> > zipWith (-) [1..3] [1..3]
22:01:58 <dons> dibblego: it takes two lists, and stiches them together using a binary function
22:02:00 <lambdabot>  [0,0,0]
22:02:07 <dibblego> I understand
22:02:07 <dons> which might be +, or a tuple constructor (,)
22:03:00 <dibblego> now I understand the rest
22:03:24 <dibblego> what is the difference between zipWith and zip?
22:03:45 <lispy> > let fib = 1 : 1 : [ a+b | a <- fib | b <- tail fib ]
22:03:46 <lambdabot>  Parse error
22:03:49 <dons> zip = zipWith (,)
22:03:54 <moonfish> dons: it's actually a reference to C function; the lib contains some native code. I wonder whether the cabal build for the lib is broken when compiling with profiling.
22:03:54 <dibblego> ok
22:04:13 <lispy> and it's that quite litterally
22:04:15 <dons> hmm, missing - flag?
22:04:19 <dons> -l
22:04:41 <dons> > let fib  n = if n < 2 then 1 else fib (n-2) + fib (n-1) in fib 10
22:04:43 <lambdabot>  89
22:04:46 <dons> > let fib  n = if n < 2 then 1 else fib (n-2) + fib (n-1) in fib 4
22:04:47 <lambdabot>  5
22:04:56 <dons> dibblego: ^^ might be a bit more intuitive :)
22:05:05 <dons> > let fib  n = if n < 2 then 1 else fib (n-2) + fib (n-1) in map fib [1..10]
22:05:06 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
22:05:11 <moonfish> dons: perhaps. it's just strange that the non-profiling lib works fine.
22:05:12 <lispy> > let fact n = product [1..n]
22:05:13 <lambdabot>  Parse error
22:05:19 <lispy> > let fact n = product [1..n] in fact 10
22:05:21 <lambdabot>  3628800
22:05:40 <dons> moonfish: hmm. maybe.
22:05:42 <lispy> lists allow for some pretty cool short cuts
22:05:45 <moonfish> dons: the lib in question is http://www.cse.unsw.edu.au/~dons/fps.html
22:05:46 <lambdabot> Title: Data.ByteString / FPS
22:05:51 <dons> oh. hmm.
22:05:58 <dons> should work fine with profiling
22:06:11 <dons> ah, no i rmeember
22:06:18 <dons> cabal breaks, since it can't find the .o file from the C build
22:06:29 <lispy> have you guys seen this puzzle? http://n.nfshost.com/1.html
22:06:30 <dons> add the path to them manually, or put them on the command line
22:06:37 <lispy> the goal is to get to the highest number
22:06:41 <lispy> i'm on 20
22:06:47 <dons> moonfish: i think some new cabals have fixed this, i've not seen it recently
22:07:24 <moonfish> dons: you mean some new versions of cabal? I am running a v recent one.
22:07:39 <dons> well, anyway, you can add the cbits .o files to the link command line, and it should work
22:07:53 <dons> but it doesn't appear in the cabal i'm using
22:07:54 <dons> nor in 6.5
22:08:09 <dibblego> lispy, wtf? how is that a puzzle?
22:08:11 <moonfish> dons: when compiling the lib or the exe?
22:08:17 <dons> oh, that was my 30k word for this year :)
22:08:18 <lispy> dibblego: what number are you on?
22:08:34 <dons> moonfish: the exe
22:09:00 <dibblego> lispy, 2
22:09:07 <lispy> dibblego: i know emperically that it goes to at least 20
22:09:16 <lispy> but getting there is not trivial
22:09:19 <dibblego> lispy, I still don't see how it is a puzzle
22:09:30 <dons> yay, 30k http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html
22:09:31 <lambdabot> Title: #haskell @ freenode.org stats by dons
22:09:32 <lispy> can you get to 5?
22:10:09 <lispy> whoa, i'm 13
22:10:14 <dibblego> lispy, probably not
22:10:17 <moonfish> dons: where does that live and what's it called?
22:10:21 <dons> dylan: btw, do you cache the results of your logs when generating the stats? seems to make a big speedup
22:10:28 <dons> moonfish: ?
22:10:43 <lispy> i'm much higher on this list (although i'm known as lispservice) http://www.borked.us/stats/orlug/
22:10:45 <dibblego> lispy, how do you get to 3?
22:10:45 <lambdabot> Title: Borked.us :: /stats/orlug/
22:10:52 <lispy> dibblego: :)
22:10:59 <lispy> dibblego: it's a puzzle
22:11:12 <dibblego> I'm going to go write my own HTML and get to a bazillion
22:11:23 <dibblego> puzzle solved!
22:11:44 <dons> hehe
22:11:49 <lispy> heh
22:11:51 <dons> brazillion :)
22:11:52 <dibblego> what kind of puzzle? where would I even start?
22:12:02 <dibblego> I could hack the web server and make it 20
22:12:02 <lispy> "They killed 6 brazillion soldiers"
22:12:09 <moonfish> there doesn't seem to be a (lib)HSfps_cbits.{a,o} around.
22:12:26 <dibblego> I doubt it's a hacking puzzle though
22:12:42 <dons> hmm? it goes into HSfps.o moonfish
22:12:59 <dons> but you want to add fpstring.o onto the link line, iirc
22:13:01 <lispy> dibblego: it's fun to work on when you have spare cycles
22:13:23 <dibblego> I have no idea how to proceed with it - surely there is more context required
22:13:28 <dons> moonfish: $ nm libHSfps-0.7.a | tail -10
22:13:32 <dons> fpstring.o:
22:13:32 <dons> 000000af T fps_count
22:13:32 <dons> 00000021 T fps_intersperse
22:13:32 <dons> 0000005f T fps_maximum
22:13:33 <dons> ...
22:13:55 <dibblego> I make a GET /1.html and get back some HTML that contains a link to /2.html and so GET request that, and then the HTML contains no links - why is that a puzzle?
22:14:35 <lispy> dibblego: well, there is a .html file for the number 3, but you have to figure out what the url is given the clues in 2.html
22:14:39 <moonfish> dons: yes, I've seen that. No such luck for the _p version. Would'nt the right thing to do be to somehow get fpstring.o added to the _p archive?
22:14:50 <dons> well, cabal should be doing that.
22:14:52 <dons> it does here.
22:15:08 <moonfish> oh
22:15:17 <dons> let me check..
22:15:22 <moonfish> dons: what version of cabal are you on?
22:15:51 <dons> the one that comes with 6.4.2
22:16:07 <dibblego> lispy, is it achievable with a web browser? do I need to watch the TCP traffic and inspect HTTP headers?
22:16:30 <moonfish> dons: I am still on 6.4.1, and darcs cabal from a few weeks back.
22:17:02 <dons> you can work around it by putting fpstring.o on your command line when linking
22:17:11 <dons> otherwise, i don't know what is happening
22:19:11 <lispy> dibblego: there is one later on that requires wget (or something without javascript) but that's the only thing (besides google) that i've needed
22:19:26 <dibblego> google? wtf? I give up
22:19:30 <dons> heh
22:19:37 <dons> for caching?
22:19:41 <dons> or searching for clues
22:19:44 <dons> ?
22:19:48 <lispy> dibblego: i didn't know welsh(sp?) so i had to look up stuff :)
22:19:52 <moonfish> dons: what exactly do I need to do for that? fpstring.o is not on the library path.
22:20:19 <dons> moonfish: ah, find where it is, literally add the .o file to you command line that you use to link your executable
22:20:28 <dons> so ghc -o foo /my/fpstring.o
22:20:35 <moonfish> dons: oh ok.
22:21:28 * moonfish butchers his beautiful generic Makefile
22:21:56 <moonfish> dons: that worked. thanks.
22:21:58 <dons> makefile, beautiful??
22:22:03 <dons> do those words even compose?
22:22:18 <dons> why not use cabal?
22:22:36 <dons> moonfish: btw, what are you using fps for?
22:23:02 <moonfish> dons: I'd use cabal if I could figure out how to.
22:23:07 <lispy> dons: for someone experience in the art of make-fu a cabal file can be daunting/confusing
22:23:23 <dons> well, sure, but they're shorter and don't use super magic powers
22:23:35 <dons> i'll sell you mine for $0.00
22:23:40 <dibblego> is cabal the de facto build system?
22:23:43 <dons> moonfish: executable?
22:23:44 <moonfish> dons: fps is a dependency of haskell-cgi
22:23:46 <dons> dibblego: yep
22:23:47 <lispy> dibblego: for haskell yeah
22:23:54 <dibblego> ok
22:24:14 <dons> moonfish: here, for the hmp3 executable, http://www.cse.unsw.edu.au/~dons/code/hmp3/hmp3.cabal
22:24:27 <lispy> dons: i've been letting visual haskell make my cabal files...it's helping because i do check them out and see how it mutates them to fit my project..but overall cabal is confusing...and where is it documented?
22:24:35 <dons> that's all you need to build an executable, with the following Setup.hs, http://www.cse.unsw.edu.au/~dons/code/hmp3/Setup.hs
22:24:52 <dons> lispy: there's the cabal documenation. big xml file
22:25:21 <lispy> hmm..i was googling for valid extensions the other day and had a hell of a time finding any list of valid extensions that can go in a cabal file
22:25:37 <lispy> plus the format seems to grow/change by leaps and bounds
22:25:39 <dons> ?darcs Cabal
22:25:40 <lambdabot> Cabal not available
22:25:44 <moonfish> dons: I am sure it's not very complicated, but I am on a steep learning curve already; one thing at a time.
22:25:46 <dons> ?fptools Cabal
22:25:46 <lambdabot> Cabal not available
22:25:49 <dons> bah
22:25:52 <dons> moonfish: ok :)
22:26:05 <dons> really though, its a 10 line file, and they're the same for every project
22:26:30 <lispy> i do quite like having a .cabal file
22:26:52 <dibblego> cripes, Visual Haskell looks appealing, just need windows
22:26:52 <lispy> darcs needs to get into the cabal program...i bet it would help smooth out the corners of cabal
22:27:14 <lispy> dibblego: do you like eclipse (i don't so feel free to say no)
22:27:21 <dibblego> lispy, I hate it
22:27:35 <dibblego> lispy, I think I told you the other day - I used to work on the Java implementation - for IBM
22:27:36 <lispy> ah, well if you liked it, there is eclipse-fp taht needs testers
22:27:41 <lispy> Oh
22:27:42 <lispy> okay
22:27:54 <dibblego> I resigned from The Filth a few months ago
22:28:16 <dibblego> I always used Intellij IDEA for Java
22:28:23 <dibblego> and Eclipse when forced
22:28:28 <lispy> netbeans and eclipse both consume about 200mb of ram on startup...blows me away
22:28:31 <moonfish> dons: my makefile calls DBDirect, builds three exes, runs the test suite, and copies the exes plus some other files to a deployment dir. I bet I'd have a hard time getting Cabal to do all that.
22:28:42 <dons> sure.
22:28:46 <dons> it would be stretching it
22:29:31 <sethk> I'm getting an error using ghc -M with 6.4 that I don't get with 6.4.1.  Does that make any sense?  It is "module `Main' is defined in multiple files" (which, by the way, it is).
22:29:42 <dons> yeah, 6.4 bug
22:29:52 <dons> oh, hang on. maybe not
22:29:59 <moonfish> dons: anyway, back to my linking problem. How should I go about fixing it properly? Upgrade cabal? ghc?
22:30:07 <dons> hmm. i'd try both.
22:30:14 <dons> i'm not sure where the problem lies.
22:30:17 <dons> try ghc 6.4.2 first
22:30:41 <sethk> dons, I'm providing specs to build my software.  I was hoping to use the ghc version that is known to the Ubuntu package manager.
22:31:20 <dons> possibly you can solve this by not having module Main in multiple files
22:31:28 <dons> using -main-is Foo.main perhaps
22:31:43 <sethk> dons, how would that fool it?
22:31:59 <sethk> dons, I'm generating dependencies for all programs with one ghc -M call, which works fine and is very convenient.
22:32:05 <sethk> dons, works fine in 6.4.1, anyway.  :)
22:32:32 <dons> oh, break up the calls then? don't generate all deps in one go?
22:32:50 <dons> anyway, ensure that the same module name isn't used multiple times
22:32:56 <dons> so you could have module Foo where main = ...
22:33:02 <sethk> dons, I can do that, yes, but ... I'm still curious about why the behavior is different, and,   it is substantial amount of work
22:33:09 <dons> depends on how important the porblem is.
22:33:15 <sethk> dons, no, I don't have main redefined for a real program
22:33:28 <sethk> dons, I'm creating dependencies for a bunch of programs at once, and of course each has a main
22:33:43 <dons> you could probably find bug reports between 6.4 and 6.4.1 that explain this, i suspect.
22:33:48 <sethk> ok.
22:34:00 <dons> i don't remember the bug.
22:34:11 <sethk> I think I'll upgrade to 6.4.1 to make sure it is really a compiler version issue.
22:34:35 <sethk> 6.4.2, I guess
22:34:49 <foxy__> > read "4608    " :: Int
22:34:50 <lambdabot>  4608
22:34:56 <moonfish> dons: will try. thanks again for your help.
22:35:54 <sethk> dons, I do want 6.4.2, right?  It's released?
22:36:16 <sethk> dons, why am I seeing daily builds if it is released?
22:36:43 <shemale_magic> well boys
22:36:54 <shemale_magic> how fast is the haskell web serve for dynamic content?
22:37:05 <shemale_magic> siriam from scheme says the scheme one si FAT AS HEK
22:37:08 <dons> we keep building it nightly (in the branch) as it heads towards a possible 6.4.3
22:37:19 <dons> 6.4.2 is good, yes
22:37:27 <sethk> ok, I'll try 6.4.2
22:37:56 <bringert> shemale_magic: fat is good I take it?
22:38:07 <shemale_magic> fast
22:38:09 <shemale_magic> lol
22:38:29 <lispy> is the haskell webserver called happs?
22:39:04 <bringert> not really
22:39:04 <sethk> it mights be
22:39:08 <lispy> as for haskell performance in concurrency and just in general, check the great programming language shoot out to see that haskell is a very fast language when that's the priority
22:39:09 <dons> hey bringert. congrats on getting into icfp :)
22:39:14 <bringert> dons: thanks
22:39:20 <foxy__> dons, if (using ByteString) I:  do { let (a,b) = BS.split 8 bs ; let (c,d) = BS.split 8 b ; putStrLn $ show a ; putStrLn $ show c ; -- etc
22:39:23 <dons> i think that's the first #haskeller since nibro in 04
22:39:31 <foxy__> will I have 3 bytestrings hanging around?
22:39:38 <sethk> hey, somebody is selling chopper rides to JFK (airport) for a mere $159 (each way)
22:40:01 <bringert> dons: are you going to icfp?
22:40:04 <dons> foxy__: you're creating 3 substrings of an original string. they're all sharing the underlying buffer
22:40:05 <sethk> plus $12.70 tax.  I can't believe they hit you separately for the tax.  :)
22:40:14 <dons> bringert: don't think so unfortunately
22:40:24 <foxy__> good, coz the actual files are going to be around 10Mb
22:40:46 <dons> foxy__: so be careful to use O(1) operations (that are taking substrings)
22:40:53 <sethk> dons, any ideas on my client/server class thing?  I thought of several clever ways to detect the problems at runtime, but still not at compile time.
22:41:00 <dons> rather than operatoins that say they're doing a copy or memcpy (like append )
22:41:11 <dons> sethk: haven't looked at it.
22:41:21 <sethk> dons, do you still have the email?
22:41:33 <dons> yep
22:42:13 <sethk> dons, you can do it with polymorphic functions, as long as you only have one instance of a function in a particular source file, but that's ugly.
22:42:48 <sethk> dons, I can make a runServer function, for example, and paste it into the source file, but if I have another runServer in the program I have to have it in a separate source file.
22:42:57 <dons> hmm
22:43:03 <bringert> dons: is that so? surely JaffaCake or ChiliX or one of the other more senior guys must have had a paper last year?
22:43:18 <dons> oh, yes. of course
22:43:28 <dons> ChilliX has been the last 2 years at least
22:43:48 <dons>  and JaffaCake spoke about threads in 04. something else last year
22:44:02 <dons> i was thinking of the students :)
22:44:05 <bringert> ah
22:44:19 <dons> hey, even simonpj was here last week :)
22:44:25 <sethk> dons, with the snapshot tarball for ghc-6.4.2.2006...., do I extract from the tar and do make install?
22:44:27 <dons> he's _certainly_ had some papers
22:44:34 <bringert> he has?
22:44:39 <bringert> never heard of the guy
22:44:57 <dons> sethk: yeah, think so
22:45:00 <dons> read the readme
22:45:05 <dons> bringert: heh
22:45:15 <sethk> dons, read?  :)
22:45:47 <dons> yeah, after you untar, i think it might actually echo to the screen the install instrs
22:46:07 <itsFastAsHek> :)
22:46:39 <dons> hello itsFastAsHek. you learning haskell?
22:47:03 <sethk> dons, it echos them at the end of ./configure
22:47:24 <bringert> dons: nibro's paper might have been the first paper for which all of the authors are #haskellers
22:47:34 <dons> ah, maybe maybe.
22:47:56 <dons>  dcoutts and i are writing a paper, but not for icfp.
22:48:06 <dons> i wonder how many other collaborations there've been
22:49:37 <lispy> i have some ideas for papers
22:49:46 <lispy> but i haven't started work on any of them
22:50:36 <lispy> actually, it's more like i know a set of tools i'd like to have or extensions to existing ones
22:50:42 <itsFastAsHek> I caught between haskell tcl and plt scheme
22:50:47 <itsFastAsHek> Im
22:50:57 <lispy> i'd say haskell
22:51:01 <lispy> but i'm biased
22:51:10 <itsFastAsHek> jboss n java scare me but my work is bringing em in
22:51:13 <itsFastAsHek> its hell
22:51:18 <itsFastAsHek> Im jsut a linux admin
22:51:35 <itsFastAsHek> but I went to UCLA so I feel Im a genius esp sicne I wanted to goto stanford
22:51:53 <itsFastAsHek> problem is m 6-6 and everyone think im dumb
22:52:30 <lispy> jboss is a pig
22:52:36 <dons> haskell, tcl and scheme are all very differnt. why not learn all 3 ?
22:53:20 <lispy> well, i'd say learn python over scheme if you would like to use it instead of just learning it :)
22:53:37 <lispy> the python community is much more alive than scheme these days
22:53:59 <tessier> Although #scheme has quite a few people in it.
22:54:08 <lispy> ah, that's good
22:54:25 <lispy> and one perk to studying lisp/scheme is that you'll be able to extend emacs more easily
22:54:26 <tessier> Not nearly as many as #python but I think learning scheme is a good thing.
22:54:41 <tessier> lispy: Exactly. That is one of my main reasons for learning it.
22:55:19 <dons> how many people are in #python?
22:55:28 <tessier> 260 in #python
22:56:06 <lispy> i like python, but the lack of type checking and the performance it gives makes me want to use haskell all day long
22:56:33 <tessier> It does have type checking.
22:56:36 <dons> wow, we're pretty close.
22:56:42 <sethk> dons, 6.4.2 doesn't have the problem, so I guess it was really a version issue.
22:56:49 <tessier> python is dynamic strongly typed
22:57:51 <sethk> tessier, true, but that isn't the same thing.
22:58:04 <lispy> specifically, it's not the thing i'm looking for
22:58:08 <sethk> tessier, because it's impossible to know that you've exercised all code paths,
22:58:15 <sethk> tessier, so you can't know that you are finished.
22:59:35 <tessier> What does exercising all code paths have to do with type checking? That sounds like a unit testing concern.
22:59:47 <sethk> tessier, no, you said it has run time type checking
23:00:05 <sethk> tessier, but runtime type checking only occurs on code that is run
23:00:21 <dons> unit testing is roughly a replacement for static type checking
23:00:25 <sethk> tessier, so you would have to exercise all code paths to know that all type checking has occurred.
23:00:50 <dibblego> even if you execute all code paths, you are still not finished
23:00:52 <dons> yeah, that's a good observation, sethk
23:00:53 <lispy> dons: i think that's an overstatement, haskell for example still benefits from unit checking
23:01:01 <dons> yes. hence "roughly"
23:01:18 <dons> you somehow need to make up for the checks that you don't get , so you employ more unit tests at runtime
23:01:26 <dibblego> and even if you execute all paths of all states, you're still not finished, but you can't do anything more without stopping time
23:01:27 <sethk> dibblego, true, but having proved the procedure is incomplete, I don't have to prove that it wouldn't be exhaustive even if complete.  :)
23:01:27 <lispy> yeah
23:02:18 <dons> so, if you're using a dynamically typed language, you should at a minimum exercise all code paths via unit tests to regain the basic level of type checking you'd get with static typing
23:02:56 <lispy> and yet, how many code coverage tools exist?
23:02:59 <lispy> they are hard to find
23:03:01 <dons> i don't think we've so concretely stated this before
23:03:07 <dibblego> I am 1 day old to FP, but I imagine if you execute all pre-condition states of a function and assert an expected post-condition, then you are free to extrapolate that the result holds ad infinitum along the arrow of time
23:03:12 <lispy> and branch coverage is a crappy coverage criteria anywho
23:03:26 <dons> dibblego: exactly. referential transparency :)
23:03:55 <sethk> dibblego, true, but python is not FP and we are discussing runtime type checking in python
23:03:56 <dibblego> dons, I tell that to the guys in the next room using "TDD with Java", but I get blank looks
23:04:13 <dibblego> I was taken off that project because I can't stand that TDD nonsense
23:04:39 <dons> so you essentially have to write your own type checker, in the form of unit tests, for each program you write, just to get up to the basic standard of safety
23:04:39 <dibblego> all they are doing is working around language defects that imply a requirement contradiction
23:04:44 <lispy> i think TDD is a good idea, but i'd apply it haskell :)
23:05:07 <dibblego> lispy, there are two parts to TDD - what you are actually doing, and the reason why you are doing it - the reasoning is utterly flawed
23:05:10 <sethk> dons, right, plus, similarly to the reasoning that underlies the fact that you can't prove a program terminates, you can't prove that all paths have been exercised
23:05:28 <sethk> dons, plus, remember, that in a conditional statement you've only type checked the true branch
23:06:03 <dons> this is rather worrying for those hoping to gain assurances about dynamically typed code, isn't it?
23:06:17 <sethk> dons, yes
23:06:31 <sethk> dons, all those if/then/else where only then (or perhaps only else) has been tested
23:06:34 <dons> maybe we should be distributing "automated unit testers" (aka type checkers) for other languages
23:06:41 <sethk> dons, all the error paths
23:06:47 <sethk> dons, and what about exception handling?  ugh.
23:07:18 <dons> so unit testing for coverage approaches type checking in the limit.
23:07:20 <lispy> well, exception handling raises problems in haskell too, though right?
23:07:40 <sethk> lispy, not for type checking
23:07:42 <dibblego> exceptions are just an alternative execution path for a different return type
23:07:48 <lispy> we don't have checked exceptions except in the case of the Either monad
23:07:58 <dibblego> you can use Java without ever using exceptions for example, by passing a callback
23:08:30 <dibblego> that one return type path is "exceptional" is just glossy brochure stuff
23:08:52 <lispy> actually, i'm wondering about this
23:08:59 <dibblego> lispy, I have implemented it
23:09:05 <lispy> dons: how do i catch prelude exceptions?  like head []
23:09:17 <dons> with Control.Exception.catch
23:09:22 <dons> its a UserException
23:09:30 <lispy> i thought i tried that and it failed
23:09:46 <sethk> lispy, oh, then when it fails, throw an exception  :)
23:09:49 <dons> lambdabot does this all the time. it just marches on if you notice, ignoring all sorts of plugin failure
23:10:33 <lispy> Prelude> head [] `catch` (\e -> do print e; return 1)
23:10:33 <lispy> *** Exception: Prelude.head: empty list
23:10:40 <dons> wrong catch
23:10:48 <dons> that's Prelude.catch
23:10:58 <foxy__> how do I convert a Char to an Int?
23:11:07 <dons> ?hoogle Char -> Int
23:11:08 <dons> ;)
23:11:08 <lambdabot> Char.digitToInt :: Char -> Int
23:11:08 <lambdabot> Char.ord :: Char -> Int
23:11:21 <lispy> dons: cool!
23:11:21 <foxy__> heh
23:11:22 <lispy> dons: thanks
23:11:26 <lispy> dons: i needed it for work :)
23:11:54 <lispy> you could also show and read
23:12:12 <dons> Prelude Control.Exception> head [] `Control.Exception.catch` (\_ -> print "got you, you little bugger!" >> return 1)
23:12:16 <dons> "got you, you little bugger!"
23:12:19 <lispy> oh, but only in some cases
23:12:30 <lispy> next question
23:12:39 <lispy> what do you return when you don't know what to return?
23:12:47 <dons> error ?
23:12:49 <dibblego> lispy, you invoke a callback
23:12:51 <dons> () ?
23:13:03 <dibblego> lispy, I can demonstrate it in Java quite easily
23:13:07 <dons> i'd return () if you're throwing it away
23:13:15 <lispy> dons: well, let's say the function returns some type i can't construct
23:13:21 <lispy> dons: but it just failde
23:13:28 <lispy> dons: i want to print out the error and exit
23:13:40 <lispy> dons: or maybe i don't want to  exit, i just want to go an about my business
23:13:45 <dibblego> given interface Association<K, V>{V get(K k);}, what do you do if no V is associated with the given K?
23:13:49 <lispy> pretend it didn't happen
23:14:13 <lispy> return Nothing
23:14:17 <lispy> @type looku
23:14:19 <lambdabot> Not in scope: `looku'
23:14:19 <lispy> @type lookup
23:14:21 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
23:14:46 <dons> lispy: catch, then recursively call back to your function
23:14:59 <dibblego> interface Foo{void f();}interface Bar<T>{void b(T t);}interface Association<K, V>{void get(K k, Foo noSuchAssociation, Bar<V> associated);}
23:15:00 <lispy> dons: i'm not sure what you mean
23:15:13 <dons> forever :: IO () -> IO ()
23:15:13 <dons> forever fn = catch (repeatM_ fn) handler
23:15:13 <dons>     where
23:15:13 <dons>         handler :: Exception -> IO ()
23:15:13 <dons>         handler e =
23:15:15 <dons>             when (not.exitTime $ e) $
23:15:18 <dons>                 (warnA . show) e >> (forever fn)        -- reopen the catch
23:15:31 <dons> that's my super-duper never-exit keep-trying combinator
23:15:43 <lispy> i see
23:15:58 <lispy> it's bottom but the type system can't see that
23:16:12 <dons> well, it'll terminate when it is exitTime
23:16:23 <dons> exitTime e | isJust . ioErrors $ e   = False
23:16:25 <dons> ..
23:16:35 <lispy> does that mean the error propagates?
23:16:39 <dons> so ignore io errors, for example
23:16:53 <dons> no, nothing propagates
23:17:00 <lispy> then how do you exit?
23:17:02 <dons> it just returns () when a fatal error occurs
23:17:06 <lispy> oh right
23:17:09 <dons> which drops it back to main, which exits
23:17:23 <lispy> yeah, that's the sort of stuff i'll need to do
23:17:33 <lispy> my program can fail but it shouldn't crash or explode
23:17:52 <dons> ah, so don't use 'doExplode' then
23:17:57 <Korollary> it doesnt crash anyway
23:17:59 <lispy> lol
23:18:17 <lispy> ah, i'm be short in my explanation
23:18:28 <lispy> i mean it needs to report the error to the user before it exists
23:18:30 <dons> or catch the isExplodingRightNOW exception
23:18:33 <lispy> exits
23:18:40 <dons> which'll put the pieces back together
23:18:47 <Korollary> gui pop-up kinda reporting?
23:18:55 <lispy> so is Control.Exception.catch the most general catch I can use?
23:19:02 <Korollary> dailywtf.com style is the best.
23:19:03 <lispy> Korollary: yeah
23:19:10 <Korollary> +the
23:19:46 <Korollary> "Insufficient diskspace. C: has only 323434673442374234 bytes left."
23:19:56 <lispy> perfect
23:20:02 <lispy> i should hard code that in
23:21:03 <lispy> geez, i should be asleep already...
23:21:05 <lispy> good night
23:21:08 <Korollary> night
23:25:21 <zarvok> is there an equivalent of Numeric.showHex for binary?
23:27:37 <Korollary> well, I suppose it would be in Numeric as well if there was one.
23:27:52 <dibblego> does one typically aim to minimise the imperative/monad part of an application by using it only where required?
23:28:00 <sethk> zarvok, you can convert to an Int type and use showHex
23:28:21 <zarvok> sethk: I mean that I want to show it in binary
23:28:38 <zarvok> I think the answer is no, for the reason Korollary mentioned
23:29:17 <Korollary> dibblego: It typically works out that way. However, actually there is nothing wrong with having imperative code all over if that's what your algorithm requires.
23:29:30 <wetnewb> i'm having trouble with number type classes and knowing what needs to be converted. Can anybody help me with the following function?
23:29:48 <wetnewb> g2 :: [(Integer, Integer)] -> (Integer, Integer)
23:29:48 <wetnewb> g2 l | l == []   = (0, 0)
23:29:48 <wetnewb>      | otherwise = g2_ 0 0 l
23:29:59 <wetnewb> and g2_ is:
23:30:13 <wetnewb> g2_ :: Integer -> Integer -> [(Integer, Integer)] -> (Integer, Integer)
23:30:13 <wetnewb> g2_ numer denom (x:xs) = g2_ (round (fromIntegral newNumer))
23:30:13 <wetnewb>                              (round (fromIntegral newDenom))
23:30:13 <wetnewb>                              xs
23:30:13 <wetnewb>                        where sumNumer    = fst x
23:30:13 <wetnewb>                              sumDenom    = snd x
23:30:14 <dibblego> Korollary, one could argue that it is never required, except for the case of files, sockets, database; and sometimes not even then
23:30:15 <zarvok> dibblego: sometimes that's nice, but you have to watch out to be sure you won't later want to insert a monadic construct deep in the non-monad code, since when that happens you either have to use Unsafe or do major rewriting
23:30:15 <wetnewb>                              scaleFactor = log2 (fromIntegral denom)
23:30:17 <wetnewb>                              newNumer    = sumNumer + scaleFactor * numer
23:30:19 <wetnewb>                              newDenom    = sumDenom + denom
23:30:21 <wetnewb> g2_ numer denom []     =  (numer, denom)
23:30:38 <wetnewb> hugs complains:Instance of Floating Integer required for definition of g2_
23:30:40 <Korollary> wetnewb: you should paste that to one of those paste pages
23:30:44 <Korollary> lisppaste2: url
23:30:45 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:30:52 <dibblego> zarvok, so when do you actually use referential transparency?
23:31:30 <Korollary> dibblego: Yes, that is the bare minimum case. However, you sometimes do use mutable arrays, etc.
23:31:53 <dibblego> Korollary, why would you? why not use lists?
23:32:01 <lisppaste2> wetnewb pasted "pasted code" at http://paste.lisp.org/display/22837
23:32:32 <wetnewb> oops, didn't know about listpaste, but I just pasted there
23:32:34 <Korollary> dibblego: Speed
23:32:52 <dibblego> Korollary, is speed really that important such that you'd do that?
23:33:04 <Korollary> dibblego: It depends on your app, of course.
23:33:05 <dibblego> surely the performance gain is typically negligible?
23:33:10 <zarvok> dibblego: that's a good question.  I think you'll find a happy medium as you start to write more haskell
23:33:29 <sethk> dibblego, no, not neglible at all
23:33:41 <dibblego> I have rewritten the list type in Java - it is immutable - and I never have a never have a need for anything else
23:33:44 <zarvok> dibblego: you can often write very large portions of the code outside of the monad, so it's not a problem
23:33:47 <Korollary> dibblego: well, if the algorithm requires index-based access, that's O(1) vs O(n) and it shows.
23:34:22 <wetnewb> anybody help me out with http://paste.lisp.org/display/22837 ? The error that hugs gives me is Instance of Floating Integer required for definition of g2_
23:34:23 <edwardk> whats the speed issue?
23:34:25 <pejo> Has anyone read "Compiler Construction" by Niklaus Wirth and have an opinion about it? http://www.oberon.ethz.ch/WirthPubl/CBEAll.pdf, but apparently printed about 10 years ago.
23:34:46 <edwardk> pejo: i've read it, its not a bad start on how to write a compiler for an imperative language
23:34:56 <edwardk> pejo: but its thin
23:35:22 <edwardk> pejo: if you want something satisfying, steven muchnik has a REALLY good book, that  I still find myself referring back to this day.
23:35:30 <dons> some graphs, http://www.cse.unsw.edu.au/~dons/irc/
23:35:30 <pejo> edwardk, happen to have read the dragon book, or Appels book as a comparison?
23:35:30 <lambdabot> Title: Haskell IRC Activity
23:35:31 <edwardk> 'advanced compiler design'
23:35:38 <dibblego> ok, I guess I'll just have to hang out and see
23:35:39 <edwardk> yeah read both =)
23:35:43 <dons> shows the growth of text and nicks in this channel over the years
23:35:54 <dons> seems to double (both nicks and text) each year!
23:36:21 <pejo> edwardk, the Muchnick book isn't really suitable for the first exposure to compilers, imho. But I use it just like you do.
23:36:25 <edwardk> the dragon book is more technical, the compiler construction boo by wirth is an overview of wrting an oberon-0 compiler in oberon.
23:36:26 <dibblego> dons, is the '6' to represent 2006, and so it is incomplete?
23:36:31 <dons> yep
23:36:42 <edwardk> pejo: yeah, wasn't sure what level you were looking at wanting it for.
23:36:43 <dibblego> dons, you should project an outcome for 2006
23:36:47 <dons> but by mid 06, we've already said and seen more people than all of 2004
23:37:14 <pejo> edwardk, ah, sorry. First course in compiler construction. Lots of parsing, little optimization.
23:37:26 <edwardk> the wirth book i found to be good light 'bathroom' reading but i don't think its all that deep.
23:37:43 <edwardk> teaching it?
23:37:53 <edwardk> or attending it? =)
23:39:06 <pejo> edwardk, just passively looking for a replacement for the current course litterature.
23:39:36 <edwardk> ah
23:39:43 <edwardk> what are you using now?
23:40:40 <wethaskellnewb> I pasted a question under a different name, and just logged in again. Question pasted to: http://paste.lisp.org/display/22837  Please help
23:40:41 <pejo> edwardk, second edition of Appels book. Many parts of it are good, but it seems to leave pretty big holes in some explainations.
23:40:46 <edwardk> if we can get enrolment up i might wind up teaching our compilers course in the fall, so i might as well do a little looking myself
23:40:50 <Korollary> @type round
23:40:52 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
23:41:07 <Korollary> @instances RealFrac
23:41:08 <lambdabot> Double, Float
23:41:23 <Korollary> wethaskellnewb: that seems to be your problem I think
23:42:24 <pejo> edwardk, but hm, judging from what you said the book by Wirth isn't really any better?
23:42:26 <wethaskellnewb> Korollary: which line? I've tried various type conversions (via round, and fromIntegral), but can't get it to compile
23:42:56 <edwardk> the book by wirth reads nicely, but it always struck me as a good weekend, not a course
23:43:12 <edwardk> it just isn't deep enough to teach out of imho.
23:44:16 <edwardk> and i think the appel book is probably more accessible than defecting to the dragon book. though i guess that depends on your audience.
23:44:29 <Korollary> @type (/)
23:44:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:44:37 <Korollary> @instances Fractional
23:44:38 <lambdabot> Double, Float
23:44:49 <edwardk> here we don't let students take the compilers/interpreters course until they are seniors, so I don't feel too bad throwing a lot at them.
23:44:57 <pejo> edwardk, yes, the dragon book starts to feel dated, unfortunately. I wish they could come out with the update.
23:45:18 <Korollary> wethaskellnewb: Check the type of log2. That seems to not mesh with your usage in scaleFactor
23:45:25 <edwardk> heh
23:45:43 <edwardk> you could always use the o'reilly lex and yacc book ;)
23:45:43 <edwardk> and build from there =)
23:45:58 <pejo> edwardk, well, while they should know basic data structures/algorithm analysis when they enter hte course, they don't really have any background in computational theory or similar.
23:46:15 <edwardk> its actually quite accessible and builds to some fairly complicated examples by the end.
23:46:38 <edwardk> supplemented with some theory on the rest of the compilation/interpretation process (maybe even from the wirth book) it wouldn't be bad
23:46:50 <edwardk> would require a bit of jumping around to give a coherent presentation though
23:48:24 <edwardk> but it'd be fairly informal i admit
23:49:49 <foxy__> @hoogle replicateM
23:49:50 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
23:49:50 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
23:50:51 <pejo> edwardk, trying to give a coherent presentation from 3 different books is a pretty hard task it seems like. And puts quite a lot of work on the teacher.
23:50:58 <edwardk> yeah
23:51:23 <edwardk> i just got done spending a semester doing that so I know what you mean
23:54:23 <edwardk> i think if i can get the course to run this fall i'll give the wirth + o'reilly path a shot.
23:55:01 <edwardk> it'll at least feel practical then
23:55:31 <pejo> edwardk, I'd be glad to hear any experiences from it.
23:55:48 <edwardk> i'll let you know how it goes =)
23:56:51 * edwardk right now is trying to figure out how to reflect enough of the current lexical scope chain to provide javascript's eval function without losing all compilation efficiency
23:56:57 * edwardk sighs.
23:59:29 <edwardk> my current best option is to compile  my heart out as long as i can show there isn't an eval in the parse tree, and then interpret or maintain the simple hash based lexical scopes if I see one.
