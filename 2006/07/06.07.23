00:00:51 <notsmack> audreyt: yeah, that's what i'm playing with
00:03:26 <audreyt> very nicely designed.
00:03:48 <audreyt> been thinking about makings it part of pugs
00:04:11 <notsmack> yeah, it seems ok
00:04:12 <audreyt> so we can provide core sqlite support for e.g. installed libraries and module state
00:05:54 <notsmack> i guess i was hoping for something more cleverly abstracted from SQL... I've just come across haskellDB, but I'm not sure I'm ready for that
00:06:27 <audreyt> also the haskelldb abstraction may not be the abstraction you want
00:07:28 <audreyt> (though it is indeed more powerful)
00:07:34 <notsmack> yeah.  i imagine it wouldn't even be too hard to build what i want over hdbc, once i figure out what i want
00:07:44 <audreyt> so if your app is totally db centric, and you need lots of type safety
00:07:47 <audreyt> then haskelldb might be right
00:08:01 <audreyt> but otherwise build your app specific abstration over hdbc is almost always easier and saner
00:08:10 <notsmack> right
00:09:21 <mathewm> how do you update an MArray?  Specifically an IOArray
00:10:16 <audreyt> @index writeArray
00:10:16 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
00:11:09 <mathewm> ah not what I expected that to do - thanks
00:11:17 <audreyt> np :)
00:28:08 <notsmack> seErrorMsg = "step: cannot commit transaction - SQL statements in progress"
00:31:46 <notsmack> (nevermind)
00:40:48 <AI_coder> So the difference between ai and technology is what?
00:44:29 <RyanT5000> ai is technology that mimics "natural" intelligence
00:44:42 <RyanT5000> (i made that up on the spot, though)
00:46:13 <audreyt> ai is technology that doesn't work yet.
00:46:21 <audreyt> when it actually works people stop calling it ai.
00:46:36 <RyanT5000> lol
00:46:53 <AI_coder> So ai is a magical term then, the definition or line separating subjective and objective?
00:46:57 <RyanT5000> yeah, i think ai is "stuff that looks intelligent, but we don't understand our technology yet"
00:47:10 <audreyt> speech recognition was considered deep ai
00:47:17 <audreyt> now it's more offshelf stuff.
00:47:23 <RyanT5000> s/our/the/
00:55:22 <wli> Speech recognition's quality is still not all that good.
00:55:44 * wli 's mind is boggled by Meek's method.
02:31:49 <foxy__> how does one get the length of a CString?
02:33:48 <dons> strlen?
02:35:43 <Lemmih> @type Foreign.Marshal.lengthArray0
02:35:44 <lambdabot> forall a. (Eq a, Foreign.Storable.Storable a) => a -> GHC.Ptr.Ptr a -> IO Int
02:36:21 <foxy__> @hoogle strlen
02:36:22 <lambdabot> No matches found
02:36:45 <dons> no, foreign import strlen ?
02:36:54 <dons> or use ByteString.packCString
02:37:00 <dons> and then just play with the byteString
02:40:54 <notsmack> with hdbc-sqlite, i need to be calling commit to close transactions, right?
02:41:11 <Lemmih> Damn it, stupid 2D error messages. And people complain about GHC, tsk.
02:42:14 <foxy__> dons, how icfp comp going?
02:47:23 <cmarcelo> @paste
02:47:23 <lambdabot> http://paste.lisp.org/new/haskell
02:49:20 <lisppaste2> cmarcelo pasted "use of (undefined :: a) inside functions with type variable "a"" at http://paste.lisp.org/display/23024
02:50:20 <cmarcelo> anyone can help me understand this? the title doesn't describe very well, sorry.. =|
02:50:40 <dons> foxy__: well, its hard :) lots of stuff to hack on
02:58:20 <astrolabe> cmarcelo: are you allowed to use variables without defining them?
03:01:44 <cmarcelo> astrolabe: actually i don't use them, as they are ignored by "number" function. My intent was using them to "hold" type information and force the right "number" function to be chosen.
03:05:04 <lorne> cmarcelo: is the 'a' in (undefined :: a) the same as the 'a' in f :: IO (C a)?
03:05:21 * lorne would guess it wasn't
03:08:11 <cmarcelo> hmm.. maybe the mistake is that I think they're the same but they aren't...
03:09:35 <cmarcelo> and astrolabe was right if was talking about type vars..
03:12:49 <notsmack> is there an easy string to integer conversion?
03:15:17 * notsmack finds read
03:18:24 <exit^afk> hi, i try to compile greencard but ghc (6.4.2) seems not to know the used "-fno-prune-tydecls". does someone know a workaround?
04:14:26 <musasabi> Is there any way to separate class definitions from default method bodies? (trying to avoid recursive modules)
04:15:18 <hellish> anyone here run sandmark (ICFP)? How long does it take on your UM implementation?
04:15:39 * hellish has more than an hour of CPUTime counted...
04:22:38 <dons> hellish: at least an hour
04:22:45 <dons> mine didn't finish before i gave up
04:23:21 <hellish> dons: Oh. Good then, that means I probably don't have some infinite loop bug.
04:24:06 <dons> :)
04:24:12 <waern> haddock: internal error: PAP object entered!    (GHC version 6.5 for i386_unknown_linux)
04:24:15 <dons> well, as long as the system runs its probably ok
04:24:21 <waern> what did I do wrong? :P
04:24:22 <dons> waern: nice!
04:25:28 <waern> dons: not so nice since I don't know what causes it
04:29:34 <dons> a ghc internal bug
04:30:45 <waern> yep.. so much I know.
04:37:00 <JohnMeacham> musasabi: I doubt it.
04:37:13 <JohnMeacham> musasabi: well, with class aliases you can come close :
04:37:15 <JohnMeacham> :)
04:38:30 <notsmack> is it just me, or shouldn't haxml unescape &amp; when you fetch a PCDATA section?
04:39:32 <wilx> Isn't PCDATA section basically a binary blob?
04:40:06 <notsmack> i think CDATA is, but PCDATA is parsed...
04:41:29 <wilx> Ah.
04:42:09 <notsmack> seems like a bug to me, but there's a good chance i'm just missing some subtlety
04:46:48 <ValarQ> > join (***) (sum . map snd) ([(0,2)],[(0,2)])
04:46:49 <lambdabot>  (2,2)
04:47:06 <ValarQ> when i try to do this in ghci i just get:
04:47:15 <ValarQ>     No instance for (Monad ((->) ([(a, b)] -> b)))
04:47:15 <ValarQ>       arising from use of `join' at <interactive>:1:0-3
04:47:31 <ValarQ> whats missing?
04:49:19 <flodin> can you recommend a text for learning about monads? I have 20ish years of programming experience but only a week or so with haskell
04:50:25 <neologism> @google monads nomaware
04:50:29 <lambdabot> http://www.nomaware.com/monads/
04:50:29 <lambdabot> Title: Nomaware | Monads
04:50:56 <flodin> thanks!
05:03:10 <shapr> Good morning #haskell!
05:04:03 <Lemmih> Hi shapr!
05:04:10 <shapr> Hiya Lemmih, what's up?
05:04:26 <Lemmih> ICFPc.
05:04:28 <shapr> oh yeah
05:04:32 <shapr> That's why it's so quiet.
05:15:00 <shapr> hi postman, learning Haskell?
05:18:03 <postman> Hi, shapr. Somewhat yes. I was wondering whether mfix is more general than fixST, fixIO, but I already answered that this very moment.
05:18:21 <shapr> Have you read the recdo paper?
05:18:29 <shapr> imho it's along the same lines and fun to read.
05:19:06 <postman> shapr: no
05:19:25 <shapr> I can find an url if you'd like to read it.
05:19:26 <postman> This is somewhat odd though: "mfix f executes the action f only once"
05:21:05 <hellish> Why does ghc look for a different (and nonexistent) .hi file for Data.ByteString when I try to compile something that uses it for profiling?
05:23:17 <shapr> I think you need to build profiling libs for ByteString.
05:23:20 <shapr> Sadly, I don't know how to do that.
05:23:37 <shapr> It's probably in the manual though.
05:25:32 <shapr> hellish: I think it might be as simple as adding -prof when you build the library.
05:25:38 <hellish> Ahah! Setup.hs configure --enable-library-profiling
05:25:43 <shapr> ah!
05:25:50 <shapr> That's useful info.
05:28:40 <postman> shapr: in the definition of fixIO I don't see anything like the semantics of "fix". What's the correspondence?
05:28:59 <shapr> What are the semantics of fix?
05:29:13 <shapr> Informally, I think it's like repeat for a function.
05:29:36 <shapr> @index fixIO
05:29:37 <lambdabot> System.IO
05:29:41 <shapr> @type System.IO.fixIO
05:29:43 <lambdabot> forall a. (a -> IO a) -> IO a
05:29:50 <shapr> @index fix
05:29:51 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
05:29:58 <shapr> @type Control.Monad.Fix.fix
05:29:59 <lambdabot> forall a. (a -> a) -> a
05:30:09 <shapr> They look the same from the type.
05:31:51 <vincenz> how goes
05:32:49 <postman> shapr: fix f = f(fix f), IIRC. There is clearly recursion going on. In fixIO http://paste.lisp.org/display/23031 there seems there is not.
05:36:43 <shapr> postman: I don't know.
05:37:27 * shapr thinks
05:39:04 <shapr> ref is the action that creates a new IORef, ans is the action that reads that ref. The (a -> IO a) passed into the function is applied to ans, which creates and reads the IORef. The result of that is written into the IORef, and returned.
05:39:27 <shapr> postman: Doesn't make much sense to me. But then, there is much deep mental magic in Haskell.
05:40:49 <shapr> postman: Any thoughts?
05:41:42 <postman> shapr: I am reading something on the subject now.
05:43:42 <postman> shapr: http://www.cse.ogi.edu/pacsoft/projects/rmb/mvr.pdf
05:44:11 * shapr looks
05:48:30 <postman> I find the explanation on "value recursion" falling short.
05:48:46 <shapr> postman: http://www.cse.ogi.edu/PacSoft/projects/rmb/recdo.pdf ?
05:50:17 <postman> shapr: sure I will read it. It's too bad that to read one paper you first need another paper explaining that concept. Luckily this recursion bottoms out soon.
05:52:12 <shapr> postman: fix readPapers :-)
05:53:55 <postman> shapr: do you know what "recursive binding" is?
05:57:33 <shapr> In what context?
05:57:50 <shapr> I know recursion, and I know binding.
05:58:22 <ndm> shapr, any more The Monad Reader articles planned?
05:58:41 <shapr> It depends...
05:59:03 <shapr> I stopped nagging authors because I wasn't spending enough time on paying work.
05:59:33 <shapr> If the Haskell community is part of my paying work...
05:59:56 <ndm> I know i offered to write one on Hoogle, and never got round to it because i was waiting for a "final version" of hoogle
06:00:02 <ndm> but I am now offered to write one on PropLang
06:00:06 <shapr> Write it!
06:00:18 <ndm> which as its not part of my phd at all, I don't really need to wait for polish
06:00:19 <shapr> I'd like to write one on how to do IO testing in HUnit.
06:00:29 <postman> While let (and where) constructs of Haskell provide a convenient
06:00:29 <postman> notation for expressing recursive bindings in pure computations,
06:00:32 <postman> That context.
06:00:37 <ndm> I will, if there is the monad reader I'll write a tutorial for that
06:00:41 <ndm> if not, i'll just bung it on the wiki
06:00:52 <shapr> ndm: Yeah okay, I'll scrape up some authors for another issue.
06:01:01 <ndm> shapr, ok, put me down
06:01:03 <postman> shapr: Never mind
06:01:05 <ndm> still on the old wiki?
06:01:07 <shapr> postman: Want to write an article for next issue of The Monad.Reader?
06:01:22 <postman> shapr: The point is that the lhs, and the rhs can contain the same variable.
06:01:24 <shapr> ndm: Probably not. What do you think about Hope?
06:01:43 <shapr> postman: Yes, that's right.
06:01:56 <ndm> shapr, no idea about it
06:02:23 <shapr> People wanted PDF output from The Monad.Reader, and I wanted to keep it as a wikizine.
06:02:32 <shapr> Something that mixed those two would be nice.
06:02:35 <postman> shapr: I don't think I am qualified.
06:03:05 <ndm> shapr, i'll write an article, and leave the rest to you :)
06:03:23 <ndm> or once you tell me, i'll do the rest
06:03:27 <shapr> postman: Sure you are... you could write about fix :-)
06:03:29 <ndm> will probably write the article in Word ;)
06:03:38 <shapr> ndm: Yeah, write an article and I'll organize the server stuff.
06:03:53 <shapr> Some people requested LaTeX .lhs as an input format... hmm.
06:04:58 <ndm> input format is irrelevant, give it will be mainly text
06:05:08 <Philippa_> shapr: I'm a maybe
06:05:36 <shapr> Philippa_: What subject?
06:05:41 <postman> shapr: I know something better to write about, but that will have to wait a couple of months. I will contact you later when I feel like I have something to add.
06:05:45 <Philippa_> good question, ask me later :-)
06:06:50 <Philippa_> got someone due round in an hour, only just got out of bed...
06:07:05 <postman> One totally different question: How many lines of code do you write on a single day on average?
06:07:39 <shapr> postman: In Haskell?
06:08:06 <shapr> Not very many, mostly because I don't need many.
06:08:27 <ndm> postman: the lower you right, the more you do, the happier you are
06:08:34 <shapr> Once my understanding is correct, I can quickly write a small amount of code that does what I want.
06:08:52 <shapr> But I do end up writing a bunch of code in pursuit of understanding.
06:08:54 <Philippa_> 0 would be median here...
06:09:06 <Philippa_> anyway, gtg
06:10:27 <shapr> postman: Lines of code isn't really a good measurement. Problems solved might be better :-)
06:11:57 <postman> shapr: is there anything you wrote online that you know of how long it took you to create?
06:16:33 <postman> Is the code from the previous ICFP contests available somewhere?
06:17:49 <shapr> postman: I wrote a mailing list archive websearch in three evenings of spare time.
06:18:07 <shapr> postman: I don't know where the code is right now but I could find it.
06:18:41 <shapr> It would have taken less time if I had figured out that mapping open over a bunch of files needs to be strict so you don't run out of file handles.
06:19:15 <postman> shapr: you could also have recompiled your kernel
06:19:17 * postman ducks
06:23:58 <shapr> postman: Yeah, but the real problem is that I wanted to open one file at a time. I ended up with a nice lazy pipeline where the max memory usage was the runtime system plus the size of the largest message.
06:57:03 * shapr boings
06:57:08 <shapr> Sure is quiet today.
06:57:28 <Igloo> Hey shapr
07:13:21 <SamB> oookay...
07:13:31 <SamB> my code seems much faster than it was last I tried it...
07:13:43 <ValarQ> SamB: congratulations
07:13:57 <SamB> maybe I forgot to compile the module or GHCi didn't load it... or maybe I actually changed my code...
07:16:18 <SamB> well for some reason I seem to have needed to use C to get my code to run reasonably fast (though I could be wrong)
07:17:58 <vincenz> > 4 ^ 34
07:18:00 <vincenz> > 4 ^ 35
07:18:00 <lambdabot>  295147905179352825856
07:18:01 <lambdabot>  1180591620717411303424
07:18:11 <petekaz> concurrency and laziness question.
07:18:19 <petekaz>         forkIO $ do result <- job
07:18:19 <petekaz>                     tid <- myThreadId
07:18:21 <petekaz>                     writeChan channel (tid, result)
07:18:31 <petekaz> job is an IO a.
07:18:59 <petekaz> That is guaranteed to be executed in the thread?  a thunk won't be written to my channel right?
07:19:10 <musasabi> if job is strict.
07:19:40 <musasabi> e.g. think about (return veryLongComputation) as job.
07:19:43 <SamB> hmm, which is more efficient, StateT stacked on ReaderT or ReaderT stacked on StateT...
07:20:08 <petekaz> it's an IO a, doesn't that mean it is guaranteed to run before writeChan is called because IO actions are sequenced?
07:20:40 <musasabi> SamB: perhaps abstract the lifting operations with suitable names and then just benchmark with changing the order?
07:20:57 <SamB> musasabi: good point, I can change it later...
07:20:59 <musasabi> petekaz: the IO is guaranteeded to run.
07:21:43 <petekaz> So 'result' will not be a thunk right?
07:22:51 <Philippa_> that's not entirely guaranteed - lazy IO exists
07:23:09 <musasabi> unsafeInterleaveIO, but that is unsafe
07:23:16 <petekaz> The confusion is occurring because I am looking at the implementation of 'parIO' in the Awkward Squad, and it's implemented like this:
07:23:44 <lisppaste2> petekaz pasted "parIO" at http://paste.lisp.org/display/23033
07:23:52 <Philippa_> musasabi: that, and there're primitives in the standard libraries that use it
07:24:40 <petekaz> Looking at 'child', the value is pulled from the action.  There is no 'seq' to force evaluation.
07:25:12 <musasabi> petekaz: yes. a1 and a2 may seq things or leave things without seq.
07:25:19 <petekaz> So I am forced to assume that it will be evaluated, otherwise one is just spawing a thread, to put a thunk in the mvar.
07:26:08 <petekaz> So if in parIO, a1 just added 2 numbers together, no seq, then the computation is not going to occur in the thread?
07:28:19 <musasabi> if e.g. a1 is (return var1+var2) the return gets executed in the forked thread but the (+) will not (unless the compiler infers it is strict and think that it makes sense)
07:28:46 <petekaz> I see.
07:29:31 <petekaz> So if I use forkIO, I need to make sure that I strictify the work to be done.
07:29:41 <petekaz> Otherwise, it's all for nothing.
07:30:14 <musasabi> yes, if you use forkIO for pure computations. Most of the time people use it with monadic actions so it is not a large issue.
07:30:23 <SamB> ack
07:30:40 <SamB> can't do newtype deriving of multi-parameter typeclasses...
07:30:56 <petekaz> musasabi: return var1+var2 is not monadic?
07:31:07 <musasabi> var1+var2 is not monadic.
07:31:29 <petekaz> but what about return?
07:32:11 <musasabi> SamB: this works: newtype Foo a = Foo (State () a) deriving(MonadState ())
07:32:40 <musasabi> petekaz: that is monadic. and that gets evaluated inside the forkIOed block.
07:33:04 <petekaz> ok.
07:33:11 <petekaz> I think I understand.
07:33:28 <SamB> musasabi: nice
07:33:50 <SamB> since I wanted the state and reader types fixed anyway
07:35:21 <petekaz> I wrote a job dispatcher this morning.  Basically, I wanted to have an API where I could pass a list of thunks, a parameter stating the max num of concurrent threads, and then run all of the thunks in threads up to max, and then as soon as one finished, start another.
07:35:21 <SamB> hmm, the UM spec doesn't seem to include the finger in the Physical Specifications
07:35:42 <lisppaste2> petekaz pasted "Job Runner" at http://paste.lisp.org/display/23034
07:36:45 <petekaz> Mind you, I am not sure of how to make this generic yet (still figuring out the type system), but my 'let result = job' in that code must be strictified based on what I just understood from musasabi.  Is this correct?
07:39:47 <musasabi> petekaz: yes.
07:42:00 <petekaz> Ok, but if I make this polymorphic, and make dispatch take a list of (IO a)s, then I, as the writer of this library function, should I force the strictness of evaluation?  Ie., instead of let result = job, I would have result <- job, then somehow sneak 'seq' in there to force it to occur in the thread?
07:42:35 <petekaz> Or should I leave that to the user of the call that pass the IO actions?
07:45:06 <musasabi> I would probably just seq them and let the user worry about how deep the seq should be.
07:45:42 <musasabi> result `seq` writeChan channel (tid, result)
07:45:54 <petekaz> Ok, so my next question, is how do I use 'seq' ... nevermind :-)
07:46:36 <petekaz> Thanks for the help musasabi.  Laziness is very confusing!
07:47:08 <petekaz> Especially when combined with monads.
07:47:45 <petekaz> The part that is confusing for me is that monads guarantee the sequencing of operations, and somehow I thought this meant being strict in evaluation.
07:49:19 <shapr> hiya Igloo!
07:49:22 <petekaz> Plus the example of 'parIO' had reinforced this view as there was no caveat mentioned indicating that if a1 or a2 were not strict, then parIO is pointless as the real work is occurring in the main thread itself vs the child threads.
07:49:29 <vincenz> Igloo: how are you guys doing?
07:49:55 <vincenz> Igloo: and join #oasis :) it became official chan for icfpc
07:50:27 <musasabi> petekaz: it is not pointless e.g. if the actions are trying to fetch DNS records from two different servers - in such situations it works fine without thinking about lazyness.
07:50:58 <shapr> musasabi: Hiya!
07:51:09 <musasabi> hello shapr
07:51:19 <vincenz> shapr: check it out, we're 4th
07:51:23 <vincenz> \o/
07:51:24 <shapr> vincenz: awesome!
07:53:48 <petekaz> musasabi: because the tasks required to fetch DNS records involve IO right that will definitely occur before writeChan is actually called (in my case).
07:54:32 <petekaz> s/right that/right, that/
07:56:39 <petekaz> vincenz: where are the standings listed?
07:56:59 <vincenz> http://www.icfpcontest.org/scoreboard.shtml
07:57:02 <lambdabot> Title: ICFP Programming Contest, 2006 : Scoreboard
07:57:03 <vincenz> we're the Lazy Bottoms
07:57:27 <petekaz> nice. are the teams above you haskell users?
07:57:31 <vincenz> dunno
07:58:12 <dons> go lazy bottoms :)
07:58:35 * dons go sleep
07:59:01 <vincenz> dons: niight
08:10:22 <Igloo> vincenz: Well, we're showing as 12th ATM
08:10:37 <Igloo> vincenz: Which team are you again?
08:10:37 <vincenz> yeah but you guys caught up a lot
08:10:39 <vincenz> lazy bottoms
08:10:50 <vincenz> 4th atm
08:10:54 <vincenz> hoping to hit 3rd
08:10:56 <vincenz> if lemmih succeeds
08:11:01 <Igloo> Yeah, there's been a lot of to-and-fro
08:11:11 <vincenz> yeah, get a puzzle done , blammo
08:11:15 <vincenz> x*10 places
08:11:33 <kuribas> Does haskell use memoization for already computed results?
08:11:45 <petekaz> The pressure is on for you guys!!  Go Haskell go!!
08:11:52 <Igloo> Unfortunately we only got 3 people together in the end
08:12:19 <vincenz> Igloo: kosmikus, dcoutts and you?
08:12:31 <Igloo> Heffalump, dcoutts and me
08:12:53 <petekaz> kuribas: for already computed thunks, but not automatic function memoization (from what I understand).
08:13:07 <Igloo> Do you know of any other Haskell teams OOI?
08:13:50 <vincenz> hmm
08:13:51 <vincenz> dons:
08:13:57 <kuribas> petekaz: ah yes, of course.  That would be logical I guess.
08:13:59 <vincenz> daes-ex-machina
08:14:24 <vincenz> then htere's alar/marc_vw/davidad ...basically some people from the original #oasis team that got turned into a new separate one
08:14:42 <Igloo> Why "deaus"?
08:14:49 <vincenz> deus
08:14:50 <Igloo> And is that dons on his own?
08:14:55 <Igloo> Why the a, though?
08:14:59 <vincenz> oh?
08:15:12 * vincenz shrugs
08:15:27 <Igloo> Hang on, I'm confused. Did you mean dons is in deaus-ex-machina above?
08:15:34 <vincenz> yes
08:15:56 <Igloo> OK. Who else is in that team?
08:16:11 <vincenz> no idea
08:16:14 <Igloo> OK  :-)
08:16:14 <vincenz> people from his uni afaik
08:16:47 <petekaz> kuribas: why is it logical again?  I always forget?  My first inclination is that in a purely functional language without side effects, wouldn't memoization of all function calls be feasible.
08:17:35 <ndm> petekaz: its possible, but usually two slow
08:17:39 <ndm> too much memory
08:17:46 <ndm> typically CAF's are memorised though
08:17:52 <petekaz> CAF?
08:18:00 <ndm> Constant Applicative Form
08:18:13 <ndm> basically if you do "value = very complex computation"
08:18:14 <petekaz> what is that?
08:18:17 <petekaz> oh.
08:18:19 <ndm> then value will only be calculated once
08:19:28 <petekaz> It would be cool to have some syntax to automatically say this function is to be memoized.  But, if I recall, there was another reason memoization wasn't a good idea (aside from the memory usage), something about ambiguities, but I am having a hard time remembering.
08:19:54 <petekaz> ahh ...
08:19:57 <petekaz> I remember now.
08:20:25 <petekaz> Because haskell is lazy, args to a function could just be thunks, vs the actual values.
08:21:07 <petekaz> So it's very hard to memoize without turning haskell into a non-lazy language, so one can compare whether the function and args have been used before.
08:25:47 <shapr> @yow !
08:25:47 <lambdabot> Hmmm ... a CRIPPLED ACCOUNTANT with a FALAFEL sandwich is HIT by a
08:25:48 <lambdabot> TROLLEY-CAR ...
08:29:14 <lisppaste2> petekaz annotated #23033 with "Another Question an parIO" at http://paste.lisp.org/display/23033#1
08:29:26 <petekaz> musasabi: you there still?
08:29:45 <musasabi> petekaz: yes, for ~5min.
08:30:23 <kuribas> petekaz: I think that it is difficult for a compiler to know when memoizing would be efficient and when not.  Memoizing everything would be a gigantic space leak :)
08:31:09 <musasabi> http://www.haskell.org/haskellwiki/Timing_out_computations
08:31:10 <lambdabot> Title: Timing out computations - HaskellWiki
08:31:35 <petekaz> musasabi: I got confused again, but now I think I'm good.  At first I was thinking that r <- a; return (Just r) was not going to run in the thread unless it was seq.
08:31:59 <petekaz> But it's the same scenario as before, if a was doing DNS lookups, that would occur first.
08:32:16 <musasabi> yes.
08:32:23 <postman> Who made up comma syntax in guards?
08:32:45 <musasabi> -> away
08:33:01 <petekaz> I think that is in the paper "Pattern Guards and Transformational Patterns"
08:33:16 <petekaz> by simon pj and martin erwig.
08:33:18 <postman> Is there also a syntax for "or"?
08:33:42 <ndm> postman: ||
08:33:49 <dons> Igloo, "deaus" as in .de-utchland and .aus-tralia. (2 guys in Frieburg, 2 in sydney)
08:33:53 <petekaz> I don't know, I was looking for something like that the other day when I was writing my job runner.
08:33:56 <postman> ndm: you are missing the point: there is also &&
08:35:12 <petekaz> postman: but the comma can be used to test a predicate, and assign vars.
08:35:15 <petekaz> rigth?
08:35:36 <postman> petekaz: I have no idea, I just inductive reasoned what it might mean.
08:35:37 <petekaz> | job:rest <- jobs, active == 0
08:35:45 <petekaz> I don't think I can use && for that.
08:35:55 <postman> petekaz: Oh, I didn't see <- yet.
08:36:39 <Igloo> dons: Aha, thanks!
08:37:07 <petekaz> I am really interested in the transformational patterns part, it seems it was never implemented, and my post to ghc-users didn't prompt any responses.
08:39:36 <postman> In Haskell 98 you have to specify all the arguments before putting a guard somewhere, right?
08:49:22 <ndm> postman: yes
09:41:19 <yaxu> hi
09:41:29 <yaxu> anyone want to see a brief haskell music screencast?
09:41:47 <AtnNn> yeah
09:41:53 <yaxu> http://yaxu.org/20/hs.avi
09:41:55 <wli> sounds interesting
09:41:59 <AtnNn> tx
09:43:55 <araujo> m, what is it?
09:44:32 <yaxu> haskell running some code to general simple drum patterns
09:44:46 <yaxu> if i edit and save the code it reloads using hs-plugins
09:44:53 <yaxu> so i can modify the patterns live
09:45:09 <yaxu> causes a bit of a break in sound at the moment though :/
09:45:26 <AtnNn> cool
10:02:21 <flodin> so what happens if you introduce a syntax error? :)
10:05:52 <ndm> @seen dcoutts
10:05:52 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #haskell-overflow and #oasis. I last heard dcoutts speak 2 hours, 24 minutes and 11 seconds ago.
10:09:58 <yaxu> flodin: fails to reload and continues with old version
10:12:29 <gaal> I have a definition: newtype PureSet = Set Val. Elsewhere in my code, I have Data.Set.elems someset, and someset is of type PureVal.
10:12:49 <gaal> this fails typecheck with Couldn't match `Set a' against `PureSet'
10:13:26 <gaal> (er, someset is of PureSet, that is)
10:13:36 <gaal> why does this fail? what can I do about it?
10:14:14 <gaal> (Val is some unrelated datatype.)
10:15:15 <musasabi> gaal: you might want to use type instead of newtype
10:15:26 <gaal> musasabi: I need to derive stuff.
10:15:48 <gaal> (plus I'm using DrIFT on that type.)
10:16:26 <gaal> does DrIFT work on type aliases?
10:16:46 <norpan> gaal: i'm not sure exactly what you have done, but when declaring a newtype you need a newtype constructor
10:17:09 <norpan> or is that what Set is?
10:17:35 <norpan> otherwise, use newtype PureSet = PureSet (Set Val)
10:18:33 <gaal> eerp, you're right of course. thanks
10:27:34 <lisppaste2> AtnNn pasted "ghc + lamdaot" at http://paste.lisp.org/display/23036
10:35:25 <ndm> AtnNn: download GHC 6.4.2
10:35:59 <AtnNn> ok
10:43:08 <ulfdoz> So, futtern.
10:44:05 * edwardk waves hello.
10:45:45 <edwardk> heya dm
10:49:03 * Korollary waves back
10:50:06 <Buzzons> if you go head tail on a list, what is it when you go last xxxx
10:50:18 <Buzzons> tail returns all but head, whats the one that returns all but last
10:50:55 <AtnNn> init
10:51:45 <Buzzons> thankee
10:57:36 <dmhouse> Hi edwardk
10:58:11 <dmhouse> When does the ICFP contest end?
10:58:17 * edwardk is sitting around beating his head against substructural logics.
10:58:18 <edwardk> not sure
10:58:27 <Korollary> tomorrow noon edt
10:58:29 <Igloo> 22 hours time
10:58:42 <dmhouse> Tomorrow? So it extends into Monday?
10:58:45 <edwardk> the lazy bottoms have to get off their... aw... too easy, no poits.
10:58:48 <Igloo> Yes
10:58:51 <edwardk> er points
10:58:57 <dmhouse> Aha, fun.
10:59:01 <Igloo> :-)
10:59:04 * dmhouse goes googling for the site.
10:59:10 <dmhouse> How are all the teams doing?
10:59:18 * Lemmih grins.
10:59:18 <Igloo> We're currently showing as 3rd
10:59:44 <edwardk> we == duncomloolookup in this case?
10:59:59 <dmhouse> Igloo: who's the 'com'?
11:00:01 <edwardk> er loolump or whatever
11:00:25 <Korollary> Duncan, Heffalump, Igloo ?
11:01:30 <gaal> hi. I have code that reads:
11:01:32 <gaal> putStrLn $ showPerl6TypeDef (undefined :: Code)
11:01:47 <edwardk> gaal: ok
11:01:50 <gaal> but I want to do this for many other types apart from Code. Is there a way to do that?
11:02:03 <gaal> I mean without spelling out the types :)
11:02:26 <gaal> or rather. with spelling them out; but not repeating the incantation.
11:03:00 <gaal> Data.Generics maybe?
11:03:13 <dmhouse> Try Data.Typeable or similar, yes.
11:03:22 <dmhouse> Lemmih: how are the Lazy Bottoms?
11:03:24 <Igloo> ComradeP (but he had to leave before we get the decompressed codec and won't be back until tomorrow  :-(  )
11:03:31 <edwardk> 6th at last check
11:03:36 <Igloo> I'm not sure if he'll have ever been in here or not
11:03:44 <Igloo> edwardk: Yes
11:03:59 <Lemmih> dmhouse: We're plotting our return to the top-3.
11:04:23 <dmhouse> Lemmih: good stuff.
11:04:26 * dmhouse is reading the task
11:04:42 <edwardk> team smartass seems to be asymptotically approach a perfect score
11:05:00 <zarvok> Igloo: what language did you write your UM in, out of curiosity?
11:06:50 <edwardk> they have someroom for improvement in antwo and could score about 3 more points in advis going by other folks scores, but they are only 203 points below the score obtained by taking everyone's best cases and combining them.
11:07:05 <gaal> there is TyCon -> TypeRep, and from there I might be able to coerce, but I don't necessarily want to explicityl enumerate constructors
11:07:10 <gaal> looks like I'm out of luck.
11:07:36 * edwardk slapped together a simple um in c++ just to see what the competition was about this year.
11:08:16 <edwardk> the um is pretty well biased towards a c/c++ style implementation
11:08:32 <edwardk> where you just malloc the arrays, etc.
11:08:39 <edwardk> er calloc
11:11:10 <Igloo> Our Haskell one was usable, but our C one makes things a lot easier due to faster response
11:11:19 <zarvok> cool
11:11:42 <zarvok> I tried a haskell implementation and it didn't go so well, but I wasn't able to spend much time on it
11:11:53 <xerox> Ciao!
11:12:29 <xerox> dcoutts: third eh?
11:13:16 <edwardk> I went c++ for the implementation, then slapped in a coredump/undump feature so i wouldn't have to reread everything each time, then got distracted by the fact that I should probably write a thesis this semester.
11:13:25 <xerox> Howdy edwardk %-)
11:13:30 <edwardk> heya xerox
11:14:47 <zarvok> edwardk: heh, probably a smart choice, makes me think of this lambda-the-ultimate post:
11:14:50 <zarvok> http://lambda-the-ultimate.org/node/1600#comment-19980
11:14:52 <lambdabot> Title: 2006 ICFP Programming Contest registration opens | Lambda the Ultimate
11:15:27 <dmhouse> xerox, isn't 'Ciao' a word for 'goodbye'?
11:15:49 <Korollary> xerox is a special kind of italian
11:15:59 <xerox> dmhouse: it can be used really in every situation (:
11:16:05 * xerox stares at Korollary 
11:16:11 * Korollary stares back
11:16:27 <edwardk> "The word ciao (pronounced somewhat like chow, and occasionally misspelled as such) is an informal verbal salutation or greeting, meaning "goodbye" or (more rarely) "hello"."
11:16:27 * xerox gives up and lughs
11:16:32 <xerox> *laughs
11:16:38 * Korollary throws confetti at xerox
11:16:47 <xerox> edwardk: well, no!
11:17:01 <edwardk> well, as wikipedia says it anyways =)
11:17:07 * xerox throws lambdacandies back to Korollary 
11:17:25 <xerox> Between friends you welcome with "Ciao!"
11:17:55 <xerox> Let it be alone the more idiomatic ways, which are even more context-dependent.
11:18:06 <edwardk> is anyone here comfortable with pure type systems and substructural logics?
11:18:28 <dmhouse> A Haskell team won the ICFP contest last year, right? Which one?
11:19:00 <zarvok> dmhouse: yes, team name "KiebererAndXiaoTou"
11:19:56 <zarvok> dmhouse: and the year before as well
11:20:03 <zarvok> (a different haskell team)
11:20:11 <zarvok> I guess igloo/dcoutts team, actually
11:20:28 <Igloo> 2 years ago it was us
11:20:36 <zarvok> yeah
11:20:37 <Igloo> Last year wasn't
11:20:54 <zarvok> right, a different haskell team
11:21:18 <Igloo> Yup
11:21:18 <zarvok> did you guys play last year?
11:21:21 <Igloo> Yes
11:21:43 <Igloo> We got through to the final stage and were somewhere around 10, I think
11:21:50 <edwardk> you guys need to get working. Team Smartass from last year was a Java team. We can't lose to java.
11:21:52 <zarvok> cool, nice work
11:22:30 <Igloo> edwardk: Did no-one tell you, it's your year to defend the honour of Haskell!
11:22:54 <dmhouse> It looks like a really fun contest.
11:22:55 <edwardk> heh, crap. well, 21 hours should be enough ;)
11:33:35 <dmhouse> @seen kowey
11:33:35 <lambdabot> I saw kowey leaving #haskell and #darcs 1 hour and 45 seconds ago, and .
11:33:44 <dmhouse> Yay, he's back.
11:44:41 <thanith> hello everyone
11:44:57 <sieni> 'lo
11:45:10 <dmhouse> Hey thanith.
11:45:11 <sieni> bachelor parties rule
11:45:27 <sieni> even if you end up feeling like a used condom
11:45:40 <dmhouse> sieni: Interesting analogy.
11:45:53 <thanith> anyone here who uses the eclipse dracs plugin  ?
11:46:11 <sieni> dmhouse: we took a boat from helsinki to tallinn...
11:46:15 <thanith> darcs :)
11:46:36 <dmhouse> Darcs should release a Halloween version called 'dracs'. :)
11:46:51 <sieni> which probably summarizes my feeling pretty much
11:47:11 <thanith> no the dracs are from "enemy mine" :)
11:48:52 <Lokadin> say, i want to be able to start a socket server, and then have a program attach to it to manage the input and output for the server
11:49:09 <Lokadin> how could i do that?
11:50:41 <Lokadin> so as in i start up a server, perhaps telling it what password the application that will be managing the connection would be using, then connect over a socket to it?
11:50:46 <xerox> sieni: you are _ever_ partying!
11:51:14 <sieni> xerox: _n_ever?
11:51:29 <sieni> xerox: I'm on vacation right now
11:51:39 <sieni> xerox: for a few weeks more still
11:53:24 <Lokadin> bah, but that kinda defeats the purpose, if you have to program in sockets every time you want to make a server
11:53:59 <sieni> xerox: and the fact that i'm drinking doesn't mean that i'm partying. you can drink without any particular reason (no that i would advocate such irresponsible abuse of alcohol to anyone)
11:54:00 <Lokadin> sieni: how can you have many weeks of vacation?
11:54:24 <Lokadin> as in where do you work?
11:54:25 <sieni> Lokadin: 5 weeks per year paid vacation is the law in finland
11:54:36 <Lokadin> wow
11:54:47 <sieni> although for new employees it's less
11:54:53 <Lokadin> that's amazing
11:54:56 <thanith> what goes wrong if darcs tells me "darcs: PATH: getEnv: does not exist ..... "
11:55:00 <sieni> Lokadin: how so?
11:55:32 <Lokadin> well here 2 weeks paid vacation is considered pretty good, from what i know anyways
11:55:40 <wilx> Huh.
11:55:49 <wilx> That's slavery :)
11:55:56 <sieni> Lokadin: you probably live in a bad place
11:56:04 <wilx> Here it is 4 weeks, by law.
11:56:05 <Lokadin> dono, toronto, Canada
11:56:42 <Lokadin> states aren't any better to my knowledge
11:56:54 <wilx> I somewhere read an article about this and comparison of worker performance in Europe with 4 or more weeks of paid vacation and US (and maybe Canada) where it seems to be only two weeks.
11:57:11 <norpan> i have 6 weeks
11:57:29 <Korollary> I get about two weeks
11:57:30 <sieni> I'll probably get some unpaid vacation as well
11:57:33 <wilx> The conclusion was that US workers do not produce more with their just two weeks.
11:57:53 <sieni> two weeks per year is a) inhuman and b) unproductive
11:58:26 <wilx> Seriously, 4 weeks is like minimum I can imagine.
11:58:30 <wilx> Two weeks in summer.
11:58:38 <wilx> A week around Christmas.
11:58:56 <wilx> A week January or February maybe.
11:59:02 <sieni> I just noticed that I would survive pretty well with only 4 days of employment a week
12:00:29 <norpan> esp if you're doing intellectual work
12:00:36 <stepcut> I would survice pretty well only 0 days -- if someone would just pay my bills
12:00:41 <wilx> :D
12:00:49 <wilx> You would get bored pretty soon.
12:00:51 <sieni> just regular bit wanking
12:01:17 <norpan> four weeks in the summer and one week around christmas, and one more week in the spring
12:01:25 <norpan> that's about sufficient
12:01:29 <wilx> Heh.
12:01:33 <stepcut> wilx: nah, I have plenty to get me busy without having to go to a job too
12:01:53 <sieni> although I dislike how the suits are paid too much in comparison to people who actually make the products
12:01:58 <norpan> otoh, the us way seem to be to quit and then take a new job after a few weeks :)
12:02:19 <wilx> The rationale is that the suits take responsibility.
12:02:23 <Lokadin> hmmm, well anyways, i was wondering what the best way to disconnect sockets from the application would be, i was thiking of having the socket server function seperatly, and just have the application latch on somehow, and i was just wondering what would be the best way for it to latch on, while not using sockets, as that would defeat the purpose
12:02:25 <wilx> In therory...
12:02:47 <sieni> I would want to get as much as the suits, but since that's not possible I intentionally keep up with a substandard amount of work
12:03:11 <stepcut> sieni: if you want to get as much as the suits, then just do what the suits do :)
12:03:11 <wilx> Heh.
12:03:19 <norpan> of course it's possible, just get a manager job
12:03:22 <yaxu> xerox: did you see my screencast
12:03:44 <wilx> I have friends who studied CS and are decent programmers but who went for server administration for exactly those reasons :)
12:03:52 <xerox> yaxu: no!
12:05:36 <Lokadin> maybe if i have an intermediate application, that i would run with runInteractiveCommand, and it would then connect to the server
12:06:03 <xerox> yaxu: where is it? Running to get some food, be back shortly.
12:06:05 <Lokadin> and i would not have to use sockets in the actual application just text communication with the command that was run
12:06:38 <Lokadin> the command being the thing that connects to the server and authenticates
12:06:46 <sieni> I don't want a manager job, except maybe being an engineer managing other engineers.
12:07:47 <Lokadin> so do you guys think that would work?
12:07:53 <Lokadin> or is there a simpler way?
12:08:04 <thanith> cant get the darcs plugin to work at all maybe i have to stick to subclipse :)
12:08:15 <sieni> I don't hate suits, quite the opposite. If I hated suits I would spend much of my precious free time hating people of whose existence i couldn't care less
12:09:04 <Lokadin> okay, well i'll go and try to make it then
12:16:51 <stepcut> sieni: I guess a different way to say it is, if you want more money, then you must something that has higher value. It is important to realize that there is no connection between the skill or difficulty of a job, and its value in the marketplace :)
12:17:22 <sieni> stepcut: indeed
12:17:47 <Korollary> no connection?
12:18:07 <sieni> I think I have some marketable skills, but I don't want to work outside finland
12:19:14 <sieni> stepcut: I only get paid for doing my work well. Not for doing it exceptionally well.
12:20:02 <stepcut> sieni: indeed
12:21:30 <stepcut> Korollary: pretty much
12:22:10 <sieni> I'm a finn, I'm from a protestant country even though i'm not a christian. we have a sense of responsibility for "doing your job well" even though there's no moral binding for it
12:23:37 <stepcut> sieni: right -- there is nothing wrong with that.
12:23:50 <sieni> which probably summarizes quite a bit about finnish attitude
12:24:51 <sieni> that if you think your employer is oppressing you, you can always do the amount of work that you think your work is worth for
12:26:18 <stepcut> sieni: yep -- and they'll probably keep paying you the same amount too :p
12:29:17 <wolverian> sieni, that's probably a pretty universal attitude.
12:29:43 <stepcut> pay increase is linked to how much value you contribute, if you aim to keep your value in line with your current pay, I think it is resonable to expect your pay ought to stay where it is.
12:30:51 <stepcut> But it is important to realize that increasing your value does not neccessarily mean working 'harder'.
12:31:47 <stepcut> and working harder, does not always mean you have increased your value either
12:32:22 <shapr> Sounds like I dropped into an interesting discussion.
12:32:55 <sieni> I don't mean I'm not contributing enough in my job, but I would be willing to use more of my intellectual capacity for my work, if the suits would appreciate more of what I do
12:33:41 <sieni> but if the attitude is negative, then it's not my fault my attitude is negative as well
12:34:16 <stepcut> sieni: it is *totally* your fault if your additude is negative -- your additude is one of the few things that you have 100% control over
12:34:27 <shapr> Interesting point.
12:34:45 <stepcut> s/additude/attitude/ ;)
12:34:47 <sieni> stepcut: I have to earn my living somehow
12:34:49 <shapr> Does that imply that tolerating a job where the management doesn't trust you is one's own fault as well?
12:34:58 <shapr> Makes me think I should have gotten rid of some of my clients awhile back :-/
12:35:29 <stepcut> shapr: probably (on both accounts)
12:35:39 <sieni> I'm working in about the only company in finland that produces industrial quality unix code
12:36:52 <stepcut> sieni: so
12:37:03 <stepcut> you don't have to have a bad attitude to be employeed...
12:37:05 <shapr> sieni: How can you increase trust between you and management?
12:37:14 <stepcut> I don't think that is a job requirement :p
12:37:56 <sieni> Me and my immediate management don't have a problem with trust
12:38:07 <sieni> which i have stated before
12:40:26 <shapr> Oh, I missed the previous discussion.
12:40:33 <sieni> the problem isn't the suits as such, but their unwillingness to recognize what it requires for an engineer to work effectively
12:40:53 <shapr> Have you talked to them about it?
12:41:08 <sieni> I've talked to my boss, yes
12:41:15 <shapr> Does it help?
12:41:42 <sieni> well, it helps as much he can do about it
12:42:08 <sieni> we can also refuse to work with my collagues
12:42:23 <sieni> but that's not necessarily a helpful attitude
12:43:57 <sieni> I'm not agains of engineering management or anything of that stuff
12:44:32 <sieni> Quite the opposite, I like to be on the managers's side on employment issues and such
12:48:29 <dmhouse> sieni: What, precisely, is the problem? I feel like I've heard most of this conversation but missed nearly all of it. :)
12:51:37 <sieni> dmhouse: my problems are manifold
12:52:22 <sieni> dmhouse: most of which are caused by the fact that one has to deal with idiots
12:53:26 <ndm> sieni: i once had a boss who complained because some code someone had written crashed, and yet "it clearly says in the company coding guidelines not to write code that crashes"
12:54:42 <dmhouse> @remember ndm i once had a boss who complained because some code someone had written crashed, and yet "it clearly says in the company coding guidelines not to write code that crashes"
12:54:43 <lambdabot> Done.
12:55:13 <madpickle> one has to deal with idiots all the time
12:55:16 <dmhouse> :)
12:55:40 <madpickle> it's all about diplomacy and subtlety
12:55:53 <sieni> With an idiot I mean a person who thinks he can write flawless c code an when i whine tha c++ is a complicated language, directs me to learn c++ from a basic oo design principles handbook, yet is unable to spot many of the most trivial race conditions
12:56:14 <sieni> the suits are one thing
12:56:39 <madpickle> shrug
12:56:48 <sieni> the people who think they are programmers, but yet lack the basic abilities being one, are another
12:56:52 <yaxu> xerox: http://yaxu.org/20/hs.avi
12:56:52 <madpickle> there's not much you can do about that other than understanding it and smiling and nodding
12:57:11 <stepcut> sieni: bah, bill gates has been working with those types of engineers for years, and he did ok
12:57:17 <madpickle> or quit
12:57:19 <ndm> i also overheard one person in the company teaching another person about writing threaded code = "you don't need to worry about locks, because those kinds of problems only happen occasionally"
12:57:20 <madpickle> or make your own company
12:57:33 <madpickle> and see how you handle all the aspects you, as an engineer, wouldn't understand
12:57:41 <stepcut> ndm: you don't need to worry about locks, just use STM ;)
12:57:44 <zvrba> ndm , rofl :)
12:58:00 <sieni> madpickle: I can tell my boss to kick those persons out, but that doesn't help much if they aren't going to kick those guys out anyway
12:58:08 <zvrba> great attitude towards locking!
12:58:17 <ndm> the company was making embeded road sign controllers in C, if that scares anyone just a little bit more :)
12:58:26 <stepcut> zvrba: perhaps that's what they mean by 'optimistic locking' ?
12:58:40 <zvrba> stepcut: hahaha :)
12:58:56 <zvrba> ndm: ugh! disaster waiting to happen
12:59:01 <ndm> they also had to compile a couple of their programs in debug mode only, never release mode
12:59:17 <zvrba> ... maybe the compiler is buggy enough
12:59:17 <shapr> yikes
12:59:29 <ndm> since debug mode in C on Windows initiallises memory to 0xdeadbeef, which was implicitly relied upon
12:59:41 <zvrba> jeez
12:59:49 <ndm> and it puts less things in registers, which removes some really bad race conditions/shared variables
12:59:50 <dmhouse> Woah, really?
12:59:51 <zvrba> wait, road sign controllers... on windows?!
12:59:58 <ndm> zvrba: Windows CE
13:00:05 <zvrba> but still, windows..?!
13:00:15 <zvrba> *shrug*
13:00:25 <ndm> dmhouse: yes, I spent 2 days tracking down a bool that was uninitialised, but defaulted to true in debug, but false in releaes
13:00:46 <ndm> zvrba: they had cute little user interfaces, it was actually pretty neat
13:01:09 <ndm> and debugging embeded win ce is amazing, you can set breakpoints on a machine attached to your computer, and examine variables etc.
13:01:09 <zvrba> ndm: who ever sees UI of traffic light controller?!
13:01:35 <ndm> zvrba: it wasn't traffic lights, it was big motorway side signs, which have a UI for the person doing maintenance
13:01:40 <madpickle> yeah, MS tend to make that kind of stuff painless
13:01:54 <zvrba> ndm: ahaa.. oki :)
13:02:12 <zvrba> MS has actually good stuff for their developers
13:02:23 <ndm> madpickle: thats why i want MS to snap up Haskell, and write a decent debugger!
13:02:26 <zvrba> I was amazed to hear that you can download debug symbols for most of win apps and dlls
13:02:45 <madpickle> MS' view on software dev is that it's a tool to solve a problem, and they are quite right.
13:02:58 <dmhouse> What else could it be?
13:03:40 <zvrba> dmhouse: some ppl make it into religion :P
13:03:47 <shapr> @quote hakko
13:03:48 <lambdabot>  most programmers have a lot of religious issues about their work, yes.
13:04:14 <ndm> woohoo, i just solved part of my phd, with a 76Mb output
13:04:18 <zvrba> I think java ppl are among the worst ones on that matter
13:04:24 <zvrba> yay!
13:04:26 <ndm> (now i just have to read it and check it got it right)
13:04:28 <zvrba> ndm: what's your topic?
13:04:36 <sieni> could somebody explain, why windows doesn't provide posix condition variables as a primitive
13:04:42 <dmhouse> Pah. Programming isn't religious, but indentation styles are.
13:04:48 <zvrba> sieni: stop after posix :P
13:05:06 <sieni> zvrba: condition variables are useful
13:05:13 <zvrba> sieni: and no, there's no rational answer
13:05:30 <zvrba> sieni: you have some event stuff
13:05:35 <ndm> zvrba: stopping haskell programs crashing at runtime with pattern match errors
13:05:38 <ndm> for example: http://www.cs.york.ac.uk/fp/darcs/catch/src/Example/Ant.hs
13:05:45 <shapr> zvrba: I think it's anybody who knows only one tool.
13:05:54 <zvrba> shapr: good point
13:05:55 <ndm> I proved that that code doesn't crash
13:06:10 <zvrba> when you have only a hammer, everything looks like a nail :)
13:06:16 <shapr> Yup
13:06:24 <shapr> When I only knew Visual Basic...
13:06:28 <shapr> Then I learned Java...
13:06:30 <xerox> Nice permutations code, ndm :-)
13:06:30 <shapr> Then I learned Python..
13:06:43 <dmhouse> That's one of the expressions I try to always remember.
13:06:49 <zvrba> ndm: nice
13:06:58 <ndm> xerox: not my code, its from someone else, entirely unmodified
13:07:10 <ndm> try and prove in your head that it doesn't crash, the proof is very complex
13:07:11 <xerox> ndm: you could use guards instead of `if', style++
13:07:17 <yaxu> xerox: can give you the code if you like but it's not nice
13:07:37 <xerox> yaxu: hang on, I downloaded it, now I'll stop the music and play it =)
13:08:32 <zvrba> ndm: so , what's the alternative to crashing?
13:08:50 <ndm> zvrba: you mean how does my thing do it?
13:09:10 <zvrba> yes
13:09:17 <ndm> to check that code i just typed "catch Ant.hs -casecheck"
13:09:22 <xerox> yaxu: haha, that's fabulous, I'd love to see the code.
13:09:23 <ndm> so I guess its to use catch
13:09:34 <ndm> once I have finished it, so it works a bit more reliably
13:09:45 <sieni> zvrba: have fun implementing condition variables correctly especially when all the googlable documentation is, if not wrong, but at least misguided
13:09:56 <ndm> and replace the current n^2 algorithm with an n one
13:10:40 <zvrba> sieni: all you need is critical section
13:10:44 <zvrba> sieni: and that's what windows provides
13:10:52 <zvrba> and I've done it at least once
13:11:20 <sieni> zvrba: yes, i just recently did that to production code
13:11:40 <sieni> and i don't want to do it again
13:18:48 <xerox> ndm: about that code, does it typecheck? `shorter' isn't really an IO action.
13:19:21 <ndm> xerox: yep, it type checks
13:19:42 <ndm> xerox: why should shorter be an IO action? there is no IO in this whole thing
13:19:43 <xerox> Hasn't main got to be of type IO a ?
13:19:54 <ndm> xerox: only in module Main
13:20:08 <ndm> for my tool, it just uses main as the name so it knows where to start checking
13:20:23 <ndm> and to be used by my tool, the code gets compiled with both Yhc and Hugs
13:20:53 <ndm> in the original code main took its first argument and ran shortest on it, and outputted the result
13:21:05 <ndm> but that stuff is uninteresting as far as my checker is concerned
13:21:30 <xerox> Does it apply to GHC too that Main.main is the one in IO ?
13:21:46 <ndm> xerox: i think so yes, thats the spec of haskell 98
13:21:52 <oopsI> lol
13:22:04 <oopsIdidItAgen> hi
13:22:05 <oopsIdidItAgen> hi
13:22:09 <dmhouse> oopsIdidItAgen: Hehe, hi :)
13:22:17 <oopsIdidItAgen> dudesIm so sick of java
13:22:22 <oopsIdidItAgen> I wana blow my head off
13:22:24 <dmhouse> How's Haskell treating you?
13:22:27 <shapr> ?
13:22:37 <oopsIdidItAgen> Im a linux admina dn java jsut seems poorly documented croproate rcrap not deisnged to be ez
13:22:57 <xerox> Are you applying some type of sourcefilter to your writings? (%
13:22:58 <oopsIdidItAgen> liek thefocus is not on getting stuff done but blah blah frameowrk and api ana java specs which arent open
13:23:02 <oopsIdidItAgen> well
13:23:07 <oopsIdidItAgen> I dont know crap about haskell
13:23:17 <oopsIdidItAgen> excet that lisp adn smalltalk rooms say its dope
13:23:27 <oopsIdidItAgen> and lisp smalltalk and ahskella re suppoed to be 3 best alngs arund
13:23:33 <oopsIdidItAgen> it seems
13:24:54 <oopsIdidItAgen> we are bringing in jboss and a corprate schedulaer at my work
13:24:57 <oopsIdidItAgen> and use nagios
13:25:01 <oopsIdidItAgen> its all kinda hellish
13:25:37 <shapr> ookay
13:25:58 <shapr> So you want to learn Haskell so that you can write better software?
13:26:02 <oopsIdidItAgen> yes
13:26:07 <oopsIdidItAgen> and open my own practice
13:26:09 <oopsIdidItAgen> get rich
13:26:10 <oopsIdidItAgen> get women
13:26:20 <oopsIdidItAgen> and fel lie i did something a bit different but something smarter
13:26:52 <ndm> if you want to get women, spending lots of time at a computer rarely helps :)
13:27:07 <shapr> Truly
13:27:39 <erider> hello all
13:28:33 <shapr> hi
13:30:02 <Korollary> #lisp says haskell is dope? Interesting.
13:30:23 * dmhouse wonders whether that's a compliment or not
13:30:29 <ValarQ> Korollary: the channel in itself?
13:30:58 <oopsIdidItAgen> well
13:31:09 <oopsIdidItAgen> Im actaulyl kicked from lisp perl python tcl and scheme
13:31:18 <oopsIdidItAgen> because I ask too many questions
13:31:32 <oopsIdidItAgen> see some say use a langauge that a been in use liek perl
13:31:40 <oopsIdidItAgen> because it is battle hardened
13:31:47 <oopsIdidItAgen> some say herd mentality hurts you
13:32:16 <oopsIdidItAgen> some say popularity measn something si good
13:32:21 <oopsIdidItAgen> best indicator
13:32:24 <oopsIdidItAgen> I dont know
13:32:50 <dmhouse> It has ups and downs.
13:33:01 <ndm> @learning
13:33:01 <lambdabot> Unknown command, try @list
13:33:04 <ndm> @learn
13:33:05 <lambdabot> http://www.haskell.org/learning.html
13:33:06 <dmhouse> Haskell doesn't have a lot of 'practical' experience, relatively speaking.
13:33:13 <notsmack> oopsIdidItAgen: what languages do you know?
13:33:23 <ndm> you should probably go and read all the stuff on that learning page, to learn haskell
13:33:27 <dmhouse> On the other hand, Perl's debatebly too popular. There are ten modules for each task, which helps no-one.
13:33:32 <madpickle> a good book helps, too
13:33:33 <Korollary> oopsIdidItAgen: Do you already have, or are you working towards a degree in computer science?
13:33:55 <madpickle> that, and having an objective
13:34:03 <madpickle> if you're gonna doodle around, learning any language can be tricky
13:42:55 <tennin> "are you now or have you ever been..."
13:43:59 <stepcut> dmhouse: ten *broken* modules at that :p
13:44:36 <dmhouse> stepcut: quite. :)
13:46:25 <stepcut> besides, being broke and unhappy is quite popular -- but I wouldn't recommend that either
13:52:35 <Ulfalizer> what's the "right" way to convert a string value to a port number that you pass to Network.connectTo? none of connectTo "www.foo.com" (read "80" :: x) with x = PortID, PortNumber, Int, Integer work.
13:53:01 <ndm> @type Network.connectTo
13:53:03 <lambdabot> Network.BSD.HostName -> Network.PortID -> IO GHC.IOBase.Handle
13:53:18 <ndm> @hoogle Int -> PortID
13:53:19 <lambdabot> No matches, try a more general search
13:53:24 <ndm> @info PortID
13:53:24 <lambdabot> Unknown command, try @list
13:53:36 <ndm> @docs Network
13:53:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
13:54:26 <ndm> @hoogle a -> PortID
13:54:27 <lambdabot> No matches, try a more general search
13:54:57 <ndm> Service String	
13:54:58 <ndm> PortNumber PortNumber	
13:55:00 <ndm> UnixSocket String	
13:55:22 <ndm> Ulfalizer: those are the 3 contructors above, so use one of them
13:55:30 <ndm> UnixSocket "string" might work
13:56:16 <Ulfalizer> ndm: ops, i'm already using the PortNumber constructor, just forgot it in the example
13:56:42 * Ulfalizer looks into UnixSocket
13:57:46 <Korollary> Ulfalizer: read the string as an int, and use fromIntegral?
13:58:06 <Ulfalizer> ndm: i couldn't find where the PortNumber type is defined. there must be some conversion path to it from Num though, since connectTo "www.foo.com" (PortNumber 80) works.
13:58:31 <Ulfalizer> Korollary: ah, had forgotten about fromIntegral
13:58:46 <ndm> :t PortNumber
13:58:51 <ndm> @type PortNumber
13:58:53 <lambdabot> Not in scope: data constructor `PortNumber'
13:58:56 <ndm> @type Network.PortNumber
13:58:58 <lambdabot> Network.Socket.PortNumber -> Network.PortID
13:59:09 <Ulfalizer> ndm: that gives me the constructor :/
13:59:23 <ndm> @type Network.Socket.PortNumber
13:59:24 <lambdabot> Not in scope: data constructor `Network.Socket.PortNumber'
14:00:06 <Korollary> @djinn Int -> Network.PortNumber
14:00:07 <lambdabot> -- f cannot be realized.
14:01:28 <Korollary> @type Network.PortNumber . fromIntegral
14:01:29 <lambdabot> forall a. (Integral a) => a -> Network.PortID
14:01:53 <Korollary> @djinn Int -> Network.PortID
14:01:53 <lambdabot> -- f cannot be realized.
14:02:11 <Korollary> @djinn (Integral a) => a -> Network.PortID
14:02:11 <lambdabot> Cannot parse command
14:02:26 * Korollary gives up supernatural entities.
14:02:37 <Korollary> +on
14:07:05 <Ulfalizer> newtype PortNumber = PortNum Word16
14:07:51 <Ulfalizer> ah, found an internal intToPortNumber in there as well..
14:08:12 <Ulfalizer> intToPortNumber v = PortNum (htons (fromIntegral v))
14:10:08 <Ulfalizer> too bad htons is internal as well..
14:12:05 <oopsIdidItAgen> I have an econ degree from ucla
14:12:07 <oopsIdidItAgen> no comp sci
14:12:09 <oopsIdidItAgen> :(
14:13:48 <vincenz> DAMN
14:17:42 <hellish> Is there any way to profile a program that doesn't terminate?
14:18:30 <Igloo> Profiling with GHC should produce output even if you ^C or whatever
14:20:31 <hellish> hmm...
14:21:46 * Ulfalizer still doesn't understand how the conversion to PortNumber happens for the constructor argument in PortNumber 123
14:22:05 <Ulfalizer> PortNumber as in the type of the constructor argument that is, not as in the name of the constructor (they're the same)
14:25:22 <Ulfalizer> or rather, what i don't understand is how you're supposed to get a non-literal there without messing around with internal types
14:25:37 <oopsIdidItAgen> hm
14:27:21 <Ulfalizer> ah, PortNumber (fromIntegral (read "123")) works
14:27:27 <Ulfalizer> now i just need to understand why :/
14:27:49 <dmhouse> @hoogle PortNumber
14:27:50 <lambdabot> Network.PortNumber :: PortNumber -> PortID
14:27:50 <lambdabot> Network.PortNumber :: data PortNumber
14:27:50 <lambdabot> Network.Socket.PortNumber :: newtype PortNumber
14:27:54 <kpreid> PortNumber is a confusingly named function, I'd say
14:28:07 <kpreid> it's evidently a constructor for PortID
14:28:26 <dmhouse> It's both a type and a constructor for a PortID.
14:28:28 <Ulfalizer> plus it's the type of the argument to the PortNumber constructor
14:29:14 <Ulfalizer> pretty confusing, imho. i would've given them different names..
14:30:34 <Buzzons> random qu, whats the command for a new line "\n" doesnt seem to work, it just outputs "\n" (as a string)
14:30:48 <dmhouse> Buzzons: it should work.
14:30:54 <dmhouse> Buzzons: paste some code.
14:30:59 <Buzzons> k sec
14:31:00 <ihope> putStr "\n" or putStrLn "".
14:31:06 <ihope> Were you doing print "\n"?
14:31:15 <Buzzons> was just adding it to the end of a line as "\n"
14:31:23 <Buzzons> eg here
14:31:25 <Buzzons> hash ((a,b):xs) = (a ++ "   "  ++  box(b)): hash xs
14:31:29 <Buzzons> i wanted sommit like
14:31:36 <Buzzons> hash ((a,b):xs) = (a ++ "   "  ++  box(b) "\n" ): hash xs
14:31:52 <dmhouse> You'll need to use the concatenation operator, ++ again.
14:32:03 <Buzzons> yea i did that before and got
14:32:03 <Buzzons> ["moo   ###\n","wee   ####\n"] :: [String]
14:32:10 <dmhouse> By the way, function application in Haskell doesn't use parentheses, normally.
14:32:11 <Buzzons> it didnt break it to a new line
14:32:32 <dmhouse> Ah.
14:32:55 <dmhouse> They are there, but when GHCi shows you the results, it converts the newlines to "\n"s.
14:32:57 <ihope> Buzzons: try leaving out the newline at the end, and using mapM putStrLn to print the list out.
14:33:09 <Buzzons> ya wha?
14:33:12 <Buzzons> <-- noon
14:33:14 <Buzzons> *noob
14:33:38 <kpreid> Buzzons: try this: mapM_ putStrLn ["a", "b", "c"]
14:34:01 <Buzzons> oo that works, thanks :)
14:34:06 <Buzzons> *runs off to do more haskelling*
14:34:28 <Ulfalizer> is fromIntegral for converting integrals to other types in Num that possibly aren't in the Integral class?
14:34:40 <dmhouse> Exactly.
14:34:41 <kpreid> Buzzons: also: putStr "a\nb\nc\n"
14:34:46 <Ulfalizer> ok
14:35:08 <dmhouse> Or putStr (unlines ["a", "b", "c"])
14:35:18 <oopsIdidItAgen> qwell
14:35:20 <oopsIdidItAgen> well
14:35:21 <oopsIdidItAgen> well
14:35:23 <kpreid> Buzzons: when you just write an expression, the result is always quoted (using 'show')
14:35:45 <oopsIdidItAgen> how do i do onitoring scheduling and error checking in haskell if i want to trade dataa with parners using text files?
14:51:58 <petekaz> wow .. dunnocomloolump really jumped up in the scoreboard taking down the lazy bottoms.
14:52:24 <petekaz> still can't believe 'team smartass' is #1.
14:52:56 <hellish> what do the parenthetical numbers mean in a hp2ps output?
14:54:21 <ihope> Team Smartass?
14:54:32 <stepcut> ihope: java programmers :(
14:54:36 <stepcut> :p
14:54:41 <petekaz> hellish: no idea, just started to learn FFI.
14:54:59 <petekaz> stepcut: that's a joke I hope.
14:56:18 <stepcut> petekaz: http://icfpc.cs.uchicago.edu/teams/138.html
14:56:19 <lambdabot> Title: ICFP 2005 Contest - Team Smartass
14:56:51 <petekaz> oh boy ... this is embarrassing.
14:57:58 <petekaz> maybe their IDEs have finally made up for the shortcomings in the language.
14:58:16 <edwardk> not sure anyone will be able to take their lead away, the only contest tey don't have the highest score in is circs and thats by 3 points. they've pegged everything else.
14:59:04 <edwardk> heh
14:59:14 <petekaz> maybe we can hope for a tie?
15:00:09 <edwardk> tie will be broken by who got the score first
15:00:40 <petekaz> well, you better get crackin then!
15:01:09 <edwardk> heh, not playing this year =)
15:01:51 * _Codex 's team got 71 points. (real points are difficult to find :)
15:01:58 <petekaz> oh, for some reason I thought I saw your name earlier in reference to it.
15:02:51 <edwardk> i slapped together a UM when when I was fed up with my work this weekend so i could play with the codex, but had/have no intent of actually competing
15:07:15 <Ulfalizer> i'm writing an irc bot that will use an output function that keeps track of how much text is written, to avoid flood attacks. this function will be called from many different places and has state associated with it (e.g. the number of characters written per second during the last minute). what would be a sensible implementation? could i use a state monad?
15:07:36 <ndm> Ulfalizer: why not just an IORef?
15:07:43 <Ulfalizer> ndm: what's that?
15:07:50 <ndm> @docs Data.IORef
15:07:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
15:07:54 <dmhouse> An IORef might be cleaner here.
15:07:56 <ndm> Ulfalizer: a mutable variable
15:07:59 * Ulfalizer looks into it
15:09:10 <edwardk> Anyone here read much about pure type systems?
15:09:18 <dmhouse> edwardk: Want to ask your question?
15:09:21 <dmhouse> In fact,
15:09:22 <edwardk> heh
15:09:26 <dmhouse> > return "Ask" :: Maybe String
15:09:27 <lambdabot>  Just "Ask"
15:10:01 <Ulfalizer> ioref is just what i need. thanks for the tip!
15:10:09 <_Codex> edwardk: I've read the chi paper.
15:10:31 <edwardk> well, i'm presently playing with extending a pure type system to cover the unrestricted, relevant, affine, and linear types (and references) from the lambda refURAL calculus, but I am not too fond of the 'pretype' approach the URAL folks use.
15:10:51 <edwardk> so its not so much a question as looking for ideas and a sounding board =)
15:12:18 <dmhouse> As we ran the twist playoffs, we realized that the results were far too sensitive to the pod selection (and, apparently, the random number seeds). So, instead of running the playoffs as advertised, we randomly picked sets of six entries and put them together in pods. We then tracked the average place (one thru six) of each entry across these pods and when the averages settled down, we picked the three entries that had the 
15:12:26 <dmhouse> err
15:12:27 <dmhouse> Oops :)
15:12:33 <edwardk> last year's icfp contest?
15:12:37 <dmhouse> Hehe, yep.
15:12:47 <_Codex> edwardk: from what I've read, the main thing in pure type systems is strong normalisation -- all systems in the lambda cube are strongly normalising.
15:13:05 * edwardk nods.
15:13:44 * dmhouse accidentally middle-mouse pasted
15:13:57 <dmhouse> If you touch the edge of my touchpad it counts as a middle-mouse click.
15:14:17 <dmhouse> I had one of those moments where I though 'Wow, someone posted a lot, I wonder who it was? Oh, it was me. Aha.'
15:14:26 * sieni accidentally spanks dmhouse
15:15:48 <edwardk> I accept the fact all lambda cube implementations have some computable functions they can't generate, etc. mostly interested the pure type system side of thing from its clean generalization of the properties of the lambda cube.
15:16:07 <edwardk> and because it seems that the URAL types plugin in nicely as sorts in a pure type system.
15:16:25 <edwardk> leading to a very clean set of semantics
15:17:39 <edwardk> need to finish working out the semantics though, because i haven't covered all the corner cases, and if the size of the refURAL tech report is any indication, that can take up a lot of space (IIRC its like 200 pages)
15:23:50 <petekaz> Are there any FFI tutorials available?
15:23:59 <petekaz> I have not been able to find any yet.
15:24:06 <dmhouse> Try the wiki(s)
15:24:28 <ndm> @wiki Wc
15:24:29 <lambdabot> http://www.haskell.org/haskellwiki/Wc
15:24:36 <petekaz> I can't find anything on the wikis.  I tried the new one, haven't tried the old one yet.
15:24:39 <ndm> petekaz: i learnt from that page, the very basics
15:25:23 <dmhouse> petekaz: try searching the mailing lists too.
15:25:24 <petekaz> ok. thanks. I just want to write a simple library of one function to verify how -threaded RTS works.
15:31:18 <petekaz> looks like team smartass just got top score on all of the categories.
15:32:05 <edwardk> there does their touchability
15:32:07 <edwardk> er goes
15:32:30 <luke-jr_> #c++ is pretty funny
15:32:35 <luke-jr_> they're all promoting Haskell
15:32:37 <edwardk> unless someone can duplicate that and find a bug or two in the um =)
15:32:38 <edwardk> heh
15:33:00 <edwardk> luke: how'd it come up?
15:33:18 <luke-jr_> edwardk: someone said they wanted to learn C++
15:33:23 <edwardk> ah
15:33:37 <petekaz> Based on ICFP results, its clear I should go learn Java instead of Haskell :-)
15:33:44 <edwardk> hehehe
15:33:49 <petekaz> (unfortunately, I already know Java)
15:33:54 <luke-jr_> ICFP?
15:34:04 <edwardk> now we just need to bribe Team Smartass to choose 'haskell' as their language ;)
15:34:08 <edwardk> its really much easier this way =)
15:34:18 <luke-jr_> I'm about to choose C over C++
15:34:24 <luke-jr_> because C++ sucks compared to C
15:34:26 <luke-jr_> but anyhow...
15:34:43 <edwardk> luke: heh, you'll learn ;) c++ is a much better language for programming in the large i think.
15:34:51 <luke-jr_> edwardk: doesn't seem to be
15:35:06 <luke-jr_> I mean, it has a few nice things
15:35:18 <luke-jr_> but the overhead from writing code to use classes instead of structs/unions isn't worth it
15:35:30 <int-e> You don't have to use all the nasty features C++ has - some are actually useful.
15:35:33 <edwardk> I find references remove a lot of misc. pointer errors. Explicit classes obviate the need to write your own vtable kind of structures. Templates prevent the need to rewrite code.
15:35:45 <edwardk> there is a lot going for C++
15:35:52 <luke-jr_> int-e: no, but if you don't, you're writing C not C++ there
15:36:05 <int-e> luke-jr_: C with templates. My favourite.
15:36:11 <edwardk> and the lack of templates is why i don't write c. =)
15:36:14 <edwardk> heh
15:36:24 <luke-jr_> templates is what #c++ were telling me is my solution
15:36:33 <luke-jr_> but the examples for templates don't make sense
15:37:02 <edwardk> templates can be very complicated. its best to start small and not dive into something like the standard template library until you are good and ready.
15:37:06 <luke-jr_> all I wanted to do was make a bunch of subclasses and switch() between them =p
15:37:31 <tony2> What language is team smartass using?
15:37:48 <dmhouse> tony2: last year a team named exactly the same used Java
15:38:00 <edwardk> you have no typeswitch in c++. you really should use a single template function and then use a 'partial template specialization' for the cases that needto be handled differently
15:38:07 <tony2> no, oh no.
15:38:25 <luke-jr_> edwardk: all the cases need to be handles differently ;)
15:38:30 <edwardk> tony: yeah, looks like we're doomed to a year of java-junkies lording it over us =)
15:38:34 <luke-jr_> handled*
15:38:49 <luke-jr_> the classes are AST expressions
15:39:02 <Philippa> unions are your friend
15:39:16 <luke-jr_> Philippa: but the other guys in the project want C++, not C :(
15:39:17 <Philippa> it's that, or muck around with the visitor pattern
15:39:19 <edwardk> luke-jr: template <typename Foo> Foo method(whatever...., Foo bar) {} ... then write instances of int method(whatever...,int) {}    char method (whatever... char) {} etc.
15:39:31 <Philippa> that's fine, C++ has unions too :-)
15:39:38 <luke-jr_> edwardk: eh?
15:39:46 <Philippa> none of the alternatives're actually any prettier when it comes to ASTs
15:39:46 <edwardk> luke-jr: fun. a union type or a boost::variant is probably the right solution
15:40:06 <hellish> How does one make a record strict? data myRec = !myRec {...} and data myRec = myRec {!foo :: Int} and data myRec = myRec {foo :: !Int} all fail with syntax errors.
15:40:14 <Philippa> point, how ugly's boost::variant? Last time I was actually writing serious C++ (OK, ignoring last night) was some time ago
15:40:23 <luke-jr_> Philippa: isn't union technically C compatibility?
15:40:24 <edwardk> boost::variant can yield pretty decent code in that scenario, but thats a bit of jumping into the deep end of the pool.
15:40:43 <edwardk> luke: yes unions are in c.
15:40:47 <luke-jr_> edwardk: so I should tell the other guy to STFU and use unions? =p
15:41:25 <dmhouse> Philippa: are you doing the ICFP contest?
15:41:45 <edwardk> luke: personally i avoid unions like the plague becuase you need to disambiguate the type in them somehow anyways, so you wind up wrapping them in a struct of some sort in the AST scenario
15:41:57 <edwardk> and its just a lot of chances for your code to go wrong.
15:42:28 <edwardk> luke: an arguably better solution is to really just USE c++ for what its good at
15:42:43 <edwardk> luke: and make a base class for an AST node, and then subclass it for terms, expressions, etc.
15:43:00 <luke-jr_> maybe I should use a class encapsulating the union and have all the code dealing directly with the union in the class...?
15:43:13 <luke-jr_> edwardk: then I need the AST=>bytecode compiler to typeswitch...
15:43:36 <edwardk> if you want to dispatch something differently per node you can either throw a method in each subclass or do it with a visitor pattern.
15:43:57 <edwardk> luke: classes generally obviate the need for union types when used correctly
15:44:32 <luke-jr_> so make the compiler code be part of the AST class?
15:44:36 <Philippa> dmhouse: I had a go yesterday, didn't get UMIX running, had a friend coming round today
15:44:47 <edwardk> luke: exactly
15:44:58 <edwardk> like: or you can decouple it by looking up how to do visitors.
15:45:13 <edwardk> luke: but that might seem a little circular to you at this stage
15:45:52 <edwardk> whee, team smartass cranked up their circs score even higher now =)
15:47:10 <sylvan> edwardk, I wonder what they're doing wrong. Java isn't supposed to be good!
15:47:17 <edwardk> sylvan: heh
15:47:33 <edwardk> sylvan: they must have bought into all that J2EE J2ME, etc marketing crap.
15:47:43 <edwardk> its like when a cartoon runs off a cliff and forgets to look down.
15:47:53 <sylvan> =)
16:09:20 <Korollary> team smartass are using java?
16:09:31 <edwardk> its a pretty safe bet
16:09:39 <Korollary> based on what?
16:09:49 <edwardk> last year that was their language.
16:09:52 <Korollary> ah
16:09:58 <edwardk> presuming its the same team smartass
16:10:06 <Korollary> how did they do last year?
16:10:25 <edwardk> didn't check
16:11:17 <Korollary> What is this year's problem about?
16:12:04 <_Codex> korollary: there's several problems, including writing a vm, and ants and raytracing; things like that.
16:12:05 <edwardk> you need to decode some ancient computational codex written for a strange universal machine
16:12:24 <edwardk> then you have to  solve a bunch of puzzles that are in the codex.
16:12:51 <edwardk> fairly imaginative
16:13:09 <_Codex> the organizers did really lots of work to pull all this up.
16:14:51 <_Codex> this year was considerably more things to do than in previous years. (more separate problems)
16:15:11 <edwardk> at least it gives you a reason to have a team
16:15:21 <edwardk> previous years not so much
16:16:55 <_Codex> actually, the beginning of the this years problem was specifically designed so that it takes long time even with a big team (one person can do it at the time etc.)
16:17:08 * edwardk nods..
16:17:39 <_Codex> but once the vm was ready, lots of possibilities for a big team appeared.
16:18:27 <edwardk> i suppose we can hope that team smartass has more than 4 members =)
16:18:36 <_Codex> which means that if there is problems with vm, even big team might spend lots of time...
16:18:47 <Korollary> it doesnt make a difference
16:18:56 <edwardk> kor ?
16:18:56 <_Codex> edwardk: so that they cannot win the first price, you mean?
16:18:59 <edwardk> yeah
16:19:05 <Korollary> oh
16:19:22 <Korollary> Well, that still doesn't spoil anything.
16:24:27 <Philippa> edwardk: yeah, trying single-handedly sure didn't help me
16:24:37 <edwardk> phillipa: fair nuff
16:24:56 <Philippa> though tbh, if I can't have a working VM with > 12 hours' hacking done, I should give up anyway
16:25:10 <edwardk> i spent long enough to slap together a VM, but didn't do anything after that.
16:25:55 <edwardk> i just registered so i'd have a key and could play with it on my own time
16:26:31 <edwinb> I registered then lost inspiration on Friday evening...
16:26:36 <edwardk> heh
16:26:39 <edwinb> I guess having a team helps because then you can't give up so easily ;)
16:26:49 <edwardk> heh
16:27:18 <Korollary> what kind of a vm is it that it takes so long to be slapped together?
16:27:40 <dons> good morning #haskell!
16:27:45 <edwardk> kor: its a littlle funny, because you basically malloc groups of instructions and it can do lots of self modifying code tricks
16:27:46 <Korollary> hey dons
16:27:49 <_Codex> we got vm done too, but then didnt do much of the additional problems. just enough to browse through (almost) all problems.
16:27:52 <edwinb> it didn't look so hard to make the VM, but then I assumed that once it worked I'd find out all sorts of exciting new problems to solve...
16:28:00 <edwardk> the vm itself is pretty trivial
16:28:01 <bolrod> oeh.. dons is going to play DJ on #haskell ?
16:28:20 <dons> heh
16:28:29 <bolrod> Good morning Vietnam!
16:28:37 <_Codex> (well, we got 71 points in the score table)
16:28:39 <bolrod> *Yawn*
16:28:55 <dons>  rec X.not(X) ?
16:28:59 <_Codex> yep
16:29:07 <dons> :)
16:29:44 <_Codex> almost everyone else got 200 points from intro :)
16:29:45 <edwardk> i have to admit its the first contest they've had in years that even piqued my interest =)
16:29:56 <dons> its quite a cool puzzle.
16:30:06 <dons> and the incremental scoring system is very rewarding
16:30:11 <edwardk> yeah
16:30:14 <dons> it should be a standard for future years
16:30:16 <_Codex> edwardk: that's because the organizers have done lots of work to make it work
16:30:17 <Philippa> Korollary: the VM doesn't look that hard, but I'm managing subtle bugs nevertheless. Plus it runs like crap written in Haskell so about 9pm last night I shifted to C++
16:30:21 <dons> (no waiting 6 months for them to tabulate the winners)
16:30:26 <edwardk> but i think its also made it so that no one even wants to try with the way things are with team smartass
16:30:40 <_Codex> philippa: we did it in haskell too, and it runs pretty ok
16:30:43 <Philippa> yeah, I liked the scoring system - do kinda feel sorry I didn't get to muck around with UMIX
16:31:03 <Philippa> _Codex: what kind of instruction rate? I was getting a couple of MHz on a mid-speed P4
16:31:03 <_Codex> philippa: though had to change data structures from maps to uarrays etc.
16:31:10 <Philippa> yeah, IOUArrays here
16:31:15 <edwardk> heh, as team smartass squeaks out another 3 points
16:31:18 <dons> Philippa: we've got about 400 lines of haskell for the machine, btw.
16:31:54 <Philippa> I ended up with about that many too, though there's half an unnecessary debug harness in there as well
16:32:06 <Philippa> (half in that I never wrote the code to serialise the VM state)
16:32:21 <_Codex> philippa: I dont know instruction rate... More worrying than speed is the memory allocations taking all mem and it starts swapping..
16:32:26 * edwardk is sitting on 130 lines of c++.
16:33:12 <Philippa> about 200 here, but some of that was linecount-increasing factoring to avoid typos
16:33:18 <_Codex> especially when running qbasic, it would freeze in the middle for about 20 seconds etc.
16:33:22 * edwardk nods.
16:33:43 <Philippa> I never got to the point of running UMIX - the codex didn't need that much memory
16:34:02 <liyang> (So, AngloHaskell... what exactly is on the agenda?)
16:34:12 <Philippa> beer, Go, unicycling...
16:34:15 <Philippa> oh, and some programming language
16:34:26 <Philippa> it's a meet rather than a conference or a workshop
16:34:38 <sylvan> AngloHaskell?
16:34:40 <edwinb> are you coming liyang?
16:34:42 <liyang> For two days straight?
16:34:44 <liyang> o.O
16:34:50 <liyang> edwinb: yes. =)
16:35:06 <edwinb> anyone else from Nottingham?
16:35:11 <Philippa> nobody says you have to be there for all of it - but in practice a lot of people'll miss working hours friday, it was really intended to be pubbage after work friday and maybe code the saturday
16:35:16 <Philippa> me, though I'm not really at the uni
16:35:16 <edwinb> I'm using it as an excuse for a weekend away ;). Not that I need one...
16:35:33 <liyang> I need to pick up a few items from my ex-flat in Cambridge as well as catch up on some acquaintances and this is the perfect excuse. :)
16:35:36 <sylvan> @where AngloHaskell
16:35:37 <lambdabot> http://haskell.org/haskellwiki/AngloHaskell
16:35:41 <Philippa> heh, fair enough
16:36:15 <Philippa> I'll have to see friends there another day, but that happens
16:36:23 <sylvan> bah, I'm moving the UK the day after :-)
16:36:40 <u221e> Wow... ghc takes a long time to compile.
16:37:09 <u221e> I could do a full build of a gentoo system before it finished.
16:37:13 <edwardk> u221e: yeah you might want to take a nap =)
16:37:14 <liyang> Do we have any concrete plans whatsoever? I mean, even mundane things like ``where am I going to find a power socket for my laptop''...
16:37:31 <u221e> edwardk, I did... it's done now ;P
16:37:34 <Philippa> I think (but could be wrong) that MSR were providing some space on the friday. Nobody's nominated a pub yet AFAIK
16:37:38 <edwinb> Pub. Beer. Go. Unicycling. Seems pretty concrete ;)
16:37:53 <edwinb> we can evaluate them to head normal form as required.
16:38:02 <Philippa> I'll drag a couple of games along that're less involved than Go
16:38:09 <Philippa> at least, if I remember
16:38:20 <liyang> (Please do. I'm so not a go player.)
16:38:32 <Philippa> if anyone wants to bring a pack of cards we could see how long it takes to turn the Chairman's game turing complete...
16:38:48 * dons begins 16 hack towards the finish
16:42:54 <dons> heh, funny seeing how activity on this channel dried up in the last two days, http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html
16:42:58 <lambdabot> Title: #haskell @ freenode.org stats by dons
16:45:27 <stepcut> the yellow bar seems to have stayed the steadiest
16:46:25 <dons> i think that's night in europe
16:46:29 <dons> maybe
16:47:37 <Korollary> "lambdabot also makes sailors blush, 0.0% of the time."
16:48:02 <edwardk> yeah but that 0.01% is a doozy ;)
16:48:13 <dons> something that either vixen or yow said
16:48:22 <edwardk> @yow
16:48:23 <lambdabot> My life is a patio of fun!
16:48:25 <edwardk> @yow
16:48:25 <lambdabot> My polyvinyl cowboy wallet was made in Hong Kong by Montgomery Clift!
16:48:30 <edwardk> @vixen
16:48:31 <lambdabot> i enjoy talking to you
16:48:39 <edwardk> ah, no luck raising her % =)
16:50:03 <dons> ?. vixen yow
16:50:04 <lambdabot> there is nothing going on in your pants that the dictatorship of the proletariat will not solve
16:50:07 <dons> close
16:50:11 <dons> ?. vixen yow
16:50:12 <lambdabot> i love fun
16:50:23 <dons> just have @yow talk to @vixen, they get on just fine
16:50:27 <edwardk> heh
16:50:32 <stepcut> I got up at 2 or 3am once, and all these scary people I didn't know were talking :p
16:50:40 <edwardk> @. elite palomer
16:50:41 <lambdabot> hrmf
16:50:44 <dons> stepcut: heh
16:51:08 <edwardk> @. vixen palomer
16:51:08 <lambdabot> wanna hear a story?
16:51:29 <dons> you can really see how lambdabot never sleeps (one of the few such nicks)
16:51:31 <dons> the other is vincenz
16:51:45 <edwardk> heh
16:52:31 <u221e> Hey dons, how would a create something like the C++ vector that I could insert and delete elements from?
16:52:43 <dons> how about a Data.Map or Data.IntMap?
16:52:52 <dons> failing that, a Data.HashTable?
16:53:14 <edwardk> after that there are some sequence types inside of pugs you could borrow that are bsd licensed.
16:53:22 <edwardk> that have the right semantics iirc
16:53:45 <u221e> Data.Map?
16:53:58 <Korollary> Hmm, a typed, pure and strict fp: http://uebb.cs.tu-berlin.de/~opal/
16:54:00 <lambdabot> Title: The OPAL Home Page
16:54:01 <dons> ?hoogle Data.Map
16:54:02 <lambdabot> No matches, try a more general search
16:54:06 <dons> ?docs Data.Map
16:54:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
16:54:07 <Pseudonym> There's also the Edison sequences.
16:54:21 <dons> ah right. those too.
16:54:36 <dons> but u221e, you should learn Data.Map, its one of the most often-used structures
16:54:44 <Pseudonym> Yup.
16:54:45 <dons> and IntMap is similar, but better if you have Int keys
16:55:24 <u221e> I don't readdy want key/value pairs... I just want a buffer of strings that I can insert a string and delete a string.
16:55:37 <Pseudonym> Like a stack?
16:55:39 <Pseudonym> Or a queue?
16:55:47 <Pseudonym> Oh, I see.
16:55:51 <Pseudonym> Well, you can Map Strings to ()
16:56:13 <Pseudonym> There's also Data.Set
16:56:19 <dons> ?docs Data.Set
16:56:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
17:00:00 <u221e> dons: finish your icfp entry yet? ;)
17:03:09 <dons> heh
17:09:31 <Korollary> What good does gzip compression do for shootout entry sources?
17:12:08 <edwardk> shootout entry?
17:12:22 <edwardk> great language, nevermind
17:12:28 <shapr> Korollary: It's a cheesy way to measure cyclomatic complexity.
17:12:48 <shapr> Probably effective though.
17:13:31 <shapr> Non cheesy would require that you have a parser for every language and then agree on a way to calculate the complexity of syntax trees.
17:13:46 <edwardk> its a cute trick
17:13:46 * ptolomy tried to make an improved measure (based on my own sense of visual complexity) a few months back.
17:13:57 <ptolomy> Wasn't impressively better.
17:14:12 <shapr> One paper that talks about this is "Are ours really smaller than theirs?"
17:14:23 <ptolomy> link?
17:14:32 <SamB> shapr: is it really such a cheesy way?
17:14:33 <shapr> @google Are ours really smaller than theirs? haskell
17:14:36 <lambdabot> http://www.cs.stir.ac.uk/~kjt/techreps/pdf/TR141.pdf
17:14:54 <shapr> SamB: The high end of cheesy hacks wraps around to the bottom end of elegance. I think it's both.
17:15:00 <SamB> heh
17:15:03 * ptolomy needs to be better about his policy of "Google first, ask questions later."
17:15:40 <SamB> so is it supposed to be good if the code doesn't compress well?
17:15:58 <edwardk> its kind of like using gzip as a poor man's bayesian filter for spam. its easy to do, close to  right, and you aren't going to get much better without having a fight on your hands =)
17:16:32 <Pseudonym> SamB: I would think that equally expressive languages would compress to roughly the same size.
17:17:15 <Pseudonym> So, for example, "begin" and "end" in Wirth languages would compress to roughly the same space as "{" and "}" in C-style languages.
17:17:59 <Pseudonym> Though I wonder if this would bias in favour of or against languages where indentation is important.
17:18:24 <Korollary> I ask because compression also hides languages with a lot of repetition.
17:18:34 <Pseudonym> That's true.
17:18:35 <edwardk> x many spaces after a carriage return and a ; are comparable by the same logic
17:18:59 <Pseudonym> Some languages seem to waste characters in certain scenarios.
17:19:01 <edwardk> you still have a few more cases, but its not so bad.
17:19:04 <edwardk> heh
17:19:04 <Pseudonym> e.g. Haskell and arrays. :-)
17:19:09 <edwardk> go design one for gzipping =)
17:19:16 <edwardk> win the great language shootout =)
17:19:34 <Pseudonym> AP/L is already Huffman encoded.
17:20:18 <u221e> What does the Reader monad do?
17:20:30 <Philippa> one thing I do like about haskell is it's rare you catch it seriously wasting tokens as opposed to characters
17:20:32 <ptolomy> I bet BF gzips well..
17:20:52 <Pseudonym> ptolomy: No doubt, but BF programs are verbose to begin eith.
17:20:55 <Pseudonym> with
17:21:00 <Cale> u221e: It lets computations read from an environment to be provided later
17:21:07 <Philippa> it's rarely actually harder to read than the character-concise alternatives, although there're some cases involving monadic code with lots of dependencies that'd be written as expressions in an impure lang
17:21:14 <Pseudonym> Philippa: I agree.
17:21:30 <Pseudonym> The problem with arrays is actually that all the good operators were already taken.
17:21:37 <Cale> > (do x <- (+1); y <- id; return (x + y)) 50
17:21:38 <lambdabot>  101
17:21:54 <Korollary> Identifiers in Java's standard libraries are quite more verbose than those of ml's
17:22:07 * ptolomy has always considered non-imperative-simulating and non-io Haskell to code to be "profound". 
17:22:20 <Pseudonym> public final void lossage iAgree();
17:22:50 <Philippa> Korollary: yeah, Java has a serious case of having to recombine by hand
17:22:55 <edwardk> heh, came here to start coding up my javascript implementation. the more i write in haskell the more i just want to write haskell =)
17:22:57 <Philippa> and then name the identifiers correspondingly
17:23:08 <edwardk> the javascript implementation is secondary. gives me a reason to write haskell =)
17:23:35 * Pseudonym has that problem too
17:23:36 <u221e> printf is weird.
17:23:47 <Philippa> ptolomy: some of the imperative-simulating stuff can be too, especially when it uses a slightly different model to the norm. If we had subtyping or row polymorphism, Haskell would be *wonderful* for OO
17:23:48 <ptolomy> Pseudonym: Heh. Yeah, I just did a test gzip of some large-ish BF code. It compresses down to about 10%, but it is still larger compressed than an equivalent ____ program.
17:23:50 <Pseudonym> Writing Haskell is so interesting by itself that I often don't get what I want to do actually done.
17:24:04 <Pseudonym> ptolomy: Try bzip.
17:24:05 <Korollary> Pseudonym: That ought to delight project managers :)
17:24:08 <ptolomy> I wish I knew what row polymorphism was.
17:24:09 <Pseudonym> Just as a matter of curiosity.
17:24:11 * ptolomy googles.
17:24:25 <Pseudonym> Korollary: Just as well I don't get paid to do Haskell.
17:24:38 <SamB> @hoogle Data.IntMap.IntMap a -> Int -> a
17:24:39 <lambdabot> No matches, try a more general search
17:24:43 <SamB> @hoogle Data.IntMap.IntMap a -> a
17:24:44 <lambdabot> No matches, try a more general search
17:24:46 <SamB> @hoogle Data.IntMap.IntMap a
17:24:47 <lambdabot> No matches, try a more general search
17:24:48 <SamB> @hoogle Data.IntMap.IntMap
17:24:49 <lambdabot> No matches, try a more general search
17:24:52 <SamB> erg.
17:24:56 <SamB> @hoogle IntMap
17:24:57 <lambdabot> Data.IntMap :: module
17:24:57 <lambdabot> Data.IntMap.IntMap :: data IntMap a
17:25:04 <Korollary> Pseudonym: Of course. You just need to omit that bit when (tee hee) trying to convince your PM that KillerApp v 17.0 shall be written in haskell.
17:25:13 <Pseudonym> True.
17:26:43 <Philippa> I have to admit, the one thing the ICFP contest did for me that was good was reminding me that I can indeed produce a few hundred lines in a day given a spec
17:26:46 * ptolomy needs to go to grad school so he can understand more of these delightful papers.... I wonder if that qualifies as "a good reason to go"..
17:27:08 <Philippa> ptolomy: many of them you just need the right couple of books as intros and possibly some of the previous papers in the field
17:28:02 <Korollary> Philippa: I've always thought that you wrote quite a bit code.
17:29:44 <Korollary> ptolomy: There's a bit of peer pressure and marketing that is at work here. Perhaps the papers are not that 'delightful'.
17:30:09 <ptolomy> Well, I label them such based only on the parts I can understand.
17:30:55 <Korollary> Ok, then perhaps you are sufficiently intrigued to pursue them further.
17:31:28 <Pseudonym> Being able to read sequent calculus helps.
17:35:16 <u221e> So I compile ghc-6.5 and the simplest program breaks it ;)
17:35:22 <u221e> Go figure.
17:35:55 <Pseudonym> Submit a bug report!
17:36:07 <edwardk> I just wish that the masters I'm finishing up now in comp sci had anything to do with functional programming. =/
17:36:30 <johnnowak> edwardk: what are you doing?
17:36:45 <Philippa> Korollary: I think about code a lot, so I give the impression of knowing the language as well as someone who writes a couple of orders of magnitude more. My grasp of the semantics might not be that far off, depending
17:36:59 <u221e> Pseudonym, I don't know what to look for... it just says there was an exception Prelude.undefined
17:37:17 <Philippa> but I'm generally not as good at getting stuff done as I'd like, and coding's often a bit downprioritised
17:37:24 <Pseudonym> Well, can we see the code?
17:37:32 <edwardk> well, i dove back into education about 2.5 years ago, picked up a double bachelors and a math masters, finishing up my comp sci masters now, but my emphasis (such as it was) in the math masters was computational geometry
17:38:01 <johnnowak> ah
17:38:02 <edwardk> coz way back when i had an interest in 3d graphics and did some plucker quadric visibility stuff i half understood, and it was a good excuse to formalize my understanding of the topics
17:38:29 <Korollary> Philippa: Do you know about Oleg Kiselyov's code snippets? Perhaps you can do something like those.
17:39:25 <edwardk> heh, thats kinda what i've been doing with the http://slipwave.info site. just throwing what i have up there when i'm not sure i want to fiddle with it any more, or to see if there is any interest.
17:40:46 <u221e> Pseudonym: I figured it out, i'm returning to value of printf to the main function.
17:41:00 <Pseudonym> Right.
17:41:07 <u221e> Doesn't seem to cause a problem with 6.4.1 though
17:41:18 <Pseudonym> printf is a bit weird.
17:41:50 <u221e> I just threw in a return () and cleared it up.
17:46:25 <LordBrain> @seen SamB
17:46:26 <lambdabot> SamB is in #perl6 and #haskell. I last heard SamB speak 21 minutes and 29 seconds ago.
17:47:11 <LordBrain> I'm thinking about writing a config file parser for conjure
17:47:36 <LordBrain> but maybe not just for conjure... maybe something more general, that could handle unix style config files.
17:47:37 <SamB> oh?
17:47:45 <LordBrain> yeah
17:47:48 <Korollary> MissingH already has something like that
17:47:58 <LordBrain> oh
17:48:00 <LordBrain> i didnt know that
17:48:03 * SamB didn't realize conjure was worthy of configuration
17:48:20 <LordBrain> well i got the idea somewhere.. maybe a todo file or something
17:48:28 <Korollary> yes, the todo file says so.
17:48:37 <Korollary> But I think the todo file is way out of date.
17:48:51 <LordBrain> yeah probably
17:49:13 <Cale> hehe, I usually just do a show of some data structure :)
17:49:23 <LordBrain> Anyway, i was thinking about it.. and i realized i'm not sure how the configurable variables would be stored
17:49:37 <Cale> I suppose that's not really very suitable for human editing.
17:49:40 <LordBrain> would we have a bunch of TVars?
17:49:50 <Korollary> Cale: Yeah that works well enough
17:50:07 <SamB> man this is an eclectic collection of instructions
17:51:06 <LordBrain> i was thinking, well what if we want settings that could be changed on the fly
17:53:11 <Korollary> Can you link ghc compiled native code to ghc compiled bytecode somehow?
17:53:41 <LordBrain> is the ghc compiled bytecode what ghci makes?
17:53:50 <Korollary> yes, and runghc
17:53:58 <Korollary> I think
17:54:17 <Cale> ghci can load .o files if they exist though
17:54:30 <Cale> which you sort of have to be careful about, actually :)
17:54:50 <LordBrain> why careful?
17:55:04 <Korollary> I was thinking: if native code can be linked at runtime to bytecode, you could put config vars in a plain haskell file.
17:55:08 <Cale> well, if it loads a .o, it's not looking at the .hs
17:55:25 <LordBrain> interesting Korollary
17:55:40 <Korollary> I bet hsplugins would allow something like this
17:55:48 <Cale> Korollary: lambdabot does this to some extent
17:56:10 <LordBrain> we would bring back the ancient art of self-modifying code hackery
17:56:20 <Cale> (but it could do it better, afaict)
17:56:51 <Cale> I've been thinking about writing a mud server in Haskell using hs-plugins.
17:57:40 <Cale> It would be really cool to have object and mob scripts which were written in Haskell and compiled and linked on the fly.
17:58:45 <LordBrain> of course, this puts a dependency on the interpretter
17:59:08 <LordBrain> i mean, linking in bytecode like that
17:59:25 <Cale> I don't see myself using anything other than GHC in the near future :)
17:59:52 <LordBrain> i'm thinking of conjure
17:59:55 <Cale> and you could easily rebuild all the object files from source when you upgraded GHC
18:00:45 <Cale> (and felt the need to rebuild the core executable)
18:05:21 <LordBrain> i was thinking of users having to have the bytecode interpretter installed and running, rather than just a binary.
18:06:47 <Philippa> in the mid-term I can see YHC becoming rather interesting
18:07:03 <LordBrain> YHC?
18:07:17 <LordBrain> another haskell compiler?
18:07:28 <Philippa> yeah, one ndm&co're working on
18:24:06 <edwardk> cale: the consequences of space leaks in a haskell mud could be horrific
18:31:39 <Cale> edwardk: You mean in object modules?
18:33:05 <Cale> Muds always have some issues with the potential for bugs in mobs and such.
18:33:36 <Cale> I suppose it would be an option to use a non Turing-complete language for mob and object specification
18:36:06 <Cale> but that's less fun :)
18:37:16 <woggle> Things are managable if you can just place some aritificial resource limitations on whatever language does that stuff.
18:48:00 <edwardk> cale:  was ostly leaning towards the memory leak issues you can get in haskell code because of its nonstrict nature, sure a judious seq here and there can patch them up, but thats a lot to expect of a mud-coder =)
18:48:38 <edwardk> i actually think it could work out quite nicely though
18:49:39 <edwardk> on consideration, Eve Online scales up insanely and its just written in stackless python, some sort of cooperative coroutine monad and you could script lots of actors fairly naturally and have the code be efficient for once.
18:50:31 <Adamant> that, and they are using DDR-Ram based "hard drives"
18:51:44 <edwardk> heh true
18:56:49 <Korollary> lang.lightweight is an interesting mailing list to read.
18:58:41 <SamB> Adamant: are those any faster than regular hard drives, properly cached?
18:59:39 <edwardk> kor ?
19:00:18 <Korollary> edwardk: http://dir.gmane.org/gmane.comp.lang.lightweight
19:00:20 <lambdabot> Title: Gmane -- Mail To News And Back Again
19:00:23 <sylvan> SamB, AFAIK they're basically a bunch of regular memory so they should be faster than any harddrive.
19:01:36 <SamB> sylvan: well, at one point ram filesystems were slower on Linux than ext2 filesystems
19:01:42 <SamB> I dunno if it is still that way or not
19:02:04 <Korollary> Perhaps that was an implementation issue.
19:02:14 <SamB> well, yeah
19:02:35 <SamB> obviously the ram filesystem should be able to go at least as fast as ext2 ;-)
19:03:22 <edwardk> samb: toms hardware profiled one quite a while back, it was impressive enough i thought about buying one to slap all my old ram into
19:04:23 <edwardk> samb: i could never find one that would take enough ram to be satisfying though.
19:04:25 <SamB> oh, well, if it is actually a device I suppose it would perform well
19:04:46 <SamB> especially if you consider that it doesn't take RAM slots on your mobo...
19:04:51 * edwardk nods.
19:05:07 <edwardk> there are several vendors out there selling 2-4 gig versions.
19:05:26 <edwardk> and its not like you have a use for old slow memory anyways
19:05:36 <SamB> but I bet Linux wouldn't know how to deal with such a fast drive (i.e., not to bother caching it... maybe to consider using it as swap...)
19:06:03 <SamB> or at least, not to cache it as much
19:06:14 <SamB> and to consider it preferentially as swap
19:06:29 <edwardk> well, as for using it as swap, you can set THAT up yourself =)
19:06:57 <SamB> what I meant to say was to consider it as better swap than a real hard drive
19:08:56 <Korollary> Heh, an OS should benchmark the existing drives during installation for swap drive candidacy.
19:09:43 <SamB> it should support benchmarking any or all drives at any time
19:10:10 <SamB> (Though of course if you do it during install that would probably be more reliable... probably!)
19:14:33 <ihope> Does the "many" parser in ReadP always parse as much as possible, or can it parse less?
19:15:00 <SamB> I'm pretty sure it is nondeterministic
19:15:16 <ihope> Oh.
19:15:33 <SamB> for some reason that is how Read is
19:17:32 * ihope writes a version that doesn't do that: many' x = do {v <- x; vs <- many' x; return (v:vs)} <++ return []
19:18:48 <ihope> Now to go crazy with pattern guards...
19:20:53 <u221e> What is a STRef?
19:23:54 <hellish> u221e: AFAIK, it's like an IORef but in the State monad.
19:23:56 <ihope> Can I do serial pattern guards?
19:23:59 <edwardk> An STRef is a mutable reference like an IORef, but its designed to be used in an ST monad
19:24:17 <ihope> @docs Control.Monad.ST
19:24:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
19:24:21 <edwardk> so its encapsulated and lets you be sure that you won't trip over other things using ST monads elsewhere in your code
19:24:32 <kpreid> u221e: the ST monad lets you use mutable cells without the IO monad
19:26:26 <ihope> @hoogle STRef
19:26:27 <lambdabot> Data.STRef :: module
19:26:27 <lambdabot> Data.STRef.STRef :: data STRef s a
19:26:27 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
19:26:34 <ihope> @docs Data.STRef
19:26:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html
19:27:18 <u221e> Is there a tutorial about multi-parameter type classes? I don't really understand...
19:29:40 <Philippa> u221e: instances are for a tuple of types rather than a single type - "if you have an instance using these types in these roles, you can do this: "
19:31:28 <Philippa> "if you have an instance for (some collection type c and some element type e) you can add elements to a collection to get a new collection..."
19:32:02 <Philippa> a couple of the papers from around then (including the "exploring the design space" one) have examples, I've not seen a tutorial though I've not looked
19:32:31 <ihope> http://pastebin.ca/97813
19:32:42 <ihope> 'parse "[-]"' doesn't work.
19:32:58 <ihope> But 'parse "[-"' does, and it shouldn't.
19:33:34 <vincenz> \o/
19:33:36 <vincenz> that was fun
19:33:48 <vincenz> 8 hours of manual circuit flooring and lining
19:34:44 <edwardk> welcome back to the land of the living vincenz
19:36:00 * edwardk is still amused that team smartass keeps squeezing out more points on circs. They apparently aren't going to sleep yet
19:36:25 <Philippa> that, or left a solver searching the solution space and submitting improved results?
19:36:29 <edwardk> heh
19:36:31 <vincenz> edwardk: smartass squeezed the most out of every single puzzle
19:36:31 <edwardk> that too =)
19:36:34 <vincenz> it's fricking insan
19:36:34 <edwardk> yeah
19:37:42 <vincenz> I could prolly squeeze more out of it too
19:38:11 * vincenz ponders
19:43:43 <ihope> Okay, who can write me a BF parser? :-P
19:45:23 <ihope> Oh!
19:50:21 <SamB_XP> ihope: it is sooooo easy
19:50:35 <SamB_XP> try using Parsec though
19:50:40 <ihope> <ihope> Says something about my programming abilities, doesn't it?
19:51:07 <SamB_XP> @google BFInterpreter
19:51:10 <lambdabot> http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter
19:51:10 <lambdabot> Title: ShortExamples/BFInterpreter - The Haskell Wiki
19:51:18 <SamB_XP> that might also be of interest...
19:51:58 <ihope> ...There's a between operator, eh?
19:52:21 <SamB_XP> uh huh
19:53:49 <ihope> @hoogle ReadP a -> ReadP b -> ReadP [a]
19:53:50 <lambdabot> Text.ParserCombinators.ReadP.endBy :: ReadP a -> ReadP sep -> ReadP [a]
19:53:50 <lambdabot> Text.ParserCombinators.ReadP.endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
19:53:50 <lambdabot> Text.ParserCombinators.ReadP.manyTill :: ReadP a -> ReadP end -> ReadP [a]
19:54:04 <SamB_XP> @hoogle between
19:54:05 <lambdabot> Text.ParserCombinators.ReadP.between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
19:54:05 <lambdabot> Text.ParserCombinators.Parsec.Combinator.between :: GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a
19:56:01 <ihope> If I do a "manyTill x y" and y succeeds, is x even tried?
19:56:29 <SamB_XP> doubt it
19:57:28 <lispy> ihope: i think for manyTill to be properly implemented it would have to test y before trying x on every 'iteration'
20:03:50 * edwardk chokes. I went and installed adobe flex builder to play around with javascript. The trial lapsed, so I thought about registering it. I went to their site, waded through the 9 pages I needed to get there, and gasped: $500 for a javascript editpr.
20:04:14 <edwardk> $749 if you add the charting tools =)
20:04:36 <edwardk> oh and did i mention its still a beta and barely works?
20:04:48 <edwardk> and its built on eclipse, so they didn't do much work? =)
20:04:50 <ihope> Isn't Adobe famous for being unaffordable?
20:04:54 <edwardk> true
20:05:02 <edwardk> it just floored me
20:05:41 * edwardk adds "write an ecma4 plugin for eclipse" to his todo list.
20:06:04 <edwardk> or, heh, is Yi completely dead or is anyone working on it?
20:11:41 <ihope> @hoogle Integer -> Char
20:11:42 <lambdabot> No matches, try a more general search
20:13:03 <dons> edwardk: slowly working on it
20:16:28 <kpreid> ihope: chr, intToDigit
20:16:44 <ihope> @type chr
20:16:46 <lambdabot> Int -> Char
20:16:54 <ihope> @type intToDigit
20:16:55 <lambdabot> Int -> Char
20:17:10 <ihope> Those are both Ints, not Integers.
20:17:20 <lispy> fromIntegral?
20:17:23 <kpreid> so? (chr . fromIntegral)
20:17:51 <lispy> @type chr. fromIntegral
20:17:53 <lambdabot> forall a. (Integral a) => a -> Char
20:18:23 <lispy> > fromIntegral 100000000000000000000 :: Int
20:18:24 <lambdabot>  1661992960
20:18:31 <lispy> > (fromIntegral 100000000000000000000) :: Int
20:18:32 <lambdabot>  1661992960
20:18:45 <ihope> > 100000000000000000000 :: Int
20:18:46 <lambdabot>  1661992960
20:18:47 <lispy> > fromIntegral (100000000000000000000 :: Int)
20:18:49 <lambdabot>  1661992960
20:19:02 <ihope> > fromIntegral (100000000000000000000 :: Int) :: Integer
20:19:03 <lambdabot>  1661992960
20:19:23 <ihope> This BF interpreter is really, really inefficient.
20:19:27 <kpreid> > (fromIntegral (maxBound :: Int)) > fromEnum (maxBound :: Char)
20:19:28 <lambdabot>  True
20:19:31 <ihope> Either that, or it's stuck in an infinite loop.
20:19:33 <lispy> > (chr . fromIntegral) 100000000000000000000
20:19:36 <lambdabot>  Exception: Prelude.chr: bad argument
20:20:05 <jgrimes> What is generally the best way of adding primitives to a lexer/parser?
20:20:30 <jgrimes> As in, whats the best way to differentiate them from user defined functions
20:20:44 <ihope> Why differentiate?
20:20:54 <lispy> jgrimes: i don't understand, can you give an example?
20:20:56 <ihope> And just how would they be differentiated?
20:21:46 <jgrimes> hm, scratch that last part
20:23:02 <jgrimes> ihope, good point, I wouldn't need to
20:24:34 <jgrimes> lispy, I am adding primitives to a simple interpreter that does simple calculations (not really programming per say, but you can assign variables and such) and beyond just listing all of the primitives in the lexer/parser definitions I was wondering how people usually took care of mapping the primitives to functions
20:25:52 <lispy> in an interpreter you can make a sort of look up table
20:26:35 <lispy> jgrimes: i haven't checked but probably the scheme in 48 hours tutorial describes this
20:26:44 <lispy> @google scheme 48 hours haskell
20:26:47 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
20:26:47 <lambdabot> Title: Write Yourself a Scheme in 48 hours
20:26:49 <jgrimes> lispy, hm, ok
20:29:28 <jgrimes> lispy, yeah, it looks like it just defines a function that returns a list of the primitives paired with an operation function
20:30:16 <jgrimes> but then the function has to have the same type for each primitive
20:32:06 <lispy> dealing with type conversion between your interpreted language and your host language is interesting
20:32:37 <ihope> Oh, yeah. If I have a C function that handles structs, how's that converted into Haskell?
20:33:05 <lispy> ihope: Storable is the easy way to go
20:33:22 <foxy__> Does Shae Erisson visit #haskell?
20:33:37 <lispy> and if the struct in defined in C you can use hsc2hs to help automate the marshalling (ie, help write the Storable instance)
20:33:49 <lispy> foxy__: yes i think that name seems familiar
20:34:01 <jgrimes> foxy__, yes, that is shapr
20:34:07 <foxy__> ah, thanks
20:34:12 <foxy__> shapr, ping
20:34:34 <foxy__> @seen shapr
20:34:35 <lambdabot> shapr is in #haskell and #ScannedInAvian. I last heard shapr speak 3 hours, 19 minutes and 41 seconds ago.
20:34:49 <foxy__> @localtime shapr
20:34:50 <lambdabot> Local time for shapr is Mon Jul 24 05:34:28 2006
20:35:04 <foxy__> @help msg
20:35:05 <lambdabot> msg <nick or channel> <msg>
20:35:31 <u221e> Is it posible to evaluate haskell code at run-time?
20:35:42 <foxy__> u221e: hs-plugins
20:35:49 <foxy__> @where hs-plugins
20:35:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:36:04 <foxy__> @where ghc-api
20:36:05 <lambdabot> http://www.scannedinavian.org/~lemmih/ghc-api/
20:37:02 <foxy__> msg shapr I would like to use some darcs technology for Yi, maintaining multiple views of an underlying buffer and was wondering whether you knew the code base at all
20:37:11 <u221e> How does lambdabot do?
20:37:16 <u221e> do it
20:37:20 <foxy__> @msg shapr I would like to use some darcs technology for Yi, maintaining multiple views of an underlying buffer and was wondering whether you knew the code base at all
20:37:20 <lambdabot> Not enough privileges
20:37:29 <kpreid> u221e: with hs-plugins
20:39:09 <foxy__> any darcs hackers about?
20:39:39 <lispy> foxy__: i have hacked on darcs a little, but i'm about to leave
20:39:45 <lispy> foxy__: did you have a specific question?
20:40:05 <foxy__> lispy, I would just like a pointer to the source file which deals with single file differences
20:42:08 <lispy> foxy__: i think you want one of the Patch* modules, i put up some haddock documentation for darcs here if  that helps: http://projects.codersbase.com/repos/darcs-unofficial/api-doc/
20:42:40 <foxy__> lispy, thanks
20:42:41 <lispy> foxy__: in fact, if it helps, let them know on the darcs-devel list
20:42:53 <lispy> foxy__: i've been trying to convince them for a while to start using haddock :)
20:43:02 <foxy__> heh
20:44:02 <lispy> foxy__: you want to look at PatchCore.FilePatchType.Hunk
20:44:20 <foxy__> lispy, OK, cool...
20:45:01 <lispy> and now i'm really gone
20:45:06 <lispy> good luck :)
21:24:59 <glguy> @where unfoldr
21:25:00 <lambdabot> I know nothing about unfoldr.
21:25:05 <glguy> @where unfold
21:25:06 <lambdabot> I know nothing about unfold.
21:25:55 <Korollary> @index unfold
21:25:55 <lambdabot> bzzt
21:25:59 <Korollary> @index unfoldl
21:25:59 <lambdabot> bzzt
21:26:04 <Korollary> @hoogle unfol
21:26:05 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
21:26:05 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
21:26:05 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
21:26:06 <glguy> It is in Data.List
21:26:30 <Korollary> There's no unfoldl, eh?
21:26:40 <glguy> it wouldn't really make sense... would it?
21:26:52 <Korollary> I don't even know what unfoldl does.
21:27:12 <glguy> unfoldr seems like an iterate with a terminating case
21:28:16 <glguy> (but more general)
21:34:45 <Cale> yeah, but only slightly so
21:34:50 <Cale> oh, quit
21:35:27 <Cale> Most things which you'd want to write with unfoldr are usually easier to read if they're written with iterate/takeWhile
21:38:10 <lorne> > let lf [] = Nothing ; lf t = Just $ splitAt 2 t in unfoldr lf "aabbccdd"
21:38:11 <lambdabot>  ["aa","bb","cc","dd"]
21:40:23 <u221e> I got a somewhat offtopic question... what would I need to learn to create and understand formal proofs? Anything other then ZFC set theory and first order logic?
21:41:48 <Cale> u221e: well, not really. How formal are you talking about?
21:42:09 <Cale> Formal enough to be read by mathematicians is a lot less formal than formal enough to tell a computer.
21:43:39 <u221e> Cale: Formal that a computer can understand.
21:44:14 <Cale> well, those two will do for proofs about sets
21:45:18 <u221e> Can't all of mathematics be described with the ZFC axioms?
21:45:50 <Cale> sort of
21:46:16 <Cale> Well, depending on what counts as "mathematics"
21:46:40 <Cale> but in practice and in your head, it's not like that at all
21:47:05 <Korollary> see http://metamath.org
21:47:06 <lambdabot> Title: Metamath Mirror Selection
21:47:24 <Korollary> Principia Mathematica style stuff
21:47:41 <Cale> You can treat those as the only axioms, but there are far more definitions, and generally you work starting from some other set of axioms, rather than dropping down to the level of set theory at every turn.
21:48:00 <u221e> Korollary, I'm already there ;)
21:48:10 <Cale> There's something about metamath.org which really irritates me.
21:48:20 <Korollary> Cale: what is it?
21:48:23 <Cale> Even as a formalist
21:48:35 <edwardk> cale: oh?
21:48:53 <Cale> I'm a bit of an odd formalist though
21:49:22 <u221e> So... what irritates you?
21:49:24 <edwardk> cale: so you don't have a particular thing about the site that bugs you, you just don't like it? =)
21:49:32 <edwardk> or can you pin it down?
21:49:38 <Cale> It's difficult to fully express.
21:49:51 <Cale> It seems a little pointless, for one.
21:50:01 * edwardk isn't a huge fan of the style its done in and it seems, yeah, pointless =)
21:50:19 <netherworld> Hi! There is a new server in the net ftp://all:q1w2e3@netherworld.is-a-geek.net:5000 if you like it, please consider uploading any related and relevant material.
21:50:20 <Cale> See, they're staying at the level of sets
21:50:39 * edwardk appropriated a ton of their proofs as a starting point for a CAS project once.
21:51:12 <Cale> Also, when you completely formalise things like that, you lose almost all of the point.
21:51:32 <Cale> Without the informal ideas about what the formal objects represent, you're missing half the story.
21:52:05 <Cale> The informal ideas don't just serve to help manage the formal ones. We construct the formal systems to meet informal expectations to some extent too.
21:52:27 <Cale> If addition of naturals failed to be commutative, we would redefine them.
21:52:57 <Cale> (say as a result of some quirk of the underlying system)
21:53:22 <Korollary> we probably wouldn't have defined something like that in the first place because we couldnt use it in the physical world.
21:53:46 <edwardk> basically you're saying that metamath is a huge exercise in people chasing their tails.
21:53:55 <edwardk> a sentiment which i entirely agree with
21:53:57 <Cale> Well, mathematics, at least in its current form, is very modularised.
21:54:31 <Korollary> Can the metamath stuff be used as a library for proof assistants?
21:54:31 <Cale> I have some axioms for a field, and I prove various things about all fields.
21:54:38 <Cale> It could.
21:54:52 <edwardk> kor: you can hack it into that form. i've done so
21:55:02 <Cale> But for useful applications, it would be a silly way to go, I think
21:55:21 <u221e> We just need an advanced AI to figure everything out from first principles.. simple ;)
21:56:06 <Cale> Like, if you're proving things for a *reason*, like ensuring that some algorithm never produces values which are outside of a particular bound, then you're going to want to use more specialised techniques.
21:56:40 <edwardk> heh, it was back when i still was thinking quite thoroughly imperatively and modeled a CAS/code correctness proof system using Hoare triples, etc. All quite horrifying to me now. =)
21:57:21 <edwardk> i found metamath provided me decent machinery to check the validity of a proof. plumbing as it were, but its not a good environment to generate a proof.
21:57:44 <edwardk> and you drag in a crap ton of machinery in metamath to prove ANYTHING about a program.
21:57:58 <Cale> Machine proof generation is also almost useless to actual mathematicians.
21:58:51 <Cale> The proofs which get generated tend to be completely useless for actually directing a deeper study of the question.
21:59:08 <Korollary> like the 4-color theorem proof
21:59:10 <Cale> Like, they might work for the one theorem, but suggest nothing in terms of generalisations.
21:59:17 <edwardk> yeah, if it produces anything the tortuous path it takes is terrible to try to derive understanding from.
21:59:18 <Cale> yeah
21:59:44 * edwardk has spent many many sleepless nights staring at computer generated proofs =)
21:59:47 <Cale> Teach computers to play go first, that's an easier problem :)
22:00:19 <edwardk> worse, a good portion of that was trying to figure out why the proof agent went wrong =)
22:00:37 <u221e> Cale, GnuGo still beats me :(
22:00:46 <Cale> u221e: not for long :)
22:01:18 <Cale> Without giving it a handicap, I can almost always force it to resign, and when I don't, I tend to win by around 60 points.
22:01:57 <Cale> and I'm not all that good of a go player :)
22:02:00 <u221e> Maybe I'm just not very good... but then again Alan Turing sucked at chess
22:02:14 <Cale> You should play lots on KGS
22:02:21 <Cale> and with friends
22:02:35 <Cale> If you play everyday, you can develop quite quickly
22:03:03 <u221e> What I don't get is how computer Go programs handle the end game.
22:03:21 <Cale> oh, the end game is almost the only thing which is reasonably programmable
22:03:41 <Cale> there are good game theoretic ways to break it down and handle it
22:04:06 <Cale> I think it was Berlekamp who wrote a (supposedly) really good book about that.
22:04:22 <u221e> supposedly?
22:04:28 <Cale> I haven't read it myself
22:04:31 <u221e> Oh
22:04:32 <edwardk> Hrmm. Playing with linear, etc. typing in a pure type system. One notation that seems to suggest itself for the resulting kinds is to use * for unrestricted, + for relevant, ? for affine. Then you can read them off almost like a regexp in terms of number of appearances are valid. ? is 0 or 1, + is 1 or more, * is 0 or more...
22:04:46 <edwardk> I don't have a good notation for linear though =/
22:05:01 <edwardk> er in terms of what number of appearances
22:05:43 <edwardk> any thoughts on how to annotate the kind for linear types then?
22:06:46 <edwardk> I could always use something like ! but then that sort of inverts the traditional linear logic notation and seems a bit backwards.
22:07:56 <edwardk> If anyone has any ideas, speak up. In the meantime I'm going back to my scribblings =)
22:08:45 <Cale> I'm afraid I haven't really ever studied linear logic in detail.
22:09:16 <edwardk> mmostly just trying to clean up the notation when i move it into a pure type system
22:09:22 <Korollary> linear logic is interesting. every step of a deduction consumes axioms or something like that.
22:09:25 <edwardk> and keep the pure type system as clean as possible.
22:09:35 <Cale> Korollary: for specific types of axioms
22:09:57 <Cale> Korollary: Classical logic is seen as a sublogic of it, I think
22:10:05 <edwardk> kor: yeah, specifically you can't use contraction or weakening
22:10:20 <Korollary> Possibly. I am not familiar with it to define it here.
22:11:58 <edwardk> cale: you need to be able to have certain unrestricted terms to do so, but yeah.
22:12:16 <edwardk> So you can't embed it in a purely linear logic.
22:12:40 <edwardk> because every linear logic is an affine logic and every statement in an affine logic can be proven in polynomial time.
22:13:26 <edwardk> but its remarkable how few unrestricted terms you need
22:13:42 <edwardk> and that you only need to use them as a generator for linear terms.
22:15:10 <edwardk> anyways, i'm presently playing with adapting the substructural formalisms to work in a pure type system. That gives a nice framework for using them in practice because then you can use it on the lambda cube or to extend any other pure type system.
22:15:55 <edwardk> The existing substructural logic stuff out there is massive, I think the tech report for lambda refURAL is like 200 pages long. But it wastes so much time on minutiae that a pure type system takes care of for you.
23:17:12 <dons> ?yow!
23:17:12 <lambdabot> I invented skydiving in 1989!
23:21:08 <edwardk> too bad there isn't any way to send arguments to the second plugin when you use @. -- would love to be able to babelfish palomer into italian or something
23:21:29 <edwardk> is there a way to access the plugins from the > prompt?
23:24:27 <stepcut> what a weird job posting -> "Back up programmer - We are looking for a programmer to fill in when our programmer goes on vacations. "
23:24:58 <edwardk> doesn't sound like steady work unless their guy is quite the slacker ;)
23:25:01 <RyanT5000> is there any particular reason for the upper/lower case namespace separation?
23:25:18 <RyanT5000> i find myself wanting to make a type named "<->"
23:25:23 <RyanT5000> but it has to start with a :
23:25:45 <edwardk> ryan: yeah, its needed in the parser to disambiguate some cases
23:25:51 <RyanT5000> huh
23:26:57 * edwardk is stuck thinking in the wrong programming language for the moment, so switching gears may take me a sec =) but there is a good concrete example
23:26:57 <Cale> In this case, it disambiguates type variables from type constructors
23:27:13 <RyanT5000> ah
23:27:28 <RyanT5000> i wanted to make a type for a function with an inverse
23:27:33 <RyanT5000> i thought <-> would be rather elegant
23:27:37 <edwardk> ahh
23:27:38 <RyanT5000> apparently it is not to be
23:29:39 <Cale> It's probably possible to weaken that restriction in general, perhaps by requiring quantification of type variables.
23:29:48 <RyanT5000> hm
23:29:58 <RyanT5000> how about unicode?
23:29:59 <RyanT5000> how's that handled?
23:31:51 <RyanT5000> well i guess since i'm using a class it wouldn't be pretty anyway
23:32:12 <RyanT5000> it'd be nice if there could somehow be a nicer syntax for that
23:32:16 <RyanT5000> i'd love to be able to say something like
23:32:31 <edwardk> unicode uses the case of the resulting character in the unicode spec. it has some issues with certain caseless languages though.
23:32:42 <RyanT5000> (Int <-> Word32) -> Blah
23:32:56 <RyanT5000> right now it's looking like that'll come out to
23:33:16 <RyanT5000> Reversible r Int Word32 => r -> Blah
23:33:28 <edwardk> what about (Int :<-> Word32) -> Blah?
23:33:46 <RyanT5000> yeah, i guess that's acceptable
23:33:59 <RyanT5000> although i haven't figured out whether i should be using a class or not
23:34:15 <RyanT5000> honestly, classes still confuse me
23:34:28 <RyanT5000> i've never successfully written one - success being defined as eventually saving time due to it
23:34:57 <edwardk> start without one, when you run into a corner that you can't get out of, then try to apply one then ;)
23:35:14 <RyanT5000> yah, i guess i'll try that
23:35:51 <RyanT5000> lol :<-> looks like "naked-mole-rat smiley face"
23:36:06 <edwardk> heh
23:36:06 <RyanT5000> their mouthes close horizontally when they're using their teeth for digging
23:36:09 <newsham> have you tried to successfully write one?
23:36:12 <newsham> they're not that complicated
23:36:18 <RyanT5000> newsham: yes, i've tried
23:36:27 <RyanT5000> but my definition of success is rather strenuous
23:36:36 <RyanT5000> i think mostly i haven't had complicated enough problems with general enough datastructures
23:37:44 <newsham> sometimes useful in really simple problems.
23:38:11 <newsham> like.. you have objects which can be tested for equality.  or objects which can be converted to strings
23:38:27 <RyanT5000> yes, but those classes are already made, lol
23:41:22 <newsham> how about objects which can be converted into an array of bytes?
23:42:03 <RyanT5000> lol, what i'm saying is that i haven't found any types specific to the problems i'm solving that need to be generalized into classes
23:42:18 <newsham> nothing ever needs to be generalized.
23:42:25 <newsham> but it can be useful
23:42:35 <RyanT5000> need == saves significant time
23:43:21 <newsham> sometimes == save time next time
23:48:31 <newsham> make em if you want em.
23:48:35 <newsham> oops.. wrong channel
23:48:54 <parnassus> I am banned from like 6 rooms
23:48:57 <parnassus> this really sucks
23:49:05 <parnassus> so not free speech
23:49:28 <newsham> tell me about it..  i pay every time you open your mouth
23:51:00 <parnassus> you pay?
23:51:06 <parnassus> Who do you pay?
23:51:16 <Pseudonym> Would you like to be banned from here, parnassus?
23:51:23 <Pseudonym> Seriously.  If it'd make you feel better...
23:51:27 <Pseudonym> We're nothing if not obliging.
23:53:09 <Syzygy-> parnassus: You know, there's nothing at all anywhere guaranteeing the right to participating in IRC channels.
23:53:18 <newsham> seems like the democratic thing to do, pseudo
23:53:39 <newsham> syzygy: you mean the government doesnt guarantee that you can babble on any irc channel you want?
23:54:11 <Syzygy-> newsham: More than that. I don't know any government that cares one bit about what you do in privately owned communication channels.
23:54:39 <Syzygy-> -the government- is a bit vague, seeing as I'm certain at least two, probably more, nationalities are active in here right now.
23:54:52 <Pseudonym> And just in case they do: psyops echelon bin Laden Hizb-allah
23:54:57 <newsham> there's only really one.  the rest are mroe or less just states.
23:55:01 * Pseudonym waves to the NSA line eater
23:55:33 <Syzygy-> newsham: What, exactly, are you talking about right now?
23:59:04 <parnassus> I do not want to be banned.
23:59:06 <parnassus> :(
23:59:53 <Syzygy-> That may well be - but free speech has nothing to do with it. Trying not to annoy The Powers That Be, however, may have a lot to do with it; depending on where you're banned...
