00:01:48 <Stinger_> win 128
00:02:16 <lambdabot> win 256
00:02:37 <vegai> petkuhuiputusta!
00:02:38 <lambdabot> vegai: You have 1 new message. '/msg lambdabot @messages' to read it.
00:02:42 <vegai> @messages
00:02:42 <lambdabot> dons said 4 hours, 46 minutes and 51 seconds ago: can't get to http://iki.fi/vegai/tmp/fps-and-lambdabot40.txt. can you repost?
00:03:19 <vegai> ummh
00:03:19 <vegai> @paste
00:03:20 <lambdabot> http://paste.lisp.org/new/haskell
00:03:29 <dons> or just mail me??
00:03:38 <dons> dons <*> cse.unsw.edu.au
00:03:58 <Stinger_> eek lambdabot is sentient
00:04:06 <dons> ?vixen-on
00:04:07 <lambdabot> What's this channel about?
00:04:20 <mauke> it's about fun!
00:04:21 <lambdabot> fun fun fun!
00:04:23 <vegai> I'm in a middle of some serious redecorating, so my regular desktop is a bit paralyzed
00:04:24 <lambdabot> you seem upset...
00:04:41 <vegai> but there's gmail, so yeah, I'll mail it.
00:04:41 <lambdabot> vixenlove@hotmail.com
00:04:46 <dons> ?vixen-off
00:04:46 <lambdabot> Bye!
00:04:59 <Stinger_> heh alice bot huh
00:05:03 <dons> vixen's so cool
00:05:21 <mauke> @vixen you're so cool
00:05:21 <lambdabot> yup, i'm cool :)
00:06:05 <vegai> dons: there.
00:06:18 <dons> here :)
00:06:30 * dons ponders the build log
00:06:30 <vegai> wow, fast couriers
00:06:54 <dons> well, you're only 16,000 kms away
00:11:32 <dons> ah ha!
00:11:45 <dons> you need the darcs version of lambdabot :/
00:12:04 <dons> or, else, edit Lib/Regex.hsc
00:12:20 <dons> and add the line: import qualified Data.ByteString.Base as P (unsafeUseAsCString)
00:13:02 <dons> its all because lambdabot 4.0 depended on the darcs version of fps. but the darcs version kept moving
00:13:23 <dons> thankfully it seems to have stabilised now.
00:13:37 <dons> vegcan you try either of those options?
00:13:43 <dons> oh, netsplit :/
00:13:57 <dons> stoopid internets
00:29:37 <dons> Success? sounds almost like a Haskell irc client.. hmm
00:33:02 <astrolabe> What do qualified operators look like?  Would it be   a  M.<  b       ?
00:34:02 <mauke> yes
00:34:09 <astrolabe> ta
00:35:03 <dons> > M.empty M.\\ M.empty
00:35:04 <lambdabot>  Add a type signature
00:35:15 <dons> > M.empty M.\\ M.empty :: M.Map () ()
00:35:16 <lambdabot>  {}
00:37:29 <xerox> > M.singleton 1 "Haskell"
00:37:31 <lambdabot>  {1:="Haskell"}
00:38:03 <xerox> > read "{1:=\"Haskell\"}" :: M.Map Int String
00:38:04 <lambdabot>  add an instance declaration for (Read (Data.Map.Map Int String))
00:38:04 <lambdabot>   In the...
00:38:12 <dons> nah, not going to work
00:38:21 <dons> its one of those evil show instances that don't read.
00:38:33 <dons> there's a couple of others (Tree?)
00:38:56 <dons> maybe it should show as fromList [(,)...]
00:39:00 <dons> :}
00:39:40 <xerox> Right :)
00:47:19 <pesco> ibid: Hey, you there?
00:47:40 <ibid> y
00:47:58 <pesco> ibid: Morning. I'm Sven Hallberg, thanks for adding my blog to Planet Haskell!
00:48:35 <pesco> ibid: I noticed you've got everyone's IRC nicks listed there, so I thought I'd drop you a line that I'm me. ;-)
00:48:47 <ibid> not everyone's
00:48:56 <pesco> Well, many people's.
00:49:03 <ibid> just those that i could reliably connect to nicks :)
00:49:31 <ibid> i suspected you but didn't have a confirmation as you weren't here then :)
00:49:49 <kzm> Anybody seen huge perf drop from {-# INLINE #-}?
00:49:58 <pesco> ibid: Right, I was disconnected except for sporadic email.
00:50:54 <pesco> ibid: Anyway now you know, or would you like a GPG-signed email? :)
00:51:26 <ibid> what would it prove? ;)
00:52:08 <pesco> Well, there would be _some_ confidence towards the statement "Sven Moritz Hallberg calls himself pesco on IRC".
00:52:35 <pesco> Of course you'd have to accept the signatures on my key as giving such confidence.
00:53:22 <ibid> given that i don't require signatures on the emails requesting addition to planet... :)
00:53:31 <pesco> ibid: ;) Right.
00:53:48 <ibid> so i'd get the ircnick right but the blog really belongs to someone else
00:54:11 <ibid> pesco: we have to remember that security is at the core just a cost-benefit tradeoff;)
00:54:35 <pesco> ibid: Right.
00:56:10 <dons> kzm, sometimes inline makes things worse, yes
00:56:24 <ibid> the main point that i insist on is that i don't add blogs just because third parties tell me to, i want at least a minimal assurance that the author is agreeable
00:56:49 <pesco> Right.
00:56:59 <dons> ibid, good work on planet, it's been running quite nicely, i think
00:57:11 <ibid> i've sometimes asked, but i only do that to celebrities ;) others will have to get out and be proactive themselves :)
00:57:24 <kzm> I reexport 'index' from ByteString under the name of (!).  Since it took 5% of my running time, I tried to INLINE.  After that, it took 35%.
00:57:54 <pesco> ibid: Right, kudos from me, too, for making it, Planet's cool.
00:58:46 <dons> pesco: oh, btw, i've created a data type to represent HWN articles. maybe you're interested, after reading your blog entry.
00:59:19 <dons> though its certainly not any super-clever data type, its more a domain-specific data type for concise hwn preparation
00:59:34 <dons> kzm, interesting. that's kind of surprising. i wonder what ghc's doing to the core
00:59:53 <eivuokko> kzm, And actual runnign time went up as well?
00:59:57 <dons> i've noticed in the past that inlining on unsafeRead synonyms can have a negative effect (when hacking on the shootuout)
01:00:01 <ibid> pesco: i added the nick, should become visible in a couple of minutes
01:00:06 <kzm> You can have a look if you want :-)  (Core makes my head hurt)
01:00:18 <dons> but its' good for you.
01:00:21 <kzm> eivuokko, I only measured it with profiling, but total was way higher.
01:00:31 <kzm> Yeah, I know.  Core builds character, and all that. :-)
01:00:39 <dons> right
01:00:49 <kzm> Young people of today.. sigh
01:00:52 <pesco> ibid: Cool, thanks.
01:00:56 <dons> hehe
01:01:01 <dons> yeah, they never learn the old ways
01:01:07 <eivuokko> dons, On other languages that has (in my experience) been because compiler inlines bottom up and runs into function size limits and stops inlining.  Is ghc like that? (in case you know)
01:01:36 <dons> hmm, that's interesting. i'm not sure what ghc does, but it tends to inline fairly agressively
01:01:43 <dons> there are limits you can tweak, too
01:01:45 <pesco> dons: Ah, go the code to your type somewhere?
01:01:51 <dons> yep
01:01:52 <pesco> s/go /got /
01:01:53 <dons> let me see...
01:02:20 <dons> most of the fun stuff is in generating wiki, html and txt from the one source
01:02:25 <dons> that's what i mostly needed to be able to do
01:02:40 <pesco> Yes, that's my goal as well.
01:03:23 <dons> here's the input http://www.cse.unsw.edu.au/~dons/code/hwn/content.hs
01:03:26 <pesco> That blog post was actually already posted by my automatic txt-email-to-advogato-html interface.
01:03:31 <dons> and the markup tool, http://www.cse.unsw.edu.au/~dons/code/hwn/utils/publish.hs
01:03:59 <kzm> For my old, array based version (the reason for the (!) is compatiblity), this function consumes about 1% of the time.  But the increase to 5% is probably due to Unicode (Char) overhead compared to Word8...
01:04:02 <dons> you'll see how content.hs describes the structure of an hwn article
01:04:16 <dons> kzm, hmm perhaps yes
01:04:40 <kzm> It's fast enough for my purposes ATM, perhaps I'll get back to optimizing more later on.
01:04:55 <pesco> dons: Yeah, looks cool. Very practical, I'm sure!
01:05:31 <pesco> dons: How'd you like my folddoctree function? ;)
01:05:36 <dons> the different output formats are generated by dispatching recursively to ppr instances, using the format type to select different formats
01:05:58 <dons> kind of an insane type :)
01:05:59 <kzm> The speedup from BS wasn't as great as I'd hoped, but I iterate over characters in sequence anyway, so perhaps there isn't a lot to be gained.
01:06:22 <dons> pesco: maybe it's calling for generic traversals using Generics?
01:06:41 <dons> kzm, hmm. yeah . sounds reasonable
01:06:53 <pesco> dons: Don't know what good that could do. I've never used Generics, actually.
01:06:59 <dons> usually the speedup come from io or complexity issues (i.e. O(1) length )
01:07:14 <dons> oh, your types could be simpler, and the traversals could be just a gfold, i suspect
01:07:45 <dons> which internally would use dynamics to select which function to apply to each different sub component of your document type
01:08:08 <dons> or to change a particular component , you would do away with the surrounding boilerplate
01:08:23 <dons> (since this stuff is designed for AST transformations, it makes sense it would work on other AST-ish types)
01:08:43 <dons> this comment: "As you can see, it takes ten functions as parameters, each telling it what to do with a certain part
01:08:46 <dons> of the document,"
01:08:58 <dons> sounds exactly like what generics were designed to solve, Scrap your boilerplate-style
01:09:03 <dons> you've got boilerplate :)
01:09:52 <pesco> dons: I guess. :) Got a pointer to an intro about it?
01:10:14 <dons> the main intros are the SYB series of papers. it could really do with a beginners tutorial
01:10:18 <dons> @google SYB
01:10:20 <lambdabot> http://www.syb.com/
01:10:20 <lambdabot> Title: "Stock Yards Bank &amp; Trust Company"
01:10:22 <dons> nope
01:10:32 <dons> @google SYB Peyton
01:10:34 <lambdabot> http://www.cs.vu.nl/boilerplate/
01:10:34 <lambdabot> Title: "Scrap your boilerplate ... in Haskell"
01:10:36 <dons> ah ha
01:10:41 <pesco> :) Okay, cool.
01:11:43 <dons> oh, that page has a reasonable example
01:12:08 <dons> increase k = everywhere (mkT (incS k))
01:12:18 <dons> finds all the 'Salary' elements of the data type, and transforms them
01:12:24 <dons> no inductive boilerplate
01:13:02 <dons> so O(1) code size, versus O(n) , where n is the number of constructors in the type (approx)
01:13:47 <dons> the example using generic folding might be interesting
01:15:11 <kosmikus> @google bringert projects compositional
01:15:15 <lambdabot> http://www.cs.chalmers.se/~bringert/projects.html
01:15:15 <lambdabot> Title: "Bj&ouml;rn Bringert - Projects &amp; Publications"
01:15:50 <kosmikus> the paper "a pattern for almost compositional functions" is also quite nice, even though it doesn't yet come with compiler support as syb does
01:16:08 <bringert> I should put the paper online
01:16:12 <dons> ah, interesting!
01:16:16 <dons> bringert: yes!
01:16:23 <kosmikus> bringert: oh sorry, I missed that it isn't there yet
01:16:50 <kosmikus> I probably should have been quiet ...
01:17:14 <bringert> I just need to change the copyright stuff so that the ACM won't sue
01:17:15 <bringert> me
01:17:33 <bringert> kosmikus: no, that seemed very appropriate
01:18:27 <vincenz> Hello
01:18:35 <bringert> was is pesco who was asking about this originally
01:19:10 <bringert> s/is/it/?
01:19:21 <kosmikus> I think so
01:20:10 <pesco> dons was suggesting generic programming to me to simplify the definition of a big fold I wrote.
01:20:22 <pesco> Hi kosmikus and bringert, btw.
01:21:00 <bringert> pesco: I have a paper at ICFP this year about doing stuff like that without having to use generics
01:21:19 <bringert> pesco: it's not online just yet, but I can send it to you if you want
01:21:37 <pesco> Cool, sure. Got my address?
01:21:52 <vincenz> bringert: interesting
01:22:16 <vincenz> bringert: is this in the same line as the generic stuff done recently?
01:22:28 <vincenz> I forgot the name of the author (Sadly my laptop is down and my paper collection is on my laptop)
01:22:41 <pesco> Here's my fold: http://www.khjk.org/~sm/code/advopost/Doc.lhs
01:23:01 <bringert> pesco: I don't have your e-mail without googling or sigging through archives
01:23:13 <pesco> bringert: sm@khjk.org
01:24:58 * pesco checks out SYB papers...
01:25:02 <vincenz> bringert: I wouldn't mind a look either
01:25:09 <vincenz> bringert: if you don't mind
01:25:09 <bringert> pesco: you've got mail
01:25:13 <pesco> :)
01:25:16 <bringert> vincenz: addr?
01:25:25 <vincenz> bringert: christophe dot poucet at imec dot be
01:26:11 <bringert> vincenz: done
01:26:23 <vincenz> thx
01:27:00 <bringert> pesco: that looks like the sort of thing that the paper deals with
01:27:22 <bringert> at a quick glance anyway
01:27:59 <pesco> Cool, would your approach work with Hugs?
01:28:41 <vincenz> bringert: so is this in the same line as the generics stuff that this english guy wrote (his papers uses haskell as introduction and then showed the results in java)
01:29:48 <bringert> pesco: it requires GADTs when you have a set of data types, like you do, so currently no
01:30:08 <bringert> vincenz: I'm not sure I know what you are referring to
01:30:18 <pesco> bringert: Aw. :)
01:31:23 <sieni> http://tnx.nl/php.jpg
01:31:32 <vincenz> bringert: jeremy gibbons work
01:31:40 <vincenz> i just remembered the name
01:32:03 <dons> ah, the english guy :)
01:32:29 <vincenz> dons: My laptop charger is dead and my paper collection is on my laptop so.... 
01:32:59 <vincenz> bringert: specifically; http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#hodgp
01:33:00 <lambdabot> Title: "Jeremy Gibbons' Publications"
01:33:32 <pesco> hodge-podge?
01:33:49 <bringert> vincenz: I've only looked briefly at it, but I didn't think that it was close enough to mention in the paper
01:34:02 <vincenz> higher order data-type generic programs
01:34:40 <bringert> hmm, or did I just forget to study it further?
01:34:59 <vincenz> bringert: on another note, maybe I could use what you do for my AST stuff... however I still don't see how you would generically annotate.  Not sure if you've seen my post regarding cyclic type-defintions?
01:35:14 <bringert> nope
01:35:45 <vincenz> subscribed to haskell-cafe?
01:37:04 <vincenz> basically I'm struggling to keep AST representatiosn clean (meaning without a lot of appendages and without a lot of code duplication to traverse/transform them) http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#hodgp
01:37:05 <lambdabot> Title: "Jeremy Gibbons' Publications"
01:37:07 <vincenz> ack
01:37:13 <vincenz> http://www.haskell.org//pipermail/haskell-cafe/2006-July/016514.html
01:37:15 <lambdabot> Title: "[Haskell-cafe] Cyclic Type-synonyms"
01:40:12 <vincenz> dcoutts_: out of curiousity, is jeremy gibbons a close colleague of yousr?
02:01:11 <dcoutts> vincenz, not close
02:04:43 <bringert> vincenz: I'm subscribed to lots of haskell mailing lists, though I don't read all of the stuff that comes there, and not every day
02:06:38 <bringert> vincenz: hmm, yes, that stuff could be useful
02:06:58 <bringert> vincenz: let me know if you find anything from the paper useful
02:07:54 <vegai> dons: any ideas?
02:08:05 <kosmikus> "essence of the iterator pattern" is probably related to bringert's paper, yes
02:09:09 <vincenz> bringert: alright
02:09:19 <vincenz> kosmikus: yeah but hodgp ;ore so
02:09:21 <vincenz> more so
02:10:51 <kosmikus> vincenz: I'm not convinced. it might look more similar, but I think the pattern that bringert describes is very close to the concept of idioms/applicative functors.
02:14:09 <vincenz> kosmikus: I'll have to take a more indepth look then
02:14:47 <kosmikus> vincenz: probably both papers are related :)
02:15:02 <vincenz> kosmikus: I only did a diagonal skim of bringert's paper so far
02:25:47 <dons> vegai: yep, solved. grab either the darcs lambdabot, or the 4.0.1 snapshot i just posted on lambdabot's home page
02:26:04 <boegel> @where lambdabot
02:26:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:26:06 <dons> basically lambdabot 4.0 depends on a darcs version of fps, but fps kept moving (slightly)
02:26:24 <dons> one import changed, so i rolled a new lambdabot tarball
02:45:55 <dcoutts> dons, any news on hs-plugins? I've got gentoo users bugging me about it :-)
02:45:55 <dcoutts> http://bugs.gentoo.org/show_bug.cgi?id=131227
02:45:57 <lambdabot> Title: "Bug 131227 - dev-haskell/hs-plugins-1.0_rc0 version bump"
02:46:35 <Itkovian> pfft, my program has been running for over 9 hours to parse 70MB of data.
02:46:42 <Itkovian> seems way out of line
02:46:56 <vincenz> o.O
02:47:02 <vincenz> Itkovian: what is it supposed to do?
02:47:13 <Itkovian> brb
02:51:51 <Itkovian> there is a file with entries (ASCII strings) that are made up of fields (1 entry per line) 
02:52:08 <Itkovian> the first field is a tag indicating the type of the entry (E,C,R or M)
02:52:45 <Itkovian> the next fields indicate the function id, the thread that was executing and the value of a hardware performance counter
02:53:09 <Itkovian> the goal is to build a calltree annotated with execution information, i.e. the stuff from the performace counter
02:53:30 <Itkovian> the calltree can then be manipulated to yield a set of functions that are interesting in some sense
02:53:48 <Itkovian> It should be very straightforward
02:54:14 <Itkovian> the entry tagged with C indicates that start of a function and its value, R indicated the end of a function and its value
02:54:15 <vincenz> move to #oasis for a sec? This'll be done faster in dutch
02:56:13 <kzm> Fixed my INLINE problem :-)
02:56:21 <kzm> ..by INLINEing even more.
02:57:59 <vegai> dons: ah, ok. Trying.
03:00:04 <vegai> dons: yep, builds now. Excellent :)
03:11:49 <MarcWeber> Can someone help me interpreting this piece of code? line 5 I don't understand where list is specified (not globally and not in the following (not pasted) where directive.
03:12:23 <MarcWeber> got it
03:12:28 <MarcWeber> function parameter
03:42:36 <dons> vegai: great
03:43:23 <dons> dcoutts: what are they bugging you about?
03:43:30 <dons> should i tag rc0 as 1.0
03:43:31 <dons> hmm
03:43:49 <dcoutts> dons, yeah, I said I'd hold off for a 1.0 release
03:44:01 <dcoutts> the user wanted an rc0 ebuild
03:44:27 <dons> yeah, i think maybe i'll tag 1.0 next week. it seems quite stable now, i'm not getting any reports, and it needs to get out before ghc 6.5
03:44:29 <dcoutts> I wasn't sure which to do since it depends on the schedule
03:44:41 <dcoutts> dons, has it been tested on amd64 ?
03:44:50 <dons> i believe so.
03:44:52 <dcoutts> is there any tests I can run in the ebuild?
03:44:56 <dons> yep
03:45:01 <dons> there's a 'make test' target
03:45:17 <dcoutts> and that' "just works"? or do I need any other setup
03:45:25 <dons> hmm. you need ghc installed
03:45:29 <dcoutts> yeah
03:45:33 <dons> and gnu make
03:45:52 <dons> oh, hs-plugins will need to be registered, i suspect
03:45:57 <dons> let me chec..
03:45:58 <dcoutts> ah, hmm
03:46:11 <dcoutts> that'd not fit well with when the ebuild tests run
03:46:19 <dons> right
03:46:26 <dcoutts> FEATURES="test" emerge hs-plugins
03:46:46 <dcoutts> it runs the test bit after it's been compiled but before it's installed and registered
03:47:02 <dons> oh, and that works?
03:47:05 <dcoutts> so eg that works fine for the ghc regressions suite since it uses ghc-inplace
03:47:24 <dcoutts> dons, no I mean that'd be the procedure
03:47:29 <dcoutts> a user would run:
03:47:31 <dcoutts> FEATURES="test" emerge hs-plugins
03:47:33 <dons> right.
03:47:51 <dons> ghc's going to need to see the pakckage somehow to run the tests
03:47:59 <dcoutts> and emerge would run the make test between compiling & installing
03:48:06 <dons> yeah, same as bsd.
03:48:15 <dons> but there'd be no fake register system, is there?
03:48:28 <dcoutts> well how about just saying -i../src
03:48:33 <dcoutts> rathe than -package hs-plugins
03:48:41 <dons> yeah, that'd work.
03:48:49 <dcoutts> so i picks up the .hi & .o files from where they've been built
03:48:52 <dons> i thought i'd actually done that. i'll check
03:48:57 <dons> it'll need to look in dist/ though..
03:49:07 <dons> dist/build/
03:49:08 <dcoutts> right
03:49:31 <dons> which might not be ../../ (or is it always there in your build system?)
03:49:43 <dons> (I at least alias configure as configure -b /usr/obj/
03:49:58 <dons> so i can wipe all my objects easily, and backup without getting objects and .his archived
03:50:07 <dcoutts> not sure what you mean about ../../
03:50:37 * dcoutts was imagining $BUID_ROOT/tests/*.hs
03:50:59 <dcoutts> and from $BUID_ROOT/tests/ calling ghc --make -i ../dist/thing/ Test1.hs
03:51:11 <dons> is dist always in the top level? or are objects built outside the src tree? won't -i../dist/build not work if dist/build is somewhere else?
03:51:20 <dons> which is the case if you use Cabal's -b flag
03:51:26 <dons> maybe you build objects in tree?
03:51:32 <dcoutts> hs-plugins uses cabal right?
03:51:34 <dons> yep
03:51:35 <dcoutts> so it's under dist
03:51:38 <dons> ok
03:51:54 <dons> on bsd, it's possible to have your objects put in some arbitrary locatoin
03:52:05 <dcoutts> using cabal ?
03:52:13 <dons> i doubt it. but i do do that myself, yes.
03:52:21 <dons> using ./Setup.hs configure -b /usr/obj
03:52:37 <dons> anyway, this is an aside. i'll see if i can get -i to work
03:52:46 <dcoutts> oh I see so you put the object files somewhere else entirely and make the src tree readonly
03:52:51 <dcoutts> no we just use a sandbox
03:53:06 <dons> yep
03:53:06 <dons> ah ,ok.
03:53:10 <dcoutts> so the src tree is writable but outside is not
03:53:25 <dcoutts> most build systems don't let you put the object files elsewhere
03:53:36 <dcoutts> they're just not that well behaved
03:53:52 <dons> yeah, i suspected that since cabal does, using -b, maybe you supported that in some tricksy way
04:08:30 <dcoutts> dons, I didn't know that cabal supported that :-)
04:09:15 <dons> ah ok :)
04:09:17 <dons> it's cool
04:09:39 <dons> my nightly backups don't get bloated now, since 
04:09:41 <dons> $ which c
04:09:41 <dons> c: aliased to runhaskell Setup configure --prefix=/home/dons -b /usr/obj/cabal
04:09:42 <dons> :)
04:11:00 <dons> jon olsson, around?
04:13:39 <noj> oi!
04:13:41 <noj> :)
04:13:46 <dons> oi!
04:14:03 <dons> you interested in taking over the darcs port maintainership?
04:14:18 <noj> hmm, maybe
04:14:37 <dons> i just don't seem to have the time to keep the openbsd ports stuff up to date. too much haskell hacking going on.
04:14:50 <dons> i'm happy to offer advice though, of course.
04:15:12 <noj> sounds good
04:15:25 <noj> but please keep maintaining the GHC port :)
04:15:48 <dons> i replied to your mail, and cc'd pvalchev and anil@ (who follow what's happening with the haskell stuff)
04:16:04 <dons> so hopefully , perhaps anil can have a look at the patch and apply it for you
04:16:23 <noj> my OpenBSD computer is waaay to slow to be anything other than painful when building GHC 
04:16:28 <dons> yeah, i'll be keeping the ghc darcs branch up to date, but not sure about the ghc openbsd port script.
04:16:58 <noj> dons, oh, that's a shame
04:17:04 <dons> my work means i have to keep ghc running on openbsd, but keeping up with the ports tree takes too much time
04:17:34 <dons> so, instead, i'll be rolling ghc binaries when releases come out, i think.
04:17:48 <noj> ok
04:18:48 <noj> dons, did you switch os?
04:19:09 <dons> nope
04:19:22 <dons> just don't have time to keep the machine up to date enough
04:19:38 <dons> OpenBSD 3.8-current (GENERIC) #3: Thu Nov  3 23:26:41 EST 2005 :}
04:19:44 <noj> I see, but that's a piece of cake with binary snapshots :)
04:19:54 <dons> sure, i use snapshots
04:20:38 <dons> i just have a huge amount of ghc and haskell software being worked on, which has stolen all the time i used to spend on openbsd ports
04:20:46 <dons> :/ 
04:20:49 <dons> oh wel
04:21:06 <noj> I hear ya
04:21:30 <dons> oh, you asked a while back about ghci not working?
04:21:44 <noj> yeah, errno-stuff
04:21:54 <dons> there was an issue with some gcc flags and propolice in the ghc rts that has been fixed now
04:21:54 <noj> Loading package base ... linking ... /usr/local/lib/ghc-6.2.2/HSbase_cbits.o: unknown symbol `__errno'
04:22:07 <dons> oh, that. hmm. no haven't seen that one.
04:22:08 <noj> do you have that particular patch?
04:22:27 <dons> however, i did fix a propolice bug causing ghci segfaults in the ghc head branch
04:22:39 <dons> gcc was being too keen to mangle our code
04:22:44 <noj> dons, might be a change between 3.8 and 3.9 that you haven't picked up
04:22:48 <dons> yeah
04:23:12 <dons> oh __errno, maybe that just needs to be added to the rts symbols list 
04:23:13 <dons> let me see...
04:23:29 <noj> something changed wrt to the threading libraries in OpenBSD
04:24:01 <dons> i see __errno is in the ghci symbols list, but only on cygwin
04:24:15 <dons> occasionally i've had to add new symbols, this might be one of those cases
04:24:44 <dons> i've got my phd review next week, but after that i should be able to update my system, and check out this issue.
04:24:51 * dons tweaks his todo list
04:24:59 <noj> cheers mate
04:32:26 <yaxu> moo
04:33:44 <yaxu> another newbie question - how can I do timing operations in haskell?   find out the time, pause for a certain amount of time etc
04:34:04 <dons> ?hoogle cpuTime 
04:34:05 <lambdabot> CPUTime :: module
04:34:05 <lambdabot> CPUTime.cpuTimePrecision :: Integer
04:34:05 <lambdabot> CPUTime.getCPUTime :: IO Integer
04:34:17 <dons> ?hoogle threadDelay
04:34:18 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
04:34:24 <yaxu> thanks dons
04:38:04 <yaxu> i shall consult http://www.haskell.org/hoogle/ first in the future
04:38:05 <lambdabot> Title: "Hoogle"
04:40:43 <vincenz> yaxu: you can even hoogle for types
04:40:47 <vincenz> @hoogle Int -> IO ()
04:40:48 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
04:40:49 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
04:40:49 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
04:44:57 <kzm> What exactly is 'cpuTimePrecision'?
04:45:12 <kzm> > CPUTime.cpuTimePrecision
04:45:13 <lambdabot>  Not in scope: `CPUTime.cpuTimePrecision'
04:45:32 <kzm> (I see it is one zillion or so, but what does it mean?  Hz?)
04:45:50 <kzm> (and shouldn't it been named timerFrequency or something instead?)
04:46:32 <kzm> Oh, picoseconds.
04:46:57 <kzm> Teach me to read docs first, and ask later.
04:58:13 * dcoutts dumps 3 more ghc patches on JaffaCake in addition to the one still awaiting review.
04:58:18 <dcoutts> sorry JaffaCake ;-)
04:58:38 * JaffaCake clambers out from under a heap of patches
04:59:35 <dcoutts> JaffaCake, btw, I didn't mention in the email, but I did test the non-exec stack bits and the .ident thing. And I checked that the configure test works on linux and fails on osx as expected. No guarantees about other archs yet however.
05:00:36 <JaffaCake> sounds good enough for me
05:00:41 <dcoutts> but if it does seem to be working it'd be nice for the non-exec patch to go into 6.4.3
05:00:48 <JaffaCake> is this critical enough for 6.4.3?
05:00:54 <dcoutts> assuming we get the -fvia-C parts sumbitted in time
05:01:25 <JaffaCake> ok
05:01:26 <dcoutts> cparrott is working on the mangler patch to let the .note.GNU-stack bits through the mangler
05:01:45 <dcoutts> not sure about split-objs yet however
05:02:05 <dcoutts> we may need that .section .note.GNU-stack,"",@progbits in every .S file that gets split
05:02:58 <dcoutts> since the semantics of it are quite conservative, the linker will only mark the binary as not needing an exec stack if every .o file linked in is marked as not needing an exec stack
05:03:46 <dcoutts> so if the splitter finds that section in the original .s then it probably needs to emit it into every little output .s file
05:04:24 <dcoutts> where as the mangler simply needs to not swallow it, but let it through into the output
05:05:07 <dcoutts> then we will not need out current hack of specifying -opta-Wa,--noexecstack every time
05:05:20 <dcoutts> which is a hack as it's not fully safe
05:05:30 <marc_vw> anyone here participating in icfp?
05:05:38 <dcoutts> marc_vw, yep
05:05:38 <vincenz> marc_vw: conference or competition?
05:05:50 <marc_vw> competition
05:05:50 <dcoutts> competition, not conference for me (sadly)
05:05:58 <vincenz> marc_vw: yep as well
05:06:17 <marc_vw> my assistent at hagen was allowed to go to the conference last year (envy, oh envy)
05:06:17 <moonfish> any idea how I get "seconds since the epoch" from a CalendarTime?
05:06:38 <marc_vw> i would like to join a team
05:06:54 <marc_vw> alone it is too much
05:07:03 <marc_vw> but i could cetainly help out
05:07:14 <marc_vw> the weekend i should have time
05:07:21 <marc_vw> about the weekdays i am not sure yet
05:07:34 <vincenz> marc_vw: there is a somewhat public haskell team
05:07:38 <vincenz> join #oasis and check wikilink
05:07:47 <marc_vw> ok
05:07:57 <marc_vw> cant let c++ win this year
05:10:14 <marc_vw> vincenz: impressive
05:10:41 <vincenz> marc_vw: heh thanks
05:10:54 <vincenz> we plan to have an organizational meeting when I'm back from a conference
05:10:58 <vincenz> the 16th
05:20:55 <_Codex> when was icfp this year (the competition)?
05:21:40 <vincenz> _Codex: it hasn't happened yet
05:21:43 <vincenz> 21-24 juy
05:21:45 <vincenz> july
05:22:48 <_Codex> oh, it's later this year than normally.
05:23:33 <Igloo> JaffaCake: By the way, did http://www.haskell.org//pipermail/cvs-ghc/2006-June/029921.html slip through the net? It doesn't seem to be applied or to have been replied to
05:23:34 <lambdabot> Title: "darcs patch: Be lazier in user config creation, and don't fail on m..."
05:25:24 <JaffaCake> Igloo: hmmm, I can't find it on cvs-all, which is the list I read
05:25:43 <JaffaCake> I suspect I might have mis-moderated it, or something
05:26:07 <Igloo> JaffaCake: http://www.haskell.org//pipermail/cvs-all/2006-June/048005.html
05:26:07 <lambdabot> Title: "darcs patch: Be lazier in user config creation, and don't fail on m..."
05:26:30 <JaffaCake> now I'm confused
05:27:24 <vincenz> how do you re-export an imported module?
05:27:53 <Igloo> Put "module Foo" in the export list
05:28:02 <vincenz> Igloo: ah thank you
05:28:57 <vincenz> Igloo: what if you don't have an export list?  I take it that you then first need to generate one and declare all the stuff from that module and then add those module Foo statements
05:29:28 <marc_vw> do you still take members?
05:29:32 <JaffaCake> Igloo: your patch didn't appear on Gmane, so I didn't get it:  http://news.gmane.org/gmane.comp.lang.haskell.cvs.all
05:29:34 <lambdabot> Title: "Gmane Loom"
05:29:35 <marc_vw> or do you want to go as 4 team
05:29:37 <yaxu> i'm having problems building a library (hs-plugins), "Could not find module `Language.Haskell.Hsx'"
05:29:41 <JaffaCake> how weird
05:29:55 <yaxu> i guess i'm missing some package in ubuntu, but can't find it
05:30:00 <vincenz> marc_vw: that's to be discussed the 16th, but this discussion is more appropriate in #oasis
05:30:06 <yaxu> anyone got any clues?
05:30:11 <marc_vw> ups wrong tab
05:30:13 <marc_vw> :)
05:30:18 <Igloo> vincenz: You can create an export list consisting of   module ThisModule, moduleFoo
05:30:31 * JaffaCake wonders if he's missing any other important patches
05:31:16 <Igloo> Is gmane meant to do any spam filtering or anything?
05:31:32 <JaffaCake> I guess it does
05:31:41 <vincenz> Igloo: ah neat, that's quite handy :)
05:31:49 <JaffaCake> maybe I should subscribe properly
05:33:19 <JaffaCake> Igloo: applied, thanks
05:35:11 <Igloo> JaffaCake: ta
05:36:36 <paolino> hi , I'm tryying to compile the example in the  docs of HGL on freebsd, I get a bunch  of undefined reference
05:40:49 <Igloo> Looks like the message didn't reach gmane at all, as I can't see it with a news client which http://gmane.org/filter.php implies I should always be able to do
05:40:51 <lambdabot> Title: "Gmane -- Gmane Filtering"
05:46:35 <dons> Igloo: i've noticed one or two emails over the lsat couple of years not make it to gmane.
05:46:48 <dons> paolino: are you missing a -package flag?
05:48:18 <paolino> probably
05:52:48 * dons -> sleep
05:53:01 <boegel> dcoutts: ping!
05:53:20 <dcoutts> boegel, pong!
05:53:40 <vincenz> net!
05:54:42 <dcoutts> boegel's serve
05:54:54 * boegel aces
05:55:05 * dcoutts dives and misses
05:55:11 <boegel> dcoutts: could you change the url on http://www.haskell.org/gtk2hs/gallery/HRay for me?
05:55:12 <lambdabot> Title: "Gtk2Hs Screenshot Gallery :: HRay"
05:56:01 <dcoutts> aye, to what?
05:56:03 <boegel> dcoutts: the correct url is http://trappist.elis.ugent.be/~kehoste/Haskell/HRay
05:56:07 <lambdabot> Title: ":: HRay - a Haskell ray tracer ::"
05:56:30 <boegel> I had to remove it from my studwww pages, and since shapr was forced to kill scannedinavian.com ....
05:56:53 <dcoutts> boegel, there we are, is that better?
05:57:29 <yaxu> http://www.haskell.org/happy/ http://www.haskell.org/alex/
05:57:30 <lambdabot> Title: "Happy: The Parser Generator for Haskell"
05:57:38 <yaxu> oops sorry wrong tab
05:58:32 <boegel> dcoutts: yeah, sure
05:58:46 * boegel suspects yaxu of spamming
05:59:03 <yaxu> boegel: why?
05:59:10 <vincenz> yaxu: he's belgian
05:59:27 <yaxu> fair enough
05:59:33 <boegel> yaxu: I was _joking_
05:59:33 <dcoutts> boegel, I've also updated this page: http://haskell.org/gtk2hs/archives/2005/04/28/hray-screenshots/
05:59:35 <lambdabot> Title: "Gtk2Hs &raquo; Blog Archive &raquo; HRay screenshots"
05:59:36 * vincenz too
05:59:36 <boegel> vincenz: f u
05:59:46 <vincenz> boegel: I'm belgian as well, 
05:59:48 <boegel> dcoutts: thanks :)
06:00:02 <boegel> vincenz: oh right, Muad_Dibber is the Dutch one, sorry :p
06:00:33 <yaxu> boegel: ah, it's just that in my other window i'm sending out emails about my illegal pharmacy business
06:00:40 <Muad_Dibber> there's lots of dutch ones here...
06:01:46 <vincenz> yaxu: oh you have a botnet on freenode?
06:02:04 <boegel> yaxu: you're selling any nice pills?
06:02:34 <yaxu> boegel: yes all different colours
06:02:47 <boegel> yaxu: send me some pink ones, will you?
06:02:58 <boegel> doesn't matter what's in them, as long as they are pink :)
06:03:09 <apfelmus> yaxu: selling HOT stuff, eh? for those who do it in a monad
06:04:26 <lome> hi! is ther is a way to know can some type be a monad?
06:04:27 <lome> e.g. we have a type
06:04:27 <lome> data S a = S a (S a)
06:04:27 <lome> It cann't be a monad 'cause it has not any implementations of unit/bind that satisfy three monad laws. Or, you can just think about function join on it - how it could be implemented? Am I clear?
06:04:45 <vincenz> lome: yes... easy
06:04:53 <vincenz> lome: you cerate an instance of Monad for S
06:05:19 <vincenz> ensuring to obey the monad laws
06:05:23 <vincenz> instance Monad S where ....
06:05:32 <lome> vincenz: what is `cerate` mens??
06:05:38 <lome> means
06:05:42 <vincenz> sorry "create"
06:05:55 <lome> oh, i see
06:06:32 <Lemmih> @wn cerate
06:06:34 <lambdabot> *** "cerate" wn "WordNet (r) 2.0"
06:06:34 <lambdabot> cerate
06:06:34 <lambdabot>    n : a hard medicated paste made of lard or oil mixed with wax or
06:06:34 <lambdabot>      resin
06:06:56 <norpan> return a = S a (return a)?
06:07:15 <norpan> or what would the implementation be? :)
06:07:16 <lome> norpan: yes,  and (>>=)?
06:08:52 <lome> vincenz: i mean can i see that type cannot be monad from its declaration? or, i have to try implement it and then check three laws?
06:09:16 <norpan> well
06:09:46 <norpan> (S a _) >>= k = k a
06:09:49 <norpan> i don't know
06:09:56 <norpan> depends on what your datatype should do
06:10:09 <lome> norpan: 2nd law doesn't work on it.
06:10:13 <vincenz> lome: oh...erm... hard to say, it all depends on how you define your data type
06:10:20 <norpan> lome: it doesnt?
06:10:32 <lome> yes, it doesnt
06:11:10 <norpan> well, it depends if you allow objects to be constructed with something else than return
06:11:10 <lome> vincenz: ok, thx :-(
06:11:43 <apfelmus> lome: your type is an infinite stream. so >>= would need to merge infinite streams, alas some kind of map NxN -> N.
06:11:53 <lome> norpan: i dont understand. what do you mean?
06:12:45 <lome> apfelmus: yes, we can not merge infinite count of infinite streams
06:13:59 <sieni> lome: what do you mean by merge?
06:15:03 <apfelmus> lome: why not? there are maps NxN -> N (start add (0,0) and browse up and down the diagonals)
06:15:10 <lome> sieni: concat
06:15:54 <lome> apfelmus: we lose elements?
06:16:32 <lome> apfelmus: ok, i'll try it.
06:16:57 <sieni> lome: let's not (n,m) the n:th element of m:th sequence. Now do as follows: (1,1) (2,1) (1,2) (3,1) (2,2) (1,3) (4,1) (3,2) (2,3) (1,4) ...
06:17:15 <dmhouse> Straw poll: how many spam messages do people get slipping through their Gmail spam filters per day?
06:18:12 <Lemmih> dmhouse: 1-2.
06:18:44 <lome> sieni: thanx a lot!
06:19:20 <anuke> dmhouse: 5-6
06:23:23 <sieni> lome: if you start from (0,0), then you get that bijection from pairs of natural numbers to natural numbers from 1/2 * ((x + y)^2 + 3x + y)
06:25:24 <lome> sieni: thx again! 
06:26:42 <lome> sieni: and what is inverse transformation?
06:26:54 <sieni> lome: http://mathforum.org/library/drmath/view/51522.html
06:26:56 <lambdabot> Title: "Math Forum - Ask Dr. Math"
06:27:32 <lome> sieni: thx!
06:50:19 <lome> sieni: no :-/ first law doesn't work.
06:50:19 <lome> e.g. f x = S x (S (x+1) (S (x+2) (...)))) and return x = S x (S x (S x ...))
06:50:19 <lome> So we have at left side (return x >>= f) -> 1 2 1 3 2 1 ... and at right side (f x) -> 1 2 3 4 ...
06:50:19 <lome> :-(
06:51:01 <gour> dcoutts: hi
06:51:03 <dmhouse> lome: Are you designing your own monad?
06:51:26 <gour> dcoutts: what skills are required for fixing c2hs?
06:52:12 <dcoutts> gour, mostly figuring out what configure.in is doing and finding portable replacements
06:52:23 <dcoutts> and then testing it on win32
06:52:28 <dcoutts> ndm? ;-)
06:52:40 * dcoutts heads out
06:52:45 <gour> dcoutts: ahh..ok. maybe i can take a bet
06:53:09 <gour> now i've to go out, have some clients for counselling
06:53:24 <lome> dmhouse: just experiment :-)
06:53:41 <dmhouse> lome: it looks fun. How does it work?
06:53:43 <norpan> (S x xs) >>= k = let (S y ys) = k x in S y (ys >>= k)
06:54:31 <lome> dmhouse: task: i guess that data S a = S a (S a) can not be monad. So I try to prove it.
06:54:51 <ndm> dcoutts, am just playing with Gtk2hs on my work machine - the file dialogue is pretty horid!!!
06:55:05 <dmhouse> lome: that's just [].
06:55:11 <lome> norpan: thx. one moment - i'll try it.
06:55:20 <norpan> no it doesn't work, xs gets lost
06:55:31 <dmhouse> [] without the empty list.
06:56:13 <lome> dmhouse - no - it has infinite count of infinite list in fmap f m (when we do `bind`) so we can not use usual `concat`.
06:56:40 <dmhouse> Tru.e
06:56:42 <lome> norpan: yes :-/
06:57:52 <lome> dmhouse: i am looking for texts about proving that this type can be a monad, but this one can not.
06:58:25 <dmhouse> It can't? You're sure?
06:59:11 <lome> i'm not sure - i guess,
07:00:08 <dmhouse> (>>=) :: Cons a (Stream a) -> (a -> Cons b (Stream b)) -> Cons b (Stream b)
07:00:15 <dmhouse> Err
07:00:22 <dmhouse> That was a bit mixed up :S
07:00:27 <lome> but i cannot prove it. but i cannot write an implementation that obeys three laws.
07:00:32 <lome> where is it?
07:00:36 <dmhouse> (>>=) :: Stream a -> (a -> Stream b) -> Stream b
07:01:12 <lome> yes. and? i dont understand yet.
07:01:25 <dmhouse> No, I'm just thinking out loud.
07:02:19 <lome> oh.
07:04:19 <Cale> lome: which type?
07:04:30 <Cale> Streams?
07:04:35 <dmhouse> Cale: data Stream a = Cons a (Stream a).
07:04:36 <dmhouse> Yeah.
07:04:39 <Cale> okay
07:04:56 <lome> Cale: data S a = S a (S a)
07:05:02 <lome> Cale: yes
07:05:03 <Cale> right
07:05:29 <Cale> Let's try
07:05:51 <Cale> fmap f (S x s) = S (f x) (fmap f s)
07:05:54 <lome> Cale: ok ;-) I tried about an hour :-)
07:05:58 <lome> Cale: yes
07:06:08 <Cale> return x = S x (return x)
07:06:12 <lome> yes
07:06:44 <lome> join?
07:06:48 <Cale> now, we need an interleave
07:06:57 <Cale> unless we want a stupid join
07:07:03 <dmhouse> interleave?
07:07:09 <Cale> join (S x ss) = x
07:07:16 <Cale> would work, but it's not interesting
07:07:18 <lome> :-)
07:07:24 <lome> it's not work
07:07:36 <Cale> Well, it's a natural map
07:07:43 <Cale> and it ought to obey the ways
07:07:46 <Cale> laws*
07:07:51 <lome> indeed
07:07:55 <Cale> heh, that was an odd typo :)
07:08:02 <lome> :)
07:08:08 <Cale> okay, so let's see...
07:08:40 <Cale> merge (S x s1) (S y s2) = S x (S y (merge s1 s2))
07:09:05 <Cale> join (S xs s) = merge xs (join s)
07:09:20 <Cale> that's more interesting, and I think it will work well
07:09:37 <lome> nope
07:09:42 <Cale> no?
07:09:45 <Cale> what fails?
07:09:50 <lome> (return x) >>= f = f x
07:10:11 <Cale> okay, how does that not hold?
07:10:35 <paolino> I'm trying http://www.cin.ufpe.br/~haskell/hopengl/files/first.hs I have problems with packages
07:10:47 <lome> Cale: one moment
07:11:14 <apfelmus> lome: there is an alternate axiomatisation of monads base on return :: a -> S a and join :: S (S a). the three axioms are:
07:11:17 <apfelmus> fmap join . join = join . fmap join
07:11:20 <apfelmus> join . fmap return = id
07:11:23 <apfelmus> join . return . fmap id = id (?)
07:11:55 <paolino> can someone tell me what I have to change to run it, please ?
07:11:57 <lome> let's x = 1, f 1 = 1 2 3
07:11:57 <lome> then we have at left side 1 1 1 1  and at right 1 2 3
07:12:06 <dmhouse> How do you recover bind again?
07:12:15 <lome> apfelmus: yes I know, thx.
07:13:09 <dmhouse> If you have return/join, I mean.
07:13:21 * int-e wonders what happens if join picks the diagonal of the stream of streams (viewed as an infinite matrix)
07:13:32 <lome> Cale: am I right?
07:13:49 <dmhouse> int-e: Why not, say, the first column?
07:13:57 <neologism> @where jhc
07:13:58 <lambdabot> http://repetae.net/john/computer/jhc/
07:14:06 <int-e> dmhouse: Cale already discounted that as boring
07:14:13 <dmhouse> lome: What would the definition of >>= be?
07:14:25 <lome> join (fmap f m)
07:14:33 <Cale> lome: hmm...
07:14:39 <apfelmus> Cale: your infinite merge touches only the first elements of every stream, i think
07:14:43 <dmhouse> @type (join .) . fmap
07:14:44 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
07:14:50 <Cale> lome: yeah, it's possible that doesn't work
07:14:54 <Cale> apfelmus: hm?
07:15:00 <lome> Cale: :-(
07:15:27 <Cale> oh, I suppose we might be able to just project out the nth components
07:15:32 <Cale> right
07:15:33 <Cale> yes
07:15:52 <lome> Cale: what you mean?
07:15:58 <Cale> tail (S x s) = s
07:16:26 <lome> ...hm. and?
07:16:38 <Cale> join (S (S x _) s) = S x (join (fmap tail s))
07:16:54 <Cale> *that* will work
07:17:21 <lome> Cale: so second law doesnt work! ;-)
07:17:26 <apfelmus> Cale: i don't think your original merge does anything different
07:17:32 <Cale> apfelmus: it does
07:18:37 <lome> Cale: oh, not... it works... wait a second.
07:18:37 <Cale> apfelmus: my original merge combines the sequences like 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 ...
07:19:08 <paolino> Is there a working example for GLUT ?
07:19:14 <lome> Cale: first law yet doesnot work
07:19:20 <apfelmus> Cale: err, i mean join.
07:19:34 <Cale> apfelmus: yes, I do too, sorry
07:19:50 <Cale> where n represents an element from sequence n
07:19:57 <Cale> where they're taken in order
07:20:30 <Cale> every other element is drawn from sequence 1, then every other element of the spots that are left are drawn from sequence 2 and so on
07:21:05 <lome> Cale: i tried this diagonal merging too - it also does not work :-(
07:21:24 <Cale> lome: yes, I'm just explaining to apfelmus what it is
07:22:05 <lome> Cale: so you dont know such type of articles? maybe category theory explains this?
07:22:16 <Cale> lome: hm?
07:22:38 <Cale> lome: Did you try my new join?
07:22:42 <Cale> what fails there?
07:22:51 <neologism> where is the website whcih lists SoC applications?
07:22:53 <lome> How this begins: I tried to find articles about how to prove that type can or not be a monad.
07:23:05 <dmhouse> neologism: applications, or projects?
07:23:07 <lome> Cale: yes I tried. It does not work
07:23:20 <Cale> lome: where does it fail?
07:23:20 <dmhouse> I.e. applications or successful applications?
07:23:27 <lome> you means this:
07:23:27 <lome> join (S (S x _) s) = S x (join (fmap tail s))
07:23:27 <lome> ?
07:23:33 <Cale> yes
07:23:39 <lome> at first law
07:23:45 <Cale> which is the first?
07:23:53 <neologism> dmhouse: applications
07:23:55 <lome> return x >>= f = f x
07:24:11 <Cale> no, that definitely works
07:24:29 <lome> no! look at this:
07:24:29 <Cale> return x = (x,x,x,x,...)
07:24:33 <lome> yes
07:24:38 <lome> then fmap f
07:24:40 <apfelmus> Cale: ah ok, i see. places 2^k,2^k+2^(k+1),..., i.e. (1+2n)*2^k are for sequence k
07:24:51 <Cale> (f x, f x, f x, ...)
07:24:54 <lome> -> ((1,2,3,4...),(1,2,3,4...)...)
07:24:57 <lome> yes
07:24:57 <Cale> then join...
07:25:00 <dmhouse> neologism: Haskell's are on http://hackage.haskell.org/trac/summer-of-code/
07:25:02 <lambdabot> Title: "Haskell.org Google Summer of Code - Trac"
07:25:04 <lome> join (1,1,1,1,)
07:25:07 <neologism> thnx
07:25:09 <int-e> so (f x, f x ...) and extracting the i-th element of each you get f x
07:25:12 <Cale> which takes the nth element of the nth sequence
07:25:13 <lome> but f x == (1,2,3,4)!
07:25:20 <Cale> no
07:25:28 <lome> oh! yes... sorry
07:25:57 <lome> I didnot take into account fmap tail
07:26:01 <jgrimes_> Cale: Monads as Containers is a pretty good introduction. I like the idea of starting with fmap, join, and return first instead of bind. That seems a bit more intuitive to me.
07:26:05 <lome> wait a moment.
07:26:11 <Cale> jgrimes: yeah
07:26:14 <Cale> :)
07:28:10 <dmhouse> So what other laws do we have left to validate?
07:28:42 <dmhouse> m >>= return == m
07:28:53 <dmhouse> That's true.
07:29:15 <Cale> and associativity
07:29:16 <dmhouse> And #
07:29:20 <dmhouse> (m >>= f) >>= g == m >>= (\x -> f x >>= g)
07:29:29 <dmhouse> s/#\n//
07:31:47 <dmhouse> Say m = (1 2 3 4 ...); f x = (x, 2x, 3x, 4x, ...); g x = (x, x^2, x^3, ...)
07:32:46 <int-e> the i-th projection of that should be  g_i (f_i m_i) = (g_i . f_i) m_i  I think.
07:32:56 <dmhouse> Then (m >>= f) >>= g    ==>    (1 2 9 16 ...) >>= g   ==>   (1 4 9^9 16^16)
07:33:21 <dmhouse> No, wait.
07:33:27 <dmhouse> Then (m >>= f) >>= g    ==>    (1 2 9 16 ...) >>= g   ==>   (1 4 9^3 16^4)
07:33:34 <int-e> (in your example, m_i = i, f_i x = i*x, g_i x = x^i)
07:33:45 <lome> (m >>= f) >>= g == m >>= (\x -> f x >>= g)
07:33:45 <lome> left side:
07:33:45 <lome> ((1,2,3,4) >>= (\n -> (n,n+1...)) >>= (\n -> (n,n+2,n+4...)) => (1,5,9...)
07:33:45 <lome> right side:
07:33:45 <lome> (1,2,3,4..) >>= (\x -> (\n -> (n,n+1...)) x >>= (\n -> (n,n+2,n+4...)) => (1,2,3,4...) >>= (\x -> (x,x+3,x+7,x+13) => (1,5,10...)
07:33:47 <lome> hm...
07:34:02 <dcoutts> ndm, if you care enough you can alway use the native one directly in the windows port
07:34:08 <dcoutts> but it'd mean #ifdefs etc
07:34:25 <ndm> dcoutts ?
07:34:27 <ndm> for what?
07:34:37 <dcoutts> for your app, whatever that may be
07:34:48 <ndm> in relation to what program?
07:34:49 <dcoutts> we can't do it in Gtk2Hs itself because we couldn't make it fit the same API
07:34:57 <lome> sorry, guys, i have to go. thank you very much!
07:35:15 <int-e> where'd you get the x+7?
07:35:58 <ndm> i have written my initial version of hat-gui, none of the hat features, but i do have some gtk2hs stuff going - not too bad so far
07:36:08 <dcoutts> ndm, great
07:36:23 <dcoutts> ndm, using glade or building the UI manually in code?
07:36:30 <ndm> dcoutts, glade
07:36:37 <dcoutts> glade is great, specialcially for prototyping
07:36:47 <ndm> which is a nasty program, btw, compared to VB and Visual Studio .NET
07:36:47 <dcoutts> specialcially/especially
07:36:53 <dcoutts> true
07:37:04 <dcoutts> there are several replacements in the pipeline
07:37:21 <ndm> hmm, i wish one of those was by MS, but thats unlikely...
07:37:30 <SamB> heh
07:37:40 <dmhouse> And m >>= (\x -> f x >>= g)   ==>   join (((1 2 3 4) >>= g) (2 4 6 8 >>= g) (3 6 9 12 >>= g)))   ==>   join ((1 4 27 64) (2^1 4^2 6^3 8^4) (3^1 3^2 3^3 3^4))   ==>   (1 16 27 ...)
07:37:42 <dcoutts> of course the 'painting' style of VB doesn't work because that doesn't resize properly
07:37:59 <ndm> dcoutts, i know, but C# handles that perfectly
07:38:02 <dcoutts> it has to use the layout/container stuff
07:38:18 <ndm> much better than Gtk2Hs - or at least as far as I can understand gtk2hs (which I'm very new at!)
07:38:20 <dcoutts> ndm, what sort of GUI does it use for building UIs ther?
07:38:30 <dmhouse> Did I make a mistake, or does it not work?
07:38:46 <ndm> dcoutts, similar design to Glade, just much better designed - just a lot more reliable
07:38:55 <dcoutts> right
07:38:56 <ndm> similar layout stuff, but uses docking rather than split pannels
07:39:05 <dcoutts> there's glade3 and another one written in python
07:39:08 <ndm> although, to be honest, 3 pane panels is probably better than the MS one
07:39:17 <ndm> just the implementation that lets it down
07:39:22 <dcoutts> on of which integrate in the mono ide
07:39:28 <dcoutts> that's for C# & Gtk# etc
07:39:40 <ndm> anyway, have to go now - thanks very much for your Gtk2hs work, hopefully soon i'll have a nice GUI for everyone to play with :)
07:39:44 <Cale> Associativity holds at least for dmhouse's example
07:39:45 <dcoutts> cool
07:39:55 <dmhouse> Cale: so I made a mistake?
07:39:55 <Cale> *Main> let x = fromList [1..]
07:39:56 <Cale> *Main> let f x = fromList [i * x | i <- [1..]]
07:39:56 <Cale> *Main> let g x = fromList [x^i | i <- [1..]]
07:39:56 <Cale> *Main> take 10 $ toList (x >>= f >>= g)
07:39:56 <Cale> [1,16,729,65536,9765625,2176782336,678223072849,281474976710656,150094635296999121,100000000000000000000]
07:39:56 <Cale> *Main> take 10 $ toList (x >>= (\u -> f u >>= g))
07:39:58 <Cale> [1,16,729,65536,9765625,2176782336,678223072849,281474976710656,150094635296999121,100000000000000000000]
07:40:00 <Cale> dmhouse: hm?
07:40:07 <dmhouse> Evidently.
07:40:55 <Cale> Really, this is equivalent to Reader Nat
07:41:05 <Cale> Which is why it ought to be a monad :)
07:41:22 <Cale> (Supposing that Reader is)
07:42:43 <Cale> Does that remark make sense?
07:43:15 <dmhouse> Do we have the same bind?
07:43:19 <Cale> yes
07:43:30 <Cale> after translating via the obvious isomorphism
07:44:10 <Cale> (Send a stream to the function which takes a natural number and returns the element at that position)
07:44:54 <Cale> I sort of expect almost any functor to be a monad in *some* way
07:45:18 <Cale> Probably there are functors which aren't, but they're pretty hard to find.
07:45:56 <Cale> I'm willing to conjecture that all polynomial functors are.
07:46:06 <dmhouse> Ooh, I remember one.
07:46:15 <dmhouse> In that paper about Applicative.
07:47:00 <Cale> Yeah, but was that an example of a functor which wasn't a monad or an idiom which wasn't?
07:47:17 <dmhouse> Ah, fair point.
07:47:18 <Cale> I can't recall what the example was, let me look it up
07:47:33 <dmhouse> @docs Control.Applicative
07:47:33 <lambdabot> Control.Applicative not available
07:47:37 <dmhouse> *sigh*
07:48:11 <dmhouse> pure = repeat
07:48:19 <dmhouse> <*> = zipWith ($)
07:48:35 <Cale> oh, so it's lists?
07:48:56 <dmhouse> Hehe. True.
07:49:30 <dmhouse> But they did state that pure repeat and zipWith ($) weren't the return and >>= for any monad, which is why it jumped out at me.
07:49:38 <dmhouse> s/pure //
07:49:54 <Cale> right
07:52:26 <Cale> There are actually quite a lot of monads, they're not very rare at all, but it's not so easy to find particularly useful ones.
07:55:30 <dmhouse> Aargh! Emacs keeps crashing on me :(
07:56:50 <Cale> Is this where I'm supposed to tell you to use vim?
07:56:51 <dmhouse> Reader t is a monad with const/(.), yes?
07:57:17 <dmhouse> (Ignoring newtype cruft)
07:57:33 <dmhouse> Hang on, that can't be right.
07:57:36 <Cale> not quite
07:57:43 <Cale> join f x = f x x
07:57:51 <Cale> return = const
07:58:04 <Cale> fmap f x = f . x
07:59:03 <Cale> xs >>= f = \k -> f (xs k) k
07:59:07 <dmhouse> So m >>= f = join (fmap f m) = join (f . m) = \x -> (f . m) x x = \x -> f (m x) x
07:59:18 <Cale> yes
08:00:03 <dmhouse> > (+) >>= (^3) $ 3 -- 30?
08:00:04 <lambdabot>  add an instance declaration for (Num (a -> a))
08:00:20 <dmhouse> > (^3) >>= (+) $ 3 -- 30?
08:00:22 <lambdabot>  30
08:00:57 <Cale> > (do x <- (+1); y <- (+2); return (x * y)) 5
08:00:59 <lambdabot>  42
08:02:00 <Itkovian> indeed
08:02:01 <dmhouse> > (do x <- (^3); (+x)) 3
08:02:02 <lambdabot>  30
08:02:20 <psi> dcoutts: what is the gladeish python program called?
08:02:49 <Cale> neat, eh?
08:03:18 <Cale> You can easily write code in this way which will be completely mindbending to anyone who doesn't know what's going on :)
08:03:45 <dmhouse> Wicked. I just grokked the relationship to Reader Nat :) (I saw how the joins were equivalent.)
08:05:28 <int-e> > foldr ((+) . join (*)) 0 [3,4]
08:05:29 <lambdabot>  25
08:06:01 <Cale> square = join (*)
08:06:09 <bolrod> !type join
08:06:20 <Cale> @type join
08:06:22 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:06:33 <Cale> > join (*) 5
08:06:35 <lambdabot>  25
08:06:41 <bolrod> ^.0
08:06:53 <bolrod> join (*) [1,2]
08:06:57 <bolrod> > join (*) [1,2]
08:06:59 <lambdabot>  add an instance declaration for (Num [a])
08:07:07 <dmhouse> > join (*) 4
08:07:09 <lambdabot>  16
08:07:14 <Cale> > join (++) [1,2]
08:07:16 <lambdabot>  [1,2,1,2]
08:08:02 <dmhouse> > join (join (*)) 3
08:08:03 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
08:08:03 <lambdabot>    Expe...
08:08:39 <Cale> square doesn't take two parameters
08:09:13 <Cale> > join (join (\x y z -> x * y + z)) 3
08:09:15 <lambdabot>  12
08:09:25 <dcoutts> psi, http://gazpacho.sicem.biz/
08:09:28 <lambdabot> Title: "Gazpacho. El diseador de Interfaces de Usuario Grficas"
08:09:37 <Cale> > join (join (\x y z -> x * y + z)) 10
08:09:39 <lambdabot>  110
08:10:31 <bolrod> > fix (join (++) [1,2])
08:10:33 <lambdabot>    Expecting a function type, but found `[a]'
08:10:33 <lambdabot>    Expected type: [a1] -> ...
08:10:54 <Cale> > join (++) [1,2]
08:10:56 <lambdabot>  [1,2,1,2]
08:11:10 <dmhouse> > take 20 $ fix (join (++)) [1,2]
08:11:11 <lambdabot>  Couldn't match `[a]' against `t -> [a1]'
08:11:12 <Cale> join f x = f x x
08:11:31 <vincenz> join (join (+)) 1
08:11:48 <vincenz> > join (join (+)) 1
08:11:49 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
08:11:49 <lambdabot>    Expe...
08:11:49 <dmhouse> Doesn't work, vincenz. Tried that already.
08:11:50 <bolrod> > fix (\x -> join (++) [4])
08:11:52 <lambdabot>  [4,4]
08:11:57 <bolrod> :o
08:11:59 <vincenz> dmhouse: I fail to see why
08:12:00 <Cale> for  join (join f)  to make sense, f must have at least 3 parameters
08:12:09 <dmhouse> vincenz: What Cale said
08:12:17 <dmhouse> Otherwise,
08:12:37 <vincenz> oh right
08:12:39 * vincenz coughs
08:12:49 <dmhouse> compose = foldr (.) id; x ^ n = compose (replicate n join) (*) x
08:12:58 <dmhouse> But I don't think that can be easily salvaged.
08:13:34 <Cale> (*) would have to be variadic
08:13:37 <dmhouse> Indeed.
08:14:10 <dmhouse> So x^3 = x * x * x = join (*) x * x
08:14:33 <dmhouse> This'll be ugly, but perhaps:
08:14:56 <Cale> > (join . join) (\x y z -> x * y * z) 3
08:14:57 <lambdabot>  27
08:15:07 <norpan> fix((0:).(1:).ap(zipWith(+))tail)
08:15:26 <vincenz> woot smileys
08:15:27 <dmhouse> norpan: Let me guess. Fibonaccis?
08:15:47 <Cale> ap is fun :)
08:15:47 <norpan> indeed
08:16:33 <Cale> ap f g x = f x (g x)
08:17:26 <Cale> fix(([0,1]++).ap(zipWith(+))tail)
08:17:39 <Cale> ah, exact same number of chars :)
08:18:44 <norpan> i like the smileys
08:19:42 <Cale> perhaps I should type in messages
08:19:45 <psi> dcoutts: have you used it_
08:19:46 <Cale> every one being exactly this long
08:20:10 <dmhouse> Like the char-based version of iambic pentameter?
08:20:19 <dcoutts> psi, last time I used it it was a bit imature, it's probably better now
08:20:19 <Cale> hehe
08:20:27 <norpan> too short
08:20:45 <psi> I'm a bit annoyed at all the windows of glade
08:20:49 <psi> I'm going to try this one
08:21:36 <norpan> having a fixed message length rox
08:21:46 <dmhouse> Iambic 34-ameter, then. (Using 34 rather than 17 as there's no notion of stressed or unstressed characters :))
08:22:53 * dmhouse notices the conversation die away as everyone tries to cram their messages into 34 characters
08:24:37 <norpan> folks just have to get used to it
08:25:00 <dmhouse> I will never be fooled into that!
08:26:05 <bolrod> > length "I will never be fooled into that!"
08:26:07 <lambdabot>  33
08:26:17 <Igloo> dmhouse: If it doesn't have stressed and unstressed syllables then in what sense is it iambic?
08:26:35 <dmhouse> Igloo: it was a very rough analogy.
08:26:45 <dmhouse> Noniambic 34-ameter, then.
08:26:50 <norpan> 33
08:26:56 <fluxx> irc clients should have a character counter, much like mobiles have one for sms messages
08:27:10 <fluxx> that way you could maximize your payload with those 512 character protocol units ;)
08:27:12 <norpan> thirty-three should be the length
08:27:28 <dmhouse> Weird...
08:27:32 <dmhouse> wc is giving me 34.
08:27:42 <dmhouse> It's probably appending a newline.
08:27:44 <bolrod> you sure?
08:27:46 <dmhouse> Or echo is, even.
08:27:59 <dmhouse> echo 'xxx' | wc -c. echo appends a newline.
08:28:00 <norpan> the newline should not be counted
08:28:01 <earthy> yes, echo does that. ;)
08:28:20 <earthy> unless you use -n
08:28:30 <dmhouse> Ah, that's better.
08:29:03 <earthy> and I wonder if this will finally let Proxima compile
08:29:10 <norpan> no punctuation should be included
08:29:31 <Cale> You thought it was thirty-four...
08:29:31 <Cale> but it actually was thirty-three.
08:29:55 <norpan> no punctuation should be included
08:30:22 <norpan> unless you count a hyphen as such
08:30:49 <Cale> but! punctuation, is the-spice-of
08:30:49 <Cale> life. Even-when-it's-all-mixed-up
08:31:06 <dmhouse> Indeed. I have errored greatly :(
08:32:10 <dmhouse> Adding an ellipsis is cheating...
08:32:30 <Cale> We forgive you your errors David.
08:32:53 <norpan> use of a fixed-width font is good
08:33:03 <Cale> unless you finish the sentence!!!
08:33:07 <earthy> so what should one do with spaces
08:33:21 <int-e> we  could  use  spaces   instead.
08:33:48 <int-e> oh, cale  is  way  ahead  of  me.
08:33:58 <earthy> count them or ignore their number?
08:33:59 <norpan> using adjacent spaces is cheating
08:34:04 <Cale> Spaces    should    all    equal.
08:34:07 <dmhouse> I'm forever indebted, ye friends.
08:34:30 <int-e> spa ces can be put in words, too.
08:34:38 <norpan> comma is allowed interpunctuation
08:34:55 <dmhouse> The last one was stretching a bit
08:35:03 <earthy> Therefore my question about space
08:35:13 <norpan> using adjacent spaces is cheating
08:35:33 <earthy> should they be counted or ignored?
08:36:26 <dmhouse> My terminal is looking great now!
08:36:28 <earthy> that is, does the 33 include them?
08:36:49 <dmhouse> Everything perfectly lined up! :)
08:37:14 <Cale> Earthy is not counting his marks.
08:37:40 <dmhouse> Smileys add three chars for free!
08:37:56 <earthy> I thought marks were not counted?
08:38:02 <norpan> eleven times three is thirtythree
08:38:19 <int-e> employ random words of length 16.
08:38:23 <int-e> actinautographic accumulativeness
08:38:26 <earthy> so I used some leeway right there
08:38:54 <earthy> anyway, this is going way too far
08:39:07 <int-e> (I cheated and used a dictionary)
08:39:08 <norpan> only lower case letters is nicest
08:39:18 <Cale> Or perhaps it is far too near? :)
08:39:44 <dmhouse> Where do you find them, int-e? ;)
08:40:07 <earthy> unfortunately, your nicknames are
08:40:25 <earthy> right-aligned in irssi, my client
08:40:37 <fluxx> once saw a 4-character nick chat
08:40:40 <earthy> or rather, are not right-aligned.
08:40:52 <ruffneck> what?
08:40:54 <earthy> therefore the right edges of this
08:40:57 <fluxx> it looked very neat, very proper
08:41:05 <Cale> It is thirty three not thirty two
08:41:11 <int-e> using grep ^................\$ on
08:41:11 <int-e> /usr/share/dict/words worked fine
08:41:30 <earthy> discussion still look quite raggy
08:41:31 <ruffneck> what's wrong with this picture ?
08:41:34 <fluxx> also all words were at most 4 char
08:41:39 <dmhouse> int-e: Eww. grep ^.{12}\$ :)
08:41:48 <dmhouse> Aargh, I forgot! Oops.
08:41:54 <ruffneck> and all the lines spoken here are the same length.. this looks suspicios
08:42:04 <Cale> No! It is falling apart, our game
08:42:17 <fluxx> it did need taking some liberties
08:42:22 <earthy> /usr/bin/ld: Undefined symbols:
08:42:22 <earthy> ___stginit_IOExts_
08:43:30 <int-e> O this will cause unbearable pain
08:43:30 <int-e> Yay, I found another way to cheat
08:43:36 <dmhouse> earthy: rm -rf **/*.hi **/*.o, then try again.
08:43:56 <earthy> dmhouse: I wish it was that easy.
08:44:10 <earthy> unfortunately Martijn's makefile
08:44:21 <earthy> sucks, to the point where I need
08:44:24 <norpan> appending an interjection is ugly
08:44:38 <ValarQ>       
08:44:41 <Cale> Our convention ruffneck is exact:
08:44:41 <Cale> Every message thirty-three chars.
08:44:53 <earthy> to add package lang in many spots
08:45:04 <wilx> Creepy chat :)
08:46:07 <ValarQ> wilx:      !!!
08:46:08 <Cale> Some people are making errors now
08:46:08 <Cale> with thirty-two or thirty four :(
08:46:11 <earthy> even though Martijn says proxima
08:46:26 <earthy> will compile cleanly with ghc 641
08:46:37 <earthy> (yeah, cale, I know, I suck at it)
08:46:50 <wilx> I guess I don't have the right fonts to see ValarQ's message :)
08:47:12 <dmhouse> Nor do I.
08:47:16 <darkgreen> ken lay is dead, he's looking in.
08:47:20 <Cale> ValarQ is using Braille in UTF-8.
08:47:23 <Spark> its braille
08:47:36 <Spark> im not sure wh braille is in unicode
08:47:38 <Spark> why
08:47:42 <earthy> easy.
08:47:53 <Spark> its more of a font than a character
08:47:58 <earthy> ah, no.
08:48:03 <vegai> ValarQ: hot damn that breaks my utf8-aware irssi like a twig
08:48:09 <ValarQ> :)
08:48:20 <earthy> it breaks my fonts, but not my irssi ;)
08:48:21 <vegai> or konsole perhaps
08:48:24 <Spark> im using irssi and its fine
08:48:26 <ValarQ> i believe it's standard UTF-8
08:48:26 <vegai> yeah..
08:48:28 <Spark> more likely konsole
08:48:30 <dmhouse> vegai: probably because your font doesn't have a glyph for every ~16 million chars.
08:48:33 <Spark> i'm using xterm
08:48:40 <Spark> and the default xterm font has it
08:48:41 <Spark> misc.fixed
08:48:43 <dmhouse> Woah, it broke konsole bad.
08:48:51 <dmhouse> Redrawing errors left, right and centre.
08:48:52 <vegai> dmhouse: it does show the braille correctly, but breaks other lines after that
08:48:54 <earthy> Terminal.app to a BSD doesn't work all that nicely
08:48:57 <vegai> and breaks redraws
08:48:58 <Spark> xterm is the only thing ive seen that does unicode properly
08:49:01 <dgoldsmith> There is not a 1:1 relationship between Braille and the same text written in other alphabets. It's not just a glyph-based transcription like a dingbat font. Braille is in Unicode because text written in Braille needs to be representable in a computer, as such.
08:49:07 <dmhouse> vegai: Cool, snap :)
08:49:15 * ValarQ uses irssi with rxvt-unicode
08:49:32 <Cale> Braille is more than font, since:
08:49:32 <earthy> okay, enough proxima headbanging for today
08:49:34 <Cale> it has shorthand words for speed.
08:49:55 <Spark> dgoldsmith: i remember doing it at school, they said it was just a mapping from a-z, numbers, and basic punctuation
08:50:02 <Spark> ah
08:50:05 <Spark> they simplified it then
08:50:07 <earthy> had we not established that using
08:50:39 <earthy> punctuation to get 33 is cheating
08:50:40 <dgoldsmith> Colloquy (Mac OS X app) was able to handle it OK.
08:50:42 <Spark> and rather than just having the braille shorthands as code points, they did the whole lot
08:50:48 <Spark> probably for completeness
08:51:17 <earthy> say, aren't the IFA characters in
08:51:17 <Spark> dgoldsmith: can it do box drawing
08:51:24 <earthy> unicode as well, even though they
08:51:37 <Cale> Not when punctuation is sensible.
08:51:44 <earthy> represent some of the same sounds
08:51:49 <earthy> that are also represented by the
08:52:02 <dgoldsmith> Spark: That's what's called "level 1" Braille. There are other levels of Braille for English, and different Braille mappings for other languages (there are Braille users worldwide).
08:52:04 <earthy> letters in normal alphabets, spark?
08:52:26 <Spark> IFA characters?
08:52:32 <Spark> cant you write stuff on one line :)
08:52:45 <Spark>                                                                
08:52:48 <Spark>     
08:52:50 <dgoldsmith> Spark: I haven't tried Colloquy with box drawing characters.
08:52:51 <Spark>   
08:52:53 <Spark> who can handle that? :)
08:52:56 <Spark>     
08:53:07 <int-e> looks fine here
08:53:18 <dgoldsmith> Well, now I have. :-) It worked, except there were gaps between the lines, and I interjected my comment in the middle.
08:53:23 <Spark> int-e: what with
08:53:24 <Cale> Spark: I can see it just fine. :)
08:53:29 <int-e> xchat
08:53:30 <dgoldsmith> It all lines up, anyway.
08:53:41 <Spark> ive never got pango to render box drawing properly int-e 
08:53:54 <Spark> or is it the original xchat that doesnt use pango
08:53:57 <earthy> IFA == international phonetic alphabet (and I'm tired)
08:54:13 <earthy> (since the abbreviation isn't IFA :))
08:54:24 <dgoldsmith> Right, it's IPA, and it is in Unicode.
08:54:28 <Spark> ive never seen any vector font renders that do unicode properly
08:54:38 <int-e> using the fixed font.
08:54:38 <Cale>   
08:54:38 <Cale>   
08:54:38 <Cale>   
08:54:38 <Cale>   
08:55:05 <Spark> i think rxvt will do unicode if you poke it enough
08:55:07 <int-e> 'the' because it's the same font that the X11 'fixed' font maps to.
08:55:09 <vincenz> Cale: funky
08:55:19 <Spark> ah right
08:55:26 <Spark> xchat2 probably wont work then
08:55:31 <Spark> even with misc.fixed
08:55:34 <Cale> This looks fine here with X-Chat.
08:55:41 <int-e> this is 2.6.4
08:55:46 <Spark> using gtk2?
08:55:54 <Spark> is it antialiased and everything
08:55:54 <int-e> yes. 2.8.something
08:56:03 <Spark> maybe theyve fixed it
08:56:06 <int-e> no. of course not, who'd want that ;)
08:56:18 <Cale> Yes two-point-six-point-one, GTK2
08:56:20 <Spark> maybe its antialiasing that breaks it then
08:56:36 <Spark> or maybe they just fixed it for bitmap fonts
08:56:47 <Cale> My fonts are subpixel-antialiased
08:56:50 <Spark> to get bitmap fonts wrong, you have to be quite clever
08:57:09 <Spark> i bet it doesnt work with a vector font though
08:57:24 <sjanssen> > flip flip (cycle "33 ") take 31
08:57:25 <lambdabot>  "33 33 33 33 33 33 33 33 33 33 3"
08:57:29 <int-e> I really like antialiasing but not for my small standard text font - I prefer that to look the same in terminals, editors and applications.
08:57:35 <Spark> hard to get adjacent chars to join up
08:57:51 <Cale> Andale Mono is the typeface I use
08:57:57 <Spark> i'd like to have an antialised bitmap font
08:58:08 <Spark> something carefully designed so that every char is perfect for the given resolution
08:58:20 <Spark> i dont believe vector renders will ever look as good as that
08:58:42 <Cale> This is less fun when no-one else
08:58:43 <Cale> is trying to make their lines 33.
08:59:00 <Spark> ah is that why this channel is unreadable
08:59:40 <Cale> fix(([0,1]++).ap(zipWith(+))tail)
08:59:56 <Cale> fix((0:).(1:).ap(zipWith(+))tail)
09:00:03 <int-e> Im sorry Cale but this is far too
09:00:03 <int-e> much effort to carry on for long.
09:00:03 <int-e> even with cheating by leaving out
09:00:03 <int-e> apostrophese like in the first li
09:00:11 <int-e> ne. ;-)
09:00:35 <vincenz> Cale: busy?
09:00:55 * int-e wonders where that e in the last line came from.
09:01:30 <Cale> Both those programs were 33 long.
09:01:30 <Cale> So I decided to make all my lines
09:01:30 <Cale> just exactly as long as that. The
09:01:30 <Cale> rest is history. I will stop here
09:01:41 <Spark> .
09:01:46 <int-e> Oh and not being a native speaker doesn't help either. You run out of synonyms more quickly then.
09:01:54 <Spark> use wordnet :)
09:02:37 <Spark> useful for natural language software, and everyone else too
09:02:48 <vincenz> Cale: care to talk briefly about some mathematics in privmsg?
09:02:56 <Cale> sure, what's it about?
09:03:00 <gds> @where HTTP-any
09:03:00 <lambdabot> I know nothing about http-any.
09:03:03 <gds> :/
09:03:10 <gds> Anyone else know anything about it?
09:03:27 <gds> The HXT tarball seems to want it...
09:03:36 <Cale> 
09:03:38 <vincenz> Cale: It concerns boolean logic and decideability
09:03:41 <Cale> who else can see that? :)
09:04:03 <Spark> FOPL? :)
09:04:08 <sjanssen> Cale: I can
09:04:13 <norpan> Cale: I can see it but I don't know what it is
09:04:16 <integral> I can but not properly with small fonts
09:04:29 <Spark> Cale: not me
09:04:32 <Spark> no font
09:04:35 <Cale> 
09:04:38 <Spark> nope
09:04:46 <norpan>  looks like D
09:04:53 <Cale> That should look like a D, but it's actually a Cherokee letter A :)
09:05:00 <int-e> Cale: did the first one use mirc control characters?
09:05:05 <int-e> I saw that
09:05:06 <Cale> int-e: no
09:05:17 <vincenz> Spark: FOPL?
09:05:19 <int-e> what was it?
09:05:25 <Spark> first order propositional logic
09:05:29 <vincenz> Spark: yes
09:05:41 <norpan> Unicode Character 'SINHALA LETTER MUURDHAJA NAYANNA' (U+0DAB)
09:05:58 <int-e> oh. I can select it and paste it elsewhere, but here it's invisible
09:06:22 <Cale> 
09:06:38 <Cale> Myanmar has some crazy characters :)
09:06:58 <vincenz> Basically I'm deciding if my AST has side-effects.  This is not a simple bottom up aproach because of recursive functions.  So when I don't know I generate a variable, annotate my ast with the variable instead and then at opints you might have a => b... Now a => b can be rewritten as a FOPL statement.  So in general given a set of boolean equations that must be true, is this solveable, or should I stick to pure a => b formats instaed of trying to gener
09:07:09 <int-e> 
09:07:24 <Spark> what is ""
09:07:31 * gds actually reads the manual, and finds the module. Doh.
09:07:35 <Spark> it looks like an italic white rectangle
09:07:47 <int-e> ogham letter ruis
09:07:49 <norpan> ruis from ogham
09:07:51 <int-e> says ucharmap
09:07:55 <Spark> ah it goes up and down and up and down
09:08:05 <Spark> just my fontsize is too small to distinguish and squashes them all together
09:08:16 <int-e> same here actually
09:08:18 <Spark>  is like a diamong with a line through it
09:08:26 <norpan> a horisontal line with five slanted verical lines crossing it
09:08:39 <norpan> r
09:08:51 <Spark> i actually editted my misc.fixed font to make the lambda look more like i'm used to
09:09:10 <SamB> "ogham letter ruis" does not render in my xterm...
09:09:14 <vincenz> Spark: you good with FOPL?
09:09:20 <int-e> 
09:09:25 <Spark> i havent done it since my undergrad
09:09:35 <int-e> amazing, that's a single character
09:09:48 <SamB> U+1672 CANADIAN SYLLABICS NNGII 
09:09:54 <SamB> wierd letter
09:10:28 <Cale> 
09:10:34 <norpan> nggii sounds like the sound you make when you are constipated
09:10:37 <Cale> 
09:11:00 <SamB> Cale: "unicode" does not know about those two
09:11:05 <SamB> and they don't render, either
09:11:13 <Cale> They're from Linear B
09:11:25 <int-e> linear B wheeled chariot
09:11:38 <int-e> looking up 'invisible' characters in gucharmap isn't fun ;)
09:11:42 <norpan> yes, linear b is in plane 1
09:11:51 <SamB> that is scary
09:11:51 <Cale> int-e: It's not invisible for me :)
09:12:05 <norpan> it's visible but i don't have the font for it
09:12:29 <SamB> it shows up as 6-character box here
09:14:03 <int-e> Cale: I put the quotes there for a reason.
09:14:20 <Spark> fonts on debian are a bit crap i think
09:14:21 <Cale> int-e: I actually have a Linear B font :)
09:14:23 <Spark> better than windows though
09:14:33 <Spark> i have no real idea whats going on with my fonts
09:14:36 <norpan> 
09:14:39 <Spark> there are so many different systems and things to configure
09:14:40 <Spark> runes
09:14:40 <Cale> runes :)
09:14:55 <Spark> quake
09:15:02 <Cale> 
09:15:05 <Spark> and the fact that some fonts are built out of other fonts
09:15:34 <Cale> 
09:15:48 <SamB> how do I get more stuff in "fixed"?
09:18:26 <int-e> hmm. a not-so-serious suggestion is to use bdfedit and bdftopcf.
09:19:23 <SamB> I meant what might I want to apt-get install?
09:19:31 <int-e> actually the bdfedit I have doesn't know about unicode.
09:22:22 <ndm> @seen dcoutts
09:22:22 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 1 hour, 2 minutes and 3 seconds ago.
09:22:54 <dcoutts> @yarr!
09:22:55 <lambdabot> Shiver me timbers!
09:23:52 <int-e> I'm not sure there even is a more complete fixed font. one of the thing pango does is steal missing characters from other fonts.
09:24:34 <dcoutts> ndm?
09:24:43 <ndm> dcoutts, how do i add a list to a treeview?
09:24:56 <ndm> and is there any introductory thing to working with each of the controls, beyond haddock
09:25:11 <ndm> (and I am definately adding Gtk2Hs to hoogle soon!)
09:25:20 <dcoutts> ndm, not really, it's that or the demo code or C tutorials
09:25:24 <ndm> i mean how do i add an item
09:25:36 <ndm> its deeply confusing with all the classes
09:25:36 <dcoutts> ndm, for treeview/list stuff we're in the middle of an upheaval
09:25:45 <dcoutts> the current api works but is ugly
09:26:07 <dcoutts> ndm, the classes jsut form a signle-inheritance class heirarchy
09:26:12 <dcoutts> like in java
09:26:18 <dcoutts> or C# or whatever
09:26:34 <ndm> it seems more confusing in Haskell, Java is more intuative - i guess because its the normal
09:26:42 <dcoutts> each module documentation has a section showing the parent and chile classes
09:27:32 <ndm> yeah, i saw that
09:29:18 <dcoutts> ndm, for the list stuff, see the C intro and the haskell demo code
09:29:26 <ndm> dcoutts, cheers
09:29:27 <dcoutts> ndm, or himerge uses that extensively
09:29:40 <dcoutts> ndm, the basic idea is that there is a model/view seperation
09:30:13 <dcoutts> ndm, so you add data to a list model, connect it to a view and specify how the veiw renders the data in the model (columns & renderers)
09:30:30 <dcoutts> ndm, I think you'll like the new api we've got after trying the old one... :-)
09:30:38 <dcoutts> but that's still in development
09:30:41 <ndm> cool - i can select the hat file to open, and have rewritten one of the tools as a library, just now need to do the display
09:30:53 <ndm> i know yhe depends on Gtk2hs HEAD
09:31:19 <dcoutts> oh, ok then you can try usign the new api
09:31:27 <dcoutts> see the demo code for that
09:31:37 <dcoutts> it's much nicer
09:31:50 <ndm> i don't have gtk2hs head yet though, and am probably going to stick with what i have for a bit - i just want a demo
09:31:59 <ndm> something with some use - literally just adding lines
09:31:59 <dcoutts> ok
09:32:11 <ndm> then i can go back to the hat developers, point out their repo is structured wrong for this
09:32:22 <ndm> have the "are gui's the root of all evil" debate
09:32:30 <ndm> then onlly after that, get back to hat-gui
09:33:17 <ndm> so do i need to call emptyListSkel to set up the store?
09:33:47 <dcoutts> ndm, avid the mogul package, it's deprecated
09:34:02 <ndm> oh, thats the listview example in the demos docs
09:34:54 <dcoutts> mm, yeah, let me find a beter example...
09:37:18 <ndm> i think i have a handle on it now, with the list view model - should be ok
09:38:32 <ndm> hmm, actually, i have no idea how to insert an item into a ListStore - i really need Hoogle
09:39:40 <dcoutts> http://darcs.haskell.org/hIDE/packages/gtkBase/src/Hide/IdeShell/FileBrowser.hs
09:39:48 <dcoutts> ndm, that's an example using a tree view
09:39:55 <dcoutts> I've got a list one too somewhere...
09:40:13 <dcoutts>             newRow <- Gtk.listStoreAppend store
09:40:13 <dcoutts>             Gtk.listStoreSetValue store newRow 0 (Gtk.GVstring (Just label))
09:40:31 <dcoutts> all the generic value stuff is ugly, our new api is much nicer
09:41:12 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-TreeList-ListStore.html
09:41:23 <psi> dcoutts: this autoconnect thing of libglade, is that something you could accomplish in haskell?
09:41:37 <dcoutts> psi, I don't see how sadly
09:41:40 <dcoutts> any ideas?
09:41:54 <psi> no, I've barely thought about it
09:42:18 <dcoutts> perhaps an IDE could help, if you followed some convention
09:42:33 <ndm> dcoutts, thanks, i think i get that now
09:42:44 <ndm> the hide example really helps :)
09:42:44 <psi> seems to work in python
09:42:55 <dcoutts> @where himerge
09:42:55 <lambdabot> http://www.haskell.org/~luisfaraujo/himerge/
09:43:37 <dcoutts> ndm, himerge uses lots of trees/lists using the old api
09:43:50 <dcoutts> it should be a better source of examples
09:47:35 <vincenz> @type liftM
09:47:37 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
10:23:23 <ndm> @hoogle liftM
10:23:25 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
10:23:25 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
10:23:25 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
10:37:37 <sjanssen> @. elite quote
10:37:38 <lambdabot> AzTrOl48e sAY$: i PUT my 7Hing iN in\/3R+ed COMM4z 83cau$3 i+ i5n'7 A REALLY S7al4cTiT3, BU7 IT LoOk5 LIKE 0n3, AnD CoNTains NITR4+ES FrOM urEa.
10:39:33 <dcoutts> SyntaxNinja, evenging
10:39:55 <dcoutts> SyntaxNinja, I've had second thought about my proposal on cabal-devel
10:40:03 <dcoutts> it'd make versioning really ugly
10:40:12 <dcoutts> since the types would have to match exactly
10:43:53 <SyntaxNinja> dcoutts: haven't read it yet.  post a followup :)  I see 3 emails from you in a row
10:44:13 <dcoutts> yeah I'm just talking to myself again
10:46:12 <SyntaxNinja> Igloo: how do you generate the dates for ghc-cvs? is there any dh_helper for that, or do you just do it by hand in the makefile?
10:46:44 <Igloo> By hand
10:46:56 <Igloo> Normal dh_* commands run too late to be useful
10:51:04 <SyntaxNinja> Igloo: thanks.
10:52:01 <ndm> dcoutts, http://www-users.cs.york.ac.uk/~ndm/projects/hat-gui.png
10:52:20 <dcoutts> ndm, looks nice
10:52:52 <ndm> dcoutts, is there a rich text box for Gtk+ ?
10:53:02 <ndm> i.e. where i can set the colour of each character/block of characters?
10:53:13 <dcoutts> ndm, yes TextView
10:53:26 <dcoutts> again it's model/view like the list/tree stuff
10:53:38 <ndm> that model/view thing scares me a lot...
10:53:40 <dcoutts> ndm, it's quite powerful, the hIDE syntax highliting uses it
10:53:46 <ndm> but i'll give it a whirl tomorrow
10:53:55 <ndm> i only want read only, so its easier for me
10:54:19 <dcoutts> ndm, for highliting within a list widget I think you could use pango markup
10:54:28 <dcoutts> ndm, readonly is possible too
10:54:36 <ndm> ah, these are things for the future
10:54:46 <dcoutts> ndm, btw you can make the scroll bars only appear when necessary, rather than all the time, if you prefer
10:54:50 <ndm> have sent my "shall we have a hat gui" email off, now just have to wait for flames
10:54:55 <ndm> dcoutts, that would be very nice :)
10:54:56 <ndm> how?
10:54:59 <dcoutts> heh, good luck
10:55:09 <dcoutts> oh, it's a property of the scroll window I think
10:56:02 <ndm> dcoutts, done now - that looks better :)
10:56:06 <dcoutts> scrolledWindowHscrollbarPolicy, scrolledWindowVscrollbarPolicy
10:56:14 <vincenz> ndm: what is that hat gui
10:56:17 <dcoutts> oh, or do it with glade, yes that's easier
10:56:24 <ndm> i did it with glad
10:56:30 <ndm> vincenz: have you heard of hat?
10:56:34 <vincenz> ndm: nope
10:56:53 <ndm> @where hat
10:56:53 <lambdabot> http://www.cs.york.ac.uk/fp/hat
10:57:05 <ndm> @where+ hat http://haskell.org/hat
10:57:06 <lambdabot> Done.
10:58:00 <ndm> vincenz: a haskell debugger
10:58:07 <vincenz> ndm: ah cool
10:58:14 <neologism> I never managed to make hat work
10:58:39 <ndm> neologism: me neither...
10:58:51 <ndm> but i'm working on it - its mainly just library issues now
11:37:14 <matthia1> grouped :: Int -> [a] -> [[a]]
11:37:14 <matthia1> grouded n [] = [] -- never reached!
11:37:14 <matthia1> grouped n l = (take n l) : (grouped n (drop n l))
11:37:14 <matthia1> putStr $ show $ grouped 8 [1,2 .. 5]
11:37:25 <matthia1> Hi, does anybody know, why the first line is never reached?
11:37:27 <matthia1> thank you.
11:38:35 <jgrimes_> matthia1: you have a type on the second line
11:38:43 <sjanssen> > let grouped n [] = []; grouped n l = take n l : grouped n (drop n l) in grouped 8 [1..5]
11:38:43 <jgrimes_> matthia1: "grouded" instead of "grouped"
11:38:44 <lambdabot>  [[1,2,3,4,5]]
11:38:55 <jgrimes_> typo*
11:39:15 <sjanssen> matthia1: looks okay to me
11:39:22 <matthia1> oh, thanks.
11:40:11 <matthia1> now, it works.
11:40:15 <jgrimes_> :)
11:40:49 <matthia1> btw: is there a function in the standard lib of ghc which does the same kind ouf grouping / partitioning?
11:41:59 <eivuokko> Data.List.group and Data.List.partition and By-versions of them.
11:43:04 <int-e> not really. no there is no such function.
11:43:37 <matthia1> too bad.  thanks.
11:43:47 <eivuokko> Ah, the question had context, sorry missed it.
12:07:29 <Cale> grouped n = map (take n) . takeWhile (not . null) . iterate (drop n)
12:07:50 <Cale> matthia1: you might like that implementation though
12:08:08 <int-e> it's more comprehensible than the unfoldr one
12:08:47 <int-e> grouped n = takeWhile (not . null) . unfoldr (Just . splitAt n)
12:35:07 <vincenz> re
12:45:09 <ihope> So there aren't any Windows binaries for Curry?
12:54:16 <vincenz> a truly portable haskell compiler would be cool
12:54:27 <vincenz> so you can just stick it on a usbstick and you always have it with you
12:58:55 <sjanssen> vincenz: you could probably install hugs on a usbstick
12:59:04 <vincenz> sjanssen: not platform independently
12:59:54 <sjanssen> sure, but the individual distributions are small, the MinHugs installer is only 1.5 MB, and there's a Linux tarball at 2.7 MB
13:00:16 <vincenz> sjanssen: and the linux one is linux independent?
13:00:35 <sjanssen> hmm, good point
13:00:41 <vegai> yhc generates bytecode, perhaps that could do it ... some day
13:00:50 <vincenz> vegai: what kind of bytecode?
13:01:16 <sieni> vincenz: why not? if it's statically linked and uses only basic system calls, it should be pretty portable, right?
13:01:20 <sjanssen> vincenz: it's own format -- but I've read of projects to compile to Java or .Net bytecode
13:01:27 <vincenz> sieni: true, though I'm not sure it is
13:01:47 <vegai> vincenz: what do you mean? It's "cross platform, architecture independent" (http://www-users.cs.york.ac.uk/~ndm/yhc/)
13:01:48 <lambdabot> Title: "yhc - York Haskell Compiler"
13:01:52 <vincenz> sjanssen: well given that (and I wish it were another VM honestly) java is installed pretty much anywhere.. 
13:02:20 <vincenz> vegai: yeah... after installation of the runtime
13:02:27 <vincenz> vegai: most computers don't come with a c compiler
13:02:34 <vincenz> I'm thinking haskell anywhere
13:02:35 <sieni> vincenz: It should be. (there are occasionally some new system calls, but if the gnu c library uses them, I think you can disable them)
13:02:47 <sieni> by using configure options
13:02:47 <ihope> Telnet stick!
13:02:49 <vegai> oh, you're asking for sort-of-a-miracle then ;)
13:03:09 <vincenz> vegai: well no, most computers do come with a java vm, now I don't think java vm is really a good vm, but oh well
13:03:22 <ihope> Plug it into the Ethernet port, and it pretends to be a what-do-you-call-it.
13:03:39 <vincenz> ihope: a server?
13:03:46 <ihope> Yeah.
13:03:46 <sjanssen> vincenz: how about an IRC client that just sends queries to lambdabot?
13:04:10 <vincenz> sjanssen: irc is not supported everywhere either, besides the aspect of a client, port blocking and proxies are another issue
13:04:28 <vincenz> we need a skype for haskell :D
13:04:35 <ihope> And the thingy would have things that you could spin to select the IP address...
13:05:09 <sjanssen> @where yhc
13:05:10 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
13:05:32 <vincenz> sjanssen: two different terminologies of portable
13:06:32 <sjanssen> yhc bytecode is supposed to be pretty simple, I bet a mere mortal could hack up a Java version of the runtime
13:07:02 <sieni> methinks that one can use a vm for portability and native compilation for speed and get the best from both worlds simultaneously
13:07:15 <vincenz> sjanssen: now if ghc and other bigger haskell compilers could compiler haskell++ to haskell98
13:07:22 <vincenz> sieni: agreed
13:07:51 <vincenz> sjanssen: tho most likely that's not possibel as I bet the new stuff requires extra parts in the runtime
13:08:11 <vincenz> mptc's, fd's, gadt's
13:08:17 <sieni> that's why I think that native compilers should have a portable bytecode target to address must-have-portability issues
13:08:56 <vincenz> sieni: and then also have a bytecode versoin of the more mature compilers
13:09:10 <vincenz> except ghc isn't written in pure haskell
13:10:41 <vincenz> tom shackell on irc?
13:39:20 <ihope> s/the thingy would have things/the stick would have thingies/
13:39:44 <roconnor> *Data.Digest.SHA1> sha1 (replicate 1000000 'a')
13:39:46 <roconnor> "*** Exception: stack overflow
13:39:48 <roconnor> :(
13:40:55 <roconnor> shouldn't happen
13:40:56 <ihope> If SHA uses right folds, that's not going to work any time soon :-)
13:41:11 <mux> looks like SHA could use some more laziness
13:41:17 <ihope> But it uses left folds, doesn't it?
13:41:32 <mux> it doesn't need all the data to start computing stuff
13:41:34 <roconnor> I see no signifigant fold rights
13:41:39 <mux> obviously I should say
13:42:17 <sjanssen> roconnor: is the code compiled with -O?
13:42:35 <roconnor> sjanssen: I just tried that, but same result, but faster!
13:42:47 <sjanssen> heh, nice
13:43:08 * roconnor wonders if it is easy for me to post a link to the source code.
13:43:17 <ihope> pastebin.ca?
13:43:27 <ihope> Much better than pastebin.com :-)
13:43:43 <mux> mmm, TLD flamewar!
13:44:00 <ihope> No, it's the Battle of the Pastebins.
13:44:17 <cjay> is lisppaste not enough?
13:44:30 <_Codex> pastewars..
13:44:36 <ihope> What's the URL?
13:44:39 <mux> damn, there's no pastebin.fr it seems
13:44:41 <cjay> ?where paste
13:44:42 <lambdabot> http://paste.lisp.org/new/haskell
13:44:47 <mux> well there is, but it's not all that useful
13:44:50 <ihope> Too hard to remember :-P
13:44:56 <sjanssen> lisppaste2: url
13:44:56 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:45:02 <cjay> then bookmark it :>
13:45:02 <roconnor> http://darcs.haskell.org/crypto/Data/Digest/SHA1Aux.hs
13:45:29 <ihope> http://pastebin.ru/ <- anybody speak Russian?
13:46:44 <roconnor> *Data.Digest.SHA1Aux> length $ sha1_step_1_2_pad_length (replicate 1000000 'a')
13:46:44 <roconnor> *** Exception: stack overflow
13:46:50 <roconnor> that's a bad start
13:48:04 <roconnor> maybe ((c64 + 8) `mod` (2^64))  is building up and not being executed?
13:48:08 <sjanssen> anyone else have trouble connecting to darcs.haskell.org ?
13:48:24 <ihope> Use lots of strictness.
13:48:35 <cjay> resolving that host takes long time for me
13:48:46 <roconnor> how do I use seq?
13:49:02 <sjanssen> roconnor: carefully ;)
13:49:38 <norpan> + should be strict if monomorphic, right?
13:49:40 <roconnor> @type seq
13:49:41 <lambdabot> forall b a. a -> b -> b
13:49:47 <sjanssen> > let x = 2 in x `seq` 2*x
13:49:48 <lambdabot>  4
13:51:44 <roconnor> *Data.Digest.SHA1Aux> length $ sha1_step_1_2_pad_length (replicate 1000000 'a')
13:51:44 <roconnor> 1000064
13:52:08 <sjanssen> roconnor: here's a handy trick to get strictness in an argument: "sha1_step_1_2_work c64 _ | c64 `seq` False undefined"
13:52:42 <roconnor> heh
13:52:44 <norpan> !c64 would be great syntactic sugar for that
13:52:50 <roconnor> yes
13:52:57 <sjanssen> norpan: there is in GHC 6.5
13:53:06 <norpan> oh, there is?
13:53:35 <vincenz> how do I do a zipwith while at the same time retaining what was not zipped with?
13:53:57 <sjanssen> norpan: yeah, with -fglasgow-exts
13:53:59 <vincenz> I guess it's a roll your own?
13:54:53 <vincenz> @type concat
13:54:55 <lambdabot> forall a. [[a]] -> [a]
13:55:11 <roconnor> Prelude Data.Digest.SHA1Aux> sha1 (replicate 1000000 'a')
13:55:11 <roconnor> "34aa973cd4c4daa4f61eeb2bdbad27316534016f"
13:55:22 <vincenz> roconnor: cool
13:56:02 <roconnor> and it is even right
13:56:20 <roconnor> and I can easily make a patch I suppose
13:56:25 <vincenz> well of course Left typically signifies an errormessage
13:56:46 <roconnor> actually it still seems to take a lot load of memory
13:56:53 <roconnor> hmmm
13:57:03 <roconnor> but better than stack overflow
13:57:04 <sjanssen> roconnor: adding strictness is what fixed it?
13:57:10 <vincenz> @type foldr
13:57:11 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
13:57:23 <roconnor> sha1_step_1_2_work c64 (c:cs) = let c64' = ((c64 + 8) `mod` (2^64)) in
13:57:23 <roconnor>        c64' `seq` c:sha1_step_1_2_work c64' cs
13:57:28 <roconnor> that's my patch
13:58:11 <vincenz> @pl (\e (l,i) -> ((e,i):l,i+1))
13:58:13 <lambdabot> (`ap` snd) . (. fst) . flip flip (1 +) . (liftM2 (,) .) . flip . ((:) .) . (,)
13:58:29 <sjanssen> it might be worth it to turn "type XYZ" into "data XYZ = XYZ !Word32 !Word32 !Word32"
13:58:38 <sjanssen> and give GHC -funbox-strict-fields
13:59:27 <sjanssen> if XYZ or ABCDE are used in any inner loops
14:02:05 * sjanssen is tempted to download and hack
14:06:34 <roconnor> sjanssen: apparently it is easy
14:07:49 <roconnor> sjanssen: while you are at it, write me a SHA-256 and SHA-512 ;)
14:08:49 <vincenz> I never quite understood what happens if you change how monad transformers are layered
14:08:57 <sjanssen> roconnor: probably won't do that . . . but I may tune the code that's been written for "fun"
14:09:24 <roconnor> How do I figure out who to send my patch to?
14:10:32 <Igloo> roconnor: You might want to look at the darcs SHA.lhs, as I think that has improvements not in the crypto one, BTw (although they're mixed in with changes to make it use PackedString instead of String)
14:11:46 <mux> is this code able to take advantage of cryptographic hardware through /dev/cryptodev ? :-)
14:13:51 * mux likes asking annoying questions
14:14:32 <roconnor> Igloo: where do I find SHA.lhs?
14:14:53 <Igloo> In the darcs source
14:14:57 <roconnor> *l*
14:15:12 <roconnor> But this is all wrong anyways.  It shouldn't use strings
14:15:26 <roconnor> strings are unicode, sha works on lists of octets.
14:15:36 <SamB> well...
14:15:36 * roconnor isn't so sure what a packed string is.
14:15:41 <SamB> what do you expect?
14:16:05 <roconnor> I expect sha1 :: [Word8] -> Word160
14:16:35 <roconnor> and then sha1ascii on top of that.
14:16:36 <SamB> lots of Haskell code does that for one reason or another -- mainly because the standard IO facilities don't support binary files...
14:16:52 <roconnor> I suppose that is vaugely fair
14:17:03 <roconnor> bah Haskell 98
14:17:31 <SamB> you can't expect all programs to do the right thing until the right thing is at least agreed on by a lot of people
14:17:52 <SamB> and even then you can't expect old code to be updated for a while
14:17:58 <sjanssen> lots of Haskell code confuses Char for Word8 -- but code that does is wrong
14:18:01 <SamB> especially for such major things
14:18:38 <roconnor> I'll write a replacement sha module, eventually.
14:18:52 <SamB> sure its wrong -- but right code hasn't been portable
14:19:20 <SamB> (wrong code hasn't either, I suppose...)
14:19:35 <SamB> but has at least worked on Unix, for the most part
14:20:42 <kpreid> Is there a function in GHC's libraries for reading numbers in arbitrary (well, integer >=2) bases?
14:21:34 <norpan> yeah, everyone knows that Char is Word20.1
14:21:49 <roconnor> @type Numeric.readHex
14:21:50 <lambdabot> forall a. (Num a) => ReadS a
14:21:51 <SamB> hmm?
14:21:53 <roconnor> @type Numeric.readOct
14:21:54 <SamB> 20.1?
14:21:55 <lambdabot> forall a. (Num a) => ReadS a
14:21:57 <roconnor> @type Numeric.readDec
14:21:58 <lambdabot> forall a. (Num a) => ReadS a
14:22:01 <SamB> > 2 ^ 20.1
14:22:02 <lambdabot>  Add a type signature
14:22:03 <norpan> yeah, 20.1 bits :)
14:22:06 <SamB> > 2 ^ 20.1 :: Double
14:22:07 <lambdabot>  Add a type signature
14:22:10 <norpan> use **
14:22:13 <SamB> > 2 ** 20.1 :: Double
14:22:15 <int-e> @type Numeric.readInt
14:22:15 <lambdabot>  1123835.9302524573
14:22:16 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
14:22:23 <roconnor> oooh there is readInt
14:22:27 <roconnor> does that do it?
14:23:02 <SamB> > printf "0x%x" (2 ** 20.1 :: Double) :: String
14:23:03 <lambdabot>  Exception: Printf.printf: bad argument
14:23:16 <SamB> what, no printing floating-point numbers in hex?
14:23:33 <roconnor> > Numeric.readInt 3 (const undefined) (const undefined) "222"
14:23:34 <lambdabot>  Undefined
14:23:39 <int-e> > readInt 3 (\x -> '0' <= x && x < '3') ord "101"
14:23:40 <lambdabot>  [(634,"")]
14:23:42 <kpreid> > Numeric.readInt 16 (const t) Char.digitToInt "A0"
14:23:43 <lambdabot>  Not in scope: `t'
14:23:50 <kpreid> > Numeric.readInt 16 (const True) Char.digitToInt "A0"
14:23:52 <lambdabot>  [(160,"")]
14:23:52 <SamB> > printf "0x%x" (round (2 ** 20.1 :: Double)) :: String
14:23:53 <lambdabot>  Add a type signature
14:23:54 <zeeeee> hi all, is there an editor/ide/ide mode that can properly indent haskell? so far, i've tried vim and emacs, which seem brain-dead in this department
14:23:54 <int-e> > readInt 3 (\x -> '0' <= x && x < '3') (\x -> ord x - ord '0 "101"
14:23:55 <lambdabot>  Improperly terminated character constant
14:23:58 <int-e> > readInt 3 (\x -> '0' <= x && x < '3') (\x -> ord x - ord '0') "101"
14:23:59 <SamB> @type round
14:24:00 <lambdabot>  [(10,"")]
14:24:00 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:24:09 <kpreid> > Numeric.readInt 16 (const True) Char.digitToInt "FF"
14:24:11 <lambdabot>  [(255,"")]
14:24:16 <SamB> > printf "0x%x" (round (2 ** 20.1 :: Double) :: Integer) :: String
14:24:17 <lambdabot>  "0x1125fc"
14:24:37 <zeeeee> > --
14:24:37 <lambdabot>  Parse error
14:24:45 <int-e> > 0 -- 1
14:24:45 <lambdabot>  0
14:24:51 <zeeeee> > -- 1
14:24:51 <lambdabot>  Parse error
14:24:52 <SamB> > printf "0x%x" (round (2 ** 20.1:: Double) - 1 :: Integer) :: String
14:24:53 <lambdabot>  "0x1125fb"
14:24:55 <zeeeee> > 0 --
14:24:56 <lambdabot>  0
14:25:15 <SamB> > "hello" -- this is a comment
14:25:16 <lambdabot>  "hello"
14:25:20 <zeeeee> > putStrLn "hello"
14:25:21 <lambdabot>  No IO allowed
14:26:43 <zeeeee> > [0..]
14:26:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:27:32 <zeeeee> > foldr (+) [0..] 0
14:27:33 <lambdabot>  add an instance declaration for (Num [[a]])
14:27:42 <zeeeee> > foldr (+) 0 [0..]
14:27:43 <lambdabot>  Exception: stack overflow
14:28:11 <zeeeee> @t 3
14:28:11 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
14:28:16 <zeeeee> @type 3
14:28:17 <lambdabot> forall t. (Num t) => t
14:28:19 <zeeeee> > :t 3
14:28:20 <lambdabot>  Parse error
14:30:31 <zeeeee> hi all, is there an editor/ide/ide mode that can properly indent haskell? so far, i've tried vim and emacs, which seem brain-dead in this department, and i was hoping folks here could point me in the right direction
14:31:53 <psi_> emacs has the best I've seen, but as you pointed out it has issues
14:32:44 <fanopanik> emacs works for me
14:33:14 <psi_> particularly do-blocks are weird sometimes
14:33:19 * vincenz hmms
14:33:24 <zeeeee> psi_: same here
14:33:26 <vincenz> Cale: ping
14:33:31 <zeeeee> they just creep toward the right 
14:33:48 <Cale> vincenz: hi
14:34:02 <vincenz> Cale: question regarding transformers... I have an action that requires two differentm onads
14:34:03 <psi_> zeeeee: it just inserts tabs?
14:34:08 <vincenz> I have defined them as transformers
14:34:23 <zeeeee> fanopanik: when you're in a 'do' block, your indentation doesn't increase with each line?
14:34:30 <zeeeee> psi_: it's like this:
14:34:32 <vincenz> do I now also need to define a custome monad that inmplements all three?
14:34:34 <fanopanik> lemme checkl
14:34:39 <vincenz> or is ther esome way to make sure they work with each other?
14:34:49 <zeeeee> main = do
14:34:58 <zeeeee>   somefunc alpha
14:35:10 <fanopanik> zeeeee: no
14:35:17 <zeeeee>            beta gamma delta
14:35:28 <fanopanik> everything is by default alligned right of the do
14:35:29 <zeeeee>                 epsilon
14:35:56 <psi_> I don't get that.
14:36:07 <zeeeee> psi_: er, i should've called beta and epsilon somefunc2 and somefunc3
14:36:17 <zeeeee> hmmm
14:36:46 <psi_> okay, wait
14:36:48 <vincenz> Cale: additionally, is there a big difference if you layer transformers differently?
14:37:26 <psi_> I actually do get that, but is that actually legal indentation to begin with?
14:37:36 <Cale> vincenz: there can be, it depends
14:37:50 <psi_> I tend to do:
14:37:50 <zeeeee> psi_: no, it's not, that's why it's bad, i have to re-align everything
14:37:51 <vincenz> Cale: I have a supply monad, a scope monad and a monad that has some stateT inside
14:37:52 <Cale> vincenz: I'm not sure I understand what your first question is though
14:38:02 <psi_> main =
14:38:06 <psi_>   do foo
14:38:09 <psi_>      bar
14:38:12 <vincenz> Cale: oasis? less spam
14:38:13 <cjay> of cause it is legal
14:38:27 <psi_> zeeeee: that indents properly in emacs
14:38:39 <kpreid> vincenz: ooh, sounds like you have a similar mess to mine!
14:38:44 <vincenz> kpreid: oh?
14:38:52 <vincenz> kpreid: join as well then ;)
14:38:55 <psi_> zeeeee: I meant your original method of moving your stuff to the left of the 'do'
14:38:58 <kpreid> data Exec a = Exec (ErrorT Exception (ReaderT Universe IO) a)
14:39:09 <kpreid> -- I need to add escape continuations to this
14:39:09 <vincenz> kpreid: yeah it's annoying you have to define a newtype 
14:39:17 <zeeeee> psi_: as soon as you have args to foo and bar, though, you're back in my situation
14:39:23 <vincenz> kpreid: what is that for?
14:39:49 <kpreid> vincenz: a dynamic language (or at least, execution model) implemented in Haskell
14:39:49 <cjay> psi, the firste non-whitespace char after do is where the block begins, so a newline after do is legal
14:39:49 <psi_> zeeeee: yeah, press tab twice
14:39:57 <vincenz> kpreid: which one,
14:39:58 <zeeeee> psi_: OH
14:40:02 <zeeeee> holy moly
14:40:03 <kpreid> vincenz: E
14:40:08 <vincenz> kpreid: I'm also working on ac ompiler/interpreeter
14:40:17 <psi_> cjay: okay
14:40:21 <vincenz> kpreid: though my language is more akin to miniML, albeit with toplevel recursion
14:40:27 <zeeeee> thanks
14:41:15 <kpreid> vincenz: maybe you want to compile your language to closures, so you don't need a scope in the monad (assuming it's runtime-lexical scope)
14:42:07 <kpreid> myself, I've been trying to insert ContT in my type, and getting type errors that I don't fully understand; possibly I can't use ContT, but I don't know what I should use instead
14:42:18 <vincenz> kpreid: the scope is for functions, although granted it could be a pure reader
14:45:55 <zeeeee> still, i would hope there's some ide/editor that can realize that i (have|haven't) finished giving all args to a function and thus indents the next line accordingly
14:46:51 <joe_k> haskell is so syntaxless that seems hard without deeper knowledge on the part of the editor
14:47:08 <norpan> the editor needs type inference to do it
14:47:18 <zeeeee> joe_k: well, that's what i mean, it would require the editor to know the function signatures
14:47:50 <norpan> more than that
14:49:04 <Philippa> it'd need both type inference and knowledge of the use-site of the result
14:49:07 <zeeeee> norpan: type inference would also be very useful for 'squiggly-red-underlining' errors in your code, on the fly
14:49:19 <Philippa> otherwise, it can't tell you didn't intend a partial application
14:49:37 <norpan> zeeeee: well yes, and that's what the hide people will fix for us
14:50:30 <Philippa> having access to the faulty typing would also be good
14:50:33 <zeeeee> norpan: ah, gotcha... 
14:52:30 <zeeeee> norpan: do you know if they have any source code yet?
14:52:48 <norpan> you'd have to ask one of them i think
14:52:50 <zeeeee> (available source code)
14:52:51 <zeeeee> oh
14:52:53 <norpan> http://www.haskell.org/hawiki/hIDE
14:52:58 <lambdabot> Title: "hIDE - The Haskell Wiki"
14:53:41 <zeeeee> oh the repos is at http://scannedinavian.com/repos/hIDE
14:54:06 <zeeeee> nvm, 404
14:56:30 <psi_> the problem I was refering to was lets within do-blocks
14:57:08 <psi_> the following line won't line up properly
14:59:38 <cjay> i think this page is newer: http://haskell.org/haskellwiki/HIDE
14:59:41 <lambdabot> Title: "HIDE - HaskellWiki"
14:59:42 <cjay> the repo is linked there
15:26:46 <kpreid> is there a HTTP-accessible Haskell evaluator like lambdabot?
16:09:33 <vincenz> \o/
16:10:01 <palomer>  /Y\
16:10:09 <vincenz> LOL
16:10:16 <vincenz> palomer: I just wrote a coold little algo
16:10:23 <vincenz> given a list of implications
16:10:34 <vincenz> find the minimal set of variables to ensure it's true
16:10:48 <palomer> minimal set of variables?
16:11:08 <vincenz> minimize [["a"] :=> "b", ["b"] :=> "a"] -> {}
16:11:21 <vincenz> minimize [["a"] :=> "b", ["b"] :=> "a", [] :=> ["a"]] -> {"a", "b"}
16:11:31 <vincenz> minimize [["a"] :=> "b", ["b"] :=> "a", [] :=> "a"] -> {"a", "b"}
16:12:01 <palomer> horn clauses?
16:12:06 <vincenz> no
16:12:07 <vincenz> pure implication
16:12:09 <vincenz> no negation
16:12:42 <palomer> horn clauses have negation?
16:12:45 <vincenz> tho... maybe that is horn clauses, I don't know what horn clauses are (only by name)
16:13:09 <palomer> a ^ b ^ c ^ .. -> h
16:13:17 <vincenz> ah right
16:13:20 <vincenz> horn clauses
16:13:20 <vincenz> yep
16:13:26 <palomer> and you want to find ... ?
16:13:51 <vincenz> the minimal set of variables that have to be True to make all the horn clauses tautologies
16:14:12 <palomer> if it exists
16:14:17 <vincenz> it always does
16:14:39 <vincenz> the algorithm is utterly simple
16:14:45 <palomer> these sets are totally ordered?
16:14:54 <vincenz> that's irrelevant
16:15:12 <palomer> who says that a unique minimum exists?
16:15:19 <palomer> there might be many least elements
16:15:22 <vincenz> nope
16:15:23 <palomer> (in the lattice of sets)
16:16:42 <vincenz> I fail to see the difficulty
16:16:48 <vincenz> the algorithm to solve it is simple
16:17:06 <palomer> a 
16:17:07 <palomer> err
16:17:12 <vincenz> and it's O^3 worst case, but O^2 in most practical cases
16:17:25 <vincenz> unless you have N variables as condition to another variable
16:18:37 <palomer> I remember looking into this before
16:19:05 <vincenz> look, the algo is simple: I find all clauses that are purely () -> x
16:19:09 <vincenz> those are true
16:19:20 <vincenz> and then remove thoses x's from the left side of the remaining clauses
16:19:22 <vincenz> rinse and repeaet
16:19:50 <vincenz> http://rafb.net/paste/results/TKTank11.html
16:20:45 <palomer> ok, what do you do when you no longer have any clauses of that form?
16:20:51 <vincenz> then I stop
16:20:59 <vincenz> I found my minimal set that satifies the horn clauses
16:21:04 <vincenz> a -> b and b -> a means
16:21:06 <vincenz> a <=> b
16:21:12 <vincenz> a and b both false satisfies this
16:21:35 <vincenz> expand that logic to any set of clauses that form circles without entering edges
16:21:57 <palomer> man, all this meditation has dulled my brain
16:22:04 <vincenz> meditation
16:22:05 <vincenz> ?
16:22:09 <palomer> ok, so your minimal set is the set of variables assigned true
16:22:14 <palomer> and all other variables assigned to false
16:22:20 <palomer> such that all the clauses are satisfied
16:22:21 <vincenz> palomer: I guess I'm lucky that I didn't know about horn clauses
16:22:29 <vincenz> or I might have freaked as well
16:22:30 <vincenz> palomer: yeah
16:22:44 <vincenz> palomer: is there a name for that?
16:22:46 <palomer> and there is always a minimal element
16:23:01 <vincenz> I would think so
16:23:03 <palomer> horn clause satisfiability
16:23:11 <vincenz> ah cool :)
16:23:12 <palomer> there's an O(n^2) algorithm for it, I believe
16:23:18 <vincenz> prolly not in haskell?
16:23:25 <palomer> http://en.wikipedia.org/wiki/Horn-satisfiability
16:23:49 <palomer> The problem of Horn satisfiability is solvable in polynomial time. A polynomial-time algorithm for Horn satisfiability is based on the rule of unit propagation: if the formula contains a clause composed of a single literal l (a unit clause), then all clauses containing l are removed, and all clauses containing \neg l have this literal removed. The result of the second rule may itself be a unit clause, which is propagated in the same man
16:23:50 <palomer> ner. The formula is satisfiable if this transformation does not generate a pair of opposite unit clauses l and \neg l. Horn satisfiability is actually one of the "hardest" or "most expressive" problems which can be computed in polynomial time, in the sense that it is a P-complete problem.
16:24:08 <palomer> unit propagation
16:24:15 <palomer> I was very interested in this stuff 6 months ago
16:24:17 <palomer> I have no idea why
16:24:27 <palomer> I think it's because I was trying to crack DSA
16:25:12 <vincenz> heh
16:25:12 <vincenz> :P
16:25:12 <vincenz> that's what I do
16:25:12 <vincenz> I think I know why it's rather trivial
16:25:13 <vincenz> I don't allow clauses with more than one variable that is not not
16:25:15 <vincenz> aka !a /\ !b /\ c /\ 
16:25:17 <vincenz> d
16:25:31 <palomer> a -> b,horn clauses don't have negation
16:26:04 <vincenz> then why all the mental masturbation on that page?
16:26:12 <vincenz> Horn satisfiability is actually one of the "hardest" or "most expressive" problems which can be computed in polynomial time, in the sense that it is a P-complete problem.
16:26:46 <vincenz> I never studied horn clauses and wrote the algo in about 20 minutes or so
16:27:07 <palomer> I think I've written that very same algo in haskell
16:27:11 <palomer> 6 months ago
16:27:12 <vincenz> :D
16:27:19 <palomer> man, you can brainwash your own brain
16:27:25 <palomer> it makes you happy though
16:28:34 <palomer> you claim that horn clauses are always satisfiable
16:28:51 <palomer> that page claims that deciding if a set of horn clauses is satisfiable is computable in polynomial time
16:28:57 <palomer> something's up
16:30:45 <vincenz> yeah
16:30:48 <vincenz> cause they say
16:30:52 <vincenz> if you don't have !a and a
16:30:59 <vincenz> but you can't have !a as horn clause
16:31:00 <vincenz> cause that is
16:31:03 <vincenz> a -> False
16:31:14 <palomer> they're treating horn clauses as a disjunction of negative literals and one positive literal
16:31:24 <vincenz> yeah at which point !a is not possible
16:31:31 <palomer> which is equivalent to a conjunction of literals implies another literal
16:31:32 <vincenz> so their satisfiability issue is nonexistent
16:31:57 <palomer> !a \/ !b \/ !c ... \/ p  ====       a ^ b ^ c ^ ... -> p
16:32:03 <vincenz> yeahI knw
16:32:10 <vincenz> satisfiable if this transformation does not generate a pair of opposite unit clauses l and \neg l.
16:32:25 <vincenz> but \neg l as unit clause is an invalid horn clause!
16:32:59 <palomer> http://en.wikipedia.org/wiki/Horn_clause <--check out this definition
16:33:06 <vincenz> palomer: I know
16:33:15 <vincenz> that's my point
16:34:36 <palomer> () -> a == T -> a, right?
16:34:43 <vincenz> yep
16:34:47 <vincenz> [] :=> a
16:36:30 <palomer> hrmph
16:36:37 <palomer> so the wikipedia definition of horn clause is false
16:36:55 <vincenz> which one?
16:36:57 <vincenz> the second page?
16:37:00 <vincenz> where they talk of !u
16:37:35 <palomer> http://en.wikipedia.org/wiki/Horn_clause
16:37:44 <palomer> because if we start with a set of horn clauses
16:37:49 <palomer> we can never get a \neg l clause
16:37:58 <palomer> with unit propagation
16:37:59 <vincenz> well which one is invalid?
16:38:05 <vincenz> yes
16:38:13 <vincenz> \neg l === l -> False
16:38:15 <palomer> vincenz: that's a very good question
16:38:23 <palomer> they don't mention false
16:38:28 <palomer> if we had false everything would be ok
16:41:00 <palomer> m 
16:41:14 <palomer> b -> a, b, a
16:41:33 <vincenz> at which point it becomes
16:41:35 <palomer> err, nevermind
16:41:40 <vincenz> Horn a = [a] :=> [a]
16:41:46 <vincenz> which is boolsat
16:41:48 <vincenz> not hornsat
16:42:32 <vincenz> erm, except for \/
16:42:41 <palomer> ok, I agree with you 100% that it's always satisfiable
16:42:56 <palomer> (simply set everything to true)
16:43:06 <vincenz> lol
16:43:12 <palomer> so the wikipedia horn clause article forgets to mention false
16:43:36 <palomer> I'm not convinced that there's always a minimal set
16:49:01 <vincenz> hmmhmm
17:10:28 <jargonjustin> I have a question about 'return', I'm not sure if it's a Monad, Haskell or syntax question though.
17:10:59 <jargonjustin> The signature is a -> m a where m is a Monad, but how does the function determine what type of Monad to wrap a in?
17:14:49 <vincenz> jargonjustin: the used context
17:14:59 <jargonjustin> vincenz: Can you explain that to me?
17:15:23 <vincenz> well eventuall you're gonna call an action
17:15:29 <vincenz> at some place
17:15:39 <vincenz> and there the compiler know what monad you're using
17:15:45 <jargonjustin> It uses the same Monad as the called action?
17:16:29 <vincenz> no
17:16:35 <vincenz> if you have some action :: m a
17:16:46 <vincenz> and you use it somewhere, then the m will be the same as the m where it's called from
17:17:00 <vincenz> now unless you use the evaluator monad, all the way at the top this is IO
17:17:19 * vincenz hopes that makes some sort of sense
17:17:57 <jargonjustin> vincenz: Okay, so let's say I call "line <- getLine", line is then a String, not an IO String.  But  calling "return line" will wrap the String line in the IO Monad, causing the function to evaluate to an IO String, right?
17:18:14 <vincenz> yep
17:18:24 <vincenz> cause you're "in the IO monad"
17:18:28 <mathewm1> is there any module for writing/reading data structures to files, like Perl's Storable module?
17:18:39 <vincenz> mathewm1: Read and Show?
17:18:55 <jargonjustin> vincenz: The entire action is "in the IO monad" or just "line" (because it came from the IO Monad?
17:19:08 <vincenz> jargonjustin: the entire action is
17:19:20 <vincenz> now let's say you didn't use any IO specific action like getline
17:19:25 <jargonjustin> vincenz: The compiler knows this because you ran an action from it?
17:19:30 <vincenz> foo x = if x then return 1 else return 0
17:19:36 <vincenz> this has type :: Bool -> m Int
17:19:47 <vincenz> at some point you will use this action somewhere
17:19:47 <jargonjustin> So it can be lifted into any Monad?
17:19:50 <vincenz> yep
17:19:53 <vincenz> not lifted, used
17:19:57 <vincenz> lifting is something else
17:20:04 <mathewm1> I might like a Read and Show for pretty display, and something else for complete serialization/deserialization
17:20:06 <jargonjustin> Ah, okay.  Still learning the jargon.
17:20:15 <vincenz> jargonjustin: lifting has to do with monad transformers
17:20:19 <vincenz> those are mor complex
17:20:21 <vincenz> so ignore for now
17:20:27 <vincenz> just know that it refers to something else distinct
17:20:49 <vincenz> mathewm1: there's this library that does this
17:20:58 <jargonjustin> vincenz: Okay, only one type of action can be run per function (or is it an action if it runs an action?)
17:21:04 <vincenz> I forgot the name, it's based on TH or something similar
17:21:31 <vincenz> jargonjustin: any function using actions (actually evaluating them, instead of just moving them around) is an action
17:22:02 <vincenz> foo x = [print x, print x]   -- not an action, just returning a list of em
17:22:13 <jargonjustin> That action's type is then determined by the type of actions it runs? (So if an action runs an IO action, it itself is an IO action)
17:22:21 <vincenz> bar x = let list = foo x in head list   :: action
17:22:39 <vincenz> jargonjustin: yes, but typically it's from outter to inner
17:22:46 <vincenz> unless you have inner to outer forming these constrraints
17:22:50 <vincenz> cause all the way at hte top you have IO
17:22:54 <vincenz> (your main)
17:24:16 <jargonjustin> If all actions stem from the IO Monad at the top of the program, then how are other Monad types allowed to exist?
17:24:35 <vincenz> jargonjustin: by explicitly running them
17:24:39 <vincenz> @type evalState
17:24:40 <lambdabot> forall a s. State s a -> s -> a
17:24:44 <vincenz> @type evalStateT
17:24:45 <lambdabot> forall a (m :: * -> *) s. (Monad m) => StateT s m a -> s -> m a
17:24:59 <vincenz> jargonjustin: I'd suggest reading up more on monad
17:25:03 <vincenz> @where nomaware
17:25:04 <lambdabot> I know nothing about nomaware.
17:25:06 <vincenz> hmm
17:25:09 <vincenz> @where monads
17:25:10 <lambdabot> I know nothing about monads.
17:25:18 <vincenz> @hoogle site:nomaware.Com monads
17:25:18 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':nomaware.'
17:25:24 <vincenz> @hoogle nomaware monads
17:25:26 <lambdabot> Did you mean: Nomaware Monads
17:25:26 <lambdabot> Prelude.undefined :: a
17:25:26 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:25:29 <vincenz> @google nomaware monads
17:25:29 <sieni> @where sex
17:25:34 <lambdabot> http://www.nomaware.com/monads/html/
17:25:34 <lambdabot> Title: "All About Monads"
17:25:34 <lambdabot> I know nothing about sex.
17:25:37 <vincenz> there you go
17:25:44 <sieni> lambdabot: coulda guessed that
17:25:50 <vincenz> @tell sieni to get laid
17:25:51 <lambdabot> Consider it noted.
17:25:59 <jargonjustin> Thanks vincenz, I'm getting it... slowly... :-)
17:26:07 <sieni> vincenz: yes, I'll do that asap
17:26:08 <lambdabot> sieni: You have 1 new message. '/msg lambdabot @messages' to read it.
17:26:10 <vincenz> jargonjustin: yeah they can be confusing at first
17:26:23 <sieni> @messages
17:26:23 <lambdabot> vincenz said 32 seconds ago: to get laid
17:28:20 <vincenz> anyways
17:28:25 <vincenz> I prettyprinted my analyzed code
17:28:28 <vincenz> everything looks good
17:28:30 <vincenz> time to hit the sack
17:31:54 <vincenz> dcoutts: still up?
17:32:23 <sieni> plh h
17:34:17 <vincenz> woot
17:34:22 <vincenz> my apply-darcs rocks
17:45:06 <zarvok> anyone planning on doing the icfp contest?
17:50:07 <vincenz> @hoogle unless
17:50:08 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
17:50:08 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
17:50:08 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
17:50:10 <vincenz> zarvok:yes
17:50:40 <zarvok> cool
17:50:58 <zarvok> out of curiosity, how big a team are you planning (I'm one of the organizers)
17:51:25 <vincenz> zarvok: well to be honest we have to decide that
17:51:29 <vincenz> zarvok: we're considering splitting
17:51:34 <vincenz> see I started a team for haskell lovers
17:51:36 <vincenz> and slowly it grew
17:51:43 <vincenz> now with this limitation of small teams...
17:51:54 <vincenz> zarvok: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
17:51:56 <lambdabot> Title: "Not Vincenz's Wiki | Icfp / Main"
17:52:18 <zarvok> yes, I can understand that.  That restriction was debated over a lot, but in the end we decided it had to stay
17:52:24 * vincenz nods
17:52:26 <vincenz> so I can't tell you
17:52:30 <zarvok> yeah
17:52:31 <vincenz> most likely we'll split into one small team
17:52:33 <vincenz> and then a remaining team
17:52:43 <vincenz> it's to be decided on the 16th
17:52:57 <zarvok> I see
17:53:03 <zarvok> well, either way, I think you're going to like it a lot
17:53:05 <zarvok> it's very cool
17:53:09 <zarvok> I'm hacking on it now
17:53:11 <vincenz> cool
17:53:22 <vincenz> not sure what archaeolinguistics is
17:53:28 <zarvok> :)
17:53:33 <vincenz> except for a mini blurb from a site of Zessa
17:53:38 <vincenz> but it smells interesting
17:53:49 <zarvok> oh, it's interesting all right :)
17:54:03 <vincenz> might I ask what the reasoning is for the team categorization?
17:54:12 <zarvok> you can ask, but I can't tell you :)
17:54:17 <vincenz> ah ok
17:54:25 <vincenz> what about the choice of 4 iso for instance 6
17:54:37 <vincenz> zarvok: and most importantly
17:54:41 <vincenz> the lowerbound of 0 :P
17:54:53 <zarvok> heh
17:54:56 <vincenz> "small teams (0-4)"
17:55:07 <vincenz> that was funny :)
17:55:07 <zarvok> we've had some people register with team sizes of 0
17:55:19 <zarvok> to be funny, I guess
17:55:21 <vincenz> isn't that a contradiction?
17:55:25 <zarvok> heh, seems so
17:55:35 <zarvok> as for the cut off, it just seemed about right
17:55:39 <vincenz> alright
17:55:43 <vincenz> well I won't second guess you
17:56:09 <vincenz> looking at our team page
17:56:37 <vincenz> we're 13 people, but most likely 3-4 won't make it
17:56:45 <vincenz> so then we'll split into 4 and 67
17:56:48 <vincenz> erm 6
17:57:10 <vincenz> so I hope that's the info you were looking for
17:57:14 <vincenz> I know of one other haskell team with dcoutts 
17:57:18 <vincenz> they have 4 people or 3
17:57:19 <vincenz> can't quite remember
17:57:48 <zarvok> [08:52pm|vincenz> cool
17:57:48 <zarvok> [08:53pm|vincenz> not sure what archaeolinguistics is
17:57:48 <zarvok> [08:53pm|zarvok> :)
17:57:48 <zarvok> [08:53pm|vincenz> except for a mini blurb from a site of Zessa
17:57:48 <zarvok> [08:53pm|vincenz> but it smells interesting
17:57:53 <zarvok> heh, oops
17:57:58 <zarvok> hate it when that happens
17:58:02 <vincenz> want the link?
17:58:22 <vincenz> http://blog.myspace.com/index.cfm?fuseaction=blog.view&friendID=88598715&blogID=137865920&MyToken=3d38ff04-9805-4133-9fd8-f969d2c0e068
17:58:22 <zarvok> for the other team, you mean?
17:58:24 <lambdabot> Title: "blog.myspace.com/zessa"
17:58:28 <vincenz> oh that I don't have
17:58:35 <zarvok> heh, I have that
17:58:38 <vincenz> ah ok
17:58:44 <zarvok> it was an accidental copy paste
17:58:51 <zarvok> happened to haev the text selected and middle clicked
17:59:37 <vincenz> hmm, this might be a bit premature
17:59:44 <vincenz> but regarding the winners, typically they're invited to the conference
17:59:54 <vincenz> but ICFP is in the us this year, no? (well I would assume at cmu)
18:00:24 <zarvok> the conference is not at CMU, we're just organizing the contest, which is not given out based on the location
18:00:32 <vincenz> ah alright
18:00:46 <zarvok> http://icfp06.cs.uchicago.edu/
18:00:48 <lambdabot> Title: "11th ACM SIGPLAN International Conference on Functional Programming (ICFP 2006)"
18:00:55 <zarvok> this year it's in oregon
18:00:55 <vincenz> but the winners would go to cmu, not the conference site
18:01:03 <zarvok> no, the winners would go to the conference
18:01:26 <zarvok> it's just that the contest organizers aren't chosen based on the location of the conference
18:01:31 <vincenz> ah yes, like I thought, just not at cmu... ok, what if they're all europeans?
18:02:04 <zarvok> well, they are still invited, of course, and there is a small cash prize to help with travel costs
18:02:15 <zarvok> though it will probably cost more
18:02:55 <vincenz> alright
18:03:02 <vincenz> thx for the info
18:03:07 <zarvok> no problem
18:04:32 <vincenz> heh, you can prolly tell by the amount of stuff we put on that wiki that we're looking forward to the competition :)
18:04:42 <zarvok> yes
18:04:45 <zarvok> I am too :)
18:04:54 <zarvok> we've had a lot of fun designing it
18:05:00 <vincenz> I can imagine
18:05:24 <vincenz> icfpc is imo the only coding competition that's worth it and fun :)
18:05:50 <zarvok> yeah.  I'm really jealous of the participants, this year's is going to be great
18:06:30 <zarvok> I hope haskell wins again
18:07:24 <zarvok> I'm looking forward to seeing what the haskell teams come up with
18:07:37 <zarvok> Anyway, I have to get back to hacking on this, but thanks for the input, and good luck!
18:07:40 <vincenz> bbye
18:07:47 <vincenz> thx!
18:07:52 <Frederick> Does anyone ever heard about a real world usage for category theory (if there is one...)?
18:08:15 <vincenz> Frederick: I believe typing theory uses it, tho my knowledge of CT is limited
18:08:33 <Frederick> vincenz, I have a 4 credit lie next semester about it
18:08:44 <Frederick> I must get prepared to pass straight
18:08:48 <Frederick> no time to waste
18:08:54 <Pseudonym> I guess it depends what you mean by "real world".
18:08:55 <vincenz> can't help you, my background is EE
18:09:08 <Pseudonym> There is software that uses categories to represent module interfaces for computer-aided software design.
18:09:13 <Pseudonym> Software you can buy, in fact.
18:09:27 <vincenz> Pseudonym: happen to see my post on haskell-cafe about apply-darcs?
18:09:36 <Pseudonym> Not yet.
18:09:40 * Pseudonym is a bit behind on email
18:09:46 <vincenz> hmm it's from two days ago
18:09:47 <Frederick> Pseudonym, caqn you give me a link?
18:09:54 <vincenz> I just wonder if I should post again, given how I improved upon it
18:10:30 <zarvok> Frederick:  I don't know how familiar you are with Curry-Howard, but it's often argued that there is the same type of isomorphism between type theory/programs and category theory
18:10:36 <zarvok> Which may not qualify as a practical use
18:10:41 <Pseudonym> Frederick: http://www.specware.org/
18:10:43 <lambdabot> Title: "Specware - Home"
18:10:55 <zarvok> But is certainly very useful for mathematicians/computer scientists
18:11:07 <vincenz> zarvok: and professors wanting to cut CS students
18:11:13 <zarvok> heh
18:11:16 <vincenz> :P
18:11:20 <zarvok> I had a course in category theory last semester
18:11:23 <zarvok> it was... unique
18:11:36 <Frederick> zarvok, don't you mean useless?
18:11:47 <zarvok> taught by Steve Awodey, who was a student of Saunders MacLane
18:11:50 <vincenz> I did EE in univ, so now I've tried to catch up a bit by reading some books on CT in my free time
18:12:11 <vincenz> tho I must say, I'm dense when trying to read those books, especially when trying the excerces
18:12:24 <Pseudonym> vincenz, have you tried "Conceptual Mathematics"?
18:12:35 <Frederick> Pseudonym, no mention about category theory there
18:12:35 <vincenz> Pseudonym: yeah the reading is ok, until they ask me to prove somethin
18:12:46 <zarvok> Frederick: heh, not quite.  It's ability to model the relatinoships between diffrent mathematical objects is a very useful way to think about things
18:13:05 <Pseudonym> Frederick: Read the introduction manual, you'll find words like "morphism" thrown around.
18:13:16 <Frederick> zarvok, that is the abstract generalization of no cense
18:13:17 <vincenz> Pseudonym: but I never had formal proofs in univ, at least not of the CS type, so it's not a metapattern in my head (yet)
18:13:20 <Pseudonym> There are some papers on the system, too.  hang on.
18:13:38 <Frederick> morphism != category theory
18:13:53 <vincenz> zarvok: you're a master student or phd student?
18:14:13 <Pseudonym> Frederick: http://pages.cpsc.ucalgary.ca/~robin/class/617/Healy_Barker.pdf
18:14:22 <Pseudonym> That might help.
18:14:34 <zarvok> vincenz: An undergrad, actually, just lucky enough to have a job working with Bob Harper/Karl Crary and other type theorists
18:15:36 <zarvok> I'm ostensibly doing research for them, but with the icfp coming up, I'm spending most of my time on the design team for taht
18:15:47 <vincenz> yep yep
18:16:01 <vincenz> hmm
18:16:34 <vincenz> one of you three should be able to answer this, there was a conflict of definition between two pages on wikipedia regarding horn clauses
18:17:22 <Frederick> Pseudonym, still seems vague superficial and maybe unreal
18:17:45 <vincenz> anyways, I wrote a hornsat function today in haskell, and according to one it's fine, according to the other page hornsat is a very complex problem.  The conflict arises from the fact that one page says that horn clauses are /\ (list of vars) -> var, and the other says it's possible to have a pure !a which == (a -> False)
18:19:43 <zarvok> well, let me see
18:20:04 <zarvok> A horn clause, if I remember my logic courses, is a disjunction with at most one positive term?
18:20:13 <vincenz> aha
18:20:15 <vincenz> at most or one?
18:20:22 <zarvok> I was taught at most
18:20:25 <vincenz> hmm
18:20:26 <vincenz> I see
18:20:30 <zarvok> but who knows
18:20:42 <vincenz> yeah I didn't know horn clauses until I explained after the fact what I had done
18:20:46 <vincenz> tho mine tackles the case of 'on'
18:20:49 <vincenz> erm 'one'
18:20:55 <vincenz> which is rather easy to do
18:21:40 <vincenz> just keep finding unit tautologies, and remove those variables from the negative variables from the other clauses, rinse and rpeeat until you have no unit tautologies left, discard remaining tautologies
18:22:09 <zarvok> yes
18:22:32 <zarvok> wikipedia suggests that even with less restrictive definition it's still a polynomial time problem
18:22:35 <vincenz> sometimes I wish I had one cs
18:22:39 <zarvok> though I haven't thought abotu the algorithm
18:22:59 <vincenz> zarvok: yeah but they say it's "the hardest problem that is polynomial"
18:23:37 <Pseudonym> PRIMES is probably harder if the Sophie Germaine conjecture is false.
18:23:43 <Pseudonym> Germain
18:23:53 <zarvok> heh, well, sure, in the sense that any polynomial time problem can be encoded in it, but I'm not sure that that's a good indicator of difficulty
18:23:54 <Pseudonym> That's O(N^12)
18:24:17 <zarvok> well, (according to wikipedia) hornsat is P-complete
18:24:18 <zarvok> so, no
18:24:25 <Pseudonym> Ah, right.
18:24:27 <Pseudonym> Gotcha.
18:24:58 <vincenz> s/one/done/
18:25:05 <|Steve|> Pseudonym: PRIMES is in P.
18:25:15 <|Steve|> So harder in what sense?
18:25:33 <|Steve|> It's been reduced to O(n^(6+e)) in the general case.
18:25:38 <vincenz> zarvok: what is "p-complete"?
18:25:55 <Pseudonym> Steve: No, that's assuming the Sophie Germain conjecture.
18:26:00 <Pseudonym> Which hasn't been proven.
18:26:09 <Pseudonym> It's only been proven to be O(n^(12+e))
18:26:10 <|Steve|> Pseudonym: I think it was O(n^4) assuming S-G.
18:26:18 <|Steve|> The proof for n^(12+e) is easy.
18:26:23 <Pseudonym> I might be going on old information.
18:26:43 <|Steve|> I could be wrong as well. It's been a few months since I read the AKS paper.
18:26:44 <zarvok> p-complete means that any program which is solvable in polynomial time can be represented, in some sense, within that problem
18:26:51 <zarvok> within the hornsat problem I mean
18:26:54 <vincenz> zarvok: ah I see
18:27:00 <zarvok> are you familiar with NP-completeness?  It's the same thing
18:27:01 <Pseudonym> That's what the original AKS paper proved.  N^12 not assuming S-G.
18:27:24 <vincenz> zarvok: the only term I knew was NP-incomplete, meaning it can't be solved in Polynomial time
18:27:34 <Pseudonym> That's NOT what NP-complete means.
18:27:37 <|Steve|> Pseudonym: Right, but then they had extensions in later papers.
18:27:41 <Pseudonym> Ah, right.
18:27:42 <Pseudonym> OK.
18:27:43 <vincenz> Pseudonym: I said incomplete
18:27:56 <|Steve|> zarvok: P-complete under what though?
18:27:59 <Pseudonym> Well actually, that's not what NP-incomplete means either.
18:28:12 * vincenz shrugs confusedly and just lets the conversation flyby
18:28:20 <zarvok> |Steve|: if I understand the question, time
18:28:21 <|Steve|> Every language that isn't empty or Sigma* is P complete under polytime reductions.
18:28:22 <Pseudonym> Oh, hang on.
18:28:27 <Pseudonym> Yes, you might be right.
18:28:29 <|Steve|> Sorry, every language in P.
18:28:48 <|Steve|> You could talk about P complete under say, linear time reductions.
18:28:49 * vincenz points to his earlier statement about sometimes wishing he had done CS
18:29:00 <|Steve|> Or P complete under log-space reduction.
18:29:16 <|Steve|> And NP does not mean it can't be solved in polynomial time.
18:29:36 <Pseudonym> It has been proven that EXPTIME > P.
18:29:37 <|Steve|> It means it can be solved in polynomial time using a nondeterministic turing machine.
18:29:46 <zarvok> right
18:29:46 <Pseudonym> So there are provably "intractable" problems.
18:30:01 <|Steve|> You can show that with the time hierarchy theorem though.
18:30:05 <Pseudonym> Though I should point out that P != tractable.
18:30:18 <vincenz> tractable >= P ? 
18:30:24 <Pseudonym> Nope.
18:30:34 <|Steve|> For any function f(n), there is a language decidable in O(f(n)) but not in O(f(n)/log n), I think.
18:30:35 <Pseudonym> An O(N^12) algorithm might still be intractable.
18:30:55 <vincenz> intractable = ?
18:31:07 <|Steve|> Can't be solved in a "reasonable" amount of time.
18:31:12 <vincenz> ah
18:31:19 <vincenz> I would think that reasonable is subjective
18:31:20 <|Steve|> Usually means more than polynomial.
18:31:22 <Pseudonym> Yeah.  It refers to any problem that's solvable in theory, but not in practice.
18:31:22 <|Steve|> It is.
18:31:39 <vincenz> how can you formally define a subjective measure?
18:31:40 <Pseudonym> It's an open question as to what "in practice" means.
18:31:49 <zarvok> vincenz: what's important to remember is that NP doesn't mean "not" P.  Actually, the P problems area subset of the NP problems
18:31:49 <Pseudonym> Because it's so context-sensitive.
18:32:02 <vincenz> zarvok: oh that I know
18:32:13 <|Steve|> In theory, theory and practice are the same. In practice, they're quite different.
18:32:25 <|Steve|> (Not sure where I read that, probably #math.)
18:32:25 <Pseudonym> We know that problems not in P are definitely intractable for reasonable N.
18:32:46 <vincenz> Pseudonym: for a reasonable definition of "reasonable"?
18:33:08 <Pseudonym> SOmething like that.
18:33:14 <vincenz> :D
18:33:38 <Pseudonym> No practical compiler would use an algorithm that has usual-time complexity greater than O(N^3) in the size of a compilation unit.
18:33:41 <Pseudonym> For example.
18:33:51 <Pseudonym> Unless the constant factor was VERY VERY low.
18:33:59 <Pseudonym> But even then, it'd be a bit dubious.
18:33:59 <vincenz> Well then I claim the new vincenz theory: tractable probles are intractable for unreasonable N, for a reasonable definition of "unreasonable" and an unreasonable definition of "reasonable"
18:34:18 <zarvok> of course, plenty of static typing algorithms are not polynomial in the worst case
18:34:24 <Pseudonym> Of course.
18:34:34 <Pseudonym> But they're pretty much all linear in the usual case.
18:34:38 <zarvok> yeah
18:34:42 <|Steve|> You can talk about RP algorithms though.
18:34:59 <Pseudonym> No compiler would use a randomised algorithm if semantics was on the line.
18:35:07 <Pseudonym> If optimisation was on the line, that's different.
18:35:08 <|Steve|> Not true.
18:35:34 <|Steve|> Well, maybe RP is the wrong class of randomized algorithms.
18:35:36 <Pseudonym> It is true.  No reasonable programming language has stochastic semantics.
18:35:43 <|Steve|> Heh, that's not what I meant though.
18:35:46 <mauke> .oO( Java2k )
18:35:54 <zarvok> heh
18:35:55 <Pseudonym> mauke: Chaotic != stochastic
18:36:00 <Pseudonym> But point taken.
18:36:06 <vincenz> Pseudonym: only for a "reasonable" definition of "reasonable", not for an "unreasonable" definition of "reasonable
18:36:17 <|Steve|> I meant that an algorithm might take exponential time (as you pointed out above) but usually take polynomial.
18:36:24 <Pseudonym> Yes.
18:36:28 <vincenz> even though your "unreasonable" might be "unreasonably" defined
18:36:29 <Pseudonym> That's fair.
18:36:50 <|Steve|> I guess I should have said, they'd use ZPP = RP intersect coRP.
18:37:09 <Pseudonym> People who use lots of ad-hoc overloading (in languages where that applies) know it might make the type checker a long time to run.
18:37:17 <|Steve|> (Zero-error probabilistic polynomial time.)
18:37:40 <vincenz> anyways, I'm off
18:37:48 <vincenz> Pseudonym: if you want the link to the little darcs widget I wrote
18:38:00 <Pseudonym> And people who write complex template meta-programs in C++ usually understand what will happen.
18:38:00 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Personal/Software
18:38:02 <lambdabot> Title: "Not Vincenz's Wiki | Personal / Software"
18:38:13 <Pseudonym> vincenz: Thanks.  I'll take a look.
18:38:19 <|Steve|> why did lambdabot just chime in there?
18:38:28 <vincenz> Pseudonym: yeah not to mention code space, I've written 100 level deep templates
18:38:34 <Pseudonym> Right.
18:38:42 <zarvok> lambda bot prints the title whenever you write a url
18:38:50 <|Steve|> That could be...bad.
18:38:53 <zarvok> heh
18:38:55 <vincenz> they're not too happy with those
18:38:55 <vincenz> zarvok: except for paste-sites
18:39:16 <Pseudonym> Oooh.
18:39:19 <Pseudonym> That gives me an idea.
18:39:25 <vincenz> Pseudonym: templates or apply-darcs?
18:39:30 <Pseudonym> Run another lambdabot instance with the user name "Title".
18:39:40 <vincenz> Pseudonym: won't work
18:39:43 <Pseudonym> And then put up a web site somewhere with an evil title...
18:39:48 <Pseudonym> No?
18:39:48 <vincenz> Pseudonym: lambdabot filters on messages coming from *bot
18:39:51 <Pseudonym> Oh, the quotes.
18:39:52 <vincenz> Pseudonym: even channels that end in bot
18:39:55 <vincenz> which bothered me
18:40:00 <Pseudonym> Ah.
18:40:01 <Pseudonym> Right.
18:40:17 <vincenz> but sure, start two instances
18:40:22 <vincenz> none of then named *Bot
18:40:37 <vincenz> and then have a website with as title name a url
18:40:55 <vincenz> that'll prolly do the trick
18:41:34 <|Steve|> I wrote a bot for hotline once that would just repeat anything someone said. I made the mistake of not filtering the bots own comments. =\
18:41:37 <vincenz> if spam was what you were originally after
18:41:47 <vincenz> |Steve|: ouch... got kliend?
18:42:08 <|Steve|> It killed the hotline server.
18:42:13 <|Steve|> It was running locally.
18:42:19 <vincenz> ah
18:42:46 <|Steve|> It was just a first go at it to see if it'd work and it did.
18:43:08 <zarvok> heh, hotline, that takes me back
18:43:48 <|Steve|> oh yes
18:43:51 <zarvok> used to run a hotline server, then someone uploaded the harry potter movie and my ISP got a nice cease and desist letter from warner brothers
18:44:31 <zarvok> I've had better days
18:44:55 <Pseudonym> Title: http://www.google.com/
18:45:06 <Pseudonym> Just checking.
18:45:13 <Pseudonym> http://www.google.com/
18:45:14 <lambdabot> Title: "Google"
18:45:16 <Pseudonym> Right.
18:45:21 <Pseudonym> However:
18:45:28 <Pseudonym> lambdabot: http://www.google.com/
18:45:35 <vincenz> However: www.google.com
18:45:44 <Pseudonym> Right.
18:45:51 <Pseudonym> So it need to be not addressed to someone.
18:45:51 <vincenz> porn: www.google.Com
18:46:05 <vincenz> Pseudonym: actuall not sure about that
18:46:08 <vincenz> Pseudonym: www.google.com
18:46:13 <vincenz> @bot
18:46:13 <lambdabot> :)
18:46:39 <vincenz> Pseudonym: but if you really want a spam cycle, remove the check
18:46:42 <Pseudonym> @vixen What's up with the URL skimmer?
18:46:43 <lambdabot> good question
18:46:47 <vincenz> lambdabot is only source-downloadable
18:46:57 <Pseudonym> Yeah, but the challenge is to do it on an unmodified lambdabot.
18:47:21 <vincenz> @vixen @vixen
18:47:21 <lambdabot> i am a bit of a vixen :)
18:47:43 <vincenz> @state @state
18:47:43 <vincenz> @state @state
18:47:44 <lambdabot>  @state
18:47:44 <lambdabot>  @state
18:47:48 <vincenz> @state @state @state
18:47:49 <lambdabot>  @state @state
18:47:50 <vincenz> @state @state @state
18:47:50 <lambdabot>  @state @state
18:47:53 <vincenz> hmm
18:47:54 <vincenz> never mind
18:48:06 <Pseudonym> @quote
18:48:07 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
18:48:15 <vincenz> @help quote
18:48:16 <lambdabot> quote <nick>
18:48:16 <lambdabot> remember <nick> <quote>
18:48:16 <lambdabot> Quote somebody, a random person, or save a memorable quote
18:48:37 <vincenz> Pseudonym: it'll still be purely reductionist
18:48:40 <vincenz> like @state
18:48:51 <vincenz> you can't quine with the lambdabot commands
18:49:36 <ruffneck> what do you reduce ?
18:49:41 <Pseudonym> I know.  The last time I managed that, dons patched it.
18:49:42 <Pseudonym> Bastard.
18:49:46 <vincenz> Pseudonym: actually
18:50:11 <vincenz> Pseudonym: you could have @quote do an @state... on a second bot... this will reduce, and the last word in the reduction chain is @quote again, which restarts the loop
18:50:23 <vincenz> maybe even on a single bot
18:50:29 <Pseudonym> Except it doesn't work any more.
18:50:30 <vincenz> thou you gotta be lucky on the quote bit
18:50:36 <Pseudonym> The addition of "says" fixes tht.
18:50:41 <Pseudonym> Yes, I did that once.
18:51:14 <vincenz> oh wait, nm, if that worked, you'd just use @quote without the @state
18:51:20 <Excedrin> Title: "http://lerp.com/t.html"
18:51:30 <Excedrin> damnit, that should work
18:51:31 <vincenz> Pseudonym: hmm
18:51:34 <vincenz> Title: @quote
18:51:39 <Pseudonym> http://tunes.org/~nef/logs/haskell/06.04.18
18:51:44 <Pseudonym> Go about 3/4 of the way down.
18:51:44 <vincenz> Title: @state
18:51:50 <Pseudonym> Did that with @fact, but it's much the same thing.
18:52:12 <vincenz> Pseudonym: with my bot!
18:52:53 <vincenz> Pseudonym: it's evne funny they kicked lambdabot and not oasisbot :P
18:53:01 <vincenz> 18:19:38 <oasisbot> lambdabot: ?fact oasisbot
18:53:02 <vincenz> 18:19:38 --- kick: lambdabot was kicked by Igloo (Igloo)
18:53:04 <Pseudonym> Yeah.
18:55:14 <vincenz> blegh, reading over these logs I realize that I have a high noise/signal ration
18:55:53 <vincenz> Pseudonym: concernig apply-darcs, had a small question, unless you haven't looked at it
18:56:01 <Pseudonym> I looked at the page.
18:56:20 <Pseudonym> But by all means ask.
18:56:27 <vincenz> the page is bare except for a link to the source
18:56:31 <vincenz> do you know what it does?
18:56:35 <Pseudonym> Nope.
18:56:38 * Pseudonym is no darcs expert
18:56:42 <vincenz> it's to mass pull a forest of darcs to a second forest of darcs
18:56:48 <vincenz> Pseudonym: no need to be
18:56:56 <Pseudonym> OK
18:57:24 <vincenz> so imagine you have repos: ~/work/foo ~/work/bar/a and ~/work/bar b
18:57:30 <vincenz> three of them
18:57:33 <vincenz> it'd be nice if you just do
18:57:43 <vincenz> darcs-apply ~/Work /usbstick
18:57:48 <Pseudonym> Right.
18:57:59 <vincenz> so that's what this does, it does a mass pull of darcs repos and recurses in subdirectories
18:58:34 <vincenz> however I'm considering adding a file such that you can stop it from looking further, cause it will prompt you if you're pulling to a place with no darcs repository in the forest where there is one in the from forest
18:58:44 <vincenz> meaning, assume you have /usbstick/foo
18:58:53 <vincenz> but you don't want to get prompted for the bar/a and bar/b
18:58:59 <vincenz> cause you only want to move foo
18:59:08 <vincenz> then it'd be nice to put a file in bar/ that tells it to stop looking
18:59:22 <vincenz> the question regards the name of that file
18:59:50 <vincenz> it's gotta be unused enough, I was thinking _norecurse
18:59:55 <vincenz> tho maybe that's too generic?
19:00:06 <vincenz> _darcstop?
19:01:37 <Pseudonym> Hrm.
19:01:46 <Pseudonym> Well, that makes sense to me.
19:01:54 <Pseudonym> But I don't know why you're asking me what to call a file. :-)
19:02:01 <dons> moin
19:02:07 <Pseudonym> G'day.
19:02:18 <vincenz> Pseudonym: cause I hate naming things?
19:02:58 <dons> vincenz: perhaps look at 'find' ?
19:03:00 <dons> i.e. --depth=N
19:03:20 <dons> or --except=_foo_dir
19:03:22 <Pseudonym> You know the First Rule of Anything To Do With Computers is that the largest argument will be over what to call it, don't you?
19:03:24 <dons> which means it won't look under
19:04:02 <vincenz> dons: I don't use find
19:04:22 <vincenz> "darcs-apply from-root-dir to-root-dir"
19:04:35 <dons> vincenz: yeah, but it does similar things. i.e. recursively decends trees, pruning subdirs or stopping at depths
19:04:40 <vincenz> version 0.2 now has auto-prompting for initting
19:04:40 <dons> so maybe it has a good api to steal
19:04:57 <vincenz> dons: the question pertains to the file of the name
19:05:00 <dons> vincenz: also, have you looked at ghc's 'darcs-all' script?
19:05:03 <vincenz> oh wait... hmm like that
19:05:07 <vincenz> dons: nope
19:05:15 <dons> for darcs pulling from multiple darcs repos
19:05:21 <vincenz> dons: ah damn
19:05:26 <vincenz> dons: link?
19:05:32 <eivuokko> It takes explicit list tho.
19:05:43 <eivuokko> http://darcs.haskell.org/ghc/darcs-all or so
19:05:47 <dons> i'm thinking you don't really want a special file to ignore, but rather have a flag to list the names of dirs not to descend into 
19:05:55 <vincenz> dons: yeah I misread your comment
19:06:02 <vincenz> dons: I thought you were suggesting actually using find
19:06:05 <dons> ah right
19:06:06 <dons> nope
19:06:08 <vincenz> but now I'm clearer on your intended meaning
19:06:11 <vincenz> yeah
19:06:12 <vincenz> that's a good idea
19:06:26 <dons> it's an api that other people will understand too.
19:06:54 <vincenz> so... eivuokko is my script bitbinned due to the existence of darcs-all?
19:06:57 <vincenz> or does it have a niche?
19:07:13 <dons> no, i think your is more general
19:07:20 <dons> a bit more general
19:07:23 <vincenz> I know for a fact that it even does nested darcs
19:07:29 <vincenz> but that's not a requirement
19:07:40 <eivuokko> vincenz, I think it is ok tool.  I think I'd use it if it was installed on my systems.
19:07:41 <dons> also, why not use rsync or unison to just copy the entire tree? (this is how i backup to my usb stick)
19:07:54 <vincenz> dons: cause I prefer pulling
19:08:02 <vincenz> dons: especially since it's
19:08:07 <vincenz> home <-> usb <-> work
19:08:20 <vincenz> and even before that
19:08:28 <vincenz> when backing up, I often wished for auto-init
19:08:51 <vincenz> anyway 0.3: --except flag
19:09:02 <vincenz> 0.314: ssh?
19:09:24 <eivuokko> dons, does rsync and unison also make links?
19:09:31 <dons> ssh should be easy.not sure.
19:09:56 <vincenz> dons: well it's just using system calls
19:10:10 <vincenz> tho it might be nice to not require 15000 password entries
19:10:16 <vincenz> even a single repo already needs like 5
19:10:30 <eivuokko> You should use agent
19:10:46 <vincenz> eivuokko: oh I do now, I have pubkeys installed
19:11:08 <vincenz> just saying that it'd be annoying like hell for people without agent if they did masspulls
19:12:43 <vincenz> dons: anyways I'mo off
19:12:46 <vincenz> 4am
19:12:54 <vincenz> and tomorrow is the last day before I leave for conference
19:12:57 <vincenz> cya
19:14:19 <eivuokko> I started a small lib for generating ia32 asm (ie data types describing instructions and functions to convert them into binary), where would it go in module namespace?
19:15:00 <vincenz> eivuokko: ooh interesting
19:15:42 <eivuokko> System. or Language. and .Asm.Ia32 or just .Ia32(Asm)?
19:16:48 <Korollary> eivuokko: Not System. Maybe it deserves its own root.
19:17:41 <Korollary> it is a bit like Text.Html
19:17:50 <eivuokko> Ah, right.
19:18:21 <eivuokko> That makes sense.  I'll go with that for now, then.
19:18:24 <eivuokko> Thanks.
19:18:26 <vincenz> Korollary: you mean as in they're both "programming languages"?
19:18:28 <Korollary> how are you handling 486/586/Pentium etc?
19:18:56 <eivuokko> Korollary, up to user not to generate wrong instructinos, I am afraid.
19:19:14 <vincenz> eivuokko: I think he's referring to how you represent them
19:19:21 <eivuokko> Eh
19:19:37 <vincenz> eivuokko: well ... either you continually have to grow your AST at each new cpu-arch
19:19:49 <vincenz> eivuokko: or you generalize some way of combining different sets
19:20:23 <eivuokko> It's not really AST :)  Nothing abstract in it.  I adopted for one huge data type for now.
19:20:33 <vincenz> well not ast
19:20:38 <vincenz> I meant data type
19:20:41 <vincenz> (it"s late)
19:20:48 <eivuokko> Although, I will add relocation generation at some point.
19:20:57 <eivuokko> Almost impossible to live without that.
19:21:26 * vincenz 's off
19:21:34 <vincenz> eivuokko: no I think it would be interesting to have
19:22:20 <vincenz> type Ia32_486 = Ia_extend Ia32 extension1
19:22:25 <vincenz> or some such
19:23:34 <eivuokko> Heh.  That's too much work to dig up.  Intel's manual doesn't have that info easily available, I think.
19:23:40 <vincenz> otherwisse your module will never be stable until I32 is obsolete
19:23:50 <vincenz> eivuokko: I mean
19:23:50 <dons> yeah, use pub keys for sure, but you could also avoid multiple passwds using master/slave ssh connections
19:23:58 <dons> so it just reuses the first connection
19:24:06 <eivuokko> Sure it is stable.  The mapping between ctor and binary represenation is stable.
19:24:10 <vincenz> Ia32_586 = IA_extend Ia32_486 MMX
19:24:16 <eivuokko> Additional ctors don't change it.
19:24:23 <vincenz> eivuokko: they change the type
19:24:51 <eivuokko> Well, ok, it is recompilation-stable.
19:24:52 <ruffneck> hih, et ole vuokko ;)
19:25:05 <vincenz> eivuokko: not really
19:25:20 <vincenz> eivuokko: people that want to deal with 486 now have to ensure they have an otherwise clause that fails for everything
19:25:26 <vincenz> cause they didn't know about I_786
19:25:35 <eivuokko> Huh?  Just need to recompile or relink (if you use explicit importing of symbols)
19:25:48 <vincenz> having distinct types for distinct asms would be a good idea
19:26:02 <eivuokko> vincenz, And anyway, as I said, I don't feel like digging it up.
19:26:06 <vincenz> ok
19:26:08 <eivuokko> The info, I mean.
19:26:27 <eivuokko> It's not in easily readable form in Intel's manuals afaict
19:26:36 <vincenz> it isn't?
19:26:48 <vincenz> just pick an 486 manual an check which instructions aren't in it
19:27:04 <eivuokko> Ehm
19:27:08 <eivuokko> I don't call that easy :)
19:27:15 <eivuokko> I just use latest.
19:27:32 <vincenz> anyways if it's to be standardized, this will most likely be an objection
19:28:21 <vincenz> not saying it's something that has to be done now
19:28:31 <eivuokko> I was thinking just good name for the module, standardising it...meh :)
19:28:56 <vincenz> ah, ok :)
19:28:59 <eivuokko> Just good intuitive place when I put the code up, in case someone else wants to write instructions down...as it's pretty boring work.
19:29:27 <vincenz> eivuokko: it's actually quite interesting, I've been toying with the thought of making a modular Instruction set simulator
19:29:39 <vincenz> where you can swap in and out caches, memories, buses, and datapaths
19:29:55 <vincenz> obviously the actual instruction set is step 1
19:30:06 <eivuokko> I just want to generate (semi-fast) code in fly :)
19:30:19 <vincenz> eivuokko: from what are you generating?
19:31:16 <eivuokko> Nothing (except tests) because the lib isn't ready enough :)
19:31:44 <vincenz> but from a prog lang?
19:31:52 <eivuokko> But, in reality, I wish to use it for user-specified formulas that are run over moderately big data sets
19:32:00 <eivuokko> very restricted.
19:32:11 <vincenz> ah
19:32:17 <vincenz> how do you then actually call the code?
19:32:27 <eivuokko> Just like I'd call any FunPtr :)
19:32:32 <vincenz> o.O
19:32:44 <vincenz> you can put assembly straight into memory?
19:33:07 <vincenz> eivuokko: could I take a look?
19:33:07 <eivuokko> Just need to allocate memory that has executable rights, castPtrToFunPtr and run it through foreign import "dynamic"
19:33:18 <eivuokko> Yes, I generate binary asm into memory.
19:33:18 <ruffneck> that's hax0ring ;))
19:33:18 <dons> right.
19:33:34 <vincenz> sounds nearly like jitting
19:33:34 <dons> ghc does it all the time (using these funky 'adjustor' thunks'
19:33:43 <vincenz> nifty
19:33:50 <ruffneck> esa you are crazy hacker nrtti ;)
19:33:56 <vincenz> didn't know you'd be able to do that from haskell
19:34:03 <vincenz> eivuokko: source code up anywhere?
19:34:06 <eivuokko> I'll put the code up when I rearrange it.  It's just few hundred lines of code at the moment, and it badly needs more instruction then mov, add, retn and int3 ;)
19:34:07 <dons> of course, you are not really putting asm, you're putting the opcodes as words into an array, you set executable
19:34:10 <dons> then jump to it
19:34:31 <dons> perhaps that makes it clearer what the process is?
19:34:36 <vincenz> dons: well yeah, I use asm interchangeably for opcodes and the textual repr
19:34:40 <vincenz> since they're one-to-one
19:34:53 <eivuokko> dons, I think it's hard to understand all the details in adjustor if one hasn't written such asm.
19:35:12 <eivuokko> vincenz, Well, actually...labels and relocation...
19:35:13 <dons> really, you'd be able to build your asm in a ByteString, and then call an ffi wrapper which just goto's its argument.
19:35:14 <vincenz> dons: was just hoping to see the actual haskell code doing it
19:35:21 <dons> maybe we should have a runtime-eval asm module :)
19:35:32 <vincenz> dons: sounds dangerous
19:35:36 <eivuokko> dons, The problem is that it needs exec bit set, need OS help for that memory allocation.
19:35:38 <dons> sure. just like calling C
19:35:42 <dons> eivuokko: right
19:35:49 <vincenz> eivuokko: is the source online?
19:35:55 <eivuokko> vincenz, Not yet.
19:36:38 <eivuokko> vincenz, I'll put it up later.  I was just about to rearrange the modules and that's why I was asking for module names.
19:36:39 <dons> vincenz: its only a few steps away from a trick i do at the moment, generating specialised C at runtime, compiling it to .o, linking it, and jumping into the big C chunk via the ffi
19:36:51 <dons> here you bypass the compiler, and generate your own asm.
19:37:07 <vincenz> dons: how do you force the linkage ate runtime?
19:37:12 <vincenz> s/ate/at
19:37:17 <eivuokko> It'd be cool to have simple SSA -> Register alloc -> Asm cycle.  Very functional.
19:37:30 <eivuokko> SSA makes great monad.
19:37:35 <dons> you'd have to be really careful. not using any external calls, for example
19:37:36 <vincenz> eivuokko: SSA si actually the next step I have to perform on the compiler Im' currently working on
19:37:43 <dons> or perhaps call the ghc linker
19:37:45 <dons> that works for c
19:38:09 <vincenz> eivuokko: tho I don't see how it's a monad
19:38:49 <eivuokko> vincenz, Well, maybe I was bad way to describe it.  Functional programming on monads fits on SSA pretty good.
19:39:08 <vincenz> still not with you
19:39:30 <dons> eivuokko: hmm interesting. you know there's an SSA<=>ANF (almost-Core) translation?
19:39:46 <eivuokko> For example something like add :: Reg -> Reg -> SSA Reg, where it'd allocate new reg for result of add
19:40:08 <eivuokko> dons, Core requires calling conventions, and in practice graph reduction-cabable one.
19:40:18 <eivuokko> dons, and memory alloc, but that's not too bad.
19:40:39 <dons> let me find the ANF/SSA paper, its quite interesting
19:40:57 <vincenz> dons: ah yeah I4d be interested as well
19:41:03 <dons> http://www.cse.unsw.edu.au/~chak/papers/CKZ03.html
19:41:04 <lambdabot> Title: "Research Papers of Manuel Chakravarty"
19:41:18 <dons> "A Functional Perspective on SSA Optimisation Algorithms"
19:42:04 <vincenz> dons: this at all related to the appel paper that compared SSA to purely functional?
19:42:11 <dons> i always found ssa super nasty to reason about, esp. when compared to a lambda term representation.
19:42:24 <eivuokko> Huh?
19:42:38 <dons> vincenz: yeah, it came from that observation
19:42:56 <vincenz> eivuokko: that add :: .... is that GADT?
19:43:07 <eivuokko> I have been playing with DirectX shader DSL in haskell, I represent stuff in SSA and do SSA -> shader asm conversion, but register alloc is easy on it.
19:43:20 <eivuokko> vincenz, NAh, just a function example.
19:43:26 <dons> oh, very interesting, eivuokko 
19:43:38 <eivuokko> vincenz, I don't use gadts because they are too ghc
19:43:43 <dons> there's a phd student in my group doing general purpose programming on nvidia gpu's
19:43:55 <vincenz> eivuokko: you speak of SSA as if it's generic....though aren't SSA's AST specific?
19:44:02 <dons> and he's going to have to generate shaders and kernels out of ghc eventually
19:44:12 <dons> do you have a link, maybe he'd be interested.
19:44:18 <vincenz> eivuokko: nor do I, I use indirect composite for AST representation
19:44:21 <eivuokko> dons, Working on shader model 3?  Because I got only shader model 2 cabable ati and it's not general purpose any sensible way
19:44:35 <dons> yeah, ati is more restricted , afaik
19:44:36 <eivuokko> dons, No, it's private.  And probably stays so.
19:44:39 <dons> ok :)
19:45:05 <eivuokko> vincenz, Yeah, I saw your mail and some of irc discussions.
19:45:33 <vincenz> eivuokko: most likely the fact it's SSA will not be represented in the AST
19:45:35 <vincenz> erm in the type
19:45:54 <vincenz> which is a shame but yeah :/
19:46:00 <eivuokko> dons, It's not about nvidia vs ati, really.  It's about that next generation (really the top cards that are sold now) support shader model 3 in directx.  It has much flexible interface and dynamic flow control etc.
19:46:04 <dons> eivuokko: conal eliott might be interested, he does a lot of haskell/graphic dsl work
19:46:20 <eivuokko> dons, I thought he gave up on shaders and went to java
19:46:28 <dons> hmm. i'd not heard that.
19:46:30 <jargonjustin> Quick question, for the Maybe datatype, Maybe is a Type Constructor and Just and Nothing are Value constructors, right?
19:46:42 <eivuokko> dons, Isn't the new stuff generating java, I thought so.
19:47:06 <dons> oh, i know he's using hs-plugins still, and he was generating specialised haskell recently
19:47:10 <eivuokko> Ah
19:47:16 <dons> jargonjustin: yep
19:47:24 <jargonjustin> dons: Thanks.
19:47:32 <dons> but we'd say : Maybe is a type constructor, and Just and Nothing are its data constructors
19:47:44 <dons> or just 'its constructors' (a synonym for data constructors)
19:48:07 <eivuokko> vincenz, SSA isn't AST imo, at that point (typically) the code has been already optimised some and syntax has nothing much to do with representation.
19:48:20 <dons> eivuokko: had any experience with Cg , Brook or the OpenGL shader language?
19:48:23 <vincenz> eivuokko: IR is still a sort of AST
19:48:32 <vincenz> just a lower level one
19:48:50 <eivuokko> dons, I dunno Brook.  And I prefer directx shader language as it's more low-level and fun ;)
19:48:54 <vincenz> eivuokko: but yeah I do need to remain at highlevel ast, cause I work on source->source transformations
19:49:10 <dons> eivuokko: i suppose you're actually doing graphics on your gpu?
19:49:14 <eivuokko> dons, I meant that my shader stuff is in EDSL really, and I generate shader binaries in memory.
19:49:24 <dons> yep, that's cool.
19:49:36 <eivuokko> dons, Yes, it's part of 3d-engine plaything I played with.
19:49:54 <dons> ah ok. the student i'm working with is doing nested data parallel array functions on the gpu
19:50:02 <dons> so things like map, folds and scans
19:50:25 <eivuokko> dons, And generating Cg/OpenGl shader langauge would go through text and it would be very hard to know when it's slow because of registers or whatever limits
19:50:35 <dons> hmm, yes. interesting.
19:50:49 <eivuokko> dons, Uhm.  Does that actually help in something?
19:51:04 <vincenz> eivuokko: have a homepage?
19:51:12 <dons> sure, the gpu is basicaly a stream coprocessor, for arithmetic intensive code
19:51:18 <dons> fft-style stuff
19:51:20 <eivuokko> dons, It does sound fun, but practical usefulness seems a bit...arbitary or specialised
19:51:38 <eivuokko> vincenz, Sort of...slowly updating bloggy: tamelambda.net
19:51:48 <vincenz> thx
19:51:51 <dons> hmm, no, i think a good gpu code generator would be fairly practical. cheap, commodity-level stream processors for all
19:51:57 <eivuokko> Hmh
19:51:59 <eivuokko> Gotta try
19:52:10 <eivuokko> Actually
19:52:15 <dons> and they're getting more and more general purpose each eyar
19:52:21 <eivuokko> Yeah
19:52:37 <dons> so it becomes easier to port scientific/math algos to the chip
19:52:38 <eivuokko> But, um, you do practically need new generation graphics card.
19:52:43 <dons> yes
19:52:49 <dons> research grants!
19:52:52 <eivuokko> Because you just can't do that stuff with cards from last year.
19:53:14 <dons> luckily they're cheap, in comparison to a vector machine (cough)
19:53:34 <eivuokko> I think there might be fun applications with displacement mapping to increase density.
19:53:39 <vincenz> eivuokko: what do you do for a living?
19:53:46 <vincenz> eivuokko: the website you say you work at is not loading
19:53:54 <dons> all those game programmers demanding faster game graphics are creating a great market for high-speed, cheap stream processors -- capitalism works :}
19:54:17 <eivuokko> vincenz, code c++ (and stuff) for company that makes (equity) trading stuff for brokerages.
19:54:24 <eivuokko> dons, Hehe.
19:55:06 <vincenz> dons: viva capitalism which has high demands for such things as "ebay" "big brother" and other such great items (TM)
19:55:14 <dons> heh
19:55:19 <eivuokko> ;)
19:55:35 <vincenz> read the latest on ebay contra google?
19:55:42 <vincenz> talk about microsoft2.0
19:55:48 <vincenz> well the old microsoft
19:56:28 <dons> here's the student's page, btw, eivuokko: http://cgi.cse.unsw.edu.au/~seanl/index.cgi/Research
19:56:29 <lambdabot> Title: "Research - Sean's Wiki"
19:56:50 <dons> not much up yet, i should get him to sell his work some more.
19:56:54 <eivuokko> dons, Thanks.  I'll check it out.  ... weeh...too many browser tabs
19:58:02 <eivuokko> dons, Researchers should be noisy!  I really like leeching ideas from them ;)
19:58:50 <dons> yeah, i agree. 
19:59:10 <dons> all those brains humming away. its good to take advantage of their work.
19:59:27 <jargonjustin> Actions that return Monads can't take Monads as arguments, right?  Since the type for (>>=) :: m a -> (a -> m b) -> m b, so the function your binding to must take just the contents of the Monad, right?
19:59:47 <eivuokko> Yeah, and anyway, going after new stuff is what keeps programming so fun :)
19:59:47 <lispy> how's code?
20:00:03 <dons> jargonjustin: hmm, no not really
20:00:10 <dons> ?type (>>=)
20:00:12 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
20:00:25 <dons> ?type return 1 >>= (\x -> return x)
20:00:27 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a
20:00:43 <dons> so it takes an action, and a computation that takes the result of the first, and does something with it
20:00:53 <eivuokko> jargonjustin, check out liftM and join
20:01:32 <eivuokko> jargonjustin, in case you need combinators.  But if you are new to monads, you probably don't need them right away.
20:01:46 <dons> jargonjustin: also, you don't really say 'takes a monad as an argument'. i would say ' a function that takes a value _in_ a monad, as an argument'
20:01:53 <jargonjustin> dons: But the right side of (>>=) (a -> m b) can not take a monad as input, right?  You'd have to do something like String -> IO String, not IO String -> IO String
20:01:58 <dons> note that the 'm' is the same on all sides of >>=, so its _in_ 'm'
20:02:08 <jargonjustin> I'm just working through some tutorials, trying to understand Monads.
20:02:13 <dons> jargonjustin: right
20:02:15 <lispy> @type join
20:02:16 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
20:02:19 <dons> it takes a function in monad 'm'
20:02:30 <dons> from some argument, to a monadic result
20:02:37 <jargonjustin> dons: Okay, so it can be done, but not with bind.
20:02:37 <lispy> > join [[1]]
20:02:39 <lambdabot>  [1]
20:02:55 <dons> yeah, it can be done, but its rarely used
20:03:10 <dons> since the intermediate type is m (m a), i.e. IO (IO a), which is a bit weird.
20:03:12 <jargonjustin> The m :: * -> * is referring to the Kind, right?
20:03:31 <dons> usually means you're reifying the monadic action -- treating it as data to be played with a bit, before you actually run it
20:03:37 <dons> jargonjustin: yep.
20:03:44 <dons> its a type constructor that takes a type argument
20:03:49 <dons> ?kind Maybe
20:03:50 <lambdabot> * -> *
20:03:54 <dons> ?kind Maybe ()
20:03:56 <lambdabot> *
20:04:02 <dons> type-level functions :)
20:04:22 <dons> similarly,
20:04:26 <dons> ?kind (->)
20:04:28 <lambdabot> ?? -> ? -> *
20:04:41 <dons> arrow takes 2 arguments (the left and right types) and returns a type of kind *
20:04:47 <dons> ?kind (->) Int
20:04:49 <lambdabot> ? -> *
20:04:50 <dons> ?kind (->) Int Bool
20:04:51 <lambdabot> *
20:05:21 * SamB_XP thinks ?kind ought to work on type classes too
20:05:24 <jargonjustin> Makes sense in an abstract way, I'll play with it for a bit.  Thanks aain
20:05:29 <SamB_XP> @kind, even
20:05:31 <lambdabot> Not in scope: type variable `even'
20:05:52 * SamB_XP remembers that he does not like the ?abomination
20:05:54 <dons> SamB: hmm, its weird. since they're just desugar-ed into a data type and function arguments.
20:06:49 <SamB_XP> dons: I suppose :kind doesn't work at a low enough level to do that ;-)
20:07:10 <dons> right, you could imagine the kind of the data type a class decl describes
20:07:22 <dons> but it would be the kind of the core value
20:10:26 <SamB_XP> but I still think :kind ought to handle classes
20:10:38 <SamB_XP> it should maybe use a funky kind of arrow for them
20:11:09 <SamB_XP> or, I dunno...
20:14:16 <eivuokko> dons, Ah, I didn't really know about ANF, and yeah, my SSA stuff was more like ANF, I think.  Thanks for the link. :)
20:14:23 <eivuokko> @karma+ dons
20:14:23 <lambdabot> dons's karma raised to 38.
20:15:00 <dons> cool. i think its a lot simpler to deal with than SSA, so maybe it would make your code easier. i'd be interested to know if you use it
20:18:53 <dons> eivuokko: my cosupervisor (who also looks after sean, the gpu guy) is quite interested in your ssa->asm generator for the ati. any chance you could post the darcs repo somewhere?
20:20:21 <eivuokko> dons, Well, my SSA code is fairly simple because the register allocation is easy on directx shaders as there isn't stack where to spill.  Real optimisations being default extending vectors and writemasks that need to be propagated "backwards".
20:21:31 <jargonjustin> Whoa, using foldl with (>>=) is pretty cool.
20:21:37 <vincenz> eivuokko: I'd still be interested in looking at that code-bit you use to write opcodes and call em... Sadly I won't be around on irc for a bit (conference and such), but if possible an email would be great
20:21:45 <vincenz> @type foldl (>==)
20:21:47 <lambdabot> Not in scope: `>=='
20:21:50 <vincenz> @type foldl (>>=)
20:21:51 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
20:21:53 <dons> currently sean wants to generate Cg, but a lot of his work will be in just virtualising the hardware enough to support normal data types and control flow. it would be interesting to see the asm generating stuff... :) 
20:22:14 <eivuokko> dons, Uhm.  Sorry, I'm not planning to publish it or give it away.  I've been also coding during my work time, and hence it's not stricly all mine..
20:22:24 <dons> ah, ok :( i understand
20:22:32 <eivuokko> dons, The shader asm basic stuff is available at my directx bindings
20:22:41 <dons> ok. thanks
20:22:49 <eivuokko> But that's got nothing to do with ssa thingys etc
20:23:07 <dons> jargonjustin: yeah, i remember the first time i fold'ed >>= over a list of actions. a lovely haskell day :)
20:23:27 <jargonjustin> dons: Yeah, I keep having those.  I like this language.
20:23:34 <vincenz> @type foldr (>>=)
20:23:36 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
20:23:36 <lambdabot>    Expected type: (a -> a) -> (a -> a -> b) -> a -> a -> b
20:24:16 <eivuokko> dons, The code at http://tamelambda.net/darcs/dx9/d3d/DirectX9/D3D/Shader/ implements most/all of the opcodes and make it fairly easy to write pure shader asm in haskell vs generating text asm.
20:24:18 <lambdabot> Title: "Index of /darcs/dx9/d3d/DirectX9/D3D/Shader"
20:25:06 <vincenz> eivuokko: ?
20:25:09 <eivuokko> dons, But unfortunately it requires deep knowledge of instructions...the higher level stuff is the interesting part...that's just the boring pat :)
20:25:22 <eivuokko> vincenz, Sorry.  Yeah, I can send email when I put the code up.
20:25:27 <vincenz> kewl
20:25:36 <vincenz> thx :)
20:27:47 <lispy> @pl join . fmap
20:27:47 <lambdabot> join . fmap
20:27:49 <dons> eivuokko: ok. cheers
20:28:04 <lispy> @pl \f x -> (join . fmap) f x
20:28:04 <lambdabot> join . fmap
20:28:24 <lispy> @pl \f x -> (join . liftM) f x
20:28:24 <lambdabot> join . fmap
20:28:29 <lispy> hmm...
20:28:38 <lispy> @pl \f x -> join $ liftM f x
20:28:38 <lambdabot> (=<<)
20:29:10 <lispy> @pl \f x -> join $ fmap f x
20:29:10 <lambdabot> (=<<)
20:32:15 <jargonjustin> What exactly does @pl do?  Reduces the expression?
20:32:58 <dons> it uses term rewriting to refactor the code mechanically
20:33:09 <dons> to 'pointfree' form
20:33:15 <jargonjustin> Is there a way to do that in GHCi?
20:33:20 <dons> a particularly elegant (or ugly, depending) normal form
20:33:36 <dons> jargonjustin: nope, you need to install lambdabot locally, and run it in your editor, or on the command line
20:33:47 <eivuokko> Is @pl more comprehensive than GHC rules, btw?
20:33:49 <dons> @pl \f x y -> f x y
20:33:49 <lambdabot> id
20:34:01 <eivuokko> (in places where @pl has rules, of course)
20:34:12 <dons> eivuokko: its less 'comprehensive'. there's no check that both sides of the rule have to have the same type
20:34:22 <dons> also, as with ghc, there's no check that the rules don't diverge
20:34:29 <eivuokko> Yeah
20:34:53 <dons> it also doesn't support all of the h98 expression type (no list comprehensions or do notation)
20:35:12 <dons> ndm is actually just starting a project for the uber-rewriter, a child of ghc's rules and @pl
20:35:41 <eivuokko> Well my point was: ghc has the desugared version, but I doubt it has as many over-the-module-boundaries rules as @pl has
20:35:44 <eivuokko> Ah, cool.
20:36:14 <dons> oh, ghc just offers a generic term rewriting system, it could certainly handle over-the-module-boundary rules, if you added them
20:36:28 <eivuokko> Yeah, I really meant ghc+base
20:36:31 <dons>  @pl has many many more rules than have ever been written for ghc, since @pl doesn't care about efficiency.
20:37:24 <eivuokko> Well, I never understood why compilers don't implement scoping/expression pragmas to force insanish iterations on optimisations.
20:39:05 <eivuokko> gcc used to have experimental patch (or maybe it's in nowdays), attribute make-leaf, which would inline everything that is possible into the function attribute was given in.  It localised easily lots of inlining and had huge gains when used on right places.  Instead of raising inliner limits, which killed on bigger translation units, such as c++ including most of stl.
20:40:24 <eivuokko> Such pragma could be usefull on ghc, too.  "inline everything here and run rules three times" ;)
20:42:18 <dons> yeah, i could imagine more control over the simplifier would be useful
20:42:34 <eivuokko> Shouldn't be hard to implement.
20:43:02 <dons> though ghc's pretty good. it just keeps running the simplifier till things don't change, or some other heuristic kicks in
20:43:14 <dons> so with tricky rewrite rules, it can take quite a while, but do a good job
20:43:46 <eivuokko> I wish hacking ghc was easier, sounds like nice project.
20:43:54 <jargonjustin> If I've defined a datatype with constructors take different parameters, but the first parameter is all I care about, is there a good way to pattern match that?
20:44:31 <eivuokko> jargonjustin, Foo a _, that is you must use _ on remaining params.
20:44:40 <eivuokko> One _ for each param.
20:45:04 <jargonjustin> eivuokko: I need to define one pattern per constructor then?
20:45:19 <eivuokko> Uhm, yeah.  Or you can use records.
20:45:27 <jargonjustin> What are records?
20:45:47 <eivuokko> data Foo = Foo { i::Int, w::Int } | Bar { i::Int, z::Int }
20:46:07 <lispy> eivuokko: ghc devs are offering a paid position for a hacker right now if you're really interested
20:46:14 <eivuokko> Now you can extract Int from all constructors with i.  But then the fields must have same type in each constructor.
20:46:26 <eivuokko> lispy, It's worse job than I have, imo :)
20:46:46 <lispy> eivuokko: yeah, they wanted too many hours and some expertise i don't feel like i was strong in
20:46:52 <lispy> otherwise...
20:46:54 <eivuokko> lispy, My problem is that I want to develop in Win32, and ghc in Win32 is too shaky, breaks too often.
20:47:20 <lispy> eivuokko: did you see the position i'm thinking of?  you'd help with issues like that
20:47:27 <lispy> not a core ghc dev
20:47:34 <eivuokko> lispy, Yes.  I know what you are talking about :)
20:47:35 <lispy> but a fringe, corner case fixer
20:47:41 <lispy> coo
20:47:58 <lispy> eivuokko: yeah, i'm trying to use ghc at work
20:48:10 <dons> though it would be a path into getting lots of papers written i suspect.
20:48:14 <lispy> eivuokko: we do win32 only, and it can be shakey in the win32 world
20:48:22 <lispy> dons: how so?
20:48:55 <dons> well, maintaining ghc was simon marlow's job 10 years ago, -- so it leads to things like deep understanding of ghc, hence contributing to the new things, hence getting into papers
20:49:31 <lispy> ah, i see.  long hard journey though :)
20:49:43 <dons> sure
20:49:50 <lispy> man, you expect people to do hard work before getting their rewards? ;)
20:49:54 <dons> just happens that bugs and problems in ghc often turn into papers
20:50:07 <eivuokko> Yeah, backend/rts interaction with stuff like concurrency, stm, ghci has lots of unexplored space.
20:50:23 <lispy> yeah, making haskell fit for the 'real-world' brings up interesting 'corner' cases in functional thinking
20:50:59 <dons> yeah, there's a paper in every new program you write in haskell ;)
20:51:06 <eivuokko> I don't think they are really corner cases.  Just that we don't think orthogonal enough, yet.
20:53:28 * lispy increases his self-efficacy of cooking by making yet another good meal without planning
20:53:45 <jargonjustin> What's the syntax for pattern-matching against a record?
20:53:45 <lispy> i think i'm up to 2 now...
20:54:02 <lispy> jargonjustin: you can do it the usual way, iirc
20:54:08 <lispy> meaning positional
20:54:15 <eivuokko> jargonjustin, foo foo {bar=field} I think
20:54:24 <jargonjustin> lispy: What if I don't want to do it positionally?
20:54:25 <eivuokko> Err, remove one foo.
20:54:31 <jargonjustin> eivuokko: Thanks
20:54:53 <eivuokko> jargonjustin, I never used that myself, not sure it's right.  But I think I saw it somewhere.
20:54:53 <dons> also, you can use the field name as a selector
20:54:59 <dons> f s = field1 s
20:55:14 <dons> where field1 is the field label (and also a function from :: s -> Field1
20:55:29 <dons> field1 s ~= s.field1
20:55:44 <dons> syntactically, if you're picking up what i'm putting down ;)
20:56:43 <eivuokko> Btw, could compiler guarantee that with ghc style unboxed values, one doesn't need memory allocation?  Hence could it be possible to write ghc rts in haskell?
20:57:32 <dons> hmm. i imagine, with some effort, you could write some things. 
20:57:45 <dons> appel wrote a paper on using region inference to write an ml GC in ml
20:57:51 <eivuokko> Ehm
20:58:03 <eivuokko> I meant you wouldn't need GC memory allocation, but stack would be enough.  Much like C.
20:58:07 <dons> yep
20:58:15 <dons> since you've got (# , #) tuples, which go on the stack
20:58:17 <eivuokko> Ah, does regions get stored in stack?
20:58:31 <dons> well, no, but they let you manipulate the heap as a first class value
20:58:41 <eivuokko> Hmh
20:58:45 <dons> so you can write a GC that munges the heap, in a type safe language
20:58:54 <dons> so , related, but not what you were implying
20:59:06 <eivuokko> Another possibility is localised memory allocation, where it's guaranteed that unboxed values don't leak.
20:59:16 <dons> i'd imagine you'd be interested in using Addr# and so on
20:59:25 <eivuokko> Which can then block freed after returning from the scope
20:59:29 <eivuokko> Yes, naturally.
20:59:48 <dons> whether that'd be fun or safe, i'm not sure
20:59:50 <dons> :}
20:59:54 <eivuokko> Interesting stuff is that if strict,unpacked data could also be in stack.
21:00:05 <eivuokko> That might make it worthwhile
21:00:13 <scsibug_> pardon, but what is the meaning of "rts" that is mentioned here pretty frequently?
21:00:18 <eivuokko> runtime system
21:00:50 <scsibug_> ok, thanks
21:00:55 <dons> the stuff that controls how thing are allocated, how threads are scheduled, how functions are applied to arguments, how lazy computations are suspended and evaluated, and so on
21:00:56 <eivuokko> ie stuff that gets linked in the program that provides basic language services
21:01:29 <eivuokko> Well, what I really hate about ghc rts is that it's too much C.
21:01:42 <dons> yeah, maybe it could be smaller.
21:02:08 <dons> someone who just sat there and refactored and audited it, with a view to making it as simple as possible, might be doing a worthwhile job
21:02:15 <dons> though of course, some of it is written in C-- now
21:02:21 <eivuokko> Not much
21:03:36 <eivuokko> The think with haskell rts would be that I think it would make it easier to split rts and compile/link customised parts into user programs.
21:03:58 <dons> right. and just making the rts safer would be a worthy goal
21:04:03 <eivuokko> Yeah
21:04:16 <eivuokko> It'd also remove more deps to external tools.
21:04:41 <eivuokko> gcc really really really is annoying ;)
21:08:28 <lispy> what if we rewrote gcc in haskell?
21:08:36 <lispy> or a c-- compiler in haskell...
21:09:10 <eivuokko> I sort of am thinking maybe it'd be fun to make c-- compiler as there's already parser and stuff.
21:10:09 <dons> well, the c-- compiler is already written in OCaml, isn't it?
21:10:20 <eivuokko> It sucks imo
21:10:30 <dons> and it would probably be a win in the long run to write gcc in haskell
21:10:42 <dons> symbolic manipulation in C is bizarre and wrong, imo
21:10:48 <eivuokko> They (on the site) say it has bad code generator.  And it requires ocaml, gnu toolset and lua and stuff.
21:11:06 <eivuokko> I also hate the burg-system they use embedded in it.
21:11:07 <dons> yeah. too heavy 
21:11:23 <lispy> burg?
21:11:24 <dons> luckily ghc is turning into a C-- compiler :}
21:11:37 <eivuokko> That's not a good reason not make competition ;)
21:12:09 <eivuokko> ghc should externalise c-- part, but the c-- in ghc dcoesn't implement the c-- runtime
21:12:58 <eivuokko> It doesn't, if I understand correctly, for example do proper register alloction/spilling, but requires stg register thingy.  Nor of course continuations/unwinds.
21:13:59 <eivuokko> lispy, burg is a rewriting technology/idea, quite often used in compielr backends to generate (and optimise) asm.
21:14:08 <eivuokko> bottom up rewrite something I think
21:14:38 <lispy> hmm...okay
21:25:01 <SamB_XP> the c-- in GHC doesn't seem to be very up-to-date, either...
21:26:14 <eivuokko> It is getting beefed up, tho
21:26:25 <SamB_XP> oh, does it support parameters now?
21:26:50 <eivuokko> Parameters should be easy to add once it has calling convention :)
21:27:06 <SamB_XP> are you sure you haven't got that backwards?
21:27:17 <eivuokko> Huh
21:27:29 <eivuokko> Do you know what C-- calling convention has to take into account?
21:27:45 <SamB_XP> not really
21:27:48 <eivuokko> Stuff like continuations and unwinding
21:27:56 <eivuokko> Parametrised
21:28:07 <SamB_XP> I do know that looking at the C-- spec makes my brain hurt when I try to think how to possibly compile it
21:28:15 <eivuokko> Hmm?
21:28:24 <eivuokko> Compared to what language?
21:28:26 <SamB_XP> there is just so much...
21:29:19 <SamB_XP> I guess I just don't have a clue how to do a compiler incrementally...
21:29:28 <SamB_XP> or perhaps at all...
21:29:50 <eivuokko> Well, I'm no expert either, could be I am wrong.
21:30:56 <SamB_XP> I suppose it would have to support some calling convention to support parameters
21:31:37 <eivuokko> What my point was that it's so crucial part of c--.
21:33:13 <SamB_XP> yeah, maybe
21:33:36 <SamB_XP> does GHC need continuations much?
21:33:47 <eivuokko> C-- needs to implement continuations, unwinding and stack walking in single stack.  That requires ordering stack so that stack frames can be found and possibly take one or two regs for some state info.
21:34:08 <eivuokko> No, c-- in ghc doesn't have any of that
21:34:12 <eivuokko> (afaict)
21:34:38 <SamB_XP> last I saw it, it didn't even support parens where the parameter list would go
21:34:46 <eivuokko> Uhm
21:34:57 <eivuokko> Ah
21:35:08 <eivuokko> It might have been it used some wierd syntax for that
21:35:25 <SamB_XP> there were no parens...
21:35:38 <eivuokko> But it does support foreign "C" atleast
21:35:47 <SamB_XP> oh, well, yeah.
21:35:51 <SamB_XP> thats kinda crucial ;-)
21:36:02 <eivuokko> It's also pretty easy :)
21:41:47 <u221e> What does the '$' operator mean?
21:42:48 <fanopanik> @type ($)
21:42:50 <lambdabot> forall b a. (a -> b) -> a -> b
21:42:57 <jargonjustin> u221e: It puts parenthesis around the rest of the expression (more or less)
21:43:10 <Saulzar> function application f $ g = f g,  it can be used to avoid brackets like  foo $ some exp  = foo (some exp)
21:43:11 <SamB_XP> > show $ ()
21:43:12 <lambdabot>  "()"
21:43:24 <SamB_XP> > show $ 1 + 3
21:43:25 <lambdabot>  "4"
21:44:09 <SamB_XP> @fixity ($)
21:44:10 <lambdabot> Unknown command, try @list
21:44:19 <SamB_XP> awwwwww
21:44:25 <u221e> thanks.
22:19:32 <palomer> @palomer
22:19:32 <lambdabot> (_|_)
22:19:36 <palomer> man I'm bored
22:19:38 <palomer> @palomer
22:19:39 <lambdabot> They're telling you lies!
22:19:42 <palomer> there are new palomers!
22:19:45 <palomer> @palomer
22:19:46 <lambdabot> Learning vim is pointless
22:19:47 <palomer> @palomer
22:19:48 <lambdabot> Brump!
22:19:48 <palomer> @palomer
22:19:49 <lambdabot> Brump!
22:19:51 <palomer> @palomer
22:19:51 <lambdabot> Learning vim is pointless
22:19:56 <palomer> only one :(
22:21:24 <SamB_XP> @SamB
22:21:25 <lambdabot> Unknown command, try @list
22:21:30 <SamB_XP> @quote SamB
22:21:30 <lambdabot>  Because sliced bread gives horribly uninformative error messages?
22:21:57 <palomer> that's a lie!
22:22:02 <SamB_XP> heh
22:22:04 <palomer> SamB_XP: dude, I'm bored
22:22:20 * palomer transcribes yet another song
22:22:21 <palomer> ugh.
22:23:20 <SamB_XP> @quote SamB
22:23:21 <lambdabot>  Boy, point-free Arrows are worse than Forth...
22:23:24 <SamB_XP> @quote SamB
22:23:24 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
22:23:29 <SamB_XP> @quote SamB
22:23:29 <lambdabot>  Because sliced bread gives horribly uninformative error messages?
22:23:32 <SamB_XP> @quote SamB
22:23:33 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
22:23:38 <SamB_XP> hmm.
22:23:43 <SamB_XP> not too many quotes, eh?
22:23:45 <SamB_XP> @quote
22:23:46 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
22:23:50 <SamB_XP> @quote
22:23:51 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
22:23:58 <SamB_XP> haha
22:24:03 <jgrimes> haha
22:24:15 * SamB_XP breaks into guffaws, except he doesn't know how to guffaw...
22:25:04 <SamB_XP> @quote
22:25:05 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
22:25:12 <SamB_XP> @quote
22:25:13 <lambdabot> lispy says: I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
22:25:35 <SamB_XP> heh
22:25:37 <SamB_XP> @quote
22:25:38 <lambdabot> ndm says: the only language i've seen which is ugly at a deeper level than syntax is perl
22:25:43 <SamB_XP> @quote
22:25:43 <lambdabot> SebastianHanowski says: I tried to formalise a proof of rev (rev l)  = l i found in W. Kluges book "Abstract Computing Machines - A Lambda Calculus Perspective" which is pretty much a 'Pimp My Ride'
22:25:44 <lambdabot> for SECD-machines.
22:26:05 <SamB_XP> @quote
22:26:06 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
22:26:10 <SamB_XP> @quote
22:26:11 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
22:26:34 <SamB_XP> man... forgot that djinn doesn't do GADTs?
22:26:36 <SamB_XP> @quote
22:26:37 <lambdabot> Pseudonym says: I think principal types are overrated
22:26:41 <SamB_XP> @quote
22:26:42 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
22:26:46 <SamB_XP> @quote
22:26:46 <lambdabot> adept says: Tried to co-read and co-understand comonads, but got co-re dump
22:26:52 <SamB_XP> @quote
22:26:53 <lambdabot> dons says: I don't mind autoconf, except for the fact that it's stupid and ugly
22:27:01 <SamB_XP> hahaha
22:27:02 <SamB_XP> @quote
22:27:03 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
22:27:10 <SamB_XP> @quote
22:27:10 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files in Different Directories!"
22:27:21 <SamB_XP> hehe
22:27:23 <SamB_XP> @quote
22:27:24 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
22:27:27 <SamB_XP> @quote
22:27:28 <lambdabot> Pseudonym says: Well, personally, I don't think dumb people should be let near a programming language.
22:27:31 <SamB_XP> @quote
22:27:33 <lambdabot> malcolm says: Most software doesn't need to be fast.  But all software needs a fighting chance of correctness
22:27:38 <SamB_XP> @quote
22:27:39 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
22:27:44 <SamB_XP> heh
22:27:45 <SamB_XP> @quote
22:27:46 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
22:28:03 <SamB_XP> shouldn't that be "harme"?
22:28:22 <SamB_XP> @quote
22:28:23 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
22:28:24 <eivuokko> Why?  (I'm not native english-speaker)
22:28:42 <SamB_XP> eivuokko: well, to go with "trappes" and "sprynges"
22:28:57 <SamB_XP> "variety" probably should be spelled more oddly as well
22:29:07 <SamB_XP> @quote
22:29:08 <lambdabot> Lemmih says: calling an out-of-scope function isn't as easy as I had hoped
22:29:11 <eivuokko> Ok.  Seems like pre-shakespeare or something.
22:29:18 <SamB_XP> pre-spelling
22:29:19 <SamB_XP> really
22:29:24 <eivuokko> Ah
22:29:29 <SamB_XP> shakespeare didn't know how to spell, either ;-)
22:29:55 <eivuokko> Seems good to me from I've seen, but dunno if they were fixed.
22:31:33 <SamB_XP> well, probably many of the small words had particular spellings that were generally used, and perhaps the spellings have been changed for modern editions of shakespear...
22:31:44 <SamB_XP> but he didn't even know how to spell his own name
22:31:52 <SamB_XP> so I don't have to remember, either ;-)
22:32:48 <SamB_XP> @quote
22:32:49 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
22:33:03 <SamB_XP> @quote
22:33:03 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
22:33:03 <lambdabot> squad, but he declined.
22:33:22 <SamB_XP> heh
22:33:29 <SamB_XP> unicycle patrol squad...
22:33:40 <SamB_XP> that sounds really practical, doesn't it?
22:39:14 <palomer> finished transcribing
22:39:18 <palomer> yet another song
22:39:19 <palomer> ugh.
22:48:58 <dons> @tell dcoutts I've fixed the fps benchmark suite. shall we try to get the stream stuff into fps this week?
22:48:59 <lambdabot> Consider it noted.
23:04:14 <u221e> Can anyone access google.com?
23:05:03 <dons> ?google google
23:05:05 <lambdabot> http://www.google.com/
23:05:05 <lambdabot> Title: "Google"
23:05:08 <dons> seems so
23:05:22 <u221e> Hm, I can't. Everything else seems to work.
23:05:35 <dons> try one of the variants, e.g. www.google.com.au
23:05:47 <dons> or ww.google.com (not the two 'w's)
23:06:38 <u221e> Nothing...
23:07:03 <dons> www.google.com.au works here
23:07:10 <dons> so i suppose something's funny at your end
23:07:34 <u221e> Yea, and I don't even live in China ;)
23:07:37 <dons> http://www.google.co.uk/ 
23:07:38 <lambdabot> Title: "Google"
23:07:40 <dons> seems to work too
23:07:53 <SamB_XP> well, if you are feeling lucky, @google away
23:08:00 <dons> maybe look outside, perhaps you ended up in china somehow by accident?
23:08:46 <fanopanik> hmm
23:08:54 <fanopanik> http://www.orf.at
23:08:56 <lambdabot> Title: "news.ORF.at"
23:09:00 <fanopanik> handy
23:09:48 <u221e> I'm having trouble with alot of domains it seems, digg as well.
23:10:32 <fanopanik> maybe one of your ISP's transit providers broke down
23:10:34 <fanopanik> happens to me all the time
23:12:12 <fanopanik> preferably if they are called "cogent"
23:12:38 <u221e> Could it be the dns? What's the IP of google.com?
23:13:09 <dons> ?google What's the IP of google.com?
23:13:12 <lambdabot> http://www.ipchicken.com/
23:13:13 <lambdabot> Title: "IP Chicken - What is my IP? Find Your IP Address!"
23:13:17 <dons> hehe
23:13:24 <dons> i thought maybe, you know, google would be clever
23:14:14 <SamB_XP> @dig google.com
23:14:15 <fanopanik> rr-dns: 64.233.167.99 72.14.207.99 64.233.187.99
23:14:15 <lambdabot> Maybe you meant: dice dict id msg
23:19:45 <u221e> Why can't I define functions in ghci?
23:20:13 <araujo> u221e, you can use let bindings
23:20:17 <araujo> hi all
23:20:26 <fanopanik> http://www.haskell.org/hawiki/HaskellNewbie_2fHaskellInterpreterUsage    
23:20:27 <lambdabot> Title: "HaskellNewbie/HaskellInterpreterUsage - The Haskell Wiki"
23:21:22 <dons> u221e: you can, using 'let'
23:21:25 <dons> let f x = x + 1
23:22:00 <dons> the reason you "can't" the way you want to, is that since haskell supports mutually recursive bindings, it doesn't have a simple semantics for  adding sequential definitions
23:22:13 <dons> as such, doing so only really makes sense inside a monad
23:22:17 <u221e> Oh I see.
23:22:23 <dons> and ghci uses a monad at the top level (IO)
23:22:32 <dons> so you're typing in sequential statements in IO in ghci
23:22:43 <dons> unlike in hugs, which doesn't do this, and thus you can't say 'let f x = x'
23:22:57 <dons> however, in all haskell implementations, you can locally define things as follows:
23:23:04 <dons> > let f x = x + 1 in f 4
23:23:06 <lambdabot>  5
23:23:55 <dons> i think this question (hopefully) i answered in the Haskell in 5 Steps tutorial on haskell.org
23:24:00 <dons> s/i/is/
23:24:24 <dons> since beginners come up against this fairly regularly here.
23:24:54 <dons> oh, its briefly mentioned
23:24:57 <dons> ?gwiki Haskell_in_5_steps
23:25:01 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
23:25:01 <lambdabot> Title: "Haskell in 5 steps - HaskellWiki"
23:32:07 <dons> u221e: you working on a haskell project, or just learning from tutorials?
23:32:26 <u221e> Still learning.
