00:18:45 <wolverian> "and ." :)
00:33:52 * wli tries to find the association list operation "update"
00:39:08 <dmhouse> Anyone else loving the NOOP thread? :)
00:40:15 <dons> bizarre and funny, isn't it?
00:40:42 <dmhouse> I didn't get it at first.
00:40:57 <dons> i like the fact that its all so serious. 
00:41:10 <dmhouse> I recognised pretty quickly it looked fairly pointless, but then he gave a serious 'possible application' and people starting talking about executable sizes...
00:41:33 <dmhouse> A cursory look at the source code and the calls to make it into a library confirmed my suspicions, though :)
00:41:50 <dons> just maybe, people who've never written a haskell project could start with it as a base.
00:41:58 <dons> that would be the most useful outcome, i think
00:42:06 <dons> just to get the cabal files
00:42:17 <dmhouse> Hrm
00:42:26 <dmhouse> Well the Cabal docs already give example files
00:42:32 <dons> and one guy realised his ghc was broken when he built noop
00:42:40 <dons> so that's good
00:56:05 <norpan> what's noop
00:57:11 <dons> ?where hnop
00:57:11 <lambdabot> http://semantic.org/hnop/
00:57:22 <dons> its a cool new haskel project
00:57:51 <xerox> heh
01:04:32 <pesco> dons: Good thing it's under an open license. I use return () all the time...
01:07:13 <norpan> wow, great project
01:07:31 <norpan> it should have a --help option though
01:07:37 <norpan> maybe i can send in a patch
01:08:03 <dmhouse> I just had one of those 'Aaaah' moments where something starts to make a lot of sense :)
01:08:11 <dmhouse> (In this case it was the Church booleans.)
01:08:19 <norpan> oh?
01:08:30 <norpan> you mean that they work like if-then-else functions?
01:08:42 <dmhouse> Yep.
01:08:49 <norpan> yes, that is the point :)
01:09:00 <dmhouse> Actually it was the line 'test b v w reduces to b v w' that made it make sense.
01:09:20 <dmhouse> norpan: But just understanding that one point lets me see how the and, or, not combinators work, etc.
01:09:20 <xerox> Have you ever seen CONS, CAR, & CDR implemented only by lambda abstractions, i.e. by `air' ? (:
01:09:30 <norpan> and church numerals work like base case and recursion case for integers
01:10:11 <dmhouse> So would it be or = \b c -> b tru c?
01:10:27 <dmhouse> And not = \b -> b fls tru?
01:10:48 <dmhouse> Where tru = \x y -> x; fls = \x y -> y
01:11:32 <dmhouse> Seems to be the answers given in my text, good. :)
01:12:39 <norpan> things can be implemented in many ways
01:13:03 <dmhouse> Sure.
01:14:05 <norpan> not = flip
01:14:55 <dmhouse> That'd work too.
01:15:02 <dmhouse> And probably be equivalent to mine.
01:16:52 <norpan> or = liftM2 (.)
01:17:26 <norpan> that one is trickier though :)
01:17:37 <dmhouse> @type liftM2 (.)
01:17:39 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
01:17:57 <dmhouse> I guess this is the (a ->) monad, so it'd be:
01:18:21 <dmhouse> (d -> b -> c) -> (d -> a -> b) -> (d -> a -> c)
01:18:47 <xerox> (a -> b -> c) -> (a -> d -> b) -> (a -> d -> c)
01:19:12 <dmhouse> Right, that's the same as mine.
01:20:19 <norpan> what was that command to create functions from types
01:20:23 <norpan> should work in this case
01:20:36 <xerox> ?djinn a -> b -> (a,b)
01:20:37 <lambdabot> f a b = (a, b)
01:20:48 <norpan> ?djinn (d -> b -> c) -> (d -> a -> b) -> (d -> a -> c)
01:20:48 <lambdabot> f a b c d = a c (b c d)
01:20:52 * dons moves his entire home dir into darcs
01:20:55 <norpan> indeed
01:20:59 <dons> xerox, how's the cabal hacking going?
01:21:02 <norpan> that's "or" for you
01:21:21 <xerox> dons, I'm reading the code just now, they've done some hacking, I'm trying to keep up :)
01:25:06 <Lemmih> I saw some patches from audreyt recently.
01:28:53 <dons> ?karma+ bringert -- polyvariadic nop !
01:28:54 <lambdabot> bringert's karma raised to 3.
01:29:26 <bringert> yay, karma!
01:29:32 <bringert> why do I have 3?
01:29:52 <dons> its a cosmic mystery
01:30:25 <bringert> hmm, maybe the hello world example I gave should have used ByteString
01:30:31 <bringert> for speed
01:30:36 <dons> yes, for speed.
01:30:37 <dons> that's important
01:30:50 <bringert> dons: care to submit a patch?
01:31:02 <dons> yeah, good idea. i'll just hack it up now
01:32:52 <bringert> dons: oh, the hello world example is not in the repo
01:33:03 <bringert> hmm, maybe there should be a strict version, nop'
01:33:58 <dons> and then you'd need some exception handling to avoid the exceptions thrown by bottom having the program do something.
01:34:04 <bringert> ah, now we can write the godot version, since nop can be applied to nop
01:34:40 <dons> i still think hnop might do something, if you interrupt it. you'll get an 'Exception: user error" or such like. which has to be something
01:34:58 <dmhouse> You'd have to be very quick to interrupt it.
01:35:07 <dmhouse> I can't imagine 'return ()' taking up too many cycles.
01:35:09 <bringert> right, that was my thinking with my first reply
01:35:26 <dons> yeah, and then if we wrote nop' undefined
01:35:38 <bringert> and you might be able to do something weird with RTS flags
01:35:49 <dons> import Data.ByteString.Char8
01:35:49 <dons> import Control.Nop
01:35:49 <dons> -- | main, do nothing
01:35:49 <dons> main :: IO ()
01:35:52 <dons> main = nop (pack "do nothing")
01:35:54 <dons> :)
01:35:58 <dons> does nothing :)
01:36:18 <lispy> dons: heh
01:36:23 <lispy> nop rules
01:36:52 <xerox> If I were GHC I would refuse to compile that program.
01:37:16 <lispy> xerox: out of self respect?
01:37:26 <lispy> @type pack
01:37:28 <lambdabot> Not in scope: `pack'
01:37:32 <lispy> @hoogle pack
01:37:33 <lambdabot> Data.PackedString.packString :: String -> PackedString
01:37:33 <lambdabot> Distribution.InstalledPackageInfo.package :: InstalledPackageInfo -> PackageIdentifier
01:37:33 <lambdabot> Distribution.PackageDescription.package :: PackageDescription -> PackageIdentifier
01:37:49 <dons> ?type Data.ByteString.Char8.pack
01:37:50 <lambdabot> String -> Data.ByteString.Base.ByteString
01:37:55 <lispy> ah
01:38:37 * lispy has been at the pub and thus should have his irc license temporarily revoked and also implicitily appologizes before he insults
01:46:28 <Lemmih> Sigh. What do I need to sacrifice to keep the gods from taking my harddisks?
01:46:57 <kaol> more money to have a RAID array
01:46:58 <dons> they're taking your disks?
01:47:16 <dons> hehe, kaol :)
01:47:17 <kaol> and time to make backups
01:48:42 <Lemmih> Ah, money and time. Not exactly two things I've got in abundance.
01:49:45 <kaol> yeah, the gods are demanding
01:51:29 <bringert> hmm, maybe I should generalize the Godot nop to a replicateNop which takes an Int and does nothing that many times
01:52:04 <bringert> how about a Nop monad which doesn't have any operations?
01:52:37 <lispy> bringert: siman said nop really only makes sense in IO
01:53:32 <bringert> hmm, yeah
01:53:40 <bringert> it could be a monad transformer
01:53:56 <bringert> but then you could embed IO in it and actually do something
01:57:17 <bringert> dons: there should be a nop module for lambdabot
01:58:26 <dons> ah!
01:58:55 <bringert> ?nop
01:58:55 <lambdabot> Maybe you meant: map yow
01:59:16 <bringert> yeah, that does something at the moment, clearly not right
02:00:29 <bringert> hmm, the polyvariadic nop is a bit like /dev/null
02:00:33 <xerox> ``The nop case, 100+1 ways to drive the majority of Haskell hackers nuts.''
02:01:14 <dons> ?id
02:01:18 <dons> that's no.
02:01:20 <dons> p
02:01:27 <dons> almost
02:01:29 <dons> ?id something
02:01:29 <lambdabot> something
02:01:41 <dons> though, that's clearly something
02:02:34 <xerox> You'd probably thought it before, but couldn't ?id raise bot-loop problems?
02:03:25 <dmhouse> How?
02:03:32 <dmhouse> I don't think lambdabot examines its own output.
02:03:36 <dmhouse> ?id ?id foo
02:03:36 <lambdabot> ?id foo
02:03:51 <xerox> Mutually recursive bots :)
02:04:29 <dmhouse> Ah.
02:04:42 <dmhouse> Indeed, with two lambdabots, that'd be a problem.
02:05:43 <dmhouse> ?id ?id foo
02:05:43 <lambdabot> ?id foo
02:05:44 <hsbot> ?id foo
02:05:44 <hsbot> foo
02:05:44 <lambdabot> foo
02:05:56 <dmhouse> xerox, :)
02:13:43 <norpan> i didn't get a chance to try http://norpan.org/~martin/test.html
02:14:08 <norpan> hmmm, doesn't lambdabot give <title> anymore?
02:14:37 <dmhouse> It should do http://google.com
02:14:38 <lambdabot> Title: "Google"
02:15:02 <dmhouse> norpan: That doesn't look like valid HTML to me
02:15:21 <norpan> no?
02:15:34 <norpan> oh, it's missing </head>
02:15:42 <dmhouse> You probably mean <html><head><title>My Title</title></head><body /></html>
02:16:05 <dmhouse> Or <body></body> if you want HTML and not XHTML.
02:16:16 <norpan> is body required?
02:16:45 <dmhouse> Probably.
02:17:00 <norpan> probably is not a good enough answer
02:18:48 <dmhouse> > let foo [] = True in foo "hello"
02:18:49 <lambdabot>  Non-exhaustive patterns in function foo
02:19:06 <dmhouse> Is there any way to turn that runtime error into something more easily dealt with, like Nothing?
02:20:08 <dmhouse> > let foo :: Maybe Bool; foo = do let [] = "hello"; return True in foo
02:20:08 <lambdabot>  Parse error
02:20:24 <dmhouse> > let [] = "hello" in True
02:20:25 <lambdabot>  True
02:20:40 <dmhouse> > let foo = do let [] = "hello"; return True in foo :: Maybe Bool
02:20:40 <lambdabot>  Parse error
02:20:57 <dmhouse> > let foo = do { let [] = "hello"; return True } in foo :: Maybe Bool
02:20:57 <lambdabot>  Parse error
02:21:07 <dmhouse> Weird.
02:22:00 <norpan> how can you return Nothing, when you don't return a maybe type
02:22:47 <dmhouse> ?
02:22:57 <dmhouse> Pattern-match failures in a do block invoke fail.
02:23:07 <norpan> sure
02:23:15 <norpan> i was commenting on your previous statement there
02:23:23 <norpan> i see now that you want to return a maybe type
02:23:45 <dmhouse> Yeah okay. s/foo [] = True/foo [] = Just True/
02:24:11 <dmhouse> > let foo = do { let [] = "hello"; return True; } in foo :: Maybe Bool -- why doesn't this work?
02:24:11 <lambdabot>  Parse error
02:25:26 <dmhouse> > let foo = do { let (x:_) = "hello"; return True } in foo :: Maybe Bool
02:25:26 <lambdabot>  Parse error
02:25:28 <kaol> > let foo = do { let [] = "hello" in return True } in foo :: Maybe Bool -- or is this the same thing?
02:25:28 <lambdabot>  Just True
02:25:43 <dmhouse> kaol: I don't think so.
02:25:46 <dmhouse> Perhaps why I need is:
02:26:04 <dmhouse> > let foo = do { Just [] <- return "hello"; return True } in foo :: Maybe Bool
02:26:04 <lambdabot>  Couldn't match `[Char]' against `Maybe a'
02:26:37 <dmhouse> ... ?
02:27:00 <dmhouse> Oh. Heh.
02:27:01 <dmhouse> > let foo = do { [] <- return "hello"; return True } in foo :: Maybe Bool
02:27:02 <lambdabot>  Nothing
02:59:14 <wolverian> heh. "[...] unfortunately it appears that reading an explanation of the Y [combinator] is somewhat recursive too. You don't get it unless you already get it."
03:00:23 <wolverian> I just tried to apply the Y combinator to the factorial function. it only took me a few iterations (recursions?) to realise it's somewhat futile to do it for integers larger than 3..
03:03:42 <dmhouse> Why?
03:04:02 <wolverian> it gets big.
03:04:15 <dmhouse> Oh, you expanded it out. I see.
03:04:17 <norpan> how do you apply the Y combinator to the factorial function?
03:04:18 <wolverian> right.
03:04:27 <wolverian> norpan, that is, to the non-recursive factorial function
03:04:49 <wolverian> g f n = if n == 0 then 1 else n * f (n - 1)
03:05:21 <wolverian> anyway, that quote was funny, I think :) 
03:05:35 <dmhouse> > fix (g f n = if n == 0 then 1 else n * f (n - 1)) 3
03:05:35 <lambdabot>  Parse error
03:05:46 <dmhouse> > fix (\f n = if n == 0 then 1 else n * f (n - 1)) 3
03:05:46 <lambdabot>  Parse error
03:05:53 <dmhouse> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 3 -- Ahem.
03:05:54 <lambdabot>  6
03:06:10 <dmhouse> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 8
03:06:10 <lambdabot>  40320
03:06:15 <wolverian> yeah, I tried to write "\x. ..." in ghci
03:06:37 <norpan> i see how you can _define_ the factorial function with the Y combinator, but apply?
03:06:57 <dmhouse> norpan: He meant expand out the definition. Manually.
03:07:03 <dmhouse> To see how it works
03:07:21 <norpan> well well
03:07:22 <wolverian> right.
03:07:48 <wolverian> should have quoted "apply"
03:08:47 <norpan> you should have quoted "factorial function" :)
03:09:12 <norpan> anyways
03:09:19 <wolverian> hah :)
03:27:25 <dmhouse> Argh. [Haskell] needs to sort out its Reply-To header.
03:28:11 <Saulzar> Hmm. I don't suppose there is a way of using values in pattern matching? I realise one could use guards with ==, but that isn't going to produce efficient code for many alternatives is it?
03:28:29 <dmhouse> Saulzar: Guards are about the best you can get.
03:29:03 <dmhouse> If you mean things like x = 'a'; case y of x:rest -> x, and you want x in the pattern-match to be 'a' and not anything.
03:30:02 <Saulzar> Yes, right..
03:30:17 <Saulzar> But that seems not entirely appropriate for say, 10 alternatives
03:30:37 <dmhouse> Afaik, there's no good way of doing this.
03:33:21 <xerox> If one can CPS-transform code with the Cont monad, it is possible to pack a function to be used with fix, I think.
03:33:34 <xerox> Like that factorial one, for instance.
03:37:09 <norpan> a Rec monad?
03:37:40 <Bacta> when i get that feeling
03:37:45 <Bacta> i want sexual healing
03:37:47 <Bacta> oooooooooooooh baby
03:37:51 <Bacta> im hot just like an oven
03:37:54 <Bacta> i need some loving
03:37:58 <Bacta> when i get that feeling
03:38:03 <Bacta> i want sexual healing
03:38:07 <Saulzar> We've heard you before...
03:38:07 <Bacta> ooooooooooooooooh baby
03:38:11 --- mode: ChanServ set +o dmhouse
03:38:15 <norpan> fac n = if n == 0 then return 1 else mapM (n*) (rec (n-1))
03:38:17 <Bacta> ill be good
03:38:28 <dmhouse> Bacta: less of that, please.
03:38:43 <mux> fac n = product [1..n]
03:38:44 <norpan> yes please
03:40:29 <norpan> > product []
03:40:30 <lambdabot>  1
03:40:36 <norpan> indeed
03:41:18 <dmhouse> fac = product . enumFromTo 1 :)
03:41:24 <xerox> ?type let f n | n == 0 = 1 | otherwise = n * f (n-1) in mfix . Control.Monad.Cont.callCC . return $ return . f 
03:41:25 <lambdabot> forall a b (m :: * -> *). (Control.Monad.Cont.MonadCont ((->) a), MonadFix m, Num a) => m a
03:42:52 <Bacta> can i wash my wanky in your sinky?
03:43:04 --- mode: dmhouse set +b *!*=silvermo@222.155.137.*
03:43:04 --- kick: Bacta was kicked by dmhouse (no.)
03:43:58 --- mode: ChanServ set -o dmhouse
03:44:16 <dmhouse> I need to think up some wittier kick messages.
03:46:50 <vegai> /kick bacta Call me
03:48:50 <dmhouse> Can ChanServ give me a list of the bans on a channel?
03:49:05 <madpickle> type /mode #haskell b
03:49:14 <madpickle> that will list current bans
03:49:20 <dmhouse> Ah, cool.
03:49:22 <madpickle> if you use mIRC, double-click in the channel window
03:50:21 <dmhouse> Thanks.
03:50:48 <norpan> hmmm, chanserv deopped you?
03:50:52 <norpan> or what happened
03:51:00 <dmhouse> I deopped myself.
03:51:26 <dmhouse> I'm not sure why I used ChanServ to do that... :)
03:51:29 <dmhouse> I'm a bit new to this game.
03:58:59 <dmhouse> wolverian: you still around?
03:59:03 <wolverian> yes
03:59:35 <dmhouse> wolverian: My text contains a really nice expansion of fac 3 using Y that makes a lot of things very clear :)
03:59:42 <dmhouse> I'll type it up if you'd like to see it.
03:59:49 <wolverian> sure! sounds great
04:07:22 <lisppaste2> dmhouse pasted "factorial with fix" at http://paste.lisp.org/display/21902
04:07:30 <dmhouse> wolverian: ^^ let me know if anything's not clear.
04:09:57 <wolverian> reading..
04:13:22 <wolverian> I understand intuitively the step from 'h h 3' to 'g fct 3' but I don't understand the exact derivation
04:13:54 <dmhouse> h h 3
04:13:56 <dmhouse> (h h) 3
04:14:12 <dmhouse> (g (\y. h h y)) 3
04:14:24 <dmhouse> g fct 3 where fct = \y. h h y
04:14:39 <wolverian> ah, here we go
04:14:40 <wolverian> thanks
04:15:04 <wolverian> it was the x->h binding that I somehow missed 
04:32:15 <Saulzar> Hmm, can fix be defined by haskell code?
04:32:57 <dmhouse> @index fix
04:32:58 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
04:33:09 <dmhouse> Saulzar: ish.
04:33:16 <dmhouse> fix f = let x = f x in x
04:33:27 <dmhouse> But then that's a recursive let, and they're translated to fix :)
04:33:35 <dmhouse> Make your own decision about which is the more primitive.
04:33:56 <norpan> fix f = f (fix f)
04:33:56 <dmhouse> I assume GHC translates reclets to fix, and that fix is primitive.
04:34:38 <dmhouse> Hrm, or perhaps not.
04:35:19 <pesco> dmhouse: Are you still interested in that "Markdown" parser?
04:35:20 <norpan> recursion is no problem when using data rewriting
04:35:39 <dmhouse> pesco: Possibly. Are you the guy I emailed?
04:35:46 <pesco> dmhouse: Yes. ;)
04:36:11 <dmhouse> Cool. I have thought about just using, say, emacs's org-mode files instead of Markdown files.
04:36:25 <pesco> dmhouse: Dunno what org-mode is.
04:36:26 <dmhouse> But if you were going to write it anyway...
04:37:01 <dmhouse> pesco: Kinda like a combined mode for todo and wiki-style stuff, with scheduling thrown in.
04:37:06 <pesco> dmhouse: Yes, I need it for my own purposes. I've got the parser running but it doesn't parse all block-level constructs yet.
04:37:29 <pesco> dmhouse: Aha.
04:38:16 <pesco> dmhouse: I'm writing the HTML export now.
04:38:39 <dmhouse> pesco, ooh, cool :)
04:39:27 <pesco> dmhouse: Unless anything happens, I'll have it running "real soon".
04:39:43 <dmhouse> pesco, hehe. Do drop me an email when that comes around.#
04:39:54 <dmhouse> I hope you'll email the mailing list anyway.
04:40:03 <pesco> [Haskell] you mean? Sure.
04:40:15 <kpreid> dmhouse: in HTML, the opening and closing tags for HTML, HEAD, and BODY are optional.
04:40:43 <pesco> kpreid: Is that still considered valid?
04:41:02 <dmhouse> kpreid: Ah, that's right, I remember reading about that on Anne Van Kesteren's weblog.
04:41:03 <kpreid> pesco: still as of HTML 4.01
04:41:13 <kpreid> the only thing you can't leave out is <title>...</title>
04:41:14 <pesco> kpreid: Oh. Ok.
04:41:22 <pesco> kpreid: Really. Huh.
04:41:28 <kpreid> XHTML is a whole 'nother thing
04:41:34 <pesco> Right.
04:42:06 <kpreid> (or rather, XHTML and HTML documents actually have the same structure; it's just that SGML allows for /implicit/ tags where HTML doesn't)
04:43:23 <yip> doesn't xhtml have more features though, like namespaces and shit?
04:43:35 <dmhouse> XHTML has all of XML's features.
04:43:38 <kpreid> those are XML features
04:43:42 * pesco hides his head under a pillow
04:43:54 <pesco> (or another window)
04:43:57 <kpreid> so, yes, an XHTML docuemnt can contain more than a HTML document
04:44:11 <dmhouse> But as of now (or, at least, when I left the HTML scene), there's not much XHTML can do that HTML can (in practice, at least);
05:14:28 * joelr1 waves
05:14:35 <joelr1> folks, what does this mean>
05:14:36 <joelr1> Chasing modules from: HOC.hs
05:14:36 <joelr1> Could not find module `Language.Haskell.THSyntax':
05:14:52 <joelr1> i thought th is preinstalled and i also checked ghc-pkg -l
05:15:42 <Saulzar> joelr1, Compiling with profiling per chance?
05:16:06 <joelr1> Saulzar: need to check. i'm trying to compile the Haskell Objective-C Bindings
05:16:36 <dmhouse> TH isn't preinstalled.
05:16:43 <dmhouse> Or hang on, it might be.
05:16:46 <dmhouse> I don't remember.
05:17:00 <Saulzar> I think it is, I've never installed it, but it's there.
05:17:15 <Saulzar> It's just that there are separate libs for profiling/non profiling... you need the profiling libs to compile profiling stuff.
05:17:18 <joelr1> Saulzar: no profiling, i don't think so
05:17:31 <joelr1> dmhouse: template-haskell-1.0, i see this 
05:17:50 <dmhouse> joelr1: is it in brackets?
05:18:01 <joelr1> dmhouse: nope
05:25:28 <joelr1> i think it became TH.Syntax
05:26:36 <vegai> [vegai@chat lambdabot]$ runhaskell Setup.hs build
05:26:38 <vegai> ...
05:26:40 <vegai> Regex.hsc:67:9: Not in scope: `P.unsafeUseAsCString'
05:26:52 <vegai> that's lambdabot-4.0 with latest fps
05:27:28 <joelr1> is anyone on mac intel?
05:27:51 <vegai> I suppose Regex isn't even using fps. ghc is 6.4.2
05:28:10 <vegai> oh, it is. import qualified Data.ByteString as P
05:31:14 <vegai> I wish lambdabot could depend on release versions ;-/
05:32:42 <Cale> all its dependencies are in darcs, so it's not too hard
05:33:05 <vegai> yes, but the non-release versions of fps are quite unstable
05:33:34 <vegai> which makes it too hard for my very limited attention span...
05:35:38 <vegai> I think it's standard practice that release versions depend only on release versions of other software. Is there a reason this is not valid for Haskell programs?
05:35:52 <joelr1> are there any definite template haskell resources?
05:36:14 <joelr1> i need to update HOC to work with "new" template haskell and i don't have a clue apart from the error messages
05:43:31 <joelr1> Cale: ping
05:44:33 <norpan> ad HOC?
05:45:58 <joelr1> Haskell Obj-C Bindings
05:46:03 <joelr1> cocoa haskell, basically
05:47:05 <joelr1> any idea why the following would return an error?
05:47:06 <joelr1>     argInst <- instanceD (cxt []) (conT (thModulePrefix "Arguments" "ObjCArgument")
05:47:06 <joelr1>                                    `appT` ty `appT` ty)
05:47:23 <joelr1> assuming: thModulePrefix mod id = "HOC." ++ mod ++ ":" ++ id
05:47:25 <dmhouse> What's the error?
05:48:07 <joelr1> Couldn't match `Name' against `[Char]', expected Name, got [Char] in the application of thModulePrefix
05:49:09 <dmhouse> What type have you annotated thModulePrefix with?
05:49:14 <joelr1> hm
05:49:18 <joelr1> no type
05:49:22 <joelr1> dmhouse: as is
05:49:31 <joelr1> thModulePrefix mod id = "HOC." ++ mod ++ ":" ++ id
05:49:35 <dmhouse> What's the type of conT?
05:49:39 <dmhouse> I bet it takes a Name.
05:49:42 <joelr1> hmm
05:49:58 <joelr1> i think conT is a TH thing
05:50:01 <joelr1> let me look it up
05:50:14 <dmhouse> @hoogle conT
05:50:15 <lambdabot> Language.Haskell.TH.conT :: Name -> TypeQ
05:50:15 <lambdabot> Control.Monad.Cont :: module
05:50:15 <lambdabot> Control.Monad.Cont.Cont :: ((a -> r) -> r) -> Cont r a
05:50:19 <dmhouse> There you go.
05:51:09 <joelr1> right
05:51:19 <dmhouse> @hoogle Name
05:51:19 <lambdabot> Language.Haskell.TH.Name :: data Name
05:51:19 <lambdabot> Language.Haskell.TH.Syntax.Name :: OccName -> NameFlavour -> Name
05:51:19 <lambdabot> Text.Html.name :: String -> HtmlAttr
05:51:23 <joelr1> dmhouse: how do i convert [Char] to Name?
05:51:27 <dmhouse> joelr1: I wouldn't know.
05:51:39 <joelr1> dmhouse: right. thanks
05:52:19 <norpan> there are functions to create Name
05:52:25 <norpan> depending on what name you want
05:53:15 <joelr1> norpan: beats me. i would venture to guess whatever name is closes to [Char]
05:53:38 <joelr1> norpan: the issue is that hoc uses old th syntax or something like that. i'm trying to fix it to use the new th syntax
05:54:37 <norpan> well, mkName does it
05:54:45 <joelr1> norpan: let me try...
05:54:53 <joelr1> norpan: how did you figure it out?
05:55:27 <norpan> figure what out
05:55:36 <joelr1> norpan: that mkName was needed :D
05:55:46 <norpan> mkName has type String -> Name :)
05:56:24 <joelr1> norpan: yes, but where did you look to figure that out? /teach a man to fish!/
05:56:41 <norpan> the source...
05:56:46 <joelr1> norpan: did you just guess that mkName would be the constructore?
05:56:54 <joelr1> the source of?
05:57:06 <norpan> Language.Haskell.TH
05:57:13 <joelr1> norpan: ah!
05:57:20 <norpan> where the types are
05:57:37 <joelr1> cool
05:57:48 <dmhouse> joelr1: ghci -package template-haskell
05:57:49 <joelr1> fortunately, that fixed the TH issues. ffi issues are a bit easier to fix
05:57:56 <dmhouse> Prelude> :b Language.Haskell.TH
05:58:14 <joelr1> dmhouse: right
05:59:32 <joelr1> thanks norpan and dmhouse 
05:59:46 * joelr1 is looking to develop mac apps in haskell
05:59:54 <joelr1> my heart is just not in web apps
06:26:38 <neologism> any native english spekaer here?
06:27:23 <vegai> many natives and several better than natives... ;P
06:27:50 <dmhouse> neologism: What do you need?
06:28:19 <neologism> what is a "weiner" ?
06:28:27 <neologism> its not in my dictionary nor I found it on web
06:28:38 <dmhouse> urbandictionary.com
06:28:55 <dmhouse> It can mean either a type of sausage, or something you'll undoubtably find on that website.
06:29:06 <Igloo> A misspelling of "wiener"
06:29:15 <dmhouse> It's actually German for "Something from Vienna".
06:29:20 <dmhouse> Ah yeah, it's spelt wrong too.
06:29:23 <neologism> thnx
06:31:19 <fanopanik> Or an inhabitant of Vienna.
06:33:22 <joelr1> how do you tell ghc that a certain library needs to be linked in statically?
06:41:24 <wolverian> pesco, hey, Markdown for Haskell sounds useful. do you have it online?
06:41:43 <wolverian> dmhouse, thanks, that made things clearer indeed.
06:41:59 <dmhouse> wolverian: Good stuff.
06:43:19 <wolverian> now I only need to find out what such a construct is actually useful for 
06:43:21 <wolverian> :-)
06:43:47 <joelr1_> darn, i'm giving ghc --make the -llib option but it loads it dynamically
06:43:49 <joelr1_> darn
06:43:58 <dmhouse> wolverian: it's used to define recursion, normally.
06:44:20 <dmhouse> You start with the untyped lambda calculus, or a combinator caclulus, then add Y and you get recursion.
06:44:46 <wolverian> hum, right. you can see I'm just learning lambda calculus itself too.
06:44:54 <wolverian> thanks. :)
06:45:16 * joelr1_ tears his hair out
06:45:42 <joelr1_> how do you tell ghc to link a given library statically? 
06:46:15 <xerox> What about -static ?
06:46:19 <joelr1_> tried
06:46:35 <joelr1_> doesn't work. i mean i put the option right in front of the library like this
06:46:45 <joelr1_> -static -lSystemStubs -dynamic -framework Foundation
06:47:07 <xerox> Maybe you should ping Andre Pang.
06:47:07 <joelr1_> but it still says: Loading object (dynamic) SystemStubs ... failed.
06:47:18 <joelr1_> andre pang?
06:47:28 <xerox> He's usually quite responsive wrt HOC.
06:47:39 <joelr1_> xerox: it's not a HOC issue
06:47:47 <joelr1_> xerox: more like a regular ghc issue
06:47:55 <xerox> Ah, no idea.
06:48:06 <joelr1_> i expect -static -lfoo to link foo dynamically
06:48:46 <SamB_XP> you do?
06:50:05 * SamB_XP doesn't believe joelr
06:51:01 <dmhouse> How do you get all the matches to a given regex with Text.Regex?
06:51:10 <joelr1_> wierd
06:51:30 <joelr1_> SamB_XP: too little sleep today
06:51:49 <xerox> dmhouse - May you leave me a message now, a dummy one?
06:51:51 <wolverian> http://haskell.org/hoogle/?q=Text.Regex am I high or do the results there make no sense?
06:51:52 <lambdabot> Title: "Text.Regex - Hoogle"
06:52:02 <dmhouse> @tell xerox sure. Why?
06:52:02 <lambdabot> Consider it noted.
06:52:05 <xerox> ?quote
06:52:06 <lambdabot> blackdog says: I'm not encouraged by the comment "i don't know haskell, but CL is much better", though. it doesn't suggest careful thought and objectivity...
06:52:07 <SamB_XP> joelr1_: you sleep in daytime?
06:52:18 <xerox> ?id she doesn't see me.
06:52:19 <lambdabot> she doesn't see me.
06:52:34 <xerox> ?arr
06:52:34 <lambdabot> Shiver me timbers!
06:52:38 <SamB_XP> @quite
06:52:38 <lambdabot> Maybe you meant: quit quote
06:52:42 <xerox> That's it.
06:52:42 <lambdabot> xerox: You have 1 new message. '/msg lambdabot @messages' to read it.
06:52:42 <SamB_XP> @quote
06:52:42 <lambdabot> xerox says: you know, befunge is probably the only language I've seen where you can run code pasted from IRC with the <nick> tags still in place ;-)
06:52:46 <pesco> wolverian: I'll put the first pre-release version up soon.
06:52:54 <joelr1_> SamB_XP: i positively should. i'm in spain and it's called siesta 
06:53:12 <SamB_XP> joelr1_: ah
06:53:29 <wolverian> pesco, yay :)
06:53:33 <SamB_XP> xerox: hey, I've done that too ;-)
06:53:41 <dmhouse> xerox, Ah. Lambdabot should probably ping you even if it was a command.
06:53:42 <xerox> ^_^
06:54:21 <dmhouse> I think that's probably a problem at the contextual level, though.
06:54:52 <dmhouse> @ask dons does contextual get called on lines which are commands to the bot?
06:54:52 <lambdabot> Consider it noted.
06:55:05 <SamB_XP> but it doesn't work as well if the first line doesn't consist of a lone V or whatever character sends the IP downwards
06:56:53 <dmhouse> How would I extract all the <title> tags from an XML document with HaXml then?
06:57:54 <SamB_XP> with a filter?
06:58:30 * xerox hops up and down because he wants that code too
06:59:10 <dmhouse> SamB_XP: is it a quick one-liner?
06:59:27 <SamB_XP> hmm
06:59:29 <SamB_XP> I dunno
07:02:07 <SamB> perhaps:
07:02:13 <SamB> deep (tag "title")
07:03:43 <dmhouse> :t runST
07:03:47 <dmhouse> Err
07:03:49 <dmhouse> @type runST
07:03:50 <lambdabot> Not in scope: `runST'
07:03:57 <dmhouse> @type Control.Monad.ST.runST
07:03:58 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
07:03:59 <SamB> does it work?
07:04:12 <SamB> because I apparantly don't have HaXml installed at the moment
07:04:30 <dmhouse> SamB, not sure. It's going to be a bit of a long-winded process as I'll have to parse the XML and everything. I know basically nothing of HaXml at the moment.
07:04:33 <mnislaih> @seen Lemmih
07:04:33 <lambdabot> I saw Lemmih leaving #haskell 32 minutes and 45 seconds ago, and .
07:04:35 <kpreid> of course, ideally it should look for <http://www.w3.org/1999/xhtml>:title so that it doesn't match <foo:title>Mr.</foo:title>
07:05:11 <mnislaih> JaffaCake there ?
07:05:17 <dmhouse> kpreid: Not a problem, there's only a single namespace floating around.
07:05:27 <SamB> @seen JaffaCake
07:05:28 <lambdabot> JaffaCake is in #haskell. I don't know when JaffaCake last spoke.
07:07:15 <Igloo> He's rarely around outside of UK office hours
07:07:47 <SamB> he gets paid to IRC?
07:08:07 <mnislaih> does anyone know why gdb dies on me when launching ghc --interactive on it ?
07:08:20 <Igloo> He gets paid to help users on IRC just as much as he gets paid to help them on the mailing lists I imagine
07:08:22 <SamB> no!
07:08:29 <dons> vegai: you need the darcs version of fps. which is stabilised now. it'll be tagged soon.
07:08:30 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
07:08:45 <SamB> does anyone know why gdb dies on *me* when launching ZSNES for Windows on it?
07:08:52 <SamB> well, only if I try to single step
07:09:04 <mnislaih> in my case, I can't get past 'run'
07:09:21 <mnislaih> it never ends launching ghci
07:09:34 <SamB> it dies or it takes forever?
07:09:43 <mnislaih> takes forever
07:09:53 <mnislaih> do I have to compile ghc with any special flag ?
07:09:55 <SamB> have you tried it on a faster machine?
07:10:04 <Igloo> Works for me, FWIW
07:10:06 <mnislaih> I've been waiting for a long while
07:10:10 <vegai> dons: hmm, I just tried it with that
07:10:18 <Igloo> gdb /usr/lib/ghc-6.4.1/ghc-6.4.1    then    run -B/usr/lib/ghc-6.4.1 --interactive
07:10:19 <SamB> have you tried installing a newer GDB?
07:10:29 <mnislaih> no
07:10:46 <dons> vegai: well, i've got both installed and things are all good. looks to me like you've got an fps from a couple of weeks ago?
07:10:46 <mnislaih> I'm using 6.4-debian
07:10:57 <vegai> I suppose.
07:11:09 <dons> before unsafeUseAs* moved into Data.ByteString.Base (the last change, hopefully, to the api)
07:11:23 <mnislaih> Igloo: yes, that's what I'm doing
07:11:27 <SamB> mnislaih: oh, do you see the prompt
07:11:29 <SamB> ?
07:11:41 <mnislaih> Igloo: should it take long ?
07:11:44 <SamB> because you have to type ^C if you want to go back to the debugger at this point
07:11:45 <Igloo> No
07:12:09 <mnislaih> SamB: no, it stops at 'loading package readline-1.0'
07:12:14 <SamB> oh
07:12:16 <SamB> huh
07:12:20 <SamB> wonder why it loads that?
07:12:26 <mnislaih> and cpu usage is at 100%
07:12:40 <SamB> well, you could type ^C and see where it is
07:13:16 <mnislaih> 0xb7f4f450 in _dl_debug_state () from /lib/ld-linux.so.2
07:13:31 <SamB> because, come to think of it, GCC doesn't actually activate again until some kind of signal hits either it or its target process ;-)
07:13:35 <SamB> er, GDB.
07:13:39 <SamB> too many Gs
07:13:47 <SamB> _dl_debug_state?
07:13:51 <SamB> okay...
07:13:54 <vegai> dons: some sort of a configuration issue, perhaps. I reinstalled latest fps again, and am still getting the same compile error with lambdabot
07:14:09 <SamB> try typing "bt"
07:14:41 <mnislaih> I got a long backtrace, 29 levels
07:14:41 <vegai> I feel deja vu...
07:15:07 <SamB> well, what are some levels after it stops going through _dl_?
07:15:35 <mnislaih> #23 0x08b444f8 in SystemziDirectory_findExecutable_closure ()
07:15:48 <mnislaih> #22 0x0899cbb4 in s7tn_info ()
07:15:53 <SamB> oh, try typing finish a few times
07:16:44 <mnislaih> it looks like the first finish never ends
07:17:06 <dsacode> Hello! My function produces ([Float], [Float]) as a result.. And i want to concatenate element to first array with another function.. Is it possible?
07:17:16 <SamB> mnislaih: okay.
07:17:40 <mnislaih> recompiling without readline would help ?
07:17:40 <SamB> so. does GHCi normally work?
07:17:49 <SamB> are you starting it in a particular directory?
07:17:55 <mnislaih> SamB: yes, I tried
07:18:07 <SamB> I wouldn't think readline would need loading
07:18:29 <SamB> (unless you were trying to interpret code that used it)
07:18:30 <mnislaih> this ghc build loads readline for ghci every time
07:18:35 <SamB> oh?
07:18:41 <SamB> which build is it?
07:18:45 <mnislaih> latest
07:18:48 <mnislaih> 6.5
07:19:03 <SamB> you don't have a ~/.ghci file, do you?
07:19:18 <dmhouse> Isn't an abstract datatype one like Regex, whose constructors aren't exported?
07:19:18 <mnislaih> no I dont
07:19:35 <SamB> dmhouse: sure
07:19:43 <SamB> why? what do you think it isn't?
07:19:51 <dmhouse> From the mailing list:
07:19:56 <dmhouse> 'i mean "Abstract Data Type" (i.e., class)'
07:20:17 <SamB> oh, well, a class would also be rather like an ADT
07:20:23 <SamB> except it isn't a type, of course
07:20:37 <dmhouse> In what way are they similar?
07:20:54 <SamB> well, a class doesn't export constructors either
07:21:07 <mnislaih> SamB: correction: it loads readline because I am loading package ghc
07:21:14 <SamB> mnislaih: ah
07:21:39 <mnislaih> all right, I tried gdb without loading package ghc in ghci and it works
07:22:07 <SamB> so if you run "/usr/lib/ghc-6.4.1/ghc-6.4.1 -B/usr/lib/ghc-6.4.1 --interactive -package ghc", what happens?
07:22:27 <mnislaih> why? you cannot load package ghc in 6.4.1
07:22:34 <SamB> oh, right.
07:22:42 <SamB> well, adjust the version numbers appropriately
07:22:46 <mnislaih> but you mean, yes
07:23:11 <mnislaih> ghci loads a few extra packages: readline, unix, Cabal, haskell98, and finally ghc
07:23:23 <dons> vegai: hmm. you reinstalled fps? you have a current lambdabot?
07:23:30 <dons> seems strange, no one else has reported an issue
07:24:11 * dons $ sleep
07:25:47 <dmhouse> Someone remind me why runST uses rank-2 polymorphism again?
07:26:16 <mnislaih> so that you cannot mix different state threads ?
07:26:22 <dmhouse> Something to do with references escaping.
07:26:42 <sylvan> right.. you need a "fresh" s parameter for each runST so you can't return an STRef from one runST and use it in another
07:27:24 <sylvan> so you can't return anything with the s type parameter in it from runST which keeps everything sane
07:27:35 <dmhouse> @hoogle STRef
07:27:35 <lambdabot> Data.STRef :: module
07:27:35 <lambdabot> Data.STRef.STRef :: data STRef s a
07:27:35 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
07:28:29 <dmhouse> Right. So if it were runST :: forall s a. ST s a -> a, then you could, for example, have ST s (STRef s a) -> STRef s a
07:28:42 <sylvan> right
07:28:45 <dmhouse> But with the extra forall, this is untypable.
07:29:07 <dmhouse> And you can never have ST s (STRef s' a), foralls aside?
07:29:50 <sylvan> well you might be able to, the point is that you can't get any s out from runST
07:29:59 <sylvan> hmm
07:30:06 <vegai> dons: did clean, configure, build, install for fps. Lambdabot is 4.0.
07:30:09 <sylvan> I'm trying to find a paper I read on this
07:30:34 <dmhouse> I remember reading the beginning of one by SPJ on this theme.
07:30:46 <mcnster> gm
07:32:12 <sylvan> well anyway, the s type parameter is "created" in runST so it is unusable outside of it, meaning that you can't return any data containing s from runST (thus all the state is local to whatever is in the action you pass to runST)
07:32:28 <sylvan> I'm probably not using anywhere near the right terminology for this =)
07:33:00 <SamB> it sounds good enough to me ;-)
07:33:07 <mcnster> Q: How many functional programmers does it take to change a lightbulb?
07:33:16 <sylvan> 1
07:33:26 <SamB> functional programmers can't change a lightbulb, duh
07:33:32 <SamB> they can only make new ones
07:33:32 <mcnster> A:  Maybe one, but we won't know (and don't care) until the program runs.
07:33:34 <sylvan> and n-1 to screw it in the rest of the way
07:33:50 <dmhouse> Ah, that's more applicable to laziness than functionality, but hehe :)
07:33:51 <mcnster> Happy Canada Day.  Later  :-)
07:34:03 <SamB> dmhouse: which is?
07:34:09 <dmhouse> SamB: The joke.
07:34:53 <SamB> notice the three different answers ;-)
07:35:04 <dmhouse> SamB: the mcnster's.
07:35:09 <dmhouse> err, s/the //
07:35:16 <SamB> yes, I've figured it out now ;-)
07:36:01 <dmhouse> So is runST just deeply magical? How does it 'create' the inital state?
07:36:15 <dmhouse> Or is it a case of 'you're not allowed to depend on any initial state'?
07:36:29 <SamB> there isn't anything in the state to start with
07:37:11 <SamB> (there are no STThings with that s)
07:37:14 <sylvan> I like to think of the ST monads as a little local heap for each runST
07:37:59 <sylvan> easy to explain to people - they'll never try to, for example, share references between two runSTs
07:38:11 <dmhouse> @google "Lazy State Threads" "Simon Peyton-Jones" "John Launchbury"
07:38:13 <lambdabot> http://citeseer.ist.psu.edu/context/29151/79890
07:38:16 <dmhouse> That's the paper.
07:38:21 <sylvan> yeah I just found it
07:38:40 <sylvan> note to self: the haddock entries often contain useful references
07:39:01 <dmhouse> Yep, I just realised that too :)
07:41:42 <wolverian> http://steve-yegge.blogspot.com/2006/07/wizard-school.html
07:41:43 <lambdabot> Title: "Stevey's Blog Rants: Wizard School"
07:42:06 <wolverian> "... the Wizard will typically write in one of the super-succinct "folding languages" they've developed on campus, usually a Lisp or Haskell derivative."
07:48:51 <Stinger_> what the hell is that?
07:49:43 <norpan> some kind of utopia
07:51:56 <wolverian> an insightful article.
07:52:15 <wolverian> (albeit probably a bit misplaced in a channel with strong research ties..)
07:54:54 <sylvan> wolverian: what the hell did I just read?
07:55:27 <dmhouse> So ST has no direct analogue of get/put, but instead you have you use the MutVar API? (And are MutVars just an older/alternative name for STRefs?)
07:55:59 <wolverian> sylvan, I'll let you make up an explanation yourself :)
07:56:22 <wolverian> (the rest of his blog is written in an entertaining way as well, even if it's not quite so out there..)
07:56:36 <sylvan> dmhouse, yeah it's called STRef and STArray now
07:56:40 <wolverian> for an example, "...Morrowind was a hideous island dominated by volcanoes and disease storms and mud flats and rotting undead zombies, much like a C++ users convention."
07:56:48 <dmhouse> sylvan: cool. Thanks.
07:57:09 <sylvan> wolverian:  lol
07:57:21 <Rheiny> check out http://opal.cabochon.com/~stevey/blog-rants/ too for his older stuff
07:57:25 <lambdabot> Title: "Stevey's Drunken Blog Rants"
07:57:37 <Rheiny> Steve yells and complains a lot but he's ok in my book
08:00:30 <wolverian> I wonder if he's changed his mind about Perl, as he seems to have been pretty violently set against it in the past, but in the wizard article seems to mention Larry Wall in a favourable light.
08:00:43 <wolverian> or maybe it's just too deep for me ... :)
08:01:52 <wolverian> hm, I guess his Perl article isn't to be taken too seriously.
08:11:01 <dmhouse> @spell signiture
08:11:13 <dmhouse> I can never rembember whether it's signature or signiture.
08:11:19 <dmhouse> @tell dons to install aspell already :)
08:11:19 <lambdabot> Consider it noted.
08:16:54 <wolverian> signature 
08:18:09 <cjay> is there a way to make all instances of a class instances of another class in one declaration? something like "instance Woggle Num.."
08:18:54 <xerox> Yes.
08:18:58 <xerox> Hmm.
08:19:01 <norpan> instance (C a) => D a
08:19:06 <norpan> where
08:19:11 <xerox> I am not sure by the way.
08:19:32 <xerox> That certaily work for classes declaration.
08:19:46 <fasta> How should I install HXML-5.5? It can't find Network.Browser
08:20:12 <cjay> norpan: that does not work, a constructor is expected instead of the last a
08:20:39 <cjay> i could encapsulate the class in a type, but that would be ugly
08:21:08 <norpan> maybe it's an extension or maybe you can't do it
08:21:11 <kpreid> instance D (C a) => a ?
08:21:49 <xerox> No, I don't think you can do it.
08:22:00 <cjay> kpreid: Syntax error in instance declaration (unexpected symbol "a")
08:24:14 <kpreid> OK, according to my notes, instance (C a) => D a works
08:24:22 <kpreid> perhaps -fglasgow-exts
08:24:28 <kpreid> and definitely -fallow-undecidable-instances
08:26:05 <fasta> Could not find module `Network.Browser': use -v to see a list of the files searched for (imported from src/Text/XML/HXT/IO/GetHTTPNative.hs)
08:26:11 <cjay> kpreid: yeah, with -fglasgow-exts it compiles, thanks
08:26:13 <dmhouse> cjay: Yes, you can do that, and it is as norpan states.
08:26:19 <fasta> What can I do about this? I am not sure where to use "-v"
08:26:27 <dmhouse> E.g. instance Monad m => Functor m where fmap = liftM
08:26:37 <fasta> I am doing runhaskell Setup.lhs build when I get this.
08:27:05 <dmhouse> sylvan: Have you got a few more minutes?
08:27:37 <dmhouse> Or in fact anyone that thinks they grok runST.
08:28:32 <xerox> fasta: IIRC Network.Browser is in the HTTP package.
08:28:42 <fasta> xerox: I know, and I installed it.
08:29:04 <xerox> ghk-pkg list shows it?
08:29:04 <fasta> xerox: It just does not work, for <unknown reason>
08:29:08 <xerox> *ghc
08:30:27 <fasta> xerox:  network-1.0?
08:30:39 <fasta> xerox: or (net-1.0)?
08:30:43 <xerox> I am not sure.
08:32:15 <dmhouse> Well, I'll ask anyway.
08:32:29 <dmhouse> Could someone read through http://en.wikibooks.org/wiki/Haskell/Existentially_qualified_types#Example:_runST to ensure it makes sense?
08:32:49 <xerox> fasta - What does the .cabal file say?
08:33:16 <fasta> xerox: Name: Browser
08:33:36 <xerox> What is the application depending on that?
08:34:09 <fasta> xerox: HXML-5.5
08:34:56 <xerox> Quite old code :)
08:34:59 <pesco> dmhouse, wolverian: A working preliminary version of the "Markdown" parser (it's not Markdown exactly -- I'm calling it Tixt) and converter to HTML is now available: darcs get http://www.khjk.org/~sm/code/advopost/
08:35:01 <lambdabot> Title: "Index of /~sm/code/advopost/"
08:35:16 <pesco> Thanks, lambdabot.
08:36:20 <pesco> That's part of the program I need it for, the relevant files are Doc.lhs, Tixt.lhs, and DocToHTML.lhs.
08:36:51 <fasta> xerox: Is there something newer?
08:37:01 <fasta> xerox: Or do you mean that it should work?
08:37:10 <xerox> Maybe HaXm
08:37:13 <xerox> HaXml
08:37:28 <fasta> xerox: I also don't seem to be able to complete GHC. 
08:37:40 <fasta> xerox: It nags about gtk+ not being installed, while it is.
08:37:52 <fasta> xerox: complete->compile
08:38:20 <xerox> Compiling GHC is some heavy work :)
08:38:23 <Igloo> Do you have the gtk+ library dev packages?
08:38:31 <fasta> Igloo: yes
08:38:31 <Igloo> You shouldn't need gtk+ to compile ghc, anyway
08:38:37 <xerox> D[5D[5D[5D(Fortunately there exist many binary versions.)
08:39:02 <fasta> xerox: what kind of characters are that?
08:39:24 <xerox> Just lag, nevermind.
08:40:49 <fasta> xerox: Are wireless connections that bad that they send incorrect data?
08:41:28 <xerox> It happens sometime.
08:41:55 <fasta> Igloo: Why can't ghc-cvs be installed on Debian? It needs libgmp3 
08:42:08 <Cale> you'd think there'd be more in the way of error detection
08:42:18 <Igloo> fasta: It's outdated currently
08:42:34 <fasta> Igloo: what is outdated? 
08:42:44 <Igloo> ghc-cvs
08:44:44 <fasta> Igloo: why don't you just give up maintainance then? 
08:47:14 <Igloo> fasta: Because I expect to be updating it soon. The main reason it currently languishes is that debugging it was triggering kernel bugs, so I needed to wait for various kernel issues to be fixed first
08:47:50 <fasta> Igloo: now, that's an unexpected response :)
08:47:53 <fasta> xerox: Does a recent GHC build include HaXML?
08:48:31 <xerox> I don't think so.
08:48:48 <fasta> xerox: but it's in the libraries directory in darcs.
08:48:59 <xerox> Dunno, try.
08:55:12 <dmhouse> Any proofread my article?
08:55:59 <dmhouse> Sorry, *Anyone
08:57:44 <dmhouse> And I probably should have phrased it *Did anyone
09:00:35 <norpan> do you want proofreading on irc too?
09:01:30 <dmhouse> norpan: Hehe.
09:02:03 <norpan> pro fread, that'd be fopen
09:05:56 <xerox> I propose we store the people's Karma as complex numbers, so one can lower just the immaginary parts for puns like that.
09:06:53 <apfelmus> xerox: quaternions, quaternions!
09:10:36 <norpan> err, why would you lower
09:10:41 <norpan> i deserve my karma
09:12:32 <fasta> What's the karma you are talking about?
09:12:54 <dmhouse> ?karma fasta
09:12:54 <lambdabot> fasta has a karma of 0
09:12:58 <dmhouse> ?karma+ fasta
09:12:59 <lambdabot> fasta's karma raised to 1.
09:13:04 <dmhouse> ?karma- fasta
09:13:04 <lambdabot> fasta's karma lowered to 0.
09:13:37 <fasta> Didn't GHC used to build from other compilers? 
09:14:26 <Cale> fasta: at one point
09:14:42 <Cale> obviously the first version couldn
09:14:51 <Cale> 't have compiled itself :)
09:15:24 <apfelmus> dmhouse: it's good!
09:15:24 <apfelmus> if i had time, i would rewrite it a bit, explaining arbitrary rank polymorphism and the introduction of quantifiers beforehand.maybe even tailoring the article to that subject.
09:15:27 <apfelmus> so 
09:16:31 <dmhouse> apfelmus: Hmm. Maybe. Perhaps I should just write another module on polymorphism, it's important enough.
09:16:32 <apfelmus> that introducing polymorphicity to preserve invariants like in runST becomes part of a "general technique"
09:17:12 <dmhouse> apfelmus: Note that the quantifiers are explained further up that page, in the 'The forall keyword' section.
09:17:22 <apfelmus> dmhouse: ah, the text would perfectly fit into that
09:17:48 <dmhouse> Into what? Sorry, too many threads of conversation going on at once. :)]
09:18:11 <apfelmus> dmhouse: into the new page "polymorphism"
09:18:18 <dmhouse> Ah.
09:18:19 <fasta> data ShowH  forall s. Show s > SH s <= Is that correct syntax?
09:18:20 <jrmole> where would i go to look up the definition of the (-> a) monad?
09:18:31 <dmhouse> jrmole: Control.Monad.Reader.
09:18:37 <dmhouse> And it's the (a ->) monad.
09:19:05 <dmhouse> fasta: Eek! Hold on.
09:19:41 <fasta> dmhouse: you want to read it again since it contains lots of typos.
09:20:21 <fasta> dmhouse: modulo that, it seems a good start.
09:20:50 <dmhouse> fasta, just the equals signs. That was due to a bit of over-eager regexing.
09:21:20 <jrmole> ah, then http://haskell.org/haskellwiki/Pointfree is wrong
09:21:21 <lambdabot> Title: "Pointfree - HaskellWiki"
09:21:26 <fasta> dmhouse: instanstiate
09:21:31 <apfelmus> dmhouse: every polymorphic type a->a actually is implicitely quantified as forall a . a -> a and hindler-milner type inference only can cope with forall on the outermost level
09:21:34 <jrmole> i guess it's also ((->) a)
09:21:34 <apfelmus> explaining why existential types are introduced with forall could be useful, too...
09:22:18 <dmhouse> True. I meant to copy that over from the GHC docs.
09:22:48 <dmhouse> fasta, ah, cheers.
09:23:21 <fasta> dmhouse: that's what I meant by reading it again, or integrating a spell checker in your wiki environment (e.g. emacs) ;)
09:23:30 <dmhouse> Yep, I'll do that.
09:23:40 <dmhouse> I think I just didn't know how to spell that word.
09:23:51 <dmhouse> Hell, 'Publish early and publish often'. :)
09:24:44 <fasta> dmhouse: Publish never or publish something correct and useful. How about that? 
09:24:59 <dmhouse> I dislike that.
09:25:08 <dmhouse> Get something out there, even if it's imperfect.
09:25:47 <dmhouse> Don't use that mantra as an excuse for imperfection, though, rather don't wait for your software/articles to be perfect before showing the world.
09:26:53 <fasta> dmhouse: software should come with a label (e.g. "created by a 16 year old")
09:27:26 <apfelmus> perish often and correctly ... (wait, i haven't polished this)
09:27:33 <fasta> dmhouse: actually I like Erlangs approach. 
09:27:53 <fasta> dmhouse: Before they include a library it must have a zillion tests and good documentation.
09:27:58 <dmhouse> Of course.
09:28:23 <dmhouse> But some value > no value.
09:28:45 <fasta>  A community should have one "community" website where only the good libraries are listed. 
09:29:06 <dmhouse> But yes, tests and documentation are a must.
09:29:13 <fasta> Thus everything which doesn't work should be removed instantly by some  "official". 
09:31:14 <norpan> i always write a lot of unit tests at work
09:31:23 <fasta> Having 10 libraries that all suck in one way or the other doesn't help a user of a language.
09:31:25 <norpan> and it's never my code that fails
09:31:44 <fasta> norpan: what language? (not that it matters)
09:33:14 <astrolabe> How can I make Word64 an instance of  Random?
09:33:41 <Heffalump> what is the difficult?
09:33:47 <norpan> fasta: c++, java, and if i'm lucky, haskell
09:33:47 <Heffalump> s/difficult/difficulty/
09:34:10 <norpan> astrolabe: it should already be an instance, surely?
09:34:31 <astrolabe> Is there a library I could import which would do it, or do I have to make my own instance declaration?
09:35:56 <astrolabe> I've got an error 'No instance for (Random BHashType)' where I have 'type BHashType Word64'
09:36:06 <norpan> hmmm
09:36:25 <xerox> You can't make istance of type synonyms astrolabe 
09:36:28 * Heffalump is not aware of any instance
09:36:39 <Heffalump> xerox: that's presumably why he wants to make Word64 the instance
09:36:50 <xerox> You have to wrap them in newtypes if you want to name them differently
09:36:50 <norpan> perhaps it's not
09:36:57 <Heffalump> is there an instance for Word32?
09:37:00 <astrolabe> :)  Hi xerox.
09:37:14 <xerox> Hello 'labwe (:
09:37:21 <xerox> Eck, 'labe.
09:37:24 <astrolabe> Not on this page http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
09:37:45 <fasta> xerox: does xerox mean anything besides the name of a company?
09:38:01 <xerox> fasta - me, if you will ;)
09:38:10 <astrolabe> or this one http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
09:38:15 <norpan> if they are not instances, look at the code for some other type in System.Random
09:38:19 <Heffalump> hmm, well StdGen has at least 30 bits range
09:38:21 <norpan> then just copy and modify
09:38:21 <xerox> ?instances Random
09:38:25 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
09:38:31 <xerox> ?instances System.Random.Random
09:38:52 <Heffalump> why did the command character change to ?
09:39:11 <dmhouse> @instances-importing System.Random Random
09:39:12 <lambdabot> Bool, Char, Double, Float, Int, Integer
09:39:25 <xerox> ?instances-importing System.Random Random
09:39:26 <lambdabot> Bool, Char, Double, Float, Int, Integer
09:39:28 <xerox> Right.
09:40:24 <norpan> will anything be done with the instance visibility system in haskell'
09:41:56 <astrolabe> The report doesn't seem to say how the Random instances for those types are defined.
09:42:13 <dmhouse> norpan: is it a problem?
09:42:33 <norpan> well, it's slightly annoying not being able to hide instances and redefine them
09:48:14 <int-e> norpan: I think you can't really control which instances will be used where in your code. so conflicting instances are bad.
09:48:57 <norpan> i know there are some technical problems
09:49:11 <norpan> but i would like to be able to decide on an instance
09:49:20 <norpan> sometimes there is more than one way to do it for a type
09:49:31 <int-e> yes.
09:50:17 <dmhouse> What about newtypes?
09:50:25 <int-e> I agree that it's something desirable - but it's definitely hard on the implementation, especially if they do separate compilation and optimizations that use inlinining
09:50:34 <dmhouse> They have the annoyance of constructor wrapping/unwrapping, I suppose.
09:50:44 <norpan> newtypes is slightly better now that you can derive any class for them
09:51:51 <int-e> @instances Monad
09:51:52 <lambdabot> ((, ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:51:54 <norpan> if we had something like deriving all except ... then it would actually be good
09:52:10 <int-e> that Either e instance bugs me, for example.
09:52:32 <dmhouse> That (( instance bugs me :)
09:53:17 <int-e> oh, that's ok. that's just a bug in the instances module :)
09:53:57 <dmhouse> Yeah, but I wrote that module ;) Somebody turned on kind annotations in the GHCi output which is throwing my module.
09:57:51 <palomer> you're all nuts!
09:58:33 <int-e> @kind (->)
09:58:34 <lambdabot> ?? -> ? -> *
09:58:39 <int-e> this funny stuff?
09:58:48 <int-e> @kind (->) Int
09:58:49 <lambdabot> ? -> *
09:59:34 <dmhouse> int-e, Nah, the fact that it's now "class Monad (m :: * -> *) where"
10:00:28 <kosmikus> much nicer with the kind annotation, though
10:01:30 <int-e> dmhouse: actually that confuses me - aren't you just interested in lines that begin with 'instance'? (I haven't looked at your code)
10:01:44 <dmhouse> More or less.
10:02:25 <dmhouse> It may not be the kinds, actually. I do look at the 'class ...' bit though.
10:04:28 <int-e> I thought it's this line that breaks:  instance Monad ((->) r) -- Imported from Control.Monad.Instances
10:10:35 <astrolabe> Could this be right?  In order to see the source code for Random, I need the source code for GHC.  This is archived using bz2.  Since I have windows I have to download something that can read bz2, but there is nothing free which does except in the form of source files, so I will need to get a C compiler, install it and....  It all seems a bit excessive.
10:10:58 <Korollary> you can get 7-zip
10:11:19 <astrolabe> thanks, looking now
10:11:34 <norpan> winrar can handle it
10:11:36 <Igloo> You can look at it online in the darcs repo
10:13:28 <astrolabe> Thanks guys
10:14:42 <xerox> ?fptools System.Random
10:14:42 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
10:14:46 <xerox> There you go astrolabe.
10:15:12 <astrolabe> xerox:  That's too easy!
10:15:25 <xerox> Haskell is!
10:16:45 * Heffalump would suggest just making the instance for Word64 by using the Int instance to generate 16 bits of randomness 4 times.
10:17:24 <astrolabe> Sounds sensible.
10:17:29 <int-e> why not 3 times?
10:17:48 <Heffalump> because 64 doesn't divide by 3 nicely and I'm lazy :-)
10:18:01 <Heffalump> it looks to me like the ghc one will generate 32 bits of randomness.
10:18:11 <Heffalump> so if you don't mind being GHC specific you can just go for two instances.
10:18:13 <astrolabe> Also, I could define instances for Word32 etc at the same time.
10:18:39 <astrolabe> So, if I did it properly, how would I get it included as a library?
10:18:53 <Korollary> possibly
10:18:57 <Heffalump> submit a patch, I guess.
10:19:11 <xerox> darcs record, and darcs send.
10:19:40 <dmhouse> int-e, where did you get that module from? It's not on my GHCi. (Control.Monad.Instances)
10:19:43 <astrolabe> Hmmm.  I'd need to connect to some repository huh?  Maybe I'll write it before askeing further.
10:20:30 <xerox> GHC 6.6 ?
10:27:32 <dmhouse> Could be, I'm still on 6.4.2
10:31:47 <dmhouse> Anyone else on 6.6?
10:32:11 <yip> :O
10:32:30 <dmhouse> int-e, could you (or anyone else on 6.6) provide me with the output of 'ghci; :m Control.Monad.Instances Control.Monad.Reader; :i Monad' please?
10:34:45 <astrolabe> ping Heffalump
10:35:18 <astrolabe> or anyone really
10:35:19 <Heffalump> hmm?
10:35:32 * Heffalump is watching the England - Portugal penalty shootout
10:35:49 <Korollary> awful game
10:35:55 * Heffalump didn't really watch it
10:36:09 <Heffalump> I turned it on for a few minutes, Rooney got sent off, got annoyed and stopped again.
10:36:12 <Korollary> nothing to speak of anyway
10:36:15 <int-e> dmhouse: http://pastebin.ca/76478 ... it's 6.5, a fairly current darcs version.
10:36:29 <dmhouse> Thanks.
10:36:55 <astrolabe> In order to make Word64 a Random, I'd need to define RandomR, which finds a random number within a range (a,b).  That seems awkward to do 16 bits at a time.
10:37:06 <int-e> (10 days old)
10:37:12 <Heffalump> need to _define _ it or use it?
10:37:26 <Heffalump> oh, I see.
10:37:46 <astrolabe> I suppose it isn't too bad, I just need to deal with the end cases.
10:37:59 <Heffalump> oh, getting it properly random will be hard.
10:38:10 <Heffalump> as in getting a proper uniform distribution
10:39:00 <astrolabe> More of a pain than hard, I think.
10:39:11 <Heffalump> fair enough
10:39:29 <astrolabe> I can hear people screaming in the pub.
10:39:36 <Heffalump> where are you?
10:39:44 <astrolabe> Malven, Worcs.
10:39:45 <Korollary> 1-1 after 2 kix each
10:39:58 <Heffalump> astrolabe: ah. England then :-)
10:39:58 <dmhouse> int-e, sorry, could you repaste that to paste.lisp.org? Yours seems to be down.
10:40:01 <astrolabe> errr Malvern.
10:40:10 <astrolabe> Heffalump:  yes :)
10:40:30 <int-e> dmhouse: err, if I could reach paste.lisp.org, I would.
10:40:50 <dmhouse> Okay, pastebin.com.
10:41:05 <Heffalump> they're not very good at this scoring business, are they.
10:41:09 <Korollary> nope
10:41:20 <Korollary> Ricardo is good
10:42:09 <Heffalump> I don't think the standard random generator produces a uniform distribution.
10:42:39 <astrolabe> Really?  That's a bit poor.
10:43:03 <Heffalump> it just takes a number modulo the length of the range
10:43:20 <Heffalump> and since the number is a random integer, it'll be biased towards lower numbers
10:43:37 <astrolabe> They should have a warning about that I think.
10:44:03 <int-e> dmhouse: pastebin.com doesn't like me today. try http://code.bulix.org/acufxa-9276 ?
10:44:18 <Heffalump> England _really_ aren't much good at penalty shootouts.
10:44:27 <dmhouse> Finally.
10:44:35 <dmhouse> int-e: Great! Thanks.
10:45:45 <astrolabe> There are lots of grumpy people walking down the hill: 'F******g J***s'  :)
10:46:00 <Korollary> heh
10:47:11 <astrolabe> Perhaps I won't explain that it's the taking part that counts.
10:47:32 <Heffalump> the report says it should be uniformly distributed, FWIW.
10:50:10 <lisppaste2> int-e pasted "Hmm, it works now?" at http://paste.lisp.org/display/21913
10:50:41 <int-e> nice. welcome back, lisppaste.
11:13:36 <dmhouse> int-e: Still around?
11:13:45 <int-e> yes
11:14:26 <dmhouse> Would you be able to do me a similar paste for the arrowic instances?
11:14:28 <dmhouse> @instances Arrow
11:14:29 <lambdabot> (, Kleisli m
11:14:32 <dmhouse> That one breaks too.
11:16:15 <lisppaste2> int-e pasted ":i Arrow with Control.Arrow module" at http://paste.lisp.org/display/21916
11:16:27 <dmhouse> Merci.
11:26:04 <mathewm> I have 'type Row = [ Element ]' is there anyway to make Row an instance of Show?  I want to override the default show 
11:26:41 <dmhouse> What's Element?
11:26:53 <int-e> no. you can make a newtype, newtype Row = Row [ Element ] ... that'll be a bit harder to work with in the code, but you can make your own Show instance then.
11:27:01 <mathewm> a 'data Element = C1 | C2 '
11:27:06 <dmhouse> Actually, there's an easier way, int-e.
11:27:32 <dmhouse> The easiest way is to _not_ derive Show on Element, but instantiate it seperately, and include a showList function which will be used when showing lists of Elements.
11:27:33 <xerox> instantiate Element in Show
11:27:45 <dmhouse> @type showList
11:27:47 <lambdabot> forall a. (Show a) => [a] -> ShowS
11:28:40 <mathewm> Element is already an instance of Show in my code,  I will check out showList - thanks!
11:29:09 <int-e> dmhouse: thanks. that clarifies something I had wondered and then forgotten about.
11:29:43 * dmhouse wonders what would happen if you instantiated Show [Element] as well...
11:29:48 <int-e> (namely, what the hell is that showList for?)
11:30:02 <int-e> dmhouse: that'd be an overlapping instance
11:30:12 <int-e> dmhouse: or conflicting. whatever.
11:30:39 <dmhouse> Ah.
11:30:45 <mathewm> hmmm now, if I have a 'type Foo = [ Row ]', 'type Row = [ Element ]', and 'data element = ...'    am I just out of luck?
11:30:51 <dmhouse> Is that true in general? Instantiating both Foo and [Foo]?
11:31:27 <int-e> if there's and instance Xyzzy a => Xyzzy [a] ... then, yes.
11:31:35 <dmhouse> Ah, of course.
11:31:46 <int-e> and in case of Show, there is such an instance.
11:31:50 <dmhouse> Indeed.
11:32:12 <dmhouse> mathewm: I'm afraid so. There's no showListList or something.
11:32:29 <dmhouse> mathewm: You have two options. 1) Declare your own showing functions. 2) Use newtypes.
11:32:48 <int-e> 3) define your own list ;)
11:33:21 <int-e> (probably not a good idea)
11:33:25 <mathewm> I just didn't want to change all my code to move from a type syn. to a newtype...
11:35:02 <dmhouse> Is The Haskell Sequence worth subscribing to? It doesn't appear to publish anything other than HWN.
11:35:23 <mathewm> there must be some haskell refactoring tools out there...
11:36:02 <dmhouse> mathewm: HaRe? :)
11:36:08 <dmhouse> @hoogle haskell refactorer
11:36:09 <lambdabot> Did you mean: Haskell Refactorer
11:36:09 <lambdabot> Prelude.undefined :: a
11:36:09 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:36:12 <dmhouse> Argh.
11:36:14 <dmhouse> @google haskell refactorer
11:36:16 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
11:36:25 <dmhouse> Why do we have two seperate interfaces?
11:37:17 <Igloo> Because we have 2 separate tools, if you mean google and hoogle
11:37:38 <Igloo> hoogle searches for Haskell functions in the standard libraries etc
11:37:50 <dmhouse> I do. But I like #emacs's fsbot. If it doesn't know about something, it googles for it
11:38:01 <dmhouse> I think @where + @hoogle + @google should be combined.
11:38:08 <dmhouse> + @seen.
11:38:31 <norpan> that's arbitrary overloading thinking
11:38:34 <Igloo> This sounds like perl DWIMism to me  :-)
11:38:49 <dmhouse> @google defined: DWIM
11:38:51 <lambdabot> http://www.redhat.com/archives/rhl-devel-list/2005-January/msg01123.html
11:38:53 <dmhouse> Grr.
11:38:54 <astrolabe> I prefer them separate
11:38:55 <dmhouse> @google define: DWIM
11:38:55 <lambdabot> No Result Found.
11:39:03 <astrolabe> @where astrolabe
11:39:03 <lambdabot> http://www.mhs.ox.ac.uk/epact/picturel.asp?record=95&enumber=40428&level=overview&sort=InstrumentTypeWithoutMarkup&searchtext=
11:39:06 <astrolabe> :)
11:39:07 <roods> i just installed ghci and cna't get anything to work that is in the tutorial i'm reading.
11:39:15 <norpan> @where norpan
11:39:15 <lambdabot> I know nothing about norpan.
11:39:20 <dmhouse> roods, what are you trying?
11:39:20 <norpan> @google norpan
11:39:24 <lambdabot> http://norpan.org/
11:39:24 <lambdabot> Title: "norpan.org"
11:39:30 <norpan> hey
11:39:34 <Igloo> Do What I Mean
11:39:35 <roods> makeList = 1 : makeList
11:39:49 <dmhouse> roods, unfortunately, you can't just type things into GHCi.
11:39:57 <dmhouse> roods, you have to prefix function definitions with 'let'.
11:40:05 <dmhouse> Try 'let makeList = 1 : makeList
11:40:11 <dmhouse> Err, without the apostrophe.
11:40:23 <palomer> > let makeList = 1 : makeList in makeList
11:40:24 <roods> dmhouse: why isn't that explained in any of the totorials
11:40:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:40:40 <roods> is there another interpreter that doesn't act like this?
11:40:40 <dmhouse> roods, I don't know.
11:40:53 <norpan> roods: put your code in a file
11:41:08 <roods> ya that is one option.
11:41:10 <norpan> and :l and :r in ghc
11:41:14 <norpan> in ghci i mean
11:41:37 <roods> how do i stop that makelist thing.
11:41:41 <roods> C-c isn't working.
11:41:48 <norpan> C-c should work
11:41:57 <dmhouse> Try any of C-d, C-c, C-z... The usual suspects.
11:42:05 <palomer> the off button!
11:42:12 <norpan> pull the plug!
11:42:21 <fasta> norpan: I wanted to say that :(
11:42:22 <norpan> throw the main switch!
11:42:36 <dmhouse> Hehe. You can't stop it! You'll just have to wait until the heat death of the universe!
11:43:09 <palomer> @palomer
11:43:09 <lambdabot> That's a lie
11:43:12 <Igloo> On the plus side, its continuous running will accelerate the process
11:43:19 <fasta> Sound/OpenAL/Config.hs:46:17: Not in scope: type constructor or class `HTYPE_ALBOOLEAN'
11:43:20 <norpan> @norpan
11:43:20 <lambdabot> Unknown command, try @list
11:43:32 <fasta> That's what I get when I complete GHC darcs.....
11:43:39 <palomer> haskell is like my family
11:43:40 <fasta> er compile
11:43:43 <Igloo> fasta: Tuen of openal and openalut
11:43:44 <dmhouse> _Sound_?
11:43:45 <palomer> the more I stay away from it, the more I like it
11:43:54 <Igloo> s/Tuen/Turn/
11:44:02 <dmhouse> s/of/off/ as well. :)
11:44:02 <fasta> Igloo: is it always broken?
11:44:05 <Igloo> s/of/off/ # Euch
11:44:06 <norpan> yes, you should visit haskell only on special occasions
11:44:18 <fasta> Igloo: It seems nobody cares about that code. 
11:44:34 <Igloo> I thought it was fixed, but I haven't been following too closely
11:44:38 <SamB> haskell doesn't cook very good food, or eat it for that matter
11:45:07 <roods> so can you define functions like factorial interactively?
11:45:21 <norpan> yes, by using let
11:45:32 <roods> let factorial  1 = 1 followed by let factorial n = n * factorial(n-1)
11:45:34 <roods> isn't work.
11:45:38 <norpan> no
11:45:48 <norpan> that kind of definitions can't be made interactively
11:45:53 <dmhouse> let factorial 1 = 1; factorial n = n * factorial (n - 1) is probably easiest.
11:45:59 <roods> ya i've seen that.
11:46:08 <int-e> let factorial n = product [1..n]
11:46:13 <norpan> cheating
11:46:15 <dmhouse> int-e, noo! Shh.
11:46:15 <roods> is there an emacs mode for haskell?
11:46:27 <dmhouse> roods: There certainly is :) And it's excellent, too.
11:46:30 <dmhouse> @where haskell-mode
11:46:30 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
11:46:38 <roods> i think i'll try that.
11:46:39 <fasta> dmhouse: I wouldn't call it excellent. 
11:46:40 <roods> thanks.
11:46:50 <palomer> haskell-mode comes with emacs
11:46:53 <palomer> btw
11:46:56 <dmhouse> palomer: Err...
11:47:05 <norpan> roods: since haskell has recursive bindings, it's better to define stuff in a file
11:47:17 <dmhouse> No it doesn't.
11:47:33 <palomer> I didn't install emacs-mode on this computer.
11:47:37 <roods> how do you run ghc on a saved file?
11:47:43 <dmhouse> roods: :load filename
11:47:47 <dmhouse> Or :l filename for short.
11:47:53 <palomer> oh, you're right, I don't have haskell-mode!
11:47:55 <dmhouse> Then when you make changes, :reload, or :r for short.
11:48:08 <palomer> hah, I haven't touched haskell in a month!
11:48:13 * palomer touches haskell
11:48:15 <roods> thanks guys.
11:48:17 <dmhouse> palomer: Why?
11:48:35 <palomer> girlfriend broke up with me
11:48:37 <Korollary> @palomer
11:48:38 <lambdabot> woof
11:48:39 <palomer> decided to stop doing research
11:48:56 <palomer> caught mono
11:49:07 <palomer> the usual
11:49:23 <fasta> palomer: Que?
11:49:32 <palomer> Que!
11:49:39 <fasta> palomer: Quod?
11:49:44 <palomer> Quod!
11:49:58 <fasta> palomer: Uria?
11:50:03 <palomer> Uria!
11:50:05 <palomer> enough!
11:50:36 <fasta> palomer: "caught mono"? WTH is that?
11:50:49 <dmhouse> Mono is the ASP-on-Apache thing?
11:51:17 <fasta> Mono can be everything, including one ;)
11:52:04 <fasta> I think Google Earth on Linux is hackish. 
11:52:22 <fasta> It said I only had software 3d... which I don't. 
11:53:15 <mathewm> OK... now that I have show working like I want it, it is time to instantiate Read
11:53:19 <fasta> I am however compiling GHC... thus it might just test whether it can do X things and if not say "hey, you don't have capability Y". In short, hackish.
11:53:38 <mathewm> I am looking for examples of how to instantiate Read ... :(
11:54:12 <dmhouse> mathewm: Head into GHCi, then hit :i Read
11:54:21 <dmhouse> That'll tell you which functions you need to define.
11:54:37 <dmhouse> (It doesn't give you the minimal-complete definition, though, which is a shame.)
11:55:36 <int-e> try the preluds ... http://haskell.org/onlinereport/standard-prelude.html#$tReadS
11:55:37 <lambdabot> Title: "The Haskell 98 Report: Standard Prelude"
11:57:25 <int-e> but it's a bit ugly; ReadS would possibly be nicer as a MonadPlus m => String -> m (a, String) (of which String -> [(a, String)] is a particular instance)
11:58:37 <mathewm> so I want a ReadS to be \s -> [ ( 1, "2 3" ), ( 2, "3" ), ( 3, "" ) ]  ?
12:01:12 <mathewm> how to I fail to parse within a ReadS ?
12:02:43 <int-e> return an empty list
12:02:50 <int-e> it's a list of possible parses
12:03:09 <int-e> a parse is a pair of (result, remainder)
12:04:41 <mathewm> ?hoogle char
12:04:41 <lambdabot> Text.ParserCombinators.ReadP.char :: Char -> ReadP Char
12:04:42 <lambdabot> Text.PrettyPrint.HughesPJ.char :: Char -> Doc
12:04:42 <lambdabot> Text.ParserCombinators.Parsec.Char.char :: Char -> CharParser st Char
12:05:54 <mathewm> ?hoogle ReadP -> ReadS
12:05:54 <lambdabot> No matches, try a more general search
12:06:01 <mathewm> ?hoogle ReadS -> ReadP
12:06:01 <lambdabot> No matches, try a more general search
12:09:21 <fasta> Gtk-CRITICAL **: gtk_list_store_clear: assertion `GTK_IS_LIST_STORE (list_store)' failed
12:09:36 <fasta> This is so typical for C programs...
12:20:11 <Korollary> france have looked good so far
12:26:36 <roods> how do i run haskell when i m-x shell in emacs? 
12:27:02 <Korollary> run ghci?
12:27:14 <roods> ya it must not be in my path
12:27:29 <dmhouse> roods: Or C-c C-l on the file.
12:31:01 <roods> dmhouse: do you use emacs for windows?
12:31:06 <dmhouse> roods, no.
12:31:10 <roods> dang.
12:31:24 <dmhouse> Why?
12:31:35 <roods> i'm not sure where my .emacs file should live.
12:31:58 <roods> i never created one when i was using emacs on windows.
12:32:10 <Korollary> iirc, it's either c:/ or ...documents and settings/UserName/
12:33:41 <Korollary> I dont think ghci ever worked for me from within emacs on win32. ghc on windows is a mingw executable, so I think I was not too happy with the cygwin emacs either
12:34:07 <roods> i don't use cygwin.
12:34:22 <madpickle> i use xemacs
12:34:24 <madpickle> works fine, really
12:34:26 <madpickle> pretty good port
12:42:27 <roods> dmhouse: all set with the .emacs file.
12:42:34 <roods> but C-c C-l isn't working.
12:42:45 <roods> does the file need a certain extension
12:42:51 <dmhouse> roods, you in haskell-mode, I assume? What error do you get?
12:43:12 <roods> how will i know if i'm in haskell mode?
12:43:17 <dmhouse> ERr
12:43:19 <dmhouse> The modeline? :)
12:43:26 <roods> doh!
12:43:27 <roods> C++ mode
12:43:32 <madpickle> lol
12:43:42 <roods> what ext does haskell files usually have?
12:43:46 <madpickle> .hs
12:44:11 <roods> something about not having hugs.
12:44:12 <madpickle> try Alt+X and type "haskell-mode"
12:44:24 <roods> do i need to install hugs too?
12:44:30 <roods> i thot it was supose to work with ochi
12:44:39 <madpickle> i don't use hugs with mine
12:44:40 <madpickle> so no
12:45:05 <dmhouse> madpickle: Alt+X? How very unemacsy.
12:45:11 <madpickle> shrug =)
12:45:24 <madpickle> you know you love it
12:45:27 <madpickle> admit it
12:45:57 <pesco> There is no Alt.
12:46:18 <norpan> esc x
12:46:21 <Cale> Is there anyone here with an actual Meta key?
12:46:26 <pesco> (Except on Macs.)
12:46:33 <madpickle> no, Cale, I'm still looking for the "Any key"
12:46:36 <dmhouse> Cale, sure. It's labelled 'Alt'.
12:46:47 <Cale> dmhouse: not just a key mapped to meta :)
12:46:55 <dmhouse> Hehe.
12:47:03 <pesco> Cale: I have a Happy Hacking Keyboard.
12:47:05 <madpickle> i think it's called meta for that reason
12:47:08 <SamB> I could take off my Alt key and paint "Meta" on it if you like
12:47:11 <madpickle> pesco: the one with no glyphs?
12:47:13 <Cale> SamB: hehe
12:47:18 <pesco> madpickle: Er, no.
12:47:25 <madpickle> you call yourself a hacker?
12:47:26 <madpickle> O.o
12:47:30 <madpickle> i'd buy it
12:47:31 <madpickle> but it's pricey
12:47:42 <madpickle> has to be the one with no glyphs on it
12:47:43 <SamB> though it would probably have to be in bigger letters than the "Alt"...
12:47:45 <madpickle> otherwise it's just not cool
12:48:10 <pesco> madpickle: That's okay, I don't call myself a hacker either.
12:48:15 <madpickle> hehe
12:49:10 <Cale> http://world.std.com/~jdostale/kbd/SpaceCadet1.jpeg
12:49:36 <dmhouse> I want one!
12:49:49 <madpickle> uh-huh.
12:49:56 <madpickle> i love the "Rub out" button
12:49:58 <madpickle> rub *what* out?
12:50:02 <dmhouse> It's even got the Alt Gr labels.
12:50:17 <madpickle> top-right button says "Call"
12:50:19 <SamB> what does the Gr even mean?
12:50:22 <madpickle> i can only assume it's a room service button
12:50:24 <madpickle> Graphic
12:50:26 <dmhouse> Green.
12:50:32 <madpickle> it's for euro-centric keyboards mostly
12:50:40 <madpickle> because of accented characters and all that miscellenea
12:50:56 <Cale> actually, those labels are greek characters
12:51:04 <madpickle> it still means Graphic =)
12:51:09 <Cale> http://world.std.com/~jdostale/kbd/SpaceCadet3.jpeg
12:51:20 <dmhouse> Cale, not all of them.
12:51:35 <madpickle> looks like a apl keyboard for greek people
12:51:36 <madpickle> O.o
12:51:46 <pesco> My favourite is the "thumbs-up" button.
12:51:49 <dmhouse> Oh, on the front.
12:51:50 <Cale> dmhouse: most of the ones on the front of the keys
12:52:09 <Igloo> Ah, the golden age of computing, when keyboards had lambda keys on...
12:52:23 <dmhouse> It doesn't have an Über key though.
12:52:30 <madpickle> yes, the white keys are accessed through the Alt Gr. buttno
12:52:31 <madpickle> typically
12:52:38 <madpickle> white letters*
12:52:41 <dmhouse> Hyper, Super, Meta, Über. Perfect fit.
12:53:04 <madpickle> "Ensign, go to Hyper speed"
12:53:07 <madpickle> "Aye, sir"
12:53:25 <roods> dang.
12:53:28 <dmhouse> Hrm.
12:53:29 <Cale> αβγδε
12:53:37 <roods> i just installed hugs and it still doesn't work.
12:53:42 <dmhouse> Do you think their font just didn't support Greek-6?
12:53:52 <madpickle> i think it's not a font thing
12:53:52 <Cale> hehe, it's pretty easy to set up a greek key in Gnome :)
12:53:55 <madpickle> just a convenience thing
12:54:05 <madpickle> most greeks i know use a bastardized form of english to speak greek
12:54:11 <madpickle> as it's too cumbersome to type greek on standard keyboards
12:54:13 <Curumo> why
12:54:21 <madpickle> i think the idea behind that keyboard was to simplify that
12:54:22 <Cale> Currently, I have my left windows key bound to Greek
12:54:32 <Curumo> why
12:54:40 <madpickle> kick that guy
12:54:42 --- mode: ChanServ set +o dmhouse
12:54:43 <madpickle> he got banned a while back
12:54:44 --- mode: ChanServ set +o Igloo
12:54:46 <madpickle> got saying why
12:54:48 <madpickle> lol
12:54:48 <Cale> hm?
12:54:57 <dmhouse> Curumo, got anything interesting to say?
12:55:01 <dmhouse> Igloo, I got there first :)
12:55:08 <Curumo> yes
12:55:11 <Cale> The Greek characters are there for mathematical use :)
12:55:17 --- mode: Igloo set +b *!*@84-73-115-240.dclient.hispeed.ch
12:55:20 --- kick: Curumo was kicked by Igloo (Igloo)
12:56:11 --- mode: dmhouse set -o dmhouse
12:56:29 <norpan> hmmmm
12:56:29 <dmhouse> I want to bind that pointless Right-Click button to another meta key.
12:56:38 <dmhouse> So things like M-; aren't a stupid stretch.
12:56:54 <norpan> that's why i use vim instead :)
12:56:55 <dmhouse> In fact, let's do that now.
12:56:59 --- mode: Igloo set +b *!i=JavaUser@*.dclient.hispeed.ch
13:00:46 <roods> damn, anyone else have trouble with this emacs module.
13:14:07 <fanopanik> what emacs module?
13:20:24 <roods> nm i got it to work. i just hadn't set the env variable in windows
13:20:32 <roods> the haskell one  i guess.
13:21:22 <roods> doh! where was that guy who was talking abou this.
13:21:33 <roods> how do you run what is in your buffer C-c C-l doesn't do anything.
13:22:03 <fanopanik> err
13:22:09 <fanopanik> you need inf-haskell
13:22:12 <fanopanik> at least that's what I use
13:22:23 <roods> inf-haskell?
13:22:25 <roods> what is that
13:22:39 <fanopanik> and then C-c C-l creates a new buffer with hugs/ghci. you need to switch to it though.
13:22:50 <fanopanik> inferior-haskell... a minor mode for interaction with hugs/ghci
13:23:32 <roods> i'm using haskell mode for emacs now.
13:23:42 <fanopanik> yes
13:23:47 <astrolabe> (i1::Int,g1) = random g      <- Why does ghc want me to use -fglasgow-exts for this?
13:23:50 <fanopanik> that's the major mode
13:23:53 <fasta> What does defaultMain do in Cabal? 
13:24:07 <int-e> because type signatures in patterns aren't Haskell 98.
13:24:11 <fasta> It would seem sensible to just execute a MakeFile when one exists.
13:24:16 <astrolabe> thanks
13:24:32 <roods> hey Cale you around still?
13:25:11 <fasta> I need someone who has in-depth knowledge of Cabal.
13:26:07 <roods> fanopanik: how do you run what's in your buffer?
13:26:58 <fanopanik> C-c C-l
13:27:44 <roods> if i type 3+3 it doesn't do anything when i do C-c C-l
13:28:01 <roods> but when i run hugs interactively it does.
13:28:04 <roods> why is that.
13:28:20 <roods> my mode is Haskell Ind Doc
13:29:13 <fanopanik> do you have a buffer named *haskell* open
13:29:20 <fanopanik> check with C-x C-b
13:30:52 <roods> oh okay cool
13:31:11 <roods> Syntax error in declaration (unexpected `}', possibly due to bad layout)
13:31:14 <fanopanik> yeah
13:31:17 <roods> why do i get that when i jus ttype 3+3
13:31:26 <roods> do i need to wrap that in some scope.
13:31:35 <fanopanik> no idea.
13:31:59 <roods> can you show me a simple program that works for you?
13:32:02 <fanopanik> I suggest you make two windows, one for the source and one for the interpreter. that's quite comfortable.
13:33:08 <roods> cool thanks for the help.
13:34:27 * joelr1 is timing a ghc 6.6 rebuild on a powerbook 1.25ghz
13:34:59 <mathewm> I have a Read6.6?
13:35:05 <mathewm> 6.6 is out?
13:35:11 <Korollary> no
13:35:25 <mathewm> might be a long build time then ;)
13:35:32 <joelr1> mathewm: from darcs
13:35:49 <mathewm> I thought that was still 6.5
13:35:52 <joelr1> 6.5 i guess. that will become 6.6 upon release.
13:35:58 <joelr1> although i could be mistaken
13:37:03 <joelr1> my mbp 17" just arrived in paris
13:37:25 <joelr1> i wonder how much faster the rebuild will be
13:44:27 <joelr1> how in the world do i build a package linking it against a static library?
13:45:31 <dmhouse> Note to self: don't ever install something from CPAN.
13:45:39 <joelr1> dmhouse: how come?
13:45:44 <dmhouse> I think I've just accepted to install about the fiftieth dependency.
13:46:04 <joelr1> :D
13:46:15 <Korollary> isnt there a yes-to-all option?
13:46:22 <dmhouse> A bit late for that now.
13:47:13 <Korollary> it's fun watching the brazilians diving for free kicks
13:47:35 <mathewm> ?hoogle Int -> [a] -> [[a]]
13:47:36 <lambdabot> No matches, try a more general search
13:48:11 <fasta> What should this do? $(shell cat obj/compilers)
13:48:33 <dmhouse> fasta: Looks like TH to me.
13:48:44 <fasta> I can't remember shell being a built-in in Make
13:48:45 <int-e> > let f n = takeWhile (not . null) . unfoldr (Just . splitAt n) in f 4 "abcdefghij"
13:48:46 <lambdabot>  ["abcd","efgh","ij"]
13:48:48 <fasta> dmhouse: You are funny. 
13:49:04 <mathewm> shell is a Make built-in
13:49:07 <dmhouse> fasta: Ah, you knew that. It's fairly funky syntax, I thought I'd make sure.
13:49:14 <mathewm> GNU make at any rate..
13:49:40 <fasta> mathewm: Thanks, I will verify it, because I want to get HaXml to work.
13:49:42 <mathewm> ?google GNU Make Manual
13:49:43 <dmhouse> int-e, a nice round of guess-the-algorithm-from-the-type. :)
13:49:44 <lambdabot> http://www.gnu.org/software/make/manual/make.html
13:49:45 <lambdabot> Title: "GNU `make'"
13:50:41 <roods> hi dmhouse 
13:50:55 <roods> what does the " ' " mean here insertionSort lst = insertionSort' lst [] where
13:51:07 <int-e> dmhouse: well, replicate is another candidate
13:51:08 <dmhouse> It's part of the name.
13:51:11 <fasta> roods: no semantics
13:51:17 <fasta> roods: just syntax
13:51:29 <dmhouse> roods: foo' is a valid function name in Haskell.
13:51:34 <dmhouse> All right, g'night all.
13:51:36 <roods> oh okay.
13:51:40 <int-e> dmhouse: I'm not sure what else could be done with the Int argument
13:53:09 <fasta> Is there any XML library that does work?
13:55:41 <joelr1> is there a static linker in ghc?
13:56:31 <joelr1> i'm going bonkers
13:58:56 <roods> how do you swap elements of [1,2]
13:59:06 <int-e> reverse
13:59:46 <roods> thanks.
14:00:07 <int-e> f [a, b] = [b, a]  will also work
14:00:23 <fasta> Did anyone install any XML tool under Haskell?
14:00:27 <int-e> @pl f [a, b] = [b, a]
14:00:28 <lambdabot> (line 1, column 10):
14:00:28 <lambdabot> unexpected "="
14:00:28 <lambdabot> expecting variable, "(", operator or end of input
14:00:42 <int-e> @pl f (a:b:[]) = (b:a:[])
14:00:42 <lambdabot> (line 1, column 12):
14:00:43 <lambdabot> unexpected "="
14:00:43 <lambdabot> expecting variable, "(", operator or end of input
14:00:51 <int-e> @pl \(a:b:[]) -> (b:a:[])
14:00:51 <lambdabot> (line 1, column 7):
14:00:52 <lambdabot> unexpected "["
14:00:52 <lambdabot> expecting natural, identifier, "_" or "("
14:00:54 <int-e> aww
14:01:09 <Korollary> p@pl 
14:01:22 <Korollary> @pl \[a,b] -> [b,a]
14:01:22 <lambdabot> (line 1, column 2):
14:01:22 <lambdabot> unexpected "["
14:01:22 <lambdabot> expecting pattern
14:01:32 <roods> i see how you can write foo [] = [] for the null set but how to you say a set with only one element
14:01:35 <int-e> @pl f a b = a + b
14:01:36 <lambdabot> f = (+)
14:01:38 <Korollary> arr
14:01:56 <int-e> it's really disliking the list pattern I think.
14:02:02 <Korollary> Yes
14:02:26 <Korollary> roods: foo [a], or foo [_]
14:02:46 <int-e> or, foo (a:[])  ... that's equivalent to foo [a]
14:03:19 <mathewm> are there multi-line quotes in lhs?
14:03:34 <SimonRC> yes
14:03:39 <SimonRC> {-     -}
14:03:57 <mathewm> that would be a comment, right?  I want a multi-line string
14:04:12 <SimonRC> ah
14:04:39 <SimonRC> I think not, other than just doing a lot of "..."++"..."++"..."
14:04:49 <SimonRC> that would only be computed once
14:05:02 <SimonRC> or use unlines on a list of strings
14:05:15 <Korollary> see section 9.3
14:05:29 <Korollary> apparently \ works
14:05:40 <Korollary> or 2.6
14:07:38 <int-e> is there a way to tell cabal to clean the compiled stuff but not its configuration?
14:08:34 <roods> what does !! mean?
14:08:54 <int-e> > [0,23,31] !! 1
14:08:55 <lambdabot>  23
14:09:10 <int-e> n-th element from a list, counting from zero.
14:09:40 <roods> cool!
14:09:41 <int-e> (warning, it's inefficient; ... !! n takes O(n) time.)
14:10:09 <roods> i'm just testing out implementing some sort routines.
14:10:23 <roods> is there a way to generate a random array of size n
14:12:10 <sylvan> roods, sure, try listArray together with a random list, for example
14:12:31 <int-e> @docs System.Random
14:12:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
14:13:06 <sylvan> @type System.Random.randoms
14:13:08 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
14:13:20 <sylvan> @type mkStdGen
14:13:21 <lambdabot> Int -> StdGen
14:13:37 <sylvan> @info StdGen
14:13:37 <lambdabot> Unknown command, try @list
14:13:40 <sylvan> hmm
14:13:42 <sylvan> @list
14:13:43 <lambdabot> list [module|command]. Where modules is one of:
14:13:43 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
14:13:43 <lambdabot> topic type unlambda url version vixen where
14:14:04 <sylvan> @instances RandomGegn
14:14:04 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:14:10 <sylvan> @instances RandomGen
14:14:10 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:14:24 <sylvan> @instances System.Random.RandomGen
14:14:34 <int-e> @instances-importing System.Random RandomGen
14:14:35 <lambdabot> StdGen
14:14:48 <roods> urg. can't get a simple example to work.
14:14:49 <int-e> hmm
14:15:06 <sylvan> > take 4 (randoms (mkStdGen 3))
14:15:07 <lambdabot>  Add a type signature
14:15:10 <int-e> @instances-importing System.Random Random
14:15:10 <lambdabot> Bool, Char, Double, Float, Int, Integer
14:15:20 <sylvan> take 4 (randoms (mkStdGen 3)) :: [Int]
14:15:27 <sylvan> > take 4 (randoms (mkStdGen 3)) :: [Int]
14:15:28 <lambdabot>  [-1704185953,2104023132,-163578927,1526256091]
14:15:29 <sylvan> there
14:15:54 <sylvan> @type Data.Array.listArray
14:15:56 <lambdabot> forall e i. (Ix i) => (i, i) -> [e] -> Array i e
14:16:05 <roods> sylvan: you lost me.
14:16:44 <int-e> roods: what do you mean by 'array'? a list, probably?
14:16:50 <roods> yes.
14:16:59 <roods> sorry just started playing with the lang today.
14:17:08 <Korollary> int-e: not that I know of. It pisses me off, too.
14:17:19 <fasta> int-e: could you try installing HaXml? darcs get http://www.cs.york.ac.uk/fp/darcs/HaXml
14:17:21 <lambdabot> Title: "Index of /fp/darcs/HaXml"
14:18:01 <int-e> (Haskell has arrays, too; they provide efficient random read access, and, in the ST monad, random access)
14:18:17 <joelr1> why would I get something like this? "    Not in scope: type constructor or class `HOC.Arguments:ObjCArgument'"
14:18:30 <int-e> fasta: I can try
14:18:41 <sylvan> roods: You probably just want a list, so the example I gave you above should work
14:18:52 <roods> sylvan: i didn't understand your example.
14:18:54 <joelr1> HOC.Arguments is listed by ghc as being skipped and ObjCArgument is a typeclass in HOC.Arguments that exports everything
14:18:56 <sylvan> Arrays are effiient to read, but clumpsy to work with
14:19:13 <sylvan> roods, okay, 'randoms' produces an infinite list of random elements, if you give it a "random generator"
14:19:21 <sylvan> mkStdGen produces a random generator from an int
14:19:24 <sylvan> >mkStdGen 4
14:19:24 <int-e> fasta: why? are you interested in ghc 6.5 problems?
14:19:47 <sylvan> take x, retrieves the x first elemetns of a list
14:19:49 <fasta> int-e: no, I think the package just doesn't work. 
14:19:50 <roods> mkStdGen 4 says Undefined variable.
14:19:59 <sylvan> You need to import System.Random
14:20:16 <sylvan> or in ghci type ":m +System.Random" to bring it into scope
14:20:17 <roods> how do i do that
14:20:19 <fasta> int-e: I tried building it via the cabal way runhaskell Setup.hs configure etc.
14:20:25 <fasta> int-e: that didn't work
14:20:39 <roods> damn can't find that module.
14:20:43 <fasta> int-e: (it didn't run cpphs)
14:20:47 <sylvan> normally you have a haskell file (.hs) where you type, say, "import System.Random"
14:20:57 <sylvan> are you using GHC?
14:21:03 <roods> hugs.
14:21:12 <sylvan> ah.. hmm.. Try "Random"
14:21:15 <sylvan> without the system part
14:21:18 <fasta> int-e: and when I just used ./configure; make; make install it also failed, but somewhat later.
14:21:28 <roods> something about undefined data constructor
14:21:41 <roods> i wanted to do it interactively.
14:21:47 <int-e> src/Text/XML/HaXml.hs:35:16: Not in scope: data constructor `VERSION' ... fun.
14:21:52 <fasta> int-e: and from the looks of it it has nothing to do with ghc, and everything with HaXml being buggy. 
14:22:04 <fasta> int-e: indeed, that's because cpphs doesn't get run.
14:22:30 <fasta> int-e: any idea how to fix it? 
14:22:36 <sylvan> roods, yeah you need to load the Random module somehow... I'll try to find hugs here and see if I can figure out how...
14:22:59 <int-e> fasta: wait, trying ghc 6.5 and its newer cabal now.
14:23:21 <fasta> int-e: well, I already have the latest... Thus that doesn't work.
14:23:24 <int-e> ok. same effect. great :)
14:23:41 <sylvan> roods, try starting with "-98" on the command line
14:23:43 <roods> sylvan: i think i'm going to read a doc or two about haskell
14:24:12 <sylvan> well this particular problem is just interpreter/compiler related...
14:24:25 <roods> or something that could generate all permutation of some range of number for a list.
14:25:38 <sylvan> you could try typing ":l System.Random" in hugs, which should load the random module
14:25:58 <roods> :-)
14:26:00 <roods> that worked.
14:26:03 <int-e> the -DVERSION=$(VERSION) is missing ... mm
14:26:09 <joelr1> any clues why Not in scope: type constructor or class would show up with Template Haskell?
14:26:23 <sylvan> good.. the trouble with that is that you're only working with one module at a time, ideally you'd want to bring several modules into scope (not sure how to do that in hugs)
14:26:55 <roods> sylvan: how do i create that random list?
14:27:09 <sylvan> roods, right so now try "mkStdGen 4" which will generate a random generator with the seed 4.
14:27:17 <sylvan> (it'll show you some weird internal reperesentation)
14:27:24 <roods> that worked.
14:27:40 <sylvan> so now try "random (mkStdGen 4)"
14:27:45 <int-e> fasta: as a hack, adding   ghc-options:    -DVERSION=1.15   to the cabal file worked. I don't know enough about cabal to do that better.
14:27:57 <sylvan> "random (mkStdGen 4) :: Int "
14:28:04 <int-e> fasta: worked = the package compiled fully
14:28:06 <roods> ERROR - Unresolved overloading
14:28:15 <fasta> int-e: I will try it.
14:28:16 <sylvan> random (mkStdGen 4) :: (Int, StdGen)
14:28:18 <sylvan> sorry
14:28:28 <sylvan> it will return an int and a new random generator
14:28:42 <roods> okay that returned something
14:28:45 <sylvan> (you need to use the new random generator each time unless you want to get the same random number each time)
14:28:50 <roods> (-106546976,1563150291 1655838864)
14:28:53 <sylvan> right
14:28:53 <roods> not sure what that means.
14:29:11 <sylvan> , the first value (-1065....) is the random number, the second (two pairs of numbers) is the new random generator
14:29:27 <roods> jeez. this is pretty complicated.
14:29:57 <sylvan> hmm.. I think it's easier if you open a haskell file (extension .hs) and load that into hugs, then you can name things with variables and stuff which makes it easier
14:30:06 <fasta> int-e: it worked!
14:30:26 <kmag> Are any of you using ghc/ghci on Linux AMD64?
14:30:39 <roods> sylvan: that still has the problem of loading the module.
14:30:40 <kmag> (yes... I've looked at Trac)
14:30:55 <norpan> kmag: yes
14:31:18 <sylvan> roods, you can't load your own modules? Should be just ":l mymodule.hs" if mymodule.hs is in the current working dir
14:31:26 <sylvan> or use "open" if you're using winhugs
14:31:30 <fasta> int-e: where does Cabal puts the documentation for the haddock target?
14:31:34 <kmag> norpain: I'm guessing you use ghc 6.5 ?
14:32:11 <roods> sylvan: maybe i'll ask you laster, i should read some manual first
14:32:13 <kmag> norpain: do you have any info on the particulars about the ELF dynamic linker not being able to link against static data in shared libs?
14:32:23 <norpan> 6.4.1 actually
14:32:36 <sylvan> anyway, if you write " take 4 (randoms (mkStdGen 4)) :: [Int]" you'll get four random numbers. randoms is almost like random except it generates a list of random numbers. Use "take 4" to only take the first four (the list is infinite, you see) :-)
14:32:40 <norpan> just using it to compile plain haskell
14:33:23 <int-e> fasta: You better ask someone else. I just wrote my first .cabal file today ;)
14:33:54 <fasta> int-e: hmm, ok, I could also just run updatedb on my entire harddisk ....
14:33:59 <norpan> kmag: no, i have no such info
14:34:23 <fasta> int-e: I already found it.
14:34:30 <roods> sylvan: thanks for the help
14:34:43 <joelr1> kmag: funny that you would ask
14:34:55 <joelr1> kmag: i just had this problem but it appeared to be a non-problem
14:35:37 <kmag> for me, GHCi 6.4.4 freaks out at startup
14:36:01 <kmag> loadObj fails
14:36:25 <sylvan> roods:  no problem
14:37:01 <kmag>  /usr/lib/ghc-6.4/HSbase.o: unknown architecture
14:37:05 <joelr1> kmag: wierd. loadObj can only load dynamic libraries, though
14:37:14 <joelr1> kmag: are you on mac intel ?
14:37:23 <kmag> AMD64
14:37:41 <joelr1> kmag: ok
14:37:49 <joelr1> kmag: can't help you then
14:37:51 <kmag> joelr1: Ubuntu AMD64
14:38:32 <joelr1> kmag: i think loadObj only loads dynamic libs. i'm positive in fact. i just looked through the code in Linker.hs and friends in ghc/compiler/ghci a few minutes ago
14:40:31 <kmag> joelr1: I think it's related to this: http://cvs.haskell.org/trac/ghc/ticket/781
14:40:33 <lambdabot> Title: "#781 (GHCi on x86_64, cannot link to static data in shared libs) - GHC - Trac"
14:40:50 <joelr1> ok
14:41:03 <kmag> but maybe not
14:41:14 <kmag> so none of you have seen problems like this?
14:44:45 <roods> why in ghci can i type let a = [2] but i can't do that in hugs
14:45:05 <norpan> because they work differently?
14:45:28 <norpan> there is no specification in the language report how an interpreter should behave
14:45:31 <roods> how do you do the same thing in hugs 
14:45:43 <norpan> don't know
14:45:52 <norpan> i only use ghci
14:45:57 <norpan> very seldom hugs
14:47:02 <kmag> roods: if you look at the factorial example on haskell.org, it notes that hugs doesn't allow you to define functions on the command line
14:47:17 <kmag> roods: you need to put the function definitions in source files
14:48:01 <kmag> can hugs be used to run ghc ?
14:48:19 <fasta> int-e: Hmm, haddock seems to run, but it produces.... _nothing_....
14:49:02 <int-e> fasta: fwiw, configure + make almost work; all that's required is to change RENAME in obj/ghc/Makefile, because ghc no longer creates an a.out file. (that means it probably works with ghc 6.4.2, because that version didn't do that)
14:49:37 <fasta> int-e: I also tried with 6.4.2, and it didn't work. 
14:49:53 <fasta> int-e: but it might be another fix for another bug.
14:50:21 <fasta> int-e: while you are at it, maybe you could send your hacks via darcs?
14:51:39 <fasta> int-e: make haddock also doesn't work.
14:54:15 <fasta> int-e: It needs HsColour, which it doesn't mention as one of its dependencies....
14:55:55 <int-e> fasta: sorry. I'm not interested right now and that line in the cabal file is too much of a hack for my taste to send as a patch.
14:56:18 <fasta> int-e: yes, I can understand. Can you recommend another XML library? 
14:57:05 <int-e> no
14:57:46 <fasta> int-e: thanks for your efforts, though.
15:10:41 <roods> i can't seem to figure out what "#" means
15:11:17 <bolrod> numbers ?
15:11:24 <norpan> where
15:11:26 <bolrod> # of players... number of players ?
15:11:29 <roods> splitAt(length(xs) # 2, xs)
15:11:31 <roods> as in that.
15:11:32 <bolrod> 8)
15:11:35 <bolrod> unboxed ?
15:11:53 <roods> hugs is saying  Undefined variable "#"
15:11:54 <Lemmih> > let f # g = g f in [1,2,3]#length 
15:11:55 <lambdabot>  3
15:12:20 <Lemmih> roods: It's just a variable name like 'foo'.
15:12:57 <norpan> an operator name
15:13:18 <norpan> that you can define the way you like
15:13:23 <roods> i can't figure out why mergesort(xs)  = (as, bs) = splitAt(length(xs) # 2, xs) in merge(mergesort(as), mergesort(bs)) doesn't work
15:13:29 <roods> merge(as,bs) = (as,bs)
15:13:46 <norpan> why should it work
15:13:57 <norpan> you think # is division for some reason?
15:14:13 <Lemmih> And what's with all the tuples?
15:14:23 <norpan> also, arugments to functions are not f (a,b) but f a b
15:14:25 <roods> not me someone else.
15:14:52 <norpan> unless you have defined your functions as taking tuples, which is unorthodox
15:14:53 <Lemmih> roods: Are you sure he wrote it as Haskell?
15:15:09 <roods> think so.
15:15:10 <roods> mergesort(xs)  = (as, bs) = splitAt(length(xs)/2  xs) in merge(mergesort(as), mergesort(bs))
15:15:12 <roods> that still doesn't work
15:15:23 <Lemmih> It doesn't look like Haskell.
15:15:24 <norpan> where did you get the code from
15:15:32 <roods> http://www.csc.depauw.edu/~bhoward/courses/0304Fall/csc122/haskintro/
15:15:33 <lambdabot> Title: "An Introduction to Haskell"
15:16:06 <norpan> read the footnote
15:16:13 <norpan> and find some other tutorial :)
15:16:34 <roods> how do you do something similar to what i posted.
15:16:40 <roods> split an array and pass the arguments to another function
15:17:08 <norpan> splitAt is fine, but it takes arguments like splitAt (length xs `div` 2) xs
15:17:24 <mathewm> how do you debug runtime problems - "Prelude.(!!): index too large" 
15:17:37 <mathewm> no line number...
15:18:02 <norpan> mathewm: no, it's hard to debug
15:18:03 <int-e> [x:xs]?!
15:18:05 <Lemmih> mathewm: There's no automatic way.
15:18:24 <norpan> int-e: yes, it seems strage
15:18:25 <norpan> strange
15:18:47 <Lemmih> int-e: I think that's valid in HasCL.
15:18:56 * mathewm starts to look more fondly upon C
15:19:01 <roods> still getting an error with mergesort(xs)  = (as, bs) = splitAt (length xs `div` 2) xs in merge(mergesort(as), mergesort(bs))
15:19:02 <norpan> why would someone modify haskell syntax and call it "almost haskell"
15:19:32 <norpan> you shouldn't look at that haskell imitating infidel
15:19:35 <int-e> Oh no, they made Haskell look like C
15:20:15 <Lemmih> roods: let (as, bs) = ...
15:20:19 <norpan> why won't they just use haskell
15:20:27 <norpan> some people...
15:20:48 <norpan> or if making a subset, make it use the same syntax
15:20:48 <roods> Lemmih: still getting a similar error
15:21:15 <Lemmih> roods: Well, did you fix 'merge'. It's completely borked too.
15:21:55 <Lemmih> roods: You could avoid all these problems by following a Haskell tutorial.
15:22:23 <roods> ?urg.
15:22:23 <lambdabot>  @where <key>, return element associated with key
15:25:37 <norpan> replace [x:xs] with (x:xs)
15:26:08 <kpreid> anyone who can help me with configuring lambdabot?
15:28:35 <int-e> edit Config.hs, rebuild, enjoy
15:29:04 <kpreid> well, it's the building part, actually
15:29:25 <kpreid> I started with the "fastest turn around" part in the README
15:29:45 <kpreid> and "sh ghci Main.hs" -> "ghc-6.4: could not execute: ./BotPP"
15:29:56 <kpreid> and I see that BotPP is built from something, but this appears to not do that
15:30:19 <kpreid> if I follow the other build instructions, I get "./Setup.hs configure --bindir=`pwd`" -> "*** Exception: Line 19: Unknown field 'hs-source-dirs'"
15:31:10 <int-e> I think that translates to: get a newer cabal
15:31:41 <int-e> and I've not tried the configure way, so I don't know what BotPP is nor why it's needed
15:41:34 <kpreid> int-e: would ghc 6.4.2 help with 'newer cabal'?
15:47:07 <sjanssen> kpreid: yes
15:47:24 * kpreid is installing that, then
15:47:35 <sjanssen> the version is newer, not sure if it's new enough for what you're installing
15:58:04 <encoded> lambdabot, hi
15:58:30 <encoded> !help
16:21:20 <mathewm> ?where paste
16:21:20 <lambdabot> http://paste.lisp.org/new/haskell
16:22:03 <lisppaste2> mathewm pasted "broken code" at http://paste.lisp.org/display/21926
16:25:38 <kpreid> mathewm: in what way is it broken?
16:26:00 <mathewm> The code I just pasted always return [] instead of a solution
16:26:53 <mathewm> I am pretty sure that puzzle has a solution, but that code stops executing pretty early on
16:27:22 <kpreid> oh. not my sort of problem, sorry
16:30:47 <lisppaste2> mathewm annotated #21926 with "program output" at http://paste.lisp.org/display/21926#1
16:35:55 <mathewm> aha!
16:35:58 <mathewm> silly bug
16:41:57 <lisppaste2> mathewm annotated #21926 with "working code - still ugly" at http://paste.lisp.org/display/21926#2
16:45:23 <mathewm> quiet... is there a worldcup match on or what?
16:45:30 <fanopanik> nope, no more.
16:45:50 <mathewm> who won?
16:45:55 <fanopanik> france
16:46:01 <fanopanik> brazil is gone.
16:46:06 <mathewm> WOW
16:51:02 <fanopanik> england is out too. portugal won the penalty shooting.
16:53:32 <Stinger_> brazil got owned
16:53:38 <mathewm> score?
16:53:48 <Korollary> 1-0
16:53:49 <mathewm> 1 0 - right ? 
16:53:49 <mathewm> ;)
16:53:54 <Stinger_> 1-0 but that doesnt tell the story :P
16:54:09 * mathewm <-- silly american smirking at low-scoring game
16:54:31 <Stinger_> its a game where goals actually mean something :)
16:54:46 <mathewm> I have never watched a full soccer game
16:54:55 <mathewm> I should give it a try before commenting...
16:57:11 <fanopanik> watch a good one
16:57:21 <fanopanik> those 0:0 matches are usually the worst, of course,
16:59:53 <Cale> Azureus is a nice bittorrent client, but it's so annoyingly unstable at the same time. The odd thing is that it never seems to crash when I'm at my computer, but 10 minutes after I walk away, it's gone.
17:00:16 <fanopanik> what OS?
17:00:22 <Cale> Debian
17:00:41 <JKnecht> thier kernel or yours?
17:00:45 <fanopanik> unfortunately there are no good FOSS bt clients
17:01:00 <fanopanik> where good means good + not java
17:02:13 <JKnecht> eclispse java is the only thing I've experienced that can hang Linux (FC4)
17:02:38 <Cale> Azureus is decent as far as features and operation are concerned, not perfect, but it's reasonably configurable at least. The latest release just seems to die when I'm not actively watching it though.
17:03:12 <fanopanik> yes, and it's also a resource hog
17:03:23 <Cale> I don't notice the resources
17:03:23 <mathewm> With GHC, are there any functions to return as a String the name of the file from which the program was compiled?
17:03:37 <Cale> I wonder if it does any nonstandard things with X/Gtk and doesn't like it when the screensaver comes on.
17:03:56 <bringert> mathewm: if you use -cpp, you have __FILE__
17:03:58 <Cale> that would explain it
17:03:59 <fanopanik> you can easily check that
17:04:20 <mathewm> can -cpp be added to the {-# #-} thingy?
17:04:42 <Lemmih> mathewm: Yes.
17:08:53 <mathewm> any pointers to docs on the "right way" to instantiate Read?  I have something that works for my use case, but I am sure it is hiddeously broken
17:09:44 <Lemmih> mathewm: Derive it?
17:10:00 <mathewm> well, I want to customize the format
17:26:49 <Korollary> mathewm: Then surely you defined what the "right" way is. Maybe you have a few bugs.
17:27:57 <kmag> hmm... so I'm going through Yet Another Haskell Tutorial
17:28:12 <kmag> Section 3.3.2 introduces Char.toUpper
17:28:30 <kmag> ghc complains that Char.toUpper isn't in scope
17:28:53 <kmag> and I read the note that in HUGS, I should just use toUpper
17:29:26 <kmag> but HUGS also complains about toUpper
17:29:38 <Korollary> @index toUpper
17:29:39 <lambdabot> Data.Char
17:30:11 <kmag> the tutorial hasn't yet introduced importing modules
17:30:21 <kmag> do I need to import Data.Char
17:30:25 <Korollary> yes
17:30:46 <kmag> the command is "import Data.Char" ?
17:30:49 <Korollary> exactly
17:31:21 <kmag> hugs says: ERROR - Syntax error in expression (unexpected keyword "import")
17:31:33 <Korollary> you need to put it at the top of the file
17:31:53 <kmag> and it won't work interactively?
17:31:55 <kmag> gotcha
17:31:55 <Korollary> or, if running interactively, enter :m Data.Char
17:32:12 <kmag> thanks Korollary :-D
17:32:44 <Korollary> np
17:32:50 <kmag> ERROR - Cannot find module "Data.Char"
17:33:01 <kmag> ERROR - Cannot find module "Char"
17:33:18 <kmag> this is HUGS
17:33:25 <kmag> I'll try ghc
17:33:31 <Korollary> :l Char works in hugs
17:33:38 <Korollary> yeah, ghci is nicer
17:33:55 <Korollary> you can use :m + in ghci to keep adding modules
17:34:05 <kmag> unfortunately, ghci 6.4.4 dies on AMD64
17:34:57 <Korollary> 6.4.2 ?
17:35:48 <Korollary> 6.4.2 seems to have x64 binaries.
17:35:59 <kmag> yes
17:36:10 <kmag> but they die in the middle of startup
17:36:17 <Korollary> os?
17:36:32 <kmag> Ubuntu Linux
17:36:37 <kmag> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
17:36:39 <kmag>         loadObj: failed
17:36:59 <kmag> Loading package base-1.0 ... ghc-6.4: /usr/lib/ghc-6.4/HSbase.o: unknown architecture
17:37:00 <Korollary> did you get the 32 bit version by accident?
17:37:24 <kmag> I apt-got it
17:37:31 <kmag> maybe the maintainer screwed up
17:38:11 <Korollary> did the package name have x86-64 in it?
17:40:24 <kmag> objdump says Base.o:     file format elf64-x86-64
17:40:26 <kmag> rw-r--r-- 0/0 1018984 Sep 13 01:53 2005 Base.o
17:41:16 <kmag> this is in HSBase.a
17:41:19 <Korollary> hmm
17:41:56 <kmag> ghc works fine
17:42:07 <kmag> it's just ghci that's problematic
17:43:04 <Korollary> I see. You might want to notify the maintainer or haskell-cafe mailing list about that.
18:04:34 <mathewm> I suppose if I want to integrate a C++ library into my haskell app I need to make an extern "C" wrapper first?
18:06:42 <joelr1> any idea how to make a TypeRep for [] in 
18:06:43 <joelr1> [d| typeOf _ = mkAppTy $(varE tyConVar) [] |]
18:06:45 <joelr1> ?
18:06:56 <joelr1> or is this like completely wrong?
18:12:55 <kpreid> joelr1: I don't know TH, but I know a bit about Data.Typable, and I think you'll have to include the type of the contents of the list
18:13:26 <kpreid> (typeOf undefined :: [Int]) would be one way to get such a type
18:14:10 <joelr1> kpreid: thanks! thinking of how to construct a typerep for that
18:14:22 <joelr1> ah!
18:14:23 <kpreid> there may well be a better way
18:15:21 <kpreid> I'm curious what you're trying to do
18:15:39 <joelr1> kpreid: HOC
18:15:50 <joelr1> kpreid: fix up the haskell objective-c binding
18:17:25 <joelr1> kpreid: which is a pain in the rear because it's all about TH and something in TH has changed
18:17:37 <joelr1> basically, it's mkName "name" everywhere it used to be "name"
18:19:26 <kpreid> ah
18:20:54 <joelr1> kpreid: more like argh :D
19:13:40 <joelr1> is andre pang around?
19:15:27 <joelr1> Cale: ping
19:16:15 <roods> i can't seem to get data Color = Red | Greeen to work.
19:16:51 <roods> i keep getting an undefined data constructor
19:17:50 <RyanT5000> Greeen
19:17:56 <roods> hehe
19:18:00 <RyanT5000> :)
19:18:03 <roods> RyanT5000: what am i doing wrong?
19:18:37 <RyanT5000> ah, that wasn't copy-and-paste? cause if it is, the 3 e's are probably the problem
19:18:44 <RyanT5000> if not, that seems right
19:18:56 <RyanT5000> is it defined in the same module as you're trying to use it in?
19:18:58 <roods> hehe
19:19:42 <roods> data Color = Red | Green
19:19:48 <roods> then i tried to do [Green]
19:20:14 <RyanT5000> paste the first part of the actual error
19:20:34 <roods> ERROR - Cannot find "show" function for:
19:20:42 <roods> *** Expression : [Green]
19:20:45 <RyanT5000> ah
19:20:49 <RyanT5000> that's not a missing constructor
19:20:55 <RyanT5000> what interpreter is that? hugs?
19:20:59 <roods> ya.
19:21:08 <RyanT5000> do you know about classes?
19:21:14 <roods> nope
19:21:33 * palomer has class
19:21:33 <RyanT5000> ok, well, all you need to do to fix that is put "deriving (Show)" after the data declaration
19:21:43 <RyanT5000> make sure to tab it in if you put it on the next line
19:22:04 <RyanT5000> Show is a class, and the function show needs your datatype to be in the class Show
19:22:25 <palomer> show some class and you might stand a chance with RyanT5000's sister
19:22:40 <RyanT5000> yes, my nonexistant sister
19:22:58 <roods> very cool.
19:22:59 <roods> thanks.
19:23:03 <RyanT5000> np
19:23:21 <RyanT5000> btw, you should read about classes asap, just to get a general idea
19:23:42 <palomer> don't listen to him, learn prolog instead
19:23:54 <RyanT5000> lol@prolog
19:24:11 <palomer> I understand the reason d'etre of clubs
19:24:17 <palomer> they're female ego boosters!
19:25:09 <palomer> who's with me?
19:25:18 <roods> what does data Point a            = Pt a a mean?
19:25:30 <RyanT5000> a is a type variable
19:25:43 <RyanT5000> so a (Point Int) is a point consisting of two Ints
19:25:51 <RyanT5000> you should read a tutorial though
19:25:54 <RyanT5000> it'll conver stuff lik ethis
19:26:00 <RyanT5000> @where yahs
19:26:00 <lambdabot> I know nothing about yahs.
19:26:03 <RyanT5000> @where yaht
19:26:03 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
19:26:08 <RyanT5000> there you go
19:26:11 <RyanT5000> that's how i learned
19:26:16 <RyanT5000> it's great if you know C
19:26:25 <palomer> "Point a = Pt a a" means "I'm declaring a new type Point with data constructor Pt. Pt is a function which sends two elements of type a to an element of type Point a"
19:26:51 <RyanT5000> @where 24QandA
19:26:51 <lambdabot> I know nothing about 24qanda.
19:27:17 <RyanT5000> @where twodzn
19:27:17 <lambdabot> I know nothing about twodzn.
19:27:44 <palomer> @type (,)
19:27:45 <lambdabot> forall b a. a -> b -> (a, b)
19:27:58 <RyanT5000> @where TwoDozen
19:27:58 <lambdabot> I know nothing about twodozen.
19:28:08 <RyanT5000> @where TwoDozen http://www.cs.lth.se/EDA120/TwoDozenLessons/
19:28:09 <lambdabot> I know nothing about twodozen.
19:28:14 <RyanT5000> how do you add an @where?
19:29:28 <RyanT5000> how do you add an @where?
19:30:22 <palomer> check this out, guys
19:30:33 <palomer> yesterday I was walking to the local statue of the virgin marie
19:30:40 <RyanT5000> @where+ TwoDozen http://www.cs.lth.se/EDA120/TwoDozenLessons/
19:30:41 <lambdabot> Done.
19:30:50 <palomer> when I look up, and there's a window open on the fifth floor of the university
19:30:55 <palomer> and there's music blasting
19:31:03 <palomer> so I'm like "there's a party going on, better find a way to get inside"
19:31:14 <palomer> background: I have mono, this is 1am on a friday night
19:31:23 <palomer> today I find a way in
19:31:32 <palomer> and it's the university radio show
19:32:24 <palomer> @palomer
19:32:25 <lambdabot> I think you're all nuts
19:34:03 <bringert> palomer: then what happend?
19:34:58 <palomer> I introduced myself
19:35:08 <palomer> they're like "we really weren't expecting anyone"
19:35:14 <palomer> that's aboot it, eh?
19:35:28 <palomer> the deal is, I thought it was some secret party
19:35:44 <palomer> I even thought of asking my neighbour to ask her boyfriend to pick the locks for me
19:42:39 <Dino_> palomer: Go there again but make sure to bring some sort of gift.
20:23:53 <alec> I've looked around and haven't been able to find an id3 library; does anyone know of one?
20:29:02 <Cale> Probably easiest to just write an FFI binding to some C library. I don't think one's been written. There's hmp3 which is a curses mp3 player, but I think it just parses the output of mpg321 and related tools.
20:38:29 <Cale> (If it does anything with the tags at all
20:38:29 <Cale> )
20:46:25 <dons> alec: i don't think we have a binding to any id3 ib yet, but it would be super easy
20:46:25 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:46:36 <dons> hmp3 does indeed just read the id3 output of mpg*
20:46:49 <alec> dons: thanks, I'll look into doing it myself, then :)
20:47:42 <SamB> oh, I should build that...
20:48:07 * SamB has been sucked into porting ZSNES's debugger to C (mostly)
20:52:28 <dons> ah. hehe
20:56:08 <SamB> well actually the main point is to get it to run on something besides DOS
21:45:35 <dons> ?quit new code
22:16:10 <eric_j> can haskell do concurrent or overlapped i/o?
22:16:50 <RyanT5000> eric_j: i think it's all threadsafe, so if you do it in different threads it will be; also, there are some asynchronous calls.  Look in the docs for System.IO
22:17:02 <eric_j> thanks, i'll check it out
22:17:11 <RyanT5000> np
22:17:14 <RyanT5000> do you know about hoogle?
22:17:20 <eric_j> no
22:17:28 <RyanT5000> @where hoogle
22:17:28 <lambdabot> http://www.haskell.org/hoogle
22:17:37 <RyanT5000> it's like google for the haskell libs
22:17:51 <RyanT5000> you can search by function name, function signature, and module name
22:18:13 <eric_j> nice
22:18:48 <palomer> it's BLACK MAGIC
22:25:16 <vegai> dons: morning
22:27:19 <dons> morning vegai
22:33:07 <dons> @tell dcoutts the problems I saw in the head fusion tests leading to weird errors don't seem to be our rules, they seem to be to due with the head/build rule in GHC/List.lhs (!)
22:33:07 <lambdabot> Consider it noted.
22:39:15 * wli is pig ignorant of Haskell raw memory facilities or otherwise he'd have FFI'd Linux' kernel aio by now.
22:39:56 <RyanT5000> wli: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html
22:39:56 <lambdabot> Title: "5 Marshalling"
22:40:18 <RyanT5000> is that what you're looking for?
22:40:36 <RyanT5000> or do you mean more explicit page management?
22:40:54 <dons> wli, yeah, pretty easy. you just want a Ptr to a chunk of stuff
22:41:16 <dons> and then peek / poke. Maybe check out how House, the Haskell OS, is wrtten
22:41:31 <RyanT5000> does House have any asm?
22:41:34 <dons> there's a bunhc of haskell drivers in it that do raw hackery
22:41:37 <RyanT5000> likein the bootloader?
22:41:48 <dons> yep, about 100 lines to load up the ghc rts
22:41:57 <dons> which in turn loads up all the haskell code
22:42:00 <RyanT5000> that sounds manageable
22:42:19 <dons> and then the haskell code loads any a.out you throw at it
22:42:37 * wli is pretty suspicious of implicit memory management.
22:42:59 <RyanT5000> wli: that doesn't happen for Ptrs
22:43:00 <dons> its quite stunning watching it run on a thinkpad, it boots in about 2 seconds
22:43:10 <RyanT5000> dons: nice
22:43:10 * wli notes that nasty corner case behavior under memory pressure is an edless source of headaches.
22:43:12 <dons> yeah, wli, you can do aloca, malloc or whatever you want.
22:43:28 <wli> dons: does it load under grub?
22:43:33 <dons> yep
22:43:51 <wli> interesting... what fs's has it got drivers for?
22:44:03 <dons> not sure.
22:44:07 <RyanT5000> Halfs?
22:44:17 <dons> i think the idea is to port halfs to house.
22:44:20 <dons> but it hasn't been done yet
22:44:28 <RyanT5000> i can't wait until there's a completely-haskell tech stack
22:45:52 <wli> doesn't look like there are any
22:46:05 <wli> (which is frankly odd0
22:47:54 <wli> dons: I'm not talking about alloca/malloc/etc. but rather privileged threads in the kernel not being able to respond to requests to release memory ... not sure how allocation failures are handled (or if they're presented to threads as such)
22:48:26 <RyanT5000> isn't this an OS-specific thing?
22:48:59 <wli> fs drivers are much like device drivers except that occasionally someone designs an fs and it doesn't need much in the way of hardware to do...
22:49:51 <wli> IOW halfs is fine to have, but shoveling data off of some preexisting fs's is worth quite a bit
22:49:59 <dons> yep.
22:50:12 <RyanT5000> yeah
22:50:35 <wli> RyanT5000: I'm referring to House here, of course.
22:50:50 <dons> vegai: any luck with lambdabot ? i haven't been able to reproduce any bug, neither dmhouse. tried a couple of boxes. sounds like a configuration issue i suspect.
22:51:19 <RyanT5000> wli: yeah, of course
22:51:23 <RyanT5000> compatability is key
22:51:55 <RyanT5000> i bet proper NTFS support would help linux's position out
22:52:08 <RyanT5000> being able to just slap linux on alongside winxp would help desktop adoption
22:52:50 <wli> ntfs has untold semantic evils
22:52:57 <RyanT5000> that may be
22:53:18 <RyanT5000> but it doesn't change the fact that MS uses it and therefore everyone else would benefit from using it
22:53:29 <RyanT5000> in fact, i bet MS purposely made it hard to write drivers for
22:53:36 <RyanT5000> as one more layer of lock-in
22:53:40 <wli> The point is that it's not just dropping in another driver as it would be for a UNIX-like fs.
22:53:53 <RyanT5000> i know, i didn't say it was easy or even worth it
22:54:02 <eric_j> it is possible to use the ms driver
22:54:27 <RyanT5000> (well, i shouldn't exactly say i "know", because i'm not really that knowledgeable about it - but i can certainly believe what you're saying)
22:54:40 <wli> In principle it wouldn't be terribly far out to get NT ABI emulation for that matter.
22:55:04 <wli> (I'm not kidding, either.)
22:55:14 <RyanT5000> well that'd be nice
22:55:51 <RyanT5000> i doubt anyone can take over the desktop arena without having either near-flawless MS compatibility or waiting for MS to die naturally (which might take a loooong time)
22:55:56 <wli> Time, money, and damage to the rest of the kernel while charging through it like a bull through a china shop dropping compatibility hooks for the semantic impedance mismatches everywhere...
22:56:26 <RyanT5000> i'm highly confused at how NTFS could possibly require thatt
22:56:38 <RyanT5000> it's a data format
22:56:53 <wli> I was going on about NT ABI emulation, but NTFS is much the same, just to a lesser degree.
22:57:08 <RyanT5000> ah true, but even so
22:57:21 <wli> Filesystems aren't just data formats. There are structures and access method affairs.
22:57:45 <RyanT5000> wli: but you wouldn't use the semantics of a windows FS
22:57:48 <wli> For instance, there's some Apple thing called something like "resource forks" or something that isn't there.
22:58:25 <RyanT5000> yeah, and NTFS has alternate data streams
22:58:31 <wli> Things "work" fairly smoothly without them, with the caveat that there's some data that can't be gotten at.
22:59:14 <wli> And if you're doing write support you often can't ignore those things. The user just doesn't have a window into them.
22:59:32 <RyanT5000> yeah
23:00:01 <RyanT5000> well i dunno, i hate the hierarchical file system semantic anyway :P
23:00:09 <RyanT5000> not that i'm saying it should be changed in linux
23:00:25 <wli> Throw ABI emulation atop the fs support and you're forced to incorporate the semantics a priori.
23:00:34 <RyanT5000> yeah
23:00:57 <vegai> dons: all right. I'll try to clean everything up properly ... somehow and go again
23:01:02 <wli> RyanT5000: What do you want instead? 1950's-style total absence of directories apart from the root directory?
23:01:36 <dons> 1950s style?
23:01:45 <dons> they had root directories in the 50s?
23:01:56 <RyanT5000> wli: something database-like
23:01:58 <wli> dons: I may be thinking of early 1960's.
23:02:08 <RyanT5000> though not really databases
23:02:15 <dons> sounds like some systems I used in the 1980s, wli :)
23:02:20 <RyanT5000> i'm not sure i have the vocabulary to express exactly what i want
23:03:33 <wli> dons: The development of OS's was kinda-sorta recapitulated by the PC types, completely ignoring CTSS, OS/360, VM/ESA, MVS, TOPS-10/20, Multics, etc. (never mind their precedents, e.g. Nova RDOS).
23:04:22 <dons> yeah.
23:04:25 <wli> RT-11 I think lacked hierarchical fs's
23:04:46 <Razor-X> How does an MVar work?
23:05:20 <xerox> ?arr!
23:05:20 <lambdabot> I'll crush ye barnacles!
23:05:28 <dons> Razor-X: with rts support. can you clarify your question a bit?
23:05:46 <RyanT5000> wli: i'm not saying i want it to lack a hierarchical file system
23:05:50 <dons> do you want to know its haskell-level semantics, or how the ghc rts implements it?
23:05:56 <Razor-X> dons: Well, how would you use an MVar to communicate between two threads?
23:06:03 <RyanT5000> i'm saying i want a FS strictly more powerful than a hierarchical one
23:06:03 <Razor-X> The semantics.
23:06:07 <dons> ah, you create an MVar, then pass it to both threds
23:06:17 <dons> they can then see anything placed into that MVar
23:06:23 <RyanT5000> certainly there are some times when hierarchies accurately express data
23:06:26 <dons> like a normal mutable variable passed via reference
23:06:30 <Razor-X> Ah.
23:06:41 <Razor-X> But you have to pass it to both functions?
23:06:49 <dons> and then you use takeMVar from a reader thread, and putMVar in the writer thread, for example
23:07:01 <dons> which ensures atomicity
23:07:09 <Razor-X> Ah.
23:07:17 <wli> RyanT5000: There are reasos why certain things are shunted into userspace. For instance, hardlinking directories makes certain search problems in the kernel potentially highly computationally expensive.
23:07:20 <dons> Razor-X: sure, hotherwise how does the thread know which Mvar to talk to? it has to be in scope
23:07:28 <Razor-X> dons: Yeah, true.
23:07:33 <dons> Razor-X: let me find an example
23:07:37 <Razor-X> dons: Thanks.
23:07:58 <RyanT5000> wli: is there some reason file systems are in the kernel?
23:08:04 <RyanT5000> "efficiency"
23:08:12 <RyanT5000> @toogle singularity os site:microsoft.com
23:08:12 <lambdabot> Maybe you meant: google hoogle
23:08:20 <RyanT5000> @google singularity os site:microsoft.com
23:08:22 <lambdabot> http://research.microsoft.com/os/singularity/
23:08:40 <RyanT5000> there's entirely too much stuff in modern kernels
23:08:46 <wli> RyanT5000: Filesystem semantics are stripped down in various ways by design, and various things having to do with "efficiency" are the general thrust of most new semantic fs developments.
23:09:14 <RyanT5000> well maybe there needs to be a two-level file system paradigm
23:09:26 <wli> RyanT5000: Yes, the kernel is required to carry out a large number of fs operations internally. For instance, when faulting in pieces of a file, kernels have to implicitly carry out a read()
23:10:05 <wli> If you get invocation chains of user -> kernel -> user -> kernel there's no guarantee they will terminate.
23:10:09 <RyanT5000> wli: that's different from needing it to be in-kernel, software design-wise
23:10:25 <wli> So that's why fs drivers are in the kernel.
23:10:47 <dons> Razor-X: main = do
23:10:47 <dons>     mv <- newEmptyMVar
23:10:47 <dons>     forkIO (writer mv)
23:10:47 <dons>     reader mv
23:10:47 <dons>     where
23:10:49 <dons>       reader mv = takeMVar mv >>= print . ("reader sees: " ++ )
23:10:52 <dons>       writer mv = putMVar mv "writer waz here"
23:11:02 <wli> RyanT5000: Um... this is a correctness issue, not a performance issue.
23:11:05 <RyanT5000> just because you trust something on some level doesn't mean you need to put it into the kernel wholesale
23:11:26 <RyanT5000> e.g.: i may need to trust my root file system 100%, but what if there's a foreign filesystem on a disk?
23:11:26 <dons> here, the writer puts a string into a shared variable, and the reader waits on that value. once its full, the reader retrieves the value and prints it.
23:11:32 <RyanT5000> i don't need to trust that at all
23:11:40 <Razor-X> dons: Ah.
23:11:52 <dons> so you get nice locking. the reader (main thread) will block until the mvar is full
23:11:57 <Razor-X> dons: Thanks.
23:12:06 <RyanT5000> in fact, if you ran that in userspace, you could have a bunch of drivers on the disk to help out with compatability
23:12:08 <wli> It's not trust. It's that there's no way to guarantee forward progress without a sophisticated apparatus for delegating kernel functions to user programs without getting into horrible circular dependencies.
23:12:51 <wli> RyanT5000: That's sort of a non-issue. Only a few fs drivers are generally required for any particular site.
23:12:54 <RyanT5000> wli: what? why? if you have a read function, it better not have a circular reference, whether or not it's in kernels pace
23:13:17 <dons> Razor-X: there's more examples of how to use mvars in the 'Tackling the Awkward Squad' paper, linked to on the runtime sytems's page of haskell.org, and googlable too.
23:13:31 <wli> RyanT5000: Yanking it out of the kernel creates a circular reference. Putting it intothe kernel eliminates the potential for a circular reference.
23:13:32 <Razor-X> dons: Thanks. I'll check it out.
23:13:44 <RyanT5000> wli: only if you design it stupidly
23:13:58 <RyanT5000> obviously some file systems need to be swapped in all the time
23:14:06 <RyanT5000> so if you don't do that, you end up with a circular reference
23:14:12 <wli> RyanT5000: No, it's always unless you get it exactly right.
23:14:29 <RyanT5000> wli: i don't see why that's any easier with it being in-kernel
23:14:36 <wli> RyanT5000: It's much more troublesome than "just swapping it in all the time"
23:15:31 <RyanT5000> in-kernel vs. out-of-kernel is equivalent to a performance penalty for each call
23:15:54 <wli> No, it's not equivalent to a performance penalty (and if it were it could be ignored since it's mostly washed out by disk operations).
23:16:21 <RyanT5000> what's the difference? you just set up gates for all the kernel functions it needs to call
23:16:40 <RyanT5000> and replace unsafe operations with kernel calls of the same
23:16:57 <wli> No, like I said, when trying to bring in a piece of data you can get into a lot of nasty situations with kernel invoking user invoking kernel invoking user etc. loops
23:17:16 <RyanT5000> yes, but you can do that anyway
23:17:27 <RyanT5000> only it's kernel invoking kernel invoking kernel invoking kernel
23:18:02 <wli> When? Things as they're arranged now invoke the kernel and the kernel returns to userspace vs. invoking it.
23:18:23 <RyanT5000> yeah well imagine you divide the same exact kernel into two pieces
23:18:30 <wli> Blowing the stack in-kernel is audited for and eliminated aggressively.
23:18:51 <RyanT5000> now you put a context-switch between these two kernel pieces
23:18:54 <RyanT5000> what changed?
23:19:01 <wli> Nonrecursive algorithms have been introduced into the block layer, methods to prevent stack blowing in pathname resolution are there, etc.
23:19:38 <RyanT5000> ok... so if it needs to be nonrecursive anyway
23:19:41 <wli> RyanT5000: You're confusing kernel/user context switching with thread switching.
23:20:00 <RyanT5000> that's because that's what it is
23:20:07 <wli> It's not.
23:20:08 <RyanT5000> i know x86 hardware decently well
23:20:22 <RyanT5000> you change page tables, you change tasks, and you change rings
23:20:30 <RyanT5000> certain operations are disabled in ring 3
23:20:37 <RyanT5000> replace them with kernel calls
23:20:49 <wli> I'm aware of x86 architecture also.
23:20:52 <RyanT5000> which are simple one-liners that do some kind of hardware thing (i'm ignoring security checks for now)
23:20:59 <RyanT5000> so what's the difference between ring 0 and ring 3?
23:21:24 <wli> okay, time #10 around the bend then I go back to what I was doing
23:21:42 <wli> userspace implicitly invokes kernel via e.g. pagefault to read itself in
23:22:14 <wli> That's user -> kernel, and that's *stacked*. Kernel has to return to user with return status in some form (in this case, pagetable update).
23:22:21 <RyanT5000> right
23:22:56 <wli> Now the kernel has to invoke userspace to do the fs operation, and *that's* stacked, user must return status to kernel for successful completion of the operation and possibly other details.
23:23:04 <RyanT5000> right
23:23:25 <RyanT5000> although the kernel has the possibility of timing out, e.g. if the fs driver crashed
23:23:39 <RyanT5000> if the fs driver's in kernel, the system just got hosed
23:23:39 <wli> Now this userspace faults and invokes the kernel, and *that's* stacked
23:23:45 <wli> eh, no
23:23:51 <RyanT5000> wli: so don't allow fs drivers to fault!
23:23:55 <wli> The kernel isn't executing, it invoked userspace
23:24:06 <wli> RyanT5000: Then they won't execute.
23:24:10 <RyanT5000> no
23:24:14 <RyanT5000> load them when you load the kernel
23:24:16 <RyanT5000> never swap them out
23:24:17 <wli> If you don't fault things in, they don't run.
23:24:22 <RyanT5000> problem solved
23:24:33 <RyanT5000> that's because your design is as such
23:24:35 <wli> RyanT500: That's usually called a kernel module.
23:24:39 <RyanT5000> change your design
23:24:52 <wli> RyanT5000: What, you don't like demand paging?
23:25:05 <RyanT5000> i love demand paging, but that doesn't mean you can't have a flag for it
23:25:15 <RyanT5000> on a per-page or per-task level
23:25:31 <RyanT5000> it's obvious the swap driver can't be paged out, ever
23:25:39 <RyanT5000> set the "don't page out, ever" bit
23:25:59 <wli> So the first time it runs it needs to get loaded and will stay loaded... at which point the first time it runs you invoke the kernel as I described, merely faulting in everything instead of incrementally faulting.
23:26:39 <RyanT5000> ...
23:26:40 <wli> Trust me, unless you launch it prior to use it's hopeless.
23:26:48 <RyanT5000> do you realize there are other ways than faulting to load things?
23:27:14 <RyanT5000> just DMA it in on kernel load
23:27:21 <wli> And for that you need a funky privileged class of application like microkernels have, that effectively run in kernelspace like an exokernel app.
23:27:33 <RyanT5000> right, and the problem is?
23:27:40 <RyanT5000> you already have that, you just didn't separate it out
23:28:08 <wli> Okay, this is not going well. I'm cutting it off.
23:28:40 <RyanT5000> alright, no problem; you obviously know what you're talking about in a lot of ways, we just don't agree on the monolithic/micro kernel debate :)
23:29:57 <RyanT5000> (i believe there's another pair of people slightly more famous than us with this debate, currently, lol)
