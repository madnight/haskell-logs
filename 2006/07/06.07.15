00:00:39 <dons> right, so this code has lots of 'boilerplate'
00:00:49 <dons> stuff just involved in getting down to the level you want
00:00:49 <rictic> I'm just wondering if there's some way I can abstract much of that type of code away
00:01:02 <rictic> Yes, and it feels dirty
00:01:18 <dons> yeah, using scrap your boilerplate. you willing to spend a few hours learning a new technique?
00:01:22 <dons> let me find the references
00:02:03 <dons> the good thing about this kind of structural induction is that you know your code is correct- -- you've covered all cases
00:02:11 <dons> but doing lots of such work can be tedious
00:02:30 <dons> so we can let the compiler generate functions for doing these traversals for us,
00:02:44 <dons> here's the main site for the SYB style, http://www.cs.vu.nl/boilerplate/
00:02:46 <lambdabot> Title: Scrap your boilerplate ... in Haskell
00:03:04 * wli screams at debian
00:03:21 <dons> it uses Data.Generics to let you write generic code that traverses your function looking for particular types
00:03:54 <rictic> Huh
00:03:59 <dons> now, however, you're new to haskell, so this might be too much stuff at once. so its a cost/benefit tradeoff
00:04:06 <rictic> This is true
00:04:09 <dons> if you're doing this for a few weeks, learning SYB style is a good idea
00:04:20 <dons> but if its a quick hack, copy/paste might be easier to do all the cases
00:04:25 <rictic> Should I have heard of Data.Generics before?
00:04:48 <dons> hmm, not necessarily. its primarily used by data structure hacking projects, like compilers
00:04:52 <dons> which is sort of what you're doing
00:04:54 <dons> but its fairly new
00:04:58 <wli> I'll settle for learning where hdbc docs are hidden.
00:05:12 <edwardk> heh good to know that its there though. skimming for functionality i can use =)
00:05:36 <dons> yeah, you can end up writing O(1) lines of code, instead of O(n) lines
00:05:38 <edwardk> i'd seen the Typeable_ classes before
00:05:52 <edwardk> but the rest i hadn't seen in haskell
00:05:59 <dons> so just the case you want, i.e. everything (the type I want), versus a structural induction of all n casees
00:06:02 <edwardk> rea the SYB stuff way back though
00:06:07 <rictic> Yeah, skimming some of the code snippets looks very promising
00:06:23 <rictic> What does structural induction mean?
00:06:40 <rictic> nm, there's a wp article on it
00:06:43 <dons> oh, you do induction over the structure of your data type
00:06:56 <dons> so you solve your programming problem by recursively breaking apart the structure
00:07:05 <edwardk> well, you have a recursive data type you want to wak down... heh, dons has it =)
00:07:24 <dons> its a general technique that encourages good solutions, since you cover all cases, and the compiler can check that for you
00:07:36 <dons> if you use it, you end up with a proof that all cases are handled
00:07:38 <dons> a good result
00:07:46 <rictic> :nod:
00:08:05 <wli> I've never tried it ... I should probably learn it sometime.
00:08:15 <dons> the basic idea is illustrated with lists, you have 2 cases, the [] case, and the inductive step, f (x:xs) = .. .f xs ..
00:09:34 <dons> its related to normal maths induction
00:09:43 <wli> At the moment I'm far more concerned with tracking HTTP cookies and CGI user state with a database library.
00:09:44 <rictic> So it's recursion through arbitrary data structures by defining rules for the base cases and rules that are guaranteed to break down into those base cases.
00:09:49 <dons> yep
00:10:13 <dons> which is a good 'pattern' for traversing structures :)
00:11:20 <dons> so what you're currently doing is good, and the usual way. if its going to be a big project, or you're looking to pick up new ideas, then check out the SYB approach
00:12:36 <rictic> Thanks.  I'm always looking to stretch my brain, it's why I'm learning haskell in the first place
00:12:40 <rictic> Thanks for the help :)
00:13:26 * johnnowa2 joins wli in his yelling
00:13:42 <dons> rictic: no problems. welcome to the community!
00:13:45 <dons> lots of fun things to learn
00:13:57 <jer> johnnowa2, i sympathize, my wifi cuts out in the afternoon quite regularly
00:15:37 <rictic> dons: Yeah, when I first started working in Haskell, I was amazed at how incompetent I was at it.  It's been a long time since programming was this hard, and I'm glad for it :)
00:16:18 <edwardk> know the feeling
00:17:13 <dons> yeah, everything down to the language foundation was reconsidered and designed, so many new ideas to grapple with
00:17:42 <dons> luckily, it improves your code in your existing languages, since it exposes concepts that were previously not understood clearly
00:18:17 <dons> things like side effects , purity, strictness , why concurrency is hard, what types really mean
00:18:25 <dons> lots of fun things
00:18:39 <vegai> and leads to using lots of function pointers
00:19:01 <dons> yeah, higher-order functions just change how you view programming
00:19:18 <dons> it's a real metalevel, that is hard to even imagine if your stuck in some other languages
00:19:38 <dons> what's the quote from Orwell about how language controls thinking?
00:20:06 <dons> if your langauge isn't expressive enough, you can't even imagine some alternatives
00:20:36 <sieni> dons: I disagree about the control part
00:21:20 <dons> yes? surely its hard to imagine the impact of say, laziness + hof, in a strict language without first class functions
00:21:24 <sieni> dons: I don't find making bad design choices with C. I'm just annoyed about having to spend too much time on trivial things while doing The Right Thing
00:22:06 <sieni> and there are some things that are hard to get right regardless of the language
00:22:47 <sieni> I had to implement posix condition variables using windows primitivves and most, if not all, documentation you find on the web are just plain wrong
00:22:58 <dons> yikes, fun fun
00:23:51 <vegai> dons: http://en.wikipedia.org/wiki/Sapir-Whorf_Hypothesis
00:24:12 <dons> ah!
00:25:36 <rictic> dons:  The biggest thing I've been struck with so far are the things that you get for free with functions without side-effects
00:25:46 <sieni> I ended up implementing the condition variable using two semaphores per condition variable so that when you get a signal or broadcast you release the waiters and start collecting new waiters on the other semaphore and if you get another signal or broadcast, then you tag the waiters appropriately to be released and then the last one to be released from the semaphore then checks if the other semaphore needs to be released
00:26:27 <Pegazus> what are the best features of haskell? (high order? lambda functions? monads? anything more?)?
00:26:29 <edwardk> yeah, spend a lot of time working for linguists, its a pretty common reference in those circles (well, given that Sapir and Whorf were linguists thats not surprising) =)
00:26:33 <rictic> dons: For example, the compiler can memoize frequently called functions
00:26:40 <dons> rictic: yeah, it has such a pervasive effect. for examples, suddenly things like concurrency becomes a lot easier.
00:26:49 <jer> Pegazus, probably time travel i'd have to say =]
00:27:10 <sieni> I don't know how you can help with all the annoying locking problems and race conditions with anything else except using one's head for something else than a hat stand
00:27:14 <dons> edwardk: right, i'd encountered, and forgotten, about kant's work on how the understanding moderates our view of the world
00:27:25 <Pegazus> nice, i didn't knew haskell computed faster than light speed...
00:27:26 <sieni> Pegazus: compared to what?
00:27:38 <edwardk> sieni: thats what STM is for. lock? whats a lock? =)
00:27:38 <Pegazus> compared to nothing
00:27:43 <wli> Memoization only makes sense if it's not faster to recompute on the fly... and even then the memo cache size needs to be tuned... AIUI anyway.
00:27:43 <Pegazus> haskell vs more haskell
00:27:47 <rictic> I don't think that lambda functions are that big of a deal.  Sure, they make higher order functions more convenient, but they're not much special as far as I can tell
00:27:58 <Pegazus> i like lambda functions :)
00:28:02 <dons> rictic: another example I like. purity means I can let lambdabot evalutate random peoples code, since the type checker gives me a proof that the code is safe:
00:28:06 <dons> > map (+1) [1..]
00:28:07 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
00:28:10 <jer> Pegazus, it doesn't, it's lazily evaluated which means that there is the possibility that an expression written after a previous expression can be evaluated before the previous expression is
00:28:12 <dons> > putChar 'x'
00:28:12 <lambdabot>  No IO allowed
00:28:13 <Pegazus> i forgot, comprenhensive lists..
00:28:15 <edwardk> rictic: write lots of functional code in javascript for a while, then you'll LOVE that \x -> .... syntax =)
00:28:15 <sieni> edwardk: I was talking about relatively low-level thing
00:28:29 <vegai> dons: ohhh! Never thought of that.
00:28:35 * vegai satori
00:28:39 <sieni> Pegazus: yes, I like lambdas very much
00:28:40 <Pegazus> what more?
00:28:40 <rictic> Pegazus: I do too, I've used them a lot, but I think it's a relatively minor thing
00:28:45 <Pegazus> mmm
00:28:52 <Pegazus> i don't think lambda are a minor thing...
00:29:07 <dons> vegai: yeah, it's a great result, i think. but one we don't often appreciate
00:29:08 <rictic> Why's that?
00:29:12 <sieni> Pegazus: i.e. that makes e.g. haskell, ml and lisp great against say c or java
00:29:13 <Pegazus> they are quite convinient...
00:29:30 <Pegazus> i am not comparing haskell to anything
00:29:36 <Pegazus> i am just talking about haskell alone...
00:29:37 <sieni> Pegazus: haskell and ml are statically typed as opposed to lisps (like common lisp or scheme)
00:29:49 <rictic> dons: That's pretty dang cool
00:29:57 <rictic> dons: That's really cool actually
00:30:02 <sieni> Pegazus: haskell is lazy, ml and lisps are strict
00:30:06 <Pegazus> i don't care about ml or lisp :)
00:30:25 <Pegazus> anyway, any more distinctive feature?
00:30:48 <sieni> Pegazus: well, I like all of them (i.e. haskell, ml and lisp ;-)
00:30:56 <jer> Pegazus, if you're not comparing haskell to anything else, then no haskell feature stands out as there's nothing to compare it to
00:31:00 <rictic> Do other languages have monads?
00:31:05 <sieni> Pegazus: well, laziness is pretty distinctive feature
00:31:12 <Pegazus> i am not talking about any other language
00:31:13 <jer> or rather, nothign that would make it stand out
00:31:19 <Pegazus> i just want to know good things about haskell
00:31:25 <edwardk> rictic: heh well, i made them work in javascript ;)
00:31:29 <shapr> Nice people use Haskell.
00:31:31 <vegai> rictic: there's nothing in monads that cannot be implemented in any language (I think)
00:31:33 <jer> Pegazus, perhaps you could read the report
00:31:40 <Pegazus> i just want to know what features are really nice to use in every day or not every day haskell programming
00:31:50 <shapr> Partial application
00:31:51 <dons> rictic, some languages have ported monads to their situation, ruby and C++ come to mind
00:31:57 <edwardk> rictic: and c++, but its somewhat absurd
00:31:58 <sieni> rictic: well, you can certainly implement them in other languages. e.g. in scheme: http://okmij.org/ftp/Scheme/monad-in-Scheme.html
00:31:59 <lambdabot> Title: Monads in Scheme
00:32:02 <Pegazus> yeah, currification is really nice too
00:32:03 <vegai> but Haskell seems to be the only language that uses Monads so extensively
00:32:15 <dons> but without the other features, (laziness, hof, syntax) it seems unlikely to be widely taken up
00:32:20 <vegai> and has special syntax for them
00:32:24 <sieni> Pegazus: look at that:
00:32:25 <rictic> dons: Reading an article on monads in ruby is what initially got me interested in learning Haskell
00:32:40 <vegai> well, I suppose you have to include scheme in the list of languages that might have 'special syntax' for monads ...
00:32:45 <shapr> rictic: http://lambda-the-ultimate.org/node/1136
00:32:47 <lambdabot> Title: Collection of links to monad implementations in various languages. | Lambda the  ...
00:33:06 <sieni> > take 10 $ let l = 1 : map (+1) l in l
00:33:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
00:33:21 <sieni> Pegazus: how do you say that similarly without laziness?
00:33:27 <edwardk> dons: someone earlier was asking what dynamically-typed lazy pure languages were out there. I couldn't think of one off the top of my head. you?
00:33:37 <sieni> Pegazus: in lisp or ml you have to spank the lambda or something
00:33:39 <dons> i don't know of any.
00:33:45 <shapr> I wonder if Joy counts?
00:33:47 <Pegazus> spank? what do you mean?
00:34:05 <sieni> Pegazus: I meant it figuratively ^_^
00:34:15 <edwardk> skimming their docs
00:34:16 <dons> but there's not a lot of language research done on dynamically typed languages, anyway.
00:34:17 <edwardk> =)
00:34:22 <edwardk> yeah
00:34:26 <edwardk> i figured as much
00:34:29 <sieni> Pegazus: spank as in making the butt hurt or something ^_^
00:34:33 <edwardk> and haskell would suck without its type system
00:34:39 * shapr wanders off to a meeting of unicyclists.
00:34:52 <Pegazus> ok
00:34:54 <sieni> shapr: say hello to them
00:35:17 <sieni> shapr: and don't forget to visit helsinki now that you live in stockholm
00:35:34 <vegai> shapr: or some nice city :P
00:37:31 <Pegazus> thanks you all guys...
00:37:57 <sieni> Pegazus: don't forget peter norvig's advice
00:38:20 <sieni> Pegazus: http://www.norvig.com/21-days.html
00:38:21 <lambdabot> Title: Teach Yourself Programming in Ten Years
00:38:21 <Pegazus> i can't forget what i've never known :)
00:38:28 <edwardk> heh
00:39:17 <Pegazus> i don't liked those books anyway...
00:39:53 <Pegazus> i think that 1 day is enough :)
00:40:04 <edwardk>  suppose lazy k fits the definition i gave above
00:40:10 <edwardk> *twitch*
00:43:57 <sieni> Pegazus: But I would suggest learning several programming languages thoroughly
00:44:33 <sieni> Pegazus: and I think that every programmer should learn c++ well.
00:44:46 <sieni> Pegazus: as a cautionary example, if not for any other reason
00:44:58 <rictic> seini: I was about to ask you why you thought that
00:45:11 <rictic> seini: c++ can be such an unpleasant experience
00:45:24 <Pegazus> i know c++ quite well already :)
00:45:34 <sieni> rictic: well... you can learn it in small pieces I guess
00:46:25 <sieni> Pegazus: I only know personally one person that I actually believe to know
00:46:35 <sieni> c++ well
00:46:46 <Pegazus> i didn't say well, just a quite well :)
00:46:50 <Pegazus> (it's a little less)
00:47:01 <sieni> he's a colleague of mine and he's actually contributed to boost libraries
00:47:06 <Pegazus> :)
00:47:11 <rictic> seini: But I'm just asking what you think is important about it for coders to learn.  I don't disagree necessarily, I'm just interested in your reasoning
00:47:17 <Pegazus> what lib?
00:47:48 <sieni> Pegazus: his name is vesa karvonen, you can probably find him by googling
00:47:57 <edwardk> boost is the only thing i've found that makes c++ worth writing these days
00:48:04 <Pegazus> O_o
00:48:21 <Pegazus> boost is just an example of how great c++ is...
00:49:07 <Pegazus> he made preprocessor O_o
00:49:07 <sieni> he's nowadays a big standard ml and mlton fanboy and commented that "c++ is a piece of shit as a language and should not be used for anything else except maintaining legacy projects"
00:49:26 <edwardk> well, give it typedef templates so i don't have to do allocator::rebind<foo>::type crap all over the places get it a type inference mechanism, and we'll talk =)
00:49:44 <sieni> he did something weird stuff, like implementing a functional programming language interpreter with c preprocessor or something
00:50:05 <Pegazus> preprocessor is to generate code with preprocesor
00:50:12 <Pegazus> it has control functions, and loops...
00:50:39 <Pegazus> (also "data structures")
00:50:42 <sieni> Pegazus: like the regular c preprocessor?
00:51:06 <Pegazus> yes, in fact it's done with the c preprocessor..
00:51:14 <Pegazus> it's not a "program"
00:51:20 <Pegazus> he just made a bunch of files/macros
00:51:22 <sieni> I guess he's done quite a bit of template stuff as well
00:51:28 <Pegazus> that let you generate more complicated things
00:52:01 <sieni> Pegazus: well, compile-time metaprogramming. like lisp or scheme macros but awfully more complicated in that
00:52:11 <Pegazus> :)
00:52:27 <sieni> Pegazus: there's also template haskell (a haskell extension) to do compile time metaprogramming in haskell
00:52:43 <Pegazus> k
00:52:46 <sieni> http://www.haskell.org/th/
00:52:47 <lambdabot> Title: Template Haskell
00:53:33 <edwardk> heh, i just realized what preprocessor you were talking about. i've used that =)
00:53:53 <Pegazus> BOOST_PP_REPEAT
00:53:56 <edwardk> (needed it to deal with various numbers of template parameters without boilerplate, etc)
00:55:17 <sieni> although some people are against compile time metaprogramming, like andrew appel, who thinks that it should be compiler's, not programmer's, problem to figure optimizations out
00:55:48 <Pegazus> metaprogramming isn't about optimizing code
00:56:03 <Pegazus> but making a program that generates the source code for your program...
00:56:17 <edwardk> well, as much as i respect appel, (and even use one of his random tricks as the core of my current project), the rest of us exist in the real world =)
00:56:38 <edwardk> i don't use metaprogramming for optimization very much, i use it to discard boilerplate
00:57:22 <edwardk> though, that said, i'm about to embark on using it for both optimization and boilerplate discarding for my current haskell project
00:57:44 <xerox> G'day sieni, edwardk :-)
00:57:50 <edwardk> heya xerox
00:58:40 <sieni> Pegazus: Yes, but in functional programming languages you can use higher order functions for that
00:59:07 <edwardk> sieni: 99% of the time
01:00:46 <sieni> well, I don't agree with appel, I just thought I'd mention his opinion as well :-)
01:00:54 <edwardk> heh
01:01:14 <sieni> although I can't say I disagree with him either
01:01:16 <edwardk> hrmm. dictionaries tend to be more efficient than record fields, right?
01:01:26 <sieni> edwardk: ?
01:01:46 <edwardk> i agree with him in principle, and i wish him luck with his endeavors and will use it if its faster =)
01:01:52 <sieni> edwardk: what do you mean? isn't dictionary like a hash table and a record is like a struct
01:02:31 <sieni> then I'd say that accessing a record field is faster, since you just take a constant offset from the pointer to your struct
01:03:02 <edwardk> i kind of take the 'no sacred cows' approach to programming and methodology. everything is open for debate and discussion. the 'don't do x' its wrong approach, usually just means 'i dont want to think about that now' =)
01:03:28 <edwardk> sieni: dictionary in haskell terms as in class dictionary.
01:03:49 <edwardk> those little hidden pointers to structures that the haskell compiler passes around
01:03:53 <dons> but a dictionary is just a struct, no?
01:04:07 <edwardk> it is, but the comppiler can optimize them away based on type
01:04:08 <dons> it's compiled to a data, where the class methods become fields in the data type
01:04:17 <dons> right.
01:04:20 <edwardk> if you pass one explicitly it has to assume you are going to use the ability to change what it points to
01:04:36 <edwardk> and can't inline or optimize it away
01:04:36 <dons> Eq a => a -> ...  goes to  EqA -> a -> ...
01:05:44 <edwardk> i was just curious how bad it was, because i'm staring at a bit of code right now thinking i might get it a lot shorter if i made a c-style 'vtable' right in my record =)
01:06:17 <edwardk> trying to see if i can simplify a type annotation by shunting the complexities into the type of that vtable.
01:06:47 <edwardk> er well, simplify a lot of type annotations
01:06:59 <edwardk> coz as i work through errors, the ones i have keep getting worse
01:07:12 <sieni> edwardk: well, there are some "don't" that you learn the hard way. Like "always broadcast a condition variable, unless you really _really_ REALLY want to just wake up any thread waiting on it."
01:07:43 <edwardk> (yes, i could replace the beginning of this with a traits class): fromList :: (Var m r, MArray a [(k,v)] m, VArray m v, Eq k) => (k -> Int) -> [(k,v)] -> m (VHash r a k v)
01:08:03 <edwardk> but a file full of type annotations like that is starting to hurt and Can't perform well
01:08:51 <dons> there's a trick using a new instance as an alias for all those class constraints, have you looked into that?
01:09:12 <edwardk> yeah that was what i was doing before
01:09:16 <dons> something like class (Var m r, MArray a [(k,v)] m, VArray m v, Eq k) => C m r a k v -- or so
01:09:25 <edwardk> then it was VTraits m r a k v...
01:09:29 <dons> ah right
01:09:49 <edwardk> but i was getting some weird problems with it complaining about my types not being the most polymorphic possible, etc.
01:10:06 <edwardk> so i unbundled a bunch to test.
01:10:09 <dons> oh, maybe you need -foverlapping-instances
01:10:27 <dons> to handle, say instance C a , instance C Bool
01:10:49 <edwardk> *nods*
01:11:28 <edwardk> my biggest gripe is that even with that monolithic traits class, the length of the defs is pretty far out there ;)
01:11:50 <edwardk> and every little tweak to the internals forces me to modify the type more
01:12:24 <dons> yeah, you're going pretty insane with the types. there's no way to reduce the paramaterisation?
01:12:51 <edwardk> i just want a pretty simple concept: a hash type parameterized by monad, key and value.
01:12:59 <edwardk> the monad should be one of STM IO or ST
01:13:19 <edwardk> from that i derive that var/ref should be TVar IORef or STRef and an appropriate array for the key and value
01:13:40 <dons> so, then, what's all the class stuff for?
01:13:45 <edwardk> but the type for the hash requires me to have the extra parameters, and i can't have fundeps in a data statement =)
01:14:04 <edwardk> the class is to fundep the ref type and array type =)
01:14:07 <dons> you'd be looking for functoins of, say, Monad m => k -> v -> m v
01:14:33 <dons> well, seems too complex to me. even our array lib doesn't go that nuts :)
01:14:38 <edwardk> heh
01:14:47 <edwardk> i agree
01:14:51 <dons> (!)           -- :: (Ix a) => Array a b -> a -> b
01:15:08 <dons> ?hoogle newArray
01:15:09 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
01:15:09 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
01:15:09 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
01:15:13 <edwardk> i wanted to see what wwould be required to get a generic way to handle a data structure that was independent of the 'refmonad' that contained it
01:15:16 <xerox> Well, you can constraint like the Array lib does, can't you?
01:15:18 <dons> MArray a e m is about as far as it gets
01:15:30 <dons> parameterised over the array, eleme and monad
01:15:49 <dons> no need for all the type class hackery
01:16:00 <xerox> dons: `a' is the elements' type, or what?
01:16:17 <dons> Ix i is the index, 'e' is the element. isn't 'a' a phantom, like in ST a ?
01:16:33 <edwardk> dons: at the least to get it to work i need the type VHash a r k v with a an array type that stores [(k,v)] pairs and is mutable within the monad
01:16:41 <edwardk> r a reference type that works in the monad
01:16:47 <edwardk> and k and v the key and value type
01:16:54 <edwardk> thats a clean generalization of the existing interface
01:17:04 <dons> xerox,
01:17:05 <dons> An array type has the form @(a i e)@ where @a@ is the array type
01:17:05 <dons> constructor (kind @* -> * -> *@), @i@ is the index type (a member of
01:17:05 <dons> the class 'Ix'), and @e@ is the element type.
01:17:21 <dons> i.e. MArray, UArray, and so on, I think
01:17:28 <xerox> Oh. Now I wonder why it is parametrized on the constructor.
01:17:45 <dons> so we can distinguish mutable, foreign, io and unboxed arrays?
01:17:58 <xerox> I never worked with arrays so far. I see.
01:18:10 <edwardk> xerox so you can feed that constructor an Ix and its element type
01:18:13 <dons> instance Storable e => MArray StorableArray e IO where
01:18:40 <xerox> What does the `M' stand for?
01:18:40 <dons> also STUArray, STArray
01:18:43 <dons> Mutable
01:18:51 <dons> in some monad
01:18:54 <edwardk> StorableArray takes two parameters the Ix () type because how you index it (with chars, ints, etc. is irrelevant, Ix is abstracted away.. and the element type
01:19:16 <edwardk> the problem is MArray needs the element type because you can have unboxed mutable arrays, et. that have limited sets of types that can be stored in them
01:19:26 <dons> yep
01:19:33 <edwardk> MArray a e m makes the array mutable within a given monad
01:19:52 <edwardk> gives you the horribly verbose mutable array access functionns to get and set elements
01:20:15 <dons> so if you could find an interface close to the Array one, it would be more readily adopted, than some scary HList/super-typehackery interface :)
01:20:30 <edwardk> and may i say that from an efficiency standpoint the internals of how MArray are implemented give me the willies
01:20:32 * xerox nods
01:20:39 <dons> yeah, me too
01:20:47 <edwardk> i tried. i started there =)
01:20:48 <dons> though there's a lot of SPECIALISE going on
01:21:00 <dons> so uarrays end up in a good place
01:21:13 <edwardk> yeah, but even with that, the type itself doesn't offer you the ability to make constructors for the other cases
01:21:36 <edwardk> so it has to build the array first (possibly initialized to arrEleBottom) THEN you can fill it.
01:21:55 <edwardk> which means for cases like my usage pattern, it would destroy the performance of my STM implementation
01:22:19 <edwardk> the compiler might somehow magically guess that it can work around that, but i currently can't see how
01:22:57 <dons> rewrite rules? specialise pragmas?
01:23:01 <edwardk> and since i reallocate arrays frequently to grow them thats a genuine worry for the 'THash' variant
01:23:15 <edwardk> could probably specialise pragma it
01:23:19 <dons> yeah, keep it simple and in IO first, perhaps?
01:23:27 <edwardk> i don't want IO
01:23:33 <dons> but i guess you know where you're heading with this.
01:23:39 <edwardk> if i figure i want it simple i'll write it in STM first then move
01:23:40 <edwardk> =)
01:23:47 <edwardk> thats what i did, i have one that works fine in STM
01:23:48 <dons> yep
01:24:00 <edwardk> i just wanted to generalize it to the others, partly so i could profile speeds
01:24:30 <edwardk> http://slipwave.info/haskell/docs/Data-THash.html
01:24:37 <edwardk> covers the STM version's interface
01:24:48 <edwardk> (just tried out haddock for the first time) =)
01:25:06 <edwardk> its got clean lines
01:25:09 <edwardk> i can live with it
01:25:25 <edwardk> the one for the generic version is a frankenstein nightmare
01:25:36 <edwardk> http://slipwave.info/haskell/docs/Data-VHash.html
01:25:47 <edwardk> and doesn't even work yet ;)
01:28:38 <xerox> At what distance do you have your screens?
01:28:54 <edwardk> i admit at this point, it seems my fastest resolution is an include file and 3 wrappers that use the c preprocessor ;)
01:29:08 <edwardk> template haskell could work, but its a little foreign to me
01:32:21 <edwardk> the need to pass in that MArray a [(k,v)] m is actually particularly galling
01:32:29 <edwardk> because it reveals so much of the internal structure
01:35:28 <edwardk> xerox: physically?
01:35:40 <edwardk> xerox: ~25 inches
01:37:27 <edwardk> ^-- that and template haskell seems like blasting a fly with a bazooka
01:40:08 <edwardk> i've been talking to myself for 15 minutes now. shutting up
01:44:27 * johnnowak was enjoying the noise
01:44:33 <edwardk> heh
01:45:15 <edwardk> well, if you have any ideas on how to cut a usable interface out of the code mentioned above, feel free to chime in =)
01:55:17 <Korollary> my brain is fried.
01:55:29 <edwardk> oh?
01:55:38 <Korollary> yum
01:55:44 * Korollary eats his own brain
01:55:49 <edwardk> i let mine simmer, occasionally slow roast
01:55:51 <JKnecht> what screens?
02:29:56 <foxy_> @seen dcoutts
02:29:56 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. I don't know when dcoutts last spoke.
02:30:11 <foxy_> dcoutts, ping
02:34:05 <Speck> are MPTCs and Fundeps going to be in Haskell'?
02:40:32 <xerox> Any Cabal Hackers here?
02:51:10 <Lemmih> xerox: Kinda.
03:06:24 <dmhouse> Good morning all!
03:06:33 <dmhouse> Good news: my mouse works. (It wasn't working last night.) :)
03:10:12 <dmhouse> Has anyone read the 'History of Haskell' paper? What's it like?
03:18:37 <ejt> hi, I've recently started tinkering with Haskell again after a gap of a few years
03:18:51 <ejt> but I'm getting a stack exception and I can't work out why
03:19:15 <ejt> I was wondering if anyone here would be prepared to look at my trivial program and explain how to reason where stack space is being used ?
03:19:31 <Lemmih> Sure.
03:19:32 <Lemmih> @paste
03:19:33 <lambdabot> http://paste.lisp.org/new/haskell
03:20:31 <lisppaste2> ejt pasted "3n+1 program" at http://paste.lisp.org/display/22635
03:21:02 <ejt> if you run it in ghci and give the input "1 1000000"
03:26:49 <foxy_> any gtk2hs hackers about?
03:35:46 <shemale_magic> is haskell able to outdo perl or python for web?
03:36:42 <xerox> foxy_ - Try asking.
03:37:29 <foxy_> I'm trying to compile gtk2hs on windows and I get an error...  (I'll paste output)
03:37:41 <xerox> shemale_magic - There are some frameworks for web developement.
03:38:08 <lisppaste2> foxy pasted "GTK2HS build" at http://paste.lisp.org/display/22636
03:40:23 <mnislaih> Lemmih, how busy are you right now? Can you spare a few minutes ?
03:40:41 <xerox> shemale_magic - Some I know of are http://happs.org/HAppS/README.html http://www.cs.chalmers.se/~d00nibro/hsp/ http://hope.bringert.net/about (if you want)
03:40:42 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8 )
03:44:20 <sieni> shemale_magic? sound quite on topic for this channel
03:44:48 <sieni> ahh sorry, I didn't notice the nick
03:45:07 <sieni> I thought xerox just made that up :-)
03:45:29 * xerox stares as sieni O_O
03:49:59 <sieni> now he escaped :-)
03:53:11 * beelsebob_ prods people with sticks
03:57:40 <dcoutts> foxy_, so this was the problem that the gtk/Graphics/UI/Gtk/Types.chs module was being generated inroccestly right?
03:58:00 <foxy_> dcoutts, yes, I'd like to try and help fix it
03:58:56 * beelsebob_ wonders if Wolfgang Thaller is ever going to pick up on HOC again
03:59:28 <erider> hi all
04:00:34 <dcoutts> foxy_, ok, great
04:01:50 <dcoutts> foxy_, ok, take a look in the Makefile and tell me what CREATE_TYPES is being defined as
04:02:03 <dcoutts> eg on my system it's: CREATE_TYPES = deprecated plugNsocket default gtk-2.2 gtk-2.4 gtk-2.6 gtk-2.8
04:03:20 <foxy_> CREATE_TYPES = deprecated plugNsocket default
04:03:21 <foxy_>      (P.S. should we open a private channel?)
04:05:16 <dcoutts> let's move to #haskell-overflow
04:05:24 <ejt> Lemmih: any ideas ?
04:07:31 <shemale_magic> hm
04:24:20 <nomeata> Hi. Any Idea on how this line might be more condesed (and maybe then morereadable)? map (\pref -> length (dropWhile (not.(`isPrefixOf` pat)) $ tail $ tails pref ) -1 ) $ inits pat
04:25:47 <dmhouse> nomeata: use a let to get rid of that horrible lambda.
04:26:20 <dmhouse> In fact, use several lets.
04:26:36 <nomeata> anything else? maybe some great standard function that I overlooked?
04:26:52 <dmhouse> Could you describe, qualitatively, what it does?
04:27:13 <nomeata> yes, it's the KMP shift function
04:27:37 <nomeata> (Knuth-Morris-Pratt text matching algorithm)
04:27:56 <dmhouse> Which does what?
04:28:40 <nomeata> for every prefix of the pattern it gives the length of the longest suffix of that prefix, that is a prefix of pattern
04:28:48 <nomeata> (not much better than the code, right :-))
04:29:57 <dmhouse> It's a complicated function, the code's going to be complicated.
04:30:03 <dmhouse> Use lets and document it well, that's my advice.
04:30:27 <nomeata> so, for "ababa", the prefix "abab" has the "ab" as such a suffix...
04:30:56 <nomeata> well, I just want to scare my students with that one, for fun, but I don't want them to come and give a half-a-liner that does it, too :-))
04:32:44 <tony2> > let pat = "ababab" in map (\pref -> length (dropWhile (not.(`isPrefixOf` pat)) $ tail $ tails pref ) -1 ) $ inits pat
04:32:45 <lambdabot>  [-1,0,0,1,2,3,4]
04:34:22 <tony2> hmm, ok.
04:46:46 <foxy_> @pl map (\pref -> length (dropWhile (not.(`isPrefixOf` pat)) $ tail $ tails pref ) -1 ) $ inits pat
04:46:46 <lambdabot> map (subtract 1 . length . dropWhile (not . (`isPrefixOf` pat)) . tail . tails) (inits pat)
04:47:49 <dmhouse> Do we have a 'null type' in Haskell? I.e. one whose only member is _|_?
04:48:49 <dmhouse> Like RealWorld, but which is actually defined in the standard libs.
04:48:56 <_Codex> undefined?
04:49:48 <dmhouse> _Codex: err, that's not a type.
04:50:01 <tony2> dmhouse, that's something I wonder every time I only use the keys in a map.
04:50:13 <tony2> but never investigate.
04:50:33 <dmhouse> tony2: Map KeyType a?
04:50:54 <dmhouse> Not much point in using a null type there. But my question stands. I don't think we do.
04:51:07 <_Codex> :t undefined :)
04:51:19 <dmhouse> _Codex: yes, and? undefined is _|_.
04:51:39 <tony2> hmm, yeah I guess so, but I serialise the map, and then that falls over.
04:52:24 <dmhouse> tony2: Ah. Why are you using a Map in the first place then?
04:52:57 <xerox> Yo.
04:52:58 <tony2> dmhouse, for logarithmic lookup and insert...
04:53:01 <xerox> ?Yow.
04:53:01 <lambdabot> Here I am in 53 B.C. and all I want is a dill pickle!!
04:53:01 <dmhouse> Hi xerox.
04:53:20 <dmhouse> tony2: But what are you looking up or inserting if you're not using the values?
04:53:44 <tony2> dmhouse, just the set of keys.
04:53:52 <dmhouse> I don't understand.
04:54:05 <dmhouse> Looking up a value means grabbing the _value_ associated with a certain key.
04:54:17 <dmhouse> I.e. you have to know the key first!
04:54:24 <dmhouse> Similarly with insertion.
04:54:35 <xerox> This conversation seem weird :)
04:54:44 <tony2> I'm using it like a set I guess, with member and insert.
04:55:22 <dmhouse> xerox: we're discussing tony2's use of a Map without caring about what the values are (or even what the type of the values are).
04:56:18 <dmhouse> tony2: Data.Set has O(log n) insert and member.
04:58:19 <tony2> dmhouse, that would make sense, only I had already defined a serialising function for maps...
04:58:54 <dmhouse> tony2: Guess what? Set instantiates Show :) But not Read.
04:59:41 <tony2> haha, very good.
05:00:32 <xerox> Like Map, Set is one of those Show instances that doesn't Read.
05:01:28 <dmhouse> @type f (n+1) = n
05:01:29 <lambdabot> parse error on input `='
05:01:36 <dmhouse> @type let f (n+1) = n in f
05:01:37 <lambdabot> forall a. (Integral a) => a -> a
05:04:46 <Saimazoon> Good morning
05:04:53 <xerox> G'day Saimazoon.
05:15:25 <nomeata> can the same (upstream provided) binary work on ia64 and amd64?
05:15:34 <nomeata> it's labeled "i86_64"
05:17:09 <nomeata> ah, sorry, wrong channel
05:20:00 <dons> dmhouse: you wanted null types? data X
05:20:13 <dmhouse> dons: Yes, I'm reading the #
05:20:22 <dmhouse> 'History of Haskell' paper, and mentions those.
05:20:25 <xerox> Hey dons, did you read what I left for you yesterday?
05:20:36 <dmhouse> So I started wondering if there was already a type which gave you that.
05:20:43 <xerox> I should have ?told you.
05:20:49 <dmhouse> As all null types are identical up to names.
05:21:12 <xerox> ?type () :: ()
05:21:13 <lambdabot> () :: ()
05:21:44 <dmhouse> And, for example, we could have data Null; somewhere, then, e.g., type RealWorld = Null.
05:21:52 <dons> data X
05:21:52 <dons> main = let x = undefined :: X
05:22:04 <dmhouse> xerox: That's the unit, not null type. It has two values: () and _|_.
05:22:06 <dons> you can't build any valid of type X other than bottom
05:22:41 <dmhouse> dons: Right, hence 'null type'. Up to lifting, the type is empty.
05:22:46 <xerox> Null types only have bottom?
05:22:58 <xerox> ?hoogle Void
05:22:59 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
05:22:59 <lambdabot> System.Win32.Types.LPVOID :: type LPVOID
05:22:59 <lambdabot> System.Win32.Types.MbLPVOID :: type MbLPVOID
05:23:00 <dons> as in data RealWorld, in GHC.Base
05:23:07 <xerox> Maybe it was defined somewhere :-)
05:23:10 <dmhouse> xerox: Yes.
05:23:19 <dcoutts> xerox, every type in haskell is inhabited (due to geneeral recursion)
05:23:22 <xerox> By the way, do you have a good reading about bottoms?
05:23:47 <dcoutts> xerox, you can look at domain theory I suppose
05:24:02 <dcoutts> I did a course on that and found it enlightening
05:24:05 <dons> i suppose if we had user-defined unboxed types, things might get tricky
05:24:13 <dons> no bottoms there
05:24:17 <dmhouse> Yeah.
05:24:32 <dmhouse> Unboxed types are 'unlifted'. The process of adding a bottom to a type is 'lifting'.
05:24:49 <xerox> dmhouse - An online course?
05:24:53 <dcoutts> unboxed types have a bottom too, it's just identified with the bottom of any containing structure
05:25:16 <dons> mmm.
05:25:24 <dmhouse> dcoutts: Huh? i :: Int#; i = undefined. That doesn't typecheck, does it?
05:25:57 <dons> as a result of having to box the value eventually, dcoutts ?
05:26:02 <dmhouse> xerox: Nothing off the top of my head. I've just picked up what I know by reading various emails, papers, and bits of the GHC manual here an there.
05:26:20 <dons> so there's always a containing structure?
05:26:30 <dcoutts> dmhouse, mm, possibly the kinds don't work there, not sure, bt using recursion we can certainly make a bottom of type Int#
05:26:42 <dons> we can diverge, yeah
05:26:49 <dmhouse> Hrm.
05:27:05 <dmhouse> I don't understand. In what sense are unboxed types unlifted then?
05:27:11 <dons> we need a kind for terminating, unboxed types
05:27:16 <dcoutts> dons, yeah, not sure what the meaning of an unboxed thing at the top level is
05:27:23 <xerox> dmhouse - Oh, so your course was a proper one? I didn't think you were in university.
05:27:39 <dons> dcoutts: well, it's either used in something that ends back in main, or else its dead code
05:27:40 <dcoutts> dons, see epigram, they've got a non-termination monad to encapsulate that sort of thing
05:27:46 <dcoutts> dons, right
05:27:48 <dons> yep, that's what i was thinking of
05:27:53 <dons> epigram
05:27:56 <dmhouse> xerox: No, I haven't taken a course. Perhaps you're confusing me with dcoutts, who just said he took a course on domain theory?
05:27:58 <Philippa_> do they actually have that rather than it being a proposal now?
05:28:03 <xerox> Wooops.
05:28:10 <xerox> Too similar nicknames.
05:28:15 <dcoutts> Philippa_, not sure actually
05:28:16 <dmhouse> Too many nicks beginning with 'd'. :)
05:28:23 <dcoutts> heh :-)
05:28:27 <dons> would be useful to have more structure for our kinds, strict, always terminates, and so on. fun fun
05:29:56 <dmhouse> Hmm. Subkinds?
05:30:10 <xerox> dcoutts - Do you know of good lecture notes on the topic?
05:30:32 <dcoutts> xerox, not online ones, I attended a lecture course
05:31:06 <dons> xerox: you might want to read up on 'pure type systems'
05:31:15 <dons> that's a good underlying theory for all this stuff
05:31:26 <dons> there's an spj paper that might help lead into it
05:31:47 <xerox> I am really interested specifically in bottoms in this very moment.
05:32:13 <dons> oh my
05:32:28 <xerox> As an example of `strange rings', if you want. It sounds to me as the CS version of what we call paradoxes.
05:32:28 <dons> ah, here http://research.microsoft.com/~simonpj/Papers/henk.ps.gz
05:32:30 <dmhouse> @remember xerox I am really interested specifically in bottoms in this very moment.
05:32:30 <lambdabot> Done.
05:32:36 <xerox> Ouch.
05:32:41 <dmhouse> :)
05:32:42 <dons> but for bottoms, perhaps some of the early lazy programming work?
05:32:48 <dons> where the idea was first dicussed?
05:32:56 <dons> i'm sure the 'history of haskell' paper has some references for this
05:33:04 <xerox> Right! Will read.
05:33:48 <dons> if you want to really get a good mental framework for understanding all these type system modificatoins, and what they mean, the PTS work is important, I think
05:34:03 <Philippa_> xerox: bottoms denote paradoxes if you take the C-H view, yeah
05:34:32 <xerox> Great.
05:34:36 * xerox pats his intuition
05:35:24 <xerox> I've started reading that paper yesterday, dons, then I got carried away in the long night talking of paradoxes and intuition with monochrom and folks on #math - crazy stuff.
05:36:02 <dmhouse> Philippa_: I thought that was non-termination?
05:37:03 <xerox> Philippa_ - By the way, are you sure about that? Specifically, what do you mean by paradoxes in that phrae?
05:37:09 <xerox> *phrase
05:38:25 <dmhouse> I believe non-termination is isomorphic to logical inconsistency or contradictions, under the C-H view.
05:38:37 <xerox> That would make sense.
05:39:33 <Philippa_> dmhouse: bottom /is/ failure to terminate
05:39:54 <dmhouse> Philippa_: as well as, for example, runtime errors.
05:40:20 <Philippa_> which, IO aside, means pattern-match failure
05:40:25 <Philippa_> (running out of memory is an IO issue)
05:41:10 <Philippa_> there the paradox is having proven you can do something you can't
05:41:33 * sieni tries to find a novel way to scare xerox
05:41:37 <dmhouse> Or dividing by zero, etc.?
05:42:39 <Philippa_> div0 is effectively pattern-match failure
05:43:35 <dmhouse> But what about error in general? I think there's more to bottom than just pattern-match failure/
05:43:36 * xerox pokes sieni 
05:44:06 <dons> bottom in gofer was defined as pattern match failure
05:44:24 <Philippa_> error directly evaluates to bottom, yes. But you could reasonably write error xs = error xs and leave it there
05:44:26 <dons> undefined              :: a
05:44:27 <dons> undefined | False       = undefined
05:44:46 <dmhouse> dons: Does that work?
05:44:57 <xerox> Sure!
05:45:00 <dons> that's Gofer 2.30, 1994
05:45:01 <dmhouse> Does that give a runtime error, more to the point.
05:45:07 <Philippa_> yes, it causes a pattern-match failure
05:45:11 <dmhouse> Right.
05:45:32 <Philippa_> note that error messages *are IO artefacts*
05:45:44 <Philippa_> much as exceptions thrown from pure code are
05:46:21 <dons> oh, that's nice, subtract   = flip (-)
05:46:34 <dons> ghc has subtract x y = y - x
05:46:43 <dmhouse> dons: Yeah. (subtract 4) is how you do sections on binary minus.
05:47:04 <dons> sure, i'm just commenting on the ghc versus gofer implementation
05:47:09 <dons> gofer does some fun things
05:47:27 <dons> back in the day, when:
05:47:28 <dons> class Functor m => Monad m where
05:47:28 <dons>     result    :: a -> m a
05:47:28 <dons>     join      :: m (m a) -> m a
05:47:28 <dons>     bind      :: m a -> (a -> m b) -> m b
05:47:53 <dons> and the lovely
05:47:54 <dons> class (Functor f, Functor g) => NatTransf f g where
05:47:54 <dons>     eta :: f a -> g a
05:47:58 <dmhouse> I've never seen those names.
05:48:05 * xerox falls in love
05:48:05 <dons> (which I've actually used , eta)
05:48:15 <dmhouse> It's always been return/>>= as far as I can tell.
05:48:24 <xerox> dons - How does gofer check naturality of the transformation?
05:48:28 * xerox thinks it doesn't
05:48:32 <dons> it doesn't :)
05:48:34 <dons> (@@)             :: Monad m => (a -> m b) -> (c -> m a) -> (c -> m b)
05:48:34 <dons> f @@ g            = join . map f . g
05:48:38 <dons> interesting function
05:48:38 <xerox> Arf!
05:48:40 <Philippa_> dmhouse: gofer isn't haskell, and >>= wasn't in the earliest papers
05:48:48 <dons> it's almost haskell.
05:49:01 <dons> i used it as haskell in my first haskell course :)
05:49:04 <xerox> OK, let's bring in the squashfix notation dons.
05:49:08 <dmhouse> dons: map being fmap?
05:49:10 <Philippa_> yeah, I know the history :-)
05:49:15 <dons> ('cept I had to write my own instances, the haskell people could derive them)
05:49:44 <xerox> dons - I came to the conclusion it is a generalized fmap.
05:49:57 <dmhouse> Philippa_: ah, fun. I've read some papers which I thought were old, that came before the monadic comprehensions and used explicit binds and lambdas.
05:50:11 <xerox> ?type \f a -> a >>= \x -> f x
05:50:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
05:50:22 <xerox> ?type \f a b -> a >>= \x -> b >>= \y -> f x y
05:50:24 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
05:50:28 <xerox> ^- this is your squashfix
05:50:39 <dmhouse> xerox: Eta-reduce!
05:50:39 <xerox> ?type \f a b c -> a >>= \x -> b >>= \y -> c >>= \z -> f x y z
05:50:40 <lambdabot> forall a a1 (m :: * -> *) a2 b. (Monad m) => (a -> a1 -> a2 -> m b) -> m a -> m a1 -> m a2 -> m b
05:50:40 <xerox> ^- and so on.
05:50:48 <dons> asTypeOf               :: a -> a -> a
05:50:48 <dons> x `asTypeOf` _          = x
05:50:48 <dons> is hardly used now, we have lexically scoped tyvars
05:50:48 <dons> ah yes, I saw
05:50:48 <dons> very interesting!
05:50:54 <xerox> dmhouse - I'm showing the argument on purpose.
05:50:55 <dons> so its fmap3 fmap4 ... ?
05:51:04 <dmhouse> xerox: Okay then.
05:51:37 <dmhouse> dons: You generally don't need lexically scoped tyvars to replace asTypeOf, just a type signiture does okay.
05:51:50 <dons> yeah, or just tihngs like pattern sigs
05:52:01 <dmhouse> Will lexically scoped type variables be in Haskell'?
05:52:10 <dons> we use signatures, where the old school guys didn't see that's how it would be
05:52:21 <dons> yeah, i think so
05:52:29 <xerox> dons - Somehow, yes.
05:52:33 <dmhouse> They're going to become necessary when you consider all the funky new features that need type signitures.
05:52:42 <dons> who uses 'asTypeOf', anyone?
05:53:18 <dons> ok,
05:53:22 <dons> ?karma- asTypeOf
05:53:22 <lambdabot> asTypeOf's karma lowered to -1.
05:53:29 <dmhouse> I have once or twice, before I realised you can just use a type signiture in pretty much all scenarios.
05:53:40 <dmhouse> @spell signiture
05:53:41 <lambdabot> signature signatures signatory signore signature's
05:53:43 <dmhouse> Gah.
05:54:05 <xerox> dons, also, I tought: a >>= . b . c =<< d is like the action squashing the point "b" in the two direction of the uni-dimensional horizontal axis.
05:54:17 <dons> hmm
05:54:25 <xerox> dons, then, for fmapN, you could add dimensions and squash towards the origin more =<< :-)
05:54:36 <dons> maybe we should hack up the fmapNs
05:54:43 <dons> and see what can be written
05:54:49 <xerox> I tried but it seems like one needs variadic functions.
05:54:56 <xerox> I could be wrong, I was sleepy.
05:55:38 <dons> k, its a step forward
05:55:45 <dons> @localtime dons
05:55:48 <lambdabot> Local time for dons is Sat Jul 15 22:51:28 2006
05:55:55 <xerox> Or if you get a list of actions, you could fold some combinations of (>>=) and (.), I believe.
05:55:55 <dons> now i'm sleepy
05:56:00 <xerox> (-:
05:56:16 <greenrd> What's an alternative to partial application of a type synonym, since that isn't possible in haskell?
05:56:41 <xerox> Use newtype, I think.
05:56:55 <greenrd> yeah, but then I have two types for the same concept, which I really want to avoid
05:56:59 <dmhouse> greenrd: For example?
05:58:52 <greenrd> Well my code is quite complicated
05:59:00 <greenrd> I'm trying to model category theory in Haskell types
05:59:13 <greenrd> And I'm getting stuck on the identity morphism of a category
05:59:26 <dmhouse> What have you got so far?
06:00:12 <greenrd> It's fine if you restrict your attention to categories whose morphisms look like functions, but a completely general notion of category seems problematic
06:01:33 <greenrd> hmm, actually I just had an idea
06:03:44 <greenrd> never mind, that won't work
06:04:06 <dmhouse> Paste some code already :)
06:04:30 <greenrd> Well my code right now doesn't compile, and is as I say very complicated
06:04:34 <xerox> Another CT<->types project!
06:04:43 <greenrd> Oh, who else is doing it?
06:04:51 <xerox> esap.
06:04:57 <dmhouse> greenrd: That's okay.
06:04:58 <dmhouse> @paste
06:04:58 <lambdabot> http://paste.lisp.org/new/haskell
06:05:07 <xerox> He's going for a different approach, by the way.
06:05:12 <dmhouse> It's very hard to help when I have no idea what the code looks like.
06:05:16 <xerox> He's designing a language whose type system is CT.
06:05:36 <greenrd> ah
06:07:04 <dmhouse> Hehe. From the 'History of Haskell', regarding unsafePerformIO:
06:07:09 <dmhouse> It should probably have an even longer name, to discourage its use by beginners
06:07:50 <foxy_> @google "History of Haskell"
06:07:52 <lambdabot> http://www.haskell.org/haskell-history.html
06:07:52 <lambdabot> Title: The History of Haskell
06:08:10 <dmhouse> foxy_: http://haskell.org/haskellwiki/History_of_Haskell
06:08:11 <lambdabot> Title: History of Haskell - HaskellWiki
06:08:18 <lisppaste2> greenrd pasted "preprocessed category theory code" at http://paste.lisp.org/display/22638
06:09:01 <xerox> Booom.
06:09:55 <greenrd> heh
06:10:32 <greenrd> So I currently have newtype IdM1 a = IdM1 (Fn a a IdR)
06:11:01 <greenrd> which can be read as "newtype IdM1 a is a function from a to a whose postcondition is the identity relation"
06:11:28 <cedricshock> Library question: where can I find IO to get the size of a file? It doesn't appear to be in System.Directory, where should I be looking?
06:11:29 <greenrd> (the real point of this work is to simulate dependent types, so I'm modelling every value at the type level)
06:12:12 <greenrd> However, this newtype isn't satisfactory, because it means I'd have to add another branch to the GADT FnMor
06:12:28 <xerox> ?hoogle stat
06:12:28 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateInput :: State tok st -> [tok]
06:12:29 <lambdabot> Text.ParserCombinators.Parsec.Prim.statePos :: State tok st -> SourcePos
06:12:29 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateUser :: State tok st -> st
06:12:44 <xerox> ?hoogle Posix
06:12:44 <lambdabot> Text.Regex.Posix :: module
06:12:44 <lambdabot> System.Win32.File.fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
06:12:44 <lambdabot> System.Win32.File.sCS_POSIX_BINARY :: BinaryType
06:12:50 <xerox> Hmmm.
06:12:51 <greenrd> and every time I have to make another newtype like this, I'd have to add another branch
06:13:18 <greenrd> which not only means more redundant pattern-matching, it also is _totally_ non-modular
06:13:26 <greenrd> because another module cannot add a branch to a GADT
06:13:58 <dmhouse> cedricshock: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#10
06:14:34 <foxy_> greenrd, can't you simulate {dependent types}\{polymorphic types} using Dynamic?
06:15:14 <cedricshock> dmhouse: thanks
06:16:32 <greenrd> foxy_: I'm trying to do static typing - I don't see how Data.Dynamic would help here
06:17:00 <foxy_> @hoogle toDyn
06:17:00 <lambdabot> Data.Dynamic.toDyn :: Typeable a => a -> Dynamic
06:17:11 <foxy_> @hoogle Dynamic
06:17:12 <lambdabot> Data.Dynamic :: module
06:17:12 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
06:17:12 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
06:17:36 <greenrd> Well, obviously Haskell is still statically typed, even if you use Data.Dynamic
06:17:57 <greenrd> However, my point is I want to represent theorems as types and proofs as programs
06:18:09 <greenrd> and I don't see how Data.Dynamic helps with that
06:19:26 <foxy_> @hoogle typeOf
06:19:26 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
06:19:27 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
06:19:27 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
06:20:00 <foxy_> with typeOf you can get the type of an expression and use it as a value.
06:20:53 <greenrd> But I want to get the value of an expression and use it as a type.
06:21:00 <greenrd> I'm not sure that the two problems are related.
06:22:28 <greenrd> Well, obviously I don't mean "get the value" in the dynamic sense
06:22:52 <greenrd> I just mean, I want types to represent values at arbitrary levels of granularity, down to individual values if required
06:23:43 <greenrd> The thought has occured to me that dependent types are too hard for this kind of thing, and that I should use a theorem prover instead.
06:23:52 <greenrd> However, I'm just experimenting.
06:24:06 <xerox> Or extend Haskell :-)
06:24:19 <greenrd> well that thought has occurred to me as well
06:24:26 <greenrd> in fact that was my original approach
06:24:52 <greenrd> but I was hoping that Haskell + GHC extensions is enough to do it - GADTs certainly look promising
06:24:55 <foxy_> can you give a small concrete example of using a value as a type?
06:25:13 <greenrd> Well you don't actually use a value as a type, you can't in Haskell
06:25:20 <greenrd> But you use a representation of a value as a type
06:25:42 <greenrd> data True = True; data False = False
06:25:58 <greenrd> class Bool b where blah blah
06:26:06 <greenrd> instance Bool True; instance Bool False
06:27:22 <xerox> How does "the representation of a value as a type" differ from "a type" ?
06:27:41 <greenrd> Well you can't say, in Haskell, foo :: 1 -> 0
06:27:47 <greenrd> Because you can't put values in types
06:27:52 <greenrd> That's what I'm getting at
06:28:13 <greenrd> You have to model the value as a type, instead of using it directly
06:28:25 <_Codex> greenrd: 1 would be one-element set?
06:28:42 <greenrd> This is confused slightly by the fact that in my example of True False and Bool, True is both the name of a value and the name of a type
06:29:08 <greenrd> _Codex: Correct, like True
06:29:31 <xerox> And 0 the Null type?
06:29:40 <greenrd> No, it would also be a one-element type
06:29:44 <_Codex> so, Bool would be 2?
06:29:57 <xerox> Still I can't understand "put value in types".
06:30:21 <greenrd> _Codex: no
06:31:02 <_Codex> greenrd: I was thinking you count the number of elements? :)
06:31:30 <greenrd> xerox: The standard example of why you would want to put values in types, is a dependently typed list function. Let's say head.
06:32:29 <xerox> What does it mean? head takes one element out of a list, returning it.
06:33:05 <greenrd> xerox: Suppose we have data Zero = Zero; data (Nat n) => S n = S n; instance Nat Zero; instance Nat (S n); class Nat where ...
06:33:21 <greenrd> oops, class Nat n where ...
06:33:52 <greenrd> Then we could say something like head :: List a (S n) -> a
06:34:03 <dmhouse> xerox: The end product is going to be a type-safe head. I.e. calling head on an empty list will be a compile-time error.
06:34:04 <greenrd> And this would prevent the programmer from passing an empty list as an argument to head
06:34:36 <greenrd> In fact this is easy to do in Haskell.
06:35:07 <dmhouse> This is described in the paper, 'Putting the Curry-Howard isomorphism to work'.
06:35:17 <dmhouse> You need extensible kinds and GADTs.
06:35:19 <dmhouse> Then,
06:35:20 <greenrd> Extending this idea to _every_ value and _every_ function, and trying to bring in category theory at the same time - that's a bit more of a challenge ;)
06:35:39 <greenrd> (That's redundant, of course, every function _is_ a value)
06:35:42 <dmhouse> data List a n where Nil :: List a Z; Cons :: a -> List a n -> List a (S n);
06:35:53 <dmhouse> Sorry, I meant:
06:36:05 <dmhouse> data List a (n::NatK) where Nil :: List a Z; Cons :: a -> List a n -> List a (S n);
06:36:13 <dmhouse> where NatK is the kind of natural numbers.
06:36:24 <AtnNn> how do you do that if you don't know that a list is headless at compile time?
06:37:02 <greenrd> AtnNn: That's the point. The type of head means you have to infer that the list has a head.
06:37:15 <greenrd> AtnNn: If you can't, you simply can't use head.
06:37:21 <AtnNn> i see
06:37:30 <greenrd> AtnNn: You'd have to use something else, like a maybeHead function which returns Maybe a, for example
06:37:33 <dmhouse> This is actually really useful for proving various invariants.
06:37:35 <dmhouse> For example,
06:37:56 <dmhouse> map :: (a -> b) -> List a n -> List b n, and you've just proven map doesn't change the length of the list.
06:38:26 <_Codex> few days ago esap showed an example of a stack which solves the same problem by returning id.
06:39:07 <_Codex> I mean, popping element from empty stack returned id.
06:39:08 <greenrd> eh?
06:39:14 <greenrd> That doesn't solve the same problem.
06:39:39 <greenrd> The problem I'm trying to solve is "Programmer must not be _allowed_ to pop an element from an empty stack".
06:40:14 <greenrd> Except via maybePop and things like that
06:40:24 <dmhouse> The whole point of a type system is to catch run-time errors at compile-time.
06:40:51 <dmhouse> This is just making the type system more expressive, so that things that have traditionally been run-time errors become compile-time.
06:41:03 <dmhouse> E.g. popping from an empty stack, accessing an array outside of its bounds, etc.
06:42:16 <foxy_> @paste
06:42:16 <lambdabot> http://paste.lisp.org/new/haskell
06:43:57 <lisppaste2> foxy pasted "using typeable " at http://paste.lisp.org/display/22639
06:44:19 <foxy_> greenrd, is this (points to paste) anything like what you're trying to do?
06:44:57 <greenrd> No
06:45:28 <greenrd> Your test function isn't even a total function, so it would be rejected under my system
06:46:11 <greenrd> (I have ghc set to error on incomplete pattern matching)
06:47:29 <greenrd> I really think Typeable is for the opposite problem - making code more dynamic
06:47:37 <greenrd> whereas I want to write code which is more statically-checked
06:47:59 <foxy_> but typeOf takes a value and constructs a type representation?
06:49:11 <greenrd> A value representation of a type, I think
06:49:18 <greenrd> I need type representations of values.
06:49:32 <lisppaste2> foxy annotated #22639 with "test is total now (I think)" at http://paste.lisp.org/display/22639#1
06:50:08 <greenrd> ok yes, that's total
06:50:15 <greenrd> but that's still not anything like what I want
06:50:47 <pesco> Anybody here with any involvement in the process of proposing a new system for importing from packages in GHC (http://cvs.haskell.org/trac/ghc/wiki/GhcPackages)
06:50:49 <lambdabot> Title: GhcPackages - GHC - Trac
06:50:50 <pesco> ?
06:51:08 <foxy_> in the instance declaration it is the _value_ of the argument which determines the type tag it gets...
06:51:35 <dmhouse> pesco: I've read the thread, why?
06:52:01 <pesco> I'm thinking of a different way to solve the problem.
06:52:23 <pesco> dmhouse: Are you familiar with the "extended proposal" (http://cvs.haskell.org/trac/ghc/wiki/GhcPackageNamespaces)?
06:52:26 <greenrd> foxy_: Yes, but I don't see how this helps me
06:53:14 <dmhouse> pesco: No, not really.
06:53:27 <dmhouse> pesco: I would encourage you to write down your thoughts in a wiki page, though.
06:53:32 <pesco> It references an email by Frederik Eaton (http://www.haskell.org/pipermail/libraries/2005-June/004009.html) where he calls for something like "mounting" packages in the module hierarchy and relieving module writers from the burden of typing in big package/hierarchy prefixes in they import statements.
06:53:33 <lambdabot> Title: rfc: package mounting
06:53:38 <greenrd> dmhouse: Any ideas about my original type synonym q? ;)
06:54:16 <pesco> dmhouse: Okay, then my next question is, which wiki is appropriate, GHC or Cabal? My solution would be implementable purely within Cabal (I think).
06:54:18 <dmhouse> greenrd: I never did get round to looking at your paste. :) Hold on.
06:54:33 <pesco> It would be very much like what Frederik wants, AFAICT.
06:54:59 <pesco> .oO(Probably Cabal, and link to it from the GHC wiki?)
06:55:03 <greenrd> The trouble is, I don't know in general how a category will choose to represent its morphisms
06:55:07 <pesco> cptchaos: Moin. :)
06:55:27 <greenrd> Some categories have morphisms with "more structure" than others
06:55:55 <dmhouse> greenrd: Okay, what am I looking at? Which part of that file
06:55:56 <dmhouse> ?
06:56:06 <greenrd> at the bottom there is a newtype
06:56:56 <dmhouse> Right.
06:57:10 <greenrd> If I make this just a type synonym, the type synonym DthUniverse (the category of all Haskell types) becomes an illegal type synonym declaration.
06:58:00 <greenrd> Because then IdM1 is partially applied, and type synonyms cannot be partially applied in that context
06:58:59 <greenrd> And SPJ says this will not be changed soon: http://cvs.haskell.org/trac/ghc/ticket/785
06:59:01 <lambdabot> Title: #785 (Allow partial application of type synonyms) - GHC - Trac
07:01:21 <dmhouse> greenrd: Does it work at the moment?
07:01:26 <greenrd> no
07:01:28 <greenrd> It doesn't help if I change DthUniverse into a data type
07:02:10 <greenrd> It doesn't work at the moment because IdM1 is not a valid type argument to FnMor, which is the type constructor for morphisms in the DthUniverse category
07:02:32 <greenrd> Now, I could add IdM1 as a branch to FnMor (which is a GADT) but this is not very satisfactory
07:03:11 <dmhouse> greenrd: Sorry, this is a bit over my head if I'm honest. I'd try posting to the mailing list with some cut-down code illustrating the problem.
07:03:32 <greenrd> because then not only would I have more pattern matching work to do, I'd have to keep on adding branches whenever I hit this type of problem
07:03:40 <greenrd> ok
07:07:02 <Philippa_> greenrd: the partially applied synonyms thing's been known a long time, I'm not surprised Bulat complained /anyway/ though
07:07:34 <phas> I'm trying to use HaskellNet for sending an email with SMTP, everithing seems to work fine but i cannot receive the mail
07:08:12 <phas> maybe is due to the "data" field which i don't know how to compile correctly
07:10:06 <greenrd> Maybe I could get away with shoehorning every category into the same mould, so that each categories morphisms had to look like functions
07:10:14 * dcoutts wonders if he should upgrade his 1.8GHz amd64 to a dual core 2.0GHz amd64 for 139.95
07:11:45 <greenrd> *category's
07:15:00 <esap> That would be overly restrictive, I think. A definition of a concrete category should include information about what kind of objects and arrows exist, and their structure.
07:18:33 <xerox> Howdy esap :-)
07:18:38 <esap> Hi
07:18:51 <xerox> How's CT?
07:19:25 <esap> I just found out there is a dual to an adjunction.
07:19:41 <xerox> How's it called?
07:19:46 <xerox> coadjunction? :-)
07:20:08 <esap> something like that. It's described in a paper at http://www.cs.man.ac.uk/~pt/domains/limccc.pdf
07:20:51 <esap> "F is co-left adjoint to G"
07:20:59 <DukeDave> Hey guys, does the (+) function belong to a class?
07:21:31 <DukeDave> I have defined a Fraction type and which to be able to add them
07:21:32 <_Codex> duke: Num
07:21:58 <DukeDave> excellent- cheers
07:22:33 <esap> xerox: it's at page 13
07:23:06 <ndm> dcoutts, you should give me the money, so I can upgrade my AMD 750 to _anything_
07:23:59 <dmhouse> DukeDave:
07:24:03 <dmhouse> @type (+)
07:24:05 <lambdabot> forall a. (Num a) => a -> a -> a
07:24:21 <DukeDave> good tip :)
07:24:23 <dmhouse> Because of that Num constraint, you might guess that it belongs to Num.
07:24:38 <dmhouse> To check that, you go into GHCi and hit ':i Num', which gives you Num's methos.
07:24:39 <dmhouse> *methods
07:24:50 <dmhouse> DukeDave: are you aware that there already exist Fraction types?
07:26:04 <DukeDave> yeah, unfortunately I have slightly different needs, am working on this:
07:26:15 <DukeDave> http://www.ecmselection.co.uk/high_iq_enter_and_win/brainbuster_no_20.html
07:26:16 <lambdabot> Title: ecm selection ... high-tech recruitment specialists brainbuster no. 20
07:26:32 <DukeDave> seemed like a good excuse to practise some haskell :)
07:26:50 <xerox> esap - Maybe after Sets for Mathematics I will be able to go as far as page 13 :-)
07:27:57 <astrolabe> Inventing new types seems a bit over the top for that.
07:28:01 <esap> xerox: heh, well actually I skipped some of the discussion about fibrations since I didn't understand it...
07:28:21 <dmhouse> DukeDave: Cool. I'd still use Rational for that, but okay. :)
07:28:41 <DukeDave> Rational? :)
07:29:18 <astrolabe> I'd just use Int
07:29:28 * astrolabe is boring
07:29:48 <xerox> esap - I was considering using Barr and Wells lecture notes for starting, what do you think?
07:29:56 <dmhouse> DukeDave: Yeah.
07:29:59 <dmhouse> @hoogle Rational
07:30:00 <lambdabot> Prelude.Rational :: type Rational
07:30:00 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
07:30:00 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
07:30:19 <dmhouse> type Rational = Ratio Integer, i.e. a ratio of integers to integers.
07:30:47 * esap goes and fetches lecture notes from http://www.let.uu.nl/esslli/Courses/barr/barrwells.ps, is this it?
07:30:56 <xerox> esap - I think so, yes.
07:31:28 <dcoutts> ndm, heh :-)
07:31:31 <DukeDave> Gotcha
07:31:42 <vincenz> hi
07:32:00 <dcoutts> ndm, you can have the old one, but you'd need a new mobo
07:32:14 <esap> xerox: Looks like the basic category theory stuff that is provided as intro in all category theory books
07:32:18 <ndm> dcoutts, i'm too lazy to upgrade, too much stuff on my old hard drive
07:32:25 <ndm> and too lazy to move a hard drive...
07:32:34 <dcoutts> no, you keep the hard drive
07:32:40 <dcoutts> just change motherboard & cpu
07:32:46 <dcoutts> it's not that hard
07:32:49 <ndm> i don't do well with electrical stuff
07:32:56 <DukeDave> do I correctly remember there is some way (using @ ?)  to expand a type within a where clause ?
07:32:57 <xerox> esap - How does it seems if I try to work out this first and get into a book afterwards?
07:33:15 <ndm> i blew up 6 Z80's and 8 analogue to digital convertors in my undergrad
07:33:18 <dmhouse> DukeDave: Like this?
07:33:26 <ndm> i have "power vs ground" issues
07:33:28 <dcoutts> ndm, that's impressive :-)
07:33:34 <dmhouse> > let all@(x:xs) = [1..5] in (x, xs, all)
07:33:35 <lambdabot>  (1,[2,3,4,5],[1,2,3,4,5])
07:33:43 <ndm> i know, i am sure i would have done more a to d convertors, but hte department ran out
07:33:58 * DukeDave tries to digest 
07:34:26 <dcoutts> ndm, I once bust some memory and maybe the whole mobo by inserting the memory the wrong way round in the slot (which should be impossible since the notch is offset)
07:34:50 <esap> xerox: I suppose it's ok. Maybe you should consider some additional intro material as well, say, Goguen's Categorical Manifesto. The "Sets for mathematics" is better than any intro you'll find on the net though.
07:34:50 <ndm> dcoutts, is that why you are considering upgrading all of a sudden?
07:35:00 <dmhouse> DukeDave: another example?
07:35:05 <dcoutts> ndm, the only tricky aspect of building machines these days is securing the heatsink
07:35:16 <dmhouse> > let v@(Just _) = Just 4 in v
07:35:16 <DukeDave> may one use it the other way round? eg..
07:35:17 <lambdabot>  Just 4
07:35:22 <dcoutts> ndm, no, that was some time ago, it works fine atm
07:35:28 <xerox> esap - How far does SfM go with respect of other possibilities?
07:35:34 <xerox> If there are any.
07:35:43 <esap> xerox: "other possibilities"?
07:35:53 <xerox> Other books or online resources.
07:35:58 <DukeDave> ... I'll pastebin an example :)
07:36:01 <dcoutts> ndm, I've wanted a smp machine for ages, but they were so expensive, dual core makes that cheap
07:36:09 <DukeDave> I see how it is being used there
07:36:12 <dcoutts> comparatively cheap
07:36:22 * xerox nods
07:36:28 <ndm> indeed, my machine at work is HT, and thats pretty useless
07:37:02 * dcoutts heads into the office
07:37:27 <xerox> Mine is a Yonah chip. Quite performing.
07:37:30 <esap> xerox: It describes the basic concepts. The last important issue that it had was  how to use adjunctions to build the Set category from just the Hom-functor and assumptions of adjunctions.
07:37:43 <foxy_> @hoogle unsafeCoerce#
07:37:44 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
07:38:00 <foxy_> @hoogle unsafeCoerce
07:38:00 <lambdabot> No matches found
07:38:18 <xerox> esap - `issue' in the `topic' sense?
07:38:27 <esap> xerox: The focus of SfM is on describing how Set theory concepts map to category theory ones. This is very useful in practice
07:38:33 <esap> xerox: yes
07:38:43 <xerox> OK, I understand.
07:38:56 <ndm> foxy_: hoogle doesn't index GHC specific stuff
07:39:09 <esap> xerox: It's pretty hard to find that kind of information from papers, because that information is scattered all around the web...
07:39:14 <foxy_> OH, anyone know where that function is found?
07:40:27 <dmhouse> @index unsafeCoerce#
07:40:27 <lambdabot> bzzt
07:40:49 <esap> xerox: Have you read through the part of SfM that is available at the author's website?
07:41:01 <xerox> esap - Not yet.
07:41:04 * xerox heads to the site
07:41:14 <esap> xerox: http://www.mta.ca/~rrosebru/setsformath/
07:41:16 <lambdabot> Title: SETS FOR MATHEMATICS by F. WILLIAM LAWVERE AND ROBERT ROSEBRUGH
07:41:40 <esap> xerox: the sample chapter I mean
07:41:44 <lisppaste2> DukeDave pasted "Expanding types" at http://paste.lisp.org/display/22643
07:41:51 * Philippa_ read the paper on n-categories that franka linked to on LtU and grinned when it said 0-categories are sets
07:42:25 <dmhouse> DukeDave: That's just standard pattern matching.
07:42:25 <DukeDave> dmhouse, this is a trivial example... also, thanks for your time!
07:43:26 <lisppaste2> dmhouse annotated #22643 with "pattern matching" at http://paste.lisp.org/display/22643#1
07:43:33 <dmhouse> DukeDave: ^^, and no problem. :)
07:43:58 <DukeDave> righty
07:44:06 <DukeDave> lol, I think I am confusing myself
07:44:12 <astrolabe> Are recent channel logs stored anywhere?
07:44:13 <DukeDave> that does make perfect sense :)
07:44:41 <dmhouse> astrolabe: meme.b9.org
07:44:49 <astrolabe> thanks
07:44:52 <dmhouse> astrolabe: /topic :)
07:45:05 <dmhouse> It lists the tunes logs, but the meme ones are nicer.
07:45:35 <astrolabe> the topic is too long for me to read with my setup.
07:47:38 <astrolabe> I don't know how to find 'meme.b9.org'.  I feel stupid :(
07:48:08 <int-e> /whois cmeme
07:48:09 <int-e> :)
07:48:21 <dmhouse> Oh, sorry, .com
07:48:43 <dmhouse> meme.b9.com/cview.html?channel=haskell
07:48:58 <dmhouse> Never mind, that doesn't work.
07:49:08 <int-e> http://meme.b9.com/cview.html?channel=haskell&date=today
07:49:09 <int-e> does
07:49:10 <lambdabot> Title: Meme haskell IRC Log 2006/07/15
07:49:11 <lmbdwr> lo
07:49:13 <dmhouse> http://meme.b9.com/cdates.html?channel=haskell
07:49:17 <lambdabot> Title: Meme Channel haskell by Dates
07:49:20 <dmhouse> That's what I wanted.
07:49:23 <dmhouse> Hi lmbdwr.
07:49:28 <astrolabe> thanks
07:49:32 <lmbdwr> anyone has good references to propose for lambda-mu-mu calculus ?
07:50:10 <lmbdwr> only one I found was "Strong normalization of ? -calculus with explicit substitutions" and "Strong normalization of lambda-bar-mu-mu-tilde-calculus with explicit substitutions"
07:51:22 <esap> lmbdwr: lambda-mu-mu calculus? What's that?
07:51:59 <int-e> is that #haskell get-together poll still relevant? it was for may or june ...
07:52:05 <ibid> lambda calculus with a fixpoint operator?
07:52:45 <xerox> int-e - franka said he hardly was willing to organize it now
07:52:54 <xerox> ?wiki AngloHaskell sounds promising
07:52:54 <lambdabot> http://www.haskell.org/haskellwiki/AngloHaskell sounds promising
07:53:25 <int-e> @where logs
07:53:25 <lambdabot> http://tunes.org/~nef/logs/haskell/
07:54:18 <dmhouse> ibid: You can define Y in the untyped LC, so I guess it's some kind of typed calculus.
07:55:21 <xerox> (He said so in #haskell-blah.)
07:55:30 <ibid> dmhouse: my thoughts exactly
07:55:46 --- topic: set to '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "@where logs", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]' by int-e
07:56:09 * esap found http://web.cs.wpi.edu/~dd/publications/entcs05-ITRS.pdf about lambda-mu-mu calculus.
07:56:10 <xerox> int-e - Why did you change it?
07:56:11 <dmhouse> Really that should be a list of pairs.
07:56:13 <int-e> still far too long, but least it's all more or less recent.
07:56:17 <ibid> hrm, irssi's topic-diff does not handle the haskell topic proprerly :)
07:56:19 <xerox> If lambdabot is down, no logs' url.
07:56:38 <int-e> @where logs
07:56:38 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
07:56:53 <Philippa_> ibid: presumably (given two mus) fixpoints at both term and type level?
07:58:02 <int-e> I can change that back. I mainly wanted to remove that poll thingy.
07:58:37 --- topic: set to '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]' by int-e
07:58:41 * int-e shrugs.
08:01:16 <dcoutts_> @yarr!
08:01:17 <lambdabot> This is the END for you, you gutter-crawling cur!
08:01:42 <ndm> dmhouse: i'm rewritting the docs for System.FilePath, using all your additions to make tests
08:01:52 <dmhouse> ndm: Good good.
08:14:03 <Cale> This guitar is insane :) http://en.wikipedia.org/wiki/Image:Pikasso_I.jpg
08:14:32 <xerox> Man! :)
08:23:02 <ndm> I have a 360 line file, and GHC runs out of memory trying to load it in GHCi :(
08:24:09 <ndm> 19Kb as well, a tiny little thing
08:25:30 <int-e> > 19000/360
08:25:31 <lambdabot>  52.77777777777778
08:38:38 <lisppaste2> dukedave pasted "Some horrible code" at http://paste.lisp.org/display/22644
08:39:00 <DukeDave> if anyones bored - comments / critism welcome
08:39:36 <DukeDave> I'm having a lot of difficulty instilling elegance into my definitions   *_*
08:40:31 <dcoutts_> DukeDave, the indenting is all over the place, improving that would help :-)
08:40:42 <dmhouse> DukeDave: weeeird layout.
08:41:16 <DukeDave> ah, yeah, I just noticed that - it looks okay in Vim :)
08:41:16 <dmhouse> Ah. You use tabs. Don't.
08:41:59 <dcoutts_> DukeDave, for Ord you could just define < rather than compare
08:42:18 <DukeDave> the pastebin seems to convert the tabs to spaces :o
08:42:31 <dcoutts_> and use pattern matching in the function definition rather a seperate where clause
08:43:19 <dcoutts_> (Frac n1 d1) < (Frac n2 d2) = n1 * denom d2 < n2 * denom d1
08:43:35 <lisppaste2> dmhouse annotated #22644 with "indentation cleaned up" at http://paste.lisp.org/display/22644#1
08:43:46 <dcoutts_> that's a 1-liner rather than your current 9 lines
08:44:29 <dcoutts_> it's more common to say: denom (d1, d2) = d1 * 10 + d2; than denom = (\(d1, d2) -> (d1 * 10) + d2)
08:45:12 <foxy_> @pl  (\(a,b) -> (a * 10) + b)
08:45:12 <lambdabot> uncurry ((+) . (10 *))
08:45:22 <DukeDave> good tips guys :)
08:45:59 <lisppaste2> dmhouse annotated #22644 with "better Ord instance" at http://paste.lisp.org/display/22644#2
08:47:02 <dmhouse> Oh, I got the patterns slightly wrong. Never mind.
08:47:05 <foxy_> @djinn a -> b
08:47:05 <lambdabot> -- f cannot be realized.
08:47:20 <foxy_> @karma- djinn
08:47:20 <lambdabot> djinn's karma lowered to -1.
08:48:37 <DukeDave> now that's elegant(tm)  ;)
08:49:09 <dcoutts_> yeah, that's a lot better
08:49:11 * DukeDave sets mode +must_not_give_up
08:49:50 <dcoutts_> you know you can use: n1' `compare` n2' if you think that reads better
08:50:35 <foxy_> DukeDave, I'd put the type declarations before the data declarations
08:50:38 * foxy_ shrugs
08:50:50 <foxy_> since you use them in that order
08:52:08 <DukeDave> I'm still enjoying the novelty of not having to be procedural :)
08:52:39 <DukeDave> one, additional note: the double definition of
08:52:49 <DukeDave>    where n1' = n1 * denom d2;         n2' = n2 * denom d1
08:53:13 <DukeDave> is there a sane way to wrap that up into one expr ?
08:53:55 <dmhouse> Not really, it's fine as it is.
08:53:59 <foxy_> @djinn (a,a) -> a -> a -> a
08:53:59 <lambdabot> f _ _ a = a
08:54:07 <dmhouse> You might want to stick it into a function if you use it more than once, though.
08:54:16 <foxy_> @hoogle curry
08:54:17 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
08:54:17 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
08:55:14 <foxy_> uncurry $ compare $ foo a b
08:55:30 <foxy_> define foo a b to be your help function returning a tuple ?
08:55:52 <dmhouse> foxy_: Eww.
08:56:23 <dmhouse> foxy_: By the way, you probably want uncurry compare $ foo a b.
08:56:39 <foxy_> ok
08:57:05 <dmhouse> Otherwise you'll do the comparing first, then feed the LT, GT or EQ into uncurry, probably not what you want :)
08:57:21 <yaxu> I'm getting strange results from System.Time.diffClockTimes
08:57:38 <dmhouse> yaxu: That's because it's a strange function.
08:57:40 <foxy_> foo (Frac n1 d1) (Frac n2 d2) = (n1 * denom d2,n2 * denom d1)
08:57:43 <yaxu> in particular tdPicoSec is often in minus figures
08:57:51 <dmhouse> yaxu: You have to normalizeClockTime or whatever after calling it
08:58:02 <yaxu> dmhouse: ah thanks, will look at that
08:58:06 <dmhouse> foxy_: He said a sane way of doing it.
08:58:15 <dmhouse> yaxu: It's a pretty rubbish function, TBH.
08:58:45 <foxy_> dmhouse, huh?
08:59:01 <foxy_> you mean just using where clauses?
08:59:06 <dmhouse> foxy_: yeah.
08:59:17 <dmhouse> Your way would work, but it's a bit esoteric.
08:59:22 <ndm> does anyone know how I can get quickCheck to go BANG if it fails?
08:59:23 <foxy_> @localtime foxy_
08:59:24 <lambdabot> Local time for foxy_ is Sunday, 16 July 2006 3:59:11 a.m.
08:59:27 <yaxu> dmhouse: can i just add tdSec to (tdPicosec / 1 000 000 000 000) and expect good results?
08:59:29 <ndm> rather than just giving me back IO ()
08:59:41 * foxy_ <- is at an esoteric time of day
08:59:42 <yaxu> well i'll read the manual first
08:59:48 <sjanssen> does Chris Kuklewicz (the guy behind TextRegexLazy) ever hang out here?
09:00:06 <dmhouse> yaxu: I'm not sure what you mean.
09:00:41 <foxy_> System.Time.diffClockTimes
09:00:53 <yaxu> dmhouse: i mean convert pico seconds to seconds then add to seconds
09:01:11 <yaxu> i will just read the manual though :)
09:01:19 <foxy_> @hoodle fail
09:01:20 <lambdabot> Prelude.fail :: Monad m => String -> m a
09:01:20 <lambdabot> System.Win32.Types.failIf :: (a -> Bool) -> String -> IO a -> IO a
09:01:20 <lambdabot> System.Win32.Types.failIfFalse_ :: String -> IO Bool -> IO ()
09:01:24 <dmhouse> yaxu: Oh, right, perhaps, I'm not sure.
09:01:36 <dmhouse> yaxu: Be sure to look at the source too, I remember that being illustrative.
09:02:11 <yaxu> ok ta
09:03:58 * yaxu spots "-- FIXME: handle psecs properly"
09:03:58 <foxy_> @hoogle evaluate
09:03:59 <lambdabot> Control.Exception.evaluate :: a -> IO a
09:03:59 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
09:04:46 <foxy_> ndm, would using Test.QuickCheck.evaluate help?
09:05:02 <ndm> foxy_: if it wasn't inside a Gen monad...
09:06:10 <yaxu> maybe the problem is due to the earth's spin not being regular enough
09:06:26 <ndm> i think i have it now - basically copy half the code out of QuickCheck and tweak it
09:06:46 <Buzzons> hey, is data ListInt = Nil  -- the empty list
09:06:46 <Buzzons>              | Cons Int ListInt  -- non-empty list with first element and rest list
09:06:46 <Buzzons>   deriving (Show,Eq,Ord)
09:06:48 <Buzzons> and
09:06:55 <Buzzons> data ListInt = Nil | [Int] deriving (Show,Eq,Ord)
09:06:56 <Buzzons> the same?
09:07:21 <Buzzons> if not, why not.
09:07:34 <foxy_> you can't have the latter, it lacks a data constructor
09:07:34 <sjanssen> Buzzons: they're slightly different
09:07:47 <dmhouse> Buzzons: the first one is the same as type ListInt = [Int].
09:08:07 <dmhouse> (Apart from Nil and Cons are called [] and (:) for Haskell []-lists.)
09:08:22 <sjanssen> let's correct the second defn. "data ListInt = Nil | List [Int]"
09:08:30 <Buzzons> ah right
09:08:36 <dmhouse> Buzzons: but as foxy_ said, the second one won't work, because you need a constructor in front of the [Int], like sjanssen added/
09:08:59 <Buzzons> so the Cons is the constructor i see.
09:08:59 <sjanssen> the second defn. has two ways to define an empty list: Nil or List []
09:09:39 <dmhouse> Right. data ListInt = Nil | Cons Int ListInt and type ListInt = [Int] are the same.
09:09:50 <Buzzons> why do you add "type" to the front of that?
09:09:52 <Buzzons> not "data"
09:09:57 <dmhouse> (Note that you don't need constructors with type.)
09:10:01 <monochrom> type synonyms
09:10:03 <dmhouse> They're different constructs.
09:10:20 <yaxu> dmhouse: yep adding them looks like the right thing for me
09:10:30 <jgrimes> how would one convert from Int to Word8?
09:10:36 <dmhouse> type declares a 'type synonym'. Here, ListInt and [Int] would be (almost) completely indisguinshible - wherever you used one you could use the other.
09:10:40 <dmhouse> jgrimes: fromIntegral
09:10:47 <Buzzons> could you have... data ListInt = Nil | ([Int]:ListInt)
09:10:47 <Buzzons> ?
09:10:48 <sjanssen> > fromIntegral (0 :: Word8) :: Int
09:10:53 <lambdabot>  0
09:10:56 <jgrimes> dmhouse, ah, there we go, thanks
09:10:56 <dcoutts_> ndm, nice bug report on ghc's O(n^2) behaviour on do blocks
09:11:00 <dmhouse> Buzzons: What do you mean
09:11:14 <ndm> dcoutts_, yep, hopefully they'll fix it - but have worked around it for now
09:11:17 <Buzzons> insteady of ListInt = Nil | List [Int]
09:11:18 <dmhouse> Buzzons: Could you describe what you're trying to achieve?
09:11:30 <Buzzons> im just trying to work out the differences between using Cons and not using Cons
09:11:46 <ndm> I think its a memory issue, which is impacting on the time, but not sure
09:11:53 <SamB> but:
09:11:54 <monochrom> not using Cons => syntax error
09:12:13 <Buzzons> yet i can use List [Int] isntead?
09:12:18 <SamB> data [a] = [] | a : [a]
09:12:27 <dmhouse> Buzzons: I think you don't quite grasp the concept of a datatype.
09:12:33 <Buzzons> maybe so.
09:12:39 <monochrom> Correction.  Not using a constructor => syntax error.
09:12:56 <dmhouse> Buzzons: data X = Y | Z. Y and Z are 'constructors' for the datatype 'X'. X is a type.
09:13:12 <monochrom> If you write "Cons ...", Cons is the anticipated constructor.  If you write "List ...", List is the anticipated constructor.
09:13:24 <dmhouse> Buzzons: Y and Z are just values of the type X. I.e. Y :: X and Z :: X. They're how you construct values of type X.
09:13:25 <Buzzons> ah right
09:13:52 <monochrom> Nil is also a constructor.
09:14:11 <dmhouse> Buzzons: data X a = Y | Z a; Y and Z are still constructors, but now Z is a function that you give an a and it constructs the X. Y :: a, Z :: a -> X a.
09:14:14 <Buzzons> so is it better to use " data ListInt = Nil | List [Int] " or the one with Cons in?
09:14:30 <monochrom> The latter.
09:14:42 <dmhouse> There's no difference between  data ListInt = Nil | List [Int]  and   data ListInt = Nil | Cons [Int].
09:14:50 <Buzzons> very true
09:14:56 <monochrom> The best is not to re-invent the list, but nevermind.
09:14:58 <dmhouse> Apart from with the second one, you're defining a constructor named 'Cons' instead of 'List'. That's all.
09:15:17 <sjanssen> Buzzons: the best thing to use is "newtype ListInt = List [Int]"
09:15:18 <dmhouse> Buzzons: Anyway, 'type' is a whole different beast. It just declares one type to be the same as another.
09:15:35 <dmhouse> Buzzons: As Haskell already has a built-in list type, type IntList = [Int] is the best solution.
09:15:48 <Buzzons> but one one you have " Cons Int ListInt " and the other you have " Linst [Int]"
09:15:54 <sjanssen> there is no reason to have a constructor for Nil because lists already have one
09:15:57 <Buzzons> s/Linst/List
09:16:26 <dmhouse> Okay:
09:16:31 <dmhouse> There are two options available here.
09:16:48 <dmhouse> Either we do data IntList = Nil | Cons Int IntList, or we do type IntList = [Int].
09:17:13 <dmhouse> data IntList = Nil | List [IntList] will typecheck, but it's very weird indeed.
09:17:39 <dmhouse> Firstly, there would be two ways of constructing the empty list. Either Nil or List [].
09:18:00 <dmhouse> So Nil is superfluous because []-lists already provide a Nil, called [].
09:18:36 <dmhouse> So we have data IntList = List [IntList]. So you're basically just declaring another type which is synonymous with [Int], and wrapping a constructor around it, which is a bit pointless.
09:18:43 <dmhouse> Hence, type IntList = [Int].
09:18:55 <MarcWebe1> I can't use sepBy from parsec without using makeTokenParser, can I?
09:18:57 <Buzzons> ah ok thanks :)
09:19:06 * Buzzons runs off to do some more haskell for noobs
09:19:12 <dmhouse> @hoogle sepBy
09:19:12 <lambdabot> Text.ParserCombinators.ReadP.sepBy :: ReadP a -> ReadP sep -> ReadP [a]
09:19:12 <lambdabot> Text.ParserCombinators.Parsec.Combinator.sepBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
09:19:12 <lambdabot> Text.ParserCombinators.ReadP.sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
09:19:25 <dmhouse> MarcWebe1: Huh? Sure!
09:19:41 <dmhouse> char '1' `sepBy` (many $ char 'a')
09:20:07 <MarcWebe1> dmhouse: Which module do I have to import?
09:20:20 <MarcWebe1> wait .
09:20:22 <dmhouse> MarcWebe1: Text.ParserCombinators.Parsec...
09:21:24 <MarcWebe1> sorry. Right. I forgot to replace semiSep by sepBy after undoing some changes.
09:22:18 <dmhouse> Aha.
09:23:05 <monochrom> Would it be nice
09:23:14 <monochrom> Err
09:23:18 <monochrom> Wouldn't it be nice
09:23:25 <monochrom> If the IDE could read your mind
09:23:46 <SamB> thats called a PDE
09:24:31 <MarcWebe1> and my tags file didn't contain it.
09:25:51 <MarcWebe1> monochrom: Then you would have to keep this IDE secret.. Or you won't have any job again ;)
09:29:04 <monochrom> I am an academic.
09:30:32 <monochrom> There is no IDE, mind-reading or not, for doing research yet.  Don't worry.
09:30:51 <MarcWebe1> *lol*
09:31:24 <SamB> and even so it could only read the papers from your mind
09:31:39 <monochrom> But I am weary of "real world" programmers.  I want them to become unemployed overnight.
09:33:55 <jer> weary of 'real world' programmers? do we bite? .. well i guess some of us might, but it's nothing you can't get a shot for =D
09:38:03 <Cale> jer: hehe
09:38:10 <madpickle> if not for the "real world", who'd fund academia?
09:39:19 <SamB> heh
09:39:23 <monochrom> I'm just referring to the programmers, not the whole real world.
09:39:32 <SamB> but I bet it isn't the programmers who fund academia
09:39:57 <SamB> so do you mind all real-world programmers, or just "real world" programmers?
09:40:46 <madpickle> no but the real-world programmers drive the perpetual machine(corps) that fund academia or pay taxes to the government, which, then, fund academia
09:40:53 <madpickle> and what's wrong with real-world programmers?
09:41:51 <Cale> I think the real-world programmers he's talking about are the ones who have lots of inertia.
09:42:02 <madpickle> oh, so a subset then?
09:42:18 <madpickle> i can sort of agree with what monochrom is saying, assuming we're on the same level (in that not all real-world programmers suck)
09:42:29 <madpickle> ignoring whatever semantic attributions one does to the word "programmer"
09:42:54 <madpickle> it disgusts me to see Sam's lousy "Teach yourself X in 10 hours"
09:43:05 <madpickle> as it is reducing CS to that of a mickey mouse field
09:43:25 <madpickle> i don't see authors writing "Teach yourself neurosurgery in 10 hours"
09:43:28 * dcoutts_ thought madpickle actually meant X at first :-)
09:43:32 <madpickle> lol
09:43:33 <dcoutts_> as in X windows
09:43:40 <Cale> and well, even from a business perspective, you don't really want to be called a programmer, since it sort of implies that you're just doing money-work for someone else.
09:43:50 <madpickle> but you usually are
09:43:56 <madpickle> i prefer "software engineer" or "developer"
09:44:01 <madpickle> but even that is not a fixed definition
09:44:07 <dcoutts_> hacker :-)
09:44:07 <madpickle> one mans engineer is another mans programmer
09:44:12 <madpickle> haha, yeah
09:44:17 <monochrom> I am controversial.  I always start debates.
09:44:17 <madpickle> CHO - Chief Hacker Officer
09:44:18 <Cale> Why can't you be a computer scientist and work in the industry?
09:44:25 <madpickle> you are
09:44:33 <madpickle> if you work for MS Research or something
09:44:49 <Cale> Or you run your own business.
09:44:53 <madpickle> i don't call myself a "computer scientist" (despite having the degree) as it's an offense to people who really are.
09:44:57 <madpickle> i'm too pragmatic
09:45:16 <monochrom> Experimental physicists are physicists too.
09:45:17 <palomer> I think spending all your time in your moms basement is part of the definition of computer scientist
09:45:24 <madpickle> i don't "scoff" theory (not at all), but I'm not as in touch with my academic/theoretical side as what a computer scientist would, by its very definition, be,.
09:45:26 <sjanssen> @palomer
09:45:26 <lambdabot> xml stands for "xtremely mild lullaby"
09:46:03 <monochrom> Experimental physicists are very pragmatic.
09:46:10 <madpickle> so what do you do, then, monochrom?
09:46:14 <madpickle> what is your forte?
09:46:19 <madpickle> pardon the lack of accented cahracters
09:46:54 <palomer> monochrom has a vast knowledge on the subject of becoming a career graduate student
09:47:04 <madpickle> ah.
09:47:14 * palomer pokes monochrom
09:47:24 <Cale> @palomer
09:47:24 <lambdabot> Brump!
09:47:38 <madpickle> say, Cale, what do you do?
09:48:07 <Cale> madpickle: Well, not much yet. I recently finished a degree in pure mathematics.
09:48:17 <madpickle> I'm sorry to hear that :P
09:48:23 <Cale> hm?
09:48:26 <madpickle> in that it's hard.
09:48:37 <madpickle> some of my maths degree friends commented on the fact that most of it was nothing but proofs
09:48:39 <SamB> well, but, Cale just finished
09:48:41 <Cale> I'm looking at grad schools.
09:48:50 <Cale> Hm?
09:48:53 <Cale> Proofs are fun :)
09:49:02 <SamB> so you should be happy for Cale to have finished this "hard" thing!
09:49:09 <Cale> If you're not proving things, you're not doing mathematics.
09:49:10 <monochrom> Experimental physicists are probably more pragmatic than most programmers.  How often do you see a programmer calculating the amount of memory he uses down to bytes?  An experimental physicist in those accelerator labs has to calculate his energy budgets.
09:49:28 <madpickle> i can see people doing it on embedded platforms
09:49:30 <dcoutts_> it's 'coz we're lazt
09:49:36 <_Codex> Proofs are programs.
09:49:59 <madpickle> some people try to determine the space-constraints of algorithms before employing them
09:50:03 <dcoutts_> _Codex, but most program arn't proofs, general recursion isn't true!
09:50:06 <madpickle> it all depends on what you do
09:53:09 <astrolabe> I think I disagree with Cale
09:53:39 <astrolabe> a lot of maths was known about before proofs came along for it.
09:53:58 <astrolabe> Apparently the italian school of algebraic geometry for instance
09:53:58 <SamB> well, they probably used some kind of informal proofs before that...
09:54:42 <astrolabe> Also I've read that alot of topological quantum field theory doesn't have proofs.
09:55:11 <astrolabe> Though obviously making it all rigorous is a goal.
09:56:01 <astrolabe> and certainly most maths these days is about theorems.  Conjectures are important though.
09:59:21 <SamB> astrolabe: well yeah -- isn't that where theorems come from, after all?
10:03:29 <lightstep> i'm compiling gtk2hs' documentation, and it has a parse error on a king annotation. how can i tell it to ignore the error?
10:03:45 <dcoutts_> king annotation?
10:04:10 <dcoutts_> using haddock-0.7 right? which gtk2hs verison? current darcs version?
10:04:51 <dcoutts_> lightstep, it can't ignore the error, we can either fix the error or not build the docs
10:04:57 <dmhouse> Haskell needs extensible kings.
10:05:04 <dcoutts_> heh
10:05:43 <foxy_> @pl foldl (\ys x -> if all (\a -> x `mod` a /= 0) ys then ys++[x] else ys) []
10:05:43 <lightstep> err, kind
10:05:43 <lambdabot> foldl (flip =<< ap (ap . (if' .) . flip (all . flip flip 0 . ((/=) .) . mod)) ((. return) . (++))) []
10:05:48 <dcoutts_> shapr, any idea when AngloHaskell will be yet? when might we know?
10:05:54 <audreyt> mm, extensible kinks.
10:06:07 <lightstep> haddoc is 0.7, and gtk2hs is the most recent version
10:06:10 <foxy_> foldl (flip =<< ap (ap . (if' .) . flip (all . flip flip 0 . ((/=) .) . mod)) ((. return) . (++))) [] [2..50]
10:06:10 <dcoutts_> lightstep, ah in the current darcs version then, which module & line ?
10:06:20 <lightstep> and i can't just remove the annotation
10:06:29 <lightstep> gtk/Graphics/UI/Gtk/TreeList/Types.hs:49:34
10:06:52 <audreyt> #ifndef HADDOCK it away?
10:07:00 <foxy_> 3 + 4
10:07:13 <lightstep> i'll try that
10:07:37 <foxy_> @foldl (flip =<< ap (ap . (if' .) . flip (all . flip flip 0 . ((/=) .) . mod)) ((. return) . (++))) [] [2..50]
10:07:47 <audreyt> >3+4
10:07:52 <audreyt> > 3+4
10:07:53 <lambdabot>  7
10:07:59 <lambdabot> *** "flip" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
10:07:59 <lambdabot> FLIP
10:07:59 <lambdabot>  
10:07:59 <lambdabot>     1. An early {assembly language} on the {G-15}.
10:07:59 <lambdabot>  
10:08:01 <lambdabot> [150 @more lines]
10:08:08 <audreyt> wow.
10:08:22 <dcoutts_> lightstep, that or something like this:
10:08:22 <dcoutts_> class TypedTreeModelClass model where
10:08:22 <dcoutts_>   dummy :: model a -> ()
10:08:23 <foxy_> > foldl (flip =<< ap (ap . (if' .) . flip (all . flip flip 0 . ((/=) .) . mod)) ((. return) . (++))) [] [2..50]
10:08:24 <lambdabot>  Not in scope: `if''
10:08:24 <dmhouse> @help foldl
10:08:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:08:45 <foxy_> @hoogle if'
10:08:45 <lambdabot> No matches found
10:09:04 <dmhouse> if' p x y = if p then x else y
10:09:12 <dmhouse> To enable @pl to deal with if statements.
10:10:08 <lightstep> dcoutts_, this seems wrong. it's better if i could tell c2hs to keep 2 versions, one for haskell and one for haddock
10:10:51 <dcoutts_> lightstep, aye, the problem is that it gets cpped before c2hs sees it so we can't use #ifdef HADDOCK
10:11:00 <dcoutts_> try my other suggstion
10:11:01 <foxy_> > foldl (flip =<< ap (ap . ((\p x y -> if p then x else y) .) . flip (all . flip flip 0 . ((/=) .) . mod)) ((. return) . (++))) [] [2..50]
10:11:01 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
10:11:34 <lightstep> yes. perhaps haddock should add a feature like "take this instead of the following line"
10:12:26 <dcoutts_> lightstep, haddock should just parse everying correctly :-)
10:12:38 <dcoutts_> by using the ghc-api
10:12:59 <lightstep> probably. but it would still not recognize some declarations
10:13:01 <dmhouse> foxy_: Eww. Eww Eww Eww.
10:13:04 <lightstep> (future ones)
10:13:22 <dcoutts_> lightstep, if it uses the ghc-api it'll recornise everything that ghc does
10:13:41 <foxy_> my previous attempt at primes was half a page long! %P
10:13:45 <lightstep> but it won't know how to handle it
10:14:45 <dcoutts_> aye, I suppose it'd need occasional maintainance
10:15:16 <dcoutts_> but at least you'd know what maintainance it needs unlike now where it just gets more and more out of date
10:24:21 <xerox> ?yow!
10:24:21 <lambdabot> Maybe we could paint GOLDIE HAWN a rich PRUSSIAN BLUE --
10:24:45 <dcoutts_> @yarr!
10:24:45 <lambdabot> Swab the deck!
10:24:58 <dcoutts_> how's it going xerox?
10:25:11 <xerox> Can't find HackageDB :-)
10:25:19 <dcoutts_> hmm, it's dissapeared?
10:25:23 <xerox> *poof*
10:25:32 <xerox> Oh, bringert surely knows.
10:25:42 <bringert> what was that?
10:25:52 <xerox> We're hunting HackageDB.
10:26:00 <xerox> Where is the latest version?
10:26:18 <bringert> I'm not involved in that
10:26:29 <bringert> lemmih isn't around?
10:26:30 <xerox> Nevermind.
10:27:35 <dcoutts_> xerox, so what are you looking for exacly? the source to the web interface?
10:27:44 <dcoutts_> http://hackage.haskell.org/ModHackage/Hackage.hs
10:27:54 <xerox> No, I should not take in consideration the web interface for this early release.
10:28:10 <lightstep> parrot has 4 logarithm opcodes
10:28:23 <bringert> xerox: there seems to be a darcs repo here: http://darcs.haskell.org/hackageDB/
10:28:24 <dmhouse> xerox: Release?
10:28:25 <lambdabot> Title: Hackage
10:28:29 <sjanssen> logarithm is an opcode?
10:28:41 <xerox> I should deploy the hierarchy of packages locally, but haven't I ever used hackageDB I am not sure what else does it need other than the filesystem hierarchy.
10:29:01 <Lemmih> Does HackageDB even exist anymore?
10:29:01 <xerox> dmhouse - That's the ultimate goal for this first round.
10:29:40 <xerox> I am not sure about what cabal-server-install _is_.
10:29:49 <lightstep> sjanssen, its a virtual machine with built-in support for floating point
10:29:50 <dmhouse> xerox: When? Where?
10:29:52 <xerox> It hasn't got the hierarchy of packages.
10:30:00 <dcoutts_> xerox, there's lots of stuff in darcs.haskell.org:/srv/www/hackage.haskell.org/public_html/ModHackage/
10:30:43 <xerox> dmhouse - When I'll be finished with the server part, and have fixed the `put' program.
10:30:48 <dcoutts_> xerox, but you're looking for the spec of the cilent server interface right?
10:30:50 <xerox> Once I find that too :-)
10:30:57 <Lemmih> I don't think HackageDB is relevant anymore.
10:31:14 <dcoutts_> xerox, how the packages are laied out on the server etc
10:31:16 <xerox> http://hackage.haskell.org/trac/hackage/ticket/87
10:31:17 <lambdabot> Title: #87 (robustify &amp; release cabal-get) - Hackage - Trac
10:31:23 <xerox> dcoutts_ - Right.
10:31:28 <Lemmih> We don't use it for downloading packages and we don't use it for uploading them either.
10:31:31 <bringert> Lemmih: so what is it that xerox will write a client for?
10:31:51 <dcoutts_> there was an email about this on cabal-devel the other day
10:31:52 <Lemmih> bringert: An HTTP server?
10:31:53 * dcoutts_ finds it
10:32:05 <bringert> mkay
10:32:29 <xerox> I think Lemmih is right, if I understand Isaac correctly.
10:32:38 <Lemmih> Uploading a package is done via SSH.
10:32:40 <xerox> So, cabal-server-install *is* the put program.
10:33:03 <xerox> And the pub/ directory is the hackageDB hierachy of packages to be exposed by the web server?
10:33:46 <dcoutts_> xerox, http://www.haskell.org//pipermail/cabal-devel/2006-July/000030.html
10:33:47 <lambdabot> Title: new cabal-get developments
10:33:52 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/62
10:33:54 <lambdabot> Title: #62 (trim down cabal-get dependencies) - Hackage - Trac
10:34:28 <xerox> dcoutts_ - Then I think what I just said is right.
10:34:32 * xerox tries.
10:34:55 * dcoutts_ thinks the smart client is the easier way to go
10:35:46 <lightstep> parrot also has bignums (both integer and floating-point), but its big rationals are fixed-point decimal fractions
10:35:56 * xerox is wgetting the hierarchy
10:36:15 <xerox> It's quite fun to get so much Haskell code in one time :-)
10:36:35 <dmhouse> @spell pronounciation
10:36:36 <lambdabot> pronunciation pronunciations pronunciation's renunciation
10:36:39 <dcoutts_> so there's no more xml right?
10:36:42 <dcoutts_> jsut http?
10:36:47 <xerox> That's right.
10:36:49 <xerox> Thanks to audreyt.
10:37:23 <xerox> If I am not mistaken there are some imports that should be cleaned up in the imports chain, but XmlRpc is taken over at this point.
10:38:35 <dcoutts_> xerox, nope, thanks to bringert, the http lib no longer deps on anything
10:38:42 <xerox> Hmmm.
10:38:50 <dcoutts_> mainly no crypto & newbinary dep
10:39:03 <xerox> And what does it mean ``Basically, Audrey was able to talk me out of my "smart server, dumb clients" stance.'' ?
10:39:34 <dcoutts_> well SyntaxNinja wanted a system where the server was smart and told the client what to do
10:39:40 <dcoutts_> and the client just did it
10:40:01 <dcoutts_> where as in this system the server is dumb, just a bunch of files
10:40:09 <dcoutts_> and the client has to work out what it needs to get
10:40:26 <dcoutts_> hmm, there seems to be some duplication in the 00-latest.txt index
10:40:45 <dcoutts_> it includes some info from the .cabal files and not other info
10:41:01 <dcoutts_> I'd have thought it should include all or none
10:41:13 * xerox scratches head
10:41:34 <dcoutts_> look: http://hackage.haskell.org/darcs/cabal-server-install/pub/unstable/
10:41:35 <lambdabot> Title: Index of /darcs/cabal-server-install/pub/unstable
10:42:06 <dcoutts_> so the .cabal files are available so you can get all the info for a package without downloading it
10:42:13 <dcoutts_> that's important
10:42:32 <dcoutts_> but then the index file duplicates a bit of that info
10:42:41 <dcoutts_> no reason why that I can see
10:43:43 <xerox> OK I have it locally in the webserver now.
10:44:16 <xerox> Now, since cabal-get does not exist anymore, to test it, I should use Cabal/cabal-install right?
10:48:21 <dcoutts_> xerox, http://hackage.haskell.org/trac/hackage/ticket/65
10:48:23 <lambdabot> Title: #65 (reorganize layered tool system (cabal-get, cabal-install, cabal-setup, etc) ...
10:48:35 <dcoutts_> right cabal-get is the tool that will download and resolve deps
10:49:45 <xerox> There is no cabal-get, but there is cabal-install in the Cabal repository, whose code recently had been patched by audreyt (hence I think this is the latest).
10:50:18 * dcoutts_ suggests xerox chat to SyntaxNinja
10:50:41 <xerox> I'll take a shower now, it's too hot to think!
10:54:14 <audreyt> xerox: yes, use cabal-install
10:56:53 <dcoutts_> audreyt, remind me, what is the scope of cabal-get/-install/-setup ?
10:57:08 <dcoutts_> there was some ideas before: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:57:10 <lambdabot> Title: CabalInstall - Hackage - Trac
10:57:42 <audreyt> the cabal-install as I hacked it is a download+unpack+installer
10:58:02 <dcoutts_> but not local installer
10:58:08 <dcoutts_> for local packages I assume
10:59:07 <dcoutts_> I think the general concensus was that there should be a user oriented "do everything" tool for dealing with .tar.gz packages and a dev tool for dealing with unpacked build trees
10:59:34 <dcoutts_> or something like that
11:00:37 <audreyt> uhm you can do local packages
11:00:43 <audreyt> just have a local package tree
11:00:47 <audreyt> it used XML RPC
11:00:54 <audreyt> it no longer does
11:01:02 <audreyt> so if you simply rsync from a remote tree
11:01:12 <audreyt> and change the conf file to point to file:///
11:01:15 <audreyt> then you can install there
11:01:33 <foxy_> dcoutts, is hIDE using Yi?
11:01:40 <audreyt> http://perlcabal.org/~audreyt/hackage/ # sample tree
11:01:42 <lambdabot> Title: Index of /~audreyt/hackage
11:02:00 <dcoutts_> foxy_, it has done at various points, not sure of current state
11:02:29 <xerox> audreyt: OK I have the sample tree locally
11:02:31 <xerox> audreyt: how does one proceed to test it?
11:04:50 <foxy_> is there a list of Haskell projects that need volunteers?
11:06:41 <audreyt> xerox: install cabal-install
11:06:51 <xerox> I did.
11:06:54 <audreyt> edit
11:06:55 <audreyt> /etc/cabal-install/serv.list
11:07:01 <audreyt> here it says
11:07:01 <audreyt> ["http://perlcabal.org/~audreyt/hackage"]
11:07:05 <audreyt> you can change it to file:///
11:07:06 <audreyt> and try
11:07:21 <audreyt> cabal-install search http
11:07:22 <xerox> ["http://hackage.haskell.org/ModHackage/Hackage.hs?action=xmlrpc"]
11:07:23 <audreyt> or something
11:07:23 <xerox> Okay.
11:07:30 <audreyt> the xmlrpc is stale and needs to be removed
11:07:31 <xerox> I also have a local webserver serving the hierarchy.
11:07:34 <audreyt> sadly I need to run in a bit
11:07:44 <xerox> Thanks for the informations.
11:07:54 <bringert> foxy_: here is a list of proposed Haskell SoC projects http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&verbose=1&type=proposed-project&order=priority
11:07:56 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac
11:09:22 <shapr> dcoutts_: No, I don't know yet, but I think we'll know soon.
11:09:28 <dcoutts_> shapr, cool
11:09:31 <shapr> bringert: Hiya!
11:09:33 * xerox boings
11:09:37 <bringert> morning shapr
11:09:52 <xerox> bringert - The latest hope CSS is neat !
11:09:52 <shapr> I just got back from five hours unicycling with three other unicyclists! That was the first time ever I've met more unicyclists!
11:10:01 <dcoutts_> xerox, did you dicide if you could afford to get to Cambridge?
11:10:11 <dcoutts_> xerox, I can probably offer floor space
11:10:26 <xerox> dcoutts_: what was the trains site run by consumers?
11:10:38 <dcoutts_> shapr, we should organise a unicycle hockey game in cambridge :-)
11:10:48 <dcoutts_> xerox, google seat 62
11:10:54 * xerox is ordering his unycicle
11:10:57 <dcoutts_> (I think)
11:11:10 <bringert> xerox: glad you like it
11:12:56 <xerox> ``It's easy to travel from London to Milan by train.  You can reach Milan the same day, using a morning Eurostar to Paris then a high-speed TGV across the French Alps direct from Paris to Milan.  Or you can take an afternoon Eurostar to Paris then the overnight sleeper to Milan.''
11:13:21 <dcoutts_> xerox, http://www.seat61.com/
11:13:22 <lambdabot> Title: The Man in Seat Sixty-One...
11:13:26 <shapr> dcoutts_: Sounds good to me!
11:13:31 <xerox> Yeah I am reading it.
11:13:34 * dcoutts_ took the sleeper train
11:16:04 <ihope> So if bottom is _|_, what's top?
11:16:12 <shapr> There is a top type actually.
11:16:23 <Philippa> at least, in some type systems - not in haskell
11:16:26 <monochrom> Topless bar.
11:16:35 <ihope> Oh, top is T :-)
11:16:35 <monochrom> We have no top.
11:16:45 <Philippa> ihope: there isn't a unique top value in haskell, all "fully-defined" (= doesn't contain bottom anywhere) values are "joint-top"
11:17:16 <monochrom> Perhaps "what's top" is ambiguous. :)
11:17:26 <Philippa> yeah :-)
11:17:56 <ihope> Yeah. If the bottom value is a member of the bottom type, then the top value would be a member of the top type... eh.
11:18:10 <ihope> Maybe the top value would *not* be a value of the top type.
11:19:47 <DukeDave> hey gang, when writing a list comprehension, say I wish to generate [(x,y,x)] such that x <- [1..10], y <- [1..10], z <- [1..10]
11:19:57 <DukeDave> is there a short hand way of writing that
11:20:26 <monochrom> [(x,y,x) | x <- [1..10], y <- [1..10], z <- [1..10] ]   is this what you want?
11:20:37 <DukeDave> oops, (x,y,z)
11:20:40 <DukeDave> however, yes
11:21:08 <DukeDave> just wondered if there was a way to say x, y, and z all come from the list [1..10]
11:21:17 <DukeDave> for brevity
11:21:49 <monochrom> [(x,y,z) | let s=[1..10], x <- s, y <- s, z <- s ]
11:22:16 <monochrom> "common subexpression elimination by hand"
11:22:21 <shapr> xerox: today - http://enhjulingsfolket.se/viewtopic.php?pid=14273#p14273
11:22:23 <lambdabot> Title: Enhjulingsfolket / Stockholms rull p lrdag 15 juli - Ngon hemma?
11:22:41 <DukeDave> that would make sense..
11:22:42 <DukeDave> :)
11:23:39 <xerox> shapr - hah hah - preparation -> chaos -> unicycles dumped away
11:24:15 <shapr> :-)
11:24:21 <ihope> Hmm...
11:24:32 <ihope> > [(1,1,1)..(10,10,10)]
11:24:33 <lambdabot>  add an instance declaration for (Enum (a, b, c))
11:24:33 <lambdabot>   In an arithmetic seque...
11:24:34 <monochrom> I am thinking [(x,y,z) | let s=[1..10], x <- s, y <- s, z <- s ] takes more memory.
11:25:03 <DukeDave> in this case I wish to generate lists of Int of length 9, in which each elem is unique from the list [1..9]
11:25:30 <DukeDave> eg, [1,2,3,4,5,6,7,8,9] or [2,1,3,4,5,6,7,8,9]
11:25:50 <monochrom> eh, all permutations?
11:25:50 <DukeDave> trying to find the `nicest' way to do it
11:25:53 <DukeDave> yeah
11:26:10 <monochrom> Cale has permutation code on some wiki-something
11:28:47 <DukeDave> interesting
11:28:53 <DukeDave> @hoogle permutations
11:28:54 <lambdabot> No matches found
11:29:13 <DukeDave> @hoogle [a] -> [[a]]
11:29:14 <lambdabot> List.inits :: [a] -> [[a]]
11:29:14 <lambdabot> List.tails :: [a] -> [[a]]
11:29:14 <lambdabot> List.group :: Eq a => [a] -> [[a]]
11:30:05 <glguy> what about just: sequence (replicate 3 [1..3]) and filtering out the results with duplicates?
11:31:14 <DukeDave> I have found an implementation here:   http://haskell.cs.yale.edu/haskell-report/List.html
11:31:15 <lambdabot> Title: The Haskell 1.3 Library Report: List Utilities
11:31:33 <Cale> yeah, I have no idea why they removed it
11:31:46 <DukeDave> damn them!
11:32:21 * DukeDave awaits horrific memory overflow :)
11:33:46 <edwardk> probably to give those sophomore computer science students something to do ;)
11:36:48 <monochrom> I don't know why I don't know how to search things in wiki.
11:40:08 <glguy> is there a prelude function for this:
11:40:11 <glguy> m f [] = []
11:40:18 <glguy> m f xs = f xs : m f $ tail xs
11:40:19 <glguy> ?
11:40:38 <glguy> lisp called it maplist or something (it's been a while)
11:40:53 <bringert> shapr, xerox, jgrimes: some new Hope stuff, see http://hope.bringert.net/
11:41:24 <DukeDave> just to clarify,   [] /= [[]]  right?
11:41:39 <glguy> right
11:41:43 <edwardk> Cale: one reason they might have gotten rid of it is that it doesn't play nice with infinite lists
11:42:08 <glguy> m :: ([a] -> a) -> [a] -> [a]
11:42:20 <monochrom> Where is the "extra prelude" or whatever it's called?
11:42:40 <Igloo> glguy: That's map f . tails
11:43:18 <glguy> cool, I didn't know about tails
11:43:20 <glguy> thank you
11:43:27 <Igloo> (assuming you meant f xs : (m f $ tail xs))
11:43:41 <glguy> yeah
11:44:11 <Igloo> Oh, actually map f . init . tails
11:44:20 <Cale> edwardk: it would be possible to fix that actually.
11:44:35 <edwardk> sure, just that implementation blows up the stack
11:44:44 <edwardk> was in the process of writing a correct one now =)
11:45:07 * DukeDave is currently struggling with the old definition
11:45:17 <foxy_> I'm running Setup.hs for Yi and it fails on regex.h but I have regex.h in /usr/local/include ?
11:45:26 <Cale> It's too bad Sym(N) is uncountable, so you won't be able to actually get *every* permutation :)
11:45:34 <edwardk> of course
11:45:44 <edwardk> but it would be nice to be able to do the sensible thing
11:45:59 <Cale> yeah, just all the permutations of the first n elements for each n
11:46:15 <edwardk> yeah so you can just take from the front of the llist and take from that
11:46:37 <monochrom> @paste
11:46:37 <lambdabot> http://paste.lisp.org/new/haskell
11:47:01 <monochrom> No, not that one.
11:47:36 <edwardk> the subsequences implementation also blows up
11:48:46 <monochrom> Is it just me or are wikis write-only unsearchable collections?
11:48:53 <edwardk> haha
11:49:03 <Heffalump> sounds about right
11:49:04 <edwardk> depends on the wiki
11:49:14 <monochrom> Ok I feel better now.
11:49:42 <Heffalump> with some work they can be kept in shape
11:49:43 <dmhouse> Write-only? Unsearchable?
11:49:50 <dmhouse> Oh, you mean Moin Moin wikis.
11:52:15 <paolino> Moin Moin is used not for its quality
11:52:58 <monochrom> I am looking for "prelude extra" or whatever it is called.  It contains permutation code.  I have searched by both Google and the haskell.org search box in vain.
11:54:18 <monochrom> (Don't you think this is an example use-case and frustrate of all new comers?)
11:54:27 <monochrom> s/frustrate/frustration/
11:55:49 <monochrom> If you could point me in a better direction, much appreciated.
11:57:58 <ADEpt> evening
11:58:05 <ADEpt> any debian/unstable users here?
12:00:28 <dcoutts_> monochrom, what's wrong with the haskell 1.3 permutation code you found?
12:01:08 <monochrom> I am not referring to the code.  I am referring to how to locate it.
12:01:37 <monochrom> Actually I am not referring to how to locate it.  I am referring to how to locate things in the future.
12:02:00 <glguy> @pl (\f -> map f . tails)
12:02:00 <lambdabot> (. tails) . map
12:02:12 <dcoutts_> monochrom, google turns this up:
12:02:12 <dcoutts_> http://www.haskell.org/hawiki/PermutationExample
12:02:14 <lambdabot> Title: PermutationExample - The Haskell Wiki
12:02:29 <xerox> bringert: seems like hope CSS broke on Safari.
12:02:37 <dcoutts_> there's too much on the old wiki that needs moving over to the new one
12:04:42 <xerox> That page links LicensedPreludeExts which is what monochrom was searching for.
12:05:02 <monochrom> May I ask what Google-fu you used to obtain that?  Because http://www.google.com/search?q=haskell+permutation doesn't.
12:05:03 <lambdabot> Title: haskell permutation - Google Search
12:05:15 <bringert> xerox: try shift + reload
12:05:47 <xerox> opt+reload works, good :-)
12:05:57 <dcoutts_> monochrom, google haskell permute
12:06:10 <monochrom> ah
12:06:19 <bringert> oh, it's opt? that's why shift + reload doesn't work so well for me
12:06:27 * bringert uses safari too
12:06:46 <bringert> I try to always test stuff in safari, firefox and ie
12:07:00 <bolrod> I never try to make a website
12:07:30 <xerox> bringert: 'alt'
12:07:48 <xerox> Oh, misread. Nevermind :)
12:08:09 <dmhouse> It's Ctrl :S
12:17:05 <dmhouse> Anyone used launch.yahoo.com on Fx/Linux?
12:17:06 <dmhouse> Apparently Macs aren't supported, which I regard as a particularly irrelevant error.
12:17:09 <dmhouse> Can I fool it into thinking I'm on Windows?
12:19:44 <monochrom> need browser to lie to the web site.
12:21:07 <monochrom> I'm all in favour of a programmable browser, i.e., programmable in lying to web sites and ignoring certain gratious web page instructions such as "open new window".
12:21:15 <bringert> dmhouse: you can change the useragent string in Firefox
12:21:23 <dmhouse> bringert: Apparently even that doesn't do it.
12:21:31 <bringert> hmm
12:21:47 <dmhouse> I was chatting on #wordpress and apparently even a fake UA doesn't get through their stupidly good detection. :)
12:21:49 <monochrom> Yeah through javascript the web site asks "what's your OS" and you have to lie there.
12:22:00 <dmhouse> monochrom: Really?
12:22:23 <dmhouse> I'm sure I wouldn't have told it I was on a Mac. I'm on Ubuntu on a x86 system :)
12:23:43 <monochrom> Bottomline: How does http://www.mozilla.com/ know your OS?
12:23:48 <lambdabot> Title: Mozilla Corporation - Home of the Firefox web browser and Thunderbird email clie ...
12:24:21 <dmhouse> monochrom: UA splicing?
12:26:32 <monochrom>    <script type="text/javascript">
12:26:32 <monochrom>     <!--
12:26:32 <monochrom>       // Configure the Firefox download write script
12:26:32 <monochrom>       var gDownloadItemTemplate = "<a href=\"%DOWNLOAD_URL%\" class=\"download-link download-firefox\"><span><strong>Download Firefox<\/strong> <em>%VERSION% for %PLATFORM_NAME%, %LANGUAGE_NAME%&nbsp;(%FILE_SIZE%)<\/em><\/span><\/a>";
12:28:21 <madpickle> use Proxomitron
12:28:28 <madpickle> the best web filter out there
12:28:50 <madpickle> make sure you get the custom filters for it (like Grypen's Filter Set)
12:29:23 <monochrom> Actually the snippet above is not the meat.  Here is the meat.  http://www.mozilla.com/download.js
12:30:01 <monochrom> The main page has <script type="text/javascript" src="download.js"></script> to load and run that script.
12:30:10 <dmhouse> You know what would be a cool ChanServ feature? You should be able to interesect all the nicks on two channels: "Who's in #blah and #foo?"
12:33:17 <monochrom> The script calls navigator.platform.indexOf("Win32"), navigator.platform.indexOf("Linux"), etc., to determine your OS.
12:40:43 <dmhouse> @remember fsbot English -> English: no matching translation services found.
12:40:43 <lambdabot> Done.
12:46:13 <palomer> @hoogle Maybe a -> [a]
12:46:14 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
12:55:38 <ookk> i would like a recursive function that continues as far as a sum is less then "smallest_sum" and if it finds a solution i want to update smallest_sum so that other branches of the recursion will use that value as a limit, how can i do that without using a global variable?
12:56:58 <ookk> the point is finding the solution with the smallest sum
12:57:18 <palomer> I'm sorry, but you haven't given us enough information
12:58:32 <ookk> ok i will try to explain further
13:00:13 <ookk> i have a recursive function that will continue to call itself as long as some variable "sum" is less then "smallest_sum". if a condition is satisfied "smallest_sum" should be updated with "sum" and all previous branches of the recursive function should see the new value of "smallest_sum"
13:00:37 <ookk> i dont have to much experience with haskell
13:01:09 <ookk> but in c++ i would use a global variable for "smallest_sum" or pass a pointer to it as a function parameter
13:01:28 <ookk> but obviously i should use some functional programming trick in haskell
13:02:26 <palomer> this function traverses what exactly?
13:05:14 <ookk> is complicated to explain the problem it solves, but the purpose could aswell be to find the shortest path from a to b in a graph
13:05:26 <ookk> but thats not at all what it is doing
13:05:31 <palomer> ok, we'll assume that this function traverses some data structure
13:05:36 <ookk> and sum would then represent the number of branches
13:05:45 <ookk> and the condition would be reaching the goal
13:05:51 <ookk> yeah it does
13:05:55 <dcoutts_> ookk, how about each recursive call returns the lowest sum in that branch, then as you do a traversal you carry that over to use in searching the next branch
13:06:00 <palomer> furthermore, it traverses the data structure in some order
13:06:22 <dcoutts_> so the "smallest_sum" value gets passed down and up
13:06:57 <ookk> yeah but if i seed multiple branches in every function-call
13:06:58 <shapr> bringert: yay! I like the new Hope look! pulling & building now.
13:07:13 <ookk> how will the parallallel branches get to know about the updated "smallest sum"
13:07:34 <shapr> You could build a multidimensional lazy datastructure and traverse it.
13:07:46 <palomer> ookk: right now you're thinking that every branch gets traversed at the same time
13:07:51 <ookk> dcoutts, maybe your idea will work when i think about it
13:07:51 <shapr> Oh, I see dcoutts_ was just saying that :-)
13:07:56 <dcoutts_> ookk, you're not actually evaluating in parallel, you're doing a sequential traversal
13:07:56 <palomer> ookk: however, you're going to draverse one branch at a time
13:08:27 <ookk> yeah you are right, so it will work the way dcoutts said :)
13:08:33 <ookk> i will try that thx
13:08:53 <shapr> hej olof, r du svensk?
13:09:05 <ookk> jag ?r svensk
13:09:14 <shapr> Nifty, would you happen to be in Stockholm too?
13:09:33 <palomer> ook also happens to be a kickass programming language
13:09:43 <ookk> nope i live in s?derk?ping
13:09:56 <ookk> ohh i didnt know that
13:09:57 <shapr> I'm looking for some #haskell, type theory, and/or functional programming people to start up a regular gathering in Stockholm.
13:10:30 <Korollary> i.e., a sect.
13:10:34 <ookk> heh
13:10:37 * Lemmih grins
13:10:44 <ookk> i just started learning haskell yesterday
13:10:54 <ookk> i wanted to learn a functional programming language
13:11:02 <ookk> and i thought ocaml had horrible syntax
13:11:03 * shapr offers kool-aid to Korollary 
13:11:14 <Korollary> ocaml does have horrible syntax. But you can get used to it.
13:11:25 <shapr> Yeah, but it's also impure.
13:11:25 <palomer> someone give me some useful generic functions Bool -> something
13:11:28 <shapr> I just can't get used to that.
13:11:31 <ookk> its fast at least, or so i have heard
13:11:32 <shapr> palomer: elem
13:11:46 <dcoutts_> shapr, I'll be in Stockholm all of September and a week or so in December
13:11:51 <shapr> Yay!
13:11:56 <shapr> dcoutts_: Bring enhjuling?
13:12:07 <dcoutts_> enhjuling == unicycle ?
13:12:08 <palomer> ok, something who's principle type is Bool -> something
13:12:09 <shapr> yup
13:12:17 <shapr> palomer: I think you meant whose?
13:12:24 <dcoutts_> shapr, I'm comming on the ferry, so I suppose I could
13:12:30 <palomer> probably did
13:12:32 <shapr> Though it could have been "who has" I guess.
13:12:33 <palomer> @hoogle elem
13:12:33 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
13:12:33 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
13:12:33 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
13:13:04 <shapr> dcoutts_: Assuming nothing untoward happens, I'll be here for awhile.
13:13:13 <dcoutts_> cool
13:13:31 <shapr> You can borrow my KH24 if you end up not bringing your own.
13:13:36 * dcoutts_ needs some advice for what touristy things to see
13:14:23 <dcoutts_> my gf and I will have about 10 days to travel & do touristy things before she starts the project she's there to do
13:14:36 <dcoutts_> we're actually arriving 25th aug
13:14:57 <dcoutts_> we thought about taking the train to the artic circle :-)
13:15:18 <palomer> arctic
13:15:28 <dcoutts_> er, yeah :-)
13:15:43 <palomer> I'm thinking of picketing the next national spelling B
13:15:47 <dcoutts_> bad spellers of the world untie!
13:15:55 <palomer> with the other phonetic spelling club members
13:16:30 <dcoutts_> speling reform eh?
13:16:41 <palomer> yup
13:16:50 <palomer> in fact, I think I'll start phonetically spelling in this channel
13:16:59 * dcoutts_ will have to stop saying aye and start saying i
13:18:26 <shapr> d00d
13:18:53 <dcoutts_> @fonetic weill need a new plugin
13:18:53 <lambdabot> Unknown command, try @list
13:19:06 <monochrom> hei palomer, hau du yu compaer haskel to es em el?
13:19:07 * shapr grins
13:19:27 <shapr> cabal-install would be great for hope.
13:19:49 <dcoutts_> @where hope
13:19:49 <lambdabot> http://hope.bringert.net/
13:20:05 <monochrom> s/to/tu/
13:20:23 <monochrom> Damn it's hard to write phonetically.
13:20:48 <palomer> hope is for the hopeless.
13:27:11 <astrolabe> How hard would it be to write a program to convert the old wiki to the new wiki format?
13:30:46 <monochrom> Interesting.
13:35:03 <palomer> astrolabe: NP-complete
13:35:17 <palomer> for all even numbered inputs
13:36:00 <dmhouse> If I wanted to make a program which output something, then changed what it had output after a certain period of time, what magic do I need to use?
13:36:11 <dmhouse> I.e. I'm writing a binary clock and I want it to update after a second.
13:36:34 <monochrom> What is a binary clock?
13:36:44 <glguy> one that shows the time in binary
13:36:49 <dmhouse> A clock which displays 1s and 0s to make up the time in binary
13:37:17 <zarvok> http://www.thinkgeek.com/homeoffice/lights/59e0/
13:37:18 <lisppaste2> dmhouse pasted "binary clock screenshot" at http://paste.lisp.org/display/22649
13:37:18 <lambdabot> Title: ThinkGeek :: LED Binary Clock
13:37:30 <dmhouse> E.g. There's a 'screenshot' from my binary clock.
13:37:53 <monochrom> Thus, it is not so much "change output" as "output again"?
13:38:15 <glguy> "It's easy for any self-respecting geek to figure out how to read this clock in a few minutes."
13:38:21 <zarvok> heh
13:38:26 <glguy> If it takes you a few minutes to figure out how to read a binary clock
13:38:31 <glguy> you are not a self-respecting geek
13:38:33 <glguy> unless
13:38:41 <dmhouse> monochrom: Well, no. I want to output the clock, then after a second, change it.
13:38:44 <glguy> true geeks can't respect themselves
13:38:49 <dmhouse> Not output a fresh clock.
13:40:21 <monochrom> Insomuch as I like to talk abstractly, I think few are ready to.  So, what is the display device, and what is its programming interface?  The rest hinges on it.
13:40:32 <dmhouse> I think this goes beyond the normal putStrLn side of IO. Perhaps I need to talk to ncurses?
13:41:04 <glguy> do it graphically with the graphics library
13:42:20 <dmhouse> That might be easier than messing around with terminal libs.
13:42:52 <monochrom> Perhaps you need to decide how to display.
13:43:25 <monochrom> I.e., gtk? ncurses? LED connected to a serial port?
13:43:35 <dmhouse> Hah, LED :)
13:44:02 <glguy> I've been playing with Graphics.SOE (just picked up the book) and it would be easy enough to display such a clock
13:44:20 <dmhouse> I think I'll go the cool kids way and check out Gtk2Hs :)
13:44:30 <monochrom> However, the programming interface is presented as though you "output again" rather than "change output".
13:44:36 <dcoutts_> dmhouse, good idea ;-)
13:46:15 <monochrom> For example, GTK.  To update the display, you issue a draw command.  Well that's new output from the POV of the driving program.
13:47:58 <monochrom> (From the POV of the driven, i.e., the GTK window, of course it has state for the current displayed stuff, and your new draw command causes it to change state.  But it is the other side of the fence and doesn't concern you.)
13:53:34 <monochrom> Another example, LED connected to a serial port or parallel port or USB or firewire or whatever.  What happens is you have additional circuitry.  The circuitry has memory.  When idling, it displays the memory content to the LED.  When some message arrives from the port, it overwrites the memory.
13:54:36 <monochrom> So again, the display device has memory and "changes" state, but it doesn't concern you.  What you care is you send a message to the port.  Once again, it is "output again".
13:55:39 <dmhouse> monochrom: But in the context of my problem, I wanted to distinguish between printing multiple clocks visible at once and printing the same clock on top of the older ones.
13:56:03 <dmhouse> So 'printing again' was convenient terminology to distinguish between the two.
13:56:10 <monochrom> If you send multiple messages to the port, will there be multiple LEDs created?
13:56:57 <monochrom> If you issue multiple draw commands to the same window, will there be multiple copies of the window created?
13:57:29 <monochrom> s/same window/same window handle/
13:58:51 <dmhouse> This isn't a very productive conversation. You're probably right, but this is just semantics.
14:00:52 <monochrom> OK, but for most display devices, including gtk, you write your program in such as way that you output again and again, and the device will take the care of changing rather than spawning.
14:01:33 <dmhouse> Oh, you're drawing a comparison with line-based terminal programs?
14:02:12 <monochrom> I suppose.
14:02:52 <dmhouse> Ah.
14:03:25 <monochrom> So, I am explaining the magic of "changing output".
14:05:59 <monochrom> And the explanation I can think of is to do it semantically.
14:19:31 <dmhouse> Hmm.
14:20:20 <dmhouse> Okay, so I've got my glade file with lots of slots for displaying the time in binary.
14:20:49 <dmhouse> However, I'm using 21 widgets for the display. This is a fair amount, are there any particular nice ways of dealing with large numbers of similar widgets?
14:21:22 <dmhouse> I.e. I'd like to not have to load them all 'hour1 <- xmlGetWidget windowXml ...'
14:24:22 <dmhouse> @hoogle sleep
14:24:23 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
14:24:34 <dmhouse> How would I 'do nothing for a second'?
14:26:43 <dmhouse> So, we're a bit quiet in here. :)
14:30:43 <monochrom> @hoogle threadDelay
14:30:43 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
14:30:51 <monochrom> That one is more portable.
14:31:01 <monochrom> But hey, both work.
14:31:47 <monochrom> 21 widgets for a clock is a lot.  how did you get into this? :)
14:31:53 <dmhouse> Yeah, I'm not on windows, so the first one won't work.
14:32:04 <monochrom> (One widget per bit? )
14:32:15 <dmhouse> monochrom: 7 radio buttons to represent the binary number for seconds, minutes and hours
14:33:53 <dmhouse> Doesn't mainGUI block?
14:34:25 <dmhouse> So how would I go into my threadDelay-for-one-second/update-clock loop? Just not call mainGUI?
14:34:35 <monochrom> My first instinct would be to use glade to make the window and other chore (menu bar say), but not the repetitive radio buttons.
14:35:17 <dmhouse> Hmm.
14:35:19 <monochrom> Then inside Haskell I have a loop to create the radio buttons and also add them to the window.  Also keep the handles of the radio buttons in an array or a list.
14:35:34 <dmhouse> Sounds good.
14:36:10 <monochrom> To update them, I have a loop over that array or list to update each individual.
14:36:58 <monochrom> Glade is superb for O(1) things with a large constant multiple. :)
14:37:43 <dmhouse> Hehe :)
14:37:50 <monochrom> Create a separate thread for threadDelay and possibly update.
14:38:03 <dcoutts> or use timerAdd
14:38:07 <dmhouse> Wow, this is complicated for a binary clock :)
14:38:12 <dmhouse> @hoogle timerAdd
14:38:12 <lambdabot> No matches found
14:38:14 <monochrom> Oh, timer, yeah.
14:38:19 <dmhouse> dcoutts: ?
14:38:41 <dcoutts> sorry, timeoutAdd I mean
14:38:47 <dmhouse> @hoogle timeoutAdd
14:38:47 <lambdabot> No matches found
14:38:55 <dcoutts> timeoutAdd :: IO Bool -> Int -> IO HandlerId
14:38:58 <dmhouse> Okay, so how many threads will I need?
14:39:03 <dcoutts> hoggle doesn't cover Gtk2Hs
14:39:21 <dcoutts> dmhouse, for a simple clock? just the main thread will do
14:39:27 <dmhouse> Cool.
14:39:30 <monochrom> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/System-Glib-MainLoop.html
14:39:37 <dmhouse> What's the IO Bool for?
14:39:44 <monochrom> that has timeoutAdd and friends.
14:39:50 <dcoutts> dmhouse, see the use of timeoutAdd in the cairo clock demo
14:40:06 <dmhouse> Ah, I see.
14:40:16 <monochrom> If you use timeoutAdd, no need to create thread.
14:40:30 <dcoutts> http://darcs.haskell.org/gtk2hs/demo/cairo/Clock.hs
14:40:35 <dcoutts> timeoutAdd (widgetQueueDraw window >> return True) 1000
14:41:09 <dcoutts> the return True/False indicates if the timer should fire again or stop
14:42:27 <dmhouse> Right. And I basically want it to loop forever so do the updating there and return constant true.
14:44:09 <dcoutts> right
14:44:50 <dmhouse> @hoogle newIORef
14:44:50 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
14:45:55 <dmhouse> So I want a Data.Array.MArray to hold the widget handles?
14:46:57 <dmhouse> Or Data.Array.IO
14:52:51 <foxy_> what do I do about an unapplicable darcs patch?  (darcs get --partial http://darcs.haskell.org/c2hs)
14:52:53 <lambdabot> Title: Index of /c2hs
14:54:55 <monochrom> I think you just need an ordinary array.
14:55:25 <shapr> Hiya Averell
14:55:38 <dmhouse> monochrom: Oh, I see.
14:55:43 <Averell> hi
14:55:55 <shapr> Averell: Learning Haskell?
14:56:00 <Averell> probably
14:56:05 <shapr> Sounds like fun to me.
14:56:19 <dmhouse> Sounds like a great idea.
14:56:28 <monochrom> Doesn't hurt to use an IOArray.  Both works.  I'm a minimalist (in minimizing the use of mutables) so I go for an immutable array/list.
14:56:30 <shapr> Learning Haskell was good for me.
15:01:11 <dmhouse> @hoogle concatMapM
15:01:12 <lambdabot> No matches found
15:01:18 <dmhouse> Aww.
15:01:59 <dmhouse> @hoogle zipM
15:02:00 <lambdabot> Monad.mapAndUnzipM :: Monad a => (b -> a (c, d)) -> [b] -> a ([c], [d])
15:02:00 <lambdabot> Control.Monad.mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
15:03:58 <palomer> @palomer
15:03:58 <lambdabot> Scalliwags!
15:06:47 <palomer> whew, my frown grammar has a shift reduce conflict
15:07:07 <dcoutts> foxy_, I don't get the same, it works fine for me, try again perhaps, what darcs version?
15:07:12 <palomer> http://www.rafb.net/paste/results/QpY8at23.html <--how could this possibly have a shift reduce conflict?
15:07:57 <foxy_> dcoutts, I just pulled again:
15:07:58 <foxy_> Unapplicable patch:
15:08:00 <foxy_> Wed May 18 19:42:11 New Zealand Standard Time 2005  chak@cse.unsw.edu.au
15:08:01 <foxy_>   * rearranging darcs repo
15:08:03 <foxy_>  
15:08:27 <palomer> oh, I see
15:08:37 <foxy_> ack, darcs 1.0.7
15:08:58 <dcoutts> same here
15:09:18 * dcoutts does not know
15:09:33 <dcoutts> is anyone else able to repdoduce this error?
15:09:49 <dcoutts> darcs get --partial http://darcs.haskell.org/c2hs
15:09:51 <lambdabot> Title: Index of /c2hs
15:10:11 <palomer> edwardk: you around?
15:10:13 <dcoutts> foxy_, tried without --partial, it should make no difference here as there are no checkpoints
15:12:40 <foxy_> same problem, installing darcs 1.0.8
15:15:01 <foxy_> same problem with darcs 1.0.8
15:16:56 <palomer> is happy LL(1) or LALR(k)?
15:22:18 * shapr wants to see L theta L complexity... LOL
15:23:07 <Korollary> heh
15:25:33 <dcoutts> palomer, it's LALR(1) I believe, unless you use the GLR parsing extension
15:29:01 <kuribas> palomer: may I ask what you are working on?
15:32:03 <kuribas> (out of curiosity)
15:49:03 <DukeDave> @hoogle Int -> [a] -> [a]
15:49:04 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
15:49:04 <lambdabot> Prelude.take :: Int -> [a] -> [a]
15:49:04 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
15:49:12 <DukeDave> hmm
15:49:30 <DukeDave> @hoogle Int -> [a] -> [[a]]
15:49:31 <lambdabot> No matches, try a more general search
15:49:40 <emertens> @hoogle unfoldr
15:49:41 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
15:49:41 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
16:03:15 <shemale_magic> well
16:03:20 <shemale_magic> is there an oo db in haskell?
16:03:29 <shemale_magic> or such a thing as a functinal database?
16:09:51 <CosmicRay> shemale_magic: yes
16:09:58 <CosmicRay> shemale_magic: I think HaskellDB may be what you're after
16:12:10 <DukeDave> hey gang
16:12:25 <DukeDave> I have a list of lists containing 3 values
16:12:48 <DukeDave> and a list (through replicate) of functions which take 3 values
16:13:15 <DukeDave> could do with a function to return the list of the functions applied to the lists
16:14:54 <CosmicRay> DukeDave: look at the Zip functions in Data.List, I think.
16:15:09 <CosmicRay> maybe zipWith
16:15:12 <CosmicRay> not quite sure.
16:15:22 <greenrd> DukeDave: zipWith ($) functions listoflists
16:33:02 <asbeta> could you tell me what is the fastest possible "desugaring" of list comprehension? now i'm using: [ exp | var <- exp', Q ] = concat (map f exp') where f var = [ exp | Q ] && [ exp | exp', Q ] = if exp' then [ exp | Q ] else []
16:36:08 <dcoutts> @localtime dons
16:36:10 <lambdabot> Local time for dons is Sun Jul 16 09:31:47 2006
16:36:53 <dcoutts> CosmicRay, did I tell you I'd found out what to replace the deprecated ldap functions with ?
16:37:03 <ADEpt> @paste
16:37:03 <lambdabot> http://paste.lisp.org/new/haskell
16:37:35 <lisppaste2> ADEpt pasted "Why doesn't it work without explicit "yield" ?" at http://paste.lisp.org/display/22658
16:37:41 <dcoutts> CosmicRay, ldap_unbind_ext apparently. http://www.openldap.org/lists/openldap-software/200508/msg00487.html
16:37:53 <CosmicRay> dcoutts: yes.
16:38:07 <dcoutts> CosmicRay, ok :-) I couldn't remember :-)
16:38:09 <CosmicRay> dcoutts: I am rather mystified about all this.
16:38:14 <CosmicRay> the manpage doesn't document it at all.
16:38:16 <dcoutts> oh yes?
16:38:18 <CosmicRay> it isn't in the LDAP RFC
16:38:20 <dcoutts> oh
16:38:21 <CosmicRay> and ldap_unbind is
16:38:26 <CosmicRay> I don't understand how it could be deprecated
16:38:28 <dons> dcoutts: yeah, that sounds sensible (your points about openFile/openBinaryFile)
16:38:31 <CosmicRay> or how to use the replacement.
16:38:35 <ADEpt> anyone with ghc newer than 6.4.1 care to look at my paste and try it out?
16:38:41 <CosmicRay> it seems like a bug in openldap to me.
16:38:46 <CosmicRay> rather, a poor design decision.
16:38:48 <dcoutts> morning dons :-)
16:38:57 <dons> morning :)
16:39:35 <dcoutts> CosmicRay, aye, I wonder what the best thing to do is, for the moment you can use -DLDAP_DEPRECATED
16:40:02 <dcoutts> dons, I've got N different versions of the Fusion module working and passing the props quickcheck tests
16:40:17 <dcoutts> dons, including a version using Stream (except for mapAccumL/R)
16:40:25 <dons> yay!
16:40:28 <dons> ?karma+ dcoutts
16:40:29 <lambdabot> dcoutts's karma raised to 15.
16:40:33 <CosmicRay> dcoutts: OK.  Should I add that to ghc-opts or is there a better cabal way for that now?
16:40:45 <CosmicRay> I'm concerned about whether adding it to ghc-opts will do the right thing for hsc2hs
16:40:53 <CosmicRay> or maybe it doesn't matter?
16:42:14 <dons> dcoutts: so what's the result of Bulat's comments? Have we clarified the openBinary issue?
16:42:23 <dons> also, I'm happy now to remove hGetLines, I think
16:42:25 <palomer> kuribas: an abc parser (for now)
16:43:16 <dcoutts> dons, Bulat has not replied yet, but I think I convinced myself that openBinaryFile/openFile is right for ByteString/ByteString.Char8 resp
16:43:30 <dcoutts> CosmicRay, I'll check
16:44:21 <dons> dcoutts: yeah, it sounds reasonable, I think.
16:47:02 <dcoutts> CosmicRay, how about cc-options
16:47:11 <dcoutts> I think that gets used for hsc2hs
16:47:18 <dcoutts> check with setup build -v
16:47:51 <foxy_> dons, I just sent a patch to you for Yi
16:48:04 <dons> yeah I saw! thanks :)
16:48:28 <foxy_> dcoutts, how does gtk2hs handle signal handling on windows? (A source ref would do :)
16:50:55 <dcoutts> foxy_, not quite sure what you mean, do you mean unix style signals or widget event/signals?
16:51:08 <foxy_> unix style signals
16:51:29 <dcoutts> there are no unix style signals on win32 so it's not an issue :-)
16:51:44 <dcoutts> you'll have to explain what your concern is
16:51:56 <CosmicRay> dcoutts: ok, thanks
16:52:06 <foxy_> Yi uses Posix signals and I'm wondering how to fashion a win32 analog
16:52:22 <SamB> uses them for what?
16:52:56 <foxy_> e.g.:
16:52:57 <foxy_>     -- make sure we pass \^C to the editor
16:52:59 <foxy_>     installHandler sigINT (Catch (return ())) Nothing
16:54:24 <Korollary> well, the idiom doesn't exist for win32 programs which are normally no console apps, right?
16:54:54 <foxy_> A GUI program should still accept Control-C?
16:55:34 <Korollary> as a valid keypress
16:57:19 <palomer> who wants to play "let's find the reduce/reduce conflicts" ?
16:57:57 <dcoutts> dons, so next is getting the lists bits of each fusion system working and then benchmarking
16:58:11 <dcoutts> dons, I'll send some patches at some point
16:58:34 <dons> anything I can look at today?
16:58:41 <dcoutts> yeah, probably
16:58:45 <dcoutts> dons, btw, what patches did Bulat send?
16:58:59 <dons> not sure yet, i'll have to decode his emails
16:59:05 <dcoutts> heh
16:59:08 <dons> something for split/lines?
16:59:12 <dcoutts> yeah
16:59:26 <dons> ah, there is a patch!
16:59:34 <dcoutts> remember I did a lot of optimisation work on the lines function, especially for .L:zy
16:59:35 <dons> Simplified and unified lazy hGetContentsN/hGetN/hGetNonBlockingN
16:59:40 <dons> yeah
16:59:44 <dons> i'm wary
16:59:52 <dcoutts> to try and get the sumfile benchmark running quicker
17:00:09 <dons> -optc-O1 is no more required (because we don't use -optc-O2 by default)
17:00:15 <dcoutts> and to decrease the gap between the strict and lazy timings for sumfile
17:00:17 <dons> hGetNonBlocking=hGet on non-GHC platforms
17:00:20 <dons> lots of patches
17:00:30 <dons> Simple implementation of getArgs for non-GHC platforms
17:00:43 <dcoutts> we don't need getArgs at all methinks
17:00:43 <dons> about 10 patches1?
17:00:56 <dons> you didn't have to write hmp3's arg handling code ;)
17:01:04 <dcoutts> heh, no I didn't
17:01:14 <dons> (I agree, maybe not, but its 5 lines, so its not too harmful)
17:01:20 <dcoutts> but that code could be done outside of ByteString anyway
17:01:28 <dcoutts> since we provide enough low level bits
17:01:35 <dons> 'interact' for strict ByteString
17:01:46 <dcoutts> that makes little sense for strict
17:01:48 <dons> oh, [getLine/hGetLine for lazy ByteString
17:02:08 <dcoutts> if it's in one email then feel free to forward it to me, if it's 10 emails then I'll leave them to you :-)
17:02:30 <dons> i'll forward it anyway, but i'll go through today and try to separate the wheat from the chaff :)
17:02:38 <dcoutts> aye ;-)
17:02:45 <CosmicRay> say, quick hmp3 question.  what do you use for an id3 tag handler?  has anyone written a binding for id3lib?
17:03:00 <CosmicRay> and would there be any interesting hmp3/hpodder integration possibilities?
17:03:26 <dons> currently hmp3 just reads the text that mpg321 spits out in its special text protocol (so mpg321 is doing the id3 handling)
17:03:34 <dons> but it would be better to do it ourselves
17:03:42 <dons> hmm
17:03:47 <dons> integration
17:03:56 <CosmicRay> ah.
17:04:04 <dons> i've thought about it. would be reasonable
17:04:08 <edwardk> hmp3 is just a front end right? doesn't do the actual mp3 encoding in haskell does it?
17:04:15 <CosmicRay> I am having some strange problems with calling /usr/bin/id3v2 to set id3 tags in hpodder.
17:04:15 <dons> right
17:04:16 <edwardk> heh doh, web page answered that right away
17:04:20 <CosmicRay> sometimes, id3v2 just doesn't.
17:04:27 <CosmicRay> so I've been pondering a binding.
17:04:53 <CosmicRay> I have verified this by passing the same args to id3v2 on the command line, so it's not just me having a bug ;-)
17:04:57 <edwardk> dons: what other data structures are missing from haskell right now that you've felt a need for?
17:05:10 <CosmicRay> dons: do you have an ncurses binding as well?
17:05:53 <dons> CosmicRay: yes, in fact a _curses_ binding, so it even works on irix
17:06:01 <dons> its a very lightweight binding, imo
17:06:31 <CosmicRay> heh, "even works on irix" sounds about as difficult as "even works on AIX" ;-)
17:06:42 <dons> hehe
17:06:48 <dons> edwardk: hmm. regexes
17:07:15 <edwardk> heh, figures. the other thing that i want/need ;)
17:07:22 <edwardk> evil evil language =)
17:07:39 <palomer> http://www.rafb.net/paste/results/78Xnmm75.html
17:07:55 <palomer> anyone willing to help me hunt down the reduce/reduce conflicts?
17:07:59 <palomer> the grammar has 3 productions
17:10:33 * palomer looks expectedly at edwardk 
17:10:34 <edwardk> dons: of course to get a good regexp i need a good unicode layer on your lazy byte strings =)
17:10:39 * edwardk hides.
17:10:43 <dons> bah
17:11:42 <edwardk> it doesn't like your abcline format i guess
17:11:50 <int-e> palomer: one conflict is that the grammar for abcMusic is ambiguous - is 'BarLine {}  , pitch  ,  LineBreak ;' to be parsed as one or as two abcLine?
17:12:32 <edwardk> would break the rule into one that matches barline, and then matches  nothing or pitch then linebreak and one that matches pitch then linebreak
17:12:49 <greenrd> Is there any blog software written in haskell?
17:12:58 <int-e> abcLine: many BarLine {}  , pitch  ,  LineBreak ;  could do the trick
17:13:14 <int-e> hmm. almost at least.
17:13:27 <dons> greenrd: lambdaFeed?
17:13:31 <dons> ?where lambdaFeed
17:13:31 <lambdabot> I know nothing about lambdafeed.
17:13:40 <dons> ?google lambdaFeed site:cse.unsw.edu.au
17:13:41 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
17:13:41 <lambdabot> Title: Manuel M T Chakravarty - lambdaFeed
17:13:44 <dons> that's it
17:13:55 <dons> ?where+ lambdaFeed http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
17:13:55 <lambdabot> Done.
17:14:02 <edwardk> abcline = barline, optpitchline | pitchline; optpitchline = (nothing) | pitchline; pitchline = pitch, linebreak;
17:14:09 <jgrimes> greenrd, Hope has a blog module
17:14:11 <edwardk> rewritten in the appropriate grammar
17:14:24 <jgrimes> @where hope
17:14:25 <lambdabot> http://hope.bringert.net/
17:15:04 <greenrd> jgrimes: ah yes, I'd forgotten about that
17:15:05 <greenrd> cheers
17:15:12 <edwardk> heh, well, using the opt in the language that can be reduced by removing the optpitchline rule and replacing it with ... opt pitchline
17:15:38 <edwardk> abcline = barline, opt pitchline; pitchline = pitch, linebreak;
17:15:54 <edwardk> er abcline = barline, opt pitchline | pitchline; pitchline = pitch, linebreak;
17:15:57 <edwardk> missed a case
17:16:05 <palomer> whoa whoa whoa
17:16:11 <edwardk> use the one after er
17:16:38 <palomer> int-e: one, of course, each abc-line has one linebreak
17:16:48 <palomer> edwardk: where's the reduce conflict?
17:16:59 <dcoutts> sjanssen, btw what did you decide in the end for the representation of unicode strings ?
17:17:17 <sjanssen> dcoutts: yes, Word32s
17:17:18 <edwardk> palomer: between the abcline barline and abcline barline pitch linebreak paths
17:17:25 <sjanssen> essentially UCS-4
17:17:27 <dcoutts> sjanssen, right
17:17:30 <palomer> ahhh, I see
17:17:33 <edwardk> when it reads the barline it doesn't know if it should collapse the first rule or if it should continue the second
17:17:45 <palomer> yes, I forgot a linebreak
17:17:46 <edwardk> hence the conflict
17:17:46 <dcoutts> sjanssen, or equivalently, Char :-)
17:17:56 <edwardk> that would probably help =)
17:19:15 <palomer> what kind of look ahead do I get with LALR(k) ?
17:19:29 <edwardk> infinite, thats what the k is for =)
17:19:39 <sjanssen> dcoutts: I'm planning on shoehorning the current ByteString code into a StorableVector data type, that way most of the code can be shared between ByteString and Unicode
17:19:50 <edwardk> lalr(1) looks ahead 1, lalr(2) looks ahead 2...
17:19:59 <palomer> isn't that simply all of the CFGs?
17:20:35 <sjanssen> dcoutts: therefore I will be bugging you and dons incessantly when I try and make the fusion stuff generic ;)
17:20:56 <dgoldsmith> sjanssen: 32 bit Unicode is called UTF-32 these days...
17:21:04 <dcoutts> sjanssen, though it can't be unified with utf8 or utf16
17:21:30 <dcoutts> sjanssen, but yes one could have a generic fusable sequence lib
17:21:33 <sjanssen> dcoutts: yeah, but UTF16 could be a StorableVector Word16 with extra parsing logic
17:22:01 <edwardk> i think there is a distinction, coz not every LL(k) grammar can be encoded as n SLR(k) or LALR(k) grammar
17:22:52 <edwardk> i confess, i'm a little fuzzy on it coz i haven't thought about it formally in a while
17:25:28 <palomer> well, thx to both int-e and edwardk !
17:26:42 <wilx> I thought LL(k) was a subset of LR(k) grammars.
17:27:33 <dcoutts> dons, looks like there are some little bits we can extract from that 10-patch set
17:27:47 <dgoldsmith> sjanssen: yes, it turns out surrogate pairs are so rare in real text that they can be handled as an exceptional case
17:29:26 <sjanssen> dgoldsmith: they still must be handled, and that means O(n) indexing or extra bookkeeping
17:29:36 <edwardk> i think i might be a little mixed up, ELL(k) contains LL(k) and there are ELL(k) grammars that aren't LALR(k)
17:29:37 <dcoutts> dgoldsmith, my representation for UTF16 would be a record with a ptr, byte offset, byte length and char length
17:30:12 <dcoutts> so it the cases where byte length = 2 * char length you know you've got no surrogate pairs and can do O(1) indexing
17:30:17 <sjanssen> and I can't imagine how one would do fusion with UTF16, and fusion seems to be a big win
17:30:29 <dcoutts> err 2 * byte length = char length
17:30:34 <dgoldsmith> If you're willing to express algorithms in terms of code units (UTF-16) instead of code points (Char) then you can just treat it as an array of code units.
17:30:46 <dgoldsmith> If it has to be Char then yes, some operations get slower.
17:31:08 <sjanssen> that isn't an option if you want map :: (Char -> Char) -> String -> String
17:31:10 <dcoutts> most people don't use indexing much on strings though, because it's so slow on String
17:31:20 <dcoutts> so I don't think it's that high a priority
17:31:26 <sjanssen> because Char is defined as a Unicode code point in Haskell
17:31:52 <edwardk> so has anyone applied the fusion techniques to get something like boost's micro-blas in haskell yet?
17:32:07 <dgoldsmith> It's easy to do (Char -> Char) -> UTF16String -> UTF16String
17:32:47 <dcoutts> dgoldsmith, it needs to check for each code unit if there's a following surrogate
17:33:21 <dgoldsmith> dcoutts: no, you can tell whether a code unit is part of a surrogate pair just by looking at it
17:33:23 <dcoutts> so there's a bit of an overhead, but probably it is still faster to do that than use 32bit always
17:33:39 <dcoutts> dgoldsmith, yes I know
17:33:52 <dgoldsmith> sorry...
17:34:22 <dgoldsmith> yes, there is a bit of overhead on each code unit to test whether it is part of a pair or not
17:34:26 * dcoutts wishes there was a pragma to indicate the liklyhood of a conditional test
17:34:26 <edwardk> wait, the issue here is that its hard to transform strings with utf8? whats wrong with (UTF16Char -> UTF16Char) -> String -> String ?
17:34:33 <dgoldsmith> time/space tradeoff
17:34:40 <edwardk> then you just unpack into the utf16 char and call your function and wrap it up on the way out
17:34:44 <dcoutts> correctly predicted conditional jumps are nearly free
17:34:46 <edwardk> or am i missing something?
17:35:17 <dcoutts> edwardk, we want (Char -> Char) -> UTF16String -> UTF16String
17:35:28 <edwardk> whats the size of char defined to be?
17:35:33 <dcoutts> 32bit
17:35:35 <edwardk> ah k
17:35:37 <dgoldsmith> right, with a type like (UTF16Char -> UTF16Char) -> String -> String you can't handle a surrogate pair when you encounter one
17:35:46 <dcoutts> and yes, all you need to do is check if each utf16 code is part of a surogate pair (cheap)
17:36:05 <dcoutts> and on getting a Char back checking if that needs to be encoded as a pair
17:36:11 <dcoutts> and 99% of the time it doesn't
17:36:19 <edwardk> dgoldsmith i was presuming that utfxx char was bigger than the char in string thinking that string used single bytes as its char type
17:36:33 <dgoldsmith> ah
17:36:47 <edwardk> so we said the same thing, i just didn't understand the haskell convention =)
17:36:55 <dgoldsmith> strictly speaking, a Unicode code point is 21 bits, but there probably is no good way to take advantage of that
17:36:58 <edwardk> yeah
17:36:59 <dcoutts> sjanssen, have you seen the new streams fusion framework ?
17:37:13 <sjanssen> dcoutts: I don't think so
17:37:18 <dcoutts> sjanssen, that might make handling of utf8/16 rather easier actually
17:37:35 <dcoutts> if the encoding can be handled in the stream reader/writer primitives
17:38:05 <dcoutts> it'd also allow to eliminate ajdacent re-encodings and go via Char
17:38:28 <sjanssen> dcoutts: streams as in Bulat Ziganshin's library?
17:38:52 <dcoutts> sjanssen, no, streams as a style of doing fusion in the ByteString context
17:39:30 <dcoutts> eg imagine map f . map g, on utf8 say, we can eliminate the encoding of 1-3 bytes -> Char  and back again and go directly via Char
17:39:36 * dgoldsmith has to run
17:40:08 <dons> yeah, sjanssen, we have a new set of basic combinators, based on an unfold-style generator
17:40:26 <dcoutts> readStrUp :: ByteString -> Stream
17:40:28 <dcoutts> writeStrUp :: Stream -> ByteString
17:40:43 <dcoutts> and then functions which operate on this Stream of chars
17:40:59 <dcoutts> then we fuse by eliminating adjacent pairs of readStrUp . writeStrUp
17:41:09 <dcoutts> it's all rather neat
17:41:22 <sjanssen> is this Stream stuff in the darcs repo?
17:41:23 * dons marvels at how firefox+fasterfox is able to start creating collisions on his LAN
17:41:23 <dcoutts> and would work fine for UTF8/16 I reckon
17:41:49 <dcoutts> sjanssen, not the main one yet, it's still a bit experimental
17:42:46 <dcoutts> dons, btw, I think it's somethign we might want to mention in the paper, that the Streams should be able to do multi-byte representations (assuming I'm right about that :-) )
17:42:55 <dcoutts> better than the previous system
17:42:58 <dons> hmm. yes. good point
17:43:22 <dcoutts> since the loopU style only allows 0 or 1 bytes output from each input
17:43:51 <dcoutts> but UTF8/16 allows some single unit inputs to correspond to multi-unit outputs
17:43:52 <dcoutts> eg map
17:44:03 <dons> yeah. tricky
17:44:30 <sjanssen> is there a repo for this on the web?
17:44:35 <dcoutts> dons, you'd jsut need to change readStrUp/writeStrUp
17:45:07 <dcoutts> dons, all the Stream stuff would operate at the Char level
17:45:18 <dons> Bulat so happily breaks the api without explanations :S /me has to think hard about some of these patches
17:45:33 * dcoutts chuckles
17:45:45 <dons> sjanssen: currently we're planning to develop in fps-unstable (in the same place as fps lives now)
17:45:45 <dcoutts> sjanssen, there will be soonish
17:45:54 <dons> but so far the streams patches are only on dcoutt's box
17:46:15 <dcoutts> oh and in the ndp darcs repo
17:46:23 <dcoutts> which is more generic
17:46:44 <dcoutts> but last time I looked it didn't cover as many examples
17:48:54 <dons> yeah, the ndp stuff is mostly concerned with zips. well, in particular zips
17:49:03 <dons> zips and permutes
17:49:41 <dons> i'm going to need some coffee before i process these patches..
17:50:18 <dcoutts> I can go through them with you if it helps
17:52:03 <dons> oh, i think some I'll be able to apply, others I'll CC. you and bulat, and try to get some clarification about what he's thinking
17:52:58 * dcoutts doesn't grok the first patch, that stuff was all very subtle
17:53:14 <dcoutts> the second on is fine, we don't need -optc-O1
17:53:57 * dcoutts would drop getArgs so patch 4 can be ignored
17:53:58 <dons> yeah
17:54:37 <dons> I'm still not sure about this text mode stuff, it'll need warnings
17:54:39 <dcoutts> the text/binary mode stuff is relevant, though the patch is to the wrong files
17:54:52 <dons> if someone trys to mix Char8 and normal ByteStrings (as we can do now)
17:55:06 <dons> i.e. if they read using Data.ByteString.readFile, then run 'lines'
17:55:11 <dons> they'll end up with \r's on windows
17:55:15 <dcoutts> dons, but that's ok
17:55:26 <dcoutts> that's what they asked for
17:55:41 <dcoutts> ByteString and ByteString.Char8 is just a matter of interpretaion
17:55:41 <dons> i suppose the story is: we need to use binary mode (for, say, binary parsers)
17:55:55 <dons> but windows people need newline handling, and there's only one place for that
17:55:59 <dcoutts> the ByteString and .Lazy should be binary, the .Char8 should be text mode
17:56:03 <dons> yeah
17:56:05 <dons> ok
17:56:36 <dcoutts> you'd need to work pretty hard to use Data.ByteString.readFile and lines
17:56:45 * edwardk bites the bullet and starts thinking about regexps
17:56:49 <sjanssen> should .Char8 be a newtype of ByteString?
17:56:59 <dcoutts> since you'd need to import both Data.ByteString & Data.ByteString.Char8 qualified
17:57:13 <dcoutts> sjanssen, we decided not
17:57:44 <dons> yeah, the first patch is the worry, isn't it
17:57:53 <dons> that's very subtle. he's removing a case we spent time checking for
17:58:03 <dcoutts> yeah
17:58:04 <dons> -            m | m == i -> return [ps]
17:58:15 <dons> and i'm not sure he's running the QC tests
17:58:24 <dons> i'll just have to ponder that one
17:58:34 <dcoutts> perhaps that's related to his "hGetNonBlocking=hGet on non-GHC platforms" patch
17:58:39 * dylan slaps his irc client -- haskell is not morse code
17:58:45 <dcoutts> dons, don't ponder, ask for justification
17:58:48 <dons> the mallocByteString = mallocForeignPtrBytes | mallocPlainForeignPtrBytes patch is ok. i asked for that
17:59:09 <dcoutts> justification/explanation
17:59:10 <dons> but then in the final patch, he changes the fromForeignPtr api
17:59:28 <dcoutts> methinks that's not necessary
17:59:34 <dcoutts> I'd like a use case first
17:59:37 <dons> which i don't really like, since you'd just plusPtr it to do a slice
17:59:50 <dons> whereas he wants to pass an explicit offset in
17:59:57 <edwardk> ....  .-  ...  -.-  .  .-..  .-.. sure it is =)
18:00:07 <dcoutts> well you can't plusPtr because it's a ForeignPtr
18:00:29 <dcoutts> changing the value of a ForeignPtr is cheating
18:00:40 <dcoutts> it'd upset the GC/finaliser I think
18:00:47 <edwardk> well, i guess you couldn't write haskell in morse code. can't get upper case letters for types.
18:01:04 <dylan> not a valid .... .- ... -.- . .-.. .-.. expression.
18:01:07 <dons> oh, you'd have to newForeignPtr it hmm
18:01:23 <edwardk> dylan: that was just the name 'haskell'
18:01:27 <dons> edwardk: google for 'remorse' haskell
18:01:30 <dons> ;)
18:01:31 <dylan> edwardk: I know.
18:01:34 <dcoutts> why do we need getLine/hGetLine for lazy ByteString?
18:01:48 <dons> i guess he's on an api synchronicity drive
18:01:53 <dylan> edwardk: irssi automatically translates anything it thinks is morse code.
18:02:41 <edwardk> heh, well, that simplifies matters i guess
18:02:55 <dcoutts> getLine is bad for the lazy chunk size
18:02:57 <edwardk> until it goes wrong
18:02:57 <SamB_XP> ... why?
18:02:59 <dcoutts> it'll make IO slow
18:04:20 <dcoutts> lazy ByteString should use lazy IO for best IO performance
18:04:30 <lucca> .-.-.- .-.-.- .-.-.- .-.-.-
18:05:19 <edwardk> hahaha thats pretty funny
18:05:23 <dons> dcoutts: right, it looks like a trap for the user
18:05:27 <edwardk> (just read the remorse sourcecode)
18:06:27 <dcoutts> dons, aye
18:31:52 <lispy> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:31:53 <lambdabot> forall t67 t66 t65 t64 t63 t62 t61 t60 t59 t58 t57 t56 t55 t54 t53 t52 t51 t50 t49 t48 t47 t46 t45 t44 t43 t42 t41 t40 t39 t38 t37 t36 t35 t34 t33 t32 t31 t30 t29 t28 z y x w v u t s r q p o n m l k
18:31:54 <lambdabot> j i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 ->
18:31:54 <lambdabot> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 ->
18:31:54 <lambdabot> t63 -> t64 -> t65 -> t66 -> t67 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44,
18:31:56 <lambdabot> t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67)
18:32:13 <lispy> i expected some truncation there...guess not
18:32:59 <lispy> ah, if you do enough comas it will truncate
18:33:03 <lispy> well that's good
18:35:51 <greenrd> Isn't there an a missing there?
18:36:11 <greenrd> j i h g f e d c b a. -> b -> c should be j i h g f e d c b a. a -> b -> c
18:41:15 <lispy> yup
18:41:18 <lispy> that looks like a bug
18:48:44 <greenrd> @type (,,)
18:48:45 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
18:48:53 <greenrd> @type (,,,,,,,,,,,,,,,,,,,,,,,,)
18:48:54 <lambdabot> forall y x w v u t s r q p o n m l k j i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (a, b, c, d, e, f,
18:48:54 <lambdabot>  g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
18:49:06 <greenrd> @type (,,,,,,,,,,,,,,,)
18:49:07 <lambdabot> forall p o n m l k j i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
18:49:11 <greenrd> @type (,,,,,,,,)
18:49:12 <lambdabot> forall i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
18:49:18 <greenrd> @type (,,,,,)
18:49:20 <lambdabot> forall f e d c b a. a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
18:49:27 <greenrd> @type (,,,,,,)
18:49:28 <lambdabot> forall g f e d c b a. a -> b -> c -> d -> e -> f -> g -> (a, b, c, d, e, f, g)
18:49:34 <greenrd> @type (,,,,,,,)
18:49:35 <lambdabot> forall h g f e d c b a. a -> b -> c -> d -> e -> f -> g -> h -> (a, b, c, d, e, f, g, h)
18:49:47 <greenrd> @type (,,,,,,,,)
18:49:48 <lambdabot> forall i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
18:49:53 <greenrd> odd
18:50:50 <greenrd> It strikes me that this is a good visual way to explain binary search to an undergraduate class :)
18:53:11 <lispy> greenrd: try it in ghci and I bet the problem comes when you get a single line printed out that looks like, "-> (a,"
18:54:20 <lispy> hmm...perhaps i'm wrong
19:01:00 <lispy> @tell dons @type (,,,,,,,,) vs. @type (,,,,,,,) notice the former has a missing type variable 'a' in the output.
19:01:01 <lambdabot> Consider it noted.
19:01:47 <dons> hmm
19:01:47 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:02:22 <dons> ah, i see
19:09:43 <palomer> ho my
19:09:51 <palomer> frown is somewhat buggy
19:10:42 <palomer> though it's otherwise quite nice
19:12:13 <edwardk> hrmm. in general with data structure kinda stuff is it considered better form to throw the methods for manipulating it into a class and then have your type be an instance of the class or to have them be names exported by the module? i ws thinking the former might avoid cluttering the namespace, but might have a performance hit associated with carrying the dictionary around.
19:12:55 <palomer> either way you're polluting the namespace
19:13:12 <palomer> if I understand the question correctly
19:13:28 <palomer> in fact, if you define a new class with a single instance, you're also polluting the class namespace
19:13:43 <edwardk> can i import classes that have methods with the same name and different signatures though?
19:14:51 <palomer> sure
19:14:59 <palomer> err wait
19:15:01 <palomer> no
19:15:04 <dons> hmm. there's some arguments for both
19:15:14 <int-e> you can import them but you can't use them then ;)
19:15:17 <dons> i.e. we have Foldable classes, but we don't have Map classes
19:15:29 <edwardk> heh
19:15:33 <edwardk> well, its progress =)
19:15:44 <int-e> (not unqualified that is. importing qualified is the usual workaround.)
19:15:50 <dons> one key thing is to use QuickCheck to write down machine checkable properties for your api
19:15:55 <dcoutts> but what would a Map class look like?
19:15:56 <edwardk> ok, so you can't use the methods that clash in that case
19:15:57 <dons> it really really improves the code quality
19:16:41 <dons> dcoutts: so some kind of class for data structures that provide !!
19:16:42 <int-e> if you expect other things could reuse the interface - put it in a type class. if you're just worried about stealing precious names, that's what qualified imports are for. in my humble opinion.
19:16:42 <dons> ?
19:16:50 <palomer> edwardk: when you define your class, you're adding functions to the namespace; the only special thing about these functions is they have class constraints
19:16:53 <edwardk> dons: yeah, i want to slap together some quickcheck stuff, i'm just trying to avoid having to have people use qualified to use the code. i find qualified clode a little clunky. =)
19:17:01 <dcoutts> for exmple: class Functor (f::* -> *) where fmap :: (a -> b) -> f a -> f b
19:17:04 <palomer> make that function names
19:17:07 <edwardk> er
19:17:12 <edwardk> whoa nonsequitor
19:17:21 <edwardk> i got distracted in the middle of typing that.
19:17:27 <dons> yeah, i figured
19:17:29 <dcoutts> however that doesn't cover map for things like ByteString or unboxed arrays, or bitmaps of pixels
19:17:31 <dons> just assumed brain explosion
19:17:33 <edwardk> heh
19:17:47 <edwardk> fiancee came in room and asked questions about food =)
19:18:04 <int-e> better make sure you answered that coherently ;)
19:18:09 <dcoutts> since sych things are not paramaterised by the element type, they have a fixed element type
19:18:14 <edwardk> forgot i'd had something half typed when i started to make a second statement
19:18:27 <dons> i want to slap together some quickcheck stuff, but yes, sex is good
19:18:29 <edwardk> ok, so namespace pollution is generally ignored in haskell code?
19:18:30 <palomer> "yeah honey, class food where pie:: kitchen -> mouth"
19:18:31 <dons> oopes
19:18:40 <dons> girlfriend walked in
19:19:00 <palomer> did she disagree?
19:19:31 <dons> edwardk: you don't want to overlap System.IO, unless you're the author of Data.ByteString
19:19:39 <edwardk> heh
19:20:00 <dons> so we do try to avoid it. unless the functionality is very similar to something existing, then you should _try_ to overlap
19:20:06 <palomer> classes help alleviate namespace pollution _if several types implement the class_
19:20:13 <dons> i.e. having !! and ! is bad, imo
19:20:24 <edwardk> so if you have two classes that have members named 'new' for instance then you have to impor the modules qualified to call new on either?
19:20:37 <int-e> dons: having !! is bad ;)
19:20:42 <dons> yeah
19:20:49 <edwardk> ick
19:20:56 <palomer> also, you shouldn't worry about performance
19:20:59 <dons> P.new Q.new
19:21:00 <dons> easy
19:21:05 <edwardk> yeah
19:21:18 <edwardk> i obsess about performance. its admittedly a curse =)
19:21:29 <dons> you have a benchmark suite?
19:21:34 <edwardk> not in haskell yet
19:21:37 <palomer> the compiler does more than you think
19:21:40 <int-e> edwardk: and the user can choose her favourite prefix for her code.
19:21:40 <edwardk> yeah
19:22:18 <edwardk> i benchmarked just about everything in my javascript javascript implementation. i was putting together the generic hash code to have something to profile to get my head around haskell speed optimizations
19:22:35 <edwardk> but i really don't like the way the types have had to go with that
19:22:43 <int-e> edwardk: that's a good argument against avoiding namespace pollution by adding a package specific prefix to everything the module exports, I think.
19:22:44 <dons> you could steal the benchmarking system from fps
19:22:51 <edwardk> so i think i may stick to the less general interfaces until we get class associated types
19:22:56 <dons> it also lets you do space benchmarking
19:23:13 <int-e> edwardk: err s/package/module/ packages didn't really enter the picture.
19:24:01 <edwardk> so, i presume that abusing the c preprocessor for haskell is considered bad form? =)
19:24:41 <dons> generally only for constants and ghc versions is acceptable
19:24:45 <edwardk> yeah
19:24:51 <edwardk> kinda figured
19:24:56 <dons> so __GLASGOW_HASKELL__ >= 605, or !defined(__GLASGOW...
19:25:21 <palomer> what's that knuth quote? premature ...
19:25:36 <dons> its really useful to install the fptools and just read Data.* when you're working on this stuff
19:25:45 <dons> Data.Map is the canonical example, I think
19:25:48 <edwardk> palomer: i actually am not looking at abusing that sort of thing for speed. i'm looking at it to avoid typing ;)
19:28:42 <edwardk> ok, last question. =)
19:29:02 <edwardk> better form to provide each hash with an explicit hashing function. or to make a hashable class and define good performance defaults for all cases.
19:29:12 <edwardk> the latter case gives me natural hasing functions for tuples, etc.
19:29:18 <edwardk> the former requires more end user support
19:29:29 <dons> I think a Hash class is quite an interesting idea.
19:29:33 <dons> Since its like Ix
19:29:35 <edwardk> yeah
19:29:40 <dons> or maybe ... you can reuse Ix
19:29:48 <dcoutts> the existing hash table impl just takes a hash function on construction
19:30:03 <edwardk> class Hashable a where hash :: a -> Int
19:30:19 <edwardk> reusing Ix is awkward because not everything hashable is enumerable into ranges
19:30:22 <dons> so, interestingly, index       -- :: (Ix a) => (a,a) -> a   -> Int
19:30:26 <dons> is in Ix
19:30:32 <dons> which is almost what you're looking at
19:30:34 <edwardk> yeah Ix is where i got the idea
19:31:00 <edwardk> but I can hash references by address, etc. which you can't do with Ix, because the the ranges aren't contiguous, etc.
19:31:07 <edwardk> Ix provides more functionality than I can use or require
19:31:15 <dons> true
19:31:24 <dons> class (Ord a) => Ix a where
19:31:45 <edwardk> hashable doesn't require ord, just eq
19:32:02 <dons> so then modeling the Ix interface sounds more reasonable
19:32:07 <edwardk> *nods*
19:32:09 <dons> Hash a => a -> Int
19:32:10 <dcoutts> a hashable class makes a bit less sence that Ix I think, because you are more likely to want to have different the hash functions for data of the same type than you are with Ix
19:32:22 <dons> that's true
19:32:27 <dons> so it's more like sortBy/sort
19:32:33 <dcoutts> aye
19:33:11 <dcoutts> and since there's a single convenient place to put the hash function, in the construction of the hash table itself
19:33:16 <edwardk> hashable opens the doors to more optimizations anyways
19:33:37 <dcoutts> it's not like the class is saving you from lots of arg passing as with Eq, Ord etc
19:33:45 <dons> yep
19:34:11 <dons> ok, i've added the openFile/openBinaryFile distinction
19:34:12 <edwardk> dcoutts: my typical usage scenario has several thousand hashes running around with the same hash function used everywhere
19:34:35 <edwardk> so while i'm open to the 'right' way. i'm also loathe to bog myself down with yet another parameter =)
19:34:45 <dcoutts> edwardk, and all those hashes are created in many different parts of the code?
19:34:47 <edwardk> i'm currently using an explicit hash function
19:34:53 * dons wonders if there are some papers on hashes in pure fp 
19:35:09 <dons> always good to look at what some guy spent 6 months thinking about
19:35:18 <dcoutts> edwardk, you can't just say mkHash = Data.Hash.new myHashFunc
19:35:20 <edwardk> i'm debating about adding a hashable class. one alternative is to make two versions of 'new'
19:35:30 <edwardk> one that takes an instance of hashable and STORES the hash function into the hash
19:35:38 <edwardk> and another that lets you provide your own hash function
19:35:56 * dcoutts doesn't understand the distinction
19:36:12 <edwardk> well, Hashable would provide a standard hashing function for each type
19:36:29 <edwardk> and if you used the easy constructor it would just take it from the class.
19:36:32 <dons> do we have hashtable implementations in ocaml or clean you could look at for api ideas?
19:36:46 <edwardk> if you needed more control you could use the one where you supply it explicitly
19:36:55 <dons> in particular, Clean might have a good api with classes
19:36:56 <edwardk> haven't found much
19:37:17 <iron32> Hi all, is "->>" a standard operator in the Haskell prelude if so what does it mean ?
19:37:29 <dons> it's no operator i've heard of
19:37:32 <dons> ?hoogle ->
19:37:33 <lambdabot> Prelude.-> :: keyword
19:37:33 <lambdabot> Text.Html.(<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
19:37:34 <dons> ?hoogle ->>
19:37:34 <lambdabot> hoogle: unrecognized option `->'
19:37:34 <lambdabot> unrecognized option `->'
19:37:34 <lambdabot> HOOGLE - Haskell API Search
19:37:34 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
19:37:35 <edwardk> basically the version i have now i could get by with, but right now i'm seeking insight into what better ways there are out there. this just happens to be the usage case i have in front of me ;)
19:37:36 <lambdabot>  
19:37:39 <lambdabot> [16 @more lines]
19:37:42 <dons> yikes!
19:37:46 <dons> ndm ^^
19:37:58 <dons> @tell ndm hoogle with ->> goes insane
19:37:58 <lambdabot> Consider it noted.
19:38:02 <int-e> oh, lambdabot abuse.
19:38:28 <dcoutts> dons, the openFile patch you just added isn't what I was expecting
19:38:44 <jgrimes> dons, if you come across any papers on hashes in pure fp, do tell
19:38:47 <dons> I added one?
19:38:51 <dons> oh, no, that's old dcoutts
19:38:58 <dcoutts> dons, oh ok
19:39:00 <dons> i'm about to add one along what we've discussed
19:39:05 <dcoutts> right ok :-)
19:39:11 <iron32> dons: Thanks I though it must be user defined
19:39:53 <iron32> ?hoogle =>>
19:39:53 <dons> jgrimes: one place to look might be http://www.cs.ru.nl/~clean/Download/Download_Libraries/body_download_libraries.html
19:39:53 <lambdabot> No matches found
19:39:55 <lambdabot> Title: Download Clean 1.3 Libraries
19:41:59 <jgrimes> dons, sounds good.
19:43:58 <edwardk> http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg00996.html (from a randomm google search) has a sort of hashable class
19:43:59 <lambdabot> Title: hstags; and an old bug
19:44:34 <edwardk> i wouldn't use it, because they are lax in not breaking up symmetry in tuples
19:44:40 <edwardk> but its an idea =)
19:45:08 <edwardk> that and its typical prime hash crap
19:45:14 <edwardk> which won't work for a linear hash table
19:45:26 <edwardk> thats my big worry about letting people define their own hash functions
19:45:35 <edwardk> a lot of people just take stuff mod some prime and call it good
19:45:41 <edwardk> that works well for a fixed sized hash
19:45:59 <edwardk> but if your hash can grow that yields a bad distribution, because the modulus is a power of 2
19:46:10 <edwardk> so you have to use a mix function instead to get good results
19:48:20 <edwardk> http://www.eecs.tufts.edu/~rdocki01/docs/edison/Data-Edison-Prelude.html#t%3AUniqueHash provides a similar interface
19:49:38 <edwardk> there isn't a standardized disjointset/union-find algorithm in haskell is there? (need it in my flowgraph reducer)
19:51:05 <dcoutts> union-find is tricky to do effeciently in a pure language I believe
19:51:10 <edwardk> yeah
19:51:23 <edwardk> i have a hackish one using STM or ST at the moment
19:51:27 <int-e> the best idea I had so far was to use a Map to simulate an array ...
19:51:28 <edwardk> was curious if there was a reference implementation
19:51:33 <dcoutts> ghc uses mutable references to do it too
19:52:18 <edwardk> in fact the paper i found from peyton jones and company on ST used union-find as an example of 'stuff haskell sucks at' =)
19:52:40 <edwardk> to motivate the st monad
19:52:46 <int-e> of course, you can do it with read arrays in ST (or IO).
19:52:52 <dons> yay for ST!
19:52:53 <int-e> :)
19:53:14 <edwardk> question, are there any performance guarantees on (new|read|write)(IORef/STRef/TVar)?
19:53:36 <edwardk> i can't find anything saying O(1)|O(n), etc on them
19:53:36 <dons> hmm
19:53:55 <dons> ah, right. no. but you can expect O(1)
19:53:57 <edwardk> i realize with STM thats tricky
19:54:05 <edwardk> but the others had me curious
19:54:11 <dons> they're wrappers over Ptrs, after all. TVar might be a different story, not sure
19:54:15 <edwardk> yeah
19:54:30 <edwardk> tvars just guarantee that one process will be able get some work done
19:54:38 <edwardk> they sacrifice a lot of rigor to get there though
19:55:13 <edwardk> the proof that you won't backtrack yourself into performance-oblivion is somewhat lacking
19:55:26 <edwardk> in the case of high contention.
19:57:58 <dons> dcoutts: what do we think of the Makefile patch from Bulat. i'm inclined to say no. (just alias make='runhaskell Setup.hs build' if you like
19:58:19 <dons> i've just got 'c ; b ; i' for the three cabal phases :)
19:59:17 <dcoutts> dons, I agree, I think a Makefile may just confuse things, is it cabalised or not!?!111 ;-)
19:59:21 <int-e> I use a Makefile for that but ... I see no reason to have one in the package :)
19:59:47 <dcoutts> sorry, that should be "is it cabalised or not!?!111"
20:00:01 <int-e> in fact this way I can put my actual configuration in the Makefile. I couldn't do that so easily if it'd conflict with what's in the repository.
20:00:26 <dons> good point.
20:00:52 <dons> and when the makefile just binds one cabal command to a new name, really, the shell alias system is better, i reckon
20:01:54 <lisppaste2> int-e pasted "simple makefile ;)" at http://paste.lisp.org/display/22665
20:02:12 <int-e> maybe it's useful for someone.
20:03:40 <zarvok> I'm curious, anyone happen to know why, when I apt-get ghc, debian installs hugs as well?
20:04:19 <zarvok> seems like a strange thing to do by default
20:06:12 <jgrimes> zarvok, it is in the haskell-utils package, on which ghc6 is marked as depending...
20:06:26 <jgrimes> zarvok, but to actually answer, I'm not really sure why it is required
20:07:28 <zarvok> huh
20:07:31 <zarvok> interesting, thanks
20:07:36 <int-e> dons: actually I probably wouldn't have the makefile if cabal wouldn't remove its configuration so often. after every clean I have to reconfigure. that got on my nerves.
20:11:06 <dcoutts> int-e, hmm yes automake distnguishes make clean and make distclean
20:11:06 <dons> int-e, hmm yeah. no distclean/clean distinction
20:11:10 <dons> rm -rf dist works :)
20:11:27 <dons> dcoutts: that's scarily brain telepathy
20:11:32 <dcoutts> ;-)
20:11:35 <dcoutts> perhaps someone should suggest it
20:12:17 <dcoutts> the clean/distclean distinction is slightly more general than just the config
20:12:30 <dcoutts> it'd include prebuilt sources like happy/alex etc
20:12:42 <dons> yeah
20:12:52 <dons> really clean should wipe the .hi and .o files, no? and any libs
20:12:54 <dcoutts> though cabal doesn't currently support that kind of thing particuarly
20:13:30 <dcoutts> the tricky question is if it should wipe generated .hs files
20:13:53 <dcoutts> eg cpphs, hsc2hs, c2hs
20:14:31 <dons> hmm
20:14:45 <int-e> clean could have options. clean [--all] [--config] [--generated] ...
20:15:17 <dcoutts> I'd really also like a cabal lint
20:15:41 <dcoutts> I've got a list of mistakes I've seen during gentoo packaging that could be detected automatically
20:18:52 <dons> ah! now that _is_ a good idea
20:18:57 <dons> examples, dcoutts ?
20:19:12 <dcoutts> missing modules from extra-modules:
20:19:20 <dcoutts> using -O2 in ghc-options
20:19:26 <dons> checking the code is haddock-safe
20:19:37 <dcoutts> using -fglasgow-exts in ghc-options rather than using specific named extensions
20:19:48 <dons> yeah or -cpp
20:20:19 <edwardk> can you say {-# INLINE #-} on methods associated with classes? do you put it inside the instance or where?
20:20:30 <dcoutts> importing non-standard modules in the Setyp.lhs
20:20:50 <dcoutts> which means that the thing doesn't even compile if you're missing the dep
20:21:02 <dons> you can, edwardk
20:21:22 <dcoutts> some of these could be fixed by making cabal stricter
20:21:22 <edwardk> do i say it once in the class or one for each instance?
20:21:23 <dons> yeah, dep/import checking could be done
20:21:44 <dons> hmm. not sure. i'd expect it only makes sense in the instance
20:21:50 <dons> check Data.Array
20:21:57 <dcoutts> cabal totally lacks dep chasing
20:22:02 <int-e> dons: btw, is there any way to tell darcs that it should install the scripts/ShowQ.hs (or .o + .hi) files along with lambdabot?
20:22:04 <dcoutts> so it can't support c2hs proerly yet
20:22:12 <int-e> dons: s/darcs/cabal/
20:22:35 <dcoutts> int-e, data-files I think, or was it extra files
20:22:54 <dcoutts> yep data-files: scripts/ShowQ.hs
20:24:11 <dons> oh? int-e, want to try dcoutts suggestion?
20:24:17 <dons> we could abolish ./build then
20:24:35 <edwardk> @where ord
20:24:35 <dons> we need the .o and .hi files in a place such that runplugs can see them
20:24:35 <lambdabot> I know nothing about ord.
20:24:38 <edwardk> er
20:24:41 <dons> ?hoogle ord
20:24:41 <lambdabot> Char.ord :: Char -> Int
20:24:41 <lambdabot> Prelude.Ord :: class Eq a => Ord a
20:24:41 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
20:24:41 <edwardk> @hoogle ord
20:24:42 <lambdabot> Char.ord :: Char -> Int
20:24:42 <lambdabot> Prelude.Ord :: class Eq a => Ord a
20:24:43 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
20:24:46 <edwardk> yeah
20:24:47 <edwardk> =)
20:24:55 <edwardk> will get used to this lambdabot thing sooner or later
20:25:11 * dons blows the smoke , spins pistol, holsters.
20:25:41 <edwardk> is ?hoogle case sensitive?
20:26:02 <edwardk> or did i just overlap the rest of its answers
20:26:03 <dons> hmm, possible
20:26:10 <dons> ?hoogle Ix
20:26:10 <lambdabot> Data.Ix :: module
20:26:10 <lambdabot> Ix :: module
20:26:10 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
20:26:13 <dons> ?hoogle ix
20:26:14 <lambdabot> Data.Ix :: module
20:26:14 <lambdabot> Ix :: module
20:26:14 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
20:26:17 <edwardk> ah
20:26:17 <edwardk> k
20:26:18 <dons> possibly not
20:26:25 <edwardk> it just seemed that way coz of the order of responses on my screen
20:26:26 <dons> ?hoogle Map
20:26:26 <lambdabot> Data.Map :: module
20:26:26 <lambdabot> Data.Map.Map :: data Map k a
20:26:26 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
20:26:29 <edwardk> kk
20:26:30 <dons> ?hoogle map
20:26:31 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
20:26:31 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
20:26:31 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
20:26:35 <dons> ah, possibly maybe
20:27:33 <int-e> hmm. data-files copies it to $PREFIX/share/lambdabot-4.0/scripts/ShowQ.hs
20:28:27 <dons> yeah, its not data. it's a runtime object
20:28:38 <dons> so it _could_ go into a library, maybe
20:28:52 <dons> and we'd need to tweak some hs-plugins args to find it
20:32:32 <dons> dcoutts: you had some thoughts on whether there should be *getLine in .Lazy? yes?
20:32:48 <dons> the argument is that its inefficient, since you lose cache-chunk encoding.
20:33:04 <dons> so write in terms of getContents >>= lines instead ?
20:33:27 <dcoutts> right
20:33:57 <dons> though at the cost of 'switchability of imports'
20:34:15 <dcoutts> but they're not the same anyway
20:34:22 <dons> true
20:34:29 <dcoutts> I don't know if it's good to encourage the idea that they're the same
20:34:29 <dons> its .Char8/* that should be switchable
20:34:40 <dcoutts> they have different behaviours
20:35:14 <dons> right. like comparing Data.Array.Unboxed/Foreign/Storable/*
20:35:33 <dons> they're allowed to have different behaviour, and the user needs to understand the reasons
20:35:53 <dcoutts> using strict IO with ByteString.Lazy can be done but you loose the nice big IO requests and have to copy via the Handle buffer
20:36:12 <dcoutts> I guess it's not out of the question to have getLine
20:36:29 <edwardk> hrmm
20:36:29 <edwardk> ok
20:36:34 <edwardk> now here is a weird case =)
20:36:42 <edwardk> say i have a function like:
20:36:48 <dcoutts> but it should be noted that it's not the reccomended style, use lazy io for better style and performance
20:36:56 <edwardk> new :: (k -> Int) -> STM (THash k v)
20:36:56 <edwardk> new hash = make =<< THT.new hash
20:37:00 <edwardk> that works fine.
20:37:21 <dons> ok, maybe we add it, recommend against it
20:37:30 <dons> as we do for a couple of other things
20:37:36 <edwardk> now i want to make a variant that wants to be able to take something like newH :: Hashable k => STM (THash k v)
20:37:36 <edwardk>  and use whatever the hash function is for k
20:37:52 <edwardk> that needs to do a little class-fu, that i can't seem to figure out =)
20:38:10 <dcoutts> dons, right, perhaps explainign that it's slower since it does IO in smaler chunks and has a higher buffer copying & locking overhead
20:38:14 <SamB_XP> but, getLine would be perfect for where you really do want to get one line...
20:38:25 <SamB_XP> but then read the rest of the file lazily
20:38:47 <dons> yeah, it's possible to imagine uses
20:38:48 <dcoutts> SamB_XP, (first:rest) <- lines =<< readFile f
20:38:53 <edwardk> the obvious newH = new hash  doesn't work because the type of (k -> Int) on new precludes me passing it something of type Hashable k => k -> Int
20:39:00 <SamB_XP> say the rest of the file was in binary ;-)
20:39:07 <edwardk> and i can't seem to figure out 'how to get the function out of the dictionary'
20:39:08 <dcoutts> no problem
20:39:26 <dcoutts> it's the same type
20:39:38 * palomer kicks frown
20:39:53 <dcoutts> SamB_XP, it's still just a ByteString so you can treat it as binary or using the .Char8 functions
20:40:16 <dons> i can see it used in interactive programs, but even there you should be using Data.ByteString.
20:40:59 <SamB_XP> I suppose you could just use Data.ByteString.getLine
20:42:56 <edwardk> a similar problem would be to write something like comparator :: Eq k => (k -> k -> Bool)
20:43:29 <edwardk> ideas?
20:44:19 <int-e> @type (==)
20:44:20 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:45:02 <edwardk> int-e: yeah. now, i want to take any instance of Eq, and get a new function that just compares that type, and doesn't rely on the Eq dictionary. i want to 'undictionary-ify' the function =)
20:45:09 <edwardk> same roblem i have with the hashable thing
20:47:00 <int-e> edwardk: so you just have to convince the type checker to do the right thing?
20:47:32 <edwardk> I have a class Hashable a where hash :: a -> Int  and I have a method new :: (k -> Int) -> ...    how can I make a newH :: Hashable k => ... that can rip the method out of the dictionary?
20:47:47 <edwardk> see the trick?
20:48:03 <edwardk> yeah
20:48:25 <edwardk> coz i can't get my hands on "==" without an instance =)
20:48:51 <edwardk> and i can't make a little lambda expression to get it, and i can't type the lambda expression to get it, etc.
20:49:12 <int-e> well, comperator = (==)
20:50:02 <edwardk>  
20:50:02 <edwardk> test.hs:1:13:
20:50:02 <edwardk>     Ambiguous type variable `a' in the constraint:
20:50:02 <edwardk>       `Eq a' arising from use of `==' at test.hs:1:13-16
20:50:02 <edwardk>     Possible cause: the monomorphism restriction applied to the following:
20:50:03 <edwardk>       comparator :: a -> a -> Bool (bound at test.hs:1:0)
20:50:05 <edwardk>     Probable fix: give these definition(s) an explicit type signature
20:50:07 <edwardk>                   or use -fno-monomorphism-restriction
20:50:29 <int-e> err, yes. add a type signature
20:50:53 <int-e> Eq a => a -> a -> Bool
20:51:28 <int-e> maybe that's the problem with newH, too?
20:52:32 <dcoutts> dons, arrg, concatMap is still ultra slow
20:52:44 <dcoutts> I don't think it's that uncommon an operation
20:53:10 <dcoutts> for .Lazy I've got an idea for a cunning impl
20:53:22 <edwardk> heh. no, i just wasn't exporting hash from the module =)
20:53:27 <int-e> edwardk: really the identifiers in the class declaration are the functions you want - they take a dictionary and return the operation.
20:53:29 <edwardk> i'mm an idiot
20:53:39 <int-e> I'll take your word for it.
20:53:54 <edwardk> heh
20:53:59 <int-e> aren't we all?
20:54:10 <int-e> from time to time. it happens :)
20:54:28 <dcoutts> an interesting advantage of doing both the strict and lazy in terms of (fusable) primitives rather than lazy ops in terms of strict ops is that we can more easily do things to preserve the chunk size
20:54:33 <edwardk> perfect
20:54:44 <dcoutts> dons, I was always expectign the chunks to get smaller as you process things
20:54:52 <edwardk> compiled, now i have a version that has a nice default hashable case and can be run with explicit hash functions if desired
20:54:59 <dcoutts> but it needn't be that way, consider filter for example
20:55:25 <dcoutts> instead of calling map P.filter which makes smaller blocks
20:55:45 <edwardk> http://slipwave.info/haskell/docs/Data-THash.html
20:56:07 <dcoutts> we alloc a chunk and just keep filling it up, irrespective of how many chunks we consume
20:56:10 <edwardk> bolts that feature onat right angles
20:56:30 <dcoutts> dons, where as with map P.filter we always get the same number of chunks, but the chunks get smaller
20:56:38 <dons> hmm!
20:56:55 <dons> good. i'll add this point to the paper so we don't forget
20:57:03 <dcoutts> dons, basically any of the Stream ops can bring the chunk size back to ideal
20:57:28 <edwardk> int-e: thanks that and the earlier bit about qualified modules makes the haskell class system make a lot more sense to me.
20:57:29 <dcoutts> or rather it's the writeStrUp that does it
20:58:03 <dcoutts> dons, I do hope the Streams system performs well, it's got so much else going for it :-)
20:58:12 <dcoutts> it's nicely modular
20:58:14 <int-e> edwardk: you're welcome :)
20:58:16 <dons> yeah, well it seems to work nicely in ndp so far
20:58:25 <dons> so, fingers crossed
20:58:39 <dcoutts> it's much less ad-hoc that some of our original ByteString code
20:58:41 <int-e> what is ndp?
20:59:17 <dcoutts> nested data parallelism
21:01:13 <dcoutts> dons, ok, I'm off to bed, I've got 2 of the fusion modules working for .Lazy now, I'll do the others and send you the patches
21:01:47 <dons> ok. cheers
21:08:18 <edwardk> int-e: heh that also makes the implicit parameter syntax make a lot more sense too
21:18:11 <palomer> I think zen buddhism may help programmers write better code
21:18:50 <edwardk> @palomer
21:18:50 <lambdabot> That's a lie
21:18:56 <edwardk> =)
21:20:55 <palomer> @palomer
21:20:55 <lambdabot> That's a lie
21:20:59 <palomer> negated!
21:21:03 <edwardk> @palomer
21:21:03 <lambdabot> Learning vim is pointless
21:21:05 <edwardk> ahhh
21:21:09 <edwardk> struck down
21:21:11 <edwardk> oh well =)
21:21:21 <audreyt> isPointless . learning . vim
21:21:41 <edwardk> pointless @palomer ? =)
21:22:46 <int-e> @pl is pointless
21:22:47 <lambdabot> is pointless
21:23:24 <foxy_> palomer: is zen buddhism pointless?
21:24:36 * edwardk is kinda leery that any sort of haskell pcre code is going to be dog slow
21:24:51 <edwardk> then again
21:24:56 <edwardk> i've been happily surprised before
21:25:07 <dons> why would it be slow?
21:25:40 <dons> have you looked at Text.Regex.Lazy?
21:25:52 <dons> before embarking on a pcre implementation...
21:25:54 <edwardk> well, mostly cache misses because its going to wind up having to use larger types to describe the linkage between states
21:25:58 <edwardk> yeah
21:26:17 <palomer> har har
21:26:33 <dons> well, you can always code up critical bits in C
21:26:41 <edwardk> that would defeat the whole purpose =)
21:26:53 <dons> 5% C, 95% Haskell seems reasonable to me
21:26:57 <u221e> I wonder how long it takes from being added to the shootout cvs to being put on the site.
21:26:58 <int-e> you can let your haskell code generate C code ;)
21:27:03 <dons> and do even better
21:27:14 <u221e> Using C admits weakness ;)
21:27:20 <dons> u221e: I see its in the 'pending' list
21:27:34 <dons> it's been assigned to musasabi, so we need to wait for him to take it
21:27:34 <edwardk> yeah. though, i admit i kinda like the thought of it working across general types, and possibly using template haskell to compile the regexps it encounters it it encounters them at compile time.
21:27:36 <dons> @seen musasabi
21:27:37 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I don't know when musasabi last spoke.
21:27:42 <edwardk> then it could be a pretty slick implementation
21:27:43 <dons> musasabi: ping?
21:29:18 <u221e> Hm... when was he last around?
21:30:01 <dons> a few weeks ago?
21:30:04 <dons> we could mail him
21:30:40 <edwardk> and ick, the text.regex.lazy.dfaengine is lgpl =P
21:30:58 <dons> u221e: ekarttun >< cs.helsinki.fi
21:34:20 <palomer> I don't understand how you can have shift/reduce conflicts in a LALR(k) grammar if the grammar is unambiguous
21:34:44 <edwardk> you know, i first came on this channel to talk to him about parrows. he hasn't spoken since i showed up =)
21:35:05 <palomer> edwardk: he's being subtle
21:35:11 <edwardk> sneaky even
21:37:50 <u221e> I think there is something wrong with the partial-sums benchmark...
21:38:06 <dons> ?
21:38:26 <palomer> ok, I'm confused by the very concept of LALR
21:38:43 <u221e> On the site it says it takes 4.14 seconds but on my computer (which is worse then theirs) I finish in 2.3 secons
21:38:48 <palomer> you have your states and you push and reduce
21:38:55 <palomer> shift and reduce, rather
21:39:02 <palomer> what's this lookahead thing?
21:39:13 <dons> hehe
21:40:03 <dons> as long as we're around Fortran, and faster than C, I don't mind how slow it it
21:40:07 <dons> is
21:40:13 <edwardk> palomer: sometimes you don't know when you can reduce until you've looked ahead  acoule of symbols
21:40:22 <edwardk> to make sure that you chose the right path
21:40:38 <palomer> when you can reduce?
21:40:46 <palomer> you just keep shifting until you can reduce
21:40:59 <edwardk> palomer: lets take a javascript example, coz i'm comfortable with those =)
21:41:59 <edwardk> i have a pretty simple grammar overall. but sometimes, i don't know if i'm parsing an expression like  foo . bar = 12; or a label like foo : while (1) {... }
21:42:09 <edwardk> until i see that the symbol after foo isn't a :
21:42:43 <edwardk> so, should i reduce foo to an identifier or should i wait until I see a : and then reduce to a label, and otherwise go into my general expression parser.
21:42:56 <edwardk> i need to lookahead that extra symbol to decide how to reduce foo
21:43:14 <edwardk> at least without explodig the number of states in the system
21:43:18 <u221e> dons, it's not slow, that's what I'm saying. ;)
21:43:35 <edwardk> in some other cases its less easily resolve or in principle unresolved.
21:43:56 <palomer> edwardk: but wait, don't you have a reduce/reduce conflict?
21:44:26 <edwardk> thats why most languages use their keywords to disambiguate whats coming up. like 'class'. once i see the keyword class in c++ i know the next word is an identifier for the class, i don't have any other parse trees to consider.
21:44:27 <dons> u221e: yeah, and I'm saying: no problem :)
21:44:38 <edwardk> its there to minimize lookahead needed to figure out what path i have
21:45:09 <edwardk> pal: i would, but i'm able to disambiguate that case within 2 symbols, keeping the grammar LALR(2)
21:45:22 <palomer> but happy would still give you a warning, right?
21:45:29 <edwardk> happy would bitch up a storm =)
21:46:05 <palomer> so LALR(k) parsers are useful when they give you a warning
21:46:09 <edwardk> most grammars are written to only need one symbol of lookahead
21:46:13 <palomer> and the only grammars that don't give a warning are LALR(0)
21:46:27 <u221e> The g++ version of pidigits uses 400,000KB of memory? Whatl?
21:46:29 <edwardk> not entirely true
21:46:47 <edwardk> the warnings do mean something =)
21:47:10 <edwardk> the reduce/reduce you had earlier was a good example. it couldn't tell which of two ambiguous rules to use.
21:47:23 <edwardk> both rules matched at that point
21:47:26 <dons> u221e: i guess the compiler doesn't spot the recursion very well?
21:47:30 <dons> the tail recursion
21:47:43 <edwardk> in a good LALR grammar its not possible to reach the END of a rule, without having disambiguated which case you meant.
21:48:04 <palomer> but ambiguities only happen at the END of a rule
21:48:09 <palomer> ie, at a reduce
21:50:23 <int-e> dons: no, they allocate lots of temporary gmp ints and never free them, I think
21:50:48 <dons> oh, sounds plausible
21:50:50 <edwardk> yeah. hence you had a conflict =) lookahead is how many characters after the end of the rule you have to go before you know you really could reduce
21:51:57 <palomer> ok, we have to agree that happy/frown give warnings when a reduce conflicts with some other action
21:52:00 <edwardk> in an LALR(1) grammar i can look at the next symbol to make sure i am done with the current rule and took the right path.
21:52:21 <palomer> all grammars which are in LALR(1) \ LALR(0) will give warnings
21:52:32 <palomer> right?
21:52:38 <edwardk> nope
21:52:56 <palomer> can you give me one that doesn't?
21:53:22 <edwardk> it should warn if you can't resolve the conflict in the specified number of tokens you have for lookahead.
21:53:26 <int-e> dons: I wonder why they don't use the nice gmpxx.h file that comes with libgmp.
21:54:27 <palomer> we're talking about happy/frown
21:54:49 <edwardk> thats why languages usually don't have the structure "{ .... 50k of code ... } is a class"    "{... 50k of code ... } is a function" they specify which rule you are using first =)
21:55:54 <edwardk> because those definitions above require arbitrary lookahead to resolve the conflict
21:56:56 <edwardk> reduce/reduce errors can be resolved by sorting the grammar appropriately or adding explicit precedence.
21:57:06 <palomer> right
21:57:13 <palomer> but getting back to my original question
21:57:38 <palomer> in happy/frown, if I specify a grammar which is in LALR(1)\LALR(0), I will get a conflict
21:57:46 <palomer> conflict warning
21:57:49 <palomer> right?
21:58:00 <edwardk> that seems likely statistically, but isn't definitely true =)
21:58:19 <palomer> got a counter example?
21:58:59 <edwardk> no, because i don't tend to just whip up LALR grammars =)
21:59:11 <edwardk> most languages in practice tend to have conflicts though
21:59:19 <edwardk> but not all lalr grammars do
22:00:38 <palomer> I think frown is LALR(k) inasmuch as it can parse nondeterministically
22:01:11 <palomer> so lookahead produces huge overhead
22:01:21 <edwardk> nah, frown builds actual lalr state functions
22:01:34 <edwardk> lookahead DOES produce lots of overhead though
22:01:48 <palomer> hrmph
22:01:50 <edwardk> because it can explode the number of states
22:02:04 <palomer> why doesn't happy/frown figure out if there's actually a conflict?
22:02:33 <edwardk> some conflicts can't be cleanly removed. like the if then {else} conflict in a lot of languages
22:03:10 <palomer> instead of giving me a warning for a grammar which doesn't have a conflict
22:03:18 <palomer> (given lookahead)
22:04:25 <edwardk> well, the warnings are a sign =) but sometimes its rather hard to read the entrails. usually the more warnings the worse things are, but you can run into perfectly legitimate grammars that have hundreds of conflicts but work fine.. some c++ grammars are like that
22:05:15 <palomer> gah
22:05:44 <palomer> hasn't anyone figured out an algorithm to only give warnings when something is wrong?
22:05:49 <edwardk> nope
22:06:31 <edwardk> there is another schooll of parsing that gives up the generative approach that provides a way to generate only good grammars, but it excapes me at the moment
22:06:40 <edwardk> and in fact reminds me a lot of parsec now that i think about it
22:06:58 <Cale> Is there a name for the set of all CFLs which are not inherently ambiguous? Is there a usable criterion for telling whether a CFL is inherently ambiguous?
22:07:47 <palomer> the number of warnings that happy outputs:O
22:07:53 <Cale> heh
22:08:01 <Cale> but that's for a grammar :)
22:08:23 <edwardk> well, you want a grammar without ambiguous left-most derivations
22:08:25 <palomer> how is your language specified?
22:08:33 <edwardk> but how to get there is another matter.
22:08:33 <u221e> How do I force GHC to compile again even if there are no changes to the source?
22:08:55 <dons> -no-recomp
22:09:04 <palomer> However, we can also instruct Frown to produce a non-deterministic parser, that is, one that generates all possible parses of a given input. We do so by supplying the option --backtrack:
22:09:14 <dons> i.e. no recompilation checking (the name is a tad confusing, i find)
22:09:23 <palomer> ok, someone tell me why we would need a nondeterministic parser?
22:09:25 <dons> i always read it as 'no recompiling'
22:09:37 <palomer> I think --backtrack puts the k in LALR(k)
22:09:44 <Cale> A language is a set of strings. A context-free language is a language generated by some context-free grammar.
22:09:57 <Cale> (but the information about which grammar is gone)
22:09:58 <edwardk> palomer: a nondeterministic parser can generate all of the possible parses even in the absence of rules about associativity.
22:10:11 <u221e> Ok, thanks. You told me that before but I forgot.
22:10:11 <edwardk> so give 1 + 2 + 3 it would generate (1 + 2) + 3 and 1 + (2 + 3)
22:10:28 <palomer> ah, righto
22:10:49 <palomer> is LALR(k) ambiguity undecidable?
22:11:04 <Cale> Does anyone know if there's a nice purely-algebraic description of context-free languages?
22:11:29 <edwardk> cale: there is a way to prove something isn't context free, by a pumping lemma
22:11:41 <edwardk> but its harder to prove something is
22:11:44 <Cale> Pushdown automata and CFGs are kind of messy
22:11:44 <palomer> which isn't a lemma at all!
22:12:23 <Cale> palomer: sure it is, it's sort of a funky incidental theorem which is mostly interesting as a tool to prove other theorems.
22:12:33 <edwardk> unless you can generate a grammar for it. then it don't know of an algorithm that readily proves an arbitrary cfg has an unambiguous left most derivation
22:12:36 <Cale> But not that interesting on its own
22:13:02 <palomer> is your language a [String] ?
22:13:12 <palomer> given a [String], figure out if has an unambiguous grammar?
22:13:24 <foxy_> dons, am I right in thinking that what is Window+Buffer in Yi is essentially all taken care of by GtkBuffer { buf :: SourceBuffer } in Yi+GTK?
22:13:24 <palomer> that would be wicked
22:13:34 <edwardk> yeah, but usually the language is an infinite [String] =)
22:13:45 <Cale> palomer: Though I don't particularly care so much about computability.
22:13:50 <dons> yep, foxy_
22:14:07 <Cale> Like, you could say "if there's such and such monoid, and such and such homomorphism"
22:14:14 <palomer> ahh, righto
22:14:59 * palomer slaps happy/frown around
22:15:30 <Cale> I've just been slightly pissed about the situation ever since I learned that there are CFLs for which no unambiguous CFG exists.
22:15:50 <Cale> That really messes up enumerative stuff.
22:16:03 <palomer> well, ambiguous CFLs fit that category
22:16:10 <Cale> exactly
22:16:19 <palomer> you didn't know about ambiguous CFLs?
22:16:26 <int-e> oh, like the union of a^nb^nc^m and a^nb^mc^m.
22:16:30 <edwardk> well, the problem i thnk is the whole generative approach. its done a good job of mucking up linguistics too =)
22:16:40 <Cale> Well, it was a number of years ago that I found this out.
22:16:54 <palomer> oh
22:16:55 <edwardk> its nice that we might recycle the same machinery to generate as to parse, but i'm more interesting in a perception oriented approach =)
22:17:12 <Cale> It kind of feels like CFLs are the "wrong" abstraction at some level -- that there should be something more expressive than regular languages, but a little more restrictive than CFLs.
22:17:19 <edwardk> start with perception and then mimic the machinery of perception to generate, not the other way around.
22:17:38 <edwardk> ahh now i remember
22:17:38 <Cale> and for which there was always an unambiguous parsing strategy
22:17:41 <edwardk> parsing expression grammars
22:17:45 <edwardk> thats the other family
22:17:52 <Cale> hmm
22:17:56 <palomer> oh my god!
22:18:00 <palomer> I'm getting excited by learning
22:18:00 <edwardk> goes recognition out, not generative in
22:18:04 <Cale> How are they defined?
22:18:06 <palomer> this hasn't happened in 4 years
22:18:12 <edwardk> http://pdos.csail.mit.edu/~baford/packrat/popl04/
22:18:12 <palomer> s/about/by
22:18:13 <lambdabot> Title: Parsing Expression Grammars: A Recognition-Based Syntactic Foundation
22:18:28 <palomer> I feel like a freshman
22:18:50 <Cale> also, is there a nice algebraic definition of them, like regular languages have?
22:19:05 <edwardk> take a look. my recollection is a little fuzzy
22:19:07 <edwardk> the paper is short
22:19:09 <edwardk> like 12 pages
22:19:19 <edwardk> it'
22:19:19 <palomer> expression grammars?
22:19:23 <Cale> I really like the "preimage of a set in a finite monoid under a homomorphism from a free monoid" definition of regular languages :)
22:19:50 <palomer> expression grammars are specified in a way similar to BNF
22:19:51 <edwardk> it'll remind you a bit about parsec parsers actually if i recall correctly
22:20:03 <edwardk> hahaha
22:20:08 <palomer> expression grammars don't have try
22:20:20 <palomer> if parsec didn't have try, noone would use it
22:20:33 <Cale> oh, prioritised choice
22:20:48 <Cale> hmm
22:21:13 <Cale> yeah, I've seen this paper before, but I haven't read it carefully
22:21:20 <edwardk> *nods*
22:21:39 <edwardk> i drudged it up out of memory coz you were railing against CFLs
22:21:49 <Cale> yeah
22:22:06 <edwardk> and it was the main alternative i could think of
22:22:26 <Cale> mhm
22:22:50 <edwardk> what about earley parsing?
22:23:00 <edwardk> remember it from linguistics, coz they like it
22:23:07 <Cale> It would be really cool to see a cute algebraic description of these things. The problem is probably hard for CFLs or it would be well-known, most likely.
22:23:56 <edwardk> but its not big on a nice formal mathematical model
22:26:31 <Cale> I'm particularly interested in the combinatorial aspects, that is counting members of the language with particular length/etc.
22:26:44 <edwardk> hrmm
22:27:17 <Cale> I should take a look at which CFGs give functional equations for the generating series which can be solved using Lagrange's theorem.
22:27:34 <edwardk> you do that =)
22:27:42 <Cale> That's probably a large chunk of usable grammars.
22:28:05 <Cale> Hmm...
22:29:20 <Cale> Lagrange's theorem has to be the most complicated and bizarre theorem I saw in all of undergrad.
22:29:31 <edwardk> thinking, you want lagrange's inversion theorem right? so your grammar has to have rational generating functions
22:29:48 <edwardk> er
22:30:41 <Cale> possibly, I'd have to think about it a bit :)
22:31:11 <edwardk> trying to remember/figure out all the rules that have to apply to use the inversion theorem
22:31:24 <edwardk> it came up in a course i took on classical analysis
22:31:55 <Cale> Let f be in C[[x]] and phi be in C[[lambda]], where phi(0) /= 0.
22:32:03 <Cale> Let w = t phi(w)
22:32:22 <Cale> Then this equation has a unique solution w = w(t) in C[[t]], and
22:33:05 <Cale> f(w) = f(0) + sum over n>=1 of t^n/n [lambda^(n-1)] f'(lambda) (phi(lambda))^n
22:33:20 <pejo> The lagrange theorem you guys are talking about, is it "The order of a subgroup H of a group G divides the order of G"?
22:33:29 <Cale> where [lambda^(n-1)] is the operator which extracts the coefficient of lambda^(n-1)
22:33:33 <Cale> pejo: not that one
22:33:42 <edwardk> lagrange has lots of theorems pego =)
22:33:45 <Cale> pejo: It's the one I'm in the middle of stating.
22:33:57 <pejo> Doh. Sorry Cale.
22:34:17 <Cale> Moreover, if c(n) = [lambda^n] g(lambda) (phi(lambda))^n, where g is in C[[lambda]], then
22:34:41 <Cale> g(w)/(1-t phi'(w)) = sum over n >= 0 of c(n) t^n
22:35:03 <Cale> As I said, the craziest theorem I learned in undergrad :)
22:35:16 <Cale> but it's pretty useful
22:35:33 <edwardk> trying to match up the theorem you're giving with the one i am thinking of =)
22:35:50 <edwardk> http://en.wikipedia.org/wiki/Lagrange_inversion_theorem
22:36:24 <Cale> yeah, it's pretty twisted, because this version is purely formal
22:36:42 <Cale> there's no convergence aspects involved with this
22:38:17 <edwardk> well, have fun with that =)
22:38:19 <Cale> It's also really general in that it gives an expression for any function of the solution.
22:38:39 <Cale> If f = id, then you get
22:38:53 <u221e> dons, pidigits also seems to be slow and it isn't better then gcc. Care about that one? ;P
22:39:09 <Cale> w = sum over n >= 1 of t^n/n [lambda^(n-1)] (phi(lambda))^n
22:39:48 <Cale> which is a lot like that combinatorial special case the wikipedia article gives
22:40:11 <Cale> I bet that was written by a student of Jackson :)
22:40:31 <dons> it's slow now?
22:40:37 <dons> it used to be #1
22:40:48 <dons> ah, but gcc uses hand-code gmp calss
22:40:55 <dons> very suspicious ;)
22:41:05 <dons> we should use hand coded Data.ByteString calls ;)
22:41:28 <edwardk> they also give: http://en.wikipedia.org/wiki/Lagrange_reversion_theorem
22:41:44 <u221e> patience, dons ;)
22:42:35 <u221e> I still don't get monads...
22:42:55 <edwardk> whats not to get u221e?
22:43:31 <Cale> edwardk: yeah, that's basically equivalent, just a little odd that they're using differentiation rather than coefficient extraction, but the same thing.
22:44:04 <Cale> Formal Taylor theorem :)
22:44:05 <u221e> I don't understand how they should be used...
22:44:48 <Cale> u221e: One place they're used is when you want to create a small embedded language to solve some particular problem
22:45:06 <edwardk> u221e: i usually think of them as a way to order my operations or carry aroud state or something i don't want to explicitly pass into every function.
22:45:24 <edwardk> think of them as a way to smuggle arguments to your function =)
22:45:41 <edwardk> and to make sure things happen in a meaningful order
22:45:44 <Cale> Or if you want nondeterminism, you can get that
22:45:48 <edwardk> yeah
22:45:49 <Cale> or goto, even
22:45:51 <Cale> :)
22:46:19 <u221e> I think I'll try and pull lambdabot apart and see how it ticks
22:46:32 <Cale> basically just about any sort of control structure you need can be constructed in some monad, and then you can even put extra controls and restrictions on its use
22:46:38 <edwardk> normally in a lazy language all that evaluation forms a tree (well, in haskell a graph). think of it a a way to thread a path of execution (or many paths of execution) through that graph kinda on the sly
22:46:43 <Cale> you should look at my sudoku solver
22:47:02 * Cale grabs a link
22:47:10 <u221e> Was just going to ask for it ;)
22:47:31 <Cale> http://www.haskell.org/haskellwiki/Sudoku -- the top one :)
22:47:32 <lambdabot> Title: Sudoku - HaskellWiki
22:47:57 <Cale> It's not the fastest, but it uses a completely naive algorithm
22:48:47 <Cale> however, the neat thing is that things are set up such that the naive algorithm is completely trivial to write
22:49:03 <Cale> and more clever algorithms could be written
22:49:29 <edwardk> you now my major reason for wanting to write the javascript implementation in haskell now is to play with weird monads in the evaluator.
22:49:59 <Cale> essentially, it allows you to put numbers on the board at will, and it will backtrack automatically if you try to put something which fails to satisfy the rules of sudoku
22:50:08 <edwardk> cute
22:50:11 <u221e> Is there any good tutorials about concurrency in haskell?
22:50:27 <Cale> @docs Control.Concurrent
22:50:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
22:50:29 <Cale> :P
22:50:36 <u221e> Might as well learn about it before I get my Core 2 Duo E6600 ;)
22:53:18 <u221e> Cale, whats a functor? I heard the term before and I see it in your code.
22:53:40 * edwardk sits back to watch the ensuing lecture =)
22:53:48 <edwardk> rather.. runs out to get a drink.
22:53:52 <edwardk> brb
23:01:39 <Cale> u221e: have you read Monads as Containers yet?
23:01:49 <Cale> @wiki Monads_as_Containers
23:01:49 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
23:03:59 <u221e> Will do.
23:05:47 <edwardk> I found all about monads to be a useful intro to them myself
23:06:18 <edwardk> @google all about monads
23:06:19 <lambdabot> http://www.nomaware.com/monads/
23:06:19 <lambdabot> Title: Nomaware | Monads
23:06:26 <Cale> Monads as Containers is sort of meant as a primer for All About Monads -- I link to it even :)
23:06:36 <edwardk> heh
23:06:53 <Cale> Though it takes a different perspective on them
23:07:08 <Cale> which I think is a little easier to swallow for beginners
23:07:21 <edwardk> fair nuff
23:07:29 <edwardk> oh yeah
23:07:40 <edwardk> read yours too. the boxes of boxes of apples thing
23:07:46 <Cale> :)
23:09:24 <u221e> All About Monads is great... I wish Part 1 was alittle longer though
23:09:25 <edwardk> hrmm. there are a lot of optimization possibilities with a fully lazy regexp now that i'm looking at it closely
23:10:07 <Cale> using parsec to simulate regular expressions is faster than using Text.Regexp
23:10:29 <edwardk> currently just looking at putting something together from scratch
23:10:57 <edwardk> mainly coz i'm not so fond of the way we to combine parsers in parsec
23:11:11 <edwardk> er way we
23:11:21 <edwardk> er way we have
23:11:22 <edwardk> gah
23:11:24 <edwardk> can't type
23:12:12 <edwardk> and i'm leery of getting the full pcre functionality in a backtracking parser. backtracking forces exponential time
23:12:20 <edwardk> in the pathological cases.
23:13:03 <edwardk> but i am rather fond of the idea of being able to supply arbitrary functions as predicates since we're in a lazy environment.
23:13:09 <edwardk> er pure environment
23:13:44 <edwardk> i just want to be able to collapse and optimize my dfa/nfa a lot
23:14:58 <edwardk> hahaha: http://www.tarari.com/press/Tarari-RegEx5-ProductBrief.pdf <-- hardware regexp processing
23:15:00 <edwardk> scary
23:18:31 <zarvok> anyone getting excited about the ICFP contest next week?
23:18:35 <zarvok> I hope a haskell team takes it again
23:18:52 <edwardk> would be nice
23:19:51 <zarvok> I think it may happen, I've heard a few good haskell teams are organizing
23:20:14 <edwardk> yeah. these things are more about people than language features, so i tend to tune them out =/
23:20:33 <zarvok> heh
23:21:23 <zarvok> well, surely it says something about your language if people using it are able to consistently solve hard problems better than people using any other language
23:21:30 <edwardk> gah. the route to my server died. *sits on hands*
23:21:38 <zarvok> heh
23:21:58 <zarvok> the server I'm using goes down for nightly reboot in 30 minutes or so :(
23:22:06 <edwardk> heh
23:22:14 <zarvok> It's always a depressing moment when you're still coding at reboot time
23:22:20 <zarvok> on this server, I mean
23:22:33 <edwardk> this is the problem with having my machine hosted by friends. can't call and complain and get 24 hour support =)
23:22:42 <zarvok> heh
23:22:52 <edwardk> though i'm usually their miner's canary ;)
23:32:12 <edwardk> heh was digging through google analytics. i think this is the first website i've ever had where 90% of my users have had firefox
23:47:46 * wli wonders how web browsers correlate to content
23:48:01 <wli> e.g. are firefox users more right-wing or left-wing than IE users
23:48:03 <edwardk> first site i had with geek content =)
23:48:27 <edwardk> so there is something. firefox users have a strong correlation with the geek factor =)
23:48:42 <edwardk> but thats not exactly rocket science
23:50:10 <wli> income levels too
23:50:18 <wli> and net worths
23:56:13 <Failure02> is there a built-in function pow a b n = (a^b) mod n?
23:56:50 <wli> Just use a^b `mod` n
23:57:13 <Failure02> does haskell optimize that?
23:57:28 <edwardk> probably not
23:57:44 <Failure02> so then i can't use it.
23:57:53 <wli> optimize it how?
23:57:54 <edwardk> unfortunate but true
23:58:02 <dons> optimize how?
23:58:10 <Failure02> try computing (234^234252) `mod` 2
23:58:15 <edwardk> its used a lot when you want to work in a prime number field
23:58:25 <dons> > (234^234252) `mod` 2
23:58:26 <lambdabot>  0
23:58:31 <edwardk> hehe
23:58:41 <wli> That didn't take long. =)
23:58:59 <edwardk> > 234^234252
23:59:02 <lambdabot>  out of memory (requested 2097152 bytes)
23:59:07 <edwardk> then i guess it optimizes =)
23:59:11 <Failure02> hm.
23:59:31 <edwardk> or it couldn't convert that to a string
23:59:54 <u221e> good
