00:00:21 <dons> just takes practice. it's diagnosing all sorts of interesting errors in your code, so it's best to just look at the line /col number if refers to, and try to work it out (it becomes trivial with some practice)
00:01:00 <dons> i suggest using explcit type annotations to start with, to help you learn to mentally infer the types
00:03:51 <zeeeee> dons: i added them to my app but how can they help me with the last line?
00:04:56 <dons> now the puzzle is to work out where the typing is going wrong. hopefully, firstly, ghc gives you a bit better error message
00:05:10 <dons> the next step is then to trace through the code, mentally inferring the types
00:05:17 <dons> but remember, you're missing a 'show'
00:05:24 <dons> that's the problem, i think
00:05:42 <dons> so where you'd previously done a show after doing the math, you've left the show out now.
00:06:09 <dons> so there's a type error, you're returning some Float, but it has to be a String
00:06:18 <zeeeee> dons: but i added the show back
00:06:34 <dons> also, you're not calling normNumber or maxNumber anymore?
00:07:15 <zeeeee> dons: this should be the latest: http://paste.lisp.org/display/22435#5
00:09:43 <Korollary> @type Concurrent.Control.STM.check
00:09:44 <lambdabot> Couldn't find qualified module.
00:09:44 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
00:09:58 <Korollary> @type Control.Concurrent.STM.check
00:09:59 <lambdabot> forall a. Bool -> GHC.Conc.STM a
00:10:22 <Korollary> @version
00:10:22 <lambdabot> lambdabot 4p23, GHC 6.5 (OpenBSD i386 )
00:10:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:10:36 <Korollary> Blah. The type is different in the paper. Heh.
00:11:25 <dons> zeeeee: now your maxNumber needs to be fixed
00:11:40 <zeeeee> dons: right
00:11:51 <zeeeee> dons: if i just use '3' it works
00:12:04 <dons> so, it's being applied to 'ls', all of input
00:12:08 <dons> which has type String, yes?
00:12:21 <dons> so you then need to take the lines of ls?
00:12:26 <dons> and then the words of each line?
00:12:45 <zeeeee> dons: yeah, i map words to each line
00:13:12 <wolverian> hm, running hasktags on the ghc libraries gave me a tags file that vim complains is malformed
00:13:30 <dons> wolverian: yeah, you need to tweak it a bit
00:13:36 <dons> there's some funky cpp symbols
00:13:42 <wolverian> oh, okay. what kind of things am I looking for?
00:13:45 <dons> do you want mine?? i'll post it
00:13:55 <wolverian> that'd be great too :)
00:14:27 <dons> http://www.cse.unsw.edu.au/~dons/tmp/.fptools-tags
00:14:33 <dons> edit the path to your liking
00:14:43 <dons> that's against the most recent fptools head
00:14:55 <dons> and then: :set tags=/home/dons/.fptools-tags
00:14:59 <dons> in the .vimrc
00:15:16 <wolverian> thanks!
00:15:46 <dons> zeeeee: looks good to me: maxNumber =  maximum . map (getNumber .  words) $ ls
00:15:54 <wolverian> I'll put it in the haskell ftplugin actually, but yeah
00:16:29 <zeeeee> dons: whoa
00:16:43 <zeeeee> i coulda sworn i saw fromIntegral earlier in this chat
00:16:52 <dons> yeah, but we don't need it now.
00:16:54 <wolverian> haha, I forgot to change the paths :-) 
00:17:02 <dons> since we ensure it's 'read' as a Double in the first place
00:17:24 <zeeeee> dons: is Integral a superset of Int and Integer?
00:17:31 <zeeeee> or superclass
00:17:49 <dons> it a class, yes.
00:17:55 <dons> @instances Integral
00:17:56 <lambdabot> Int, Integer
00:19:15 <dons> wolverian: here's the wrapper script i hacked on, http://www.cse.unsw.edu.au/~dons/tmp/tag-fptools
00:19:34 <dons> since i couldn't get htags on its own to work, nor any of the other systems
00:20:03 <wolverian> what's htags?
00:20:10 <dons> ?where htags
00:20:10 <lambdabot> I know nothing about htags.
00:20:19 <dons> ah, its on haskell.org anyway
00:20:30 <wolverian> it's not hasktags?
00:20:31 <dons> it's a haskell program for extracting idents and src locs
00:20:32 <Voxel> hello, you can check www.idpz.net/tomytom/net_linux.htm for infos
00:20:41 <dons> go away Voxel 
00:20:55 --- mode: ChanServ set +o dons
00:21:01 <Korollary> wow. it worked.
00:21:03 <dons> grr. i hate that
00:21:16 <dons> stupid bot, i suppose
00:21:21 <wolverian> oh well, I'm afraid my libraries are too old 
00:21:29 <wolverian> ..for your tags to work on them :/
00:21:38 <dons> oh. do a darcs checkout of the head, then?
00:21:50 --- mode: ChanServ set -o dons
00:22:04 <dblhelix> dons: still, the authority you see to have even without being an operator... incredible ... clearly, you're good with bots ;)
00:22:07 <zeeeee> thanks a lot dons...i went through that haskell for c programmers tutorial but i learned a lot more here
00:22:15 <dblhelix> /s/see/seem
00:22:21 <dons> dblhelix: ;)
00:22:45 <dons> zeeeee: great :)
00:22:53 <Korollary> I dont like that tutorial.
00:23:12 <dons> zeeeee: you might want to go through the YAHT one though. that's usually the main reference
00:23:17 <zeeeee> Korollary: do you recommend any?
00:23:22 <dons> ?where yaht
00:23:23 <zeeeee> dons: oh ok
00:23:23 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
00:23:35 <zeeeee> ?where hoogle
00:23:35 <lambdabot> http://www.haskell.org/hoogle
00:23:35 <dons> that's the most often recommended one here, i suspect
00:23:51 <dblhelix> perhaps we could write a really short tutorial: "step 1: enter #haskell on irc.freenode.net; step 2: that's it"
00:24:12 <Korollary> @get-shapr
00:24:13 <lambdabot> shapr!!
00:25:05 <Korollary> my brain is fried. I cant read any more STM papers.
00:38:56 <dons> ?remember Korollary my brain is fried. I cant read any more STM papers
00:38:56 <lambdabot> Done.
00:39:43 <Muad_Dibber> poor dons  :)
00:48:41 <zeeeee> Muad_Dibber: poor Korollary actually
00:49:01 <zeeeee> but poor dons for putting up with me
00:49:27 <Muad_Dibber> zeeeee, that requires background information as to the reason why Korollary makes dons read those papers
00:49:36 <Muad_Dibber> But, poor dons for having his brains fried :P
00:51:13 <zeeeee> ?help remember
00:51:13 <lambdabot> quote <nick>
00:51:13 <lambdabot> remember <nick> <quote>
00:51:13 <lambdabot> Quote somebody, a random person, or save a memorable quote
00:53:49 <Muad_Dibber> ?quote
00:53:50 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
01:01:56 <zeeeee> ?quote
01:01:56 <lambdabot> shapr says: Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
01:09:40 <mnislaih> yawn
01:13:42 <MarcWeber> Do you know about a Either monad?
01:14:37 <JKnecht> who me?
01:14:55 <MarcWeber> I'm struggeling compiling the MissingH.Logging.Logger module which is using Data.Map.lookup and wants a monad returning a Either value. This monad isn't defined.
01:15:40 <MarcWeber> JKnecht: Thtis question was adressed to anyone here in gereral ;)
01:15:40 <dblhelix> MarcWeber:  instance Monad (Either String a) is defined somewhere, iirc
01:16:22 <dblhelix> > return (Right 'c')
01:16:23 <lambdabot>  add an instance declaration for (Show (m (Either a Char)))
01:16:23 <JKnecht> I just never saw a # referred to in 1st person like that.
01:17:12 <dblhelix> > return 'c' :: Either String Char
01:17:13 <lambdabot>  add an instance declaration for (Monad (Either String))
01:17:13 <lambdabot>   In the expressi...
01:17:20 <MarcWeber> JKnecht: I'm not a native speaker so I might write kind of rubbish ;)
01:17:33 <dblhelix> @instances Monad
01:17:34 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:18:02 <dblhelix> Either e is listed
01:22:27 <MarcWeber> dblhelix: http://rafb.net/paste/results/OTcAZC61.html So what's wrong here?
01:22:32 <MarcWeber> line 347
01:24:11 <dblhelix> MarcWeber: if the instance declaration for Either is in scope, there's nothing wrong I think
01:26:53 <dblhelix> MarcWeber: that instance is defined in the module Control.Monad.Error
01:27:04 <dblhelix> MarcWeber: so, maybe you should import the module here
01:27:15 <MarcWeber> dblhelix: How did you find it?
01:27:32 <dblhelix> MarcWeber: by remembering it
01:28:51 <MarcWeber> My tag generation doesn't recognize instances.. There is quite a lot to remember ;) Thx
01:42:50 <zeeeee> hi all, is it possible to pass a list or tuple of objects as the different args into a function?
01:45:16 <tony3> zeeeee, uncurry the function for a tuple
01:45:28 <dblhelix> zeeeee:
01:45:31 <zeeeee> tony3: thanks
01:45:42 <dblhelix> > uncurry (==) (2,3 )
01:45:43 <lambdabot>  False
01:47:13 <vegai> works only for a pair
01:48:39 <MarcWeber> Overlapping instances for Eq command? http://rafb.net/paste/results/JkFbv830.html
01:48:54 <zeeeee> so no general way?
01:48:59 <zeeeee> i mean
01:49:01 <MarcWeber> What is causing this?
01:49:01 <zeeeee> for n-tuples
01:49:05 <xerox> No, zeeeee.
01:49:07 <zeeeee> or lists
01:49:20 <xerox> Now it depends on what you mean by `on lists'.
01:49:25 <tony3> well, second element can be a tuple also (a,(b,c).
01:49:46 <tony3> :s/(a,(b,c)/(a,(b,c))
01:49:55 <MarcWeber> zeeeee: Con you give a short example on what you want to do?
01:50:01 <xerox> Functions can take lists as arguments.
01:50:25 <zeeeee> MarcWeber: pass first 5 argv into a function
01:50:34 <vegai> he wants foo (mysteryFunction [a1, a2, ..., an]) => foo a1 a2 ... an
01:50:37 <zeeeee> uncurry foo (take 5 argv)
01:51:03 <xerox> What do you want foo to do?
01:52:00 <vegai> perhaps you want lisp :)
01:52:11 <shapr> Good morning #Haskell!
01:52:12 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
01:52:13 * shapr boings
01:52:13 <xerox> G'day roconnor!
01:52:21 * shapr copies xerox 
01:52:23 <MarcWeber> zeeeee: write your own function f (a:b:c:d:e:[]) f2 = f2 a b c d e
01:52:24 * xerox throws lambda cookies at shapr 
01:52:44 <xerox> MarcWeber - That doesn't seem sensible.
01:52:45 * shapr partially applies himself to a lambda cookie.
01:52:56 * xerox partially applies to the rest
01:53:00 * shapr shares the cookie with xerox!
01:53:04 * xerox bounces
01:53:07 * shapr boings
01:53:17 <xerox> Yum.
01:53:21 <shapr> xerox: Hey, when will you next be in Northern Europe?
01:53:33 <xerox> As soon as possible!!
01:53:45 <xerox> Well, really, I don't know; but I want to visit there sometime.
01:54:07 <pputrd> is haskell  a lisp or smalltalk 80 impelemtation?
01:54:09 <shapr> Cool, if you want to stop by Stockholm, you can sleep at my place. (Though I don't have an apartment yet).
01:54:21 <anuke> NO
01:54:24 <shapr> pputrd: It's not either.
01:54:25 * xerox hugs shapr -- thanks! I'll keep that in mind!
01:54:37 <pputrd> smalltalk and seaside squeak seem interesting
01:54:42 <pputrd> is haskell mroepower?
01:54:43 <shapr> pputrd: Haskell is its own language, it's a purely functional language with non-strict evaluation.
01:54:54 <pputrd> and lisp claims to be most flexible
01:55:00 <shapr> pputrd: You can't really say 'more power' directly, it's not possible to compare directly.
01:55:01 <pputrd> and oz concurrent ??
01:55:04 <pputrd> hm
01:55:13 <pputrd> scheme has some good books
01:55:27 <shapr> pputrd: Mozart/Oz is good, so is Smalltalk, so is Scheme. Haskell is my favorite, but you have to choose for yourself.
01:55:44 <shapr> pputrd: We can tell what makes Haskell different, but you get to decide if you like that or not.
01:55:52 <xerox> shapr - Non-comparable values reminds me of non-Diophantine arithmetics.
01:56:03 <pputrd> why haskell?
01:56:11 <pputrd> why not clisp?
01:56:16 <pputrd> or perl?
01:56:25 <boegel> shapr: still studying at uni?
01:56:28 <xerox> (In projective arithmetics you can have n + 1 = n.)
01:56:44 <shapr> pputrd: Smalltalk is purely object oriented, Scheme is a much simpler and streamlined Lisp, Mozart/Oz is focussed on logic/constraint and concurrency.
01:57:10 <xerox> Which ``works'' in some situations. Like at the shop, if you see an advertisement `buy one, take one free', you do 1 + 1 = 1 pricewise.
01:57:26 <shapr> pputrd: Perl was originally built as a language to leverage knowledge of and bring together the strong points of 'sharp tools' like sed.
01:57:41 <xerox> Or even better, if the Monna Lisa is worth $10M, how much are worth two of them? (:
01:57:57 <pputrd> sharp tools
01:58:05 <shapr> pputrd: Haskell is non-strict and purely functional, that's what makes it different.
01:58:12 <pputrd> can scheme be used for bigtime rela world porgraming
01:58:16 <shapr> Yes.
01:58:17 <pputrd> ok
01:58:21 <pputrd> what do those thigns mean
01:58:32 <pputrd> can haskell handle bigtime projects?
01:58:33 * boegel thinks its shapr that makes Haskell different :)
01:58:39 <shapr> For big-time real world programming you can use Haskell, Scheme, CLisp, Smalltalk, or whatever you like.
01:58:42 <shapr> boegel: hah, thanks :-)
01:58:55 <pputrd> ?
01:58:58 <pputrd> hm
01:59:07 <boegel> shapr: you _are_ Haskell ;)
01:59:11 <shapr> pputrd: strictness has to do with when code is executed. For example, you wouldn't want both sides of an IF to be executed.
01:59:17 <xerox> (CLisp is the implementation, CL is the language.)
01:59:17 <dons> that's two people in two days who've asked "is haskell a lisp"
01:59:25 <shapr> boegel: Thanks, but I think you're exaggerating a bit ;-)
01:59:31 <boegel> dons: I say shoot them
01:59:40 * johnnowak readies the firearms 
01:59:43 <boegel> shapr: well, you and a few others then ;)
01:59:49 <pputrd> soe site I was on said haskell cant scale sicne becomes bunch of fucntions
01:59:53 <pputrd> hard to rewrite stuff
02:00:01 <dons> that doesn't make much sense
02:00:10 <johnnowak> pputrd: they're right. we use it because we're masochists. 
02:00:10 <u221e> Does putStr just putChar the individual elements of the Char list?
02:00:11 <shapr> pputrd: Tactfully put, that's fertilizer :-)
02:00:29 <xerox> u221e: mapM_ putChr does :-)
02:00:39 <dons> pputrd: go check out the tutorials on haskell.org
02:00:43 <shapr> pputrd: So, do you want me to explain non-strict or purely functional first?
02:00:45 <dons> all you questions will be answered there
02:00:59 <dons> all you questions belong to us
02:01:09 <xerox> haha
02:01:14 <shapr> Someone set us up the redex.
02:01:15 * boegel bows for dons
02:01:27 <xerox> ?remember dons all your questions belong to us
02:01:28 <lambdabot> Done.
02:01:44 <dons> hehe
02:02:22 <boegel> @quote shapr
02:02:23 <lambdabot>  Academics are continually chewing pieces off of impossible and making them merely difficult.
02:02:29 <boegel> :)
02:02:30 <shapr> @quote boegel
02:02:30 <lambdabot> boegel hasn't said anything memorable
02:02:33 <MarcWeber> Can you give me a hint on how to resolve this? http://rafb.net/paste/results/JkFbv830.html
02:02:35 <boegel> :(
02:02:53 <shapr> boegel: You've said memorable things, I think it just happened while @remember was broken.
02:03:21 <boegel> shapr: I have? can't remember, so they musn't have been that memorable
02:03:29 <pputrd> non strict
02:03:29 <xerox> MarcWeber: comment the instance Eq Command.
02:03:31 <pputrd> :)
02:03:31 * shapr grins
02:03:33 <pputrd> ;)
02:03:53 <shapr> pputrd: Non-strict means that a value is not calculated before it is needed.
02:04:08 <xerox> a.k.a. lazy.
02:04:10 <shapr> For example, head [1,1/0] does not cause an error.
02:04:16 <shapr> > 1/0
02:04:17 <lambdabot>  Infinity
02:04:22 <xerox> Cough.
02:04:25 <shapr> That is an error, but..
02:04:31 <shapr> > head [1,1/0]
02:04:32 <lambdabot>  1.0
02:04:37 <shapr> That works just fine.
02:05:18 <shapr> pputrd: You can use laziness to set up a big computation, and then only ask for the pieces that you need. The rest of the computation won't be executed.
02:05:39 <xerox> That's why we use lists as control structures.
02:05:46 * xerox can't resist...
02:05:58 <shapr> xerox: You're going to show primes, fibonacci, or what?
02:06:03 <xerox> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 15 fibs
02:06:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
02:06:36 <shapr> pputrd: Even the items in a list are not evaluated until you ask for them, so you can use infinite lists with no problem.
02:06:49 <u221e> Woo!
02:06:56 <shapr> > let ones = 1 : ones in take 5 ones
02:06:57 <lambdabot>  [1,1,1,1,1]
02:07:06 <dons> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f)
02:07:07 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:07:14 <u221e> dons, I knocked another second off the time ;)
02:07:19 <dons> oh wow!
02:07:34 <dons> when you stick these on the wiki, please @tell me, so i go and check it out
02:07:38 <xerox> > let primes = 2 : 3 : [ n | n <- [5,7..], any (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)] in take 100 primes
02:07:39 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
02:07:43 <xerox> Ops.
02:07:52 <dons> when you're done, also let me know, and i'll pass it on to the shootout guys.
02:08:01 <dons> u221e: very interested in what you've done
02:08:23 <xerox> This one is fun though, then I'll be back to primes:
02:08:26 <pputrd> ok
02:08:27 <shapr> pputrd: Laziness has big advantages in multidimensional stream programming. Other functional languages use streams, but it's more difficult to control multidimensional traversal without laziness.
02:08:41 <shapr> pputrd: Any questions about all that, or was it clear?
02:08:46 <pputrd> say I need to have remote server trade data with our central server
02:08:47 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens in (take 10 evens,take 10 odds)
02:08:48 <lambdabot>  ([2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
02:08:57 <pputrd> does haskell have ways of moving data?
02:08:59 <MarcWeber> xerox: I've tried this. Doesn't solve the problem: http://rafb.net/paste/results/yXFb3329.html Now haskell wants to copare each element of Command thus failing because there is no EQ instance for the handler function..
02:09:11 <pputrd> woa
02:09:27 <shapr> pputrd: Yes, that sort of thing is easily done. You can use the xml-rpc lib, standard sockets, or whatever.
02:09:40 <pputrd> !
02:09:47 <dons> ?
02:09:50 <pputrd> wat about monitoring failures?
02:09:51 <u221e> dons, Is there a faster way to output strings other then just calling putChar on all the elements?
02:10:10 <dons> well, we have to do byte-at-a-time, so what options does that give us?
02:10:33 <xerox> > let primes = 2 : 3 : [ n | n <- [5,7..], all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)] in take 20 primes
02:10:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
02:10:40 <dons> there's no faster way than putChar (hmm, though an ffi binding to putc might _possibly_ do it
02:10:41 <xerox> Seems like it.
02:10:43 <pputrd> what is multidem steram
02:10:50 <u221e> dons, but how does ByteString do it so fast?
02:10:51 <pputrd> and what is non strict
02:11:08 <dons> u221e: oh, for strings, it's storing them as flat byte arrays, not linked lists
02:11:44 <dons> check the slides on the fps home page, there's some graphics of the different memory layouts that [a] versus ByteString has. that explains much of the performance improvement
02:11:45 <xerox> MarcWeber: makes sense...
02:11:52 <tony3> dons, arern't you mentoring the utf8 bytestring soc project?
02:11:56 <dons> yep
02:12:19 <tony3> thats the soc I'm most interested in....
02:12:24 <tony3> how is it coming?
02:12:48 <xerox> dons: when was the talk held?
02:13:04 <dons> good so far. yeah, i haven't spoken to sjanssen today, but i think he's in a good position to finish the project
02:13:09 <dons> xerox: about a month ago
02:13:48 <pputrd> why was haskell invented?
02:13:56 <tony3> excellent, well, if he puts up a darcs repo at any time, I'd be interested to take a look,
02:14:05 <dons> to further research lazy, functional programming, pputrd 
02:14:07 <MarcWeber> xerox: Do you have another idea? Did change that much? I'm using ghc-6.5. And I think some people are using missingh without problemns
02:14:17 <tony3> be sure to buzz haskell-cafe, if and when...
02:14:40 <dons> pputrd: since it seems to be a good foundation for solving many interesting problems in language design.
02:15:10 <tony3> MarcWebber have you tried -fallow-overlapping-instances
02:15:18 <xerox> MarcWeber: no, sorry. Ping John :|
02:15:41 <pputrd> is it practical?
02:15:56 <dons> yes, hence there's 205 people in this channel
02:16:00 <xerox> dons: when was it held?
02:16:18 <dons> check out haskell.org, pputrd. seriously, all these questions are answered there..
02:16:23 <dons> xerox: ?
02:17:14 <xerox> The talk, I mean. dons
02:17:20 <dons> it was held about a month ago
02:17:38 <dons> i gave a lecture to an type systems class
02:17:42 <xerox> I mean, one of you flew thousand miles to held a talk  in the other's direction? :D
02:17:53 <MarcWeber> xerox: Thanks!
02:18:09 <dons> nono, it was just at my local univerity, to some post-grad students studying language design
02:18:16 <xerox> Ah okay :D
02:18:35 <dons> ah, i see what you mean. Duncan didn't deliver the talk, but he sure did help write the code
02:18:45 <xerox> Indeed :)
02:19:09 <shapr> pputrd: Haskell can monitor failures just fine.
02:19:20 <shapr> pputrd: (sorry, I got distracted by someone in real life)
02:19:54 <xerox> The graphs of fused pipelines is stunning.
02:19:58 <xerox> Great work, dudes.
02:20:15 <shapr> pputrd: multidimensional stream programming is where you setup an algebraic datatype to represent a computation and then traverse that datatype looking for answers. Game tree searching is a good example.
02:23:14 <xerox> `Powered by Ph.D.', eh.. ;)
02:25:14 <u221e> Char isn't an instance of Num?
02:26:08 <sieni> xerox: hmm... I could use that slogan ^_^
02:28:22 <dons> @instance Num
02:28:23 <lambdabot> Maybe you meant: instances instances-importing
02:28:26 <dons> @instances Num
02:28:27 <lambdabot> Double, Float, Int, Integer
02:28:34 <dons> u221e: nope. use fromIntegral . ord
02:28:55 <dons> ?type ord
02:28:56 <lambdabot> Char -> Int
02:28:58 <xerox> Why didn't it correct instance with instances?
02:28:58 <dons> might do you
02:29:05 <u221e> No, i'm removing type conversions, thats the point.
02:29:09 <dons> xerox: overalapped, i suppose
02:29:22 <dons> u221e: ah ok. the conversion should be a no-op though
02:29:34 <xerox> Well the `humming(?)' distance is very different for the two possibilities.
02:30:29 <shapr> pputrd: Anymore questions?
02:30:34 <shapr> xerox: hamming?
02:30:35 <amiddelk> xerox: humming -> hamming
02:30:46 <xerox> That.
02:33:24 <shapr> dons: Wow, great slides.
02:33:31 * shapr is only on page 17
02:33:56 <shapr> dons: Is there some way to tune the strict chunks to the cpu cache size?
02:34:27 <shapr> Or maybe some sort of autotuning where you profile different chunk sizes and adjust automatically?
02:35:20 * shapr reaches page 20
02:36:31 <dons> shapr: we could detect it at compile time, i suppose. maybe?
02:36:41 <dons> or just look at what cpus are most common and guess
02:37:26 <roconnor> xerox: hey there
02:37:55 <shapr> For binary distros like debian, is there some way to have the chunksize in an external config file so you can run the profiler and pick the best choice?
02:39:51 <u221e> Does 1.0 default to a Double or a Float?
02:43:28 <MarcWeber> u221e: Neither. Depends on usage
02:44:27 <MarcWeber> u221e: Wait
02:44:27 <xerox> http://news.com.com/2061-10801_3-5980850.html
02:44:28 <lambdabot> Title: "Harass co-workers with USB missiles | News.blog | CNET News.com"
02:44:39 <shapr> Wow
02:44:50 <xerox> ahah.
02:46:04 <shapr> dons: Spiffy! I especially like the QC stuff at the end.
02:47:38 <roconnor> where are these slides you are reading?
02:48:14 <shapr> http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz
02:49:40 <MarcWeber> > head $ filter (\a -> (snd a)==0) $ [ (nr, 10**(-nr)) | nr <- [1..]]
02:49:41 <lambdabot>  (324.0,0.0)
02:50:55 <MarcWeber> > head $ filter (\a -> (snd a)==0) $ [ (nr, (10::Float)**(-nr)) | nr <- [1..]]
02:50:56 <lambdabot>  (46.0,0.0)
02:51:04 <MarcWeber> > head $ filter (\a -> (snd a)==0) $ [ (nr, (10::Double)**(-nr)) | nr <- [1..]]
02:51:05 <lambdabot>  (324.0,0.0)
02:51:11 <bolrod> ?..
02:51:11 <lambdabot> Not enough arguments to @.
02:51:20 <MarcWeber> u221e: Does this answer your question?
02:53:16 <roconnor> So.... when is garbage collection done in ghc?
02:53:56 <shapr> Have you seen the non-stop haskell gc paper?
02:55:41 <xerox> http://www.freebsd.org/cgi/query-pr.cgi?pr=99979
02:55:42 <lambdabot> Title: "Problem Report kern/99979 : [patch] Get Ready for Kernel Module in C++"
02:55:47 <xerox> (!)
02:56:24 <roconnor> shapr: nope
02:56:36 <roconnor> I know nothing about how gc works in ghc
02:57:03 <vegai> xerox: auch :/
02:57:07 <tony3> it's generational, stop and copy.
02:57:23 <tony3> with two generations by default.
02:57:48 <tony3> so you have minor gc's often, and occasional major gc's.
02:57:59 <tony3> you can also force them with performGC.
02:58:10 <vegai> does lambdabot attempt to rejoin a server after losing connection?
02:58:17 <roconnor> tony3: thanks
02:58:21 <roconnor> how often is often?
02:58:52 <tony3> there is an rts option to print out gc stuff....so you can see depending on your program...
02:59:01 <roconnor> super!
02:59:06 <tony3> depends on how much allocation is going on...
02:59:59 <tony3> (my final year project was testing the real time gc described in non-stop haskell paper)
03:00:46 <shapr> tony3: Oh cool
03:01:19 <tony3> Shapr, I got rid of all the c++ from FVision, to make a fully haskell motion tracker.....
03:01:48 <dons> vegai: i'm not sure it does anymore
03:02:05 <dons> the best thing for now would be to : while true ; do ./lambdabot --online ; done
03:02:20 <vegai> hmm, but it doesn't seem to quit after being kicked out either
03:02:33 <vegai> I mean, after losing connection
03:04:56 <u221e> Are guards slower then if-then-else statements or something?
03:05:42 * vegai votes "or something"
03:05:59 <roconnor> I'd imagine guards are translated into if-then-else statements by the compiler.
03:06:08 <tony3> I love QuickCheck, I just found a non-deterministic bug related to concurrency in my code that might have taken forever to catch otherwise....
03:06:24 <u221e> I just removed an if statement, replaced it with a guard, and now it's 2 seconds slower
03:06:41 <roconnor> tony3: how did you end up having a nondeterministic bug?
03:07:51 <roconnor> u221e: care to show the two pieces of code?
03:09:02 <tony3> um, becuase a context switch would very rarely occur at the one place in the excecution that would cause an error.
03:09:57 <u221e> roconnor, alright. WHat's that pasteing site again?
03:09:57 <shapr> tony3: that's way cool.
03:10:18 <shapr> tony3: Is that code online?
03:10:25 <roconnor> ?paste
03:10:25 <lambdabot> http://paste.lisp.org/new/haskell
03:11:04 <tony3> shapr, I'm affraid not, the original FVision code isn't for general release apparently.
03:11:21 <roconnor> dons: I wonder if we could prove the correctness of your rewrite rules in coq.
03:11:31 <shapr> tony3: That sucks :-(
03:11:54 <tony3> I could, at some point build my algorithms into a tracker without the FVision dsl...
03:12:15 <shapr> Where are your publications?
03:12:42 <tony3> I don't have any! It was just an undergrad project.
03:12:56 <lisppaste2> u221e pasted "Guards" at http://paste.lisp.org/display/22448
03:13:15 <shapr> Too bad, I wanted to know how Non-stop Haskell worked with FVision.
03:13:41 <shapr> Anyway, time to upgrade to 2.6.17, bbl
03:13:51 <tony3> shapr, I think Andrew Cheadle might still get that real time GC into ghc..
03:15:31 <tony3> anyone use HUnit tests here?
03:16:52 <u221e> roconnor, can you make any sense of it? ;)
03:17:58 <roconnor> nope
03:18:05 <roconnor> I'm surprised
03:19:29 <u221e> THe only thing really different about them is the binding in the second case
03:20:44 <roconnor> I suppose if you are interested you can fiddle so that the _only_ difference is the change of the if to a guard
03:20:56 <roconnor> as it stands there are a few other changes too.
03:21:11 <roconnor> but I don't really know why any of the changes would have an effect
03:51:21 <dons> roconnor: there'd be a research paper or two in it. i've talked to one of the lead isabelle guys (Gerwin Klein) and he thinks its highly doable, but a bit of work
03:51:31 <dons> depends on how much we want to prove
03:51:43 <dons> (how deep we go before we start assuming things)
03:56:05 <shapr> Does anyone know of regular meetings on the subject of type theory, functional programming, etc in or near Stockholm?
03:59:07 * paolino is focusing a little the monad :/
03:59:51 <paolino> a meta-function composition
04:02:46 <paolino> can it be any correct to say "compose under a monad" ?
04:03:02 * shapr doesn't know
04:12:16 * shapr boings
04:39:10 <xerox> It should be (>>=) I think.
04:39:47 <xerox> In the computational view of the monad it is what composes the action and the function to form the new action.
04:51:38 <xerox> (Take (>>) as composition if you need to compose (`sequence') actions only.)
04:56:00 <greenrd> I think the user documentation for GADTs is somehow incorrect.
04:56:26 <greenrd> It says (section 7.5 of the GHC user guide) "The type signature of each constructor is independent, and is implicitly universally quantified as usual."
04:57:05 <greenrd> However, at the end of the section, it then gives an example of a constructor with a type signature with implicit *existential* quantification.
04:57:25 <greenrd> data T' a where { MKT :: b -> (b->a) -> T a }
04:57:58 <greenrd> Here, I think b is existentially quanitified, and a is universally quantified
04:58:20 <dblhelix> greenrd: depends on your pov, I guess
04:58:30 <greenrd> How so?
04:58:40 <greenrd> It's a very relevant difference
04:58:51 <dblhelix> greedrd: MKT has type forall a b . b -> (b -> a) -> T a
04:59:17 <dblhelix> greenrd: here, both a and b are universally quantified
05:00:20 <dblhelix> greenrd: the fact that b does not show up as a type argument in the result type makes that T is an existential type
05:01:07 <dblhelix> greenrd: so, one could say that we have support for existential types here, even though we have no existential quantification 
05:01:45 <greenrd> I'm confused
05:01:55 <dblhelix> greenrd: you should be :)
05:02:06 <greenrd> Actually, my real question which led to this criticism was this:
05:02:25 <dblhelix> greenrd: (for I'm obviously explaining this in a very unclear way)
05:02:28 <greenrd> data Quant a p where Quant :: Quant a (a,b)
05:02:54 <dblhelix> greenrd: this is GADT
05:03:06 <dblhelix> greenrd: GADT subsume existential types
05:03:14 <greenrd> In Quant, is b existentially quantified, or universally quantified?
05:03:29 <dblhelix> greenrd: universally
05:03:44 <dblhelix> greenrd: as said, we only have universal quantification
05:04:31 <dblhelix> greenrd: notice, for instance, that there is no exists keyword in glasgow haskell
05:06:41 <dblhelix> Quant :: forall a b . Quant a (a, b)
05:09:41 <greenrd> Well I can't verify your signatures unfortunately because ghci can't see those constructors :(
05:09:46 <greenrd> Seems like a bug in ghci
05:09:59 <greenrd> But anyway, the point is, there is something which looks like existential quantification
05:10:21 <greenrd> Take MkT for instance.
05:10:40 <greenrd> You can't just extract the second argument of MkT and apply it to any value.
05:10:57 <dblhelix> greenrd: i'd say: there is something that people tend to confuse with existential quantification
05:11:03 <greenrd> haha, ok
05:11:07 <greenrd> What should I call it then?
05:11:14 <kosmikus> whether the quantifier is existential or universal depends on your viewpoint. the "b" above is what you usually call an existential type
05:11:53 <greenrd> kolmodin: ah, thanks
05:11:56 <greenrd> oop
05:12:00 <greenrd> kosmikus: thanks
05:12:55 <kosmikus> oh, to add to the confusion, I retract my statement. I didn't look closely, and this is actually not true.
05:13:08 <greenrd> oh
05:13:09 <kosmikus> You only call it an existential type if it isn't visible in the result type.
05:13:10 <dblhelix> :)
05:13:30 * dblhelix agrees
05:13:45 <kosmikus> data Example a where Example :: (b -> a) -> a -> Example a
05:13:53 <kosmikus> here, the b would be an "existential" type
05:14:27 <dblhelix> kosmikus: still, I feel both b and a are universally quantified in the data constructor
05:14:50 <kosmikus> sure, they're always universally quantified in the constructor
05:14:53 <greenrd> But isn't Example rather useless because you can never apply its first argument to anything?
05:15:07 <greenrd> because you don't have a value of type b
05:15:32 <kosmikus> but a constructor in Haskell, perhaps confusingly, is dinstinguished from an ordinary function that it can also be used as a destructor (in pattern matching), and there the existential semantics kicks in
05:15:42 <dblhelix> kosmikus: well, from wich pov, would you then argue that b is existentially quantified
05:15:55 <kosmikus> greenrd: just a meaningless example, yes
05:15:55 <amiddelk> I guess kosmikus means: Example :: (b -> a) -> b -> Example a
05:16:07 <greenrd> ok
05:16:17 <kosmikus> amiddelk is right. that's what I meant to write, but indeed it's still pretty useless.
05:16:37 <kosmikus> because now all you can do is apply the function to the one argument, so you could also store the result of that application immediately.
05:16:48 <dblhelix> (an then he'll call the data constructor App and the type constructor Spine and start writing a paper about it :))
05:16:51 <kosmikus> but nevertheless, there are uses of existentials.
05:16:53 <greenrd> I wondered, however, if the variable only occurs on the right-hand side of the last arrow, is it "existential" or "universal"?
05:16:58 <greenrd> Hence my Quant example.
05:17:21 <greenrd> (which has no arrows, but hey, you know what I mean.)
05:17:38 <kosmikus> if it only occurs in the result type, it isn't existential.
05:17:45 <greenrd> Ah
05:17:46 <kosmikus> some people call it a "phantom" type variable
05:18:02 <kosmikus> because it makes it possible to "artificially" distinguish things that have the same representation
05:18:10 <greenrd> But in ghc 6.4.2, it seems to be rigid if the whole type is rigid
05:18:22 <greenrd> which means, in effect, that it isn't universally quantified any more
05:18:26 <greenrd> or am I confused?
05:18:55 <kosmikus> example?
05:19:05 <greenrd> ah, my code is quite complicated
05:19:17 * dblhelix is dazzled with wobbliness
05:19:39 <greenrd> however, the GADT paper for ICFP does say that if a type is rigid all its components are rigid as well, so that would seem to be expected behaviour
05:20:07 <greenrd> I guess I should just stick an explicit forall in there when I refer to the GADT.
05:20:39 <kosmikus> that's always implicitly there
05:20:40 <greenrd> Unfortunately, I tried that, and that has the side-effect that it prevents me from "currying" the type constructor :(
05:21:02 <kosmikus> but I agree that it'd be good if Haskell programmers started to write it explicitly
05:21:03 <greenrd> no, I mean a forall inside a parentheses
05:21:19 <kosmikus> ah, ok
05:21:36 <greenrd> i.e. higher-rank polymorphism
05:22:06 <greenrd> I have a fuzzy intuitive idea of what all this stuff means, but I don't understand it that clearly :)
05:24:02 <kosmikus> you can read the "sexy types in action" paper. IIRC, it contains some motivating examples and pointers.
05:24:14 <greenrd> sexy types, eh?
05:25:14 <kosmikus> yeah ;)
05:25:53 <SamB_XP> how do you tell if a type is sexy or not?
05:26:34 <greenrd> See if you can get ghc to accept it without -fglasgow-exts?
05:26:56 <greenrd> I imagine that would be the approximate answer.
05:27:00 <SamB_XP> heh
05:36:46 <greenrd> oh
05:36:52 <greenrd> "There is one place you cannot put a forall: you cannot instantiate a type variable with a forall-type"
05:36:56 <greenrd> Damn.
05:37:55 <greenrd> oh, but if I put the forall "one level up", it should be allowed?
05:38:21 <esap> explain, "one level up"?
05:39:10 <greenrd> i.e. (forall a. [a]) instead of [forall a. a]
05:39:20 <greenrd> the former is allowed, right?
05:39:22 <amiddelk> greenrd: that makes a difference
05:39:31 <amiddelk> but indeed, the first one is allowed
05:39:46 <esap> greenrd: Yes, the first one is allowed. But the meaning of those is different
05:39:51 <dblhelix> greenrd: still, there's work on so-called "boxy types" that'll probably make the latter possible in due time
05:39:53 <greenrd> so the text I quoted is misleading, if not wrong.
05:40:14 <greenrd> How is the meaning different?
05:40:45 <esap> greenrd: If you had [forall a. a], then each element of the list could have different type. In forall a. [a], each element of the list must have the same typer.
05:41:10 <greenrd> ah I see
05:41:17 <dblhelix> esap: I do not agree
05:41:36 <esap> dblhelix: why?
05:41:46 <dblhelix> esap: [forall a. a] would not be the type of a heterogeneous list
05:42:09 <dblhelix> esap: it would be the type of a list of bottoms: [undefined, ..., undefined]
05:42:11 <amiddelk> depends on impredicativity I guess?
05:42:14 <esap> dblhelix: maybe you mean the difference between [forall a.a] and [exists a.a] ?
05:42:25 <dblhelix> esap: indeed
05:43:58 <esap> dblhelix: ok, granted, forall a.a is same as _|_, which is the type of 'undefined'. But hmm.. how does instantiation work for that?
05:44:11 <lisppaste2> BetaTEST pasted "how to make that program eager in mainLoop?" at http://paste.lisp.org/display/22454
05:44:46 <xerox> May someone say the last word and give a comrehensive explanation of type variable quantification in Haskell?
05:44:52 <xerox> (Or is it qualification?)
05:44:54 <amiddelk> esap: if your type system is impredicative, then you delay instantiation, and then you can write [undefined, undefined, undefined] :: [forall a . a]
05:45:07 <esap> dblhelix: there is an unique function exit : (forall a.a) -> b, for each type b.
05:45:45 <dblhelix> esap: I guess there's no instantiation going on... only when you apply the elements of the list: f :: [forall a . a] -> Int ; f = head
05:46:35 <dblhelix> xerox; I'd say (in GHC) there's only universal quantification
05:47:01 <esap> dblhelix: ok, true. I confused the existential quantification with the conversion _after_ extraction from the list.
05:47:19 <esap> dblhelix: s/conversion/instantiation/
05:47:22 <dblhelix> esap: there's a relation with the last example you gave
05:48:12 <xerox> dblhelix - So how does one do heterogenous list?
05:48:21 <dblhelix> esap: exists a . a    ~=     (forall a . a -> b) -> b
05:48:53 <dblhelix> xerox: with some type-class hacking... cf. Laemmel and Kiselyov
05:49:09 <esap> xerox: data HList a where { Cons :: b -> HList (b,a) ; Nil :: HList a }
05:49:31 <esap> xerox: ugh, Cons :: b -> HList a -> HList (b,a)
05:50:04 <esap> xerox: That uses GADTs for the heterogeneous list
05:50:36 <xerox> dblhelix: HList doesn't use Type Classes, does it?
05:51:47 <xerox> So the difference between ADT and GADT is that with the latter you can decide the return type of the datD[D[Da constructors?
05:51:57 <xerox> data, even.
05:52:20 <dblhelix> xerox: it does:
05:52:20 <esap> xerox: yes. And there is refinement of the type when you pattern match against the constructors
05:53:20 <xerox> esap, what refinement? It is not positional anymore?
05:53:24 <esap> There's actually a nice way to implement polymorphic stacks with GADTs:  data Stack a where { Frame :: f (Stack a) -> Stack (f a) }
05:55:48 <esap> xerox: It means that if your constructor's type in a GADT is declared as something more specific than what's the type of the datatype, then within the case branch, you can use that information.
05:58:01 <esap> xerox: So the variables bound by the case branches will get types that are more specific than the original datatype, because the constructor is declared as more specific.
05:58:50 * xerox scratches his head
05:59:07 <esap> xerox: So, suppose you have data Expr a where { Plus :: Expr Int -> Expr Int -> Expr Int }, then case e of { z@(Plus x y) -> ... }, z has type Expr Int, as do x and y.
05:59:29 <esap> xerox: Even if 'e :: Expr a'
06:00:27 <esap> xerox: And this is because the constructor has been restricted to work on Ints only.
06:01:09 <xerox> That's true!
06:01:20 <esap> That's refinement
06:03:22 <BetaTEST> so.. any comments about my paste? :)
06:03:29 <xerox> Does it enable anything useful beside being required because of GADT nature?
06:04:43 <esap> xerox: It's the basis of the power of GADTs. If enables you to specify data constraints in much more fine-grained way than ordinary datatypes.
06:06:30 <esap> xerox: and the compiler will make sure (due to refinement) that the constraints are satisfied when needed.
06:06:52 <xerox> I like it.
06:06:59 <xerox> Do you have an example application?
06:08:26 <esap> xerox: the stack example. data Stack a where { Frame :: f (Stack a) -> Stack (f a) } ; push = curry Frame ; pop (Frame x) = x
06:08:43 * xerox falls over the chair
06:09:07 * xerox has the urge of running GHCi
06:09:07 <esap> xerox: new_stack = Frame id
06:12:31 <xerox> Prelude> :load Stack.hs
06:12:31 <xerox> [1 of 1] Compiling Stack            ( Stack.hs, interpreted )
06:12:31 <xerox> ghc-6.5.20060608: panic! (the 'impossible' happened)
06:12:31 <xerox>   (GHC version 6.5.20060608 for i386-apple-darwin):
06:12:31 <xerox>         kindFunResult ?
06:12:33 <xerox> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
06:12:35 <lambdabot> Title: "1.2. Reporting bugs in GHC"
06:12:52 <xerox> kindFunResult ?  <-- it seems coming from @ghc 
06:12:55 <esap> heh :-)
06:12:58 <xerox> @ghc
06:12:59 <lambdabot>  eval_thunk_selector: strange selectee
06:13:05 <xerox> Meh!
06:13:22 <esap> I suppose you might need to give types for push, pop and new_stack :-)
06:13:31 <xerox> The funny thing is that GHCi is still opebn
06:13:35 <xerox> *open
06:13:58 <xerox> ?paste
06:13:58 <lambdabot> http://paste.lisp.org/new/haskell
06:15:39 <lisppaste2> xerox pasted "Stack.hs panic! kindFunResult ?" at http://paste.lisp.org/display/22458
06:15:49 <esap> The types are: push_stack :: a -> Stack b -> Stack (a,b)    pop_stack :: Stack (f a) -> f (Stack a)  and new_stack :: Stack (Stack a -> a)
06:16:55 <esap> do you have {} around the where part of the data declaration?
06:16:58 <xerox> What happens when pop, pops too much?
06:17:04 <xerox> No, I don't.
06:17:12 <esap> pop newStack == id
06:17:23 <esap> s/newStack/new_stack/
06:17:28 <xerox> What, that's sensible.
06:17:37 <xerox> s/What/Wow/1
06:17:45 <esap> That's why new_stack is defined as "Frame id"
06:18:12 <xerox> I mean, looks like a sensible thing in data design.
06:19:01 <xerox> pop's type seems wrong.
06:19:18 <esap> hmm why?
06:19:35 <esap> it's more general than what is strictly needed
06:20:03 <xerox> Right, nevermind.
06:21:04 <xerox> Very nice datastructure!
06:21:06 <xerox> Thanks much.
06:22:39 <esap> Unfortunately, the current implementation of GADTs in GHC do not work as well as I have hoped. I've been getting many panics from GHC lately when using GADTs. Especially if you constrain GADTs with type class constraints
06:23:07 <xerox> Do you have other nice GADT code?
06:24:03 <esap> xerox: Yes, I tried to build the parse tree of my compiler using GADTs. It failed spectacularly due to problems in GHC implementation of GADTs
06:24:25 * xerox chuckles
06:24:27 <esap> xerox: And I had to revert to using non-GADT types
06:25:41 <esap> xerox: see http://www.kotiposti.net/epulkkin/TTree.txt. It's only half-finished though
06:26:17 * xerox steps back
06:26:26 <esap> xerox: See for example, the type of TCompose in the TArrow datatype.
06:26:30 <xerox> Cathegory Theory programming?<interrobang>!
06:26:38 <esap> hehe :-)
06:27:09 <NotInventedHere> Hi silly question: how do I type inline my name in the phrase I'm writing (like xerox did in "xerox steps back")?
06:27:31 <xerox> /me inlines
06:27:36 * xerox inlines
06:27:40 <NotInventedHere> aha! thx
06:27:51 <xerox> esap, what is the difference between 'T' and 'S' prefixes?
06:28:48 <esap> xerox: The ones starting with ST are existentially packaged versions of the ones starting with T.
06:29:13 <MarcWeber> Is this usage of runInteractiveProcess correct? I'm getting ExitSuccess and ExitFailure 13 using the same commandline
06:29:29 <MarcWeber> http://rafb.net/paste/results/dqm9ZT57.html
06:29:34 <esap> xerox: In order to be able to parse from a non-typed strings, you have to encapsulate the type variables, because their type is determined only at run-time.
06:29:42 <xerox> Would you mind explaining what is that code? Over to #haskell-overflow if we don't want to flood the channel with this topic while people is requesting other informations.
06:30:38 <esap> ok
06:31:02 <xerox> Sorry, non-typed strings? I don't understand what are you talking about in your last phrase.
06:31:46 <MarcWeber> xerox: Was your request addressing me?
06:32:03 * esap went to #haskell-overflow
06:32:09 <xerox> MarcWeber: I have no idea.
06:33:34 * edwardk waves ello.
06:41:16 <u221e> How do I drop the fractional part of a Double?
06:41:42 <u221e> If it's 1.234, I just want 1.0
06:42:10 <NotInventedHere> u221e: floor
06:42:39 <integral> NotInventedHere: doesn't floor round towards 0, so wouldn't "drop the fractional part" for negative numbers?
06:44:15 <NotInventedHere> it would round down to the next negative number, so floor (-1.23) == -2. So it's probably not the right answer, actually ;-)
06:44:39 <u221e> It doesn't work on Doubles...
06:45:05 <vegai> hmm, I'm a bit stuck with one of the first assignments on SoE...
06:45:24 <tony3> u221e round
06:45:30 <vegai> I suppose this book will teach me more geometry than Haskell
06:45:33 <tony3> >round 1.56
06:45:36 <roconnor> @seen dons
06:45:36 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2 hours, 53 minutes and 54 seconds ago.
06:45:43 <tony3> > round 1.56
06:45:44 <lambdabot>  2
06:45:47 <NotInventedHere> > truncate 1.34
06:45:48 <lambdabot>  1
06:45:54 <roconnor> dons: Have you looked at http://www.coverproject.org/
06:45:55 <NotInventedHere> > truncate (-1.23)
06:45:56 <lambdabot>  -1
06:45:56 <lambdabot> Title: "Cover Project"
06:46:00 <NotInventedHere> seems ok?
06:46:00 <tony3> > truncate 1.6
06:46:01 <lambdabot>  1
06:46:15 <NotInventedHere> tony3: beat you to it ;-(
06:46:20 <roconnor> dons: I'd presonally be inclined to do it in coq (which has haskell extraction)
06:47:00 <roconnor> dons: you don't have a paper about your fusion laws?
06:50:43 <u221e> Damn, truncate doesn't return a double...
06:51:17 <dmhouse> @type truncate
06:51:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:51:31 <dmhouse> @type fromIntegral . truncate
06:51:32 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
06:51:37 <NotInventedHere> dmhouse: exactly
06:51:55 <dmhouse> @type (`mod` 1)
06:51:56 <lambdabot> forall a. (Integral a) => a -> a
06:52:06 <NotInventedHere> u221e: hoogle is your friend!
06:52:27 <xerox> Interactive proving sounds fun!
06:52:46 <dmhouse> xerox: ?
06:55:07 <u221e> I've been using hoogle alot recently
06:55:11 <Lemmih> > fromIntegral (truncate (10.12::Double)) :: Double
06:55:12 <lambdabot>  10.0
06:56:22 <NotInventedHere> all: does anyone know of any bindings to cocoa, that is not wxHaskell (seems this is not maintained so well)?
06:57:44 <NotInventedHere> apparently not...
07:04:38 <xerox> u221e: I personally not find it so useful.
07:05:10 <dmhouse> xerox: I like it as a combined @type and @index.
07:05:27 <dmhouse> But I think it gives too many useless results.
07:08:06 <xerox> Why do you need it if you have type and index? Names?
07:12:52 <dmhouse> Is there an iterateUntil?
07:13:09 <dmhouse> That iterates a function until the result passes some predicate?
07:13:27 <dmhouse> Perhaps fromJust . find p . iterate
07:15:00 <gds> can you use unfold to do that?
07:15:12 <xerox> Jup!
07:15:26 <dmhouse> You can?
07:15:55 <gds> @type unfold
07:15:56 <lambdabot> Not in scope: `unfold'
07:15:57 <dmhouse> It's not going to be shorter than fromJust . find p . iterate though.
07:16:02 <dmhouse> @hoogle unfoldr
07:16:02 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
07:16:03 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
07:16:16 <dmhouse> You'd need to define a boolToMaybe.
07:17:03 <gds> I guess so...
07:17:25 <gds> either that, or use takewhile and never return Nothing....
07:17:45 <dmhouse> And last.
07:17:49 <gds> indeed.
07:17:57 <dmhouse> Which is precisely the same as fromJust . find p :)
07:18:01 <gds> :)
07:18:07 <dmhouse> So there's no point to using unfoldr over iterate.
07:18:14 <gds> Cool :)
07:20:40 <roconnor> @hoogle until
07:20:40 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
07:20:40 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
07:20:50 <roconnor> @type iterate
07:20:51 <lambdabot> forall a. (a -> a) -> a -> [a]
07:20:57 <roconnor> ah
07:21:31 <dmhouse> Ooh.
07:21:46 <dmhouse> > until (> 5) (+1) 0
07:21:47 <lambdabot>  6
07:21:49 <dmhouse> Lovely!
07:22:01 <roconnor> oh, that's what you want?
07:22:09 <dmhouse> Yeah.
07:23:06 <roconnor> @djinn (a -> Bool) -> (a -> a) -> a -> a
07:23:07 <lambdabot> f a b c =
07:23:07 <lambdabot>   case a c of
07:23:07 <lambdabot>   False -> b c
07:23:07 <lambdabot>   True -> c
07:23:19 <roconnor> oh well
07:57:03 <dmhouse> What's an easy function with a polymorphic type?
07:57:16 <neologism> length?
07:57:23 <dmhouse> Perfet.
07:57:40 <dmhouse> I wanted something a little more complicated than id but not involving things like HOFs or typeclasses, that's great.
07:58:22 <xerox> f [] = 0
07:58:29 <xerox> f (_:xs) = 1 + f xs
07:58:41 <dmhouse> Thanks, xerox, I did know how to define length :)
07:59:07 <int-e> oh, and now it has type Num a => [b] -> a
07:59:10 <int-e> @type length
07:59:11 <lambdabot> forall a. [a] -> Int
07:59:20 <xerox> ?type Data.List.genericLength
07:59:21 <lambdabot> forall i b. (Num i) => [b] -> i
07:59:25 <int-e> yep
08:00:04 <xerox> int-e - I don't know if you are interested in CT but #haskell-overflow is hosting a nice dialogue about that.
08:46:19 <the_lord> @hoogle [a] -> a
08:46:20 <lambdabot> Prelude.head :: [a] -> a
08:46:20 <lambdabot> Prelude.last :: [a] -> a
08:46:20 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
08:46:24 <the_lord> last
08:46:28 <the_lord> @hoogle [a] -> [a]
08:46:29 <lambdabot> Prelude.cycle :: [a] -> [a]
08:46:29 <lambdabot> Prelude.init :: [a] -> [a]
08:46:29 <lambdabot> Prelude.reverse :: [a] -> [a]
08:46:38 <the_lord> init [2,3,4,5]
08:46:41 <the_lord> > init [2,3,4,5]
08:46:47 <lambdabot>  [2,3,4]
08:46:53 <the_lord> > last [2,3,4,5]
08:46:54 <lambdabot>  5
08:47:02 <the_lord> good
08:48:37 <bolrod> good?
08:49:10 <yaxu> another desperate newbie question - how do i parse a string into an integer? 
08:49:22 <sjanssen> > read "123" :: Integer
08:49:23 <lambdabot>  123
08:49:34 <yaxu> thanks sjanssen
08:49:57 <ndm> @hoogle String -> Int
08:49:58 <lambdabot> No matches, try a more general search
08:50:14 <bolrod> @type read
08:50:16 <lambdabot> forall a. (Read a) => String -> a
08:50:37 <bolrod> @hoogle String -> a
08:50:38 <lambdabot> Prelude.error :: String -> a
08:50:38 <lambdabot> Debug.Trace.trace :: String -> a -> a
08:50:38 <lambdabot> Prelude.fail :: Monad m => String -> m a
08:51:19 <bolrod> @instance Read
08:51:20 <lambdabot> Maybe you meant: instances instances-importing
08:51:25 <bolrod> @instances Read
08:51:27 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
08:52:40 <kpreid> ndm: by the way, hoogle doesn't find =<< or liftM given their types
08:53:04 <xerox> Hoogle n doesn't look at class constraints.
08:53:05 <ndm> kpreid: a known bug, higher kinded type classes (i.e. Monad) don't work properly
08:53:07 <xerox> Hoogle (n+1) will do.
08:53:17 <ndm> it does look at class constraints, just not higher kinded ones
08:53:20 <kpreid> ndm: that makes sense
08:53:30 <ndm> well, it does look at higher kinded ones, it just gets it totally wrong :)
08:53:41 <ndm> it is scheduled for fixing in Hoogle 4
09:16:08 <the_lord> @hoogle lookup
09:16:08 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
09:16:08 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
09:16:08 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
09:16:38 <lispy> eivuokko: ping?
09:17:55 <lispy> @tell eivuokko What should I name the common dialog module?  For now I'll just use ComDlg
09:17:56 <lambdabot> Consider it noted.
09:23:54 <the_lord> how do I catch exceptions?
09:24:27 <Cale> @type catch
09:24:28 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
09:24:41 <the_lord> Cale: thx
09:24:43 <Cale> Well, look in Control.Exception
09:30:57 <xerox> ?docs Control.Exception
09:30:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
09:53:18 <largos> ?paste
09:53:18 <lambdabot> http://paste.lisp.org/new/haskell
09:55:24 <sjanssen> @keal
09:55:25 <lambdabot> my proof show math is broken right now
09:55:33 <sjanssen> oh no!
09:55:53 <lisppaste2> largos pasted "suggestions for a more elegant approach?" at http://paste.lisp.org/display/22475
09:56:45 <sjanssen> change "length s > 0" to "not (null s)"
09:57:56 <largos> is the second more efficient?
09:58:32 <kpreid> Yes.
09:58:36 <tony3> sjanssen, you are working on UTF8 layer for SoC, is this correct?
09:58:37 <largos> at my (meager) level of haskell experience, length seems like a more descriptive function
09:58:39 <largos> ok
09:58:40 <sjanssen> yes, the second only peeks at the first cons cell
09:58:45 <largos> ah, cool
09:59:17 <sjanssen> tony3: I'm working on a packed unicode string, and I'll write some routines for UTF-8 IO
09:59:50 <tony3> very good, that will be rather useful to me! How's it coming?
09:59:59 <largos> what about associate? it seems horribly convoluted, but I haven't found anything much simpler using Text.Regex
10:00:29 <sjanssen> tony3: it is going well
10:00:49 <dgoldsmith> sjanssen: packed how? What kinds of operations is the type intended to support?
10:01:00 <sjanssen> tony3: what do you plan to use the unicode stuff for, if you don't mind me asking?
10:01:09 <tony3> be sure to buzz haskell-cafe if you set up a darcs repo, I'd be interested to have a look.
10:01:14 <sjanssen> dgoldsmith: are you familiar with fps/Data.ByteString
10:01:32 <dgoldsmith> sjanssen: not yet -- still learning Haskell
10:02:17 <tony3> sjanssen, I'm writting an app which requires many languages.
10:02:57 <sjanssen> ByteString are arrays of characters rather than linked lists -- the idea is to put a nice list like interface around very fast array operations
10:03:41 <tony3> but, one part is a naive baysian thing, which is being trained over several gigs of docs all of which are utf8.
10:04:02 <tony3> currently that bit is in C and quite a pain.
10:04:11 <dgoldsmith> I think I get it. Also, just took a quick look at the fps/Data.ByteString page...
10:04:26 <dgoldsmith> So will the model for Unicode be a fast array of Char, or something else?
10:04:54 <sjanssen> tony3: I have a darcs repo at http://darcs.haskell.org/SoC/fps-soc/, however the unicode stuff isn't there yet.  I've been working on the other aspects of my project
10:04:55 <lambdabot> Title: "Index of /SoC/fps-soc"
10:05:24 <sjanssen> dgoldsmith: internally, a fast array of Word32
10:05:27 <tony3> sjanssen, cool,, what are the other aspects?
10:05:43 <sjanssen> but those will be converted to/from Char in the library interface
10:06:38 <sjanssen> tony3: ropes (tree based string structure that has fast concatenation), and a Stringable class that lets you write generic String code
10:07:08 <tony3> Ah, very good, I've missed a rope implmentaion.
10:08:03 <dgoldsmith> sjanssen: one thing you might want to do is arrange so that the internals can work with the UText abstraction in ICU (http://icu.sourceforge.net/).
10:08:35 <tony3> sjanssen, if there will only be UTF8 IO, I won't be able to tell the size of the underlaying utf8 byte array, until writing it out?
10:08:40 <dgoldsmith> UText has been revised for the upcoming ICU 3.6, so you'd need to look in the CVS repository (browsable online). Let me look...
10:08:47 <lispy> largos: how goes your battery monitor?
10:09:40 <sjanssen> tony3: yeah, such is the peril of a variable length encoding
10:09:45 <tony3> Unicode is all 4 bytes right (UArray's)? That makes for an easier implmentation for you than UTF8 I suppose,
10:09:56 <sjanssen> oh yeah, that's what I'm doing
10:10:30 <sjanssen> storing everything in 4 bytes -- I think parsing UTF8 every time you want  to do an operation has too much overhead
10:10:46 <dgoldsmith> http://dev.icu-project.org/cgi-bin/viewcvs.cgi/icu/source/common/unicode/utext.h
10:10:47 <lambdabot> Title: "CVS log for icu/source/common/unicode/utext.h"
10:11:07 <tony3> but UTF8 could be stored in a boxed array of utf8 chars though right?
10:12:11 <beelsebob_> does darcs have an equivalent to trac?
10:12:36 <lispy> beelsebob_: darcs has trac
10:12:48 <lispy> beelsebob_: check the darcs.net wiki there should be a link to it
10:13:06 <sjanssen> tony3: I'm not sure I follow you.  There isn't really such a thing as a "utf8 char", as I understand it
10:13:59 <tony3> well, I don't mean char as in byte but as in a type which could be 1, 2, 3, or 4 bytes. (hence the boxed array requirement) 
10:14:16 <sjanssen> ah yes, sure you could do that
10:14:36 <sjanssen> but once you've got a boxed array, you're nearly as bad as a linked list
10:14:55 <tony3> hmm, is that true?
10:15:23 <tony3> but at least no parsing,
10:15:30 <sjanssen> true
10:15:37 <tony3> and you'd get to know the size of the underlaying array.
10:16:36 <dgoldsmith> quick technical intro to Unicode: http://www.unicode.org/standard/principles.html
10:16:37 <lambdabot> Title: "Technical Introduction"
10:17:01 <dgoldsmith> explains UTF-8 vs. UTF-16 vs. UTF-32, character vs. glyph, etc.
10:20:28 <the_lord> how do I change the vales of a record?
10:20:54 <michael> rec { label = value }
10:22:03 <the_lord> michael: thx
10:22:30 <sjanssen> well, I'm off for now.  tony3, dgoldsmith good talking with you on the Unicode stuff
10:22:48 <tony3> sjanssen, cheers, bye.
10:23:21 <tony3> (also I'll happily alpha/beta test)
10:30:56 <lispy> @type space
10:30:58 <lambdabot> Not in scope: `space'
10:31:01 <lispy> @hoogle space
10:31:02 <lambdabot> Text.PrettyPrint.HughesPJ.space :: Doc
10:31:02 <lambdabot> Text.ParserCombinators.Parsec.Char.space :: CharParser st Char
10:31:02 <lambdabot> Text.Html.spaceHtml :: Html
10:31:14 <lispy> @hoogle isSPace
10:31:14 <lambdabot> Char.isSpace :: Char -> Bool
10:31:47 <lispy> > isSpace '\t'
10:31:48 <lambdabot>  True
10:32:00 <dgoldsmith> sjanssen: thanks for discussing it!
10:32:49 <lispy> @hoogle trim
10:32:50 <lambdabot> No matches found
10:32:55 <lispy> @hoogle strip
10:32:55 <lambdabot> No matches found
10:33:07 <lispy> is there a function for droping the whitespace?
10:33:09 <alec> lispy: there's a strip in MissingH.Str
10:33:12 <lispy> ah
10:33:41 <alec> lispy: you could roll it yourself; String == [Char]
10:33:52 <alec> lispy: (if you don't have access to MissingH)
10:42:17 <lispy> @hoogle assoc
10:42:17 <lambdabot> Control.Parallel.Strategies.Assoc :: data Assoc a b
10:42:17 <lambdabot> Text.ParserCombinators.Parsec.Expr.Assoc :: data Assoc
10:42:17 <lambdabot> Array.assocs :: Ix a => Array a b -> [(a, b)]
10:46:26 <largos> hm..
10:46:31 <largos> Array.assocs could do it
10:51:26 <lispy> i need help learning to use hsc2hs but the only manual i can find is in the ghc manual and it's really short with no examples
10:51:41 <lispy> largos: arrays in haskell are generally a bad ideas
10:54:23 <lispy> largos: because haskell is so different from other languages and lists have been heavily optimized in ghc; lists are often much better to use
10:55:36 <SamB> they fuse well too
10:56:37 <lispy> so let's say i have a struct in a .h file, do i have to recreate it in my .hsc file?
10:56:49 <lispy> and if so, does .hsc help me with the marshalling?
10:57:44 <lispy> http://tinyurl.com/5wchk
10:57:50 <lispy> that is the struct i want to use
10:58:12 <lispy> if tiny urls bug you the full url is http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/userinput/commondialogboxlibrary/commondialogboxreference/commondialogboxstructures/openfilename.asp
11:04:25 <ihope> > filter (not . isSpace) "Hello, world!"
11:04:26 <lambdabot>  "Hello,world!"
11:15:42 <lispy> is this true?
11:15:44 <lispy> http://en.wikipedia.org/wiki/Levenshtein_distance#Haskell
11:15:51 <lispy> i didn't think that haskell memoized
11:16:26 <xerox> Yup.
11:16:40 <dmhouse> lispy: Why wouldn't it?
11:16:54 <lispy> <shrug> i just didn't think it did :)
11:17:15 <largos> the IO monad prevents memoization, I'm assuming?
11:17:28 <dmhouse> lispy: I'd expect so.
11:17:31 <sjanssen> I don't think that's a true statement
11:17:45 <sjanssen> GHC won't memoize any of that
11:19:01 <sjanssen> least, I'm pretty sure
11:19:05 * sjanssen checks
11:19:42 <dmhouse> sjanssen: Why not?
11:19:50 <dmhouse> Surely that's one of the big perks of purity?
11:20:33 <sjanssen> a Haskell implementation is allowed to memoize like that, but they don't in practice
11:20:34 <edwardk> sjannsen: how is Data.Rope coming?
11:21:27 <sjanssen> edwardk: well.  just a couple more things to implement
11:21:29 <largos> hm..
11:21:47 <largos> it seems like it memoized a recursive fib implementation
11:22:05 <sjanssen> really?  perhaps I'm just insane
11:22:14 <largos> well, I may have spoken to soon
11:22:18 <largos> testing with higher values
11:22:37 <dmhouse> sjanssen: I don't understand why it wouldn't memoize
11:22:53 <sjanssen> fib 100 or so should cripple it, if it isn't memoizing
11:22:57 <largos> is there an easy way to time a computation at a ghci prompt?
11:23:11 <largos> fib 50 was taking a long time
11:23:32 <monochrom> Depends on the actual coding.
11:23:58 <sjanssen> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
11:23:59 <lambdabot>  354224848179261915075
11:24:08 <dmhouse> Wow. Fast.
11:24:13 <sjanssen> largos: if it took any longer than that, there isn't any memoization
11:24:29 <largos> sjanssen: then you're right :)
11:25:02 <largos> that's to bad that it doesn't
11:25:04 <edwardk> ghc opportunitistically uses mem-thunks if it can't see a way to reuse it immediately it kinda lets it go, no?
11:25:12 <monochrom> Then the local fibs is remembered until the answer (fibs!!100) comes out.
11:25:13 <edwardk> er memo-thunks
11:25:16 <sjanssen> dmhouse: the problem with automatically memoizing functions is storing the results
11:25:19 <xerox> paolino!!!
11:25:33 <largos> ah, that's true
11:25:45 <sjanssen> how can GHC know that the overhead of storing results of functions isn't more expensive than just recomputing it?
11:25:59 <edwardk> exactly
11:25:59 <dmhouse> I see.
11:26:18 <dmhouse> Could we have a {-# MEMOIZE #-} pragma?
11:26:29 * lispy wonders if anyone that is awake now is an hsc2hs expert that can answer him some questions
11:26:45 <sjanssen> dmhouse: sure, it wouldn't break semantics
11:27:06 <edwardk> memoizing requires a funny bit of knowledge about what inputs are equal to implement well though.
11:27:15 <edwardk> suppose the pragma could work well in most cases
11:27:18 <sjanssen> true
11:27:32 <Cale> http://citeseer.ist.psu.edu/peytonjones99stretching.html
11:27:39 <Cale> there's a relevant paper
11:27:54 <Cale> and the stuff described in it is in GHC, so you can try it
11:27:57 <edwardk> heh
11:28:27 <sjanssen> dmhouse: if you want to show a pretty dynamic programming example, there's a neat DP combinator from Okasaki
11:28:37 * sjanssen checks his bookmarks
11:30:04 <sjanssen> dmhouse: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
11:30:07 <lambdabot> Title: "Gmane -- Mail To News And Back Again"
11:32:05 <monochrom> Nice wrapper.
11:32:10 <the_lord> how do I put where in a function with guards?
11:32:24 <dmhouse> The same way as normal.
11:32:30 <dmhouse> But it'll scope over all the guards.
11:33:19 <monochrom> So, after all the alternative guards.
11:33:36 <monochrom> f x | x>10 = y
11:33:42 <monochrom>     | otherwise = z
11:34:00 <monochrom>   where {y=x; z=-x}
11:35:03 <sjanssen> > let x = 2; z=-x; in z
11:35:04 <lambdabot>  Parse error
11:35:22 <dmhouse> > let x = 2; z=-x in z
11:35:22 <lambdabot>  Parse error
11:35:30 <dmhouse> > let x = 2; z = -x in z
11:35:31 <lambdabot>  -2
11:35:41 <sjanssen> monochrom: be careful with those spaces
11:35:42 <dmhouse> sjanssen: =- is one lexeme.
11:35:49 <sjanssen> yep
11:35:50 <dmhouse> Ah. You knew that.
11:36:10 <monochrom> yeah
11:38:38 <lispy> i'm on windows and i want to use odbc, which haskell packages are recommended?
11:39:11 <dmhouse> What's a good noun for someone who Haskells? I.e. Scheme -> Schemer. Lisp -> Lisper. Haskell -> Haskeller? Haskellian?
11:39:12 <sjanssen> > let x=-2 in x
11:39:12 <lambdabot>  Parse error
11:39:31 <sjanssen> Haskeller, I think
11:39:43 <monochrom> Curry.
11:40:06 <sjanssen> @djinn Haskell -> Curry
11:40:07 <lambdabot> -- f cannot be realized.
11:40:15 <lispy> dmhouse: mathematician? ;)
11:40:30 <dmhouse> @remember sjanssen @djinn Haskell -> Curry
11:40:30 <lambdabot> Done.
11:40:45 <sjanssen> @. elite djinn Haskell -> Curry
11:40:46 <lambdabot> -- f (4nNo7 bE R3A1IZed.
11:40:51 <lispy> haha
11:41:02 <lispy> @. elite keal
11:41:03 <lambdabot> I T|-|inx I kNo\/\/ wH47 (Od3 d035 8u7 (0D3 |Ooxz0rz 70 sI/\/\P1e To Ac7UallY dO I7
11:41:36 <sjanssen> ah, that is a gem
11:41:50 <sjanssen> trying to parse the leetspeak kills the joke though
11:42:20 <dmhouse> 'I Think I know what code does but looks to simple to actually do it'?
11:42:23 <monochrom> Have we implemented the inverse of elite?
11:42:30 <dmhouse> monochrom: I was just thinking that.
11:42:37 <dmhouse> It might be ambiguous.
11:43:03 <sjanssen> yeah, what if someone actually wrote looxzorz?
11:43:09 <sjanssen> @elite looxzorz
11:43:10 <lambdabot> Looxz0rz
11:43:31 <lispy> @. elite I T|-|inx I kNo\/\/ wH47 (Od3 d035 8u7 (0D3 |Ooxz0rz
11:43:32 <lambdabot> compose module failed: IRCRaised Parse error: "I"
11:43:34 <dmhouse> We should call it @the-queen's-english
11:43:37 <lispy> @ elite I T|-|inx I kNo\/\/ wH47 (Od3 d035 8u7 (0D3 |Ooxz0rz
11:43:40 <lispy> @elite I T|-|inx I kNo\/\/ wH47 (Od3 d035 8u7 (0D3 |Ooxz0rz
11:43:41 <lambdabot> i T|-|iNx I kNO\/\/ w|-|47 (od3 D035 8U7 (0d3 |o0xz0Rz
11:44:04 <lispy> almost idempotent
11:44:05 <monochrom> Haha @the-queen's-english
11:45:05 <lispy> hasql says the result sets are lazy
11:45:13 <lispy> that sounds attractive
11:46:12 <largos> lispy: that sounds dangerous.. wouldn't that require a really weird transaction?
11:47:11 <lispy> no one else will be reading/writing to my database, it's an .mdb
11:47:27 <lispy> but hasql looks a bit unsupported
11:47:31 <lispy> maybe hsql is better
11:48:04 <lispy> haskelldb sounds neat
11:48:57 <largos> these names sound erriely close to the whole eq, eql, equal thing in lisp..
11:49:06 <lisppaste2> int-e pasted "list-based memoizing edit distance" at http://paste.lisp.org/display/22481
11:50:17 <monochrom> lazy result set is not dangerous. they come from the native api of the db.
11:51:21 <largos> huh, one of these days I should take a db course, or really dig into how they work
11:52:01 * lispy too
11:52:04 <monochrom> If the db also conforms to a high level of atomicity support, and you start and end your transactions properly, there will also be consistency guarantees.
11:52:24 <sjanssen> lispy: are the lazy pattern matches really necessary?
11:54:01 <int-e> sjanssen: me?
11:54:50 <sjanssen> int-e: yes
11:55:50 <edwardk> heh that makes me want to port some cheesy lewis carroll distance code to haskell
11:55:53 <int-e> sjanssen: the first one is. it's not entirely clear to me why
11:57:40 <bolrod> where's a good tutorial to the ffi?
11:58:08 <xerox> G'day monochrom!
11:58:47 <int-e> sjanssen: err. the second one. I can't count :)
11:58:49 <dmhouse> bolrod: The wiki.
11:58:53 <lispy> bolrod: the ghc manual isn't bad if you couple it with some example code
11:59:02 <lispy> @wiki ffi
11:59:02 <lambdabot> http://www.haskell.org/haskellwiki/ffi
11:59:04 <monochrom> hello xerox
11:59:31 <int-e> sjanssen: the other two are there for symmetry.
11:59:49 <bolrod> (There is currently no text in this page)
12:00:01 <dmhouse> @oldwiki
12:00:02 <lambdabot> http://www.haskell.org/hawiki/
12:00:04 <dmhouse> @wiki
12:00:04 <lambdabot> http://www.haskell.org/haskellwiki/
12:00:09 <dmhouse> Try searching those.
12:00:38 <xerox> monochrom - If I remember correctly you are into Category Theory. Today we discussed with esap his programming language, which aims to have Category Theory _itself_ as typing system.
12:01:28 <monochrom> I am not into categories, but it is still a side interest.
12:01:36 <edwardk> xerox: well, more formally a topos of finite sets i think
12:02:19 <xerox> You are into categories no matter if you want or not.
12:02:21 * xerox smiles
12:02:28 <edwardk> heh
12:02:36 <dmhouse> xerox: Ooh, I am. Got any reading material?
12:02:57 <xerox> Right, they went over my head and arrived to some interesting result, I think.
12:03:55 <edwardk> well, not so sure how useful it will be for a type system
12:04:03 <edwardk> but its a useful tool to have
12:04:33 <xerox> Maybe once one stops wondering what it _is_ %)
12:05:17 <edwardk> and i'd like to have something that lets me talk about arbitrary categories rather than just 'all type'
12:05:20 <edwardk> er all types
12:06:40 <lispy> well shoot, cabal doesn't like haskelldb.cabal
12:06:50 <lispy> parse error on extensions
12:12:43 <eivuokko> lispy, re: ComDlg.  I'd prefer full words.
12:13:02 <petekaz> What does -threaded do?  I'm reading the docs, but I don't get it.
12:13:27 <sjanssen> petekaz: multiple threads can run simultaneously (in GHC 6.5)
12:13:37 <eivuokko> petekaz, On ghc6.4 it allows you to run blocking foreign calls while runnig haskell threads.  Without -threaded blocking calls will block all haskell execution
12:13:38 <petekaz> Let's say I am not using any calls to forkIO or forkOS.
12:13:52 <eivuokko> Then it won't matter.
12:14:47 <petekaz> eivuokko: so if one wants to avoid halting their entire program just because a foreign call is made, you run that call in a forkIO?  
12:14:59 <petekaz> Isn't forkIO a fake haskell thread, and not a real OS thread?
12:15:45 <petekaz> sjanssen: is that SMP support?  or is this something totally different?
12:15:56 <petekaz> The word thread is so overloaded :-)
12:16:17 <sjanssen> petekaz: yeah, compiling with -threaded enables the SMP stuff (in GHC 6.5)
12:16:37 <eivuokko> petekaz, In ghc6.4 there are haskell threads, and only one IO-thread that runs haskell thread at a time.  In ghc6.5 there can be many OS-threads that execute haskell.
12:16:48 <petekaz> And what just means that threads created with forkIO can run in different OS threads?
12:16:52 <lispy> eivuokko: CommonDialog?
12:17:01 <lispy> or CommonDialogs
12:17:25 <eivuokko> lispy, I am not sure.  Common Dialog Boxes is iirc what microsoft calls them.
12:17:29 <petekaz> eivuokko: you meant to say OS-thread, not IO-thread?
12:17:36 <lispy> eivuokko: okay, i'll use that as the name then
12:17:54 * lispy upgrades cabal in hopes that haskelldb will start building
12:17:59 <eivuokko> petekaz, Yeah ,sorry.
12:19:24 <lispy> seems to have done the trick
12:19:32 <petekaz> Ok, so that is why a foreign call can block the whole program because the whole program is running on a single OS-thread.  And now -threaded avoids this?  How does the RTS know when to start a new OS-thread?  Surely it doesn't start one for each call to forkIO rigt?
12:20:18 <eivuokko> petekaz, nope.  But it does for forkOS, jsut that is suspends those when haskell is ran elsewhere.
12:20:32 <dcoutts> @arr
12:20:32 <lambdabot> I'll keel haul ya fer that!
12:20:34 <eivuokko> petekaz, It runs foreign blocking calls in diffrent IO-thread, that is all.
12:20:39 <eivuokko> OS-thread..
12:20:42 <eivuokko> damn.
12:20:54 <sjanssen> petekaz: the RTS has a fixed number of OS threads that you supply as an argument at runtime
12:20:58 <int-e> petekaz: there's an RTS option,  -N<n>     Use <n> OS threads (default: 1)
12:22:22 <eivuokko> lispy, Did you find examples/docs for using hsc2hs?
12:23:05 <petekaz> Sorry ... still confused ... if I do not have any calls to forkOS, and the RTS starts up say 5 OS-threads, if I have say 3 forkIO calls, then those can all run concurrently in OS-threads?
12:23:38 <petekaz> And I have to make sure that I run any foreign calls in a separate haskell thread to take advantage of -threaded?
12:23:38 <lispy> eivuokko: no i didn't
12:23:47 <lispy> eivuokko: do you have any time to distribute your cognition?
12:23:53 <eivuokko> lispy, Did you try reading Win32-sources?
12:24:10 <lispy> eivuokko: yeah, but i can't tell if i found anything useful :)
12:24:32 <lispy> eivuokko: i get the idea that i can create a haskell record type but how to marshall it?
12:24:51 <eivuokko> lispy, by making it instance of Storable
12:25:07 <eivuokko> lispy, which is often fairly east using the hsc2hs macros
12:25:19 <lispy> eivuokko: ah, can you point at an example?
12:25:30 <eivuokko> I'm looking for clean one
12:25:37 <lispy> eivuokko: thanks!
12:26:16 <eivuokko> instance Storable SYSTEM_INFO where, in http://darcs.haskell.org/packages/Win32/System/Win32/Info.hsc
12:27:42 <lispy> eivuokko: thanks, that doesn't look to bad actually
12:28:07 <dmhouse> xerox: Ooh, I am. Got any reading material?
12:28:11 <eivuokko> It's just using #peek, #poke, and #size.
12:29:05 <dmhouse> Err
12:29:14 <dmhouse> Sorry, I didn't mean to say that again :)
12:30:16 <eivuokko> lispy, If you have VH docs installed, open help contents.  Visual Haskell help collection/The Glorious Haskel.../Other haskell utility programs/Writing Haskell interfaces to C
12:30:45 <petekaz> Regarding RTS threading: it basically seems to work like Erlang does.
12:30:54 <petekaz> right?
12:32:48 <petekaz> And it sounds as though ghc6.5 works like the latest erlang release with SMP.  Erlang RTS starts up a scheduler for each processor on the system and will transparently run all erlang threads (they call them processes though) among each processor.  Does ghc's SMP work in a similar vain?
12:33:09 <sjanssen> petekaz: yes
12:34:04 <petekaz> Ok. Is there a good page that talks about this stuff?  I could not find anything.
12:36:45 <dsacode> Hello! Can someone think of elegant one-liner for this task: Let [a_1, a_2 .. a_n] be coeffients of some polynomial like a_1 + a_2 * x + a_3 * x^2 + ... + a_n + x^(n-1), i need to differentiate it n times, so iterations will look like [a_1, a_2, a_3 ... a_n] -> [a_2, 2*a_3, 3*a_4, ..., (n-1)*a_n] -> [2*a_3, 6*a_4, 12*a_5, ..., (n-2)*(n-1)*a^n]. I have solution for this problem, but it's huge and doesn't look pretty. I bet that it can be
12:36:45 <dsacode> done beautiful with Haskell. 
12:37:20 <dmhouse> Define a differentiate function, then:
12:37:21 <dmhouse> @hoogle iterate
12:37:22 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
12:37:35 <xerox> Hehe!
12:37:36 <dsacode> dmhouse: differentiate it N times is not effective
12:37:40 <dmhouse> iterate f x = [x, f x, f (f x), f (f (f x)), ... ]
12:37:56 <dmhouse> dsacode: What do you mean, 'not effective'?
12:38:05 <xerox> dmhouse is quite correct. The `differentiate' function sounds fun, too.
12:38:29 <dsacode> dmhouse: I mean amount of reductions, GC and such other stuff :)
12:38:55 <dmhouse> Woah, you want it pretty _and_ fast?
12:39:11 <dsacode> dmhouse: in this situation it must be possible :)
12:39:11 <dmhouse> What are you going to be differentiating? Things of degree, say, 100 or more?
12:39:47 <dsacode> dmhouse: i can paste my solution, at what site i can do it?
12:39:52 <dmhouse> @where paste
12:39:53 <lambdabot> http://paste.lisp.org/new/haskell
12:41:30 <lisppaste2> dsacode pasted "differentiate polynomial" at http://paste.lisp.org/display/22484
12:41:55 <dsacode> dmhouse: check it please
12:42:10 <dmhouse> What do each of the functions do?
12:43:22 <dsacode> dmhouse: it's like general formula for n-th derivative, for last monom we will have (n-1)*(n-2)*..*a_n..
12:43:46 <dsacode> dmhouse: you can check my question above, there's sample iterations..
12:44:18 <dsacode> dmhouse: so this solution looks ugly, I believe that there's more elegant way to write it
12:45:22 <dmhouse> mapWithIndex f x = mapWithIndex' 0 f x where mapWithIndex' _ _ [] = []; mapWithIndex' n f (x:xs) = f x n : mapWithIndex' (n + 1) f xs
12:45:34 <dmhouse> (A bit quicker than zipping and uncurrying.)
12:46:06 <dmhouse> differentiate = mapWithIndex (*) . tail
12:46:09 <dsacode> dmhouse: nice! didn't know about that function
12:46:15 <dmhouse> dsacode: I just wrote it :)
12:46:19 <dmhouse> It's not in the standard libs.
12:46:27 <edwardk> heh
12:46:45 <dmhouse> differentiateN n = (!! n) . iterate differentiate
12:47:06 <dmhouse> Now, do I still have to plough through your code?
12:47:38 <dsacode> /usr/local/lib/hugs/libraries % grep -ri mapwithindex *        
12:47:38 <dsacode> /usr/local/lib/hugs/libraries % 
12:47:38 <dsacode>  
12:47:39 <dsacode> :(
12:47:58 <edwardk> dsacode: dmhouse gave the definition for it above, when he wrote it =)
12:48:07 <dsacode> ahh :)
12:49:17 <dmhouse> @tell kowey Type basics is nearing completion, go read it through!
12:49:17 <lambdabot> Consider it noted.
12:57:00 <sjanssen> > let diff n = map (\(i, a) -> a / fromIntegral (product [n .. i])) . drop n . zip [0..] in diff 1 [1, 1, 1]
12:57:01 <lambdabot>  [1.0,0.5]
12:57:36 <lispy> hmm...the haskelldb example on the wiki seems to be older than the haskelldb code
12:57:42 <sjanssen> > let diff n = map (\(i, a) -> a * product [n .. i]) . drop n . zip [0..] in diff 1 [1, 1, 1]
12:57:43 <lambdabot>  [1,2]
12:58:30 <sjanssen> dsacode: how about that?
12:58:38 <dsacode> sjanssen: nice :)
13:00:00 <dmhouse> What was wrong with mine?
13:00:28 <dsacode> dmhouse: yours is nice too :)
13:00:33 <dmhouse> Hehe.
13:00:37 <sjanssen> actually, I think mine is wrong
13:00:39 <lispy> @hoogle TInfo -> Table
13:00:40 <lambdabot> No matches, try a more general search
13:01:46 <sjanssen> yeah, mine is wrong
13:01:59 <dsacode> Main> diff 1 [2,2,0,3]
13:01:59 <dsacode> [2,0,18] :: [Int]
13:01:59 <dsacode>  
13:02:00 <dsacode> yes :)
13:02:21 <dsacode> it must be [2,0,9]
13:04:58 <dsacode> sjanssen: but it works correctly in many cases :))
13:05:06 <sjanssen> > let diff n = map (\(i, a) -> a * fromIntegral (product [i - n + 1.. i])) . drop n . zip [0..] in diff 1 [2, 2, 0, 3]
13:05:07 <lambdabot>  [2,0,9]
13:05:56 <dmhouse> > let diff = iterate (map (uncurry (*)) . zip [1..] . tail) in diff 1 [2,2,0,3]
13:05:56 <lambdabot>    The function `diff' is applied to two arguments,
13:05:57 <lambdabot>   but its type `[a] -...
13:06:17 <dmhouse> > let diff n = (!! n) . iterate (map (uncurry (*)) . zip [1..] . tail) in diff 1 [2,2,0,3]
13:06:18 <lambdabot>  [2,0,9]
13:08:40 <sjanssen> @pl \(i, a) -> a * fromIntegral (product $ enumFromTo (i - n) i)
13:08:41 <lambdabot> uncurry ((*) . fromIntegral . product . (enumFromTo =<< subtract n))
13:09:58 <sjanssen> @pl \i a -> a * fromIntegral (product $ enumFromTo (i - n) i)
13:09:59 <lambdabot> (*) . fromIntegral . product . (enumFromTo =<< subtract n)
13:10:25 <dmhouse> > let mapWithIndex f x = mwi 0 f x where mwi _ _ [] = []; mwi n f (x:xs) = f x n : mwi (n+1) f x; diff n = (!! n) . iterate (mapWithIndex (*) . tail) in diff 1 [2,2,0,3]
13:10:26 <lambdabot>  Not in scope: `diff'
13:10:40 <dmhouse> > let mapWithIndex f x = mwi 0 f x where { mwi _ _ [] = []; mwi n f (x:xs) = f x n : mwi (n+1) f x }; diff n = (!! n) . iterate (mapWithIndex (*) . tail) in diff 1 [2,2,0,3]
13:10:41 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
13:10:41 <lambdabot>    Expected...
13:10:49 <dmhouse> Oops.
13:10:54 <dmhouse> > let mapWithIndex f x = mwi 0 f x where { mwi _ _ [] = []; mwi n f (x:xs) = f x n : mwi (n+1) f xs }; diff n = (!! n) . iterate (mapWithIndex (*) . tail) in diff 1 [2,2,0,3]
13:10:55 <lambdabot>  [0,0,6]
13:11:01 <dmhouse> Ta-da! :)
13:12:06 <bolrod> O_O
13:12:06 <dmhouse> Weird.
13:12:32 <dmhouse> Oh, wait, I know.
13:12:38 <dmhouse> > let mapWithIndex f x = mwi 0 f x where { mwi _ _ [] = []; mwi n f (x:xs) = f x n : mwi (n+1) f xs }; diff n = (!! n) . iterate (tail . mapWithIndex (*)) in diff 1 [2,2,0,3]
13:12:39 <lambdabot>  [2,0,9]
13:13:02 <dmhouse> There we go. And we get the bonus of a nice list function defined too. :)
13:14:26 <sjanssen> @type \f xs -> zipWith f xs [0..]
13:14:27 <lambdabot> forall a b c. (Num b, Enum b) => (a -> b -> c) -> [a] -> [c]
13:14:45 <dmhouse> Ah, that's nicer.
13:15:00 <dmhouse> Only one traversal.
13:15:10 <xerox> You could even thing about giving it a name, once you stick b = Int, maybe.
13:15:11 <sjanssen> @pl mapWithIndex f xs = zipWith f xs (enumFrom 0)
13:15:11 <lambdabot> mapWithIndex = flip flip [0..] . zipWith
13:15:30 <dmhouse> > let diff n = (!! n) . iterate (zipWith (*) [1..] . tail) in diff 1 [2,2,0,3]
13:15:31 <lambdabot>  [2,0,9]
13:15:35 <xerox> (-:
13:15:53 <dmhouse> > let diff n = (!! n) . iterate (zipWith (*) [1..] . tail) in diff 2 [2,2,0,3]
13:15:54 <lambdabot>  [0,18]
13:16:45 <xerox> What are you ding?
13:16:56 <dmhouse> Differentiating. It's a list of coefficients.
13:17:10 <xerox> That's nice indeed.
13:17:22 <dmhouse> diff = zipWith (*) [1..] . tail. A very nice piece of code.
13:17:26 <xerox> Is tail the correct one?
13:17:50 <dmhouse> Sure. The first element is the x^0 coefficient, which always gets removed.
13:17:51 <xerox> Hmm, yes, a_1 + .. + a_n x^n
13:17:57 <sjanssen> @type \n -> (!! n) . iterate (zipWith (*) [1..] . tail)
13:17:59 <lambdabot> forall a. (Num a, Enum a) => Int -> [a] -> [a]
13:18:01 <SamB> @pl diff n = (!! n) . iterate (zipWith (*) [1..] . tail)
13:18:01 <lambdabot> diff = (. iterate (zipWith (*) [1..] . tail)) . flip (!!)
13:18:12 <xerox> Exponents are correct?
13:18:53 <dmhouse> What do you mean?
13:19:27 <xerox> Oh well, nothing. It's very nice.
13:19:44 <xerox> Write a dual one for integration now (:
13:20:05 <dsacode> > let diff n = (!! n) . iterate (zipWith (*) [1..] . tail) in diff 7 [0..25]
13:20:06 <lambdabot>  [35280,322560,1632960,6048000,18295200,47900160,112432320,242161920,48648600...
13:20:19 <bolrod> > let diff xs = zipWith (*) [1..] (tail xs)  in diff [2,2,0,3] 
13:20:20 <lambdabot>  [2,0,9]
13:20:21 <bolrod> ?
13:20:44 <dmhouse> bolrod: Yes, or the eta-reduced form: diff = zipWith (*) [1..] . tail
13:21:02 <bolrod> ^.0
13:21:08 <dmhouse> bolrod: What?
13:21:14 <bolrod> eta-reduced? :)
13:21:17 <xerox> What animal is that bolrod ? %)
13:21:31 <xerox> bolrod: (f . g) x = f (g x)
13:21:51 <dmhouse> bolrod: Yeah. For example, diff xs = zipWith (*) [1..] (tail xs)  ->   diff = zipWith (*) [1..] . tail
13:21:58 <xerox> Substitute your `zipWith (*) [1..]' for `f' and `tail' for `b'.
13:22:01 <bolrod> it's not an animal
13:22:05 <dmhouse> In general, (\x. t x)  ->   t
13:22:16 <xerox> That's not the case dmhouse.
13:22:28 <xerox> That is beta-reduction.
13:22:36 <dmhouse> No, that's definitely eta-reduction.
13:22:46 <xerox> Really?
13:23:05 <dmhouse> Beta-reduction is (\x. t1) t2  ->  [x |-> t2](t1)
13:23:46 <xerox> You are right on eta-reduction.
13:24:08 <xerox> But then it doesn't seem to me that it is what it has been used.
13:24:24 * bolrod is hungry
13:24:25 <dmhouse> Sorry?
13:24:34 <xerox> We've used f . g = \x -> f (g x)
13:24:48 <dmhouse> Oh, I see.
13:24:57 <xerox> In \x -> f x = f, f remains equal.
13:25:26 <xerox>  @pointless code is interesting.
13:25:45 <xerox> (That sounds like a quotable... hah)
13:25:56 <dmhouse_> xerox: Still there?
13:26:02 <xerox> Yup.
13:26:06 <dmhouse_> I got d/c'd.
13:26:11 <dmhouse_> Anyway.
13:26:22 <xerox> 21:24 <xerox> In \x -> f x = f, f remains equal.21:25 <xerox>  @pointless code is interesting.
13:26:24 <dmhouse_> diff xs = zipWith (*) [1..] (tail xs)
13:26:26 <dmhouse_> Or,
13:26:36 <dmhouse_> diff xs = (zipWith (*) [1..] . tail) xs
13:26:45 <xerox> That is one transformation!
13:26:51 <dmhouse_> Then eta-reduce.
13:26:52 <xerox> Then it happens an eta-reduction.
13:27:11 <xerox> You are getting very formal :-)
13:27:35 <dmhouse_> Right. You just need to notice that the more natural zipWith (*) [1..] (tail xs) is equivalent to the one defined with (.) :)
13:27:50 <dmhouse_> Hehe, I'm reading a type-theory book, so these things are hot on my mind :)
13:28:03 <xerox> Which one are you reading?
13:28:09 <dmhouse_> Types and Programming Languages.
13:28:30 <edwardk> good book
13:28:40 <dmhouse_> Yes, I'm enjoying it so far.
13:28:56 <dmhouse_> It's like, 'Wow, I can prove stuff! Watch me go!' :)
13:29:04 <edwardk> heh
13:29:09 <bolrod> :]
13:29:11 * dmhouse_ is, of course, converting all the OCaml implementations to Haskell ones.
13:29:19 <edwardk> heh
13:29:22 <bolrod> heh
13:29:23 <xerox> Is it available online?
13:29:29 <bolrod> is it free?
13:29:34 <dmhouse_> The book? No. Neither of those.
13:29:38 <edwardk> xerox: not afaik. you need to buy it
13:29:38 <dmhouse_> The implementations are.
13:29:40 <edwardk> but its worth it
13:29:55 <xerox> Hmmm. What was the one available online?
13:29:56 <edwardk> types and programming languages by benjamin pierce
13:30:05 <dmhouse_> xerox: Or, as you're at a university, go to the library :)
13:30:07 <edwardk> is the good one, dunno about onine
13:30:10 <edwardk> =)
13:31:19 <dmhouse_> All right, g'night all.
13:31:54 <xerox> This one.
13:31:55 <xerox> Simon Thompson: Type Theory and Functional Programming
13:36:23 <BetaTEST> oh, ocaml stuff, that's for me :)
13:37:49 <dsacode> > let diff n = (!! n) . iterate (zipWith (*) [1..] . tail) in diff 999
13:37:49 <dsacode> 	  [0..1000]
13:37:50 <lambdabot>  Add a type signature
13:38:04 <dsacode> let diff n = (!! n) . iterate (zipWith (*) [1..] . tail) in diff 999 [0.1000]
13:40:53 <dsacode> > let diff n = (!! n) . iterate (zipWith (*) [1..] . tail) in diff 999 [0..1000]
13:40:54 <lambdabot>  [401984872817016679770158731489080981733655489346503917911256110519508573886...
13:44:31 <Buzzons> can some one help me with this code please, it doesnt seem to work..
13:44:32 <Buzzons> moo :: [(a,b)]->[(b,a)]
13:44:32 <Buzzons> moo [(a,b),xs] = (b,a): moo [xs]
13:44:32 <Buzzons> moo [] = error "mooooo"
13:44:48 <Buzzons> it should reverse the list but it just fails with a horrid non sensicle error
13:44:53 <monochrom> moo ((a,b):xs) = (b,a) : moo xs
13:45:01 <monochrom> Use that for your second case.
13:45:12 * Buzzons goes to try
13:45:13 <Cale> first case
13:45:38 <Cale> however, you probably want moo [] = []
13:45:43 <int-e> @type uncurry (flip (,))
13:45:44 <lambdabot> forall a b. (a, b) -> (b, a)
13:45:50 <Buzzons> thank you :)
13:46:10 <xerox> I like swap = (snd &&& fst).
13:46:53 <xerox> (Then moo = map swap.)
13:47:05 <Buzzons> mm intreaging
13:47:11 <int-e> will swap be in haskell'?
13:47:17 <xerox> Hope so.
13:47:20 <monochrom> But don't say "it reverses the list".
13:47:20 <monochrom> > reverse [1,2,3]
13:47:21 <lambdabot>  [3,2,1]
13:47:25 <Buzzons> er no... i had to write it.
13:48:24 <Cale> Buzzons: he was referring to Haskell', which is the next version of the Haskell standar
13:48:25 <Cale> d
13:48:34 <Buzzons> oh i see thanks :)
13:51:02 <syntaxfree> is it worth learning logic programming?
13:51:54 <wilx> Hmmm, I don't think so.
13:52:14 <wilx> It depends on what you expect from it.
13:52:27 <Cale> I'd say it's worth learning to some extent
13:52:41 <largos> constraint logic programming is nice to know about, and it could be useful in day-to-day use if there were a good interface to one
13:53:06 <syntaxfree> I don't know precisely what I expect from it. 
13:53:25 <syntaxfree> I've been thinking a lot about how to best implement heuristics for walking game trees.
13:53:28 <largos> expect cool behavior and long runtime :)
13:54:22 <syntaxfree> is logic programming hard to learn?
13:54:38 <syntaxfree> say, if 90% of my programming background is basically functional.
13:55:00 <xerox> So is it true that anything that can be computed can be computed in lambda calculus?
13:55:26 <araujo> That's what Church said :-P
13:55:29 <sieni> syntaxfree: everything depends on your attitude and your personality
13:55:36 <syntaxfree> I haven't seen the proof,  but I've heard so.
13:55:43 <largos> xerox: yep, lambda calculus is turing-complete, if that helps
13:56:21 <sieni> largos: that's a different question
13:56:58 <largos> sieni: well, lambda calculus and turing macahines are equivelanat w.r.t. computational power, aren't they?
13:57:13 <largos> s/power/expressiveness/
13:57:48 <sieni> largos: yes, but that wasn't the question. (which was incidentally, that: "<xerox> So is it true that anything that can be computed can be computed 
13:57:56 <sieni>               in lambda calculus"
13:58:32 <largos> sieni: since we're being pedantic and quoting... "<largos> ... if that helps."
13:58:39 <xerox> How do you quantify computational power?
13:58:49 <sieni> largos: http://en.wikipedia.org/wiki/Church-Turing_thesis
13:59:03 <monochrom> By considering computational complexity.
14:00:02 <xerox> Do you check wethere you can build computations featuring an immense computational complexity in the system you are considering?
14:00:32 <sieni> largos: there are several independently given notions of computability: Church's lambda calculus, Gödel's recursive functions and Turing's machines and it's known that they yield the same class of functions. The question is: why?
14:00:36 <monochrom> I check the complexity of a problem in the system I am considering.
14:00:41 <largos> sieni: the point I was trying to make is that if some one is famaliar with turing machines, but not lambda calculus, the knowledge about one can carry over to the other.
14:01:11 <xerox> monochrom - In this case we are comparing two systems, lambda calculus and turing machines.
14:02:05 <monochrom> Yes. Given a problem and a system, find out how much time the fastest algorithm in the system takes to solve the problem.
14:02:07 <xerox> sieni - What are Goedel's recursive functions?
14:02:11 <Taral> GHC 6.4.2: I've imported Data.Array.ST, but I'm still getting No instance for (MArray (STUArray s) Bool (ST s))
14:02:34 <xerox> monochrom - So it does not relly answer my initial question.
14:03:19 <monochrom> Note that "takes forever" is a possible answer.  Some people call it "uncomputable".
14:04:31 <xerox> How does this help? It beats me.
14:04:44 <monochrom> It quantifies the question.
14:05:07 <sieni> xerox: http://en.wikipedia.org/wiki/Recursive_function
14:05:39 <sieni> xerox: it's the notion of computability that we used in our mathematical logic courses
14:05:54 <sieni> It's handy for a mathematician or a logician.
14:05:54 <monochrom> I was answering "How do you quantify computational power?"
14:05:55 * xerox is reading too ma ny things at the same time
14:06:12 <xerox> monochrom - Oh yes, sure. I was referring to the questione before.
14:06:20 <xerox> ...question, even.
14:06:36 <monochrom> I think that question will take forever to answer. :)
14:07:50 <xerox> Hah.
14:08:19 <xerox> Do you ever find yourself reading past cnoversation on #haskell through the logs? There surely are very interesting ones.
14:08:19 <Taral> :(
14:08:25 <xerox> ...conversations, even.
14:08:27 <syntaxfree> "Constraint logic programming has been applied to a number of fields, such as civil engineering, mechanical engineering, digital circuit verification, automated timetabling, aircraft traffic control, finance, and others."
14:08:50 <monochrom> When I type, I tend to miss things.
14:09:06 <monochrom> Err.  When I type, I tend to miss things other people say.
14:09:10 <sieni> xerox: recursive functions are closely related to primitive recursive functions of which the former can be thought of as an extension. The Ackermann's function is the classical example of a recursive function that's no primitive recursive.
14:09:32 <syntaxfree> I wonder what's the effect of learning how to cope with chaotic IRC channels on IQ test measuring.
14:09:47 <syntaxfree> I spent my teenage years on a dalnet channel that used to have 5 different conversations at the same time.
14:10:03 <sieni> syntaxfree: who gives a flying f**k?
14:10:04 <syntaxfree> We would even participate in more than one.
14:10:19 <syntaxfree> sieni: well, it either helps your brain develop or it rots it up.
14:10:36 <sieni> syntaxfree: or it doesn't matter
14:10:37 <syntaxfree> It's nice to know what kind of things help your brain function.
14:10:45 <monochrom> It helps you take several IQ tests simultaneously. :)
14:10:55 <syntaxfree> sieni: yeah. In any case, it's something to be tested.
14:10:56 <xerox> sieni - I think I have heard of it before, thanks much.
14:11:02 * xerox laughs in monochrom's general direction
14:11:11 <xerox> (In a friendly way.)
14:11:13 <sieni> syntaxfree: why? probably those things you are interested in help your brain function
14:11:18 <syntaxfree> It's probably more societally relevant than most theoretical CS.
14:11:32 <sieni> xerox: :-)
14:11:42 <syntaxfree> sieni: not if the things you are interested in are smoking pot and bashing your head into metal plates.
14:13:32 <syntaxfree> http://en.wikipedia.org/wiki/McCarthy_91_function
14:13:35 <syntaxfree> that is cool.
14:14:00 <sieni> syntaxfree: Depends. I can only say that after I've got my Ph.D. I've been mostly doing what I want (and got a decent job in that respect) and stopped caring about anything. Then I've actually been productive at work (and learned quite a bit of juggling)
14:14:30 <syntaxfree> sieni: what line of work are you in?
14:15:12 <xerox> ?seen esap
14:15:12 <lambdabot> I saw esap leaving #haskell-overflow and #haskell 4 hours, 26 minutes and 56 seconds ago, and .
14:15:29 <syntaxfree> ?seen lambdabot
14:15:30 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #haskell.es, #haskell.se, #haskell.it, #perl6, #darcs, #haskell_ru, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah, #haskell and #Haskell.se
14:15:32 <sieni> syntaxfree: unix/windows network programming in c
14:15:50 <syntaxfree> I admire you for actually finding enjoyment in that.
14:15:54 <monochrom> Productivity is in the eyes of the beholder.
14:16:33 <sieni> well the windows part is a bit distressing i have to admit
14:16:40 <monochrom> haha
14:16:48 <Taral> Did anyone see my question?
14:17:35 <monochrom> I'll reconsider it, Taral.
14:17:45 <xerox> sieni - What do you work on? :)
14:17:51 <xerox> Woops.
14:17:59 <sieni> implementing posix condition variables correctly using windows primitives is an interesting exercise given that all the documentation you find with googling is wrong
14:18:46 <xerox> What makes you start such a jounrey? (:
14:18:55 <monochrom> I think you need to be more specific.  Paste something in a pastebin.  Limit it to 10 lines or fewer.
14:19:05 <syntaxfree> what are posix condition variables?
14:19:17 <monochrom> Oh, and those 10 lines have to reproduce your problem if I put them in a file and compile.
14:19:24 <Taral> aha!
14:19:26 <sieni> xerox: what's the alternative, since I don't want to move outside of finland anymore
14:19:30 <Taral> I'm using ST.Lazy
14:19:38 <monochrom> Ah.
14:19:40 <syntaxfree> @paste
14:19:40 <lambdabot> http://paste.lisp.org/new/haskell
14:19:59 <sieni> 18 months in the states has been an experience, mostly because there are too few finns to speak finnish with
14:20:11 <syntaxfree> sieni: you could try and find mr. Torvalds.
14:20:26 <syntaxfree> You moved to the states to get that job?
14:20:53 <monochrom> Oh! Condition variables sound like synchronization in concurrency.
14:21:32 <sieni> syntaxfree: no, first 9 months were as a student and the other 9 months were as a post-doc
14:21:46 <syntaxfree> can't you, like, work at Nokia as a java programmer?
14:22:07 <syntaxfree> I know someone with some kind of technical degree that was lesser than a BS that did neural nets stuff for Nokia.
14:22:15 <syntaxfree> in Finland.
14:22:21 <sieni> syntaxfree: why would I want to, since I can do real programming in Finland as well
14:22:27 <monochrom> haha
14:22:31 <neologism> http://perforce.freebsd.org/branchView.cgi?BRANCH=rdivacky%5flinuxolator
14:22:32 <neologism> sorry
14:22:32 <lambdabot> Title: "P4DB: Branch rdivacky_linuxolator"
14:22:37 <petekaz> sjanssen: are you still there?  I'm reading a paper "Haskell on a shared-memory multiprocessor" and they describe how they manage to evaluate thunks in parallel without the use of locking, and erring on the side that a thunk will be evaluated twice, which is not a big deal.  However, there is one big exception they mention, unsafePerformIO, and they hint at a comibinator called "justOnce", but they said it wasn not implemented at the
14:22:37 <petekaz> time (Aug 2005).  Do you know how they handle this now?
14:23:19 <syntaxfree> um, how is network programming in C more "real" than doing handwriting recognition and games in Java?
14:23:25 <sjanssen> petekaz: I don't know what they do (if anything)
14:23:38 <sjanssen> petekaz: but I do remember reading that and wondering
14:23:57 <petekaz> Because I imagine a lot of code will break with smp.
14:24:22 <monochrom> "real" is in the eyes of the beholder as well.  You see, the problem with bragging about "real" or "the real world" is that everyone has a different real world.
14:24:46 <dcoutts> dons, did you know about TextRegexLazy ?
14:24:51 <dcoutts> @where TextRegexLazy
14:24:51 <lambdabot> I know nothing about textregexlazy.
14:25:00 <dcoutts> @where+ TextRegexLazy http://sourceforge.net/projects/lazy-regex
14:25:00 <lambdabot> Done.
14:25:18 <dcoutts> see the email to the libs list just now
14:25:29 <sjanssen> petekaz: just code that expects unsafePerformIO to only execute once (which can be tricky regardless of smp)
14:26:31 <petekaz> sjanssen: right.
14:26:34 <sjanssen> dcoutts: think the library will work with lazy bytestrings too?
14:26:47 <petekaz> sjanssen: maybe I'll post a question to the user list.
14:26:48 <dsacode> Is there merge sort available in haskell standard library?
14:27:00 <sjanssen> @hoogle sort
14:27:00 <lambdabot> List.sort :: Ord a => [a] -> [a]
14:27:01 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
14:27:01 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
14:27:09 <dcoutts> sjanssen, probably not yet, the chunked representation is tricky for regex libs
14:27:33 <sjanssen> dsacode: sort in Data.List is a merge sort
14:27:37 <dcoutts> sjanssen, if it's in haskell then it can be adapted, if it's a C lib binding it may be impossible
14:27:59 <dcoutts> sjanssen, I've not looked at the lib before so I don't know how it's implemented
14:28:01 * dcoutts looks
14:28:29 <xerox> System.Win32 ?!
14:28:57 <dsacode> sjanssen: so may be there's some function which input is list of sorted lists and output is sorted list? :)
14:30:17 <norpan> dsacode: sort . concat?
14:31:26 <norpan> of course it's not optimal, but sort on a partially sorted list is fast
14:31:30 <norpan> as it uses merge sort
14:31:34 <lisppaste2> Itkovian pasted "Once more" at http://paste.lisp.org/display/22496
14:32:28 <sjanssen> dsacode: http://darcs.haskell.org/packages/base/Data/List.hs -- look for mergesort'
14:35:53 <bolrod> ^.0.. isn't mergesort Theta(nlogn) ?
14:36:15 <norpan> O(n log n) yes
14:36:27 <sieni> Theta?
14:36:36 <bolrod> O(N log n)
14:36:44 <bolrod> And   Omega(n log n)
14:36:51 <bolrod> so worst case is n log n as well
14:36:55 <bolrod> erh
14:36:56 <bolrod> best case
14:37:11 <norpan> yes
14:37:13 <sjanssen> theta has nothing to do with best/worst case
14:37:21 <sieni> I though they are actual lowercase and uppercase O: http://en.wikipedia.org/wiki/Landau_notation
14:37:36 <bolrod> what then?
14:37:38 <norpan> there are all sorts of asymtotic bounds
14:37:54 <sjanssen> theta means bounded by a constant both below and above
14:38:35 <bolrod> isn't that like saying..   it has a worst case of X and a best case of X ?
14:38:41 <monochrom> Why do dysfunctional students think that O is worst case Omega is best case etc.?
14:38:42 <bolrod> for sufficiently large n
14:39:01 <sjanssen> f(n) in Theta(g(n)) means the limit of f(x)/g(x) as x approaches infinity is equal to a constant
14:39:15 <dsacode> Theta implies Omega and o
14:39:22 <norpan> to say they have *nothing* to do with best/worst case is stretching it
14:39:47 <bolrod> ;o
14:39:49 <Cale> Well, those are orthogonal concerns though
14:39:53 <monochrom> O(f) is a class of functions, period.  Whether you apply it to worst case or best case or average case or no case is orthogonal.
14:40:35 <bolrod> oh.. yes  ofcourse something that is O(n) is also O(n^2)  ..  bleagh
14:40:39 <norpan> i agree that many use the notation without knowing the meaning
14:40:51 <Cale> You're not usually that concerned with getting upper bounds on your best case though.
14:40:56 <norpan> informally, you'd say O(n) when you mean Theta(n)
14:41:04 <Cale> Or lower bounds on your worst case.
14:41:15 <sjanssen> norpan: and you wouldn't even be wrong, you'd just be less specific
14:41:22 <norpan> exactly
14:41:42 <norpan> anyway
14:41:45 <norpan> it's bed time
14:41:57 <bolrod> anyway.. what I was trying to say..   
14:41:59 <monochrom> Oh, but I think the whole question of "P = NP?" is a question about the lower bound on worst cases!
14:42:10 <bolrod> with mergesort it doesn't matter if your list is 'almost sorted' 
14:42:15 <norpan> P = NP is something else
14:42:17 <bolrod> for the time that mergesort runs in.. right?
14:42:28 <norpan> bolrod: of course it matters
14:42:41 <alec> > P == NP
14:42:42 <lambdabot>  Not in scope: data constructor `NP'
14:42:43 <monochrom> To prove "P != NP" is to prove a lower bound on worst cases.
14:43:01 <alec> > P != NP
14:43:01 <lambdabot>  Not in scope: data constructor `NP'
14:43:13 <alec> heh
14:43:16 <Cale> not to mention != :)
14:43:18 <bolrod> and != doesn't exist
14:43:47 <neologism> > "P" != "NP"
14:43:47 <lambdabot>  Not in scope: `!='
14:43:53 <largos> P /= NP :: Maybe Bool
14:43:55 <sjanssen> bolrod: the complexity is always the same, but mergesort tends to be quicker in practice with partially sorted lists
14:43:56 <norpan> bolrod: when merging two parts and the second part is all bigger than the first part, you need only traverse the first part
14:43:59 <Cale> > "P" /= "NP"
14:44:00 <lambdabot>  True
14:44:48 <norpan> confusing actual running time with asymptotic measures is another thing
14:44:55 <xerox> > let  n p = p  in  (\p -> p == n p) ()
14:44:56 <lambdabot>  True
14:45:21 <norpan> i'd rather have an O(n^2) algorithm that solves my problem in 1 second than an O(n) that takes an hour
14:45:25 <bolrod> sjanssen,norpan: aha
14:45:27 <bolrod> ofcourse :)
14:45:56 <bolrod> norpan: depends
14:46:02 <bolrod> who you are ;)
14:46:14 <norpan> depends if you have time or not
14:46:15 <bolrod> if you are 'Microsoft'  or something
14:46:19 <bolrod> and have a deal with Intel
14:49:05 <norpan> also, with modern computers, cache locality is just as important for your algorithm
14:49:23 <pejo> They don't need to select bad algorithms to use your CPU, just put in more blinking things on your screen bolrod. 
14:50:09 <bolrod> ohyeah
14:50:15 <bolrod> "Do you want to continue"
14:50:25 <bolrod> "Do you want to continue with continueing"
15:00:07 <bolrod> and ofcourse they have a deal with Nvidia now.. with their Aero!
15:00:29 <syntaxfree> Aero looks nifty, in a fluxbox kind of way.
15:02:06 <bolrod> http://www.vblog.ch/articles/2006/06/26/the-blond-myth    
15:02:06 <lambdabot> Title: "The blond Myth"
15:02:23 <syntaxfree> Heh. I didn't know Aero was an acronym.
15:02:33 <syntaxfree> I thought it was just a cheesy answer to Aqua.
15:07:14 <palomer> good news, everyone
15:07:18 <palomer> I'm about to do something!
15:07:35 <edwardk> be still my beating heart. =)
15:08:18 <palomer> in haskell!
15:09:30 <edwardk> so what pray tell is this epic task that you are about to undertake? =)
15:09:48 <monochrom> That is a great start to two months of nightmare, at the end of which you will once more proclaim "Haskell is such a pain".
15:10:09 <edwardk> is this how his random cursing of vim began?
15:10:38 <edwardk> or did palomer spring into being on this channel with his editor prejudices fully intact? ;)
15:11:06 <vininim> mmm.. talking about editor... haskell editor?
15:11:32 <edwardk> vin: as in whats out there to edit haskell or whats out there written in haskell to edit?
15:11:54 <vininim> written in haskell, I have vim and emacs haskell modes. :)
15:12:00 <edwardk> heh
15:12:56 * ihope ponders
15:13:30 <ihope> So there's no Curry for Windows that comes with typeclasses, or what?
15:14:58 <palomer> Haskell _is_ a pain
15:15:06 <palomer> this point is of low mootness
15:15:39 <vininim> I don't think so.. but hey, I don't even know monads yet. :)
15:15:40 <palomer> it's a lesser pain than most other programming languages I know, for this particular task
15:16:12 <vininim> at least I did correct mergesort in 2 hours, while I take more than that in any other language.
15:16:52 <vininim> don't try to scare me away, I'll resist! :)
15:18:22 <largos> is anyone famaliar with any research into the clustering of strings base on syntactic similarity?
15:19:43 <palomer> whew, just looking at this grammar makes my head spin
15:19:47 <vininim> like the wordnet prolog thing?
15:20:03 <largos> vininim: I'm not sure what that is
15:20:38 <vininim> http://wordnet.princeton.edu/perl/webwn
15:20:39 <lambdabot> Title: "WordNet Search - 2.1"
15:21:16 <largos> vininim: thanks, looking that over 
15:23:09 <largos> vininim: that seems to be more centered on semantics than syntax
15:24:40 <vininim> indeed, but I believe clustering in both cases can be reduced to metric clustering.
15:26:57 <largos> vininim: it's definitely cool, and relevant :) a little heavy-weight for what I'm trying to do, but I'll keep it around if nothing else turns up.
15:41:39 <lispy> @index FilePath
15:41:39 <lambdabot> System.IO, Prelude, Distribution.Compat.FilePath
15:41:54 <lispy> @doc System.IO
15:41:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
15:42:10 <lispy> oh,  it's just a string
15:52:56 * shapr hugs bringert 
15:53:11 <shapr> bringert: Hey, you remember that list of features I mentioned earlier?
15:53:11 * bringert gets lots of hugs these days
15:53:14 * shapr grins
15:53:15 <bringert> wassup?
15:53:31 <bringert> shapr: the one you sent in an e-mail?
15:53:36 <shapr> Er, maybe?
15:54:35 <bringert> did I implement all of them or something?
15:55:05 <shapr> Actually, I think you've done about half of them...
15:55:27 <shapr> But in any case, I persuaded a friend of mine to let me implement an educational website for her using Hope...
15:55:49 <bringert> sweet!
15:55:55 <bringert> are you getting paid?
15:56:10 <shapr> Not yet, but I will when she gets money.
15:56:21 <shapr> This is part of why I get to implement it in my choice of platforms :-)
15:56:49 <bringert> so I guess you will have lots of feature requests coming up
15:56:55 <shapr> Well, yeah :-)
15:57:20 <lispy> @type catch
15:57:21 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:57:26 <shapr> But I figured I'd check with you first to see if you're actually interested in writing more features for Hope or if your vacation is about to end and you're going to hack on C code for months now or something.
15:57:45 <lispy> @hoogle catchError
15:57:45 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
15:58:00 <lispy> how do you catch things like:
15:58:04 <lispy> > [] !! 0
15:58:05 <lambdabot>  Add a type signature
15:58:13 <lispy> > [1] !! 1
15:58:14 <lambdabot>  Exception: Prelude.(!!): index too large
15:58:14 <bringert> shapr: I plan to do a bit more work on Hope, but I will probably be offline at least parts of August
15:58:40 <lispy> i put in a catch but the exception is not caught
15:58:47 <bringert> shapr: I'd like to get it into good enough shape to allow others to work on it
15:58:53 <shapr> bringert: Ok, that sounds good. She wants the website up in the next two months.
15:59:04 <shapr> bringert: Ah, that sounds perfect.
15:59:24 <shapr> My friend wrote SNOBOL, Icon, etc years ago and she wants to get into Haskell if I'm going to use it for her website.
16:00:03 <lispy> of course in this case i'll just check for a list that is too short, but i'd like to wrap my program in a very general exception handler at the top so i can report things graphically instead of to the console
16:00:29 <bringert> shapr: I'd appreciate any feature requests
16:00:49 <shapr> bringert: Anyway, thanks for all the great code so far :-)
16:01:34 <shapr> bringert: Oh, I have plenty. She wants forums (use the comments code?), and a bunch of other stuff that doesn't come to mind at the moment.
16:01:52 <bringert> shapr: I of course can't promise anything, seeing how I don't get paid for this :-) if there's something I'm being slow about, fell free to implement it. checking with me first might be agood idea, maybe I have thought about how to do it already, or have already started
16:02:08 <bringert> shapr: I was thinking that the comments stuff should be enough for forums
16:02:24 <bringert> it needs range limiting, but so does everything
16:02:26 <shapr> bringert: Right, no promises or obligations, and I'm likely to ask you for your advice before I write plugins.
16:02:56 <bringert> I'm working on image rotation at the moment
16:03:09 <bringert> writing C code to extend GD
16:03:11 <bringert> it doesn
16:03:22 <bringert> t have right angle rotation support
16:03:44 <bringert> and using the normal rotation function to rotate 90 degrees gives rounding errors
16:04:39 <jgrimes> bringert, how might one go about deleting and editing comments?
16:05:01 <bringert> jgrimes: you mean how to add the code for it?
16:05:03 <shapr> I'd like to talk about it more, but I have to go see an apartment in SÃ¶dertÃ¤lje tomorrow morning.
16:05:08 <jgrimes> bringert, either one
16:05:31 <jgrimes> bringert, since they don't currently have that ability as far as I can tell
16:05:32 <bringert> jgrimes: there is no GUI support for it, but it would be easy to add
16:05:49 <jgrimes> thats what I was thinking
16:06:02 <jgrimes> I was also thinking it'd be easy to make a pastebin module at this point
16:06:20 <bringert> jgrimes: sure
16:06:33 <bringert> jgrimes: do you want to try writing the code yourself?
16:06:39 <jgrimes> bringert, sure.
16:07:30 <bringert> jgrimes: for comment editing and deletion, look at the stuff in Module_blob2 for blog entry editing and deletion
16:07:41 <bringert> jgrimes: you need to add similar stuff in Module_comment
16:07:49 <jgrimes> bringert, all right
16:07:57 <bringert> and permissions in the comment permissions module
16:08:13 * shapr goes to bed
16:08:20 <bringert> good night shapr
16:08:31 <lispy> sweet, i can open .mdb files using odbc even if office is not installed
16:08:43 <jgrimes> shapr, later
16:09:10 <bringert> jgrimes: will you send me a patch when you're done? please ask if there is anything you wonder about in the code
16:09:18 <jgrimes> bringert, sure thing
16:09:30 <largos> lispy: mdb = microsoft data base?
16:11:07 <bolrod> something like that
16:11:10 <bolrod> I guess.
16:12:19 <jgrimes> bringert, I'll start working on the editable/deletable comments after I run a few errands. Hopefully (ha. ha.) I can make some progress tonight.
16:13:53 <bringert> jgrimes: great, have fun. again, ask me if you have any questions. I may be offline tonight
16:19:29 <lispy> largos: correct
16:19:43 <lispy> largos: our software can create text files or access databases
16:19:55 <lispy> it's been up to me to decide which format I want to fight with
16:20:12 <lispy> given that the data sets are huge, i think access is prefered
16:20:20 <bolrod> I guess text files are ok..
16:20:22 <lispy> plus i won't have to write a parser for each format
16:20:44 <largos> oof.  what were your other choices?
16:21:35 <lispy> text files but each type of evaluation data is dumped in a different format or tables in an access database...those were the options
16:22:04 <largos> ah..
16:22:54 <dgoldsmith> I'm looking for an article I read recently on arguments people use against higher-level languages.
16:23:19 <lispy> it terms of performance, given a sufficiently lazy implementation (shouldn't be a problem in either format) it sholud be about the same.  But, the advantage is, i don't have to worry about parsing formats that might change?
16:23:30 <dgoldsmith> The thesis was that people who had never used a language higher up the expressiveness scale couldn't see why it would be better than their language.
16:23:46 <dgoldsmith> Does that ring a bell with anyone? I can't find the reference.
16:24:08 <bolrod> nope.. but if you find it..
16:24:09 <lispy> dgoldsmith: i think that was by Paul Graham
16:25:18 <jargonjustin> dgoldsmith: Perhaps http://www.paulgraham.com/icad.html ?
16:25:19 <lambdabot> Title: "Revenge of the Nerds"
16:27:38 <lispy> my advice to anyone reading Paul Graham is to read critically...he says many intelligent things and slips in some really odd ball things as well
16:27:46 <dgoldsmith> jargonjustin: that looks like it, but I think it was a more recent version (shorter, too). It was definitely using Lisp, so I think this is the right track.
16:28:38 <johnnowak> jargonjustin: that quote from Mr. Steele doesn't say much for lisp, does it?
16:29:55 <jargonjustin> johnnowak: My interpretation of the quote was that Java was targeted at C++ programmers looking for something incrementally better, and to get that they took ideas from Lisp.
16:31:08 <johnnowak> jargonjustin: right, well, yes, i understand the quote. just having a bit of fun.
16:33:54 <lispy> anyone else notice that these examples no longer type check? 
16:33:56 <lispy> http://www.haskell.org/hawiki/HaskellDbTutorial
16:33:57 <lambdabot> Title: "HaskellDbTutorial - The Haskell Wiki"
16:36:46 <the_lord> @hoogle concat
16:36:46 <lambdabot> Prelude.concat :: [[a]] -> [a]
16:36:46 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
16:36:46 <lambdabot> Data.PackedString.concatPS :: [PackedString] -> PackedString
16:37:18 <the_lord> @hoogle ++
16:37:18 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
16:37:19 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
16:37:19 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
16:44:33 <palomer> you're all nuts.
16:45:01 <palomer> what's the standard parser/lexer for haskell?
16:45:16 <palomer> palomer: happy/alex
16:45:19 <palomer> thx
16:45:37 <edwardk> heh
16:45:37 <palomer> any others?
16:45:50 <edwardk> parsec, parsek/readp, parrows
16:45:54 <thumper9> hey haskell
16:46:09 <thumper9> can one do OLTP in haskell?
16:46:14 <lispy> OLTP?
16:46:16 <thumper9> online transaction processing
16:46:23 <thumper9> ebusiness
16:46:24 <palomer> I already have the grammar in BNF
16:46:37 <thumper9> biz
16:46:38 <edwardk> palomer: oh, and frown
16:46:43 <lispy> thumper9: hmm..check the haskell-cafe mail list archives...i think someone was looking into that
16:46:50 <edwardk> frown is lalr(k)
16:47:00 <edwardk> might work well forn an existing lalr grammar
16:47:08 <ValarQ> is there any good arrow based parser packages yet?
16:47:14 <palomer> happy vs frown!
16:47:15 * ValarQ was pretty impressed with parsec
16:47:17 <edwardk> valarq: parrows is arrow based
16:47:35 <ValarQ> edwardk: does it keep up with parsec?
16:47:37 <lispy> my only complaint with parsec is that backtracking must be explicit
16:47:50 <edwardk> didn't spend too muh time using it and haven't profiled the alternatives yet
16:48:03 <palomer> what do you guys recommend?
16:48:07 <palomer> the grammar is at http://www.norbeck.nu/abc/bnf/abc20bnf.htm
16:48:08 * edwardk kicks musasabi
16:48:10 <lambdabot> Title: "ABC notation 2.0 - BNF specification"
16:48:21 <edwardk> and musasabi here who i think wrote it, has been a lurker for days =)
16:49:37 <edwardk> i'm kinda partial to frown, but thats because i'm most comfortable with LALR
16:50:00 <edwardk> fewer surprises, no need to refactor the grammar, etc.
16:50:06 <palomer> difference between LALR and whatever happy uses?
16:51:28 <edwardk> eh, happy is GLR/LALR(1) also
16:51:32 <edwardk> so i guess it doesn't matter =)
16:52:07 <palomer> does parrow have left recursion yet?
16:52:11 <cjay> there is a parsec clone with automatic backtracking http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/HaskellCgi/show-haskell.cgi?file=../koen/Parsek.hs
16:52:12 <edwardk> frown compiles states down to a bunch of functions for each state
16:52:15 <lambdabot> Title: "The Multi Library"
16:52:17 <edwardk> happy is more traditional
16:52:32 <edwardk> so if frown doesn't need to lookahead, it doesn't, etc.
16:53:15 <palomer> efficiency isn't much of a concern for me
16:53:16 <edwardk> dunno, i gave up on them all and have a simple lexer written in parsec and my own grammar
16:53:37 <edwardk> i could probably do something horrific to get the javascript rules into parsec directly
16:54:11 <edwardk> but its more beneficial for me to recognize the handful of token types in a separate scanner with minimal state (just need the previous token to disambiguate future tokens)
16:54:34 <edwardk> because i have to deal with variable keyword sets, etc between different versions of the language i'm parsing
16:54:45 <edwardk> so happy/frown were both useless to me
16:54:46 <dgoldsmith> Found the reference: it was indeed by Paul Graham, "Beating the Averages". The phrase I couldn't quite remember was "The Blub Paradox."  :) 
16:54:46 <palomer> ugh, this grammar is in EBNF
16:54:54 <dgoldsmith> http://www.paulgraham.com/avg.html
16:54:55 <lambdabot> Title: "Beating the Averages"
16:54:59 <edwardk> oh, and i forgot one more
16:55:06 <edwardk> there is a packrat parser out there, called pappy =)
16:55:10 <edwardk> if you want another alternative
16:55:14 <palomer> pffft
16:55:29 <palomer> happy pappy frown
16:55:33 <edwardk> that grammar has a crud ton of rules though, so packrat would probably be slow
16:55:38 <edwardk> or rather
16:55:43 <edwardk> it would probably chew up memory
16:55:51 <edwardk> its speed should be fine
16:55:53 <palomer> packrat is supposed to be extra fast
16:56:15 <edwardk> packrat is linear, but it'll have a large constant in your case
16:56:20 <edwardk> linear != fast =)
16:56:28 <palomer> parrows hasn't been worked on in a year!
16:56:37 <edwardk> pal: yeah
16:56:44 <palomer> left recursion and EBNF, hrmph
16:56:53 <palomer> there aren't many choices
16:56:56 <edwardk> i was going to try to use it but i couldn't get einar here to wake up and answer any questions about its status
16:57:47 <edwardk> well
16:58:02 <edwardk> parsek will get the job done
16:58:12 <edwardk> if you don't care about speed
16:58:18 <palomer> left recursion
16:58:41 <edwardk> refactor it out or note the terminal set and loop it yourself
16:58:58 <edwardk> you combine the parsec/parsek functions yourself anyways
16:59:39 <lispy> @hoogle fromJust
16:59:39 <lambdabot> Maybe.fromJust :: Maybe a -> a
16:59:54 <palomer> terminal set?
16:59:54 <lispy> @index fromJust
16:59:55 <lambdabot> Data.Maybe
17:01:30 <palomer> edwardk: ever use these funky frown rule schematas?
17:01:48 <edwardk> http://slipwave.info/#js/lang/Parser.js
17:01:53 <edwardk> look on line 244
17:02:15 <edwardk> thats the core of the expression parser for a javascript interpreter
17:02:23 <edwardk> that spot in the grmmar is left recursive
17:02:30 <edwardk> but its the only spot
17:03:01 <thumper9> hey
17:03:11 <thumper9> what program do I use to do websites in haskell
17:03:11 <thumper9> ?
17:03:32 <thumper9> and how do I do communication with vendors in haskell?
17:03:43 <palomer> it seems frown can do my ebnfness
17:03:55 <edwardk> palomer: cool.
17:04:00 <edwardk> thats a lot easier then =)
17:04:44 <palomer> go frown go!
17:04:54 <edwardk> heh
17:05:21 <edwardk> i tend towards recursive decent and operator precedence parsing
17:05:31 <edwardk> and tend to bang them out by hand
17:05:47 <palomer> hrmph, cabal doesn't seem to be in my apt-cache
17:06:21 <palomer> recursive descent has to do with implementation, right?
17:07:02 <palomer> @hoogle cabal-get
17:07:02 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-get'
17:07:07 <edwardk> its just a off the cuff way to translate lalr style grammars into code, yeah
17:07:46 <edwardk> i don't like using rec-descent for everything though, coz you can chew through stack frames if you have a rich operator precedence layer
17:08:11 <edwardk> er rather that statement was ambiguous, if you have lots of layers of precedence rules, there =)
17:08:47 <edwardk> then an operator precedence parser works well for rest
17:08:48 <edwardk> http://en.wikipedia.org/wiki/Operator-precedence_parser
17:09:42 <palomer> hrmphrmph
17:10:11 <edwardk> line 211 in that earlier page points to the operator precedence parser in the js implementation, 20 lines of javascript probably 5-6 in haskell ;)
17:11:14 <palomer> I've never heard of this distinction before
17:11:54 <palomer> so if you have more than one operator in your grammar, it becomes an operator-precedence parser?
17:11:56 <edwardk> its main advantage is that it doesn't keep recursing through functions to get to finer terms, it reduces as early as possible and with as few stack frames as possible
17:12:43 <edwardk> not quite, operator precedence works well when you have multiple levels of precedence, its an alternative way to formulate a parser than recursive descent. works well for lots of binary operators. (theoretically it can handle unary as well)
17:13:00 <edwardk> but i just use it for my binary operators, resolves all my precedence there in one swoop
17:13:58 <edwardk> so i sandwich an operator precedence parser between two simple recursive descent implementations
17:13:59 <palomer> so recursive decent and operator-precedence are simply different ways of representing a grammar
17:14:16 <edwardk> they abuse the stack in different ways
17:14:45 <palomer> does a pragrammer need to know about them?
17:15:12 <edwardk> operator precedence requires some things about the syntax of your operators (can't take up multiple symbols or be recursive) but takes up a ton less stack space and can run several times faster as a result for a big grammar
17:15:20 <edwardk> depends on what you think a programmer should know ;)
17:15:40 <palomer> a programmer who's interested in coding in specifications and has no time/space constraints
17:15:41 <edwardk> er multiple symbols i mean multiple lexemes. i suppose there are ways to work around that
17:16:20 <edwardk> well i don't tend to define grammars that can't be parsed by the rec descent/op prec combo, thats technically a subset of the LALR(1) grammars
17:16:36 <edwardk> so knowing they are there is useful if you are spec'ing a language
17:17:13 <palomer> so you do all this by hand?
17:17:18 <edwardk> heh though i guess technically my grammar there cheats and is really LALR(2) to resolve labels
17:17:35 <edwardk> that thing was written by hand, yeah
17:18:28 <edwardk> it can't be readily parsed by standard tools because of some stupid language design decisions
17:18:43 <edwardk> so it was my only option
17:19:54 <palomer> that's nuts!
17:19:58 <edwardk> heh
17:20:08 <edwardk> well, the lexer is just a bunch of regexps, so thats painless
17:20:40 <edwardk> the rec. descent part is a pretty straight translation of the ebnf
17:21:07 <edwardk> and i can use combinator functions to literally translate the ebnf almost word for word
17:21:25 <edwardk> so the code there can translate almost perfectly to parsec
17:21:38 <edwardk> which is how i plan on implementing it in haskell
17:23:09 <palomer> consider frown
17:23:15 <edwardk> can't
17:23:22 <edwardk> i have two major problems
17:23:31 <edwardk> one is semicolon insertion in javascript
17:23:40 <edwardk> which makes the language not amenable to standard tools
17:23:46 <edwardk> it has some fairly arcane rules on that front
17:24:11 <edwardk> the other is that they tend to implement large chunks of the same grammar over with one word restricted for special contexts.
17:24:20 <edwardk> so yoou need parameterized rules
17:24:28 <edwardk> and no standard tool offers those
17:24:33 <edwardk> i.e.
17:24:46 <palomer> frown has rule schematas
17:25:37 <palomer> and the semicolon rules could maybe be mitigated to the lexer
17:26:04 <lispy> thumper9: check the haskell-cafe mail archive,  you'll see things like wash and emails about POS systems
17:26:50 <edwardk> can't do the semicolon insertion in the lexer readily, it requires a lot of information about the parse
17:27:42 <edwardk> they get somewhat crazy about what line the next token is on, and what context you're in, etc.
17:27:51 <edwardk> and you can do it after this but not there, etc.
17:28:07 <edwardk> its easy to get it almost right, hard to hit it dead on that way
17:29:12 * palomer frowns on frown
17:29:40 <edwardk> the frown rule schemata system doesn't realy buy me anything over hand writing the rec descent, because thats what i have in the javascript version =)
17:30:03 <edwardk> their many is my star, their sepby is my tie, etc.
17:30:04 <edwardk> =)
17:30:13 <edwardk> it just gives you ebnf
17:31:56 <edwardk> and then you run into the fact that i don't have one grammar, i have a lot of grammars that tend to overlap
17:32:14 <edwardk> because i parse ecmascript 3, and ecma4 which are totally different languages
17:32:30 <edwardk> but share 'gross' structure.
17:33:31 <edwardk> and i want to be able to combine the current ecma4 variants out there, actionscript 3 and jscript.net which have subtle variations.
17:35:08 <edwardk> so i build little language profiles of features, use those to build a lexer and parser and then use the specialized lexxer and parser to generate a parse tree thats a fixed point of combined expression type for the language features i care about
17:35:24 <edwardk> the fixed point of the combined...
17:35:35 <edwardk> and i''m going to shut up now, because you probably don't care =)
17:35:48 <edwardk> and i just realized i've been talking to myself for 6 minutes =)
17:37:46 <wolverian> javascript has a weird semicolon rule in the grammar? *boggle*
17:38:44 <edwardk> wolverian: you insert a semicolon if the derivation would crash,, bu only if the next symbol is on a new line and the last symbol isn't return break continue or throw OR you insert it before certain other keywords even if they are on the same line
17:38:48 <edwardk> etc, etc.
17:39:03 <edwardk> lets you forget a ; and it keep on ticking in most cases
17:39:50 <edwardk> it actually is a useful language feature because their two function syntaxes cause someone to use it fairly ofte
17:39:53 <edwardk> you can say
17:40:08 <edwardk> function foo() {}  <-- which doesn't expecct a ; terminator there
17:40:21 <edwardk> or var foo = function() {};  <-- which requires a semicolon
17:40:28 <edwardk> because its a var statement
17:40:38 <edwardk> the latter, people forget semicolons all the time
17:40:50 <edwardk> and the language just chugs along
17:40:54 <wolverian> yeah, that sounds familiar
17:41:16 <wolverian> another option is to make } act as a ; in certain contexts
17:41:24 <edwardk> that and things like in javascript you are expected to terminate most statements with a ; even if its the 'then' clause of an if
17:41:37 <edwardk> yeah } is one of the contexts in which you insert a missing ;
17:41:49 <edwardk> the language DOESN'T specify that else is a keyword you do so for 
17:42:02 <wolverian> weird
17:42:22 <edwardk> so if (x > 1) x = x - 1 else x = x + 1
17:42:35 <edwardk> is actually not valid and should fail
17:42:51 <edwardk> but all implementations out there fake the insertion anyways ;)
17:43:22 <wolverian> function declarations should be expressions too, really
17:43:26 <edwardk> (the x=x+1 statement should be ; terminated there
17:43:37 <wolverian> unifies the two cases, making it easier to remember the ; possibly
17:43:50 <edwardk> wolv: nah, because (function foo (){}); and function foo() {} mean two different things in javascript
17:44:01 <edwardk> the latter gets hoisted and you can refer to foo anywhere in the containing scope
17:44:09 <wolverian> boggle! 
17:44:18 <edwardk> the former defines a function and tells the functionn its name is foo, but doesn't tell the containing scope
17:44:47 <edwardk> so the function foo () {} and var foo = function () {} have two very different meanings
17:45:00 <edwardk> the former rebinds the name, and makes a foo you can call even before you declare it
17:45:09 <edwardk> the latter just makes an anonymous function that you can later reassign
17:45:17 <edwardk> the former is constant and shouldn''t be rebindable
17:45:26 <edwardk> etc
17:46:01 <bdash> edwardk: is it really any wonder that a lot of web browsers have incompatibilities, given how bizarre a lot of the semantics are in some places?
17:46:16 <wolverian> right, but that's totally orthogonal to the expression issue. I admit the (function foo(){}); is rather bizarre. 
17:46:31 <edwardk> the implementation can know in the former case that it can inline the function or perform other esoteric optimizations. in the latter it always has to check the var
17:46:53 <edwardk> (function () {}) is just a lambda with a funny hat ;)
17:47:08 <wolverian> but what about the named version?
17:47:13 <wolverian> are they equivalent? 
17:47:22 <edwardk> the fact that you can give it a name has to do with the fact that you can actually ask a function for a string equivalent
17:47:35 <edwardk> the foo version will return "function foo () { ... }"
17:47:40 <edwardk> the otherone will return without the foo
17:47:46 <edwardk> so the name is actually retrievable!
17:47:50 <wolverian> oh. that's rather cute
17:47:52 <edwardk> so they aren't equivalent
17:48:10 <edwardk> people have used it for some aspect oriented programming tricks
17:48:19 <edwardk> (heck, i've used it for some aspect oriented programming tricks) =)
17:48:51 <wolverian> the only thing I've used named anonymous (cough) functions for was for aiding debugging
17:48:54 <edwardk> that same trick lets me do things like define a cps transformation that works on the source of the function
17:49:05 <wolverian> (perl++ for being flexible like a 13 year old gymnast)
17:49:20 <edwardk> then if i evaluate that cps transformed function string in the same evaluation context as the original function it 'just works'
17:49:25 <edwardk> not bad for a scripting language
17:49:53 <wolverian> I know what cps is, but what's cps transformation?
17:50:08 <edwardk> cps transformation takes non-cps code and turns it into cps code
17:50:08 <edwardk> =)
17:50:29 <edwardk> http://slipwave.info/#%5B%5BCPS%20transformation%5D%5D%20libraries%20js.lang.Recompiler%20js.aop.Observable
17:50:47 <wolverian> and that actually halts? :)
17:50:53 <edwardk> yeah
17:51:15 <edwardk> just replace return with a call to a passedin parameter
17:51:40 <edwardk> so instead of: function square(x) { return x*x;} print square(x);
17:51:56 <edwardk> you have function square(x,return_) { return_(x*x); } square(print(x));
17:52:21 <edwardk> er the first should be using print(square(x));
17:52:31 <bdash> edwardk: before you said that 'if (x > 1) x = x - 1 else x = x + 1' isn't valid, and that the 'x = x + 1' needs a semicolon... surely you mean the 'x = x + 1' expression needs the semi-colon?
17:52:39 <edwardk> making it work right in an imperative language is a little trickier, because you have to deal ith the stuff in the next statement
17:52:52 <edwardk> bdash actually both =)
17:53:12 <edwardk> an expression statement requires a ; terminator by the grammar
17:53:20 <wolverian> edwardk, is that actually guaranteed to work? neat, in any case :)
17:53:42 <edwardk> wolverian yeah its guaranteed to work for all code, you can prove it nice and formally
17:54:01 <edwardk> i think davvi and filinski give a bunch of formal accounts of different lambda machine transformations
17:54:05 <wolverian> ah, nice. 
17:54:08 <bdash> edwardk: right, then I see what's going on in my little test case -- the in the function i've wrapped it in } causes the ; to be inserted
17:54:08 <wolverian> I'll take a look, thanks
17:54:33 <edwardk> bdash: yeah, spidermonkey does the else ; insertion usually
17:54:38 <edwardk> depending on how old the version is, etc.
17:54:45 <bdash> edwardk: JSCore (Safari's JS engine) doesn't
17:55:07 <bdash> edwardk: any reason you're so into ecmascript?
17:56:03 <edwardk> bdash: i had an application i needed a lot of javascript to run on the client side for... and i needed to build something more robust than javascript was designed to handle
17:56:40 <edwardk> so i implemented all this crap to recompile javascript into javsascript adding support for continuations so i could have blocking and threads and to give me the ability to overcome the million instruction cap
17:56:47 <edwardk> and the stack depth limitations
17:56:53 <edwardk> since you can't have mroe than 1000 stack frames
17:56:54 <bdash> hehe
17:57:19 <edwardk> so i have a complicated transform bounces up and down the stack and uses that as its thread quantum
17:57:50 <bdash> edwardk: I occasionally hack on JSCore (recently on the new JS debugger, Drosera) so I can understand a lot of the issues you're referring to :)
17:58:29 <edwardk> bdash: ahh
17:58:48 <edwardk> i kinda gave up coz, historically safari has had the worst javascript implementation out there
17:58:50 <edwardk> =/
17:58:55 <edwardk> no offense intended
17:59:09 <bdash> worst from a standards/compatibility PoV i take it?
17:59:18 <edwardk> it inherited a bad one and has done wonders improving it, but its still a little wonky
17:59:18 <edwardk> yeah
17:59:26 <edwardk> actually
17:59:39 <bdash> recent versions, especially the current development version, are much improved :)
17:59:41 <edwardk> it might be ok now, but i can't rely on that, because so many people run old copies of safarii
17:59:43 <wolverian> edwardk, you are crazy and I love you.
17:59:48 <bdash> but yeah, it's had its issues in the past
17:59:54 <edwardk> if i want to run something on the web i have a lot of safari 1.2 folks out there
17:59:59 <wolverian> edwardk, please come work on pugs's JS backend? :)
18:00:01 <edwardk> who get annoyed when they can't use the page
18:00:20 <bdash> tere 
18:00:22 <edwardk> wolverian: possibly, let me get my haskell javascript backend working first =)
18:00:22 <bdash> err
18:00:29 <bdash> there can't be many Safari 1.2 users out there now?...
18:00:35 <edwardk> i want a nice STM backed javascript first
18:00:48 <bdash> 10.4 ships with 2.0, and 10.3 software update will upgrade you to 1.3, IIRC
18:00:50 <edwardk> bdash: you'd be surprised. you can't run the new version on old mac os x
18:00:56 <edwardk> even 1.3 is abysmal
18:01:01 <wolverian> edwardk, that would probably be useful ... join #perl6 and talk about it sometime with the people who know pugs better than I do :)
18:01:23 <bdash> edwardk: I never used 1.3, so I'll take your word for it :)
18:01:29 <edwardk> wolverian: talked to audrey about it briefly (in fact hopped on freenode to ask her about the progress towards hsjudy)
18:01:39 <edwardk> happened to wander here on a lark =)
18:01:43 <wolverian> ah. nice. :)
18:03:00 <edwardk> the other motivation for the javascript recompiler
18:03:08 <edwardk> was to get working javascript in REALLY crappy browsers
18:03:26 <edwardk> like mac os ie 5.2 =)
18:03:51 <edwardk> which lacks exceptions, and you can't even test for the lack... because that requires you to use a language feature that would... throw an exception
18:04:16 <edwardk> so i implemented the recompiler to recompile javascript with exceptions down to javascript without
18:04:43 <edwardk> that combination of features and removing some of the other internal details could let the coderun down to like ns3 or so
18:05:00 <edwardk> but you start to get diminishing returns at that point
18:05:08 <edwardk> so i didn't bother in the end
18:05:30 <edwardk> and left the macos ie 5.2 case in place as a proof of concept
18:06:35 <wolverian> that must be some really nifty transformations indeed
18:07:00 <edwardk> well, internally i pretend ii'm a real compiler
18:07:14 <edwardk> build a flow graph, etc. then i dumb out javascript statements like a real assembler would
18:07:29 <edwardk> but my assembly statements are actual javascript expressions
18:08:10 <edwardk> the statements are output in a sort of backwards duff's device while (1)  switch (state) { case 0: .... ; case 1: ... }
18:08:18 <edwardk> so i can set state and break as a goto =)
18:08:38 <edwardk> there is a nice theorem that shows you can turn any number of while loops into one
18:08:59 <edwardk> and i use state transitions to model all loop structures etc.
18:09:19 <edwardk> the cps transform handles exceptions, and i just have a little overhead for counting stackframes
18:09:45 <edwardk> if i don't use the cps features (coz i only transform some of the calls) then i don't pay for them, and in general it runs about as fast as before
18:10:17 <edwardk> if i do, i get tail-call-optimization and i only have to trampoline every 990 stack frames =)
18:11:21 <the_lord> isn't && shortcut?
18:11:40 <SamB_XP> whatever do you mean?
18:11:52 <the_lord> s/shortcut/shortcircuit
18:11:56 <SamB_XP> > True && undefined
18:11:57 <lambdabot>  Undefined
18:11:58 <edwardk> in haskell?
18:12:04 <SamB_XP> > False && undefined
18:12:05 <lambdabot>  False
18:12:12 <SamB_XP> well... in a manner of speaking...
18:12:20 <SamB_XP> but there aren't any side-effects anyway
18:14:23 <edwardk> so yes, i've been obsessed with the javascript thing for the last month or so
18:15:45 <edwardk> right now however, i'm just trying to beat this stupid hashtable into shape. *kick*
18:16:07 <SamB_XP> hash table?
18:16:27 <edwardk> i started slapping together an STM based sorted linear hash table
18:16:40 <edwardk> so i could a.) get a feel for why Data.HashTable sucks, and b.) because i need it for my code
18:16:51 <edwardk> and i really don't want to use Data.Map over TVars
18:17:27 <SamB_XP> you doing that thing where every so often you jump off of the empire state building?
18:17:40 <edwardk> samb: in the javascript engine? yeah =)
18:17:43 <edwardk> its an appel trampoline
18:18:19 <edwardk> stole the idea from Chicken =)
18:20:49 <edwardk> afk for an hour
18:26:54 <the_lord> all the functions inside a where are calculated in the beginning?
18:27:11 <the_lord> or just when they are needed?
18:28:49 <eivuokko> When needed.
18:30:08 <Pseudonym> Everything everywhere is only calculated when needed.
18:30:20 <Pseudonym> In theory.
18:30:36 <Pseudonym> In practice, GHC sometimes calculates things if it can prove that it will definitely be needed.
18:30:50 <Pseudonym> And the programmer can force a "need" (e.g. with seq).
18:32:16 <SamB> well, really, GHC could try to calculate stuff early anyway if it could guarentee it wouldn't take forever and if it could fail gracefully...
18:32:27 <Pseudonym> Sure.
18:32:32 <Pseudonym> Even CPUs do that.
18:32:58 <eivuokko> Didn't speceval branches have code to do that?
18:33:02 <SamB> well, CPUs need to do better than guarenteeing it won't take forever, but then CPUs don't have to deal with expressions
18:33:14 <Pseudonym> Sure.
18:33:48 <Pseudonym> CPUs just need to guarantee that critical operations (e.g. memory commits, traps/exceptions) don't commit.
18:35:28 <Pseudonym> Speculative execution in a CPU by definition won't take forever because the pipeline depth is always finite.
18:35:44 <Pseudonym> As is the ROB size.
18:41:11 <palomer> @palomer
18:41:11 <lambdabot> xml stands for "xtremely mild lullaby"
18:41:34 <palomer> yes! a new quote
18:41:35 <Pseudonym> @keal
18:41:35 <lambdabot> can haskell compile flash animations and java apps?
18:41:58 <Pseudonym> @pseudonym
18:41:59 <lambdabot> Unknown command, try @list
18:42:04 <Pseudonym> @fact pseudonym
18:42:04 <lambdabot> pseudonym: My initial creator.
18:42:13 <Pseudonym> @vixen I'm never going to live that down, am I?
18:42:13 <lambdabot> whoa whoa whoa, one question at a time!
18:42:39 <Echo_Flat> hello
18:42:55 <Echo_Flat> i need some help in haskell...
18:43:03 <Pseudonym> Well you've come to the right place.
18:43:29 <Echo_Flat> thanks.
18:43:46 <Echo_Flat> im writting an application in Happy/Alex
18:44:01 <Echo_Flat> i wrote whole app... byt
18:44:03 <Echo_Flat> but
18:44:15 <Echo_Flat> happy exports parser
18:44:16 <Echo_Flat> and
18:44:29 <Echo_Flat> alex exports alexScanTokens
18:44:58 <palomer> ok
18:45:05 <palomer> someone tell me the easiest way to obtain cabal-get
18:45:07 <palomer> I'm on debian
18:45:13 <Echo_Flat> apt-get ?
18:45:40 <palomer> cabal isn't in my apt-cache
18:45:42 <Pseudonym> apt-get is surely the easiest way to get anything!
18:45:42 <palomer> is it in yours?
18:45:50 <offby1> so how do I turn an .lhs file into something readable?
18:46:08 <Echo_Flat> palomer, some extra repository
18:46:08 <Echo_Flat> ?
18:46:09 <Pseudonym> ofby1: By definition, lhs is meant to be more readable than hs.
18:46:21 <Pseudonym> palomer, what repo are you using for haskell?
18:46:23 <offby1> Pseudonym: erp
18:46:43 <Echo_Flat> i need to use alexScanTokens with parser generated whit alex
18:46:45 <Echo_Flat> HOW?
18:46:46 <palomer> deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable testing stable
18:46:47 <lambdabot> Title: "Index of /archive/i386"
18:47:00 <offby1> Pseudonym: the .lhs file that I just made is identical to the .hs file from which I made it, except I removed the "--" that introduced comments, and added "> " at the beginning of each code line :-|
18:47:12 <palomer> I tried a package, and it says this:
18:47:15 <palomer> libghc6-cabal-dev: Depends: ghc6 (< 6.4.2) but 6.4.2-2 is to be installed
18:47:31 <Pseudonym> Echo_Flat: Do go on.
18:47:45 <Echo_Flat> Pseudonym: ?
18:47:48 <palomer> !
18:47:57 <Pseudonym> Echo_Flat: You had a question.
18:48:00 <Pseudonym> Which you hadn't yet asked.
18:48:00 <Echo_Flat> mtd x = readFile x >>= \str -> putStr (show parser . (alexScanTokens str))   ???
18:48:11 <Echo_Flat> err0r
18:48:15 <Korollary> offby1: what do you exactly mean by readable?
18:48:20 <Pseudonym> What's the error?
18:48:32 <offby1> Korollary: I was expecting, say, a LaTeX file, which I could then process with LaTeX.
18:48:33 <Echo_Flat> ok
18:48:51 <Pseudonym> palomer, what debian version are you using?
18:49:12 <palomer> unstable
18:49:14 <palomer> I think
18:49:17 <Echo_Flat> Main.hs:11:39:
18:49:17 <Echo_Flat>     Expecting a function type, but found `[Char]'
18:49:17 <Echo_Flat>       Expected type: b -> c
18:49:17 <Echo_Flat>       Inferred type: String
18:49:17 <Echo_Flat>     Probable cause: `show' is applied to too many arguments in the call
18:49:18 <Echo_Flat>         (show parser)
18:49:20 <Echo_Flat>     In the first argument of `(.)', namely `show parser'
18:49:24 <Echo_Flat> Failed, modules loaded: Parser, Lexer.
18:50:25 <Pseudonym> palomer, unstable is by definition unstable.  Don't be shocked if stuff gets out of sync.
18:50:26 <the_lord> unmanarc, que más?
18:50:28 <Korollary> offby1: ah. http://www.iai.uni-bonn.de/~loeh/lhs2tex/
18:50:29 <lambdabot> Title: "lhs2TeX"
18:50:33 <palomer> I'm shocked!
18:50:49 <Pseudonym> palomer, you might want to ask igloo
18:50:53 <Echo_Flat> the_lord: tu tambien
18:50:54 <Echo_Flat>  :p
18:50:57 * palomer slaps Igloo 
18:51:02 <the_lord> Echo_Flat: ya yo termine
18:51:04 <lorne> offby1: http://www.haskell.org/onlinereport/literate.html might be of use, the bottom half
18:51:05 <lambdabot> Title: "The Haskell 98 Report: Literate Comments"
18:51:09 <palomer> I take a 4 month haskell hiatus and this is what happens!
18:51:22 <Korollary> offby1: actually, there are others here: http://haskell.org/haskellwiki/Libraries_and_tools/Program_development
18:51:23 <lambdabot> Title: "Libraries and tools/Program development - HaskellWiki"
18:51:30 <Pseudonym> palomer, the other topion is compile up GHC yourself.
18:51:39 <Pseudonym> All things considered, talking to igloo is probably better.
18:51:48 <offby1> lorne: thanks.  I read that, but didn't notice any mention of a processing tool.
18:51:52 <Pseudonym> http://urchin.earth.li/mailman/listinfo/debian-haskell <- Also helpful.
18:51:54 <lambdabot> Title: "debian-haskell Info Page"
18:51:59 <offby1> There seems to be an lhs2tex, though, which I'm now investigating
18:52:10 <the_lord> Echo_Flat: si pones show.parser.alexScanTokens $ str no te sirve?
18:52:40 <Pseudonym> Echo_Flat: Or even show parser . 
18:52:51 <Echo_Flat> a ver
18:52:53 <Pseudonym> show . parser . alexScanTokens $ str
18:53:11 <Echo_Flat> where $ str?
18:53:22 <Pseudonym> $ is function application.
18:53:30 <Pseudonym> See, what you actually typed is this:
18:53:35 <Pseudonym> show parser . (alexScanTokens str)
18:53:48 <Echo_Flat> hmm, yes
18:53:52 <Pseudonym> That composes the function (show parser) with the function (alexScanTokens str)
18:54:01 <Echo_Flat> ok, let me try
18:54:01 <lorne> offby1: I've used that style and \input{blah.lhs} in a latex document, I'm not quite sure what the other options are
18:54:02 <Pseudonym> But (show parser) isn't actually  a function.
18:54:18 <palomer> edwardk: still around?
18:54:23 <Echo_Flat> mtd x = readFile x >>= \str -> show . parser . alexScanTokens $ str ?
18:54:40 <Pseudonym> Echo_Flat: Yup.  Or even more succinctly:
18:54:48 <Pseudonym> readFule x >>= show . parser . alexScanTokens
18:54:53 <Pseudonym> readFile, not readFule
18:55:16 <Echo_Flat> oki
18:55:40 <Pseudonym> Actually, that's not type correct.
18:55:46 <Pseudonym> readFule x >>= putStrLn . show . parser . alexScanTokens
18:55:47 <Pseudonym> That is.
18:55:53 <Pseudonym> readFile again, not readFule
18:56:00 <Echo_Flat> ok
18:57:01 * palomer hugs frown
18:57:20 <Echo_Flat>     No instance for (Show Parser.Exp)
18:57:31 * Pseudonym loves misery who loves company
18:57:41 <Pseudonym> Echo_Flat: Ah.
18:57:48 <Pseudonym> Well.
18:58:04 <Pseudonym> Do you understand what that error means?
18:58:17 <Echo_Flat> Deriving show?
18:58:46 <Echo_Flat>  Probable fix: add an instance declaration for (Show Parser.Exp)
18:58:46 <Pseudonym> Doing that would work, yes.
18:59:03 <Pseudonym> Right.
18:59:03 <Echo_Flat> where deriving show in happy?
18:59:24 <Pseudonym> Hang on, let me look.
18:59:40 <Echo_Flat> oki
19:00:32 <Pseudonym> You declared Exp somewhere in the happy file, correct?
19:00:44 <Pseudonym> data Exp = Stuff | MoreStuff
19:00:57 <Echo_Flat> yes
19:01:02 <Echo_Flat> well
19:01:03 <Pseudonym> data Exp = Stuff | MoreStuff deriving (Show)
19:01:10 <Echo_Flat> oh!!
19:01:12 <Echo_Flat> :D
19:01:17 <Echo_Flat> let me try.
19:01:18 <Pseudonym> That'll do the trick.
19:01:39 <Echo_Flat> in all data types?
19:01:55 <Pseudonym> In all the ones that are part of the parse tree.
19:01:58 <Pseudonym> At least.
19:02:20 <Echo_Flat> Ok, modules loaded: Main, Parser, Lexer.
19:02:20 <Pseudonym> In general, it's usually not a bad idea to derive Show on most of your data types for debugging purposes.
19:02:23 <Echo_Flat> WOOOOOOOOOOOT!
19:02:35 <Echo_Flat> im happy!!
19:02:38 <Echo_Flat> :)
19:02:42 <Echo_Flat> thanks :)
19:02:43 <Pseudonym> Cool.
19:02:51 <Pseudonym> Can I ask what you're writing, BTW?
19:03:18 <Echo_Flat> a turing machine.
19:03:21 <Pseudonym> Cool.
19:03:39 <Echo_Flat> :)
19:04:08 <Pseudonym> Once you're a bit more comfortable with monads, you might like to look into Parsec.
19:04:34 <Echo_Flat> ?
19:04:35 <Pseudonym> It's an interesting approach to parsing, and it doesn't require source to source translators.
19:04:50 <Pseudonym> @google parsec haskell
19:04:53 <lambdabot> http://www.cs.uu.nl/~daan/parsec.html
19:05:32 <rhw> Is there a literate haskell .properties file for SciTe? Or can anyone recommend a decent Haskell editor?
19:05:50 <audreyt> whatever happened to hIDE?
19:05:55 <Echo_Flat> :)
19:07:43 <Pseudonym> audreyt: http://darcs.haskell.org/packages.hide/haskell-src/
19:07:45 <lambdabot> Title: "Index of /packages.hide/haskell-src"
19:07:50 <Pseudonym> I don't think anyone is actively maintaining it.
19:07:59 <Pseudonym> But I'm pretty sure that's the latest incarnation.
19:08:39 <audreyt> danke.
19:08:56 <Pseudonym> rhw: Emacs and vim are popular editors.
19:09:06 <Pseudonym> And they both support Haskell extremely well.
19:09:29 <rhw> Yeah; they're editors not IDEs.
19:09:39 <Pseudonym> Sure.
19:09:48 <rhw> Feh; hIDE seems dead, Visual Haskell is quite dead too - it seems.
19:10:02 <the_lord> rhw: Eclipse plugin for haskell is nice
19:10:03 <rhw> This language really needs an IDE if it wants to become popular.
19:10:26 <the_lord> rhw: it's not simple to write an IDE for haskell
19:10:28 <Pseudonym> rhw: Actually, the last thing any language needs is another IDE.
19:10:51 <Pseudonym> Far better to have a single (or a small number) of IDEs which are customisable for different languages.
19:11:35 <Pseudonym> I ended up not installing Visual Haskell.  You needed to be an administrator to install it.
19:11:37 <rhw> Well, what I really wanted to say was it that it would be great if VisualHaskell worked.
19:11:48 <Pseudonym> Which is dumb.  I didn't even need to be an admin to install Visual Studio!
19:11:51 <rhw> It doesn't work for VS2005.
19:12:11 <johnnowak> Pseudonym: You don't have admin privilages?
19:12:23 <Pseudonym> johnnovak: Yes, but that's not the point.
19:12:28 <eivuokko> johnnowak, It might be a matter of principle...
19:12:34 <Pseudonym> Right.
19:12:39 <Pseudonym> It's a bad sign.
19:12:43 <rhw> eivuokko, I think I know you :P
19:12:52 <the_lord> how do I make the infinite String of '-' ?
19:12:54 <rhw> Weren't you on #C++/DALnet a while ago?
19:12:57 <Pseudonym> Requiring admin privileges for a task that doesn't require admin privileges...
19:12:58 <johnnowak> eivuokko: I was guessing. :)
19:13:02 <Pseudonym> the_lord: repeat '-'
19:13:06 <Pseudonym> > repeat '-'
19:13:07 <lambdabot>  "---------------------------------------------------------------------------...
19:13:18 <johnnowak> Well... If you're sure it doesn't and it does, you have a point.
19:13:21 <eivuokko> rhw, Hmm?
19:13:23 <the_lord> thx
19:13:51 <rhw> eivuokko, Weren't you on #C++/DALnet a while ago? Friend of Belzex'?
19:14:09 <eivuokko> rhw, While ago, sure.
19:14:34 <rhw> eivuokko, Heh. Not sure if you remember me. I'm __cplusplus / typeid... or maybe my nick was Kdevilon. Can't remember for sure.
19:14:46 <eivuokko> rhw, Ah, yeah, I do :)
19:14:50 <rhw> heh :)
19:15:16 <Korollary> I actually find it uncomfortable when languages develop dependencies on IDEs.
19:15:26 <lispy> yeah
19:15:46 <lispy> and versa vica
19:15:51 <lispy> vice-a?
19:15:57 <Korollary> vice versa
19:16:01 <rhw> Yeah, increasing productivity and simplifying the programmer's work are completely undesirable.
19:16:01 * lispy nods
19:16:33 <Korollary> There's nothing wrong with increasing productivity.
19:17:02 <eivuokko> Korollary, Do you have some concrete example in mind with haskell and ides?
19:17:57 <Pseudonym> I think so-called "intentional programming" is the classic example of a system too dependent on its IDE.
19:18:04 <rhw> That's one of the things IDEs do. They also tend to attract programmers that use other IDEs. I've been mainly using VS for my C++/C# coding; using vim or any other text editor (not IDE) is a pita. And most people that used a decent IDE feel the same.
19:18:04 <lispy> i think VB and C# are good examples of languages with dependence on IDEs
19:18:12 <Pseudonym> Although even general COM programming is pretty close.
19:18:31 <Korollary> eivuokko: I can think of trivial use cases, but nothing groundbreaking I am afraid.
19:18:34 <Pseudonym> I'm not convinced that it's possible to write component code in Windows without the IDE.
19:19:16 <rhw> If the IDE can help a programmer to write programs faster, then I don't see what's wrong with it :)
19:19:37 <lispy> Pseudonym: if you had a type lib viewer, a reference book on COM and some patience you'd be okay
19:19:43 <monochrom> Then there is something wrong with the language.
19:20:05 <Korollary> A lot of IDE's let programmers "type" faster, more like secretarial work. I am not against those who perform static checks, highlight potential problems, etc.
19:20:13 <rhw> And I don't mean the drag and drop crap. I mean the integrated help, the class viewers, autocompletion, etc.
19:20:21 <monochrom> Not absolutely or certainly, I mean.  I mean probably.  The actual situations differ.
19:20:28 <eivuokko> Debugger.
19:21:22 <lispy> i value extensibility in an IDE because someone besides the developers will always come up with a cooler helper than the IDE devs dreamed of :)
19:22:40 <lispy> i think emacs held the trophy in that arena for a very long time, but it seems that maybe emacs has seen its peak and can't easy be extended in the ways people expect these days
19:23:20 <lispy> but then eclipse requires some pretty hardcore development to extend
19:23:41 <monochrom> Here is one example, even admitted by the Java community, of the point.  Until Java 1.4, they made the IDE write for loops over iterators because it was a pita.  The logical conclusion, as you can see in Java 5 now, is to add a new for construct to the language, rather than relying on the IDE.
19:24:30 <Korollary> The same goes for libraries that require assistance with boilerplate code.
19:24:42 <lispy> i find for-each to be often useless in java because i very often need indexes
19:25:48 <lispy> generics help a lot, now if only using tuples was convenient
19:25:55 <eivuokko> Korollary, I wonder what you think about automatic deriving for Prelude classes, then?
19:27:14 <Pseudonym> The problem here isn't using an IDE.
19:27:23 <Korollary> eivuokko: Yes, that is similar in principle.
19:27:37 <Pseudonym> Though I should point out that any language which requires boilerplate code probably needs some work on its abstraction mechanisms.
19:27:52 <Pseudonym> Boilerplate ideally belongs in a library.
19:28:01 <Pseudonym> Or at worst some macro system/
19:28:32 <Pseudonym> The problem is languages which are significantly harder to work in without the IDE.
19:28:33 <rhw> the_lord, Where can I find the haskell plugin for Eclipse?
19:28:33 <Korollary> eivuokko: The IDE I would like consumes CPU time while I am not typing, trying to help me think.
19:28:52 <monochrom> eclipsefp.sf.net
19:29:20 <dons> moin
19:29:21 <Pseudonym> I truly, truly object to having to learn a new IDE in order to use a new langauge.
19:29:31 <lispy> dons: moin
19:29:36 <the_lord> rhw
19:29:40 <the_lord> let me see
19:30:48 <the_lord> rhw: http://eclipsefp.sf.net/updates
19:30:50 <lambdabot> Title: "Index of /updates"
19:32:36 <Korollary> I gave a presentation of GHC STM today, which was well received.
19:37:11 <rhw> Feh, wtf. I can't create a new Haskell project in Eclipse.
19:37:18 <lispy> Korollary: to what audience?
19:37:39 <lispy> rhw: have you defined a 'workspace'? eclipse has a lot of weird restrictions
19:37:58 <Korollary> lispy: to buncha guys at work. nothing serios. purely adademic
19:38:29 <lispy> Korollary: STM does look very promising tho when i looked at it
19:38:35 <lispy> did*
19:38:50 <lispy> neat idea and apparantly has great performance
19:40:08 <Korollary> Yes, it's very easy to use. I value that more than any performance claim.
19:41:44 <Korollary> what is a tor connection?
19:42:20 <eivuokko> It's some sort of messenger or chat-system, I think.
19:44:02 <lorne> Maybe http://tor.eff.org/
19:44:03 <lambdabot> Title: "Tor: An anonymous Internet communication system"
19:45:42 <Korollary> Ah, thanks.
19:46:18 * edwardk returns from 'spending quality time' =)
19:46:57 <Korollary> You quoted that as if to mean "I just had to see my parole officer".
19:47:09 <edwardk> hah
19:47:10 <edwardk> well
19:47:12 <edwardk> =)
19:51:56 <edwardk> the fiancee finally let me free from watching the dance show to program, so its not much different ;)
19:52:14 <Korollary> which dance show?
19:52:25 <edwardk> 'so you think you can dance'
19:53:26 <Korollary> how about 'so you think you can parse'?
19:53:35 <jer> urgh, reality tv shows aren't.
19:54:00 <edwardk> right now i'm just trying to resolve 'so you think you can hash' =)
19:54:12 <edwardk> pathetic that its taking this long to transcode to haskell =)
19:54:31 <dons> what are you trying to do?
19:54:46 <edwardk> an STM based sorted linear hash
19:54:57 <dons> ah, ok. very interesting.
19:55:01 <edwardk> trying to get my head around why Data.HashTable sucks and avoid using Data.Map if possible
19:55:03 <Korollary> How is it STM based?
19:55:06 <dons> i hope you cabalise it and release it for all :)
19:55:44 <edwardk> kor: well, the hash is stored over an array of tvars for one, and i bundle the whole hash struct into another tvar to reflect global state changes
19:55:59 <edwardk> so you can make modifications with only a 2 tvar change delta.
19:56:09 <edwardk> so it should be reasonably quick
19:56:09 <Korollary> is this like a distributed hash table?
19:56:42 <edwardk> well, its STM, so its a hash table that can be read or written to by multiple threads. i wanted to use stm for threading in my js implementation
19:57:08 <edwardk> and i don't like using Data.Maps of TVars, it seems wrong to me that thats currently the way people like to do it because the hashtable sucks so bad
19:57:23 <edwardk> so i wanted to understand what could be done to fix or replace the hash table
19:58:38 <Korollary> how does Data.HashTable suck?
19:58:39 <edwardk> not currently trying to comply with the old interface, because, well, i'm still learning my way around haskell, so i figure i make a few mistakes and learn from them
19:59:22 <edwardk> well, in my case i want to be able to read/write it from multiple threads ithout locking
19:59:27 <dons> well, implementing an STM-based hashtable is kind of diving in at the deep end. good stuff!
19:59:40 <edwardk> so since there is no STM equivalent, thats one strike
20:00:16 <Korollary> oh I see
20:00:36 <edwardk> the other thing is i recall that pugs defected from it in favor of data.map for speed reasons, though that may be apocryphal.
20:00:51 <edwardk> and it may combine with the simultaneous defection to using tvars and stm
20:01:03 <edwardk> dons: its actually pretty painless
20:01:21 <edwardk> i kinda want to code up a bunch of STM data structures now =) these are neat
20:01:22 <edwardk> heh
20:01:30 <Korollary> yes
20:01:37 <rhw> WTF
20:01:44 <edwardk> i wound up reinventing STM for a database programming class abot a year and a half ago, so i find it very intuitive.
20:01:55 <Korollary> but, the achieve that granularity, you will have to re-implement hash tables with TVars as primitives.
20:02:51 <edwardk> kor: currently i have the hash table itself with one tvar, and then the hash table is built over an Array Int (TVar [(k,v)])
20:03:42 <edwardk> so to modify the hash it sets up the global environment, possibly growing the array, uses the linear hash table stuff to tweak the right cells and goes from there
20:04:18 <edwardk> most ops should only need 2 tvars one to the single relevant hash table cell, one to rebind the hash table itself.
20:04:37 <edwardk> i'm playing with other ways to carry around that state since i'm mostly interested in storing hashes in hashes
20:05:25 <edwardk> so i might be able to strip the outer layer, but i think that risks carrying a state monad around or me screwing up and forgetting to rewrite the tvar or something.
20:06:36 <edwardk> i''m also currently being evil an only allowing the underlying vector to grow, not shrink
20:06:50 <edwardk> i probably should do the latter, but then i risk array thrashing at power of 2 sizes.
20:07:01 <edwardk> as you add and remove elements
20:07:27 <edwardk> i figure once its grown that big keep it. but then thats a decision based on usage patterns for javascript
20:07:29 <Korollary> well, isn't that pretty lousy look-up performance?
20:07:32 <edwardk> where you very rarely delete from arrays
20:08:26 <edwardk> kor: well, right now its looking in the hash table at a tvar, and walking the list for the item, standard O(1). two tvars read, nothing written, lookups shouldn't suck.
20:08:45 <edwardk> the current hash table has to walk 3 iorefs, i want 2 tvars
20:08:47 <edwardk> er walk
20:08:58 <edwardk> doesn't seem too bad in comparison
20:09:11 <Korollary> oh ok
20:09:30 <edwardk> my growth is a little more irreguar because i'm doing a standard c++ style stl vector growth pattern of doubling in size each time
20:09:43 <edwardk> and the current implementation does an array of arrays shtick
20:09:57 <edwardk> but i figure thats probably yet another of the nails in its retrieval performance coffin
20:11:07 <palomer> edwardk: why must every line of a frown file start with a '>' ?
20:11:20 <dons> do you plan to cabalise and release the code as a library?
20:11:59 <edwardk> each insertion has to deal with the linear hash table distribution of one cell, so technically insertion costs 3 tvar reads and 4 tvar writes
20:12:23 <dons> @tell roconner yeah, dcoutts and i are writing a paper on the fusion rules at the moment
20:12:23 <lambdabot> Consider it noted.
20:12:33 <Korollary> I think it's roconnor
20:12:33 <edwardk> dons: i'm more than happy to throw it to the wolves. i don't know enough about cabal and the attendant processes, but i have nothing against that
20:12:49 <dons> oop
20:12:58 <dons> @tell roconnor yeah, dcoutts and i are writing a paper on the fusion rules at the moment
20:12:58 <lambdabot> Consider it noted.
20:13:05 <edwardk> palomer: because its a literate file format. isn't there a non-literate frown grammar format?
20:13:18 <edwardk> palomer: like .lhs -> .hs
20:13:26 <dons> edwardk: ok, well i could give you a cabal build system in about 30 seconds, let me find an example for oyu
20:13:29 <dons> ?where hnop
20:13:29 <lambdabot> http://semantic.org/hnop/
20:13:32 <dons> there :)
20:13:46 <edwardk> dons: heh, ok, well, let me get it functioning before i give it away =)
20:14:03 <edwardk> right now i have a couple of cases where i'm not freeing things up properly yet
20:14:05 <dons> you could just grab that repo, put your code in Data.Something
20:14:19 <edwardk> heh
20:14:27 <edwardk> haven't even run darcs/cabal yet ;)
20:14:34 <palomer> edwardk: very good question, I'm very new to frown
20:14:34 <dons> ah well, more wonders to behold yet
20:14:43 <edwardk> heh
20:15:26 <palomer> yes, you just remove the l!
20:15:52 <edwardk> usig dotted module names doesn't make you 'non-portable' these days, no? =) though i guess, using STM probably does ;)
20:16:14 <Korollary> STM is ghc only
20:16:19 <edwardk> yeah
20:16:54 <dons> every haskell implementation supports hierarchical modules, yep
20:17:03 <dons> ?where haskellexts
20:17:03 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
20:17:21 <dons> has a portability list, bsaed on feature
20:17:43 <dons> HierarchicalModules       True    True    True  True 
20:18:13 <Korollary> @keal
20:18:13 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
20:19:57 <Korollary> lambdabot should have its own blog.
20:20:16 <edwardk> heh, lambdabot does more work around here than any of us ;)
20:20:34 <dons> hehe
20:20:52 <dons> hence the 'overworked chick' logo
20:20:57 <edwardk> heh
20:21:16 <Korollary> borism doesn't learn
20:21:20 <dons> :/
20:21:30 <dons> maybe his client is just reconnecting.
20:21:48 <edwardk> ?
20:21:53 <edwardk> ah
20:23:18 <palomer> @hoogle Id
20:23:18 <lambdabot> Prelude.id :: a -> a
20:23:19 <lambdabot> Control.Monad.Identity :: module
20:23:19 <lambdabot> Text.Read.Ident :: String -> Lexeme
20:23:26 <augustss> dons: every haskell implementation does not support hierarchical modules :)
20:25:00 <palomer> rock, rock on!
20:26:18 <glguy> "not every haskell implementation supports hierarchical modules"?
20:27:32 <dons> augustss: i know ;) i hoped no one would notice that one
20:27:46 <edwardk> heh
20:28:05 <edwardk> it seems to be more of a 'every haskell implementation i'd want to use'... thing =)
20:28:25 <dons> the 4 that have had patches committed to them in the last 4 weeks support hierarchical modules
20:28:29 <dons> :}
20:28:34 <augustss> I admit that even I rarely use hbc anymore.
20:28:38 <edwardk> hah
20:28:58 <dons> i use it for bug checking purposes, still
20:29:05 <Korollary> I have not had programmer relationship, with that compiler, hbc.
20:29:16 <dons> $ hbi
20:29:16 <dons> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
20:29:16 <dons> Loading prelude... 1 values, 4 libraries, 200 types found.
20:29:29 <edwardk> ok, for style review: http://slipwave.info/#js/TLHT.hs should work =)
20:29:54 <offby1> gaa
20:29:58 <edwardk> the name isn't final, it doesn't work yet all the way or probably not much at all
20:30:10 <edwardk> just want insight into better ways to write things
20:30:18 <edwardk> this is downright imperative i admit
20:31:29 <augustss> hbc still has some unique features, like views.  that i've never used :)
20:32:19 <dons> hehe
20:32:36 <dons> ?remember augustss hbc still has some unique features, like views.  that i've never used..
20:32:37 <lambdabot> Done.
20:32:43 <edwardk> how 'heavy' is mucking around on the inside of lists from an efficiency standpoint?
20:32:50 <ozone> hbc had support for views?
20:32:57 <dons> had??
20:33:01 <ozone> you learn something new every day
20:33:01 <dons> ozone: bad ozone
20:33:05 <ozone> i mean, have!  have!
20:33:22 <edwardk> if i want something as fast as i can make it, i'm probably better off walking the chain and searching than bothering to maintain the list sorted?
20:33:36 <augustss> of course hbc has views.  probably even documented somewhere
20:33:46 <edwardk> since the size of the chains should be stochastically ~1?
20:36:08 <augustss> i should do an x86_64 port of hbc, i've not made a new port in 10 years, i think
20:36:46 <dons> we should put the src in darcs..
20:37:30 * palomer hits frown over the head with a bat
20:38:00 <offby1> .oO ( "#haskell-blah" ? )
20:38:03 <augustss> yeah, i should darcsify it
20:38:17 <dons> i could add a lambdabot plugin then :)
20:38:18 <augustss> darcs rulez!
20:38:30 <dons> yeah!!
20:38:35 <palomer> woot!
20:38:48 * offby1 glances around
20:38:50 <offby1> Rat own!
20:38:57 * offby1 cringes
20:39:21 <augustss> at work they still use rcs.  unbelievable
20:39:24 * offby1 stares blankly 
20:39:28 <offby1> not possible.
20:39:29 <Korollary> holw cow
20:39:42 <offby1> augustss is pulling our collective functional-programming legs.
20:39:48 <augustss> nope
20:40:01 <dons> that's really scary
20:40:06 <augustss> but they'll switch to clearcase soonish
20:40:10 <dropdrive> augustss: where do you work?
20:40:18 <augustss> Credit Suisse
20:40:29 <offby1> conservative, them bankers.
20:40:30 <dropdrive> ahh, no account there.
20:40:36 <offby1> Are the using VMS, too?
20:40:39 <offby1> s/the/they/
20:40:46 <augustss> I work in the investment bank part
20:41:16 <augustss> no, they mostly use MS, except for some solaris servers
20:41:23 <Korollary> augustss: Are you a quant?
20:41:25 <palomer> augustss: weren't you a prof before?
20:41:46 <augustss> i'm not a quant, but the group i work in has about 50 quants
20:42:00 <augustss> now they pay me to do haskell :)
20:42:18 <augustss> palomer: yeah, i've been a prof too
20:42:21 <dons> ?karma+ augustss 
20:42:21 <lambdabot> augustss's karma raised to 1.
20:42:27 <dons> ?karma lennart
20:42:27 <lambdabot> lennart has a karma of 0
20:42:31 <dons> this is all wrong
20:42:40 <augustss> no karma :)
20:42:47 <Korollary> had they had some competent immigration lawyers, I would have been a hedge fund quant on the east coast, and probably burned out by now. Tee hee.
20:43:03 <ozone> augustss: wave hello to gabi for me
20:43:04 <augustss> hmmm, maybe i should reclaim 'lennart' again.  but i have to change now and the
20:43:24 <augustss> ozone: will do
20:43:41 <augustss> she's having fun too
20:44:29 <ozone> yeah, well... i'm having... just as much fun!  really... i am
20:44:33 <augustss> so now my mission is to get the 50 quants to use haskell ;)
20:44:55 <augustss> my secret mission
20:46:48 <Korollary> Well, they may find the channel logs.
20:48:59 <augustss> oh now.  i'll have to blow up the internet
20:50:03 <dons> hehe
20:50:05 * palomer wonders what a quant is
20:50:17 <dons> i think that really is the only solution, in this case
20:50:50 <dons> if Project Lambda isn't to be made public in a terrible scandel
20:52:16 <dons> @fact-set ProjectLambda There is no Project Lambda
20:52:16 <lambdabot> Fact recorded.
20:53:00 <edwardk> there isn't some silly monadic version of fst to extract m (a,b) -> m a is there?
20:53:11 <Korollary> liftM fst
20:53:15 <edwardk> or should i just lift
20:53:17 <edwardk> ah k
20:53:18 <edwardk> yeah =)
20:53:20 <edwardk> thats what i figured
20:53:24 <augustss> fmap fst
20:56:01 <Korollary> augustss: so, what the heck is going on with the stock market?
20:56:11 <augustss> don't ask me
20:56:23 <augustss> i wear my headphones and hack haskell
20:56:30 <Korollary> hah
20:56:55 <augustss> pointer arithmetic and such
20:57:14 <augustss> unsafe left and right
20:58:20 <Korollary> For some reason, I can't bring myself to imagine that they are that performance-crazed like game engine programmers.
20:59:23 <augustss> no, but Haskell has to talk to C++ and Excel.
20:59:48 <Korollary> yes
20:59:53 <augustss> But for their inner loops they are willing to do just about anything.  it will never be written in haskell
21:00:16 <Korollary> how many engineers are we talking about?
21:00:26 <augustss> and they have large farms with thousands and thousands of servers
21:00:43 <augustss> engineers?  what kind?
21:00:49 <Korollary> software
21:01:19 <Korollary> thousand machines eh. That is more than I imagined.
21:01:34 <augustss> i don't really know.  I work in a modelling group.  about 50 mathematicians and physisists
21:02:06 <augustss> all the investment banks have large compute farms
21:03:01 <Korollary> STM to the rescue?
21:03:35 <Korollary> hmm , not really
21:03:42 <palomer> what's a quant?
21:03:49 <Korollary> palomer: quantitative analyst
21:04:07 <palomer> oh
21:05:06 <augustss> until i started working there i had no idea that they were using as much advanced math as they do
21:06:15 <Korollary> It is crazy.
21:07:02 <Korollary> I read that any given week, 50% of the trades are done by an algorithm.
21:08:18 <augustss> i bet they are
21:09:16 <Korollary> what were you doing before you joined them?
21:10:34 <Adamant> lambdabot - Project Lambda?
21:11:10 <Korollary> Adamant: no. Nonetheless, I can't divulge any more information.
21:12:58 <Adamant> lambdabot - self-improvement, self-destruction, lambda-nature
21:13:27 <Korollary> Is that what a real lambda looks like?
21:13:44 <augustss> Korollary: I part time at Galois, before that at Sandburst.
21:13:52 <Echo_Flat> *Main> ejecutar "prueba" usando "cinta"
21:13:52 <Echo_Flat> <interactive>:1:18: Not in scope: `usando'
21:14:04 <Echo_Flat> i want to define "usando"
21:14:10 <Echo_Flat> like... null
21:14:18 <Echo_Flat> ?
21:14:20 <dons> let usando = null -- perhaps/
21:14:28 <Korollary> Echo_Flat: either use a let expression, or put it in a file and load it.
21:14:29 <Echo_Flat> thanks dons :D
21:15:13 <u221e> My mandelbrot program keeps getting better ;)
21:16:00 <Echo_Flat> parse error (possibly incorrect indentation)
21:17:05 <Echo_Flat> why it work on *Main>, but not on file?
21:17:16 <Echo_Flat> let usando = 0
21:17:43 <Korollary> in a file, you just say "usando = 0"
21:17:57 <Echo_Flat> oh
21:17:58 <Echo_Flat> thanks
21:18:53 * offby1 had trouble with that too
21:20:20 <dons> maybe we should explain the whole prompt/file/let/top-level decl system in a tutorial somewhere
21:20:55 <mlh> yes please :-)
21:21:09 <Korollary> YAHT doesn't?
21:21:47 <u221e> dons, I'm almost at 100% improvement ;)
21:22:02 <dons> great!
21:22:13 <dons> can you show me the code?
21:22:22 <u221e> I'm almost done.
21:22:25 <dons> i'll run it against the older versions in my shootout setup
21:22:47 <u221e> I still want to remove an uneeded recusive function.
21:23:39 <Korollary> dons: how does @lambda work?
21:23:46 <the_lord> how do I get the args in a main program?
21:23:55 <the_lord> main = do { file <- head (getArgs); mtd file }
21:24:04 <the_lord> I have never compiled haskell
21:24:07 <the_lord> please help
21:24:07 <Korollary> @type args
21:24:08 <lambdabot> Not in scope: `args'
21:24:10 <dons> it runs a lambda interpreter
21:24:15 <Korollary> @type getArgs
21:24:16 <lambdabot> Not in scope: `getArgs'
21:24:22 <dons> @hoogle getArgs
21:24:23 <lambdabot> System.getArgs :: IO [String]
21:24:34 <glguy> @pl \x -> (0,x)
21:24:34 <lambdabot> (,) 0
21:24:45 <dons> main = do file <- getArgs >>= return . head ; mtd file 
21:24:53 <dons> or
21:25:00 <dons> main = do args <- getArgs ; mtd (head args)
21:28:44 <the_lord> dons: thx
21:35:04 <Echo_Flat> haskell could use a functions with differents parameters ? 
21:35:06 <Echo_Flat> like
21:35:17 <Echo_Flat> function x y z = z+y+x
21:35:23 <Echo_Flat> function x y = x+y
21:35:24 <Echo_Flat> ?
21:35:30 <araujo> uh?
21:35:52 <araujo> > let f x y z = x + y + z in f 3 4 5
21:35:53 <lambdabot>  12
21:35:57 <Echo_Flat> n 
21:35:59 <Echo_Flat> no n o
21:36:11 <Echo_Flat> i want a function called same
21:36:18 <Echo_Flat> with variable arguments
21:36:23 <skew> not so easily
21:36:31 <araujo> you could use classes
21:36:41 <Echo_Flat> hmmm?
21:37:04 <araujo> that will allow you some kind of polymorphism
21:37:25 <skew> Is there any way to make something like a GADT constructor   Univ :: (forall a . EType (a,env) t h[a]) -> EType env t (forall a. h[a])
21:38:05 <Echo_Flat> ouch. 
21:38:13 <Echo_Flat> hmm, im thinking...
21:39:34 <Echo_Flat> well NM. iwll think later.
21:39:43 <Echo_Flat> isnt so important now...
21:39:49 <Echo_Flat> right now :p
21:50:13 <Echo_Flat> if i want to read 2 files
21:50:16 <Echo_Flat> readFile x >>= \str 
21:50:21 <Echo_Flat> and
21:50:28 <Echo_Flat> readFile y >>= \stre
21:51:03 <Echo_Flat> oh
21:51:05 <Echo_Flat> done
21:52:53 <skew> maybe I can avoid translations to Haskell types in eval
21:54:53 <dons> Echo_Flat: ? do x <- readFile "1" ; y <- readFile "2" ; ...
21:55:39 <Echo_Flat> or.
21:55:50 <Echo_Flat> mtd x y = readFile x >>= \str -> readFile y >>= \strm ->  putStr . show . parser . alexScanTokens $ (str++strm)
21:55:52 <Echo_Flat> :)
21:56:01 <Echo_Flat> ;)
21:56:22 <dons> yeah, not using do notation for multiple args like this is a bit icky though
21:56:35 <dons> ?pl readFile x >>= \str -> readFile y >>= \strm ->  putStr . show . parser . alexScanTokens $ (str++strm)
21:56:35 <lambdabot> (readFile y >>=) . ((putStr . show . parser . alexScanTokens) .) . (++) =<< readFile x
21:56:39 <dons> hehe
21:56:56 <Echo_Flat> w00t
21:57:07 <dons> i've never seen someone actually write: action1 >>= a . b . c =<< action2
21:57:26 <palomer> @palomer
21:57:26 <lambdabot> Category theory is the Paris Hilton of mathematics
22:03:39 * edwardk returns. the party may commence =)
22:04:15 <Pseudonym> I wonder what syntax you'd use to put a third bind in there.
22:04:29 <Pseudonym> action1 >>= a . b . c =<< action2
22:04:33 <Pseudonym>              ||
22:04:40 <Pseudonym>              /\
22:04:40 <Pseudonym>              /\
22:04:44 <Pseudonym>            action3
22:04:48 <Cale> haha
22:06:52 <Pseudonym> action1 >>= a . b . c =<< action2
22:06:52 <Pseudonym>              ||    \\_
22:06:52 <Pseudonym>              /\     | _
22:06:52 <Pseudonym>              /\      |
22:06:53 <Pseudonym>            action3      action4
22:07:01 <edwardk> hehehe
22:07:03 <Pseudonym> Apologies to those with proportional-width fonts.
22:07:13 <Pseudonym> OK, I'll stop now.
22:07:49 <edwardk> someone feel like looking over some code stylistic gaffes on my behalf?
22:07:58 <edwardk> er some code for stylistic gaffes
22:08:13 <Cale> Pseudonym: I can only imagine what a parser for that would look like
22:08:28 <dons> so this is actually kind of a useful idiom, we've just invented...
22:08:29 <dons> Prelude> (readFile "f" >>=) . (putStr .) . (++) =<< readFile "g"
22:08:29 <Pseudonym> Cale: I think I've just discovered an elegant way to program with arrows.
22:08:29 <dons> no
22:08:29 <dons> yes
22:09:06 <edwardk> heh
22:09:07 <dons> yeah, its definitely related to arrows
22:09:16 <Pseudonym> Represent your arrow diagrams in ASCII art.
22:09:21 <Pseudonym> Parsec can parse anything!
22:09:23 <Pseudonym> Even Perl!
22:09:30 <dons> so zips, for example
22:09:30 <dons> Prelude> (readFile "f" >>=) . (print .) . zip =<< readFile "g"
22:09:31 <dons> [('n','y'),('o','e'),('\n','s')]
22:10:20 <edwardk> dons: you have wayyy too much free time
22:10:23 <dons> > (return [6..10] >>=) . (return .) . zip =<< (return [1..5])
22:10:24 <lambdabot>  add an instance declaration for (Show (m [(a, b)]))
22:10:30 <dons> arg, right.
22:11:35 <dons> > (return [6..10] >>=) . (show .) . zip =<< (return [1..5])
22:11:36 <lambdabot>  "[(1,6),(2,7),(3,8),(4,9),(5,10)]"
22:11:53 <edwardk> working up to an obfuscated haskell contest i see
22:12:04 <mogaal> Heyy. I want learn Haskell. How i should start?
22:12:26 <Cale> mogaal: I recommend starting with "Yet Another Haskell Tutorial"
22:12:32 <Cale> @where YAHT
22:12:32 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
22:12:49 <Pseudonym> mogaal: I recommend not learning from dons.
22:12:56 <edwardk> lol
22:12:58 <mogaal> Cale, Ok. What things i can do with haskell? for example?
22:12:59 <dons> thank you , Pseudonym :P
22:12:59 <palomer> ouch
22:13:04 <palomer> I second that motion!
22:13:05 <jrmole> http://haskell.org/tutorial/ is fairly intense but good
22:13:06 <lambdabot> Title: "A Gentle Introduction to Haskell, Version 98"
22:13:11 <dons> mogaal: anything you want, it's a general purpoes language.
22:13:24 <Pseudonym> And _definitely_ don't learn Haskell from lambdabot's @pl.
22:13:27 <dons> generally your code will be shorter, and more elegant than you might expect.
22:13:37 <Pseudonym> Sorry, yes, serious mode noew.
22:13:39 <Pseudonym> now
22:13:39 <edwardk> mogaal: just about anything. its a fast functional programming language.
22:13:40 <dons> mogaal: all the tutorials under the sun are at haskell.org
22:13:41 <audreyt> unless you have unreasonable expectations...
22:14:18 <palomer> I find haskell good for parsing and representing data as organized hierarchical structures
22:14:29 <palomer> not much else
22:14:32 <jrmole> haskell is great for high-level, maths-like stuff
22:14:40 <mogaal> Ahhh ok. I will learn. :-D Because i listen about this languaje in the univerisity
22:14:43 <audreyt> haskell works if you know what you are doing :)
22:14:45 <edwardk> then again palomer is a ray of sunshine =)
22:14:55 <palomer> @palomer
22:14:55 <lambdabot> That's nuts!
22:15:12 <Pseudonym> Haskell-like languages were originally designed for manipulating things with structure.
22:15:19 <Pseudonym> As palomer does.
22:15:38 <Pseudonym> If you're doing that, Haskell is one of the best choices around.
22:15:46 <Pseudonym> Haskell can do other things very well, of course.
22:15:54 <jrmole> a good haskell exercise of moderate length/difficulty is to implement Scheme :)
22:16:10 <jrmole> once you get fairly good, of course
22:16:10 <Pseudonym> I would think that implementing the parser would be the hardest part.
22:16:26 <jrmole> Pseudonym: both Happy and Parsec are fairly easy
22:16:35 <Pseudonym> Yeah, true.
22:16:45 <jrmole> stick to pure functional scheme without some of the sugar
22:16:48 <Pseudonym> Sorry, for some reason I had the Common Lisp lexical language in my head.
22:16:57 <jrmole> aye
22:16:58 <audreyt> implementing Haskell, however, is considerably harder and hairier
22:17:13 <Pseudonym> Implementing Perl can be done in a week.  Just ask Audrey.
22:17:23 <palomer> oh, I forgot to mention that it's syntactically more pleasant than most languages I know
22:17:25 <audreyt> if you restrict yourself to the subset of Perl without "print", sure.
22:17:38 <audreyt> "print" was surprisingly hard.
22:17:50 * Pseudonym isn't surprised, personally
22:18:04 <dons> well , how long was it until haskell had print ? ;)
22:18:12 <audreyt> very good point ;)
22:18:20 <edwardk> he
22:18:49 <Pseudonym> Reimplementing CPAN in Haskell takes longer than a week, sadly.
22:19:11 <audreyt> I thought I had a pretty good prototype working with SyntaxNinja
22:19:20 <audreyt> with cabal-install and ssh-based cabal-put
22:19:28 <audreyt> with the http://perlcabal.org/~audreyt/hackage/ layout
22:19:29 <lambdabot> Title: "Index of /~audreyt/hackage"
22:19:31 <Pseudonym> I meant all of the user-submitted libraries.
22:19:39 <audreyt> but he seems busy recently
22:19:52 <audreyt> oh. that. yeah.
22:19:56 <Pseudonym> But I digress.  The joke is a bit stale now.
22:20:21 <palomer> haskell is not the language for quick hacks; and robust imperative style code requires great knowledge in monad transformers and how they're stacked
22:20:38 <Pseudonym> Actually, I disagree with that.
22:20:59 <palomer> I disagree with your disagreeing
22:21:01 <Pseudonym> Haskell _is_ the language for quick hacks.
22:21:11 <Pseudonym> They just quickly turn into non-hacks.
22:21:32 <palomer> quick hack == not completely understanding the problem and wanting it solved quickly
22:21:34 <audreyt> I find Haskell very helpful when I have absolutely no idea what I'm doing.
22:21:39 <audreyt> what palomer said.
22:21:40 <Pseudonym> yeah, me too.
22:21:48 <audreyt> but then, to _code_ it into application
22:21:59 <audreyt> then the curve can be steep.
22:22:02 <Pseudonym> I often use Haskell for exploratory programming.
22:22:02 <palomer> I find haskell can help me understand the problem, but it takes time
22:22:16 <palomer> this isn't good when you want something which is mostly good and very dirty
22:22:24 <audreyt> yup.
22:22:27 <audreyt> steep = takes lotsa time.
22:22:51 <Pseudonym> Once again, I respectfully dissent.
22:22:55 <Pseudonym> You should see some of my code.
22:23:13 <audreyt> Pseudonym: case in point being cabal-install
22:23:17 <Pseudonym> Combinators can be responsible for some pretty awful hacks.
22:23:48 <audreyt> mostly it's the lack of readily available libraries, as well as the need to work with their APIs -- maybe of which involves monads -- that makes progress slower
22:23:53 <dons> haskell seems to make me more productive. i think that's been galois' experience too. 
22:24:07 <audreyt> but yeah, once it's coded up, refactoring is joyful
22:24:09 <palomer> I find I need to understand the underlying problems of a domain before getting any code done
22:24:11 <Pseudonym> dons: I think that assumes you're setting out to write a decent, robust program.
22:24:11 <dons> audreyt: what kinds of programs are you writing though?
22:24:12 <audreyt> and the code can survive far longest.
22:24:21 <dons> Pseudonym: yeah, maybe
22:24:29 <audreyt> dons: cabal-install was my previous haskell hack project with syntax ninja
22:24:34 <Pseudonym> But it makes me more productive in my hackery, too.
22:24:35 <dons> that's another point. once written the code seems very stable
22:24:59 <Pseudonym> I think nothing of going through five intermediate languages on one line to do something that could be much more elegantly and straightforwardly expressed in one recursive function.
22:25:11 <palomer> I'd be very surprised to see some natural ruby/perl super hacks being in haskell
22:25:21 <Korollary> what is a super hack?
22:25:21 <audreyt> like Plagger?
22:25:52 <palomer> a 1 liner that takes every file in a directory and translates them to piglatin
22:25:54 <audreyt> # http://plagger.org/trac/wiki/CookbookBloglinesGmail
22:25:55 <lambdabot> Title: "CookbookBloglinesGmail - Plagger - Trac"
22:26:14 <audreyt> writing Plagger in Haskell would be fun and entertaining but not a 3hr-hack.
22:26:14 <Korollary> I am sorry, but perl one liners dont impress me.
22:26:21 <audreyt> plagger, however, is a 3hr-hack.
22:26:35 <palomer> it's not about being impressed! it's about getting the job done quickly and dirty
22:26:43 <Pseudonym> Haskell one-liners on the other hand...
22:26:49 <edwardk> audreyt: was the major reason for giving up on Data.Hashtable and moving to Data.Maps of TVars because of the performance of Hashtable or the lack of an STM version?
22:27:03 <edwardk> sorry for the very off topic question
22:27:07 <edwardk> but i saw you on channel
22:27:22 <Pseudonym> On the contrary, that's an on-topic question for a change.
22:27:28 <dons> :)
22:27:32 <Korollary> edwardk: it's on topic, d00d.
22:28:01 <edwardk> woohoo
22:28:03 <edwardk> *TLHT> show $ unsafePerformIO $ atomically $ do { hash <- build (`mod` 1500007) [(1,10),(2,21)]; lookup hash 132891 } 
22:28:04 <edwardk> "Nothing" 
22:28:04 <edwardk> *TLHT> show $ unsafePerformIO $ atomically $ do { hash <- build (`mod` 1500007) [(1,10),(2,21)]; lookup hash 2 }      
22:28:04 <edwardk> "Just 21" 
22:28:04 * palomer sees no difference between haskell 1 liners and perl 1 liners
22:28:06 <edwardk> *TLHT> show $ unsafePerformIO $ atomically $ do { hash <- build (`mod` 1500007) [(1,10),(2,21)]; lookup hash 1 } 
22:28:09 <edwardk> "Just 10"
22:28:11 <edwardk> finally working =)
22:28:41 <audreyt> edwardk: well, lack of a STM version primarily
22:29:02 <audreyt> edwardk: also couldn't find something for sparse lists
22:29:14 <edwardk> audreyt: heh, well, then i might have that fixed soon as a side effect of what i wanted for javascript
22:29:37 <palomer> note: if you use Map, you can't use hat
22:29:37 <audreyt> THash?
22:29:43 <edwardk> need to finish the wrapper so you don't have to do manual plumbing
22:29:50 <audreyt> can I get a TArray too? :)
22:29:54 <edwardk> thats basically what its becoming. =)
22:29:59 <audreyt> or TSequence actually
22:30:01 <edwardk> and TArray is easy ;)
22:30:03 <audreyt> URL? :)
22:30:23 <edwardk> its not done yet, but http://slipwave.info/#js/TLHT.hs
22:30:35 <edwardk> started cobbling it together today
22:30:36 * audreyt bookmarks edwardk as Source Of Good Bits
22:30:50 <edwardk> the code will move some place more permanent
22:31:17 <edwardk> i've basically been trying to get people to look through it to give me haskell style tips all afternoon, but no one has cared to reply =)
22:31:58 <edwardk> i'm planning on throwing a nicely named 'THash' or something around this, which will hold its state ina  TVar
22:32:21 <audreyt> this belongs to GHC core if you can pull it off :)
22:32:39 <edwardk> well, its there and functioning, not sure about speed yet
22:32:56 <edwardk> i was planning on playing with a bunch of STM data structures if i get the chance this week
22:33:00 <edwardk> coz i want them for my javascript project
22:33:10 <audreyt> the style looks fine
22:33:23 <audreyt> I'll indent them a bit differently
22:33:28 <edwardk> yeah
22:33:38 <edwardk> indentation needs to get flipped over. i'm used to 4 space tabs
22:33:48 <edwardk> and i haven't turned on soft tabs in vim yet
22:33:52 <edwardk> for various reasons
22:34:05 <edwardk> so indenting properly has been a pain in the ass this afternoon
22:34:17 * JKnecht suggests the lack of comment is an affirmation.
22:34:21 <Cale> edwardk: expandtabs is the way to go
22:34:26 <skew> Has anyone figured out how to do System F in the style of Sheard et. al.'s typed metaprogramming?
22:34:42 <edwardk> oh whoa, heh the autoformatter is mangling those tabs
22:34:57 <edwardk> so you probably wnt to 'view plain'
22:35:14 <edwardk> i think i'd mangled the view-source macro on that site to 4 space tabs
22:35:21 <edwardk> woops
22:35:45 <JKnecht> didn't need to do that in Mozilla
22:35:48 <skew> universals are tripping me up - looks like substitution in type application might require manually constructing witnesses
22:35:50 <edwardk> http://slipwave.info/jslib/js/TLHT.hs
22:35:53 <audreyt> edwardk: I'm giving it a reformat
22:35:53 <edwardk> there
22:36:07 <edwardk> kk
22:37:49 <edwardk> now, there are two ways this code could go. one is to implement a traditional sorted linear hash table, bt that means inserts and deletes have to deal with reversing lists in place and stuff
22:37:59 <edwardk> so they become more expensive
22:38:16 <edwardk> but it gives the ability to walk two hashes with the exact same set of keys in the same order
22:38:32 <edwardk> so if yu get the same key set you'll get the same key traversal order regardless of insertion order
22:38:42 <edwardk> the urrent way doesnt provide that guarantee, because i don't need it
22:39:00 <edwardk> and it slows down the common access patterns for javascript
22:39:54 <edwardk> reformatting eta? (that way i know whether or not to sit up and wait ;)
22:47:01 <audreyt> 2min
22:47:07 <audreyt> edwardk: only one real point other than general style
22:47:08 <edwardk> kk
22:47:17 <audreyt> you've using "let" only in certain branches
22:47:26 <audreyt> this is a habit by eager languages
22:47:33 <audreyt> in haskell you can float everything to "where"
22:47:39 <audreyt> and the branches that do not use those definitions
22:47:41 <audreyt> won't actually run them
22:48:09 <audreyt> which may (generally speaking) lead to more code reuse
22:48:12 <edwardk> one of those (split' was left in place, because it used things that were in scope above it
22:48:20 <audreyt> ah ok.
22:48:21 <edwardk> the others i probably am being an idiot =)
22:49:03 <edwardk> this is pretty much the first thing i've bothered to write in haskell since i started dusting it off
22:49:15 <edwardk> so like i said, style pointers welcome
22:51:51 <audreyt> edwardk: http://perlcabal.org/~audreyt/tmp/THash.hs
22:52:22 <edwardk> heh, well, THash was going to be the weapper around that that made the THash k v plumbing implicit =)
22:52:27 <edwardk> er wrapper
22:53:00 <audreyt> oh.
22:53:02 <edwardk> sok
22:53:19 <edwardk> i'll fix it up
22:54:00 <audreyt> uhm
22:54:06 <audreyt> http://perlcabal.org/~audreyt/tmp/THLT.hs
22:54:35 <audreyt> there now
22:55:04 <audreyt> I may be a bit overboard in convertin "if" and "let" to guards and "where"
22:55:10 <audreyt> but generally nested-ifs are bad idea
22:55:29 <edwardk> kk
22:55:50 <audreyt> you've had a lot of Hs experience years ago? :)
22:56:00 * audreyt can't quite believe that it's the "first thing" :)
22:56:12 <wolverian> audreyt, heh, I like the | = thing, visual branches :)
22:56:19 <edwardk> not very
22:56:35 <edwardk> i bsially looked at it, compared it to ML, saw that haskell 98 sucked and left
22:56:59 <audreyt> yeah. GHC is much better nowadays.
22:57:14 <edwardk> i'm pretty much an imperative programming type person, but i've slapped together a couple of computer algebra systems in the meaantime, so the functional style isn't entirely alien
22:57:33 <audreyt> I've seen your JS gateway drug thing
22:57:39 <edwardk> heh
22:57:55 <edwardk> not much there yet
22:57:59 <skew> A guy at the office last used Haskell 1.2
22:58:14 <audreyt> wolverian: yeah. pattern guards is teh luv
22:58:17 <edwardk> i just started putting something up so that i could have something describing the structure of the code before i forgot
22:58:40 <wolverian> audreyt, sure, but I haven't aligned them like that before. I think I'll do that from now on.
22:59:01 <audreyt> edwardk: oh line 214 should read
22:59:01 <audreyt> bin :: THLT k v -> Int -> Int
22:59:43 <edwardk> kk
23:00:23 * audreyt wonders why people write javascript with semicolons.
23:00:40 <edwardk> coz, a lot of us want to get rid of the semicolon insertion =)
23:00:47 <edwardk> its evil and makes parsing a pain
23:01:12 <edwardk> plus, if you omit them there are random cases in which they will nab the next symbol and continue parsing
23:01:23 <edwardk> you need to know a lot about the grammar to catch them all
23:01:34 <audreyt> weird, I've found myself on the other side of this discussion...
23:01:43 <edwardk> i tried ; free style for a while, then defected bacck
23:02:14 <edwardk> i also tend to mangle my javascript in several passes, and the last one removes all the linebreaks anywaays
23:02:17 <edwardk> =)
23:02:38 <audreyt> =)
23:02:44 <xahlee> hi folks
23:02:49 <audreyt> greetings xahlee
23:02:50 <xahlee> how do you pronounce haskell?
23:03:12 <xahlee> with emphasis on the first or lsat syllable?
23:05:09 <xahlee> greetings, audreyt
23:07:36 <xahlee> no one here? :(
23:08:23 <edwardk> nobody here but us chickens
23:08:40 <edwardk> audrey: heh patching up a couple of random bugs your reformatting brought to light in my code ;)
23:08:44 <audreyt> er no, chickens are over there in #scheme
23:08:50 <audreyt> edwardk: good. :)
23:09:31 <palomer> nobody here at all
23:09:54 <audreyt> just heads
23:13:13 <dons> ?google spj how do you say haskell
23:13:15 <lambdabot> http://lambda-the-ultimate.org/node/1507
23:13:15 <lambdabot> Title: "Linspire chooses Haskell as preferred language | Lambda the Ultimate"
23:13:19 <dons> ah, close
23:13:33 <dons> there's a .mp3 somewhere of simon saying it, if you're really interested, xahlee 
23:14:45 <xahlee> dons: where? eg. the ell should be as in tell or earl?
23:14:55 <dons> tell
23:15:20 <dons> hask, like hash, and ell like the letter L
23:15:56 <dons> i'm not sure where the sound grab is. shapr used to host it. he would know.
23:17:41 <skew> has-kell just invites confusion with pascal
23:20:02 <palomer> what? we aren't learning pascal?
23:29:50 <xahlee> mm... i think i've always pronounced it Hask-earl
23:30:02 <xahlee> more like Haskll
23:30:44 <xahlee> yeah, now reading them both several times, i def pref Haskll over Hask-ell
23:31:10 <dons> yeah, i suppose i also say Haskll
23:31:31 <skew> probably one of those upside-down e symbols, if I really knew IPA
23:40:34 <xahlee> haskÉll
23:40:43 <xahlee> skew dons
23:41:09 <xahlee> is there a online dict that actually gives IPA as pron?
23:41:36 <xahlee> see http://www.xahlee.org/Periodic_dosage_dir/t2/voksa_sinxa_ciste.html
23:41:38 <lambdabot> Title: "Xah: English Phonetics"
23:42:00 <Cale> Compose-e-e É
23:42:01 <Cale> :)
