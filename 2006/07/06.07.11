00:03:24 <u221e> How do I convert a Word8 into a Char without using ByteString's w2c function?
00:04:08 <dons> inline the body of w3c
00:04:18 <dons> w2c, i.e. chr . fromIntegral 
00:04:44 <u221e> Oh that's it? ;P
00:05:06 <dons> ?type chr . fromIntegral
00:05:07 <lambdabot> forall a. (Integral a) => a -> Char
00:05:11 <dons> ?type chr . fromIntegral :: Word8 -> Char
00:05:13 <lambdabot> Word8 -> Char :: Word8 -> Char
00:05:15 <dons> works for me
00:09:05 <u221e> What module is chr in?
00:09:14 <jgrimes> would using a ByteString instead of a list of Ints result in any speed increase for either manipulation or printing?
00:11:08 <jgrimes> or is it really more of a case by case thing.
00:12:19 <dons> bytestrings are faster than [Char] across the entire api. however, for a [Int] you've got more work, since an Int doesn't pack into a Word8
00:12:29 <u221e> nm, I found it
00:12:32 <dons> it would still be possible, with a coerce, to treat it as such
00:12:42 <jgrimes> dons, well, I don't need a full Int anyway
00:12:54 <dons> or you could consider Data.Array.Unboxed?
00:12:54 <jgrimes> a Word8 would work
00:13:04 <dons> ah, then, it would be bettter
00:13:08 <jgrimes> all right
00:13:09 <jgrimes> :)
00:22:31 <u221e> > putChar '1'
00:22:31 <lambdabot>  No IO allowed
00:22:37 <u221e> heh
00:23:10 <u221e> Why won't the following display anything on the screen?
00:23:14 <u221e> putChar $ (chr . fromIntegral) (1::Word8)
00:23:23 <dons> no newline to flush the buffer
00:23:34 <dons> try adding a putChar '\n' immediately after
00:23:44 <dons> or else ./a.out | less
00:25:15 <u221e> Still doesn't print a 1
00:25:22 <u221e> just a newline.
00:26:36 <dons> oh, what char do you think '1' is :)
00:26:39 <dons> try '65'
00:26:45 <jgrimes> :)
00:27:25 <dons> $ ghc -e 'putChar $ (Char.chr . fromIntegral) (65::Data.Word.Word8)' | less
00:27:25 <dons> A
00:27:43 <u221e> ...
00:27:47 <dons> > (chr . fromIntegral) (65::Word8)
00:27:48 <lambdabot>  'A'
00:27:53 <dons> > (chr . fromIntegral) (1::Word8)
00:27:54 <lambdabot>  '\SOH'
00:28:15 <u221e> I can't believe I forgot that :(
00:28:42 <dons> don't worry, i've done it many times when testing bytestrings :)
01:27:39 <roconnor> I want to Cabalize my FewDigits library.  Should I put the modules into a Heirarchy?
01:34:36 <xerox> roconnor - It is usually a good idea, yes.
01:34:48 <mnislaih> @seen Lemmih 
01:34:49 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I don't know when Lemmih last spoke.
01:35:27 <roconnor> How do I decide on things like where in the hierarchy, and Category, etc.?  Maybe I need to read more of the Cabal docs
01:37:29 <xerox> roconnor - Also take a look at the standard library hierarchy.
01:37:34 <xerox> ?docs
01:38:10 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/
01:38:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
01:38:40 <xerox> ?karma+ roconnor -- lambdabotness.
01:38:48 <lambdabot> roconnor's karma raised to 2.
01:39:49 <roconnor> I guess I should put it in Data.Real
01:41:12 <roconnor> What about the Cabal Category?
01:41:27 <xerox> What is FewDigits?
01:41:51 <roconnor> An implementation of exact real arithmetic
01:44:49 <mnislaih> can anyone recommend a good Emacs mode for Darcs ? There seem to be quite a few
01:47:00 <dons> Lemmih: good, looks like everyone's submitted their SoC surveys
01:47:22 <mux> are the SoC projects coming along nicely?
01:47:41 <dons> yeah, i think so.
01:47:41 <Lemmih> dons: Yeah. I got a hold of shapr last night.
01:47:45 <dons> cool
01:47:49 <mux> good
01:50:23 <roconnor> @type PreludeList.sum
01:50:24 <lambdabot> Couldn't find qualified module.
01:50:24 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
01:50:38 <roconnor> where's the PreludeList module?
01:50:55 <mnislaih> Lemmih: I've been running into strange ghc issues. Is it a bad idea to {-source-} import the GHC module ?
01:50:58 <xerox> Prelude imports List, or parts of it.
01:51:03 <xerox> If that is what you mean.
01:51:11 <xerox> ?hoogle sum
01:51:12 <lambdabot> Prelude.sum :: Num a => [a] -> a
01:51:12 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
01:51:12 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
01:51:14 <roconnor> But it is defined in the standard.
01:51:20 <roconnor> why can't I import it?
01:51:41 <roconnor> oh wait
01:51:56 <roconnor> An implementation is not required to use this organisation for the Prelude, nor are these three modules available for import separately.
01:57:40 <shemale_magic> so can haskell do what perl does but simpler?
01:58:16 <shemale_magic> I have perl bok but saw haskell and am woner hey this is new and improved and seems powerful because MIT guy philip green says haskell adn lisp are only langs where u spend more tie thinking than coding
01:58:18 <mauke> no, haskell isn't very good at obfuscated oneliners
01:58:45 <xerox> That last quote is quite right.
01:59:19 <dons> it's perfectly possible, isn't it?
01:59:26 <dons> ?wiki Obfuscation
01:59:27 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
01:59:42 <mux> haskell is not as script-oriented as perl is
01:59:49 <mauke> I said one liners :-)
02:00:02 <dons> ok :)
02:00:03 <mauke> as in perl -pe 's/^>//||!/\S/||s/^/-- /'
02:00:23 * xerox eyes start bleeding
02:00:37 <dons> well, -p is doing an 'interact'
02:00:46 <dons> so i suppose you could add an 'interact' switch to ghc
02:00:48 <jer> haskell is good at obfuscating whole programs (though not intentionally) =D
02:01:08 <dons> and then plugin in some spooky banana lensed barb wire operators
02:01:45 <dons> http://www.cse.unsw.edu.au/~dons/crawl/crawl.hs 
02:01:46 <dons> :)
02:06:51 <xerox> dons - Eeeek! \(!) -> .. <interrobang>
02:08:34 <Lemmih> mnislaih: It's best to avoid cyclic imports if possible, imo.
02:22:34 <shemale_magic> so haskell is new and improved c
02:22:39 <shemale_magic> better than perl?
02:22:45 <shemale_magic> Im sick of my boss
02:23:03 <Paltas> shemale_magic: heh haskell can't be compared to imperative languages. :)
02:23:07 <Paltas> imho.
02:23:25 <mauke> haskell is both better and worse than perl
02:23:44 <Paltas> well it's two different types of languages, you can't compare..
02:23:54 <mauke> I can
02:24:03 <Paltas> like comparing prolog and haskell you can't do either
02:24:23 <mauke> only because I don't know prolog
02:24:28 <Paltas> prolog is good for combinatorics, haskell ain't..
02:24:50 <Paltas> i choose a language for the computational problem.. 
02:25:14 <Paltas> If i should solve a optimization problem i would rather use prolog than any other language
02:27:08 <dons> or one of the many prologs written in haskell , perhaps ;)
02:28:18 <earthy> it is almost trivial to do a prolog in haskell
02:28:53 <dons> hence prolog < haskell ;)
02:29:10 <Paltas> dons: prove it :)
02:29:17 <dons> there's even a prolog in the ghc testsuite
02:30:02 <dons> well, you can implement a prolog in haskell (indeed, there's many, and it'd even be possible on the type level), but there's no haskells implemented in prolog.
02:30:35 <Paltas> ofcourse not.. why should there be?
02:30:59 <dons> anyway, i think everyone here's of the view that you choose the tool for the problem 
02:31:15 <Paltas> doesn't make sense, imho programmers should choose language by purpose.. not just because they like a language...
02:31:31 <dons> yeah, i was agreeing :)
02:31:39 <JKnecht> pure prolog is one thing, a good solid production level implementation of practical prolog is quite another.
02:31:42 <Paltas> :-)
02:32:31 <Paltas> afair does gprolog provide a lib. so you can start the interpreter from some C code..
02:32:36 <dons> if only people did choose the language for the purpose, there'd be far more compilers written in haskell
02:32:58 <Paltas> never really got into it but could be quite exciting. :)
02:33:06 <dons> and a lot less perl code, sigh. 
02:33:49 <Paltas> btw i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something, since he could get that mad idea
02:34:14 <dons> hehe
02:34:23 <dons> that's a good summary of the discussion here on the same topic :)
02:34:43 <dons> @remember Paltas i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
02:34:43 <lambdabot> Done.
02:34:46 <dons> @quote
02:34:46 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
02:34:49 <dons> @quote Paltas
02:34:49 <lambdabot>  i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
02:35:36 <Paltas> :-)
02:36:31 <Paltas> map, filter is okey to remove, they are easy to make by using list comprehension, but removing lambda functions and reduce seems really stupid.. :S
02:36:53 <Paltas> yet another reason to stick with haskell :))
02:38:58 <dons> yeah, considering map/reduce or lambda are kinda... umm ... fundamental
02:39:23 <Paltas> right! :)
02:40:11 <bdash> reduce is very rarely used in Python code in my experience
02:41:14 <Paltas> yep but the only way to do something like fold.. 
02:44:27 <u221e> Damn, I have another error I can't figure out...
02:45:17 <dons> ?paste
02:45:17 <lambdabot> http://paste.lisp.org/new/haskell
02:47:32 <u221e> Heh, the moment I come I I find the error
02:49:16 <MarcWebe1> I'm getting this error when compiling missingh http://rafb.net/paste/results/M7CaJk90.html Any idea what is causing this?
03:43:17 <Arnia> Ok... using the WxHaskell .dmg and GHC 6.4 for OSX (PowerPC) I get all manner of opcode errors when I try and use WxHaskell
03:43:30 * shapr boings
03:43:43 <Arnia> I'm using a MacBook, but I can't get WxHaskell to compile either
03:44:21 <ozone> Arnia: it has compatibility problems with gcc 4, iirc
03:44:30 <shapr> g'day ozone
03:44:39 <ozone> hey shapr
03:44:44 <Arnia> Yeah, I try switching to gcc 3.3 and I get a missing program error
03:45:04 * Arnia sends shapr a badger courtesy of Monty
03:45:24 <ozone> you can't, gcc 3.3 isn't available for the intel macs
03:45:28 <ozone> it's only for cross-compiling to ppc
03:46:04 <noj> Arnia, check out http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
03:46:06 <lambdabot> Title: "X86OSXGhc - GHC - Trac"
03:46:10 <ozone> you'll probably need to update the header files that wxeiffel produces
03:47:23 <Arnia> ozone: WxEiffel is used?
03:48:05 <ozone> afaik wxhaskell uses the bindings created by wxeiffel
03:48:09 <ozone> not entirely sure though
03:48:34 <ozone> i don't have enough space to install GHC on my mac yet, so it's hard for me to test it :)
03:48:47 <Arnia> Fair enough :)
03:49:08 * Arnia is working on an interpreter for a new language
03:49:35 <Arnia> Want to use Haskell, but need it to be possible to write decent GUI bindings :)
03:49:44 <shapr> gtk?
03:50:22 <Arnia> shapr: Whatever Wx binds to atm
03:50:29 <Arnia> (assuming I can get it to run)
03:53:13 <Arnia> shapr: So what are you up to these days?
04:30:53 <roconnor> woot, I've made a Cabal package.
04:56:00 <Arnia> Hngh... wxcore/src/Graphics/UI/WXCore/IntMap.hs:188:0: Not in scope: `!'
04:56:22 <dons> @hoogle (!)
04:56:23 <lambdabot> Did you mean: (!)
04:56:23 <lambdabot> Prelude.undefined :: a
04:56:23 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
04:56:30 <dons> yes, hoogle, I meant !
04:56:36 <dons> @hoogle !
04:56:36 <lambdabot> Array.(!) :: Ix a => Array a b -> a -> b
04:56:36 <lambdabot> Prelude.! :: keyword
04:56:36 <lambdabot> Data.Array.(!) :: Ix i => Array i e -> i -> e
04:56:48 <dons> keyword? 
04:56:51 <Arnia> dons: That module defines (!)
04:56:52 <dons> ndm ^^ what's all this then?
04:56:57 <dons> Array
04:57:11 <dons> @index (!)
04:57:12 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
04:57:27 <Arnia> That (!) is not in scope error occurs with the typedecl: (!) :: IntMap a -> Key -> a
04:57:39 <dons> something's borked
04:57:45 <dons> perhaps a missing 'import qualified'?
04:58:05 <Arnia> dons: This is wxhaskell's slightly modified IntMap implementation
04:59:44 <Arnia> I don't entirely understand why the error is being thrown?
05:22:20 <Arnia> Ok, next stage... figure out why I'm now getting 'unknown package wx-0.9.4' errors when the package is listed when I do ghc-pkg list
05:31:06 <dons> missing -package wx ?
05:32:12 <Arnia> dons: Nope... that line is there
05:41:17 <shapr> Arnia: Still Python mostly.
05:41:34 <P4W3R> freaks
05:41:40 <P4W3R> XD
05:43:03 <shapr> k
05:43:52 * Arnia wonders if he is cursed to not get wxhaskell working :)
05:44:06 <xerox> ?where gtk2hs
05:44:07 <lambdabot> http://haskell.org/gtk2hs/
05:44:09 * xerox whistles
05:44:21 <Arnia> Can't get GTk running either
05:44:24 <Arnia> So that's no help :P
05:44:26 <Arnia> ;)
05:44:32 <xerox> :(
05:54:08 <roconnor> how does one contribute to Hackage?
05:54:52 <Lemmih> roconnor: With a package or patches?
05:54:59 <roconnor> package
05:55:06 <roconnor> or is it still too beta
05:55:50 <roconnor> Now that I have cabalized FewDigits, putting it in Hackage would seem to be the next logical step, should I choose to take it.
05:56:18 <Lemmih> You'd need an account on darcs.haskell.org.
05:56:44 <roconnor> actally FewDigits is sort of dumb, so I might not want to put it there.
05:57:45 <roconnor> Hmm, not so many packages listed.
05:58:20 <u221e> How do you add an item to the end of a list?
05:58:32 <roconnor> ++
05:58:40 <roconnor> ++[a]
05:58:55 <roconnor> \a -> (++[a])
05:59:01 <roconnor> @pl \a -> (++[a])
05:59:01 <lambdabot> flip (++) . return
05:59:52 <roconnor> O(n)
06:00:32 <roconnor> don't run it in a loop
06:00:56 <xerox> ...or use a different data structure. snoc snoc.
06:01:22 <roconnor> xerox: who's there?
06:01:24 <mauke> type ListBuilder a = [a] -> [a]
06:01:51 <mauke> newBuilder = id
06:02:03 <mauke> toList = flip id ""
06:02:07 <mauke> er, []
06:02:12 <vininim> o_O
06:02:40 <mauke> concatBuilder = (.)
06:03:27 <vincenz> dcoutts: ping
06:03:40 <xerox> mauke - What's that for?
06:03:50 <vincenz> @tell dcoutts Would you know why I would get a lot of link errors for jpg and png stuff when 'making' an application that uses gtk2hs?
06:03:50 <lambdabot> Consider it noted.
06:03:54 <mauke> it's a list builder
06:04:04 * vincenz disconnects and goes to present his poster 
06:04:05 <mauke> with O(1) append
06:05:27 <roconnor> consBuilder x y = (x:) . y
06:05:42 <roconnor> snocBuilder x y = y . (x:)
06:06:07 <roconnor> return x = (x:)
06:07:28 <roconnor> He's running it in a loop isn't he...
06:07:33 * roconnor worries
06:08:48 <u221e> You mean me?
06:09:56 <roconnor> yep
06:10:29 <roconnor> er, sorry for making assumptions about your gender
06:10:49 <roconnor> Infinity is sort of a gender neutral name.
06:10:53 <u221e> Yes, a very large one
06:11:44 <roconnor> is there a wiki page for teaching how to correctly deal with situations when you want to append to lists?
06:12:05 <roconnor> the simplest solution is to reverse the list, prepend all your data, and reverse at the end.
06:13:27 <Arnia> hum... is there a package called concurrent?
06:13:46 <roconnor> a better solution is to use mauke's data structure.
06:14:06 <tony3> what about using data.sequence?
06:14:44 <roconnor> and the best solution is usually there is a way to generate your list recursively correctly all at once, after some careful thinking.
06:17:02 <tony3> what is the standard way to make several IO actions atomic, as in not inturrupted by a context switch, do I have to use an MVar?
06:17:41 <tony3> or is there some kind of blocking function?
06:17:55 <roconnor> @type atomic
06:17:56 <lambdabot> Not in scope: `atomic'
06:18:02 <roconnor> @hoogle atomic
06:18:03 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
06:18:03 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
06:18:03 <lambdabot> Foreign.C.Types.CSigAtomic :: data CSigAtomic
06:18:22 <roconnor> GHC.Conc.atomically
06:18:37 <roconnor> well, that works for memory reference
06:18:48 <tony3> thats for software transactional memory,
06:18:50 <tony3> which prohibits IO
06:19:01 <eivuokko> And it repeats on conflicts.
06:19:13 <roconnor> hmmm
06:19:20 <roconnor> is there a way to do it in C?
06:19:39 <eivuokko> Can't usually block OS-level context switch at user level.
06:20:25 <tony3> So I have to use an MVar as a lock then I guess.
06:20:35 <roconnor> sounds like it defeats the purpose of peremptive multitasking
06:21:26 <roconnor> ah, you are trying to make a transaction.
06:21:37 <roconnor> ghc implements its own threading right?
06:21:54 <roconnor> in principle it would be possible to stop switches to other ghc threads at the user level?
06:21:55 <tony3> yes I suppose I am trying to make a transaction.
06:21:58 <eivuokko> It has both, multiple OS-threads and user level threads.
06:22:12 <eivuokko> tony3, if you just need same OS-thread, maybe you bould use bound threads.
06:22:26 <roconnor> persumally tony3 is using only user level threads.
06:23:20 <tony3> I am using -threaded, so I'm using OS threads also.
06:23:26 <roconnor> oh
06:23:39 <roconnor> welcome to locking hell :)
06:23:41 <eivuokko> Well, even with just user level threads, bound threads are needed.  Consider calling a function and reading errno.
06:23:42 <tony3> For blocking ffi calls,
06:23:59 <eivuokko> (Although errno is magic in ghc rts)
06:24:24 <mux> locking is overrated, it's not that hard :)
06:24:51 <tony3> mux depends how many resources you have locks for....
06:25:02 <mux> the FreeBSD kernel has many ;-)
06:25:04 <roconnor> mux: locking is the easy part.  avoiding deadlock is harder.
06:25:21 <roconnor> I'd say not humanly possible.
06:25:41 <roconnor> up there with memory management
06:25:41 <mux> sissy!
06:25:53 <roconnor> not sure which is worse
06:26:01 <roconnor> mux: that's why I use haskell ;)
06:26:05 <mux> heh.
06:26:06 <mux> fair enough :D
06:26:45 <mux> that makes me think, we should implement RCU in the FreeBSD kernel one of these days
06:26:46 <roconnor> I'd be inclined to make sure at most one thread can ever touch a file.
06:26:54 <neologism> roconnor: there are formalisms to avoid deadlock
06:27:01 <mux> now *that* is more complicated than mutexes, shared/exclusive locks, condition variables and semaphores
06:27:18 <roconnor> @what RCU
06:27:18 <lambdabot> I know nothing about rcu.
06:27:26 <sieni> read copy update
06:27:31 <mux> @google read-copy-update
06:27:33 <lambdabot> http://lse.sourceforge.net/locking/rcupdate.html
06:27:33 <lambdabot> Title: "Read-Copy Update Mutual Exclusion for Linux"
06:27:45 <roconnor> hands up who orders all their resourses when using locks
06:27:47 <mux> the original paper is very interesting.
06:28:05 <mux> that page is only a summary
06:29:36 <mux> roconnor: RCU is interesting for data structures that are read much more often than written; it delays writes until the kernel knows for sure that noone else has references (in the semantic sense) to the data structure
06:29:49 <mux> the paper calls that quiescent states IIRC
06:30:17 <tony3> hPutBuf will always be atomic right? If so I guess I could maintain an IO buffer in a TVar, and use atomically on that, then some poke calls........
06:30:33 <mux> it allows completely lockless reading on UP, and requires only a critical section on SMP (for reading too of course)
06:30:56 <mux> but it requires a fair deal of code and instrumentation to work
06:31:03 <roconnor> nifty
06:31:32 <tony3> hPutBuf will call posix write, if so does that mean it will block until completion?  
06:31:43 <mux> until completion or error
06:31:49 <mux> write() is atomic per POSIX
06:32:18 <tony3> aha, good, ok......
06:32:45 <mux> actually, RCU might require critical sections for reading on UP too, so as to avoid preemption, I'm not so sure about it
06:32:52 <mux> it's been some time since I last read this paper
06:33:26 <roconnor> wow, write() is atomic?
06:33:31 <roconnor> how big can the buffer be?
06:34:43 <mux> that's where problems begin :-)
06:34:53 <mux> you specify the size of a size_t, but write() returns a ssize_t
06:34:55 * mux hearts POSIX
06:35:17 <eivuokko> I'm not sure at all that hPutBuf is atomic - never seen anything claim so.
06:35:23 <mux> so it's probably safe to assume you can write 2^(sizeof(ssize_t)*8) at most
06:35:30 <mux> err
06:35:31 <mux> -1
06:35:37 <mux> you get the point (I thinkà
06:35:42 <mux> gah, I just can't type
06:35:46 * mux goes to have some more coffee
06:37:09 <roconnor> we need to write a hPutBuf race condition.
06:38:11 <eivuokko> Even if passes now, it doesn't mean it will everywhere.
06:38:24 <roconnor> hmmm
06:40:31 <tony3> hmm, indeed.
06:41:44 <mux> aaah, coffee.
06:42:02 <eivuokko> Fwiw, if I needed to build transactions on top of OS-services, I'd probably write my own ffi-imports (or use existing) and write the logic on using those.
06:59:57 <pejo> mux, doesn't IBM have a patent that covers RCU?
07:07:40 <offby1> can someone point me to the simplest possible example (ideally just two or three lines) that demonstrates 1) creation of a hash table; 2) inserting an element into it; and 3) retrieving an element from it?  I can't seem to find any such thing.
07:08:04 <JKnecht> pejo: if so it can safely be ignored.
07:11:04 <neologism> any native english spekaer here?
07:13:49 <xerox> > M.singleton 1 "offby1" :: M.Map Int String
07:13:50 <lambdabot>  {1:="offby1"}
07:15:20 <xerox> > let m = M.singleton 1 "offby1" in M.insert 2 "xerox" m :: M.Map Int String
07:15:21 <lambdabot>  {1:="offby1",2:="xerox"}
07:16:55 <xerox> > let m = M.fromList [(1,"offby1"),(2,"xerox")] in m M.! 1
07:16:56 <lambdabot>  "offby1"
07:17:03 <Cale> heh, from Wikipedia: "If B is contained in A, then every problem in B is also in A, and so a type of machine that can solve all problems in A can solve all problems in B."
07:17:18 <xerox> ?docs Data.Map
07:17:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
07:17:26 <xerox> ^- for more insights, offby1 
07:17:37 <Cale> That is, and the department of redundancy department.
07:22:10 * Arnia recompiles
07:24:11 <offby1> xerox: thanks, I'll try it
07:25:11 <offby1> xerox: I read the docs, but I couldn't figure out how to instantiate one.
07:27:20 <offby1> neologism: yes, I'm a native English speaker
07:29:04 <offby1> xerox: could you show me _precisely_ what to type into ghci to try out your first example?
07:30:07 <pejo> JKnecht, how so?
07:37:20 <JKnecht> pejo: because it's a fundamental technique whose patent if granted would be unenforcible, especially by IBM
07:40:42 <Philippa_> it doesn't really work like that - in practice you have to be able to afford to fight the patent, and it's liable to be granted after minimal inspection in the US
07:46:39 <kpreid> offby1: either first do :m + Data.Map and remove the "M.", or replace it with "Data.Map."
07:46:52 <offby1> kpreid: got it; thanks
07:46:57 <mnislaih> Lemmih: ping
07:47:04 <kpreid> offby1: lambdabot evaluates in an environment including "import Data.Map as M", and you can't express that in ghci
07:47:14 <offby1> ah
07:47:38 <sjanssen> actually, import qualified Data.Map as M
07:47:44 <kpreid> er, yes
07:47:58 <mnislaih> @tell Lemmih to send me the fix for rnExpr breakpoint code
07:47:58 <lambdabot> Consider it noted.
07:49:13 <xerox> offby1: write an Haskell module containing "module Foo where\nimport qualified Data.Map as M\n" and :load it.
07:53:15 <JKnecht> phillipa: right; I'm saying that IBM would be unlikely to try to enforce such a patent except perhaps in a specific counteraction.
07:54:09 <Philippa_> IBM specifically might be, but slightly smaller companies are more likely to do so against smaller competitors
07:55:06 <JKnecht> agreed. (that 1 such might try, success on an intl. scale more problematic)
07:55:42 <JKnecht> (read: 'flat out impossible')
07:55:52 <offby1> xerox: got it, thanks
07:55:59 <xerox> offby1: you're welcome!
07:56:33 <Philippa_> depends what counts as success
07:56:52 <Philippa_> often you don't need international-scale success with it anyway though
07:57:04 <JKnecht> keeping others from using the technique in any form
07:57:06 <xerox> How's your Haskell journey coming along, offby1 ?
07:58:02 <Philippa_> see, I don't think that's it. I think success is being able to hamper the business of your competitors
07:58:07 <u221e> WHat would be the best and fastest way to make a ByteString out of a very large number of Word8s?
07:58:18 <Philippa_> in this particular case, the patent's clearly there purely for the purpose of harassment
07:59:24 <sjanssen> u221e: where are you getting the Word8s?
07:59:53 <sjanssen> ByteString has it's own IO, so use that if possible
07:59:57 <u221e> I'm generating them.
08:00:00 <JKnecht> right, and this runs counter to IBM's current overall current strategy. Would as you say make sense for some small captial formation operating entirely in some national jurisdiction.
08:00:16 <sjanssen> u221e: can you use ByteString.unfoldr?
08:00:33 <sjanssen> unfoldrN if you know how many Word8s you'll generate
08:02:27 <shapr> Silly question, can several wifi cards talk amongst themselves without requiring an accesspoint?
08:02:36 <shapr> Or is it like 10BaseT where you have to have a central hub?
08:02:42 <Arnia> shapr: ad-hoc mode
08:02:46 <u221e> unfoldr... interesting.
08:03:05 <woggle> shapr: Ad-hoc mode and some wifi cards can act as an accesspoint.
08:03:05 <offby1> xerox: it's coming very slowly.  There's a lot to learn.
08:03:45 <shapr> woggle: That'll let me NAT a bunch of computers in my apartment through my desktop, yeah? I can't think of any reason it wouldn't but it's always better to ask...
08:05:30 <mux> pejo: there has been legal issues with RCU indeed, but I *think* there are ways around it
08:05:44 <mux> pejo: not sure at all though
08:05:52 <mux> but many other OSes have something similar to RCU
08:06:21 <shapr> Arnia: Do you know if I can use ad-hoc mode to nat a bunch of computers through my desktop to the 'net?
08:07:20 <Arnia> shapr: yes you can...
08:07:40 <Arnia> shapr: Just need to forward the connection from the ad-hoc network
08:09:51 <shapr> spiffy
08:09:58 <xerox> offby1: feel free to ping me directly if you need informations anytime.
08:11:07 * Arnia wonders if he'll have to compile again
08:11:29 <offby1> xerox: thanks
08:11:51 * ihope loves these compile-time stack overflows
08:12:14 <vincenz> l
08:12:16 <vincenz> lo
08:12:21 <vincenz> @seen dcoutts
08:12:21 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I don't know when dcoutts last spoke.
08:14:13 <ihope> Hmm, maybe GHC isn't recognizing the .h file.
08:14:54 <ihope> It seems to be ignoring it completely.
08:16:44 <mauke> argh, what's going on here: Chasing modules from: scripts/BotPP.hs ... Could not find module `Data.ByteString.Char8'
08:17:54 <Lemmih> mauke: Using Cabal?
08:17:54 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
08:18:15 <jgrimes_> mauke: do you have the ByteString library installed?
08:18:31 <mauke> I think so, I have this thing called fps
08:18:39 <jgrimes_> yeah, thats it
08:19:31 <mauke> wait, this package.conf looks broken
08:26:41 <jgrimes_> do any of you know of any two dimensional cellular automata simulations?
08:26:50 <jgrimes_> written in haskell, of course
08:27:41 <mauke> pugs broke my fps :(
08:30:59 <xerox> mauke: same here :|
08:32:19 <kpreid> @pl \x -> ((!!) . (x !!))
08:32:20 <lambdabot> ((!!) .) . (!!)
08:36:17 <dmhouse> Hey kowey.
08:41:40 <kowey> hi dmhouse! hi all
08:43:23 <ihope> @pl \x -> x . x . x . x . x
08:43:24 <lambdabot> ap (.) (ap (.) (ap (.) (join (.))))
08:43:47 <xerox> fd:6: hClose: resource vanished (Broken pipe)
08:43:54 <ihope> @pl \x -> (\y -> y x) (\y -> y x)
08:43:54 <lambdabot> flip id `ap` flip id
08:44:04 <xerox> Anybody experienced this while trying to use lambdabot's eval plugin locally?
08:45:50 <dmhouse> :) wb
08:46:09 <xerox> dmhouse: any idea? :)
08:46:11 <kowey> sorry dmhouse, seems lab had lost connection to the rest of the world
08:46:14 <kowey> :-)
08:46:26 <dmhouse> xerox: Sorry, I haven't used lambdabot's eval recently.
08:46:34 <dmhouse> xerox, Why _are_ you using it locally?
08:46:35 <xerox> Mumble.
08:46:42 <xerox> Because it is fast :-)
08:46:48 <dmhouse> So's GHCi :)
08:46:55 <xerox> But.. but..
08:47:17 <dmhouse> You can install Hoogle locally, integrate it with GHCi, and then there's not much use for a local lambdabot.
08:47:22 <dmhouse> IMO.
08:47:31 <u221e> If a functions returns a tuple, how do you extract one element to pass to a second function?
08:47:50 <xerox> It is especially cool since it comes with hoogle, djinn, & all the sweeties.
08:47:52 <dmhouse> fst and snd if it's a pair, otherwise pattern matching.
08:48:04 <dmhouse> djinn's useless. Hoogle you can install.
08:48:09 <u221e> I knew it was simple, thanks.
08:48:22 <xerox> dmhouse: I have just built it via cabal, and ran it. '> 2+2' raises that exception.
08:49:34 * dmhouse is building gtk-emacs. It's in emacs CVS now, so hopefully it crashes less.
08:49:39 <dmhouse> xerox, sorry, I don't know.
08:49:47 <kpreid> @pl \f is js -> map (\x -> map ($ x) (map f is)) js
08:49:47 <lambdabot> ((map . flip (map . flip id)) .) . map
08:49:49 <dmhouse> xerox, I'll try to update my lambdabot, see if I get those errors.
08:50:44 <dmhouse> Oh yeah, my lambdabot repo's broken. My computer crashed whilst I had darcs open on it, so now any darcs invocation on that dir waits forever for the lock file to free up.
08:51:37 <dmhouse> Gah.
08:51:44 * dmhouse wonders how to fix that
08:52:49 <Philippa_> I imagine by killing the lock file by hand?
08:53:04 <Philippa_> but do it to a copy, not the original
08:53:12 <dmhouse> Ooh, that might work.
08:54:05 <xerox> ?help url
08:54:05 <lambdabot> url <key>. Return element associated with key
08:54:09 <xerox> What's that.
08:54:16 <dmhouse> ?url haddock
08:54:16 <lambdabot> http://www.haskell.org/haddock/
08:54:21 <dmhouse> ?where haddock
08:54:21 <lambdabot> http://www.haskell.org/haddock/
08:54:25 <dmhouse> ?help where
08:54:25 <lambdabot> where <key>. Return element associated with key
08:54:29 <xerox> I knew where.
08:55:08 <dmhouse> Philippa_: cp'ing didn't work, I think I'll rm it and touch it.
08:55:24 <dmhouse> Although I have a feeling that that won't work either, I think the _filename_ is locked somehow.
08:55:33 <xerox> How is it called the '> ..' plugin?
08:55:36 <dmhouse> So I'll need to remove the filename from some lock file that darcs has.
08:55:40 <xerox> ?help eval
08:55:40 <lambdabot> eval. Do nothing (perversely)
08:55:49 <xerox> It doesn't seem to be this one.
08:55:49 <dmhouse> xerox, 'What is the '> ...' plugin called'. @run.
08:56:06 <xerox> ?help run
08:56:06 <lambdabot> run <expr>
08:56:06 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
08:56:19 <xerox> Oh, it hangs my lambdabot here.
08:56:43 <xerox> If it runs over runplugs the problem is that I don't have hs-plugins, I fear.
08:58:40 <xerox> ./Plugin/Eval.hs:24:binary = "./runplugs"
08:58:49 <xerox> Seems so.
08:58:57 <xerox> hs-plugins to the resque!
08:59:24 <dmhouse> 'rescue'. </pedantics> :) (Sorry.)
08:59:45 <xerox> :-|
09:00:15 <dmhouse> @wb rescue
09:00:18 <lambdabot> *** "rescue" wn "WordNet (r) 2.0"
09:00:18 <lambdabot> rescue
09:00:18 <lambdabot>    n : recovery or preservation from loss or danger; "work is the
09:00:18 <lambdabot>      deliverance of mankind"; "a surgeon's job is the saving
09:00:18 <lambdabot>      of lives" [syn: {deliverance}, {delivery}, {saving}]
09:00:20 <lambdabot>    v 1: free from harm or evil [syn: {deliver}]
09:00:22 <lambdabot>    2: take forcibly from legal custody; "rescue prisoners"
09:02:48 <dmhouse> xerox: Did dons apply my ASCII art patch to the README?
09:03:01 <xerox> Yeah :)
09:03:08 <dmhouse> Awesome :)
09:03:22 <xerox> You have misconfigured your personal data by the way.
09:03:30 <dmhouse> Why?
09:03:31 <dmhouse> How?
09:04:11 <xerox> You appear as 'david <something@localhost.localdomain>'.
09:04:43 <dmhouse> Hrm.
09:07:27 <offby1> what's the haskell equivalent of Lisp's "every", "some", or "any" ?
09:07:42 <dmhouse> What do those functions do?
09:07:46 <offby1> i.e., [a] a -> Bool -> Bool
09:07:50 <xerox> > any even [1..10]
09:07:51 <lambdabot>  True
09:07:58 <offby1> (every odd? ' (1 3 5)) is tru
09:08:01 <offby1> (every odd? ' (1 3 5 6)) is false
09:08:05 <xerox> > all (>1) [2..5]
09:08:06 <lambdabot>  True
09:08:07 <dmhouse> every = all
09:08:09 <offby1> thanks
09:08:14 <dmhouse> any = any
09:08:20 <dmhouse> I don't know what 'some' does.
09:08:24 <sjanssen> @type let any = any
09:08:26 <lambdabot> not an expression: `let any = any'
09:08:31 <xerox> forall a. a
09:08:43 <xerox> ?type let any = any in any
09:08:44 <lambdabot> forall t. t
09:08:54 <sjanssen> thank you, xeroxbot ;)
09:08:58 <xerox> Now, if only I could build hs-plugins...
09:09:01 <xerox> My duty!
09:11:41 <xerox> src/AltData/Typeable.hs:452:0:
09:11:41 <xerox>     parse error (possibly incorrect indentation)
09:13:25 <xerox> No Typeable.h, while the comments say it needs it...
09:15:13 <xerox> Oh. It is distributed with ghc-6.4
09:15:34 <xerox> Anybody with 6.4 can upload/paste Typeable.h somewhere? It is not distribuited anymore with 6.5.
09:16:36 <Daveman> xerox :D
09:17:05 <xerox> Got it from the web, nevermind.
09:17:09 <xerox> Howdy Daveman :)
09:17:14 <Daveman> Howdy :)
09:17:32 <Daveman> heh heh, xeroxbot :P
09:17:40 <xerox> (:
09:20:11 <xerox> No -package posix on os x? Eck.
09:21:44 <sjanssen> xerox: it's -package unix over here
09:23:50 <dmhouse> -package? Pfft. --make, please. :)
09:24:10 <sjanssen> at least, 6.4.2 on Linux has both the unix and posix packages, where 6.5 on OS X has only posix
09:27:04 <xerox> --make makes it compile in fact :-)
09:28:22 <xerox> make check  ==>  failed with: -453973694165307953197296969697410619233826
09:28:24 <xerox> Aww :)
09:30:18 <offby1> how would I combine the function + with the list [1,2,3] to get 6?  i.e., what's the haskell equivalent of lisp's "apply" ?
09:30:29 <xerox> > sum [1,2,3]
09:30:30 <lambdabot>  6
09:30:31 <sjanssen> > sum [1, 2, 3]
09:30:32 <lambdabot>  6
09:30:34 <offby1> thanks.
09:30:38 <sjanssen> > foldl (+) [1, 2, 3]
09:30:39 <lambdabot>  add an instance declaration for (Num [a])
09:30:43 <xerox> > foldr (+) 0 [1,2,3]
09:30:44 <lambdabot>  6
09:30:55 <kpreid> offby1: APPLY in general does not exist in Haskell
09:30:59 <dmhouse> offby1: In general, you'll want a fold.
09:31:06 <kpreid> offby1: fold is what CL calls REDUCE
09:31:07 <Paltas> > foldl1 (+) [1,2,3]
09:31:08 <lambdabot>  6
09:31:12 <Paltas> :-)
09:31:21 <jgrimes_> anyone know of any two dimensional cellular automata simulators written in haskell?
09:31:30 <dmhouse> offby1: http://en.wikibooks.org/wiki/Haskell/List_Processing#Folds
09:31:40 * xerox was writing one times ago
09:31:47 <kpreid> jgrimes: I don't, but I'm writing one right now because it sounded interesting when you asked.
09:32:04 <int-e> Paltas: that doesn't work for empty lists though. foldl (+) 0  (actually, foldl' (+) 0) is better.
09:32:07 <jgrimes_> yeah, thats why I was considering writing one
09:32:10 <dmhouse> jgrimes_: I wrote the game of life in Haskell, but it doesn't exactly utilise any nice techniques for the automata.
09:32:58 <Paltas> int-e: Right. :) but i'm just used to then creating functions checking for empty lists, so not really a big issue for my programs.. :)
09:33:19 <sjanssen> > foldr (+) 0 [1..1000000]
09:33:20 <lambdabot>  Exception: stack overflow
09:33:27 <sjanssen> > foldl' (+) 0 [1..1000000]
09:33:28 <lambdabot>  500000500000
09:33:52 <dmhouse> When does a right-fold provide better performance?
09:33:55 <jgrimes_> yeah. I got to thinking about it and it would be really easy to write the rules system using hs-plugins and just hiding everything but the few things you need to define rules.
09:34:03 <dmhouse> foldl is tail recursive and there's a strict version.
09:34:05 <sjanssen> dmhouse: foldr allows you to consume the result lazily
09:34:43 <dmhouse> sjanssen: Could you give an example of where a right-fold would be better?
09:35:04 <int-e> > take 10 $ foldr (++) [] [[a] | a <- [1..]]
09:35:05 <sjanssen> > foldr mplus Nothing (Just 3 : repeat Nothing)
09:35:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:35:06 <lambdabot>  Just 3
09:35:12 <sjanssen> > foldl mplus Nothing (Just 3 : repeat Nothing)
09:35:14 <int-e> > take 10 $ foldl (flip (++)) [] [[a] | a <- [1..]]
09:35:19 <lambdabot> Terminated
09:35:20 <lambdabot> Terminated
09:36:02 <int-e> > take 10 $ foldl (++) [] [[a] | a <- [1..]]
09:36:06 <lambdabot> Terminated
09:36:07 <sjanssen> > foldr (&&) True (repeat False)
09:36:08 <lambdabot>  False
09:36:14 <sjanssen> > foldl (&&) True (repeat False)
09:36:18 <lambdabot> Terminated
09:36:22 <int-e> the flip was wrong actually, sorry.
09:36:23 <dmhouse> Infinite lists, then.
09:36:32 <int-e> dmhouse: or long lists
09:36:43 <dmhouse> 'Nearly infinite lists' :)
09:37:03 <sjanssen> dmhouse: any operator that is lazy in it's second argument stands to benefit
09:39:18 <dmhouse> Okay, which functions does Haskell have that are the 'listified' versions of an operator?
09:39:27 <dmhouse> sum, product, and, or, concat. Anything else?
09:40:06 <xerox> ?docs Data.List
09:40:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
09:40:35 <Cale> zip = zipWith (,)
09:40:48 <dmhouse> I meant specifically folds.
09:41:31 <dmhouse> maximum and minimum, perhaps, but they're not quite so easy.
09:41:34 <dmhouse> > maximum []
09:41:35 <lambdabot>  Add a type signature
09:41:42 <dmhouse> Okay, so they use fold*1.
09:42:21 <xerox> > foldl (\n x -> if x > n then x else n) 0 [1,2,10,3,-4,100,1]
09:42:22 <lambdabot>  100
09:42:41 <sjanssen> or foldl max undefined (which is equivalent
09:42:42 <xerox> > foldl (\n x -> if x < n then x else n) 0 [1,2,10,3,-4,100,1]
09:42:44 <lambdabot>  -4
09:42:48 <xerox> Ah, okay.
09:42:50 <dmhouse> > max 10 undefined
09:42:51 <lambdabot>  Undefined
09:42:54 <dmhouse> sjanssen: how is it?
09:43:03 <dmhouse> > foldl max undefined [1..10]
09:43:04 <lambdabot>  Undefined
09:43:18 <xerox> ?index maximum
09:43:18 <lambdabot> Data.List, Prelude
09:43:22 <dmhouse> > foldl1 max [1..10]
09:43:23 <lambdabot>  10
09:43:25 <xerox> ?fptools Data.List
09:43:25 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
09:43:31 <sjanssen> dmhouse: actually, they aren't equivalent
09:43:47 <xerox> maximum                 :: (Ord a) => [a] -> a
09:43:47 <xerox> maximum []              =  errorEmptyList "maximum"
09:43:47 <xerox> maximum xs              =  foldl1 max xs
09:43:53 <dmhouse> Yay. :)
09:44:07 <dmhouse> sjanssen: Because max is strict.
09:44:13 <sjanssen> I think that fold ought to be strict
09:44:28 <sjanssen> unless you want to count on strictness analysis to save you
09:44:31 <dmhouse> Yes, there are very few occasions where you need a lazy fold.
09:44:57 <sjanssen> dmhouse: there are very few occasions where you need a lazy *left* fold
09:45:04 <sjanssen> you almost always want lazy foldr
09:45:06 <dmhouse> Rgiht.
09:45:10 <dmhouse> *Right.
09:45:26 <dmhouse> > foldl (\x y -> if y > 5 then "yes" else x) undefined [1..6]
09:45:27 <lambdabot>  "yes"
09:45:30 <dmhouse> > foldl' (\x y -> if y > 5 then "yes" else x) undefined [1..6]
09:45:31 <lambdabot>  Undefined
09:45:37 <dmhouse> But that's somewhat contrived :)
09:46:10 <sjanssen> there is a good argument for swapping the names of foldl and foldl'
09:47:30 <int-e> can you distinguish  foldl f  from  foldr (flip f) . reverse ?
09:48:05 <xerox> > length "foldl f" == length "foldr (flip f) . reverse"
09:48:06 <lambdabot>  False
09:48:18 <xerox> That, and complexity :-)
09:48:47 <int-e> heh
09:48:56 <dmhouse> Sure.
09:48:58 <jgrimes_> for anyone interested I wrote an elementary cellular automata simulator, if anyone finds anything wrong or has suggestions let me know: http://marginalerror.com/entry/9
09:49:03 <dmhouse> No, never mind.
09:49:26 <dmhouse> You can distinguish between foldr f and foldl (flip f) . reverse.
09:49:31 <dmhouse> (Infinite lists.)
09:50:31 <int-e> yes. :)
09:54:16 <dmhouse> Today is a good day.
09:54:22 <dmhouse> Emacs with XFT fonts is working great :
09:54:23 <dmhouse> *:)
09:54:42 <jgrimes_> oo..
09:55:00 <jgrimes_> XFT fonts are nice
09:55:02 <vegai> better just use a good bitmap font...
09:55:16 <dmhouse> Dude. _Anti-aliasing_.
09:55:18 <largos> what are XFT fonts?
09:55:23 <largos> Oooh
09:55:24 <dmhouse> largos: Pretty ones.
09:55:31 <largos> do you have a screenshot?
09:55:40 <dmhouse> I'll cook one up.
09:56:23 <vegai> dmhouse: eugh ;/
09:57:20 <dmhouse> vegai: http://imagebin.org/5594
09:57:21 <lambdabot> Title: "Imagebin - A place to slap up your images."
09:57:30 <dmhouse> Ignore the grey background and crappy JPEG quality.
10:02:50 <largos> dmhouse: nice
10:04:31 <largos> dmhouse: is that running in windows?
10:05:56 <dmhouse> largos: Nope, Kubuntu.
10:06:55 * Cale wonders when freetype support will be in ordinary emacs packages
10:07:52 <dmhouse> Cale: This is in the branch that's going to become emacs-23.
10:08:10 <dmhouse> No extra patches needed, just a couple of arguments to configure, all well documented on the emacs wiki.
10:09:22 <Cale> I wonder if emacs-snapshot-gtk in Debian has those options on.
10:11:18 <largos> dmhouse: I like your color scheme -- could you post your .emacs somewhere?
10:11:31 <dmhouse> largos: Hehe, sure.
10:11:37 <Cale> hmm, it's upgrading cairo along with it, so maybe :)
10:12:00 <SamB> cairo?
10:12:02 <SamB> for text?
10:12:08 <SamB> sounds like overkill
10:12:15 <Cale> I have no idea what it's using cairo for
10:12:23 <dmhouse> Cale, You got it off a package?
10:12:38 <dmhouse> I had to get it from CVS, but I expected that.
10:13:06 <Cale> dmhouse: I'm trying the emacs-snapshot-gtk package.
10:13:09 <dmhouse> Ah.
10:13:24 <dmhouse> That's was an older version, last time I checked. It certainly works, but it's got a few bugs.
10:13:25 <jgrimes_> the new gtk uses cairo.
10:13:26 <vegai> dmhouse: http://vegai.ravissant.net/old-feb-22-2005/uniread-emacs.png
10:13:30 <vegai> dmhouse: bitmap font
10:13:33 <Cale> The version number is 20060707
10:14:25 <lisppaste2> dmhouse pasted "(custom-set-faces)" at http://paste.lisp.org/display/22413
10:14:29 <Cale> jgrimes_: right, but what in emacs would involve it?
10:14:57 <dmhouse> vegai: That's quite nice.
10:15:00 <largos> dmhouse: thanks
10:15:04 <dmhouse> vegai: I still prefer mine, though.
10:15:12 <dmhouse> largos: Are you using KDE?
10:15:27 <dmhouse> vegai: But I could certainly live with yours. Which font's that?
10:15:27 <largos> dmhouse: nope, fvwm
10:15:40 <jgrimes_> Cale: I haven't used gtk-emacs so I'm not really sure at all.
10:15:53 <vegai> dmhouse: the one in the shot is uniread. Terminus is another popular one
10:16:00 <dmhouse> largos: Ah, okay. Be sure to change the font name if you don't have that one installed on your system.
10:16:03 <dmhouse> vegai: Cool.
10:52:09 <edwardk> turns out that the arrow preprocessor does happen to reject more specialized bindings, so no sugar for me
10:56:35 <Lemmih> You're using Hugs?
10:56:44 <edwardk> actually that was ghc
10:57:31 <Lemmih> ghc doesn't use an arrow preprocessor. At least not any more.
10:57:36 <edwardk> well
10:57:45 <edwardk> the one thats in ghc that generates Core then 
10:57:46 <edwardk> =)
10:58:04 <edwardk> that one was being mean and not letting me replace Arrow with something more suited to my purposes
10:58:16 <edwardk> I am going to try a preprocessor next
10:58:57 <Lemmih> Replace the Arrow class?
10:58:57 <edwardk> i can stick to point-free arrow style, but the sugar is nice
10:59:00 <dmhouse> Lemmih: He was refering to the 'Rebinable syntax' part of GHC that lets you define, for example, your own (>>=) and return that do-blocks desugar to.
10:59:14 <dmhouse> Well, in this case, it was the arrowic functions and the arrowic sugar, but yeah.
10:59:33 <edwardk> yeah tried that, even with the options that let you rebind those functions it won't let me specialize the type signature
10:59:53 <tony3> I seem to recall reading somewhere that someone is working on a UTF8 bytestring, anyone know if that's true, if there is a darcs repo or tgz somewhere?
11:00:15 <edwardk> sjanssen i think, i don't think its up yet
11:00:17 <dmhouse> Isn't that sjanssen's SoC project?
11:00:37 <edwardk> was talking to him and dons about it the other day
11:00:49 <tony3> ah SoC, that was it.
11:01:41 <tony3> It has to be finished by the end of summer then presumably,
11:01:56 <dmhouse> Yep.
11:01:56 <tony3> did they say how it was coming along?
11:02:01 <dmhouse> sjanssen: ping?
11:02:33 <edwardk> he sounded upbeat, but thats about all i know =)
11:02:37 <tony3> cool,
11:02:57 <edwardk> i'm waiting on that and hsjudy
11:05:03 <tony3> as in judy arrays?
11:05:07 <edwardk> yeah
11:05:17 <edwardk> another soc project
11:05:58 <dmhouse> I'm looking forward to xerox's work on GHCi debugging.
11:07:02 <xerox> You mixed up things :-)
11:07:17 <edwardk> heh
11:07:17 * xerox cabal-gets.
11:07:28 <dmhouse> Right.
11:07:42 <dmhouse> I'm looking forward to two projects: xerox's, and that on GHCi debugging. :)
11:07:47 <dmhouse> And HaskellNet.
11:07:52 <xerox> :D
11:07:59 <xerox> http://code.google.com/soc/haskell/about.html
11:08:03 <lambdabot> Title: "Google Code - Google Summer of Code - Organization Information"
11:11:22 <jgrimes_> is (!!) O(n)?
11:11:32 <stepcut> Currently, in cabal, when you do, "./Setup.hs --enable-library-profiling ; ./Setup.hs build", it also builds the non-profiling versions. I plan to add a new flag --disable-library-non-profiling. Except, I need a better term than 'non-profiling' because, it is also 'non-parallel' and 'non-things-not-invented-yet'. Any ideas? --disable-library-default, --disable-library-standard ?
11:11:44 <Lemmih> jgrimes_: Of course.
11:12:11 <jgrimes_> Lemmih: ok.
11:12:31 <dmhouse> jgrimes_: If you want better performance, try Arrays or Maps. (!) is O(1) for both of those.
11:12:41 <xerox> --disable-library-non-profiling is rather confusing, imo.
11:12:41 <SamB> huh?
11:12:48 <jgrimes_> dmhouse: all right, I think I will
11:12:57 <SamB> O(1) for Maps?
11:13:01 <SamB> O(1) in what?
11:13:12 <Lemmih> dmhouse: Isn't it O(log n) for maps?
11:13:17 <xerox> Maybe IntMap?
11:13:24 <xerox> ?docs IntMap
11:13:24 <lambdabot> IntMap not available
11:13:28 <dmhouse> Oh, sorry.
11:13:38 <stepcut> xerox: yes, confusing and imprecise
11:13:47 <xerox> ?docs Data.IntMap
11:13:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
11:13:54 <dmhouse> jgrimes_: sorry, it's O(log n) for Maps.
11:14:05 <jgrimes_> dmhouse: still better than O(n) :)
11:14:10 <xerox> lookup :: Key -> IntMap a -> Maybe a
11:14:11 <xerox> O(min(n,W)). Lookup the value at a key in the map.
11:14:27 <xerox> (Same goes for (!).)
11:14:30 <jgrimes_> xerox: sounds good.
11:14:32 <dmhouse> If you want slightly-better-than-lists performance, try Data.Sequence, which has O(min(i, n-i)), where i is the requested index.
11:14:33 <Lemmih> stepcut: Is it for the dh_haskell thingy?
11:14:39 <sjanssen> lookup for IntMap is technically O(1)
11:14:55 <xerox> I would have thought so too.
11:15:10 <dmhouse> (And if we're talking amortized, (!!) is O(i), better that O(n).)
11:15:11 <stepcut> Lemmih: yes -- or anyone else who wants to split the profiling libraries into a seperate package
11:15:23 <jgrimes_> I think IntMap will work fine for what I need.
11:15:39 <stepcut> Lemmih: it is not dh_haskell or even debian specific problem
11:17:46 <stepcut> Lemmih: if you want to produce seperate, -dev, -prof, and -parallel packages, it is a lot easier if cabal will let you build each flavor separately
11:18:05 <stepcut> or at least into separate directory trees
11:18:16 <Lemmih> stepcut: Agreed.
11:19:28 <xerox> Maybe the flag wasn't *that* bad in the end.
11:19:31 <stepcut> but I am not sure what a good name for the vanilla version of the libraries is: --enable/disable--library--vanilla, --enable/disable--library--default, --enable/disable--library--standard, --enable/disable--library--plain
11:21:20 <lisppaste2> kpreid pasted "lazy infinite-field Life" at http://paste.lisp.org/display/22417
11:21:34 <kpreid> jgrimes_: you might find this interesting.
11:21:53 <kpreid> jgrimes_: it's what I wrote due to your question, and it's very different from what you wrote
11:22:11 <jgrimes_> kpreid: all right :)
11:22:18 <Lemmih> mnislaih: Greetings.
11:22:50 <mnislaih> ah Lemmih
11:22:55 <kpreid> jgrimes_: try "lshow 80 10 chain", for example
11:22:59 <bringert> shapr: hope supports PNG and GIF now
11:22:59 <xerox> vanilla sounds like a good name.
11:23:29 <xerox> Also keep in mind that the configure script also writes an explanation for the flags, if I am not mistaken.
11:24:11 <kpreid> jgrimes_: it's slower than O(iterations) because it's exploring more of the infinite empty field, which I intend to fix
11:24:35 <jgrimes_> kpreid: thats pretty cool
11:24:51 <stepcut> xerox: true
11:25:00 <jgrimes_> yeah, mine is just elementary automata, I hadn't got around into looking at 2d stuff
11:25:21 <xerox> Oh, I think arrays are a good choice for the automata problem.
11:25:52 <jgrimes_> bringert: something is breaking the CSS and keeping it from validating currently, though I haven't had a chance to investigate it yet
11:26:07 * xerox hugs bringert 
11:27:19 <bringert> jgrimes_: it looks like unescaped < in javascript
11:27:53 <bringert> now why does that happen?
11:28:32 * xerox will update hope!
11:28:41 <xerox> News on the FlatDB file, 'gert?
11:28:56 <bringert> ah, I use primeHtml for inline javascript. wonder why?
11:29:16 <bringert> xerox: just one small updated, added support for HaskellDB's new _in operator
11:29:40 <bringert> xerox: if you pull latest hope, you also need latest haskelldb and flatdb
11:30:01 <xerox> I think I didn't even modified the db the first time.
11:30:03 <bringert> and latests cgi is recommended, fixes a bug which affects image uploading from windows
11:30:16 * xerox will lose his db again
11:30:34 <bringert> xerox: I don't think you have to lose it
11:30:45 <bringert> xerox: use the DB migration program
11:31:11 <bringert> oh, and you also need to update the gd package, because of the new PNG and GIF stuff
11:31:19 * xerox takes notes
11:31:33 <vegai> why not just copy them?
11:31:42 <vegai> ah-hahhahah.
11:31:47 <xerox> I should get some designer friend to work on CSSes for hoe.
11:31:59 <bringert> that would be cool
11:32:37 <bringert> xerox: make sure that you are logged in when updating, since you will need to set your password after upgrading, because of the new MD5 password encryption
11:32:59 <xerox> That sound sane :-)
11:33:26 <the_lord> @hoogle a -> Maybe a
11:33:27 <lambdabot> Prelude.Just :: a -> Maybe a
11:33:27 <lambdabot> Data.Generics.Twins.gzip :: (a -> b -> Maybe b) -> a -> b -> Maybe b
11:33:27 <lambdabot> Data.FiniteMap.lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
11:33:55 <the_lord> Just "Hi"
11:33:58 <the_lord> > Just "Hi"
11:33:59 <lambdabot>  Just "Hi"
11:34:08 <the_lord> > (Just "Hi") ++ Nothing
11:34:08 <lambdabot>  Couldn't match `[a]' against `Maybe a1'
11:34:21 <bringert> jgrimes: there is a patch in darcs now for the validation problem. thanks for the report
11:36:13 <the_lord> > (Just "Hi") ++ (Just Nothing)
11:36:14 <lambdabot>  Couldn't match `[a]' against `Maybe a1'
11:36:49 <dmhouse> > liftM2 (++) (Just "Hi") (Just " world")
11:36:50 <lambdabot>  Just "Hi world"
11:36:55 <dmhouse> > liftM2 (++) (Just "Hi") Nothing
11:36:56 <lambdabot>  Nothing
11:37:24 <the_lord> @hoogle liftM2
11:37:25 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
11:37:25 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:38:48 <the_lord> dmhouse, I want (++) (Just "Hi") Nothing to return Just "Hi"
11:38:55 <the_lord> as if Nothing were ""
11:39:14 <dmhouse> the_lord: Try defining your own function to do that.
11:39:23 <dmhouse> Do it with pattern matching.
11:41:20 <the_lord> dmhouse, how do I redefine ++ for a specific datatype?
11:41:37 <dmhouse> the_lord: Don't.
11:41:43 <dmhouse> Write your own function.
11:41:50 <dmhouse> I.e., not (++).
11:42:19 <the_lord> dmhouse, ok, I'll try and see
11:43:13 <kpreid> the_lord: (concat . Maybe.catMaybes)
11:43:25 <dmhouse> kpreid: Shhh!
11:43:42 <dmhouse> kpreid: Interesting way of doing it, though.
11:44:08 <kpreid> sh? did I answer a homework question?
11:45:07 <dmhouse> kpreid: No, but it would have been beneficial for him to answer it regardless
11:45:26 * kpreid nods
11:45:31 <xerox> join . catMaybes hehe
11:47:59 <shapr> Shazam!
11:48:24 <shapr> What's the excitement today?
11:48:33 <shapr> SyntaxNinja: Hey, are you ever on GoogleTalk?
11:49:01 <kpreid> shapr, I just wrote http://paste.lisp.org/display/22417
11:49:02 * malcolm_ wonders what GoogleTalk is
11:49:21 <shapr> malcolm_: http://www.google.com/talk/
11:49:22 <lambdabot> Title: "Google Talk"
11:49:34 <shapr> malcolm_: It's like Skype but it uses jabber/xmpp instead.
11:50:04 <shapr> I'm trying to get all my skype-using friends to switch to Google Talk since I much prefer open standards.
11:51:05 <malcolm_> shapr: does Apple's iChat use jabber or xmpp protocols?
11:52:18 * malcolm_ can answer his own question with a web search :-)
11:53:12 <shapr> malcolm_: I don't know, does it?
11:53:30 <the_lord> @type "Hola"
11:53:31 <lambdabot> [Char]
11:53:34 <malcolm_> shapr: apparently it can do jabber, yes.
11:54:02 <malcolm_> Can jabber do video streams?
12:07:27 <bringert> shapr: hope has PNG and GIF support today
12:21:21 <vegai> is there something clever somewhere for doing simple string replaces, or do you guys write your own replace functions when needed?
12:21:41 <SamB> string replaces?
12:22:11 * SamB usually uses sed or search-replace-regexp
12:22:24 <vegai> in Haskell code
12:22:46 <vegai> so, Text.Regex?
12:23:06 <Cale> I suppose you could
12:24:00 <Cale> If you want a really nice Regex library, have a look at JRegex, it's pretty cool.
12:24:27 <Cale> @where JRegex
12:24:27 <lambdabot> http://repetae.net/john/computer/haskell/JRegex/
12:27:51 <Cale> hmm, but does it do replacements?
12:27:54 <Cale> I'm not sure
12:28:48 <sieni> why not cl-ppcre? ;-)
12:30:49 <dmhouse> Cale: nope.
12:40:29 <the_lord> @type ([Just "a", Just "b"] ++ [Nothing])
12:40:31 <lambdabot> [Maybe [Char]]
12:42:46 <the_lord> > [Just "a", Just "b"] ++ if True then [Nothing] else [Just "c"]
12:42:47 <lambdabot>  [Just "a",Just "b",Nothing]
12:42:57 <the_lord> @type ([Just "a", Just "b"] ++ if True then [Nothing] else [Just "c"])
12:42:58 <lambdabot> [Maybe [Char]]
12:43:17 <the_lord> ok, my haskell does report that's an error
12:43:23 <the_lord> in the [Nothing]
12:43:24 <xerox> How?
12:43:33 <dmhouse> Which error?
12:43:39 <the_lord> Couldn't match `[Maybe String]' against `Maybe a'
12:43:39 <the_lord>       Expected type: [Maybe String]
12:43:39 <the_lord>       Inferred type: Maybe a
12:43:39 <the_lord>     In the list element: Nothing
12:43:53 <shapr> malcolm_: Jabber has many extensions, video support would not surprise me.
12:43:55 <xerox> Square parens missing
12:44:28 <the_lord> xerox, no, they are there
12:44:38 <xerox> Could you paste the line?
12:44:40 <dmhouse> the_lord: paste the _exact_ code.
12:44:50 <Cale> the type of the rest of your list is wrong then
12:46:04 <the_lord> xerox, fixed, my bad
12:46:13 * xerox hops happily
12:50:06 <the_lord> @hoogle [a] -> [Maybe a]
12:50:07 <lambdabot> No matches, try a more general search
12:50:12 <the_lord> @hoogle a -> Maybe a
12:50:13 <lambdabot> Prelude.Just :: a -> Maybe a
12:50:13 <lambdabot> Data.Generics.Twins.gzip :: (a -> b -> Maybe b) -> a -> b -> Maybe b
12:50:13 <lambdabot> Data.FiniteMap.lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
12:54:20 <xerox> the_lord - return :: a -> Maybe a; Just :: a -> Maybe a.
12:59:55 <SyntaxNinja> y0
13:00:08 <SyntaxNinja> shapr: I'm sometimes on google talk.
13:00:26 <SyntaxNinja> shapr: I guess it does jabber, but can I talk to google ppl w/ my own jabber server?
13:04:25 <Revision17> SyntaxNinja: yes
13:04:32 <Revision17> they opened it up a bit ago
13:05:56 <edwardk> syntaxninja: yeah.. oh, someone already replied =)
13:11:22 <the_lord> @hoogle lookup
13:11:22 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:11:22 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
13:11:22 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
13:12:17 <the_lord> @type catMaybes
13:12:18 <lambdabot> forall a. [Maybe a] -> [a]
13:12:34 <the_lord> @hoogle Maybe a -> a
13:12:35 <lambdabot> Maybe.fromJust :: Maybe a -> a
13:12:35 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
13:12:35 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
13:16:38 <MarcWeber> Lemmih: Are you around?
13:17:55 <SyntaxNinja> maybe I should get back on jabber, tehn.
13:24:43 <xerox> SyntaxNinja: what is your jabber account?
13:24:57 <xerox> More or less privately speaking as you prefer :)
13:27:25 <SyntaxNinja> xerox: don't have one right now.
13:27:36 <SyntaxNinja> I used to run a server.
13:31:54 <SyntaxNinja> anyone got a pointer to the combinators John Hughes uses to create web surveys?
13:37:48 <xerox> Can't find it on GHC site.
13:39:19 <xerox> http://www.haskell.org/pipermail/glasgow-haskell-users/2005-March/008055.html
13:39:20 <lambdabot> Title: "ANNOUNCE: The GHC Survey 2005"
13:41:29 <xerox> It was here <http://www.haskell.org/ghc/survey/>
13:41:40 <SyntaxNinja> yeah. I wonder if he's ever released his little framework, though.
13:42:17 <xerox> Tomasz Zielonka wrote it it seems.
13:44:45 <the_lord> @hoogle [a] -> a
13:44:46 <lambdabot> Prelude.head :: [a] -> a
13:44:46 <lambdabot> Prelude.last :: [a] -> a
13:44:46 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
13:47:10 <tieTYT> wow this is a really big channel.  Makes me feel like more people use haskell than java
13:47:42 <sieni> tieTYT: hopefully
13:47:53 <vininim> people that use java don't know what irc is, only msn. [/joke]
13:48:15 <tieTYT> the next language I want to learn I want to be a functional language
13:48:41 <tieTYT> and I think i want it to be purely functional.  So I'm thinking haskell/clean
13:49:07 <sjanssen> ?elite you should learn Haskell
13:49:07 <lambdabot> y0U $Hou|D 1eArN |-|AsxE11
13:49:09 <sieni> tieTYT: both are probably good choices
13:49:39 <tieTYT> i don't see a clean channel
13:50:44 <xerox> If you get into Haskell you will also have a practical outcome :-)
13:51:07 <tieTYT> meaning i won't with clean?
13:51:10 * SyntaxNinja likes Haskell :)
13:51:24 <xerox> Right, tieTYT.
13:51:32 <sieni> Well, I think Haskell has much more active community and GHC has better platform support than Clean
13:51:49 <tieTYT> sieni: that's what i'm interested in when i decide which one to learn
13:52:06 <xerox> And once cabal-get will be in place you will also have a package manager for Haskell applications in the default compiler distribution :-)
13:52:43 <largos> xerox: cabal-get ~= asdf?
13:53:00 <xerox> cabal-get =~= apt-get.
13:53:17 <tieTYT> alright, well i'll probably look into haskell then.  anyway, ttyl
13:53:19 <Lemmih> tieTYT: And of course, our opinions are completely unbiased! (:
13:53:27 <tieTYT> right of course
13:54:14 <sieni> öi
13:56:20 <MarcWeber> I want do download some pdfs from a website using httplib. I've contacted Bjorn Bringert because I think I need a persistant connection because this site returns 302 temporarely redirection and keeps returning this when using this lib. Are you working on this?
13:56:34 <MarcWeber> , Lemmih ?
13:57:43 <SamB> er, maybe httplib just needs to follow the redirection?
14:00:01 <Lemmih> MarcWeber: Huh? Should I be working on httplib?
14:05:38 <bringert> Lemmih: I told him that you might be. I seem to recall you telling me that, but maybe I'm confused
14:16:53 <jgrimes> bringert, I added another entry to my blog that uses hscolour (may or may not be the cause) and now this is happening: http://marginalerror.com/entry The separate entries work fine (8, 9, 11)
14:17:18 <bringert> oops
14:18:04 <bringert> jgrimes: go to http://marginalerror.com/entry/10/edit and get the blog entry source
14:18:11 <bringert> and give it to me
14:20:04 <jgrimes> bringert, http://paste.lisp.org/display/22428
14:21:30 <bringert> jgrimes: temporary fix: add an empty line before {{{haskell:
14:21:33 <jgrimes> bringert, hm... looks like when I an empty line before the {{{ it started working again
14:21:37 <jgrimes> ;)
14:21:56 <bringert> jgrimes: I need to fix it so that bad markup doesn't crash it
14:34:16 <largos> how do you go about using a haskell library that isn't in the standard distrib? (JRegex, for example: http://repetae.net/john/computer/haskell/JRegex/)
14:34:19 <lambdabot> Title: "JRegex"
14:36:23 <Lemmih> largos: You use cabal to install it.
14:36:28 <ihope> How can I put a space after every comma in a string?
14:38:13 <bringert> jgrimes: ok, fix is in darcs. you will still get a parse error, but it will be in the blog entry text, not a 500 internal server error
14:38:26 <jgrimes> bringert, nice, sounds good
14:40:29 <largos> Lemmih: thanks
14:50:34 <sjanssen> > foldr (\x xs -> (if x == ',' then (", "++) else (x:)) xs) [] "add,spaces,please"
14:50:35 <lambdabot>  "add, spaces, please"
14:51:43 <sjanssen> @pl \x -> if x == ', ' then (", "++) else (x:)
14:51:44 <lambdabot> (line 1, column 15):
14:51:44 <lambdabot> unexpected "'"
14:51:44 <lambdabot> expecting space or simple term
14:51:44 <Lemmih> > foldr (\x xs -> x:(if x == ',' then (' ':) else id) xs) [] "add,spaces,please"
14:51:45 <lambdabot>  "add, spaces, please"
14:53:39 <sjanssen> @pl \x -> if x == comma then (space:) else id
14:53:39 <lambdabot> flip (flip if' (space :) . (comma ==)) id
15:31:55 <offby1> hooray -- I've learned enough Haskell to write my little anagram program (alarmingly similar to www.haskell.org/haskellwiki/Anagrams)
15:32:15 <vininim> you should do mergesort first. ;)
15:32:59 <vininim> s/should/should have done
15:41:25 <vininim> or, could be the next thing heh
15:44:30 <cjay> is there a list of things one should have done when learning? :>
15:49:11 <vininim> cjay: nlogn sorting, dynamic programming, numerical analysis, partial solveable problems... oh, and hello world. ;)
15:49:51 <vininim> even thought I doubt my intuitive mergesort was really nlog :P
15:50:08 <cjay> :)
15:50:26 <wolverian> gotta love the intuitive solutions ..
15:59:16 <offby1> vininim: mergesort is too easy
16:08:33 <Nanar> $ ghci -L/usr/lib64 -lrpm -lrpmio -lrpmbuild -lrpmdb  parserpm.hs -fffi
16:08:41 <Nanar> During interactive linking, GHCi couldn't find the following symbol: tagName  
16:09:03 <Nanar> but program compil with -lrpm and is properly linked
16:09:14 <SyntaxNinja> does anyone have experience w/ wash? I"m trying to get something to compile without understanding it :)
16:09:16 <Nanar> should I report a bug ?
16:10:25 <bringert> SyntaxNinja: I have use wash a bit, but it was probably two years ago
16:10:30 <bringert> eh used
16:10:54 <SyntaxNinja> then you might not be able to help because I guess the code doesn't compile due to changes in wash.
16:11:20 <stepcut> SyntaxNinja: I am somewhat familiar with it
16:11:37 <stepcut> SyntaxNinja: I wrote a simple double-entry bookkeeping program in it :p
16:11:48 <stepcut> s/in it/with it/
16:12:33 <stepcut> hrm, that isn't much better, perhaps 's/in it/that used it/'
16:12:37 <SyntaxNinja> man. I hardly know where to start. I'm trying to compile JH's SurveyLib. he's out of office, so I can't actually ask permission :)
16:12:48 <SyntaxNinja> I just grabbed it from his web site, but there's no license attached to it.
16:13:35 <SyntaxNinja> I've cabal-ized it... seems that the type of "value" has changed
16:14:08 <SyntaxNinja> is it the case that textareaContents is now just value, by chance?
16:14:22 <stepcut> SyntaxNinja: could be
16:14:48 <SyntaxNinja> I get this error:     Couldn't match `Maybe [Char]' against `String'
16:14:48 <SyntaxNinja>       Expected type: InputField (Maybe [Char]) VALID
16:14:48 <SyntaxNinja>       Inferred type: InputField String INVALID
16:14:48 <SyntaxNinja>     In the first argument of `value', namely `new'
16:14:48 <SyntaxNinja>     In the third argument of `maybe', namely `(value new)'
16:14:49 <SyntaxNinja>  
16:15:09 <SyntaxNinja> I don't really get that VALID / INVALID stuff.
16:15:39 <stepcut> SyntaxNinja: I think the VALID / INVALID stuff is a phantom type indicating if the value is 'valid' or not
16:15:51 * SyntaxNinja nods
16:16:02 <SyntaxNinja> so how do I convert them?
16:16:25 <stepcut> with 'value'
16:17:04 <SyntaxNinja> I am using value, it's complaining about the argument to value.
16:17:05 <stepcut> I think that textArea used to always return 'String' even if the user entered nothing
16:17:15 <SyntaxNinja> oh...
16:17:27 <stepcut> but perhaps textarea now returns 'Maybe String' to indicate if there was any user input
16:17:51 <SyntaxNinja> newValue = maybe "" id (value new) 
16:18:20 <stepcut> yeah, something like that
16:18:41 <SyntaxNinja> no, that's what's there now... but when I change that to just "value new" I get:  Couldn't match `VALID' against `INVALID'
16:18:41 <SyntaxNinja>       Expected type: InputField String VALID
16:18:41 <SyntaxNinja>       Inferred type: InputField String INVALID
16:18:41 <SyntaxNinja>     In the first argument of `value', namely `new'
16:18:41 <SyntaxNinja>     In the definition of `newValue': newValue = (value new)
16:19:26 <stepcut> SyntaxNinja: hrm, let me ponder
16:19:31 <SyntaxNinja> by all means ;)
16:20:53 <stepcut> SyntaxNinja: where I can I get this code? These errors happen *all the time* when trying to use wash...
16:21:07 <stepcut> I think I need to see more context
16:37:15 <the_lord> @type lookup
16:37:16 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
16:37:54 <the_lord> @hoogle a -> [(a,b)] -> [Maybe b]
16:37:55 <lambdabot> No matches, try a more general search
16:39:56 <the_lord> how do I find all the matching ones?
16:41:16 <the_lord> @hoogle a -> [(a,b)] -> [b]
16:41:17 <lambdabot> No matches, try a more general search
16:41:33 <the_lord> @hoogle a -> [a] -> [b] -> [b]
16:41:34 <lambdabot> No matches, try a more general search
16:41:43 <offby1> is there a "multi-set" library?  By "multi-set", I mean like a set, except each element can occur more than once.
16:41:55 <the_lord> offby1: List
16:42:18 <offby1> I meant an efficient version
16:42:18 <offby1> and naturally you can ask not just "is this element a member", but rather "how many times does the element appear"
16:42:20 <ndm> the_lord: findIndexes
16:42:38 <ndm> offby1: Data.Map, keys is item, value is count
16:43:06 <offby1> ndm: I considered that; I was wondering if something more specialized (and presumably more efficient) existed.
16:43:25 <ndm> offby1: that shoudl be pretty efficient - i guess anything else would just be implemented in terms of that
16:43:36 <offby1> I'll give that a try
16:43:38 <offby1> thanks
16:54:04 <dfeuer> Anyone here familiar with Okasaki's catenable deques?
17:00:12 <edwardk> is there a monadic form of ixmap?
17:00:32 <thumper9> hey
17:00:38 <ndm> dfeuer: ever so slightly
17:00:38 <edwardk> heya
17:00:38 <thumper9> we are about to byu a scheduler fro 20k
17:00:46 <thumper9> is there a job scheduler in haskell?
17:00:47 <thumper9> :)
17:00:51 <edwardk> heh
17:01:44 <stepcut> thumper9: haskell-cron ?
17:01:48 <stepcut> :p
17:02:35 <dfeuer> ndm: I'm wondering if they might be simplified ....  would a datatype of   data Deque a = Shallow (Q a) | Deep (Q a) (Q (Deque a)) (Q a) support O(1) operations, if Q is a non-catenable deque?
17:04:13 <ndm> dfeuer: i don't know that...
17:04:21 <dfeuer> mumble.
17:04:34 <dfeuer> Guess I'd have to ask Dr. Okasaki :-/
17:04:49 <dons> offby1: lists are pretty efficient. is there a particular operation you need good complexity on?
17:04:52 <ndm> if you write your code
17:05:10 <ndm> it should be reasonably obvious if its O(1) or not, depending on laziness
17:05:22 <dfeuer> I'm working on it.
17:05:24 <dfeuer> It's slow.
17:05:30 <dfeuer> Figuring out what invariants I need, etc.
17:05:45 <offby1> dons: I'm having second thoughts.
17:05:52 <ndm> dons, what patches have you got in your coyp of hoogle on irc?
17:05:59 <offby1> dons: if I were to explain what I was doing, it'd take five or ten minutes
17:06:04 <dons> ndm, let me check
17:06:23 <dons> offby1: well, do you need fast lookup? fast append? fast insertion?
17:06:41 <dons> ndm, i suspect it's out of date.
17:06:50 <offby1> dons: lookup _and_ insertion, prolly
17:07:11 <dons> hmm, is that right, i seem to have rsync'd hoogle : Fri Jun  9 13:15:46 EST 2006
17:07:13 <ndm> offby1: Data.Map will give you O(log n) for both
17:07:17 <dons> i don't _remember_ doing that.
17:07:31 <dons> or you could use Data.HashTable, i suppose
17:07:33 <ndm> there isn't anything new since then
17:07:53 <ndm> its just you often give no results, when web hoogle would give some
17:07:59 <dons> hmm.
17:08:14 <ndm> often when the result is not very good - i wondered if you filtered results below a certain score?
17:08:19 <dons> i have my 3rd (!) phd review in 1 hr. i'll have a look afterwards.
17:08:22 <dons> yeah, i suspect so
17:08:29 <ndm> hehe, good luck!
17:08:34 <dons> 3rd and final.
17:08:37 <dons> fingers crossed
17:08:55 <ndm> final before the real phd submission?
17:08:59 <dons> then i'll change my nick to dr.dons, and you can all pay me money
17:09:09 <dons> well, i hope not to have a 4th review, this time next year
17:09:10 <ndm> or final, to get your phd?
17:09:16 <dons> i intend to submit in 12 months
17:09:53 <ndm> i think we only get a fixed number of reviews, then after that no more reviews
17:10:03 <ndm> i hope to submit in two years :)
17:10:07 <dons> well, here, you get up to 5 at most, i suppose.
17:10:25 <ndm> ours is 3 as "standard", everyone takes 4
17:10:31 <ndm> but you are only officially a student for 3
17:10:32 <dons> right. same here
17:10:47 <dons> well, we're only funded for 3 years, but they plan for 4 from the start
17:10:53 <thumper9> hey
17:10:59 <thumper9> in functinla programming
17:11:03 <thumper9> how do you do if then
17:11:07 <thumper9> or do ya avoid it?
17:11:08 <dons> unlike, say, the german system. or finnish. they have more itme
17:11:21 <ndm> thumper9: if condition then blah else blah2
17:11:27 <dons> > if 1 == 2 then "yes" else "no"
17:11:28 <lambdabot>  "no"
17:11:30 <ndm> its absolutely essential
17:11:48 <dons> > case 1 == 2 of True -> "yes" ; False -> "no"
17:11:49 <lambdabot>  "no"
17:12:32 <dons> > let myif x y z |  x = y | otherwise = z in myif (1==2) "yes" "no"
17:12:32 <lambdabot>  "no"
17:12:35 <dons> :)
17:12:58 <dons> thumper9: so there's lots of ways, in haskell at least
17:13:05 <ndm> > ["yes" | 1 == 2] ++ ["no" | 1 /= 2]
17:13:06 <lambdabot>  ["no"]
17:13:19 <dons> ah, tricksy!
17:13:38 <ndm> you should see Colin Runciman's code, it reads like a book of Haskell tricks you never knew
17:13:54 <ndm> ['('|bracket] ++ value ++ [')|bracket]
17:13:57 <dons> yeah, these old school guys know all the tricks
17:14:00 <ndm> thats my favourite
17:14:10 <dons> huh
17:14:28 <dons> maybe i need to read some of colin's code
17:14:39 <ndm> i once helped him debug some of his code
17:14:57 <ndm> and he showed me the code, 4 pages, before having even compiled it
17:15:04 <dons> hehe
17:15:06 <thumper9> so hey
17:15:15 <thumper9> how do you do like event driven programing in haskell
17:15:27 <ndm> thumper9: like what events?
17:15:29 <dons> the usual way
17:15:35 <ndm> if you mean a GUI, see Gtk2Hs for examples
17:15:39 <dons> if you're fancy, you could use the 'Arrows' abstractions.
17:15:46 <dons> see, for example, Frag, our 3d shooter game
17:15:48 <dons> ?wiki Frag
17:15:48 <lambdabot> http://www.haskell.org/haskellwiki/Frag
17:16:42 <thumper9> like file dropped on my ftp server msut be found and operated on as soonas thye arrive
17:17:00 <ndm> you can of course do polling
17:17:05 <thumper9> idea is to read em as soon as they appear
17:17:08 <thumper9> oh?
17:17:11 <thumper9> cool
17:17:13 <ndm> not sure if there is some select mechanism exported by Posix module
17:17:22 <thumper9> can haskell do data transfer from box to box over sockets?
17:17:30 <eivuokko> lispy, Are you Jason Dagit?
17:17:31 <thumper9> or http
17:17:35 <ndm> yes, it has socket protocols
17:17:37 <dons> thumper9: sure. look at lambdabot:
17:17:43 <dons> ?google lambdabot
17:17:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:17:44 <lambdabot> Title: "lambdabot"
17:17:46 <thumper9> woa is there a MTA in haskell?
17:17:48 <thumper9> coolio
17:17:49 <dons> yep
17:18:00 <dons> check haskell.org under 'libraries and tools/network'
17:18:10 <ndm> have you seen darcs? that does lots of network stuff
17:18:38 <dons> are there any general purpose programming languages that do support the network?
17:18:43 <dons> s/do/dont/
17:18:59 <dons> seems like we get asked a lot, but i feel the answer should be obvious.
17:19:17 <ndm> almost every language could be hooked up to a library to do it
17:19:22 <dons> @tell shapr we're the iohcc/2004 results now there's no scannedinavian?
17:19:22 <lambdabot> Consider it noted.
17:19:33 <dons> we're? /me needs more caffeine
17:19:45 <ndm> esp if you've got a phd thing in an hour :)
17:20:14 <dons> yikes!
17:21:53 <ndm> i had my first one at 8 am in the morning, so my supervisor could attend a drinks reception at 10am, and do two of them in that time
17:22:07 <ndm> i was half asleep, so was my examiner
17:52:38 <thumper9> hey
17:52:43 <thumper9> i dont know how to program
17:52:44 <thumper9> im 33
17:52:51 <thumper9> ubt I feel the need to learn
17:52:56 <thumper9> since many apps here are stinkers
17:53:09 <thumper9> stinkers!
17:53:50 <thumper9> yeah
17:53:56 <thumper9> it seems haskell is web savvy too
17:53:59 <lispy> thumper9: do i know you?
17:54:27 <lispy> perhaps you're a different thumper than i remember
17:55:40 <iron32> thumper9: Well once you have done it for a while you standards may decrease in that you apreciate some of the difficulties in writing software. It is easy to criticize others
17:56:04 <lispy> iron32: that's a stupid thing to say <wink>
17:56:36 <thumper9> http://www.bivio.biz/hm/why-bOP
17:56:37 <lambdabot> Title: "bivio Software, Inc. - Why bOP?"
17:56:38 <thumper9> check this out
17:57:03 <thumper9> this looks sick
17:57:08 <thumper9> like way powerful
17:57:09 <thumper9> :)
17:57:12 <thumper9> hey now
17:57:26 <eivuokko> lispy, re: Win32:  Eeeks!  It looks like you got older winapi than I do.
17:57:38 <lispy> eivuokko: i see...
17:58:08 <eivuokko> lispy, Are you using Visual Haskell?  Because I think it works on 6.4.2 (except you need FPS) and it did work on 6.5 I had compiled.
17:58:36 <lispy> eivuokko: i tried using ghc 6.5 (yes from VH) on the command line
17:58:46 <eivuokko> Well, anyway, you can comment usage of that constant.
17:58:57 <lispy> okay, i'll try that
17:58:58 <eivuokko> And added FPS in cabal?
17:59:17 <eivuokko> That constant is used just for completeness sake
17:59:24 <eivuokko> Well, ok, it has uses.
18:00:06 <lispy> i don't think i have fps
18:00:12 <eivuokko> Hmh
18:00:26 <eivuokko> You will need to install it.  Wierd if cabal didn't say anything
18:00:53 <eivuokko> (And add ref to .cabal file, because VH's base-package doesn't have it like current darcs base)
18:01:07 <lispy> Could not find module `Data.ByteString.Base'
18:01:09 <eivuokko> Or comment the few lines off, again.
18:01:21 <eivuokko> Yeah, there's improt and one function iirc.
18:01:52 <lispy> how do i find the version of FPS that you want me to install+
18:01:55 <lispy> is that from dons site/
18:02:00 <lispy> @where fps
18:02:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
18:02:10 <eivuokko> Ehm, good question
18:02:23 <eivuokko> darcs versions probably works
18:03:11 <lispy> the darcs version of fps is really old iirc
18:03:20 <eivuokko> Huh?
18:03:34 <eivuokko> I thought ByteString devel happens in dons' darcs repo
18:03:50 <eivuokko> Well, the "main" devel of ByteString and Lazy.
18:03:52 <lispy> oh, i thought you meant the version of fps that is bundled with darcs
18:04:14 <eivuokko> Oh no
18:04:19 <SamB_XP> heh
18:04:27 <eivuokko> That is in practice totally diffrent beast :)
18:04:36 <eivuokko> dons' and friends have rewritten it
18:04:51 <lispy> okay, i'll build fps and install it, then attempt the win32 build again
18:05:31 <eivuokko> If you have any questions or suggestions, let me know.
18:06:52 <lispy> iron32: i was just teasing, i think you're right about the critisim comment
18:07:03 <lispy> critizism...
18:07:13 <lispy> Data/ByteString/Base.hs:303:28:
18:07:13 <lispy>     Not in scope: `finalizeForeignPtr'
18:07:20 <lispy> today is full of non compiles
18:07:32 <lispy> iron32: sorry if it sounded mean
18:07:53 <eivuokko> Uhm
18:08:10 <iron32> lispy: No its ok
18:08:52 <iron32> I am thicked skin just was curios 
18:09:10 * lispy was trying to be ironic
18:09:20 <lispy> er maybe ironic is wrong term
18:09:27 <iron32> well I will have to try and be more perceptive
18:10:47 <iron32> actually anyone give some Darc pointers I want to getdons Frag project and take a look at it
18:11:06 <eivuokko> lispy, Hrm.  That is new thing and seems ghc specific.
18:11:31 <eivuokko> Ah
18:12:31 <ndm> iron32: darcs get --partial repo
18:12:46 <ndm> where repo is where the Frag projects darcs repo is located
18:13:06 <iron32> ok I will try it
18:13:16 <eivuokko> lispy, I think you can, again, comment that part of FPS off.
18:13:29 <lispy> iron32: ask here and/or in #darcs if you need help with it
18:13:31 <eivuokko> lispy, Do you really use VH for compiles?
18:13:49 <lispy> eivuokko: it's the only version of ghc i have installed
18:14:00 <ndm> I found VH way way too slow
18:14:04 <lispy> eivuokko: i can use it from the commandline or from visual studio if that's what you mean
18:14:05 <eivuokko> lispy, Because I'd think you'd be better off using 6.4.2 or 6.5 compiled lately.
18:14:34 <lispy> eivuokko: eventually i'm going to need COM support, and H/Direct is very broken except for the version that comes with VH
18:14:35 <eivuokko> lispy, Yeah, I meant how dependant you are on using Visual Studio.  I use it only for syntax highlighting, I found cabal too flaky with it.
18:14:42 <eivuokko> lispy, Ah
18:15:10 <eivuokko> lispy, If you want to fix H/Direct, drop me a line.  I'm interested getting it working, but I don't have immediate needs for it.
18:15:26 <eivuokko> Maybe we could put up some effort to bring it to speed.
18:15:34 <lispy> eivuokko: that does sound nice
18:15:45 <eivuokko> Anyway, it's not terribly hard to fake com-stuff in just ffi
18:15:54 <lispy> eivuokko: simonM gave me a link to the source tree if you need that
18:16:57 <eivuokko> It's not in darcs.haskell.org?
18:17:51 <lispy> eivuokko: it is
18:17:56 <lispy> http://darcs.haskell.org/vshaskell
18:17:59 <lambdabot> Title: "Index of /vshaskell"
18:18:04 <eivuokko> Yeah, ok.
18:18:26 <lispy> i wonder if i could extract the COM stuff from there and use it with 6.4.2
18:18:49 <eivuokko> Dunno, I find the source unintuitive.
18:19:03 <eivuokko> com-stuff would be cool also because it'd allow easily almost all of .net
18:19:22 <lispy> well, automation is semi-broken
18:19:53 <eivuokko> Hmh
18:20:14 <lispy> so, some of the problems i found already 1) finalizers had to be disabled so we're ref counting manually 2) i had to write my own createInstance function for talking to Office
18:20:52 <eivuokko> That sounds almost working to me
18:21:13 <lispy> yeah, i was able to communicate with excel after some work at which point i considered  it good enough
18:21:36 <lispy> i'd like to get typelib support working gain
18:21:43 <eivuokko> Heh
18:21:50 <lispy> then i wouldn't care about automation
18:22:04 <eivuokko> What's wrong wit hit?
18:22:07 <eivuokko> *with it
18:22:19 <eivuokko> (Just asking for future reference) :)
18:22:58 <eivuokko> I imagine tt shouldn't be too hard to fix.  There's tlb handling in atleast python's win32all-extensions.
18:23:26 <eivuokko> So it's not neccesarily all-in-dark engineering.
18:23:29 <lispy> i'm not sure why it's been disabled
18:24:01 <lispy> i see two important directions for h/direct, resurrect tlb support and figure out a pleasant way of using automation
18:24:34 <lispy> right now with automation you have to do all the manual resource junk, manual down casting and the syntax isn't so hot
18:24:42 <lispy> compare this to python where you use com as if it were VB
18:24:53 <eivuokko> Hmmm
18:25:46 <lispy> i looked at the idea of porting over python's com support but when i was able to communicate with excel i dropped it and worked on other things...like i really need a gui library now
18:26:02 <eivuokko> And wxhaskell didn't fit?
18:26:20 <lispy> i think i'll use gtk for 90% of stuff and then fall back to comdlg32 for native dialogs
18:26:31 <lispy> wxhaskell is very nice until i needed to use wxgrid
18:26:37 <eivuokko> I can't find wxhaskell darcs repo :-S
18:26:46 <eivuokko> So I guess it's still at that dead cvs
18:26:51 <lispy> i think they just have an sf.net page
18:27:04 <eivuokko> Argh
18:27:14 <eivuokko> Wish I had more time.  I'd like to resucurrect it
18:27:23 <eivuokko> I pretty much hate gtk myself.
18:27:47 <lispy> i don't care that much about gtk vs. wx, but i need my program to look like our existing software
18:28:03 <lispy> eventually i'll be writing this in C++ and it will be part of the same source tree and this won't matter
18:28:09 <lispy> but for my prototype i'm using haskell
18:28:12 <eivuokko> Hmh
18:28:13 <eivuokko> Ah
18:28:33 <lispy> there is also the idea of writing this as a dll
18:28:42 <lispy> using C++ as the gui and haskell as the brains
18:28:44 <eivuokko> It's easy.
18:28:50 <eivuokko> Well
18:28:59 <eivuokko> Ok, it's easy if you use ghc 6.5 from darcs, I think.
18:29:15 <eivuokko> Otherwise it's a bit messy as you can't use ghc --make properly
18:29:15 <lispy> is it hard to build ghc is windows?
18:29:21 <eivuokko> Depends
18:29:34 <eivuokko> If you know unixy shell or  mingw/msys, not that hard
18:29:49 <lispy> oh yeah, i'm veteran linux guy
18:30:07 <lispy> i bet i've logged more hours at a terminal than i have in windows :)
18:30:12 <eivuokko> I think last I tried.  darcs get ..ghc; darcs-all get; autoreconf; ./configure --prefix=..; make; make install + copy mingw stuff correctly by hand.
18:30:33 <eivuokko> in msys prompt, when you have mingw, msys and msysdtk installed (Atleast)
18:30:46 <lispy> i don't know if i have msysdtk
18:30:50 <eivuokko> Latest stable from mingw.org worked, I think.
18:31:18 <eivuokko> Yeah, most people don't have it, but you really need it.  Oh yeah, and ghc in path.  Not sure if you need alex and happy, I think the translated sources are in darcs.
18:31:27 <eivuokko> But you got all that with visual haskell
18:31:40 <lispy> yeah VH made it easy
18:32:15 <palomer> <:o
18:32:17 <palomer> you're all nuts!
18:32:31 <cjay> right.
18:32:33 <eivuokko> You can also grab prebuilt binaries
18:33:10 <eivuokko> http://www.haskell.org/ghc/dist/current/dist/ <- nightly build tars
18:33:11 <lambdabot> Title: "Index of /ghc/dist/current/dist"
18:33:45 <palomer> the haskell community should really concentrate on a cross platform development environment, especially since many of the people in academia use unix
18:33:59 <eivuokko> Uhm.
18:34:08 <lispy> eivuokko: cool
18:34:23 <lispy> palomer: such as emacs?
18:34:35 <palomer> themacs!
18:34:37 <lispy> eivuokko: i added import GHC.ForeignPtr to that file and FPS compiles
18:34:45 <eivuokko> Heh
18:34:58 <eivuokko> I thought it was all new - I check just Foreign.ForeingPtr sources.
18:35:23 <eivuokko> That's what you get for using old devel version :o
18:36:25 * erider has to roll 
18:36:37 <the_lord> @hoogle a -> [a] -> Maybe a
18:36:37 <lambdabot> No matches, try a more general search
18:36:46 <lispy> eivuokko: hehe, thanks for your help
18:37:14 <eivuokko> np
18:37:26 <lispy> eivuokko: stil not compiling tho
18:37:33 <lispy> eivuokko: i mean win32
18:37:34 * eivuokko looks at his add-to-TODO list and sighs
18:37:46 <lispy> eivuokko: i added fps to the depends in the .cabal
18:37:49 <eivuokko> What's missing now?
18:37:58 <lispy> same error
18:38:06 <lispy> System\Win32\FileMapping.hsc:24:7:
18:38:06 <lispy>     Could not find module `Data.ByteString.Base':
18:38:24 <eivuokko> Did you run configure again?
18:38:37 <lispy> no, i 'll try that
18:38:42 <eivuokko> package deps are checked (and cached) at configure iirc
18:39:00 <lispy> you're rigt
18:40:15 <lispy> eivuokko: hopefully in the next week i'll be sending you patches that add some comdlg stuff
18:40:18 * lispy crosses fingers
18:40:39 <eivuokko> :)
18:40:45 <eivuokko> I should hack Win32 myself.
18:41:22 <lispy> sweet it builds and installs
18:41:33 <lispy> but, my work day is done so i'm outta here for a while
18:41:35 <lispy> thanks for all the help
18:41:48 <eivuokko> Have fun.
18:41:58 <eivuokko> (Whatever you do outside work)
18:42:17 <lispy> thanks, i'm training for a marathon...so i'm going home and then jogging :)
18:42:24 <eivuokko> Whoa
18:42:50 <eivuokko> That's a serious target...running a marathon.
18:43:07 <lispy> i'm only one week into the program and my marathon is in late april, so we'll see how serious i am :)
18:43:54 <eivuokko> It's probably great fun :)
18:44:05 <lispy> yeah, and i really need the exercise
18:44:44 <the_lord> machineFromName :: String -> [Maquina] -> Maybe Maquina
18:44:44 <the_lord> machineFromName id ((Maq id a b c d e f g):sig) = Just (Maq id a b c d e f g)
18:44:44 <the_lord> machineFromName id ((Maq id2 _ _ _ _ _ _ _):sig) = machineFromName id sig
18:44:44 <the_lord> machineFromName [] = Nothing
18:44:56 <lispy> i started running and set this goal because i needed something outside of work, friends, relationships and all that, which i could feel good about and i could focus on
18:45:06 <the_lord> I know I can do this with a fold, I'm just ran out of knowledge
18:45:09 <the_lord> please help
18:45:36 <Pseudonym> the_lord, your code would be a lot simpler with records.
18:45:52 <lispy> even an @ pattern
18:45:56 <the_lord> Pseudonym: and by records you mean???
18:46:18 <lispy> what is the difference between the first two patterns?
18:46:27 <eivuokko> Nothing
18:47:14 <lispy> Oh
18:47:23 <lispy> the_lord: i don't think pattern matching works that way
18:47:41 <eivuokko> Well, the second pattern can never match, first one always takes it.
18:47:45 <lispy> > let {f x x = True; f x _ = False} in f 1 1
18:47:46 <lambdabot>    Conflicting definitions for `x'
18:47:46 <lambdabot>   In the definition of `f'
18:47:58 <Pseudonym> the_lord: Records are like data constructors, only you give names to fields.
18:48:05 <eivuokko> Ah, right.  One name repeated.
18:48:10 <lispy> the_lord: you need a guard
18:48:23 <lispy> anyway, i 'm out of here for real this time
18:50:18 <u221e> Why are the ghc shootout scores so much lower on the sempron compared with the pentium 4?
18:50:23 <the_lord> machineFromName :: String -> [Maquina] -> Maybe Maquina
18:50:23 <the_lord> machineFromName name ((Maq id a b c d e f g):sig) i
18:50:23 <the_lord>         | name == id = Just (Maq id a b c d e f g)
18:50:23 <the_lord>         otherwise = machineFromName id sig
18:50:23 <the_lord> machineFromName [] = Nothing
18:50:38 <dons> u221e: it's a slower machine, different arch.
18:50:45 <dons> also, its possible some flags are different?
18:50:52 <dons> (i.e. like mandelbrot, which has been fixed now)
18:50:58 <the_lord> without the trailing "i" on the second line
18:51:06 <Pseudonym> the_lord: There's one syntax error and one type error.
18:51:18 <Pseudonym> The syntax error is that you need another | before otherwise.
18:51:45 <Pseudonym> Oh, quick note about records.
18:52:00 <Pseudonym> data Foo = { fooName :: String, fooData :: Int }
18:52:04 <Pseudonym> data Foo = Foo { fooName :: String, fooData :: Int }
18:52:07 <Pseudonym> Sorry, second not first.
18:52:10 <Pseudonym> That's equivalent to:
18:52:11 <u221e> dons, I mean on comparisons between language, not in general
18:52:14 <Pseudonym> data FOo = Foo String Int
18:52:18 <Pseudonym> And:
18:52:22 <Pseudonym> fooName (Foo a b) = a
18:52:27 <Pseudonym> fooData (Foo a b) = b
18:52:43 <Pseudonym> But there's also syntax for updating fields.
18:52:55 <dons> u221e: btw, did you post your updated mandelbrot?
18:53:10 <the_lord> Pseudonym: thx man, didn't knew that
18:53:39 <u221e> No, not yet, i'm still trying some stuff
18:53:52 <the_lord> Pseudonym: now I'm going to do that
18:54:23 <scsibug> Pseudonym: could you show me or point me towards the syntax for updating fields?
18:54:38 <u221e> dons, I tried making one that buffered the output using ByteString and while the final result printed very fast. I Couldn't build the actually ByteString fast enough :(
18:54:55 <u221e> Probably doing something wrong.
18:55:06 <Pseudonym> scsibug: It's this, pretty much.
18:55:26 <Pseudonym> Suppose we have: someFoo = Foo "Hello" 2
18:55:39 <Pseudonym> Then you can update it using: someFoo { id = 42 }
18:55:49 <Pseudonym> You can do parallel updates, too:
18:55:57 <Pseudonym> Sorry, that should be: someFoo ( fooData = 42 }
18:56:02 <the_lord> Pseudonym: and can I do polymorphism with records?
18:56:16 <Pseudonym> Parallel updates: someFoo { fooId = "bar", fooData = 42 }
18:56:20 <Pseudonym> the_lord: Of course.
18:56:45 <scsibug> Pseudonym: Thanks, I was getting very frustrated earlier because I wanted to do that, but didn't think it was possible
18:56:55 <Pseudonym> No problem.
18:57:05 <Pseudonym> There should be a wiki page about this.
18:57:13 <Pseudonym> Once you've worked it out, by all means write one. :-)
18:57:17 <u221e> Here is a question I have... can monadic functions be tail recusive if you make a "variable assignment"? If I understand correctly, the variable is just a function who's argument is passed to the rest of the function...
18:57:39 <Pseudonym> u221e: What is a "variable"?
18:58:02 <u221e> x <- blah
18:58:09 <u221e> Bad choice of words
18:58:14 <Pseudonym> We call that a "binding".
18:58:21 <Pseudonym> Does this answer your question?
18:58:27 <Pseudonym> > do { x <- [1,2,3] }
18:58:27 <lambdabot>  Parse error
18:58:52 <sjanssen> the last statement in a do block can't be a binding
18:58:56 <Pseudonym> Right.
18:59:04 <Pseudonym> So by definition, this can't be tail recursive.
18:59:09 <Pseudonym> Because it's not even syntax correct.
18:59:30 <the_lord> Pseudonym: you simplified a lot of work for me
18:59:38 <the_lord> Pseudonym: thx
18:59:44 <Pseudonym> No problem.
19:00:04 * palomer high fives Pseudonym 
19:00:12 <Pseudonym> Yeah!  Woo!
19:01:37 <sjanssen> u221e: are you worrying about a case like: go = do {x <- something; go}
19:02:54 <Pseudonym> That's translated into:
19:03:04 <Pseudonym> (More or less):
19:03:13 <Pseudonym> go = bind something (\x -> go)
19:03:29 <Pseudonym> The bind operation is actually an operator.
19:03:45 <Pseudonym> Any reasonable definition of "bind" is going to be tail recursive.
19:03:54 <Pseudonym> But in general it depends on the monad.
19:04:17 <Pseudonym> Well, it'll be _eventually_ tail recursive, anyway.
19:05:06 <Korollary> Just check out the desugaring of the do-notation in the report or various monad tutorials.
19:05:41 <zeeeee> hi all, can i run my .hs directly from the shell using ghc[i]/hugs without compiling it or manually loading/running it from within the interpreter?
19:05:57 <Korollary> zeeeee: runghc / runhaskell should do
19:06:10 <dons> zeeeee: yep, you can
19:06:21 <dons> add: #!/usr/bin/env runhaskell
19:06:28 <dons> to the top of your .hs file, and chmod +x it
19:06:58 <dons> (of course, it runs slower than if you compile it, but its good for scripts that aren't executed that often)
19:07:01 <zeeeee> Korollary, dons: thanks!
19:10:23 <vininim> Note to self: prefix notation in category theory might be better.
19:13:58 <eivuokko> dons, That ANF-stuff is fun.  I'm considering writing anf reg alloc + x86 backend for something like that.
19:14:14 <eivuokko> Many thanks for the link...I was ignorant about it.
19:14:27 <eivuokko> Uhm, if that is right use of the word.
19:14:51 <dons> oh, very cool!
19:15:10 <dons> you should CC. the authors, since I sit next to one of them, and the other two are my supervisors ;)
19:16:14 <eivuokko> lol :)
19:17:51 <zeeeee> are there any examples of simple haskell scripts that read in (and process) "tabular" text files (where each line has a number of fields separated by e.g. whitespace)?
19:18:55 <dons> > words "x y z a b c"
19:18:56 <lambdabot>  ["x","y","z","a","b","c"]
19:19:00 <zeeeee> i'm trying to write such a program right now and i'm having trouble (coming from python); i'd ask specific questions like "how do i read in a line and then split it on whitespace" but that might not be the "haskell approach"
19:19:00 <dons> will be very useful to you
19:19:10 <dons> no no, it makes lots of sense
19:19:18 <dons> ?type interact 
19:19:20 <lambdabot> (String -> String) -> IO ()
19:19:27 <u221e> What's the biggest fixed size data type in haskell? Word64?
19:19:30 <dons> is also useful for functions that read and write to stdin/stdout
19:19:36 <dons> fixed size, Word64 yes.
19:19:42 <dons> otherwise bump over to Integer
19:20:23 <u221e> The shootout machines are still 32 bit aren't they...
19:20:28 <dons> right
19:20:39 <modulo7> ?type id
19:20:40 <lambdabot> forall a. a -> a
19:21:14 <u221e> Well, using all of that 32 bits should improve things, right now the algorithm is only using 8 and tossing the rest.
19:21:39 <the_lord> Pseudonym: a simple question
19:21:42 <dons> hmm, maybe, maybe. good idea u221e 
19:21:48 <dons> check that it's legal though
19:22:02 <u221e> Why wouldn't it be?
19:22:06 <the_lord> how do I export all the functions created by a record?
19:22:17 <dons> well, sometimes you have to do _exactly_ what some other implementation does
19:22:19 <zeeeee> dons: that's a good function to know; thanks to that i also guessed there'd be a 'lines' function
19:22:28 <dons> right, lines is also useful
19:22:59 <the_lord> dons: do you know how to do it?
19:23:10 <modulo7> ?type let y x = x (y x) in y
19:23:11 <lambdabot> forall t. (t -> t) -> t
19:23:12 <dons> hmm, interesting u221e:
19:23:13 <dons> Each program should plot the Mandelbrot set [-1.5-i,0.5+i] on an N-by-N bitmap. Write output
19:23:16 <dons> byte-by-byte in portable bitmap format
19:23:24 <dons> so, you need to write output byte-by-byte, but you could buffer
19:23:40 <dons> and it doesn't really give any constraint on how to compute things, so Word32 might be a real win
19:23:50 <dons> would be worth looking at what C/gcc does
19:25:25 <modulo7> erm, define that y as y = <applicative term of names defined in Prelude>
19:25:47 <dons> the_lord: what's the question? "how do I export all the functions created by a record?"
19:26:02 <dons> you export the data type, as such: module M ( D(..) ) where ..
19:26:04 <the_lord> dons, I have to type each one?
19:26:12 <dons> well, no, module M where also works
19:26:16 <zeeeee> there wouldn't happen to be something like a postfix notation for function composition would there (for a more shell-pipe-like feel)?
19:26:34 <dons> postfix? you mean, flip (.) perhaps
19:26:37 <dons> ?type (.)
19:26:39 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
19:26:40 <dons> ?type flip (.)
19:26:41 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
19:26:52 <Korollary> $ looks like shell-pipes somewhat
19:26:58 <plidle-wiidle> hey
19:27:06 <plidle-wiidle> how can haskell help me build a scheduluer?
19:27:14 <the_lord> dons: but if I put module M where it exports some things I dont want to be exported
19:27:15 <dons> > let (.|.) = flip (.) in (id .|. map toUpper) "haskell"
19:27:16 <lambdabot>  "HASKELL"
19:27:34 <dons> plidle-wiidle: you'd just write it. perhaps look at the House OS scheduler
19:27:59 <u221e> dons, how do I check that it's legal?
19:28:12 <zeeeee> dons: holy cow, my head is spinning
19:28:23 <modulo7> ?type let m x = x x in m
19:28:24 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
19:28:24 <lambdabot>    Expected type: t
19:28:31 <dons> u221e: well, you look at the spec, and make sure you don't do anything they say you really aren't allowed to do.
19:28:36 <zeeeee> that's awesome
19:29:31 <Korollary> > id $ map toUpper "yes"
19:29:32 <lambdabot>  "YES"
19:29:46 <dons> yeah, usually we just use $
19:30:22 <dons> >>= also behaves like | for monadic operations
19:30:32 <u221e> dons, all I can find it says about it is that the output must match the file listed.
19:30:32 <dons> print >>= mapM_ ... 
19:30:40 <u221e> Unless there is some other spec page
19:30:41 <dons> u221e: yeah. and the range. 
19:30:47 <dons> so it seems quite flexible
19:30:48 <u221e> yes
19:30:51 <dons> some are far more strict
19:31:29 <zeeeee> does lambdabot use ghc or hugs?
19:31:47 <zeeeee> and does this mean $ = flip (.)?
19:32:03 <dons> no, $ is: f $ x = f x
19:32:10 <dons> lambdabot uses ghc
19:32:23 <dons> actually, not really, it uses runplugs, over ghc.
19:32:52 <Korollary> Anybody here tried C# transactional memory (SXM)?
19:33:18 <Korollary> umm, I guess there must be a c# channel where I could ask this
19:33:28 <u221e> Is there a function that would print the actual bytes of a Word32?
19:33:32 <wolverian> #C# is cute :)
19:33:45 <dons> u221e: show?
19:33:55 <dons> oh, no. you'd need to shift the bytes off one at a time.
19:34:09 <dons> using
19:34:14 <dons> ?hoogle shift
19:34:15 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
19:34:15 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
19:34:15 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
19:34:35 <dons> ?hoogle (.&.)
19:34:36 <lambdabot> Did you mean: (.&.)
19:34:37 <lambdabot> Prelude.undefined :: a
19:34:37 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:34:39 <dons> ?hoogle .&.
19:34:39 <lambdabot> Data.Bits.(.&.) :: Bits a => a -> a -> a
19:34:41 <Korollary> Blah. #csharp has one person in it.
19:35:11 <zeeeee> haha
19:35:15 <zeeeee> i'm surprised that exists
19:35:23 <wolverian> Korollary, ##csharp?
19:35:26 <zeeeee> er, maybe it doesn't
19:36:03 <Korollary> wolverian: nada
19:36:16 <wolverian> there are 99 people there
19:36:19 <wolverian> that's not good enough?
19:36:22 <Korollary> oh my
19:36:22 <modulo7> > let f n = if n==0 then 0 else 1+f(n-1) in f (10^100)
19:36:25 <lambdabot>  Exception: stack overflow
19:36:26 <Korollary> why dont I see any
19:36:47 <wolverian> you're on ##csharp, as in, two #s?
19:36:55 <wolverian> and on freenode? ;)
19:37:14 <Korollary> yes. irssi lies to me.
19:37:20 <wolverian> naughty.
19:37:30 <wolverian> try parting #C# explicitly 
19:38:44 <modulo7> > let f n = if n==0 then 23 else f(n-1) in f(10^100)
19:38:47 <lambdabot> Terminated
19:38:56 <zeeeee> can i bring up documentation (e.g., a human language description of what 'words' does) from the interpreter or from the shell? or do i need to browse to the haskell site and search the html?
19:39:03 <plidle-wiidle> house os scheduler
19:39:35 <dons> @docs Data.List
19:39:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
19:39:38 <dons> zeeeee: ^^
19:39:52 <dons> otherwise, you have the type information, which gives you some hints
19:39:55 <dons> ?type words
19:39:56 <lambdabot> String -> [String]
19:40:03 <dons> > words "a b  c     c"
19:40:04 <lambdabot>  ["a","b","c","c"]
19:40:30 <dons> and the src, even
19:40:31 <dons> @fptools Data.List
19:40:32 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
19:40:44 <wolverian> adding haddock to ghci would be nice though 
19:40:54 <zeeeee> dons: but if i'm looking for (eg) ".", it's a pain to find it on that html page
19:41:02 <dons> right
19:41:16 <dons> you can do :info (.) though
19:41:22 <dons> and i'd install the docs locally
19:41:36 <dons> also, it's useful to install the library src locally, run hasktags over it,
19:41:43 <dons> and then let your editor find the definition
19:41:57 <dons> Prelude> :info (.)
19:41:57 <dons> . :: (b -> c) -> (a -> b) -> a -> c     -- Imported from GHC.Base
19:41:57 <dons> infixr 9 .
19:42:01 <dons> for example
19:42:01 <zeeeee> dons: holy cow...what editor does that??
19:42:02 <dons> then
19:42:05 <dons> ?docs GHC.Base
19:42:06 <lambdabot> GHC.Base not available
19:42:11 <dons> bah, you know where to look
19:42:16 <dons> zeeeee: vim does, so does emacs
19:42:24 <dons> i'm sure many others
19:42:30 <u221e> There should be a function for Data.Bits to convert them into a list of Chars.
19:42:51 <zeeeee> dons: ahh, a la ctags
19:42:54 <the_lord> love Haskell!!!
19:43:02 <zeeeee> haha
19:43:06 <the_lord> machineFromName :: String -> [Maquina] -> Maybe Maquina
19:43:06 <the_lord> machineFromName name (maq:sig)
19:43:06 <the_lord>         | name == mName maq = Just maq
19:43:06 <the_lord>         | otherwise = machineFromName id sig
19:43:06 <the_lord> machineFromName [] = Nothing
19:43:08 <the_lord> ==
19:44:13 <the_lord> machineFromName name maqs = find ((==name).mName) maqs
19:44:19 <the_lord> :D
19:44:21 <wolverian> is it common to always give a type for functions, even if it's trivial? 
19:44:53 <Korollary> no
19:45:34 <dons> > let showify :: Int -> [Data.Word.Word8] ; showify w = (fromIntegral (w `shiftR` 24)) : (fromIntegral ((w `shiftR` 16) .&. 0xff)) : (fromIntegral ((w `shiftR` 8)  .&. 0xff)) : (fromIntegral (w .&. 0xff)) : [] in showify 123124441
19:45:35 <lambdabot>  [7,86,186,217]
19:45:36 <wolverian> do the hierarchical libraries do it? just wondering, because apparently hasktags doesn't index functions without signatures 
19:45:57 <dons> u221e: see above ;)
19:46:17 <dons> > let showify :: Int -> [Data.Word.Word8] ; showify w = (fromIntegral (w `shiftR` 24)) : (fromIntegral ((w `shiftR` 16) .&. 0xff)) : (fromIntegral ((w `shiftR` 8)  .&. 0xff)) : (fromIntegral (w .&. 0xff)) : [] in showify 0xff
19:46:18 <lambdabot>  [0,0,0,255]
19:47:32 <lisppaste2> offby1 pasted "Criticisms appreciated!" at http://paste.lisp.org/display/22431
19:47:45 <offby1> it's my first Haskell program ... be gentle ...
19:47:57 * dons peeks
19:48:21 <dons> oh, you'd write these on separate lines: primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0]
19:48:54 <dons> as in:
19:48:55 <dons> primes = sieve [2..]
19:48:55 <dons>     where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0]
19:49:12 <dons>              | True = 1
19:49:13 <dons> should be
19:49:17 <dons>             | otherwise = 1
19:49:34 <dons> no need for parens here: toLower (c)
19:49:39 <dons> just write: toLower c
19:50:01 <modulo7> > let x = 0.0 / 0.0 in  x /= x  {- !!! -}
19:50:02 <lambdabot>  True
19:50:21 <dons> generally Haskell hackers would write: charPrime  over char_prime
19:50:28 <dons> > 1.1 + 2.2 -- the mysteries of the fpu
19:50:29 <lambdabot>  3.3000000000000003
19:50:41 <dons> > 0.0 / 0.0
19:50:42 <lambdabot>  NaN
19:50:47 <dons> anyway, you can't compare NaNs
19:51:00 <dons> > NaN == NaN -- i think
19:51:00 <lambdabot>  Not in scope: data constructor `NaN'
19:51:04 <dons> bah on that
19:51:14 <zeeeee> dons: i'm still trying to decipher what happened with the (.$.) above...is that basically what i want for piping (instead of defining my own)?
19:51:43 <modulo7> unfortunately, this breaks general-purpose functions like stop_after_first_repetition :: Eq a => [a] -> [a]
19:51:53 <dons> zeeeee: I think $ is what you want, probably
19:52:08 <dons> though you want it to be (f1 | f2 | f3) input, yeah?
19:52:12 <zeeeee> dons: so let $$ = flip $?
19:52:18 <dons> instead of f3 (f2 (f1 input))
19:52:34 <zeeeee> dons: right
19:52:36 <dons> so perhaps, f1 .|. f2 .|. f3 $ input would be ok
19:52:43 * offby1 holds a poll: figure out what language he _normally_ codes in
19:53:34 <Korollary> offby1: not java. possibly ocaml
19:53:34 <zeeeee> dons: is Data.Bits.(.|.) a red herring for me?
19:53:46 <offby1> Korollary: not even close!
19:53:46 <Korollary> or C
19:53:57 <offby1> Korollary: C, a long time ago; hardly any any more
19:53:57 <dons> zeeeee: yeah , sorry. .|. in data.bits in unrelated.
19:54:04 <dons> perhaps try .| or >| or something
19:54:48 <edwardk> piping as in shell piping?
19:54:49 <Korollary> offby1: I can't guess from what I see. underscores are common among ocaml'ers.
19:54:50 * edwardk wakes up
19:54:56 <offby1> Korollary: Lisp and Perl
19:55:05 <u221e> Damn, it's slower... ;)
19:55:38 <Korollary> offby1: well, then that's a lot of type annotations by a formerly untyped programmer, eh?
19:56:12 <zeeeee> dons: i'm having trouble defining these, i keep getting parse errors...are they really valid function names?
19:56:17 <offby1> Korollary: actually Common Lisp allows type annotations, and I used them in the CL version of this program.  Sped it up a lot.
19:56:28 <dons> zeeeee: using:
19:56:29 <dons> infixr 1 |>
19:56:29 <dons> (|>) = flip (.)
19:56:31 <dons> we can have:
19:56:32 <Korollary> ah, right
19:56:36 <dons> ord |> (+1) |> (*2) $ 'x'
19:56:39 <dons> which is nice
19:56:56 <offby1> (in fact, of the various languages I've written this in, CL is _by far_ the fastest, even though I spent very little time optimizing it)
19:57:25 <zeeeee> dons: | doesn't seem to be used; is that bad for any reason?
19:57:36 <dons> well, it's guard syntax
19:57:42 <zeeeee> oh
19:57:43 <zeeeee> duh
19:57:43 <zeeeee> haha
19:58:33 <Korollary> offby1: sml or ocaml should perform similarly. Haskell is a totally different animal, being lazy.
19:58:57 <dons> though its performance is around the same. i.e. very good
19:59:01 <offby1> I actually assumed Haskell would be faster than it was -- it was merely as fast as C++
19:59:04 <dons> hooray for compiled fp
19:59:20 <dons> offby1: there's probably some more profiling and strictness checking to look at
20:00:01 <offby1> dons: I'd be interested in comments about that.
20:00:28 <offby1> I've profiled, and (as I expected, since I've profiled the same algorithm many times before, in other languages) most of the time is spent doing bignum division.
20:00:32 <dons> since we average 1.3x the speed of C in the shootout, as does SML and OCaml, with C++ back at 1.6x C, I think its reasonable to expect, given enough time and effort, to reach such a point
20:00:43 <offby1> I don't know how to speed that up, nor to reduce the number of divisions I need to do.
20:01:01 <SamB> so, is there some wonderful bignum division algorithm we could use?
20:01:14 <offby1> I assume ghc is already linking with gmp, which is pretty damned fast.
20:01:19 <dons> right
20:01:28 <offby1> you are not gonna do better than that.
20:01:37 * offby1 runs ldd
20:01:42 <offby1> yup
20:01:42 <dons> at some point you need to reach the core output of ghc, and then look at the C generated
20:01:47 <zeeeee> is it ok to use # for comments instead of -- or is the latter more standard/preferred? (i only see the latter mentioned in tutorials and such)
20:01:51 <offby1> bah; I'm not _that_ interested :-)
20:02:03 <dons> zeeeee: well, you could try to use #
20:02:06 <dons> but it won't work ;)
20:02:18 <zeeeee> dons: oh, odd...it worsk for the shabang
20:02:21 <zeeeee> *works
20:02:22 <dons> anyway, -- is much less noisier on the eyeballs
20:02:27 <dons> shebangs are super-specia
20:02:29 <dons> l
20:02:30 <zeeeee> haha
20:02:32 <zeeeee> got it
20:02:50 <eivuokko> Well, # being operator, can't really be on first column anyway, can it?
20:02:56 <dons> offby1: you could write:
20:02:57 <dons> empty b = (b == 1)
20:02:58 <eivuokko> I think it also works for #line in ghc.
20:02:59 <dons> better as:
20:03:01 <dons> @pl empty b = (b == 1)
20:03:01 <lambdabot> empty = (1 ==)
20:03:04 <dons> :)
20:03:12 * offby1 ponders emptiness
20:03:19 <SamB> well, it would be too easy to mix up comments and preprocessor directives...
20:03:26 <dons> similarly,
20:03:29 <offby1> dons: OK, that went right over my head.
20:03:29 <dons> @pl bags_equal b1 b2 = (b1 == b2)
20:03:29 <lambdabot> bags_equal = (==)
20:03:33 <offby1> oh, I see.
20:03:45 <offby1> just return a partial function
20:03:50 <dons> hooray for the all dancing, all refactoring irc bot
20:04:06 <dons> well, don't bother with the redundant arguments
20:04:26 <dons> and since bags_equal is just ==, you should just use that, ==
20:04:29 <offby1> see, I'd have done that if I were writing Lisp.
20:04:40 <u221e> Is there a way to create a list of a preset size, so it doesn't have to alloc any memory as it goes?
20:04:48 <dons> u221e: hmm. use an array
20:04:53 <modulo7> @pl f x = x
20:04:53 <lambdabot> f = id
20:04:57 <lisppaste2> zeeeee pasted "my first semi-useful program in haskell...can it be better (faster/shorter/cleaner/prettier/...)?" at http://paste.lisp.org/display/22432
20:05:07 <Korollary> u221e: as it goes where?
20:05:30 <offby1> dons: gaah.  ``bags_equal = (==)''  => ``Ambiguous type variable `a' in the constraint:''
20:05:37 <modulo7> @pl s x y z = x z (y z)
20:05:38 <lambdabot> s = ap
20:05:38 <u221e> By cons'ing... it does the alloc memory for each new element
20:07:12 <u221e> Ok, i'll read about arrays
20:07:52 <dons> zeeeee: I'd write that module you posted as:
20:07:53 <dons> main = interact (unlines . map go . lines)
20:07:53 <dons>     where
20:07:54 <dons>         go = show . (+1) . read . head . tail . words
20:08:07 <vininim> > nonsense :: ( [a] -> [a] ) -> ( ([a],[a]) -> ([a],[b]))
20:08:07 <lambdabot>  Not in scope: `nonsense'
20:09:50 <offby1> I don't recall seeing a simple explanation of the significance of whitespace in Haskell.  Anyone know of one?
20:10:13 <jgrimes> offby1, http://en.wikibooks.org/wiki/Haskell/Indentation
20:10:28 <modulo7> @pl f x = x (f x)
20:10:28 <lambdabot> f = fix (ap id)
20:10:29 <offby1> jgrimes: far out!
20:10:34 <jgrimes> :p
20:10:46 <offby1> (or, "thank you", for the '60s-challenged)
20:10:56 <jgrimes> you can also see the haskell report, section 2.7 which is on layout
20:11:10 <jgrimes> (linked at the bottom of that wikibook page)
20:13:13 <modulo7> @pl m x = x x
20:13:14 <lambdabot> m = join id
20:13:25 <modulo7> ?type join
20:13:26 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
20:14:33 <lispy> @type join id
20:14:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
20:14:34 <lambdabot>    Expected type: a -> a -> a1
20:14:48 <lispy> interesting
20:15:01 <lispy> @type let m x = x x in m
20:15:02 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:15:02 <lambdabot>    Expected type: t
20:15:50 <modulo7> @pl z a b c d e f = d e a d b e e f b a b e
20:16:05 <lambdabot> z = (const .) . flip flip id . ((flip . ((ap . (flip .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . join (flip . ((flip . ((flip . (flip .)) .)) .) . join . ((flip . ((flip . (flip .)) .))
20:16:05 <lambdabot> .) . flip flip id . (flip .) . ((ap .) .) . flip flip id . (flip .) . ((ap .) .) . flip . (flip .) . join . (flip .) . flip flip)
20:16:05 <lambdabot> optimization suspended, use @pl-resume to continue.
20:16:32 <modulo7> hooray :D
20:16:37 <lispy> nice
20:16:48 <dons> mmm. term-rewrite-arific!
20:17:17 <modulo7> in which module is  ap  anyway?
20:17:26 <lispy> i like in windows with ms's compiler in debug mode it sets dead pointers to 0xdeadbeef
20:17:45 <Korollary> @index ap
20:17:46 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
20:17:46 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
20:17:48 <lispy> then whenever you see 0xdeadbeef in the debug pane you know you have trouble
20:18:03 <modulo7> ?type ap
20:18:04 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
20:18:21 <modulo7> ?type s x y z = x z (y z) in s
20:18:22 <lambdabot> parse error on input `='
20:18:40 <lispy> ?type let s x y z = x z (y z) in s
20:18:41 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
20:19:06 <modulo7> wtf .... s = ap  ??
20:19:40 <eivuokko> lispy, My x86-asm-monad does so too  ;)
20:20:14 <lispy> it's a mooonad
20:20:16 <dons> modulo7: using the (-> a) monad, I suspect
20:21:18 <lispy> @type liftM id `ap` [1]
20:21:19 <lambdabot>   Couldn't match `(->) (a -> a1)' against `[]'
20:21:19 <lambdabot>    Expected type: (a -> a1) -> a
20:21:31 <lispy> @type liftM id
20:21:32 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
20:21:40 <lispy> ah
20:22:05 <lispy> so what would be an example of m (a -> b) ?
20:22:19 <lispy> @type [id]
20:22:20 <lambdabot> forall a. [a -> a]
20:22:33 <lispy> @type [id] `ap` [1]
20:22:35 <lambdabot> forall a. (Num a) => [a]
20:23:26 <lispy> @type return (+1) `ap` return 5
20:23:27 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
20:23:53 <u221e> Is there a map function for arrays?
20:24:07 <dons> map, perhaps?
20:24:14 <dons> map /elems
20:24:32 <dons> actually, usually I write a list comprehension
20:24:50 <dons> [ f (arr ! n) | n <- [0..end] ]
20:25:03 <dons> unless you want _mutable_ arrays, but that's another story
20:25:21 <lispy> @hoogle (a -> b) -> Array i a -> Array i b
20:25:22 <lambdabot> No matches, try a more general search
20:28:13 <dons> ?type accum
20:28:14 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
20:28:22 <dons> ?type (//)
20:28:23 <lambdabot> forall e i. (Ix i) => Array i e -> [(i, e)] -> Array i e
20:28:32 <dons> ?type ixmap
20:28:33 <lambdabot> forall e i j. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
20:29:06 <lispy> dons: i bet u221e wants an inplace update though
20:29:19 <dons> yeah, mutable arrays.
20:29:25 <dons> so really he probably wants Data.Map 
20:29:47 * lispy should look at Data.Map sometime
20:30:10 <sjanssen> well, if you're just mapping on every element, list is better than Data.Map
20:30:14 <sjanssen> less memory consumption
20:30:27 <dons> true
20:31:32 <lispy> hmm..and i bet mapping is actually pretty memory efficient
20:31:45 <lispy> because the old cons get tossed and replaced by the new ones
20:31:55 <lisppaste2> zeeeee pasted "my second app...i just can't hack it! what's the problem? error messages are impossible to decipher" at http://paste.lisp.org/display/22435
20:32:03 <sjanssen> lispy: especially if you're lucky and GHC deforests the intermediate lists
20:32:21 <zeeeee> dons: i based this off your last suggestion, but i'm not sure what the problem is
20:32:28 <zeeeee> it's trying to do something a bit more complicated though
20:32:36 <dons> zeeeee: firstly, you don't need to write 'module Main where', for the main module
20:32:47 <dons> also, 'do' isn't required if there's only one statement
20:33:15 <zeeeee> dons: hm, when does module Main need to be specified then?
20:33:38 <dons> if you have multiple modules
20:33:44 <dons> @pl \x -> x / (mymax n)
20:33:44 <lambdabot> (/ mymax n)
20:34:16 <dons> your error is to do with /
20:34:23 <dons> do you want floating point or integer division?
20:34:30 <zeeeee> dons: floating point
20:34:38 <lispy> zeeeee: if you broke things up more (for example by adding more things in the where clause) it would be easier to think about
20:35:05 <zeeeee> lispy: i'm not sure i follow...
20:35:07 <dons> ?l \x -> (fromIntegral x) / mymax n
20:35:08 <lambdabot> Maybe you meant: lambda last learn leave libsrc list listchans listmodules localtime localtime-reply log-email lojban . pl v
20:35:11 <dons> ?pl \x -> (fromIntegral x) / mymax n
20:35:12 <lambdabot> (/ mymax n) . fromIntegral
20:35:43 <sjanssen> it seems your are performing word on your input twice, that doesn't really make sense
20:35:53 <lispy> zeeeee: you might add something like, normalize x = (/ mymax n) . fromIntegral
20:36:07 <zeeeee> sjanssen: i'm not sure how else it's possible to do the normalization since you'd need to first find what the max is
20:36:15 <lispy> zeeeee: without the explict x
20:36:59 <dons> mm. how is 'max n' going to work?
20:37:04 <dons> ?type max
20:37:06 <lambdabot> forall a. (Ord a) => a -> a -> a
20:37:17 <dons> ?type maximum
20:37:18 <lambdabot> forall a. (Ord a) => [a] -> a
20:37:22 <dons> I suppose you want?
20:37:30 <zeeeee> oh
20:37:34 <zeeeee> dons: yeah
20:37:43 <lispy> zeeeee: also you might want to name this quantity: read . head . tail . words $ input, because that might help the reader understand why you apply those transformations
20:37:54 <dons> so, something like:
20:37:55 <dons> main = interact ( unlines . map norm . lines )
20:37:55 <dons>     where
20:37:55 <dons>         norm n = show . (/ mymax n) . fromIntegral . read . head . tail . words $ n
20:37:58 <dons>         mymax  = fromIntegral . maximum . read . head . tail . words
20:38:13 <dons> I think, though it's getting a bit complex
20:38:22 <dons> you'll want to break it up more, the way sjanssen was suggesting
20:38:31 <dons> too many read . head . tail .words 
20:38:54 <lispy> oh and that $ is not needed
20:39:00 <dons> ?
20:39:07 <dons> sure it is. isn't it?
20:39:10 <zeeeee> lispy: i think iti is
20:39:11 <lispy> read . head . tail . words $ input
20:39:18 <lispy> oh
20:39:18 <dons> yeah, it's needed
20:39:24 <lispy> because of the (.)
20:39:27 <sjanssen> actually, $ and input can be dropped
20:39:27 <lispy> yeah i see
20:39:35 <sjanssen> go totally point free
20:39:42 <lispy> treu
20:40:04 <SamB> @pl main = interact ( unlines . map norm . lines ) where norm n = show . (/ mymax n) . fromIntegral . read . head . tail . words $ n; mymax  = fromIntegral . maximum . read . head . tail . words
20:40:04 <lambdabot> (line 1, column 61):
20:40:05 <lambdabot> unexpected "="
20:40:05 <lambdabot> expecting variable, "(", operator or end of input
20:40:06 <zeeeee> wait...it *can* be dropped? but we're using the input twice, right?
20:40:09 <SamB> ack
20:40:15 <SamB> someone needs to add "where" to pl
20:40:18 <dons> sure, you can, it'll just get hard to read.
20:40:26 <dons> ?pl f x = x / g x
20:40:26 <lambdabot> f = ap (/) g
20:41:04 <lispy> zeeeee: also, when you start adding more things in the where clause you might consider giving them type signatures
20:41:22 <lispy> as you program in haskell more you'll find that the types give you clues as to what the code is doing
20:41:51 <zeeeee> when i try running this i get "*** Exception: Prelude.read: no parse"
20:42:09 <zeeeee> but my file only has integers
20:42:09 <dons> yeah, since its broken with all those reads
20:42:11 <SamB> maybe you need a typesig on the read thing?
20:42:38 <SamB> or perhaps you should invest in a real parser ;-)
20:43:01 <zeeeee> i hope there's a cleaner way to write this...i had a bunch of code repetition
20:43:19 <SamB> a parser!
20:43:29 <lispy> zeeeee: breaking things into little pieces that you understand is often a great way to make things cleaner
20:43:30 <SamB> parser combinators!
20:43:44 <zeeeee> well, before i learn about parser combinators, i wouldn't mind getting these basics down
20:43:46 <SamB> parser utility functions!
20:44:00 <lispy> utility function parsers!
20:44:01 <SamB> well, parser combinators might be easier than whatever that mess of yours is
20:44:05 <dons> zeeeee: what's the problem specification again?
20:44:25 <SamB> I honestly can't tell if they are appropriate ;-)
20:44:26 <zeeeee> i put it in the comments of my paste
20:44:39 <lispy> regexp would be appropirate
20:44:42 <zeeeee> but basically, normalize the second field against the max second-field value in all lines.
20:44:58 <dons> ah, ok.
20:45:20 <wolverian> argh. so, ghci.vim sucks
20:45:45 <lispy> oh, actually a regex might even be overkill...
20:45:50 <zeeeee> my program also discards the other fields, which is bad
20:45:59 <lispy> words/unwords should be about perfect
20:46:21 <zeeeee> lispy: but you don't know how many words per line
20:46:29 <zeeeee> i just happened to have 3 in that example
20:46:37 <zeeeee> but it could be variable
20:46:51 <lispy> but you only ever care about the second column right?
20:47:00 <zeeeee> lispy: ya
20:47:09 <lispy> > words "1 two three four"
20:47:10 <lambdabot>  ["1","two","three","four"]
20:47:20 <Dino_> I'm reading YAHT, the section on a Simple State Monad. And it just got to this type syn declaration: type State st a = st -> (st, a)
20:47:30 <wolverian> does ghc provide a nicer interface for introspecting from outside than ghci and parsing its output?
20:47:33 <zeeeee> lispy: i do use words already, though...
20:47:59 <lispy> > read ((words "whatever 2 three four") !! 1) :: Int
20:48:00 <Dino_> The right side of that looks like a function type with the ->
20:48:00 <lambdabot>  2
20:48:28 <zeeeee> lispy: my attempt is here: http://paste.lisp.org/display/22435
20:48:39 <lispy> Dino_: yeah, it's like st is going to update the state
20:48:53 <lispy> Dino_: but not quite
20:49:13 <lisppaste2> zeeeee annotated #22435 with "revised...but still doesn't work (parse exception)" at http://paste.lisp.org/display/22435#1
20:49:14 <lispy> i meant to say, the right hand side is a function that takes the state and gives a new state and some value a
20:49:37 <Dino_> I didn't know the type synonym can do things like that.
20:49:51 <Dino_> Ok, I'm not even sure what's it really doing there.
20:49:56 <wolverian> I assume this "GHC API" thing is what I want :)
20:50:33 <lispy> zeeeee: let's focus on mymax, where mymax = fromIntegral . maximum . read . head . tail . words
20:50:43 <zeeeee> ok
20:51:13 <lispy> > (head . tail . words) "One Two Three"
20:51:13 <lambdabot>  "Two"
20:51:36 <lispy> zeeeee: seems like we could name the function (head . tail . words)
20:51:50 <lispy> @pl \x -> head . tail . words $ x
20:51:51 <lambdabot> head . tail . words
20:51:54 <lispy> hmm...
20:52:06 <Dino_> Oh, ok, so then the example is defining a function: returnState :: a -> State st a
20:52:41 <Dino_> So if you do the straight subst, it's really :: a -> st -> (st, a)
20:52:41 <lispy> zeeeee: let's call it, columnTwo = head . tail . words
20:52:45 <zeeeee> ok
20:53:13 <lispy> so then what does (read . columnTwo) do?
20:53:18 <lispy> (what is the type)
20:53:28 <zeeeee> i'm guessing Int
20:53:39 <zeeeee> or Num
20:53:46 <zeeeee> or Integer
20:53:48 <lispy> @type read . head . tail . words
20:53:49 <lambdabot> forall a. (Read a) => String -> a
20:54:07 <zeeeee> so it could be anything...
20:54:15 <lispy> so it takes a string and returns something reable (in this case a number)
20:54:30 <lispy> the thing to note is that it returns one thing not a list
20:54:50 <zeeeee> right
20:54:52 <lispy> @type maximum
20:54:53 <lambdabot> forall a. (Ord a) => [a] -> a
20:55:00 <zeeeee> bah
20:55:02 <lispy> maximum seems to take a list
20:55:02 <zeeeee> i see
20:55:05 <lispy> :)
20:55:19 <dons> zeeeee: here you go, i think:
20:55:21 <dons> main = interact $ unlines . norm . lines
20:55:21 <dons>     
20:55:21 <dons> norm ls = map (show . (/ m)) nums
20:55:21 <dons>     where nums   = map field2 ls
20:55:23 <dons>           field2 = read . head . tail . words
20:55:26 <dons>           m      = maximum nums
20:55:55 <dons> compiled, it produces: 
20:55:55 <lispy> notice how dons split things up
20:55:55 <dons> $ ./a.out 
20:55:55 <dons> 1 2 3 
20:55:55 <dons> 4 5 6
20:55:55 <dons> 0.4
20:55:57 <dons> 1.0
20:56:41 <lisppaste2> sjanssen annotated #22435 with "preserves other fields" at http://paste.lisp.org/display/22435#2
20:58:21 <wolverian> wow. I wish the ghc api was documented. :)
20:58:24 <zeeeee> ok...wow
20:58:34 <dons> wolverian: indeed we all do :/
20:58:37 <zeeeee> so should i use let instead of where?
20:58:51 <dons> zeeeee: it depends. let is less common, though used widely in monadic code
20:58:58 <lispy> i prefer 'where' whenever i can use it
20:59:04 <dons> 'where' is preferred when teaching, too
20:59:23 <sjanssen> hmm, does where work in lambda abstractions?
20:59:37 <sjanssen> > (\x -> z where z = x) 3
20:59:37 <lambdabot>  Parse error
20:59:37 <Cale> The difference between let and where is that 'let' is part of expression syntax, and 'where' is part of declaration syntax.
20:59:46 <lispy> no, but i prefer to write out my lambdas in a where to avoid cluter
20:59:58 <dons> i prefer to @pl my lambdas ;)
21:00:23 <lispy> and then we are all reminded  of
21:00:24 <jgrimes> I have to say... @pl is pretty nifty.
21:00:25 <jgrimes> :p
21:00:31 <zeeeee> @pl?
21:00:31 <lambdabot> (line 1, column 1):
21:00:31 <lambdabot> unexpected end of input
21:00:31 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
21:00:37 <zeeeee> @pl
21:00:38 <lambdabot> (line 1, column 1):
21:00:38 <lambdabot> unexpected end of input
21:00:38 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
21:00:39 <lispy> @pl z a b c d e f = d e a d b e e f b a b e
21:00:46 <lambdabot> z = (const .) . flip flip id . ((flip . ((ap . (flip .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . join . (flip .) . ((flip .) .)
21:00:46 <lambdabot> . (((flip .) .) .) . flip flip id . (flip .) . ((ap .) .) . flip flip id . (flip .) . ((ap .) .) . flip . (flip .) . join . (flip .) . flip flip)
21:00:46 <lambdabot> optimization suspended, use @pl-resume to continue.
21:00:48 <dons> well, that's not such a great case ;)
21:00:55 <sjanssen> @pl-resume
21:01:09 <lambdabot> z = (const .) . flip flip id . ((flip . (liftM2 flip .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . (flip =<< ((flip . ((flip . (flip .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) .
21:01:09 <lambdabot> flip flip id . ((flip . (ap .)) .) . flip flip id . ((flip . (ap .)) .) . flip . (flip .) . join . (flip .) . flip flip)
21:01:09 <lambdabot> optimization suspended, use @pl-resume to continue.
21:01:10 * dons watches top go nuts
21:01:13 <dons> ?pl \x -> (fromIntegral x) / mymax n
21:01:13 <lambdabot> (/ mymax n) . fromIntegral
21:01:20 <lispy> yeah, that's pretty cool
21:01:29 <dons> zeeeee: ^^ see, term-rewriting / refactoring to "pointfree" form
21:01:33 <lispy> it's flip'n fun
21:01:45 <sjanssen> @type \a b c d e f -> d e a d b e e f b a b e
21:01:47 <lambdabot>   Occurs check: cannot construct the infinite type:
21:01:47 <lambdabot>    t = t1 -> t2 -> t -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11
21:01:54 <sjanssen> pssh, that doesn't even type
21:02:10 <dons> yeah, ndm and I have an evil plan for a new @pl, codenamed "dr haskell" that does typechecking as well
21:02:17 <sjanssen> neat
21:02:20 <dons> based on the same term rewriting system as ghc uses for rules
21:02:32 <lispy> fun
21:02:50 <modulo7> is "@pl" meant to allude to "point-free -> pointless" ?
21:02:50 <sjanssen> the inverse of @pl would be neat
21:03:04 <dons> modulo7: right
21:03:09 <dons> ?help pl
21:03:09 <lambdabot> pointless <expr>. Play with pointfree code.
21:03:15 <dons> ?pointless \x -> x
21:03:15 <lambdabot> id
21:03:30 <lispy> @type ($)
21:03:31 <lambdabot> forall b a. (a -> b) -> a -> b
21:03:40 <Korollary> @help djinn
21:03:41 <lambdabot> djinn <type>.
21:03:41 <lambdabot> Generates Haskell code from a type.
21:03:41 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:03:48 <lispy> @pl \f x -> f x
21:03:48 <lambdabot> id
21:03:59 <dons> ?djinn a -> a
21:03:59 <lambdabot> f a = a
21:04:04 <Korollary> @djinn Maybe Int -> Char
21:04:05 <lambdabot> -- f cannot be realized.
21:04:09 <Korollary> lies
21:04:18 <sjanssen> @. pl djinn (a -> b) -> a -> b
21:04:18 <lambdabot> f = id
21:04:25 <dons> has to be parametrically polymorphic, if you want your theorems for free
21:04:32 <dons> ?djinn Maybe a -> a
21:04:32 <lambdabot> -- f cannot be realized.
21:04:36 <dons> ?djinn Maybe a -> b
21:04:36 <lambdabot> -- f cannot be realized.
21:04:38 <dons> bad
21:04:39 <lispy> so why doesn't @pl \f x -> f x === $
21:04:44 <dons> ?djinn a -> Maybe a
21:04:44 <lambdabot> f = Just
21:05:11 <dons> ?. pl djinn a -> Maybe a
21:05:11 <lambdabot> f = Just
21:05:24 <Cale> @djinn Maybe a -> a -> a
21:05:24 <lambdabot> f a b =
21:05:24 <lambdabot>   case a of
21:05:24 <lambdabot>   Nothing -> b
21:05:24 <lambdabot>   Just c -> c
21:05:28 <dons> lispy: no rule for that has been written
21:05:46 <dons> ?djinn Not (Not (Either a (Not a)))
21:05:47 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
21:05:49 <Cale> Good that it tries to use all its assumptions
21:05:54 <dons> yeah
21:06:05 <sjanssen> hmm, what is Not?
21:06:22 <dons> ?djinn-env
21:06:23 <lambdabot> data () = ()
21:06:23 <lambdabot> data Either a b = Left a | Right b
21:06:23 <lambdabot> data Maybe a = Nothing | Just a
21:06:23 <lambdabot> data Bool = False | True
21:06:23 <lambdabot> data Void
21:06:25 <lambdabot> type Not x = x -> Void
21:06:27 <Cale> I remember it used to return something like const id for that one
21:06:47 <dons> i recently updated @djinn. maybe that's changed
21:07:18 <dons> ?djinn Bool-> Bool -> Bool
21:07:19 <modulo7> ?djinn [a] -> [[a]]
21:07:19 <lambdabot> f a b =
21:07:19 <lambdabot>   case a of
21:07:19 <lambdabot>   False -> b
21:07:19 <lambdabot>   True -> False
21:07:19 <lambdabot> -- f cannot be realized.
21:07:26 <dons> no lists
21:07:28 <dons> ?help djinn
21:07:29 <lambdabot> djinn <type>.
21:07:29 <lambdabot> Generates Haskell code from a type.
21:07:29 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:07:34 <dons> ?list djinn
21:07:34 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-ver
21:07:45 <dons> ?djinn-add data ListN a as = Nil | Cons a as
21:07:52 <dons> ?djinn-add type List a = Fix (ListN a)
21:08:01 <dons> ?djinn-env
21:08:01 <lambdabot> data () = ()
21:08:01 <lambdabot> data Either a b = Left a | Right b
21:08:01 <lambdabot> data Maybe a = Nothing | Just a
21:08:01 <lambdabot> data Bool = False | True
21:08:01 <lambdabot> data Void
21:08:03 <lambdabot> type Not x = x -> Void
21:08:05 <lambdabot> type List a = Fix (ListN a)
21:08:07 <lambdabot> data ListN a as = Nil | Cons a as
21:08:13 <dons> ?djinn List a -> ListN a (List a)
21:08:13 <lambdabot> f _ = Nil
21:08:20 <dons> ?djinn  ListN a (List a) -> List a
21:08:20 <lambdabot> -- f cannot be realized.
21:08:34 <dons> ?djinn List a -> Bool
21:08:34 <lambdabot> f _ = False
21:09:06 <dons> oh well
21:09:24 <dons> ?djinn (a -> b) -> (c -> b) -> Either a c -> b
21:09:24 <lambdabot> f a b c =
21:09:24 <lambdabot>   case c of
21:09:24 <lambdabot>   Left d -> a d
21:09:24 <lambdabot>   Right e -> b e
21:09:34 <lispy> your monads for nothing and your theorems for free
21:09:40 <dons> heh
21:13:53 <dons> keep those patches coming, sjanssen 
21:14:12 <Korollary> @index forkIO
21:14:12 <lambdabot> Control.Concurrent
21:17:05 <Pseudonym> ?djinn Not (Not a) -> a
21:17:06 <lambdabot> -- f cannot be realized.
21:17:20 <Pseudonym> ?djinn a -> Not (Not a)
21:17:20 <lambdabot> f a b = b a
21:19:09 <Korollary> forkIO is absurdly convenient
21:19:40 <dons> i remember how amazed i was when i discovered it. imagine: you can fork any io action!
21:19:43 <dons> insane
21:26:29 <Cale> Well, the other surprising thing is that it's just the obvious thing, which makes you wonder why everything else doesn't handle forking that way.
21:27:15 <vegai> like the wonderful way of forking in C
21:27:25 <vegai> pid_t fork(void); 
21:27:46 <sjanssen> well, C doesn't have first class actions like we do, so it has to use a hack
21:28:01 <vegai> well, it could use a function pointer, couldn't it?
21:28:03 <Cale> It does, however, have function pointers
21:28:15 <sjanssen> that's how pthreads handles forking a new thread
21:28:35 <vegai> Cale: or action pointers really...
21:29:05 <Cale> vegai: well, yes, it did pain me to write function there, but that's what they call them :)
21:29:06 <sjanssen> forkIO and fork() are quite different, so it really doesn't make sense to compare the two
21:29:08 <vegai> sjanssen: yeah, I suppose that's a more fair comparison.
21:30:52 <vegai> I wonder how C would like if one added a simple distinction between actions and functions
21:31:04 <vegai> "...would be like..."
21:31:46 <vegai> simple as in "you can't call actions from functions, and that's the whole of the law"
21:32:44 <Cale> well, you'd probably also want to make everything which has a side effect an action too
21:32:49 <Cale> including assignment
21:33:02 <sjanssen> it'd be annoying . . . how do you sum a list of numbers in C without destructive assignment?
21:33:10 <Cale> sjanssen: recursion
21:33:35 <sjanssen> Cale: you'd need tail call support too
21:33:49 <vegai> ...and so the snowball rolls
21:33:59 <vegai> end product: C++++
21:34:04 <Cale> sjanssen: well, that's just compiler brokenness
21:34:21 <sjanssen> and then (hopefully) everybody says: screw this, let's program in Haskell
21:34:29 <vegai> (or C)
21:35:53 <SamB_XP> you'd need GC...
21:37:05 <sjanssen> would we consider dereferencing a pointer to be an action?  what about in the presence of threads?
21:40:30 <Cale> sjanssen: yeah, it'd be very inconvenient
21:44:55 <vegai> @where hope
21:44:56 <lambdabot> http://hope.bringert.net/
21:45:07 <lisppaste2> zeeeee annotated #22435 with "trying to combine the fields, but how do i "flatten" out the inputs to zip?" at http://paste.lisp.org/display/22435#3
21:45:13 <vegai> my own lambdabot answered rather gloomily "I know nothing about hope."
21:45:23 <SamB_XP> heh
21:45:29 <u221e> Hm, not much information about haskell arrays
21:46:41 <jgrimes> u221e, http://www.haskell.org/tutorial/arrays.html
21:46:41 <lambdabot> Title: "A Gentle Introduction to Haskell: Arrays"
21:46:57 <jgrimes> it's got some pretty good information on them
21:47:06 <Korollary> @pl \x -> x - 1
21:47:06 <lambdabot> subtract 1
21:47:15 <Korollary> @index subtract
21:47:15 <lambdabot> Prelude
21:47:19 <Korollary> doh
21:48:51 <u221e> Yes... I already read that
21:49:21 <u221e> Just seems to be copied from the onlinereport...
21:49:37 <sjanssen> u221e: any specific questions?
21:50:35 <u221e> Yes, what are the advantages of an array compared with a list
21:50:42 <u221e> and disadvantages
21:50:57 <sjanssen> arrays have O(1) indexing
21:51:19 <sjanssen> using certain variants like UArrays, you get very small memory use too
21:52:01 <u221e> But to build an array don't you have to pass it a list first?
21:52:08 <sjanssen> however, they're just less convenient than lists
21:52:31 <sjanssen> yeah, I think all the array constructors take lists
21:53:11 <u221e> So how can you save memory if you need to allocate a list in the first place?
21:53:46 <sjanssen> the list can be lazily evaluated
21:54:22 <sjanssen> the short of it: unless you need O(1) indexing, don't use arrays
21:54:49 <u221e> Well, O(1) indexing would be great...
21:55:21 <u221e> Concidering my current list is 9000000 elements in length.
21:55:38 <sjanssen> and you index that list?
21:55:54 <sjanssen> if you lazily generate and consume that list, you're fine
21:56:45 <u221e> What I don't like is how I make the list though.
21:57:13 <u221e> I create it in a recusive call that cons it's results together
21:57:58 <u221e> Each cons would have to allocation more memory to grow the list.
21:58:08 <sjanssen> recursive like "x : recursive call" ?
21:58:27 <sjanssen> or recursive like "tailRecursive (x:accumulator)"
21:59:07 <sjanssen> the first is good, the second bad
21:59:08 <u221e> I'm using an accumulator, yes.
21:59:12 <u221e> Why?
21:59:29 <SamB_XP> stack smashing
21:59:36 <SamB_XP> I think...
21:59:37 <sjanssen> the first lets you consume the list lazily
21:59:45 <SamB_XP> or at least it uses a lot of memory ;-)
22:00:02 <sjanssen> the second makes you actually generate that entire list and keep it in memory
22:00:27 <u221e> But I need the entire list anyway.
22:00:49 <SamB_XP> at one time?
22:00:55 <u221e> Yes
22:01:03 <u221e> To print it to a file
22:01:05 <sjanssen> oh, that is problematic
22:01:16 <u221e> Or stdout in this case
22:01:22 <sjanssen> actually, you can print it out lazily
22:01:48 <u221e> I thought tail recursion was a good thing...
22:02:17 <sjanssen> u221e: with lazy evaluation, things become a bit more muddy
22:02:19 <SamB> well... not when you are building datastructures in a lazy language
22:02:35 <SamB> its great for replacing GOTO, though ;-)
22:03:20 <sjanssen> u221e: do you have a problem description, or code that we can see?
22:03:55 <u221e> Still, what about the matter of memory allocation? One big alloc is better then 9000000 small o nes
22:04:19 <SamB> er...
22:04:23 <SamB> what one big alloc?
22:04:24 <sjanssen> GHC is very efficient at doing does little allocations -- they're very typical in Haskell code
22:04:26 <SamB> and what makes you think so?
22:04:37 <SamB> especially since maybe it never will have to allocate those cons cells...
22:05:24 <u221e> I have no idea how GHC actually works... could you explain please?
22:05:28 <glguy> just as a learning exercise I've been trying to implement a breadth first tree spanning algorithm. given: data Tree a = Node a [Tree a]; I've gotten this far: breadthFirst t = concat $ iterate (concatMap children) [t]
22:05:38 <glguy> obviously this never ends because there is no stop case
22:05:56 <glguy> should I just implement my own concat that stops when it hits an empty list?
22:06:02 <glguy> or is there a better way to do this?
22:06:33 <glguy> (and i left out the labels on my data type, sorry: data Tree a = Node { label::a, children::[Tree a]}
22:07:01 <Korollary> lisppaste2: url
22:07:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:08:52 <sjanssen> u221e: do you understand lazy evaluation?
22:09:36 <u221e> The concept? Yes.
22:10:54 <Korollary> @index times
22:10:55 <lambdabot> bzzt
22:10:58 <Korollary> @index while
22:10:58 <lambdabot> bzzt
22:10:59 <sjanssen> if you consume a list lazily, there's only one cons cell in memory at any given time, so the burden on allocation isn't so bad
22:11:02 <Korollary> good
22:11:07 <lisppaste2> NxndnhFEuA pasted "NxndnhFEuA" at http://paste.lisp.org/display/22437
22:11:23 <Korollary> rofl
22:13:36 <sjanssen> there are even special cases where an intermediate list isn't created at all
22:14:05 <u221e> sjanssen, do you know any articles specifically about taking advatage of the lazy aspect of haskell?
22:14:34 <sjanssen> "sum [1..1000] :: Int" won't create a single cons cell in ghc and -O, it turns into a loop
22:15:12 <lisppaste2> glguy pasted "Breadth First Feedback" at http://paste.lisp.org/display/22439
22:15:48 <u221e> Hm...
22:16:02 <sjanssen> u221e: I'm afraid I don't know of any
22:16:12 <sjanssen> that would be a nice resource though
22:16:24 <glguy> u221e I'll link you to a good paper that I just read
22:16:51 <glguy> Search google for: Why Functional Programming Matters
22:16:58 <glguy> and either choose the HTML or PDF results
22:17:02 <glguy> depending on your preferences
22:17:10 <glguy> there are some excellent lazy evaluation examples
22:17:49 <glguy> specifically, the examples cover numerical methods, and minimax searching of game trees
22:20:42 <u221e> I'm wondering how I can make a list in the from of "x : recursive call" when I don't have an initial value...
22:21:31 <Cale> u221e: hm?
22:22:36 <u221e> As in I don't have an x to cons the with the result initialy... in fact it takes 8 calls of the recursive function to generate a single element.
22:23:10 <glguy> u221e: sounds like two different functions to me...
22:23:44 <u221e> Hm... probably.
22:23:52 <Cale> u221e: you can have the function return a bunch of its initial results and pass them back in as parameters
22:24:02 <Cale> u221e: as long as it's well-defined
22:24:34 <sjanssen> also, the function can be tail recursive sometimes, and yield an element other times
22:25:02 <Cale> yes, that's also quite possible
22:25:29 <Cale> and certainly more common :)
22:25:41 <Cale> I'm just unclear on what exactly you're doing
22:26:29 <glguy> Cale: it's been a long time, could you please remind me how to ask lambdabot for the point-free version of a function?
22:26:59 <sjanssen> @pl \x y z -> x z y
22:26:59 <lambdabot> flip
22:27:08 <Cale> @pl y f = f (y f)
22:27:09 <lambdabot> y = fix (ap id)
22:27:36 <glguy> afraid that when I ask for \x -> [x] that it will just say return
22:27:41 <glguy> @pl \x -> [x]
22:27:41 <lambdabot> return
22:27:44 <glguy> bah
22:27:55 <Cale> hehe
22:28:04 <Cale> or (:[])
22:28:07 <glguy> that'd require me to specify the type signature of my function
22:28:11 <glguy> :[] will do :)
22:28:47 <Cale> or you can just enclose whatever in []'s, unless you're writing in points-free style to begin with
22:29:03 <glguy> I was mostly just curious
22:29:26 <Cale> return is usually good enough though
22:29:48 <Cale> since usually there will be enough type context in the end to determine which type you mean
22:30:13 <glguy> in this case  Isuppose that there was
22:34:40 <glguy> @pl 
22:34:40 <lambdabot> (line 1, column 1):
22:34:40 <lambdabot> unexpected end of input
22:34:40 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
22:34:42 <glguy> ...
22:34:49 <glguy> @pl \f x -> f x x
22:34:50 <lambdabot> join
22:35:00 <glguy> that one has always confused me :)
22:40:28 <glguy> last question and I'll go to bed...
22:40:42 <glguy> is there a way to determine if a Monad is equal to mzero?
22:40:52 <glguy> or at least if an instance of MonadPlus is
22:40:54 <glguy> ?
22:41:22 <glguy> (I'm assuming that the MonadPlus laws and class don't cover that)
22:43:16 <u221e> Never before have I spent so much time, working on functions so small.
22:43:37 <glguy> What functions are you working on? (I came late to the conversation)
22:43:50 <u221e> Just a genral comment
22:44:07 <u221e> general even
22:45:16 <u221e> I'm trying different ways of speeding up the mandelbrot program for the shootout
22:51:44 <u221e> if I have something like (width*width) in my recursive call is GHC smart enough to only do that calculation once since width never changes?
22:52:39 <glguy> u221e: I remember being told that ghc didn't automatically memoize function calls
22:52:56 <glguy> and that a let was needed
22:56:09 <dons> u221e: even better just to float it out with a 'let', as glguy says
23:00:52 <u221e> What do you mean?
23:03:19 <jgrimes> how do you profile something that uses ByteString?
23:04:54 <u221e> I think using a where would be better.
23:28:43 <u221e> If there is a 'where x = (w*w)' statement for a guarded expression would it only recalculate (w*w) if thw w argument changes on the next call?
23:30:57 <sjanssen> u221e: it would always recalculate
23:33:32 <dons> jgrimes: the usual way. you must ensure, of couse, you built fps with profiling
23:33:38 <dons> (configure -p flag to cabal)
23:34:27 <u221e> Is there anyway to just have it calculate once?
23:35:02 <u221e> I could just add a 'size' argument to the function but is there any other way?
23:35:12 <dons> u221e: to calculate only once you need to use a 'let' or 'where' in an outer scope. i.e. with a worker/wrapper split (calculate the value in the wrapper, then hand control to the worker)
23:35:29 <dons> otherwise, perhaps the compiler will figure it out. but you can always manually ensure this is the case
23:36:02 <u221e> so a 'let' inside a recursive call won't work?
23:36:30 <dons> well, if it depends on a parameter that is changing, then no. but if it doesn't change, then the compiler might notice this and rewrite it for you
23:36:42 <dons> but it is more common to manually do this, i think
23:36:47 <lisppaste2> zeeeee annotated #22435 with "help! i just can't get fix the typing in this very simple program" at http://paste.lisp.org/display/22435#4
23:37:06 <dons> f x y = g y where x2 = x * x ; g n = ... x2 ...
23:39:23 <dons> zeeeee: the process would be to write down the types of each subexpression until you spot the type error
23:39:34 <u221e> How is g able to access x2?
23:39:47 <zeeeee> dons: so you mean i should explicitly type my app
23:40:04 <dons> u221e: there's in the same scope, so g can see it
23:40:10 <dons> so in
23:40:17 <dons> where g = ... x2 ....
23:40:20 <dons>       x2 = ...
23:40:22 <dons> works fine
23:40:34 <dons> then g is the recursive function
23:40:59 <dons> but 'x2' has been floated out, so it won't be recalulated. it doesn't depend on any arguments to the recursive function, g
23:41:15 <dons> of course, ghc might notice this in your code anyway, but this makes sure that's the case
23:41:24 <dons> zeeeee: well, that's how i'd debug it, yes.
23:41:40 <zeeeee> dons: ok, i'll try...
23:41:40 <dons> i'd write down the types you think things have, which should help work out the error
23:41:45 <dons> (better than having it fail at runtime ;)
23:41:55 <u221e> so g has to be defined within f?
23:42:19 <dons> zeeeee: another trick is to use 'undefined' for bits that are wrong, and let ghci infer the other types for you.
23:45:00 <dons> zeeeee: note that you're never 'show'ing your numbers
23:45:10 <dons> so ghc has to infer that your 'read' produces a String, not a Double
23:45:14 <dons> there's a missing 'show' 
23:45:18 <zeeeee> oh man
23:46:06 <dons> so you can start a the bottom, 
23:46:07 <dons> getNumber :: [String] -> Double
23:46:07 <dons> getNumber = read . head . tail
23:46:10 <dons> yeah?
23:48:56 <zeeeee> dons: how do you know that read will return Double?
23:48:58 <dons> oh, hmm, and you never call normNumber or getNumber?
23:49:03 <zeeeee> dons: it can return any Num
23:49:08 <zeeeee> or anything actually
23:49:08 <dons> that'll do
23:56:45 <lisppaste2> zeeeee annotated #22435 with "ok, i've made some typing and fixed most problems, but i still can't beat the last line..." at http://paste.lisp.org/display/22435#5
23:57:39 <zeeeee> dons: also, is there any haskell implementation that has newbie-friendlier error messages? ghc/hugs print really meaningless messages to me
23:58:29 <Cale> there's Helium, but that's not full Haskell
23:58:47 <Cale> The best thing is probably just to find out what the error messages mean
