00:02:17 <Cale> jargonjustin: yes
00:02:28 <Cale> jargonjustin: (->) is right associative
00:02:31 <jargonjustin> Cale: That was essentially my problem, right?
00:02:49 <jargonjustin> I was trying to combine functions whose types didn't work like that?
00:02:53 <Cale> right
00:03:04 <Cale> The two 'b's didn't match
00:03:43 <jargonjustin> Okay, I actually understand it now, thanks again.
00:03:53 <Cale> no problem
00:15:14 <skew> uh, isn't the problem there that zip takes two lists, and . composes unary functions?
00:16:53 <skew> zipSum x = map (uncurry (+)) . zip x is the same as zipSum x y = map (uncurry (+)) $ zip x y
00:20:20 <xerox> ?type (map (uncurry (+)) .) . zip
00:20:21 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
00:20:27 <xerox> I'd do it this way.
00:20:36 <skew> or, you could use this operator: http://okmij.org/ftp/Haskell/types.html#polyvar-comp
00:20:37 <lambdabot> Title: "Haskell Programming: Types"
01:06:53 <ruffneck> http://volny.cz/ropucha_3000/hitlatuma.swf
01:09:20 <dcoutts> dons, ping
01:16:42 <dons> yo
01:23:44 <dcoutts> dons, yeah I saw that speed of byte string thread / wc -l thing
01:24:01 <dcoutts> dons, so what should I be working on in the next couple days?
01:25:48 <dcoutts> dons, as for TAP, we need some proof technique, not just testing
01:26:08 <dcoutts> "The TAP conference is entirely devoted to this convergence of proofs and tests. Contributions discussing just proof techniques, or just testing techniques, are not appropriate for submission to TAP; instead we are interested in work that somehow combines ideas from both sides, for the advancement of software quality."
01:27:18 <dons> ah. 
01:27:27 <dons> we'd need to hook in isabelle and be super smart
01:27:33 <dons> ok, too much work.
01:30:11 <dons> ok, what to work on. well, do you think we can get the streams  stuff into the paper?
01:30:23 <dons> i have my review this week, so i can't do too much work on fps/paper
01:30:30 <dons> but it should be free from next week.
01:36:40 <JKnecht> review?
01:38:04 <dons> phd yearly review. give a talk and a tech. report on how you're going.
01:38:22 <dons> paperwork. bah.
01:39:39 * JKnecht had a friend who took more than 10 years to get her Phd.
01:40:22 <dons> well, this is only my 3rd, so not so bad.
01:41:19 <xerox> Hoo-yi-rray! :)
01:45:35 <JKnecht> which front-end are you using?
01:47:08 <dons> ?
01:47:36 <JKnecht> meant xerox, assumed he was referring to your Yi.
01:47:53 <dons> ah.
01:48:03 <dcoutts> dons, yes I think we could do the streams
01:48:19 <dcoutts> dons, I was also wanting to get the last system working better
01:48:38 <dcoutts> that is working for strict & lazy folds nicely
01:48:51 <dons> ah yes. that's something that could be done
02:24:50 <mnislaih> JaffaCake, Lemmih: any there ?
02:28:53 <Lemmih> I'm here!
02:29:18 <mnislaih> Hiya Lemmih. I've started a wiki page with all the stuff and designs. Where in the haskellwiki should I hang it? I had thought under ghci/debugger/Development_Ideas, or maybe just ghci/debugger
02:29:24 <Lemmih> With a new tupe of non-garlic tartex!
02:29:44 <mnislaih> did you manage to play with the closure viewer yesterday night ?
02:29:56 <mnislaih> what is a tupe?
02:30:34 <Lemmih> It's a tube in disguise.
02:30:51 <Lemmih> Yeah, I did. It's quite nice.
02:31:04 <mnislaih> I thought it had to do with your hair
02:31:14 <mnislaih> ok, so I've prepared a wiki page showing it.
02:31:21 <mnislaih> And some other boring stuff
02:31:39 <Lemmih> I'd love try a "real" test.
02:31:56 <mnislaih> oh no, then it would break and that would mean more work for me =)
02:32:35 <mnislaih> actually that's why I did the wiki page. Maybe we can fool people into using it
02:34:15 <Lemmih> I'm not very familiar with the structure of the wiki but ghci/debugger sounds nice.
02:36:17 <mnislaih> ok, it's up
02:36:20 <mnislaih> http://haskell.org/haskellwiki/Ghci/Debugger
02:36:22 <lambdabot> Title: "Ghci/Debugger - HaskellWiki"
02:36:59 <mnislaih> I still have to add a few unimportant things, such as where to get the patches
02:37:09 <mnislaih> ^^
02:37:18 <mnislaih> but I must eat something, now
02:37:37 * mnislaih will be back soon
02:37:57 <mnislaih> let me know your opinion
02:38:44 <Lemmih> Yeah, I was just about to ask for a darcs repo.
02:40:25 <eivuokko> mnislaih, Looks cool.
02:41:46 <dcoutts> dons, interesting email about the head (build g) seq issue
02:42:03 <dcoutts> dons, also note that the streams representation does not suffer from this
02:42:46 <dcoutts> because forcing the intermediate values is explicit rather than relying on lazyness
02:47:03 * mnislaih is back
02:47:26 <mnislaih> thanks eivuokko, soon you'll be able to try it
03:00:53 <fasta> I am trying to find a function ::String -> XmlTree, but almost all of the functions seem to be living in the IO monad, and I have no need for that, right now. This is a direct link to the documentation: http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html
04:18:45 <kzm> @seen
04:18:45 <lambdabot> Lately, I have seen kzm.
05:03:52 <isaacd> Can I use common portable modules like Data.Map and Control.Monad.Fix with Yhc currently? (How?)
05:08:03 <isaacd> I suppose I'll have to upgrade to GHC 6.4.2 because 6.4.1 is reliably "panic!"ing with a compiler bug when compiling my code now.
05:08:14 <isaacd> That is, a particular set of code.
06:11:40 * dons -> sleep
06:28:16 * fasta learned the significance of API design ... the hard way...
06:28:37 <vegai> I learn it every time :P
06:28:42 <vegai> the hard way
06:29:53 <fasta> vegai: The thing I am working with now, exports almost everything. 
06:30:18 <fasta> vegai: while there are maybe 20 useful functions. 
06:31:08 <apfelmus> learning the hard way is preferable to hardly learn the way
06:33:42 <vincenz> How do I install GHC on a machine where I don't have root perms
06:33:54 <petekaz> how do I include an ESC (^[) character in a Haskell literal String?
06:34:16 <vincenz> @join #oasis
06:34:18 <petekaz> I get a lexical error as soon as I add it.
06:34:26 <dcoutts> '\123'
06:34:29 <dcoutts> > '\123'
06:34:30 <lambdabot>  '{'
06:34:40 <Igloo> vincenz: Tell configure --prefix=/my/home/dir/ghc or somesuch
06:34:45 <petekaz> Thanks.
06:36:16 <vincenz> Igloo: that's for a source instal, but source install assumes a prior install no?
06:36:33 <apfelmus> petekaz: there should be a backslash notation for it
06:36:45 <vincenz> my laptop charger died :(
06:36:51 <vincenz> the week before I go to a conference
06:36:54 * vincenz kicks his karma
06:37:38 <fasta> vincenz: can't you just grab a binary version and place it inside a directory?
06:38:27 <fasta> IIRC, I did that once on Linux. 
06:38:40 <Igloo> vincenz: IIRC the docs in the binary dists tell you how to install where you want
06:38:47 <petekaz> apfelmus: yeah, dcoutts just showed me.
06:38:52 <petekaz> > "\27"
06:38:53 <lambdabot>  "\ESC"
06:39:02 <vincenz> Igloo: thx
06:39:24 <apfelmus> petekaz: sorry, i temporarily lost connection
06:39:25 <petekaz> I'm just adding some color to my first haskell program.
06:39:50 <petekaz> apfelmus: hey, I appreciate the help, sometimes I need to be told twice anyways :-)
06:56:37 <roods> haskell is pretty cool, i just started learning it.
06:56:43 <mnislaih> @seen waern
06:56:44 <lambdabot> I saw waern leaving #Haskell and #haskell.se 3 days, 15 hours, 35 minutes and 35 seconds ago, and .
06:59:56 <fasta> Does anyone know a good Xml 1.0 validator, which is packaged by Debian?
07:00:14 <dcoutts> haxml
07:00:25 <fasta> dcoutts: Oh, please not.
07:00:32 <fasta> dcoutts: That doesn't compile
07:00:53 <fasta> dcoutts: well, it does with a few hacks, but then the Haddock documentation doesn't work.
07:01:20 <dcoutts> the gentoo packages of 1.12 & 1.13 work fine
07:01:31 <dcoutts> otherwise there's two others
07:01:43 <dcoutts> not sure which ones are packaged by debian
07:01:46 <fasta> dcoutts: Switching distro for one thing is not an option. 
07:02:00 <dcoutts> no, my point is that it can be made to work
07:02:03 <fasta> dcoutts: I am now using HXT-5.5, but it says that every element specified in the DTD is not valid. 
07:02:14 <mux> fasta: so, did that trick helped?
07:02:42 <fasta> mux: Yes, I can now use HXT-5.5
07:02:47 <mux> cool
07:02:52 <fasta> mux: it only has a complete horrible interface.
07:02:57 <mux> I should re-mail the HXT maintainer
07:03:04 <fasta> mux: it exports way too much stuff.
07:03:07 <mux> spamming him with the patch
07:03:16 <mux> or get dons to take maintainership over :)
07:04:36 <SamB_XP> fasta: yeah, it does seem to export way too many things from a lot of modules...
07:05:00 <fasta> I just need a utility to check whether the file I have is valid to verify that HXT-5.5 is wrong.
07:05:38 <fasta> I don't care whether it's written in Haskell or Brainfuck, as long as it's correct. 
07:05:55 <SamB_XP> you might be able to get nsgmls to do it
07:09:04 <arjanoosting> fasta: searching for haxml .debs?
07:09:38 <fasta> arjanoosting: If that interface is better than HXT-5.5 and it actually *works*, and it comes with documentation, then yes.
07:10:43 <mux> I've been disappointed by both HaXML and HXT in the past
07:10:59 <arjanoosting> fasta: i don know HXT so I do not know if the interface is better, but i do have .debs of HaXml
07:11:04 <mux> none of those were able to parse some XML file of mine, which is admittedly huge
07:11:26 <arjanoosting> fasta: http://moonshine.dnsalias.org/debian/unstable
07:11:29 <lambdabot> Title: "Index of /debian/unstable"
07:11:56 <vegai> fasta: there's an xml validating mode for emacs
07:12:05 <arjanoosting> still trying to get them into the Debian archive :(
07:12:10 <fasta> arjanoosting: For what version do they work? Or doesn't it matter?
07:12:34 <fasta> arjanoosting: I installed a GHC darcs version.
07:17:02 <fasta> mux: I think it's so slow because it uses Parsec.
07:17:09 <SamB_XP> huh?
07:17:27 <arjanoosting> fasta: they are build against 6.4.2
07:17:31 <SamB_XP> I thought Parsec was supposed to be efficient?
07:18:11 <fasta> SamB_XP: there are some inefficiencies in monads, that arrows don't have. 
07:18:30 <SamB_XP> fasta: such as?
07:18:33 <fasta> SamB_XP: the UU parser should be faster, but I haven't used it.
07:18:48 <SamB_XP> does that have decent errors?
07:18:57 <fasta> SamB_XP: I believe so.
07:19:28 <arjanoosting> it even has error correction
07:19:38 <SamB> that sounds freaky
07:20:01 <fasta> SamB_XP: Probably you can turn that off.
07:21:02 <SamB> @google uu parser
07:21:05 <lambdabot> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
07:21:15 <SamB> @google uu parser haskell
07:21:16 <lambdabot> http://www.cs.uu.nl/~daan/parsec.html
07:21:24 <arjanoosting> @google Hut parser 
07:21:26 <lambdabot> http://www.cs.uu.nl/wiki/HUT/ParserCombinators
07:21:26 <lambdabot> Title: "HUT / Parser Combinators"
07:22:38 <SamB> hmm, liking the feature lists
07:25:01 <fasta> HaXml seems _much_ better designed
07:25:25 <fasta> For example: it doesn't export the exact parsing types
07:27:39 <fasta> When I press C-d I get ^D^D^D^D in my terminal. Something must be wrong with my terminal, any idea of what it can be?
07:28:01 <SamB> it is stuttering?
07:28:35 <fasta> SamB_XP: no, I just want to press e.g. BACKSPACE, to undo the typing of a character
07:28:48 <fasta> SamB_XP: so, it was just an example.
07:28:54 <mux> you most likely have a wrong $TERM type
07:30:40 <fasta> mux: what do you suggest?
07:34:19 <vincenz> Hello
07:34:49 <vincenz> I switched to 6.4.2 from 6.4.1 (lappy charger died, I had to do clean nistall on work pc so now it's 6.4.2)  Sources that compiled fine on 6.4.(1?) now give me this compile error on 6.4.2: http://rafb.net/paste/results/B598MQ69.html
07:36:57 <fasta> It appears I only have the problem when I start ghci, since e.g. vim does recognize it (backspace) correctly.
07:39:01 <arjanoosting> then your ghc(i) is not build against readline probably
07:39:16 <fasta> arjanoosting: That is very probable.
07:39:16 <norpan> vim may do secret tricks too
07:39:29 <fasta> arjanoosting: especially since I got a warning during build for that.
07:39:41 <arjanoosting> :)
07:39:50 <fasta> arjanoosting: something like "warning, the configuration of read line is not set".
07:40:01 <fasta> arjanoosting: Do you have any idea of how I can build ghc with read line support?
07:40:09 <dsacode> Hello! Is it possible to rid off two "reverse" function in definition "reduceL = reverse . dropWhile (==0) . reverse" ?
07:40:56 <arjanoosting> first do apt-get build-depends ghc6 to make sure you have the rigth build dependencies for ghc
07:41:06 <arjanoosting> then rebuild I guess
07:41:50 <norpan> dsacode: not without difficulty
07:42:10 <fasta> arjanoosting: I wouldn't have to rebuild my libraries then, right?
07:42:25 <fasta> arjanoosting: (since the interface file didn't change)
07:42:49 <fasta> arjanoosting: or does it overwrite my package configuration?
07:43:07 <arjanoosting> hmm, if you don't change of ghc version it is not necessary I guess
07:47:30 <apfelmus> > let drops = fst . foldr (\c (xs,b) -> if b && c == 0 then (xs,True) else ((c:xs),False)) ([],True) in drops [1,0,2,3,0,0,0]
07:47:31 <lambdabot>  [1,0,2,3]
07:49:11 <apfelmus> > let drops = fst . foldr (\c xs -> if null xs && c == 0 then [] else c:xs) [] in drops [1,0,2,3,0,0,0]
07:49:11 <lambdabot>  Couldn't match `[a]' against `(a1, b)'
07:49:51 <apfelmus> > let drops = foldr (\c xs -> if null xs && c == 0 then [] else c:xs) [] in drops [1,0,2,3,0,0,0]
07:49:52 <lambdabot>  [1,0,2,3]
07:51:39 <apfelmus> dsacode: content?
07:52:09 <dsacode> apfelmus: sorry, what do you mean? :)
07:52:24 <dsacode> apfelmus: thank you for those code snippets
07:53:07 <erider> how do you read haskell from left to right or from right to left?
07:53:48 <apfelmus> dsacode: just asked if the snippets make you happy :)
07:53:59 <dsacode> apfelmus: yes :) thank you! :)
07:54:28 <apfelmus> dsacode: np
08:12:19 <dcoutts> CosmicRay, is there a tarball for ldap-haskell ?
08:12:46 <dcoutts> CosmicRay, I'm trying to do a gentoo package
08:13:33 <dcoutts> CosmicRay, I must be looking in the wrong place since the .cabal file in the darcs repo (http://darcs.complete.org/ldap-haskell/) says it's version 0.5.0 but the current debian version is 0.5.1
08:13:34 <lambdabot> Title: "Index of /ldap-haskell"
08:14:28 <dcoutts> CosmicRay, btw, the license in the .cabal file doesn't match the COPYING
08:17:58 <CosmicRay> dcoutts: let me check
08:18:11 <dcoutts> CosmicRay, ta
08:18:15 <CosmicRay> dcoutts: I probably need to update that package for GHC 6.4.2 anyway
08:18:38 <CosmicRay> dcoutts: let me do that quick and I'll fix the licence in .cabal while I'm at it
08:18:45 <dcoutts> great
08:18:51 <CosmicRay> dcoutts: if a particular version has fixes that apply only to Debian, I don't upload new tarballs
08:19:03 <CosmicRay> and that was the case with 0.5.1
08:19:13 <dcoutts> I couldn't see where the tarballs were kept
08:19:23 <CosmicRay> dcoutts: quux.org/devel/haskell-ldap IIRC
08:19:32 <CosmicRay> actually this one should be GHC 6.4.2-clean as it is
08:19:45 <CosmicRay> err, ldap-haskell
08:19:50 <dcoutts> ah thanks, perhaps the link on the haskell.org wiki should point there rather than the darcs repo
08:20:07 <dcoutts> CosmicRay, http://haskell.org/haskellwiki/Libraries_and_tools/Network
08:20:08 <lambdabot> Title: "Libraries and tools/Network - HaskellWiki"
08:20:12 <CosmicRay> OK, actually I guess I have never made tarballs of this one.
08:20:47 <dcoutts> ah right
08:21:10 <CosmicRay> so just pull from darcs, I guess, for now.  could you drop me an e-mail asking about tarballs?
08:21:45 <dcoutts> sure
08:22:26 <CosmicRay> dcoutts: I have pushed out the license fix to the darcs repo
08:23:21 <CosmicRay> or maybe not.
08:23:26 <CosmicRay> apparently BSD is not a valid string
08:24:21 <CosmicRay> ok, it's really fixed now.
08:24:31 <CosmicRay> ah blat.
08:24:40 <CosmicRay> hang on, there are GHC 6.4.2 problems.  I will have to make a new release.
08:25:08 <CosmicRay> stupid base no longer being automatically imported, grrr.
08:26:36 <dcoutts> CosmicRay, it's BSD3 or BSD4 iirc
08:26:53 <mux> yeah
08:27:04 <CosmicRay> dcoutts: yup, already got it.
08:27:13 <CosmicRay> dcoutts: ok, there is now a tarabll at http://quux.org/ldap-haskell/ for you.
08:27:18 <dcoutts> yay, thanks
08:27:49 <dcoutts> hmm, doesn't seem to be working
08:28:06 <CosmicRay> make that http://quux.org/devel/ldap-haskell
08:28:08 <lambdabot> Title: "Gopher: ldap-haskell"
08:28:08 <CosmicRay> sorry
08:28:16 <dcoutts> thanks
08:44:41 <SyntaxNinja> w00t
08:44:41 <lambdabot> SyntaxNinja: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:44:48 <SyntaxNinja> wtf
08:45:18 <SyntaxNinja> heh. lambdabot now replaces email!
08:48:20 <dcoutts> CosmicRay, does ldap-haskell need any particular version of OpenLDAP ?
08:49:35 <vincenz> hello SyntaxNinja
08:49:51 <CosmicRay> dcoutts: not AFAIK
08:50:07 <CosmicRay> dcoutts: the LDAP C API is specified by RFC
08:50:17 <SyntaxNinja> heya
08:50:22 <CosmicRay> SyntaxNinja!
08:50:23 <CosmicRay> LTNS!
08:50:27 * SyntaxNinja hands CosmicRay a cookie
08:50:33 * CosmicRay munches happily
08:50:55 <dcoutts> CosmicRay, ok, ta
08:51:00 <SyntaxNinja> I just uploaded darcs 1.0.8 to debian last night. might have hit the mirrors by now.
08:51:11 <CosmicRay> SyntaxNinja: I saw that.
08:51:19 <CosmicRay> SyntaxNinja: you closed one of my bugs ;-)
08:51:23 <SyntaxNinja> eyes like a hawk this one
08:51:30 <CosmicRay> heh
08:51:42 * CosmicRay is busily updating all his stuff for ghc 6.4.2
08:51:46 <CosmicRay> I think I've got most of it now.
08:51:49 <CosmicRay> oh, missingpy yet.
08:51:53 <SyntaxNinja> I need to do something about cabal still.
08:52:03 <SyntaxNinja> hurray Igloo for uploading ghc 6.4.2!
08:52:24 <CosmicRay> WHEE!!!  darcs pull can send multiple patches over a single ssh connection now!
08:52:30 <CosmicRay> that had been bugging me for ages.
08:52:46 <SyntaxNinja> seriously
08:53:14 <kosmikus> CosmicRay: would you consider updating lhs2tex in debian to 1.11?
08:53:39 <CosmicRay> kosmikus: would be happy to.
08:53:42 <SyntaxNinja> heya kosmikus. you're awake already?
08:53:44 * CosmicRay sends himself a reminder
08:53:51 <kosmikus> SyntaxNinja: why not?
08:54:11 <SyntaxNinja> kosmikus: I was under the impression that you've been awake for like 40 hours straight ;)
08:54:35 <kosmikus> I had very irregular sleeping patterns, but I didn't stay awake for a single full night
08:55:13 <kosmikus> no, today I had to get up extremely early, so I had only 3.5 hours of sleep in the night
08:55:22 <kosmikus> Ralf is at MPC, so I have to give his lectures
08:56:04 <SyntaxNinja> aha! You slept for 3.5 hours and asked me why I asked if you're awake.
08:56:10 <SyntaxNinja> <--- knows such things
08:56:44 <kosmikus> well ... it's 6pm here -- that's a time where I'm usually not asleep :)
08:57:59 <SyntaxNinja> :)
09:25:04 <mathewm> are Test.QuickCheck and Debug.QuickCheck different?
09:26:19 <norpan> they are the same
09:26:24 <norpan> Test.QuickCheck is the new name
09:26:28 <mathewm> cool
09:27:02 <norpan> gah
09:27:24 <norpan> why cant people stop using dddddd notation for dates
09:27:37 <norpan> how am i supposed to know which day 050607 is
09:28:56 <vincenz> how safe is it to use darcs on a usbstick
09:29:04 <vincenz> because usbsticks have limited rewrites
09:29:16 <norpan> do they really, anymore?
09:29:19 <norpan> in practise i mean
09:30:27 <vincenz> norpan: don't know
09:30:32 <vincenz> but at the moment my laptop is incapacitated
09:30:50 <norpan> i think modern usb sticks handle like 100k writes or something
09:30:57 <norpan> and reallocates blocks
09:31:03 <vincenz> hmm
09:33:08 <norpan> i think you should be fine
09:33:26 <vincenz> alright thanks
09:34:13 <mathewm> type constructors are composable functions, right?  How does one parse Foo.bar ?  Foo . bar  or bar in the Foo module?
09:34:46 <norpan> bar in the Foo module
09:34:53 <norpan> longest lex rule
09:35:09 <mathewm> I see, thanks
09:35:20 <rafl> SyntaxNinja: ping
09:39:50 <SyntaxNinja> hi rafl
09:40:45 <rafl> SyntaxNinja: I have a question concerning the libghc6-cabal-dev package in Debian and one of my packages. My I query you as it doesn't really fit into this channel?
09:41:01 <SyntaxNinja> rafl: sure. this chan is fine, or email or whatever.
09:53:54 <dmhouse> mathewm: by the way, you meant 'data constructors' up there.
09:59:08 <vincenz> who wants to see something nasty?
09:59:29 <vincenz> http://rafb.net/paste/results/tjGQ2n70.html
09:59:37 <erider> does haskell use prefix notations 
09:59:38 <vincenz> indirect composite at it's best
10:00:12 <dmhouse> erider: For what?
10:00:17 <dmhouse> > sqrt 2
10:00:18 <lambdabot>  1.4142135623730951
10:00:22 <dmhouse> > 2 + 2
10:00:23 <lambdabot>  4
10:00:26 <dmhouse> > (+) 2 2
10:00:27 <lambdabot>  4
10:00:36 <dmhouse> erider: You get to choose :)
10:01:15 <erider> hmm sounds interesting 
10:01:18 <dmhouse> By default, functions whose name are all non-alphanumeric are infix, otherwise they're prefix.
10:01:21 <dmhouse> But:
10:01:26 <dmhouse> > (+) 2 2 -- prefix operator
10:01:27 <lambdabot>  4
10:01:37 <dmhouse> > 2 `elem` [1..4] -- infix function
10:01:38 <lambdabot>  True
10:02:07 <erider> > (-) 2 3 
10:02:08 <lambdabot>  -1
10:03:12 <erider> so you have to use the parenthesis to choice what it is going to be?
10:03:49 <dmhouse> Kind of.
10:03:55 <|Steve|> > 1 + (-) 2 3
10:03:55 <lambdabot>  0
10:04:20 <dmhouse> If you have a function whose name is all non-alphanumeric characters (an operator), then you can use it infix without and parentheses, or prefix with parentheses.
10:04:48 <dmhouse> For a normal function, you can use it prefix without anything special, or infix (if it's a binary function) with `tickmarks`.
10:05:36 <|Steve|> > [1..3] `zip` [2,4,6]
10:05:37 <lambdabot>  [(1,2),(2,4),(3,6)]
10:05:42 <|Steve|> wow, you can.
10:06:24 <erider> cool I'm glad my stupid question helped somebody 
10:07:08 <|Steve|> I didn't know you could do it with any binary function.
10:07:56 <dmhouse> Technically, as multi-parameter functions in Haskell are curried, you can do it with any function that takes 2 or more arguments.
10:08:09 <dmhouse> > ((+) `foldr` 0) [1..10]
10:08:10 <lambdabot>  55
10:08:19 <dmhouse> But that's just ugly :)
10:08:21 <|Steve|> Ha, nice.
10:08:24 <|Steve|> That is ugly.
10:08:31 <|Steve|> But then, so was my 1 + (-) 2 3.
10:08:45 <dmhouse> And the same applies to operators always being binary. A common function used in papers is:
10:09:48 <dmhouse> > let (*) :: (a -> b) -> (c -> d) -> (a, b) -> (c, d); f * g = \(x, y) -> (f x, g y) in ((+1) * map toUpper) (1, "hello")
10:09:48 <lambdabot>    Quantified type variable `c' is unified with another quantified type var...
10:09:58 <dmhouse> Oops :)
10:10:06 <dmhouse> > let (*) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d); f * g = \(x, y) -> (f x, g y) in ((+1) * map toUpper) (1, "hello")
10:10:07 <lambdabot>  (2,"HELLO")
10:10:15 <dmhouse> Alternatively:
10:10:25 <dmhouse> > let (*) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d); (*) f g (x, y) = (f x, g y) in ((+1) * map toUpper) (1, "hello")
10:10:26 <lambdabot>  (2,"HELLO")
10:10:33 <dmhouse> Operators can even be unary:
10:10:54 <dmhouse> > let (^) = map toUpper = (^) "hello" -- but you always have to use parentheses.
10:10:54 <lambdabot>  Parse error
10:11:02 <dmhouse> > let (^) = map toUpper in (^) "hello" -- but you always have to use parentheses.
10:11:03 <lambdabot>  "HELLO"
10:11:06 <|Steve|> That's crazy.
10:11:31 <erider> dmhouse, are there macros in haskell?
10:11:34 <|Steve|> Oh, actually, it's not so bad.
10:13:19 <Cale> erider: There's Template Haskell, but it's not very widely used
10:13:49 <erider> ah ok thanks Cale 
10:13:54 <dmhouse> Or you can use CPP macros and compile with -fcpp
10:13:55 <Cale> erider: Most of the things you see macros getting used for in Lisp/Scheme/etc. are taken care of by laziness and various monads.
10:14:09 <Cale> Depending on the sort of macros you're talking about :)
10:16:09 <erider> Cale, thanks I was just trying to make a comparsion I'm kinda at the crossroads of language choices 
10:20:29 <SyntaxNinja> I'm sitting on my balcony using wireless.  A lady just walked by on a cell phone saying, "One daughter was at ski camp and the other daughter was at fashion camp."  Wow.
10:21:59 <madpickle> fashion camp?
10:23:27 <SyntaxNinja> I think around here fashion camp must involve tattoos and fixed-gear bikes.
10:34:24 <roods> indentation matters in haskell
10:34:27 <roods> that is kind of lame.
10:34:49 <dmhouse> No it isn't.
10:34:56 <dmhouse> Indentation makes Haskell programs pretty.
10:35:10 <roods> isn't that what pascal said. 
10:35:22 <dmhouse> You can use semicolons and braces if you want, but most people use indentation because it's less crufty.
10:35:38 <dmhouse> > let { x = 1; y = x + 3 } in y
10:35:39 <lambdabot>  4
10:41:27 <mathewm> is there an option to launch GHCi without printing the banner?
10:42:55 <ndm> mathewm: that would be handy actually!
10:43:01 <ndm> and for Hugs as well
10:43:23 <dmhouse> It'd be good for lambdabot plugins that need to query GHCi
10:43:38 <dmhouse> At the moment they use some flaky heuristics to skip past the banner.
10:43:56 <ndm> yep, so does WinHaskell
10:44:04 <ndm> although the WinHaskell one isn't flakey at all
10:44:20 <ndm> if you fire off a :set prompt DONE
10:44:31 <ndm> as the first action, then you can wait for DONE and know you are finished
10:44:36 <Cale> mathewm: what are you actually trying to do?
10:44:41 <ndm> thats the entire reason i wrote the :prompt feature :)
10:44:46 <Cale> mathewm: did you know about ghc -e ?
10:44:51 <mathewm> just setting up unit-tests and QuickCheck
10:45:09 <dmhouse> Well, LB plugins are normally more toward the 'quick hack' end of the scale. We normally just drop 7 lines or so.
10:45:11 <mathewm> I want to run my tests automatically named "test_" or "prop_"
10:45:45 <mathewm> the quickCheck script launches ghci which prints lots of junk besides what I want...
10:46:15 <mathewm> actually, what I want may being on stderr so I can just '>/dev/null' :)
10:47:37 * vincenz is off
10:47:40 <vincenz> I'll connect from home later
10:47:42 <vincenz> hasta lueg
10:47:43 <vincenz> o
10:54:37 <the_lord> Hi! how do I instance a data definition with Eq?
10:54:55 <the_lord> with my own definition of ==
10:55:07 <Cale> instance Eq MyData where
10:55:24 <Cale>    ... definitions for (==) ...
10:55:37 <roods> i'm looking at some examples of haskell and don't understand what "@" means wrt insert e lst@(x:xs)
10:56:06 <the_lord> ...
10:56:07 <Cale> roods: It calls the whole list lst and names the head x and tail xs
10:56:26 <the_lord> data Maquina = Maq String [String] String [String]
10:56:31 <roods> Cale: thanks bud.
10:56:45 <the_lord> instance Eq Maquina where
10:56:46 <the_lord> ...
10:56:51 <Cale> roods: no problem
10:57:07 <the_lord> I want Maquina == other Maquina only when the first String are the same
10:57:09 <Cale> yeah
10:57:13 <the_lord> how do I do that
10:57:22 <the_lord> I've tried this
10:57:44 <Cale>   (Maq x _ _ _) == (Maq y _ _ _) = x == y
10:57:46 <the_lord> where (Maq n1 _ _ _) == (Maq n2 _ _ _) = n1 == n2
10:57:52 <the_lord> nope
10:58:28 <Cale> What error do you get?
10:59:15 <roods> is haskell used outside school?
10:59:25 <Cale> roods: yes
10:59:34 <roods> in what fields?
10:59:37 * araujo uses it only outsid school :-)
10:59:53 * ValarQ has never used Haskell in school
11:00:01 <araujo> roods, writting applications!
11:00:19 <the_lord> Cale, it was tabulation
11:00:26 <the_lord> I had it like this
11:00:30 <araujo> surpringsily Haskell _does_ work for that :-)
11:00:31 <roods> araujo: what types of applications
11:00:38 <the_lord> instance Eq Maquina where
11:00:38 <Cale> roods: Specifically it seems popular for high assurance type applications
11:00:42 <the_lord> blah blah
11:00:53 <araujo> roods, you mention it...
11:00:53 <the_lord> I've corrected to 
11:00:56 <dcoutts> CosmicRay, what cabal ersion are you using? I get an error processing LDAP/Data.hsc because the hsc2hs command doesn't include -lldap
11:01:03 <roods> araujo: ?
11:01:03 <the_lord>       blah blah
11:01:04 <dcoutts> CosmicRay, which seems to me to be a cabal issue
11:01:06 <the_lord> and it worked
11:01:19 * araujo can't think of anything that might not be written on Haskell
11:01:20 <dcoutts> CosmicRay, since you do specify ldap in extra-libraries: in the .cabal file
11:01:42 <Cale> the_lord: yes, the code inside must be indented
11:02:35 <CosmicRay> dcoutts: I'm just using the version which comes with ghc 6.4.2
11:04:16 <gour> dcoutts: hi, i'm back & alive :-)
11:04:16 <ValarQ> araujo: realtime applications where you want very fine control of execution speed maybe?
11:04:41 <the_lord> Cale, thx anyway
11:04:49 <dcoutts> gour, long time no, see how was india
11:04:55 <dcoutts> CosmicRay, strange, so am I
11:05:14 <gour> dcoutts: in the beginning it was hot, but later pretty cool
11:05:30 <dcoutts> CosmicRay, when you do setup build -v and it calls hsc2hs on LDAP/Data.hsc does it use -lldap ?
11:05:37 <the_lord> @hoogle String -> [String] -> [String]
11:05:38 <lambdabot> No matches, try a more general search
11:05:47 <the_lord> @hoogle a -> [a] -> [a]
11:05:47 <lambdabot> List.intersperse :: a -> [a] -> [a]
11:05:47 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
11:05:47 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
11:05:53 <gour> dcoutts: i'm happy seeing lot of interesting stuff happening with haskell
11:05:57 <CosmicRay> dcoutts: huh, this is weird.  I wonder how this is working over here.
11:06:08 <araujo> ValarQ, you mean... something like an OS?
11:06:25 * gour is still busy with emerging 'world' having some issues
11:06:28 <CosmicRay> dcoutts: -lldap should not make a difference on a call to hsc2hs
11:06:35 <CosmicRay> doesn't that just process .h files?
11:06:46 <dcoutts> CosmicRay, sure it should, it's creating and running a C program
11:07:03 <dcoutts> gour, yes, lots has been happening in your absence
11:07:07 <CosmicRay> tree/ldap-haskell$ ./setup build -v
11:07:07 <CosmicRay> Preprocessing library LDAP-0.5.0...
11:07:07 <CosmicRay> /usr/bin/hsc2hs -oLDAP/Types.hs LDAP/Types.hsc
11:07:10 <CosmicRay> and that worked
11:07:33 <gour> dcoutts: maybe it is the reason ;)
11:07:39 <dcoutts> Preprocessing library LDAP-0.5.2...
11:07:39 <dcoutts> /usr/bin/hsc2hs -D__GLASGOW_HASKELL__=604 -o LDAP/Data.hs LDAP/Data.hsc
11:07:51 <dcoutts> LDAP/Data_hsc_make.o: In function `main':
11:07:51 <dcoutts> Data_hsc_make.c:(.text+0x3619): undefined reference to `ber_pvt_opt_on'
11:08:08 <dcoutts> CosmicRay, and then with -lldap it works fine since it links to the right lib
11:09:04 <gour> dcoutts: however, i'm enthusiastic to resume my study (both jyotish & haskell :-)
11:09:28 <CosmicRay> dcoutts: I also don't understand how this library is working for me without listing ldap in .cabal.  very weird.
11:09:42 <dcoutts> CosmicRay, what version of OpenLDAP have you got?
11:09:58 <dcoutts> CosmicRay, in LDAP/Data.hsc it references LDAP_OPT_ON
11:10:04 <CosmicRay> 2.1.30
11:10:12 <dcoutts> CosmicRay, and that is defined as so:
11:10:14 <dcoutts> #define LDAP_OPT_ON             ((void *) &ber_pvt_opt_on)
11:10:29 <dcoutts> hence the reference to the linker symbol ber_pvt_opt_on
11:10:35 <dcoutts> and hence the linker error
11:10:40 <dcoutts> when the -lldap is missing
11:10:47 <CosmicRay> so just adding "extra-libraries: ldap" fixes it for you?
11:10:56 <dcoutts> no, you've already done that
11:11:03 <dcoutts> but cabal doesn't use it for hsc2hs
11:11:12 <dcoutts> but perhaps that LDAP_OPT_ON definie is different in your version of OpenLDAP
11:11:13 * CosmicRay blinks
11:11:34 <CosmicRay> is you .cabal file the same as this one:
11:11:40 <CosmicRay> oh
11:11:43 <dcoutts> CosmicRay, check /usr/include/ldap.h and look for LDAP_OPT_ON
11:11:56 <CosmicRay> bah, it is at the top of the file, which is not where I usually put it.  gah I'm blind.
11:12:11 <CosmicRay> #define LDAP_OPT_ON             ((void *) 1)
11:12:11 <CosmicRay> #define LDAP_OPT_OFF    ((void *) 0)
11:12:16 <dcoutts> ah
11:12:18 <dcoutts> that's it
11:12:22 <CosmicRay> indeed
11:12:28 <CosmicRay> what openldap version are you using?
11:12:45 <dcoutts> 2.3.24
11:13:06 <CosmicRay> huh.
11:13:18 * gour wonders what is dcoutts doing with ldap, but he goes to take a dinner 1st...
11:13:30 <dcoutts> gour, just making a gentoo package
11:13:48 <sieni> remember to funroll loops
11:13:55 <gour> ahh, ok...bbl
11:14:20 <dcoutts> CosmicRay, so smells like a cabal issue to me
11:15:01 <mathewm> so how can ghc be forced to treat an input file as .lhs in spite of a different filename ?
11:15:35 <dcoutts> mathewm, if nothing else, by specifying unlit as a pre-processor
11:15:37 <CosmicRay> dcoutts: yes, that makes sense.  how do you want to work around it until cabal gets updated though?
11:15:55 <dcoutts> CosmicRay, well I might just patch Cabal
11:16:01 <the_lord> > (`++`) "World!!!" "Hello "
11:16:01 <lambdabot>  Parse error
11:16:08 <CosmicRay> dcoutts: make sure you send the diff to syntaxninja
11:16:22 <dcoutts> CosmicRay, yep, I'm also a Cabal patch reviewer
11:16:24 <the_lord> isn't ` do what I want?
11:16:26 <CosmicRay> dcoutts: ahh
11:16:33 <CosmicRay> the_lord: leave it off
11:16:45 <the_lord> CosmicRay, what?
11:16:46 <CosmicRay> > (++) "World!!!" "Hello "
11:16:47 <lambdabot>  "World!!!Hello "
11:16:57 <CosmicRay> >"World!!!" ++ "Hello"
11:17:01 <the_lord> yes, but I want Hello World!!!
11:17:10 <dmhouse> > "Hello" ++ "World!!!"
11:17:10 <ihope> > "Hello, 
11:17:11 <lambdabot>  Improperly terminated string
11:17:11 <lambdabot>  "HelloWorld!!!"
11:17:15 <ihope> Erm.
11:17:24 * ihope surses his enter key
11:17:30 <CosmicRay> > (flip (++)) "World!!!" "Hello "
11:17:30 * ihope curses his 's' key
11:17:31 <lambdabot>  "Hello World!!!"
11:17:39 * dmhouse wants more flexible `` syntax. E.g. x `flip ($)` x
11:17:51 <ihope> > flip (++) "World!" "Hello, "
11:17:52 <lambdabot>  "Hello, World!"
11:17:55 <dmhouse> > flip (++) "World!!!" "Hello" -- those were unnecessary parentheses.
11:17:56 <lambdabot>  "HelloWorld!!!"
11:18:08 <the_lord> @type flip
11:18:09 <ihope> There, I won this time :-P
11:18:09 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
11:18:19 <the_lord> good
11:18:44 <ihope> Anyway, what was that function that did "(sequence .) . map"?
11:19:02 <dmhouse> ?type Control.Monad.mapM
11:19:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
11:19:26 <dmhouse> > mapM Just [1..5]
11:19:27 <lambdabot>  Just [1,2,3,4,5]
11:19:42 <dmhouse> > mapM (\x -> if x > 4 then Nothing else Just x) [1..5]
11:19:43 <lambdabot>  Nothing
11:19:54 <dmhouse> > sequence [Just 1, Just 2, Just 3, Just 4, Nothing]
11:19:55 <lambdabot>  Nothing
11:20:10 <ihope> Thanks.
11:20:40 <ihope> @hoogle returnM
11:20:40 <lambdabot> No matches found
11:20:43 <ihope> :-)
11:20:58 <dmhouse> That'll be 'return', then ;)
11:21:31 <kzm_> @seen
11:21:31 <lambdabot> Lately, I have seen audreyt, cosmicray, dcoutts, dmhouse, fglock, gaal, gour, ihope, ingy, kzm_, limbic_region, mathewm, nothingmuch, pasteling, rafl, sieni and the_lord.
11:21:42 <ihope> No, return . return.
11:21:46 <dmhouse> You just pinged about half the channel. :)
11:21:52 <ihope> You monadify function results.
11:21:58 <dmhouse> Oh, right.
11:22:08 <dmhouse> @hoogle (a -> b) -> a -> m b
11:22:09 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
11:22:09 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:22:09 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
11:22:19 <ihope> Maybe return should be called idM :-P
11:22:25 <dmhouse> Okay, those first too shouldn't be showing up.
11:22:29 <dmhouse> ndm: pingeroo
11:22:38 <ndm> dmhouse: pongeroo
11:22:45 <dmhouse> ndm, see ^^
11:22:50 <kzm_> dmhouse, My apologies.  When I checked in a few hours back, it was quiet as the grave - I presumed summer vacations had set in.
11:23:04 <dmhouse> kzm_: Hehe, I'm sure people won't mind.
11:23:30 <ndm> dmhouse: thanks, but i don't see why they shouldn't turn up
11:23:35 <ndm> they are pretty close, after all
11:23:58 <dmhouse> ndm, m b is a distinct type to b, and ($) and ($!) require that they be the same.
11:24:20 <ndm> dmhouse: yes, and it looses a mark for that, but there is nothing better
11:24:23 <dmhouse> I.e. if their types were (a -> b) -> a -> c, it'd be okay.
11:24:38 <ndm> unless you can give a function thats closer in spirit to that version
11:24:57 <ndm> it spotted that one on the basis you can easily wrap a return around the answer anyway :)
11:25:06 <dmhouse> I don't understand. It's not finding correct matches. Or does it use "You were probably looking for this" heuristics?
11:25:19 <ndm> it doesn't find exact matches
11:25:27 <ndm> for every match it has a list of "you were wrong because" things
11:25:35 <ndm> if its exactly right, that list is empty
11:25:47 <ndm> otherwise it scores penalty points for each negative point
11:26:03 <ndm> its matching is very loose - it makes it all up in the scoring
11:26:16 <dmhouse> Okay.
11:26:47 <ndm> its only "wrong" if there is something better matched, which I can't think of in that particular example
11:26:54 <ndm> the main reason it allows that is for lookup:
11:27:06 <ndm> @hoogle [(a,b)] -> a -> b
11:27:07 <lambdabot> No matches, try a more general search
11:27:26 <dmhouse> @hoogle a -> [(a, b)] -> b
11:27:26 <ndm> @hoogle Eq a => [(a,b)] -> a -> b
11:27:27 <lambdabot> No matches, try a more general search
11:27:28 <lambdabot> No matches, try a more general search
11:27:54 <ihope> @hoogle lookup
11:27:55 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
11:27:55 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
11:27:55 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
11:27:55 <ndm> thats dons fault :) it works fine on teh web version
11:28:24 <ndm> anyway, it matches in the web version despite the fact that one is b and one is Maybe b
11:28:38 <ndm> argument order is entirely irrelevant - it doesn't even loose points for it
11:29:45 <ndm> i think dons has more restrictive matching in place, or maybe its an old version - i'll have to ask what patches are applied to it
11:31:23 <Stinger_> just thinkin of something, I don't suppose its possible to have an array of a class type or something like that
11:31:42 <ndm> Stinger_: higher ranked types give you this, I think
11:31:55 <dmhouse> Stinger_: a class type? What do you mean?
11:32:06 <dmhouse> You can have Foo a => Array a b, for example, sure.
11:32:35 <Stinger_> er sorry should have said list
11:36:52 <Stinger_> just thinking, in a normal OO system you have an abstract class, and you can make a list of references to that abstract class (with objects of different derived types). How would you do that sort of thing in Haskell?
11:37:15 <ihope> Um...
11:37:32 <Stinger_> if it is indeed possible
11:37:51 <ihope> Maybe you're looking for existential types, like interface types in OO languages.
11:39:01 <ihope> You define a class called, say, Foo, then you define a type as "data Bar = forall a. Foo a => Baz a" or "data Bar where Baz :: Foo a => a -> Bar".
11:39:01 <dmhouse> Stinger_: when you say 'reference', do you mean that in a different way to 'pointer'?
11:39:42 <Stinger_> well I'm just using the terminology for the said OO language here
11:39:56 <dmhouse> Yes, I'm not too well versed therein.
11:39:56 <ihope> And what is the said OO language?
11:40:28 <Stinger_> man I'm not doin a very good job of explaining myself heh
11:40:41 <ihope> It sounds to me like you want an interface, and a list of objects that implement that interface.
11:40:50 <Stinger_> basically yeah
11:41:06 <Stinger_> can that be done with haskell classes
11:41:20 <ihope> Well, first you create the class, then you create the type, then you make the type an instance of the class.
11:42:21 <ihope> Lemme whip something up...
11:42:28 <Stinger_> yeah I'm (to an extent) familiar with most of that
11:44:56 <ihope> http://pastebin.ca/78038
11:45:20 <ihope> That should explain it.
11:49:46 <rafl> I wonder if there is a reliable and portable way to get the ghc version number as well as the path to ghc-pkg in haskell.
11:53:18 <Stinger_> hmm ghci doesnt like your first instance declaration for some reason (there must be at least one non-type var in the instance head
11:54:10 <kzm_> Stinger, you generally want to uses Hs 'class' much less than OO-type class.  Usually, you want an algebraic data type instead. 
11:55:11 <Stinger_> do you mean something like Either/Maybe etc.?
11:58:08 <rindolf> Hi all!
11:58:22 <rindolf> I'd like to write a log analysis program in Haskell.
11:58:40 <rindolf> That scans some IRC logs, chunks them into phrases and counts each phrase.
11:59:19 <Stinger_> hmm ok looking at GADTs now
11:59:23 <dmhouse_> rindolf: Sounds fun :)
11:59:40 <rindolf> dmhouse_: yes.
11:59:52 <rindolf> dmhouse_: should I represent the state of the count using a Monad?
12:00:00 <dmhouse_> I would.
12:00:23 <rindolf> dmhouse_: OK.
12:00:28 <dmhouse_> It sounds more sequential than recursive, so I'd suggest State with an environment of a Map Phrase Count.
12:00:35 <the_lord> > "" == ""
12:00:36 <lambdabot>  True
12:02:10 <rindolf> dmhouse_: hmmm... sounds like greek to me.
12:02:43 <rindolf> dmhouse_: OK. I understand ghc ships with a binary tree implementation. What is it called?
12:02:48 <Stinger_> hmmm that was another thing I was wondering about, when you are modelling an imperative system, do you generally use one state monad and lump the whole thing in there together, or is there a method of breaking it up a bit
12:02:55 <rindolf> blanaced binary tree.
12:02:57 <ihope> Stinger_: eh, sorry, just a second...
12:03:02 <sjanssen> rindolf: it's in Data.Map (which is what dmhouse_ was referring to)
12:03:39 <ihope> You can delete the "instance Show a => MyShow a"; it doesn't really matter.
12:03:45 <dmhouse_> rindolf: Basically, there are two monads in the standard libraries you can use for holding state. Reader, and State. Reader is good when you don't want a mutable environment, or can process your instructions recursively rather than sequentially
12:04:08 <ihope> And I think you'd use one state monad, too. But try to make it extensible.
12:04:19 <|Steve|> > product []
12:04:20 <lambdabot>  1
12:04:25 <dmhouse_> For example, I have a Reader-based lambda calculus evaluator, because the evaluation of each term is innately recursive (do this, and in doing so, do that), not sequential (do this, then do that).
12:04:29 <Stinger_> seems a bit monolithic
12:05:03 <ihope> Well, in imperative languages, you're given one monad, and you can't get out. :-)
12:05:32 <Cale> Stinger_: usually for more complex scenarios you use the StateT monad transformer to construct a new monad more suitable to your situation -- for instance, various invariants can be enforced on the state
12:07:14 <Cale> (if you hide get and put, and only expose your own interface to the state
12:07:16 <rindolf> This http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html could really use a CPAN-like synposis.
12:07:16 <Cale> )
12:07:30 <Cale> rindolf: hm?
12:07:37 <Cale> What would that be like?
12:08:02 <Stinger_> hmm have to read more on them I suppose
12:08:03 <dmhouse_> Cale, you might be able to express those invariants with the type system, so you wouldn't have to worry about everything going through your API.
12:08:19 <Cale> dmhouse_: possibly, for simple invariants
12:08:23 <dmhouse_> I suppose in those situations it's more natural to define your own monad.
12:08:46 <Cale> dmhouse_: but for example, you've seen my Sudoku solver, right?
12:08:51 <dmhouse_> Right.
12:09:02 <rindolf> Cale: http://search.cpan.org/~shlomif/HTML-Widgets-NavMenu-1.0000/lib/HTML/Widgets/NavMenu.pm#SYNOPSIS
12:09:03 <lambdabot> Title: "HTML::Widgets::NavMenu - A Perl Module for Generating HTML Navigation Menus - se ..."
12:09:19 <Cale> I enforce the rules of Sudoku on the current board condition
12:10:04 <Cale> rindolf: so by "synopsis" you mean "example"?
12:10:20 <dmhouse_> rindolf: I've written a Map example on the Haskell wikibook.
12:10:50 <dmhouse_> rindolf: http://en.wikibooks.org/wiki/Haskell/Hiearchicial_libraries/Maps#Example
12:10:52 <Cale> most of the functions in that library require little explanation on use
12:11:47 <wolverian> Cale, in perl parlance, "synopsis" means "a short usage example". I think haddock's idea is more of an index.
12:11:49 <dmhouse_> Cale: hrm, I wonder how your Sudoku invariants could be expressed with the type system.
12:12:25 <Cale> wolverian: yeah, a synopsis in general is usually like a summary
12:12:37 <Philippa> I think more precisely "synopsis" probably means "overview of system lifetime" here?
12:13:01 <Cale> dmhouse_: it would likely be ridiculously complicated :)
12:13:06 <dmhouse_> Firstly you'd need to define some collection whose elements were in the type, and somehow express how these had to be unique.
12:13:08 <Philippa> with an explicit or implicit "-- ... more usage as per the above" at some point before various shutdown occurs?
12:13:14 <Cale> dmhouse_: With lots of typeclass swindling
12:13:28 <Cale> Philippa: hm?
12:13:28 <dmhouse_> Cale, I think GADTs might be able to do it. 
12:13:55 <franka> Does anyone want to give a talk at the Haskell User Meeting in Utrecht?
12:13:57 <sjanssen> to do invariants at the type level, you'd need to express the current board state as a type, yeah?
12:14:06 <Cale> sjanssen: yes
12:14:20 <Cale> So essentially, you'd end up solving the puzzle at compile time :)
12:14:28 <dmhouse_> sjanssen: more or less.
12:14:29 <sjanssen> or use existentials
12:14:40 <Cale> yeah, I suppose that might be possible
12:14:53 <dmhouse_> Hell, if it weren't for IO, everything could be done at compile-time :)
12:14:58 <Philippa> Cale: synopses still. Seems to me a good one's summarising how a system works
12:15:30 <Cale> Philippa: oh, lifetime as in during the execution of a program
12:15:45 <Cale> Not lifetime in terms of development cycles :)
12:15:49 <Philippa> not necessarily. Could be as in module or instance lifetime. But yeah
12:20:58 <franka> How does having the Haskell User Meeting in Utrecht on October 8-9 (Sat.-Sun.) grab you?
12:21:29 <lispy> there is no way i colud make taht
12:21:31 <lispy> ;)
12:22:12 <franka> Well, if anyone has suggestions for the Haskell User Meeting, for example, date, agenda, etc., email me.
12:22:35 <lispy> franka: i was teasing because i can't make it in general
12:22:51 <franka> OK.
12:29:51 <urz> is there a category theory irc channel?
12:30:53 <Cale> I don't think there is one specifically for category theory
12:31:08 <Cale> Category theory is often discussed in #haskell and #math though
12:32:49 <urz> well i'm trying to learn it
12:33:52 <urz> F(A) = AxA is a polynomial functor and as such it's category of algebras Alg(F) has an initial algebra, right?
12:36:43 <urz> What would the initial algebra send to?
12:37:19 <urz> how old is freenode #math?
12:37:30 <urz> i dont remember freenode having a significant math channel
12:37:47 <Cale> It's been around for at least 4 years
12:37:56 <rindolf> How do I create an empty PhraseCounter where type PhraseCounter = Map String Integer
12:38:00 <rindolf> ?
12:38:00 <Cale> I'm not sure about before then
12:38:15 <Cale> urz: yes, it is a polynomial functor, so yeah
12:38:29 <sjanssen> @hoogle Map a b
12:38:30 <lambdabot> Data.Map.empty :: Map k a
12:38:30 <lambdabot> Data.Map.deleteMax :: Map k a -> Map k a
12:38:30 <lambdabot> Data.Map.deleteMin :: Map k a -> Map k a
12:38:31 <Cale> urz: send to?
12:38:53 <urz> well, let F:Set->Set
12:38:59 <urz> so its a cross product functor
12:39:05 <Cale> right
12:39:11 <Cale> It's sending A to AxA
12:39:28 <Cale> and f to f x f
12:39:42 <urz> yeah and F-algebras send BxB->B for particular sets B
12:40:17 <urz> so they are essentially binary operations
12:41:06 <Cale> yeah
12:41:08 <urz> so there is an initial algebra binary op
12:42:01 <urz> I think it probably sends (a,b) to (a,b), but from what set are we taking a and b from?
12:43:27 <monochrom> I have forgotten alot about initial algebras.  But my impression is that this particular one is close to trivial, as in it does almost nothing.
12:43:46 <Cale> yeah
12:44:11 <Cale> I'm getting a picture in my head of two infinite binary trees being joined into a single larger one :)
12:44:22 <Cale> (which is isomorphic to each)
12:44:41 <fasta> Where can I find documentation for HaXml 1.15?
12:45:13 <monochrom> The carrier of an initial F-algebra satisfies F(X)=X more or less; moreover it is the least fixed point we want.  XxX=X has a very uninterested least fixed point.
12:45:41 <monochrom> s/uninterested/uninteresting/
12:46:05 <Cale> I'm thinking it'll be a one element set.
12:46:16 <Cale> in fact, any one element set will do
12:46:28 <fasta> Never mind, I found it, luckily...
12:46:31 <urz> XxX=X. hm.
12:46:37 <Cale> with the morphism sending A x A -> A in the only possible way
12:47:22 <monochrom> To be correct, replace = by some kind of equivalence (perhaps bijection? I forgot)
12:47:34 <urz> if XxX=X, does this mean X is the empty set?
12:48:07 <Cale> well, yes, but equality is not really what we have here
12:48:12 <urz> well teh intial algebra is an isomorphism (and in this category, that is a bijection)
12:48:59 <urz> so really all we need is that |XxX| = |X| 
12:49:11 <Cale> XxX is isomorphic to X for finite sets when X has 0 or 1 elements, or for any infinite set.
12:49:11 <monochrom> Still, "XxX isomorphic to X" and "least solution" leaves you something very uninteresting.
12:49:44 <urz> i dont know what "least solution" means at all
12:50:16 <rindolf> Can anyone take a look at this, please - http://sial.org/pbot/18191 ?
12:50:17 <lambdabot> Title: "Paste #18191 from "rindolf" at 88.155.89.47"
12:50:38 <monochrom> Smallest set, roughly speaking.
12:52:15 <ihope> @hoogle intersperse
12:52:15 <lambdabot> List.intersperse :: a -> [a] -> [a]
12:52:48 <Cale> An object of our F-algebra category is a pair (A,), where A is a set, and  is a binary operation on A. The arrows of the category (A,) -> (B,) are given by functions f: A -> B such that f .  =  . (f x f)
12:53:44 <isaacd> rindolf: foldl (++) "" === quadratic behavior. Use 'concat'.
12:53:46 <franka> Huh-huh.  You said, "".  Huh.
12:54:10 <urz> do i need to use a unicode terminal?
12:54:10 <rindolf> isaacd: oh, yes.
12:54:12 <urz> heh
12:54:29 <Cale> urz: yes, FreeNode is in UTF-8 by convention :)
12:54:32 <rafl> Is there a ghc equivalent to perls Config.pm, which contains paths the executable was configured with, libraries to link against, etc?
12:54:34 <ihope> foldl (++) "" is quadratic?
12:54:45 <Philippa> yes
12:55:14 <monochrom> Yes, please use a UTF-8-knowledgeable environment.  Also it was the greek letter alpha, so make sure you have the fonts too.
12:55:15 <Cale> An object of our F-algebra category is a pair (A,a), where A is a set, and a is a binary operation on A. The arrows of the category (A,a) -> (B,b) are given by functions f: A -> B such that f . a = b . (f x f)
12:55:24 <ihope> What about foldl'?
12:55:35 <Philippa> the problem's ++'s behaviour
12:55:44 <Philippa> you can't stop each invocation from re-walking the list
12:55:52 <ihope> Ah.
12:56:08 <rindolf> How can I have a Map-like Monad with state that I can elements to?
12:56:27 <Cale> rindolf: State (Map a b) ?
12:56:35 <rindolf> Cale: maybe.
12:56:40 <ihope> So concat ((x:xs):xss) = x : concat (xs:xss); concat ([]:xss) = concat xss; concat [] = []?
12:56:42 <|Steve|> Philippa: How are lists stored? I'd have guessed that it would know where the end was at the very least.
12:56:50 <franka> What is Map?
12:56:59 <Philippa> |Steve|: they don't
12:57:04 <Philippa> they're cons-lists
12:57:14 <ihope> Linked lists.
12:57:19 <Philippa> almost linked lists, yeah
12:57:24 <ihope> Almost?
12:57:28 <franka> Is that in that applicative functor paper I haven't read?
12:57:31 <Philippa> strictly speaking they're a similar-but-distinguishable structure
12:57:35 <Cale> An initial object of our category is a pair (I,i) such that for every (X,x), there is precisely one morphism (I,i) -> (X,x)
12:57:36 <|Steve|> Having written many a linked list implementation, I know how to keep a pointer to the last cell.
12:57:48 <urz> i switched, but for some reason this terminal is a lot slower and i can see a wave run down it every time it scrolls
12:58:02 <Philippa> |Steve|: doesn't work like that. You'd have an explicit last pointer on every item in the list too...
12:58:26 <Philippa> data List a = Nil | Cons a (List a) -- this is isomorphic to [a]
12:58:32 <Cale> so there's precisely one morphism f: I -> X such that f . i = x . (f * f)
12:59:02 <Philippa> it's just an ordinary datatype. No special hacks to maintain an end pointer. Nothing stopping you from taking "part of a list", and most functions on lists do exactly that for each item in the list...
12:59:06 <|Steve|> Philippa: be that as it may, that doesn't preclude a haskell implementation from making optimizations.
12:59:16 <Cale> I'm thinking it's (0,e), where 0 is the empty set, and e is the empty function
12:59:33 <sjanssen> |Steve|: a last pointer wouldn't be an optimization
12:59:49 <isaacd> ihope: well, concat could also be defined as foldr (++) []
12:59:56 <isaacd> and still be linear
12:59:59 <Cale> There's always exactly one map from the empty set to any set at all.
13:00:06 <urz> Cale, isnt the category we are dealing with simply Set?
13:00:07 <Philippa> |Steve|: that's not as easy as you think it is
13:00:09 <sjanssen> the only function that would be faster is last, but it'd increase the size of each cell by the size of a pointer
13:00:14 <|Steve|> It most certainly would for concat. The cell itself need not know anything about the last pointer but there's nothing that says you couldn't have a list structure that did know.
13:00:14 <Philippa> in many cases it's be a significant pessimisation in space
13:00:23 <ihope> > case 3 of {}
13:00:23 <lambdabot>  Parse error
13:00:26 <ihope> Aww.
13:00:26 <Cale> urz: the category we're finding an initial object of is not Set
13:00:28 <Philippa> the cell damn well does need to know, because every cell is the head of a new list
13:00:51 <sjanssen> |Steve|: having a last pointer doesn't help for append, because append has to create an entirely new list
13:00:54 <Cale> urz: We're working in the category of F-algebras
13:01:01 <Philippa> sjanssen: that too
13:01:03 <urz> oh
13:01:17 <|Steve|> Philippa: It doesn't have to be implemented that way as long as haskell's semantics are preserved.
13:01:29 <Philippa> |Steve|: it's impossible to implement it any other way in the general case
13:01:33 <Cale> but in this case it hardly matters because our result is so similar :)
13:01:42 <|Steve|> I don't buy that it's impossible to do it.
13:01:44 <Philippa> you *don't know* when something's going to take part of the list
13:01:49 <Philippa> you haven't the slightest damn clue
13:01:56 <|Steve|> And lazy evaluation could prevent needing to actually construct the new list.
13:02:07 <Cale> We get the empty set, with the empty binary operation
13:02:09 <Philippa> it already does that, so what?
13:02:13 <Cale> It's very boring :)
13:02:16 <urz> i was thinking of an F-algebra as being the Set-morphism rather than the pairing of that with its target set
13:02:38 <Philippa> actually, wait. You could optimise this perfectly
13:02:44 <Philippa> it just doesn't do what you think it does...
13:02:49 <Philippa> endOf xs = []
13:02:57 <Philippa> buys you jack shit
13:03:18 <Cale> An F-algebra is an object A together with a morphism  a: FA -> A.
13:03:21 <|Steve|> ...I never said it did.
13:03:32 <Philippa> you did when you called it an optimisation
13:03:41 <|Steve|> I was talking about an implementation detail. Not something to be implemented in haskell.
13:03:45 <isaacd> Philippa: well, what about infinite lists? :-p
13:03:56 <isaacd> Do they have an "end"?
13:03:57 <Philippa> your implementation detail doesn't work
13:04:03 <Cale> And an F-algebra morphism (A,a) -> (B,b) is a morphism f: A -> B which has f . a = b . Ff
13:04:10 <Philippa> isaacd: yeah, I realised that just before you said it. Of course, non-termination is always an option
13:04:12 <|Steve|> You haven't given me any reason to believe it doesn't.
13:04:22 <|Steve|> You've just said it's impossible.
13:04:24 <Philippa> you couldn't possibly gain by it
13:04:31 <Philippa> because you *can't modify the end of the list*
13:04:46 <Cale> That turns the collection of F-algebras into a category
13:04:58 <|Steve|> Ah well. You don't understand. It's not important to me.
13:05:20 <falconair> does anyone know where I can find an example of a type which models list comprehensions?  I found a DsListComp.lhs, but it is apparently not exactly haskell code (i'm new to haskell syntax, much less this lhs code)
13:05:29 <Philippa> fine. Give me one good example of such an optimisation actually doing anything useful, complete with the rules necessary to apply it
13:05:40 <falconair> (by the way, DsListComp.lhs comes from GHC source code)
13:06:35 <|Steve|> Philippa: Iterating over the list A ++ B. Rather than constructing a new list, you need only know when A ends so that way an implementation iterates over A, and then over B.
13:06:48 <Philippa> insufficient detail. Please expand.
13:07:01 <Cale> We know that any two initial objects of a category are isomorphic (somewhat obviously), so it suffices to find one such algebra
13:07:08 <sjanssen> |Steve|: laziness gives us that property
13:07:09 <|Steve|> Insufficient where?
13:07:28 <Cale> and indeed (0,f) does it, where f is the unique map 0 x 0 -> 0
13:07:30 <|Steve|> sjanssen: I'm not sure that's true. When you actually iterate over the list and examine each element, it has to actually construct the list.
13:07:40 <urz> 0 being the empty set?
13:07:43 <Cale> yes
13:07:45 <Philippa> sure, it has to anyway
13:08:10 <|Steve|> With my idea, it doesn't.
13:08:10 <isaacd> |Steve|: But constructing it while iterating through it is no loss, not asymptotically anyway
13:08:16 <Philippa> what you can do is eg show that cells of the new list (A ++ B) are only used once
13:08:28 <sjanssen> |Steve|: oh, I suppose.  But if each cell is consumed and thrown away, it isn't a big deal.  Plus we have list fusion to address
13:08:31 <sjanssen> this
13:08:43 <|Steve|> isaacd: It is if it takes quadratic time though.
13:08:55 <|Steve|> If constructing the next element of the list requires walking the whole list.
13:08:58 <Cale> So yeah, this is a boring example. More interesting is 1 + B x B
13:09:00 <Philippa> ++ doesn't. Repeated use of ++ does
13:09:11 <|Steve|> Yes, you were talking about repeated use of ++.
13:09:13 <isaacd> |Steve|: Quadratic time happens when iterating through it repeatedly
13:09:15 <Philippa> OTOH, concat doesn't
13:09:22 <monochrom> ++ itself is in turn a foldr over a constructor.  This together with laziness gives you very sensible performance.
13:09:49 <isaacd> Left-associative use of (++) is the time-waster.
13:09:56 <|Steve|> How does concat work then?
13:10:08 <monochrom> To see this, the best way is to manually simulate the thunking and forcing yourself through a lifetime of a++b.
13:10:16 <sjanssen> @type foldr (++) []
13:10:17 <lambdabot> forall a. [[a]] -> [a]
13:10:23 <isaacd> |Steve|: right-associatively applying (++) to the list members
13:10:27 <sjanssen> |Steve|: looks light that
13:10:31 <urz> you are taking F(B) = 1 + BxB ?
13:10:32 <monochrom> concat is a foldr over ++ so that's nice too.
13:10:56 <Cale> urz: yes
13:11:05 <sjanssen> @type foldr (foldr (:))
13:11:05 <|Steve|> Remind me again the difference between foldr and foldl.
13:11:06 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:11:49 <falconair> ... hm... can some please point out what *.lhs files actually are?  it looks like a mix of haskell and c code
13:11:56 <isaacd> |Steve|: foldr (++) [] --> (e1 ++ (e2 ++ (e3 ++ ... (e4 ++ []))))
13:11:59 <sjanssen> oops, that should be foldr (flip foldr (:)) []
13:11:59 <roods> i'm just learning haskell and was try to implement different sort routines. can someone show me how to implement http://www.cs.vu.nl/~dick/gnomesort.html
13:12:01 <lambdabot> Title: "Gnome Sort - The Simplest Sort Algorithm"
13:12:11 <Cale> There, the initial algebra will be the set of unlabelled, finite, ordered binary trees with the map sending 1 to the tree consisting of a single vertex, and an element of Tree x Tree to the tree with those two trees as children.
13:12:23 <|Steve|> isaacd: okay.
13:12:23 <isaacd> |Steve|: foldl (++) [] --> (((([] ++ e1) ++ e2) ++ e3) ++ ... e4)
13:12:28 <urz> in this case algebras are (c,*) for binary operations *
13:12:32 <|Steve|> That's what I thought.
13:12:33 <urz> right?
13:12:47 <sylvan> falconair: , lhs is literate haskell... where rather than escaping comments (by using --) you escape the code (by using >)
13:12:57 <Cale> Algebras are sets (A,f) where f : 1 + AxA -> A
13:13:25 <|Steve|> So why not use foldr (++)?
13:13:26 <Cale> pairs, I should say
13:13:53 <urz> I'm letting [c,*] 1 = c and [c,*] (a,b) = a*b
13:14:06 <Cale> ah, okay
13:14:13 <Cale> then yes
13:14:18 <isaacd> falconair: or TeX-style markup with code between \begin{code} and \end{code}
13:14:49 <Philippa> |Steve|: because concat is quicker to write and conveys the intention
13:14:51 <falconair> sylvan, isaacd: so there must be a way of converting lhs file to a simple hs file, no?
13:14:55 <Cale> and the initial one will be the set of trees I described
13:15:03 <Philippa> oh, and because you missed out a []
13:15:12 <|Steve|> You're right, I did.
13:15:19 <urz> binary trees
13:15:25 <Cale> yeah
13:15:32 <isaacd> falconair: yes, although the compiler does it anyway
13:17:18 <falconair> isaacd: i know GHC has to have an implementation of list comprehension somewhere (obviously), I need to extract that haskell code, is it documented somewhere how I can translate all lhs file to hs source code?
13:17:21 <Cale> There's only one way to map the algebra of trees to any other F-algebra
13:17:38 <Cale> You send the single vertex to what you called c
13:18:28 <Cale> and you send the tree whose children are r and l to r' * l', where r' and l' are the images of r and l under this map.
13:20:17 <Cale> Really, this corresponds to the Haskell datatype, data Tree = Nil | Branch !Tree !Tree
13:20:31 <fasta> If anyone asks what's "the best" XML library for Haskell, the answer is HaXml.
13:20:37 <isaacd> falconair: hmm, there is an unlit program (with GHC), but IIRC it doesn't preserve the non-code portions as comments -- there was this question a while ago in #haskell
13:20:39 <urz> why do you use the ! marks?
13:20:47 <Cale> (note the strictness flags, because we want the least fixed point, not the greatest)
13:21:04 <Cale> We're excluding infinite trees
13:21:16 <falconair> isaacd, thanks, i'll look for the unlit prog and google for further info
13:21:28 <Cale> Oh,  suppose you have to ignore _|_ too
13:22:18 <Cale> but essentially, that's the idea behind it
13:23:12 <roods> Cale: can you answer my question?
13:23:35 <Cale> roods: oh, sorry, I missed it... implementing gnome sort?
13:23:37 <urz> i read in the tutorials that every datatype shares the value _|_ but the hugs and gcc don't recognize the symbol
13:23:47 <roods> Cale: yup :)
13:24:00 <roods> Cale: the more simple and readable the better :)
13:24:04 <Cale> urz: yeah, it just means nontermination or error
13:24:25 <Cale> urz: you can get an easy bottom value using undefined, which is in the prelude
13:24:29 <Cale> @type undefined
13:25:00 <urz> ghc i meant to say
13:25:19 <Cale> @bot
13:25:32 <Cale> anyway, undefined :: forall a. a
13:25:35 <lambdabot> forall a. a
13:25:41 <lambdabot> :)
13:25:47 <Cale> ah, one of us is just slow :)
13:25:53 <sylvan> @paste
13:25:53 <lambdabot> http://paste.lisp.org/new/haskell
13:25:55 <urz> I want to understand the conection between least/greatest fixed point and strict/lazy evaluation
13:26:20 <lisppaste2> sylvan pasted "gnome sort" at http://paste.lisp.org/display/22018
13:27:26 <sylvan> roods, there's my stab at gnome sort
13:28:29 <Cale> It's a little odd reinterpreting imperative algorithms of that sort :)
13:28:49 <Cale> Whether you really have the "same" thing is a little hard to tell
13:29:31 <Cale> but sylvan's approximation is decent
13:29:45 <sylvan> roods, I keep the "gnome position" by simply splitting the list into elements that are behind him and in front of him (the "behind" list is thus reversed, the last visited element is first -- which is the reason I reverse the comparison), so moving back and forth in the list is done by moving the heads between the two lists
13:30:03 <sylvan> but yeah, this is hardly a "simple" sort in a functional language
13:30:11 <sylvan> or at least not *the* simplest
13:30:22 <Cale> I find it a little hard to see that it even works :)
13:30:26 <roods> sylvan: ya it is kind of weird to write this in a functional language. in c++/c i think of it happening in place. where in a function langauge it is as if i'm maintaining a tmp array.
13:31:13 <Cale> I'd say the simplest sort algorithm is probably quicksort, using the head of the list as pivot :)
13:31:23 <roods> sylvan: thanks.
13:31:31 <sylvan> you could think of the comma in the tuple as being the "gnome", so you when you move through the list you simple put elements from one side of the comma to the other side
13:31:55 <rafl> Is there some kind of module that handles file paths in a portable fashion?
13:32:15 <Cale> rafl: people have written various attempts at that
13:32:53 <Cale> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php -- Data.FilePath here is supposed to work
13:32:55 <lambdabot> Title: "Neil Mitchell - Haskell Libraries"
13:33:37 <rafl> Cale: Thanks.
13:34:17 <isaacd> :( now it's GHC-6.4.2 that's panicking on my code: ghc-6.4.2: panic! (the `impossible' happened, GHC version 6.4.2): checkHiBootIface RoboWarziRoboTalkziCompile.SourceLocation{tc r9pP}
13:35:39 <isaacd> I suppose I should report it as a compiler bug, as it says to do
13:40:53 <Cale> urz: I think to get greatest fixed points category theoretically, you consider F-coalgebras, that is objects A paired with morphisms a: A -> FA, where the homomorphisms (A,a) -> (B,b) are morphisms f: A -> B such that Ff . a = b . f
13:41:01 <Cale> and take the terminal F-coalgebra
13:42:05 <Cale> urz: so it's sort of a dual construction all the way along
13:43:24 <urz> when we say fixed point, we are talking about fixed point of the base functor F ?
13:44:03 <Cale> yeah
13:44:06 <urz> so F(B)=1+BxB has a fixed point B which is the set of finite binary trees?
13:44:21 <Cale> right
13:44:51 <Cale> It also has a fixed point which is the set of possibly infinite binary trees
13:45:39 <urz> how do you order the fixed points?
13:45:49 <urz> inclusion?
13:46:04 <urz> the finite binary trees are a subset of the possibly infinite ones?
13:46:14 <urz> so it is a lesser fixed point
13:46:25 <Cale> Probably by morphisms
13:47:33 <Cale> I'm not entirely sure really
13:47:47 <Cale> You really want to be able to consider the algebra/coalgebra structure there
13:48:22 <Cale> but they're not the same category, so that's a little difficuly
13:48:24 <Cale> t*
13:48:32 <urz> im reading Alegebra of Programming by Bird and somebody else.  They mention coalgebras being connected to infinite data structures but put any details outside the scope of the book
13:49:02 <Cale> Well, yeah, it's the exact same thing that you do with algebras, only dualised :)
13:49:21 <urz> well category theory doesnt exactly come naturally to me
13:49:21 <Cale> and you tend to end up with infinite structures rather than finite ones
13:49:31 <Cale> http://en.wikipedia.org/wiki/F-coalgebra
13:49:39 <Cale> http://en.wikipedia.org/wiki/F-algebra
13:49:42 <Cale> compare :)
13:50:04 <Cale> the example they give for coalgebras is a good one
13:50:26 <Cale> I wish they'd used it for algebras too, since it makes a good comparison.
13:50:36 <urz> is an endofunctor a functor whose source and target categories are the same?
13:50:41 <Cale> yes
13:50:56 <urz> wikipedia is unclear on that, it sends endofunctor to the page for functor which never mentions endofunctor
13:51:14 <bringert> @hoogle Monad m => m a -> m b -> m a
13:51:15 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:51:15 <lambdabot> Prelude.const :: a -> b -> a
13:51:15 <lambdabot> Prelude.seq :: a -> b -> b
13:51:23 <Cale> urz: ah, hehe
13:51:52 <fasta> Do Template Haskell and ghci play nice together?
13:52:38 <Cale> fasta: I think so
13:53:19 <fasta> urz: I don't think you want to learn Category Theory from wikipedia.
13:53:25 <urz> yeah heh
13:53:58 <urz> btw, what is "program derivation" ?
13:54:04 <Cale> hmm
13:54:16 <monochrom> Derive implementation from specification.
13:54:24 <kpreid> bringert: perhaps you want (flip (>>))
13:54:30 <Cale> ah, in that sense :)
13:55:04 <bringert> kpreid: no, I want to have the first action done first, then the second, and return the result of the first
13:55:17 <bringert> kpreid: i.e. evaluation order matters
13:55:28 <Cale> http://en.wikipedia.org/wiki/Program_derivation has a nice description of the idea
13:55:28 <urz> whats an example of implementation being derived that way?
13:55:43 <kpreid> @pl \a b -> a >>= \v -> b >>= return a
13:55:43 <lambdabot> liftM2 (.) (>>=) ((const .) . (=<<) . return)
13:55:48 <monochrom> The very book you're reading.
13:56:13 <urz> is that the only example then?
13:56:15 <kpreid> bringert: in the absence of a trick, I would just write that out in do-notation
13:56:29 <bringert> @pl \a b -> a >>= \v -> b >> return v
13:56:29 <lambdabot> (. ((. return) . (>>))) . (>>=)
13:56:39 <monochrom> The book is full of examples in the later chapters.  Program derivation is the book's sole purpose.
13:56:41 <urz> i wanted a simple small example so i just see what the phrase is actually trying to say
13:56:44 <bringert> @type \a b -> a >>= \v -> b >> return v
13:56:45 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => m a -> m a1 -> m a
13:56:50 <urz> ok
13:56:59 <urz> well im trying to read it in order
13:57:16 <kpreid> bringert: oops, my error
13:57:28 <bringert> kpreid: right, it just seems like a common enough thing that it should be in the standard libs
13:57:42 <kpreid> hmm
13:57:57 <monochrom> It will take you a month or two before you reach that point.  It certain took me a month or two.  And I have never finished. :)
13:58:02 <urz> its an unusual book that doesnt tell you what its about and doesnt give you any examples of the subject it is about till the end
13:58:05 <kpreid> @hoogle Monad m => m a -> m b -> m c -> m b
13:58:06 <lambdabot> No matches, try a more general search
13:58:10 <erider> > (+) 100 4322
13:58:11 <lambdabot>  4422
13:58:26 <kpreid> bringert: I have the feeling I saw something like that once
13:59:05 <mikael> hey guys
13:59:17 <monochrom> The prologue material certainly states that it is about program derivation in some framework.  But to appreciate what framework it is and how the derivations are done and what you can do with it, of course it is a big uphill battle.
13:59:21 <mikael> bringert: hey, still at chalmers? :-)
13:59:29 <isaacd> @type finally
13:59:30 <lambdabot> Not in scope: `finally'
13:59:30 <bringert> @type Control.Exception.bracket_
13:59:32 <lambdabot> forall c b a. IO a -> IO b -> IO c -> IO c
14:00:09 <bringert> mikael: yep, PhD student now
14:00:22 <mikael> oh, neat.  what are you working on?
14:00:27 <norpan> const (const id)
14:00:29 <norpan> you're welcome
14:01:25 <bringert> norpan: that doesn't quite do what you'd expect for monads
14:01:45 <bringert> mikael: functional programming and natural language technology
14:02:03 <monochrom> Bear in mind that if you do not already know categories, a book about programming with categories has to have several chapters on categories before it can talk about programming.
14:02:24 <urz> heh
14:02:51 <norpan> that's what you get when only specifying a type htough
14:03:04 <urz> i took a grad course in categories
14:03:23 <monochrom> There was an ancient civilization whose number system was "one, two, many".  That's it.  Imagine now you have to write a book "numerical recipes in C" for its people.  What will you do?
14:03:29 <urz> we zipped right through it and there was never any mention of applications to programming
14:03:39 <urz> i promptly forgot most of it
14:03:44 <mikael> bringert: any specific branch of natural language technology?
14:03:47 <Rheiny> monochrom: it's actually a Brazilian tribe still alive
14:04:01 <mikael> o hi Rheiny
14:04:10 <mikael> you're from SH/SC, right? ^.~
14:04:15 <Rheiny> yeah
14:04:19 <monochrom> I would imagine your book will contain nine chapters on the real numbers.
14:04:47 <urz> na
14:04:49 <bringert> mikael: grammar-based stuff, mainly related to GF: http://www.cs.chalmers.se/~aarne/GF/
14:04:51 <lambdabot> Title: "GF Version 2.6"
14:05:01 <monochrom> The tribesmen will definitely complain "when will you get to the programming?"
14:05:20 <monochrom> perhaps s/complain/wonder/
14:06:03 <monochrom> It is not so much that the book doesn't reveal its purpose until the end.  It is more like the civilization is not advanced enough.
14:06:56 <urz> ya damn it, we need to teach category in grade school 
14:06:59 <urz> ;)
14:07:16 <monochrom> If some rudimentary category stuff were in every highschool curriculum, Bird's book would not be this dense.
14:07:41 <mikael> bringert: neat.  good luck with that!  I'm enrolling in GU's CS course this fall, by the way, and SGS finally threw me an apartment (a tiny one in olofshojd, with a communal kitchen...) :-)
14:08:28 <urz> monochrom: now that you've read it, does it affect the way you program?
14:09:04 <bringert> mikael: sweet. Well, at least the CS stuff. Olofhjd isn't the greatest place on earth, but it's at least reasonably close to Chalmers and the city center
14:10:02 <monochrom> I had already been converted (to the derivation way) before I met this book.  I do not use its theory.  I use something simpler.
14:10:37 <mikael> yeah.  I was hoping for a place at rotary's, but I didn't want to turn down this offer and have to go for something even worse
14:11:31 <bringert> mikael: I lived at Rotary for a while. It was more like Rttary for while, but the location is good. 
14:12:01 <monochrom> There is one thing I can't do and the theory in this book can.  Greedy algorithms.  But I have not read or understood that chapter.
14:12:27 <bringert> bringert: feel free to drop by my office. Most of your courses will be right in our building, where we were for EuroHaskell
14:12:41 <bringert> eh, that was for mikael, not me
14:12:42 <mikael> ow :-) yeah, right across the street from chalmers and in the same building as a student pub seems sweet
14:12:47 <mikael> oh, awesome
14:13:21 <urz> monochrom: would you recommend i learn your method instead of this books?
14:13:34 <bringert> mikael: actually the Rotary pub is not a student pub as such, it's just run by students and frequented by them
14:13:41 <bringert> but its actually open to the public
14:13:43 <mikael> ah, okay
14:13:47 <bringert> and has really cheap beer
14:13:51 <mikael> heh
14:14:33 <monochrom> I recommend knowing everything.
14:15:30 <bringert> time for lunch
14:15:34 <monochrom> But in any case, http://www.cs.toronto.edu/~hehner/aPToP/
14:15:35 <lambdabot> Title: "a Practical Theory of Programming"
14:15:37 <bringert> bbl
14:15:38 <mikael> I heard about andersca's job in cupertino, that's so cool
14:15:42 <mikael> oh, er, bye
14:16:05 <mikael> (are you confusing your AM and PM?)
14:16:08 <Janni> Hello.
14:16:41 <mikael> Rheiny: hey I'm phubuh by the way
14:16:47 <Rheiny> I know
14:16:51 <mikael> o
14:17:41 <bringert> mikael: I'm in Seattle atm
14:18:11 <mikael> oh!
14:40:48 <sylvan> mikael, if you're looking for an apartment with a really good location (*right* across the street from Chalmers, I mean, really, 50m from hrsalsvgen) I'm going to England for my masters thesis, will be gone for a year. The downside is the rent of about 4000:-, but if you can afford it maybe it'll be available...
14:41:15 <Igloo> sylvan: Whereabouts in England?
14:41:17 <sylvan> (I've sort of promised it to a friend, but it's not certain he'll want it)
14:41:33 <sylvan> Leicster or Birmingham, I'm going to Rare (the game company) and it's right between them
14:41:39 <sylvan> between those cities
14:41:56 <user317> has anyone been able to install c2hs on windows
14:42:10 <vincenz> re
14:42:18 <vincenz> @join #oasis
14:42:23 <vincenz> @bot
14:42:23 <lambdabot> :)
14:42:58 <madpickle> birmingham, eh?
14:43:03 <madpickle> hopefully not central b'ham
14:43:25 <sylvan> I'm leanin towards Leicester atm, seems to be far cheaper living expenses... 
14:43:50 <sylvan> Nothing's locked down yet, I'll live in a hotel for a while and go apartment hunting...
14:44:04 <madpickle> birmingham's a glorified crack town
14:44:10 <madpickle> (no offense to brummeys :)
14:44:11 <sylvan> heh
14:44:26 <madpickle> leicester's just a fairly tiny town.. never been there myself, though.
14:45:03 <sylvan> IIRC it's something like 240K people there though? Which is fairly decently sized in my book.. At least big enough to not be an issue
14:46:51 <madpickle> oh yeah, but compared to birmingham it's on the small(er) size
14:47:38 <sylvan> yeah.. but then again it's not a crack town =)
15:00:39 <kzm_> Is there a good way to make Data.Map.unionWith strict?  I worry that I'm building huge unevaluated thunks in my maps...
15:01:06 * kzm_ suspects he has to write his own unionWith.
15:05:40 <mikael> sylvan: oh, that's interesting!  how many m^2 is it?  (so I can plug it into the bostadsbidrag calculator)
15:11:36 <sylvan> mikael, 43
15:11:53 <sylvan> like I said, it's sort of up in the air right now, I have a friend who might take it...
15:12:47 <sylvan> mikael: , if you give me an email adress I could mail you if he doesn't end up taking it (I'll know within a week or so)
15:19:19 <mikael> I guess it isn't furnished?
15:19:25 <user317> anyone use windows?  i cant get c2hs to build on win32
15:19:27 <JKnecht> sylan: 4000 lbs/mo? For how much space?
15:20:03 <JKnecht> excuse sylvan.
15:20:11 <mikael> that's 4000 swedish kronor :-)
15:21:28 <JKnecht> oh, kroner, thought it was sterling.
15:21:55 <mikael> I certainly hope it's not
15:22:08 <madpickle> 4k squid a month is pricey
15:22:21 <madpickle> you may even get a 1-br hovel in london SW for that price :O
15:29:15 <JKnecht> that kronor figure is less than my rent of 600 USD which is considered cheap here.
15:34:54 <SyntaxNinja> xerox: alive?
15:35:15 <vincenz> > drop 10000000 $ iterate (+1) 
15:35:16 <lambdabot>    Expecting a function type, but found `a'
15:35:16 <lambdabot>    Expected type: [a]
15:35:16 <lambdabot>    ...
15:35:17 <vincenz> > drop 10000000 $ iterate (+1) 1
15:35:19 <sylvan> JKnecht: , it is sort of cheap, but it's one bed room and for a student (who usually get 6900:-  a month) it can be pricey
15:35:20 <lambdabot> Terminated
15:35:22 <xerox> YEs
15:35:24 <vincenz> > drop 1000000 $ iterate (+1) 1
15:35:25 <lambdabot>  Exception: stack overflow
15:35:27 <xerox> I just came back home
15:35:31 <vincenz> o.O
15:35:37 <xerox> SyntaxNinja: yo
15:35:44 <vincenz> stack overflow?
15:35:53 <vincenz> @hoogle iterate
15:35:54 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
15:35:57 <vincenz> @fptools Prelude
15:35:57 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
15:35:58 <JKnecht> sylvan: yes. I have a 2 bedroom.
15:36:53 <mikael> sylvan: will it be furnished?  (dunno if you saw me asking)
15:37:19 <sylvan> mikael:  yes. Most of my stuff will be left behind
15:40:16 <vincenz> Does anyone know why iterate blows its stack?
15:40:32 <vincenz> as far as I can tell it uses unfoldr, and unfoldr seems to be list-tail-recursive
15:40:41 <vincenz> or whatever the word is for non pure tail recursion but in a lazy list
15:45:33 <visq> if someone is bored, maybe I could get a hint on a type-checking confusion ?
15:46:24 <lisppaste2> visq pasted "Rigid variables ?" at http://paste.lisp.org/display/22024
15:47:03 <mikael> sylvan: okay, that's cool.  and it seems that I'd get about the full bostadsbidrag, which is 1100:-, whereas I think I'd only get 500:- with the olofshojd apartment, which has a rent of 3000:-...  my email is phubuh@gmail.com
15:47:15 <Lemmih> visq: 't' has type 'Either ParseError (a -> b,String)'.
15:47:27 <Lemmih> visq: Not 'Either ParseError (b,String)'.
15:47:53 <visq> Lemmih: thank you
15:48:00 <mikael> sylvan: does it have shower & kitchen(ette)?  by the way, I'm far from sure I'll be able to rent it, I'll try to find out more about the bureaucratic stuff tomorrow
15:49:56 <dcoutts> JohnMeacham, I was ondering about JRegex and ByteString
15:50:14 <dcoutts> we need a fast regex lib for ByteString and ByteString.Lazy
15:50:17 <sylvan> mikael:  yes, it has all of that, balcony facing chalmers as well :-)
15:50:23 <mikael> nice :-)
15:51:28 <bringert> mikael: what bureaucratic stuff is that?
15:53:26 <mikael> I mailed SGS a signed rental contract today, so I'll have to cancel that, and I'm not too sure about my calculations for the bidrag
15:54:09 <bringert> mikael: I think you are right about the bostadsbidrag. Back when I had it you would get the full 1100 if the rent was >= 3800
15:54:26 <bringert> mikael: though you lose it really quickly if you work and earn money
15:55:10 <bringert> mikael: I think you need 1 month notice for cancelling your lease with SGS if it is just a single room
15:55:32 <bringert> I don't know what happens if you cancel more than 1 month before the lease starts
15:55:42 <sylvan> mikael, I'm going to bed, but send me an email (sylvan@student.chalmers.se) and I'll contact you if I need someone to rent the apartment (again, I have a friend who might rent it)
15:55:51 <bringert> it should say on the contract though
15:57:06 <mikael> ah, yes, I was unsure about my income, but apparently you need a -lot- to not get the full 1100:-
15:57:11 <sylvan> SGS aren't short on people wanting apartments. I had one with SGS before I got this one and I could cancel with a few weeks notice (even though technically that's not allowed in the contract)
15:59:55 <mikael> sleep tight :-)
16:16:46 <mathewm> ?pl  xx (s,t) = putStr s ++ ": " >> putStr $ show t
16:16:46 <lambdabot> xx = uncurry ((. show) . (>> putStr) . (++ ": ") . putStr)
16:18:44 <mathewm> ?pl  xx (s,t) = putStr s >> putStr t
16:18:44 <lambdabot> xx = uncurry ((. putStr) . (>>) . putStr)
16:23:30 <mathewm> ?pl  xx (s,t) = putStr s >> putStrLn t
16:23:31 <lambdabot> xx = uncurry ((. putStrLn) . (>>) . putStr)
16:24:05 <mathewm> ?type (>>)
16:24:06 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
16:24:42 <mathewm> ?type ((. putStrLn)
16:24:43 <lambdabot> parse error (possibly incorrect indentation)
16:24:53 <mathewm> ?type (. putStrLn)
16:24:54 <lambdabot> forall c. (IO () -> c) -> String -> c
16:25:22 <mikael> hey, since I'm not 18, my contract with SGS can't even be binding, can it? :-o
16:26:37 <mathewm> ?type ((. putStrLn) ) . (>>))
16:26:38 <lambdabot> parse error on input `)'
16:26:45 <mathewm> ?type ((. putStrLn) . (>>))
16:26:46 <lambdabot> forall a. IO a -> String -> IO ()
16:28:14 <Sentinel> has anyone ported lamdabot or hsplugins to win?
16:37:51 <mathewm> ?pl  xx (s,t) = putStr s >> return ( length t )
16:37:52 <lambdabot> xx = uncurry ((. (return . length)) . (>>) . putStr)
16:39:06 <Philippa> hsplugins builds under windows
16:41:16 <Sentinel> oh cool
16:44:22 <mathewm> ?type (. putStrLn)
16:44:23 <lambdabot> forall c. (IO () -> c) -> String -> c
16:46:07 <Lemmih> mathewm: You can use lambdabot in private.
16:53:24 <mathewm> function composition is hurting my head...
16:53:34 <mathewm> sorry about the spam
16:53:35 <bringert> mikael: then they've changed it. It used to be that you could only make 38000 in a year, including the CSN grant, before they cut the bostadsbidrag
16:55:08 <bringert> mikael: will you be 18 when you start in fall? if not, there might be some interesting situations with alcohol permits and such
16:55:32 <mikael> not immediately, no.  my birthday's august 30
16:55:49 <bringert> just don't tell anyone
16:56:25 <bringert> andersca should know how that works with all the parties
16:58:31 <mikael> what's the nollning like?
16:58:49 <bringert> I don't really know what it's like in the GU CS program
16:59:01 <bringert> but I guess it's similar to the Chalmers ones
16:59:03 <mikael> ah, right
16:59:14 <bringert> lots of parties
16:59:33 <bringert> good opportunity to get to know some people in your class
17:00:29 <bringert> my experience is that for the first day or so, few people talk to each other. I think it is a good idea to talk to as many people as possible
17:00:40 <bringert> so that you don't miss out on any great people
17:01:09 <mikael> yeah :-)
17:01:50 <bringert> also, don't be afraid to interact with the lecturers and tutors
17:01:55 <bringert> they enjoy it
17:02:01 <bringert> eh, we
17:02:28 <bringert> it's so much more fun to be teaching a class with students who are interested and ask questions
17:02:43 <bringert> most students just sit quiet all the time
17:03:01 <bringert> and you don't get any feedback as to whether they understand what you are saying
17:03:10 <bringert> it's much better to ask questions
17:03:38 <bringert> if you are wondering about something, chances are at least half the class are too
17:03:45 <mikael> most my classes will be in a regular little classroom, right?  as opposed to the giant theaters they always have in the movies
17:03:53 <madpickle> no
17:04:00 <madpickle> most "class rooms" are for language classes
17:04:18 <madpickle> any department with a decent student attendance will usually use theatres
17:04:23 <bringert> mikael: the first years you will probably be in pretty large lecture halls
17:04:37 <madpickle> we had 240 in my first year
17:04:39 <madpickle> (doing CS)
17:04:40 <Pseudonym> Having taught a class of people who wanted to be there and a class of people who didn't want to be there, I'd definitely take the former over the latter any day.
17:04:45 <bringert> mikael: in the later years courses are more specialized and have fewer students
17:04:59 <madpickle> yeah
17:05:04 <madpickle> Functional Programming II springs to mind :P
17:05:20 <madpickle> lots of people doing Computer Graphics II and Web Applications though
17:05:32 <madpickle> Abstract data types had very few in mine too :P
17:05:33 <Pseudonym> Games and jobs respectively.
17:05:36 <bringert> madpickle: what university are you at?
17:05:40 <madpickle> was
17:05:45 <madpickle> swansea, wales, uk
17:05:49 <Pseudonym> Sadly, people don't really learn computer graphics theory.
17:05:55 <madpickle> that's what we did, really
17:05:56 <Pseudonym> Largely because lecturers don't understand it.
17:06:09 <madpickle> comp graphics i covered colours, writing convolution filters
17:06:22 <madpickle> rudimentary image compression and how to do basic filtering and image analysis
17:06:25 <bringert> mikael: the courses as Chalmers / GU are being rearranged and merged, so you could have courses with up about 200 people in them
17:06:35 <madpickle> comp graphics ii was more along the lines of 3d
17:06:46 <Pseudonym> I bet they never mentioned Clifford algebra once.
17:06:48 <madpickle> a handful of people wrote ray tracers as part of their 3rd-year dissertation
17:06:52 <bringert> mikael: the largest I was ever in at Chalmers had close to 300, but that was a bit too much for the biggest lecture hall
17:06:53 <mikael> bringert: oh, right, I heard something about that
17:06:55 <Pseudonym> Or Hilbert spaces.
17:07:01 <madpickle> neither ring a bell, so no =)
17:07:06 <mikael> at well, lecture halls seem cozy in their own special way :-)
17:07:06 <Pseudonym> :-)
17:07:12 <mikael> "ah well"
17:07:21 <madpickle> lecture halls rock
17:07:25 <madpickle> you can actually take a nap and not be seen
17:07:36 <bringert> mikael: sadly the number of applications to the CS, CS&E and IT programs seems to be dropping each year
17:07:37 <Pseudonym> There's only one lecture I actually fell asleep in.
17:07:43 <Pseudonym> Statistics, for the record.
17:07:46 <bringert> so we are forced to cut down on courses
17:07:52 <mikael> oh :/
17:08:09 <madpickle> i just played around with my pda
17:08:13 <bringert> madpickle: are you sure?
17:08:27 <mikael> the CS program at GU seemed great to me because after the first year, there are zero obligatory courses
17:08:28 <madpickle> bringert: yeah.. in the back.. if you have caring friends who wake you up
17:08:40 <madpickle> i remember in my first year we had one who fell asleep
17:08:41 <bringert> I thinks it's very easy to spot sleeping students even in lecture halls
17:08:43 <madpickle> so we drew on him
17:08:49 <mikael> and all the first-year courses seem worthwhile
17:08:52 <madpickle> and we all laughed and snapped pics of him with a camera phone
17:08:56 <madpickle> even our good lecturer had a laugh
17:09:00 <madpickle> we let him sit after we left
17:09:01 <Pseudonym> The operator representation of light transport, incididentally, is one of the most beautiful things in computer graphics.
17:09:02 <bringert> it's just that most lecturers don't do anything about
17:09:03 <bringert> it
17:09:07 <madpickle> he woke up in an empty, dark lecture theatre :P
17:09:11 <bringert> haha
17:09:17 <madpickle> it was good fun
17:09:21 <jsherlock> heh, yeah never fall asleep in the front of the lecture hall
17:09:24 <madpickle> we later on cleaned out his dorm room
17:09:24 <bringert> mikael: yes, that's good
17:09:29 <Pseudonym> It turns out that a ray that's cast in raytracing is the adjoint of a photon.
17:09:31 <madpickle> and he woke up in an empty room :P
17:09:50 <mikael> also, "fil kand" sounds more sophisticated than "civilingenjor"
17:09:51 <madpickle> r.e. lecturers not doing anything about people sleeping
17:10:00 <bringert> mikael: it's not though
17:10:02 <madpickle> my view is this: you're paying x pounds a year to study
17:10:10 <bringert> mikael: I think you'd get paid less
17:10:12 <madpickle> so you can theoretically do whatever you please, as long as you do not disrupt the class
17:10:13 <bringert> :-)
17:10:19 <mikael> yeah yeah :-)
17:10:26 <jsherlock> i used to have a lecturer who had a wireless mike if he needed to walk around looking for sleepers to embarass
17:10:32 <madpickle> lol
17:10:38 <madpickle> i have a horror story
17:10:47 <madpickle> our head of departmetn was a notorious evil professor
17:10:50 <madpickle> not in a strict sense
17:10:58 <madpickle> only when students acted stupid
17:11:11 <madpickle> one girl promised to do something for the next lecture, only to not show up at al
17:11:17 <madpickle> he acquired her phone number and called her in class
17:11:21 <mikael> haha
17:11:37 <jsherlock> haha, nice
17:11:41 <madpickle> another was againstn oise in class
17:11:48 <madpickle> which is.. terrible
17:11:51 <madpickle> and very frustrating
17:11:57 <madpickle> i'm no model student, but i never made noise in class
17:12:02 <madpickle> some people though...
17:12:08 <Pseudonym> Incidentally, the "you're paying x pounds a year" argument is something that's deeply wrong with the modern university.
17:12:09 <madpickle> we had a lecturer (this guy's a real whackjob)
17:12:22 <madpickle> who THREW (i kid you not) a FLAPJACK at a student
17:12:23 <Pseudonym> People get the impression that if you pay the money, you get the degree.
17:12:25 <madpickle> because he kept talking in class
17:12:37 <madpickle> now, you may ask why a CS lecturer brought flapjacks to class
17:12:47 <Pseudonym> I am of the opinion that if you don't want to pay attention in the class, just don't turn up.
17:12:48 <madpickle> he used it to explain algorithms that involved stuff like divide and conquer
17:12:59 <Pseudonym> Though I guess sleeping isn't so bad so long as you don't snore.
17:13:05 <madpickle> of course, he'd never pass the damn cake or anything like that around
17:13:12 <madpickle> so many of us thuoght about mugging him for the cake
17:13:26 <madpickle> overall my uni had a very informal relationship between lecturers and students
17:13:40 <madpickle> enough so that you didn't feel the formalities conflicted with your ability to be casual
17:13:45 * Pseudonym nods
17:13:46 <bringert> it's like that everywhere in sweden I think
17:13:50 <Pseudonym> I think that's important these days.
17:13:54 <madpickle> in our 3rd year we all went on a 3-day colloquium
17:13:56 <madpickle> and we all got drunk
17:14:00 <madpickle> lecturers and students alike
17:14:08 <madpickle> in a huge tudor mansion owned by the university
17:14:15 <madpickle> it was awesome
17:14:25 <madpickle> and a great way to get to know your lecturers in person
17:14:50 <madpickle> anyone else got any funny stories?
17:15:01 <Pseudonym> The guy who taught me functional programming brought homebrew to one gathering.
17:15:06 <madpickle> lmao
17:15:32 <madpickle> the lecturer who threw flapjacks took off his shoes in class
17:15:34 <madpickle> every time
17:15:36 <madpickle> no idea why
17:15:37 <madpickle> he always did
17:15:40 <madpickle> walked around barefoot
17:15:44 <Pseudonym> Oh, Lee Naish never wears shoes.
17:15:46 <madpickle> bit of a nutter
17:15:51 <madpickle> oh he does wear them
17:15:58 <madpickle> (it gets rainy and cold in wales)
17:16:01 <Pseudonym> Lee Naish is a logic programming demigod, BTW.
17:16:05 <madpickle> heheh
17:16:11 <madpickle> but anyway
17:16:15 <madpickle> he always brought a huge mug of coffee
17:16:21 <madpickle> except on St. Patrick's day
17:16:23 <madpickle> he brought Guinness
17:16:37 <madpickle> of course, most of us were, uh, drunk by the time it was 10 am
17:16:41 <madpickle> wanting the hat and all..
17:18:06 <Pseudonym> All logic programmers, incidentally, satisfy one or more of the following criteria:
17:18:11 <Pseudonym> 1. Vegetarian
17:18:13 <Pseudonym> 2. Juggler
17:18:16 <Pseudonym> 3. Bridge player
17:18:30 <madpickle> never asked mine about either of those
17:19:16 <madpickle> what uni did you go to, Pseudonym?
17:19:23 <Pseudonym> University of Melbourne
17:19:29 <madpickle> nice
17:19:33 <madpickle> aussie, eh?
17:19:36 <Pseudonym> Yup.
17:19:39 <Pseudonym> Bloody oath.
17:19:42 <madpickle> hahaha
17:19:52 <Pseudonym> The catch was that at Unimelb, everyone is a logic programmer.
17:19:59 <madpickle> your research area?
17:20:01 <Pseudonym> The one functional programmer took a sabbatical in the year that I did honours.
17:20:15 <Pseudonym> So I had to do logic programming.  Oh well.
17:20:21 <madpickle> i liked Prolog
17:20:23 <madpickle> it was fun
17:20:39 <Pseudonym> How many Prolog programmers does it take to change a light globe?
17:20:49 <madpickle> no clue.
17:21:16 <Pseudonym> fail.
17:21:16 <madpickle> well?
17:21:19 <madpickle> haha
17:21:22 <vincenz> ...
17:24:42 <Pseudonym> A nice little FP group has arisen at Unimelb since I left.
17:24:48 <Pseudonym> Shame for me. :-)
17:29:06 <Pseudonym> Grrr.
17:37:32 <carp> mowning
17:40:13 <s1> hi all
17:42:01 <sm> question: what would be some good darcs code for me to look at to learn good habits ? insightful, maintainable real-world code ?
17:42:14 <sm> sorry, I mean haskell code of course
17:42:30 <sm> and is darcs considered a good example ?
17:42:57 <ruffneck> if you find one..
17:43:07 <ruffneck> what is darcs ?
17:43:26 <sm> a revision control system, http://darcs.net
17:43:27 <lambdabot> Title: "darcs"
17:43:43 <ihope> Hmm...
17:43:57 <ihope> http://darcs.net http://darcs.net http://darcs.net
17:43:58 <lambdabot> Title: "darcs"
17:44:04 <ihope> :-)
17:45:19 <mauke> http://mauke.ath.cx/stuff/poly2.html
17:45:51 <ruffneck> that is a horrible page
17:46:06 <ruffneck> makes you flip
17:46:09 <mauke> yes, that's what it says
17:48:22 <sm> got to go.. I'll leave this open
18:02:08 <ruffneck> chessmaster
18:02:14 <ruffneck> like in the cube 3
18:03:02 <AtnNn> they made a cube 3?
18:03:48 <ihope> Oh my...
18:03:51 <ihope> A polyglot!
18:04:17 <ruffneck> AtnNn: you haven't seen it yet?
18:04:39 <AtnNn> i loved cube and disliked cube 2, never heard of cube 3
18:04:50 <ruffneck> it's called "cube zero
18:04:53 <ruffneck> actually
18:05:08 <ruffneck> well.. just like me, cube2 didn't quite work, just like in every trilogy
18:05:24 <ruffneck> it's just the repeat of the first as usual
18:05:34 <ruffneck> but the third of the trilogy as usual, is better
18:05:46 <ruffneck> well.. the original is a classic ofcourse
18:05:51 <AtnNn> yeah
18:05:58 * AtnNn adds it to his list of things to do
18:06:01 <ruffneck> you gotta watch it
18:06:04 <ruffneck> it's worth it
18:06:23 <ruffneck> tell me when you did it in irc?
18:06:24 <AtnNn> if I find some time. I'm learning two languages right now
18:06:31 <AtnNn> ok
18:06:33 <ruffneck> bilinguistics ;)
18:06:39 <AtnNn> haskell and russian :P
18:06:46 <ruffneck> I know only cunninglinguistics ;P
18:06:51 <ruffneck> russian, cool
18:07:02 <ruffneck> try to learn finnish ;)
18:07:07 <ruffneck> you could find it interesting ;)
18:07:23 <ruffneck> opettele suomea lk s hipinretaliini mussuta siel ;P
18:08:11 <AtnNn> If I meet more finnish people I might consider it :)
18:08:28 <ruffneck> have you met any?
18:08:31 <ruffneck> listen to this
18:08:32 <ruffneck> http://dojo.fi/~rancid/loituma__.swf
18:09:03 <AtnNn> to watch flash I have to start X, and the sound still wouldn't work if I did
18:09:04 <ruffneck> it actually has 1 finnish word in it... and all the other only sounds like it is
18:09:07 <ruffneck> ok
18:09:08 <ruffneck> no prob
18:09:14 <ruffneck> I give you mp3
18:09:15 <ruffneck> ;)
18:10:02 <ruffneck> or how about mov?
18:10:08 <AtnNn> mov is ok
18:10:08 <ruffneck> you have a mac? ;D
18:10:15 <ruffneck> http://www.tvfolk.net/video/loituma_256k.mov
18:10:16 <AtnNn> debian sid
18:10:23 <ruffneck> should be something, I'm not sure.. doesn't load
18:10:29 <urz> can i get mac os for a pentium II?
18:10:30 <ruffneck> no
18:10:33 <ruffneck> wrong!!
18:10:34 <ruffneck> don't listen
18:10:45 <ruffneck> well
18:11:29 <AtnNn> urz: dunno, but debian runs really well, even when you start X
18:11:53 <ruffneck> install X ;P
18:12:18 <ruffneck> what? you have some crappy linux or why don't you have X without any trouble? ;P
18:12:34 <ruffneck> or you have NetBSD ;D
18:14:00 <vincenz> Try to keep it somewhat on-topic?
18:14:20 <vincenz> There's #haskell-blah for generic stuff
18:14:36 <ruffneck> AtnNn: do you know systema?
18:16:11 <AtnNn> no
18:20:42 <ruffneck> vincet true, I was just about to say #haskell-blah
18:21:20 <urz> I have an exercise problem that asks me what catagories does a functor T act between if (a,T) is the initial type for a functor F: A <- (BxA).
18:21:51 <ruffneck> damn you speak weird.. I'm sorry.. I don't know haskell and I would like to learn but I've only read the basics
18:22:09 <ruffneck> "functor" ;)
18:22:12 <urz> it's a catagory theory problem
18:22:26 <dons> ?type fmap
18:22:27 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:22:34 <dons> ^^ Functor ;)
18:24:02 <ruffneck> catagory ;) is that explicit or typo? ;) 
18:24:10 <ruffneck> in the exact case or ?
18:24:48 <urz> category, it was neither a typo or explicit.  it was a spelling error
18:25:09 <ruffneck> ok :) It sounded funny ;) and google has lots of links =)
18:25:32 <ruffneck> I'm not english
18:28:11 <JKnecht> you mean it's not your native language?
18:29:55 <ruffneck> JKnecht: exactly
18:30:02 <ruffneck> and I'm not english ;)
18:30:35 <JKnecht> most native speakers aren't.
18:31:02 <ruffneck> true ;)
18:31:34 <ruffneck> never thought that... in my language they kind of mean the same
18:33:07 <urz> so ruffneck /= redneck 
18:33:18 <JKnecht> that being Finnish.
18:34:09 <JKnecht> ruffneck and redneck are unrelated idioms.
18:34:55 <JKnecht> i.e roughneck. ruffneck actually sounds sort of 16th century.
18:35:01 <ruffneck> =D =D are they? I've heard that ruffnecks worked in the oilfields in midwest ?
18:35:26 <ruffneck> there are music artists named ruffneck and rednecks and the later is lot worse ;P
18:35:48 <Pseudonym> Ruffnecks sound like the arch enemies of the roundheads.
18:37:15 <ruffneck> ok I've been revealed.. I'll continue to stfu myself on #haskell-blah ;P
18:38:20 <ruffneck> JKnecht: join the channel too... how does it sound 16th century? what kind of image or imaginary vision it emerges?
18:39:09 <urz> how do you send unicode codes to the uxterm terminal?
18:39:27 <urz> is there a control code sequence that will let you do it?
18:39:42 <urz> sort of like alt-numpad sometimes can be used to enter ascii codes?
18:44:38 <Cale> urz: I think uxterm does nothing special to process the input it gets from X, so it depends on your X server.
18:45:00 <urz> xfree86
18:45:30 <urz> hey Cale 
18:45:36 <Cale> I can type greek characters into it just fine, but that's because of the way my keymaps are set up
18:45:51 <Cale> and compose works
18:45:58 <urz> I have an exercise problem that asks me what catagories does a functor T act between if (a,T) is the initial type for a functor F: A <- (BxA).
18:46:06 <Cale> er, actually, no it doesn't
18:46:18 <ruffneck> what is the difficulty level+
18:46:34 <urz> I think T:A->B but the solution says the oposite
18:46:36 <Cale> "initial type"?
18:46:43 <urz> yeah
18:47:00 <urz> the intial algebra paired with the type functor 
18:48:08 <urz> it considers parameterized to have associated bifunctors where the first argument is fixed for purposes of determining Alg(F)
18:48:54 <ruffneck> bifurcation ?
18:48:59 <urz> listr A := nil | cons (A,listr A) defines a bifunctor F(A,B)=1+(AxB)
18:49:10 <Cale> ah, okay
18:49:50 <Cale> and (a,T) is the initial algebra?
18:51:37 <urz> no, (TA, alpha) where alpha: TA <- F(A,TA) and in my example T can be thought of as listr
18:51:59 <urz> hm
18:52:12 <urz> in your (a,T) which is the object and which is the function?
18:52:36 <Cale> I'm just asking about your notation
18:53:04 <Cale> oh,
18:53:11 <urz> this book actually defined the initial algebra not as a pair, but as a function
18:53:28 <Cale> a is the initial algebra, and T the type functor
18:53:36 <Cale> as a function?
18:54:41 <urz> yeah.  A morphism between a: T <- FT 
18:55:09 <Cale> mm
18:55:13 <Cale> what's T there?
18:55:35 <Cale> are those functors?
18:55:36 <urz> there T is an object in the catagory C where F: C <- C
18:55:51 <urz> but thats for a non paramaterized type
18:56:05 <urz> for a parameterized type, F is a bifunctor and T becomes a functor
18:56:14 <Cale> okay
18:56:29 <Cale> and a becomes a natural transformation?
18:56:49 <urz> yes
18:57:39 <urz> they have a kind of bracket for taking the catamorphism
18:58:38 <urz> so if i use <>, then <f> would be the unique F-homomorphism from a to f
18:58:47 <Cale> ah, okay, so they're sort of ignoring the fact that there is this associated object at all
18:58:54 <ruffneck> this is getting interesting... wtf catamorphish? I have problems to understand everything here :D
18:59:28 <urz> i dont see what object you mean that they are ignoring
18:59:56 <Cale> a: FT -> T, where T is actually fixed
19:00:14 <Cale> It's not a big deal
19:00:44 <urz> well "initial type" usually means T is a functor
19:00:52 <Cale> Where I had pairs, they're just taking the second part of the pair, which is okay, since the first part is fairly redundant anyway
19:01:04 <urz> oh right
19:01:12 <urz> for the definition of algebra
19:01:16 <Cale> right
19:01:27 <urz> ya
19:01:33 <urz> i notice wikipedia does it your way
19:01:39 <urz> your way maybe is more common
19:02:21 <urz> this book also likes to put its arrows facing the opposite of usual a: T <- FT instead of a: FT -> T
19:02:30 <Cale> yeah, I noticed that
19:02:51 <Cale> some people like to do that because it makes composition line up
19:03:00 <Cale> some other people swap the order of composition
19:03:38 <Cale> but most books I've seen just accept the fact that composition is reversed from the diagrams :)
19:05:12 <urz> so now they say F: A <- BxA
19:05:50 <urz> and ask me what is the categories that T acts between
19:06:41 <Cale> hmm, A and B are categories there?
19:07:07 <urz> must be
19:07:28 <Cale> okay
19:07:38 <urz> F is called a bifunctor
19:07:47 <urz> so i guess A and B must be categories
19:09:24 <Cale> FT has to make sense somehow, in particular, it ought to be a functor
19:10:07 <urz> well in the examples, we fixed the first argument to the bifunctor when convenient
19:10:48 <urz> so i guess FT = F(Y,T) for some fixed Y
19:11:13 <urz> so T sends to catagory A
19:11:27 <Cale> yeah
19:11:44 <Cale> well, T would be an object in category A
19:11:58 <urz> oh
19:12:09 <urz> F_Y T = F(Y,TY)
19:12:15 <urz> so now T sends to category A
19:12:20 <urz> and it takes from B
19:12:27 <urz> T: B->A
19:12:30 <Cale> that would work
19:13:02 <urz> that concurs with the solution
19:13:18 <urz> which is opposite of what I thought the first couple of times i thought about it
19:14:56 <urz> let me think on the second part a bit before i beg for help
19:16:31 <urz> They are asknig me to consider an example B = Fun x Fun and A = Fun where F((f,g),h)=f+g
19:17:05 <urz> This book uses Fun as the name of the category with sets as objects and functions as arrows
19:17:33 <urz> So now i see that T : Fun x Fun -> Fun
19:17:34 <orz> orz orz
19:17:57 <araujo> hello
19:18:03 <jesse> hello
19:18:41 <urz> i am asked to deterimin the initial type of that example
19:19:13 <urz> it sounds like a war outside
19:19:20 <urz> with all the damn fireworks
19:20:20 <urz> this is a constant functor if we fix the first argument
19:21:36 <urz> Cale: do you use greek letters in your variables?  Does ghc allow that?
19:23:46 <Cale> urz: GHC 6.5 allows it now
19:23:54 <Cale> but I don't currently have that installed
19:27:01 <urz> he didnt define + on arrows, but he uses it
19:27:29 <urz> he defined the notation [f,g] to be what i think he means by f+g here
19:28:32 <Cale> yeah
19:29:59 <urz> hm.  he defines a bifunctor + whose definition on arrows is f+g = [inl . f, inr . g]
19:30:12 <urz> I guess theres a distinction 
19:30:49 <ruffneck> fine distinction between unsane and the trancendential
19:31:53 <Cale> urz: hmm... there is? :)
19:32:01 <Cale> Oh, I suppose so
19:32:09 <urz> im still trying to see the types
19:32:14 <Cale> Depending on how the notation [f,g] is defined
19:32:43 <Cale> If f: A -> C and g: B -> C then [f,g] : A + B -> C ?
19:32:55 <urz> "Given f:C<-A and g:C<-B, the unique arrow C<-A+B is written [f,g],..."
19:33:32 <Cale> the unique arrow making the coproduct diagram commute, right.
19:34:27 <urz> so because [,] requires its arguments to both go to the same object in the category, the inl and inr are needed
19:34:42 <Cale> yeah
19:34:44 <urz> as converters to A+B 
19:34:58 <urz> from C and D or whatever f and g each map to
19:35:13 <urz> for f+g
19:35:23 <Cale> so yeah, f + g is almost the same thing, it's just that f: A -> C, g: B -> D, then f + g: A + B -> C + D
19:35:48 <urz> oh, C+D i should have said
19:39:12 <urz> if i know what a functor does to arrows, is that enough to determin what it does to objects?
19:40:04 <Cale> well, yeah, since you'll have to know what it does to identity arrows
19:41:56 <urz> what if i send all arrows to a certain arrow?
19:42:18 <foxy> Hi, is there a GTK2HS that works with GHC 6.4.2 on Win?
19:42:32 <urz> then identities arent sent to identities unless that arrow is an identity
19:42:45 <Cale> then that arrow must be the identity arrow for some object
19:43:01 <Cale> and all the objects are being sent to that object
19:43:25 <Cale> foxy: dcoutts would know, I think it ought to work
19:43:54 <foxy> Cale, When I tried the latest installer it said I needed 6.2.2 or 6.4.1
19:43:57 <urz> i'm given F((f,g),h) = f+g.  I consider the first argument fixed and I have F(h) = f+g for all h.  So f+g must be the identity arrow from some object
19:44:02 <dons> hey foxy
19:44:15 <Cale> foxy: oh, that's interesting -- what about the darcs version?
19:44:18 <foxy> dons, hiya -- got a new computer, back online!
19:44:28 <dons> cool!
19:44:45 <foxy> cale, Ah darcs version... do you know the address?
19:45:12 <dons> ?where gtk2hs
19:45:12 <lambdabot> http://haskell.org/gtk2hs/
19:45:20 <dons> it'll be mentioned there somewhere
19:45:31 <foxy> ?where darcs
19:45:31 <lambdabot> http://darcs.net/
19:45:55 <Cale> http://darcs.haskell.org/gtk2hs
19:45:58 <lambdabot> Title: "Index of /gtk2hs"
19:46:19 <dons> that's it
19:53:40 <foxy> dons, are you working on hIDE, and if so, does it compile on windows yet?
19:54:47 <dons> haven't been working on it for a while.
19:55:09 <dons> Lemmih's been designing the hIDE 2.0 system, to make it easier to maintain and develop
19:55:25 <foxy> how's Yi?
19:55:57 <dons> not too bad, actually. been getting a few patches from a guy in the uk, which is moving it along.
19:56:11 <dons> it does selected-region highlighting now
19:56:11 <foxy> does _it_ run on windows?
19:56:16 <dons> yep, i think so.
19:56:25 <dons> i'm sure i've had guys using it on windows.
19:56:25 <urz> what's Yi?
19:56:30 <dons> ?where yi
19:56:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
19:56:56 <dons> mostly , foxy, i've been hacking away on Data.ByteString/fps
19:57:07 <dons> at least the last few months
19:57:28 <foxy> heh, I saw your contribution to noOp ;P
19:57:37 <dons> hehe
19:59:21 <foxy> I was adding programmable brackets to ghc, I got the concrete syntax working but ran into trouble with the need to add a new variable type to the abstract syntax, it was either that or lose source code information, and then I upgraded to XP and lost computing facilities for 5 months
19:59:50 <dons> argh
20:00:23 <dons> I suggest: linux or *bsd   ;)
20:00:45 <dons> or was the "upgraded to XP" unconnected to "lost computing facilities " ?
20:00:56 <foxy> direct causal link
20:01:01 <dons> at least it wasn't  "upgraded to XP" and "lost mental faculties"
20:01:19 <dons> scary
20:02:12 <Cale> upgrading to XP is correlated with lost mental faculties
20:02:45 <urz> what did you upgrade from?
20:02:55 <foxy> 98
20:04:19 <urz> i have 98 wasting a few gigs on this laptop
20:04:37 <urz> i hardly ever boot it and i never got the wireless card working there
20:05:02 <urz> I dont have enough space to install xp
20:05:25 <urz> i said a few gigs, but its less than 1 gig 
20:05:35 <urz> and my linux partition is pretty full up
20:05:41 <foxy> dons, do you recall previously I was trying to load polymorphic functions at runtime using hs-plugins...  well I now think the solution is to use the GHC API to run typechecking at runtime, wouldn't that be a way to provide type Typeable for polymorphic functions?
20:09:14 <dons> foxy, yes, indeed it would. its on my todo list for the next 3 months 
20:09:38 <dons> i.e. a fully PoyTypeable that uses the actual Haskell type representation and a full typechecker
20:09:47 <dons> its the proposal at the end of the hs-plugins paper, in fact
20:09:54 <dons> PolyTypeable
20:09:57 <foxy> yeah! then we get dependent typing!
20:10:10 <dons> well, runtime values could depnd on types
20:10:19 <dons> and i suppose we could create runtime types that depend on values
20:10:41 <dons> so its a metaprogrammish dependent typing. hmm. hadn't thought of it that way before
20:11:42 <foxy> well, I'd be willing to help/hack at some point
20:12:13 <dons> yeah, Lemmih started a bit on ghc-plugins (an hs-plugins interface to ghc-api), I think
20:12:57 <kpreid> dons: I successfully ran lambdabot
20:13:00 <dons> which would be a good starting point
20:13:03 <dons> kpreid: cool!
20:13:10 <dons> ?karma+ kpreid
20:13:11 <lambdabot> kpreid's karma raised to 2.
20:13:13 <kpreid> it's running now, under the nick 'swhask'
20:13:20 <dons> how'd you go? any difficulties?
20:13:30 <dons> @seen swhask
20:13:30 <lambdabot> I haven't seen swhask.
20:13:43 * kpreid thinks
20:14:10 <dons> what does your @version say?
20:14:14 <dons> @version
20:14:14 <lambdabot> lambdabot 4p23, GHC 6.5 (OpenBSD i386 )
20:14:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:14:19 <kpreid> first: GHC 6.4 didn't work, because its Cabal is too old - I installed 6.4.2 and that was OK
20:14:24 <dons> (we have a page for interesting @version outputs)
20:14:24 <dons> right.
20:14:42 <kpreid> second: the 'Or with ghci' instructions don't work because it wants BotPP which isn't put in place by them
20:15:04 <kpreid> dons: /msg swhask !version
20:15:05 <dons> ah, yes, you need to first build and install the cabal way, then the ghci way will work
20:15:12 <kpreid> (that is, don't work till the first other-build
20:15:20 <dons> ooh, on the mac!
20:15:22 <kpreid> yes, well, the README implies they are independent :)
20:15:28 <dons> yeah, fixing...
20:15:39 <dons> !versoin
20:16:00 <kpreid> second thing: if I did 'main' from the ghci mode, then entered a command like '?id' it hung
20:16:04 <dons> you could add your @versoin to http://www.haskell.org/haskellwiki/Lambdabot#.40version
20:16:05 <lambdabot> Title: "Lambdabot - HaskellWiki"
20:16:10 <kpreid> (that is, including a prefix)
20:16:13 <dons> hmm
20:16:19 <dons> ah, yes, i know about this
20:16:23 <kpreid> now, a question:
20:17:47 <kpreid> I'm not an expert darcs user; what is good practice for sending patches back such that I don't mix up my deliberate local changes, and also can tell what I haven't sent? (I say 'send' generically, not 'darcs send')
20:18:15 <dons> you should just darcs whatsnew -s to see your changes
20:18:18 <dons> then darcs record only the things you want to send
20:18:23 <dons> i.e. darcs record Plugins/*
20:18:26 <kpreid> hm
20:18:38 <dons> its a problem at the moment that config.hs is under darcs control, yet everyone needs to edit it
20:19:07 <kpreid> it's not feasible to say 'push/send all patches but this one'?
20:19:20 <dons> yeah, you can do that too
20:19:30 <kpreid> but not recording is simpler for the moment
20:19:34 <dons> since it asks you what to send
20:19:39 <dons> you just have to be careful.
20:19:40 <kpreid> ah, yes
20:20:00 <dons> so you could record your Config.hs changes as "PRIVATE PATCH"
20:20:04 <dons> then make sure you never send it
20:20:07 <kpreid> also, I note that diffs of Modules.hs would be more useful if it had one module per line
20:20:21 <dons> yeah, we'd need to improve the lexer/parser in BotPP then
20:20:25 * kpreid nods
20:20:34 <dons> currently its very simple hander-built parser
20:20:39 <dons> grr.
20:20:43 <dons>  hand-built
20:21:07 <kpreid> now that I have built, I can change things and run sh ghci Main.hs without disturbing the running compiled lambdabot, right?
20:21:30 <dons> should be fine, yes, except if you quit it'll write to the State/ file, and when your other lambdabot quits, it'll overwrite
20:21:34 <dons> you probably don't care about that 
20:21:46 <dons> should be harmless
20:22:07 <petekaz> > sortBy (\(_ s) (_ s') -> compare s s') [(1,"pete"), (2,"bill"), (3,"alan")]
20:22:07 <lambdabot>  Parse error in pattern
20:22:15 <petekaz> What am I doing wrong?
20:22:25 <dons> is that supposed to be a tuple?
20:22:29 <petekaz> yes.
20:22:30 <dons> (_ s) isn't (_,s)
20:22:35 <petekaz> oh.
20:22:36 <petekaz> thanks.
20:22:52 <dons>  > sortBy (\(_ ,s) (_ ss') -> compare s s') [(1,"pete"), (2,"bill"), (3,"alan")]
20:22:55 <dons> my bad
20:23:03 <dons> > sortBy (\(_ ,s) (_,ss') -> compare s s') [(1,"pete"), (2,"bill"), (3,"alan")]
20:23:04 <lambdabot>  Not in scope: `s''
20:23:11 <dons> > sortBy (\(_ ,s) (_,s') -> compare s s') [(1,"pete"), (2,"bill"), (3,"alan")]
20:23:12 <lambdabot>  [(3,"alan"),(2,"bill"),(1,"pete")]
20:23:22 <dons> @pl (\(_ ,s) (_,s') -> compare s s')
20:23:22 <lambdabot> (`ap` snd) . (. fst) . const . compare . snd
20:23:25 <dons> oh well
20:23:32 <dons> @pl sortBy (\(_ ,s) (_,s') -> compare s s') [(1,"pete"), (2,"bill"), (3,"alan")]
20:23:33 <lambdabot> sortBy ((`ap` snd) . (. fst) . const . compare . snd) [(1, "pete"), (2, "bill"), (3, "alan")]
20:23:39 <petekaz> ap?
20:23:40 <dons> fun for all!
20:23:44 <petekaz> @hoogle ap
20:23:45 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
20:23:45 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
20:23:45 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
20:23:47 <dons> ?hoogle ap
20:23:47 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
20:23:47 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
20:23:47 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
20:24:08 * dons loses the hoogle quick-draw shootout
20:24:24 <petekaz> that pl version is ugly!
20:24:29 <dons> sure is
20:24:42 <dons> something with arrows might be nicer
20:28:19 <foxy> ooh, reboot time! <wave>
20:31:10 <kpreid> dons: do you like darcs send or public repositories?
20:31:40 <dons> ah, I like my repos to be public, and people to darcs send me their stuff
20:31:54 <dons> (since i can apply the patches directly from mutt, and reply to the author at the same time)
20:31:59 <dons> (as well as doing code reviews)
20:32:19 <dons> so, darcs send me the patches, if you can
20:32:39 <dons> for large numbers of patches, it becomes easier if the other person has a public remote that i can update from
20:32:49 <dons> but for the odd patch, mail is more convenient
20:33:02 <dons> s/remote/remote repo/
20:36:35 <kpreid> sent!
20:36:42 <araujo> hello around here
20:36:58 <u221e> Does haskell support concurrency?
20:37:12 <dons> of course, one of the best concurrent languages around
20:37:21 <dons> and smp too, if you'd like
20:37:34 <u221e> Great. I'm thinking about learning it.
20:37:37 <dons> @docs Control.Concurrent
20:37:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
20:37:44 <dons> ?shootout
20:37:44 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
20:37:52 <dons> check out the concurrency benchmarks
20:38:05 <dons> "chameneos"
20:38:11 <dons> is one of them
20:38:37 <u221e> I'm kind of concerned about these monad things though.
20:38:54 <dons> oh, they're pretty simple, they just have a scary name
20:39:02 <dons> you should think of them as warm fuzzy imperative programming
20:39:55 <dons> u221e: have youhad a look at haskell.org?
20:40:04 <u221e> But if you use one, wouldn't every other function that uses it also have to be imperative and ones that use that one have to me imparitive, etc?
20:40:06 <dons> there's lots of tutorials and starting info for people learning the language there.
20:40:15 <u221e> Yes, I'm looking at the tutorials there now.
20:40:30 <dons> ones that ues your imperative function have to be imperative also, but the imperative code can call pure, non-imperative code
20:40:50 <dons> so you write the io layer on the shell/outside of your program, and do pure computations on the inside
20:41:03 <u221e> Cool, video lectures.
20:41:34 <kpreid> also, you can write pure code that happens to be putting together an IO operation
20:41:38 <dons> separating side-effecting IO into its own type has great benefits as well. for example, lambdabot, our irc bot, can run arbitrary haskell code, simply by checking that the type isn't IO
20:41:43 <dons> > 1+ 2
20:41:44 <lambdabot>  3
20:41:46 <dons> > print "hello"
20:41:47 <lambdabot>  No IO allowed
20:41:54 <mauke> > unsafePerformIO
20:41:55 <lambdabot>  Not in scope: `unsafePerformIO'
20:41:57 <dons> that's a type-based proof that the code is safe to run
20:42:09 <kpreid> dons: of course, that error is sugar for "No instance for Show IO", right? :)
20:42:18 <dons> kpreid: right.
20:43:02 <dons> anyway, we get statically-checked sandboxing, effectively, with no runtime overhead
20:43:38 <dons> so, keep your side effects on the side, is the lesson here, i think
20:44:27 <dons> kpreid: no patch yet, did it get sent off your machine? do you have mail set up?
20:44:40 <dons> otherwise, you should 'darcs send -o /tmp/foo.patch' then mail me that file
20:44:54 <kpreid> dons: also, what is the significance of 'admins'? just they can make the bot join and so on, or they end up with access to the user running lambdabot?
20:45:01 <kpreid> dons: oops, I forgot that :)
20:45:24 <dons> no, they just get p'privledged' commands, not hacker commands ;)
20:45:31 <petekaz> Is there an "easy" way to go from this list: [(1,2), (2,2), (3,2), (4,1), (5,1)] to this list: [([1,2,3],2), ([4,5],1)]?
20:45:52 <u221e> I hear that ghc first compiles haskell code into C and has gcc compile that... I assume there is a command line switch to just dump out the intermediate C code. I'm kind of curious what it looks like.
20:46:41 <dons> yeah, -keep-tmp-files, and then look in /tmp for things named '*.hc'
20:46:59 <dons> if ((W_)Hp > (W_)HpLim) goto _c1wUt;
20:46:59 <dons> Hp[-2] = (W_)&GHCziForeignPtr_MallocPtr_con_info;
20:46:59 <dons> Hp[-1] = Sp[1];
20:46:59 <dons> *Hp = Sp[2];
20:47:07 <dons> Sp[-1] = Sp[3];
20:47:07 <dons> Sp[-2] = 0x0;
20:47:07 <dons> R1.p=Hp-2;
20:47:07 <dons> Sp=Sp-2;
20:47:07 <dons> JMP_((W_)&s17Kw_info);
20:47:09 <dons> :)
20:47:12 <dons> fwi
20:47:24 <dons> fwi???/ i'm on crack today.
20:48:02 <kpreid> @pl (\(a,_) (b,_) -> a == b)
20:48:03 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
20:48:15 <dons> the C is basically used as an assembler, u221e. so its not very C-ish
20:48:25 <dons> and its full of runtime system macros, like JMP_
20:48:39 <u221e> Heh, ok.
20:48:45 <u221e> Is anyone planning on entering ICFP this year?
20:48:48 <dons> ghc also has a spiffy native code generator
20:49:00 <Korollary> the #oasis people are planning
20:50:01 <dons> i'll be having a go, with my uni team and some guys in .de (hopefully we get 24 hour hacking that way)
20:50:19 <Korollary> dons: who in .de?
20:50:30 <u221e> What's the theme this year?
20:51:01 <dons> stefan wehr, author of the ML<->Type classes work. and matthias neubauer, too , i think.
20:51:18 <dons> also, dcoutts and Igloo will probably enter, since they won the whole tihng 2 years ago
20:51:39 <dons> I suspect WolfgangT might enter again, since he won it last year
20:53:12 <kpreid> dons: really sent
20:53:29 <dons> really received this time:)
20:54:25 <kpreid> a further refinement would be setting command prefixes per channel
20:54:36 <kpreid> if lambdabot already had that, I wouldn't be running my own copy!
20:54:54 <dons> oh, it clashes with something/
20:54:56 <dons> ?
20:54:57 <kpreid> (well, mostly)
20:55:03 <kpreid> dons: yes, supybot uses @
20:55:37 <dons> ok. good idea
20:55:39 <kpreid> (by which I mean the nick supybot on freenode, not necessarily the software in general)
20:55:46 * dons -> uni
20:56:02 <kpreid> next idea: make this work
20:56:12 <kpreid> @. pl Maybe a -> a -> a
20:56:12 <lambdabot> compose module failed: IRCRaised Parse error: "Maybe"
20:56:21 <kpreid> er
20:56:24 <kpreid> @. pl djinn Maybe a -> a -> a
20:56:25 <lambdabot> (line 3, column 13):
20:56:25 <lambdabot> unexpected ">" or "-"
20:56:25 <lambdabot> expecting variable, "(", operator or end of input
20:56:54 <mauke> @djinn Maybe a -> a -> a
20:56:54 <lambdabot> f a b =
20:56:54 <lambdabot>   case a of
20:56:54 <lambdabot>   Nothing -> b
20:56:54 <lambdabot>   Just c -> c
20:57:02 <mauke> oh, ok
20:57:28 <kpreid> @pl let f a b = case a of Nothing -> b; Just c -> c in f
20:57:28 <lambdabot> (line 1, column 31):
20:57:28 <lambdabot> unexpected ">"
20:57:28 <lambdabot> expecting variable, "(", operator, ";" or "in"
20:57:38 <kpreid> huh
20:57:49 <mauke> pl doesn't grok case
20:57:51 <kpreid> maybe that's more than I want to tackle
20:57:56 <u221e> Is there a haskell mode for emacs?
20:58:11 <kpreid> making it work with @type would be more reasonable
20:59:02 <mauke> @. djinn type head
20:59:03 <lambdabot> -- f cannot be realized.
20:59:35 <kpreid> @type head
20:59:36 <lambdabot> forall a. [a] -> a
20:59:55 <mauke> @. djinn type ($)
20:59:56 <lambdabot> f a = a
21:00:58 <mauke> @. pl . djinn type ($)
21:00:59 <lambdabot> f = id
21:01:06 <kpreid> @. djinn type either
21:01:07 <lambdabot> f a b c =
21:01:07 <lambdabot>   case c of
21:01:07 <lambdabot>   Left d -> a d
21:01:07 <lambdabot>   Right e -> b e
21:01:32 <kpreid> @pl f a = a
21:01:32 <lambdabot> f = id
21:01:42 <kpreid> huh, I didn't know @pl was happy with definitions
21:05:30 <mauke> @. pl . djinn type foldr
21:05:31 <lambdabot> f = const const
21:06:59 <Cale> heh
21:07:17 <Cale> djinn doesn't deal with recursive types
21:26:26 <bringert> does Malcom Wallace hang out here?
21:26:33 <kpreid> Is there a better way to write this?
21:26:36 <kpreid> List.unfoldr (\x -> case x of _:_ -> Maybe.listToMaybe (lex x); _ -> Nothing)
21:28:24 <Lemmih> kpreid: Is the case necessary?
21:28:45 <kpreid> Lemmih: yes
21:28:56 <kpreid> > List.unfoldr (Maybe.listToMaybe . lex); _ -> Nothing)
21:28:56 <lambdabot>  Parse error
21:29:04 <kpreid> > List.unfoldr (Maybe.listToMaybe . lex) "a"
21:29:05 <lambdabot>  ["a","","","","","","","","","","","","","","","","","","","","","","","",""...
21:29:09 <kpreid> > lex ""
21:29:10 <lambdabot>  [("","")]
21:29:43 <Lemmih> Ah, I thought you were using your own definition of 'lex'.
21:32:01 <Lemmih> What are you trying to do?
21:34:52 <kpreid> parse @djinn-env
21:37:02 <Lemmih> How about using a Haskell parser?
21:38:04 <Lemmih> Hm, it isn't really Haskell.
21:39:44 <kpreid> yep
21:39:50 <kpreid> 'data ()' and 'data Void'
21:44:13 <kpreid> @hoogle (a -> Bool) -> (a -> Bool) -> a -> Bool
21:44:14 <lambdabot> No matches, try a more general search
21:44:35 <kpreid> @hoogle (a -> b) -> (a -> b) -> (b -> b -> b) -> a -> b
21:44:36 <lambdabot> No matches, try a more general search
21:51:11 <|Steve|> > [1..]
21:51:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:55:47 <sieni> that's certainly a sign of a professional irc client that the default logout message is a stupid advertisement
22:03:20 <dons> bringert: yep, as "malcolm"
22:03:36 <bringert> dons: thanks
22:03:52 <bringert> I'm hacking on hscolour
22:04:18 <dons> oh, cool.
22:04:50 <bringert> I'm just making it into a library
22:05:11 <bringert> so that I can use it to highlight Haskell code in blog entries in Hope
22:05:26 <dons> hmm. yes, that would be useful
22:17:29 <jesse> could anyone help me install the package "collections"? I can't 
22:18:02 <jesse> get the makefile to work
22:19:29 <jesse> when I run make, it complains that there is no boilerplate or target... thanks
22:32:32 <danb> >1+1
22:32:36 <danb> ?1+1
22:32:36 <lambdabot> Unknown command, try @list
22:32:40 <danb> @1+1
22:32:41 <lambdabot> Unknown command, try @list
22:32:44 <danb> @list
22:32:44 <lambdabot> list [module|command]. Where modules is one of:
22:32:44 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
22:32:44 <lambdabot> topic type unlambda url version vixen where
22:32:56 <danb> @help
22:32:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:34:43 <danb> > 1 +1 
22:34:44 <lambdabot>  2
22:34:50 <danb> there we go
22:35:08 <jcreigh> >1+1
22:35:12 <jcreigh> > 1+1
22:35:14 <lambdabot>  2
22:35:16 <jcreigh> > 1 + 1
22:35:17 <lambdabot>  2
22:35:51 <jcreigh> Err...lots lag for me...but it looks like it needs the leading space...
22:36:54 <danb> jcreigh: agreed
23:02:20 <jesse> The package I'm having difficulty installing is <http://darcs.haskell.org/packages/collections/>. Is this the right place for me to seek help?
23:03:36 <Lemmih> It is. Just have to ask the right questions.
23:05:24 <Lemmih> jesse: The package looks Cabalized so this should do it: runhaskell Setup.hs configure && runhaskell Setup.hs build && sudo runhaskell Setup.hs install
23:13:52 <jesse> Thanks Lemmih! It seems to be working.
23:18:06 <tato> question: how does one write a binding to a C++ library?
23:18:46 <kzm> tato: wrap the interface with 'external "C"'?
23:19:02 <tato> is it that easy?
23:19:35 <kzm> Uh...well - it worked for me.  That was a library with a relatively simple, functional interface, though.
23:19:54 <kzm> You also need to link with libstdc++ (or at least I did).
23:20:29 <tato> is static linking possible? 
23:20:52 <kzm> Yes.  ghc -optl-static
23:21:12 <kzm> I use it all the time, since our Linux machines are rather heterogenous.
23:21:29 <mlh> tato: in general it's not enough.  depends on what's in the C++ library
23:21:31 <tato> and you can link in the C++ lib you wrote?
23:21:35 <kzm> Can't get it to work on Solaris, but it's an old installation, with a misconfigured gcc v.2.95.
23:21:58 <kzm> No thirty-day money-back guarantee, but it worked for me.
23:22:04 <tato> mlh: what about something like Qt
23:22:25 <tato> lots of overloading of functions...
23:22:55 <kzm> That might...complicate matters a bit.
23:23:29 <kzm> You're not on Windows?  I thought perhaps they had better integration for C++.
23:23:55 <tato> I'm on Linux/AIX
23:23:57 <mlh> tato: almost certainly will not work
23:24:38 <mlh> call it 'extern C' would only work in general if it IS C.  I.e. compilable with a C compiler. no classes, no namespaces...
23:24:53 <tato> mlh: :-/... I'm wondering how Perl and Python's Qt (and other C++ lib) binding work
23:25:07 <mlh> good question :-)
23:25:11 <tato> mlh: yea thats what i was guessing
23:28:33 <urz> use the mangled names
23:30:21 <mlh> looks like sip (swig derivative) helps.  or look at how boost.python do things
23:30:44 * mlh suspects I've veered too far off topic
23:32:28 * urz calls for mlh's excomunication
23:33:01 <mlh> no need, I'll repent
