00:00:01 <lispy> i've been very displeased with arrays thus far in my haskell travels
00:00:06 <Cale> really?
00:00:22 <lispy> yeah, lists or functions have pretty much always been faster
00:00:30 <lispy> oh, what if you used Data.Map instead of arrays?
00:00:42 <dons> IOUArray is ok
00:00:46 <dons> as are UArrays
00:00:49 <Cale> oh, there are places where arrays are much faster, but it depends on what you're doing
00:00:53 <dons> yeah
00:01:02 <dons> see the arrays we use in the shootout nsieve benchmark
00:01:05 <dons> we beat _all_
00:01:12 <int-e> dons: sandmark is indeed faster with um4.hs, here. funny. maybe it's too heavy on allocating and freeing arrays
00:01:32 <lispy> i used IOUArray to cache doubles computed by a sine function and it turned out to be faster to recompute the sine function than look up the values in the IOUArray
00:02:22 <dons> lispy, e.g. http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
00:02:23 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ...
00:02:31 <dons> in particular, use unsafeRead/Write
00:02:42 <lispy> lambdabot: nice entity parsing ;)
00:02:53 <lispy> why is it unsafe?
00:02:58 <dons> and check that the array is strict, so that it is unboxed to a raw Addr#
00:03:02 <dons> well, usually you have done the bounds checks yourself
00:03:08 <dons> so no need to have them checked on each read and write
00:03:18 <int-e> lispy: The sin function? that's not worth precomputing I think, even in C.
00:03:26 <dons> no one _relies_ on catching the bounds check exceptoin from a !
00:03:38 <int-e> it's a single opcode in an FPU.
00:03:42 <dons> so once the code is correct, you should use unsafeRead/Write, if its a simmple array type
00:04:12 <int-e> (x86 at least. I doubt other CPUs are much different there though, nowadays)
00:04:29 <lispy> int-e: fwiw, this was ppc but i get the point
00:06:31 <lispy> int-e: even computing sine my haskell version was quite a bit slower...but iirc the rest of the slow down was due to excessive garbage
00:06:39 <vincenz> dons: thank you
00:06:51 <dons> if you do a bunch of math, you can manually unbox it
00:06:57 <dons> then you get exactly the C code you need
00:07:03 <dons> i did this for a random gen once
00:07:19 <dons> vincenz: http://www.cse.unsw.edu.au/~dons/um.html
00:07:19 <lambdabot> Title: Haskell UM
00:07:25 <dons> vincenz: do you have a haskell UM?
00:07:32 <lispy> i think this pattern: loop arr m n c | arr `seq` m `seq` n `seq` c `seq` False = undefined, demonstrates a weakness in current haskell.
00:07:38 <vincenz> dons: no :/
00:07:48 <dons> yes, you would write: loop !arr !m !n !c = ...
00:07:52 <dons> using ghc 6.5
00:08:02 <lispy> dons: unbox it?  but isn't that what IOUArray is?  unboxed?
00:08:16 <dons> you want to unbox the IOUArray constructor too
00:08:16 <lispy> dons: ohh....shiny
00:08:24 <dons> then you get a MutableArray#
00:08:39 <lispy> how is that accomplished?
00:08:45 <dons> strictness :)
00:08:58 <lispy> i mean, do you have an example or tutorial?
00:09:15 <dons> hmm. yes, in the unboxed part of the ghc performance guide
00:09:18 <dons> there's a bit on doing this
00:09:31 <dons> its the trick that makes nsieve-bits run fast
00:09:38 <int-e> hmm. is the only clean way to get a global variable to use FFI?
00:09:44 <lispy> i see, i should go to bed...but i'll try to remember to check it out in the morning
00:09:56 <dons> int-e, an IORef or MVar?
00:10:01 <dons> + unsafePerformIO
00:10:12 <lispy> and no inlining
00:10:12 <dons> depends on what you mean by clean
00:10:18 <int-e> dons: I'm after the {-# NOINLINE #-} stuff and thread safety.
00:10:26 <dons> so try an MVar
00:10:50 <int-e> dons: I don't like the first and want the latter. And the problem is that more than one thread could allocate the global variable, the same is true for mvars
00:11:04 <dons> maybe don't use global variables then ;)
00:11:16 <int-e> fair point.
00:11:19 <lispy> oh, one more question...does strip remove debug symbols?
00:11:38 <lispy> wait
00:11:48 <lispy> nevermind, we don't have debuggers in haskell :)
00:12:15 * lispy goes to sleep before confusing himself further
00:12:45 <dons> he
00:12:48 <dons> hehe
00:14:23 <vincenz> dons: btw, our UM is 64bit compatible
00:14:31 <dons> yeah, i know
00:14:33 <dons> well done
00:14:54 <vincenz> no I mean, that's why it's slower!
00:15:20 <dons> ah, right.
00:15:21 <dons> :)
00:18:05 <vincenz> btw
00:18:15 <vincenz> I have .uma file
00:18:23 <vincenz> so you can send submissions as .umz
00:18:28 <vincenz> um icfp.umz > icfp.tgz
00:18:29 <vincenz> :)
00:18:55 <dons> :)
00:20:27 <vincenz> it's a bit unstable as you have to manually enter the size of your file in the .uma
00:20:28 <vincenz> so I'm thinking
00:20:35 <vincenz> um pack.um < file > file.um
00:20:41 <vincenz> and I can actually stream it
00:20:45 <vincenz> without first loading the entire file into memory
00:20:52 <vincenz> basically just add jump statements every 1024 packets
00:21:06 <vincenz> (cause the code has to come first, remember?)
00:22:33 <vincenz> dons: truth be told we have part of a haskell implementation
00:22:41 <vincenz> dons: just not a ccomplete one
00:24:41 <dons> yeah, that's what i thought
00:25:00 <dons> and i think duncan has a complete one, as well as their C um
00:26:11 <int-e> is there an unboxed equivalent for IORef (i.e. just a tag and a mutable value?)
00:26:20 <Itkovian> meuning
00:27:08 <dons> int-e, Addr# ?
00:27:34 <dons> int-e, Bulat's streams lib has something like that
00:29:32 <hellish> What is the system stack in the context : "A retainer is either the system stack, or an unevaluated closure (thunk)."?
00:29:53 <ProfTeggy> G'morning #Haskell
00:30:07 <int-e> dons: hmm, yes, that would be it. accumulating a result with modifyIORef is deadly :)
00:44:02 <MarcWeber> When doing darcs pull <repo>; remove accidently some files; How can I get the files back? Using something like darcs diff | patch?
00:44:22 <hellish> MarcWeber: darcs revert
00:46:52 <int-e> dons: sandmark allocates 91964702 arrays of total size 399348141. uncompressing the codex allocates 11 arrays, total size 7120258 :)
00:47:49 <dons> ah, right
00:48:01 <dons> darcs unpull, MarcWeber?
00:48:14 <dons> cp the repo first, in case you type the wrong thing
00:51:37 <mnislaih> I had this 'problem' yesterday MarcWeber
00:51:58 <mnislaih> if your patch is not available in another repository, then you have indeed lost it
00:52:08 <mnislaih> but if you go into the _darcs folder,
00:52:46 <mnislaih> inside the patches subfolder, you will find a gz'ed copy of the changeset of your patch
00:52:55 <mnislaih> one option is to manually reconstruct the changes in your code
00:53:04 <mnislaih> that's what I did to fix it
00:53:51 <mnislaih> I tried darcs apply too, but it was not a valid patch
00:54:13 <dons> who's the hacking going, mnislaih ?
00:54:23 <dons> how's :}
00:54:31 <mnislaih> you mean the ghci debugger dons ?
00:54:36 <dons> yep
00:54:58 <mnislaih> it's going well. I am trying to dig some stuff about how ghc typechecking works
00:55:07 <mnislaih> but dynamic breakpoints will be soon available
00:55:13 <mnislaih> and the closure viewer will be soon complete
00:55:14 <dons> great news!
00:55:17 <mnislaih> soon is the word ;)
00:55:31 <dons> i'd like to add a closure viewer to lambdabot's eval
00:55:36 <dons> so we could have more than
00:55:37 <dons> > putChar
00:55:38 <MarcWeber> hellish: did work
00:55:39 <lambdabot>  <Char -> IO ()>
00:56:15 <mnislaih> hmm, what do you intend to do with functions dons ?
00:56:29 <dons> what do you mean?
00:56:44 <mnislaih> the closure viewer was designed with Constrs in mind, I'm not sure what it can do to show functions
00:56:49 <dons> ah.
00:57:04 <dons> so how about let f x y = x + y in f 10 ?
00:57:18 <dons> or, g = f 10 in g?
00:57:29 <dons> that would be good , to print as a function, and show the bound variable
00:57:41 <dons> i..e <g { x = 10 }> or something
00:57:55 <dons> <g { x = 10 } :: Int -> Int> -- maybe
00:58:11 <dons> just playing with ideas. maybe this makes no sense
00:58:22 <mnislaih> oh sure, that makes sense
00:58:53 <dons> but the main thing would be to show polymorphic functions
00:58:55 <dons> > id
00:58:56 <lambdabot>  Add a type signature
00:59:01 <dons> > id :: () -> ()
00:59:02 <lambdabot>  <() -> ()>
00:59:23 <mnislaih> f - (_t560::forall a. a -> a)
00:59:30 <mnislaih> that's what it gives you in its current form
00:59:33 <dons> ah!
00:59:39 <dons> that's very good :)
01:00:05 <dons> yes, i could use that.
01:00:15 <mnislaih> if you are a client of ghc-api
01:00:20 <mnislaih> then you can directly get the type
01:00:27 <xahlee> a fuckface int-e banned me on #math
01:00:42 <xahlee> unjustly
01:00:42 <dons> xahlee: language!
01:00:55 <dons> this is a friendly channel, xahlee. so keep it civil
01:01:08 <xahlee> dons: did you hear what i said?
01:01:20 <xahlee> dons: or, are you willing to gang up on me?
01:01:28 <mnislaih> what would stop int-e from banning you from this channel too ?
01:02:05 <int-e> Oh a lot of things. But maybe insulting people here isn't the best strategy anyway.
01:02:09 <xahlee> if in a society, a cop murderd someone A, and this A complaint to a public place,
01:02:09 --- mode: ChanServ set +o dons
01:02:18 <xahlee> is the proper response to tell A to: please be civil?
01:02:31 <xahlee> i thought so.
01:02:35 <dons> we don't care about whether person X gets banned in channel Y
01:02:51 <dons> i don't know why people always come here to tell us they've been banned elsewhere
01:02:57 <Syzygy-> xahlee: Can you ever start out civil?
01:03:14 <Syzygy-> And what does your behaviour elsewhere have to do with haskell?
01:03:24 <xahlee> dons: listen: if you want to argue, then demote yourself. You can't fucking wear the badge in thread and pretenting to have a fair argument with me.
01:03:40 --- mode: dons set +b *!*n=xah@*.dsl.pltn13.pacbell.net
01:03:40 --- kick: xahlee was kicked by dons (dons)
01:04:00 <dons> i'm am so sick of him. he raises the temperature here _every time he shows up_
01:04:15 --- mode: ChanServ set -o dons
01:04:43 <dons> @tell shapr finally banned xahlee
01:04:44 <lambdabot> Consider it noted.
01:04:52 <mnislaih> so dons, I encourage you to go play with the patches
01:04:58 <mnislaih> and let me know any problems you may find
01:05:00 <dons> mnislaih: yes, i will
01:05:10 <dons> i do want to integrate lambdabot and ghc-api at some piont
01:05:16 <dons> it should give us a lot of useful things
01:09:52 <tessier__> xahlee is being considered for a permanent ban over in #lisp
01:10:00 <tessier__> He has been causing problems there for  months at least.
01:10:50 <dons> at best he is off topic, at worst he's agressive, and ranting
01:11:01 <dons> he has no interest in haskell, and doesn't care about our community
01:11:16 <tessier__> Look at the channels he is on. I wonder what his deal is.
01:11:18 <dons> there's been a strategy in place to deal with him, which came in to play
01:11:49 <tessier__> The strategy being to ban him?
01:12:01 <dons> yes, if he was again agressive and off topic
01:12:17 <dons> since he doesn't want to contribute to haskell in any form
01:12:28 <dons> we've just been a place he can come to complain
01:12:39 <dons> anyway. done. we can go back to being happy now :)
01:12:41 <dons> ?yow!
01:12:41 <lambdabot> Look DEEP into the OPENINGS!!  Do you see any ELVES or EDSELS ... or a
01:12:41 <lambdabot> HIGHBALL?? ...
01:13:00 * tessier__ sees a highball
01:14:59 <dons> It all comes down to our #1 principle: The #haskell channel is a friendly, welcoming place to hang out, teach and learn.
01:17:29 * araujo gives a cookie to dons 
01:17:58 <dons> :)
01:19:23 <araujo> dons, i support you to keep that ban forever too.
01:20:13 <int-e> > concat . intersperse "  " . map ("O-"++) $ zipWith (:) ">/<|>" (cycle ["-<","-="])
01:20:14 <lambdabot>  "O->-<  O-/-=  O-<-<  O-|-=  O->-<"
01:21:23 <int-e> oh. @donssnack :)
01:29:27 <dcoutts> @yarr!
01:29:28 <lambdabot> Get out of me way, yeh landlubber
01:29:31 <dcoutts> good call dons
01:30:10 <dcoutts> only lambdabot is allowed to be that rude in #haskell :-)
01:31:12 <edwardk_> ok, jit proof of concept seems to work, now i just need to finish all the opcodes, and then peephole optimize
01:31:26 <edwardk_> but, i need to get some sleep and go to work, etc.
01:31:53 <dcoutts> edwardk_, I translated your C UM into Haskell, but it's the memory allocation that's the tricky bit
01:32:10 <edwardk_> kinda figured it'd foul up there
01:32:14 <dcoutts> we can't use the same trick of using the pointer as the token
01:32:36 <edwardk_> can't even cheat with some sort of foreign.haskellfunctionpointer thing?
01:32:43 <dcoutts> as not only is it rather a low level unportable hack, but it doesn't work when the GC can move things about
01:32:47 <edwardk_> to make it stable, etc.
01:33:01 <dons> dcoutts: got a Haskell or C UM I can stick up here, http://www.cse.unsw.edu.au/~dons/um.html
01:33:02 <lambdabot> Title: Haskell UM
01:33:23 <dcoutts> yeah, one could use StablePtrs but I think they have performance overheads too
01:33:30 <edwardk_> i'll try to finish up the jit after work tomorrow
01:33:59 <edwardk_> mostly using it as a proof of concept of how abusable the plugin interface is for my javascript impl.
01:34:03 <dons> dcoutts: can we not use an Addr# ?
01:34:13 <dcoutts> dons, how to allocate one?
01:34:23 <dons> oh, you need to get the Ptr a somehow
01:34:37 <dons> and then take the Addr# inside, and use that like a ptr in the C version
01:34:47 <dcoutts> dons, could use Foreign.something I suppose
01:34:48 <dons> or grab an Addr# from a primop :/
01:34:57 <edwardk_> heh, well, we have one guarantee. the um itself manages the arrays, so you could allocate in c with a good ole malloc and free it when the corresponding call is made
01:34:58 <dcoutts> to get the Ptr
01:34:59 <dons> right. its an option
01:35:02 <dons> yep
01:35:04 <int-e> dons: btw I don't understand why sjanssen's UM is so much faster on your machine
01:35:11 <edwardk_> so you'd not have any haskell memmory management going on in the array
01:35:25 <edwardk_> no collection issues then
01:35:34 <dons> int-e hmm. i could try with different flags. maybe there was something magic kicking in
01:35:45 <edwardk_> if haskell doesn't allocate it, haskell doesn't own it =)
01:35:54 <dcoutts> I was using an IOArray Word32 (IOUArrays Word32 Word32)
01:36:08 <edwardk_> yeah same way sjannsen does it
01:36:19 <dons> dcoutts: do you have your C UM up somewhere?
01:36:25 <dons> and the haskell prototype?
01:36:46 <edwardk_> anyways, g'night folks
01:36:51 <dcoutts> dons, it's a C++ one, I was basing mine on edwardk_'s since his C one was so short & sweet
01:37:05 <dons> oh, i was wondering about benchmarking the one you used in the contest
01:37:17 <dcoutts> dons, sure, let me find it
01:37:35 <dcoutts> both of them only work on little endian
01:37:39 * dons noted with some dismay that his haskell um ran slower than um.um
01:37:45 <dons> though that's kind of cool in a way..
01:37:51 <dons> that we actually got away with it
01:38:00 <dcoutts> heh, I figure most of the overhead is in memory allocation
01:38:07 <dons> yeah
01:38:15 <dons> esp. since we had a StateT
01:38:27 <dons> oh, and a data type for the instructions
01:38:30 <dcoutts> ah
01:38:32 <dons> that' was overhead we didn't need
01:38:43 <edwardk_afk> how bad is stateT?
01:38:45 <int-e> getting rid of statet made my program 8 or 10 times faster.
01:38:56 <dons> oh, that's a good result
01:38:59 <edwardk_afk> ouch
01:39:01 <edwardk_afk> ok
01:39:06 <edwardk_afk> rethinking my jit design now =)
01:39:35 <int-e> well, StateT and the ADT for the machine state. I don't know which of these changes had the bigger impact.
01:39:56 <int-e> (the ADT was a flat struct)
01:41:26 <edwardk_afk> my jit right now consists of a simple api that provides a handful of functions through a type class
01:42:05 <edwardk_afk> so the 'world' state is encapsulated there, where it nows how to free, alloc, map a platter to an array, jit a function from a given address and load a new platter as the program
01:42:42 <edwardk_afk> er knows
01:42:57 <edwardk_afk> er and load a new array as the program
01:43:26 <edwardk_afk> internally i bundle most of that up as a state monad though
01:44:00 <edwardk_afk> newtype EvalState a = EvalState {
01:44:00 <edwardk_afk>         arrs :: PArraySet,
01:44:00 <edwardk_afk>         free :: [Int],
01:44:00 <edwardk_afk>         jits :: IntMap (JitF a)
01:44:00 <edwardk_afk> }
01:44:00 <edwardk_afk> type Eval a = StateT (EvalState (Eval a)) IO a
01:44:08 <edwardk_afk> ^-- will that be too slow?
01:44:30 <edwardk_afk> er ignore the last a there on the Eval line
01:44:51 <int-e> looks nasty
01:45:08 <edwardk_afk> it should read type Eval a r = State T (EvalState (Eval a)) IO r
01:45:23 <dons> looks pretty wild
01:45:38 <dons> will be interesting to see how that goes
01:45:42 <edwardk_afk> i need the recursive definition for the evaluator =/
01:45:46 <dcoutts> dons, any idea how the rts allocates StablePtrs ?
01:46:04 <edwardk_afk> coz otherwise the jitted functions can't get the jit to generate the next one, unless i exit out and call back in
01:46:09 <dcoutts> dons, it keeps an array of them I believe, and initially allocates them sequentially
01:46:15 <dcoutts> but does it fill in holes?
01:46:48 <edwardk_afk> dcoutts: there aren't many arrays allocated during the lifetime of a normal um program anyways
01:46:52 <dcoutts> how would it cope with SandMark allocating 9 million StablePtrs, with up to 50,000 at the same time.
01:47:03 <edwardk_afk> does sandmark abuse them?
01:47:09 <int-e> edwardk_afk: sandmark allocated 91 million
01:47:16 <dons> dcoutts: hmm. that sounds right. not sure about the holes though
01:47:23 <edwardk_afk> running it under my profiling version, hadn't tried sandmark
01:47:36 <edwardk_afk> oh yeah
01:47:38 <vincenz> int-e: sandmark did 91million allcocations???
01:47:39 <edwardk_afk> it does abuse them
01:47:43 <int-e> edwardk_afk: most of them small; the total allocate memory was 400 MB (not all simultaneously)
01:47:52 <int-e> vincenz: yep
01:47:55 <vincenz> holy cow
01:47:56 <edwardk_afk> 1636596 arrays loaded just getting to 99 from 100.
01:48:04 <edwardk_afk> so i believe it =)
01:48:24 <vincenz> Itkovian: hoy
01:48:29 <vincenz> Itkovian: how is it in l'aquila
01:48:34 <vincenz> Itkovian: any news on your coming to IMEC/
01:49:33 <edwardk_afk> ok. going to sleep for real now =)
01:50:05 <vincenz> @localtime edwark
01:50:08 <vincenz> damn
01:50:35 <int-e> mi.comcast.net ... michigan?
01:51:35 <dons> dcoutts: oh, your haskell one loadprog: array not copied (1)sim: Halt! [32,112,111,100,41,108,0,97]
01:51:47 <dons> maybe it doesn't like the sandmark
01:51:54 <dcoutts> dons, yeah, I noticed that. It ran everything else ok.
01:52:04 <vincenz> did anyone implement buffer-overflwo protection
01:52:05 <vincenz> ?
01:52:50 <dons> dcoutts: added your C++ impl http://www.cse.unsw.edu.au/~dons/um.html
01:52:50 <lambdabot> Title: Haskell UM
01:53:41 <vincenz> dcoutts: hmm
01:53:45 <vincenz> dcoutts: is it portable?
01:53:59 <dcoutts> vincenz, is what portabe?
01:54:07 <vincenz> your implementation
01:54:12 <dcoutts> which one
01:54:17 <vincenz> the c++ one
01:54:35 <dcoutts> it probably needs editing for a different endian arch
01:54:54 <vincenz> dcoutts: but for different bit?
01:55:03 <dcoutts> huh?
01:55:07 <vincenz> 64bit
01:55:11 <dcoutts> dunno
01:55:16 <dcoutts> try it
01:55:19 <vincenz> dons: I want to see the implemetation1
01:55:20 <int-e> weee. adventure eats a lot more memory with haskell than with C.
01:55:21 <vincenz> dcoutts: it's not online :/
01:55:31 <dons> if dcoutts puts it online somewhere.
01:55:35 * vincenz should probably finetune his allocator
01:56:28 <vincenz> heh
01:56:33 <vincenz> and to think I have a whole library for optimizing allocators
01:56:34 <vincenz> :P
01:56:57 <vincenz> tho I wouldn't be able to use it (IP and all that :/)
01:57:02 <dcoutts> I think it should work on 64bit, it's not casting pointers to ints.
01:57:03 <int-e> adventure also heavily allocates memory
01:57:14 <vincenz> dcoutts: cool :)
01:57:34 <int-e> run umix, start adventure, look around, go north, look around, quit, end umix: 5931552 allocations, 29227093 memory total.
01:57:53 <dcoutts> that's ML for you :-)
01:58:05 <vincenz> dcoutts: ML?
01:58:17 <dcoutts> the adventure was probably written in ML
01:58:20 <vincenz> oh no
01:58:24 <vincenz> I asked the organizer
01:58:26 <vincenz> it wasn't
01:58:58 * int-e notices that his memory figures are in words, not bytes.
02:01:04 <dons> vincenz: what was it written in?
02:01:09 <dons> if not SML?
02:01:26 <vincenz> dons: he couldn't share
02:01:30 <dons> oh..
02:01:35 <vincenz> dons: besides SML is typeinferred
02:01:36 <dons> so it will be a big surprise at icfp
02:01:42 <dons> vincenz: so?
02:01:44 <vincenz> dons: apparently they'll release in less than a month
02:01:56 <vincenz> dons: code required typing when adding onto rml
02:02:05 * vincenz made a new function
02:02:08 <vincenz> for recursive get
02:02:17 <vincenz> and it had to be explicitly typed
02:03:00 <dons> hmm. i don't understand. how could you know what language the um code was compiled from?
02:03:18 <vincenz> o.O
02:03:28 <dons> it could even be an x86 -> um cross-assembler
02:03:38 <vincenz> well it's not a backend to gcc
02:03:43 <vincenz> I asked that and got a negative answer
02:03:46 <dons> right
02:03:47 <vincenz> they said we'd be surprised
02:03:53 <vincenz> but x86 -> um makes no sense
02:04:00 <dons> but the obvious thing to do at cmu would be to add a backend to an sml compiler
02:04:05 <dons> or maybe a C-- to UM
02:04:07 <vincenz> cause the whole code-allocation issue is much more easily used when you have closure
02:04:17 <vincenz> dons: new-code segment allocation doesn't pop up in c--
02:04:21 <vincenz> and in fact it induces more work to do it that way
02:04:29 <vincenz> it'd be easier to jump within frame 0
02:04:40 <vincenz> hence I think, as dcoutts suggested, that it's a closure based language
02:04:56 <dons> ok. so we're back to SML of CMU then.
02:05:14 <int-e> don't they have a lisp, too? :)
02:05:35 <dcoutts> dons, I've got to go out shopping but I'll be in the lab within an hour or so, will you still be around to go over the BS benchmarks?
02:05:48 * dons -> out to see sonic youth
02:05:56 <dons> but i'll be reading email and online in around 4 hours
02:07:06 <vincenz> from a post
02:07:06 <vincenz> The end result
02:07:06 <vincenz> is a UM that can decompress the codex in 49 sec on a 1.0 GHz PowerBook
02:07:06 <vincenz> G4, and that runs sandmark in 4 MB of RAM.
02:07:09 <vincenz> WOW
02:10:24 <dcoutts> dons, ok
02:11:35 <vincenz> \o/ sandmark in less than 4MB
02:11:40 <vincenz> RAM
02:31:59 <Itkovian> vincenz: koen has not yet discussed anything, he's been extremely busy
02:32:20 * vincenz nods
02:32:22 <Itkovian> vincenz: I'd like to drop by perhaps in the week of august 14th, or so
02:32:33 <Itkovian> but not on monday
02:36:17 <vincenz> oy
02:36:22 <vincenz> I'll be gone then
02:36:39 <vincenz> 15-30 aug: me >>= sardegna
02:36:51 <vincenz> oh wait, you mention weeks by friday
02:36:54 <vincenz> sure that week should be fine
02:37:02 <vincenz> you mean the week of 9-15
02:38:39 <Itkovian> august?
02:38:42 <vincenz> yep
02:38:55 <Itkovian> the weeks are: 7 - 11 and 14 - 18 afaik
02:38:59 <vincenz> o.O
02:39:01 <vincenz> no they're not
02:39:08 <vincenz> whoops
02:39:10 * vincenz was looking at july
02:39:15 <Itkovian> uhu
02:39:20 * boegel hits vincenz 
02:39:32 <vincenz> hmm
02:39:41 <vincenz> then I guess 12-27 me >>= sardegna
02:39:52 <Itkovian> ok, so the 8th or 10th ?
02:39:56 <vincenz> sure
02:40:09 <vincenz> boegel: you coming too?
02:40:32 <boegel> vincenz: erm
02:40:32 <boegel> dunno
02:40:33 <boegel> I might
02:40:51 <boegel> can't come the 4th
02:40:55 <boegel> otherwise I'm free
02:41:04 <vincenz> > 4 `elem` [8,10]
02:41:05 <lambdabot>  False
02:41:06 <boegel> vincenz: you'll be presenting something, right?
02:41:15 <vincenz> boegel: yeah the profiling framework
02:41:17 <boegel> > eval show "f u"
02:41:18 <lambdabot>  Not in scope: `eval'
02:41:22 <vincenz> presenting is a big word, let's call it demonstrating
02:41:22 <boegel> arg :)
02:41:30 <boegel> vincenz: hmm, ok, interesting
02:41:34 <Itkovian> if one deletes a file, can one easily get it back from the darcs repos?
02:41:35 <boegel> I might join Itkovian, yeah
02:41:39 <vincenz> tho
02:41:41 <vincenz> if koen is coming
02:41:46 <vincenz> then perhaps a presentation would be in order
02:41:51 <vincenz> I don't think he's gonna be intersted in the technical side?
02:41:59 <Itkovian> i doubt it.
02:42:05 <vincenz> about interest or him coming?
02:42:11 <Itkovian> I'll talk to him this afternoon if I can track him down
02:42:19 <vincenz> alright
02:42:47 <xerox> Itkovian: darcs revert?
02:43:59 <vincenz> boegel: trouwens, volgend jaar ICFPC?  kunnen we een belgisch team doen :P_
02:44:28 <Itkovian> xerox: yes ... thx
02:44:37 <vincenz> Itkovian: idm
02:44:38 <vincenz> idem
02:44:40 <xerox> You're welcome :-)
02:45:14 <Itkovian> xerox: what if you want multiple files back and you don;t wish to undo other changes?
02:45:30 <vincenz> Itkovian: make a seconcd repo
02:45:31 <vincenz> revert
02:45:35 <vincenz> then copy the files over?
02:45:39 <Itkovian> pfft
02:45:40 <vincenz> tho your repo wil lgrow in size
02:45:40 <xerox> darcs revert file1 file2 file3 ... fileN ?
02:45:41 <Itkovian> that sucks
02:45:43 <vincenz> but!
02:45:51 <vincenz> you can revert speicifc changes without reverting others
02:45:58 <vincenz> xerox: ooh, neat :)
02:46:01 <Itkovian> in cvs I think you do a cvs up and it refetches the files
02:46:01 <xerox> (I always only used revert on single files.)
02:46:19 <boegel> vincenz: I'm not into FP atm, so I guess that'll be hard
02:46:34 <vincenz> boegel: it's not perse FP
02:46:37 <vincenz> its problem solving
02:46:47 * vincenz >>= lunch
02:46:57 * xerox =<< lunch
02:46:58 <boegel> vincenz: well, if we would join, it would be using Haskell, right? :)
02:47:08 <xerox> _I_ am the function eating lunch ;-)
02:47:12 <Itkovian> not ocaml in any case!
02:47:23 <Itkovian> xerox: don;t make us go hungry!
02:47:57 <xerox> In fact I just woke up.  Let's have some tea.
02:48:01 <boegel> too late
02:49:51 <Itkovian> yeah ...
02:50:00 <Itkovian> I hope lunch is not veal ...
02:50:05 <Itkovian> and not boiled vegetables, duh
02:50:05 <boegel> again...
02:50:12 <Itkovian> something sweet like pizza
02:50:13 <boegel> or cheese
02:50:18 <Itkovian> no cheese, please
02:50:27 <boegel> or French fries!
02:50:29 <Itkovian> wel, parmesanfor the antipasta is ok
02:50:35 <boegel> Veerle got eggs yesterday
02:50:43 <boegel> antipasta,
02:50:44 <boegel> ?
02:50:52 <xerox> Hmm, we'll have some kind of fish I presume.
02:51:07 * boegel would like fish
02:51:14 <boegel> because it's not veal or cheese :)
02:51:30 <Itkovian> no fries, the italians can't make those, I think
02:51:57 <int-e> @yhjulwwiefzojcbxybbruweejw
02:51:58 <lambdabot> Just 'J'
02:52:01 <boegel> they can try
02:52:09 <boegel> int-e: wtf? :)
02:52:20 <int-e> boegel: I just asked myself the same question
02:52:25 <boegel> int-e :)
02:52:32 <int-e> on #math:
02:52:34 <int-e> [11:51:03] <Olathe> @yhjulwwiefzojcbxybbruweejw
02:52:34 <int-e> [11:51:04] <mbot> Exception: <<loop>>
02:52:52 <boegel> so Haskell beats math?
02:53:33 <int-e> mbot is a lambdabot. people like mbot. it's good publicity ;)
02:53:57 <bolrod> @y
02:53:57 <lambdabot> Maybe you meant: yhjulwwiefzojcbxybbruweejw yow . v
02:54:01 <bolrod> ic
02:54:17 <bolrod> @yhjulwwiefzojcbxybbruweejw yow . v
02:54:17 <lambdabot> "\"#$%&'()*+,\""
02:54:20 <bolrod> 8)
02:54:24 <int-e> @help yhjulwwiefzojcbxybbruweejw
02:54:24 <lambdabot> V RETURNS!
02:54:31 <xerox> hahaha
02:54:48 <bolrod> @. elite help yhjulwwiefzojcbxybbruweejw
02:54:49 <lambdabot> v REtURN$!
02:56:29 <Itkovian> @yow
02:56:30 <lambdabot> All this time I've been VIEWING a RUSSIAN MIDGET SODOMIZE a HOUSECAT!
02:56:38 <Itkovian> poor thing
02:56:50 <bolrod> who?
02:56:53 <int-e> who, the bot, the midget or the cat?
02:56:58 <dmhouse> @botsnack
02:56:59 <Itkovian> the cat
02:56:59 <lambdabot> :)
02:58:09 <Itkovian> @seen BCoppens
02:58:10 <lambdabot> I saw BCoppens leaving #haskell-blah and #haskell 1 day, 9 hours, 30 minutes and 24 seconds ago, and .
02:58:11 <shapr> Good morning #haskell!
02:58:11 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:58:25 * Itkovian waves at shapr
02:58:29 <shapr> hoi Itkovian
02:58:42 <bolrod> 02:26:54 < BCoppens> <~ holiday, 2nd try, bye! :-)
02:58:50 <shapr> dons: The xahlee result is unsurprising. I was hoping he'd be a good citizen, but I wasn't expecting it.
02:59:15 <Itkovian> shapr:  I'd like to pick your mind a bit, so perhaps we can talk later, as I'm off to lunch soon. I hope.
02:59:27 <shapr> ok
02:59:33 <bolrod> lubch... hrmm
02:59:37 <bolrod> lunch*
02:59:50 <shapr> dons: Thanks :-)
02:59:57 <Itkovian> as soon as David Padua stops talking I'm off
03:00:13 <shapr> who?
03:00:27 <shapr> Anyway...
03:00:44 <shapr> xerox: Hey, is there a usable beta version of cabal-get? I'd very much like to use it for Hope.
03:01:12 <shapr> I'm sort of bored with LtU.
03:01:37 <xerox> shapr: the simple version of cabal-install works, I am working on cabal-put now.
03:01:39 <shapr> Can anyone suggest something like it that has more about proofs, types, etc?
03:01:55 <shapr> xerox: Oh boy! Will the simple cabal-get install all the hope packages for me?
03:02:00 * dmhouse is happy people are using @tell. :)
03:02:22 <xerox> shapr: those packages have to be `put` before being able to be `get`
03:02:36 <shapr> Ah ok
03:02:41 <shapr> When do you think that'll work?
03:02:42 * shapr bounces
03:02:47 <xerox> But the good news is that cabal-put needs only simple fixes, it'll be ready for today, I believe
03:03:00 <shapr> xerox: I *really* want to Hope to become popular, and cabal-get is totally necessary there.
03:03:03 <shapr> xerox: Thanks!
03:03:07 * shapr boings furiously!
03:03:08 * xerox too!
03:03:18 <shapr> @karma+ xerox -- for making cabal-get work
03:03:18 <lambdabot> xerox's karma raised to 19.
03:03:25 <xerox> My duty!
03:03:32 * dmhouse reaches for the sedatives
03:04:19 <shapr> hej psi
03:06:57 <dmhouse> Is it wrong that I find Lisp pretty?
03:07:34 <wolverian> no. get your head checked if you find it practical, though.
03:07:49 <dmhouse> Not the way it does things, just the syntax.
03:07:53 <dmhouse> I like the simplicity.
03:08:03 <shapr> The syntax is easy to transform.
03:08:19 <wolverian> it's the same kind of elegance that XML has.
03:08:21 <shapr> Has anyone tried the emacs-obby integration named ebby?
03:08:28 <dmhouse> Obby?
03:08:47 <shapr> dmhouse: apt-cache show gobby libobby
03:08:56 <wolverian> shapr, lumi was talking about that on #perl6. I think he's hacking it to support obby0.4
03:09:05 * shapr decides to try it
03:09:12 <shapr> wolverian: Do you know where his codebase lives?
03:09:36 <wolverian> sorry, no
03:11:39 <shapr> I want to try pair programming with #haskell people, and I don't want to leave the comfort of my emacs customizations.
03:12:55 <shapr> Ya know, I'd like to switch to XMPP one day.
03:13:08 <shapr> I bet we could get collab editing working over XMPP.
03:13:14 <dmhouse> shapr: I'm mildly surprised Emacs doesn't have networked collaboration built-in.
03:13:29 <shapr> Well it does... sort of.
03:13:42 <shapr> And in fact, Luke Gorrie's shbuf probably works anyway.
03:13:58 <shapr> I don't think I ever got it working though.
03:15:48 <xerox> shapr: the code is linked from that emacswikipage sin't it?
03:16:06 <shapr> Yeah, but you need either a erlang server or a gnumacs server.
03:17:36 <xerox> I thought it only needed an open gobby instance
03:17:53 <shapr> Oh that one.
03:18:00 * shapr tries it.
03:20:12 <shapr> Sadly, gobby won't run as a server in consolemode.
03:21:17 <xerox> That's a minor problem, though. Collaborative-Emacs-editing is worth it in my opinion :-)
03:21:47 <xerox> Hmmm, maybe you can just subscribe to buffers already open in Gobby, though
03:22:02 <xerox> I.e. you can't add new ones from Emacs
03:23:43 <shapr> shbuf might be friendlier.
03:24:08 <xerox> Where is it?
03:26:32 <shapr> On collabemacs page.
03:28:17 <wolverian> shapr, sobby is a standalone obby server, would that help?
03:29:29 <shapr> yes!
03:29:38 <shapr> Still won't let us create new buffers though.
03:32:13 <xerox> dmhouse: want to give it a try and add buffer creatin to ebby? (-:
03:32:22 <xerox> ...creation, even.
03:33:02 <dmhouse> xerox: maybe, let me check it out first
03:33:09 <dmhouse> xerox, shapr: got a URL?
03:33:38 <xerox> http://dev.technomancy.us/phil/wiki/ebby
03:33:40 <lambdabot> Title: ebby - Technomancy - Trac
03:34:55 <dmhouse> So who's got the obby server?
03:38:09 <dmhouse> xerox: What is it that you want to add?
03:40:28 <xerox> dmhouse: ebby-subscribe can attach Emacs to opened bufferes on the obby server, but one can't open new ones directly on Emacs
03:40:50 <dmhouse> xerox, have you got an obby server I can check this out with?
03:40:51 <psi> shapr, hej :)
03:41:43 <xerox> dmhouse: I am building obby and its dependencies now
03:42:33 <dmhouse> xerox: which version? I gather 0.4 is the latest, but apt only seems to have 0.3.
03:43:01 <xerox> Right, I also have 0.3.1 mhhh
03:43:11 <dmhouse> Oh, perhaps not. 0.4 is only in RC stage.
03:43:19 <xerox> Maybe I'd better compile it by hand
03:43:28 <dmhouse> I'll use 0.3.0, that should be good enough.
03:51:10 <dmhouse> xerox: now what, do I connect to the localhost?
03:51:24 <dmhouse> xerox: or are you setting up a server? Or what?
03:52:44 <xerox> Still bulding :(
03:53:18 <xerox> Oh well  port want to build perl, I think you'd better try locally :)
03:53:23 <dcoutts> @tell ndm keep up the good work on System.FilePath
03:53:24 <lambdabot> Consider it noted.
03:53:53 <dmhouse> @tell ndm +1 on what dcoutts just said
03:53:54 <lambdabot> Consider it noted.
03:53:59 <pejo> Is there anyone else than dons who runs ghc on OpenBSD here?
03:54:26 * dmhouse tries to remember whether he wrote that as a FIFO or LIFO, whether the messages will come out in the right order or not... :)
03:54:53 <dcoutts> pejo, noone else is that crazy :-)
03:55:36 <pejo> dcoutts, heh, boggle. Any Solaris users then? :-)
03:55:45 <dcoutts> pejo, actualyl yes
03:56:00 <pejo> dcoutts, you?
03:56:06 <dcoutts> I use ghc on sparc solaris & sparc linux
03:56:37 <dcoutts> version 6.4.1 on solaris as 6.4.2 has threading issues
03:56:39 <pejo> dcoutts, does your compile fail in rts/posix/OSMem.c because it can't find stdint.h?
03:57:15 <pejo> dcoutts, yeah, my original intention is to see if I can dig something up with that, but I got led astray due to the building trouble. :-)
03:58:05 <mlh_> prob doesn't need stdint.h if it's not there.  just #ifdef it out
03:58:27 <mlh_> else what it needs it for is in values.h or types.h
03:58:37 <dcoutts> pejo, yes a quick check indicates that my solaris gcc can't #include <stdint.h>
03:59:01 <mlh_> coz solaris doesn't include it.  sol9 anyway.  sol10 has it
03:59:07 <pejo> mlh, there is an ifdef there for openbsd_HOST_OS or something similar. I'm pondering whether it shouldn't be checking HAS_STDINT_H instead.
03:59:14 * dcoutts has access to sol9 not 10
03:59:44 <mlh_> pejo: possibly.  but you might find it doesn't need it at all
04:00:07 <pejo> And also the build system doesn't seemt o have picked up that to link libHSbase.a it needs -lm as well. But not sure where to patch that.
04:00:11 <mlh_> you could try installing the free solaris C compiler. studio11
04:00:34 <dmhouse> xerox: I've gotta dash, I'll check this out later.
04:01:02 <pejo> mlh, it needs uintptr_t or something like that, so some header is used. I picked it up from inttypes.h instead, where it seems to be defined.
04:01:32 <mlh_> ok, I knew it was somewhere (else as well)
04:15:18 <dcoutts> pejo, see the libaries/base/package.conf
04:15:38 <dcoutts> you can add 'm' there
04:18:26 * joelr1 waves
04:18:38 <joelr1> @seen JaffaCake
04:18:39 <lambdabot> I saw JaffaCake leaving #haskell 5 days, 19 hours, 46 minutes and 18 seconds ago, and .
04:25:14 <dcoutts> @seen JaffaCak1
04:25:14 <lambdabot> I saw JaffaCak1 leaving #haskell 19 hours, 12 minutes and 50 seconds ago, and .
04:26:37 <pejo> dcoutts, thanks. I take it back though, apparently there is no cosf in libm. Doh.
04:28:28 <dcoutts> pejo, are you sure? nm /lib/libm.so | grep cosf
04:28:36 <dcoutts> that shows it's there for me
04:29:46 <pejo> Hm. You're right. I should think before I speak.
04:35:30 <gour> dcoutts: hi, how was on the contest? (i'm on a dialup in rijeka - city on the coast, across the island Cres where you were last summer)
04:35:57 <dcoutts> gour, it went ok, we might get into the top 10
04:36:22 <dcoutts> gour, yes I remember Rijeka :-)
04:36:28 <gour> dcoutts: who (language) is at the top?
04:36:37 <dcoutts> it's not clear
04:36:41 <dcoutts> possibly Java
04:36:52 <gour> really?
04:37:39 <gour> then i'm better thinking about taking bath 'cause thinking about java being the winner is not so pleasant :-)
04:38:03 <gour> dcoutts: what about your holidays?
04:38:18 <dcoutts> Sweden this year :-)
04:38:32 <gour> dcoutts: quite a change ;)
04:39:07 <dcoutts> gour, actually this year the language was less important as it was a series of tasks, some of which one could solve by hand
04:39:23 <dcoutts> and I expect people used different languages for different tasks
04:39:25 <mikael> I'm amazed anyone has the attention span to implement that boring trivial virtual machine
04:39:37 <dcoutts> mikael, it's less than 100 lines of code
04:40:16 <mikael> but you have no idea if it has to be fast, or extensible, or debuggable, or whatever
04:40:31 <gour> dcoutts: so how will judges put together 1st prize then?
04:40:56 <dcoutts> gour, teams were asked to say which their major and other languages were
04:41:09 <mikael> after the third or so opcode, I thought "nevermind, I'll just wait for the blog posts about it"
04:41:21 <dcoutts> mikael, true, but you quickly find out once you run the program
04:41:35 <dcoutts> once you run the codec I mean
04:41:38 <gour> dcoutts: ahh, but that's not in tune with "the programming language of choice for discriminating hackers" slogan
04:41:47 <dcoutts> gour, true
04:42:09 <gour> dcoutts: what's new with gtk2hs?
04:42:14 <mikael> I hope the judges' prize is for someone who built a physical universal machine with FPGAs and LEDs or something
04:42:26 <dcoutts> gour, not a lot, we need to do a new release
04:42:46 <dcoutts> because there's lots in the dev version compared to the last release
04:43:56 <gour> dcoutts: my jyotish teacher told me to ask a question whether haskell is a good langauge for our project, but the answer was not so good...stil i hope it's more with the general obstacles, and not so about the language itself
04:44:36 <gour> dcoutts: so, if haskell, survives, i'll have to get into gtk2hs sometime soon..
04:45:08 <dcoutts> gour, so why is it not so good for your project?
04:45:32 <gour> dcoutts: i don't want to go into c++, and believe it's better than scripting langs like python, ruby...
04:45:53 <gour> dcoutts: it appeared there will be waste to time/resources
04:46:36 <gour> dcoutts: and i have to ask some more specific questions to get more details...
04:46:46 <dcoutts> right'o
04:47:57 <gour> dcoutts: what is your suggestion for plugin system in haskell? hs-plugins or Lemmih's hacks?
04:48:39 <dcoutts> gour, depends on your needs, hs-plugins is probably a good place to start
04:48:51 <dcoutts> but you should think if you really need a plugins system
04:49:26 <gour> dcoutts: well, i'd like to be able to have plugin system (in haskell), like in e.g. Gimp
04:50:02 <gour> dcoutts: the other option is to just use gconf and re-load the program or something else?
04:50:32 <dcoutts> it depends on exactly what your program is supposed to do
04:50:39 <gour> dcoutts: the program is supposed to have different 'modes'
04:51:11 <shapr> samason: Hey, do you think any of your hsmail code would be useful in http://darcs.haskell.org/SoC/haskellnet/ ?
04:51:12 <lambdabot> Title: Index of /SoC/haskellnet
04:51:24 <gour> e.g beginner 'mode' would require one set of functions, pro mode another, research mode another etc.
04:51:57 <gour> dcoutts: and those functions can be realized via different plugins 'cause they are not all needed at once
04:52:13 <dcoutts> gour, but there's no harm in them all being loaded at once
04:52:15 <shapr> mikael: Hey, want to write an article for TMR?
04:52:27 <dcoutts> gour, just expose a subset of the features depending on the mode
04:53:14 <gour> dcoutts: that's also possible, although some functions (e.g. plugin) should maybe be as close-source
04:53:41 <dcoutts> gour, that's not a problem, your whole thing can be closed
04:53:42 <gour> dcoutts: and main 'engine' will be realized via different 'core-libs'
04:55:04 <gour> dcoutts: we want to have some parts open, especially if someone can provide some additional functions, e.g. we are going to use south-indian format for displaying charts, but someone may prefer (and write plugin) for north-indian ones, or western
04:55:36 <gour> dcoutts: but let's succeed in use haskell first :-)
04:55:45 <dcoutts> aye
04:56:19 <gour> dcoutts: i've to go. i'm back by the end of the week or beginning of next week
04:56:25 <dcoutts> right'o
04:56:28 <dcoutts> see you later
04:56:34 <gour> dcoutts: greet shapr in sweden
04:56:50 <dcoutts> I'll greet him in Cambridge next week :-)
04:57:11 <gour> ohh. anglohaskellers. great!
04:57:31 <gour> all the best to the group...
04:57:41 <shapr> Yow!
04:57:59 <gour> shapr: take care in cambridge. bok, bok
04:58:27 <shapr> bok bok!
04:58:38 <gour> :-)
04:58:56 <shapr> Anyone here using gnumacs and want to try shbuf for collaborative programming?
04:59:07 <shapr> I have to restart xemacs to try it ...
05:00:07 <dcoutts> shapr, xerox and I had good fun with gobby for collaborative programming last year
05:00:51 * xerox nods
05:01:17 <shapr> I want to stay inside my comfy emacs customizations though.
05:02:36 <nattfodd> shapr: you are in Sweden?
05:02:59 <samason> shapr: I'd forgotton about the hsmail stuff.  it's not very good and the reason I came here was I was wanting to do the imap server stuff properly with a happy parser
05:03:11 <xerox> shapr: shbuf 1.2 ?
05:03:28 <shapr> xerox: yup
05:03:34 <shapr> nattfodd: At the moment, yes.
05:03:44 <shapr> samason: HaskellNet has an IMAP lib, want to hack on that?
05:04:07 <samason> shapr: I'll have a look at it
05:04:38 <samason> it's an imap client?  I wanted to do a server. . .
05:04:42 <shapr> oh!
05:04:48 <xerox> shapr: how do I setup it? I have gnu (carbon) Emacs.
05:05:03 <shapr> xerox: Load shbuf.el then shbuf-connect to kakapo.scannedinavian.com
05:06:02 <nattfodd> shapr: where exactly, if I may ask?
05:06:09 <shapr> Stockholm, where are you?
05:06:11 <musasabi> Is there a nice combinator for: liftMJust :: (Monad m) => (a -> m b) -> Maybe a -> m (Maybe b); liftMJust f = maybe (return Nothing) f ?
05:06:39 <shapr> nattfodd: Actually, if you look at my blog, you can find out exactly which part of stockholm. I moved here ... three days ago?
05:07:30 <xerox> shapr: ``Master is: "nobody"''
05:07:39 <shapr> xerox: Hey, at least we know it works.
05:07:52 <xerox> shapr: oh. Buffer is read-only.
05:07:57 <shapr> hmm
05:08:21 <musasabi> (grah, even that is missing the Just)
05:09:03 <shapr> xerox: Seems that you can become the master somehow.
05:09:20 <xerox> M-x shbuf-takeover
05:09:26 <shapr> Ok, does it work?
05:09:27 <xerox> I just did it and wrote something.
05:09:47 <shapr> Spiffy!
05:09:52 <xerox> Can you see it?
05:09:57 <shapr> No, I can't connect yet.
05:10:20 <shapr> I have to figure out how to make shbuf work with xemacs.
05:10:27 <shapr> xerox: Can you set the buffer to haskell-mode and write code?
05:11:16 <xerox> Seems so, but the `Fundamental Shbuf[YOU!]' went away.
05:11:30 <shapr> oh, hm.
05:11:35 <xerox> Hmm "Not Connected!" says now.
05:11:38 <shapr> oops
05:11:47 <xerox> No I can't change mode easily
05:11:57 <shapr> I see what you're typing in the erlang server :-)
05:11:58 <xerox> But it seems it worked
05:12:09 <xerox> Yes, I re-did a connect and I see what I left before :D
05:13:08 <xerox> Hrmpf.
05:13:15 <shapr> I'll ask Luke.
05:14:23 <xerox> Okay!
05:16:47 <roconnor> >splitat 8 [0..12]
05:16:53 <roconnor> >splitAt 8 [0..12]
05:18:24 <shapr> > 1
05:18:26 <lambdabot>  1
05:18:29 <shapr> roconnor: space?
05:19:51 <xerox> shapr: did you see audrey's slides?
05:22:23 <shapr> xerox: no?
05:22:31 <xerox> You should :-) <http://pugs.blogs.com/oscon-rhox-draft.pdf>
05:22:35 <shapr> Ok, I'll look.
05:24:46 <ricky_clarkson> [OT, about functional programming] To emulate tail recursion in an environment that doesn't optimise it (Java), say for factorial, I think I would make it return either the number or a function (anonymous inner class instance) that the caller can call to get at either the number or yet another function that the caller can call.  Does that sound right?
05:25:00 <shapr> Sounds right to me.
05:25:03 <ricky_clarkson> To emulate the optimisation to iteration, I mean.
05:25:30 <ricky_clarkson> Thanks Shae.
05:28:12 <shapr> ricky_clarkson: http://c2.com/cgi-bin/wiki?BlocksInJava
05:28:14 <lambdabot> Title: Blocks In Java
05:28:58 <shapr> ricky_clarkson: Have I seen you on ##java?
05:31:24 <ricky_clarkson> I'm an op there.
05:31:30 <shapr> ricky_clarkson: seen http://functionalj.sourceforge.net/ ?
05:31:32 <lambdabot> Title: FunctionalJ
05:31:38 <ricky_clarkson> Nope.
05:31:39 <shapr> ricky_clarkson: Yeah, I remember when you joined ##java years ago.
05:32:49 <ricky_clarkson> I haven't read BlocksInJava before, but so far it seems to describe what I already do fairly well. ;)
05:33:14 <ricky_clarkson> Except I use real-world terms, because I'm big and tough and don't understand the mathematical ones.
05:33:28 <shapr> The mathematical terms are nice because they have exact definitions.
05:33:38 <shapr> Plus I'd argue the math is very real world :-)
05:33:40 * xerox nods
05:33:56 <xerox> Oh well, not sure about the latter one
05:34:30 <ricky_clarkson> That could do with being updated for generics, it would make some of it more readable (and some worse).
05:35:00 <JaffaCake> shapr: there's probably several bits of Klingon
05:35:30 <shapr> Hiya JaffaCake, got a minute to talk about the stub bug?
05:35:36 <JaffaCake> Hans Wolfgang Lloidl had a habit of writing comments in Klingon
05:35:39 <shapr> I only found one so far.
05:35:44 <shapr> ChilliX said it was probably him.
05:35:59 <JaffaCake> I delete them when I find them :)
05:36:02 <dcoutts> heh
05:36:02 <shapr> heh, really?
05:36:07 <shapr> I was thoroughly amused.
05:36:14 <dcoutts> can anyone translate?
05:36:15 <shapr> Especially when I spent ten minutes translating it.
05:36:19 <JaffaCake> wouldn't hurt to leave one or two I suppose
05:36:33 <JaffaCake> would be better to put the translation in, I guess
05:36:46 <shapr> The equivalent english is above the Klingon I found.
05:36:47 <xerox> Look out for commits dcoutts ;-)
05:37:08 <JaffaCake> sure, you have until I finish my sandwich to talk about the stub bug :)
05:37:19 <shapr> Anyway, do you think it's possible that #706 isn't really a bug? Could it be that the one-shot mode is working normally but the users don't know?
05:37:24 * shapr writes quickly!
05:37:46 <shapr> I got lost a few times, I haven't found out where GHCi linking happens.
05:38:16 <JaffaCake> no, I'm pretty sure it's a bug, but admittedly I haven't tried to repro it
05:38:18 <shapr> Finder.findObjectLinkable explicitly and automatically picks up a matching (++ "_stub.o") if it exists
05:38:32 <shapr> That's the only code I've found that does so.
05:38:50 <shapr> Admittedly, I haven't found everything, I haven't gone through all of GHC yet.
05:38:51 <JaffaCake> one-shot mode is fine, but --make that is wrong
05:39:04 <shapr> I wonder if maybe one-shot is being called from --make?
05:39:18 <JaffaCake> yes, findObjectLinkable is the problem
05:39:39 <shapr> findObjectLinkable appears to be called only from one-shot mode.
05:39:47 <JaffaCake> oh realy?
05:39:56 <shapr> That's all I could find.
05:39:58 * JaffaCake looks
05:40:06 <shapr> That's why I wonder if this isn't a bug.
05:40:17 <shapr> I talked to ChilliX and Lemmih about this when I got frustrated.
05:40:45 <shapr> ChilliX said that I should trace through the linking parts of hscCompileBatch, hscCompileNothing and hscCompileInteractive.
05:41:01 <shapr> I got lost again there, can you tell me how they connect to the linking code?
05:41:14 * shapr keeps JaffaCake typing so the sandwich will last longer...
05:41:52 * JaffaCake has one mouthful left, but both hands operating emacs...
05:41:56 <shapr> JaffaCake: Also, do you and Simon use emacs for ghc hacking? There are some collaborative coding tools...
05:42:53 <shapr> JaffaCake: If this is a one hour task for you, you must have very productive hours.
05:43:12 <JaffaCake> don't confuse BatchCompile with one-shot, BatchCompile is --make
05:43:34 <JaffaCake> which version of the sources are you looking at, BTW?
05:43:44 <shapr> darcs.haskell.org/ghc
05:43:48 <JaffaCake> ok
05:44:00 <shapr> I think I'm missing five or ten patches though.
05:44:13 <JaffaCake> then findObjectLinkable is called at GHC.hs:1108
05:44:31 <shapr> aha
05:44:47 <shapr> And that interactive case is the GHCi link?
05:45:03 <JaffaCake> right
05:45:16 <JaffaCake> interactive is probably wrong too, but I guess in a different place
05:45:16 <shapr> So if I change both of those to code that checks a bool in ModIface, it'll be fixed!
05:45:28 <shapr> There's another findObjectLinkable a few lines below, looks like the same thing.
05:45:36 <JaffaCake> right
05:45:45 <JaffaCake> one problem is that we haven't read the ModIface yet
05:45:51 <shapr> oh
05:46:00 <JaffaCake> hmm, actually this is slightly harder than I thought
05:46:17 <shapr> Ok, it's not a one hour JaffaCake task, whew.
05:47:01 <shapr> JaffaCake: I very much wish for a pipeline view of GHC.
05:47:05 <JaffaCake> some refactoring would be required so we don't have to pass the linkable down from here, but calculate it later
05:47:07 <shapr> I could write up one for the GHC wiki.
05:47:19 <psnl> shapr: that would be cool
05:47:28 <JaffaCake> yes, sounds good
05:47:45 <shapr> JaffaCake: Want me to continue? SPJ sent me an email prod saying that the devlog needs to be sent ASAP.
05:48:08 <JaffaCake> by all means stop here and write up your analysis if you like
05:48:22 <shapr> Ok, will do.
05:48:37 <shapr> Oh hey, is there a dress code for the interviews?
05:48:46 <shapr> Jeans and a button down is okay?
05:49:00 <JaffaCake> I don't know for sure, probably dress "smart" to be on the safe side
05:49:19 <shapr> What does "smart" mean in the UK?
05:49:36 * psnl prods edwinb 
05:49:37 <JaffaCake> shirt and trousers I guess
05:49:43 <shapr> Ok, thanks for your time!
05:49:45 * JaffaCake doesn't own any smart clothes
05:49:49 <vincenz> JaffaCake: do you think there will still be ghc projects there in 2008?
05:49:49 <edwinb> oof
05:49:50 <shapr> hah
05:49:53 <psnl> I would wear a suit or a shirt and tie
05:49:55 <shapr> JaffaCake: But you got the job :-)
05:50:01 <psnl> edwinb: smart in the uk?
05:50:12 <vincenz> JaffaCake: unfortunately I don't think that I could come during this point in time, though I would like to do an internship somewhere in the future
05:50:13 <JaffaCake> yeah, the clothes I wore for my MS interview don't fit any more :)
05:50:20 <shapr> I wonder if I could ride my unicycle during the interview ;-)
05:50:24 <edwinb> I'd take smart to mean whatever the context demanded smart to be
05:50:28 * edwinb gives a content free answer
05:50:39 <shapr> :-P
05:50:46 <JaffaCake> vincenz: very likely, yes
05:50:53 <psnl> edwinb: you can tell you have become a postdoc
05:51:05 <edwinb> hmmm... how?
05:51:14 <vincenz> JaffaCake: maybe postdoc position?
05:51:18 <psnl> content free answer
05:51:19 <edwinb> For an interview, I suppose if someone said I should be smart I'd wear a tie...
05:51:27 <edwinb> psnl: Bah!
05:51:30 <musasabi> Is there a good way to find what causes shift/reduce conflicts in a Happy grammar? -i produces a lot of output (some ~15000 lines for me)
05:51:37 <psnl> I wore a tie for my last job interview
05:51:41 <JaffaCake> vincenz: postdoc positions are very scarce right now, but internships are plentiful
05:51:42 <vincenz> musasabi: it should tell you up ront
05:51:51 <ricky_clarkson> I just about manage to shave for interviews.
05:52:02 <vincenz> JaffaCake: alright, either way it'd have to be during my second rewrite of my phdthesis or right after that so 2008 at the earliest :/
05:52:02 <JaffaCake> musasabi: the -i option
05:52:06 <ricky_clarkson> Anything else is a bonus.
05:52:49 <edwinb> psnl: I wore a tie for my interview here and was relieved when the interviewers were dressed up too...
05:53:04 <edwinb> First thing they said was "Don't worry, we don't usually wear suits."
05:53:19 <psnl> heh
05:54:12 <ricky_clarkson> shapr: functionalj doesn't interest me, because it uses reflection heavily, which I'm keen to avoid.  Thanks for the links, some good reading there.
05:54:12 <shapr> Hiya timjr, learning Haskell? :-)
05:54:28 <shapr> ricky_clarkson: Sure, any other FP questions? Want to learn Haskell?
05:54:43 <shapr> I can give you the quick tour of Haskell and #haskell if you want.
05:55:08 <ricky_clarkson> shapr: More likely lisp, and then Clean.
05:55:15 <timjr> I'm planning to, actually.  I recently picked up "The Haskell Road to Logic, Maths, and Programming", but haven't had time for it yet
05:55:21 <shapr> timjr: Oh, nice book.
05:55:32 <ricky_clarkson> However, I wouldn't mind an explanation of monads that a mainly Java-guy can understand. ;)
05:55:36 <shapr> ricky_clarkson: Ok, feel free to come back here and ask questions.
05:55:38 <shapr> ricky_clarkson: Sure, no problem.
05:55:56 <shapr> Monads are an abstraction, like objects are an abstraction.
05:56:26 <shapr> They turn the significance/semantics/meaning of a value/type into a pipeline (typeline?).
05:56:37 <shapr> ricky_clarkson: I bet you've built webshops...
05:56:40 <ricky_clarkson> No.
05:56:45 <erider> hi all good day
05:56:48 <vincenz> shapr: piletyne
05:56:51 <ricky_clarkson> I'm a client-side coder, not a web monkey. ;)
05:56:55 <shapr> Ok, fair enough
05:57:35 <shapr> In any case, a webshop often ends up with a bunch of nested if-then-else chunks. Have you ever wanted to abstract that sort of thing away?
05:57:55 <shapr> There's a type in Haskell called Maybe, it looks like: data Maybe a = Nothing | Just a
05:57:56 <ricky_clarkson> One way of doing that is with the visitor pattern.  Another is the strategy.
05:58:14 <xerox> timjr: excellent book!
05:58:29 <xerox> shapr: hah - typeline!
05:58:36 <timjr> thanks, I bought it myself ;)
05:58:44 <shapr> The maybe type represents failure with Nothing, or a successful result with Just result
05:58:56 <shapr> ricky_clarkson: Yeah well, we can talk Gang of Four and FP later :-)
05:58:56 <ricky_clarkson> Ok.  That smells like null.
05:59:15 <shapr> Yeah, close enough.
05:59:21 <musasabi> hmm. GHC parser would have the same problem with the class alias proposal.
05:59:28 <ricky_clarkson> Probably the NullObjects [anti?]pattern.
06:00:05 <shapr> If you had a webshop with doesClientExist, doesItemExist, isItemInStock, those functions could have an input of the order record, and an output of Maybe OrderRecord.
06:00:38 <shapr> Rather than manually doing all the if-then-else, you can build a pipeline that abstracts the way to combine all those functions.
06:00:53 <ricky_clarkson> So instead of those returning booleans, they return the object, or a Nothing.
06:00:54 <musasabi> "'class' 'alias' ctype '=' ..." <- alias is a valid typevariable and thus this conflicts in nasty way with normal class declarations as the parser does not require them to be sensible types for a class declaration.
06:00:59 <shapr> ricky_clarkson: yup
06:01:27 <ricky_clarkson> Ok, I've done that myself in Java before.  Yet another way is to throw an exception instead of returning Nothing.
06:01:38 <shapr> The combination function looks like Nothing >>= f = Nothing and (Just a) >>= f = f a
06:02:03 <vincenz> anyone know a spamfilter for mail under linux
06:02:14 <shapr> ricky_clarkson: Is that clear enough? You know pattern matching?
06:02:21 <ricky_clarkson> shapr: I don't understand that syntax.
06:02:25 <musasabi> Basically the haskell parsers treat "class foobar" as valid and only check later that the LHS is valid.
06:02:31 <ricky_clarkson> Can you put in the optional parentheses?
06:02:42 <shapr> Haskell lets you write what looks like multiple definitions of a function, but instead it's a case match.
06:03:02 <psnl> vincenz: I use spamassassin
06:03:02 <shapr> foo 1 = "It's a one" ; foo 2 = "It's a two" ; foo _ = "Something else"
06:03:13 <llama32> what's a good tutorial for someone who is used to languages like C and smalltalk? i tried "haskell 98 tutorial" but it didn't seem to explain anything very well...
06:03:20 <shapr> ricky_clarkson: Each case is tried in turn, the _ matches anything.
06:03:25 <vincenz> @tell dons When you have some time, I just got a university account.  I would like to reuse your interface (I like the layout).  Do you use any tools to autogenerate?  Is the layout and format opensource.../
06:03:26 <lambdabot> Consider it noted.
06:03:35 <vincenz> psnl: it will read stuff from "mail" and remove em
06:03:35 <vincenz> ?
06:03:40 <shapr> ricky_clarkson: Got it?
06:03:43 <ricky_clarkson> shapr: Does the first f in that line mean f(), i.e., f called with nothing?
06:03:51 <shapr> Nah, it means f called with 1 as the argument.
06:03:55 <psnl> vincenz: oh, if I want to do something like that, I use procmail
06:03:59 <ricky_clarkson> No, in the other line.
06:04:06 <ricky_clarkson> "Nothing >>= f = Nothing and (Just a) >>= f = f a"
06:04:10 <shapr> http://www.haskell.org/hawiki/HaskellDemo
06:04:12 <lambdabot> Title: HaskellDemo - The Haskell Wiki
06:04:27 <vincenz> psnl: it's on the uni box so I don't have root acecss
06:04:28 <shapr> ricky_clarkson: Nah, that's an infix operator definition.
06:04:39 <shapr> Any operator is just a function.
06:04:59 <shapr> You can use the foo we just talked about as infix with backticks.
06:05:02 <ricky_clarkson> Is the type beforehand, i.e., Nothing or (Just a) there an input type, a return type or both?
06:05:10 <shapr> Wouldn't help though, since it doesn't take two args :-)
06:05:27 <mikael> the first f is the function f itself.  haskell doesn't have functions that take no arguments, because it'd necessarily give the same result every time, so just use a variable :-)
06:05:29 <psnl> vincenz: .forward doesn' work?
06:05:33 <shapr> The type of the whole definition is a -> Just a
06:05:34 <psnl> evil
06:05:43 <ricky_clarkson> mikael: Makes sense. ;)
06:06:13 <shapr> You can define a type with a variable in it to get parameterized types.
06:06:23 <xerox> <name> <args> = <expression> -- function definition
06:06:38 <xerox> <name> :: <type> -- type annotation
06:06:43 <shapr> For example, look at the definition of Tree in http://www.haskell.org/hawiki/HaskellDemo
06:06:44 <lambdabot> Title: HaskellDemo - The Haskell Wiki
06:06:47 <ricky_clarkson> So when f receives Nothing it returns Nothing, and when f receives Just a it calls itself and passes a to itself?
06:06:57 <xerox> <name> :: (<constraints>) => <type> -- when you learn about typeclasses :)
06:07:03 <shapr> ricky_clarkson: We're defining >>=
06:07:09 <shapr> and naming its second argument f
06:07:09 <vincenz> psnl: procmail uses .forward?
06:07:21 <vincenz> psnl: can we pm?
06:07:21 <shapr> ricky_clarkson: Would text names be easier to read?
06:07:45 <ricky_clarkson> shapr: So if I call >>= on a Nothing, I will get a Nothing back.
06:07:47 <shapr> Nothing >>= f = Nothing  --> Nothing bindM f = Nothing
06:07:52 <ricky_clarkson> Nothing >>= anything, gives nothing.
06:07:57 <shapr> That's correct.
06:08:09 <musasabi> JaffaCake: is there a good alternative to the context type parsing hack in the GHC parser? btype seems too liberal if one wants to have the class alias syntax.
06:08:43 <kosmikus> use parser combinators ;)
06:08:51 <xerox> ?fptools Control.Monad.Maybe
06:08:51 <lambdabot> Control.Monad.Maybe not available
06:08:52 <ricky_clarkson> If I call >>=, passing a Just a on the left and f on the right, I get f(a) back?
06:08:53 <shapr> ricky_clarkson: the syntax at the beginning of "(Just a) bindM f = f a" is a constructor match, unpack, and value assignment.
06:09:00 <shapr> ricky_clarkson: That's correct.
06:09:05 <xerox> ?fptools Data.Maybe
06:09:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
06:09:10 <shapr> You now understand your first monad!
06:09:14 <JaffaCake> musasabi: difficult question - there are various ways to parse types in LALR(1), but no completely accurate way AFAIK
06:09:20 <xerox> See `instance Monad Maybe' in that file!
06:09:32 <xerox> It's the clearest description you'll find :)
06:09:35 <ricky_clarkson> shapr: It seems very simple, I think I could emulate that in Java easily.
06:09:42 <shapr> ricky_clarkson: So do you see how doesItemExist >>= doesClientExist >>= isItemInStock would work?
06:09:53 <shapr> ricky_clarkson: Just wait, it gets better...
06:09:58 <ricky_clarkson> Yes, but the names of those functions seem odd.
06:10:02 <xerox> Positive Karma to equational reasoning.
06:10:15 <shapr> It's just a model.
06:10:19 <musasabi> JaffaCake: ok. I'll talk to JohnMeacham if he has a solution/alternative syntax for it (or just add an another hack).
06:10:20 * shapr quotes Monty Python
06:10:28 <ricky_clarkson> It reminds me of the way floats and doubles work with NaN in languages that use the IEEE formats.
06:10:35 <JaffaCake> musasabi: are you adding class aliases?
06:10:39 <vincenz> pffft
06:10:41 <vincenz> WAY TOO WARM
06:11:02 <shapr> ricky_clarkson: So, if you'd rather return an informative error message instead of just "It died.", you can use the Either type
06:11:15 <shapr> looks like data Either a b = Left a | Right b
06:11:27 <musasabi> JaffaCake: I am looking into it, cannot promise anything yet.
06:11:28 <shapr> By convention, left is an error and right is a successful result.
06:11:29 <ricky_clarkson> shapr: I don't see how that is modelling state, it appears to be (possibly) creating new state on each stage of the pipeline.
06:11:49 <shapr> ricky_clarkson: It doesn't model state at all, we haven't gotten to the state monad. You asked about monads, right?
06:11:58 <JaffaCake> musasabi: ok, good luck!
06:11:59 <Itkovian> shapr: ping
06:12:00 <ricky_clarkson> shapr: Ah, I didn't know there was a distinction.
06:12:01 <shapr> Not all objects are state objects
06:12:03 <vincenz> Itkovian: pong
06:12:04 <shapr> Itkovian: y0
06:12:08 <Itkovian> you have some time?
06:12:16 <Itkovian> I suggest we take this to #overflow
06:12:46 <shapr> Itkovian: After I'm done explaining monads to ricky_clarkson?
06:12:55 <Itkovian> sure
06:13:19 <ricky_clarkson> shapr: Ok, I think I get that much, approximately.
06:13:32 <shapr> ricky_clarkson: Like I said in the beginning, a monad is just an abstraction. It roughly turns the meaning of a type into a pipeline with the same meaning.
06:13:49 <ricky_clarkson> Except you get a Maybe at the end.
06:13:59 <xerox> ricky_clarkson: until the type of the expression becomes polymorphic
06:14:09 <xerox> ricky_clarkson: then you are not tied to the particular monad anymore
06:14:14 <mikael> shapr: who makes your keyboard, again?
06:14:19 <shapr> mikael: kinesis-ergo.com
06:14:21 <mikael> thanks
06:14:25 <xerox> ....and monads show the composability property!
06:14:44 <ricky_clarkson> xerox: Which means you can make other functions out of them?
06:14:55 <shapr> ricky_clarkson: oookay... did you get the Either type?
06:15:01 <ricky_clarkson> shapr: I think so.
06:15:11 <xerox> Listen to shapr, overlapping explanations are not too good.
06:15:15 <ricky_clarkson> Like a C union inside a struct that identifies it.
06:15:15 * shapr grins
06:15:24 <shapr> um
06:16:11 <shapr> ricky_clarkson: How would you modify the just explain definition of >>= to match on the Left error constructor to return the error?
06:17:19 <ricky_clarkson> I haven't noticed any error constructors yet.
06:17:32 <shapr> ricky_clarkson: Left is the error message by convention.
06:17:53 <ricky_clarkson> I see.
06:18:01 <shapr> Can you see how you'd turn the Nothing match into something like the Just match, but use Left a instead?
06:18:08 <xerox> If it doesn't go Right, it will go... Left.
06:18:27 <ricky_clarkson> I'd substitute Nothing for Left a and Just a for Right a.
06:18:34 <shapr> ricky_clarkson: exactly!
06:18:41 * shapr gives a gold lambda sticker to ricky_clarkson
06:18:59 <shapr> I always got gold stars for good answers when I was young.. I loved it :-)
06:19:06 <shapr> aanyway
06:19:33 <ricky_clarkson> Why would you use Left instead of Nothing?  To give more information about errors?
06:19:50 <shapr> Exactly, it returns an error message of your choice of flavors.
06:20:37 <shapr> It's maybe with an error message.
06:20:42 <Itkovian> @tell vincenz Koen is definitely interested, but he cannot make it in the week of the 7th August, so we should move this to the end of August, and some other people will probably attend too
06:20:42 <lambdabot> Consider it noted.
06:21:07 <shapr> ricky_clarkson: Ok, those were both nearly identical, let's go for something more fun... the list monad!
06:21:20 <ricky_clarkson> shapr: Is Left used for that convention merely because defining a new version of Either for everything would be a pita?
06:21:21 <shapr> ricky_clarkson: You can follow along on the web if you want - http://www.nomaware.com/monads/html/index.html
06:21:22 <lambdabot> Title: All About Monads
06:21:40 <shapr> The either type is just for representing something that can be either one thing or the other.
06:21:41 <xerox> Now, if your actions use "fail" to express failure, when you use Maybe you get Nothing, when you use Either you get Left foo where foo is the argument to fail. The same action can be reused.
06:22:09 <shapr> Since lots of people will use such a type, it's in the standard libs.
06:22:13 <ricky_clarkson> Ok.
06:22:31 <shapr> Do you see the "Catalog of standard monads" section on that url I pasted?
06:22:33 <ricky_clarkson> Don't you ever want to resolve what's actually there?
06:22:41 <shapr> What do you mean?
06:22:47 <ricky_clarkson> Yep.
06:23:09 <shapr> resolve what's actually there?
06:23:21 <xerox> (What monad to use.)
06:23:24 <ricky_clarkson> You have an Either - at some point you need to find out whether you have a Left or a Right.  E.g., to find out whether to display an error etc.
06:23:33 <xerox> (Oh, sorry.)
06:23:38 <shapr> The definition of >>= does that.
06:24:02 <shapr> doesItemExist >>= doesClientExist >>= isItemInStock
06:24:11 <shapr> At this point those functions now return a message instead.
06:24:17 <ricky_clarkson> Ah, right, so you don't actually inspect it, you just say what should happen in each case.
06:24:34 <shapr> For example, isItemInStock might return "Not in Stock" or instead "Database on fire"
06:25:13 <ricky_clarkson> Ok.
06:25:20 <SamB> aww. my C UM is a bit slower than edwardk's :-(
06:25:28 <shapr> Ok, time for the next monad.
06:25:50 <ricky_clarkson> So it's like a tree of possible operations, except in this case it's a very biased tree.
06:25:59 <shapr> Sounds right to me.
06:26:15 <shapr> Speaking of trees, you know you could use a list to represent a tree of possibilities, yeah?
06:26:54 <ricky_clarkson> Yes, but you'd need a way of knowing where each branch terminates.
06:27:06 <SamB> I shoulda done that thing with A/B/C macros too. I almost did...
06:27:09 <shapr> Look at http://www.nomaware.com/monads/html/listmonad.html
06:27:10 <lambdabot> Title: The List monad
06:27:32 <xerox> Do you? Bear in mind you can have infinite list.
06:28:47 <shapr> If you take the significance of the list type to be a list of possibilities, like a game tree, the pipeline equivalent would traverse that tree, yeah?
06:29:11 <shapr> ricky_clarkson: Or would you rather jump straight into state from here?
06:29:40 <ricky_clarkson> I don't know. ;)
06:29:56 <Itkovian> let's tackle list fiirst
06:30:34 <ricky_clarkson> I think I get the tree traversal, but I envisage lots of pipelines repeating to traverse the tree, unless you have a way of passing a function to a tree (or list) to operate on each node.
06:30:59 <SamB> I think the less hacky way he uses the cheesy hack is probably the secret?
06:31:35 <shapr> Hm, I've just blanked out on the list monad.
06:31:46 <shapr> At least, I can't think of a good way to explain it...
06:32:12 <shapr> Ok, let's go to state for now =)
06:32:12 <SamB> huh?
06:32:18 <SamB> blanked out?
06:32:19 <ricky_clarkson> Ok.
06:32:23 <xerox> shapr: reader! writer!
06:32:25 <ricky_clarkson> SamB: Blanked.
06:32:28 <shapr> SamB: How would you explain the list monad?
06:32:31 <shapr> Anyway, state...
06:32:49 <xerox> I know how to explain it|!
06:32:56 <shapr> You've seen those weenie solar powered calculators with a single chunk of memory yeah? The ones with M+ and MC?
06:33:02 <shapr> xerox: Ok, after state?
06:33:06 <ricky_clarkson> shapr: Yes.
06:33:10 <shapr> tag team monads...
06:33:13 <xerox> shapr: before! Then you compose them and get state!
06:33:34 <shapr> Ok, go for it.
06:33:36 <xerox> Ah, you got a metaphore :-)
06:33:38 * shapr makes a sandwich
06:33:41 <SamB> well, return gives you a one-item list, fmap applies your function to every item, and >>= is more-or-less concatMap?
06:33:57 <shapr> I know how to use the list monad, I just can't think of how to explain it.
06:34:23 <SamB> it contains a number of values
06:34:31 <ricky_clarkson> I thought it might.
06:34:36 <xerox> The computational view of the list monad is more or less this one: an action returning values in the list monad simply returns a list of results. Since the list can be infinite, it models nondeterminism, returning all the possible results!
06:34:43 <dons> did everyone see xerox's new ghci-on-acid binding to lambdabot, http://www.scannedinavian.com/hope/image/27/full
06:34:46 <dons> ?
06:34:47 <dons> ?karma+ xerox
06:34:47 <lambdabot> xerox's karma raised to 20.
06:34:54 <xerox> Thanks dons :-)
06:35:08 <ricky_clarkson> xerox: Surprisingly I think I get that.
06:35:19 <SamB> does that use something like Pan?
06:35:23 <xerox> ricky_clarkson: Good!
06:35:43 <xerox> An example is enlightening:
06:35:56 <ricky_clarkson> So something that returns a list monad returns an object that you can pass functions to, and those functions will be executed for every item in the list?
06:36:05 <xerox> > [1,2,3] >>= (\x -> [x*2,x*3,x*4])
06:36:06 <lambdabot>  [2,3,4,4,6,8,6,9,12]
06:36:22 <SamB> ricky_clarkson: heh
06:36:27 <SamB> no, just a plain-old list
06:36:39 <xerox> ricky_clarkson: that's part of it.
06:37:03 <xerox> First the function gets mapped on each element of the returned list:
06:37:07 <SamB> @pl concatMap f xs
06:37:08 <lambdabot> f =<< xs
06:37:16 <xerox> > map (\x -> [x*2,x*3,x*4]) [1,2,3]
06:37:17 <lambdabot>  [[2,3,4],[4,6,8],[6,9,12]]
06:37:21 <SamB> so, basically...
06:37:25 <xerox> Then the result is joined so to form another list:
06:37:29 <xerox> > join $ map (\x -> [x*2,x*3,x*4]) [1,2,3]
06:37:31 <lambdabot>  [2,3,4,4,6,8,6,9,12]
06:37:44 <xerox> Thus returning just a list.
06:38:05 <xerox> As SamB showed, (>>=) = concatMap for the List Monad.
06:38:11 <ricky_clarkson> Ok, that makes sense I think.
06:38:16 <xerox> In fact every monad behaves like that.
06:38:19 <SamB> xerox: no, (=<<) = concatMap
06:38:23 <ricky_clarkson> Why is it called concatMap and not concatList?
06:38:37 <dons> it does a map and a concat
06:38:38 <SamB> ricky_clarkson: it is the same as concat.map
06:38:41 <dons> ?type concat
06:38:42 <xerox> ricky_clarkson: because it is xs >>= f = concat (map f xs)
06:38:43 <lambdabot> forall a. [[a]] -> [a]
06:38:43 <dons> ?type map
06:38:44 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
06:38:48 <dons> ?type concatMap
06:38:49 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
06:38:53 <dons> ?type concat.map
06:38:54 <lambdabot>   Expecting a function type, but found `b'
06:38:55 <lambdabot>    Expected type: (a1 -> b) -> [[a]]
06:38:57 <xerox> ?type (concat .) . map
06:38:58 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
06:38:58 * xerox boings
06:39:01 <dons> :)
06:39:14 <dons> ?pointfree-fu+ xerox
06:39:15 <lambdabot> Unknown command, try @list
06:39:21 <ricky_clarkson> map f xs maps the function f to the list xs?
06:39:26 <xerox> Yes.
06:39:26 <shapr> yup
06:39:28 <ricky_clarkson> ..and returns a list
06:39:32 <dons> > map (*2) [1..10]
06:39:33 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
06:39:47 <dons> > map toUpper "haskell"
06:39:48 <lambdabot>  "HASKELL"
06:39:52 <xerox> Now, more generally: amb >>= f = join (fmap f amb) -- where join and fmap are the proper definition for each monad.
06:39:58 <dons> it our basic control structure, the map
06:40:06 <xerox> For some monads this definition is terribly convenient, for example for the List one.
06:40:14 <xerox> (For other monads it's not.)
06:40:17 <SamB> instance Functor [] where { fmap = map }; instance Monad [] where { (>>=) = flip concatMap, return = (:[]) }
06:40:21 <SamB> I think that works
06:40:41 <SamB> except that [] is already an instance of both of these classes
06:40:48 * xerox nods
06:41:08 <shapr> xerox: So, you want to do state too?
06:41:37 <xerox> Please go on shapr, I gotta go out for a moment now. I just meant that makes sense to do Reader and Writer before that :)
06:41:38 <shapr> ricky_clarkson: Are you beginning to see that both the list monad and the maybe monad are instances of the same thing?
06:41:48 <SamB> hehe
06:41:59 <ricky_clarkson> shapr: Nope. ;)
06:42:08 <SamB> ricky_clarkson: the difference is that...
06:42:13 <xerox> Environment • Logs = State -- or something like that :)
06:42:22 <kpreid> ricky_clarkson: Nothing is to [] as Just x is to [x]
06:42:32 <SamB> > return "Hi" `mplus` return "Hello" :: Maybe String
06:42:34 <lambdabot>  Just "Hi"
06:42:46 <SamB> returns Just "Hi"
06:42:50 <SamB> and...
06:42:51 <ricky_clarkson> [] is an empty list, and [x] is a list with one element, x?
06:42:56 <SamB> > return "Hi" `mplus` return "Hello" :: [String]
06:42:57 <lambdabot>  ["Hi","Hello"]
06:43:01 <kpreid> ricky_clarkson: yes
06:43:10 <SamB> returns ["Hi", "Hello"]
06:43:28 <ricky_clarkson> Maybe has only two possible states, a list has an infinite number of possible states, but you don't care about them.
06:44:10 <shapr> Cale wrote a neat article about monads as containers...
06:44:27 <shapr> http://www.haskell.org/haskellwiki/Monads_as_Containers
06:44:28 <lambdabot> Title: Monads as Containers - HaskellWiki
06:44:51 <Dino_> I've gotten working on something and had originally just made a simple Makefile. But it's gotten even more complicated. And I'm now wondering if I should be using hmake instead.
06:44:59 <SamB> heh
06:45:01 <SamB> hmake?
06:45:09 <xerox> Later, haskellers!
06:45:10 <SamB> try a shell script instead
06:45:14 <shapr> And in fact, each monad has three pieces, the container and two functions. One function puts a value into the container, and one function puts together two containers.
06:45:16 <Dino_> http://www.cs.york.ac.uk/fp/hmake/
06:45:18 <lambdabot> Title: hmake - a make tool for Haskell programs
06:45:35 <shapr> ricky_clarkson: Still keeping up?
06:45:44 <ricky_clarkson> A state monad seems rather like a stack variable in Java, if it is declared final in each method it is passed to.
06:45:45 <Dino_> That answers one question right there: I was going to ask if it's just totally The Way for everyone to use hmake.
06:46:05 <SamB> ricky_clarkson: that sounds ... wierd!
06:46:10 <ricky_clarkson> shapr: I will go back and fill in the gaps, but I think so.
06:46:52 <shapr> OK, I'll jump to the state monad.
06:47:06 <shapr> Remember the weenie calculator above?
06:47:21 <SamB> how do you calculate a weenie?
06:47:26 <shapr> You could write a purely functional version of that by explicitly passing around the one chunk of memory.
06:47:28 <Killer666> haha, ricky, java is not cool anymore?
06:47:30 <ricky_clarkson> shapr: Yes.
06:47:47 <shapr> Killer666: He's taking a short sabbatical to learn monads :-P
06:47:50 <ricky_clarkson> Killer666: Sure, just trying to get the hang of some FP concepts - I've found my Java code drifting that way.
06:48:20 <shapr> ricky_clarkson: That's how I got into Haskell, I went from Java to Python to Haskell as I pursued certain ideas.
06:48:31 <ricky_clarkson> Killer666: oh and, yo tere.
06:48:33 <kpreid> shapr: Have you caught them yet?
06:48:35 <shapr> Such as, "a chunk of code should turn into its result"
06:48:53 <shapr> kpreid: Yeah, my ideas were good, I was just a few decades behind the FP community.
06:49:16 <shapr> Anyway, pure FP was exactly what I was blindly groping towards.
06:49:19 <ricky_clarkson> shapr: I wrote a layout manager for Java that probably smacks of this stuff a lot.
06:49:33 <shapr> There's lots more good stuff where this came from.
06:49:43 <SamB> layout manager?
06:49:43 <ricky_clarkson> http://cime.net/~ricky/tmp/extensible.zip is a reasonably recent version - it's not fully released yet.
06:49:51 <shapr> I've been learning for five years and I still find new things every week.
06:50:34 <shapr> Anyway, instead of explicitly passing around that one chunk of state all the time, we could build a type to represent it, and then a pipeline to do it automagically, right?
06:50:55 <SamB> indeed!
06:50:59 <SamB> newtype is fun!
06:51:13 <ricky_clarkson> Ok, a state monad seems to consist of an immutable starting state and a chain of functions to get its current state from that.
06:51:25 <ricky_clarkson> Probably the immutable starting state was just in my imagination.
06:51:32 <shapr> No, you're right.
06:51:40 <SamB> all of them are immutable
06:51:56 <SamB> not just the starting one
06:52:06 <Killer666> there is nothing mutable
06:52:21 <Itkovian> so how do you avoid keeping the functions that update it around when they're not really required?
06:52:23 <ricky_clarkson> So the problem is, how does the user get his starting state replaced with the starting state plus the chain of functions?
06:52:25 <SamB> its kind of silly to use a state monad to pass around a mutable value...
06:52:32 <shapr> ricky_clarkson: If you want to see a step-by-step rewriting of explicit passing to monad, check out the sources @ http://www.scannedinavian.com/~shae/steve_atkins_monads/
06:52:33 <lambdabot> Title: Index of /~shae/steve_atkins_monads
06:52:34 <SamB> er, reference
06:53:32 <Dino_> Every time there's any change, the new state comes back as part of the evaluation?
06:53:34 <SamB> ricky_clarkson: chain of functions?
06:53:36 <shapr> ricky_clarkson: Eval6.hs from that directory explicitly passes in the starting state.
06:53:38 <kpreid> > execState (modify (+1) >> modify (*2)) 1
06:53:40 <lambdabot>  4
06:54:05 <shapr> And as kpreid just demonstrated, the starting state must be explicit.
06:54:18 <kpreid> > execState (modify (+1) >> modify (*2)) 2
06:54:20 <lambdabot>  6
06:54:30 <SamB> @type execState
06:54:32 <lambdabot> forall s a. State s a -> s -> s
06:54:35 <SamB> @type runState
06:54:37 <lambdabot> forall s a. State s a -> s -> (a, s)
06:54:47 <kpreid> > evalState (modify (+1) >> modify (*2) >> get) 2
06:54:49 <xerox> > execState (put 1 >> get) undefined :: Int
06:54:49 <lambdabot>  6
06:54:50 <lambdabot>  1
06:54:56 <xerox> No explicit initial state, shapr -^
06:54:57 <xerox> ;-)
06:55:18 <kpreid> (runState returns the state and the last value; evalState and execState return one or the other)
06:55:19 <xerox> ?type runState
06:55:21 <lambdabot> forall s a. State s a -> s -> (a, s)
06:55:22 <shapr> :-P
06:55:28 <xerox> OK, shops.
06:55:55 <ricky_clarkson> Is Dino_ right?
06:56:08 <shapr> yes
06:56:32 <ricky_clarkson> Ok, so the only thing special about it is that the language has special support for it, I'm guessing.
06:56:38 <xerox> The thing is that State s a is just a synonym for 's -> (a,s)'
06:56:49 <ricky_clarkson> What's ->
06:56:55 <kpreid> ricky_clarkson: special about what?
06:56:56 <shapr> It's a function type.
06:56:57 <xerox> The functions type constructor
06:57:11 <xerox> Reader e a  is  e -> a
06:57:17 <shapr> So add1 x = x + 1 is of type Int -> Int
06:57:18 <xerox> Writer w a  is  (a,w)
06:57:24 <ricky_clarkson> Got it.
06:57:25 <xerox> Compose then and you get State s a.
06:57:26 <shapr> written add1 :: Int -> Int
06:57:42 <ricky_clarkson> The first Int there is input type?
06:57:43 <SamB> xerox: compose?
06:57:51 <SamB> you mean smoosh
06:57:55 <xerox> SamB: not at language level
06:58:09 <ricky_clarkson> kpreid: Special about a monad.
06:58:15 <SamB> xerox: so smoosh
06:58:15 <ricky_clarkson> Er, a state monad.
06:58:19 <kpreid> ricky_clarkson: no
06:58:24 <kpreid> state monads have no special support
06:58:32 <kpreid> nor do monads /except/ for the do-notation
06:58:36 <kpreid> which we're not using
06:58:39 <kpreid> (yet)
06:58:40 <xerox> Still ReaderT (Writer w a) e a or WriterT (Reader e a) w a .. ?
06:58:43 <SamB> but which is way cool
06:59:06 <xerox> There _is_ a speciality about them, by the way, the MonadState MonadReader MonadFoo classes.
06:59:22 <kpreid> ricky_clarkson: if you invent something like monads but not, you can still write it in Haskell!
06:59:23 <xerox> Which makes stacking very handy
06:59:31 <xerox> OK, let me go now!!! :-)
06:59:31 <SamB> oh, okay, so they use multiparameter type classes with functional dependencies
06:59:38 <shapr> ricky_clarkson: In fact, monads do not require any special support - http://lambda-the-ultimate.org/node/1136
06:59:39 <lambdabot> Title: Collection of links to monad implementations in various languages. | Lambda the  ...
07:00:08 <SamB> but, monad users like extra support for some reason
07:00:45 <shapr> ricky_clarkson: The spiffiness of monads comes from the fact that their laws mean you can compose them in very nice ways.
07:01:18 <shapr> Since a >>= (b >>= c) must have the same result as (a >>= b) >>= c, then order of execution is unimportant...
07:01:33 <ricky_clarkson> Oh, that's new.
07:01:36 <SamB> order of execution?
07:01:43 <SamB> shapr... you silly.
07:01:48 <shapr> SamB: wah?
07:01:50 <SamB> that isn't order of execution
07:01:55 <shapr> what is it?
07:01:55 <SamB> that is associativity
07:01:57 <ricky_clarkson> So a monad is a state+functions, and the order of application of those functions is irrelevant?
07:01:58 <shapr> Right, ok...
07:01:59 <Dino_> ricky_clarkson: What you said above, the Int -> Int, yes, the first Int there can be thought of as input and the last thing is the evaluates-to-this.
07:02:27 <shapr> ricky_clarkson: http://www.nomaware.com/monads/html/laws.html
07:02:28 <lambdabot> Title: The monad laws
07:02:40 * gds likes the way the haskell type system is powerful enough to give us compile time guarentees about our Monads...
07:02:52 <SamB> a monad is not state plus functions
07:03:15 <shapr> The laws let you get certain behaviour out of monads that in my opinion makes them superior to OOP.
07:03:16 <gds> If I use the Maybe monad rather than null pointers, then I know at compile time which bits of the programme have to be prepared to deal with "Nothing"s...
07:03:28 <ricky_clarkson> Heh, typo in the first paragraph there, shapr.
07:03:30 <SamB> a monad is a polymorphic type for programs and a way to build programs with it
07:03:43 <ricky_clarkson> gds: Yes - in Java I would emulate the Maybe type, and have done.
07:04:09 <SamB> ricky_clarkson: java has parametric polymorphism now?
07:04:16 <Dino_> gds: Yeah, this is something that struck me. How many languages hack some idea of nullness into any old type, or mix strange things in that way.
07:04:17 <ricky_clarkson> SamB: Define it.
07:04:25 <SamB> well...
07:04:33 <SamB> data Mayba a = Just a | Nothing
07:04:33 <ricky_clarkson> Overloaded methods are statically chosen.
07:04:38 <ricky_clarkson> OVerridden methods aren't.
07:04:55 <Dino_> And then you look at Maybe and it's clearly separated from the type being carried by the Maybe.
07:04:58 <SamB> can you write a "class" that takes a type as argument?
07:05:04 <ricky_clarkson> SamB: Yes.
07:05:14 <SamB> ricky_clarkson: what would it look like?
07:05:42 <gds> Dino_: indeed - helps a lot with avoiding problems of the sort that lead to SQL injection attacks and whatnot...
07:05:57 <ricky_clarkson> interface Maybe<T> { void doIfNothing(); void doIfNotNothing(); }
07:06:00 <kpreid> ricky_clarkson: Java/Haskell translation: interface/class class/datatype implements/instance instance/value
07:06:05 <ricky_clarkson> SamB: doIfNotNothing is a terrible name. ;)
07:06:36 <ricky_clarkson> In fact the T isn't even relevant there.  I'll do it in a different way..
07:06:47 <Dino_> Perhaps doUnlessNothing
07:07:02 <ricky_clarkson> interface Maybe<T> { boolean isNothing(); T get(); }
07:07:02 <shapr> ricky_clarkson: You may want to look at the Java monad implementation, it may help.
07:07:04 <ricky_clarkson> That's reasonable.
07:07:11 <SamB> you haven't provided a way to get the value out of a non-Nothing value...
07:07:15 <ricky_clarkson> shapr: Yes, gives an error in WinZIP, gonna try in something else.
07:07:30 <ricky_clarkson> SamB: I have in the second of those interfaces.
07:07:32 <ricky_clarkson> get().
07:07:36 <SamB> oh, yeah...
07:08:03 <SamB> why is it called an "interface"?
07:08:13 <shapr> Anyway, I've seen Java parser libs that use monads, scheme uses monads in several libs, Ruby is starting to...
07:08:31 <shapr> Monads may supplant objects as the abstraction of choice.
07:08:39 <SamB> shapr: how long until Lisp has monadic parser combinators?
07:08:40 <kosmikus> SamB: why not? it describes an interface as opposed to an implementation ...
07:08:45 <SamB> er, Common Lisp
07:09:11 <SamB> kosmikus: I don't know Java well enough to understand if this is like @interface or not
07:09:21 <ricky_clarkson> SamB: Do you know C++ well?
07:09:41 <Dino_> Interface in Java is like a C++ pure abstract class. No implementations are allowed at all.
07:09:48 <SamB> well, I don't believe C++ has interfaces anyway
07:09:55 <ricky_clarkson> No instances are allowed at all.  Implementations are allowed.
07:09:59 <Dino_> SamB: You an make them by pure abstracting something.
07:10:02 <kpreid> SamB: the closest thing to a Java interface is an existential type
07:10:02 <ricky_clarkson> SamB: Right, but it has a direct equivalent.
07:10:11 <kpreid> SamB: except you can escape from it by casting
07:10:11 <SamB> why would you need more than one implementation?
07:10:18 <ricky_clarkson> SamB: Different uses.
07:10:26 <SamB> ricky_clarkson: oh, you mean pure abstract classes?
07:10:31 <ricky_clarkson> Yes.
07:10:38 <SamB> or do I mean virtual...
07:10:53 <ricky_clarkson> Abstract classes with solely pure virtual functions in them.
07:11:34 <SamB> I don't understand why they use such an icky notation...
07:12:18 <SamB> I mean, really: "virtual T get() = 0;" -- what were they thinking?
07:12:36 <kosmikus> SamB: that's not Java ...
07:12:46 <SamB> kosmikus: C++
07:12:55 <kosmikus> yes, I know ...
07:12:56 <Dino_> That's because C++ is really hacked onto C and those methods are pointers in a struct really. So setting it to 0 is like a null fp.
07:13:00 <Itkovian> brb
07:13:30 <SamB> I would have thought that "pure virtual T get();" was a more reasonable way to notate it.
07:13:44 <malcolm> Anyone here planning on going to ICFP?
07:13:58 <Dino_> SamB: It would. I'm with you, the notation gives me hives.
07:14:10 <mauke> yeah, but that requires yet another keyword
07:14:16 <SamB> well... so?
07:14:42 <mauke> keywords are bad
07:15:32 <ricky_clarkson> shapr: It's actually hard to read code with Object in now.
07:15:45 <ricky_clarkson> shapr: It's like seeing null, or switch, or float.
07:16:38 <Dino_> void!
07:17:27 <ricky_clarkson> Generics in Java has some interesting features that I think lead programmers closer to FP, if they use them.
07:17:41 * shapr grins
07:17:41 <ricky_clarkson> http://rickyclarkson.blogspot.com/2006/07/duck-typing-in-java-and-no-reflection.html
07:17:43 <lambdabot> Title: rickyclarkson: Duck Typing in Java, and no reflection
07:17:54 <shapr> ricky_clarkson: There's lots more past monads. Heard of arrows?
07:18:06 <ricky_clarkson> Yes, heard of them.
07:18:14 <Dino_> ricky_clarkson: I was screaming about not having templates in Java for the entire 10 years that I used it. And they finally lost my interest with the big J just as everybody is starting to use those Generics.
07:18:18 <ricky_clarkson> Thanks a lot for your explanations guys, appreciated.
07:18:25 <Dino_> Why it wasn't done much earlier, I have no idea.
07:18:31 <ricky_clarkson> Dino_: They aren't templates.
07:18:53 <ricky_clarkson> People that wanted templates were already using them, e.g., via Velocity.
07:19:06 <Dino_> Ok, then call it generics on both languages.
07:19:24 <ricky_clarkson> Java generics don't generate code like C++ templates do.
07:19:42 <shapr> ricky_clarkson: Anyway, if you have any more questions about Haskell, FP, etc, feel free to ask here.
07:19:49 <ricky_clarkson> Cheers.
07:20:02 <ricky_clarkson> Btw, did you know I'm on the #haskell quotes page?
07:20:07 <shapr> Yes
07:20:09 <shapr> I quoted you.
07:20:11 <psnl> @quotes
07:20:11 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
07:20:15 <shapr> @quote ricky_clarkson
07:20:16 <lambdabot> ricky_clarkson hasn't said anything memorable
07:20:33 <ricky_clarkson> (14:21:13) ricky_clarkson: Is Haskell an interface between programming languages and academics?
07:20:44 <ricky_clarkson> http://www.haskell.org/hawiki/QuotesPage
07:20:46 <lambdabot> Title: QuotesPage - The Haskell Wiki
07:21:25 <kpreid> ricky_clarkson: I sometimes see it as a way to get something useful out of them academics :=
07:21:31 <ricky_clarkson> I only knew because of Google Alerts.
07:21:52 <shapr> ricky_clarkson: It was a cute quote :-)
07:22:00 <kpreid> er, s/:=/:)/
07:22:19 <shapr> ricky_clarkson: I've never had any computer classes but I really enjoy Haskell. Thus I find that sort of quote entertaining.
07:22:57 <ricky_clarkson> I like the fact that I can explain Java to technophobes.  Of course, on that score, bash is the best language ever.
07:24:28 <Dino_> ricky_clarkson: I could be not understanding something very important, but I always had the impression that these two things are similar between C++ and Java. In that they allow you to design similar things.
07:24:44 <ricky_clarkson> All the FP languages that I've glanced at seem to be unnatural in syntax - saying that, I've been using imperative/OO languages for 20 years, so 'natural' for me is a little warped.
07:25:09 <tennin> I don't really see what would make Java easy to explain to 'technophobes'
07:25:55 <ricky_clarkson> I did it with a girlfriend, made interfaces Man and Woman and made Man have the method haveSexWith(Woman).
07:25:58 <mikael> there are a lot of technophobes who would find haskell easier and more enjoyable than java
07:26:03 <mikael> the unabomber, for example
07:26:24 <ricky_clarkson> Man implementations would call certain methods on Woman, like areYouGoodLooking and throw exceptions accordingly etc. ;)
07:26:38 <greenrd> mikael: I'm not sure the unamomber would be a good, uh, character witness for Haskell ;)
07:26:59 <ricky_clarkson> That was just for fun though, when it comes to real teaching, I get people to write small GUI programs.
07:27:10 <ricky_clarkson> http://cime.net/~ricky/netsim/pi
07:27:12 <lambdabot> Title: Programming on the Internet
07:27:24 <ricky_clarkson> Stupid name, I can't change it though. ;)
07:27:56 * ricky_clarkson goes off to find some live music to moan about.
07:28:24 <shapr> ricky_clarkson: etree.org?
07:29:05 <ricky_clarkson> shapr: Nice, but I was thinking more http://www.manchesterjazz.com/
07:29:06 <lambdabot> Title: Manchester Jazz Festival 2006: Home
07:30:31 <tennin> I'd think areYouGoodLooking should properly be a multimethod
07:30:53 <tennin> attractiveness is pretty subjective
07:31:03 <tennin> but wait, Java doesn't have those does it?
07:31:34 <Dino_> You know, I'm don't realy know what multimethod means.
07:31:41 <Dino_> bah, typing
07:31:44 <shapr> ricky_clarkson: Anyway, are you into languages like Mozart/Oz, Joy, etc?
07:32:15 <kosmikus> Dino_: a method that belongs to multiple objects (rather than just a single object)
07:34:49 <Dino_> ah
07:34:56 <sjanssen> @quote
07:34:57 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files in Different Directories!"
07:34:59 <greenrd> Dino_: Or in other words, a method whose implementation is polymorphic over not just a single "target" object, but over multiple objects
07:36:21 <kosmikus> any Haskell function that performs pattern matching on more than one argument is essentially a multimethod ...
07:37:04 <Philippa> ricky_clarkson: now make your example work in the real world where not everybody's straight, tastes vary...
07:38:32 <mikael> and it's offensive to have the method belong to the Man; a Haskell function doesn't need to arbitrarily belong to either gender :-)
07:39:00 <greenrd> Philippa: I had problems with a class where the lecturer was asking students to define contracts for a Person class... I started saying to students things like "Well it is physically _possible_ to get pregnant as a teenager... a parent isn't _necessarily_ more than 17 years older than their child"
07:39:05 <Dino_> Thank you.
07:39:33 <joelr1> JaffaCake: ping
07:40:02 <Lemmih> @seen ndm
07:40:02 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 11 hours, 58 minutes and 14 seconds ago, and .
07:40:08 <vincenz> @seen dons
07:40:09 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour and 11 seconds ago.
07:40:15 <Philippa> greenrd: if the lecturer'd specified that this class should behave according to local law that might've been more excusable
07:40:21 <sjanssen> @seen lambdabot
07:40:21 <lambdabot> Yes, I'm here. I'm in #instant-chaos, #unicycling, #oasis, #scannedinavian, #haskell.es, #haskell.se, #haskell.it, #perl6, #darcs, #haskell_ru, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-
07:40:22 <lambdabot> blah, #haskell and #Haskell.se
07:40:27 <vincenz> ricky_clarkson: you're in ruby-lang, no?
07:40:28 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
07:40:46 <vincenz> Itkovian: sounds good
07:40:48 <joelr1> oops
07:40:51 <joelr1> foot in mouth!
07:41:23 <greenrd> Philippa: Well, yes, he clarified that later ("you can base it on law, morals, whatever"). But I think it would be more usual for contracts to represent reality, not laws. Well, I have a database background.
07:41:28 <vincenz> Itkovian: Do you have a guestimate on the number of people that will attend?  Maybe I should book a meeting room so I Can give a small presentation instead of just doing it at my desk
07:42:03 <Philippa> greenrd: quite. Me, I'd deduct marks from anyone whose gender field was isomorphic to a boolean...
07:42:07 <greenrd> hehe
07:42:35 <vincenz> Itkovian: ping
07:43:02 <vincenz> @msg Itkovian Do you have a guestimate on the number of people that will attend?  Maybe I should book a meeting room so I Can give a small presentation instead of just doing it at my desk.  Additionally, did you get a chance to read my ICME paper to have an overview of the framework?
07:43:09 <Philippa> there're cases where the contracts represent rules because the contracts're there to enforce the rules - they're just not things that happen when modelling the real world
07:43:18 <vincenz> @bot
07:43:19 <lambdabot> :)
07:43:39 <Philippa> otherwise, you're in deep shit when someone discovers that just as Newton's laws were a first order approximation, Einstein's were a second order one
07:44:26 <Itkovian> vincenz: Koen is interested, and he suggested perhaps Lieven and boegel should attend too
07:44:46 <Itkovian> I've still have to talk to them though, although I thought boegel definitely was interested
07:44:57 * vincenz nods
07:45:02 <vincenz> Lieven ==  ?
07:45:45 <greenrd> Philippa: yeah, most systems probably assume that time "flows at the same rate for everyone", contra special relativity - that'll probably have to be revised when we start colonising other star systems ;)
07:50:51 <mahogny> dcoutts, dcoutts_: ping
07:51:04 <dcoutts_> mahogny, pong
07:51:20 <mahogny> dcoutts_: I got refered to you. gtk2hs expert? :)
07:51:31 <dcoutts_> aye
07:51:32 * xerox nods
07:51:45 <mahogny> ok. I was looking at the example for concurrency
07:51:49 * dcoutts_ is one of the Gtk2Hs maintainers
07:51:49 <Philippa> greenrd: here, have an epsilon :-)
07:51:53 <mahogny> and no matter how I look at it, it looks hackish
07:51:58 <dcoutts_> mahogny, yep
07:52:04 <mahogny> has anyone tried to fix it? otherwise I think I can do it
07:52:12 <mahogny> in that case, I might even give some code for it
07:52:29 <dcoutts_> mahogny, it needs quite a bit of thought and possibly low level hacking
07:52:39 <dcoutts_> mahogny, did you read the FAQ about it on the website?
07:52:44 <mahogny> yes
07:52:48 <mahogny> and... me no like
07:53:00 <mahogny> anyhow, I am gonna try to fix it using the socket listening feature of GTK
07:53:21 <mahogny> I haven't checked if you have made it available for haskell use, otherwise I guess I will have to fix it
07:53:28 <dcoutts_> it is available
07:53:34 <mahogny> ok, perfect
07:53:54 <dcoutts_> that's not a general solution though
07:54:19 <mahogny> well, at least it gives a mutex so you obtain thread safety. to some degree
07:54:26 <dcoutts_> it solves the problem in a different hackish way for programs that just need to listen on a socket, eg an irc client
07:54:46 <dcoutts_> I don't think there are any OS threading problems
07:55:12 <mahogny> no? I thought GTK lacked thread safety?
07:55:19 <dcoutts_> so long as all Haskell threads using the GUI are scheduled on the same OS thread that initialised Gtk
07:55:49 <dcoutts_> which is true if you're not using the threaded rts
07:56:17 <dcoutts_> with the threaded rts as it currently stands we're in trouble
07:56:28 <mahogny> well, I might need to squeeze out all the performance there is, but on the other hand I don't like to poll like a freak either
07:56:50 <mahogny> so if I can get rid of the polling while still having good response time, then I'm happy
07:57:00 <dcoutts_> another trick I use is instead of using threads to use idle handlers
07:57:14 <dcoutts_> eg a sim that needs to do a lot of work but keep the GUI responsive
07:57:29 <dcoutts_> if the work can be cut up into short slices then it can be run from an idle handler
07:57:32 <mahogny> that works I guess. that's how I ended up doing it with wx earlier. hm
07:57:40 <mahogny> yeah, maybe I try that first
07:57:53 <dcoutts_> I've got some example code that does that
07:58:02 <dcoutts_> the ant sim from ICFP'04
07:58:20 <mahogny> but still, you think there are any problems with my other approach of using sockets to obtain mutex on the gtk handler for fully threaded concurrency?
07:58:40 <dmhouse> > "monads" > "OOP"
07:58:41 <lambdabot>  True
07:58:48 <mahogny> :)
07:59:05 <dcoutts_> mahogny, gtk itself provdes a lock/unlock operation which you can use when using multiple OS threads.
07:59:22 <dcoutts_> mahogny, however you're, much better off avoiding multiple OS threads anyway
07:59:28 <dcoutts_> stick to Haskell threads
07:59:29 <mahogny> prolly
07:59:33 <dcoutts_> they perform better too
08:00:10 <dcoutts_> if you really need the input thing, see inputAdd
08:00:22 <mahogny> oh well, I know enough to get to work then :) thanks
08:00:34 <dcoutts_> someone used that to write an IRC client without using threads
08:01:17 <dcoutts_> mahogny, what are you writing btw?
08:01:55 <mahogny> dcoutts_: I'm throwing out wxhaskell from a simulator of the prebiotic evolution
08:02:00 <mahogny> -the
08:02:35 <dcoutts_> mahogny, well I'm always looking for more screenshots to stick on the Gtk2Hs website :-)
08:02:49 <dcoutts_> http://haskell.org/gtk2hs/archives/category/screenshots/
08:02:50 <lambdabot> Title: Gtk2Hs » Screenshots
08:03:20 <mahogny> dcoutts_: ok :)
08:03:47 <mahogny> dcoutts_: will prolly port another irc client later on as well. if I get time
08:03:55 <dcoutts_> mahogny, that'll make 5 :-)
08:04:16 <mahogny> dcoutts_: bah. there gotta be more programs out there using gtk2hs :)
08:04:42 <mahogny> dcoutts_: got any statistics how many?
08:04:43 <dcoutts_> there are a few, I should go chase down the authors and pester them for screenshots
08:05:05 <dcoutts_> no stats as such
08:05:22 <mahogny> dcoutts_: you know, there are some scripts where the user can add links. you could use it to at least find the pages of such projects
08:05:37 <mahogny> a link is easy to add. screenshots are a bit more work :)
08:05:41 <dcoutts_> true
08:06:15 <dcoutts_> we should get our PR man on the case :-)
08:06:28 <mahogny> hmmm. who's that? :)
08:06:52 <dcoutts_> well me mostly :-) and gour helped us set up the new website
08:15:22 <dmhouse> xerox: pingerific :) Still playing with Gobby?
08:18:44 <vincenz> @seen dons
08:18:45 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 38 minutes and 47 seconds ago.
08:18:52 <xerox> dmhouse: I have not built it yet
08:19:02 <dmhouse> xerox: Woah, really?
08:19:12 <dmhouse> xerox: You're not a Gentoo user, are you?
08:19:18 <xerox> Got carried away by other things
08:19:21 <xerox> No :-)
08:19:54 * dmhouse starts hacking on ebby
08:20:57 <ozone> vincenz: it's 1am here, so he's likely asleep
08:21:35 <vincenz> ozone: okies
09:15:02 <malcolm> Anyone here planning on attending ICFP? booking the hotel on-line seems to be a no-go
09:16:55 * Lemmih will attend.
09:16:55 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
09:22:11 <malcolm> Lemmih: managed to book the hotel yet?
09:22:54 <Lemmih> malcolm: Nope.
09:29:18 <lispy> lol, joelonsoftware: "For some reason most people seem to be born without the part of the brain that understands pointers."
09:30:45 <shapr> malcolm: I think MSR is booking for us?
09:30:49 <shapr> oh duh
09:30:50 <shapr> ICFP
09:30:52 * shapr smacks self
09:31:05 * malcolm joins in smacking shapr
09:32:50 * vincenz does as well
09:33:13 <malcolm> gotta stop that boinging somehow :-)
09:33:15 <vincenz> it's a smack-the-shapr fest!
09:33:26 * shapr boings very quietly
09:33:35 <gaal> can I construct a list of elements of different types if they happen to all be instances of the same typeclass?
09:33:43 * vincenz zoofs
09:34:00 <shapr> gaal: yeah...
09:34:05 <gaal> or some other order-preserving structure
09:34:11 <shapr> But I forget exactly how.
09:34:49 <gaal> you wanted to write it down but the margins were too small? :)
09:34:57 * shapr laughs
09:35:00 <vincenz> [forall a. (Class a) => a]
09:35:09 <malcolm> data Wrap = forall a . MyClass a => Wrap a
09:35:20 <malcolm> list :: [Wrap]
09:35:52 <vincenz> bad idea
09:35:55 <vincenz> that wil have no methods
09:36:19 <malcolm> huh?
09:36:42 <sjanssen> can you do: newtype Wrap = forall a . MyClass a => Wrap a deriving MyClass
09:36:51 <sjanssen> with -fglasgow-exts, of course
09:36:53 <vincenz> sjanssen: you can only derive specific clacsses
09:36:56 <vincenz> afaik
09:37:08 <gaal> I'll explain what I'm doing: I'm metaprogramming a little with DrIFT, creating methods that at first take looked like this:
09:37:16 <sjanssen> vincenz: -fglasgow-exts has extended deriving for newtypes
09:37:16 <malcolm> you can derive any class for a newtype (with -fglasgow-exts)
09:37:50 <vincenz> sjanssen: ah interesting
09:38:13 <gaal> asSometing (Cons1 aa ab ac) = "new(" ++ (showSm aa) ++ (showSm ab) ++ (showSm ac) ++ ")"
09:38:26 <gaal> well, that with commas between the variables
09:38:37 <vincenz> > [1, "String"] :: [forall a. (Eq a) => a]
09:38:37 <lambdabot>  Parse error
09:38:43 <vincenz> damn
09:38:45 <sjanssen> ah, newtypes can't have existentials in them
09:38:47 <gaal> now I'm handling this for different constructors, so I wanted to do:
09:38:47 <sjanssen> which makes sense
09:39:28 <gaal> asSometing (Cons1 aa ab ac) = "new(" ++ (intersperse ", " $ map showSm [aa, ab, ac]) ++ ")"
09:39:48 <gaal> where showSm is a method in a class I know all my various fields are instances of.
09:39:54 <kpreid> I like calling the existential for class Foo AnyFoo
09:40:14 <gaal> perhaps I'm better off leaving it as it was?
09:40:43 <malcolm> asSometing (Cons1 aa ab ac) = "new(" ++ (intersperse ", " [showSm aa, showSm ab, showSm ac]) ++ ")"
09:41:01 <gaal> well, that works too :)
09:41:23 <dmhouse> Are the aa, ab, ac different types?
09:41:27 <gaal> yes.
09:41:30 <gaal> well, probably.
09:41:43 <gaal> it works for various types.
09:41:58 <dmhouse> Then I'd use malcolm's method.
09:42:13 <dmhouse> You _could_ do something like:
09:42:16 <gaal> yes, it is an improvement
09:42:47 <dmhouse> newtype YourClassHider = forall a. YourClass a => YCH a
09:43:02 <sjanssen> dmhouse: no existentials in newtypes
09:43:07 <dmhouse> Fine, data.
09:43:50 <gaal> that's been suggested... how is it used?
09:43:50 <dmhouse> map showSm' [YCH aa, YCH ab, YCH ac]
09:44:00 <dmhouse> showSm' (YCH x) = showSm x
09:44:32 <sjanssen> you can even instance YourClass YourClassHider to avoid showSm'
09:44:40 <dmhouse> Right.
09:44:54 <gaal> ah. well that does lift the show, but it puts something else in its stead...
09:45:00 <dmhouse> instance YourClass YourClassHider where showSM (YCH x) = showSM x
09:45:06 <kpreid> gaal: that can never be avoided
09:45:22 <dmhouse> gaal: You simply can't have a polymorphic list, I'm afraid.
09:45:36 <gaal> okay, thanks all
09:46:08 <kpreid> > let x:::xs = show x : xs in 1 ::: "2" ::: 3.0
09:46:13 <lambdabot>  Not in scope: data constructor `:::'
09:46:22 * dmhouse still thinks malcolm's is the best method.
09:46:27 <kpreid> > let x-:xs = show x : xs in 1 -: "2" -: 3.0
09:46:28 <lambdabot>  Couldn't match `String' against `Char'
09:46:41 <dmhouse> kpreid: fixity?
09:46:45 <kpreid> > let x -: xs = show x : xs in 1 -: ("2" -: 3.0)
09:46:46 <lambdabot>  add an instance declaration for (Fractional [String])
09:46:55 <mikael> lambdabot: HList?
09:46:58 <kpreid> > let x -: xs = show x : xs in 1 -: ("2" -: (3.0 -: []))
09:46:59 <lambdabot>  ["1","\"2\"","3.0"]
09:47:17 <mikael> okay, http://homepages.cwi.nl/~ralf/HList/
09:47:19 <dmhouse> Perfect. :)
09:47:20 <lambdabot> Title: Strongly typed heterogeneous collections
09:47:26 <sjanssen> @where hlist
09:47:26 <lambdabot> http://homepages.cwi.nl/~ralf/hlist/
09:47:32 <kpreid> now all you need is a way to define your own [] variants given a : variant :)
09:47:41 <dmhouse> Or do it the Lisp way, (1, ("2", (3.0, [])))
09:50:45 <shapr> Wow, after I posted the Haskell Jazz Improv paper on my blog, it showed up a bunch of times on del.icio.us
09:51:25 <dmhouse> I hate SPJ's emails. He never quotes, and often writes in bright blue.
09:51:43 * shapr grins
09:53:58 * malcolm reckons you can blame Outlook for most bad email habits
09:54:25 * sieni reckons one can blame crack smoking for most bad email habits
09:55:06 * dylan reckons one can blame Outlook on crack smoking habits.
09:55:33 * sieni also reckons one can blame crack smokers for Outlook
10:12:45 * SamB wonders why you don't get anything for doing "rm advise"
10:23:00 <samason> would anyone have a suggestion about interleaving IO calls in a parsec parser?
10:23:28 <Philippa> does the parsing itself depend on the IO, or just the results of parsing?
10:23:49 <tennin> Wait, Haskell jazz improv?
10:24:25 <tennin> (double take...)
10:25:00 <samason> Philippa: the parsing itself depends on doing IO
10:27:19 <Philippa> samason: ow. Not sure, I suspect the recommended method for #includes is to cheat blatantly...
10:27:37 <Philippa> this is why some people're thinking about writing a ParsecT that provides a monad transformer version, btw
10:28:14 <samason> I guess I shouldn't be using a parser as it could need to backtrack and that could do bad things
10:28:21 <Cale> yeah
10:28:35 <Cale> probably better to do whatever you're doing in multiple stages
10:29:40 <vincenz> in 3
10:29:42 <vincenz> 3 is the magic number
10:30:02 <Cale> heh
10:30:16 <samason> :)   bah, who designed the imap protocol
10:30:24 <Cale> Is vincenz the next palomer? :)
10:31:03 <sjanssen> @vincenz
10:31:04 <lambdabot> Unknown command, try @list
10:32:48 <shapr> Whoa, I think the bayesian surprise paper and the jazz improv paper are connected.
10:39:40 <Philippa> samason: the trick for protocols is to call one smallish parser with a pre-set state to munch each message
10:39:58 <Philippa> admittedly I've not tried it with overly complex protocols, but it works a treat with something like IRC
10:40:19 <Philippa> just don't try to do everything in one big lazy parse step and it'll be fine
10:40:55 <xerox> Do you organize your papers in a hierarchy?
10:41:10 <shapr> Nah, I have them all in a single dir.
10:41:19 * vincenz winces
10:41:23 <vincenz> I have > 1000 papers
10:41:23 <Philippa> I put references to papers in a hierarchy, the papers themselves're in the single dir with subdirs containing said references
10:41:24 <vincenz> I could never do that
10:41:26 <shapr> I really want to finish FLM, it'll let me handle the mass.
10:41:31 <vincenz> I want to reorganize them with multitagging tho
10:41:40 <shapr> I do rename each paper to the full title.
10:41:56 <shapr> That way I don't have seventy files name paper.ps and thesis.ps
10:41:58 <xerox> shapr: do you include authors in the name?
10:41:59 <Philippa> yeah, I should do that. I do it with some of the shortcuts
10:42:01 <shapr> Nope
10:42:12 <xerox> Me too, I just finished with the collection I got on this computer.
10:42:12 <shapr> I'd like to switch to using DOI in FLM.
10:42:34 <Philippa> I figure it'd be easier to have a byName folder with per-author subfolders
10:42:34 <xerox> Well, one nice thing is that Spotlight can search _inside_ the PDF.
10:42:55 <Philippa> of course, the problem there is what gets to be byValue
10:43:04 <Philippa> byNeed should really be maintained by a script...
10:44:31 <shapr> I had no idea Jazz was so central to the study of improvisation.
10:45:47 <Philippa> it's more that the reverse is the case and hasn't been to anywhere near the same extent in pretty much any other style
10:47:42 <xerox> shapr: want to try Emacs' make-new-frame-on-display ?
10:48:47 <dcoutts_> g'evening ndm
10:49:03 <kowey> got a practical GADT question here... http://www.haskell.org/haskellwiki/Talk:Generalised_algebraic_datatype
10:49:04 <lambdabot> Title: Talk:Generalised algebraic datatype - HaskellWiki
10:49:09 <ndm> good evening dcoutts_, i saw you jumping to my defence on haskell-cafe earlier :)
10:49:10 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:49:24 <dcoutts_> ndm, aye :-)
10:49:37 <ndm> ah, have seen the @tell's as well now
10:49:42 <dcoutts_> heh
10:49:59 <dcoutts_> it's somewhat of a case of worse is better
10:50:12 <ndm> well hopefully its getting towards the end of the comments now
10:50:28 <ndm> i don't think anyone has a small problem with teh semantics
10:50:44 <dcoutts_> they only big problems with the semantics :-)
10:50:46 <ndm> everyone either agrees, or disagrees largelly enough that its not worth changing to meet them
10:50:51 <dcoutts_> indeed
10:51:01 <dcoutts_> they have different needs
10:51:04 <dcoutts_> eg security
10:51:10 <dcoutts_> "known good paths"
10:51:13 <ndm> yeah
10:51:34 <ndm> it would be nice though if there was class FilePathLike a where getFilePath :: a -> String
10:51:47 <ndm> and then written all FilePath things like readFile/writeFile in terms of FilePathLike
10:51:57 <ndm> then they can write their own library, and be perfectly happy :)
10:52:17 <dcoutts_> heh
10:52:28 <Philippa> yes, that'd be a good idea
10:53:09 <dcoutts_> it's actually a very complex problem as the semantics vary subtly across platforms in annoying ways
10:53:24 <dcoutts_> and indeed even within a platform depending on the FS
10:53:24 <ndm> yes, the quick check properties really brought out loads of little things
10:53:39 <shapr> Wow, Haskore Autotrack...
10:53:41 <dcoutts_> eg ext2 vs CIFS vs NFS vs FAT etc etc
10:54:03 <ndm> yeah, its annoying
10:54:33 <ndm> I really wish MS had just gone with Unix file paths
10:54:37 <dcoutts_> and the file name encoding issue is much worse that most people realise
10:54:48 <dcoutts_> because 99% of the time it works ok
10:55:00 <ndm> i haven't even begun to look in that direction yet, just avoid encodes at all
10:55:12 <dcoutts_> which is the right thing to do mostly
10:55:41 <ndm> i'm glad its a windows user writing this code though, because otherwise I could see Haskell becoming Posix only...
10:55:56 <dcoutts_> does ghc use the ASCII or Unicode file APIs on win32?
10:56:36 <ndm> don't know, just checking...
10:58:02 <ndm> no idea, they look like they are primitives
10:58:33 <ndm> it certainly uses the ASCII versions for some functions
10:59:13 <ndm> I saw this morning that canonicalizePath is not implemented on Hugs, only GHC, which annoyed me
10:59:28 <ndm> seems someone just wanted a function, so added it to GHC (less work), and ignored it for other compilers
10:59:35 <dcoutts_> aye, lazy
11:00:02 <ricky_clarkson> shapr: I'm not into those languages, but I'm open minded.
11:00:51 <ricky_clarkson> shapr: I'm more into concepts atm - I haven't yet come across a language that I am satisfied with.  Part of me hopes I never do.
11:01:17 <ricky_clarkson> Philippa: I'm not sure what you were talking about.
11:01:29 <ricky_clarkson> vincenz: Not in ruby-lang, ##java.
11:01:39 * ricky_clarkson finished his /lastlog, as you were.
11:02:24 * vincenz nods
11:02:33 <vincenz> (re from #oasis) personally I think it shows of bad taste to criticize something people had put so much effort in it.  If you don't like it, don't participate, it's not a paid for service.  And otherwise, shut the hell up
11:02:50 <vincenz> not to mention it's not even constructive criticism
11:05:23 <Cale> what's going on?
11:05:42 <ricky_clarkson> I was in a bookshop and almost all I could see was C#, Java and ASP/PHP/etcetera books.  I eventually settled on flicking through a Python book over a coffee, but it wasn't satisfactory.
11:06:08 <ricky_clarkson> You FP types need some shelf space.
11:06:41 <xerox> I think I heard Cale wanting to write a book!
11:06:51 <Cale> Yeah, I might write a book at some point.
11:06:52 <shapr> We have shelf space. Check out the nearest university library :-)
11:07:23 <Philippa> hah
11:07:30 <ndm> shapr, still WAY more Java books
11:07:32 <Cale> I never really had all that much trouble finding stuff online though.
11:07:33 <Philippa> UoN's libraries tend not to have the books I actually want
11:07:36 <ricky_clarkson> I don't go in those, even though I work in a University.
11:08:07 <ricky_clarkson> They don't typically embed coffee shops.
11:08:35 <Cale> But I'm the sort of person who downloads digital copies of books that he already has so that he can read them on screen. :)
11:08:41 <shapr> Me too.
11:08:55 <vincenz> Cale: some guy criticizinig (destructively) the very contest he partook in
11:08:59 <shapr> Since my Nokia 770 holds *many* books and fits nicely into my shirt pocket.
11:09:08 <Cale> oh?
11:09:09 <Cale> why?
11:09:12 <xerox> Some people can't read on the screen, I do it all the time!
11:09:16 <vincenz> Cale: check ML :)
11:09:22 <Cale> vincenz: what's the criticism?
11:09:29 <vincenz> Cale: "it's not like last year"
11:09:44 <Cale> what was the contest this year?
11:09:50 <vincenz> FUN!
11:09:53 <dmhouse> Craaazy.
11:09:54 <Cale> Simulating turing machines?
11:10:14 <Cale> I haven't read it carefully
11:10:26 <dmhouse> Way more than that.
11:10:39 <dmhouse> Once you finished the VM and ran it through the input, you got this operating-system type thing.
11:10:40 <xerox> Once you got UMIX the real contest started :-)
11:10:49 <vincenz> yeah
11:10:51 <vincenz> \o/
11:10:53 <Cale> UMIX?
11:10:57 <vincenz> UMIX!
11:10:58 <dmhouse> There were loads of minipuzzles, and different levels of solved-ness got you different points.
11:11:04 <dmhouse> Cale: The OS that gets spat out.
11:11:15 <xerox> It's a joke on `Universal Machine' and UNIX.
11:11:34 <shapr> Has anyone tried the Haskell Ajax lib?
11:11:43 <xerox> Not much of a joke in fact, the CMU people did some terrific work, I believe.
11:12:01 <Lemmih> shapr: The SoC HSP thingy?
11:12:07 <shapr> Yeah
11:13:12 <vincenz> xerox: you subscribed to ML?
11:13:20 <xerox> Nope.
11:13:29 <Cale> vincenz: what do you mean check ML?
11:13:45 <vincenz> mailing list
11:13:54 <Cale> the haskell mailing list?
11:13:59 <vincenz> icfp-discuss
11:14:04 <Cale> oh
11:14:27 <vincenz> http://lists.andrew.cmu.edu/pipermail/icfpcontest-discuss/Week-of-Mon-20060724/000664.html
11:14:28 <lambdabot> Title: [icfp-discuss] Grats to the organizers
11:14:36 <Lemmih> shapr: There isn't much Ajax over it, imho.
11:15:56 <shapr> Lemmih: Any idea how it works?
11:17:06 <shapr> Oh, I found the example.
11:17:37 <shapr> Oh, I think I like this.
11:17:59 <xerox> Do you know of any command-line utility to play wav files?
11:18:05 <shapr> aplay
11:18:10 <shapr> Part of alsa
11:19:02 <xerox> Hmmm, can't have it on OS X.
11:19:05 <xerox> Anything else?
11:19:12 <Lemmih> mplayer
11:19:38 <dmhouse> mplayer is a bit overkillish if you just want to play WAVs :)
11:19:56 <xerox> Yep; thanks, by the way.
11:20:02 <dmhouse> But probably worth having around anyway.
11:20:11 <pejo> xerox, can't you just "open file.wav" and whatever player you have will play it?
11:20:15 <vincenz> dmhouse: cat *.wav > /dev/dsp?
11:20:18 <shapr> Lemmih: It looks cute, HSP automatically generates the code to call a server side cgi via XmlHttpRequest.
11:20:30 <dmhouse> vincenz: s/dmhouse/xerox/.
11:20:31 <xerox> pejo - I'd like something more discrete.
11:20:38 <Lemmih> shapr: URL?
11:20:45 <xerox> vincenz: no :(
11:20:47 <shapr> http://csmisc14.cs.chalmers.se/~bjornson/soc/
11:20:48 <lambdabot> Title: HSP.Clientside
11:20:48 <vincenz> dmhouse: you said mplayer was overkill
11:20:54 <shapr> Look at the example.
11:21:06 <dmhouse> vincenz: Yes, but xerox was the one looking for solutions.
11:23:24 <ndm> hmm, i am considering using Ajax for the next version of hoogle...
11:23:33 <ndm> wonder if that might be a good option
11:23:47 <Cale> So what was the idea of the contest?
11:23:50 <dmhouse> As long as you use lots of pastel colours and very big text.
11:24:13 <Cale> Write a just in time optimiser for the UM language just to get it to run decently fast?
11:24:31 <ndm> dmhouse: are you refering to my FilePath stuff?
11:24:51 <dmhouse> ndm: With what?
11:24:53 <xerox> Cale, no, I think the point is solving the puzzles.
11:25:01 <ndm> the pastel colours and big text
11:25:09 <Cale> I see a lot of postings on the mailing list of people complaining that they can't get the UM running quickly in C :)
11:25:17 <dmhouse> ndm: Oh, no, that was a Web 2.0 joke. Never mind. :)
11:25:26 <ndm> dmhouse: ah, fair enough :)
11:25:34 <dmhouse> Cale: C's really the only thing people _can_ get it running quickly in, too.
11:25:44 <Cale> well, that's stupid :)
11:26:37 <Cale> did anyone write an assembler implementation?
11:27:25 <sjanssen> dmhouse: my Haskell implementation isn't all that slow
11:27:44 <dcoutts_> sjanssen, is the code for your available?
11:27:53 <dmhouse> Cale: one of the teams near the top of the table was called 'You can't spell Awesome with ASM', so I guess so.
11:27:53 <dcoutts_> I was trying to write a fast one yesterday
11:27:59 <dmhouse> sjanssen: How fast?
11:28:31 <sjanssen> dcoutts_, dmhouse: http://www.cse.unsw.edu.au/~dons/um.html
11:28:32 <lambdabot> Title: Haskell UM
11:28:59 <work_metaperl> @seen shapr
11:29:00 <lambdabot> shapr is in #haskell-overflow, #haskell, #ScannedInAvian and #unicycling. I last heard shapr speak 2 minutes and 33 seconds ago.
11:29:02 <shapr> ?
11:29:05 <work_metaperl> hey
11:29:20 <shapr> What can I do for you?
11:29:45 <work_metaperl> I was going to go private
11:29:55 <shapr> ok
11:30:35 <dcoutts_> sjanssen, ah so you use a free list, I was thinking of doing that
11:30:53 <sjanssen> dcoutts_: that's where the speed up comes from
11:31:00 <dcoutts_> I can believe it
11:31:06 <sjanssen> free list and not reallocating small arrays
11:31:17 <dcoutts_> ah, interesting
11:32:36 <Cale> Did anyone write a proper compiler?
11:32:42 <vincenz> for?
11:32:45 <Cale> um
11:32:50 <dcoutts_> I see, so when taking something off the free list you check if the bounds satisfy the current request
11:33:00 <vincenz> Cale: oy, the name for that has to be horrible
11:33:08 <sjanssen> dcoutts_: yep
11:33:16 <vincenz> Cale: I have an assembler from a frenchc guy
11:33:17 <vincenz> with labels
11:33:22 <sjanssen> and I only deallocate largish arrays
11:33:26 <dcoutts_> right
11:34:25 <vincenz> sjanssen: me too
11:34:31 <vincenz> sjanssen: and I preallocate 10000 arrays
11:34:43 <vincenz> it's only 6MB top footprint for sandmark :)
11:35:16 <sjanssen> mine eats up quite a bit of memory eventually
11:35:18 <vincenz> vector<vector<value> > environment;
11:35:23 <vincenz> environment.reserver(10000);
11:35:52 <sjanssen> I double the size of the allocation pool when I run out of ids -- I should probably change to Fibonacci or something
11:35:55 <vincenz> (cause reallocation of environment causes all the subarrays to be copied unless the compiler is really smart)
11:36:02 <mikael> I want to read some writeups about the contest
11:36:05 <vincenz> sjanssen: how can you run out of ids?
11:36:07 <mikael> wait, is it even over yet?
11:36:12 <vincenz> sjanssen: I use a list of free spots
11:36:16 <vincenz> list<value> freelist;
11:36:42 <sjanssen> vincenz: yeah, I also have a IOArray Int (IOUArray Int Word32)
11:37:08 <sjanssen> so when all the arrays in that are being used, I double it's size and add those to the freelist
11:37:20 * vincenz nods
11:41:14 <vincenz> Cale: if you want to play with the system, dons put up a few um implementations
11:41:46 <vincenz> http://www.cse.unsw.edu.au/~dons/um.html
11:41:47 <lambdabot> Title: Haskell UM
11:45:41 <petekaz> so some of the haskellers weren't using haskell for the contest?
11:46:06 <xerox> You got to use all the tools you can!
11:46:10 <dmhouse> petekaz: Nah, they wrote mostly Haskell, then C for the UMs.
11:46:20 <petekaz> I see.
11:46:28 <mikael> is there any document anywhere that talks about what goes on once you've written the UM?
11:46:49 <dmhouse> mikael: Did you run the input you're given?
11:47:09 <mikael> no, I didn't write a UM.  I'm just curious
11:47:21 <Cale> I think I'd be too disinterested in writing a fast UM to do the rest of the contest.
11:48:17 <Cale> by the sounds of it, at least
11:48:30 <shapr> Oh hey, I just thought of way to get all of the IM2000 anti-spam features without only a minor change to existing protocols.
11:48:33 <shapr> hm!
11:49:36 <shapr> What if you fetched an email via DNS?
11:49:37 <mikael> yeah, that's how I felt.  the contest spec should have had *some* indication of what the rest was about, I think
11:50:51 <int-e> heh. I liked the mystery.
11:56:13 <kpreid> any lambdabot hackers around? I need an opinion
11:56:46 <shapr> kpreid: yes?
11:57:31 <kpreid> I want the Dummy plugin without the #haskell-specific stuff; particularly @id. What should I do to make my patches least messy?
11:57:45 <kpreid> I've thought of moving @id to the Compose plugin.
11:58:17 <kpreid> Or deleting the stuff I don't want in Dummy.
11:59:25 <kpreid> by "least messy" I mean having the minimum of local changes that won't go into the regular lambdabot repository
12:00:18 <dmhouse> kpreid: Perhaps just remove those commands from the instance declaration for Dummy.
12:00:52 <kpreid> dmhouse: filter dummylst?
12:01:17 <dmhouse> kpreid: Yeah. Comment them out.
12:02:35 * kpreid fails to think of exactly what's wrong with that
12:04:16 <roconnor> @seen vincenz
12:04:16 <lambdabot> vincenz is in #oasis and #haskell. I last heard vincenz speak 17 minutes and 5 seconds ago.
12:14:36 <kpreid> dmhouse/shapr: I modified Dummy.hs, put Dummy back in Modules.hs, and did ./build, but Dummy isn't enabled; what do I need to rebuild?
12:16:24 <vincenz> re
12:16:53 <daniel_larsson> Hmm.... if I get link errors like "unknown symbol `DatabaseziHaskellDBziSql_lvl21_closure'", anyone have any idea what kind of problem I might have?
12:17:13 <ihope> Are you using FFI?
12:17:36 <daniel_larsson> Well, I'm using HaskellDB, which I guess is using FFI eventually
12:17:39 <sjanssen> daniel_larsson: you probably need to tell GHC which packages you're using
12:17:45 <sjanssen> or just use --make
12:18:25 <vincenz> roconnor: /
12:18:30 <vincenz> ?
12:21:15 <vincenz> roconnor: ping
12:21:35 <daniel_larsson> Thanks for the help. Turned out I forgot to relink a dependent package
12:24:52 <urz> Setup.lhs: haifa.cabal:22: Parse of field 'extensions' failed:
12:25:06 <urz> do i need to upgrade cabal?
12:38:15 <syntaxfree> @where hope
12:38:16 <lambdabot> http://hope.bringert.net/
12:38:22 <syntaxfree> there's still hope!
12:38:51 <urz> is cabal 1.1.4 not backward compatible with cabal 1.0 ?
12:38:51 <vincenz> no there's not
12:39:19 <syntaxfree> It's mildly annoying that every Haskell package is downloadable only via darcs.
12:39:35 <syntaxfree> I eventually got darcs to manage my thesis, but still.
12:40:29 <urz> there should be a package manager that just gets the stuff for us
12:40:38 <urz> like perl has
12:41:04 <syntaxfree> well, that can easily evolve from darcs. I don't think there are enough packages for GHC to warrant that.
12:41:13 <syntaxfree> But, c'mon, occasionaly uploading .tar.gz files is common courtesy.
12:42:09 <sieni> I don't think using darcs to get packages is much more difficult than to wget a tgz an tar xvfz:ing it.
12:42:21 <syntaxfree> You have to have darcs in first place.
12:42:31 <syntaxfree> I refused to until I had an use for it.
12:42:35 <syntaxfree> I wonder if wordpress.com allows hosting of large files.
12:42:50 <syntaxfree> I could host .tar.gz files of popular Haskell packages/modules/whatever there.
12:43:33 <syntaxfree> Data.Byte.String looks cool.
12:43:50 <syntaxfree> It's a list interface to arrays, right?
12:43:52 <dmhouse> You mean Data.ByteString?
12:44:02 <syntaxfree> that, too :)
12:44:04 <kosmikus> syntaxfree: you're absolutely right. packages should be properly released and distributed as tarballs / zip-files / installers ...
12:44:38 <dmhouse> syntaxfree: it's an alternative for using [Char] for Strings, which internally is an array of bytes.
12:45:17 <syntaxfree> kosmikus: if Wordpress.com allows some hosting of files, do you wanna be my partner in a volunteer project with tarballs for Haskell projects?
12:45:21 <urz> [Char] is internally an array of bytes, or Data.Byte.String?
12:45:41 <dmhouse> urz: Data.ByteString.
12:45:46 <dmhouse> (Not Data.Byte.String.)
12:45:53 <dmhouse> Basically, ByteStrings are wicked-fast.
12:46:10 <syntaxfree> well, are head, tail, map,  etc. defined for Data.ByteString?
12:46:14 <dmhouse> Yeah.
12:46:24 <dmhouse> Nearly all functions from Data.List are.
12:46:24 <kosmikus> syntaxfree: sorry, no. I can't currently afford to take on any additional responsibilities.
12:46:32 <sjanssen> ByteStrings pretend to be lists as much as possible
12:46:33 <kosmikus> syntaxfree: you have my full support, however :)
12:46:40 <urz> is there a reason the compiler doesnt just do [Char] as byte arrays?
12:46:41 <syntaxfree> haha.
12:46:57 <kosmikus> syntaxfree: on the other hand, I really think that package developers should release their software properly
12:46:57 <syntaxfree> I don't wanna take that project all alone because I'm a little out of the loop in Haskell packages.
12:47:10 <kosmikus> that's more than just providing a random snapshot tarball
12:47:23 <dmhouse> syntaxfree: I don't think wordpress.com would be the best place for a Haskell distribution centre.
12:47:24 <sjanssen> urz: what would happen when you send [Char] to a function that takes [a]
12:47:24 <kosmikus> it's declaring a certain version as a stable frame of reference
12:47:51 <syntaxfree> dmhouse I don't want to dick around with building a website.
12:48:15 <syntaxfree> yeah, is there a reason the compiler doesnt just do [Char] as byte arrays?
12:48:16 <dmhouse> syntaxfree: download WordPress, upload it, ta-da! I just think going with the free option is abusing wordpress.com a bit.
12:48:22 <urz> sjanssen: i guess a byte-array version of the function would be generated
12:48:31 <dmhouse> syntaxfree: ByteStrings are quite new stuff, they've only really come through in the last year.
12:49:51 <syntaxfree> I'm frying to install Data.ByteString
12:50:00 <syntaxfree> I got the darcs package as recommended.
12:50:07 <syntaxfree> but my Setup.hs is an empty file.
12:50:14 <dcoutts_> hmm
12:50:25 <sjanssen> urz: specializing containers based on what they contain is an optimization that GHC doesn't do.  I have a feeling it might be difficult
12:51:14 * syntaxfree eventually wants to build a local copy of Hope and play around with the possibility of ditching PHP forever.
12:51:22 <syntaxfree> Anyone here has some experience with Hope?
12:51:25 <shapr> me me!
12:51:34 <syntaxfree> it runs as CGI, right?
12:51:38 <shapr> or FastCGI
12:52:01 <syntaxfree> so, um, I'm gonna need to compile stuff on a separate (Linux) machine, as I run OS X.
12:52:14 <syntaxfree> I mean, to get them to work on a webhost.
12:52:14 <shapr> Why?
12:52:16 <shapr> Oh
12:52:21 <dmhouse> Could someone just whip me up factorial() in C?
12:52:27 <syntaxfree> I can't really serve files from my Mac.
12:52:45 <syntaxfree> Anyway. Is a typical Hope application contained within one executable?
12:53:10 <dmhouse> Would it be int factorial(int n) { int res; for (i = 1; i <= n; i++) { res *= i; }; return res; }
12:53:12 <sjanssen> int factorial(int n){int acc = 1; for(int i = 1; i <= n; i++) acc *= i; return acc;}
12:53:24 <dmhouse> Cool, thanks.
12:53:46 <sjanssen> > product [1..10]
12:53:46 <syntaxfree> There are exact analytical formulas for arbitrary factorials.
12:53:47 <lambdabot>  3628800
12:53:50 <sjanssen> much better
12:53:54 <syntaxfree> look up the Gamma function.
12:54:07 <syntaxfree> on mathworld.wolfram.com or something.
12:54:24 <dmhouse> syntaxfree: Right, but not so helpful when you're giving an example, trying to explain how you use recursion instead of loops in Haskell. :)
12:54:39 <dcoutts_> syntaxfree, you got fps from the normal place?
12:54:41 <dcoutts_> @where fps
12:54:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
12:54:50 <syntaxfree> You're trying to teach Haskell to C programmers?
12:54:59 <dmhouse> syntaxfree: (fps is the old name for ByteString.)
12:55:16 <syntaxfree> yes, yes. That's where I'm getting it from.
12:55:18 <dmhouse> syntaxfree: Not necessarily, but a lot of the people reading the wikibook could be old C programmers.
12:55:23 <shapr> xerox: Is cabal-get ready for beta testing?
12:55:25 <vincenz> wikibook?
12:55:34 <syntaxfree> I'd suggest writing for Scheme programers.
12:55:39 <shapr> xerox: I really want to put in the Hope packages.
12:55:46 <syntaxfree> Many introductory IT courses are taught in Scheme nowadays.
12:55:47 <urz> i can't get the haifa package to install
12:55:57 <urz> i get a parse error when i tell Setup.lhs to configure
12:56:09 <syntaxfree> And then there's a cultural shock when you move to "real-world" programming and no longer have functional programming.
12:56:18 <syntaxfree> Haskell is the ideal solution for those disillusioned.
12:56:21 <urz> it complains about "extensions:" in the .cabal file
12:56:27 <syntaxfree> In fact, it's the ideal market opportunity for Haskell.
12:56:50 <dmhouse> syntaxfree: The wikibook is aimed at people that have never programmed before, but will hopefully be helpful to everyonge.
12:56:53 <dmhouse> *everyone
12:57:12 <syntaxfree> Haskell and Scheme are ideal first languages.
12:57:15 <vincenz> dcoutts_: wikibook?
12:57:24 <dcoutts_> vincenz, huh?
12:57:34 <vincenz> oh nm
12:57:35 <urz> do i need to learn all about cabal in order to figure out how to install teh package?
12:57:38 * vincenz redirects to dmhouse 
12:57:49 <dcoutts_> @where haifa
12:57:50 <lambdabot> I know nothing about haifa.
12:57:51 <syntaxfree> Academia often chooses Scheme because it's syntax-free, but Haskell is an ideal next step up.
12:57:54 <dmhouse> @where wikibook
12:57:55 <lambdabot> I know nothing about wikibook.
12:57:56 <vincenz> syntaxfree: heh, I did engineering, but EE, scheme was a first year course
12:58:08 <vincenz> tho at that time I didn't know yet I was a coder :D
12:58:09 <dmhouse> @where+ wikibook http://en.wikibooks.org/wiki/Haskell
12:58:10 <lambdabot> Done.
12:58:22 <syntaxfree> I did economics, and we had a Scheme course.
12:58:41 <syntaxfree> In graduate school, we're having an R course.
12:58:52 <lispy> the wiki doesn't have a page on cabal, or am i mistaken?
12:59:07 <syntaxfree> R is nice. It's an ideal Matlab replacement.
12:59:09 <lispy> R is nice for semi-programmer types
12:59:25 <syntaxfree> And it supports proper higher-order functions.
12:59:41 <syntaxfree> R is for the Matlab types, yes.
12:59:47 <dcoutts_> urz, you should need to, no. what version haifa?
12:59:56 <syntaxfree> But it has all sorts of premade tools for advanced econometrics, so it's great.
13:00:23 <dcoutts_> syntaxfree, I did darcs get and I get a normal Setup.hs
13:00:42 <vincenz> dmhouse: lots of work
13:00:42 <syntaxfree> weird. I'm gonna try again.
13:00:48 <syntaxfree> mgf<-function(x){ m<-function (t) {return(mean(exp(t*x)));};}
13:01:00 <syntaxfree> see? Functional programming in GNU R ;)
13:01:16 <dmhouse> vincenz: it's a work in progress. :)
13:01:29 <syntaxfree> x is a vector,  and mgf returns a function.
13:01:31 <lispy> syntaxfree: we encourage our customers to use python and R for statistical calculations (they are traffic engineers)
13:01:41 <syntaxfree> (that calculates the moment-generating function)
13:01:55 <dmhouse> vincenz: Nowhere near complete, it need people like you to contribute! :) Would http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes be to your taste? :)
13:01:58 <dcoutts_> urz, with ghc-6.4.2 and haifa-0.10 the Setup.lhs compiles fine. What versions are you having problems with.
13:02:10 <dmhouse> (No worries if you don't have the time, I know you've got a lot on your plate at the moment.)
13:02:51 <vincenz> maybe after 10sept
13:02:55 <dmhouse> Sure. Any time.
13:03:24 <syntaxfree> shapr: you forgot about my question :(
13:04:21 <urz> dcoutts_: thanks.  ghc-6.4.1 and haifa from darcs (.cabal file says version 0.10)
13:04:46 <syntaxfree> Cool. HaskellDB has a proper release.
13:04:57 <dcoutts_> urz, and it's a parse error? The file looks pretty simple.
13:05:01 <urz> i'm using cabal 1.1.4.  Not the cabal that came with ghc.  I upgraded for another project
13:05:11 <syntaxfree> ah, yes! Data.ByteString came with a proper Setup.hs this time.
13:05:19 <dcoutts_> syntaxfree, oh good
13:05:33 <dcoutts_> urz, 1.1.4 is a good version to have tam
13:05:38 <dcoutts_> tam/atm
13:05:44 <syntaxfree> Now I'm suspecting of darcs.
13:05:58 <syntaxfree> It seems unreliable. Jesus, and to think I'm using it to manage my 150-page thesis.
13:06:17 <dcoutts_> syntaxfree, still got the repo where it didn't work?
13:06:27 <urz> runhaskell Setup.lhs configure
13:06:27 <urz> Setup.lhs: haifa.cabal:22: Parse of field 'extensions' failed:
13:06:46 <syntaxfree> dcoutts: the only one advertised on the official page
13:06:48 <syntaxfree> @where fps
13:06:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
13:06:50 <dcoutts_> urz, ah, a parse error of the .cabal file
13:06:58 <urz> yes, thats what i meant to say
13:07:02 <dcoutts_> syntaxfree, no, I mean the copy you downloaded
13:07:07 <syntaxfree> ah,  no, I deleted it.
13:07:09 <dcoutts_> syntaxfree, try running darcs check on it
13:07:12 <dcoutts_> ah oh well
13:07:29 <urz> is "extensions" something that cabal 1.0 had that 1.1.4 through out?
13:07:50 <dcoutts_> urz, change AllowUndecidableInstances to UndecidableInstances,
13:07:59 <dcoutts_> in the extensions field
13:08:24 <dcoutts_> this bit lots of projects sadly :-(
13:08:37 <dcoutts_> the parser should have been made backwards compatible
13:08:40 <lispy> i created a page for cabal on the wiki, someone else should probably review it and make sure there are no glaring mistakes: http://haskell.org/haskellwiki/Cabal
13:08:42 <lambdabot> Title: Cabal - HaskellWiki
13:09:12 <urz> dcoutts_: i see, it works now. thanks (though i need another package)
13:09:17 <syntaxfree> is the HaskellWiki written in Haskell?
13:09:29 <lispy> syntaxfree: no it's a modified mediawiki
13:09:42 <dcoutts_> lispy, I had no idea building .dlls worked at all
13:09:53 <dcoutts_> the user guide says it doesn't work :-)
13:09:57 <syntaxfree> the old hawiki was MoinMoin?
13:10:05 <dcoutts_> syntaxfree, yeah
13:10:09 <lispy> dcoutts_: but it also says it does work as long as you build a single dll
13:10:16 <syntaxfree> I like MoinMoin wikis better :(
13:10:26 <lispy> dcoutts_: i haven't gotten far enough to test the dll to make sure it's valid :)
13:10:46 <dcoutts_> lispy, hmm, maybe you should before telling everyone it works :-)
13:11:19 <lispy> dcoutts_: perhaps, but if people see this and complain maybe the documentation or implmenetation will be brought in line :)
13:11:21 <dcoutts_> and if/when ghc supports building dlls properly we should add support for that to Cabal
13:11:34 <syntaxfree> GRRR.
13:11:45 <syntaxfree> HaskellDB seems to expect GHC **and** Hugs
13:12:18 <lispy> dcoutts_: but, i think it will work...i mean, reading the ghc documentation they say it should work if you build a single dll and it did build
13:12:22 <lisppaste2> syntaxfree pasted "GRR! GRR!" at http://paste.lisp.org/display/23211
13:12:58 <lispy> dcoutts_: if it doesn't work i'm sort of screwed :)
13:12:59 <dcoutts_> vincenz, I can't reply as this nick is not registered
13:13:15 <dcoutts_> lispy, good luck! :-)
13:13:20 <syntaxfree> Help? :'(
13:13:44 <urz> i need to find syb-generics
13:13:54 <urz> i found a web page all about it but i dont see a download for the package
13:13:54 <vincenz> dcoutts_: oy
13:13:57 <vincenz> dcoutts_: :/
13:14:11 <emertens> I'm screwing around and I'd like to implement Kruskal's algorithm as a learning exercise. to do this I need to implement a disjoint set (union/find) algorithm.  I was wondering if someone could point me at the correct combination of these two techniques because:
13:14:18 <urz> is there some website where all the haskell packages register?
13:14:37 <emertens> I know that the set operations have state, and I know that kruskal's algorithm has state (the disjoint set)
13:14:59 <xerox> shapr: today was too hot to think, I am now working on it
13:15:00 <emertens> (no, this isn't a homework assignment, I'm wasting time at work)
13:15:03 <syntaxfree> I want to build HaskellDB withough Hugs support. Any hints?
13:15:57 <sylvan> emertens, I have a TSP solution using Kruskal complete with a lab report :-)
13:16:07 <sylvan> It's a specialised version of Kruskal though (no branches)
13:16:08 <emertens> sylvan: TSP?
13:16:16 <sylvan> Travelling Salesman Problem
13:16:22 <emertens> ah, duh
13:16:27 <dcoutts_> urz, there's the libraries pages on haskell.org
13:16:40 <emertens> sylvan: could I read it?
13:16:48 <sylvan> yep, hang on..
13:17:03 <emertens> where is teh pastebot?
13:17:40 <vincenz> @paste
13:17:41 <lambdabot> http://paste.lisp.org/new/haskell
13:17:45 <roconnor> vincenz: My teammate implemented a UM Huffman decoder
13:18:20 <lisppaste2> emertens pasted "Prim's" at http://paste.lisp.org/display/23212
13:18:27 <emertens> this was the angle I took with Prim's algorithm
13:18:32 <vincenz> roconnor: neat :)
13:18:41 <emertens> does that look "idiomatic" ?
13:18:43 <lisppaste2> sylvan pasted "TSP a la Kruskal" at http://paste.lisp.org/display/23213
13:19:00 <roconnor> he had written one for another VM, so he figured it would be pretty easy to translate.
13:19:44 <vincenz> yep
13:19:54 <sylvan> basically I use the ST monad
13:19:57 <vincenz> huffman encoder of stdin?
13:20:29 <emertens> sylvan: hopefully ST's purpose will make more sense to me as I review your example
13:20:46 <sylvan> emertens: O(1) mutable arrays in this case
13:21:09 <roconnor> I think the encoder was in C, or some strange scripting language or something
13:21:22 <vincenz> roconnor: ah so how does UM enter the picture
13:21:35 <sylvan> there was a sequence data structure that had O(1) reversions that I used, but I've misplaced it... You could just ignore the Sequence, use a list, and "reverse" instead of "rev", and ++ instead of +++
13:21:54 <roconnor> vincenz: the UM does the decoding
13:22:04 <erider> is there a haskell compiler for palmOS?
13:22:09 <roconnor> vincenz: it make UMZ files
13:22:18 <roconnor> er the C/whatever makes UMZ files
13:22:51 <vincenz> ah
13:23:06 <vincenz> neat :)
13:23:14 <vincenz> ideally that c would also be compiled to umz
13:23:36 <roconnor> so there would be a um encoder as well?
13:23:45 <sylvan> emertens, I have a lab report describing it some detail if you have a way of sending you a PDF
13:23:52 <roconnor> When do we get a UM backend for ghc?
13:24:05 <vincenz> yeah!
13:24:06 <vincenz> ghcucm
13:24:09 <vincenz> ghcum
13:24:13 <emertens> sylvan: I have a gmail.com account using this nick as username
13:24:18 <sylvan> ok
13:24:48 <sylvan> sent
13:25:19 <emertens> would it make sense to implement the disjoin set operations separately from the implementation of Kruskal's algorithm?
13:25:26 <emertens> and then use a stateT
13:25:28 <emertens> to link the two?
13:25:35 <emertens> disjoint*
13:29:01 <sjanssen> won't efficient disjoint set operations require mutable references?  (ie STRef or IORef)
13:29:06 <sylvan> hmm... I guess you coulc implement the UF data structure separately
13:29:28 <lispy> whoa, why does cabal run the postBuild on clean?
13:29:33 <lispy> that seems broken...
13:29:36 <sylvan> I didn't since it was so specialized in my case (path joins were O(1) rather than O(n) due to not having branches)
13:30:26 <lispy> or perhaps it's a windows issue with Ctrl-C
13:30:51 <emertens> I wanted to write the union to be O(1) and then have the find actually update every element on it's way to finding the root node
13:32:23 <sylvan> You can write your UF using STArrays and have a completely regular imperative implementation. All your operations on it would then be i the ST monad.
13:33:39 <emertens> did you glace at the prim's implementation I posed?
13:33:41 <emertens> posted*
13:34:15 <sylvan> not yet
13:35:58 <emertens> it's pretty short. i just wondered if I missed any oportunities to use some of the more interesting Monads or other haskell techniques :)
13:37:16 <sjanssen> emertens: xor is equivalent to /=
13:37:42 <emertens> wow
13:37:52 <sylvan> emertens, well generally it's not very efficient to have a list of edges if you're trying to find a connected node (or edge). An adjacency array is more efficient (O(1) lookup, just index it with the current index and get out the list of neighbours).
13:38:07 <sylvan> the last index = vertex
13:38:39 <emertens> i can't beleive that I reimplemented /=
13:40:01 <sylvan> :-)
13:43:11 <emertens> sylvan: does it make sense to use an adjacency matrix is the idea is to iterate through the edges (sorted by weight) and pick the next connected one?
13:43:20 <emertens> s/is/if
13:43:45 <sjanssen> emertens: you probably want an adjacency list
13:44:50 <sjanssen> i.e. Array Edge [Edge]
13:46:02 <emertens> other than the storage issues, does the use of the state monad make sense in that example
13:46:22 <emertens> practicing with the State monad was one of the main reasons that I picked this algorithm to implement in Haskell
13:47:00 <sylvan> emertens, not matrix, array (or list). Basically an array indexed  by vertex containing a list of all the neighbours
13:47:16 <sylvan> so adj!4 would return a list of neighbours to vertex 4
13:47:44 <emertens> sure
13:47:46 <sylvan> (!) is the indexing operator
13:47:53 <emertens> I understand that suggestion
13:48:04 <emertens> I was just wondering if my use of the State monad was appropriate
13:48:43 <syntaxfree> I need help building HaskellDB. What's the appropriate place to ask?
13:48:57 <sylvan> Yeah I guess it's good enough. To me I use the State monad as a way to get rid of excessive plubming. So there's no "right". It's just a personal threshold of when you feel you're passing around too much data
13:49:52 <sylvan> particularly auxillirary data. Like if you need to use random  numbers in a computation, it makes sense to hide that since the details (a random number generator) is not the *point* of the algorithm, so plumbing it around is just noise
13:50:19 <emertens> how does State relate to ST?
13:50:25 <sylvan> Not at all
13:50:29 <emertens> ok
13:50:40 <emertens> what does ST stand for?
13:50:47 <sylvan> ST has mutable references, State is just the equivalent of passing around extra data with each function call (but hiding it)
13:50:48 <syntaxfree> @type (!)
13:50:49 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
13:50:53 <sylvan> State Transformer I think
13:51:03 <syntaxfree> I don't understand Arrays.
13:51:21 <sjanssen> ST stands for State Thread, if I recall correctly
13:51:28 <sylvan> syntaxfree, they're immutable fields of data with O(1) read, but O(n) update
13:51:33 <sylvan> sjanssen: , right that makes sense
13:52:11 <syntaxfree> What's the boundary on Lists?
13:52:12 <emertens> StateT is the state transformer, right?
13:52:17 <sjanssen> emertens: essentially, it's the IO monad without IO.  Mutable arrays and references, basically
13:52:23 <syntaxfree> (for read, update, cons, append, etc.)
13:52:34 <sylvan> emertens:  it's the monad transformer of State. Allowing you to combine the State functionality with other monads (such as Error)
13:52:48 <sjanssen> syntaxfree: what kind of boundary do you mean?
13:52:51 <sylvan> You can thus build new monads by picking and choosing from existing monad transformers
13:53:05 <syntaxfree> boundary on time. Like O(n)?
13:53:32 <sylvan> sjanssen:  One big difference though! You can *run* an ST to get the result from it, but you can't run an IO action
13:53:34 <syntaxfree> But I digress.
13:53:35 <sjanssen> cons O(1), append O(n) in length of second argument, index O(i)
13:53:44 <syntaxfree> I need help building HaskellDB!
13:54:21 <sylvan> sjanssen:  random access for lists are O(n) which is the most common reason for needing arrays
13:54:42 <sjanssen> rather, append is O(n) in length of *first* argument
13:54:43 <syntaxfree> Arrays are fixed size, though. Right?
13:54:52 <sjanssen> syntaxfree: yes
13:54:54 <sylvan> syntaxfree, yes
13:55:03 <syntaxfree> what about Data.ByteString?
13:55:21 <sylvan> what about them?
13:55:28 <sjanssen> syntaxfree: cons is O(n), append O(n), index is O(1)
13:55:53 <sylvan> size is O(1)
13:56:20 <sylvan> and there's a much smaller constant factor for most of the ops compared to String
13:56:21 <sjanssen> actually append is O(n+m)
13:56:35 <vincenz> seems logical
13:56:39 <vincenz> array vs list tradeoff
13:56:57 <syntaxfree> Index= random access by index?
13:57:07 <sjanssen> syntaxfree: yes
13:57:13 <sylvan> but when you start mixing in Data.Sequence, Data.Array.Diff, Data.Array.ST etc. it all gets blurred =)
13:57:29 <sjanssen> also, substring operations are O(1) in memory
13:57:33 <sylvan> I guess the upshot is: There are plenty of options to try
13:57:38 <syntaxfree> what is Data.Sequence?
13:57:58 <sylvan> A new sequence type...
13:58:02 <sjanssen> 2-3 finger tree implementation of a sequence
13:58:05 <syntaxfree> what is a sequence?
13:58:09 <sylvan> O(1) append and some other nice properties
13:58:20 <vincenz> syntaxfree: contiguous integer-index data-set
13:58:24 <vincenz> aka, a list or a vector
13:58:28 <vincenz> or a 2-3 finger tree
13:58:33 <syntaxfree> Where can I learn about data structures like that? Will an ordinary data structures textbook do?
13:58:36 <emertens> sjanssen / sylvan: do you have a simple example for the use of mfix
13:58:37 <emertens> ?
13:58:48 <sylvan> @type mfix
13:58:49 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
13:58:50 <emertens> or anyone else for that matter
13:58:50 <vincenz> syntaxfree: read edison
13:58:58 <sjanssen> emertens: I don't often use it
13:59:16 <vincenz> > mfix (:[])
13:59:17 <lambdabot>  Add a type signature
13:59:17 <syntaxfree> I basically know data structures from introductory scheme. Binary trees, rose trees, unary natural numbers, vectors (which are imperative in Lisp) and not much else.
13:59:25 <vincenz> > mfix (:[]) :: [Int]
13:59:27 <lambdabot>  Exception: <<loop>>
13:59:32 <vincenz> > mfix (:1:[]) :: [Int]
13:59:34 <lambdabot>  Exception: <<loop>>
13:59:43 <lispy> dcoutts_: it does in fact work
13:59:45 <syntaxfree> no one to the rescue regarding HaskellDB?
13:59:51 <lispy> dcoutts_: i just used my haskell dll from VB
13:59:54 <sjanssen> syntaxfree: there's a book by Okasaki about data structures in functional languages
14:00:00 <dcoutts> lispy, oh good
14:00:04 <dmhouse> > take 20 (fix (1:))
14:00:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
14:00:12 <vincenz> dmhouse: mfix
14:00:19 <lispy> dcoutts: but my Setup.lhs is ugly...
14:00:21 <dmhouse> What does mfix do?
14:00:25 <syntaxfree> oh, god, I can't build wxHaskell.
14:00:25 <vincenz> @type mfix
14:00:27 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
14:00:30 <sylvan> I can heartily recommend Algorithm Design by Kleinberg & Tardos
14:00:39 <vincenz> > mfix (return) :: [Int]
14:00:40 <syntaxfree> What amazing ammounts of toil is necessary to get Hope to run!
14:00:40 <lambdabot>  Exception: <<loop>>
14:00:44 <dcoutts> lispy, post it and your wiki link to the cabal-devel list
14:00:48 <sylvan> though it's not specifically about functional structures, it's really quite excellent
14:00:51 <lispy> syntaxfree: what OS?
14:00:59 <syntaxfree> OS X, 10.3.9
14:01:01 <vincenz> > mfix (const $ return 1) :: [Int]
14:01:02 <lambdabot>  [1]
14:01:07 <dmhouse> Gotcha.
14:01:10 <lispy> syntaxfree: ah :(
14:01:13 <syntaxfree> Mingus:~/downloads/wxhaskell-0.9.4 syntax$ uname -a
14:01:13 <syntaxfree> Darwin Mingus.local 7.9.0 Darwin Kernel Version 7.9.0: Wed Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC  Power Macintosh powerpc
14:01:14 <lispy> dcoutts: will do
14:01:21 <dcoutts> lispy, ta
14:01:32 <dmhouse> mfix f = mfix f >>= f?
14:01:33 <xerox> > mfix return 1
14:01:33 <lambdabot>  Add a type signature
14:01:39 <monochrom> > take 20 (mfix (\s -> 1:s) :: [Int])
14:01:40 <sjanssen> > mfix return :: [Int]
14:01:40 <lambdabot>  Couldn't match `[a]' against `Int'
14:01:41 <lambdabot>  Exception: <<loop>>
14:01:46 <xerox> > mfix return 1 :: [Int]
14:01:47 <lambdabot>  Exception: <<loop>>
14:02:04 <syntaxfree> I don't even know why wxHaskell will  not build.
14:02:26 <syntaxfree> I know HaskellDB is looking for both Hugs and GHC, and yet supposedly one should be able to compile it without Hugs support.
14:02:54 <roconnor> > mfix (\x -> return 1 `mplus` return x)
14:02:55 <lambdabot>  add an instance declaration for (Show (m a))
14:03:03 <roconnor> > mfix (\x -> return 1 `mplus` return x) ::[Int]
14:03:05 <lambdabot>  Exception: <<loop>>
14:03:15 <roconnor> > mfix (\x -> return x `mplus` return 1) ::[Int]
14:03:16 <lambdabot>  Exception: <<loop>>
14:03:40 <syntaxfree> @where wxHaskell
14:03:40 <lambdabot> http://wxhaskell.sourceforge.net/
14:03:52 <monochrom> > take 20 (mfix (\s -> [1:s]) :: [Int])
14:03:52 <lambdabot>  Couldn't match `[a]' against `Int'
14:04:12 <xerox> Can I undo ghc-pkg undegister Cabal easily?
14:04:22 <monochrom> > map (take 20) (mfix (\s -> [1:s]) :: [[Int]])
14:04:24 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
14:04:30 <monochrom> Hahahaha I rock!
14:05:04 <Pete_I> ....it's a string of ones....
14:05:11 <xerox> Lemmih: any ideas?
14:05:50 <Lemmih> xerox: Ideas about what?
14:05:54 <xerox> Can I undo ghc-pkg undegister Cabal easily?
14:05:58 <xerox> *unregister
14:06:18 <syntaxfree> Haskell needs some work in the user-friendliness of tools.
14:06:21 <monochrom> > map (take 20) (mdo { s <- [1:s]; return s } :: [[Int]])
14:06:21 <lambdabot>  Parse error
14:06:35 <monochrom> Boo, lambdabot doesn't know mdo.
14:06:41 <Lemmih> xerox: Why do you want that?
14:06:47 <xerox> Lemmih: Cabal's README says to do that if you want to eradicate the previous Cabal and get the new one, but if one does so, one can't build it, specifically, one can't build cabal-setup.
14:07:04 <Lemmih> xerox: Don't listen to the README. It tells lies.
14:07:10 * xerox eeeeks
14:07:15 <monochrom> But anyway mfix is the de-sugaring of the mdo notation.
14:07:19 <xerox> I'm doomed now!
14:07:40 <Lemmih> xerox: Just upgrade Cabal like you would with any other Cabal package.
14:07:51 <xerox> Lemmih: but I can't build it now!
14:08:21 * syntaxfree cries and whines and pants.
14:08:36 <syntaxfree> The docs claim that wxHaskell needs readline, not shipped by default with OS X.
14:08:43 <syntaxfree> I installed it. What is it complaining about now?
14:10:02 <Lemmih> xerox: The README got ya, eh.
14:10:09 * xerox sighs
14:11:07 <Lemmih> Someone should probably fix the README.
14:11:32 <xerox> And my installation :(
14:12:03 <lisppaste2> syntaxfree pasted "cries, whines and pants" at http://paste.lisp.org/display/23218
14:12:54 <syntaxfree> oh, more fool me.
14:13:04 <syntaxfree> I need wxwidgets first.
14:13:12 <monochrom> Oh! Haha.
14:13:19 <syntaxfree> I don't even want a GUI toolkit, I want HaskellDB to work :'(
14:13:35 <syntaxfree> what's pre-annoying me already is that apparently wxhaskell expects wxwidgets to be in /sw
14:13:40 <xerox> OK, fixed.
14:13:43 <syntaxfree> i.e. expects me to have Fink.
14:13:50 <xerox> It was simple than I thought :-)
14:14:11 <xerox> syntaxfree: why are you installing wxwidgets if you don't want it?
14:14:24 <syntaxfree> because HaskellDB lists it as a requirement.
14:14:30 <syntaxfree> You either need wxHaskell or HSQL.
14:14:31 <xerox> No way, I believe.
14:14:39 <syntaxfree> HSQL has gone AWOL, it seems.
14:14:39 <xerox> Oh well, go for HSQL!
14:14:58 <syntaxfree> apparently wxHaskell has some kind of database connectivity.
14:15:03 <syntaxfree> @where HSAQL
14:15:03 <lambdabot> I know nothing about hsaql.
14:15:08 <syntaxfree> @where hsql
14:15:08 <lambdabot> http://htoolkit.sourceforge.net
14:15:13 <syntaxfree> look at that website, an.
14:15:16 <xerox> YEs but it doesn't make sense to install it if you are not going to use it.
14:15:16 <syntaxfree> s/an/man.
14:15:30 <syntaxfree> My ultimate goal is to get Hope to function.
14:15:34 <xerox> You gotta use sf.net/projects/htoolkit
14:15:36 <syntaxfree> I need HaskellDB to work first.
14:15:48 <monochrom> wxHaskell is a superset of HSQL, I think.
14:16:05 <syntaxfree> but isn't wxHaskell a GUI toolkit?
14:16:07 <xerox> If I could suggest another thing, is to use haskelldb-flat, so that you don't have to install any relational database.
14:16:21 <syntaxfree> Well, I want to interface with MySQL.
14:16:26 <monochrom> Some years ago I could install HaskellDB and HSQL.  No wxHaskell installed.
14:16:30 <syntaxfree> (I already have MAMP functioning)
14:16:54 <syntaxfree> Um, question.
14:16:54 <xerox> Then go for HSQL, I don't believe wxHaskell is going to give you MySQL interoperability.
14:17:06 <syntaxfree> Like, newb question.
14:17:08 <syntaxfree> So bear with me.
14:17:17 <syntaxfree> I'm installing a tower of Haskell packages to get to Hope.
14:17:25 <syntaxfree> But ultimately, I expect my program to run as CGI elsewhere.
14:17:39 <xerox> Lemmih: I am now re-getting the Cabal repository, re-making my changes, and adding ONE MORE change... let's fix the README?
14:17:44 <syntaxfree> I won't need that tower built elsewhere, will I?
14:18:15 <xerox> If you build hope statically, it will run on other systems without the whole work of unrolling dependencies.
14:18:40 <syntaxfree> I see.
14:18:42 <xerox> There are some informations about static building in the README/INSTALL file.
14:18:51 <xerox> (Specifically for OS X.)
14:18:55 <syntaxfree> God, to think I'm gonna have to build the tower of dependencies on a Linux box just for the sake of compiling.
14:19:09 <xerox> Those are really little dependencies.
14:19:38 <xerox> The big number of them is due to the hard work of bringert who wrote a series of little cabalized haskell libraries for everything he needed :-)
14:19:39 <monochrom> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WXCore.Db.html
14:19:49 <syntaxfree> What's a minimal Linux distribution that has all of what I need to run GHC?
14:20:10 <xerox> It's cool because once you have got cabal-get it will all be automatized :-)
14:20:25 <monochrom> I erred.  wxHaskell is not a superset of HSQL.  But wxHaskell and in fact wxWindows has SQL capability (I don't know why).
14:21:21 <syntaxfree> the only thing that pisses me off about owning a Mac is having to run a Linux virtual pc to compile CGI apps to get them to run on a normal web host.
14:21:29 <monochrom> I use Ubuntu.  I add readline4.  Then GHC is happy.
14:21:37 <syntaxfree> Ubuntu is gigantic.
14:21:45 <xerox> monochrom: QT had something like that, they were probably envious.
14:21:55 <monochrom> Ubuntu Desktop is gigantic.  Ubuntu Server is small.
14:21:57 <wolverian> ubuntu-minimal is not that large.
14:22:05 <syntaxfree> interesting.
14:22:19 <syntaxfree> I don't want X and graphics of sexy black people,  I just want to compile some apps.
14:22:41 <monochrom> There is not one single Ubuntu.
14:22:44 <wolverian> http://releases.ubuntu.com/dapper/
14:22:46 <lambdabot> Title: Ubuntu 6.06 LTS (Dapper Drake)
14:22:52 <wolverian> browse down to "server install cd"
14:23:37 <syntaxfree> oh god. I need Cabal to install HSQL.
14:23:42 <monochrom> It's like saying "Windows is 16 bit".
14:24:01 <syntaxfree> What's worse, I'm gonna have to replicate all those steps on the Linux virtual box.
14:24:25 <wolverian> syntaxfree, you might want to wait until cabal-get works. :-)
14:24:57 <dylan> debian has packages for hsql, it appears.
14:25:15 <wolverian> yup. ubuntu as well.
14:25:34 <wolverian> version 1.6-5
14:26:02 <monochrom> It has a dependency on ghc.  ghc is at merely 6.4.1 in those deb repositories.
14:26:21 <dylan> 1.6-8 here, for hsql
14:26:23 <wolverian> merely? it's the latest stable release
14:26:32 <monochrom> 6.4.2
14:26:55 <wolverian> oh, well, almost latest. :-) ubuntu has a six month release cycle, during which only security and serious bugfixes go in
14:27:25 <wolverian> debian sid (also called unstable) is updated more regularly, but is also more, well, unstable (feature-wise)
14:27:26 <dylan> I wonder if sid has 6.4.2
14:27:34 <ihope_> Grumble, monomorphism restriction...
14:27:41 <dylan> debian sid is more stable than etch on amd64
14:28:01 <wolverian> dylan, 6.4.1-2.1
14:28:18 <monochrom> the ghc deb is not maintained by the ubuntu people or the debian people.
14:28:22 <dylan> etch on amd64 is an adventure in madness
14:28:27 <wolverian> wait. 6.4.2-2
14:28:31 <ihope_> > let x = 32 in 1-((x-1)/x)^x
14:28:32 <wolverian> (on sid)
14:28:32 <lambdabot>  Add a type signature
14:28:35 <dmhouse> @type (^)
14:28:36 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:28:44 <wolverian> monochrom, mm?
14:28:47 <dmhouse> > let x = 5 in (2^x, x/2)
14:28:48 <lambdabot>  Add a type signature
14:28:57 <xerox> Lemmih: got a minute to think about what to say in the README exactly? I have little confidence with Cabal on the whole yet.
14:29:08 <monochrom> OK, I over-simplified.
14:29:14 <dmhouse> ihope_: 1-(fromIntegral $ (x-1) / x)^x
14:29:33 <sjanssen> dmhouse: there aren't any types that can do that
14:29:40 <sjanssen> @type (^)
14:29:41 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:29:43 <sjanssen> @type (/)
14:29:45 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:29:47 <ihope_> Or use GHCi without the monomorphism restriction?
14:29:58 <dmhouse> sjanssen: because of the monomorphism restriction.
14:30:00 <sjanssen> requires a type that is both integral and fractional
14:30:11 <sjanssen> dmhouse: no monomorphism restriction, I think
14:30:14 <dmhouse> > 2^5
14:30:14 <ihope_> sjanssen: Num a => a? :-)
14:30:15 <lambdabot>  32
14:30:18 <dmhouse> > 5/2
14:30:19 <lambdabot>  2.5
14:30:27 <dmhouse> That's precisely the monomorphism restriction.
14:30:37 <dmhouse> x doesn't look like a function, so it is infered to have a monomorphic type.
14:30:43 <sjanssen> > let x = 5 in (2^x, (fromIntegral x)/2)
14:30:44 <lambdabot>  (32,2.5)
14:30:51 <dmhouse> Precisely.
14:30:58 <sjanssen> oh, I see what you mean
14:31:17 <monochrom> The thing with Debian is that it is not one single Debian, not even three Debians, but rather a huge non-linear poset under the version ordering.
14:31:18 <urz> is there a distcc for haskell?
14:31:36 <integral> @karma+ monochrom
14:31:36 <lambdabot> monochrom's karma raised to 4.
14:31:39 <monochrom> Ha
14:31:55 <integral> That's the single most enlightened thing I've heard today :-)
14:35:41 * dmhouse idly wonders why the type of length is restricted to Ints
14:35:51 <dmhouse> (And yes, I know about genericLength.)
14:36:04 <dmhouse> But it seems that any Num type would suffice. You only need addition.
14:36:05 <sjanssen> dmhouse: speed
14:36:37 <sjanssen> plus, who really has lists with more than 2^31 elements?
14:36:48 <dmhouse> > [1..] -- me! :)
14:36:49 <vincenz> or lists with 2.14 element
14:36:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:36:56 <monochrom> It seems that Int suffices for most purposes, and length is used often enough to warrant optimizations.
14:37:22 <vincenz> > length ([1..2^32] :: [Integer])
14:37:26 <lambdabot> Terminated
14:37:38 <sjanssen> the naive implementation with Double would reach an upper bound anyway
14:37:58 <lispy> so next question
14:38:09 <vincenz> > length ([1..2^31] :: [Integer])
14:38:11 <lispy> how do i know the alias for the dll entry points?
14:38:13 <lambdabot> Terminated
14:38:22 <lispy> my function is named "bench" in the .hs file
14:38:27 <dmhouse> vincenz: that's quite a bit list.
14:38:29 <lispy> in the dll it appears to be named bench@0
14:39:59 <lispy> my guess is that the number after the @ has to do with the size of the stack frame
14:40:31 <lisppaste2> GeoffSK pasted "main loop problems" at http://paste.lisp.org/display/23219
14:40:55 <lisppaste2> GeoffSK pasted "main loop problems" at http://paste.lisp.org/display/23220
14:43:10 <monochrom> Is that spam?
14:43:59 <dmhouse> Seems unlikely.
14:44:03 <dmhouse> GeoffSK: got a question?
14:44:27 <GeoffSK> yes, thanks. i am having trouble working out how to organise a main loop
14:45:03 * edwardk waves ello.
14:45:07 <GeoffSK> it feels like i am trying to pretend haskell is java
14:45:18 <edwardk> geoff?
14:45:29 <GeoffSK> yes?
14:45:40 <monochrom> It is fine.
14:45:44 <edwardk> er i should have said: ? i meant how so? =)
14:46:27 <GeoffSK> oh really..all those g1, g2, g3 - seems bad form
14:47:58 <edwardk> anyonw here comfortable with the plugins interface?
14:48:07 <emertens> @paste
14:48:08 <lambdabot> http://paste.lisp.org/new/haskell
14:48:23 <ihope_> So does Haskell have any arbitrary-precision floating point numbers?
14:48:38 <xerox> ?type pi
14:48:39 <lambdabot> forall a. (Floating a) => a
14:48:52 <edwardk> ihope there was a library entered into the multiprecision floating point competition
14:48:55 <ihope_> (x-1)/x where x is very large tends to get rounded, and that's bad when you intend to take it to the power of x.
14:48:56 <xerox> > show (pi :: Float)
14:48:58 <lambdabot>  "3.1415927"
14:49:04 <xerox> Eeeeek.
14:49:05 <edwardk> but it kinda paled in comparison to the mpre impl.
14:49:08 <monochrom> No, Haskell does not have an arbitrary-precision floating point number type.
14:49:11 <ihope_> xerox: ?
14:49:22 <dmhouse> GeoffSK: often the main loop of a program ends up looking quite imperative.
14:49:27 <lisppaste2> emertens pasted "my attempt at a union find structure" at http://paste.lisp.org/display/23221
14:49:44 <xerox> ?type showFFloat
14:49:44 * dmhouse finds it weird that pi is actually a _method_ of the Floating class.
14:49:45 <edwardk> heh looks pretty much like the one i did
14:49:46 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> ShowS
14:50:03 <edwardk> modulo some naming conventions
14:50:04 <GeoffSK> ok, thanks. appreciate it
14:50:12 <xerox> > last $ showFFloat (Just 100) pi ""
14:50:13 <lambdabot>  '0'
14:50:19 <xerox> > last $ showFFloat (Just 1000) pi ""
14:50:20 <lambdabot>  '0'
14:50:26 <xerox> Luck?
14:50:38 <dmhouse> What does the function do?
14:50:39 <edwardk> (i need union-find for my flowgraph simplification in javascript)
14:50:51 <vincenz> > last $ showFFloat (Just 1001) pi ""
14:50:53 <lambdabot>  '0'
14:50:54 <dcoutts> dmhouse, you'll notice it's a 'method' with no parameters
14:50:55 <vincenz> nope
14:51:03 <dmhouse> > take 20 $ reverse $ showFFloat (Just 1000) pi ""
14:51:04 <lambdabot>  "00000000000000000000"
14:51:19 <monochrom> Why are you people proving that pi is rational?!
14:51:28 <emertens> edwardk: do you have any suggestions for me that you might have picked up when you implemented yours?
14:51:29 <xerox> ?index pi
14:51:30 <lambdabot> Prelude
14:51:34 <xerox> ?fptools Prelude
14:51:34 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
14:51:38 <dmhouse> dcoutts: yes, but functions and values are one and the same in my mind.
14:51:55 <dcoutts> dmhouse, so it's all ok then :-)
14:51:56 <emertens> edwardk: I'm just screwing around trying to find algorithms and data structures to code up in haskell
14:52:00 <dmhouse> (Which is why Emacs is very annoying sometimes. :))
14:52:01 <xerox> ?fptools GHC.Float
14:52:01 <lambdabot> GHC.Float not available
14:52:04 <xerox> Dang.
14:52:06 <vincenz> edwardk: btw, didn't know you had my source on your page :P
14:52:18 <vincenz> edwardk: tho your webpage crashes my browser when I click on ifcp
14:52:28 <edwardk> i don't actually, vincenz
14:52:35 <vincenz> slipwave?
14:52:51 <edwardk> i put a copy in the directory for dons to copy but never linked it anywhere
14:52:52 <emertens> What is an antonym for disjoint...
14:52:59 <vincenz> http://slipwave.info/icfp/vincenz-um.cpp
14:53:05 <Cale> emertens: conjoint
14:53:06 <vincenz> edwardk: nah it's ok :)
14:53:11 <edwardk> ah removing the link i didn't expect it to persist
14:53:13 <emertens> Cale: thanks :)
14:53:22 <vincenz> edwardk: anyways your website crashes my browser
14:53:30 <xerox> instance  Floating Float  where
14:53:30 <xerox>     pi			=  3.141592653589793238
14:53:30 <vincenz> open it up
14:53:32 <vincenz> click on icfp
14:53:34 <vincenz> crash
14:53:38 <xerox> instance  Floating Double  where
14:53:38 <xerox>     pi			=  3.141592653589793238
14:53:39 <edwardk> vincenz: what browser?
14:53:44 <vincenz> ff linux
14:53:45 <xerox> Bah!
14:53:50 <monochrom> emertens: sometimes we say "X intersects Y"
14:53:54 <vincenz> 1.5.0.1
14:54:02 <dmhouse> emertens: undisjoint? :)
14:54:04 <edwardk> vincenz: can you try clicking on options >> to the right and click off EnableAnimations?
14:54:05 <monochrom> "X intersects with Y"
14:54:07 <edwardk> and see if that helps?
14:54:15 <edwardk> if it does i'll turn them off by default
14:54:19 <emertens> djsConjoined a b uf = liftM2 (==) (djsFind a uf) (djsFind b uf)
14:54:21 <dmhouse> emertens: I'd probably go with 'with a non-empty intersection'.
14:54:22 <emertens> I'm just trying to name that
14:54:45 <vincenz> edwardk: don't see that
14:54:53 <dmhouse> hasAnElementInCommonAndNoYouDidntJustStumbleIntoHashLispByAccident. :)
14:54:57 <edwardk> right hand bar, search, close all, permaview, edit >>, options >>
14:55:00 <vincenz> nm
14:55:07 <emertens> Hash Lisp?
14:55:10 <vincenz> edwardk: still crashes
14:55:12 <dmhouse> emertens: As in, #lisp.
14:55:14 <edwardk> strange
14:55:19 <emertens> ah :)
14:55:25 <edwardk> ah well. i'm going to scrap tiddlywiki when i get a chance anyways
14:55:27 <xerox> > last $ showFFloat (Just 1000) (4 * atan 1) ""
14:55:28 <lambdabot>  '0'
14:55:37 <xerox> > last $ showFFloat (Just 1001) (4 * atan 1) ""
14:55:37 <edwardk> added to my todo list
14:55:38 <lambdabot>  '0'
14:55:55 <xerox> Nah, eh?
14:56:03 <edwardk> ah, i think i know what part it is, its the view-source macro thats killing you
14:56:14 <vincenz> possibly
14:56:22 <vincenz> why such a complex site?
14:56:37 <edwardk> heh, coz it works fine for me and i wanted to play with tiddlywiki =)
14:56:44 <vincenz> :)
14:56:52 <Cale> where's this site?
14:56:53 <edwardk> i really just started documenting the stuff i was doing to play with the interface.
14:56:57 <edwardk> http://slipwave.info/.
14:57:00 <edwardk> er sans final .
14:57:48 <Cale> heh, yeah, clicking on a link does crash it
14:57:50 <edwardk> vincenz: when i get around to fixing the javascript recompiler on there back into a working state i'll recompile the view-source macro so it won't crash you
14:57:58 <edwardk> interesting
14:58:01 <edwardk> what browser cale?
14:58:02 <Cale> TiddlyWiki works for me normally though
14:58:18 <edwardk> its the view-source stuff, i'm pretty sure
14:58:26 <edwardk> i'd never had a problem with it before
14:58:27 <Cale> firefox 1.5.0.1
14:58:31 <edwardk> platform?
14:58:31 <Cale> on Debian
14:58:33 <edwardk> ah
14:58:37 <vincenz> Ubuntu :)
14:58:52 <edwardk> heh, so i have 3 folks who are all running debian or ubuntu who have had it make them crash
14:58:58 <edwardk> time for me to gut the view-source macro =/
14:59:29 <dmhouse> edwardk: Woah, that's one souped-up site.
15:00:09 <edwardk> dmhouse: wanted to put something up to document what i was working on, but didn't want to deal with the full page load times for microcontent.
15:00:32 <edwardk> i find this writing style works for me because I can write whatever I want to say, and people only read what they want to hear.
15:00:34 <dmhouse> The animation's still a little laggy.
15:00:40 <edwardk> browser?
15:00:54 <edwardk> i'm going to can the default tiddlywiki animation i think as well.
15:01:16 <dmhouse> edwardk: hey, you seem to know stuff about continuations! Weird.
15:01:26 <dmhouse> Know anything about using them in Haskell?
15:01:36 <edwardk> it appears to be buggy in internet explorer and on linux firefox
15:01:44 <edwardk> a bit, just the same stuff anyone who has used them a lot does
15:01:49 <dmhouse> The wikibook's got a kickass CPS module which is waiting to be written :)
15:01:54 <edwardk> heh
15:02:01 <ihope_> > showFFloat (Just 20) pi ""
15:02:02 <lambdabot>  "3.14159265358979300000"
15:02:13 <ihope_> > showFFloat (Just 50) pi ""
15:02:14 <lambdabot>  "3.14159265358979300000000000000000000000000000000000"
15:02:20 <ihope_> That's bad :-)
15:02:36 <Cale> no it's not
15:02:36 <lispy> > showFFloat Nothing pi ""
15:02:37 <lambdabot>  "3.141592653589793"
15:02:39 <dmhouse> edwardk: http://en.wikibooks.org/wiki/Haskell/CPS If you have the time, you'd get major lambdacookies. :)
15:02:57 <dmhouse> edwardk: feel free to ignore, delete or incorporate anything that's already there.
15:03:04 <edwardk> fair enough
15:03:05 <lispy> @type showFFloat
15:03:06 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> ShowS
15:03:29 <edwardk> let me finish up my current writing projects and i'll probably get bored and obsess about it =)
15:04:10 <dmhouse> edwardk: But really nice site, anyway.
15:04:40 <dmhouse> edwardk: Sure. Both myself and Kowey seem to know very little about it so it'd be great to have a really solid module filling that gap.
15:04:43 <edwardk> Hrm. I wonder if its the XmlHttpRequest or the construction of the highlighted table
15:04:58 * dmhouse has personally struggled to find a decent continuations tutorial.
15:05:33 <edwardk> you can dig around in the site, i explain them -- i think -- pretty well in a functional context
15:05:50 <edwardk> but i mostly have the non-computer science intro to them for people on there. the 'callback function' viewpoint
15:06:16 <edwardk> most lambdafolk tend to try to give them a more intelligent sounding derivation =)
15:06:51 <monochrom> I can't crash my browser. :(
15:06:52 <edwardk> since i'm imperative in JS, my continuations are technically partial continuations, etc.
15:07:03 <edwardk> monochrom: site works fine for you?
15:07:16 <dmhouse> edwardk: Woah, I can edit your posts. Is that deliberate?
15:07:34 <edwardk> you can try, it won't let you save unless you log in with an account.
15:07:45 <Cale> It's fairly simple, you simply rewrite the function f x = y like f' x k = k y, and that's called "continuation passing style", since you're passing f' a function k which it will pass what would have been the result of f
15:07:47 <edwardk> and i'm the only person with an account =)
15:08:03 <Cale> a "continuation" for the computation
15:08:12 <dmhouse> Cale: yeah, I get that bit, but things get reeeeally crazy once Cont appears in the picture.
15:08:13 <edwardk> yeah
15:08:29 <Cale> well, Cont just wraps that
15:08:31 <monochrom> Seems to work fine here :(
15:08:41 <edwardk> it becomes a little crazier in the javascript case up on that site because i have to do the transform in a language without tail call optimization without blowing up the stack.
15:09:12 <xerox> ?fptools Control.Monad.Cont
15:09:13 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
15:09:22 <edwardk> and i can't have my lexical scope chains grow too long so i have to invert a duff's device so it works in javascript to get a usable transform
15:09:34 <ihope_> @type Control.Monad.Cont.callCC Left
15:09:36 <lambdabot>   Occurs check: cannot construct the infinite type: m = Either (a -> m b)
15:09:36 <lambdabot>    Expected type: (a -> m b) -> m a
15:09:46 <ihope_> @type Control.Monad.Cont.callCC Right
15:09:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> Either a1 b
15:09:48 <lambdabot>    Expected type: (a -> Either a1 b) -> Either a1 a
15:09:54 <edwardk> but yeah, especially in a pure functional language, continuations are easy =)
15:10:04 <ihope_> Hmm.
15:10:16 <ihope_> @type Control.Monad.Cont.callCC Just
15:10:18 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> Maybe b
15:10:18 <lambdabot>    Expected type: (a -> Maybe b) -> Maybe a
15:10:46 <xerox> > callCC -- just a test
15:10:47 <lambdabot>  Add a type signature
15:10:51 <ihope_> @type Control.Monad.Cont.callCC (const Nothing)
15:10:52 <lambdabot>   No instance for (Control.Monad.Cont.MonadCont Maybe)
15:10:53 <lambdabot>    arising from use of `Control.Monad.Cont.callCC' at <interactive>:1:0-24
15:11:18 <ihope_> @type Control.Monad.Cont.callCC (return . Left)
15:11:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = Either (a -> m b1) b
15:11:20 <lambdabot>    Expected type: (a -> m b1) -> m a
15:11:59 <ihope_> @type Control.Monad.Cont.callCC (const (return Left))
15:12:00 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => m (a -> Either a b)
15:14:30 <dmhouse> I've decided writing type declarations in code is evil.
15:14:42 <dmhouse> It makes it harder to refactor.
15:14:58 <dmhouse> They can, and therefore should, be scribed computationally.
15:15:15 <monochrom> Need an IDE to refactor and update type signatures for you!
15:15:30 <dmhouse> (Obviouslly apart from when the language feature requires you to write the signitures in.)
15:15:34 <wolverian> dmhouse, document the ghc api please :)
15:15:34 <monochrom> Haddock requires manual type signatures.
15:16:08 <edwinb> It also makes it harder to read your code...
15:16:08 <monochrom> Need type inferrer for Haddock!
15:16:18 <edwinb> Surely it's not hard to change your type signature when you change your function?
15:16:24 <edwinb> I do it a lot...
15:16:39 <dmhouse> edwinb: Sure, but what if you want to change the name of a type, say?
15:16:43 <monochrom> It is hard.  You do it alot?  Poor you.
15:16:53 <dmhouse> The functions themselves needn't change, just what you've written down as their types.
15:17:00 <edwinb> I have search and replace for that...
15:17:13 <edwinb> Types are supposed to help you, not get in the way!
15:17:36 <dmhouse> I'm not arguing about _types_, I'm arguing about explicit type signitures.
15:18:13 <edwardk> there, refactored to remove the view-source stuff
15:18:16 <edwardk> does it still crash you?
15:18:34 <edwinb> don't you find it harder to read what your code is supposed to do?
15:18:37 <edwardk> i removed all autogenerated wiki elements for the source code too though
15:18:53 <monochrom> For every task T that we now all agree should be left to the computer, there exists a time t in the past such that at least half of the people at t thought T was not hard and they did T all the time.
15:19:04 <monochrom> Example: writing machine code.
15:19:16 <dmhouse> edwinb: of course, but I think ideally the types would be inferred and available by your IDE.
15:19:20 <monochrom> Example: memory deallocation.
15:19:33 <edwinb> I guess it depends how you program. I prefer to take types as the prior notion and work from that.
15:19:55 <edwinb> Rather than write the program and have the machine tell me what it thinks it does
15:19:58 <dmhouse> That's a fair point.
15:20:04 <edwardk> in general i tend to agree with edwinb, but putzing with HList, etc, those types can become nigh impossible to write out
15:20:12 <dmhouse> Types as specifications is something that's going to become very big in the future.
15:20:29 <edwardk> cale, vincenz?
15:20:37 <ihope_> RSA should be left to a computer.
15:20:43 <edwinb> and if you have a strong enough type system, you might find the machine can infer some of the program for you...
15:20:49 <monochrom> When you refactor, you change the specification in a non-linear way.
15:21:05 <Cale> edwardk: With things like HList, you don't want to write all your types, that's what type inference is for
15:21:26 <edwinb> I'd like to be able to refactor by changing a type signature then be told what parts of the program I have to change.
15:21:31 <edwardk> yeah hence my limited agreement in principle if not entirely in my operational habits =)
15:21:35 <edwinb> I guess I can do that by looking at compile errors too of course...
15:21:39 <dmhouse> monochrom: Behold the mighty power of Djinn! Ahem.
15:21:41 <monochrom> Perhaps you should change the type specification, and the IDE does the remaining refactoring for you?
15:21:42 <Cale> edwinb: I've done that in Haskell :)
15:21:48 <Cale> edwinb: yeah :)
15:21:54 <edwinb> This is the way I do it ;)
15:22:13 <dmhouse> That's an interesting problem.
15:22:22 * edwardk pokes cale to see if the browser still crashes =)
15:22:27 <dmhouse> (Automatic refactoring through changing the specification.)
15:22:31 <xerox> Well, one usually also do change the actual code, and then fix where the compilers show incongruences
15:22:34 <dmhouse> I'm not sure Haskell's type system is up to it yet.
15:22:44 <monochrom> Interesting idea!  Type error messages have it backwards!
15:22:58 <dmhouse> "The type's wrong? Well, fix it!"
15:23:06 <xerox> Is it decidable in general?
15:23:15 <xerox> I believe you need a programmer.
15:23:15 <dmhouse> Probably not in non-trivial cases
15:23:30 <dmhouse> Depends on the expressiveness of the type system. :)
15:23:54 <xerox> Then you want the same with types, writing kinds? <chuckle>
15:23:55 <dmhouse> Anyway, even if we do eventually get a good enough type system to do that, all the work will just be concentrated in two places:
15:24:06 <dmhouse> 1) Writing the types (non-trivial). 2) Writing the compiler.
15:24:18 <monochrom> If you give the specification "negate :: (Num a) => a -> a" to the computer, ...
15:24:30 <monochrom> It is likely to provide "id" to you. :)
15:24:35 <dmhouse> Right.
15:24:36 <edwardk> heh
15:24:59 <edwardk> yeah but if you can give properties you might get somewhere via coq, or something
15:25:03 <monochrom> "Theorems for free!" dictates this to be the canonical behaviour!
15:25:04 <dmhouse> But imagine an expressive enough system that would be able to prove, statically, for any n, that negate n is -n?
15:25:22 <xerox> A mathematician you mean?
15:25:31 <dmhouse> ;) I meant a type system.
15:26:04 <dmhouse> It's fairly easy, to, say, annotate the types of lists with their lengths, then you can easily prove that, say, map doesn't change the length of a list.
15:26:12 <dmhouse> Or that length (filter p xs) <= length xs
15:26:14 <monochrom> The specification "forall x. x + negate x = 0" is harder.
15:26:42 <edwardk> well to get the negate concept you need to add more into the type system. negation is just finding the additive inverse.
15:26:43 <monochrom> Generally, the computer can begin by generating exhaustive-search code.
15:26:53 <xerox> Given you can set that specification, what kind of modifications will you then do? And what should the "compiler" do about them?
15:26:56 <edwardk> so get up to an additive group and then sure, you can find it =)
15:27:28 <edwardk> now explaining that to a first year comp sci student? another matter.
15:27:57 <xerox> This sounds like a task T :-)
15:28:03 <monochrom> Haha
15:28:08 * xerox laughs too
15:29:54 <shapr> dmhouse: Hey, have you done any GHC hacking yet?
15:30:05 * shapr boings
15:30:13 <dmhouse> shapr: Nah, I got distracted :)
15:31:11 <shapr> I know the feeling.
15:31:18 <shapr> vincenz: Did you do any GHC hacking?
15:31:24 <dmhouse> It's a big and scary repo. So, it's on the todo list :)
15:31:27 <vincenz> shapr: not yet, too bus
15:31:27 * shapr is considering forming a posse
15:31:28 <vincenz> y
15:31:36 <xerox> What is a posse?
15:31:43 <shapr> @babel en it posse
15:31:45 <lambdabot>  posse
15:31:47 <shapr> hmm
15:31:49 <xerox> Ah sure.
15:31:51 <xerox> :-P
15:31:58 * shapr grins
15:32:13 <dmhouse> xerox: like, a club.
15:32:21 <dmhouse> But more gangsta.
15:32:31 <shapr> http://en.wikipedia.org/wiki/Posse_comitatus_%28common_law%29
15:32:34 <sieni> posse is a secret police force
15:33:18 <shapr> "Resort to the posse comitatus figures often in the plots of Western movies, where the body of men recruited is frequently referred to as a posse. Based on this usage, the word posse has come to be used colloquially to refer to various teams, cliques, or gangs."
15:33:48 <sieni> shapr: http://en.wikipedia.org/wiki/Posse
15:33:54 <lispy> hmm...in VB my dll works, in C++ it causes my program to crash when the dll is unloaded...
15:33:54 <xerox> I think @wikipedia could return the first line/paragraph description of the item, if any!
15:34:00 <sieni> well, maybe more like temporary rather than secret
15:34:17 <ihope_> @. babel en de babel de en This won't work.
15:34:17 <lambdabot> compose module failed: IRCRaised Parse error: "en"
15:34:36 <ihope_> @babel en de This won't work.
15:34:37 <lambdabot>  Dieses arbeitet nicht.
15:34:50 <ihope_> @babel de en Dieses arbeitet nicht.
15:34:51 <lambdabot>  This does not work.
15:35:16 <xerox> ihope_: you are very welcome to fix that (-:
15:35:43 <ihope_> lambdabot needs types.
15:36:54 <edwardk> ihope the @. command can't pass arguments to the second. =/
15:37:22 <edwardk> i would be happy if i could just interact with the commands from the > prompt
15:37:23 <edwardk> =)
15:37:33 <edwardk> then i could loop babelfish, etc.
15:37:45 <ihope_> > babel En De "This won't work."
15:37:45 <lambdabot>  Not in scope: data constructor `De'
15:37:56 <edwardk> > babel
15:37:57 <lambdabot>  Not in scope: `babel'
15:38:02 <xerox> @. state babel en de This will work
15:38:04 <lambdabot>  Dieses arbeitet
15:38:04 <lambdabot>  
15:38:15 <xerox> Hmm
15:38:18 <ihope_> @state Hmm?
15:38:18 <xerox> Well
15:38:19 <lambdabot> Hmm?
15:38:26 <xerox> We need @>>= :-)
15:38:28 <ihope_> @state Broken, eh?
15:38:28 <lambdabot> Broken, eh?
15:38:30 <edwardk> >heh
15:38:34 * xerox grins
15:38:44 <ihope_> xerox: and parentheses.
15:38:54 <xerox> ihope_: wrong channel
15:39:10 <ihope_> I should be in #lambdabot?
15:39:16 <xerox> #lisp ? :-P
15:41:47 <dmhouse> ihope_: You could /msg him. :)
15:41:58 <ihope_> /msg who?
15:42:37 <monochrom> lambdabot
15:42:57 <ihope_> But lambdabot's female.
15:43:03 <shapr> hir?
15:43:04 <ihope_> I couldn't /msg him.
15:43:11 * shapr throws lambdas
15:43:45 <monochrom> Oh!
15:46:56 * dmhouse polishes off the Recursion wikibook module
15:47:46 <dmhouse> http://en.wikibooks.org/Haskell/Recursion, for anyone that wants to proofread for me :)
15:47:52 <xerox> shapr: I need some feedback from Isaac, -put is delayed at last to tomorrow, sorry.
15:49:58 <dcoutts> xerox, how's that going btw?
15:50:26 * dmhouse is off. @tell me any feedback on that recursion stuff.
15:50:27 <dibblego> if map is a non-infix function and + is an infix function, where is the declaration that makes the distinction?
15:50:30 <mwc> dmhouse, nothing in the page. Did you save the changes, or are you still on preview
15:50:44 <dmhouse> dibblego: + is all non-alphanumeric characters
15:50:49 <LordBrain> is scheme48 written in haskell?
15:51:07 <mwc> dibblego, for starters, characters are infix operators, they can be made prefix by ( ) enclosure
15:51:10 <dibblego> dmhouse, I see thanks
15:51:11 <dmhouse> mwc, all, http://en.wikibooks.org/wiki/Haskell/Recursion
15:51:15 <sieni> LordBrain: is gcc written in pascal?
15:51:27 <dmhouse> @tell kowey to check out the Recursion module, I gave it a facelift.
15:51:28 <lambdabot> Consider it noted.
15:51:32 <mwc> and then you can make map or the like infix by `map`
15:51:58 <dmhouse> dibblego: http://en.wikibooks.org/wiki/Haskell/More_on_functions#Infix_versus_Prefix might be useful
15:52:01 <LordBrain> sieni: i doubt that
15:52:10 <dibblego> dmhouse, cheers
15:52:11 * edwardk_ sometimes wishes the prelude didn't include numbers. so many more operators would open up then =)
15:52:33 <ihope_> What would happen?
15:52:40 <LordBrain> i asked, because there is the Haskell tutorial, "Write yourself a Scheme in 48 Hours"
15:53:03 <int-e> edwardk_: you can explicitely import the prelude hiding everything you don't like ;)
15:53:17 <dmhouse> LordBrain: that gets you writing a Scheme implementation, supposedly over two days.
15:53:22 <edwardk_> int-e: yeah i know, but thats effort i have to undertake every time =)
15:53:30 <edwardk_> i realize the counter-argument is the same
15:53:34 <LordBrain> i know dmhouse
15:53:36 <edwardk_> and more people want them than don't =)
15:53:47 <edwardk_> but still =)
15:53:49 <LordBrain> i was wondering if it was connected to scheme48, that's all
15:53:53 <ihope_> The Prelude doesn't give the number literals; it gives fromInteger :-)
15:54:08 <shapr> xerox: ok
15:54:16 <syntaxfree> well, writing an interpreter for s-expressions with Parsec is not complicated.
15:54:43 <dmhouse> Right, I was going, I seem to remember.
15:55:03 <shapr> Oh boy! I'll be able to buy Wensleydale!
15:55:17 <ihope_> The island or the cheese?
15:55:19 <edwardk_> shapr?
15:55:20 <shapr> Er, the cheese.
15:55:23 <edwardk_> heh
15:55:40 <shapr> I've never been to the UK, I'll finally be able to see what Wallace is on about.
15:58:25 <xerox> Sent some patches and ideas in...
15:58:39 <xerox> ...I think I'll be reading my CT book now!
15:59:57 <edwardk_> xerox: how are you liking thebook?
16:04:24 <SamB> hmm, either my UM is leaky or UMIX and/or 2d is leaky
16:04:58 <edwardk_> samb:?
16:05:11 <lispy> well, shoot, dlls seem broken after all
16:05:17 <hellish> @eval take 8 $! [1..]
16:05:20 <lispy> you can load them, but unloading them will klil  you
16:05:47 <SamB> ==13982== malloc/free: in use at exit: 34,030,460 bytes in 902,084 blocks.
16:05:47 <SamB> ==13982== malloc/free: 1,418,878 allocs, 516,794 frees, 44,949,524 bytes allocat
16:05:58 <SamB> ==13982== LEAK SUMMARY:
16:05:58 <SamB> ==13982==    definitely lost: 0 bytes in 0 blocks.
16:05:58 <SamB> ==13982==      possibly lost: 34,029,824 bytes in 902,069 blocks.
16:05:58 <SamB> ==13982==    still reachable: 636 bytes in 15 blocks.
16:07:13 <hellish> Oops. Did I break lambdabot? On my system that evaluates to [1..8] with no problems which makes no sense.
16:08:56 <int-e> @run take 8 $! [1..]
16:08:57 <lambdabot>  [1,2,3,4,5,6,7,8]
16:09:01 <int-e> > 1+1
16:09:02 <lambdabot>  2
16:09:09 <hellish> Oh.
16:09:17 <int-e> @help eval
16:09:18 <lambdabot> eval. Do nothing (perversely)
16:09:40 <int-e> dons: why does @eval do nothing?
16:09:54 <int-e> @localtime dons
16:09:56 <lambdabot> Local time for dons is Thu Jul 27 09:03:46 2006
16:10:03 <hellish> Anyway, huh? Shouldn't it keep attempting to evaluate [1..] until the end of time?
16:10:10 <int-e> no
16:10:26 <SamB> hellish: it only has to evaluate the first 8 cells
16:10:43 <int-e> it just evaluates the top constructor; the result is 1 : <unevaluated [2..]>
16:11:52 <hellish> $! doesn't force evaluation of the whole thing in this case?
16:12:11 <SamB> never does
16:12:27 <SamB> (unless the calculation requires it)
16:13:25 <hellish> I thought the point was to force evaluation in order to work around the detrimental effects of laziness.
16:14:26 <SamB> ==14215== malloc/free: in use at exit: 34,030,112 bytes in 902,083 blocks.
16:14:27 <SamB> ==14215== malloc/free: 1,418,878 allocs, 516,795 frees, 44,949,528 bytes allocated
16:14:37 <SamB> ==14215== LEAK SUMMARY:
16:14:37 <SamB> ==14215==    definitely lost: 0 bytes in 0 blocks.
16:14:37 <SamB> ==14215==      possibly lost: 0 bytes in 0 blocks.
16:14:37 <SamB> ==14215==    still reachable: 34,030,112 bytes in 902,083 blocks.
16:15:23 <SamB> that was for edwardk's UM
16:15:31 <SamB> doing the same exact thing
16:16:17 <SamB> I think UMIX & co. leaked 902,083 blocks, and I just don't deallocate array 0 at the end
16:16:53 <SamB> (nevermind that none of them was actually *leaked*)
16:17:36 <SamB> you'd think UMIX&co. would want to free the memory that they have so carefully kept pointers to...
16:23:36 <SamB> hmm, for some reason the 2d compiler didn't seem to notice that I tried to connect to inputs together
16:23:39 <SamB> or two outputs...
16:23:57 <SamB> er, interpreter
16:28:36 <dibblego> func (x:xs) = ... is x always the first element of a list and xs the rest of the list?
16:28:56 <SamB> dibblego: you mean in that case, or in general?
16:29:02 <SamB> in general, it is just a convention
16:29:08 <SamB> in that case, yes
16:29:33 <dibblego> I don't mean the names - I mean is there ever a case where x is the first two elements or is it always one?
16:29:44 <SamB> always one
16:29:50 <dibblego> ok
16:30:06 <SamB> : is just an infix data constructor...
16:30:53 <dibblego> right, so I could have [1,2,3] : [4,5,6]
16:31:11 <dibblego> but for the case of a function declaration, it is always one element, followed by the tail
16:32:11 <SamB> > [1,2,3] : [4,5,6]
16:32:12 <lambdabot>  add an instance declaration for (Num [a])
16:32:12 <lambdabot>   In the list element: 6
16:32:26 <SamB> > [1,2,3] : []
16:32:26 <xerox> ?type (:)
16:32:27 <lambdabot>  [[1,2,3]]
16:32:28 <lambdabot> forall a. a -> [a] -> [a]
16:32:34 <xerox> edwinb: it's been fun so far.
16:32:40 <SamB> dibblego: try ++ instead of : for that ?
16:32:55 <dibblego> oh maybe I mean that
16:33:06 <xerox> ?type (++)
16:33:07 <lambdabot> forall a. [a] -> [a] -> [a]
16:38:15 <SamB> how in the world are you supposed to write this raytracer? are you supposed to write a compiler for 2d?
16:38:26 <SamB> that is, one that outputs 2d?
16:45:50 <vincenz> heh
16:45:54 <vincenz> I wrote one in haskell
16:45:58 <vincenz> lemmih ported it to a minidsl
16:46:01 <vincenz> mapped that to 2d
16:46:07 <vincenz> and I then rewired it a bit to optimize the area
16:55:14 <SamB> were your + and * implementations huge?
16:55:25 <musasabi> Is there any generic way to get from "ST st (m (ST st a))" to "ST st (m a)" or from "m (ST st (m a))" to "m (ST st a)" if m is Monad, but not MonadTrans? (too tired to think straight)
16:56:05 <petekaz> is anyone here familiar with the inards of GHC?
16:56:12 <xerox> ?type join
16:56:14 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
16:56:46 <xerox> Hm, you case seem to be more complex, musasabi :-/
16:56:51 <musasabi> xerox: it is "m (n (m a))" where ST can be either m or n (I can do it either way)
16:57:00 <petekaz> I'm trying to figure out which calls will be treated as 'safe' foreign calls.
16:57:21 <musasabi> petekaz: a foreign call is safe if it 1) does not block, 2) does not call back into Haskell
16:57:28 <petekaz> I.e. are there any internal primitive ops that can block?
16:58:15 <petekaz> Right, but are there any internal calls that GHC makes that end up emitting the suspend/resume thread routine that takes place for 'safe' FFI calls?
16:59:10 <xerox> musasabi: sorry, the former beats me on the semantic side, while I miss how to do m a -> a in general for the latter one.
16:59:17 <petekaz> Or is this a dumb question?  And no primitive ops can block the entire RTS.
16:59:46 <SamB> what is takeMVar?
16:59:51 <xerox> System.Process.waitForProcess does block, but I don't know if it answers your question.
17:00:09 <SamB> (does switching to another thread count as blocking?)
17:00:19 <musasabi> petekaz: there are many such ops (IO and concurrency related)
17:00:43 <xerox> I'd better sleep, goodnight.
17:00:47 <musasabi> night
17:01:02 <petekaz> aren't those done using some form of non-blocking IO?
17:01:33 <musasabi> non-blocking for the OS-thread, but blocking to the haskell thread.
17:01:57 <petekaz> Right.
17:02:51 <petekaz> Ok.  I think you answered my question.  Basically only 'safe' FFI calls will yield the suspend/resume thread code and generated a new OS worker thread (in the threaded RTS).
17:04:02 <musasabi> a thread can be blocked for many reasons and only in some of them a worker is created. (e.g. blocking in STM)
17:04:24 <musasabi> (is an example where no such worker is created)
17:04:41 <petekaz> Right, and 'some' of them is defined only as FFI 'safe' calls right?
17:05:04 <musasabi> yes. IO is mostly done via the FFI
17:05:30 <musasabi> then there are some things like asyncRead# on win32
17:05:39 <petekaz> But IO is done using non-blocking FFI calls right?
17:05:58 <petekaz> So even then no other worker threads are started.
17:12:42 <petekaz> ahh .. its making sense now (just found something in the sources that clarifies).  All those IO FFI calls are 'emitForeignCall' with a safety of 'PlayRisky' which does NOT generate the suspend/resume mechanism used to spawn a new OS worker.
17:12:52 <musasabi> Usually it is done this way on *nix: 1) perform a nonblocking call, 2) check for EAGAIN or return result, 3) threadWaitRead/Write, 4) on threaded RTS wait on a MVar, on non-threaded wait till the scheduler activates us.
17:14:00 <musasabi> On windows things are quite different.
17:15:58 <petekaz> musasabi: in 4), do you mean 'on a haskell that supports concurrency'?  MVars can be used in both threaded RTS and non-threaded RTS right?
17:17:19 <musasabi> petekaz: This is all specific to GHC. It just uses different implementations for things depending whether the RTS is threaded or not.
17:18:05 <petekaz> I understand.  I got confused for a moment.
17:18:31 <petekaz> Thanks for your help.
17:20:20 <musasabi> np, GHC.Conc can be helpful if you want to understand the way IO is done.
17:20:46 <petekaz> the haddock docs?
17:20:56 <petekaz> or is that a file in the source tree?
17:22:51 <petekaz> and one last question, do you know what the ioManagerThread is used for in the threaded RTS?  I.e., when I use the threaded RTS, and make one safe FFI call, I expect a total of 2 OS threads to be active, but I see 3.  I want to know what this 3rd thread is, and going through the sources I see reference to a ioManagerThread, and I assume the 3rd thread is in fact this.
17:25:14 <musasabi> @libsrc GHC.Conc
17:25:15 <lambdabot> http://darcs.complete.org/fptools/libraries/base/GHC/Conc.hs
17:26:40 <musasabi> libsrc seems buggy. The correct URL is http://darcs.haskell.org/packages/base/GHC/Conc.lhs
17:29:26 <musasabi> petekaz: you probably have 1) thread running haskell code, 2) thread doing the safe foreign call, 3) the io manager thread blocking on the safe FFI call on select.
17:29:51 <musasabi> thus 2 FFI threads and one thread running Haskell code.
17:30:40 <petekaz> musasabi: ok ... thanks ... I go search for the ioManagerThread source.
17:32:01 <musasabi> petekaz: the iomanager for threaded RTS is in GHC.Conc. The non-threaded one is in the C source code.
17:32:32 <petekaz> thanks!
17:42:28 * SamB wishes you could write 2d by dragging boxes around...
17:42:59 <int-e> write an editor :P
17:43:09 <mwc> anybody know of some good openssl bindings for haskell? http://cryp.to/hopenssl/ only have digest functions
17:43:11 <lambdabot> Title: hOpenSSL
17:48:21 <emertens> @paste
17:48:21 <lambdabot> http://paste.lisp.org/new/haskell
17:49:44 <lisppaste2> emertens pasted "ST implementation of Kruskal's algorithm" at http://paste.lisp.org/display/23227
17:50:04 <emertens> If anyone was bored and wanted to give me any general feedback on that code, I'd appreciate it
17:50:16 <emertens> specifically relating to things I might have misused or could have done better
17:50:30 <emertens> (the code isn't that long)
17:51:24 <emertens> and no, you wouldn't be doing my homework for me.  I wasn't lucky enough to go to a college that taught haskell :)
18:04:46 <foxy_> @where ghc-api
18:04:47 <lambdabot> http://www.scannedinavian.org/~lemmih/ghc-api/
18:25:07 <emertens> @instances MonadFix
18:25:08 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:32:12 <erka123> hello
18:32:36 <Korollary> hi
18:34:31 <emertens> anyone have any good examples for uses of mfix or mdo?
18:37:18 <Cale> http://www.cse.ogi.edu/PacSoft/projects/rmb/mdoTalk.pdf
18:38:16 <emertens> wonderful, thank you
18:38:30 <emertens> what do I have to import to use mdo?
18:38:45 <Korollary> @index mdo
18:38:45 <lambdabot> bzzt
18:38:54 <Cale> mdo is syntax
18:39:07 <emertens> alright
18:39:07 <Cale> I think you just need -fglasgow-exts
18:39:09 <Korollary> dayum
18:39:19 <emertens> (Visual Haskell underlines it as an error so I assumed)
18:39:22 <Cale> you might also have to import Control.Monad, I can't remember
18:41:47 <musasabi> Control.Monad.Fix should be imported but is not really needed
18:44:29 <musasabi> wrote a very dirty bit of code for references. 60 lines of code with two unsafeCoerce# and unsafeIOToST.
18:58:59 <dons> moring
18:59:48 <foxy_> @seen Lemmih
18:59:48 <lambdabot> Lemmih is in #oasis, #haskell-overflow and #haskell. I last heard Lemmih speak 4 hours, 48 minutes and 41 seconds ago.
19:02:41 <monochrom> @seen lambdabot
19:02:41 <lambdabot> Yes, I'm here. I'm in #instant-chaos, #unicycling, #oasis, #scannedinavian, #haskell.es, #haskell.se, #haskell.it, #perl6, #darcs, #haskell_ru, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-
19:02:42 <lambdabot> blah, #haskell and #Haskell.se
19:03:27 <monochrom> need #haskell.zh  :)
19:03:39 <foxy_> > 1 + 1
19:03:40 <lambdabot>  2
19:04:02 <monochrom> @seen monochrom
19:04:03 <lambdabot> You are in #haskell. I last heard you speak just now.
19:04:12 <monochrom> @seen dons
19:04:13 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 5 minutes and 13 seconds ago.
19:04:13 <foxy_> lambdabot: poke
19:16:32 <dons> :)
19:26:23 <foxy_> dons, have you and Lemmih had any discussion about using ghc-api in Yi?
19:26:49 <dons> not recently, but I expect Lemmih has some ideas on the topic
19:27:01 <dons> i'd like lisp-like eval of haskell fragments
19:27:04 <dons> for example
19:29:07 <foxy_> I just listened to a podcast about McBlair, the bagpiping robot from CMU :)
19:30:15 <dons> yikes!
19:35:42 <sylvan> Are there any good reasons for not just replacing do with mdo in Haskell-Prime? It may break some tiny bit of code (shadowing, what else?) but it's generally much better right?
19:36:05 <musasabi> sylvan: breaking lots of code.
19:36:26 <musasabi> "do x <- foo x; x <- bar x; ..." is quite common
19:36:46 <musasabi> (add more arguments so it makes sense)
19:37:19 <sylvan> It is? It shouldn't be! Shadowing should be avoided IMO and I'm not sure it should be allowed even without mdo! :-)
19:37:31 <syntaxfree> I'm not sure if I already installed Cabal. What's a simple way to check?
19:38:00 <musasabi> ghc-pkg -L | grep Cabal
19:38:30 <syntaxfree> Mingus:~ syntax$ ghc-pkg -L
19:38:30 <syntaxfree> rts, base, haskell98, haskell-src, network, parsec, QuickCheck,
19:38:30 <syntaxfree> readline, unix, lang, concurrent, posix, util, data, text, net,
19:38:30 <syntaxfree> hssource, wxcore, wx
19:38:37 <syntaxfree> um, but I don't have wx. Compilation failed.
19:38:53 <syntaxfree> and where is fps/Data.ByteString? :'(
19:39:03 <sylvan> I like the comparison to let/letrec in other languages, Haskell doesn't have it, so why should we have do/mdo
19:39:06 <syntaxfree> @where cabal
19:39:06 <lambdabot> http://www.haskell.org/cabal
19:39:37 <dons> ?uptime
19:39:38 <lambdabot> uptime: 8 days, 10 hours, 55 minutes and 14 seconds
19:39:46 <musasabi> sylvan: If redesigning then it would make sense - and for a major revision of the language that is expected to break lots of code.
19:40:19 <sylvan> Is it really "lots"? I mean Haskell-Prime isn't supposed to break too much code, but would this really be an unacceptable amount?
19:40:44 <musasabi> sylvan: also what would the type of: "do return ()" be if the change would be made?
19:41:36 <musasabi> currently it is "Monad m => m ()", but with mdo it is "MonadFix m => m ()"
19:41:38 <syntaxfree> what can I do if a makefile expects ghc to be at /usr/bin, but it's at /usr/local/bin?
19:41:38 <sylvan> depends on how you use it I guess.
19:42:12 <sylvan> Well I would think that do would be mdo in a monad which is an instnace of MonadFix, but not when it isn't
19:42:19 <sylvan> (you'd still disallow shadowing to be consistent)
19:43:20 <sylvan> "do" is already "hardcoded" to the Monad class' functions, so it's not such a big step to hardcode it so that it would choose MonadFix if possible.
19:43:44 <musasabi> so the compiler would first analyze whether a do-block has recursion and based on that assign the type for it?
19:43:59 <musasabi> the current hardcoding is a trivial one
19:45:15 <sylvan> musasabi, well yes.
19:45:32 <sylvan> Or add mfix to Monad
19:45:56 <musasabi> Can all monads be mfix:ed?
19:46:12 <sylvan> not sure.. I'm trying to think of some that can't...
19:49:26 <musasabi> Continuation monad seems hard
19:51:06 <syntaxfree> bah. Installation of Cabal just failed.
19:51:28 <syntaxfree> It seems all ok.
19:51:41 <syntaxfree> then ghci -package Cabal  goes ghc-6.2: unknown package name: Cabal
19:51:54 <syntaxfree> I mean, the whole thing compiles without errors, and so does make install.
19:51:57 <musasabi> sylvan: the require MonadFix if it is recursive could work nicely it seems (not too hard to do even)
19:52:55 <sylvan> wonder if it's being considered for H'
19:53:11 <sylvan> it's *really* useful for writing interfaces
19:53:46 <sylvan> no more "step 1: Create a bunch of widgets with no properties, step 2: set the properties referencing other widgets"
19:54:22 <sylvan> *graphical* interfaces; i mean
19:54:36 <musasabi> http://hackage.haskell.org/trac/haskell-prime/wiki/RecursiveDo
19:54:38 <lambdabot> Title: RecursiveDo - Haskell Prime - Trac
19:56:03 <musasabi> "Adopt: probably no"
19:58:05 <sylvan> too bad
20:05:17 <syntaxfree> God, I hate trying to install third-party Haskell  packages.
20:05:30 <syntaxfree> I wish there was a one-stop container with all that Hope needs.
20:06:47 <monochrom> Most GUIs are to be programmed in the IO monad.  The IO monad has mfix.
20:06:49 <musasabi> syntaxfree: you might want to start with GHC 6.4.2 to make things a little easier.
20:07:09 <syntaxfree> I have GHC 6.4.2. Somehow, the fink GHC prevailed.
20:07:12 <syntaxfree> but now, looky.
20:07:13 <syntaxfree> Mingus:~/downloads/HSQL/MySQL syntax$ /usr/local/bin/runghc Setup.lhs configure
20:07:13 <syntaxfree> Could not find module `Distribution.Simple.Utils':
20:07:13 <syntaxfree>   use -v to see a list of the files searched for
20:07:13 <syntaxfree>   (imported from Setup.lhs
20:07:23 <syntaxfree> that runghc is from 6.4.2
20:07:38 <syntaxfree> what *is* Distribution.Simple.Utils?
20:07:44 <dons> its part of cabal
20:07:45 <musasabi> part of Cabal
20:07:50 <dons> why are you using runghc, btw/
20:08:03 <dons> does it have different semantics to runhaskell, anyone know?
20:08:09 <dons> i.e. no --make ?
20:08:13 <musasabi> syntaxfree: I think your problem is that things get installed to the wrong version of GHC due to it being first in the PATH.
20:08:29 <monochrom> runhaskell does not exist.
20:08:30 <dons> ah, that could be it
20:08:45 <syntaxfree> I just tried ghc-pkg -l on the right GHC, and there things are installed.
20:08:57 <syntaxfree> My problem is that I'm tangled up  in undocumented dependencies.
20:09:41 <syntaxfree> or presumes-Linux installation scripts.
20:10:12 <syntaxfree> anyway, how do I go about obtaining Distribution.Simple.Utils?
20:10:52 <petekaz> dumb question: in the ghc sources, I keep seeing reference to 'STG' and 'TSO'.  What are those acronyms for?
20:11:21 <syntaxfree> Three Saltitant Orthodontists, what else?
20:11:58 <petekaz> @slap syntaxfree
20:11:58 * lambdabot smacks syntaxfree about with a large trout
20:12:37 <syntaxfree> you mean you don't know about the Saga of the Tangled Gnomes?
20:13:55 <musasabi> STG = spineless tagless G-machine
20:13:56 <petekaz> Nevermind, I found it.
20:14:11 <syntaxfree> Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones.
20:14:36 <syntaxfree> What actually happened is that during a functional programming conference, some key academics were teleported to the Deep Complex Universe.
20:14:51 <syntaxfree> in the Deep Complex Universe some Gnomes were having Tangling problems.
20:15:17 <syntaxfree> Wadler & friends solved their problems and as a reward the Tangled Gnomes gave them the Secret of Haskell.
20:15:25 <musasabi> petekaz: have you looked at http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/ - it might help understanding GHC.
20:15:26 <lambdabot> Title: The GHC Commentary - The Beast Explained
20:16:01 <monochrom> Why couldn't the Gnomes use the Secret of Haskell to solve their own problems?
20:16:04 <syntaxfree> not wanting to be regarded as loonies, these fine people decided to reveal the Secret slowly as if it was the progressive result of years of painstaking research.
20:16:28 <syntaxfree> monochrom: ah, my friend, you overestimate the power of computer programming.
20:16:58 <syntaxfree> the Tangled Gnomes had been Tangled by the Three Saltitant Orthodontists.
20:17:00 <petekaz> musasabi: just found it about 30 seconds ago.  I had been reading the part on concurrency and the threaded RTS, but didn't realize that that section was part of a larger in scope doc.
20:17:28 <monochrom> OK.  If Phil and Simon could solve this super-difficult problem, why couldn't they come up with Haskell themselves?
20:17:58 <syntaxfree> because defeating the Three Salittant Orthodontists is not a matter of intellectual problem-solving alone, my friend.
20:18:21 <monochrom> That doesn't answer my question.
20:18:50 <dons> syntaxfree: quoted!
20:18:52 <syntaxfree> the Tangled Gnomes, while they carrry great knowledge since the old days of Purple Snow, don't have the inner "force", to use a popular movie analogy, that ordinary humans have.
20:19:26 <syntaxfree> It's not merely a matter of sheer intellectual brilliance.
20:19:39 <syntaxfree> Defeating the Three Saltitant Orthodontists was a question of *humanity*.
20:21:14 <syntaxfree> now can you *please* explain how can I go about obtaining Distribution.Simple.Utils?
20:21:17 <monochrom> I prefer to believe the more logically consistent: in the process of untangling the Gnomes, Phil and Simon invented Haskell.
20:21:35 <dons> syntaxfree: you need to make sure the compiler you're using has an up-to-date cabal, I think.
20:21:40 <syntaxfree> you, my friend, overestimate the extent of your own logical powers.
20:21:44 <dons> somehow you've mixed things up in your system.
20:21:52 <syntaxfree> um.
20:22:10 <syntaxfree> Mingus:~/downloads/HSQL/MySQL syntax$ ghc-pkg -l
20:22:10 <syntaxfree>     rts-1.0, base-1.0, haskell98-1.0, template-haskell-1.0, unix-1.0,
20:22:10 <syntaxfree>     parsec-1.0, haskell-src-1.0, network-1.0, QuickCheck-1.0,
20:22:10 <syntaxfree>     HUnit-1.1, mtl-1.0, fgl-5.2, X11-1.1, HGL-3.1, OpenGL-2.0,
20:22:10 <syntaxfree>     GLUT-2.0, stm-1.0, readline-1.0, (lang-1.0), (concurrent-1.0),
20:22:10 <syntaxfree>     (posix-1.0), (util-1.0), (data-1.0), (text-1.0), (net-1.0),
20:22:12 <syntaxfree>     (hssource-1.0), (plugins-0.9.10), (Cabal-1.1.4), fps-0.1, fps-0.7,
20:22:14 <syntaxfree>     Cabal-1.0
20:22:17 <dons> there you go.
20:22:20 <dons> (Cabal-1.1.4)
20:22:24 <syntaxfree> ummm.
20:22:27 <dons> your new cabal is hidden
20:22:29 <syntaxfree> how do I obtain that?
20:22:33 <dons> and you've only got old bog standard cabal
20:22:39 <dons> which is mising thingies
20:23:05 <syntaxfree> so, how do I fix that?
20:23:09 <monochrom> Is there a reason to use ghc 6.2 and not ghc 6.4.2?
20:23:17 <syntaxfree> I'm using 6.4.2
20:23:38 <syntaxfree> at one point, I quoted a ghc 6.2 comment because I was in a terminal window with the wrong PATH variable.
20:23:50 <monochrom> Ah.
20:23:51 <syntaxfree> The whole process was done at a bash session with the right PATH variable, not including the fink tree.
20:24:16 <dons> anyway, the right combination of ghc-pkg hide and ghc-pkg expose might do it
20:24:28 <dons> but what the right combination is, you'll need to ask the Gnomes
20:24:38 <dons> maybe they will reveal it, for a price..
20:25:03 <syntaxfree> where was I quoted? ;)
20:25:11 <dons> hopefully that is just the usual 3 riddles they ask you to solve
20:25:17 * dylan does /lastlog -file insane-haskell-people.log
20:25:29 <dons> *cough*
20:25:34 <dons> oh dear
20:25:40 <dons> ?quote syntaxfree
20:25:40 <lambdabot>  Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional programming conference,
20:25:40 <lambdabot>  some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their problems and as a reward the
20:25:40 <lambdabot> Tangled Gnomes gave them the S
20:25:42 <dons> that's where
20:25:47 <dons> oh, chopped?
20:25:54 <dons> we need multiline-quote, it seems
20:25:56 <syntaxfree> yeah, at the best part ;)
20:26:15 <dons> the Tangled Gnomes gave them the S
20:26:24 <dons> makes sense to me
20:26:29 <dylan> The funny thing is, I was just having a conversation about gnomes with my girlfriend's son. I was explaining about the gnomes that live in the closet and steal bacon...
20:26:32 <Korollary> dons: runghc and runhaskell seem to be identical executables
20:26:42 <dons> Korollary: ah, there you go
20:26:45 <dons> dylan: hehe
20:27:19 <monochrom> runhaskell is syntaxpolice's debianism.
20:27:33 <dons> no no. its everywhere.
20:27:33 <monochrom> it is unheard of if you don't use the debs
20:27:41 <dons> nuh uh.
20:27:45 <dons> it comes with ghc now
20:27:48 <Korollary> does hugs provide a runhaskell?
20:27:56 <dons> i think it does now too.
20:27:58 <monochrom> I be damned.
20:28:10 <dons> $ uname -msr
20:28:11 <dons> OpenBSD 3.8 i386
20:28:11 <dons> $ runhaskell --version
20:28:11 <dons> The Glorious Glasgow Haskell Compilation System, version 6.4.2
20:28:16 <syntaxfree> Mingus:~/downloads/HSQL/MySQL syntax$ sudo runghc Setup.lhs configure
20:28:16 <syntaxfree> Setup.lhs: Warning: No license-file field.
20:28:16 <syntaxfree> Configuring hsql-mysql-1.7...
20:28:16 <syntaxfree> configure: Dependency base-any: using base-1.0
20:28:16 <syntaxfree> Setup.lhs: cannot satisfy dependency hsql-any
20:28:18 <syntaxfree> now WHAT?
20:28:27 <dons> syntaxfree: recurse.
20:28:42 <syntaxfree> recurse?
20:28:46 <dons> it tells you what youre missing. check your ghc-pkg if you think its there (it might have been hidden by something)
20:28:48 <Korollary> curse again?
20:28:55 <dons> if its now there, find hsql and install it
20:28:59 <dons> s/now/not/
20:29:12 <syntaxfree> but it's precisely HSQL that I'm trying to install!!!
20:29:23 <monochrom> C'est odd.  Very odd.
20:29:25 <dons> looks like your in MySQL?
20:29:33 <monochrom> Ah!
20:29:46 <syntaxfree> oh. there's a base HSQL to be installed?
20:29:49 <Korollary> why sudo setup?
20:29:51 <syntaxfree> The README file suggestedotherwise.
20:29:54 <dons> so you've jumped ahead one step, by accident, by buliding it with the wrong flags
20:29:56 <monochrom> Yeah, cd .. , try again
20:29:58 <dons> or in the wrong dir
20:30:00 <dons> right
20:30:15 <syntaxfree> there's no Setup.lhs in the base directory.
20:30:29 <syntaxfree> again, the README file suggests I need to build HSQL-MySQL directly.
20:30:40 <monochrom> You are tempting me to install HSQL myself to see the problem!
20:30:47 <dons> check the build instructions, if its a multi-package system, they might have a meta-cabal build, using make or something
20:31:05 <syntaxfree> It's an OS X machine. The Haskell package world is filled with linuxisms, it seems.
20:31:09 <Korollary> well, if hsql-mysql is goign to depend on hsql, it's not happening.
20:31:17 <dons> yeah, that's clear.
20:31:32 <dons> so you have to find the actual hsql first
20:31:42 * dons tries to inductively reconstruct the hsql build system
20:32:06 * Korollary sees into the future
20:32:14 <syntaxfree> OH.
20:32:16 * monochrom uses co-induction
20:32:27 <syntaxfree> the GENIUS human computer interaction people behind HSQL...
20:32:35 * Korollary throws keal-grade math jargon at people
20:32:37 <syntaxfree> ... put the base package in HSQL/HSQL/
20:32:47 <syntaxfree> that is just BRILLIANT.
20:32:55 <dons> syntaxfree: complain not, lest you be asked to write a patch
20:33:09 <monochrom> Or to solve a Gnome problem.
20:33:54 <dylan> so, if haskell has monads, that means the gnomes must have gonads, right?
20:34:01 <dons> hah!
20:36:42 <syntaxfree> KILL KILL KILL.
20:37:00 <syntaxfree> I've already removed THE ENTIRE FINK TREE, why oh why DOES IT KEEP ON LOOKING FOR STUFF AT /SW/BIN?
20:37:12 <syntaxfree> it's not in the PATH :'(
20:38:44 <monochrom> You can't call PATH a Linuxism. :)
20:39:41 <monochrom> Is /sw/bin hardcoded in "IT"?
20:40:47 <syntaxfree> there's no portability in the Unix world.
20:40:48 <syntaxfree> What a lie.
20:43:15 <syntaxfree> quick unix reference.
20:43:29 <syntaxfree> how do I create a symlink for /sw/bin/hsc2hs to /usr/local/bin/hsc2hs?
20:45:23 <Korollary> ln -s source target
20:45:32 <Korollary> target is /sw...
20:46:09 <Dino_> pushd /usr/local/bin; ln -s /sw/bin/hsc2s; popd
20:46:31 <Dino_> You ought to need to be root for that, or sudo.
20:48:39 <syntaxfree> good lord I feel like I'm dying.
20:48:44 <Korollary> no
20:48:48 <Korollary> that would be worse
20:50:43 <syntaxfree> hehe. pushd/popd rules.
20:50:48 <syntaxfree> I love stack structures.
20:51:47 <emertens> when something is named with the suffix of ST, what does that typically imply?
20:52:34 <monochrom> It is related to the ST monad.
20:53:08 <syntaxfree> you know what?
20:53:10 <syntaxfree> I give up.
20:53:18 <syntaxfree> I have one-click access to a MAMP stack.
20:53:29 <petekaz> Anyone ever make an epoll patch for GHC to avoid select() porr performance with large numbers of descriptors?
20:53:40 <petekaz> s/porr/poor
20:54:13 <emertens> is the ST monad GHC specific?
20:54:29 <dons> petekaz: there's been talk of it
20:54:37 <dons> check the ghc mailing list archives for details
20:54:47 <dons> probably on glasgow-haskell-users and cvs-ghc ?
20:54:55 <emertens> (I don't actually use any of the other compilers, but it just seems that a lot of the functions are in the GHC namespace)
20:54:56 <dons> I think, just possibly, eivuokko_ was involved.
20:55:26 <petekaz> dons: ok ... found a ticket for it in trac.
20:55:32 <dons> ST is a general thing, emertens
20:55:35 <dons> ?hoogle ST
20:55:37 <lambdabot> Control.Monad.ST :: module
20:55:37 <lambdabot> Data.Array.ST :: module
20:55:37 <lambdabot> Control.Monad.ST.ST :: data ST s a
20:55:48 <dons> just means 'State' of some kind
20:55:55 <dons> ?hoogle+
20:55:56 <lambdabot> Control.Concurrent.STM :: module
20:55:56 <lambdabot> Data.STRef :: module
20:55:56 <lambdabot> Data.STRef.STRef :: data STRef s a
20:56:04 <dons> except in Control.Concurrent.STM
20:56:08 <dons> that's something else entirely
20:56:10 <dons> ?hoogle+
20:56:10 <lambdabot> GHC.Conc.STM :: data STM a
20:56:11 <lambdabot> Data.Array.ST.STArray :: data STArray s i e
20:56:11 <lambdabot> Data.Array.ST.STUArray :: data STUArray s i a
20:56:25 <dons> so we have ST arrays, ST refs, the ST type, the ST module.
20:56:32 <dons> handling state is a big deal :)
20:56:49 <petekaz> Performance of GHC in a non-threaded RTS must get very poor with a large number of open file descriptors due to the constant select()ing done in the scheduler loop.
20:57:21 <petekaz> At least the threaded RTS has the io manager in a separate OS thread.
20:59:52 <dons> ?yow!
20:59:53 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me to
20:59:53 <lambdabot> Minnesota but don't EMBARRASS me!!
21:00:02 <dons> crazy stuff
21:00:14 <syntaxfree> ?suicide
21:00:14 <lambdabot> Unknown command, try @list
21:04:05 <monochrom> Hugs probably has the ST monad and associated libraries too.
21:04:40 <dons> surely does. if its not in GHC.*, its probably in hugs then
21:05:33 <dons> and ST is quite old. from the early monad days. Control.Monad.ST:
21:05:36 <dons> -- This library provides support for /strict/ state threads, as
21:05:36 <dons> -- described in the PLDI \'94 paper by John Launchbury and Simon Peyton
21:05:37 <dons> -- Jones /Lazy Functional State Threads/.
21:09:03 <emertens> I've actually got that paper printed out
21:09:08 <emertens> and sitting on my coffee table
21:09:17 <emertens> I suppose I should read it now :)
21:09:20 <edwardk> well, we also have http://www.haskell.org/ghc/docs/6.4.2/html/libraries/base/Control-Monad-ST-Lazy.html no?
21:09:59 <dons> edwardk: how'd the JITted UM go?
21:10:19 <edwardk> dons: haven't been able to work on it, been stuck with various crises in the world of linguistics
21:10:25 <edwardk> I should probably get cracking on it now =)
21:10:33 <dons> I'm still interested in an FFTW-style haskell um, that spits out the C or asm in an initial pass
21:10:44 <edwardk> yeah
21:10:46 <dons> any thoughts on that?
21:10:59 <edwardk> I kinda thought about that way of going about it but I don't have your c plugins interface yet =)
21:11:04 <dons> the self-mod code creats problems, yes?
21:11:12 <dons> well, i can hack one up in 30 mins or so, if we need it
21:11:13 <edwardk> i'm generating haskell on my initial pass
21:11:22 <dons> ok. good idea
21:11:24 <dons> then we can generate C
21:11:28 <edwardk> i could just as easily generate c
21:11:38 <dons> so just use haskell functoins that map to C easily
21:11:45 <dons> incrementPC and such
21:12:25 <edwardk> basically what i'm doing is jitting from a finger address to a function, where the code is everything in the run up until the halt or loadprog
21:12:30 <dons> its this kind of problem that a runtime-generated C pass, in haskell, would shine. we work around any deficits in the ghc code gen, by generating our own code
21:12:37 <edwardk> i never explicitly increment a PC =)
21:12:41 <dons> ok.
21:12:46 <dons> i've posted some more ums
21:12:49 <edwardk> the only time the PC is used is during the jump, and its constructed anew then
21:12:57 <edwardk> so i don't need one in the jit
21:13:03 <dons> one guy's does instructoin combining, where multiple instructoins can be optimised into 1
21:13:13 <dons> oh, that's good
21:13:29 <edwardk> yeah i'm playing with deferring register writes until the absolute last second.
21:13:37 <edwardk> basically turning UM ops into 'uops' =)
21:13:45 <edwardk> because not alll of the writes are needed
21:13:49 <dons> yep
21:14:04 <edwardk> a good portion of the stuff is just 'load reg' 'orthography' 'load reg' 'orthography'
21:14:08 <edwardk> so i can optimize that down
21:14:38 <edwardk> i'm probably dragging in too much haskell baggage, but i haven't learned the way of efficient code in haskell yet
21:14:44 <edwardk> and i figure its easy to optimize once it works
21:14:51 <dons> sure.
21:15:03 <dons> -ddump-minimal-imports is useful
21:15:09 <dons> to at least find dead module immports
21:15:12 <edwardk> oh
21:15:15 <edwardk> i did have a question for you
21:15:18 <edwardk> on the plugins stuff
21:15:37 <edwardk> i'm currently playing with using eval and importing the API, is that the best way to construct a function?
21:15:51 <dons> yeah, that soudns reasonable
21:16:03 <dons> so you want to create new functions on the fly, yes?
21:16:06 <dons> and then apply them
21:16:07 <edwardk> yeah
21:16:22 <edwardk> i want to create a new function, and then stuff it into my table of pre-jitted functions indexed by finger
21:16:24 <dons> eval is the way to go. but there's a compilation cost on each call
21:16:30 <edwardk> then whenever i get a load to array 0 i flush the cache.
21:16:32 <dons> so you want to have a large number in each go
21:16:41 <dons> excellent idea
21:17:11 <edwardk> i only have one jit to do at a time because i don't know where the next one will start until something jumps there
21:17:30 <edwardk> i might be able to skim the opcode set for patterns that write to a register a fixed value and then call loadprog, but thats speculative
21:17:30 <dons> ok
21:18:10 <edwardk> i would need to build some sort of 'known state' automaton that could skim code
21:18:14 <edwardk> and that gets tricky
21:18:24 <edwardk> i'm trying to adopt the standard jit practice of well... er just jitting =)
21:18:37 <dons> :)
21:19:27 <edwardk> how much faster would the c plugin interface be to compile?
21:20:11 <edwardk> coz the haskell one will only be able to bet case catch up with one of the slower c++ ones i think
21:20:17 <edwardk> er best
21:21:18 <dons> right
21:21:22 <dons> but gcc is damn fast
21:21:24 <edwardk> so if i had a simple function i could call from c that compiled it probably knock the socks off the haskell one you know what?
21:21:39 <edwardk> i might just do that
21:21:46 <edwardk> its not that bad to write something to call gcc and compile
21:21:54 <dons> yeah. i agree
21:22:00 <dons> its just the code generation stuff is nicer in haskell
21:22:09 <edwardk> yeah
21:22:15 <dons> ideally though, you do a single pass in haskell, generate C, and jump
21:22:16 <edwardk> i do admit i love the haskell plugins interface
21:22:24 <dons> oh, really :)
21:22:25 <dons> that's good.
21:22:37 <dons> i spent the first couple of months of my phd thinking about the interface
21:22:39 <edwardk> unfortunately i can't do it in one pass, hello, jit =)
21:22:48 <dons> yes
21:23:47 <edwardk> bah, going to finish up the haskell one since i have so much effort into it
21:23:51 <edwardk> and i want to see it perform
21:24:05 <dons> > -2^2
21:24:06 <lambdabot>  -4
21:24:09 <dons> > 0-2^2
21:24:10 <lambdabot>  -4
21:24:31 <dons> ah good. in haskell 1.0, -2^2 == 4
21:26:42 <edwardk> ack
21:27:59 <edwardk> heh, i am amused that that minimal c implementation is holding up so well in the um pissing contest.
21:28:36 <dons> yeah :)
21:28:56 <dons> but people aren't submitting new haskell ones :/
21:29:01 <edwardk> yeah
21:29:12 <edwardk> you're just getting all the c implementations that people sheepishly generated
21:29:24 <edwardk> after finding out their pet language was too slow =)
21:29:47 <edwardk> I would think something like Ocaml would have generated a nice high speed implementation.
21:30:06 <dons> hmm, maybe.
21:30:10 <emertens> isn't this year's ICFP contest over?
21:30:15 <dons> they're pretty much the same as haskell these days though
21:30:15 <edwardk> yeah
21:30:26 <edwardk> we're just bored and playing witht he UM
21:30:28 <dons> some better libs, we only just got a strict packed string type, for example
21:30:32 <emertens> I figured as much
21:30:35 <emertens> but I wasn't sure
21:30:39 <edwardk> in my case primarily coz i want to prototype some jitting in haskell
21:30:43 <Korollary> Ruby!
21:31:12 <dylan> well, someone was asking about unsigned 32bit ints in #ocaml a while ago
21:31:17 <dylan> I imagine that was for a UM.
21:31:24 <dons> ah, quite probably :)
21:31:33 <emertens> are the results in for this years competition?
21:31:33 * edwardk is probably overkilling the jit pass, i'm transforming them into a data type, then transforming from there to the string.
21:31:48 <dons> emertens: no, not announced till icfp
21:31:57 <dylan> it seems there were at least two caml teams in this year's contest.
21:32:00 <emertens> I'll stop asking dumb questions and proceed to read icfpcontest.org :)
21:32:04 <dons> dylan: oh i think many more
21:32:10 <dons> there was at least 5 haskell teams
21:32:11 <edwardk> i think i might actually go to icfp this year.
21:32:13 <dylan> well, two obvious ones.
21:32:23 <dylan> "Caml Riders", and another one with Caml in the name
21:32:25 * dons greps for Caml in the scorebard
21:32:38 <dons> i count 6
21:32:52 <dylan> Cool. Not very high-scoring though, eh?
21:32:57 <edwardk> heh yeah but by that logic there was an assembly team ;)
21:33:03 <dons> The Caml Riders, INTERCAmL, CamlNuggets are in the top 20
21:33:19 <dons> The lone Camlist, Super Turbo Caml Puncher 2
21:33:26 <dons> ocamlman
21:33:40 <dons> but the haskell teams are more cryptic
21:33:46 <dons> like "Lazy Bottoms"
21:33:48 <dylan> ocaml people can cheat and use C a bit easier, I think. ;)
21:34:11 <dons> do you mean, they can switch to C with more ease?
21:34:21 <edwardk> dons, hrmm, to generate a function via eval, how would that work? lambda expression or can i give it a full signature?
21:34:22 <dylan> I mean, they could mix C and ocaml a bit easier.
21:34:48 <edwardk> or is it implicitly wrapped in some sort of 'eval = ' baggage behind the scenes
21:34:49 <dylan> e.g. 'ocamlopt vm.c something.ml somethingelse.ml -o umvm'
21:34:49 <dons> oh, that's easy in haskell too. unless ocaml has some special features?
21:35:07 <dons> sure, but that's like ghc cbits.o main.hs -ffi ?
21:35:20 <dylan> except ocamlc calls gcc for you.
21:35:26 <dons> as does ghc
21:35:31 <dons> ghc foo.c is a C compiler!
21:35:36 <edwardk> heh
21:35:48 <edwardk> used that the other day
21:36:05 <dons> dylan: are there other things that make using C easier from OCaml?
21:36:11 <dons> how do you do a foreign import?
21:36:21 <dylan> two possible ways.
21:36:30 <dylan> in a module interface, you can go:
21:36:43 <emertens> The only ICFP task I've played with was the AI for the game of Pousse
21:36:52 <emertens> mostly because it was short enough to do at work one day
21:37:03 <dylan> external add : int -> int -> int = "myfunc_add"
21:37:04 <edwardk> dons: ok, how can i eval to generate a function of signature: World a => Word32 -> Word32 -> Word32 -> Word32 -> ... -> a ()?
21:37:11 <dons> dylan: oh, here's an example of using C with Haskell to solve a task, http://www.haskell.org/haskellwiki/Wc
21:37:13 <lambdabot> Title: Wc - HaskellWiki
21:37:14 <edwardk> er type annotation
21:37:31 <dons> dylan: ah, like: foreign import "myfunc" :: Int -> Int -> Int in Haskell
21:37:40 <dylan> basically.
21:37:49 <dons> what's the other way?
21:37:54 <dylan> Now, as long as you have "external.." in an implementation file, you could write:
21:38:03 <dylan> val add : int -> int -> int
21:38:16 <dons> oh, that's interesting.
21:38:21 <dylan> and everyone but the module will know it's really a C function.
21:38:35 <dylan> You must have the 'external' declartion in the implementation file, though
21:38:55 <dylan> humph. My spelling is starting to degrade, I should sleep soon.
21:39:09 <dylan> anyway, the said C function has to be ocaml-compliant.
21:39:11 * edwardk bottlenecks waiting for a reply and goes to get something to drink.
21:39:13 <dylan> e.g.
21:39:28 <dons> ocaml compliant, eh?
21:39:32 <dylan> one second
21:39:54 <dons> edwardk: the usual way. what's the problem? getting the dictionary?
21:40:17 <dons> you'll need to use a wrapper. it's mentioned in the hs-plugins paper, iirc
21:40:22 <edwardk> dons: well, eval seems tuned to evaluating an expression
21:40:30 <dons> it just returns a value
21:40:35 <dons> so that value could be a function
21:40:41 <dons> you'll need to put the right type signature on it
21:40:49 <edwardk> hence my confusion coz i've never had to generate a lambda expression that needed a dictionary
21:41:03 <dons> > (\x -> x) :: Int -> Int -- eval producing a function
21:41:04 <lambdabot>  <Int -> Int>
21:41:27 <edwardk> the dons: yeah, ok, so the answer is 'use the lambda function' =)
21:41:40 <dons> well, it could be a let i suppose
21:41:47 <dons> > let f x = x in f :: Int -> Int
21:41:48 <lambdabot>  <Int -> Int>
21:42:01 <dylan> dons: http://pastebin.be/1538/
21:42:07 <edwardk> i was trying to figure out if that or let foo :: ....; foo a b c d e f g h = ... in foo
21:42:08 <dons> the monomorphic type is just for 'Show' (hehe)
21:42:09 <edwardk> would be cleaner
21:42:36 <dons> dylan: oh, very interesting!
21:42:44 <edwardk> or foo where foo :: (type); foo a b c d e f g h = ...
21:42:48 <dons> so you are doing the marshalling on the C side??
21:42:53 <dylan> dons: Int_val() and Val_int() are constant functions.
21:43:05 <dylan> as ints are not boxed.
21:43:12 <dylan> (one bit is reserved though)
21:43:20 <dons> ok, but you can't just mix any C in?
21:43:25 <dylan> The C side is basically untyped
21:43:40 <dons> here's a C fragment I use in my bytestring library
21:43:41 <dons> unsigned char fps_minimum(unsigned char *p, int len) {
21:43:41 <dons>     unsigned char *q, c = *p;
21:43:41 <dons>     for (q = p; q < p + len; q++)
21:43:43 <dons>         if (*q < c)
21:43:44 <dylan> well, you need to wrap and unwrap C values as the type 'value'
21:43:45 <dons>             c = *q;
21:43:47 <dons>    
21:43:58 <dons> the foreign import handles the wrapping and unwrapping of the arguments from and to haskell values
21:44:15 <dylan> there's a seperate tool, camlidl, which auto-generates those type converstion routines.
21:44:29 <edwardk> hrmm does haskell have a heredoc? i seem to recall something about ghc offering one
21:44:30 <dylan> it'd seem haskell's ffi is cleaner.
21:44:31 <dons> huh. i think this might actually be more complicated than the haskell ffi
21:44:47 <dons> edwardk: no. but you've got unlines [], or string gaps
21:44:57 <edwardk> how do string gaps work?
21:44:58 <dylan> it's amazingly simple compared to python, perl, and even ruby. :)
21:45:12 <dons> dylan: not surprising though, since it was with the benefit of ocaml and so on already having done their's
21:45:30 <dons> i think that was on of the reasons to move marshalling onto the haskell side of things
21:45:37 <edwardk> just backslash the cr?
21:45:49 <dons> > "xya /     / more stuff"
21:45:50 <lambdabot>  "xya /     / more stuff"
21:45:55 <dons> oh my bad
21:46:00 <dons> > "xya \     \more stuff"
21:46:01 <lambdabot>  "xya more stuff"
21:46:05 <edwardk> alrighty
21:46:08 <edwardk> pretty standard stuff
21:46:48 <dylan> dons: I think the ocaml FFI has more to do with the design of the ocaml bytecode interpreter, and the compiler's calling conventions.
21:47:00 <dons> ah that too, yes.
21:47:25 <dylan> it's 'raw'. It is arguable that camlidl is more equiv. to haskell's FFI, and the CAMLparam stuff is an implementation detail.
21:47:35 <dons> yeah
21:47:36 <dylan> (of course, there is only one implementation of ocaml...)
21:47:51 <dons> since we have the compiler generating all our type conversions from the foreign import/export
21:48:09 <dons> so that works with bytecode/ghci too, for example
21:48:39 <dons> dylan: oh that too. having several haskell compilers made people sit down and think up a good interface
21:48:50 <dons> that would work across ghci, hugs, nhc and ghc
21:49:12 <dons> so it had to deal with very different systems, forcing the marshalling logic into the compiler, and away from the user
21:49:31 <audreyt> dons: my OSCON talk went very well!
21:49:40 <audreyt> (and I managed to get some haskell advocacy in)
21:49:48 <dons> yay!
21:49:50 <dons> slides??
21:49:57 <audreyt> and this year they have 3hr tutorial on haskell anyway
21:50:05 <audreyt> it's definitely getting there
21:50:06 <dons> huh
21:50:14 <audreyt> slides: http://pugs.blogs.com/talks/oscon-rhox.pdf
21:50:26 <dons> a 3hr tutorial on haskell at OSCON. wow
21:50:40 <audreyt> I got the course material.
21:50:42 <audreyt> it's not bad
21:50:50 <audreyt> though too much at "why you need to learn this"
21:50:58 <audreyt> instead of expliaining concepts
21:51:02 <dons> yeah ok.
21:51:06 <audreyt> also, putting IO to the last chapter, big mistake.
21:51:10 <dons> we need to move beyond the "this is good for you"
21:51:11 <audreyt> but otherwise solid
21:51:22 <dons> ah, common mistake, leaving IO to the end.
21:51:26 <audreyt> yeah. we need to say "this solves your immediate problems"
21:51:29 <dons> gives the impression of not being real world
21:51:35 <Korollary> oh no! Web 2.0!
21:51:44 <dons> audreyt: right.
21:51:47 <audreyt> indeed. IO is like the second thing I show after function call syntax
21:52:03 <dons> yeah, ChilliX switched around our comp1A course to do roughly this too
21:52:13 <dons> as well as moving to ghc, and away from hugs
21:52:27 <audreyt> *nod*
21:52:36 <audreyt> Korollary: it's just a hype title
21:52:38 <dons> throw them in, and hopefully they learn to swim, and like it!
21:52:46 <audreyt> the concent content is more about HSP and HaskellDB and WaSH like things
21:52:53 <audreyt> s/concent/concrete/
21:53:05 <audreyt> and lazy evaluation and declarative programming
21:53:11 <audreyt> just expressed in perl5 context :)
21:53:13 <dons> who was running the haskell tut?
21:53:19 <audreyt> AdamTuroff
21:53:48 <audreyt> http://conferences.oreillynet.com/cs/os2006/view/e_sess/8898
21:53:50 <lambdabot> Title: O'Reilly Open Source Convention - July, 24-28, 2006 - Portland, OR
21:54:06 <audreyt> his first slide says haskell needs ~1yr dedicated coding on a project to learn well
21:54:11 <audreyt> since it involves so much unlearning
21:54:24 <audreyt> but then, you _still_ come out ahead if the project is large enough.
21:54:43 <audreyt> my experience echos that of his, except for me it's more like 1 month
21:54:47 <audreyt> but that month I did nothing else :)
21:54:55 <Pseudonym> It depends on the project.
21:55:07 <audreyt> that too.
21:55:26 <audreyt> my first project is heavy binary IO processing with constrained memory and slow CPU
21:55:35 <audreyt> exercises all haskell's weaknesses ;)
21:55:41 <Pseudonym> yeah.
21:55:45 <audreyt> ...and still it came out just fine.
21:55:50 <Pseudonym> OTOH, if you try to write a compiler in C...
21:55:54 * Pseudonym shudders
21:56:01 <Pseudonym> Been there, done that, never go back.
21:56:18 <Pseudonym> Mind you, I made the mistake of using triples as my intermediate representation.
21:56:56 <audreyt> relational triples
21:57:04 <audreyt> or three-address triples?
21:57:10 <dylan> I ended up using ocaml because of perl's parser-generator modules being slow, and ocaml lead me here...
21:57:21 <Pseudonym> Three-address triples are quadruples.
21:57:31 <audreyt> indeed
21:57:32 <Pseudonym> Operation plus three operands.
21:57:45 <audreyt> dylan: same path... except it was Parse::Binary for me
21:57:48 <Pseudonym> Triples, in archaic compiler parlance, is two operands plus operation.
21:57:55 <audreyt> and I wrote that, so I can't blame anyone but myself for it being slow :/
21:58:01 <Pseudonym> Operands can point to previous triples.
21:58:02 <dylan> audreyt: you're, ahem, slightly more useful of a programmer. ;)
21:58:52 <dylan> Actually, it's ironic: I was quite upset that Parse::Lex was documented primarily in french, so I learned ocaml, where a large percentage of the users are french...
21:58:59 <audreyt> :D
21:59:25 <Korollary> heh
22:00:39 <dylan> LOL! Quote from #ocaml, to a newbie, and a perfect example of why I dislike that community: "And it's a waste of time to write programs that do IO."
22:01:01 <audreyt> indeed, you should save the computers valuable time
22:01:05 <audreyt> by doing the IO _yourself_!
22:01:08 <dons> dylan: yikes!
22:01:49 <dylan> I'm sorry for quoting such rubbish, but it's late and this has me in tears... "Why are you writing a program that uses files?"
22:02:00 <Pseudonym> No program should do any output.
22:02:16 <Pseudonym> That way, there are only two programs: terminate and infinite loop.
22:02:26 <Pseudonym> It is left as an exercise to write a superoptimising compiler.
22:02:57 <Korollary> Does a CPU run if there is no one reading the output?
22:03:14 <Adamant> yes, but it's mostly good as a space heater
22:03:18 <Plareplane> is it possible that you quoted out of context and it was a joke
22:03:21 <dons> see, IO is such an interesting problem, that we talk about it _all the time_
22:03:28 <dylan> Can you guess which one is which? This is an exercise left to a hyperturing machine?
22:03:47 <dons> which is kind of perverse for a pure functional language channel
22:03:59 <Pseudonym> Speaking of which, it's 27C in here.
22:04:07 <Pseudonym> Too many computers turned on.
22:04:12 <dylan> figuratively or really?
22:04:16 <dons> serious? ah. not a heatwave in melbourne
22:04:20 <Pseudonym> No.
22:04:23 <Pseudonym> Yes, serious.
22:04:26 <Pseudonym> I said "in here".
22:04:32 <Pseudonym> Out there it's a much more temperate 14 or so.
22:04:38 <dons> heh
22:04:55 <musasabi> Doing fast IO in Haskell is black magic - or installing fps.
22:05:29 <dylan> perhaps... "(Use your shell to do file IO)"... but isn't shell I/O still file I/O?
22:05:41 <dons> wonderful, musasabi :)
22:06:13 <dons> i should get tshirts printed with that on it
22:06:30 <dylan> My first useful haskell program is shaping up to be a 'take a dir, symlink all the files in it into another dir', which is a lot of I/O.
22:06:44 <Korollary> You might as well have "EHJ334253423" printed on a tshirt
22:07:12 <dons> heh. that's cool too!
22:07:27 <Korollary> have that on the back
22:08:09 <dylan> I'd rather have the earlier conversation about gnomes on a shirt.
22:08:25 <Korollary> ooh. Adamant and I are in #scheme as well.
22:08:27 <dylan> easier to explain to co-workers.
22:08:31 <dons> :)
22:08:40 <dons> yeah, audreyt would like that one.
22:09:04 <dons> audreyt: check the logs earlier today for 'Gnomess' and Wadler
22:09:13 <dons> Gnomes, I mean
22:10:43 <dylan> Yess, gnomeses. We hates them. *cough*
22:10:52 * Korollary shoots dylan
22:10:52 <audreyt> dons: *rofl*
22:28:30 <edwardk> ok, dump question, whats a good list join function in haskell? i have a list of strings, that i want to space separate.
22:28:37 <edwardk> er dumb
22:28:52 <edwardk> ah
22:29:04 <edwardk> > intersperse "," "abcde"
22:29:05 <lambdabot>  Couldn't match `[Char]' against `Char'
22:29:14 <edwardk> > intersperse ',' "abcdef"
22:29:15 <lambdabot>  "a,b,c,d,e,f"
22:29:17 <dons> > concat . intersperse " " $ ["abc", "def"]
22:29:19 <lambdabot>  "abc def"
22:29:19 <edwardk> nevermind =)
22:29:20 <edwardk> heh
22:29:44 <dons> ?pl \ls c -> concat . intersperse c $ ls
22:29:44 <lambdabot> flip ((join .) . intersperse)
22:29:58 <dons> > flip ((join .) . intersperse) ":" ["abc", "def"]
22:29:59 <lambdabot>  Couldn't match `[a]' against `Char'
22:30:07 <dons> > flip ((join .) . intersperse) ["abc", "def"] ":"
22:30:08 <lambdabot>  "abc:def"
22:30:22 <dons> ?pl \c ls -> concat . intersperse c $ ls
22:30:23 <lambdabot> (join .) . intersperse
22:31:04 <dons> > ((join .) . intersperse) ":" (replicate 4 "haskell")
22:31:05 <lambdabot>  "haskell:haskell:haskell:haskell"
22:33:19 <edwardk> is there any weird issues with tail-call-optimization and do-sugar i should worry about? going to be nesting very deep on calls through the jit
22:33:47 <dons> only if you don't have tail calls..
22:34:28 <musasabi> edwardk: if you want performance then Lazy fps might be one solution if String processing takes a lot of time.
22:34:31 <edwardk> the final call is 'jit array ip v1 v2 v3 v4 v5 v6 v7 v8
22:34:39 <edwardk> where the function jit is a function in the same monad
22:35:10 <edwardk> musasabi: this is just during the compilation pass. any time i spend here will be dwarfed by the time ghc spends jitting the code =)
22:35:26 <glguy> are there any standard library functions somewhere between mapM and filter? Monad m => (a -> m Bool) -> [a] -> [a]
22:35:28 <dons> musasabi: oh that'd be cool. jitting a lazy bytestring
22:35:29 <edwardk> where array and ip are the names of two of the variables from the variable list.
22:35:39 <musasabi> @type filterM
22:35:41 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:35:49 <glguy> @index filterM
22:35:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:35:53 <dons> ?hoogle Monad m => (a -> m Bool) -> [a] -> [a]
22:35:53 <glguy> sweet deal
22:35:54 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
22:36:04 <glguy> I hoogled for that typesig but did not find anything
22:36:20 <dons> ?hoogle Monad m => (a -> m Bool) -> [a] -> m [a]
22:36:21 <lambdabot> No matches, try a more general search
22:36:25 <edwardk> right now i just have a lot of little funcs like
22:36:27 <edwardk> emit (Aload a b c) = do
22:36:27 <edwardk>         a' <- fresh a
22:36:27 <edwardk>         t <- var
22:36:27 <edwardk>         return $ t++" <- " ++ p2a b ++ ";" ++ show a'++"<- unsafeRead "++t++" "++show c++";"
22:36:39 <edwardk> that are all gluing together strings to make up the new monadic function
22:36:54 <dons> so probably you want a few little combinators for building these expressions
22:37:02 <edwardk> all of the a = b + c's become lets on fresh vars
22:37:05 <dons> possibly using Language.Haskell
22:37:09 <dons> ok. good
22:37:13 <edwardk> so it should be able to optimize whatever it can away
22:37:26 <edwardk> then i just marshal the set of 8 vars on the final cal to the next jitted function
22:37:36 <dons> it would also be interesting to generate _unboxed_ haskell out the back end
22:37:46 <dons> i did that once for a mini-ML, and the code usually beat gcc
22:37:52 <edwardk> with all the funny # marks?
22:37:58 <dons> right.
22:38:08 <glguy> filterM makes my Kruskal's algorithm implementation even cleaner :)
22:38:08 <dons> since then you don't get any heap allocation
22:38:38 <edwardk> well, my usage of integers etc could perfectly well allow that.
22:38:52 <edwardk> right now i'm not even forcing strictness to see how far i can take it in this direction
22:38:55 <dons> yep.
22:39:01 <gavino> hey folks
22:39:08 <gavino> hows the lambd
22:39:09 <gavino> a
22:39:19 <edwardk> once it runs at all, we'll see if it can be made fast by giving in and doing the strictness crud
22:39:19 <edwardk> =)
22:39:55 <dons> since its a code generator, you don't necessarily have to see the Word#'s your generating
22:40:00 <edwardk> I just need to write the JitQ monad that gives me my fresh variable supply and i think it might even work.
22:40:08 <dons> gavino: good, last time I checked :)
22:40:21 <edwardk> are and tracks register allocation
22:40:30 <dons> > (\x y -> y) "how are you" "good"
22:40:31 <lambdabot>  "good"
22:43:15 <glguy> is there a better way to phrase this: if not conjoined ; then union u v djs ; else return () ; return $ not conjoined ?
22:43:27 <roconnor> dons: Do you want my haskell UM?
22:43:39 <dons> when (not conjoined) $ union u v djs ; ..
22:43:42 <dons> roconnor: yes please!
22:43:49 <glguy> @type when
22:43:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:44:00 <glguy> brilliant! :)
22:44:01 <dons> glguy: it writes the empty else branch for you ;)
22:44:10 <dons> or even
22:44:24 <dons> unless conjoined $ union u v djs ; return $ not conjoined
22:44:30 <roconnor> dons: darcs get --tag=contest http://r6.ca/icfp2006/ ought to work, I think.
22:44:37 <dons> cheers
22:44:47 <roconnor> the haskell code is UM.hs
22:44:59 <dons> any special flags you want?
22:45:07 <dons> and a team name?
22:45:14 <dons> (for the stats page)
22:45:23 <dons> if no team name, then I use "roconnor"
22:45:29 <glguy> @paste
22:45:29 <lambdabot> http://paste.lisp.org/new/haskell
22:45:45 <roconnor> the team is Team Roflcopter, but we used a C vm later on
22:46:06 <dons> that's ok. I just want to collect the Haskell ones, really
22:46:15 <dons> no one's got a good Haskell one yet, basically
22:46:21 <dons> which is a puzzle to be solved.
22:46:24 <lisppaste2> emertens pasted "kruscal's just keeps getting shorter :)" at http://paste.lisp.org/display/23234
22:46:41 <glguy> I know you guys are busy with big projects like implementing the UM
22:46:47 <dons> heh
22:47:09 <glguy> but I appreciate learning about when and filterM
22:47:19 <glguy> etc
22:47:36 <glguy> as I screw around with these individual functions
22:48:35 <dons> ?pl kruskalST djs (u,v) = djsConjoined u v djs >>= \c -> if c then return () else djsUnion u v djs >> return (not c)
22:48:40 <dons> thinking...
22:48:41 <lambdabot> kruskalST = (`ap` snd) . (. fst) . ap (ap . (liftM2 (>>=) .) . flip (flip . djsConjoined)) (((ap (flip if' return) .) .) . flip flip (return . not) . ((flip . (((.) . (>>)) .)) .) . flip (flip .
22:48:41 <lambdabot> djsUnion))
22:48:41 <lambdabot> optimization suspended, use @pl-resume to continue.
22:48:46 <dons> ah well
22:48:56 <dons> its beautiful to my eyes
22:50:21 <Pete_I> netsplit again?
22:50:29 <Pete_I> happens often on freenode?
22:50:43 <dons> not too often
22:50:53 <dons> but not too rare either
22:51:00 <Pete_I> this's like...the 3rd one in the last week or two
22:51:11 <dons> sounds about right
22:51:26 <dons> big network
22:51:48 <dons> maybe its been a bit worse recently
22:52:40 <glguy> ?pl b <- getBool ; if b then 1 else 2
22:52:41 <lambdabot> (line 1, column 14):
22:52:41 <lambdabot> unexpected ";"
22:52:41 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
22:52:58 <glguy> ?pl getBool >>= \b -> if b then 1 else 2
22:52:58 <lambdabot> flip (flip if' 1) 2 =<< getBool
22:53:05 <glguy> @type if'
22:53:06 <lambdabot> Not in scope: `if''
22:53:10 <roconnor> dons: we have been using -O3 -fvia-c
22:53:12 <dons> if' e x y = if e then x else y
22:53:14 <Pete_I> how does ?pl work?
22:53:18 <dons> term rewriting
22:53:22 <dons> roconnor: ok.
22:53:26 <roconnor> um
22:53:34 <roconnor> and some other flag ...
22:53:35 <glguy> same for case? case'?
22:53:41 <dons> there's no case'
22:53:44 <roconnor> that didn't work on my version of GHC
22:53:50 <dons> case is what everything else is implemented in terms of
22:54:01 <glguy> I suppose that I'd just use "maybe" in this situation
22:54:04 <dons> if x then a else b == case x of True -> a ; False -> b
22:56:17 <dons> reminds me i should try out xerox's ghci+lambdabot binding
22:58:10 <emertens> wireless == unreliable
22:58:27 <emertens> s/==/===
22:58:44 <emertens> not testing... unifying :)
22:58:57 <jer> emertens, my wifi sucks too =/
22:59:45 <dons> i've got a WAN wifi, it used to suck, but is better now i have a big antenna in the roof :}
23:04:30 <dons> @seen sjanssen
23:04:31 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
23:05:36 <emertens> I spoke with sjanssen earlier today
23:05:54 <emertens> (so he's probably still alive)
23:05:59 <dons> ok. lambdabot's being weird then
23:06:03 <dons> ?uptime
23:06:04 <lambdabot> uptime: 8 days, 14 hours, 21 minutes and 40 seconds
23:26:22 <emertens> @instances Functor
23:26:23 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:33:20 <emertens> the Israel / Hezbollah problem is a good fit for "mdo"
23:34:06 <emertens> since there is no good way to define the order of resolution
23:34:39 <emertens> (I recognize that this is a bit of a stretch)
23:35:21 <dons> or a backtracking monad, perhaps
23:37:18 <emertens> after spending all simplifying my prims and kruskals implementations... I've run out of lines to clean up (and the solutions look so simple tha I feel dumber having spent my time)
23:37:31 <emertens> prims degenerated into a simple unfoldr
23:38:10 <dons> :)
23:38:14 <Lemmih> greenrd: ping.
23:39:02 <dons> thta's an interesting observation. now who was it yesterday who pointed out the art of haskell was learning to approach 0 lines of code in the limit, for each problem
23:39:20 <dons> ?karma+ expressive power
23:39:20 <lambdabot> expressive's karma raised to 1.
23:39:42 <emertens> that means that expressive, which doesn't "exist" now has more karma than I do :)
23:40:20 <emertens> I did learn how to work with STArrays in the ST monad tonight
23:40:25 <emertens> so it wasn't a total loss
23:40:35 <dons> ?karma+ emertens -- learning ST
23:40:35 <lambdabot> emertens's karma raised to 1.
23:40:59 <Korollary> "There are people in my computer."
23:41:13 <emertens> Korollary: you are watching an Intel ad?
23:41:32 <Korollary> No, a movie trailer for a run-of-the mill teenage thriller
23:41:36 <emertens> ahh
23:41:51 <Korollary> The primary target for evil entities
23:41:52 <dons> heh
23:44:20 <emertens> Do you remember the scene in Jurrassic Park
23:44:29 <emertens> where the girl navigates the unix filesystem?
23:44:58 <dons> yeah
23:45:08 <dons> "oh, its unix. i know this" or something, she says
23:45:12 <emertens> exactly
23:45:34 <emertens> I recently discovered that that 3d filesystem manager app was real
23:45:45 <emertens> that blew me away :)
23:45:47 <dons> heh.
23:45:51 <emertens> I always though that JP was full of shit
23:46:01 <dons> but it was actually stunningly realistic?
23:46:16 <emertens> I figured it was just some "cgi" effect
23:46:19 <emertens> yeah
23:46:44 <emertens> unfortunately it only ran on some old UNIX flavor
23:46:51 <emertens> so I didn't get a chance ot install it :)
23:47:35 <Korollary> Yes, as you know, billions of people don't actually have computers at home and they need to see a fancy GUI to be convinced that it's a computer.
23:48:08 <Korollary> I actually have apps that pop up bright red windows that go "ALERT!"
23:48:23 <dons> you particularly need little high-pitched glitches and clicks whenever an instruction is executed..
23:48:30 <emertens> heh
23:48:34 <dons> so that you know something is actually happening
23:48:39 <dons> the UM should have that!
23:48:54 <dons> oh, its a bit like the bell that rings when ghc does a GC, with +RTS -b -RTS (iirc)
23:48:55 <Korollary> Right. My shell window also prints character by character. Don't ever do "ls /usr/bin"
23:49:21 <emertens> ?pl djsFind p djs >>= \g -> writeArray djs a (Just g) >> return g
23:49:21 <lambdabot> ap ((>>) . writeArray djs a . Just) return =<< djsFind p djs
23:49:25 <edwardk> hrmm is there a version of something like takeWhile that will grab every element matching the predicate and the first that doesn't? or can someone think of a nice idiomatic way to express that?
23:49:32 <Pseudonym> It was for IRIX.
23:49:34 <Pseudonym> I ran it once.
23:49:40 <Pseudonym> That file system thingy.
23:50:01 <emertens> 3dfm was it?
23:50:18 <Pseudonym> Something like that.
23:50:30 <emertens> ?pl djsFind p djs >>= \g -> writeArray djs a g >> return g
23:50:31 <lambdabot> ap ((>>) . writeArray djs a) return =<< djsFind p djs
23:50:47 <dons> ah, sounds like an irix thing
23:50:49 <Pseudonym> I also remember the audio mixer for that generation IRIX had a --spinal-tap mode.
23:50:57 <dons> osx before there was an osx!
23:50:59 <Pseudonym> You can guess what that did.
23:51:06 <emertens> Pseudonym: i can't
23:51:08 <emertens> Pseudonym: what's it do
23:51:13 <Pseudonym> The sliders went to 11.
23:51:41 <emertens> According to *Guitar Hero*, "11 *is* louder than 10"
23:52:17 <astrolabe> edwardk: maybe base it on span?
23:52:24 <astrolabe> @type span
23:52:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:52:31 <Korollary> If you have 11, it is indeed louder than 10.
23:52:34 <edwardk> ahh
23:52:39 <edwardk> that should work
23:53:43 <edwardk> kinda ugly coz i have to ++ the last node on the wrong end of a list, but it'll do =)
23:53:55 <astrolabe> yeah
23:54:36 <emertens> ?pl djsFind a djs >>= (flip (writeArray djs) (Just b))
23:54:36 <lambdabot> flip (writeArray djs) (Just b) =<< djsFind a djs
23:55:34 <edwardk> ah maybe not, i just won't build the actual list
23:55:39 <edwardk> good idea with the span
23:55:57 <emertens> ++ isn't really that expensive when you are using it in a lazy sense... is it?
23:56:29 <emertens> since it just starts evaluating the second list when it runs out of first elements to return?
23:57:03 <emertens> rather than copying the left hand list strictly
23:58:10 <edwardk> kinda new at this, so i'll smile and nod =)
23:58:22 <edwardk> just remembered reading something about lots of string ++'s being slow.
23:58:40 <emertens> which makes sense in a strict evaluation
23:58:52 <emertens> I was just asking about the lazy evaluation
23:59:13 <astrolabe> It is bad to use to list the nodes of a tree, for efficiency reasons, but I can't see why at the moment.
