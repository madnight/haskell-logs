00:00:56 <dons> mmm.. http://www.cse.unsw.edu.au/~dons/tmp/Fast.hs
00:01:16 <dons> but still, this is a hard problem in haskell
00:01:21 <edwardk> yeah
00:01:31 <dons> i wonder if Bulat can help out with his mutable data libs
00:02:20 <edwardk> heh, right now i'm trying to see how bad it would be to write a minimal assembler so i can just generate the code
00:02:28 <edwardk> i don't need much in the way of register coloring, etc.
00:03:07 <edwardk> just some basic loads, and a couple of EAX+4*EBX+constant indirections
00:03:17 <edwardk> er that style anyways
00:03:48 <edwardk> if i'm greedy in register alloc and follow the same last second emission of register values, it wouldn't suck too bad
00:04:37 <foxy_> @hoogle intersperse
00:04:38 <lambdabot> List.intersperse :: a -> [a] -> [a]
00:06:43 <foxy_> @hoogle contains
00:06:44 <lambdabot> No matches found
00:07:08 <foxy_> @hoogle [a] -> [a] -> Bool
00:07:09 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
00:07:09 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
00:07:55 <Korollary> @type elem
00:07:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:08:26 <foxy_> @hoogle subStr
00:08:27 <lambdabot> Data.PackedString.substrPS :: PackedString -> Int -> Int -> PackedString
00:08:39 <edwardk> hrmm. i think i won't map the cache if i do a c++/assembly generating one. i'll just make a second array and stuff the pointer to the jitted code in the array position it starts the run from.
00:13:20 <shapr> Good morning #haskell!
00:13:24 <edwardk> heya shapr
00:14:06 <shapr> What's goin on?
00:14:21 <Korollary> global domination phase D
00:14:23 <edwardk> not much. my haskell jit for the icfp um is too slow to live
00:14:25 <dons> ?yow!
00:14:26 <lambdabot> BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-BI-
00:14:55 <shapr> Haven't seen that one before.
00:15:08 <dons> edwardk: well, a haskell jit in 3 days is still pretty good ;)
00:15:23 <edwardk> heh
00:15:43 <edwardk> 2 of which were because i didn't spot a "Maybe" not being there in the unsafeEval_ specification =)
00:15:47 <foxy_> is there a way to set environment variables from Haskell?
00:16:06 <shapr> I had fun following references from Hudak's jazz improv paper recently.
00:16:28 <dons> foxy_: getEnv/setEnv, iirc
00:16:33 <dons> ?hoogle Env
00:16:34 <lambdabot> System.Environment :: module
00:16:34 <lambdabot> System.getEnv :: String -> IO String
00:16:34 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
00:16:40 <dons> ?hoogle+
00:16:44 <shapr> Jazz seems to be central to a large chunk of research into creativity.
00:16:45 <edwardk> i tweaked the old version to remove that problem and lo and behold. my more elegant fixed point version would be reasonably close to done if i wanted to go back and patch all of the bugs that i patched that were unreleated to the fixedpoint again.
00:16:45 <foxy_> I don't see setEnv
00:17:22 <edwardk> THAT at least makes me feel better because i need that structure in order for the javascript plugin stuff to work right
00:17:23 <dons> seems like it doesn't make sense. of course you can tweak any env values you use in your subprocesses
00:19:22 <ValarQ> morning folks
00:24:28 <tessier__> Are there haskell libraries to do things like sha1 sums and crypto type stuff like RSA?
00:27:09 <shapr> tessier__: http://darcs.haskell.org/crypto/
00:27:11 <lambdabot> Title: Index of /crypto
00:28:42 <tessier__> shapr: Perfect. Thanks!
00:32:16 <dons> ?karma+ shapr -- question solved
00:32:17 <lambdabot> shapr's karma raised to 21.
00:32:30 <dons> I'm taking anew approach to karma. if you solve someone's problem. you get karma+
00:33:40 <tessier__> That's a good idea.
00:33:52 <tessier__> What does the person with the highest karma get?
00:34:16 <dons> the extinguishing of the self, of course ;)
00:34:30 <ValarQ> how do you list the karma top?
00:34:37 <dons> ?karma-all
00:34:37 <lambdabot>  dons                   45
00:34:37 <lambdabot>  shapr                  21
00:34:37 <lambdabot>  xerox                  21
00:34:37 <lambdabot>  Lemmih                 19
00:34:37 <lambdabot>  lambdabot              18
00:34:38 <tessier__> That doesn't sound like much of a reward.
00:34:39 <lambdabot> [186 @more lines]
00:34:44 <dons> ?more
00:34:44 <lambdabot>  dcoutts                16
00:34:44 <lambdabot>  Cale                   12
00:34:45 <tessier__> I'm not sure I would want to be extinguished.
00:34:45 <lambdabot>  musasabi               10
00:34:47 <lambdabot>  sjanssen               10
00:34:49 <lambdabot>  SamB                    9
00:34:51 <lambdabot> [181 @more lines]
00:34:57 <dons> ?more
00:34:57 <lambdabot>  int-e                   9
00:34:58 <lambdabot>  Igloo                   8
00:34:59 <lambdabot>  SyntaxNinja             8
00:35:01 <lambdabot>  vincenz                 8
00:35:03 <lambdabot>  QuickCheck              7
00:35:05 <lambdabot> [176 @more lines]
00:35:13 <dons> quickcheck solved a lot of problems, it seems
00:35:31 <dons> but see, we haven't consistently rewarded problem solving
00:35:40 <dons> for example, Igloo solves lots of tricky ones
00:35:49 <ValarQ> @karma STM
00:35:49 <lambdabot> STM has a karma of 0
00:35:53 <dons> and i just get free ones, for writing/fixing lambdabot
00:36:21 <int-e> @karma quickcheck
00:36:22 <lambdabot> quickcheck has a karma of 0
00:37:21 <int-e> dons: do you have time to test another UM?
00:37:56 <dons> yep, just briefly.
00:38:01 <dons> oh,nice, this:
00:38:02 <dons> set (int2Word# 7# `and#` (w `uncheckedShiftRL#` 25#))
00:38:02 <dons>                    (w `and#` int2Word# 0x1ffffff#)
00:38:04 <dons> compiles to:
00:38:12 <dons>         _s4Uu = _s4Lb & 33554431;
00:38:12 <dons>         _s4Uo = _s4Lb >> 25;
00:38:12 <dons>         _s4Uq = 7 & _s4Uo;
00:38:12 <dons>         _s4Us = _s4Uq;
00:38:28 <dons> which is exactly what i wanted :)
00:38:47 <int-e> dons: http://int-e.home.tlink.de/haskell/um5.hs (runs faster than my previous one with ghc 6.4.2 here - about as fast as with 6.5 before)
00:38:56 <dons> ok. i'll run it
00:38:58 <int-e> neat
00:39:18 <dons> int-e, check the scores. i posted a new haskell one
00:39:27 <int-e> I just saw that
00:39:29 <dons> using the above careful unboxings
00:42:46 <int-e> Oh, ByteString has a memset. I was sorta looking for one.
00:43:15 <int-e> (not desparately enough to bind my own one though)
00:43:42 <dons> yeah, there's a few C functions bound in *.Base
00:44:59 <int-e> @karma+ ByteString
00:44:59 <lambdabot> ByteString's karma raised to 1.
00:45:02 <int-e> @karma FPS
00:45:02 <lambdabot> FPS has a karma of 0
00:45:07 <int-e> @karma fps
00:45:07 <lambdabot> fps has a karma of 0
00:45:10 <int-e> strange :)
00:45:27 <int-e> @karma Data.ByteString
00:45:27 <lambdabot> Data.ByteString has a karma of 0
00:49:53 <dons> int-e, updated
00:54:02 <int-e> thanks.
00:55:18 <int-e> dons: ah, the relative speed of your program and mine matches what I observe here. I never got sjanssen's as fast as you did.
00:55:28 <foxy_> dons, do you want ghc-api to be built into Yi or a plugin?
01:03:40 <esdegan> hello
01:03:41 * tessier__ notes with interest that C is still quite a bit faster than haskell but that haskell is much faster than python or perl
01:03:50 <tessier__> I thought python and perl were much closer to C than they are. Hmm
01:05:14 <esdegan> I'm new to haskell. Can someone help me understand why f (x+1) = x works but f (x-1) = x, f (x*2) = x don't?
01:05:19 <edwardk> you know you've been staring at haskell too long when you think -- foo is a perfectly reasonable comment in c++.
01:05:30 <esdegan> I'm using GHCi
01:06:02 <int-e> (x*2) isn't a pattern. f x = x/2  or f x = x `div` 2  will work.
01:06:33 <edwardk> the fact that (x+1) works is because we have these things called n+k patterns, that 'sugar' things so that particular syntax works.
01:06:49 <edwardk> its used by a lot of newer haskell programmers to define recursive functions, etc.
01:07:32 <edwardk> unfortunately, it also leads them to think it generalizes, like here =/
01:08:03 <esdegan> ooo, so it is special. Well, thank you. yes, I thought it was just an example of more general usage
01:08:18 <int-e> and it's completely unecessary except for a few people who want to implement primitive recursion for natural numbers exactly as in text books.
01:08:51 <edwardk> yeah its on the short list of language features i wouldn't be sad to see go
01:09:12 * ValarQ agrees with that
01:11:09 <esdegan> thank you all. You've been very helpful
01:12:09 <dons> tessier__: on the shootout we've averages 1.2x the speed of C
01:12:27 <dons> which works out as faster than C half the time, and a few outlying programs
01:15:27 <ValarQ> it would be really fun to have a separate SMP shootout
01:16:07 <edwardk> wanting to put STM to use?
01:16:19 <ValarQ> not only STM
01:17:35 <ValarQ> there is many languages that handles multiple processes quite well
01:18:04 <ValarQ> but it would be interesting to see how C is doing then
01:18:10 <dons> :)
01:18:44 <dons> yeah, they're not the strongest in several of the 'hard' problems.
01:18:45 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=gcc&id=0
01:18:46 <lambdabot> Title: chameneos C gcc program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ...
01:18:50 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=message&lang=gcc&id=0
01:18:51 <lambdabot> Title: cheap-concurrency C gcc program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ...
01:18:59 <musasabi> re shootout we are missing Fasta.
01:19:06 <dons> we are?
01:19:16 <dons> musasabi: ?
01:19:24 <dons> oh. hmm.
01:19:27 <dons> that's new
01:19:29 <musasabi> dons: the preconverting to Int was disallowed.
01:19:33 <dons> ah
01:19:42 <musasabi> Isaac sent me a mail yesterday.
01:20:37 <edwardk> missing it? i see it right in front of me
01:21:10 <dons> edwardk: check the gp4 benchmarks
01:21:46 <dons> oh, and i see the lisp concurrency was disallowed. I thought 10x faster than everything else was a bit suspicious
01:22:02 <edwardk> interesting alternative programs?
01:22:28 <dons> yes?
01:23:30 <musasabi> interesting alternative = it implements the test but is not "fair" when looking at the spec.
01:23:42 <edwardk> *nods*
01:26:20 <int-e> hmm. and to find out why that is you have to follow the mailing list?
01:26:39 <dons> comments used to be posted. sometimes they appear on the forums now
01:26:47 <dons> otherwise, you get personally mailed
01:27:29 <musasabi> int-e: the Haskell Fasta is commented on the website why it is disallowed.
01:29:02 <musasabi> We need a release of GHC with fps+regex to make the shootout entries really change.
01:29:35 <int-e> musasabi: oh. at the bottom of the page.
01:30:05 <dons> musasabi: well the plan is to have 6.6 out by mid-september, it seems
01:30:09 <dons> which will have fps, at least
01:30:18 <musasabi> that is soon enough
01:31:18 <ValarQ> is there a ghc6.6 roadmap?
01:32:23 <dons> there's some discussion on the ghc mailing lists
01:34:23 <ValarQ> which mailing list? glasgow-haskell-users?
01:39:10 * dmhouse pokes his head round the door
01:39:11 <dons> i think so
01:39:26 <ValarQ> the trac ticket page seems to be what i looked for
01:39:29 <ValarQ> http://cvs.haskell.org/trac/ghc/milestone/6.6?by=component
01:39:31 <lambdabot> Title: Milestone 6.6 - GHC - Trac
01:49:03 <int-e> dons: using uncheckedShiftRL really, really helps.
01:50:56 <dons> ah, cool!
01:51:08 <dons> i have this suspicion that Data.Bits isn't optimised properly
01:51:13 <dons> not inlined enough
01:51:17 <dons> i should run some measurements
01:54:00 <int-e> dons: http://int-e.home.tlink.de/haskell/um6.hs is about 30% faster than um5.hs here; the only change is using unsafeShiftR (W# w) (W# s) = W# (uncheckedShiftRL# w (word2Int# s))  instead of shiftR
01:55:25 <java-its-pssa> lol
01:55:51 <roconnor> unsafeShiftR?
01:56:19 <int-e> unsafeShiftR x 64 = x, not 0, on x86. I think.
01:56:49 <java-its-pssa> what is a good way to handle the ftp transfer and reading of files to mysql?
01:56:56 <java-its-pssa> I have like 50 customers
01:57:10 <java-its-pssa> each needs to communicate throguh ftp and xml file reads and writes
01:57:13 <java-its-pssa> its bugy as hell
01:58:20 <roconnor> int-e: you know, this code isn't haskell anymore.
01:58:47 <roconnor> it's just a big mess of #'s and !'s
01:59:57 <int-e> roconnor: hmm? there's not a single ! there.
02:00:19 <int-e> roconnor: so whose code are you talking about?
02:00:43 <roconnor> oops I was looking at dons code
02:00:58 <roconnor> your code looks moderately reasonable
02:01:39 <yip> please, if you can hear me: optimize Data.Bits!
02:01:56 <roconnor> unsafeWrite is just without bounds checking?
02:02:01 <int-e> yep
02:02:26 <int-e> oh, and with 0-based indices, so the Ix instance isn't involved anymore.
02:02:43 <roconnor> newArray (0, 63) undefined == newArray_ (0,63)?
02:04:04 <int-e> right
02:04:36 <int-e> the newArray _ 0, too, because these deal with unboxed arrays.
02:05:21 <dons> running um6
02:05:57 <roconnor> int-e: how does your copyArray compare with (mapArray id)?
02:06:48 <roconnor> @type Data.Array.MArray.mapArray id
02:06:49 <lambdabot> forall e' (a :: * -> * -> *) (m :: * -> *) i. (Ix i, Data.Array.Base.MArray a e' m) => a i e' -> m (a i e')
02:06:52 <int-e> roconnor: it doesn't create the copy itself. it's really more of a memcpy - probably a bad name.
02:07:08 <roconnor> ah
02:07:31 <roconnor> so the dest array must be smaller.
02:08:11 <int-e> no, the dest array is of same size or bigger
02:08:41 <int-e> (copyArray from to ... unlike memcpy in its argument order.)
02:09:04 <roconnor> yes, of course
02:09:06 <dons> i think mapArray id isn't so much fun
02:09:20 <roconnor> > 2^25
02:09:22 <lambdabot>  33554432
02:09:22 <dons> Foreign.copyArray is a memcpy, underneath, iirc
02:09:51 <roconnor> > 2^25*4
02:09:52 <lambdabot>  134217728
02:11:40 <dons> int-e, updated.
02:11:44 <dons> indeed, 30% faster
02:15:13 <int-e> not quite, but still convincing.
02:16:13 * int-e wishes the numbers would carry over more reliably between gcc versions (3.4.6 vs. 4.0.1) and architectures (athlon xp vs. pentium 4)
02:36:16 <dons> now i'll try this unchecked shift patch on sjanssen's code
02:38:46 <musasabi> Is the ghc-fc expected to go in for 6.6 ?
02:39:16 <dons> i think they're working towards it. spj is pushing
02:39:28 <dons> and they've got a student working on it too
02:39:35 <dons> as well as the unsw people
02:52:33 <foxy_> dons, did you envisage ghc-api being a plugin or built into Yi?
02:59:48 <dons> i'm not sure. possibly built int
02:59:53 <dons> in.
03:28:46 <shapr> I'm looking forward to Cmm being the best GHC backend.
03:29:54 <ndm> shapr, realistically, how far away are they from that?
03:32:11 <xerox> dons: you should add karma to the #haskell stats ;-)
03:32:18 <xerox> Good morning!
03:32:55 <dons> xerox, i should work out how to do that
03:33:12 <xerox> dons: did you see my roman numerals encoded in the type system?
03:33:12 <dons> ah, reminds me to try out G.O.A. NOW!
03:33:17 <dons> yeah!
03:33:22 <dons> have you made a wiki page?
03:33:32 <dons> its a very wikish idea ;)
03:33:41 <xerox> ?wiki User:PaoloMartini
03:33:41 <lambdabot> http://www.haskell.org/haskellwiki/User:PaoloMartini
03:33:53 <xerox> I put them there usually
03:34:05 <dons> oh, how about /Roman Numerals ?
03:34:11 <dons> make a real page
03:34:11 <xerox> Sure
03:34:20 <dons> and file under Idioms
03:34:45 <dons>  just add [[Category:Idioms]] to the bottom of the new page
03:34:47 <xerox> OK, maybe later
03:34:51 <dons> :)
03:34:58 * xerox yawns
03:36:19 <xerox> The class/instance language is a kind of logic/substitution language, in fact it's quite simple to encode facts in it.
03:36:32 <dons> exactly
03:36:38 <dons> its prolog
03:36:58 <dons> the new System Fc should make this type level stuff much easier
03:37:04 <dons> we get proper functional functions
03:37:08 <xerox> Do we get new...
03:37:10 <dons> rather than this logic programming stuff
03:37:17 <xerox> Oh.
03:37:26 <ndm> hmm, i'm worried that soon everyone will be programming at the type level
03:37:29 <xerox> When will we get this?
03:37:30 <dons> with associated types as well :)
03:37:34 <dons> soon.
03:37:38 <ndm> and we'll have reduced all Haskell program bodies to |undefined|
03:37:46 <xerox> hahaha
03:37:53 <dons> ndm, well its all about getting more things checked statically
03:38:12 <xerox> Haskell or Haskell' ?
03:38:21 <ndm> dons: and increasing the complexity of our beautiful language, maybe the correct place for static properties isn't in the type system
03:38:37 <ndm> but in a separate annotation language which works _properly_ with logical formulas
03:38:42 <xerox> I would love a more powerful type system
03:38:42 <musasabi> The problem is that types are not modular and thus expose the implementation.
03:39:04 <xerox> Class aliases would help, musasabi, right?
03:39:04 <dons> ndm, I suppose you've seen the quicksort on the type level, that does indeed use only undefineds at runtime
03:39:11 <ndm> dons, yep
03:39:27 <ndm> i still think that types are not the place for this static checking
03:39:49 <musasabi> xerox: partially.
03:40:03 <dons> we're still not there really. we'll look back and see this as a strange period where we were working out how to add extra static properties in a good way
03:40:07 <dons> something will emerge
03:40:10 <musasabi> xerox: my problem is usually that the types become ~10 pages long which makes type errors quite evil.
03:40:18 <ndm> yes, and i'm pretty sure it won't be in the types
03:40:21 <dons> i.e. there's an Isabelle/type checker for OCaml now.
03:40:31 <xerox> musasabi: that's wild.
03:40:36 <ndm> (of course, it seems everyone disagrees with me)
03:41:00 <dons> some people really want theorems proved, for arbitrarily complex theorems
03:41:04 <xerox> ndm: it's the way of the geniouses...
03:41:17 <dons> but, its an exciting time to be in haskell, i must say
03:41:22 <dons> so many new doors yet to open
03:41:23 <samason> ndm: have you seen BitC, itÄ'll be interesting to see how it turns out. . .
03:41:24 <xerox> Yes!
03:41:47 <ndm> xerox: not a particularly good way to get funding :)
03:42:15 <dons> lots of PhDs in proofs/high assurance/PCC these days
03:42:28 <foxy_> have you checked out http://www.cs.nott.ac.uk/~jjw/papers/Compiler_Pearl/Compiler_Pearl.pdf
03:42:32 <ndm> samason: yes, i saw that, a bit
03:42:51 <ndm> foxy_: yes, and that looks very cool!
03:43:19 <foxy_> and http://www.cs.rice.edu/~jgs3847/pubs/pubs/2007/pasalic07:_concoq.pdf
03:43:37 <foxy_> the second is about using Coq proofs with a type system
03:43:38 <xerox> There was that conference dcoutts pointed up some time ago
03:43:48 <dons> oh, that's right. I said earlier it was an Isabelle typing for OCaml. It was Coq, actually
03:43:53 <xerox> That one about proofs/high assurance/PCC ....
03:44:32 <ndm> @seen dcoutts
03:44:33 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 9 hours and 2 minutes ago.
03:44:51 <dons> xerox: what's the darcs repo for goa?
03:44:57 <dons> ?where goa
03:44:58 <lambdabot> I know nothing about goa.
03:45:12 <dons> maybe it should be called genoa, or goanna, or something..
03:45:19 <musasabi> Associating proofs with classes and requiring that instances pass them would be very nice.
03:45:23 <xerox> http://haskell.galois.com/~paolo/darcs/goa
03:45:24 <lambdabot> Title: Index of /~paolo/darcs/goa
03:45:33 <xerox> Huh?
03:45:36 <dons> ?where+ goa  http://haskell.galois.com/~paolo/darcs/goa
03:45:36 <lambdabot> Done.
03:46:04 <dons> musasabi: I just want to associate types with classes ;)
03:47:43 <ndm> woohoo, i can now run Hugs in a GUI Gtk2Hs shell :)
03:47:44 <dons> ?remember xerox For some [lambdabot] is like an addiction
03:47:45 <lambdabot> Done.
03:47:55 <dons> ndm, cool!
03:48:00 <dons> pretty fonts? nice colours?
03:48:04 <dons> screenshots?
03:48:11 <xerox> hehe
03:48:13 <ndm> ugly fonts, no nice colours
03:48:32 <ndm> screenshots i can do though :)
03:49:12 <dons> ndm, have you seen xerox's ghci-binding-to-lambdabot-binding-to-hoogle?
03:49:32 <ndm> dons, nope, but this tool will integrate lamdabot stuff directly in
03:49:48 <dons> xerox, what's the url of that screenshot of goa in action?
03:49:57 <ndm> am tempted to have it even connect to haskell IRC in a tab :)
03:50:00 <dons> was it shapr's blog?
03:50:10 <xerox> Yes
03:50:12 <dons> ndm, how about have a 'Help' button that starts irc ;)
03:50:17 <xerox> ?where shapr
03:50:17 <lambdabot> http://www.ScannedInAvian.com/
03:50:25 <dons> connecting to #haskell and forking a lambdabot
03:50:34 <xerox> add hope/ to that url
03:50:41 <dons> and debiting the user's bankaccount $1 for each question
03:50:50 <xerox> http://www.scannedinavian.com/hope/entry/59
03:51:04 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/guihaskell-hugs.png
03:51:16 <dons> ah, that's it. hoogle running in lambdabot, running in ghci
03:51:19 <ndm> i was going to have a connect to IRC
03:51:22 <dmhouse> Wow, we should build a lambdabout GUI.
03:51:28 <ndm> and a send mailing list button
03:51:33 <xerox> Got too many \n ndm? :)
03:51:41 <dons> dmhouse: almost there, hmm.
03:51:42 <ndm> xerox: no, got too many \r's
03:51:46 <dmhouse> dons: ?
03:51:46 <xerox> Woops.
03:51:48 <ndm> Windows = \r\n
03:51:50 <dons> ndm, cool!
03:51:55 <ndm> Gtk treats each one twice
03:51:57 <dons> dmhouse: well, see xerox's ghci binding
03:52:02 <dons> then you just have to wrap ghci
03:52:07 <ndm> give me a few seconds of filter magic and it'll fix that
03:52:12 <dmhouse> dons: that's not really a _G_UI, though, is it?
03:52:22 <dons> no, but that's the missing piece
03:52:22 <xerox> dmhouse: it depends on how you wrap ghci :)
03:52:25 <dons> a gtk2hs ghci
03:52:30 <dmhouse> Hrm.
03:52:36 <dmhouse> Not sure that'd be useful in general.
03:52:38 <xerox> I was talking about that to dons, we would come up with too many ghci !
03:52:40 <dons> then again, perhaps you should use a good xterm with freetype fonts..
03:52:46 <ndm> dons, i could have just as easily given you that screenshot with GHCi in the window
03:52:53 <dmhouse> But a GUI specifically aimed at lambdabot could be useful.
03:52:53 <xerox> GHCi is one, lambdabot is becoming another, Yi... ?
03:53:03 <dons> ndm, so you're writing a terminal?
03:53:04 <dmhouse> If nothing else, it'd be a useful investigation into modular GUI programs.
03:53:18 <ndm> dons, i have written a terminal, now i'm writing a GUI round it
03:53:36 <dons> ndm, hehe, is that code portable ?
03:53:42 <ndm> dons: yep!
03:53:45 <dons> cool!!
03:53:48 <dons> ?karma+ ndm
03:53:48 <lambdabot> ndm's karma raised to 8.
03:53:51 <dons> i wasn't sure .. ;)
03:53:57 <xerox> hah.
03:54:02 <dons> and was hoping for some irony. but of couse, you defeat me
03:54:04 <ndm> and expect to see a lambdabot tab at the top there in a while
03:54:33 <dons> ah ok. i think the windows/lambdabot issues are soluble
03:54:40 <ndm> cool :)
03:54:40 <dmhouse> Really, we should work on IDE integration.
03:54:41 * dons remembers to use 'soluble' more ofte
03:55:07 <dmhouse> Having seperate GUI programs are very nice and pretty, but IDE integration is the place anyone really cares about it.
03:55:23 <dmhouse> I think we'd need to hit at least four to matter: Vim, Emacs, Eclipse and Visual Studio.
03:55:31 <ndm> dmhouse: with WinHugs and TextPad, I stopped feeling a need for integration
03:55:37 <dons> dmhouse: you mean with ghci/lambdabot?
03:55:58 <dmhouse> dons: I'm thinking specifically lambdabot, yes.
03:55:59 <dons> i hardly care, using wmii/ion as window managers ,all of unix feels pretty integrated
03:56:19 <dons> but ghci integration for lambdabot, and vim integratoin (we have that now) is enough for me
03:57:10 <dons> xerox, I don't like how Cabal by default doesn't use -O flags to ghc :/
03:57:18 <ndm> i want to replace WinHugs with this thing, which probably captures the Windows market, unless a very good IDE comes along
03:57:25 <dons> you have to actually remember to add ghc-options: -Wall -O
03:57:27 <dmhouse> I'd love to see better Haskell support for Emacs.
03:57:28 <dons> which is bad, imo
03:57:42 <dons> ndm, yeah, sounds like a plan
03:57:45 <dmhouse> When the SoC project on GHCi debugging's done, I want to write Emacs integration for that and possibly Hat.
03:57:46 <xerox> dons: hooks?
03:57:52 <dons> no hooks
03:57:56 <dons> just the cabal file line
03:58:04 <xerox> Why can't you add it and push?
03:58:12 <dons> e.g. ghc-options:         -Wall -fglasgow-exts -O2 -funbox-strict-fields
03:58:14 <ndm> GuiHaskell will have integration with Hat-Gui
03:58:18 <dons> Why can't I. .. I can!
03:58:29 * dons makes patches for xerox
03:58:41 <xerox> dons: aaaah!
03:58:43 <xerox> You said ghc!
03:58:48 <xerox> I didn't understand what was going on
03:58:56 <xerox> You mean goa
03:59:07 <neologism> dmhouse: hows the ghci debuging project going?
03:59:15 <dons> no no. I mean, Cabal in general doesn't add the -O flag
03:59:17 <dmhouse> neologism: I don't know, it's not mine :)
03:59:22 <dons> so you need to add it by hand.
03:59:26 <dons> which, e.g. goa, is missing
03:59:33 <dmhouse> But I'm very interested to see the end result.
03:59:41 <xerox> dons: ok, makes sense, no worries, I'll add it.
03:59:51 <xerox> Just -O or the others you wrote as well?
03:59:54 <dons> oh, i'm adding it now
03:59:58 <dons> i'll send you a patch
04:00:03 <xerox> OK, I'll apply it, thank you
04:08:25 <shapr> ndm: From what I've read, the Cmm backend is solid but the Cmm compilers aren't quite up to it yet.
04:09:41 <shapr> ndm: Ah, here's what I read - http://hackage.haskell.org/trac/ghc/wiki/BackEndNotes
04:09:44 <lambdabot> Title: BackEndNotes - GHC - Trac
04:10:16 <falconair_> A few years ago I read about Pappy, a packrat parser, however I don't see as a haskell project, is there a reason it is not used as much as happy or parsec? (I'm assuming its not used because I don't see it mentioned on mailing lists, activities reports, etc.)
04:10:19 <ndm> shapr: cheers
04:10:37 <ndm> falconair_: isn't packrat parsing pretty high overhead?
04:10:54 <dons> falconair_: i think probably because happy is very solid and fast, and parsec is very convenient and flexible, so the market is saturated
04:11:37 <falconair_> i just printed out happy's manual, it says that it doesn't come with a lexer...isn't that a problem? (i'm brand new to parsers so I have no idea yet)
04:11:48 <dons> no, since you use alex for lexing
04:11:53 <ndm> falconair_: try Alex, a good companion
04:11:54 <dons> ?where alex
04:11:55 <lambdabot> http://www.haskell.org/alex/
04:12:04 <dons> happy is a 'parser generator' after all :)
04:12:31 <dons> however, parsec is a combinator-based parser library, and is flexible enough to also write lexers in
04:12:38 <falconair_> never heard of alex before, I'll try it (Happy manual claims that lexer will be included in the future...hopefully soon :) )
04:12:50 <dons> i doubt it. alex is the standard here.
04:13:00 <dons> ghc, for example, uses alex to lex, and happy to parse the result
04:13:08 <dons> happy knows about alex, and hooks in nicely
04:13:22 <dons> just like lex and yacc
04:13:55 <falconair_> i've been avoiding it for years, but looks like lex/yacc (or their derivatives) are going to force themselves on me
04:14:00 <dons> for complex grammars, with no exising yacc or BNF, parsec might be preferred
04:14:09 <dons> you could try parsec
04:15:17 <falconair_> i looked at parsec, but it looks like it is easier (for a newbie) to learn the syntax of happy (or pappy) rather than constantly having to look up which function does what in parsec
04:15:23 <Philippa_> parsec's not bad for exploratory work, though it'd be nice to have a modified version that was first-order only and statically analysable
04:15:38 <Philippa_> you only need a handful of functions to get started in parsec
04:15:47 <Philippa_> the rest're built in terms of the primitives anyway
04:15:53 <dons> i think there might be a few good newbie introductions to parsec
04:15:56 <dons> Philippa_: know of one?
04:16:06 <Philippa_> sadly no, I just RTFMed
04:16:07 <ndm> dons, the manual is pretty good
04:16:18 <dons> ah, maybe that's what I remember
04:16:23 <Philippa_> but then I'd been happily hand-coding parsers in C++ for a few years at the time
04:16:48 <dons> falconair_: for your personal growth as a human, learning parsec/combinator-based lexing/parsing is useful :)
04:17:06 <falconair_> i started going through the tutorial which teaches how to implement scheme in haskell (scheme in 48 hours or something)...it looks like a good tutorial
04:17:15 <dons> it was considered a bit of a killer app for haskell in the 90s
04:17:30 <dons> falconair_: yeah, there seems to be a bit of a buzz about that tut
04:17:33 <Philippa_> yeah, though having a natural structure to parse stuff into kinda helped too
04:17:33 <dons> i should check it out sometime
04:17:41 <falconair_> as far as i can tell, i should learn parsec to understand functional programming better, but happy if i ever want to parse anything in any other language
04:18:49 <dons> that's reasonable, yes.
04:24:50 <dons> ah ha!
04:25:40 <dons> $ ghci
04:25:40 <dons> *GOA> :bs
04:25:40 <dons> :)
04:25:40 <dons> *GOA> :pl \f x -> f x
04:25:40 <dons> id
04:26:10 <Igloo> Can you :eval, then?  :-)
04:26:39 <dons> oooh, /me tries
04:28:04 <xerox> Yup
04:29:16 <dons> *GOA> :def eval ghci "run"
04:29:16 <dons> *GOA> :eval 1
04:29:16 <dons>  1
04:29:16 <dons> *GOA> :eval map (+1) [1..10]
04:29:16 <dons>  [2,3,4,5,6,7,8,9,10,11]
04:29:23 <dons> very good!
04:29:28 * xerox hops happily
04:29:58 <dons> xerox, now, the constraints so far are: it has to run inside lambdabot (a lambdabot issue), we load the interpreted GOA.hs (should use the compiled library instead)
04:30:01 <dons> anything else?
04:30:11 <dons> oh, and installing requires a bit of hand editing of files
04:30:16 <xerox> Yes.
04:30:29 <dons> ok, i can fix those I think.
04:30:31 <dons> super cool
04:30:35 <xerox> I wasn't sure about how to fix it via shell scripts
04:30:37 <xerox> You're the man :-)
04:30:57 <dons> most of these are fixed if we just allow lambdabot to run outside of its home dir
04:31:00 * xerox =<< lunch
04:31:03 <dons> then we don't have to hard code the lambdabot path
04:31:38 <dons> ndm, hehe *GOA> :hoogle map
04:31:39 <dons> Prelude.map :: (a -> b) -> [a] -> [b]
04:32:44 <dons> xerox: and then we add GOA.hs to lambdabot, and just have it installed whenever you install lambdabot
04:34:38 <ndm> dons, seems like lamdabots trying to take over the world...
04:34:49 <ndm> have you considered a web interface to lambdabot?
04:34:57 <ndm> a textbox you can enter stuff into
04:35:14 <ndm> and with some HTML magic you can give help etc around the textbox
04:35:21 <dons> we should have one, i suppose
04:35:45 <ndm> would be handy, then you have dijiin as a web page etc, which is handy
04:37:14 <roconnor> when I export a type (and not newtype) through a module, is it transparent or opaque?
04:37:28 <dons> it can't be opaque
04:37:36 <roconnor> that's what I figured
04:37:38 <dons> well, it depends....
04:37:43 <roconnor> I should probably use newtype.
04:37:48 <dons> if you hide the constructors of the synonym'd data type..
04:38:10 <dons> but you'll always be able to treat it as a _synonym_
04:38:30 <roconnor> I want to hide it to help enforce safety
04:38:38 <dons> yeah. long live newtype
04:39:00 <dons> 'type' is more for naming long types, or adding documentation, I find
04:39:25 <dons> but usually you want to add more type information, and newtype is good for that
04:39:46 <dons> beginners rarely use it (I think hudak's book says its hardly ever used?)
04:39:58 <dons> (same with 'let', too, fwiw)
04:40:28 <ski> one should be able to export type synonyms opaquely
04:40:30 <dons> I guess people doing comp1A don't do much instance-level hackery
04:41:08 <ndm> dons, and you can always use data Foo = Foo wrapper
04:41:39 <roconnor> damn
04:41:44 <roconnor> Uasm.hs:63:8:
04:41:44 <roconnor>     Can't make a derived instance of `MonadWriter MachineCodeM'
04:41:44 <roconnor>     (even with cunning newtype deriving:
04:41:44 <roconnor>      `MonadWriter' does not have arity 1)
04:41:44 <roconnor>     When deriving instances for type `MachineCodeM'
04:44:05 <ski> 'deriving MonadWriter Foo' ?
04:44:37 <roconnor> wait, I don't want to even export those.
04:44:40 <roconnor> :)
04:44:57 <roconnor> deriving (Monad, MonadFix) is good enough
04:45:20 <roconnor> they can use the monad function *I* provide.
04:45:28 <ski> you can newtype-derive multi-parm type-classes, if you derive in the last arg
04:46:00 <roconnor> ski: how do you know all this?
04:48:01 <ski> i have read http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving
04:48:03 <lambdabot> Title: 7.4. Type system extensions
04:48:05 <ski> ?
04:48:11 <shapr> roconnor: Hey, did you check out that mdo paper?
04:48:20 <roconnor> shapr: yep.
04:48:25 <roconnor> I'm using mdo now
04:48:54 <ski> using 'mdo' for what ?
04:48:58 <roconnor> let me find my quote
04:48:59 <shapr> Was it the same thing you wanted to write about for TMR?
04:49:22 <ski> hi shapr
04:49:30 <shapr> hej ski, how's life?
04:49:38 <shapr> Jag bor i Stockholm nu!
04:49:50 <roconnor> ``mdo certainly makes my code simpler, even if I don't really understand it anymore.''
04:49:54 <shapr> heh
04:50:01 <roconnor> shapr: yep
04:50:07 <ski> shapr : coolt, hur aer det daer ?
04:50:19 <shapr> Could you write a tmr article about how you discovered mdo before you discovered mdo?
04:50:25 <ski> @quote roconnor
04:50:26 <lambdabot>  life lesson from today: 1 closure is nice, 500 000 closures sucks
04:50:32 <shapr> @quote roconnor
04:50:32 <ski> @quote roconnor
04:50:32 <lambdabot>  okay, mfix is slowly starting to make sense to me. and mdo certainly makes my code simpler, even if I don't really understand it anymore.
04:50:33 <lambdabot>  okay, mfix is slowly starting to make sense to me. and mdo certainly makes my code simpler, even if I don't really understand it anymore.
04:50:36 * shapr grins
04:50:39 <shapr> @quote ski
04:50:40 <lambdabot> ski hasn't said anything memorable
04:50:43 <shapr> hmm
04:50:44 * ski grins
04:51:19 <roconnor> shapr: You want me to write about how I came to the IRC channel and was told about mdo?
04:51:37 <shapr> roconnor: No no, I mean I want you to write about the code that led to start using value recursion.
04:51:44 <shapr> I've never used mdo because I've never found a good reason to use it.
04:51:57 <shapr> So I don't really understand it, I've only read about it.
04:52:04 <shapr> You know the difference?
04:52:19 <roconnor> well, I would write about the code that I have now, and just forget about the code I had before.
04:52:35 <shapr> But the code you had before led you to use that nifty value recursion right?
04:52:43 <ski> but how did you translate from before to now ?
04:52:51 <ski> or did you rewrite the parts in question ?
04:53:09 <ski> (s/rewrite/rewrite from scratch/)
04:53:33 <roconnor> ski: In the begining I was thinking, I wish I could access an assignment in a do expression before it is declared.
04:53:48 <shapr> See that's the sort of thing I want to read in a TMR article about mdo.
04:54:07 <roconnor> so I wrote a RWS monad that faked it with string variables names and association arrays, and ciruclar programming.
04:54:25 <shapr> Yes this is good :-)
04:54:29 * shapr boings and listens
04:54:30 <roconnor> but then I discovered that with mdo, I can access an assignment before it is declared.
04:54:40 <roconnor> so I don't need to fake it.
04:54:43 <shapr> Ok that's a great article!
04:54:53 <roconnor> I can do exactly what I originally wanted.
04:54:55 <shapr> Just add in the three stages of your code and publish it!
04:55:01 * shapr bounces
04:55:11 <ski> i think i saw somewhere an example of circular programming being a simple cpp-like macro system, in which macros could use macros defined later (and one-pass of course)
04:55:14 <roconnor> shapr: Do you think it is worth going through the poor man's mdo detour?
04:55:29 <shapr> Very much so.
04:55:48 <roconnor> ski: I'm writing an assembly language monad for the UM machine code.
04:55:54 <roconnor> shapr: ok
04:55:57 <shapr> Because the poor man's detour is the next step, and people might see cases where they've written that sort of thing themselves.
04:55:59 <ski> 'UM' ?
04:56:25 <int-e> @where um
04:56:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
04:56:28 <roconnor> http://www.icfpcontest.org/um-spec.txt
04:56:56 <roconnor> ski: I want to be able to jmp foo, even before I've declared foo <- label.
04:57:17 <roconnor> and with mdo, it Just Works!
04:57:25 <roconnor> ... as long as you are careful.
04:57:30 <ski> what happens if ther's no 'foo' label defined ?
04:57:38 <ski> bottom or catchable-error ?
04:57:45 <Pete_I> is it possible to get ! to stand for factorials, like in regular math? 10!, 4!, etc?
04:57:46 <roconnor> ski: the mdo won't compile.
04:58:07 <ndm> Pete_I: no, operators in Haskell are all infix, not pre/post fix ever
04:58:15 <ndm> with the single exception of -12
04:58:17 <ski> roconnor : oh, i thought you were parsing asm text
04:58:20 <Pete_I> ok
04:58:33 <roconnor> ski: ah, nope.  I'm writing a Haskell domain specific language.
04:58:38 <ski> ah, ok
04:58:41 <roconnor> the asm code IS Haskell.
04:58:43 <roconnor> :)
04:58:45 <ski> right
04:59:06 <roconnor> bbl
04:59:07 <shapr> Sounds nifty
04:59:24 <ndm> roconnor: typed?
05:18:17 <dcoutts> ndm, looks promising
05:18:41 <ndm> dcoutts, its way easier to write than the C version, which is nice to find out
05:18:50 <dcoutts> nice :-)
05:19:56 <ndm> is there a way to combine two handles into one in some way?
05:20:17 <ndm> GHCi outputs on both its stderr and stdout when you make a mistake (some is the prompt, some is the error message)
05:20:27 <ndm> if i just read each and output it, they interleave
05:20:37 <dcoutts> hmm
05:21:16 <dcoutts> yes, I think it's possible to set both outputs to the same
05:21:21 <dcoutts> @hoodle interactive
05:21:22 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
05:21:22 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
05:21:31 <dcoutts> use runInteractiveProcess
05:21:38 <dcoutts> oh, hmm
05:21:51 <dcoutts> @docs System.Process
05:21:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
05:21:58 <ndm> yeah, they are returned, so i either need to stop them splitting, or join them later
05:22:06 <dcoutts> you want runProcess
05:22:15 <dcoutts> @type System.Process.runProcess
05:22:17 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> IO System.Process.Internals.ProcessHandle
05:22:30 <ndm> ah, cool
05:22:35 <ndm> and now do i create my own handles?
05:23:06 <dcoutts> make a pipe
05:23:09 <dcoutts> or indeed 2
05:23:16 <ndm> @hoogle pipe
05:23:16 <lambdabot> Foreign.C.Error.ePIPE :: Errno
05:23:16 <lambdabot> Foreign.C.Error.eSPIPE :: Errno
05:23:16 <lambdabot> System.Win32.File.fILE_TYPE_PIPE :: FileType
05:23:41 <ndm> and how do i do that?
05:23:50 <dcoutts> hmm
05:26:11 <xerox> shapr: http://video.google.it/videoplay?docid=-8246463980976635143
05:26:12 <lambdabot> Title: Human Computation - Google Video
05:27:32 <dons> xerox: http://www.cse.unsw.edu.au/~dons/code/goa/
05:27:32 <lambdabot> Title: Index of /~dons/code/goa
05:27:36 <dons> i've fixed most issues.
05:27:41 <dons> it runs from any directory now
05:27:45 <xerox> Great :)
05:27:51 <dons> and its faster: it forks lambdabot once at start up, and then talks over a pipe
05:28:04 <dons> so the response is instance, basically
05:28:14 <dons> its also mirroed at the above dir.
05:28:16 <dcoutts> ndm, heh, turns out that runInteractiveProcess calls pipe in C code
05:28:20 <dons> so you can just darcs pull from there.
05:28:32 <ndm> dcoutts, but not exposed to Haskell?
05:28:37 <dcoutts> ndm, nope
05:28:45 <ndm> :(
05:28:45 <dons> anyone else want to try out lambdabot-in-ghci?
05:28:53 <dcoutts> ndm, that's another thing we need in the standard IO libs, pipe & mmap
05:28:59 <Numbers> SUre dons
05:29:03 <xerox> dons: crazy, you're exceptionally fast
05:29:28 <dons> $ ghci
05:29:28 <dons> Initialising plugins ........................................... done.
05:29:28 <dons> Prelude GOA> :pl \f x y -> (f x) y
05:29:28 <dons> id
05:29:28 <dcoutts> g'evening dons :-)
05:29:37 <dons> xerox: note the start up message ;)
05:29:40 <dons> hey dcoutts
05:29:44 <xerox> That is lambdabot :D
05:30:16 <dons> WE HAVE CONTROL
05:30:18 <dons> hehe
05:30:20 <dcoutts> heh
05:30:21 <Numbers> @pl \f _ -> x
05:30:21 <lambdabot> const (const x)
05:30:24 <xerox> dons: how do you use ST exactly?
05:30:39 <dons> ST in this case is module-internal global state (ick, i know)
05:31:00 <dons> I couldn't think of a quick way to hide the forked lambdabot pipe from the ghci user
05:31:07 <shapr> xerox: thanks
05:31:18 <dons> so when ghci starts up, lambdabot is forked, and sits there waiting
05:31:28 <dons> then you call it later, and it answers back over the pipe
05:31:46 <xerox> Sensible.
05:31:46 <dons> Numbers: ok. do you have a lambdabot installed?
05:31:54 <dcoutts> so you're not loading the lambdabot plugins directly in ghci then
05:32:02 <xerox> Nope!
05:32:06 <dons> dcoutts: nope. we fork lambdabot as an external process
05:32:11 <dcoutts> ah right
05:32:13 <dons> then our threading doesn't mess with ghci
05:32:19 <dons> its more emacs-style (I think)
05:32:28 <Numbers> dons: Nopw.   WHat do I need to get from this website?   Everything?
05:32:53 <dons> Numbers: ok. you need to do three things. Install FPS, then build and install lambdabot, then build and install goa.
05:32:59 <dons> ?where fps
05:32:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
05:33:03 <dons> ?where lambdabot
05:33:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:33:16 <Numbers> DOes this involve having gcc? :/
05:33:31 <dons> hmm. you on windows or a unix?
05:33:35 <Numbers> WIndoze.
05:33:39 <Numbers> RIght now.
05:33:42 <dons> ok. too hard for now
05:33:46 <Numbers> My LInux ghc enviroment isn't setup. :(
05:33:53 <dons> we still need to resolve a couple of porting wibbles in lambdabot
05:33:59 <Numbers> OK
05:34:26 * Numbers will guinea pig later, then. :)
05:34:41 <dons> thanks for offering though.
05:34:53 * dons notes down Numbers as potential guinea pig for new code
05:35:21 <dons> xerox: see how we work around lambdabot's install issues?
05:35:52 * Peter_Mc suggests dons check out Deuteronomy too.
05:35:55 <Peter_Mc> (Sorry.)
05:36:14 <dons> hmm?
05:36:15 <xerox> dons: wakeup you mean?
05:36:23 <dons> xerox: no, the withLambdabot
05:36:33 <xerox> Oh sure.
05:36:39 <dons> each action gets executed in lambdabot's home dir ;) easy peasy
05:36:56 <xerox> I was doing that yesterday with cabal-server :)
05:37:18 <xerox> (To make sure .cabal file extracted from the tarballs went in the right directories.
05:37:19 <dons> ok. now what cool things can we do with this ghci on acid
05:37:36 <xerox> We can call every single function of lambdabot...
05:37:42 <xerox> Hmmm
05:37:50 <dons> heh
05:38:02 <Numbers> @yarr!
05:38:02 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
05:38:08 <xerox> ahah
05:38:11 <xerox> :yow
05:38:23 <xerox> Amusement in GHCi.
05:38:28 <dons> we could have @yow run in a background thread...
05:38:36 <dons> and just randomly deliver amusing messages to ghci
05:38:41 <xerox> haha
05:38:47 <xerox> Can we?
05:38:52 <dons> sure
05:39:01 <xerox> We could get them in the middle of type errors?
05:39:10 <xerox> For amuse musasabi even more
05:39:17 <Numbers> Probable fix: WELL BLOW ME DOWN!
05:39:28 <xerox> Pages of type errors, interleaved with Zippies!
05:39:39 <dons> forkIO $ yowSometimes ; yowSomtimes = fix $ \f -> do x <- a random; threadDelay x ; lambdabot "yow" ; f
05:40:06 <dons> modulo correctness ;)
05:40:10 <Numbers> @t fix
05:40:10 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
05:40:23 <dons> fix is the recursion combinator
05:40:31 <Numbers> O_o
05:40:38 <dons> for lazy functional programmers who've given up on explicit recursive calls
05:40:49 <Numbers> oh
05:40:58 <dons> actually, in thise case, I'd forgotten the name of the function i was typing by the end, so named it 'f' instead
05:41:00 <xerox> Yay.
05:41:13 <dons> > fix $ \f -> 1 : f
05:41:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:41:39 <dons> > let f = 1 : f in f -- compare and contrast (3 points)
05:41:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:41:41 <Numbers> > fix 5
05:41:41 <lambdabot>  add an instance declaration for (Num (a -> a))
05:41:58 <Numbers> Ahh.. OK
05:42:09 <dons> ?pl fix $ \f -> 1 : f -- its more point free friendly
05:42:10 <lambdabot> fix (1 :)
05:42:12 <xerox> ?type fix $ \f -> do { x <- (undefined :: IO Int); (undefined :: Int -> IO ()); f }
05:42:14 <lambdabot>   Expecting a function type, but found `t_a1Mw t_a1N8'
05:42:14 <lambdabot>    Expected type: IO a
05:42:17 <dons> > fix (1 :)
05:42:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:42:28 <dons> isn't that a nice function?
05:42:40 <xerox> ?type fix $ \f -> do { x <- (undefined :: IO Int); (undefined :: Int -> IO ()) x; f }
05:42:41 <lambdabot> forall b. IO b
05:42:50 <xerox> Nice.
05:43:05 * xerox makes a post it with this code
05:43:45 <Numbers> > fix (1 +)
05:43:47 <lambdabot>  Exception: <<loop>>
05:43:58 <Numbers> > fix ((1 +) :)
05:43:59 <lambdabot>  Add a type signature
05:44:12 <roconnor> > fix (1:)
05:44:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:44:15 <dons> ?type fix ((1 +) :)
05:44:16 <lambdabot> forall a. (Num a) => [a -> a]
05:44:21 <dons> not quite right
05:44:28 <xerox> Why?
05:44:47 <dons> ?type fix ((1 +) :)
05:44:49 <lambdabot> forall a. (Num a) => [a -> a]
05:44:53 <dcoutts> dons, did you get similar benchmark result?
05:44:54 <dcoutts> http://dhcp0332.gradacc.ox.ac.uk:8080/~duncan/fps-unstable/tests/
05:44:56 <lambdabot> Title: Index of /~duncan/fps-unstable/tests
05:44:57 <xerox> > (foldl (.) id . take 10 $ fix ((1+) :)) 0
05:44:58 <lambdabot>  10
05:45:02 * shapr boings
05:45:04 <dons> dcoutts: still building ghc :/
05:45:08 <dons> it broke somewhere
05:45:10 <dcoutts> dons, ah ok :-)
05:45:10 <xerox> You can use that :)
05:45:14 <xerox> ?wiki Compose
05:45:14 <lambdabot> http://www.haskell.org/haskellwiki/Compose
05:45:16 <dons> and i had to unpull , and the pull other patches
05:45:17 <xerox> With this -^
05:45:20 <dcoutts> dons, you're using the same snapshot?
05:45:22 <dons> all grumble grumble bah
05:45:23 <dons> yes
05:45:29 <Numbers> take 10 $ fix ((1+):)
05:45:29 <dcoutts> ghc-6.5.20060724
05:45:31 <dons> but it was borkified on openbsd
05:45:33 <Numbers> > take 10 $ fix ((1+):)
05:45:34 <lambdabot>  Add a type signature
05:45:35 <dcoutts> oh :-(
05:45:43 <dons> so i had to switch to the darcs repo, and cherry pick
05:45:47 <Numbers> Oh well.
05:45:51 * dons checks out his build
05:46:05 <dcoutts> dons, because there's lots of breakage from recent darcs versions
05:46:16 <dcoutts> the big module/package name overhaul
05:46:28 <dons> dcoutts: yes. i'm making sure not to pull after the 25th
05:46:31 <dcoutts> right
05:46:36 <dons> it was a matter of unpulling a few things before then
05:46:37 <shapr> eek "A copy of glibc was found in an unexpected directory. \n It is not safe to upgrade the C library in this situation; \n please remove that copy of the C library and try again. \n dpkg: error processing /var/cache/apt/archives/libc6_2.3.6-16_i386.deb"
05:47:12 <shapr> I like new things and I like surprises, except when they're errors.
05:50:04 <Numbers> Is there any advantage to \f _ = y over \f x = y?
05:50:23 <dons> well, neither is legal :)
05:50:30 <dons> ?pl \f x -> y -- you mean?
05:50:31 <lambdabot> const (const y)
05:50:36 <Numbers> Yeah.
05:50:39 <Numbers> OOps. :)
05:50:47 <dons> but 'y' is free?
05:50:48 <Igloo> The former silences a warning
05:51:12 <Numbers> y is independent of x.
05:51:23 <dons> that's the main reason to drop an underscore in, as Igloo says
05:51:27 <Igloo> And as warnings help you find bugs, having incorrect warnings silenced is useful
05:51:28 <Numbers> OK
05:51:34 <bringert> hi #haskell
05:51:44 <shapr> hej bringert!
05:51:54 <dons> in case you don't want to lose the identifier documentation, you can say _x
05:52:00 <bringert> grr, stupid colloquy betas, I still can't see what I or anyone else says
05:52:03 <bringert> brb
05:52:05 <dons> which should also silence the warnings
05:52:09 <shapr> bringert: I had a bunch of Hope questions, but got distracted before I wrote you an email :-( The only thing I remember now is ...
05:52:13 <shapr> foo
05:53:07 <dons> oh, hmm. now this is interesting...
05:53:19 <dons> xerox: commands like @instances recursively invoke ghci..
05:53:30 <dons> so when we run lambdabot from ghci, well, things get kinky
05:53:34 <xerox> hehe
05:53:43 <xerox> ':def' itself is quite fix-y
05:54:30 <dons> its cool, and underappreciated
05:54:37 * xerox nods
05:58:31 <foxy_> dons: did you catch the rugger?
05:59:19 <dons> yes :P
05:59:29 <dons> great game though
06:00:38 <bringert> hi again
06:02:08 <dons> ah, you surivied, bringert. you using some new client?
06:02:37 <bringert> I was just trying a new beta of colloquy, the client I'm using now
06:03:03 <dons> any good?
06:03:11 <dons> would an irssi user want to switch?
06:03:19 <bringert> it's for OS X only
06:03:27 <dons> ah. that secret cabal
06:05:00 <bringert> I bought a new harddrive (120 GB) for my laptop today
06:05:11 <bringert> and I'm setting up my system again
06:05:17 <bringert> that's why I'm trying new stuff
06:06:10 <Numbers> (insert derisive mac joke here)
06:09:43 <dons> hmm, are there any apps that started out on the mac, and are now available freely elsewhere?
06:10:18 <bringert> iTunes, if you count free as in beer
06:10:29 <dons> but no source
06:10:52 * dcoutts can't think of any
06:10:55 <dons> maybe this is a bit morally suspect, using all the oss tools, but not contributing anything new back
06:11:17 <dcoutts> apple make some minor contributions to gcc
06:11:26 <ValarQ> dons: you can contribute without starting new projects
06:11:26 <dcoutts> and to some web things
06:11:44 <dcoutts> khtml
06:11:45 <ndm> for quite a long time FSF was boycotting Mac's
06:11:49 <Philippa_> sometimes the fact something exists at all is more important than it being free
06:11:59 <ndm> as in delibrately not accepting patches to fix things that were wrong in their software
06:12:05 <ndm> so I guess apple has no love for them
06:12:06 <Philippa_> I get really pissed off with people who release GPLed gamedev libraries "to help to community"
06:12:12 <ValarQ> dons: opendarwin?
06:12:30 <dons> yeah, there's darwin.
06:12:42 <Igloo> Philippa_: Why?
06:12:44 <Philippa_> all it means is you'll never see anything done with those libraries with anywhere near commercial-quality content
06:13:00 <dons> though the open darwin is it more of a token gesture, isn't it?
06:13:10 <dcoutts> Philippa_, maybe that wasn't their aim
06:13:16 * Philippa_ nods
06:13:18 <dcoutts> to get "commercial-quality content"
06:13:29 <foxy_> @where goa
06:13:30 <lambdabot> http://haskell.galois.com/~paolo/darcs/goa
06:13:30 <dcoutts> dons, it's not open anymore :-)
06:13:46 <Philippa_> but the ones I've encountered then go off on one about how evil it is that commercial games use libs that were released freely
06:13:49 <dcoutts> http://opendarwin.org/
06:13:58 <dcoutts> top news item "OpenDarwin Shutting Down
06:13:58 <dcoutts> "
06:14:16 <dons> hmm :/
06:14:46 <Philippa_> thing is, doing so rules out entire genres of game - ones that just don't work without the content
06:15:22 <dcoutts> apple said they'd base OSX on darwin, but OpenDarwin.org were not able to become the upstream development of darwin, it's still done in-house at apple and the sources are not always released
06:16:17 <dons> it just seems that our software disappears into a mac blackhole. unlike the huge cross-pollination between all the linux and bsd systems
06:16:43 * Philippa_ nods
06:16:47 <dons> part of it would be the writing of this fancy gui stuff using non-portable apis
06:16:51 <dons> cocoa stuff and so on
06:17:00 <dons> so it just can't get off the mac in the first place
06:17:00 <Numbers> Apple wants to use the open source community and the prestige but still make money.
06:17:03 <Philippa_> in the case of iTunes I'm inclined to say that it existing at all is probably worth more than it being free at this point
06:17:20 <dons> is there an iTunes for linux, though?
06:17:40 <Philippa_> yeah. That's a bit problematic - the alternative would involve Apple not being able to compete on UI
06:17:42 <xerox> rhythmbox is quite nice
06:17:56 <dcoutts> yah, I was going to mention rhythmbox
06:17:57 <Philippa_> or at least, not to the extent they're used to doing so
06:18:20 <Philippa_> does the windows iTunes run under any of the various emulation or support layers?
06:18:32 <dcoutts> don't think so
06:18:38 <dcoutts> its a natvie win32 app
06:18:57 <SamB_XP> lots of those run under WINE...
06:21:00 <Numbers> I think Windows iTunes relies heavily on Quicktime.
06:21:22 <ndm> xerox: did you manage to get hte espgame thing working?
06:21:36 <xerox> No I am still watching the video
06:21:45 <SamB_XP> Numbers: probably both of them do...
06:21:56 <ndm> well first it crashed firefox, and now it seems to do nothing with IE
06:21:58 <dons> foxy_: you trying out goa?
06:22:06 <ndm> stcuk at "loading Java Applet"
06:22:36 <foxy_> dons, not yet, thinking about Yi integration
06:22:48 <ricky_clarkson> ndm: This is why /topic ##java says "no applets". ;)
06:23:09 <dons> heh
06:31:54 <dons> xerox: ah, still have to handle properly commands that return different lengths of output
06:32:07 <dons> perhaps lambdabot should emit a character to aid parsing its output
06:32:16 <dons> a blank line perhaps
06:37:19 <xerox> dons: I tried to go as far as "lambdabot>" the first time, but I couldn't make it work
06:38:31 <dons> that's what I'm trying now
06:45:36 <shapr> bringert: hiya
06:46:04 <dons> ok, seems to work xerox
06:46:07 <dons> let me push
06:46:41 <petekaz> @hoogle (\\)
06:46:42 <lambdabot> Did you mean: (\\)
06:46:42 <lambdabot> Prelude.undefined :: a
06:46:42 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
06:47:18 <SamB_XP> hmm, well, Inform 7 started on Mac and there is a Windows version and a sort of a Linux version (written in Haskell, no less!)
06:47:19 <ndm> @hoogle \\
06:47:19 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
06:47:25 <ndm> @hoogle \\\\
06:47:25 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\\\'
06:47:30 <petekaz> What does 'xs\\[x]' do?
06:47:32 <ndm> bad hoogle
06:47:38 <ndm> petekaz: set difference
06:47:46 <petekaz> Where is it defined?
06:47:48 <ndm> > "test of this" \\ "tso"
06:47:49 <lambdabot>  "et f this"
06:47:52 <ndm> Data.List
06:47:57 <petekaz> thanks.
06:48:06 <ndm> sorry hoogle wasn't more hepl...
06:48:24 <petekaz> just reading an email on the haskell list and I had never come across it before.
06:48:41 <petekaz> @bitchslap hoogle :-)
06:48:41 <lambdabot> Unknown command, try @list
06:49:37 <dons> mwhhahaha
06:49:37 <dons> Prelude GOA> :version
06:49:38 <dons> lambdabot 4p36, GHC 6.4.2 (OpenBSD i386 )
06:49:38 <dons> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:49:39 <lambdabot> Title: Index of /~dons/lambdabot
06:53:13 <dons> ok, pushed xerox. i think we're just about done. except for maybe making it more robust to possible lambdabot failures (what? failures? lambdabot? no!)
06:56:53 <xerox> dons: hehe right
06:56:57 <xerox> dons: I've written the page
06:57:00 <xerox> ?wiki Roman numerals
06:57:01 <lambdabot> http://www.haskell.org/haskellwiki/Roman numerals
06:57:06 <xerox> ?wiki Roman_numerals
06:57:06 <lambdabot> http://www.haskell.org/haskellwiki/Roman_numerals
06:57:10 <dons> ?karma+ xerox -- wiki contrib
06:57:11 <lambdabot> xerox's karma raised to 22.
06:57:18 <xerox> Hmm, the space is wrong?
06:57:24 * xerox bows
06:57:26 <dons> needs an _ in the url
06:57:45 <dons> very nice.
06:57:58 <xerox> Is it a ?wiki problem, or I did it in a non-idiomatic way?
06:58:07 <xerox> No we have Peano_numbers it seems, okay.
06:58:33 <dons> no, its fine
06:58:54 <xerox> So what's the current situation of goa?
06:58:58 <Igloo> The ?wiki command could presumably do the substitution, though?
06:59:46 <ricky_clarkson> xerox: There are other numerals too, but they aren't ASCII.
07:00:08 <xerox> ricky_clarkson: what do you mean?
07:00:23 <xerox> More glyphs?
07:00:27 <ricky_clarkson> xerox: There are numerals for 5,000, 100,000 etc.
07:00:32 <dons> Igloo: wiki is just a const functoin. But we have gwiki for actual searches
07:00:37 <dons> ?gwiki pointless
07:00:40 <lambdabot> No Result Found.
07:00:42 <xerox> ricky_clarkson: feel free to implement them! (-:
07:00:44 <dons> bah .google foo
07:00:48 <dons> ?gwiki Peano
07:00:50 <lambdabot> No Result Found.
07:00:57 <dons> google doesn't like our wiki
07:01:01 <xerox> ?gwiki Peano numerals
07:01:02 <Igloo> dons: But couldn't it also s/ /_/g?
07:01:03 <lambdabot> No Result Found.
07:01:07 <xerox> :-(
07:01:10 <dons> Igloo: yeah, maybe that's a simple fix :)
07:01:11 <ricky_clarkson> xerox: So how does this benefit from being in the type system?
07:01:19 <dons> ricky_clarkson: is't it obvious! :)
07:01:21 <ricky_clarkson> xerox: Are there compile errors for bad numerals?
07:01:24 <xerox> ricky_clarkson: yes.
07:01:29 <dons> we _all_ need roman numerals in our type
07:01:32 <ricky_clarkson> Ok, cool.
07:01:55 <dons> and didn't you just want to solve your roman numeral math from high school in the ghc type checker?
07:02:14 <xerox> Absolutely.
07:02:20 * xerox just finished high school
07:03:01 <mahogny> hm. would have been nice if when had type  :: bool -> m a -> m ()
07:03:36 <dons> xerox: ok. i added news to the lambdabot home page
07:03:37 <dons> http://www.cse.unsw.edu.au/~dons/lambdabot.html
07:03:37 <lambdabot> Title: lambdabot
07:03:41 <dons> with some goa examples
07:03:43 <xerox> ?type when
07:03:45 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:04:18 <xerox> ?type (. when) . (>> return ())
07:04:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => ((m () -> m ()) -> a) -> Bool -> ()
07:04:23 <xerox> Wooops.
07:05:11 <xerox> ?type (. (>> return ())) . when
07:05:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> m a -> m ()
07:05:16 <xerox> Got them swapped :D
07:05:29 <xerox> Yay for mind-?pl-ing.
07:05:33 <dons> heh
07:05:56 <int-e> I usually stop when looking at an expression ties a knot in my brain.
07:06:14 <xerox> Ah you stop, I should take this in consideration...
07:06:16 <dons> better than having a neuron-stack exhaustion
07:06:20 * xerox giggles uncontrollably
07:06:31 <xerox> It's all due to TheHunter!
07:06:46 <xerox> (Whom is always missing....)
07:06:58 <dons> yeah. that's a pretty influential bit of code. it changed how i wrote haskell
07:07:14 <dons> even philip wadler and lennart were discussing it the other day
07:07:26 <dons> TheHunter should have written a paper about it..
07:08:05 <shapr> Wadler and Augustsson were discussing @pl ?
07:08:13 <xerox> I believe I was bothering him with questions about points-free so much that he wrote point-less.
07:08:17 <dons> yep, shapr
07:08:26 <shapr> On the mailing list, or in person?
07:08:34 <dons> wadler was twisting his head working out some of the (-> a) refactorings
07:08:37 <shapr> heh
07:08:40 <int-e> we could rename @pl to @mpl ... mostly pointless.
07:08:43 <xerox> As everybody :)
07:08:45 <dons> and then lennart showed up to demonstrate
07:08:54 <shapr> Speaking of which, I wish TheHunter would come back and talk to us.
07:09:01 * xerox nods vigorously
07:09:04 <dons> his off in math land, isn't he?
07:09:06 <shapr> He's off in the north of the USA nowadays, isn't he?
07:09:19 <shapr> dons: Wadler was on #haskell?
07:09:20 <dons> yeah. that's math land, isn't it?
07:09:23 <shapr> heh
07:09:25 <shapr> I dunno...
07:09:26 <xerox> %-)
07:09:30 <dons> shapr: no. but he was somehow reading @pl stuff
07:09:33 <dons> maybe the wiki?
07:09:36 <shapr> Maybe so.
07:09:38 <dcoutts_> dons, looks like PADL has had fusion papers before which is good
07:09:39 <dcoutts_> Improved Fusion for Optimizing Generics
07:09:44 <dcoutts_> from two years ago
07:09:47 <dons> dcoutts_: oh, excellent
07:10:06 <dcoutts_> I was otherwise looking through the prevoious papers and thinking it was looking a bit off topic
07:10:23 <dcoutts_> but then the PADL '06 page does seem to indicate they want more practical papers
07:10:32 <dons> yeah.
07:10:43 <shapr> hey dons, what about having the occasional InterHaskell academic IRC meeting?
07:10:44 <mahogny> hm. which are the journals about programming languages that you consider worth reading?
07:10:55 <shapr> mahogny: LtU is pretty good.
07:10:59 <xerox> The Monad.Reader !
07:11:02 <dcoutts_> dons, "is not limited to the scope of the first seven PADL symposia"
07:11:08 <dons> ah
07:11:13 <dcoutts_> so practical is good
07:11:14 <dons> isn't that an interesting phrase
07:11:16 <shapr> Kimbly, LShift, um...
07:11:25 <dons> shapr: i'm all for getting more academics in here
07:11:27 <shapr> roconnor's livejournal is nice.
07:11:33 <shapr> r6.livejournal
07:11:34 <xerox> Where is it?
07:11:40 <dcoutts_> dons, seems like they've had more declarative than practical in previous years
07:11:52 <shapr> Anything by BrianBec is worth reading.
07:12:00 * shapr thinks..
07:12:13 <dons> dcoutts_: ok. i think we should be fine, focus wise
07:12:18 <shapr> Is Tony Finch the guy who's designing the next version of javascript via Haskell?
07:12:19 <dcoutts_> aye
07:12:38 <shapr> Oh hey!
07:12:41 <dons> if term rewriting isn't a declarative thingy , then I'm not sure what would count.
07:12:54 <shapr> I thought of a new command like @pl, @type, etc! We need @laziness
07:13:00 <dons> hmm?
07:13:07 <xerox> It seqs it out?
07:13:12 <shapr> The .hi files can dump laziness info, right?
07:13:12 <dons> like strictness info for a function?
07:13:15 <shapr> Exactly
07:13:15 <dons> yeah
07:13:17 <dons> demand info
07:13:20 <dons> SSLU and so on
07:13:22 <dcoutts_> that'd be nice
07:13:27 <shapr> And it should show strictness for anything in the standard libs.
07:13:30 <dons> ok. yes. we actually talked about that once
07:13:38 <dons> _and_ we have easy access to that ifo
07:13:40 <dons> info
07:13:40 <dcoutts_> preferably in a different presentation than SSLU, I've never understood that
07:13:41 <shapr> yes!
07:13:43 <dcoutts_> it's jut not intuitive
07:13:53 <shapr> dcoutts_: Strict, Lazy, Unboxable.
07:13:59 <dons> dcoutts_: but what about S(U)LL(U)!? that's intuitive ;)
07:14:11 <dcoutts_> shapr, yeah, I know, but it's in one ear and out the other
07:14:15 <dcoutts_> I understand types
07:14:20 <dons> and the parens mean something too...
07:14:23 <dcoutts_> show me Int#
07:14:30 <dcoutts_> I know that's an unboxed Int
07:14:37 <dons> ok, let's see what the libs say for this stuff..
07:14:48 <dcoutts_> or !Int
07:14:50 <dcoutts_> or something
07:14:57 <shapr> That's an idea.
07:15:03 <int-e> so, kinds instead of strange letters?
07:15:07 <dcoutts_> !Int for strict yet boxed int
07:15:09 <shapr> Maybe you could back-annotate the typesig?
07:15:16 <int-e> ! -> # -> * -> * (strict, unboxed, lazy, lazy)?
07:15:24 <dcoutts_> int-e, that's nice
07:15:40 <dcoutts_> even better if it has the original type names too
07:15:43 <dcoutts_> imho
07:15:49 <shapr> Anyway, Hamming's book says that we should be researching the most important questions in our area. Right now, laziness is the biggest mystery to Haskell programmers, even long time users.
07:16:00 <dcoutts_> true
07:16:40 <shapr> I've made a point of finding the benefits of laziness and exploiting them in my programs, but most people instead wildly add strictness to get behaviour they're familiar with.
07:16:45 <dcoutts_> I think I've got an intuition for it, but I'm still flumoxed sometimes
07:16:45 <dons> here we go,
07:16:45 <dons> head :: [a] -> a
07:16:46 <dons>   {- Arity: 1 Strictness: S
07:17:06 <dons> lookup :: GHC.Base.Eq{1} a => a -> [(a, b)] -> Data.Maybe.Maybe{1} b
07:17:07 <dons>   {- Arity: 3 HasNoCafRefs Strictness: LLS
07:17:15 <dons> that seems useable.
07:17:19 <dons> the arity and the strictness
07:17:28 <shapr> So the best way for the average user to find space leaks is to first know where they might happen with a @laziness command, and then to know where they do happen with profiling.
07:17:31 <dons> then we have:
07:17:32 <dons> splitAt :: GHC.Base.Int -> [a] -> ([a], [a])
07:17:32 <dons>   {- Arity: 2 HasNoCafRefs Strictness: U(L)Lm
07:17:44 <dcoutts_> so that's, head :: ![a] -> a ?
07:17:45 <dons> so we'll have to grok this stuff, and make it user-friendly
07:17:49 <shapr> Yes!
07:18:01 <int-e> is that ULS stuff explained anywhere?
07:18:07 <shapr> Unboxable, Lazy, Strict
07:18:10 <dons> int-e, yep the docs on Core
07:18:34 <dcoutts_> dons, it's somewhat related to the custom calling conventions of the wrapper/worker right?
07:18:35 <dons> I think best would be to extract all this into a data file, and then just index it
07:18:43 <dons> dcoutts_: i'd imagine so
07:18:51 <dcoutts_> dons, perhaps all we need is the type of the worker
07:19:01 <dcoutts_> that shows all the unboxing
07:19:01 <dons> foldl :: (a -> b -> a) -> a -> [b] -> a
07:19:01 <dons>   {- Arity: 3 HasNoCafRefs Strictness: LLS
07:19:09 <Igloo> You'll need to handle some magic too, e.g. Int# is always marked as L IIRC
07:19:16 <dons> ah.
07:19:21 <Igloo> And you'll need to cope with annotations for dictionaries, too
07:19:41 <dons> $wsplitAt# :: GHC.Prim.Int# -> [a] -> (# [a], [a] #)
07:19:42 <dons>   {- Arity: 2 HasNoCafRefs Strictness: LL
07:19:42 <xerox> dons: that would really help, if it becomes understandable! You can get :laziness !
07:19:46 <dons> illustrates the above
07:19:51 <xerox> (In GHCi, that is.)
07:19:51 <Igloo> Right
07:20:18 <xerox> dons: how are you producing this informations?
07:20:28 <dons> ghc --show-iface GHC/List.hi
07:20:46 <Igloo> With the U(L) in splitAt above, the L is also refering to an Int# AIUI
07:23:42 <dons> on a similar theme, rules that use an identifier are also in the .hi file, and might be useful
07:24:07 <dons>  ?rules head  -- for example
07:24:33 <dons> now, length :: [a] -> GHC.Base.Int
07:24:34 <dons>   {- Arity: 1 HasNoCafRefs Strictness: Sm
07:26:56 * dons sleep
07:27:57 <dcoutts_> g'night dons
07:32:39 <shapr> In any case, having this info available in GHCi would help many people.
07:41:25 <ricky_clarkson> shapr: Hi.  I made that Java layout into a google-hosted project: http://code.google.com/p/anylayout/
07:41:26 <lambdabot> Title: anylayout - Google Code
07:41:49 <ricky_clarkson> I like the way most of the titles lambdabot reports are expressed sufficiently by the URL ;)
07:42:08 <xerox> That's debate topic :)
07:42:25 <shapr> ricky_clarkson: spiffy
07:43:40 <dons> ricky_clarkson: you could submit a patch to make lambdabot a bit smarter regarding when to print url titles
07:43:53 <dons> perhaps if the title words appear in the url, then don't bother?
07:45:41 * dons `seq` sleep
07:45:43 <shapr> ricky_clarkson: Yeah, submit a patch!
07:46:13 * xerox finds amusing dons need to seq sleep to actually do it
07:46:20 <xerox> Lazy bottom!
07:48:07 <dcoutts_> is a lazy bottom the same as a lazy bum?
07:48:57 <int-e> force dons, then sleep.
07:49:04 <int-e> nothing wrong with it.
07:49:57 <Numbers> lazy _|_?
07:59:08 <Peter_Mc> lazy ( | )
08:00:01 <dmhouse> Peter_Mc: ?
08:00:20 <Peter_Mc> I was correcting Numbers' representation of a bottom.
08:00:25 <dmhouse> Oh :)
08:00:31 <dmhouse> _|_ is bottom from type theory.
08:01:00 <Peter_Mc> I thought Type Theory was supposed to *avoid* ambiguity!
08:01:09 <dmhouse> Bottom, in languages with polymorphism, is a value with type forall a. a. (In languages with subtyping, Bot is the subtype of all other types.)
08:01:39 <dmhouse> I.e. every type has bottom, or _|_ (or 'undefined' as it's known in Haskell), as a value.
08:01:58 <Peter_Mc> dmhouse: Thankyou for enlightening me.
08:02:02 <dmhouse> :) Any time.
08:02:29 <Peter_Mc> (But I still prefer my ASCII art version.)
08:02:37 <dmhouse> :P
08:02:46 <dmhouse> _|_ is actually just the ASCII representation.
08:03:05 <Peter_Mc> Fair point.
08:03:10 <dmhouse> â¥ is the proper character.
08:03:23 <dmhouse> (If your font supports that. If not: http://en.wikipedia.org/wiki/Bottom_type.)
08:03:24 <Peter_Mc> wiseass!
08:03:26 <xerox> ?where logs
08:03:26 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
08:04:14 * Peter_Mc wonders what the kanji character for "buttocks" is.
08:06:00 <shapr> ricky_clarkson: Have you used darcs before?
08:07:06 <bolrod> 3 rotated 90 degrees?
08:08:01 <Peter_Mc> boldord: I was using the Japanese style of emoticons, which aren't rotated.  \(^_^)/
08:08:26 <Peter_Mc> boldord: (Whence the musing about kanji.)
08:10:20 <bolrod> Peturd_Mc: try using the <tab>
08:11:10 <Peter_Mc> bold rod:  Good idea!  I'll try it.
08:11:17 <bolrod> argh
08:11:25 <bolrod> liek... >_<
08:11:32 * Peter_Mc nods
08:11:53 <dmhouse> How is that using TAB?
08:12:04 <bolrod> I don't know!
08:12:12 <bolrod> it's like... (>.<)
08:12:15 <bolrod> P:
08:12:19 * Peter_Mc performs the Japanese dogeza (bowing to the floor) to apologise for getting bolrod's name wrong
08:12:28 <Peter_Mc> m(-_-)m
08:12:28 <bolrod> :]
08:12:49 <bolrod> (((^.^)))
08:13:13 <dmhouse> Oh, I get it. Using TAB for name completion. Nothing to do with emoticons :)
08:13:19 <bolrod> yes
08:13:50 <bolrod> Ï
08:14:05 <Peter_Mc> oldbore: So ... seen any good Haskell lately?
08:14:06 <bolrod> that's the 3 rotated 90 degrees ;)
08:14:30 <Peter_Mc> bolrod: Looks like an omega to me.
08:14:37 <bolrod> indeed
08:14:54 <bolrod> now turn your screen 90 degrees.. and it will kind of look like a 3
08:15:18 <Peter_Mc> I can't.  There's a light balanced on top of it.
08:15:31 <bolrod> damn.... you have a CRT?
08:15:31 <dmhouse> bolrod: there's a better character for doing that:
08:15:32 <dmhouse> 3
08:15:39 <bolrod> dmhouse: you're so right
08:15:43 <dmhouse> Now turn your screen 360 degrees... you should see it.
08:15:46 <bolrod> or what about the number 3 ?
08:15:53 <Peter_Mc> Hang on.  I can turn my head instead ...
08:15:55 <bolrod> > ord Ï
08:15:55 <lambdabot>  Illegal character ''\137''
08:15:58 <bolrod> ic..
08:16:16 <bolrod> no.. NO!! You're joking!.. I don't believe you
08:16:19 <dmhouse> > ord 'Ï'
08:16:19 <lambdabot>  Improperly terminated character constant
08:16:22 <Peter_Mc> ... It looks like an epsilon.
08:16:31 <bolrod> haha :P
08:16:32 <Philippa_> Peter_Mc: to go back a bit, "bottom" is the 'least' value in a complete, partially ordered set. In Haskell it's non-termination, pattern-match failure etc because those have "the least" info content
08:16:38 <dmhouse> Peter_Mc: turn it the other way.
08:18:59 <Peter_Mc> Philippa_: Thank you for taking the trouble to explain it to me, but I actually knew that already.  I was just experiencing a flashback to times spent in less well-appointed chatrooms.
08:19:31 <dmhouse> Philippa_: one thing I never got is how types are cpos. What, for example, is the order relationship between True and False?
08:19:57 <Philippa_> dmhouse: partial order. There isn't one, but both're "bigger" than _|_
08:19:58 <Peter_Mc> dmhouse: *Partially* ordered.
08:20:23 <Philippa_> Peter_Mc: heh, fair enough. Just wanted to point out that it's not magically different in type theory
08:20:54 <dmhouse> Ah, gotcha.
08:21:05 <Peter_Mc> Philippa_: a/s/l?
08:21:07 <Philippa_> in light of comments on LtU I think I'll skip the obvious puns this time
08:21:11 <Peter_Mc> Philippa_: Sorry.  I'm off again.
08:21:12 <bolrod> !asl
08:21:17 <dmhouse> So in general are the only pairs in the partial order relation (_|_, other stuff)?
08:21:18 <tennin> are there other order relationships besides that between _|_ and everything else?
08:21:46 <Philippa_> Peter_Mc: I find the obligatory answer's something like 40/m/your underwear...
08:21:51 <tennin> haha, slightly more precise
08:21:58 <Peter_Mc> tennin: Sure.  Whenever one type is "inside" another.
08:22:21 <Philippa_> tennin: actually it's not "everything else" - consider the tuple (12, _|_)
08:22:31 <Philippa_> (and assume a non-strict language)
08:22:40 <Peter_Mc> tennin:  E.g. forall a b . a -> b  is below  forall a . a -> a which is below  Num a => a -> a  which is below  Int -> Int
08:22:57 <dmhouse> Peter_Mc: that's using the subtype relation, though, which is an ordering on types.
08:22:59 <tennin> wait, are we talking types or values here?
08:23:07 <dmhouse> Peter_Mc: we're talking about types being an ordering on values.
08:23:31 <Philippa_> *sigh* yay ambiguity!
08:23:57 <Peter_Mc> dmhouse: Er ... yes.  Sorry.
08:24:14 <dmhouse> The confusing thing is that when you're talking subtyping, 'bottom' (or Bot) often refers to the bottom _type_ of the subtype relation.
08:24:21 <Peter_Mc> dmhouse: Listen to Philippa.  Not me.
08:24:24 <johnnowak> Is it possible in haskell to have a function which conditionally can return values of different types?
08:24:38 <dmhouse> johnnowak: Sure, if you give it a type something like 'Either Foo Bar'.
08:25:02 <johnnowak> dmhouse: so i must explicitly declare it?
08:25:17 <dmhouse> johnnowak: of course. Haskell is strongly typed ;)
08:25:32 <Philippa_> dmhouse: sure, just as when you're talking about values it's the bottom value
08:25:33 <ricky_clarkson> shapr: I use darcs for my main project.
08:25:45 <Peter_Mc> johnowak:  (If you want Lisp, you know where to find it....)
08:25:49 <tennin> (12, _|_) does not embody more information than _|_?
08:25:53 <Philippa_> though yeah, sometimes it's confusing which is meant. Thankfully there's a habit of writing the types Top and Bottom
08:26:03 <Philippa_> tennin: sure it does. _|_ could be /anything/
08:26:04 <johnnowak> dmhouse: well that doesn't mean i'd have to explicitly declare it. you'd think it could do so by looking at the possible exit points of the function, no?
08:26:12 <Philippa_> (that doesn't terminate, of course)
08:26:17 <dmhouse> johnnowak: what do you mean?
08:26:35 <dmhouse> Philippa_: is it true that _|_ <= (12, _|_)?
08:26:38 <Philippa_> whereas with (12, _|_) you've succesfully evaluated the fact it's a tuple and the first value in it
08:26:44 <tennin> why is there no order relationship between the two, then?
08:26:45 <Peter_Mc> johnowak:  It depends what you're trying to do.  Yes, in some contexts it's possible.
08:26:47 <Philippa_> dmhouse: in the most common ordering used, yes
08:26:48 <johnnowak> dmhouse: for example, in pseudocode, something like if(x, return "foo") else(return 10)
08:26:58 <Philippa_> (but only in a non-strict language, in a strict one they're equivalent)
08:27:19 <dmhouse> johnnowak: I assume you mean 'if x then return "foo" else return 10', and no, you need to use a union type for that.
08:27:25 <Peter_Mc> johnowak: 'if x then Left "foo" else Right 10' should do the trick.
08:27:47 <johnnowak> dmhouse: sorry for the odd syntax, I use Io quite a bit :)
08:27:56 <Peter_Mc> johnowak:  The compiler infers the type "Num a => Either String a" for you.
08:28:02 <tennin> ok, I'd thought you were implying there was none
08:28:15 <dmhouse> johnnowak: also, I don't think you're talking monads, so miss out the 'return' (which throws a value into a monad).
08:28:23 <dmhouse> Peter_Mc: only if you tag the results with Left and Right.
08:28:31 <dmhouse> Either is a _tagged_ union type.
08:29:02 <johnnowak> dmhouse: yes, it is just a quick example
08:29:18 <Peter_Mc> dmhouse: If you want Lisp....  ;-)
08:29:39 <dmhouse> johnnowak: so, in summary, you want 'if x then Left "foo" else Right 10', and you'll have the type Either String Int.
08:29:54 <johnnowak> so then the function that calls this function must expect the *exact* union type? in other words, if Foo calls Bar and Bar can return a string or int, that part of foo must expect a string or int?
08:30:24 <dmhouse> If foo calls bar, and bar can return a String or Int. Case matters in Haskell.
08:30:56 <johnnowak> right.
08:31:03 <dmhouse> And yes, you'd need something like (as part of foo): case bar of Left s -> putStrLn s; Right n -> putStrLn (show n)
08:31:12 <Peter_Mc> johnowak:  Exactly.  You have to prove to the compiler that their won't be any type errors in the code.
08:31:14 <dmhouse> Where s would be a String and n an Int.
08:32:10 <johnnowak> Could it accept a strict superset of the returnable types? For example, if foo can return a string or int, could it be called if the caller needs an int, string, or float? or, is "int or string" a distinct type.
08:32:39 <johnnowak> that's really my question, if I'm being clear.
08:32:39 <Philippa_> there aren't "Int or String" types
08:32:40 <Peter_Mc> johnowak:  There are such things as "Type classes" for doing that.
08:33:45 <dmhouse> johnnowak: Although that's not really the Haskell way of doing things.
08:34:02 <dmhouse> Can you describe your problem more generally?
08:34:11 <Peter_Mc> johnowak:  For instance, supposing you are interested in the set of types for which the function "print" is defined.  There is the type class "Show" which includes all of these types, and you can write one piece of code to handle all of them.
08:34:40 <johnnowak> Okay, I think I understand now. Thanks.
08:34:46 <johnnowak> dmhouse: it is just a hypothetical. :)
08:36:07 <Philippa_> johnnowak: the problem with hypotheticals is sometimes they encompass a class of problems with different solutions...
08:36:21 <dmhouse> Peter_Mc: actually, Show is for show. show's more general than print.
08:36:35 <Philippa_> yeah, but print requires show so no biggie
08:36:50 <Peter_Mc> johnowak: My advice is to stop trying to do things in the way that you used to do them in your old language.  When the only tool you've ever used is a hammer, every problem looks like a nail.  Now you've been given a screwdriver; don't bang screws into a wall with it.
08:36:54 <johnnowak> Philippa_: Certainly true -- I was just wondering how the intersection of types is handled.
08:36:58 <Peter_Mc> dmhouse: Yeah, I know.
08:37:13 <johnnowak> Peter_Mc: Please stop making these assumptions. :) That's not at all the case.
08:37:52 <Philippa_> johnnowak: you can put multiple class constraints on the same type variable, Haskell doesn't have anything equivalent to intersection types though
08:37:56 <Peter_Mc> johnowak: I stand corrected.
08:38:39 <johnnowak> Philippa_: Ah, I see. Thanks.
08:39:02 <johnnowak> Does anyone know of a language which does have such intersection types? This is purely a matter of curiosity.
08:39:21 <dmhouse> Any language with subtyping.
08:39:29 <dmhouse> (I.e. most object orientated ones.)
08:39:30 <Philippa_> dmhouse: *No*
08:39:40 <Philippa_> most of them specifically don't have intersection types
08:40:25 <Philippa_> or union types for that matter, subtyping achieves something slightly different (especially when the types require an open-world assumption)
08:40:27 <dmhouse> Ah, hold on, what are we discussing here?
08:40:46 * Peter_Mc is curious to find out what intersection types are, too.
08:41:03 <dmhouse> We definitely _were_ talking about subtyping a while back :)
08:41:08 <Peter_Mc> I vaguely assumed that multiple inheritance == intersection types, but I'm here to learn.  :)
08:41:12 <Philippa_> intersection types are of the form "has types A and B" (but not "is a tuple")
08:41:48 <dmhouse> Right.
08:42:01 <dmhouse> So, anything with duck typing?
08:42:09 <Philippa_> you might have (in the absence of a subtype relationship) "this is both an Int and a Float"
08:42:19 <Philippa_> there're a few interesting constraints they can enforce
08:42:23 <Philippa_> no
08:42:26 <dmhouse> Although with duck typing it doesn't really make sense to say 'A has type B'
08:42:39 <xerox> Why is it called "duck" ?
08:42:41 <dmhouse> Just 'A supports the function f'.
08:42:45 <Philippa_> think of it as a built-in type constructor with a specific meaning, much like ->
08:42:46 <Peter_Mc> dmhouse: Duck typing is a different kind of beast entirely.
08:42:55 <dmhouse> xerox: 'If it walks like a duck and quacks like a duck, it must be a duck.'
08:43:06 <greenrd> Does Template Haskell support explicitly-kinded quantification?
08:43:06 <Philippa_> xerox: walks like a duck, quacks like a duck. Ignore the fact it smells like an orangutang...
08:43:26 <dmhouse> xerox: I.e. if it's safe to call some function on a given value, we infer that value has some type.
08:43:29 <Peter_Mc> Philippa_: Nice one.
08:43:37 <johnnowak> Philippa_: Can you clarify what you mean by types A _and_ B as opposed to types A _or_ B?
08:43:45 <xerox> dmhouse: gotcha!
08:43:58 <xerox> _and_ is product
08:44:12 <SamB> duck typing is called duck typing because, instead of typing, you just ... duck!
08:44:36 * xerox ducks
08:44:37 <Philippa_> johnnowak: you can pass the intersection of A and B as an A. You can also pass it as a B, or as an A^B (where ^ is the intersection 'operator').
08:44:43 <dmhouse> Yeah, it's 'duck' typing because you have to duck all the bug reports that come your way when you publish code that typechecks but isn't right. :)
08:44:47 <Philippa_> SamB: and cover?
08:45:01 <SamB> Philippa_: hmm?
08:45:10 <SamB> oh, yeah, I suppose maybe
08:45:26 <johnnowak> Philippa_: Can you give an example of how that might be used, even if it is rather contrived?
08:46:27 <SamB> okay, so I hear people used solvers to solve adventure. how did they feed the problems to the solver?
08:46:41 <Peter_Mc> johnnowak: There are one or two Design Patterns that simulate multiple inheritance.  Wish I could remember what they were called.
08:46:59 <Peter_Mc> SamB:  Is this a joke?
08:47:26 <johnnowak> Philippa_: Actually, I retract that request. :)
08:47:47 <dmhouse> Peter_Mc: I think it's a reference to the ICFP contest, of which one of the subproblems regarded an adventure game.
08:47:58 <SamB> Pete_I: indeed it is no joke
08:48:08 <SamB> at least, if it is a joke, I must be the butt end of it
08:48:10 <Peter_Mc> Ooh.
08:48:28 <SamB> or, well, you could say the *problem* was a joke
08:48:39 <Peter_Mc> Those crazy mesoamericans!
08:49:01 <Peter_Mc> pre-Colombians!
08:49:03 <Peter_Mc> whatever.
08:49:12 <johnnowak> In regards to Left and Right... is there then no way to conditionally return one of three types?
08:49:16 <SamB> because most of the problems in this year's ICFP contest involved parodies of and/or tributes to real things
08:49:36 <dmhouse> johnnowak: Sure. You could use Either (Either a b) c, or define your own datatype.
08:49:36 <SamB> Either a (Either b c)
08:49:46 <Philippa_> or build a new three-way datatype
08:49:47 <Peter_Mc> johnnowak: Sure.  Left Int  Right (Left String)   Right (Right Foo)
08:49:56 <johnnowak> Ah, I see.
08:50:04 <johnnowak> Well I am learning new things today. :)
08:50:32 * dmhouse wonders whether a general implementation of union types is possible
08:50:34 <SamB> but a more sensible thing might be to just come up with an algebraic datatype that has more mnemonic constructors
08:50:34 <Philippa_> building your own type allows you to assign a little extra meaning, because the type and its data constructors get new names
08:51:05 * SamB waits for Peter_Mc to say the same thing again
08:51:15 <Peter_Mc> dmhouse: You mean Extensible Type Unions?
08:51:17 <Philippa_> dmhouse: it makes sense in a system with arbitrary sums. If you lose disjointness, less so
08:51:31 * johnnowak wonders if someone may be looking for Lisp
08:51:35 <SamB> observe Either String String
08:51:49 <SamB> notice that Either does more than union types
08:52:07 <dmhouse> Yeah, it's a *disjoint* or *tagged* union.
08:52:46 <SamB> anyway, how did people feed their solvers?
08:52:50 <Peter_Mc> dmhouse:  Oh.  You're referring to the *other* kind of union type.
08:53:01 <dmhouse> Peter_Mc: ?
08:53:03 <Philippa_> Peter_Mc: the one that's called a "union type" in the literature, yes
08:53:06 <dmhouse> Peter_Mc: I'm refering to Either.
08:53:21 <Philippa_> wait. Stuff it, I'm losing context left right and centre
08:53:22 <dmhouse> Which is a disjoint union, tagged union, or sum type.
08:53:25 <Philippa_> ignore that :-)
08:53:27 <Peter_Mc> Philippa_: Me too.
08:53:53 <Peter_Mc> Philippa_: And I'm getting my terminology confuzzled, which doesn't help,.
08:55:30 <Philippa_> yeah. It doesn't help that there's a whole pile of related concepts
08:57:21 <Peter_Mc> I need to get some rest.  See you all later, folks.
08:57:35 * vincenz tickle Philippa_ 
08:58:19 <Philippa_> 'lo vincenz
08:58:52 <vincenz> Any news
08:59:21 <Philippa_> none that belongs in here rather than -blah
09:06:08 * dcoutts_ has drawn a pretty diagram of how much space is wasted by the [Char] representation
09:06:17 * Numbers laughs.
09:06:21 <dmhouse> dcoutts: ooh, let's see :)
09:06:30 <dcoutts_> give us a sec..
09:06:47 <dmhouse> dcoutts_: I saw a pretty diagram in one of dons's talks that illustrates that, I think.
09:07:07 * dcoutts_ checks he's not duplicating work...
09:09:02 <dmhouse> Page 7 of http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz
09:11:44 <dcoutts_> yep
09:11:55 <dcoutts_> my diagram is more accurate on space use
09:12:00 <dcoutts_> I use one block per word
09:12:08 <dcoutts_> so including the header word on each block
09:12:21 <dmhouse> Okay, can we see it then? :)
09:13:22 <dcoutts_> http://dhcp0332.gradacc.ox.ac.uk:8080/~duncan/fps/paper/%5bChar%5d.png
09:13:48 <dcoutts_> > 15 * 4
09:13:50 <vincenz> dcoutts_: make em point down!!
09:13:54 <lambdabot>  60
09:13:55 <dcoutts_> bytes
09:14:16 <dcoutts_> vincenz, yeah, ok
09:14:17 <vincenz> the cchar bit is a header?
09:14:22 <dmhouse> 60 bytes?! For "foo"?
09:14:23 <dcoutts_> yep
09:14:27 <vincenz> what's the size of that block?
09:14:28 <dcoutts_> to store 3 8-bit ascii chars
09:14:30 <vincenz> 4 bytes?
09:14:36 <dcoutts_> yes, 4 bytes
09:14:43 <vincenz> but it only shows one letter
09:14:49 <dcoutts_> huh?
09:14:56 <vincenz> [char | 'f']
09:15:02 <dcoutts_> yes, that's one char
09:15:06 <vincenz> so what size is that block?
09:15:11 <dcoutts_> 8 bytes
09:15:15 <vincenz> o.O
09:15:21 <dcoutts_> each block is a word
09:15:28 <vincenz> ouch
09:15:32 <dcoutts_> exactly
09:15:40 <vincenz> I mean a header shouldn't take more than a byte...
09:15:52 <dcoutts_> yep is does
09:15:55 <dcoutts_> it's a pointer
09:16:01 <dcoutts_> to a descriptor
09:16:03 <vincenz> ah right
09:16:10 <vincenz> and then the char has to be word aligned
09:16:12 <dcoutts_> so it's 8bytes on a 64bit box :-)
09:16:14 <dcoutts_> right
09:16:23 <ricky_clarkson> dmhouse: http://rickyclarkson.blogspot.com/2006/07/duck-typing-in-java-and-no-reflection.html
09:16:24 <lambdabot> Title: rickyclarkson: Duck Typing in Java, and no reflection
09:16:31 * ricky_clarkson chortles.
09:16:32 <dcoutts_> but also look how they're not contiguous
09:16:45 <dcoutts_> so low locality of reference
09:16:52 <dcoutts_> == lots of cache misses
09:16:54 <dcoutts_> == slow
09:17:22 <vincenz> dcoutts_: can't pack more than one char in that 'f' block?
09:17:37 <dcoutts_> nope
09:17:39 <vincenz> oh wait this is std [Char]
09:17:42 <dcoutts_> yep
09:17:44 <vincenz> do you have a diagram of BS?
09:17:49 <dcoutts_> comming up
09:18:00 <vincenz> so....20 bytes / letter :P
09:18:33 <dmhouse> ricky_clarkson: sweet.
09:20:08 <ricky_clarkson> dmhouse: There's nothing in the def'n of duck typing that prevents a statically-typed language from implementing it, despite what wikipedia says.
09:30:53 <SamB> yeah. you just need to make a type called Duck...
09:31:51 <ricky_clarkson> No, see my blog. ;)
09:32:29 <SamB> hmm, I think I figured out how you feed your solver...
09:32:45 <SamB> too bad there isn't a Haskell mode...
09:33:57 <mahogny> ok! anyone who have experience of the idle callback for gt2hs? the GUI becomes *horribly* inresponsive (read: hangs)
09:35:02 <mahogny> hm. or actually, it only does so for anything but priorityLow. crazy. hm
09:35:12 <mahogny> oh well, whatever works
09:38:19 <Numbers> Hrm
09:38:25 <Numbers> @pl   show wa = show (wallcoords wa)
09:38:25 <lambdabot> show = fix (. wallcoords)
09:39:14 <dmhouse> Hehe
09:39:25 <dmhouse> I wouldn't use that pointsfree version if I were you.
09:39:31 <Numbers> Heh
09:40:49 <Numbers> SInce, like, it doesn't work?
09:44:23 <monochrom> It won't work.  @pl is not aware of typeclasses.  The two "show"s are different.
09:44:23 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
09:49:59 <Buzzons> silly qu
09:50:03 <Buzzons> why doesnt this work
09:50:04 <Buzzons> getTuple :: [(a,b,c)] -> (a,b,c)
09:50:04 <Buzzons> getTuple [] = error "moo"
09:50:04 <Buzzons> getTuple [(a,b,c)] = head[(a,b,c)]
09:50:29 <Buzzons> -- wanting it to return the first tuple
09:51:06 <xerox> You don't have to pattern match like that
09:51:18 <Buzzons> but it fails and i dunno why
09:51:20 <xerox> You should just give a name to the argument
09:51:24 <xerox> getTuple xs = head xs
09:51:34 <Buzzons> *goes to try*
09:51:45 <Numbers> or getTuple x:xs = x
09:51:55 <Numbers> ne?
09:51:56 <xerox> You missed parens there.
09:52:04 <Buzzons> oo it worked :)
09:52:20 <Buzzons> with the xs bit instead of [(a,b,c)]
09:52:21 <Buzzons> ty
09:52:27 <xerox> Buzzons: now, since 'head' is polymorphic on the type the list contains, getTuple is equivalent to head
09:52:36 <Buzzons> very true
09:52:47 <xerox> Also, do you get Numbers' definition?
09:52:49 <Buzzons> i was tryin it in basic stuff, as now i wanna get diff ones out etc
09:52:55 <Buzzons> a what now?
09:53:04 <xerox> getTuple (x:xs) = xs
09:53:07 <xerox> Woops, x.
09:53:12 <xerox> getTuple (x:xs) = x
09:53:14 <Buzzons> yea
09:53:18 <xerox> OK, cool.
09:53:28 <Buzzons> oh yea, i thought you ment sommit other than the dude called Numberss
09:53:31 <Buzzons> * Numbers
09:53:41 * Buzzons fwaps Numbers for having a silly name :p
09:53:43 <Buzzons> ty
09:53:45 <Numbers> :P
09:53:48 <Buzzons> *goes back to failing at haskell*
09:53:50 <xerox> You're welcome.
09:53:56 <xerox> ?oldwiki HaskellDemo
09:53:57 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
09:54:02 <xerox> This contain some syntax reference if you want
09:54:07 <Buzzons> ty
09:54:08 <xerox> ?google Haskell Report
09:54:10 <lambdabot> http://www.haskell.org/onlinereport/
09:54:10 <lambdabot> Title: The Haskell 98 Language Report
09:54:12 <xerox> This contains the proper one :-)
09:54:52 <greenrd> @paste
09:54:52 <lambdabot> http://paste.lisp.org/new/haskell
09:55:58 <lisppaste2> greenrd pasted "confusing quote from lhs2TeX user guide" at http://paste.lisp.org/display/23344
09:56:45 <Numbers> OK.   SO, I've got these functions to make rooms.   Now, if I want to call them with random values, but I want to save the result (i.e. later on I can access the same rooms) How might I go about doing that?
09:56:46 <greenrd> I don't understand the excerpt I just posted
09:57:15 <greenrd> if the current source file is ran through lhs2TeX during compilation, it will enter an infinite loop
09:57:29 <greenrd> if it isn't, ghci won't understand the literate haskell syntax
09:57:53 <greenrd> maybe the \eval command isn't intended for use in this situation
09:57:59 <monochrom> xerox: Nice realization of my crazy dream :)
09:58:05 * xerox tips his hat
10:00:08 <greenrd> unfortunately template haskell can't be used for this problem because it doesn't support explicitly-kinded quantification
10:00:47 <Buzzons> xerox ok trying somthing similar now, to take a list of tuples, and then return a value from one of those lists, the return a tuple bit works, thanks :), and getVal works how can i make getVal work on the getTuple command?
10:00:55 <Buzzons> code being :
10:00:56 <Buzzons> getTuple :: [(a,b,c)] -> (a,b,c)
10:00:56 <Buzzons> getTuple [] = error "moo"
10:00:56 <Buzzons> getTuple xs = (head (tail xs))
10:00:56 <Buzzons> getVal :: (a,b,c) -> b
10:00:56 <Buzzons> getVal (_,b,_) = b
10:01:19 <Buzzons> how can i pass the tuple that getTuple returns into getVal
10:01:20 <xerox> getFoo = getVal . getTuple
10:01:27 <monochrom> Numbers: where do you want to save?
10:01:35 * SamB wonders how to write an Adventure solver...
10:01:39 <xerox> getFoo xs = getVal (getTuple xs)
10:02:12 <Buzzons> thanks :)
10:02:21 <monochrom> SamB: breadth-first exhaustive search
10:02:30 <Numbers> monochrom: I'm having problems with explination.
10:03:03 <monochrom> Numbers: Yes but where do you want to save the rooms?  In a file?  In another variable?  In .... ?
10:03:11 <Numbers> In an imperative language, I would go like myMap = RandomMap().   I could then refer to mymap, and it would stay as the same map.  In Haskell, it would become a differnet map each time, right?
10:03:42 <monochrom> Have you played with the Random module in Haskell?
10:03:53 <Numbers> A little but.
10:03:54 <Numbers> er bit
10:04:00 <Numbers> But I don't really understand it. :)
10:04:05 <monochrom> (What you stated is not entirely true.  More subtle.  There is a choice.)
10:04:39 <SamB> hmm, which goggles should I use...
10:04:55 <Numbers> SamB: The ml goggles!
10:05:01 <SamB> ick
10:05:20 <SamB> they look like the sexp goggles gone mad
10:05:36 <monochrom> OK, play with it more until you understand.  There are two choices.  If you use the IO version, it is just like writing imperative programs.  If you use the other choice, well understand the other choice first, then it's obvious.
10:06:11 <monochrom> I should write some examples in the afternoon.
10:06:46 <Numbers> I think I understand the theory.. I could make a generator, and as long as I gave it the same number, I'd get the same result.
10:06:53 <Numbers> I can't seem to make it work good tho. :)
10:07:15 <yip> Numbers: such a RandomMap() function is not possible to write in haskell
10:07:21 <monochrom> If you are comfortable with imperative programming, do it in IO.
10:07:50 <monochrom> Well in IO you can, yip.  Like getChar.  Different character every time.
10:08:16 <monochrom> The type of RandomMap may be: IO Room
10:08:18 <yip> yeah, but then it wouldn't "become a differnet map each time"
10:08:31 <monochrom> Err IO Map
10:08:39 <Numbers> Yas.
10:10:14 <monochrom> Random.randomRIO ('a', 'z')   -- this returns a different character every time
10:10:36 <Numbers> Right.
10:10:37 <dcoutts_> vincenz, ok fixed the diagrams
10:10:48 <dcoutts_> http://dhcp0332.gradacc.ox.ac.uk:8080/~duncan/fps/paper/%5bChar%5d.png
10:10:51 <Numbers> ANd I think I can figure out how to make it like do x <- randomRIO etc.
10:10:56 <ricky_clarkson> monochrom: Then it isn't random.  Sometimes it must give the same one twice. ;)
10:10:58 <monochrom> Use newStdGen or setStdGen at the beginning of your program to initialize or randomize the seed.
10:11:00 <dcoutts_> http://dhcp0332.gradacc.ox.ac.uk:8080/~duncan/fps/paper/ByteString2.png
10:11:15 <monochrom> ricky_clarkson: Heh, you're right
10:11:41 <dcoutts_> so the space usage for [Char] is  c * 20 bytes, for ByteString it's c + 32 bytes
10:11:57 <SamB> I feel like I want to use the XML goggles except that the indentation makes it too much work to copy/paste the output out of the xterm...
10:12:06 <monochrom> do { x <- randomRIO ('a', 'z'); y <- randomRIO ('a','z'); return [x,y] }  :: IO String
10:12:07 <dmhouse> dcoutts_: is there no overhead from the byte array?
10:12:25 <dmhouse> Apart from the header.
10:12:27 <dcoutts_> and number of allocations is c * 2 for [Char] and 3 for ByteString
10:12:29 <monochrom> The above code returns a random string of length two.
10:12:59 <dcoutts_> dmhouse, possibly, not sure I'll have to check
10:13:15 <xerox> ?type Control.Monad.Fix.fix $ \f -> do { x <- System.Random.randomRIO ('a','z'); y <- f; return (x:y) }
10:13:16 <lambdabot> IO [Char]
10:13:20 <xerox> (-%
10:13:41 <dmhouse> xerox: well done. :)
10:15:15 * dmhouse goes back to writing about continuations
10:17:31 <vincenz> dcoutts_: \o/
10:17:36 <Numbers> Hrm.
10:17:46 <Numbers> Monads make me cry.  Back to the tutorials. :)
10:17:58 <vincenz> dcoutts_: what do you use? opendraw?
10:18:04 <dcoutts_> dia
10:18:27 <vincenz> dcoutts_: ah... right used to use dia too but it's yucky
10:18:32 <vincenz> dcoutts_: try opendraw
10:18:44 <vincenz> part of openoffice
10:18:51 <vincenz> much better copy pasting and handling on zooming
10:18:57 <vincenz> (dia seriously slows down when zoomed in)
10:19:08 <vincenz> plus you can mass-change items, when you select multiple in dia and change a property, only one changes
10:19:16 <dcoutts_> vincenz, OOo doesn't run on my 64-bit box
10:19:19 <vincenz> oh :
10:19:21 <vincenz> :/
10:19:24 <dmhouse> How about Kivio?
10:19:31 <dcoutts_> there's also inkscape
10:19:35 <dmhouse> I haven't played with it that much but I know it exists :)
10:19:53 <cathper> Mmm, xfig :-)
10:20:03 <dcoutts_> I tend not to run K* programs
10:20:05 <Paltas> dia :)
10:20:14 <Paltas> oh doh :)
10:20:18 <dcoutts_> :-)
10:20:23 <vincenz> dcoutts_: inkscape is nice for fancy stuff... it's not great for diagram editing... the easy stuff is made hard
10:20:32 <dcoutts_> heh
10:20:37 <dmhouse> dcoutts_: why not?
10:20:40 <dcoutts_> dia is ok for this kind of thing
10:20:49 <dmhouse> (And what about amaroK? :))
10:20:50 <vincenz> well I used to use dia but it sriously frustrated me
10:20:53 <dcoutts_> dmhouse, it means compiling QT/KDE
10:21:02 <dmhouse> dcoutts_: gentoo user? :)
10:21:07 <dcoutts_> vincenz, yeah I can understand that
10:21:11 <dcoutts_> dmhouse, aye
10:21:28 <dmhouse> dcoutts_: then fair enough.
10:21:42 <dcoutts_> actually it's just prejudice against C++
10:26:08 <dcoutts_> actually I believe I can run OOo on my sparc, but it'd take several days to compile :-)
10:27:01 <neologism> dcoutts_: I think OOo is not 64bit clean so if that sparc is 64bit yo are out of uck
10:27:05 <neologism> luck
10:27:19 <dcoutts_> neologism, it's a 64bit sparc, but runs 32bit userspace
10:27:43 <neologism> isnt it easier to ssh -X somewhere ooffice ? :)
10:27:58 <dcoutts_> my other box is 64bit so I'm out of luck :-)
10:28:24 <neologism> I run these things (big gui things) at school
10:28:49 <dcoutts_> I don't often feel the need to use it anyway so I can't be bothered to sort it out
10:28:56 <dcoutts_> latex for papers
10:29:05 <dcoutts_> html for presentations
10:29:27 <mwolak> Is there any way to tell haskell that I don't care about the order in which a couple of IO () statements are executed?
10:29:53 <dcoutts_> mwolak, not exaclty
10:30:11 <mwolak> rats, thanks
10:30:21 <dcoutts_> mwolak, you can delay a single IO operaton so that it happens whenever its result is needed
10:30:28 <dcoutts_> which might be never
10:30:57 <dcoutts_> mwolak, what are you really tring to do?
10:31:01 <mwolak> don't think that would work for me
10:31:25 <dcoutts_> not caring about the order of just two operations is easy! just statically pick one to go first ;-)
10:31:38 <dcoutts_> so perhaps you do care?
10:32:07 <mwolak> I've got a network that want to print as "Node 1\nNode 2\nConnect 1 2"
10:32:45 <dcoutts_> ok
10:32:49 <mwolak> things get messy with recurrent networks
10:32:56 <mwolak> I've got a State version that works
10:33:36 <mwolak> I'm pretty sure how to modify the IO version to work (keep the connections in a list, print that out last)
10:34:00 <dcoutts_> sounds reasonable
10:34:04 <mwolak> but it would have been nicer if I could just tell haskell I didn't care about the order :P
10:34:10 <shapr> value recursion? mdo!
10:34:19 <mwolak> using mdo :)
10:34:38 <SamB> okay, so I've written an sexpression parser...
10:34:56 <Numbers> Sounds kinky.
10:35:08 <SamB> data SExp = SList [SExp]
10:35:08 <SamB>           | SString String
10:35:08 <SamB>           | SSymbol String
10:35:08 <SamB>             deriving (Eq, Ord, Show)
10:35:16 <SamB> parseSExp  = spaces >> parseSExp'
10:35:17 <SamB> parseSExp' = do x <- (between (char '(' >> spaces) (char ')' >> spaces)
10:35:17 <SamB>                               (liftM SList (many parseSExp'))
10:35:17 <SamB>                       <|> liftM SSymbol (many1 (letter <|> oneOf "_"))
10:35:17 <SamB>                       <|> liftM SString (between (char '"') (char '"')
10:35:19 <SamB>                                                  (many (noneOf "\""))))
10:35:21 <SamB>                 spaces
10:35:23 <SamB>                 return x
10:35:32 <shapr> mwolak: Sounds interesting, what are you writing?
10:36:10 <mwolak> DSL for describing spiking neural networks
10:36:17 <shapr> oh neat
10:36:21 <dcoutts_> mwolak, one normally end up calculating things in some order, even if that order isn't interesting or significant
10:36:23 <shapr> I bet mdo rocks for ANNs.
10:36:28 <mwolak> it does!
10:36:56 <mwolak> though I'm doing the simulator in C, cause I need the speed :(
10:37:18 <shapr> Oh hey, you could have a manager thread that takes requests, and then have the code post a request for the IO action.
10:37:38 <shapr> That's how Oleg did the pure filesystem stuff.
10:38:28 <mwolak> think I'm gonna go with the list thing, cause I can rip that off the State version :)
10:38:52 <shapr> Is your ANN code open source?
10:39:09 <mwolak> it will be, when it's in releasable state
10:39:15 <shapr> Spiffy, I look forward to it.
10:39:25 <mwolak> there's not much to it though...
10:40:04 <mwolak> got put on hold a while cause I wasn't looking forward to doing the simulator, but ICFP contest got me back in the mood
10:40:04 <shapr> It's the mdo usage I want to peruse.
10:41:31 <psi> what's mdo?
10:41:53 <mwolak> oh, that part's small!
10:42:18 <dmhouse> psi, syntactic sugar for mfix.
10:42:20 <mwolak> class (MonadFix m) => NNet m n where
10:42:21 <mwolak>     neuron :: Nprops -> [n] -> m n
10:42:21 <mwolak>     synapse :: n -> n -> m ()
10:42:21 <mwolak>     getProps :: n -> m Nprops
10:42:43 <mwolak> instance NNet (State NetState) Int where
10:42:43 <mwolak>     neuron props parents = do
10:42:43 <mwolak>         (id,neurons,synapses) <- get
10:42:43 <mwolak>         let newSyn = map (\n -> (n,id)) parents
10:42:43 <mwolak>         put (id+1,(id,props):neurons,newSyn)
10:42:44 <mwolak>         return id
10:42:46 <mwolak>     synapse source dest = do
10:42:48 <mwolak>         (id,neurons,synapses) <- get
10:42:50 <mwolak>         put (id,neurons,(source,dest):synapses)
10:42:54 <mwolak>     getProps n = do
10:42:56 <mwolak>         (id,neurons,synapses) <- get
10:42:58 <mwolak>         return (fromJust $ lookup n neurons)
10:43:00 <mwolak> hopeNet :: (NNet m n) => m n
10:43:02 <mwolak> hopeNet = mdo
10:43:04 <mwolak>     n1 <- neuron BlankProps [n1,n2]
10:43:06 <mwolak>     n2 <- neuron BlankProps [n1,n2]
10:43:08 <mwolak>     return n2
10:43:21 <psi> dmhouse: mkay... *looks up mfix*
10:43:27 <dmhouse> @index mfix
10:43:27 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
10:43:29 <mwolak> perhaps that was a little too large to paste :/
10:43:32 <dmhouse> @fptools Control.Monad.Fix
10:43:32 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad/Fix.hs
10:43:50 <psi> @type mfix
10:43:51 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
10:45:51 <mwolak> mostly I'm ripping off^H^H^H^H^H^H^H^H^H^H^H being heavily inspired by http://www.cs.chalmers.se/~koen/Papers/lic.ps
10:46:32 <mwolak> they mention using mfix, but dismiss it as being a pain... but that was before mdo was introduced, I think
10:57:12 <Buzzons> hey, why wont this work
10:57:12 <Buzzons> getVal :: (a,b,c) d -> b
10:57:12 <Buzzons> getVal (a,_,_) 1 = a
10:57:12 <Buzzons> getVal (_,b,_) 2 = b
10:57:12 <Buzzons> getVal (_,_,c) 3 = c
10:57:32 <dmhouse> Buzzons: the type's wrong.
10:57:37 <Buzzons> why??
10:57:41 <dmhouse> Buzzons: why did you put down what you wrote as the type?
10:58:00 <Buzzons> oo sec
10:58:05 <Buzzons> brb
10:58:29 <dmhouse> (In fact, you're going to run into trouble, because what you wrote isn't typeable unless the three tuple elements have the same type.)
10:59:04 <dmhouse> (And yes, all you keen #haskellers, I'm precluding the fact that you could probably use some typeclass dark arts to get it to type.)
11:00:40 <monochrom> getVal :: (a,a,a) Int -> a
11:00:55 <monochrom> Please don't confuse type variables with parameter variables!
11:01:06 <monochrom> err
11:01:11 <monochrom> getVal :: (a,a,a) -> Int -> a
11:01:26 <dmhouse> monochrom: I thought it might be more instructive to have him justify what he'd already written.
11:01:42 <dmhouse> And possibly get him to correct it himself ;)
11:02:10 <monochrom> mwolak's application of mfix and mdo is nice!
11:02:27 <mwolak> thank you!
11:02:56 <mwolak> ooh, hoogle got shinier!
11:03:53 <zarvok> mmm colors
11:03:54 <Buzzons> i dont want it the same type
11:03:59 <Buzzons> i want it to be polymorphic
11:06:15 <dmhouse> Buzzons: okay, well think about it:
11:06:28 <dmhouse> What would getVal ('a', 1, True) 1 be?
11:06:43 <Buzzons> that
11:06:55 <Buzzons> well 'a'
11:07:03 <Buzzons> or at least thats what i want it to be
11:07:05 <mwolak> You could make a new datatype, like Either but with 3 types
11:07:35 <dmhouse> Buzzons: right, but what about getVal ('a', 1, True) 2?
11:07:48 <mwolak> getVal :: (a,b,c) -> Int -> MYthing a b c
11:07:58 <dmhouse> Buzzons: it'd be 1, right?
11:08:01 <Buzzons> yea
11:08:04 <Buzzons> no..
11:08:07 <Buzzons> oh yea
11:08:09 <Buzzons> sorry
11:08:11 <Buzzons> :p
11:08:12 <dmhouse> Buzzons: but 'a' and 1 are different types.
11:08:20 <Buzzons> ya yea, cos it indexes from 0
11:08:30 <Buzzons> so 1 is the 2nd value in, which is 1
11:08:31 <dmhouse> It doesn't matter where it indexes from.
11:08:51 <dmhouse> Your function would have a different type depending on its second parameter, which you can't do
11:09:00 <Buzzons> oh
11:09:08 <Buzzons> i see where your commin from
11:09:15 <Buzzons> can i toString it?
11:09:21 <Buzzons> or whatever it is in haskell
11:09:29 <Buzzons> to make it all strings?
11:09:35 <dmhouse> That's a bad idea.
11:09:38 <Buzzons> it is?
11:09:41 <sjanssen> > show ('a', 1, True)
11:09:42 <lambdabot>  "('a',1,True)"
11:09:46 <Buzzons> well no
11:09:57 <dmhouse> It doesn't actually _solve_ your problem.
11:10:05 <Buzzons> i mean you take the 'a' the 1 and the True and string it so its just 'a' '1' and 'True'
11:10:13 <Buzzons> well it means all the outputs are strings
11:10:17 <dmhouse> You'd have to get the value out of the String at the other end, though.
11:10:25 <Buzzons> meh
11:10:25 <dmhouse> And that just moves the un-typeableness to that point.
11:10:42 <dmhouse> Buzzons: you basically have 2 options.
11:10:43 <sjanssen> unless the only thing you need to do is print out the string representation
11:11:07 <dmhouse> 1) define three different functions: fst3 :: (a, b, c) -> a, snd3 :: (a, b, c) -> b, thd3 :: (a, b, c) -> c
11:12:30 <dmhouse> 2) Define a 'union type' which covers the three types you might return.
11:12:36 <dmhouse> (This would be like Either.)
11:13:02 <dmhouse> I think the first option is the better one, to be honest.
11:15:05 <Buzzons> k
11:21:05 <Buzzons> er ok
11:21:06 <Buzzons> i tried that
11:21:09 <Buzzons> and now i cant get it working
11:21:15 <Buzzons> getValst :: (a,b,c) -> a
11:21:15 <Buzzons> getValst (a,_,_) = a
11:21:15 <Buzzons> getValsnd :: (a,b,c) -> b
11:21:15 <Buzzons> getValsnd (_,b,_) = b
11:21:15 <Buzzons> getValtrd :: (a,b,c) -> c
11:21:16 <Buzzons> getValtrd (_,_,c) = c
11:21:18 <Buzzons> they all work fine
11:21:23 <Buzzons> getFoo xs d e = if e == 1 then getValst(getTuple xs d) else if e == 2 then getValsnd(getTuple xs  d) else getValtrd(getTuple xs d)
11:21:26 <Buzzons> why then does that fail
11:21:42 <Buzzons> it worked with just getVal (a,_,_) = a
11:21:47 <ricky_clarkson> Is Dave Herman a member of this channel?
11:21:49 <Buzzons> so the getTuple bit etc is all correct
11:23:13 <Buzzons> eg : getBar xs d = getValst(getTuple xs d) == that works fine
11:23:47 <sjanssen> Buzzons: you have the same problem as earlier, you just pushed it into a different function
11:24:14 <sjanssen> the type of your result depends on the value of the 'e' parameter
11:24:25 <_Codex> buzzons: if statement requires that return type is the same for all branches.
11:25:00 <Buzzons> bah!
11:25:09 <Buzzons> so how can i er get around that
11:25:14 <dmhouse> You don't want to.
11:25:19 <Buzzons> i do!
11:25:26 <dmhouse> You don't define your getFoo :)
11:25:32 <Buzzons> so?
11:25:33 <dmhouse> What do you want to do, more generally?
11:25:35 <Buzzons> it works fine
11:25:47 <_Codex> buzzons: you need something like this; getFoo :: .... -> Either3 a b c
11:25:51 <Buzzons> take a list of tuples and return a value from one of the tubles
11:26:05 <sjanssen> @djinn (a, b, c) -> a
11:26:06 <lambdabot> f (a, _, _) = a
11:26:10 <Buzzons> _Codex it was working fine withuot a deffinition before(when i just had getVal)
11:26:12 <dmhouse> _Codex: I doubt that's the best solution.
11:26:30 <dmhouse> Buzzons: more general than that. What problem are you trying to solve?
11:26:34 <Buzzons> but i want it so you can say i want to take the 3rd value of the 5th tuple
11:26:47 <Buzzons> then use same code to take the 1st value of the 15th tuple
11:27:17 <sjanssen> Buzzons: can't be done without type classes
11:27:17 <Buzzons> getBar xs d = getValst(getTuple xs d) -- this gives me the first value of the given tuple (d)
11:27:18 <dmhouse> Unless the tuple elements are all the same type, you can't do that.
11:27:23 <sjanssen> and that is an advanced technique
11:27:30 <Buzzons> bah!
11:27:46 <sjanssen> actually, it can't really be done with type classes either
11:28:24 <dmhouse> Buzzons: _why_ do you want to write this function?
11:28:29 <sjanssen> the problem is that you need to know the type of your result at compile time, but you don't know the value of the argument until run time
11:28:52 <Buzzons> dmhouse to see if i could?
11:29:05 <Buzzons> why do any of you actualy WANT to use haskell? its kind of a silly question to ask :p
11:29:14 <Buzzons> sjanssen mkay
11:29:21 <Buzzons> so its actualy nearly impossible to do in haskell?
11:29:27 <dmhouse> Yeah.
11:29:32 <Buzzons> k
11:29:32 <Buzzons> :(
11:29:36 <_Codex> buzzons: it's clean.
11:29:48 <Buzzons> it was a retorical question :p
11:30:15 <monochrom> I like Haskell for its safe typing and lazy evaluation.
11:30:37 <dmhouse> monochrom: < Buzzons> it was a retorical (sic) question :p
11:30:52 <Buzzons> :)
11:30:52 <monochrom> It was a rhetorical answer.
11:30:55 * SamB wonders how to neatly get to the interesting part of an s-expression
11:30:59 <Buzzons> touché
11:32:09 <sjanssen> @keal
11:32:10 <lambdabot> 99% of my book has been erased by faulty hdd's
11:39:11 <SamB> oh, I could just delete the uninteresting parts of the sexpression...
11:39:31 <monochrom> I was wondering what are the interesting parts.
11:40:40 <madpickle> sexpression
11:40:47 <madpickle> took me a few re-reads before i got that :P
11:42:23 <jcreigh> s-expression. The hypen helps. :)
11:42:49 <jcreigh> hyphen, even
11:49:28 <SamB> took me a reread or two to notice that the h was missing in "hypen"
11:57:50 <vincenz> dcoutts_: saw the pngs of BS
11:58:10 * dcoutts_ always thinks of BS=BullS***
11:58:13 <shapr> Is that like the ides of march?
11:58:20 <dcoutts_> hah
11:58:33 <dcoutts_> berware the pngs of BS
11:58:53 <shapr> Cser is off topic here, we only talk about Hskllrs.
11:59:00 <nclife> ski!!!!
11:59:21 <vincenz> dcoutts_: yeah me too
11:59:31 <shapr> Right, time for focus
11:59:52 <dcoutts_> na, time for tea
12:00:41 <vincenz> time for haskell
12:01:58 <nclife> haskell addict
12:02:45 <dmhouse> Time to write about Haskell.
12:02:53 <vincenz> nclife: yeah I admitit
12:03:14 <vincenz> HoH: hooked on haskell
12:03:25 <vincenz> w
12:04:35 <dmhouse> Does >>= associate?
12:04:43 <dmhouse> I seem to remember that's one of the monad laws
12:04:52 <dcoutts_> yep
12:05:46 <vincenz> test
12:05:46 <vincenz> anyone see this?
12:06:27 <dcoutts_> vincenz, you mean your last line "test" ?
12:07:03 <vincenz> I'm trying to find the powerswitch for my light
12:07:08 <vincenz> cause I have to change the fixture
12:07:12 <vincenz> and instead I rebooted my modem
12:07:22 <dcoutts_> hah
12:10:46 * vincenz did it again
12:18:11 <dmhouse> Haha, cool, I understand how Cont's >>= works.
12:25:06 <dmhouse> @spell auxilary
12:25:08 <lambdabot> auxiliary axillary maxillary ancillary axially
12:28:20 <dcoutts_> dmhouse, you were right, there is an extra word overhead in a MutableByteArray#
12:28:29 <dcoutts_> http://dhcp0332.gradacc.ox.ac.uk:8080/~duncan/fps/paper/ByteString2.png
12:29:00 <dcoutts_> it's the size in words of the array, just for GC purposes
12:29:08 <dmhouse> dcoutts_: fun. What's the purpose of the FCA indirection?
12:29:15 <dmhouse> *FPC
12:29:24 <dcoutts_> ForeignPtrContents
12:29:49 <dmhouse> Oh, right.
12:29:54 <dcoutts_> it's the thing for possibly holding a Finaliser for a foreign object
12:29:59 <dcoutts_> eg mmap
12:30:05 <dcoutts_> with unmmap as a finaliser
12:30:21 <dmhouse> Right.
12:30:23 <dcoutts_> the nice thing is that there's no extra indirection in the normal case
12:30:30 <dcoutts_> that's what the dottedline is
12:30:35 <dcoutts_> it's an Addr#
12:30:46 <dcoutts_> but the GC doesn't follow Addr#'s
12:30:54 <dcoutts_> since they may point out of the Haskell heap
12:31:15 <dcoutts_> so the FPC also has a pointer to the MutableByteArray since this one is allocated on the Haskell heap
12:31:57 <dcoutts_> if it was genuinely a foreign object that the ForeignPtr pointed to, then the FPC wouldn't point anywhere but just hold the Finalisers
12:32:12 <dmhouse> Yeah.
12:32:20 <dcoutts_> data ForeignPtrContents
12:32:20 <dcoutts_>   = PlainForeignPtr !(IORef [IO ()])
12:32:20 <dcoutts_>   | MallocPtr      (MutableByteArray# RealWorld) !(IORef [IO ()])
12:32:20 <dcoutts_>   | PlainPtr       (MutableByteArray# RealWorld)
12:32:43 <dmhouse> Is there no way to avoiding this overhead, given that you always know the ForeignPtr will be pointing to something in the Haskell heap?
12:32:50 <dcoutts_> but we don't
12:32:52 <dcoutts_> that's the point
12:33:03 <dcoutts_> otherwise yes we'd just use a MutableByteArray# directly
12:33:17 <dcoutts_> we can mmap a file to get a ByteString
12:33:22 <dmhouse> Oh? I've missed something then.
12:33:35 <dcoutts_> when we mmap we're pointing outside the Haskell heap
12:33:41 <fasta> What's the point of the OneOf2 constructor in HaXml?
12:33:55 <dmhouse> Aha.
12:34:08 <fasta> Since only one of two can be a valid entry in any readin XML document.
12:34:10 <dcoutts_> dmhouse, and in that case we need a finaliser, ie munmap
12:34:17 <dmhouse> Yeah.
12:34:41 <dcoutts_> we we can work with C libs that give us big chunks of data without haiving to copy them
12:34:58 <dmhouse> Indeed.
12:35:06 <dcoutts_> that feature should be useful for all sorts of C libs
12:35:27 <xerox> dmhouse: mind explaining Cont's bind?
12:35:46 <dmhouse> xerox: I can tell you how I worked it out
12:35:50 <dcoutts_> where the foreign lib give us a buffer, possibly with some free function we need to use when the buffer is no longer required
12:35:54 <xerox> dmhouse: it would be great.
12:36:00 <dmhouse> All right:
12:36:13 <dmhouse> square :: Int -> Cont r Int; square n = return (x ^ 2)
12:36:55 <xerox> Would it be square n = return (n ^ 2) ?
12:37:05 <dmhouse> Err, yeah :)
12:37:16 <dmhouse> printSquare :: Int -> Cont r (IO ()); printSquare n = square n >>= return . print
12:37:31 <dmhouse> Then use the definition of Cont's >>= to express it in terms of lambdas only
12:37:39 <dmhouse> Then once that's done, add an extra stage:
12:37:51 <dmhouse> addThree :: Int -> Cont r Int; addThree n = return (n + 3)
12:37:57 <dmhouse> printSquare becomes:
12:38:12 <dmhouse> printSquare n = square n >>= addThree >>= return . print
12:38:21 <dmhouse> And then hopefully the pattern should be visible.
12:38:57 <xerox> No idea. Thanks anyway :-)
12:38:59 <dmhouse> Tip: ignore the newtype cruft that Cont provides, and pretend Cont is a straightforward type synonym.
12:39:18 <dmhouse> xerox: I'm saying you should expand that out to just the lambdas, using the definition of >>= and return.
12:39:31 <fasta> How can one know which of the 3 values is actually supplied in a value of type (OneOf3 Foo Bar Baz)?
12:39:34 <xerox> So what does exactly Cont give you in that expression?
12:39:41 <fasta> It certainly isn't encoded at the type level.
12:39:53 <dmhouse> xerox: work it out :)
12:39:59 <xerox> dmhouse: OK! Thanks.
12:40:33 <dmhouse> xerox: hopefully the wikibook module I'm writing should clear things up.
12:40:53 <fasta> Did anyone here ever use HaXml?
12:41:06 <dmhouse> fasta: perhaps it's a union type?
12:41:11 <xerox> dmhouse: what's its url?
12:41:37 <dmhouse> xerox: I got the definitions from http://www.nomaware.com/monads/html/contmonad.html
12:41:41 <lambdabot> Title: The Continuation monad
12:41:45 <fasta> dmhouse: why is that relevant?
12:41:58 <dmhouse> fasta: then you could pattern match to see which value it is
12:42:02 <dmhouse> fasta: just like Eiher.
12:42:05 <dmhouse> *Either
12:42:52 <fasta> dmhouse: ok, that's the solution.
12:43:05 <xerox> I thought he meant |data OneOfThree a b c = OneOfThree a b c|
12:43:26 <dmhouse> That would be a product type (like a tuple)
12:43:36 <xerox> Surely |data OneOfThree a b c = One a | Two b | Three c| makes things usable :-)
12:44:22 <fasta> data OneOfThree a b c = OneOfThree a b c<- this is a product type?
12:44:35 <xerox> Right, like (a,b,c).
12:44:37 <dmhouse> fasta: yes, it's the same as a tuple.
12:44:47 <nclife> xEErOOx
12:44:55 <nclife> i find you everywhere
12:44:56 <nclife> lol
12:45:05 <xerox> hah hah! Look who's there.
12:45:11 <fasta> dmhouse: oh, if it's isomorphic to a tuple it's a product type?
12:45:16 <nclife> heh heh
12:45:24 <dmhouse> fasta: pretty much. Do you see why?
12:45:46 <dmhouse> fasta: Imagine a type as a set of its possibly values, then interpret 'product' as 'cartesian product'.
12:45:59 <fasta> dmhouse: well, yes, otherwise I would not have come with this relation.
12:46:14 <xerox> nclife - What brings you here? Learning Haskell?
12:46:58 <nclife> nah, i was looking up for a friend who disappeared suddenly
12:47:00 <fasta> dmhouse: Actually, I don't think the problem is solved.
12:47:08 <fasta> dmhouse: it is a product type.
12:47:26 <nclife> and i found him here.. da little pastard :P
12:47:36 <xerox> Whom?
12:47:46 <nclife> ski :)
12:47:49 <dmhouse> Right, so every value OneOfThree a b c has three subvalues, one of type a, one of type b, and one of type c.
12:48:11 <nclife> but he doesnt seem to be here atm
12:48:29 <fasta> dmhouse: yes, and I need to figure out which of the a, b and c actually exists.
12:48:37 <xerox> nclife: he's a great chap! We've both got a ski number of 1 then :-)
12:48:39 <dmhouse> fasta: all three do in every value.
12:48:53 <fasta> dmhouse: can't parse that.
12:49:04 <fasta> dmhouse: oh, right
12:49:13 <dmhouse> fasta: just think tuples :)
12:49:39 <fasta> dmhouse: The point is that only one of them has a sensible value.
12:49:52 <nclife> haha, yes he is (:
12:49:52 <dmhouse> fasta: are you sure it's a product type then?
12:49:57 <fasta> dmhouse: What the other two have is undefined in HaXml.
12:50:10 <xerox> nclife: are you an hardcore prolog coder as ski?
12:50:34 <fasta> dmhouse: no, you are right :)
12:51:03 <fasta> dmhouse: I was completely confused by the module's generated code.\
12:51:08 <fasta> dmhouse: thanks
12:51:20 <dmhouse> fasta: no problem. :)
12:51:38 <nclife> xerox no, in fact i dont program a shite.. i cant remember how to make the hello world program
12:51:57 <nclife> i was a wannabe programmer a while ago
12:52:07 <nclife> no i like physics ^ ^
12:52:07 <xerox> nclife - ``was'' ?
12:52:14 <xerox> Oh, terrific.
12:52:19 <nclife> heheh :P
12:52:52 <fasta> Is there any difference between physics and cs? The physics people just don't know, I guess.
12:53:02 <dmhouse> They're rather different, tbh.
12:53:29 <xerox> nclife: catch you later! ~~
12:53:50 <nclife> okayz xerox-machine
12:54:43 <nclife> i dunno if there's a big difference btw pysics and cs.. all i know is that i <3 knowledge
12:54:52 <fasta> dmhouse: I meant that some physics people think the universe is computable.
12:55:22 <nclife> oh, are you guys into quantum computation and that stuff?
12:55:35 <nclife> i've got a neat link with lectures about that
12:55:40 <dmhouse> Some around here are, yes.
12:55:52 <nclife> do you know David Deutsch?
12:56:27 <nclife> http://www.quiprocone.org/Protected/DD_lectures.htm
12:56:28 <lambdabot> Title: David Deutsch Video Lectures
13:15:48 <wilx> So, to whom do I report a haskell-mode bug?
13:16:14 <dmhouse> Stefan Monnier.
13:16:26 <dmhouse> His email address is at the top of one of the files.
13:16:35 <dmhouse> Although, I think there's actually a bug tracker somewhere
13:16:38 <dmhouse> wilx: what's the bug?
13:17:58 <wilx> It complains about missing charsetp function.
13:18:07 <wilx> But I installed it only through XEmacs' menu.
13:18:10 <wilx> Not from package.
13:18:16 <wilx> I mean, not from sources.
13:20:59 * edwardk boggles at haskell. 
13:21:32 <edwardk> It seems it teaches you so much wonderful higher order thinking. Lets you hide everything in monads. Gives you wonderful hope for the future with laziness...
13:21:47 <edwardk> Then in order to do anything yu have to forget all that, throw away the monads and make everything strict.
13:22:04 <edwardk> =)
13:23:12 <dmhouse> edwardk: :)
13:23:26 <edwardk> Sad but true.
13:35:25 <dcoutts_> edwardk, sometimes lazyness makes things faster
13:37:31 <dmhouse> dcoutts_: sadly more often than not strictness is an advantage, though.
13:37:54 <dcoutts_> true
13:38:09 <vincenz> 1
13:38:10 <dmhouse> Although, as people have pointed out, perhaps people that find laziness slow just aren't writing lazy code the way it was meant to be written.
13:38:25 <dcoutts_> aye
13:38:31 <dcoutts_> I'm sure there's a lot of that
13:38:54 <dcoutts_> when you need lazyness, the workaround that do not involve using it are quite ugly
13:39:00 <dcoutts_> so it's good to have
13:39:08 <dcoutts_> to have available
13:39:31 <dcoutts_> I'm prepared to believe that a strict by default language might be good
13:39:40 <dmhouse> I do believe, however, that Haskell could do more to make strictness easier.
13:39:55 <dcoutts_> but I don't want to have the lazyness change the type like it does in ML
13:40:06 <dcoutts_> making the lazyness explicit in the interfaces
13:40:14 <dcoutts_> that's bad for modular programming
13:40:21 <dmhouse> Right.
13:40:45 <dmhouse> Is it possible to have a 'strict where possible, lazy when necessary' approach?
13:41:00 <dmhouse> I.e. anywhere you need corecursion or tying-the-knot, make it lazy, but otherwise, have it strict?
13:41:14 <dcoutts_> well I guess you'd have things strict by default and require annotations to make things lazy
13:41:22 <fasta> Is corecursion the same as tying-the-knot?
13:41:44 <dmhouse> They're probably related.
13:41:45 <dcoutts_> like currently we have lazy by default and annotations to make things strict
13:42:20 <dmhouse> But hey, laziness is prettier, so there.
13:42:23 <dmhouse> :)
13:42:32 <dcoutts_> exactly, it'd make lots of the casual uses of lazyness more ugly
13:42:34 <dmhouse> Let's face it, we're all into programming for the aesthetics anyway.
13:43:02 <dcoutts_> so conclusing, we just need better tools to understnad the lazyness of the code we write?
13:43:15 <petekaz> Clean is strict by default, right?
13:43:20 <dmhouse> Yeah.
13:43:21 <dcoutts_> don't think so
13:43:25 <dcoutts_> is it really?
13:43:34 <dmhouse> Isn't it?
13:44:02 <petekaz> Well, how about the new bang features for strictness?
13:44:06 <petekaz> that should help out right?
13:44:17 <dmhouse> Yeah.
13:44:52 <dcoutts_> dmhouse, looking at the webiste it decribes itself as pure and lazy
13:45:01 <petekaz> you guys are scaring me, if haskellers think laziness should not be default, then I need to reconsider spending all this time learning this oddball language.
13:45:01 <dmhouse> Clean looks like a really great language, but it's commercial, so it's not evolving. Haskell is the future.
13:45:08 <dmhouse> It's based on graph reduction, that's interesting.
13:45:16 <petekaz> What about Ocaml?
13:45:25 <dmhouse> That's not referentially transparent. Eww.
13:46:12 <petekaz> how important is that really?
13:46:23 <dmhouse> I like Haskell's purity.
13:46:37 <petekaz> Did I make the wrong choice with Haskell over Ocaml?
13:47:04 <dmhouse> In terms of 'importance', perhaps not very, but if we'd used hacks like references instead of striving for purity, things like ST would never have been invented.
13:47:12 <dmhouse> ST gives you _pure_ references, I might add.
13:47:24 <dmhouse> petekaz: talk to vincenz. He uses the both.
13:47:25 <petekaz> What is ST?
13:47:32 <dmhouse> A wicked-cool monad.
13:47:45 <dcoutts_> @hoogle runST
13:47:46 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
13:47:46 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
13:47:46 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
13:47:47 <dmhouse> It's a State monad, but based on different concepts of 'state'.
13:47:58 <petekaz> The last language I learned prior to Haskell was Erlang, which I really like.
13:48:05 <dmhouse> vincenz: pingeroo
13:48:15 <dcoutts_> @type Control.Monad.ST.runST
13:48:17 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
13:48:21 <petekaz> vincenz: tell me about ocaml vs haskell.
13:48:54 <dmhouse> Haskell is just as fast as OCaml these days anyway.
13:49:12 <dmhouse> And in 10 years, who knows what kind of importance 'performance' will hold?
13:49:18 <petekaz> I use python all the time at work, I don't care about speed.
13:49:29 <dmhouse> Functional languages are the future, and Haskell is the future of functional languages.
13:49:48 <petekaz> I'm more concerned about the general feeling here that laziness should not be default, but rather optional.
13:50:00 <dcoutts_> most of the ocaml code I see is much more pervaded with side effects than Haskell code where the IO monad encourages you to seperate the IO parts
13:50:08 <petekaz> Which is why I ask about ocaml.
13:50:23 <dcoutts_> petekaz, lazyness is optional
13:50:28 <dmhouse> petekaz: if you don't care about performance, laziness is for you.
13:50:58 <dcoutts_> you can make things strict with annotations or reformulating expressions
13:51:01 <edwinb> Laziness leads to much more beautiful code. Unless you really need the performance, it's a good thing.
13:51:10 <edwinb> And sometimes it's good for performance...
13:51:15 <musasabi> Laziness can be good for performance too.
13:51:33 <petekaz> dcoutts_: right, but you just said earlier that you wished strict was by default.
13:51:35 <dmhouse> Although it _would_ be interesting to see a pure strict language.
13:51:43 <dcoutts_> petekaz, I don't think I do actually
13:51:53 <dmhouse> petekaz: this is purely a performance issue.
13:52:05 <dcoutts_> I do want better tools to help me see and understand the strictness of my code
13:52:19 <petekaz> I see.
13:52:20 <dmhouse> My opinion is that it shouldn't be default, but better support for strictness would be available.
13:52:38 <mnislaih> dcoutts: like a better strictness analyzer?
13:52:46 <dmhouse> Tools, yes. I'd love to see some research about reasoning about space performance for lazy programs.
13:52:50 <musasabi> Having Yi highlight strict variables with a different color would be nice.
13:52:59 <mnislaih> or more like  a GHood on steroids ?
13:53:07 <dcoutts_> mnislaih, no, more like a viewer for the output of a strictness analyser
13:53:30 <mnislaih> I get the point with the example by musasabi
13:53:33 <musasabi> dcoutts_: GHC-API + Yi?
13:53:40 <dcoutts_> musasabi, something like that
13:53:56 <mnislaih> it'd be easier to embed that in VH
13:53:59 <dcoutts_> or as we were discussion eariler some feature in ghci
13:54:08 <dcoutts_> @strictness head
13:54:09 <lambdabot> Unknown command, try @list
13:54:16 <mnislaih> have you looked at the ghci debugger closure viewer ?
13:54:22 <mnislaih> it can help in the same way as Hood does
13:54:30 <mnislaih> only that it's more convenient
13:54:33 <dmhouse> dcoutts_: is that decideable from a compiler's point of view?
13:54:38 * petekaz breathes a sigh of relief knowing his recent time with haskell is not a waste
13:54:40 <dcoutts_> dmhouse, yes
13:54:41 <dmhouse> Hrm, strictness inference. Interesting.
13:54:48 <musasabi> mnislaih: VH is nice, but doesn't help the *nix crowd (which is a majority here).
13:54:53 <dmhouse> petekaz: hasn't it taught you a lot?
13:54:59 <dcoutts_> dmhouse, the compiler already does lots of strictness analysis
13:55:06 <mnislaih> musasabi: still, it'd be easier to do
13:55:36 <dcoutts_> dmhouse, we're just not very good at asking the compile what the strictness it infered was!
13:55:45 <dmhouse> Indeed.
13:56:11 <petekaz> dmhouse: not yet, still striving to understand things!  I like what I see thus far though!
13:56:11 <mnislaih> so has anyone looked at the ghci.debugger closure viewer ? any suggestions or wishes ?
13:56:35 <mnislaih> it can be used to look at strictness (manually) too
13:56:49 <dmhouse> @where soc
13:56:49 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
13:57:06 <mnislaih> @google haskell ghc.debugger closure viewer
13:57:08 <lambdabot> http://www.haskell.org/haskellwiki/Ghci/Debugger
13:57:08 <lambdabot> Title: Ghci/Debugger - HaskellWiki
13:57:18 <dmhouse> mnislaih: at all related to the SoC project to do with that?
13:57:26 <dmhouse> # GHCi based debugger for Haskell
13:57:26 <mnislaih> yep
13:57:26 <dmhouse> * JosÃ© Iborra LÃ³pez * Mentor: David Himmelstrup
13:57:32 <mnislaih> that's me :9
13:57:34 <mnislaih> :)
13:57:47 <dmhouse> Hehe, awesome :)
13:57:59 <dmhouse> Weird, a /who on you reveals a slightly different name.
13:58:26 <dcoutts_> one wants to ask the question: when I force the result of this function, what other expressions/variables/arguments in the function will that force.
13:58:38 <dmhouse> mnislaih: that's on my list of cool things to check out.
13:58:51 <dcoutts_> so you'll notice that return foo doesn't nececessarily force foo
13:59:06 <dcoutts_> which is an example people often don't realise
13:59:15 <dcoutts_> similarly with Just x etc
13:59:51 <mnislaih> I can think of you putting a breakpoint there, forcing the binding, and then examining the rest of things with the closure viewer
14:00:05 <dcoutts_> yes, you can do it dynamically
14:00:06 <mnislaih> that's a bit involved, but would work
14:00:19 <dcoutts_> but I want to see the static analysis really
14:00:29 <dcoutts_> I suppose both are useful
14:00:40 <dcoutts_> the dynamic view is tricker to use but is more detailed
14:01:45 <mnislaih> dmhouse: pepe = jose !
14:02:00 <mnislaih> it's like john = jack, isn't it ?
14:02:09 <dmhouse> Not quite?
14:02:14 <dmhouse> Those are different names, I think.
14:02:23 <mnislaih> well but you get the point
14:02:26 <dmhouse> Sure.
14:09:47 <dmhouse> xerox: pingtastic
14:11:35 <xerox> dmhouse: pongabulous
14:11:52 <dmhouse> xerox: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style#Using_the_Cont_monad
14:12:24 <dmhouse> That (hopefully) makes the basic structure of Cont's >>= and return clear.
14:13:44 <dmhouse> If anyone asks me 'what's your greatest achievement?', my response would currently be 'understanding continuations!'. :)
14:14:12 <fasta> dmhouse: they are not hard when someone properly explains them to you.
14:14:26 * SamB thinks he has written his solver ;-)
14:14:52 <SamB> sadly it is 170 lines
14:15:57 <dmhouse> fasta: not in themselves, but Cont is confusing, and callCC is sheer voodoo at first.
14:16:39 <fasta> dmhouse: call/cc from Scheme (abbreviated) is easy imho
14:16:49 <fasta> dmhouse: I assume in Haskell it's the same?
14:17:02 <dmhouse> Ish.
14:17:06 <xerox> dmhouse: what sense does it make the "Example: Expanding square" code?
14:17:25 <xerox> dmhouse: in particular, the printSquare definition.
14:17:36 <dmhouse> xerox: what's wrong with it?
14:18:30 <xerox> What is a3?
14:18:48 <dmhouse> fasta: the difference between Scheme's and Haskell's is that you can use call/cc anywhere in Scheme, but you can only use it within Cont in Haskell.
14:19:03 <dmhouse> xerox: the number after it's been squared and three added to it.
14:19:22 <fasta> dmhouse: Haskell is so limited
14:19:24 <xerox> Where does it come from?
14:19:38 <xerox> printSquare n = do
14:19:38 <xerox>   sq <- square n
14:19:39 <xerox>   return (print a3)
14:19:43 <dmhouse> xerox: Ah! Tyo.
14:19:45 <dmhouse> *Typo
14:19:50 <dmhouse> xerox: that should be print sq
14:20:17 <xerox> Basically using Cont means starting to write imperative code without purpose? %-)
14:20:40 <xerox> (I.e. code that can be classical declarative Haskell code.)
14:20:59 <roconnor> monad != imperative
14:21:00 <SamB> hmmhmm
14:21:07 <SamB> my solver must not work right...
14:21:11 <xerox> ....or maybe I'm missing someting that Cont gives you?
14:21:12 <dmhouse> xerox: to begin with, yes.
14:21:17 <SamB> or maybe it is absurdly slow...
14:21:18 <roconnor> sequenced <- monad
14:21:29 <dmhouse> xerox: then when callCC gets introduced, BANG!
14:21:37 <roconnor> xerox, it allows you to abort a computation and return early
14:21:41 <xerox> roconnor: I thought imperative was a synonym for procedural.
14:21:44 <roconnor> or retry
14:21:49 <xerox> dmhouse: I am interested in the bang.
14:22:25 <dmhouse> xerox: let me finish the callCC stuff, then it'll All Make Sense.
14:22:49 <xerox> What about that?
14:22:56 <roconnor> xerox: I was thinking of using callCC for my exact real arithmetic implementation.
14:23:04 <musasabi> I think continuations in Scheme were easier to understand than Cont.
14:23:11 <petekaz> Call/cc in scheme lets one modify control flow in all sorts of cool and interesting ways, in haskell, it seems less than useful.  I was thrilled to write a python-like yield operator in scheme using call/cc.
14:23:12 <dmhouse> musasabi: I think that's true.
14:23:13 <SamB> how does my tree type look?
14:23:15 <SamB> data Tree a = Tree [(a, Tree a)]
14:23:15 <SamB> breadthFirst (Tree xs) = map fst xs ++ concatMap (breadthFirst . snd) xs
14:23:27 <roconnor> you are going along doing interval arithmetic, and suddenly your interval is too big ...
14:23:38 <dmhouse> petekaz: coroutines will be one of the examples in the finished wikibook module.
14:23:42 <xerox> SamB - Like a graph? (-:
14:23:44 <roconnor> so call your continuation to restart the whole computation with a smaller initial interval.
14:23:55 <SamB> xerox: why a graph?
14:24:09 <petekaz> dmhouse: nice, I look forward to reading that section.
14:24:15 <dmhouse> xerox: you can look at the big example from all about monads on that page to appreciate the power of the continuation abstraction, but it won't make much sense for now.
14:24:21 <vincenz> ping
14:24:22 <vincenz> what?
14:24:24 <vincenz> dmhouse: you pinged?
14:24:33 <kpreid> SamB: That looks like Data.Tree.Forest
14:24:37 <dmhouse> vincenz: we were discussing OCaml vs. Haskell.
14:24:39 <SamB> kpreid: oh
14:24:43 <xerox> SamB: hmm, no, maybe if the tuple had a list of trees instead of just one
14:24:47 <vincenz> right
14:24:48 <petekaz> vincenz: you use both?
14:24:51 <vincenz> petekaz: yep
14:24:59 <vincenz> well I used ocaml a LOT now I haev switched
14:25:03 <vincenz> so I consider myself an expert in both
14:25:12 <vincenz> not sure if I still use ocaml actively, besides maintaining a tool
14:25:42 <vincenz> my issues with ocaml: non first class data constructors and lack of TCs
14:25:43 <SamB> hmm hmm...
14:25:51 <petekaz> vincenz: so you like haskell better these days?  what are your thoughts on strictness as default vs laziness?
14:26:00 <vincenz> well I used to fear that lazyness would be slow
14:26:03 <vincenz> but that's not so
14:26:16 <vincenz> for the rest I don't think it really matters that much except that laziness does give you some extra options
14:26:45 <musasabi> lazy code = easier to think with and offers more alternatives.
14:26:55 <musasabi> strict code = easier to optimize.
14:27:08 <vincenz> correct
14:27:08 <dmhouse> Yeah.
14:27:25 <dmhouse> With laziness you can pretty much write whatever you want and it'll be executed in the right order.
14:27:40 <petekaz> ok, so I won't be turning traitor and going to the ocaml camp like joel reymont did :-)
14:28:00 <vincenz> well for very heavy data consupmtion
14:28:05 <vincenz> where you know you're not gonna be not using data
14:28:09 <vincenz> ocaml is better imho
14:28:14 <vincenz> but at that point use sml
14:28:23 <vincenz> cause it's got crossmodule optimizations
14:28:41 <dcoutts_> I thought ocaml was typically the fastest ml about
14:28:47 <musasabi> Haskell is bad at numerical computing at the moment.
14:28:50 <dcoutts_> including mlton
14:28:54 <vincenz> dcoutts_: not for crossmodule optimizations
14:28:58 <vincenz> aka if you have a routine in module A
14:29:02 <vincenz> and call it in an inner loop in B
14:29:03 <musasabi> Even lots of data + network is no problem for Haskell
14:29:05 <vincenz> heh...
14:29:40 <vincenz> musasabi: well then network is the bottleneck, not the memory subsystem
14:29:52 <vincenz> I'm talking pluriGigabyte
14:29:53 <SamB> why am I supposed to do a breadth-first search anyway?
14:29:59 <dcoutts_> musasabi, what do people need for numerical stuff? is it just because the numerical people come along to haskell and then naievely use lists of ints ?
14:30:20 <vincenz> dcoutts_: I like the use lazy array pattern :)
14:30:28 <musasabi> dcoutts_: fast easy multidimensional arrays I think.
14:30:55 <vincenz> musasabi: heh... that's funny cause if you look at matlab, most arrays are stored sparsely
14:31:06 <dcoutts_> musasabi, so we've got UArray (Int, Int, Int) Int and STUArray
14:31:21 <musasabi> vincenz: I am mostly talking about the people who use fortran/C++ for these things.
14:31:26 <vincenz> musasabi: ah
14:31:45 * vincenz doesn't think c++ is great either
14:31:50 <musasabi> dcoutts_: STUArray is much worse than any imperial language usually from most POVs
14:31:50 <emertens> UArray is the packed pure functional array and STUArray is the packed in-place updating array?
14:31:52 <vincenz> unless you're very smart about operator overloading
14:32:01 <dmhouse> Isn't there a SoC project for a fast mutable types collection?
14:32:06 <dcoutts_> emertens, yes
14:32:11 <SamB> musasabi: what is an imperial language?
14:32:20 <musasabi> *imperative
14:32:23 <SamB> oh, okay.
14:32:24 <dmhouse> :)
14:32:25 <dcoutts_> SamB, a language of the dark side of the force
14:32:32 <SamB> I thought maybe you meant something by "imperial"
14:32:34 <vincenz> dcoutts_: only in the second half!
14:32:38 <SamB> ;-)
14:33:39 <emertens> why is STUArray much worse than any imperative language?
14:33:46 <emertens> What does that even mean?
14:34:20 <dcoutts_> less convenient
14:34:26 <dcoutts_> a[b] = c
14:34:39 <dcoutts_> writeArray a b c
14:34:44 <dcoutts_> or worse:
14:34:54 <dcoutts_> a[b[c]] = d[e]
14:35:01 <dcoutts_> becomes three lines
14:35:32 <SamB> also, it isn't properly polymorphic like IOUArray is
14:35:38 <SamB> because of that pesky forall
14:35:56 <dmhouse> What's the difference?
14:36:04 <dmhouse> IO has all the power of ST anyway, right?
14:36:05 <SamB> @type runSTArray
14:36:07 <lambdabot> Not in scope: `runSTArray'
14:36:07 <dcoutts_> do { x <- readArray b c; y <- readArray d e; writeArray x y}
14:36:16 <SamB> @hoogle runSTUArray
14:36:17 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
14:36:29 <dmhouse> (Unless you consider unsafePerformIO et al.)
14:36:34 <dcoutts_> dmhouse, yes, but you can use ST in pure code because of runST
14:36:35 <SamB> hmm.
14:36:41 <SamB> isn't there supposed to be a forall?
14:36:45 <dmhouse> dcoutts_: precisely.
14:36:46 <SamB> @type Data.Array.ST.runSTUArray
14:36:48 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
14:36:50 <dcoutts_> @type Data.Array.ST.runST
14:36:50 <dmhouse> SamB: hoogle doesn't do existentials.
14:36:52 <lambdabot> Not in scope: `Data.Array.ST.runST'
14:36:54 <SamB> dmhouse: ah
14:37:02 <dmhouse> @hoogle runST
14:37:02 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
14:37:03 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
14:37:03 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
14:37:07 <dcoutts_> @type Control.Monad.ST.runST
14:37:08 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
14:37:42 <SamB> anyway, you can't write functions for STUArrays without fixing the element type
14:37:57 <dcoutts_> similarly for UArrays
14:37:58 <SamB> well, I mean, you could but they would not work
14:38:12 <dcoutts_> oh, maybe not
14:38:18 <SamB> dcoutts: you can! but they may not be as efficient...
14:38:25 <dcoutts_> right
14:38:52 <dcoutts_> yes I remember bumping into the fact that you can't give a type to a polymorpic use of STUArray when combined with runST
14:39:08 <dcoutts_> because there is nowhere to put the MArray class constraint
14:39:34 <dcoutts_> I never got a satisfactory answer for that one
14:39:37 <dmhouse> > runST (return 5)
14:39:38 <lambdabot>  5
14:39:46 <dmhouse> Cool, you can do ST in lambdabot :)
14:39:52 <dcoutts_> because it's pure
14:39:56 <dmhouse> Yeah.
14:40:09 <SamB> dcoutts: even if you wrote a function that was just supposed to manipulate STUArrays in the ST monad, you couldn't use it
14:40:15 <dmhouse> > runST (do x <- newSTRef; writeSTRef x 4; readSTRef x)
14:40:16 <lambdabot>  Not in scope: `readSTRef'
14:40:28 <dmhouse> ?docs Data.STRef
14:40:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html
14:40:30 <dcoutts_> SamB, really?
14:40:40 <SamB> because runSTUArray would complain that the forall was missing
14:40:58 <SamB> (unless you fix the element type)
14:40:58 <dcoutts_> SamB, you don't need to use runSTUArray if you're already in the ST monad
14:41:01 <dmhouse> > runST (do x <- Data.STRef.newSTRef; Data.STRef.writeSTRef x 4; Data.STRef.readSTRef x)
14:41:02 <lambdabot>  Not in scope: `Data.STRef.readSTRef'
14:41:09 <emertens> @hoogle runSTArray
14:41:10 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
14:41:14 <SamB> dcoutts: well, you couldn't runST it either
14:41:29 <LordBrain> what was the url to that pastebin? lisp.pastebin.org or something like that?
14:41:31 <SamB> runST would complain about the missing forall too
14:41:32 <emertens> why would one use runSTArray instead of runST?
14:41:39 <dcoutts_> SamB, right, the problem comes with trying to use runST without fixing the type of the array
14:41:43 <xerox> @paste
14:41:43 <dmhouse> > runST $ return 5
14:41:43 <lambdabot> http://paste.lisp.org/new/haskell
14:41:43 <lambdabot>    Inferred type is less polymorphic than expected
14:41:44 <lambdabot>    Quantified type va...
14:41:55 <xerox> LordBrain: that one two lines above
14:41:57 <SamB> emertens: to efficiently compute an Array or UArray
14:42:07 <dcoutts_> dmhouse, that error confuses people greatly
14:42:13 <dmhouse> dcoutts_: yep :)
14:42:26 <dmhouse> It's because you start thinking of ($) as syntax.
14:42:26 <emertens> If you don't use runSTArray, I guess you have to explicitly type the array
14:42:32 <emertens> when you call newArray
14:42:32 <dcoutts_> dmhouse, right
14:42:33 <dmhouse> Perhaps it should be.
14:42:48 <SamB> dmhouse: ick
14:42:57 <LordBrain> yeah i see it, thanks
14:43:02 <SamB> that is the *wrong* solution, I think
14:43:04 <dmhouse> Or is there a way to keep it a function, but allow higher-rank polymorphic functions?
14:43:08 <dcoutts_> dmhouse, then how would I use map ($) ?
14:43:10 <SamB> I hope so
14:43:20 <dmhouse> s/\?/ as arguments?/
14:43:23 <dmhouse> dcoutts_: point.
14:43:26 <SamB> if not, we might as well not try to use them for that
14:43:41 <SamB> I mean, they are still good for build...
14:43:59 <dmhouse> dcoutts_: actually, no. Just map id works too
14:44:14 <xerox> > map 2 . map ($) . map (*) $ [0..]
14:44:15 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
14:44:30 <dmhouse> > map (`id` 4) [(*2), (+1)]
14:44:32 <lambdabot>  [8,5]
14:44:41 <dmhouse> > (*2) `id` 4
14:44:42 <lambdabot>  8
14:44:47 <xerox> I was trying to decompose that one.
14:45:11 <dmhouse> (*2) `id` 4  --->  id (*2) 4  --->  (*2) 4  --->  8
14:45:44 <xerox> Thinking about how to use map ($), that is.
14:46:07 <emertens> @type runSTArray
14:46:08 <lambdabot> Not in scope: `runSTArray'
14:46:16 <xerox> > map (*2) . map ($) $ [0..]
14:46:17 <lambdabot>  add an instance declaration for (Num (a -> b))
14:46:21 <xerox> Neither...
14:46:24 <emertens> @type Data.Array.ST.runSTArray
14:46:25 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e)) -> Array i e
14:46:48 <dmhouse> xerox: zipWith ($) is more common, admitedly. Or map ($ x).
14:46:52 <SamB> @type Data.Array.ST.runSTArray (newArray (0,0) [])
14:46:54 <lambdabot> Not in scope: `newArray'
14:47:04 <SamB> @type Data.Array.ST.runSTArray (Data.Array.MArray.newArray (0,0) [])
14:47:05 <lambdabot> forall i a. (Num i, Ix i) => Array i [a]
14:47:15 <SamB> @type Data.Array.ST.runSTUArray (Data.Array.MArray.newArray (0,0) [])
14:47:17 <lambdabot>   No instance for (Data.Array.Base.MArray (Data.Array.Base.STUArray s)
14:47:17 <lambdabot>                       [a]
14:47:29 <emertens> the reason that runSTArray doesn't work for me is that I don't want the STArray as a result, I use an STArray to compute an [a]
14:47:40 <xerox> Ah, gotcha.
14:47:45 <xerox> The first argument is the function.
14:47:46 <emertens> so I use runST because my return type is ST s [a]
14:48:21 <xerox> ?type map ($) (repeat (*2))
14:48:22 <lambdabot> forall a. (Num a) => [a -> a]
14:48:26 <SamB> emertens: you could just runSTArray and then extract the elements... it doesn't actually have to copy the array.
14:48:41 <xerox> So map ($) isn't exactly useful, is it? :-)
14:48:52 <emertens> SamB: I use an STArray to implement a disjoint-set with union/find operations
14:49:01 <emertens> but I don't actually need the resulting array
14:49:12 <dmhouse> ?type map ($)
14:49:12 <SamB> emertens: oh
14:49:13 <lambdabot> forall a b. [a -> b] -> [a -> b]
14:49:23 <dmhouse> It actually doesn't do anything. :)
14:49:30 <xerox> That's what i mean :-)
14:49:49 <dmhouse> > map ($ 4) $ map ($) [(*2), (+1)] -- :)
14:49:50 <lambdabot>  [8,5]
14:50:33 <dmhouse> dcoutts_: is there a public report anywhere on how the SoC projects are progressing? There was a mid-term review a while back, wasn't there?
14:50:44 <emertens> > [(*2), (+1)] `ap` [4]
14:50:45 <lambdabot>  [8,5]
14:50:46 <xerox> > map ($2) $ fix (map ($)) [(*2),(+1)]
14:50:47 <lambdabot>  Couldn't match `[a]' against `t -> [a1 -> b]'
14:50:51 <dcoutts_> dmhouse, there's no centeral public report
14:51:32 * dmhouse goes to check out mnislaih's stuff
14:51:44 <xerox> ?type map ($2) $ fix (map ($))
14:51:45 <lambdabot> forall b. [b]
14:51:57 <xerox> This is fluffy air.
14:53:53 <SamB> hmm, I wish :set args accomodated arguments with spaces in them.
14:54:09 <xerox> Oh, right, this is the actually-looping-undefined.
14:54:31 <SamB> > map ($2) $ fix (map ($))
14:54:32 <lambdabot>  Add a type signature
14:54:41 <SamB> > map ($2) $ fix (map ($)) :: [Int]
14:54:43 <lambdabot>  Exception: <<loop>>
14:54:59 <SamB> not looping *too* badly...
14:55:00 <xerox> > fix id :: ()
14:55:01 <lambdabot>  Exception: <<loop>>
14:55:09 <xerox> That, in the end.
14:55:24 <xerox> fix id :: () -- the looping bottom.
14:55:40 <SamB> my solver is too slow...
14:55:47 <SamB> I hope.
14:55:55 <dmhouse> Well, id's strict, so fix id will diverge.
14:55:59 <SamB> maybe I should try it on an earlier puzzle...
14:56:24 <emertens> > fix (\~x -> x) :: ()
14:56:25 <lambdabot>  Parse error
14:56:32 <emertens> > fix (\~(x) -> x) :: ()
14:56:32 <lambdabot>  Parse error
14:56:36 <emertens> > fix (\x -> x) :: ()
14:56:37 <lambdabot>  Exception: <<loop>>
14:57:41 <SamB> > fix (+1)
14:57:42 <lambdabot>  Exception: <<loop>>
14:58:05 <dmhouse> > (+1) undefined -- it's strict, so it'll diverge.
14:58:06 <lambdabot>  Undefined
14:58:08 <SamB> hmm hmm hmm
14:58:10 <wilx> Hm, the charsetp problem in haskell-mode seems to be well known. :/
14:58:17 <SamB> it doesn't let you set goggles in the first puzzle?
14:58:39 <SamB> oh, wrong command
15:04:23 <dmhouse> mnislaih: am I meant to get conflicts after pulling from your repo?
15:04:53 <mnislaih> oh, that's because of latest SMarlow patches with the new package stuff
15:05:25 <mnislaih> I have a tentative patch for fixing it, but it is still untested, but either way, you're probably better without said new patches
15:05:42 <monochrom> @hoogle fix
15:05:42 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
15:05:42 <lambdabot> Control.Monad.Fix :: module
15:05:42 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
15:05:46 <mnislaih> unless you have already managed to compile them
15:05:58 <dmhouse> No, net yet.
15:06:05 <dmhouse> Which patches should I unpull then?
15:06:08 <mnislaih> they are a bit annoying to compile
15:06:34 <mnislaih> all the patches by smarlow starting with the new package stuff. Let me check a sec
15:06:45 <monochrom> > fix (\ ~x -> x) :: ()
15:06:46 <lambdabot>  Exception: <<loop>>
15:07:01 <monochrom> ~ will not help you :)
15:07:23 <dmhouse> 'x' is already a lazy pattern match, no?
15:07:51 <monochrom> Yes.
15:08:18 <dmhouse> Hrm.
15:08:32 <dmhouse> I've heard f _|_ = _|_ <=> f strict, is this true?
15:09:07 <dmhouse> Wikipedia says so.
15:09:16 <dmhouse> And yet, id doesn't (or needn't) evaluate its argument
15:09:27 <mnislaih> argh
15:09:35 <mnislaih> dmhouse: unpull a week of patches and you
15:09:41 <mnislaih> and it'll be fine
15:10:00 <ski> nclife : hiya
15:10:07 <musasabi> "f is strict"  =>  f _|_ = _|_
15:10:59 <dmhouse> Right, but not <=?
15:11:21 <ski> 'id' forces it's arg to whnf
15:11:52 <ski> (since 'id' isn't called unless the result is wanted)
15:12:03 <dmhouse> whnf?
15:12:18 <fasta> weak head normal form?
15:12:47 <ski> (hm, maybe better to say s/to whnf/as much as of the answer is demanded)
15:12:58 <musasabi> dmhouse: "<=" depends on what one means. But I would say no.
15:13:13 <monochrom> > id undefined :: ()
15:13:13 <lambdabot>  Undefined
15:13:16 <ski> (so, at least whnf, if 'id' is actually (operationally) forced)
15:13:54 <monochrom> > const () (undefined :: ())
15:13:55 <lambdabot>  ()
15:15:37 <dmhouse> > fst $ id (3, undefined)
15:15:38 <lambdabot>  3
15:16:02 <monochrom> Heh, mathematically, id _|_ = _|_  strict
15:16:15 <dmhouse> monochrom: that's what's puzzling me.
15:16:28 <ski> '(3,_|_)' is not the same as '_|_'
15:16:33 <SamB> monochrom: that is probably because id doesn't do anything
15:16:40 <dmhouse> ski, no, I know, that was a pointless test.
15:16:58 <dmhouse> ski, can you give an example where id forces some evaluation?
15:17:06 <SamB> id never forces any
15:17:13 <ski> > id (1 + 2)
15:17:14 <lambdabot>  3
15:17:15 <monochrom> > const () (id undefined :: ())
15:17:16 <lambdabot>  ()
15:17:17 <SamB> it doesn't do *anything*
15:17:29 <monochrom> id itself doesn't force anything.  but > does.
15:17:58 <ski> 'id' just passes through the demand placed on the returned value, to the argument
15:18:30 <dmhouse> Okay.
15:18:34 <ski> and, operationally, 'id' is not activated unless it's returned value is at least to some extent demanded
15:18:50 <dmhouse> So intuitively I'd call id lazy, because it doesn't force evaluation.
15:19:04 <SamB> no, but it is strict
15:19:15 <SamB> well, sort of
15:19:20 <ski> > let foo _ = () in foo (1 + 2)
15:19:21 <lambdabot>  ()
15:19:30 <SamB> it really doesn't do anything...
15:19:31 <ski> that's an example of a lazy function
15:19:47 <SamB> > let foo _ = () in foo undefined
15:19:48 <ski> 'id' is stricter than 'foo' there
15:19:48 <lambdabot>  ()
15:20:02 <dmhouse> Yeah.
15:20:25 <SamB> > let foo x = x in foo undefined
15:20:26 <lambdabot>  Add a type signature
15:20:30 <SamB> > let foo x = x in foo undefined :: String
15:20:31 <lambdabot>  Undefined
15:20:39 <monochrom> I don't think "f :: forall a. a->a" and "f is non-strict" are simultaneously implementable.
15:21:09 <monochrom> Correction. I don't think "f :: forall a. a->a" and "f is non-strict" and "for all x, f x terminates" are simultaneously implementable.
15:21:56 * dcoutts_ agrees
15:22:37 <dcoutts_> because f is either id, const undefined or undefined
15:22:52 <dcoutts_> all of which are strict
15:23:00 <dcoutts_> or non-terminating
15:23:06 <dmhouse> What I'm trying to link is the two definitions of a strict function I've seen: 1) f with f _|_ = _|_, and 2) doesn't force evaluation of its arguments.
15:23:18 <monochrom> A clearer way to say it and also a weakening of the requirement.  I don't think "for all non-bottom x, f x = x" and "f is non-strict" and "for all x, f x terminates" is implementable.
15:23:19 <dmhouse> Sorry s/doesn't/does/.
15:23:51 <ski> (for all x, f x terminates) => f is non-strict    no ?
15:23:59 <dcoutts_> monochrom, actaully, is the terminating a requirement here?
15:24:15 <dcoutts_> monochrom, why was your original statement not right?
15:24:37 <dcoutts_> "f :: forall a. a->a" and "f is non-strict" not being simultaneously satisfiable
15:24:38 <monochrom> I have been unclear, even after clarification. :)
15:25:56 <monochrom> If you want "f x = x for non-bottom x" and "f _|_ /= _|_", you ask f to detect _|_ perfectly.  That's the halting problem.
15:26:31 <monochrom> There is a solution, but it does not promise termination.  (So I have to state termination explicitly.)
15:27:16 <foxy_> Is there a reason that GHC 6.5 snapshots don't have a ghc executable binary?
15:27:51 <SamB> I dont understand this format...
15:29:12 <SamB> I'm not sure the designers do, either ;-)
15:29:17 <paj_> Anyone else going to AngloHaskell?  I tried to find the #anglohaskell forum, but couldn't
15:29:39 <dmhouse> paj_: /join #anglohaskell? :)
15:29:53 <monochrom> Does id force evaluation?  Does a strict function force evaluation?  That is an implementation question.  I'll elaborate.
15:30:44 <paj_> Ahh thanks.  That worked.  I dont use IRC much.
15:31:24 <dmhouse> paj_: you should! We have a great community here. :)
15:31:38 <monochrom> Let C be a context.  Let f be a strict function.  You make the computer evaluate C[f _|_] and you get _|_.  Who forced it?
15:32:04 <ski> (http://www.haskell.org/pipermail/haskell/2004-June/014134.html is an interesting paper re bottom,etc and topology)
15:32:05 <lambdabot> Title: [Haskell] topology in Haskell
15:32:09 <SamB> I bet the ML format doesn't have wierd stuff like this...
15:32:49 <monochrom> In one runtime, it may be C who forced it.  In another runtime, it may be f who forced it.  In yet another runtime, it may be the runtime who forced it.  Code optimization implies that you must be flexible about this.
15:32:53 <dmhouse> ski: thanks.
15:33:43 <paj_> OK.  #anglohaskell seems quiet.  Anyone else here going?
15:33:56 <paj_> (I know its 11pm uk time, so not surprising)
15:34:15 <dmhouse> Well, 11:35, even.
15:34:30 <dmhouse> And it's raining! First time in ages.
15:34:44 <paj_> We've been having regular thunderstorms down here
15:34:49 <fasta> >"a" == undefined
15:34:53 <fasta> > "a" == undefined
15:34:55 <lambdabot>  Undefined
15:34:56 <monochrom> How to reconcile the denotational defintion "f _|_ = _|_" and the operational definition involving evaluation and forcing?  Here is one way to define it operationally while being flexible.  For some context C, C[f x] forces x.
15:35:17 <paj_> > product [1..10]
15:35:18 <lambdabot>  3628800
15:35:25 <paj_> (Just trying out Lambdabot)
15:35:41 * SamB really wishes there was a SmashedXML setting on these goggles
15:39:08 <turok> rel
15:39:10 <turok> oops
15:39:36 <monochrom> Oh!  It is very hard to give an operational definition.  Mine breaks.  I have to re-think.  It breaks with things like (\ ~(x:xs) -> (x,xs))
15:42:20 <paj_> Are there any other Haskell people in Hants, UK?
15:42:41 <paj_> I live in Fareham (or soon will, anyway)
15:43:10 <monochrom> What is a SmashedXML setting?
15:43:48 <SamB> monochrom: it would be just like the XML setting, only with no newlines or indentation added
15:44:01 <SamB> for convenient copy/paste
15:44:25 <monochrom> Oh! That kind of smash.
15:45:16 <SamB> I can't help but wonder if there isn't a smarter way to solve this...
15:46:31 <SamB> right now I'm trying a depthfirst search, with combine tried first, followed by incinerate and then take...
15:51:06 <SamB> hmm, does anyone have a ./adventure solver I can steal ideas from?
16:04:44 * SamB can't help but think that a method that figured out what objects were indispensible and didn't chuck them would work better...
16:16:30 <emertens> @djinn a -> a
16:16:31 <lambdabot> f a = a
16:16:51 <emertens> is there an f such that f :: a -> a  is not "id"?
16:17:14 <emertens> add commas to my sentence as appropriate!
16:17:46 <emertens> @type (\_ -> undefined)
16:17:48 <lambdabot> forall a t. t -> a
16:18:09 <emertens> hmm, b -> a is not what I'm looking for :)
16:18:16 <ski> @type (let f :: a -> a; f _ = undefined in f)
16:18:18 <lambdabot> forall a. a -> a
16:18:40 <ski> @type const undefined `asTypeOf` id
16:18:42 <lambdabot> forall b. b -> b
16:19:07 <emertens> @type asTypeOf
16:19:08 <lambdabot> forall a. a -> a -> a
16:19:24 <emertens> > asTypeOf 1 2
16:19:25 <lambdabot>  1
16:19:33 <emertens> > asTypeOf 1 2.0
16:19:34 <lambdabot>  1.0
16:19:39 <emertens> > asTypeOf 1 'a'
16:19:41 <lambdabot>  add an instance declaration for (Num Char)
16:19:47 <bringert> JaffaCake: I didn't get much response to my proposal for replacing Network.CGI (http://www.haskell.org/pipermail/libraries/2006-July/005580.html). Do you think that I should just go ahead and do it?
16:19:48 <emertens> cool...
16:20:23 <ski> @type undefined `asTypeOf` id
16:20:25 <lambdabot> forall a. a -> a
16:20:58 <ski> (though 'undefined' is the same as 'const undefined' (if we ignore 'seq'))
16:21:23 <emertens> who is Oleg?
16:22:34 <ski> http://okmij.org/ftp/
16:22:36 <lambdabot> Title: This FTP site
16:22:45 <ski> emertens : ^^
16:23:49 <ski> @where oleg
16:23:50 <lambdabot> I know nothing about oleg.
16:24:18 <ski> @where+ oleg http://okmij.org/ftp/
16:24:19 <lambdabot> Done.
16:24:42 <SamB> I repeat: does anyone have a ./adventure solver for me to steal ideas from
16:24:46 <SamB> ?
16:29:54 <mahogny> ....../adventure?
16:30:05 <mahogny> solver? o_O
16:30:17 <yip> reverse emacs shrink
16:30:32 <SamB> for the ICFP thingy
16:30:38 <madpickle> http://www.bash.org/?43316
16:30:40 <lambdabot> Title: QDB: Quote #43316
16:30:44 <madpickle> recognize that person?
16:30:44 <madpickle> :P
16:36:35 <Buzzons> http://www.bash.org/?618715
16:36:36 <lambdabot> Title: QDB: Quote #618715
16:36:40 <Buzzons> best quote.. ever
16:46:41 <SamB> my solver is TOO SLOW
16:48:00 <mnislaih> funny one: http://www.bash.org/?627168
16:48:02 <lambdabot> Title: QDB: Quote #627168
17:00:09 <vincenz> SamB: solver of what
17:00:15 <vincenz> SamB: oh that
17:00:19 <vincenz> SamB: don't use backtracking
17:00:26 <vincenz> SamB: use directed goal-oriented approach
17:00:30 <SamB> ah
17:00:36 <vincenz> well backtrack on that
17:00:40 <vincenz> but don't just randomly try stuff
17:01:02 <SamB> yeah, I'm having absolutely no success with this idiotic approach
17:01:13 <vincenz> basically you start with two goals
17:01:17 <vincenz> "build uploader, build downloader"
17:01:25 <vincenz> try one goal and alternatively trry the other
17:01:30 <vincenz> trying means: remove goal from stack
17:01:45 <vincenz> and add the goals "find subpart 1, combine with subpart1, find subpart 2, combine with subpart 2]
17:01:49 <vincenz> then pick a random goal
17:02:11 * int-e had great success with backtracking :)
17:02:38 <vincenz> int-e: but with random moves??
17:02:45 <SamB> but:
17:02:49 <SamB> Each piece may be assembled from the items at a single location.
17:02:55 <int-e> (but I did not try it on te large scale. each room can be solved separately)
17:03:00 <vincenz> yeah
17:03:03 <vincenz> I didn't know that bit
17:03:07 <vincenz> so I tried to solve over all the pieces
17:03:10 * vincenz mutters
17:03:16 <vincenz> we eventually ended up using prolog
17:03:20 <SamB> oh? is my codex newer than yours?
17:03:29 <SamB> oh, prolog, yeah, I was wondering about that.
17:03:36 <vincenz> as my backtracking goal-oriented solver was buggy
17:03:37 <SamB> I'm not very good at it though
17:04:01 <SamB> which goggles did you use with it?
17:04:03 <vincenz> ml
17:04:08 <vincenz> and then some combinators for haskell :D
17:04:11 <int-e> vincenz: ok, over everything it's a lot harder to normalize the solution as I did to reduce the search space.
17:04:15 <vincenz> and then just made it a .hs
17:04:16 <vincenz>  file
17:04:22 <vincenz> only thing I had to do:
17:04:24 <vincenz> s/::/:/g
17:04:38 <SamB> yeah, the sexp output is buggy
17:04:51 <SamB> and the XML is too full of whitespace...
17:05:31 * int-e parsed english output because he had forgotten about the goggles when he wrote the solver.
17:05:35 * int-e chuckles
17:05:42 <SamB> ouch!
17:05:49 <SamB> doesn't that mean you had to "X" everything?
17:06:05 <int-e> that too
17:06:25 <SamB> thats why I checked to see what happens if you use the goggles for that...
17:06:32 <SamB> for look, I mean
17:06:51 <int-e> what can I say, I ended up with 164 lines total and probably 2/3 of that is a parser.
17:07:10 <int-e> I did try the goggles, but couldn't find a use for them at first ;)
17:07:42 <SamB> I have the advantage of having heard people talk about things a little
17:07:48 <int-e> I probably wasted 2 or 3 hours of time that way. Oh well.
17:07:48 <SamB> even if very mysteriously
17:08:04 <SamB> notice how the contest was about a week ago?
17:08:10 <SamB> and I am still working on the problems?
17:09:22 <SamB> I bet a naive approach without incineration could work well...
17:09:41 * int-e mutters that improving reverse from area 869 to 820 didn't improve the score.
17:10:08 <SamB> what are you getting for reverse at that area?
17:10:13 <int-e> 44
17:11:40 <SamB> hmm, I get 41 at 1012
17:11:49 <SamB> and I think I got 40 at almost twice that...
17:12:00 <SamB> but maybe not
17:12:31 <SamB> can I see yours, by the way?
17:13:00 * SamB wondes why the category is named "CIRCS"
17:13:15 <SamB> oh, circuits?
17:13:20 <lisppaste2> int-e pasted "rev.2d" at http://paste.lisp.org/display/23357
17:13:53 <int-e> note the end-of-file-marker at the end of the last line. I didn't discover that trick during the contest, unfortunately.
17:14:22 <SamB> oh that looks just like what I would do if I would totally redo the layout on mine
17:14:56 <lisppaste2> SamB annotated #23357 with "his rev.2d" at http://paste.lisp.org/display/23357#1
17:20:31 <SamB> see, mine is the same except the args are switched
17:20:41 <SamB> and the layout a good deal worse
17:21:16 <int-e> the algorithm *is* sorta obvious though :)
17:21:42 <SamB> yeah
17:22:46 <SamB> that EOF trick gets me another point
17:26:41 <stepcut> for anyone who is interested, this is a interesting paper on searching, http://www.cse.ogi.edu/PacSoft/publications/2001/modular_lazy_search_jfp.pdf
17:27:38 <stepcut> backtracking, backmarking, forward jumping, dynamic variable ordering, it's all there ;)
17:27:54 <xerox> Cool, thanks!
17:28:36 <SamB> is it about games?
17:28:55 <stepcut> I actually need to read that one, I read this version, but I think it is an older copy because it does not talk about DVO -. http://www.cse.ogi.edu/PacSoft/publications/phaseiiiq10papers/modular_lazy_search.pdf
17:29:43 <stepcut> SamB: not directly, but it is about efficiently traversing search trees -- I think with the DVO stuff it could be very quickly applied to things like sudoku
17:30:46 <SamB> the game in question is *nothing* like sudoku
17:31:58 <stepcut> SamB: I haven't looked at the game -- I just saw that some people said they had success with 'backtracking'
17:34:18 <SamB> you basically have a stack of objects, and you can take an object off the stack, destroy an object, or combine an object with another, if one of the objects is missing one of the other
17:34:47 <SamB> however, some objects are missing objects which must in turn be missing other objects
17:36:09 <stepcut> SamB: is this a one-player game?
17:36:32 <SamB> it is a text adventure
17:37:54 <stepcut> SamB: hrm, I would have to see the spec I think
17:38:16 <stepcut> SamB: is it published on the ICFP now ?
17:38:31 <SamB> stepcut: spec?
17:38:43 <SamB> just play with it, maybe with XML goggles on
17:39:28 <stepcut> SamB: how do I play?
17:39:31 * stepcut knows nothing
17:42:19 <SamB> type "help
17:43:30 <stepcut> SamB: haha, No, I mean, I don't even know where to get the game :) Maybe I should just get back to real work :p
17:51:44 <SamB> stepcut: oh, the game?
17:52:19 <SamB> well, grab a UM off of dons's page and the codex off of icfp.org
17:52:44 <SamB> you'll also need a decryption key
17:53:04 <SamB> (which is not really used for decryption...)
17:54:04 <SamB> you could use mine
17:54:06 <SamB> (\b.bb)(\v.vv)06AAhsCWeqGUmdIWEQ
17:54:27 <int-e> the first part is used for decryption actually
17:54:35 <SamB> oh?
17:54:53 <SamB> okay, so the omega is used for decryption then...
17:55:33 <int-e> (\b.bb)(\v.vv)06 is a key (RC4, someone said) ... the rest is for identifying teams (and has a checksum)
17:55:43 <SamB> oh, the 06 too?
17:55:46 <SamB> for 2006?
17:56:06 <int-e> ironically that key would be tried by the password cracker in the codex :)
17:56:51 <SamB> yeah, I noticed
17:57:51 <SamB> I really think they should put a key or keygen up for general use
17:58:26 <SamB> oh, I could just send you my unpacked codex...
17:58:32 <stepcut> heh
17:58:34 <int-e> same thing actually
17:58:39 <stepcut> nah, i think I should do some real work
17:58:39 <int-e> it's personalized :)
17:58:50 <foxy_> @seen dcoutts
17:58:50 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 11 hours, 40 minutes and 12 seconds ago.
17:58:54 <SamB> int-e: I realize that it is personalized
17:58:59 <dcoutts> @yarr!
17:58:59 <lambdabot> Aye Aye Cap'n
17:59:08 <int-e> but creating a keygen isn't hard, hmm.
17:59:30 <SamB> I figured out that the score cookies (aka publications) were generated based on that pretty quickly ;-)
17:59:39 <dcoutts> foxy_?
17:59:51 <foxy_> dcoutts, I'm having trouble giving focus to a child window (gtk2hs), are there functions which don't actually work?  (Coz I noticed that 'setJustify' doesn't work and is commented as such)
18:00:49 <SamB> so, how did you get this into prolog?
18:02:17 <dcoutts> foxy_, you want to give focus to a widget programatically?
18:02:26 <foxy_> yes
18:04:47 <foxy_> I'm getting Gtk-CRITICAL messages when I try to add a scrolled window to a notebook, the window doesn't come to the top...
18:05:13 <dcoutts> what's the error message?
18:05:20 <dcoutts> so you're using widgetGrabFocus ?
18:05:33 <dcoutts> and why do you need to do it at all btw?
18:07:31 <foxy_> @paste
18:07:32 <lambdabot> http://paste.lisp.org/new/haskell
18:08:54 <SamB> how do you parse in Prolog?
18:09:04 <lisppaste2> foxy_ pasted "open Gtk Window" at http://paste.lisp.org/display/23363
18:09:56 <lisppaste2> foxy_ annotated #23363 with "error message" at http://paste.lisp.org/display/23363#1
18:10:25 <foxy_> dcoutts, I don't know whether I need to, I'm fishing for a solution to the errors %)
18:14:21 <dcoutts> foxy_, so action exaclty gives us that error?
18:14:42 <dcoutts> does it happen immediatley on startup
18:14:48 <dcoutts> or after some other action
18:15:11 <dcoutts> is the whole source available to reproduce this?
18:17:17 <foxy_> dcoutts, The first call to addGtkBuffer works, but the second fails when adding a new buffer
18:17:47 <foxy_> dcoutts, I can send you the source (it's modified yi+gtk)
18:18:04 <dcoutts> foxy_, ok, because there's no addGtkBuffer in the source you pasted :-)
18:18:50 <foxy_> dcoutts, um, I mean openGtkWindow
18:19:53 <dcoutts> foxy_, ok, but that's also not called in the code
18:20:00 <dcoutts> though it's defined
18:20:19 <foxy_> it's called somewhere else, I was trying to minimise what I pasted :)
18:20:28 <dcoutts> yeah, the whole code would help
18:20:44 <foxy_> how do I make a tarball from darcs?
18:24:17 <MarcWeber> Is someone familiar with HaXml ? Since 1.06 there is no longer Xml2Haskell.hs but the documentation is still there. I'm currently trying to create a simple XML document by using the haskell representation.
18:24:39 <MarcWeber> foxy_: darca dist?
18:25:38 <SamB> where should I ask prolog questions?
18:26:06 <foxy_> dcoutts, I have a tarball I can send you?
18:26:13 <dcoutts> foxy_, great
18:46:07 <dons> morning
18:49:52 <int-e> SamB: http://paste.lisp.org/display/23364 ... note the funny formula.
18:54:31 <SamB> > maxBound Word16
18:54:32 <lambdabot>  Not in scope: data constructor `Word16'
18:54:35 <SamB> > maxBound :: Word16
18:54:36 <lambdabot>  65535
18:55:43 <SamB> okay, I see an 31337 in there. is that l33tsp34k?
18:56:13 <int-e> I don't know why they chose that value. The formula is directly from the codex.
18:56:25 <int-e> :-P
18:57:20 <SamB> so do you know anything about parsing in Prolog?
18:57:22 <dons> dcoutts: looking at your bytestring drawing. do we actually get the Addr# of the MBA unpacked into the ByteString constructor?
18:57:33 <dcoutts> dons, yes
18:57:50 <dons> since I know its cached in the ForeignPtr, but that gets unpacked. you've checked?
18:58:00 <dcoutts> I think we do and we certainly should do
18:58:31 <dons> well, your drawing shows a ForeignPtr with an unpacked ForeignPtrContents?
18:58:43 <dcoutts> no
18:59:00 <dcoutts> it shows a ByteString with a ForeignPtr unpacked into it
18:59:03 <dons> so you're showing the results after -O unpacking?
18:59:17 <dons> ah. yes. I see.
18:59:22 <dons> the first indirection is to the FPC
18:59:22 <dcoutts> the ForeignPtrContents is not unpacked
18:59:26 <dcoutts> right
18:59:33 <dcoutts> -O doesn't affect it
18:59:35 <int-e> argh. why did I write random() there?
18:59:59 <dcoutts> (I think)
19:00:04 <dons> dcoutts: but literaly we don't have an Addr# in our ByteStrings. You're using a representation based on -funbox-strict-fields or {-# UNPACK #-} no?
19:00:12 <dcoutts> yes
19:00:20 <dcoutts> I'm looking at the real machine level representation
19:00:33 <dons> yes. and i'm hoping its accurate :)
19:00:43 <dcoutts> dons, me too :-)
19:00:51 <dcoutts> I think it is
19:01:05 <dons> i think it is, but it involves reasoning about what -funbox-strict-fields does.
19:01:15 <dcoutts> which is stated in the ghc manual
19:01:15 <dons> i wonder if we could confirm somehow. checking the Core
19:01:29 <dcoutts> and you can tell somewhat from looking at the core
19:01:33 <dcoutts> eg, in a loop
19:01:56 <dons> yeah
19:01:57 <SamB_XP> can't you tell from looking at interface files, even?
19:02:01 <dons> you see an Addr# passed in
19:02:18 <dcoutts> if the ByteString is a parameter to the loop then when it's strict we see a Addr# as a parameter to the function
19:02:23 <dcoutts> so that's a two level unpacking
19:02:48 <dcoutts> the Addr# into the ByteString and then the ByteString into parameters of the recursive funcion
19:03:14 <dons> ok. yes, with -funbox-strict-fields, we should see the ForeignPtr contents unpacked next to the offset and length
19:03:24 <dcoutts> dons, btw, I've got .eps versions of the diagrams which work fine given a suitable scaling
19:03:55 <dons> so there's a pointer down to an FPC, which then pionts to a MBA#.
19:04:02 <dons> now, how'd you work out the MBA# structure?
19:04:06 <dons> .eps is good :)
19:04:23 <dcoutts> dons, right, the only liberty I've taken is reversing the FPC and Addr# fields in the ByteString constructor
19:04:36 <dons> sure.
19:04:43 <dcoutts> as for the MBA#, I looked at the StgClosures.h
19:05:01 <dcoutts> it's one word for the header and one for the length in words of the array
19:05:11 <dcoutts> hence the extra empty box in the diagram
19:05:19 <dons> StgMiscClosures.h?
19:06:33 <dcoutts> include/Closures.h
19:06:35 <dcoutts> StgArrWords
19:07:05 <xerox> You never stop hacking!
19:07:29 <dons> ah ha. good
19:07:41 * dons notes that a ByteArray# is a char *
19:08:13 <dcoutts> dons, well with some admin prefix stuff
19:08:17 <dcoutts> no?
19:08:30 <dons> now, I wonder what the effect of an {-# UNPACK #-} on the PlainPtr       (MutableByteArray# RealWorld) would be
19:08:36 <dons> dcoutts: oh, I missed that, yes
19:08:52 <dcoutts> nothing I think
19:08:54 <heatsink> Maybe a long shot, but I have a porting question.  What is the mangler supposed to do with register save/restore functions in the prologue/epilogue?
19:09:07 <heatsink> s/functions/instructions/
19:09:14 <dcoutts> because a MutableByteArray# is not a boxed object and yet is a heap object
19:09:37 <dons> right, so its special
19:10:04 <dcoutts> it has no compiler visible strucure
19:10:09 <dcoutts> so it can't be unpacked
19:10:26 <dcoutts> besides it's a varible length object
19:10:34 <dcoutts> so it's pretty difficult to unpack
19:10:50 <dons> could we avoid the 2nd indirection via the FPC with an unpack here, data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
19:10:57 <vincenz_> bad net
19:11:00 <vincenz_> dcoutts: do you -ever- sleep
19:11:10 <dcoutts> dons, there's no second indirection in the fast path
19:11:18 <dcoutts> the second indirection is only for the GC
19:11:23 <dcoutts> vincenz_, sometimes :-)
19:11:25 <dons> how often do we take the slow path? ever?
19:11:30 <dcoutts> I just keep variable hours
19:11:36 <dcoutts> dons, I don't think we do
19:11:48 <dons> dcoutts: ok. i think maybe we should make that clearer in the diagram
19:11:49 <dcoutts> we never examin the ForeignPtrContents
19:12:02 <dons> have solid lines for the fast path, and dotted lines for the theoretical path?
19:12:04 <dcoutts> dons, I was thinking we would make it clear in the text
19:12:37 <dcoutts> I was using solid for ones the GC follows
19:12:53 <dcoutts> well it's not the GC that's the point
19:12:54 <dons> ok
19:13:03 <dcoutts> but it's the Addr# that's odd and special
19:13:30 <dcoutts> I was using solid for normal pointers between normal objects
19:13:41 <vincenz_> dcoutts: :D
19:13:55 <dcoutts> eg note that the Addr# doesn't point to a heap object
19:14:06 <dcoutts> it points to the interior of a heap object
19:14:12 <dons> ok. i think with text that is fine.
19:14:14 <dcoutts> or out of the Haskell heap entriely
19:14:28 <dons> its quite interesting that we can do that in fact. break abstraction ..
19:14:29 <dcoutts> for a foreign ForeignPtr :-)
19:14:41 <dcoutts> break abstraction?
19:14:48 <dons> ForeignPtr should probably be ManagedPtr or something
19:14:55 <dons> oh, have ptrs to the internals of structures
19:15:00 <dons> not very haskellish ;)
19:15:02 <dcoutts> ah yes
19:15:17 <dons> and then you can always call addrToInt# and go nuts
19:15:22 <dcoutts> but jolly cunning
19:15:23 <SamB_XP> thats why all those names are so sharp
19:15:24 <dcoutts> and fast
19:15:28 <dons> it works well
19:15:33 <dons> SamB_XP: heh
19:15:37 <SamB_XP> to remind you thathey are dangerous and pointy things!
19:16:01 <dcoutts> dons, so we should double check with JaffaCake that our size & unpacking calculations are right
19:16:24 <dons> ghc should have a flag that prints out just the representation of data structures after core2core passes
19:16:41 <dcoutts> dons, but I figure, on a 32bit machine that you need 20 bytes for each character when using the [Char] representation
19:16:55 <SamB_XP> hmm.
19:17:01 <dons> that sounds about right. there are figures in the literature
19:17:01 <dcoutts> so you only fit 3 characters into a 64byte cache line!
19:17:01 * SamB_XP thinks
19:17:14 <SamB_XP> lets see...
19:17:23 <SamB_XP> 3 words per cons cell...
19:17:26 <dcoutts> assuming perfect end to end allocation of [Char]
19:17:35 <SamB_XP> two words for a Char...
19:17:38 <dcoutts> right
19:17:49 <SamB_XP> 5 times 4 is 20...
19:17:51 <SamB_XP> yep
19:17:53 <dcoutts> so for a 64bit machine it's 36 bytes!
19:18:06 <dcoutts> 4 * 8 + 4
19:18:08 <int-e> dcoutts: do they ever end up in consecutive memory locations?
19:18:27 <dcoutts> int-e, if they're allocated sequentially in time then they should do, yes
19:18:36 <SamB_XP> dcoutts: are you sure that the Char# only takes 4 bytes on 64-bit?
19:18:41 <dons> some particular Char's are unpacked sequentially, as are [Int] for small ints
19:18:50 <dons> and string constants are unpacked too, of course
19:19:03 <dcoutts> SamB_XP, I assume so, but i may be 8bytes too
19:19:27 <dcoutts> where as we get 64bytes per cache line
19:19:43 <dcoutts> or 32 for UTF16, or 16 for UTF32
19:20:02 <SamB_XP> > 64 / 36 :: Fraction
19:20:02 <dcoutts> (which is the main reason for prefering UTF16)
19:20:03 <lambdabot>  Not in scope: type constructor or class `Fraction'
19:20:09 <SamB_XP> > 64 / 36 :: Ratio
19:20:11 <lambdabot>    `Ratio' is not applied to enough type arguments
19:20:11 <lambdabot>   Expected kind `?', b...
19:20:14 <SamB_XP> > 64 / 36 :: Rational
19:20:16 <lambdabot>  16%9
19:21:34 <dons> I thought we used to have data decls in Core, but have these gone somewhere?
19:21:38 <dons> maybe I need ext-core
19:21:56 <dcoutts> dons, so I calculate that it's 20*c bytes for [Char] and c+36 bytes for ByteString
19:22:14 <dons> ok good.
19:23:11 <SamB_XP> > [(20*c, c+36) | c <- [0..3]]
19:23:13 <lambdabot>  [(0,36),(20,37),(40,38),(60,39)]
19:23:21 <dcoutts> dons, I've started writing an intro on the representation
19:23:39 <SamB_XP> so that pays off for 2-char strings already
19:24:11 <SamB_XP> not bad, not bad at all ;-)
19:24:14 <dons> dcoutts: ok. i'll get my ghc unborked, and run the benchmarks.
19:25:18 <dcoutts> SamB_XP, though the allocation time for a MutableByteArray# is considerably higher than for a cons cell
19:25:37 <dcoutts> dons, ok, good good :-)
19:26:50 <dons> darcs is breaking on me now, complaining about partial patches :/
19:27:25 <dcoutts> :-(
19:27:50 <SamB_XP> partial patches?
19:30:04 * dons tries --reorder-patches
19:33:09 * dcoutts reads sources for withForeignPtr
19:33:14 <dcoutts> it's rather clever
19:33:21 <dcoutts> it looks like its doing a lot of work
19:33:32 <dcoutts> but actually it's just a single pointer dereference
19:33:44 <dcoutts> touchForeignPtr does exactly nothing
19:34:13 <dcoutts> the implementation of touchForeignPtr calls the touch# primop
19:34:17 <dcoutts> which is implemented as:
19:34:18 <dcoutts> emitPrimOp [] TouchOp [arg] live = nopC
19:34:56 <dcoutts> so it's a complex way of doing nothing :-)
19:35:09 <SamB_XP> which is a very important thing to do sometimes
19:35:11 <dons> heh
19:35:20 <dons> I didn't realise it was a nopC
19:35:43 * SamB_XP didn't know what a nopC was, but thinks he knew it was a NOP
19:36:33 <RyanT5000> i often have need of bidirectional maps; e.g.: a datastructure that lets me lookup b's by a's, and also a's by b's
19:36:43 <Saulzar> Perhaps nopC is implemented as a foreign call to C...
19:36:44 <RyanT5000> is there a standard datastructure for this?
19:37:08 <SamB_XP> Saulzar: to an inlined function that does nothing?
19:37:19 <Saulzar> Something like that :)
19:39:48 <dcoutts> RyanT5000, you could do worse than a pair of maps
19:40:12 <Plazma> I am new to programming,, well sort of new.. and iw ould like to acutally grasp the basics of programming so i can move on to making applications and so forth.. is haskell a good place to start? or should i start with a BASIC type language such as REALBASIC
19:40:15 <RyanT5000> dcoutts: well that's the plan, but i was hoping to encapsulate that somehow
19:40:45 <dcoutts> RyanT5000, make a module, don't export the representation
19:41:09 <wolverian> Plazma, it is fairly controversial where one should begin. the common teaching languages nowadays are scheme and java.
19:41:12 <RyanT5000> dcoutts: yah, i guess that's what i'll do; i was just wondering if someone had already done it for me :)
19:41:38 <Plazma> i have had some java expierence but it gets kinda complicated for me.. like ill try to go off on my owna nd write something and then i get lost and frustrated
19:41:40 <dcoutts> RyanT5000, try looking in the libraries page, but I've not heard of one
19:41:42 <dons> Plazma: Haskell's a good introductory language. Basic and its friends aren't
19:42:07 <Plazma> dons , ive heard otherwise about basic and friends.. i know this is #haskell and many will be biased.. etc..
19:42:15 <dons> Haskell's used in many universities as a first programming langauge, so you could certainly start there
19:42:17 <dcoutts> Pascal/Oberon are good teaching languages for imperitive languages
19:42:37 <dcoutts> At Oxford we teach Haskell and Oberon, in that order
19:42:46 <dcoutts> to the first years
19:43:16 <Plazma> never heard of oberon
19:43:37 <Plazma> one thing i like about haskell so far is its cross-platform.. i ujse windows, mac os x , linux.. etc
19:43:43 <dons> Plazma: anyway, if you want to try, look at haskell.org under the tutorials link
19:43:56 <wolverian> dcoutts, that is nice. they use java here, unfortunately. then again, oxford is a bit more posh. :)
19:44:01 <dons> also, the '5 steps to Haskell' introduction
19:44:03 <wolverian> (I'm just jealous.)
19:44:29 <dcoutts> we use Java in the second and third years
19:44:32 <Plazma> dons , hmm ok.. so why not say any BASIC type language?
19:44:38 <dcoutts> Java is not a good introductory language
19:44:43 <dcoutts> too complex, too many quirks
19:44:47 <Plazma> well i was in a major for networking/cisco and they had us doing java.. it got confusing.. complex
19:44:50 <dons> Plazma: I'm not aware of any place that actually teaches basic to students
19:44:56 <dcoutts> to object heavy for an intro to imperitive programming
19:44:58 <Plazma> dons , yea thats true
19:45:10 <wolverian> dcoutts, that sounds like a fairly comprehensive plan. how much programming is there in the first year curriculum?
19:45:17 <Plazma> dons , ive also heard that IDE's are bad for new programmers and to stick with interpeted languages
19:45:18 <dcoutts> wolverian, lots
19:45:18 <RyanT5000> Plazma: what does BASIC teach that other languages don't? except maybe GOTO, which, in my experience, is basically useless
19:45:23 <dons> Plazma: hmm?
19:45:40 <Plazma> RyanT5000 , yea.. i do know that GOTO 's are a no no in a lot of situations
19:45:41 <dons> ides are probably bad for programmers
19:45:55 <dons> but whether your language is interpreted or _compiled_ probably doesn't matter
19:45:59 <dons> when learning
19:46:01 <dcoutts> I don't think that's necessarily true
19:46:05 <dcoutts> about IDEs
19:46:17 <Plazma> ive just heard IDE's are bad for newcomers because they dont acutally learn whats going on.. i guess im referring to something like VB IDE
19:46:25 <Plazma> or so forth where you drag and drop and its done for you
19:46:35 <dons> nothing better than firing up your text editor and learning the tools
19:46:57 <Plazma> yea i use textpad on windows , textmate on os x , and vim on linux
19:47:02 <Plazma> or gedit on linux
19:47:13 <dcoutts> IDEs for some languages (*ahem* C,C++ *ahem*) try to automate some tricky and complex bits, but in a decent language those are non-problems so you shouldn't have the problem that an IDE generates incomprehensable boiler place code
19:47:31 <RyanT5000> lol i currently use visual studio for haskell; here's the total features i use:
19:47:31 <RyanT5000> syntax highlighting
19:47:31 <RyanT5000> text editing
19:47:31 <RyanT5000> tabs and multiple panes
19:47:40 <RyanT5000> everything else is worthless
19:47:55 <Plareplane> ides are good for autocomplete.  if your text editor does autocomplete, i'm not sure if it qualifies as a text editor anymore
19:47:56 <Plazma> i also have used Jedit as well.. its not to bad
19:48:03 <Plazma> hehe
19:48:19 <Plazma> ive not done much programming in vim though.. just some
19:48:26 <Plazma> emacs confused me more than the acutal programming language does
19:49:29 <Plazma> one thing i do like from what im reading about haskell is it acutally can be used in many practical applications
19:50:02 <SamB_XP> always a plus for a programming language ;-)
19:50:11 <Plazma> indeed
19:50:27 <Plazma> i myself benefit more from visual instruction when compared to simply reading.. any acutal video tutorials on haskell?
19:50:29 <tessier__> How about haskell as a replacement for perl/python? Is haskell too low level for that?
19:50:34 <wolverian> tessier__, no.
19:50:48 <Plazma> perl annoyed me.. and python doesnt feel "right" to me for some reason
19:50:54 * tessier__ needs to learn not to ask two opposing questions in the same line
19:50:56 <dons> tessier__: too low level?
19:50:59 <dons> oh this is great
19:51:10 <RyanT5000> tessier__: although if you're using heavy regexes, perl may beat haskell
19:51:12 <tessier__> dons: I noticed HOUSE is an OS written in Haskell. If you can write an OS with it...it must be somewhat low level.
19:51:28 <SamB_XP> tessier_: well, it has low-level capabilities
19:51:37 <tessier__> RyanT5000: I have seen a fair amount of stuff about haskell and pattern matching.
19:51:54 <SamB_XP> Haskell doesn't match that kind of patterns directly
19:52:12 <RyanT5000> tessier__: haskells pattern matching is much simpler than regexes
19:52:31 <RyanT5000> you could match the beginning of a string, but not "any context-free string"
19:52:45 <dons> its cool that you would actually suggest a pure, functional language based on top of the lambda calculus and graph reduction would be too low level :)
19:52:48 <RyanT5000> "any string in this provided context-free language"
19:53:06 <dons> tessier__: is the implication that it wouldn't be expresive enough ?
19:53:40 <dons> but really, haskell is a very high level language, we just have a bit-twiddling library :)
19:54:21 <tessier__> dons: I mentioned to a friend that there is an OS written in haskell and he suggested it might be too low level. I have always considered it high level but HOUSE made me think. Obviously it is best if it can easily be high level or low level when you need it to.
19:54:27 <foxy_> @pl \s -> { do b <- textBufferGetModified s ; return $ not b }
19:54:28 <RyanT5000> tessier__: yeah; dons is right - haskell isn't particularly more low-level than any language that has the ability to call C functions
19:54:28 <lambdabot> (line 1, column 7):
19:54:28 <lambdabot> unexpected "{"
19:54:28 <lambdabot> expecting lambda abstraction or expression
19:54:53 <foxy_> @pl \s -> do { b <- textBufferGetModified s ; return $ not b }
19:54:53 <lambdabot> (line 1, column 10):
19:54:53 <lambdabot> unexpected "{"
19:54:53 <lambdabot> expecting variable, "(", operator or end of input
19:55:07 <Plazma> so i assume GHC is the best compiler to use
19:55:08 <RyanT5000> a language need not be low level to write an OS - it just needs to have the ability to execute a few low-level functions
19:55:21 <foxy_> @pl \s -> textBufferGetModified s >>= return $ not b
19:55:22 <lambdabot> ($ not b) . textBufferGetModified
19:55:41 <foxy_> @pl \s -> textBufferGetModified s >>= return (not b)
19:55:42 <lambdabot> (return (not b) =<<) . textBufferGetModified
19:56:01 <RyanT5000> direct memory manipulation, inputting and outputting to/from ports, accepting interrupts
19:58:08 <Plazma> so what would be better for someone like me.. ghci or hugs?
19:58:36 <dons> Plazma: its all on haskell.org :)
19:58:55 <dons> Plazma: http://haskell.org/haskellwiki/Haskell_in_5_steps
19:58:57 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
19:59:05 <Plazma> im reading that now acutally
19:59:14 <kpreid> RyanT5000: and doing computation without requiring too-complex sub-operations
19:59:21 <Korollary> hugs doesnt support all the libs
20:00:02 <Dreadshoot> dons: what is the prime haskell about, why just not update the whole standard?
20:01:18 <SamB_XP> Haskell', or Haskell prime, its called...
20:02:17 <Dreadshoot> i didnt question the word itself
20:02:35 <Korollary> It is going to be the next standard
20:02:51 <Korollary> prime is just a placeholder name
20:02:57 <SamB_XP> and then it will be Haskell 2007, right?
20:03:12 <Dreadshoot> is it the same committee that was behind haskell 98?
20:03:17 <Korollary> Haskell XP!
20:03:44 <Plazma> hmm.. do i wnat the interpreter or the compiler..
20:03:53 <heatsink> Haskell XD
20:03:54 <Korollary> Plazma: ghc gives you both
20:04:01 <foxy_> dcoutts, had a chance to look at the code?
20:04:08 <Plazma> oh really?
20:04:22 <Korollary> Dreadshoot: Same people, but this time I think it's more of a community work.
20:04:29 <Korollary> more people are involved
20:05:22 <Dreadshoot> hmm, is it so or just.. let them think they are involved
20:05:59 <SamB_XP> if you want to add something, go write a paper and implement it in some Haskell compiler or other ;-)
20:06:34 <dons> Dreadshoot: yes, its a big conspiracy where we are trying to turn haskell into the new C++ , and tricking the community into following
20:06:38 <SamB_XP> oh, and it better work with a dictionary-passing implementation of typeclasses
20:06:49 <Dreadshoot> dons: i fully support that :)
20:07:07 <Dreadshoot> c++ ftw
20:07:09 <SamB_XP> if by "the new C++", you mean what people use instead...
20:07:24 <SamB_XP> that would be nice, but we'd need to work on those space leaks...
20:08:01 <Dreadshoot> dons: thats not what i meant, but in what kind is the community involved, just adding ideas to the committee?
20:08:26 <SamB_XP> we get to say what ideas we like?
20:08:36 <SamB_XP> what extensions we use?
20:09:15 <Dreadshoot> i dunno, thats why im asking
20:11:32 <sethk> dons, you are too late.  I've already turned it into the new c++.  At least in one company.  :)
20:13:17 <Korollary> hey sethk
20:13:43 <sethk> Korollary, hey
20:25:51 <dons> ?karma+ sethk -- for making Haskell the new C++
20:25:52 <lambdabot> sethk's karma raised to 5.
20:27:13 <Dreadshoot> the new c++.. so dons you are saying haskell is wannabe c++
20:27:35 <sethk> dons,  the cm people complained a bit, but I just put the ghc distribution (extracted from the tarball) and used make in-place, and I can now build without having a separate "install ghc" step.
20:27:54 <dons> yes, that's what i'm saying :P I think we should aim to be deliberately obfuscated, ugly, and have terrible semantics. and to be UBIQUITOUS!
20:28:12 <SamB_XP> good luck trying to figure out how to do that
20:28:15 <dons> sethk: ah, interesting strategy, sethk!
20:28:54 <sethk> dons, the configure + make in-place takes only a few seconds.  Of course it's a binary distribution, so nothing is really being built.
20:29:04 <dons> yep
20:29:42 <Korollary> ghc would be easier to install/relocate if the global package.conf didn't have paths hardcoded in it.
20:29:49 <Dreadshoot> i think it looks pretty good syntax wise
20:30:18 <sethk> Korollary, that's true.  In fact, if you move the location, and repeat the ./configure + make in-place, it doesn't work (import fails)
20:30:59 <Korollary> I had to write a perl script that replaced paths in package.conf and the ghc/ghci driver scripts.
20:31:30 <sethk> Korollary, wouldn't be a bad idea to post that in the wiki.  It's good documentation even if someone doesn't want to use perl.
20:32:04 <Korollary> strangely, runghc is written in haskell
20:32:56 <dons> how ironic :)
20:33:29 <Korollary> it basically does `which ghc` unless you give it an explicit path
20:34:01 <Korollary> it's probably there to support win32
20:34:45 <Korollary> probably the same reason as to why runhaskell is an identical executable instead of a symlink
20:39:27 <foxy_> dons, the patch I just sent you... there's a function I was wondering if you could check, it does some pointer stuff that I'm not sure about
20:40:20 <dons> ok. i'll check
20:40:35 <dons> argh. another winmail.dat file :/
20:40:46 <dons> how can we avoid this and get plain text attachments?
20:41:02 <dons> since currently the patches are encoded as applica/ms-tnef, base64, 20K
20:41:48 <dons> ah, mutt wants to extract it. let's see..
20:42:00 <foxy_> arg, is there a way to change it within darcs?
20:42:26 <dons> foxy_: this patch, change container to notebook ?
20:42:30 <foxy_> yes
20:42:40 <dons> seems mutt knows how to extract it. so no problem
20:42:47 <foxy_> yay :)
20:42:57 <dons> i'm not sure its darcs doing this, but maybe the windows sendmail?
20:43:08 * vincenz kicks his connection
20:43:30 <foxy_> ah, OK, I have no idea how darcs interacts with Outlook
20:43:30 <int-e> argh. "[MS] used their own method, called the MicroSoft Transport Neutral Encapsulation Format, or MS-TNEF. Essentially a file called WINMAIL.DAT, which is just a standard MIME encoding of a Rich Text Format version of the message ..."
20:43:49 <int-e> and then they include the attachments in that RTF.
20:44:14 <dons> yeah, that seems to be what's happening to the darcs patches
20:44:18 <int-e> (from http://agamemnon.ucs.ed.ac.uk/faq/mstnef.html )
20:44:20 <lambdabot> Title: What is an "application/ms-tnef" Attachment?
20:45:02 <dons> since its clear that no one using windows would ever email someone on the rest of the internet... :/
20:45:10 <SamB_XP> heh
20:45:31 <dons> we should be able to kick MS every time they intentionally break an open standard
20:45:37 <int-e> Huh? What rest of the internet would that be?
20:45:43 <Korollary> MS outlook also uses some MS-specific tags in emails so the email threads get all barfed.
20:46:03 <Korollary> You can't understand who's replying to whom unless you also use outlook.
20:46:18 <foxy_> @karma- Microsoft
20:46:19 <lambdabot> Microsoft's karma lowered to -1.
20:46:34 <int-e> that's too high.
20:46:37 <Adamant> @karma-- Microsoft
20:46:37 <lambdabot> Microsoft's karma lowered to -2.
20:46:39 <int-e> @karma- Microsoft
20:46:39 <lambdabot> Microsoft's karma lowered to -3.
20:46:51 <dons> i wonder if there's a way to trick the encoding of these attachements to not happen?
20:46:58 <dons> i.e. if the file was called patch.txt ?
20:46:59 <SamB_XP> @karma- Microsoft
20:47:00 <lambdabot> Microsoft's karma lowered to -4.
20:47:18 <foxy_> @google Microsoft karma
20:47:33 <lambdabot> search module failed: IRCRaised thread killed
20:47:33 <Adamant> otoh, they hired SPJ
20:47:35 <SamB_XP> @karma- Microsoft
20:47:35 <lambdabot> Microsoft's karma lowered to -5.
20:47:36 <int-e> . o O ( Not found. )
20:47:49 <Adamant> @karma+ Micorsoft
20:47:50 <lambdabot> Micorsoft's karma raised to 1.
20:47:50 <dons> no karma, it seems
20:47:52 <Korollary> you broke lambdabot
20:47:54 <Adamant> heh
20:47:58 <int-e> @karma+ MicrosoftResearch
20:47:59 <SamB_XP> @google Microsoft karma
20:48:06 * int-e chuckle
20:48:07 <int-e> s
20:48:31 <Dreadshoot> "There are two types of programming languages; the ones that people bitch about and the ones that no one uses. -Bjarne Stroustrup"
20:48:39 <dons> heh
20:48:46 <SamB_XP> Haskell is firmly in the former category
20:48:55 <dons> people do bitch about it a lot
20:49:01 <Korollary> palomer himself bitches about haskell enough for everybody
20:49:04 <Dreadshoot> not really, you seem to bitch down on c++ all the time :)
20:49:26 <Korollary> I don't. I write C++ for a living.
20:49:27 <SamB_XP> I myself bitch about STUArrays every chance I get
20:49:29 <Saulzar> Yeah but everyone else bitches about Haskell
20:49:29 <foxy_> dons, the function is FastBuffer.hs:172:cPutFBuffer
20:49:41 <dons> ok. looking foxy_
20:49:53 <dons> Dreadshoot: this is #haskell, we're allowed to bitch on C++ here
20:49:56 <dons> its expected
20:49:59 <int-e> Hehe. lazyness is Haskell's main virtue and also its main problem ...
20:50:04 <Korollary> I think it's also expected in ##c++
20:50:09 <Korollary> or whatever channel it is
20:50:15 <Dreadshoot> dons: yeah didnt expect anything else
20:50:24 <int-e> C++ does make a reasonably usable high-level assembler.
20:50:39 <SamB_XP> don't people bitch about C++ in *every* channel on this network?
20:50:43 <foxy_> dons, Yi hangs when you write to file "C-x C-w"
20:50:51 <dons> ?remember int-e C++ does make a reasonably usable high-level assembler
20:50:51 <lambdabot> Done.
20:50:54 <Dreadshoot> c++ is way higher level than assemby
20:51:01 <SamB_XP> @quote SamB
20:51:02 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
20:51:14 <SamB_XP> haha, right on the first try ;-)
20:51:27 <Frederick> :(
20:51:38 <dons> foxy_: you want me to just apply this patch, and then comment?
20:52:00 <SamB_XP> Frederick: it refers to all the UB and implementation-defined behaviour
20:52:12 <dons> but we love C here.
20:52:15 <Frederick> instead of messing other languages you could write better tutos for haskell.
20:52:24 * Frederick is reading some papers
20:52:26 <Korollary> There are way too many haskell tutorials
20:52:32 <Saulzar> Hmm, can Haskell feasably compile for any pda? Seems to be 3 different OS' and hardware...
20:52:39 <dons> C is the thing on the end of our FFI, so that gives it some good karma
20:52:45 <Frederick> Korollary, it lacks a good book
20:52:48 <SamB_XP> really, you can always assume things about the implementation of C
20:53:09 <Korollary> Frederick: School of Expression is ok, imho.
20:53:21 <Frederick> Korollary, yup it is oki, not good
20:53:32 <SamB_XP> ... sometimes your assumptions will turn out to be wrong, but what do you expect when you start to make assumptions?
20:53:45 <monochrom> What is good?
20:53:53 <Frederick> monochrom, as a book?
20:53:54 <Korollary> I dont remember ever making assumptions. I don't know what you are talking about.
20:54:11 <int-e> gcc 4 breaks some assumptions in really funny ways.
20:54:16 <monochrom> I guess
20:54:24 <Frederick> monochrom, K&R
20:54:26 <SamB_XP> Korollary: I was talking about using C, silly
20:54:30 <Frederick> TOCP
20:54:32 <Korollary> SamB_XP: I know.
20:54:49 <Frederick> advanced programming in unix enviroment ...
20:55:07 <SamB_XP> I bet you have made unwarranted assumptions in C!
20:55:11 <Frederick> Dive into Python
20:55:15 <Korollary> Give me an example?
20:55:24 <SamB_XP> example?
20:55:30 <Korollary> of an assumption
20:55:49 <int-e> gcc 4 also impressed me. it optimized unsinged int x, y; [...] while (x) { y++; x+=3; } to ... y += x*<some constant>; x=0; (wow)
20:55:50 <SamB_XP> you crack open the spec every time you code?
20:55:52 <stepcut> Saulzar: Since Haskell is a language not a specific compiler ... yes. YHC generates byte-code that runs on a highly portable VM, so that might be one option
20:56:01 <int-e> Oh, 'unsinged'.
20:56:24 <Korollary> I don't. In fact, I've never read the C standard.
20:56:39 <SamB_XP> Korollary: you never code in C huh?
20:56:49 <Korollary> No, I've coded in C for about 4 years
20:57:04 <SamB_XP> well then I think you must be assuming you've an idea what C is ;-)
20:57:13 <int-e> platform-independent C code is a myth. :/
20:57:19 <SamB_XP> int-e: indeed
20:57:24 <SamB_XP> thats kind of what I am getting at ;-)
20:57:42 <Korollary> Not everybody writes platform independent code.
20:58:00 <monochrom> Not everyone writes platform dependent code.
20:58:15 <SamB_XP> eventually, someone will try to use it on an incompatible platform
20:58:15 <Korollary> It wasn't particularly platform dependent. We just didn't give a crap.
20:58:30 <SamB_XP> maybe it will happen to work
20:58:43 <int-e> my current pet peeve is that you can't just take two pointers and compare them, because if they don't point to the same memore object (or one location after it) and aren't 0 pointers, that triggers undefined behaviour.
20:58:43 <Korollary> Not likely due to numerous non-technical reasons.
20:58:49 <Dreadshoot> SamB: most plograms written is only used on one target platform anyway, so whats the problem
20:59:14 <SamB_XP> well, in any case I'm sure it makes assumptions beyond the standard ;-)
20:59:27 <int-e> Oh I got an upgrade to my typo module. 'memore' is new.
20:59:37 <Korollary> La memore!
21:00:30 <int-e> But I don't know french :)
21:00:34 <SamB_XP> pretty much you just have to assume that the C implementation is sane -- or go insane yourself...
21:01:12 <foxy_> dons: I'm doing some C pointer trickery and I don't know if I'm doing it correctly
21:01:16 <Korollary> well, compiler docs usually tell you what you need to be careful with. It's the least of your problems. Typically, you don't know what the heck you are supposed to write.
21:01:20 <SamB_XP> i.e., unless you know you want to run it in a segmented memory model (ala win16), just compare away...
21:01:30 <foxy_> dons, because it's hanging Yi
21:01:55 <Dreadshoot> as if you often have to compare 2 pointers
21:02:02 <dons> foxy_: hmm. I think you probably should just to a memcpy
21:02:19 <dons> since you've got Ptr CChar on both sides
21:02:21 <Korollary> Dreadshoot: I've done that a lot actually
21:02:58 <Dreadshoot> Korollary: yeah.. and how much problems have you got with it?
21:03:10 <dons> foxy_: It seems highly suspect to reallocArray the cstr
21:03:12 <Korollary> None. I didn't have many bugs, either.
21:03:15 <Dreadshoot> exactly
21:03:27 <dons> foxy_: can you pop over to #haskell-overflow?
21:03:34 <monochrom> I think we're complaining about the standard, not the existing implementations.
21:03:41 <SamB_XP> quite
21:04:26 <monochrom> The implementations let us safely compare pointers fine.  The standard doesn't, and that's the regretful thing we're talking about.
21:04:49 <SamB_XP> yup
21:04:57 <dons> foxy_: let me mail a reply with my comments
21:05:23 <int-e> gcc 4.1 is a bit funny. See for example http://www.securityfocus.com/archive/1/431184/30/0/threaded   ... note that gcc's behaviour is correct according the the C standard.
21:05:24 <SamB_XP> only, if you hang in ##c, they will probably tell tales of implementations that *don't*
21:06:07 <Dreadshoot> monochrom: well if the implementations does it.. then it aint really a problem for the programmer.. is it
21:06:54 <SamB_XP> Dreadshoot: except then someone comes along and implements it wrong, but still standardly!
21:07:08 <Korollary> Then it's not wrong
21:07:25 <Korollary> as long as its docs say what it does
21:07:41 <SamB_XP> but it *is*
21:07:46 <SamB_XP> it means you have to *check*
21:07:51 <Dreadshoot> SamB: someone.. well you still have the choice of choosing what implementation to use
21:07:57 <SamB_XP> *every time you upgrade*
21:08:03 <monochrom> I am never too sure about lack of problems.
21:08:07 <Korollary> These are really minor problems. Code is not portable for a plethora of reasons.
21:08:40 <foxy_> dons, ok, thanks, if you could suggest how to actually do it ? ... ;)
21:08:53 <dons> yep, I'm writing a version for you :)
21:09:19 <Dreadshoot> yep, sounds like more that someone that cant come up with any real problemjust wanna bitch about something and luckily found some minor flaw
21:09:21 <foxy_> :)
21:10:15 <Korollary> For instance, boost or stlport can bitch about the various c++ compilers. I have sympathy. But, I don't write that kind of code.
21:11:18 <dons> maybe we should move this over to #haskell-bitching-about-c++ ?
21:11:27 <Korollary> heh. sorry.
21:12:04 <foxy_> I just did the 'What programming language is for you" test (linked from LtU) and got C/C++ !!!
21:12:10 <Korollary> heh
21:12:51 <ayrnieu> foxy - well, we'll be seeing you.
21:13:13 <dons> foxy_: hah!
21:13:35 <dons> you forgot to tick the "I want type level hacking" box
21:14:10 <foxy_> http://awaretek/atesterea.html
21:14:41 <dons> ok, sent a reply, fo	
21:14:46 <dons> xy. slow tab
21:15:36 <dons> anyone want to try out the new ghci binding to lambdabot?
21:17:50 <foxy_> dons, is Data.ByteString a GHC 6.5 ism?
21:18:09 <dons> no, you either need to have fps installed, or else it comes for free with 6.5
21:18:13 <dons> ?where fps
21:18:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:22:02 <dons> GOA> :pl \f x y -> x $ f y x
21:22:03 <dons> ap (.) . flip
21:22:03 <dons> GOA> :version
21:22:03 <dons> lambdabot 4p36, GHC 6.4.2 (OpenBSD i386 )
21:22:03 <dons> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:22:04 <lambdabot> Title: Index of /~dons/lambdabot
21:22:05 <dons> GOA> map (+1) [1..10]
21:22:07 <dons> [2,3,4,5,6,7,8,9,10,11]
21:23:11 <Korollary> is that within a ghci session?
21:23:24 <dons> yes :)
21:23:31 <dons> ghci launches up as GOA>
21:23:39 <dons> which is ghci + lambdabot bindings transparently available
21:24:09 <ayrnieu> what does it mean, though?
21:24:21 <Korollary> it means you can use lambdabot stuff within ghci
21:24:33 <dons> GOA> :bs
21:24:33 <dons> :)
21:24:33 <dons> GOA> :docs Prelude
21:24:33 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
21:24:33 <dons> GOA> :m + List
21:24:35 <dons> GOA List>
21:24:43 <dons> so you get both lambdabot things, and normal ghci things
21:24:52 <ayrnieu> more importantly, what does GOA mean?
21:24:54 <dons> giving you access to @instances, @docs, @source, @pl and so on
21:25:01 <dons> GHCi on ACID
21:25:23 <wolverian> ?where GOA
21:25:24 <lambdabot> I know nothing about goa.
21:25:29 <wolverian> dons, where? :)
21:25:38 <dons> ?where lambdabot
21:25:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:25:47 <dons> check the lambdabot home page, its got a link to the darcs repo for goa
21:25:49 <Stinger_> you should change that to "I know nuuusiiink!"
21:25:50 <wolverian> oh, thanks
21:26:00 <dons> you need to have lambdabot installed. and then build goa.
21:26:39 <dons> ?where+ goa http://www.cse.unsw.edu.au/~dons/code/goa/
21:26:40 <lambdabot> Done.
21:27:33 <dons> I'm interested in getting some feedback before we release it
21:31:43 <foxy_> dons, Is there a way to cast a CString to (Ptr Word8) ? (to make the code you sent me work)
21:31:51 <dons> ah. castPtr
21:31:57 <dons> ?type Foreign.castPtr
21:31:59 <lambdabot> forall b a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
21:32:14 <dons> i.e. f ptr --> f (castPtr ptr)
21:32:36 <dons> ?hoogle CString
21:32:37 <lambdabot> Foreign.C.String.CString :: type CString
21:32:37 <lambdabot> Foreign.C.String.CStringLen :: type CStringLen
21:32:37 <lambdabot> Foreign.C.String.newCString :: String -> IO CString
21:32:48 <dons> oh, it should show what CString is a synonym for
21:33:19 <dons> @tell ndm could hoogle show the rhs of a type synonym? so ?hoogle CString -> type CString = Ptr CChar ?
21:33:19 <lambdabot> Consider it noted.
21:34:19 <foxy_> ?hoogle CSize
21:34:20 <lambdabot> Foreign.C.Types.CSize :: data CSize
21:34:29 <int-e> sigh, stupid ghci.
21:34:58 <lisppaste2> int-e pasted ".ghci included twice :/" at http://paste.lisp.org/display/23368
21:35:41 <dons> is it included twice? or is the .ghci file  too long?
21:36:05 <dons> what's in your ~/.ghci ?
21:36:06 <int-e> put .ghci in your home dir and run ghci from there.
21:36:20 <dons> ah
21:36:36 <dons> hmm. no. doesn't do it here.
21:36:40 <foxy_> dons, howzabout CChar -> Word8 ?
21:36:52 <dons> fromIntegral
21:37:21 <dons> int-e, what's in your .ghci? $ length .ghci
21:37:21 <dons> 12
21:37:31 <dons> it could be a 6.5-ism, I suppose?
21:37:46 <int-e> possibly.
21:37:57 <int-e> it's just the dot-ghci from goa
21:38:02 <int-e> (it was empty before)
21:38:13 <dons> hmm.
21:38:33 <dons> does -ignore-dot-ghci help?
21:38:37 <dons> or does that disable all .ghcis
21:39:02 <dons> ah, you can use a combination of -ignore-dot-ghci and -read-dot-ghci $HOME/.ghci
21:39:10 <dons> to force only one to be read, I think
21:39:23 <wolverian> hm, hs-plugins fails to build on my 6.5
21:39:46 <dons> indeed. do you have a 6.4.2 install already?
21:39:58 <wolverian> yes
21:40:09 <dons> you need to do 2 small things then:
21:40:28 <dons> edit the plugins.cabal file to have this line: includes:             Linker.h Typeable.h
21:40:50 <dons> and add the path to your 6.4.2 include dir to ghc-options, i.e. -I/home/dons/l
21:40:50 <dons> ib/ghc-6.4.2/include/
21:40:54 <dons> then rebuild
21:41:01 <dons> it will use the 6.4.2 Typeable.h , which is ok
21:41:14 <wolverian> thanks!
21:41:17 <dons> for GOA purposes we don't even need hs-plugins
21:41:31 <wolverian> hm, I thought lambdabot requires it
21:41:31 <dons> so many i'll add that as an optoinal extra, if people start using goa more than lambdabot-on-irc
21:41:36 <wolverian> right
21:41:37 <dons> wolverian: no, its optoinal
21:41:44 <dons> grr. typo. brain mess
21:41:47 <wolverian> well the configure bombs if it's not present
21:41:54 <dons> yes. but we can fix that.
21:41:56 <dons> i will do so now.
21:42:00 <wolverian> @karma+ dons
21:42:01 <lambdabot> dons's karma raised to 46.
21:42:01 <int-e> dons: that warning seems to be new. I suppose ghc-6.4.2 reads the file twice, too.
21:42:20 <dons> int-e, ah maybe.
21:53:11 <dons> wolverian: i've just pushed a lambdabot patch that removes the hs-plugins dependency, by default
21:53:37 <wolverian> thanks!
21:57:44 <wolverian> hm. is fps in ghc 6.5?
21:57:58 <dons> it is. so you need to remove the fps dep in the cbal file if you're using 6.5
21:58:03 <int-e> Data.ByteString is in the base package.
21:58:04 <dons> how recent is your 6.5?
21:58:06 <wolverian> heh.
21:58:09 <wolverian> let me see
21:58:18 <wolverian> ghc-6.5.20060712
21:58:27 <int-e> not too recent then
21:58:56 <int-e> i.e. should be fine :)
21:59:14 <dons> yes, that should be fine
21:59:25 <wolverian> :) thaks
21:59:28 <wolverian> s,ks,nks,
21:59:47 <dons> you need a ghc newer than July 1
21:59:50 <foxy_> @hoogle with
21:59:51 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
21:59:51 <lambdabot> Network.withSocketsDo :: IO a -> IO a
21:59:51 <lambdabot> Distribution.PackageDescription.withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
21:59:57 <int-e> It's probably a good idea to avoid versions later than 0725 for a bit.
22:00:23 <wolverian> oh, what's happening? sounds interesting
22:01:05 <dons> packages are first class!
22:01:09 <int-e> oh, package system modifications. "a module is now identified by the pair of its package and module name" (before it was just the module name)
22:01:35 <dons> which should solve some issues with , i.e. multiple ByteString.hs installed :)
22:01:39 <int-e> introduces a bit of trouble though. cabal is still a bit broken.
22:02:25 <dons> I think a style rule should be to not mix haskell98 names with hier name
22:02:32 * dons grumbles about ndm's code 
22:02:37 <int-e> (it passes -package-name <package> to ghc when building but later ghc looks for the package with full version.)
22:03:08 <int-e> i.e. ghc looks for fps-0.7:Data.ByteString but only finds fps:Data.ByteString and doesn't like that.
22:03:25 <dons> ah
22:03:34 <dons> so big changes to hs-plugins coming up too then
22:03:39 <dons> boo
22:03:51 <int-e> yes, runplugs is currently broken.
22:04:06 <dons> yeah, parsing .hi files will probably fail
22:04:10 <dons> as will searching the package.conf
22:04:10 <int-e> lambdabot works though, which surprises me a bit.
22:04:17 <dons> well, that's good :)
22:04:44 <dons> its getting more and more buildable as the years go by :)
22:04:56 <int-e> runplugs fails to resolve symbols. runplugs: /tmp/MOzqG16515.o: unknown symbol `base_GHCziNum_Szh_con_info'
22:04:59 <dons> i mean, in the dim dark days exactly, precisely one person could build lambdabot
22:05:05 <dons> ah yes
22:05:10 <dons> so even worse than I thought
22:05:15 <dons> we have to change how we search for syms
22:05:37 <int-e> I did comfort you about that a day or two ago ;)
22:05:49 <dons> yes, I didn't realise it was this bad :)
22:06:09 <dons> perhaps I shall just switch to ghc-api for hs-plugins post 6.6
22:06:56 <wolverian> hm, GOA seems to die
22:07:15 <dons> ?paste
22:07:16 <lambdabot> http://paste.lisp.org/new/haskell
22:07:18 <dons> transcript, wolverian ?
22:07:36 <wolverian> well, everything goes well until:
22:07:37 <wolverian> GOA> :hoogle foo
22:07:37 <wolverian> 2;141 wolverian@feather:~$
22:08:07 <dons> does lambdabot run in its home dir?
22:08:12 <dons> cd lambdabot ; ./lambdabot ?
22:09:02 <wolverian> yup
22:09:14 <dons> and then does hoogle map work inside ./lambdabot ?
22:09:37 <wolverian> yes
22:09:51 <dons> ok. do other lambdabot commands work inside ghci? like :bs ?
22:10:05 <wolverian> :bs works
22:10:13 <wolverian> wait, :hoogle works now ...
22:10:15 <vincenz> @bs
22:10:16 <lambdabot> Maybe you meant: . ask b52s id msg pl v wn
22:10:23 <dons> it should be ?bot
22:10:28 <wolverian> I think I forgot to ./build lambdabot
22:10:31 <dons> wolverian: hmm. ok. ah!
22:10:36 <dons> yes, helps to install and build ;)
22:10:44 <wolverian> PEBCAK strikes again
22:10:46 <wolverian> thanks :)
22:10:48 <dons> but we should issue a better message
22:12:49 <wolverian> is there a plugin to show the actual source of a function?
22:13:07 <dons> ?source Data.List
22:13:08 <lambdabot> lambdabot 4p36, GHC 6.5 (OpenBSD i386 )
22:13:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:13:18 <dons> ?fptools Data.List
22:13:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
22:13:25 <dons> that is as close as we have
22:13:29 <wolverian> mm, okay.
22:13:32 <dons> but we could just about do it with a tags file
22:14:07 <dons> it would be worth writing though
22:14:18 <wolverian> what, no automatic deparsing back to source? :)
22:14:21 <dons> but it would need, ideally, the base libs installed (or all of fptools)
22:14:40 <wolverian> right.
22:14:45 <dons> no. that's a bit hard in a statically typed, compiled language that throws away all type info.
22:15:03 <dons> our binary blobs don't reveal very much about hte original source :}
22:15:17 <wolverian> I suppose that makes it a bit hard, yeah..
22:15:23 <wolverian> thanks for goa, it's great :)
22:15:38 <wolverian> (and fps, and lambdabot, and hs-plugins, and...)
22:15:52 <dons> sure :)
22:16:24 <dons> so what issues did we find?
22:16:28 <dons> a) hs-plugins dep (solved)
22:16:37 <dons> b) no error msg if lambdabot fails to start?
22:16:40 <dons> anything else?
22:16:50 <dons> ?karma+ wolverian -- alpha testing
22:16:51 <lambdabot> wolverian's karma raised to 1.
22:16:55 <wolverian> hmm.. Exception: <socket: 5>: hGetChar: end of file
22:17:00 <wolverian> ./lambdabot --online
22:17:22 <wolverian> it gets up to NOTICE: ["*",":*** Ident reply received."], then bombs out with that.
22:17:38 <dons> are you trying to connect to freenode as "lambdabot" ?
22:17:46 <dons> if so, you need to change the name of the bot
22:17:50 <wolverian> no. it is possible there is a nick clash, however
22:17:50 <dons> in Config.hs
22:17:51 <wolverian> let me see.
22:18:05 <wolverian> no, there shouldn't be. I'm trying to connect to efnet
22:19:07 <dons> not sure then .double check your Config.hs settings for ports, servers and so on
22:19:14 <dons> and make sure to rebuild when you tweak Config.hs
22:19:16 <wolverian> right
22:21:14 <wolverian> ok, another server worked
22:21:28 <wolverian> possible that the machine has just too many connections to irc.prison.net
22:22:06 <wolverian>  fd:8: hClose: resource vanished (Broken pipe) when trying to eval on irc
22:22:38 <wolverian> don't tell me that's what I need hs-plugins for :)
22:23:17 <int-e> ... @run uses hs-plugins indeed.
22:23:30 <int-e> @run 2*42
22:23:31 <lambdabot>  84
22:23:41 <wolverian> mmkay, adding that then.. :-)
22:23:42 <wolverian> thanks
22:23:48 <dons> that's exactly what its for :)
22:30:14 * edwardk wakes up and waves ello.
22:30:46 <edwardk> got most of a perl based jit done the other night after i gave up on the haskell jit in disgust =)
22:31:56 <wolverian> hmm, how do I enable @run? RunPlugs? uncommenting that in lambdabot.cabal gives at buildtime this: Could not find module `System.Eval.Haskell'
22:32:09 <edwardk> have the perl one jitting code in x-kilobyte chunks down to functions, via c, then dynamically linking them back in and running them. but interpreting code unless that target spot has been jumped to at least a given number of times.
22:32:15 <edwardk> trying to get the best of both worlds
22:32:25 <wolverian> (that's naturally a wild guess)
22:32:42 <wolverian> edwardk, oh, nice
22:32:43 <edwardk> wolverian: have you downloaded hsplugins?
22:32:49 <wolverian> edwardk, yes, just installed it
22:32:55 <dons> wolverian: with the new lambdabot, you need to use lambdabot.cabal.plugins
22:33:06 <dons> using the patch i pushed a little while ago
22:33:16 <wolverian> ah, ok. thanks again.
22:33:25 <dons> i.e. mv lambdabot.cabal to lambdabot.cabal.prime ; ...
22:35:24 <wolverian> ghc-6.5.20060712: could not execute: /usr/obj/cabal/BotPP/BotPP
22:35:28 <wolverian> again at ./build
22:35:43 <dons> oh. my bad
22:35:54 <wolverian> :) no worries
22:36:03 <dons> edit the current cabal file to use the same paths as the first cabal file
22:36:12 <dons> it should retefre to dist/build/BotPP/BotPP
22:36:26 <dons> refer (/me takes eyes of screen and thinks about something else while typing)
22:37:54 <dons> just pushed a patch to do this
22:38:21 <wolverian> yup. thanks, vimdiffed it
22:42:00 <wolverian> ok, now > "foo" fails with: user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: ...
22:42:23 <dons> hm. not sure what that is
22:42:25 <wolverian> (how considerate of it to ellipsize the actual reason :)
22:44:15 <wolverian> just > foo doesn't die though (besides not finding the symbol)
22:44:30 <wolverian> but anything that wants to print user data seems to die with that error
22:45:05 <wolverian> also, weird: IrcMessage {msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@run  product [1..3]"]}
22:45:15 <wolverian> where does #haskell come from? it is not in the .cabal file
22:46:40 <tessier> #haskell is an IRC channel. :)
22:47:09 <wolverian> really. ;)
22:47:17 <tessier> Seriously.
22:47:23 <wolverian> what's this IRC thing you speak of?
22:48:18 <tessier> I Repeat Classes
22:48:24 <tessier> The Internet's biggest time waster.
22:48:31 <tessier> I've been an addict since '93.
22:48:49 <tessier> Take my advice: Sell your computer and go Amish before it's too late.
22:49:32 <wolverian> it's too late.
22:50:31 <int-e> wolverian: IRC.hs, offlineReaderLoop
22:51:18 <wolverian> ah. should have grepped myself
22:51:19 <wolverian> thanks
22:56:32 * tessier raps o/ grep yourself before you wreck yourself o/~
23:01:21 <dons> int-e, you fixed the cabal issue?
23:01:27 <dons> ?karma+ int-e -- haxoring
23:01:28 <lambdabot> int-e's karma raised to 9.
23:02:58 <foxy_> dons, I got that working, the problem was deadlocks with MVars, fixed now.
23:03:30 <dons> ok. good
23:07:35 <int-e> dons: I don't like the fix. But it works for now.
23:13:43 <foxy_> what causes short file reads?
23:14:16 <dons> hard drives getting set on fire?
23:14:35 <vincenz> short ide cables
23:14:58 <dons> heh
23:15:15 <foxy_> @yarr
23:15:16 <lambdabot> I heard andersca is a pirate
23:15:21 <int-e> short files (sorry)
23:15:28 <vincenz> oh
23:16:23 <foxy_> the size that hFileSize returns is different from the amount that hGetBuf reads? %-<
23:16:27 <jer> @convert 4 oz pound
23:16:28 <lambdabot> Unknown command, try @list
23:16:32 <jer> err wrong chan
23:16:45 <vincenz> foxy_: you mean list lenght?
23:16:53 <vincenz> foxy_: hGetBuf returns [Char]
23:16:55 <vincenz> [Char] is unicode
23:16:57 <dons> japplied, foxy_ thanks.
23:17:07 <vincenz> whic means it can be more than one byte per Char
23:17:31 <vincenz> aka (liftM length $ hGetBuf) should be smaller than hFileSze
23:17:46 <foxy_> @hoogle hGetBuf
23:17:47 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
23:17:47 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
23:17:47 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
23:17:55 <vincenz> whoops
23:17:58 * vincenz was thinking of something else
23:18:24 <foxy_> @hoogle hFileSize
23:18:25 <lambdabot> IO.hFileSize :: Handle -> IO Integer
23:19:19 <foxy_> with my file hFileSize returns 54 and (hGetBuf ptr 54) returns 51
23:19:25 <vincenz> hGetBuf hdl buf count reads data from the handle hdl  into the buffer buf until either EOF is reached or count 8-bit bytes have been read. It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if count is zero).
23:19:36 <vincenz> ah
23:19:40 <int-e> foxy_: hmm, are you on windows?
23:19:46 <foxy_> yes :(
23:19:47 <vincenz> int-e: thinking \r\n?
23:19:51 <int-e> yep
23:20:15 <int-e> I think the file is openened in text mode, and \r\n is converted to \n
23:20:43 <foxy_> @hoogle ReadMode
23:20:44 <lambdabot> System.IO.ReadMode :: IOMode
23:20:45 <dons> ah, you might need openBinaryFile ?
23:20:59 <foxy_> @hoogle openBinaryFile
23:21:00 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
23:21:08 <dons> doesn't do the text mode conversions on windows
23:21:14 <foxy_> aha, I'll try that
23:43:06 <foxy_> woohoo, I can load, save, and edit files!
23:43:26 <dons> yay!
23:43:33 <dons> ?karma+ foxy -- yi hacking!
23:43:34 <lambdabot> foxy's karma raised to 2.
23:44:01 <foxy_> thanks for helps various peoples :)
23:46:43 <dons> foxy_: screenshot!
23:47:49 <foxy_> hm... how on windows?
23:48:26 <rictic> Ok, this is among the dumbest questions I've ever asked, but I'd like to import ParsecExpr and I neither know the path (Text.ParserCombinators.Parsec) nor how to find this information
23:48:51 * rictic I have: import Text.ParserCombinators.Parsec hiding (Line)
23:48:51 * rictic import Text.Parsec.ParsecExpr
23:49:15 <rictic> And runhaskell can't find ParsecExpr
23:49:24 <rictic> I've also tried just import ParsecExpr
23:51:38 <paj> runhaskell is ghc, so import Text.ParserCombinators.Parsec.Expr should be right.
23:52:17 <Korollary> @index ParsecExpr
23:52:17 <lambdabot> bzzt
23:52:24 <paj> The Parsec tutorial is a bit out of date.
23:52:30 <Korollary> @docs ParsecExpr
23:52:31 <lambdabot> ParsecExpr not available
23:52:37 <dons> ?google how to take a screenshot on windows
23:52:40 <rictic> paj: Thank you, I feel like I've been asking too many questions here lately, but everywhere I looked online just had 'import ParsecExpr'
23:52:40 <lambdabot> http://support.cis.ksu.edu/docs/user/faq/windows/screenshot.html
23:52:54 <paj> @index Text.ParserCombinators.Parsec.Expr
23:52:54 <lambdabot> bzzt
23:54:16 <paj> You need to check the GHC library docs for the updated reference manuyal
23:54:52 <dons> ?hoogle Expr
23:54:53 <lambdabot> Text.ParserCombinators.Parsec.Expr :: module
23:54:53 <lambdabot> Text.ParserCombinators.Parsec.Expr.buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
23:55:07 <dons> ?docs Text.ParserCombinators.Parsec.Expr
23:55:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Expr.html
23:58:21 <rictic> Wow.  It just did exactly what I needed with minimal effort.  ParsecExpr is like magic.
