00:00:01 <vilager> my problem
00:00:05 <vilager> the iputs
00:00:08 <vilager> are like that
00:00:13 <vilager> inputs:
00:00:23 <vilager> a Integer n
00:00:35 <vilager> and n lines with 2 Integers
00:00:37 <vilager> example:
00:00:38 <vilager> 5
00:00:40 <vilager> 2 4
00:00:41 <vilager> 3 1
00:00:42 <vilager> 2 6
00:00:47 <vilager> 8 9
00:00:48 <vilager> 7 2
00:00:51 <vilager> you know ?
00:01:28 <largos> vilager: you can bound the list to itterate over, it doesn't need to be infinite, as [1..] is
00:02:17 <dons> yeah, you'll need to modify your main function just slightly to either map verificaAluno over the list, or to call a worker loop, whose first argument is 1.
00:02:24 <dons> its 2 or 3 lines of code. so pretty easy.
00:02:33 <vilager> hmm
00:02:35 <dons> if you're totally stuck, post the main function
00:02:49 <dons> ?paste
00:02:50 <lambdabot> http://paste.lisp.org/new/haskell
00:03:12 <dons> vilager: really, this is a pretty common problem, yeah? so there are standard ways to solve it :)
00:03:35 <dons> 3 common solutions. a recursive loop, or a map, or a list comprehension
00:03:45 <dons> just as in C you would use a for-loop
00:04:09 <dons> (or maybe a global variable, but its kind of heavy-weight to use a global variable for this, i would argue)
00:04:58 <johnnowak> yes, why use a heavy thing like a global variable when you can use a list comprehension? :)
00:05:08 <vilager> hmm
00:05:09 <vilager> hehe
00:05:10 <vilager> ok guys
00:05:13 <vilager> i've figured out
00:05:17 <vilager> ^^
00:05:20 <vilager> thanx =D
00:05:36 <dons> the semantics of a global var a subtle and can lead to bugs. a [ | ] isn't nearly so evil
00:06:11 <dons> ?type sequence_ [ print x | x <- [1..10] ] -- hello imperative loop
00:06:13 <lambdabot> IO ()
00:06:29 <dons> ?type mapM_ print [1..10] -- or nicer
00:06:31 <lambdabot> IO ()
00:07:03 <largos> ?hoogle mapM_
00:07:04 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
00:07:04 <dons> ?type let f 10 = return () ; f n = print n >> f (n+1) in f 0 -- or old school style
00:07:04 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
00:07:05 <lambdabot> IO ()
00:07:36 <vilager> i got it
00:07:43 <dons> fmapM_, that's your friendly function for the day.
00:07:48 <vilager> =D
00:07:52 <vilager> dons
00:07:57 <vilager> thank you very much
00:07:59 <vilager> largos
00:08:01 <vilager> you too
00:08:01 <dons> i encourage all to use fmapM_ in at least one sentence today, for bonus points.
00:08:06 <vilager> i've solved my problem
00:08:09 <sjanssen> alternatively, use unsafePerformIO and a NOINLINE pragma to create your global var
00:08:11 <dons> how'd you solve it?
00:08:23 <vilager> dons
00:08:25 <vilager> the problem
00:08:26 <vilager> is
00:08:27 <dons> sjanssen is clearly a subversive
00:08:53 <vilager> that my main function couldn't have any argument
00:08:59 <vilager> so i just changed
00:09:08 <vilager> and the main function
00:09:21 <vilager> call another auxiliar function giving an argument starting in 1
00:09:30 <vilager> main = comeca 1
00:09:30 <vilager> comeca turma = do
00:09:30 <vilager>        {
00:09:30 <vilager>         
00:09:30 <vilager>          x<-getLine;
00:09:30 <vilager>          if x/="0" then do { entraNotas (read x :: Int) [] turma; comeca (turma+1); } else putStr ""
00:09:32 <vilager>        }
00:09:32 <dons> ok. cool. a worker :)
00:10:05 <vilager> thank you very much ^^
00:10:18 <vilager> good night
00:10:20 <vilager> cya
00:10:35 <dons> another option would be to say, main = mapM_ comeca [1..] ; comeca turm = do ... if x/="0" then do { entraNotas (read x :: Int) [] turma
00:10:50 <dons> i.e. let the mapM_ handle the looping, don't do it explicitly
00:10:57 <dons> ah well. too slow
00:11:13 <dons> where do they teach this explicit layout style?
00:11:18 <dons> bad karma
00:12:37 <largos> a large part of the Parsec documentation seems to use it
00:12:52 <dons> ah, there you go
00:12:57 <largos> (not that that's the cause of all evil, but I happen to be in there right now)
00:26:29 <jmob> I just wrote something that I don't think is possible in a strict functional language, and it struct as being really cool, so I wanted to share my experience with #haskell
00:28:21 <dons> cool. 
00:28:24 <dons> want to paste it?
00:28:38 <kaol> strict functional languages are during complete too
00:28:48 <dons> there's lots of fun things that you can't do if your language is strict though
00:28:50 <kaol> s/during/Turing/ (blah)
00:28:56 <dons> without emulating laziness somehow
00:29:07 <dons> > [1..]
00:29:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
00:29:11 <jmob> Sure, I'm just learning though, so it's probably just new user awe
00:29:20 <jmob> Where to paste?
00:29:24 <dons> ?paste
00:29:24 <lambdabot> http://paste.lisp.org/new/haskell
00:30:04 <dons> kaol: i guess its really expressiveness that's important here, not turing completeness. just because you can do it all in asm, doesn't mean that's a fun thing ;)
00:30:21 <jmob> kaol: sure it'd be possible, but probably not as interesting
00:30:38 <kaol> I know, I was just being too pedantic, sorry. ;-)
00:30:41 <dons> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20
00:30:43 <lambdabot>  10946
00:30:53 <dons> for example, is fun and expressive
00:31:16 <lisppaste2> jmob pasted "strcmp" at http://paste.lisp.org/display/22247
00:31:18 <dons> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
00:31:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:32:29 <dons> fun jmob :) I like your 'infinite' 
00:34:14 <jmob> Infinite truth? :)
00:35:18 <jmob> I was surprised that (tail f) on infite didn't try to compute the whole list
00:35:46 <jmob> I was trying to do something like (tail . f) instead
00:36:05 <dons> tail just drops the head, so it'll only force one element
00:36:20 <dons> that's why it also works above in fibs()
00:36:30 <jmob> Ah, okay.
00:37:16 <paolino> jmob, can you explain your first assertion on strictness ?
00:37:32 <dons> jmob: you know about 'compare' though, i suppose?
00:37:40 <dons> > "foo" `compare` "foob"
00:37:41 <lambdabot>  LT
00:37:45 <dons> > "foo" `compare` "fo"
00:37:46 <lambdabot>  GT
00:38:24 <paolino> np, I understand now
00:38:44 <dons> > let strncmp n x y = let m = min (length x) (length y) in take m x `compare` take m y in strncmp 2 "fooo" "fooba"
00:38:45 <lambdabot>  GT
00:38:49 <jmob> dons: I didn't know about it, but I was writing strcmp as an exercise
00:38:59 <dons> yeah, i suspected :)
00:39:55 <dons> > let strncmp n x y = take n x `compare` take n y in strncmp 2 "fooo" "fooba"
00:39:57 <lambdabot>  EQ
00:40:05 <dons> why did i try that min thing? weird
00:40:54 <jmob> What does take and `` do?
00:41:05 <dons> turns compare into an infix function
00:41:17 <dons> > let strncmp n x y = compare (take n x) (take n y) in strncmp 2 "fooo" "fooba"
00:41:19 <lambdabot>  EQ
00:41:26 <dons> is less nice, i'd say
00:41:37 <dons> binary functions look good in infix
00:41:56 <jmob> Ah, cool.
00:42:00 <dons> > 1 `const` 2
00:42:01 <lambdabot>  1
01:10:41 <mauke> > sqrt `id` 2
01:10:43 <lambdabot>  1.4142135623730951
01:36:48 <lispy> > sqrt $ 2
01:36:49 <lambdabot>  1.4142135623730951
01:37:07 <lispy> > length `id` show 2
01:37:08 <lambdabot>  1
02:31:16 <pesco> People of #haskell, I am in need of advice! I have implemented two modules I'd like to export in a package and I don't know how to call them, wrt. to The Hierarchy.
02:31:25 <pesco> Er, three modules.
02:32:05 <pesco> So far, they are called Doc, Tixt, and DocToHTML and I'd like that to become something like Text.Doc, Text.Doc.Input.Tixt, and Text.Doc.Output.XHTML.
02:32:25 <dons> hmm. 
02:32:30 <dons> let's see what we've got in fptools
02:32:59 <pesco> I should most probably put an author-specific element somewhere in there, but where?
02:33:02 <dons> ah, but are they pretty printers?
02:33:08 <dons> or specific languages?
02:33:15 <dons> (yes, i think it needs to be more specific)
02:33:34 <pesco> Well, what _exactly_ is a pretty printer?
02:33:52 <pesco> Doc is a general data type for representing structured text documents, i.e. sections, paragraphs, emphasis, etc.
02:34:03 <dons> a Doc -> String function, and a bunch of combinators for building Docs, I suppose
02:34:12 <dons> (you know Doc is a type in Text.PrettyPrint?)
02:34:17 <pesco> Yes.
02:34:47 <dons> so this is a generic structure text lib?
02:35:10 <pesco> Yes. The Tixt module reads something like Markdown and returns a Doc.
02:35:29 <dons> Text.Something.{Doc,Tixt,HTML} would be reasonable
02:35:30 <pesco> And there's no Doc->String function in Doc.
02:35:55 <dons> where Something might be Structured or Pesco, I suppose
02:36:04 <dons> Text.Structured.Doc sounds good
02:36:16 <dons> and makes clear this isn't the same Doc as _the_ Doc
02:36:18 <dons> ?hoogle Doc
02:36:19 <lambdabot> Text.PrettyPrint.HughesPJ.Doc :: data Doc
02:36:20 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
02:36:20 <lambdabot> Language.Haskell.TH.PprLib.to_HPJ_Doc :: Doc -> Doc
02:36:45 <pesco> Yes. Doc is a very generic name.
02:36:59 <dons> it does need to be qualified, I agree
02:37:35 <pesco> Text.Structured sounds good as the overarching category.
02:37:56 <pesco> Now what about an author-specific element in there?
02:38:12 <dons> well, Structured could be all you need
02:38:29 <dons> unless its a pretty printer lib, then perhaps Text.PrettyPrint.Pesco.* :)
02:38:41 <pesco> I wouldn't call it a pretty-printer.
02:38:52 <dons> though there's some criticism of having author names in the hier path, since they say nothing about what the code _does_
02:38:59 <dons> which i'm inclined to agree with.
02:39:09 <dons> so *.HughesPJ is a bad name in hindsight
02:39:24 <pesco> Hm, point. What would you have called it instead in the face of other pretty-printers?
02:39:58 <dons> Text.PrettyPrint.SomeName, hmm, make something up?
02:40:35 <pesco> And you think it's okay if I just "grab" Text.Structured?
02:40:54 <dons> well, I'm a little hesitant. but i think its not too bad.
02:41:04 <eivuokko> Hierarchical libs doc says User./Org.-prefix for author/organisation naming.
02:41:17 <pesco> Does it?!
02:41:24 <dons> alternately, you could reuse Text.HTML and Text.PrettyPrint
02:41:27 <eivuokko> But I have never seen anyone use it.
02:41:31 <dons> placing your Doc and things underneath
02:41:32 <u221e> I'm playing around with HOpenGL but does anyone know why Vertex3 is of type Vertex3 a, instead of Vertex3 GLfloat? It's kind of annoying having to give the type checker a hint.
02:42:13 <eivuokko> It is probably because you can give graphics data in few diffrent forms that driver extends on the way to the graphics card.
02:43:35 <dons> right, and it plays with Ptrs underneath
02:43:42 <dons> (castPtr :: Ptr (Vertex3 b) -> Ptr b)
02:44:16 <dons> so presumably its paramateriable somewhere.
02:44:25 <dons> u221e: if its a problem, use a type synonym
02:44:40 <dons> type Vertex3GL = Vertex3 GLFloat
02:45:05 <pesco> eivuokko: Got a pointer to that User/Org-prefix bit in the docs?
02:45:15 <eivuokko> http://www.haskell.org/hierarchical-modules/libraries/layout.html
02:46:28 <Igloo> pesco: It's only meant for things that haven't been given a place in the "real" hierarchy, I think
02:46:38 <u221e> dons, I would have the same problem if I did that.
02:46:46 <u221e> Well... It's not really a problem.
02:47:22 <pesco> Igloo: So wouldn't that be kind of appropriate for me?
02:48:57 <Igloo> pesco: Well, you could certainly use User.* or whatever if you want
02:49:33 <pesco> And then ask on libraries@ for a proper allocation...
02:50:38 <u221e> I seem to be having trouble with recursion...
02:51:40 <u221e> It's hard trying to figure out how to make a recursion stop.
02:51:43 <dons> the first step in dealing with recursion is to deal with the recursion
02:52:15 <dons> u221e: well, usually we do inductive recursion, so you have a natural base case in the data structure you recurse over (i.e. [])
02:52:31 <dons> otherwise, if its some kind of loop, you stop at 0 or some boolean condition, like a for or while loop
02:53:59 <u221e> But what if the function needs more then one loop...
02:54:38 <dons> then the second loop needs a base case too. 
02:54:46 <dons> they all need a termination condition
02:55:23 <dons> just as when you would write a for (;;;) loop, you should work out what your start and end condition are. and if there's anything to do each time around
02:56:34 <u221e> Maybe I'm trying to make individual functions do too much?
02:57:01 <dons> yeah, that sounds a bit like it
02:57:14 <dons> simple simple simple is the best way
03:00:33 <eivuokko> Would anyone care to comment on data-type organisation on http://tamelambda.net/darcs/ia32-asm/Asm/Ia32/Base.hs (it models ia32 assembler), small, and dirty, test bit: http://tamelambda.net/small-test.hs  (the main has lists of instruction that show how they look)
03:01:06 <eivuokko> I've been trying to make writing it humanly possible, but also that it's possible to get any instruction encoding out if neccesary.
03:34:38 <johnnowak> does anyone have a link related to proving correctness for haskell program?
03:50:00 <dmhouse> pesco: pingeroo
03:50:02 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
03:50:20 <pesco> dmhouse: Pong.
03:50:23 <dmhouse> @tell dons greatification!
03:50:24 <lambdabot> Consider it noted.
03:50:53 <dmhouse> pesco: Just opened up your code for your Doc stuff.
03:51:03 <pesco> Ah.
03:51:09 <dmhouse> pesco: Why is it a literate script? You don't seem to have many comments in it :)
03:51:21 <pesco> Because I plan to add them. ;-)
03:51:41 <dmhouse> Also, the comments seem almost Haddock like. It would be trivial to just add some '|' characters in here and there.
03:52:37 <pesco> dmhouse: I guess.
03:54:00 <pesco> Right now I want to find proper names for the modules.
03:54:36 <dmhouse> pesco: It also seems that the references stuff could be automagically handled.
03:55:05 <u221e> Isn't there any difference between where and let-in besides syntax?
03:55:24 <pesco> dmhouse: What do you mean?
03:55:36 <dmhouse> u221e: There are some very subtle differences, like scope when you introduce guards.
03:56:02 <dons> johnnowak: check on haskell.org under 'Research papers'. there's a section on proving correctness
03:56:03 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
03:56:13 <dons> in practice however, we mostly use QuickCheck
03:56:24 <dons> (which can do exhaustion proofs if you're clever)
03:56:43 <dons> u221e: and 'where' isn't an expression
03:56:48 <dmhouse> pesco: I mean, you should be able to link something, give it a title (which could show up in the html 'title' attribute), mark it as a reference somehow, and then all such links would be automatically collected in a References section at the bottom of the HTML output.
03:57:21 <dmhouse> Totally off-tangent question: what's Scheme's type system?
03:57:37 <johnnowak> scheme is dynamically typed
03:58:43 <dmhouse> Yes, but how? Are things like (lambda (x) (x x)) rejected?
03:59:04 <dons> they are?
03:59:36 <dmhouse> Hrm? It was a question, dons.
03:59:44 <dons> well, if its dynamically typed, that might produce a runtime error/exception, or it might just diverge
04:00:03 <dmhouse> Exactly, I'm wondering which one :)
04:00:18 <dons> just think about delaying all the checks till the moment the code is run, and then choosing some alternative that 'makes things work' (rather than an exception)
04:00:20 <dmhouse> I would suspect the latter, if you're going to do full typechecking you may as well do it at compiletime.
04:00:42 <pesco> dmhouse: I think that's too inflexible.
04:01:35 <pesco> dmhouse: I'd rather not dictate where exactly the reference section will be, what its title will be, and what the exact contents of the individual reference entries will be.
04:03:00 <pesco> dmhouse: So I've decoupled the links from the bibentries. I think that's a very satisfactory solution.
04:03:20 <dmhouse> I suppose so.
04:04:27 <pesco> I plan to come up with some extension mechanism. Then anything more sophisticated (i.e. more BibTeX-like) coulg be implemented that way (I hope).
04:06:04 <pesco> Or maybe not. Dunno yet.
04:09:34 <dmhouse> pesco, When things are starting to get properly polished, it'd be nice to send an email to the mailing list and libraries@ as well.
04:12:21 <dmhouse> Does http://www-formal.stanford.edu/jmc/puzzles.html work for anyone?
04:12:24 <lambdabot> Title: "FORMALIZATION OF TWO PUZZLES INVOLVING KNOWLEDGE (23-Dec-1997)"
04:13:43 <dmhouse> Never mind, it works now.
04:22:56 <dmhouse> http://okmij.org/ftp/Haskell/Mr-S-P.lhs That's good fun :)
04:45:42 <pesco> dmhouse: Will do. I'm going to make the first release now.
04:46:00 <pesco> dmhouse: Which will be unpolished in the sense of lacking documentation, but hey, at least it will be a release.
04:46:15 <dmhouse> I would do documentation first.
04:52:55 <araujo> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gpp 
04:52:57 <lambdabot> Title: "Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..."
04:53:06 <araujo> GHC does even better than Ocaml!
04:54:45 <pesco> dmhouse: Okay, so I'll make a package and wait with the announcement until I have docs. That's reasonable.
05:04:34 <u221e> My brain hurts...
05:06:20 <dmhouse> u221e: why?
05:06:31 <u221e> recursion.
05:08:09 <dmhouse> u221e: What's wrong with recursion?
05:09:28 <u221e> I'm still learning so... it's hard.
05:09:37 <dmhouse> Hmm, okay.
05:09:45 <dmhouse> Anything specific we could help you out with?
05:10:23 <u221e> I don't think so.
05:10:49 <dmhouse> All right then. Do feel free to ask if you think of something :)
05:18:45 <u221e> I'm close to finishing my first little project though.
05:48:21 <dmhouse> Yay! I managed to download a wikibook!
05:53:14 <kowey> the haskell one?
05:53:29 <dmhouse> Indeed.
05:53:41 <dmhouse> Oh, hey kowey. Didn't realise you were an IRC'er too :)
05:53:54 <kowey> :-) a very occasional one
05:54:05 <kowey> i usually come for help, but sometimes like to lurk
05:54:32 <kowey> thanks for all your work on the wikibook, btw, i'm really happy to see it zoom forward like that
05:54:47 <dmhouse> So yeah, I managed it through an ugly combination of 1) grabbing the source for the main page 2) Text.JRegex'ing out all the links 3) downloading the mvs MediaWiki client 4) xargs :)
05:54:56 <dmhouse> Hehe, it's not finished yet! :)
05:55:13 <dmhouse> I want to write one or two more modules then post an email to the mailing lists plugging it.
05:55:29 <kowey> what would be awesome is if it gets so good that people actually start using it for teaching
05:55:41 <dmhouse> Yes, that's a long-term aim.
05:55:52 <dmhouse> At the moment there's quite a bit of content but it's quality isn't brilliant.
05:56:25 <kowey> right... the old wikipedia style of getting it down and hoping somebody makes it better later
05:56:32 <dmhouse> Yeah.
05:57:02 <dmhouse> I think a lot of the introductory articles could stand up to some improvement.
05:58:21 <dmhouse> I want to overhaul the 'Basic concepts' section, but I'm not sure what to write
05:58:40 <dmhouse> Perhaps split it and cover the basics of the type system in more detail.
06:00:44 <kowey> i suppose it depends on what our target audience is
06:01:15 <kowey> there's a lot of high quality tutorials out there, but they all seem to aim high, so what I figure is that
06:01:35 <kowey> wikibooks could make a difference by targeting newbies better
06:01:43 <kowey> the question being, what kind of newbie?
06:02:06 <dmhouse> Hrm.
06:02:50 <kowey> in any case, i think a distinguishing feature (or bug depending on taste) of the wikibook should be that it goes very slowly
06:03:11 <paolino> http://okmij.org/ftp/Haskell/ , thanks dmhouse
06:03:12 <kowey> this might frustrate some people, but they are already well served by pre-existing stuff
06:03:13 <lambdabot> Title: "Haskell Programming: Miscellanea"
06:03:51 <dmhouse> paolino: Sorry?
06:05:03 <dmhouse> paolino: What about that page?
06:05:29 <dmhouse> kowey: we'll see.
06:05:48 <dmhouse> The beauty of a wiki is that it can always be hacked about to see if it gets better. :)
06:06:15 <dmhouse> By the way, I was thinking we could do with a template for Haskell examples.
06:06:22 <kowey> always an interesting new direction around the corner indeed
06:06:29 <kowey> you mean instead of just using pre?
06:06:49 <dmhouse> Well, the template would probably use pre.
06:07:12 <dmhouse> But it'd be fun if all the examples in the book could be visually consistent.
06:07:16 <dmhouse> Like the exercises are.
06:07:34 * kowey tries
06:09:36 <kowey> http://en.wikibooks.org/wiki/Template:ExampleCode
06:09:50 <kowey> hmm... i wonder if there's a way to control how a pre block is displayed in mediawiki
06:10:04 <kowey> (this is just a copy of Template:Example, btw)
06:10:06 <dmhouse> Yeah, I saw that, but it's kind of ugly.
06:10:18 <dmhouse> We might want to have a HaskellExample.
06:10:28 <dmhouse> Or Haskell/Example, however one should do i.
06:10:29 <dmhouse> *it
06:12:52 <kowey> something like this?
06:12:55 <kowey> http://en.wikibooks.org/wiki/Template:HaskellExample
06:13:22 <dmhouse> Hrm
06:14:36 <dmhouse> kowey: How does it look now?
06:15:16 <kowey> a tad wide :-)
06:15:34 <int-e> far too wide. can't you use width=100% there?
06:15:47 <dmhouse> How about now?
06:16:12 <int-e> absolute widths are evil.
06:16:22 <dmhouse> Okay, no more width.
06:17:30 <dmhouse> Try now.
06:18:08 <dmhouse> Now if we could get a cute graphic in there...
06:18:49 <dmhouse> Like that?
06:19:57 <int-e> I like that better now.
06:19:58 <kowey> i dunno... we're going to be using a *lot* of examples... i wonder if we have any more discrete cute graphics in stock
06:20:06 <kowey> (it is better though)
06:20:49 <dmhouse> Can you get a listing of a specific namespace?
06:21:27 <kowey> the search functionality lets you select namespaces, i think
06:23:34 * kowey slaps his forehead
06:23:46 <kowey> of course, the {{{3}}} is being interpreted literally by the pre tag
06:24:46 <dmhouse> Why?
06:24:55 <dmhouse> <pre> isn't special to MediaWiki, is it?
06:26:43 <kowey> i guess mediawiki doesn't look inside the pre tags when interpreting templates
06:27:13 <kowey> but, maybe that's ok, maybe we should just include the pre ourselves when using it
06:27:37 <kowey> that would allow the template to be used for non-code stuff (what stuff, i cannot fathom)
06:28:07 <dmhouse> Okay.
06:28:09 <dmhouse> Let's do that.
06:34:26 <kowey> dmhouse: how about now? http://en.wikibooks.org/wiki/Haskell/Basic_Concepts
06:34:36 <kowey> as you can see, i'm experimenting with not having a title
06:35:06 <dmhouse> Hmm
06:35:22 <dmhouse> Yeah, I think that's okay.
06:36:07 <kowey> only thing we need to figure out now is the funny indentation
06:37:35 <dmhouse> Might be because of the graphic.
06:38:14 <dmhouse> Yeah, I suggest we pad the top of the pre so it doesn't get in the way.
06:39:53 <dmhouse> kowey: Try it now.
06:40:02 <u221e> My mandelbrot fractal works :)
06:40:08 <kowey> another thing we could try is moving the graphic to the right
06:40:40 <kowey> in any case, aye, the padding works
06:41:58 <dons> u221e: cool :)
06:43:52 <u221e> It's soooo slow though :P
06:45:28 <dons> you using ghc?
06:45:34 <dons> compiling with -O ?
06:45:48 <dons> using arrays of Double? and -optc-ffast-math?
06:45:59 <dons> let me find you a fast mandelbrot in haskell
06:46:22 <u221e> -optc-ffast-math?
06:46:37 <dons> here's a fairly quick one: http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&id=2
06:46:40 <lambdabot> Title: "mandelbrot Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Co ..."
06:46:48 <dons> (well, by that I mean as quick as we know how to write)
06:47:22 <dons> no real tricks, and its slowed down by the requirements of the benchmarks
06:47:35 <dons> ideally you'd write the bytes directly into a bytestring, and dump that out.
06:48:04 <dons> do you want a quick lesson in how to find out which part of your haskell code is slowest?
06:49:01 <u221e> Sure.
06:49:12 <u221e> -O made a big difference by the way
06:49:21 <dons> ok, compile your program with ghc -O -prof -auto-all
06:49:32 <dons> and then run it with: ./a.out +RTS -p -RTS
06:49:44 <dons> profiling output will go into a.out.prof, a new file
06:50:01 <dons> if you look at that file, there's a list of the slowest functions, and the amount of memory allocated by them as well
06:50:16 <dons> which helps you concentrate on what's actually the slowest part of the code
06:50:16 <kowey> dmhouse: have templatified all examples on Basic_Concepts
06:50:50 <u221e> Failed to load interface for `Prelude'
06:50:52 <u221e> ?
06:51:09 <dons> oh, you mustn't have the profiling versions of the libraries installed
06:51:19 <dons> you're out of luck :/ 
06:51:44 <u221e> No, I'm using ubuntu so it should be a simple fix
06:51:52 <cjay> moin
06:51:58 <dons> perhaps ghc for your os/distro doesn't include the profiling libs by default? so you need to ask for them especially
06:52:22 <dons> yeah, use apt-get blah blah or however ubuntu does it
06:52:48 <u221e> Ok, all fixed ;)
06:52:57 <dons> oh, cool!
06:53:09 <dons> yeah, so , compile with -O -prof -auto-all
06:53:13 <u221e> The Synaptic Package Manager is great
06:53:47 <Lemmih> @karma+ SynapticPackageManager
06:53:48 <lambdabot> SynapticPackageManager's karma raised to 1.
06:55:13 <u221e> Hm... my .prof file is empy
06:55:16 <u221e> empty
06:55:47 <dons> you ran it with +RTS -p -RTS ?
06:56:47 <u221e> Yes. Does the program have to exit normal? Right now i'm just killing the process
06:56:55 <dons> ah, it does have to exit normally
06:57:20 <dons> and not using System.Posix.Process.exitImmediately either.
06:59:00 <dons> I'm sure there's some wise saying about optimising a man's code, and he has fast code for a day, teach him to profile, and something something something...
06:59:30 <Igloo> I thought these days a profile was generated even on exceptional exits
07:00:00 <dons> I think signals and exitImmediatly still cause nothing to be emitted. perhaps 6.5 changed this?
07:00:25 <Igloo> I'm fairly sure you can even watch the profile being generated in real time
07:00:32 <Igloo> In 6.4 too
07:00:37 <dons> yeah, there's a magic flag for that
07:00:50 <int-e> dons: give a man a program and he's frustrated for a day, teach him to code and he's frustrated for his entire life. that one? ;-)
07:01:00 <dons> using a different prof format for viewing code in uDrawGraph, igloo
07:01:10 <dons> hehe, yesh, that one int-e
07:03:06 <dons> u221e: how you going?
07:03:18 <u221e> Trying to figure out how to exit from GLUT
07:03:31 <u221e> the only "recent" tutorial doesn't say.
07:03:42 <Igloo> dons: No, with the normal profiling stuff, as per http://www.haskell.org/ghc/docs/latest/html/users_guide/hp2ps.html#id3137970
07:03:43 <lambdabot> Title: "5.6. hp2ps&#8211;&#8211;heap profile to PostScript"
07:04:20 <dons> ah. leaveMainLoop :: IO () ?
07:05:06 <dons> oh, yes. I've used that actually, with hmp3, to watch it over many hours.
07:05:16 <u221e> Heh, thanks.
07:05:53 <dons> (/me just grepped for 'exit' in the GLUT src)
07:06:16 <dons> -- If the application has two nested calls to 'mainLoop' and calls
07:06:17 <dons> -- 'leaveMainLoop', the behaviour is undefined. It may leave only the inner
07:06:17 <dons> -- nested loop or it may leave both loops. If the reader has a strong preference
07:06:18 <u221e> Hm, .prof is still empty
07:06:20 <dons> -- for one behaviour over the other he should contact the freeglut Programming
07:06:22 <dons> -- Consortium and ask for the code to be fixed.
07:07:21 <dons> hmm. you could insert an early exitSuccess to check your program does actually exit (before starting up glut, perhaps)
07:10:30 <u221e> Got it working.
07:10:57 <dons> cool. any useful info?
07:11:10 <u221e> I resorted to never entering the mainLoop and just manually calling the display callback once
07:12:11 <u221e> What does enteries mean?
07:13:13 <jgrimes> @hoogle Day
07:13:15 <lambdabot> System.Time.Day :: data Day
07:13:15 <lambdabot> System.Time.Friday :: Day
07:13:15 <lambdabot> System.Time.Monday :: Day
07:13:28 <jgrimes> interesting...
07:13:46 <dons>  The number of times this particular point in the call graph was entered.
07:13:54 <u221e> 98 percent of the time and allocation is spent in my iteration function
07:14:27 <dons> perhaps its numerically expensive, or maybe there's a space leak?
07:15:10 <dons> now, you can annotate individual expressions in your function to find out how much each line costs
07:15:20 <dons> say you have: f <- some expr
07:15:24 <dons> inside a function,
07:15:33 <dons> you can find out exactly how much that costs via:
07:15:43 <dons> f <- {-# SCC "some expr" #-} some expr
07:16:44 <dons> the SCC pragma lets you tag a cost centre, and it get displayed in the prof output
07:18:35 <u221e> Over 1 GB of total alloc...
07:18:47 <dons> oh, that's kind of insane :) sounds like a bad space leak
07:18:59 <dons> or a really inefficient data type?
07:19:55 <dons> how are you representing points on the plane? are they coloured?
07:20:20 <u221e> Yes
07:20:45 <dons> so something like: data Point = Point !Double !Double !Double ?
07:21:25 <dons> other issues are raised http://www.haskell.org/haskellwiki/Performance
07:21:27 <lambdabot> Title: "Performance - HaskellWiki"
07:22:01 <dons> you might look to ensure that arguments to recursive loops (particularly numbers) are strict
07:22:06 <u221e> No, a list of (GLfloat, GLfloat, Color4 GLfloat) tuples
07:22:16 <kpreid> dons: something I'm thinking of for lambdabot is to make all the printing of commands go through something that knows what the prefixes are, so it doesn't say @foo when @ isn't a command prefix. any thoughts on how that should work?
07:22:51 <dons> the printing of commands?
07:22:58 <dons> like in @help ?
07:23:04 <kpreid> @help
07:23:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:23:11 <kpreid> hm
07:23:16 <kpreid> I know there are examples somewhere
07:23:22 <dons> (i know there are some docs that presume @)
07:23:36 <kpreid> @poll-show
07:23:38 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
07:23:41 <kpreid> example there
07:23:42 <dons> well, hmm, one way would be to translate all help strings, expanding the @
07:23:57 <dons> not sure if its a high priority though :)
07:24:11 <dons> the _right way_ would be to use a data type to represent Cmd
07:24:23 <dons> and then help strings would have to be Docs
07:24:28 <dons> but that's too heavy i think
07:24:54 <kpreid> nasty bit: to do it *right*, you need to know whether lambdabot is running in offline mode and put in no prefix
07:25:29 <dons> or perhaps just adopt a convention not to use any prefix in any help string?
07:25:40 <dons> well, we know what mode we're in, i think
07:25:48 <dons> at least, it would be possible to know
07:25:59 <kpreid> sure, but it just means you can't have showCommand :: String -> String
07:26:03 <dons> right
07:26:08 <dons> it needs to be in LB
07:26:19 <kpreid> showCommand = (head $ commandPrefixes config ++)
07:26:49 <dons> yeah
07:28:46 <u221e> Wow, the shootout mandelbrot example isn't very readable ;P
07:28:58 <dons> no it kind of got a bit silly, i suppose
07:29:08 <dons> its fast though
07:29:36 <dons> the original C++ (I think) it was translated from was worse, I recall
07:29:51 <dons> the algorithm is kind of gross
07:29:57 <dons> all the byte-at-a-time hackery
07:30:00 <u221e> Does the shootout website usually dump the entire program output on the code page?
07:30:05 <dons> yes
07:30:09 <dons> usually it isn't a bitmap
07:31:16 <dons> here's one i'm proud of, http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
07:31:18 <lambdabot> Title: "partial-sums benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..."
07:31:40 <dons> ghc really kicks butt there, without too much ubermagicks
07:32:30 * dons -> night
07:33:03 <u221e> Is Is ghc 6.4.2 much better then 6.4.1?
08:07:04 <dmhouse> kowey: still around?
08:07:12 <kowey> yep
08:07:32 <dmhouse> kowey: What were you trying to say just as I was leaving?
08:08:13 <kowey> dmhouse: just that i had updated the basic concepts page with the new template (to show what it did)
08:08:26 <dmhouse> Ah, cool. Looks good.
08:08:40 <dmhouse> I didn't destroy your changes with my <code> updates, did I? Does MediaWiki merge edits?
08:10:18 <kowey> seems to have gone through ok
08:11:40 <dmhouse> Okay.
08:21:15 <dmhouse> kowey: Have you got a few minutes? I think we should start brainstorming changes to make to the Basic Concepts page.
08:21:36 <kowey> sounds good
08:21:51 * kowey checks the history first
08:22:16 <dmhouse> Firstly I think we should rip out that stuff about tail recursion. It's much to in-depth for that level.
08:22:28 <kowey> yeah seriously!
08:22:53 <kowey> i'd go even further we seem to expect the reader to know what recursion is... that might not be such a good idea
08:23:01 <dmhouse> We can say something like: 'All this recursion doesn't break the stack because of something called ''tail recursion optimisation'', we will cover that in later chapters'.
08:23:07 <dmhouse> Indeed.
08:23:24 <kowey> in fact... who wrote this chapter? paul? would be neat if he were on irc too
08:23:49 <dmhouse> It's down as an IP.
08:24:09 <dmhouse> We might also want to say at some point about how lists are used as well as recursion for similar effects to loops.
08:24:24 <dmhouse> E.g. factorial n = product [1..n]
08:26:00 <dmhouse> And I think we should have a whole chapter on types.
08:26:07 <dmhouse> I think the main faults of that page are:
08:26:22 <dmhouse> 1) Bad focus on what Haskell's about
08:26:35 <dmhouse> 2) Assumes too much of the reader (recursion, types).
08:27:33 <dmhouse> A better introduction wouldn't spend so much time talking about how to emulate other languages.
08:28:08 <dmhouse> I know newcomers struggle with the lack of loops -- I did -- but I don't think that's sufficient reason to dedicate the entire 'Basic concepts' chapter to overcoming it.
08:28:14 <kowey> i think it would be fair to write this book as if the reader has never programmed before
08:28:19 <dmhouse> Agreed.
08:29:02 <dmhouse> Perhaps we could change this into a brief chapter explaining the _very_ basics -- arithmetic and so forth, before outlining the rest of the book, or at least the rest of the first section of the bookl
08:29:06 <dmhouse> *book.
08:29:26 <kowey> a brief romp through the interpreter?
08:29:36 <kowey> try this! now see what happens what you try that?
08:29:44 <dmhouse> That could be nice.
08:29:52 <dmhouse> That's how, for example, YAHT starts.
08:29:57 <dmhouse> The entire first chapter is all in GHCi.
08:30:17 <kowey> incidentally, hal daume is going to the same conference in australia i am on the 14th
08:30:31 <kowey> if i'm lucky, maybe i'll meet him and convince him to donate yaht to wikibooks :-)
08:30:37 <dmhouse> Ah, nice :)
08:30:37 <kosmikus> which conference?
08:30:46 <dmhouse> Tell him to finish the damn tutorial too! :)
08:31:08 <dmhouse> I think YAHT is a great tutorial for beginners but woefully lacking in any kind of advanced topics.
08:31:10 <kowey> http://www.acl2006.mq.edu.au/ (acl - computational linguistics)
08:31:12 <lambdabot> Title: "Welcome to the COLING•ACL 2006 web site | COLING•ACL 2006"
08:31:28 <kosmikus> sounds interesting
08:31:38 <dmhouse> My vision for the Wikibook is that it'll cover the advanced topics really well too :)
08:31:39 <kowey> (i say this because i saw his name on one of the talks)
08:32:03 <kowey> yes... i like the idea of wikibooks making the really advanced stuff surprisingly easy to understand
08:32:12 <kosmikus> just tell hal to place his text in the public domain, so that it can be reused for other projects :)
08:32:15 <dmhouse> There are lots of minitutorials covering different parts of advanced functional programming, but it'd be great if we could lump them all together and have them all interrelated.
08:32:32 <dmhouse> For some topics there's nothing but the GHC user manual, for others, there's nothing at all.
08:32:47 <dmhouse> Apart from the papers where they were introduced, which aren't that accessible to a lot of people :)
08:33:48 * kowey is still working on the scheme in 48 import
08:33:59 <dmhouse> Yeah, that chapter need extreme cleanup.
08:34:02 <kowey> need to convert html to wiki syntax and figure out how to massage it in
08:34:07 <kosmikus> dmhouse: you're right. documentation on advanced features is lacking.
08:34:39 <dmhouse> kosmikus: http://en.wikibooks.org/wiki/Haskell/To_do#Stubs feel free :)
08:35:38 <kowey> well... actually, we could probably be more organised about this, sort of a haskell wikibooks PR campaign
08:35:53 <kowey> what i mean is that we already have a history of reaching out and asking authors if we could import their stuff
08:36:16 <kowey> what might be fun is we got in touch with experts on subjects and had them write tutorials within the framework of our book
08:36:53 <dmhouse> They'd have to be ready for their work to be nipped and tucked, though, which some might not like.
08:37:11 <kowey> although then again, the problem with experts also, is that they're way too far ahead of the rest of us
08:37:45 <kowey> yeah, not everyone's into the whole lack-of-control thing
08:37:56 <dmhouse> Experts have to be good at explaining to other experts. Some experts also happen to be good at explaining to the mere mortals, but it's not a necessary condition for expertise.
08:38:58 <kowey> hmm... we might be straying here :-) so about those basic concepts...
08:39:23 <dmhouse> Quite. :)
08:39:57 <kosmikus> dmhouse: I currently have enough projects I'm working on; maybe at a later point.
08:40:13 <dmhouse> kosmikus: That's fine. Do drop by any time :)
08:41:09 <dmhouse> kowey: We now have a 'Type basics chapter'.
08:41:48 <kowey> oh! by now, you meant just a few seconds ago
08:42:08 <dmhouse> Right, I added it then told you :)
08:44:00 <dmhouse> I'm going to start writing that section.
08:44:11 <dmhouse> I moved the stuff from Basic Concepts into there, but I'm not sure how much I'll keep.
08:45:15 <kowey> i remember when teaching ocaml, that types was REALLY hard for me to get across
08:45:26 <dmhouse> We'll see.
08:49:33 <kowey> hmm... so one interesting thing is that we say you can't reassign variables, but
08:50:04 <kowey> if we go through the romp-through-interpreter approach, the user might notice that you can (you know what i mean)
08:51:22 <dmhouse> Then we'll introduce the variables-don't-change at a later date
08:51:25 <dmhouse> Or indeed not at all.
08:51:31 <dmhouse> There's no need to state it up front.
08:51:46 <kowey> or maybe we could just make the reader type stuff into a text file
08:51:48 <kowey> and use :r
08:51:49 <dmhouse> It's just a consequence of the way you tend to program with Haskell, it's not a key language choice.
08:52:12 <dmhouse> I prefer the GHCi approach.
08:52:23 <kowey> ok... yeah besides
08:52:44 <kowey> like "why fp matters" points out... it's not so nice to start out with what we _can't_ do
08:52:53 <kosmikus> "variables-don't-change" is not a key language choice?
08:53:00 <kowey> even though we think of not-changing as a feature
08:53:38 <dmhouse> kosmikus: Well, ish.
08:54:27 <dmhouse> kosmikus: I'd say the key language choice is no specified order of evaluation. Variables not changing is a corollary.
09:03:21 <kowey> hmm... so the getting set up chapter goes through some basic arithmetic
09:03:33 <kowey> what kind of points would we want to cover from there?
09:04:05 <dmhouse> Just get people accustomed to GHCi, then move on to functions.
09:04:33 <kowey> ok, give them some small things to play with, one or two exercises and then functions
09:04:35 <dmhouse> You might want to try a mathematical analogy, or a physical analogy ('You put a value in one end of a black box, and get the result out at the other end').
09:05:04 <dmhouse> Needless to say, start with easy ones like double x = x * 2
09:05:08 <dmhouse> Some images might help here.
09:05:15 <kowey> so basic concepts will still be variables and functions
09:05:18 <kowey> just... basic
09:05:28 <dmhouse> I think so.
09:05:30 <kowey> like, for example, not insisting on the whole referential transparency thing :-)
09:05:39 <dmhouse> Right.
09:05:58 <dmhouse> Don't mention words above two syllables in the first introductory sentence :)
09:08:06 <fasta> If you take an extreme view, Haskell is as referential transparant as C, so there is no need to point that out. 
09:08:19 <mikael> huh?
09:08:58 <dmhouse> fasta: C isn't very referentially transparent...
09:10:04 <eivuokko> Isn't that is so extreme view that it makes whole idea unuseful.
09:10:20 <fasta> dmhouse: C contains features to break referential transparancy, Haskell does too. It's just that you are very much encouraged to program in a referential transparant way in Haskell, but nobody is _forcing_ you to do so. It's more of hard push in that direction in Haskell.  
09:10:32 <fasta> eivuokko: possibly
09:10:35 <mikael> no, haskell contains no such features
09:11:03 <mikael> ghci and hugs have features like that, but the standard doesn't!
09:11:17 <dmhouse> fasta: The difference is that Haskell provides them via esoteric compiler extensions, whereas they're deeply ingrained into C.
09:12:05 <dmhouse> But, for example, we might also want to call Haskell a statically typed language. And yet we can emulate dynamic typing.
09:12:24 <dmhouse> So as eivuokko says, your claim makes the idea of referential transparency not very powerful.
09:14:59 <fasta> dmhouse: maybe I am not right, since I can't find an "escape"(to break ref. transp.) in Haskell98, while all the implementations do have escapes. 
09:22:41 <ihope> So with -fno-monomorphism-restriction, can a person do the fancy unsafeCoerce# thing entirely with monadic IO?
09:23:06 <ihope> a -> IO b, that is?
09:25:10 <Igloo> If you allow things like casting pointers then you can write that function, but -fno-monomorphism-restriction doesn't help
09:26:13 <ihope> So if I have an IORef made from undefined, writing to it makes it monomorphic or whatever?
09:26:16 <kosmikus> fasta: the FFI is an accepted standard extension of Haskell98 and contains unsafePerformIO
09:27:21 <Igloo> Lambda bindings are monomorphic, unrelated to the monomorphism restriction
09:27:43 <Igloo> And do notation desugars into something that would lambda bind the IORef
09:28:30 <droundy> Anyone here have experience with DAGs as data structures?
09:28:32 <Igloo> (you might be able to make a polymorphic ioref by annotating it with a type signature and turning on suitable extensions)
09:38:53 <mikael> i think something like http://brockman.se/~mikael/io.txt is necessary as an introduction to I/O, instead of starting it out by talking about "obscure mathematical concepts" like monads
09:39:31 <mikael> because really, isn't I/O being monadic pretty tangental?  it's just a convenient interface that happens to fit and be kinda useful
09:39:50 <dmhouse> Hah, I doubt if one twentieth of the people in here understand the mathematics behind monads.
09:40:14 <mikael> I think the most important thing to understand is that there isn't really much to understand
09:40:19 <mikael> but that's probably because I don't understand.
09:40:23 <mauke> oh, there's mathematics behind it?
09:40:57 <dmhouse> Sure, they're an entity from Category Theory. But as you said, they're fairly esoteric.
09:40:59 <mikael> (I seem to recall some big shot like simon marlow or SPJ saying they weren't even sure IO fulfilled the monadic axioms...)
09:43:11 <kowey> dmhouse: started writing a ghci-based intro to variables and functions... thoughts?
09:43:15 <dmhouse> mikael: I'm not sure I follow your analogy.
09:43:22 <dmhouse> mikael: Re that page you linked to.
09:43:46 <mikael> the apple pie analogy?
09:43:54 <dmhouse> And never use the words 'clearly' or 'obviously' in a text aimed at beginners.
09:44:05 <dmhouse> Show _how_ and _why_ it invalidates purity.
09:44:28 <mikael> er, yes, whoops, that's one of my pet peeves too :-)
09:45:06 <dmhouse> Use a cat-like program to explain how it invalidates ref transp, perhaps. (cat as in Unix cat.)
09:45:13 <dmhouse> kowey: What have you got so far?
09:45:37 <dmhouse> Oh, I see it :)
09:45:48 <kowey> might be a bit... eh... heavy
09:46:43 <mikael> still, this isn't really meant as an easy text for beginners, it's more like me asserting how I think haskell I/O should be taught :-)
09:47:22 <dmhouse> mikael: Really? Sentences like 'Get that out of _your_ head' don't fit in with that.
09:47:31 <dmhouse> kowey: I like your pi analogy.
09:47:39 <dmhouse> > pi
09:47:46 <lambdabot>  3.141592653589793
09:47:50 <dmhouse> kowey: Well, not analogy, example.
09:47:55 <mikael> the text is a rough example of how I/O should be taught...
09:48:04 <bolrod> > pi*pi
09:48:06 <dmhouse> kowey: But are you sure the digits are truncated?
09:48:06 <lambdabot>  9.869604401089358
09:48:09 <dmhouse> mikael: Ah, okay.
09:48:15 <kowey> oh, built-in! (learn something new every day)
09:48:34 <dmhouse> Oh, you weren't using the built-in pi, never mind.
09:48:36 <kowey> eh... no, but i tried doing some arithmetic with it, like subtracting the truncated value and then dividing by that
09:48:41 <dmhouse> @type pi
09:48:41 <kowey> right
09:48:43 <lambdabot> forall a. (Floating a) => a
09:48:56 <dmhouse> > pi - 3.141592653589793
09:48:58 <lambdabot>  0.0
09:49:10 <dmhouse> > (pi * 10^9) - (3.141592653589793 * 10^9)
09:49:12 <lambdabot>  0.0
09:49:23 <dmhouse> Hmm. I think pi is exactly what was stated.
09:49:32 <kowey> > 1 / (pi - 3.141592653589793)
09:49:34 <lambdabot>  Infinity
09:49:41 <kowey> 1 / (pi - pi)
09:49:41 <dmhouse> Bleh.
09:49:44 <kowey> > 1 / (pi - pi)
09:49:47 <lambdabot>  Infinity
09:49:51 <kowey> hmm
09:50:07 <kowey> > 1/0
09:50:09 <lambdabot>  Infinity
09:50:46 <bolrod> 1/0 = infinity ?
09:50:47 <bolrod> O_o
09:50:48 <krypton> > pi
09:50:49 <lambdabot>  3.141592653589793
09:50:51 <dmhouse> bolrod: I know.
09:51:03 <cjay> so there is no arbitrary-precision-float-type?
09:51:03 <dmhouse> bolrod: Apparently it's a POSIX thing or some other stupid standard.
09:51:04 <krypton> > 1/0 * pi
09:51:05 <lambdabot>  Infinity
09:51:16 <dmhouse> @type (1/0)
09:51:18 <lambdabot> forall a. (Fractional a) => a
09:51:24 <krypton> > 0 * pi
09:51:26 <lambdabot>  0.0
09:51:26 <neologism> > 1/pi * pi
09:51:28 <lambdabot>  1.0
09:51:39 <krypton> hmm
09:51:45 <dmhouse> So, what, data Fractional a = a % a | Infinity | NegativeInfinity?
09:51:51 <dmhouse> s/%/:%/
09:52:01 <krypton> seem he doing from right to left
09:52:02 <bolrod> I don't think so
09:52:12 <dmhouse> > 1 `div` 0
09:52:14 <lambdabot>  Exception: divide by zero
09:52:25 <bolrod> that's better
09:52:26 <dmhouse> Oh, Fractional's a class.
09:52:31 <krypton> > 0 / 1 / 0
09:52:32 <lambdabot>  NaN
09:52:36 <krypton> ?
09:52:38 <bolrod> > 1/0
09:52:40 <lambdabot>  Infinity
09:52:41 <bolrod> > 0/1
09:52:43 <lambdabot>  0.0
09:52:47 <bolrod> > 0/0
09:52:49 <lambdabot>  NaN
09:52:53 <bolrod> righto
09:52:55 <krypton> > 0 / 1 / 0
09:52:56 <lambdabot>  NaN
09:53:01 <bolrod> 1/-0
09:53:02 <krypton> > 2 / 1 / 2
09:53:04 <lambdabot>  1.0
09:53:07 <bolrod> > 1/-0
09:53:08 <krypton> hmm
09:53:09 <lambdabot>  Not in scope: `/-'
09:53:13 <bolrod> > 1/(-0)
09:53:16 <lambdabot>  -Infinity
09:53:21 <bolrod> :]
09:53:22 <krypton> 2 / 1/2
09:53:22 * kowey uses fewer digits for pi
09:53:41 <krypton> > pi - 3.14
09:53:42 <lambdabot>  1.5926535897929917e-3
09:53:47 <krypton> o_0
09:53:51 <bolrod> what?
09:54:10 <krypton> big number....
09:54:12 <kowey> (unless somebody can reassure me that let pi = 3.14159265358979323846264338327950 actually works)
09:54:16 <dmhouse> krypton: pi /= 3.14
09:54:22 <dmhouse> kowey: Well, let's see.
09:54:24 <dmhouse> > pi * pi
09:54:26 <krypton> dmhouse: i know
09:54:26 <lambdabot>  9.869604401089358
09:54:41 <ruffneck> it's about right at least the 25 first decimals ;P
09:54:41 <dmhouse> > p
09:54:42 <lambdabot>  Not in scope: `p'
09:54:43 <dmhouse> > pi
09:54:45 <lambdabot>  3.141592653589793
09:55:03 <dmhouse> Notice how pi ends in a '3', but pi^2 ends in an '8', not a '9'.
09:55:14 <dmhouse> So either (*) isn't exact, or pi isn't exactly that.
09:55:20 <bolrod> you could do    pi = (3,14159265358979323846264338327950)
09:55:21 <krypton> > pi^3
09:55:23 <lambdabot>  31.006276680299816
09:55:30 <krypton> > pi^4/pi
09:55:31 <lambdabot>  31.00627668029982
09:55:37 <bolrod> @type (3,14159265358979323846264338327950)
09:55:39 <krypton> hmm
09:55:39 <lambdabot> forall a b. (Num a, Num b) => (a, b)
09:55:47 <dmhouse> @type pi * pi
09:55:49 <lambdabot> forall a. (Floating a) => a
09:55:52 <krypton> > pi^5
09:55:53 <lambdabot>  306.0196847852814
09:56:03 <Stinger_> > toRational pi
09:56:05 <lambdabot>  884279719003555%281474976710656
09:56:18 <bolrod> omg!  that shouldn't be possible!
09:56:20 <krypton> > (pi^4)*pi
09:56:21 <lambdabot>  306.0196847852814
09:56:21 <bolrod> hehe ;p
09:56:26 <Stinger_> hah
09:56:39 <kowey> oh!
09:56:41 <kowey> >pi * 10
09:56:44 <Stinger_> mathematics as we know it suddeny breaks down due to haskell
09:56:50 <krypton> > (pi^4)/(pi^4)
09:56:51 <lambdabot>  1.0
09:56:52 <bolrod> haha :)
09:56:54 <krypton> good one
09:56:56 <krypton> :P
09:57:21 <krypton> how to "sqrt" the number?
09:57:28 <krypton> > sqrt 4
09:57:29 <lambdabot>  2.0
09:57:32 <krypton> oh
09:57:34 <krypton> how simple
09:57:35 <krypton> :P
09:57:36 <bolrod> indeed
09:57:40 <krypton> > sqrt pi
09:57:41 <lambdabot>  1.7724538509055159
09:58:01 <kowey> > pi * 1000
09:58:03 <lambdabot>  3141.592653589793
09:58:09 <dmhouse> > 4 ^ (1/2)
09:58:11 <lambdabot>  Add a type signature
09:58:12 <krypton> > sqrt (pi^4)/(pi^2)
09:58:13 <lambdabot>  1.0
09:58:16 <dmhouse> > 4 ^^ (1/2)
09:58:17 <lambdabot>  Add a type signature
09:58:20 <dmhouse> > 4 ** (1/2)
09:58:21 <krypton> hmm
09:58:22 <lambdabot>  2.0
09:58:31 <Stinger_> > 4 ^ (1%2)
09:58:32 <lambdabot>  add an instance declaration for (Integral (Ratio a))
09:58:32 <lambdabot>   In the definition ...
09:58:35 <dmhouse> Exponentaion is too complex in Haskell.
09:58:38 <Stinger_> hehe ok
09:58:39 <krypton> |185427|           krypton  | > sqrt (pi^4)/(pi^2)
09:58:39 <krypton> |185428|         lambdabot  |  1.0
09:58:48 <bolrod> > 4**(1/3)
09:58:49 <krypton> result sholudn't be pi?
09:58:50 <lambdabot>  1.5874010519681994
09:58:59 <bolrod> > 4**(2/3)
09:59:02 <lambdabot>  2.519842099789746
09:59:15 <krypton> > sqrt (pi^2)
09:59:16 <lambdabot>  3.141592653589793
09:59:20 <bolrod> -.-
09:59:30 <dmhouse> > sqrt ((pi^4)/(pi^2))
09:59:32 <lambdabot>  3.141592653589793
09:59:33 <pesco> Anybody here who can comment on the current state of cabal-get/put?
09:59:34 <krypton> > (pi^4)/(pi^2)
09:59:35 <lambdabot>  9.869604401089358
09:59:46 <dmhouse> pesco: It's xerox's SoC project.
09:59:48 <bolrod> xerox ? :)
09:59:50 <krypton> hmm
09:59:59 * kowey is reassured
09:59:59 <pesco> dmhouse: Oh! :)
10:00:01 <dmhouse> krypton: Function application binds tighter than anything else.
10:00:07 <kowey> > pi * 1000 - 3141
10:00:09 <lambdabot>  0.592653589792917
10:00:15 <kowey> more digits
10:00:20 <krypton> dmhouse: i see
10:00:24 <dmhouse> kowey: Ah, nice.
10:00:28 <dmhouse> I wonder how many more.
10:00:42 <Stinger_> hehe pi is implemented with some algo that lazily computes digits ;)
10:00:53 <krypton> > pi*(31337/666)^1024
10:00:54 <lambdabot>  Infinity
10:00:57 <krypton> :/
10:01:06 <krypton> > pi*(31337/666)^2
10:01:07 <lambdabot>  6955.306127163137
10:01:13 <krypton> > pi*(31337/666)^10
10:01:15 <lambdabot>  1.671020419870411e17
10:01:19 <dmhouse> > pi * 10^15 - 3141592653589793
10:01:21 <lambdabot>  0.0
10:01:29 <dmhouse> > pi * 10^14 - 314159265358979.3
10:01:31 <bolrod> > pi * 1000 - 3141592653
10:01:32 <lambdabot>  0.0
10:01:33 <lambdabot>  -3.1415895114073462e9
10:01:38 <bolrod> > pi * 1000000000 - 3141592653
10:01:40 <lambdabot>  0.5897932052612305
10:01:55 <bolrod> > pi * 1000000000000 - 3141592653000
10:01:58 <lambdabot>  589.79296875
10:02:05 <krypton> > (pi^2)-((pi^2)^2)
10:02:05 <lambdabot>  -87.53948663291307
10:02:12 <krypton> o_0
10:02:27 <bolrod> > 909 - 808
10:02:29 <krypton> > (pi^2)^2
10:02:29 <lambdabot>  101
10:02:30 <lambdabot>  97.40909103400243
10:02:51 <krypton> > sqrt ((pi^2)^2)
10:02:52 <lambdabot>  9.869604401089358
10:03:03 <krypton> seems to be good
10:03:09 <bolrod> ofcourse.. what else would it do
10:03:37 <krypton> > 2^pi
10:03:37 <lambdabot>  Add a type signature
10:03:47 <bolrod> I hate screaming kids
10:03:47 <krypton> hmm
10:03:52 <krypton> :))
10:03:55 <bolrod> @type 2^pi
10:03:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:03:57 <lambdabot>    `Floating a' arising from use of `pi' at <interactive>:1:2-3
10:04:23 <Stinger_> @type pi
10:04:25 <lambdabot> forall a. (Floating a) => a
10:04:35 <bolrod> oh.. they're in a boat...
10:04:39 <bolrod> if only I had a bow and arrow
10:04:49 <krypton> k
10:04:54 <krypton> that's all for today
10:04:55 <krypton> :P
10:05:24 <bolrod> maybe I can point my subwoofer in such a way that it'll blow up the boat...
10:09:55 <dmhouse> "Let's imagine we're a greengrocer. We had our daily delivery of fresh, juicy and healthy fruit this morning, but unfortunately, the delivery van went round a corner a little too fast and all our fruit is mixed up!"
10:10:05 <dmhouse> This will be explaining how types help to categorise things.
10:10:17 <dmhouse> Is this a cute physical analogy or is it being patronising?
10:11:21 <Stinger_> real world situations would be more useful
10:11:47 <dmhouse> The point of an analogy isn't to be useful, it's to explain the concept.
10:12:13 <ihope> @type 2**pi
10:12:15 <lambdabot> forall a. (Floating a) => a
10:12:24 <dmhouse> @spell meticulous
10:12:26 <lambdabot> meticulous
10:12:35 <ihope> @spell status
10:12:36 <lambdabot> status
10:12:37 <kowey> dmhouse: i very very briefly introduce types in Basic Concepts, using a plugs and connectors metaphor
10:12:38 <Stinger_> yeah but when your analogies get too far removed from real world situations, too contrived, ppl go wtf, or at least I do
10:12:44 <ihope> The piece of junk :-P
10:12:51 <kowey> i'm not meaning to teach types, just to say that types are why a certain example don't work
10:12:56 <dmhouse> kowey: Ah, okay.
10:13:08 <dmhouse> kowey: I'll link in your stuff when I'm finished then.
10:13:19 <ihope> @type (^^)
10:13:20 <dmhouse> Stinger_: Well, this isn't _too_ far from reality :) It's just a little imaginitive.
10:13:21 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
10:13:43 <ihope> > (3 :: Integer) ^^ 3
10:13:45 <lambdabot>  add an instance declaration for (Fractional Integer)
10:13:45 <lambdabot>   In the definition ...
10:14:05 <ihope> @type (^)
10:14:05 <dmhouse> I like it. I'm keeping it :) People can rip it out if they hate it.
10:14:07 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
10:14:33 <ihope> So isn't (^) just a more general version of (^^)?
10:15:14 <bolrod> @vixen isn't (^) just a more general version of (^^)?
10:15:15 <lambdabot> good question
10:15:47 <bolrod> @type 1
10:15:49 <lambdabot> forall t. (Num t) => t
10:15:52 <bolrod> @type 1.1
10:15:55 <lambdabot> forall t. (Fractional t) => t
10:15:58 <bolrod> I guess not :P
10:16:10 <bolrod> @type (**)
10:16:12 <lambdabot> forall a. (Floating a) => a -> a -> a
10:16:28 <bolrod> ^.0 whats the difference between fractional and floating :P
10:16:42 <bolrod> @type 3%3
10:16:44 <lambdabot> forall a. (Integral a) => Ratio a
10:17:07 <bolrod> > 4^^5.5
10:17:08 <lambdabot>  Add a type signature
10:17:22 <bolrod> > 4^^5.5 :: Float
10:17:24 <lambdabot>  Add a type signature
10:17:46 <bolrod> > (4::Float)^^(5.5 :: Float)
10:17:48 <lambdabot>  add an instance declaration for (Integral Float)
10:17:48 <lambdabot>   In the definition of `...
10:18:11 <ihope> bolrod: I think floating includes irrationals.
10:18:41 <bolrod> I See... can you represent those in a computer?
10:18:44 <dmhouse> What's a fruit which is a similar shape to a melon/grapefruit?
10:18:58 <ruffneck> orange ?
10:19:04 <bolrod> how similar is a melon to a grapefruit :/
10:19:05 <ihope> bolrod: with rounding errors, yes.
10:19:13 <dmhouse> Sorry, vegetable.
10:19:29 <ihope> Toma--never mind.
10:19:29 <ruffneck> cabbage?
10:19:33 <bolrod> How can a vegetable be similar to a fruit?!
10:19:45 <dmhouse> Oh, wait, I did mean fruit.
10:19:59 <dmhouse> A fruit which is a similar shape to a melon/grapefruit. And preferable size as well.
10:20:11 <bolrod> mango?
10:20:13 <ruffneck> Asian?
10:20:19 <ruffneck> Durian?
10:20:29 <bolrod> but a melon is a bit larger then grapefruit.. well..
10:20:52 <dmhouse> Mangos are a bit squashe
10:20:54 <dmhouse> *squashed
10:20:57 <dmhouse> Ah well, they'll do.
10:21:31 <kpreid> dmhouse: pomegranate
10:21:32 <ihope> They're not squashes, are they? :-P
10:21:33 <bolrod> In botany, a fruit is the ripened ovary, together with its seeds, of a flowering plant. 
10:21:37 <bolrod> hmm..
10:22:31 <dmhouse> kpreid: Sounds good.
10:23:47 * paolino is pealing peas %]
10:24:13 <bolrod> hrm.. are those fruit as well ..hrm :)
10:27:51 * paolino puts a poster out of his vegetable garden: "haskells fruits! Keep out" 
10:30:36 <sjanssen_> @keal!
10:30:37 <lambdabot> pork steaks taste like dick
10:30:46 <bolrod> O_O
10:30:53 <sjanssen_> oh, that silly keal
10:31:10 <mauke> @keal
10:31:12 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
10:32:10 <bolrod> @keal!
10:32:11 <lambdabot> i aint running that on my puter
10:32:22 <bolrod> @keal
10:32:23 <lambdabot> what the hell does Prelude > mean?
10:32:28 <sjanssen_> @seal
10:32:30 <lambdabot> what are epsilons?
10:32:41 <mauke> @kale
10:32:43 <lambdabot> i cant think anymore
10:32:50 <dmhouse> @keel
10:32:52 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
10:33:02 <sjanssen_> ah! there's a good one
10:33:25 <sjanssen_> @seen dons
10:33:26 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3 hours and 55 seconds ago.
10:33:32 <sjanssen_> @seen dcoutts
10:33:34 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 1 day, 5 hours, 23 minutes and 8 seconds ago.
10:33:45 <paolino> @kul!
10:33:46 <lambdabot> Unknown command, try @list
10:33:58 <bolrod> @. elite . keal
10:33:59 <lambdabot> not 3noU9H AR9uMEN7s to @.
10:34:05 <bolrod> hmm
10:34:09 <sjanssen_> @. elite keal
10:34:10 <lambdabot> iT I5 VerY eAzy +o gO OFF +opIC
10:34:46 <ihope> @. elite djinn (a -> b -> c) -> (a -> b) -> a -> c
10:34:47 <lambdabot> F A 8 c = 4 ( (B C)
10:34:49 <sjanssen_> @. elite eval show
10:34:51 <lambdabot> Say again?
10:35:18 <ihope> @eval "foo"
10:35:35 <bolrod> @run "foo"
10:35:37 <lambdabot>  "foo"
10:35:52 <bolrod> @id ha
10:35:53 <lambdabot> ha
10:35:58 <bolrod> @id /me rules
10:35:59 * lambdabot rules
10:36:06 <dmhouse> kowey: http://en.wikibooks.org/wiki/Haskell/Type_basics
10:38:02 <ihope> @. elite run undefined
10:38:04 <lambdabot> 4dd 4 7Yp3 SiGNaTURe
10:38:09 <ihope> @. elite run undefined :: Integer
10:38:11 <lambdabot> Undephined
10:38:16 <ihope> :-)
10:38:23 <kowey> dmhouse : hey, with a small biology lesson thrown in to boot :-)
10:38:37 <ihope> @. elite run ['a'..]
10:38:39 <lambdabot> "ab(d3FG|-|IJxlmNopqrztuVWxYz{|}~\dE1\128\129\130\131\132\133\134\135\136\137\...
10:38:56 <kpreid> is there a log of the keal event?
10:39:09 <paolino> this evening peas cooked in goat milk with grated marrow and mustard
10:39:13 <ihope> http://tunes.org/~nef/logs/haskell/ :-P
10:39:17 <lambdabot> Title: "Index of /~nef/logs/haskell"
10:39:41 * kowey fixes dinner
10:39:54 <ihope> @. elite type lift return
10:39:56 <lambdabot> fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
10:40:04 <dmhouse> kpreid: Lambabot's sources has all the quotes
10:40:06 <ihope> That's no fun...
10:40:39 <kpreid> OK, silly question
10:40:40 <sjanssen_> heh, /\/\oNAd+R4nz0r
10:41:31 <ihope> @remember lambdabot fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
10:41:33 <lambdabot> Done.
10:41:54 <ihope> Hmm...
10:41:59 <ihope> @type lift return
10:42:01 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a. (MonadTrans t, Monad m) => t ((->) a) (m a)
10:42:10 <ihope> Oh, wait... never mind.
10:42:49 <bolrod> @quote
10:42:51 <lambdabot> kzm says: My program contains a bug.  How ungrateful, after all I've done for it.
10:43:50 <ihope> @quote lambdabot
10:43:50 <lambdabot>  fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
10:44:05 <dmhouse> @quote lambdabot
10:44:06 <lambdabot>  lambdabot hasn't said anything memorable
10:44:13 <dmhouse> @quote lambdabot
10:44:15 <lambdabot>  fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
10:44:18 <bolrod> O_O
10:44:28 <dmhouse> @remember lambdabot lambdabot hasn't said anything memorable
10:44:29 <lambdabot> Done.
10:44:55 <ihope> @quote Foogoohoo
10:44:57 <lambdabot> Foogoohoo hasn't said anything memorable
10:45:03 <bolrod> dmhouse: that's stupid :P
10:45:10 <ihope> Ah, so now that's in there twice!
10:45:19 <dmhouse> @quote lambdabot
10:45:21 <lambdabot>   lambdabot hasn't said anything memorable
10:45:24 <dmhouse> @quote lambdabot
10:45:25 <lambdabot>  Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
10:45:32 <dmhouse> Ah, oops.
10:45:47 <dmhouse> Well, lambdabot should output the quote in quote marks or something.
10:45:56 <ihope> Oh, yeah.
10:46:00 <bolrod> nah
10:46:47 <bolrod> @quote ihope 
10:46:48 <lambdabot>  Oops, I forgot that Djinn doesn't do GADT's.
10:47:06 <ihope> :-)
10:47:28 <bolrod> @quote bolrod 
10:47:29 <lambdabot> bolrod hasn't said anything memorable
10:47:36 <bolrod> tru
10:47:55 <ihope> @quote foo
10:47:56 <lambdabot> foo hasn't said anything memorable
10:48:04 <Korollary> @quote lambdabot
10:48:05 <lambdabot>  Of course i'm female
10:48:13 <bolrod> @quote keal
10:48:15 <lambdabot> keal hasn't said anything memorable
10:48:32 <dmhouse> @keal
10:48:33 <lambdabot> ithink has to do with hardcased government failsafe in chip
10:48:39 <dmhouse> @keal
10:48:41 <lambdabot> you need a Zh function in Haskell
10:48:44 <Korollary> @quote MegaMonad
10:48:45 <lambdabot> MegaMonad hasn't said anything memorable
10:49:38 <bolrod> 2morrow a great match !! :)
10:50:16 <dmhouse> > 2 + 1.5
10:50:18 <lambdabot>  3.5
10:50:44 <dmhouse> What's the most well-known dynamically typed language?
10:51:00 <Stinger_> javascript probably
10:51:09 <bolrod> English?
10:51:11 <dmhouse> I was thinking a compiled one.
10:51:27 <dmhouse> Otherwise it's a little difficult to explain the concept of type errors being caught at compiletime :)
10:53:22 <Cale> Python?
10:54:20 <ihope> Is Python actually any good>
10:54:44 <Cale> It's all right, for what it is
10:54:49 <dmhouse> Isn't Python intepreted too?
10:54:54 <Cale> yes
10:54:54 <Korollary> Lisp?
10:54:58 <Cale> but you could compile it
10:55:02 <wolverian> dmhouse, bytecode compiled 
10:55:48 <Cale> There's nothing that says an interpreted language couldn't be statically typed -- just look at Haskell with Hugs
10:56:54 <Korollary> there are lisp-to-native code compilers
11:00:48 <paolino> ruby ?
11:01:50 <wolverian> dmhouse, perl is probably the oldest, still widely used dynamic language. 
11:02:12 <wolverian> (I'm biased though. but it's one answer, anyway :)
11:02:15 <dmhouse> Again, I'd prefer a compiled example. And not one that you _can_ compile. One that people _do_ compile.
11:02:24 <dmhouse> But if there are no obvious answers, I'll skirt round it.
11:02:46 <wolverian> well, perl (and python, and ruby) is compiled _to bytecode_ every time a script is run
11:02:53 <wolverian> you want machine code?
11:03:56 <dmhouse> I was thinking one where compile-time and run-time are distinct.
11:04:03 <Stinger_> probably wants something that has an explicit compile action
11:05:05 <wolverian> distinct from the user's point of view? 
11:05:17 <dmhouse> Yeah.
11:05:49 <Stinger_> elisp? ;)
11:06:07 <wolverian> can't think of any dynamic language whose users actively distribute compiled code instead of dynamic.
11:06:14 <pejo> dmhouse, why do you want a dynaically typed language to explain the concept of type errors caught at compile time? 
11:06:18 <wolverian> er, s/instead of dynamic/instead of source/
11:06:28 <dmhouse> I think I'll give up on this one.
11:06:55 <palomer> wolverian: perl6 !
11:06:58 <Stinger_> you could use c or something
11:07:06 <paolino> mmhh, dynamical languages has usually a big VM running them , I can't find a compiled dynamically typed one
11:07:13 <wolverian> that said, at least perl exposes the compile- and runtime phases on the language level, but it's not used for precompiling, so to say
11:07:17 <Stinger_> that allows a lot of dodgy casts
11:07:25 <Stinger_> that can be implicit
11:07:26 <wolverian> palomer, yes, but I doubt it's going to be used that way much.
11:07:32 <wolverian> distributing source is so much nicer. 
11:07:45 <palomer> dynamic language == no type system?
11:07:54 <Stinger_> but it is typed though so you cant make the typed/untyped distinction
11:08:03 <Stinger_> you can just say cs type system sucks :P
11:08:08 <palomer> if so, I bring you scheme!
11:08:26 <wolverian> oo, scheme! palomer++
11:08:45 <palomer> sir, you have to type @karma palomer 1
11:08:58 <Stinger_> heh
11:09:01 <wolverian> that is the bot's problem, not mine 
11:09:08 * wolverian coughs
11:09:21 <pejo> Stinger_, I don't think anyone will argue that the typesystem of C is great. Just an awful lot of freedom.
11:09:46 <wolverian> palomer, you mean @karma+ palomer? anyway, that worked (in priv) 
11:10:14 <palomer> @karma palomer
11:10:16 <lambdabot> You have a karma of 5
11:10:18 <palomer> yes!
11:10:32 <Korollary> @palomer
11:10:33 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
11:10:43 <dmhouse> Karma counters that work by counting ++s are good fun. '@karma C' beats everyone. :)
11:10:59 <palomer> anyways, there's also smalltalk and assembly
11:11:17 <palomer> lisp variants, etc...
11:12:57 * paolino wonders if scheme is a language to learn
11:13:22 <palomer> it's a language to burn!
11:13:26 <Korollary> nah
11:13:42 <Korollary> be fair to scheme
11:13:48 <palomer> it's a great language if you want to learn about abstract syntax trees
11:14:30 <palomer> I jest, I have no hard feelings towards scheme
11:15:24 <Stinger_> well I'd hope you wouldnt get that excited over a programming language
11:16:38 <Korollary> I wish I had more time for scheme and a good logic/constraint programming language.
11:18:14 <neologism> Korollary: is there any CPL which is not dead?
11:20:54 <Korollary> neologism: I don't know. I bet more are being invented every month.
11:21:07 <neologism> I know only about goedel
11:21:25 <neologism> logic programming is realyl hard to debug and people dont like it
11:23:46 <Korollary> I would probably go for a copy of ConceptsTechniquesModels and Mozard-oz
11:23:58 <Korollary> mozart
11:24:00 <Korollary> bleh
11:44:24 <zeeeee> hi all, can i use ghci or hugs as a shell scripting tool? eg i want the output "hello ..." without the loading/extraneous text when i run: echo "take $x (repeat "hello")" | hugs
11:46:09 <Stinger_> is haskells array type I hear you people mentioning every now and again implemented in the haskell language? or is it a hardcoded optimization/external lib?
11:46:21 <Cale> zeeeee: try ghci -e
11:46:36 <Cale> zeeeee: you can give an expression to evaluate on the commandline like that
11:46:49 <Cale> Stinger_: It's part of the spec
11:46:58 <Stinger_> oh rightyoh
11:47:02 <zeeeee> Cale: ah, thanks
11:48:56 <Cale> Stinger_: The spec doesn't specify actual runtime bounds on operations though. It just says that fast access to elements can be expected.
11:50:00 <Cale> Stinger_: So a compliant implementation could probably use binary balanced trees in Haskell if it wanted, but I think all existing implementations implement arrays as a primitive type.
11:50:47 <Stinger_> seems sensible to implement an array as an array :)
11:54:45 <Stinger_> oh well wc time
11:56:51 <petekaz> Are there any builtin string functions?  Many of the Data.List functions only work with single elements (chars), and not mulitple elements (subsets of the original string)?
11:57:41 <Cale> Well, there's words
11:57:44 <petekaz> For example, any builtin to take "this is a test" and replace all occurrences of "test" with "word"?
11:58:23 <Cale> no builtins for that, no
11:58:26 <petekaz> Perhaps I should look into the regexp module.
11:58:35 <Cale> yeah, it has replacement stuff
11:59:15 <petekaz> Ok, I wonder if the MissingH library has that as well.  I've noticed that he's basically modified all of Data.List to work with multiple elements and not just a single element.
12:00:23 <Cale> > words "Hello, this is a test."
12:00:25 <lambdabot>  ["Hello,","this","is","a","test."]
12:00:45 <Cale> that can be handy
12:00:49 <Cale> there's also lines
12:01:01 <petekaz> Ok.
12:01:22 <Cale> splitAt, span, and break are also useful
12:01:56 <Cale> > break (== ',') "a,list,of,elements"
12:01:58 <lambdabot>  ("a",",list,of,elements")
12:02:23 <Cale> > break (== ',') "list,of,elements"
12:02:26 <lambdabot>  ("list",",of,elements")
12:03:39 <petekaz> I'm writing a simple vocab cgi program, and I noticed that some of my definitions contain the word one is supposed to guess!  So I want to remove the word in question from its definition and that includes the copital form, simple plurals, etc ...
12:03:54 <petekaz> And replace in with '___' as a placeholder instead.
12:04:18 <petekaz> See here: http://www.kazmier.com/~kaz/vocab.cgi
12:04:20 <lambdabot> Title: "Vocabulary Quiz"
12:04:29 <petekaz> The definitions contain the words ... doh!
12:05:37 <Cale> yes, every definition :)
12:07:56 <petekaz> MissingH.Str does indeed have a 'replace' function which works the same as the python equivalent.
12:08:17 <petekaz> http://quux.org/devel/missingh/html/MissingH-Str.html
12:13:19 <petekaz> Ahh .. much better.
12:22:49 <Cale> petekaz: you're still missing some though
12:30:38 <waern> Lemmih: ping
12:33:14 <Cale> petekaz: I'm reminded of http://www.archivestowearpantsto.com/tracks/0039_alliteration.mp3, which was a requested "song", using the words from http://myfreewebtools.com/vocablist/vocab1.html
12:35:36 <Lemmih> waern: pong
12:36:34 <waern> Lemmih, I'm getting a panic when using the GHC api, in tidyProgram (lookup_dfun).. ever got that?
12:37:03 <petekaz> Cale: oh yeah ... I'll fix tonight, off to a cookout now.  Thanks for pointing it out.
12:37:22 <waern> Lemmih, the module that I'm loading compiles fine using GHC normally
12:37:36 <Lemmih> waern: I don't recall.
12:38:13 <waern> Lemmih, okay, just checking
12:43:46 <kowey> still there, dmhouse?
14:06:51 * ihope feels a sudden need to make (a -> a) -> a -> a an instance of Num
14:17:25 <kuribas> What is the fastest way to read data from a file into an array (for image manipulation).
14:23:07 <eivuokko> @doc System.IO.hGetBuf
14:23:07 <lambdabot> System.IO.hGetBuf not available
14:23:12 <eivuokko> @doc System.IO
14:23:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
14:23:23 <eivuokko> Binary IO probably.
14:23:52 <ihope> @bot
14:23:54 <lambdabot> :)
14:24:04 <ihope> Okay, that still works.
14:33:55 <johnnowak> how can i tell if ghc has decided that a given function can be evaluated eagerly? 
14:37:31 <eivuokko> http://haskell.org/ghc/docs/latest/html/users_guide/faster.html has some tricks
14:37:32 <lambdabot> Title: "6.2. Faster: producing a program that runs quicker"
14:42:46 <kuribas> How can I convert the Ptr data read from hGetBuf into an immutable array?
14:44:02 <kuribas> Perhaps I could use hGetArray, but I it also returns an mutable array.
14:45:43 <eivuokko> Using Foreign.Storable's methods
14:49:25 <ihope> So how is (^) defined?
15:04:05 <Cale> ihope: differently on each type?
15:04:31 <int-e> ^ does a multiply and square.
15:04:37 <ihope> It isn't a class function in Integral, is it?
15:05:55 <Cale> oh, sorry, no it isn't
15:06:01 <largos> I'm having some trouble with regular expressions (in Text.Regex)
15:06:22 <Cale> It's ** which is a class function
15:06:23 <largos> [[:digit:]]+ matches a string of 1-n digits, but \\d+ doesn't seem to work
15:06:40 <largos> is there some syntactic trick I'm missing?
15:07:50 <largos> (by "doesn't work" I mean that it doesn't seem to match the same string of digits, it is interpreted without complaint)
15:09:30 <int-e> you could use [0-9]
15:09:57 <Cale> \d is nothing special in Posix regexps
15:10:37 <ihope> So (^) is pretty much defined like it is at http://en.wikipedia.org/wiki/Talk:Exponentiation_by_squaring? :-)
15:10:40 <largos> ah, I thought \d was defined in posix to be equal to [[:digit:]]
15:11:03 <Cale> ihope: look at the Prelude standard
15:11:14 <Cale> @libsrc Prelude
15:11:15 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
15:11:34 <Cale> huh
15:11:42 <Cale> no fptools there anymore
15:12:06 <Cale> but the actual thing to look at is
15:12:07 <ihope> http://www.haskell.org/onlinereport/standard-prelude.html
15:12:09 <lambdabot> Title: "The Haskell 98 Report: Standard Prelude"
15:12:13 <int-e> ihope: pretty much except ghc does it correctly ;)
15:12:13 <Cale> http://haskell.org/onlinereport/standard-prelude.html
15:12:15 <Cale> yes
15:12:15 <lambdabot> Title: "The Haskell 98 Report: Standard Prelude"
15:12:32 <ihope> int-e: I did it wrong?
15:12:32 <Cale> I was just interested in what it looks like in GHC
15:12:55 <int-e> ihope: the x := x*x is unconditional and comes after the condition n := n*x step
15:13:32 <ihope> Um...
15:14:32 <int-e> ihope: err, result := result*x.
15:15:33 <ihope> Multiplying the final result by the base is unconditional?
15:16:27 <vininim> Is "The Art of Functional Programming" a good book?
15:17:02 <vininim> Addison-Wesley, 1999
15:17:19 <neologism> vininim: very good
15:17:32 <int-e> ihope: I changed it on the wiki talk page
15:18:40 <ihope> int-e: um, I meant the Haskell code there.
15:18:58 <int-e> ihope: oh, down there. I didn't see that.
15:19:02 <kosmikus> vininim: I don't know that book. Who's the author?
15:19:29 <int-e> ihope: that one looks better.
15:22:20 <ihope> @. docs hoogle Weak
15:22:22 <lambdabot> System.Mem.Weak :: module
15:22:22 <lambdabot> System.Mem.Weak.Weak :: data Weak v
15:22:22 <lambdabot> System.Mem.Weak.deRefWeak :: Weak v -> IO (Maybe v)
15:22:22 <lambdabot>  not available
15:22:26 <ihope> Pah.
15:22:39 <ihope> @docs System.Mem.Weak
15:22:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
15:24:33 <vininim> kosmikus: Simon Thompson
15:29:53 <kosmikus> vininim: ah, you mean the *craft* of functional programming then?
15:30:15 <kosmikus> that's an ok book
15:38:43 <vincenz> hi from toronto
15:39:00 <Korollary> hello toronto
15:39:11 <int-e> somewhere over the ocean *tilt*
15:39:19 <vincenz> yeah
15:39:34 <vincenz> damn, been up 18.5 hours and it's only 6:30 pm here
15:39:46 <vincenz> and they blew up a luggage in paris
15:39:47 <vincenz> o.O
15:39:54 <Korollary> jetlag's worse when going the other way 
15:39:57 <vincenz> they didn't even move it, just blew it up on the spot
15:40:02 <vincenz> that made as shitload of noise
15:40:05 <vincenz> Korollary: yeah I know
15:40:19 <Korollary> why did they blow it up?
15:40:32 <vincenz> they suspected a bomb I guess?
15:40:35 <vincenz> unattended luggage
15:40:37 <Korollary> ah
15:40:47 <vincenz> imagine accidentally forgetting your luggage briefly :P
15:41:00 <Korollary> now your underwear is distributed all over
15:46:33 <largos> is function composition preffered over nesting?
15:46:45 <largos> eg: (head . head) vs. head ( head (..))
15:47:08 <vincenz> yes
15:47:27 <largos> because of the extra variable needed? or just for elegance reasons?
15:48:24 <vincenz> eleganc
15:48:47 <vincenz> 7pm
15:48:51 <vincenz> time to read a bit and hit the sack
15:51:20 * vincenz mutters "complimentary internet" but they forget to mention "at 1bps"
15:51:38 <SamB> hahaha
15:52:14 <ihope> What's the fixity of >>=? Is it infixl 4?
15:52:26 <SamB> :i in GHCi will tell
15:53:09 <ihope> > fix (\(_:xs) -> '`':xs >>= boink) where boink '`' = "``s"; boink 's' = "`ks"; boink 'k' = "`kk"
15:53:10 <lambdabot>  Parse error
15:53:29 <ihope> > let boink '`' = "``s"; boink 's' = "`ks"; boink 'k' = "`kk" in fix (\(_:xs) -> '`':xs >>= boink)
15:53:31 <lambdabot>  Exception: <<loop>>
15:54:15 <ihope> Hmm, so how do I get ``s``s`ks``s``s`ks``s`kk`ks...
15:54:35 <largos> ?hoogle String -> Maybe Double
15:54:37 <lambdabot> No matches, try a more general search
15:55:27 <largos> ?hoogle String -> Maybe Number
15:55:28 <lambdabot> No matches, try a more general search
15:55:41 <Korollary> largos: looking for read?
15:56:04 <largos> I need to extract a double from an input string
15:56:11 <Korollary> use read
15:56:21 <Korollary> @type read
15:56:23 <lambdabot> forall a. (Read a) => String -> a
15:56:39 <largos> ok
16:00:26 <largos> read is.... weird.  
16:00:48 <largos> the fact that it "just works" is eerie.
16:03:29 <int-e> > fix (\(_:xs) -> '`':('`':`s`:xs >>= boink)) where boink '`' = "``s"; boink 's' = "`ks"; boink 'k' = "`kk"
16:03:30 <lambdabot>  Parse error
16:03:40 <int-e> > fix (\(_:xs) -> '`':('`':'s':xs >>= boink)) where boink '`' = "``s"; boink 's' = "`ks"; boink 'k' = "`kk"
16:03:40 <lambdabot>  Parse error
16:04:13 <madpickle> O.o
16:04:58 <Stinger_> thats just evil
16:09:55 <int-e> > let boink '`' = "``s"; boink 's' = "`ks"; boink 'k' = "`kk" in fix (\ ~(_:xs) -> '`':xs >>= boink) -- there you go
16:09:55 <lambdabot>  "``s``s`ks``s``s`ks``s`kk`ks``s``s`ks``s``s`ks``s`kk`ks``s``s`ks``s`kk`kk``s...
16:12:42 <ihope> largos: just works?
16:15:30 <int-e> ihope: behold the power of type classes ;)
16:16:17 <ihope> Hmm...
16:16:42 <ihope> So, isn't the above the only fixed point of (>>= boink)?
16:18:35 <ihope> > let boink x = '`' : zap x; zap '`' = "`s"; zap 's' = "ks"; zap 'k' = "kk" in fix (>>= boink)
16:18:37 <lambdabot>  Exception: <<loop>>
16:18:40 <int-e> ihope: no. bottom  (undefined) is another one.
16:18:42 <ihope> Meh.
16:18:55 <ihope> Okay, what about the new boink?
16:18:56 <int-e> and that's the one you get
16:19:33 <int-e> > let boink x = '`' : zap x; zap '`' = "`s"; zap 's' = "ks"; zap 'k' = "kk" in fix (\ ~(x:xs) -> x:xs >>= boink)
16:19:34 <lambdabot>  "``s``s`ks``s``s`ks``s`kk`ks``s``s`ks``s``s`ks``s`kk`ks``s``s`ks``s`kk`kk``s...
16:19:43 <int-e> add some more lazyness and it works.
16:19:56 <ihope> Hmm...
16:20:22 <ihope> Oh, right.
16:20:28 <ihope> Now for some evil...
16:20:36 <ihope> > let boink x = '`' : zap x; zap '`' = "`s"; zap 's' = "ks"; zap 'k' = "kk" in mfix boink
16:20:37 <lambdabot>  Exception: <<loop>>
16:21:04 <ihope> So this one just can't work?
16:21:26 <int-e> hmm.
16:22:40 <int-e> > let boink x = '`' : zap x; zap '`' = "`s"; zap 's' = "ks"; zap 'k' = "kk" in mfix (\ ~(x:xs) -> boink (x:xs))
16:22:41 <lambdabot>  Couldn't match `[a]' against `Char'
16:22:51 <int-e> ah
16:23:01 <ihope> Hmm, [] is a fixed point of (>>= boink)?
16:23:04 <int-e> right. no. but that may be a shortcoming of list's mfix.
16:23:14 <int-e> oh right.
16:23:27 <int-e> another one.
16:23:47 <ihope> And these guys don't like to compete...
16:24:13 <ihope> Sadly, in a competition of fixed points, everyone loses.
16:25:31 <int-e> they submit to the dark side and become undefined.
16:26:04 <johnnowak> question: at what point do advanced methods of ensuring software correctness through the language become counter-productive; either due to their complexity, or due to limitations on expressiveness requiring larger volumes of code and/or a less ideal approach?
16:26:50 <ihope> Dynamic typists argue that static typing is already too much.
16:26:56 <ihope> (Yes, I know that's not what a typist is.)
16:27:02 <Korollary> I am not aware of any research
16:28:09 <johnnowak> ihope: This is true, although I certainly don't agree.  :)
16:28:48 <johnnowak> Surely many would say it about "purely" functional languages in general that thusly require fancy ways of doing i/o or similar.
16:29:28 <ihope> Say, is there a purely functional dynamically-typed language out there?
16:29:34 <ihope> And Lazy K doesn't count.
16:30:19 <Korollary> productivity is a fuzzy concept
16:31:06 <johnnowak> ihope: not that i'm aware of. not sure why you'd want one, really.
16:31:44 <ihope> What if I'm a loyal Python fan, despite my not knowing any Python?
16:32:47 <ihope> And what if despite my baseless Python loyalties, I like the purely-functionalness of Haskell?
16:34:05 <Korollary> schemers also prefer purity whenever possible
16:34:36 <sylvan> johnnowak: IIRC the original paper on "clean room programming" actually showed a productivity *increase* from using formal rigid methods... I'm not aware of any more research into this particular aspect but in my own experience I'd say that the cost of incorrect programs (w.r.t. overall productivity) is so massive that pretty much any amount of extra work "up front" to ensure correctness will pay 
16:34:36 <sylvan> off in productivity as well
16:34:48 <lisppaste2> lispy pasted "how to simplify this parser" at http://paste.lisp.org/display/22272
16:35:13 <JKnecht> clean room, that was U of Md SEI wannit?
16:35:22 <lispy> i bet my parser can be written as a one liner, but i'm not sure how to apply (<|>) ot the list
16:35:46 <sylvan> not sure... 
16:36:01 <ihope> lispy: choice or something, maybe?
16:36:02 * johnnowak feels more in line with Scheme's philosophy than Haskell's
16:36:06 <ihope> @hoogle choice
16:36:07 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
16:36:07 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec a
16:36:07 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] -> GenParser tok st a
16:36:14 <johnnowak> but that's besides the point :)
16:36:38 <largos> lispy: maybe a list comprehension & some sort of fold?
16:36:46 <pejo> johnnowak, I don't think anyone in either camp is arguing for a straightjacket that disallows you to write correct programs. It's just about what you're prepared to sacrifice.
16:36:48 <lispy> ihope: that looks pretty much prefect
16:37:04 <johnnowak> pejo: yes, 'course.
16:37:04 <lispy> choice ps  = foldl (<|>) pzero ps
16:37:19 <johnnowak> i suppose i am looking for papers or something similar.
16:37:32 <pejo> And type system research has come a long way in the last 20 years. :-)
16:37:33 <johnnowak> rather than random informal irc gut opinions :)
16:38:48 <lispy> escapeChars cs = choice (map escapeChar cs)
16:39:38 <lispy> largos: yeah, i could replace the map with a list comp. and choice is the fold
16:40:39 <largos> lispy: oh, so I got about half-way through the backend of this battery monitor today and realized I was writing it in typed lisp..
16:40:56 <ihope> choice [ escapeChar x | x <- cs ]
16:41:03 <Korollary> johnnowak: There are papers, including some over at haskell.org. I just find 'productivity' studies nebulous.
16:41:10 <ihope> We all need to use more list comprehensions!
16:41:56 <lispy> largos: aka imperative haskell?
16:42:10 <largos> lispy: sortof
16:42:31 <largos> lispy: there are just a number of things I should be doing differently..
16:42:49 <largos> lispy: eg: I have a BatteryState type, but it doesn't know how to read its self
16:43:05 <lispy> add deriving (Read)
16:43:08 <Korollary> largos: deriving Read comes for free for many user defined types.
16:43:13 <largos> exactly
16:44:12 <largos> once I create types that derive Read, I can combine all the file parsing code, and use generic types there
16:44:57 <lispy> cool
16:45:17 * lispy is following this today: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/parser.html#symbols
16:45:18 <lambdabot> Title: "Write Yourself a Scheme in 48 hours"
16:45:42 <lispy> it's not really at my level of haskell but it's fun to follow along
16:49:55 <madpickle> when i use C-s to search in Xemacs, what's the command to make it go to the next match?
16:50:18 <lispy> C-s
16:50:31 <madpickle> doh!
16:50:37 <madpickle> thanks :)
16:50:40 <lispy> np
16:50:48 <lispy> emacs is tricky that :)
16:51:29 <madpickle> yeah, it's always the little things
16:51:41 <madpickle> but there's no decent editors out there for python (or, indeed, haskell)
16:51:46 <madpickle> or.. prolog
16:52:48 <|Steve|> madpickle: I just use vim for haskell. =\
16:52:49 <lispy> madpickle: do you use eclipse?
16:53:00 <madpickle> i try to avoid that
16:53:05 <madpickle> i have used it for Java
16:53:13 <madpickle> but I'd rather cut myself with a dull knife
16:53:13 <lispy> there is pydev and fp for eclipse
16:53:15 <madpickle> /wrist
16:53:19 <madpickle> yeah, i've seen em
16:53:23 <madpickle> but me and Eclipse don't get along =)
16:53:29 * lispy nods
16:53:32 <madpickle> thanks tho
16:53:40 <madpickle> i wrote a nice editor for prolog in windows for students new to Prolog
16:53:44 <lispy> emacs is hard to beat (or vim if you insist)
16:53:46 <madpickle> it's well loved as it integrates SWI-Prolog
16:53:52 <madpickle> but no linux support
16:56:40 <lispy> i usually have ghci in one terminal where i go over and type :r all the time
16:56:49 <lispy> and then emacs in another window where i do my editing
16:57:00 <madpickle> yeah
16:57:09 <madpickle> thing with that in Prolog is the need to use consult
16:57:15 <madpickle> and when you're dealing with a new language paradigm 
16:57:25 * lispy doesn't like using prolog
16:57:25 <madpickle> and you mix in Eclipse (ack) or Emacs (ugh)
16:57:31 <madpickle> you got a bad mix for new students
16:58:47 * JKnecht raises eyebrows at SWI eclipse perspective. Would think I'd have heard of that.
16:59:29 <madpickle> not saying that's possible (or even feasible)
16:59:33 <madpickle> i value my sanity
17:16:38 <joe_k> is it me or does ghci not handle input editing to well? i can't seem to use arrows, delete, backspace, or even ctrl-d 
17:16:46 <joe_k> (to exit)
17:17:05 <lispy> ghci uses readline and normally works great
17:17:35 <joe_k> hm. i know my termcap is set right (screen and irssi work great)
17:18:41 <lispy> maybe it's busy?  hit ctrl+c a few times?
17:19:18 <joe_k> this is at a Prelude> prompt from a freshly started ghci
17:19:41 <joe_k> ctrl-c gives me a "^CPrelude>
17:19:42 <joe_k> "
17:20:00 <lispy> weirdness
17:20:03 <joe_k> yeah
17:20:12 <joe_k> as i recall 6.4.1 works fine, 6.4.2 didn't
17:21:41 <eivuokko> Then it might be threaded RTS getting linked to ghci
18:07:11 <jargonjustin> Monad question: Why does "(Just 42) >>= return" evaluate to (Just 42), or how does "return" know that the monad to use is Maybe.
18:07:42 <kpreid> @type (>>=)
18:07:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:08:00 <kpreid> jargonjustin: because the type of (>>=) requires that the same monad be on the left and right
18:08:22 <kpreid> therefore the 'return' can be inferred to be for Maybe
18:08:34 <jargonjustin> kpreid: So it picks up the return implicitly from the input (m a) ?
18:08:59 <kpreid> I don't understand what you mean.
18:09:41 <jargonjustin> kpreid: Nevermind, it makes sense.
18:09:58 <jargonjustin> Big ol' light just went on, thanks a lot.
18:10:05 <kpreid> jargonjustin: for another example of this sort of inference, look at maxBound/minBound from the Bounded class
18:10:27 <kpreid> > [1::Int, 2, maxBound - 1, maxBound]
18:10:28 <lambdabot>  [1,2,2147483646,2147483647]
18:12:11 <jargonjustin> kpreid: Isn't that more of a datatype thing though?  The type of the list is [Int] and since Int is an instance of Bounded, the compiler knows to call maxBound for Int?
18:12:39 <kpreid> no, they're both just type inference
18:13:19 <kpreid> @type return
18:13:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
18:13:22 <kpreid> @type maxBound
18:13:24 <lambdabot> forall a. (Bounded a) => a
18:13:34 <kpreid> anything that behaves that way will mention a type class in its type
18:13:40 <jargonjustin> kpreid: How is it determining the type of "a" ?
18:13:49 <jargonjustin> In your example
18:15:27 <jargonjustin> Slightly unrelated question, in the type signature the forall part refers to the kind, while the rest refers to the type, right?
18:16:04 <kpreid> it determines the type of a because lists must have the same type for all elements
18:16:20 <jargonjustin> kpreid: Okay, that's what I thought.
18:16:25 <kpreid> [1,maxBound] is equivalent to 1 : (maxBound : [])
18:16:29 <kpreid> @type (:)
18:16:31 <lambdabot> forall a. a -> [a] -> [a]
18:16:49 <jargonjustin> And since a in this case is an Int... okay.
18:17:10 <kpreid> and : restricts its two arguments in the same king of way that >>= does
18:17:28 <jargonjustin> Type inference with polymorphic types makes sense now.  Thanks.
18:24:12 <largos> I'm trying to derive Read for a new type defined as: data BatState = Dead|Full|Charging|Discharging
18:24:57 <largos> when I implement read :: Read a => String -> a   I want to parse strings into the various BatState values
18:25:25 <largos> is there as easier way than simply using string equality or a parsec parser?
18:26:20 <eivuokko> data Foo = Bar deriving (Read)
18:27:07 <eivuokko> Manually, I don't think it gets any simpler for that datatype than equality checking.
18:27:51 <largos> ok..
18:28:15 <largos> what does the data Foo = Bar deriving (Read) line do?
18:28:27 <eivuokko> The point is the deriving-clause.
18:28:37 <eivuokko> Some classes are automatically deriveable
18:30:17 <largos> in addition to the deriving line, I'll still need an instance for the read implementation, right?
18:30:33 <eivuokko> No
18:31:02 <largos> oh, because it brings along automatic parsing to go from say "discharging" to Discharging?
18:31:17 <eivuokko> Uhm
18:31:27 <eivuokko> Automatically deriving doesn't give you that.
18:32:40 <eivuokko> Read might no be the best thing for parsing.
18:34:43 <largos> hm.. ok, I'm confused.  reading about Types on the haskell wiki though, I'll see if that helps
18:35:05 <eivuokko> Sorry.
18:35:41 <largos> no prob, I'm still really new to haskell
18:45:20 <largos> hm.. can you not derive Ord without either also deriving Eq or providing an instance deffinition for (==) ?
18:46:25 <eivuokko> Ord a depends on Eq a being declared, yes.  Eq is Ord's superclass.
18:47:20 <largos> ok
18:48:36 <largos> I'm still confused about what deriving a class gets you.  it seems like some functionality is defined, but it isn't clear to me how to add to that -- for example, how I would create a type that could be compared for equality but had no intrinsic ordering.
18:49:36 <eivuokko> Derive just Eq
18:50:36 <largos> oh, that's working now :) I must have botched it when I tired before
18:51:17 <dons> morning
18:51:23 <eivuokko> Hiya
18:51:23 <largos> g'day
18:51:40 <dons> @seen sjanssen
18:51:41 <lambdabot> I saw sjanssen leaving #haskell 9 hours, 31 minutes and 7 seconds ago, and .
18:52:17 <largos> could someone point me to an example of a simple type that derives Read and has an accompanying read :: Read a => String -> a defined?
18:52:42 <largos> (or documentation pertaining to that..)
18:53:44 <SamB> doesn't read work on everything that derives Read ?
18:53:53 <SamB> @type
18:53:54 <lambdabot> not an expression: `'
18:53:56 <SamB> @type Read
18:53:57 <lambdabot> Not in scope: data constructor `Read'
18:53:58 <SamB> @type read
18:54:00 <lambdabot> forall a. (Read a) => String -> a
18:54:08 * SamB is hot and/or tired
18:54:43 <largos> hm.. maybe I'm testing incorrectly
18:55:22 <largos> data BatState = Dead|Full deriving (Read, Show, Eq) -- read "Dead" gives: *** Exception: Prelude.read: no parse
18:56:04 <SamB> better give a type signature, i.e. (read "Dead" :: BatState)
18:56:13 <u221e> Are there any good sdl bindings for haskell?
18:56:20 <largos> ah..
18:56:47 <largos> SamB: thanks, I was wondering about that :)
18:57:42 <largos> u221e: I ran across haskelldb the other day, but haven't even read much about it yet
18:57:54 <largos> er, my bad. s*d*l
18:58:06 <dons> u221e: check on haskell.org under the 'Libraries and tools' link
19:16:40 <Frederick> SamB, ever heard about category theory?
19:18:43 <SamB> heard of it, don't know too much of it
19:18:53 <SamB> but apparantly it has been a big inspiration for Haskell
19:19:13 <Frederick> I will have 4 credit class about it got some books still getting courage toread it
19:19:28 <SamB> it probably isn't tooooo hard
19:19:54 <Frederick> SamB, I believe it is quite useless from what Ive heard from the seniors
19:20:12 <SamB> they don't know anything, probably
19:20:32 <SamB> perhaps *they* haven't found a use for it
19:20:44 <SamB> but lots of people around here seem to like it
19:21:08 <Frederick> SamB,we argued with the teachers there is no point for a grad course have it
19:27:11 <dons> I think Cale has found it very useful.
19:27:34 <dons> Sometimes when I need to think up a typeclass to solve some problem, Cale says, "oh, that's just a foobar category'
19:28:25 <dons> so I imagine that it would be useful, especially if you're going to get into serious typeclass programming
19:31:20 <largos> ?paste
19:31:21 <lambdabot> http://paste.lisp.org/new/haskell
19:33:22 <augustss> hi
19:33:38 <Frederick> =/
19:34:05 <augustss> well, now i have a spanking new macbook and no haskell compiler
19:34:14 <lispy> augustss: :(
19:40:43 <LordBrain> i have some questions about the simple example server here on the wiki: http://haskell.org/hawiki/HaskellNewbie_2fTcpIpAndNetworking
19:40:45 <lambdabot> Title: "HaskellNewbie/TcpIpAndNetworking - The Haskell Wiki"
19:41:03 <LordBrain> first... i notice that he imports IO hiding bracket...
19:41:09 <LordBrain> (or she)
19:41:19 <LordBrain> Stefan..
19:41:39 <LordBrain> i'm guessing thats a he
19:41:42 <LordBrain> anyway
19:41:59 <LordBrain> he uses bracket in the program... i guess from Network...
19:42:06 <sjanssen_> I think the IO module has moved to System.IO
19:42:07 <LordBrain> or actually i'm not sure where
19:42:09 <kpreid> @hoogle bracket
19:42:09 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:42:10 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
19:42:10 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
19:42:20 <kpreid> @hoogle+ bracket
19:42:20 <lambdabot> Text.PrettyPrint.HughesPJ.brackets :: Doc -> Doc
19:42:21 <lambdabot> Text.ParserCombinators.Parsec.Token.brackets :: TokenParser st -> CharParser st a -> CharParser st a
19:42:33 <sjanssen_> @type Control.Exception.bracket
19:42:35 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:42:41 <LordBrain> ok
19:42:48 <LordBrain> so he's using it from Control.Exception...
19:43:12 <lispy> when you're creating your own instances, why does Show let you define show directly but with Read you have to define readsPrec?
19:43:13 <LordBrain> @type IO.bracket
19:43:15 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:43:27 <sjanssen_> @info read
19:43:28 <lambdabot> Unknown command, try @list
19:43:44 <sjanssen_> lispy: read isn't a member of the Read class
19:44:02 <lispy> sjanssen_: oh, that seems odd
19:44:06 <augustss> and just read would not make any sense
19:44:07 <LordBrain> i notice hoogle didnt mention that Control.Exception.bracket existed.
19:44:45 <LordBrain> @type Network.bracket
19:44:47 <lambdabot> Not in scope: `Network.bracket'
19:44:53 <LordBrain> hmm
19:45:02 <augustss> when reading you have to return what was read and what's left of the input
19:45:04 <lispy> LordBrain: maybe because it listed IO.bracket instead?
19:45:22 <sjanssen_> @type readsPrec
19:45:23 <lambdabot> forall a. (Read a) => Int -> ReadS a
19:45:37 <LordBrain> lispy... but if there are two.. why not list both?
19:45:55 <lispy> LordBrain: my guess that there  is one which gets reexported
19:46:15 <lispy> so what is the purpose of that int parameter?
19:47:12 <augustss> the int in readsprec has the same purpose as the int in showsprec, it's the precedence level so you can parse operator expressions correctly
19:47:30 <lispy> okay
19:51:00 <dons> morning sjanssen_ :)
19:51:13 <LordBrain> lispy... this doesnt kind of bug you? i would like to understand the decision to hide bracket in IO in this program... and clarity on whether there are two brackets or if its re-exported.. i dont know where to go to clarify this for myself.. do you have any suggestions?
19:51:51 <lispy> LordBrain: i don't think i can help, sorry
19:52:11 <lispy> outside of reading the source code for those modules i have no ideas
19:52:16 <LordBrain> maybe its a portability thing...
19:52:45 <lispy> maybe dons can give some insigh
19:54:04 <LordBrain> well the source for hugs Control.Exception has an actual bracket function written
19:54:21 <LordBrain> so its not re-exported in that case
19:54:21 <dons> ah, what am I giving insights about?
19:54:54 <LordBrain> ok... i'll repost a little 
19:54:59 <lispy> dons: why is 42 the answer...er i mean, is IO.bracket the same as Control.Exception.bracket
19:55:16 <dons> they're not the same, are they?
19:55:29 <dons> just like Control.Exceptoin.catch and Prelude.catch
19:55:31 <LordBrain> i am looking at the program here: http://haskell.org/hawiki/HaskellNewbie_2fTcpIpAndNetworking
19:55:32 <lambdabot> Title: "HaskellNewbie/TcpIpAndNetworking - The Haskell Wiki"
19:55:48 <lispy> @type Control.Exception.bracket
19:55:49 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:55:49 <dons> you want to use the Control.Exception.* variety, since you can catch more exceptions
19:55:53 <lispy> @type IO.bracket
19:55:54 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:56:09 <lispy> at least at the type level they are the same
19:56:12 <LordBrain> i guess the exception version installs handlers...
19:56:45 <LordBrain> but this seems to be missing from the ghc docs.. or hoogle at least
19:59:08 <dons> let me check the src
19:59:24 <dons> oh, bracket is the same.
19:59:27 <dons> -- Copied here to avoid recursive dependency with Control.Exception
19:59:35 <LordBrain> oh
19:59:35 <dons> says IO.hs
19:59:42 <LordBrain> i didnt look in io
19:59:45 <LordBrain> hmmm
20:00:09 <dons> anyway, you should use Control.Exception, I'd say
20:00:11 <LordBrain> so this guy just arbitrarily decided to hide it in IO as opposed to Control.Exception
20:00:49 <lispy> is there a technical reason to not allow recursive dependencies with modules?
20:01:04 <dons> I suppose it helps out compilers that can't deal with it
20:01:10 <LordBrain> since hoogle doesnt even metion Control.Exception.bracket.. i wouldn't have even known to think about that, i would have just used it in IO
20:01:17 <dons> this is the haskell base library after all, which everyone uses
20:01:32 <dons> hoogle reflects ndm's love of h98, I think :)
20:01:34 <lispy> i just realized that if two modules depend on each other you probably have a bad layout too interms of maintenence
20:01:38 <dons> ?hoogle bracket
20:01:39 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:01:39 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
20:01:39 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
20:01:43 <dons> ?hoogle+
20:01:44 <lambdabot> Text.PrettyPrint.HughesPJ.brackets :: Doc -> Doc
20:01:44 <lambdabot> Text.ParserCombinators.Parsec.Token.brackets :: TokenParser st -> CharParser st a -> CharParser st a
20:02:00 <dons> lispy: layout?
20:02:08 <lispy> design
20:02:15 <dons> mututal recursion isn't so bad. ghc uses it a lot
20:02:23 <dons> i've got a few programs that use it.
20:02:32 <dons> often its more natural to have mutual recursion
20:02:35 <lispy> do you need an extension?
20:02:40 <dons> rather than merge everything into one big thingy
20:02:42 <dons> no
20:02:45 <dons> its h98
20:02:47 <lispy> i tried it today and it gave me an error
20:02:58 <dons> you need to use .hs-boot files in ghc :/
20:03:04 <dons> to break the fixpoint
20:03:16 <lispy> what are those?
20:03:17 <dons> well, to stop the loop, anyway
20:03:35 <dons> somehow you have to stop the loop of dependencies between modules
20:03:54 <dons> either the compiler can be clever and work it out, or ghc can be given a hint on where to start the dependency tracking
20:04:12 <LordBrain> is IO obsoleted by a heirarchical module?
20:04:51 <dons> System.IO  is the preferred name
20:05:28 <LordBrain> so System.IO obsoletes IO ?
20:05:39 <dons> I suppose so, yes.
20:05:44 <dons> IO is the old h98 name
20:06:25 <LordBrain> i find some of the nonhierarchical versions are less complete than the hieararchical ones.. thats why i say obsoletes.. they're not just two names for the same thing at least in some cases, i dont know about all
20:07:17 <lispy> oh that reminds me, should i prefer import Maybe or import Data.Maybe
20:09:02 <LordBrain> *shrugs* I'm guesssing we should we be prefering the *.* version whenever there is one
20:09:40 <LordBrain> but i'm no authority
20:11:13 <LordBrain> maybe stefan's coding style comes from portability concerns...
20:12:26 <LordBrain> @hoogle accept
20:12:27 <lambdabot> Network.accept :: Socket -> IO (Handle, HostName, PortNumber)
20:12:28 <lambdabot> Network.Socket.accept :: Socket -> IO (Socket, SockAddr)
20:12:44 <dons> a lot of people still code in h98 just because they never got used to the hier system
20:12:50 <dons> well, not a lot so much any more
20:13:10 <LordBrain> well maybe they're getting thrown by hoogle the way i am
20:13:23 <LordBrain> @hoogle+
20:13:34 <dons> yeah, hoogle's suggesting h98 imports. hmm.
20:16:36 * lispy goes for a walk
20:17:53 <LordBrain> @hoogle recv
20:17:54 <lambdabot> Network.Socket.recv :: Socket -> Int -> IO String
20:17:54 <lambdabot> Network.recvFrom :: HostName -> PortID -> IO String
20:17:54 <lambdabot> Network.Socket.recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
20:20:29 <SamB> @google BFInterpreter
20:20:32 <lambdabot> http://www.esoteric.sange.fi/brainfuck/impl/interp/BFI-VB/BFInterpreter.vbp
20:20:40 <SamB> @google site:haskell.org BFInterpreter
20:20:42 <lambdabot> http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter
20:20:43 <lambdabot> Title: "ShortExamples/BFInterpreter - The Haskell Wiki"
20:43:53 <freshhawk> newbie question - anyone know why i can't pass "floor $ int1 / int2" to a function that accepts Integrals? compiler complains about not being able to deduce RealFrac a, etc.
20:46:50 <dropdrive> freshhawk, what are you trying to do?  do you know about `div`?
20:47:41 <freshhawk> dropdrive: i do, i found it when this didn't work, but now that's driving me crazy.
20:48:24 <freshhawk> although i guess i can get the answer by looked at the source to div
20:48:31 <freshhawk> s/looked/looking
20:57:27 <dropdrive> freshhawk, if you figure it out, let me know.
20:58:31 <freshhawk> dropdrive: nope, prelude uses quotRem (makes sense) which looks to be built in. I was more worried about the fact that me not understanding that seemed to mean that i don't understand the type system well enough
21:00:15 <freshhawk> if floor takes a Fractional and returns an Integral shouldn't i be able to pass "(floor (x / y))" to a function accepting Integrals?
21:00:36 <freshhawk> the types seem to match up properly
21:00:58 <dropdrive> what is Int / Int?  I don't think it works...
21:01:20 <dropdrive> freshhawk: I'm obviously a novice, so I'm fumbling around...
21:01:41 <freshhawk> dropdrive: heh, me too
21:02:41 <freshhawk> > :t floor
21:02:41 <AtnNn> uhm, if you get an error about not being able to deduce RealFrac a, the problem isnt about Intrgrals
21:02:42 <lambdabot>  Parse error
21:02:44 <dons> there's some missing fromIntegrals, i suspect
21:02:51 <AtnNn> > 2 ^ (floor $ 4.0/1.5)
21:02:52 <lambdabot>  4
21:03:02 <AtnNn> @type floor
21:03:03 <dons> > (1 :: Int) / (2 :: Int)
21:03:04 <lambdabot>  add an instance declaration for (Fractional Int)
21:03:04 <lambdabot>   In the definition of `...
21:03:04 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:03:09 <dropdrive> > let a = 1::Int; b = 1::Int in a/b
21:03:11 <lambdabot>  add an instance declaration for (Fractional Int)
21:03:11 <lambdabot>   In the definition of `...
21:03:16 <dons> > (1 :: Int) `div` (2 :: Int)
21:03:17 <lambdabot>  0
21:03:23 <dons> > (8 :: Int) `div` (2 :: Int)
21:03:24 <lambdabot>  4
21:03:41 <dons> > (fromIntegral $ 8 :: Int) / (fromIntegral $ 2 :: Int)
21:03:42 <lambdabot>  add an instance declaration for (Fractional Int)
21:03:42 <lambdabot>   In the definition of `...
21:05:31 <freshhawk> if i tried to make my own div say called floorDiv :: (Integral a) => a -> a -> a, floorDiv x y = floor $ x / y -- why would that not work?
21:05:36 <freshhawk> @type (/)
21:05:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:05:43 <freshhawk> @type floor
21:05:45 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:05:58 <dons> because Integral a isn't the constraint on /
21:06:04 <dons> its Fractional
21:07:35 <freshhawk> but floor takes the fractional result of / and returns an integral
21:08:07 <freshhawk> i realize this is a dumb question, thanks for your help
21:08:21 <dons> but your arguments to floorDiv are Integrals, which you then apply to /
21:08:46 <dons> ?type (/)
21:08:48 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:08:56 <dons> but you have  floorDiv :: (Integral a) => a -> a -> a
21:09:27 <freshhawk> duh, the type mismatch is on the (/) not with the floor...
21:09:44 <freshhawk> thanks...perhaps i should get some sleep now.
21:10:19 <dons> > fromIntegral (1::Int) :: Float
21:10:20 <lambdabot>  1.0
21:11:18 <dons> > let myDiv :: (Integral a) => a -> a -> a ; myDiv x y = floor $ (fromIntegral x) / (fromIntegral y) in myDiv 8 2
21:11:20 <lambdabot>  4
21:12:29 <dons> I always thought 'fromIntegral' was a bit too verbose, considering how often its needed. However, I suppose it helps us stay aware of the possible issues involved in converting our Ints to Floatified values
21:32:53 <dons> Lemmih: around?
21:32:55 <dons> @seen shapr
21:32:56 <lambdabot> I saw shapr leaving #haskell 9 days, 17 hours, 43 minutes and 40 seconds ago, and .
22:11:18 <johnnowak> lambdabot: and what?
22:14:06 <dons> and '.' of course
22:18:23 <johnnowak> hm.
22:22:43 <u221e> I had to leave for alittle while so I didn't see if my questions what answered... Is there a good sdl binding for haskell?
22:34:44 <u221e> Hm, hsSDL is in the music and sound sections of the libraries and tools page...
22:44:19 <skew> u221e: there are logs at http://tunes.org/~nef/logs/haskell/, as the topic says
22:44:20 <lambdabot> Title: "Index of /~nef/logs/haskell"
22:44:23 <skew> useful for catching up
22:45:29 <u221e> Ok, thanks.
22:46:24 <skew> I don't know about SDL bindings.
22:56:27 <yip> u221e: http://darcs.haskell.org/~lemmih/hsSDL/
22:56:29 <lambdabot> Title: "Index of /~lemmih/hsSDL"
22:56:58 <u221e> Yes I already found that package.
22:58:25 <yip> it's good :)
22:59:01 <u221e> Hey If I'm using binary ghc 6.4.1 and build and install a more current version, will the packages still work in both?
22:59:16 <dons> nope
22:59:32 <dons> you need to rebuild them
22:59:49 <u221e> Bah!
23:00:25 <dons> its not surprising, I think. considering all the cross-module optimistations, and library improvements.
23:00:31 <u221e> So I can't install two different versions of ghc?
23:00:43 <dons> sure you can
23:00:58 <dons> $ ghc-*
23:00:58 <dons> ghc-6.2.2      ghc-6.4.1      ghc-6.5        ghc-pkg-6.2.2  ghc-pkg-6.4.2  
23:00:58 <dons> ghc-6.4        ghc-6.4.2      ghc-pkg        ghc-pkg-6.4.1  ghc-pkg-6.5
23:01:00 <dons> :)
23:02:37 <u221e> I mean how do compile packages for the different versions.
23:03:25 <dons> well, if they use a cabal build system, then everything should go just fine:
23:03:26 <dons> $ pwd
23:03:26 <dons> /home/dons/lib/fps-0.7
23:03:26 <dons> $ ls
23:03:26 <dons> ghc-6.4.2 ghc-6.5
23:03:39 <dons> since cabal will put them into a different subdir based on which compile you use
23:06:11 <u221e> Is 6.5 relatively stable?
23:06:35 <dons> relatively, yes.
23:06:54 <dons> but there's no real reason to use it, and you can expect some packages not to support the library changes that have happened
23:08:03 <u221e> Is 6.4.2 much better then 6.4.1?
23:08:13 <dons> 6.4.2 is a bug fix version of 6.4.1
23:08:20 <dons> and the odd performance wibble is fixed
23:08:34 <dons> so, its better, but not `much' better, I'd say.
23:08:50 <dons> likely is that you'll never notice the difference
23:09:42 <u221e> I wonder why 6.4.1 is the current package in my ubuntu repository
23:14:13 <lisppaste2> Ronald Mai pasted "nested monad" at http://paste.lisp.org/display/22277
23:38:03 <Lemmih> dons: pong
23:41:51 <dons> do we know if shapr submitted his review?
23:43:23 <Lemmih> No, we don't /-:
23:44:04 <Lemmih> dons: Heard from ChilliX?
23:44:22 <skew> review of what?
23:44:31 <dons> yep, he's submitted it.
23:44:47 <dons> any idea about JaffaCake or SyntaxNinja?
23:45:20 <dons> skew, SoC mid-term reviews
23:46:08 <Lemmih> SyntaxNinja is done, haven't heard from JaffaCake.
23:46:11 <Lemmih> @seen JaffaCake 
23:46:12 <lambdabot> JaffaCake is in #haskell. I last heard JaffaCake speak 2 days, 18 hours, 12 minutes and 53 seconds ago.
23:46:36 <Lemmih> I'll mail the missing parties.
23:46:40 <dons> ok, that's the only two then. shapr and JaffaCake
23:48:49 <dons> i notice we still can't work out from the web interface what's been submitted (I thought they said they'd fix that?)
23:50:10 <Lemmih> dons: They'll give us a list of missing evaluations after the deadline.
23:50:47 <dons> ah, ok. _after_ the deadline, eh?
23:50:48 <Lemmih> Plus some time to track down the mentors, I think.
23:51:10 <dons> cool, yeah, that's what i suspected
23:52:28 <Lemmih> Notification to Shae and Simon sent.
23:53:03 <dons> cheers
23:53:59 <Lemmih> Do you think they just forgot to tell they're done? JaffaCake /must/ have seen either the mails or his lambdabot msg.
23:55:13 <dons> he saw the msg that he had a lambdabot msg, but I'm not sure he realised it was a new one that needed reading.
