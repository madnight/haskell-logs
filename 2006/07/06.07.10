00:17:55 <u221e> What does newIORef do?
00:18:16 <dons> creates a new IORef
00:18:48 <boegel> dons: the insight!
00:18:48 <u221e> Heh. What is an IORef ;)
00:19:01 <dons> oh, it's a pointer to a mutable cell, u221e 
00:19:16 <dons> that is, a mutable variable available in the IO monad
00:19:20 <u221e> Um... is that allowed?
00:19:24 <dons> it has an equivalent, STRef, in the ST monad.
00:19:36 <dons> yes, since the monad preserves ordering of actions, making it safe to use
00:20:07 <dons> i.e. newIORef >>= writeIORef 'x' >>= readIORef has a defined order that makes sense
00:20:13 <dons> hooray for monads
00:21:05 <dons> sometimes mutable cells are a useful data type, after all
00:25:15 <dons> i should call them 'mutable cells', not mutable variables. they're not 'transparent' mutable variables, you have to access them via an api, and stay in io
00:32:02 <u221e> I still don't really get how to use monads.
00:33:58 <dons> do x <- newIORef "foo " ; r <- readIORef x ; print r  :)
00:34:17 <dons> the easiest way is to just play with IO, forget about the word monad for a while, and use do notation
00:34:41 <u221e> That's what I have been doing.
00:34:47 <dons> just imagine your programming in some sublime imperative language with this cool, high-assurance pure expression part
00:35:55 <dons> they'll sink in bit by bit. remember that, after all, you're learning a new abstraction -- monads -- that abstract over the sequencing of computations themselves
00:36:04 <dons> pretty highlevel funky stuff, unlike anything out there
00:36:52 <dons> esp. if you've been born and raised in strictly imperative programming, the idea that you can even abstract over the sequencing of operations is bizarre/too hard/brain explodes
00:37:37 <dons> however, with time, the brain swelling subsides, the migraines leave, and you just get about the job of high level programming in the 21st century
00:37:55 <u221e> Well, I've never really used an fp language before... not even lisp.
00:38:07 <dons> one of the few things that come close to monads are callcc/continuations
00:38:12 <dons> which already most languages don't have
00:38:24 <EdwardKmett> yeah
00:39:05 <dons> the rules are all changed in haskell. everything is up for abstraction, and that means lots and lots of expressivity, but also lots of tricky concepts
00:39:07 <EdwardKmett> monads are probably the most elegant language construct i've seen in a long time
00:39:22 <EdwardKmett> maybe arrows
00:39:31 <EdwardKmett> but its harder to find immediate programmatic uses for arrows
00:39:42 <dons> EdwardKmett: especially once you see things like the backtracking, non-deterministic monads used to implement, say, prolog in a few lines.
00:39:52 <EdwardKmett> yeah
00:40:42 <paolino> mmh can you explain me what the function readsPrec from class Read should produce  , please?
00:40:46 <EdwardKmett> the first bit of code i did in haskell when i got back to it was started banging out a prolog-wannabe and proved a bunch of random stuff with the non-determinism monad =)
00:40:48 <dons> arrows are great for functional reactive programming. Frag might be one of the most visible cases, http://www.haskell.org/haskellwiki/Frag. But I agree, arrows seem to be used in more specialised problems
00:40:50 <lambdabot> Title: "Frag - HaskellWiki"
00:41:00 <u221e> I think I'll read the "All about monads" tutorial.
00:41:12 <EdwardKmett> All about monads is a great tutorial
00:41:13 <dons> ?type readsPrec
00:41:14 <lambdabot> forall a. (Read a) => Int -> ReadS a
00:41:33 <dons> paolino: probably an example of the use of readsPrec might be better
00:42:01 <paolino> I'm trying to undestand http://www.nomaware.com/monads/examples/example4.hs
00:44:34 <paolino> *Main> :t readsEntry
00:44:35 <paolino> readsEntry :: ReadS Entry
00:44:51 <paolino> it produces nothing ?
00:45:35 <u221e> Another thing I'm used to is printing strings to the stdout for debugging, but I don't think I can do that within the non monad parts of the program.
00:46:23 <EdwardKmett> u221e: one thing that helps compensate for that is that if it passes type-check its probably doing the right thing =)
00:46:43 <mauke> @index trace
00:46:43 <lambdabot> Debug.Trace
00:47:12 <paolino> *Main> readsEntry "paolo=studia\n2"
00:47:13 <paolino> [("paolo" = "studia","\n2")]
00:47:13 <paolino> lokks  like it does 
00:48:27 <dons> yeah, use 'trace'
00:48:59 <dons> though with ghci, and the ability to test individual components of your code, this is less useful than in languages without interactive environments
00:50:44 <paolino> dons, must I understand alone ?
00:51:34 <dons> paolino: oh, you want help with reads functions?
00:52:07 <paolino> probably
00:52:28 <paolino> I don't seem to catch that type
00:53:03 <dons> generally you never have to manipulate reads* functions directly, you just derive Read
00:53:17 <dons> so if you're interested, probably the best thing to do is read GHC/Read.lhs
00:53:24 <dons> ?fptools GHC.Read
00:53:24 <lambdabot> GHC.Read not available
00:53:28 <dons> ?fptools Data.List
00:53:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
00:53:37 <dons> http://darcs.haskell.org/packages/base/GHC/List.lhs
00:53:39 <dons> I think
00:53:47 <dons> http://darcs.haskell.org/packages/base/GHC/Read.lhs, I mean
00:54:03 <dons> yes, ^^
00:55:08 <paolino> dons .. why they implemented readsPrec there ?
00:56:12 <paolino> I think deriving from Read without a function implementation was not enough
00:58:49 <EdwardKmett> catching a few hours sleep.
00:58:56 <EdwardKmett> be back in a few hours
01:03:00 <rob-d> who *
01:03:02 <rob-d> gak
01:03:48 <rob-d> since i'm awake, is there a standard way of handling matrices in haskell?
01:04:24 <dons> well, if they're small, a list of lists would do it. otherwise consider the Array library
01:04:54 <dons> failing that, you can ask on haskell-cafe@haskell.org, where there's a few matrix-hackers looking to port high-perf physics/math matrix libraries to haskell 
01:05:14 <dons> there may already be some matrix libs, check haskell.org under 'libraries and tools'
01:05:23 <dons> in particular, look in 'math' and 'data structures'
01:05:24 <paolino> readsEntry :: ReadS Entry
01:05:25 <paolino> Reads Entry is the output type ?
01:05:48 <dons> well, it's not a function, it takes no arguments, so its a constant of some sort.
01:06:39 <rob-d> dons: thanks
01:06:47 <paolino> readsEntry s = [(Entry (trim key) (trim val), s'') | (key, s')    <- [break (=='=') s],                                                      (x:val, s'') <- [break (=='\n') s'] 
01:06:59 <paolino> s is not its argument ?
01:07:12 <dons> ah, ReadS is hiding the function type
01:07:26 <paolino> eh ?
01:07:38 <dons> the thing about ReadS is that for efficiency purposes it uses function composition, rather than string concatenation, to join strings
01:08:00 <dons> so it builds up a hugh function that when applied generates the output, rather than doing bit by bit, using ++ to compose the output
01:08:09 <mauke> uh? I thought read was for input
01:08:19 <dons> ah, other way around.
01:08:27 <dons> s/out/in/
01:09:14 <dons> anyway, it's doing this marginally tricky thing with function composition, iirc. you'll have to read the Read documentation and src, paolino 
01:09:19 <dons> ?docs Text.Read
01:09:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
01:09:22 <dons> ?docs Text.Read.Lex
01:09:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Read-Lex.html
01:11:17 <paolino> k
01:11:33 <dons> ReadS is a thing of String -> something or other, iirc.
01:11:55 <mauke> String -> [(a, String)] IIRC
01:12:23 <dons> yeah, that looks like it.
01:12:25 <dons> @hoogle readS
01:12:26 <lambdabot> Prelude.reads :: Read a => ReadS a
01:12:26 <lambdabot> Prelude.ReadS :: type ReadS a
01:12:26 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
01:12:30 <dons> @hoogle ReadS
01:12:30 <lambdabot> Prelude.ReadS :: type ReadS a
01:12:30 <lambdabot> Prelude.reads :: Read a => ReadS a
01:12:30 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
01:12:35 <dons> ah, doesn't tel us
01:13:28 <mauke> > reads "123 456" :: ReadS Int
01:13:29 <lambdabot>    Expecting a function type, but found `[(a, String)]'
01:13:29 <lambdabot>    Expected type...
01:13:33 <mauke> er, ok
01:14:24 <dons> > reads "123" []
01:14:25 <lambdabot>    The function `reads' is applied to two arguments,
01:14:25 <lambdabot>   but its type `Read...
01:14:34 <dons> yeah, read fooey
01:14:47 <paolino> how can it hide the function type ?
01:14:52 <mauke> > (reads :: ReadS Int) "123 456"
01:14:53 <lambdabot>  [(123," 456")]
01:15:20 <mauke> type ReadS a = String -> [(a, String)]
01:16:01 <dons> paolino: you'll need to read up on parser combinators to understand how read in implemented
01:16:09 <dons> ?docs Text.ParserCombinators.ReadP
01:16:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
01:16:26 <dons> -- | A parser for a type @a@, represented as a function that takes a
01:16:26 <dons> -- 'String' and returns a list of possible parses as @(a,'String')@ pairs.
01:16:26 <dons> --
01:16:26 <dons> -- Note that this kind of backtracking parser is very inefficient;
01:16:26 <dons> -- reading a large structure may be quite slow (cf 'ReadP').
01:16:28 <dons> type ReadS a = String -> [(a,String)]
01:17:22 <dons> so every ReadS is really a functoin from String to some 'a's, with any left over strings
01:17:40 <dons> interestingly, newtype ReadP a = R (forall b . (a -> P b) -> P b)
01:25:20 <paolino> what is the category of ReadS? A parametric funtion type ?
01:26:17 <paolino> how should I call it ?
01:27:55 <paolino> nm , I don't do it 
01:45:42 <xerox> :)
01:55:24 <mnislaih> JaffaCake ping
01:55:45 <mnislaih> are you there? I just saw your response
01:56:19 <JaffaCake> mnislaih: yes, hi
01:56:39 <mnislaih> I have a doubt, if you can spare a second
01:56:53 <mnislaih> is the output of the desugarer annotated with srclocs ?
01:57:18 <mnislaih> we want to be giving information about code locations and such
01:57:47 <JaffaCake> mnislaih: no, but the input *to* the desugarer has srclocs in it
01:58:04 <mnislaih> ah, I see.
01:58:05 <JaffaCake> I think it might be easier to add breakpoints during desugaring
01:58:15 <mnislaih> that's perfect then
01:58:30 <JaffaCake> take a look at how -auto-all works
01:58:51 <mnislaih> oki
01:58:55 <mnislaih> thanks
01:59:02 <JaffaCake> np, good luck
01:59:25 <Igloo> JaffaCake: Did you see my messages?
01:59:56 <JaffaCake> Igloo: no....
02:00:06 <JaffaCake> haven't read all my mailboxes yet today tho
02:00:25 <Igloo> IRC messages
02:00:45 <JaffaCake> oh, sorry
02:00:49 * JaffaCake looks
02:10:57 <Lemmih> mnislaih, JaffaCake: Note that the desugarer doesn't have access to the local scope.
02:11:36 <mnislaih> that will be a showstopper then
02:11:58 <mnislaih> the renamer is very convenient for that reason
02:12:17 <mnislaih> btw Lemmih, did you manage to look at the issue with local bindings?
02:12:22 <Lemmih> Yeah, I don't think you can bypass the renamer.
02:12:36 <Lemmih> mnislaih: I can give it a look now.
02:13:06 <mnislaih> I haven't fixed it, but I can give you some details
02:16:56 * tennin is reading the Haskore tutorial paper... "The possibility of expressing other scale types instead of the thus far unstated assumption of standard equal temperament scales is another area of investigation."
02:17:10 <tennin> anyone know if this investigation has yet borne fruit?
02:18:38 <bringert> @seen shapr
02:18:38 <lambdabot> I saw shapr leaving #haskell 10 days, 22 hours, 29 minutes and 24 seconds ago, and .
02:19:04 <bringert> has he ever been offline this long?
02:20:43 <dons> yeah, once i think
02:20:56 <dons> but he's moved towns, so i suppose it 'tis to be expected 
02:25:49 <Lemmih> mnislaih: How do you trigger it?
02:26:11 <mnislaih> put a breakpoint inside a let or where
02:38:19 <Lemmih> mnislaih: Hm, pretty weird.
02:38:38 <mnislaih> did you see my messages about this the other day ?
02:39:12 <mnislaih> I think it is because the binder is included in the captured list of bindings
02:41:49 <Lemmih> mnislaih: Yeah, removing the binder "solves" it.
02:42:12 * Lemmih heads off to buy groceries.
02:47:41 <nealar> @tell shapr I have a short text "why use arrows for parsers", but it is in russian =)
02:47:41 <lambdabot> Consider it noted.
03:14:43 <Nanar> hemm stupid question, what the character for comment in haskell ?
03:15:19 <ibid> there is no signle character
03:15:27 <u221e> --
03:15:28 <ibid> there is -- and {-...-}
03:15:35 <Nanar> ok thanks
03:15:48 <Nanar> -- like sql
03:16:47 <u221e> If I have a function that builds a finite list, can I have the whole thing built in a strict manner?
03:24:37 <dons> yes, by forcing the list (i.e. by evaluating its length0
03:24:55 <dons> however, relying on the order of evaluation is a nasty and error prone business :)
03:25:57 <roconnor> one doesn't really _rely_ on the order of evaluation.  One is just trying to optimise memory use.
03:29:46 <u221e> The only why that I can thing of is to have another function strictList that would go and access every element of the list that it can.
03:36:10 <eivuokko> Eeek. Function body of 31 lines and 11 lines of where.
03:43:31 <dons> roconnor: oh, yeah. i was thinking of some programs that do indeed rely on the order. (s <- readFile "x" ; writeFile "x" (f s))
03:43:50 <dons> you do need to force the list sometimes just to get `correct' behaviour
03:45:24 <u221e> What does unsafeChr mean?
04:06:35 <roconnor> dons: I've never liked that.  Isn't the semantics of readFile broken.
04:06:45 <roconnor> broken?
04:06:50 <dons> well, using files as mutable variables is broken :)
04:08:24 <roconnor> what do you mean by files as mutable variables?
04:08:54 <dons> reading and writing back to the same file
04:09:04 <dons> ie. like a mutable cell in memory
04:09:04 <roconnor> right
04:09:34 <dons> unsurprisingly, there's issues with laziness/interleaving
04:09:36 <roconnor> the semantics ought to be to delay reading a file until the file is written, then read it into memory.
04:09:54 <roconnor> but monads solve all that interleavingness (more or less)
04:10:10 <roconnor> It is clear what you example code ought to do.
04:10:22 <roconnor> and it could do what it ought to do.
04:10:31 <dons> well, not with lazy io , it's lazy io allowing interleaving of reads and writes on the same file that's problematic
04:10:32 <roconnor> I don't really understand why it doesn't.
04:10:40 <roconnor> exactly
04:10:53 <dons> but that's using unsafeInterleaveIO underneath, so problems could be expected
04:10:54 <roconnor> it seems like it would be easy to change.
04:11:19 <roconnor> we need a new System.IO!
04:11:22 <dons> hehe
04:11:30 <roconnor> who's with me!
04:12:12 <roconnor> ... anyone?
04:23:16 <u221e> What function grabs specific element of a list? I assume it's just a shortcut for using head and tail
04:23:46 <mikael> @type (!!)
04:23:47 <ski> > "abcde" !! 2
04:23:48 <lambdabot> forall a. [a] -> Int -> a
04:23:48 <lambdabot>  'c'
04:24:38 <u221e> Heh, thanks.
04:27:07 <ski> roconnor : if you mean 'readFile' should conceptually capture the state of the file at the point of running the action (but implementation-wise probably wait until forced or file modified), then i agree
04:27:35 <ski> (btw, isn't this semantics remniscent of 'DiffArray' ?)
04:29:28 <roconnor> what is Lenient evaluation?
04:32:23 <u221e> How do I turn a String such as "42" into an Int
04:34:05 <lorne> > read 42 :: Int
04:34:06 <lambdabot>  add an instance declaration for (Num String)
04:34:12 <lorne> > read "42" :: Int
04:34:12 <ski> > read "42" :: Int
04:34:12 <lambdabot>  42
04:34:13 <lambdabot>  42
04:36:16 <kzm> From FPS docs: isSubstringOf p s is equivalent to not (null (findSubstrings p s)).
04:37:00 <kzm> Why not 'isJust . findSubstring p'?
04:37:36 <kzm> Hmm.. I perhaps the null terminates as early.  Never mind.
04:37:38 <roconnor> :hoogle findSubstring
04:37:42 <roconnor> @hoogle findSubstring
04:37:43 <lambdabot> No matches found
04:37:48 <kzm> Don't think hoogle indexes FPS yet.
04:38:07 <kzm> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-ByteString.html
04:38:29 <kzm> about two-thirds to the bottom of the page.
04:47:27 <dozer> I'm having trouble compiling SYB3 with ghc 6.5
04:47:45 <dozer> the mailing list told me that I probably needed to add some forall statements
04:47:48 <dozer> but forall confuses me
04:48:17 <dons> kzm, right, i need to add fps to the hoogle index
05:02:46 <moonfish> how can I get my ghc-compiled programs to display source locations when they exit with an error like, say, "Maybe.fromJust: Nothing"?
05:03:09 <dons> you can use 'assert', instead
05:03:18 <dons> ?hoogle assert
05:03:19 <lambdabot> Control.Exception.assert :: Bool -> a -> a
05:03:19 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
05:03:19 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
05:04:32 <dons> i also have a trace() that does a similar thing, http://www.cse.unsw.edu.au/~dons/tmp/Location.hs
05:04:56 <dons> so I suppose what you need is to find where you're doing a fromJust, and add an assert on those cases
05:05:00 <u221e> Is it posible to have just an 'if-then' statement?
05:05:10 <dons> in the IO monad, yes
05:05:13 <dons> it's called 'when'
05:05:18 <earthy> u221e: what would the type be?
05:05:25 <dons> when (x == 10) $ do print "yes"
05:05:42 <dons> yeah, the type is the issue :)
05:05:48 <moonfish> dons, err, that's exactly my problem though: I want to find out where I am calling fromJust!
05:05:58 <mux> you don't even need the "do" here, do you?
05:06:13 <ski> right
05:06:14 <u221e> when, eh? So many things to learn....
05:06:19 <dons> moonfish: you'll have to find the fromJust (use 'grep') and replace them with assert . fromJust
05:07:13 <moonfish> so there is no general way to have exceptions display their source location?
05:07:15 <dons> mux, yes, 'do' is optional, it's easier to read with 'do' though for didactic purposes
05:07:30 * mux nods
05:07:36 <dons> moonfish: there is. see http://www.cse.unsw.edu.au/~dons/tmp/Location.hs
05:07:41 <dons> but it's not been implemented yet :)
05:07:51 <dons> perhaps we should think about how to do that.
05:08:33 <dons> a locationable-exception could use either TH, or cpp, or a preprocessor, or 'assert'
05:08:37 <dons> all would work
05:09:43 <u221e> What module is 'when' in?
05:10:16 <eivuokko> @hoogle when
05:10:17 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
05:10:17 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
05:10:40 <moonfish> dons: but that would still involve changing all the code locations that may raise an error, right?
05:10:58 <dons> yes
05:11:17 <u221e> I got to learn how to use lambdabot
05:11:37 <moonfish> that's gross.
05:11:54 <eivuokko> u221e, hoogle's also available at haskell.org/hoogle
05:11:57 <dons> well, how many occurences of 'fromJust' are there in your code?
05:12:06 <dons> 10?
05:12:13 <ski> @vixen meet u221e
05:12:13 <lambdabot> Tell me truthfully what the nastiest thing you have ever done.
05:13:45 <moonfish> dons: not many, but what about all the libraries I am using?
05:13:51 <u221e> Hoogle sure looks useful.
05:14:41 <dons> moonfish: so, a quick fix is to manually replace all fromJust's with: (\x -> GHC.Base.assert (x /= Nothing) (Maybe.fromJust x))
05:15:07 <dons> then if its a library, you need to look at the Maybe values you're using, i suppose it could be in a library (but less likely)
05:15:49 <moonfish> it's not just about Maybes though but any exceptions that might get thrown by my code or library code.
05:16:10 <dons> oh, if you want to use locations in all your exceptions, yeah
05:16:29 <dons> perhaps we should have an exceptoin that prints locations if compiled with --asserts or something
05:16:32 <dons> that'd be useful
05:18:48 <moonfish> dons: it would be very useful indeed. I am struggling to see how I could live without it since nearly every PL implementation I've used over the last 15 years does this.
05:19:33 <dons> yeah, i wonder why it hasn't been an issue. i suppose static typing rules out the large majority of bugs, so you don't spend time hunting unknown failures
05:20:03 <dons> additionally, you shouldn't be using, e.g. fromJust, but instead case / fromMaybe with an error condition
05:20:36 <moonfish> dons: yeah, I know. But unexpected things do happen.
05:20:50 <dons> anyway, its easy enough to add locations to failures to any exceptions in your code, just use the cpp line pragma
05:21:08 <dons> but its an interesting issue. i might look into it.
05:30:06 <dons> moonfish: here's a useful function for you: http://www.cse.unsw.edu.au/~dons/tmp/Exception.hs
05:30:19 <dons> *Exception> locatedError "my failure" assert
05:30:20 <dons> *** Exception: <interactive>:1:26-31: my failure
05:30:49 <dons> it needs the magic 'assert' token as a second argument, as a trickys way to find the current line
05:32:54 <moonfish> dons: thanks, I will play with that later. I am still somewhat astonished that the GHC compiler/runtime doesn't do this kind of thing automatically, at least when -debug is turned on.
05:33:32 <dons> i think pattern match failures report line numbers
05:33:39 <dons> > case Nothing of Just _ -> False
05:33:40 <lambdabot>  Non-exhaustive patterns in case
05:33:48 <dons> oh, lambdabot dropped the line
05:33:58 <dons> case Nothing of Just _ -> False
05:33:59 <dons> *** Exception: <interactive>:1:0-30: Non-exhaustive patterns in case
05:34:07 <dons> so some failures do
05:34:38 <dons> but fromJust throws error, which doesn't have line numbers
05:34:46 <dons> perhaps there should be some debugError, as I suggest.
05:34:51 <ihope_> So this FFI thing still isn't working.
05:36:02 <dons> so you have to be unlucky, i suppose, to use something that throws 'error'
05:37:33 <dons> moonfish: it would be worth writing an email to haskell-cafe@haskell.org querying this. I can think of a few solutions, such that error becomes locatedError, but maybe someone's already thought about this
05:43:35 <marc_vw> ping
05:44:17 <Lemmih> pong?
05:45:09 <marc_vw> ack!
05:45:45 <cjay> drop
05:46:12 <sieni> nak
05:49:41 <marc_vw> fin
05:53:15 <u221e> ghc is giving me an error and I can't figure out why...
05:53:30 <u221e> The error message are very unhelpful.
05:53:47 <Igloo> What error?
05:53:47 <dons> what's the error?
05:53:49 <dons> ?paste
05:53:49 <lambdabot> http://paste.lisp.org/new/haskell
05:55:20 <lisppaste2> u221e pasted "Error" at http://paste.lisp.org/display/22348
05:55:40 <gour> Lemmih: anything new with hide?
05:55:58 <dons> looks like there's a missing argument to your function, u221e 
05:56:17 <dons> ghc thinks it should be [Pixel], but it actually has a function type, t -> t1
05:56:29 <dons> ie. it needs to be applied to another argument
05:56:41 <dons> beyond that, I couldn't say, without seeing the code
05:56:44 <ihope_> Yeah, can you post the code?
05:57:03 <Lemmih> gour: Hope.
05:57:08 <Lemmih> *Nope.
05:57:36 <gour> Lemmih: hmm...Hope is a lot
05:57:47 <u221e> ... I just found my error... stupid too.
05:57:52 <gour> Nope not so much
05:58:17 <Lemmih> gour: Yeah, I wish we had some new hope.
05:58:19 <dons> u221e: in hindsight, i hope that error msg isn't so bad. it's a fairly good one, as far as ghc goes.
05:58:22 <dons> @ghc
05:58:23 <lambdabot>  At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
05:58:27 <dons> @ghc
05:58:27 <lambdabot>  The signature contexts in a mutually recursive group should all be identical
05:58:29 <u221e> The type definition was wrong.
05:58:33 <dons> cool
05:58:39 <dons> @ghc
05:58:39 <lambdabot>  Non-type variables in constraint
05:58:44 <dons> see, could be worse :)
05:59:29 <xerox> ?type undefined :: Foo => a
05:59:30 <lambdabot> Not in scope: type constructor or class `Foo'
05:59:59 <gour> Lemmih: why 'no hope', i.e. what's the obstacle? visual haskell shows it's possible..
06:02:00 <Lemmih> gour: Visual Haskell is a cripple. We could abandon our plugin system but that wouldn't be fun.
06:03:19 <lisppaste2> ihope pasted "Argh!" at http://paste.lisp.org/display/22350
06:03:20 <gour> Lemmih: what about 'blind uncle is better than no uncle' ?
06:04:19 <dons> ihope_: don't test ffi stuff in ghci on windows :)
06:04:32 <ihope_> :-)
06:04:41 <dons> seriously though, maybe you're missing an object file on the command line?
06:04:55 <dons> oh, no, its worse: Not x86 PEi386
06:05:10 <Lemmih> gour: That only works when you're paid.
06:05:16 <ihope_> Did I booch the C compilation?
06:05:35 <dons> possibly? could it have been compiled in to some cygwin or something format?
06:05:37 <gour> Lemmih: so, All or Nothing?
06:05:47 <xerox> Just the best :)
06:05:57 <dons> ihope_: try with --make and a static object, not ghci
06:06:02 <dons> does that work/?
06:06:08 <dons> then try fancy dynamic loading/ghci games
06:06:11 <ihope_> ghc --make, you mean?
06:06:15 <dons> right
06:06:17 <vegai> dons: hey...
06:06:25 <vegai> http://www.real.com/linux/
06:06:26 <lambdabot> Title: "RealPlayer 10 for Linux &ndash; the best audio and video player &ndash; Real.com"
06:06:33 <dons> vegai?
06:07:10 <vegai> dons: I was wondering making some of the entities in that feature a bit more readable. Any snappy way to do that, you think?
06:07:18 <ihope_> C:/Documents and Settings/foobar/Desktop/Haskell FFI/ffitest-c.o: file not recognized: File format not recognized
06:07:23 <vegai> e.g. "&ndash" => "--"
06:07:34 <dons> oh, like un-html-encodifying it?
06:07:36 <vegai> &ndash; that is
06:07:49 <vegai> yeah
06:08:05 <nealar> is there a way to encode structure {int size; int array[size];} without dependent types?
06:08:19 <Lemmih> gour: Yeah. I do ugly hacks for a living; my spare time is reserved for fun and/or beauty (:
06:08:27 <dons> nealar: yep. using type classes and phantom types
06:08:54 <gour> Lemmih: i see. no trace of pragmatism :-)
06:09:09 <dons> vegai: can you send me a patch implementing unhtml, in front of the fetchTitle function, here http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Url.hs
06:09:11 <dons> ?
06:09:25 <dons> should be pretty easy to add the most common cases
06:09:45 <vegai> you think a simple replace will do?
06:10:03 <dons> i think a string matcher could do it pretty easy, yep
06:10:06 <Nanar> what is the proper name for this: rpmvercmp :: String -> String -> CInt, I know it is not prototype iirc ?
06:10:07 <dons> look for encoded tokens
06:10:24 <dons> type declaration, Nanar 
06:10:29 <Nanar> thanks
06:10:31 <vegai> all right, I'll write that down on my miraculously short todo-list
06:11:02 <nealar> dons: is there a guide for phantom types?
06:11:18 <dons> nealar: http://haskell.org/haskellwiki/Peano_numbers, http://haskell.org/haskellwiki/Phantom_type, http://haskell.org/haskellwiki/Dimensionalized_numbers and particularly http://haskell.org/haskellwiki/Smart_constructors
06:11:19 <lambdabot> Title: "Peano numbers - HaskellWiki"
06:11:31 <dons> ah, interesting. bug! :)
06:12:02 <dons> nealar: in the smart constructors article i develop a stripped down version of what you want, but it points to the article by Oleg that could just about get you there.
06:12:28 <dons> note that its not trivial. and perhaps a simple smart constructor would work, rather than an actual type-level natural
06:13:20 <ihope_> dons: so should I recompile ffitest-c.h?
06:13:26 <ski> Nanar : or 'type signature'
06:13:36 <xerox> http://dont.scream http://www.google.com
06:13:42 <xerox> heh.
06:13:49 <dons> ihope_: nope. ghc --make should do all the magic, shouldn't it? and gcc should produce the .o files
06:14:49 <alar> dons: do you mean Oleg's type-level arithmetic?
06:14:57 <dons> yeah.
06:15:21 * alar thinks that it's just dependent types from the backside
06:15:39 <dons> which , once you've got type level nats, you can link to constructors that set the type of the accompanying vector
06:15:43 <dons> oleg's articles do just this
06:15:57 <dons> well, you stay in h98, which ain't no dependent type system
06:16:11 <ihope_> When I give both the source files to GHC, I get "C:/Documents and Settings/foobar/Desktop/Haskell FFI/ffitest-hs.o(.text+0x44):fake: undefined reference to `_add'".
06:16:18 <alar> yes, I've followed Oleg and tried Ackermann at type level
06:16:25 <dons> and your terms can't really appear in types, they're mirrored. big difference
06:17:01 <dons> ihope_: you need to pass a missing -lfoo flag or .o file on the command line?
06:18:28 <ADEpt___> hello there
06:18:43 <ihope_> If I pass the C source file *and* its object file, I get "C:/Documents and Settings/foobar/Desktop/Haskell FFI/ffitest-c.o: file not recognized: File format not recognized".
06:18:58 <dons> let me code up an example
06:19:08 <dons> hey ADEpt___ , long time not chatification :)
06:19:29 <ermineq> ADEpt___: irc sucks
06:21:33 <ADEpt___> could anybody have any idea (including wild ones) as to why i am unable to enter as "adept" (or "ADEpt") or chane nickname to any of those?
06:22:00 <dons> hmm. someone got it? or a ghosted version of you?
06:22:34 <ADEpt___> dons: could you please as NickServ about current status of nick "adept" ?
06:22:56 <ihope_> Is adept@ukr.net your address?
06:23:03 <ADEpt___> ihope_: yes
06:23:08 <ADEpt___> ihope_: one of them
06:24:07 <ihope_> Okay, then "/msg NickServ GHOST adept password".
06:24:32 <dons> ihope_: so does this workfor you:
06:24:33 <dons> import Foreign.C.Types
06:24:33 <dons> main = putchar 65 >> putchar 10
06:24:33 <dons> foreign import ccall unsafe "stdio.h" putchar :: CInt -> IO CInt
06:24:46 <dons> if so, then we can try with a local .c file
06:25:10 <dons> $ ghc --make -ffi A.hs 
06:25:22 <alar> ADEpt: someone has taken your nick? I wasted some time overtaking alar as well :)
06:25:52 <dons> -- adept [i=adept@hektik.org]
06:25:58 <dons> says 'whois'
06:26:13 <ADEpt___> dons: seems like he did :(
06:26:21 <dons> but didn't you have a password?
06:27:07 <ihope_> dons: ghc --make didn't seem to produce an executable.
06:27:15 <dons> hmm?
06:27:21 <dons> well, that's very odd
06:27:25 <alar> say RECOVER adept
06:27:33 <alar> that RELEASE adept to NickServ
06:27:40 <ihope_> Why not just GHOST?
06:27:42 <ADEpt___> dons: i'm trying to figure out how to send message to nickserv currently (i'm behind jabber gateway)
06:27:50 <dons> ah, you can't /msg ?
06:28:06 <alar> ADEpt: /query NickServ doesn't work?
06:28:06 <ADEpt___> dons: yep
06:28:11 <ihope_> Well, can you /nickserv or /ns?
06:28:21 <alar> what's GHOST?
06:28:23 <ADEpt___> /nickserv help
06:28:39 <ermineq> huh-huh
06:28:52 <ADEpt___> ermineq: ;)
06:29:49 <ihope_> So you can't do anything except send messages to #haskell?
06:29:56 <ihope_> s/#haskell/channels/
06:30:03 <ADEpt___> ihope_: yep :)
06:30:16 <ADEpt___> ihope_: and to bots who speak to me first
06:30:19 <ihope_> Before or after the substitution? :-P
06:30:39 <ADEpt___> ihope_: after :)
06:30:42 <ermineq> ADEpt___: is that described in rfc irc?
06:30:47 <dons> ADEpt___: maybe fire up an irc client?
06:31:05 <ihope_> Yep, an IRC client would help.
06:31:05 <dons> steal back the nick, then go back to jabber
06:31:31 <ermineq> better to forgot irc
06:33:08 * ADEpt___ talked to nickserv
06:33:16 * ADEpt___ willt ry to change nick
06:33:55 <ihope_> adept's still alive.
06:34:30 <ADEpt___> ihope_: oops. wrong NickServ - from irc.debian.org :)
06:35:53 <alar> =))
06:36:13 <alar> ihope: how do you know adept's still alive?
06:36:20 <ihope_> alar: /whois.
06:36:21 * EdwardKmett waves ello.
06:36:27 <ADEpt___> alar: from "nickserv info" ?
06:37:08 <ski> hello EdwardKmett
06:38:37 <ADEpt_> test
06:38:49 <ihope_> 1, 2, 3?
06:39:12 <ADEpt_> yep :)
06:39:49 <ihope_> Huh. GHC simply fails to produce an executable.
06:40:18 <alar> ADEpt:nickserv info tells your status (the one who's registered adept) not the status of adept(the one who currently owns it)
06:43:39 <dons> ihope_: is gcc failing silently?
06:43:50 <dons> perhaps check with ghc -v4 that the correct gcc path is used
06:43:54 <dons> and try -fasm
06:44:12 <dons> if gcc's not working, surely the native gen will
06:44:37 * dons `id` sleep
06:45:03 <ihope_> "ghc -o test -fasm file.hs" still doesn't work...
06:45:05 <xerox> hah
06:46:47 * ADEpt_ thanks everyone present for their warm welcome :)
06:47:40 <ihope_> Hmm... I put C:\ghc\whatever\bin in the PATH environment and popped over to the "Haskell FFI" folder, and now it works.
06:47:42 <ihope_> Weird.
06:50:22 <u221e> How do I turn an Int into a String?
06:50:36 <ihope_> > show 3
06:50:37 <lambdabot>  "3"
06:52:03 <edwardk> was skimming the haskell wiki the other day and it grumbled a bit about some issues with using arrows for computation, but was really vague on specifics, anyone know more?
06:52:04 <u221e> I forgot about that...
06:53:10 <xerox> edwardk - Check out Shae's article on TMR (can't remember the #).
06:55:03 <edwardk> tmr = the monad reader right?
06:55:12 <ski> yes
06:55:51 <ski> (edwardk : which wiki page ?)
06:56:42 <edwardk> well,, i got stalled skimming the first page of issue 1, reading andrew bromage's article which rants about the same thing more or less
06:56:46 <edwardk> =)
06:57:54 <joelr1> howdy 
06:58:06 <joelr1> dons: how do i use a different stage for testing?
06:58:09 <ski> edwardk : 'issue 1' ?
06:58:25 <edwardk> oh
06:58:26 <edwardk> sorry
06:58:33 <edwardk> you meant the wiki page that ranted about arrows
06:58:40 <edwardk> might not have been on the haskell wiki lemme find it
07:01:54 <edwardk> hrmm
07:01:57 <edwardk> can't seem to find the page now =)
07:02:23 <edwardk> but it referenced that a number of people had run into problems using arrows as a computational tool. and referenced einar karttunen and a couple others
07:02:43 <edwardk> but i couldn't get anything more specific from the context. it sounded a lot like 'here be dragons' ;)
07:02:53 <ski> m
07:03:33 <joelr1> does anyone know how to use stage2 ghc when testing?
07:05:56 <ihope_> So what's ld?
07:05:57 * ski ponders if one could make some more applicative "internal language" for arrowful computations
07:11:50 <xerox> http://fooling.lambdabot http://www.haskell.org/tmrwiki/ArrowsIntroduction <- edwardk 
07:12:11 <xerox> ski - What does "more applicative" mean?
07:12:39 <ihope_> Um, is http://fooling.lambdabot a valid URL?
07:12:47 <edwardk> there we go =)
07:12:58 <edwardk> reove the lambdabot fooling part and enter it =)
07:13:05 <edwardk> er remove
07:13:29 <ihope_> I don't think http:// is a valid URL either.
07:14:16 <xerox> http:// http://www.google.com
07:14:20 <ski> xerox : well, something structured more like ordinary expressions with applications inside, as opposed to a 'do'-like sequence
07:15:02 <xerox> I never got around _using_ |returnA ..|
07:15:18 <ski> hm ?
07:15:23 <edwardk> xerox: thanks, btw
07:16:12 <ski> (but let me check the current bnf first ..)
07:18:46 <edwardk> ski: you know, i don;t really have much of a problem with the current arrow syntax. the <-x-< notation is quite slick
07:19:12 <edwardk> their category theoretic nature didnt quite click for me fully until i saw the sugar =)
07:19:50 <ski> mhm (i wasn't suggesting removing that syntax)
07:20:08 <ski> i just got some vague ideas for a possible alternate
07:20:11 <edwardk> *nods*
07:21:16 <dmhouse> What are you discussing? It sounds interesting.
07:21:24 <ihope_> http://www.haskell.org/tmrwiki/ArrPipe <- why not just restrict the Process type to Readables and Showables?
07:21:25 <lambdabot> Title: "ArrPipe - TmrWiki"
07:22:24 <edwardk> the arrpipe is an awkward example because those pipes don't really behave in a category theoretic way
07:22:29 <ski> dmhouse : just some re arrows
07:22:57 <edwardk> so while the notation may be appropriate, and could be used as a monad sorta hackishly, they don't meet the arrow criteria
07:23:04 <edwardk> at least as far as i can see
07:23:10 <edwardk> then again
07:23:20 <edwardk> maybe i have too limited a view of what arrows should be used for
07:23:24 <edwardk> and need to be enlightened
07:23:50 <ski> what criteria don't they meet ?
07:24:18 <edwardk> heh now i have to go make that rigorous =)
07:24:22 <edwardk> gimme a sec
07:25:33 * ski smiles
07:26:18 <edwardk> my understanding is that you need to be able to construct an arrow over all types, but the definition required to make arrpipe is limited to readable & showable types
07:26:52 <ski> ah, ok
07:27:11 * ski has not looked at 'ArrPipe', he thinks
07:27:41 <edwardk> it seems to me to be related to the functor problem i was babbling on about the other day, the llimited subset available via the api is useful but not the full spectrum of possible types
07:27:55 <ski> so possibly it makes a category over a subtype of '*', then .. hm
07:28:12 <ski> s/subtype/subkind/
07:28:21 <edwardk> yeah, a form of limited arrow might be more useful than the general construction
07:29:43 <ski> or having kind arguments to type classes ("kind-polymorphic type classes") (i have no idea if this could be made to work, no)
07:29:57 <edwardk> hrmm
07:30:02 <ski> re u221e
07:30:26 <u221e> dons, you still around?
07:30:37 <ski> class Arrow k (ar :: k -> k -> k) where ...
07:31:10 <edwardk> wonder if it can't just be hacked out by making a general rule match to undefined or whatever and a specific rule match Show a, Read b => (b -> c) -> a b c
07:31:23 <ski> * dons `id` sleep
07:31:23 <ski> (46 minutes ago)
07:31:26 <edwardk> not sure about haskell's type system though. kinda new here =)
07:31:28 <u221e> Damn...
07:31:55 <u221e> I wanted to tell him that I improved his mandelbrot program for the shootout ;)
07:31:59 <edwardk> coz the specification for arrpipe given in that is a little more general than it needs to be
07:32:12 <edwardk> since you only need to read for sinks and show for sources
07:32:21 <ski> (u221e : maybe there's a wiki page you could add a notice to ?)
07:32:23 <edwardk> not all pipe types have to be both a sink and a source.
07:32:50 <ski> right
07:32:52 <SamB> hmm. so how do you do sinks and sources?
07:33:06 <edwardk> ok, playing here =)
07:33:15 <edwardk> going to test the idea real fast
07:33:18 <edwardk> might work
07:33:22 <edwardk> might show me i'm an idiot
07:33:28 <edwardk> either will be informative
07:33:32 <dmhouse> u221e: you could @tell him :)
07:33:52 <ski> (hm, though on quick look i don't see they do that ..)
07:34:30 <u221e> ... 4 seconds faster on my computer :o
07:35:20 <dmhouse> u221e: is that 4 seconds faster than the original run on your system, or 4 seconds faster than the submitted time?
07:35:37 <u221e> On my system
07:35:38 <ihope_> @djinn ((a -> b) -> a -> c) -> b -> c
07:35:38 <lambdabot> -- f cannot be realized.
07:35:49 <dmhouse> u221e: nice :)
07:36:09 <ihope_> @djinn ((a -> b) -> a -> c) -> a -> b -> c
07:36:09 <lambdabot> f a b c = a (\ _ -> c) b
07:36:24 <dmhouse> u221e: That'd bring it down to... 3rd place?
07:36:28 <ihope_> The reverse of (a -> b -> c) -> (a -> b) -> a -> c :-)
07:36:31 <dmhouse> u221e: how did you improve the time?
07:36:59 <u221e> Removing some unnecessary function arguments
07:37:09 <edwardk> and of course my network connectivity to my linux box is shot. 1000+ms ping times.
07:37:15 <edwardk> going to load it up in visual haskell =/
07:37:22 <ski> ihope_ : not iso
07:38:59 <ski> (ihope_ : 'S' uses contraction, so "normally" that shouldn't be an iso)
07:39:00 <u221e> Didn't think it would make that much of a difference though.
07:39:35 <ihope_> Is there an inverse of S?
07:39:52 <ski> i think not
07:40:21 <ski> (well, if the morphisms are effectful, there could be, i think)
07:40:35 <ihope_> If what?
07:41:24 <ski> hm, maybe i could try that
07:41:51 <ski> if 'a -> b' function space is not pure function space, but has effects (vaguely speaking)
07:44:39 <ihope_> Okay...
07:51:30 <ski> (i think it can maybe be made to work, if we assume 'amb' and continuations ..)
07:52:15 <edwardk> ski: lost you there
07:52:34 <ski> which part ?
07:52:59 <edwardk> ski: wasn't sre if you were talking to me or ihope
07:53:37 <ski> ihope_ lastly
07:53:41 <edwardk> ah k
07:53:57 <edwardk> then i'm not totally lacking context =)
07:54:30 <edwardk> gah
07:56:00 <ihope_> Gah?
07:56:23 <edwardk> noise of frustration exhibited over the fact that the place hosting my server is flapping their routes all over the place =)
07:57:17 <ihope_> Ah.
07:57:53 <edwardk> I'd stab the network administrator to death with a spork, but then, i'd have no network administrator ;)
07:59:09 <dozer> edwardk: sounds like that could be an improvement
07:59:17 <dozer> at least there will be a vacancy you can hire for
07:59:36 <dozer> edwardk: regardless, use a rusty spoon - it hurts more
07:59:46 <edwardk> dozer: good point. =)
08:01:15 <ihope_> > product [1..20]
08:01:16 <lambdabot>  2432902008176640000
08:01:30 <ihope_> ...No, I'm not going to do that.
08:02:34 <dozer> http://www.rafb.net/paste/results/kNMkYO57.html
08:03:11 <dozer> got a horrible feeling that I should be doing something to make a1 and a2 unify
08:03:13 <boegel> Itkovian: train? :)
08:03:19 <dozer> but I have no idea what
08:03:43 <Itkovian> what train?
08:04:01 <boegel> Itkovian: 17u32?
08:04:16 <Itkovian> there is no train at 17:32 going my direcxtion
08:04:23 <Itkovian> it's at at 17:33
08:04:33 <Itkovian> you see, I can't even type decently
08:04:38 <boegel> whateva
08:04:39 <Itkovian> that Duvel wat too much
08:04:41 <Itkovian> :-)
08:04:42 <boegel> Itkovian: that drunk? :D
08:04:48 <boegel> was :p
08:04:51 <Itkovian> nah, that tired
08:04:53 <boegel> omfg :)
08:04:57 <boegel> let's go have a drink dude ;)
08:07:15 <dozer> if I have "(forall a. Foo a => a) -> a", is the "a" in the first part of the function the same "a" as in the 2nd?
08:07:31 <dmhouse> No.
08:07:38 <dozer> or can I rename either one e.g. "(forall a. Foo a => a) -> b"
08:08:12 <dmhouse> The second a is free (or implicitly universally qualified, if you prefer).
08:08:24 <dmhouse> So yes, those two signitures are the same.
08:08:37 <edwardk> ok, dumb question time =)
08:08:46 <dmhouse> That's what makes the type of runST work :)
08:08:51 * ihope_ puts on his dunce cap
08:09:24 <edwardk> if i have 'lost' the fact that a type is an instance of, say, Ord or Read or Show, can i get that back with a case guard or something?
08:09:26 * ski wrestles with the sequents
08:09:53 <dmhouse> edwardk: Come again?
08:09:53 <dozer> ok - and this lets me do some of the styles of polymorphism I am used to from OO - implementation hiding & things
08:10:11 <dmhouse> edwardk: You probably need to add the class constraint in the type signiture somewhere.
08:10:21 <edwardk> say i have a function arr f :: (i -> o) -> a i o
08:10:30 <ski> (or use existentials or GADTs)
08:10:34 <dmhouse> dozer: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_runST might be useful
08:10:40 <edwardk> can i make multiple versions dependant on whether or not i is an instance of Read
08:10:48 <edwardk> and have it select accordingly?
08:10:54 <dmhouse> Hmm.
08:11:06 <dmhouse> I think you'd need two seperate functions.
08:11:18 <edwardk> ok, so polymorphism can't resolve that issue?
08:11:27 <ski> edwardk : maybe with incoherent instances or something like that
08:11:34 <edwardk> because of the need to pass the dictionary around or something?
08:11:50 <ihope_> Because there's no "if it's not an instance of Read".
08:12:22 <ski> edwardk : how do you know if the user later makes a type and instance and passes a value whose type mentions that type to your polymorphic function ?
08:12:43 <dozer> dmhouse: thanks - that's sort of what I thought was going on
08:13:07 <ihope_> So you couldn't have one for if it's not a Read, and one for if it is a Read.
08:13:37 <edwardk> ski: well, the issue at question is the overly-constructive Arrow interface, in the face of that limitation, there are a lot of arrows that can't be written.
08:13:45 <edwardk> er constrictive
08:14:25 <edwardk> my not Read interface was going to blow up to undefined anyways =)
08:14:53 <edwardk> as a hack to try to see if it was possible to construct arrows over a subkind
08:15:08 <dozer> hum - my turn for a dumb question - does using existentials mean some functions have to be implemented by run-time dispatch?
08:15:11 <ski> the right solution is to have a different formulation of the 'Arrow' class (or an additional class or something)
08:15:12 <edwardk> so the possibility of that kind expanding doesn't trouble me
08:15:17 <edwardk> ski: yeah
08:15:56 <ski> dozer : what do you mean by 'run-time dispatch' ?
08:15:57 <edwardk> ski: do you know if the syntactic sugar for Arrow requires the target to be an instance of that class? or does it just devolve to >>>'s calls to arr and pure?
08:16:24 <dmhouse> edwardk: 
08:16:26 <dmhouse> @type arr
08:16:27 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
08:16:28 <edwardk> er >>>'s and calls
08:16:32 <dmhouse> @type (>>>)
08:16:33 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
08:16:41 <dmhouse> They already have the class constraint.
08:16:53 <dozer> ski: what I meant to say was, that the actual function that is executed can't necisarily be known at compile-time e.g. if it is made available through a class, so must be resolved at run-time based upon the type of the actuall thing there
08:17:05 <edwardk> dmhouse well, what i mean is if i don't import those from prelude, can i abuse the existing syntactic sugar =)
08:17:11 <ski> dozer : does 'map even [0,1,2,3]' qualify as run-time dispatch  ?
08:17:19 <dmhouse> edwardk: I very much doubt it.
08:17:27 <edwardk> oh well
08:17:41 <dmhouse> Althought GHC _does_ provide some funkiness in this regard.
08:17:44 <edwardk> then the 'something other than an arrow' approach is still doomed to substandard syntax.
08:17:50 <dmhouse> Let me see if I can dig it out of the manual.
08:18:02 <ski> (dozer : note, 'even' could be constructed from user input)
08:18:23 <dmhouse> edwardk: http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
08:18:24 <lambdabot> Title: "7.3. Syntactic extensions"
08:18:43 <edwardk> ahh
08:19:00 <dozer> for example, the ShowH example in that wiki page ends up with "hetroList" where each item in the list is showable, but you don't know /which/ show to call untill you inspect an actual list
08:19:04 <edwardk> so if i -fno-implicit-prelude it might work for arrows
08:19:05 <edwardk> but
08:19:09 <edwardk> i also note
08:19:23 <edwardk> that it requires that the functions with the appropriate names must match the prelude signatures
08:19:32 <edwardk> so it doesn't seem to help
08:19:54 <edwardk> though it doesn't explicitly mention the arrow operators in that page
08:20:11 <edwardk> so maybe =)
08:20:24 <dmhouse> They're not preluded anyway, you realise
08:20:31 <edwardk> yeah
08:20:36 <dmhouse> @index (>>>)
08:20:36 <lambdabot> Control.Arrow
08:20:47 <edwardk> k
08:20:50 <edwardk> so maybe it can work =)
08:20:57 <dmhouse> edwardk: Err, "Similarly recursive do notation (see Section 7.3.3, “The recursive do-notation ”) uses whatever mfix function is in scope, and arrow notation (see Section 7.7, “Arrow notation ”) uses whatever arr, (>>>), first, app, (|||) and loop functions are in scope."
08:21:09 <dmhouse> It does explicitly mention the arrow operators :)
08:21:12 <edwardk> nifty!
08:21:25 <edwardk> then i can make a more constrained arrow type
08:21:34 <edwardk> and resolve that subkind problem
08:21:37 <edwardk> heh
08:21:41 <edwardk> i might just bang that out
08:21:46 <dmhouse> Well, "The functions with these names that GHC finds in scope must have types matching those of the originals, namely:"
08:21:57 <dmhouse> It might reject your extra constraints
08:22:20 <edwardk> yeah well with these names is hopefully limmited to the set depected below that statement
08:22:29 <edwardk> er depicted
08:22:40 <edwardk> in that case i should be able to get by
08:22:47 <dmhouse> I doubt it is.
08:22:59 <edwardk> well a boy can dream, can't he? =)
08:23:11 <edwardk> as soon as my network connectivity returns in full, i'll give it a shot
08:23:17 <edwardk> and if it doesn't work, grumble about it =)
08:25:34 <edwardk> worst case, there should probably be some old arrow preprocessor lying around that doesn't check its argument types =)
08:27:15 <jgrimes_> > testBit (167::Int) (4::Int)
08:27:16 <lambdabot>  False
08:28:44 <roconnor> > testBit (168::Int) (4::Int)
08:28:44 <dmhouse> @hoogle testBit
08:28:45 <lambdabot> Data.Bits.testBit :: Bits a => a -> Int -> Bool
08:28:45 <lambdabot>  False
08:28:59 <roconnor> > testBit (157::Int) (4::Int)
08:29:00 <lambdabot>  True
08:29:27 <dmhouse> > 0b100
08:29:28 <lambdabot>  Not in scope: `b100'
08:29:31 <roconnor> wait, that's not hex
08:29:34 <dmhouse> > b100
08:29:34 <lambdabot>  Not in scope: `b100'
08:29:36 <roconnor> > 0x0b100
08:29:37 <lambdabot>  45312
08:29:43 <dmhouse> Ah, that's how you do it.
08:30:01 <dmhouse> > testBit 0x0b100 0
08:30:02 <lambdabot>  Add a type signature
08:30:15 <dmhouse> > testBit (0x0b100 :: Int) 0
08:30:17 <lambdabot>  False
08:30:21 <dmhouse> > testBit (0x0b100 :: Int) 1
08:30:22 <lambdabot>  False
08:30:30 <dmhouse> Hold on...
08:30:44 <dmhouse> Ah, I see.
08:30:52 <dmhouse> How do you do binary then?
08:30:57 <Lemmih> You don't.
08:30:59 <dmhouse> 0x0b100 is hex.
08:31:09 <dmhouse> Oh, I thought I remember there being sugar for that too.
08:31:13 <roconnor> oops
08:31:14 <dmhouse> > 0100
08:31:15 <lambdabot>  100
08:31:21 <dmhouse> No octal either?
08:31:24 <roconnor> I thought the b was hex
08:31:40 <roconnor> readOctet "100"
08:31:43 <roconnor> > readOctet "100"
08:31:44 <lambdabot>  Not in scope: `readOctet'
08:31:51 <dmhouse> > readOctal "100"
08:31:52 <lambdabot>  Not in scope: `readOctal'
08:32:00 <roconnor> > readOct "100"
08:32:10 <dmhouse> Grr, got there just before me.
08:32:17 <lambdabot>  [(64,"")]
08:32:39 <jgrimes_> > 0o100
08:32:52 <lambdabot>  64
08:33:04 <dmhouse> Ah, okay.
08:33:15 <dmhouse> Odd that's there's no sugar for binary, then.
08:33:30 <jgrimes_> agreed.
08:34:21 <roconnor> readInt 2 (`elem` ['0','1']) (\x -> fromEnum x - fromEnum '0') "0100"
08:34:24 <roconnor> > readInt 2 (`elem` ['0','1']) (\x -> fromEnum x - fromEnum '0') "0100"
08:34:29 <lambdabot>  [(4,"")]
08:37:37 <dmhouse> fromEnum x - fromEnum '0';    (-) (fromEnum x) (fromEnum '0');   (-) $ liftM2 fromEnum x '0';    (-) $ flip (liftM2 fromEnum) '0' x;    (-) . flip (liftM2 fromEnum). I think.
08:37:57 <dmhouse> Err, (-) . flip (liftM2 fromEnum) '0'
08:38:01 <dmhouse> @pl \x -> fromEnum x - fromEnum '0'
08:38:01 <lambdabot> subtract (fromEnum '0') . fromEnum
08:38:23 <dmhouse> @type (-) . flip (liftM2 fromEnum)
08:38:25 <lambdabot>   Expecting a function type, but found `Int'
08:38:25 <lambdabot>    Expected type: a1 -> a2 -> r
08:38:30 <dmhouse> @type (-) . flip (liftM2 fromEnum) '0'
08:38:31 <lambdabot>   Expecting a function type, but found `Int'
08:38:31 <lambdabot>    Expected type: a1 -> a2 -> r
08:38:45 <kpreid> dmhouse: Char.digitToInt
08:38:55 <roconnor> nice
08:39:06 <roconnor> readInt 2 (`elem` ['0','1']) digitToInt "0100"
08:39:09 <roconnor> > readInt 2 (`elem` ['0','1']) digitToInt "0100"
08:39:10 <lambdabot>  [(4,"")]
08:39:15 <dmhouse> Oh, that's what the function does. :)
08:41:47 <dmhouse> What's a nice, simple example of a function that takes one type and returns another?
08:42:00 <dmhouse> Preferably it should be monomorphic.
08:42:12 <dmhouse> (And the types need to be distinct, obviouslly.)
08:42:20 <ski> @type ord
08:42:21 <lambdabot> Char -> Int
08:42:36 <dmhouse> Nice.
08:47:34 <edwardk> heh
08:47:52 <edwardk> someone on high has decreed that this day i shall not write haskell code. now visual haskell is freezing too =)
08:49:16 <ski> (ihope_ : hm, it seems a bit more complicated that i first imagined .. :)
08:49:34 <ihope_> Hmm?
08:50:06 <ski> inverse 'S'
08:50:55 <ski> the problem with your (er, djinn's) version is of course that it discards one of the 'b's
08:52:59 <ski> (and '\ab_ac a0 b -> ab_ac (\a1 -> b) (amb a0 a1)' is not well-scoped)
08:54:42 <dmhouse> Does ord/chr only deal with ASCII, or can it go to, say, latin-1?
08:55:00 <dmhouse> > ord 'ü'
08:55:01 <lambdabot>  Improperly terminated character constant
08:55:35 <ski> > ord ''
08:55:36 <lambdabot>  196
08:55:43 <int-e> > chr 1000
08:55:44 <lambdabot>  '\1000'
08:56:14 <int-e> it doesn't really char about encoding (pardon the pun)
08:56:38 <dmhouse> Hrm.
08:57:03 <dmhouse> So chr sends out '\x', and that's caught at some higher-level and rendered as the glyph it represents?
08:57:21 <dmhouse> E.g. chr 196   ==>   \196, which is caught somewhere and displayed as 'Ä'?
08:58:13 <int-e> it stores a value of 1000; the Show instance of Char shows that as \1000
08:58:39 * int-e notices that String/Char is probably the main reason for having showList in Show.
09:00:34 <int-e> putStr on the other hand just emits the characters truncated to 8 bits
09:00:46 <int-e> putStrLn "\320" prints an @
09:01:09 <int-e> no magic anywhere.
09:02:15 <dmhouse> > chr (320 `mod` 128)
09:02:15 <lambdabot>  '@'
09:02:42 <int-e> mod 256 really :)
09:02:58 <dmhouse> Err, oops.
09:03:11 <dmhouse> My knowledge of the powers of two failed me :)
09:03:39 <int-e> shame on you
09:03:45 <dmhouse> > let twos = iterate (*2) 1 in take 9 twos
09:03:46 <lambdabot>  [1,2,4,8,16,32,64,128,256]
09:04:18 <dmhouse> > let twos = iterate (*2) 1 in map (chr . (320 `mod`)) (take 9 twos)
09:04:19 <lambdabot>  "\NUL\NUL\NUL\NUL\NUL\NUL\NUL@@"
09:04:30 <dmhouse> > let twos = iterate (*2) 1 in map (chr . (320 `mod`)) (take 20 twos)
09:04:32 <lambdabot>  "\NUL\NUL\NUL\NUL\NUL\NUL\NUL@@\320\320\320\320\320\320\320\320\320\320\320"
09:04:49 <dmhouse> Wow, so I was extremely lucky in my poor choice of power :)
09:05:06 <int-e> not really, because @ is ASCII :)
09:11:45 <eivuokko> Is the primary source for wxhaskell still in sourceforge cvs?
09:12:28 <dozer> @type gcast1
09:12:29 <lambdabot> forall a (t' :: * -> *) (c :: * -> *) (t :: * -> *). (Typeable1 t', Typeable1 t) => c (t a) -> Maybe (c (t' a))
09:13:50 <dozer> @type dataCast1
09:13:51 <lambdabot> Not in scope: `dataCast1'
09:14:39 <u221e> How can I turn a Word8 into a Char?
09:15:35 <roconnor> @type toEnum
09:15:36 <lambdabot> forall a. (Enum a) => Int -> a
09:15:51 <roconnor> @type toEnum . fromIntegral
09:15:52 <lambdabot> forall a a1. (Enum a, Integral a1) => a1 -> a
09:28:51 <edwardk> hrmm
09:29:14 <edwardk> is there presently a way to specify that the type parameters of a class are instances of a given class?
09:29:30 <edwardk> or must that be threaded throughout all of the functions in the class?
09:29:53 <edwardk> i seem to recall a paper calling for the feature, don't know if ghc or anyone adopted it though
09:30:39 <dmhouse> You mean like:
09:30:41 <eivuokko> class (Foo a) => Bar a and instance (Baz a) => Blah a
09:30:47 <dmhouse> That?
09:31:44 <edwardk> more like, i have a class, say class GCategory a i o where ... and i want to set a requirement that i and o are instances of a particular class, like Num or Read or Show
09:31:48 <edwardk> for instance
09:32:14 <edwardk> so i could specify that constraint once at the class level rather than in every function in the where clause
09:32:34 <dmhouse> The first example eivuokko gave.
09:32:34 <edwardk> or maybe you said what i just said
09:32:42 <edwardk> and i just didn't catch the syntax =)
09:32:43 <eivuokko> I think so
09:32:44 <u221e> I shaved off another 0.2 seconds... It's these damn type conversions...
09:32:48 <edwardk> heh
09:32:52 <eivuokko> There is two syntax, the first for superclasses
09:33:08 <dmhouse> class (Show o, Read i) => GCategory a i o where ...
09:33:09 <eivuokko> The second is for instance class context.
09:33:40 <edwardk> dmhouse thats basically what i was looking for =)
09:34:39 <edwardk> there isn't a way to parameterize the constraint is there? i.e. to turn Show o into something absurd like x o where i can make x vary is there?
09:35:01 <dmhouse> Err
09:35:10 <dmhouse> It's unlikely. Could you give a more concrete example?
09:35:10 <edwardk> it seems like it would get fairly circular fast
09:35:29 <SamB> no
09:35:38 <SamB> ... how could you do that?
09:35:50 <SamB> you can't call a method in a class you don't know...
09:35:56 <edwardk> there was a paper i recall using an example from Collection, alowing you to specify if the collection was built over an instance of Eq or an instance of Ord
09:36:03 <edwardk> without rewriting the member functions
09:36:12 <dmhouse> Weird. Got a reference?
09:36:18 <edwardk> like i said, it was a proposal
09:36:26 <edwardk> hence my inquiry
09:36:38 <edwardk> not sure off hand, i have it printed out at home i think
09:37:38 <dmhouse> @type chr
09:37:39 <lambdabot> Int -> Char
09:38:15 <eivuokko> Depending what you want, you might be able to use functional dependencies.
09:38:17 <edwardk> basically was trying to see if i could get away with some form of constraint on the definition of class rathere than chaining type constructors somewhat insanely to get something like
09:38:36 <edwardk> >>> :: a (i b) (o c) -> a (i c) (o d) -> a (i b) (o d)
09:38:41 <edwardk> or something like that
09:39:12 <dmhouse> That would make i and o have kind * -> *, I'm not sure that's what you want.
09:39:29 <edwardk> yeah
09:39:47 <dmhouse> It is or isn't what you want/
09:39:53 <dmhouse> s/\//?/
09:40:18 <edwardk> i this current constrained case i really want something like >>> :: (Read b, Show c, Read c, Show d) => a b c -> a c d -> a b d
09:40:34 <edwardk> but i wanted to abstract away the particulars that the type constraints were Read and Show somehow
09:40:46 <dmhouse> Why?
09:41:10 <dmhouse> That doesn't sound like a very good thing to apply abstraction to.
09:41:21 <dmhouse> Changing class constraints tends to change an awful lot
09:41:31 <dmhouse> As it changes the methods you have at your disposal.
09:41:37 <edwardk> because i don't want to have to rewrite this 'categorical' defininition whenever i want to define a category over a different subkind
09:42:15 <eivuokko> Is that same as having abstract pattern matching?
09:42:29 <edwardk> what i want is the category to serve as a guarantee that i can connect any source to a sink given an arrow chain between them
09:42:44 <edwardk> but to provide nothing more really =)
09:43:13 <edwardk> read and show at the moment serve to provide the source and sink interface but their nature isn't essential
09:43:22 <edwardk> the details aren't categoric
09:43:40 <dmhouse> Woah, 'subkind'? Where did kinds come into things?
09:43:45 <edwardk> there is nothing magical about serializing to/from strings?
09:43:58 <edwardk> ok, rewind
09:44:07 <edwardk> you missed the earlier part of the discussion =)
09:44:20 <dmhouse> Ah, I think I grasp the essence of your problem.
09:44:22 <edwardk> it started out with me inquiring as to what problems there were with Arrows =)
09:44:25 <dmhouse> Well, how I'd do it is this:
09:44:32 <edwardk> this led into the ArrPipe example
09:44:52 <edwardk> which can't be resolved with the current Arrow interface, because you can only construct arrows over a constrained set of types.
09:44:58 <edwardk> for that particular set of arrows
09:45:02 <dmhouse> class ProcessLink i o where forwards :: i -> o; backwards :: o -> i
09:45:09 <edwardk> so i started diving into how to make it rigorous
09:45:45 <dmhouse> instance (Show o, Read i) => ProcessLink i o where forwards = read; backwards = show;
09:45:52 <edwardk> while trying to preserve the existing arrow sugar.
09:46:06 <edwardk> hrmm
09:46:17 <dmhouse> class (ProcessLink i o) => GCategory a i o where ...
09:47:00 <edwardk> that i can understand =)
09:47:23 <dmhouse> How's that look categoricall?
09:47:30 <dmhouse> s/\?/y?/
09:47:33 <edwardk> playing with it
09:47:55 <edwardk> there might be an issue or two with the type a, which should really probably be (ProcessLink i o) but that more or less nailed what i wanted
09:49:07 <dmhouse> An instance of ProcessLink is a relationship between two types saying 'you can convert freely between these two'.
09:49:31 <edwardk> it seems to be working so far
09:49:38 <edwardk> i just need to flesh it out a bit
09:50:02 * lispy is excited today, droundy is coming to work at his uni and he may be able to act as a coadvisor for some darcs work
09:50:19 <ski> hm, is the type system rules for the arrow notation described in some paper ?
09:50:23 <edwardk> hrmm
09:50:41 <edwardk> hughes original one with some notational differences, an there was a patterson one i think
09:51:14 <edwardk> hrmm trying to figure out my >>> signature now =)
09:52:06 <dmhouse> ski, I would at least the operational semantics, or a translation to points-free using the arrowic functions, is in 'A new notation for arrows'
09:52:09 <edwardk> still unchanged?
09:52:50 <edwardk> hrmm problem
09:53:13 <ski> i see a translation in 'Arrows and Computation'
09:53:28 <edwardk> >>> carries an arrow from b -> c and c -> d into one from b -> d
09:53:58 <edwardk> but the type just specified only lets me carry one type in and out of my serialization format
09:54:09 <edwardk> unless i'm screwed up
09:54:53 <edwardk> it seems i need something more like
09:55:22 <edwardk> >>> :: (ProcessLink b c, ProcessLink c d) => a b c -> a c d -> a b d
09:55:53 <dmhouse> (By the way, when specifying types for operators, you need to enclose them in parentheses.)
09:56:03 <edwardk> yeah
09:56:13 <dmhouse> Yes, so it would seem.
09:56:16 <edwardk> been kinda lax posting it to the channel
09:56:32 <dmhouse> So you can't parameterise over a single pair of input/output types.
09:57:03 <edwardk> yeah, coz pipes could carry text, or xml, etc.
09:57:33 <edwardk> while its all Strings underneath the idea of the original writeup someone was to carry the info in phantom types for the contents of the channel
10:02:19 <edwardk> ok, abandoning the objects for a while and playing with a pure category arrow-theoretic version
10:02:28 <edwardk> and seeing if i can get anywhere
10:02:39 <edwardk> if nothing else i get some insight into the type system this way
10:02:42 <ski> 'pure'/'arr' is a problem
10:02:46 <edwardk> yeah
10:02:58 <edwardk> thats why i'm trying to generalize the interface
10:03:14 <edwardk> its kinda like the 'forgetful functor' problem i had yesterday
10:03:40 <ski> data Foo a b where MkFoo :: (Read a,Show b) => ..a..b.. -> Foo a b
10:04:07 <ski> is that legal, with GADTs ?
10:04:31 <edwardk> hrmm
10:07:11 <edwardk> i get an illegal gadt declaration
10:07:44 <dozer> I still can't figure out how to get Data/Generics2/Instance.hs through the compiler
10:07:57 <ski> dmhouse : hm, yes, a description of typing, in words is there
10:08:21 <dozer> there's a missmatch between the type of dataCast1 and gcast1 that I can't see how to resolve
10:09:10 <dmhouse> ski, sorry, a lot of threads of conversation going on. What was that regarding?
10:09:20 <ski> 'A new notation for arrows'
10:09:38 <dmhouse> Aha. Cool.
10:13:03 <dmhouse> @spell signiture
10:13:05 <lambdabot> signature signatures signatory signore signature's
10:13:32 <aFlag> nice, lambdabot is full of features
10:13:39 <dmhouse> That's one of my favourites.
10:13:59 <ski> from what i can decipher, it seems similar to my typing idea ..
10:15:55 <ski> (though i think they do things in a strange way)
10:17:29 <dmhouse> ski, your typing idea?
10:17:46 <ski> for typing arrowful computations
10:18:01 <aFlag> what do you mean?
10:18:10 <edwardk> what we were talking about above? or something more robust?
10:18:18 <ski> probably it is not so different from theirs, in practice, but i want to check
10:18:23 <ski> sorry, no
10:18:38 <Arnia> Hey. I'm having problems building wxHaskell on OS X
10:18:45 <ski> Gamma | p :: sigma |-_ar c :: tau
10:18:45 <ski> ------------------------------------
10:18:45 <ski> Gamma |- proc p -> c :: ar sigma tau
10:18:49 <Arnia> Getting the weak reference errors but the solutions given don't seem to work
10:19:07 <ski> dmhouse : a system based on that rule
10:19:53 <dmhouse> ski, what's the |-_ symbol?
10:20:05 <ski> '_' is just "index"
10:20:38 <ski> i.e. a small 'ar' below to the right of the turn-stile symbol
10:20:41 <dmhouse> Oh, right.
10:20:57 <dmhouse> So, more latexily, |-_{ar} :)
10:21:09 <ski> yes
10:21:26 <dozer> so can "(forall a. Foo a => a) -> (forall a. Foo a => a)" be used anywhere that "forall a. Foo a => a ->a" can?
10:21:43 <dozer> or the other way round?
10:21:46 <dozer> or neither?
10:21:49 <dmhouse> dozer, I suspect the former is a direct generalisation of the latter.
10:22:09 <dmhouse> I assume the former is equivalent to (Foo a, Foo b) => a -> b
10:22:15 <Arnia> Anyone know of any other solutions?
10:22:16 <dozer> yeah, so do I
10:22:24 <ski> dmhouse : it is not
10:22:42 <eivuokko> dmhouse, I think it isn't, in your a nd b can be the same, in dozer's they can't.
10:22:57 <eivuokko> Type variable can't escape the forall-scope.
10:23:00 <dozer> can be the same, or can be known to be the same?
10:23:05 <ski> (or, hm)
10:23:14 <dmhouse> eivuokko: In dozer's first example, of course the two as can be the same.
10:23:47 <eivuokko> Hmmm.
10:25:05 <ihope_> @type 
10:25:06 <lambdabot> not an expression: `'
10:25:08 <ihope_> Erm.
10:25:53 <ihope_> @type asTypeOf (undefined :: (forall a. Show a => a) -> (forall a. Show a => a)) (undefined :: forall a. Foo a => a -> a)
10:25:54 <lambdabot> Not in scope: type constructor or class `Foo'
10:26:01 <ihope_> @type asTypeOf (undefined :: (forall a. Show a => a) -> (forall a. Show a => a)) (undefined :: forall a. Show a => a -> a)
10:26:02 <lambdabot>   Inferred type is less polymorphic than expected
10:26:02 <lambdabot>    Quantified type variable `a' escapes
10:26:09 <ihope_> Ipe!
10:26:19 <dmhouse> Odd.
10:26:29 <dmhouse> Perhaps it's not very good at renaming bound terms.
10:26:53 <dmhouse> @type (undefined :: forall a. Show a => a) `asTypeOf` (undefined :: forall a. Show b => b)
10:26:54 <lambdabot> Not in scope: type variable `b'
10:26:54 <lambdabot>  
10:26:54 <lambdabot> <interactive>:1:82: Not in scope: type variable `b'
10:26:58 <dmhouse> @type (undefined :: forall a. Show a => a) `asTypeOf` (undefined :: forall b. Show b => b)
10:26:59 <lambdabot> forall b. (Show b) => b
10:27:15 <eivuokko> First of all, the class constraint means nothing for the type inference.
10:27:26 <dmhouse> Well, that was to be expected. That's a simple inference from the type of asTypeOf.
10:27:34 * shapr boings
10:27:34 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:27:36 <dmhouse> shapr! Wb.
10:27:39 <dmhouse> @type (undefined :: forall a. a) `asTypeOf` (undefined :: forall b. b)
10:27:40 <lambdabot> forall b. b
10:27:59 * Arnia waves to shapr
10:28:00 <shapr> dons: SoC review! argh!
10:28:05 <shapr> hiya Arnia!
10:28:10 <shapr> Gotta be social, bbl
10:28:13 <dmhouse> @type (() :: forall a. a) `asTypeOf` (() :: forall b. b) -- now it's nice and short :)
10:28:14 <lambdabot>   Couldn't match the rigid variable `a' against `()'
10:28:14 <lambdabot>    `a' is bound by the polymorphic type `forall a. a' at <interactive>:1:1-17
10:28:18 <dmhouse> Ahem.
10:28:22 <dmhouse> Ignore that then.
10:28:41 <dmhouse> ihope_: what were you expecting?
10:28:48 <dmhouse> Or why were you expecting funkiness?
10:29:07 <dmhouse> And why can't the type inferer rename the bound type variables?
10:29:11 <dmhouse> @type (undefined :: forall a. a) `asTypeOf` (undefined :: forall a. a)
10:29:12 <lambdabot> forall a. a
10:29:42 <dmhouse> Oh, I see how they differ.
10:30:16 <dmhouse> @type (undefined :: (forall a. a) -> (forall a. a)) `asTypeOf` (undefined :: forall a. a -> a)
10:30:17 <lambdabot>   Inferred type is less polymorphic than expected
10:30:17 <lambdabot>    Quantified type variable `a' escapes
10:30:31 <dmhouse> @type (undefined :: (forall a. a) -> (forall b. b)) `asTypeOf` (undefined :: forall c. c -> c)
10:30:33 <lambdabot>   Inferred type is less polymorphic than expected
10:30:33 <lambdabot>    Quantified type variable `a' escapes
10:31:24 <dmhouse> @type undefined :: forall b. (forall a. a) -> b
10:31:26 <lambdabot> forall b. (forall a. a) -> b :: forall b. (forall a. a) -> b
10:31:55 <eivuokko> It is easier with explicit data ctors.  It is to do with binding the types and the binding scope.
10:32:28 <dmhouse> Is it an implementation detail or is it genuinely untypable?
10:33:22 <eivuokko> Variables cannot escape the scope of forall... if you have data Foo = forall a. Bar a... and case .. of Bar v -> expr, the v's a cannot be inferred to be same outside that scope.
10:33:32 <eivuokko> IF that makes sense.
10:34:28 <eivuokko> dmhouse, as far as I understand, it is the primary logical abstraction forall provides.
10:34:54 <eivuokko> So, I guess it is the genuine-type of problem.
10:36:24 <dmhouse> So it's the combination of the scoping and asTypeOf.
10:37:44 <eivuokko> asTypeOf just tells you that the types really cannot be inferred be the same.
10:54:10 <ihope_> If we had "exists a. a" and such, would the intersection of those two types be defined?
10:55:05 <Cale> which two?
10:55:50 <dmhouse> Straw poll. How do you pronounce 'chr'?
10:56:15 <Cale> I pronounce it like 'care'
10:56:31 <ski> ihope_ : intersection ?
10:57:30 <ihope_> ski: unification?
10:57:42 <alar> char?
10:57:55 <ihope_> Cale: (forall a. a) -> (forall b. b) and forall c. c -> c.
10:58:07 <ihope_> dmhouse: like "care", I guess.
10:58:43 <dmhouse> Weird. I've always said 'char'. How could you pronounce it 'care'? It's got a 'ch'!
10:58:44 <ski> ihope_ : hm, from the latter, one can derive the former, if the quantification is impredicative
10:59:05 <Cale> ihope_: the intersection of those types is (forall a. a)
10:59:26 <ihope_> Cale: that looks more like a union to me.
10:59:26 <jgrimes_> dmhouse: because the beginning of character is pronounced "care"
10:59:39 <Cale> dmhouse: how do you pronounce 'character'?
10:59:44 <Cale> ihope_: it's not
10:59:46 <dmhouse> Not like 'care'.
11:00:01 <dmhouse> But then, not with a soft sounding 'c' either.
11:00:08 <Cale> It's a hard c
11:00:14 <dmhouse> So you say it like the beginning of 'character'?
11:00:18 <Cale> yes
11:00:46 <ihope_> Cale: how could the intersection of two types be more general than either?
11:00:51 <Cale> which, in my accent, sounds exactly like 'care'
11:01:06 <dmhouse> The first syllabyle in my pronounciation of 'character' sound like the beginning of 'cap'.
11:01:25 <Cale> ihope_: Suppose that some term has type "forall a. a", then it is in all types.
11:01:42 <Cale> For example, the intersection of Int and String is forall a. a
11:01:43 <ihope_> dmhouse: you know just how much about you I can derive from that?
11:02:03 <ihope_> Cale: I'd call that the union.
11:02:10 <Cale> Because there are no other terms which are in both of those types.
11:02:19 <Cale> Why would you call it union?
11:02:20 <dmhouse> ihope_: Go ahead :)
11:02:32 <Cale> (forall a. a) has only one element in it.
11:02:44 <ihope_> dmhouse: well, it's less than I can derive from your hostmask.
11:02:46 <Cale> namely, undefined/bottom
11:03:01 <ihope_> Cale: hmm.
11:03:09 <dmhouse> ihope_: ;)
11:03:13 <ihope_> I see,
11:03:40 <dmhouse> I have a sudden urge to go read my type theory book.
11:03:51 <alar>  forall a.a == undefined ? 
11:04:03 <Cale> forall a. a = {undefined}
11:04:04 <lispy> what is the grid/table control called in gtk?
11:04:07 <ihope_> alar: undefined :: forall a. a.
11:04:20 * ski wants counions !
11:04:25 <sjanssen> @type let x = x in x
11:04:26 <lambdabot> forall t. t
11:04:37 <alar> undefined::(foralll a.a)
11:04:44 <alar> hm, I would not object
11:04:49 <dmhouse> sjanssen: Which is _|_.
11:05:03 <ihope_> Cale: I'd call forall a. a the union of Int and String because forall a. a contains both Int and String, in a way.
11:05:15 <ihope_> Essentially, the opposite of the reason that you call it the intersection.
11:05:37 <alar> what are counions?
11:05:40 <ski> that's backwards
11:05:53 <dmhouse> alar, if you view types as sets of their values with a bottom, i.e. Bool = { _|_, False, True }, then forall. a = { _|_ }.
11:05:59 <ski> consider 'forall a. a -> String'
11:06:37 <Cale> ihope_: you're misinterpreting 'forall a. a'
11:06:49 <Cale> ihope_: 'exists a. a' is what contains both Int and String
11:06:53 <ihope_> Cale: it's a type that can act as any type, yes?
11:07:12 <Cale> 'forall a. a' is the type of values which are in every type.
11:07:29 <Cale> That is, it's the intersection of all types.
11:07:43 <Cale> 'exists a. a' is the union of all types
11:08:04 <ihope_> Yes, I see.
11:08:07 <Cale> because if t :: exists a. a, that just says that t has some type.
11:08:08 <ihope_> I just don't agree :-P
11:08:14 <dmhouse> Because 'exists a. a' means 'there exists some type a such that this term has type a'.
11:08:25 <Cale> that is, exists a. t :: a
11:08:29 <ski> alar : as 'union' but dual, i.e. for quotient objects, instead of subobjects
11:08:48 <Cale> forall a. t :: a is a much stronger statement
11:08:56 <dmhouse> And 'forall a. a' means 'for all types, this term has that type'.
11:09:02 <ihope_> Okay... so what's the union of (forall a. a) -> (forall b. b) and forall c. c -> c?
11:09:02 <Cale> that means that if a is any type whatsoever, t can have that type.
11:09:27 <SamB> > error "ouch!" :: forall a. a
11:09:27 <lambdabot>  Parse error
11:09:31 <SamB> aww
11:09:44 <Cale> Well, there's only one value in the first type, and it's undefined
11:10:01 <Cale> in the second type, you have undefined and id.
11:10:05 <dmhouse> The first type is all functions from bottom to bottom.
11:10:25 <Cale> dmhouse: right, which is only bottom
11:10:31 <Fritez|away> hi ppl
11:10:39 <dmhouse> Cale, why?
11:10:58 <SamB> @type const undefined
11:10:59 <lambdabot> forall a b. b -> a
11:10:59 <ski> @type (let foo :: (forall a. a) -> b; foo x = x in foo)
11:11:00 <lambdabot> forall b. (forall a. a) -> b
11:11:01 <Fritez> anyone can help me solving a problem in haskell?
11:11:05 <Cale> dmhouse: because there's only ever one function from a one element set to a one element set.
11:11:28 <dmhouse> Ah, that's right. I couldn't recall how equivalence on functions was defined.
11:11:33 <dmhouse> Fritez: probably, ask away :)
11:11:45 <ihope_> Cale: um, isn't id also (forall a. a) -> (forall b. b)? (forall a. a) seems the same as (forall b. b), after all.
11:11:48 <Fritez> 12,00:01D
11:11:55 <ihope_> Uh oh.
11:11:56 <Cale> ihope_: but with that type, id = undefined
11:11:57 <dmhouse> Fritez: no colours or blinking, thought, please.
11:12:06 <Fritez> k
11:12:06 <alar> ski: quotient objects?
11:12:13 <ski> Fritez : what is the problem ?
11:12:14 <dmhouse> ihope_: no.
11:12:18 <Cale> that is, for all values x in forall a. a, id x = undefined x
11:12:23 * alar tries to imagine object division
11:12:34 <dmhouse> ihope_: Int -> String satisfies your first type. id certainly doesn't have that type.
11:12:40 <ski> alar : think 'equivalence classes'
11:12:49 <alar> ah, this
11:13:05 <ihope_> > (undefined :: (forall a. a) -> (forall b. b)) "foo"
11:13:06 <lambdabot>  Parse error
11:13:12 <Cale> dmhouse: (forall a. a) is the same type as (forall b. b)
11:13:14 <ihope_> Um.
11:13:19 <SamB> dons!
11:13:30 <SamB> your parser is being a pain again
11:13:46 <Fritez> i need to read the number os students in a class, the after that read their codes and grades, after that i need to find the ones with the higher grade and then return their codes
11:13:47 <ihope_> Anyway, can Int really be passed into a something that takes forall a. a?
11:13:56 <Fritez> i'm getting a lot of problems with IO
11:13:56 <alar> ski: still I do not understand why eq classes are called counions. What are they dual to unions in?
11:13:57 <dmhouse> @type (undefined :: (forall a. a) -> (forall b. b)) "foo"
11:13:58 <lambdabot>   Couldn't match the rigid variable `a' against `[Char]'
11:13:58 <lambdabot>    `a' is bound by the polymorphic type `forall a. a' at <interactive>:1:0-50
11:14:01 <Cale> ihope_: no
11:14:15 <ski> > (let u :: (forall a. a) -> (forall b. b); u = undefined in u) "foo"
11:14:15 <lambdabot>  Parse error
11:14:26 <dmhouse> Ah, I was wrong. Now I know why.
11:14:27 <ski> > (let u :: (forall a. a) -> b; u = undefined in u) "foo"
11:14:27 <lambdabot>  Parse error
11:14:34 <Cale> dmhouse: the only value which you can pass a function of type (forall a. a) -> (forall b. b) is undefined.
11:14:40 <dmhouse> Yeah.
11:14:48 <Cale> and the only value which can be returned is undefined
11:14:53 <dmhouse> And that's totally different to (forall a. a -> (forall b. b))?
11:15:04 <Cale> yes
11:15:08 <ihope_> dmhouse: that takes anything and returns anything.
11:15:08 <Fritez> so, any idea on how i can solve this?
11:15:11 <dmhouse> As that's all functions with a range of _|_, i.e. _|_.
11:15:15 <ski> alar : sorry, no, 'counion' would be an operation over quotient objects
11:15:15 <ihope_> That is, unsafeCoerce# :-)
11:15:31 <Cale> forall a. a -> (forall b. b) will take any value and give undefined
11:15:45 <ihope_> Fritez: well, you could use the number of students as a loop counter, sort of.
11:15:52 <dmhouse> Fritez: there are numerous IO tutorials that would probably help.
11:15:53 <Cale> well, the only functions of that type
11:16:01 * ski tries to remember an example of counion and cointersection
11:16:16 <Cale> Fritez: what exactly are you stuck on?
11:16:29 <Fritez> i'm having problems on using the numbers im reading...
11:16:52 <ihope_> Can you give us what you have so far?
11:17:09 <Cale> Fritez: are they strings?
11:17:36 <Cale> Fritez: 'read' will convert a string to an integer, or any other sort of number or value you want
11:17:47 <Cale> > read "56" :: Integer
11:17:48 <lambdabot>  56
11:17:59 <Fritez> they appear to be IO Int
11:18:08 <Cale> oh, then you haven't read them yet
11:18:19 <dmhouse> Does f :: Int -> _|_ satisfy the type forall a. a -> (forall b. b)?
11:18:25 <Cale> a value of type IO Int is a program which when run, will return an Int
11:18:31 <Fritez> can i paste the code here?
11:18:34 <Cale> Fritez: sure
11:18:36 <dmhouse> @where paste
11:18:37 <lambdabot> http://paste.lisp.org/new/haskell
11:18:40 <dmhouse> Fritez: paste it there
11:18:42 <Fritez> getMediaCod = do {
11:18:42 <Fritez> 		 putStr "Entre com o cdigo: ";
11:18:42 <Fritez> 		 a <- readNum;
11:18:42 <Fritez> 		 putStr "Entre com a mdia: ";
11:18:42 <Fritez> 		 b <- readNum;
11:18:43 <Fritez> 		 return(criaLista (a,b))
11:18:45 <Fritez> 		 }
11:18:52 <dmhouse> Ack. Never mind, it was short.
11:18:58 <Cale> dmhouse: where _|_ = forall a. a
11:19:04 <dmhouse> Cale, sure.
11:19:11 <Cale> dmhouse: yes
11:19:21 <Fritez> criaLista is a function that im using to concatenate the numbers and create a list...
11:19:28 <Cale> Fritez: okay
11:19:41 <Cale> Fritez: You could also write return [a,b]
11:19:46 <dmhouse> So there are many functions satisfying the type forall a. a -> (forall b. b), as for every choice of a domain type, you get a different function.
11:19:53 <Cale> dmhouse: right
11:20:02 <dmhouse> (If you consider equivalence by matching input/output.)
11:20:23 <alar> is forall a.a unit type or null type?
11:20:25 <Cale> dmhouse: on the other hand, they're all equivalent to const undefined = undefined
11:20:31 <dmhouse> alar, it's the 'bottom type'.
11:20:44 <ski> void type
11:20:55 <dmhouse> alar: the unit type is (), 'null type' doesn't really mean anything, but bottom is analoguous to void or null in other languages, in certain contexts.
11:21:10 <Cale> Fritez: okay, so what's the problem?
11:21:23 <alar> unit type is type containig one element, null type is empty type
11:21:28 <Fritez> criaLista (x,y) (a:c) = [(x,y)] ++ (a:c)
11:21:41 <Cale> alar: the unit type in Haskell has two elements, and the null type has one
11:21:47 <alar> oh
11:21:49 <Cale> alar: because every type has bottom in it
11:21:50 <xerox> criaLista = (:)
11:21:55 <dmhouse> Because of this 'universal subtype', _|_, or bottom.
11:22:00 <Fritez> *** Type : IO [Int]
11:22:00 <Fritez> *** Does not match : (a,b)
11:22:06 <Fritez> here
11:22:17 <Fritez> i cant use the returned values on this function
11:22:20 <aFlag> Fritez, what are you trying to do?
11:22:21 <ski> Fritez : do you intend to return a function from 'getMediaCod' ?
11:22:31 <dmhouse> xerox: ciraLista = uncurry (:), at least. More likely, crisaList (a, b) = [a, b].
11:22:34 <Cale> Fritez: you're defining an action, you have to run it to get a list of integers
11:22:52 <dmhouse> Oh, never mind.
11:22:58 <Cale> but you're only passing one pair to creaLista
11:23:05 <ski> (Fritez : also, what is the type of 'readNum' ?)
11:23:19 <Fritez> readNum :: IO Int
11:23:29 <aFlag> Fritez, mixing portuguese and english in your function names is probably not a really nice style
11:23:45 <alar> dmhouse: if you consider equivalence of values paired with their types, there still will be the same many functions of that type
11:23:52 <Cale> so creaLista (a,b) :: [(Int,Int)] -> [(Int,Int)]
11:23:57 <palomer> @palomer
11:23:57 <lambdabot> woof
11:24:07 <alar> @palomer
11:24:07 <lambdabot> Blargh!
11:24:13 <dmhouse> alar: of which type?
11:24:25 <Cale> Fritez: so you're returning a function
11:24:36 <alar> ah
11:24:38 <alar> sorry
11:24:55 <dmhouse> Cale, I don't understand your statement, "They're all equivalent to const undefined = undefined".
11:24:58 <Fritez> u said i could use return [a,b]
11:25:13 <Cale> dmhouse: well, they're all constantly undefined functions
11:25:14 <alar> I have not think about equality wrt typr conversions/polymorphism
11:25:20 <Fritez> then i could call this function on another one...
11:25:23 <aFlag> Fritez, you should use return (a, b)
11:25:30 <Cale> Fritez: well, not after I was what creaLista was
11:25:36 <Cale> saw*
11:25:41 <alar> @type const
11:25:42 <lambdabot> forall a b. a -> b -> a
11:25:45 <aFlag> and you can join all (a, b) together outside that function
11:25:58 <Cale> Fritez: though yeah, probably it should just be returning (a,b)
11:26:12 <Fritez> let's see
11:26:13 <dmhouse> Cale, if you mean the range of each function is {_|_}, then yes, I agree.
11:26:33 <Cale> dmhouse: yeah
11:26:51 <Cale> dmhouse: so a valid definition for every f in the type is f = undefined
11:26:58 <Cale> but they have various types
11:27:06 <dmhouse> And that makes them distinct.
11:27:07 <dmhouse> I see.
11:27:24 <Excedrin> what's {_|_} ?
11:27:31 <dmhouse> Excedrin: the set containing bottom.
11:28:28 <Cale> dmhouse: I suppose that whether that really makes them distinct is up for debate
11:28:33 <Cale> well, actually
11:28:54 <Cale> there's only one function of type *forall* a. a -> (forall b. b)
11:28:57 <alar> Cale: they are distinct  wrt some equality
11:28:58 <dmhouse> It depends how you form your equivalence relationship.
11:29:17 <Cale> dmhouse: since it has to really be polymorphic
11:29:22 <Cale> there's really only one
11:29:33 <dmhouse> Hrm. Now I'm confused again :)
11:29:41 <alar> which one?
11:29:45 <Cale> undefined
11:29:48 <Cale> so
11:29:49 <dmhouse> alar, f _|_ = _|_, or just _|_.
11:29:54 <Cale> For example...
11:29:58 <alar> no
11:29:58 <Cale> If I wrote
11:30:03 <Cale> f True = undefined
11:30:14 <Cale> f False = undefined
11:30:17 <alar> I mean what equality relations whould you use
11:30:30 <alar> for those functions
11:30:31 <dmhouse> alar: equivalence of input/output; the normal one
11:30:42 <Cale> I can't give f type forall a. a -> (forall b. b)
11:30:42 <alar> then they are distinct
11:31:00 <alar> but eq of IO is undecidable IMHO
11:31:04 <Cale> because it's insufficiently polymorphic
11:31:16 <dmhouse> alar, huh? How did IO enter things?
11:31:25 <alar> input/output
11:31:36 <dmhouse> I don't mean that kind of IO.
11:31:48 <alar> I know what you mean
11:32:00 <dmhouse> I mean if you did zip (map f allValues) allValues, and compared that list.
11:32:03 <Cale> It's usually human-decidable :)
11:32:24 <alar> dmhouse: yes
11:32:25 <dmhouse> alar, of course it's undecidable in practice, but that's not a problem.
11:32:27 <Cale> in all these cases we're talking about, we can tell whether two functions are equal
11:33:05 <Cale> dmhouse: yeah, I made a mistake earlier
11:33:09 <Cale> there's only one function
11:33:13 <dmhouse> Right.
11:33:18 <Cale> It takes any value whatsoever
11:33:21 <Cale> and gives undefined
11:33:40 <Cale> that is,
11:33:41 <alar> it's equal to const undefined
11:33:44 <dmhouse> So the types (forall a. a) -> (forall b. b) and forall a. a -> (forall b. b) are the same.
11:34:02 <Cale> forall a. a -> (forall b. b) is the same type as (exists a. a) -> (forall b. b)
11:34:27 <dmhouse> Which is in turn the same as (forall a. a) -> (forall b. b)?
11:34:30 <Cale> no
11:34:43 <dmhouse> But we decided in both cases the only inhabitant of the type was _|_.
11:34:46 <Cale> (exists a. a) has every value in it
11:34:51 <Cale> (forall a. a) has only one
11:35:15 <Cale> yes, but that doesn't mean they're the same type :)
11:35:20 <dmhouse> Ah.
11:35:34 <dmhouse> I was defining equality on types by just equating the sets.
11:35:47 <dmhouse> How else can you do it?
11:35:53 <Cale> right, which isn't quite right, because, for example
11:36:02 <Cale> If f :: forall a. a -> (forall b. b)
11:36:07 <Cale> then f "hello"
11:36:10 <Cale> will typecheck
11:36:23 <Cale> but if g :: (forall a. a) -> (forall b. b)
11:36:31 <Cale> then g "hello" won't typecheck
11:36:44 <alar> > let f=undefined :: (forall a. a -> (forall b. b)) in f "hello"
11:36:45 <lambdabot>  Parse error
11:36:51 <dmhouse> True.
11:37:04 <dmhouse> So equivalence on types is defined by...?
11:37:20 <Fritez> Cale: pvt
11:37:29 <Cale> Fritez: pvt?
11:38:01 <Fritez> sent u some part of the code there...
11:38:11 * alar tries to understand
11:38:14 <Cale> Fritez: I didn't get it, are you registered and identified?
11:38:23 <Fritez> nope
11:38:30 <Fritez> first time here today
11:38:46 <Cale> ah, you can't send private messages unless you're signed in
11:38:47 <alar> f takes argument of any type and returns undefined::(forall b.b)
11:38:54 <Cale> It helps prevent spam
11:39:20 <alar> g takes polymorphic argument and returns the same undefined
11:39:23 <alar> right?
11:39:30 <Cale> yeah
11:39:42 <alar> then g "hello" will typecheck
11:39:47 <ski> so there're more possible contexts to 'f' than to 'g'
11:39:49 <ski> no
11:40:07 <ski> "hello" is not polymorphic
11:40:12 <alar> yes
11:40:22 <alar> oh
11:40:23 <alar> sorry
11:40:34 <alar> f hello is well-typed
11:40:51 <alar> g "hello" isn't
11:40:58 <ski> right
11:41:30 <dmhouse> It helps a lot to think about types in terms of sets when seeing which values will typecheck.
11:41:54 <dmhouse> E.g. "hello" is not a member of the set (forall a. a), so g "hello" doesn't typecheck.
11:42:02 <dmhouse> Okay, so where were we.
11:42:14 <dmhouse> It seems equivalence on types is complicated. How is it defined?
11:42:20 <dmhouse> (Roughly speaking ;))
11:42:54 <shapr> jiihaa
11:43:07 <shapr> So, what did I miss?
11:43:16 <dmhouse> A nice type theory discussion/lecture. :)
11:43:32 <dmhouse> shapr: Where've you been the last few days?
11:43:45 <alar> if you define eq of functions by their IO then IMHO you should define eq of types as sets
11:43:46 <shapr> dmhouse: Moving to Stockholm.
11:43:47 <dmhouse> Was that your move to Stockholhm?
11:43:51 <alar> do I miss something?
11:43:57 <shapr> Yup, with a delay for Internet, etc
11:44:33 <shapr> Also, I had an apartment lined up but it was brutally yanked out from under me before I moved... 
11:44:37 <dmhouse> alar, that's what I thought, but Cale discounted that earlier, when he said that (forall a. a) -> (forall b. b) and forall a. a -> (forall b. b) aren't the same time.
11:44:40 <dmhouse> *type.
11:44:51 <dmhouse> Because, for example, of the typechecking issues we just discussed.
11:45:40 <alar> then typechecker doesn't define eq of functions by their IO
11:46:05 <dmhouse> The typechecker can't compare functions, that's uncomputable.
11:46:29 <alar> yep
11:46:33 <alar> and undecidable
11:47:04 <Cale> Well, really, to the typechecker, types are equal when they are structurally equal
11:47:14 <Cale> but we don't have exists
11:47:25 <Cale> so that might be different in systems which do
11:47:54 <Cale> but if you think about it, the domain of a function f :: forall a. a -> (forall b. b)
11:47:59 <Cale> is forall a. a
11:48:01 <Cale> er
11:48:02 <Cale> no
11:48:04 <dmhouse> So the typechecker compares types by taking them at face value?
11:48:09 <Cale> it's exists a. a
11:48:15 <dmhouse> Yes.
11:48:32 <Cale> and functions aren't equal if they don't have the same domain and codomain
11:48:33 <ski> it's 'a'
11:48:38 <shapr> Cale: I had crazy dreams about discussing type theory with you recently.
11:48:43 <Cale> shapr: hehe
11:48:57 <Lemmih> shapr: Hi!
11:49:11 * xerox waves to shapr
11:49:14 <shapr> hiya Lemmih!
11:49:14 <Lemmih> shapr: Have you submitted your mid-term evaluation?
11:49:16 <shapr> greetingz xerox 
11:49:20 <Cale> For example, id :: String -> String, is not the same function as id :: Int -> Int
11:49:25 <shapr> Lemmih: Not yet, I've just gotten online.
11:49:29 <Lemmih> shapr: I've been trying to reach you for days.
11:49:44 <shapr> I've been without internet while moving to Stockholm.
11:49:44 <Lemmih> shapr: Well hurry up! Deadline is today.
11:49:48 <shapr> awright!
11:50:03 * alar congratulates adept with overtaking the nick
11:50:20 <xerox> There is no evaluations from students for mentors, right, Lemmih ?
11:51:03 <adept> alar: :)
11:51:20 <Lemmih> xerox: Not yet.
11:51:30 * xerox heads to dinner (thanks)
11:51:31 <alar> adept: http://gl-notes.livejournal.com/812842.html is there a bit of truth?
11:51:33 <lambdabot> Title: "gl_notes: Живу и работаю в Киеве. Нашу "контору" н"
11:52:50 <shapr> I've lived on my Nokia 770 the last ten days, it's quite spiffy.
11:53:02 <dmhouse> I presume it doesn't have IRC.
11:53:18 <bringert> shapr: welcome back!
11:53:23 <dmhouse> Someone needs to write a Java IRC client and stick it on a website somewhere.
11:53:28 <dmhouse> I can never connect when I'm at school.
11:53:51 <shapr> My 770 does have IRC, but open wifi points tend to be in public areas where it's suspicious to stand about and irc.
11:53:58 <shapr> So I just grabbed my mail.
11:54:24 <shapr> bringert: Hiya!
11:54:46 <shapr> bringert: Have I missed huge changes in Hope?
11:55:14 <bringert> shapr: you haven't missed them, they are still there
11:55:21 <jgrimes_> :p
11:55:37 <bringert> shapr: see http://hope.bringert.net/entry
11:55:41 * shapr looks
11:56:04 <adept> alar: gonevo :)
11:56:08 <bringert> shapr: there is some newer stuff too, but I haven't installed that on hope.bringert.net yet
11:56:26 <bringert> shapr: like static pages
11:56:36 <shapr> Oh wow, hscolour support!
11:56:44 <bringert> shapr: there are per-user RSS feeds now too
11:56:56 <shapr> oh and RSS formatting too!
11:56:58 <jgrimes_> you can see a static page on my newly public Hope installation at www.marginalerror.com
11:56:58 <shapr> Wow, this is great.
11:57:06 <bringert> right, that too
11:57:19 <pejo> shapr, did you move already?
11:57:32 <bringert> jgrimes_: sweet
11:57:41 <shapr> pejo: Yes, though I don't have an apartment yet.
11:57:55 <shapr> Mooching off my gf at the moment...
11:58:02 <bringert> jgrimes: can I link to it from hope.bringert.net?
11:58:10 <jgrimes_> bringert: sure :D
11:58:42 <shapr> jgrimes_: Is "What is Hope?" the static page?
11:58:47 <jgrimes_> shapr: yep
11:58:50 <shapr> spiffy
11:59:17 <shapr> I would ask how that works but I think I'll darcs pull, build, and read the docs first...
12:00:24 <bringert> jgrimes_: when not logged in, there is a dead "Pages" entry in your menu
12:00:31 <bringert> I'll fix that
12:05:01 <jgrimes_> so there is
12:12:38 <bringert> jgrimes: fix in darcs
12:13:09 <bringert> jgrimes: I don't know how current your version is, but the latest darcs version requires the current HaskellDB darcs version
12:13:30 * shapr wishes for cabal-get
12:13:30 <bringert> I should add a version module that just says which Hope version the site is running
12:13:43 <jgrimes_> bringert: all right
12:14:14 <shapr> bringert: yeah, hope/server-status
12:14:17 <shapr> Just like apache.
12:15:08 <jgrimes_> how would dynamic module loading in Hope via hs-plugins work?
12:15:27 <bringert> jgrimes_: hopefully pretty well
12:15:41 <bringert> though I haven't tried it
12:16:12 <bringert> maybe I could write a "dynamic" module that would load other modules dynamically
12:16:26 <bringert> would need to change some things for that though
12:16:50 <jgrimes_> bringert: yeah, it would be nice though :)
12:17:18 <bringert> I worry a bit about performance and server compatibility
12:17:29 <bringert> as long as it is optional it should be fine
12:17:33 <jgrimes_> yeah.
12:18:15 <jgrimes_> not that my site will ever have much load on it, but I don't thinking serving up a cgi app and compiling things would go over too well
12:18:24 <jgrimes_> think, rather.
12:19:30 <jgrimes_> but for some purposes I think it could be pretty useful
12:19:38 <shapr> I think so too.
12:19:46 <shapr> For example, dynamically generated pages.
12:21:22 <bringert> it could have a directory where it caches the object files, and only recompile when the source has changed
12:24:49 <shapr> hs-plugins handles most of that, dunno about all.
12:26:35 <dmhouse> kowey: pingeroo
12:26:45 <kowey> dmhouse : heya
12:27:30 <dmhouse> Hi! Good work on the lists stuff.
12:27:33 <kowey> dmhouse : i hope i'm talking too much about types in the new list basics chapter...
12:27:43 <dmhouse> I did see that, and I think it's okay.
12:27:43 * kowey just saved
12:28:03 <dmhouse> People who know stuff about types will think 'ah, yeah', and people who don't will have it explained to them in my chapter.
12:28:11 <dmhouse> Anyway, I'm working on Type basics and I could do with some advice.
12:28:37 <dmhouse> I'm basically at the stage where I want to explain the types of functions in more than one argument. This basically means I need to explain currying.
12:28:46 <kowey> ooooh... 
12:28:50 <dmhouse> I looked at how YAHT does it and it's easy if you have lambda abstractions.
12:28:58 <kowey> i think that's going a little fast
12:29:09 <dmhouse> Yeah, I did think that.
12:29:22 * kowey recalls eyes glazing in his public whilst teaching
12:29:36 <kowey> (of course, this might be the teacher's [kowey] fault more than anything else
12:29:42 <dmhouse> So just say something like 'multiple arguments? Just chain 'em together like Foo -> Bar -> Baz.'
12:29:47 <dmhouse> Then explain currying later on.
12:29:54 <dmhouse> How's that sound?
12:29:57 <kowey> right... what you could even say is something to the effect
12:30:03 <kowey> or maybe sort of a side note
12:30:17 <kowey> that something really really deep and mystical about functions
12:30:32 <kowey> is that strictly speaking, functions only take ONE argument
12:30:46 <kowey> but then remind the reader that they aren't expected to understand that
12:30:54 <kowey> just dangle a little bait for the fast readers
12:31:47 <dmhouse> Sure.
12:31:50 <dmhouse> Sounds good
12:31:56 <dmhouse> Right, I'm almost done with this section.
12:32:44 <dmhouse> Then I need an explanation of type inference and we can call that chapter to a close.
12:35:36 * kowey is thinking about list exercises... 
12:35:46 <kowey> (but simple ones that don't involve pattern matching or libraries)
12:35:59 <jgrimes_> bringert: I updated haskelldb/hope and now when linking hope I get undefined references in libHShaskelldb-hsql-0.9.a
12:36:59 <bringert> jgrimes_: did you recompile and install all the haskelldb packages that you are using? e.g. haskelldb, haskelldb-hsql and haskelldb-hsql-mysql
12:37:09 <jgrimes_> bringert: that'll do it
12:37:10 <jgrimes_> ;p
12:41:45 <malcolm_> bringert: did I remember to say thanks for the patches to HsColour?
12:43:03 <bringert> malcolm_: you said that you pulled them into the main repo and wrote about it on the web page. I take that as a "thank you" :-)
12:43:36 <jgrimes_> bringert: that worked and the update worked too, thanks :D
12:44:01 <malcolm_> bringert: good.  It seems to be the way with many projects - they start as a tool, and eventually become a library
12:44:23 <bringert> malcolm_: I was thinking that it would be nice to color variable bindings different from variable uses
12:44:58 <malcolm_> bringert: you won't be able to do that with just lexical analysis...
12:45:01 <bringert> haskell-mode does that for top-level declarations 
12:45:24 <bringert> a variable in the first column is always a top-level declaration, right?
12:45:34 <malcolm_> I suppose it would need a much simpler parser than a full H'98+extensions job though
12:45:56 <malcolm_> What about pattern bindings?  let (x,y) = foo 2 in ...
12:46:19 <bringert> yeah, it get's a little messy
12:46:24 <bringert> eh, gets
12:46:29 <dmhouse> What's a nice example of a monomorphic function in more than one argument?
12:46:56 <malcolm_> If the colour is to be meaningful, it needs to be consistently and accurately assigned.
12:47:02 <bringert> right
12:47:20 <lightstep> dmhouse, regular expression matching
12:47:47 <dmhouse> I'd rather not bring in something that won't be accessible to a non-programmer.
12:47:58 <lightstep> open window?
12:48:08 <bringert> malcolm_: http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/ could be used for parsing
12:48:09 <dmhouse> Sorry?
12:48:11 <lambdabot> Title: "Haskell-Source with eXtensions"
12:48:24 <shapr> hiya malcolm_ 
12:48:30 <jgrimes_> dmhouse: (&&)?
12:48:31 <bringert> malcolm_: but I guess you want to stay away from using a full haskell parser?
12:48:47 * malcolm_ waves at shapr and anyone else in his vicinity
12:48:52 <lightstep> @type Graphics.HGL.openWindow
12:48:53 <lambdabot> Graphics.HGL.Internals.Types.Title -> Graphics.HGL.Internals.Types.Size -> IO Graphics.HGL.X11.Window.Window
12:49:01 <dmhouse> jgrimes_: Ooh, that'll make a nice exercise. But I'd rather the two argument were a different type.
12:49:04 <dmhouse> I know, I'm being picky.
12:49:06 <dmhouse> :)
12:49:24 <malcolm_> bringert: if you bring in full parsing, you may as well just use programatica
12:49:53 <bringert> right
12:50:31 <bringert> is the first column rule enough to catch all top-level declarations?
12:50:58 <bringert> malcolm_: if so, would you think that that would be ok to add to hscolour?
12:51:00 <malcolm_> bringert: for toplevel, nearly.  Not many people use pattern-binding at the top-level.
12:51:10 <bringert> you can do that?
12:51:39 <malcolm_> Sure.  check the report
12:51:57 <bringert> have you ever seen code that uses it?
12:52:01 <bringert> I don't think I have
12:52:04 <malcolm_> nope
12:52:35 <eivuokko> I recall I tried to use it when defining some constants.
12:52:43 <alar> dmhouse: Network.Socket.bind ?
12:52:52 <dmhouse> @hoogle bind
12:52:53 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
12:52:53 <lambdabot> Language.Haskell.TH.bindS :: PatQ -> ExpQ -> StmtQ
12:52:53 <lambdabot> System.Console.Readline.bindKey :: Char -> Callback -> IO ()
12:54:39 <bringert> malcolm_: another idea would be to do something special for type signatures
12:54:55 <malcolm_> bringert: do you think it would be confusing if binding occurrences were a different colour at the top-level, but the same colour as usages when defined locally?
12:54:58 <bringert> but I guess that would also need slightly more than lexing
12:55:23 <bringert> malcolm_: I don't think that would be confusing, haskell-mode does it
12:55:34 * alar has to go
12:55:59 <malcolm_> bringert: so let me ask the question the other way round - why is it useful to have the colours different?
12:56:08 <alar> please, notify me when you'll have interesting type theory talk next time
12:56:41 <bringert> malcolm_: it makes it easier to find the definition of a given function
12:57:10 <bringert> doesn't the anchor stuff already identify bindings btw?
12:57:31 <malcolm_> bringert: oh, good point.  yes the anchors are identified already
12:57:59 <malcolm_> bringert: but again only by lexical position (column 1), so class methods don't work (for instance)
12:58:15 <bringert> right
12:58:15 <dmhouse> @hoogle ord
12:58:16 <lambdabot> Char.ord :: Char -> Int
12:58:16 <lambdabot> Prelude.Ord :: class Eq a => Ord a
12:58:16 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
12:58:45 <dmhouse> kowey: Wow, I just realised I've got a lot more to explain here.
12:58:46 <bringert> finding the definitions of class methods is a bit useless anyway, since you would only see the type signature
12:59:18 <dmhouse> kowey: basic polymorphism (i.e. type variables), higher-order functions, type classes...
12:59:34 <dmhouse> how much of that can be relegated to later chapters?
12:59:38 <kowey> hmm... probably not in type basics, eh?
12:59:39 <malcolm_> bringert: but it might be nice to discover all instance defns too, maybe chained together, so if you keep clicking, you cycle through them
13:00:03 <dmhouse> I think at least the first should be in there, otherwise lists get complicated.
13:00:07 <bringert> yes, that would be good
13:00:09 <dmhouse> And it's not too hard to explain.
13:00:10 <kowey> i sometimes wonder if we need an intermediate haskell section
13:00:38 <kowey> (for type classes and ilk)
13:00:53 <dmhouse> Might be good.
13:01:13 <dmhouse> Move Libraries to the end of the second column, under 'Reference' or something.
13:01:32 <dmhouse> Make the cut after 'Lists'.
13:02:48 <bringert> CosmicRay: have you seen this HDBC installation question: http://www.haskell.org//pipermail/haskell-cafe/2006-July/016567.html
13:02:49 <lambdabot> Title: "[Haskell-cafe] Problems installing HDBC-postgresql"
13:03:57 <malcolm_> bringert: I bet Programatica can do something like that - if it has type inference, it could find whether a usage of a class method simplifies to a particular type + dictionary, then take you only to the right instance.
13:05:23 <dmhouse> kowey: Thoughts?
13:05:38 <kowey> (sorry, in the middle of wrapping up the list basics chapter)
13:05:48 <dmhouse> Sure
13:06:35 <bringert> malcom_: yes, that should be possible, and very useful
13:07:37 <bringert> malcom_: another idea: in html output, identifiers could be links to their definitions. though that doesn't work if a top-level identifier is overshadowed by a local definition
13:08:08 <bringert> and things that aren't declared in the current program could be links to haddock docs :-)
13:08:45 <bringert> but again that would be really confusing if it missed a local binding
13:09:25 <kowey> what we might even do is pop the libraries stuff out of the columns altogether
13:09:57 <kowey> one thing that has been bugging me, for example
13:10:08 <kowey> is that we seem to give the impression that Practical Haskell comes after ALL that advanced stuff
13:10:12 <kowey> which clearly isn't the case
13:10:24 <dmhouse> Right.
13:10:29 <kowey> so what would be nice is to somehow merge the practical haskell stuff with the libraries stuff
13:10:36 <malcolm_> bringert: just like Programatica....
13:10:36 <kowey> i don't think we can fit three columns though
13:10:43 <bringert> ah
13:10:54 <bringert> yeah, maybe it's KISS time
13:11:00 <kowey> maybe a big coloured block below
13:11:27 <dmhouse> kowey: Tutorials? I think the Libraries should be more tutorials and large examples than documentation; we've already got Haddock for that.
13:12:00 <kowey> well, that would also give a nice place for write yourself a scheme...
13:12:07 <kowey> tutorials would be for very precise topics
13:12:19 <kowey> that aren't strictly speaking related to learning Haskell
13:12:26 <dmhouse> Hmm.
13:12:34 <dmhouse> No, I think we should keep it Haskell-specific
13:12:41 <dmhouse> But certainly more outward- than inward-looking.
13:12:41 <kowey> i mean, yeah
13:12:52 <kowey> Haskell specific, but not, erm... essential
13:12:57 <dmhouse> Right.
13:13:05 <dmhouse> But then, the Libraries don't fit in well.
13:14:06 <kowey> one question is if we really need the libraries stuff
13:14:10 <kowey> would haddock do?
13:14:23 <kowey> i guess the point of the libraries
13:14:35 <kowey> stuff is to let the newbie know what the most important libraries to get to know are
13:15:29 <malcolm_> bringert: one more question.  Did you come up with your own colour scheme as a .css file for the hscolour'ed parts of Hope?
13:15:37 <bringert> malcolm_: yes
13:15:53 <malcolm_> bringert: can you send me a copy?
13:16:11 <bringert> malcolm_: http://hope.bringert.net/modules/haskell/style/haskell.css
13:16:12 <dmhouse_> kowey: Sorry, dodgy wifi.
13:16:22 <dmhouse_> I'd say keep the Libraries, but tune it toward examples.
13:16:37 <dmhouse_> Provide an overview of the useful functions if there's not too many.
13:16:42 <malcolm_> bringert: thx
13:16:54 <dmhouse_> One of the harder parts of learning a languages it getting accustomed to its libraries.
13:16:58 <kowey> so what i would say is this
13:17:19 <kowey> we have a Haskell in Practice block below the book, but above the other links... we use a coloured block to keep it highlighted
13:17:32 <kowey> in it goes the libraries reference (full of examples) and tutorials
13:18:10 <dmhouse> We could even make it two-columned. Basic Libraries on the left, More Expansive Libraries on the right.
13:18:24 <dmhouse> And 'Other tutorials' on the right too.
13:18:37 <dmhouse> I'm still not happy about the Scheme stuff just sitting around, disconnected, though.
13:18:41 <svens_> mhm, what's the simpliest way to print an Word8 in hex on stdout?
13:19:02 <monochrom> @hoogle showHex
13:19:02 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
13:19:18 <monochrom> That will do.
13:19:34 <kowey> dmhouse: well, we might even just unlink it and keep the link in our discussion page
13:19:40 <kowey> just source material for us
13:19:44 <dmhouse> Perhaps.
13:19:49 <dmhouse> May as well leave it for now.
13:19:54 <malcolm_> > (showString "0x" . Numeric.showHex (51::Word8)) ""
13:19:55 <lambdabot>  "0x33"
13:20:02 <kowey> ok, i'm going to try playing with tables to implement this
13:20:08 * kowey puts on his hardhat
13:20:26 <monochrom> Err, more details.  (showHex (your Word8 here) "") will give you the string.  You use putStr or whatever you like to get it to stdout.
13:20:48 <dmhouse> kowey: Copy the page to somewhere else and play there.
13:20:52 <dmhouse> kowey: Perhaps your user area.
13:21:04 <kowey> dmhouse: good call
13:22:07 <svens_> malcolm_, monochrom: thx :)
13:59:11 <kowey> dmhouse: in the "it seemed like a good idea at the time dept" http://en.wikibooks.org/wiki/User:Kowey/HaskellRedesign
14:05:55 <lispy> dcoutts: are you around? I'm having some compilation problems with gtk2hs on win32 and the prebuilt binaries won't cut it
14:15:39 <palomer> bolrod: what wasn't too good?
14:16:08 <palomer> kowey: eh?
14:16:38 <lispy> dcoutts: nevermind it's a bug in the gladewin32 distro, looks to be building now
14:17:12 <kowey> palomer: just moving bits of the Haskell wikibook around... not 100% happy with the result
14:17:44 <bolrod> palomer: I went cycling
14:18:53 <palomer> I like the idea of a community book
14:19:05 <kowey> please contribute! :-)
14:19:24 <kowey> for example, we could use a nice chapter ond GADT
14:20:29 <poro> hi, do you know, how to handle utf8 or unicode with haskell? 
14:20:53 <lispy> poro: i have no experience here, but i thought haskell was unicode friendly
14:21:02 <poro> ok
14:21:12 <kowey> poro: the good news is that Char is Unicode
14:21:34 <poro> I'm able to write some special marks with vim to my file but the compilation gives me an error...
14:21:40 <kowey> poro: the bad news is that when we read/write stuff, we do (effectively) as iso-8859-1 (feel free to correct me if i'm wrong)
14:21:47 <poro> and those marks are in the string
14:22:46 <poro> The terminal shows them correctly
14:23:23 <edwardk> question, does anyone know when between the old wadler papers on monads and the current time that monads shifted from types to classes? 
14:23:35 <poro> for ex when I cat the function
14:24:13 <kowey> poro, this might be related: http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
14:24:15 <lambdabot> Title: "UnicodeInHaskellSource - Haskell Prime - Trac"
14:26:44 <poro> thanks, I'll take a look of it right away!
14:36:13 <poro> uhh, page says there should be a support but somehow things don't work (for the utf8-support). I have a character 0xf7 
14:36:26 <poro> which is a divison symbol. 
14:36:27 <kowey> maybe you need the unstable GHC?
14:36:39 <poro> Terminal shows it correctly, vim shows it correctly
14:37:39 <poro> unstable GHC?  Hmm, do you know if it is hard to obtain and take into use (I have an Ubuntu 6.06)?
14:38:27 <poro> About that character, I was able to copy it to the ghci window, where it is shown correcly, but
14:38:41 <poro> <interactive>:1:19: lexical error in string/character literal
14:42:42 <CosmicRay> bringert: no, I hadn't.  I'll take a look.
14:43:14 <edwardk> proto: are you trying to use unicode operators?
14:43:29 <edwardk> poro: that a ghc 6.5 thing, download the head or hit the darcs repository for it
14:43:37 <edwardk> 6.4.x don't support it yet
14:44:08 <edwardk> was fiddling with it myself a few hours ago =)
14:44:40 <poro> ok,  :)
14:44:59 <poro> I'll try to obtain more recent version of ghc then.
14:45:14 <poro> Do you have any idea, when 6.6 is about to come out?
14:45:18 <edwardk> poro: though, be warned, stability issues, not for production use, etc.
14:45:20 <edwardk> no idea.
14:45:25 <poro> ok
14:45:51 <poro> yep, cannot use haskell for production code even though I
14:45:56 <poro> 'd like to...
14:46:02 <edwardk> heh
14:46:15 <edwardk> i'm trying to use haskell for some production code right now, we'll see how well that works out
14:46:30 <poro> have to still stick to apl... :)  (don't vomit, please)
14:46:40 <edwardk> if nothing else, its giving me more fun than banging it out in my usual linguistic playgrounds.
14:46:44 <edwardk> *gag*
14:46:54 <edwardk> people still program in apl? =)
14:46:55 <edwardk> wow
14:47:13 <poro> yes, I started to learn it less than year ago... 
14:47:53 <earthy> talk about legacy code...
14:48:09 <edwardk> what business use has it found for you to get stuck using it?
14:48:10 <earthy> otoh.. cobol is also a highly valued skill.
14:48:42 <poro> to support old code base, nothing more
14:49:07 <poro> no particular business value 
14:49:22 <edwardk> poro: thankfully i'm free of that sort of constraint, and can frolick in the land of the overeducated... er.. haskell
14:51:02 <poro> I like its +/list way of mapping a sum over list. And +.x notation, where + and x can be any operators, is applied to two matrices, but with
14:51:20 <poro> + and x I'll have a common matrix multiplication etc.
14:51:30 <edwardk> yeah
14:52:05 * shapr boings
14:52:07 <shapr> jiihaa
14:52:16 <shapr> wow, 207 clients.
14:52:26 <poro> so I thougth that if ghc could have one symbol operator, then I'd silently turn to haskell...
14:52:32 <CosmicRay> shapr!
14:52:44 <shapr> CosmicRay!
14:52:46 <shapr> How's life?
14:52:50 <poro> that is one symbol unicode op
14:52:57 <CosmicRay> shapr: very busy.  
14:53:00 <CosmicRay> shapr: (as usual, I guess)
14:53:01 <shapr> jhc handles unicode sources.
14:53:04 <CosmicRay> shapr: you?
14:53:15 <shapr> CosmicRay: Moved to Stockholm, have internet, but no apartment.
14:53:43 <CosmicRay> heh
14:53:53 <CosmicRay> at least your priorities are straight ;-)
14:53:59 <shapr> Oh, I got a response from MSR Cambridge!
14:54:02 * shapr boings happily
14:54:19 <earthy> stockholm is slightly more reachable than what-was-it-again-way-up-north
14:54:23 <CosmicRay> cool!
14:54:25 <shapr> earthy: Yeah, exactly.
14:54:40 <shapr> RyanAir is so cheap I can visit dcoutts for unicycling!
14:55:02 <edwardk> poro: yeah, i admit. mmy major resurgence of interest in haskell came in two waves. one when the ecma4 language specification added some spiffy types to it, and 2 when i saw that ghc 6.5 had unicode operators and i could have a language to play with my computer algebra system stuff in
14:55:31 <lispy> well, gtk2hs seems to be building now...i think i'll try to combine gtk2hs with wxhaskell, using wxhaskell when i need 'native' dialogs and gtk2hs for everything else
14:55:47 <shapr> I wish for gtk2hs for jhc.
14:55:50 <CosmicRay> ugh, unicode operators.  sigh.
14:55:56 * CosmicRay doesn't like that idea
14:55:58 <lispy> shapr: is that your compiler of choice?
14:55:59 <palomer> haskell? that's old news. the future is in perl 6!
14:56:03 <CosmicRay> nothing like not know how to type somebody's code
14:56:23 <JohnMeacham> palomer: you forgot the sarcasm tongs
14:56:23 <lambdabot> JohnMeacham: You have 1 new message. '/msg lambdabot @messages' to read it.
14:56:35 * CosmicRay has to scram
14:56:41 <edwardk> cosmic: something to be able to use real union and intersection operators though =)
14:56:45 <palomer> who said anything about sarcasm?
14:56:58 <JohnMeacham> me.
14:57:01 <edwardk> and they tend to be more mnemonic than 3 random symbols
14:57:09 <palomer> well, you're nuts!
14:57:20 <lispy> @palomer
14:57:20 <lambdabot> Learning vim is pointless
14:57:29 <JohnMeacham> it's supposed to be "who said anything about sarcasm?" (the quotes mean sarcasm)
14:58:28 <shapr> lispy: jhc is the only Haskell compiler for my Nokia 770.
14:58:35 <lispy> shapr: oh right
14:59:07 * lispy tries to prove by example that haskell is good for win32 programming
14:59:11 <JohnMeacham> shapr: I tend to use raw X11 for linux graphics programming... but I have not done anything that big.
14:59:27 <lispy> i find that i'm having to get creative just to get programs that seem normal to windows users
14:59:28 <poro> really? How jhc and ghc differ?
15:00:52 <edwardk> does anyone know around when monads switched from types (i.e. the old Wadler definitions) to classes (i.e. Control.Monad)?
15:01:05 <lispy> poro: jhc is JohnMeacham's haskell compiler and while being very cool it tends to only be as complete as JohnMeacham needs for the projects he's used haskell on
15:01:24 <shapr> That's the whole "open source scratches its own itches" deal.
15:01:33 <shapr> Meaning, feel free to extend JHC to work for your own projects.
15:01:35 <earthy> isn't that due to some papers roundabout 1995, edwardk?
15:01:47 <edwardk> earthy: yeah they are admittedly ancient
15:01:49 <ihope_> lispy: just implement a card game :-P
15:02:13 <lispy> ihope_: are you comparing me to joelr? :)
15:02:14 <edwardk> i'm just following up on some forgetful functor stuff i was working on the other day and trying to figure my way through the various warts of the current design
15:02:45 <JohnMeacham> indeed. I have had not much time to work on it recently which is bad because it is in a poor state at the moment, but I hope to fix that soonish.
15:02:52 <shapr> Hey, did anyone else get invited to interview with Microsoft Research Cambridge? I thought maybe we could organize an AngloHaskell gathering.
15:04:45 <lispy> shapr: i wasn't but i wouldn't turn down a trip to cambridge ;)
15:04:56 <edwardk> bbiab
15:06:17 <shapr> dcoutts: Are you close to Cambridge?
15:07:31 <bringert> shapr: is it for the GHC job?
15:07:54 <Lemmih> bringert: Yes.
15:08:48 <shapr> bringert: Yup, are you interviewing there too?
15:09:00 <bringert> shapr: me? nope
15:09:11 <bringert> shapr: i've already got a job til 2010
15:10:12 <cjay> ghc job? is microsoft supporting ghc development?
15:10:13 <shapr> Oh, nice
15:10:16 <shapr> cjay: yup
15:10:19 <cjay> cool
15:10:23 <bringert> shapr, xerox, jgrimes: if you pull the latest hope now, be sure that you are logged in before updating, and then set your passwords. Hope now uses MD5 passwords, and will not accept the old unencrypted passwords in the DB
15:10:33 <shapr> Ah, cool
15:10:47 <bringert> or you can mess with the DB by hand
15:11:10 <jgrimes> bringert, ok
15:13:26 <jgrimes> bringert, sounds good. :)
15:14:55 <bringert> shapr, xerox, jgrimes: while not required for Hope, there is a bugfix (or rather workaround for a seemingly standardized browser bug) in NewCGI. Before, the title of images uploaded from Windows would be weird because of the unescaped backslashes that browsers insist on putting in the filename parameter value. Summary: You are recommended to update the cgi package.
15:17:28 * shapr upgrades
15:17:44 <shapr> bringert: You think halbum will handle PNG soon?
15:18:18 <bringert> shapr: it shouldn't be very difficult. Just some extensions to the gd binding.
15:19:36 <bringert> shapr: is that your top prio RFE at the moment?
15:22:43 <shapr> bringert: Nah, I don't have any top priorities at the moment. Maybe tomorrow I will.
15:25:08 <pejo> bringert, doktorand, antagen fram till doktor?
15:25:34 <bringert> pejo: yep
15:25:45 <shapr> How do I get an account on darcs.haskell.org?
15:25:56 <pejo> bringert, that's job security. :-)
15:26:07 <bringert> shapr: e-mail someone. I forget who :-)
15:26:44 <bringert> pejo: technically I'm only employed until 2008, when they will renew it if I don't drop out totally
15:33:37 <pejo> bringert, lic?
15:34:16 <bringert> pejo: not required, but encouraged. 
15:40:00 <ihope_> @hoogle lookup
15:40:00 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:40:00 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
15:40:00 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
15:40:57 <ihope_> Uh oh.
15:41:19 <ihope_> Argh, I don't want to use unsafeCoerce#...
15:46:57 <nomeata> liyang: ping
15:48:03 * shapr hops
15:51:25 <lispy> sweet, gtk2hs is installed and working
15:51:28 <shapr> yay!
15:51:43 * lispy does a dance
15:54:38 <lispy> @index getArgs
15:54:38 <lambdabot> System.Environment
15:54:46 <Lemmih> shapr: Email your ssh-key to Simon Marlow.
15:54:52 <shapr> thanks
15:56:13 <ihope_> For once, I'm wishing Haskell had just a little less type safety.
15:56:28 <offby1> *gasp*
15:56:29 <shapr> ?
15:56:39 * offby1 gets out his matchbook and kindling
15:57:04 <ihope_> A list of values of different types!
15:57:21 <ihope_> Please don't hurt me!
15:57:42 <madpickle> I pity the fool who does not love type safety.
15:58:01 <madpickle> Mr. T said it
15:58:12 <madpickle> in his "Haskell and You" campaign awareness
15:58:45 <offby1> ihope_: I had the same feeling recently, but I've been using Haskell for about five minutes, so I just figured it was my inexperience (plus I can probably get away with pairs).
15:58:47 <pejo> ihope, and tuples isn't the way to go, or several lists?
15:59:23 <ihope_> Nope.
16:00:42 <lispy> ihope_: the solutios is to create an extestential data type as a wrapper and then box up the values
16:00:56 <lispy> ihope_: not as pretty as it could be, but it does work
16:01:37 <ihope_> Yeah, but then the only way to get at the values is unsafeCoerce#.
16:01:48 <ihope_> I don't want that.
16:03:13 <u221e> Is there a way I can print a Word8 to the screen without first converting it to a Char?
16:03:39 <ihope_> u221e: you mean as ASCII?
16:03:40 <bringert> u221e: print as a number or a character?
16:04:07 <ihope_> @hoogle Word8 -> IO 
16:04:07 <lambdabot> No matches, try a more general search
16:04:14 <ihope_> Grumble.
16:04:16 <ihope_> @hoogle Word8 -> IO ()
16:04:16 <lambdabot> No matches, try a more general search
16:04:19 <liyang> nomeata: pong
16:05:10 <u221e> print as a character
16:05:19 <liyang> nomeata: got email. Thanks for the prod. Will update... no guarantees on the timespan though. ^_^;;
16:05:27 <u221e> or a byte
16:05:53 <nomeata> liyang: thanks!
16:06:25 <nomeata> liyang: have you considered making that repository apt-get'able?
16:07:27 <ihope_> "It would be very natural to add a type Natural providing an unbounded size unsigned integer, just as Integer provides unbounded size signed integers. We do not do that yet since there is no demand for it." Pah...
16:07:31 <liyang> er, yes. I should shouldn't I.
16:07:55 <liyang> *cough*
16:08:54 <nomeata> liyang: just a convenience thing. most convenient would be to have gtk2hs in sid. do you know why that hasn't happend yet?
16:09:18 <liyang> (I'm on holiday until the middle of next week. I'll update stuff if my host has a suitably speedy connection...)
16:09:45 <liyang> nomeata: Laziness on my part. :)
16:10:14 <nomeata> allright :-)
16:10:31 <liyang> The official line is that I have too many other (more interesting) things I'm working on.
16:10:40 <liyang> But that's a lie really.
16:11:09 * shapr grins
16:11:20 <nomeata> and what about Marco Tulio Gontijo e Silva? I think he has filed an ITP
16:15:09 <nomeata> anyways, I gotta go. thanks for the debs, liyang!
16:15:12 <liyang> nomeata: when I spoke to him I got the impression he gave up on it.
16:15:29 <liyang> later
16:16:08 <nomeata> liyang: maybe you should take over the ITP then, so that people will bug^H^H^Hmotivate the right person :-)
16:18:14 <liyang> nomeata: I'm not in the mood for Debian bureaucracy... :(
16:28:08 <u221e> Doesn't Data.ByteString come with ghc?
16:29:01 <cjay> next version, afaik
16:29:46 <u221e> Crap...
16:31:49 <shapr> g'day Pseudonym 
16:32:50 <Pseudonym> G'day.
16:34:32 <palomer> GDAY
16:34:35 <palomer> @palomer
16:34:36 <lambdabot> Blargh!
16:35:42 * offby1 's ISP used to be called "blarg.net"
16:36:19 <palomer> best.isp.ever.
16:36:38 <offby1> palomer: you'd heard of blarg?!
16:37:07 <Pseudonym> That's the best ISP, but the best educational domain is Imperial College.
16:37:09 <Pseudonym> ic.ac.uk
16:37:36 <offby1> oh; you guys are talking about domain names, not ISPs.
16:37:49 <Pseudonym> Well I am.
16:37:50 * offby1 recalls pointing out ic.ac.uk to someone recently
16:38:03 * Pseudonym is proud of futplex.com
16:38:11 <Pseudonym> But a friend of mine owns dev.null.org
16:38:22 <Pseudonym> Which is even cooler.
16:39:02 <offby1> not bad ...
16:39:23 <bolrod> "Chuck Norris was originally cast as the main character in 24, but was replaced by the producers when he managed to kill every terrorist and save the day in 12 minutes and 37 seconds."
16:40:42 <offby1> pfft
16:42:15 <lispy> it would appear that using wxhaskell and gtk2hs in the same program spells trouble
16:43:17 <palomer> it spells wxhaskellgtk2hs
16:43:39 <iron32> lispy: Did you find the lectures about building a type checker ?
16:49:30 <lispy> iron32: yes but they are too large to download :( I'm going to stick to TaPL for now.  Thanks though.
16:49:51 <edwardk> lispy: what has you on a type checking kick?
16:51:52 <iron32> lispy: Well if I find the exact file lectures would downloading one or two of them be to much for you ?
16:52:19 <freshhawk> @docs missingH.Str
16:52:19 <lambdabot> missingH.Str not available
16:53:19 <lispy> iron32: if i changed computers  it wouldn't be so bad, but i have only about 500mb free and each lecture is about that size
16:53:31 <freshhawk> is there a mirror of the missingH docs anywhere? can't seem to get them at quux.org
16:55:05 <iron32> lispy: I see well if I run across anything else about type checkers I will let you know
16:55:43 <lispy> iron32: TaPL isn't bad
16:56:30 <iron32> lispy: ok
17:01:27 <pejo> Dr ser man. 
17:01:30 <pejo> Ups.
17:51:02 <vininim> "A poset(partially ordered set) can also be..."
17:51:14 <vininim> Is there really the need for the poset word? =P
17:51:49 * Arnia likes the term poset
18:00:20 <u221e> What do the "+RTS -p -RTS" profiling options mean?
18:09:31 <tony2> -p is for profile.  everything between +RTS (Run time system) and -RTS is an option, is that what you mean? 
18:11:24 <SamB> +RTS means "start of RTS options". -RTS means "back to program options"
18:13:03 <cjay> u221e: see section 4.14 and 5 in the manual
18:14:20 <u221e> Ok I get it, thanks
18:15:55 <u221e> Would buffering the output of an algorithm into a Data.ByteString to print it after algorithm completion be faster then putChar in the body of the algorithm itself?
18:24:30 <beelsebob_> doubt it - certainly not in terms of the user actually getting the output
18:24:51 <beelsebob_> maybe in terms of the algorithm finishing earlier
18:49:42 <dons> @seen u221e
18:49:42 <lambdabot> u221e is in #haskell. I last heard u221e speak 33 minutes and 47 seconds ago.
18:49:50 <dons> hey u221e 
18:50:08 <dons> yeah, if you're talking about mandelbrot, buffering would be better, but i'm not sure the spec allows us to
18:50:24 <dons> however, i'm not surprised a small change improved the code -- maybe it was enough for gcc to kick in 
19:09:03 <u221e> Hey dons...
19:09:25 <u221e> I improved you mandelbrot progam by 4 seconds ;)
19:09:58 <dons> cool!
19:10:00 <dons> same output?
19:10:05 <u221e> Yup.
19:10:08 <dons> (you diffed the result?)
19:10:11 <dons> ok. excellent.
19:10:26 <dons> want to post it some where? let me find you the mandelbrot wiki page we use
19:10:49 <edwardk> wow, i never realized people actually cared about those language shootout posts =)
19:10:58 <dons> regarding buffering, it would undoubtedly improve things, but might not be legal
19:11:08 <u221e> You were passing the height along with with width to most functions. But since the height can only been the same as the width it wasn't needed.
19:11:13 <dons> edwardk: ah, we've had so much good press since leading the shootout.
19:11:20 <edwardk> fair nuff
19:11:32 <dons> u221e: oh, hmm. i thought i'd dealt with that. well spotted u221e 
19:11:43 <dons> you compiling with the same flags?
19:11:52 <u221e> Yes
19:11:53 <dons> -fexcess-precision -optc-O2 -funbox-strict-fields ?
19:12:11 <Korollary> Without something like the shootouts, people's perceptions are all over the place.
19:12:20 <Korollary> I know lispers who think lisp is at least as fast as C.
19:12:20 <edwardk> yeah
19:12:23 <u221e> I used the options found on the shootout site.
19:12:25 <dons> here, you can add your code . i'll look at it, and then submit it further up the chain. http://www.haskell.org/hawiki/MandelbrotEntry
19:12:26 <lambdabot> Title: "MandelbrotEntry - The Haskell Wiki"
19:12:31 <edwardk> fair enough
19:12:42 <dons> Korollary: right. people just had no idea that we would average 1.3x the speed of C.
19:12:46 <dons> even the best were way off
19:13:00 <dons> empirical evidence is good for guiding intuitions :)
19:13:11 <Korollary> I was also surprised by java's JIT.
19:13:12 <edwardk> yeah
19:13:22 <edwardk> jit doesn't suck these days
19:14:30 <edwardk> a jit and a good copying collector can work wonders, because it doesn't need to touch anything it isn't going to use. if the generations are fast enough it can even remain reasonably cache coherent
19:14:37 <dons> an its a bit disappointing to see the fascination with things like javascript, php and ruby. all of which do very poorly
19:14:43 <edwardk> yeah
19:15:01 <dons> oh, well, the masses do what they want, i suppose
19:15:05 <edwardk> i thought ruby was kicking a bit of ass on there?
19:15:10 <edwardk> or did i read that backwards? =)
19:15:13 <Korollary> the opposite
19:15:15 <edwardk> lol
19:15:16 <dons> seems to be ranked 2nd last
19:15:20 <edwardk> fair enough
19:15:28 <Korollary> not that it matters. Certainly it could be improved a lot.
19:15:43 <dons> yeah, these are interpreted after all, and no one seems to mind
19:15:47 <u221e> What does -funbox-strict-fields do?
19:16:21 <dons> it uses strictness analysis to pack strict values into primitive data types, rather than heap allocating them
19:16:28 <dons> i.e. int versus Integer in java.
19:16:35 <dons> mucho speed up
19:17:03 <dons> you just can't have any 'undefined's in those values.
19:17:35 <dons> u221e: i found the mandelbrot code quite fragile with respect to runtimes
19:17:55 <dons> small changes to the code, with none or little semantic change, would have big 2-4x slow down or speed up
19:18:15 <dons> so it seems reasonable that a little tweak would bring us along side CCclean.
19:19:21 <alec> I'm going through the "Write Yourself a Scheme in 48 hours" and am stuck on one of the exercises.  I've managed to rewrite "liftM (Number . read) (many1 digit)" in do-notation, but haven't got a clue how to rewrite it with the >>= operator.  Can anyone point me in the right direction?
19:19:51 <dons> what does it look like in do notation?
19:20:07 <dons> well, basically, every x <- f in do-notation becomes: f >>= \f ->
19:20:12 <dons> semi colons become >>
19:20:31 <alec> ah
19:20:36 <dons> so, we have: do print "X" ; c <- getChar ; return c
19:20:46 <dons> would be: print "X" >> getChar >>= \c -> return c
19:20:56 <Korollary> doesnt that tutorial explain the de-sugaring?
19:21:12 <alec> Korollary: if it did, I missed it
19:21:19 <dons> well, the h98 report certainly does. so you could look there
19:21:27 <alec> dons: ok, thanks
19:21:28 <dons> though the above is all there is to it, really
19:21:49 <u221e> I don't notice much of a speedup using -funbox-strict-fields
19:22:10 <dons> ok, it may be that we don't have enough strictness. that's ok
19:22:32 <u221e> I've been using -O3 -optc-O3 -fglasgow-exts -fexcess-precision
19:22:37 <dons> or, alterately, the compiler had already worked out the strictness
19:22:46 <dons> u221e: what happens if you remove -fexcess-precision
19:23:01 <dons> (I'm expecting a big slowdown)
19:23:48 <u221e> Ok, lets see
19:25:44 <u221e> +32 seconds :)
19:26:02 <dons> so many times worse? 5x worse?
19:26:45 <u221e> 12 seconds vs. 44 seconds
19:26:55 <dons> ok. good stuff
19:26:58 <dons> and the original ran in?
19:27:20 <dons> (pretty good speed up just by tweaking a compiler flag, eh?)
19:28:10 <u221e> That was the original
19:28:36 <dons> oh, and the improved version runs in 8s?
19:28:41 <u221e> Mine is 42 seconds.... the gab seems to shrink with that option.
19:28:49 <u221e> gap
19:29:40 <dons> ok. it's to be expected that removing a variable will make only a small improvement. but anything is good at this point
19:30:11 <u221e> Yes but with the -fexcess-precision option, the original takes 12 seconds and the improved one takes 8
19:30:23 <dons> ok. great.
19:30:27 <dons> post it!
19:30:34 <u221e> Ok
19:30:41 <dons> i'll run some benchmarks tomorrow, and forward it to the shootout cvs 
19:30:55 <dons> maybe your change opens the way for some other tweaks
19:31:05 <dons> so, 
19:31:25 <u221e> Post that link again
19:31:26 <dons> > (8 / 12) * 7.84 -- current time
19:31:27 <lambdabot>  5.226666666666667
19:31:35 <dons> http://www.haskell.org/hawiki/MandelbrotEntry
19:31:36 <lambdabot> Title: "MandelbrotEntry - The Haskell Wiki"
19:32:00 <u221e> Is Data.ByteString not allowed in the shootout?
19:33:02 <dons> and 5.22 s would give us  us 4 or 5 places better
19:33:06 <dons> it will be once ghc 6.5 comes out
19:33:22 <dons> unfortunately, you can't (generally) install other libraries (unless you're C :/)
19:33:28 <dons> ah well, thems the rules.
19:34:26 <u221e> Heh the password for the wiki user isn't used? :P
19:35:04 <dons> well, you have to register, yes, and create a password. can't remember quite the details (we do't use the old hawiki so much anymore)
19:37:08 <u221e> Please enter your name like that: FirstnameLastname
19:37:13 <u221e> Heh...
19:46:31 <u221e> Ok, I uploaded it but I noticed the the current "Current Entry" is different then the one on the wiki.
19:46:45 <u221e> Mine is based on the current shoortout code.
19:46:53 <edwardk> oh well, so much for trying to abuse the arrow sugar for a more specific type =/
19:47:47 <edwardk> guess i'll try the old arrow preprocessor ad see if i can abuse that to the same end
19:50:50 <u221e> Is there a command line option to force recompilation?
19:53:32 <dons> -no-recomp
19:53:38 <dons> u221e: hmm. different/
19:53:43 <dons> can you check here:
19:53:44 <dons> ?shootout
19:53:44 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
19:53:50 <dons> maybe i just forgot to update the wiki
19:53:56 <dons> but maybe we forgot something, it's possible
19:54:51 <u221e> The one on the shootout seems to be the one with the printf line.
19:55:39 <dons> would you like to see which one runs faster? (it may just be that one is shorter, only)
19:55:55 <dons> i'm preparing my phd review , so can't investigate now
19:56:06 <dons> ?karma+ u221e -- shootout hacking
19:56:07 <lambdabot> u221e's karma raised to 1.
19:56:17 <dons> there's more good cookie where that came from :)
19:57:15 <u221e> The one on the wiki is a good 0.4 seconds faster then the one currently on the shootout
19:57:19 <dons> hmm
19:57:29 <dons> musn't have made it in for some reason
19:57:47 <dons> can you then take that, add your fixes, and i'll try to get it pushed through to the shootout?
19:58:09 <dons> we had so much going on at the time, its not impossible we forgot to submit something
19:58:15 <dons> (4 or 5 fixes a day were going in)
20:36:24 <dons> ?uptime
20:36:24 <lambdabot> uptime: 1 day, 2 hours and 48 seconds
20:52:14 <u221e> Hm I just compiled profiled versions of the origiinal and the improved one and the .profs say they finish in proetty much the same time...
20:55:25 <u221e> dons, you got any idea why this is?
21:40:30 <Korollary> u221e: the profile overhead is probably significant enough to render the differences negligible.
21:46:52 <Cale> Oh, btw, Sokoban *is* a monoid. (To go back to a discussion which was several months ago, and I don't know if anyone remembers it :)
21:48:29 <Cale> If you consider the set of words on {up,down,left,right}, there's a DFA which defines exactly when a given word puts you into a solved state.
21:49:11 <Cale> That DFA has a syntactic monoid, which was the one I was thinking of at the time, but had trouble expressing.
21:49:49 <Cale> (or, if you'd like the syntactic monoid of the regular language of solutions)
22:08:47 <rob-d> Sokoban the little game where you slide the blocks around?
22:11:08 <ruffneck> FDA approved?
22:12:55 <Pseudonym> Sokoban would be much easier were it a group.
22:14:40 <u221e> What would be the fastest way to build a Data.ByteString from sepperate Word8s?
22:15:42 <u221e> heh, separate even
22:36:14 <dgoldsmith> Is there any way in Hoogle or any other tool to see instance definitions? For example, if I want to see how Ordering is an instance of Ord, is that online or do I just need to look at the source?
22:36:41 <dgoldsmith> I know it lists whether something is an instance, but not *how* it's an instance.
22:38:04 <Korollary> @help instance
22:38:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:39:31 <Korollary> dgoldsmith: Prelude in the report has the definitios
22:46:47 <dgoldsmith> Hmm. OK, that works for instances in the Prelude. But how do I see how Ordering is an instance of Data.Monoid (which it is)?
22:47:03 <dgoldsmith> I already figure it out by experimentation, but I was hoping it was written down somewhere.
22:47:11 <dgoldsmith> s/figure/figured/
22:48:34 <Korollary> that's a non-standard library, so it's up to them. You probably only have the sources to look at.
23:30:25 <dons> u221e: just got an email from Mr. Shootout, Brent Fulgram, saying he's fixed the missing -fexcess-precision on the debian test
23:30:33 <dons> it goes from 11x slower to 1.6x slower, I think
23:30:39 <dons> with your speedup it should do even better
23:37:35 <u221e> dons what do you mean?
23:38:02 <u221e> -fexcess-precision wasn't missing
23:39:11 <u221e> Oh on debian it is..
23:39:18 <u221e> I was looking at gentoo
23:39:27 <ruffneck> how about unbtu?
23:39:49 <sieni> ubnutu?
23:40:04 <ruffneck> ubuntu
23:40:23 <ruffneck> sieni vanha pieru ;P
23:41:14 <u221e> Shouldn't 'putChar (B.w2c 10)' print something to the screen?
23:41:32 <ruffneck> sorry.. I don't know about haskell
23:41:39 <u221e> B is Data.ByteString.Char8 btw
23:42:00 <u221e> It compiled fine but nothing happens.
23:42:12 <ruffneck> can you show me reference I can check how it works?
23:57:26 <Lemmih> u221e: Depends on the buffering.
23:58:15 <u221e> Is there a flush command?
23:58:34 <Lemmih> @type System.IO.hFlush
23:58:35 <lambdabot> GHC.IOBase.Handle -> IO ()
