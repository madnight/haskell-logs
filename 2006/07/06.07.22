00:17:45 <u221e> How does printf work?
00:18:09 <edwardk> type trickery.
00:18:48 <edwardk> kind of like the polyvariadic functions that xerox was playing with the other day
00:19:59 <edwardk> there is a nice alternative implementation written up as part of template haskell that i rather prefer that can catch argument errors as type errors at compile time though.
00:20:51 <u221e> What's the easiest way to extend printf? I not only want it printed to stdout but a file too.
00:21:09 <edwardk> hrmm
00:21:19 <edwardk> good question, they don't really give an sprintf do they? =)
00:23:39 <edwardk> "Format a variable number of arguments with the C-style formatting string. The return value is either String or (IO a)."
00:23:58 <edwardk> so use it in a context where you'll get a string out of it, then take that string and send it to stdout and the file
00:25:57 <u221e> I would like to call me own function and pass the arguments to printf thought...
00:26:00 <u221e> though
00:27:53 <edwardk> ok, well, pointfree things appropriately and work around printf's funky variable return type.
00:27:55 <edwardk> hrmm
00:28:15 <jgrimes> u221e, does it have to be your program that does it? you couldn't just pipe it to the "tee" command?
00:28:59 <jgrimes> of course doing that would kind of kill portability...
00:29:13 <jgrimes> but I really have no idea as to what your purposes behind this are anyway :)
00:30:14 <u221e> Becuase I want to call a function myPrintf say, that would pass it's arguments to printf, grab the returned String and do some things to it.
00:43:00 <u221e> Well... that was simeple.
00:43:08 <u221e> simple too
00:43:49 <edwardk> ?
00:44:26 <edwardk> what was your solution?
00:44:26 <u221e> I just made my own function with printf's type declaration and passed it a string... seems to work.
00:44:34 * edwardk nods.
00:44:42 <u221e> then passed the string to printf
00:44:51 <u221e> I still have no clue how it works though.
00:45:17 <u221e> From what I know of haskell so far it SHOULDN'T work...
00:45:55 <edwardk> basically printf keeps returning you a function unless the return type has to be IO a or a String in order to satisfy Hindley-Milner
00:46:06 <edwardk> remember this isn't c++ so we can parameterize on return type
00:46:17 <u221e> Hm, I have a problem...
00:46:24 <edwardk> so it uses the context in which its being run to give you the stopping point
00:46:40 <u221e> RIght now my function is just another name for printf... that's not what I want.
00:49:52 <u221e> Is there an app like Hoogle but allows me to actually look at the function definition?
00:59:52 <u221e> @seen dons
00:59:52 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3 hours, 15 minutes and 30 seconds ago.
01:01:46 <dons> can't talk.... icfp
01:01:50 <u221e> hehe
01:05:18 * wli tries to muster the determination to write a CPO-STV CGI app.
01:10:13 <vincenz> who is lemonlime?
01:10:15 <alar> how can i force haskell to flush output?
01:10:16 <vincenz> dons: what is your team name
01:10:32 <alar> simple putStrLn does not write anything :)
01:10:48 <alar> vincenz: do you ever sleep? :)
01:11:17 <vincenz> alar: no, I had to get our score or advis up
01:11:17 <vincenz> :D
01:12:02 <wli> alar: hFlush stdout
01:12:38 <alar> thanks
01:12:40 <wli> Quiznos: Section 2 manpages document libc functions.
01:13:19 <wli> Quiznos: They're not docs for raw system calls.
01:16:30 <dons> vincenz: deaus-ex-machina. (.au has to start 8 hours behind you guys, but we're going strong now)
01:18:01 <u221e> How can I brose the haskell source to see how the libraries are implemented?
01:18:05 <u221e> browse
01:18:13 <dons> ?fptools Data.List
01:18:13 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
01:18:24 <dons> best way is to install libs locally, via darcs
01:19:06 <u221e> thanks
01:19:15 <u221e> ?fptools Text.Printf
01:19:16 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
01:21:51 <vincenz> dons: cool :)
01:43:51 * wli wonders if he can recruit helpers.
01:44:47 <wli> Extremely burned-out working programmer is looking for someone to write a CPO-STV CGI app in Haskell for him
01:45:03 <wli> (graduate student algorithm)
01:51:06 <goltrpoat> just curious, what do you need it for?
01:55:08 <Stinger_> CPO-STV?
01:55:56 <wli> Comparison of Pairs of Outcomes by the Single Transferable Vote
01:56:23 <wli> http://en.wikipedia.org/wiki/CPO-STV
02:04:17 <wli> goltrpoat: I basically want multi-winner webvoting (like electing a parliament for an online organization).
02:05:04 <goltrpoat> yeah i figured it was something to do with online voting, since i figured you wouldn't be asking for help on it if it were a clearance type situation
02:05:06 <goltrpoat> hehe
02:05:22 <wli> Mostly I'm just incredibly burned out.
02:05:36 <goltrpoat> ah
02:05:47 <goltrpoat> yeah i just went through that about six months ago
02:05:49 <wli> It's not a short-term thing.
02:06:16 <wli> It may require a career change (which will probably be forced on me anyway with offshoring and all).
02:07:04 <goltrpoat> yeah i hear ya.  ive been working probably 100 hour weeks on average for years on end, i keep waiting for it to catch up with me
02:07:49 <goltrpoat> keep slowly getting dumber every year, nothing drastic though
02:07:50 <goltrpoat> hehe
02:07:52 <wli> That's how it caught up to me.
02:08:09 <goltrpoat> -nod-
02:09:24 <wli> I should've gone into mgmt. a long time ago. I'm toast now.
02:09:49 <goltrpoat> if i recall correctly, you were doing kernel work last time we spoke.  still doing that?
02:10:03 <wli> Yeah, to the extent I'm still effective.
02:11:47 <goltrpoat> could go back to school and do contracting on the side, or something.  still a ton of work, but at least more varied work.
02:12:37 <wli> I suspect I'm headed toward burger flipping or factory work. I've got bubbles coming out my ears.
02:12:41 <goltrpoat> hehe
02:13:56 <wli> I've got a fantasy of escaping to Europe and programming there but it's a pipe dream and I can't hack it anymore anyway.
02:16:24 <u221e> Is there a function like printf put doesn't print anything to the screen and just returns a String?
02:16:39 <wli> sprintf?
02:17:40 <u221e> there is no sprintf ;)
02:18:30 <wli> There is, Printf.hs just doesn't export it.
02:18:43 <wli> OTOH it's a class method so it should be visible
02:19:00 <wli> unless I'm looking at a different Printf.hs
02:21:43 <wli> goltrpoat: CPO-STV looks pretty sexy from a lot of different angles... I already wrote a Schulze method CGI app but that took quite a bit of pushing myself to eke out as it stood and CPO-STV is slightly bigger.
02:24:53 <goltrpoat> i remember reading about condorcet's method, but i think that was entirely out of the context of programming
02:26:08 <wli> Well, Condorcet is an incomplete method, things are mostly said to be Condorcet complete, which is matching Condorcet when it produces a conclusive result
02:26:50 <wli> The Schulze method is a way to choose conclusive results.
02:26:50 <goltrpoat> that may have been the context, actually.  some voting paradox.
02:27:07 <wli> (called a completion method)
02:27:48 <goltrpoat> oh.  well, then:  http://en.wikipedia.org/wiki/Voting_paradox
02:28:00 <wli> CPO-STV treats the composition of the parliament/whatever as a candidate to carry out a Condorcet-complete decision process upon.
02:28:03 <goltrpoat> so now we've successfully established why ive heard of condorcet :)
02:28:20 <goltrpoat> yah, was just reading about it
02:28:24 <goltrpoat> cpo-stv i mean
02:28:50 <wli> There are less naive ways of going about it but I expect naive methods will do.
02:29:43 <wli> (they're based on approximating the CPO-STV result with plain STV then refining that result to determine the CPO-STV result)
02:30:19 <goltrpoat> ah
02:30:19 <wli> James G. Armytage did a terse writeup on that.
02:32:08 <wli> I think the combinatorial explosion is something like Choose(candidates - 1, seats - 1)
02:33:49 <wli> The best candidate for STV is known to get a seat, the worst is known excluded, then a let n = (candidates - 1) `choose` (seats -1) in n*(n-1) comparison matrix.
02:34:26 <goltrpoat> in other words, don't try to use this to assign 100 scholarships to 5000 applicants.
02:36:35 <wli> Well, somehow party-list voting needs to be factored in, but I have no idea how.
02:39:32 <wli> doh, quotas of first preferences require inclusion
02:40:00 <wli> That makes speed depend on the voting behavior.
02:41:36 <goltrpoat> actually.. am i on crack about the 100 seats / 5000 candidates thing?  the whole matrix doesn't need to exist at any one time, right.. you're just computing results on individual rows
02:42:08 <goltrpoat> so at least the memory complexity doesn't explode in the same way.
02:42:41 <goltrpoat> (still reading about schulze)
02:43:10 <wli> once you get the matrix of pairwise comparisons (however ephemeral) you have to use e.g. beatpath on it. It could be trivial e.g. when there's a Condorcet winner but otherwise you've got to do all the path weight calculation.
02:43:48 <goltrpoat> schulze == beatpath?
02:43:57 <wli> yeah
02:45:00 <wli> "CPO-STV" Armytage
02:45:12 <wli> That brings up the shortcut in google if you're interested there.
02:46:09 <goltrpoat> yah i found his page when you mentioned him
02:46:31 <goltrpoat> the "voting methods survey" bit scared me
02:48:29 <goltrpoat> so one upper bound is something like n times the diameter of the graph
02:49:37 <wli> It's hairy whatever it is.
02:49:44 <goltrpoat> -nod-
02:50:04 <wli> The brute-force CPO-STV doesn't require so much thought just enough coding stamina to churn it out.
02:50:41 <goltrpoat> looks like it
02:51:44 <wli> I figure one of these days the bubbles in my head will temporarily gel into something semisolid enough to eke it out.
02:52:53 <wli> Here's one way to use it more practically in an online organization.
02:53:53 <wli> So various agenda proposals come in and after a few rounds of cleanup the textually distinct rephrasings are coalesced until there's a large, coherent set of candidates (e.g. 100 candidate agenda items).
02:54:35 <wli> The goal is to pick 10, so the those 100 candidates are circulated and people rank the top 10 or more in order of preference.
02:54:57 <wli> CPO-STV and the online org's agenda is set.
02:55:40 <u221e> Damn, icfp... no one is around to answer any questions.
02:56:11 <goltrpoat> until the board members get wind of it and ask for their votes to be weighed higher
02:56:35 <wli> goltrpoat: Depends a lot on the structure of the org, of course.
02:56:41 <goltrpoat> hehe yeah
02:57:15 <wli> goltrpoat: Precisely what you mentioned happened recently with moveon.org whose higher-ups moved to strike anything about Iraq from their agenda.
02:57:33 <goltrpoat> eh?
02:57:34 <goltrpoat> lovely
02:57:38 <wli> They had a nominally democratic agenda-setting system.
02:57:40 <goltrpoat> why'd they do that
02:58:23 <goltrpoat> the war is not exactly popular.  doesn't make sense.
02:58:26 <wli> goltrpoat: Long story. The main thing is that the weighting concern has already happened in real life.
02:58:46 <wli> Well, the specifics and/or meaning aren't what I'm on about.
02:58:59 <Adamant> Arrow's Theorem
02:59:03 <wli> Rather that the "board" or whatever stepped in and vetoed stuff.
02:59:16 <wli> (more properly, rigged, but anyway)
02:59:24 <goltrpoat> yah, it just popped into my head because however democratic a particular company tries to be, if it's externally funded, the whole democracy spiel goes down the drain at key moments
02:59:29 <goltrpoat> in my experience anyway
02:59:37 <Adamant> then, there's the "Skiddies with Zero Day" Theorem
02:59:48 <Adamant> for online elections
03:00:13 <Adamant> sorry, I can't sleep and I'm cynical
03:00:19 <wli> goltrpoat: Well, that's another issue entirely.
03:00:26 <wli> Adamant: Never heard of that.
03:00:49 <Adamant> Arrow's Theorem basically says no voting system is ever perfectly fair
03:01:02 <Adamant> of course, it's couched in mathematics
03:01:34 <wli> Adamant: I know Arrow's theorem. "Skiddies with Zero Day" I've not.
03:01:44 <Adamant> ah
03:01:59 <Adamant> basically, any online voting over insecure media has credibility problems
03:02:10 <Adamant> the Internet is an insecure media
03:02:15 <wli> More specifically?
03:02:20 <goltrpoat> i remember some place required a photocopy of your driver's license.
03:02:52 <Adamant> "Skiddies with Zero Day" = Script Kiddies with a Zero-Day browser exploit
03:02:58 <wli> Adamant: What exactly is the "Skiddies with Zero Day" theorem?
03:03:03 <Adamant> it's a joke
03:03:07 <Adamant> not a real theorem
03:03:11 <Adamant> although the issue is real
03:03:32 <wli> Well, there are authentication methods, e.g. tying authentication to a gpg web of trust.
03:03:33 <goltrpoat> there was specific risk for people trying to abuse it because it had to do with what city was going to host a particular event, and a large number of the voters had financial interest
03:04:07 <Adamant> you could probably generate digitized "driver's licenses" programmatically
03:04:11 <goltrpoat> so i guess they just made you send in an id photocopy.  not exactly failsafe, but nothing.
03:04:14 <goltrpoat> er
03:04:19 <goltrpoat> but better than nothing, rather
03:04:32 <goltrpoat> not sure how i managed to lose two whole words there.
03:04:46 <wli> gpg web of trust would be interesting to try to rely upon
03:04:58 <Adamant> who signed who's key?
03:04:58 <wli> I'm not sure what anyone's ever done with webs of trust.
03:05:09 <wli> And flow equations based thereupon.
03:05:13 <Adamant> I barely trust random PGP keys as it is
03:05:37 <wli> yeah, I'm not sure anyone takes it seriously
03:05:53 <Adamant> yeah, all I can say is good luck
03:05:57 <wli> Or that it should be taken seriously.
03:06:08 <wli> Well, I'm not trying to deal with anything on that level.
03:06:10 <Adamant> with the stuff, you have a really hard job
03:06:13 <Adamant> ah, ok
03:06:18 <Adamant> not your purview
03:06:23 <goltrpoat> nice.  i'm supposed to get up for a conference about three hours from now
03:06:28 <goltrpoat> somehow i don't think that'll happen.
03:06:56 <Adamant> conference on what?
03:06:58 <wli> no problem
03:07:14 <goltrpoat> "texas independent game conference"
03:08:07 <Adamant> I bet you are in Austin then
03:08:11 <goltrpoat> yeah
03:08:24 <Adamant> I need to make it out there sometime
03:08:32 <Adamant> it sounds like my kind of place
03:08:47 <goltrpoat> it's ok.  seen better, seen worse.
03:08:50 <goltrpoat> fucking hot right now.
03:09:03 <Adamant> hot's no problem, I'm from south Georgia
03:09:13 <Adamant> can't get much worse than here
03:09:19 <Adamant> barring rainforest
03:09:19 <goltrpoat> true
03:10:14 <Adamant> are any gaming companies in the Austin area using any FP/non-standard langs?
03:10:24 <goltrpoat> well.. we are
03:10:29 <Adamant> Haskell, O'Caml/SML, Lisps, etc
03:10:41 <goltrpoat> that's still mostly in r&d though
03:10:45 <Adamant> ah
03:10:56 <Adamant> prototyping
03:11:06 <goltrpoat> i can't really name any game companies anywhere that use FP to a large extent
03:11:24 <Adamant> well, there's Naughty Dog
03:11:27 <Adamant> but that's about it
03:11:42 <goltrpoat> oh?  hadn't heard that about them
03:11:58 <Adamant> yeah, they wrote their own Lisp to do game development in
03:12:06 <Adamant> and IIRC, another to do event scripting
03:12:26 <Adamant> although I don't think they were strict FP'ers
03:12:35 <goltrpoat> ah
03:13:35 <Adamant> I wonder how much they could hand-optimize when required
03:14:57 <yip> hey guys, i got a q
03:17:30 <yip> sort of an "OOP" question.... let's say the 'shape' class that has a 'draw' operation, and a state-changing 'rotate' operation
03:18:07 <yip> to rotate a circle, no action is needed, but to rotate a square, the shape's state must be changed
03:18:34 <yip> the question is, how can i create such a system in haskell, in such a way that i can have a collection of shapes, rotate all of them, and then draw all of them?
03:19:00 <malcolm> the rotate method takes a shape as argument and returns a new shape as result
03:19:19 <malcolm> then just "map rotate listofShapes"
03:19:21 <yip> the types of shapes that are available is not known
03:19:41 <yip> malcolm: what would be the type of listofShapes?
03:19:50 <malcolm> oh I see what you mean
03:20:17 <malcolm> there are various standard constructions for this - existential types is one
03:20:42 <malcolm> e.g. listOfShapes :: [ Shape a => a ]
03:21:07 <yip> if i only needed the "draw" operation, then i could just use a list of functions, but with "rotate" this will not work
03:21:20 <yip> hm... existential types... don't know about those
03:21:49 <malcolm> data AnyShape = forall a . Shape a => Any a
03:22:33 <malcolm> Notice that the type variable 'a' does not appear on the LHS of the datatype.  This is an existential - it is quantified on the RHS
03:23:30 <yip> hm...
03:23:40 <malcolm> It means you can only build an AnyShape value by taking some value of type Circle or Square or whatever, but whatever it is, it must belong to the Shape class.
03:24:05 <malcolm> Then your listOfShapes :: [AnyShape]
03:24:20 <yip> this looks good
03:24:46 <yip> what is Any?
03:24:57 <malcolm> Any is a normal data constructor
03:25:37 <malcolm> You need to wrap up your Circle or Square or whatever inside this extra layer.
03:26:08 <yip> [Any (Circle 2), Any (Square 5)]
03:35:51 <yip> is it true that GADT generalises existential types?
03:37:06 <malcolm> yes
03:45:56 <hellish> @pointless registerPtrC x = getBits x 29 3
03:45:57 <lambdabot> registerPtrC = flip (flip getBits 29) 3
04:09:56 <malcolm> ping psnl
04:12:08 <edwinb> malcolm: I don't think he has internet access over the weekend at the minute...
04:13:15 <malcolm> edwinb: ta. (but he does appear in the list of people in the channel at the moment)
04:13:43 <edwinb> just so you know you might have to ask again on Monday ;)
04:21:31 <fasta> What Debian package do I need for GHC to recognize that I do have readline installed?
04:21:36 <fasta> I get: configure: WARNING: no configuration information is in readline.
04:22:08 <fasta> I have libreadline5-dev installed
04:34:47 <goltrpoat> goltrpoat wrote the longest lines, averaging 74.1 letters per line.
04:34:49 <goltrpoat> haha typical
04:38:29 <shapr> @yow !
04:38:30 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
04:38:40 <shapr> malcolm: Coming to AngloHaskell?
04:39:00 <malcolm> shapr: sorry no, I'm out of the country
04:39:49 <shapr> Aww
04:40:01 <malcolm> otherwise it would have been fun
04:40:04 <shapr> Maybe next year? :-)
04:40:37 <shapr> Is there some unix cmdline util that will show an ascii art tree of directories?
04:40:53 <xerox> ls -f
04:41:03 <u221e> Is there a way to have a series of modules imported without having to specify all of them in each and every file?
04:41:09 <shapr> xerox: Hm, doesn't seem to make a tree.
04:41:18 <xerox> Hmm, it used to.
04:43:18 <u221e> Anyone?
04:43:40 <xerox> u221e: write a module importhing them and then import it
04:43:59 <malcolm> need to re-export them all from the collecting module too
04:44:16 <u221e> Hm?
04:44:57 <malcolm> module Everything (module One, module Two) where { import One; import Two}
04:45:28 <u221e> That looks strange...
04:46:46 <u221e> Well, I guess I'm off to rewrite printf alittle bit.
05:08:02 <ejt> hi all
05:08:22 <ejt> is there a way to force ghc to evaluate something completely when compiling
05:08:23 <ejt> ?
05:08:44 <ejt> eg, a long (but not infinite) list that is used as a lookup table
05:11:18 <Philippa_> nope. No way to prove to GHC that it terminates, which means the compiler might not either
05:11:45 <Philippa_> goltrpoat: does figure, doesn't it?
05:12:03 <ejt> k, I wondered if there was a way to annotate it
05:12:04 <Philippa_> I guess I'm just thankful I'm not ranked higher
05:12:18 <Philippa_> still doesn't prove anything, sadly
05:12:44 <ejt> ouwld it help if I made a strict list type, eg. data List = Cons !List !List | Nil ?
05:13:00 <ejt> s/ouwld/would/
05:13:13 <Philippa_> nope, it can still fail to terminate
05:13:36 <xerox> data StrictList a = Cons !a !(StrictList a) | Nil
05:13:52 <ejt> xerox: y
05:16:29 <malcolm> ejt: what you want is a partial evaluator.  You divide your input data into statically known vs dynamically entered, then a tool goes away and computes a residual program that only depends on the dynamic data, and all the static stuff has already been done.
05:17:14 <ejt> true, I could just generate the result, that's what I would do in C
05:22:45 <yip> maybe template haskell can help?
05:29:03 <Philippa_> malcolm: often the actual case is "this here expression - evaluate it as completely as possible". I guess currying has its uses
05:29:18 <Philippa_> and yes, TH'd be the way to go for now
05:30:02 <ejt> I'll pass, need to get fluent at vanilla Haskell first
05:30:04 <Philippa_> I guess in a lazy language there's the whole "so what's driving demand?" issue
05:30:52 <malcolm> Philippa_: how about just loading the module in Hugs/ghci, running it, then cutting and pasting the result back into a new module?
05:31:32 <shapr> @yow !
05:31:32 <lambdabot> Yow!  We're going to a new disco!
05:31:42 <malcolm> It's called "staged computation", and is easy enough to do by hand sometimes
05:31:55 <shapr> Like the memoization array stuff in PreludeExts
05:31:59 <Philippa_> it's not so easy if it was a function you wanted evaluated
05:32:23 <shapr> Lor's memoize works pretty well.
05:32:34 <malcolm> ah, evaluation inside lambdas is another topic - "full laziness" I think?
05:32:42 <shapr> memoize' f range = ((map f range) !!)
05:33:49 <Philippa_> yeah, I'd certainly want to do some thinking. My usual use case is something simple like interpret program progparms where you want interpret program evaluated as much as possible
05:34:18 <Philippa_> (largely so's to expose the resulting interpreted program to the optimiser)
05:34:20 <edwinb> it's even more fun if you don't know what the program you want evaluated is until run-time...
05:34:41 <Philippa_> well yes. I think my point is that it's damn annoying having to resort to TH when I do know :-)
05:34:52 <malcolm> Philippa_: well then a partial evaluator is exactly the right thing
05:34:56 <JKnecht> @seen Lor
05:34:57 <lambdabot> I haven't seen Lor.
05:35:05 <Philippa_> yep
05:35:08 <malcolm> Philippa_: I think John Hughes wrote one for Haskell
05:35:23 <edwinb> oh, did he?
05:35:26 * edwinb searches
05:35:39 <Philippa_> there's one for a Mini-Haskell, and one in TH floating around
05:38:33 <Philippa_> I think the thing that bugs me about my use case is that in a strict language I don't think there'd be any 'partial' about it. But hey, still gotta convince the compiler it's either going to terminate or doesn't care
05:39:26 <goltrpoat> reminds me, i still haven't touched TH
05:39:50 <Philippa_> TH is surprisingly easy. My first Impure Thoughts article should show you what you need
05:40:33 <goltrpoat> oh, i think ive read that one
05:41:22 <yip> i have a hard and long question
05:41:48 <yip> and multi-part
05:42:29 <goltrpoat> philippa:  you'll be happy to know that i wrote a lazy fp language in the c++ preprocessor a few months back
05:42:36 <goltrpoat> my goal was to make something that *everyone* will cringe at
05:42:50 <goltrpoat> imperative folk, functional folk, etc
05:42:55 <goltrpoat> i think i succeeded brilliantly.
05:43:55 <ejt> goltrpoat: did you publish this, or rm -rf it straight away ?
05:44:11 <goltrpoat> as far as i can tell, it's utterly useless, unless you're into quicksorting compile-time arrays.
05:44:27 <goltrpoat> ejt:  ive been writing a paper on it.
05:45:10 <ejt> sounds like something the Boost people would be interested in
05:45:38 <goltrpoat> yeah, it overlaps with a fair bit of functionality in boost
05:45:50 <goltrpoat> i think my partial application is nicer, but eh.
05:46:34 <shapr> memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
05:46:34 <shapr> Admittedly, I'd rather go for the lazy pipeline approach to minimze memory use.
05:46:34 <shapr> Are there other popular or beneficial high level structures like the lazy pipeline?
05:48:40 <shapr> grr - Ping time to shapr is 00:13.46
05:48:49 <xerox> shapr: how's icfpc?
05:49:09 <shapr> I just read the task description, I won't have time to do the contest.
05:49:30 <xerox> lazy bottoms are doing great it seems
05:49:30 <shapr> It does look like a fun contests.
05:49:50 <goltrpoat> shapr:  filter graphs?  they have to restrict laziness in a way -- stuff has inputs and outputs, this cycle's inputs affect next cycle's outputs, and the computations per filter are cached *per cycle*
05:50:03 <goltrpoat> so it's memoization that gets purged every iteration
05:50:07 <xerox> http://www.icfpcontest.org/scoreboard.shtml
05:50:10 <lambdabot> Title: ICFP Programming Contest, 2006 : Scoreboard
05:50:42 * xerox is scared by the "Can't Spell Awesome without ASM" team name
05:50:53 <goltrpoat> that IS scary.
05:51:24 <shapr> xerox: Wow, Lazy Bottoms are 6th!
05:51:33 <xerox> Yeah
05:51:50 <malcolm> How about circular programming "tying the knot" as a high-level pattern
05:52:20 <shapr> Hm, yeah.
05:52:46 <shapr> Zipper seems to fit into tying the knot to me.
05:53:29 <shapr> Always makes me think of those Rubik's snakes.
05:53:48 <shapr> Anyway, I gotta fix the network here before I move my computer to my new apartment.
05:54:04 * shapr signoff network fixing
05:54:13 <xerox> Rubik's snakes?
05:54:18 <xerox> Ouch.
05:56:13 <goltrpoat> ultimately, it's pull vs push.. lazy languages standardize on the former, strict ones on the latter
06:00:58 <goltrpoat> so then we end up with hacks in both whenever we need an instance of the "other" model
06:08:18 <Philippa_> I'm trying to decide if I'm bored enough to enter the ICFP contest on my own. Oh, and pick a silly team name, because that has to happen
06:09:04 <goltrpoat> i tossed the idea around for about 15 minutes
06:09:54 <goltrpoat> got a ton of work to do though
06:11:41 <Philippa_> I haven't. I guess it's not too big an issue if I give up after a few hours
06:15:21 <goltrpoat> it looked like a VM with [insert details i didn't read]
06:20:10 <Philippa_> that's the start, yes
06:26:47 <goltrpoat> what's a good constraint programming book?
06:27:05 <goltrpoat> preferrably recent, preferrably with a ton of exercises and examples, don't really care what language
06:29:43 <goltrpoat> http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=8270&xid=4&xcid=0 looks nice, but i'm green as hell.  bit of a background in optimization theory if that helps.
06:29:44 <lambdabot> Title: Principles and Practice of Constraint Programming - Table of Contents - The MIT  ...
06:29:54 <goltrpoat> thank you, lambdabot.
06:31:14 <yip> about that, let's say i have:
06:31:27 <yip> data Numba = Zero | Succ Numba
06:31:42 <yip> now i can write a function inc x = Succ x
06:31:53 <yip> and i can write a function dec (Succ x) = x
06:32:11 <yip> dec uses a patten match, but doesn't match over all possible constructors
06:32:13 <xerox> (`dec' is not total this way.)
06:32:57 <yip> yeah, i'm interested in knowing about systems that will but require proving that all evaluations of dec function meet the condition that the function argument is only of the Succ constructor
06:33:32 <xerox> Sounds like invariants.
06:33:36 <yip> i can write an add function, add x Zero = x; add x y = inc (add x (dec y))
06:34:00 <yip> now i must prove that the y argument in that dec evaluation is only of a constructor Succ
06:34:09 <xerox> Why don't you want to write the Zero case?
06:34:51 <yip> because i want to express that the value "Zero" is invalid with the dec function
06:35:19 <yip> and so whenever someone wants to evaluate dec they must first prove that the argument is of a valid value
06:35:42 <yip> i am also interested in proving that the add function above terminates for all arguments
06:38:02 <goltrpoat> mindfuck x = if (mod x 3 == 3) then (mindfuck $ dec x) else (mindfuck $ inc x)
06:38:31 <goltrpoat> mindfuck 987234987 is going to result in a very long compile time, at best
06:40:28 <goltrpoat> blah.  make that == 0
06:42:25 <goltrpoat> actually, i guess == 3 works too.  dec is never called, but without some guarantees on the output of whatever form mod takes in this, how would you tell that mindfuck 0 is legal
06:43:00 <goltrpoat> or that it's illegal in the == 0 verison
06:43:09 <yip> well that's why mod would also have to be "in on the scheme"
06:43:46 <SamB_XP> goltrpoat: what language are you talking about?
06:44:14 <SamB_XP> also yip
06:44:36 <yip> i think i we are talking about haskell
06:45:10 <SamB> really?
06:45:14 <goltrpoat> yip:  oh, so mod, div, sub, add, etc are written with the explicit guarantee that dec Zero doesn't happen?  or that if it does happen, then the expression is broken?
06:45:19 <SamB> why is this going to take forever to compile then?
06:46:00 <SamB> also why are we calling this type Numba instead of Nat?
06:46:12 <yip> goltrpoat: the idea is that everytime you write "dec x", you must prove that x is of a valid value that dec will accept, in this case it must be such a value that is built from the Succ constructor and not the Zero constructor
06:46:21 <goltrpoat> well.. the point was that if the compiler has to detect, in this case, that dec 0 is illegal, then that function would be difficult to reason about
06:47:04 <goltrpoat> yip:  doesn't that more or less require that you build up the arithmetic from dec and inc
06:48:17 <yip> yes
06:48:33 <yip> but what other ways are there for building up the arithmetic?
06:49:09 <goltrpoat> gotcha.  i misunderstood what you were saying
06:49:26 <SamB> hmm.
06:49:35 <SamB> too bad you can't define datatypes locally...
06:50:18 <SamB> then you could test this here by doing something like
06:50:19 <yip> things get more interesting when we define a sub function
06:50:59 <yip> the idea would be to somehow prove that (sub x y) is only valid if x >= y
06:51:14 <yip> and then for every expression (sub x y) you must actually prove that relation
06:52:09 <goltrpoat> well.. sub x 0 = x, and something like sub x y = sub (dec x) (dec y)
06:52:19 <goltrpoat> that'll fail when x < y
06:53:00 <yip> yep, as it should
06:53:10 <SamB> hey wait
06:53:21 <SamB> you can't write stuff like that without a Num instance...
06:53:39 <yip> you mean "x < y"
06:53:57 <SamB> I meant the numeric literals ;-)
06:54:10 <goltrpoat> er.  Zero, not 0
06:54:25 <yip> right, actually "x < y" is the tough part, since we haven't really defined what it means with Numba
06:54:58 <goltrpoat> well, x=Succ(y) is transitive, and establishes a total ordering, right.
06:55:18 <yip> with the dec function it was easy to come to the conclusion about valid values, since we were dealing with a non-exhaustive pattern match. but how the heck do we get to "x >= y" conclusion in this sub function?
06:56:01 <SamB> what about mod?
06:56:04 <goltrpoat> we can say, recursively, that x > y iff there exists z s.t. Succ(z) = x, and z > y.
06:56:09 <SamB> @type mod
06:56:10 <lambdabot> forall a. (Integral a) => a -> a -> a
06:56:51 <yip> goltrpoat: you are defining '>' in terms of '>'
06:57:00 <goltrpoat> hence "recursively"
06:57:04 <yip> hm...
06:57:15 <goltrpoat> except.. forgot something.
06:57:30 <goltrpoat> add.. ".. or z = y"
06:58:36 <goltrpoat> basically, the point is that if x > y and x,y are naturals, then either there's a z between them, or x = y+1.
06:59:15 <SamB> hmm, it is annoying that you have to define an instance for Eq seperately from Ord...
06:59:31 <yip> can't we just define < as such:
06:59:36 * SamB wonders if this could be altered
06:59:40 <yip> Zero < Zero = False
06:59:47 <yip> Zero < _ = True
06:59:55 <yip> _ < Zero = False
07:00:09 <yip> x < y = (dec x) < (dec y)
07:00:49 <yip> of course we first need a data Bool = True | False
07:01:41 <SamB> yip: if this is Haskell you already have Bool...
07:01:44 <SamB> don't you?
07:02:10 <yip> this is i guess haskell without the prelude
07:02:15 <SamB> oh
07:02:27 <SamB> well, you can copy/paste Bool from Prelude ;-)
07:02:50 <xerox> SamB hinders code duplication :P
07:02:54 <goltrpoat> ive been assuming it was a language that looks and operates remarkably like haskell, but is blissfully ignorant of arithmetic of any sort
07:03:00 <yip> goltrpoat: yes
07:03:20 <SamB> goltrpoat: Haskell doesn't know anything about arithmetic either
07:03:42 <goltrpoat> you know what i mean.
07:03:46 <SamB> its just that there are some numeric types in the base library that are implemented by undisclosed means ;-)
07:04:42 <SamB> I have:
07:04:52 <SamB> instance Eq Numba where
07:04:52 <SamB>     (==) x y = compare x y == EQ
07:04:52 <SamB> instance Ord Numba where
07:04:52 <SamB>     compare  Zero     Zero    = EQ
07:04:52 <SamB>     compare  Zero    (Succ _) = LT
07:04:53 <SamB>     compare (Succ _)  Zero    = GT
07:05:01 <SamB>     compare (Succ x) (Succ y) = compare x y
07:07:34 <SamB> it really would be nice if you didn't have to write the Eq instance
07:09:33 * SamB wonders if it would be reasonable to allow default implementations that only work if the type is an instance of another class too...
07:10:00 <goltrpoat> bedtime
07:10:35 <SamB> wow, Haskell code looks so nice and works so nice too ;-)
07:11:01 <SamB> I haven't really written anything for a while aside from one-liners for lambdabot...
07:11:36 * SamB goes to take a shower
07:27:33 <Philippa_> can I trust the compiler not to optimise mapArray a id to a?
07:27:40 <Philippa_> (I'm using it as "copyArray")
07:28:11 <SamB> well I don't see how it could with no RULE
07:34:06 <kuribas> Why would you need "copyArray" in a purely functional language?
07:38:30 <genneth> can someone help me get a combination of Cont and State correct?
07:38:38 <genneth> my head is about to explode
07:39:09 <genneth> I'm trying to adapt the paper by Pen and Zdancewic on unifying events and threads
07:39:38 <genneth> the central idea is to do CPS on a thread
07:40:02 <Philippa_> kuribas: who says I'm being purely functional? The code's in the IO monad using IOUArrays
07:40:18 <genneth> in my case, I need a particular state to be always with the thread, specifically a Float representing time
07:40:29 <genneth> do I want a StateT Cont or ContT State?
07:55:21 <fasta> What does this mean? configure: WARNING: no configuration information is in readline. ?
08:12:09 <vincenz> > [1..10] //1
08:12:10 <lambdabot>  Couldn't match `Array i e' against `[a]'
08:12:27 <vincenz> > [1..10] \\1
08:12:28 <lambdabot>  add an instance declaration for (Num [a])
08:12:28 <Lemmih> [1..10] \\ [1]
08:12:32 <Lemmih> > [1..10] \\ [1]
08:12:33 <lambdabot>  [2,3,4,5,6,7,8,9,10]
08:13:24 <vincenz> > [1..10,1] \\[1]
08:13:25 <lambdabot>  Parse error
08:13:39 <vincenz> > ([1..10] ++[1] \\[1]
08:13:39 <lambdabot>  Parse error
08:13:41 <vincenz> > ([1..10] ++[1]) \\[1]
08:13:43 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
08:32:22 <vincenz> > 3 >= 2
08:32:43 <lambdabot>  True
08:33:16 <ValarQ> hmm
08:51:02 <Philippa_> damn. genericLength has shitty stack behaviour...
09:22:58 <vincenz> > nil
09:22:59 <lambdabot>  Not in scope: `nil'
09:23:45 <yip> > Nothing
09:23:46 <lambdabot>  Add a type signature
09:24:09 <yip> > Nothing :: (Maybe (Maybe (Maybe (Maybe Bool))))
09:24:11 <lambdabot>  Nothing
09:26:09 <boegel> hehe :)
09:26:33 <boegel> > Just :: (Maybe (Maybe (Maybe (Maybe Bool)))
09:26:33 <lambdabot>  Parse error
09:26:41 <boegel> > Just :: (Maybe (Maybe (Maybe (Maybe Bool))))
09:26:42 <lambdabot>    Expecting a function type, but found `Maybe (Maybe (Maybe (Maybe Bool)))...
09:26:53 <boegel> > Just True :: (Maybe (Maybe (Maybe (Maybe Bool))))
09:26:54 <lambdabot>  Couldn't match `Maybe (Maybe (Maybe Bool))' against `Bool'
09:27:06 <boegel> urgh, nvm :)
09:27:33 <boegel> > Just (Just (Just (Just True))) :: (Maybe (Maybe (Maybe (Maybe Bool)))
09:27:33 <lambdabot>  Parse error
09:27:40 <boegel> > (Just (Just (Just (Just True)))) :: (Maybe (Maybe (Maybe (Maybe Bool)))
09:27:41 <lambdabot>  Parse error
09:28:02 <boegel> > (Just (Just (Just (Just True)))) :: (Maybe (Maybe (Maybe (Maybe Bool))))
09:28:02 <xerox> ?type Just undefined :: Maybe (Maybe (Maybe (Maybe Bool)))
09:28:03 <lambdabot>  Just (Just (Just (Just True)))
09:28:04 <lambdabot> Maybe (Maybe (Maybe (Maybe Bool))) :: Maybe (Maybe (Maybe (Maybe Bool)))
09:28:26 * boegel needs to repractice his type skills
09:36:40 <alar> 2 short questions
09:37:03 <alar> is Data.Array.(!)  O(1)?
09:37:38 <Lemmih> alar: Yes.
09:37:42 <alar> how can I ask GHC "tell me how long time did it take to evaluate my IO () function"
09:37:44 <alar> ?
09:38:08 <Lemmih> :set +s
09:38:13 <alar> if there's no realtime, reductions/cells count would be ok
09:38:25 <alar> @karma+ Lemmih
09:38:26 <lambdabot> Lemmih's karma raised to 19.
09:59:58 <vincenz> > [1,1,2] \\ [1]
09:59:59 <lambdabot>  [1,2]
10:01:01 <vincenz> :w
10:06:27 <vincenz> ok
10:06:29 <vincenz> solver works
10:06:30 <vincenz> but is seriously slow
10:06:36 <vincenz> I gotta figure out a way to use some more heuristics
10:06:43 <vincenz> whoops
10:06:44 <vincenz> wrong channel
10:06:45 <xerox> (:
10:06:48 <xerox> icfpc?
10:06:50 <vincenz> :D
10:07:00 <xerox> best luck!
10:07:04 <vincenz> :)
10:08:57 <MarcWeber> I want to count the number of each ascii code in a file. Would you use an array as datatype for that task?
10:09:41 <mahogny> Array, sounds good. you already know the size of it
10:09:49 <mahogny> some might go for ST type Array
10:09:55 <ibid> in an imperative language yes
10:10:07 <MarcWeber> mahogny: How do I access an element? convert to list and use !!?
10:10:08 <ibid> not in haskell, at least not immutable arrays
10:10:25 <mahogny> ibid: how would you prefer it?
10:10:56 <mahogny> you can of course do a length filter combo. but oh the speed...
10:10:57 <ibid> my first reaction is to use a map
10:10:59 <Korollary> use Data.Map?
10:11:34 <ibid> the problem with immutable arrays is that they don't handle individual element updates well
10:12:16 <mahogny> well, right. if you're in for speed here, then you should go all the way with unsafe mutable arrays, unboxed I guess
10:12:33 <MarcWeber> But dictionaries are too much for this task. All I need is accessing the 5th element add increment it.. This doesn't mind (in my case)..
10:12:53 <ibid> MarcWeber: use IntMap
10:13:30 <MarcWeber> Thanks
10:13:48 <waern> anyone here who knows their way around the GHC renamer?
10:14:14 <MarcWeber> Never heard.
10:14:59 <fasta> waern: you mean the mangler?
10:15:07 <waern> fasta, no..
10:15:19 <MarcWeber> So I should add each ascii code once and use update afterwards?
10:15:20 <waern> fasta, the renaming steps sits between the parser and the typechecker
10:40:47 <vincenz> @type lookup
10:40:49 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
10:52:47 <vincenz> @hoogle swap
10:52:48 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
10:52:48 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
10:52:48 <lambdabot> System.Win32.Info.sM_SWAPBUTTON :: SMSetting
10:53:23 <vincenz> @pl \(a,b) -> (b,a)
10:53:23 <lambdabot> uncurry (flip (,))
10:53:50 * alar wonders what vincenz is making. Distributed solver?
10:54:04 <vincenz> heh
10:54:06 <vincenz> no
10:57:48 <vincenz> > sort . uniq $ [1,2,1,2]
10:57:49 <lambdabot>  Not in scope: `uniq'
11:25:05 * edwardk waves hello.
11:28:40 <musasabi> evening
11:28:52 <edwardk> holy crap, he's alive =)
11:29:11 <edwardk> you know i joined this channel like 4 weeks ago to ask you some question about PArrows that is now entirely irrelevant ;)
11:30:01 <musasabi> I was away quite a long time.
11:30:06 * edwardk noticed =)
11:30:14 <edwardk> well, welcome back
11:32:33 <edwardk> Ah, now i remember, some random page had mentioned your name in conjunction with finding problems with using arrows in practice. By now, I presume that the problem in question was that arr/pure has to be able to turn all functions into arrows and can't be used in contexts where you can only promote functions whose arguments are of certain type classes or where you have other constraints?
11:34:25 <musasabi> That and it makes impossible to know the structure of the plumbing inside arrows
11:34:33 * edwardk nods.
11:34:44 <edwardk> Ok, then we basically ran into the same problems. =)
11:35:45 <edwardk> I couldn't even work around it with -fno-implicit-prelude, because the desugaring presumes certain arrow properties anyways, even if you change the signatures.
11:36:06 <musasabi> i.e. pure fst and pure (const 1) can both look the same to code inspecting things
11:36:16 * edwardk nods.
11:37:10 <musasabi> It could be mostly worked around to make those pure usages so rare they don't matter. Except arrow syntax compiles to extensive use of them.
11:37:22 <edwardk> i'm currently using them as the target for a compiler to help mix pure, stm and io based functions, so i understand the introspection issues.
11:38:17 <edwardk> I mostly just want to be able to can the 'pure' arrows, extend the bulk of the sugar to work over the simpler morphism type that results, then subclass that to obtain hughes arrows.
11:38:23 <musasabi> I usually just stack a suitable monad and use various typing tricks to keep various preconditions working.
11:38:35 * edwardk nods.
11:39:17 <edwardk> the monad approach is where i started, and probably where i'll return. playing with the arrow approach in the meantime because it can cleanly expose parallelism opportunities
11:39:25 <musasabi> wrapping STM is easy and one can control on the type level which variables different functions may read or write
11:40:07 <edwardk> well, in my case its for ecma4 so its a little tricky to know all my types and sideeffects apriori
11:41:10 <musasabi> if you know suitable equivalence classes of them, then it should be enough
11:41:25 * edwardk nods.
11:42:07 <edwardk> in any event things are coming along nicely. mostly i've shelved arrows as a solution to a problem i don't have right now =)
11:42:35 <edwardk> my current arrow code could be converted to monads pretty readily
11:43:02 <edwardk> i ran into problems when i tried to see what the conceptual issues were with someones 'pipe' arrows.
11:43:09 <musasabi> ok :-)
11:48:28 <edwardk> What tripped me up at first is the name 'arrows' seems evocative of category theory's arrows. Once you accept that they are their own thing, or that they are only defined when the category in question includes all functions, they become a lot easier to stomach.
11:49:11 <musasabi> well it is more a problem with haskell than with arrows.
11:49:18 <edwardk> yeah
11:49:33 <edwardk> kind like haskell's strange functor.
11:49:49 <musasabi> things would work if functions were not opaque. Of course non-opaque functions would be problematic in other parts of the language.
11:49:58 * edwardk nods.
11:56:06 <LordBrain> Does ghc optimize any of its Non-IO data type structure modifications to use in place editing?
11:56:29 <LordBrain> for example, Data.Map
11:56:48 <LordBrain> or Array.. etc
11:57:09 <musasabi> no.
11:57:17 <musasabi> see DiffArray though
12:01:18 <psnl> would it be wrong to buy the haskell report on paper and get into microsoft research to get it signed?
12:01:44 <SamB> why would it be wrong?
12:02:19 <psnl> waste of money, more than anything else
12:02:39 <Lokadin> what is a simple form of standalone program to program communication?
12:02:45 <SamB> #haskell doesn't tell you what to do with your money
12:02:58 <SamB> standalone communication?
12:03:03 * psnl takes that as a vote of support
12:03:20 <Lokadin> SamB: i mean, if i have two standalone programs and i want them to communicate
12:03:27 <Lokadin> so say two servers or some such
12:03:39 * SamB does not think such programs would qualify as standalone anymore
12:03:59 * Lokadin is then confused as to the meaning of standalone
12:04:01 <SamB> am thinking that TCP/IP is a popular way
12:04:13 <SamB> nevermind about the meaning of standalone
12:04:18 <Lokadin> kk
12:04:23 <Lokadin> so is that sockets?
12:04:28 <SamB> yeah
12:04:35 <SamB> unix domain sockets may also be of interest
12:04:54 <SamB> I haven't a clue how you use that though
12:05:06 <Lokadin> i'm sure ordinary sockets would do
12:05:18 <Lokadin> hmmm
12:05:22 <SamB> both kinds are ordinary
12:05:44 <Lokadin> they aren't different?
12:05:51 <edwardk> hrmm. does anyone know of any sort of investigations into pure type systems extended with linear, relevent, etc types?
12:05:55 <SamB> well, I mean, unix domain sockets are less used but not really any more special, except for the fact that non-unix OSes don't tend to clone them
12:06:40 <Lokadin> well i'll try and use tcp/ip sockets then as they are available on non-unix oses
12:06:44 <Lokadin> right?
12:06:53 <edwardk> i can't seem to find much written on PTSs in the last few years.
12:08:14 <Lokadin> SamB: k, well i'll go and try implementing sockets then
12:08:22 <musasabi> Philippa might know
12:09:35 <edwardk> i'll ask her when i see her on next.
12:10:36 <Philippa_> I'm not aware, but I've not been looking in too much depth
12:10:46 <Philippa_> trying (badly) to do the ICFP contest single-handedly atm
12:10:52 * edwardk nods.
12:11:01 <Philippa_> think I'm finally in the process of clearing the first stage but my code takes an aggravating length of time to run
12:11:32 <edwardk> mostly just curious. coz i like the PTS stuff, and I like the various linear-friendly lambda calculi, and they both seem to be extending the same foundation in orthogonal directions.
12:11:35 <Philippa_> why oh why they couldn't have included a second output instruction for code dumps I don't know :-(
12:11:42 <edwardk> heh
12:12:12 <Philippa_> adding the instrumentation to redirect my VM's output is seriously slowing it down - had to use Control.Concurrent
12:12:14 <SamB> is there no opcode free for that use?
12:12:32 <Philippa_> yes, there's room for another two opcodes
12:12:39 <SamB> thats what I thought
12:13:00 <Philippa_> somehow, I think rewriting the codex to use an additional opcode would be painful though :-)
12:13:04 <SamB> I haven't finished the code to read a scroll ;-)
12:13:07 <SamB> oh
12:13:47 <Philippa_> the codex, once executed, eventually offers you a menu and the chance to dump out another load of code
12:13:54 <Philippa_> at this point, you want a second output channel
12:13:59 <SamB> ah
12:14:08 <Philippa_> which the UM doesn't have, of course
12:14:15 <Philippa_> like I said, the instrumentation's costing me :-(
12:14:30 <SamB> some kind of script might be good
12:14:38 * Philippa_ nods
12:15:25 <Philippa_> the next feature I actually code up'll be serialising the VM state
12:15:40 <Philippa_> once I have that, I can save from a slow, instrumented version and load into a nice fast one
12:17:39 <alar> menu?
12:18:09 <Philippa_> yeah, with all of two options :-)
12:18:19 <Philippa_> but it needs some interaction to start dumping
12:18:19 <edwardk> heh
12:19:11 <SamB> hmm, what is the difference between unpack and unpackList in Data.ByteString?
12:24:02 <SamB> well, that sounds like a nice job for a shell script or something like that
12:29:37 <SamB> > array (0,0) [1]
12:29:38 <lambdabot>  add an instance declaration for (Num (i, e))
12:29:39 <lambdabot>   In the list element: 1
12:29:48 <SamB> > array (0,0) [(0,1)]
12:29:49 <lambdabot>  array (0,0) [(0,1)]
12:30:12 <SamB> > let arr = array (0,0) [(0, bounds arr)] in arr
12:30:13 <lambdabot>  array (0,0) [(0,(0,0))]
12:30:28 <SamB> hmm
12:30:34 <SamB> @type let arr = array (0,0) [(0, bounds arr)] in arr
12:30:35 <lambdabot> forall i. (Num i, Ix i) => Array i (i, i)
12:30:49 * SamB wonders if that works on unboxed arrays
12:37:50 <SamB> why does it look like the UM is supposed to be implemented in C on a 32-bit architecture?
12:41:57 <SamB> hmm, probably that is just me
12:42:56 <SamB> @hoogle thaw
12:42:56 <lambdabot> Data.Array.MArray.thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
12:42:57 <lambdabot> Data.Array.MArray.unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
12:43:33 <SamB> @hoogle bounds
12:43:34 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
12:43:34 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
12:43:34 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
12:48:06 <hellish> is there a generic form of toEnum?
12:48:44 <Lemmih> (Num a, Enum e) => a -> e?
12:49:53 <hellish> Yes, that. Actually, I need the opposite. Generic of fromEnum.
12:49:55 <SamB> Lemmih: that wouldn't work
12:50:12 <SamB> @type fromEnum
12:50:13 <lambdabot> forall a. (Enum a) => a -> Int
12:50:22 <Lemmih> SamB: I know.
12:50:24 <kpreid> @type fromIntegral . fromEnum
12:50:25 <lambdabot> forall b a. (Num b, Enum a) => a -> b
12:50:34 <SamB> Lemmih: it'd have to be Integral for that one
12:50:53 <kpreid> hellish: that should do
12:53:30 <hellish> appears to work. Cool.
12:57:55 <SamB> hmm, my code is too slow
12:58:48 * xerox profuses donsness upon SamB
12:59:20 <SamB> how would you read a file of big-endian 32-bit words?
12:59:31 <xerox> bytestrings!
12:59:42 <SamB> what kind?
12:59:57 <xerox> I think you can copy the code from some dons' code
12:59:57 <SamB> and how would you convert it to the proper array type?
13:00:09 <xerox> Hey I'm not dons.
13:00:18 <mathewm> I used CChar
13:00:19 <SamB> are ICFP entries allowed to steal dons' code?
13:00:21 <stepcut> SamB: You might want to look at the Streams library
13:00:21 <xerox> darcs-graph is quite simple I think
13:00:37 <SamB> mathewm: CChar?
13:00:50 <xerox> Let me find it.
13:00:51 <mathewm> of course, I am still having trouble with my decryption key after 3 hours... :(
13:00:59 <mathewm> cannot find my bug
13:01:24 <xerox> http://www.cse.unsw.edu.au/~dons/code/darcs-graph/Graph.hs
13:01:33 <xerox> `readDir' is a good example %)
13:01:37 <SamB> hmm
13:02:54 <SamB> ack that is ugly
13:03:18 <SamB> it looks like C without the C or something
13:04:29 <SamB> hmm, shouldn't C.copyCString be strict already?
13:06:35 <SamB> @hoogle GHC.Prim.ByteArray# -> Data.Array.Unboxed.UArray a
13:06:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> -> Data.'
13:06:56 <SamB> hmm
13:13:30 <liyang> ls
13:13:33 <liyang> ack
13:27:31 <SamB> @hoogle unsafePerformIO
13:27:31 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
13:28:57 * xerox tickles SamB 
13:29:01 <SamB> hmm
13:29:43 <SamB> I wonder how long it should take to read the codex on a PII 450 MHz
13:30:32 <xerox> Do you know what the codex is?
13:31:02 <SamB> it is a legacy 8-bit scroll representing a 32-bit array in big-endian fashion
13:31:28 <xerox> Do you know what the Cult have brought you under that form? %)
13:31:35 <SamB> not yet
13:31:56 <SamB> I've been trying to get it to load in a decent amount of time
13:31:57 <xerox> (!)
13:32:15 <Korollary> how big a file is it?
13:32:42 <SamB> oh, 2.3M
13:32:47 <SamB> whatever M means
13:34:13 <Philippa_> I'm just discovering that I can't profile my code because it crashes if I compile it with profiling on. Woohoo.
13:34:35 <xerox> :(
13:34:39 <SamB> I don't think I've enough space to install profiling libraries
13:35:27 * xerox takes nots for next year's icfpc
13:35:37 <Philippa_> I'm only using the stuff that comes with GHC anyway
13:35:50 <Philippa_> but yeah, it's biting me. And I swear I should be able to run faster than 1:1000
13:35:55 <SamB> those are the profiling libraries I meant
13:36:01 <Philippa_> especially when there's bugger all allocation happening
13:40:19 <SamB> >>> readscroll.readscroll("../codex.umz")
13:40:19 <SamB> array([3489660936, 3221225520,  335544530, ...,   50958976, 1920103779,
13:40:19 <SamB>        1937010277], type=UInt32)
13:40:24 <SamB> that is in Python...
13:40:33 <SamB> it seems nice and speedy...
13:40:53 <SamB> well, the heavy lifting is in C...
13:42:00 <Philippa_> how fast is "nice and speedy", exactly? How long from inputting the decryption code to getting an okay with the codex, for example?
13:44:00 <SamB> er, I meant its faster than my code to just read the file as an array of platters
13:45:33 <yip> what do you guys think of the idea of compiling haskell programs to javascript?
13:46:09 <mux> I think that would be incredibly insane
13:46:38 <Philippa_> it'd certainly have its uses if you could do it efficiently enough
13:48:23 <mux> what use? IOJCC?
13:48:30 <xerox> yip: edwardk
13:51:51 <Philippa_> mux: same uses javascript has, only with a nicer language
13:52:14 <mux> uh? the only use I see for javascript are web things using the DOM API
13:52:28 <mux> in which case providing DOM bindings to Haskell is much more sane
13:54:30 <Philippa_> not when Haskell doesn't run on the client side
13:54:55 <Philippa_> not when you'd have to get Haskell into all the major browsers for it to work
13:56:35 <mux> you mean writing haskell code, converting it to js and then putting this in the web page? that's the only way to not impact the client
13:56:41 <mux> and it sounds terribly useless
13:56:45 <mux> but whatever.
13:57:15 <edwinb> I don't see why it's useless. I'd rather do that than write javascript
13:57:30 <edwinb> It's similar to what the Links guys are doing.
14:02:13 <stepcut> yip: I have done some work trying to compile scheme to flash (aka, .swf)
14:02:23 <yip> interesting
14:03:24 <stepcut> yip: Scheme is a good way to start, because scheme has only 7 core instructions (or something like that). Once you have those implemented, the rest of scheme can just be written in scheme
14:04:40 <stepcut> yip: oh! hold on
14:05:51 <stepcut> yip: Someone wrote a program that turned java byte-code into XML, and then wrote an XSLT transformer that turned the java byte code into javascript
14:06:02 <stepcut> yip: you could probably do the same with yhc byte-code
14:07:22 * stepcut looks for the link
14:07:36 <vincenz> @type groupBy
14:07:37 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
14:07:41 <vincenz> @type sortBy
14:07:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:08:01 <vincenz> > groupBy (==) [1,2,3,1,2,3]
14:08:02 <lambdabot>  [[1],[2],[3],[1],[2],[3]]
14:08:21 <xerox> vincenz: you gotta sort
14:09:21 <xerox> stepcut: you could in principle do that with yaml too?
14:10:46 <stepcut> xerox: probably -- though I just use the YHC libraries, and do it all in haskell myself ;)
14:11:23 <xerox> :)
14:12:29 <stepcut> hrm, I can't find the link
14:12:56 <bolrod> > groupBy ((==).(/=)) [1..10]
14:12:56 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> Bool
14:12:57 <lambdabot>    Ex...
14:13:01 <bolrod> :O
14:13:03 <stepcut> anyway, a yhc byte-code to javascript converter sonuds like it might be feasible
14:13:14 <stepcut> javascript supports anonymous functions
14:13:44 <bolrod> > groupBy (\x y-> (x==y)||(x/=y)) [1..10]
14:13:45 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10]]
14:14:28 <vincenz> YAY
14:16:20 <xerox> stepcut: yes indeed, maybe you could mention this on the list
14:16:40 <stepcut> heh
14:16:49 <stepcut> It does sound like a fun project
14:17:50 <stepcut> Unfortunately, I am already working on one crazy haskell project -- probably shouldn't double-up write now ;)
14:18:02 <Korollary> not write now.
14:18:18 <stepcut> yikes.
14:19:09 <stepcut> I was originally going to say 'I am already writing...'. It appears the word got stuck in my head :)
14:19:11 <xerox> stepcut: what project? :D
14:19:37 <stepcut> xerox: real-time virtual synth :)
14:20:20 <kpreid> @pl (\x y-> (x==y)||(x/=y))
14:20:21 <lambdabot> ap (ap . ((||) .) . (==)) (/=)
14:20:28 <xerox> oh, another guy mentioned me something like that stepcut  :D
14:20:40 <xerox> here on haskell, i mean
14:20:59 <stepcut> xerox: recently ?
14:21:13 <xerox> yes
14:21:19 <stepcut> cool
14:24:47 <vincenz> we're 3rd \o/
14:26:12 <stepcut> vincenz: cool!
14:27:19 <xerox> great
14:30:05 <shemale_magic> heh
14:30:17 <shemale_magic> how can haskell automate ftp?
14:41:28 <Korollary> check out MissingH.Network.FTP.Client
14:55:12 <Philippa_> shemale_magic: you were asked not to use that nick last time and agreed to change it. It might be an idea to stick to that agreement?
15:02:28 --- mode: ChanServ set +o vincenz
15:02:45 <vincenz> shemale_magic: please change your nick
15:04:17 <vincenz> ...
15:04:34 * vincenz kick shemale_magic When you notice you're kicked I'm sure you will have time to change your nick and return properly :_
15:04:40 --- kick: shemale_magic was kicked by vincenz (When you notice you're kicked I'm sure you will have time to change your nick and return properly :_)
15:04:50 <norpan> what's the problem with the nick
15:05:07 <vincenz> it's offensive to some
15:05:10 --- mode: vincenz set -o vincenz
15:05:18 <vincenz> besides this is a haskell channel, not a sex channel
15:05:21 <Philippa_> you mean aside from the term "shemale" being rather offensive and only really used by people who don't know better and the sex industry?
15:05:50 <norpan> i don't know what it means so i'm not offended
15:06:03 <Philippa_> it's a nasty term for a pre-op trans woman
15:06:09 <norpan> so, do you take offense
15:07:18 <Philippa_> yep. In its own little way it's actually nastier than someone with "nigger" in their nick - and when I asked it's because they're a porn fan, so it's not like it's someone taking the label to describe themselves either
15:08:16 <dgoldsmith> agreed
15:08:34 <norpan> i see no reason to be offended
15:08:42 <norpan> it's not like i'm a shemale
15:08:42 <vincenz> norpan: well then it's great to be you :)
15:08:47 <Philippa_> lucky you, then
15:09:56 <norpan> it is
15:10:43 <norpan> i hope my nick doesn't mean anything that can offend anybody
15:10:54 <dons> vincenz: how goes?
15:11:29 <xerox> heya dons
15:11:34 <vincenz> dons: gerat !!
15:11:37 <vincenz> dons: we're 3rd
15:11:37 <HeyObjects> ok
15:11:38 <vincenz> dons: you guys?
15:11:43 <dons> vincenz: great stuff.
15:11:49 <HeyObjects> how do we automate ftp file transfers with haskell?
15:11:49 <dons> we're on the first page now, which is good.
15:11:52 <dons> about 20th?
15:11:52 <vincenz> dons: what team are you?
15:11:58 <dons> deaus-ex-machina
15:12:02 <vincenz> dcouts = dunkoo...?
15:12:04 <xerox> ?where haskellnet
15:12:05 <lambdabot> I know nothing about haskellnet.
15:12:09 <dons> vincenz: yep
15:12:11 <vincenz> :)
15:12:14 <vincenz> We are Lazy Bottoms
15:12:23 <dons> I know. go lazy bottoms!
15:12:24 <xerox> dons - doing some evil bytestringery? (:
15:12:26 <Philippa_> norpan: if you didn't base your nick on a habit of objectifying an entire minority, you're probably okay
15:12:38 <dons> xerox, no actually. well, only a little ;)
15:12:39 <vincenz> \o/
15:12:51 <vincenz> dons: heh last night I spent the time hacking to get that nice 327
15:12:55 <vincenz> until finally someone got a 328
15:12:57 * vincenz mutters
15:12:57 * yip at first thought that you guys had a problem with the "magic" part :P
15:13:25 <Philippa_> if I knew ByteString well enough to use it for the IO I'd do so, but it's not the most horrendous cost even if I do blow a lot of heap doing the initial loading
15:13:42 <xerox> HeyObjects: HaskellNet has code to do ftp, at least, it should have or will in a short timespan :)
15:13:45 <Philippa_> yip: I think I was pretty clear about it the last time it came up
15:13:48 <yip> racism and discrimination against wizards must be dealt with :P
15:14:03 <xerox> yip: haha
15:14:10 <Philippa_> this time round it was more a case of "Oi! You're going back on what you agreed on, sort it out"
15:14:10 <yip> Philippa_: ok, i wasn't hear last time... hopefully things are solved now...
15:14:13 <norpan> severely
15:15:36 <Philippa_> norpan: I don't think this was particularly severe given that the person in question was asked to change nick or leave last time this came up, changed then and has come back with the same nick
15:16:43 <norpan> i meant that discrimination against us wizards must be dealt with severely
15:17:09 <wilx> lol, what's wrong with shemale_magic nick?
15:17:20 <greenrd> wilx: scroll up
15:18:00 <wilx> Would I be kicked if I named myself "gay"?
15:18:09 <Philippa_> probably not
15:18:27 <Philippa_> big difference: "gay" isn't a term primarily used by people exploiting a minority in a particularly unpleasant way
15:19:12 <Philippa_> whereas "shemale" is primarily used by the sex industry, which many trans women're forced to work in one way or another - in most countries there's no employment discrimination legislation, and in several that do have it it's still often the only way to afford surgery
15:19:42 <Philippa_> in short, one term's offensive and the other isn't
15:20:19 <dons> vincenz: funny, everyone on my team immediately asked to use bytestrings too :)
15:20:28 <yip> the only problem i have with that nick is that it's longer then the polite "10 letter limit"
15:20:42 <norpan> which of you guys are from the us?
15:20:45 <wilx> Ok.
15:20:49 <wilx> I stand corrected.
15:20:51 <norpan> and i mean guys as in all sexes
15:20:55 <Philippa_> UK here
15:20:56 <wilx> I read the wikipedia definition.
15:21:04 <wilx> I thought it was normal term.
15:21:17 <Philippa_> it's "normal" the same way "nigger" once was
15:21:57 <greenrd> wilx: "bitch" is used on a lot of porn sites, does that make it ok to call women bitches?
15:22:14 <Philippa_> not your fault - most people only see the sex industry output and the odd shock newspaper story
15:22:27 <astrolabe> greeerd: he said he stands corrected
15:22:31 <yip> does this mean that we should ban the use of BitchX in here? ;)
15:22:40 <norpan> bitch is a dog, right?
15:23:27 <greenrd> astrolabe: I was just generalising.
15:24:00 <xerox> We are in #haskell for a reason.
15:24:06 <Philippa_> norpan: that, and a social role associated with the way dogs structure their packs - hence the prison sex usage
15:24:11 <norpan> yes, to generalize :)
15:24:18 <xerox> =)
15:28:49 * xerox tunes some GOA
15:29:59 <vincenz> @type groupBy
15:30:00 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:33:01 <astrolabe> Today I went to Oxford, and amongst other books bought "Types and Programming Languages" by Benjamin C. Pierce.  Does anyone know if it's a good book?
15:33:43 <edwardk> what would be a good terse haskell equivalent to the ocaml: let rec f = [f];; ?
15:33:45 <xerox> You as afterwards? %)
15:33:58 <xerox> edwardk: what does it do?
15:34:10 <kpreid> edwardk: not possible, because it has an infinite type
15:34:15 <edwardk> makes a recursively infinite list [[[[[[[[[[[[[[[[...]]]]]]]]]]]]]]]]
15:34:16 <xerox> astrolabe: I meant "You ask afterwards?" :)
15:34:24 <edwardk> kpreid: heh was afraid of that =)
15:34:29 <xerox> edwardk: ah! Well...
15:34:32 <norpan> how can you do it in ocaml?
15:34:36 <kpreid> edwardk: ...why do you want to?
15:34:39 <norpan> isn't that statically typed too?
15:34:59 <edwardk> to shut up a glib ocaml'er? =)
15:35:14 <Philippa_> astrolabe: it's an excellent book
15:35:24 <astrolabe> xerox: Afraid so.  Ithought the name rang a bell.
15:35:29 <astrolabe> Philippa_: Thanks!
15:35:30 <xerox> :D
15:35:34 <xerox> edwardk: let me try.
15:35:35 <Philippa_> the sequel's also good
15:35:50 <kpreid> edwardk: if you use a data type which is not parameterized in that way on the element type you can do that
15:36:15 <stepcut> # let rec f = [f];;
15:36:15 <stepcut> This expression has type 'a list but is here used with type 'a
15:36:41 <kpreid> for example, data List a = Empty | Cons (List a) (List a) | Value a
15:36:51 <kpreid> (which is more like a tree, but let's ignore that :))
15:37:41 <edwardk> you have to use -rectypes for that to work in ocaml
15:40:25 <edwardk> kpreid: was mostly looking to see if there was a nice concise version i was overlooking.
15:41:48 <kpreid> edwardk: with the standard list type, no
15:50:13 <DukeDave> can anyone give a suggestion why I am recieving "Instance of Ord (Int -> Int) required for definition"
15:50:57 <norpan> DukeDave: you are missing an argument to a function
15:50:58 <edwardk> probably passing the wrong number of parameters to a function
15:52:22 <DukeDave> cheers, shall investigate
15:53:38 <lisppaste2> dukedave pasted "Instance of Ord error" at http://paste.lisp.org/display/23007
15:54:09 <HeyObjects> ?
15:54:27 <HeyObjects> my yahoo essenger stopped working
15:54:30 <HeyObjects> what a bummer
15:54:33 <HeyObjects> reinstalled
15:54:46 <HeyObjects> yahoo puts lots fo fun crap on your pc even when u deselect all
15:55:08 <norpan> DukeDave: you need to pass two arguments to "dist"
15:55:09 <xerox> I've done it edwardk :-)
15:55:40 <hellish> What's the difference between Data.ByteString.unpack and Data.ByteString.unpackList?
15:55:40 <DukeDave> well spotted!
15:55:54 <norpan> DukeDave: well, Ord has to do with <
15:55:59 <SamB> hellish: I asked that earlier
15:56:01 <DukeDave> thank you - I'm a little confused why hugs reports an error on line 2
15:56:18 <norpan> because the definition starts there
15:56:24 <norpan> ghc has better errors for these
15:56:25 <DukeDave> with you
15:56:33 <SamB> are we talking about scroll reading?
15:56:34 <SamB> I'
15:56:36 <SamB> er,
15:56:36 <DukeDave> I'd never noticed that
15:56:42 <SamB> I'm trying to write it in C
15:56:45 <DukeDave> thanks again
15:56:56 <SamB> hellish: nobody answered
15:57:21 <SamB> or at least, I didn't see any answer...
15:57:28 * xerox pokes edwardk and kpreid 
15:57:34 <hellish> SamB: dons is in a cave working on his icfp entry. He would know.
15:57:43 <SamB> the cheater!
15:58:10 <kpreid> ?
15:58:14 <SamB> spending all his time on HIS entry!
15:58:22 <SamB> instead of everyone elses!
15:58:35 <xerox> *FixList> :t (fixlist 1 :: W Int, fixlist 1 :: [W Int], fixlist 1 :: [[[[[W Int]]]]])
15:58:39 <xerox> (fixlist 1 :: W Int, fixlist 1 :: [W Int], fixlist 1 :: [[[[[W Int]]]]]) :: (W Int, [W Int], [[[[[W Int]]]]])
15:58:41 <hellish> SamB: your program doesn't happen to segfault for no apparent reason does it?
15:58:46 * xerox grins
15:58:48 <SamB> hellish: not yet
15:58:59 <hellish> aww.
15:59:04 <xerox> Do you believe, eh, infidels? ;-)
15:59:39 <SamB> but I'm trying to write some loading code in C
15:59:46 <SamB> so that will most likely change soon
16:00:02 * kpreid attempts to figure out what xerox is doing
16:00:37 <xerox> kpreid: arbitrary-nested list
16:00:39 <edwardk> xerox: ?
16:00:43 <mathewm> ?hoogle [a] -> Int -> a -> [a]
16:00:44 <lambdabot> No matches, try a more general search
16:00:48 <edwardk> xerox: took its fixed point?
16:00:58 <kpreid> xerox: nice typeclass, but how exactly is that an infinitely recursive list?
16:00:58 <Philippa_> I'm pretty sure there's a subtle error in my code, but I can't find it - which is more than a little aggravating
16:00:59 <mathewm> ?hoogle Int -> [a] -> a -> [a]
16:01:00 <lambdabot> No matches, try a more general search
16:01:05 <kpreid> hm
16:01:28 <mathewm> is there no Prelude function to copy an array replacing just one indicated element with a given value?
16:01:29 <Philippa_> my UM runs at about 1MHz on my machine, FWIW - whereas judging by the timescale given on the site I should be getting more like 10MHz
16:01:47 <xerox> kpreid: it is as finite as you want?
16:02:03 <norpan> mathewm: a list or an array?
16:02:07 <xerox> edwardk: i was thinking of something like that now, yes
16:02:21 <mathewm> list
16:02:22 <edwardk> mathewm what about // ?
16:02:32 <edwardk> ah well, thats different =)
16:02:48 <norpan> mathewm: i wouldn't think so
16:03:05 <mathewm> I don't know how to use arrays yets...
16:03:15 <norpan> normally you don't use lists that way
16:03:41 <xerox> kpreid: do you think its not doable?
16:04:00 <kpreid> xerox: the original problem, no, by definition
16:04:03 <vincenz> @type mapM
16:04:05 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
16:04:10 <xerox> May you explain me why?
16:04:29 <kpreid> because as far as I know there is not even an extension for infinite types
16:04:47 <kpreid> and [[[[[[[[[[[[[[[... has an infinite type
16:05:00 <kpreid> @type fix head
16:05:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:05:02 <lambdabot>    Expected type: [a] -> [a]
16:05:12 <xerox> You can do explicit recursion maybe
16:05:42 <xerox> But in the end GHC will not tell you "infinite type" I see
16:07:14 <xerox> kpreid: bue in principle this is constructively correct right?
16:08:04 <kpreid> if "this" is your typeclass thing above, I believe it's no more or less correct than "let x = [x] in x"
16:08:13 <kpreid> but I'm no Haskell expert
16:08:38 <Philippa_> you shouldn't be able to build an 'infinite type-level list' in GHC
16:08:42 <Philippa_> the type system's not lazy
16:09:08 <xerox> :(
16:09:18 <Philippa_> furthermore, lazy type systems don't work
16:09:25 <xerox> Oh well
16:09:31 <norpan> a lazy type system would be akin to dynamic types, right?
16:09:49 <xerox> When would the compiler unify types?
16:10:02 <SamB> the compiler couldn't unify types...
16:10:37 <xerox> Goodnight chaps
16:11:47 <vincenz> @type map mapM
16:11:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a -> m b] -> [[a] -> m [b]]
16:12:05 <vincenz> @type \f map (mapM f)
16:12:06 <lambdabot> parse error (possibly incorrect indentation)
16:12:11 <vincenz> @type \f -> map (mapM f)
16:12:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [[a]] -> [m [b]]
16:12:24 <mathewm> ?hoogle [a] -> Array Int a
16:12:25 <lambdabot> No matches, try a more general search
16:12:37 <HeyObjects> how is smalltalk different from haskell?
16:12:53 <norpan> more like how is it similar to it :)
16:13:00 <edwardk> matthewm:
16:13:04 <edwardk> ?hoogle listArray
16:13:05 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
16:13:05 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
16:13:05 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
16:14:45 <vincenz> @type all
16:14:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:14:49 <vincenz> @type and
16:14:51 <lambdabot> [Bool] -> Bool
16:15:17 <xerox> vincenz: run a lambdabot on your pc :)
16:15:36 <edwardk> xerox: no need you can just /msg lambdabot and it'll respond too
16:16:14 <xerox> well he's hacking hard
16:16:21 <edwardk> lambdabot is right on my 'buddy list' =-)
16:16:24 <HeyObjects> ok what kinds of apps are done in haskell so far?
16:16:32 <HeyObjects> the power is shown by applications eh?
16:16:40 <norpan> HeyObjects: all kinds of apps
16:16:44 <HeyObjects> is there a web browser or database or webserver or something done in haskell?
16:16:52 <edwardk> hey: darcs, pugs, lots of haskell compilers
16:16:56 <HeyObjects> how about a rules enigne? monitoring ssytem? or scheduler?
16:17:23 <edwardk> hey: i'm working on a javscript compiler, so there is one step towards a web browser i guess ;)
16:18:04 <SamB> haha
16:18:05 <Philippa_> there's something that looks a bit like a rules engine in a lot of programs. I've written concurrent code that looks a bit like a monitoring system, though I wouldn't want to call it realtime
16:18:06 <SamB> compiler?
16:18:17 <edwardk> samb: well, yes =)
16:18:36 <xerox> Goodnight for real!
16:18:38 <SamB> that is not traditionally the way webbrowsers do JS, is it?
16:18:43 <edwardk> samb: ecma4 has templates, strong typing, type and data statements in the language
16:18:50 <SamB> wow
16:19:03 <edwardk> samb: thats why i brought out the big guns for the implementation =)
16:19:05 <SamB> and this is supposed to be supported in web browsers?
16:19:12 <SamB> they is almost crazy
16:19:14 <edwardk> samb: yeah, funny eh? =)
16:19:30 <SamB> almost
16:19:32 <edwardk> samb: they can do it without most of the tyupe checking if they have to, and run in 'standard'  mode
16:20:02 <edwardk> if its in an environment where precompilation is possible 'strict' mode lets you catch most type error stuff at compile time
16:20:15 <SamB> I think "strict" mode should be standard
16:20:16 <edwardk> i.e. adobe/macromedia actionscript 3
16:20:31 <edwardk> well, the terms come from actionscript's usage of them
16:20:37 <edwardk> and i agree
16:20:55 <SamB> well, I'm more worried about web browsers ;-)
16:20:57 <edwardk> my implementation is a strict mode compiler, that can generate standard mode if it has too
16:21:34 <edwardk> and i'll probably extend my ecmascript 3-in-ecmascript 3 implementation to run ecmascript 4-in-ecmascript 3.
16:21:42 <SamB> oh, my C code for reading scrolls would likely work better if I seeked back to the beginning before reading...
16:21:45 <edwardk> that way i can write with classes and templates, et.
16:22:03 <edwardk> and still run in old browsers.
16:22:05 * vincenz grins at dcoutts 
16:22:45 <edwardk> currently i'm playing with compiling javascript packages down to haskell modules and loading them with hsplugins.
16:23:14 <HeyObjects> so there is no database, monitoring system, web browser, webserver, or scheduling ssytem in haskell
16:23:17 <hellish> SamB: Why'd you decide to write the scrollreader in C? Are you still bringing the data into haskell to run the UM?
16:23:24 <HeyObjects> what Is writen in haskell that gets work done?
16:23:27 <edwardk> in the absence of eval this should generate good code efficiency, in the presence of eval its a little hairier.
16:23:35 <SamB> hellish: my scroll reader is not fast enough
16:23:57 <hellish> SamB: Aah. How slow is "not fast enough"?
16:23:59 <edwardk> hey: there is a nice 'haskell server pages' implementation and it has database connectivity
16:24:22 <SamB> well... I dunno. it might have been under 30 seconds, but seemed like forever...
16:24:57 <edwardk> hey: software transactional memory lets apps written in haskell scale better to multiprocessors than traditional lock-based concurrency
16:25:26 <hellish> SamB: What'd you use? Fast packed strings?
16:25:27 <edwardk> hey: and pugs (the only real working implementation of perl 6) is pretty non-trivial and written in haskell.
16:25:59 <SamB> hellish: I started with those yeah
16:26:16 <SamB> er, only they are now Data.ByteString
16:27:05 <dcoutts> vincenz?
16:27:21 <vincenz> dcoutts: progressing :)
16:27:26 <dcoutts> aye aye
16:27:35 <vincenz> it's gonna be a battle, aye?
16:27:38 <dons> good work guys :)
16:27:42 <dcoutts> so who's the Lazy Bottoms? is that your team?
16:27:44 <vincenz> yeah
16:27:48 <HeyObjects> why would u write a interpreter for perl in haskell?
16:27:53 <dcoutts> ah, thought so :-)
16:27:56 <dons> HeyObjects: a _compiler_ ;)
16:28:06 <HeyObjects> hm
16:28:13 <dcoutts> HeyObjects, do you notice one written in any other language?
16:28:17 <HeyObjects> still the oint of haskell etc is taht its higher level
16:28:19 <dcoutts> it's a hard spec to implement
16:28:22 <HeyObjects> but where does ti get work done?
16:28:26 <HeyObjects> whera re the end user apps?
16:28:29 <dcoutts> hence you need good tools
16:28:49 <HeyObjects> but what have you got with it?
16:28:53 <HeyObjects> what work can u get done?
16:29:13 <dcoutts> vincenz, what lang did you write your sim in?
16:29:27 <dons> dcoutts: are you implying you didn't use haskell?
16:29:31 <vincenz> dcoutts: c
16:29:33 <Philippa_> HeyObjects: why does the end-user care?
16:29:37 <dons> vincenz: !
16:29:42 <dcoutts> dons, vincenz: we used both :-)
16:29:57 <vincenz> C for sim, manual coding for some problems, haskell tools or others
16:29:58 <vincenz> for others
16:29:59 <vincenz> :)
16:30:02 <Philippa_> dons: getting the UM going fast in Haskell's beyond me, certainly. I can only get it to about 1MHz - if you're faster I'd be interested to know how?
16:30:03 <dcoutts> one worked sooner than the other and one worked quicker than the other
16:30:09 <vincenz> for instance I coded advise by hand
16:30:17 <dcoutts> no prizes for guess ing which way round
16:30:21 <dons> heh
16:30:44 <dons> just haskell this end.
16:31:06 <dcoutts> vincenz, aye, me too, but I can't do the second half to work very well, I'm missing some trick.
16:31:43 <dcoutts> dons, what's your team name?
16:31:53 <dons> deaus-ex-machina
16:32:28 <vincenz> dcoutts: ah I see :)
16:32:33 <vincenz> dcoutts: I'll tell you after its done :
16:32:34 <vincenz> :)
16:33:06 <Philippa_> dons: how fast's your UM actually going? I'd be interested to take a look at your code after the deadline
16:33:07 <dcoutts> vincenz, heh :-)
16:33:39 <dcoutts> dons, I'm going to have to rewrite our UM too after the deadline to make it as fast as the C version. :-)
16:33:40 <vincenz> dcoutts: I was proud of my long time hold on 1st place in that field
16:33:41 <dons> Philippa_: well, seems fast enough. don't have a Ghz value (hehe)
16:33:45 <vincenz> dcoutts: until someone nipped off a point
16:33:50 <vincenz> dcoutts: but I plan to get back at em
16:34:04 <dcoutts> vincenz, not sure it's worth it for one point ;-)
16:34:08 <Philippa_> dons: if it's a handful of seconds to get to "ok" on the codex you're doing a hell of a lot quicker than mine
16:34:16 <vincenz> dcoutts: well you have to maximize ALL scores!
16:34:16 <dcoutts> vincenz, go for the ray tracer!
16:34:24 <vincenz> dcoutts: that's what I'm just starting on
16:34:35 <vincenz> I have a hunch
16:34:56 * vincenz gets out a paper block
16:36:55 <dcoutts> dons, hope you see you having passed us by the time my team gets back in the morning. :-) you just need that 1000 jump and you're in the top few.
16:37:03 * dcoutts -> home -> bed.
16:37:31 <dons> dcoutts: yep, hope so
16:37:42 <dons> we're 8 hours down, so we have to plan to catch up while everyone else sleeps
16:38:08 * Philippa_ curses loudly
16:38:15 <Philippa_> this is what I get for working on windows
16:38:20 <Philippa_> should've set binary mode on stdout...
17:04:58 <SamB> okay so how do I turn a Ptr Word32 and its length into an array...
17:05:34 <stepcut> SamB: in 6.6 there is an unsafeForeignPtrToStorableArray
17:05:41 <SamB> hmm
17:05:47 <stepcut> you might be able to backport it pretty quickly
17:06:01 <SamB> @google unsafeForeignPtrToStorableArray
17:06:03 <lambdabot> http://www.haskell.org/HOpenGL/newAPI/base/Data-Array-Storable.html
17:10:11 <u221e> Are there something like shared libraries in Haskell?
17:11:41 <SamB> u221e: hs-plugins, yes
17:11:58 <SamB> but I think it only works in GHC right now
17:12:22 <SamB> er, those are like shared libraries in that you can load them dynamically
17:12:34 <u221e> That what I meant ;)
17:12:40 <SamB> good ;-)
17:13:09 <u221e> They are compiled I assume?
17:13:13 <SamB> yes
17:13:25 <SamB> but I think hs-plugins supports compiling for you
17:13:31 <SamB> not positive
17:13:47 <notsmack> is this an ok place to ask a HaXml question?
17:13:56 <SamB> it uses the same linker as GHCi
17:14:00 <u221e> SamB, how do I uninstall packages?
17:14:05 <SamB> notsmack: sure
17:14:12 <SamB> u221e: well, I'm not quite sure
17:14:25 <SamB> Is it cabalized?
17:14:28 <u221e> Yes
17:14:38 <notsmack> i'm pretty new to haskell, but am trying to use HaXml on gentoo
17:14:46 <SamB> well, try Setup.hs --help
17:14:55 <SamB> or whatever command
17:15:01 <notsmack> so i use Dtd2Haskell, and it generates a module
17:15:34 <notsmack> then i import that from a script, and try to write out a file, and i get: During interactive linking, GHCi couldn't find the following symbol:
17:15:34 <notsmack>   TextziXMLziHaXmlziTypes_Elem_con_info or TextziXMLziHaXmlziTypes_Elem_static_info
17:16:15 <u221e> I'm surprised there is no function like fprint in the Text.Printf module... seems useful.
17:16:24 <SamB> u221e: isn't there?
17:16:26 <u221e> fprintf
17:16:47 <SamB> @hoogle printf
17:16:48 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
17:16:48 <lambdabot> Text.Printf :: module
17:16:48 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
17:16:55 <vincenz> woot
17:16:57 <u221e> Like printf but it would also take a function to perform on the string instead of putStr
17:17:00 <vincenz> dcoutts: we might have a solution for the raytrace
17:17:10 <SamB> u221e: try this
17:17:17 <dcoutts> vincenz, well done, we're working on it too
17:17:30 <vincenz> it's nutty :)
17:17:31 <SamB> > printf "Hello, %s!" "World" :: String
17:17:32 <lambdabot>  "Hello, World!"
17:17:40 <dcoutts> notsmack, you might like to report a bug in the gentoo bugzilla
17:17:43 <u221e> Sam, that's not what I want.
17:17:59 <SamB> u221e: you just need to demand a String rather than an IO () if you want the string rather than the IO
17:17:59 <u221e> That would print the string to the screen, not what I want.
17:18:12 <SamB> recall that lambdabot doesn't allow IO
17:18:17 <notsmack> dcoutts: yeah, will do
17:18:52 <dcoutts> notsmack, if you do, please include exaclty what version of haxml and what commands we can use to reporduce the issue. Cheers.
17:18:53 <SamB> u221e: observe the quotation marks in the output
17:19:27 <u221e> SamB, I want to make a function like MyPrint that would take var args like printf and do something to the string inside MyPrint
17:19:29 <dcoutts> notsmack, I'll not be able to help til tuesday due to being busy with this ICFP competition
17:19:49 <SamB> u221e: try this
17:20:20 <dcoutts> notsmack, it's also worth asking in #gentoo-haskell. Other gentoo devs might be able to fix it.
17:20:26 <SamB> u221e: er, I dunno if you can quite do that
17:20:33 <u221e> Since printf relies on point-free programming I am not able to both pass MyPrint's args to printf AND do something on the resulting String.
17:20:33 <SamB> because of the PrintfType magic
17:20:38 <SamB> @type printf
17:20:40 <lambdabot> forall r. (PrintfType r) => String -> r
17:20:55 <SamB> @intances-importing PrintfType Text.Printf
17:20:56 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
17:21:04 <u221e> SamB, my idea is to rewrite prinf to also take a function.
17:21:06 <SamB> @intances-importing Text.Printf PrintfType
17:21:07 <lambdabot> (a -> r), IO a, [c]
17:21:19 <notsmack> dcoutts: ah, didn't know about #gentoo-haskell, thanks
17:21:40 <SamB> u221e: believe it or not, PrintfType instances exist for IO a and String
17:22:17 <u221e> fprintf putStr "Hello %s\n" "World" would print to formated string to the screen for instance
17:22:32 <SamB> u221e: you don't need it
17:22:43 <kpreid> > (printf "hello %s" "world") >>= return
17:22:44 <lambdabot>  add an instance declaration for (Show (m a))
17:22:56 <kpreid> > (printf "hello %s" "world") >>= return :: [a]
17:22:57 <lambdabot>  add (IsChar a) to the expected type of an expression
17:23:05 <kpreid> > (printf "hello %s" "world") >>= return :: [String]
17:23:06 <lambdabot>  add an instance declaration for (IsChar [Char])
17:23:09 <SamB> > putStr . (printf "hello %s" "world")
17:23:10 <lambdabot>  Add a type signature
17:23:15 <SamB> > putStr . (printf "hello %s" "world") :: IO ()
17:23:16 <lambdabot>    Expecting a function type, but found `IO ()'
17:23:16 <lambdabot>    Expected type: IO ()
17:23:16 <lambdabot> ...
17:23:19 <SamB> hmm.
17:23:25 <SamB> @type putStr
17:23:27 <lambdabot> String -> IO ()
17:23:49 <kpreid> > (printf "hello %s" "world")
17:23:50 <lambdabot>  Add a type signature
17:23:52 <kpreid> > (printf "hello %s" "world") :: String
17:23:54 <lambdabot>  "hello world"
17:24:01 <SamB> oh right
17:24:04 <u221e> Just getting to formatted string isn't enough...
17:24:12 <SamB> > putStr $ printf "hello %s" "world" :: IO ()
17:24:12 <lambdabot>  No IO allowed
17:24:14 <kpreid> > return (printf "hello %s" "world") :: String
17:24:14 <lambdabot>  add an instance declaration for (PrintfType Char)
17:24:16 <SamB> see see
17:24:24 <kpreid> u221e: why can't you get the string, and then output that?
17:24:31 <SamB> > return (printf "hello %s" "world") :: [String]
17:24:32 <lambdabot>  ["hello world"]
17:24:52 <u221e> kpreid, becuase I want to call my own function that takes args and operates on the String.
17:24:56 <SamB> anyway, printf is magical and only does IO if you try to make it do IO
17:25:36 <kpreid> > unwords (printf "hello %s" "world")
17:25:37 <lambdabot>  add an instance declaration for (IsChar [Char])
17:25:39 <SamB> u221e: just pretend printf returns a string
17:25:46 <kpreid> er
17:25:51 <kpreid> > words (printf "hello %s" "world")
17:25:52 <lambdabot>  ["hello","world"]
17:25:58 <kpreid> u221e: seems to work just fine
17:25:58 <u221e> Like I said, returning a String is NOT enough. That's simple.
17:26:07 <kpreid> in what way is it not enough?
17:26:10 <SamB> u221e: what more do you need?
17:26:39 <u221e> Ok... I want to call MyPrint that takes variable args like printf. With me so far?
17:26:59 <SamB> @type putStr . Text.Printf.printf
17:27:01 <lambdabot> String -> IO ()
17:27:03 <SamB> hmm.
17:27:18 <kpreid> that's tricker, yes
17:27:20 <u221e> Now since, printf relies on point free programming, the only thing I can do is MyPrint = printf
17:27:36 <kpreid> "relies on point free programming" doesn't make sense t ome
17:27:40 <u221e> Is I do that then, I don't have access to the resulting String.
17:28:30 <u221e> Could be the wrong terminology.
17:28:40 <kpreid> I think I see. you'd have to duplicate printf's typeclass to make your own pseudo-variable-argument function, yes?
17:29:05 <u221e> Yes, that takes a function to perform.
17:29:23 <SamB> u221e: the problem is probably the inability to write a type for your proposed function...
17:29:49 <u221e> What's wrong with (String -> IO ())?
17:30:01 <kpreid> no, it has a type just as much as printf does
17:30:11 <SamB> u221e: String -> IO () isn't a vararg type
17:30:20 <SamB> it isn't polymorphic
17:30:34 <u221e> Maybe I am confused on how printf really works
17:30:36 <kpreid> SamB: I think u221e meant the type of the result-processing function
17:30:42 <u221e> Yes
17:30:48 <SamB> oh
17:30:49 <SamB> well.
17:31:00 <u221e> fprintf (String -> IO()) -> String -> r
17:31:10 <u221e> forgot the ::
17:31:11 <u221e> ;)
17:31:39 <kpreid> PrintfType r => too, I assume
17:31:44 <SamB> well, hPrintf needs its own typeclass...
17:31:50 <SamB> so you would too...
17:31:58 <u221e> No, i'll ignore that
17:32:40 <u221e> kpreid, yes.
17:33:45 <SamB> u221e: you can't just ignore that!
17:34:22 <u221e> Why is hPrint needed?
17:34:27 <u221e> hPrintf
17:34:53 <SamB> well, it isn't quite
17:35:08 <SamB> but it is more convenient
17:37:18 <u221e> Is everyone working on icfp contest right now?
17:37:47 <stepcut> I am not.
17:38:12 <SamB> I am
17:38:16 <u221e> I would be... if I knew more about Haskell.
17:38:28 <SamB> I am not intending to do well though
17:38:40 <sheobug> ok
17:38:45 <SamB> I just like a good puzzle
17:39:06 <SamB> and this one doesn't seem to need much AI so far ;-)
17:39:41 <sheobug> where are the woring haskell apps?
17:39:47 <sheobug> is wash a decent web site builder?
17:40:17 <stepcut> sheobug: not really -- it is very good at form processing, but has no concept of hyperlinks :)
17:40:39 <sheobug> no cept of hyperlinks?
17:40:43 <sheobug> !
17:40:47 <sheobug> hm
17:40:53 <sheobug> how about a dns server in haskell?
17:40:57 <SamB> heh
17:40:59 <sheobug> bind is painful to me
17:41:05 <sheobug> or a scheduler
17:41:08 <sheobug> or rules engine?
17:41:11 <sheobug> or database?
17:41:22 <SamB> you want UNIX reimplemented in something better than C, you could try #twisted
17:41:56 <sheobug> unix?
17:42:04 <sheobug> hm
17:42:15 <sheobug> I have a place fo work
17:42:21 <sheobug> we are buying a sceduler
17:42:27 <sheobug> we need monitoring
17:42:35 <sheobug> because when stuff breaks no one knows
17:42:39 <sheobug> why or when exactly
17:42:43 <sheobug> its kinda hellish
17:42:55 <sheobug> when haskell get error is is easily debuggible?
17:43:51 <audreyt> depends on the kind of error.
17:43:57 <audreyt> if it's compile-time error, yes, it's very easy.
17:44:06 <sheobug> we have  lot of trouble with ftp file transfers
17:44:07 <audreyt> when it's runtime, no, it's about as hard as any other language
17:44:13 <audreyt> and harder than languages with really good debuggers.
17:44:15 <sheobug> when a file gets hung or wont transfer
17:44:25 <audreyt> that's the "hard" part.
17:44:28 <sheobug> the perl breaks down and no one except for guy who wrote it
17:44:42 <sheobug> knows where or why
17:44:46 <audreyt> perl however, at least has two pretty good debuggers...
17:45:15 <audreyt> haskell at this moment has no production-level debuggers :/
17:45:50 <sheobug> hm
17:46:01 <sheobug> is perl good when used well?
17:46:06 <marc_vw> no
17:46:07 <sheobug> my boss bitches about it
17:46:15 <sheobug> hm
17:46:16 <marc_vw> it is regexps on steroids
17:46:20 <audreyt> perl is good when you have disciplined people writing it
17:46:31 <marc_vw> it drives folks mad who want one nice elegant solution
17:46:31 <audreyt> people who read "Perl Medic" and "Perl Best Practices" and "Higher Order ePerl"
17:46:34 <sheobug> we are bringing in j2ee at my work
17:46:36 <sheobug> jboss
17:46:41 <sheobug> cuz they see its popular
17:46:44 <marc_vw> but
17:46:46 <sheobug> so hey we should do it
17:46:46 <audreyt> but if you don't have those people
17:46:49 <audreyt> then perl is hellish to maintain
17:46:51 <marc_vw> my friend is computer linguist
17:46:54 <marc_vw> he loves it
17:47:00 <marc_vw> larry wall was too
17:47:07 <sheobug> they see me as crazy to look at lplt scheme squeak or haskell
17:47:08 <marc_vw> you can express yourself in many ways
17:47:11 <sheobug> plt scheme
17:47:26 <audreyt> sheobug: O'Caml is perhaps a better bet for industrial use...
17:47:35 <audreyt> but then, if you are after a large team
17:47:39 <audreyt> of replacable parts of people
17:47:42 <marc_vw> php is easier than perl
17:47:47 <audreyt> then get them coding with Scala :)
17:47:52 <sheobug> we have 2 programmers left
17:47:54 <sheobug> lol
17:47:57 <marc_vw> and you understand what you wrote 10 mins ago
17:47:59 <sheobug> scala?
17:48:04 <audreyt> Scala runs on Java
17:48:11 <audreyt> it's Java with lots of Haskell mixed in.
17:48:14 <sheobug> Ocaml?
17:48:19 <sheobug> whats ocaml?
17:49:11 <audreyt> http://caml.inria.fr/ocaml/
17:49:32 <audreyt> somewhat more mature for production use. though haskell is getting there.
17:49:48 <stepcut> audreyt: we just switched from ocaml to haskell at my job :p
17:49:51 <audreyt> but Scala gets access to jBoss and J2EE :)
17:50:05 <audreyt> stepcut: right, I've seen several such switches this year
17:50:17 <audreyt> Hs is definitely doomed to succeed
17:50:33 <u221e> Is there a way to require modules be imported qualified?
17:50:53 <sheobug> j2ee has shitload of apps
17:51:06 <sheobug> its chaos
17:51:16 <SamB> u221e: make the exported names conflict with those of Prelude
17:51:31 <stepcut> SamB: I was about to suggest the same thing :p
17:51:33 <SamB> the users will soon import them qualified if you do
17:52:36 <stepcut> maybe you could use some template haskell code that checks if the module was imported qualified ? Not sure if that is possible though
17:53:53 <SamB> you don't need to bother, though, because Haskell users are smart
17:54:08 <SamB> just mention "qualified" in the documentation...
17:54:51 <stepcut> oh look -- they added rank numbers to the ICFP score board so you don't have to count :)
17:55:49 <sheobug> there are like 30 j2ee frameworks
17:55:53 <sheobug> !!
17:57:04 <u221e> Is there a function I can use to return information about the current operating system and CPU?
17:57:25 <audreyt> sheobug: 30 is better than 0, though, most of the time... it's also better than 1
17:57:43 <stepcut> file:///usr/share/doc/ghc6-doc/html/libraries/base/System-Info.html#v%3Aos
17:57:48 <stepcut> System.Info
17:59:07 <u221e> Thank you
18:00:06 <stepcut> haha! --> Description - Information about the characteristics of the host system lucky enough to run your program
18:00:08 <sheobug> java is really popular
18:00:21 <marc_vw> it sucks
18:00:34 <marc_vw> only good for quick guis and earning money
18:00:50 <stepcut> being 65 and broke is really popular too
18:00:53 <audreyt> java is good for teams with replaceable programmers.
18:01:03 <audreyt> like, really good. it's designed for that :)
18:01:03 <stepcut> but I wouldn't recommend it
18:01:03 <SamB> oh huh
18:01:10 <SamB> apparantly I already have Foreign.Array.Storable
18:01:11 <marc_vw> my last job was a j2ee to php port hehe
18:01:22 <marc_vw> because php coders even more replacable
18:01:39 <audreyt> that is true, though I wouldn't say by design
18:01:40 <stepcut> SamB: yes, 6.6 just adds some useful new functions
18:01:42 <wli> "labor flexibility"
18:01:44 <audreyt> it's more by natural selection ;)
18:01:51 <SamB> stepcut: but I didn't think I had that
18:02:20 <stepcut> when is 6.6 supposed to come out anyway
18:02:25 <SamB> Prelude> :set --version
18:02:25 <SamB> The Glorious Glasgow Haskell Compilation System, version 6.4.1
18:02:27 <stepcut> it is getting too awesome not to have
18:04:07 <SamB> @hoogle Foreign.Ptr a -> IO (Data.Array.Storable.StorableArray i a)
18:04:08 <lambdabot> No matches, try a more general search
18:04:11 <SamB> hmm
18:04:30 <u221e> Is there a way for GHC to embed the current date in the code? Like __DATE__ in C?
18:04:49 <notsmack> hmm, can anybody tell me why:
18:04:50 <notsmack> main = do xml <- fReadXml "test.xml"
18:04:50 <notsmack>           fWriteXml "out.xml" xml
18:05:03 <notsmack> results in:      Ambiguous type variable `a' in the constraint:
18:05:03 <notsmack>       `XmlContent a' arising from use of `fReadXml'
18:05:19 <stepcut> u221e: you could try using the cpp for that
18:05:44 <SamB> notsmack: because it can't figure out what type to use for the XML data
18:05:54 <SamB> you should specify one
18:06:09 <notsmack> SamB: makes sense...   how?  :-)
18:06:11 <stepcut> u221e: otherwise, you can use template haskell -- I once wrote some TH code that would generate its version number by checking the source control version at compile time :p
18:06:57 <SamB> notsmack: well you could do something to the data that would make it obvious what type it was supposed to be
18:07:28 <sheobug> labor flexibility lol
18:08:04 <wli> a.k.a. "bend over labor, capital's got a big one for you"
18:08:11 <stepcut> u221e: I put this in a Test.hsc -- 'main = print #{const __DATE__ }' and ran hsc2hs on it and got 'main = print 134617688'
18:08:17 <SamB> or you could use a well-placed type signature
18:08:31 <stepcut> u221e: I assume that is seconds since epoch or something
18:08:38 <notsmack> SamB: where could i put such a type signature?
18:08:44 <notsmack> main is still IO (), right?
18:08:58 * notsmack is a newbie
18:09:01 <kpreid> notsmack: xml <- fReadXml "test.xml" :: ...
18:09:02 <audreyt> main is "IO a"
18:09:04 <audreyt> IO () would do.
18:09:20 <notsmack> kpreid: thank you
18:09:25 <kpreid> actually, better, fWriteXml "out.xml" (xml :: ...)
18:09:34 <stepcut> notsmack: you can add the type to the end of line too --> xml <- fReadXml "test.xml" :: IO (XmlContent ())
18:09:36 <kpreid> because you don't need IO in the type ther
18:10:21 <notsmack> audreyt: sounds analogous to "void main(int argc, char *argv[])"?
18:11:17 <vincenz> @type (=<<)
18:11:18 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
18:11:41 <vincenz> @type (>>=)
18:11:42 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:12:44 <audreyt> notsmack: yeah I guess
18:14:45 <u221e> How would I create a text buffer in Haskell? I want to call a function like addText that would update the buffer with the additional text... but I can't figure out how.
18:15:55 * SamB doesn't understand the question
18:16:17 <SamB> at least you won't cause random buffer overflows...
18:16:21 <u221e> :\
18:16:45 <SamB> but could you describe more of the operations you'd want to perform on this "text buffer"?
18:17:28 <audreyt> u221e: newArray or newIORef
18:17:34 <u221e> Throughout my program I want to call addText to add text to a buffer and at a set point I want to print the whole think to to screen
18:17:39 <SamB> audreyt: nonono!
18:17:49 <SamB> you are just *trying* to get him to overflow his buffers!
18:17:54 <audreyt> yes
18:17:56 <audreyt> he asked for it
18:18:06 <SamB> how about a Writer monad?
18:18:10 <SamB> maybe those can do that?
18:18:11 <u221e> I asked for it?
18:18:21 <audreyt> or a STRef?
18:18:50 <audreyt> u221e: a more complete use case would be nice (or pseudocode)
18:18:51 <hellish> how much space does Nothing take up?
18:19:02 <audreyt> hellish: sizeof(void*)
18:19:07 <SamB> I don't remember seeing: <u221e> Oh, and I want buffer overflows
18:19:18 <audreyt> uh, you can't overflow with newIORef
18:19:22 <audreyt> nor with newArray, actually
18:19:23 <SamB> well, true
18:19:32 <SamB> oh.
18:19:38 <SamB> but how are those buffers?
18:20:02 <audreyt> point.
18:20:12 <u221e> I just want to add lines and update a list of Strings basically.
18:20:31 <audreyt> updater :: [String] -> [String]
18:20:34 <audreyt> something like that?
18:20:56 <audreyt> (a function that takes a list of strings and return an updated list of strings)
18:21:02 <SamB> try the State monad and a backwards list ;-)
18:21:22 <audreyt> SamB: not sure that helps...
18:21:38 * audreyt tries not bringing up peekArray
18:21:55 <SamB> heh
18:24:31 * SamB is glad his code is so simple it cannot overflow unless he has a type error in it
18:24:44 <SamB> unfortunately C isn't very good at catching type errors
18:24:50 * audreyt recommends D
18:25:01 <Eidolos> befunge!
18:25:05 <sheobug> hmmm
18:25:09 <audreyt> it's what C++ should have been
18:26:20 <u221e> How long does it take to update an element of an array?
18:26:55 <sheobug> hmm
18:27:10 <sheobug> can haskell build better websites than java?
18:28:36 <audreyt> possibility? yes
18:32:45 <SamB> u221e: what sort of array?
18:33:02 <SamB> normal Array update is O(n) in its size
18:33:09 <SamB> as are UArray updates
18:33:35 <SamB> (so don't use those if you are going to update them a lot)
18:33:41 <SamB> (preferably)
18:33:56 <SamB> (unless the arrays are small anyway)
18:39:01 <heatsink> (or your program runs too fast)
18:57:04 <ptolomy> I'm running an Intel Mac.. what is the preferred haskell platform/installation? Or at least the one that requires least effort?
18:59:13 <stepcut> ptolomy: ubuntu
19:00:46 <stepcut> ptolomy: If you search on the wiki, i think you will find a page about ghc for OS X/Intel
19:01:45 <wli> OS X/x86 shouldn't be that tough to build.
19:06:25 <u221e> Are FingerTree and Data.Sequence only availible in the development version of ghc right now?
19:15:21 * SamB wishes [n..m] didn't include m
19:16:51 * audreyt notes in perl6 that's written as [n..^m]
19:16:52 <edwardk> heh, wouldn't that be [n..m) ? =)
19:16:56 <edwardk> heh
19:16:59 <SamB> heh
19:17:22 <SamB> audreyt: too bad that is probably a valid op in Haskell...
19:17:30 <SamB> > ..^
19:17:31 <lambdabot>  Parse error
19:17:34 <SamB> > 1..^2
19:17:35 <lambdabot>  Not in scope: `..^'
19:17:39 <SamB> yah
19:17:39 <audreyt> see?
19:17:42 <audreyt> just define it
19:17:49 <SamB> but you can't
19:17:55 <edwardk> can't make one that will work for a list comprehension though
19:17:56 <SamB> because it would have the wrong type
19:17:57 <heatsink> > (Prelude...)
19:17:58 <audreyt> yeah. sad
19:17:58 <lambdabot>  Not in scope: `Prelude...'
19:19:18 <edwardk> well, someone has been busting their asses on the icfp contest site. someone shot up from nowhere to half again as many points as everyone
19:19:55 * SamB realizes he has to peek *before* freeing the Ptr
19:20:09 <SamB> thankfully I noticed this before I got my code to compile
19:20:27 <u221e> Is Template Haskell api relatively stable?
19:20:38 <edwardk> audrey: currently playing with abusing hsplugins and teplate haskell for my javascript compiler.
19:20:49 <edwardk> doesn't appear to have changed much
19:20:55 <SamB> u221e: er, not particularly, to my knowlege
19:21:08 <SamB> but not too bad I guess
19:21:15 <edwardk> but its fairly icky =)
19:21:20 <SamB> indeed
19:21:34 <u221e> Should be fine for small things though
19:21:35 <SamB> you don't want it to be stable yet
19:21:42 <edwardk> yeah
19:21:47 <edwardk> i _want_ it to change =)
19:21:49 <SamB> it would get all moldy and icky
19:22:00 <SamB> instead of just icky
19:22:15 <u221e> Is FingerTree and Data.Sequence only availible in the development version of ghc right now?
19:22:26 <stepcut> u221e: I think so
19:22:28 <SamB> hmm, I get a warning for this: foreign import read_scroll :: CString -> Ptr Word32 -> IO (Ptr Word32)
19:22:32 <SamB> what should I write instead?
19:22:41 <SamB> why doesn't GHC tell me the right way to write it?
19:23:35 <SamB> hmm, at least it is using 100% CPU...
19:23:47 <stepcut> SamB: perhaps you want -> foreign import ccall read_scroll :: ....
19:23:51 <edwardk> this is a good thing? =)
19:24:03 <u221e> If I have two versions of GHC installed, how does Cable know which one to install the packages too? Both?
19:24:24 <SamB> stepcut: ah
19:24:28 <SamB> that fixes it
19:24:33 <SamB> it could have just said...
19:24:33 <u221e> Cabal even
19:24:47 <stepcut> u221e: probably whichever one you get if you just type, 'ghc'
19:24:59 <dgoldsmith> ptolomy: the page to look at for Intel Mac builds is http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
19:25:01 <lambdabot> Title: X86OSXGhc - GHC - Trac
19:25:04 <edwardk> yeah thats all it does when i install stuff with cabal.
19:25:11 <dgoldsmith> There isn't an official build yet.
19:25:16 <u221e> stepcut, can I make it install for one or the other?
19:25:29 <u221e> or Both?
19:25:51 <stepcut> u221e: you will have to compile / install it twice, once for each compiler
19:26:01 <stepcut> u221e: there is probably a Setup.hs configure option to give it the full path to the compiler
19:26:16 <u221e> Thanks again
19:26:32 <SamB> hmm
19:26:45 <SamB> apparantly GHC wants there to be a prototype for my function
19:27:14 <stepcut> SamB: you can just stick the prototype in a .h file and do #include "my.h"
19:27:24 <SamB> er, no!
19:27:26 <SamB> I cannot
19:27:32 <stepcut> oh ?
19:27:34 <SamB> for the .h file would not be valid Haskell
19:27:56 <heatsink> You specify the header file in a string in the import statement
19:28:04 <DukeDave> hey gang - would anyone like to play my new game, "implement the tree"? :)
19:28:08 <heatsink> I don't quite remember the syntax
19:28:13 <stepcut> SamB: that is ok -- you can also do it this way, foreign import ccall unsafe "jack/jack.h jack_last_frame_time" jackLastFrameTime :: Ptr JackClient -> IO CUInt
19:29:01 <SamB> yeah, I thought so
19:29:14 <SamB> I was just giving running commentary for some reason
19:29:48 <DukeDave> http://www.dukedave.com/images/theTree.png
19:29:54 <stepcut> but, I am pretty sure you can just also do, #include "my.h" -- it knows it is a C header file
19:30:06 <stepcut> hrm, actually, maybe that is because I am using hsc2hs
19:30:08 <stepcut> :p
19:30:20 <DukeDave> thoughts welcome - I've been stumped for hours :|
19:30:46 <SamB> stepcut: most likely
19:31:00 <SamB> because if I did that it would give me a syntax error, actually ;-)
19:31:01 <DukeDave> I would like to construct it from a list, e.g. [1..6
19:31:08 <DukeDave> ]
19:32:52 <stepcut> DukeDave: like --> foldl addElement emptTree [1..6] ?
19:33:02 <vincenz> is there some way to trace haskell?
19:33:07 <vincenz> single step or so?
19:33:28 <stepcut> vincenz: I think that is what hat does
19:33:44 <stepcut> vincenz: but in a haskelly way :)
19:33:51 <DukeDave> stepcut, yeah, I've had most success with the foldl route
19:34:21 <foxy__> How do I resolve circular module dependencies?
19:34:26 <DukeDave> vincenz, get some really big sheets of paper and a pen ;)
19:35:02 <DukeDave> but I can't get a definition which produced a balanced tree
19:35:03 <SamB> foxy__: the {-# SOURCE #-} pragma + hs-boot files
19:35:10 <stepcut> DukeDave: hrm, you can't actually have an empty tree, can you ?
19:35:15 <DukeDave> no
19:35:27 <DukeDave> I've been 'boot strapping' it
19:35:29 <SamB> but be careful to make sure each module gets imported once without {-# SOURCE #-} too
19:35:33 <vincenz> hat won't compile
19:35:57 <SamB> vincenz: so, pen and paper ;-)
19:35:59 <vincenz> ...
19:36:06 <foxy__> SamB, thanks, hmm... is this documented?
19:36:08 <DukeDave> so makeTree (x:xs) = foldl (Leaf x) addElem xs
19:36:15 <SamB> vincenz: quickcheck then?
19:36:17 <SamB> foxy__: yes
19:36:25 <stepcut> vincenz: You could mark it up with Debug.Trace.trace calls (different type of trace than what you are talking about though)
19:36:28 <SamB> @google "{-# SOURCE #-}"
19:36:28 <DukeDave> and makeTree [] = error
19:36:30 <lambdabot> http://sourceforge.net/
19:36:32 <SamB> hmm
19:36:33 <vincenz> stepcut: I need exits as well
19:36:38 <SamB> google does not like wierd things
19:36:39 <heatsink> heh
19:36:47 <DukeDave> what do ya think? :)
19:36:50 <SamB> @google "{-# SOURCE #-}" GHC documentation circular
19:36:53 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/separate-compilation.html
19:36:53 <lambdabot> Title: 4.6. Filenames and separate compilation
19:37:06 <stepcut> vincenz: hrm, dunno
19:38:05 <SamB> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/separate-compilation.html#mutual-recursion
19:38:06 <lambdabot> Title: 4.6. Filenames and separate compilation
19:38:20 <SamB> foxy__: see that section
19:38:24 <SamB> 4.6.9
19:38:38 <foxy__> SamB, thanks, that's exactly what I'm after
19:38:55 * SamB patpats his baby @google
19:39:16 <u221e> Heh, the current hsSDL examples are broken.
19:40:08 <stepcut> DukeDave: are the numbers always added in ascending order?
19:40:37 <stepcut> DukeDave: like, what happens if you do, makeTree [1,3,2] ?
19:41:22 <DukeDave> Branch (Branch (Leaf 1) (Leaf 3)) (Leaf 2)
19:41:32 <DukeDave> ideally
19:42:08 <stepcut> ok, so the sort order is not important ?
19:42:42 <DukeDave> well,
19:42:43 <DukeDave> no
19:43:06 <DukeDave> the elems being added do not need to be Ord
19:43:19 <SamB> hmm, too bad I can't hoogle "ByteArray# -> Ptr a" or the other way around
19:43:46 * SamB wants to memcpy
19:43:56 <DukeDave> but the tree should be constructed such that the leaf nodes, traversed in order, produce the original list
19:44:12 <DukeDave> uh, preorder?
19:44:25 * DukeDave tries to remember first year comp sci
19:45:16 <DukeDave> using the boot-strap and foldr method I can produce something of the form: http://www.dukedave.com/images/badTree.png
19:46:36 <DukeDave> with:  addElem x tree = Branch tree (Leaf x)
19:47:15 <DukeDave> grr, just can't get my head around it
19:48:45 <stepcut> @paste
19:48:45 <lambdabot> http://paste.lisp.org/new/haskell
19:48:57 <SamB> what is the difference between and Addr# and a ByteArray#
19:48:58 <SamB> ?
19:49:17 <lisppaste2> stepcut pasted "is this the right output?" at http://paste.lisp.org/display/23012
19:50:50 * DukeDave cries
19:50:52 <DukeDave> yeah
19:50:58 <DukeDave> perfect
19:51:07 <SamB> hmm hmm hmm
19:51:10 * stepcut hacked it real bad
19:51:17 * kpreid is trying too
19:51:23 * heatsink has a solution
19:51:59 <heatsink> It's recursive, and keeps a count of the desired tree size for the next subtree to build
19:52:16 <hellish> Why does Data.Map.lookup return a monadic type?
19:52:32 <stepcut> hellish: so you can choose how to handle failure if the element does not exist
19:52:58 <stepcut> hellish: Since Maybe has a Monad instance, you can get the normal Just v / Nothing behaviour
19:53:04 <edwardk> Maybe?
19:53:07 <stepcut> hellish: but, you could also use a different Monad if you want
19:53:19 <SamB> > Just "Hello!"
19:53:20 <lambdabot>  Just "Hello!"
19:53:21 <stepcut> edwardk: data Maybe a = Just a | Nothing
19:53:30 <SamB> > Just "Hello!" `mplus` Nothing
19:53:31 <lambdabot>  Just "Hello!"
19:53:40 <edwardk> my question was a response to the original why does it use a monadic type. not asking what maybe is =)
19:53:46 <SamB> > Nothing `mplus` Just "Hello!" `mplus` Nothing
19:53:47 <lambdabot>  Just "Hello!"
19:53:52 <edwardk> if i don't know that by now i probably shouldn't be using haskell =)
19:53:58 <stepcut> heatsink: my solution is much different, it uses a silly backtracking approach
19:54:01 <hellish> what would other monads do in that situation?
19:54:15 <DukeDave> stepcut, I don't suppose I'm allowed to see your implementation of makeTree?
19:54:15 <SamB> well...
19:54:19 <kpreid> mine repeatedly takes the length of sublists, but could be fixed
19:54:34 <stepcut> DukeDave: makeTree (x:xs) = foldl addElem' (Leaf x) xs
19:54:53 <SamB> hellish: it depends on how the fail method for that monad is implemented
19:55:24 <hellish> So using catch as if it were an IO action would also work?
19:55:42 <stepcut> hellish: I think so
19:55:47 <vincenz> @type (>>=)
19:55:48 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:56:00 <DukeDave> with my addElem?
19:56:01 <lisppaste2> kpreid pasted "tree builder for DukeDave" at http://paste.lisp.org/display/23013
19:56:39 <edwardk> you know the biggest thing i want that i can't get out of hoogle is a quick link into the source code where the function is defined.
19:57:12 <DukeDave> thanks :)
19:57:35 <lisppaste2> stepcut annotated #23013 with "a 'backtracking' solution" at http://paste.lisp.org/display/23013#1
19:57:50 <SamB> edwardk: "class Monad" will not be a very interesting read
19:58:02 <edwardk> samb: Data.Map lookup =P
19:58:08 <SamB> oh
19:58:12 <lisppaste2> heatsink pasted "Tree size counting version" at http://paste.lisp.org/display/23014
19:58:18 <edwardk> i can look it up by hand
19:58:23 <edwardk> but by then my interest is lost ;)
19:58:33 <SamB> edwardk: sorry, I got you mixed up with vincenz because both of you are the same color, length, and capitalization
19:58:47 <edwardk> leave my length out of this =P
19:58:59 <SamB> > length "<edwardk>"
19:59:01 <lambdabot>  9
19:59:05 <stepcut> hrm
19:59:12 <SamB> > length "<vincenz>"
19:59:14 <lambdabot>  9
19:59:20 <heatsink> Are those Metric or British units?
19:59:24 <SamB> no
19:59:26 <SamB> they are not
19:59:43 <stepcut> oops, I forgot an important part in mine :)
20:00:04 <DukeDave> thanks guys - I'm just digesting and processing your geniuses :)
20:00:09 <stepcut> the recursion part ;)
20:00:11 <SamB> hmm
20:00:22 * stepcut hacks 
20:00:32 <SamB> can I unsafeCoerce a Ptr into a ByteArray# somehow?
20:00:47 <heatsink> SamB: deconstruct it?
20:01:19 <SamB> hmmmmm
20:01:23 <SamB> looks tricky
20:01:42 <SamB> ah, GHC.Ptr exports it with a constructor
20:01:43 <heatsink> source says data Ptr a = Ptr Addr#
20:02:31 <SamB> oh, or I could just foreign import memcpy with the right type...
20:04:51 <SamB> oh oh
20:05:11 <SamB> or I could just try using IOUArray before resorting to such nasty things, silly me ;-)
20:05:23 <stepcut> hrm, all three 'solutions' to makeTree generate different answers for [1..7] :)
20:06:11 <heatsink> Yea, the problem is still a bit underspecified :)
20:06:15 <lisppaste2> kpreid annotated #23013 with "mine with length caching" at http://paste.lisp.org/display/23013#2
20:06:24 <vincenz> > or []
20:06:25 <lambdabot>  False
20:06:43 <SamB> what?
20:06:47 <zarvok> @djinn a -> b -> (a,b)
20:06:47 * SamB would have thought True
20:06:48 <lambdabot> f a b = (a, b)
20:06:55 <SamB> who wrote or?
20:07:10 <SamB> er, maybe not...
20:07:11 <kpreid> in order to make it efficient without messing with the algorithm, I just substituted all the list functions with versions that track lengths.
20:07:16 <kpreid> > and []
20:07:17 <lambdabot>  True
20:07:19 * SamB is silly 
20:07:24 <heatsink> > (False || True, False || False)
20:07:25 <lambdabot>  (True,False)
20:07:27 <kpreid> has this been done before?
20:07:36 <SamB> okay, I guess "or []" should return Flase
20:07:38 <SamB> er, False
20:09:08 <SamB> waitwait
20:10:55 <u221e> Does darcs-all in the GHC directory grab all the available libraries as well?
20:11:23 <kpreid> SamB: f x == f (f [] : x) where f is (and) or (or)
20:11:55 <kpreid> (or sum or product, too)
20:12:27 * heatsink thinks "or []" should return FileNotFound
20:13:02 <kpreid> > [f x == f (f [] : x) | f <- [and, or], x <- [False, True]]
20:13:03 <lambdabot>  Couldn't match `[Bool]' against `Bool'
20:13:32 <kpreid> oop
20:13:43 <kpreid> > [f x == f (f [] : x) | f <- [and, or], x <- [[False], [True]]]
20:13:44 <lambdabot>  [True,True,True,True]
20:14:07 <u221e> To build GHC do I have to already have a version of GHC?
20:14:35 <kpreid> > [f x == f (f [] : x) | f <- [sum, product], x' <- [1..4], x <- inits x']
20:14:36 <lambdabot>  add an instance declaration for (Num [a])
20:14:37 <lambdabot>   In an arithmetic sequence: [1...
20:14:57 <heatsink> u221e, No, there's some kind of bootstrapping process where it builds a haskell compiler that builds ghc.
20:15:00 <kpreid> > [f x == f (f [] : x) | f <- [sum, product], x' <- [1..4], x = [x]]
20:15:01 <lambdabot>  Parse error
20:15:08 <kpreid> > [f x == f (f [] : x) | f <- [sum, product], x' <- [1..4], let x = [x]]
20:15:09 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
20:15:10 <lambdabot>    Expected...
20:15:13 <kpreid> > [f x == f (f [] : x) | f <- [sum, product], x' <- [1..4], let x = [x']]
20:15:14 <lambdabot>  [True,True,True,True,True,True,True,True]
20:16:07 <lisppaste2> stepcut annotated #23013 with "pretty print the tree" at http://paste.lisp.org/display/23013#3
20:16:48 <lisppaste2> stepcut annotated #23013 with "updated to recurse" at http://paste.lisp.org/display/23013#4
20:17:01 <foxy__> @pl (\fb -> return $ FB.name fb)
20:17:01 <lambdabot> return . (FB .) . name
20:17:17 <kpreid> foxy__: @pl doesn't understand qualified names
20:17:21 <foxy__> @pl (\fb -> return $ name fb)
20:17:22 <lambdabot> return . name
20:18:40 <stepcut> kpreid: I am not sure your solution is correct, it looks like the (Leaf 1) does not have a sibling, and (Leaf 2) and (Leaf 3) are paired together...
20:19:27 <kpreid> stepcut: how is that wrong?
20:21:51 <stepcut> kpreid: try, makeTree [1..3]. I think his graph is, (Branch (Branch (Leaf 1) (Leaf 2)) (Leaf 3)), but yours generates, (Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3)))
20:23:34 * stepcut gets back to real work
20:23:38 <kpreid> that's easily enough fixed
20:23:39 <u221e> heatsink: It says GHC is required unless bootstrapping from .hc files
20:23:46 <kpreid> where l' = ceiling ((fromIntegral l) / 2)
20:24:30 <kpreid> I don't see that it really matters, though; it's just the choice of which branch is slightly more filled
20:24:46 <heatsink> u221e, I don't really know how the bootstrapping process works, but I think you can build it without having it installed.
20:25:38 <kpreid> oh, I see, mine won't ever generate http://www.dukedave.com/images/theTree.png
20:25:49 <kpreid> I assumed just a balanced tree was wanted
20:26:13 <stepcut> kpreid: ah, that makes sense
20:26:30 <stepcut> kpreid: my solution is scary :)
20:27:25 * heatsink 's solution has a redundant line of code
20:27:46 <stepcut> but I am not sure what is supposed to happen when you insert '7'
20:28:14 <stepcut> I assumed that the [1..6] tree would become the left child, and '7' would become the right child
20:28:46 <stepcut> but, I think maybe he wanted it rebalanced ?
20:30:11 <stepcut> oh well, balancing is for unicyclists
20:30:17 <DukeDave> aha
20:30:20 <DukeDave> still going? :)
20:30:34 <DukeDave> I'm still getting my head round the current suggestions :)
20:30:42 <heatsink> Does it need to be specifically one solution, or is any properly orderered tree of the right height good?
20:30:53 <DukeDave> one specific soln.
20:31:04 <DukeDave> so in adding 7..
20:31:56 <DukeDave> you'd have  B (1..4 as prev.)   (B (B 5 6) 7)
20:32:14 <DukeDave> then  B (1..4 as prev.)   (B (B 5 6) (B 7 8))
20:32:25 <stepcut> DukeDave: ah, mine does not do that :)
20:33:14 <DukeDave> heatsink 's seems to be the closest :)
20:33:19 <DukeDave> I think it's perfect
20:33:23 <stepcut> DukeDave: yeah, I think so too
20:33:26 <heatsink> wul thx
20:33:30 <DukeDave> I'm just trying to write
20:33:42 <DukeDave> a func to pretty print the tree now :)
20:33:43 * stepcut ponders if his solution is salvagable
20:33:56 * DukeDave hands heatsink a cookie
20:34:05 <stepcut> DukeDave: I wrote one -- but it may not be what you need
20:34:27 <stepcut> http://paste.lisp.org/display/23013#3
20:35:08 <DukeDave> it'll all be helpful :D
20:35:36 <DukeDave> oh dear - fmap
20:35:52 <DukeDave> functors?   I remember giving up on reading about those  *_*
20:35:52 * heatsink looks at the cookie.  "name=last_visited&domain=bulldogdsl.com&expiration=20060822"?
20:36:07 <DukeDave> hehe
20:36:18 <DukeDave> damn nerds ;)
20:36:20 * heatsink accepts the cookie
20:54:29 <Dino_> Is it possible to insert elements between others in the "stock" array things like Data.Array.MArray or similar?
20:56:14 <SamB_XP> nope
20:57:18 <Dino_> Interesting. So where it's mutable, it's only change-existing-elements mutable, not grow the size arbitrarily from the middle.
20:58:07 <SamB_XP> yeah, it doesn't have as many features as e.g. Python's list type...
20:58:24 <SamB_XP> but why would you want to insert something in the middle anyway?
21:00:39 <Dino_> I wrote something that reads key=value pair config type text files. And I was thinking of making it also able to handle preserving comments, blank lines and programmatic additions to the data before writing back out.
21:01:27 <SamB_XP> sounds neat
21:01:32 <SamB_XP> I have no idea how you do that though
21:01:35 <Dino_> This leads me to think of how to store the data not as a map but in something like a list or array. (or least the keys stored that way) and then be potentially able to stick new items between others.
21:01:49 <SamB_XP> I'd do a list on a per-section basis
21:02:07 <Dino_> But it can just be done in an ugly manner, like new list has everything before, then the new one, then everything after.
21:02:17 <Dino_> We're not talking about monstrous amounts of inserts.
21:02:24 <SamB_XP> why would you be inserting?
21:03:23 <Dino_> To group things together that are related. But maybe the container is bad in that case. As in it should be hierarchical.
21:03:42 <SamB_XP> indeed
21:04:57 <SamB_XP> oh, and you should probably be using plain-old lists
21:05:00 <SamB_XP> not arrays
21:05:43 <Dino_> Why use arrays in general instead of lists?
21:05:52 <SamB_XP> you don't
21:06:00 <SamB_XP> you use them in specific cases where they make sense
21:06:01 <SamB_XP> ;-)
21:06:12 <Dino_> They have fast indexing, is that where the excel?
21:06:17 <Dino_> s/the/they/
21:06:19 <SamB_XP> yeah, pretty much
21:06:59 <Dino_> Ok, thank you.
21:07:08 <SamB_XP> if you have to index something by densely-packed whole numbers or something of that ilk, basically
21:08:02 <SamB_XP> can work nicely for dynamic programming
21:08:57 <johnnowak> Dino_: Basically, in a list, each element in the list points to the next element. Inserting an element then is as simple as telling the element before the insertion point to point to the new element and the new element to point to the one after the insertion point. For arrays, you'd need to resize the array and then shift up every piece of data after the insertion point to add it, or just copy data over to a new array entirely.
21:09:21 <SamB_XP> well, each cell in the list...
21:09:28 <liyang> nomeata: new and improved Gtk2Hs debs. I hope they work... (next step, make a repository.)
21:09:32 <Dino_> johnnowak: Oh, so lists can actually handle insertion with less work?
21:09:37 <SamB_XP> points to an element and another cell...
21:09:52 <johnnowak> SamB_XP: Well, yes, it also stores data, otherwise it would be useless. :)
21:10:03 <johnnowak> Dino_: Yes, much less.
21:10:08 <Dino_> For some reason I thought they were only nice about it if you built onto the ends.
21:10:12 <SamB_XP> johnnowak: you actually have to throw out the front part of the lits altogether
21:10:34 <SamB_XP> Dino_: it really only works well if you stick things on at the beginning ;-)
21:10:36 <Dino_> Or perhaps even only the tail end.
21:10:38 <johnnowak> SamB_XP: Why?
21:10:43 <Dino_> hm
21:11:01 <SamB_XP> johnnowak: because this is not Lisp, and you can't mutate existing cons cells
21:11:12 <johnnowak> Ah. Well drats then.
21:11:20 <johnnowak> I am primarily a Schemer. :)
21:11:25 <SamB_XP> hehe
21:11:52 <johnnowak> Dino_: There's your solution Write it in Scheme. ;-)
21:11:54 <SamB_XP> often the simplest thing to do is build a list by adding to the beginning and then reverse it when you are through ;-)
21:11:55 <Dino_> I suppose a lot of adds could be done and then the list could be reversed when done.
21:12:02 <SamB_XP> yeah ;-)
21:12:13 <SamB_XP> that makes it O(n) rather than O(n^2)
21:12:26 <Dino_> squared!
21:12:32 <SamB_XP> yeah
21:12:52 <SamB_XP> repeatedly appending things to the end of a list is O(n^2)
21:13:07 <SamB_XP> another strategy is to build a list of lists and concat them
21:13:12 <SamB_XP> @type concat
21:13:13 <lambdabot> forall a. [[a]] -> [a]
21:13:27 <johnnowak> SamB_XP: Is there no way to do efficient inserts in Haskell?
21:13:28 <Dino_> Ah, work on the data in sections. Assemble later.
21:13:41 <SamB_XP> johnnowak: sure ;-)
21:13:45 <SamB_XP> insert at the beginning ;-)
21:13:53 <johnnowak> SamB_XP: besides that. :)
21:14:13 <johnnowak> I mean it certainly wouldn't be a limitation unique to Haskell. Just curious.
21:14:21 <johnnowak> I rarely have a need to do it.
21:14:52 <SamB_XP> well, you could do something with MVars
21:15:09 <SamB_XP> @hoogle Queue
21:15:09 <lambdabot> Data.Graph.Inductive.Internal.Queue :: module
21:15:10 <lambdabot> Data.Queue :: module
21:15:10 <lambdabot> Data.Queue.Queue :: data Queue a
21:15:24 <SamB_XP> @docs Data.Queue
21:15:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Queue.html
21:15:59 <SamB_XP> hmm
21:16:05 <SamB_XP> oh right ;-)
21:16:15 <SamB_XP> @hoogle Channel
21:16:16 <lambdabot> No matches found
21:16:19 <SamB_XP> @hoogle Chan
21:16:20 <lambdabot> Control.Concurrent.Chan :: module
21:16:20 <lambdabot> Control.Concurrent.Chan.Chan :: data Chan a
21:16:20 <lambdabot> Distribution.Compat.FilePath.changeFileExt :: FilePath -> String -> FilePath
21:16:27 <SamB_XP> @docs Control.Concurrent.Chan
21:16:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
21:17:18 <SamB_XP> though note that okasaki has written about a wide variety of purely-functional datastructures which you might find interesting
21:17:43 <SamB_XP> but no, there really isn't anything for it but to add stuff at the front end of a list
21:18:06 <SamB_XP> if you are going to use the standard list type
21:18:41 * johnnowak looks at one of okasaki's papers
21:19:10 <SamB_XP> he also has a book which I should buy and never properly read ;-)
21:19:24 <SamB_XP> well. I mean, if I bought it I probably wouldn't properly read it ;-)
21:19:39 <johnnowak> i've taken to putting my books into a queue where i cannot read any of them until i finish the one on top. seems to help. :)
21:19:51 <Korollary> heh
21:20:25 <SamB_XP> that is certainly an appropriate place to put okasaki's "Purely functional datastructures" -- even if it would be an imperative stack
21:20:41 <SamB_XP> er, queue
21:20:51 <SamB_XP> hard to remember which is which in real life
21:20:54 <SamB_XP> ;-)
21:21:02 <Korollary> both
21:21:36 <Korollary> mine is a stack indeed
21:22:05 <SamB_XP> I need to take time to read technical stuff...
21:23:28 <Dino_> Hm. Data.Queue  It says O(1) even for addToQueue
21:24:09 <SamB_XP> yeah.
21:24:12 <SamB_XP> different datastructure
21:24:19 <SamB_XP> standard lists are like this:
21:24:21 <Dino_> Well, both addToQueue and deQueue, so there you go, adding to one and and taking from the other. Fast.
21:24:33 <Dino_> bah, one end
21:24:44 <SamB_XP> data [a] = [] | a:[a]
21:25:44 <SamB_XP> if you look at the source for Data.Queue, you'll see something quite different
21:26:12 <SamB_XP> (or you could just read the journal article so handily referenced)
21:28:23 <Dino_> Referenced above? I only see URLs to haddock docs.
21:29:29 <SamB_XP> it is in the bibliography of the haddock doc ;-)
21:29:35 <SamB_XP> @docs Data.Queue
21:29:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Queue.html
21:29:50 <SamB_XP> well, description really
21:30:00 <SamB_XP> Description
21:30:00 <SamB_XP> Queues with constant time operations, from Simple and efficient purely functional queues and deques, by Chris Okasaki, JFP 5(4):583-592, October 1995.
21:30:01 <Dino_> Ah, I see.
21:30:44 <SamB_XP> okay, it is probably half-past red and I need to go to bed ;-)
21:31:00 <Dino_> Hey, thanks for the help.
21:31:40 <SamB_XP> (Thats a reference to something said when discussing the neat statistics dons has generating every day)
21:42:15 <Dino_> sleep
21:44:30 <stepcut> hrm, I have forgetting almost everything I knew about DSP :)
21:44:50 <stepcut> forgotten
21:47:59 <johnnowak> "i forgot"
21:48:13 <stepcut> even better
21:48:29 <johnnowak> "i dun know nufin bout no dsp no more"
21:49:10 <stepcut> dsp `elem` myKnowledge == False
21:49:39 <johnnowak> dsp.gotIt(totally) == asIf;
21:49:53 <johnnowak> !dsp
22:41:50 <mathewm> MMap ?  Mutable Maps?
23:45:41 <notsmack> what do you guys use for SQL?
23:57:49 <audreyt> hdbc-sqlite
