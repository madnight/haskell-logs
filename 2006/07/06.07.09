00:53:27 <dons> huh, there's been 55 contributors to lambdabot yi and fps in the last 12 months
00:53:29 <dons> thanks guys!
00:53:35 <dons> ?karma+ #haskell
00:53:35 <lambdabot> #haskell's karma raised to 1.
00:53:37 <dons> ?karma+ #haskell
00:53:38 <lambdabot> #haskell's karma raised to 2.
00:54:28 <jer> neato
01:01:30 <lispy> dons: cool
01:01:36 <lispy> @karma+ dons
01:01:36 <lambdabot> dons's karma raised to 39.
01:20:54 <roconnor> what are the rules about using foldr and foldl' and strictness vs laziness of the two arguments?
01:25:47 <dons> foldl' is strict in the accumulating value
01:25:58 <dons> which is almost always want you want (strictness in the accumulator)
01:26:08 <dons> foldr is good when you need to compute from the end of the list
01:26:17 <roconnor> Is foldr (flip (.)) best
01:26:47 <roconnor> because flip (.) is lazy in it's second argument.
01:26:48 <dons> best for what?
01:27:02 <roconnor> best for memory use of course ;)
01:27:08 <dons> it all depends on what you're trying to do.
01:27:16 <dons> usually i'd say foldl' is going to win.
01:27:17 <roconnor> it does?
01:27:43 <dons> but it really depends on the data type you're going to build
01:28:02 <roconnor> let's say int -> int
01:28:44 <dons> > foldl' (+) 0 [1..10] -- is quite good, for example
01:28:46 <lambdabot>  55
01:29:20 <roconnor> I'm having trouble seeing the memory requirements of foldr (flip (.))
01:29:37 <roconnor> Consider foldl' (.)
01:29:50 <mauke> @type foldr (flip (.))
01:29:52 <roconnor> this will presumably force the evaluation
01:29:52 <lambdabot> forall b c. (b -> c) -> [b -> b] -> b -> c
01:30:01 <dons> you want to fold over a list of functions?
01:30:16 <roconnor> dons: you have a better way of composing a list of functions?
01:30:24 <dons> well, no, that's a good way 
01:30:45 <roconnor> I wrote this beautiful piece of haskell last night
01:31:00 <dons> but if you're dealing with datatypes containing functions, why're you worried about space/performance?
01:31:01 <roconnor> (foldr (flip (.)) id (zipWith mkStep3 k_256 w) h)
01:31:25 <dons> yeah, nice.
01:31:29 <roconnor> what if I have a lot of functions?
01:31:54 <roconnor> Suppose I am generating a list of 1000000 functions
01:32:07 <roconnor> (so it isn't true in this case, but it is a good excercise)
01:32:09 <dons> i'd imagine a loop would be more efficient, than generating 1000s of functions in a data type
01:32:49 <roconnor> dons: I couldn't figure out how to make a loop
01:32:55 <dons> keep things on a level gcc can understand, and you get good code. otherwise, don't worry about performance so much -- and enjoy the expressivity :)
01:33:01 <roconnor> k_256 generates one of the parameters
01:33:12 <roconnor> and it is sort of arbitrary.
01:33:17 <roconnor> and external.
01:34:02 <roconnor> w is internal, but kinda complicated.
01:34:23 <roconnor> w = m++wZip (drop (16-2) w) (drop (16-7) w) (drop (16-15) w) (drop (16-16) w)
01:35:55 <roconnor> anyhow, I'm intrested if there is a better way to do that line.
01:36:10 <roconnor> the code is a bit confusing and it was really late when I wrote it.
01:37:48 <lisppaste2> roconnor pasted "sha256step" at http://paste.lisp.org/display/22281
01:39:13 * roconnor is always trying to write more elegent code
01:41:00 <roconnor> @hoogle zipWith4
01:41:01 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
01:41:05 <roconnor> oh
02:10:39 <dons> now, why is datalab.navy.mil downloading fps from the darcs repo?
02:21:29 <science-user> is haskell a lisp?
02:21:45 <dons> no
02:21:55 <dons> its a purely functional, statically typed programming language
02:22:07 <dons> > map (*2) [1..10]
02:22:09 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
02:23:57 <dons> it's a child of ML, and influenced by Clean, Scheme, Lisp, and Miranda
02:24:20 <dons> it differs from lisp in that it is pure, lazy and strongly, statically typed
02:24:24 <dons> and has nicer syntax, imo.
02:24:39 <dons> you can find out heaps more at http://haskell.org :)
02:24:41 <lambdabot> Title: "Haskell - HaskellWiki"
02:34:01 <dons> science-user: does that answer your question? or do you have some more questions about Haskell?
02:39:12 <|Steve|> dons: Is it statically typed? I know it's strongly typed.
02:40:46 <Igloo> It is
02:40:52 <science-user> well
02:41:11 <science-user> is it a better choice than say perl to build a company around and ger rich?
02:42:40 <science-user> I want to learn to program
02:42:49 <science-user> and get lots fo work done in cpmuters
02:42:53 <science-user> to add value
02:42:55 <science-user> et
02:42:59 <science-user> ect
02:43:49 <|Steve|> So no typing can be done at run time?
02:46:23 <Lemmih> science-user: Haskell is to a programmer as a pen is to a writer. Becoming a great writer (or programmer) takes a lot of hard work no matter what tools you use.
02:49:01 <mauke> |Steve|: you can't type things at runtime, ever
02:49:07 <|Steve|> Okay.
02:49:28 <|Steve|> I don't know all that much about haskell. It's a cool language, though.
02:49:37 <mauke> this isn't haskell specific
02:49:59 <science-user> hmm
02:50:09 <|Steve|> Oh, then you're just wrong.
02:50:10 <science-user> is haskell at all related to sisal?
02:50:15 <mauke> |Steve|: how so?
02:50:17 <|Steve|> Take a language like objective C.
02:50:25 <|Steve|> It's weakly and dynamically typed.
02:50:33 <Lemmih> mauke: That Haskell is statically typed sounds pretty Haskell specific (:
02:50:38 <|Steve|> You can send any message to any object at any time.
02:50:55 <mauke> |Steve|: oh, so each value carries a tag that identifies its "type"?
02:50:58 <|Steve|> How the object responds to the message is completely determined by what object it is.
02:51:00 <|Steve|> Yes.
02:51:07 <mauke> you can do that in haskell, of course
02:51:30 <mauke> data Universal = UInt Int | UStr String | UList [Universal] | ...
02:51:32 <|Steve|> But you can pass objects between programs that the other program has never seen before.
02:51:49 <|Steve|> Isn't that just a union though?
02:51:57 <mauke> that's what dynamic typing is
02:52:04 <|Steve|> Well, sort of.
02:53:25 <science-user> so haskell is better then perl?
02:53:39 <|Steve|> "better"?
02:53:40 <eivuokko> It's a matter of opinion.  Most on this channel probably think so.
02:53:41 <|Steve|> No.
02:53:44 <|Steve|> It's different.
02:54:12 <Lemmih> I would rather use Haskell than Perl for most things.
02:54:26 <|Steve|> heh
02:54:38 <|Steve|> I'd rather use perl for text processing.
02:55:58 <|Steve|> And for one line scripts.
02:56:11 <pesco> science-user: No, Haskell is way worse than Perl, because Perl has many more specialized operators, more flexible syntax, doesn't force static typing on you, supports regular expressions natively, just to name a few points. Also Perl 6 will be much faster than Haskell.
02:56:26 <eivuokko> I agree with Lemmih.   And I prefer parsec (a parser library in haskell) over regexp+perl.
02:57:06 <isaacd> pesco: great! computers will be much faster than possible after the invention of perl 6!
02:57:22 <|Steve|> Heh.
02:57:28 <|Steve|> I doubt perl will be faster than haskell.
02:57:30 <|Steve|> ghc kicks ass.
02:57:59 <isaacd> Not to mention the potential of jhc
02:58:04 <mauke> pesco: I think haskell's syntax is more flexible :-)
02:58:05 <pesco> @where irony
02:58:05 <lambdabot> I know nothing about irony.
02:58:18 <mauke> perl's syntax is more awesome, though
02:58:18 <pesco> lambdabot: That's what I expected.
02:58:57 <|Steve|> It's hard to beat doing something like perl -ne '/(\d+)\s+(\d+)/;$a+=$1;$b+=$2'END{print "a=$a b=$b\n"}' though.
02:59:11 <pesco> Matter of opinion.
02:59:12 <|Steve|> Doing that to add two columns of numbers.
02:59:19 <mauke> that script doesn't work
02:59:27 <|Steve|> heh, nope.
02:59:27 <mauke> (unbalanced '')
02:59:31 <|Steve|> I have one too many '.
02:59:42 <|Steve|> Remove the middle one, it was supposed to be ;.
02:59:44 <mauke> the other problem is that it doesn't check for match failure
03:00:43 <|Steve|> Ah, true.
03:00:44 <isaacd> If you know perl, then it's great for quick things -- the same sort of way using a shell is, only perl is closer to the flexible programming language idiom
03:01:18 <|Steve|> perl -ne 'if(/(\d+)\s+(\d+)/){$a+=$1;$b+=$2}END{print "a=$a b=$b\n"}' then.
03:01:22 <pesco> Just for kicks, compare that to "\s -> print [(a,b) | [a,b] <- map read (words s)]"
03:01:25 <isaacd> (shell < perl < haskell is the comparison I'm alluding to here)
03:01:50 <isaacd> (for some comparison area)
03:02:07 <isaacd> (flexible programming)
03:02:09 <pesco> Ah, wait, is that correct...
03:02:32 <isaacd> pesco: no, show.read
03:02:42 <isaacd> It needs type specification
03:02:49 <pesco> Something like that.
03:03:04 <|Steve|> I guess it's all what you know. I don't know how to do I/O very well in haskell.
03:03:12 <|Steve|> Still, what if the regex was more complicated?
03:03:22 <isaacd> but if it's supposed to add them, then it will be fine
03:03:46 <pesco> \ls -> [(a,b) | [a,b] <- map (map read . words) ls] is what I meant.
03:04:49 <pesco> But this is moot anyway.
03:06:15 <isaacd> > unlines . map show . (\ls -> [a + b | [a,b] <- map (map read . words) ls]) . lines $ " 1 3\n2 -5 \n3 4"
03:06:18 <lambdabot>  "4\n-3\n7\n"
03:06:44 <isaacd> a-ha, worked the first time!
03:10:58 <mauke> perl -pe 's/^>//||!/\S/||s/^/-- /'
03:16:25 <|Steve|> So if the line starts with >, remove it, otherwise if it contains nonspace characters, add haskell comments?
03:16:36 <|Steve|> remove > that is, not the whole line.
03:17:19 <|Steve|> No, that's not right.
03:17:50 <|Steve|> No, it was.
03:20:39 <|Steve|> It'd probably be less confusing as perl -pe 's/^>//or/\S/and$_="-- $_"'
03:20:55 <|Steve|> Heh, not that it worked.
03:21:22 <isaacd> I wish there was an easy-to-use evaluator for every language. For example, to test what some C code/operator is supposed to do exactly (so that I can consider whether to reproduce the behavior in a Haskell clone).
03:21:37 <|Steve|> perl -pe 's/^>// or/\S/ and$_="-- $_"' works though.
03:21:58 <|Steve|> isaacd: use gcc with standard input.
03:22:28 <isaacd> |Steve|: Does that run the result immediately?
03:22:50 <mauke> gcc doesn't run code at all
03:22:57 <isaacd> Well of course I could make a wrapper to do that even if it doesn't
03:23:04 <isaacd> mauke: I agree
03:23:11 <|Steve|> gcc -x c - <<< 'int puts(const char*);int main(){puts("Hello World!"); return 0;}' && ./a.out
03:23:24 <isaacd> yeah
03:25:19 <|Steve|> I agree that an interpreter would be nice.
03:26:28 <mauke> http://fabrice.bellard.free.fr/tcc/
03:26:30 <lambdabot> Title: "TCC : Tiny C Compiler"
03:26:51 <isaacd> mauke: unfortunately only for x86 currently (IIRC)
03:27:12 <|Steve|> Still pretty neat.
03:27:22 <|Steve|> Not that I own any x86 machines.
03:27:38 <isaacd> yes, that's why it's unfortunate -- that it's neat :)
03:27:46 <|Steve|> heh
03:27:57 <isaacd> I mean, because it's neat
03:28:09 <|Steve|> I knew what you meant.
03:28:18 <|Steve|> Which tells me that I'm sober enough to go to sleep.
03:30:17 <|Steve|> Which is starting to seem like an excellent idea given that I need to prepare my lecture for monday.
03:30:32 <|Steve|> I'm strongly considering being totally unprepared.
03:35:00 <isaacd> I wish I could output the executable on stdout and pipe it to something that executes it, so that I don't have to use a tempfile of any sort
03:42:10 <|Steve|> That's not going to work. The execve syscall requires a file path, it won't even work with a file handle.
03:48:47 <|Steve|> Goodnight all.
03:52:09 <isaacd> /dev/stdin is a filepath, albeit a strange one
04:01:06 <isaacd> aww, /dev/stdin doesn't have the necessary execute permissions
04:10:16 <isaacd> heh, I'm used to Haskell so I was typing "case x of" instead of "case x in" for a shell script
04:10:26 <isaacd> Luckily my syntax highlighter caught it for me
04:13:37 <bolrod> story of your life... ?
04:16:06 <Burne> Hello, linux forum at http://www.idpz.net/tomytom/forum_index.php
04:16:24 <dons> :/
04:17:04 <isaacd> Hello, linux forum named Burne.
04:21:20 <mlh> one of the ioccc entries had #include "/dev/tty"   :-)
04:24:48 * roconnor finishes his SHA-2 implementation
04:25:07 <roconnor> should I haddock only the exported functions?
04:29:03 <isaacd> roconnor: it can't hurt to haddock even non-exported functions, but it won't improve the user's documentation
04:29:50 <isaacd> It might help document the code though, for its developers
04:35:56 <dmhouse> Morning channel.
04:36:24 <kowey> howdy
04:36:35 <madpickle> hi
04:36:44 <dmhouse> kowey: Been spamming the Recent Changes list again? :)
04:36:50 <dmhouse> *Related Changes
04:36:54 <kowey> :-D
04:37:10 <kowey> there should be a "hide user _____ 's edits" feature
04:37:20 <dmhouse> Or 'Show all edits since my last one'.
04:37:39 <kowey> (inflated since most of it is the completed write yourself a Scheme in 48 hours import)
04:37:50 <dmhouse> Yep, I saw that.
04:37:55 <dmhouse> What are you going to do with it?
04:38:07 <kowey> no clue... for now, the entire tutorial is a subpage
04:38:14 <kowey> but i'm hoping we can cannibalise it
04:38:35 <kowey> for the main wikibook, maybe some key insights, text snippets, exercises to mine from that
04:40:52 <kowey> dmhouse: do you use the "Enhanced Recent Changes" feature? it's quite handy
04:41:11 <dmhouse> kowey: No?
04:41:34 <kowey> check it out in your preferences: if I make like 10 changes to the same page, 
04:41:44 <kowey> instead of listing each change seperately, it just says that I made 10 changes
04:42:30 <dmhouse> Ooh, cool.
04:46:05 <dmhouse> @localtime kowey
04:46:08 <lambdabot> Local time for kowey is Sun Jul  9 13:45:44 2006
04:46:23 <dmhouse> British?
04:46:45 <kowey> French summer time
04:47:07 <dmhouse> Hrm. Isn't French summer time UTC+2?
04:47:16 <dmhouse> (I assume their non-summer time is UTC.)
04:47:19 <dmhouse> *UTC+1
04:47:33 <kowey> hmm... i always get confused about that
04:47:45 <dmhouse> kowey: Well, what time is it where you are?
04:47:53 <kowey> i mean, it is 13:47, I hope
04:48:01 * kowey turns on his radio
04:48:03 <dmhouse> Perhaps your client doesn't know about summer time and so is erroneously responding to the CTCP time.
04:49:39 <madpickle> @localtime swansea
04:49:45 <madpickle> :(
04:49:47 <madpickle> @localtime cardiff
04:49:50 <madpickle> :(
04:49:55 <madpickle> @localtime london
04:49:58 <madpickle> :(
04:50:00 <madpickle> @localtime uk
04:50:05 <madpickle> aww, crud.
04:50:25 <dmhouse> It sends CTCP TIME to a specified nick.
04:50:29 <dmhouse> @localtime madpickle
04:50:30 <madpickle> oh
04:50:32 <lambdabot> Local time for madpickle is Sun Jul 09 12:50:08 2006
04:50:33 <madpickle> hahaha
04:50:38 <madpickle> i thought it looked it up on the net
04:52:53 <dmhouse> @timein London
04:53:01 <dmhouse> @help timein
04:53:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:53:08 <dmhouse> @help @timein
04:53:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:53:36 <dmhouse> @doesLambdabotStillSayNotACommand?
04:53:38 <lambdabot> Unknown command, try @list
04:53:43 <dmhouse> Yeah. So @timein exists.
04:54:01 <dmhouse> Must just 1) not work 2) not have any @help description.
04:54:13 <madpickle> that, or London is just a figment of everyone's imagination
04:55:17 <dmhouse> @timein london
04:55:24 <dmhouse> @timein washington
04:55:30 <madpickle> the state or D.C.?
04:55:32 <madpickle> =)
05:08:08 <dmhouse> kowey: Pingeroo
05:08:24 <kowey> dmhouse: Pongoala
05:09:33 <dmhouse> My types chapter isn't going to get very far if I can't talk about lists. (As that counts out things like Strings as well, and numeric literals like 5 have a complicated type: Num a => a).
05:09:39 <dmhouse> So. Want I want to do:
05:10:32 <dmhouse> Basically tear up the Lists chapter. Stick the introduction section "Lists, not Arrays" into an earlier introduction chapter. Move the rest to the top of List Processing.
05:11:06 <kowey> generally, i like the idea of introducing lists as early as conveniently possible
05:11:10 <dmhouse> If the reader knows about (:), [] and [1,2,3,4] syntactic sugar, that'll be enough. Maps and folds etc aren't necessary.
05:11:16 <dmhouse> Right, that's another advantag.
05:11:18 <kowey> and with as little extra baggage (recursion, folds, etc)
05:11:20 <dmhouse> *advantage.
05:11:35 <dmhouse> So we agree? Cool.
05:11:36 <kowey> but sans types? so just show the basic syntax, and don't worry about the types of lists?
05:11:43 <dmhouse> Yeah.
05:11:44 <kowey> i think it can be done... yeah
05:11:57 <dmhouse> Then I'll introduce what the types look like in my Type basics chapter.
05:11:59 * dmhouse goes to work
05:12:24 <kowey> in general, I tend to like hands-on approach better... don't motivate until you can maniplate, so I'm happy with this
05:12:31 <kowey> s/maniplate/manipulate/
05:12:34 <dmhouse> (In terms of ripping the chapters up, not going to my place of employment.)
05:14:41 <dmhouse> kowey: what are you planning to put in the 'Functions within functions' section?
05:14:52 <kowey> point out that you can call functions from other functions
05:14:57 <kowey> (like variables within variables)
05:15:13 <kowey> also allude to recursion, but not more, i don't think
05:15:24 <dmhouse> Oh, I see. Nothing like let and where clauses?
05:15:30 <kowey> heavens, no
05:15:36 <kowey> :-)
05:15:42 <dmhouse> Good. That's in a later module already.
05:16:16 <dmhouse> Right.
05:16:40 <dmhouse> Perhaps we also ought to move your section on Haskell Source Files to the new 'Next steps' module?
05:17:06 <dmhouse> The 'Variables and functions' module is getting a little unwieldly already, and that section doesn't really fit the title.
05:17:36 <kowey> i'm not sure what to do with it... i left it there, because the examples were fresh
05:17:52 <kowey> but it does seem to be a prereq for anything fancy
05:17:57 <dmhouse> Yeah. Well if we moved it it'd be at the top of the next module.
05:18:02 <kowey> actually... it _could_ go after the intro to lists
05:18:05 <kowey> so yeah, let's do it
05:18:43 <kowey> variables, functions and lists in ghci, then source files, then let's get serious?
05:19:00 <dmhouse> Sure. Sounds good.
05:20:17 <dmhouse> kowey: Right, done.
05:20:23 <dmhouse> http://en.wikibooks.org/wiki/Haskell/Next_steps
05:23:42 * kowey twiddles nav stuff
05:23:47 <dmhouse> Hehe.
05:23:56 <dmhouse> That really should be automated.
05:24:35 <kowey> well, i guess that's the thing with mediawiki: you gain collaborative goodness, but lose the automation of latex
05:25:07 <dmhouse> Perhaps we should just move everything over to a wiki.
05:25:12 <dmhouse> Err, repository.
05:25:30 <dmhouse> Stick a load of LaTeX files in a darcs repo. Although, that raises the barrier of entry.
05:25:38 <dmhouse> You don't get helpful little edits from people passing by.
05:25:49 <kowey> well... the low barrier to entry is essential, imo
05:26:03 <kowey> how many people got started in wikipedia by fixing typos?
05:26:35 <kowey> of course, would be most excellent, is a darcs-and-latex based wiki, written in Haskell
05:26:39 <dmhouse> An ideal solution would be to use MediaWiki style markup (perhaps pesco's work on a Markdown parser?), stick the files in a wiki, then add various goodness to the parser's HTML output.
05:27:00 <dmhouse> I've been thinking about this quite a bit, and I think the essence of a wiki is:
05:27:06 <dmhouse> 1) Some kind of document markup language
05:27:10 <dmhouse> 2) Versioning
05:27:12 <dmhouse> 3) Collaboration
05:27:19 <dmhouse> 4) Web front-end.
05:27:31 <pesco> Yay pesco's Markdown parser. ;-)
05:27:50 <pesco> cptchaos: Moin!
05:27:50 <dmhouse> Latex/Markdown etc covers 1, darcs covers 2 and 3, and HTML output from the parser covers 4.
05:28:09 <cptchaos> pesco: Moin!
05:28:32 <pesco> dmhouse: But you still need the web editing frontend.
05:28:35 <dmhouse> We'd likely also need someway of posting to the wiki from the web.
05:28:38 <dmhouse> Yeah.
05:28:59 <dmhouse> That would be the bulk of the written code.
05:29:39 <kowey> i guess the wikipedia experience is that massive parallelisation (many eyeballs and mice) makes up for lack of automation
05:29:46 <kowey> but that works less well when you have a niche wiki
05:29:52 <dmhouse> Yeah.
05:30:04 <kowey> cf the wiki spam problem
05:30:09 <dmhouse> Doing it ourselves would also allow us Haskell syntax highlighting :)
05:31:24 <dmhouse> kosmikus: ping.
05:38:44 * kowey forces himself to do laundry
05:40:46 <dmhouse> Quick! Someone give me an example of a pair of synonyms! (In the English, not Haskell, language).
05:41:45 <mauke> fast,quick?
05:41:48 <resiak> alive, not dead
05:41:55 * resiak hides a bit.
05:42:42 <dmhouse> mauke: Thanks.
06:27:03 <dons> ?yow
06:27:05 <lambdabot> FOOLED you!  Absorb EGO SHATTERING impulse rays, polyester poltroon!!
06:27:10 <dons> ?uptime
06:27:11 <lambdabot> uptime: 4 days, 15 hours, 13 minutes and 22 seconds
06:27:19 * dons -> sleep
07:02:15 <joelr1> howdy
07:06:17 <joelr1> does anyone have ghc running on mac intel?
07:06:59 <eivuokko> ghc wiki has page for it
07:08:13 <joelr1> i think i've been there
07:08:28 <joelr1> i actually have ghc on mac intel via wolfgang
07:08:53 <joelr1> the issue is that i'm trying to recompile ghc 6.5 using his ghc 6.5 and i get undefined module GHC.Dynamic
08:01:32 <mnislaih_> joelr1 any luck ?
08:01:41 <joelr1> mnislaih_: with?
08:01:53 <mnislaih_> ghc on mac intel
08:02:19 <joelr1> mnislaih_: i have wolfgang's package installed but it's a bit wierd. i'm gonna try the one by autrijus
08:04:13 <Igloo> It's waiting for someone with time to finish it off properly AIUI: http://www.haskell.org//pipermail/glasgow-haskell-users/2006-July/010444.html
08:04:15 <lambdabot> Title: "MacOS X / PowerPC"
08:05:16 <joelr1> Igloo: reading
08:05:30 <mnislaih_> I am postponing the purchase of a MacBook until ghc-6.5 builds on it
08:05:59 <joelr1> this is wierd
08:06:00 <mnislaih_> aint it hardcore? :)
08:06:13 <joelr1> i thought i'm on the haskell list and i somehow missed this post
08:06:45 <joelr1> wait, this is some 3d mailing list, right? apart from haskell and haskell-cafe
08:06:59 <eivuokko> There's plenty of haskell related mailing lists
08:07:08 <Igloo> 3d mailing list?
08:07:15 <Igloo> It's glasgow-haskell-users@haskell.org
08:07:17 <eivuokko> 3rd?
08:07:24 <Igloo> http://www.haskell.org/mailman/listinfo/glasgow-haskell-users
08:07:26 <lambdabot> Title: "Glasgow-haskell-users Info Page"
08:07:30 <Igloo> Ah, that makes more sense
08:07:37 <Igloo> http://haskell.org/mailman/listinfo for the full list
08:07:39 <lambdabot> Title: "haskell.org Mailing Lists"
08:08:06 <joelr1> cool
08:09:21 <joelr1> well, i've got a brand spanking new 17" mbp
08:09:34 <joelr1> and i'm trying to bootstrap 6.5
08:09:42 <joelr1> trying another install now
08:13:16 <joelr1> this is much better
08:13:28 <joelr1> the 1st package on the OSX Intel page, the one by autrijus
08:13:41 <augustss> joel, where can i find it?
08:13:42 <joelr1> trying to rebuild ghc 6.5 now
08:14:03 <joelr1> it's not really hiding :D http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
08:14:05 <lambdabot> Title: "X86OSXGhc - GHC - Trac"
08:15:06 <augustss> ah, found it
08:16:05 <ihope_> > let False = True in False
08:16:08 <lambdabot>  False
08:16:12 <ihope_> :-)
08:16:49 <vininim> > let True = False in True
08:16:51 <lambdabot>  True
08:17:05 <xerox> You are defining (=).
08:17:13 <ihope_> No, I'm not defining anything.
08:17:26 <ihope_> (=) isn't a valid operator, I'm sure...
08:17:32 <vininim> And I'm just mocking around with substitutions systems. =P
08:17:32 <eivuokko> It's just never-used pattern match.
08:17:38 <ihope_> Yep.
08:17:48 <ihope_> > let f ~False = 3 in f True
08:17:50 <lambdabot>  3
08:18:02 <ihope_> Same thing.
08:18:04 <xerox> Duh.
08:21:24 <joelr1> mnislaih_: so i think you can buy the macbook now
08:22:13 <mnislaih_> you managed to bootstrap a current ghc-6.5 from the darcs repo ?
08:23:21 <joelr1> mnislaih_: oh, not yet. but i've got a binary build that seems to be working. i'll let you know re: the bootstrap in a few minutes
08:24:12 <mnislaih_> oh, I was already dressing up to get to the local Apple store :)
08:24:47 <joelr1> i thought of using ocaml for my trading platform but they require you to become part of the ocaml consortium if you want to embed it in your own product
08:25:08 <mnislaih_> what is the ocaml consortium ?
08:25:41 <mnislaih_> or what are the implications of joining it ?
08:25:52 <joelr1> i also thought of using ruby and generating c code when everything is sound but ... i could not come up with a way to do combinators in ruby
08:25:55 <joelr1> no decent way
08:26:17 <joelr1> mnislaih_: you pay 2-10k euro and get a license to sell commercial products that embed ocaml
08:26:40 <mnislaih_> :O
08:27:08 <mnislaih_> when you say embed, does it imply any special usage of the ocaml technology?
08:27:30 <joelr1> mnislaih_: yes, it means having a built-in ocaml compiler
08:36:31 <augustss> it works!
08:37:13 <mnislaih_> augustss: you mean, the binary
08:37:22 <joelr1> augustss: of course it does! but the ultimate test is bootstrapping ghc with that binary
08:37:28 <joelr1> augustss: which is what i'm doing now
08:37:45 <augustss> and it's what i'm going to do next :)
08:37:49 <joelr1> he
08:37:59 <joelr1> building ghc is soooo slooooooow
08:38:18 <joelr1> i was hoping that a 2ghz 2-core mbp and a 7200rpm drive would help but alas
08:38:44 <augustss> my drive is only 5400rpm
08:38:57 <augustss> cheap macbook :)
08:39:04 <augustss> got it yesterday
08:39:09 <joelr1> i wonder if -a10m would help
08:39:43 <mnislaih_> what irc client are you using joelr1 ?
08:39:45 <joelr1> i had my employer buy me the mbp in the us and ship it to tenerife. i think i saved at least 1k euro. of course they also paid for applecare and shipment
08:39:52 <joelr1> colloquy
08:40:06 <Igloo> joelr1: Have you got a reference for the need to join the consortium?
08:40:15 <joelr1> Igloo: sec
08:40:19 <Igloo> joelr1: ocaml is in Debian main, and that doesn't sound Free
08:40:47 <joelr1> Igloo: it's on the lexifi q&a pages
08:41:09 <joelr1> Igloo: the deal is that ocaml itself IS free but if you want to embed the interpreter/compiler than it's not
08:41:14 <joelr1> Igloo: apparently
08:41:26 <Igloo> That doesn't sound Free to me
08:41:27 <joelr1> Igloo: or to be more precise, if you want to embed and THEN sell the app
08:41:48 <Igloo> What is Lexifi?
08:41:53 <joelr1> Igloo: it's free for open source projects even if you embed, that's my understanding
08:41:56 <joelr1> Igloo: let me look it up
08:42:06 <kuribas> joelr1: I have implemented Monads in Ruby.
08:42:20 <joelr1> http://www.lexifi.com/faq.html
08:42:22 <lambdabot> Title: "LexiFi: Financial Products Language FAQ"
08:42:29 <joelr1> kuribas: cool! and?
08:42:38 <kuribas> joelr1: But it's a ugly hack and uses continuations.
08:42:51 <kuribas> joelr1: since you where mentioning combinators in Ruby
08:43:10 <joelr1> Igloo: http://www.lexifi.com/faq.html#camllicense
08:43:11 <lambdabot> Title: "LexiFi: Financial Products Language FAQ"
08:43:25 <Igloo> Oh, I see, you aren't saying that lexifi are the ones making the restrictions, just that they say they are complying with them
08:43:27 <joelr1> kuribas: ah, ok
08:43:37 <joelr1> Igloo: right
08:44:14 <Igloo> But it doesn't actually say they couldn't do what they do without being a member and having the alternative licence
08:45:31 <joelr1> Igloo: read the license that they are referring to
08:46:11 <joelr1> Igloo: http://caml.inria.fr/consortium/ link on this page
08:46:32 <augustss> any compiler taking more than 1/2 hour to recompile itself is sub-standard :)
08:46:54 <augustss> either too big or too slow
08:47:03 <joelr1> augustss: ocaml is darn frigging fast when compiling itself
08:47:11 <augustss> i know
08:47:19 <augustss> it's a joy to compile
08:47:42 <Igloo> joelr1: Reading the licence you don't have isn't relevant. You need to read the licence you /do/ have.
08:47:42 <augustss> and it bootstraps via bytecode
08:48:00 <joelr1> hehe
08:48:07 <joelr1> the glossy screen is nice even outside in the sun
08:48:18 <joelr1> hot tenerife sun
08:49:04 <joelr1> i'm using the mbp on a iLap stand, though
08:49:07 <mnislaih_> arent you afraid of toasting the mbp ?
08:49:13 <joelr1> the thing is too darn hot to handle
08:49:16 <joelr1> by itself
08:49:40 <joelr1> mnislaih_: hmm... well, i'm sort of almost in the shade
08:50:01 <mnislaih_> here in Valencia it's pretty hot too
08:50:05 <joelr1> mnislaih_: dunno, haven't thought of it. hopefully iLap provides the airflow
08:50:32 <mnislaih_> I wouldnt put my poor old thinkpad under this soon,
08:50:35 <augustss> well, here in NY we have AC :)
08:50:37 <mnislaih_> sun*
08:50:38 <joelr1> kuribas: the thing that i couldn't figure out with ruby is how to do combinators like when
08:50:50 <joelr1> augustss: no airconditioning for me :)
08:51:09 <joelr1> this is too hot, i better go inside
08:51:23 <augustss> joel, what build.mk options are you using?
08:51:39 <joelr1> augustss: beats me, i haven't bothered looking, why?
08:51:53 <kuribas> joelr1: did you finish that sentence?
08:51:59 <augustss> ummm, don't you have to copy a file to even get started?
08:52:08 * joelr1 highly recommends iLap from Rain Design
08:52:17 <joelr1> kuribas: yes :) "when" is a combinator
08:52:32 <joelr1> augustss: nope. grab ghc from darcs. ./configure && make
08:52:49 <augustss> ok, I did.  and now it says I don't have happy
08:53:02 <joelr1> http://www.raindesigninc.com/ilap.html
08:53:04 <lambdabot> Title: "iLap Laptop Stand - intro"
08:53:14 <joelr1> augustss: right. gotta have happy and alex
08:56:00 <joelr1> kuribas: take a look at the composing financial contracts paper. i was thinking of doing the same in ruby
08:57:57 <kuribas> Only 13 pages :-)
08:58:23 <joelr1> mnislaih_: what do you do with haskell?
08:58:29 <joelr1> kuribas: yes, an easy read
08:58:45 <mnislaih_> http://haskell.org/haskellwiki/Ghci/Debugger
08:58:46 <lambdabot> Title: "Ghci/Debugger - HaskellWiki"
08:59:01 <mnislaih_> I am working on a SoC project
08:59:50 <joelr1> mnislaih_: oh, cool! do you think you are gonna finish by august?
09:00:13 <mnislaih_> I certainly hope so, or at least a first release
09:01:13 <joelr1> mnislaih_: super-cool
09:01:18 <mnislaih_> thanks :)
09:01:37 <mnislaih_> but most credit is for Lemmih and Simon Marlow anyway
09:02:36 <joelr1> kuribas: did you get the gist of it?
09:04:59 <augustss> mnislaih: if you're not finished and would want to continue working on this, I can probably find someone willing to pay
09:05:48 <joelr1> augustss: what do you do with haskell?
09:06:12 <mnislaih_> getting paid for working with Haskell, that's a sweet thing.
09:06:26 <joelr1> i wonder who got the haskell support job
09:06:29 <joelr1> anybody knows?
09:06:53 <augustss> I work for Credit Suisse, the investment bank.  And I get paid for doing Haskell. :)
09:07:14 <joelr1> oh, is your name lennart?
09:07:33 <augustss> yep
09:07:40 * joelr1 never worked at CS 
09:07:54 <joelr1> i did work at bear, morgan, ubs and merrill, though :D
09:07:59 <joelr1> mostly consulting
09:08:11 <augustss> i'm consulting too
09:08:23 <joelr1> augustss: through one of the body shops i assume?
09:08:35 <joelr1> augustss: how come not full-time?
09:08:43 <augustss> no, straight from CS
09:09:04 <joelr1> augustss: i don't get it. you are consulting straight from cs? how is that?
09:09:10 <augustss> it's full time.  the reason i'm a consultant is that they could pay me better that way
09:09:22 <joelr1> ah! straight with cs you mean, through your own company?
09:09:34 <augustss> yes
09:09:36 <joelr1> the wierd ways of wall st. /pay/
09:10:01 <augustss> well, it took 2 months before they payd anything :)
09:10:03 <joelr1> augustss: that's how i did the 2nd half of my time at bear. i left and came back as a consultant through my own co.
09:10:11 <joelr1> augustss: yeah, i know the pain
09:10:33 <joelr1> augustss: what are you doing with haskell? modeling risk or something like that?
09:11:43 <joelr1> augustss: also, is heavy numeric performance required?
09:11:48 <augustss> i'm doing very general things at the moment.  trying to convince them to use haskell more ;)
09:12:15 <augustss> heavy numeric stuff that is performance critical is all written in c++
09:12:50 <augustss> ok, my ghc recompile died the same way as on my netbsd box :(
09:13:02 <joelr1> augustss: i'm still going strong
09:13:15 <augustss> panic in iselExpr64
09:13:33 <augustss> are you using today's tree?
09:13:39 <mnislaih_> oh, I believe that panic is not related to Mac Intel issues
09:13:40 <joelr1> augustss: why would cs want to do general stuff with haskell? are you attached to a business unit with a very open-minded head?
09:13:57 <mnislaih_> I've been seeing that panic since a few days ago in my box
09:13:57 <joelr1> augustss: i think it's todays tree. i updated last night
09:14:11 <augustss> i'm in the R&D using of the global modelling group
09:14:21 <augustss> yes, they are openminded :)
09:14:36 <joelr1> augustss: so they hired you and then you pushed haskell for general things?
09:14:56 * joelr1 starts harboring plans of wall st. domination... with haskell
09:15:00 <augustss> mnislaih: any idea how to get around it?
09:15:15 <mnislaih_> no, sorry. I just resorted to unpulling some patches
09:15:17 <augustss> they hired two haskell people
09:15:20 <joelr1> haskell in program trading... yummy!
09:15:34 <joelr1> augustss: for the express purpose of trying haskell? :-)
09:15:44 <augustss> me and Gabrielle Keller
09:16:12 <augustss> for the express purpose of trying new things, especially FP
09:16:12 <shemale_magi1> hm
09:16:14 <joelr1> is gabrielle a female name? 
09:16:25 <secret-orb> hi
09:16:26 <joelr1> augustss: wow! what luck! 
09:16:31 <augustss> yes.  she's Manual Chakravarty's wife
09:16:56 <joelr1> augustss: hmm... i thought M.C. was in australia, did she move to wall st. as well?
09:17:09 <augustss> the job ad was posted by spj on the haskell mailing list a year ago
09:17:13 <joelr1> err, he move, sorry 
09:17:16 <secret-orb> so hey how can I make data processing jobs work in parallell using haskell so that they run really fast?
09:17:27 <augustss> yes, they both libe here in NYC this year
09:17:39 <joelr1> augustss: cool! 
09:18:17 <joelr1> augustss: i'm looking to start small, i just want a mac-only trading platform
09:18:31 <augustss> mnislaih: do you know how far to revert?
09:18:53 <Korollary> secret-orb: did you see the paper titled "Composable Memory Transactions"?
09:19:53 <mnislaih_> augustss: I would guess - say around a week
09:20:01 <mnislaih_> 10 days if you want to make sure
09:20:09 <joelr1> how come i don't see the issue that augustss is seeing?
09:20:29 <mnislaih_> But afaik, there is some patch pushed recently fixing some issues in darwin
09:20:36 * joelr1 doesn't know why he wants a mac-only trading platform
09:20:37 <mnislaih_> which you probably don't want to revert
09:21:28 <mnislaih_> joelr1: dunno. I don't really know the cause or the problem
09:21:39 <augustss> i tried adding the missing case to the code generator, but then it died somewhere else :(
09:22:24 <joelr1> augustss: are you rebuilding ghc or just trying out the binary version?
09:22:57 <augustss> rebuilding
09:23:25 <augustss> the rebuilt binary dies when compiling PrimOps.cmm
09:23:34 <joelr1> hmm
09:23:56 <joelr1> my laptop is quite fast and you started rebuilding after me so i assume i'm past that issue
09:24:11 <mnislaih_> augustss: that is the same issue I am talking about
09:24:19 <joelr1> i have the latest mac osx if that matters. 10.4.7
09:25:26 <joelr1> i just finished building parsec and am building haskell libraries now
09:26:13 <mnislaih_> btw, does the ocaml compiler build include building all the libraries ?
09:26:24 <Korollary> I think so
09:26:50 <joelr1> my mbp is 75-83C how
09:26:51 <joelr1> hot
09:27:06 <joelr1> according to CoreDuoTemp
09:27:18 <joelr1> building haskell surely makes it work
09:27:56 <kuribas> joelr1: So far I see no reason why it shouldn't be possible in Ruby, but why would you choose Ruby over Haskell?
09:28:03 <joelr1> one other strike against ocaml is that it wouldn't let me use both processors unless i did something special
09:28:33 <joelr1> kuribas: how would you do it in ruby? i would choose it because it's warm and fuzzy i guess. for popularity.
09:29:03 <joelr1> kuribas: how would you do the "when" combinator, for example? or the between? what would the syntax look like? 
09:29:41 <joelr1> kuribas: i think you would need to use lots of blocks and parens and you couldn't use the infix syntax
09:30:09 <joelr1> kuribas: or even then simple "and" combinator. and is a reserved word
09:30:23 <kuribas> joelr1: perhaps you could use methods for the combinators
09:30:41 <kuribas> "c1.and c2" for example
09:30:42 <joelr1> augustss: how many years of haskell experience do you have? i think you've been using it at least since '99, right?
09:30:53 <joelr1> kuribas: hmm...
09:31:01 <joelr1> kuribas: let me try something real quick...
09:31:07 <joelr1> kuribas: try that i mean
09:31:34 <mnislaih_> joelr1 long long before '99, I think
09:31:39 <kuribas> joelr1: I'll try something when I finished the paper
09:32:42 <ChilliX> augustss: Hi!
09:32:49 <ChilliX> You doing Mac now?
09:32:51 <joelr1> kuribas: this is da bomb! of course it works! i can define if and and methods on a class
09:33:38 * joelr1 is rewiring his brain from haskell-style combinators to ruby
09:34:34 <joelr1> kuribas: i suppose you could indeed define all the methods on the contract object.. the syntax could end up just a tad wierd... maybe... you would need to remember to use the dot but it's not a big price to pay
09:36:05 <kuribas> joelr1: I think not.  And you can use blocks for higher order functions.
09:36:22 <joelr1> kuribas: oh, then you need to use comma to separate the arguments... 
09:36:38 <joelr1> kuribas: you think not what?
09:37:42 <joelr1> kuribas: haskell makes it easy to deconstruct the constructors but with ruby you could use reflection
09:39:55 * dmhouse yawns
09:40:05 <dmhouse> You know what, like _all_ the water's fizzy in Germany.
09:40:05 <mnislaih_> joelr1: I thought ruby could do parens-less method invocation. That would be comma-less too
09:41:12 <joelr1> hmm
09:41:20 <kuribas> joelr1: I think it's not a big price, like you say.  If you have more than one argument I would use parens thought.
09:42:06 <joelr1> mnislaih_: don't think you can do comma-less
09:42:42 <joelr1> kuribas: well, the syntax with haskell is far nicer
09:44:07 <kuribas> yeah, I think so too.
09:46:43 <kuribas> One of the reasons I don't use Ruby so often is that it doesn't favor a functional programming style.
09:48:16 <joelr1> kuribas: yeah, you can do certain things with blocks but nowhere near close to haskell
09:49:26 <binary42> would there be interest in a haskell-ruby bridge?
09:49:50 <binary42> I've toyed with doing that a number of times... maybe even Inline::Haskell for ruby.
09:50:40 <augustss> ChilliX: yes, I bought a MacBook yesterday :)
09:52:00 <ChilliX> Don't remember whether he mentioned it, but Bob also had just bought one of the high-end x86 ones when he visited last weekend
09:52:05 <augustss> So why can the ghc darcs repository be compiled?  don't people test before they check things in?
09:52:05 <joelr1> augustss: black? :D
09:52:17 <joelr1> augustss: my build is still chugging along
09:52:30 <augustss> white.  i prefer black, but it's not worth the extra $150
09:53:01 <augustss> i bought a low end macbook :)
09:53:09 <ChilliX> augustss: usually, it can.  Did you darcs get from scratch or pull into an existing tree?
09:53:15 <augustss> it's still 2gHz dual core
09:53:39 <Igloo> ghc darcs from earlier this weekend works for me, and I don't think there have been any commits since
09:53:43 <augustss> i did 'darcs get' from what i thought was the official source tree
09:53:52 <joelr1> augustss: cool! no, hot would be proper :D
09:54:12 <Igloo> augustss: Did you follow the checkout instructions?
09:54:20 <augustss> to the letter
09:54:22 * joelr1 suddenly has all sorts of rogue ghc source tree visions
09:54:31 <augustss> (copy&patse)
09:54:56 <Igloo> What went wrong, then?
09:54:56 <joelr1> imagine a troyan attack after spoofing www.haskell.org :D
09:55:06 <augustss> And I've tried it on NetBSD and MacOS X
09:55:21 <joelr1> build our troyan into your ghc!
09:55:47 <joelr1> sheer sophistication! 
09:55:51 <augustss> It dies when compiling PrimOps.cmm because it contains a negation of a 64 bit number and the code generator can't handle that
09:56:37 <joelr1> augustss: i'll do another pull, just in case. right after this build finishes
09:57:07 <augustss> i'm doing the 'devel' build, but i don't see why that should matter
09:57:21 <Igloo> augustss: OK, I'm not sure if anyone is doing nightly *BSD builds at the moment
09:57:29 <ChilliX> augustss: dies in stage1 or stage2?
09:57:43 <Igloo> I'm not sure if anyone uses the 'devel' build regularly either
09:58:05 <augustss> dies in stage1, I'm pretty sure
09:58:25 <ChilliX> ah, then what's the compiler you compile with?
09:58:40 <joelr1> what's a devel build?
09:58:54 <augustss> on NetBSD it was 6.4.2, on MacOS it was Audery's 6.5.  I got the exact same error.
09:58:55 <Lemmih> ChilliX: Hello. You have completed your mid-term evaluation, right?
09:59:24 <ChilliX> Lemmih: yes - didn't tell you specifically, because I saw that dons told you here in irc
09:59:28 <augustss> joelr: I set BuildFlavour=devel in mk/build.mk to make it build faster
09:59:53 <joelr1> ah! i didn't do that. how does it make the build faster?
10:00:16 <augustss> doesn't build for profiling etc, doesn't optimize as much
10:00:23 <Lemmih> ChilliX: Ok, just wanted to be sure.
10:00:39 <joelr1> augustss: ok
10:01:14 <mnislaih_> Lemmih entor, did you see my privs ?
10:01:16 <joelr1> augustss: wanna try the regular build?
10:01:45 <joelr1> mnislaih_: sounds kinky
10:02:26 <mnislaih_> err.. you mean ?
10:02:35 <joelr1> i'm still building opengl. i should have caught some zzzzs while this is building, darn
10:02:50 <joelr1> mnislaih_: never mind me silly self. too little sleep today
10:02:50 <mnislaih_> I can't help it, english ...
10:03:07 <Lemmih> mnislaih_: Yes, it sounds good.
10:03:50 <joelr1> i knew a girl once who was writing an essay with a dictionary and wrote something along the lines of "i like human intercourse"
10:03:55 <mnislaih_> Lemmih: One of these days you are going to do a code review, and I dont want you yelling at me ...
10:03:57 <joelr1> her native language wasn't english
10:04:38 <mnislaih_> I wonder how is your spanish joelr1 :P
10:04:45 <joelr1> mnislaih_: my cuban you mean :D
10:05:10 <joelr1> mnislaih_: my spanish is very cuban, thank you 
10:05:24 <augustss> i'll try a regular build when my hacked build has finished
10:05:33 <joelr1> mnislaih_: the spoken one is fine but the written is somewhat poor
10:06:51 <mnislaih_> actually I didn't expect you to know spanish, or cuban for that matter,
10:07:04 <joelr1> mnislaih_: yeah, i know :D
10:07:07 <mnislaih_> so its a nice surprise
10:07:36 <joelr1> mnislaih_: only the british live in tenerife... well, germans too. and no offense to either!
10:08:28 <joelr1> barely any programmers or programming jobs regardless
10:09:14 <joelr1> now that ghc has ghc as a library i'll just embed it and load things in hs-plugins-style
10:09:53 <joelr1> the real challenge is probably to try to write the whole trading app in haskell (cocoa callbacks included) while resorting to as little objc as possible
10:10:31 <joelr1> although it's likely much easier to call haskell from objc callbacks
10:11:09 <mnislaih_> joelr1: you should look at InteractiveUI.hs, the code for ghci, for a helpful ghc-api example
10:11:30 <joelr1> mnislaih_: thanks, i'll make a mental note!
10:12:40 <joelr1> the hardest thing is to figure out who i'm targeting this at. but i'll just release and see who bites. the good thing is that there aren't many such apps on the mac
10:13:30 <augustss> joelr: do you have any customers in mind?
10:15:51 <joelr1> augustss: well, i can't compete in the real-time trading space since all the drivers are on windows
10:16:10 <joelr1> augustss: so i have to do research, modelling, visualization
10:16:25 <joelr1> augustss: and any customers need to have macs
10:17:59 <joelr1> so i guess it would be advanced traders who care about heavy-duty optimization and visualization. and easy modelling.
10:18:28 <augustss> i was just thinking of how things are at CS.  they are so deeply entrenched in how they do things now that it's very hard to change.  any change will have to fit seamlessly into what they already do
10:18:52 <joelr1> where visualization is a strength of the mac, haskell laziness and smp should help with optimization and combinators would cover modelling
10:19:36 <joelr1> augustss: i'm not looking to sell to institutions. god forbid! can you elaborate on the entrenched ways, though?
10:19:46 <joelr1> i think i'll try to go after advanced traders
10:20:14 <augustss> different banks are entrenched in different places.  at CS it's all Excel based
10:20:21 <joelr1> i was trying to push a real-time trading platform based on erlang a while ago and the funny thing i discovered is all the cool kids are doing end-of-day trading
10:20:37 <joelr1> cool being serious about making money
10:21:13 <joelr1> augustss: i don't see how i can seamlessly merge haskell with excel 
10:21:13 <augustss> but they realize that Excel is a terrible, terrible vehicle for program development
10:21:31 <joelr1> augustss: on the other hand, i could compile to excel :D
10:21:47 <augustss> i've made some pretty seamless excel integrations :)
10:21:54 <augustss> with haskell
10:21:55 <joelr1> augustss: in what way?
10:22:16 <joelr1> augustss: what i mean is how do you split responsibility? excel does visualization?
10:22:34 <augustss> you can write Excel addins in Haskell.  You can call Excel addins from Haskell (they are all written in C++ and 95% of them are pure)
10:22:50 <augustss> You can generate Excel from high level Haskell specifications.
10:23:17 <joelr1> augustss: the part i'm having conceptual trouble with is using combinators for trading as opposed to modeling contracts
10:23:47 <joelr1> because trading involves lots of if-then-else decisions
10:24:06 <joelr1> it's rule-based 
10:24:10 <augustss> so one of Haskell's strengths when it comes to Excel integration is it's lack of side effects
10:24:21 <joelr1> augustss: interesting /excel/
10:25:20 <joelr1> but i like the stream processing model: you take quotes on the input stream and emit buy/sell/stop signals
10:25:55 <joelr1> that is feed them into the output stream
10:26:03 <joelr1> my ghc just finished building
10:26:07 <joelr1> testing time
10:27:22 <augustss> my hacked ghc is doing it's stage2 build, so it's looking promising
10:28:11 * mnislaih_ wants to know when ghc-6.5 demonstrates to build in the mac intels
10:28:17 <joelr1> actually, yampa is just the model for trading
10:28:35 <joelr1> mnislaih_: i just built it
10:28:59 <mnislaih_> dd you try it already? Great news
10:30:17 <joelr1> mnislaih_: i'm running regression tests 
10:30:34 <joelr1> mnislaih_: but the mere fact that ghc built on mac intel was able to compile ghc on mac intel is promising
10:31:07 * mnislaih_ gets ready to purchase a macbook tomorrow early
10:31:55 <Taral> @pl \f x -> f x
10:31:56 <lambdabot> id
10:31:59 <Taral> ???
10:32:27 <augustss> @pl let x = 3 in x
10:32:27 <lambdabot> 3
10:33:51 <joelr1> mnislaih_: you guys on the mainland have it easy :D
10:33:52 <augustss> grrr, my compilation died
10:34:01 <joelr1> augustss: again? where now?
10:34:02 <waern> joelr1, I know a guy doing trading with arrows 
10:34:30 <joelr1> waern: you do? tell me more! please!
10:34:38 <ChilliX> augustss: Did you say what compiler you are using to build stage1?
10:34:44 <waern> joelr1, his name is Johan Tavelin, try google
10:34:54 <augustss> i told it not to build the threaded RTS (because that panics).  And no it complains it can't find HSrts_thr
10:35:13 <joelr1> augustss: ouch
10:35:27 <augustss> ChilliX: I used 6.4.2 on NetBSD, and 6.5 from Audray Tang on MacOS.
10:35:29 <joelr1> waern: let me see... 
10:35:52 <ChilliX> augustss: And both failed in the same way?
10:35:55 <augustss> yes
10:36:22 <joelr1> waern: googling does not give me much
10:37:23 <waern> I don't think he has released anything publically 
10:37:36 <joelr1> waern: unless you are talking about antropomorphic AI
10:38:09 <joelr1> waern: what does he trade?
10:38:13 <waern> but you may try email.. d00jota at dtek.chalmers.se
10:38:35 <waern> joelr1, stock I think
10:38:51 <augustss> bah, stage2 is linked threaded.  I guess I need the threaded rts
10:39:00 <augustss> which panics the compiler
10:39:13 <Lemmih> @join #ypn
10:39:15 <lambdabot> Not enough privileges
10:39:23 <joelr1> waern: emailing
10:39:43 <mnislaih_> augustss make sure you pull the latest patches. Maybe the fix has been pushed, I haven't updated in some time
10:41:25 <augustss> I have the latest version
10:41:37 <joelr1> i think i'm stuck on the arr012(opt) test
10:41:51 <roconnor> @type \a b c d -> foldr id a (zipWith b c d)
10:41:56 <lambdabot> forall b a b1. b -> (a -> b1 -> b -> b) -> [a] -> [b1] -> b
10:42:44 <roconnor> @type \a b c d -> foldr (flip (.)) id (zipWith b c d) a
10:42:45 <lambdabot> forall b a b1. b -> (a -> b1 -> b -> b) -> [a] -> [b1] -> b
10:42:59 <Taral> hi roconnor :P
10:43:17 <Taral> My function-fu is stronger than yours! :)
10:43:20 <roconnor> What I don't get is that (flip (.)) is lazy in it's second argument (I think)
10:43:28 <Taral> id is lazy in everything.
10:43:34 <Taral> (well, not really)
10:43:35 <roconnor> but id isn't lazy in it's second argument.
10:43:43 <Taral> id doesn't have a second argument
10:43:48 <roconnor> yes it does
10:43:51 <Taral> Look at it this way:
10:43:52 <xerox> ?type flip id
10:43:54 <lambdabot> forall b c. b -> (b -> c) -> c
10:43:56 <xerox> (:
10:44:00 <roconnor> yes
10:44:09 <Taral> foldr (\f x -> f x) ...
10:44:13 <roconnor> but you didn't use flip id
10:44:17 <Taral> that function is lazy in its second argument
10:44:58 <roconnor> I was about to say, it won't evaluate f until x is evaluated, but that is just false.
10:45:03 <Taral> :)
10:45:08 <roconnor> In haskell f will be evaluated before x.
10:45:16 <roconnor> I guess
10:45:19 <Taral> yup
10:45:28 <Taral> I was going for this:
10:45:30 <roconnor> How did you think of that
10:45:34 <Taral> you have [f1 f2 f3 ...] and h
10:45:43 <Taral> you want f1 (f2 (f3 (... h)))
10:45:47 <Taral> this is exactly what foldr does
10:45:53 <roconnor> no that's not what I want
10:45:57 <Taral> no?
10:46:02 <roconnor> I want .. (f3 (f2 (f1 h)))
10:46:06 <Taral> hm
10:46:15 <Taral> ok...
10:46:21 <roconnor> I thought I would see it in the types
10:46:34 <Taral> foldl (flip id) h ...
10:46:40 <roconnor> Taral: what you wrote is what I wrote first time;
10:46:42 <xerox> > foldl (.) id [(+1),(*2)] 1
10:46:45 <lambdabot>  3
10:47:04 <Taral> ha xerox and I have the same idea
10:47:04 <xerox> > foldr (.) id [(+1),(*2)] 1
10:47:06 <lambdabot>  3
10:47:15 <roconnor> @type @type \a b c d -> foldr id a (zipWith b c d)
10:47:16 <lambdabot> parse error on input `@'
10:47:18 <xerox> > foldr (.) id [(+2),(*2)] 1
10:47:18 <Taral> > foldl (flip id) 1 [(+1),(*2)]
10:47:20 <lambdabot>  4
10:47:21 <lambdabot>  4
10:47:21 <roconnor> @type \a b c d -> foldr id a (zipWith b c d)
10:47:23 <lambdabot> forall b a b1. b -> (a -> b1 -> b -> b) -> [a] -> [b1] -> b
10:47:26 <Taral> mine works!
10:47:30 <roconnor> @type \a b c d -> foldr (flip id) a (zipWith b c d)
10:47:32 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
10:47:32 <lambdabot>    Expected type: (a -> t) -> a -> a -> t
10:47:49 <Taral> @type \a b c d -> foldl (flip id) a (zipWith b c d)
10:47:51 <lambdabot> forall c a b. c -> (a -> b -> c -> c) -> [a] -> [b] -> c
10:48:08 <roconnor> I'm not sure how I feel about foldl
10:48:25 <Taral> well, you can use foldl, or foldl' if you want to avoid big closures
10:48:40 <roconnor> but I've got a foldr now.
10:48:44 <xerox> > (foldl (.) id [(+2),(*3)] &&& foldr (.) id [(+2),(*3)]) 2
10:48:45 <Taral> you're not any better off with foldr (flip (.)), since the intermediary functions are just as big
10:48:46 <lambdabot>  (8,8)
10:49:00 <bolrod> (0,0)
10:49:02 <roconnor> yeah, I have a hard type picturing my memory usage.
10:49:02 <Taral> @type (&&&)
10:49:05 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:49:33 <roconnor> But concat is implemented with foldr
10:49:36 <Taral> @pl \x f -> f x
10:49:37 <lambdabot> flip id
10:49:54 <roconnor> and that's fine because (++) is lazy in it's second argument
10:50:14 <roconnor> and (I think) (flip (.)) is also lazy in it's second argument
10:50:22 <roconnor> so isn't foldr (flip (.)) all good?
10:50:46 <Taral> hm
10:51:01 <Taral> (.) is not lazy at all
10:51:05 <Taral> so flip (.) will not be lazy
10:51:13 <roconnor> (.) isn't lazy at all?
10:51:19 <Taral> no
10:51:19 <bolrod> xerox: how are the google projects going?
10:51:22 <Taral> you need those functions
10:51:41 <Taral> if I give you (f . _) x, can you give me any part of the result?
10:51:47 <Taral> no, you *need* g
10:51:49 <Cale> > (const 5 . undefined) 7
10:51:51 <lambdabot>  5
10:51:55 <Taral> !!
10:52:04 <Taral> bah, ok
10:52:09 <roconnor> what about (_ . g) x?
10:52:17 <Taral> Cale is right
10:52:28 <Taral> (f . g) x == f (g x), so if f is lazy, so is (f.)
10:52:31 <roconnor> hence my concern about using foldl.
10:52:38 <Cale> Well, obviously if f is undefined, then f (g x) is as well.
10:53:05 <Cale> But g can be undefined if f doesn't care about its parameter
10:53:24 <roconnor> Um, so what is the conclusion?
10:53:32 <int-e> So (.) is strict in its first argument.
10:53:40 <roconnor> crap
10:53:44 <Cale> I missed the first part of the conversation
10:53:47 <Cale> what are you doing?
10:53:52 <Taral> roconnor: you want this function:
10:53:55 <Taral> appList [] h = h
10:53:55 <Taral> appList (f:fs) h = appList fs (f h)
10:53:58 <Taral> it looks just like foldl
10:53:58 <roconnor> foldr (flip (.)) id
10:54:13 <roconnor> vs foldl (flip id)
10:54:24 <Taral> (flip (.)) is strict in its second argument since (.) is strict in its first
10:54:25 <Taral> there we go!
10:54:52 <Taral> foldl (flip id) has the advantage that you're not trying to build the composition of the functions, you're just passing through the value
10:54:59 <Taral> note the positioning of h:
10:55:06 <Taral> foldr (flip (.)) flist h
10:55:15 <roconnor> so I should use foldl' (flip id) h?
10:55:15 <Taral> foldl (flip id) h flist
10:55:34 <Taral> I'm guessing so.
10:55:41 <Taral> Or you could use foldr (.) $ reverse
10:55:45 <roconnor> presumably I want to use foldl'.  I'm told you never want to use foldl
10:55:49 <Taral> (etc. etc.)
10:55:58 <Taral> yes, in general you want to use foldl' to avoid building the big closures
10:55:58 <roconnor> reverse doesn't sound fast at all.
10:56:09 <Cale> Almost never, anyway.
10:56:18 <roconnor> I would never have thought of using foldl (flip id)
10:56:34 <Taral> roconnor: why not change the function list builder to return the functions in the other order?
10:56:53 <Taral> roconnor: I was trying to avoid the use of (.) by using h as the accumulator instead of id
10:57:01 <Taral> everything followed from that
10:57:27 <roconnor> ws = m++zipWith4 smallSigma (drop (blockSize-2) ws) (drop (blockSize-7) ws)
10:57:27 <roconnor>                               (drop (blockSize-15) ws) (drop (blockSize-16) ws)
10:57:28 <Taral> Also, you want to use foldl if any of your functions in the list are non-strict
10:57:39 <roconnor> that makes ws hard to reverse ;)
10:57:43 <int-e> > foldl1' (flip const) [3, undefined, 2, 1]
10:57:45 <lambdabot>  Undefined
10:57:47 <int-e> > foldl1 (flip const) [3, undefined, 2, 1]
10:57:49 <lambdabot>  1
10:57:55 <int-e> yay for contrived examples.
10:57:59 <Taral> thanks int-e
10:58:05 <roconnor> good example
10:59:15 * roconnor makes Taral's patch
10:59:18 <Taral> roconnor: I'm assuming blockSize is 16 or 17?
10:59:48 <roconnor> 16
11:00:03 <roconnor> So this is really academic
11:00:08 <Taral> Yeah. :P
11:00:17 <roconnor> but it will be useful when I have the same problem with longer lists
11:00:19 <Taral> Anyway, yes, there's no easy way to reverse ws in construction
11:00:56 <Taral> if you're going to want that value anyway, and all of the functions are strict anyway, foldl' is very efficient.
11:01:48 <Taral> of course, given how short the explicit version is (appList, above), you might just want to use that for clarity
11:02:32 <roconnor> appList doesn't use seq
11:02:57 <roconnor> one argues that using folds make it easier to reason about programs
11:03:29 <Taral> only if you already think that way
11:03:46 <roconnor> Yeah, I'm not sure I'd make that argument
11:04:05 <roconnor> but I'm sticking with foldl' (flip id) for now
11:06:26 <kuribas> What does this cryptic error message mean: "ERROR "image.hs":17 - Instance of Integral Char required for definition of readPBM"?
11:07:46 <roconnor> kuribas: It probably means on line 17 you are trying to use toInteger on a Char.
11:07:57 <roconnor> instead of fromEnum
11:08:01 <roconnor> for Char.ord
11:08:06 <roconnor> or Char.ord
11:08:48 <roconnor> (or maybe you are trying to divide a Char by another Char)
11:09:42 <lisppaste2> kuribas pasted "ppm " at http://paste.lisp.org/display/22307
11:10:56 <kuribas> roconnor: I am not aware I am doing any of this :-|
11:11:41 <Taral> kuribas: getpix wants a number, but it's getting a Char
11:11:59 <Taral> change it to read: case ((fromEnum n) `mod` 2) of ...
11:12:09 <roconnor> @hoogle number
11:12:10 <lambdabot> Network.PortNumber :: PortNumber -> PortID
11:12:11 <lambdabot> Network.PortNumber :: data PortNumber
11:12:11 <lambdabot> Network.BSD.getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry
11:12:22 <Taral> @hoogle Parsec.number
11:12:23 <lambdabot> No matches, try a more general search
11:12:46 <Taral> bah, anyway it's a number parser in parsec
11:13:54 * roconnor out of ideas
11:14:43 <kuribas> Taral: Yes, that's the error, thanks!
11:15:33 <kuribas> roconnor: seems you were right.
11:16:39 <kuribas> I need to replace number2colors with char2colors (taking a Char).
11:18:12 <kuribas> It's just strange it gives 17 as the line of the error.
11:19:17 <lisppaste2> kuribas annotated #22307 with "correct image.hs" at http://paste.lisp.org/display/22307#1
11:20:08 <roconnor> It's sad that my implementation of SHA-512 is fater that the haskell implementation of SHA-1
11:23:15 <Igloo> The SHA-1 in darcs is about a factor of 2 off of C IIRC
11:24:58 <jgraves> howdy, I was looking for a little help...
11:25:22 <jgraves> Does anyone know of a reformatting tool for Haskell code?
11:25:44 <jgraves> I've got some example code that is kind of 'all over the place' in terms of indenting.
11:27:26 <Korollary> I think lambdabot has some pretty-printing functions
11:27:27 <jgraves> Actually, I'd also appreciate pointers to a style guide for Haskell too.
11:28:53 <jgraves> OK, I'll check the code for that.
11:30:25 <roconnor> Taral: BTW, I was wrong about the list size.  It is the number of rounds.  In this case 64 or 80
11:57:18 <vininim> Is it funny to implement a turing-complete pseudo-turing machine in haskell using semi-thue systems? =P
11:58:04 <vininim> at least to start with a deterministic one before bothering with enumeration
12:01:34 <offby1> what's a less-verbose, more-idiomatic way of writing a function that maps a single lower-case character to an integer?  I've got char_prime c = case toLower (c) of
12:01:34 <offby1>            'a' -> 2
12:01:34 <offby1>            'b' -> 3 ...
12:01:34 <offby1> which works fine, but looks silly.
12:01:49 <offby1> in case it's not obvious, I'm a total Haskell newbie.
12:01:59 <Cale> um, depends on what you're doing
12:02:04 <offby1> huh
12:02:09 <Cale> you can get the character code for the character easily enough
12:02:13 <Cale> > ord 'a'
12:02:15 <lambdabot>  97
12:02:29 <int-e> > ord 'z' - ord 'a'
12:02:30 <offby1> but I don't think I want the code; I want the mapping I described above: a -> 2, b->3, c->5, etc.
12:02:31 <lambdabot>  25
12:02:38 <offby1> each character gets mapped to a small prime number.
12:03:29 <int-e> also, lookup (zip ['a'..'z'] primes)  could do it but will not be very efficient.
12:03:44 <offby1> "zip", huh?
12:03:45 * offby1 looks
12:04:02 <Korollary> if you mind linear lookups, you should use Data.Map
12:04:32 <Cale> or just  primes !! (ord c - ord 'a')
12:04:47 <offby1> whoa, slow down Pointdexter.  What is this "primes" of which you speak?  Is it something predefined?
12:04:53 <Cale> no
12:04:56 <sylvan> How about using an Array (assuming we're talking a-z here and not thousands of unicode chars)
12:05:03 <Cale> > let primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in primes
12:05:05 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:05:18 <Cale> there you go, infinite list of primes :)
12:05:29 <offby1> sylvan: my instinct was do use an array, but after reading about arrays in some tutorial or other, I got the impression that they weren't quite idiomatic.
12:05:39 <offby1> Cale: thanks; that's interesting.
12:06:40 <sylvan> Hmm.. Not sure i'd agree with that. In any case they give you constant time lookup... Seems nice to just do primesMap!myChar
12:06:41 <offby1> Cale: is sieve built-in, or does that expression define it?
12:06:53 * xerox hugs offby1 
12:06:54 <offby1> the latter, I now see
12:07:08 * offby1 stiffens homophobically
12:07:09 <xerox> Welcome here :)
12:07:14 <offby1> eww.  hugs
12:07:27 <offby1> welcome, Hot Tuna lovers everywhere
12:07:46 <sylvan> @type array
12:07:48 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
12:32:05 <dmhouse> Allez les bleus! :) Who's watching the match?
12:32:16 <Korollary> I am
12:32:38 <dmhouse> Korollary: who are you cheering for?
12:32:46 <Korollary> nobody really
12:34:50 <Korollary> dmhouse: check this out: http://www.manyrivers.org.uk/roberto.htm
12:34:52 <lambdabot> Title: "Roberto Carlos"
12:36:12 <dmhouse> Korollary: hah! :)
12:41:27 <Korollary> going to extra time methinks
12:42:05 <kuribas> What do I have to type into ghc to use Parsec?
12:42:30 <kuribas> I get "Could not find module `Parsec'"
12:42:38 <dmhouse> :m Text.ParserCombinators.Parsec
12:43:38 <kuribas> dmhouse: that works, thanks!
12:44:27 <dmhouse> kuribas: in general, you probably want to head over to http://haskell.org/ghc/docs/latest/html/libraries/index.html and look for the full module name there
12:45:52 <kuribas> dmhouse: ok, I'll do that next time :)
12:46:01 <dmhouse> kuribas: hehe, no problem :)
12:56:55 <kuribas> How do I link agains Parsec?
12:57:50 <dmhouse> Use -package parsec on your invocation of GHC.
12:57:50 <lightstep> it usually works automatically
12:58:00 <dmhouse> Or use ghc --make and it'll happen automatically.
12:58:11 <dmhouse> ghc -o myprogram --make Main.hs
12:58:39 <kuribas> Yes, that works.  What does --make do?
13:00:03 <Nanar> I have a small problem:
13:00:23 <Nanar> where \n s  0 = "=" \n s -1 = "<"
13:00:32 <dmhouse> kuribas: 1) 'chases' the modules from Main.hs so you don't have to specify them all
13:00:38 <dmhouse> 2) Includes all the necessary packages
13:00:40 <Nanar> ghc don't like the -1
13:00:43 <dmhouse> 3) Probably some other stuff
13:00:52 <dmhouse> Nanar, that doesn't look like haskell
13:01:05 <Nanar> dmhouse: \n for new line
13:01:27 <Korollary> Nanar: use (-1)
13:01:49 <Nanar> Korollary: ah thanks
13:02:08 <dmhouse> Nanar: Ah, I see. In future, perhaps use something like the following when typing out suff here:
13:02:20 <dmhouse> s 0 = "="; s (-1) = "<"
13:02:41 <Nanar> yes, you're right
13:04:00 <vininim> > Movement :: L | R | S
13:04:01 <lambdabot>  Parse error
13:04:06 <vininim> indeed
13:04:14 <Nanar> dmhouse: btw what I type look like haskell to me, but not to ghc :)
13:04:52 <dmhouse> vininim: Are you trying to declare a data type?
13:04:58 <vininim> yes
13:05:01 <dmhouse> vininim: In which case, you probably want:
13:05:07 <dmhouse> data Movement = L | R | S
13:05:25 <vininim> oh, thanks.
13:07:29 <dmhouse> Hmm.
13:07:38 <dmhouse> Random thought, can you have unlifted types without unboxing?
13:08:17 <dmhouse> Say, can you define a datatype such that not only are the constructors strict, but that bottom isn't a member of the type at all (excuse the fudgy terminology)?
13:08:53 <dmhouse> Unboxed types give you that, but I was wondering if there was a way of doing it without unboxing.
13:09:07 <dmhouse> Or is it a case of 'If it's unlifted you may as well unbox it anyway'?
13:09:11 <dmhouse> </monologue>
13:09:28 <lightstep> unboxing is a matter of implementation
13:09:55 <lightstep> for example, ML has boxed types without bottom
13:10:19 <lightstep> but lazy evaluation says that all types are lifted
13:10:29 <dmhouse> Ah. Howso?
13:11:47 <lightstep> since you can defined `undefined = undefined'
13:11:57 <lightstep> and any type would be valid for that definition
13:12:11 <lightstep> s/defined/define/
13:12:34 <dmhouse> Well, that depends how you design your type system.
13:12:49 <dmhouse> But okay, I suppose the answer in Haskell, which is primarily what I'm interested in, is 'no'.
13:12:54 <Dino_> I'm confused about what const is for. I'm reading in YA, Advanced Datatypes and it looks like we're moving towards explaining general monadic behavior.
13:13:43 <Dino_> In particular, they're using an (I think fictitious) Computation class and explaining how Maybe and [] both fit into the idea of having a success, failure, augment and combine.
13:14:35 <Dino_> The failure of both are: Maybe.. failure = const Nothing,  [].. failure = const []
13:15:26 <Dino_> :t const
13:15:30 <Dino_> @type cnst
13:15:32 <lambdabot> Not in scope: `cnst'
13:15:33 <Dino_> @type const
13:15:35 <lambdabot> forall a b. a -> b -> a
13:15:36 <dmhouse_> Dino_: that's another way of writing:
13:15:46 <dmhouse_> fail _ = Nothing; fail _ = []
13:16:20 <dmhouse_> For an example of where you'd use const:
13:16:30 <dmhouse_> m >> n = m >>= const n
13:16:40 <dmhouse_> That's the same as m >>= \_ -> n, but is arguably neater.
13:17:21 <Dino_> Basically it means ignore the input variable and give always the same thing back?
13:17:31 <Korollary> wow. Zidane whacked that guy
13:17:32 <Dino_> Ok, it probably doesn't mean that.
13:18:02 <dmhouse_> Dino_: yeah, sort of. Ignore the second argument and always return the first
13:18:07 <dmhouse_> > const 4 "hello!"
13:18:09 <lambdabot>  4
13:18:11 <dmhouse_> > const 4 "world"
13:18:13 <lambdabot>  4
13:18:28 <Dino_> And this basically exists for syntax cleanage as in your example?
13:18:38 <dmhouse_> Now, because of partial application, you can say that 'const 4' is a function that just returns 4, regardless of what you give it.
13:18:42 <dmhouse_> Dino_: yeah, sort of.
13:18:48 <dmhouse_> Look:
13:19:09 <dmhouse_> m >> n = m >>= \x -> m
13:19:19 <dmhouse_> As we don't use the x, we normally replace it with a _:
13:19:23 <dmhouse_> m >> n = m >>= \_ -> m
13:19:50 <dmhouse_> But what is \_ -> m? It's a function which accepts anything, doesn't do anything with it, then returns m.
13:19:58 <dmhouse_> (Or executes m, if you're thinking monadically.)
13:19:59 <Dino_> Ok, I get it. It's funny, sometimes stuff gets winged into the mix in the YAHT that I hadn't seen before.
13:20:15 <dmhouse_> Right, const's a fairly nice function, it's good to know.
13:20:20 <dmhouse_> Partial application basically makes it useful.
13:20:21 <Dino_> Confusing, and it's tough to get what it's used for based on the docs.
13:20:31 <dmhouse_> Yeah
13:20:39 <dmhouse_> Dino_: one more example.
13:20:45 <dmhouse_> Dino_: there's a function either:
13:20:47 <dmhouse_> @type either
13:20:49 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
13:21:28 <dmhouse_> So if you give either a function for converting something of type a to something of type c, plus something of type b to something of type c, plus something which is either type a or b, then either gives you the c.
13:21:32 <dmhouse_> For example,
13:21:39 <dmhouse_> > either toUpper (+1) (Left 'a')
13:21:41 <lambdabot>  add an instance declaration for (Num Char)
13:21:53 <dmhouse_> Huh?
13:21:58 <Dino_> Ok, so it figures out which function to use and gives you the same-typed result that both would give.
13:22:04 <dmhouse_> Yep.
13:22:15 <dmhouse_> Weird. Why didn't that work?
13:22:23 <dmhouse_> Oh, heh.
13:22:29 <dmhouse_> The two functions have to return the same type.
13:22:38 <dmhouse_> > either toUpper intToDigit (Left 'a')
13:22:40 <lambdabot>  'A'
13:22:46 <dmhouse_> > either toUpper intToDigit (Right 5)
13:22:47 <lambdabot>  '5'
13:22:51 <dmhouse_> Okay.
13:23:12 <dmhouse_> Dino_: so say you want to write a function for converting Either types to Maybe types.
13:23:18 <Dino_> ok
13:23:28 <dmhouse_> Left anything should be converted to Nothing, and Right x should be converted to Just x.
13:23:37 <dmhouse_> A nice way of doing it is thusly:
13:23:54 <dmhouse_> > either (const Nothing) Just (Left "foo")
13:23:55 <lambdabot>  Add a type signature
13:24:23 <dmhouse_> Hold on.
13:24:46 <dmhouse_> > let eitherToMaybe :: Either a b -> Maybe b; eitherToMaybe = either (const Nothing) Just in eitherToMaybe (Left "foo")
13:24:47 <lambdabot>  Add a type signature
13:24:58 <dmhouse_> > let eitherToMaybe :: Either a b -> Maybe b; eitherToMaybe = either (const Nothing) Just in eitherToMaybe (Left "foo" :: Either String Int)
13:25:00 <lambdabot>  Nothing
13:25:05 <dmhouse_> > let eitherToMaybe :: Either a b -> Maybe b; eitherToMaybe = either (const Nothing) Just in eitherToMaybe (Right 5 :: Either String Int)
13:25:07 <lambdabot>  Just 5
13:25:14 <dmhouse_> Dino_: See how that works?
13:25:19 <Dino_> Yes, I see it.
13:26:06 <Dino_> I think it's another of those things that seems quirkily arbitrary at first (like Maybe itself) but then later on the usefulness begins to dawn on me.
13:26:13 <dmhouse_> Exactly.
13:26:18 <dmhouse_> id is another classic example.
13:26:29 <Dino_> The identity?
13:26:39 <dmhouse_> Yeah.
13:26:45 <Dino_> Yeah, I don't get that either yet.
13:26:52 <Dino_> And it makes me vaguely remember math classes, too.
13:27:00 <dmhouse_> :) More examples then.
13:27:32 <dmhouse_> Say we have a list of functions, for example [(+1), (*2), (1-)].
13:27:41 <dmhouse_> And say we have a value, like 5.
13:28:04 <dmhouse_> We want to compose all those functions together, and feed the value in to the result.
13:28:20 <dmhouse_> I.e. we want, in this case, ((+1) . (*2) . (1-)) 5
13:28:26 <dmhouse_> We can easily do this with a fold:
13:28:43 <dmhouse_> > let compose = foldr (.) id in compose [(+1), (*2), (1-)] 5
13:28:45 <lambdabot>  -7
13:29:13 <dmhouse_> Next example. maybe is a nice function that is in many ways similar to either.
13:29:14 <dmhouse_> @type maybe
13:29:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:29:46 <dmhouse_> You give it a fallback parameter, a function for getting from things of type a to type b, and then a Maybe, and it gives you the b.
13:29:59 <Dino_> Or the Nothing?
13:30:09 <dmhouse_> No, if it's Nothing, it uses the fallback.
13:30:15 <dmhouse_> I.e. maybe z _ Nothing = z
13:30:17 <Dino_> ah
13:30:23 <dmhouse_> maybe _ f (Just x) = f x
13:30:33 <dmhouse_> But often you don't want to do anything to the x in the case of Just x.
13:30:44 <dmhouse_> > maybe 5 id (Just 4)
13:30:45 <lambdabot>  4
13:30:49 <dmhouse_> > maybe 5 id Nothing
13:30:51 <lambdabot>  5
13:30:52 <dmhouse_> Ta-da :)
13:30:59 <Dino_> Oh, ok, there it is, the id
13:31:10 <dmhouse_> Basically, if you keep in your mind what these kind of functions do, you'll probably come across places to use them.
13:31:33 <Dino_> And look at a lot of examples.
13:31:44 <Dino_> Ok, thank you very much. That was excellent.
13:32:03 <dmhouse_> (In actuality, you wouldn't use maybe there at all, because there's another nice function, fromMaybe :: a -> Maybe a -> a, which is just fromMaybe z = maybe z id)
13:32:13 <dmhouse_> > fromMaybe 5 (Just 4)
13:32:15 <lambdabot>  4
13:32:20 <dmhouse_> > fromMaybe 5 Nothing
13:32:22 <lambdabot>  5
13:32:28 <dmhouse_> But it's useful quite a bit.
13:32:57 <dmhouse_> You basically use id somewhere where you have to give a function, but don't want to do anything.
13:32:58 <Dino_> Ah, the other day I used catMaybes to take a [Maybe a] and drop all the Nothings in there while stripping all the Just off the rest.
13:33:24 <dmhouse_> Sure. That's slightly different, but you _could_ do that with a map, I suppose.
13:33:51 <Dino_> I did actually initially, and then started thinking about the general case of pulling all the non-Nothing values out of a list like that..
13:33:59 <Dino_> And that led to finding catMaybes
13:34:05 <dmhouse_> Right.
13:34:12 <dmhouse_> It pays to know the library functions :)
13:34:20 <Dino_> Absolutely, the code got way smaller.
13:34:45 <dmhouse_> > let myCatMaybes = concatMap (maybe [] (:[])) in myCatMaybes [Just 4, Nothing, Just 10, Nothing, Nothing]
13:34:46 <lambdabot>  [4,10]
13:34:58 <dmhouse_> That's a bit of an ugly defintion.
13:34:59 <Dino_> But that is very useful, I can see. In this type of work where you routinely pass a function into something.
13:35:17 <dmhouse_> > let myCatMaybes = map fromJust . filter isJust in myCatMaybes [Just 4, Nothing, Just 10, Nothing, Nothing]
13:35:19 <lambdabot>  [4,10]
13:35:37 <dmhouse_> That's the more obvious but still quite ugly and involes traversing the list twice defintion.
13:36:25 <dmhouse_> > let myCatMaybes [] = []; myCatMaybes (Just x : xs) = x : myCatMaybes xs; myCatMaybes (Nothing : xs) = myCatMaybes xs in myCatMaybes [Just 4, Nothing, Just 10, Nothing, Nothing]
13:36:27 <lambdabot>  [4,10]
13:36:35 <dmhouse_> That, I think, is how it's actually defined.
13:37:41 <Dino_> Ok, with a simple recursion.
13:37:46 <dmhouse_> But that was a bit of a discourse. :)
13:38:08 <Dino_> Is the source for stuff like this around when you have the GHC or whatever?
13:38:25 <dmhouse_> It's online.
13:38:28 <dmhouse_> Steps for finding it:
13:38:37 <dmhouse_> @index catMaybes
13:38:38 <lambdabot> Data.Maybe
13:38:44 <dmhouse_> @fptools Data.Maybe
13:38:45 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
13:38:51 <dmhouse_> Et voilà.
13:39:02 <dmhouse_> @. fptools index catMaybes
13:39:03 <lambdabot> Data.Maybe
13:39:03 <lambdabot>  not available
13:39:30 <dmhouse_> Meh.
13:40:45 <Dino_> Thanks again.
13:42:13 <dmhouse_> No problem.
13:43:01 <kuribas> Is it possible to read from a file handle directly into an (immutable) unboxed array?
14:49:07 * joelr1 waves
14:49:22 <petekaz> hello
14:49:28 <joelr1> audreyt: do the ghc tests run for you on mac intel?
14:50:56 <joelr1> tests are hanging (and some failing) for me on mac intel with the latest ghc 6.5 from darcs :-(
14:53:27 <vininim> list comprehension has linear time complexity?
14:56:06 <bolrod> like.. how?
15:00:55 <vininim> > let test = [x | x <- [1..20], (div x 2) /= 2]
15:01:26 <bolrod> I guess that's linear
15:01:58 <bolrod> > let test xs = [(x,y)| x<-xs, y<-xs]  in test [1,2,3]
15:02:13 <bolrod> stupid netsplit!
15:02:36 <bolrod> [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:02:40 <bolrod> so that wouldn't be linear
15:03:54 <vininim> mmm...
15:04:38 <Stinger_> depends what you consider as your input, the two lists or the list of all pairs
15:07:47 <bolrod> list of all pairs are the output ... :s
15:08:11 <vininim> each '<-' is linear then. =
16:01:25 <ekmett> I have a quick question about haskell functors. From my understanding a functor maps arrows and objects from a category C to a category D, but the haskell functor signature just adds a type constructor, adding a layer of structure, which is useful if you want to do monadic things, but seems less useful for writing forgetful functors
16:02:28 <ekmett> it seems that the signature should be something like class Functor c d where fmap :: (c a -> c b) -> d a -> d b to meet the mathematical definition, unless there is something magical i'm overlooking that you can do with types and constructors.
16:06:44 <ekmett> coz otherwise it seems to be awfully convoluted to write a forgetful functor
16:14:47 <int-e> Well, Functor doesn't capture all possible functors. There's a trade-off between simplicity and usefulness here.
16:15:16 <ekmett> understood. I just have never seen that simplification mentioned or quantified anywhere
16:22:44 <Korollary> ekmett: You may be interested in this: http://lambda-the-ultimate.org/node/1183
16:24:00 <ekmett> the article or the comments? =)
16:24:06 <Korollary> the paper
16:25:28 <ekmett> heh
16:25:37 <ekmett> read that one a long time ago, just skimmed the functor section again
16:25:52 <Korollary> ah ok
16:25:54 <ekmett> doesn't seem to address the question above though
16:26:12 <malc_> Troy: Uh... the movie or the planet?
16:26:12 <malc_> Parker: The brand-new multimillion dollar musical. And you are starring... as the human.
16:27:56 <ekmett> easiest example i have that springs to mind that the current notation makes painful is writing a forgetful functor to take something like a monoid and extract the underlying set, thats a straightforward functor from Mon to Set, but is painful to express unless i'm overlooking something
16:41:41 <Korollary> ekmett: you may want to define your own functor typeclass
16:41:51 <ekmett> yeah
16:41:57 <ekmett> i wrote one up above =)
16:42:13 <ekmett> was just curious why we had the crippled one
16:42:42 <augustss> Any (ghc) cmm expert around?
16:42:48 <ekmett> or at least the one that seemed crippled
16:44:23 <bringert> @seen shapr
16:44:43 <Korollary> ekmett: Perhaps simplicity. I remember seeing long threads leading to the H98 proposal about monads, what should be called what, etc. Perhaps you can find some reasoning, or email haskell-cafe for answers.
16:44:55 <bringert> hey, where's lambdabot?
16:45:08 <Korollary> netsplit victim
16:45:59 <ekmett> *nods*, but Functor isn't used as a base class for anything is it? i mean they slap a couple of instances for IO Maybe and [] on it, but i don't see much else
16:46:48 <Korollary> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AFunctor
16:46:54 <Korollary> quite a few instances
16:46:59 <ekmett> oh wait, there are a few out there using it in the current format, but they are all monads of a sort
16:47:23 <ekmett> driving home the fact that its not really possible to write forgetful functors with the current interface =)
16:49:43 <ekmett> and the only reason those are instances is because monad isn't an instance of functor
16:53:27 <Korollary> There is a long thread on that one. One of Cale's major gripes.
16:53:38 <ekmett> yeah that one is pretty well known
16:54:16 <Cale> I'm more annoyed by fail being in Monad, than Monad not being a subclass of Functor
16:54:21 <ekmett> just trying to grok the purpose of the current definition, given that almost everything else i've seen expressed in haskell has had as full a generality as possible applied.
16:54:27 <ekmett> yeah
16:54:31 <ekmett> fail in monad bugs me too
16:54:43 <Cale> Just read "Functor" as "Endofunctor on the category of types"
16:55:01 <Cale> there's really only one category we actually talk about in Haskell
16:55:07 <ekmett> cale: then it makes sense =)
16:55:24 <ekmett> thats no fun, it kinda defuses my whole argument =)
16:56:19 <Cale> well, it's also a problem
16:56:43 <Cale> We'd really like to have a good way to talk about, for instance, the subcategory of types which have an instance of Ord
16:56:50 <Cale> so that Set would be a functor
16:57:28 <ekmett> but don't presently have a good way to express that concept
16:59:29 <ekmett> ok, so nothing bars the more general definition. the current definition of a functor is a matter of convenience and people not wanting to write "Endo" all the time? =)
17:00:25 * vininim trying to get set at the recursive thought...
17:00:39 <vininim> but spliting a list in half seems to be not trivial.
17:01:09 <vininim> (withouth list comprehension, using only recursion that is..)
17:03:12 <sylvan> ekmett, H98 doesn't have multi-parameter type classes, which is one of the reasons why some of the standard stuff is simpler than it could be
17:03:24 <ekmett> good point
17:03:27 <sylvan> (e.g. Num)
17:03:51 <ekmett> i kinda settled into using ghc for everything
17:04:13 <ekmett> so i get a little fuzzy about standardized haskell
17:04:17 <sylvan> yeah, it seems most people just use "GHC" as their standard... Hopefully Haskell-prime can give us a more usable standard
17:04:36 <ekmett> yeah
17:04:46 <sylvan> (if they ever finish :-))
17:05:05 <ekmett> read the wiki, sounds useful if they can stop debating and release the spec =)
17:05:45 <vininim> > let x = split [1,2,3,4,5] where split (x:y:ls) = (x:(snd (split y:ls) ),y:(fst (split ls)))
17:06:05 <Stinger_> so what bizarely complicated structures will they be adding to haskell next ? :)
17:06:24 <sylvan> ekmett: sometimes I think Haskell needs a benevolent dictator rather than a committee
17:06:29 <ekmett> doesn't look ike they are adding anything really
17:06:38 <Stinger_> sylvan in an ideal world :)
17:06:40 <ekmett> just standardizing what people have gone off and implemented anyways ;)
17:07:00 <vininim> What is the Haskell2 thing that I've seen people mentioning here?
17:07:46 <sylvan> vininim:  AFAIK it's not anything concrete. Just the next "major" revision of Haskell.. "major" as in "we'll break anything we want to if it means we can do cool new stuff"
17:08:06 <bolrod> har har
17:08:19 <sylvan> I'm not aware of any active work into it, it's just an idea of what will happen in the future sometime
17:08:47 <ekmett> so what are the major ideas that are lurking in the wings that people are afraid to implement in the haskell-as-it-exists-today?
17:08:51 <sylvan> hopefully we'll get proper records at least :-)
17:08:57 <ekmett> heh
17:09:10 <ekmett> if anyone can settle on a definition of what proper records are =)
17:09:25 <sylvan> there are a couple of really cool proposals, I say we roll a dice!
17:09:42 <sylvan> any of them is better than what we have now...
17:09:53 <ekmett> yeah
17:09:58 <ekmett> heh
17:10:25 <ekmett> when the new ecmascript proposal has a better record system than haskell, you know haskell is falling behind ;)
17:10:25 <bolrod> yeah.. 1 through 5 means I win
17:10:34 <bolrod> and with 6 you may roll a 2nd time
17:11:01 <sylvan> heck, the C# 3.0 spec has better records ("anonymous types")
17:12:39 <ekmett> i just want to see the end of the monomorphism restriction
17:13:27 <sylvan> yeah, wonder what the status of that one is...
17:20:35 <ekmett> i was digging through the haskell wiki and it said that a number of folks found limitations in using Arrows for computation, but then it didn't give any specifics. anyone know more
17:20:36 <ekmett> ?
17:22:44 <ekmett> without justification, the statement seemed to be more like 'argh. here be voodoo'  =)
17:29:25 <vininim> [Ord] -> [Ord] makes sense?
17:29:42 <ekmett> Ord a => [a] -> [a]  perhaps?
17:30:20 <ekmett> <- haskell neophyte, so take it with a grain of salt =)
17:32:49 <vininim> uh... supposedly Prelude is out of scope =P
17:33:31 <ekmett> dunno then
17:34:02 <ekmett> where are you pulling Ord from in that case?
17:37:44 <vininim> merge :: (Ord a) => [a] -> [a] -> [a]
17:38:23 <vininim> but what do you mean by pulling? isn't it part of prelude?
17:38:33 <ekmett> yeah =)
17:38:44 <ekmett> hence my question when you said 'prelude is out of scope' =)
17:39:02 <ekmett> coz i really had no idea what you were talking about at that point =)
17:46:20 <vininim> I just killed pastebin with my code :/
17:47:18 <vininim> Anyway, this is the beast that isn't like Ord in ghci. http://rafb.net/paste/results/9yHAVL35.html
17:47:23 <vininim> *linking
17:48:01 * vininim gives up on typing
17:48:22 <ekmett> Ord isn't a constructor, hence line 6 breaks down
17:49:43 <ekmett> replace Ord x  <= Ord y with x <= y
17:50:30 <ekmett> by saying that type a was an instance of ord, you gained access to the functions that are defined in the where portion of the Ord class including the operator <=
17:50:49 <vininim> mmmmm... thanks.
17:50:52 <ekmett> er instance of Ord
17:51:03 <ekmett> you sstill have problems further down
17:51:09 <ekmett> but that should resolve the immediate impasse =)
17:52:31 * juhp wonders what kind of link quux.org is on
17:52:59 <juhp> 1kB/s...
17:53:03 <CosmicRay> juhp: it just got switched to a different box
17:53:07 <CosmicRay> like 15 minutes ago
17:53:15 <juhp> hmm, ok :)
17:53:16 <CosmicRay> juhp: previously, it got a slice of my DSL
17:53:22 <CosmicRay> what IP is it resolving to for you?
17:53:31 <juhp> it wasn't any faster yesterday ;)
17:53:39 <CosmicRay> right
17:53:47 <CosmicRay> but it should be faster as soon as your DNS cache updates
17:53:55 <juhp> 69.69.114.6
17:54:02 <CosmicRay> but in the meantime...  use 64.79.197.70
17:54:03 <juhp> ok cool, thanks
17:54:05 <CosmicRay> that's the old IP
17:54:12 <CosmicRay> you should get T1 speeds there
17:54:14 <juhp> okay
17:54:18 <juhp> lovely
17:54:44 <juhp> CosmicRay: how big is the missh tarball now roughly? :)
17:55:00 <CosmicRay> -rw-r--r-- 1 jgoerzen jgoerzen 347577 Jul  4 13:00 missingh_0.14.5.tar.gz
17:55:27 <vininim> ekmett: yeah, I just found all kinds of parenthesis problems. Fixed them all... and now I found that my recursion is infinite. :)
17:55:58 <ekmett> heh
17:56:08 <ekmett> its a start =)
17:56:44 <juhp> CosmicRay: the gopher server is cute, but it doesn't tell one how big the files are...
17:56:46 <ekmett> i''m presently debugging the entire type system for my interpreter =)
17:57:00 <ekmett> so i feel your pain re: recursion
17:58:13 <juhp> CosmicRay: hmm, seems I got redirected to gopher.quux.org:70
17:58:43 <juhp> nm, seemed it downloaded now anyway
17:58:47 <CosmicRay> yeah, you will, but when you get to the actual tarball, you can replace that hostname with the IP I gave you
17:59:00 <juhp> ah right
18:05:54 <juhp> CosmicRay: hmm funny, I got a lex error when I try to build with ja_JP.UTF-8
18:06:07 <juhp> like c2hs does
18:07:00 <CosmicRay> juhp: when you try to build what?
18:07:07 <juhp> CosmicRay: missingh
18:07:14 <CosmicRay> can you paste the full error please
18:07:38 <juhp> CosmicRay: sure - hang on a bit - building with LANG=C now
18:08:16 <CosmicRay> juhp: actually, I'm about to head off for a bit.  could you email it to me instead?
18:09:43 <juhp> CosmicRay: sure, np
18:23:16 <juhp> CosmicRay: ah you use c2hs... that explains it then I guess
18:23:30 <juhp> it is a long standing c2hs bug
18:24:03 <CosmicRay> ah.
18:24:24 <CosmicRay> I don't use c2hs, though.
18:24:26 <CosmicRay> I do use hsc2hs
18:28:20 <sjanssen> @yow
18:33:59 <vininim> mergeSort :: [a] -> [a] -- given a list of elements from a set S, mergeSort will return a sorted list with elements from set S. yeah, the list is bigger with repeat elements, but that doesn't matter.. does it?
18:34:13 <vininim> :)
18:35:18 <dons> ?bot
18:35:22 <ekmett> did you just elide the Ord requirement from a for sake of conciseness?
18:35:45 <dons> morning sjanssen 
18:35:53 <sjanssen> hey dons
18:36:00 <offby1> in Lisp terms, is "lookup" more or less "assq" ?
18:36:17 <dons> assq, that's a great function name :)
18:36:29 <offby1> I'm ass-king yew
18:36:42 <sjanssen> @hoogle lookup
18:36:42 <offby1> gesündheit
18:36:53 <sjanssen> oh right, no bot
18:36:54 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
18:36:56 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
18:36:57 <vininim> i'm using Ord, but was typing here. heh
18:36:58 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
18:37:14 <sjanssen> offby1: yeah, they're analogous
18:37:16 <dons> we don't have a @hoogle for lisp 
18:37:26 <offby1> sjanssen: thanks.  May I assume it's linear time, just like assq too?
18:37:29 <dons> it might be kind of nice to have ?type for a few other langs though
18:37:34 <dons> it is linear, yes
18:37:35 <ekmett> vininim: then yeah merge sort doesn't care about repeats
18:37:37 * offby1 nods
18:37:38 <offby1> thanks again
18:37:50 <sjanssen> offby1: nobody really uses lookup -- Data.Map is preferred
18:38:03 <dons> log n rules
18:38:54 <vininim> yay, it works. my split function was kind of funky.
18:39:18 <offby1> sjanssen: actually my next question was gonna be "so where's the hash table" :-)
18:40:22 <sjanssen> offby1: Data.HashTable
18:40:31 <offby1> thanks
18:40:43 <sjanssen> however, it's mutable and in the IO monad, so you probably want to stick with Data.Map
18:41:30 <ekmett> offby1: that was pretty much my reaction when i first saw haskell too =)
18:42:00 <sjanssen> I wonder if a hashtable based on DiffArray would be any good?
18:42:34 <ekmett> it would accumulate pretty long chains quickly
18:43:03 <ekmett> actually the hash table problem is rather near and dear to my heart
18:43:09 <sjanssen> yeah, but if you use it in a single threaded fashion, it might be okay
18:43:28 <ekmett> since my main purpose for haskell right now is an ecmascript 4 interpreter, which is basically built over a set of hash tables.
18:43:35 <ekmett> and i don't use it single threaded at all ;)
18:44:19 <ekmett> biiting the bullet and abusing the io monad i can use data.hashtable or even hsjudy
18:44:27 <ekmett> but its not elegant or haskellish enough for me
18:45:07 <sjanssen> it'd be nice if Data.HashTable worked in ST, it'd be slightly less sinful
18:45:14 <ekmett> yeah
18:49:07 <waern> what's the easiest way to make a darcs patch out of the difference between two repositories?
18:49:17 <vininim> ekmett: I was actually refering that my mergeSort was growing the input list with repeated elements, but now everything works, and I will try to do it in one-line ;)
18:49:28 <ekmett> heh
18:50:09 <waern> e.g for making a patch that collects all changes from a branch repository
18:51:12 <EdwardKmett> heh keep forgetting that irc these days doesn't cap you at 9 chars ;)
18:58:23 <EdwardKmett> vin: did you add the cases for merge x [] = x and merge [] y = y to your mergesort?
18:58:24 <offby1> sjanssen: where's the canonical documentation for "Data" ?
19:04:05 <dons> ecmascript 4 interpreter, eh? is it available online?
19:04:11 <EdwardKmett> not yet
19:04:16 <dons> sounds cool, though
19:04:23 <dons> were you inspired by pugs?
19:04:35 <EdwardKmett> i have a hacked up ecma3 interpreter/recompiler banged out in er... ecmascript 3 =)
19:04:49 <dons> scary
19:04:52 <EdwardKmett> i went to start doing more stuff with ecma4 and it started to be a pain to work in ecmascript
19:04:59 <dons> do you know about pugs?
19:05:04 <EdwardKmett> i know about pugs
19:05:26 <EdwardKmett> the fact that pugs works was a good proof of concept for the ecma4 interprete r=)
19:05:28 <dons> yeah, so I think it's a good choice to write interpreters in haskell. all that symbolic manipulation
19:05:32 <EdwardKmett> yeah
19:05:32 <dons> yeah
19:05:46 <dons> and you're using HashTables underneath? (for the heap?)
19:05:48 <EdwardKmett> though the lack of a good hash type really bites you in the ass some times
19:05:51 <dons> or Data.Map?
19:06:07 <dons> there's Data.Map and Data.HashTable, you've looked at those?
19:06:11 <EdwardKmett> currently playing with implemetations using either (i've abstracted over them to test)
19:06:18 <EdwardKmett> also playing with HsJudy
19:06:19 <dons> ok.
19:06:26 <EdwardKmett> haven't been sold on any of the 3 yet
19:06:33 <lispy> i want to learn how type checkers are implemented, what is a good book for this information?
19:06:41 <dons> if you're interested in putting this online, I'd expect to get a few contributors from our community
19:06:46 <EdwardKmett> i hate binding myself so tightly to the IO monad, because i want to try to use STM
19:06:55 <dons> personally, I'd go for Data.Map, that's the most elegant
19:07:05 <EdwardKmett> it'll probably go online once it is at least as fuctional as my javascript implementation
19:07:14 <dons> ok. any timetable?
19:07:19 <dons> or a url I can keep track of?
19:07:22 <EdwardKmett> yeah, but data.map spends a lot of time dealing with the tree structure
19:07:28 <EdwardKmett> http://slipwave.info 
19:07:28 <dons> true
19:07:33 <EdwardKmett> should have the info on the javascript version
19:07:43 <dons> also, you might be interested in the haskell work done on describing a javascript type system.
19:07:50 <EdwardKmett> infact if you are sufficiently devious i suppose you could pull the whole thing through the view-source
19:08:28 <EdwardKmett> basically i started putting together a javascript recompiler so i could use continuation passing style to emulate threads
19:08:37 <EdwardKmett> that much of the recompiler works just fine
19:09:00 <EdwardKmett> so i can run threaded javascript in a browser without having to do much in the way of gymnastics
19:09:10 <EdwardKmett> the whole thing compiles and packs down to about 12k of code
19:09:22 <EdwardKmett> (since i gzip the resulting javascript
19:09:24 <dons> cool
19:09:37 <EdwardKmett> which is i think, a reasonable amount of bloat to add to a web page.
19:09:43 <dons> http://citeseer.ist.psu.edu/context/2648168/0
19:09:53 <dons> that's a haskell guy whose written some (all?) of a type system for javascript
19:10:06 <EdwardKmett> to support tail call optimization and threads in javascript
19:10:13 <dons> might be an interesting read to understand how the static typing people think about java script
19:10:29 <iron32> lispy: Well on the Haskell web under learning there is a link to video lectures on a Haskell course giving in english in a german university the last part of the course takes about implementing type checkers
19:10:45 <EdwardKmett> well, is it for ecma3 or ecma4 though?
19:10:48 <dons> not sure.
19:10:49 <EdwardKmett> they are totally different
19:11:06 <EdwardKmett> the stuff there is about inferring types it seems
19:11:15 <dons> oh, i'm not suggesting you use it. just that it might help give some ideas for javascript in haskell
19:11:20 <iron32> lispy: I liked the course a lot help me get started in Haskell
19:11:32 <EdwardKmett> the new type system in ecma4 has some pretty nifty stuff where the anonymous types get structural subtyping
19:12:13 <EdwardKmett> so basically javascript is going from one of the loosest typed languages out there to one of the strongest typed imperative languages in one fell swoop =)
19:12:17 <lispy> iron32: at haskell.org?
19:12:28 <dons> hehe. that's cool EdwardKmett 
19:13:01 <iron32> lispy: http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
19:13:04 <lambdabot> Title: "S-INF.de - Vorlesungsvideos"
19:13:09 <EdwardKmett> btw- feel free to ignore the js.monad stuff on that site, everything else should be coherent though =)
19:14:01 <EdwardKmett> i kept playing with using javascript functions to double as haskell style types to i culd build monads over unboxed types, but it didn't really work out.. too much notation.
19:14:07 <EdwardKmett> er could
19:14:12 <iron32> lispy: Yes you can find the link on the page http://www.haskell.org/haskellwiki/Books_and_tutorials
19:14:13 <lambdabot> Title: "Books and tutorials - HaskellWiki"
19:14:30 <iron32> lispy: Just search for video
19:14:52 <lispy> iron32: thank you very much
19:15:43 <iron32> lispy: No problem it is a very good course at least for me I was mostly interested in the first 9 to 10 lectures you would probably be interested in the lectures after that more advanced stuff
19:15:55 <EdwardKmett> bsically the reason i wanted to use haskell was because it lets me define the grammar in chunks and compose the types and take the fixed point to build different grammars
19:16:16 <EdwardKmett> that way i can have a grammar for ecma3, and one for the various prototype dialects of ecma4 in one code base
19:17:02 <EdwardKmett> more pain up front, but i can ue it to model the variations that are evidenced by microsoft vs. adobe, etc.
19:17:04 <iron32> lispy:  Well I need to log off now wife is calling me to watch a flic with her good luck hope it pans out for you
19:18:00 <iron32> later all
19:22:13 <lispy> i never thought about it before but you can't define a function of arity 0 using '\ ->' 
19:22:43 <EdwardKmett> heh
19:25:23 <lispy> i guess haskell is just really flawed huh?
19:25:27 <lispy> ;)
19:25:51 <EdwardKmett> terribly ;)
19:26:29 <EdwardKmett> what do you want this particular thunk for anyways?
19:26:46 <EdwardKmett> or was it just an observation
19:27:17 <EdwardKmett> since you have the whole referential transparency thing wouldnt that just be a noop anyways?
19:28:13 <lispy> well, a function of arity 0 is just a value right?
19:28:14 <ihope_> Yeah, functions of arity 0 simply aren't functions.
19:28:21 <ihope_> Unless they return functions.
19:28:25 <lispy> so you don't actually need the form, i was just wondering if the syntax allowed it
19:28:37 <ihope_> Well, you could use '\() ->'.
19:28:43 <Cale> yeah, there's no distinction between a function of 0 parameters and a value in a lazy language
19:29:04 <ihope_> A lazy, referentially-complete one.
19:29:22 <ihope_> (I like to put hyphens between adverbs and adjectives.)
19:29:43 <offby1> like "annoyingly-pedantic" ?
19:30:10 <EdwardKmett> =)
19:31:27 <ihope_> Oh, and has anybody ever noticed that "and" is an infix function? :-)
19:31:55 <int-e> > and [True, False]
19:31:56 <lambdabot>  False
19:32:01 <int-e> not so far.
19:32:12 <int-e> not yet?
19:32:41 <ihope_> I mean in English...
19:33:01 <ihope_> "In" is actually an English data constructor.
19:33:05 <int-e> I chose not to follow your intended interpretations even though it was clear to me.
19:33:06 <EdwardKmett> well, here we like to use it on lists =)
19:33:33 <int-e> I wonder if I can produce a complete sentence without a typographic error.
19:33:40 <jargonjustin> What would be a cleaner way to write: do { args <- getArgs; putStrLn $ show $ foldr (+) 0 $ map read args }
19:34:06 * offby1 hasn't yet learned what the {} and $ mean :-|
19:34:11 <ihope_> jargonjustin: 'print $ sum $ map read args'?
19:34:44 <int-e> print . sum . map read $ args ?
19:34:44 <jargonjustin> ihope_: I know sum, I was wondering if there was a way to use Monads and (>>=) to clean it up as far as the mapping goes.
19:35:19 <int-e> print . sum . map read =<< getArgs ?
19:35:20 <ihope_> offby1: the {} are just for stating blocks, like in C, and the $ is an infix operator for application, so that's putStrLn (show (foldr (+) 0 (map read args))) without all the parentheses.
19:35:32 <offby1> ah
19:35:40 <jargonjustin> int-e: That's it I think.
19:35:47 * offby1 _likes_ parentheses :-)
19:35:53 <ihope_> Me too.
19:36:02 <EdwardKmett> offby1: $ grows on you like .
19:36:14 <ihope_> I am strongly against using $ for grouping for little reason.
19:36:15 <EdwardKmett> offby1: pretty soon you forget that your functions even have arguments ;)
19:36:16 * offby1 brushes off the . he found growing on him
19:37:07 <EdwardKmett> bah, one $ is worth two parentheses. good trade =)
19:37:09 * int-e admits he'd usually prefer the args <- getArgs ; ... stuff to using =<<.
19:38:43 <int-e> EdwardKmett: but usually $ comes with an additional space while ( and ) do not.
19:38:50 <ihope_> So why doesn't someone make a comonad that's the opposite of Reader?
19:38:57 <ihope_> @docs Control.Comonad
19:38:57 <lambdabot> Control.Comonad not available
19:38:57 <EdwardKmett> fair nuff
19:42:11 <lisppaste2> Ronald Mai pasted "Monad Transformer" at http://paste.lisp.org/display/22328
19:42:14 <int-e> EdwardKmett: I like . and $ btw, because matching parentheses gets easier the fewer nesting levels there are.
19:42:29 <EdwardKmett> yeah
19:42:43 <EdwardKmett> $ made haskell the first functional language I really liked
19:42:43 <int-e> EdwardKmett: but usually it makes my code a bit longer, not shorter.
19:43:08 <EdwardKmett> less cognitive overhead shuffling arguments around
19:43:13 <EdwardKmett> and maintaining parenthesis
19:43:15 <int-e> EdwardKmett: (it becomes longer when I rewrite a (b (c d)) as a . b . c $ d for semantic reasons.)
19:43:18 <audreyt> I can't wait to deploy bang patterns in production :)
19:43:29 <audreyt> (it solves my current #1 gripe about haskell)
19:43:40 <audreyt> (which is having to say $! everywhere)
19:43:58 <Cale> Do you really find that you need $! all that often?
19:44:03 <audreyt> yes.
19:44:11 <int-e> and wondering why $! has such a weird fixity :)
19:44:18 <Cale> I hardly ever use $! or seq
19:44:19 <audreyt> Perl6 has mixed eager/lazy evaluation
19:44:32 <audreyt> and for the eager parts I have to put strategic $!s
19:44:39 <Cale> ah
19:44:42 <int-e> Cale: hmm. do you use strictness annotations in data declarations?
19:44:56 <Cale> int-e: occasionally when it makes lots of sense
19:45:24 <audreyt>   let ![x,y] = e in b
19:45:30 <Cale> int-e: I won't add any strictness annotations before I actually run a program unless it's immediately obvious that the thing won't run without them.
19:45:35 <EdwardKmett> bag patterns are when you can throw them into the pattern matching rule right?
19:45:36 <audreyt> and just strict lets:
19:45:37 <audreyt>   let !y = f x in b
19:45:44 <audreyt> EdwardKmett: yes. GHC 6.5
19:45:50 <EdwardKmett> audrey: ah k
19:45:50 <Pseudonym> I find that I either need seq or $! sprinkled very lightly (and it's usually obvious where), OR I need deepSeq.
19:46:13 <Pseudonym> But yeah, strict lets would be a very convenient way to do this.
19:46:28 <Pseudonym> let y = f x in y `seq` b
19:46:31 <Pseudonym> It's just not as elegant.
19:46:32 <EdwardKmett> i seem to recall reading somewhere that 6.5 added unicode operator support too, am i mistaken?
19:46:36 <audreyt> yeah. currently it requires cases
19:46:37 <Cale> Most of the things I like to write tend to be various search algorithms, so as much laziness as possible is good.
19:46:39 <audreyt> EdwardKmett: I think so, yeah
19:47:01 <SamB> oh no! we are now like PERL?
19:47:07 <EdwardKmett> thats something i'l be happy to see
19:47:14 <Pseudonym> Perl and Haskell have had a symbiotic relationship for a while.
19:47:20 <Pseudonym> There's a shocking amount of overlap.
19:47:25 <Cale> Unicode operator support is great.
19:47:32 <SamB> oh well, at least each operator won't have its own syntax ;-)
19:47:33 <EdwardKmett> samb: is it really better to overload yet another 3 symbol sequence or just use the nice ones they have up there in the mathematical operator set?
19:47:34 <Cale> Especially with SCIM :)
19:47:41 <lispy> i think TaPL has the info i need to learn how type checkers are built
19:47:46 <audreyt> lispy: yes.
19:47:53 <Cale> f ∘ g = \x -> f (g x)
19:47:55 <Pseudonym> Either Haskell represents the Perl hacker's deep-seated desire for theoretical purity, or Perl represents the Haskell programmer's pragmatism.
19:47:56 <satan> anyone have a quick link to instructions to making a haskell program a stand alone executable with ghci ?
19:47:58 <SamB> now someone fix fonts in Debian and Emacs...
19:48:01 <EdwardKmett> lispy: TaPL is a godsend
19:48:10 <audreyt> it doesn't talk about typo operators, typo inferencing and typo checkers, though.
19:48:16 <Pseudonym> Or perhaps Haskell is the Perl hacker's dirty little secret and vice versa
19:48:27 <audreyt> satan: quick answer: you don't. use ghc --make
19:48:32 <Pseudonym> Somehow, this is all embodied in the evil mangler.
19:48:34 <lispy> audreyt: heh
19:48:39 <satan> audreyt: thanks
19:48:45 <audreyt> np :)
19:48:45 <int-e> sometimes I feel I want an ocaml with a sane (type ?) syntax.
19:48:49 <Cale> > let x ∈ [] = False; x ∈ (y:ys) = x == y || x ∈ ys in 4 ∈ [1,2,3,4,5]
19:48:49 <lambdabot>  Illegal character ''\136''
19:48:53 <Cale> aww
19:48:57 <Pseudonym> int-e: YES!
19:49:03 <SamB> do they have an evil mangler for Perl written in Haskell?
19:49:07 <lispy> so how come no one shouted TaPL when i asked for books about type checking? ;)
19:49:14 <Pseudonym> If only ML didn't have an arcane syntax...
19:49:19 <audreyt> SamB: yes, it's called Pugs :)
19:49:27 <EdwardKmett> lispy: didn't hear you =)
19:49:30 <Pseudonym> LOL
19:49:31 <audreyt> SamB: also, now the perl5-to-perl6 translator is written in haskell.
19:49:41 <Pseudonym> That's not evil, though.
19:49:45 <Cale> Is λ-bot using GHC 6.4 or 6.5?
19:49:46 <Pseudonym> The evil mangler is evil.
19:49:50 <EdwardKmett> TaPL and ATTaPL are both good, but read TaPL first
19:49:52 <audreyt> I assure you that the translator is evil
19:49:59 <audreyt> since it attempts to do "idiomatic" translation
19:50:03 <Pseudonym> Oh, good.  That restores my faith.
19:50:08 <audreyt> without 100% guarantee of preserving semantics.
19:50:26 <audreyt> but it'd try very hard with heuristics.
19:50:27 <int-e> do what larry thought you'd mean? (abbreviated: DWIM)
19:50:33 <Korollary> heh
19:50:42 <Korollary> you have been autovivfied!
19:50:51 <SamB> but Pugs doesn't rearrange assembler in breakage-prone, ill-defined ways, does it?
19:50:58 <Pseudonym> Any program which attempts to simulate a Perl programmer must be de facto evil.
19:51:14 <audreyt> SamB: well, you should see our JavaScript codegen...
19:51:22 <lispy> Pseudonym: nice term, 'de facto evil'
19:51:37 <SamB> well, it doesn't assume things it shouldn't about the output of other programs, does it?
19:51:39 <Cale> > let x ⊕ y = zipWith (+) x y in [1,2,3] ⊕ [5,6,7]
19:51:39 <lambdabot>  Illegal character ''\138''
19:51:42 <Cale> bah
19:51:52 <SamB> probably still using 6.4?
19:51:57 <audreyt> SamB: indeed. so the mangler is still eviller
19:51:59 <EdwardKmett> Cale: no love for the unicode operators, eh?
19:52:24 <Cale> EdwardKmett: It's probably using 6.4...
19:52:28 <lispy> oh, if we had unicode symbols you could make some cool operators...never thought of taht before...
19:52:29 <Cale> @version
19:52:29 <lambdabot> lambdabot 4p23, GHC 6.5 (OpenBSD i386 )
19:52:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:52:32 <Cale> hmm
19:52:33 <Cale> no
19:52:37 <Cale> says 6.5
19:52:43 <lispy> like you could use the kanji for house as an operator ;)
19:52:50 <EdwardKmett> cale: maybe the interactive portion doesn't support them or something?
19:52:57 <SamB> lispy: its a lot more practical than trying to use strange letters
19:53:02 <Pseudonym> I wonder if the Perl translator tries to translate haiku to haiku.
19:53:22 <int-e> Haskell could use a few more good infix operators :)
19:53:28 <Cale> Well, the eval plugin actually compiles a program with your expression.
19:53:31 <EdwardKmett> int-e: =)
19:53:32 <Korollary> Pseudonym: use the perl variant in latin as it is profound
19:53:32 <audreyt> Pseudonym: maybe it should translate Saturn to Saturn.
19:53:41 <Cale> but maybe it's not transferring the characters correctly somewhere
19:53:47 <Pseudonym> Or golf entries to golf entries.
19:53:52 <Cale> or else dons has both GHC 6.4 and 6.5 on that machine
19:53:55 <SamB> oh oh oh
19:53:59 <audreyt> # http://www.perlmonks.org/index.pl?node_id=397958
19:54:00 <SamB> dons put in that parser
19:54:02 <lambdabot> Title: "Saturn"
19:54:08 <Cale> SamB: aha!
19:54:09 <SamB> it does not parse Unicode operators, duh!
19:54:09 <audreyt> or selfgol to selfgol.
19:54:10 <audreyt> # http://lib.fo.am/cgi-bin/view/Libarynth/SelfGOL
19:54:13 <lambdabot> Title: "SelfGOL &lt; Libarynth &lt; Libarynth"
19:54:16 <Pseudonym> I used to work at the same university as Damian Conway.
19:54:20 <EdwardKmett> cale: could be getting mangled somewhere along the way in your irc client, the irc network, the bot's irc interface, etc.
19:54:35 <Cale> EdwardKmett: I'm fairly sure it's what SamB said
19:54:36 <Korollary> ? is also a bot command prefix, right?
19:54:44 <EdwardKmett> cale: sounds right
19:54:58 <Cale> EdwardKmett: dons put in a parser which checks that the expression you type is valid Haskell, it's probably failing to lex the string.
19:55:14 <Cale> Korollary: yes, with the same meaning as @
19:55:16 <EdwardKmett> *nods*
19:55:30 <SamB> but nobody says @??
19:55:35 <SamB> people do say
19:55:36 <SamB> ???
19:55:42 <SamB> oh nice
19:55:42 <EdwardKmett> but a nice language with unicode operators might make me write yet another computer algebra system ;)
19:55:43 <offby1> I say!
19:55:44 <Pseudonym> I described to Damian the minimal set of operators that needed to be added to Perl regular expressions which (in conjunction with his quantum computation module) would make them equivalent to a quantum Turing machine.
19:55:47 <Pseudonym> He told me to go away.
19:55:51 <SamB> someone made ??? not nasty
19:56:02 <audreyt> Pseudonym: aww, that's rude of him
19:56:14 <Pseudonym> He was kinda busy at the time, and I was a young hothead.
19:56:16 <audreyt> if it's me I'd hack it into perl5 :)
19:56:24 <audreyt> do you still have those ops around?
19:56:32 <SamB> what good is a quantum turing machine? besides being regular than a newtonian one...
19:56:35 <Cale> SCIM + LaTeX Table is really nice, I can type most mathematical symbols in only a few keystrokes
19:56:46 <SamB> er, better...
19:56:46 <Pseudonym> Actually, it's pretty easy.
19:56:59 * SamB does not know how he messed that up
19:57:24 <Pseudonym> First, you have to understand how to represent context-free languages as regular expressions.
19:57:30 <Cale> let Σ = sum in Σ [1,2,3]
19:57:36 <Pseudonym> You need to add stack operations:
19:57:54 <Pseudonym> Let {A,B..Z} be stack symbols.
19:57:56 <Pseudonym> Then:
19:57:58 <Pseudonym> <A| means "
19:58:01 <Pseudonym> push A"
19:58:08 <Pseudonym> and |A> means "pop A"
19:58:14 <dons> Cale, indeed, it's what SamB said. that the Language.Haskell parser rejectifying your unicode
19:58:15 <dgoldsmith> Since kanji are considered letters in Unicode, they would probably make more sense as identifier characters than as operator characters.
19:58:20 <Pseudonym> <A| |A> = 1 (where 1 == empty string)
19:58:31 <Pseudonym> <A| |B> = 0 (where 0 == empty set, fail etc)
19:58:34 <SamB> dons: so fixorifyorate it
19:58:49 <Cale> dgoldsmith: but are they uppercase or lowercase? :)
19:58:50 * offby1 is perplexifcationed
19:58:51 <Pseudonym> |A> <A| + |B> <B| + ... + |Z> <Z| = 1
19:58:52 <dons> i'd have to find the right fixomorphism first.
19:59:01 <Pseudonym> + is set union
19:59:04 <SamB> fixomorphism?
19:59:10 <dgoldsmith> They are non-cased. There are many non-cased writing systems in the world.
19:59:14 <Pseudonym> a^N b^n, for example, would be:
19:59:18 <EdwardKmett> samb: basically on a quantum coputer you can show more algorithms to be in the class of quantum probabalistic time algorithms (QPP) that you can prove to be in the class of probabilistic time algorithms (BPP)
19:59:22 <dgoldsmith> The Unicode category is "Letter, Other"
19:59:24 <dons> the function that when applied fixorifies the code, of course ;)
19:59:28 <Pseudonym> <A| (a <B|)* (b |B>)* |A>
19:59:44 <dgoldsmith> I realize that may be a problem for Haskell identifiers...
19:59:46 <SamB> dons: why don't you just fix it rather than doing AI research?
19:59:53 <Pseudonym> Make that two stacks instead of one, and you have Turing machines.
20:00:11 <dons> well, Language.Haskell isn't my personal project you know..
20:00:21 <Cale> dgoldsmith: It might just exclude them from occurring in patterns.
20:00:26 <SamB> I thought you already hacked up that parser a bit
20:00:39 <Cale> hmm
20:00:46 <dons> sure, I hacked the parser. I'd need to hack the lexer too 
20:00:52 <SamB> well...
20:00:53 * dons takes a peek
20:01:02 <Dino_> audreyt: I have gotten attached to using YAML for all sorts of things over the past year. I know that the YAML perldoc at least used to say something tantalizing about a Haskell YAML module in-progress. Does such a beast exist?
20:01:04 <dgoldsmith> Hebrew and Arabic are also non-cased.
20:01:09 <SamB> okay. so hopefully it doesn't use Happy...
20:01:24 <Cale> right
20:01:29 <SamB> er, Alex...
20:01:34 <Cale> along with lots of other character sets
20:01:41 <SamB> whichever generator thing I mean
20:01:47 <Cale> Greek works nicely though.
20:01:50 <dgoldsmith> The Indic scripts are non-cased, too.
20:01:59 <dons> bah, its all hand coded
20:02:06 <Cale> I look forward to using Greek letters for type variables.
20:02:10 <dons> if it was alex we'd be ok (since ghc uses alex and supports unicode)
20:02:12 <Cale> :)
20:02:30 <EdwardKmett> so does anyone have any insight into relative performance between Parrows, Parsec, Happy and Frown for a complex (real world) sized grammar?
20:02:40 <dons> Happy is the fastest
20:02:42 <Cale> map :: (α -> β) -> ([α] -> [β])
20:02:47 <dons> and you'd use Alex for the lexing
20:02:59 <dons> these work very nicely on the big old haskell/ghc grammar
20:03:16 <EdwardKmett> happy is a little tricky for me, because of the funny ;-insertion rules in javascript
20:03:30 <dons> however, Parsec is often used as well, for large grammars, with few issues
20:03:36 <Cale> Parsec is probably the most fun to use.
20:04:10 <Cale> and there's Parsek, which is almost compatible, if you need more speed. It uses the same technique as ReadP, iirc.
20:04:29 <Cale> Or do I have that backwards?
20:04:41 <EdwardKmett> looking at Alex right now
20:04:46 <Cale> Maybe ReadP/Parsek are slower, I can't recall :)
20:04:58 <EdwardKmett> currently i'm using parsec and a trie over my keywords
20:05:06 <SamB> I thought Parsek was slower but more nondeterministic, or something like that?
20:05:14 <Cale> oh, right, yes.
20:05:28 <EdwardKmett> don't need nondeterminism.
20:05:29 <SamB> does it have okay errors?
20:05:29 <Cale> While not being too slow
20:05:58 <Cale> Probably parsec has the nicest handling of error messages.
20:06:20 <EdwardKmett> i'm borderline between SLR and LALR (SLR except for one language case iirc)
20:06:36 <EdwardKmett> so frown is appealing.
20:06:56 <EdwardKmett> in javascript i used a pair of recursive descent parsers wrapped around a simple operator precedence parser (ala perl 5)
20:07:23 <Cale> With Parsec, it's easiest if your language is LL(1), but it handles LL(∞) using the try function.
20:07:30 <dgoldsmith> The cased scripts in Unicode (4.1) are Latin, Greek, Cyrillic, Coptic, Armenian, Georgian, and Glagolitic.
20:07:50 <Cale> plus it can handle context-sensitive languages
20:08:09 <EdwardKmett> i might retain that same structure here. regexps in the language make it slightly context-sensitive. which i'm tracking with a simple lexer state monad.
20:08:13 <Cale> for example, you can even parse a language in which an initial part of the string describes the grammar for a later part.
20:08:47 <Cale> (wholesale)
20:08:56 <EdwardKmett> cale: *nods*
20:09:02 <SamB> such as Perl?
20:09:36 <EdwardKmett> cale: personally i'm not a fan of using a pure LALR or LL grammar for most real world languages that have lots of precedence levels
20:10:00 <EdwardKmett> you get so many nested reductions in the operator set
20:10:06 <SamB> precedence should be post-processed
20:10:12 <SamB> :-P
20:10:26 <EdwardKmett> samb: operator precedence, you can reduce as you go
20:10:38 <EdwardKmett> samb: without that painful recursion
20:10:53 <SamB> that doesn't work if the precedence is defined further down in the file ;-)
20:10:57 <EdwardKmett> samb: heh
20:11:08 <EdwardKmett> well, fortunately i have fixed precedence in javascript ;)
20:11:39 <audreyt> parsec's "try" is very costly though.
20:11:42 <SamB> anyway, it is probably easier to do it as an extra pass in Parsec...
20:11:46 <SamB> audreyt: indeed
20:11:50 <audreyt> if you are going to try a lot
20:11:53 <audreyt> then switch to pappy
20:11:56 <audreyt> it's much nicer.
20:12:03 <SamB> especially since there is no way to say when it can stop "try"ing
20:12:14 <audreyt> with pappy you can try as much as you like
20:12:16 <audreyt> and it's still O(n)
20:12:29 <EdwardKmett> fair enough
20:13:12 <EdwardKmett> pappy == packrat right?
20:13:20 <audreyt> (amortized; extra memory may apply; fare restrictions is subjected to local regulation; changes must be announced 30 days before boarding time; your mileage may vary)
20:13:47 <audreyt> EdwardKmett: yes
20:14:31 <SamB> do you still get the same number of frequent flyer miles even if your mileage varies?
20:15:23 <EdwardKmett> k, then i'll have to stay clear. packrat gets hairy when you introduce state as i recall and i'm leery about a couple of the ecma4 proposals biting me in the ass that way
20:16:18 <EdwardKmett> since its really O(n*r) where r is the rule set size. works great as long as thats small or fixed, but otherwise...
20:17:53 <EdwardKmett> that and it tends to hold onto a heck of a lot more data than i need since i only have to backtrack 1 symbol in 99% of the cases and 2 in the case of labels in some cases. 
20:19:16 <audreyt> oh. then just use parsec state and lookaheads
20:19:24 <EdwardKmett> yeah
20:19:38 <EdwardKmett> basically where i'm at =)
20:20:16 <EdwardKmett> i have a simple lexer written in parsec, and a simple parser in parsec atm
20:20:27 <audreyt> I was doing easily the most unparsable real-world language as my Parsec project
20:20:39 <EdwardKmett> audrey: heh i understand =)
20:20:41 <audreyt> so my views on it is biased :)
20:20:49 <audreyt> s/biased/crippled/
20:21:24 <EdwardKmett> audrey: ecmascript only has the ;-insertion rules that make it problematic for LL/LALR/etc style traditional grammars
20:21:33 <audreyt> k.
20:21:37 <JohnnyL> wow.
20:21:46 <JohnnyL> #haskell has definitely grown.
20:21:53 <EdwardKmett> that and they have a tendency to define parallel parse paths, that are easy to define in parsec, but a pain in the ass to define in those forms
20:22:20 <EdwardKmett> mostly was concerned with  how bad i would be shooting myself in the foot to use parsec on a large scale
20:22:21 <audreyt> perl6 has "if the symbol } occurs at the end of a line (except whitespace), and a semicolon can logically occur after it without introducing syntax error, and pretend one is there."
20:22:32 <EdwardKmett> yeah
20:23:18 <EdwardKmett> javascript has a 'if the parse would crash if you don't put a ; in, and the next symbol is on a new line, insert a semicolon, UNLESS the previous symbol is return break throw or continue or the ; would be a semicolon in a for(;;) loop, etc.
20:23:41 <EdwardKmett> the 'is on a new line' requires some funny glue in the lexer
20:23:56 <EdwardKmett> and the parser, which most lalr type grammar tools don't like to give you
20:24:03 <audreyt> yup.
20:24:12 <audreyt> so do you just use getInput/setInput?
20:24:23 <audreyt> I use that (and getPosition/setPotion) to literally insert a ;
20:24:43 <audreyt> into the parse stream
20:25:01 <EdwardKmett> my current approach is to just not consume the next token
20:25:07 <EdwardKmett> as long as i'm in the right spot for it
20:25:13 <audreyt> 'k.
20:25:17 <EdwardKmett> there is an easy way for me to annotate the cases in the grammar
20:25:48 <EdwardKmett> my javascript version used that approach to good effect and was able to parse the full ecma-3 spec
20:25:55 <audreyt> nice. url?
20:25:59 <EdwardKmett> so i don't anticipate any probems yet
20:26:04 * audreyt ponders hooking it up as a Pugs frontend
20:26:28 <EdwardKmett> http://slipwave.info/ its still a work in progress, and i haven't technically 'released' the source, but its up there to view
20:27:13 <EdwardKmett> has a pretty pathetic test suite coz i haven't ported the full suite over yet
20:27:24 <EdwardKmett> since i got distracted by they 'hey lets write the next version in haskell' bug =)
20:27:34 <EdwardKmett> which sent me on a two week monad binge =)
20:28:26 <EdwardKmett> major purpose for that version of the parser/interpreter/recompiler was to implement a javascript to javascript continuation-passing-style transformation so i could do 'heavy-lifting' in javascript
20:28:38 <EdwardKmett> coz otherwise that 1 million instruction limit bites you in the ass
20:28:51 <audreyt> wow
20:28:54 <dons> there's a 1M instruction limit?
20:28:55 <audreyt> that UI is kinda nice.
20:29:00 <EdwardKmett> this way i use an Appel style trampoline (like the chicken scheme compiler)
20:29:04 <EdwardKmett> the UI is tiddlywiki
20:29:21 <audreyt> EdwardKmett: we use exactly the same encoding for Pugs->JavaScript
20:29:24 <EdwardKmett> i slapped a little bit of code on it to let it view source
20:30:02 <EdwardKmett> once i have it cps transformed and using the appel trampoline i have another stage where i use a better cps transform to a sort of inverted duff's device
20:30:33 <EdwardKmett> i use up stack frames 3 at a time instead of 2 at a time, but i get shorter lexical scope chains (a fixed length, rather than growing with continuation count)
20:30:51 <EdwardKmett> which gives me asymptotically optimal behavior
20:31:00 <audreyt> hm.
20:31:16 <EdwardKmett> the trampoline gives me a natural thread quantum and i only do a partial cps transform for performance reasons
20:31:27 <EdwardKmett> so i throw threading in basically for free.
20:31:36 <EdwardKmett> so you can write stuff like
20:31:59 <EdwardKmett> for (var i=0;i<50;++i) new Thread(function() { do something }).start();
20:32:12 <EdwardKmett> and block and join, and do all that good stuff
20:32:47 <EdwardKmett> though i want to throw away the nasty java inspired thread library and replace it with something cleaner.
20:33:03 <EdwardKmett> the current interface is a direct port of java.lang.Thread
20:33:18 <EdwardKmett> and a simple dijkstra style PV semaphore
20:34:38 <dons> you could implement an MVar and forkIO layer, I suppose.
20:34:41 <EdwardKmett> dons: sorry missed your comment
20:34:51 <dons> but maybe you need laziness and such like for that.
20:34:52 <EdwardKmett> dons: yeah there is a 1m instruction limit historically in netscape
20:35:00 <dons> ah, there you go
20:35:10 <EdwardKmett> dons: internet explorer sets it somewhere around there by a different mechanism
20:35:48 <EdwardKmett> i set it to 20 times recursing to a depth of just under 1000, which given my distance between function calls is conservative
20:35:59 <EdwardKmett> that way i work with a stacklimit of 1000 and a million instruction cap
20:36:16 <EdwardKmett> i just set a timeout for a millisecond later and resume my trampoline
20:36:24 <EdwardKmett> with whatever is left in my thread queue
20:36:43 <Korollary> 1M instructions should be enough for everybody.
20:36:44 <EdwardKmett> since javascript has first-class closures, its all fairly painless
20:37:05 <EdwardKmett> korollary: to be fair javascript gives a ssingle thread for control of the user interface and the javascript of a window
20:37:15 <EdwardKmett> korollary: if you don't return fast enough the ui stalls
20:37:26 <EdwardKmett> kor: and the language wasn't originally intended to have thread primitives.
20:37:30 <Korollary> EdwardKmett: Heh. I was messing around.
20:37:34 <EdwardKmett> kor: heh
20:37:43 <EdwardKmett> kor: but yeah the bill gates reference is somewhat appropriate ;)
20:38:39 <EdwardKmett> audreyt: the programming practices evidenced on that site are by no means 'best practices' but they do wonders for optimizing for byte count ;)
20:39:40 <EdwardKmett> my favorite regexp in the whole thing is (?:^(?:\\d+\\.\\d*(?:[eE][-+]?\\d+)?|^\\d+(?:\\.\\d*)?[eE][-+]?\\d+|^\\.\\d+(?:[eE][-+]?\\d+)?|(?:"(?:[^\\\\"]|\\\\.)*"|'+"'"+'(?:[^\\\\'+"'"+']|\\\\.)*'+"'"+')|0[xX][\\da-fA-F]+|^0[0-7]*|^\\d+|\\/(?:(?:\\\\.|[^\\\\\\/])+)\\/(?:[egim]*)))
20:39:40 <audreyt> EdwardKmett: so, are you in some way involved with JS2?
20:39:44 <Korollary> roflmao
20:39:58 <EdwardKmett> audreyt: nope, interested amateur
20:40:01 <basis> sorry, what site?
20:40:30 <EdwardKmett> basis: http://slipwave.info/ has a javascript recompiler/interpreter/parser, etc i wrote for my own purposes on it
20:40:31 <basis> omg look at that
20:40:40 <basis> ah ty
20:40:46 <EdwardKmett> the \'s in that are doubled coz its quoted
20:41:05 <EdwardKmett> but it was to match string literals, number literals or regexp literals without caring which they were ;)
20:43:15 * Korollary wonders whether watching artst movies will rot his brain.
20:43:19 <Korollary> artsy
20:43:51 <EdwardKmett> is the text.regexp.lazy module just traditional posix style regexps or does it have perl-style regexp support?
20:44:32 <EdwardKmett> or whatever the module name is that i forgot
20:44:43 <Korollary> I believe it's posix
20:44:50 <EdwardKmett> bah =)
20:45:01 <Korollary> there are other regexp libs
20:45:03 <EdwardKmett> yeah
20:45:11 <EdwardKmett> i know there is a pcre version
20:45:16 <EdwardKmett> but i was hoping to stay lazy
20:46:06 <EdwardKmett> lazy means that i can let lexing drive the file reading, etc.
20:46:07 <Korollary> in a different context, such a sentence would be construed as quite odd.
20:46:24 <palomer> you're all nuts
20:46:26 <palomer> @palomer
20:46:27 <EdwardKmett> rather than snarf the whole file
20:46:27 <lambdabot> Learning vim is pointless
20:46:48 <EdwardKmett> been using vi in some form or other for 22 years. =)
20:46:50 <Korollary> EdwardKmett: I am not sure you want file i/o driven by lazyness. 
20:47:14 <EdwardKmett> kor: for the parser i wouldn't complain.
20:47:38 <EdwardKmett> kor: the alternative is loading the whole thing, which i suppose i'm also ok with
20:47:43 <EdwardKmett> but its less elegant
20:48:35 <lispy> isn't getContents lazy?
20:48:39 <EdwardKmett> mostly i just want to get a working ecma4 implementation with stm support
20:48:46 <lispy> so you could write it as if you're loading the whole thing but laziness will save you?
20:49:02 <EdwardKmett> lispy: passing to pcre i have to send it as a string
20:49:14 <lispy> @type getContents
20:49:15 <lambdabot> IO String
20:49:39 <EdwardKmett> lispy: so using pcre i have to fully load the file, mangle it into a string and go from there
20:49:45 <EdwardKmett> not very haskelly if you ask me
20:49:57 <palomer> EdwardKmett: I have news for you, it's pointless
20:50:02 <lispy> EdwardKmett: i don't understand where the strictness is coming from
20:50:13 <EdwardKmett> lispy: pcre isn't native haskell its c code
20:50:20 <lispy> EdwardKmett: ah
20:50:24 <EdwardKmett> lispy: with a sugary haskelly coating
20:50:39 <EdwardKmett> isn't palomer just a ray of sunshine? =)
20:50:48 <Korollary> @palomer
20:50:48 <lambdabot> I think vim is good for the rubbish bin
20:50:52 <lispy> EdwardKmett: and you don't like the haskell regexp implementations for various reasons?
20:51:25 <EdwardKmett> lispy: well, i need to use some form of pcre type moddule to handle the javascript regexp object
20:51:34 <lispy> palomer: pointless or pointfree?
20:51:35 <EdwardKmett> so i was trying to avoid using two different modules.
20:52:24 <EdwardKmett> i alway found it greaty amusing that pointfree style involved putting in .'s all over the place. (yes i know the mathematical distinction between points and function composition)
20:53:42 <Korollary> with unicode, maybe a composition operator that looks like one may elimiate that irony
20:53:52 <EdwardKmett> yeah
20:54:20 <EdwardKmett> like i said, give me unicode operators and i'll probably bang out another half-baked computer algebra system =0
20:54:31 <lispy> > let (\cdot) = (.) in 1
20:54:31 <lambdabot>  Parse error
20:55:18 <EdwardKmett> lispy: don't think you can do that one pointfree.
20:56:51 <SamB> certainly not in LaTeX notation
20:56:53 <lispy> i was just thinking we could use latex to get all the weird symbols in there :)
20:57:01 <EdwardKmett> heh
20:57:44 <EdwardKmett> my answer has been in my little pet programming language projects to make the source files valid xml documents, not to add any structure, but just to hand all the arbitrary encodings
20:58:13 <EdwardKmett> and give entity declarations so i could always fall back on a &union; b when i didn't have a unicode terminal
20:58:27 <EdwardKmett> but i guess that would be weird even by haskell standards =)
20:58:39 <Korollary> XML should be enough for everybody.
20:59:04 <SamB> DSSSL does even better
20:59:17 <SamB> it uses SGML, so you don't even have to write any tags!
20:59:40 <EdwardKmett> samb: and all 8 people who know their way around the standard can use it =)
21:00:02 <SamB> you don't have to know SGML to write DSSSL
21:00:24 <EdwardKmett> yeah i know. i first encountered dsssl when i was doing a lot of xsl:fo stuff
21:00:28 <EdwardKmett> still not a big fan of it
21:01:08 <EdwardKmett> the word has moved away from SGML (yea yeah yeeah html and xml are sgml-based, etc)
21:01:16 <EdwardKmett> but its the sgml-isms that make them suck ;)
21:01:36 <lispy> EdwardKmett: actually i was thinking it would be interesting to make a compiler/run-time system where you only define the intermediate code representations and the semantics and then let people build tools for whatever languages.  You could define all your intermediate reps to be in xml since it's a tree structure and many parsers exist
21:01:40 <SamB> those catalog files aren't too shabby, though
21:02:04 <SamB> lispy: DSSSL barely uses SGML in its language
21:02:09 <SamB> it is mostly a SCHEME-like
21:02:10 <lispy> then maybe you'd have a .net like system that is more 'open'
21:02:21 <EdwardKmett> lispy: actually my last project which i started gutting for nefarious money making purposes and so will never see the light of day was just such a language
21:02:56 <dons> EdwardKmett: what got you interested in Haskell? Or've you used it before?
21:03:01 <EdwardKmett> lispy: basically consisted of an editor for a family of 'rich text programming' languages that took care of the first step of parsing and lexing and resolved operator precedence as a PARTIAL ordering
21:03:27 <EdwardKmett> that way the editor could red flag operator precedence ambiguity and make you fix up your code
21:03:48 <EdwardKmett> which is more conducive to an explosion of operators and a richer mathematical syntax that adding another precedence rule to remember.
21:03:53 <lispy> EdwardKmett: i was imagining with my 'compiler' than a front end is all anyone would need to write then there would exist canned transformations once you got to the first intermediat rep.
21:04:10 <lispy> EdwardKmett: interesting
21:04:18 <EdwardKmett> dons: good question, basically what happened is my library of language features kept converging closer and closer to haskell =)
21:04:38 <dons> so you were already familiar with haskell?
21:04:44 <EdwardKmett> lispy: so the editor is an editor for a family of small loadable subgrammars that define operators and relative precedences.
21:05:19 <EdwardKmett> dons: not terribly, i knew it was out there on the fringe of the type system community, and when i went to lookk for stuff on whatever feature i was implementing i kept tripping over it
21:05:35 <EdwardKmett> i got on a haskell kick a little back around 99 or so but the laguage wasn't very mature then
21:06:00 <dons> it's on the fringe?
21:06:05 <EdwardKmett> so i kinda forgot about it, and wound up coming back to it because it was sort of an anti-erlang, when i drifted back towards functional programming
21:06:15 <dons> most research on fp type systems at least is done in haskell these days
21:06:15 <EdwardKmett> dons: well, its where all the cool stuff is being done =)
21:06:34 <dons> yeah
21:06:36 <EdwardKmett> dons: so i guess you could say its where the smart kids are hanging out nowadays
21:06:56 <dons> i think so, more and more we pick up OCaml and ML refugees
21:07:12 <dons> and C++ victims
21:07:18 <dons> hehe
21:07:34 <jgraves> For me, it is the lazy evaluation that makes Haskell really cool.
21:07:35 <SamB> or maybe people who got a whiff of templates and wanted the whole pie ;-)
21:07:40 <EdwardKmett> lispy: basically the editor was a minimal xul app written in firefox which understood enough to talk to the source repository over the network and check in changes
21:08:02 <EdwardKmett> lispy: and compilers just worked across the network talking to the same source repository
21:08:22 <EdwardKmett> samb: yeah. i was doing a lot of template metaprogramming in the intervening years
21:08:43 <EdwardKmett> rewriting code from boost::mpl to haskell is like removing shackles.
21:08:44 <lispy> EdwardKmett: okay, now you're just talking crazy ;)
21:08:57 <lispy> EdwardKmett: (actually it sounds cool, but i have to tease)
21:09:22 <EdwardKmett> lispy: nah, jabber for the network protocol, so i don't care if the editor is behind a firewall, just jabber over the ssl port to a jabber server
21:09:28 <EdwardKmett> and toss xml document fragments around as messages
21:09:31 <EdwardKmett> since thats what jabber does
21:09:53 <audreyt> hm, that reminds me. in perl-land I was doing template autogeneration/autoupgrading and template-based extraction (reversing the template function). I've read some arrow-based reversable parsing+prettyprint paper on last HW, but I havn't seen something comparable in JS or Hs land really
21:10:01 <EdwardKmett> goal was that since the code is now xml (after the first lexing/parsing stage) you can annotate it with loop counts, etc.
21:10:02 <lispy> well, not all is roses when using haskell.  show me an easy to use COM or GUI library for win32 that is actively developed, native looking (in the GUI case) and easy to get going with
21:10:09 <audreyt> this is btw HSP-like template, not C++ template
21:10:38 <Korollary> COM is a bit out of fashion. If anything, haskell <> .net is more likely.
21:10:43 <audreyt> lispy: wxhaskell win32 with mingw?
21:11:20 <EdwardKmett> but the first target for that compiler was javascript to extend the editor so i could bootstrap it
21:11:24 <lispy> audreyt: wxhaskell has some rough corners.  it's what i'm using but wxgrid for example leaves much to be desired.  It also doesn't appear to be developed anymore
21:11:30 <EdwardKmett> which of course led me to start building monolithic apps i javascript
21:11:40 <dons> lispy: right, we don't have enough windows users for windows people to be truly happy
21:11:47 <EdwardKmett> which of course let to the current situation where i now know far more about javascript than i ever wanted to learn ;)
21:11:49 <dons> too many pointy-hedaed linux/bsd hackers
21:12:06 <lispy> dons: yeah, that's my favorite platform...stupid paying job :(
21:12:23 <audreyt> lispy: yeah. we need a good cabal-{install,put} (where's xerox anyway?) before we can apply CPAN's horde technique to solve bitrot problem
21:12:27 <lispy> they make me develop for win32...but oh well, it's a learning experienc
21:12:42 <dons> audreyt: right. that's the critical next step
21:12:44 <audreyt> basically, if you have enough number of newcomers as human sacrifice, you'll do fine :)
21:12:55 <lispy> heh
21:13:20 <audreyt> in Pugs we've seen linear commits and linear committers
21:13:38 <audreyt> which means each commiter basically commits a constant number of revs at average and then leave
21:13:39 <lispy> gtk2hs looks nice but it doesn't use very many native dialogs so our users would be really put off by it
21:13:42 <audreyt> so the whole thing is based on attrition
21:13:46 <EdwardKmett> heh
21:13:48 <EdwardKmett> yeah
21:14:00 <EdwardKmett> i admit i threw some stuff at cpan way bak
21:14:02 <EdwardKmett> er back
21:14:06 <SamB> audreyt: I wonder what the figures are for lambdabot
21:14:08 <EdwardKmett> but it has definitely bitrotted by now
21:14:32 <audreyt> yeah, Parse::Lexer, Language::Style, Chart::Pie3d
21:14:35 <dons> SamB: similar I think. though we've had 55 unique contributors to lambdabot and fps in the last 12 months, which i think is great
21:14:41 <dons> way up on the pre-darcs days
21:14:41 <EdwardKmett> heh
21:14:44 <dons> way way way up
21:14:44 <lispy> audreyt: yeah, i think in recent times #darcs has had most of it's new visitors come over with questions about getting the pugs source
21:15:09 <SamB> well yeah
21:15:21 <SamB> you can't have had many contributors before darcs -- that doesn't count
21:15:48 <dons> sure, but it shows how darcs has lowered the cost of the commit bit, helping everybody out
21:16:03 <dons> the haskell wiki is similar, with even cheaper commit bits than darcs
21:16:33 <dons> so we can guesstimate some results for a wiki-ish hackage db
21:16:44 <blackdog> heyo you lot.
21:16:53 <dons> oh my, blackdog !
21:16:57 * Korollary high-fives blackdog 
21:16:59 <dons> ?vixen-on
21:16:59 <lambdabot> What's this channel about?
21:17:06 <dons> vixen, meet your creator!
21:17:07 <lambdabot> we all have a little vixen in us
21:17:08 <blackdog> aw, just for me?
21:17:09 <lambdabot> let me answer that later, okay?
21:17:12 <blackdog> you're sweet, don
21:17:12 <lambdabot> thanks, you're pretty sweet yourself
21:17:16 <SamB> haha
21:17:17 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please.. ill know!
21:17:26 * basis lol
21:17:27 <lambdabot> there is nothing going on in your pants that the dictatorship of the proletariat will not solve
21:17:30 <dons> ?vixen-off
21:17:30 <lambdabot> Bye!
21:17:39 <SamB> http://domain.invalid/not-a-real-photo.jpg
21:17:41 <dons> just for blackdog.
21:17:47 <blackdog> thanks, dude, i was going to tell her to shut up myself...
21:17:53 <blackdog> got to treat 'em mean.
21:18:02 <dons> that's the spirit
21:18:06 <Korollary> blackdawg?
21:18:11 <SamB> dawg!
21:18:15 * lispy even contributed to the new haskell wiki, i helped with syntax highlighting
21:18:17 <blackdog> hells yeah
21:18:44 <blackdog> i'm a little bewildered that my mere appearance in the channel can engender such a spirited rise in silliness...
21:19:07 <dons> well, you started vixen, i think
21:19:12 <dons> startled
21:19:13 <blackdog> anyway, i need to ask a really stupid newbie question, on account of not having hacked haskell for months...
21:19:20 <SamB> how would you know -- did you check the logs to see how silly we were acting before you joined?
21:19:38 <blackdog> :) yeah, she's been messaging me for a while. some girls just don't know when to let go.
21:19:56 <blackdog> SamB: nah, I just know what a desperately intelligent lot you all are.
21:20:12 <SamB> that doesn't have much correlation to our level of silliness either way
21:20:21 <blackdog> anyway. Question, dammit. How do i implement Read?
21:20:23 <SamB> except maybe that we aren't stupid enough to avoid it
21:20:27 <SamB> heh
21:20:29 <SamB> well...
21:20:33 <dons> deriving ?
21:20:37 <lispy> sortof off topic but...anyone here play Kingdom of Loathing?
21:20:37 <SamB> you probably use that there ReadP thing
21:20:42 <SamB> @hoogle ReadP
21:20:42 <lambdabot> Text.ParserCombinators.ReadP :: module
21:20:43 <lambdabot> Text.ParserCombinators.ReadP.ReadP :: data ReadP a
21:20:43 <lambdabot> Text.ParserCombinators.ReadPrec :: module
21:20:50 <dons> blackdog: you can't derive it?
21:20:54 <blackdog> it's a really simple implementation
21:21:00 <SamB> see this module: Text.ParserCombinators.ReadP
21:21:18 <blackdog> no, it's for my own datatype - i want Wildcard to be read as the character '?', and all other characters to represent themselves
21:21:36 <SamB> hey wait
21:21:40 <blackdog> SamB: you really need to bring out the parser combinator guns for omething this simple?
21:21:56 <SamB> of course!
21:22:02 <SamB> unlimited ammo and all that!
21:22:03 <blackdog> i have this for Read:
21:22:04 <blackdog> instance Show Tile where
21:22:04 <blackdog>   show Wildcard = "?"
21:22:04 <blackdog>   show (Letter c) = [c]
21:22:09 <blackdog> sorry, Show
21:22:19 <dons> can't you munge your input into a deriving-Read'able form
21:22:25 <dons> i've done that occasionally
21:22:32 <SamB> dons: that sounds awful
21:22:32 <dons> i.e. read . munge 
21:22:37 <dons> nah, not so!
21:22:44 <SamB> well, in this case it does
21:22:47 <dons> munge might just do '?' = "WildCard"
21:23:02 <audreyt> yeah, what's wrong with dons's approach?
21:23:05 <SamB> well...
21:23:12 <audreyt> except for the lack of unlimited ammo?
21:23:28 <SamB> because "Letter 'c'" /= "c"
21:23:42 <dons> sure, this is a 4 liner 
21:24:04 <SamB> parser combinaters are teh better
21:24:43 <blackdog> it's not too bad a solution, but i'm curious why you can't do it directly, without resorting to parser combinators - am i missing something obvious?
21:25:00 <SamB> the fact that your code would probably be uglier that way?
21:25:08 <audreyt> but Read is implemented as parser combinator in ReadP anyway
21:25:09 <dons> well read instances need combinator hackiyfing
21:25:21 <dons> munge ('?':xs) = "WildCard" ++ munge xs
21:25:21 <dons> mugne (x:xs)   = "Letter " ++ x : munge cs
21:25:37 <SamB> dons: that doesn't work does it?
21:25:38 <dons> verusus some custom Read instance, depends on what you want to do
21:25:44 <dons> something like that would though
21:25:57 <dons> depends on what it looks like shown
21:25:58 <SamB> munge (x:xs)   = "Letter " ++ show x : munge cs
21:26:05 <blackdog> audreyt: hm, didn't know that. thanks. 
21:26:09 <dons> right
21:26:15 <SamB> note the "show"
21:28:44 <blackdog> so an implementation for the instance should look something like
21:28:55 <blackdog> instance Read Tile
21:29:06 <blackdog> read blah = some cambinator expression
21:29:07 <blackdog> ?
21:29:14 <blackdog> insert where after Tile
21:29:20 <SamB> I'm pretty sure that read is not the method
21:29:30 <SamB> in fact, positive
21:29:44 <SamB> @hoogle ReadS -> a
21:29:45 <lambdabot> No matches, try a more general search
21:29:47 <SamB> @hoogle ReadS
21:29:47 <dons> here to illustrate is Read Maybe:
21:29:48 <lambdabot> Prelude.ReadS :: type ReadS a
21:29:48 <lambdabot> Prelude.reads :: Read a => ReadS a
21:29:48 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
21:29:49 <dons> instance Read a => Read (Maybe a) where
21:29:49 <dons>   readPrec =
21:29:49 <dons>     parens
21:29:49 <dons>     (do L.Ident "Nothing" <- lexP
21:29:52 <dons>         return Nothing
21:29:54 <dons>      +++
21:29:57 <dons>      prec appPrec (
21:29:59 <dons>     do L.Ident "Just" <- lexP
21:30:02 <dons>            x              <- step readPrec
21:30:04 <dons>            return (Just x))
21:30:07 <dons>     )
21:30:09 <dons> from GHC.Read
21:30:10 <EdwardKmett> dons: oh, now i remember what put me back on a haskell kick in particular it was an article in an AMA journal that used haskell to reformulate a spigot algorithm from a fixe number of places to a lazy algorithm for an arbitrary number of places in haskell.
21:30:22 <dons> oh, i read that paper this morning :)
21:30:28 <dons> yeah , spigot is cool. 
21:30:42 <dons> it became a langauge shootout benchmark too, which we were leading, last time I checked
21:31:01 <dons> it also one the '04 haskell obfuscation contest (in at least one category)
21:31:02 <EdwardKmett> dons: my little CAS projects were all doing all sorts of tricks to get lazy evaluation for Cauchy sequences, etc. its a hell of a lot easier in haskell.
21:31:14 <dons> language support is super useful for laziness
21:31:26 <EdwardKmett> so i thought i might try something more robust, hence the parser
21:31:55 <SamB> yeah, its a pain to implement closures in J. Random Language
21:31:56 <dons> ah, here we are , http://shootout.alioth.debian.org/gp4/benchmark.php?test=pidigits&lang=all
21:31:57 <lambdabot> Title: "pidigits benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..."
21:32:05 <dons> oh, but we've lost the lead . still the shortest though, I think
21:32:09 <SamB> though at least in Slate it is not *too* hard
21:32:12 <EdwardKmett> and it doesn't hurt that the ecma structural subtyping is very haskellish either.
21:36:04 * dons hacks on new eval library, evalC :: CSource -> IO ()
21:36:29 <EdwardKmett> dons: ?
21:38:58 <dons> oh, I've a library, hs-plugins, for runtime haskell evaluation. I'm adding runtime C evaluation to it.
21:39:20 <dons> useful for numerically intensive problems, since the code can be specialised at runtime to each problem instance
21:39:21 <SamB> oooooooh
21:39:21 * audreyt ponders porting the entire Inline.pm to Haskell follwoing that
21:39:29 <EdwardKmett> heh i note that the great language shootout doesn't have the ability to say 'errors caught at compile time', 'errors caught at runtime' because of the nature of the beast. kinda skews it towards script languages a bit
21:39:33 <dons> (like the Fastest Fourier Transform thingy in OCaml)
21:39:39 <EdwardKmett> dons: ahh
21:39:43 <EdwardKmett> dons: heh
21:40:00 <EdwardKmett> last fft i wrote was a template metaprogramming monstrosity
21:40:04 <Korollary> FFTW at runtime eh
21:40:45 <EdwardKmett> generated all the multiplicative factors in the templates (which required me to manually compute exponent and mantissa) damn stroustrop not allowing floats as template parameters!
21:40:46 <dons> yeah, so you generate a C source for your problem, hopefully applying some inlining and #defining, then we let gcc go nuts (picking up any cpu-specific flags, for example)
21:41:08 <dons> it'll be nicer once we have Language.C to help build the src combinator-style
21:41:32 <EdwardKmett> i'm slowly slogging on Language.Ecmascript, but that won't do you much good ;)
21:41:34 <SamB> how about evalC++?
21:41:56 <dons> well, we'd have to work out a generic system for ffi'ing C++ 
21:41:59 <EdwardKmett> dons: so you generate code, then link?
21:42:01 <dons> using wrappers
21:42:04 <SamB> true
21:42:06 <dons> yep, link back in dynamically
21:42:08 <EdwardKmett> dons: er compile and link?
21:42:25 <dons> generate, compile, link then jump
21:42:38 <EdwardKmett> dons: solid enough
21:42:42 <dons> and briefly the evil C personality takes over your haskell program
21:42:48 <SamB> um
21:42:58 <EdwardKmett> dons: how crufty is the syntax forced to be though?
21:43:01 <SamB> thats not too evil
21:43:11 <SamB> syntax?
21:43:15 <SamB> you mean C syntax?
21:43:23 <EdwardKmett> the c-in-haskell syntax
21:43:24 <dons> however, it lets you essentially generate arbitrary custom C for your haskell code, so who cares about that ghc does in the backend-- you can generate your own domain specific code
21:43:29 <EdwardKmett> do you have to write it all as string literals?
21:43:37 <EdwardKmett> or do you get some sugar? =)
21:43:50 <dons> currently i have some Doc/Text.PrettyPrint sugar
21:44:05 <dons> but ideally we'd use Language.C (a google project being worked on for the SoC)
21:44:29 <SamB> next summer will we get a C compiler?
21:44:42 <EdwardKmett> ahh
21:44:50 <dons> SamB, you volunteering?
21:44:54 <SamB> no
21:45:03 <audreyt> mm HCC
21:45:10 <SamB> I might be able to do it
21:45:39 <EdwardKmett> heh ported lcc to javascript, shouldn't be too bad to build a haskell backend for it =)
21:45:54 <EdwardKmett> argh
21:46:47 <EdwardKmett> of course that doesn't give you everything you need
21:48:09 <EdwardKmett> then again since i have an lcc port to javascript and am writing a javascript port to haskell, that woud mean you could run a c virtual machine over haskell in a fashion but it'd be dog slow
21:48:34 <EdwardKmett> and it wouldn't be native c
21:48:43 <EdwardKmett> it'd be c in a little play arena
21:50:18 <dons> I wonder if we can think up some more good examples for when runtime-evaluated (and specialised) C would be good
21:50:25 <dons> currently i have a polymer simulation
21:50:33 <dons> and I suppose fft as well
21:50:40 <EdwardKmett> fft, linear algebra code
21:50:51 <EdwardKmett> a haskell blas wouldn't suck =)
21:51:24 <dons> is that the graph library in C++?
21:51:28 <EdwardKmett> theres probably one out there but dynamically generating c code for arbitrary types would be cool
21:51:47 <EdwardKmett> blas = basic linear algebra system
21:51:51 <dons> ah yes.
21:51:57 <EdwardKmett> atlas, micro-blas, etc.
21:52:23 <EdwardKmett> usually written in fortran and linked together into monolithic libraries of various orders
21:53:01 <EdwardKmett> because noone these days wants to write eigensystem solvers and before c99 you couldn't get decent proof against aliasing in the compiler
21:58:51 <Korollary> I can't recall the title of a book, whose reviews I liked, for the life of me.
21:59:19 <Axio[Bnk]> Hi
21:59:38 <EdwardKmett> never really thought about polymer simulation before
22:00:12 <Axio[Bnk]> err.. Matching a string, how do I test whether head is a alpha char or a num char ?
22:01:00 <Korollary> @index isAlpha
22:01:01 <lambdabot> Data.Char
22:01:08 <Korollary> @index isDigit
22:01:08 <lambdabot> Data.Char
22:01:26 <dons> EdwardKmett: oh, it's quite cool. monte carlo simulation of every molecule in a big vat,  stir/randomise occasionally, count the polymer chain lengths when done, draw pretty graphs
22:01:37 <EdwardKmett> yeah what korollary said =)
22:02:00 <Axio[Bnk]> ha thanks... I was going for a   if map x [0;1;2;3;4;5;6;7;8;9].... :)
22:02:09 <EdwardKmett> dons: did some bioinformatics work for a graduate certificate a while back of similar nature
22:02:39 <dons> > let headIsAlpha [] = False ; headIsAlpha (c:_) =  isAlphaNum c in headIsAlphaNum "haskell"
22:02:40 <lambdabot>  Not in scope: `headIsAlphaNum'
22:02:53 <dons> > let headIsAlpha [] = False ; headIsAlpha (c:_) =  isAlphaNum c in headIsAlpha "haskell"
22:02:53 <lambdabot>  True
22:02:59 <dons> > let headIsAlpha [] = False ; headIsAlpha (c:_) =  isAlphaNum c in headIsAlpha "!haskell"
22:02:59 <lambdabot>  False
22:05:47 <EdwardKmett> to nab ghc 6.5 as it stands the best option i have is to grab the ghc head branch right, they don't have a 6.5 branch in there do they?
22:06:34 <sjanssen> > foldr (const . isAlphaNum) False "haskell"
22:06:35 <lambdabot>  True
22:06:52 <dons> ah, the head/foldr rule :)
22:07:30 <dons> EdwardKmett: you need to either download the nightly 6.5 build, or use darcs to take ghc head, yes.
22:07:38 <EdwardKmett> kk
22:07:41 <dons> sjanssen: any tasty patches for me?
22:07:49 <EdwardKmett> i want to play with the operators
22:08:06 <dons> the unicode ones?
22:08:08 <EdwardKmett> yeah
22:08:25 <dons> also, forall, exists and lambda are keywords (the unicode versions)
22:08:30 <dons> oh, maybe not exists
22:08:34 <EdwardKmett> i spent 3-4 years in my basement writing compilers for unicode based languages man, comeon =)
22:08:42 <dons> sjanssen: hugs fixes. 
22:08:46 <dons> ?karma+ sjanssen
22:08:46 <lambdabot> sjanssen's karma raised to 10.
22:08:51 <EdwardKmett> not a whole heck of a lot to show for it in retrospect
22:08:57 <sjanssen> wha?  hugs fixes?
22:09:03 <Pegazus> Hi, does anyone know any automatic tool to check if a given grammar is LL, LR, of simple predecentes, ambiguos, and other properties? (or a tool that just check for at least one of those thing is good too), does anyone know any way to do this without doing it by hand?
22:09:10 <dons> Thu Jul  6 13:59:58 EST 2006  Spencer Janssen <sjanssen@cse.unl.edu>
22:09:10 <dons>   * Hugs fixes
22:09:30 <Pegazus> of simple predecentes --> or simple precedence
22:09:33 <dons> it's good to remember hugs, nhc and so on. karma-worthy.
22:09:40 <sjanssen> oh, I see
22:09:40 <EdwardKmett> peg: well you can always run it through yacc and check out the shift-reduce conflicts =)
22:09:55 <sjanssen> dons: no patches quite yet, I've been reading other people's code
22:09:57 <Pegazus> yacc what parser uses?
22:10:04 <dons> ok. looking at unicode?
22:10:20 <EdwardKmett> yacc is LALR
22:10:25 <Pegazus> (i mean i want to know the "minimal" or least power grammar that can parse it)
22:10:37 <Pegazus> and yacc won't tell me if it is LR(0) or SLR if it is LALR
22:10:38 <EdwardKmett> peg: ah
22:10:45 <sjanssen> dons: yeah, and Simon Marlow's packed string code
22:10:49 <Pegazus> (and my grammar is parsed by yacc by the way, so it's LALR)
22:10:53 <EdwardKmett> peg: hrmm
22:10:55 <Pegazus> :)
22:11:03 <Pegazus> i think it's LL(1) too
22:11:12 <EdwardKmett> peg: well you might try running it through frown and checking the resulting automaton, it only uses lookahead when needed
22:11:23 <EdwardKmett> so you can check to see if it bothers to 
22:11:32 <dons> sjanssen: ok. good. you could start with simon's code and try to get empty/head/tail/drop/take and so on working?
22:11:38 <EdwardKmett> but neither of these is a particularly formal approach =)
22:11:38 <Korollary> Holy crap. The book I couldnt remember was already in my wish list. Tee hee.
22:11:45 <Pegazus> :/ how do i check it?
22:11:54 <sjanssen> I've realized that the Unicode string is going to be largely a copy paste job of ByteString, and changing stuff from byte to Word32
22:12:01 <sjanssen> dons: I think ByteString is a better base
22:12:02 <dons> hmm. interesting
22:12:03 <EdwardKmett> peg: it has a command line option to view the resulting automaton
22:12:13 <dons> sjanssen: i.e. cpp-ify it? like Simon did?
22:12:22 <EdwardKmett> peg: the documentation should tell you a little more about the internals of it so you ca figure out if its using the lookahead modes.
22:12:23 <Pegazus> mmm good, thanks!
22:12:39 <sjanssen> dons: I'm not sure what bugs me more . . . cpp-ifying or copy and pasting
22:12:45 <sjanssen> both seem ugly
22:12:45 <dons> so you #defined WORDSIZE CHARBITS and so on
22:12:50 <EdwardKmett> peg: won't help ypou with the LL side of things, though
22:12:55 <dons> cppy would be better, less bugs
22:13:02 <sjanssen> yeah
22:13:08 <Pegazus> :)
22:13:12 <Pegazus> thanks
22:13:21 <sjanssen> another thing I was wondering about, was the StorableVector idea
22:13:34 <dons> yeah, that's the other option. paramaterise on the element type
22:13:47 <EdwardKmett> sjanssen ahh thats where i saw your name before, you're the guy doing the unicode bytestring stuff right?
22:13:47 <sjanssen> how hard do you think getting fusion rules to work polymorphically?
22:13:57 <dons> not too hard
22:13:58 <sjanssen> EdwardKmett: indeed.
22:14:03 <dons> i.e. they already do it in the ndp array code
22:14:12 <dons> it slows things down just a tad, iirc
22:14:25 <EdwardKmett> pleased to make your acquaintance, get cracking, i want to use it ;) 
22:14:39 <sjanssen> EdwardKmett: yessir
22:14:43 <EdwardKmett> =)
22:14:58 <dons> sjanssen: if it was to behvae like Array.Unboxed (i.e. a few unboxed types could go in), that would be a good result
22:15:09 <EdwardKmett> actually, how is it coming along?
22:15:25 <EdwardKmett> i've been finding lots of cool toys i want to play with that i need to wait til after the summer of code for
22:15:30 <dons> though I'd stil be happy to have you move Data.ByteString to ByteString.hs.inc and then cpp it, as Simon did.
22:15:32 <EdwardKmett> hsjudy also come to mind
22:16:41 <sjanssen> dons: I think I'll shoot for Storable Vector -- should be pretty straightforward starting from ByteString
22:16:55 <dons> ok.
22:17:31 <dons> it's more work, of course
22:17:45 <dons> though probably not a huge amount.
22:18:05 <dons> since we already peek/poke. you'll need to audit for hardcoded Word8 peek/pokes
22:18:21 <sjanssen> yeah, I'll lean hard on the quickchecks for that
22:18:37 <dons> just grepping for Word8 in the src should help too
22:18:56 <dons> once you start building up your vector lib.
22:25:34 <sjanssen> dons: is there a paper (or code) I can read about the ndp fusion?
22:26:31 <dons> yeah, let me find the references
22:26:39 <EdwardKmett> is there a haskell implementation of something like the SGI rope template?
22:26:59 <sjanssen> EdwardKmett: you seem to be interested in things I'm working on!
22:27:01 <dons> though the exact things we're doing aren't yet written up, they have precursors in some papers by my supervisors
22:27:17 <EdwardKmett> sjanssen: heh
22:27:21 <sjanssen> EdwardKmett: part of my SoC project
22:27:28 <EdwardKmett> nifty keen =)
22:27:32 <EdwardKmett> how far along?
22:27:44 <EdwardKmett> i was going to start banging one out today if i hadn't found one ;)
22:27:50 <dons> sjanssen: http://www.cse.unsw.edu.au/~chak/papers/CK01.html
22:27:51 <lambdabot> Title: "Research Papers of Manuel Chakravarty"
22:28:01 <sjanssen> EdwardKmett: pretty close, I'd love it if I had a user
22:28:14 <dons> also, http://www.cse.unsw.edu.au/~chak/papers/CK03.html
22:28:15 <lambdabot> Title: "Research Papers of Manuel Chakravarty"
22:28:39 <sjanssen> EdwardKmett: http://darcs.haskell.org/SoC/fps-soc/ is the darcs repo
22:28:41 <lambdabot> Title: "Index of /SoC/fps-soc"
22:28:50 <EdwardKmett> sjanssen if the performance is there i'll wrap a javascript interpreter around it, strings are the majority of what the language works on
22:29:04 <dons> more info here http://www.cse.unsw.edu.au/~chak/project/dph/
22:29:04 <EdwardKmett> and fast slicing and splicing is critical
22:29:04 <lambdabot> Title: "Manuel M T Chakravarty - Data Parallel Haskell"
22:29:08 <EdwardKmett> ropes shine there
22:29:32 <dons> EdwardKmett: the fps library is already used in pugs, as its speed-critical string library, afaik
22:29:43 <dons> sjanssen's extending that library
22:29:50 <sjanssen> EdwardKmett: this is unfinished, untested, and undocumented so far
22:29:58 <EdwardKmett> fps is the traditional c style string library
22:30:06 <dons> hmm, not really.
22:30:07 <sjanssen> EdwardKmett: you might wanna wait a bit before trying it
22:30:12 <EdwardKmett> sjanssen thats ok, i'm not exactly in a production quality state myself
22:30:20 <dons> how do you mean 'traditional c style'?
22:30:25 <dons> ?where fps
22:30:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:30:28 <EdwardKmett> dons: that was meant to have a ? on it =)
22:30:29 <dons> there's the api, anyway
22:30:38 <dons> no, its not like C :)
22:30:55 <dons> its like a much much faster pure, functional string lib
22:31:03 <EdwardKmett> ah
22:31:06 <EdwardKmett> skimming
22:31:17 <EdwardKmett> then my understanding was in error and i will read in more depth =)
22:31:38 <dons> it uses unboxed byte arrays and fusion via equational term rewriting to beat C at its own game. 
22:31:49 <EdwardKmett> ok, but the idea is that it manipulates little chunks of unboxed byte arrays right?
22:32:05 <dons> hmm, i suppose so.
22:32:10 <dons> they can be big chunks
22:32:15 <dons> gigabyte big, if you like
22:32:24 <dons> or L1-cache size, if you use the lazy api
22:32:48 <EdwardKmett> see, my main usage pattern is slicing and splicing little strings in the middle of potentially large strings
22:32:59 <dons> substrings are O(1)
22:33:09 <EdwardKmett> thats why i'm kinda in favor of something like a rope rather than a traditional string library
22:33:10 <dons> since its purely functional, we can share the strings around
22:33:11 <dons> so no copying
22:33:43 <sjanssen> sharing unless you do an append operation (unless you use lazy bytestrings)
22:33:48 <dons> splicing involves copying, of course. unless you use the lazy api, where instead of O(n) splicing, it's O(n/k), where k is length/chunk size
22:33:51 <EdwardKmett> typoial usage pattern, would be to take a string representing an xml document, say, and insert another xml fragment inline in the middle
22:34:03 <EdwardKmett> hrmm
22:34:08 <EdwardKmett> might just give that a whirl
22:34:19 <EdwardKmett> i'm still getting my head around the libraries that are here in haskell
22:34:35 <dons> the large list of them is at 'libraries and tools' on haskell.org
22:34:39 <EdwardKmett> i go away for several years and you rewrite the language on me. hmmmf ;)
22:34:42 <dons> that's most of what's been publically released
22:35:00 <EdwardKmett> yeah read through them, i just misunderstood the scope of this library on first glance
22:35:02 <dons> and of course, the standard libraries, on haskell.org as well
22:35:18 <dons> ah, how so? perhaps i can clarify the abstract 
22:35:24 <EdwardKmett> and you have to admit that haskell libraries are not very well documented =)
22:35:26 <sjanssen> EdwardKmett: the usage pattern you mention would work pretty well with lazy bytestrings
22:35:36 <dons> EdwardKmett: in some cases, yes.
22:35:54 <EdwardKmett> most people seem to think that haddock is just fine, and give maybe a line of comments to explain each function if you're lucky ;)
22:36:11 <dons> EdwardKmett: you read about fps where? on haskell.org or on the fps home page?
22:36:25 <dons> i.e. here http://haskell.org/haskellwiki/Libraries_and_tools/Data_structures#Strings
22:36:27 <lambdabot> Title: "Libraries and tools/Data structures - HaskellWiki"
22:36:29 <dons> or 
22:36:31 <dons> ?where fps
22:36:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:37:09 <EdwardKmett> i dunno about you but i tend to find haddock generated docs to be relatively opaque
22:37:23 <dons> they can be good, but good ones are rare
22:37:25 <Korollary> it's the human factor. Not haddock heh.
22:37:53 <dons> i think this is pretty good http://www.cse.unsw.edu.au/~dons/fps/Data-ByteString.html , but maybe i'm biased ;)
22:38:19 <dons> maybe it assumes too much. I'd be interested in feedback.
22:38:20 <EdwardKmett> usage example take a language far =)
22:38:37 <EdwardKmett> i think i see one for the group function. not sure about any others =)
22:38:55 <dons> hmm.
22:38:58 <EdwardKmett> i realize with something as generic as a string library that sounds pretty contrived
22:39:07 <EdwardKmett> but it is a pretty much core piece of functionality
22:39:42 <EdwardKmett> haskell documentation always seems to suffer a bit of a platform problem. its never sure of who its talking to. 
22:39:44 <dons> yes, a tutorial walking through the api would be very useful
22:40:02 <EdwardKmett> it seems written to the person who already knows the ins and outs of the language and who wants to write everything pointfree
22:40:12 <dons> right.
22:40:30 <Korollary> "Terse"
22:40:30 <dons> alternatively, there's some good ones here
22:40:34 <EdwardKmett> but it doesn't render things very accessible to someone trying to get their head around the language from the get go. 
22:40:35 <dons> @docs Control.Concurrent
22:40:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
22:40:39 <dons> @docs Control.Exception
22:40:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
22:40:40 <EdwardKmett> terse is great
22:40:55 <EdwardKmett> i've been coding under a 'Dont Repeat Yourself' principle for years =)
22:41:00 <dons> oh, you're not supposed to learn the language from haddocks, though.
22:41:13 <EdwardKmett> sure, but i'd like to learn the usage of the library in question
22:41:31 <Axio[Bnk]> Can't I write  "if foo == Cons _"   (as I would in ML with a single "=") ?
22:41:35 <dons> one thing we have is that almost all the libraries are documented in research papers
22:41:45 <dons> which can be found on haskell.org, but the average person doesn't chase up
22:41:50 <EdwardKmett> yeah but the problem is they drift out of date
22:41:56 <dons> that too
22:42:07 <EdwardKmett> thats how i learned the current view of Monads and Arrows
22:42:09 <sjanssen> Axio[Bnk]: no, you need to use a case expression
22:42:22 <Axio[Bnk]> sjanssen, ok
22:42:37 <EdwardKmett> though i had a couple years of category theory under my belt, would be scared for someone who didn't at least do a masters in mathematics first ;)
22:42:42 <sjanssen> Axio[Bnk]: case foo of (Cons _) -> ...; _ -> ...;
22:42:43 <dons> > case [1,2] of [] -> False ; [_] -> False ; [_,_] -> True -- perhaps?
22:42:44 <lambdabot>  True
22:43:04 <dons> > case [1,2] of [] -> False ; _:[] -> False ; _:_:[] -> True -- maybe
22:43:05 <lambdabot>  True
22:43:25 <dons> assuming Cons means : (maybe you have your own Cons?)
22:44:48 <EdwardKmett> but even that tripped me up because then i wandered in here wondering why the definition of Functor wasn't a definition for a Functor =)
22:44:57 <dons> hehe
22:45:46 <Axio[Bnk]> dons, I have my own. Just was a dummy constructor name
22:46:38 <dons> ah, ok, so yeah, use 'case', our pattern-matching syntax
22:49:43 <EdwardKmett> there is no hash table that isn't shackled to an IO or STM monad is there?
22:50:14 <EdwardKmett> for when i want lookup to be fast but don't give a rat's ass how long setup takes? =)
22:51:26 <EdwardKmett> i realize i could just build an array, stuff everything in it and freeze it, but thats seems clunky
22:54:48 <dons> it'd only be 1 line though
22:55:27 <dons> you're options are a) Map, b) HashTable (in IO) c) roll your own array d) lists (no thanks)
22:55:32 <dons> maybe there's some others
22:56:05 <EdwardKmett> dons: k, yeah only additional one i know is a summer of code project to port judy, but that also io based
22:56:28 <EdwardKmett> it just happens to have nice performance characteristics and be designed for cache hits
22:57:13 <sjanssen> EdwardKmett: perhaps you can write a wrapper around the judy (or HashTable) lib that uses unsafePerformIO all over
22:57:19 <EdwardKmett> the last posted version the author had of that had some bugs in its api
22:57:53 <EdwardKmett> sjanssen thats kinda what i was thinking about doing with a rope based api =)
22:58:15 <EdwardKmett> sjanssen replace ropes with equivalent flat ropes on an as-needed balancing basis
22:58:33 <EdwardKmett> let iterators continue to iterate over the old one, and have the garbage collector pick them up
22:58:39 <palomer> if it's written in vim, it won't work
22:59:28 <EdwardKmett> use unsafePerformIO to do the flattening and rely on the fact that through the api referential transparency is preserved.
22:59:50 <EdwardKmett> though
22:59:59 <EdwardKmett> i'm not even sure i need unsafePerformIO there
23:00:24 <EdwardKmett> since the sgi rope api and the older boehm cord code can run immutably without too much of a performance hit
23:01:00 <EdwardKmett> btw- i find the data.bytestring.fusion documentation incredibly abstruse =)
23:01:17 <EdwardKmett> if you don't know what the module does, you never find out what the module does =)
23:01:25 <palomer> I'm shocked at how infrequently I'm consulted on the feasibility of exporting these projects to overseas developers in the north of canada
23:02:03 <dons> oh, the Fusion.hs module? 
23:02:12 <dons> it's not even meant for public consumption. that's a known bug
23:02:17 <EdwardKmett> heh
23:02:19 <dons> the real docs are in an upcoming paper
23:02:22 <EdwardKmett> =)
23:02:30 <EdwardKmett> ahh the world of academics =)
23:02:31 <dons> thanks for reminding me actually, i'll put a todo in a try to fix the haddocks this week
23:02:44 <EdwardKmett> its either in an upcoming paper or an out of date paper =)
23:03:09 <dons> well, at least the code's available :)
23:03:15 <EdwardKmett> heh
23:03:32 <palomer> seriously, this obsession with papers is very annoying
23:03:39 <palomer> the world of academics should switch to a wiki system
23:03:44 <EdwardKmett> even if a significant fraction of the people out there who can read it are all on this channel =)
23:04:11 <palomer> papers are an obseleted concept
23:04:13 <dons> that's somewhat true :/
23:05:06 * audreyt points to the "Powered by Ph.D." drawing
23:05:18 <EdwardKmett> heh
23:05:24 <sjanssen> paper is an obsoleted concept
23:05:44 <audreyt> # http://perlcabal.org/~audreyt/taipei/phd.png
23:05:52 <dons> audreyt: my 3rd review is on wednesday. so you're graphic will get another run :)
23:06:01 <EdwardKmett> i'm stalled after a couple of masters degrees. no wonder i find haskell daunting at times. i didn't pick up the right credentials =)
23:06:14 <audreyt> dons: woot
23:06:33 <audreyt> EdwardKmett: ...and as a junior high school dropout... I don't even stand a chance =)
23:06:37 <palomer> advantages of wiki vs papers: can be updated and added upon by other people, potentially unoutofdateable
23:07:05 <palomer> I seriously think that haskell ability has nothing whatsoever to do with the number of papers that tell you you're a champ
23:07:06 <audreyt> I think wiki in the original Hawaiian means "I can't find any damned thing".
23:07:13 * audreyt much prefers haddock+darcs
23:07:26 <dons> @remember audreyt I think wiki in the original Hawaiian means "I can't find any damned thing"
23:07:26 <lambdabot> Done.
23:07:29 <dons> :)
23:08:05 <audreyt> "Where did you put your glasses?" "Wiki!"
23:09:01 <EdwardKmett> audrey: heh. i basically went back to school 2 and a half years ago and went degree collecting, before that i had a high school diploma and ten year dot-com rollercoaster ride.
23:09:10 <cerberus> can haskell break a jbo into many small jobs and distribute the work among many computers?
23:10:04 <dons> it is certainly possible to do distributed programming in haskell, but it doesn't just happen magically
23:10:08 <EdwardKmett> audrey: seem to recall from some interview or something i read of yours that you were big o autodidactism - i just got sick of having to constantly prove myself, so decided to get the papers to shove in people's faces.
23:10:15 <EdwardKmett> er big into
23:11:39 <audreyt> *nod*
23:12:31 <audreyt> yeah. totally quit school at 15 (but that's after, wow, 10 schools) to join dot-com startup... it's ten years this year
23:12:59 <bringert> man, web browsers suck
23:13:20 <EdwardKmett> i made it through school, got into university of michigan, and quit midway through my first semester to go work for ford, then did a bunch of dot-com stuff from there
23:13:21 <bringert> none of them implement multipart/form-data correctly
23:13:25 <bringert> or even sanely
23:13:50 <palomer> EdwardKmett: you were sick of having to prove yourself so you decided to get diplomas?
23:14:15 <EdwardKmett> pal: yeah, several years as a CTO, no formal education made it hard to get a real job
23:14:42 <EdwardKmett> no entry level programming stuff would take me cause they wouldn't think i'd stay, nothing higher in the management food chain because i lacked pieces of paper
23:15:26 <EdwardKmett> pal: so i figured i'd vault to the other side of the education spectrum =)
23:16:03 <palomer> why not just get an MBA?
23:16:09 <EdwardKmett> heh
23:16:10 <EdwardKmett> well
23:16:25 <EdwardKmett> when i returned i was going to do an undergraduate degree in actuarial science and economics and do my mba
23:16:42 <EdwardKmett> and go back to being a guy in a suit doing dog and pony shows for wall street
23:17:01 <palomer> ah yes, the good life
23:17:57 <EdwardKmett> but i got sidetracked, discovered i could do my undergrad in math in less time,, discovered i could add a comp sci degree to it if i pushed an insane number of credits, did those, did my masters in math in the time i had schedule for my undergrad,, and then added a masters i comp sci since a masters in math isn't all that useful in the big bad real world.
23:18:14 <EdwardKmett> now i'm finding i really like academia, so i'm trying to find excuses to stay ;)
23:18:38 <palomer> I decided I don't like academia
23:18:56 <palomer> though I'm pretty sure I'd dislike industry more
23:19:06 <EdwardKmett> in the middle there i picked up a couple of random graduate certificates, by carefully overlapping credits, so i picked up a graduate cert in bioinformatics and one in artificial intelligence
23:19:10 <palomer> so I'm thinking of dropping my masters degree (with one month left) and becoming a waiter
23:19:28 <cerberus> yeah but do you fuc big busty blondes?
23:19:48 <EdwardKmett> pal: finish it, sunk cost is one thing, regret when you don't have it later is another.
23:19:57 <palomer> I don't have regrets
23:20:16 <palomer> I'm sick of defining my life in terms of my goals
23:20:20 <palomer> I realized I was empty inside
23:20:28 <palomer> and decided to fix this, right now
23:20:31 <audreyt> palomer++
23:20:49 <wilx> lol
23:21:07 <EdwardKmett> pal: fair nuff, just definitely not the path i'd choose.
23:21:14 <cerberus> sex is best way to now if u happy
23:21:19 <palomer> nor would anyone else I know
23:21:20 <cerberus> do u fuck ncie looking girls?
23:21:23 <wilx> You can become a waiter even with the school finished, so why not wait the month? :)
23:21:27 <cerberus> blow loads on their face?
23:21:42 --- mode: ChanServ set +o dons
23:21:50 --- kick: cerberus was kicked by dons (dons)
23:22:08 <palomer> wilx: why do something which goes against everything I've learned?
23:22:27 <palomer> Imagine you lived in a tribal village where a person't life was defined by the number of coconut shells he would collect
23:22:37 <palomer> and the size of the coconut shells
23:22:48 <wilx> :D
23:22:52 <palomer> you're a villager, and you're about to get a really big coconut
23:23:00 <palomer> then, you realize the madness of it
23:23:19 <palomer> so you sit down and start watching the other people go for their coconut shells
23:23:23 <wilx> Heh.
23:23:43 <palomer> and everyone is like "but you're so close, you'll surely regret not having that coconut shell"
23:23:44 <Axio[Bnk]> hum where is the answer of " Probable fix: add an instance declaration for (Show Foo)" ?
23:23:56 <wilx> Well, I would think that I would get the huge coconut and then decide what do next :)
23:24:03 <palomer> Axio[Bnk]: you're calling show on an inhabitant of Foo
23:24:05 <EdwardKmett> pal: yeah but if by having that coconut you get other people in the community to run around and do things for you, aren't you really just using their delusions against them? =)
23:24:25 <lispy> Axio[Bnk]: your data type Foo needs a Show instance, the easiest way so to add 'deriving (Show)' to the end of your data declaration
23:24:37 <Axio[Bnk]> palomer, I just don t knoz the syntax to tell show how to manage fooers
23:24:43 <Axio[Bnk]> ha ok
23:24:54 <Axio[Bnk]> and if I want to tweak it ?
23:25:16 <palomer> EdwardKmett: I don't particularly want to have people run around and do things for me
23:25:19 <lispy> Axio[Bnk]: then you'll need "instance Show Foo where show f = ..."
23:25:27 <palomer> now get this
23:25:38 <palomer> in this village ,you learn that you are _nothing_ without coconut shells
23:25:51 <palomer> which is why everyone is obsessed with them
23:26:13 <Axio[Bnk]> without coconut shells, I m topless
23:26:20 <lispy> Axio[Bnk]: but show was intended to be the inverse of read, so actually you usually don't want to define your own show if you just want custom printing
23:26:23 <audreyt> it's a village of cocoa nuts
23:26:33 <wilx> My father said to me, when I graduated HS and thought about not going to university: "You can be a garbage collecet, I don't care. But only after you finish the university." (or something similar)
23:26:46 <wilx> I think it was wise decision to force me to go to the university.
23:26:57 --- mode: ChanServ set -o dons
23:27:11 <Axio[Bnk]> wilx,  you wrote a GC ? :)
23:27:12 <wilx> I can still be a garbage man but besides that I can be other things too.
23:27:14 <EdwardKmett> pal: i understand where you are coming from, and waiting tables may be fine for today. But after a year of a shitty job with a shitty manager yelling at you about what a shitty waiter you are, and not being able to stop and take a vacation, you might find that having the coconut shell might have been worth it
23:27:14 <audreyt> there's a potential joke here about generational GC that I'm tempted, but will not, make.
23:27:15 <palomer> so you sit down and you realize "I've learned I am nothing and I've spent my life chasing coconuts; I have to start spending time unlearning"
23:27:27 <wilx> lol
23:27:37 <EdwardKmett> audrey: *groan*
23:27:43 <palomer> I would never do a job I dislike; programming jobs can be just as shitty and just as fun as waiting jobs
23:27:49 <palomer> they simply pay better
23:27:58 <EdwardKmett> pal: thats true, but they usually come with benefits =)
23:28:40 <EdwardKmett> i guesss i just have a different point of view.
23:28:45 <palomer> which will do nothing to make me happy
23:28:57 <EdwardKmett> to me, academia has been like the promised land, compared to what i did before
23:29:18 <wilx> If you have endured the unhappiness for so long, keep up with it for the few more months that you need to finish the school.
23:29:31 <palomer> my masters has not been a source of unhappiness
23:29:42 <palomer> in the same way as chasing coconuts wouldn't make me unhappy
23:30:09 <EdwardKmett> wore the suit, managed people, hired and fired almost my entire circle of friends, worked my ass off for years, and left when the company bankrupted and went to secured creditors without anything to really show for it
23:30:12 <palomer> it is, quite simply, pointless; furthermore ,it would get in the way of my unconditioning
23:30:50 <palomer> I'm pretty sure I don't want to work in industry
23:30:58 <palomer> and I'm pretty sure that I don't want to be in academia
23:31:07 <palomer> why the blazes would I do with a masters degree?
23:31:10 <EdwardKmett> pal: fair enough
23:31:12 <audreyt> EdwardKmett: there's crazy startups, and then there's sane work
23:31:17 <audreyt> <- doing sane work, for example.
23:31:29 <palomer> the only thing I see doing is working for myself
23:31:44 <EdwardKmett> audrey: well, the company i started working for was one thing, the company we merged into was an entirely different entity =)
23:31:56 <EdwardKmett> i'm kinda leery of startups these days
23:32:12 <audreyt> I know, been there, quit _right_ before the attempted crazy IPO scheme
23:32:17 <wilx> Gah, I will be late for work.
23:32:18 <blackdog> ek: were you a founder or an employee?
23:32:22 <palomer> EdwardKmett: do you know anything about getting financing for a project?
23:32:23 <wilx> All palomer's fault :D
23:32:31 <palomer> EdwardKmett: I have a great project  but no funds
23:32:37 <palomer> what I say is so true!
23:32:37 <EdwardKmett> yeah ours went the IPO route the CEO decided he could sell below cost and make it up in volume. =)
23:32:43 <palomer> yet it's something we all hear from time to time
23:32:44 <palomer> and ignore it
23:33:06 <EdwardKmett> he figured he'd IPO at umpteen dollars a head and we'd break even and turning a profit would be someone else's problem
23:33:11 <palomer> EdwardKmett: I don't even have a company, I need startup cash
23:33:11 <EdwardKmett> classic .com fiasco
23:33:29 <palomer> all I have is an application
23:33:36 <palomer> (which I think is revolutionary)
23:33:37 <EdwardKmett> this was after i'd nicely gone and showwn him and the board that you coun't ake money on DSL. Look what happened to that whole market since? =)
23:34:00 <EdwardKmett> pal: then build it and money will flow. i'm kinda in the same boat myself =)
23:34:14 <palomer> the application is built
23:34:20 <EdwardKmett> pal: my obsession with javascript interpreters is a means to an ends
23:34:22 <palomer> I simply do not know where to get the money
23:34:24 <audreyt> palomer: find somebody who can use this application to solve an immediate problem; enter consulting relationship or as contractor with that somebody; and then start getting money for improving the product :)
23:34:53 <palomer> I thought about that
23:35:02 <EdwardKmett> pal: the question is who is your customer? are you going to bill companies? the "long tai" of end users?
23:35:09 <EdwardKmett> er long tail
23:35:20 <palomer> school boards
23:35:24 <EdwardKmett> are they buying a widget or a service
23:35:34 <palomer> and I think they prefer to buy completely finished products, whereas my product needs some finishing
23:35:46 <palomer> widget at first
23:40:34 <palomer> anyways, I'm of
23:40:34 <palomer> f
