00:01:30 <edwardk> well, the wrapper compiles now
00:01:36 <edwardk> but isn't very elegant
00:02:32 <edwardk> http://slipwave.info/jslib/hs/Test/THash.hs
00:02:40 <edwardk> and
00:02:41 <edwardk> http://slipwave.info/jslib/hs/Test/THash/THT.hs
00:31:19 <u221e> Is there a way to turn something like "((bw * 8) == w)" into a Bool value?
00:32:20 <edwardk> it isn't already?
00:32:22 <edwardk> or wait
00:32:28 <edwardk> you mean the string containing that?
00:33:17 <u221e> No, like "let b = ((bw * 8) == w)"
00:33:48 <vegai> doesn't that just work?
00:33:55 <edwardk> yeah
00:34:27 <edwardk> > let b = (12 * 6) == 72 in b
00:34:28 <lambdabot>  True
00:34:32 <edwardk> =)
00:36:01 <u221e> Hm, I guess my error is releated to comething else
00:36:26 <edwardk> god i love haskell.
00:36:35 <edwardk> once something typechecks 9 times out of 10 it just works...
00:37:07 <u221e> Found my error ;P
00:37:40 <u221e> let opt = (bw * 8) == fromEnum w
01:21:30 * xahlee sleep
01:27:42 <Itkovian> shapr: hey man. long time no see.
01:27:55 <Itkovian> all is well up north?
02:19:10 <u221e> dons, you around?
02:19:28 <roconnor> @seen dons
02:19:29 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2 hours, 48 minutes and 18 seconds ago.
02:19:57 <u221e> I'm done my shootout program finally.
02:20:04 <roconnor> :)
02:20:04 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
02:20:33 <u221e> It's twice as fast as the current one.
02:20:56 <roconnor> woot!
02:23:25 <dons> u221e: yeah?
02:23:30 <dons> great stuff.
02:23:33 <dons> posted it yet?
02:23:39 <roconnor> heh, it's pretty easy to do capabilities programming in haskell.
02:23:43 <u221e> Going to in a second
02:24:25 <roconnor> to only give read access to a function, just pass it a function that reads from a file.
02:25:09 <dons> right
02:25:20 <dons> like some of the modifyFoo or withFoo functions
02:25:31 <dons> in fact, in lambdabot, we have a modifyState $ \writer -> ...
02:25:56 <dons> so that you can do what you want, but the only way to record your state changes is via the 'writer' function we supply the plugin user/author
02:26:11 <roconnor> :)
02:26:13 <roconnor> safe!
02:26:53 <dons> ?remember spj it looks like hopscotch! (referring to a funny notation for lists)
02:26:53 <lambdabot> Done.
02:29:21 <u221e> dons, it's on the wiki
02:30:35 <u221e> Or not...
02:30:40 <u221e> Why is it taking so long.
02:34:15 <roconnor> why is what taking so long?
02:34:50 <u221e> I can't seem to update a page on hawiki
02:35:28 <dons> you've logged in?
02:35:41 <u221e> Yes.
02:35:42 <dcoutts> morning dons 
02:35:54 * dcoutts is back from his camping trip
02:36:23 <dons> hey dcoutts. roman's off to russia now, and will be in cambridge from august 6 -> 27, i think
02:36:44 <dcoutts> right'o
02:36:57 <u221e> dons, want me to just send it to you?
02:37:11 <dons> so the plan is for him to write the theory sections on streams and loops, and, say, connections to unfold/destory, and we can get the story about bytestring, as well as all the benchmarks in.
02:37:18 <dons> u221e: ok, dons at cse.unsw.edu.au
02:41:19 <u221e> dons, it finally showed up on the wiki
02:46:01 <dcoutts> dons, right, so today I should be doing... ?
02:46:25 <dcoutts> dons, my plan before was to finnish the last non-streams version and then also the streams one
02:46:31 <dcoutts> then benchmark them
03:18:45 <dons> dcoutts: yes. we want to get the streams stuff done and testable within 10 days, i think
03:18:53 <dons> what state is it currently in?
03:19:11 <dcoutts> partially implemented and not much tested
03:19:35 <u221e> Did you check that code dons or are you busy at the moment
03:19:50 <dons> u221e: dinner time, visitors. so can't check now. i'll run benchmarks tomorrow though
03:19:58 <u221e> np
03:20:01 <dons> let me have a peek though..
03:21:12 <dons> ah, but does it do byte-at-a-time IO?
03:21:42 <u221e> Yes
03:21:45 <dons> you build a list and write it out? how much worse would it be to putChar each point
03:21:54 <u221e> Alot it seems
03:22:01 <dons> putStr $ ms 1 0 0 (-1.0) -- that's not byte at a time, is it?
03:22:56 <u221e> putStr just prints the chars of the list.
03:23:21 <u221e> I don't get your question ;P
03:24:56 <dons> well, i'm almost certain we're supposed to do one character on each io call
03:25:01 <dons> so O(n) io calls
03:25:15 <dons> unless you can find some examples in the current code that write buffers at a time
03:25:36 <dons> still, the code looks a lot simpler, so even with putChar it might still be faster, no?
03:25:39 <vegai_> did someone here already get the GHC gig, by the way?
03:25:52 <dons> don't think it's been announced.
03:26:11 <u221e> But it's lazy
03:26:18 <xerox> `gig' ?
03:26:27 <u221e> How could putStr not print a char at a time
03:26:38 <xerox> Buffering, I think.
03:26:43 <dons> it stuffs it all into a Handle buffer, as CChars, and then does a single flush of that buffer
03:27:15 <dons> i think the essence of the spec is that there's supposed to be O(n) writes
03:27:42 <dons> it's much faster on my box!
03:27:54 <u221e> What if I map the list with putChar?
03:27:55 <vegai> gig (n.) A job, especially a booking for musicians. :)
03:28:05 <dons> > 0.430 / 1.292 * 100
03:28:06 <lambdabot>  33.28173374613003
03:28:12 <dons> u221e: that'd be good
03:28:16 <dons> mapM_ putChar 
03:28:19 <u221e> Yes
03:28:32 <dons> i.e. mapM_ putChar $ ms 1 0 0 (-1.0)
03:29:07 <dons> so its a bit of a slow down, but still much better
03:29:08 <dons> $ time ./h1 1000 > y
03:29:09 <dons> ./h1 1000 > y  0.69s user 0.00s system 100% cpu 0.685 total
03:29:09 <dons> $ time ./h 1000 > y 
03:29:09 <dons> ./h 1000 > y  0.41s user 0.01s system 98% cpu 0.430 total
03:29:17 <dons> ?karma+ u221e 
03:29:17 <lambdabot> u221e's karma raised to 2.
03:30:15 <u221e> Wee
03:30:35 <dons> it compresses to a slightly smaller result if we remove the ';' from the module import lines
03:30:43 <dons> (it's also more readable). 
03:30:54 <dons> the use of import X ; import Y goes back to when they used to use line count as a measure
03:31:01 <dons> now they use the size of the gzip'd result
03:31:39 <dons> yeah, very good u221e. great work
03:32:06 <dons> have you added your name to the file?
03:32:45 <dons> ah yes, you have :)
03:32:56 <norpan> shootout?
03:33:05 <dons> yep
03:33:09 <dons> ?shootout
03:33:10 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
03:33:22 <u221e> I'll probably add "Based on version bt Don Stewart" or something
03:33:28 <dons> yeah, fair enough
03:33:36 <dons> it's the same numerical loop, is it?
03:33:48 <dons> (i hand-tuned that based on the Core and C output :)
03:34:25 <dons> so there's no speed up floating gb and ms out to the top level?
03:34:33 <dons> oh, recursive, i suppose not.
03:34:45 <dons> ghc would rewrite it to the current form anyway, i suspect
03:35:22 <norpan> yeah i know about it but what test are you working on now?
03:36:24 <dons> ah, improving mandelbrot
03:42:18 <u221e> I floated out ms and gb because I didn't really feel like passing two more arguments to the functions.
03:45:14 <Lemmih> Itkovian: (re-blog entry) Do you have the program online together with some test data?
03:49:45 <Itkovian> Lemmih: I can put a tarball online, sure
03:50:02 <Itkovian> I'll get you a 30K line sample trace
03:50:05 <Itkovian> a sec.
03:51:39 <Itkovian> it is at http://www.elis.ugent.be/~ageorges/parser.tgz
03:52:15 <Itkovian> equivalent ocaml does it in 13 sec atm for a _full_ trace (with one thread in the trace execution - adding support for that)
03:52:38 <Itkovian> btw, I'm looking to understand what's wrong, not just a correction, cause that won;t teach me anything
04:09:40 <u221e> Are guards and if-then-else statments about the same performance wise?
04:10:35 <roconnor> is there a way of getting ghc-core out of ghc?
04:12:17 <norpan> u221e: they should be exactly the same
04:16:05 <roconnor> ?paste
04:16:05 <lambdabot> http://paste.lisp.org/new/haskell
04:18:06 <lisppaste2> roconnor pasted "guards vs if for u221e" at http://paste.lisp.org/display/22522
04:20:02 <u221e> What would be the best app to strip out all duplicate whitespace from a file? I don't really like making on right now.
04:22:06 <roconnor> heh, haskell core uses named variables.
04:22:26 <Lemmih> Itkovian: The code finishes in 11secs on my box. Is that good or bad?
04:22:28 <roconnor> I supose that makes it easier to read.
04:23:10 <boegel> Lemmih: which code? the Haskell code for his tracer thingie?
04:23:19 <Lemmih> boegel: Yeah.
04:23:35 <boegel> Lemmih: that seems quite fast to me...
04:23:40 * boegel pulls Itkovian's bell
04:24:44 * Lemmih even got bittornado+firefox+rhytmebox eating a steady 30% of his cpu.
04:25:33 <Itkovian> Lemmih: without changing it?
04:25:46 <Itkovian> yeah, with a 30K trace
04:25:58 <Itkovian> shall I wrap up a full trace for you?
04:26:41 <Itkovian> it's 18M large
04:27:26 <Itkovian> http://www.elis.ugent.be/~ageorges/compress.prep.log.gz
04:27:32 * boegel sees Lemmih box smoking already
04:27:42 <Itkovian> erm
04:27:49 <boegel> s/Lemmih/Lemmihs
04:28:00 * Itkovian tries not to form a mental image of that
04:28:05 <Itkovian> sick bastard
04:28:07 <Itkovian> ;-)
04:30:08 <Lemmih> Itkovian: Do you really need Integers?
04:31:24 <Itkovian> Lemmih: I suppose 64-bit ints would do well too
04:31:42 <Itkovian> do we have those?
04:33:22 <Lemmih> Yes, but Integers are probably faster.
04:33:49 <Itkovian> ok, then I'll stick with those
04:33:53 <Lemmih> 64bit primop are implemented as out-of-line C calls.
04:33:59 <Itkovian> ic
04:34:12 <Itkovian> the counts I collect can easily grow larger than 32-bit values
04:39:15 <Lemmih> Itkovian: Using a fold instead of the State monad gives an almost 2x speed-up.
04:40:39 <dons> u221e: s/  */ /g  -- ?
04:40:43 <dons> in sed or vi/vim
04:44:34 <dozer> nmrp3@fluxion:~/devel/haskell/HXT-6.1$ ./Setup.lhs configure
04:44:34 <dozer> Program error: Line 124: Unknown field 'hs-source-dirs'
04:44:52 <dozer> any idea what could be causing this? It;s from the cabal file from hxt
04:45:00 <u221e> dons, why do the debian and gentoo shootout sites both run the benchmarks differently?
04:45:09 <Lemmih> dozer: hs-source-dirs is used in newer versions of Cabal.
04:45:26 <dozer> Lemmih: ok - so it looks like I have a new ghc, but an old cabal
04:45:27 <Lemmih> dozer: You can change it to 'hs-source-dir' if it only mentions one directory.
04:45:29 <Itkovian> Lemmih: that's nifty. 
04:45:55 <Itkovian> writing that down
04:45:58 <Lemmih> Itkovian: There's more to come.
04:46:15 <Itkovian> Of course, the idea of the State is to hide all the ugliness
04:46:33 <Itkovian> I had an implementation without a State and it was worse, so I went with the State in the end
04:46:41 <Lemmih> A fold is way prettier.
04:46:48 <Lemmih> And shorter.
04:46:49 <Itkovian> maybe, yeah
04:47:33 <Itkovian> The question remains why the State seems to be retaining all the stuff it won't need anymore - or am I mistaken here?
04:47:47 <dozer> Lemmih: is there an easy way to get the cabal installation to print out its version?
04:48:16 <Lemmih> dozer: `ghc-pkg field Cabal version`
04:48:45 <dozer> 1.1.4 - what should I be up to?
04:49:38 <Lemmih> Heh. Cabal got the most fucked up versions ever. I believe my 1.1.3 is newer than yours.
04:49:55 <dozer> that is ... non-monotonic
04:51:40 <Lemmih> Itkovian: Using ByteStrings in 'mkMethod' gives another 20%.
04:51:49 <Lemmih> Itkovian: State is lazy.
04:51:56 <Itkovian> I know
04:52:08 <Itkovian> but seq should force it, no?
04:52:57 <Lemmih> Nope, it's impossible to force it. You should use a strict implementation instead.
04:53:18 <Itkovian> ok
04:53:24 <Lemmih> (well, is this case you shouldn't: A fold is perfect for the task)
04:53:29 <Itkovian> glad I know that
04:54:22 <Itkovian> Lemmih: if you want larger traces, you can in general head -n <your-size> the large file I put online
04:55:45 <Lemmih> Itkovian: Using ByteStrings in updateMethod gives a 4x speedup.
04:55:59 <Itkovian> now there's some excellent news.
04:56:05 * Itkovian jots it down
04:57:40 <Lemmih> I'm using a specialized version of read for ByteStrings. It's quite fast but doesn't parse negative numbers, hexadecimals, octals, etc.
04:59:22 <Lemmih> Itkovian: Ok, I think I'm done with the low hanging fruit. It's now down from 11s to 1.5s.
05:00:02 <Itkovian> nice. thanks. I'll apply the suggestions
05:00:16 <boegel> Itkovian: finally :)
05:01:40 <Itkovian> Anyway, I put my judgement on hold but it still seems ocaml is way faster here. But they cannot give the keys in a map it seems.
05:01:43 <Itkovian> ttsssk
05:03:56 <dozer> is there a darcs for cabal?
05:05:07 <Lemmih> Itkovian: And inserting random seqs is kinda like shooting birds while blindfolded.
05:05:16 <Itkovian> dozer: there is a darcs repo of cabal available, yes
05:05:41 <Itkovian> Lemmih: true enough
05:05:58 <dozer> Itkovian: doesn't seem to be on darcs.haskell.org - where do I look?
05:05:58 <Itkovian> I was following advice though
05:06:42 <Itkovian> dozer: darcs get http://darcs.haskell.org/packages/Cabal
05:06:45 <lambdabot> Title: "Index of /packages/Cabal"
05:06:50 <Itkovian> it says so on the Cabal page
05:06:58 <dozer> I must be so blind
05:09:05 <Itkovian> don't worry, it seems I'm blind too
05:10:40 <dozer> ah - looks like when I "make" ghc, it's not making the stuff under ./libraries
05:13:15 <dons> u221e: they don't keep in sync, for some reason
05:13:42 <u221e> the debian one still counts code lines
05:18:13 <dons> ah, so they haven't pulled that patch in either
05:18:17 <dons> they're run by different people
05:18:34 <u221e> Do you know how they get the memory usage numbers?
05:18:37 <dons> in general, i think the gp4 is kept more up to date
05:18:55 <dons> no, but i noticed some wide discrepancies between gp4 and debian
05:19:02 <dons> in partial-sums, i think?
05:23:45 <u221e> Ok, I'm going to submit it now.
05:35:57 <u221e> dons: where do you specify what command line args they are supposed to use?
05:45:49 <dons> well, one way is to put them in a pragma, {-# OPTIONS .... #-}
05:46:11 <dons> then you don't need to worry about the guy at the shootout putting them in his makefile
05:46:18 <ndm> OPTIONS_GHC is the prefered way, for GHC
05:46:21 <dons> you going to submit via the web interface?
05:46:31 <ndm> (Yhc is hopefully going to add OPTIONS_YHC soon ;) )
05:47:02 <norpan> as an environment variable?
05:47:39 <ndm> norpan: as a pragma, at the start of the file
05:47:50 <norpan> oh, good
05:48:16 <ndm> mainly because compiling the prelude without it puts half the logic into the makefile, which is annoying
05:50:47 <u221e> dons: How else can you submit?
06:01:16 <dcoutts_> g'afternoon JaffaCake 
06:01:23 <JaffaCake> hey there
06:01:35 <JaffaCake> and a fine afternoon it is
06:01:43 <dcoutts_> aye
06:02:05 * dcoutts_ got back yesterday from a camping trip, so has apreciated the good weather
06:02:35 <JaffaCake> sounds great, I miss camping, haven't done it for ages
06:02:46 * xerox is coming back from some days of camping too :)
06:03:04 <dcoutts_> just one tip: avoid midgie infested campsites :-)
06:03:05 * roconnor wants to go camping
06:03:26 <JaffaCake> after we nearly got washed off a scottish hillside in a thunderstorm one night, my wife won't go camping ever again :(
06:03:35 <dcoutts_> eek
06:03:41 <roconnor> sounds like fun
06:04:00 <dcoutts_> thunderstorms when camping are fun, so long as they don't wash you away
06:04:19 * JaffaCake loves the sound of rain on a tent
06:04:22 <roconnor> I see
06:04:32 <xerox> `midgie' ?
06:04:41 <norpan> rain during the night is ok, rain all day is not so much fun
06:04:49 <JaffaCake> true
06:04:50 <dcoutts_> xerox, like mosquitoes, only much smaller and more numerous
06:05:05 <xerox> Oh well, we've got them too. Way too many of them :)
06:05:54 <dcoutts_> we had to keep little camp fires smoking all day to drive them away
06:06:02 <JaffaCake> midgies are the only thing keeping scotland from being overrun by tourists, they are a good thing :)
06:06:16 * dcoutts_ goes back to hacking on ByteString fusion
06:06:27 <dcoutts_> JaffaCake, ha ha, I suppose so
06:06:31 <xerox> hehe
06:07:03 <xerox> It's too hot here to hack in fact, sigh.. 
06:07:06 <dcoutts_> JaffaCake, it drove us away, after three days camping near the scotish border we all moved down to the lake district :-)
06:07:14 * xerox 's head is boiling
06:07:27 <JaffaCake> dcoutts_: there you go, it works :)
06:07:34 <dcoutts_> yep :-)
06:07:50 <JaffaCake> they can recognise the English, too
06:08:06 <dcoutts_> they smell better ;-) ?
06:08:07 * gour goes to the (croatian) coast on saturday...
06:08:08 <JaffaCake> which isn't good for me, either :)
06:09:27 <dcoutts_> some of my friends took to wearing tights on their heads to keep off the midgies
06:09:45 <dcoutts_> which was an odd sight
06:10:05 <JaffaCake> heh
06:10:08 <xerox> I used my long hairs
06:10:12 * dcoutts_ too
06:10:14 <xerox> Blame me :P
06:10:15 <ndm> dcoutts_, http://www-users.cs.york.ac.uk/~ndm/projects/hat.php - my Gtk2Hs thing is going quite well :)
06:10:17 <JaffaCake> you can get special hats, like beekeeper hats I think
06:10:17 <lambdabot> Title: "Neil Mitchell - Hat"
06:10:33 <xerox> JaffaCake: ha ha that sounds like a fun way to camp
06:10:48 <xerox> Where's the contact with the nature!
06:10:50 <dcoutts_> ndm, looks good!
06:11:17 <ndm> i went paintballing, crawling around a ditch in the mud for a day, and still have midge bites from 3 weeks ago
06:11:38 <JaffaCake> ndm: but no paintball scars?
06:11:50 <ndm> JaffaCake: one or two bruises - but nothing much
06:12:06 <ndm> one friend got shot in the throat from 10cm away, and was bleeding quite a bit
06:12:17 <JaffaCake> ouch
06:12:40 <dcoutts_> JaffaCake, btw, if people could agree on a binary serialisation module, do you think we could stick it in the base package? there are lots of apps that use somethime like that. I was thinking it might be the next thing on the list after ByteString (and probably based on ByteString too)
06:13:09 <ndm> I would love that - Read/Show serialisation is both too slow, not lazy and doesn't work between GHC/Hugs
06:13:38 <JaffaCake> sure, I'm not sure it has to be in base, but we might ship it by default with GHC
06:13:40 <ndm> but what you really need is deriving Serialise
06:13:52 <dcoutts_> borrowing from the existing binary modules in ghc/haddock etc and probably taking some ideas from wassisname's new binary stuff
06:13:58 <JaffaCake> that's true, deriving support would be good
06:14:02 <dcoutts_> aye
06:14:15 <ndm> if you have deriving, doesn't it need to be in the base module then?
06:14:17 <JaffaCake> you mean Bulat? :)
06:14:24 <dcoutts_> yeah :-)
06:14:35 * dcoutts_ couldn't remember how to spell it
06:15:12 <dcoutts_> his one gives more control over endianness etc I believe
06:15:15 <JaffaCake> Bulat's library depends on his whole stream framework, but we might be able to settle on an API that can be used by both.  I think Streams comes with an implementation of NewBinary, for example
06:15:46 <JaffaCake> The big problem with NewBinary is that it doesn't have a way to pass your own state around
06:15:56 <dcoutts_> right, I'm thinking of an api & feature set similar to the NewBinary but probably based on ByteStrings
06:16:18 <dcoutts_> JaffaCake, what's the main use case for that?
06:17:10 <JaffaCake> eg. in GHC we collect a dictionary of strings to output at the end, so we need to pass the dictionary around both when reading and writing
06:17:27 <JaffaCake> any kind of state you need to thread through the reader or writer, basically
06:17:31 <dcoutts_> ah yes the shared string table
06:18:07 <JaffaCake> it could be done by abstracting the Binary class over MonadIO, but I'm not sure what efficiency implications that would have
06:18:40 <Philippa> you could always provide a specialisation for IO itself?
06:19:15 <JaffaCake> yes, but then it would slow down dramatically if someone used a StateT of IO, or something
06:19:50 <Philippa> yeah. I always hope for more inlining and the like than actually happens...
06:20:45 <xerox> What does it mean to `abstract a class over another' ?
06:21:15 <shapr> jiihaa!
06:21:26 <JaffaCake> oh, I just mean 'class MonadIO m => Binary m a where put :: BinHandle -> a -> m ()'
06:21:47 * shapr boings happily
06:21:55 <JaffaCake> good day, shapr?
06:21:57 <shapr> Good afternoon #haskell!
06:22:01 <shapr> hiya JaffaCake!
06:22:12 <JaffaCake> hi there ;)
06:22:40 <Philippa> JaffaCake: I think more generally there's something of an efficiency/optimisation problem with monad transformers that's kinda crying out for some good attacks on it?
06:22:42 <shapr> JaffaCake: I might have an apartment, I got some more contracting work, and I got an interview with microsoft research for a Haskell job! w00!
06:22:44 * xerox waves to shapr greetingly
06:22:44 <shapr> Life is good!
06:22:52 <Philippa> cool
06:23:01 <JaffaCake> Philippa: quite possibly, yes
06:23:19 <xerox> shapr - Wow, that's great!
06:23:31 <shapr> Oh, I was reading 'Composing Monads Via Coproducts' today, that's a nifty paper.
06:23:34 <dcoutts_> well done shapr 
06:23:39 <ndm> shapr, the GHC maintainer job?
06:24:10 <shapr> ndm: The description sounds more like "GHC General Assistant Person".
06:24:28 <shapr> Also, I'm trying to figure out who else got invited for an interview so maybe we can organize AngloHaskell :-)
06:24:32 <ndm> I wish Yhc had one of those...
06:24:47 <Philippa> I suspect there's a lot that can be done any time you know the exact transformer stack that some code's going to be run on, specialisation is our friend... how difficult would a "deepSpecialise" pragma be to implement?
06:24:54 * gour is cheering shapr too
06:25:19 <Philippa> shapr: interview in cambridge? Even if there's no meet as such I can probably head over and say hi
06:25:24 <shapr> So far Lemmih and I are signed up for AngloHaskell, anyone else want to show up?
06:25:24 <xerox> shapr, nice paper indeed, that one.
06:25:42 <shapr> Philippa: Yup, AngloHaskell will be a meetup in Cambridge.
06:25:53 <shapr> Igloo, ndm: Are you anywhere close to Cambridge?
06:25:59 <roconnor> Coproducts ... why don't they just say sums
06:26:06 <shapr> I have a suspicion that JaffaCake is already somewhere near Cambridge.
06:26:14 <Philippa> got a date for it? I'll be muchly miffed if it turns out to be during the few days after the DWCon I have someone staying...
06:26:16 * JaffaCake raises his hand
06:26:16 <Lemmih> shapr: They want an interview between the 31st of July and the 11th of August, right?
06:26:19 <xerox> ...and Duncan?
06:26:25 * shapr grins
06:26:33 <shapr> Lemmih: I gotta check the dates to be sure.
06:26:50 <Philippa> I might need to find crashspace if it goes on late, but that shouldn't be too hard hopefully
06:27:17 <JaffaCake> I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
06:27:23 <shapr> Yeah, MSR is paying for lodging, and an extra bed usually costs just a tiny bit, so I'll fund an extra bed for you to crash in my room if you want.
06:27:28 <shapr> JaffaCake: haha
06:27:37 <xerox> he he he
06:27:52 <shapr> JaffaCake: Well, I'm sure you guys will pick the best candidate, I'm not worried about that. I just like to meet Haskellers.
06:28:09 * edwinb wonders what an AngloHaskell would involve
06:28:14 <Philippa> in a pinch, if you're sure it won't confuse people :-)
06:28:15 <JaffaCake> it should be good fun, definitely
06:28:17 <Philippa> at a guess? Beer
06:28:21 <shapr> edwinb: England and Haskell at least.
06:28:30 <Lemmih> edwinb: Unicycling.
06:28:30 <edwinb> I probably can't justify travelling just for beer ;)
06:28:33 <edwinb> Not that it'd be the first time.
06:28:51 <shapr> edwinb: C'mon, you know you want to talk about dependent types in a pub.
06:29:01 <edwinb> Yeah, I don't do that nearly often enough any more
06:29:26 <ndm> shapr, I'm York
06:29:45 <shapr> ndm: Good to meet you York ;-) but seriously, is that close or far from Cambridge?
06:29:48 * xerox checkes how much does it cost to fly over there
06:29:54 <xerox> ....and come back, hopefully.
06:30:03 <Philippa> it's far enough to want to crash somewhere
06:30:06 <ndm> shapr, not that close - 100 mile maybe
06:30:07 <shapr> xerox: You'll be drawn into MSR, never to return!
06:30:24 * xerox feels comfortable with the view!
06:30:54 <JaffaCake> you can get a train to/from york for a day trip, shouldn't be that difficult
06:31:06 <ndm> indeed, reasonably easy
06:31:45 <Philippa> in fairness I seem to have slightly less tolerance for travel for day trips, I wouldn't do manchester from here for a day unless I really had to for example
06:32:10 <ndm> 2:30hr on the train
06:32:29 <Philippa> one way, presumably?
06:32:33 <ndm> yeah
06:32:43 <Philippa> it's getting on for that from nottingham, too
06:33:15 <Philippa> coming back on a sunday stinks, I end up having to go via leicester
06:33:35 <xerox> > do { x <- [1,2,3]; return x }
06:33:36 <lambdabot>  [1,2,3]
06:33:37 <ndm> oh yeah, on a sunday that would be more like 5 hours
06:33:54 <xerox> > do { x <- [1,2,3]; liftM (*2) [1,2,3]; return x }
06:33:55 <lambdabot>  [1,1,1,2,2,2,3,3,3]
06:33:56 <ndm> i spent all sunday stood on trains back from preston :(
06:33:59 <xerox> What's happening?
06:33:59 <Philippa> ouch
06:34:11 <edwinb> oh, Stansted is pretty near isn't it...
06:34:47 <JaffaCake> yep, Stansted about 30 mins by train from cambridge
06:35:04 <edwinb> I might consider visiting if I can find a cheap flight then ;)
06:35:22 <xerox> edwinb: where are you coming from?
06:35:23 <edwinb> and if it's a date I can do of course
06:35:52 <edwinb> I'm in St Andrews, but quite used to travelling all over the uk for no good reason.
06:36:06 <ndm> i have a wedding and a week long karate course within those dates, but will go if i can
06:36:17 <shapr> Sounds good.
06:36:19 <roconnor> xerox: its the non-deterministic monad.  no problem adding repeatitions.
06:36:38 <roconnor> and remind me to stop using it for my list manipulations.
06:36:48 <xerox> roconnor: I don't understand when the repetition goes on.
06:37:00 <xerox> Looks crazy to me.
06:37:04 <shapr> Any other UK people who might show up for AngloHaskell?
06:37:20 <roconnor> > [x | x<-[1,2,3] y <- liftM (*2) [1,2,3]]
06:37:21 <lambdabot>  Parse error
06:37:25 <roconnor> > [x | x<-[1,2,3], y <- liftM (*2) [1,2,3]]
06:37:26 <lambdabot>  [1,1,1,2,2,2,3,3,3]
06:37:31 <roconnor> now do you see?
06:37:48 <Igloo> shapr: I'm 2 hours away, I think
06:38:00 <xerox> roconnor: yup.
06:38:06 <ndm> what about dcoutts?
06:39:06 <shapr> Igloo: interested in showing up?
06:39:27 * shapr asks Heffalump too
06:40:16 <shapr> Arnia: AngloHaskell?
06:40:59 <Philippa> you prolly want to nominate someone who lives in or near cambridge to pick a pub?
06:41:13 <ndm> and if anyone had a floor to sleep on, that would be useful?
06:42:24 <Philippa> very much so. I think I managed to dodge that by asking first...
06:42:39 <edwinb> Cambridge is full of lovely pubs
06:43:27 <xerox> let multiply xs n = do { x <- xs; liftM (:[]) [1..n]; return x } in multiply [1,2,3] 3
06:43:27 <Philippa> So long as someone here knows which ones're well-placed :-) I only really know the ones I've been to for afpmeets
06:43:38 <xerox> Wops.
06:43:55 <edwinb> I've been to a few on go tournament weekends...
06:46:41 <psnl> I hear you are planning a meetup in cam
06:46:58 <dcoutts_> shapr, what dates? I'll bring my unicycle on the bus from Oxford. :-)
06:47:10 <dcoutts_> shapr, as for accomodation, my parents live in Cambridge
06:47:22 <dcoutts_> xerox, or take the train
06:47:29 <psnl> I can provide crash space/pub advice
06:47:36 <ndm> dcoutts_, would they mind people staying on their floor?
06:47:44 <psnl> aiming for the start of aug is good
06:47:56 <dcoutts_> ndm, I could have a few on the floor at my parents place, yes
06:48:01 <ndm> cool :)
06:48:16 <ndm> any reason that this command works in GHC 6.4 but not 6.5: ghc -M -optdep-f -optdepsrc/compiler98/.Bind.hs.dep src/compiler98/Bind.hs
06:48:31 <ndm> it fails to find one of the dependancies that is in the same directory
06:48:48 <ndm> its 6.4 Windows/Linux is fine, 6.5 Mac fails to find
06:50:10 <ndm> -M is the makefile generation thingy
06:52:16 <JaffaCake> edwinb: you play go?
06:52:27 <edwinb> I try to...
06:52:42 <JaffaCake> I'll be sure to bring my go board to the pub then!
06:52:46 <rhaaw> Feh, I was being a retard yesterday. I was trying to make eclipsefp work with Eclipse-3.0.2 instead of 3.2.0.
06:52:52 <rhaaw> Which is why I was getting odd errors.
06:52:57 <edwinb> JaffaCake: yay!
06:53:08 <rhaaw> Never try to do anything that requiers THINKING after 5am.
06:53:31 <Philippa> I'm aware of the rules, I wouldn't say I really play
06:54:05 <ndm> i played once, i thought i won, but i'm only vaguely aware of the rules, and i think my opponent tricked me when counting up the score
06:54:36 <shapr> I've only played Go once, but I want to play more!
06:54:43 <JaffaCake> we considered asking for Go ranking on the GHC job application :)
06:54:44 <edwinb> Excellent, more victims!
06:55:13 <shapr> JaffaCake: hah!
06:55:32 <shapr> edwinb: As long as I'm learning, I don't mind being the victim :-)
06:55:38 <edwinb> hehe
06:55:53 <JaffaCake> it's dangerous to start learning Go, too easy to get hooked
06:56:38 <Philippa> yeah, I've concluded I probably don't have the time to take it as seriously as I'd like
06:56:46 <Philippa> then again, I still want a good Street Fighter opponent or two locally...
06:58:24 <ndm> i want a squash player, but everyone believes i'd be too competative
06:58:49 <xerox> dcoutts_: train?
06:58:58 <xerox> I am also able to play Go!
06:59:10 <dcoutts_> xerox, to get to cambridge
06:59:22 <dcoutts_> xerox, I took the train from oxford to naples recently
06:59:38 <xerox> That's an idea, how long does it last?
06:59:44 <dcoutts_> (via london, paris & rome)
06:59:47 * edwinb resists getting '#haskell go tournament' added to the British Go Association tournament calendar
06:59:47 <xerox> (And how much does it cost?)
06:59:58 <dcoutts_> there's an overnight train from milan to paris
07:00:17 <dcoutts_> xerox, depends how much in advance you book
07:00:41 <xerox> If I get the right books in time, I could spend the time well on the train.
07:00:43 <shapr> Is there a website that describes cool things to look at in Cambridge?
07:01:19 <vegai> shapr: did you get it? :)
07:01:29 <Philippa> probably. I tend to spend more time with people there though
07:01:52 <dcoutts_> xerox, http://www.seat61.com/ it's a good consumer-run eurpoean train advice site
07:01:54 <lambdabot> Title: "The Man in Seat Sixty-One..."
07:02:02 <shapr> vegai: Nah, but I'm going for an interview. Cambridge will be fun to visit however the job turns out.
07:02:08 <JaffaCake> shapr: http://www.visitcambridge.org/visitors/whattoseeanddo.php
07:02:10 <lambdabot> Title: "Visit Cambridge > Visitors > What to See &amp; Do"
07:02:24 <dcoutts_> shapr, I lived there 'til I was 18, I can be your tour guide
07:02:30 <xerox> dcoutts_: thanks much!
07:02:36 <dcoutts_> shapr, when were you thinking of?
07:02:59 <vegai> shapr: I got a "...although your your background and skills are very impressive, unfortunately..." :)
07:03:22 <vegai> shapr: but best of luck to ya 
07:03:24 <shapr> dcoutts_: Haven't nailed down a time yet.
07:03:29 <dcoutts_> right'o
07:03:40 <shapr> JaffaCake: thanks!
07:06:20 <Philippa> I occasionally wonder if I should have a chat with a few places like MS Research essentially asking if they might have any use for me at some point in the next few years if I start being a little more productive
07:07:21 <shapr> Lemmih created http://haskell.org/haskellwiki/AngloHaskell add yourself if you want to show up!
07:07:22 <lambdabot> Title: "AngloHaskell - HaskellWiki"
07:10:30 <boegel> heh cool
07:10:36 <boegel> shapr: did you sent your CV too?
07:11:50 <Itkovian> god, either ocaml is just ugly or I'm screwing up royally
07:13:22 <Itkovian> how the hech can you avoid writing ten times the same stuff when you only have let's and no where's ... and you prolly don't need the let definitions in each case.
07:13:36 * Itkovian runs back to Haskell screaming
07:13:59 <ndm> and lazy evaluation would let you write the lets at the top, without worrying about which were important
07:13:59 <Philippa> by defining most of the function (including the cases) inside a let?
07:14:02 * roconnor wonders how cheap he can fly to Cambridge
07:14:11 <ndm> you can of course lambda lift your function
07:14:18 <ndm> create a new function and pass all the let arguments
07:15:23 * roconnor doesn't see how where differs from let in any essential way
07:15:35 <ndm> there was a student project at york to basically give Ocaml a Haskell syntax, unfortunately it didn't work out
07:16:25 <xerox> Aww :(
07:17:20 <vegai> ndm: laziness or too ambitious?
07:17:38 <ndm> vegai: are you asking about laziness of the student or the Haskell language?
07:17:56 <ndm> mainly the first one though
07:18:07 <vegai> answer the question first, then I'll figure that out
07:18:11 <vegai> ;P
07:18:22 <vegai> ok, that's not how laziness works.
07:18:39 <ndm> stage one was to give O'Caml a Haskell syntax, stage two was to make it the O'Caml lazy
07:19:01 <ndm> or optional laziness annotations
07:19:06 <ndm> it didn't get to stage 1
07:19:27 <norpan> and after stage 1 and 2 it would be == haskell, so what's the point :)
07:19:31 <JaffaCake> AngloHaskellers: we *might* be able to provide some space here at MSR for AngloHaskellers to hang out during the day, w/ wireless network access.  We're looking into it.
07:19:48 <Lemmih> Hurray!
07:20:01 <vegai> yeah, it's easy to confuse Ocaml as just an ugly version of Haskell...
07:20:14 <vegai> and conclude that it just needs better syntax
07:20:19 <Philippa> cool
07:20:26 <ndm> norpan: compare compile speed
07:20:35 <Adamant> how is Haskell speed-wise compared to O'Caml these days?
07:20:46 <ndm> and possible optional laziness - i.e. investigating how much laziness is used, how much is not
07:20:50 <Adamant> it used to be that O'Caml whomped all over it
07:20:50 <Philippa> row polymorphism's important, too
07:21:00 <Philippa> depends how much work you're willing to do
07:21:04 <shapr> boegel: Yup, I sent my CV and I got a response!
07:21:21 <xerox> Hurray squared!
07:21:23 <vegai> Adamant: microbenchmarks tell that ghc's performance is very competitive theses days
07:21:37 <norpan> ndm: i agree that it would be nice to have a strict variant of haskell, but perhaps it's better to start from the haskell end?
07:21:54 <vegai> ...which actually means that the programs were fixed to do well in microbenchmarks
07:21:56 <ndm> norpan: perhaps, it was just a random student project - rather than a research direction
07:22:01 <norpan> oh
07:22:02 <norpan> i see
07:22:06 <norpan> then it doesn't matter
07:22:18 <Itkovian> shapr: congrats!
07:22:22 <ndm> but there were some proposals floating around for a strict haskell - you might want to check out Clean
07:22:25 <Adamant> vegai, true enough, but it's interesting to see progress
07:22:33 <ndm> officially now Clean is a "pure lazy and strict functional language"
07:22:34 <norpan> clean is interesting
07:22:52 <ndm> rather than a pure lazy functional language, as it was at the begining
07:23:00 <Itkovian> yeah, but Clean is restricted to Linux/Windows on x86 afaik
07:23:30 <ndm> I just played their platform game demo's - didn't get any further than that :)
07:23:47 <norpan> clean works on macos x/solaris too
07:23:52 <vegai> hmm, ghc's nsieve is now 2.5 times faster and 24 times(!) more space-efficient than the ocaml solution
07:23:52 <norpan> but it's lgpl
07:24:06 <Adamant> btw, someone just turned me on to darcs... this is a fantastic SCS
07:24:10 <norpan> so you need a license to use it commercially
07:24:46 <aref> Adamant: if you don't mind me asking, what's better about it? been told to check it out, haven't gotten around to it yet
07:24:56 <vegai> norpan: I thought that was gpl
07:25:19 <ndm> norpan: no longer, you used to, now its free to use commercially
07:25:19 <Adamant> aref - I haven't done any complicated stuff with it, but just doing basic stuff is tons easier than CVS, and a bit easier than SVN
07:25:20 <norpan> commercially is the wrong word
07:25:34 <Adamant> propretiarialy
07:25:36 <ndm> Yhc is GPL, but you can still use that commercially
07:25:40 <Adamant> (sp..)
07:26:11 <aref> Adamant: heh, yeah, so I hear. have to check it out
07:26:46 <ndm> Adamant: are you a windows user?
07:26:58 <Adamant> ndm - not right now, why?
07:26:59 <norpan> their homepage says it's lgpl and you can't use it proprietarily (without releasing your source code) unless you have a commercial license
07:27:01 <ndm> if so TortoiseCVS makes CVS a lot easier than darcs
07:27:09 <Adamant> ah
07:27:15 <Adamant> nah, on Linux right now
07:27:18 <ndm> norpan: they have changed their mind since then, but not updated their page yet
07:27:48 <ndm> although darcs is a better SCS than cvs clearly, its just harder on Windows than tortoise - which is more of a compliement to tortoise than anything to do with CVS
07:27:57 <Adamant> well, from a command line, darcs is easier :)
07:28:11 <Adamant> Tortoise is graphical, right?
07:28:18 <ndm> yep
07:28:19 <norpan> ndm: then you should tell whomever you got that information from to update the web page :)
07:28:33 <ndm> norpan: the clean mailing list, i beleive
07:28:36 <Adamant> yeah, sorta apples to oranges.. but thanks for the info :)
07:28:45 <offby1> tortoise uses svn underneath, which is centralized; darcs is decentrailzed.
07:28:52 <offby1> apple to oranges indeed.
07:29:17 <Adamant> yeah, I haven't even started playing with decentralization stuff
07:29:20 <ndm> offby1: there is both tortoisecvs and tortoisesvn - two separate projects
07:29:36 <Itkovian> I disagree about the let and where, at least I don't see how you can avoid computing something that would have been shortcircuited by a logical operator, e.g. | null xs || foo xs bar where foo ... will never evaluate the foo is xs is [], in a let it would be evaluated.
07:29:39 <arjanb> ndm: have you tried http://tortoisedarcs.sourceforge.net/ ?
07:29:39 <Itkovian> no?
07:29:41 <lambdabot> Title: "TortoiseDarcs"
07:30:18 <ndm> arjanb: no... - i'll definately try that out - when i searched for that kind of thing i found nothing - but that was a year ago
07:30:22 <sjanssen> JaffaCake: I wrote a version of unfoldr that works with GHC's fusion framework.  If I were to submit a patch, where does the code belong?  unfoldr is in Data.List right now, does it belong there or GHC.List?
07:30:27 <ndm> thanks for the pointer!
07:30:57 <dcoutts_> sjanssen, interesting, can I see the code?
07:31:10 <sjanssen> dcoutts_: yes, momentarily
07:31:28 <JaffaCake> sjanssen: probably it belongs in Data.List, but I'm not the best person to review that patch, Simon PJ will probably need to look at it
07:32:03 <norpan> the uniqueness types of clean are really interesting
07:32:57 <boegel> shapr: so, if you're going to the interview, I guess other people don't stand a chance? :P
07:33:44 <sjanssen> dcoutts_: http://cse.unl.edu/~sjanssen/unfoldr.hs
07:34:12 <vegai> boegel: that includes the interviewers ;P
07:34:22 <boegel> vegai: :)
07:36:01 <dcoutts_> sjanssen, seems reasonable
07:36:43 <dcoutts_> sjanssen, have you tested it with -ddump-simpl-stats -ddump-simpl-iterations 
07:38:02 * dcoutts_ wonders if the recent discussion on seq & build/fold rules has any relevence to the unfoldr rules
07:38:03 <sjanssen> what am I looking at with -ddump-simpl-iterations?  a dump of the core at each simplification step?
07:38:23 <dcoutts_> right
07:38:37 <dcoutts_> so you can see if and how the rules get applied
07:41:40 <sjanssen> yeah, the rules are applied, and they seem to be a big win in my test case (0.1 sec. vs. 0.6 sec.)
07:45:31 <dcoutts_> nice
07:46:52 <sjanssen> another thing, with build fusion you can't fuse foldl, right?  however, GHC docs claim that length is a good consumer.  How is this possible?
07:51:25 <Lemmih> JaffaCake: Are you in a position to tell how many have been invited?
07:52:04 <int-e> sjanssen: length gets rewritten to a foldr for optimization, by a rule in GHC.List
07:53:29 <sjanssen> int-e: wouldn't that foldr take linear space to find the length then?
07:54:02 * Itkovian is about to start smashing stuff
07:55:16 <SamB> depends whether the list is used for anything else or not, I guess...
07:56:59 <norpan> looking at the length implementation in GHC.List it seems to use a tail recursive call with accumulator
07:57:53 <int-e> sjanssen: http://darcs.haskell.org/packages/base/GHC/List.lhs , look for length
07:59:30 <Itkovian> omfg
08:00:16 <norpan> that stuff looks fragile :)
08:00:46 <sjanssen> int-e: yeah, I see the length to foldr rule.  But, under normal circumstances length defined via foldr would take linear space, but GHC's length doesn't
08:01:11 <vegai> anyone defined replace::String -> [(String, String)] -> String yet? ;)
08:02:00 <norpan> sjanssen: because the foldr is transformed to lenAcc by the second rule
08:02:06 <sjanssen> lenAcc and incL have "-- Internal" after them.  Is this where the magic happens?
08:02:19 <vegai> yah, I'm lazy, but only because everyone keeps saying it's a good thing!
08:02:55 <norpan> vegai: replace = const
08:02:58 <int-e> sjanssen: did you see the second rule there?
08:03:12 <norpan> vegai: or do you want it to do more? :)
08:03:20 <int-e> sjanssen: that rewrites it back to a lenAcc in most cases where fusion fails, I think.
08:04:20 <int-e> sjanssen: the incL makes sure it doesn't get inlined anywhere and thus serves as a marker
08:04:33 <vegai> norpan: well, I could just use that go for a beer ;P
08:05:28 <int-e> sjanssen: but I don't know if there's additional compiler magic there.
08:05:32 <erider> > (*) 457 277 337
08:05:33 <lambdabot>  add an instance declaration for (Num (t -> a))
08:06:41 <sjanssen> int-e: I think there must be some additional magic
08:10:34 <dcoutts_> Lemmih, so you applied too?
08:10:42 <Lemmih> dcoutts_: Yep.
08:10:52 <dcoutts_> Lemmih, cool
08:11:08 * dcoutts_ looks forward to having another great ghc maintainer
08:11:12 <Lemmih> (it's the best job I've ever seen)
08:11:31 <dcoutts_> yeah, if it is offered when I finnish my PhD I'm sure I'll apply
08:12:00 <norpan> translate it to finnish?
08:12:08 <norpan> ei saa peittää
08:12:08 <dcoutts_> hah
08:12:47 <dcoutts_> I'll be needing a 1 year thing when I finish (as my gf will have one year remaining of a 3 year post-doc)
08:18:54 <int-e> sjanssen: the [~1] means the rule only applies in phase 0, the [1] that it applies in phases 1 and later. for noinline the logic seems to be reversed (see GHC docs) so the NOINLINE [0] prevents the incL from being inlined in phase 0 so it'll still be there to be recognized by the second rule if no other fusion rules triggered. A grep indicates that there's no further magic in the compiler.
08:21:05 <dmhouse> *Yawn* Afternoon all.
08:21:31 <Lemmih> dmhouse: Hiya.
08:22:39 * offby1 glances around calmly. 
08:44:30 * shapr glances around excitedly!
08:44:54 <dmhouse> Hi there shapr.
08:46:23 <shapr> hiya dmhouse!
08:54:35 <Lemmih> dcoutts_, dons: ping.
08:54:45 <dcoutts_> Lemmih, aye?
08:55:54 <jmob|> so, say I want to extract the exit code from System.Cmd.system, how would I do so?
08:56:10 <jmob|> All I can figure out is how it the output from the I/O monad
08:56:13 <sjanssen> int-e: after further exploration, I've found that fused length does take linear stack
08:56:37 <dmhouse> jmob|: Perhaps investigate System.Process.
08:56:52 <shapr> Lemmih: Will you bring a unicycle?
08:56:54 <dmhouse> Oh, never mind.
08:57:07 <dcoutts_> sjanssen, it's part of the problem that ghc can't effeciently fuse foldl with list producers
08:57:10 <dmhouse> jmob|: Well, if you're in the IO monad, then it's simple.
08:57:27 <sjanssen> int-e: if you're interested, try this program with ghc -O vs. ghc -O -fules-off: main = print $ length [0 .. 2^21 :: Int]
08:57:29 <shapr> dcoutts_: If you show up, you'll bring your Coker?
08:57:30 <dmhouse> (as part of a do-block) ... code <- system "foo"
08:57:36 <dcoutts_> sjanssen, spj says ghc needs an extra arity analysis & transformation to do foldl in terms of foldr effeciently
08:58:05 <dcoutts_> shapr, it needs it's wheel rebuilding with a wider axel
08:58:31 <shapr> Ah, I wanted to try your coker.
08:58:48 <shapr> Secret Joy feels huge, I can only imagine a 36"
08:59:29 <Lemmih> shapr: If I can, yes.
09:03:01 <Lemmih> I'll finally be able to thank you in person for the seat. (:
09:03:34 * shapr grins
09:04:15 <shapr> Hiya simonpj!
09:04:24 * edwardk returns.
09:04:33 <simonpj> Re AngloHaskell, I'm delighted by the idea
09:04:46 <simonpj> but I've removed the "might offer facilities" from the wiki because
09:04:58 <Lemmih> Oh /-:
09:05:02 <simonpj> I don't want to even seem to offer something till i've checked at this end, ok?
09:05:09 <edwardk> so does someone want to beat up on my tvar based hash and show me what an idiot i am? =)
09:05:12 <shapr> Makes sense to me.
09:05:16 <simonpj> I'm hopeful tho
09:05:20 <simonpj> and hiya
09:05:34 <dcoutts_> hia simonpj :-)
09:05:42 <dmhouse> Wow, it's a real storm here. In the literal sense.
09:05:46 <Lemmih> simonpj: I got the rumour from Simon Marlow.
09:05:55 <dmhouse> And 'here' being Rüsselsheim, Germany, not #haskell.
09:05:56 <shapr> dcoutts_: Do you know of any pubs with wifi in Cambridge?
09:06:18 <edwardk> hi simonpj. read a lot of your papers. nice to see you in person er.. by proxy as it were =)
09:06:22 <dcoutts_> shapr, no, last time I was familiar with the Cambridge pubs was pre-wifi
09:06:39 <shapr> Right, we'll have to ask residents.
09:07:18 <shapr> simonpj: Meeting the people and talking (and maybe coding too) is the really fun part, and facilities and wifi are not necessary for that.
09:07:19 <dcoutts_> or possibly the graduate center
09:07:28 <shapr> It'll be fun however it shakes out!
09:08:23 <ndm> shapr, as long as a pub has beer, do you need wifi?
09:08:29 <dcoutts_> heh
09:08:51 <shapr> Probably not, but it's a lot easier to point to code than to talk about programming.
09:09:04 <shapr> I do wish a spoken programming language existed, it would make social programming simpler.
09:09:17 <shapr> You can't really describe quicksort to a newbie over lunch.
09:09:27 <simonpj> Yes, I'm not regarding being able to hang out at MSR as essential; but I'd like to offer if we can
09:09:48 <simonpj> no clue re wifi pubs; but would be surprised if nothing existed
09:10:12 <dmhouse> You should all post photos on that wiki page so people know who's who when they arrive. Either that, or wear namebadges with your IRC nicks on.
09:10:22 <shapr> I guess the guys at MSR don't unicycle much?
09:10:24 <edwardk> heh
09:11:03 * dcoutts_ should ask his sister if she can borrow a giraf unicycle
09:11:05 <shapr> A bunch of #haskell regulars met at ICFP2003, that was fun!
09:11:34 <ndm> we also did at ICFP 2005
09:11:42 <shapr> Yeah, I missed that one.
09:11:44 <dcoutts_> shapr, ever tried a giraffe unicycle?
09:11:49 <shapr> dcoutts_: Never, what's it like?
09:11:53 <dcoutts_> fun ;-)
09:12:00 <dcoutts_> not that hard
09:12:05 <shapr> dmhouse: The easy way to recognize some of us, spot the guys with the unicycles.
09:12:18 <dmhouse> Hehe.
09:12:22 <SamB> well, but how to know who is who?
09:12:34 <SamB> are you supposed to recognize them by their unicycles?
09:12:39 <shapr> SamB: Well, yeah?
09:12:43 * shapr grins
09:12:56 <SamB> as in know what each of the different unicycles looks like?
09:13:01 <dcoutts_> shapr will be the one with the chunky mountain unicylce
09:13:02 <SamB> and remember who owns it?
09:13:10 <edwardk> yeah the one on the giraffe will be dcoutts i guess ;)
09:13:22 * SamB wishes he could go to stuff like that
09:13:33 <dmhouse> SamB: me too.
09:13:33 <dcoutts_> heh, or the one with the enormous wheel (if I get it fixed in time)
09:13:42 <edwardk> when is this particular gathering/where?
09:13:50 * edwardk <<-- out of the loop
09:13:54 <dmhouse> edwardk: http://haskell.org/haskellwiki/AngloHaskell
09:13:55 <lambdabot> Title: "AngloHaskell - HaskellWiki"
09:14:01 <dmhouse> edwardk: Subscribe to the mailing lists. :)
09:14:13 <shapr> simonpj: Oh, I like reading your papers also :-)
09:14:22 <edwardk> ahh
09:14:27 <SamB> sometimes I can understand them too ;-)
09:14:34 <sjanssen> simonpj: I've written an unfoldr that works with GHC's fusion stuff.  Simon Marlow suggested I speak with you about it
09:14:41 <shapr> I was just reading STM with invariants today. That will be great for conjure for example.
09:15:16 * SamB wonders what Lemmih meant about conjure not working
09:15:49 <dcoutts_> simonpj, sjanssen, my impression is that it may have the same problem as other 'foldl's
09:15:57 <simonpj> Shapr, edwardk, Thank you for nice comments about papers. I enjoy writing them.
09:16:18 <dcoutts_> that it needs the extra analysis & transform to do foldl in terms of foldr effeciently
09:16:30 <simonpj> Got to go.  Re fusion, send email.
09:16:30 <shapr> simonpj: How do you find time to write so many papers? Do you sleep four hours a night or something?
09:16:35 <shapr> ok, bye!
09:17:28 * shapr is often amazed by simonpj's ability to write lots of good papers.
09:17:48 <edwardk> does anyone have any good suggestions for how to use quickcheck to test a datastructure?
09:17:57 <edwardk> or something similar
09:18:07 * zarvok lets out breath, having successfully resisted the urge to gush like a simonpj fanboy
09:18:27 * vegai follows suit.
09:18:45 <vegai> @vixen do you like Simon?
09:18:46 <lambdabot> yah, i like
09:19:27 <SamB> @vixen do you like
09:19:27 <lambdabot> sure, i definitely don't hate
09:19:38 <SamB> @vixen do you hate
09:19:38 <lambdabot> hating doesn't get you anywhere, so no
09:19:46 <SamB> @vixen do you hate me
09:19:47 <lambdabot> hating doesn't get you anywhere, so no
09:19:53 <SamB> @vixen do you like me
09:19:53 <lambdabot> yah, i like you
09:20:17 <Frederick> @vixen what time is it?
09:20:17 <lambdabot> i don't know, what?
09:20:23 <Frederick> =/
09:20:35 <vegai> @vixen math is hard, let's go shopping
09:20:36 <lambdabot> Prolly
09:20:57 <Frederick> @vixen do you like dogs?
09:21:05 <SamB> @vixen what do you think
09:21:24 <SamB> hmm
09:21:32 <Frederick> wooooooops I  think he got lost =/
09:22:07 <lambdabot> yah, i like
09:22:09 <lambdabot> i don't know, what?
09:22:19 <ndm> shapr, maybe its because spj spends less time on IRC ;)
09:22:52 <vegai> hmm, cabal's biting me in the ass a bit.
09:23:03 <vegai> or something. My rebuilds don't reflect to my changes, or so it seems.
09:23:39 <Lemmih> ndm: hehe (:
09:24:47 <SamB> chris covell came to #zsnes once... I did not quite resist the urge to gush like a fanboy
09:27:23 <dcoutts_> edwardk, we use quickcheck heavily for testing Data.ByteString 
09:27:54 <edwardk> trying to figure out a good way to test to make sure that my hash table isn't blowing up inside =)
09:27:57 <dcoutts_> we have a model (Lists) and we use quickcheck to compare our impl to that model
09:28:15 <edwardk> i suppose i can model data.hashtable pretty closely
09:28:45 <dcoutts_> see the presentation on the fps site, it has an intro to our use of quickcheck
09:28:48 <edwardk> modulo IO ~ STM
09:28:49 <edwardk> kk
09:45:31 <vegai> did lambdabot have some sort of reload command for the plugins?
09:46:45 <edwardk> which f these you do you find more intuitive:
09:46:57 <edwardk> hashInt' k0 = k6 
09:46:57 <edwardk>         where 
09:46:57 <edwardk>         k1 = k0 + complement (k0 `shiftL` 15) 
09:46:57 <edwardk>         k2 = k1 `xor` (k1 `shiftR` 10) 
09:46:57 <edwardk>         k3 = k2 + (k2 `shiftL` 3) 
09:46:58 <edwardk>         k4 = k3 `xor` (k3 `shiftR` 6) 
09:47:00 <edwardk>         k5 = k4 + complement (k4 `shiftL` 11) 
09:47:02 <edwardk>         k6 = k5 `xor` (k5 `shiftR` 16)
09:47:06 <edwardk> or
09:47:10 <edwardk> hashInt = ap xor (`shiftR` 16) 
09:47:10 <edwardk>         . ap (+) (complement . (`shiftL` 11)) 
09:47:12 <edwardk>         . ap xor (`shiftR` 6) 
09:47:14 <edwardk>         . ap (+) (`shiftL` 3) 
09:47:16 <edwardk>         . ap xor (`shiftR` 10) 
09:47:18 <edwardk>         . ap (+) (complement . (`shiftL` 15)) 
09:47:20 <edwardk>         where ap x y z = x z $ y z
09:47:24 <edwardk> ?
09:48:07 <shapr> ndm: That's likely it.
09:49:13 <shapr> edwardk: You could also use the invariants part of STM for Eiffel-style design-by-contract that's checked at runtime.
09:49:40 <xerox> The second one is really cool :-)
09:49:58 <edwardk> shapr: kinda don't want to introduce contracts because i'm paranoid about speed of implementation.
09:50:02 <shapr> edwardk: I'd go for the second as well, but then again, I actually like arrows.
09:50:07 <Spark> edwardk: theyre both the same to me
09:50:17 <shapr> edwardk: I bet it's worth trying at least.
09:50:19 <Spark> ah no i see the difference
09:50:28 <edwardk> hey i like arrows too. just would like them more if i could parameterize type classes and limit the scope of arr to something smaller
09:50:56 <edwardk> spark: yeah you have to read the second 'bottom up'
09:50:57 <xerox> he he again.
09:51:13 <Spark> you could write the other one the other way up though
09:51:15 <shapr> edwardk: Yeah, I agree with that.
09:51:54 <Philippa> edwardk: you are far from the first person to think that... (although usually in the context of monads)
09:51:58 <edwardk> spark: suggestion on the style fix to get there?
09:52:25 <Spark> personally i'd go with the top one as is, as i actually like imperative programming :)
09:52:32 <edwardk> heh
09:53:10 <edwardk> what would be a clean way to invert the flow of the point-free one to go the other way?
09:53:16 <edwardk> i'm afraid i don't have all the tricks down
09:53:38 <edwardk> just some sort of where randomsymbol = flip (.) ?
09:54:54 <erider> how can haskell help my programming?
09:55:04 <Spark> not sure actually
09:55:10 <nothingmuch> erider: do you want to hear personal testimonials?
09:55:18 <edwardk> erider: depends on what your strengths are coming into the language =)
09:55:24 <nothingmuch> i've not actually programmed much in haskell, but it has vastly improved my OO design skills
09:55:36 <ndm> erider: faster code, less bugs, more fun, more functions :)
09:55:39 <nothingmuch> (i am a perl coder by profession)
09:55:56 <erider> yes please if it is not too much trouble if so don't worry about it
09:56:46 <edwardk> erider: well, it gets you used to higher level abstractions, which can be useful even when returning to scripting languages, because after time in haskell you become really comfortable with their functional subsets (join, map, etc)
09:57:10 <edwardk> erider: which can lead to very clean and concise code (well, by the standards of those languages anyways) =)
09:57:48 <ndm> erider: it gives you new perspectives on problems, letting you pick the best approach, rather than those you are currently familiar with
09:57:53 <erider> I'm using abstraction in lisp 
09:58:08 <erider> how are the two languages different 
09:58:12 <ndm> less brackets is the obvious advantage then!
09:58:18 <edwardk> personally: i find that the haskell way to do things is very clean and lends itself to thinking about the specification of the problem more than the plumbing of how to shuffle bits around. monad, etc help you shuttle aside all the details of which copy of a pure object you are carrying around and just work
09:58:25 <ndm> haskell is typed, so it catches a lot more bugs at compile time
09:58:34 <ndm> its also lazy, which means you have to think about things less
09:58:50 <Philippa> ndm: we're not on LtU, the phrase you want is "statically typed" :-)
09:58:55 <ndm> rather than focusing on the mechanics - which lisp already frees you from mostly - you can ignore them entirely
09:59:48 <edwardk> erider: fewer parens for one, an amazing type system that catches your errors, lazy evaluation means you can do infinite lists without using special language constructs for the comprehension, and its _purely functional_ which means you can be sure of the lack of side effects so the compiler can perform more optimizations, etc.
09:59:50 <erider> hmm where do you get started 
09:59:54 <edwardk> but
10:00:02 <edwardk> ndm seems to have said most of those while i typed that =)
10:00:13 <edwardk> @where YAHT
10:00:13 <erider> and do you read code from right to left 
10:00:13 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
10:00:14 <zarvok> erider:  Plus, haskell is purely functional, which makes it easier to prove things about your code than lisp
10:01:09 <edwardk> erider: sometimes, kinda like lisp if you nest stuff in ()'s or (\x -> ...) lambdas or use $ to omit parens, you can get just as deeply nested.
10:01:17 <Killer666> what is the reason why java is more popular in business apps than haskell?
10:01:23 <erider> so you are dealing with factural expression and symbolic algebre
10:01:50 <norpan> Killer666: many reasons, more mature technology, sun's pushing it very hard, marketing, etc
10:01:53 <ndm> Killer666: managers, pointy haired people, and more people no Java
10:01:57 <edwardk> killer: well, reflection, and most people come from a c background so they are used to impure imperative programming, haskell is pure functional.
10:02:00 <Philippa> Killer666: Java's a reasonably conservative extension of the same old stuff business apps've been using for decades
10:02:14 <Killer666> i see
10:02:17 <Philippa> plus it's OO, plus it had a good niche market to get enough people learning it
10:02:20 * erider says "run for you lifes its java the memory monster!"
10:02:42 <edwardk> its the opposite side of the language spectrum, and you use more mathematics in your day to day programming in haskell. the io system has its roots (somewhat distantly) in category theory, which can scare people off
10:02:50 <norpan> haskell is also a potential memory monster
10:02:58 <edwardk> heh, well, so is java =)
10:03:16 <norpan> yes, i was responding to erider
10:03:50 <norpan> the graph evaluation plays some tricks with memory usage sometimes
10:03:53 <erider> hmm where does one get started with haskell
10:03:56 <Killer666> i remember that turbo pascal with 60K memory limit was fun
10:04:20 <norpan> @google a gentle introduction to haskell
10:04:23 <lambdabot> http://www.haskell.org/tutorial/
10:04:23 <lambdabot> Title: "A Gentle Introduction to Haskell, Version 98"
10:04:50 <erider> so haskell is purely an algebraic language
10:04:52 <edwardk> but admittedly, haskell code can tend to take up more space than the equivalent java program if written in pure functional style because of the number of throwaway objects it makes
10:05:25 <norpan> the best thing about haskell imo is it's purity
10:05:47 <norpan> its
10:05:52 <norpan> i never get that right
10:05:53 <edwardk> being able to say that two expressions are equal in a mathematical sense has a great beauty to it
10:06:32 <erider> so I would need to you a good amount of math to be effective in the language?
10:06:35 <edwardk> its hard to use math to reason about programs in imperative languages, but then haskell goes and slips in an imperative sublanguage with all the same rigor
10:06:42 <edwardk> erider: not really.
10:06:43 <erider> s/you/use
10:06:46 <edwardk> erider: you know lisp right?
10:07:05 <norpan> haskell is like lisp, but pure and with static type checking...
10:07:09 <edwardk> erider: same skillset works here, in fact you can translate almost word for word as you pick up more knowledge of the language
10:07:25 <edwardk> you can then extend that subset of the language you use
10:07:46 <NotInventedHere> norpan: but with a *much* nicer syntax
10:08:00 <edwardk> the monads and arrows have pretty pointy-headed origins, but they can be used by joe-average programmer once you take the time to read a tutorial on them
10:08:21 <norpan> yeah, the haskell syntax is ok
10:08:26 <erider> I have look at some of the sytnax and I'm not sure I like the style
10:08:39 <norpan> erider: haskell lets you choose style
10:08:47 <edwardk> the trickiest thing about haskell is that its io subsystem is built over monads, so you have kind of a leap to make to get used to io, but after that its amazing how well that interface generalizes to everything
10:08:57 <NotInventedHere> erider: what specifically don't you like?
10:09:04 <norpan> if you want to use { and ; you can
10:09:20 <erider> well I'm kinda use to the prefix style 
10:09:36 <NotInventedHere> oh I see
10:09:45 <norpan> the prefix style being exactly?
10:09:59 <edwardk> > ((+) 1 2)
10:10:00 <lambdabot>  3
10:10:02 <edwardk> =)
10:10:05 <NotInventedHere> lisp!
10:10:13 <edwardk> ^-- note that was interpreted by haskell
10:10:15 <erider> cool 
10:10:27 <NotInventedHere> lisp makes my brain hurt
10:10:27 <norpan> > let add x y = x + y in add 2 3
10:10:28 <lambdabot>  5
10:10:37 <erider> > ((*) 3 4)
10:10:38 <lambdabot>  12
10:10:40 <edwardk> the only quirky part is that operators have to be wrapped in ()'s because haskell lets you also use
10:10:47 <edwardk> > 1 + 2
10:10:47 <lambdabot>  3
10:11:10 <edwardk> putting them in quotes makes them prefixes like all the other functions
10:11:51 <erider> why is there no block structure or maybe I can't see it
10:12:01 <NotInventedHere> edwardk: I think it's a bad idea to recommend someone to use a style from a different language (like lisp). It's akin to telling someone: hey, you can make C look like pascal by using a bunch of #defines... ;-)
10:12:15 <edwardk> block structure like prog?
10:12:21 <erider> I can separate my expression with the parens 
10:12:29 <NotInventedHere> just bite the bullet and learn to get comfortable with the syntax: once you do, I guarantee you will start to love haskell
10:12:35 <edwardk> not: heh, well, i'm mostly trying to point out its a subset of the language. =)
10:12:47 <NotInventedHere> true
10:12:54 <norpan> erider: separate expressions? you'd need some kind of operator to make a new expression out of expressions
10:13:57 <erider> what are the primatives of the language? and is there a lot to learn in the core of the language 
10:14:12 <norpan> you can make function declarations
10:14:17 <norpan> and call functions
10:14:27 <edwardk> here you don't tend to use parens as statement separators,, because the entire language isn't built up out of parens. if you want multiple declarations you tend to basically say what you are declaring and set it equal to an expression, so foo = bar is your (define ... )
10:14:57 <norpan> and that's all you need to know to start with
10:15:05 <erider> so = is like defun 
10:15:15 <NotInventedHere> erider: yes
10:15:31 <edwardk> yeah
10:15:49 <erider> and it is a compiled language 
10:15:53 <edwardk> yep
10:16:11 <erider> so I have to get the compiler ghc 
10:16:11 <edwardk> btw- i'm a fairly recent haskell convert myself
10:16:29 <edwardk> i tend to recommend grabbing both ghc and hugs
10:16:34 <Philippa> edwardk: one quirk if you're used to lisp is this:
10:16:35 <NotInventedHere> erider: but I have to say I also really like using the "where" notation: it reminds so much of mathematics, and it just feels like I'm reading literally.
10:16:37 <Philippa> > ((+) 1 2 3)
10:16:38 <lambdabot>  add an instance declaration for (Num (t -> a))
10:16:48 <edwardk> phillippa: good point =)
10:16:51 <xerox> > sum  [1,2,3]
10:16:52 <lambdabot>  6
10:17:09 <Philippa> erider: there aren't any cons cells, at least not the way you get them in lisp
10:17:37 <edwardk> our cons is :, but we pass our function arguments in a little differently
10:17:40 <erider> so how is data and objects structured 
10:17:45 <Philippa> datatypes
10:17:53 <Philippa> data MyList a = Nil | Cons a (List a)
10:18:00 <NotInventedHere> erider: or records as well
10:18:20 <Philippa> that declaration is equivalent to the built-in list type, aside from some mild syntactic sugar
10:18:20 <erider> and no tables 
10:18:24 <xerox> In lisp you have variadic functions, in Haskell you have implicit currying. You decide.
10:18:28 <erider> or hashes 
10:18:39 <Philippa> there're maps and hashtables in the hierarchical libraries
10:18:42 <NotInventedHere> true: I think records are probably the weak point of haskell
10:18:43 <edwardk> erider: we have hashes, they are just writtn in the language
10:18:44 <Philippa> but they're not built in
10:18:56 <xerox> FSVO built in.
10:19:18 <xerox> `It comes with the compiler' is quite a good approximation of `built in', in my opinion.
10:19:24 <edwardk> fair enough
10:19:34 <erider> so I have to add external libraries to add socket support?
10:19:43 <xerox> ?docs
10:19:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:19:43 <NotInventedHere> yes: it's in missingh
10:19:58 <xerox> There surely is something in the libraries that comes with GHC.
10:20:02 <Philippa> yes, there is
10:20:06 <edwardk> that one is still separate, there is some sort of haskell net project for it
10:20:11 <Philippa> it's not complete, but it's enough to write a lot of stuff
10:20:14 <xerox> The `Network' hierarchy.
10:20:25 <Philippa> edwardk: that's about protocols layered on top of TCP/IP
10:20:28 <xerox> Oh, and there is HaskellNet, the SoC project.
10:20:58 <erider> so what is haskell main use to write
10:20:59 <Philippa> erider: the hierarchical libraries that come with GHC et al are de facto standard libraries
10:21:08 <erider> *mainly
10:21:18 <edwardk> erider: heh, well, it seems like the major use of haskell is to write haskell compilers ;)
10:21:21 <Philippa> interpreters and compilers, but once you step outside academia it's pretty much anything you fancy
10:21:22 <edwardk> j/k =)
10:21:32 <Philippa> not just haskell interpreters and compilers :-)
10:21:36 <edwardk> heh
10:21:41 <Philippa> Haskell makes an excellent metalanguage
10:21:48 <edwardk> yeah i'm using it for a javascript parser/interpreter/compiler
10:22:02 <edwardk> pugs is the current reference implementation of perl6 and is written in haskell
10:22:03 <edwardk> etc.
10:22:16 <NotInventedHere> erider: doesn't sound very glamorous, but I actually use it a lot for scripting (since we have to use another language at work)
10:22:20 <erider> I heard that today 
10:23:19 <edwardk> the main thing i really like about haskell is that the type system is like 10x stronger than any i've seen in any other language without locking you into rigid type specifications.
10:23:31 <NotInventedHere> erider: I would say that the only thing you *can't* use it for is for writing numerical analysis stuff -- it's still a little bit slow here. However, this is supposed to imporve with new releases, and you really want to link wtih external libraries here anyways.
10:23:43 <edwardk> the result is that code written in haskell almost  always seems to work perfectly when it successfully type checks
10:24:19 <erider> well is sounds interesting
10:24:38 <erider> is there a macro system
10:24:40 <Philippa> want an explanation of that list type I defined? It'll probably explain a lot
10:24:56 <Arnia> erider: Template Haskell
10:25:09 <Philippa> there's an extension called Template Haskell that does multi-staged programming, but there's no macro system per se
10:25:18 <Philippa> TH doesn't do syntax extensions
10:25:40 <erider> hmm I see 
10:25:46 <xerox> What does DrIFT do?  (/me launches the question randomly.)
10:25:46 <NotInventedHere> erider: one thing to bear in mind: if you try it, there *will* be moments of strong frustration (for me monads where a bit non-intuitive at first). But once you "get it", it all seems very logical and elegant.
10:25:50 <Philippa> you don't need it as much as you would in lisp though, because lazy evaluation means you don't need macros just for evaluation order stuff
10:25:58 <erider> so you can't create the language in your own image
10:26:04 <Philippa> for example, you can write this function:
10:26:31 <Philippa> if cond t e = case cond of {True -> t; False -> e}
10:26:36 <erider> macros are use to stop repeated operations 
10:26:38 <Philippa> and that's if, right there
10:27:12 <erider> what is the functions name 
10:27:16 <Philippa> people build entire libraries of combinators that effectively implement small languages
10:27:17 <Philippa> "if"
10:27:20 <erider> is it E
10:27:31 <Philippa> strictly speaking, that's bad because there's a keyword-based if, but if' would work fine
10:27:33 <norpan> i've never needed macros, you just use normal functions
10:27:51 <Philippa> I've found uses for a macro-like system, Haskell's not so good at reflection at the moment
10:28:27 <Philippa> norpan's experience is probably the more common though
10:28:42 <NotInventedHere> I concur with norpan
10:28:57 <Philippa> erider: "if cond t e = ..." declares a function "if" with parms cond, t and e
10:28:59 <edwardk> erider: you don't use macros to stop operations in haskell, because of the evaluation order here
10:29:00 <norpan> of course, with ghc you can use c style macros
10:29:29 <Philippa> strictly speaking, cond, t and e are "patterns", because you can declare functions like this:
10:29:32 <Philippa> not True = False
10:29:34 <Philippa> not False = True
10:29:38 <erider> so for a beginning that is not upto writing a compiler or interperter, where do you go with haskell if that makes since 
10:29:46 <Philippa> interpreters're surprisingly easy, in fact
10:29:55 <edwardk> erider: depends on what you like to do in your day to day life
10:30:10 <edwardk> erider: what do you code in your free time?
10:30:20 <Philippa> I can build a small four-operator desk calculator right here and now...
10:30:24 <xerox> Programming langauges whose type system is CT? heh heh
10:30:24 <erider> bots 
10:30:39 <erider> and like network stuff 
10:30:40 <edwardk> xerox: heh, you're somewhat stuck on that ;)
10:30:46 <Philippa> have a poke around lambdabot then
10:30:49 <edwardk> lambdabot here is written in haskell
10:31:03 * xerox cringes
10:31:06 <Philippa> though it uses hs-plugins which might confuse you a bit
10:31:06 <edwardk> @where lambdabot
10:31:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:31:13 <erider> and telecomunications stuff for palmOS 
10:31:48 <Philippa> a word of warning: doing IO isn't hard per se, but is scary until you realise it's not
10:32:06 <Philippa> just have some courage, and remember that do isn't the start of a loop
10:32:16 <erider> hmm what does that mean exactly 
10:32:20 <edwardk> yeah, when doing io pretend you are writing in another language while you learn monads
10:32:33 <edwardk> then you later can realize its just the same stuff as before with some syntactic sugar
10:33:22 <xerox> Are there different kinds of syntactic sugar?
10:33:22 <NotInventedHere> one thing I had problems with, is that when I had do foo <- bar x, I couldn't write do foo <- f (bar x), where f isn't an action
10:33:28 <edwardk> erider: well, haskell is lazy, right? so you don't know the order of evaluation of your function argumments, and its pure so you can't do io as a side effect of a function in the traditional sense, because calling the function has to give the same result as just reusing its output
10:33:49 <Arnia> An area where Haskell excels is the creation of Embedded Domain Specific Languages
10:33:50 <xerox> NotInventedHere: foo <- liftM f (bar x)
10:33:55 <NotInventedHere> exactly
10:34:03 <NotInventedHere> or, let f_foo = f foo
10:34:21 <Philippa> Arnia: I'm not sure it "excels" compared to lisp, although it certainly competes
10:34:21 <NotInventedHere> or: foo <- return . f =<< bar x
10:34:27 <edwardk> erider: so to work around this without requiring some sort of hack to switch to eager evaluation, the haskell community came up with an idea about how to use this thing called a monad to order operations in such a way that you could still use equational reasoning, still be lazy, aan still have your cake and eat it too
10:34:35 <erider> ok how do you setup arguments in a function 
10:34:41 <edwardk> foo a b = a + b
10:34:44 <xerox> ?pl \f xs -> xs >>= return . f
10:34:44 <lambdabot> fmap
10:34:46 <xerox> (-;
10:34:49 <Arnia> Philippa: I find haskell's EDSLs to be much clearer
10:34:50 <SamB> basically you return what would have been a side effect ;-)
10:34:50 <edwardk> or
10:34:56 <Arnia> But that is a personal preference :)
10:34:56 <edwardk> foo = \a b = a + b 
10:34:58 <edwardk> or...
10:35:06 <edwardk> foo = (+)
10:35:09 <edwardk> or... =)
10:35:13 <xerox> edwardk - The second one is a -> not a =.
10:35:17 <edwardk> woops
10:35:18 <edwardk> typo
10:35:38 <erider> ok foo is the name and a and b are the argument and after the = is the definition of the function?
10:35:41 <Philippa> Arnia: yeah, I reckon lisp has the lead for DSLs where you can replace read and Haskell for EDSLs unless you have a prefix fetish
10:35:48 <edwardk> erider: yeah
10:36:03 <edwardk> eider the second sets foo equal to a lambda expression with two arguments a and b
10:36:27 <edwardk> the third just notes that i'm just passing my arguments forward to (+) anyways, so uses 'pointfree' style
10:36:33 <SamB> Haskell also has a type system, you know, Philippa
10:36:40 <erider> so the lambda is not shown 
10:36:52 <erider> the = is use to say lambda?
10:36:57 <SamB> which can be used to good effect
10:36:57 <Philippa> SamB: if you're really stuck for any other way, build an interpreter
10:37:03 <edwardk> erider the lambda symbol in haskell is \
10:37:12 <NotInventedHere> eg \x -> x + 1
10:37:20 <edwardk> lambda a . a      is \ a -> a
10:37:29 <Philippa> I don't know haskell's type system is necessarily beneficial for the user of an EDSL, the error messages won't contain any info from the domain
10:37:39 <erider> what is the arrow
10:37:46 <Philippa> it's a separator
10:37:48 <SamB> well... it depends what kind of users you have ;-)
10:37:58 <Philippa> in the lambda calculus, it's \x.e, in haskell it's \x -> e
10:38:26 <edwardk> the reason we don't use lambda calculus's dot is that we use dot for function composition
10:38:27 <SamB> if you have users who already know the substrate, they should be fine, right?
10:38:31 <Philippa> I'm an experienced user and my first thought was that you meant it as a negative point wrt EDSLs, 'nuff said? :-)
10:38:44 <erider> what are ::
10:38:45 <Philippa> more or less
10:38:47 <edwardk> and for module namespaces
10:38:51 <edwardk> :: is a type definition
10:39:00 <SamB> depends what you mean by domain-specific, I guess
10:39:00 <Philippa> no, it's a type /annotation/
10:39:08 <edwardk> it says something about what the value of an expression is, or what types of arguments it takes
10:39:10 <erider> so you have to define type 
10:39:13 <edwardk> phil: true enough
10:39:20 <edwardk> erider: no, but its useful documentation
10:39:30 <edwardk> eridere: if you don't in 99% of the cases haskell can figure it out
10:39:30 <Philippa> edwardk: this is a personal quirk, but please don't abbreviate my name to one of the other gender?
10:39:43 <edwardk> philippa: sure thing
10:39:55 <SamB> like, don't you have a TAB key?
10:39:57 <Philippa> thanks :-)
10:40:08 <SamB> ph<TAB> is all *I* have to type
10:40:24 <norpan> is phil necessarily a man?
10:40:27 <edwardk> samb: heh, well, i come from a ircii background. i haven't gotten used to that habit yet =)
10:40:39 <SamB> ircii doesn't have that?
10:40:40 <Philippa> norpan: almost always
10:40:45 <norpan> but not in this case
10:40:57 <edwardk> samb: didn't when i used it =)
10:41:05 <edwardk> samb: i haven't irc'd much since around 95
10:41:16 <SamB> heh
10:42:03 <SamB> I never really got anywhere with IRC until I started with Linux, which was probably around 2000
10:42:09 <erider> sounds good I have finished downloading hug and ghc and I going to give it a go 
10:42:40 <edwardk> hugs is basically faster to use for quick command line stuff if you just want to see if something is a legal expression
10:42:41 <norpan> erider: remember that this is the most helpful channel in the whole world
10:43:08 <norpan> otoh, ghc has an interpreter too
10:43:13 <edwardk> ghc is a compiler, lots of advanced language features, it includes a repl loop but its not as snappy to start up
10:43:22 <Philippa> yeah, I use ghci more than anything else
10:43:25 <erider> one question a function is a complete program right?
10:43:32 <Philippa> evaluation's pretty quick though
10:43:38 <Philippa> erider: yes and no
10:43:46 <Philippa> more accurately, an "IO action" is a complete program
10:43:47 <norpan> erider: a function is a function, a program is a function of type IO ()
10:44:04 <NotInventedHere> actually: why hugs' speed the only factor favouring it for scripting?
10:44:11 <Philippa> but an IO action is Just Another Value, it just has a particular type
10:44:17 <erider> ok in lisp a function is a complete program 
10:44:22 <Philippa> (functions're just another value too)
10:44:40 <erider> and you can add it to other programs or forms 
10:44:40 <SamB> actually, a program is a collection of modules one of which is called "Main" and exports a function called "main" of type "IO ()"
10:44:41 <Philippa> functions are "complete" in the sense you can call one from an interpreter and get useful results
10:44:48 <Arnia> erider: For a nice example of why laziness is so powerful see http://citeseer.ist.psu.edu/karczmarczuk98functional.html (however this is a fairly mathematical example... I'll dig for more 'concrete' ones if you like)
10:44:53 <edwardk> erider: most haskell programs have a main :: IO () function that takes the place of a c style main
10:44:53 <Philippa> they just don't get to do IO and thus aren't really "programs" as such
10:44:57 <NotInventedHere> Philippa: in fact actions are just functions! ;-)
10:45:02 <Philippa> NIH: no they aren't
10:45:14 <Philippa> they have a denotational semantics describing them as functions
10:45:19 <Philippa> that's not the same thing
10:45:25 <NotInventedHere> what?
10:45:25 <erider> so there is a entry point
10:45:34 <Philippa> yes
10:45:44 <NotInventedHere> if they're not functions, how can haskell compile them?
10:45:46 <norpan> is there even such a thing as an "action" defined
10:45:47 <Philippa> although any IO action is "a program", and you could bind main to any of them
10:45:52 <Philippa> NIH: because they're still values
10:46:10 <NotInventedHere> actually: you're right -- my bad
10:46:14 <Philippa> norpan: it's an informal term for "a value whose type is subsumed by IO a"
10:46:23 <norpan> a nullary function :)
10:46:39 <erider> can you pass functions to other functions 
10:46:44 <norpan> sure
10:46:46 <NotInventedHere> yes
10:46:48 <edwardk> erider: yep
10:46:49 <Philippa> (putStr "Hello world!") is an action
10:46:55 <Philippa> yeah, and you can pass IO actions around as well
10:47:06 <edwardk> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in take 20 fib
10:47:07 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
10:47:16 <NotInventedHere> eg writeHello = putStr "Hello world"
10:47:21 <edwardk> (+) is a function, so is zipWith
10:47:34 <norpan> and fib
10:47:39 <edwardk> yeah
10:47:39 <Philippa> no, fib is a list
10:47:42 <norpan> a nullary function :)
10:47:47 <Philippa> norpan: *NO*
10:48:00 <Philippa> Haskell does not have nullary functions. All functions in Haskell have exactly one parameter.
10:48:08 <Philippa> (but currying is your friend, etc etc)
10:48:12 <norpan> except nullary functions
10:48:16 <norpan> which are called values
10:48:22 <Philippa> and *aren't functions*
10:48:57 <norpan> says you
10:49:18 <Philippa> says the definition of function that's relevant
10:49:48 <Philippa> we aren't coding in C here. Nor are we coding in the lambda calculus.
10:50:26 <norpan> i like to call values nullary functions
10:50:58 <Philippa> and in doing so, you use a different definition of function to the one haskell is based upon. In technical discussion, it's not a valid thing to do.
10:51:37 <Philippa> there are cases in which it's possible to discern the difference. A trivial one: "all functions have a type of the form a -> b"
10:51:50 <integral> norpan: I guess you call elements of (a -> b -> c) trinary functions too
10:51:53 <Philippa> or for that matter "all functions can be applied to yield a value"
10:52:37 <norpan> then you have to separate between values that are functions and values that are not
10:52:39 <Philippa> integral: I'll informallly call it a function of two parameters, because it's isomorphic to one. But there aren't any nullary functions for a value to be isomorphic to
10:52:43 <norpan> and that's the same difference
10:52:55 <cognominal> what is the best way to have ghc on an intel macbook?
10:53:02 <Philippa> no, it's not. It's a useful difference, a meaningful one
10:53:08 <cognominal> 6.4.1 or above...
10:53:19 <norpan> in my opinion it's just a matter of naming
10:53:34 <NotInventedHere> cognominal: I was wondering the same
10:53:34 <Speck> it is just naming, but names are meaningful
10:54:16 <Philippa> and using them in a way contrary to established meaning is something that should be done with care
10:54:16 <norpan> Philippa: if i define f = 1, what is f
10:54:27 <Philippa> f is a variable, bound to the value 1
10:54:40 <norpan> a VARIABLE?
10:54:43 <Philippa> (and thus, it evaluates to the value 1)
10:54:59 <norpan> surely not a variable
10:55:01 <Speck> single-assignment variable :-)
10:55:08 <Philippa> norpan: why not?
10:55:16 <Philippa> it's /mutable/ variables that haskell doesn't have
10:55:17 <NotInventedHere> because it doesn't vary
10:55:32 <Philippa> NotInventedHere: it does between bindings
10:55:35 <norpan> because it's not a variable, variables are what you use in patterns
10:55:42 <Philippa> that's a pattern
10:55:44 <norpan> it's a name
10:55:47 <Philippa> really, go read the report, it's a pattern
10:56:10 <Philippa> I got into an argument on here a few weeks about that and I was wrong, so I remember that one well :-)
10:56:20 <Philippa> *a few weeks ago
10:56:41 <pejo> cognominal, there is a 6.5 snapshot by Wolfgang somewhere.
10:57:14 <Arnia> http://cvs.haskell.org/trac/ghc/wiki/X86OSXGhc
10:57:15 <lambdabot> Title: "X86OSXGhc - GHC - Trac"
10:57:28 <Arnia> Works quite well
10:57:46 <Arnia> Well, got wxHaskell working at last :)
10:58:17 <NotInventedHere> Philippa, about your statement about actions not being functions: can you elaborate? I'm confused because the "do" notation essentially desugars into a "catenation" of a lambdas, no?
10:58:26 <NotInventedHere> That's why I think of an action as a function
10:58:28 <Philippa> it does, but they're applied
10:58:51 <Philippa> (\in -> print in) is a function
10:58:58 <NotInventedHere> yes
10:59:02 <Philippa> getLine >>= (\in -> print in) isn't
10:59:28 <NotInventedHere> ok
10:59:32 <Philippa> for approximately the same reason ((\x -> x) foo) isn't a function
10:59:39 <Philippa> (unless foo is, of course)
10:59:45 <NotInventedHere> ah - actually makes sense
11:00:15 <Philippa> right, can I take off my official pedant hat now?
11:00:16 <xerox> Philippa's last one is an expression.
11:00:24 <edwardk> i thought the whole point of the io monad was to continue to be able to use them as functions, because laziness can't cheat around the fact that it can't make a new world object in the definition of the IO type, so we can still equate them, we just can't get the same one or something
11:00:31 <Philippa> xerox: read syntactically, yes :-)
11:00:34 <NotInventedHere> Philippa: but: foo :: Int -> IO Int IS a function
11:00:43 <Philippa> NotInventedHere: right
11:00:58 <NotInventedHere> yeah ok: that's where I was getting confused.
11:00:58 <Philippa> edwardk: to use them "purely", not quite the same thing
11:01:32 <cognominal> thx Arnia and pejo
11:01:32 <Philippa> edwardk: it avoids needing functions that aren't pure
11:01:38 <cognominal> i must go&
11:02:14 <Philippa> sure, we sometimes describe IO actions as denoting functions with the type World -> (World, a), but there aren't any such functions in the language
11:02:14 <xerox> edwardk - Somehow you are right, because everything reduces to function application in teh end.
11:02:20 <xerox> Haskell is lambda calculus with sugar ontop..
11:02:38 <edwardk> *nods*
11:02:41 <norpan> Philippa: hey, you are right, it is a pattern
11:02:46 <norpan> you learn something new every day
11:03:00 <Philippa> xerox: Haskell can be defined as such, not quite the same thing :-)
11:03:37 <Philippa> the report doesn't define the meaning of data constructors in terms of the lambda calculus, and this is IMO a good thing
11:04:04 <xerox>  Agreed :)
11:04:20 <Philippa> if you want to describe it as an extended lambda calculus plus sugar then sure, give or take the type definitions I'm with you :-)
11:04:58 <norpan> then i concede, there can't be nullary functions
11:04:59 <norpan> too bad
11:05:01 <norpan> i like them
11:05:06 <edwardk> heh
11:05:13 <Philippa> they make a sensible concept in languages like C
11:05:14 * xerox wonders of the conversations of the AngoHaskell
11:05:29 * Arnia is tempted to go
11:05:49 <Arnia> Drag some others down from Durham too :)
11:06:16 <norpan> Philippa: is it okay to say that functions are all values with arity > 0?
11:06:52 <Philippa> norpan: sure, so long as you realise arity's an essentially informal concept here
11:07:21 <norpan> there must be something like it for type checking
11:07:24 <Philippa> I'll talk about "functions with two parameters", because there's an isomorphism and so it's reasonably fair game - currying matters, but only when it matters
11:07:26 <Philippa> no
11:07:27 <edwardk> well, we curry, so all functions take a value of one type and return a value of another, that type possibly being a function =)
11:07:42 <Philippa> you can do all the type checking in terms of single-parm application and single type constructor for functions
11:07:55 <Philippa> said constructor being (->)
11:07:56 <edwardk> no arity per se, arity is the concept that the chain of those function returns probably terminates, but it doesn't have to
11:08:17 <norpan> at least constructors have arities
11:08:20 <xerox> This sounds like the Stack implemented as GADT
11:08:23 <Philippa> that's isomorphic to the n-parm function not terminating though
11:08:31 <Philippa> norpan: they do, but not when treated as functions
11:08:50 <cedricshock> I've got a neat little question: Say I have a big data structure (a tree of tuples or somesuch), a company to use a normal example, that includes some object, like a specific employee. I'm going to fire that employee and replace him with a new one everywhere in the company. What's the easy way to do this? What's the fast way if I don't need the old company anymore?
11:09:07 <Philippa> you can typecheck the application of a constructor without caring it's a constructor
11:09:14 <norpan> but for each value there is a computable number which we can call arity
11:09:26 <Philippa> it's a 'sanity check' on pattern matching, granted
11:09:37 <Philippa> there is, but it doesn't always match the intention
11:09:58 <edwardk> cedric: depends on the datastructure, if it has some form of search and replace lifting function for you to use.
11:09:59 <xerox> data Stack f where Frame :: ;f (Stack a) -> Stack (f a)
11:10:01 <xerox> ops.
11:10:01 <Philippa> I say that because the only sensible way I can think to do it is to chew up all the arrows on the LHS, and sometimes you genuinely intended to return a function
11:10:10 <norpan> and for non-function values that number is 0 and for function values it's > 0
11:10:22 <Philippa> yes
11:10:27 <norpan> but all that matters for type checking is if it's 0 or not
11:10:30 <edwardk> as for not needing the old company any more. it could be some sort of IORef based structure allowing you to mutate it, otherwise you'd have to build up a new company out of parts of the old anyways
11:10:46 <Philippa> right. So you don't compute arity, you just check if the type constructor's (->) or not
11:10:52 <cedricshock> About the above: Generics look pretty close, but I don't want to raverse the whole company every time I change a single employee because in the real example I'm going to have 200,000+ "employees" and am going to replace all of them every time, but, of necescity, one at a time and in no particular order.
11:11:34 <edwardk> cedric: well, your traversal/replacement should just share structure with the old company wherever possible.
11:12:42 <Philippa> OK, I'm gonna go make sure people in this house actually eat - back in a bit
11:12:43 <norpan> so the type constructor (->) correspond to the data constructor " " :)
11:12:46 <edwardk> so deleting an employee has to remove him from the chain of command, remove the links from his manager down if there is one, remove links up from his employees, etc. but really its more like you build a new company where that person 'never existed' =) so walk the old company and while the view is consistent with them not existing, you don't change anything
11:12:48 <cedricshock> edwardk: If I don't need the old company I can do it in constant time monadically. I don't want to get into that mess though.
11:13:08 <norpan> or $ if you will
11:13:13 <Philippa> norpan: cute, though sadly not quite accurate. Oh, and monads're like overloading ; in C++ :-)
11:13:27 <edwardk> cedric: well, the alternatives are messy monad or rebuild the company
11:13:40 <edwardk> if you build the data structure right you can minimize the pain of removal
11:13:52 <edwardk> since you tend not to have lots of cyclic data structures in typical haskell usage patterns
11:14:06 <cedricshock> edwardk: But I still want to do it in constant time. 
11:14:15 <cedricshock> edwardk: It's not cyclic.
11:14:23 <tony2> cedricshock, does the number of 'employees' change and what about their positions?
11:14:52 <edwardk> cedric, how do you remove a manager then if you are viewing this as an org chart? or is there no hierarchy of links?
11:15:22 <edwardk> cedric: if its just an array then you can use something like a STArray and monad plumbing
11:15:31 <cedricshock> tony2: Ok. Here's the real problem, since it's acyclic. Its a tree of a computer filesystem with each directory and file having a list of events. I'm going to add an event to every one of them, but in no particular order.
11:16:15 <cedricshock> edwardk: The problem would be replacing the manager "John" with a new (previously non-exsisting) hireie "Sally".
11:16:52 <edwardk> cedric actually managers are easy to replace its the employees that are a pain in the ass because you have to thread up the structure =)
11:17:03 <sjanssen> cedricshock: add an extra layer of indirection?
11:17:07 <tony2> cedricshock, you could have IORefs in the structure to change names?
11:17:28 <cedricshock> sjanssen: I've thought of that (the extra layer of indirection).
11:17:30 <edwardk> personally, i tend to abuse STM Tvars like IOrefs and just store the likes in tvars
11:17:36 <edwardk> er the links
11:17:36 <tony2> cedricshock, or keys and a map.
11:18:04 <edwardk> where the link in my case is usually the whole linked list or whatever, so i can just reassign the list to the tvar in one go
11:18:07 <sjanssen> cedricshock: use Position when you want to refer to an employee, and then have a map from Position to Name
11:19:46 <cedricshock> Hmm, and now I have to manage a namespace of identifiers to make the datastructure small...
11:21:09 <cedricshock> I'll look at this STArray, any other monadic lookup table structures I should peek at?
11:21:41 <edwardk> heh, well, you could help me debug http://slipwave.info/jslib/hs/Test/THash.hs =)
11:21:42 <cedricshock> And don't I lose type safety by adding the layer of indirection (type system can't guarantee the key exists)?
11:22:03 <sjanssen> cedricshock: well, you do lose type safety
11:23:19 <cedricshock> I really want a monadic indirection construct that works at the comiler level. Is that what IORefs are?
11:23:40 <edwardk> cedric: or you can ioref or tvar them and have them be a type that can only contain an actual link.
11:24:18 <edwardk> so say, every employer has a manager then its safe to put a link to the manager for the employee in a (TVar|ORef) and just update it atomically when you fire the manager
11:24:26 <edwardk> to point to the new boss
11:24:36 <sjanssen> cedricshock: IORef is an indirection construct in the IO monad
11:24:40 <cedricshock> edwardk: That sounds much more like it. Then I can change where the IORef / tvar points to, right?
11:24:53 <edwardk> the employee object doesn't change, but the IORef or TVar does
11:25:00 <cedricshock> Perfect!
11:25:26 <edwardk> cedric: if you do it with TVars then it even scales up to threaded use
11:25:38 <sjanssen> cedricshock: you may want to consider doing this in the ST monad -- slightly more pure than the IO monad
11:25:47 <cedricshock> Where are these TVars documented, so I can stop bugging you?
11:25:51 <edwardk> its not necessarily the 'right' way to do things from a haskellers perspective though
11:26:27 <edwardk> look up something on STRefs
11:26:30 <unmanarc> hello
11:26:33 <edwardk> those are the ST equivalent
11:26:41 <edwardk> so you have 3 ways now =)
11:26:58 <sjanssen> we need a class that abstracts *Var data types
11:26:58 <edwardk> TVars, IORefs and STRefs
11:27:02 <edwardk> yeah
11:27:05 <edwardk> i agree
11:27:10 <unmanarc> how, can i wrote that:
11:27:10 <cedricshock> edwardk: It's the right way to do it from the 200000 * 200000 is 40000000000 instead of just 200000 stepos point of view. It's also correct from the point of view of linear types.
11:27:14 <unmanarc> data Exp                = [ExpCombinaciones] deriving (Show)
11:27:15 <unmanarc> data ExpCombinaciones   = ExpMaquinaDeTuring
11:27:15 <unmanarc>                         | ExpEjecutar
11:27:15 <unmanarc>                         | ExpEntrada deriving (Show)
11:27:23 <edwardk> i was tripping over the fact that i wanted to parameterize my hash table over what monad it was built in so 
11:27:38 <edwardk> i would have MHash k v m or something
11:27:48 <edwardk> where m could be STM IO or ST
11:27:49 <sjanssen> something like: class (Monad m) => Var v m | v -> m where ...
11:28:08 <edwardk> that way i could use the appropriate Var implementation
11:28:20 <edwardk> hrmm
11:28:26 <edwardk> nothing really stops it, no?
11:28:54 <sjanssen> well, some people might not like the MPTC or the fundep, because they aren't Haskell '98
11:29:16 <edwardk> well, i am using it to generalize a STM based interface anyways =)
11:30:07 <sjanssen> edwardk: I believe there is an implementation of STM in Haskell '98 + concurrent Haskell
11:30:29 <sjanssen> so STM is barely an extension
11:30:39 <edwardk> hrm
11:30:45 <edwardk> going to play with that
11:31:00 <cedricshock> Oh I forgot one thing: I want to marshal the whole thing. That could be a problem with IO monads at least. (Yeah I losetype safety from the marshalling but I'm not worried about it.)
11:31:57 <sjanssen> cedricshock: marshaling isn't a big problem.  Just put your marshalling function in the IO monad too
11:37:24 <lispy> is haskell.org's geshi highlight file for the wiki publicly available?
11:40:15 <palomer> woot!
11:40:17 <palomer> @palomer
11:40:17 <lambdabot> Learning vim is pointless
11:41:23 <NotInventedHere> heresy!
11:44:02 <ndm> sjanssen: you have no concurrency in Hugs, only Yhc and GHC
11:44:04 <Cale> @palomer
11:44:04 <lambdabot> Brump!
11:44:31 <sjanssen> ndm: true, true
11:44:38 <Cale> I like how palomer can just converse by telling the bot to imitate him
11:45:50 <edwardk> haha
11:46:10 <Philippa> I'm kind of glad the bot never gained a module to imitate me
11:46:24 <Philippa> I mean, it'd be condemned to spend all its time explaining polyamory
11:46:32 <edwardk> heh
11:47:34 <ndm> Philippa: there is a wikipedia article on it, why do you need to explain it?
11:48:18 <Philippa> because I always get asked directly. Plus I've not got round to reading the wikipedia article to check I'm happy with its explanation being used to describe how I do things or what is/isn't poly
11:48:51 <Philippa> and I'd /still/ get asked if Damien's okay with it
11:48:57 <largos> who maintains the haskell wiki?
11:49:11 <Cale> largos: everyone :)
11:49:12 <ndm> you should add that information to the wikipedia article then :)
11:49:45 <largos> Cale: well, yeah <g>
11:50:08 <largos> Cale: I'm looking for the person who does upgrades / tweaks the extensions, etc..
11:50:15 <Cale> ah
11:50:23 <Philippa> I don't think they'd be happy with me writing "and yes, my boyfriend is happy with it" there :-)
11:51:16 <largos> Cale: I threw together the syntax highligthing extension for mediawiki, but I don't have the haskell geshi highlighting file :)
11:53:44 <edwardk> so what haskell implementations out there don't support multiparameter type classes?
11:54:14 <Philippa> the hypothetical H98 implementation in my head. I don't know that YHC supports them?
11:54:32 <edwardk> kk
11:54:35 <ndm> Yhc doesn't
11:54:39 <ndm> nhc98 doesn't
11:54:54 <ndm> Yhc wants to add them though...
11:54:56 <edwardk> then ghc it is for me, as i descend down the path towards pugs =)
12:08:10 <pierre-> hello!
12:12:38 <ndm> pierre-: hello!
12:22:39 <cedricshock> Anyone know where I can find an example of recursivly traversing directories in Haskell? The IO monads are throwing me off.
12:23:47 <SamB> hmp3
12:24:06 <NotInventedHere> cedricshock: look at missingh
12:24:51 <cedricshock> Thanks
12:25:52 <NotInventedHere> cedricshock: the function is "recurseDir"
12:27:00 <cedricshock> Excelent. Now I probably won't even write it.
12:27:43 <edwardk> sjannsen, got a basic var type to work, had to use fundeps and a multiparameter type class, but its clean enough to do IORef STRef and TVars
12:28:13 <edwardk> gonna see if i can use it to generalize my hash over io, st and stm
12:46:17 <edwardk> erf.
12:46:19 <edwardk> problemm =)
12:46:28 <cedricshock> NotInventedHere: Any idea why the linker would fail with a tiny program using missingh?
12:47:21 <NotInventedHere> without any more detail, no, not really
12:47:52 <NotInventedHere> what command are you using to compile?
12:47:55 <cedricshock> ghc
12:48:12 <cedricshock> actually: ghc missingh-dir.hs
12:48:31 <cedricshock> Which is this little program (sorry for the pasting):
12:48:34 <cedricshock> import MissingH.Path
12:48:34 <cedricshock> import MissingH.IO.HVFS
12:48:34 <cedricshock> import Directory
12:48:34 <cedricshock> main = do d <- getCurrentDirectory
12:48:34 <cedricshock>           l <- recurseDir SystemFS d
12:48:34 <cedricshock>           print l
12:48:50 <NotInventedHere> try using --make switch?
12:49:27 <cedricshock> Wow. That's magic.
12:49:33 <NotInventedHere> did it work?
12:49:35 <cedricshock> Yep.
12:49:37 <NotInventedHere> cool
12:49:40 <cedricshock> Why's that?
12:50:13 <NotInventedHere> I think --make tells ghc to include any necessary packages (i.e. missingh) which are registered.
12:50:41 <cedricshock> Thanks.
12:50:48 <NotInventedHere> otherwise, you could also write ghc -package missingh missingh-dir.hs
12:51:13 * NotInventedHere is going home
12:51:19 <cedricshock> Ah, all my other "import"s I've been doing must have been from base to not see this before.
12:51:26 <cedricshock> Thanks a bundle.
12:51:30 <NotInventedHere> no prob
13:34:53 <unmanarc> how can i repair that: http://www.synacksecurity.com:7299/Parser.y
13:34:54 <unmanarc> ?
13:36:48 <karma`> Hello! How I can get infinite list of zeros? iterate (\a -> a) [0] looks bad :)
13:36:49 <ndm> unmanarc: whats broken with it?
13:36:59 <sjanssen> > repeat 0
13:37:00 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:37:31 <unmanarc> ndm: well, im trying to create a list with
13:37:37 <unmanarc> diferent data types
13:37:48 <norpan> > fix (0:)
13:37:49 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:37:52 <ndm> unmanarc: you can't
13:37:57 <unmanarc> ExpMaquinaDeTuring, ExpEjecutar and... 
13:37:58 <unmanarc> etc
13:38:10 <unmanarc> ndm: some possibility?
13:38:16 <ndm> you can have a type data AllTypes = Type1 Exp.. | Type2 Exp2 etc
13:38:24 <ndm> and then make a list of AllTypes
13:38:34 <ndm> or you can have a tuple, if the list is a fixed size
13:38:46 <unmanarc> varsize. 
13:39:03 <unmanarc> ok, alltypes. i'll try
13:39:31 <unmanarc> data Exp                = [ExpPosibilidades] deriving (Show)
13:39:32 <unmanarc> data ExpPosibilidades   = ExpMaquinaDeTuring | ExpEjecutar | ExpEntrada deriving (Show)
13:39:32 <unmanarc> ?
13:39:47 <ndm> unmanarc: not quite, but thats the right idea
13:40:07 <ndm> you'd need ExpPosib = ExpMaquine' ExpMaquina | ExpEject' ExpEject
13:40:13 <ndm> to wrap each of the types you put in
13:40:46 <unmanarc> hmmm
13:40:51 <unmanarc> with ' ?
13:41:20 <ndm> with anything
13:41:40 <unmanarc> hmm
13:41:41 <ndm> actually ExpMaq ExpMaq is ok
13:41:53 <ndm> without the '
13:42:01 <ndm> because you don't use ExpMaq as a constructor already
13:44:45 <unmanarc> data Exp                = [ExpPosibilidades] deriving (Show)
13:44:45 <unmanarc> data ExpPosibilidades   = ExpMaquinaDeTuring ExpMaquinaDeTuring | ExpEjecutar ExpEjecutar  | ExpEntrada ExpEntrada  deriving (Show)
13:44:54 <unmanarc> ./Parser.hs:674:26: parse error in data/newtype declaration
13:44:54 <unmanarc> Failed, modules loaded: Lexer.
13:45:03 <unmanarc> error is in data Exp
13:45:03 <unmanarc> ?
13:45:53 <ndm> type Exp = [ExpPos...
13:46:05 <ndm> or data Exp = Exp [ExpPos...
13:46:05 <unmanarc> hmm
13:46:10 <unmanarc> trying.
13:46:11 <unmanarc> :)
13:46:13 <lispy> @hoogle isPrefix
13:46:14 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
13:46:15 <ndm> its only a data if it has a constructor at the front
13:46:27 <ndm> if its just an alias its a type
13:46:43 <unmanarc> :) work
13:47:12 <lispy> @index isPrefixOf
13:47:12 <lambdabot> Data.List
13:49:57 <lispy> so i guess with ghc 6.5 and forward that List is gone and you have to use Data.List?
13:50:50 <ndm> lispy: you can probably use package haskell98
13:51:28 <ndm> Hoogle is going to be updated soon to answer Data.List, not List anymore
13:51:56 <ndm> Haskell 98 was committed to being support for a long period of time with appropriate compiler flags
13:56:11 <Lemmih> Hop.
14:03:01 <palomer> how do you represent a character with hex code 0xef in haskell?
14:03:34 <norpan> toEnum 0xef
14:03:40 <norpan> or chr
14:03:49 <norpan> or '\xef'
14:08:56 <palomer> righto
14:08:57 <palomer> thx
14:26:17 <erider> is there a good tutorial for newbies to haskell on line? 
14:26:42 <erider> or one that somewhere here would recommend 
14:27:56 <Speck> http://haskell.org/haskellwiki/Learning
14:27:57 <lambdabot> Title: "Learning - HaskellWiki"
14:27:59 <Speck> lots of links there
14:28:08 <norpan> it depends on your background
14:29:05 <erider> ok thanks 
14:58:20 <lisppaste2> cedricshock pasted "Why's the type wrong?" at http://paste.lisp.org/display/22546
14:59:28 <cedricshock> In the above the type of the empty list is expected to be IO. I'm probably doing something wrong or expecting too much.
15:01:23 <norpan> cedricshock: backup is not of type IO 
15:01:32 <norpan> so you can't call it using <- notation
15:01:43 <norpan> replace a <- with let a =
15:01:48 <cedricshock> What operation do I need instead?
15:02:05 <norpan> the right hand side of the arrow need to be of type IO
15:02:33 <cedricshock> Ooh, neat. It worked.
15:02:39 <norpan> of course
15:03:02 <cedricshock> Thanks!
15:07:24 <wolverian> hm, too bad the gstreamer bindings didn't make it to SoC 
15:08:33 <moonfish> Is anybody here familiar with QuickCheck?
15:09:12 <erider> why doing this print the some of the two arguments: main = do args <- read
15:09:12 <erider>           show ( args !! 0 +  args !! 1)
15:09:42 <erider> sorry why doesn't it 
15:11:37 <ndm> erider: show does nothing, it converts something to a string, you want putStrLn or print
15:11:42 <ndm> that output something to the console
15:12:22 <palomer> edwardk: you around?
15:17:21 <edwardk> heh. i just finished reinventinng Control.Concurrent.STM.TArray almost to the letter. sad.
15:17:33 <edwardk> i should look around more =)
15:21:26 <lisppaste2> erider pasted "help" at http://paste.lisp.org/display/22548
15:23:26 <edwardk> pal yea
15:25:35 <palomer> was wondering if there were any alternatives to alex
15:25:43 <ndm> erider: read -> getArgs
15:25:52 <ndm> erider: you've used the wrong function
15:26:08 <ndm> palomer: Parsec has a lex mode, I'm also in the process of writing an alternative, but not nearly finished yet
15:26:10 <erider>  args <- getArgs
15:26:10 <erider>           print ( args !! 0 +  args !! 1)
15:26:21 <edwardk> palomer: parsec ;)
15:26:28 * palomer is staying away from parsec
15:26:46 <palomer> ndm: work faster!
15:26:47 <edwardk> dunno any
15:27:02 <ndm> palomer: http://www-users.cs.york.ac.uk/~ndm/projects/helix.php
15:27:03 <lambdabot> Title: "Neil Mitchell - Helix"
15:27:10 <edwardk> frown and happy can do cheesy lexers, but they won't give you that traditional flex format
15:28:10 <ndm> palomer: why don't you want use to Alex?
15:28:10 <palomer> oh? frown has regular expressions?
15:28:24 <palomer> because I don't need the power of alex
15:28:25 <palomer> err
15:28:28 <palomer> yeah
15:28:35 <edwardk> no, just meant you can write it ebnfishly =) hows that for making up a word? =)
15:28:39 <ndm> what do you mean by the "power of alex"?
15:29:54 <ndm> palomer: isn't alex reasonably simple? certainly to use the simple features
15:30:17 <palomer> my tokens are ridiculously simple
15:30:20 <palomer> 1 or 2 character strings
15:30:22 <palomer> and numbers
15:30:49 <ndm> palomer: have you seen the haskell lex function?
15:31:02 <palomer> @hoogle lex
15:31:02 <lambdabot> Prelude.lex :: ReadS String
15:31:02 <lambdabot> Text.Read.Lex.lex :: ReadP Lexeme
15:31:02 <lambdabot> Text.Read.Lex :: module
15:31:11 <palomer> @hoogle ReadS
15:31:11 <lambdabot> Prelude.ReadS :: type ReadS a
15:31:11 <lambdabot> Prelude.reads :: Read a => ReadS a
15:31:11 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
15:31:16 <ndm> > lex "12 neil"
15:31:17 <lambdabot>  [("12"," neil")]
15:31:22 <ndm> lex " neil ("
15:31:28 <ndm> > lex " neil ("
15:31:29 <lambdabot>  [("neil"," (")]
15:31:34 <ndm> very basic haskell style lexing
15:32:15 <palomer> hrmph
15:32:18 <ndm> I used it in the first version of Hoogle
15:32:26 * palomer will have to ponder all of this
15:33:01 <ndm> you can always write a lexer by hand - its not hard at all
15:33:36 <palomer> that's my other alternative
15:34:01 <edwardk> the only thing i need to implement to make an MArray is newArray newArray_ unsafeRead and unsafeWrite right?
15:35:09 * palomer goes and ponders
15:37:09 <edwardk> cmarcelo == hsjudy guy right? =)
15:37:17 <cmarcelo> yep
15:37:32 <edwardk> how is thhat going? -- not to grill yoou upon first entry to the channel ;)
15:38:33 <edwardk> (moving my javascript interpreter etc to haskell, was thinking about trying to use it if the performance is there)
15:41:33 <cmarcelo> last 2 weeks were consumed by university end of semester. but now i'm back to hsjudy work.. first I did some low-level FFI stuff, now I'm trying some high level interfaces (working at Maps right now) and trying to test them (in Pugs and RBR).. but not much results to show at the moment. (still fighting with some finalizer issues) =P
15:41:46 <edwardk> k
15:42:04 <cmarcelo> edwardk: well, move it to haskell, then optimize =)
15:42:23 <edwardk> cmarcelo: already doing that part =)
15:42:46 <edwardk> currently building up a bunch of my internal data structures
15:43:40 <edwardk> probably won't be abe to use the hsjudy stuff, since i want to use STM, but its at least work poking at =)
15:44:13 <cmarcelo> edwardk: is it opensource?
15:44:51 <edwardk> will be when it works. =) the web page for the javascript version is http://slipwave.info/
15:45:40 <edwardk> basically liked implementing it so much in javascript i figured it wouldn't suck to have a fast ecma4 implementation in haskell. and i wasn't havinng fun hacking together ecma4 in ecma3
15:46:35 <edwardk> er. rather i was first doig an ecma3 interpreter in ecma4, but i found the type system for the implementations like actionscript to be cripplingly bad
15:49:09 <cmarcelo> edwardk: firefox today implements ecma3? and what people call JS2 is ecma4? or did i get it all wrong?
15:49:42 <edwardk> cmarcelo: more or less right, firefox is ecma3, js2 was thrown out, ecma4 is close to it in spirit though
15:50:13 <edwardk> but they are adding a whole structural type system on top, which might make it not suck =)
15:51:40 <tony2> cmarcelo, edwardk, sorry to interupt, hsjudy as in judy arrays?
15:51:49 <edwardk> tony: yeah
15:52:17 <tony2> cmarcelo, is that a SoC project?
15:52:24 <cmarcelo> yes
15:52:31 <tony2> ah very good, 
15:53:00 <tony2> that sounds interesting.
15:54:34 <cmarcelo> right now I'm working on Map-like interfaces for Judy datatypes (which looks like will be more succesful).
15:55:09 <tony2> Thats great, I very much approve of these performance related projects.
15:55:48 <tony2> Map is currently 2-3 finger trees, or AVL? 
15:56:09 <sjanssen> tony2: size balanced trees
15:56:55 <tony2> ok, right, I recall "it's a balancing act" right.
15:57:28 <sjanssen> there was talk about moving to AVL, I'm not sure if that's actually happening or not
15:57:50 <tony2> sjanssen, for performance?
15:57:54 <sjanssen> tony2: yes
15:58:41 <edwardk> i am always so amused when i look at haskell data structures, it seems like people here spend sooo much time on the type system that in the end they just can't be buggered to optimize the algorithms ;)
15:59:29 <tony2> edwardk, quite true, looking back I can't believe we never had fps/bytestrings until recently.
15:59:35 <edwardk> *nods*
16:00:24 <Cale> Personally, I hope for a future in which the compiler determines that something like FPS is appropriate :)
16:00:32 <edwardk> heh
16:00:37 <tony2> it is a small community though, and action is now being taken.
16:00:38 <Cale> but it's nice to get some speed
16:00:45 <tony2> Cale,  yes.
16:00:53 <edwardk> i want to be able to use the language before my teeth fall out and my grandkids are runninng around =)
16:00:54 <Cale> Did you see dons' slides?
16:00:58 <Cale> We beat C :)
16:01:10 <tony2> I did see those! 
16:01:20 <sjanssen> @elite fusion rocks!
16:01:20 <lambdabot> FuSIOn R0Cx5!
16:01:26 <sylvan> Cale, do you have a link?
16:02:13 <Cale> http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz
16:02:16 <Cale> I think that's it
16:02:54 <pejo> vis
16:02:58 <pejo> Ups. Wrong window.
16:06:55 <sylvan> thanks
16:07:20 <Philippa> the type system's been more critical than speed until recently - there've been significant things that couldn't be comfortably expressed
16:07:56 <Philippa> but it's cool that stuff's happening now
16:11:04 <ndm> tony2: we've had packed string for absolutely ages - it was just never that fast
16:11:11 <edwardk> heh, the c++ community calls those fusion rules 'expression templates' they've caught on there too
16:11:24 <tony2> Philippa, sure, and the type system will pay off speed wise in the long run I feel. In a many cores world STM is a boon.
16:12:24 <edwardk> STM is my reason for jumping to haskell actually
16:12:49 <tony2> edwardk, jumping from what?
16:14:09 <edwardk> lots of places actually, but embarassingly enough, javascript =)
16:14:57 <edwardk> though for performance code mostly c++
16:15:25 <edwardk> i've been pretty far away from the functional community for a long time
16:15:40 <ndm> edwardk: you don't need to be embarrassed of a language with functions as objects, there was even an invited javascript talk at ICFP 05
16:15:55 <edwardk> ndm: actually i'm rather fond of javascript
16:16:03 <ndm> me too :)
16:16:08 <edwardk> it needs a terser syntax, but the new type system is cool
16:16:27 <ndm> i haven't seen the new type system that much, only the one tacked into JScript .NET - is that similar in any way?
16:16:32 <ndm> or even the same, perhaps?
16:17:09 <edwardk> well, they are keeping that ratty thing, but they are adding one for structural typing of anonymous hashes, arrays, etc.
16:17:25 <ndm> and i like the syntax - a layout rule would be horrible for places like onclick="code here"
16:17:30 <edwardk> and a type and data keyword that make one think a lot about haskell ;)
16:17:57 <edwardk> ndm: heh, well, a shorter lambda and return would be nice for that same reason though
16:18:21 <ndm> edwardk: lambda, yes, but return is already short enough
16:18:29 <ndm> given that its implicit in everything
16:18:37 <edwardk> ndm: after cps transforminng javascript, its painfully verbose =)
16:18:54 <edwardk> <-- weirdo
16:20:15 <edwardk> i find i have to use a bunch of crap to flatten the lexical scope chains to maintain asymptotically optimal performance, etc because it lacks tail call recursion and it has a very simple scoping syste that you can't work around or precompile away
16:20:19 <edwardk> because it is so dynamic
16:20:27 <edwardk> but yes, i definitely like the language
16:21:45 <ndm> surely if you want to do those kind of computations, javascript is the wrong language?
16:22:03 <ndm> as soon as you cps transform a language, its time to upgrade languages ;)
16:22:37 <edwardk> ndm: needed the cps transform to work around browser limitations on instruction counts and stack sizes.
16:22:42 <Philippa> If you're stuck doing client-side web stuff, it's all you've got
16:22:50 <Philippa> it could certainly be a worse language
16:23:05 <edwardk> ndm: and yeah, the whole reason i use javascsript is because it runs everywhere
16:23:34 <ndm> you could compile javascript to haskell :)
16:23:41 <ndm> there was a plan to do that via Yhc at one point
16:23:45 <edwardk> ndm: doing that =)
16:23:51 <ndm> but don't think it ever got too far
16:23:54 <edwardk> ndm: thats part of what this project i'm working on is for
16:24:06 <ndm> edwardk: with what compiler front end?
16:24:32 <edwardk> i want a nice imperative language with a good implicit type system and stm under the hood so it scales nicely to multiple cores. decided i'd have to write one
16:24:33 <erider> probably swig 
16:25:32 <ndm> woops, i meant hte other way round - haskell to javascript
16:25:36 <ndm> that was the yhc plan
16:25:37 <edwardk> ndm: i have a parsec based lexer, a hand written rec descent and operator precedence parser and do the work myself
16:25:39 <edwardk> ndm: ahh
16:25:40 <edwardk> heh
16:25:43 <conal> philippa -- what about java instead of javascript for client-side?
16:25:57 <ndm> conal: arrrggghhhhh!!!!! - java is horrid
16:25:58 <edwardk> ndm: yeah, fraid i'm not enough of a type guru to do the haskell compiler yet =)
16:26:09 <conal> ndm: compared with javascript??
16:26:16 <ndm> and is also not installed on lots of windows machines, and those it is installed on it makes it drag terribly
16:26:17 <edwardk> conal: its actually surprisingly useless to use java for client side programming
16:26:27 <conal> oh?
16:26:34 <edwardk> the runtime is sluggish to initialize, people feel like they are being taken out of their usua environment, etc.
16:26:36 <ndm> conal: focusing entirely on end user speed, java sucks massively, and tends not to work
16:26:45 <ndm> javascript always works, and always pretty fast
16:27:00 <edwardk> and you issues with not being able to use modern language features, etc.
16:27:16 <edwardk> er you have
16:27:28 <tony2> I embeded spidermonkey into a project once and was quite impressed with speed.
16:27:34 <edwardk> javascript is uiet, unobtrusive and can pretty much gracefully degrade
16:27:52 <conal> ndm: you don't mean faster than java, do you?
16:28:01 <edwardk> in my case, i use cocoon on the server and then migrate the javascript to run in cocoon as a flowscript so i can still use javascript to service people without javascript at all!
16:28:09 <ndm> conal: yes, i do
16:28:21 <edwardk> i just use continuations to restore server state
16:28:24 <ndm> for almost every purpose, mainly because the startup time for java is close to minutes
16:28:37 <edwardk> so one javascript library and i can run it client side or server side to build big apps
16:29:10 <edwardk> conal: it isn't a matter of actual speed, its perceived speed. java tends to devour large chunks of memory and stall for 20+ seconds on initialization
16:29:14 <tony2> edwardk, what is 'cocoon'?
16:29:19 <edwardk> in the meantime the persons browser stalls
16:29:33 <conal> yeah: the initialization time is a bummer
16:29:57 <tony2> edwardk, never mind, sorry, I've done a little google.
16:30:15 <edwardk> apache cocoon is a java servlet framework designed for transforming xml streams. it happens to have a neat trick called flowscript that lets it use a continuation-extended javascsript engine to run code on the server that can be written in a linear style
16:30:16 <ndm> and often even after they navigate away Sun's java thingy has decided it should place an icon in the system tray, shout loudly about security updates (since its not updated with the browser and has security issues), and advertise itself by being "cool and hip"
16:30:47 <edwardk> and actually you can write those flowscripts in java, coz it has a continuation based class loader as well
16:30:47 <lispy> how do i make String an instance of a type class?
16:30:57 <conal> ndm: yep, bummers.
16:31:01 <ndm> lispy: not in haskell 98
16:31:04 <lispy> instance Foo [Char] where...
16:31:05 <lispy> oh
16:31:10 <ndm> lispy: -fglasgow-exts
16:31:13 <lispy> thanks
16:32:22 <conal> about performance, i found java to be okay (except for startup!) as a compiler back-end for pajama (http://conal.net/Pajama), which is a Pan rewrite.
16:32:32 <lispy> ndm: you wouldn't happen to know how that translates into .cabal would  you?
16:32:37 <tony2> On a different note, has anyone been following the haskell prime situation regarding records? is anything going to change or happen on that front?
16:32:44 <edwardk> i don't complain about java in a server setting
16:33:00 <edwardk> i just dont think it makes a good choice for a web based app
16:33:05 <ndm> lispy: not a clue i'm afraid
16:33:11 <ndm> tony2: probably nothing
16:33:18 <ndm> since no one has implemented another record scheme
16:33:29 <ndm> (although I do like Dann Lejin's records, personally)
16:33:31 <edwardk> you build a robust app in java and it'll weigh most of a meg, you build it in javascript and you can pack it in ways to get it down to 80k for the same functionality usually =/
16:34:17 <tony2> ndm, fair enough I suppose, but unfortunate
16:34:51 <conal> edwardk: mine are pretty tight: http://conal.net/Pajama/examples (.jar files)
16:34:53 <lambdabot> Title: "Index of /Pajama/examples"
16:35:58 <edwardk> conal: i think 'desktop application' usually when i talk application, but thats bias fro the kind of apps i have been building
16:38:18 <edwardk> i was acctually doing some lightweight stuff in my earlier web app stuff. used it for a while to replace the javascript implementation in crappy browsers
16:38:57 <edwardk> would run rhino under java and a little simple box based manual dom/css implementation =)
16:41:14 <conal> doesn't this situation sound like an opportunity for a well-designed language & VM with good engineering?
16:41:57 <edwardk> sure, but i'm not going to be able to put it on enough desktops, hence i stretch javascript out of shape ;)
16:43:17 <edwardk> btw- those pajama things are pretty neat
16:44:10 <conal> thanks.  i want to make the interaction interface much more obvious.
16:44:18 <edwardk> yeah
16:44:29 <edwardk> was going to say, its hard to find out that you can change mouse mode, etc.
16:45:36 <conal> i'd love suggestions.  how to make obvious w/o cluttering
16:46:29 <conal> and, of course, right-clicking is pretty mac-unfriendly
16:46:37 <edwardk> *nods*
16:48:46 <conal> am i right in assuming that compute-intensive interactive apps like the Pajama ones would run much more slowly in javascript?  they do per-pixel computations.
16:49:02 <edwardk> conal: can't do per pixel stuff in javascript
16:49:11 <edwardk> not an appropriate problem for the language
16:49:24 <edwardk> there isn't a good image composition trick that works cross browser
16:49:51 <edwardk> then again, actionscript 3 doesn't suck at it and thats technically a javascript flavor
16:49:59 <edwardk> but thats in flash
16:51:11 <conal> per-pixel is not just slow, but impossible in javascript?
16:51:48 <conal> i guess it's a pretty specialized requirement
16:51:52 <edwardk> conal: well, ecma3 == current javascript lacks a traditional array type, so everything is hanging out in hashes
16:52:07 <edwardk> so you do the math ;)
16:52:20 <edwardk> you can do hacks with divs and setting css styles per pixel
16:52:23 <edwardk> but they are just that
16:52:24 <edwardk> hacks
16:52:32 <edwardk> and they are terribly bad performers =)
16:52:43 <conal> thanks.  i was curious.
16:52:53 <edwardk> the smileys on http://slipwave.info/ are generated that way
16:53:11 <edwardk> but heh
16:53:17 <edwardk> my browser crashed from pajama
16:53:54 <conal> oops !  happens to me, too, when i navigate away while there's an applet still init'ing.
16:54:16 <edwardk> yeah, there is a trick for playig with the start and stop events to manage that
16:54:22 <edwardk> but i don't recall it off hand
16:54:27 <conal> oh!
16:54:38 <edwardk> you can probably find it online
16:54:44 <Cale> hey cool, someone's developing an X server which supports multiple simultaneous pointers
16:54:57 <edwardk> about time =)
16:54:57 <conal> edwardk: thanks.
16:55:03 <Cale> edwardk: yeah
16:55:17 <Cale> edwardk: I've been quite interested in multi-pointer UIs for a while
16:55:30 <edwardk> i have 2 hands, put a mouse in it =)
16:55:37 <edwardk> er in the other
16:55:47 <Cale> edwardk: right, tying your shoes with one hand is tricky :)
16:56:03 <lisppaste2> lispy pasted "help with type issues" at http://paste.lisp.org/display/22553
16:56:34 <edwardk> well, that and it would work well for vnc/remote desktop kind of interfaces
16:56:35 <conal> two-handed interaction is fun: ftp://ftp.research.microsoft.com/pub/tr/tr-98-56/animations.htm
16:56:49 <edwardk> if i can associate a keyboard with each mouse and let each keyboard have a different focus
16:57:26 <Cale> Toolglass/Magic Lenses looks like a really neat idea too
16:57:34 <lispy> i would appreciate some help with the type error i'm getting, it has me stumped
16:57:46 <Cale> (and one which has been around for ages with basically no attention)
16:58:00 <conal> cale: yes, very neat idea
16:58:02 <edwardk> mix and match that with a bit of desktop->desktop connectivity and drag files from machine to machine without disturbing the other user on the screen so much
16:58:51 <edwardk> i am sittig here cominng to the conclusion that haskell has the worst designed dynamic array interface ever
16:58:59 <edwardk> and thats including languages like coldfusion ;)
16:59:21 <edwardk> the syntax actively jumps in my way ;)
16:59:50 <Pitarou> Haha!
17:00:54 <Pitarou> w.r.t. arrays: A little syntactic sugar for the most common use cases might help.
17:01:00 <tony2> lispy, you need to add a type signature to the fromSQL function (it doesn't know which instance to use)
17:01:00 <edwardk> yeah
17:01:04 <sjanssen> edwardk: Bulat Ziganshin wrote some code that tries to provide nice syntax from arrays
17:01:10 <edwardk> i realize there is some 3rd party parser, etc.
17:01:15 <sjanssen> s/from/for
17:01:23 <edwardk> but i'm kinda leery of how well it plays with extensions, etc.
17:01:42 <lispy> tony2: that's the point tho...i don't know what types the table colums have
17:01:45 <sjanssen> edwardk: this is in pure Haskell -- it uses clever operators and type classes
17:01:53 <edwardk> s: and i'm trying to build a library and don't want to force evreyone to use it
17:01:54 <cedricshock> Looking for IO libraries: interface to some type of archive file (gzip, tar, etc). It'd also be neat to have something for building ISO file systems, writing optical disks (these last 2 are pretty easy just running external programs)
17:02:00 <edwardk> sjannsen: now we might be talking =)
17:02:22 <edwardk> that that a[|i|] stuff right?
17:02:25 <sjanssen> edwardk: http://www.haskell.org/haskellwiki/Library/ArrayRef
17:02:27 <lambdabot> Title: "Library/ArrayRef - HaskellWiki"
17:02:57 <edwardk> lol
17:02:58 <Pitarou> Does anybody here feel up to talking about the continuations monad?
17:03:01 <sjanssen> oh, it even looks like Bulat has "Monad-independent references" in there
17:03:08 <edwardk> i just reinvented its newRef writeRef readRef =)
17:03:23 <edwardk> though mine also does STM
17:03:34 <sjanssen> edwardk: y'know, when I mentioned we needed a type class I may have been remembering this code ;)
17:03:52 <lispy> i guess maybe i have to create different fetch value function for each type of column
17:03:59 <lispy> and then somehow linkup the types
17:04:27 <tony2> lispy, yes you can't have a varying return type
17:04:45 <tony2> you'd normally encapsulate in Either
17:04:59 <edwardk> sjanssen, not sure i want to drag in a dependency that goes and replaces the whole array system though
17:05:21 <sjanssen> edwardk: yeah, an ArrayRef-lite package would be nice
17:05:39 <sjanssen> you should be able to rip out the syntactic sugar pretty easily
17:05:50 <edwardk> currently i have a Data.Var type that i'm using like its Ref type
17:06:09 <tony2> lispy, hang on I'll take a proper look at your code.
17:06:10 <edwardk> and a Data.VArray that fundeps me an array type from a stateful monad type
17:06:22 <edwardk> (and VUArray for the unboxed kinds)
17:06:38 <edwardk> and i'm currently reimplementing my hash table over the VArray and with a Var to hold it
17:06:42 <sjanssen> this stuff needs to be in the base package
17:07:00 <lispy> tony2: thanks
17:07:07 <Pitarou> sjanssen: I'd go along with that.
17:07:51 <cmarcelo> are there in fps/ByteString any out-of-box direct conversion from Int -> ByteString, Integer -> ByteString?
17:08:00 <Pitarou> Any hot chicks in here -- 18 to 25 -- wanna' chat about Monads?  IM me now!
17:08:16 <Pitarou> ;-P
17:08:47 <madpickle> how about a kick in the monads? :P
17:09:00 <tony2> lispy, ok, I don't know HSQL but I see what your trying to do.
17:09:15 <Pitarou> But seriously...
17:09:28 <cedricshock> What do you want to say about continuations?
17:09:29 <lispy> tony2: i don't know HSQL either :)  I wanted to use HaskellDB but that requires static knowledge of your database
17:09:38 <Pitarou> I'm reading some notes about the Continuations Monad, and there's somethign that's got me baffled.
17:09:59 <tony2> with static knowledege of database it'd know which function to call.
17:10:18 <Pitarou> cedricshock: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lec-20051118.html
17:10:20 <lispy> tony2: yeah
17:10:21 <lambdabot> Title: "Advanced Functional Programming - Lecture Notes, Fri Nov 18"
17:10:32 <Pitarou> lambdabot: Thanks!
17:10:49 <lispy> @botsnack
17:10:50 <lambdabot> :)
17:11:09 <Pitarou> Have a look at the definition of bindC.  Couldn't it just be replaced with "m `bindC` k = m k" ?
17:11:29 <tony2> lispy, so you don't know the types of the columns?!?
17:11:43 <lispy> tony2: no, but the database does, so i just ask it
17:12:16 <lispy> tony2: the best i can offer is that i know the set of columns (and their types) that i'd be interested in looking at, but i can't be sure the database has them
17:13:33 <tony2> lispy, ok well if you know the type you'd be interested in looking at then you'd know the return type, which is what your after......
17:15:40 <lispy> tony2: maybe what i should do is write a getFieldValue for each possible return type, then at run time i lookup the column type and invoke the appropriate version of getFieldValue
17:15:55 <Pitarou> Continuations turn my head inside out whenever I look at them.  Continuations + Monads is just too much for me.
17:16:15 <tony2> lispy, yes that would work. 
17:16:23 <lispy> tony2: i don't see any reason to tightly couple this to the columns i currently care about...because it's going to change :)
17:17:27 <lispy> tony2: thanks for your help
17:17:43 <edwardk> pitarou: they hit all of us pretty hard when we first saw them
17:18:09 <tony2> lispy, you can still do it with a type class though, if you encode the type in a data structures parameter.
17:18:26 <tony2> same thing is done in Binary class for get function
17:18:31 <Pitarou> edwardk: Should I find that reassuring?
17:18:42 <tony2> when you only know the type that your going to get.
17:18:59 <Pitarou> Would somebody mind taking a look at those notes, and passing comment on them?
17:19:07 <edwardk> pitarou: what have you got?
17:19:17 <cedricshock> Pitarou: No, because it returns a monad
17:19:34 <Pitarou> edwardk: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lec-20051118.html
17:19:35 <lambdabot> Title: "Advanced Functional Programming - Lecture Notes, Fri Nov 18"
17:19:51 <Pitarou> cedricshock: Please explain a little more.
17:21:00 <Pitarou> Oh .. hang on.  I've just realised I was doing something really stupid.
17:21:29 <edwardk> i had it a little easier because i was doing them in javascript =) nno problem with the continuation type, its just a function i call when i have my answer =)
17:22:08 <Pitarou> I thought I had given both versions to ghci, and it was giving me the same type both times.  Now I realise that it was just me doing something wrong with ghci.  It gives me *different* types.
17:23:53 <Pitarou> I'll go back to my code, and do some more hard thinkin'.
17:24:39 <Pitarou-thinking> Thank you for your help, cedricshock.  Much appreciated.
17:25:06 <edwardk> sjannsen: might just grab that arrayref library and use it ayways. its hard to write an efficient and still generic data structure through the existing MArray interface
17:26:25 <Pitarou> Actually, I was right the first time.
17:26:30 <Pitarou> *sich*
17:26:33 <Pitarou> *sigh*
17:27:35 <lispy> tony2: dependent types?
17:28:36 <lispy> tony2: isn't the syntax something like: class SqlBind a => FromSql a b | a -> b where
17:29:43 <lispy> @wiki dependent types
17:29:44 <lambdabot> http://www.haskell.org/haskellwiki/dependent types
17:30:00 <bolrod> woah!
17:30:24 <bolrod>  @wiki <name>  =  http://www.haskell.org/haskellwiki/<name>   ?
17:30:34 <lispy> oh am i thinking of functional dependencies?
17:30:36 <bolrod> @wiki nonsense
17:30:37 <lambdabot> http://www.haskell.org/haskellwiki/nonsense
17:30:39 <bolrod> :p
17:30:53 <Pitarou> @wiki goldfish
17:30:53 <lambdabot> http://www.haskell.org/haskellwiki/goldfish
17:31:03 <bolrod> :]
17:31:09 <Pitarou> That's cheating!
17:31:11 <nothingmuch> @wiki ../foo
17:31:11 <lambdabot> http://www.haskell.org/haskellwiki/../foo
17:31:50 <Pitarou> :
17:32:02 <Pitarou> @wiki photos_of_cute_kittens
17:32:02 <lambdabot> http://www.haskell.org/haskellwiki/photos_of_cute_kittens
17:32:32 <bolrod> @wiki Special:Search?ns0=1&search=test&searchx=Search
17:32:32 <lambdabot> http://www.haskell.org/haskellwiki/Special:Search?ns0=1&search=test&searchx=Search
17:33:04 <Pitarou> Does that work?
17:33:29 <bolrod> apparently 
17:33:35 <lispy> @. wiki wiki
17:33:35 <lambdabot> http://www.haskell.org/haskellwiki/http://www.haskell.org/haskellwiki/
17:33:59 <bolrod> @wiki . http://google.com
17:34:00 <lambdabot> http://www.haskell.org/haskellwiki/. http://google.com
17:34:01 <lispy> @. wiki elite keal
17:34:01 <lambdabot> http://www.haskell.org/haskellwiki/k34L
17:34:10 <bolrod> no no
17:34:13 <lispy> @. wiki elite . keal
17:34:13 <lambdabot> http://www.haskell.org/haskellwiki/. xEAl
17:34:23 <bolrod> @. elite wiki keal
17:34:23 <lambdabot> H7tp://wwW.HA$ke11.or9/HA5ke1LWiKi/xEA|
17:34:29 <bolrod> 8)
17:34:43 <lispy> i wanted to see the output of keal in elite as the wikipage :)
17:34:47 <Pitarou> STOP IT!  :-(
17:35:05 <Pitarou> You're confusing me.
17:35:15 <bolrod> @. elite wiki . run keal
17:35:15 <lambdabot> |-|7TP://Ww\/\/.|-|azkeL|.Or9/|-|A5K31lWiKi/. ruN xEA1
17:35:24 <bolrod> ok.. sorry
17:35:34 <lispy> @linenoise
17:35:35 <lambdabot> Unknown command, try @list
17:35:48 <Pitarou> @perl
17:35:48 <lambdabot> Maybe you meant: keal part pl spell tell url vera
17:35:59 <bolrod> vera?
17:36:07 <Pitarou> @vera
17:36:13 <Pitarou> ?
17:36:13 <bolrod> @help vera
17:36:14 <lambdabot> I perform dictionary lookups via the following 13 commands:
17:36:14 <lambdabot>  @all-dicts .. Query all databases on dict.org
17:36:14 <lambdabot>  @devils ..... The Devil's Dictionary
17:36:14 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
17:36:14 <lambdabot>  @elements ... Elements database
17:36:16 <lambdabot> [9 @more lines]
17:36:26 <bolrod> omg.. the spam!
17:36:46 <Pitarou> @easton herod
17:36:48 <lambdabot> No match for "herod".
17:37:00 <Pitarou> @easton emissions
17:37:01 <lambdabot> No match for "emissions".
17:37:06 <Pitarou> It's not very good.
17:37:07 <lispy> where do i learn about functional dependencies?
17:37:21 <bolrod> @all-dicts herod
17:37:23 <lambdabot> *** "Herod" wn "WordNet (r) 2.0"
17:37:23 <lambdabot> Herod
17:37:23 <lambdabot>    n : king of Judea who (according to the New Testament) tried to
17:37:23 <lambdabot>      kill Jesus by ordering the death of all children under
17:37:23 <lambdabot>      age two in Bethlehem (73-4 BC) [syn: {Herod the Great}]
17:37:25 <lambdabot> [7 @more lines]
17:37:26 <bolrod> ;)
17:37:48 <bolrod> lispy: google for  pdf's ?
17:37:50 <Pitarou> lispy: If you look in the GHC documentation, in the chapter about type system extensions, there's a link to an excellent paper on the subject.
17:38:22 <bolrod> then the only question remains..
17:38:24 <bolrod> will he learn?
17:38:28 <bolrod> 8)
17:38:48 <Pitarou> lispy: The basic idea is something like this:
17:38:52 <lispy> bolrod: i have been googling..but i get all these .ps files and i'm on windows :(
17:39:01 <bolrod> :D
17:39:14 <bolrod> print them... or get a ps2pdf or something
17:39:15 <Pitarou> lispy: You need to install ghostscript.
17:39:48 <Pitarou> ghostscript is like a pdf viewer, but it does .ps files too.
17:40:23 * bolrod is glad to not have to battle windows
17:41:17 <lispy> ah, i found the Mark P. Jones paper
17:41:19 * lispy digs in
17:41:23 <lispy> in pdf!
17:41:38 <Pitarou> lispy:  Seriously.  You *need* to install ghostscript.
17:41:59 <Pitarou> There's a lot of stuff out there that you won't be able to get at without it.
17:42:30 <Pitarou> (Debian would help, too.  But let's take things one step at a time.)
17:42:50 <lispy> Pitarou: every computer i own, save for my ibook, runs debian :)
17:42:54 <lispy> Pitarou: but i'm at work :(
17:43:08 <Pitarou> Fair enough.  That sucks.
17:44:40 <Pitarou> That explains why I always see you whenever I come to this chatroom, lispyl.
17:46:22 <Pitarou> Anyway, I was going to explain the basic idea of functional dependencies:
17:46:39 <Pitarou> A class can be considered as a predicate on the types.
17:47:08 <Pitarou> Similarly, a class with multiple parameters can be considered a *relation* on the types.
17:47:36 <Pitarou> The trouble with relations is that they create ambiguity.  Luckily, relational database theory has solved that one for us.
17:48:43 <bolrod> @localtime Pitarou 
17:48:44 <lambdabot> Local time for Pitarou is Fri Jul 14 02:52:23
17:49:18 <Pitarou> By including those funny arrows, the typechecker automagically understands what constraints you are placing on type relations, checks that they are satisfied, and proceeds accordingly.
17:49:36 <Pitarou> @localtime lambdabot
17:49:43 <Pitarou> @localtime bolrod
17:49:44 <lambdabot> Local time for bolrod is Fri Jul 14 02:49:22 2006
17:49:49 <lispy> Pitarou: hmm...yeah, i think i get that
17:50:01 <bolrod>  your clock is off ;p
17:50:23 <lispy> Pitarou: yeah, i irc from a debian server via emacs :)
17:50:34 <lispy> ERC Version 5.0 $Revision: 1.743 $
17:50:39 <Pitarou> bolrod: Yeah.  I forgot to tell my brand new second-hand PC about GMT.
17:50:44 <lispy> it's like multiplayer text editing
17:50:55 <bolrod> install apache
17:51:03 <bolrod> and ps2pdf.. and use that ?
17:51:33 <lispy> yeah, i could do that...i actually have all of that installed just didn't think about wget'ing them and converting
17:51:44 <bolrod> hrmm..
17:52:01 <bolrod> is it because you're so busy with work? 
17:52:17 <Pitarou> @localtime lispy
17:52:18 <lambdabot> Local time for lispy is Thu Jul 13 17:51:55 2006
17:52:39 <bolrod> hah.. Thursday... 
17:53:22 <bolrod> that's a long way across the world..
17:53:34 <lispy> wow, yeah
17:53:40 <lispy> you mean you're living friday already?
17:54:05 <Pitarou> Yeah, lispy.  Thursday is, like, so yesterday, y'know?
17:54:15 <lispy> at the moment work is getting this database code working in haskell, so i can't use busy an excuse to not read relevant documentation :)
17:54:52 <Pitarou> By the way.  Can somebody tell me how to tell Debian to use British Summer TIme rather than GMT?
17:55:07 <bolrod> O_o?
17:55:10 <bolrod> why the hell do you want that?
17:55:16 <lispy> Pitarou: tzconfig?
17:55:55 <Pitarou> bolrod: Because I'm 50 minutes early for everything, and I'm getting confused.
17:56:18 <bolrod> what about setting it to gmt+1
17:56:24 <lispy> if you could make a backwards '?' then that would look like a face with two ears, ?O_o?
17:56:29 <bolrod> or -1 
17:56:43 <bolrod> backwards?
17:56:47 <bolrod> ah
17:57:06 <bolrod> O_o?
17:57:09 <lispy> @O_o?
17:57:10 <lambdabot> Unknown command, try @list
17:57:11 <bolrod> rats
17:57:19 <Pitarou> lispy: thanks
17:57:21 <bolrod> O_o?
17:57:24 <bolrod> hmmm
17:57:28 <lispy> Pitarou: np
17:57:49 * lispy also recommends ntpdate if you don't already run it
17:57:50 <bolrod> C:
17:57:55 <bolrod> no no no no
17:57:57 <bolrod> not ntpdate
17:58:01 <bolrod> ntp-server
17:58:09 <lispy> why?
17:58:16 <bolrod> because it runs automaticly
17:58:24 <bolrod> and you can enter multiple npt servers
17:58:49 <lispy> nice, i think i created a crontab to solve that problem
17:58:55 <lispy> which is sort of ghetto
17:59:08 <bolrod> well.. if you don't want to have a running service due to lack of memory
17:59:12 <bolrod> you could do that
17:59:18 * Pitarou checks aptitude
17:59:29 <bolrod> aptitude?
17:59:32 <Pitarou> Yup.  I've got ntp-server installed.
17:59:33 <bolrod> go use  apt
17:59:39 <bolrod> ;p
17:59:41 <Pitarou> bolrod: Don't be such a snob.
17:59:42 <lispy> well, foo, bar and baz, i'm still getting the type error, so my fd fu is too weak
17:59:57 <bolrod> it's late.. go home ;)
18:00:06 <Pitarou> bolrod: Anyway, real men use dpkg.
18:00:08 <lispy> oh, and do the dishes!
18:00:15 <bolrod> I use it occaisionally 
18:00:19 <bolrod> to install .debs
18:00:26 <bolrod> or see what I got installed
18:00:38 <bolrod> with  dpkg --get-selections | grep 
18:00:59 * bolrod is using ubuntu though
18:01:23 <lispy> apt-get install apt-showversions
18:02:01 <bolrod> apt-show-versions
18:02:02 <bolrod> >_>
18:02:07 <Pitarou> bolrod: Have they got the WiFi and WPA support up to scratch in Ubuntu yet?
18:02:14 <bolrod> I don't know
18:02:24 <bolrod> I did have a wifi card in my desktop..
18:02:29 <bolrod> and I got it to work
18:02:37 <bolrod> but not WPA
18:02:50 <bolrod> I don't bother with using wpa...
18:03:01 <bolrod> WEP is fine enough for me ;)
18:03:23 <Pitarou> That was my experience when I tried it a few months ago.  I wanted to install Ubuntu on my sweetheart's spare computer, so that I could remotely admin it.
18:03:38 <tony2> I came to debian from gentoo about a month ago, and so far quite impressed.
18:03:52 <bolrod> few months ago is before the dapper release I guess?
18:04:04 <bolrod> the newest kernel has quite some wifi drivers I think
18:04:09 <bolrod> also the Airport extreme
18:04:15 <bolrod> it's not in ubuntu though
18:04:27 <Pitarou> bolrod: Yeah.  The last I heard, WiFi support was one of the causes for delaying the Dapper release.
18:04:56 <bolrod> seems like they updated the kernel 'again'
18:05:18 <bolrod> that's like..2 times after the release..
18:05:19 <Pitarou> tony2: I thought Gentoo was for the hardcore control freaks?  (The ones who don't feel comfortable unless they compiled the kernel themselves.)
18:05:29 <bolrod> haha
18:05:59 <tony2> I compile my own kernels always.
18:06:09 <Pitarou> haha!
18:06:11 <Pitarou> I rest my case.
18:06:14 <Pitarou> ;-)
18:06:19 <bolrod> I don't bother with it
18:06:19 <tony2> ;)
18:06:29 <lispy> for me it depends on the machine
18:06:40 <lispy> laptop --> self compile, server -> distro kernel
18:06:41 <tony2> I thought I'd love gentoo cos I loved freebsd so much back in the day.
18:06:42 <bolrod> it'll only break the ubuntu things
18:06:58 <Pitarou> tony2:  Do you get better performance that way?  Or does it just give you a warm, glowing feeling inside?
18:07:08 <bolrod> I guess that 2nd
18:07:09 <tony2> but emerge sucked.
18:07:32 <bolrod> it's not that it's like... alot faster on a normal pc..
18:07:32 <tony2> no generally it is patched.
18:07:34 <lispy> http://funroll-loops.org/
18:07:35 <lambdabot> Title: "Welcome to Gentoo is Rice, the Volume goes to 11 here."
18:07:38 <bolrod> maybe if you have specialized hardware.. ?
18:07:48 <tony2> reiser4
18:08:03 <tony2> for ages bluetooth patches, although not anymore.
18:08:28 <tony2> (I have an apple wireless keyboard)
18:08:29 <bolrod> http://www.watching-grass-grow.com/
18:08:30 <lambdabot> Title: "Watching Grass Grow WEBCAM!"
18:08:43 <Pitarou> http://www.oralse.cx
18:08:45 <lambdabot> Title: "Sex Kitten"
18:08:55 <Pitarou> Miaow.
18:09:52 <bolrod> "So... if you are under the age of 18 or find this photograph offensive, please don't look at it"    genius 8)
18:11:49 <Pitarou> tony2: I'm nowhere near your level of hardcoreness.  aptitude gives me all the toys I need.
18:12:56 <tony2> well, it's not such hardcoreness, I just use an unsupported filesystem and I just love apple peripherals even though I have a PC.
18:13:40 <tony2> and now I use debian and it's working out ok. 
18:13:56 <tony2> Gentoo's emerge tool really was badly broken.
18:14:11 <Pitarou> What *is* emerge?  Is that their package management system?
18:14:17 <tony2> and now I have a need for those CPU cycles also.
18:14:33 <tony2> yeah, but it builds everything not packages.
18:15:03 <u221e> Great... I'm going to submit my program for the shootout and the website is down.
18:15:11 <pejo> tony2, doesn't it build a package, from the source?
18:15:33 <tony2> pejo, well it can, but typically not.
18:15:44 <sjanssen> u221e: which program did you write?
18:15:56 <u221e> mandelbrot
18:16:13 <sjanssen> ah, is it a big improvement?
18:16:30 <tony2> u221e, much improvement?
18:16:33 <u221e> Yes. about 5 seconds on my machine
18:17:03 <tony2> opps, stupid lag. Well done u221e.
18:19:32 <Pitarou> Nice one, u221e.1
18:20:18 <Pitarou> By the way, the last time I looked (which *was* a long time ago) I noticed that the Haskell code for the "read in a long list of numbers and sum them all" was actually cheating.  Has anything come of that yet?
18:20:37 <sjanssen> Pitarou: how is it cheating?
18:21:32 <Pitarou> The rules said something like, "You're not allowed to write your own custom number parser.  You have to use the standard one."
18:22:00 <Pitarou> Is that version still in there?
18:22:11 <u221e> What's the benchmark called?
18:22:46 <u221e> Guess it doesn't matter, the site is down so I can't check.
18:22:48 <Pitarou> I can't remember.  It was a long time ago that I noticed it.  What's the URL?
18:23:07 <u221e> http://shootout.alioth.debian.org/
18:25:09 <Pitarou> Thanks.  I'll check it out when the server's back up.
18:25:38 <u221e> My mandelbrot program would be even faster but dons informed me that I probably had to print the chars one at a time and not use putStr
18:27:52 <sjanssen> why do you have to print the chars one at a time?
18:27:57 <Pitarou> u221e: Aren't they equivalent in Haskell?
18:28:57 <tony2> isn't line buffering default?
18:30:58 <u221e> Well there is a slowdown when I used putChar compared to putStr
18:31:16 <sjanssen> u221e: yeah, I would imagine
18:32:03 <sjanssen> I can't think of any cases where you must use putChar rather than putStr
18:32:16 <tony2> how big a slowdown?
18:32:22 <u221e> About 1 second
18:32:24 <Pitarou> I meant semantically equivalent.
18:33:02 <u221e> You can check it out here i s you want
18:33:03 <u221e> http://www.haskell.org/hawiki/MandelbrotEntry
18:33:04 <lambdabot> Title: "MandelbrotEntry - The Haskell Wiki"
18:33:43 <sjanssen> u221e: I still don't see the necessity of putChar, what did dons say about it?
18:34:54 <u221e> He said that the shootout people would probably have concerns about it
18:35:25 <sjanssen> I can't imagine what kind of concerns they would have
18:35:39 <sjanssen> is there some kind of restriction I don't know about?
18:35:51 <u221e> Not in the actually rules of the benchmark
18:36:26 <u221e> I wonder if there is someone I can email for clarification.
18:37:12 <sjanssen> u221e: is the first entry yours?
18:37:24 <u221e> Proposed, yes
18:37:56 <sjanssen> have you tried looking at the core GHC generates for it?
18:40:06 <u221e> How?
18:40:40 <sjanssen> u221e: -ddump-simpl . . . it's tough to read if you're new to it
18:41:03 <sjanssen> I'll look at it and see if I can juice out more performance
18:41:51 <u221e> What does unsafeChr do?
18:42:14 <sjanssen> u221e: what is a good argument for me to benchmark this?
18:42:28 <sjanssen> u221e: unsafeChr checks to see if the Integer is in the correct range or not
18:44:03 <u221e> Good argument? Well it's faster and easier to read for one.
18:44:53 <sjanssen> u221e: I mean argument for when I execute the program
18:45:19 <Pitarou> u221e: That's a beautiful piece of code!  :-)
18:46:17 <u221e> lol
18:46:24 <u221e> Ok, hold on.
18:46:53 <u221e> -O3 -optc-O3 -fglasgow-exts -fexcess-precision
18:48:26 * Pitarou is going to bed now
18:51:31 <sjanssen> I have no clue why, but adding strictness to this code slowed it down . . . weird
18:56:34 <tony2> goodnight all
18:58:30 <bolrod> what about a mandelbrot that can zoom in arbitrarily far
18:58:57 <lispy> sjanssen: i've experienced that too
18:59:19 <lispy> strictness isn't always good and laziness isn't always good...ah...life
18:59:32 <sjanssen> u221e: did find one critical thing, give bw an explicit type signature of Int
18:59:40 <bolrod> yes. life..   since you mention it..  it's getting light REALLY fast
18:59:54 <sjanssen> lispy: code like this, with tight numerical loops, should be faster with strictness
19:02:11 <u221e> Why Int?
19:02:44 <sjanssen> Int is faster -- a single machine instruction per operation
19:03:03 <sjanssen> u221e: you don't need more precision than 32 bits, do you?
19:03:05 <u221e> What is it now?
19:03:29 <sjanssen> u221e: Integers are multiple precision
19:03:41 <sjanssen> > 2^33 :: Integer
19:03:42 <lambdabot>  8589934592
19:03:53 <sjanssen> > 2^33 :: Int
19:03:54 <lambdabot>  0
19:04:02 <dons> morning!
19:04:30 <sjanssen> evening!
19:04:57 <u221e> dons, tell sjanssen what you told me about not being about to use putStr for the shootout
19:05:25 <dons> ah, the rules for mandelbrot say we have to do 'byte-at-a-time' io
19:05:37 <dons> which rules out putStr, imo, since it's writing buffers at a time
19:05:49 <sjanssen> ah, I suppose
19:05:53 <Dino_> Working on the section of YAHT with the Simple State Monad..
19:05:56 <dons> hence all the entries i looked at use putc or equivalent
19:06:18 <u221e> But doesn't putChar buffer?
19:06:20 <cmarcelo> dons: hi. are there in fps/ByteString any out-of-box direct conversion from Int -> ByteString, Integer -> ByteString?
19:06:28 <SamB> u221e: so does putc
19:06:33 <Dino_> They have this:  type State st a = st -> (st, a)
19:06:40 <SamB> that is an implementation detail of the library
19:06:46 <Dino_> And then:  returnState :: a -> State st a
19:06:47 <dons> cmarcelo: direct? no. pack . show works though
19:06:48 <sjanssen> u221e: I've got your entry from 3.21s to 2.53s (with n = 2000)
19:06:57 <Dino_> returnState a = \st -> (st, a)
19:07:12 <dons> wow, after being stuck on a local minima so long, there seems to have been lots of speed ups in the last few days
19:07:21 <dons> ghc must have been choking on the old code
19:07:28 <Dino_> Does that mean, when returnState is used, it's like curried with the a already in place and waiting for an st?
19:07:38 <dons> u221e: have you submitted? what's the state of play?
19:07:50 <u221e> Not yet, the shootout site is down
19:08:17 <dons> ah
19:09:22 <bolrod> was that the site that was comprommised?
19:10:08 <u221e> compromised?
19:10:22 <bolrod> maybe it wasn't
19:10:24 <bolrod> http://it.slashdot.org/article.pl?sid=06/07/13/0047210
19:10:25 <lambdabot> Title: "Slashdot | Debian Server Compromised"
19:11:45 <bolrod> it's not even that the server is just down.... it's not even found :/
19:11:48 <bolrod> try pinging it
19:12:15 <bolrod> maybe their nameserver is down..
19:14:46 <dons> u221e: re. "how else can you submit" to the shootout, musasabi here has a cvs account, so he can cvs commit directly
19:14:51 <dons> which speeds the whole process up
19:14:56 <dons> since you bypass the web queue
19:15:07 <dons> @seen musasabi 
19:15:08 <lambdabot> musasabi is in #haskell, #haskell-blah and #haskell-overflow. I don't know when musasabi last spoke.
19:15:17 <dons> yeah, been a while. i think he's busy with his new job
19:15:39 <sjanssen> bah, why didn't somebody invent ! patterns 5 years ago?
19:16:00 <dons> yeah, when clean started doing the same things. we should have jumped
19:16:11 <sjanssen> the `seq` False trick is losing it's novelty
19:16:18 <dons> hehe
19:16:24 <dons> ! is much nicer, I agree
19:17:15 <sjanssen> u221e: mind if I paste my improvements over your code on the wiki?
19:17:35 <sjanssen> it's just a couple line changes, but it makes a substantial difference
19:17:46 <dons> if you guys want, i can benchmark them all. it's important to get some empirical data
19:17:48 <u221e> Sure
19:18:04 <sjanssen> dons: so easier if I just dump it on the web for now?
19:18:08 <dons> yep
19:20:06 <sjanssen> http://cse.unl.edu/~sjanssen/mandelbrot-sjanssen.hs
19:20:24 <dons> chees
19:20:26 <dons> r
19:20:33 <sjanssen> cheesr!
19:21:01 <u221e> What's seq do?
19:21:28 <dons> you looked at the core, sjanssen ?
19:21:45 <sjanssen> u221e: seq x y forces x to be evaluated before returning y
19:22:02 <dons> it helps out the strictness analyser, meaning more values can be unboxed to primitive types
19:22:02 <sjanssen> dons: yeah.  With 6.5, is everything cool with 6.4?
19:22:11 <dons> since it's known they're never bottom/undefined
19:22:17 <dons> let me see..
19:22:28 <dons> should be fine, i don't suspect anything
19:23:41 <dons> hmm, i just installed the cache-ahead firefox plugin, seems to make a noticeable difference, https://addons.mozilla.org/extensions/moreinfo.php?id=1269&application=firefox for those interested
19:23:51 <Dino_> So, when we say this:  type State st a = st -> (st, a)
19:24:06 <Dino_> We mean that State st a is the type of a function from st to (st, a)
19:24:41 <bolrod> does it also cache pages you don't want to click?
19:25:11 <u221e> Hm..
19:25:19 <dons> yeah, i think it looks ahead, does a whole bunch of evil things
19:25:19 <u221e> sjanssen, you version runs slower
19:25:30 <dons> u221e: it can vary from box to box, of course
19:25:50 <dons> in particular, bsd versus linux, and powerpc versus x86
19:25:55 <bolrod> ofcourse... looking ahead while filling in some online form.. isn't the best thing to do
19:25:56 <dons> for these tight numerical problems
19:26:06 <u221e> I mean like more then 3 seconds slower
19:26:57 <dons> gp4 reults:
19:26:58 <dons> $ time ./old 5000 > x 
19:26:58 <dons> ./old 5000 > x  14.48s user 0.02s system 99% cpu 14.519 total
19:26:58 <dons> $ time ./u221e 5000 > y 
19:26:58 <dons> ./u221e 5000 > y  12.04s user 0.02s system 99% cpu 12.078 total
19:27:01 <dons> $ time ./sjanssen 5000 > z 
19:27:03 <dons> ./sjanssen 5000 > z  12.68s user 0.01s system 99% cpu 12.696 total
19:27:39 <dons> and in the same ratio for smaller numbers.
19:28:06 <u221e> I'm still using GHC 6.4.1 though.
19:28:15 <dons> yeah, me too.
19:28:44 <dons> let's see 6.5
19:28:47 <jgrimes> :)
19:29:25 <sjanssen> mine seems to do better on the lower numbers, at 2000 I solidly beat u221e's
19:30:10 <u221e> The bench is run at 3000 I think
19:31:01 <dons> oh, things run a lot slower under my april ghc 6.5, i'll avoid that i think
19:31:14 <u221e> What arguments are you using sjanssen?
19:31:27 <dons> u221e: i think it's run at 600 on the debian box, and 5000 on the gp4, isn't it?
19:31:30 <dons> or maybe 3000
19:31:46 <dons> i used -O2 -optc-O3 -funbox-strict-fields -fexcess-precision
19:32:03 <sjanssen> I used the same except for -funbox-strict-fields
19:33:37 <palomer> @palomer
19:33:37 <lambdabot> Learning vim is pointless
19:33:39 * palomer hugs dons
19:34:41 <sjanssen> hmm, so what could be causing my code to be slower for higher iterations?
19:34:51 <dons> u221e wins by 1.9 versus 2s on my gp4, with n=2k
19:35:05 <dons> i'm wondering why yours is faster on your box.
19:35:07 <dons> what arch?
19:35:10 <dons> which gcc version?
19:35:19 <dons> ah, I see i'm using 4.0.3
19:35:48 <sjanssen> dons: OS X on Intel Core Duo, gcc 4.0.1
19:36:04 <u221e> On my machine at n=3000, my version gets 6.388 and sjanssen's mod gets 9.797
19:36:36 <bolrod> how can it enter as a 'haskell' program.. when it uses gcc ?
20:57:57 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together", "http://snappoll.com/poll/84228.php'
20:57:57 --- topic: set by kosmikus on [Mon Jun 12 09:18:44 2006]
20:57:57 --- names: list (clog lispy largos dfeuer wli noj svens NameTab Lemmih qwr wolverian musasabi thedward shawn wilx genneth Philippa dgoldsmith ramkrsna arguile pflanze pejo neologism mux cods orbitz dvekravy ksandstr moonlite GeniXPro dons integral Pseudonym Adamant jmob CLxyz borism chessguy ozone bdash mattam aref lambdabot sieni SamB_XP cmeme Korollary Speck Khisanth Nioate seafood jer u221e ruffneck jargonjustin sethk kpreid edwinb tic johs scw mlh Hmm_|)
20:57:57 --- names: list (Nanar JKnecht Spark lorne liyang slipstream resiak joe_k lokadin eyck WillKW mornfall reppie psnl shrimpx LoganH flux__ Igloo ohub ValarQ Lunar^ alec pesco _calvin_ aleator noclouds Revision17 dcoutts_ mathrick palomer Pupeno jgrimes cedricshock |Steve| tessier_ Poeir Cale Plareplane Bobstopa petekaz sellout edwardk satan juhp Arnia david_ ulfdoz JohnMeacham Wallbraker ibid eivuokko drbean kosmikus SimonRC astrolabe rafl gds toyz nomeata)
20:57:57 --- names: list (df_ dany2k norpan Twig-raptor nothingmuch ChilliX _Codex piggybox mauke jmob| xinming AtnNn earthy audreyt nnunley gdsx ricebowl vegai xerox SamB magagr dropdrive woggle araujo moonfish dcoutts Azmo Nomius kolmodin Trixsey bolrod danly conal kpk exnor cmarcelo wchogg locksy)
20:57:59 <lambdabot> Double, Float, Ratio a
20:58:04 <SamB_XP> oh, okay...
20:58:14 <SamB_XP> @hoole Rational
20:58:14 <lambdabot> Prelude.Rational :: type Rational
20:58:15 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
20:58:15 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
20:58:29 <jgrimes> SamB, the implementation of init is on http://www.haskell.org/onlinereport/standard-prelude.html
20:58:30 <lambdabot> Title: "The Haskell 98 Report: Standard Prelude"
20:58:43 <SamB_XP> palomer: Rational is a type synonym for Ratio Integer, isn't it?
20:59:15 <SamB_XP> jgrimes: that one I've seen
20:59:20 <SamB_XP> but what about RULES?
20:59:25 <SamB_XP> there are no RULES on that page
20:59:29 <jgrimes> SamB_XP, oh, hm
20:59:34 <palomer> yeah, it is
20:59:38 <palomer> that explains it
20:59:40 <palomer> what a silly alias
20:59:45 <SamB_XP> hehe
21:39:07 <palomer> hrmph
21:39:13 <palomer> how do we get the index of an element in a list?
21:41:01 <vegai> > [1,2,3] !! 2
21:41:02 <lambdabot>  3
21:41:15 <vegai> what the hell am I thinking, you didn't ask that.
21:42:52 <Cale> findIndex (==2) [1,2,3]
21:42:54 <Cale> > findIndex (==2) [1,2,3]
21:42:55 <lambdabot>  Just 1
21:43:32 <vegai> @arr
21:43:32 <lambdabot> Aye
21:48:14 <dons> what the hell are you thinking, vegai?
21:49:39 <palomer> just saw "what the bleep do we know?!"
21:55:53 <RyanT5000> is there a way to have two .cabal files in one directory work properly?
21:55:58 <RyanT5000> i want to do something like
21:56:12 <vegai> dons: I'm thinking that I could send you a bad patch for lambdabot
21:56:18 <RyanT5000> runhaskell setup whatever.cabal configure
21:56:31 <RyanT5000> i'm also open to modifying the setup.lhs
21:56:38 <RyanT5000> (or having two of them)
21:57:29 <vegai> I ended up doing the unhtml in Lib/Url.hs's urlPageTitle. I hope that's ok.
22:00:08 <vegai> oh, and I did it against 4.0.1... that's not good.
22:01:48 <dons> well, the patch will probably still apply
22:01:52 <vegai> ah, not so bad. That file hasn't been changed since. Yep.
22:01:57 <dons> unhtml sounds good.
22:02:11 <dons> send send!
22:03:47 <vegai> hmm, what does darcs send use to transport the mail by default... localhost:smtp?
22:04:39 <dons> yep
22:04:46 <dons> perhaps then darcs send -o /tmp/foo.patch
22:04:51 <vegai> yep
22:04:51 <dons> then mail me manually that file
22:06:23 <vegai> I'll put up some dummy mail server later, darcs send is very convenient indeed
22:08:22 <vegai> thece.
22:08:45 <dons> got it.
22:08:56 <dons> ?karma+ vegai -- patchified!
22:08:56 <lambdabot> vegai's karma raised to 1.
22:09:12 <vegai> wow 
22:09:42 <palomer> welcome to the family
22:13:24 <dons> @quit some new toys
22:17:01 <palomer> hrmph
22:17:43 <palomer> seems tautology and fallacy are losing meaning, in the sense that they now encompass new meanings
22:17:56 <vegai> they're gaining meaning!
22:19:07 <glguy> I'm trying to understand what forall does.  As I'm reading about it I'm hearing a lot about "rank 2 types"... could someone tell me what a rank 2 type is?
22:19:56 <palomer> oh boy
22:20:28 <palomer> a -> (forall b. c->b) -> b
22:21:09 <palomer> err
22:21:12 <palomer> a -> (forall b. c->b) -> c
22:21:24 <palomer> the second argument has to be polymorphic in its return type
22:21:43 <palomer> a -> (forall b.b) -> c
22:21:50 <palomer> the second argument has to inhabit all types
22:21:54 <palomer> (thus must be bottom)
22:21:59 <palomer> are you gaining insight?
22:22:41 <dons> here you go, http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#universal-quantification
22:22:43 <lambdabot> Title: "7.4. Type system extensions"
22:22:46 <glguy> () is equivalent to _|_ ?
22:22:54 <palomer> no
22:22:58 <palomer> () doesn't inhabit Int
22:23:00 <palomer> but _|_ does
22:23:01 <dons> nope
22:23:04 <dons> > ()
22:23:06 <lambdabot>  ()
22:23:07 <dons> > undefined
22:23:07 <lambdabot>  Add a type signature
22:23:39 <dons> () is the value with type (), whose only other inhabitant is _|_
22:23:49 <vegai> dons: oh, wait. darcs send just uses /usr/bin/sendmail.
22:23:50 <dons> also known as unit
22:24:00 <glguy> () is unit?
22:24:04 <dons> yep
22:24:40 <dons> > (minBound :: (), maxBound :: ())
22:24:41 <lambdabot>  ((),())
22:24:51 <dons> > (minBound :: Bool, maxBound :: Bool)
22:24:52 <lambdabot>  (False,True)
22:25:01 <dons> so the first has one non-bottom element
22:25:09 <dons> the second type as 2 inhabitants
22:26:25 <glguy> the first type?
22:26:30 <glguy> and second type
22:27:03 <dons> ah, here's a better way to show the non-bottom inhabitants of a type
22:27:05 <dons> > enumFrom (minBound :: ())
22:27:07 <lambdabot>  [()]
22:27:11 <dons> > enumFrom (minBound :: Bool)
22:27:12 <lambdabot>  [False,True]
22:27:18 <dons> > enumFrom (minBound :: Word8)
22:27:20 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
22:27:34 <dons> > enumFrom (minBound :: (Bool,Bool))
22:27:34 <lambdabot>  add an instance declaration for (Enum (Bool, Bool))
22:27:35 <lambdabot>   In the definition o...
22:27:41 <dons> > enumFrom (minBound :: (Bool,()))
22:27:41 <lambdabot>  add an instance declaration for (Enum (Bool, ()))
22:27:41 <lambdabot>   In the definition of ...
22:27:45 <dons> bah
22:28:04 <Oejet> Hi, I'm trying to make an offline installation of GHC from Fedora Extras.
22:28:16 <glguy> so "Maybe Bool" has 3 inhabitants?
22:28:27 <dons> right, Just True, Just False, Nothing
22:28:33 <glguy> > enumFrom (minBound :: Maybe Bool)
22:28:34 <lambdabot>  add an instance declaration for (Bounded (Maybe Bool))
22:28:34 <lambdabot>   In the expressio...
22:28:51 <Oejet> Using: "rpm --install ghc-6.4.2-2.fc5.i386" I get this error:
22:28:53 <dons> yeah, there's a missing recursive instance call 
22:29:19 <dons> i.e. we want instance Bounded a => Bounded (Maybe a)
22:29:23 <dons> for the enum trick to work
22:29:43 <glguy> oh..
22:29:45 <Oejet> error: Failed dependencies: ghc642 = 6.4.2-2.fc5 is needed by ghc-6.4.2-2.fc5.i386
22:30:21 <Oejet> The problem is, I do not see a ghc642 package anywhere.
22:31:46 <dons> glguy: which is a bit strange, considering we already have instance (Bounded a, Bounded b) => Bounded (a,b) where
22:32:24 <dons> > enumFrom (minBound :: Ordering)
22:32:25 <lambdabot>  [LT,EQ,GT]
22:32:34 <dons> 3 elements
22:36:21 <glguy> alright, now help me relate types having a possibly defined number of inhabitants
22:36:30 <glguy> to bottom inhabiting all types
22:37:00 <dons> well, its a lazy language, so a value of type 'x' could always be an as-yet-unevaluated computation, that might even diverge
22:37:20 <dons> so the bottom value is an element of every (boxed) type in haskell
22:37:43 <dons> we do also have strict, unboxed values, for which bottom cannot be a value, since such values are strict
22:38:39 <dons> > case Just (Just (error "too deep")) of Just _ -> "yes"
22:38:40 <lambdabot>  "yes"
22:38:53 <dons> so there , a bottom value in a data structure isn't a problem
22:39:59 <dons> glguy, more questions?
22:40:03 <glguy> as a side question, does the language specification dictate that error "too deep" must not be evaluated because it doesn't need ot be evaluated?
22:40:19 <glguy> or would it be valid behavior for the error to be evaluated?
22:40:37 <dons> yes, in this case it is specified by the "normal form" a value is evaluated to in a case statement
22:40:49 <dons> only the minimum amount of evaluatoin is done
22:40:52 <dons> no, it wouldn't be valid
22:41:06 <glguy> ok, so *only* the minimum ammount of evaluation may be performed
22:41:11 <dons> > case Just (Just (error "too deep")) of Just (Just _) -> "yes"
22:41:12 <lambdabot>  "yes"
22:41:19 <dons> > case Just (Just (error "too deep")) of Just (Just x) -> x
22:41:19 <lambdabot>  Add a type signature
22:41:23 <dons> > case Just (Just (error "too deep")) of Just (Just x) -> x :: ()
22:41:24 <lambdabot>  Exception: too deep
22:41:41 <dons> so only when we finally actually used the error value did it get evalauted
22:41:48 <glguy> I understand that part
22:41:53 <dons> > case Just (Just (error "too deep")) of Just (Just x) -> take 2 [1,2,x]
22:41:54 <lambdabot>  [1,2]
22:42:08 <glguy> I was just asking if the compiler is free to evaluate as much as it wants to or not
22:42:17 <glguy> or if it must always evaluate the minimum
22:42:20 <dons> within the constraints of the operational semantics
22:42:35 <dons> you can't have more bottoms sneaking in
22:43:28 <dons> there's an evaluatoin strategy, eager eval, where the compiler evaluates strictly by default, until it hits a bottom (from memory), in which case it suspends that computation in case the bottom was important (i.e. like an infinite list)
22:43:49 <palomer> haskell evaluation is confluent, I think, so you don't need to worry
22:44:26 * jer likes to think of haskell as the language that can do time travel =]
22:44:36 <dons> that's a good analogy :)
22:44:40 <edwardk> heh
22:44:41 <dons> i must use that some time
22:44:59 <jer> dons, i think i read it first on an LtU posting, i cannot remmeber. it is safe to say it's not my own words
22:45:03 <edwardk> i suppose it can in sort of a closed loop sorta way =)
22:45:15 <dons> well, we do have backtracking monads now
22:45:26 <dons> and most haskell debuggers can reverse the computation order
22:45:36 <dons> (which is kind of stunning when you discover this for the first time)
22:45:44 <jer> although the poster put it more eloquently, something to the tune of haskell being able to do something phsyics cannot: allow for time travel
22:45:56 <dons> ah, yes, that rings a bell
22:45:57 <edwardk> heh, didn't know about the debugger thing
22:46:19 <edwardk> going to have to get some haskell code to actually type check and then misbehave so i can have an excuse to debug ;)
22:46:19 <dons> edwardk: perhaps ask ndm. he's working on hat, which i think is able to 'step backwards'
22:46:37 <dons> yeah, that's more of the problem, trying to get bugs _in_ the code ;)
22:46:45 <pissed> php room kiced me the bastards
22:47:13 <edwardk> i suppose its a happy problem to have ;)
22:47:25 <palomer> hrmph
22:47:32 <palomer> it sucks that I won't ever be part of a workforce
22:47:39 <palomer> I just can't bring myself to care for any company
22:47:54 <edwardk> then why does it suck? =)
22:48:01 <palomer> limits my options
22:48:09 <vegai> anyone know the Website META Language toolkit? Anything similar written on Haskell yet?
22:48:45 <vegai> I suppose Text.Html is not very far from that..
22:50:52 <edwardk> btw- dons: the class associated types thing is tons slicker than the other crap i was doing
22:51:18 <dons> oh, you looked into it?
22:51:20 <edwardk> not portable for shit, but hey
22:51:21 <edwardk> yeah
22:51:22 <edwardk> =)
22:51:27 <dons> not portable?
22:51:31 <dons> oh, too hugs et al
22:51:41 <edwardk> grabbing building ghc 6.5 now to support it
22:51:52 <dons> hmm. i'm not sure its in ghc 6.anything yet
22:52:02 <dons> it's in a associated-types branch of ghc 6.5
22:52:09 <edwardk> oh joy
22:52:15 <edwardk> =)
22:52:19 <dons> and will get merged into the new System Fc branch
22:52:33 <dons> which unifies gadts, fds and assoc. types under the one Core language
22:52:41 <edwardk> *nods*
22:52:45 <dons> which will then become 6.6, i think
22:52:50 <edwardk> any idea of eta there?
22:52:55 <dons> 6 months?
22:53:04 <edwardk> and is 6.5 ever going to be released or is it stillborn?
22:53:05 <dons> or less if the System Fc stuff isn't to go in
22:53:11 <dons> no, its a devel branch
22:53:13 <edwardk> *nods*
22:53:14 <edwardk> ahh
22:53:18 <dons> it gets frozen and tagged, and renamed 6.6
22:53:21 <edwardk> odd/even kinda thing like linux?
22:53:26 <dons> yep
22:53:28 <edwardk> kk
22:53:46 <glguy> it's *way* ahead of linux... ;-) linux is only on version 2
22:53:49 <lispy> well, like linux used to use
22:53:53 <edwardk> heh
22:53:59 <dons> what does the kernel do this day?
22:54:09 <lispy> they just increment away now
22:54:10 * dons hasn't used linux in 5 years
22:54:19 <dons> is it still 2.4 or is there 2.6 now?
22:54:22 <edwardk> lispy: ?
22:54:36 <lispy> 2.6.something the last i checked
22:54:40 <vegai> debian stable is defaulting to 2.4, I think
22:54:46 <vegai> rest of them are pretty much in 2.6
22:54:47 <edwardk> afaik its still standard policy to do risky things in odd minors
22:54:57 <lispy> vegai: more like debian stale :)  I tend to run testing
22:55:07 <edwardk> coz it was a big deal swapping out memory managers etc during an even cycle
22:55:17 <vegai> lispy: weell... having to upgrade the system just very rarely can be useful
22:55:39 <lispy> vegai: yup, it exists for a reason
22:56:05 <vegai> what's a Full Professor, as opposed to just Professor?
22:56:15 <vegai> well-fed?
22:56:21 <edwardk> lol
22:56:29 <edwardk> depends on the university
22:56:33 <vegai> http://web.cecs.pdx.edu/~sheard/
22:56:34 <lambdabot> Title: "Tim Sheard's home page"
22:56:47 <edwardk> they like to give all sorts of tiered titles to make you feel like you're getting somewhere ;)
22:57:45 <pissed> hello
22:57:49 <edwardk> adjunct, assistant, associate, professor, full senior whatever
22:58:15 <pissed> is haskell able to prduce nice websites?
22:58:23 <edwardk> they just stick random adjectives on and then if you make it to department head you can bicker with the other department heads about how to sort that list =)
22:58:32 <vegai> pissed: what a coincidence, I was just wondering the same
22:58:33 <pissed> is there any kind fo scheduling osftware in haskell?
22:58:33 <dons> pissed: yes, of course. check haskell.org for all the faqs
22:58:36 <glguy> the idea of data MyType b = forall a. MyConstructor a (a->b)
22:58:41 <glguy> makes sense to me now at least :)
22:58:43 <edwardk> pissed: there is a haskell server pages project out there thats pretty slick
22:58:50 <pissed> k
22:58:54 <pissed> back in few week
22:59:05 <vegai> though I'm looking something like WML instead of PHP
22:59:53 <pissed> wml?
22:59:59 <vegai> http://www.thewml.org
23:00:01 <lambdabot> Title: "Website META Language (WML), Title"
23:00:09 <edwardk> heh
23:00:26 <vegai> I suppose I could just use that, since it's very stable piece and works.
23:00:27 <jgrimes> we have html/xhtml combinator libraries
23:00:31 <edwardk> glad its a new wml, coz i'd bsically written you off as nuts wanting something like wireless markup language =)
23:00:39 * vegai smirks.
23:01:03 <jgrimes> and you can check out http://hope.bringert.net
23:01:07 <pissed> wml?
23:01:37 <dons> you missed the answer, pissed. scroll up
23:02:40 <dons> hmm. I'd like to write a tutorial, The Zen of Haskell, about the elegance and beauty of haskell hacking
23:02:50 <jgrimes> dons, :)
23:03:14 <dons> so, i suppose, combinators, pointfree style, higher-order stuff, 
23:03:27 <dons> domain specific mini languages
23:03:59 <vegai> Hope seems to be heading towards the blog market, am I right?
23:04:05 <jgrimes> no.
23:04:12 <jgrimes> towards the web application market
23:04:29 <vegai> ok
23:04:31 <jgrimes> it just has modules mostly related to blog stuff currently
23:05:02 <vegai> might it be usable for generating websites, a bit like thewml?
23:05:13 <jgrimes> I honestly haven't used thewml
23:06:26 <pissed> seems hoky
23:06:29 <pissed> wml
23:06:36 <pissed> offline?
23:08:08 <edwardk> i tend towards something like cocoon that can build it online on the fly on demand and cache the crap out of it
23:08:12 <dons> ?quit wibbles
23:09:14 <dons>  http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:09:18 <dons> testing...
23:09:29 <edwardk> a little bit of sitemap work and you can get your documentation or site out there updated from the database, in xsl:fo-> pdf or htm, etc. without much difficulty
23:09:32 <lambdabot> that's lambdabot
23:09:49 <dons> http://web.cecs.pdx.edu/~sheard/
23:09:50 <lambdabot> that's Tim Sheard's home page
23:10:13 <dons> http://www.google.com
23:10:14 <lambdabot> that's Google
23:10:22 <dons> hmm, maybe 'that's' isn't so nice
23:10:44 <edwardk> playing with the phrasing?
23:10:45 <pissed> coocoon?
23:10:53 <vegai> http://www.ksc.co.jp/spnet/excellent/
23:11:12 <edwardk> @google cocoon
23:11:13 <lambdabot> http://cocoon.apache.org/
23:11:13 <lambdabot> that's The Apache Cocoon Project
23:11:14 <glguy> http://google.com/search?q=just_reading_the_title_question_mark
23:11:15 <lambdabot> that's just_reading_the_title_question_mark - Google Search
23:11:32 <dons> hehe
23:11:36 <dons> right
23:11:59 <glguy> http://google.com/search?q=the%20funniest%20thing%20ever
23:12:00 <lambdabot> that's the funniest thing ever - Google Search
23:12:18 <vegai> http://utterlyboring.com
23:12:19 <lambdabot> that's Utterly Boring - You Have Something Better To Do?
23:12:23 <glguy> http://google.com/search?q=what%20she%20said
23:12:24 <lambdabot> that's what she said - Google Search
23:12:29 <vegai> ;-P
23:12:32 <dons> oh silly peopel
23:12:42 <jgrimes> haha..
23:12:44 <glguy> http://google.com/search?q=quite%20enough
23:12:45 <lambdabot> that's quite enough - Google Search
23:12:46 <glguy> ;)
23:12:49 <dons> heh
23:13:27 <glguy> it's a shame that setting q=/quit wouldn't work ;)
23:13:29 <dons> ?quit that's quite enough
23:15:10 <dons> http://google.com/search?q=any%20better
23:15:11 <lambdabot> Title: any better - Google Search
23:15:43 <glguy> hope for recursion?
23:15:43 <glguy> http://www.google.com/search?client=safari&rls=en&q=http://google.com&ie=UTF-8&oe=UTF-8
23:15:44 <lambdabot> Title: http://google.com - Google Search
23:15:49 <glguy> :(
23:15:56 <edwardk> heh
23:15:58 <dons> you wish 
23:16:07 <dons> :)
23:16:11 <edwardk> nah, ow you just need two of them on channel, and then it'll work =)
23:16:23 <dons> no, in fact. they ignore each other
23:16:28 <edwardk> shucks
23:16:31 <dons> but there's a few other fixpoints out there for people to fine
23:16:33 <dons> d
23:16:41 <edwardk> he
23:16:59 <glguy> why does this yield 'join' ?
23:17:03 <edwardk> i've started finding lambdabot to be pretty damn useful as a programming aid though
23:17:06 <glguy> @pl (\f x -> f x x)
23:17:06 <lambdabot> join
23:17:15 <dons> it's join in the (-> a) monad?
23:17:18 <dons> ?type join
23:17:20 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
23:17:32 <dons> ?type (\f x -> f x x)
23:17:34 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
23:19:12 <edwardk> dons: pointless kept inferring ap for me as a type, it makes sense, but ghc complained. i finally just added a where ap x y z = x y $ y z to the statement, but is there a trick to use the monadic ap that i'm not getting?
23:19:15 <dons> ?type join :: Monad ((->) r) => ((->) ((->) r)) -> ((->) r) -- maybe?
23:19:15 <lambdabot>   `(->) r' is not applied to enough type arguments
23:19:16 <lambdabot>   Expected kind `??', but `(->) r' has kind `? -> *'
23:19:23 <edwardk> er ap for me as a function to use
23:19:40 <dons> edwardk: yep, you need to get the Monad and Functor instance for (-> r)
23:19:49 <dons> which in ghc 6.4.x is in Control.Monad.Reader, iirc
23:19:55 <edwardk> ahhh
23:19:55 <dons> in 6.5 it's in Control.Monad
23:19:59 <dons> ?instances Monad
23:20:00 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:20:14 <edwardk> so import Control.Monad.Reader and all is well
23:20:20 <dons> yep, i think so
23:20:28 <dons> it's a common issue with @pl-ified code
23:20:39 <dons> -> r uses f >>= k = \ r -> k (f r) r
23:20:45 <dons> and fmap = (.)
23:20:50 <dons> which makes for some concise code
23:21:07 <edwardk> *nod*
23:21:12 <dons> but on an `interesting' abstraction level if you've not read up about Monad ((->) r)
23:21:21 <edwardk> heh
23:26:08 <glguy> what is the ((->) r) monad called?
23:26:15 <glguy> google doesn't know how to search for symbols
23:27:21 <dons> i say "arrow a", as in (-> a), but "function monad" might be better.
23:27:28 <dons> i'm not sure if there are papers on it though
23:28:11 <dons> maybe in jones, 95, "Functional Programming with overloading and higher-order polymorphism" ?
23:28:20 <dons> ?google Functional Programming with overloading and higher-order polymorphism
23:28:22 <lambdabot> http://www.cse.ogi.edu/~mpj/pubs/springschool.html
23:28:22 <lambdabot> Title: Functional Programming with Overloading and Higher-Order Polymorphism
23:28:45 <glguy> I've got that one downloaded
23:28:46 <glguy> but
23:28:58 <glguy> it looks like it has been scanned in
23:29:11 <glguy> I'm going to wait till i get t owork to abuse the printer 
23:29:32 <dons> yep, its in that paper, page 22
23:29:40 <dons> instance Functor (r ->)
23:29:40 <glguy> interesting, the pdf on this site isn't as hard to read as the copy that I have
23:30:42 <dons> and its described as a reader monad, page28. 
23:31:03 <dons> oh and return / >>= for Monad (-> r)  are just S and K, didn't spot that before
23:31:28 <glguy> the S and K i've read about on "Unlambda"
23:31:29 <glguy> ?
23:31:39 <Cale> glguy: yeah
23:31:40 <dons> yep. 
23:31:56 <Cale> hmm
23:33:16 <Cale> well, (=<<)
23:37:45 <edwardk> printing that to have something to read tonight
23:37:59 <khaladan> game of life in javascript: http://bhiggins.googlepages.com/game-of-life.html
23:38:01 <lambdabot> Title: Conway's Game of Life
23:39:02 <dons> khaladan: how is that related to haskell?
23:39:28 <khaladan> oh, oops, wrong channel
23:39:32 <khaladan> sorry
23:39:34 <dons> 'scool
23:39:38 <jgrimes> :p
23:40:06 <dons> we've just had a few link spammers recently, so i'm on the lookout :)
23:40:23 <jgrimes> how would you write some kind of case checking (if, guards) in an anonymous function?
23:40:30 <dons> in a lambda?
23:40:33 <jgrimes> yeah
23:40:33 <dons> like so
23:40:59 <dons> > (\x -> case x of 1 -> "Yes" ; 2 -> "No" ; 3 -> "I give up") 2
23:41:00 <lambdabot>  "No"
23:41:05 <jgrimes> sweet.
23:41:25 <jgrimes> thanks
