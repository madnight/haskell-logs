00:04:42 <parnassus> scheme
00:04:52 <parnassus> lisp, php, python, perl, tcl
00:04:53 <newsham> lisp
00:04:55 <parnassus> al banned
00:05:07 <parnassus> riastradh hates my guts in lisp and scheme
00:05:09 <parnassus> :(
00:05:14 <newsham> common tastes
00:05:40 <newsham> parnassus: the only thing perl, python and lisp people can agree on
00:06:01 <Pseudonym> That and the evilness of ruby.
00:06:25 <newsham> ruby's just reverse polish python
00:06:27 <RyanT5000> are you a C++ proselytizer?
00:06:41 <RyanT5000> that'd explain the banning from those rooms, lol
00:08:03 <Pseudonym> Haven't seen riastradh around here lately.
00:08:34 <parnassus> no
00:08:44 <parnassus> Im a linux admin who doesnt know much more than some bash
00:08:55 <parnassus> and i ask about what tools are nicest etc.
00:09:00 <RyanT5000> huh
00:09:04 <parnassus> how to get a scheduler and monitoring going easily
00:09:16 <parnassus> things that hurt me at rk u know
00:09:19 <parnassus> work
00:09:22 <parnassus> that is
00:09:30 <dons> why are you telling us this? its a haskell channel. we don't care.
00:09:34 <parnassus> ok
00:09:56 <parnassus> is there a decent scheduler in haskell? how about a netwrok monitor?
00:09:58 <Syzygy-> parnassus: Most of the channels you've mentioned will in highest probability have a more or less strict "stay on topic" policy.
00:10:22 <parnassus> right
00:10:36 <newsham> you need a bartender.
00:10:39 <Korollary> parnassus: you seem to be lacking some computer science fundamentals, which is why I think your questions may have annoyed some people.
00:10:40 <Syzygy-> parnassus: And most of what you're asking about are things that are not bound to a specific language - go ask around in #linux or something like that instead; where they actually are on-topic discussing system tools.
00:11:16 <Syzygy-> For scheduling, you want to look into cron and at. But this is definitely offtopic for #haskell.
00:15:38 <parnassus> hm
00:17:17 <Syzygy-> So - for something more ontopic. Having written a fibonacci function, I could find all fibonacci numbers lower than a specific threshold by filter (<n) $ map fibonacci [1..] - however, this won't terminate. Is there a sane way to do the same thing but with stopped execution and return as soon as the first non-matching element was encountered?
00:17:46 <newsham> takeWhile, under the assumption that fib numbers are increasing
00:17:55 <Pseudonym> Right.
00:18:50 <Syzygy-> Wow! Neat! :)
00:20:53 <dons> > takeWhile (<100) $ fix $ \f -> 1 : 1 : zipWith (+) f (tails f)
00:20:54 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
00:20:54 <lambdabot>    Expected...
00:21:25 <dons> > takeWhile (<100) $ fix $ \f -> 1 : 1 : zipWith (+) (tails f) f
00:21:26 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
00:21:26 <lambdabot>    Expected...
00:22:08 <dons> > takeWhile (< 100) $ fix $ \f -> 1 : 1 : zipWith (+) f (tail f)
00:22:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89]
00:22:20 <dons> > takeWhile (< 1000) $ fix $ \f -> 1 : 1 : zipWith (+) f (tail f)
00:22:21 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987]
00:24:26 <newsham> write a function which prints the percentage of numbers with the digit '7' in them
00:32:37 <wethaskellnewb> hey all, is there a builtin function for converting an integer to a string? Given 101, returns "101". I know I could write such a function pretty easily, but is there a standard built-in function?
00:33:10 <dons> > show 101
00:33:11 <lambdabot>  "101"
00:33:12 <RyanT5000> wethaskellnewb: show
00:33:31 <RyanT5000> show works on lots of things too
00:33:37 <RyanT5000> > show True
00:33:38 <lambdabot>  "True"
00:33:44 <wethaskellnewb> Doh, I didn't think of that. Was searching for names that have 'Str'...
00:34:02 <RyanT5000> yeah, it's not really the most obvious name ever
00:34:17 <dons> > read "101" :: Int
00:34:18 <lambdabot>  101
00:34:27 <dons> > (read . show) 101 :: Int
00:34:28 <lambdabot>  101
00:34:42 <newsham> :t (read . show)
00:37:12 <RyanT5000> @where lisppaste
00:37:12 <lambdabot> I know nothing about lisppaste.
00:37:15 <RyanT5000> @where paste
00:37:16 <lambdabot> http://paste.lisp.org/new/haskell
00:37:27 <wethaskellnewb> Thanks very much..., again
00:38:03 <lisppaste2> RyanT5000 pasted "Class deduction problem" at http://paste.lisp.org/display/23069
00:38:35 <RyanT5000> could someone who understands classes and such explain why that doesn't work?
00:39:19 <RyanT5000> it seems related to functional dependencies and such
00:39:36 <RyanT5000> oh... huh... maybe it really is ambiguous
00:41:16 <RyanT5000> grrr... making an abstract container class that works well when nested is harder than i thought
00:54:10 <Pseudonym> Night everyone.
01:03:28 <Syzygy-> wli: You're the same wli as in #math:EFNet, right?
01:17:25 <dmhouse> You know what? Gmail isn't all that productive. It's a four-click operation to mark some unread mail as read.
01:17:39 <dmhouse> It's at least a three-click operation to do most things.
01:18:13 <dmhouse> There endeth my early-morning rant.
01:18:40 <ValarQ> just ssh into google and run mutt :o)
01:18:56 <dmhouse> Does it have conversation view?
01:19:39 <dmhouse> That's the one thing I think Gmail has over practically all other webmails, but I haven't considered clients.
01:20:25 <ValarQ> i run imap and procmail on my own little server at home and then i can use virtually any client
01:20:41 <ValarQ> including squirrelmail if im in the webmail mood
01:20:48 <dmhouse> Well, Gmail provides POP3 access
01:21:34 <ValarQ> pop3 isn't really the same thing
01:22:17 <ValarQ> pop3 is good when you only retrieve the mails and retrieve them from one place
01:22:37 <Syzygy-> And running pop3 at a home server isn't an issue either if you have to...
01:23:02 <ValarQ> imap is more of a email client backend
01:30:12 <edwardk> heh, was skimming through the backlog
01:30:34 <edwardk> who had the question about the fraction of numbers with 7s in their digits?
01:31:00 <dmhouse> Surely you'd know if you were skimming through the backlog.
01:31:04 <edwardk> heh
01:31:13 <edwardk> well, i closed it just before reopening =)
01:31:15 * ValarQ points at newsham
01:31:42 <edwardk> kind of a pointless program to write isn't it? =)
01:32:32 <ValarQ> i can't se any good use for it
01:33:23 <dmhouse> > filter (any (=='7') . show) [1..1000]
01:33:25 <lambdabot>  [7,17,27,37,47,57,67,70,71,72,73,74,75,76,77,78,79,87,97,107,117,127,137,147...
01:33:31 <edwardk> (x + a)^n = Sum_{k=0}^n (n choose k) x^k a^n-k. Let x = -1/10, a = 1, you can show quite quickly that the resulting sequence is 1-(.9^x)
01:33:53 <edwardk> where x is the number of digits you are checking over.
01:34:05 <edwardk> so as x goes to infinity, the sequence goes to 1.
01:34:20 <edwardk> so the answer is that 100% of numbers have 7 as a digit. =)
01:34:33 <edwardk> its a vanishingly small fraction that don't.
01:35:36 <edwardk> so er..
01:35:48 <edwardk> > let f x = 1-(0.9**x) in f 1
01:35:50 <lambdabot>  9.999999999999998e-2
01:36:07 <edwardk> let f x = 1-(0.9**x) in f 2
01:36:35 <edwardk> > let f x = 1-(0.9**x) in map f [1..]
01:36:36 <lambdabot>  [9.999999999999998e-2,0.18999999999999995,0.2709999999999999,0.3438999999999...
01:37:06 <dmhouse> > let has7 = any (=='7') . show; has7s ub = filter has7 [1..ub] in (fromIntegral $ length $ has7s 1000) / 1000
01:37:07 <lambdabot>  0.271
01:37:16 <edwardk> aw that was boring. too much precision lost on lambdabot.
01:38:08 <edwardk> dmhouse: heh, the problem comes in when you try to run that way up to 100000000000 or so =)
01:38:19 <dmhouse> edwardk: Or indeed, infinity :)
01:38:23 <dmhouse> > let has7 = any (=='7') . show; has7s ub = filter has7 [1..ub] in (fromIntegral $ length $ has7s 10000) / 10000
01:38:23 <edwardk> yeah
01:38:24 <lambdabot>  0.3439
01:38:29 <dmhouse> > let has7 = any (=='7') . show; has7s ub = filter has7 [1..ub] in (fromIntegral $ length $ has7s 100000) / 100000
01:38:30 <lambdabot>  0.40951
01:38:49 <dmhouse> If I were proficient enough with Matlab, it'd be fun to plot that.
01:38:56 <edwardk> > let f x = 1-(0.9**x) in f 30
01:38:57 <lambdabot>  0.9576088417247838
01:39:08 <edwardk> i'll let you try to compute that one your way ;)
01:39:10 <edwardk> heh
01:39:35 <dmhouse> > let has7 = any (=='7') . show; has7s ub = filter has7 [1..ub]; ub = 10^30 in (fromIntegral $ length $ has7s ub) / ub
01:39:39 <lambdabot> Terminated
01:39:42 <dmhouse> Aww :)
01:44:43 <edwardk> well, final version of the icfp scoreboard is up, so its no fun to watch any more =)
01:47:03 * hellish still doesn't have a working UM.
01:47:39 <edwardk> did you get it to run the diagnostics and have it die or did you get further?
01:47:45 <shapr> Good morning #haskell!
01:47:51 <dmhouse> Hey there shapr.
01:47:55 <ValarQ> g'day shapr
01:48:02 <dmhouse> hellish: Are you on a team, or are just playing around?
01:48:03 <edwardk> you are way too perky for this time of morning shapr =)
01:48:17 <shapr> edwardk: it's 10:47am
01:48:22 <hellish> edwardk: It runs the diagnostics until the in runs out of head from it's space leak.
01:48:37 <hellish> dmhouse: Registered, but trying to solo it.
01:48:38 <edwardk> @localtime edwardk
01:48:39 <lambdabot> Local time for edwardk is Mon Jul 24 04:48:16 2006
01:48:43 <edwardk> =)
01:48:50 <dmhouse> edwardk: Go to bed.
01:48:54 <edwardk> heh
01:48:58 <edwardk> getting ready to
01:49:05 <dmhouse> I was up at that time on Saturday, but that's because I was climbing mountains.
01:49:36 * edwardk has been taping bits of paper to his wall with random notes for the last 6 hours trying to make some coherent sense out of them
01:49:43 <xerox> Good morning!
01:49:54 * xerox stretches
01:49:56 <dmhouse> Hey xerox.
01:50:10 <dmhouse> edwardk: why?
01:50:16 <xerox> Ah, you substituted me with the wall.. cool, ed %-)
01:50:38 <edwardk> trying to figure out that substructural pure type system thing i was poling folks aboutbefore =)
01:51:42 <edwardk> got most of the substructural properties in place, now i just want to make it clean.
01:53:06 <edwardk> kind of bizarre though, my sorts are now members of a powerset of qualifiers
01:53:33 <edwardk> that will probably go away when i wake up and can think straight.
01:54:24 <edwardk> getting sleep
02:00:31 <hellish> What do you do to pin down the source of a space leak? I have it narrowed down to single function...
02:01:33 <shapr> hellish: You can random stick seq in there to see when the behaviour changes, and then remove some seq to see when it comes back.
02:01:43 <xerox> Profile?
02:01:46 <dmhouse> Give up.
02:02:01 <shapr> But once you've found exactly what's leaking, think hard?
02:02:40 <hellish> what does seq do? I understand $!.
02:03:25 <xerox> ?type seq
02:03:26 <lambdabot> forall b a. a -> b -> b
02:03:39 <xerox> It evaluates to WHNF a and returns b.
02:03:43 <dmhouse> seq evaluates its first argument before returning the second.
02:04:00 <dmhouse> Unless the first argument evaluated to _|_, in which case, it returns _|_.
02:04:24 <xerox> That's not a property of seq, though, it's a property of bottom.
02:04:41 <hellish> Hmm...
02:04:42 <dmhouse> xerox: How so?
02:05:48 <xerox> dmhouse: bottoms mean interrupting evaluation.
02:06:22 <dmhouse> > const 4 undefined -- it's trivial to make functions that don't return bottom when passed it
02:06:23 <lambdabot>  4
02:06:52 <xerox> dmhouse: you don't need seq to interrupt the evaluation with bottoms.
02:07:11 <dmhouse> xerox: I'm not following you.
02:07:45 <xerox> > (+1) undefined
02:07:46 <lambdabot>  Undefined
02:08:31 <xerox> If it gets evaluated it stops the evaluation. `seq' just happen to force evaluation, it has no check whatsoever about "bottoms".
02:09:17 <dmhouse> Oh, I see what you mean.
02:30:04 <shapr> hellish: Did you get seq to help you?
02:30:44 <hellish> shapr: still sprinkling randomly. It doesn't look like it's in the where clause.
02:31:15 <shapr> @seen pesco
02:31:16 <lambdabot> I saw pesco leaving #haskell 2 days, 18 hours, 12 minutes and 6 seconds ago, and .
02:35:19 <gaal> Is there a pretty-printing library that can align tabular data? I have lines of the form
02:35:23 <gaal> aaa bbbbbbb cccc
02:35:53 <gaal> with a, b, and c of differenr widths. I want consecutive lines of this form to align a b and c columns.
02:36:18 <gaal> I don't think Text.PrettyPrint.HughesPJ does this, but I may be missing something.
02:54:10 <hellish> What is meant by "the system stack"?
02:54:20 <shapr> What context?
02:54:32 <mauke> the memory segment thingy?
02:54:43 <hellish> A retainer is either the system stack, or an unevaluated closure (thunk).
02:56:39 <hellish> from the heap profiling documentation.
03:30:07 <ndm> is there some syntax in haskell to declare a record where only some of the fields are named?
03:30:14 <ndm> i.e. Record {a :: Int} Bool
03:30:39 <ndm> which is equivalent to Record {a :: Int, anonymous1 :: Bool}
03:30:50 <ndm> with anonymous1 not being accessible
03:35:17 <edwinb> I don't think it is...
03:35:21 <dons> hmm, interesting question
03:35:23 <edwinb> er, possible, that is.
03:35:40 <edwinb> Seems it ought to be, but I just checked the report, and can't find it.
03:35:42 <ndm> I suspect not either, but just checking
03:35:46 <dons> brain to fried from icfp to remember
03:36:02 <ndm> interestingly, the core data types of Yhc seem to allow it - but that doesn't prove much at all
03:36:24 <edwinb> Well you can implement it as an extension ;)
03:36:31 <ndm> less extensions = better
03:36:35 <ndm> for the moment...
03:36:44 <ndm> i'm making the Yhc core output be 100% Haskell 98
03:36:49 <ndm> and simple Haskell 98 at that
03:37:03 <ndm> nothing but single level cases etc.
03:38:45 <dons> that's a cool idea
03:45:32 <shapr> ndm: How would you use inaccessible parts of a record?
03:45:43 <ndm> shapr: normal pattern matching
03:45:56 <dmhouse> What would they contain/
03:46:17 <dmhouse> If you can't set them, what would they contain? If you can both set and get them, in what way are they inaccessible?
03:46:20 <norpan> i've never liked the named record fields syntax
03:46:26 <ndm> imagine data Test = Test {a :: Bool} Int
03:46:39 <ndm> Test a b = Test a (b+1)
03:46:47 <ndm> the increment Test function, for example
04:12:38 <syntaxfree> Run run run to the cities of the future
04:13:23 <dmhouse> syntaxfree: ?
04:13:50 <syntaxfree> Slashdot finally discusses the technological singularity.
04:13:58 <syntaxfree> I'd almost given up on theplace.
04:25:34 <ValarQ> is there a unicode version of length?
04:25:45 <syntaxfree> http://science.slashdot.org/comments.pl?threshold=2&mode=flat&commentsort=0&op=Change&sid=191964
04:25:47 <lambdabot> Title: NPR Looks to Technological Singularity
04:25:49 <syntaxfree> oops.
04:25:51 <syntaxfree> not that.
04:25:57 <syntaxfree> this:
04:25:58 <syntaxfree> http://craphound.com.nyud.net:8080/man-machine-merger.mp3
04:33:27 <dmhouse> I can't stand literate sources.
04:33:45 <syntaxfree> I find doing literate programming amusing.
04:33:56 <syntaxfree> I have to try and write an academic paper that way some time.
04:34:12 <norpan> better than illiterate sources
04:34:12 <syntaxfree> I find the TeXBook and the Metafont Book unreadable, though.
04:34:40 <syntaxfree> maybe because I can't grok Pascal.
04:35:31 <dmhouse>       
04:35:34 <dmhouse> Err, oops
04:37:10 <shapr> syntaxfree: Do you think Haskell will help with the singularity?
04:37:44 <syntaxfree> I was with a friend who's going to grad school in computer science last night.
04:37:54 <shapr> What did he say about Haskell? :-)
04:38:02 <syntaxfree> I'm an economist, and a functional programming enthusiast. He's very skeptical about functional languages.
04:38:36 <shapr> Did you proselytize him?
04:38:42 <syntaxfree> Heck, he's skeptical about garbage collection.
04:38:49 <dons> what's to be skeptical about?
04:38:57 <dons> that's so fun :)
04:39:14 <shapr> Does he have better suggestions? I know region allocation is better than GC in many cases.
04:39:16 <syntaxfree> well, that it doesn't work as well as doing your malloc/free like God intented the Texan man to
04:39:22 <norpan> syntaxfree: what does he do with his garbage
04:39:32 <syntaxfree> Nothing. He's into graph theory.
04:39:44 <shapr> Sounds like he'd love Haskell.
04:39:59 <norpan> well, haskell does not necessarily imply garbage collection
04:40:04 <syntaxfree> He's had a good look into Scheme and Haskell in his undergrad years.
04:40:22 <syntaxfree> The only alternative-ish language I've seen him be enthusiastic about is Prolog.
04:40:38 <shapr> Did he have any concrete data on good or bad points of 'alternative' languages?
04:40:52 <syntaxfree> He's enthusiastic about Objective-C, mostly because it's what C++ should be.
04:41:20 <edwinb> Did you tell him it was a GCed language? :)
04:41:25 <syntaxfree> He's an algorithmic efficiency nut.
04:41:56 <syntaxfree> He doubts the scalability of lazily evaluated languages.
04:42:17 <syntaxfree> I got to impress him with Genera, the Lisp-based OS for Symbolics machines.
04:43:19 <syntaxfree> it was an informal encounter, not a religious war.
04:43:45 <edwinb> Does he have good reasons for his doubts though?
04:44:06 <edwinb> It's a shame when people dismiss languages without good technical reasons
04:44:51 <norpan> the only thing that counts are hard numbers
04:44:54 <syntaxfree> Remember, I can't go far with technical arguments in computer science.
04:44:56 <syntaxfree> I'm a hobbyist.
04:45:02 <syntaxfree> I'm enthusiastic about functional programming and AI.
04:46:00 <syntaxfree> So what generally happens is that I'm enthusiastic about ease of learning/use, expressive power,  yadda yadda, and he's enthusiastic about "oh, there's an O(1) algorithm for that".
04:46:31 <norpan> oh, an ordo-fanatic
04:47:39 <syntaxfree> He's skeptical about compilers "knowing" what to memoize.
04:47:51 <syntaxfree> Pretty much all I can say is "Oh, I've seen it do wonderful things". I have.
04:48:56 <edwinb> I guess if people enjoy spending ages writing, debugging and hand optimising their code, that's up to them...
04:49:05 <norpan> it's just a matter of finding examples of when the compiler screws up and either 1) fix the compiler or 2) complain about how bad the language is
04:49:07 <edwinb> ...I just like things to work.
04:49:38 <norpan> i have a collegue at work that spends far too much time on optimizing
04:49:43 <postman> I would like that nhc98 would work, but apparently it depends on lipgmp3, which isn't installable...
04:49:51 <norpan> i've told him to profile first...
04:50:33 <norpan> but he works like 12 hours per day so he gets as much work done as i do
04:50:45 <shapr> I probably don't spend enough time optimizing.
04:51:25 <norpan> he does stuff like unfolding loops manually
04:51:30 <norpan> pain in the ass
04:51:35 <syntaxfree> -funroll-loops? ; )
04:51:51 <shapr> norpan: In Haskell?
04:51:59 <norpan> no
04:52:01 <norpan> in c++
04:52:04 <norpan> and java
04:52:06 <mahogny> unrolling loops is fun o_O
04:52:24 <norpan> we don't use that much haskell at work unfortunately
04:52:26 <ValarQ> better to use inline asm :o)
04:52:31 <shapr> postman: Not installable where?
04:52:34 <norpan> he is one of the major opponents of haskell naturally :)
04:52:46 <shapr> Because it can unroll the loops for you?
04:52:49 <postman> shapr: Debian unstale
04:52:54 <postman> shapr: unstable, even
04:52:57 <shapr> Have you shown him Template Haskell and Igloo's paper?
04:53:03 <syntaxfree> http://www.funroll-loops.org
04:53:05 <lambdabot> Title: Welcome to Gentoo is Rice, the Volume goes to 11 here.
04:53:06 <norpan> shapr: well, the c++ compiler can unroll loops for you too :)
04:53:17 <shapr> Yeah, but TH gives you more control.
04:53:37 <shapr> This guy seems to want to write the compiler instead of the program.
04:55:02 <norpan> yeah
04:55:23 <norpan> we have some parts of the code in haskell, me and one other guy writes those
04:55:42 <norpan> maybe we are much more clever, but there rarely are bugs in our parts
04:55:53 <norpan> of course we quickcheck them to weed out bugs
04:56:08 <shapr> sensible
04:56:39 <edwinb> this sort of thing always reminds me of "Greenspun's Tenth Rule of Programming: any sufficiently complicated C or Fortran program contains an ad hoc informally-specified bug-ridden slow implementation of half of Common Lisp."
04:56:45 <ValarQ> norpan: well, i find it easier to create bugs in C than Haskell
04:56:56 <norpan> ValarQ: certainly
04:57:12 <norpan> esp. it's much easier to create latent bugs
04:57:32 <ValarQ> thats true
04:57:49 <postman> How can I see a trace of a function? I don't mean "Debug.Trace.trace".
04:58:14 <shapr> postman: scan instead of fold?
04:58:26 <dmhouse> postman: Try Hat.
04:58:28 <dmhouse> @where hat
04:58:28 <lambdabot> http://haskell.org/hat
04:58:47 <syntaxfree> um, that looks good.
04:58:54 <syntaxfree> @where my glasses
04:58:54 <lambdabot> I know nothing about my.
05:00:53 <postman> shapr: I don't understand.
05:01:07 <shapr> postman: If you have a fold, you could use scan instead? But that's only a special case.
05:01:13 <syntaxfree> @where understanding
05:01:13 <lambdabot> I know nothing about understanding.
05:01:18 <syntaxfree> Ok, I promise to stop.
05:01:20 * shapr goes into focus mode
05:01:57 <postman> shapr: I just want to see my factorial function (with primitive recursion) show a few expansions.
05:05:12 <shapr> One of Cale's professors had something that did that.
05:06:37 <postman> shapr: I think Hat can do it too.
05:06:50 <shapr> postman: You could try Vital http://www.cs.kent.ac.uk/projects/vital/ or Pivotal http://www.cs.kent.ac.uk/projects/pivotal/ ?
05:06:52 <lambdabot> Title: Vital homepage
05:07:23 <postman> Haskell support is badly broken on Debian Unstable
05:07:50 <postman> I can't install nhc98 nor hat.
05:11:43 <shapr> postman: It works fine for me.
05:11:51 * shapr checks again
05:12:07 <postman> shapr: Can you install libgmp3?
05:12:25 <postman> shapr: Maybe I need to do a "smart" upgrade then.
05:12:35 <shapr> postman: No, you're right.
05:13:11 <shapr> Sounds like the nhc98 package needs fixing. File a bug?
05:14:00 <postman> shapr: It holds for everything depending on libgmp3. (which is a lot)
05:14:15 <postman> shapr: It has been broken for a _long_ time.
05:16:14 <postman> Hat doesn't compile.... /hat-2.04/lib/ix86-Linux/config:11: *** missing separator.  Stop.
05:19:56 <shapr> Is ghc/compiler/main/Config.hs generated by configure?
05:21:02 <postman> shapr: no
05:21:15 <shapr> postman: Have you worked on GHC before?
05:21:21 <postman> shapr: I already fixed this bug, but apparently it depends on package lang.
05:21:25 <shapr> oh
05:21:39 <postman> shapr: Which isn't in ghc-6.5
05:21:55 <shapr> postman: Who are you?
05:22:04 <postman> shapr: It seems all tool only support the latest stable release.
05:22:42 <postman> tools, even
05:26:49 <postman> I was mistaken: it doesn't build with ghc-6.4.2
05:26:57 <postman> Same config error.
05:27:49 <postman> Never mind
05:30:36 <postman> It wants to touch ~/hat-2.04/targets/ix86-Linux/obj/hattrans//usr/bin/ghc-6.4.2
05:31:15 <postman> Why do you recommend this, when it's full of bugs?
05:31:27 <ndm> postman: hat -AT- haskell.org
05:31:40 <ndm> postman: email the mailing list, and demand that someone fixes the bugs!
05:32:26 <ndm> I know its got many bugs in, but it is the best debugging tool for haskell
05:32:44 <ndm> there are three solutions: write something better, fix hat, or don't debug
05:32:55 <shapr> postman: How about QuickCheck?
05:33:00 <ndm> unfortunately most of Haskell seems to go for number 3, i am trying to persude people to do 2
05:33:34 <shapr> I'm usually in favor of option three, use QuickCheck or HUnit for testing instead.
05:33:36 <shapr> But that's just me.
05:33:47 <postman> ndm: Most people expect that things Magically Work Without Every Paying Anyone.
05:33:52 <shapr> On the other hand, I've never really used a debugger, so maybe I don't know what I'm missing.
05:33:53 <norpan> tracing is just one form of debugging
05:33:53 <postman> ndm: That's the root cause.
05:34:02 <norpan> and it's less needed with haskell
05:34:02 * JKnecht has reproduces this error ...
05:34:06 <ndm> postman: you don't have to pay, you just have to report...
05:34:15 <JKnecht> s/reproduces/reproduced/
05:34:16 <norpan> as you can quickcheck/call subfunctions/...
05:34:20 <ndm> shapr: hat-stack is just beautiful
05:34:37 * psnl wonders if he can get a degree based on bugfixing hat
05:34:40 <ndm> hat-cover works great in combination with QuickCheck/HUnit to test what you have actually checked
05:34:47 <ndm> psnl: i'd give you a degree for it!
05:37:03 <JKnecht> the normative question is which of: 'this just another piece of b0rken punk ass shit?' or 'this is a community verified tool whose usefulness I should restore' is the correct response?
05:38:32 <shapr> Haskell doesn't have much in the way of punk ass shit.
05:38:54 * shapr tries to think of a crappy Haskell project...
05:39:09 <ndm> JKnecht: unfortunately hat is both b0rken and beautiful
05:39:26 <shapr> Hm ... GpH, GdH and GUM never seem to materialize.
05:39:31 <shapr> That's about as close as it gets.
05:39:38 <JKnecht> Acknowledged.
05:40:30 <edwinb> There must be plenty that aren't publicised...
05:41:12 <psnl> edwinb: can I take the easy shot? ;-)
05:41:19 <shapr> I think no one is motivated to make crappy Haskell projects.
05:41:23 <shapr> There's no money in it.
05:41:29 <shapr> jyp: Hey, want to write another TMR article?
05:41:33 <edwinb> psnl: :-P
05:41:46 <shapr> edwinb: Want to write a TMR article on deptypes?
05:41:48 <jyp> shapr: I'm busy with the icfp contest atm
05:41:51 <jyp> talk to you later
05:41:54 <edwinb> It's hard to set out to make something crappy ;). It just evolves that way...
05:41:54 <shapr> jyp: ok
05:42:09 <edwinb> shapr: I want to have written one. It's the bit in between that is hard to find time for...
05:42:10 <shapr> edwinb: What about a simple intro to deptypes?
05:42:28 <edwinb> I should do that really, yes. It would be useful.
05:42:54 <shapr> For example, "A short introduction to dependent types for Haskell programmers, or why you might like Epigram."
05:43:16 <edwinb> I'd quite like to have something explaining the limits of GADTs and why dependent types can go much further.
05:43:53 <shapr> You could do comparisons like "HaskellDB uses several tricks for length limited lists. Value types are directly expressible in a dependently typed language..."
05:44:23 * edwinb takes decisive action and adds it to his TODO list...
05:44:27 <shapr> haha
05:44:33 <edwinb> whether that means anything in practice remains to be seen ;)
05:45:04 <shapr> edwinb: Well, start writing the article on the wiki, then everyone can see your public progress.
05:45:07 <shapr> That motivates me..
05:45:12 <shapr> "Embarassment oriented programming"
05:45:21 <edwinb> heh
05:45:29 <psnl> edwinb: so, a 1% increase in length of list, then?
05:45:48 <edwinb> In the "stuff to write" subsection, 20%...
05:46:01 <postman> Vital is impressive, but again not bug free.
05:46:13 <shapr> postman: Are you from .de?
05:46:54 <postman> shapr: I might
05:46:55 <ndm> shapr, the TMR wiki?
05:47:10 <shapr> ndm: Sure, good place to start.
05:47:17 <shapr> Do you have access already?
05:47:37 <shapr> I could go ahead and put up the sound file of SPJ saying "Haskell"
05:48:51 <ndm> shapr: yeah, i do
05:48:59 <dmhouse> ndm: Ooh, I'd like to hear that
05:50:04 <dmhouse> Do you stress the second syllable or not?
05:50:28 <edwinb> First
05:50:39 <dmhouse> I'm not sure whether it's "Hask-ell" or unstressed, "Haskul". The latter serves to distinguish it more from Pascal.
05:50:52 <edwinb> Many things distinguish it from Pascal ;)
05:50:53 <shapr> #haskell has wondered that for years.
05:50:54 <shapr> Now we know!
05:51:10 <dmhouse> Where's the file?
05:51:53 <shapr> http://www.haskell.org/tmrwiki/IssueSix
05:51:54 <lambdabot> Title: IssueSix - TmrWiki
05:52:39 <shapr> grr, I have to restart emacs to change smtpmail-default-smtp-server
05:52:41 <shapr> brb
05:53:21 <dmhouse> Aww, it'd be better if it were the full sentence, "Hi, I'm Simon Peyton-Jones, and I pronounce Haskell, 'Haskell'."
05:54:00 <edwinb> he says it in a sufficiently authoritative way though...
05:54:08 <ndm> i always have great problems on the phone going through my CV
05:54:15 <shapr> dmhouse: Yeah, i wanted that too.
05:54:17 <ndm> someone always wants to check the "Pascal" box...
05:55:13 <shapr> dmhouse: I say it the wrong way - http://www.scannedinavian.com/~shae/shapr-haskell.wav
05:55:44 <postman> I think Vital would be in the category: Nice try.
05:55:56 <shapr> Pivotal is the sequel.
05:56:42 <Syzygy-> http://www.scottaaronson.com/blog/2006/07/and-they-say-complexity-has-no.html
05:56:44 <lambdabot> Title: Shtetl-Optimized: And they say complexity has no philosophical implications
05:57:56 <gds> @where pronunciation
05:57:56 <lambdabot> I know nothing about pronunciation.
05:57:58 <gds> @where+ pronunciation http://www.haskell.org/tmrwiki/IssueSix
05:57:59 <lambdabot> Done.
06:00:06 <shapr> Hm, who can I pick on for TMR articles?
06:01:44 <dmhouse> Hrm.
06:01:49 <dmhouse> What do you want writing about?
06:01:54 <shapr> ProfTeggy: Want to write something about queries?
06:01:58 <petekaz> shapr: you are going to start it up again?
06:02:00 <shapr> dmhouse: Anything Haskell related.
06:02:04 <shapr> petekaz: I'd like to...
06:02:13 <dmhouse> (TMR's a great project, by the way, I'd love to see it flourish.)
06:02:16 <petekaz> Nice!
06:02:18 <shapr> petekaz: Want to write an article?
06:02:28 <shapr> TMR will flourish only if I can find enough authors.
06:02:48 <petekaz> I would if I had something to write about.  I'm a complete newbie still trying to grok monads etc ...
06:02:56 <shapr> I spent a lot of time hunting authors and then later poking them to finish on time.
06:03:17 * Syzygy- has seen monads used by operad theorists.. Still trying to grok them in the programming context.
06:03:26 <shapr> petekaz: That's perfect, you can describe what's different about Haskell as compared to the languages you already know.
06:03:29 <petekaz> I would think in today's world of bloggers that it may be easier to find content writers.
06:03:31 <postman> I know a good topic for TMR: fixing a bug in some piece of software. This will give embarrassment to the original writers (motivating to release better software next time), and it fixed a bug in the process.
06:03:38 <shapr> petekaz: It's harder than you might think.
06:03:46 <shapr> postman: That's happened already.
06:03:52 <shapr> postman: But feel free to write an article.
06:04:29 <postman> shapr: Cool, that it did.
06:05:10 <Igloo> I'm not sure embarassing volunteers is a good way to get more useful output from them
06:05:13 <shapr> True that
06:05:41 <shapr> In the world of open source, something that I can fix is better than nothing at all.
06:06:17 <shapr> dmhouse: What do you want to write about?
06:06:22 <shapr> hej lhz
06:06:28 <dmhouse> shapr: I'm thinking.
06:06:37 <lhz> hej
06:06:52 <dmhouse> shapr: I'll check out the previous articles.
06:06:59 <petekaz> shapr: It would be cool to get one of the haskell ICFP teams to explain how on earth they could have lost to a bunch of java programmers called "Team Smartass".
06:07:00 <ndm> shapr, one thing i think would be great for TMR is project reports from existing projects
06:07:12 <dons> petekaz: i think its a conspiracy
06:07:20 <ndm> just future goals, whats being planned etc, a nice way to keep up to date
06:07:39 <shapr> ndm: How about code tutorials for libraries? Like, how to use ByteString in a simple app?
06:07:42 <petekaz> :-)
06:07:48 <ndm> shapr, also good :)
06:07:58 <shapr> That would be a constructive way to do project reports.
06:08:07 <shapr> You wouldn't need more than a page or two.
06:08:28 <shapr> ndm: Like, how to use hoogle from the ghci command line?
06:08:47 <ndm> shapr, yeah, that could be useful (its on the hoogle wiki though)
06:08:49 <shapr> I could write a tutorial for Hope.
06:09:00 <ndm> not that i ever have used it, someone else did the instructions
06:09:01 <JKnecht> how about an advisory/list on packages such as Hat which although useful/essential don't build with current ghc?
06:09:10 <shapr> JKnecht: That's a good idea, want to write it?
06:09:17 <ndm> JKnecht: better just to fix up Hat :)
06:10:11 <JKnecht> i'd rather make a shell service available at a price.
06:10:26 <JKnecht> with working versions of 'everything'.
06:11:53 <ndm> i want to do that for windows, with my windows and haskell project
06:11:59 <ndm> apart from the charging bit...
06:13:40 <postman> Can I see somewhere what languages everyone is using? Or did you just ask about Team Smartass?
06:14:15 <JKnecht> actually, when/if I do make such services available, even as a public/community service, a small charge will be required to access, for authentication purposes.
06:14:44 <JKnecht> like say 0.42 euro.
06:15:00 <dmhouse> postman: Last year a team by the same name was using Java.
06:16:50 <postman> JKnecht: What exactly do you mean by a shell service (I know what a shell service is, but I see no use for that in this context)?
06:17:13 <dmhouse> shapr: Have you got a good example of a 'typical' TMR article? I'm looking through Oleg's but it looks a bit beyond what I could write and it reads more like an actual paper anyway.
06:17:19 <petekaz> There are a lot in the Java circles that have started using Ruby, so it wouldn't surprise me if that was their language choice either.
06:20:52 <JKnecht> postman: a unix shell + X service (a Windows version is possible too) with all the Haskell tools in working order, e.g. Hat, Cabal, Hxt, usw.
06:21:33 <shapr> dmhouse: Check out the FrontPage, look at the back issues.
06:21:58 <petekaz> shapr: I spent the last few days learning about concurrency.  This included verifying that OS threads were started for each 'safe' FFI call (I called out to sleep(3) and verified the # of os threads running with ps), and then writing a simple job dispatcher that will fork off no more than N tasks at a time, starting a new task as soon as one finishes, etc ... to compare to one I wrote in erlang.
06:22:17 <shapr> JKnecht: I'd pay for shell access to a GHC build box with 8+ cores.
06:22:35 <shapr> petekaz: You wrote this in Haskell?
06:22:44 <postman> JKnecht: so you want to let people login there and compile their programs on that shell?
06:22:55 <petekaz> Although, this would be written from a beginner's point of view as I'm still trying to grok haskell.
06:23:06 <postman> in, even
06:23:14 <shapr> petekaz: That's perfect! Beginners are one of the audiences for TMR.
06:23:17 <petekaz> shapr: yes.
06:24:02 <shapr> petekaz: Create a user account - http://www.haskell.org/tmrwiki/UserPreferences tell me what name you used, (FirstLast is common) and put your article up there.
06:24:03 <lambdabot> Title: UserPreferences - TmrWiki
06:24:23 <shapr> One of the nice things about a wikizine is that you can quickly get feedback from other authors, the editor, etc.
06:24:46 <shapr> You can set your article to be only readable by other authors, but I usually make my world readable and hope for feedback.
06:25:00 <JKnecht> postnam: right, concept would give a 'complete' dev env, with db access and the like which you could then deploy on your own servers without the expense and hassel of dev env building.
06:25:11 <postman> I don't think it's practical to let 10 users work on the equivalent of one typical desktop machine.
06:26:09 <shapr> postman: Why do you think that?
06:26:16 <JKnecht> your assumption(s) about user load to fielded servers is unwarranted/premature.
06:26:32 <petekaz> shapr: Ok, my name is PeteKazmier.  I'll start jotting down my thoughts on what I have learned in a tutorial-like manner for other beginners.
06:26:38 <JKnecht> I can simply limit the load to what I can handle.
06:26:47 <postman> shapr: I worked on a project in C++ where we waiting all day long for stuff to compile.
06:27:04 <postman> shapr: Note that this was on a LAN.
06:27:24 <shapr> postman: Have you tried to combine distcc and cachecc?
06:27:38 <ValarQ> postman: thats when you install make
06:28:07 <postman> shapr: no, that didn't exist or we didn't know of it's existence at that time.
06:28:46 <petekaz> shapr: any chance of updating to the latest version of moinmoin?  They have significantly improved the CSS.
06:28:54 <shapr> A combination of distcc and compilercache can dramatically speed up compiles.
06:28:56 <postman> ValarQ: we used all the autotools, didn't include to many headers, etc.
06:29:45 <shapr> petekaz: Maybe... I've been talking to Yale (haskell.org's host uni) about switching to debian/unstable. Right now they're using a seriously antique version of RHEL and it's a pain to do any sort of sysadmin there.
06:29:59 <ValarQ> postman: did you recompile all sources a lot?
06:30:21 <shapr> I'm in charge of spam filtering for haskell.org, and I haven't been able to do anything because their postfix, perl, etc is very old.
06:31:15 <shapr> Alternatively I could move TMR to my server and publish static pages on haskell.org
06:31:27 <postman> ValarQ: Since everyone was touching files they were working on and everyone wanted to test whether it worked, and the machine had only 512 MB of memory, it started to swap.
06:32:53 <postman> Anyway, another solution is to have a program lying on some fixed location that gives you a complete installation of all haskell tools.
06:33:08 <shapr> If you have a single build box, wouldn't it make more sense to schedule one compile after the other?
06:33:14 <JKnecht> I think a current P4 box with a couple Gig RAM and 10K RPM disk could serve 10 users but that's not the approach I'd take anyway; would present all servers as a single VM which users shared.
06:33:57 <shapr> My Nokia 770 with 225MHz ARM cpu and 64mb of ram serves multiple users for command line tasks.
06:34:04 <shapr> Wouldn't want to run gcc on it though.
06:35:14 <postman> shapr: In theory you are right, in practice it wasn't an option. Remember that we had to complete a project (not implement some scheduler for a compiler).
06:36:07 <shapr> Scheduling a compile to happen one after the other is as simple as making a lockfile that's checked by a cron job.
06:36:17 <shapr> It'd take about thirty seconds to do that in a shell script.
06:37:00 <ValarQ> connecting inotify with make might be something :)
06:37:08 <shapr> Yeah, I want to do that for zero-button unit testing.
06:37:13 <shapr> But I haven't gotten to it yet.
06:37:16 <postman> shapr: a lockfile?
06:37:58 <ValarQ> my current machine is also a quite good solution against swaping compilations
06:38:02 <shapr> postman: Assume that you keep all your sources in CVS or so. The build box will check out the latest sources and run a compile.
06:38:11 <ValarQ> SMP machine with 2GB of RAM :)
06:38:19 <shapr> postman: Your developers check in new code while the compile is going on.
06:38:27 <mrchebas> hi everyone, sorry for the hurry, but i have an urgent problem concerning System.Process.runInteractiveProcess
06:38:39 <postman> shapr: That was not the situation. The situation was people first testing whether something worked and then checking it in.
06:38:40 <ValarQ> mrchebas: shoot
06:38:46 <mrchebas> neither in ghc 6.4.1 nor 6.4.2 i can get it to work with "cat"
06:38:47 <shapr> postman: They could send an email, click a browser button, or whatever... as long as a file is created somewhere that's named "compile again"
06:39:14 <mrchebas> with other processes ("ls") i can receive output but i cannot find the way sending input
06:39:39 <shapr> postman: In that case, you needed darcs desperately. With darcs you could have put your changes into a dev repo, and only put them into the 'real' repo when the code passed all the tests.
06:39:49 <postman> shapr: Ok, yes, that wouldn't be too hard. At that time, we were young and many of us worked for the first time with *nix.
06:40:21 <postman> shapr: darcs wouldn
06:40:39 <postman> shapr: 't have helped because not all the dev tools could be installed
06:40:43 <dmhouse> mrchebas: Why don't you use, say, readFile?
06:40:55 <dmhouse> mrchebas: And to send input, you use hPutStr.
06:41:30 <shapr> postman: This sounds like a problem with many sides... I'll go back to writing Haskell code for money :-)
06:41:30 <dmhouse> (in, out, err, _) <- runInteractiveCommand "cat"
06:41:38 <dmhouse> hPutStr out "whatever"
06:41:41 <postman> shapr: Your other solution could have helped, but it still would be slow. OTOH, I think that JKnecht has a point.
06:42:11 <postman> Still I would prefer the script solution.
06:42:27 <dmhouse> Oh, runInteractiveProcess. Well, that's roughly the same, but with different parametrs.
06:42:35 <shapr> The lock script would let you run each compile in the shortest time possible.
06:42:55 <postman> shapr: True, but still slow.
06:43:08 <shapr> compilercache :-)
06:43:23 <postman> shapr: was in beta, I think in that year.
06:43:25 <shapr> apt-cache show distcc compilercache
06:43:40 <postman> shapr: I am familiar with it, since Gentoo.
06:44:02 <mrchebas> dmhouse: you have the descriptors mixed up, but i tried the same idea (hPutStr inp "whatever") but cat does not seem to receive it
06:44:14 <shapr> mrchebas: Popen
06:44:33 <dmhouse> mrchebas: Still, are you sure you can't just use readFile/writeFile?
06:44:41 <kpreid> mrchebas: perhaps you need hFlush?
06:44:42 <dmhouse> @hoogle readFile
06:44:43 <lambdabot> Prelude.readFile :: FilePath -> IO String
06:44:43 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
06:44:43 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
06:44:48 <dmhouse> @hoogle writeFile
06:44:48 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
06:44:49 <lambdabot> System.Win32.File.c_WriteFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
06:44:49 <lambdabot> System.Win32.File.win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
06:44:51 <shapr> Lemmih: Do you know if ghc/compiler/main/Config.hs is created by configure?
06:45:09 <postman> shapr: What do you think of an Instant Haskell Development Environment program that would automatically install all the latest stable Haskell libraries (for example in a cronjob)?
06:45:28 <mrchebas> kpreid: you're right, buffering might be biting me
06:45:53 <shapr> postman: cabal-get is basically apt-get for Haskell. That'll fix most of the current problems.
06:45:55 <dmhouse> @hoogle hFlush
06:45:56 <lambdabot> IO.hFlush :: Handle -> IO ()
06:46:02 <dmhouse> mrchebas: Then that might help.
06:46:05 <shapr> postman: cabal-get is xerox' Summer of Code project...
06:46:09 <shapr> xerox: w00! Go Paolo!
06:46:21 <shapr> xerox: Any progress today?
06:46:27 <shapr> @seen xerox
06:46:28 <lambdabot> xerox is in #oasis, #unicycling, #perl6, #haskell.it, #haskell-overflow, #haskell-blah and #haskell. I last heard xerox speak 4 hours, 37 minutes and 57 seconds ago.
06:46:33 <shapr> He must be working :-)
06:46:39 <mrchebas> dmhouse: thanks, i 'll try buffering now
06:46:46 <mrchebas> or disabling it
06:47:22 <postman> shapr: Yeah, so will I.
06:47:57 <jgrimes_> When do you generally use Happy instead of Parsec?
06:48:28 <mrchebas> thanks dmhouse and kpreid, disabling buffering solved my problem
06:51:07 <dons> jgrimes_: when you feel the need for speed
06:51:16 <dons> or you already have a yacc grammar to translate
06:51:19 <shapr> I should setup my dual athlonmp 1.5GHz for building GHC. It's much faster.
06:52:40 <jgrimes_> dons: ok, so it is faster then?
06:52:55 <dons> yes. it uses normal tabular methods, like yacc
06:53:03 <dons> ghc uses happy, for example
06:53:04 <jgrimes_> dons: it certainly was faster for what I've been doing
06:53:27 <jgrimes_> dons: but I didn't know if that was perhaps my ignorance of some of parsec's abilities
06:53:32 <jgrimes_> (not that it isn't ;) )
06:54:39 * ValarQ still wonders how he should get parallel compiles with cabal
06:55:15 <Lemmih> shapr: It is.
06:55:58 <shapr> Lemmih: Do I need to change something to get the cProjectPatchLevel value to change?
06:57:42 <kuribas> Would it be possible to do type inference using a logic programming language?
06:57:59 <ndm> kuribas: yes
06:57:59 <shapr> yup
06:58:13 <shapr> Haskell's typechecking is a simple logic programming language.
06:58:14 <ndm> and in fact, it almost is with the typeclass stuff
06:58:30 <ndm> although personally i want to do type checking with a constraint solver
06:58:49 <shapr> Look at Martin Sulzmann's Chameleon for example. He does all of his typechecking with constraint handling rules.
06:59:09 <shapr> ndm: Are we doing this in stereo? Funny how we went along the same paths :-)
06:59:13 * shapr boings
06:59:28 * shapr wonders if he can derive this Binary instance automatically.
06:59:40 <kuribas> Oh, nice.  I was wondering if it would be easier to implement type inference using Curry for example.
06:59:42 <ndm> shapr: is it Binary for serialisation?
06:59:48 <shapr> Yeah
06:59:57 <ndm> please, please, please, add it to GHC :)
07:00:13 <ndm> I have at least 3 apps wehre I am doing read/show to save data to disk
07:00:23 <ndm> if I had binary, it would be 1000's of times faster :)
07:00:25 <shapr> It seems that GHC already does Binary derivation via DrIFT.
07:01:11 <shapr> Lemmih: Any idea if Binary stuff like BinIface.hs is automatically derived/generated at compile time?
07:02:13 <Lemmih> shapr: It was generated once, I think.
07:02:15 <shapr> Ah
07:02:20 <shapr> It should be generated everytime...
07:03:00 * shapr files a wishlist bug
07:03:17 <shapr> Poo, I don't have a login.
07:03:27 * shapr boings happily.
07:03:29 <shapr> This is fun!
07:03:30 <Lemmih> It should?
07:03:32 <dmhouse> shapr: GHC hacking?
07:03:53 <shapr> dmhouse: How did you guess?
07:04:10 <dmhouse> ;) This something to do with your GHC job application?
07:04:32 <shapr> Lemmih: Yeah, anything that can be generated should be generated. That way improvements in the generation process give benefits without added work.
07:04:36 <shapr> At least, that's my opinion.
07:04:52 <ndm> I would love Haskell' to have deriving Binary build in
07:05:55 <norpan> which Binary?
07:06:09 <ndm> norpan: any, provided write == read, who cares!
07:06:19 * shapr agreees
07:06:32 <shapr> SerTH works nicely, but it's GHC specific.
07:07:14 <norpan> well, the first thing is to standardize a Binary
07:07:38 <norpan> is that done in haskell'?
07:07:44 <ndm> thats a good plan too, binary support is something sadly lacking in Haskell
07:07:57 <ndm> having to use extensions just to write a binary file is not good
07:08:30 <shapr> What about something like Serialize for Haskell' ? Then Binary could be optional, and the simple solution would use Read/Show
07:08:57 <ndm> shapr: it would be nice if Serialize worked across all compilers
07:09:00 <norpan> ndm: well, if you don't care about the format, you can use Read/Show
07:09:08 <ndm> norpan: yes, and wait, and wait, and wait
07:09:11 <norpan> so that's why i'm asking which Binary
07:09:13 <ndm> norpan: and be strict
07:09:26 <ndm> which is actually a more severe problem for me
07:11:14 <norpan> maybe it should be merged with the Storable stuff
07:11:18 <shapr> hm
07:11:31 <norpan> although that is for a different purpose
07:11:55 <musasabi> There is no portable solution for handling cycles.
07:12:09 <musasabi> Which has been discussed in the deepSeq discussion.
07:12:12 <norpan> sure
07:12:30 <norpan> but non-cyclic data should be ok
07:12:32 <musasabi> Thus a portable SerTH is quite impossible.
07:12:45 <norpan> which is sufficient for most uses
07:13:35 <SamB_XP> cycles are not good for serialization period...
07:14:10 <musasabi> shapr: a library to make it easier to derive instances with TH could be one solution.
07:14:32 <shapr> TemplateDrift... hmm
07:15:06 <dons> musasabi: hi!
07:15:24 <dons> long time no irc :)
07:15:37 <ndm> but if Template Haskell doesn't make it in h' (which it won't), then we still have no 'd serialisation
07:16:07 <musasabi> most class instances seem to have functions of the form: "foo (C a1 a2 .. aN) = do foo a1; foo a2; ...; foo aN;", "bar = do a1 <- bar; a2 <- bar; ...; aN <- bar; return $ C a1 a2 ... aN" and a few others.
07:16:19 <musasabi> dons: hello :-)
07:20:22 <shapr> What's the trick to make tags for the whole GHC repo and all underlying repos?
07:20:28 <norpan> it would be great to have a standard binary representation for haskell data structures
07:20:39 <norpan> and a deriving read/write
07:20:48 <norpan> non-cyclic, that is
07:22:18 <Lemmih> shapr: Is there one?
07:22:53 <shapr> make tags doesn't work in the top level directory.
07:24:16 <dons> shapr, here's a script http://www.cse.unsw.edu.au/~dons/tmp/tag-fptools
07:24:22 <dons> you want a tags file for your editor?
07:24:33 <dons> and here's the tags file: http://www.cse.unsw.edu.au/~dons/tmp/tags
07:29:51 <ibid> hrm, it's kinda funny that ghc6 indirectly depends on hugs in debian
07:30:03 <nothingmuch> how embeddable is ghc?
07:30:05 <ibid> (sid)
07:30:11 <nothingmuch> shapr: last.fm has a haskell group. Please join =)
07:30:21 <nothingmuch> s/ghc/ghc output/;
07:30:45 <ndm> ibid: though which packages?
07:31:03 <ibid> ndm: haskell-utils
07:37:13 <shapr> nothingmuch: Wow, I had no idea.
07:37:52 * shapr searches for htags
07:38:31 <shapr> dons: Can I replace htags with hasktags?
07:40:55 <dons> shapr: not sure. htags is on the haskell.org site
07:41:00 <dons> let me see if i've got it somewhere
07:42:37 <dons> ah, i think 'htags' is my name for tagsh
07:42:56 <dons> or possibly it is hasktags
07:43:02 <dons> yeah, i think you can just use hasktags
07:44:02 * dons `flip` (light off)
07:44:52 * shapr tries that
07:49:02 <shapr> nothingmuch: Paul Hudak does Jazz. That should be one of the artist connections.
07:49:48 <nothingmuch> shapr: hmm?
07:50:03 <dmhouse> Paul Hudak was one of the people on the original Haskell committee.
07:50:08 <nothingmuch> oh
07:50:12 * nothingmuch is a haskell idiot
07:50:15 <shapr> Oh, Conal Elliot does Jazz also.
07:50:16 <dmhouse> (Along with such household names as Simone Peyton-Jones.)
07:50:22 <dmhouse> *Simon. Oops :)
07:50:27 <gaal> shapr: looking for something that does haskell tags? I have a patch to exuberant ctags
07:50:35 <gaal> somewhere :)
07:50:37 * dmhouse goes GHC-exploring
07:50:40 <syntaxfree> what are tags?
07:50:43 <shapr> Whoa, check this out - Paul Hudak wrote a research paper on modelling jazz improvisation - http://citeseer.ist.psu.edu/156920.html
07:50:43 <dmhouse> Hrm, where's raise# defined?
07:50:45 <shapr> That's seriously badass.
07:50:52 <norpan> exuberant...
07:51:17 <gaal> syntaxfree: thingies your editor can use to let you hop from a name of a function to its definition.
07:51:51 <gaal> http://gaal.livejournal.com/161104.html
07:52:34 <jgrimes_> shapr: wow that is pretty awesome
07:52:38 <edwardk> didn't hudak make some sort of april fools joke that he was going off to become a jazz musician because the pressure of working on haskell was too much? so its not surprising to see he has some musical connection
07:52:50 <shapr> edwardk: Yes, he wrote that.
07:52:54 <shapr> He already does jazz.
07:52:55 <jgrimes_> well, he also wrote Haskore
07:53:01 <shapr> I'm trying to learn to play sax.
07:53:04 <shapr> My gf is teaching me.
07:53:30 <shapr> She's very good at saxophone, both alto and tenor.
07:53:43 <shapr> er, soprano & tenor?
07:53:48 <Cale> heh, I misread that at first
07:53:51 <shapr> The straight one and the smallest bendy one :-)
07:54:04 <edwardk> again with the misreading =)
07:54:06 <gds> shapr: soprano and alto then :)
07:54:08 <sjanssen> shapr: soprano and alto
07:54:22 <shapr> Thanks :-)
07:54:58 <shapr> Last time she played, they had a monstrous clarinet... bass?
07:55:11 <shapr> They also had one of the monster saxophones as well.
07:55:41 <shapr> I got to meet Tim Hagans after the concert. That was neat.
07:55:43 <gds> baritone? With the curley bit at the top?
07:55:53 <gds> Those are very cool....
07:56:01 <dmhouse> Most of GHC's sources are Haddockised. Is the API documentation available anywhere?
07:56:05 <sjanssen> gds: bass saxophones are even cooler
07:56:15 <gds> Don't think I've ever seen one...
07:56:18 * gds googles...
07:56:54 <shapr> Tim is a really cool guy, but his Swedish is possibly the worst I've ever heard.
07:57:02 <shapr> I cringe every time he speaks Swedish.
07:57:24 <shapr> Still, he gets his point across, so no one minds.
07:57:32 <gds> http://robotics.caltech.edu/~kj/jay/images/photos/stoiccontra.jpg # big...
07:57:45 <dmhouse> They don't seem to be linked to from the GHC wiki. Anyone built them?
07:57:48 <shapr> The one at the concert was not that large.
07:57:51 <ndm> dmhouse: they aren't haddockised
07:58:04 <ndm> dmhouse: try compiling the types stuff, loads of haddock parse errors
07:58:14 <shapr> dmhouse: You could clean it up?
07:58:19 <dmhouse> Ah, okay
07:58:20 <ndm> i was trying to build hoogle documentation for GHC
07:58:32 <ndm> dmhouse: should be doable, i started and got bored quite quickly
07:58:58 <shapr> With all that CS research, you'd think citeseer would already be distributed.
07:59:13 <shapr> Salut kowey, oh ye of the non-french-ness.
07:59:27 <shapr> Oh ye of the spacesuits and spacestations monad tutorial.
07:59:28 <psnl> shapr: yeah, a better citeseer would be cool
07:59:39 <dmhouse> kowey!
07:59:42 <shapr> kowey: That's popular on del.icio.us, btw.
07:59:54 <dmhouse> shapr, have you seen the nuclear waste one?
07:59:58 <kowey> hi all
07:59:58 <lambdabot> kowey: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:00:06 <shapr> No?
08:00:24 <dmhouse> shapr: Ah, it's on the wikibook. You should check out the wikibook by the way, some really great stuff on there.
08:00:28 <dmhouse> </shameless plug>
08:00:38 <edwardk> ndm: what does hoogle use to search the source?
08:00:50 <ndm> edwardk: haddock -hoogle output
08:00:54 <kowey> dmhouse: exciting news for the wikibook... i did indeed speak with hal daume
08:00:56 <edwardk> ndm: or do you just generate it with haddock.. ahh
08:01:05 <shapr> dmhouse: If it has some way for me to edit it via emacs, I'll go in and hack on it.
08:01:10 <ndm> edwardk: but I might be moving to ghci :b, not decided yet
08:01:17 <dmhouse> shapr: I'm working on that right now :)
08:01:18 <edwardk> heh
08:01:29 <dmhouse> shapr: At the moment, the big plan is as follows:
08:01:35 <dmhouse> 1) Use wikipedia-mode for font-locking etc.
08:01:35 <kowey> dmhouse: and he's ok with the idea of letting us use yaht - i wouldn't act until he sends me the tex though (i.e. till it be official)
08:01:56 <dmhouse> 2) Use MVS, which is a clientside MediaWiki interaction program
08:02:01 <dmhouse> 3) Write VC bindings for MVS.
08:02:10 <edwardk> any chance i might be able to put in a request to be able to link to the original source file where the definition is made? some times reading the definition for a function answers a llot of questions the haddock documentation doesn't.
08:02:22 <dmhouse> kowey: Awesome :)
08:02:58 <kowey> also, dmhouse: i use omnigraffle for my diagrams... i realise it's non-free, and the fact that it's mac-only makes life difficult, but i haven't found anything nearly as easy to use yet
08:03:08 <kowey> (in response to your question from days back)
08:03:12 <dmhouse> Yeah.
08:03:29 <dmhouse> Fun. I'll investigate free, Linux-based options then :)
08:03:35 <ndm> edwardk: thats a feature of the newest version of haddock
08:03:39 <ndm> @where FilePath
08:03:39 <lambdabot> http://darcs.haskell.org/~lemmih/FilePath
08:03:46 <ndm> @where System.FilePath
08:03:46 <edwardk> ndm: rock =)
08:03:46 <lambdabot> I know nothing about system.filepath.
08:04:05 <ndm> edwardk: I used it for my filepath module, and hopefully someone will do it to the documentation available sometime
08:04:23 <dmhouse> kowey: Great stuff. What's Hal Daume like?
08:04:45 <edwardk> now is it the same 'link to source directory' thing? or is it a link to the particular file?
08:05:02 <kowey> dmhouse: he seems quite friendly... we chatted briefly about his choice of o'caml for some stuff
08:05:09 <ndm> edwardk: http://www-users.cs.york.ac.uk/~ndm/projects/filepath/System-FilePath.html - thats an example of using it
08:05:12 <kowey> dmhouse: if i understand him correctly, he might be coming back to the fold
08:05:26 <dmhouse> Cool :) I want to see YAHT finished.
08:05:29 <Syzygy-> What kind of diagrams, precisely?
08:05:33 <edwardk> ahh nice
08:05:36 <ndm> edwardk: but thats with HsColour as well, and my patches into HsColour, so you can't quite get that yet (but i have submitted the patches)
08:05:37 <edwardk> thats what i wanted =)
08:05:42 <shapr> Hal used to hang out on #haskell.
08:05:43 <edwardk> doh
08:05:44 <kowey> dmhouse: hence the wiki, we joked
08:05:45 <ndm> me too, its really useful
08:05:46 <dmhouse> shapr: Check out 'To do' if you want to contribute.
08:05:58 <ndm> actually, just checked, the patches are now in HsColour
08:06:02 <dmhouse> And probably 'Notes for contributors' too.
08:06:14 <dmhouse> I'll hack together some notes for using Emacs with MediaWiki;
08:06:15 <ndm> so with HEAD of HsColour and Haddock you can get that documentation
08:06:20 <shapr> dmhouse: thanks!
08:06:42 <edwardk> woot =)
08:07:55 <ndm> edwardk: of course with Hugs, :f map gets you the definitions, which is very handy
08:10:26 <kowey> syzygy- : we were talking about the diagrams on the wikbooks darcs tutorial (as well as the monads and arrows stuff)
08:12:47 <Syzygy-> Right. *browse* Nope - this doesn't seem to be the place to wave Taylor or xy-pic around.
08:15:42 <xerox> shapr: you can have ghci on acid now (thanks for the hasktags pointer, it's making my life with cabal a lot easier. It's the first time I hack on a big piece of software, needing to know bits sparsed all over the place!)
08:17:15 <xerox> shapr: http://img57.imageshack.us/my.php?image=ghcionacidzn1.jpg
08:17:17 <lambdabot> Title: ImageShack - Hosting :: ghcionacidzn1.jpg
08:18:42 <xerox> Tell me if you are interested !
08:18:48 <xerox> ACTION `offline`
08:20:29 <shapr> xerox: Awesome! Where do I get it?
08:20:42 <dmhouse> That's very cool. Full lambdabot integration?
08:22:41 * Project2501a smacks revision17_ around a bit with some Fadi Deek
08:29:20 <xs> is there a haskell ffi type that corresponds to void *?
08:29:28 <xs> (in haskell, i mean.)
08:30:15 <xs> i've found HsPtr on the c side, but is that just typedef void * HsPtr, or something else?
08:30:36 <Cale> xs: corresponds in what sense?
08:31:02 <Cale> You could probably use something like Ptr ()
08:31:09 <xs> if i have in c, void *blah(), then in haskell i would have foreign import ccall ... :: IO (<type>)?
08:31:31 <xs> ah, hm, i'll try that, thanks :)
08:31:40 <Cale> You'd probably have a more specific type on the Haskell side
08:31:56 <xs> it's a handle, so i'd rather not
08:32:29 <dmhouse> shapr: http://en.wikibooks.org/wiki/Haskell/Notes_for_contributors
08:32:45 <dmhouse> shapr: specifically, http://en.wikibooks.org/wiki/Haskell/Notes_for_contributors#Using_Emacs
08:34:41 <xerox> shapr: darcs get http://haskell.galois.com/~paolo/darcs/goa
08:34:43 <lambdabot> Title: Index of /~paolo/darcs/goa
08:35:58 * xerox crosses fingers ~ releasing code is a difficult task :-)
08:36:14 <dmhouse> @karma+ xerox
08:36:15 <lambdabot> xerox's karma raised to 18.
08:36:32 * xerox hops happily!
08:36:43 <xerox> Hope it works for you as it is, ping me if you need anything.
08:42:52 <dmhouse> xerox: Although GHCi invoking a Haskell script which invoked lambdabot which invoked, say, Hoogle, seems like a bit of a long way round :)
08:44:00 <SamB> a veritable rube golberg machine!
08:44:08 <xerox> Dang.
08:44:12 <SamB> (only with a chance of working)
08:44:25 <xerox> Re-pull, I didn't add dot-ghci at the first time.
08:44:28 <xerox> dmhouse: see TODO :D
08:45:16 <dmhouse> xerox: I've previously integrated GHCi and Hoogle, would that be of any interest?
08:45:22 <xerox> Sure!
08:45:35 <xerox> How did you do it the first time?
08:45:55 <dmhouse> Let me find the wiki page.
08:46:24 <xerox> s/the first time// ~ wonder what was I thinking o_O
08:46:25 <dmhouse> http://haskell.org/haskellwiki/Hoogle#Integrating_Hoogle_and_GHCi
08:46:26 <lambdabot> Title: Hoogle - HaskellWiki
08:46:48 <xerox> dmhouse: aha!
08:47:00 <xerox> dmhouse: isn't :def crazy?
08:47:16 <dmhouse> It's great. :)
08:47:55 <dmhouse> xerox: Did you catch Simon Marlow's email to the mailing list regarding :def hackery?
08:47:57 <xerox> I mean, a command, which translates to a Haskell expression, is like a macro. Then, the result of that, is feeded to GHCi, shortcutting it.
08:48:05 <xerox> It is _crazy_
08:48:09 <xerox> dmhouse: no please point me.
08:49:13 <xerox> dmhouse: which mailing list? I can search it via gmane
08:49:37 <dmhouse> xerox: http://www.haskell.org//pipermail/haskell-cafe/2006-July/016847.html
08:49:38 <lambdabot> Title: [Haskell-cafe] Re: Why Haskell?
08:50:46 <xerox> dmhouse: hehe nice.
08:54:03 <jgrimes_> thats really useful...
08:54:47 * edwardk files that one away.
08:55:00 * dmhouse types up the Emacs integration
08:55:15 <xerox> edwardk: I got SfM in this very moment :-)
08:55:22 <edwardk> SfM?
08:55:36 <xerox> `Sets for Mathematics'
08:55:39 <edwardk> ahh
08:58:03 <SamB> @hoogle exit
08:58:05 <lambdabot> System.Exit :: module
08:58:05 <lambdabot> System.exitFailure :: IO a
08:58:05 <lambdabot> System.exitWith :: ExitCode -> IO a
09:01:22 <SamB> hmm.
09:02:34 <SamB> I want something of type "Monad m => (a -> b -> c -> m d) -> m a -> m b -> m c -> m d"
09:02:49 <xerox> liftM#
09:02:53 <xerox> ?type liftM3
09:02:55 <lambdabot> forall r (m :: * -> *) a3 a2 a1. (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
09:03:18 <SamB> that would give me an m (m d)
09:04:01 <xerox> Howdy SyntaxNinja!
09:04:02 <xerox> ?type (((sequence .) .) .) . liftM3
09:04:04 <lambdabot> forall (m :: * -> *) a a1 a2 a3. (Monad m) => (a1 -> a2 -> a3 -> m a) -> [a1] -> [a2] -> [a3] -> m [a]
09:04:11 <xerox> Hmm.
09:04:39 <SamB> @type ((join .) .) . liftM3
09:04:40 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a3)
09:04:41 <lambdabot>    Expected type: (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m a3 -> a
09:04:47 <xerox> Another one.
09:04:48 <SamB> erg
09:05:03 <dmhouse> There we go, you can now use Hoogle from Emacs. http://haskell.org/haskellwiki/Hoogle#Using_Hoogle_from_Emacs
09:05:04 <lambdabot> Title: Hoogle - HaskellWiki
09:05:08 <SamB> @type ((join .) .) . liftM3 (\x y z -> print (x + y + z))
09:05:09 <lambdabot> forall a3. (Num a3) => IO a3 -> IO a3 -> IO a3 -> IO ()
09:05:22 <SamB> @pl (join .) .) . liftM3
09:05:22 <lambdabot> (line 1, column 11):
09:05:22 <lambdabot> unexpected ")"
09:05:22 <lambdabot> expecting white space or simple term
09:05:31 <xerox> That's pl'ed SamB :)
09:05:32 <SamB> @pl (join .) .) . liftM3 f
09:05:33 <lambdabot> (line 1, column 11):
09:05:33 <lambdabot> unexpected ")"
09:05:33 <lambdabot> expecting white space or simple term
09:05:37 <SamB> erg.
09:05:39 <SamB> @pl ((join .) .) . liftM3 f
09:05:39 <lambdabot> ((join .) .) . liftM3 f
09:05:57 <xerox> You mean \f -> ((join .) .) . liftM3 $ f
09:05:58 <xerox> ?
09:05:58 <SamB> @pl ((join .) .) . liftM3 f x y z
09:05:59 <lambdabot> ((join .) .) . liftM3 f x y z
09:08:29 <SyntaxNinja> heya xerox
09:10:06 <shapr> hiya SyntaxNinja
09:10:25 <SyntaxNinja> shapr: what's up?
09:10:33 <SyntaxNinja> xerox: any cabal-get questions?
09:10:53 <shapr> SyntaxNinja: Hacking on GHC.
09:11:09 <xerox> SyntaxNinja: in a minute :-) God bless hasktags!
09:11:25 * shapr tries to figure out what Outputable.SDoc does...
09:12:13 <shapr> grr, I hate those "invalid syntax identifier" and "can't find face haskell-default" errors in haskell-mode in xemacs.
09:12:20 <shapr> Does anyone know how to fix those problems?
09:12:22 <ndm> shapr: pretty printing combinators, show for GHC
09:12:27 <xerox> SyntaxNinja: what is the `Hc' acronym supposed to mean?
09:12:46 <shapr> ndm: Um, I can't persist those can I?
09:13:07 <ndm> shapr: i doubt it, gives its a representation of how the text should be pretty printed
09:13:16 <SyntaxNinja> xerox: in what context?
09:14:13 <dmhouse> ndm: I added http://haskell.org/haskellwiki/Hoogle#Using_Hoogle_from_Emacs
09:14:14 <lambdabot> Title: Hoogle - HaskellWiki
09:15:07 <ndm> dmhouse: cheers :)
09:15:34 <dmhouse> I really like writing Elisp.
09:15:53 <dmhouse> Not the language itself, but just because I know it'll make me more productive :)
09:16:31 <shapr> Yi would be nicer...
09:16:45 <dmhouse> Yeah.
09:16:55 <shapr> One day :-)
09:17:10 <ndm> that can certainly have a hoogle binding :)
09:17:54 <xerox> SyntaxNinja: TempFlags here <http://darcs.haskell.org/packages/Cabal/Network/Hackage/CabalInstall/Types.hs>
09:19:23 <sjanssen> @keal
09:19:23 <lambdabot> i just got banned from math because i not have good ability to convey thoughts
09:19:45 <SyntaxNinja> xerox: haskell compiler
09:19:55 * xerox goes back to the code ~ thanks.
09:23:34 <SamB> hmm, what is the URL for the test codex?
09:23:46 <SamB> my web browser is thrashing too much...
09:24:06 <SamB> oh, nevermind
09:24:10 <SamB> it finished thrashing...
09:28:01 <int-e> Did anyone write a fast UM in Haskell? My attempt was a factor of 20 slower than the C implementation that I wrote when I grew impatiant.
09:28:24 <int-e> (I still don't regret using Haskell the first time, it made a good prototype)
09:28:36 <dmhouse> Igloo said their Haskell one was 'usable'.
09:28:50 <vincenz> the c-version is < 100 lines tho
09:28:56 <dmhouse> (But not as fast as their C one.)
09:29:06 <vincenz> it's quite simple
09:38:47 <SamB> mine still does not work
09:43:29 <SamB> ah, forgot to mask the opcode out in "orthography"...
09:45:35 <SamB> @hoogle stderr
09:45:36 <lambdabot> IO.stderr :: Handle
09:55:25 <SamB> okay, so I guess I'll leave the sandmark to run while I walk the dog or something...
09:55:50 <SamB> er, maybe not yet.
09:55:57 * SamB doesn't like the weather.
09:56:05 <SamB> I guess I'll do somegthing else...
09:57:58 * shapr waits for building...
09:58:25 * SamB hopes the sandmark is not going to be comparable to building GHC
10:02:51 <Igloo> SamB: It should produce output as it goes
10:03:21 <vincenz> Igloo: final score?
10:04:07 * Igloo isn't going to say without at least checking with all teammates
10:04:26 <Igloo> (who have now dispersed)
10:04:41 <vincenz> k
10:05:03 <shapr> My electricity bill was one third smaller when I stopped using that dual athlon, but it might be worth the time saved to turn it on for building GHC.
10:05:54 <dmhouse> One _third_!?
10:06:31 <shapr> It also heats my apartment.
10:06:50 <vincenz> shapr: compile GHC in the winter
10:06:52 <dcoutts_> Heffalump, what was our final score?
10:06:52 * Heffalump appears, rather knackered
10:06:57 <vincenz> save on heating
10:06:57 <Heffalump> igloo is just working it out
10:07:06 <Igloo> 4122
10:07:08 <vincenz> Heffalump: it should say at the bottom
10:07:09 <shapr> vincenz: In the summer it overheats and dies.
10:07:13 <xerox> SyntaxNinja: there is no need of `Cabal/dependencies/hackage-client-0.1.0' anymore, right?
10:07:13 <dcoutts_> vincenz, ^^
10:07:19 <Heffalump> 4122
10:07:21 <vincenz> 3595
10:07:33 <dmhouse> Aww, so we didn't get top 3 this time. Never mind.
10:07:38 <dcoutts_> we're hoping to still be in the top 10
10:07:48 <vincenz> begot got > 5000 as well
10:08:00 <SyntaxNinja>  xeroxthat's probably right.  can you verify, and remove it?
10:08:08 <xerox> SyntaxNinja: Yes.
10:08:16 <Heffalump> we were >< close to finishing advtr at the end :-(
10:08:18 * xerox got confused by multiple instances
10:08:24 <vincenz> how'd you do ants?
10:08:29 <xerox> (Of the near-same-code, that is.)
10:08:35 <Heffalump> vincenz: Igloo did them all by hand
10:08:40 <vincenz> and I take it that for BLNCE you wrote a compiler?
10:08:45 <Heffalump> no, we didn't
10:08:50 <Heffalump> but we didn't score very well on it
10:09:05 <vincenz> Lemmih was working on how to get some basic stuff going
10:09:12 <vincenz> like just incrementing one register without touching the rst
10:09:15 <Heffalump> Igloo had an assembler for BLNCE
10:09:23 <vincenz> yeah, jyp had one too
10:09:36 <Heffalump> I wrote the 2D code by hand.
10:09:37 <vincenz> Igloo: what's the tactic for rants?
10:09:44 <Heffalump> I wrote a solver for BLACK
10:10:00 <vincenz> Heffalump: I spent 8 hours optimizing the textual output of our 2d code printer :P
10:10:03 <jgrimes_> what teams were you guys?
10:10:09 * int-e got extremely lucky with his choice of heuristics for BLACK.
10:10:16 <Igloo> One tick
10:10:19 <Heffalump> Duncomloolump
10:10:22 <Heffalump> int-e: what were your heuristics?
10:10:28 <Heffalump> I spent ages on a bad approach, then found a good one
10:10:34 <dmhouse> Heffalump/Igloo/dcoutts were Duncomloolump, vincenz/jyp/adept/Lemmih were the Lazy Bottoms.
10:10:35 <Heffalump> but had to use a quick hack to make 050 work, annoyingly
10:10:48 <jgrimes_> cool deal
10:10:56 <vincenz> Heffalump: adept actually wrote a solver
10:11:06 <vincenz> I think
10:11:07 <Heffalump> vincenz: a solver for what?
10:11:12 <vincenz> oh n
10:11:13 <vincenz> nm
10:11:14 <int-e> basically choose the rightmost pair witht the most plinks left, if a simple lower bound on plinks admits it.
10:11:17 <vincenz> black is bruteforced
10:11:25 * int-e got away without any searching
10:11:31 <Igloo> vincenz: http://musketeer.comlab.ox.ac.uk/~igloo/antwo/
10:11:33 <lambdabot> Title: Index of /~igloo/antwo
10:11:37 <int-e> (just two minor tweaks for 400 and 500)
10:11:38 <Heffalump> int-e: oh, wow.
10:11:45 <Heffalump> I made a complicated graph of plink deficits.
10:11:59 <vincenz> Igloo: is there some method
10:12:09 <Heffalump> And searched for ways to reduce it, cutting off the search according to certain rules about invalid graphs
10:12:20 <Igloo> Yes. Stare at the problem until the solution appears in your head. Type in solution.
10:12:25 <vincenz> Igloo: :D
10:12:50 <int-e> Heffalump: I was surprised that it worked at all. And later I found that most small modifications to the heuristic would make it fail more often.
10:13:28 <Heffalump> int-e: heh
10:14:09 <int-e> Anyway. I didn't beat 2000. Starting more than 2 days into the contest didn't help.
10:14:37 <shapr> Should GHC's testsuite repo be pulled into the main ghc repo?
10:14:43 <vincenz> Igloo: DOH!
10:14:58 <vincenz> Igloo: that's why I didn't attempt, I thought ants went straight until they hit something
10:15:12 <jgrimes_> Will they keep the codex and such up indefinitely or do they usually end up taking the provided resources down?
10:15:26 <SamB> hmm, sandmark is much faster without printfs
10:15:37 <Heffalump> I expect they'll keep them up for quite a while.
10:15:38 <_Codex> pretty nice contest.
10:15:44 <Heffalump> vincenz: what was your simulator written in?
10:15:55 <vincenz> Heffalump: first one c, second c++
10:16:02 <Heffalump> ours was C++ too
10:16:11 <vincenz> Heffalump: environment :: vector<vector>
10:16:14 <Heffalump> we couldn't make Haskell fast enough :-(
10:16:14 <Igloo> We at least /tried/ to get by with a Haskell one, though  :-)
10:16:29 <vincenz> freelist:: list<value>  :: for all arrays in environment that were freed
10:16:30 <ndm> shapr: no , the opposite, it should be made a Haskell compiler test suite
10:16:35 <SamB> jgrimes: I believe the materials for most of the previous problems are still up
10:16:37 * int-e had one in Haskell, with abysmal speed
10:16:47 <SamB> int-e: hmm, how slow is abysmal?
10:16:48 <_Codex> our haskell UM worked fast enough -- just a little slowness in adventure...
10:16:53 <vincenz> Igloo: so did we :)
10:16:58 <int-e> SamB: more than a factor of 20 from C
10:17:03 <Heffalump> _Codex: it was fast enough for 2D and BLACK, then?
10:17:26 <SamB> why isn't there a C UM up on the site for comparison's sake now?
10:17:28 <Heffalump> I found our Haskell simulator painful for those, and had given up on it by the time I did the difficult problems.
10:17:37 <_Codex> heffalump: yes, speed was fine for those
10:17:38 <Heffalump> SamB: maybe they didn't write it in C...
10:17:48 <Heffalump> _Codex: how quickly does it run sandmark?
10:17:50 <vincenz> Heffalump: yeah checkin raytrace was SLOW
10:17:52 <SamB> they could have written one in C just for that
10:18:01 <shapr> ndm: eh?
10:18:01 <vincenz> Heffalump: who did the ADVIS thing in youor team
10:18:03 <SamB> or taken one from a winner or something
10:18:04 <_Codex> heffalump: slow as hell :)
10:18:07 <Heffalump> vincenz: duncan
10:18:10 <Heffalump> _Codex: ah, ok
10:18:13 <vincenz> dcoutts_: wanna compare and contrast?
10:18:19 <Heffalump> so your definition of "fast enough" doesn't agree with mine :-)
10:18:24 <Igloo> CosmicRay: Adventure was the first thing I worked on, and thus what motivated me to fix the C simulator instead
10:18:27 <dcoutts_> vincenz, compare what?
10:18:30 <int-e> SamB: I guess some essential code didn't get strictified, I had stack overflows, too. I didn't profile though, writing in C was quicker than learning that :)
10:18:32 <ndm> shapr, oh, you are asking how to do it, not what should be done with it
10:18:32 <vincenz> dcoutts_: ADVIS
10:18:37 <shapr> ndm: Yeah :-)
10:18:44 <dcoutts_> vincenz, oh, solutions you mean
10:18:48 <Igloo> _Codex: (Meant to type hte above to you)
10:18:48 <vincenz> dcoutts_: yeah
10:19:01 <Heffalump> shall I put all our solutions on the web?
10:19:01 <SamB> int-e: what datastructures and monads did you use?
10:19:15 <dcoutts_> vincenz, I've got an appointment in 40 min (and I need a shower ;-) )
10:19:17 <vincenz> ok
10:19:22 <shapr> dcoutts_: I can sleep on your floor Friday night, right?
10:19:31 <dcoutts_> shapr, yes
10:19:35 <shapr> Ok, just checking :-)
10:19:44 <_Codex> igloo: starting adventure still takes long time... and eats memory alot
10:19:50 <SamB> I haven't tried writing one in C yet
10:19:52 <dcoutts_> shapr, what time are we starting on Friday?
10:20:19 <vincenz> SamB: 100-200 lines of code
10:20:20 <shapr> Not sure. What are we doing on Friday?
10:20:23 <vincenz> SamB: and simple at that
10:20:26 <Heffalump> isn't it a week Friday?
10:20:28 <Heffalump> not this Friday?
10:20:28 <int-e> SamB: I tried StatT (IO), with a data carrying Arrays of Arrays, later chose a ReaderT carrying an IORef (That change had no noticable effect. The problems must be elsewhere)
10:20:34 <dcoutts_> shapr, dunno :-)
10:20:38 <int-e> SamB: IOArrays of IOArrays
10:20:44 <int-e> SamB: Arrays would be crazy
10:20:54 <dcoutts_> shapr, we'll work it out in the next day or so hopefully :-)
10:20:57 * vincenz still isn't sure whether he can make it
10:21:03 <SamB> you didn't use IOUArrays?
10:21:08 <int-e> Oh yes I did
10:21:14 <SamB> oh good
10:21:46 <_Codex> yeah, we originally used Array, then Map, and then IOUArray in the end :-)
10:21:49 * SamB retrieves his decryption key from his email so he can get into the codex
10:21:56 * shapr is checking flights
10:22:03 <Heffalump> http://urchin.earth.li/icfpcontest/2006/ is our entire darcs repo
10:22:05 <lambdabot> Title: Index of /icfpcontest/2006
10:22:12 <SamB> I realized I'd want IOUArrays at the start
10:22:31 <shapr> RyanAir specifically whines about cycles on their page, is there any other airline that's cheap and deals with cycles?
10:22:34 <vincenz> Heffalump: WOW
10:22:36 <dcoutts_> shapr, oh, I was confused. It's next Friday, right, not this Friday. 4th Aug.
10:22:37 <SamB> I use a Map of IOUArrays for the heap and an IOUArray for the registers (with the execution finger piggybacking on it)
10:22:38 <vincenz> Heffalump: sim.cpp is complex
10:22:38 <Heffalump> vincenz: ?
10:22:43 <int-e> SamB: same here (ignoring a joke implementation that worked with Data.Map)
10:22:43 <Heffalump> really?
10:22:46 <dmhouse> Who's writing up their contest experiences then?
10:22:50 <Heffalump> you mean sim2.cpp right?
10:22:51 <vincenz> Heffalump: eah
10:23:04 <Heffalump> about as simple as it needed to be, surely
10:23:04 <vincenz> http://rafb.net/paste/results/9azOKV96.html
10:23:10 <SamB> and I didn't really finish it until about just now
10:23:29 <SamB> though I hadn't really many hours during the contest
10:23:33 <Heffalump> I didn't really use much C++
10:23:44 <Heffalump> yours looks pretty clean :-)
10:23:46 * edwardk is back
10:23:54 <vincenz> Heffalump: the list is just for GC_cpurposes
10:23:59 <vincenz> Heffalump: or I'd run out on sandmark
10:24:00 <Heffalump> anyway
10:24:02 <shapr> Lemmih: Which airline are you using?
10:24:03 <Heffalump> I need to leave.
10:24:14 * Heffalump disappears
10:24:26 <edwardk> My UM was calloc'd each array and freed. Seemed a lot easier. s long as you are on a 32 bit machine the pointer size and the register contents are the same size
10:24:30 <edwardk> er just
10:24:45 <Lemmih> shapr: I don't know yet.
10:24:46 <edwardk> then handled array 0 as a special case by storing a current program pointer.
10:24:47 <vincenz> edwardk: checkc that paste
10:24:51 <SamB> edwardk: that is what I'd do too
10:25:09 <vincenz> edwardk: the nice thing of not using pointers is that it's portable to 64bit comps
10:25:18 <SamB> vincenz: heh
10:25:20 <SamB> portable!
10:25:33 <vincenz> jyp uses a 64bit comp
10:25:54 <edwardk> vincenz: yeah but you pay a performance penalty and with everyone griping about speed i wanted to go to the bare metal =)
10:26:13 <Igloo> Lemmih: Where are you, OOI?
10:26:55 <shapr> Anyone suggest a cheap but not crappy airline?
10:27:00 <SamB> how can the key be unique to me and still decrypt the standard codex?
10:27:35 <Igloo> Doesn't cheap => crappy?
10:27:39 <shapr> Not necessarily.
10:27:50 <int-e> SamB: btw, the 'simple bound' for BLACK is this: a marble at position p, with destination d must have at least max(d-p,0) plinks. Also, for every marble to the right of it that ends up to the left of it, there must be a plink, giving a second lower bound. The bound I used is the maximum of these two.
10:28:24 <shapr> Igloo: But anyway, MSR will pay me back for an economy ticket, and I don't want to buy something expensive.
10:28:25 * SamB wonders why he is being told all this stuff he does not understand
10:28:32 <Pete_I> why doesn't hugs recognise negative exponents?
10:28:45 <SamB> try parenthesizing
10:28:48 <int-e> SamB: because I confused you and Heffalump
10:29:00 <SamB> > 21 ^ (-1)
10:29:02 <lambdabot>  Exception: Prelude.^: negative exponent
10:29:07 <SamB> > 21 ** (-1)
10:29:08 <lambdabot>  4.7619047619047616e-2
10:29:13 <Pete_I> oh
10:29:18 <int-e> SamB: (I'm obviously not paying enough attention)
10:29:22 <Pete_I> i see. thanks, SamB
10:30:15 <int-e> > (2 % 5) ^^ (-2)
10:30:16 <lambdabot>  25%4
10:30:21 * SamB wonders how much work it would be to add UM to qemu
10:31:06 <cjeris> novice question: Is there a free editor for Win32 that does satisfactory syntax coloring for Haskell (EclipseFP doesn't by default) and can print the colored source to a color printer (I can't get Emacs to)?
10:31:22 <vincenz> cjeris: vim
10:31:32 <shapr> cjeris: html-colorize-buffer can turn source into an html page.
10:31:37 <SamB> emacs is only good with postscript printers
10:31:59 <shapr> cjeris: For example - http://www.scannedinavian.com/~shae/Test_TutorRing.hs.html
10:32:01 <lambdabot> Title: Test_TutorRing.hs
10:32:04 <shapr> And then you can print from your browser.
10:32:13 <shapr> You may not like my color-scheme though.
10:32:17 <cjeris> MY EYES!
10:32:21 * shapr grins
10:32:35 <shapr> Why is that people always claw their eyes and scream something about burning?
10:32:38 <SamB> hmm, this decryption is awful slow...
10:33:12 <cjeris> ok, thanks everybody.  i'll try vim (ngg, the dark side...)
10:33:27 <shapr> cjeris: M-x htmlize-buffer is the cheesy way.
10:34:17 <ndm> shapr: oplease, no!
10:34:23 <int-e> shapr: oh, it's readable in links ;)
10:34:27 <shapr> int-e: :-P
10:34:30 <ndm> thats just horrible horrible horrible!
10:34:37 <ndm> why not hscolour -css ?
10:34:47 <shapr> Hey, that'd work.
10:34:50 <cjeris> shapr: where can I find this emacs package?
10:35:13 <ndm> and generate really nice looking code :)
10:35:27 <shapr> cjeris: http://www.emacswiki.org/cgi-bin/wiki/w32-winprint.el
10:35:29 <lambdabot> Title: EmacsWiki: w32-winprint.el
10:36:04 <shapr> cjeris: I think it's part of emacs. Try M-x load-library htmlize
10:36:56 <shapr> cjeris: There's a long list of emacs tricks for w32 - http://www.emacswiki.org/cgi-bin/wiki/CategoryWThirtyTwo
10:36:59 <lambdabot> Title: EmacsWiki: CategoryWThirtyTwo
10:37:08 <shapr> Check out the printing subsection.
10:37:48 <cjeris> ok, checking it out now.  thanks!  (now that I can see again...)
10:37:52 * shapr snickers
10:38:56 <shapr> Surprisingly, SAS is ten bucks more expensive than RyanAir.
10:39:54 <hellish> dons: Did you write your UM in Haskell? If so, can I see the source?
10:40:31 <shapr> btw, could someone tell me whether it's easier to get to Cambridge from Gatwick, Heathrow, or London City apt?
10:41:29 <Igloo> Is Stanstead an option?
10:42:58 <yaxu> stansted
10:43:23 <hellish> shapr: Isn't that a train sort of trip?
10:43:46 <norpan> stansted shold be closest to cambridge
10:44:17 <yaxu> luton airport is fairly close too
10:44:20 <hellish> nevermind. You're figuring which airport to fly into.
10:45:22 * vincenz sighs deeply
10:45:44 <Igloo> vincenz: ?
10:46:21 <vincenz> just talked to the girl-im-in-love-with-who-lives-on-other-side-of-ocean-with-her-boyfriend on msn
10:46:36 <norpan> that's-a-lot-of-words
10:46:39 <Igloo> Ah
10:46:53 <vincenz> I'm glad this contest was here
10:47:04 <vincenz> or I would've been thinking all night about  other stuf
10:47:59 <syntaxfree> I don't believe in unrequited love.
10:48:01 <yaxu> shapr: looks like gatwick and heathrow are about the same by train (about 2 hours), london city airport isn't really useful, stansted airport is best - 30 mins by train
10:48:08 <syntaxfree> I think love is something that happens between two people.
10:48:24 <newsham> or a man and a beer
10:48:29 <vincenz> syntaxfree: it is not unrequited
10:48:31 <yaxu> luton airport might also be an option, not a great train route but probably a coach
10:48:33 <vincenz> syntaxfree: it's more a practical thing
10:48:55 <vincenz> that's the hard part
10:49:01 <yaxu> www.thetrainline.co.uk is useful for checking out train times etc
10:49:25 <syntaxfree> anyway. I'm too screwed up in my own relationship to spend emotional energy handing out advice.
10:49:30 <vincenz> norpan: or a man who had beer and anyone(thing?) else
10:49:50 <norpan> vincenz: ?
10:49:57 <vincenz> whoops
10:50:00 * vincenz redirects to newsham 
10:50:49 <Heffalump> shapr: London City should be quite easy.
10:50:54 <vincenz> Igloo: the teamsize rule now makes perfect sense
10:50:59 <Heffalump> shapr: Stansted is easily best.
10:51:04 <Igloo> Yeah
10:51:08 <Heffalump> Heathrow is relatively fast if you take the expensive route.
10:51:30 <vincenz> Heffalump: you're @ cambridge?
10:51:32 <Igloo> We only had a 4th person for the first few hours and the last 7, which didn't help  :-(
10:51:34 <Heffalump> from Gatwick, take a Thameslink train to Kings Cross then the train to Cambridge
10:51:38 <Heffalump> vincenz: yes.
10:51:54 <vincenz> @wiki AngloHaskell
10:51:55 <lambdabot> http://www.haskell.org/haskellwiki/AngloHaskell
10:52:09 * Heffalump is almost certainly coming
10:52:22 <vincenz> I'd like to
10:52:24 <vincenz> not sure yet
10:52:30 <vincenz> it'll depend, I have a paper deadline for 10sept
10:52:36 <vincenz> and 2 weeks of planned vacation before that
10:52:42 <vincenz> + a lot to do before the paper can be written
10:58:15 <Lemmih> Igloo: Geographically, Denmark; Mentally, in a long lost land, far away.
11:00:11 <Igloo> Lemmih: I know the feeling :-)
11:01:54 <shapr> Any swedes want to help me translate the cykel rules for SAS? :-/
11:02:08 <shapr> "Fr att undvika skador p vrigt bagage mste styret vridas ett kvarts varv samt pedalerna bortmonteras." ?
11:02:20 <shapr> "Take the pedals off" ?
11:04:48 <musasabi> to avoid breaking other luggage must ... pedals offsomething.
11:05:33 <dmhouse> Scandinavian languages are a world apart from what I know.
11:05:52 <heatsink> ??? are we supposed to fill in the blank?
11:06:18 <dmhouse> heatsink: shapr posted some Swedish he'd like translating.
11:06:25 <norpan> to avoid damages to other luggage, the handlebar must be turned a quarter turn and the pedals be removed
11:06:28 <heatsink> oh
11:07:15 <musasabi> swedish looks like a very twisted adaption of german
11:07:16 <norpan> i'm swedish
11:07:39 <norpan> well, that sentence is not normalspeak
11:07:44 <norpan> it's rulespeak
11:08:10 <monochrom> Ah, rule for shipping a *cycle.
11:08:24 <norpan> yes
11:08:25 <dmhouse> It doesn't look anything like German to me :)
11:08:55 <norpan> well, swedish is part nordic and part germanic
11:09:18 <musasabi> the languages are related and some constructs (e.g. man-passive) are identical
11:13:15 <shapr> norpan: Ok, thanks :-)
11:22:08 <dmhouse> What's a convenient term for 'functions in more than one argument'?
11:22:16 <dmhouse> It'd use 'ariatic' somewhere.
11:22:32 <dmhouse> Multiariatic?
11:22:42 <dmhouse> Polyariatic?
11:23:05 <ibid> dmhouse: n-ary? :)
11:23:05 <shapr> I think that means it can vary.
11:23:24 <dmhouse> shapr: I think that's polyvariatic, but perhaps they're too close.
11:23:27 <shapr> dmhouse: Actually, polyariadic probably is right.
11:23:31 <shapr> dmhouse: Yes, you're right.
11:23:49 <dmhouse> Perhaps just 'polyaratic'. It stems from 'arity'.
11:23:56 <dmhouse> Or even *polyaritic.
11:24:29 <ibid> or polyary?
11:24:43 <astrolabe> I've only seen 'functions of more than one variable'
11:24:51 <SamB> polyadic
11:24:56 <SamB> perhaps?
11:26:44 <ibid> "polyary" is used according to google, at least
11:27:54 <ibid> wikipedia says: Polyadic or multary (or multiary) means any number of operands (or parameters).
11:28:28 <ibid> (http://en.wikipedia.org/wiki/Arity)
11:28:46 <dmhouse> Ah, not what I want.
11:28:53 <ibid> dmhouse: is it specifically arity >= 1 or just n-ary that you are looking for?
11:29:04 <dmhouse> > 1.
11:29:04 <lambdabot>  Parse error
11:29:07 <dmhouse> :P
11:29:10 <ibid> :)
11:29:23 <dmhouse> E.g., 'you can either use currying or tuples to model XXX functions.'
11:29:36 <ibid> multiparameter?
11:29:55 <ibid> i think it gets the message across, at least
11:31:10 * edwardk was going to make a crack about adult functions, but figured it would be beneath him.
11:31:27 <shapr> oy
11:31:49 <ibid> "to model thirty functions"?!?
11:31:51 <ibid> :)
11:38:16 <monochrom> You can either use currying or tupling to code a multiple parameter function.
11:39:06 <shapr> jgrimes_: How do you get static pages to show up in the nav?
11:40:48 <jgrimes_> shapr: when logged in: Settings -> front -> menu pages
11:40:57 <shapr> What do I put into menu pages?
11:41:01 <shapr> Oh, just the name?
11:41:15 <jgrimes_> shapr: the page path
11:41:17 <shapr> jgrimes_: thanks!
11:41:36 <jgrimes_> shapr: no problem :)
12:24:12 <SamB> hmm, my C UM is waaay faster than my Haskell UM
12:24:34 <jgrimes_> is it customary to calculate the value of expressions in productions using Happy or to just build an AST that is then processed later?
12:24:38 <SamB> but I had some really obscure problems...
12:24:47 <int-e> may haskell UM took 41 minutes to uncompress the codex
12:24:58 * cjeris really needs to try the contest one of these years
12:25:11 <SamB> does decompression come before or after decryption?
12:25:22 <SamB> cjeris: I'm not trying the contest realyl
12:25:24 <SamB> er, really
12:25:30 <SamB> just trying to solve the problem
12:26:09 <int-e> my C version takes *runs and measures* 33 seconds.
12:26:37 <cjeris> this one looked fun, that's all.  a lot of years it's stuff I don't know anything about (like the game AI ones)
12:26:49 <SamB> yeah
12:27:00 <int-e> it's also sneaky
12:27:22 <int-e> you can start thinking it's about writing a vm then you see you have to write some basic and then you have a bunch of other problems ...
12:27:46 <SamB> well if you looked at the scoreboard that might be a hint...
12:27:52 <int-e> sure.
12:28:04 <int-e> but you don't know what those tasks are.
12:28:23 <int-e> ok, you know it's an ICFP and thus it's probably more than just the VM. :)
12:28:24 <SamB> I wonder how well I'd have done if I started at the beginning of the contest and worked fairly steadily
12:28:56 <SamB> yeah, at least more than a VM for such a clearly defined architecture ;-)
12:29:03 <SamB> (and simple)
12:29:17 <SamB> like, maybe you'd have to program it later...
12:29:32 <int-e> still it's a good way to get people started and hooked (later)
12:29:34 <SamB> because programming it is certainly more taxing than writing the VM
12:29:53 <int-e> (I was going to have a quick look and ended up staying awake for 24 hours straight)
12:30:06 <SamB> does everyone use htonl or am I the only one?
12:30:09 <cjeris> pnlleeeesssss++
12:32:03 <SamB> probably most ICFP tasks begin with writing a VM
12:33:38 <SamB> hmm, my C UM takes longer to start the codex, but then my CPU is not fast
12:34:23 <vincenz> int-e: 27.4s :)
12:34:27 <vincenz> int-e: for decode
12:34:31 <vincenz> P1.6M
12:36:17 <int-e> vincenz: XP2500+ here. so yours is faster.
12:36:45 <vincenz> int-e: the nice thing is that it's incredibly simple
12:36:48 * vincenz uses STL and -O3
12:37:39 <edwardk> int-e: mine takes about a 10th of a second, but is er...a dump of the executable after decompression. =)
12:38:15 <edwardk> which i undumped into a runnable state
12:39:27 <SamB> hmm, HTH are they expecting you to grab the output of the codex?
12:39:44 * int-e tries a bit of compiler option fiddling. 28.5 seconds (gcc4 instead of 3, O3, omit-fp)
12:40:02 <int-e> yes
12:40:12 <SamB> oh...
12:41:19 <edwardk> then again, my approach probably doesn't help my sandmark
12:41:33 <SamB> so?
12:41:52 <SamB> your sandmark is not important per-se
12:41:57 <edwardk> yeah
12:42:21 <SamB> hmm....
12:55:41 <monochrom> Some answers to two Haskell questions:  http://www.vex.net/~trebla/haskell/
12:55:43 <lambdabot> Title: Index of /~trebla/haskell
12:56:01 <monochrom> Eh, lambdabot is proactive again! :)
12:58:17 <SamB> hmm, is it just me or is Data.ByteString.Lazy.Char8.interact supposed to be something other than what it is?
12:59:41 <sjanssen> SamB: it's analogous to Prelude.interact
12:59:54 <SamB> sjanssen: it *is* Prelude.interact
13:00:00 <SamB> at least, in my copy
13:00:31 <sjanssen> ooh, that's a bug
13:00:50 <sjanssen> I'll write a patch
13:01:14 <SamB> it isn't a since-fixed bug?
13:02:16 <sjanssen> SamB: nope, it's like that in the latest darcs
13:04:25 <lisppaste2> Ronald Mai annotated #22277 with "nested Monad" at http://paste.lisp.org/display/22277#1
13:05:18 <monochrom> Who is Ronald Mai?
13:05:50 <SamB> someone who doesn't know to use his IRC nickname in that field, I suppose
13:10:35 <nomeata> Is there something like "eval" in haskell, if a program is run by ghci?
13:10:50 <nomeata> I.e., something that turn a string of haskell code into a function?
13:11:08 <sjanssen> nomeata: there is a library called hs-plugins, but it isn't used very often
13:11:26 <SamB> ghc turns a string of Haskell code into some functions
13:12:01 <nomeata> SamB: yes, but can I call that from within the ghc program?
13:12:05 <sjanssen> SamB: I fixed that interact problem, do you want me to copy the patch to you?
13:12:51 <nomeata> (I'd like to have something like main = interact (map (eval commandline_args))
13:12:54 <SamB> sjanssen: I don't need it right now
13:13:18 <dmhouse> nomeata: To be really obscene, you could create a new process to GHCi :)
13:13:23 <SamB> nomeata: you can call ghc from within a ghc program, but it won't do you much good if you can't load the object file...
13:14:08 <nomeata> hmm. but I could put the commandline_args in a let =, then append the line up there, and then call ghc
13:14:20 * Heffalump appears
13:14:49 * dmhouse spots a Heffalump on the horizon
13:15:30 * shapr boings
13:16:38 <sjanssen> nomeata: you should ask yourself whether you really need dynamic evaluation
13:16:55 <nomeata> sjanssen: I want to write a
13:16:58 <nomeata> sorry
13:17:24 <nomeata> sjanssen: I'd like to have a "hmap" command line tool that takes a String->String function, for everyday's text file mangling
13:17:31 <SamB> hmmhmm
13:17:53 <nomeata> for when AWK is to akward and perl, well, for when I don't feel like using perl for a change
13:18:02 <SamB> why does GHC just give linker errors when you try to link without --make and leave out a package flag?
13:18:14 <SamB> it should tell you you need the package flag, instead
13:19:25 <SamB> "no game playing is allowed" <- heh
13:19:31 <sjanssen> nomeata: you should get out the -e flag you can give to GHC
13:19:41 <Philippa> I was just typing about that...
13:19:44 <sjanssen> s/get/check
13:20:52 <nomeata> cool, just tried "ghc -e 'interact id'", works nice
13:21:24 <monochrom> If Haskell has an eval, does eval has an eval too? :)
13:21:34 <nomeata> so a shell function "hmap () = { ghc -e "interact ($1)" }" should do
13:22:24 <nomeata> or alternatively a  "hmap () = { ghc -e "interact (unlines.(map $1).lines)" }" should do
13:23:33 <SamB> aww, I can't figure out my score now that the deadline has passed :-(
13:26:15 <malcolm> ping psnl
13:26:51 <SamB> is this thing a real UNIX system?
13:27:32 <nomeata> cat /etc/passwd | ghc -e 'interact (unlines.(map reverse).lines)'
13:27:53 <SamB> SYNTAX ERROR.
13:27:53 <SamB> Command: cat
13:27:53 <SamB> Purpose: Prints a file to the terminal.
13:27:53 <SamB> Correct syntax: cat file
13:27:59 <SamB> I guess not
13:30:41 <CosmicRay> heh
13:30:44 <monochrom> A real UNIX system does not give you that kind of informative message. :)
13:31:00 <monochrom> s/informative/educational/
13:31:47 <SamB> a real unix would have complained that GHC was not installed, rather than having cat complain at all
13:31:57 <SamB> well, rather that it couldn't find a ghc
13:32:07 <monochrom> It does not know |
13:32:15 <SamB> it has weak shell-fu
13:32:24 <SamB> % cat /bin/sh
13:32:24 <SamB> cat: no such accessible file
13:32:41 <SamB> it doesn't even have an echo command
13:33:52 <SamB> hmm, real unix doesn't know that a binary isn't a text file either...
13:34:04 <RyanT5000> can you specify that a particular type is not an instance of a class?
13:34:18 <SamB> no
13:34:25 <RyanT5000> well i have this situation
13:34:25 <monochrom> Odd thing to specify.
13:34:43 <SamB> you could prevent it from being one by not exporting all the members of the class, though
13:34:59 <RyanT5000> well i have a functional dependency issue
13:35:04 <RyanT5000> i've got this:
13:35:08 <RyanT5000> instance (Ix i, IArray a e) => Container (a i e) i e where
13:35:26 <RyanT5000> as well as
13:35:26 <RyanT5000> instance Container c k c' => Container (View c c' v') k v' where
13:35:44 <RyanT5000> View isn't an instance of IArray, but there's no way it can tell taht
13:35:56 <RyanT5000> is there any way to make this work?
13:37:12 <RyanT5000> (View is an adaptor; it takes a container of one thing and transparently converts it into a container of another thing - kind of like map, only modifications to the resulting container are back-mapped to the original type of structure)
13:37:37 <RyanT5000> do i need to use -fallow-overlapping-instances or something?
13:37:49 <RyanT5000> and where can i find man pages on those -f directives? i couldn't find them on google
13:37:49 <sjanssen> RyanT5000: the simplest way is to drop that first instance
13:38:07 <RyanT5000> sjanssen: and just manually instance each IArray class?
13:38:11 <sjanssen> and then write an instance for the Array types you want to use
13:38:14 <RyanT5000> that wouldn't be terrible, as i'm only using a few
13:38:22 <sjanssen> RyanT5000: yeah, there are only a couple that exist
13:38:29 <RyanT5000> mostly DiffArray
13:38:33 <RyanT5000> alright
13:38:40 <SamB> RyanT5000: overlapping instances?
13:38:51 <RyanT5000> isn't that what the directive is?
13:38:56 <sjanssen> overlapping instances?  yuck
13:39:02 <SamB> -fallow-overlapping-intances
13:39:19 <SamB> I am usually against them but it ought to be okay if they don't actually overlap
13:39:46 <RyanT5000> well, on second thought, View actually could be an instance of IArray
13:39:53 <RyanT5000> so i'll just do the manual instancing
13:40:25 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
13:40:27 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.4.2
13:40:34 <RyanT5000> does the idea of having a container adaptor make sense to anyone other than me?
13:41:04 <ihope_> RyanT5000: a what?
13:41:07 <RyanT5000> here's what it does
13:41:27 <RyanT5000> i have an array, e.g. Array Int (a, b)
13:41:47 <RyanT5000> arr :: Array Int (a, b)
13:42:04 * SamB wonders how to use UMODEM
13:42:54 <RyanT5000> then we can use View arr fstAccessor as an array of a
13:43:15 <RyanT5000> but updates are made to an Array Int (a, b)
13:43:22 <monochrom> I don't see why View is an IArray a priori.
13:43:27 * SamB supposes pasting from emacs and saying STOP would work fairly well
13:45:18 <RyanT5000> monochrom: instance IArray a e => IArray (View a e e') e'
13:45:49 <RyanT5000> basically if you have an array of x, and a way of getting y's out of x's, and putting them back in
13:45:50 <monochrom> Yes, if you have that, you have overlapping instances.
13:46:01 <RyanT5000> yeah
13:46:34 <RyanT5000> i realize that, which is why i'm going to just explicitly do each IArray instance i need
13:46:45 <RyanT5000> but my larger concern is whether this is a reasonable technique
13:47:36 <RyanT5000> the idea is to have the same effect as doing a map over the container, except being able to do the reverse map as well
13:48:26 <monochrom> instance Container c k c' => Container (View c c' v') k v'     I might discard this.
13:48:39 <RyanT5000> how so?
13:48:59 <monochrom> class Container c k v => View c k v       I might do this instead.
13:49:41 <RyanT5000> hm... then how would one implement the view datastructure?
13:49:51 <RyanT5000> or, a View datastructure
13:50:52 <RyanT5000> right now it just has the original container and a get and set routine that does the conversion between the original v and the v that the View is showing
13:51:27 <monochrom> Perhaps I don't understand your View.
13:52:46 <RyanT5000> alright, so here's how it's currently implemented:
13:52:46 <RyanT5000> data View c c' v' = View c (c' -> v') (v' -> c' -> c')
13:52:56 <RyanT5000> the idea being that c is a container of c'
13:53:25 <RyanT5000> a View c c' v' looks like a container of v'
13:53:46 <RyanT5000> but it's really keeping track of a container of c'
13:54:48 <RyanT5000> (View c f g) is kind of analogous in purpose to (fmap f c)
13:55:16 <RyanT5000> the difference being that updates made to the resulting container are reflected in the View as well
13:55:48 <RyanT5000> so let's say i have a game board, where each cell is a (Terrain, Set Piece)
13:56:46 <RyanT5000> board :: IArray a e => a (Int, Int) e
13:57:35 <RyanT5000> s/e/(Terrain, Set Piece)/
13:57:50 <RyanT5000> so now if something operates on the Terrain only
13:58:18 <RyanT5000> i can pass it (View board fst setFst) instead of the whole board (which it wouldn't understand)
13:58:40 <RyanT5000> (setFst x (_, y) = (x, y))
13:59:28 <dmhouse> @hoogle first
13:59:28 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
13:59:29 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:59:29 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
13:59:39 <dmhouse> @type first . const
13:59:41 <lambdabot> forall b d a. a -> (b, d) -> (a, d)
13:59:55 <dmhouse> RyanT5000: How's that look?
14:00:02 <dmhouse> Actually,
14:00:08 <RyanT5000> first  is a simmilar idea
14:00:18 <dmhouse> I think there's an arrowic combinator to do exactly this. hold on.
14:00:35 <RyanT5000> i thought there might be
14:00:40 <dmhouse> Ah, no, never mind. (first . const) is nice, though.
14:01:15 <RyanT5000> i can see how you could use arrows to map a function over all the firsts in a datastructure
14:01:33 <RyanT5000> but i can't figure out how you'd make a function that is applied to the whole datastructure work that way
14:01:46 <RyanT5000> though i must admit my understanding of arrows is infantile
14:02:17 <dmhouse> They're actually very easy.
14:02:38 <RyanT5000> i use *** routinely
14:02:39 <shapr> stick!
14:02:42 <RyanT5000> but that's about it
14:02:49 <monochrom> Why make View a class?
14:03:01 <RyanT5000> monochrom: i dunno, that was your suggestion
14:03:08 <dmhouse> RyanT5000: The arrowic combinators make frequent appearances in the
14:03:11 <monochrom> Err nevermind.
14:03:23 <RyanT5000> sorry,  i need to leave; i'll  be back on in a few hours, probably with more of this stuff
14:03:26 <dmhouse> #haskell algorithm golf competitions, but rarely outside of that, I think. :)
14:04:10 <shapr> Arrows rock.
14:04:28 <SyntaxNinja> shapr: want to do some Haskell'-related web hacking?
14:04:32 <musasabi> but don't produce simple easy to understand code.
14:04:44 <shapr> SyntaxNinja: yes?
14:05:01 <SamB> man, the contest organizers this year were insane
14:05:08 <shapr> SyntaxNinja: Though right now I'm hacking on GHC for MSR, and Hope for a friend of mine.
14:05:22 <dmhouse> RyanT5000: read shapr's 'Introduction to Arrows' from the TMR somewhere
14:05:49 <shapr> RyanT5000: Arrows are neat and extremely powerful in some special cases, but don't integrate well with normal functions.
14:06:03 <shapr> Arrows are generalization (superset) of monads.
14:06:26 <dmhouse> But that's not a particularly good way of thinking about it,.
14:06:46 <SyntaxNinja> shapr: I want a survey, and I want it to be very little effort on my part :)
14:06:59 <dmhouse> Arrow a => a b c is a "function" from b to c. It takes a parameter of type b, and a result of type c, but might do some funky stuff along the way.
14:07:14 <musasabi> The most important thing with arrows would be to come up with a good syntax. Same with comonads.
14:07:26 <SyntaxNinja> shapr: I've got something simple, but it doesn't save results yet or do much, really, but it could get you started
14:07:33 <dmhouse> Once you've read the examples from Paterson's 'Arrows and Computations', you've more or less got it.
14:07:35 <SyntaxNinja> but if you don't think you have time, i guess I can do it :)
14:07:45 * dmhouse thinks more of the Haskell researchers should hang out on IRC.
14:07:56 <Philippa> shapr: strictly speaking they're not a superset, but there's a corresponding arrow for each monad
14:07:59 <Heffalump> this might inhibit their research progress though :-)
14:08:06 <SyntaxNinja> kosmikus: I really dislike generating the print-ready version of a paper :P
14:08:06 <Philippa> no kidding
14:08:16 <SyntaxNinja> dmhouse: well, just keep mentioning it here, I'm sure they'll show up ;)
14:08:18 <Philippa> that, and they might run screaming the first time I pun...
14:08:35 <shapr> SyntaxNinja: Hope could probably do it without too much work.
14:08:39 <dmhouse> SyntaxNinja: that's the plan! :)
14:09:11 <SyntaxNinja> dmhouse: I'm sure they pour over the logs looking for their names. you could just start mentioning them randomly.  Paul Hudak: Visit #haskell
14:09:32 <SyntaxNinja> shapr: I can do it from scratch in far less time than it'll probably take to install hope ;)
14:09:40 <shapr> I mentioned Hudak earlier, have you seen his paper about modelling Jazz Improvisation with Haskore?
14:09:44 <shapr> SyntaxNinja: True :-)
14:10:12 <dmhouse> Ross Paterson, Ralf Hinze, you too :) (I like their papers a lot.)
14:10:23 <shapr> Derek Elkins, please come back.
14:10:31 <shapr> Thomas Jaeger too
14:11:05 <shapr> Let's see, dennisb, Martin Sjgren....
14:11:16 <shapr> Hal Daume
14:12:01 <dmhouse> Ooh, yeah, then I can complain about YAHT's incompleteness :)
14:12:29 <SyntaxNinja> We can yell at hudak for naming it "A gentle introduction" which scares away all these young ones.
14:12:48 <shapr> Yeah, the mental brickbat of doom is a bit closer.
14:14:22 <dmhouse> @remember shapr [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
14:14:23 <lambdabot> Done.
14:14:47 <Philippa> SyntaxNinja: it's not the name that's the problem. It's that it got distributed beyond the intended audience
14:14:57 <Philippa> if you were already, say, an ML hacker it was indeed a fairly gentle introduction
14:15:53 <shapr> Philippa: Hm, good point.
14:16:00 <shapr> Hmm_|: RMS? Are you ...?
14:16:39 <SyntaxNinja> Philippa: there's an inescapable link between the name of something and its distribution patterns.  one should assume that things will be distributed more widely than its intended audience, and so name it accordingly.
14:16:45 * SyntaxNinja hands rms a cookie
14:16:47 * Philippa nods
14:16:55 <Philippa> I suspect it was named after similar pieces for other languages
14:17:24 <Philippa> unfortunately that's a cultural cue that's got lost in the meantime
14:17:44 <SyntaxNinja> hm. yeah
14:17:51 <xerox> SyntaxNinja: it works!
14:18:04 <xerox> Personal code: start with the documentation, not the code ;-)
14:18:10 <xerox> s/code/note/
14:18:36 <SyntaxNinja> shapr: he's case-sensitive: http://geekz.co.uk/lovesraymond/archive/mundane-name
14:18:38 <lambdabot> Title: Everybody loves Eric Raymond  Mundane name
14:18:39 <SyntaxNinja> xerox: yay!
14:19:00 <xerox> SyntaxNinja: in what format are the haskellDB programs?
14:19:11 <SyntaxNinja> xerox: haskellDB programs?
14:19:18 <SyntaxNinja> there is no more haskelldb
14:19:35 <xerox> Well, the programs which are in the (ex-haskellDB) hierarchy
14:19:46 <SyntaxNinja> they're tarballs w/ cabal files in them.
14:20:06 <xerox> SyntaxNinja: when you fetch a program, it downloads a gzipped file without extensions, is it done on purpose?
14:20:18 <stepcut> SyntaxNinja: that cartoon is very disturbing
14:20:26 <xerox> I only tried the small helloWorld examples so far, though
14:20:28 <dmhouse> SyntaxNinja: hehe :)
14:20:47 <dmhouse> (Who's the guy in the background?)
14:20:55 <SyntaxNinja> bruce perens
14:21:17 <SyntaxNinja> xerox: that is kinda strange. the new code does this?
14:21:23 <xerox> Yes.
14:21:32 <SyntaxNinja> I think they're tarballs
14:21:51 <xerox> $ file etc-cabal-install/packages/helloWorld-1.0
14:21:52 <xerox> etc-cabal-install/packages/helloWorld-1.0: gzip compressed data, from Unix, max compression
14:22:11 <SyntaxNinja> xerox: on the server, what format are they?
14:22:40 <xerox> helloWorld-1.0.cabal  helloWorld-1.0.tar.gz
14:23:09 <monochrom> Eric Raymond uses a Bayesian filter.  Our stuff here probably gets rejected by the filter, and he probably never gets to see it.
14:23:18 <xerox> ...under pub/unstable/helloWorld/
14:23:29 <SyntaxNinja> xerox: hm. don't know why it renames it.  feel free to fix :)
14:23:36 <SyntaxNinja> monochrom: we're that much safer ;)
14:23:58 <xerox> SyntaxNinja: sure, I will track this down; I also have other ideas, but I am very sleepy now, where do you think we should discuss them?
14:25:31 <SyntaxNinja> xerox: stick 'em on the wiki, and if you want, send a link to me && || cabal-devel.
14:25:52 <xerox> SyntaxNinja: OK! ttyl
14:26:10 --- topic: set to '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who has won?"]' by int-e
14:26:19 --- topic: set to '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]' by int-e
14:29:21 <dmhouse> I'd like to reduce that topic to just 'We put the Funk in Funktion'.
14:29:31 <dmhouse> And perhaps mention the HCAR and SoC.
14:37:47 <wilx> Oh.
14:37:59 <wilx> ICFPC contest has already ended?
14:38:58 <dmhouse> Yeah.
14:40:52 <SamB> wilx: you can still play with it if you have a decrytion key
14:41:00 <SamB> er, decrytion
14:41:04 <SamB> ack
14:41:09 <SamB> @spell decrpytion
14:41:11 <lambdabot> decryption decrypting description decoration deception
14:41:17 <SamB> decryption
14:42:54 <heatsink> What is a "publication"?  I didn't understand that part.
14:43:08 <Philippa> it's a key to hand in for points
14:45:05 <heatsink> ok.  So the sample um files were meanses of generating keys, and players had to figure out how to use them.
14:45:09 <SamB> is it just me or does qvickbasic leak?
14:45:24 <heatsink> The contest format was quite different from previous years.
14:45:52 <SamB> indeed
14:45:59 <Philippa> 'twas fun, although a bit nasty to those running on systems that use something other than LF for newlines
14:53:31 <SamB> hmm, so IIL = '0'?
14:54:12 <heatsink> indeed.
14:54:30 <Heffalump> I didn't quite understand what the decryption key did
14:54:46 <SamB> it probably has something to do with score cookies?
14:54:47 <Heffalump> Was it just checked, then cooked into the decompressed codex and used to encrypt the publications?
14:55:14 <SamB> also, it starts with the symbol of the Cult of the Bound Variable
14:55:43 <Heffalump> you mean omega?
14:55:51 <SamB> oh?
14:55:54 <SamB> mine does anyway...
14:56:08 <Heffalump> (\b.bb)(\v.vv) is the lambda calculus fix-point combinator, also known as omega
14:56:19 <SamB> oh
14:56:30 <SamB> well. is it usually written with Bs and Vs?
14:56:33 <Heffalump> no
14:56:46 <SamB> well, see, that is why I think it is the symbol of the Cult
14:58:06 * int-e wonders what the meaning of the gif image in the codex is - it shows CBV I think
14:58:28 <SamB> gif image?
14:58:40 <int-e> yes
14:58:46 <dmhouse> Heffalump: surely *a lambca calculus fix-point combinator. Surely there are many, of which Omega is one, Y is one, etc.
14:59:00 <int-e> there's a GIF89a signature inside the codex file
14:59:04 <Heffalump> dmhouse: yes, ok
14:59:15 <int-e> and that and what follows is a valid gif image
14:59:16 <SamB> indeed there is
14:59:17 <dmhouse> int-e: I think there are several.
14:59:29 <Heffalump> btw, did anyone finish adventure?
14:59:33 <Heffalump> And if so, could you explain how?
14:59:43 <SamB> I would first suggest to buy more RAM
14:59:46 <Heffalump> we got the uploader working with 5 mins to spare but didn't manage to do anything useful with it.
15:00:18 <int-e> I got there an hour before the contest end
15:00:43 <int-e> it's a fun device really :)
15:01:24 <Heffalump> it was cool :-)
15:01:33 <Heffalump> I really regretted not having more time to play with it.
15:01:48 * SamB wonders how you get a language you like declared the Language of Choice for Discriminating Hackers in this thing
15:02:01 <Heffalump> SamB: by winning...?
15:02:03 * int-e got as far as increasing his inventory and collecting all incinerated items :)
15:02:06 <SamB> it looks like they are trying to get QvickBASIC picked or something
15:02:20 <int-e> oh and I found the blueprint
15:02:23 <Heffalump> SamB: you can choose on the team page what to use?
15:02:25 <Heffalump> s/?//
15:02:28 <Heffalump> int-e: I got that and a proof.
15:02:34 <Heffalump> Couldn't figure out what to do with them though.
15:02:44 <SamB> I didn't get any points before the contest ended ;-)
15:02:50 <Heffalump> SamB: ah.
15:02:57 <int-e> I think I found the blueprint's length. Couldn't check it though :)
15:03:10 <Heffalump> int-e: oh. Did you find a way to get round REDACTED then?
15:03:28 <SamB> so even if you don't get any points with your Haskell code, do you still get to pick that?
15:03:44 <int-e> sure. didn't you read the note? :)
15:04:14 <Heffalump> it said to change your goggles, and ignore perception
15:04:16 <Heffalump> SamB: I think so.
15:04:21 <int-e> (well I think I have something that will work.)
15:04:23 <Heffalump> though you might feel a bit guilty..
15:04:47 <Heffalump> int-e: bear in mind I only had 5 minutes of playing with this before the contest ended (I could have kept going after I guess, but was rather knackered)
15:04:50 <SamB> well, I suppose you could count it towards some of the first 200 points...
15:05:05 <Heffalump> we didn't actually use Haskell _that_ much
15:05:06 <int-e> Heffalump: I had a bit more, but not much.
15:05:17 <norpan> it sounds more like it was a codebreaking contest than a programming contest
15:05:18 <Heffalump> our simulator was C in the end, but debugged using a Haskell reference implementation
15:05:27 <int-e> 40 minutes? not enough to do anything really interesting.
15:05:29 <Heffalump> norpan: no, many of the puzzles needed programming to solve.
15:05:47 <norpan> well yes, but still a puzzle solving contest?
15:05:52 <Heffalump> norpan: sure.
15:05:58 <SamB> norpan: note that you have to write a BASIC program to find passwords ;-)
15:06:07 <SamB> or, at least, are supposed to
15:06:09 <Heffalump> but most ICFP contests are about that in some form
15:06:11 <int-e> I wonder if anyone solved the adventure puzzles completely by hand (the ones you need to get the up- and downloader)
15:06:25 <Heffalump> even the game-based ones required writing code to do stuff like find routes, which is essentially puzzle solving
15:06:35 <Heffalump> int-e: we would have done if we'd realised how modular they were
15:06:37 <nnunley> Well... A very special version of BASIC.
15:06:40 <norpan> well, it's not clear cut
15:06:44 <Heffalump> it would have been quicker than all the code we wrote to solve them.
15:07:09 <Heffalump> we ended up solving RS232 by hand cos our code just couldn't do it
15:07:17 <SamB> qbasic: VNKNOWN SVBROVTINE OR ARRAY ASC ON LINE X
15:07:21 <Heffalump> but we only realised with 20-30 mins to spare that we could do it by hand.
15:07:23 <SamB> yeah, that is special
15:07:50 <Heffalump> norpan: well, I think programming to solve puzzles is programming in its finest form ;-)
15:08:23 <SamB> but in QVICKBASIC?
15:08:59 <SamB> in QVICKBASIC, the LINE NVMBERS are a pain
15:09:03 <Heffalump> well, that was really just a fun diversion. It wasn't hard.
15:09:15 <Heffalump> now 2D, that's a language that'll give me nightmares for a while..
15:09:22 <Heffalump> (I spent most of Sunday writing our raytracer)
15:09:48 * nnunley grins.
15:09:58 <SamB> how does it know if your raytracer works anyway?
15:10:04 * int-e was thrown off by the spec.
15:10:17 <Heffalump> it makes up random inputs
15:10:40 <Heffalump> once I got my raytracer to stop failing (as in causing abnormal conditions and dying) it worked first time
15:10:49 <Heffalump> sadly this first step took rather a long time
15:11:03 <SamB> did it make a nice picture too?
15:11:28 <Heffalump> nope :-)
15:11:35 <Heffalump> it was just a number as output
15:11:47 <Heffalump> (in the range Low, Medium, All)
15:11:49 <SamB> WTH is the point of a raytracer that does not make a nice picture?
15:11:54 <Heffalump> or None, Medium, All or something.
15:12:04 <Heffalump> well, it was a reference to a past contest
15:12:08 <SamB> oh
15:12:09 <Heffalump> quite a lot of the puzzles were
15:12:15 <Heffalump> e.g. ants, Chicago streets
15:12:25 <SamB> I was just about to ask if there was an ant puzzle
15:12:51 <Heffalump> luckily Igloo managed to solve all of the ant puzzles, it'd have been rather embarrassing for us not to have managed that :-)
15:12:58 <nattfodd> heh, talking of icfp here too :)
15:13:19 <SamB> whatwhatwhat?
15:13:26 <SamB> qbasic does not like IIL?
15:13:53 <lisppaste2> xerox pasted "ghc-pkg: invalid package identifier: " at http://paste.lisp.org/display/23100
15:13:56 <nattfodd> Heffalump: which score did you manage to reach in the end?
15:14:28 <Heffalump> nattfodd: 4000 or so
15:14:30 <xerox> It's the second time this error happens to me, this time is the `haskell-rss' package. I can't remember how I fixed it the first time :(
15:14:34 <xerox> Any ideas?
15:14:39 <Heffalump> 4122
15:14:49 <nattfodd> Heffalump: congratulations
15:14:58 <nattfodd> we reached a mere 2269
15:15:00 <xerox> (The file mentioned in the output is empty.)
15:15:03 <SamB> what is the roman numeral for 48?
15:15:16 <Heffalump> not really, it puts us 4th even on the 8hour-old leaderboard :-)
15:15:21 <nattfodd> XLVIII
15:15:22 <dmhouse> SamB: IIL?
15:15:39 <shapr> xerox: clean first?
15:15:40 <dmhouse> Ah, okay.
15:16:27 <SamB> DXIII    word = words(i) + CHR(j+IIL) + CHR(k+IIL)
15:16:34 <SamB> qbasic didn't like this line
15:17:21 <SamB> stated reason:
15:17:23 <SamB> qbasic: BAD NVMERAL IIL
15:17:45 <int-e> XLVIII
15:17:55 <xerox> No luck shapr
15:18:01 <int-e> but that has been said
15:18:06 <SamB> oh, oops
15:18:37 <SamB> I missed it because dmhouse told me the one I'd tried right after and was highlighted because he used my name
15:18:56 <nattfodd> SamB: I'm used not being listened to, don't worry :)
15:18:56 * int-e reached a 1983 after 40 hours or so (including 8 hours of sleep)
15:19:06 <dmhouse> "Rules regarding Roman numerals often state that a symbol representing 10x may not precede any symbol larger than 10x+1. For example, C cannot be preceded by I or V, only by X (or, of course, by a symbol representing a value equal to or larger than C). Thus, one should represent the number "ninety-nine" as XCIX, not as the "shortcut" IC. However, these rules are not universally followed."
15:19:08 <nattfodd> int-e: working all alone?
15:19:11 <int-e> yep
15:19:16 <nattfodd> impressive then
15:19:18 <xerox> shapr: what does your haskell-rss/.installed-pkg-config file contain?
15:19:23 <dmhouse> 10x -> 10^x, bad copy-paste algorithms.
15:19:29 <nattfodd> 2269 was with a team of 7 persons going on and off
15:19:47 <nattfodd> only two of us worked for the whole thing, but that still is a lot more manpower
15:20:06 * edwardk returns. The festivities may resume.
15:20:14 <Heffalump> int-e: wow, that's pretty good
15:20:45 <Heffalump> we had 3 people continuously and a 4th for the initial few hours and final 8 hours
15:20:48 <nattfodd> are there some public haskell UM?
15:21:04 <SamB> hmm hmm hmm
15:21:08 <SamB> my looping is wrong
15:21:32 <shapr> xerox: http://www.scannedinavian.com/~shae/.installed-pkg-config
15:21:36 <Heffalump> nattfodd: ours is
15:21:39 <int-e> I got very lucky on BLACK.
15:21:42 <nattfodd> Heffalump: URL?
15:21:58 <Heffalump> http://urchin.earth.li/icfpcontest/2006/sim.hs
15:22:02 <nattfodd> thanks
15:22:04 <int-e> but I said that already :)
15:22:06 <Heffalump> we ended up using the C++ one instead though
15:22:08 <Heffalump> that one was too slow
15:22:16 <Heffalump> int-e: true, I spent all of Saturday on that
15:22:20 <nattfodd> we sticked to http://paste.plone.org/6721
15:22:23 <Heffalump> and most of Sunday on CIRCS
15:22:44 <Heffalump> and the rest of Sunday and all of Monday on a mostly futile assault on ADVTR
15:23:12 <kuribas> Is it possible to type (\x -> x x)?
15:23:28 <nattfodd> Heffalump: as I said on the ml, I think adventure was easier solved by hand
15:23:39 <xerox> shapr: thanks! I got a plenty of package to update, hehehe, it reminds me ... ;)
15:23:49 <JKnecht> > (\x -> x x)
15:23:50 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
15:23:51 <xerox> ?pl \x -> x x
15:23:51 <lambdabot>    Expe...
15:23:51 <lambdabot> join id
15:23:56 <xerox> ?type join id
15:23:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
15:23:57 <lambdabot>    Expected type: a -> a -> a1
15:24:07 <WIreD0x90> hey i wanna know if it's possible to login to freenode n efnet server at the same time..
15:24:18 <nattfodd> kuribas: not in simply typed lambda calculus
15:24:27 <xerox> Hmm.
15:24:28 <kuribas> In ocaml you can turn on recursive types, does haskell have something like that?
15:24:44 <nattfodd> WIreD0x90: yes, use /connect with irssi or ^T with x-chat
15:25:19 <nattfodd> kuribas: I'd be very surprised if not
15:25:23 <WIreD0x90> i m using gaim..
15:25:35 <nattfodd> WIreD0x90: then ask on #gaim :)
15:25:49 <Heffalump> nattfodd: yeah, we realised that after the event
15:26:00 <Heffalump> we hadn't read the note very carefully so we didn't realise how modular it was
15:26:06 <int-e> I spent 5 hours on a solver for adventure puzzles which turned out to be usable (it can solve all 11 problems in a few seconds)
15:26:09 <WIreD0x90> k..thanks
15:26:10 <nattfodd> Heffalump: the real hard stuff was actually finding how to read the blueprint
15:26:30 <Heffalump> nattfodd: yeah, couldn't figure that out in the 5 minutes I had spare once we finished the uploader :-)
15:26:36 <Heffalump> int-e: what strategy did it use
15:26:37 <Heffalump> ?
15:26:37 <nattfodd> and did you find how to switch goggles?
15:26:41 <nattfodd> that was really cool
15:26:48 <Heffalump> nattfodd: nope, how did you do it?
15:26:56 <nattfodd> type 'switch goggles' :)
15:26:59 <nattfodd> try ANSI, it's great
15:27:07 <nattfodd> and I guess it would have helped a lot parsing
15:27:19 <Heffalump> oh, and that didn't get sent through the gc.rml file?
15:27:29 <nattfodd> no, there was stuff on server side
15:27:36 <nattfodd> like some "go" directives
15:27:58 <Heffalump> so how did you read the blueprint?
15:28:15 <nattfodd> well, you have to use the cards in the eastern room
15:28:16 * Heffalump would quite like to know the answer but doesn't have any more time to work it out for himself :-(
15:28:23 <nattfodd> that gets 53 objects in your inventory
15:28:24 <int-e> Heffalump: actually it's just based on combining things as early as possible, plus the fact that you can add the incinerates in a second pass. that makes the search tree reasonably small. (a level in the tree consists of taking one item, combining it with other items, using the result for further combinations, if desired)
15:28:27 <Heffalump> oh, right. I assumed those were just to be in the way of the proof.
15:28:40 <Heffalump> int-e: that's what we did too, but how did you do RS232?
15:28:40 <nattfodd> and then you have to rely on side-effects, as there is a "taint" which transmits to values being returned
15:28:57 <cjeris> damn. i just finished coding a vm and starting it up.  i am so sorry i did not try this contest while it was going on.  that is really neat.
15:29:08 <nattfodd> then you move_item_to_room one card for each char
15:29:15 <nattfodd> and the value of the card tells which letter it is
15:29:43 <Heffalump> nattfodd: wow. Does switching goggles help you figure this out?
15:29:48 <nattfodd> btw, you later learn that the proof was wrong because the guy hadn't considered side-effects :)
15:29:55 <Heffalump> hehe
15:29:59 <nattfodd> Heffalump: it didn't, someone told me how to do it afterwards
15:30:07 <edwardk> cjeris: yeah, playing with 'advise' now.
15:30:07 <int-e> Heffalump: I expected to have to optimize the inventory slots required but that wasn't necessary. RS232 could be solved by the same program
15:30:16 <Heffalump> int-e: hmm, odd, ours couldn't.
15:30:27 <Heffalump> I think my "enumerate all possible trees" approach went wrong somewhere.
15:30:38 <Heffalump> oh well.
15:31:02 <int-e> Heffalump: one thing that I was careful about was distinguishing commutative and non-commutative 'combine's.
15:31:05 <Heffalump> we couldn't have overhauled the 8hours to go first place score even with completeing adventure. That team was amazing.
15:31:14 <Heffalump> int-e: do you mean associative and non-associative?
15:31:17 <Heffalump> they were all commutative
15:31:23 <int-e> Heffalump: yes, that's a better term
15:31:25 <nattfodd> Heffalump: I heard they are all google people
15:31:29 <nattfodd> they are everywhere :)
15:31:37 <Heffalump> actually, even associative is poor
15:31:40 <int-e> err, no
15:31:46 <Heffalump> it's (a+b)+c = (a+c)+b, anyway.
15:31:56 <Heffalump> maybe commutative is better.
15:32:00 <int-e> it's commutative in some sense
15:32:11 <int-e> (namely thinking of +x as an operation)
15:32:18 <Heffalump> nattfodd: any idea how many of them there are?
15:32:23 <int-e> +x and +y can be commutative or not
15:32:36 <nattfodd> Heffalump: just 4
15:32:36 <Heffalump> int-e: well, you mean they can commute or not.
15:32:42 <Heffalump> nattfodd: shame :-)
15:32:54 <nattfodd> which means C++ has good chances of being a hacker's tool of choice :'(
15:33:34 <Heffalump> googling for their name suggests they used Java last year
15:33:43 <int-e> Heffalump: I think that's grammatically equivalent. Mathematically 'commutative' has a more restricted meaning. Anyway, I think that cut down the search tree a lot in some cases.
15:33:47 <nattfodd> not so surprising considering the low level task
15:33:54 <Heffalump> I wonder if anyone will have overhauled their individual score on any particular problem, let along their overall score.
15:34:02 <Heffalump> int-e: I think operators are commutative and operands commute.
15:34:15 <nattfodd> Heffalump: someone said they were using C++ this year (thank goodness, java winning the icfp would be terrible)
15:34:15 <Heffalump> int-e: fair enough. My search code was too stupid to cope with it well.
15:34:22 <Heffalump> nattfodd: fair enough
15:34:41 <Heffalump> anyone know if any of the top teams were using Haskell?
15:34:52 <nattfodd> no idea
15:34:57 <SamB> is the password cracking program supposed to be able to find a password for user "htb"?
15:35:07 <nattfodd> I think we're one of the only teams to have sticked to a high-level UM anyway :)
15:35:12 <int-e> Heffalump: I had a 'set' with a try operation (monadic) that came with a 'continue trying' operation that didn't consider the previous elements. the concrete representation is a pair of lists.
15:35:14 <nattfodd> SamB: no
15:35:22 <SamB> good
15:35:36 <Heffalump> int-e: yeah, I should have done something like that.
15:35:39 <nattfodd> SamB: some of the passwords can only be found in other accounts, iirc
15:35:52 <SamB> nattfodd: I imagined so
15:35:56 <Heffalump> 'htb'?
15:36:05 <Heffalump> we didn't have a 'htb'.
15:36:22 <SamB> well no wonder it couldn't find a password for that user ;-)
15:36:27 <nattfodd> hum, neither did we :)
15:36:29 <int-e> Heffalump: It's very short, too. http://paste.lisp.org/display/23101
15:36:39 <SamB> I haven't either
15:36:52 <SamB> % ls /home
15:36:52 <SamB> ftd/
15:36:52 <SamB> guest/
15:36:52 <SamB> gardener/
15:36:52 <SamB> ohmega/
15:36:52 <Heffalump> we had guest, howie, ohmega, bbarker, gardener, ftd, yang, hmonk, assistant-root, associate-root, root.
15:36:53 <SamB> yang/
15:36:55 <SamB> howie/
15:36:57 <SamB> hmonk/
15:36:59 <Heffalump> int-e: you're just making me feel bad :-)
15:37:03 <SamB> bbarker/
15:37:14 <nattfodd> Heffalump: grrrr, you got root
15:37:19 <nattfodd> I want the end of that discussion!
15:37:46 <Heffalump> I don't have any problem with msging you the password if you want it.
15:37:52 <nattfodd> if we add the 400 points we got 10 minutes after the deadline, we're only 300 points short or so :)
15:37:59 <nattfodd> nah, that wouldn't be fun
15:38:03 <nattfodd> but thanks :)
15:38:19 <Heffalump> I want to just see solutions for all the stuff I worked on and didn't manage, now.
15:38:26 <int-e> Heffalump: sorry. I didn't mean to.
15:38:35 <Heffalump> cos although I'd like to figure themselves out for myself, I just don't have time
15:38:53 <Heffalump> int-e: it's ok :-) We clearly got rather overcomplicated.
15:38:56 <nattfodd> Heffalump: heh, same, except that I only really worked on adventure and found just after the deadline
15:39:35 <Heffalump> our raytracer only got us 1241 points, did anyone manage more than that?
15:39:48 <Heffalump> (and that was after Igloo spent ages squishing it)
15:39:53 <nattfodd> people had 1280 (or was it 1380?)
15:40:12 <Heffalump> Smartass had 1410 for the whole lot
15:41:11 <nattfodd> looks like they were done 8h before the deadline...
15:41:22 <Heffalump> yeah.
15:41:49 <edwardk> they were working right up to when it froze too, because they last updated circs around that time.
15:42:19 <edwardk> the score kept creepig up by 3 points at a time til the scoreboard froze
15:44:14 <dmhouse> @tell kowey I think we could do with something in the very first chapter (Variables and functions) about the different sorts of values. Introduce numbers, bools, strings and chars. (No types, obviously.)
15:44:15 <lambdabot> Consider it noted.
15:44:20 <shapr> salut mboes
15:56:39 <nattfodd> dmhouse: are you writing a haskell book?
15:57:00 <Heffalump> oh, now I get what was going on with that REDACTED stuff. The RML program has the value with the full string, but can't communicate it to the user?
15:57:15 <nattfodd> yes
15:57:20 <dmhouse> nattfodd: http://en.wikibooks.org/Haskell it's a wikiboook! :) Feel free to peruse and contribute, check out the Notes for contributors if you feel you want to do the latter. :)
15:57:35 <nattfodd> and it taints the whole function each time you even touch the variable
15:57:43 <kosmikus> Heffalump: have you won this time?
15:58:01 <Heffalump> kosmikus: no chance (our final score puts us in 4th place on the 8hours old scoreboard)
15:58:06 <nattfodd> dmhouse: I was more thinking of being a reader than a contributor but thanks :)
15:58:39 <kosmikus> Heffalump: that sounds like a reasonably good result.
15:58:56 <Heffalump> well, I expect it'll leave us somewhere between 10th-20th overall.
15:59:00 <Heffalump> so not really :-)
15:59:11 <kosmikus> was the task fun? I only looked at it a few hours ago, and it was very hard to judge what it really was about ...
15:59:17 <Heffalump> yes, it was really good.
15:59:22 <Heffalump> Best contest ever, I reckon.
15:59:26 <kosmikus> ok
15:59:36 <dmhouse> kosmikus: the Task doesn't reveal much.
15:59:41 <kosmikus> indeed
15:59:47 <kosmikus> that's a bit sad
15:59:50 <Heffalump> They gave us a program written in a virtual machine language, and told us how to implement the VM.
15:59:51 <dmhouse> kosmikus: Once you have a working UM, the _real_ task reveals itself.
16:00:09 <kosmikus> that's what I could see myself
16:00:14 <Heffalump> then you run the program in the VM, get a new program, run that, and discover an operating system with lots of little problems.
16:00:15 <kosmikus> what *was* the task, though? ;)
16:00:19 <Heffalump> (FSVO "little")
16:00:38 <Heffalump> there were 8 or 9 sub problems
16:00:48 <Heffalump> each with points available as you progressed through them
16:00:59 <Heffalump> the columns in http://www.icfpcontest.org/scoreboard.shtml tell you what they were
16:01:02 <lambdabot> Title: ICFP Programming Contest, 2006 : Scoreboard
16:01:09 <dmhouse> @tell kowey to check out the tuples stuff in the newly name Lists and tuples module.
16:01:09 <lambdabot> Consider it noted.
16:01:13 <dmhouse> Right, g'night all.
16:01:43 <kosmikus> yes.
16:02:09 <Heffalump> sorry, they clearly don't tell you what the puzzles were, they just identify them :-)
16:02:28 <kosmikus> you'll have to tell about the details some other time ... I need to get some sleep
16:02:38 * kosmikus is still sad that he couldn't participate
16:10:59 * shapr has a hissy fit
16:11:31 <shapr> Never try to find bugs when tired.
16:14:57 <int-e> hmm, that shouldn't be too bad as long as you don't fix them
16:15:24 <monochrom> Heh.  You heard the saying?  "Code away when you're drunk. Marvel at the type error messages when you're sober."  Not the other way round! :)
16:16:19 <int-e> I love Haskell for prototyping btw. change a data structure, let the compiler complain about all places that need to be changed ;)
16:16:50 <int-e> and it's amazing how often code is correct once it typechecks.
16:22:11 <vincenz> Anyone know prolog?
16:24:32 <JKnecht> prolly a whole bunch.
16:25:46 <JKnecht> SWI is the answer to your question (personlich)
16:30:38 <vincenz> swi doesn't do definitions in interpreter
16:30:46 <vincenz> whichc is bugging me
16:30:48 <vincenz> I want to define some fact
16:30:50 <vincenz> then test em
16:34:54 <JKnecht> right, it has basically a single developer and he's pretty clear on his focus for the product.
16:38:49 * shapr gives up and goes to sleep
16:39:22 <Pseudonym> Actually, what a good idea.
16:39:28 <Pseudonym> Next time I have trouble sleeping, I'll give up first.
16:44:06 <xerox> Night shapr!
16:52:03 <vincenz> JKnecht: apparently it -is- possible
16:52:05 <vincenz> JKnecht: [user]
16:52:06 <vincenz> \o/
16:52:21 <vincenz> prolog seems like a reasonably complex system
16:52:52 <vincenz> yet it's much smaller than haskell community wise it seems
16:52:54 <JKnecht> yeah if do all the stuff required
16:52:56 <vincenz> is research dead in it/
16:53:51 <JKnecht> it's meant to be a production q prolog. There may be an XPCE interface which sets stuff in a kinda Prolog REPL.
16:54:53 <JKnecht> (and you prolly are close to knowing how to create one by now)
16:55:14 <vincenz> ?
16:55:18 <JKnecht> prolly not smaller but less concentrated/active
16:55:40 <vincenz> not sure what you mean by "you prolly are close to knnowing how to create one by now"
16:55:49 <vincenz> enne, blijkbaar gebruiken de belgen prolly
16:56:21 <JKnecht> prolly = wahrscheinlich
16:56:30 <vincenz> dat weet ik wel
16:56:38 <vincenz> oh shoot
16:56:40 <vincenz> I thought you were belgian
16:56:47 <vincenz> I was saying that belgians tend to use prolly
16:56:50 <vincenz> I always use prolly :
16:56:51 <vincenz> :P
16:57:04 <vincenz> but
16:57:09 <vincenz> not sure what you mean by "you prolly are close to knnowing how to create one by now"
16:57:50 <JKnecht> by virtue of having gotten defs working you could add that to a hello world type XPCE bit without modifying core SWI
16:58:28 <JKnecht> bbl
16:58:36 * vincenz nods as if he knows what you mean
16:58:40 <vincenz> XPCE?
16:58:49 <vincenz> toch een belg
17:04:39 <JKnechtWeg> I can't believe that kid asked Kit Lo if he'd come out yet
17:05:02 <JKnechtWeg> sorry
17:41:54 <dons> morning!
17:42:09 <tessier_> Does haskell have closures?
17:42:23 <dons> yes! everything's a closure.
17:42:29 <dons> > map (+1) [1..10]
17:42:30 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:43:10 <Pseudonym> Even something that looks like an integer is sometimes a closure.
17:43:14 <dons> > let f x y = x + y ; g x = f 10 in g 2
17:43:15 <lambdabot>  Add a type signature
17:44:02 <dons> > let f x y = x + y ; g = f 10 in g 3
17:44:03 <lambdabot>  13
17:44:06 <int-e> > (- 1) -- and sometimes something that ought to be a closure is a number
17:44:08 <lambdabot>  -1
17:44:08 <dons> closures for all!
17:44:45 <Pseudonym> Even generic programs are implemented as closures.
17:46:00 <int-e> > let twice f x = f (f x) in twice (*3) 2
17:46:01 <lambdabot>  18
17:48:32 <seafood_> dons: morning.
17:49:26 <tessier_> Interesting.
17:50:06 <tessier_> It would seem that closures are a way of internalizing state to a function.
17:50:39 <ihope_> Is a closure, like... um...
17:50:45 <int-e> some values, maybe. not state though
17:50:56 <ihope_> Like a function constructed at runtime, sorta?
17:50:58 <int-e> in haskell that is.
17:51:52 <Pseudonym> Haskell doesn't really have state in the same way that other languages do.
17:51:52 <Pitarou> > let n_times n f x = if n == 0 then x else f (n_times (n-1) f x) in n_times 2 (*3) 2
17:51:54 <lambdabot>  18
17:52:27 * Pitarou shrugs
17:52:45 <ihope_> s/f (n_times (n-1) f x)/n_times (n-1) f (f x)/ makes it more efficient.
17:52:49 <int-e> I think 'everything is a constant' describes Haskell quite well. (You can define new constants but you can never change a value)
17:53:20 <ihope_> Or s/f \(n_times \(n-1\) f x\)/n_times (n-1) f (f x)/, if you like your regexes to be correct.
17:53:20 * Pitarou nods @ ihope_
17:53:27 <dylan> What would the statement "everything is a closure" mean, then?
17:54:11 <dylan> I assumed it was a joke about laziness...
17:54:21 <int-e> I'd like to know that, too.
17:54:21 <Pitarou> ihoep_: It depends on which particular dialect of "regexp" you are using.
17:54:49 <dylan> there's only like, what? five or six dialects, right?
17:55:11 <Pitarou> dylan: At least!
17:55:17 <dylan> grep, egrep, perl, pcre, ocamllex, ...
17:55:28 <ihope_> And aren't parentheses considered "special" in all of them?
17:55:32 <int-e> posix basic, posix extended, perl, pcre, gnu's versions ... yes. a few.
17:55:44 <int-e> extended regular expressions don't
17:55:48 <Pseudonym> I think boost is posix, but vim isn't.
17:55:56 <Pitarou> dylan: Isn't there a RegExp package for Haskell?
17:56:06 <dylan> I dunno. I'm a recent convert.
17:56:22 <Pitarou> s/dylan:/int-e
17:57:01 <int-e> yes. Text.Regex I think. And it's supposedly slow.
17:57:34 <int-e> "Regular expression matching.  Uses the POSIX regular expression"
17:57:50 <ihope_> Big and ugly and maybe incorrect regex thingy: data Regex = Choice [RegexSomething]; data RegexSomething = Concat [RegexThingy]; data RegexThingy = Kleene RegexWhatever | NoKleene RegexWhatever; data RegexWhatever = Literal Char | Parens [Regex]
17:57:54 <dylan> which POSIX one?
17:58:23 <int-e> it uses the C regex functions and involves marshalling Strings to and from C. extended, apparently.
17:58:50 <wagle> anyone else have trouble displaying the 22nd page of the haskell 98 report on linux?
17:59:13 <Pitarou> wagle: No.  I always use the html version.
17:59:30 <Pitarou> int-e: I thought there was another "Haskell native" RegExp library?
17:59:30 <int-e> in which format anyway?
17:59:34 <wagle> hmm  this is pdf
17:59:57 <wagle> cpu is plugged
18:00:05 <wagle> pegged (rather)
18:00:12 <Pitarou> wagle: There are at least 3 different pdf readers for Linux.
18:00:31 <wagle> this is the default fedora one
18:00:47 <sjanssen> there's been some buzz about Text.Regex.Lazy lately
18:00:57 <Pitarou> Get hold of Adobe Acrobat reader for Linux.
18:01:08 <int-e> Pitarou:  Text.Regex.Lazy   I don't know what its current status is.
18:01:39 <jlhamilton> evince is a pretty good doc viewer
18:01:45 <Pitarou> If it's half as good as Parsec, it would be pretty damn' good.
18:01:51 <dylan> xpdf displayed the haskell 98 report here just fine
18:02:27 <int-e> here, too
18:02:45 <wagle> the default is apparently "Document Viewer", which spins on the ebnf
18:02:57 <wagle> kpdf had no trouble..  sigh
18:03:18 <wagle> thanks all
18:04:10 <wagle> evince is whats spinning the cpu
18:04:59 <wagle> yow..  5 cpu minutes to render the page
18:08:55 <monochrom> Page 22, as in "2.2 Lexical Program Structure"?
18:09:22 <monochrom> Or "3.8 Tuples"?
18:09:30 <wagle> monochrom: page 2 of chapter 2
18:09:51 <monochrom> That's the former.
18:10:04 <monochrom> Took my evince no more than a second.
18:10:06 <Pitarou> Ooh ... news on the nerd grapevine: AMD have just slashed the prices on their 64-bit CPUs.
18:10:11 <monochrom> (For the record.)
18:10:26 <wagle> monochrom: how fast is your cpu?
18:10:52 <int-e> wagle: what's your point of reference?
18:11:05 <monochrom> 1GHz Celeron in laptop, 512MB PC133 RAM, four year old laptop.
18:11:19 <wagle> int-e: ?
18:11:25 <monochrom> Ubuntu 6.06
18:11:47 <int-e> wagle: sorry, physics joke (sort of)
18:12:19 <wagle> monochrom: 600MHz 6 year old notebook..  8)
18:12:22 <int-e> I should probably have said 'system' instead of 'point' for that. but that wouldn't have helped. :)
18:12:33 <wagle> int-e: frame of reference?
18:12:37 <int-e> ah.
18:12:55 <int-e> yes, that's the one.
18:13:10 <Pseudonym> It also depends on the local gravitational field strength, of course.
18:13:31 <wagle> was thinking maybe i was falling into a black hole
18:13:34 <Pseudonym> CPU speed is hard to measure because CPUs, being massive, alter the local spacetime geometry.
18:13:55 <wagle> massively parallel?
18:14:10 <Pseudonym> If it's massively parallel enough, you probably could create a black hole.
18:14:17 <wagle> o_O
18:14:19 <Pitarou> wagle: Maybe the problem is quantity of RAM, not CPU speed?
18:14:20 <monochrom> I think it is not evince.  I think it is fedora.
18:14:32 <wagle> Pitarou: 512 MB
18:14:54 <wagle> fedora did something, i'm sure
18:15:14 <Pitarou> wagle: Okay.  Maybe that's enough.
18:15:15 <wagle> kpdf has no trouble
18:16:11 <monochrom> Or more likely, fedora chose or built a bad version of evince, and ubuntu chose or built a good version of evince.
18:16:46 <monochrom> (Are you sure you are not building GHC in the background at the same time? XD )
18:16:52 <wagle> Version     : 0.5.1
18:17:06 <monochrom> 0.5.2
18:17:45 <wagle> evince pegs cpu all by itself for 5 minutes a page
18:18:54 <wagle> oh well..
18:19:03 * wagle uses kpdf
18:19:27 <monochrom> evince calls a library called "poppler" to do pdf.
18:20:15 <monochrom> The poppler version on ubuntu is 0.5.1
18:20:25 <wagle> Version     : 0.5.1 here
18:20:44 <monochrom> Alright, not too obvious what the problem is.
18:21:14 <wagle> they patched it at least once, though: Source RPM: poppler-0.5.1-2.src.rpm
18:24:24 <wagle> cy'all
18:24:59 * Pitarou wave gobyebye to all.
18:33:06 * notsmack can't build yi
18:33:11 <notsmack> Could not find module `Data.ByteString.Base':
18:33:34 <sjanssen> notsmack: have you installed ByteString?
18:33:54 <notsmack> sjanssen: fps-0.6, yeah
18:34:50 <notsmack> i'm not sure if it's looking the right place for it, but i'm trying default build and install commands on both
18:35:51 <dons> 0.6 sounds too old
18:36:01 <dons> try the darcs version. I think we only added .Base in 0.7
18:36:33 <notsmack> oh, ok, will do.  i believe the configure script wanted fps-any
18:39:16 <DukeDave> is there no 'first index of' function in the prelude or list? I'm not having any luck hoogling
18:39:33 <DukeDave> :: [a] -> a -> Int
18:39:41 <SamB> @hoogle findIndex
18:39:42 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
18:39:42 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
18:40:09 <DukeDave> cheers :)
18:51:55 <notsmack> ah, sjanssen, you're the one adding unicode to bytestring?
18:52:12 <sjanssen> I am indeed
18:52:18 <notsmack> how's that going?
18:53:06 <sjanssen> well
18:53:23 <notsmack> dons: darcs fps fixed it, thanks
18:59:48 <lispy> C style #defines used to create enums are a ridiculous idea...
19:07:30 <dons> in haskell?
19:07:55 <dons> or C. if its C, then anything goes -- i expect the worst ;)
19:09:24 <lispy> :)
19:09:36 <lispy> yeah, i had to add a menu item to this HUGE C++ program
19:09:45 <lispy> to do it i needed a unique id
19:09:54 <Korollary> why not an enum?
19:10:15 <lispy> is my new id unique?  well, i don't see an exact textual match for the number i chose...
19:10:32 <lispy> Korollary: perhaps legacy reasons
19:25:53 <DukeDave> Hey gang, I wish to make a class an instance of Show, however the class is overloaded. In showing the class I need to enforce that the overloading class implements Show, but hugs doesn't like it?
19:28:00 <DukeDave> so       Foo a = Bar a;     instance Show (Foo a) where show x = draw x;      draw :: Show a => Foo a -> String
19:28:23 <Cale> DukeDave: which class?
19:28:39 <Cale> Show is overloaded?
19:28:55 <DukeDave> Foo is my new type, overloaded to type a
19:29:03 <DukeDave> is that the correct terminology?
19:29:09 <Cale> how are you declaring Foo?
19:29:19 <kpreid> DukeDave: you want instance (Show a) => Show (Foo a) where ...
19:29:42 <DukeDave> data Foo a = myConstructor a
19:30:49 <DukeDave> kpreid, thanks, that both makes sense and resolves my problem :)
19:31:01 <DukeDave> a rare combination I find
19:32:51 <DeeJay> hi all, i'd like to ask a quick question about StablePtr's, could anyone explain to me when you might use "castStablePtrToPtr"?
19:34:09 <DeeJay> I have a small toy program which passes a value of type StablePtr (Maybe Int) to a C function, and it works fine... so was wondering what the use of casting it to a straight Ptr might be
19:37:30 <DeeJay> I guess everyone is exhausted after the ICFP ;)
19:38:51 <Cale> DukeDave: data Foo a = MyConstructor a ?
19:39:05 <Cale> (constructors have to start with a capital letter)
19:39:31 <Cale> instance Show a => Show (Foo a) where show x = draw x
19:39:42 <Cale> or rather
19:39:53 <Cale> instance Show a => Show (Foo a) where show (MyConstructor x) = draw x
19:40:05 <Cale> er, no, nm
19:44:21 <DukeDave> yes, sorry
19:44:42 <DukeDave> thanks for the help, am sorted :)
19:45:00 <DukeDave> so, I'll pessimistically, brb
20:09:47 <spaecious> I did a quick search to see if Haskell supports multi-line strings, like python's triple-quote, and I couldn't find anything. Can anyone confirm or deny that Haskell does not have multi-line strings?
20:10:48 <Korollary> \ at the end of the line works afaik
20:12:20 <sjanssen> spaecious: Haskell does indeed have mult-line strings
20:12:39 <sjanssen> it isn't particularly well known though
20:12:53 <spaecious> s = "asdf\
20:12:53 <spaecious> zxcv" doesn't work Korollary. It says "Missing `\' terminating string literal gap.
20:13:05 <spaecious> sjanssen: what's the syntax?
20:13:27 <spaecious> that's great news. i was thinking it would the first thing haskell didn't have that i'd wanted ;)
20:15:42 <sjanssen> spaecious: http://haskell.org/onlinereport/lexemes.html see section 2.6
20:15:43 <lambdabot> Title: Haskell 98 Lexical Structure
20:16:39 <sjanssen> essentially it's \ at the end and beginning of the line
20:18:58 <spaecious> great, thanks, not quite as convenient as python's triple-quote but not so bad. slightly inconvenient that you can't cut and paste 10 lines into a file without adding the backslashes, but much better than nothing..
20:38:25 <petekaz> ffi newbie question, I'm looking at some ffi examples, and I see things like this line: #poke struct rlimit, rlim_cur, where is this #poke documented?
20:40:04 <petekaz> I'm just trying to figure out construct a structure so I can pass it to a C call.
20:41:24 <RyanT5000> #poke is from a hsc file isn't it?
20:41:27 <petekaz> So far it seems all I need to do is 'allocaBytes (#const sizeof(struct timeval)) $  \p_timeval -> do' and then a bunch of #pokes.
20:41:46 <RyanT5000> that's HSC-related stuff
20:41:59 <RyanT5000> which is useful if you want the struct defined in a .h file
20:42:11 <RyanT5000> that's about as much as i know about it though
20:42:11 <petekaz> HSC is a tool?
20:42:16 <RyanT5000> yeah, i think it's called HSC2HS
20:42:24 <RyanT5000> greencard is related, but different
20:42:25 <petekaz> I want to do my first simple example of FFI manually.
20:42:36 <RyanT5000> then just look up Foreign.Ptr
20:42:46 <RyanT5000> you can peek and poke bytes off of it
20:42:50 <RyanT5000> also look at Foreign.Storable
20:43:04 <RyanT5000> but that would be peek and poke, not #peek
20:43:16 <petekaz> which is the one I use if I want to create a C structure object in haskell to pass to a C FFI call?
20:43:48 <RyanT5000> yeah
20:43:58 <RyanT5000> oh you mean which of those?
20:44:02 <petekaz> yes.
20:44:09 <RyanT5000> well if you use something which implements Storable
20:44:11 <RyanT5000> you can just pass it
20:44:26 <RyanT5000> if you want to actually implement Storable, you'll probably need to use a Ptr
20:44:36 <petekaz> I see.
20:44:40 <RyanT5000> just look in the haddock for those two, you'll probably be able to figure it out
20:44:48 <petekaz> Ok
21:04:24 <dons> ?uptime
21:04:24 <lambdabot> uptime: 6 days, 12 hours, 19 minutes and 58 seconds
21:04:29 <dons> good lambdabot
21:25:17 <petekaz> RyanT5000: couldn't figure it out by the docs, so I just looked at the code outputted from hsc.
21:30:15 <petekaz> Is there a function that will let me determine the number of haskell processes (forkIO) and OS threads are currently running?
21:30:54 <RyanT5000> no idea
21:31:01 <RyanT5000> maybe in System.Process?
21:35:28 <RyanT5000> is amap lazy?
21:36:15 <RyanT5000> if i map it across a huge array, is it going to use a huge amount of memory?
21:37:31 <lispy> @type amap
21:37:33 <lambdabot> Not in scope: `amap'
21:38:33 <lispy> @hoogle amap
21:38:34 <lambdabot> Data.Array.IArray.amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
21:43:58 <RyanT5000> i'd rather not copy several kilobytes of boxes just to read a small number of them
21:44:05 <AI_coder> Does anyone think haskell is reminiscent of perl?
21:45:14 <RyanT5000> lol definitely not syntactically
21:49:12 <dons> AI_coder: in what way?
21:54:02 <dons> petekaz: there's no magic functoin, no.
21:55:55 <AI_coder> I guess I just find the syntax more concise than other languages, omission of parentheses and other niceties.
21:57:02 <dons> yeah, that's true. syntax was a big consideration in the early days of the language
21:58:37 <Pseudonym> You know, a lot of people think Haskell is a lot like Perl, but nobody knows why.
21:58:42 <Korollary> I don't.
21:58:57 <Pseudonym> I think it's because they both draw heavily on Zen.
21:59:02 <dons> heh
21:59:15 <Pseudonym> However, I know what Larry Wall would say.
21:59:17 <RyanT5000> i have a hard time comparing a language without side-effects to a language with implicit side-effects
21:59:27 <Pseudonym> Perl and Haskell are 20% language and 80% culture.
21:59:32 <dons> or http://www.cse.unsw.edu.au/~dons/pretty.html
21:59:33 <lambdabot> Title: pretty.hs
21:59:39 <Pseudonym> I think that's the real parallel.
21:59:41 <audreyt> also, they both attract golfers.
21:59:41 <dons> kind of reveals one link.
21:59:50 <dons> ryeah.
22:00:00 <audreyt> as in, people who actively reduce the program length
22:00:07 <Korollary> Well, there is the lack of a benevolent dictator, yeah.
22:00:15 <RyanT5000> dons, why did you write that?
22:00:22 <RyanT5000> or did someone else
22:00:28 <dons> to see if it was possible :)
22:00:31 <RyanT5000> lol
22:00:37 <RyanT5000> what does it do?
22:00:51 <dons> it was some cs101 ssignment problem
22:01:00 <dons> i think the idea was to find anagrams in a dictionary file
22:01:03 <RyanT5000> haha ok i would've done something like that too
22:01:19 <RyanT5000> i turned in some of those in assembler and stuff
22:01:21 <RyanT5000> it was fun
22:01:45 <dons> hehe
22:03:03 <Pseudonym> Now there's another example.
22:03:05 <jmob> Is ... actual haskell syntax?
22:03:09 <Pseudonym> people just doing things to see if it's possible.
22:03:21 <Pseudonym> Is it possible to write a regex that only matches prime-length strings?
22:03:30 <RyanT5000> jmob: i think you could define ...
22:03:36 <Pseudonym> That sort of thing.
22:03:53 <dons> > let x ... y = x ++ y in "maybe" ... "yes"
22:03:55 <lambdabot>  "maybeyes"
22:04:01 <sseefried> Regex's are quite limited aren't they?
22:04:26 <jmob> Pseudonym: That requires state, which regexs lack
22:04:35 <dons> well, you could do it in sed. but you'd need state.
22:04:38 <Pseudonym> dons, that's a work of art.
22:04:49 <dons> thanks :)
22:04:58 <Pseudonym> jmob: Posix regexes have back-references.
22:05:22 <dons> i'm particularly happy that there's no keywords, let ,case , do ...
22:05:31 <dons> its all lambdas
22:05:34 <Pseudonym> \(..*\)(\1)+ matches composite-length strings
22:05:55 <dons> hmm, with back refs. yes, maybe.
22:06:07 <dons> that's how you implement lookup tables in sed
22:06:13 <Pseudonym> Right.
22:06:20 <Pseudonym> Assuming you're insane enough to do that.
22:06:25 <jmob> I don't know what back-refs are.
22:06:27 <dons> and with lookup tables you can count
22:06:29 <Pseudonym> Really, if you need lookup tables, you should learn awk at least.
22:06:38 <Pseudonym> Or Perl, perhaps.
22:06:52 <dons> unless you just want to see if it is possible
22:07:00 <Pseudonym> Well, yes.
22:07:01 * notsmack is skeptical it's possible
22:07:29 <jmob> Pseudonym: Why would you use Perl if you can avoid it?
22:07:53 <Pseudonym> Because it's the right tool for the job?
22:07:57 <Pseudonym> Or _a_ right tool?
22:08:00 * Pseudonym did suggest awk
22:08:18 <notsmack> it's _a_ tool
22:09:05 <jmob> Pseudonym: there's so many other "right" tools... probably any language with regexes and state.
22:10:23 * jmob is working on a regex library for bf
22:10:56 <Pseudonym> There's also the conciseness issue.
22:11:21 <Pseudonym> The amount of work to invest should be proportional to the inherent complexity of the problem.
22:11:25 <jmob> Java is teaching the world that concise doesn't matter.
22:11:29 <Pseudonym> Or less if you have a decent library.
22:11:38 <jmob> Programs should read like Hemmingway novels.
22:11:59 <Pseudonym> Oooh, good idea!
22:12:01 <RyanT5000> long variable names != inconcise
22:12:13 <Pseudonym> I hereby coin... Hardytran
22:12:22 <jmob> Sorry, sans one m
22:12:40 <Pseudonym> A Saturday afternoon was approaching the time of twilight, add one to counter.
22:13:05 <RyanT5000> i'm not saying there aren't other properties of Java that lead to inconciseness, though
22:13:06 <jmob> RyanT5000: however, there seem to be so many other aspects of java that are inconcise
22:13:12 <RyanT5000> yeah
22:13:18 <jmob> RyanT5000: oh, okay
22:13:35 <jmob> long variable names do come to mind though
22:13:48 <RyanT5000> well with a java-centric IDE they aren't really an issue
22:14:10 <RyanT5000> (btw, i'm quite anti-Java, so don't presume that because i defend long variable names i defend anything else in the language)
22:14:32 <jmob> RyanT5000: any "IDE" with string completion is long variable name friendly
22:14:48 <jmob> RyanT5000: my 80 column teletype isn't though
22:14:49 <RyanT5000> well that's kinda what i meant
22:14:59 <Pseudonym> There's long and there's long.
22:15:03 <RyanT5000> lol
22:15:06 <RyanT5000> this is true
22:15:26 <RyanT5000> concisely self-documenting names are reasonable though, imo
22:15:31 <Pseudonym> The odd bastardisation of Hungarian convention favoured by Windows programmers is length for the sake of length.
22:15:37 <RyanT5000> lol yes
22:15:53 <RyanT5000> LPCSTR
22:15:57 <Pseudonym> Right.
22:16:17 <RyanT5000> i don't understand why that's ever better than CSTR *
22:16:29 <Pseudonym> Oh, that's historical.
22:16:44 <RyanT5000> when long pointers were different from short pointers?
22:16:46 <Pseudonym> The "L" means "long".
22:16:47 <Pseudonym> Right.
22:16:51 <RyanT5000> yeah, i suppose
22:16:57 <RyanT5000> so maybe that's reasonable
22:17:11 <Pseudonym> The thing is, the original Hungarian convention was about semantic types.
22:17:12 <RyanT5000> but it's really the variable name prefixes that are the problem
22:17:20 <Pseudonym> rCell and cCell for row and column.
22:17:24 <RyanT5000> right
22:17:25 <Pseudonym> not iRow and iCol
22:17:41 <Pseudonym> Which makes sense.
22:17:49 <Pseudonym> A lot of people follow similar conventions.
22:18:09 <jmob> Okay, figure out this one: pawsz
22:18:24 <RyanT5000> obviously a zero-terminated string of paws
22:18:34 <RyanT5000> probably rabbit paws, for good luck
22:18:34 <Pseudonym> I think it's the size of a paw.
22:18:50 <jmob> pointer to an array of wide zero terminated strings.
22:19:06 <RyanT5000> i see
22:19:07 <Korollary> wide zeroes are nice.
22:19:13 <RyanT5000> lol
22:19:23 <Pseudonym> Type checking is the compiler's job.  Checking the intent is the programmer's job.
22:19:32 <Pseudonym> So your variable names should encode intent, not physical type.
22:20:05 <Korollary> Pseudonym: Right, but they get lost in the api as to whether to take the address of this variable while passing to so and so function, etc.
22:20:29 <RyanT5000> so... does anyone know if amap is expensive on large arrays?
22:21:24 <Korollary> They could have used an IDE that showed the argument types as you typed. Oh well. Water under the windows.
22:21:38 <jmob> I'm reading "A physical analogy for monads" (http://tinyurl.com/osvs6) and it using "...", presumably to indicate that they didn't what to write out a real definition.
22:21:40 <lambdabot> Title: A physical analogy for monads
22:21:55 <RyanT5000> that seems reasonable
22:21:57 <jmob> ...but I wanted to actually write the code for producing chopsticks, so I was disappointed.
22:22:35 <sjanssen> @hoogle amap
22:22:36 <lambdabot> Data.Array.IArray.amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
22:23:16 <sjanssen> RyanT5000: expensive in what way?
22:24:00 <Pseudonym> Clearly it constructs a new array.
22:24:25 <Pseudonym> I would think that it wouldn't be strict unless it was an unboxed array.
22:24:33 <RyanT5000> well if i have an array with a million elements, is it going to use 4 MB?
22:24:42 <Pseudonym> Yeah.
22:24:47 <RyanT5000> k
22:24:57 <Pseudonym> Plus memory for the thunks.
22:25:00 <RyanT5000> right
22:25:52 <RyanT5000> alright, so i guess i'll make a type MapArray that doesn't do that
22:25:54 <jmob> @hoogle type
22:25:55 <lambdabot> Prelude.type :: keyword
22:25:55 <lambdabot> Network.Socket.Type :: SocketOption
22:25:55 <lambdabot> Language.Haskell.TH.Type :: data Type
22:26:12 <sjanssen> and the thunks will likely require the original array
22:26:29 <RyanT5000> sjanssen: yeah, well i don't plan on getting rid of the original array anyway
22:26:34 <jmob> type -> "Please write this"
22:26:45 <Korollary> I got a nice book on Theory of Computation for $15. I love the internets.
22:27:10 <RyanT5000> the idea is i have something like an array of (Terrain, Set Unit), and i want to pass an array of just terrain to a function
22:29:23 <sjanssen> yeah, amap would have to touch every element of the original array before you could perform lookups
22:29:39 <RyanT5000> how about for Maps and such?
22:29:42 <RyanT5000> same problem?
22:29:46 <RyanT5000> seems like it'd have to be
22:30:02 <sjanssen> I'm not sure if Map uses a strict constructor
22:30:10 <RyanT5000> ah true
22:30:26 <RyanT5000> well i guess, other than arrays, i'll just fix it if it's too slow
22:30:31 <Korollary> Why does it need to be strict?
22:30:35 <sjanssen> yes, Data.Map uses strict constructors
22:30:42 <RyanT5000> ah dang
22:31:18 <RyanT5000> is there a general solution to this problem?
22:31:23 <RyanT5000> am i missing something?
22:31:52 <Korollary> What is the problem?
22:32:02 <RyanT5000> my situation is that i have multiple representations of a game board
22:32:43 <RyanT5000> some functions require some things from some of those representations
22:33:02 <RyanT5000> so like drawBoard might require just the terrain and units
22:33:20 <RyanT5000> but other functions might require an index or something
22:33:38 <RyanT5000> basically the board type needs to be extensible wrt most of the functions that operate on it
22:33:43 <sjanssen> hmm, I wonder if Data.Map really should be strict . . .
22:35:04 <sjanssen> depending on your needs, you could pass a function rather than an array
22:35:39 <RyanT5000> hm
22:36:06 <RyanT5000> i'd have to pass the size too, but that might not be so bad
22:36:07 <sjanssen> that's only reasonable if you only need lookup
22:36:11 <RyanT5000> yeah
22:36:19 <RyanT5000> i potentially want to use the same concept for updates
22:36:23 <Korollary> your board doesn't grow, so it is surely an array and not a list or map.
22:36:29 <RyanT5000> right
22:36:34 <RyanT5000> but other things are Maps
22:36:40 <RyanT5000> and i want to do the same thing on them
22:37:08 <RyanT5000> here's one thing, for instance, that is a huge difference
22:37:16 <RyanT5000> i have a client and a server
22:37:30 <RyanT5000> they share the same core datastructure and algorithms
22:37:45 <RyanT5000> obviously, they both have a concept of Board, Unit, etc.
22:37:58 <RyanT5000> but, e.g.: the client has Notes on tons of stuff
22:38:09 <Korollary> I don't think the client's board is the same board
22:38:12 <RyanT5000> which are sort of like a tiny web forum on each interesting object in the game
22:38:19 <RyanT5000> right, they're not the same board
22:38:42 <jmob> Will lambdabot accept data declarations?
22:38:47 <RyanT5000> no
22:38:48 <sjanssen> jmob: no
22:39:01 <RyanT5000> but even if they're not the same board, they both need some of the same operations
22:39:13 <RyanT5000> e.g.: looking up the units in a cell, or looking up the position of a unit
22:39:26 <RyanT5000> why should i have to write all that stuff twice?
22:39:33 <RyanT5000> or 3 times, or whatever
22:40:05 <RyanT5000> let's say, for the sake of argument, the client's Board is strictly more powerful than the server's board
22:40:13 <RyanT5000> so then the lookup function should work on the server's board
22:40:24 <RyanT5000> but how can the client efficiently pass a server board to that function?
22:40:55 <Korollary> well, to use OO terms, ClientBoard and ServerBoard may share some interface methods, but depending on your goals, they may or may not share the implementation.
22:41:22 <RyanT5000> yeah, exactly, and i have no idea how to do that, lol
22:41:27 <RyanT5000> in haskell, that is
22:41:38 <RyanT5000> in an OO language i basically know what i'd do
22:41:43 <jmob> ?paste
22:41:44 <lambdabot> http://paste.lisp.org/new/haskell
22:42:47 <lisppaste2> jmob pasted "chopsticks" at http://paste.lisp.org/display/23122
22:42:59 <Korollary> Similarly, you need an analysis phase where you determine whether or not they are alike and share anything
22:43:34 <RyanT5000> right, but i don't even understand the transliteration into haskell to begin with, which is why i'm asking
22:43:47 <RyanT5000> let's say, in OO terms, we have B derives A
22:43:59 <RyanT5000> and a function that operates on A's
22:44:01 <sjanssen> jmob: you'd remove the 'w' type variable, and write "data Chopsticks = WoodCStix Wood"
22:44:07 <RyanT5000> how do we do this in haskell?
22:44:23 <Korollary> RyanT5000: How do you know B derives A without doing OOA?
22:45:00 <RyanT5000> Korollary, i'm saying, if we did OOA (oo analysis?), and determined that B derives A, how do we deal with that in haskell?
22:45:10 <RyanT5000> typeclasses?
22:45:19 <Korollary> Well, we can't do the exact same analysis surely.
22:45:19 <jmob> ah ha, nifty, sjanssen thanks
22:47:49 <sjanssen> surely the relationship between A and B in Haskell would be: class (A t) => B t where ...
22:47:59 <RyanT5000> should it be a typeclasses thing?
22:48:05 <Korollary> But, you can easily create a core type and functions that operate on it, and define another type that contains it.
22:48:22 <RyanT5000> true, but not necessarily with proper nesting semantics
22:48:47 <Korollary> I don't follow.
22:48:48 <RyanT5000> e.g.: if you do it with the board/terrain/units example, you end up having two arrays, which means you have to manually synchronize their sizes
22:49:18 <RyanT5000> basically you'd end up with a pair of arrays when you should end up with an array of pairs
22:49:59 <Korollary> I don't remember the example.
22:50:41 <lispy> RyanT5000: have you seen the way wxHaskell encodes the inheritance tree in the haskell type system?
22:50:54 <RyanT5000> lispy, no; i'll look at that though
22:51:21 <lispy> RyanT5000: i looked but didn't spend a lot of time on it.  I remember being a bit confused
22:51:37 <RyanT5000> maybe classes really are the right thing here
22:52:27 <RyanT5000> i only need static polymorphism
22:52:46 <Korollary> How would you write this in C?
22:53:00 <RyanT5000> hm, not sure about C
22:53:21 <RyanT5000> C++ i guess i'd make an inheritance hierarchy
22:53:29 <Korollary> forget C++
22:53:39 <Korollary> You have two boards
22:54:00 <Korollary> what are the common operations?
22:54:19 <RyanT5000> erm, lookups, i guess
22:54:23 <RyanT5000> that's probably it
22:55:15 <Korollary> so, typedef an array and define a function that does the lookup. For the server board, create a struct that contains the array.
22:55:49 <Korollary> the server board would have a wrapper function that calls the other function on the struct member.
22:55:54 <RyanT5000> yeah, that'll work, but something definitely rubs me the wrong way about having two arrays that must be the same size
22:56:33 <Korollary> How does OO solve that problem?
22:56:38 <RyanT5000> it doesn't
22:57:04 <Korollary> These arrays are on different machines, right?
22:57:20 <Korollary> or processes, etc.
22:57:21 <RyanT5000> no, the client would have both
22:57:28 <RyanT5000> and the server would only have the server version
22:58:28 <Korollary> It's odd that the client knows more than the server
22:59:06 <RyanT5000> well, in this example i'm ignoring the things that the server would know that the client wouldn't
22:59:10 <RyanT5000> in reality you'd have 3 versions
22:59:23 <RyanT5000> one common to client and server, and then a specialized one for each
22:59:34 <RyanT5000> the client would store, e.g.: notes the user makes to himself
22:59:40 <Korollary> Ok, on a process that has both boards, you can have a constructor function to hide array creation to ensure that they are created equal.
23:00:14 <RyanT5000> yeah, i suppose
23:00:53 <RyanT5000> doesn't that seem stupid though? without worrying about the details, doesn't it seem like having two arrays is worse?
23:01:13 <Korollary> You said you needed two arrays.
23:01:27 <RyanT5000> well i need a pair of arrays or an array of pairs
23:01:35 <RyanT5000> array of pairs seems cleaner
23:02:15 <RyanT5000> i mean if the server needs an array of (a, b) and the client needs an array of (a, c)
23:02:21 <jmob> How would you describe data "hierarchies" in haskell?  Say I have a type Material, and Wod and Metal should "derive" from that type?
23:02:22 <RyanT5000> and some operations only depend on an array of a
23:03:11 <lispy> jmob: i'd like to know the answer to that as well
23:03:22 <RyanT5000> as would i, lol
23:03:23 <sjanssen> jmob: usually, we avoid the hierarchy
23:03:35 <lispy> jmob: in the Prelude the num types are does as type classes
23:03:40 <sjanssen> data Material = Wood | Metal -- a material is wood or metal
23:04:12 <sjanssen> now, you might have a problem when you want to add plastic, so that method has it's limits
23:04:53 <lispy> yeah, but if material was an interface you could add new instances as you need them
23:05:07 <lispy> so i guess that's the argument for using a type class
23:08:57 <jmob> sjanssen: What about different types of Wood/Metal?
23:13:41 <lispy> data Material a = Wood a | Metal a
23:14:07 <RyanT5000> what if there were extensible datatypes?
23:14:59 <RyanT5000> extensible Material
23:14:59 <RyanT5000> extend Material = Wood
23:14:59 <RyanT5000> extend Material = Metal
23:15:37 <RyanT5000> i don't think that's equivalent to existentials
23:16:06 <RyanT5000> you could only pattern-match against constructors you've imported
23:19:49 <Korollary> Well, thereis no subtyping in Haskell98, so there are no type hierarchies.
23:20:39 <Pseudonym> The common way to simulate extensible datatypes in Haskell at the moment is to use typeclasses.
23:21:02 <Korollary> GHC extensions also allow a few other tricks.
23:21:05 <Pseudonym> It uses about 250 milli-Olegs of type hackery.
23:21:12 <Pseudonym> Yes, you need GHC extensions.
23:21:45 <Pseudonym> Basically, what you would consider to be a data constructor becomes its own type.
23:22:05 <Pseudonym> And what you would consider to be a function which operates on the algebraic type becomes a type class.
23:22:17 <Pseudonym> It's a visitor pattern, more or less.
23:47:13 * edwardk waves hello.
23:48:46 <Korollary> hi
23:49:23 * edwardk gives up and adds pretypes to his substructural thingy. =(
23:50:15 <edwardk> I was hoping to avoid them coz they bloat the syntax.
23:50:19 <Korollary> What is a pretype?
23:50:52 <edwardk> its a type without an annotation about what substructural conditions can apply (linear, relevant, affine, unrestricted, ordered)
23:52:22 <edwardk> I was originally working around it by just expanding the set of sorts, but then if I extend the IL do include pointedness and a polytype/monotype split so that its impredicative and has a nicer theory, then the my set of sorts (in particular my number of explicitly enumerated kinds) explodes
23:52:41 <edwardk> er so that its not impredicative
23:53:21 <edwardk> er and explicitly enumerated 'sorts of sort kind'.
23:53:32 <edwardk> to be pedantic
23:55:15 <edwardk> Mostly playing around with the pure type system thing because it seems that all of the literature on substructural systems kinda missed the boat on all the tricks that a pure type system lets you unify in the syntax and semantics (foralls, ->, etc all become Pis).
23:55:29 <edwardk> So one set of logic does most of your work on terms, types and sorts.
23:55:39 <edwardk> er terms types and kinds.
23:56:52 <Korollary> What are you doing?
23:57:03 <Korollary> err, I mean the nature of the project.
23:57:39 <edwardk> playing with substructural logics in a pure type system setting, so i can bang out a thesis before fall semester, so there won;t be an issue with me holding 3 jobs on campus. =)
23:58:18 <Korollary> ah ok
23:58:29 <edwardk> but the general idea is I want to bring the substructural lambda calculus stuff that was done in "lambda refURAL" into a nicer theoretical context.
23:59:20 <edwardk> the "lambda refURAL" ext. tech report is like 200 pages. It shouldn't be that long. It doesn't have that much substance. Moving to a better theoretical framework gives you a more powerful proof framework, and would make the system less 'fragile'
23:59:31 <edwardk> coz, right now its monolithic and hard to extend.
23:59:44 <edwardk> by contrast a pure type system is readily extended by adding more sorts.
