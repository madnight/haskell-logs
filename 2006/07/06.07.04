00:17:41 <kzm> tato, mlh: you can still write thin wrappers with extern "C", and mangle names manually where needed.  At least that way it'll be portable.
00:30:00 <falconair> if anyone is aware of the "Scheme in 48 hours" tutorial, are the code examples in that tutorial considered "point free"?
00:34:07 <kzm> When heap profiling (-hd), I get stuff like Data.Map.sat_xyz
00:34:18 <kzm> Am I correct in thinking these are unevaluated thunks?
00:36:41 <kzm> I do 'foldr1 (unionWith (+)) ss' where ss :: [Data.Map a Int] -- do I need to implement my own unionWith for this to be strict enough?
00:41:36 <Lemmih> falconair: I doubt it.
00:44:38 <kzm> Apparently it is faster just to try things than to wait for an answer :-)
00:44:59 <kzm> The result is: with lazy unionWith: crash out of memory (4Gb) after 100 minutes
00:45:23 <kzm> With homegrown strict union, produce result after ten seconds.
00:45:35 <kzm> (not enough time to check memory consumption with 'top' :-)
00:47:18 <kzm> ...so the question becomes: is lazy-by-default the right choice for Data.Map?
00:49:27 <kzm> Whee!  Paper accepted!
00:49:51 * kzm opens a bottle of virtual champagne.
01:02:04 <mnislaih> @seen Lemmih
01:02:05 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 20 minutes and 28 seconds ago.
01:02:12 <mnislaih> lemmihh
01:02:36 <mnislaih> I just got my account for the repository from Simon
01:22:35 <dcoutts> JaffaCake, re bug 809, did you mean just compiling the hello world prog with -optc-fno-unit-at-a-time or did you mean rebuilding ghc-6.4.2 with that flag?
01:22:40 <dcoutts> http://hackage.haskell.org/trac/ghc/ticket/809
01:22:42 <lambdabot> Title: "#809 (SplitObjs option doesn't work when compiling ghc with gcc 4.x) - GHC - Tra ..."
01:22:58 <JaffaCake> dcoutts: no, one of the modules that should be split
01:23:00 <JaffaCake> eg. GHC.Base
01:23:32 * dcoutts doesn't follow exactly
01:26:20 <dcoutts> JaffaCake, so I need to rebuild the base lib with -optc-fno-unit-at-a-time
01:26:41 <JaffaCake> Just one module should be enough to tell us whether it works or not
01:27:15 <JaffaCake> i.e go into libraries/base, rm GHC/Base.o; make GHC/Base.o EXTRA_HC_OPTS=-optc-fno-unit-at-a-time
01:27:40 <JaffaCake> then have a look at the sizes of the modules in GHC/Base_split
01:27:50 <dcoutts> ok
01:28:19 <Lemmih> mnislaih: Great. I see that the repo is up and running.
01:29:54 <mnislaih> I'm upping my patches now
01:30:08 <mnislaih> Lemmih: I did get --partial from the main ghc repo
01:30:18 <mnislaih> Should I have used the ghc.partial repo instead ?
01:30:48 <dcoutts> JaffaCake, it works
01:30:54 <JaffaCake> ok, cool
01:31:01 <JaffaCake> I'll commit the fix
01:31:11 <Lemmih> mnislaih: No, I think you did it the right way.
01:31:18 <dcoutts> instead of GHC/Base_split/Base__1.o at 56k we get hundereds of little .o files
01:31:28 <JaffaCake> great
02:35:01 <dcoutts> @hoogle system
02:35:01 <lambdabot> System.system :: String -> IO ExitCode
02:35:02 <lambdabot> System :: module
02:35:02 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
02:43:21 <dcoutts> JaffaCake, sent a hsc2hs patch to make it's failures less confusing
02:43:34 <JaffaCake> ok, thanks
02:43:54 <dcoutts> JaffaCake, oh, I had a Q about configureisms
02:44:10 <JaffaCake> go ahead?
02:44:24 <dcoutts> JaffaCake, we're working on a patch to make ghc produce .o files that do not need an exec stack
02:44:37 <dcoutts> it's two parts, one for -fvia-C and one for -fasm
02:44:46 <dcoutts> the -fiva-C is a mangler patch
02:44:47 <JaffaCake> ok, sounds good
02:45:02 <dcoutts> the -fasm bit is to output another line into the asmbely
02:45:10 <JaffaCake> right
02:45:14 <dcoutts> however it should probably only go in for GNU LD
02:45:21 <dcoutts> I think
02:45:30 <dcoutts> I'm not sure other linkers will grok it
02:45:39 <dcoutts> or maybe I mean assemblers
02:45:50 <xerox> Howdy men :)
02:45:52 <dcoutts> it's certainly a gnu toolchain thing
02:46:00 * dcoutts finds the patch
02:46:02 * xerox yarrs astrolabe 
02:46:26 <dcoutts> ./compiler/nativeGen/AsmCodeGen.lhs
02:46:32 <dcoutts> JaffaCake, I want something like:
02:46:33 <dcoutts> #if HAVE_GNU_NONEXEC_STACK
02:46:37 <dcoutts> Pretty.$$ Pretty.text ".section .note.GNU-stack,"",@progbits"
02:46:40 <JaffaCake> dcoutts: there should probably be a configure check for it then
02:47:29 <JaffaCake> add a little test to aclocal.m4 to see whether you can compile & link a .s with that line in it
02:47:32 <Lemmih> xerox: How's code?
02:47:33 <dcoutts> JaffaCake, I guess it's much like the HAVE_SUBSECTIONS_VIA_SYMBOLS bit that's already there
02:47:41 <JaffaCake> yep
02:48:24 <xerox> Lemmih - Yesterday night we me and Isaac agreed on some higher level on the goals of the project, I'd like to know your opinions too in fact :)
02:53:07 <Lemmih> xerox: Are you guys IRCing or mailing?
02:53:27 <ndm> @seen dons
02:53:28 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 4 hours, 48 minutes and 2 seconds ago.
02:53:29 <xerox> IRCing && mailing
02:58:18 <JaffaCake> Lemmih: I like the idea of adding conditional breaks to various places automatically
02:58:41 <JaffaCake> maybe we should only do it for function entry points, though
03:00:13 <xerox> Lemmih: audreyt teared off xmlrpc completely, but the dependency chains are not polished, and that work needs finishing
03:00:56 <xerox> Then it's matter of agree on what to do with the other dependencies, and slim out hackageDB too.
03:01:30 <xerox> It will just be a hierachy of files and an index, and the (ssh+)put tool.
03:01:56 <xerox> Isaac told me the web frontend can be left out for the moment, and maybe put together afterwards.
03:02:49 <ndm> @tell dons I have an initial version of my Haskell suggestion thing done if you want to have a hack
03:02:49 <lambdabot> Consider it noted.
03:07:01 <ndm> @tell dons darcs get http://www.cs.york.ac.uk/fp/darcs/drhaskell :)
03:07:01 <lambdabot> Consider it noted.
03:07:51 <mnislai2> JaffaCake: Do you think it'll be possible to rewrite the condition of the breakpoint directly in the BCOs ?
03:08:02 <norpan> dr. haskell?
03:09:04 <ndm> norpan: you write stuff like "concat (map f x)" - it automatically suggests maybe you should use concatMap here
03:09:35 <roconnor> f >>= x
03:09:50 <int-e> f =<< x
03:09:51 <norpan> ndm: huh
03:09:55 <norpan> interesting
03:10:07 <int-e> roconnor: and that mistake says it's a bad idea ;)
03:10:12 <roconnor> ;)
03:10:24 <roconnor> >>= is always a bad idea
03:10:33 <int-e> no.
03:10:41 <roconnor> I never remember which way things go
03:10:41 <norpan> >>= is good
03:10:47 <ndm> its not a very good implementation yet - can match concatMap and map map, but not much else - only wrote it in about 20 mins
03:10:48 <norpan> follow the arrows
03:10:59 <ndm> dons said he wanted to hack it a bit
03:11:08 <roconnor> oh right
03:11:27 <roconnor> f >>= x means take f and apply it to x ;)
03:11:32 <norpan> i never use =<< though
03:11:53 <xerox> Lemmih: any ideas?
03:11:57 <int-e> there's something to be said for x <- f =<< t
03:12:11 <int-e> because x <- t >>= f  looks awkward
03:12:31 <norpan> not to me
03:12:36 <norpan> but then i'm used to it
03:34:49 <kzm> I'm curious about the current efforts to support packages exporting similarly named modules.  Are there example cases where this is needed, and the existing solutions are insufficient?
03:36:21 <ndm> kzm, there are at least 2 System.FilePath 's
03:36:47 <kzm> Which you want to use together in the same program?
03:36:56 <eivuokko> ByteString in base and fps?
03:37:56 <kzm> The BS case bit me.  But it can be solved by not using make, or by using -hide-package.
03:38:12 <kzm> ..again, unless you want to use both versions simultaneously.
03:38:19 <kzm> Oh, wait.  It's in *base*?
03:38:43 <kzm> hiding that is probably a bit...cumbersome. :-/
03:38:52 <eivuokko> a bit.
03:40:54 <kzm> This sucks, and the proposals on the wiki are also cubersome.
03:41:28 <kzm> E.g. if I have a largish body of FPS using code, and want to compile them against a newer FPS, I must modify every import statement in the code.
03:41:57 <eivuokko> Then use proxy module for your FPS imports?
03:44:01 <eivuokko> Well, still can't link that with ghc, probably.
03:44:08 <kzm> Hmm.. can I 'ghc -c FpsProxy.hs -hide-package base -package myfps' and still compile the rest against base?
03:44:22 <kzm> I think the wiki page warns against it.
03:44:47 <kzm> So whose idea was it to put fps in base anyway?
03:44:54 <eivuokko> Nvm, I doubt that works.  The module in base and fps should have linker error for multiple defs.
03:44:55 * kzm scowls.
03:44:56 <kzm> :-)
03:46:00 <Lemmih> xerox: Yeah, the web frontend doesn't really matter.
03:53:34 <N1ckH0rr0r> is there a function that does "do { a <- x; return a }" ?
03:54:03 <mauke> id?
03:54:11 * pesco blinks.
03:54:24 <kzm> eivuokko, from the Wiki: By manipulating these flags, you can expose package P1 when compiling module M (say), and expose P2 when compiling module N. Then M and N could both import module A.B.C, which would come from P1 and P2 respectively
03:54:42 <kzm> And: ompiling different modules with different flags in a way that affects the semantics (rather than, say, the optimisation level) seems undesirable.
03:54:48 <kzm> So apparently, it will work?
03:54:49 <N1ckH0rr0r> mauke i think that's different. at least not a replacement as it wont compile :)
03:55:03 <kzm> (using -c -hide-package x and -package y)
03:55:13 <mauke> N1ckH0rr0r: what are you trying to do?
03:55:57 <eivuokko> kzm, I am fairly sure it shouldn't.  modules that have same name in P1 and P2 should have same identifiers, which would bork linking.  But I haven't tried.
03:56:04 <N1ckH0rr0r> mauke i have a list of actions that i want to run with map and have the list of results
03:56:12 <N1ckH0rr0r> mapM actually
03:56:23 <kzm> @seen JaffaCake
03:56:24 <lambdabot> JaffaCake is in #haskell. I last heard JaffaCake speak 57 minutes and 43 seconds ago.
03:56:32 <mauke> ok, and what's the problem?
03:56:34 <kzm> Perhaps I could ask on the list?
03:57:00 <N1ckH0rr0r> mauke i wonder whether there is a function for "do { a <- x; return a }" or not :)
03:57:05 <JaffaCake> kzm: can I help?
03:57:35 <kzm> Probably :-)
03:57:39 <mauke> N1ckH0rr0r: uh, what do you think does that line do?
03:57:56 <kzm> We were wondering about the use of different -package options in different modules of the same program
03:57:59 <mauke> .oO( was that valid english )
03:57:59 <isaacd> N1ckH0rr0r: do { a <- x; return a } ---> x >>= \a -> return a ---> a >>= return ---> a
03:58:03 <N1ckH0rr0r> mauke never mind, i just realized id is not in scope :) sorry
03:58:29 <isaacd> oops, I mean ---> x
03:58:34 <kzm> The wiki seems to say it will work, but will it link correctly?  Is the package name part of the identifier in the .a files?
03:58:38 <isaacd> and x >>= return
03:58:41 <dons> ?type \f -> do { a <- f ; return a }
03:58:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
03:58:45 * kzm realizes he could check this himself.
03:58:55 <dons> ?type \f -> f
03:58:56 <lambdabot> forall t. t -> t
03:58:57 <JaffaCake> kzm: well, you can't do it yet.  We're still musing on the syntax/UI, but the underlying technology will allow it soon
03:59:07 <mauke> @. pl . djinn type \f -> do { a <- f ; return a }
03:59:09 <lambdabot> Cannot parse command
03:59:13 <mauke> damn
03:59:34 <JaffaCake> kzm: yes, the package name will become part of all exported linker symbols
03:59:43 <dons> @pl \f -> f >>= \a -> return a
03:59:43 <lambdabot> id
03:59:46 <kzm> Doesn't that mean that the import Data.Foo from "myfoo" is bogus?
03:59:51 <dons> ah ha! :)
03:59:51 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
04:00:06 <dons> thankyou lambdabot
04:00:17 <kzm> JaffaCake, name *and* version, presumably?
04:00:24 <JaffaCake> kzm: yes
04:01:07 <kzm> Are there many cases where this is an actual problem?  So far, we've only come up with the need for more current fps'es, since base is cumbersome to do without.
04:01:54 <JaffaCake> I've run into the restriction in its various forms, yes
04:02:06 <dons> fps'es? 
04:02:21 <vegai> dons: couldn't get rid of my fps-darcs & lambdabot-4.0 problems
04:02:34 <kzm> dons, I want to use fps-0.x instead of fps-0.y, but fps-0.y is unfortunately part of base.
04:02:40 <dons> ah
04:02:43 <dons> yes, 0.7 is in base.
04:02:56 <kzm> Not on 6.4.1, it's 0.3 or something.
04:03:11 <dons> it doesn't interact well if you want to use the dev branch of fps as well as base
04:04:14 <dons> you end up having to remove fps from base/. however, now they're in sync, and hopefully wil remain so. most things we've wanted to do are done.
04:04:51 <kzm> Well, it will be solved if I can specify that this import is from that version.  I'd prefer a command line option I can give ghc --make to ensure consistency, but I'll live.
04:05:46 <kzm> Ideally, fps should of course be its own package, and not in base.  But I guess that's too late for that now.
04:06:19 <kzm> Unicode is in place now?  How does it perform?
04:06:32 <dons> no, not unicode. Data.byteString.Lazy.
04:06:43 <dons> sjanssen's still hacking away at the unicode stuff
04:07:02 <kzm> So that will be a separate package?
04:07:22 <kzm> (I should take a look, I guess.)
04:07:52 <dons> if its done to my satisifaction, then ideally i'd like to see it in base, and we ditch the legacy PackedString
04:07:57 <dons> (we should do that anyway, i suspect)
04:08:07 <kzm> I still think it is worthwhile to have easy replacement.  
04:08:09 * kzm shrugs.
04:08:19 <kzm> What is the advantage of having it in base, btw?
04:08:54 <dons> i think its too late to have it as a separate package. its in base because we envisage things in base depending on it (like text.Regex)
04:10:10 <isaacd> Oh my, when trying to compile nhc98 without any haskell compilers, something
04:10:29 <isaacd> 's reliably segfaulting -- either a shell script, or gcc, seemingly
04:10:48 <isaacd> (annoying "return" next to apostrophe key...)
04:12:09 <vegai> should lambdabot be buildable on out-of-the-box ghc-6.6, whenever that comes out?
04:12:35 <dons> it should, i think
04:12:51 <dons> i used 6.5 for quite a while recently, and i think lambdabot built ok.
04:12:56 <dons> vegai, did you try regetting both fps and lambdabot from scratch?
04:13:35 <vegai> hmm, not for lambdabot. Let's see...
04:14:30 <isaacd> I wish I had another compiler that could do recursively-dependent modules so that I could check my code that triggers a ghc-bug with them.
04:15:02 <dons> vegai, otherwise, send me the build log and where it fails, and i'll see if i can reproduce it.
04:15:39 <ndm> dons, did lamdabot tell you stuff?
04:15:57 <dons> it did!
04:16:03 <dons> drhaskell, good name
04:16:22 <ndm> yeah, i had "haskellsuggest", then the person next to me came up with the name
04:16:43 <ndm> it does some simple stuff, needs more powerful matching, conditional matching etc.
04:16:51 <ndm> and lots and lots of rules
04:17:04 <dons> ok, i'll have a look in the next couple of days
04:17:12 <dons> maybe we can port the lambdabot @pl rules
04:18:32 <ndm> yep, would be cool - some of them at least
04:18:50 <vegai> ok, I'll do a typescript out of the whole thing right from installing ghc
04:19:00 <vegai> odds are, it works this time... 
04:19:09 <dons> @seen musasabi
04:19:09 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I don't know when musasabi last spoke.
04:36:41 <alar> is there Group class?
04:37:35 <alar> some things, e.g. parsers are not only monads (by sequential combination) , but also form halfgroup (by alternation)
04:38:11 <norpan> MonadPlus?
04:39:34 <alar> maybe
04:40:04 <norpan> the class system is a bit ad hoc
04:40:28 <alar> yes, MonadPlus should be what I imply
04:47:46 * Itkovian tries his first State monad thingie
04:53:17 <Itkovian> anybody any urls with neat, crisp-clear examples?
05:00:06 <kzm> dons: any perf numbers on comparing (short) bytestrings?  I'm wondering whether it is worthwhile to calculate an Int32 hash for use as keys in Data.Map, or just use BS comparison.
05:01:07 <dblhelix> norpan: "the class system is a bit ad hoc": pun intended?
05:01:27 <norpan> pun at least considered
05:06:19 * JKnecht doesn't get it
05:06:44 <JKnecht> (i.e. the pun, which is a play on words)
05:07:34 <dblhelix> JKnecht: Haskell's class systems provides a type of polymorphism that is known as ad-hoc polymorphism (i.e., overloading)
05:07:55 <dblhelix> /s/systems/system
05:10:16 <JKnecht> OK
05:17:35 <dons> kzm, mm. short strings would be faster not to use a hash, i reckon
05:18:14 <kzm> Okay.  I'm currently very slow, but I'll investigate a bit more.
05:18:59 <kzm> You wouldn't happen to know whether a Set is more efficient than a Map?  I was thinking of storing the key in the upper bits, and the value in the lower bits of an Int32 or Int64.
05:19:46 <dons> sounds cool. might be better. if compare is the problem, it should show up in the profile
05:19:49 <kzm> Doesn't a Map over BS lead to a lot of pointer indirection, btw?
05:20:15 <dons> wel, the nodes are indirected, i suppose
05:27:21 <vincenz> anyone nkow how to generate a public key frmo a private key?
05:27:34 <BCoppens> you can't
05:27:40 <BCoppens> afaik =)
05:28:09 <norpan> vincenz: what kind of keys
05:28:41 <vincenz> ssh keys
05:28:47 <vincenz> generated by keygen
05:28:51 <vincenz> I accidentally overwrote my public key
05:28:55 <vincenz> still have my private one of course
05:29:07 <BCoppens> didn't you upload it to any public key servers?
05:29:22 <norpan> you don't do that with ssh keys
05:29:40 <dons> yeah, anything you've logged onto you might have it in the authorized_keys file?
05:30:08 <norpan> should have
05:30:14 <BCoppens> norpan: erm right =)
05:30:22 <vincenz> found it
05:30:29 <vincenz> ssh-keygen -y 
05:30:44 <vincenz> but yeah I had it on some other place
05:30:46 <vincenz> just didn't know which one
05:30:54 <vincenz> but ssh-keygen -y generated a pubkey that matched one of them
05:30:57 <vincenz> so I'm sure :)
05:30:57 <dons> ah cool. didn't know about -y
05:31:07 <vincenz> I think it should be possible
05:31:12 <vincenz> after all the crucial info is the private key
05:31:14 <vincenz> not the pubilc one
05:31:20 <vincenz> so I think public one shoudl be regeneratable
05:31:52 <norpan> yes, if you have the private key you can calculate the public key
05:31:53 * vincenz continues to back up from his laptop to his work pc... (my charger died :( )
05:32:03 <Itkovian> oops
05:32:10 <norpan> pbkey = g^(privkey) mod p
05:33:47 * vincenz was gonna ask dons something last night but now completely forgot
05:34:19 <dons> well, you haven't told me yet, so i sure don't know.
05:34:30 <vincenz> :D
06:02:06 * roconnor prefers RSA
06:12:47 <dons> @seen malcolm
06:12:47 <lambdabot> I saw malcolm leaving #haskell-blah and #haskell 3 days, 1 hour, 19 minutes and 2 seconds ago, and .
06:13:10 <dons> Lemmih: any other mentors we can contact via irc to make sure they fill out the mentor form?
06:14:17 * dons -> sleep
06:15:52 <cjay> @vixen i need some food
06:15:52 <lambdabot> pretty needy, aren't you?
06:17:14 <cjay> @vixen won't you bring me some?
06:17:14 <lambdabot> first you tell me.
06:17:55 <cjay> @vixen tell you what?
06:17:55 <lambdabot> is that really what you want to know?
06:18:12 <cjay> @vixen yes
06:18:12 <lambdabot> i guessed that
06:18:17 <cjay> hum
06:37:20 <JKnecht> @vixen version
06:37:20 <lambdabot> what do you want to know about me?
06:37:31 <JKnecht> @version
06:37:32 <lambdabot> lambdabot 4p23, GHC 6.5 (OpenBSD i386 )
06:37:32 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:37:34 <ihope> @version vixen
06:37:35 <lambdabot> lambdabot 4p23, GHC 6.5 (OpenBSD i386 )
06:37:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:37:46 <ihope> Pweh.
06:39:59 <vincenz> blegh on vfat
06:40:04 <vincenz> if you have a darcs repo
06:40:09 <vincenz> with a directory inside that is all caps
06:40:15 <vincenz> putting it on a usb stick turns it into lowercase
06:57:11 <vincenz> holy cow
06:57:18 <vincenz> tabcompletion for haskell in vmi7.0 rocks
06:58:01 <mux> vim7 is yummy
06:58:25 <vincenz> it even checks other modules apparently
07:02:14 <vincenz> someone should make an omnicomplete for vim7.0 for haskell :D
07:02:30 <gds> vincenz: tab completion as in ^p and ^n or is there some other key combination I haven't discovered yet?
07:04:01 <vincenz> gds that one yes
07:04:15 <vincenz> gds: but there is also omnicompletion "i_CTRL-X_CTRL-O"
07:04:20 <vincenz> which requires coding however
07:04:40 <vincenz> ooh nice, tab-support
07:04:44 <vincenz> somethign else I've been hoping for
07:04:52 <gds> :)
07:05:27 <dcoutts> JohnMeacham, I'm having touble compiling jhc from darcs today, compiling E/SSimplify.hs fails as isIsBoundTo is not in scope
07:08:53 <vincenz> dcoutts: where is the repo of jhc?
07:09:25 <dcoutts> http://repetae.net/john/repos/jhc
07:09:27 <lambdabot> Title: "Index of /john/repos/jhc"
07:09:37 <vincenz> thx
07:10:12 <gour> does ebuild for hlmerge exist somewhere?
07:17:54 <dcoutts> gour, you mean himerge? ask araujo 
07:19:17 <gour> dcoutts: yes (although here http://sequence.complete.org/hwn/20060410 says hImerge :-)
07:19:32 <dcoutts> ok I/i but not l
07:20:06 <gour> ahh, it's pretty close on my monitor :-)
07:20:30 <gour> and 'i' it's irc's shorthand for I ;)
07:20:46 <gour> araujo: do you have ebuild for your merge tool?
07:21:38 <gour> dcoutts: how jhc behaves with gtk2hs?
07:21:48 <dcoutts> gour, I can't get jhc to build atm
07:22:22 <gour> dcoutts: have you tried earlier version?
07:22:49 <dcoutts> gour, a little but at that time it didn't support all the ffi bits gtk2hs needed I think
07:23:13 <gour> dcoutts: but it looks promising, true?
07:23:24 <dcoutts> I'd love to see jhc working
07:23:36 <dcoutts> even for just H98 stuff
07:23:42 <dcoutts> FFI would make it practical
07:24:39 <vincenz> dcoutts: when trying to get jhc:
07:24:39 <vincenz> Applying patch 2 of 133... Unapplicable patch:
07:25:03 <dcoutts> vincenz, what version of darcs?
07:25:05 <gour> true. i'd like to get my future app on some palm-like device running linux :-)
07:25:07 <dcoutts> it worked for me
07:25:14 <vincenz> Copying patch 133 of 133... done!
07:25:14 <vincenz> Applying patch 2 of 133... Unapplicable patch:
07:25:14 <vincenz> Mon Apr 10 06:52:52 CEST 2006  John Meacham <john@repetae.net>
07:25:14 <vincenz>   * add routines to Util.SetLike
07:25:14 <vincenz> darcs: ./Util/SetLike.hs: openBinaryFile: does not exist (No such file or directory)
07:25:17 <dcoutts> gour, seen the nokia 770 ?
07:25:30 <vincenz> 1.0.7
07:25:41 <gour> dcoutts: just on the monitor screen :-(
07:26:03 <dcoutts> vincenz, using darcs get --partial ?
07:26:08 <vincenz> now I am
07:26:09 <dcoutts> gour, aye, smae here
07:26:09 <vincenz> that worked
07:26:19 <vincenz> how come --partial can work while non partial can not work?
07:26:24 <gour> dcoutts: haskell runs on nokia?
07:26:27 <vincenz> seems a bit counterintuitive
07:27:24 <dcoutts> gour, yep, the 770 runs linux and I think shapr got yhc working
07:27:34 <N1ckH0rr0r> is it possible do something like: a <- takeWhile (?) (replicate [getLine]) ?
07:27:41 <dcoutts> vincenz, something is broken, --partial is just a workaround
07:28:01 <vincenz> dcoutts: I'd just expect- partial to be even more broken
07:28:02 <vincenz> oh well
07:28:07 * vincenz ponders no how to generate a simpler 
07:28:15 <dcoutts> vincenz, because --partial is skipping some patches, and so it seems to be skipping a broken patch
07:28:17 <vincenz> AST that does not allow side-effect expressions as function-call paramters
07:28:17 <int-e> vincenz: old patches before the last checkpoint (tag?) could be missing
07:28:44 <mux> N1ckH0rr0r: what do you want to do? read lines until EOF?
07:28:52 <N1ckH0rr0r> mux yes, for example
07:28:57 <int-e> vincenz: --partial works with a complete snapshot and recent patches on top of that.
07:28:57 <cjay> somebody should tell them that their repo is broken
07:29:11 <fasta> mux: Can I ask you a question about HaXml?
07:29:19 <gour> dcoutts: so, it means we only need gtk2hs. sqlite probably runs
07:29:21 <vincenz> int-e: Ah I see
07:29:22 <mux> N1ckH0rr0r: liftM lines . hGetContents
07:29:37 <mux> fasta: you can, but I'd be surprised if I could be of any help
07:29:38 <dcoutts> gour, on a palmtop you mean?
07:29:40 <Itkovian> if I have a list, and wish to update a State by accessing each element in turn, should I use mapM with the threaded State, and return the second item of the tuple at the end, or do a foldM? I think the foldM is not right, as I discard the list items as soon as I've updated the state using them
07:30:11 <vincenz> Itkovian: foldM
07:30:12 <dcoutts> gour, best bet is yhc with gtk2hs on a nokia 770, as that uses linux and gtk+
07:30:31 <vincenz> oh wait
07:30:34 <vincenz> mapM
07:30:36 <N1ckH0rr0r> mux my problem is how to lift the condition because takeWhile needs a->Bool but due to lifting to IO a it will return IO Bool.. i hope you get it
07:30:37 <vincenz> you don't combine elements
07:30:50 <fasta> mux: I finally seem to understand the CFilter concept of HaXml, but I don't want to just select subtrees, I want to compute values from it. Any idea how I could get a value? Or should I just use pattern matching?
07:31:02 <Itkovian> vincenz: nope, they just aggregate into the state, which is a record of stuff I wish to track while 'parsing' the list
07:31:32 <gour> dcoutts: well, no rush here...my app is not written (yet), and when it gets some shape, who know what will be nokia's model then
07:31:43 <mux> fasta: no idea, sorry :-)
07:31:49 <mux> N1ckH0rr0r: not sure I get you here
07:31:55 * mux feels quite impressively useless
07:32:09 <Itkovian> vincenz: it should discard the list items no longer needed, no? ready for GC to free the memory
07:32:28 <vincenz> Itkovian: execState (mapM (\e -> modify (+e)) [1..10]) 0
07:32:36 <vincenz> > execState (mapM (\e -> modify (+e)) [1..10]) 0
07:32:37 <lambdabot>  55
07:32:53 * Itkovian tries to grok
07:32:56 <fasta> dcoutts: do you know the answer on the question I asked mux? It must still be in your screen.
07:32:57 <vincenz> Itkovian: yeap, depending on the aggression of the gc
07:33:04 <vincenz> @type execState
07:33:05 <lambdabot> forall s a. State s a -> s -> s
07:33:08 <vincenz> it takes an action and an original state
07:33:10 <vincenz> and returns the final state
07:33:13 <Itkovian> ok
07:33:28 <vincenz> my action is mapM (\e -> modify (+e)) [1..10]
07:33:49 <dcoutts> fasta, not sure, appart from just patterm matching on the xml ast, I never really groked the haxml model (even though I've writen some progs using it)
07:33:51 <vincenz> @type modify
07:33:52 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
07:34:04 <vincenz> @pl (\e -> modify (+e))
07:34:04 <lambdabot> modify . (+)
07:34:07 <vincenz> ooh
07:34:22 <vincenz> > execState (mapM (modify . (+)) [1..10]) 0
07:34:23 <lambdabot>  55
07:34:48 <fasta> dcoutts: I also think that's the only way to do it. It seems doing these things in Java is easier. 
07:34:50 <roconnor> @docs Control.Monad.Writer
07:34:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
07:35:07 <dcoutts> fasta, it really shouldn't be :-(
07:35:16 <fasta> dcoutts: I know
07:35:24 <dcoutts> i've neot looked into the haskell xml stuf very much
07:35:45 <fasta> dcoutts: There's not much to see I am afraid.
07:35:53 * dcoutts continues packaging hxt
07:36:03 <fasta> dcoutts: I wouldn't do that.
07:36:05 <dcoutts> fasta, there are three libs, one must be ok no?
07:36:15 <fasta> dcoutts: HXT has a completely horrible interface.
07:36:16 * joelr1 waves
07:36:19 <fasta> dcoutts: Three?
07:36:27 <fasta> dcoutts: HXT, HaXml, and?
07:36:31 <fasta> dcoutts: HXML?
07:37:05 <fasta> dcoutts: I don't really count HXML.
07:37:18 <dcoutts> fasta, oh, perhaps I was thining of a xml-rpc thing
07:37:29 <dcoutts> what's hxml ?
07:37:40 <fasta> dcoutts: arrow interface for XML
07:37:45 <dcoutts> ah
07:37:46 <fasta> dcoutts: HXT uses its ideas
07:38:18 <roconnor> How do I look up the sources for Control.Monad.Writer.Writer?
07:38:54 <eivuokko> http://darcs.haskell.org/packages/mtl/Control/Monad/Writer.hs
07:39:29 <maard> hello
07:39:31 <joelr1> fasta: are you still looking for that ultimate xml toolkit? did todays announcement help?
07:39:39 <maard> my module startsmodule Math1
07:39:39 <maard>     where
07:39:39 <maard> import IO
07:39:59 <roconnor> ah I see, w must be a monoid.
07:40:46 <fasta> joelr1: well, "ultimate", I am just trying to use something, and I am dangling between switching to C/Java (any platform with decent documentation), or staying with Haskell. I will have a look at the announcement.
07:40:48 <maard> oops, sorry. i've got errors about functions from Prelude: No instance for (Show (a -> a -> a)). how i can fix this? (ghc)
07:41:30 <joelr1> fasta: the announcement is about http://www.fh-wedel.de/~si/HXmlToolbox/index.html
07:41:31 <lambdabot> Title: "Haskell XML Toolbox 6.0"
07:41:54 <int-e> maard: you can't print functions
07:41:56 <isaacd> maard: Do you need to apply some more arguments to a function?
07:42:00 <joelr1> fasta: it's strange that you haven't been able to find a haskell xml toolbox to your liking
07:42:30 <fasta> joelr1: I wonder whether they cleaned up the interface.
07:43:21 <Itkovian> vincenz: if I wanted e.g. the numbers counted in that list, I'd use what as argument to modify?
07:43:25 <Itkovian> @type modify
07:43:26 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
07:43:44 <vincenz> modify just modifies your state with the given function
07:44:32 <vincenz> > execState (mapM (\e -> modify (+1) [1..10]) 0
07:44:33 <lambdabot>  Parse error
07:44:39 <vincenz> > execState (mapM (\e -> modify (+1)) [1..10]) 0
07:44:40 <lambdabot>  10
07:44:45 <maard> calc i = putStrLn (read i ++ ": " ++ show(f (1 2 i))), where f has type:  f :: Int -> Int -> Int -> Int
07:45:10 <Itkovian> ok, it's slowly starting to make sens, I _think_
07:45:14 <Itkovian> +e
07:45:16 <int-e> maard: you want f 1 2 1
07:45:19 <isaacd> maard: Don't put parentheses around the arguments to a function (namely f)
07:45:24 <int-e> maard: not f (1 2 1)
07:45:50 <kpreid> well, you *could* write show(f(1)(2)(i))
07:46:14 <maard> just curious: what haskell thought when he saw f(1 2 i) ?
07:46:16 <int-e> or (((f 1) 2) i)
07:46:31 <isaacd> maard: apply the function "1" to 2 and i
07:46:43 <isaacd> and then apply f to the fesult of that
07:46:50 <int-e> maard: f is a function of type a->a->a->a and applied to one argument; the result is a -> a -> a ; you want to print that but it has no Show instance
07:47:19 <isaacd> Of course, "1" isn't a function, but GHC found an earlier error to report than that, apparently.
07:47:28 <maard> wow :) thanks
07:47:48 <int-e> maard: that's how it arrived at the error message, I think. it never tried to figure out types for the (1 2 i) part - which would give error messages like 'No instance for (Num (a -> b))'
07:48:12 <isaacd> Because GHC doesn't know that a function can never be a number.
07:48:30 <int-e> maard: because 1 is of type Num a => a and the application (1 2) means that 1 must be a function.
07:48:50 <int-e> isaacd: not really, you *could* define such a Num instance
07:48:58 <int-e> isaacd: say, Church numerals.
07:49:06 <isaacd> hmm
07:49:35 <isaacd> Yes, you *could*, if you put a sufficiently restrictive context on it...
07:49:41 <int-e> isaacd: it'd be an evil thing to do though and probably not be as flexible as you'd like.
07:49:48 <isaacd> yes
07:50:06 <maard> aha, ok. then another question. i try to comvert example from lisp to haskell as an axercise. i need to calculate function and print result for list [2..8]. i'm still stuck with C iterative approach...
07:50:25 <isaacd> mapM (print . f) [2..8]
07:50:27 <maard> main = do
07:50:28 <maard> 	let l = map calc [2..8]
07:50:28 <maard> 	putStrLn "done"
07:52:37 <Itkovian> vincenz: thx
07:52:41 <vincenz> Itkovian: welcome
07:54:17 <Itkovian> though I'm not sure it'll make my code overall prettier or more readable, which I'd somehow hoped, as the updater for the modify will still be crack ugly
07:59:19 <maard> thanks, everything is working
07:59:41 <Carillon> hey guys, anyone know what this error means: ``Setup.lhs: haifa.cabal:22: Parse of field 'extensions' failed:``
08:05:36 <dcoutts> Carillon, it probably means that either your version of cabal is too old or that the package needs updating for your current cabal version
08:11:57 <Carillon> dcoutts: thanks, it's interesting since i'm working with the latest versions of the package and a fresh install of cabal.  i'll try reinstalling and see if that helps.
08:12:30 <dcoutts> Carillon, it probably wont, what do you find in the extension field?
08:12:37 <dcoutts> what extensions are listed?
08:14:34 <Carillon> dcoutts: MultiParamTypeClasses, FunctionalDependencies, AllowUndecidableInstances, TemplateHaskell
08:14:53 <dcoutts> Carillon, change AllowUndecidableInstances to UndecidableInstances,
08:16:46 <Carillon> dcoutts: awesome, thanks.  i have no idea what 'UndecidableInstances' are...i should RTM.
08:30:36 <roconnor> How would I go about making a Writer monad that writes to a file?
08:32:00 <roconnor> I guess I would make a fiileWriter type that is an instance of Writer, and with a liftIO function. ...
08:32:16 <roconnor> That doesn't seem right
08:32:21 <isaacd> Take the output from a Writer monad, and just write that to a file, because Haskell is lazy?
08:32:23 <roconnor> @hoogle liftIO
08:32:25 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
08:32:52 <roconnor> ah
08:33:19 <roconnor> isaacd: i want guarentees that after I call write, it is on disk.
08:33:26 <roconnor> err call tell
08:33:37 <isaacd> hmm
08:34:11 <norpan> if you want that guarantee you must call fsync
08:34:41 <norpan> or open the file in synchronized mode if that is possible
08:35:11 <isaacd> If outputting the written messages is the first thing you do with it (and IO actions are sequenced, so there can be a "first"), you can be guaranteed that outputting it is the first thing that will happen
08:35:18 <isaacd> Also what norpan says.
08:35:35 <roconnor> @hoogle fsync
08:35:36 <lambdabot> No matches found
08:36:32 <roconnor> isaacd: but I want tell to be interleaved with IO actions.
08:40:31 <norpan> why don't you just use the IO monad?
08:41:34 <roconnor> where would I keep the file handle that tell would use?
08:41:43 <ihope> Um...
08:41:53 <ihope> foo <- openFile?
08:42:01 <ihope> Then use foo as the handle?
08:42:10 <roconnor> and pass foo into every function?
08:42:53 <ihope> Yes. Or make your own monad, and turn that into IO.
08:43:16 <isaacd> Layer a MonadReader for the file handle?
08:43:22 <roconnor> ihope: exactly make my own monad implementing MonadWriter and MonadIO
08:43:45 <isaacd> yeah
08:43:46 <ihope> @docs Control.Monad.Writer
08:43:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
08:44:06 <fasta> @type const
08:44:11 <lambdabot> forall a b. a -> b -> a
08:44:36 <fasta> > const "a" "b"=="a"
08:44:38 <lambdabot>  True
08:44:53 <roconnor> > const "a" 5=="a"
08:44:54 <lambdabot>  True
08:45:06 <roconnor> const "a" id=="a"
08:45:20 <roconnor> > const "a" id == "a"
08:45:21 <lambdabot>  True
08:45:25 <roconnor> > const "a" const == "a"
08:45:26 <lambdabot>  True
08:46:13 <Cale> @type const const
08:46:14 <lambdabot> forall a b b1. b1 -> a -> b -> a
08:46:20 <roconnor> > const const "a" "b"
08:46:21 <lambdabot>  Add a type signature
08:46:26 <Cale> @type const const const
08:46:26 <roconnor> > const const "a" "b"=="b"
08:46:27 <lambdabot>  Couldn't match `b -> [Char]' against `[Char]'
08:46:27 <lambdabot> forall a b. a -> b -> a
08:46:53 <lisppaste2> petekaz pasted "Does this look ok?  Or is there a more "haskell"-like way of doing it?" at http://paste.lisp.org/display/22056
08:46:55 <roconnor> > const const "a" "b" "c"
08:46:56 <lambdabot>  "b"
08:47:00 <Cale> @type const (const const)
08:47:01 <lambdabot> forall b a b1 b2. b2 -> b -> a -> b1 -> a
08:47:02 <roconnor> :)
08:47:18 <Cale> @type const (const (const const))
08:47:20 <lambdabot> forall b b1 a b2 b3. b3 -> b -> b1 -> a -> b2 -> a
08:47:35 <Cale> silly :)
08:48:08 <ihope> petekaz: data EmailHeaderThingy = EmailHeaderThingy From Subject?
08:48:40 <shapr> Greetings from Stockholm!
08:49:06 <petekaz> From and Subject are just Strings.
08:49:13 <ihope> Or maybe "EmailHeaderThingy {from :: From; subject :: Subject}".
08:49:49 <petekaz> Aside from that, is it ok?
08:50:02 <maard> tell me the difference between function composition and application (. vs $). it seems like both  f . g anf f $ g apply g to argument(s) and then apply f to result.
08:51:01 <petekaz> ihope: Would that help me eliminate the annoying use of the \(_,s) (_,s) lambdas?
08:51:39 <mikael> hi shapr :-)
08:51:44 <ihope> Well, the lambdas would be "\s s'" or whatever, but you'd apply the subject function to them.
08:51:57 <Cale> maard: Look at their types
08:52:02 <petekaz> ihope: I guess not, as those would just be \(EmailHeader _ s) now rigth?
08:52:17 <isaacd> maard: (.) waits for an argument to be applied to the whole thing, while ($) requires the second function to already have any arguments applied to it
08:52:43 <shapr> mikael, hej!
08:52:57 <mikael> what's your business in stockholm?
08:52:59 <roconnor> mergeEmail x = (map fst x, snd (head x))
08:53:00 <Cale> If f :: b -> c, and g :: a -> b, then f . g is valid, but f $ g isn't
08:53:04 <ihope> maard: the reason $ acts that way is because of precedence.
08:53:55 <ihope> foo $ bar baz does apply bar to baz, then foo to the result, but that's only because it's foo $ (bar baz). With ., it would be (foo . bar) baz.
08:54:01 <Cale> But if x :: a, then f $ g x is fine
08:54:04 <kpreid> shapr!
08:54:18 <shapr> mikael, I live here!
08:54:30 <shapr> kpreid, hiya!
08:54:31 <mikael> whoa, really!
08:54:41 <kpreid> shapr: had time to look at EoHS yet? :)
08:54:41 <gour> shapr: bok!
08:54:54 <mikael> wait, I am confused
08:54:59 <gour> shapr: how are you satisfied with nokia-770?
08:55:04 <shapr> gour, bok!
08:55:07 <ihope> Also, "foo . bar $ baz" and "foo $ bar $ baz" do the same thing for that reason, as well: "foo . bar $ baz" is "(foo . bar) $ baz" while "foo $ bar $ baz" is "foo $ (bar $ baz)".
08:55:21 <mikael> you used to live up north, right?
08:55:27 <gour> shapr: i'm back from india (after 3 months)
08:55:28 <shapr> kpreid, not yet, my ife is still unsettled
08:55:33 <Cale> I prefer foo . bar $ baz to foo $ bar $ baz though
08:55:37 <kpreid> ah
08:55:48 <kpreid> shapr, in other news, I am tinkering with lambdabot
08:56:14 <shapr> gour, 770 is getting better & better. I'm in a pizza hut waiting for food right now.
08:56:28 <Cale> Just for refactoring code, it's easier to deal with chains of compositions, because foo . bar is something valid on its own whereas foo $ bar wouldn't be in this case
08:56:33 <gour> shapr: dobar tek (bon appetite :-)
08:56:45 <shapr> mikael, yes, just flytat fran Boden.
08:56:53 <gour> shapr: what about haskell (& gtk2hs) on nokia?
08:57:11 <pesco> Hey, shapr.
08:57:23 <shapr> Coi pesco 
08:57:29 <pesco> Long time no see!
08:57:31 <mikael> shapr: nice.  any specific reason? :-)
08:57:45 <shapr> gour, jhc can make ARM binaries.
08:58:08 <dcoutts> hi shapr, so you're wandering about town and still on #haskell using your n770 ?
08:58:13 <gour> shapr: so, it could be possible to 'port' some gui app on nokia then?
08:58:26 <dcoutts> gour, only if we get gtk2hs to work with jhc or yhc
08:58:27 <shapr> mikael, woman mostly
08:58:41 <maard> Cale: ok. this means f . g "creates" new thingy (function), while f $ g calls f only when g arg has been called
08:58:48 <gour> dcoutts: well, i count on that ;)
08:59:07 <dcoutts> gour, it'll need some cabal hacking
08:59:09 <shapr> dcoutts, time for food, bbl!
08:59:12 <mikael> shapr: I'm moving to gothenburg this august!
08:59:14 <pesco> shapr: If you want to use my txt parser for your blog, it's finished and darcs-gettable as part of http://www.khjk.org/~sm/code/advopost/.
08:59:16 <lambdabot> Title: "Index of /~sm/code/advopost/"
08:59:25 <shapr> Oh hey, anyone using gtalk?
08:59:25 <pesco> bababa.
08:59:27 <dcoutts> mikael, I'll be in gothenburg in aug too!
08:59:34 <dcoutts> shapr, yep, as of yesterday
08:59:34 <Cale> maard: f $ g applies f to g
08:59:46 <pesco> Time for food here, too. BBL!
08:59:47 <shapr> dcoutts, name?
08:59:56 <Cale> maard: whereas f . g forms a new function which is the composition of f and g
08:59:57 <dcoutts> shapr, duncan.coutts@googlemail.com
09:01:00 <ihope> Is there a term for a class that can be made into an existential type which is itself an instance of the class?
09:01:16 <maard> Cale: ok, but taking into account lazyness "applying f to g" means that f . g is the same... if forget about lazyness (but we can't?), they differ
09:01:33 <Cale> maard: no, they actually have different types altogether
09:01:56 <shapr> Food, bye!
09:02:05 <Cale> If f and g are functions, f $ g only makes sense when f can take a function of g's type as its first parameter
09:02:21 <ihope> "f $ g" is the same as "f g", ignoring operator precedence.
09:02:27 <Cale> right
09:02:31 <ihope> That is, "(f $ g)" is the same as "(f g)".
09:02:57 <ihope> (f . g) is the same as (\x -> f (g x)). It is not the same as (f g).
09:04:49 <Cale> which means that (f . g) = (\x -> f $ g x)
09:04:58 <ihope> Yes.
09:05:16 <ihope> But (f $ g x) is (f $ (g x)), not ((f $ g) x).
09:05:47 <Cale> since $ has really low precedence
09:06:05 <Cale> (and regardless, function application has higher precedence than anything else
09:06:08 <Cale> )
09:06:29 <ihope> Yeah, even (x !! y z) is (x !! (y z)).
09:06:32 <maard> got it (i guess) :)
09:06:36 <maard> thank you
09:07:06 <Cale> In code, supposing that you apply a function parameter, there are places where you can replace $'s with .'s
09:07:10 <Cale> and vice versa
09:07:14 <Cale> but not everywhere
09:07:21 <isaacd> Is Yhc supposed to be able to compile mutually recursive modules transparently?
09:07:43 <Cale> and it's generally nicer to use . when you have the choice
09:08:08 <Cale> Because it makes editing the code later easier
09:08:56 <Cale> If you have a big long chain of compositions and decide that part of it should be separated into a new function, you can just cut and paste rather than having to edit anything.
09:09:12 <maard> i see
09:16:18 <ndm> isaacd: no
09:16:21 <ndm> not yet at least
09:16:37 <ndm> it is on the todo list, the make infrastructure handles it, but the type checking doesn't
09:16:51 <ndm> for a SoC project someone is rewriting the type checker, so we'll see :)
09:20:19 <isaacd> ndm: okay, so that's why it doesn't like them
09:20:27 <isaacd> oh well
09:22:59 <ndm> isaacd: it doesn't like much yet, but we're working on it, slowly
09:23:37 <isaacd> yeah, half its error messages don't even end with a newline yet
09:33:31 <ndm> isaacd: patches welcome :)
09:33:39 <ndm> the error messages need improving for sure
09:33:40 <isaacd> :)
09:33:47 <ndm> one goal is to have the best error messges
09:33:52 <ndm> and ideally numbers for each error
09:34:13 <ndm> with a reference on the wiki explaining the error in more detail, referencing the report, workarounds, common mistakes etc.
09:35:31 <ndm> btu thats a long.... way off
09:36:10 <isaacd> btw I haven't figured out how to get darcs send to actually send e-mail yet
09:47:08 <dcoutts> isaacd, darcs send
09:47:14 <dcoutts> + a working local mail setup
09:47:39 <dcoutts> eg if you're using ssmtp then you need to set the forwarding smtp server (ie your isp)
09:48:55 <isaacd> dcoutts: yes, I've found a HOWTO sSMTP, which I expect will work
09:49:14 <isaacd> (I do know that I have ssmtp)
09:49:25 <dcoutts> isaacd, just edit /etc/ssmtp/ssmtp.conf
09:49:29 <dcoutts> and change the mailhub
09:49:29 <isaacd> yep
09:49:36 <dcoutts> that's it
09:49:45 <dcoutts> mailhub=smtp.myisp.com
09:50:06 <isaacd> is that all?
09:53:55 <dcoutts> yep
10:25:13 <bolrod> >_<
10:25:39 <Lemmih> O.o
10:25:46 <bolrod> indeed
10:30:28 <isaacd> Despite the boasts about a Haskell program never segfaulting, it happened to me once. I think a library I was using was, itself, using -funbox-strict-fields with ghc.  But I figured it's not a bug in ghc if it's just some special optimization.
10:31:18 <isaacd> or whatever pragma GHC has for unboxing particular fields
10:34:04 <psi> I made a mistake in my gtk2hs program that made it segfault. (I caused an endless loop of callbacks.)
10:34:50 <psi> of course, that is using the ffi
10:36:31 <dcoutts> psi, interesting
10:37:06 <dcoutts> psi, if you've still got said prog feel free to send it in as a bug report
10:37:16 <dcoutts> I'd be interested to know which bit causes a segfault
10:39:13 <psi> ok, let me see
10:45:02 <vincenz> Lemmih: got my @tell?
10:45:35 <Lemmih> Nope.
10:45:57 <Lemmih> lambdabot: Do I have any messages?
10:46:08 <Lemmih> @messages
10:46:09 <lambdabot> You don't have any new messages.
10:46:57 <vincenz> hmm
10:46:58 <vincenz> odd
10:47:01 * vincenz kicks lambdabot
10:47:08 <vincenz> Lemmih: there's news on the oasis wiki
10:47:24 <psi> dcoutts: I managed to recreate the bug, I have a small app that triggers it
10:47:40 <psi> bug might not be right word
10:48:07 <dcoutts> psi, ta, send it to gtk2hs-devel@lists.sourceforge.net
11:03:53 <isaacd> dcoutts: I also had to add myself to /etc/ssmtp/revaliases
11:04:07 <dcoutts> fair enough
11:04:47 <psi> dcoutts: sent
11:04:52 <dcoutts> psi, ta
11:04:54 <isaacd> (actually I don't know if the modification to ssmtp.conf was strictly necessary, but I'm not going to bother to check!)
11:26:26 <vincenz> ps: it's my bday tomorrow
11:26:27 <vincenz> \o/
11:29:39 <lightstep> when is tomorrow?
11:29:39 <lambdabot> lightstep: You have 1 new message. '/msg lambdabot @messages' to read it.
11:30:50 <vincenz> 5 july
11:31:04 <lightstep> @localtime vincenz
11:32:13 <vincenz> 8:30pm
11:34:02 <lightstep> @localtime EDT
11:34:18 <lightstep> eh, maybe lambdabot is off
11:42:09 <erider> > (+) 5 6
11:42:10 <lambdabot>  11
11:42:19 <erider> nope 
11:43:02 <erider> > @localtime EDT
11:43:02 <lambdabot>  Parse error
11:51:43 <int-e> localtime just sends a CTCP Time to the given nick and evaluates the reply (if any)
12:06:53 <ihope> @localtime ihope
12:06:55 <lambdabot> Local time for ihope is Tuesday, July 04, 2006 3:06:25 PM
12:14:43 * vincenz logs off and head home
12:36:10 <ihope> Woot, flurry of error messages.
12:36:21 <ihope> What was that thing to not import the Prelude?
12:37:13 <ihope> Ah, -fno-implicit-prelude.
12:37:26 <sjanssen> or "import Prelude ()"
12:37:39 <ihope> What about "import Prelude hiding ..."?
12:37:47 <ihope> Or whatever that is...
12:38:00 <ihope> "import qualified Prelude as P"? :-)
12:38:18 <sjanssen> yeah, qualified import would work
12:40:43 <zarvok> hey all - registration for this year's ICFP contest is now open: www.icfpcontest.org
12:40:52 <zarvok> don't mean to spam, but I want to see haskell win again :)
12:40:56 <zarvok> And this year's is going to be good
12:41:11 <coward> has anyone ever written a serach engine in haskell?
12:41:18 <coward> btw, scheme is gonna win ifcp
12:41:21 <zarvok> no way
12:41:21 <coward> icfp
12:41:27 <coward> if not, I'll win in assembly
12:41:30 <zarvok> heh
12:41:42 <zarvok> This year's is going to be a lot of fun
12:41:47 <zarvok> It will be interesting to see who wins
12:41:58 <ihope> How do I derive Show for a GADT, exactly?
12:42:15 <coward> sucks to be at cmu; can't enter
12:42:33 <zarvok> you at cmu, or commenting on my IP?
12:42:44 <zarvok> (as I'm also at cmu)
12:42:47 <coward> oh
12:42:51 <coward> I was just reading the faq
12:42:51 <zarvok> In fact, I probably know you, if you know that much abou tit
12:42:55 <zarvok> oh
12:42:57 <zarvok> heh
12:43:00 <coward> and it said: cmu students can't enter
12:43:02 <zarvok> yes
12:43:14 <coward> I'm at Stanford; we crushed you guys at the darpa grand challenge :-P
12:43:15 <zarvok> well, CMU's POP group is designing it
12:43:21 <coward> hehe
12:43:25 <zarvok> heh, well, your leader is ex-cmu
12:43:30 <coward> true true
12:43:32 <coward> in that case
12:43:34 <coward> the top 3 teams
12:43:35 <coward> wer eal lcmu ppl
12:43:38 <coward> btw
12:43:39 <zarvok> yeah
12:43:45 <coward> what is it about cmu that makes them so good at robotics?
12:43:53 <coward> you guys seem to have more robots
12:43:55 <coward> alot more robots than us
12:44:12 <zarvok> eh, we just have a lot of good people.  Our Robotics Institute is one of the best places in the world to study robotics, and it draws people in
12:44:33 <coward> like does your undergrad cricullium; along with how to program and theory of computer science; have "how to build awesome robots on a shoe string" ?
12:44:54 <coward> i was looking at the snake videos you guys have
12:44:57 <coward> they're quite impressive
12:44:59 <zarvok> haha, no, there aren't any required robotics courses in the undergrad cs curriculum
12:45:15 <zarvok> some people take a double major in robotics though
12:45:21 <coward> wtf
12:45:24 <coward> robotics is a "major" ?
12:45:31 <zarvok> sure, why not?
12:45:33 * ihope suddenly realizes that he's using GADT's to back up his phantom typeclass stuff that does arithmetic up there
12:45:36 <coward> oh man
12:45:50 <coward> that expalins so much
12:45:55 <coward> we have cs / ee / mechanical engineering
12:45:59 <coward> but we don't have a "robotics" major
12:46:00 <zarvok> not many undergrads in it though, mostly it's a PhD program
12:46:09 <zarvok> though you can take it as a major
12:46:14 <coward> dude; that's awesome
12:46:20 <zarvok> only as a double though, you can't be only a robotics major
12:46:26 <zarvok> have to be cs/robotics
12:46:31 <coward> ah
12:47:07 <zarvok> works out well though, since CS students are required to take a minor or double major in something else
12:47:08 <coward> I want a swarm of mini hellicopters flying around me at all times
12:47:13 <coward> I see
12:48:11 <zarvok> they think we need the breadth :)
12:48:43 <coward> I _am_ really jealous about that.
12:49:10 <zarvok> I used to work in the RI, it was fun
12:49:17 <coward> RI /
12:49:18 <coward> ?
12:49:19 <coward> what's that
12:49:25 <zarvok> err, RI = robitics institute, sorry
12:49:30 <zarvok> *robotics
12:50:22 <zarvok> first I worked on robot soccer, and later on multi-robot coordination
12:50:37 <zarvok> now I do PL research instead :)
12:51:37 <ihope> Oh, GHC's going to kill me for this...
12:51:39 <dbremner> zarvok - does robotics make any use of swarm intelligence?
12:52:31 <zarvok> maybe, I worked specifically on market-based multirobot coordination, so I didn't do any of that myself
12:52:49 <coward> zarvok, when I first came to Stanford, I wnated to do PL research
12:52:53 <coward> now I'm doing AI research
12:53:02 <coward> what made you do the switch the other direction?
12:53:26 <coward> I've got the (possibly incorrect) feeling that (1) no one in academia really cares about new PL's and (2) funding for it isn't all that great either.
12:53:31 <coward> your thoughts?
12:53:33 <zarvok> eh, robots are what first got me interested in CS, way back in the day, but really I'm more of a math nerd.  I love type theory and curry-howard
12:53:56 <joelr1> howdy
12:54:07 <zarvok> Well, CMU is a great place to study it, we have some of the best people in the world here.
12:54:45 <zarvok> I don't know though, I mean, Peyton-Jones is basically paid by microsoft to hack on GHC, there has to be some money there somewhere
12:55:08 <dcoutts> zarvok, that's not where the money is
12:55:42 <dcoutts> the money is in building reliable software quickly using Haskell as the secret sauce
12:55:46 * joelr1 anxiously waits on dcoutts 
12:55:48 <zarvok> well, I agree
12:55:59 <zarvok> I was just pointing to an example of industry supported haskell work
12:56:03 <Philippa> in MS's case, they've got new ideas to put into VB out of encouraging haskell dev
12:56:07 <joelr1> i wanna know where the money is!
12:56:08 <Philippa> but that's not something that scales
12:56:19 <coward> dcoutts, please say more
12:56:21 <dcoutts> zarvok, right, though it's a bit of a niche :-)
12:56:24 <zarvok> It's clear ms has an interest in more reliable code
12:56:30 <zarvok> :)
12:56:55 <dcoutts> coward, well I'd start by joining shapr's haskell consultancy group
12:57:19 <dbremner> coward- there's been a lot of work that uses type theory to prove interesting properties about code written in ugly old languages.
12:57:31 <joelr1> shapr's consulting group?
12:58:30 <joelr1> i doubt there's money in that. people don't want 1/4" drills, they want 1/4" holes. and i doubt they care what drill you use so long as you do it fast, for a reasonable price, with good quality, etc.
12:58:45 <coward> dude
12:58:49 <coward> why not write a serach engine in haskell :-)
12:58:59 <coward> since developing them are so complex
12:59:14 <Philippa> joelr1: so advertise cheap holes, and hope they don't call you a pimp
12:59:41 <joelr1> Philippa: that's sort of what everyone does :D 
12:59:55 <joelr1> you never see a c++ consultancy or a c consultancy, etc.
13:00:06 <Philippa> exactly
13:01:12 <Philippa> OTOH, if you do have a better toolset, you should be able to outcompete - especially in niche holes, eg ones that need to be measured more precisely than usual
13:01:29 <wilx> Well, maybe there are just some altruists in MS.
13:01:59 <joelr1> Philippa: but then you would be selling the advantages of the toolset as opposed to the toolset itself. you would still be selling the hole.
13:02:01 <coward> yeah; occasionally the hiring dept screws up
13:02:42 <joelr1> Philippa: i tried selling the merits of erlang once, with my poker server. you can imagine the outcome. this is despite all the good things about erlang like fault-tolerance, blah-blah-blah
13:03:05 <dbremner> joelr1 - I doubt that the people using DMS or Fermat care that either is written in a nonstandard language.
13:03:08 <Philippa> yep, selling the toolset doesn't work 'til you've evidence it's a better toolset - and then there's the slight issue with GHC being free
13:03:34 <Philippa> joelr1: I'm guessing the outcome was "none of us read this damn language, stuff that"?
13:03:36 <joelr1> dbremner: you are seconding my opinion then
13:04:14 <joelr1> Philippa: no, because i wasn't selling to programmers. there was no outcome, period, because they wanted features
13:04:16 <ihope> Oh, lookie here, I found something that says "you cannot use a deriving clause on a GADT-style data type declaration" :-P
13:04:33 * Philippa nods
13:04:39 <Philippa> wrong spiel to the wrong people
13:04:45 <dbremner> joerl1 - I guess what I'm saying is that programming languages are means to an end. Both programs benefit from their special purpose languages.
13:04:48 <joelr1> Philippa: lots of people had half-baked software fault-wise (i worked on some) but had lots of features
13:04:59 <joelr1> dbremner: sure
13:05:01 <Philippa> I mean, list fault tolerance and scalability as features, but know you're going to have to compete on the others
13:05:16 <Philippa> "we can build new features cheap and without fucking up your system" starts to be a feature by itself though
13:05:55 <joelr1> Philippa: not really. marketing wins. technology is a distant second. marketing is not selling the technical features unless you are selling to programmers. 
13:06:01 <fasta> I wonder who was the first to use the word 'elegant' in a Haskell paper.
13:06:15 <joelr1> now, haskell-wise, marketing is galois selling verifiability to government customers, for example
13:06:24 <dbremner> joerl1 - I'd mention 9 nines and Erlang's popularity in telecom.
13:06:44 <joelr1> dbremner: i did, people don't care. i wasn't selling to telco customers.
13:06:58 <fasta> 9 nines?
13:07:12 <joelr1> dbremner: yeah, it's 5 9s :)
13:07:54 <Philippa> cheap customisability is marketable, you just don't phrase it in a techie manner
13:08:07 <joelr1> i'm looking to develop trading software. strictly for the mac (nothing there, scores of apps on windows if not hundreds). in haskell and objective c
13:08:29 <dbremner> joelr1 - google found Joe's presentation slides, he says the AXD301 had 9 nines.
13:08:33 <joelr1> i will definitely have to use a modeling language and it's unlikely i'll come up with a new one
13:08:56 <joelr1> dbremner: 99.9999999? unlikely. i heard 5 minutes of downtime a year and that's 99.999
13:09:05 <Philippa> ouch. Bet you won't be allowed to say "haskell is my modelling language", either
13:09:05 <fasta> Oh, uptime?
13:09:07 <joelr1> dbremner: probably a typo 
13:09:11 <Philippa> despite it being an extremely sensible one
13:09:36 <joelr1> Philippa: i can say whatever i want, it's my software. but i won't. i'll use warm and fuzzy modeling language :D
13:10:16 <dbremner> joerl1 - that # is repeated frequently, either it's a propagated error or you're mistaken.
13:10:33 <joelr1> Philippa: and of course i use haskell but try to hide most of it out of the way besides the stuff in the io monad :D
13:10:51 <fasta> joelr1: What exactly do you mean by "trading"? 
13:11:38 <joelr1> dbremner: could be. but everyone is talking 5 nines. http://www.google.com/search?hl=en&lr=&safe=off&client=safari&rls=en&q=5+nines+uptime&btnG=Search
13:11:38 <lambdabot> Title: "5 nines uptime - Google Search"
13:12:01 <joelr1> fasta: futures likely. or stocks and futures 
13:12:12 <joelr1> definitely not options and forex, not initially
13:12:28 <fasta> joelr1: but how do you get the interfaces for those systems?
13:12:30 <joelr1> there are lots of funs processes to apply functional programming to
13:12:37 <joelr1> fasta: what systems?
13:12:48 <fasta> joelr1: I assume you talk to other systems?
13:13:06 <fasta> joelr1: Or are you going to create your own Wallstreet?
13:13:15 <joelr1> fasta: nope. not looking to initially. maybe yahoo quotes and that's it. after that it's sockets
13:13:33 <joelr1> fasta: no need to create your own wall st. to download end-of-day quotes
13:13:51 <dbremner> joelr1 - ah, the 9 nines figure comes from Joe Armstrong's ICFP paper but is cited as "private communication."
13:15:22 <fasta> joelr1: but downloading end-of-day quotes isn't that interesting, or am I wildly mistaken? 
13:16:33 <joelr1> dbremner: it's a bit of a funny number. joe could have said 20 nines and it would have been the same. with erlang if a process fails you restart it so that does not count as a failure. and you have multiple layers of monitors. and if a hardware box fails you switch to another one. so yes, you can just put your stuff in the closet and leave it running unattended
13:16:54 <joelr1> fasta: it's not interesting. might need to parse xml or something like that
13:17:10 <joelr1> fasta: and build a nice interface for importing text data from files
13:17:20 <joelr1> fasta: did you have a question, though?
13:17:43 <joelr1> the interesting part is modeling trading systems once you have all the data loaded
13:18:06 <fasta> joelr1: you mean data mining for behaviour?
13:18:06 <dbremner> joelr1- a couple weeks ago I talked to a guy who had worked on Nortel's Switch OS. At the time it was either the first or second largest RT system.
13:18:22 <joelr1> fasta: i guess you can call it that 
13:18:38 <joelr1> fasta: i mean writing trading systems and backtesting them on old data
13:18:43 <fasta> joelr1: In theory that doesn't work. In practice people are not rational.
13:19:00 <joelr1> fasta: right
13:19:01 <fasta> joelr1: So, in practice you could make money with that. 
13:19:15 <joelr1> or you could make money selling shovels to prospectors
13:20:32 <fasta> joelr1: I don't really get the word shovel in this context, but I think you mean that you can basically sell nice aggregrate values to your customers displayed on their 23" screen, right?
13:20:44 <joelr1> a bunch of stuff like dividend splits, futures rolls, etc. have to be verifiable so i'm hoping that haskell and quickcheck will help me properly implement those
13:21:08 <joelr1> fasta: software is shovels, traders are prospectors
13:21:43 <Philippa> sell 'em an RNG, it works out in the long run
13:21:59 <joelr1> fasta: i can sell tools to write trading systems and analyze the markets
13:22:11 * joelr1 will be back later
13:22:13 <Philippa> apparently even the best traders "run out of luck". Much like the psychics in the old experiments where they kept looking for an elite...
13:23:09 <dbremner> Phillipa - LTCM comes to mind.
13:26:31 <Korollary> I've seen a job ad of a NY trading firm looking for ocaml programmers
13:35:52 <esap> Is there a way in Data.Map to use Arrow-based functions for union of two maps? From what I can see, the combining function must be stateless, which doesn't work very well in the situation I have.
13:39:28 <vincenz> In 1h20m it's my bday \o/
13:40:32 <vincenz> @seen jethr0
13:40:32 <lambdabot> I saw jethr0 leaving #oasis and #haskell 16 days, 21 hours, 34 minutes and 11 seconds ago, and .
13:40:34 <vincenz> @seen dmhouse
13:40:34 <lambdabot> I saw dmhouse leaving #oasis and #haskell 1 day, 1 hour, 37 minutes and 29 seconds ago, and .
13:40:44 * vincenz snaps his fingers
13:41:20 <vincenz> @tell dons For some reason @tell messages got dropped.  Could this be due to the fact that you might have restarted lambdabot?
13:41:21 <lambdabot> Consider it noted.
13:46:25 <isaacd> @tell isaacd something
13:46:25 <lambdabot> You can tell yourself!
13:47:45 <norpan> that's an interesting message
13:53:40 <Ulfalizer> @tell foo @tell foo bar
13:53:40 <lambdabot> Consider it noted.
13:53:53 <Ulfalizer> oh, that's how it works..
13:55:30 <int-e> @tell lambdabot and who'll clean up all these stupid messages?
13:55:31 <lambdabot> Nice try ;)
13:59:40 <ihope> Eh, once foo joins this channel, we'll be okay.
14:01:24 <int-e> @messages
14:01:24 <lambdabot> You don't have any new messages.
14:01:47 <isaacd> There is a "foo"
14:01:52 <int-e> I know :)
14:02:27 <isaacd> :)
14:04:06 <ihope> Hmm... pretty-printing proofs. That's a challenge.
14:05:04 <norpan> what kind of proofs
14:05:32 <ihope> Proofs that 2 + 2 = 4 and stuff like that.
14:06:14 <sieni> hmm... we'd need hs-typesetting
14:06:26 <vincenz> ihope: there's a package out for it
14:06:40 <sieni> maybe that would be a nice way to learn haskell, since (La)TeX sucks
14:06:44 <norpan> well, you can prove that 2 + 2 = 4 on many different levels
14:06:52 <ihope> vincenz: where's that?
14:06:57 <vincenz> ihope: check LTu
14:07:01 <ihope> norpan: it's Peano here.
14:07:04 <vincenz> ihope: there was something about mathtexo r so
14:07:40 <sieni> like 2 + 2 = (1 + 1) + (1 + 1) = ((1 + 1) + 1) + 1) = 4
14:08:25 <norpan> SSZ + SSZ = S(SZ+SSZ) = SS(Z+SSZ) = SS(SSZ) = SSSSZ
14:08:42 <int-e> 2 + 2 = 0'' + 0'' = (0'' + 0')' = (0'' + 0)'' = (0'')'' = (0''')' = 0'''' = 6
14:08:44 <int-e> 4
14:09:05 <int-e> same :)
14:09:11 <norpan> yes if you recurse on that one instead :)
14:09:30 <int-e> well, isomorphic at least.
14:09:39 <astrolabe> I can't beleive you got 2 + 2 wrong :)
14:10:21 <int-e> I just applied a wrong definition for 6 - other than that it was all correct ;)
14:10:33 <Korollary> it's a metric 6
14:10:59 <chessguy> what's SSZ?
14:11:06 <vincenz> succ succ zeo
14:11:09 <chessguy> ah
14:11:14 <sieni> Korollary: I'd say it's a U.S. 6, like war is U.S. peace and dictatorship is U.S. freedom
14:11:41 * Korollary sends sieni to Guantanamo Bay
14:11:46 <int-e> The choice of digits is arbitrary and there are 10 of them to memorize, so messing up one of these definitions is a minor sin.
14:11:48 * int-e giggles
14:12:08 <chessguy> yes, but if you're guilty of one, you're guilty of 'em all
14:12:21 <int-e> SSZ is what GEB uses.
14:13:58 <sieni> I like <N,+,*,0,1> notation and as you can see, there are fewer steps!!1!
14:14:37 <ihope> What if I don't have access to the values themselves, only the axioms I'm applying?
14:14:50 <norpan> sieni: but you skip steps
14:14:50 <ihope> sieni: that looks more like a definition of a ring than a notation.
14:15:32 <norpan> of course there are fewer steps if you skip some :)
14:15:45 <ihope> Even if you add more than you skip?
14:15:57 <Korollary> there are no steps. 2+2=4 as intelligently designed.
14:17:04 <sieni> norpan: no, how? with <N,*,+,0,1> stuff like (0''+0')' is the same formula as (0''')', which is the same formula as 0''''
14:17:11 <ihope> Well, it's tricky to understand a proof that 2+2=4 which uses only axioms in different orders...
14:17:40 <ihope> The proof that 2 = 2 is "by the reflexive property of equailty", for example.
14:17:52 <int-e> I probably should have skipped the (0''')' step.
14:18:34 <Korollary> metamath.org has it all
14:19:06 <norpan> sieni: how would you differentiate the function 1+1 and the constant 1+1
14:19:32 <ihope> The proof that 2 + 2 = 3 + 1 is "by the definition of addition to a successor", and that of 3 + 1 = 4 + 0 is the same, so the proof that 2 + 2 = 4 + 0 is "by the transitive property of equality along with the definition of addition to a successor and the definition of addition to a successor".
14:19:43 <sieni> norpan: wtf?
14:19:52 <int-e> we can do it worse, we can use set theory and the natural definition of natural numbers, 0 = {}, 1 = {0}, 2 = {0,1}, 3 = {0,1,2}, etc. succ x = {x} \/ x; pred x = union x.
14:21:41 <sieni> norpan: 1+1 is a formula, not a function nor a constant (unless you mean that formulas are constants, i.e. are looking at the formulas themselves and not the values they refer to)
14:22:20 <norpan> i think we are talking about different things
14:22:25 <Itkovian> evening
14:22:59 <sieni> norpan: how?
14:23:09 <norpan> 1 is an element in the set, + is a relation (function) on the set
14:23:54 <norpan> we want to prove that 2+2 is the same as 4
14:24:06 <Korollary> how could you
14:24:18 <Korollary> 2+2 e R, 4 e S
14:24:51 <norpan> R?
14:24:53 <norpan> S?
14:24:53 <int-e> Korollary: obviously we need to define a lot of things first. Which is why we ended up with 4 or 5 different proofs.
14:25:08 <sieni> norpan: I was using the symbols in the language and usual Peano axioms. You can call the symbols +, *, 0 and 1 and the corresponding functions on N + and * and the elements of N 0 and 1 
14:25:12 <int-e> (all more or less incompatible with each other)
14:25:15 <Korollary> R is the relation defined as a subset of SxS
14:26:02 <int-e> well, + is a ternary relation (binary function)
14:26:15 <int-e> so be careful
14:26:47 <Korollary> boom. Italy 1-0
14:27:12 <sieni> so 2 is just short for 1+1 and 4 is just short for ((1+1)+1)+1
14:27:58 <Korollary> so you're not defining the function +. You're definining the equality predicate
14:28:37 <Korollary> lol 2-0
14:28:42 <norpan> sieni: i don't like using + for both the function + and for constants
14:28:46 <Itkovian> how can i make sure that "parseTraceMonadic ss = execState (mapM (\x -> let y = modify (updateState x) in y `seq` y) ss) initialParserState
14:28:49 <sieni> 2-0 \o/
14:28:49 <Itkovian> " doesn't retain too much information along the way that isn't needed anymore?
14:29:22 <Itkovian> Korollary: I'm not sure who should win
14:29:37 <int-e>  y `seq` y == y ... so that part is useless.
14:30:08 <norpan> bed time
14:30:30 <int-e> (you're forcing y when y is forced ...)
14:30:31 <Itkovian> int-e: hmm, yes, but it makes sure y is evaluated, no?
14:30:44 <sieni> cool finish from Italy, although I was on the German side :-)
14:30:45 <Itkovian> well, I used to not have the seq
14:30:54 <Korollary> classy goals
14:31:18 <isaacd> Itkovian: it only make sure y is evaluated when its value is needed, which is already true
14:31:23 <kosmikus> good match
14:31:41 <Itkovian> okok ... but I'm using 2+gig heap here.
14:31:51 <Itkovian> I could profile, but that takes a _long_ time
14:32:45 <isaacd> Itkovian: possibly seq could be used in some other way to add strictness (which might or might not help)
14:33:05 <sieni> Korollary: well, Italy was much more active, so it was an earned end result
14:34:23 <Korollary> sieni: In the extra time maybe. the first 90 was pretty 50-50
14:34:36 <Itkovian> isaacd: updateState updates one of the maps from a record structure that is used as the state, perhaps I should fiddle there somewhat
14:34:59 <kosmikus> I guess one can say it was earned in the end.
14:35:22 <sieni> Korollary: I think it was something like 60-40. Italy was applying pressure all the time.
14:35:24 <kosmikus> congratulations to .it
14:35:34 <int-e> hmm. strictifyState = get >>= (`seq` return ())
14:36:06 <sieni> congratulazioni \o/
14:36:20 <Korollary> Forza Italia
14:36:39 <isaacd> Itkovian: good luck
14:37:04 <Itkovian> isaacd: do I hear irony? ;-)
14:37:16 <int-e> Itkovian: this could - maybe - help; the idea is to have an actual monad action that depends on the monad state
14:37:21 <sieni> well, i've got 7 cousins and 2 aunts that are italian citizens, so I have more than a good reason to support germany in such a match ;-)
14:37:33 <isaacd> Itkovian: I hadn't meant to be, but unfortunately it is that way when dealing with such things in Haskell
14:37:35 <Itkovian> sieni: yeah!
14:37:43 <Itkovian> isaacd: np :-)
14:37:51 <int-e> Itkovian: unfortunately, State is inherently lazy, there's no seq to be found anywhere in the module.
14:38:12 <Itkovian> int-e: I had hoped it might clean up my code somewhat, which it did
14:38:31 <Itkovian> but now I'm stuck with memory trouble
14:39:14 <isaacd> Itkovian: did you use seq before, or why did it not have this problem then?
14:39:46 <Itkovian> @url pastebin
14:39:47 <lambdabot> http://rafb.net/paste
14:39:56 <Itkovian> @url paste-bin
14:39:57 <lambdabot> I know nothing about paste-bin.
14:40:53 <isaacd> @paste
14:40:53 <lambdabot> http://paste.lisp.org/new/haskell
14:41:29 <int-e> If it's a truely linear computation you could try a MonadState instance built on top of an ST Monad and one STRef. The writes to and reads from the STRef would act as sequencing points and are an obvious place to put a strategic `seq`. Now I feel dirty for suggesting this.
14:45:02 <Itkovian> http://rafb.net/paste/results/MRxidb20.html
14:45:05 <Itkovian> ah well
14:45:42 <Itkovian> int-e: hmm, it'll take me prolly another day to grok all that
14:53:04 <coward> OT: why is the cantor set compact?
14:59:25 <Daveman> xerox :)
14:59:29 <int-e> Itkovian: but I'd really give y >> get >>= (`seq` return ()) a try first (instead of y `seq` y)
14:59:51 <Itkovian> int-e: sure
15:01:09 <isaacd> dang keyboard crash
15:01:28 <isaacd> It kept outputting 'r's and ignoring my input, and I had to reboot
15:01:37 <isaacd> @where paste
15:01:38 <lambdabot> http://paste.lisp.org/new/haskell
15:01:38 <Itkovian> weird
15:02:06 <isaacd> Why are there three or more ways of asking that, some of which give different answers?
15:03:10 <norpan> isaacd: versatility?
15:03:13 <int-e> because the people who added the links had different preferences?
15:03:19 <int-e> lisppaste2: url
15:03:20 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:03:22 <int-e> 4 ;)
15:04:42 <Itkovian> no, 2+2
15:04:57 <norpan> no ((1+1)+1)+1)
15:07:08 <isaacd> It does make sense to have different ways of asking, so that if someone tries something, they
15:07:15 <isaacd> 're more likely to get an answer
15:07:28 <astrolabe> coward: because it is closed and bounded
15:10:44 <int-e> @where paste
15:10:45 <lambdabot> http://paste.lisp.org/new/haskell
15:11:05 <isaacd> or ():():():():error "we don't know yet whether there are more"
15:12:27 <int-e> > last $ repeat "<<Loop>>"
15:12:31 <lambdabot> Terminated
15:13:37 <isaacd> > error $ cycle "<<Loop>>"
15:13:38 <lambdabot>  Add a type signature
15:13:45 <isaacd> > (error $ cycle "<<Loop>>") :: Int
15:13:54 <isaacd> poor lambdabot
15:14:05 <isaacd> It should be easy to fix
15:14:38 <isaacd> lambdabot: sorry for bothering you so
15:14:58 <int-e> ugh.
15:18:58 <isaacd> > throw
15:18:59 <lambdabot>  Not in scope: `throw'
15:20:36 <isaacd> mapException (\e -> case e of ErrorCall str -> take 200 str; _ -> e)
15:20:42 <isaacd> or whatever instead of 200
15:20:52 <isaacd> from Control.Exception
15:21:32 <isaacd> applied to the result of the inputted Haskell string
15:22:42 <Itkovian> night
15:22:48 <isaacd> It's good that access is not given to just any kind of exception
15:24:05 <isaacd> Rather, mapException (\e -> case e of ErrorCall str -> ErrorCall (take 200 str); _ -> e)
15:26:24 <isaacd> > Just {}
15:26:25 <lambdabot>  Add a type signature
15:26:32 <isaacd> > Just {} :: Maybe Int
15:26:33 <lambdabot>  Missing field in record construction
15:27:03 <isaacd> > assert
15:27:04 <lambdabot>  Not in scope: `assert'
15:27:32 <isaacd> > (\Nothing -> 1) (Just 3)
15:27:34 <lambdabot>  Non-exhaustive patterns in lambda
15:27:44 <isaacd> > (\Nothing -> 1) Nothing
15:27:45 <lambdabot>  1
15:35:59 <sylvan> I'm going to write a Haskell -> PHP translator, then I'll write a winning entry for the ICFP contest, just to hear the judges proclaim that PHP is the language of choice for discriminating hackers...
15:37:11 <fanopanik> php sure is a marvellous language
15:38:08 <sylvan> yeah.... or something... 
15:40:13 <mikael> that'd be a fun prank even if you rewrote your program by hand
15:41:07 <fanopanik> since I've seen a scheme implementation in javascript I'm willing to believe _anything_.
15:45:08 <bolrod> you're actually dead, but you don't know it yet.
15:46:48 <zeeeee> hi all, i'm trying to do exercise 3.10 from Yet Another Haskell Tutorial. i was wondering why my attempt 1 doesn't work: http://rafb.net/paste/results/yLgcnn63.html
15:49:57 <bolrod>      then do sum nums  <--  I guess it's that
15:50:07 <int-e> try  return sum nums  instead of  sum nums
15:50:27 <int-e> > do 1
15:50:27 <lambdabot>  add an instance declaration for (Num (t t1))
15:50:28 <lambdabot>   In the result of a 'do' ex...
15:53:01 <int-e> that's helpful, but actually I'd expect that to be 1?
15:53:06 <lisppaste2> petekaz pasted "Is there a more idiomatic way of doing this?" at http://paste.lisp.org/display/22077
15:53:50 <petekaz> I'm trying to split a long string on "\n\n", is my code ok?  It works, but wondering if it's passable as haskell.
15:54:24 <zeeeee> > do 1
15:54:24 <lambdabot>  add an instance declaration for (Num (t t1))
15:54:25 <lambdabot>   In the result of a 'do' ex...
15:54:53 <int-e> http://haskell.org/onlinereport/exps.html#sect3.14 says nothing about types ... it just gives a rule for rewriting the do block.
15:54:53 <lambdabot> Title: "The Haskell 98 Report: Expressions"
15:58:19 <zeeeee> bolrod, int-e: ok i just tried "return sum nums" instead but it still doesn't work
15:58:51 <int-e> zeeeee: my bad. return (sum nums)
15:59:16 <zeeeee> int-e: oh wow, that works. thanks!
15:59:24 <zeeeee> this is way confusing
16:01:06 <int-e> zeeeee: the point is that  do e == e ; so you were returning a sum instead of an IO action that returns the sum, and then tried to use it as an IO action.
16:02:39 <zeeeee> int-e: yeah, i should keep reading to find out what things like "return" and "IO action" mean...maybe this tutorial wasn't the best in its ordering of topics
16:03:04 <dons> morning haskell hackers!
16:03:21 <petekaz> morning.
16:04:12 <sieni> morning, sort ofg
16:04:12 <eric_j> would it be possible to put the return before the if too?
16:04:42 <int-e> zeeeee: no.
16:05:11 <zeeeee> int-e: i'm guessing that was to eric_j?
16:05:23 <int-e> zeeeee: oh, indeed.
16:06:07 <petekaz> any takers for comments on that 3-line paste?
16:07:01 <int-e> petekaz: I had a look at it but I couldn't improve it
16:07:19 <petekaz> ok, thanks.
16:07:57 <petekaz> just wanted to make sure there wasn't something more obvious.
16:17:05 <rafl> Is it possible to use ccache with ghc?
16:18:18 <dons> oh, sounds interesting. what's ccache again?
16:18:50 <rafl> Compiler results cacher, for fast recompiles
16:19:14 <dons> ah, interesting. well, ghc does already cache results, in .hi files
16:19:29 <dcoutts> morning dons 
16:19:37 <dons> we'd have to see how ccache worked to see if it would be any benefit
16:19:40 <dons> hey dcoutts 
16:19:52 <dons> talked to roman some more about streams, he's keen to work on the paper
16:19:59 <dcoutts> cool
16:20:00 <dons> also, he'll be leaving for cambridge next week
16:20:13 <dcoutts> so it'd be the three of us as authors on said paper
16:20:38 <dcoutts> nice, I should arrange to meet him and the simons in cambridge
16:20:39 <dons> i'd say so
16:20:59 <dons> yeah, find out exactly when he's in cambridge. i know he also needs to go to st peterberg
16:21:54 <rafl> dons: ccache is a wrapper around gcc which caches object files. It's probably comparable with .hi files, but the cache is usually not in the same directory as the code is which allows to build a cleaned source tree very fast.
16:26:17 <dons> rafl, you would be able to use it, i suppose (via -pgmc-ccache or something)
16:26:24 <dons> but i'm not sure it would be a win, would it?
16:26:29 <dons> maybe it would be
16:27:27 <ihope> A command line option that doesn't start with f? Wow, that's a new one :-P
16:27:38 * rafl didn't know of -pgmc
16:27:43 <rafl> I'll give it a try.
16:30:12 <dons> it would be interesting to try distcc as well
16:30:25 <dons> though ideally a distghc would be written. that would rock
16:30:45 <dcoutts> has anyone done some profiling to see which ghc phases take most time
16:30:55 <dcoutts> in both -O0 and -O1 modes
16:31:02 <ihope> You know, this code is definitely going to require -falllow-incoherent-instances, -fallow-undecidable-instances, and -fallow-overlapping-instances :-P
16:31:13 <dcoutts> only some phases can be distributed easily
16:31:44 <dcoutts> a bigger payoff may be to avoid using gcc for compiling and assembling
16:32:05 <dcoutts> or perhaps the assembly phase is blindingly quick
16:32:30 <dcoutts> I've often wondered how hard it'd be to write the binary elf file directly
16:32:31 <Pseudonym> We need -fjust-allow-any-instances-i-say-trust-me-on-this
16:32:38 <dcoutts> it'd also make a jit possible
16:32:51 <dcoutts> just write the object code to memory
16:32:58 <Korollary> -fallow-inconsistent-axioms
16:33:13 <dcoutts> eg a faster ghci but compiling into memory rather than using bytecode
16:33:15 <dcoutts> ghci -O
16:33:16 <ihope> -allow-everything
16:33:29 <ihope> Erm, -fallow-everything
16:34:04 <Korollary> -fallow-you-fallow-me for Genesis fans (eek)
16:34:09 * Korollary seeks therapy
16:34:49 <dons> compiling into memory with bytecode sounds interesting
16:34:59 <dons> i wonder, maybe there is room still to improve the speed of ghci
16:35:00 <ihope> So if I "import qualified Prelude as P", will I also have to use P.: and P.[]?
16:35:09 <dons> the turnaround, i mean
16:35:11 * Pseudonym doesn't recognise post-Peter-Gabriel-and-Steve-Hackett-Genesis as truly being Genesis
16:35:34 <dcoutts> dons, I was thinking of not going via bytecode at all, just use the cmm backend and then assemble into memory
16:35:38 <dons> oh, i feel so young. i assumed 'Genesis' meant 'Evangelion Neon Genesis' :/
16:35:53 <ihope> Oh, I can just test it...
16:36:00 <Pseudonym> Well, Peter Gabriel left the band when I was like... two.
16:36:18 <Pseudonym> But I can still be a snob about it.
16:36:20 <dons> hehe
16:36:27 * dons -> uni, back later
16:37:51 <ihope> "Duplicate instance declarations:"
16:38:01 <ihope> Those aren't duplicates! *boom*
16:38:46 <ihope> It's calling "instance Provable (Eq a b) => Provable (Eq b a) where" and "instance (Provable (Eq a b), Provable (Eq b c)) => Provable (Eq a c) where" duplicates...
16:41:04 <rafl> using ccache as the compiler command doesn't really work. It either thinks the input is not a c/c++ file or it refuses to cache because of unsupported compiler options.
18:27:20 <Frederick> hail
19:02:30 <dons> rafl: ah, yes, could be unsupported compiler flags
19:16:39 <mathewm> ?where paste
19:16:39 <lambdabot> http://paste.lisp.org/new/haskell
19:17:34 <lisppaste2> mathewm pasted "How does this work??" at http://paste.lisp.org/display/22089
19:20:50 <dons> build' :: [a] -> a -> r
19:20:57 <dons> that r could be a (a -> x)
19:21:05 <dons> hence, BuildList a (a->r)
19:21:14 <dons> thus, build' :: [a] -> a -> (a -> r)
19:21:32 <dons> and so on, generating a whole set of ever larger types, yeah?
19:21:48 <dons> it's a cool trick, imo
19:24:51 <mathewm> thanks dons
19:37:51 <mathewm> I see - the type checker sees that there are more parameters, so the 'BuildList a [a]' doesn't fit, but the 'BuildList a (a->r)' does ... until it reaches the base case of 'BuildList a [a]'
19:39:35 <dons> :)
19:39:39 <dons> its cool, heh?
20:09:44 <petekaz> > map (isPrefixOf "bc") (tails "abcabcabca")
20:09:45 <lambdabot>  [False,True,False,False,True,False,False,True,False,False,False]
20:10:44 <petekaz> Is there a simple way to somehow use this list of T/F to split the string on "bc" so it returns a list of ["a", "a", "a", "a"]?
20:12:30 <petekaz> dons: you are good with the one-liners, got any suggestions?
20:15:42 <petekaz> > findIndices (==True) $ map (isPrefixOf "bc") (tails "abcabcabca")
20:15:44 <lambdabot>  [1,4,7]
20:17:43 <lispy> > zipWith (!!) "abcabcabca" (findIndices (==True) $ map (isPrefixOf "bc") (tails "abcabcabca"))
20:17:44 <lambdabot>  Couldn't match `[a]' against `Char'
20:18:11 <lispy> @type zipWith (!!)
20:18:12 <lambdabot> forall a. [[a]] -> [Int] -> [a]
20:19:46 <petekaz> lispy: I'm trying to get build something like this: split "\n\n" "pete\n\nwas\n\nhere" and have it return ["pete", "was", "here"].  
20:20:31 <petekaz> And I wanted to see if there were any cool haskell laziness tricks I could play (like the isPrefixOf and tails combo).
20:21:36 <dons> > lines "pete\n\nwas\n\nhere"
20:21:37 <lambdabot>  ["pete","","was","","here"]
20:21:44 <dons> > filter (not.null) $ lines "pete\n\nwas\n\nhere"
20:21:46 <lambdabot>  ["pete","was","here"]
20:21:56 <dons> how's that?
20:21:58 <petekaz> dons: I am trying to make it generic for any pattern.
20:22:05 <dons> ah, you want 'split'?
20:22:11 <petekaz> but that is better than the one I wrote.
20:22:32 <petekaz> http://paste.lisp.org/display/22077
20:22:39 <petekaz> (that was my version)
20:23:25 <petekaz> yours wouldn't work if there were single newlines intermixed though.
20:23:47 <dons> right
20:24:07 <dons> but the function split :: String -> String -> [String] has been written by others before us
20:24:13 <dons> its in MissingH, let me find it
20:24:18 <petekaz> I have it
20:24:30 <petekaz> It just uses a ton of other stuff in missingh.
20:24:44 <dons> right
20:24:51 <petekaz> I was more interested in finding a neat alternative and I thought I was onto something with my examples above.
20:24:55 <dons> there's another version in lambdabot, let's see.
20:25:06 <petekaz> > findIndices (==True) $ map (isPrefixOf "bc") (tails "abcabcabca")
20:25:08 <lambdabot>  [1,4,7]
20:25:25 <dons> breakOnGlue _ [] = ([],[])
20:25:25 <dons> breakOnGlue glue rest@(x:xs)
20:25:25 <dons>     | glue `isPrefixOf` rest = ([], rest)
20:25:25 <dons>     | otherwise = (x:piece, rest')
20:25:25 <dons>         where (piece, rest') = breakOnGlue glue xs
20:25:35 <dons> split glue xs = split' xs
20:25:35 <dons>     where
20:25:35 <dons>     split' [] = []
20:25:35 <dons>     split' xs' = piece : split' (dropGlue rest)
20:25:35 <dons>         where (piece, rest) = breakOnGlue glue xs'
20:25:38 <dons>     dropGlue = drop (length glue)
20:25:54 <dons> so split here uses breakOnGlue, which is like break, but for [Char] -> [Char]
20:26:06 <dons> so its along the lines of your isPrefixof solution
20:26:24 <dons> but i imagine that you could merge split and breakOnGlue, and you'd end up with something like your findindices trick
20:26:50 <petekaz> I just can't figure out where to go from my findIndices point.
20:27:29 <dons> use splitAt in a loop?
20:27:32 <dons> in a fold
20:27:46 <dons> splitAt 1 "abcabcabca"
20:27:51 <dons> > splitAt 1 "abcabcabca"
20:27:53 <lambdabot>  ("a","bcabcabca")
20:28:49 <petekaz> yeah, but after the first one, its harder cuz you don't know where the string should start.
20:28:53 <dons> yep
20:29:24 <petekaz> oh well, I think I am thinking too hard.  If you can't think of a one-liner, then I feel comfortable with the lambdabot solution.
20:29:58 <dons> i think there's a one liner... ;)
20:30:56 <petekaz> yeah?  lemme guess, it's over 500 characters in length?
20:31:21 <dons> no no, a magic fold. let me hack..
20:31:21 <petekaz> s/\n//
20:31:51 <petekaz> okie, knock yourself out.
20:47:41 <dons> @seen sjanssen 
20:47:42 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
21:20:23 <tato> I wrote a program which outputs an undirected weight graph; are there any general techniques for drawing such a graph?
21:22:37 <dons> well, there's 'dot' -- isn't that a generic graph drawer?
21:23:34 * tato googles...
21:24:01 <tato> oh, nice, thanks
21:24:28 <u221e> Speaking of which, doesn anyone have a gmail invite they can shoot me?
21:24:38 <dons> u221e: you don't need invites anymore , do you?
21:25:01 <u221e> Yes you do.
21:25:22 <dons> hmm, I didn't need an invite recently
21:25:38 <u221e> How did you sign up then?
21:25:48 <dons> clickity clickity something something done.
21:25:54 <dons> anyway, i might have an invite. let's see..
21:26:17 <tato> " You can get a Gmail account if you're invited by someone who already has one. Or, you can sign up for an account using your mobile phone."
21:26:32 <u221e> Heh
21:26:34 <dons> ah, that's what i did
21:26:45 <dons> they sent me a login key on my mobile
21:26:52 <tato> you gave google your mobile phone number? 
21:27:02 <dons> sure
21:27:07 <dons> and sold them my first born
21:27:23 <tato> google should rename themselves to SkyNet
21:27:29 <fanopanik> I'd rather give it to google than to MS
21:27:52 <johnnowak> the mobile phone bit is some rather impressive marketing
21:28:02 <tato> I'm waiting for google to take over information technology for the pentagon
21:31:20 <u221e> So, any invites? If you haven't been using them you should have alot.
21:31:45 <Korollary> I have 50
21:31:55 <dons> doesn't seem to be any in my account. the help thingy says they're randomly distributed, and you'll i'll get my chunk eventually
21:32:14 <Korollary> u221e: pm me your email and I ll do it
21:34:55 <dons> now, do you think its faster to transfer 4k mp3 files over the network using scp -r mp3 foo: (i.e. one at a time), or tar cf - mp3 | ssh foo "cat | tar xf -" ?
21:35:04 <dons> so around 10G or so.
21:35:24 <u221e> Figures...
21:35:28 <dons> i'm inclined to think the later version, but not sure.
21:36:29 <Korollary> bah. irssi locked up.
21:36:32 <u221e> Why would the later be faster?
21:37:02 <u221e> Korollary, Did you get my email?
21:37:07 <Korollary> no. pm me again. sorry
21:37:27 <dons> it avoids O(n) start and end operation when copying files, by instead copying a single massive chunk, and doing the file io on the remote end
21:37:57 <Lemmih> @seen shapr
21:37:57 <lambdabot> I saw shapr leaving #haskell 5 days, 17 hours, 48 minutes and 40 seconds ago, and .
21:37:58 <u221e> Heh I'm unregistered, so try: u221egmail@mailinator.com
21:38:05 <dons> based on the evidence that tarring up a local dir and then copying it is much faster than scp -r *
21:38:43 <Korollary> done
21:38:55 <Lemmih> ChilliX: ping.
21:39:26 <dons> Lemmih: I spoke to Chilli, he's aware of the deadline, and was waiting on hearing back from his student
21:39:42 <Lemmih> dons: Ok, thanks.
21:39:51 <dons> Lemmih: is there anyone else who's not yet submitted their review?
21:39:58 <u221e> Got it, thanks.
21:40:38 <dons> shapr?
21:40:46 <dons> and JaffaCake?
21:40:54 <Lemmih> dons: Shae, Simon, Chakravarty and Malcome Wallace.
21:41:16 <dons> oh, didn't malcolm mail last night?
21:41:18 <u221e> " Creating a Google Account activates Personalized Search, which finds the search results most relevant to you based on your search history and more. "
21:41:21 <dons> before SyntaxNinja
21:41:24 <u221e> Is that new? :P
21:41:24 <Lemmih> Err, right.
21:41:34 <dons> so Shae Simon and Manuel then.
21:41:39 <dons> @get-shapr
21:41:40 <Lemmih> Yeah.
21:41:41 <lambdabot> shapr!!
21:41:52 <dons> @seen JaffaCake
21:41:53 <lambdabot> Last time I saw JaffaCake was when I left #darcs, #flippi, #gentoo-haskell, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it, #haskell.se, #haskell_ru, #oasis, #perl6 and #
21:41:53 <lambdabot> scannedinavian 2 days, 23 hours, 56 minutes and 20 seconds ago, and .
21:42:03 <dons> @seen shapr
21:42:03 <lambdabot> I saw shapr leaving #haskell 5 days, 17 hours, 52 minutes and 46 seconds ago, and .
21:42:07 <Korollary> u221e: Yes, they know everything about you from now on.
21:42:07 <dons> hmm :/
21:42:08 <Lemmih> It's a bit weird that shapr hasn't been on for five days.
21:42:14 <dons> yeah, didn't he move to stockholm?
21:42:33 <dons> but then he logged on from his mobile a few days ago.
21:43:28 <Lemmih> Right, he was on yesterday (or earlier today depending on your location).
21:43:44 <u221e> Hm, the email username must be +6 chars... u221e is only 5. Damnit.
21:44:30 <dons> is he aware of the review and the deadline, Lemmih/
21:45:37 <Lemmih> dons: I don't know. If he hasn't checked his mail then he probably isn't.
21:47:09 <dons> @tell shapr Have you filled out your SoC review (http://code.google.com/soc/mentor_home.html). The deadline is today.
21:47:10 <lambdabot> Consider it noted.
21:47:18 <dons> @tell JaffaCake Have you filled out your SoC review (http://code.google.com/soc/mentor_home.html). The deadline is today.
21:47:18 <lambdabot> Consider it noted.
21:58:15 <dons> @tell vegai did you get the lambdabot built?
21:58:16 <lambdabot> Consider it noted.
22:04:18 <u221e> Ah, finally thought of a username... all done. Thanks again Korollary.
22:07:24 <Korollary> np. I have 99 more invites if anybody else needs a gmail acct
22:12:07 <u221e> You can donate them if you want to http://www.bytetest.com/
22:12:18 <u221e> Although I don't think google likes people doing that
22:13:36 <Lemmih> Nothing happens when I click "Donate invite(s)".
22:14:03 <u221e> Did you send the invite to yourself then copy the url into the box?
22:14:25 <Lemmih> Bah, Never mind. I'm just stupid /-:
22:18:08 <u221e> Lemmih, Did you just add an invite?
22:21:59 <Lemmih> u221e: I added 19.
22:22:43 <u221e> Well, I noticed people have been grabbing them immediately. Heh
22:27:33 <vincenz> j 
22:27:46 <vincenz> @join #oasis
22:28:18 <vincenz> dons: ping
22:39:11 <foxy_> ?hoogle trace
22:39:11 <lambdabot> Debug.Trace.trace :: String -> a -> a
22:39:12 <lambdabot> Debug.Trace :: module
22:39:12 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
22:51:10 <kzm> @seen dons
22:51:11 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 52 minutes and 56 seconds ago.
22:56:56 <lisppaste2> iyu annotated #20388 with "uiyi" at http://paste.lisp.org/display/20388#2
23:14:19 <dons> kzm?
23:15:06 <kzm> We talked about...well, I mentioned, at least - using Data.Map BS Int vs Data.Map Int Int  (where the first Int is a hash of the BS)
23:15:19 <kzm> I did some timings.
23:15:47 <dons> yep
23:15:47 <kzm> And Ints are faster.
23:15:54 <dons> oh, interesting.
23:16:07 <kzm> Yes, I knew you'd be thrilled and fascinated :-)
23:16:14 <dons> well, that's good to know
23:16:25 <dons> maybe we should add back the hash function i used to have on bytestrings
23:16:47 <kzm> Okay, I know it's a niche application.  My case is special, since I only have an alphabet size of four.  So easily packable.
23:16:59 <dons> ah, you pack. yep
23:17:12 <dons> i did that for an IntMap in one of the other shootout benchmarks
23:17:14 <kzm> Yes, not really hashing, I guess.  Or one-to-one hashing.
23:17:28 <dons> interesting that its faster packed.
23:17:34 <kzm> Hmm...I'm not even using IntMap.  There is more to be gained, it seems.
23:17:37 <marc_vw> (nick help
23:17:53 <dons> we did actually try 4 byte at a time compare after an idea from vincenz, that ended up slower
23:17:58 <dons> but not for the case of length = 4
23:18:29 <kzm> OTOH, my BS version may not be optimal.
23:19:08 <kzm> slower than memcmp?
23:19:14 <kzm> or than byte at a time comparison?
23:20:05 <dons> i think the latter.
23:20:10 <dons> can't quite remember though
23:21:11 <kzm> I guess everything is against L1 cache anyway, so loading four bytes isn't going to save you much.  Especially on netburst.
23:21:55 <kzm> The extra book-keeping will perhaps not be worth it.
23:24:32 <kzm> I guess I should mention that hashes are pretty fast, since the words overlap.  I just: add next_letter . mod 4^k . shift 1
23:27:21 <dons> yeah, l1 cache, that's what we figured
23:31:53 <dons> i'd be interested to know how much better the IntMap is.
23:32:02 <dons> i've found it to be worth at least a few percent
23:35:17 <vincenz> dons: hi
23:35:31 <dons> hey
23:35:37 <dons> you pingified?
23:35:37 <vincenz> I think lambdabot drops @tell messages
23:35:44 <vincenz> when you reboot him
23:35:59 <dons> i didn't reboot him? but maybe he got kicked or dropped off
23:36:04 <vincenz> oh
23:36:04 <dons> hmm, still shouldn't drop them though
23:36:15 <vincenz> I don't know, I've had people not know they had messages
23:36:16 <dons> so something got dropped last night?
23:36:17 <dons> ?uptime
23:36:18 <lambdabot> uptime: 8 hours, 22 minutes and 27 seconds
23:36:20 <vincenz> yeah
23:36:30 <dons> ^^ see i didn't reboot, but maybe the server dropped him
23:36:41 <dons> which should throw an exception, and trigger a state flush
23:36:43 <vincenz> oh well it wasn't last night
23:36:44 <sieni> dons: you are clearly not using an enterprise level implementation language with lambdabot
23:36:45 <vincenz> it was the night before
23:36:56 <vincenz> monday -> tuesday
23:36:57 <dons> sieni: thanks, i suppose so :}
23:37:04 <vincenz> btw, today is my bday \o/
23:37:14 <dons> happy birthday vincenz!
23:37:29 <lambdabot> Happy birthday to you, happy birthday to you!
23:37:40 <vincenz> :)
23:38:24 <dons> i find  "enterprise" such a funny adjective for good software. considering so much commerical software sucks hard
23:38:35 <dons> it always makes me grin
23:39:17 <vincenz> enterprise means: you need enterprise class hardware to run it
23:39:24 <dons> heh
23:39:24 <vincenz> like 5 sun servers and 3 db servers
23:39:30 <vincenz> just for one lousy website
23:39:40 <dons> yeah, some 500k server to run apache
23:39:46 <mlh> you need enterprise size bank account to pay for support
23:39:53 <dons> ah, perhaps that's it.
23:40:30 <vincenz> it's structured like an enterprise with N^N=tier
23:40:41 <vincenz> erm -tier
23:40:47 <dons> or perhaps its something to do with the starship enterprise. always lost in space? getting blown up and attacked all the time?
23:41:01 <vincenz> sounds like a bad GC
23:46:23 <gour> araujo: ping
23:47:14 <araujo> gour, pong
23:47:27 <vincenz> gour, araujo: net
23:47:38 <araujo> vincenz, web
23:47:42 <araujo> :-)
23:47:48 <gour> araujo: hi, i'd like to try your himerge. do you have some ebuild available?
23:48:03 <gour> vincenz: out :-)
23:48:38 * vincenz sighs as he has to use two different ASTs in his compiler
23:48:44 <vincenz> one for parsing/binding/typechceknig
23:48:47 <vincenz> and another for analysis
23:48:55 <araujo> gour, right, i saw your mesage and i wrote one a few hours ago, if you want to test it, use the overlay http://haskell.org/~gentoo/gentoo-haskell/
23:48:56 <lambdabot> Title: "Index of /~gentoo/gentoo-haskell"
23:49:11 <araujo> i just commited it btw :-)
23:49:49 <vincenz> @tell JohnMeacham I'm working on a compiler that I'm writing in haskell.  If possible I wouldn't mind discussing some implementation choices you made for the representation of ASTs, annotations and those sort of things.  Thanks!
23:49:50 <lambdabot> Consider it noted.
23:50:04 <gour> araujo: thanks. i'll do. yesterday i pulled from the overlay, but wasn't there (yet :-)
23:50:23 <araujo> gour, yeah , i committed it around 2hrs. ago
23:50:52 <araujo> gour, enjoy and please feel free to ping me if anything 
23:51:12 <gour> araujo: thanks. sure i'll ping ;)
23:51:21 <araujo> :-)
23:53:13 <vincenz> Anyone have a suggestion for a function that reads ar efrence?
23:53:18 * vincenz is working on a ML-like compiler
23:53:24 <vincenz> atm it's
23:53:28 <vincenz> !x
23:53:36 <vincenz> but that creates a special case in the syntax
23:53:41 <vincenz> which is bothering me ... 
23:54:05 <vincenz> (plus it means I have to make a special AST-leaf for it nistead of just putting it in the prelude, due to the special syntax)
23:54:45 <vincenz> rr x ?   ref x?    read x?
23:55:13 <wilx> ref.val?
23:56:32 <dons> readRef x -- does it need special syntax?
23:57:15 <Cale> heh, name it something obscure, like scrutinize
23:57:32 <dons> heh
23:57:54 <Cale> or contemplate
23:58:20 <vincenz> dons readRef is too logn
23:58:26 <dons> kiss or bless or something bizarre like that
23:58:27 <vincenz> dons: especially due to its' high usage
23:58:30 <vincenz> I'll go for rr
23:58:41 <Cale> I'd probably use  'read'
23:58:54 <vincenz> nah
23:58:59 <vincenz> it's not a public domain language
23:59:07 <dons> *x ?
23:59:22 <dons> just to be old skool
