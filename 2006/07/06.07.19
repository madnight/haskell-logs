00:00:58 <edwardk> but i don't capture the magical case where someone decides to be a smart ass and alias the eval 'function'. gah it should be a keyword =/
00:01:45 <Korollary> heh'
00:02:33 <edwardk> with() is almost as bad =/
00:03:00 <edwardk> coz i can't even constrain the type of the parenthesized argument.
00:03:28 <edwardk> i might infer it from context, but thats limited
00:05:44 <lisppaste2> wethaskellnewb annotated #22837 with "New Problem: Program error: argument out of range" at http://paste.lisp.org/display/22837#1
00:07:21 <wethaskellnewb> thanks for your help Korollary. Made a bit of progress by adding type declarations to the log methods, but now I get an even less comprehensible error message
00:07:53 <edwardk> not in scope f2 =)
00:08:36 <edwardk> seems pretty straightforward to me =)
00:09:10 <wethaskellnewb> oops, forgot to paste f2
00:09:34 <lisppaste2> wethaskellnewb annotated #22837 with "Forgot to paste f2" at http://paste.lisp.org/display/22837#2
00:10:26 <edwardk> what is the error?
00:11:08 <sethk> you are giving it a character, "(".  It wants a number.
00:11:08 <wethaskellnewb> (
00:11:18 <wethaskellnewb> Program error: argument out of range
00:11:34 <sethk> it's using the ( as a number so it isn't doing what you think
00:11:43 <edwardk> when you call what function, that h2 1 mentioned?
00:11:52 <wethaskellnewb> edwardk: yes
00:11:59 <edwardk> *Main> h2 1
00:11:59 <edwardk> (1,2)
00:12:00 <edwardk> =)
00:12:09 <wethaskellnewb> hugs or ghci?
00:12:12 <edwardk> ghci
00:12:23 <wethaskellnewb> hmm, i'll try that, i was in hugs
00:12:51 <edwardk> ok, yeah hugs blows up
00:13:02 <wethaskellnewb> damn, works like a charm in ghci
00:13:13 <wethaskellnewb> Is hugs no good?
00:13:32 <wethaskellnewb> I use it because it allows me to :e in order to edit the module and immediately get back to a REPL
00:13:44 <wethaskellnewb> Is there a way to do that from within gchi too?
00:13:53 <edwardk> you might be rounding something out of range for log?
00:14:02 <edwardk> :load <module> and another window ;)
00:14:06 <sethk> wethaskellnewb, I think ghci can handle that, yes
00:14:22 <sethk> wethaskellnewb, generally, though, hugs is good
00:14:32 <wethaskellnewb> except for when it blows up ;-)
00:14:44 <sethk> wethaskellnewb, well, nothing's perfect
00:15:03 <wethaskellnewb> yeah, i know, but that's one of the sorriest error messages I've ever seen
00:15:28 <edwardk> well
00:15:32 <edwardk> try log (-1)
00:15:35 <edwardk> you get the same error
00:15:48 <dons> > log (-1)
00:15:49 <lambdabot>  -Infinity
00:15:54 <edwardk> so thats likely your culprit
00:15:56 <edwardk> (in hugs)
00:16:06 <wethaskellnewb> yeah, that seems like it's it
00:16:08 <dons> quite so,
00:16:08 <dons> Program error: argument out of range
00:16:47 <edwardk> whoever wrote the definition for hugs probably just used the real analysis definition
00:16:54 <wethaskellnewb> I guess the confusing part was that it was ( out of range, as if I gave it a '(' character as somebody suggested...
00:17:00 <wethaskellnewb> thanks a lot all
00:17:06 <edwardk> not a problem
00:17:43 <wethaskellnewb> I'll get in the habit of trying in both ghci before bugging you all...
00:17:49 <wethaskellnewb> both ghci and hugs...
00:17:51 <wethaskellnewb> i mean
00:17:52 <edwardk> heh
00:18:08 <edwardk> don't worry about it, was worth learning about the bug =)
00:18:17 <edwardk> or lack of specification as the case may be
00:20:19 <edwardk> hrmm
00:20:22 <edwardk> ghci gets
00:20:23 <edwardk> Prelude> log (-1)
00:20:23 <edwardk> NaN
00:20:59 <dons> isn't that interesting!
00:21:09 <dons> > log (-1)
00:21:10 <lambdabot>  -Infinity
00:21:11 <dons> > log (-0)
00:21:12 <lambdabot>  -Infinity
00:21:15 <dons> > log (0)
00:21:16 <lambdabot>  -Infinity
00:21:20 <dons> > log 1
00:21:21 <lambdabot>  0.0
00:21:31 <dons> ?type log
00:21:32 <lambdabot> forall a. (Floating a) => a -> a
00:21:47 <dons> floating point is for the birds
00:21:47 <edwardk> and i get that answer in both 6.5 and 6.4.2
00:21:48 <wethaskellnewb> yeah, problem was I was starting off my function with initial values of 0, then taking a log of that arg because i wasn't thinking about the initial value, only the values I was expecting later. works in hugs after changing that...
00:25:00 <edwardk> well, its not a floating point  problem, its a specification problem
00:25:16 <edwardk> it can't give an answer for numbers <=0 with that signature.
00:25:18 <lisppaste2> wethaskellnewb annotated #22837 with "Fixed version" at http://paste.lisp.org/display/22837#3
00:26:32 <edwardk> it needs a complex result, to handle all real inputs but even then because the function is holomorphic everywhere except non-positive reals you still have holes.
00:27:28 <lisppaste2> wethaskellnewb annotated #22837 with "Reformatted" at http://paste.lisp.org/display/22837#4
00:29:34 <edwardk> even then though, we have Euler's identity so it should have give -(i pi)
00:29:40 <edwardk> or whatever the haskell equivalent is
00:29:53 <edwardk> what does haskell do for complex numbers?
00:30:00 <edwardk> or does it have that in the number hierarchy at all?
00:30:23 <dons> ?hoogle Complex
00:30:23 <lambdabot> Complex :: module
00:30:24 <lambdabot> Data.Complex :: module
00:30:24 <lambdabot> Data.Complex.Complex :: data Complex a
00:30:40 <dons> ?hoogle+
00:31:24 <dons> > 1 :+ 8 :: Complex Int
00:31:25 <lambdabot>  add an instance declaration for (RealFloat Int)
00:31:26 <edwardk> dons: do you know if anyone hs bothered to profile different radices for type level arithmetic?
00:31:28 <dons> > 1 :+ 8 :: Complex Float
00:31:30 <lambdabot>  1.0 :+ 8.0
00:31:50 <dons> edwardk: i'm not sure if there's much ork on profiling type level arithmetic, in general.
00:32:02 <edwardk> fair enough
00:32:32 <dons> there's some comments in an article by Oleg K. about using his rsa on the type level as a type checker benchmark, iirc.
00:33:02 <edwardk> just have a base 2 implementation i was playing with and was debating about trying a base 10 or base 16 but was worried abut if its dictionary depth or breadth that would squash performance worse
00:33:43 <edwardk> i figure there has to be a sweet spot, just curious where it is
00:33:58 <edwardk> too wide and the adders and multipliers have a ton of cases
00:34:04 <edwardk> too narrow and you nest too many types
00:34:18 <edwardk> hence why i was curious if anyone had bothered =)
00:34:51 <edwardk> i'll look up oleg's rsa thing though
00:35:18 <dons> it's linked on the type arithmetic page of the haskell wiki
00:35:19 <edwardk> oh heh, there was a passing joke about it
00:35:24 <dons> ?gwiki Type_arithmetic
00:35:27 <lambdabot> http://www.haskell.org/haskellwiki/Type_arithmetic
00:35:27 <lambdabot> Title: Type arithmetic - HaskellWiki
00:37:42 <edwardk> wow, i like oleg's post. slick way to handle the division case
00:38:53 <dons> some know him as Mr. TypeHack
00:38:59 <edwardk> heh
00:39:18 <edwardk> reminds me a lot of the various boost libraries for c++ at times
00:40:10 <edwardk> i slapped together some type level booleans and type orderings based on the ones in HList, coz i needed them to reason about javascript types
00:40:22 <edwardk> so i've tripped over him a couple times.
00:40:54 <edwardk> that and his decimal type article was pretty good
00:50:26 <edwardk> i'm going to play with his inverse and see if i can't make a better version for monotonic functions like div
00:50:45 <edwardk> should give a few orders of magnitude improvement
00:51:25 <edwardk_> rmm, did what i said go through before i lost connectivity?
01:01:03 <dons> hey, tony was here?
01:01:31 <dons> i've projected the results of #haskell activity forward into the end of the year, http://www.cse.unsw.edu.au/~dons/irc/
01:01:32 <lambdabot> Title: Haskell IRC Activity
01:10:35 <ejt> hi, does anyone here use haskell on a MacIntel ?
01:11:37 <Igloo> dons: Do we get a bonus if we meet our targets?
01:11:46 <dons> yes!
01:12:00 <dons> i'll reinstate the @moo plugin ;)
01:12:29 * Igloo stops talking  :-þ
01:12:56 <dons> :P
01:15:23 <pejo> ejt, sort of?
01:15:59 <ejt> pejo: I found a precompiled build of 6.5, after some fiddling with readline libraries I got ghci to work
01:16:24 <ejt> but ghc -O barfs due to a rogue gcc option
01:16:32 <dons> ejt, try -fasm
01:16:39 <dons> i.e -O -fasm
01:17:56 <shapr> Wassup?
01:18:01 <shapr> Good morning #haskell !
01:18:17 <ejt> dons: thx, I'll try ...
01:18:39 <shapr> Dang, ndm is sleeping. Just when I have the urge to try YHC on my 770.
01:20:32 <ejt> dons: that worked, thankyou
01:32:28 * shapr boings
01:37:55 <dons> shapr: some more graphs, http://www.cse.unsw.edu.au/~dons/irc/
01:37:56 <lambdabot> Title: Haskell IRC Activity
01:39:30 <shapr> dons: ouchie for Clean - http://it.slashdot.org/comments.pl?sid=191465&cid=15736403
01:39:32 <lambdabot> Title: High-level Languages and Speed
01:41:08 <shapr> It's funny that a good score on the Shootout has suddenly made Haskell visible to Slashdotters too.
01:45:49 <shapr> dons: Why the downturn?
01:46:08 * shapr thinks
01:47:06 <edwardk_> shapr isn't dragging the numbers up enough i guess ;)
01:48:23 <dons> shapr: it hasn't finished this year yet....
01:48:36 <dons> hence the projected 'x' for what i think we'll get
01:48:47 <edwardk_> ah
01:50:19 <dons> ouch for Clean.
01:57:00 <shapr> hiya Lemmih
01:57:30 <shapr> dons: Oh, so it's filling in zeros for the rest of the year we haven't produced?
01:58:06 <dons> yeah, see the 'X' in the graph roughly where the line should be. that's a bit of haskell projecting how much noise we'll make in the next 6 months
01:58:09 <norpan> i will keep silent just to ruin the prediction
01:58:11 <norpan> doh!
02:06:57 <shapr> There's an amazing lack of clue in this Slashdot article. I really shouldn't read PLT Slashdot articles.
02:07:11 <vincenz> PLT?
02:07:21 <shapr> programming language theory
02:07:28 <vincenz> oh, heh
02:07:34 <vincenz> yeah slashdot is not exactly the place for that
02:07:47 <shapr> Stuff like "Lisp is only interpreted" and "As for higher-level-than-C languages being faster than C, it is purely a myth."
02:07:56 <shapr> It goes on like that forever.
02:08:15 <norpan> the slashdot crowd is just that, a crowd
02:08:43 <vincenz> I think the slashdot crowd is mainstream IT
02:08:53 <vincenz> and mainstream IT tends to have a lot of myths about "alternative" languages
02:10:37 <shapr> This one is my favorite so far - http://it.slashdot.org/comments.pl?sid=191465&cid=15736479
02:10:39 <lambdabot> Title: High-level Languages and Speed
02:12:06 <pejo> vincenz, I wouldn't be surprised if large parts of slashdot aren't "mainstream IT".
02:12:24 <vincenz> pejo: why not?
02:12:39 <vincenz> and more concretely, who then?
02:12:59 <pejo> vincenz, some are too young, and as soon as any thread on grad school is on slashdot it instantly pops out quite a few phds.
02:13:04 <pejo> In other subjects than CS.
02:13:53 <edwardk_> dons: any idea about:
02:13:53 <edwardk_> Building plugins-1.0...
02:13:53 <edwardk_> [18 of 24] Compiling AltData.Typeable ( src/AltData/Typeable.hs, dist/build/AltData/Typeable.o )
02:13:56 <vincenz> hmm
02:14:00 <pejo> (I'm not saying they're plt researchers either, just that the crowd seems to vary quite a lot).
02:14:05 * vincenz nods
02:14:25 <norpan> i object to the idea of a computer language being "fast"
02:14:43 <edwardk_> norpan: ?
02:14:53 <norpan> a specific implementation of an algorithm written in a specific language compiled by a specific compiler could be fast
02:14:58 <vincenz> boegel: pinig
02:14:59 <shapr> yup
02:15:10 <edwardk_> fair enough
02:15:37 <edwardk_> but there are some languages that are designed to enable more aggressive optimization than others. so the characterization isn't entirely unfair
02:15:47 <norpan> but change the first or the third it could be dreadfully slow instead
02:15:50 <shapr> I think the future is optimal solutions.
02:15:58 <norpan> yet you say that the second component is what makes it fast
02:16:16 <norpan> well, not you personally
02:16:19 <edwardk_> there are plenty of languages that make it hard to make something fast. a 'fast' language is necessary but not sufficient for speed in some cases.
02:16:41 <edwardk_> so it mostly turns on the matter of sufficiency
02:16:41 <norpan> an intelligent enough compiler could make any language "fast"
02:16:52 <shapr> Look at this - http://lambda-the-ultimate.org/node/652
02:16:55 <lambdabot> Title: Relating FFTW and Split-Radix | Lambda the Ultimate
02:17:03 <psnl> norpan: where is that coming from?
02:17:03 <vincenz> norpan: I disagree
02:17:10 <shapr> Oleg uses the principles behind the algorithm to generate optimal FFT code from Scheme.
02:17:11 <vincenz> norpan: In fact I'm quite certain tha tis wrong
02:17:16 <norpan> any reasonable language
02:17:16 <psnl> I mean, is that a known result or a belif?
02:17:24 <shapr> Is what a known result?
02:17:25 <vincenz> norpan: C, for instance, is so lowlevel and convoluted that it is impossible to obtain high optimizations
02:17:34 <norpan> it'd have to be pretty darn intelligent to make c fast though :)
02:17:34 <vincenz> norpan: You need higherlevel information to enable stronger optimizations
02:18:11 <vincenz> for instance there are a lot of optimizations that aare library-usage specific
02:18:18 <vincenz> sadly c does not use such higher level libraries
02:18:22 <norpan> of course the case with c is that the programmer could make those optimizations
02:18:27 <psnl> ok, I just had to look up the spelling of "belief"
02:18:29 <vincenz> norpan: not really
02:18:50 <vincenz> norpan: I'm talking optimizations about register usage that are a) more global b) get you a lot more gains
02:18:54 <vincenz> above
02:18:55 <vincenz> not about
02:19:07 <edwardk_> has anyone else run into build problems trying to ompile hs-plugins-1.0?
02:19:37 <norpan> vincenz: yes, the programmer could rewrite his program to make those optimizations, not practical, but possible
02:19:39 <edwardk_> er the rc0
02:19:57 <vincenz> norpan: if you want to spend 1-2 years.... and risk a shit load of bugs, sure
02:20:08 <vincenz> norpan: but with an infinite budget anything is possible
02:20:11 <vincenz> is it realistic? hell no
02:20:24 <shapr> Wait, what's the subject again?
02:20:30 <norpan> random ranting
02:20:36 <vincenz> shapr: compilers for languages
02:20:52 <shapr> I still think optimal generation is the way of the near future.
02:20:58 <pejo> norpan, that statement about intelligent compilers - if we only knew how to solve the halting problem we could make awfully good c compilers.
02:21:05 <norpan> what is optimal generation
02:21:14 <shapr> In which case choice of language would be personal preference.
02:21:27 <norpan> pejo: please, don't mention the halting problem
02:21:33 <shapr> Like Oleg's paper where he generated an optimal FFT by knowing the axioms that underly the problem.
02:21:39 * shapr halts!
02:21:49 <vincenz> shapr: that's only feasible for specific libraries, not for generic programming
02:21:56 <shapr> How do you know that?
02:21:57 <vincenz> or all programming problems would've been solved already
02:22:04 <vincenz> cause every problem is different?
02:22:14 <shapr> That's not much of a proof :-)
02:22:28 <vincenz> nor is yours?
02:22:42 <shapr> Hey, at least I have one instance of an optimal solution :-)
02:22:54 <vincenz> well why don't we make infinitely fast computers
02:22:57 <vincenz> that's another instance
02:23:08 <shapr> C'mon, that's not the same thing at all.
02:23:13 <pejo> vincenz, when you say "more global register usage" - do you mean interprocedural register allocation?
02:23:42 <vincenz> pejo: no, loop transformations, data reusage, variable removal, task-scheduling, data-layout
02:23:45 <shapr> Optimal solutions means generated the best possible binary to solve a certain problem. (modulo some minor stuff)
02:24:00 <vincenz> pejo: I didn't mean more, I meant above
02:24:01 <shapr> Anyway, it's taxtime now...
02:24:04 <vincenz> aka more abstract, higherlevle
02:24:07 <norpan> simple, just enumerate binaries and benchmark
02:24:09 <vincenz> sorry for misunderstanding
02:24:09 <edwardk_> @tell dons had trouble building hs-plugins off the ghc head. blows up on AltData.Typeable on both your 0.9.10 and 1.0-rc0. 6.4.2 worked fine.
02:24:10 <lambdabot> Consider it noted.
02:24:26 <norpan> no need to solve no halting problem
02:25:05 <xerox> edwardk_ - You should add Typeable.h in AltData/
02:25:19 <vincenz> anyone here familiar with the dATE conference?
02:25:24 <vincenz> I can't find their template
02:25:26 <xerox> Good morning, by the way.
02:25:36 <edwardk_> xerox: ?
02:25:49 <shapr> Anyone know if GnuCash handles Swedish taxes? :-)
02:25:51 <xerox> edwardk_: what's the error of your compilation blowup?
02:26:20 <edwardk_> lost track of it, building it with 6.4.2 right now
02:26:51 <edwardk_> it was griping about indentation
02:27:08 <xerox> edwardk_ - In order to build hs-plugins head with GHC 6.5 you should take GHC 6.4's Typeable.h and copy it to the Typeable.hs directory
02:27:32 <edwardk_> will try that
02:35:23 <mlh> shapr: taxes .se probably exceed maxint, so no.
02:35:39 <edwardk_> gotta get some sleep
02:35:41 <edwardk_> later folks
02:37:48 <norpan> shapr: the swedish tax authorities do everything for you
02:37:52 <norpan> they are so nice
02:38:02 <norpan> in our big brother society
03:37:44 <shapr> norpan: Yeah, but I still need to file my skattedeklaration.
03:58:07 <foxy_> @hoogle replicateM
03:58:07 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
03:58:08 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
04:02:54 <foxy_> I have 24bit data with LSB on the left, how can I convert that to a Word32?
04:16:25 <norpan> shapr: well you do, but don't you have a förenklad självdeklaration?
04:16:50 <norpan> foxy_: on the "left"?
04:17:23 <foxy_> norpan: [LSB,...,MSB]
04:17:52 <norpan> interesting
04:21:17 <lisppaste2> erider pasted "help" at http://paste.lisp.org/display/22846
04:28:11 <norpan> erider: you don't need to use "head", the pattern matching of x:xs takes care of putting the first element of the list in x, and the rest in xs
04:29:24 <erider> the book I'm reading hasn't example the properties of x:xs yet
04:29:41 <erider> could you explain them to me please
04:29:50 <norpan> look at the first example
04:30:04 <erider> *explain
04:30:06 <norpan> here you define my_filter p (x:xs)
04:30:07 <erider> oops
04:30:38 <norpan> this means that the first element of the list given as argument will be put in x, and the rest of the list in xs
04:30:50 <norpan> then you recursively call the function for xs (the rest of the list)
04:30:55 <norpan> and put everything together
04:31:05 <norpan> the same should be done for mymap
04:35:22 <erider> norpan, what I use an if then else clause there?
04:35:37 <erider> s/what/would
04:36:41 <norpan> no, you need to think recursively
04:37:17 <norpan> the first thing you should do is to make sure you understand the my_filter definition
04:37:37 <vincenz> dcoutts: excited about friday?
04:37:56 <erider> which I don't completely :(
04:38:08 <shapr> norpan: I have a one page thing to file, but I've always done it with a bookkeeper before.
04:39:08 <norpan> erider: then you should concentrate on understanding that
04:39:33 <erider> will do
04:40:15 <norpan> do you understand the general concept of recursion?
04:41:04 <erider> I understand the you have a condition case and a recursive case
04:41:19 <erider> s/the/that
04:41:44 <norpan> in the case of my_filter, the call "myfilter p xs" is the recursive call
04:41:58 <norpan> that one will give you xs filtered
04:42:22 <norpan> then you need to create x:xs filtered, and you do that by checking if x should be in there or not, and doing two different things
04:52:41 <erider> norpan, is there step feature in ghci that I could use to watch the program run step by step?
04:53:05 <norpan> erider: not really
04:53:12 <norpan> it would be nice to have though
04:53:24 <norpan> maybe there is something, i don't know
04:53:29 <mwc> it would be too verbose
04:53:38 <mwc> what I'd like to see is backtracking step by step
04:53:58 <norpan> well, for a very small example it would not be too verbose
04:54:03 <mwc> Okay, this value is wrong, how did you get it? It would pop up the computation, and I could select a value, and see how that was computed, etc.
04:54:41 <mwc> that looks like an idea for me to play around with actually
04:55:34 <erider> in lisp I can watch a recursion program run thru step by step to understand what is going on. I think that would help my understanding of what is taking place.
04:56:09 <norpan> one problem with doing that for haskell is lazy evaluation
04:56:09 <mwc> say I applied, at the prompt, foo 42. There should be a way to switch to the right hand side of that definition, and see what's going on there. Then select any given term there and switch to its right hand side.
04:56:13 <mwc> I like that idea
04:57:06 <norpan> but it would be neat to have some tool that would show the current closure and let you expand it step by step
05:00:52 <dozer> that would be great, particularly if you could run your app in it and when it fails with stuff like non-exhaustive cases, it displays the context
05:01:46 <dozer> For my Java code, I rely heavily on exceptions and nested exceptions to trace what caused a program to fail but I find that when a haskell program fails I am usually in the dark about what went wrong and why
05:04:17 <erider> norpan,  is there anyway I could did it on paper or something use a substitution model for the argumets being given
05:06:05 <norpan> erider: yes
05:06:08 <vincenz> any phd students here?
05:06:15 <norpan> just replace the left hand side with the right hand side
05:07:14 <norpan> and bind the first element of the list to x, and the rest of the list to xs
05:07:35 <norpan> remember, the list [1,2,3,4] is really 1:(2:(3:(4:[]))))
05:07:49 <vincenz> norpan: that's a lot of sad smileys (I'm in GAIM)
05:07:55 <norpan> hehe
05:07:58 <vincenz> How do people here write code in their latex papers?
05:08:05 <vincenz> listings?
05:08:09 <norpan> i only use latex for sex
05:08:32 <norpan> occasionally i've used the listings package, though
05:08:48 <vincenz> what I hate about listings is how it just makes the text run past the end of the line
05:08:52 <vincenz> straight into the margin or right column
05:09:01 <vincenz> not to mention the wide font spacing
05:11:39 <norpan> listings can be configured
05:16:10 <boegel> norpan: we should meet :P
05:17:01 <madpickle> listings work, but there's a special package you can get specifically for code; it'll even do proper syntax highlighting
05:17:20 <vincenz> madpickle: oh?
05:17:25 <vincenz> donde?
05:17:25 <madpickle> just tell emacs to break up lines
05:17:32 <madpickle> one sec
05:18:32 <vincenz> btw, norpan
05:18:34 <vincenz> > 1:2:3:4:[]
05:18:35 <lambdabot>  [1,2,3,4]
05:19:01 <norpan> vincenz: yes?
05:19:08 <vincenz> no need for ()
05:19:13 <norpan> i know
05:19:19 <norpan> but i put it there for clarity
05:19:25 <vincenz> okkies
05:19:41 <madpickle> bleh - i can't find it. needless to say, it was fairly easy to use
05:19:45 <madpickle> if only i could remember the name
05:19:52 <madpickle> you can probably find it on a latex package site
05:19:57 <madpickle> alternatively, use a custom float:
05:19:58 <madpickle> http://www.andy-roberts.net/misc/latex/latextutorial6.html
05:20:03 <madpickle> scroll to the bottom
05:20:16 <vincenz> madpickle: thx
05:20:16 * roconnor wonders if I ought to use where clauses instead of @'s in pattern matching.
05:20:44 <vincenz> madpickle: typically I just stick listings into figures cause otherwise they risk getting cut
05:21:07 <madpickle> right. you gotta format your code carefully
05:21:34 <madpickle> thing is tho, IMO, big code listings have no place in a dissertation anyway -- appendices, sure, but main body? nah. Small code is fine
05:21:41 <madpickle> at least, that's what i was told
05:21:47 <madpickle> i suppose house style varies from place to place.
05:22:32 <vincenz> floats seem better than figures
05:22:37 <ndm> i am trying to do ghci and cpp stuff
05:22:39 * vincenz tackles Itkovian
05:22:42 <madpickle> yep. they are very flexible
05:22:54 <vincenz> madpickle: it's just annoying to say \ref{figurexxx} is code
05:22:57 <madpickle> you may have a problem with the "one float per page" rule LaTeX has
05:23:00 <ndm> i want to include a file Blah.hs from Main.hs, and I want to pass a preprocessor definition to Blah.hs
05:23:02 <vincenz> o.O
05:23:06 <vincenz> only one???
05:23:06 <Itkovian> vincenz: I've forwarded your mail to koen, but I've received no response yet
05:23:11 <madpickle> well, you can change it :)
05:23:12 <vincenz> Itkovian: alright perfect
05:23:14 <madpickle> use something like:
05:23:16 <ailndx> hmm whats .ps.gz is that some packed file?
05:23:21 <ndm> ghci Main.hs -cpp -DMacro only applies -DMacro to Main.hs
05:23:40 <vincenz> ndm: precompile the other .hs?
05:23:43 <Itkovian> vincenz: in any case, I'm back after the first week of August
05:23:56 <vincenz> Itkovian: ok.... I'll be gone from 14-28 aug
05:23:57 <pejo> ailndx, gzipped postscript, atleast gv can view it as it is.
05:24:01 <vincenz> +/-
05:24:04 <ndm> vincenz: yeah, i guess, would rather not, but hey
05:24:15 <ailndx> pejo: but i am in win
05:24:26 <ailndx> http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz wanna look at this
05:24:37 <vincenz> ailndx: get ghostview
05:24:57 <vincenz> alternatively, find ps2pdf
05:24:58 <vincenz> gunzip
05:24:59 <Itkovian> vincenz: anyway, I (partially) rewrote my tool in ocaml - dropping it to 13 sec for a full trace of one thread
05:25:10 <vincenz> Itkovian: coming from?
05:25:11 <madpickle> well, i couldn't find where he(the author above) mentioned it, but if you use the parameter "!h" (which means: ignore latex' ruleset and place it *here*)
05:25:22 <vincenz> madpickle: ah rightio :)
05:25:25 <vincenz> madpickle: thx for the info
05:25:28 <Itkovian> pfft, above a few hundred minutes
05:25:29 <vincenz> madpickle: definitely better than figures
05:25:33 <pejo> ailndx, can't winzip unpack gzipped files?
05:25:35 <vincenz> Itkovian: nice gain :)
05:25:39 <madpickle> np -- and yeah, vincenz.
05:25:48 <Itkovian> Lemmih helped me out speeding it up about 6 times, but it still is way too slow
05:25:50 <madpickle> good thing about LaTeX is code reusability
05:25:52 <vincenz> Itkovian: in fact... in the end for our tool I went for a binary packet format to save on filesize..
05:25:58 <madpickle> so once you get some nice floats set up, it's easy to port em from paper to paper
05:25:58 <Itkovian> vincenz: drawback: I suck at ocaml
05:26:07 <ailndx> pejo the strange thing is when i save it to harddrive its saved as .ps.ps
05:26:21 <Itkovian> @seen boegel
05:26:22 <lambdabot> boegel is in #haskell-blah and #haskell. I last heard boegel speak 10 minutes and 12 seconds ago.
05:26:23 <vincenz> madpickle: well right now I just do \begin{figure}\begin{listings}\caption...
05:26:26 <pejo> ailndx, oh. Might be your browser doing funky stuff with it.
05:26:41 <u221e> I'm STILL stuck on monads :(
05:26:46 <madpickle> you oculd do that, but floats will have its own naming scheme
05:26:54 <vincenz> madpickle: yeah that's what I like better
05:26:55 <madpickle> so if you name your float "Code", it will do "Code 1", "Code 2", ....
05:26:59 <Itkovian> u221e: so am i
05:26:59 <ptolomy> > (,,) 4 5 6
05:27:01 <lambdabot>  (4,5,6)
05:27:03 <ailndx> pejo: could you try to unpack and send it to me?
05:27:04 <vincenz> madpickle: can you make em captionless?
05:27:17 <madpickle> yeah, sure - you're gonna have to play around with that.
05:27:42 <madpickle> http://www.ctan.org/tex-archive/info/lshort/english/lshort.pdf
05:27:52 <madpickle> that one is probably the best guide to LaTeX ever.
05:28:07 <madpickle> http://www.physics.udel.edu/~dubois/lshort2e/lshort2e.html
05:28:09 <lambdabot> Title: The Not-So-Short Guide to LaTeX
05:28:15 <madpickle> that's the html version (try not to use it, formatting is weird)
05:29:20 <vincenz> :)
05:30:02 <pejo> u221e, you asked about bugs in gcc's optimization the other day - they've done quite a lot in the 4.x series, mainly putting in SSA and a bunch of optimizations on that.
05:31:02 <Itkovian> ttyl
05:33:11 <vincenz> madpickle: what
05:33:18 <madpickle> hum?
05:33:20 <vincenz> what's the {ext} parameter
05:33:30 <u221e> pejo, Thanks but I don't even know if that was the real reson it ran so slow on the P4 or not.
05:33:30 <vincenz> in the example I got from the page before {lop}
05:34:01 <madpickle> just the filename extension
05:34:03 <madpickle> IIRC
05:34:08 <vincenz> ah alright
05:34:12 <pejo> u221e, does it work well with the same version of the compiler on a p3 or slower?
05:34:14 <madpickle> it's where the captions are stored, apparently.
05:34:56 <madpickle> also
05:35:01 <madpickle> if you do \floatstyle{plain}
05:35:10 <madpickle> it shouldn't draw any captions or bars -- just a completely invisible 'float'
05:35:13 <madpickle> ``plain - the normal style for Latex floats, i.e., nothing!''
05:35:44 <u221e> pejo, I don't know. The benchmarks were not done by me and I don't have access to the a Pentium 4 like the shootout uses
05:36:39 <PsiXi> hey, any other haskellers stuck without a partner for icfp? surprisingly, even here at MIT it is hard to find people who know haskell
05:37:27 <pejo> u221e, do you get different results with the same version of gcc on your machine?
05:37:58 <u221e> PsiXi, Do you know what information archeolinguistics is?
05:38:47 <PsiXi> u221e, it's pretty much made up, but my assumption is hieroglyphics
05:38:54 <u221e> pejo, no. I've tried 4.0.1 and 3.3.6 and they both run the same.
05:39:19 <PsiXi> u221e: there's not many hits for archaeolinguistics on google that aren't jokes or ICFP-related
05:39:50 <u221e> But then I have an old Athlon 1.4 GHZ Thunderbird, not a pentium 4...
05:40:18 <u221e> It probably isn't even the compiler that's the problem.
05:41:44 <pejo> u221e, sounds pretty impossible to "debug" that problem without access to a similar machine then.
05:42:07 <u221e> PsiXi, I would help but I'm still stuck on monads ;)
05:42:59 <u221e> pejo, Yea... I think it may be the conditional branches though.
05:43:41 <PsiXi> anyone else who needs an extra person for ICFP, then?
05:46:35 <ailndx> PsiXi: MIT.. what are you studying?
05:48:16 <PsiXi> ailndx: i'm a grad student at http://cba.mit.edu, which is a quite interdisciplinary program but I'm doing mostly programming and EE
05:48:17 <lambdabot> Title: The Center for Bits and Atoms
05:48:47 <ailndx> EE?
05:48:54 <PsiXi> ailindx: electrical engineering
05:48:57 <ailndx> okay
05:50:14 <vincenz> anyone know a place I can upload a file for showing?
05:50:16 <vincenz> pdf
05:50:25 <dcoutts> vincenz, you mean ICFP?
05:50:44 <vincenz> dcoutts: is this in relation to my earlier question about excited or my current question?
05:51:01 <vincenz> now I was just hoping to show a pdf to someone (madpickle) cause listings is pissing me off
05:51:15 <dcoutts> vincenz, eariler Q
05:51:25 <vincenz> dcoutts: yeah
05:51:29 <vincenz> ICFPC more exactly
05:51:33 <dcoutts> not sure if we're doing it yet
05:51:37 <vincenz> oh :/
05:51:40 <PsiXi> starts on Friday
05:51:50 <PsiXi> btw http://upload2.net/
05:51:52 <lambdabot> Title: Upload2.net Free File Hosting, Free Image Hosting
05:51:56 <dcoutts> Igloo, so do we know about 002 at all? My room is a little crampt
05:52:09 <dcoutts> Igloo, but is usually inunhabited
05:52:20 <dcoutts> inunhabited/uninhabited
05:52:28 <vincenz> dcoutts: why not just do distributed/
05:52:37 <dcoutts> vincenz, it's not our style
05:52:42 <vincenz> dcoutts: we finally reduced to: Lemmih, Adept, jyp and myself
05:52:43 <dcoutts> not for ICFP
05:52:49 <vincenz> we're gonna use irc & skype
05:53:04 <dcoutts> vincenz, cool, best of luck! take home the trophy for Haskell!
05:53:06 <vincenz> dcoutts: who are you collaborating with?
05:53:09 <vincenz> dcoutts: will try :)
05:53:23 <PsiXi> vincenz: no chance of taking an extra person eh? ;D
05:53:23 <vincenz> dcoutts: but we want our main competitors to particpiate too!
05:53:26 <dcoutts> vincenz, Igloo and a couple other people in the comlab
05:53:34 <vincenz> dcoutts: but <= 4
05:53:38 <vincenz> ?
05:53:41 <dcoutts> yeah, 3 or 4
05:53:44 * vincenz nods
05:53:47 <PsiXi> ah, right.
05:53:59 <vincenz> PsiXi: well we initially had 12 people interested
05:54:07 <vincenz> I'm certain that a few could coallesce into a second group
05:54:08 <dcoutts> vincenz, so you've got a team of 4 then, good good
05:54:09 <vincenz> join #oasis
05:54:12 <vincenz> dcoutts: yeah
05:54:21 <vincenz> dcoutts: and I'm happy with the selection :)
05:54:32 <dcoutts> yeah you should be
05:55:14 <vincenz> jethr0 dissappeared for like several months, and dmhouse told me he couldn't participate as he'd be internetless
05:56:16 <norpan> those programming contests seem like fun
05:58:30 <vincenz> norpan: shapr and myself have considered having one for haskell community
05:58:37 <vincenz> like every 6 months or so
05:58:42 <vincenz> but shorter ones, 24 hours or so
05:58:49 <amiddelk> <vincenz> we're gonna use irc & skype
05:58:51 <PsiXi> vincenz: good idea
05:59:17 <vincenz> amiddelk: hmm, es?
05:59:18 <vincenz> yes?
05:59:23 <amiddelk> vincenz: i'm still typing ;)
05:59:37 <ptolomy> I think it'd be neat to have something akin to ruby/perl/probably python-quiz.. weekly bite-sized tasks.. It'd be really interesting to see the solutions that people bring to the same problem.
05:59:56 <PsiXi> probably python?
05:59:58 <vincenz> the main issue with organizing such a thing is the effort
06:00:02 <amiddelk> vincenz: if you are going to use group-conversations using skype, I recommend you to run teamspeak or ventrillo instead. They are slightly better suited when talking with multiple persons at the same time.
06:00:22 <vincenz> amiddelk: ah thank you for the suggestion :)
06:00:28 <vincenz> but there is no linux client for ventrilo afaict
06:00:31 <vincenz> madpickle: http://www.upload2.net/page/download/Bt5GYO1MHTwYj3z/plop.pdf.html
06:00:32 <lambdabot> Title: Upload2.net Free File Hosting, Free Image Hosting
06:00:36 <vincenz> madpickle: how do I get smaller/fixed font
06:00:51 <PsiXi> ptolomy: maybe you should suggest that in the #python channel instead :D
06:00:51 <vincenz> \basicstyle = \small
06:01:39 <vincenz> amiddelk: another issue with skype is the fact tha tI have to restart it after each call, it doesn't like sounds cards too much (1.2...) as for 1.3... I get wavering sound as if my comp is having issues running it, though top doesn't show problems
06:01:51 <vincenz> amiddelk: is there a linux server of teamspeak?
06:01:56 <amiddelk> vincenz: yes
06:02:00 <vincenz> o\/
06:02:30 <madpickle> page 113 of lshort.pdf should list different font sizes
06:02:34 <vincenz> amiddelk: is it intensive?
06:03:21 <amiddelk> vincenz: not with the little amount of people you are dealing with
06:04:06 <amiddelk> configuring the client to work properly on linux might be difficult as the version that I used still used the old sound system (not salsa)
06:05:18 <shapr> vincenz: google talk is better than skype!
06:05:29 <ptolomy> PsiXi: the 'python' was party of my languages-that-already-have-quiz-type-things slash clause.. I was unclear. I meant that a weekly haskell quiz would be lovely, particularly because haskell is quite TMTOWTDI-ey.
06:06:03 <PsiXi> ptolomy: ahh i get it now.  yeah that would be interesting
06:06:58 <shapr> What sort of quiz questions?
06:07:11 <ptolomy> shapr: check out ruby quiz for examples..
06:07:15 <ptolomy> ?google ruby quiz
06:07:17 <lambdabot> http://www.rubyquiz.com/
06:07:18 <lambdabot> Title: Ruby Quiz
06:10:48 <SamB_XP> a sound system called salsa?
06:11:10 <PsiXi> if it's not a typo, it's some kind of pun
06:11:16 <PsiXi> like super-alsa ... salsa!
06:12:10 <SamB_XP> super advanced linux sound architecture?
06:12:24 <PsiXi> exactly
06:12:26 <PsiXi> just a guess
06:12:37 <vincenz> madpickle: aha I found it.... my listings is just not reacting to \lstset{basicstyle=..}
06:12:44 <vincenz> PsiXi: no salsa....sounds like a sad party
06:13:05 <madpickle> ?google define:salsa
06:13:06 <lambdabot> No Result Found.
06:13:07 <Igloo> dcoutts: I delegated room-finding to the two of you in the comlab  :-)
06:13:11 <madpickle> aww, it can't do define
06:13:40 * vincenz grins at Igloo: competition!
06:13:44 <SamB_XP> ?google define:hello
06:13:45 <lambdabot> No Result Found.
06:13:52 <PsiXi> SamB_XP: http://tinyurl.com/ksno6
06:14:19 <sowhat> does anyone know the gnuplot wrapper from http://darcs.haskell.org/htam/src/GNUPlot.hs
06:14:22 <roconnor> @hoogle build
06:14:23 <lambdabot> GHC.Exts.build :: ((a -> b -> b) -> b -> b) -> [a]
06:14:24 <lambdabot> Distribution.Simple.Build.build :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()
06:14:24 <lambdabot> Data.Graph.Inductive.Internal.Heap.build :: Ord a => [(a, b)] -> Heap a b
06:14:36 <roconnor> @type GHC.Exts.build
06:14:37 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
06:14:42 <vincenz> madpickle: http://rafb.net/paste/results/VlJq8v92.html
06:15:21 <roconnor> I see, build takes a list destructor and builds a list from it.
06:15:52 <roconnor> I think
06:17:22 <norpan> it takes a foldr and applies : and [] to it
06:18:27 <roconnor> forall a b. (a->[a]->b) -> b -> [a] -> b
06:19:20 <roconnor> forall a b. (a->[a]->b) -> b -> b
06:29:34 <dcoutts> Igloo, right'o
06:44:18 <erider> norpan, I'm still not getting it :(
06:46:26 <norpan> my_filter?
06:51:14 <vincenz> dcoutts: so kosmikus is not on your team
06:51:14 <vincenz> ?/
06:51:15 <lambdabot> Maybe you meant: . v
06:51:35 <dcoutts> vincenz, sadly he can't make that weekend
06:51:43 <kosmikus> icfp contest?
06:51:50 <vincenz> kosmikus: yah
06:52:03 <kosmikus> no, other plans this weekend
06:52:03 <erider> norpan, yep I understand that it is creating a new list with cons but I don't understand how the function is being applied to each element in the list
06:52:38 <norpan> erider: that is where recursion comes in
06:52:52 <norpan> the recursive call is applying the function to each element in the rest of the list
06:53:23 <norpan> look at the recursive call as magically doing the right thing
07:02:13 <erider> norpan, ok the x is being added to the front of the new list. well if it is true it is being added
07:05:20 <norpan> yes, the new list constructed will start with x if p x is true
07:05:21 <dcoutts> shapr, looks nice: http://www.scannedinavian.com/hope/image/15
07:06:30 <shapr> Yeah, maemo-mapper is way nifty.
07:06:42 <shapr> I cache the maps locally and then I can find my way around stockholm without a 'net connect.
07:06:50 <dcoutts> cool
07:18:34 <Philippa_> nice - that's a feature that might just help sell me on a 770
07:19:42 <dmhouse> @seen kowey
07:19:43 <lambdabot> I saw kowey leaving #haskell and #darcs 7 days, 12 hours, 9 minutes and 10 seconds ago, and .
07:19:48 <dmhouse> Hmm. I wonder where he's got to.
07:24:59 <Dino_> Is there a way to get rid of the lambda abs in this:  readFile somepath >>= (\str -> return (notAnAction str))
07:25:39 <xerox> Sure.
07:26:42 <xerox> \path -> notAnAction `fmap` readFile path
07:26:56 <xerox> fmap notAnAction . readFile
07:27:19 <zarvok> ls
07:27:25 <zarvok> oops :)
07:27:30 <vincenz> ls -la
07:27:34 <xerox> Dino_: that is -^
07:27:36 <Dino_> Hm. Why fmap? Doesn't that map across some collection of somethings?
07:27:40 <vincenz> zarvok: cat task-description >> #haskell
07:27:42 <xerox> Oh.
07:27:44 <xerox> fmap = liftM
07:27:45 <zarvok> :)
07:27:48 <xerox> ?type liftM
07:27:49 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
07:27:53 <xerox> That's the same thing.
07:28:08 <dmhouse> (Ish.)
07:28:40 <dmhouse> (fmap is more general, applying to any Functor, whereas liftM is specific to Monads.)
07:29:05 <Dino_> I see. I was just reading about how the plain old map function is actually the implementation of Functor for the list monad.
07:29:11 <xerox> In Haskell very few things are Functors but not Monads.
07:29:25 <Dino_> Or maybe I should the implementation of fmap from Functor for the list monad.
07:29:47 <dmhouse> Err
07:29:50 <zarvok> vincenz: It will be at least 3-4 hours before we release anything, so I wouldn't sit around waiting
07:29:55 <dmhouse> map is the implementation of fmap for the list Functor.
07:29:55 <vincenz> :)
07:30:01 <xerox> Right. fmap is the associated operation with every Functor in Haskell. map is its implementation for the List type constrc.
07:30:08 <xerox> type.
07:31:53 <Dino_> Thank you. That was far more instructive than I thought it would be, given a small, simple original question.
07:32:34 <xerox> Write the Functor instance for the binary tree: data Tree a = Leaf a | Branch (Tree a) (Tree a)
07:32:38 <xerox> :-)
07:32:43 <vincenz> xerox: bad
07:33:08 <xerox> And then the catamorphism ;-)
07:33:09 <vincenz> data Tree a =Leaf | Branch (Tree a) a (Tree a)
07:33:16 <xerox> It's not "bad".
07:33:30 <vincenz> xerox: your version only puts data at bottom (fringes) so always have to go down.
07:33:34 <vincenz> secondly cant make an empty a tree
07:33:45 <xerox> I do know.
07:33:57 <xerox> Every tree has its purpose =)
07:34:02 <vincenz> only in forests
07:34:06 <vincenz> :)
07:34:09 <zarvok> :)
07:34:21 <psnl> everyone seems to be happy today
07:34:49 <dylan> I think that I shall never see / a graph more lovely than a tree ...
07:34:51 <Dino_> mapTree f (Leaf x) = Leaf (f x)
07:35:03 <vincenz> @paste
07:35:03 <lambdabot> http://paste.lisp.org/new/haskell
07:35:11 <vincenz> lots of trees and morphisms
07:35:14 <Dino_> mapTree f (Branch t1 t2) = Branch (mapTree f t1) (mapTree f t2)
07:35:17 <lisppaste2> vincenz pasted "Trees and morphisms" at http://paste.lisp.org/display/22856
07:35:23 <xerox> Dino_: right. You idiomatically write:
07:35:32 <vincenz> :D
07:35:32 <xerox> instance Functor Tree where fmap ...
07:35:37 <Dino_> Just went over this within the past 24 hours in the HSOE book.
07:35:43 <vincenz> check out that page :)
07:35:47 <vincenz> it's got lots of trees
07:36:00 <Dino_> vincenz: Thank you, I'll look at that.
07:36:29 <vincenz> even has a tree instance for []
07:36:30 <vincenz> :)
07:36:45 <vincenz> the great thing is that I can easily define bfs and dfs for any instance of Tree
07:36:55 <vincenz> bfs       = traverse (\a b -> a:concat b) []
07:37:00 <vincenz> dfs       = traverse (\a b -> concat b ++ [a]) []
07:37:10 <Dino_> xerox: Now what does that mean after you instance for this Tree? That you can use fmap on any Tree after that?
07:37:22 <Dino_> Instead of calling your own mapTree
07:37:24 <xerox> Dino_: yes, check out fmap's type
07:37:28 <xerox> ?type fmap
07:37:29 <vincenz> @type fmap
07:37:30 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
07:37:31 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
07:37:39 <xerox> It takes whatever Functor f is instantiated.
07:37:44 <Dino_> Ok, any Functor
07:37:52 <vincenz> xerox: should take a look at hte paste as well
07:37:54 <vincenz> it's funky :)
07:37:57 <dmhouse> Dino_: That's called _polymorphism_. The same name, 'fmap', can mean several different implementations, depending on the type of its argument.
07:37:59 <ndm> what function can i write that will make ghci take about 5 seconds to calculate?
07:37:59 <vincenz> dfs       = traverse (\a b -> concat b ++ [a]) []
07:38:03 <vincenz> whoops
07:38:05 <vincenz> (splitAt =<< (\l -> length l `div` 2))
07:38:11 <dmhouse> ndm: threadDelay 5000?
07:38:32 <jgrimes_> ndm: naive fibonacci
07:38:35 <vincenz> dmhouse: isn't it 5000000
07:38:43 <Dino_> dmhouse: I'm still having trouble seeing it sometimes even with a lot of OO experience. It seems like the polymorphism here is much bigger and more powerful. Or something.
07:38:46 <dmhouse> vincenz: O,h perhaps.
07:38:48 <ndm> dmhouse: that may well work :)
07:39:17 <SamB> Dino_: indeed
07:39:22 <dmhouse> Dino_: I'm reliably informed that polymorphism in an OO language and in Haskell mean slightly different things.
07:39:30 <Philippa_> yep
07:39:34 <Dino_> I will add that I never did much with C++ templates at all and gave up on Java prior to the emergence of their Generics.
07:39:46 <Philippa_> Dino_: you might find it helps to think of single parameter typeclasses as being like interfaces
07:39:54 <ndm> dmhouse: in my copy of GHCi that finishes instantly!!!
07:40:04 * dmhouse is going to write the killer polymorphism tutorial once he's finished his type theory book
07:40:14 <dmhouse> ndm: Try 5000000 as vincenz suggests.
07:40:24 <jgrimes_> dmhouse: which type theory book are you reading/working through?
07:40:40 <dmhouse> jgrimes_: Types and Programming Languages, Benjamin C Peirce.
07:40:51 <dmhouse> *Pierce. I always misspell his name.
07:40:59 <jgrimes_> dmhouse: How is it? I've heard good things and have considered working through it myself.
07:41:17 <dmhouse> jgrimes_: Excellent, so far. A good amount of exercises, nearly all with detailed solutions.
07:42:03 <kosmikus> it's a really good book
07:42:19 <Philippa_> dmhouse: JOOI, do you misspell it when talking about piercings etc as well?
07:42:20 <jgrimes_> dmhouse: Great. I started working through Essentials of Programming Languages first, since Types and Programming Languages recommended it as prior reading.
07:42:43 <jgrimes_> And since I am somewhat unfamiliar with the territory.
07:42:50 <Philippa_> I read it without EoPL, worked for me (though I've gone easy on the proofs and the like so far)
07:42:52 <Dino_> Philippa_: Why only single parameter type classes? But yes, I did notice that they seem a lot like the idea of interfaces, with the must have certain functions implemented.
07:42:58 <dmhouse> Philippa_: not really.
07:43:51 <Philippa_> Dino_: multiparameter classes are a bit more complicated, it becomes more useful to think of instances as meaning "these functions are defined for this tuple of types" rather than the types supporting an interface
07:44:00 <xerox> dmhouse: refold = ((flip (.) unfold . (.) . (.) . (.)) .) . fold -- points-free hylomorphism
07:44:12 <xerox> dmhouse: the reduction (manual, of course) is on the usual page :D
07:44:18 <dons> xerox: we have @hylo for that
07:44:18 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
07:44:23 <dmhouse> xerox: What does that do?
07:44:25 <dons> ?hylo f x = x
07:44:25 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
07:44:26 <lambdabot>  where g (x) = x
07:44:26 <lambdabot>     h x = (x)
07:44:32 * xerox doesn't believe dons
07:44:35 <xerox> Oh my.
07:44:43 <dmhouse> What's a hylomorphism?
07:44:44 <dons> ?hylo f x y = f x y
07:44:44 <lambdabot> f x y = f x y
07:44:48 <dons> ?hylo f x y = y
07:44:49 <lambdabot> f x y = y
07:44:52 <dons> ?help hylo
07:44:53 <lambdabot> hylo <expr>. Derive hylomorphism for <expr>. Based on DrHylo.
07:44:53 <lambdabot> Uses the Pointless.Combinators from:
07:44:53 <lambdabot>  http://wiki.di.uminho.pt/twiki/bin/view/Alcino/PointlessHaskell
07:44:53 <lambdabot> Mirrored:
07:44:53 <lambdabot>  http://www.cse.unsw.edu.au/~dons/Pointless/
07:45:31 <vincenz> dons: !
07:45:52 <Dino_> Philippa_: When you say multiparameter, you more more complex than just (say, for example) Eq like compare this instance of Eq for equality with another. The one param being "this one"
07:45:56 <vincenz> Philippa_: you can say that MPTC is a bit like the dylan-style methods
07:46:09 <xerox> dons: that's crazy.
07:46:19 <Philippa_> Dino_: right. The classic examples are a class Coerce from to, or Collection collection element
07:46:26 <dons> xerox: right!
07:46:29 <Philippa_> Coerce would have a single method, of type from -> to
07:47:04 <vincenz> dons: what is that?
07:47:14 <Philippa_> the collection type would allow both monomorphic and polymorphic containers, so you could have eg a specialised IntArray
07:47:31 <dons> vincenz: its a hylomorphism :)
07:47:44 <vincenz> of what
07:47:51 <Philippa_> and it'd know which types're okay as elements because that's the second parameter - you'd have an instance Collection IntArray Int, but not one Collection IntArray Float or Collection IntArray a
07:48:00 <dons> vincenz: of the argument to @hylo
07:48:04 <vincenz> oh
07:48:09 <dons> ?hylo f x = x
07:48:10 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
07:48:11 <lambdabot>  where g (x) = x
07:48:11 <lambdabot>     h x = (x)
07:48:15 * vincenz shuddes
07:48:23 <dons> ?hylo f x = (x,x,())
07:48:23 <vincenz> Nu!
07:48:23 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
07:48:24 <lambdabot>  where g (x, x) = (x, x, ())
07:48:24 <lambdabot>     h x = (x, x)
07:48:47 <vincenz> what is used for the parsing of expressions?
07:48:50 <vincenz> I find no AST
07:48:55 <dons> DrHylo
07:49:04 <dons> i.e. Language.Haskell, I suppose
07:49:30 <ndm> dons, where is DrHylo from?
07:49:33 <norpan> Mu?
07:49:35 <vincenz> I take it that it first goes to a reduced core?
07:49:38 <dmhouse> So what does this crazy function do?
07:49:41 <dons> ndm, Minho, in .pt
07:49:48 <dons> they do lots of pointfree stuff there
07:50:04 <vincenz> where is .pt?
07:50:10 <dons> portugal
07:50:14 <vincenz> ah
07:50:26 <vincenz> the silent european coutnry
07:50:45 <dons> dmhouse: it does the same as f x = ..., but using some wacky pointfree combinators
07:50:46 * edwardk waves ello..
07:50:49 <vincenz> sometimes you wonder if it really exists or if it's just a myth
07:50:55 <dons> hehe
07:50:59 <Spark> can a partial order be a dag?
07:51:07 <vincenz> Spark: yes
07:51:10 <Dino_> Philippa_: Interesting. Thank you.
07:51:11 <Spark> thats what i thought
07:51:17 <edwardk> yeah, quite easily
07:51:23 <Spark> but then i had this memory of some lecturer saying "all partial orders are trees"
07:51:30 <vincenz> Spark: only cpo's
07:51:39 <vincenz> you need a bottom (top) for a tree
07:51:49 <vincenz> so I guess a partial order could be a forest
07:51:52 * vincenz ponders
07:51:53 <vincenz> nm
07:51:56 <vincenz> I'm wrong
07:51:58 <vincenz> dag
07:51:58 <Spark> but a forest is injective
07:52:04 <dmhouse> So then. Who out of you clever, clever people feels like writing the Concurrency section of the Wikibook? :) Or perhaps
07:52:19 <dmhouse> 'Advanced type classes'? Or something on GADTs?
07:52:23 <Dino_> It's nice to be back to studying the H. I had a distracting few days negotiating with creepy recruiters for a job.
07:52:35 <edwardk> only thing i know about concurrency is STM, i haven;t looked into the older stuffyet
07:52:45 <Dino_> Not done with that yet either. :/
07:52:49 <vincenz> concurrency in IO is neat too :)
07:53:03 <vincenz> it's great for having a gui that's tied to a input-output system
07:53:10 * edwardk nods.
07:53:45 <Philippa_> yeah, it was great when I was writing an IRC client - it was the GUI bindings kept getting in the way
07:54:04 * edwardk wants to kick javascript to the curb and build a new imperative language thats conducive to running on STM some times.
07:54:11 <Philippa_> once you get used to the idea of essentially muxing and demuxing over Chans, it's sweet
07:54:18 <edwardk> then i remember i have haskell, and it has a nice imperative subset.
07:54:36 * vincenz wishes gmail had nested labels
07:55:40 <psnl> vincenz: that would be against the search thingy
07:56:00 <vincenz> psnl: nah label:foo:bar:bing:bang
07:56:08 <blackdog> do i need an 'if' primitive to implement scheme?
07:56:17 <petekaz> Philippa_: is this IRC client available?
07:56:27 <edwardk> whats currently killing me is i think i have to give in and use IO for everything, because i could have a getter or setter associated with each hash element and that might call an IO action.
07:56:29 <blackdog> barring S and K silliness
07:56:32 <vincenz> psnl: just that I label each new conference, it'd be nice if I could just hide them all under "paper
07:57:32 <blackdog> wait, i remember now -pattern-matching and laziness is ok, but you need an explicit if in a strict language
07:57:39 <blackdog> thanks, #haskell, you rock!
07:57:47 <dons> blackdog: just got back from Yeah yeah yeahs. excellent!
07:57:55 <blackdog> oh, sweet.
07:58:05 <dons> punk chicks rock!
07:58:13 <blackdog> how is it that we like the same sort of music, but have been to a concert together precisely once?
07:58:26 <dons> its bizarre..
07:58:32 <dons> sonic youth next week?
07:58:33 <blackdog> very weird. and yes. punk chicks are awesome.
07:58:47 <blackdog> nah. too many concerts, not enough cash.
07:59:00 <blackdog> but make sure you get there early, my favourite sydney band is the support
07:59:01 <dons> ah, fair enough
07:59:05 <dons> ah, yes?
07:59:09 <Philippa_> petekaz: I had a rather pathetic accident whereby I saved a workspace-type file over the Main module while I was still in the middle of factoring stuff out into the first pile of actual modules. Never got round to rewriting it :-(
07:59:12 <blackdog> mogwai tomorrow, dj shadow on sunday :)
07:59:19 <dons> oh, yes. mogwai. i forgot!
07:59:22 <blackdog> They're called the thaw
07:59:30 <dons> ok. will take notes
07:59:33 <blackdog> kind of noisy mogwai-ish stuff.
07:59:34 <petekaz> Philippa_: oh well, I was hoping to learn from it.
07:59:40 <Philippa_> it'd never got much beyond being a glorified telnet that PONGed PING messages for you
07:59:55 <Philippa_> (which is the first more-than-telnet feature most sane IRC client writers add...)
07:59:58 <blackdog> they're all preachy vegan types, though. keep making me feel guilty for wearing leather shoes and eating cowburgers
08:00:12 * dmhouse quietly advocates version control in Philippa_'s direction
08:00:14 <dons> hehe. and so you should
08:00:24 <Philippa_> dmhouse: I try to remember but usually forget :-(
08:00:37 <Philippa_> force of bad habit, basically
08:00:42 <dmhouse> Mm.
08:00:52 <blackdog> but i _like_ cowburgers! Murder is tasty!
08:00:53 <Philippa_> it doesn't help that I tend to be working on what should be 2-4 patches at once
08:01:14 <dmhouse> Better interdependant patches than no patches at all.
08:01:17 <dons> oh blackdog. that's the cancer you're tasting.
08:01:23 <norpan> i wrote a fluxx server in haskell some years ago
08:01:24 <ndm> dons, thought about moving to System.FilePath instead of your functions in Lib/Util for lamdabot?
08:01:24 <blackdog> mmmmm. cancer.
08:01:25 <norpan> http://norpan.org/fluxx/
08:01:27 <Philippa_> heh
08:01:29 <lambdabot> Title: Index of /fluxx
08:01:34 <dons> ndm, hmm!
08:01:35 <Philippa_> I never enjoyed fluxx all that much
08:01:43 <dons> ndm, its a good idea
08:01:43 <norpan> it involves concurrent io
08:01:51 <ndm> dons, cause i can see quite a few bugs in them :)
08:01:52 <norpan> so it's therefore interesting
08:01:54 <dons> ndm, i'll put this on the todo list
08:01:59 <dmhouse> norpan: Did you use STM?
08:02:02 * blackdog thinks he should say something about haskell in #haskell
08:02:06 <Philippa_> though the time Aquarion made it entirely deterministic twice in the same game may also have something to do with it
08:02:16 <norpan> no, i used channels
08:02:18 <norpan> and io
08:02:20 <ndm> dons, if you'd accept a patch, i'll put it on my todo list as well
08:02:26 <blackdog> has there been any movement on haskell web stuff? CGI is still a bit clunky...
08:02:30 <ndm> does lamdabot run on Windows?
08:02:31 <norpan> http://norpan.org/fluxx/Server.hs
08:02:31 <Philippa_> dmhouse: AIUI if you're doing piles of IO, STM's less useful
08:02:34 <dons> ndm, oh, i will i will!
08:02:37 <dons> ndm, it has done.
08:02:45 <dons> you get karma too, if you submit lambdabot patches
08:02:47 <Philippa_> blackdog: there's an FCGI version of bringert's NewCGI
08:03:03 <ndm> dons, does lamdabot watch its commit list and karma people automatically?
08:03:16 <dmhouse> Does anyone else typically have to consult Google's define: after nearly everything Philippa_ says? ;)
08:03:24 <greenrd> hehe
08:03:25 <dons> ndm, no. but it could...
08:03:37 <Philippa_> dmhouse: consider it an education :-)
08:03:39 <dons> since it already watches repos
08:03:42 <blackdog> Philippa_: cheers, will check it out. but was thinking more higher-level frameworks
08:03:42 <dmhouse> Philippa_: :)
08:04:03 <ndm> dons, your combinators worry me greatly - (</>), (<.>), (<+>), (<>), (<$>)
08:04:09 <norpan> almost half the code is for handling the X=X+1 card :)
08:04:22 <ndm> surely <> is exactly the same as ++
08:04:24 <dons> ndm, what could be wrong with </> ;)
08:04:29 <dons> ndm, right
08:04:41 <ndm> dons, </> i kind of understand and basically follow
08:04:44 <dmhouse> ndm: Using <> abstracts away from the fact you're using Strings.
08:05:09 <Philippa_> blackdog: I know there're apps that're getting on for that. I don't think anyone's doing AJAX-style stuff yet though. It did occur to me that if you don't mind losing continuations when the server process dies, a continuation-based framework would be... well, trivial
08:05:12 <ndm> <+>, how can inserting a space between two filepath's return a FilePath?
08:05:29 <dons> don't know.
08:05:43 <dons> its probably used as a _string_ combinator
08:05:49 <dons> bad type synonyms
08:05:54 <ndm> yeah, i know
08:06:01 <ndm> i'll get a patch in a few days
08:06:19 <blackdog> Philippa_: yeah. but non-persistent web stuff is ick.
08:06:24 <dons> yeah, i see. it's used for building strings in popen calls, and system calls
08:07:33 <vincenz> I take it that someone has been inspired by prettyprinter combinators?
08:07:40 <dons> right
08:10:13 <xerox> ?b52s
08:10:13 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
08:12:01 <ndm> dons, do you just import the source code for each of the modules you depend on directly into the tree?
08:12:17 <dons> i have done previously yes.
08:12:25 <dons> and try to remove code that isn't used anymore
08:12:46 <dons> unless its an external lib, then we don't need to import, of course
08:12:55 <dons> like fps
08:12:59 <ndm> how do you mean external lib?
08:13:05 <dons> well, a package.
08:13:15 <ndm> so for System.FilePath, would I dump the code in
08:13:17 <ndm> or not?
08:13:22 <dons> how many modules?
08:13:23 <dons> 1?
08:13:39 <ndm> exactly 1 file
08:13:44 <dons> dump in in1
08:13:54 <dons> it in. typity typity type
08:14:08 <ndm> ok, will do
08:15:10 * dons $ sleep
08:27:21 <jgrimes_> ok, I've got a REPL that takes simple mathematics commands and I'm trying to profile it. When I go to view the .prof file, it says "total time = 0.00 secs (0 ticks @ 20 ms)" Is this accurate?
08:27:55 <shapr> Dang, I missed JaffaCake
08:27:57 <jgrimes_> Even though I've run several calculations through the REPL
08:28:09 <shapr> Sounds wrong then
08:28:17 <jgrimes_> Yeah, thats what I figured =/
08:28:31 <shapr> Can you stick a long running calculation ( > 1sec) in there to be sure?
08:29:16 <jgrimes_> I don't think I have the facilities for writing a long running calculation yet =/
08:29:26 <jgrimes_> since it is all basic arithmetic and simple variable assignment
08:29:36 <shapr> You need QuickCheck!
08:29:58 <shapr> Write an Arbitrary instance for your calculations.
08:30:08 <jgrimes_> I guess I'll Check it out then :)
08:30:11 <norpan> why are you profiling it if you don't have a time problem with it?
08:30:17 <jgrimes_> norpan: for fun
08:30:39 <norpan> i see
08:31:30 <ndm> D:\sources\contrib\lambdabot>runhaskell Setup configure
08:31:32 <ndm> Setup: lambdabot.cabal:15: Unknown field 'exposed'
08:31:57 <dmhouse> So. I've got basically an entire week with nothing to do next week, so I figure I should write some cool Haskell project. Any ideas? :)
08:31:57 <shapr> Uh oh, lambdabot is exposing herself in public again.
08:31:59 <ndm> anyone know whats wrong there?
08:32:05 <shapr> dmhouse: Hack on GHC?
08:32:14 <ndm> dmhouse: Hack on Yhc?
08:32:17 <shapr> dmhouse: Or maybe find some cool research papers and write newbie docs for them?
08:32:33 <ndm> Yhc takes a few mins to build, and can be hacked on in WinHugs :)
08:32:48 <dmhouse> I've been writing on the wikibook for a while but I've ran out of steam a little bit. I need Kowey to come back so we can start throwing ideas around again.
08:32:51 <shapr> Oh hey, do I just grab the repo and build on ARM?
08:33:49 <ndm> @seen dons
08:33:50 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 18 minutes and 40 seconds ago.
08:34:10 <ndm> dons, the cabal says that lambdabot depends on unix, a package thats likely to be missing on windows...
08:34:16 <shapr> ndm: y0, do I grab the repo and it should just build?
08:34:27 <ndm> shapr, yep: darcs pull, scons
08:34:30 <shapr> k, thx
08:34:45 <vincenz> scons....AAAAAAAAAAAAa
08:34:57 <dons> interesting, http://www.10kloc.org
08:34:59 <lambdabot> Title: 10kloc.org - 10000 lines of code
08:35:31 <dons> hmm. ndm. interesting.
08:35:36 <dons> i'll have to work out why that is
08:35:47 <ndm> and i also have cabal issues with the exposed field
08:35:52 <ndm> is that an old version of cabal issue?
08:35:56 <dons> remove it :)
08:36:01 <dons> i think its a new cabal issue?
08:36:04 <vincenz> dons: go sleep
08:36:13 <dons> tour de france!
08:36:37 <vincenz> wanna see something seriously funny?
08:36:40 <dmhouse> dons, get a better continent.
08:36:51 <dons> these 10kloc guys are fun.
08:36:52 <vincenz> check "A function to quit for" http://thedailywtf.com/default.aspx
08:36:59 <vincenz> dons: sadly it's C
08:37:02 <dons> "We believe that software exceeding this maximum is bloated and seriously wrong."
08:37:14 <ndm> dons, i did, and then the unix issue came up
08:37:20 <vincenz> dons: I disagree with his claim that most hackers want to maximize loc
08:37:26 <dons> ndm, ok, i'll need to look into it.
08:37:35 <dons> vincenz: well, in this community we strongly value brevity
08:37:39 <vincenz> yep
08:37:39 <Philippa_> I don't think that's the claim. I think the claim is that hackers dicksize by LoC
08:37:41 <vincenz> and clarity
08:37:51 <vincenz> Philippa_: not in our environment
08:38:03 * vincenz points around #haskell
08:38:04 <Philippa_> sure, but we're not your normal bunch of hackers anyway
08:38:10 <dons> Philippa_: yeah, i think that's what they're getting at.
08:38:16 <vincenz> oh right, we're 1337
08:38:32 <ndm> functional programmers boast by number of type classes and amount of higher kinds :)
08:38:35 <dons> "As the number of lines of code in your software shrinks, the more skilled you have become."
08:38:35 <vincenz> dons: check the second post on the link I just sent
08:38:49 <Philippa_> I think it's fair to say that compared to hackerdom at large there's something of an elite in here, yes
08:38:55 <vincenz> ndm: nah, you gotta boast by semantics/loc
08:38:59 <dons> ndm, yeah, the rank-n-iess ;)
08:39:16 <dons> my rank-4 trumps your rank-2 ;)
08:39:26 <Philippa_> I mean, hackerdom at large still shits itself at the idea of writing a compiler and thinks interpreters are hard...
08:39:28 <SamB> you boast about how few typeclasses you needed to perform whatever wonder...
08:39:38 <vincenz> Philippa_: true
08:39:42 <shapr> Here we measure dicksize by abstrosity.
08:39:44 <vincenz> Philippa_: that's daily breakfast here
08:39:54 <Philippa_> damn right it is
08:39:58 <ndm> dons, my rank has never exceeded 1
08:40:00 <dons> Philippa_: ah yes. very good.
08:40:03 <SamB> and how little of your code is boring
08:40:08 <ndm> my type classes have never exceeded one variable either
08:40:08 <vincenz> Philippa_: then again, I'd shit at it too if I had to do it in C
08:40:11 <dons> i always forget that people consider compilers scary uber-magic
08:40:20 <gds> dicksize =~ pointfreeness? >;)
08:40:27 <dons> oh could be!
08:40:30 <shapr> gds: hah
08:40:31 <vincenz> dons: not to mention type inference :)
08:40:34 <shapr> privet alex_vod
08:40:36 <Philippa_> I'd curse if I had to do it in C, and spend a lot of time developing idioms, but I could do it
08:40:38 <edwinb> I think I'd panic if I had to write something that wasn't a compiler.
08:40:39 <vincenz> dons: that's like ... magic :)
08:40:45 <shapr> edwinb: bwahah, quoted!
08:40:46 <SamB> hahaha
08:40:50 <edwinb> :)
08:40:51 <vincenz> Philippa_: yeah but would you want to?
08:40:51 <Philippa_> gds: sort of, yes
08:40:52 <dons> hehe
08:40:55 <SamB> @quote edwinb
08:40:56 <lambdabot> edwinb hasn't said anything memorable
08:40:57 <Philippa_> vincenz: hell no
08:40:58 <shapr> @remember edwinb I think I'd panic if I had to write something that wasn't a compiler.
08:40:59 <lambdabot> Done.
08:41:06 <SamB> @quote edwinb
08:41:07 <lambdabot>  I think I'd panic if I had to write something that wasn't a compiler.
08:41:31 <vincenz> read this: http://thedailywtf.com/forums/thread/81930.aspx
08:41:42 <vincenz> and laugh very loudly
08:42:00 <dmhouse> vincenz: You _just_ linked to that, three minutes ago ;)
08:42:07 <dons> vincenz: yeah, its good :)
08:42:09 <vincenz> yeah but I'm not getting feedback
08:42:14 <norpan> bah
08:42:33 <vincenz> notice the _do
08:42:36 <vincenz> and the _is
08:43:05 <norpan> bah, writing a program to generate that code would take me just a few minuts
08:43:10 <norpan> so what's the point, just do it
08:43:40 <vincenz> norpan: erm
08:43:42 <vincenz> > sum l
08:43:47 <lambdabot>  Not in scope: `l'
08:43:49 <dmhouse> norpan: Read the comments. Range is a better idea.
08:43:58 <vincenz> any sort of list-structure is better
08:44:06 <vincenz> but I finally understand why the number of columns in excel are limited :D
08:44:17 * dons `seq` sleep -- this time for sure1
08:45:39 <norpan> deepSeq
09:02:54 <ndm> @seen dcoutts
09:02:55 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 1 hour, 49 minutes and 9 seconds ago.
09:03:01 <dcoutts> @yarr!
09:03:02 <lambdabot> Aye Aye Cap'n
09:03:23 <ndm> dcoutts: how do i tell if a widget is a container?
09:03:38 <ndm> i.e. will castToContainer succeed
09:04:08 <dcoutts> ndm, if the type is an instance of the Contrainer class
09:04:14 <dcoutts> ndm, it says in the docs for that type
09:04:24 <dcoutts> you're doing downcasting?
09:04:29 <dcoutts> do you really need to do that?
09:04:38 <dcoutts> it's usually a sign of...
09:05:18 <ndm> dcoutts, i basically want to enumerate all controls on a form
09:05:24 <ndm> including nested controls
09:05:28 <dcoutts> ah ok
09:05:59 <dcoutts> hmm
09:06:27 <dcoutts> ndm, try typeInstanceIsA
09:06:36 <dcoutts> it's a bit low level
09:06:48 <dcoutts> we didn't really anticipate that usage
09:07:05 <dcoutts> of really really not knowing if the down cast is going to be safe
09:07:21 <ndm> i want it to give a nicer interface
09:07:44 <ndm> how would i use typeInstanceIsA? what is my Ptr (), and what is the Long i need for container?
09:08:54 <dcoutts> castToContainer :: GObjectClass obj => obj -> Container
09:08:54 <dcoutts> castToContainer = castTo
09:08:54 <dcoutts>   {# call fun unsafe gtk_container_get_type #} "Container"
09:09:02 <dcoutts> ndm, and castTo is defined as:
09:09:30 <dcoutts> well it's a bit bigger, see Grpahics.UI.Gtk.Types
09:09:46 <ndm> hmm, i might leave this bit for later
09:09:56 <ndm> i am just trying to hook up glade and proplang
09:10:00 <dcoutts> the GType ie CLong is the result of gtk_container_get_type
09:10:39 <dcoutts> and the Ptr () is the raw Ptr inside the ForeignPtr inside the Contrainer newtype wrapper
09:10:45 <dcoutts> yeah, low level
09:10:46 <ndm> i think my brain exploded a few levels back :)
09:11:02 <dcoutts> we could add something a bit higher level I guess
09:11:15 <dcoutts> we didn't anticipated it
09:11:17 <norpan> waht is the current research front on gui for haskell?
09:11:31 <dcoutts> there isn't a whole lot actually
09:11:38 <dcoutts> I'm a bit disapointed
09:11:49 <ndm> the current reasearch front is proplang :)
09:11:56 <dcoutts> heh :-)
09:11:59 <ndm> and i hope to have an early demo of that out tomorrow
09:12:06 <norpan> proplang?
09:12:09 <norpan> tell me more
09:12:18 <dcoutts> there was a bunch of stuff a few years back but that focused on doing it from the groud up
09:12:25 <dcoutts> which is clearly the wrong approach
09:12:43 <ndm> norpan: you have a load of properties, and you define the relationships between them
09:12:52 <ndm> then the gui takes care of the plumbing those together
09:13:02 <dcoutts> it needs to be a functional style with a mature backend implemented by someone else (Wx,Gtk,Qt,Tk etc)
09:13:05 <ndm> its best shown with an example, which i'm working on
09:13:15 <norpan> ok, i'll wait until tomorrow then
09:13:35 <norpan> dcoutts: well yes, the gui backend is not interesting
09:13:43 <norpan> could be anything
09:13:51 <norpan> all of those are similar in style
09:13:54 <vincenz> ndm: spit it out
09:14:03 <dcoutts> norpan, however it's essential if you want something that people would actually want to use
09:14:22 <dcoutts> and there are some real differences
09:14:26 <norpan> sure, and gtk2 seems like the best option right now
09:14:29 <norpan> or wx
09:14:35 <dmhouse> dcoutts: Ideally you'd abstract away from the choice of back-end.
09:14:51 <ndm> dmhouse: i am for the most part, but you can't really
09:14:59 <vincenz> ndm: example?
09:15:01 <ndm> since gtk is already an abstract thing over a concrete implementation
09:15:05 <dmhouse> A thin mapping layer to connect things up might be all you need.
09:15:16 <ndm> vincenz: my example is a text editor, with modified and file variables, which propagate around
09:15:18 <dcoutts> dmhouse, that's easier said than done, and building nice abstractions sometimes needs particular features of theunderlying toolkit (eg consitent notifications on property changes)
09:15:20 <norpan> qt is out, tk is ugly
09:15:33 <norpan> gtk2 should be good
09:15:47 <ndm> dmhouse: people will always want more advanced twiddles, so its best to just allow access back to the underlying code, now you are toolkit specific again
09:15:50 <dmhouse> My personal favourite is GTK, but I haven't really worked with Wx.
09:16:12 <norpan> since it does object orientation in pure c it should be easier to interface with from haskell
09:16:14 <dcoutts> abstractions over gui toolkits never fare ery well
09:16:35 <shapr> Hiya sm, how's Haskell treating you?
09:16:39 <dmhouse> ndm: Still, there's no reason for the high-level stuff, like the architecture of the library (arrows? Or something else?) to depend on the choice of back-end.
09:16:49 <sm> hey shapr.. pretty well thx!
09:16:50 <dcoutts> it's ok for windows and buttons but not for more complex widgets, eg trees lists etc
09:16:54 <shapr> sm: Got any questions?
09:17:05 <dcoutts> dmhouse, yes that's (mostly) true
09:17:14 <sm> what webapp framework do you like best ? :)
09:17:18 <shapr> Hope!
09:17:20 <norpan> we'll see what ndm has come up with
09:17:21 <dcoutts> hope
09:17:24 <ndm> dmhouse: no, but the high level stuff (arrows) will never work for tree's and list etc.
09:17:27 <vincenz> Distress!
09:17:33 <shapr> ndm: Why not?
09:17:39 <sm> is it good for building general webapps ?
09:17:54 <ndm> shapr, i suspect there will be a conceptual mismatch - if i am wrong then someone needs to prove it :)
09:18:08 <shapr> sm: It will be soon, or I'll switch to something else.
09:18:18 <sm> cool
09:18:24 <shapr> ndm: Yeah, "show me the code" is always a good argument :-)
09:18:29 <vincenz> shapr: that's not much of a statement regarding it's quality
09:18:40 <sm> I tried happs and liked it
09:18:46 <shapr> In one way, that is a good statement of quality.
09:18:48 <ndm> vincenz: but its valid at the moment
09:19:06 <vincenz> ndm: "if it won't be good then I won't use it" has no implication regarding future value
09:19:22 <dcoutts> dmhouse, don't get me wrong, I think we can do better than what we've got now, but it's harder than it looks which is why we don't have it already
09:19:32 <dmhouse> dcoutts: Right.
09:20:05 <dcoutts> ndm, hae you looked at fran(tk) or the clean object io lib?
09:20:27 <ndm> dcoutts: i took a look at fran briefly, and a couple of toher toolkits
09:20:29 <ndm> not the clean one
09:21:11 <dcoutts> ndm, I keep hoping we can pinch some of the previous research and just apply it
09:21:30 <vincenz> dcoutts: did you read the ANF paper by chakravarty?
09:21:35 <ndm> dcoutts: but i think the state of affairs now shows that the previous research didn't quite catch on
09:21:51 <dcoutts> vincenz, not very carefully
09:21:59 <vincenz> in his figure about ANF
09:22:10 <dcoutts> ndm, but I wonder if that's just because they were basing their impls on tk or xlib.
09:22:13 <shapr> sm: Want a Hope demo?
09:22:13 <vincenz> letrec f in e_s
09:22:19 <vincenz> why is the e subscripted by the s
09:22:19 <dcoutts> ndm, it they were reall really ugly
09:22:21 <ndm> dcoutts: more than possible
09:22:38 <sm> shapr: sure!
09:22:48 <dcoutts> ndm, and partly solving the wrong problems, like layout rather than concentrating on events and state
09:22:48 <shapr> http://www.scannedinavian.com/hope/
09:23:49 <ndm> dcoutts: i have noticed much academic reasearch gets good answers and shows that most academics have no appreciation of software engineering at all
09:24:08 <dcoutts> ndm, heh
09:24:30 <ndm> for example, there has been lots of reasearch into "writting Hoogle", but no actual programs that people get to use
09:24:53 <ndm> (and interestingly hoogle throws out most of there isomorphism principles)
09:25:43 <shapr> hi Speck
09:26:37 <vincenz> ndm: problem is that software engineering typically does not warrant paper
09:26:47 <shapr> vincenz: It should :-/
09:26:47 <vincenz> ndm: except perhaps in OOPSLA style conferences
09:26:53 <shapr> SE needs help.
09:27:10 <shapr> sm: Want a temporary login to try out Hope?
09:27:12 <ndm> vincenz: indeed, but personal gratification should make people want their thing to be solid and useable
09:27:16 <shapr> Hi SyntaxNinja!
09:27:34 <sm> shapr: yes please
09:27:59 <norpan> haha, birthday.se is a real integrity porn site
09:28:10 <edwinb> It'd be nice if research generated solid and usable software, but unfortunately number of publications is what matters in the end.
09:28:14 <norpan> shapr is 35 in 61 days
09:28:15 <shapr> sm: Login is your irc nick, and password is your most famous Product.
09:28:19 <shapr> norpan: What?
09:28:34 <shapr> edwinb: That does suck
09:28:41 <SyntaxNinja> heya. 'sup shapr
09:28:45 <shapr> y0 y0!
09:29:00 <vincenz> ndm: true and I sometimes tend to lean too much towards SE when working on my stuff
09:29:02 <edwinb> If researchers had the chance to spend time writing software, we'd have an Epigram 2 by now for a start...
09:29:04 <reppie> http://xkcd.com/c114.html
09:29:05 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
09:29:06 <vincenz> ndm: which is dangerous as academic
09:29:16 <SyntaxNinja> darn! I forgot my phone today
09:29:25 <ndm> vincenz: me too
09:29:29 <shapr> edwinb: It's hard to find a balance between pure research and helping out the everyday worker.
09:29:32 <vincenz> ndm: for instance the profiling library that I sent to ICME
09:29:45 <vincenz> and the compiler I'm currently working on
09:30:14 <dcoutts> ndm, http://haskell.org/FranTk/userman.pdf
09:30:18 <vincenz> heh, once made a very nice c++ template based functor library but it ended up being useless :(
09:30:27 <vincenz> I even got currying to work in c++
09:30:43 <dcoutts> ndm, my supervisor actually built a structure editor using frantk
09:31:45 <dcoutts> it's related to Fran
09:31:57 <dcoutts> which is related to these arrow things
09:32:17 <dcoutts> ndm, so FranGtk ?
09:32:37 <edwinb> shapr: We don't get any more money to do fun stuff if we don't write papers though, so that's where the priority is. If software happens too, that's a nice side-effect...
09:32:45 <ndm> dcoutts: I'll hack up my ideas first - they are a few hours from done, then i'll compare after
09:32:55 <dcoutts> y'ok
09:33:35 <shapr> edwinb: Yeah, that's sad.
09:39:38 <lispy> shapr: that's my biggest reason to not like research :(
09:39:51 <shapr> Ah, but we have The Monad.Reader, and especially #haskell
09:40:01 <SamB> ideally, papers would be documentation for software
09:40:07 <shapr> Where the road meets the ivory tower!
09:40:20 <lispy> heh
09:41:07 <vincenz> SamB: well not all papers, but for instance the "pearl" section of ICFP, sure :)
09:41:18 <vincenz> those are typically fun to read
09:41:41 <SamB> what are the other sections for?
09:41:46 <vincenz> theory?
09:42:04 <SamB> well, um, theory should be documentation for software also
09:42:10 <SamB> this is Haskell, after all!
09:42:20 <vincenz> SamB: there's a limit
09:42:25 <SamB> true, true...
09:43:01 * vincenz hmms
09:43:06 <vincenz> indirect composite.... or ast tagging
09:43:10 <vincenz> that is the eternal question
09:43:21 <edwinb> Ideally papers would *be* software ;).
09:43:27 <vincenz> edwinb: lhs2tex?
09:43:33 <edwinb> with a machine checkable appendix! etc.
09:44:14 <bringert> shapr: I see Hope has a marketing department :-)
09:44:27 <shapr> Oh yes :-)
09:45:06 <vincenz> ndm: you use tagging?
09:45:13 <ndm> vincenz: for what?
09:45:18 <vincenz> ast annotation
09:45:26 <ndm> no, i don't really tag my ast
09:45:32 <vincenz> data AST a = Var | .. | .. | ASTTag a
09:45:38 <ndm> otehr than having separate tables, mapping ast elements to information
09:46:03 <vincenz> hmm
09:46:07 <vincenz> maybe bringert knows more
09:46:13 <vincenz> his latest icfp paper is great for this kind of stuff
09:47:04 * vincenz wonders where he saved it
09:47:45 <vincenz> vincenz@abstractlappy:~/Documents/Oasis/Dox$ find . -type f | wc
09:47:45 <vincenz>    1104    2878   63458
09:49:38 <vincenz> bringert: ping
09:50:59 <bringert> vincenz: pong
09:51:07 <bringert> looking for my paper?
09:51:18 <vincenz> no I have it
09:51:23 <vincenz> just have some questions regarding it
09:51:54 <vincenz> would it be possible to somehow parametrize the GADT?
09:51:56 <bringert> I'm cleaning my apartment, so my response time might be a bit long, but ask away
09:52:16 <vincenz> data Tree a = ....
09:52:35 <bringert> ?
09:52:36 <vincenz> so you can compos :: ... -> ... -> ... -> Tree a -> m (Tree b)
09:52:50 <vincenz> section 4.1 & 4.2
09:53:16 <vincenz> that should be data Tree a :: where
09:53:37 <vincenz> also I don't understand why you pass in return into compos...
09:56:25 <bringert> vincenz: the GADT already has a type parameter. do you want a second one?
09:56:51 <vincenz> yes
09:56:56 <vincenz> so for instance
09:56:58 <vincenz> data Tree var ::
09:57:04 <vincenz>   V :: var -> Tree Var
09:57:07 <vincenz> erm
09:57:15 <vincenz> V :: var -> Tree var Var
09:57:45 <bringert> vincenz: the reasone why return is passed in is that you may want to pass something other than return, for example Control.Applicative.pure
09:57:47 <vincenz> SAss :: Tree var Var -> Tree var Exp -> Tree var Exp
09:58:08 <vincenz> is that feasible or are GADTS still too unstable for that?
09:58:15 <vincenz> @type Control.Applicative.pure
09:58:16 <lambdabot> Couldn't find qualified module.
09:58:17 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
09:58:44 <bringert> I haven't tried with more type parameters, but I don't see why it shouldn't work
09:58:59 <vincenz> what is pure?
09:59:10 <bringert> vincenz: lib here: http://cvs.haskell.org/Hugs/pages/libraries/base/Control-Applicative.html
09:59:31 <bringert> vincenz: paper here: http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
09:59:34 <vincenz> ah right
09:59:38 <vincenz> thx
09:59:59 <bringert> pure is a generalization of return to applicative functors, a generalization of monads
10:00:08 <vincenz> bringert: on another note.... how would you annotate ASTs that you built up with your system?
10:00:24 <vincenz> tagging or another type parameter that you'll have as () when unused?
10:00:26 <bringert> as in type annotate for example?
10:00:29 <vincenz> yeah
10:00:42 <vincenz> flexible annotations aren't the easiest thing to do
10:01:07 <vincenz> at least not cleanly
10:01:28 <bringert> by tagging, do you mean having a separate data constructor for annotations, that you wrap each node in?
10:01:33 <vincenz> pretty much
10:01:41 <bringert> I think you could do either
10:01:42 <vincenz> ndm suggested it I think
10:01:58 <bringert> but I haven't tried
10:01:59 <vincenz> bringert: on another note, how would you fold over your GADT
10:02:10 <bringert> composFold
10:02:19 <vincenz> pass in x functions where x = number of constructors?
10:02:44 <bringert> ah, the point of the paper is to avoid having to do that sort of thing
10:02:57 <vincenz> composFold is not mentioned in the paper
10:03:02 <vincenz> but yeah, you do want to avoid that
10:03:20 <bringert> vincenz: sorry, composOpFold
10:03:35 <vincenz> is compos a generalization of composOp?
10:03:54 <bringert> yes, and of composOpM and composFold
10:03:58 * vincenz nods
10:04:00 <vincenz> alright :)
10:04:13 <vincenz> it'll be interesting to see how this works out for more type parameters
10:04:24 * vincenz crosses his fingers
10:04:38 <vincenz> oh yeah I remember someone mentioning how GADT didn't mesh well with some other haskell feature atm...
10:04:59 <bringert> the idea compared to normal folds is that instead of passing in a function for each constructor, you pass in a single function which can pattern match on the various constructors, and ignore the ones it doesn't care about
10:05:10 <vincenz> yeah, that's a great idea :)
10:05:25 <vincenz> basically a "defaulting" mechanism
10:06:10 <bringert> see the "free" example in section 3 for a fold example
10:06:53 <vincenz> right
10:07:16 * bringert goes to get his laundry
10:07:49 <vincenz> bringert: would the version for multiparameter typecons interest you?
10:08:07 <bringert> vincenz: yes
10:09:37 <vincenz> bringert: I get the impression that Compos the module wouldn't work straight away
10:09:48 <vincenz> cause it does: t c -> m ( t c)
10:10:05 <ndm> dcoutts: when playing with onInsertAtCursor I cna't get it working on a TextView item?
10:10:35 <ndm> it brings up EntryClass, but thats not mentioned in that bit of hte docs....
10:10:59 <dcoutts> ndm, ah, it's a name clash, hoole for it, you'll see
10:11:15 <dcoutts> http://haskell.org/hoogle/?package=gtk&q=onInsertAtCursor
10:11:17 <lambdabot> Title: onInsertAtCursor - Hoogle
10:11:38 <ndm> dcoutts: ah, that makes sense
10:11:43 <dcoutts> ndm, it's a problem with trying to shoehorn a non-flat namespace into a flat namespace
10:11:55 <ndm> in a kind of now i understand it, not in a eeekkk i want to kill myself way though
10:11:56 <dcoutts> you'll have to fully qualify it I' afraid
10:12:37 * dcoutts wants to be able to import non-flat namespaces
10:12:52 <dcoutts> eg import Graphics.UI.Gtk and then use Button.new
10:12:57 <vincenz> bringert: I guess I need something that's both Compos and a Functor
10:13:02 <vincenz> at the same time
10:14:40 <ndm> dcoutts: it doesn't seem to be raising onInsertAtCursor when I type stuff?
10:14:44 <ndm> is that the right event?
10:14:50 <bringert> vincenz: but the t could be a partially applied type constructor
10:16:05 <vincenz> bringert: not sure how that'd work for Compos
10:16:09 <vincenz> bringert: it'd need to be changed
10:17:03 <dcoutts> ndm, I have no idea what that signal does, but you want onInsertText on the buffer, not the view
10:17:16 <vincenz> bringert: maybe I should write a paper :) even though I work in a different context :P
10:17:24 <ndm> dcoutts: cheers, thats better!
10:17:44 <ndm> dcoutts: and if i insert text programmatically, with setText for example, will it raise that signal?
10:17:52 <dcoutts> ndm, there are unfortunately a few undocumented Gtk signals so it's not always obvious :-(
10:18:00 <dcoutts> ndm, yes it probably will
10:19:58 <vincenz> gadt's are neat :)
10:20:36 <vincenz> bringert: is it possible to make one data constructor that can become any type of Tree?
10:20:43 <vincenz> ETag :: Tag -> Tree a
10:20:50 <bringert> yes
10:20:57 <vincenz> compiler won't complain about not knowing?/
10:21:13 <vincenz> cause no a is being passed in
10:21:22 <bringert> but wouldn't you want it to be: ETag :: Tag -> Tree a -> Tree a
10:21:26 <bringert> to wrap a tree
10:21:39 <bringert> vincenz: it's like read
10:21:42 <bringert> @type read
10:21:43 <lambdabot> forall a. (Read a) => String -> a
10:22:12 <vincenz> bringert: good point
10:22:21 <vincenz> and it'll be
10:22:31 <vincenz> ETag :: tag -> Tree a tag -> Tree a tag
10:22:34 <vincenz> :)
10:22:46 <vincenz> or possibly een
10:22:52 <vincenz> ETag :: tag -> Tree a b -> Tree a tag
10:22:54 * vincenz scratches his head
10:23:08 <vincenz> though I doubt that would work, but it would allow me to tag different places with different tags
10:25:06 <palomer> tags!
10:25:25 <palomer> haskell should have syntactic sugar for dealing with tags
10:26:00 <SamB> but semantic sugar would be so much more lovely!
10:27:45 <bringert> haskell allows you to create embedded languages, aka syntactic nutrasweet
10:29:06 * palomer hates nutrasweet
10:29:20 <palomer> haskell also needs list types
10:29:31 <vincenz> bringert: gotta be identified to privmsg, fyi, in case you sent me one
10:29:32 <petekaz> bringert: what is meant when you say embedded languages?  DSLs like lisp?
10:29:44 <palomer> lisp is a DSL?
10:29:53 <palomer> common lisp is the anti-DSL
10:29:55 <bringert> vincenz: I didn't
10:29:56 <petekaz> no, I meant making DSLs in Lisp.
10:29:58 <vincenz> ok :)
10:30:03 <MarcWeber> Why isn't haskell as spreaded as perl? ;-(
10:30:22 <vincenz> oh wait, you are identified
10:30:23 * vincenz shuts up
10:30:38 <vincenz> MarcWeber: spreaded?  sounds kinky
10:30:40 <vincenz> you mean widespread
10:31:20 <MarcWeber> *g* .. vincenz you're right. I couldn't decide.
10:31:46 <MarcWeber> But I've learned kinky now, too
10:32:21 * bringert goes out to hunt for quarters for the laundry
10:34:20 <vincenz> heh
10:34:24 <vincenz> my compiler doesn't like GADTS
10:34:26 <vincenz> it complains on the * in
10:34:30 <vincenz> data X :: * -> * where
10:35:43 <vincenz> nm, forgot an option.  Does anyone know if it's possible to do "deriving" stuff for GADTs?
10:37:02 <bringert> nope
10:37:07 <bringert> unfortunately
10:38:25 * vincenz whistles as he forces his heartbeat to 3x speed in less than 30 seconds
10:39:37 <vincenz> bbl
10:39:40 * vincenz -> home
10:47:52 <Spark> i might have to stop research CS and start research cryogenics
10:48:02 <shapr> Getting cold there?
10:48:17 <Spark> nah its too ho
10:48:18 <Spark> hot
10:48:51 <Spark> maths should only occur between 17 and 23 degrees centigrade
10:49:10 <shapr> bringert: How do you do layout of the boxes?
10:49:26 <Spark> for some reason this country is woefully underequipped for any kind of weather that isnt light drizzle
10:49:28 <shapr> Oh, by name?
10:49:44 <lisppaste2> erider pasted "confussion " at http://paste.lisp.org/display/22868
10:51:17 <ndm> Spark: which country?
10:51:25 <Spark> uk
10:51:41 <ndm> yeah, i have guessed that was going to be your answer, i'm in the uk too
10:51:45 <Spark> :)
10:52:46 * edwardk waves hello.
10:53:32 <shapr> hiya!
10:53:52 <edwardk> ok, I have to admit, I found the whole darcs/cabal setup a little weird at first, but now its winning me over.
10:54:46 <shapr> yay!
10:56:13 <ndm> disturbingly, i have almost been won over by cabal as well
10:56:17 <dcoutts> ndm, I've checked with a Gtk+ dev and that signal you and I were confused about should not be bound at all, it's kind of an internal thing (keybindings).
10:56:29 <dcoutts> ndm, hah :-)
10:56:32 <ndm> dcoutts: cool :)
10:56:42 <dcoutts> ndm, so no wonder we were confused :-)
10:56:44 <ndm> i am about 15 mins away from a preview demo being shoved in darcs
10:56:58 <dcoutts> ndm, so turns out there are no interesting TreeView signals
11:04:03 <erider> excuse my english
11:04:22 <bringert> shapr: CSS :-)
11:05:06 <erider> hola araujo
11:05:44 <bringert> shapr: the default layout is in style/hope.css. I suggest that you make your own theme, where you can also play with colors etc. Just copy theme/hope to theme/shapr or something, and start editing the CSS there
11:08:05 <araujo> hola erider
11:08:33 <araujo> erider, good to see you around, learning haskell? :-)
11:08:45 <shapr> bringert: Will do, thanks.
11:12:12 <dcoutts> http://www-128.ibm.com/developerworks/java/library/j-cb07186.html?ca=dgr-lnxw07Haskell
11:12:14 <lambdabot> Title: Crossing borders: Explore functional programming with Haskell
11:12:21 <dcoutts> as seen on OSNews
11:12:26 <vincenz> re
11:14:31 <ndm> dcoutts, http://www.cs.york.ac.uk/fp/darcs/proplang/
11:14:33 <lambdabot> Title: Index of /fp/darcs/proplang
11:14:58 <edwardk> still getting used to just throwing my working directory on the web, but then i was doing that with the slipwave site anyways =)
11:17:04 <vincenz> wanna read something funny?
11:17:17 <vincenz> they're comparing opera9, firefox 2 b1 and ie7b3
11:17:21 <vincenz> check the tables on this page
11:17:28 <vincenz> http://www.extremetech.com/article2/0,1697,1990855,00.asp
11:17:34 <vincenz> especially the scaling of memory usage for opera 9.0
11:17:35 <vincenz> :D
11:18:34 <ndm> dcoutts: type in the textbox, watch the title bar
11:18:44 <dcoutts> ndm, ok
11:19:36 <dcoutts> ndm, nice
11:20:55 <ndm> dcoutts: if i can have an enumeration of all the child windows, i can make it a bit nicer
11:21:11 <dcoutts> ndm, how would that help?
11:21:31 <ndm> dcoutts: the top bit, getTextBox window "txt" for each control
11:21:39 <ndm> I can preload them all on getWindow
11:21:43 <ndm> then they can be pure
11:21:49 <ndm> then I can create getItem "txt"
11:22:03 <ndm> and just fill the record with {txt = getItem "txt", sb = getItem "sb" ...}
11:22:08 <ndm> which makes it a lot neater
11:22:17 <dcoutts> I don't quite follow
11:22:25 <dcoutts> what does getTextBox do?
11:22:33 <ndm> getTextBox gets a textbox from a window
11:22:39 <ndm> but its unpure
11:22:51 <ndm> if I could enumerate the children of window, i could cache the results
11:22:57 <ndm> and then return them in a pure manner
11:23:10 <ndm> have you looked at the code in Sample.hs?
11:27:12 <edwardk> memory usage 42k? =)
11:27:15 <edwardk> ha!
11:27:49 <vincenz> edwardk: funnier, opera goes down when you open websites :)
11:27:56 <edwardk> yeah
11:28:26 <edwardk> that and they are using acid2 as a benchmark, which, while valid, opera has been obsessing about, breaking otherwise functional stuff to make it work ;)
11:29:53 <vincenz> edwardk: yeah the article feels slightly (though just slightly) skewed towards opera
11:32:12 <dcoutts> ndm, how do you know which text box you're getting?
11:32:22 <ndm> dcoutts: "txt"
11:32:27 * vincenz heads out for dinner
11:32:28 <ndm> its the name i assigned it in glade
11:32:49 * shapr hacks around inside Hope
11:32:52 <dcoutts> ndm, so can't we just use the glade name lookup ?
11:33:11 <vincenz> cool link: http://www.google.com/holidaylogos.html
11:33:12 <lambdabot> Title: Google Holiday Logos
11:33:12 <dcoutts> why do we need to iterate over all widgets in the widow?
11:33:13 <ndm> dcoutts: we can, but its in IO
11:33:25 <ndm> I want to cache it, take it out of IO, then have it become pure
11:33:38 <dcoutts> ndm, ah ok, well there's probably better ways
11:33:50 <ndm> unsafePerformIO better ways?
11:33:53 <dcoutts> ndm, actually getting the widget from the gladexml could be considered pure
11:34:04 <dcoutts> ndm, so indeed unsafePerformIO would be kosher
11:34:13 <ndm> fair enough, will do that then
11:34:13 <shapr> bringert: How does the part after $MODULE/ get handled?
11:34:36 <shapr> bringert: I want to extend Module_user to handle user/$NAME and then add a personal area for uploading files.
11:34:39 <dcoutts> ndm, it might even be a good improvement to the current glade interface to make that pure
11:34:49 <ndm> dcoutts: i would have thought so
11:35:11 <dcoutts> I'd want to double check that it really is pure
11:35:18 <dcoutts> but I think it is
11:35:33 <shapr> bringert: ah, Module.moduleResources, specifically Module_user.userResources ?
11:35:48 <shapr> aha
11:36:14 <ndm> dcoutts: actually, i have loads more stuff to do which is really unpure, so cacheing would be the only way
11:36:31 <dcoutts> ndm, like?
11:36:38 * shapr cackles happily
11:36:42 <shapr> Haskell kicks butt :-)
11:36:47 <ndm> dcoutts: wiring up events
11:37:00 <Cale> dcoutts: How could I help with VTE support?
11:37:19 <dcoutts> Cale, run the api generator to generate most of the binding, that's all I did
11:37:31 <dcoutts> Cale, then fix up the bits the code generator can't handle
11:39:49 <bringert> shapr: yes, you got it
11:41:32 <mwc> I finally figured out what I'd like a haskell debugger to be
11:41:52 <ndm> dcoutts: ContextId, I can't seem to use it, it says not in scope
11:42:10 <mwc> suppose you apply a function: foo (Just "a") 4. then you switch the lhs for the rhs and see those values subsituted in
11:42:13 <vincenz> bringert: you ignore privmsg?
11:42:22 <ndm> dcoutts: it seems you have it available, but don't export the type
11:42:24 <bringert> I do?
11:42:32 <dcoutts> ndm, yep, bug. type ContextId = CUInt
11:42:37 <vincenz> bringert: did you get my message?
11:42:38 <mwc> then you can go down the expression tree and perform further expansion on other "lhs" terms
11:42:38 <bringert> oh
11:42:40 <bringert> yes
11:42:43 <vincenz> okk
11:42:47 <vincenz> well feel free to think on it
11:42:48 <bringert> it was in a window that I didn't see
11:42:50 <vincenz> I have to head out for dinner
11:42:52 <vincenz> be back a bit later
11:43:22 <dcoutts> ndm, you're using 0.9.10 right? it seems to be fixed in the current darcs version
11:43:44 <ndm> dcoutts: yep, the release you put together a week ago
11:43:51 <dcoutts> ndm, ah yes
11:46:09 <ndm> dcoutts: cool, i got round it easily enough
11:51:23 <Cale> what project is libvte part of?
11:53:12 <Cale> oh, gnome, it looks like
11:58:28 <ndm> dcoutts, what is the concept name to disable/enable things in Gtk?
11:59:02 <dcoutts> ndm, you mean to make say a button greayed out and not pressable?
11:59:09 <ndm> dcoutts: yep
11:59:15 <dcoutts> sensitive I think
11:59:17 <ndm> without the name, its almost impossible to find :)
12:00:24 <ndm> dcoutts: how do i toggle it for a control?
12:00:43 <ndm> it seems to want to toggle it for actions, rather than controls
12:01:08 <Cale> widgetSetSensitivity
12:01:21 <Cale> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Widget.html#v%3AwidgetSetSensitivity
12:01:29 <ndm> Cale, thanks - i hoogled on sensitive, which obviously misses...
12:01:36 * dcoutts too
12:01:45 <dcoutts> calbe beat me to it :-)
12:01:52 <dcoutts> calbe/Cale
12:01:54 <Cale> I just looked for the Widget library :)
12:03:05 <ndm> dcoutts: it appears not to be in scope...
12:03:33 <ndm> oh, i was looking for getSensitivity
12:03:43 <ndm> which doesn't exist...
12:03:50 <dcoutts> :-)
12:04:42 <ndm> is there any way to get the sensitivity?
12:04:50 <ndm> seems like there should be, but can't find it
12:05:12 <Cale> widgetGetState
12:05:34 <dcoutts> heh, not terribly obvious
12:05:39 * dcoutts checks
12:05:42 <Cale> which will give you a value in StateType, that might be StateInsensitive
12:06:25 <ndm> cool, will write my own widgetGetSensitivity from that
12:06:38 <Cale> yeah, that should be in there :)
12:07:01 <dcoutts> ndm, ah, I see why we don't have a widgetGetSensitivity, in the C api it's a macro :-(
12:07:14 <dcoutts> ndm, we should just bind it anyway by doing what the macro does
12:07:24 <ndm> yeah, would be more regular
12:07:32 <ndm> although once you have proplang no one will ever care ;)
12:07:32 <Cale> heh, why would it be a macro?
12:08:16 <dcoutts> ndm, I've noted it in my TODO
12:08:33 <Cale> C programmers are strange :)
12:08:36 <dcoutts> aye
12:08:52 <dcoutts> they thought quite a bit about language bindings, but weren't 100% consistent
12:14:09 <Cale> Will make get-source-code download the vte source for me, or should I get that separately?
12:19:35 <Cale> Do some C programmers just code every small function as a macro or something?
12:19:59 <jer> Cale, no
12:20:04 <BCoppens> lots of them do
12:20:33 <jer> that's very bad style... any modern compiler will inline functions where it can; and C99 supports 'inline' keyword now adays anyway
12:20:39 <dcoutts> Cale, it was a trivial macro/function: GTK_WIDGET_SENSITIVE(wid) = ((GTK_WIDGET_FLAGS (wid) & GTK_SENSITIVE) != 0)
12:20:41 <ailndx> Cale: i asked a friend to make some optimized C code for an example for one of the examples you gave last time(binary trees) it it beat the shit out of haskell
12:20:46 <Cale> jer: yeah, I know
12:21:01 <dcoutts> Cale, so you can see why a C coder would do that, it's just testing a flag.
12:21:12 <Cale> ailndx: I gave a binary trees example?
12:21:57 <ailndx> Cale: you gave a link to some sites that compares very many languages on different implementations.. binary trees/threads and so on
12:22:13 <LordBrain> the shootout?
12:22:14 <Cale> the GCLS?
12:22:14 <SamB> oh, you mean the shootout
12:22:25 <Cale> He should submit his code.
12:22:41 <ailndx> Cale: http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
12:22:43 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ...
12:23:09 <ailndx> Cale: no need, there was allready a pretty good C example code there that allready beat haskell and was almost as good as his
12:23:24 <Cale> ailndx: Haskell is winning there
12:23:31 <ailndx> Cale: No it aint
12:23:38 <ailndx> Cale: look lower at the site
12:23:43 <Cale> Haskell GHC #2 : 1.87 s
12:23:55 <ailndx> 1.2 C gcc #2 1.27 3,568 826
12:23:58 <ailndx> look LOWER
12:24:00 <ailndx> on the site
12:24:49 <ailndx> no wonder it can look like haskell wins a few tests when it dont uses the best C example codes in the default compare
12:24:54 <Cale> Hmm, interesting, I wonder why it's not properly entered
12:25:06 <Cale> Maybe it's noncompliant?
12:25:38 <ailndx> it works
12:25:45 <ailndx> he tested it also
12:25:57 <ailndx> was pretty similar performance to his
12:26:16 <Cale> http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all -- ask your friend to try this one :)
12:26:17 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ...
12:27:44 <Cale> Usually the "interesting alternative programs" don't meet the spec somehow.
12:27:59 <ailndx> Cale: well so many of those examples the C/C++ code totally suck, some of them didnt even make them able to compile.. pretty much tells it
12:28:03 <Cale> (For example, they use an alternate data structure than the one requested)
12:28:11 <Cale> Hm?
12:28:12 <int-e> Cale: it allocates a pool of (about) 2^n nodes for a tree of depth n.
12:28:24 <int-e> Cale: and frees it at once
12:29:24 <int-e> Cale: and that's indeed clever but doesn't meet the specification :)
12:29:32 <Cale> ah, so it's not doing all the deallocation it's supposed to
12:29:49 <ailndx> Cale: and that example isnt even doable in clean C/C++, C dont support threads, thats OS specific
12:29:50 <Cale> s/d/r/
12:29:50 <SamB> what does it do that for?
12:30:09 <int-e> hmm. actually the specification is very vague.
12:30:11 <Cale> ailndx: No it's not. Concurrency, not parallelism.
12:30:15 <SamB> ailndx: well, you can surely do something!
12:30:26 <SamB> int-e: the specification does say the first tree is supposed to stick around
12:30:45 <SamB> er, second tree
12:30:51 <ailndx> Cale: it is, threading isnt even mentioned in the standards. So its NOT in the language
12:31:01 <SamB> first tree is *supposed* to be immediately deallocated
12:31:13 <SamB> Each program should
12:31:13 <SamB>     * define a tree node class and methods, a tree node record and procedures, or an algebraic data type and functions, or…
12:31:13 <SamB>     * allocate a binary tree to 'stretch' memory, check it exists, and deallocate it
12:31:13 <SamB>     * allocate a long-lived binary tree which will live-on while other trees are allocated and deallocated
12:31:13 <SamB>     * allocate, walk, and deallocate many bottom-up binary trees
12:31:15 <SamB>           o allocate a tree
12:31:17 <SamB>           o walk the tree nodes, checksum node items (and maybe deallocate the node)
12:31:19 <SamB>           o deallocate the tree
12:31:21 <SamB>     * check that the long-lived binary tree still exists
12:31:24 <Cale> ailndx: Then implement your own lightweight threads. :)
12:31:37 <Philippa> ailndx: I think in the case of languages like C that're clearly intended to allow calling functions defined in other languages that's somewhat misleading
12:32:20 <Cale> Or you're allowed to use pthreads
12:32:22 <ailndx> Philippa: threads isnt a language, it uses specific api's like the posix threads, win threads and so on.
12:32:42 <int-e> SamB: I see.
12:32:52 <ailndx> And even if you would call another languages code through a lib or something, that is not C/C++ code
12:32:52 <Cale> GHC has platform-independent threads.
12:33:00 <LordBrain> he could implement it in haskell and output it to c
12:33:00 <Philippa> ailndx: and *that* is irrelevant
12:33:03 <LordBrain> hehehe
12:33:10 <Philippa> specific APIs are implemented how?
12:33:12 <ailndx> Philippa: no it certainly aint
12:33:30 <SamB> by using syscalls provided by the kernel
12:33:36 <ailndx> Cale: So does boost, but boost aint a part of the c/c++ standard and therefor shouldnt be compared
12:33:42 <Cale> ailndx: why?
12:33:52 <Philippa> C code that uses a set of existing facilities outside the standard libs is nevertheless still C code
12:34:00 <Philippa> it's just C code that's also written against a specific API
12:34:24 <int-e> what a silly benchmark :(
12:34:28 <SamB> certainly these libraries would need to be installed on the benchmark machines
12:34:56 <LordBrain> maybe they should have a separate entry for c+boost
12:34:59 <ailndx> Cale: cause its a compare between languages, not all kinds of external API's they can use
12:35:16 <LordBrain> hmm c++ that is... boost is c++ isnt it?
12:35:23 <SamB> LordBrain: quite
12:35:28 <Cale> ailndx: Well, fine then, write your own threading as part of the submission. :)
12:35:33 <SamB> you can't *do* that in C
12:35:50 <LordBrain> i've never actually used boost
12:35:54 <SamB> I believe boost uses templates heavily
12:36:01 <Cale> ailndx: But GHC comes with threading built in, so there's no problem there :)
12:36:10 <ailndx> Philippa: WRONG, it can be C/c++ code like boost for example, but threads or something can be pre compiled libs and have NOTHING to do with C and therefor aint any C code even if you call it from C
12:36:31 <Cale> ailndx: pthreads is written in C
12:36:36 <Cale> (the implementation)
12:37:04 <SamB> well, doesn't it use wierd syscalls?
12:37:04 <Philippa> ailndx: I don't recall saying the API implementations were C
12:37:07 <ailndx> well the compare will still be os specific then, not language specific since it calls OS API's
12:37:08 <LordBrain> is it correct to say, that what makes the threads lightweight is that they are in user space?
12:37:17 <LordBrain> managed in user space i mean
12:37:23 <Cale> ailndx: yes, of course it is.
12:37:28 <Philippa> LordBrain: that and don't have some other form of high overhead
12:37:35 <SamB> well, anyway, why not include extra API's in the "language" for shootout purposes?
12:37:36 <LordBrain> yeah
12:37:37 <LordBrain> ok
12:37:39 <Cale> ailndx: Though it would be easy enough to port pthreads to any other OS.
12:37:41 <SamB> er, APIs
12:37:58 <LordBrain> why cant the operating systems provide user-space thread management servers
12:38:07 <SamB> they *can*
12:38:15 <Cale> It doesn't even matter though.
12:38:17 <SamB> but it doesn't make much difference to normal apps
12:38:22 <LordBrain> hmmm
12:38:25 <SamB> as long as it isn't dreadfully slow, I mean
12:38:37 <ailndx> Cale: sure, but the point of the compare pretty much falls then, it should compare languages, not OS API calls.
12:38:37 <Cale> If your language doesn't have a primitive notion of concurrency, you ought to be able to write one.
12:38:44 <SamB> and why would threads be managed by servers, anyway?
12:38:48 <Cale> ailndx: Don't make OS calls then
12:38:58 <Cale> ailndx: I don't see what your problem is.
12:39:01 <LordBrain> they can use kernel threads for the kernel and drivers.. and use a user-space thread system for everything else... ?
12:39:02 <ailndx> Cale: the threads will do that nontheless
12:39:07 <Cale> ailndx: no
12:39:15 <Cale> ailndx: The GHC program for instance doesn't use OS threads.
12:39:21 <SamB> ailndx: in practice, programs use OS calls
12:39:26 <ailndx> Cale: the whole point of these tests is to see how good code performancewise the compiler can generate
12:39:28 <SamB> directly or through libraries
12:39:41 <Cale> ailndx: right
12:39:47 <Cale> ailndx: so don't use OS threads
12:39:54 <LordBrain> hmmm i think its suitability for multi-threaded applications is a decent thing to want to compare
12:39:58 <palomer> damnit, how do you roll your Rs?
12:40:00 <Philippa> and therefore crippling a language to not use calls that other languages' implementations very clearly do isn't clever
12:40:18 <Philippa> it shafts the low-level languages that're otherwise supposed to be fast
12:40:57 <LordBrain> i dont see the problem, like Cale says, ailndx could implement his own user-space threads just for the app.
12:41:01 <ailndx> Philippa: that has nothing to do with crippling, you can do inline asm in C, but if you begin to write inline asm in a C test in school you will fail anyway
12:41:19 <SamB> ailndx: it might depend on various factors
12:41:32 <Cale> ailndx: I don't see your objection, are you even listening?
12:41:45 <SamB> if you could gather enough information about the testing harness, you might be able to determine that ASM would work
12:41:48 <ailndx> Cale: pretty much going out of the door to get a pizza
12:42:02 <SamB> but you don't need to write high-performance code for tests in school anyway
12:42:05 <Cale> I'm saying you write your own bloody threads for your app. Don't rely on the OS threads if you don't want to.
12:42:32 <LordBrain> i dont think haskell could really defeat C, if its optimized well enough.
12:42:46 <Cale> LordBrain: I think it could :)
12:42:53 <ailndx> Cale: well time wasting i got other stuff to do. But ive allready seen optimized code from both language and seen haskell been beeten
12:42:55 <LordBrain> that would be like defeating correctly optimized assembler
12:43:05 <LordBrain> from a higher level language
12:43:12 <ailndx> it one language is optimized code and the other aint there aint much point of a compare
12:43:15 <Cale> ailndx: You haven't seen it beaten in concurrency.
12:44:10 <ailndx> Cale: say what..? they were compiled on the same comp also
12:44:37 <ailndx> thought its true results wont be exactly the same for all kinds of tests or anything
12:44:59 <Cale> http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all -- look at this benchmark
12:45:01 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ...
12:45:18 <LordBrain> the problem is knowing all the expertise necessary to optimize correctly for the given archetecture, and at the same time doing all the extra work to implement a lot of things yourself that would have been done for you in haskell... thats why haskell is what i prefer, but i wouldnt say that from a theoretical point of view for a given haskell program that you cant write a c program that is just as fast or faster.
12:45:24 <Cale> GHC is taking 4.08s, and gcc is taking 54.02
12:45:43 <Cale> LordBrain: well, of course
12:45:58 <Cale> LordBrain: But a *reasonable* C program is another thing :)
12:46:04 <LordBrain> lol
12:46:04 <LordBrain> ok
12:46:32 <LordBrain> maybe
12:46:35 <Cale> Like, GHC can compile to C with similar performance results
12:46:52 <Cale> so obviously there exists a C program which runs about the same :)
12:46:53 <LordBrain> hmmmmmm
12:46:59 <LordBrain> yes
12:47:07 <SamB> but, it isn't portable C that GHC compiles to, is it?
12:47:20 <jer> many C programmers have libraries they've built up over years to do a lot of the stuff that haskell gives you though. (not arguing any side here, just saying that most developers don't start off from only what C gives you each time)
12:47:34 <LordBrain> but you think, for some programs, the C would have to be as complicated and strange to look at as that autogenerated output from teh haskell?
12:47:58 <Cale> jer: right, in this case, GHC's builtin threads beat pthreads hands down.
12:48:09 <jer> Cale, no question =]
12:48:14 <jer> Cale, but pthreads isn't too hot to begin with
12:48:35 <jer> so it's like saying that your dog can run faster htan my turtle... my turtle moves, but he sure as shit don't run =]
12:48:35 <Cale> yeah
12:49:08 <LordBrain> i sense that c is becoming higher level itself, as the compilers do more and more of the optimizing for people.
12:49:26 <reppie> LordBrain that doesn't make it high level.
12:49:29 <Cale> But really, and we are only starting to see this, I think that Haskell programs will outperform C programs because the compiler will have more information available to it for performing reductions and optimisations at compile time.
12:49:32 <LordBrain> hmm
12:49:32 <reppie> or even higher level
12:49:39 <LordBrain> doesnt it reppie?
12:49:48 <reppie> LordBrain no
12:50:02 <LordBrain> it used to be, you look at c, and you know exactly what the binary is going to look like... at least if you knew asm and stuff.
12:50:07 <jgrimes_> heh, look at the interesting alternative O'Caml for chameneos, it's pretty quick
12:50:13 <Cale> LordBrain: Higher level means that there are more abstractions present over the machine architecture while programming.
12:50:14 <LordBrain> thats what i call low level
12:50:18 <reppie> LordBrain that's still true.
12:50:42 <LordBrain> how can that be true if i dont even know what it will do to optimize?
12:50:52 <jer> LordBrain, turn off the optimizer
12:50:56 <LordBrain> yeah
12:51:02 <LordBrain> turn off the optimizer makes it low level
12:51:05 <Cale> reppie: yeah, that's because it uses its own entirely trivial implementation of threads
12:51:12 <LordBrain> hence, its higher level with the optimizer on....
12:51:16 <reppie> Cale ?
12:51:24 <jer> LordBrain, no, it makes it compile faster and produce object code which you can easily infer what it's going to look like
12:51:24 <LordBrain> at least the way i think of the term
12:51:31 <Cale> er, jgrimes rather
12:51:32 <Cale> sorry
12:51:38 <jgrimes_> Cale: yeah, I see that now
12:51:43 <jer> that does not make it any more or less low level than with the optimizer
12:52:14 <LordBrain> jer.. well, maybe i dont use the correct technical definition for you. But to me, if its less correlated to the output, that is at least one sense of the term higher level.
12:52:25 <Cale> I suppose that's true
12:52:50 <Cale> Though it's more like depth rather than height, in some sense :)
12:53:24 <Cale> However, there are certain things which are just ridiculous to attempt in C
12:53:26 <jer> LordBrain, i would classify that in the same context as classifying a language which has type coersions as being weakly typed.. not exactly accurate, but i suppose in some peoples view, perhaps
12:53:45 <Cale> The sorts of optimisations where you use algebraic properties of matrices, for instance.
12:53:58 <Cale> Matrix multiplication in C would be done with a loop
12:54:39 <Cale> and it's hard to tell, for instance, that if multiply(matrix_A, inverse(matrix_A)) comes up, that you're going to get an identity matrix.
12:54:55 <Cale> (say as the result of inlining)
12:55:14 <LordBrain> yeah
12:55:19 <LordBrain> i can see that
12:55:31 <Cale> Whereas in a language which has abstract matrices, this sort of thing can be optimised to nothing.
12:55:48 <LordBrain> yeah
12:56:26 <Cale> In Haskell (have a look at FPS/ByteString), we can do fusion tricks that you just can't even express to a C compiler.
12:56:33 <LordBrain> i definitely think there is more room for optimizations with the higher level of abstraction
12:56:35 <jer> hrmm.. interesting, optimized to a noop =D i think i might be able to build an optimizer which could do that =D
12:57:06 <LordBrain> automatic optimizations that is
12:57:15 <LordBrain> rather than handcoded...
12:58:39 <Cale> Handcoded optimisations are eventually impossible. They just don't scale, especially when you try to take machine architectures into account.
12:59:34 <LordBrain> you still need architecture experts somewhere... have them optimize ghc's output for us.
12:59:35 <Cale> Hand optimisation of assembler where you have to keep track of dependencies in a window of 150 instructions is ridiculous.
12:59:48 <LordBrain> lol
13:01:45 <Cale> Somewhat similarly, you could do some of these hand optimisations at a slightly higher level instead of making library calls, but as libraries get more complex, this gets more and more self-defeating.
13:02:04 <LordBrain> true
13:02:30 <Cale> You really need smart libraries which can tell the compiler "here's how to optimise me".
13:03:02 <Cale> (or rather, code written using me)
13:03:02 <ailndx> "[09:49pm] <Cale> But really, and we are only starting to see this, I think that Haskell programs will outperform C programs because the compiler" ... that isnt true, on one hand it can get more information, but it will also so information of exactly what you wanna do since you type less code the higher level you get
13:03:43 <Cale> ailndx: no, you're missing the point. Matrix multiplication, as in my example, is something which the high level language compiler knows how to do.
13:04:00 <Cale> So it can put that code back and extract the low-level program from the high-level one.
13:04:10 <ailndx> Cale: which a lower level language compiler also could know
13:04:13 <Cale> But you can't go the other way (at least not in any reasonable sense)
13:04:49 <LordBrain> no... a lower level compiler doesnt have those kinds of abstractions.. thats what makes it low level
13:05:02 <Cale> The low-level compiler isn't going to stare at a bunch of loops and say "hey, this is matrix multiplication!" and then write the high level code where the optimisation can be performed.
13:05:24 <ailndx> you could also make that code on your own for matrix multiplication
13:05:35 <Cale> You might be able to write one which catches some special cases, but in general, the problem is impossible.
13:05:51 <Cale> You're missing the point though. Completely.
13:06:03 <Cale> Have you ever even written a compiler?
13:06:14 <LordBrain> heh.. hasnt everone?
13:06:15 <ailndx> not really
13:06:18 <LordBrain> lol
13:06:21 <LordBrain> j/k
13:06:23 <SamB> haha
13:06:37 <SamB> I wrote a brainfuck compiler in Python
13:06:42 <ailndx> but i know pretty much of how they work
13:06:47 <SamB> it was very stupid
13:06:51 <LordBrain> lol
13:07:00 <xerox> Stoopid.
13:07:01 <ailndx> writing a compiler is just waste of time since there are allready good ones
13:07:05 <SamB> hahaha
13:07:25 <Cale> ailndx: Okay, so let's say I have a function defined like  f(A,B) = A * inverse(B), where A and B are supposed to be matrices.
13:07:54 <ailndx> Cale: yes..
13:07:56 <SamB> in some imaginary language with a type system that handles matrix multiplication properly
13:07:58 <Cale> and let's say that somewhere in my program, I have f(A,A) showing up, possibly as a special case of some iteration
13:08:16 <LordBrain> the point Cale is making... and i agree.. is that potentially, you can make many more optimizations in a langauge like haskell.. this is because besides the archetecture specific optimizations, you can actually recognize and optimize algorithms
13:08:19 <Cale> SamB: well, this is going to be code in multiple languages actually
13:08:25 <xerox> A * inv(a) = I ?
13:08:30 <Cale> xerox: yes
13:08:37 <xerox> Cool.
13:08:47 <SamB> so what does inverse(B) do when you call it on a matrix with no inverse?
13:09:24 <Cale> SamB: Well, good question :) It might be that in the high level language, we can assert that the matrix is invertible
13:09:30 <ailndx> and the point is true, it will be easier to recognize. but you also lack ability so put other performance specific stuff to the compiler
13:09:33 <SamB> hmm
13:09:36 <xerox> Good answer.
13:09:37 <Cale> Or have it recognise that fact
13:09:46 <xerox> That's computationally different :)
13:10:02 <monochrom> I know a researcher who has a language with a type system that handles matrix multiplication properly.  He knows how to generate fast code based on that too.
13:10:07 <SamB> how would it know, though?
13:10:10 <Cale> ailndx: Okay, so let's say that instead of matrix multiplication and inverse being known to the compiler, they're implemented as code in a library
13:10:16 <SamB> monochrom: interesting
13:10:24 <ailndx> Cale: sure
13:10:28 <Cale> Yeah, this stuff I'm talking about is actually doable
13:10:37 <ndm> is there a message box prompt in Gtk2hs?
13:10:43 <SamB> Cale: I dunno about that notation, though!
13:10:46 <ndm> I don't know what its called so can't find it :(
13:11:12 <ndm> I want to ask the user if they want to save or not, so just a yes no box
13:11:19 <Cale> ailndx: Then the compiler can do nothing more than potentially trying to inline the code. It won't know that the matrix multiplication function is really matrix multiplication, and it won't know any of its properties.
13:11:55 <Cale> ailndx: So it will totally miss the huge optimisation opportunity of turning an O(n^3) operation into an O(1) operation
13:12:01 <ailndx> "There are two types of programming languages; the ones that people bitch about and the ones that no one uses. -Bjarne Stroustrup"
13:12:11 <xerox> monochrom: that sounds like fun!
13:12:14 <monochrom> It would be krad to "I recognize you are doing bubble sort.  Let me generate n log n sorting code!"
13:12:52 <Cale> monochrom: hehe, better yet, why not just have the programmer write it as "sort", and have the compiler choose optimised code from a library!
13:13:17 <araujo> ailndx, i like the guy :-)
13:13:22 <ailndx> Cale: just put in some extra "if.." in the code
13:13:26 <ailndx> :)
13:13:29 <monochrom> 1st year students generally write their own bubble sort and linear search code.
13:13:30 <Cale> ailndx: but you can't
13:13:46 <Cale> ailndx: If there's an if there, you'll have to actually check that the matrix is the inverse of the other
13:13:57 <ailndx> why not, could can make a matrix class and you can check easily for these special cases to accour
13:14:04 <Cale> ailndx: Which takes as long as multiplying them, which is what you wanted to avoid.
13:14:17 <monochrom> "Real world" programmers generally don't get pass 1st year.
13:14:19 <Cale> So you lose the benefit of optimisation
13:14:33 <LordBrain> lol monochrom
13:14:55 <Philippa> monochrom: I had a habit of implementing linked list classes for Java in the middle of exams because I couldn't remember the interface for the version in the standard libraries
13:15:09 <Philippa> no more functionality than needed, of course
13:15:18 <Cale> ailndx: It *has* to be done at compile time, if it's done at all. Or you need a language in which functions are able to observe the expressions passed to them before they're evaluated.
13:15:22 <monochrom> Yes that's one usual reaction.
13:15:33 <madpickle> java addles your mind
13:15:34 <madpickle> it's quite normal
13:15:42 <madpickle> it's like eating ice cream, it numbs your mind.
13:15:49 <xerox> Cale, Lazy Evaluation?
13:15:57 <Philippa> I still want to go back and write up the substring search algorithm I wrote in my second year where you were allowed to partially evaluate based on the string being searched for...
13:15:58 <Cale> xerox: something stronger still
13:16:06 <Cale> That is, the matrix multiplication function would have to see that it's "A" and "inverse(A)" getting passed to it.
13:16:07 <Philippa> ...because since then, I have a much better high-level understanding of what I did
13:16:10 <xerox> Something possible, and stronger?
13:16:18 <monochrom> Nice
13:16:37 <Cale> and not just A and B
13:16:37 <Philippa> I thought the code was messy and was told it was good compared to most code doing anything non-trivial that year...
13:16:49 <monochrom> haha
13:16:57 <Cale> (where B happens to be inverse(A), but this information is gone)
13:17:50 <Philippa> oh, wait, it was one of a collection of substrings, with just a true/false response
13:18:54 <Cale> ailndx: do you see what I mean?
13:19:02 <Philippa> anyway, the implementation was just a degenerate DFA (always a tree) plus a bag with known maximum size in which the 'tokens' for positions starting from each place in the string that'd been fed to the NFA so far
13:19:17 <Philippa> bags have a nice low invariant count to maintain :-)
13:19:40 <xerox> In what language you did it?
13:19:43 <Philippa> and having a max size lets you do a lot in constant time - so I had the best asymptotic performance outright...
13:19:43 <Philippa> Java
13:19:48 <Cale> ailndx: This isn't something that you can just write into your C library, it needs compiler support. (Unless your C library implements, say, expression trees, at which point you're metaprogramming, making it a moot point)
13:20:33 <xerox> Cale, like python who's recently exposed the AST or something similar?
13:20:39 <Philippa> so the bag implementation was a done-by-hand linked list in the end IIRC (in hindsight, an array and swapping stuff with the end to delete would've been better), and the tree was tedious - especially as it was a 128-tree (7-bit ASCII charset)
13:20:46 <Cale> xerox: possibly, yeah, or like GHC's RULES
13:21:10 <ailndx> Cale: yes that you because of earlier recognision of an algorithm can predefine happenings at compile time, i dont really see that as a langauge feature though.. with some work..(maybe more) you could do that for c/c++ also. And this about matrix manipulation is a special case where we actually can do it.. but say you make up your own datatypes then the compiler will have no clue how to do it anyway
13:21:11 <xerox> RULES are so powerful?
13:21:21 <LordBrain> i think the highlevel functional compilers can make not only the optimizations that the lowlevel compilers make, but also a bunch of new optimizations that would be impossible.. And as the trend to rely more and more on compilers to do optimizing continues, and that trend is more and more a necessity do to complications of optimizing, you have more and more potential to have something like average haskell outperform average c (if it does
13:21:43 <Cale> ailndx: What I'm saying is that you can't do it in C/C++, unless those languages are modified in some pretty fundamental ways.
13:21:52 <Cale> (at which point they're not C/C++ anymore0
13:21:55 <Philippa> ailndx: not if your language is powerful enough to encode and take advantage of the invariants. Some are.
13:22:06 <LordBrain> whew.. that sentence just grew and grew.. sorry
13:22:36 <Cale> LordBrain: long enough to get cut off at "(if it doe"
13:22:50 <LordBrain>  (if it doesnt already)... (of course,
13:22:59 <Cale> yeah
13:23:00 <ndm> How would I get Gtk2Hs to put up a prompt "Do you want to save"?
13:23:01 <LordBrain>  (if it doesnt already)... (of course,
13:23:08 <LordBrain> ever and ever more "unreasonable" c will still be able to beat it...
13:23:17 <LordBrain> hmm i'm having trouble cut and pasting..
13:23:17 <ndm> i.e. alert/msgbox/messagebox in other programming api's
13:24:04 <ailndx> Philippa: thats not all to it
13:24:09 <SamB_XP> LordBrain: but, you'd need people who could deal with the output of a Haskell compiler ;-)
13:24:13 <Philippa> actually the C might not be able to - the abstraction gap between C and machine code might well contain sufficient room that it can't be made fast enough
13:24:15 <Cale> ndm: http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Windows-Dialog.html
13:24:21 <Philippa> ailndx: yes, you need to encode how to take advantage as well
13:24:25 <SamB_XP> and then they'd need to optimize it again every time you *changed* something
13:24:35 <ndm> Cale, thanks very much :)
13:24:49 <ailndx> Philippa: so a c compiler can output the same asm code as a haskell compiler teoretically
13:24:51 <SamB_XP> and that only works if you assume the Haskell compiler is going via C anyway
13:25:29 <Cale> ailndx: yes, and vice versa
13:25:31 <Philippa> ailndx: it's extremely hard to show that it can do for the same source stripped of those details that can't be expressed in C in all cases
13:25:32 <LordBrain> yeah
13:25:36 <ailndx> Cale: ofc
13:25:50 <LordBrain> we'd still need our archetecture experts
13:25:55 <Cale> right
13:25:57 <LordBrain> working in c and assembly
13:26:03 <Philippa> and Haskell isn't as expressive as it could possibly get when it comes to such things, either
13:26:35 <SamB_XP> LordBrain: indeed
13:26:43 <SamB_XP> someone obviously needs to maintain the RTS
13:26:54 <Cale> If your language just doesn't have a way to express invariants, there's no reasonable way that the compiler can be expected to prove them all for you and make optimisations on them.
13:27:02 <SamB_XP> and someone needs to maintain the kernel
13:27:06 <LordBrain> my brother has had this idea he keeps bouncing at me for a long time.. that optimizing should take place in the OS, so that each time you run a program, it having gained some profiling info for example, now makes a more and more optimized version.
13:27:10 <ailndx> Philippa: that goes both ways
13:27:34 <Philippa> ailndx: not as well as you think it does
13:27:35 <Cale> ailndx: hm?
13:27:41 <SamB_XP> LordBrain: wouldn't work too well for higher-level optimization...
13:27:45 <Cale> ailndx: what goes both ways?
13:28:05 <Philippa> though yes, Haskell as-is is missing some things that C can express. It's certainly possible to have a Haskell-flavoured language that can express all of C and more though
13:28:05 <LordBrain> SamB_XP: it could.. just have the os understand the high-level language
13:28:23 <ailndx> Cale: lack of ability to express stuff as the other language
13:28:24 <Philippa> LordBrain: *hah*
13:28:32 <LordBrain> :)
13:28:36 <Philippa> basically that amounts to having the OS privilege one or more languages
13:28:54 <SamB_XP> LordBrain: at that point your OS needs to be a Haskell compiler
13:29:00 <LordBrain> exactly
13:29:03 <Philippa> ailndx: statically, C is almost as unexpressive as it gets
13:29:03 <Cale> The assumption here is that you're compiling downward toward machine code, so if you start with a high level language, your compiler should be able to pass through a bunch of lower level languages where you'll have similar information as you would if the code had been written there.
13:29:09 <dylan> would something like that be possible in a JVM?
13:29:20 <ailndx> Philippa: wrong
13:29:35 <SamB_XP> anyway, Haskell takes too long to compile for that to be practical that way...
13:29:38 <Philippa> ailndx: show me a piece of C code that expresses a static property. Go on.
13:29:40 <Cale> Philippa is completely right.
13:30:22 <LordBrain> SamB_XP: yeah but thats mostlyl because we try to do all the optimizations the first time we produce a binary... but in this scenario, that wouldnt be necessary.
13:30:25 <SamB_XP> const char const* greeting = "Hello";
13:30:45 <Cale> About the only static information you have are C's types, which, due to casting, and unchecked array indexing, is hardly any information at all.
13:30:49 <Philippa> SamB: good example, and pretty much as powerful as it gets
13:30:51 <SamB_XP> LordBrain: also, you'd need to build for profiling!
13:31:18 <SamB_XP> and even *that* is only available in the same compilation unit
13:31:21 <LordBrain> yeah, but its no biggie to have a means to disable it.. to improve performance if need be
13:31:21 <Philippa> C can accurately express information about constants that can be evaluated at compile-time. That's pretty much /it/.
13:31:57 <LordBrain> once its profiled, and compiled and you've used it a couple of times, you can just disable the optimizing and use what you got.
13:32:42 <ailndx> Philippa: just to make a kids example say you get one line to express stuff that should qualif for a present that you want, "red", "round", "something that has to do with water" and so on.. the more you write is a factor(notice factor.. you can always more more good or less specifications) that reduses the result to narrow down the the percentege you will get a present you dont want. Same with Code, the more you use the more you can narrow
13:32:47 <ailndx> it down to do exactly what you want
13:33:44 <Philippa> ailndx: why are you telling me this?
13:33:49 <Cale> ailndx: the problem is that instead of writing useful information about what you want, you might be writing things which the compiler can figure out anyway
13:33:57 <Philippa> Cale: *might*?
13:34:01 <Cale> hehe
13:34:06 <ailndx> Philippa: cause it has something to do with low vs high level
13:34:12 <Philippa> worse yet, you might be forced to write down things that get in the compiler's way in order to say what you want
13:34:16 <Philippa> ailndx: no it doesn't
13:34:42 <ailndx> Cale: sure, but then if it figures it out you get a more general result
13:34:47 <Philippa> it has jack shit to do with high and low level, it's entirely about precision of specs. The thing is, there's practically bugger all you can specify statically in C in the first place
13:34:52 <ailndx> Philippa: it odes
13:35:06 <Philippa> so there's no spec to start with
13:35:14 <boegel> Itkovian: ping! (pm)
13:35:29 <ailndx> the spec to start with is the standard of the language
13:35:37 <ailndx> thats the tool
13:35:46 <Cale> ailndx: Look at this example in Haskell, I can write a function which calculates, say, the length of a list, and I can give it a type signature, like  length :: [a] -> Integer.  The 'a' there is a type variable, it means that any type of data will work. The compiler will guarantee that length does not inspect the actual elements of the list.
13:35:54 <Philippa> that might be the spec you're starting with, the rest of us aren't writing C compilers
13:36:20 <ailndx> Philippa: rest of us.. who does, but some people use them
13:36:26 <Cale> Try giving a C function for calculating the length of a list a type that expresses that it doesn't look at the elements of the list.
13:36:39 <Philippa> ailndx: the rest of us're interested in what we can specify about the programs we're writing
13:36:41 <Cale> (and the compiler has to check it)
13:37:11 <Philippa> in C, the grand total that can be specified and read off without running the program or something pretty close to it is the type of a constant
13:37:14 <ailndx> Philippa: that has nothing to do with the rest of us, thats pretty much to everyone
13:37:17 <Cale> Also, since the compiler knows that length won't look at the elements of the list, perhaps this sort of information could be used to optimise things.
13:37:31 <Cale> If Haskell wasn't already lazy, for instanc
13:37:56 <Cale> It would know that it wouldn't necessarily need to calculate those elements, if all it wanted was the length.
13:38:00 <Philippa> that can still be used by some Haskell implementations - a strictification in stages, say
13:38:05 <Philippa> (which'd be of benefit to the GC)
13:38:10 <Cale> yeah
13:38:15 <ailndx> Cale: what do you mean. count the length of a list with a nonyetspecific kind of elements?
13:38:17 <SamB_XP> Philippa: I bet the compiler is allowed to assume that that greeting I defined above won't change, too...
13:38:27 <Cale> ailndx: yeah
13:38:38 <Philippa> SamB: is nominally part of the type of the constant, right? :-)
13:38:45 <ailndx> Cale: np, that depends on the allocator.
13:38:47 <SamB_XP> is it now?
13:38:54 <Cale> ailndx: and have the compiler guarantee that the function doesn't look at the elements
13:39:09 <SamB_XP> I mean, is the string literal really part of the type?
13:39:17 <Philippa> no, but the const specifier is
13:39:18 <Cale> like, for example, it doesn't just take the first one, cast it to an integer and return that
13:39:19 <ailndx> Cale: what does it hurt to look at one element?
13:39:40 <SamB_XP> but, I mean, it can assume that the constant will have the value given, as well as being constant
13:39:41 <Cale> ailndx: It's an additional guarantee of correctness.
13:39:42 <Philippa> and by equality that's the type of the string literal
13:39:58 <Cale> ailndx: and it's useful information in detemining possible optimisations
13:40:01 <Philippa> point
13:40:02 <ailndx> Cale: correctness, how could it be wrong..
13:40:23 <Cale> ailndx: It could take the first element of the list, cast it to an integer, and return that.
13:40:30 <Cale> (in C)
13:40:32 <Philippa> because you've no reason to look at hte element, so doing so gives additional scope to fuck up
13:40:44 <Philippa> just like the more I type, the more tyops creep in
13:41:08 <Philippa> in a lazy language you might also want to prove it doesn't force the elements because that affects termination
13:41:09 <Cale> of course, that would be an atrocious bug, but it's something the compiler should be able to catch
13:41:13 <LordBrain> in haskell it could hurt to look at the element, because it would mean evaluating it to find out what it is... in C, you'd probably just have a pointer anyway and you wouldnt have to follow it, so this isnt necessarily the best example.
13:41:37 <Cale> LordBrain: you wouldn't have to follow it, but nothing would be stopping you
13:41:46 <Cale> that's the point I'm trying to make
13:42:05 <ailndx> nono, in C++ for example there are allready STL types for lists, same as they are defined in haskell. There are allready length function and so on for it. But if you want to.. you got the ability to specify and make your own lists also
13:42:08 <Philippa> the parametricity of lists in Haskell means that there's only two places you could get the result of a length function from: the structure of the list and a constant
13:42:24 <SamB_XP> perhaps the qsort function in the library is a nice example of where the type system helps you out?
13:42:38 <Cale> ailndx: however, in C++ even with templates, you don't get the guarantee I'm talking about
13:42:55 <SamB_XP> that is, the qsort function in the C library is a good example of where a HM-style typesystem *would* help you out
13:42:58 <LordBrain> is Data.ByteString a type of home made list?
13:43:00 <Cale> You're still allowed to take your T* and cast it to an integer.
13:43:19 <LordBrain> i'm not really clear on that
13:43:35 <Cale> LordBrain: It's a pointer to a contiguous block of memory
13:43:41 <ailndx> Cale: so.. dont do if you dont need to
13:43:46 <LordBrain> yeah but in terms of haskell, it has a list interface right?
13:43:55 <Cale> ailndx: argh, you're not listening again
13:43:58 <LordBrain> or no?
13:44:02 <LordBrain> i've not worked with it yet
13:44:13 <Philippa> Cale: no, he's doing worse. He's presuming we've nothing to say
13:44:17 <Cale> LordBrain: The library implements functions with the same names as the usual list functions.
13:44:29 <LordBrain> yeah i see
13:44:35 <ailndx> Cale: no cause there are more to add to this than you are adding, optimizing lists still has to do with allocatiors for example, you can optimize them for different stuff
13:44:42 <LordBrain> thats basicly equivalent in my mind to using STL and making a new List type
13:44:51 <LordBrain> since it gave the interface
13:45:07 <Cale> ailndx: Yeah, and I could say things about that, but this is just one simple example, and you don't seem to be getting the picture.
13:45:20 <Philippa> ailndx: so we build a regions monad and a list-inna-region type and go to town. What else is new?
13:45:20 <LordBrain> ailndx: are you a regular here?
13:45:39 <Cale> ailndx is DreadShoot
13:45:39 <ailndx> Cale: well im a bit busy getting the pizza into the mouth atm :)
13:45:41 <LordBrain> just curious
13:45:42 <Philippa> oh, incidentally: we can use that typing to cure dangling pointer issues at the same time
13:46:02 <ailndx> no im not a regular in here
13:46:06 <LordBrain> oh
13:46:23 <LordBrain> do you like to program in haskell?
13:46:47 <Cale> no, he mostly likes to complain about how C is "better" ;)
13:46:47 <ailndx> I can see its adventages sure, but i havent spent much time into it
13:47:00 <ailndx> naah, just bugging with Cale a little :)
13:47:00 <Cale> you really should try it
13:47:13 <Cale> You'll get a better idea of what we're all trying to say here
13:47:30 <Philippa> you're probably not familiar enough with type theory, modern optimisation techniques etc etc to see much of the point of what we're saying here atm
13:47:48 <Cale> And don't assume that we don't know what we're talking about. I spent a lot of time programming in C and C++ too.
13:47:53 <LordBrain> yes
13:47:57 <Philippa> (make that: modern optimisation techniques for compilers)
13:48:05 <LordBrain> c++ i'm more familiar with than haskell even, but already i prefer haskell.
13:48:14 <ailndx> Philippa: im fairly familiar with it and also listen to several people who has this as a job
13:48:17 <Philippa> yeah, I ended up coding in Haskell constantly in the end after I blew C++'s abstraction ceiling
13:48:52 <Philippa> so if I talk about System F or the Calculus of Constructions, you know how to characterise them in relation to the simply-typed lambda calculus, stuff like that?
13:49:25 <Cale> Philippa: ;)
13:49:27 <Philippa> I can't see how someone familiar with the Curry-Howard isomorphism'd claim C's significantly statically expressive
13:49:29 <sylvan> lol
13:49:54 <Philippa> (note: I wrote C and not C++ for a reason - C++ is merely statically confusing)
13:50:14 <ailndx> obviously but we were talking about C/C++
13:50:34 <Cale> C++ has a few more static guarantees, but not too much
13:50:54 <int-e> . o O ( C::operator++<is, slightly, confusing>(int) )
13:50:55 <Philippa> sorry, what's "obviously"?
13:51:03 <sylvan> we should have a FAQ about these things.. I mean, some of this is subjective, but major parts of these arguments are just a matter of "wrong" vs "right"...
13:51:07 <LordBrain> anyway, i got that sense ailndx, when you were talking, that you really might think differently if you had more experience with haskell.
13:52:50 <int-e> Cale: Stroustrup doesn't believe in static guarantees. He wants pure expressive power, even if it means providing a Turing complete language on the compiler level.
13:53:06 <int-e> Cale: oh, and an ugly syntax. But who cares about that?
13:53:24 <Philippa> pure "presence-of" expressive power, perhaps. Expressing absences in C++ is hard
13:54:07 <edwardk> int-e: template metaprogramming gives you that =)
13:54:08 <LordBrain> this is not to say necesarily that c isnt currently faster or more optimized and so on, but when it comes to potential... i see a lot of potential in haskell, that just isnt there in c.
13:54:13 <int-e> edwardk: I know
13:54:20 <ndm> @seen dcoutts
13:54:21 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 1 hour, 33 minutes and 19 seconds ago.
13:55:08 <dcoutts> @yarr!
13:55:09 <lambdabot> I'd like to drop me anchor in her lagoon
13:55:14 <dcoutts> oh how rude!
13:55:22 <ndm> dcoutts: i have a new sample, give me a second to commit it
13:56:00 <ndm> dcoutts: pull!
13:56:34 <LordBrain> in otherwords, there is like a writing on the wall, that even if something like haskell doesnt really outperform "reasonable" c, yet, its only a matter of time... at least thats how it looks to me.
13:56:36 <ndm> its a faux text editor, new starts a new document, close shuts it, save as changes it to unmodified
13:56:47 <ndm> there is a word count in the status bar, 2 lines of code :)
13:56:51 <dcoutts> nice
13:56:58 <ndm> and the titlebar shows the filename and modified state
13:57:10 <ndm> any thoughts about the direction its taking?
13:57:20 <LordBrain> at least for non-trivial programs
13:57:41 <ndm> its a very simple interface - objects have properties, variables (get/set/notify) and events (notify)
13:57:59 <ndm> you then just hook them up, as you feel like
13:59:20 <dcoutts> ndm, looks good
14:00:01 <LordBrain> SamB_XP: the particular machine already does give preferences to some languages... its assembly language has special status after all.
14:00:14 <sylvan> LordBrain, I think you're spot on. Optimizing for modern CPUs is difficult, and will probably become even more so. It seems inevitble that languages that can offer the compiler som information about the *meaning* of the program (e.g. types) would preset more opportunities for optimization than low-level languages and thus produce code that runs faster
14:00:31 <monochrom> "Real world programmers" first say academics should not talk about software development because they haven't done it.  Then they proceed to talk about code optimization and performance while they have not done it.
14:00:47 <SamB> did I complain about the kernel giving preferential treatment to Haskell? no. I merely claimed that it would need to embed a Haskell compiler.
14:01:22 <Philippa> I suspect the ideal language to give preferential treatment to is some variant of the Calculus of Constructions
14:01:36 <Philippa> plus a crapload of built-in types describing properties of the underlying system
14:01:49 <int-e> edwardk: although what I had in mind was an article about how concepts are not like Haskell type classes, because the type classes are too restrictive.
14:01:56 <Philippa> (including, at a pinch, the machine language itself)
14:02:06 <dcoutts> ndm, so these withN things, whenever the state of them changes it recalculates the value using the user's functon
14:02:20 <dcoutts> ndm, that's the bit that generalises to arrows right?
14:02:21 <edwardk> int-e yeah
14:02:22 <ndm> dcoutts: yep
14:02:27 <Philippa> int-e: I've not looked at the proposals lately, what're the significant differences?
14:02:39 <ndm> dcoutts: no idea about arrow generalisations though - i'm not really that sure about them
14:03:33 <ndm> the underlying event/variable mechanism is quite complex...
14:04:53 <dcoutts> aye
14:05:05 <LordBrain> SamB_XP: well, thats not necessarily true.. you could get all the same effect using a special sort of interpretter when necessary... i think.
14:05:46 <SamB> LordBrain: it comes out to at least as much trouble, if not more
14:05:55 <edwardk> phillipa: a c++ contract doesn't actually force the type to implement a particular function with any particular signature. it relies on the fact that c++ function names take on meaning based on their context and so if you use them in a template, and the template is instantiated in a place where those functions have meaning, the result is you call the appropriate function on the template.
14:06:07 <SamB> also, you'd have profiling overhead
14:06:19 <SamB> which can be pretty considerable for good Haskell profiling
14:06:27 <edwardk> so a c++ 'concept' is more of an informal contract used in lieu of structural typing more or less
14:06:32 <SamB> and probably affects O() too
14:06:55 <Philippa> edwardk: as per the standards proposals? I know the situation in the existing standard...
14:06:57 <ndm> dcoutts: any recommendations for a paper on arrows?
14:07:12 <ndm> am off home in a few mins, might as well have a bit of light bed time reading :)
14:07:18 <Philippa> because if a C++ concept doesn't actually do anything, all I can say is *yuck* - it's just a sugared comment, no?
14:07:20 <dcoutts> I think a development on fran was arrow based
14:07:36 <LordBrain> SamB: yep, but you could think of it this way... as a programmer you might choose to use an interpretter to speed development anyway, the only difference here would be the first couple of times the user uses your program its interpretted, and then after a while you remove the overhead creating a truely compiled version.
14:07:37 <Philippa> all the yampa stuff is good
14:07:42 <edwardk> well, boost has a concept checking library, dunno if its standards track though
14:07:46 <dcoutts> so check for later papers by the fran chaps
14:07:51 <ndm> I just showed the code of my mini-text editor to a C hacker in my office, he was very very impressed :)
14:07:59 <dcoutts> :-) good!
14:08:01 <ndm> he still goes crazy when I show him quickSort though
14:08:05 <Philippa> edwardk: I know some notion of concepts is/was supposed to be, at least
14:08:05 <dcoutts> hah
14:08:22 <edwardk> currently its not even got sugar =)
14:08:54 <Philippa> it'd be nice to have concise "good" quicksort implementations to show - one in-place using mutable arrays, one not
14:09:26 <edwardk> the boost concept mechanism enforces that the contract is met by letting you write a witness function that forces the appropriate members to be present, but you can't do much with it
14:09:52 <Cale> dcoutts: what should I do about this error? Can't locate XML/LibXML.pm in @INC (@INC contains: /etc/perl /usr/local/lib/perl/5.8.8 /usr/local/share/perl/5.8.8 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.8 /usr/share/perl/5.8 /usr/local/lib/site_perl /usr/local/lib/perl/5.8.0 /usr/local/share/perl/5.8.0 .) at ./gapi_parser.pl line 23.
14:10:11 <dcoutts> Cale, install the perl LibXML lib
14:10:40 <dcoutts> on gentoo it's dev-perl/XML-LibXML
14:10:45 <edwardk> wow, that was a reply worthy of an eliza bot dcoutts =)
14:10:46 <Cale> I tried using cpan to do it, but it didn't affect anything. I'll see if debian has a package
14:10:53 <edwardk> well, not after the elaboration
14:11:03 <dcoutts> edwardk, heh :-)
14:11:43 <dcoutts> Cale, one other thing: you need haxml-1.12. It will not work with 1.13 :-)
14:12:20 <dcoutts> I tried updating it but they changed the bahaviour too much, apparently the fixes I requested might be in the next haxml release
14:12:27 <dcoutts> so for the moment you need 1.12
14:12:51 <Cale> okay
14:13:07 * edwardk sits on his hands hoping the ecma4 working group sees things his way so he can have a fast javascript runtime environment.
14:13:50 <edwardk> (trying to clarify/simplify/change the semantics of eval for some border cases)
14:15:37 <SamB> edwardk: did you send them an email?
14:15:42 <edwardk> yah
14:16:03 <SamB> okay, because I don't think they are very telepathic ;-)
14:16:21 <SamB> hmm, which Wesnoth mission should I try...
14:16:25 <SamB> er, campaign...
14:16:25 <edwardk> gave a nice long formal justification, showed that the current cases weren't consistently implemented and that my way would help the compiled flavors without adversely affecting anyone
14:16:39 <edwardk> except the fact that its counter to the way that jscript.net does it
14:16:54 <edwardk> but works with identical side effects to the way that mozilla does it
14:17:07 <Cale> SamB: hehe, every time I open Wesnoth, it looks 10% more professional
14:17:18 <edwardk> and is more favorable for the way opera and adobe want to view the language
14:17:26 <edwardk> so with luck, that should get enough weight behind it =)
14:17:56 <SamB> UtBS has huge maps
14:18:09 <SamB> it kills my CPU/RAM
14:18:35 <edwardk> and it happens to mean that i can safely elide the construction of the fairly bloated lexical scopes that javascript uses in about 98% of my functions.
14:18:49 <SamB> they are very nice looking (though the help needs work, as some "special" unit types appear in the index)
14:18:55 <edwardk> so when its compiled down to haskell it might actually be fast
14:19:04 <SamB> also, sorting unit types in alphabetical order is not the best way to list them
14:19:24 <SamB> (in the help file)
14:19:38 <dmhouse> When a perl script does something like $self->{edit}->{date}, what does the curly braces mean?
14:19:57 <SamB> dmhouse: why ask here?
14:19:59 <edwardk> curly braces mean to look it up in the hash
14:20:22 <dmhouse> SamB: I like the people here :)
14:20:29 <Cale> SamB: wow, the castles and docks look so much better now.
14:20:32 <dmhouse> If it turns out to be complicated I'll go RTFM and learn some peopl.
14:20:35 <dmhouse> *perl.
14:20:40 <edwardk> -> dereferences. so its looking in a hash reference for a key named edit, then treating that as a hash reference and looking in that for date.
14:20:43 <vincenz> re
14:21:01 <SamB> Cale: would you believe I totally didn't notice?
14:21:13 <Cale> SamB: hehe :)
14:21:16 <SamB> I did notice everything looks really nice
14:21:18 <edwardk> as oppose to $self{edit}{date}  which looks in a hash (not a hash reference) for edit, then treats the result as a hash reference and looks in that.
14:21:40 <Cale> SamB: They still need some more music though.
14:21:42 <SamB> but I was playing UtBS so I was unable to tell how much of that was added and how much was basics
14:21:49 <SamB> oh, yes, music is quite repetetive
14:22:07 <dmhouse> edwardk: So $self->{edit} means $self is a reference to a hash table, and that looks up the key 'edit' in said hash?
14:22:11 <SamB> they should do something more complicated with that
14:22:11 <Philippa> UtBS?
14:22:13 <edwardk> yep
14:22:17 <SamB> Under the Burning Sons
14:22:24 <dmhouse> edwardk: Great. :)
14:22:25 <SamB> a Wesnoth campaign
14:22:32 <SamB> er, Suns
14:22:39 <SamB> hehe
14:23:01 <edwardk> note that after the first {} any '->'s can be skipped. since you can only store scalars (which are strings, numbers and references) in a hash, so ....{foo}{foo} == ....{foo}->{foo}
14:23:02 <SamB> hmm, some of these story thingies look bad in spots...
14:23:49 <edwardk> dmhouse: note that perl6 will change all that, making it a lot less weird
14:25:30 <SamB> the art is fantastic at beginning of Heir to the Throne
14:27:11 <int-e> Philippa: actually concepts are a proposed language extension. see http://www.research.att.com/~bs/n1782-concepts-1.pdf for example. the claims with respect to haskell type classes are two-fold, 1st, he claims that C++ templates are enough to model them (which is true up to a point. you will have trouble expressing the restrictions of the type class system, but Stroustrup thinks these restrictions are a weakness anyway) and b) the concepts (wh
14:27:11 <int-e> ich describe class interfaces, but can also express other restrictions; the details are unclear to me) are something entirely different.
14:27:32 <BCoppens> sho
14:27:40 <BCoppens> erm, wrong chan
14:27:42 <int-e> Philippa: I had to look that paper up, otherwise I'd have replied sooner :)
14:28:53 <edwardk> ahh
14:29:00 * edwardk eats crow =)
14:29:37 <int-e> Philippa: anyway, I don't blame him for his arguments. concepts seem to have the potential to make C++ a somewhat saner language if they're used carefully.
14:29:53 * edwardk nods.
14:30:15 * SamB would like to make a joke about how they ever got along without concepts
14:30:32 <edwardk> heh, just needs to learn to spell Random
14:30:41 <edwardk> samb: please, feel free ;)
14:31:17 <SamB> Well, okay. So, how did they ever write anything without concepts?
14:31:22 <edwardk> =)
14:31:41 <Philippa> int-e: notably, he only compares to single-parm typeclasses...
14:31:44 <SamB> I mean, with no concepts... how do you even have anything to write?
14:32:21 <edwardk> exactly, now that they have concepts they can write MORE code that does nothing. =)
14:33:39 <SamB> Cale: is it just me, or does Konrad have more hair?
14:33:54 <monochrom> f1 :: (Num a) => a -> a -> a; f1 x y = x+x*y
14:34:26 <edwardk> heh, I've only been through about a month of haskell therapy, and yet looking at C++ makes me feel dirty.
14:34:31 <monochrom> In Haskell, the type signature of f1 (Num a) already tells you some requirements on 'a'.  You need not look at the code.
14:34:56 <vincenz> hi
14:35:04 <vincenz> anyone know how to call canada with skype?
14:35:31 <edwardk> never tried
14:36:13 <monochrom> In C++, at present, you can only translate to: template<clase T> T f(T,T)  (I forgot the exact syntax).  The type signature does not say anything.
14:36:13 <norpan> canada has the same country code as the us
14:36:18 <norpan> so +1 number
14:36:43 <vincenz> norpan: it automatically fails
14:36:52 <norpan> it fails?
14:37:05 <vincenz> yeah
14:37:06 <vincenz> call failed
14:37:17 <vincenz> too fast for it to be able to check the carrier
14:37:18 <monochrom> There are implications on the quality of error messages too.
14:37:36 <vincenz> oh well
14:37:38 <vincenz> I'll use my cell
14:37:41 <vincenz> :/
14:37:45 <edwardk> they must just have the NPAs for america in it then, not the entire north america number plan.
14:37:45 <vincenz> that'll cost me shitloads
14:37:56 <norpan> but other numbers work?
14:38:00 <vincenz> yeah
14:38:01 <monochrom> The new C++ "concept" is supposed to fix that, isn't it?
14:38:10 <int-e> monochrom: yes.
14:38:15 <edwardk> monochrom: looks that way
14:38:31 <monochrom> To be fair, I admire the syntax of defining a C++ concept.
14:39:18 <monochrom> Anyway, before there were concepts, C++ programmers just live with the absence of "(Num a) => ..."
14:39:22 <vincenz> :(
14:39:24 <vincenz> no answer
14:39:53 <edwardk> cout << x in the one concept doesn't make any sense to me, cout isn't a class, shouldn't that be an ostream?
14:40:05 <edwardk> p.15
14:40:19 <emertens> cout is an instance of ostream
14:40:22 <monochrom> (And marvel at the elaborate error messages produced when T does not support + or * )
14:40:49 * vincenz blinks
14:40:52 <vincenz> is this ##C++?
14:41:03 <edwardk> emertens: yeah, just seems odd to name an instance of a class to describe the signature of something like that
14:41:22 <monochrom> (In Haskell you just get "no instance for Num T".  Short and sweet and to the point.  I personally prefer it.)
14:41:29 <emertens> edwardk: << isn't defined on cout tho... it's defined on ostream
14:41:43 <edwardk> emertens: because they are using it to say that the concept should support output to ostreams
14:41:51 <edwardk> emertens exactly =)
14:42:05 <emertens> Oh, I guess I haven't read the link you must have posted earlier
14:42:09 <int-e> vincenz: Haskell is the refuge of many people who've seen too many bad computer languages ;)
14:42:21 <monochrom> Hey in Haskell we do that all the time!  We define Functor just for one single method fmap!
14:42:24 <vincenz> int-e: amongst other things :((
14:43:19 <emertens> monochrom: one function implemented by many types tho...
14:43:41 <emertens> assuming you are relating that to the cout example
14:43:42 <monochrom> "cout << x"  is to be implemented by many types of x.
14:43:50 <monochrom> Yes I'm relating to that.
14:44:04 <monochrom> Perhaps s/by/for/
14:44:14 <emertens> someone send me this concepts page so I can see this new use of concepts
14:44:15 <vincenz> I thought we'd get some more crud today for the icfpc
14:44:34 <emertens> I'm obviously thinking of this in terms of the current way
14:45:00 <monochrom> A concept for "cout << x" is similar to a typeclass for Show.
14:45:30 <emertens> That's a quote from the page?
14:45:39 <monochrom> That's a quote from me. :)
14:45:44 * vincenz kicks the nearest person
14:45:51 <edwardk> main thing i find strange about haskell type classes is because of the way they are built its not readily possible to define 'member functions' for them with the same name and totally types like you can C, so you wind up having to qualify a lot of names if you have multiple functions with names like 'new'
14:46:09 <shapr> SamB: UtBS?
14:46:16 <shapr> SamB: Under the Burning Sun?
14:46:27 <SamB> shapr: Suns
14:46:30 <SamB> plural
14:46:43 <shapr> Never heard of it.
14:46:52 <SamB> 'tis a Wesnoth campaign
14:46:52 <Philippa> edwardk: letting the module name act as a qualifier works
14:47:11 <emertens> so why is it better to write stream operators specific to cout than ostream?
14:47:21 <emertens> rather ^
14:47:47 <edwardk> philippa: yeah, but the whole point of that statement was that i have to qualify a lot of names =)
14:48:14 <Philippa> I really can't say I see it as that big a problem, although I should take a look at where the superclassing proposals went sometime
14:48:22 <edwardk> i accept the fact that it works, just find it quirky
14:48:23 <vincenz> edwardk: new is an OO concept
14:48:29 <vincenz> edwardk: it makes little sense with TCs
14:48:41 <norpan> edwardk: what is it that you want?
14:48:41 <edwardk> and makes giving functions nice names awkward
14:49:00 <norpan> ad-hoc overloading?
14:49:39 <monochrom> by "cout << x" I really mean "os << x".  Arbitrary ostream& os.
14:49:52 <shapr> SamB: Oh
14:49:53 <norpan> in c++ you write new Object(), in haskell you'd write newObject (or similar)
14:49:58 <edwardk> vincenz: well, the example at hand would be a bunch of different data structures provide some form of lookup functionality, etc. it gets kind of frustrating to all of a sudden lose compositionality when i go to merge two modules that each used different structures. now i wind up having to qualify half of the names or explicitly state that i'm hiding x y and z from the prelude
14:50:34 <vincenz> edwardk: well typically methods imply some common outer semantis, at which point they should really be in the same typeclass
14:50:54 <vincenz> erm
14:50:58 <vincenz> methodnames/functionames
14:50:59 <vincenz> names
14:51:00 <edwardk> sure, but the prelude ones are already there and gobble up a lot of good names =)
14:51:04 <vincenz> well
14:51:11 <norpan> i'm all for a smaller prelude
14:51:13 <vincenz> I've been arguing that all the list funcs should be methods
14:51:19 <vincenz> I'm all for a typeclassed prelude
14:51:19 <norpan> and a list class
14:51:24 <vincenz> norpan: sequence
14:51:28 <edwardk> yeah
14:51:30 <vincenz> list is one instantiation
14:51:34 <norpan> sequence, list, whatever
14:51:39 <vincenz> not whatever
14:51:43 <vincenz> list typically implies O(N) access
14:51:49 <norpan> *linked* list does
14:51:52 <vincenz> no
14:51:56 <vincenz> linked list has no meaning
14:51:58 <vincenz> unless you say
14:51:59 <vincenz> siingle linked
14:52:01 <vincenz> or double linked
14:52:02 <norpan> bah
14:52:08 <monochrom> list typically implies [a]
14:52:30 <Philippa> vincenz: sure it does, it means one of the two. Usually singly-linked unless specified though
14:52:32 <norpan> well, the name is not important
14:52:43 <vincenz> monochrom: in FPL yes but if you do a study of data-structures over moer languages, you'll see that list implies O(N) access, O(1) insert
14:52:46 <edwardk> well i'd go and do the legwork to typeclass it and put it together, but not sure anyone would actually adopt it
14:53:00 * vincenz has done a study of the stdlibs of several different languages
14:53:07 <vincenz> the proper terminology is sequence
14:53:42 <norpan> http://norpan.org/~martin/StringClass.hs
14:53:54 <norpan> supbstitute List for Sequence to please vincenz
14:54:04 <edwardk> heh
14:54:09 <vincenz> I'm in a pissy mood
14:54:21 <norpan> of course, it requires multi-param
14:54:27 <norpan> and fundeps
14:54:29 <vincenz> norpan: yeah, same as edison
14:54:36 <edwardk> hrmm
14:54:45 <vincenz> that's why edison never got stdized
14:54:52 <vincenz> and may now be superceded by jyp's library
14:54:54 <vincenz> just cause of timing
14:55:23 <vincenz> anyone know how to turn off an ipod that won't turn off
14:55:40 <norpan> having the prelude list class multi-param is not strictly neccessary
14:55:43 <norpan> but nice
14:55:54 <dmhouse> I dislike type classes.
14:55:55 <norpan> sorry *sequence*
14:55:59 * dmhouse ducks
14:56:03 <vincenz> norpan: I doubt that will happen before haskell'
14:56:08 * norpan ducks too
14:56:25 <vincenz> norpan: yeah sorry for being such a hardass... it's just that I'm ... well I'm dealing with a shitload of stress
14:56:29 <norpan> well, haskell' is around the corner
14:56:49 <norpan> most of it already in ghc
14:56:58 <vincenz> :/
14:57:05 <dmhouse> It's just... if you have a library of functions, and suddenly someone wants them to work on some other type they've developed, I just think the answer 'stick everything in a typeclass' is decidedly inelegant.
14:57:14 <norpan> dmhouse: yes
14:57:24 <dmhouse> norpan: Yes, Haskell' is mostly just a collection of already-implemented techniques.
14:57:28 <vincenz> dmhouse: list has a lot of stuff that -should- be tc'd tho
14:57:33 <vincenz> dmhouse: like folding and unfolding for any sequence type
14:57:38 <vincenz> or even BS and LBS
14:57:44 <dmhouse> vincenz: Right. Hence Data.Traversable.
14:58:01 * vincenz kicks another person
14:58:09 <dmhouse> Break it into little bits, then use a class alias (who _really_ need an implementation, by the way) to cover them all.
14:58:15 <dmhouse> vincenz: Are you going to the GHC hackathon?
14:58:18 <vincenz> dmhouse: class alias will rock
14:58:19 <vincenz> dmhouse: too far
14:58:25 <dmhouse> Aww, that's a shame.
14:58:26 <vincenz> dmhouse: and I have a paperdeadline by 10sept
14:58:31 <vincenz> yeah I know
14:58:37 <vincenz> I'd like to add class aliases to ghc
14:58:40 <vincenz> but I don't know the structure of ghc
14:59:33 <dmhouse> Talk to shapr, he's just exploring for the first time, I believe.
15:01:02 * xerox eats honey
15:01:56 * vincenz doesn't make the obvious comment
15:02:28 <norpan> class alias
15:02:42 <norpan> like bunching together several classes into one name?
15:02:47 <vincenz> sorta
15:02:50 <norpan> so that you could have one class for each method
15:02:55 <edwardk> class aliases like being able to make an alias for an equivalent class with fundeps so you don;t carry all the values around? or like norpan said
15:03:18 <vincenz> google for class aliases
15:03:25 <norpan> but would you then have to pass a shitload of dictionaries?
15:03:34 <vincenz> @google class alias haskell
15:03:36 <lambdabot> http://repetae.net/john/recent/out/classalias.html
15:03:37 <lambdabot> Title: Class Alias Proposal for Haskell
15:03:42 <norpan> hey
15:03:48 <norpan> yes sir, i can google
15:04:00 <emertens> but I'm lazy
15:04:05 <emertens> so thanks :)
15:06:08 <norpan> sounds like what i said
15:06:47 <dmhouse> norpan: You could combine them into one dictionary if you had C c => ..., where C is a class alias.
15:06:59 <norpan> yeah
15:07:29 <vincenz> they're just great
15:07:34 <vincenz> saves a lot of hassle
15:07:39 <vincenz> which makes making smaller tc's much easiier
15:07:42 <edwardk> ok, so the major benefit of this if i get it straight is instead of typing instance (Foo a, Bar b, Baz a b) => FooBarBaz a b c
15:07:51 <vincenz> not only
15:07:56 <edwardk> you can create a class alias and then people can fill in the where clause of your alias
15:08:11 <edwardk> instead of filling in 3 where clauses?
15:08:15 <norpan> yeah, it works backwards too
15:08:32 <vincenz> edwardk: yep
15:08:35 <SamB> edwardk: that does sound kind of neat
15:08:37 <vincenz> edwardk: and you can refer to it as if it's one class
15:08:38 <edwardk> so if they are members of Foo a, Bar b and Baz a b, then you automatically get FooBarBazz
15:08:42 <SamB> er, vincenz
15:08:44 <vincenz> meaning we can refactor Num into a lot of tiny little TCs
15:08:48 <vincenz> without the user noticing
15:08:49 <SamB> anyway it sounds neat
15:08:53 <edwardk> nice
15:09:03 <vincenz> I'd like to implement it
15:09:06 <vincenz> I doubt it's difficult
15:09:13 <vincenz> just don't know GHC :/
15:09:22 <vincenz> and atm have a ton of work
15:10:01 <norpan> if it's just being implemented as an alias, FooBarBaz a meaning (Foo a, Bar a, Baz a) then it should be straightforward
15:10:28 <vincenz> norpan: not quite
15:10:34 <norpan> of course dealing with deriving classes and order could be trouble
15:10:35 <vincenz> you need to a) change the .hi files so they're exported
15:10:47 <SamB> deriving doesn't need help, does it?
15:10:49 <vincenz> b) change lexer, parser, typechecker and possibly something more
15:10:54 <dmhouse> G'night all.
15:11:12 <SamB> as long as it expands before you deal with these, I mean
15:11:20 <vincenz> SamB: yeah
15:11:20 <norpan> class inference may be tricky too
15:11:27 <vincenz> norpan: not really
15:11:30 <vincenz> just expand
15:11:37 <vincenz> the only technical difficulty is in changing the .hi
15:11:39 <SamB> oh but that changes types
15:11:39 <vincenz> so they're exported
15:11:49 <SamB> but I guess thats the idea
15:12:29 <edwardk> class Ring a b c d, Commutative ..., WithUnity =
15:12:31 <edwardk> yeah
15:12:37 <edwardk> i would definitely like the class aliases =)
15:13:11 <edwardk> not if class aliases can only expand
15:13:36 <edwardk> shouldn't be too bad in that case
15:14:57 <vincenz> expand
15:14:58 <vincenz> ?
15:16:25 <edwardk> well if a class alias is always one thing and it expands out to real classes it should be ok as long as you never have cycles no?
15:16:52 <vincenz> edwardk: and this is different from the current situation...how?
15:16:56 <norpan> the same as type aliases
15:16:57 <vincenz> I can still make cycles without CAs
15:17:03 <vincenz> Num a => Eq a
15:17:06 <vincenz> Eq a => Num a
15:17:12 <norpan> but thats superclassing
15:17:16 <norpan> a different matter
15:17:25 <edwardk> yeah i know, what i mean is that a class alias can't introduce any new non-termination cases
15:17:34 <vincenz> edwardk: have an example?
15:17:59 <shapr> @seen ndm
15:18:00 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 1 hour, 3 minutes and 28 seconds ago, and .
15:18:02 <shapr> hm
15:18:10 <vincenz> shapr: I kicked him
15:18:31 <norpan> good for you
15:18:36 <vincenz> he was the nearest person
15:18:36 <edwardk> well, wouldn't it be up to someone to provide a counter-example since it was a claim of non-existence? =)
15:18:39 * vincenz looks at his foot
15:19:04 <vincenz> edwardk: what if god suddenly intervened in the compiler and flipped a bit.... can you prove non-existence?
15:19:22 <vincenz> edwardk: I was askng for an example cause I have no idea what you're referring to
15:19:53 <vincenz> edwardk: and if you don't have an example then probably you don't either (no offense) so it was probably some convoluted thinking that ended up in an impossibility
15:20:24 <vincenz> tho if you do have an example, I'd be curious :)
15:20:47 <edwardk> vincenz: the class alias thing they were talking about above. a class alias is just a way of expanding out a large (Foo a, Bar a, Baz a) with a single label, very close to declaring an instance
15:21:01 <vincenz> yep
15:22:05 <edwardk> all i was saying is that it seems like it is a harmless extension because any cycle it introduces should be reproducible by just dealing with the type classes it aliases.
15:22:28 <vincenz> oh
15:22:29 <edwardk> because the article in question didn't seem to indicate any sort of recursion directly in aliases
15:22:31 <vincenz> then we agree :)
15:22:43 <edwardk> hence my confusion about wtf you were jumping down my throat about =)
15:22:58 <vincenz> you won't get more cycles with ca's then you will get without
15:23:02 <edwardk> exactly
15:23:23 <vincenz> shapr: you understood parts of GHC yet?
15:23:27 <vincenz> shapr: found any good documents?
15:23:32 <xerox> I really like the new Numeric Prelude hierarchy.
15:23:41 <xerox> Weel, the proposed one.
15:23:42 <edwardk> xerox: ?
15:24:03 <vincenz> xerox: it's linear?
15:24:08 <xerox> The one proposed in the Class Alias Proposal.
15:24:10 <vincenz> oh
15:24:11 <vincenz> right
15:24:13 <vincenz> me too :)
15:26:43 <vincenz> http://googlesystem.blogspot.com/2006/07/malware-search-engine.html
15:32:09 * vincenz is off
15:32:09 <vincenz> night
15:32:15 <edwardk> night vincenz
15:33:44 <edwardk> vincenz: i did write stuff back, i'll catch you later =)
15:33:49 <vincenz> ok
15:33:58 <edwardk> and no problem
15:34:04 <vincenz> :)
15:34:10 <edwardk> i'll punch a hole for ident
15:37:01 <shapr> edwardk: Or use ipv6!
15:37:25 <edwardk> kind of need upstream support for that =)
15:39:47 <greenrd> It's great when you read a haskell paper and you think "Oh yeah, I was just thinking along those lines" :)
15:39:53 <shapr> freenode supports ipv6
15:40:12 <edwardk> yeah but comcast doesn't ;)
15:40:18 <shapr> You can tunnel.
15:40:25 <edwardk> true
15:40:39 <shapr> There's a particular address that means "The nearest IPv6 router." you send packets out, and they get there.
15:40:54 <mwc> shapr, no kidding
15:41:07 <shapr> Lucky for me, ipv6.org is about ten minutes bus ride away.
15:41:11 <edwardk> heh
15:41:18 <mwc> The ip6 gnomes spirit them over the ether to the router or what?
15:41:43 <edwardk> i mostly see ipv6 as a technology that died on the vine because it tried to solve too many problems at once, half of which there wasn't a real financial need to fix
15:41:58 <shapr> I think it's a great tech that hasn't been tried yet.
15:42:08 <monochrom> So was Haskell ten years ago. :)
15:42:15 <greenrd> heh
15:42:16 <shapr> The US Gov't is switching to IPv6 in the next coupla years.
15:42:33 <edwardk> well, i used to run an isp, we set up for the 6bone, etc. then... nothing =)
15:42:34 <mwc> shapr, just like they officially switched to metric?
15:42:41 <edwardk> so i'm biased =)
15:42:58 <shapr> I dunno, I think IPv6 is harder to switch to without switching to...
15:43:16 <shapr> In any case, that large an installed base of IPv6 will hopefully kick the rest of the world into trying it.
15:43:28 <edwardk> mostly its been used as a scare tactic by companies like cisco to sell bigger hardware with the threat that its coming =)
15:43:30 <shapr> Multicast alone would cut down on many bandwidth problems.
15:43:34 <edwardk> yeah
15:43:48 <edwardk> multicast is good stuff
15:43:51 <shapr> I'd like to try using the linked list of headers for various cute tricks...
15:44:28 <edwardk> devised a whole set of protocols based on multicast, but the router implementations on the ipv4 mbone even are pretty screwy
15:44:43 <edwardk> so i'm even more leery of the ipv6 ones.
15:45:01 <shapr> I think one-to-many would be enough.
15:45:41 <dcoutts> does anyone know how to get a snapshot of a darcs repo from a specific date?
15:46:20 <edwardk> i was mostly abusing hashing and sparse mode multicast routing
15:46:20 <shapr> For example, games could have two datastreams, multicast and personal. Assuming 50% of the game data is multicast, servers would nearly halve their required outgoing bandwidth.
15:46:29 <edwardk> for pretty much what you are talking about
15:47:52 <edwardk> between that, and tornado codes, you can localize traffic reasonably well and guarantee assembly in near linear time without responses
15:48:13 <shapr> Bittorrent could be replaced by a multicast stream that loops.
15:48:25 <edwardk> heh, well, its a little trickier than tha
15:48:28 <dcoutts> shapr, Lemmih, want a ghc bug to fix? ;-)
15:48:28 <edwardk> you don't want to just loop
15:48:40 <shapr> dcoutts: Sure
15:48:55 <dcoutts> oh it's not come through on ghc-bugs list
15:48:59 <shapr> edwardk: How so?
15:49:00 * dcoutts double checks
15:49:23 <edwardk> you want to take it and chunk it, and then tornado code everything in each chunk, so yu get say 128 packets any 64 of which can reassemble the original 64 packet chunk. then you step through sending one packet frm each chunk
15:49:35 <edwardk> any dropped packet means one traversal through the chunk list, not a while retransmit
15:49:42 <shapr> hm, interesting.
15:49:49 <edwardk> factor of 60+ reduction in the listen time
15:50:01 <shapr> Can you point me to some papers or maybe wikipedia about tornado codes?
15:50:07 <bringert> shapr, Lemmih: I've also got a GHC bug for you (well more of an RFE really): http://cvs.haskell.org/trac/ghc/ticket/829
15:50:09 <shapr> I've heard of turbo codes, but not tornado codes.
15:50:09 <lambdabot> Title: #829 (Make -fcontext-stack dynamic) - GHC - Trac
15:50:12 <edwardk> better as long as you randomize the order of the coded subchunks so that regular frequency packet loss doesn't adversely affect you either
15:50:21 <dcoutts> shapr, I've forwarded it to you
15:50:23 <shapr> edwardk: that's neat.
15:50:27 <shapr> Food, bbiab
15:50:52 <edwardk> you could also use a reed-solomon code so as not to patent-infringe
15:50:57 <dcoutts> shapr, it's a problem where it should be possible to narrowed down by binary search to a specific patch
15:51:26 <dcoutts> a patch which broke my code :-)
15:52:10 <dcoutts> I know it worked on May 26th and didn't by Jun 24th
15:52:35 <dcoutts> err Jul 4th
15:52:38 <dcoutts> sorry
15:53:44 <zarvok> @seen vincenz
15:53:45 <lambdabot> I saw vincenz leaving #oasis and #haskell 19 minutes and 36 seconds ago, and .
15:54:29 <dcoutts> shapr, so I guess the thing we need to do is try various snapshots
15:54:41 <dcoutts> shapr, and do quick builds to save time
15:54:52 <edwardk> http://en.wikipedia.org/wiki/Tornado_codes is the wikipedia article, but its a stub, hrmm. maybe i should write it
15:54:57 <dcoutts> eg missing as many libs as possible and building without -O if that saves time
15:55:15 <dcoutts> shapr, if there's two of us then we can do trinary search rather than binary search :-)
15:55:29 <edwardk> http://www-math.mit.edu/~spielman/Research/erase.html
15:55:31 <lambdabot> Title: Efficient Erasure Correcting Codes
15:55:38 <edwardk> is a where they were introduced
15:55:51 <edwardk> the reed-solomon code is probably faster for a real world implementation though
15:55:54 <dcoutts> or if dons is awake we can go even quicker
15:56:41 <dcoutts> shapr, as you can see in my bug report, the issue seems to be that ghc is appending a '1' to the name of a function and this makes the RULES not match
15:56:54 <int-e> dcoutts: I wonder how darcs trackdown works ... hmm.
15:57:08 <dcoutts> int-e, yeah, that might be helpful
15:57:17 <dcoutts> I can specify the test
15:57:30 <dcoutts> not sure how easy it is to automate
15:57:31 * edwardk gets a vision of shapr being abused by the channel if he winds up getting the msr job ;)
15:57:45 <edwardk> dcoutts chasing him around getting him to work in his off hours.
15:57:53 <dcoutts> heh heh
15:58:13 <dcoutts> well at the moment they're trying to show off their bug fixing skills for the interview
15:58:17 <edwardk> yeah
15:58:24 <dcoutts> I'm just finding things for them to do ;-)
15:58:27 <edwardk> heh
15:58:39 <edwardk> i think there is a pretty good list queued up =)
15:58:50 <dcoutts> shapr, 'm half joking, if you're busy then np.
15:58:58 <dcoutts> yeah
15:59:23 * edwardk notes that its only half joking.. dcoutts' other side is holding a whip. =)
15:59:31 <dcoutts> hah
16:07:13 <Lemmih> dcoutts: What bug report?
16:07:32 <dcoutts> Lemmih, for some reason the mailing lists are being slow
16:07:42 <dcoutts> it didn't make it through to the bugs list yet
16:07:51 * dcoutts will forward it
16:09:47 <Lemmih> Thanks.
16:09:59 <edwardk> shapr: if you return you might find http://www.cs.utk.edu/~plank/plank/classes/cs560/560/notes/Erasure/2004-ICL.pdf informative, its a lot less formal and explains the state of the art
16:26:38 <Lemmih> greenrd: ping.
16:28:21 <greenrd> Lemmih: pong
16:29:50 <Lemmih> (re your bug report) What version of lhs2TeX are you using and can you provide a minimal test file?
16:33:35 <shapr> dcoutts: darcs trackdown
16:34:11 <dcoutts> shapr, right, so for that we need a script that builds ghc and runs a test prog
16:35:44 <dcoutts> it doesn't seem as if it's possible to tell darcs trackdown a specific range of dates
16:35:49 <Lemmih> Wouldn't that takes ages? Wouldn't it have to rebuild the libraries for each iteration?
16:35:55 <dcoutts> indeed
16:36:15 <dcoutts> btw do you know how to do a minimal build with minimal libs?
16:36:29 <shapr> What about something like the caching package for gcc?
16:36:34 <dcoutts> and using the fastest optimisation flags for build speed?
16:37:09 * shapr thinks
16:37:16 <shapr> I'm sure there must be ways to optimize the build process.
16:37:23 <dcoutts> there is
16:37:26 <dcoutts> let me find...
16:37:29 <shapr> Anyway, I'll be back tomorrow for more discussion. G'nite all :-)
16:37:38 * shapr is trying to get a regular schedule...
16:37:39 * shapr &
16:37:53 <dcoutts> # Set GhcBootLibs=YES from the command line to work with just the libraries
16:37:53 <dcoutts> # needed to bootstrap GHC.
16:37:58 <dcoutts> g'night shapr
16:38:12 <dcoutts> though I've not tested if this really works
16:38:18 <dcoutts> then there's also mk/build.mk
16:38:21 <Lemmih> And darcs will allow you to keep that patch applied when it goes back in time?
16:38:24 <dcoutts> one can build withot -O
16:38:32 <dcoutts> no idea
16:38:42 <dcoutts> I've never played with darcs trackdown
16:38:55 <dcoutts> I was going to do it manually by a binary search :-)
16:39:06 <Lemmih> That might be faster.
16:39:08 <dcoutts> between May 26th and July 4th
16:39:17 <dcoutts> want to help? :-)
16:40:02 <dcoutts> it may also be useful to record in the ghc docs / wiki how to do the fastest build
16:40:37 <Lemmih> Copying it from HACKING?
16:41:00 * dcoutts checks
16:41:41 <dcoutts> ok, jsut extending HACKING to mention GhcBootLibs=YES would be enough
16:42:08 <Lemmih> GhcBootLibs?
16:42:27 <dcoutts> especially a complete example for min build time
16:42:34 <dcoutts> Lemmih, see libraries/Makefile
16:43:16 <xerox> G'nite.
16:43:29 <Lemmih> Ah.
16:43:31 <dcoutts> g'night xerox
16:45:08 <dcoutts> I'm currently building the ghc snapshot for May 26th
16:46:56 * heatsink feels weird when people explain simple functional concepts in a complicated object-oriented way
16:48:37 <heatsink> There's this article in Computer Magazine about the Visitor Patten.  It looks a lot like fmap.
16:48:54 <int-e> and fold.
16:49:26 <heatsink> yea, depending on whether you're "modifying" the data you're visiting or just gathering results.
16:50:09 <heatsink> But it doesn't take eight pages to describe that.  It shouldn't.
16:52:25 <edwardk> heh
16:52:33 <edwardk> well, thats what it takes in their vocabulary =)
16:52:37 <int-e> Well, carefully avoiding the term 'functional programming' (because it'd scare people) or even functor, I can imagine it'll take that much :)
16:52:45 <edwardk> sapir-whorf hypothesis and all that =)
16:53:54 <heatsink> heh.
16:55:02 <heatsink> I'm reminded of a presentation I saw about a tool for the Eclipse Java IDE where you could search for functions based on their types... like hoogle... and promoting how useful such a feature was.
16:55:12 <heatsink> (they didn't mention hoogle.)
16:55:34 <vincenz> Yay insomnia
16:55:39 <edwardk> well, 80% of the haskellers out there are sitting here in this channel it seems some times ;)
16:56:01 <LordBrain> haha
16:56:04 <heatsink> The _hardcore_ haskellers, you mean
16:56:40 <int-e> heatsink: ok, now lookup Object -> Object -> Object ;)
16:56:50 <LordBrain> has simon peyton jones ever paid a visit?
16:57:07 <edwardk> the ecma4-specification actually goes through and enumerates its user base when its talking about some features, and it goes through and gives 3 alternatives, one of which is the nice way that we'd expect it to work, and the others are derivatives of c and java approaches. they then discount us as 0% of their user base, and i can't disagree
16:57:08 <edwardk> yeah
16:57:11 <edwardk> he was in here the other day
16:57:20 <Lemmih> @seen simonpj
16:57:21 <lambdabot> I saw simonpj leaving #haskell 6 days, 7 hours, 40 minutes and 47 seconds ago, and .
16:57:29 <vincenz> edwardk: I'm back
16:57:31 <edwardk> ok, so my time sense is a little off
16:57:31 <LordBrain> oh cool
16:57:41 <heatsink> edwardk, what's ecma4?
16:57:49 <vincenz> heatsink: the stuff ghosts are made off
16:57:55 <vincenz> don't you know ghostbusters?
16:57:59 <edwardk> ecmascript 4 == the next javascript version
16:58:08 <heatsink> ecmaplasm?
16:58:15 <heatsink> ok
16:58:16 <edwardk> heh
16:58:25 <LordBrain> hmm i'm curious what he talked about
16:58:31 * vincenz mutters as he only slept 1.5h
16:58:40 <heatsink> @where vincenz
16:58:41 <lambdabot> http://notvincenz.com/
16:58:44 <edwardk> was here talking about the guys they are inviting down to microsoft research
16:58:49 <Lemmih> LordBrain: He talked about AngloHaskell, iirc.
16:58:58 <vincenz> Lemmih: got a headset yet?
16:58:59 <heatsink> @time vincenz
16:59:01 <lambdabot> Local time for vincenz is Thu Jul 20 01:58:40 2006
16:59:02 <vincenz> Lemmih: and we'll use teamspeak
16:59:06 <Lemmih> vincenz: Nope.
16:59:12 <heatsink> ah.
16:59:13 <vincenz> Lemmih: you prefer not using one?
16:59:57 <Lemmih> vincenz: I don't own a headset. My brother does but he's in Finland right now.
17:00:10 <vincenz> ah
17:00:12 <vincenz> and he's visiting you soon
17:00:29 <madpickle> http://www.babynamewizard.com/namevoyager/lnv0105.html
17:00:29 <madpickle> wow
17:00:30 <lambdabot> Title: The Baby Name Wizard: NameVoyager
17:00:32 <madpickle> that thing is awesome
17:00:36 <madpickle> check out your own name
17:01:26 <vincenz> madpickle: cool, tho apparently anglosaxon
17:01:34 <madpickle> but of course
17:01:38 <vincenz> christophe defaulted to christopher
17:01:44 <Lemmih> vincenz: Well, no. The plan was to steal it from his appartment. Just haven't got around to it yet.
17:01:53 <vincenz> :D
17:01:58 <madpickle> mine's mickey -- which was at its height in the 50s
17:02:00 <madpickle> (hello, Disney)
17:02:15 <vincenz> Lemmih: Lazy bottoms?
17:02:19 <madpickle> girls were named Mickey back then ,too
17:02:31 * vincenz ponders
17:02:32 <vincenz> Pure bottoms
17:02:50 * heatsink discovers that some girls are named Christopher
17:02:58 <madpickle> how about this name: Gus
17:02:59 <vincenz> heatsink: poor girls
17:03:03 <palomer> you're all nuts!
17:03:05 <madpickle> or Gertrude
17:03:06 <palomer> @palomer
17:03:07 <lambdabot> woof
17:03:16 <madpickle> which is , well, unpopular nowadays
17:03:32 <madpickle> adolf, incidentally, took a dive during the 40s
17:04:04 <palomer> know what's a great name?
17:04:06 <palomer> chauncey
17:04:06 <vincenz> is anyone an MSN expert?
17:04:32 <madpickle> no, Maximilian is a ogod name
17:04:38 <madpickle> very modern, too
17:04:56 <tony2> I think I'd like to have eight kids, so I can call the last octavian or octavia depending.
17:05:09 <madpickle> look up "Haskell"
17:05:17 <madpickle> apparently that was 'the' name du jour circa 1900s :D
17:05:52 <u221e> What does it mean that something is boxed or unboxed?
17:05:57 <Ulfalizer> i read somewhere that haskell never liked his name. kinda ironic..
17:05:57 <heatsink> "Aubrey" transformed completely from a male name to a female name in the sixties
17:06:30 <vincenz> zarvok: ping
17:06:35 <madpickle> apparently, "Washington" was a good name back then
17:06:48 <vincenz> madpickle: yeah, I hear it was hot 300 years ago too
17:06:54 <tony2> u221e, values which could be unboxed are things that have a fixed length, Int etc.
17:06:58 <Ulfalizer> "curry" would have been a cooler name
17:07:05 <Ulfalizer> for the language, that is
17:07:14 <heatsink> u221e, an unboxed value is the actual value.  A boxed value is a reference to the value.
17:07:34 <u221e> I see.
17:07:35 <heatsink> u221e, A boxed value could require some computation to be performed before you get the real value.
17:07:38 <edwardk> I think there is a joke about audrey switching from a male name to a female name in the 2000s in there somewhere, but it might be in poor taste as I don't know her sense of humor that well ;)
17:07:39 <tony2> u221e, other stuff has to be put in a box (referenced),  becuase it has variable length.
17:07:43 <madpickle> lmao
17:07:48 <madpickle> "Lexus" is, apparnetly, a girls name
17:07:55 <madpickle> and... so is Mercedes
17:08:11 <madpickle> i tried "Buick" but I didn't get any hits.
17:08:12 <Ulfalizer> lexus sounds like something from a game show with people on steroids..
17:08:40 <madpickle> i looked up "Gay"
17:08:50 <madpickle> which had its peak in the 40s as a girls name, back when it meant something else...
17:09:03 <heatsink> edwardk: Well, if you didn't know that she's younger than forty-five, you do now.
17:09:03 <LordBrain> i think of a boxedtype as being implemented using a pointer
17:09:29 <LordBrain> i'm not sure about the true implementation details
17:10:13 <monochrom> Example: (b :: Array Int Double)  this says b is an array with Int indexes and Double elements.  But internally it is an array of pointers to the heap, and the Double's are stored in the heap.
17:11:02 <monochrom> A benefit of that is that more generally you could have pointers to expressions rather than numbers.  Then you can do lazy evaluation.
17:11:47 <LordBrain> i see
17:12:13 <monochrom> (c :: UArray Int Double)   now this is an array which internally is an array of Doubles.  No deferencing.  You can no longer do lazy evaluation per element.  But it's fast and sweet.
17:12:44 <monochrom> So, the former is an array of boxed Doubles, the latter an array of unboxed Doubles.
17:12:45 <heatsink> madpickle: The overall shape of the graph means that uncommon names have been becoming more common since the sixties.  That's interesting in itself.
17:13:03 <madpickle> yeah
17:13:05 <madpickle> it makes sense
17:13:10 <madpickle> people were under the affects of a lot of drugs
17:13:19 * heatsink looks up the name "rainbow"
17:13:28 <heatsink> aww, nothing.
17:13:30 <madpickle> heheheh
17:13:32 <madpickle> "Sunshine"
17:13:33 <tony2> Less people names after saintsis a big factor.
17:13:33 <madpickle> bingo :)
17:13:47 <madpickle> seems to start circa 1968
17:14:02 <heatsink> Ah, good point
17:14:02 <tony2> :s/saintsis/saints is
17:14:17 <vincenz> Anyone know how to block people form entering a channel?
17:14:23 <madpickle> yes.
17:14:29 <madpickle> you ban them, basically
17:14:52 <vincenz> no
17:14:55 <vincenz> like a limited userset
17:15:01 <madpickle> oh
17:15:02 <madpickle> +i
17:15:02 <monochrom> The ops add a ban.  A ban is by hostmask.  wildcards ok.
17:15:04 <madpickle> makes it invite only
17:15:07 <int-e> madpickle: Do you realize that the Mercedes series was actually named after the daughter of Emil Jellinek, who developed the first Mercedes model?
17:15:17 <madpickle> int-e: nope
17:15:21 <madpickle> Emil.. good scandi name.
17:15:32 <Ulfalizer> a friend of mine lives near a chinese guy who's name means 'heavy scrotum' in swedish
17:15:43 <vincenz> monochrom: can't do it by identified nick list?
17:15:43 <monochrom> /mode #haskell +b *!*@*.aol.com     This is an example of a ban.
17:15:50 <LordBrain> where's the name graph, i want to peek?
17:15:56 <madpickle> lol
17:16:09 <monochrom> If you know the nick, monochrom!*@*
17:16:10 <madpickle> i had a guy in class once whose name was "Yu ho"
17:16:13 <madpickle> i always found that amusing.
17:16:33 <heatsink> LordBrain, http://www.babynamewizard.com/namevoyager/lnv0105.html
17:16:34 <lambdabot> Title: The Baby Name Wizard: NameVoyager
17:16:48 <madpickle> i swear, that graph is just well made.
17:16:51 <madpickle> usability is superb
17:16:56 <vincenz> monochrom: yeah but that's for bans, not for allows
17:17:00 <madpickle> oh
17:17:02 <madpickle> you want exceptions
17:17:06 <madpickle> i think this network has em
17:17:10 <madpickle> /mode #chan +e banmask
17:17:13 <heatsink> What does the *!*@* string mean?
17:17:17 <madpickle> exceptmask, would be more appropriate
17:17:21 <madpickle> heatsink: ban everything
17:17:26 <madpickle> nick!ident@host
17:17:28 <monochrom> nick!username@hostname
17:17:36 <heatsink> oic.
17:18:20 <monochrom> For example I'm monochrom!n=trebla@*.magma.ca
17:18:21 <edwardk> afk a bit
17:18:26 * Ulfalizer wonders if anyone proofread the 1459 irc rfc
17:18:36 <Ulfalizer> lots of missing words and cut off sentences
17:18:52 <monochrom> Sounds like IRC indeed :)
17:18:57 <Ulfalizer> heh :)
17:19:01 <LordBrain> hmmm
17:19:05 <madpickle> unf
17:19:10 <madpickle> @unf
17:19:11 <lambdabot> Maybe you meant: run url wn
17:19:14 <LordBrain> so if i'm reading this right James was number 1 in the forties
17:19:14 <madpickle> lol
17:19:15 <madpickle> hahaha
17:19:54 <LordBrain> i always felt it was far too common
17:20:16 <madpickle> no one named Beowulf
17:20:19 <int-e> Ulfalizer: rfcs 2810 to 2813 are slightly better.
17:20:20 <madpickle> what a shame
17:20:25 <madpickle> nor Faust
17:20:29 <madpickle> at least, not enough to register.
17:20:55 <Ulfalizer> int-e: they deal with the basic protocol as well?
17:21:13 <heatsink> Faust isn't exactly a heroic figure...
17:21:19 <Ulfalizer> i know there are some rfc:s on extensions that aren't very common
17:21:25 <madpickle> heatsink: say that to the people named "Sunshine" or "Gus"
17:21:31 <madpickle> yeah, ulf, like IRC+
17:21:38 <int-e> Ulfalizer: they 'update' rfc 1459. They explain the whole architecture again.
17:21:41 <madpickle> MS made it.. i think that was enough to put off most people.
17:21:53 <Ulfalizer> int-e: ok, thanks for the tip
17:21:53 <madpickle> most ircd developers never did bother reading the RFC
17:22:00 <int-e> Ulfalizer: and I know of no network that implements them faithfully ;)
17:22:07 <Ulfalizer> madpickle: irc+?
17:22:18 <newsham> the ircd rfc was written way after ircd was written
17:22:25 <madpickle> yes. your best bet is /debug on in mIRC, or some other way of saving a raw dump of irc data
17:22:33 <newsham> and I dont think it even reflected the current version of ircd at the time of its writing
17:22:33 <madpickle> and then reverse each part you need. it's very easy
17:22:37 <madpickle> supplement it with the RFC
17:22:41 <Ulfalizer> int-e: heh, i've already seen qnet break the rfc in a couple of places =)
17:22:50 <madpickle> that's nothing new, Ulfalizer
17:22:55 <madpickle> most of them break em horribly
17:23:02 <madpickle> most IRC clients are very, very lenient
17:23:10 <madpickle> and most don't make any assumptions nowadays
17:23:24 <int-e> noone seems to implement the {\} are upper case versions of [|] part :)
17:23:28 <Ulfalizer> i'm just gonna write a simple bot, shouldn't have to worry about most such details
17:23:47 <madpickle> those that do, read numeric 005 for the environment variables
17:24:01 * Dreadshoot wobbles ulfalizer
17:24:06 <madpickle> such as channel- and user modes, channel lengths and nickname prefixes
17:24:20 <madpickle> no, ulf, but make sure you respond to ping requests
17:24:27 <madpickle> you will receive PING :some.server.com (usually)
17:24:32 <madpickle> and you will reply with PONG :some.server.som
17:24:34 <Ulfalizer> i use ethereal to capture messages
17:24:35 <int-e> ping requests are abused as well
17:24:36 <madpickle> or whatever it sends
17:24:41 <madpickle> Ulfalizer: no, that's stupid. don't do that.
17:24:44 <Ulfalizer> madpickle: yeah, i'm aware of that
17:24:48 <madpickle> it's a text-based protocol, not a binary one
17:24:52 <madpickle> ethereal will just complicate it
17:24:59 <Ulfalizer> madpickle: ethereal can decode it
17:25:05 <madpickle> yes, i know
17:25:16 <madpickle> use mIRC or X-Chat that lets you type /debug on or something
17:25:22 <madpickle> to log it to a file.. it's simpler to deal with
17:25:38 <madpickle> in mIRC, you can also type /debug @mywindow to make a separate window where data will be streamed, real-time.
17:25:57 <Ulfalizer> when i say "decode", i mean it understands the irc protocol. you get the ascii messages.
17:26:12 <madpickle> yeah, i know that. but, eh, it's a headache to deal with Ethereal (IMO)
17:26:24 <Ulfalizer> i think it's pretty good
17:26:28 <newsham> write a tiny server which accepts a connection on a socket, opens a socke to an irc server, and copies data through in both ways and to a log file.
17:26:37 <newsham> then connect your irc client ot the server.
17:26:41 <madpickle> yeah, proxy it
17:26:43 <madpickle> good idea, newsham
17:26:49 <vincenz> newsham: proxytee?
17:26:50 <newsham> if you want code, lemme know.
17:27:05 <Ulfalizer> heh, ethereal is working just fine
17:27:07 <madpickle> wriiting a bot on irc is thankfully very esay (and good fun)
17:27:43 <vincenz> madpickle: easier than writing easy
17:27:43 <Ulfalizer> i thought i'd do it in haskell, using parsec for a simple command language
17:27:49 <madpickle> vincenz: yep
17:31:01 <newsham> manually irc'ing (ie. with nc or telnet) is also a good experience
17:31:10 * Ulfalizer pokes Dreadshoot 
17:31:25 <madpickle> yes, if a bit verbose
17:31:32 <SamB> hahaha
17:31:43 <SamB> I'm lucky if I can NICK fast enough
17:32:02 <SamB> well, maybe not anymore
17:32:06 <madpickle> heheh
17:32:13 <madpickle> timeout is usually 30 secs to 1 min
17:32:19 <Ulfalizer> newsham: yeah, i'm planning on trying it out tomorrow
17:32:21 <SamB> I seem to remember running into trouble with that at one point...
17:32:27 <SamB> maybe handshake was more complicated or something
17:32:31 <madpickle> USER moo moo moo :moo
17:32:33 <madpickle> NICK moocow
17:32:36 <madpickle> and it should connect you
17:32:47 <SamB> oh, right, the USER stuff....
17:32:54 <vincenz> JOIN prairy
17:32:54 <madpickle> it'll throw numeric 433 if the nick is in use
17:32:58 <madpickle> so just give it another
17:34:04 <Ulfalizer> i wonder what's with the asterisk before the nick in the 433 message..
17:35:14 <madpickle> well, yes, the irc protocol is not very stream line
17:35:17 <madpickle> stream lined
17:35:28 <madpickle> at least it's plain text.
17:36:34 <Ulfalizer> yeah, i just couldn't figure it what it was for. maybe i haven't looked hard enough in the rfc..
17:36:41 <madpickle> who cares?
17:36:47 <Ulfalizer> good point :)
17:44:40 <vincenz> imagine.... not daring to go to sleep
17:44:48 <vincenz> dum Dum DUM!
17:50:29 <vincenz> madpickle: ooc, what do you do
17:53:00 <vincenz> anyone around?
17:53:14 <heatsink> sure
17:53:17 <vincenz> ah
17:53:18 <vincenz> btw
17:53:21 <vincenz> is it necessary to have
17:53:24 <vincenz> forall a.
17:53:27 <vincenz> for a parameter?
17:53:33 <vincenz> compos :: (forall a. a -> m a)
17:53:42 <vincenz> compos :: (forall a. a -> m a) -> something -> something
17:54:10 <heatsink> Usually, no.  GHC has extensions to the type system where it can matter.
17:54:28 <int-e> in fact the forall a. isn't even Haskell 98.
17:55:26 <heatsink> I don't remember... is (forall a. a -> b) -> c the same as forall a. a -> b -> c?
17:56:46 <int-e> you mean forall a. (a -> b) -> c  No I don't think so.
18:02:02 <vincenz> yeah I'm doing something like bringert's paper at icfp
18:02:03 <vincenz> but more involved
18:02:27 <zarvok> vincenz:
18:02:30 <zarvok> the page has been updated
18:02:34 <zarvok> enjoy :)
18:03:49 <vincenz> woot
18:03:52 <vincenz> zarvok: oh yeah
18:03:55 <vincenz> zarvok: most likely "Lazy bottoms"
18:03:57 <vincenz> as tema neame
18:04:00 <vincenz> team name
18:04:14 <zarvok> vincenz: I'll be on the lookout
18:04:20 <vincenz> zarvok: hmm what's "umz"
18:04:31 <zarvok> a mail will go out to the announce list in an hour or so
18:04:35 <zarvok> haha, can't tell you that :)
18:04:36 <vincenz> cool
18:05:20 <heatsink> oh cool, the contest is coming on this weekend.
18:05:35 <zarvok> heatsink: are you goign to enter?
18:05:55 <heatsink> I hadn't considered it.
18:06:04 <zarvok> well, it's going to be fun
18:06:22 <zarvok> vincenz: of course, full details come out friday, but have fun poking at that file in the mean time
18:06:32 <heatsink> What, a small team consists of zero to four persons?
18:06:33 <vincenz> :)
18:06:38 <heatsink> Should be one to four, no?
18:06:41 <zarvok> hehe
18:06:52 <zarvok> just a joke
18:07:05 <zarvok> actually, the webform accepts 0, and several people registered as 0 person teams
18:07:32 <vincenz> they'll most likely get judges price if they get any solution at all
18:07:33 <vincenz> :P
18:07:41 <johnnowak> well maybe it was just one person registering
18:07:41 <vincenz> tho there will be noone to award
18:07:45 <johnnowak> but there's no i in team?
18:08:55 <heatsink> I'm gonna follow the contest's progress for sure.
18:27:24 <u221e> Why is modifying an array so expensive?
18:29:31 <Revision17> if it's a regular array, the entire array gets copied each time it's modified
18:29:40 <Revision17> use diffArray if you're going to be modifying arrays alot
18:29:57 <Revision17> that has O(1) modify times
18:30:13 <Lemmih> The '1' is pretty big, though.
18:30:30 <ihope> Well, O(10472803759817489237529035801384) = O(1), so...
18:31:08 <newsham> what if 10472803759817489237529035801384 is really big?
18:31:28 <ihope> O(2^2^2^2^2^2^2^2^2^2^2^2^2^2) = O(1).
18:31:30 <vincenz> newsham: numbers don't change size, silly
18:31:37 <vincenz> nooo: Server Error
18:31:38 <vincenz> We're sorry, but Gmail is temporarily unavailable. We're currently working to fix the problem -- please try logging in to your account in a few minutes.
18:31:59 <Lemmih> My gmail works.
18:32:12 <vincenz> Keep getting popup box "error code 766"
18:33:23 <u221e> Mine works too
18:33:26 <vincenz> fuck
18:33:34 <newsham> 1 = 2 for large values of 1
18:34:41 <Lemmih> 1 > 2 for large values of 1 and small values of 2?
18:36:26 <u221e> ;P
18:36:46 <vincenz> up again \o
18:36:56 <johnnowak> 1 != 1 for differing values of zero?
18:37:04 * johnnowak bumbles
18:39:05 <u221e> Well 1.999...  does equal 2, but then it's not value of 1 anymore, large or not ;)
18:41:23 <int-e> only if you're dealing with real numbers
18:42:44 <u221e> I remember a discussion on digg about 0.999... being 1, it was pretty sad, even math students thought it was wrong.
18:43:12 <int-e> it's pretty much the definition of real numbers
18:44:19 <int-e> An example of numbers without the necessary defining property (namely, completeness) are surreal numbers (I'm not making that up).
18:44:36 <Cale> It's because in highschool, they define the real numbers as strings of digits, if that.
18:45:00 <Cale> So obviously people get confused.
18:45:41 <int-e> that being said I'd usually assume that when people write 0.9999... they mean a real number that equals 1.
18:45:54 <Cale> yes, me too
18:45:56 <SamB> I don't think mine defined real numbers to start with
18:46:00 <SamB> but that was okay by me
18:46:17 <u221e> Cale, even college mathematics students didn't get it
18:46:19 <Cale> Somehow they manage to do this "math" that's not mathematics at all.
18:46:49 <Cale> u221e: yeah, there are lots of colleges which are no better -- especially if you're in science or engineering and not mathematics.
18:47:37 <zarvok> In my high school we did a proof that .999... = 1, is that uncommon?
18:47:53 <Cale> zarvok: Well, somewhat. Which proof did you get?
18:48:00 <zarvok> honestly I don't recall
18:48:11 <int-e> zarvok: more importantly, what is a real number? :)
18:48:35 <zarvok> int-e: heh, well, I'm not convinced there is any such thing
18:48:39 <SamB> I think I could have figured it out based on 0.333... = 1/3
18:48:43 <Cale> There's a sneaky "proof" which isn't really all that great, but it's at least somewhat convincing.
18:48:44 <SamB> if I'd thought about ti
18:48:49 <SamB> er, it
18:48:53 <Cale> and yeah, that fact helps too
18:48:54 <SamB> Cale: ooooh sneaky
18:49:04 <u221e> The most simple explaination I've ever heard what that since 0.999... is rational, give my the ratio that would equal 0.999...
18:49:17 <SamB> tell me about sneaky proof
18:49:36 <int-e> 1= 9/9= 9* 0.111... = 0.999.... is sneaky
18:49:37 <Cale> Well, the thing is, 0.9999... really means sum over i >= 1 of 9/10^i, so a real proof should use that.
18:49:41 <zarvok> u221e: yes, come to think of it, I think that's what the proof we saw in high school was based on
18:49:50 <Cale> Yes, I meant int-e's
18:49:51 <int-e> it's not a proof at all, just a big abuse of notation
18:50:12 <Cale> well, it works, but relies on facts which themselves need proving
18:50:22 <int-e> because it never uses a definition of a real number.
18:50:38 <Cale> hmm
18:50:46 <zarvok> still, you can't expect the average person to be prepared for an explanatino of dedikind cuts or other similar methods
18:50:52 <Cale> Not necessarily. I mean, certainly what you wrote is valid.
18:51:05 * int-e was actually taught that real numbers are Cauchy sequences, sometime in (what is roughly equivalent to) high school but that's an exception even in Germany I think.
18:51:12 <Cale> zarvok: But an axiomatic description of the reals is good.
18:51:13 <SamB> I remember seeing a really whacky proof of something that used infinitely long binary numbers...
18:51:24 <Cale> That is, list all the axioms of a complete ordered field.
18:51:25 <SamB> maybe that ...111 = -1
18:51:39 <Cale> For the completeness, I like using the least upper bound property.
18:51:39 <int-e> equivalence classes of Cauchy sequences, all that nasty stuff. But it makes that proof quite immediate.
18:51:40 <zarvok> Cale: true, but it leaves questions of existence
18:51:54 <Cale> zarvok: Somehow that doesn't bother me as much
18:52:00 <zarvok> fair enough
18:52:04 <Cale> zarvok: You don't worry about existence of sets :)
18:52:11 <SamB> int-e: you mean you learned that in gym?
18:52:48 <int-e> SamB: yes.
18:53:00 <zarvok> Cale: heh, I can just imagine them trying to teach ZFC or NBG in high school
18:53:09 <int-e> SamB: we had a quite enthusiastic math teacher :)
18:53:11 <SamB> they don't teach anything like that in gym around here!
18:53:18 * SamB is in the US
18:53:46 <SamB> To tell the truth, I haven't any idea what they teach in gym around here
18:54:02 <Cale> zarvok: but sets certainly should show up
18:54:20 <Cale> zarvok: actually, ZFC isn't *that* bad if you write out the axioms in a friendly way
18:54:31 <u221e> Heh
18:54:35 <Cale> and maybe ignore replacement and foundation :)
18:54:37 <zarvok> Cale: sure, but in high school you're almost certainly going to see a naive set theory
18:54:39 <Cale> hehe
18:54:51 <int-e> SamB: but really, we were dealing with limits of sequences around the same time - you can't do that properly without some definition of a real number, and cauchy sequences arise quite naturally in that context.
18:54:59 <zarvok> just unrestricted comprehension, basically
18:55:21 <Cale> But you should definitely see what a function actually is, and they don't really teach that
18:55:31 <Cale> They teach you that a function is a rule.
18:55:37 <zarvok> int-e: I don't know, sounds like you're going to have a chicken and egg problem
18:55:39 <Cale> But it's certainly not.
18:55:44 <SamB> indeed
18:56:02 <SamB> but a function for which you have no rule is really hard to deal with
18:56:04 <int-e> zarvok: well, not really, because you have rational numbers :)
18:56:05 <Cale> Unless you have a really strange definition of "rule"
18:56:12 <zarvok> true
18:56:43 <Cale> another thing which pisses me off is how they teach the logarithm
18:56:52 <Cale> and real-valued exponents
18:57:05 <zarvok> int-e: have you read dedekind's later development of the rationals?  It's so beautiful
18:57:05 <int-e> how do they do it?
18:57:06 <Cale> you just can't do that without at least a little calculus
18:57:26 <SamB> oh, I don't remember the rubbish I learned before the stuff in the calculus book at *all*
18:57:53 <int-e> zarvok: no. but I'd define them as equivalence classes of pairs of integers. What did he do?
18:58:09 <Cale> int-e: they define  log_b(x) = y to mean that b^y = x, but they don't *really* tell you what b^y means when y isn't an integer.
18:58:13 <SamB> all I remember right now is that d/dx ln(x) = 1/x
18:58:38 <zarvok> int-e: something similar, but he has this really neat way of blending an axiomatic method with a genetic method.  You might argue that he was the first to build in the naturals and rationals axiomatically
18:58:46 <int-e> (Btw, integers would be equivalence classes of pairs of natural numbers, if I were to define them)
18:59:04 <Cale> int-e: me too
18:59:45 <zarvok> Cale: of course, you have to have some way of teaching things like logarithms and exponents to students who will never see calculus
19:00:04 <Cale> zarvok: I don't think so. I think it would be better to do the necessary calculus first.
19:00:13 <int-e> Cale: so they never go the b^(p/q) = (b^p)^(1/q) and then we make the function continuous route? That's - evil.
19:00:47 <Cale> int-e: Well, they might define it for rationals
19:00:50 <zarvok> Cale: well, I don't know where you're from, but at my high school maybe half the students never took a calculus course.  Plus I think it helps to get an intuitive feel for the idea before presenting it rigorously
19:01:02 <int-e> it leads to questions like 'what's -1.4^pi?'
19:01:03 <Cale> int-e: But at that point, they don't really even have a notion of continuity
19:01:12 <Cale> or any sort of limiting process at all
19:01:17 <Cale> not even supremum
19:01:37 <Cale> zarvok: yea, I know, just if it were up to me, I'd swap things around
19:01:52 <zarvok> sure, but people successfully used the concepts of logs and exponents for centuries before _anyone_ understood those concepts
19:01:57 <int-e> and people wonder why pupils hate math?
19:02:16 <int-e> (I'll assume that most do. Tell me if that's wrong.)
19:02:20 <Cale> It's okay to have good intuitive ideas, but without proper definitions, you're being unfair
19:02:36 <Cale> int-e: you're right, and that's exactly why, I'd wager
19:02:46 <Cale> watering down mathematics doesn't make it easier
19:02:49 <Cale> it makes it harder
19:02:53 <vincenz> what does a nickmask look like?
19:02:54 <Korollary> People that do hate math do it because it is crystal clear when they are wrong.
19:03:02 <int-e> Oh. 'a function is a graph'
19:03:12 <zarvok> I think it would be just as unfair to assume that everyone needs to see a fully rigorous development of these ideas.  Some people simply won't ever need or care to know these things
19:03:19 <wagle> hi..  in bird's algebra of programming book, he uses the notation (\forall b \elem B : a R b : b \elem x)  ...  what does the second colon mean?
19:03:35 <vincenz> anyone? nickmask for a nick
19:03:38 <vincenz> like ... vincnez?
19:03:51 <vincenz> vincenz!*@* ?
19:03:59 <dylan> you mean like nick!user@host?
19:04:17 <vincenz> ah :)
19:05:00 <vincenz> thx
19:05:05 * vincenz sighs as he can't sleep
19:05:11 <vincenz> zarvok: I'm gonna be a reck for your thing
19:05:14 <zarvok> wagle: could you provide some context for the expression?  I can think of a couple possible things, but it might help
19:05:18 <zarvok> to see more
19:05:30 <zarvok> vincenz: heh, well, it's just for fun
19:05:50 <SamB_XP> yeah, a function is a graph, but a graph ain't one of those things you draw on paper
19:06:21 <zarvok> SamB_XP: I can think of plenty of other ways to define it as well - how about a set of ordered pairs?
19:06:36 <wagle> zarvok: E R x = { a \elem A | (\forall b \elem B : a R b : b \elem x) } ....  (set brackets)
19:06:36 <SamB_XP> that is the same as a graph, is it not?
19:06:39 <vincenz> zarvok: oh, right but I can't sleep due to other reasons
19:07:59 <zarvok> vincenz: still jet lagged, or other stuff?
19:08:05 <vincenz> other stuff :(
19:08:12 <vincenz> jet lag in fact was not the root cause I fear
19:08:43 <zarvok> vincenz: That's too bad, there's nothing worse than lying awake at night
19:08:44 * vincenz 's seriously stressed about some personal issues, so much so that I can't sleep due to heartburn, something I rarely get unless I chug like 10 coffees in a day
19:09:00 <vincenz> (is that the proper term?)
19:09:24 <vincenz> maybe not heartburn, but basically wher eyou feel the acid at the top of your stomach
19:09:28 <zarvok> wagle: I'm not sure, sorry
19:09:46 <wagle> zarvok: oh well..  thanks
19:09:58 <zarvok> sounds like heartburn to me, but who knows
19:10:15 <zarvok> according to wikipedia:
19:10:23 <zarvok> Heartburn or pyrosis is a painful or burning sensation in the esophagus, just below the breastbone caused by regurgitation of gastric acid.
19:10:31 <vincenz> yep
19:11:12 <Cale> Do you eat a lot of spicy food? :)
19:11:59 <vincenz> I have no issues when eating spicy food
19:12:03 <vincenz> nor when drinking coffee
19:12:06 <vincenz> unless I barely eat
19:12:09 <vincenz> and drink a pot or 2
19:22:07 <vincenz> zarvok: keep analyzing the file :)
19:23:24 <zarvok> vincenz: having fun yet? :)
19:23:30 <vincenz> :D
19:28:46 <Dreadshoot> dons: are you managing the haskell.org website?
19:29:29 <dons> nope.
19:34:06 <Cale> though dons does do a lot of work on it
19:34:52 <Dreadshoot> the second haskell tutorial link is dead
19:36:03 <Cale> on which page?
19:36:40 <Dreadshoot> http://www.haskell.org/learning.html under tutorials
19:36:42 <lambdabot> Title: Learning Haskell
19:37:06 <Cale> oh, hrm
19:37:36 <u221e> Stupid monads...
19:37:40 <Cale> That page should probably be removed
19:38:01 <Cale> there are better wiki pages that cover that :)
19:38:03 <Cale> http://www.haskell.org/haskellwiki/Books_and_tutorials
19:38:04 <lambdabot> Title: Books and tutorials - HaskellWiki
19:38:16 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
19:38:17 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
19:38:40 <zarvok> step 1: learn syntax
19:38:45 <zarvok> steps 2-5: understand monads
19:38:59 <Cale> hehe
19:39:02 <newsham> step 6: goto step 2
19:39:08 <zarvok> heh
19:39:15 <SamB_XP> no! tail call!
19:39:27 <mathewm> anyone know how Perl can read the script from stdin but still be able to read more from stdin after the Ctrl-D?  How can I run perl under haskell feeding the script from stdin of the Perl child?
19:39:27 <LordBrain> hmm i never read the scheme in 48 hours tutorial
19:39:28 <u221e> step 7: profit!
19:39:56 <newsham> perl reads the script from stdin?
19:40:02 <Cale> newsham: it can
19:40:15 <Cale> mathewm: perhaps just give it an EOF character
19:40:44 <newsham> what's an EOF character?
19:41:04 <mathewm> UNIX doesn't have an eof character, AFAIK
19:41:14 <u221e> Why doesn't GHC check that instances of a Monad obey the three monad rules?
19:41:20 <dons> u221e: how can it?
19:41:25 <dons> it would need a theorem prover
19:41:29 <mathewm> I wonder if perl does something with /dev/tty or the like...
19:41:38 <dons> in practice though, you _would_ check it, using either a hand proof, or QuickCheck
19:41:49 <stepcut> newsham: Cntl+d perhaps ?
19:42:13 <mathewm> I thought Ctrl-D was interpreted by the shell to close stdin
19:42:13 <dons> u221e: for a similar reason, it can't check that RULES are confluent and terminating and so on. the logic is too hard to embed in the compiler
19:42:18 <dons> so we fork it off to external tools
19:42:25 <mathewm> s/shell/terminal/
19:42:35 <stepcut> mathewm: yeah..
19:43:04 <newsham> >>> f = file('out')
19:43:04 <newsham> >>> s = f.read()
19:43:04 <newsham> >>> s
19:43:05 <newsham> 'testing\x04this'
19:43:08 <stepcut> http://www.stylusstudio.com/xmldev/200112/post80570.html
19:43:14 <newsham> I dont see how that ^D is gonna stop it
19:43:57 <newsham> can your perl script accept input from a fd other than stdin?
19:44:08 <mathewm> yes
19:44:17 <newsham> tell perl to read script from stdin, tell perl script to read input from fd=3, redirect stdin to fd=3
19:44:34 <newsham> (dup 3 to 0 at the top of the script, if you prefer)
19:44:40 <mathewm> well, I don't need to do that on the command-line and so I am wondering why
19:45:10 <newsham> what are you doing on the command line?  perl; <stuff>^d;<stuff> ?
19:45:47 <u221e> Haskell is probably the hardest language I've ever tried to learn...
19:46:00 <mathewm> yeah, myscript, then ctrl-D, then my script reads more input from stdin
19:46:17 <newsham> haskell's like chess.  easy to learn. hard to master.
19:46:31 <lispy> newsham: nice
19:46:46 <newsham> mathew: because the terminal can convince the program that it's at EOF (a read returns no data) and then allow more data to be read
19:46:50 <vincenz> anyone know the movie "serendipity"
19:46:51 <lispy> @remember newsham haskell's like chess.  easy to learn. hard to master.
19:46:52 <lambdabot> Done.
19:47:29 <LordBrain> i vaguely recall it, it had that guy my sister thinks is cute..
19:48:04 <newsham> perl's like poker, easy to learn, but often rewards you for your mistakes, making mastery virtually impossible.
19:49:02 * vincenz kicks someone in the nuts
19:49:13 <newsham> </meaningless philosphical whittisims>
19:49:13 <SamB_XP> OWw!
19:49:36 <Cale> so *that's* who was hiding back there
19:49:55 <vincenz> ARRRGH
19:50:01 * vincenz is going nuts
19:50:30 <newsham> i like cashews
19:51:11 <lispy> vincenz: just propose...it will make all your problems go away
19:51:19 <vincenz> lispy: hardly
19:51:30 <vincenz> lispy: she lives on the other side of the planet with her current boyfriend
19:51:38 <vincenz> and just told me to watch the movie "serendipity"
19:51:43 <vincenz> I don't fucking know what to think
19:51:52 <lispy> vincenz: suddenly i know who you mean to kick in the nuts...
19:52:06 <vincenz> yeah, and suddenly it's prolly also clear why I'm having insomnia
19:52:11 * lispy looks it up on imdb
19:52:41 <vincenz> the plotline
19:52:41 <vincenz> Plot Outline: A couple reunite years after the night they first met, fell in love, and separated, convinced that one day they'd end up together
19:52:59 <vincenz> in this case the projected amount of years = 2
19:53:05 <vincenz> for my case that is
19:53:05 <lispy> hmm
19:53:13 <vincenz> except, the world ain't hollywood
19:53:26 <lispy> so this wasn't the first time you two met?
19:53:31 <vincenz> itwas
19:53:32 <vincenz> it was
19:53:32 <Cale> Yeah, but you also don't have to not keep in touch.
19:53:33 <stepcut> http://www.nearlygood.com/video/kickedinnuts.html
19:53:35 <zarvok> yeah, I feel your pain.  It's the type of thing only time will help with
19:53:51 <vincenz> zarvok: the problem is that she was like two drops of water :(
19:54:16 <lispy> and your in a drought?
19:54:22 <vincenz> Cale: I know, but currently she's with her bf, and wants to keep it "just friends".... which means that she risks forgetting everything she felt and marrying the git she's with
19:54:24 <lispy> s/your/you're/
19:54:26 <vincenz> lispy: no I'm one of them
19:54:42 <vincenz> never heard of that expression?
19:54:48 <lispy> nope
19:54:49 <vincenz> but I should prolly take this elsewhere, it's seriously OT
19:54:54 <vincenz> "like two drops of water"
19:54:59 <vincenz> two persons match perfectly?
19:55:08 <Cale> vincenz: I know what you mean
19:55:09 * lispy points at #haskell-blah as "elsewhere"
19:55:37 <vincenz> Cale: so the questions is whether Is hould be happy or sad ... it's hard to tell
19:55:54 <Cale> Happy is usually more fun.
19:56:02 <vincenz> let's just get the ICFPC soon..... that way I can take my mind off things
19:56:06 * vincenz thanks zarvok 
19:56:13 <lispy> be glad that she's marrying that other git...she's probably like all other girls and a waste of time ;)
19:56:16 * zarvok bows
19:56:18 <vincenz> Cale: happy implies hope
19:56:22 <vincenz> lispy: she's not
19:56:45 <vincenz> if she said "I wanna come to europe to visit" I'd pay the ticket without a second's notice
19:56:56 <palomer> oh my my my
19:57:03 <lispy> I'll come to europe to visit!
19:57:07 <palomer> the ever repeating story
19:57:11 <vincenz> lispy: hah!
19:57:19 <lispy> it was worth a try...
19:57:38 <lispy> we can go get drunk together to forget about our sorrows
19:57:41 <palomer> rule of thumb: if you feel that you could make big sacrifices for a girl, you like the idea of the girl more than the girl herself
19:57:42 <Cale> vincenz: can't you see that lispy loves you?
19:57:51 <palomer> hands off, lispy's mine
19:58:00 * lispy blushes
19:58:19 <Pseudonym> Awwww.
19:58:19 <vincenz> palomer: or you found the lid that fits you
19:58:32 <lispy> vincenz: full of phrases today...
19:58:41 <vincenz> it's a dutch expression "for every jar there's a lid"
19:58:59 <palomer> that's an idea perpetrated by hollywood and is a huge lie
19:59:06 <palomer> you don't feel desperate for the lid that fits you
19:59:08 <lispy> she's your delta
19:59:14 <vincenz> lispy: to my omega?
19:59:22 <lispy> well, epsilon...
19:59:28 * vincenz scratches his head
19:59:30 <lispy> like the definition of continuous
19:59:35 <vincenz> oh rightio
19:59:36 <Cale> heh
19:59:45 <bringert> noone said that there is *exactly* one lid
19:59:46 <lispy> what do constructionists drink?
19:59:56 <lispy> peano noir
20:00:00 <palomer> there's a reason girls don't like it when you act desparate for them: they know that you want them because you think it'll complete you, that you don't actually like them for who they are
20:00:12 <Cale> I'll have to tell that one to my girlfriend-halfway-around-the-world
20:00:18 <vincenz> Cale: got one?
20:00:33 <Cale> yeah
20:00:40 * vincenz pats Cale on the back
20:00:47 <vincenz> well at least you have her
20:00:53 <vincenz> but yeah, the planet is way too big
20:00:54 <palomer> I find the idea that we're pots without lids to be uninspirational
20:01:13 <vincenz> palomer: you just broke up, it's obvious you're gonna be cynical
20:01:15 <newsham> they just want something they cant have
20:01:28 <newsham> like the rest of us
20:01:28 * lispy nods at newsham 
20:01:47 <palomer> vincenz: I'm still a huge fan of getting together with people
20:02:04 <palomer> vincenz: however, I realized that I was desperate for my ex-girlfriend because I had very little self-respect
20:02:05 <vincenz> you mean women?
20:02:14 <palomer> people
20:02:15 <Cale> The real solution to this problem is to mod out by all the lines passing through the centre of the Earth, turning the surface of the planet into a projective plane.
20:02:26 <palomer> that I thought of myself as a pot without a lid
20:02:28 <lispy> awwww
20:02:30 <vincenz> Cale: or barring that, startrek 'porters
20:02:56 * lispy has had a lid thing is...sometimes they find a new jar
20:02:58 <Cale> Hey, wouldn't it be cool if suddenly all the cities that had the same name were identified?
20:03:00 <palomer> once you realize that you already have a lid, you start appreciating people for who they are and not for how they can complete you
20:03:40 <Cale> That way, I could to to Paris or Waterloo Ontario, and visit my friends in Europe.
20:03:50 <vincenz> @localtime cale
20:03:55 <vincenz> @whereis cale
20:03:55 <lambdabot> Maybe you meant: where where+
20:04:00 <palomer> because noone can complete you, and the stories in your head that tell you otherwise are lies fabricated by society to keep you in check
20:04:02 <lispy> @where cale
20:04:03 <lambdabot> I know nothing about cale.
20:04:05 <Adamant> where Adamant
20:04:05 <lispy> :(
20:04:28 <vincenz> palomer: well we hit it off incredibly well, better than I imagine I would ever hit it off with someone else, even from a levelheaded perspective
20:04:28 <lispy> palomer: um..that's a bit extreme...i'd say just to make money
20:04:31 <Cale> http://www.haskell.org/hawiki/HaskellUserLocations
20:04:33 <lambdabot> Title: HaskellUserLocations - The Haskell Wiki
20:04:59 <palomer> the key clause in that statement is "better than I imagine I would ever hit it off with someone else"
20:05:01 <vincenz> damn
20:05:08 <vincenz> I need to go visit wagle
20:05:13 <vincenz> or SyntaxNinja
20:05:24 <lispy> or lispy
20:05:33 <vincenz> too far
20:05:40 <lispy> i live south of syntaxNinja
20:05:43 <vincenz> yeah
20:05:46 <vincenz> I need north of him
20:05:53 <lispy> oh, seattle?
20:05:56 <vincenz> B.C
20:06:00 <stepcut> Ok, I have a unboxed, mutable array of Floats, and 'Ptr Float' that points to malloc'd space big enough to hold the array contents. What is the most efficient way to copy the values from the MUArray to the space pointed at by 'Ptr Float' ?
20:06:00 <palomer> I read a) I can't imagine myself hitting it off nicely with very many people and b) she's somehow special, maybe made for me, maybe the thing that'll make me happy, more happy than I am now
20:06:23 <palomer> bah, enough palomer ranting
20:06:24 <palomer> @palomer
20:06:25 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
20:06:26 <vincenz> palomer: yes, but not out of low self-esteem, more out of levelheaded thinking
20:06:38 <palomer> vincenz: I thought so too
20:06:42 <lispy> vincenz: you want to say, passion :)
20:06:52 <vincenz> lispy: I meant point a
20:06:57 <palomer> bah
20:07:05 <palomer> from my experience, it's no use telling people these things
20:07:10 <palomer> they have to learn for themselves
20:07:23 <u221e> How does (Just [1, 2, 3]) match (x:xs)
20:07:24 <Cale> palomer: learn to be bitter and jaded?
20:07:34 <lispy> u221e: it shouldn't
20:07:36 <Cale> u221e: It doesn't
20:07:38 <palomer> oh no! it's so much nicer when you start seeing things the way they are!
20:07:49 <palomer> for one, you start having genuine respect and compassion
20:07:50 <Cale> heh
20:07:57 <Cale> "the way they are"
20:07:58 <palomer> you start appreciating people
20:07:59 <Plareplane> why are there multiple wikis on haskell.org
20:08:09 <Cale> You speak as if there is an objective existence.
20:08:15 <dons> stepcut: memcpy?
20:08:44 <u221e> @paste
20:08:45 <lambdabot> http://paste.lisp.org/new/haskell
20:09:01 <dons> Plareplane: one's old
20:09:08 <palomer> Cale: some argue that everyone is endowed with a consciousness that, when removed from the obsessive thinking and egocentric behavioural patterns, sees what is and does not judge or label
20:09:19 <palomer> Cale: it is the "you" that realizes that you're thinking
20:09:20 <dons> the 'hawiki' is the old wiki, we've recently switched to MediaWiki, or what's it caled.
20:09:46 <stepcut> dons: how do I get the Ptr addr of the mutable array --  'withStorableArray' perhaps ?
20:10:05 <palomer> once you start dreaming, making up stories, having expectations, confusing what's real and what's in your head, you lose your consciousness and you start living in your own reality
20:10:18 <palomer> you lose all sense of perspective
20:10:25 <palomer> (which is why break ups are so bad)
20:10:52 <Cale> The only reality you live in is your own.
20:10:54 <dons> stepcut: hmm, there's got to be a way
20:11:36 <audreyt> "why do you live in multiple realities?" "one's old - I've recently switched to MediaReality."
20:11:38 <vincenz> zarvok: ping
20:11:39 <stepcut> dons: I think withStorableArray might be the 'correct' answer, but it has the slow ForeignPtr problem prior to 6.6
20:11:43 <vincenz> zarvok: typoe in the announce list
20:11:48 <vincenz> zarvok: [icfp-annouce]
20:11:53 <dons> well, you can unwrap the constructor, and get down to a MutByteArray#, which is a pointer, if you're evil
20:11:54 <vincenz> not that it matters a lot
20:12:00 <palomer> Cale: I see two realities, the reality I live in when I start thinking and fantasizing, and the reality in which I live in when I realize that I'm daydreaming and that reality is happening right now
20:12:06 <dons> stepcut: well, its' not that slow to unwrap
20:12:14 <dons> if you only do it once
20:12:18 <vincenz> hiya dons
20:12:22 <dons> hey
20:12:33 <palomer> in my daydreaming reality, I'm always very smart and everyone praises me and I get laid a lot
20:12:41 <zarvok> vincenz: where
20:12:46 <vincenz> zarvok: the ML
20:12:53 <vincenz> subjet-line
20:12:57 <vincenz> subject even
20:12:59 <palomer> in my conscious reality, I simply am and nothing more.
20:13:16 <zarvok> vincenz:  haha, I see, interesting
20:13:36 <zarvok> vincenz: thanks for the heads up, we've fixed it and it will be correct from now on
20:13:48 <vincenz> zarvok: no prob, just trying to help :)
20:13:55 <stepcut> dons: I might choose to be evil for now. I am doing some real-time audio stuff -- so I need to copy a 4096 byte array to a Ptr () atleast ten times a second with very low overhead
20:13:57 <zarvok> vicnenz: I'm heading home, so I'm going to disappear fora  while.  Hope you feel better!
20:14:09 <zarvok> man I can't type today
20:14:11 <palomer> sometimes, in my daydreaming reality, I imagine people being made for me, imagine myself rich, imagine people meeting extraordinary expectations
20:14:37 <vincenz> zarvok: thx, talk to you soon
20:14:41 <palomer> anyways, enough palomer rant
20:14:51 <vincenz> zarvok: feel free to drop by #oasis, we started another channel for our team so it'll be a hangout channel
20:15:29 <lisppaste2> u221e pasted "Pattern..." at http://paste.lisp.org/display/22892
20:15:38 <u221e> How does that function work.
20:15:41 <u221e> I'm confused.
20:16:04 <vincenz> u221e: it's the maybe monad
20:16:16 <dons> Maybe monad
20:16:29 <dons> do the <-'s are unwrapping Justs
20:16:54 <u221e> How?
20:17:05 <u221e> Hm.
20:17:16 <dons> let's find that pesky monad
20:17:31 <dons> firstly
20:17:32 <dons> instance  Functor Maybe  where
20:17:32 <dons>     fmap _ Nothing       = Nothing
20:17:33 <dons>     fmap f (Just a)      = Just (f a)
20:17:39 <dons> which makes good sense
20:17:45 <dons> now,
20:17:46 <dons> instance  Monad Maybe  where
20:17:46 <dons>     (Just x) >>= k      = k x
20:17:46 <dons>     Nothing  >>= _      = Nothing
20:17:54 <dons> return              = Just
20:18:37 <dons> so, (x:xs) <- f is sugar for : Just y >>= \(x:xs) -> ...
20:18:43 <dons> so you get your Justs's removed
20:18:48 <u221e> Ah.
20:18:54 <dons> and the Nothings are noops
20:19:18 <vincenz> and stop flow
20:19:26 <dons> and then return has to pack things back into a Maybe, so it wraps a Just
20:19:38 <vincenz> it's like an early return with null or 0 from a c or java function
20:19:48 <dons> yeah, Nothing is a return () of sorts
20:20:06 <dons> in fact, fail _      = Nothing
20:20:35 <dons> u221e: you can see many of these 'container' structures as behaving like a Monad
20:20:45 <dons> that have a wel-defined 'sequencability'
20:20:49 <u221e> Isn't it hard to keep track of what each specific bind does depending on the monad?
20:20:57 <dons> yes
20:21:01 <vincenz> not really
20:21:05 <vincenz> it's typically straightforward
20:21:05 <dons> so , e.g. , the [a] monad isn't used that often.
20:21:18 <dons> well, people are confused when you slip a [a] monad in, vincenz
20:21:23 <vincenz> well yeah
20:21:27 <vincenz> was gonna say the [a] monad is the exception
20:21:29 <dons> though once you know what to look for, its fairly simple
20:21:46 <Dino_> This is the reason why you can't just 'let (x:xs) = f' ? Because that would leave it in the monadic wrapping?
20:21:48 <vincenz> that and the continuation  monad most likely, though I haven't tried it yet
20:21:59 <dons> Dino_: right!
20:22:08 <dons> the type would be wrong
20:22:16 <dons> it would be let Just (x:xs) = f
20:22:31 <dons> and for some monads you don't get access to the constructor, like IO
20:22:34 <Dino_> All of this gets boiled down to >>= and return notation -- it's there that the type fails?
20:22:43 <dons> you can't say, let (IO c) = getChar
20:22:51 <Korollary> no
20:23:00 <vincenz> dons: unless you're a sneaky bastard
20:23:06 <Korollary> the IO data constructor is not exported, is it>
20:23:10 <dons> vincenz: we prefer no snakes
20:23:13 <vincenz> :D
20:23:18 <dons> Korollary: yes, from GHC.IOBase.hs
20:23:43 <Korollary> sleaze... hmmm.
20:23:50 <Dino_> I understand, depends on the monad. As in Maybe, how you can catMaybes the data back out of there.
20:23:59 <u221e> Why is Maybe also an instance of Functor?
20:24:04 <dons> why not?
20:24:11 <dons> every monad is also a functor
20:24:12 <Cale> because it's a functor
20:24:29 <Cale> fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
20:24:42 <vincenz> Cale: they should invente a deep fmap
20:24:48 <audreyt> fmapM ?
20:24:49 <dons> oh, I see we don't actually have Functor f => Monad f anymore
20:24:56 <vincenz> audreyt: that's not a depe one, just a monad one
20:24:57 <Cale> dons: right
20:24:58 <dons> we used to. /me cites gofer again
20:25:01 <audreyt> everywhereM?
20:25:06 <u221e> Well I don't know what functors are yet ;P
20:25:08 <vincenz> @type everywhereM
20:25:09 <lambdabot> Not in scope: `everywhereM'
20:25:24 <Cale> u221e: did you read Monads as Containers yet? :)
20:25:27 <audreyt> @type Data.Generics.Schemes.everywhereM
20:25:28 <lambdabot> forall a (m :: * -> *). (Data.Generics.Basics.Data a, Monad m) => Data.Generics.Aliases.GenericM m -> a -> m a
20:25:28 <bringert> you need ghc 6.5 for that
20:25:31 <dons> class  Functor f  where
20:25:34 <dons>     fmap        :: (a -> b) -> f a -> f b
20:25:35 <Dino_> audreyt: Oh, something I wanted to ask: Is there a YAML lib for Haskell?
20:25:35 <dons> u221e: ^^
20:25:41 <u221e> Cale, well... I tried.
20:25:42 <audreyt> Dino_: yes, it's called HsSyck
20:25:53 <vincenz> audreyt: he's sick?
20:25:54 <Dino_> audreyt: Oh, that's awesome!
20:25:55 <bringert> not generics that is
20:25:57 <dons> functors behave like 'map, u221e
20:25:59 <dons> they obye,
20:26:00 <dons> > fmap id  ==  id
20:26:00 <dons> > fmap (f . g)  ==  fmap f . fmap g
20:26:01 <lambdabot>  ghc-6.5: unknown package:lambdabot
20:26:01 <lambdabot>  ghc-6.5: unknown package:lambdabot
20:26:06 <dons> nice error!
20:26:10 <vincenz> :D
20:26:12 <dons> > 1+1
20:26:12 <lambdabot>  ghc-6.5: unknown package:lambdabot
20:26:16 <vincenz> woot
20:26:16 <dons> ah, i broke it
20:26:18 <audreyt> Dino_: I'll cabal-put it when there is a cabal-put
20:26:28 <vincenz> @type id
20:26:29 <lambdabot> forall a. a -> a
20:26:32 <audreyt> Dino_: for the moment, http://svn.openfoundry.org/pugs/third-party/HsSyck/
20:26:34 <lambdabot> Title: Revision 11637: /third-party/HsSyck
20:26:45 <vincenz> audreyt: you dong icfpc?
20:26:46 <vincenz> doing
20:26:53 <dons> > 1+2
20:26:53 <lambdabot>  ghc-6.5: unknown package:lambdabot
20:26:54 <Dino_> audreyt: Thank you. I totally prefer YAML over XML for a lot of things.
20:26:57 <audreyt> vincenz: no, OSCON and OOPSLA is too much
20:26:58 <Korollary> hey mathewm
20:27:08 <vincenz> audreyt: I mean the contest
20:27:09 <Korollary> blah
20:27:10 <audreyt> Dino_: also pugs has DrIFT for YAML <-> arbitrary haskell data
20:27:23 <vincenz> audreyt: why is most of syck written in c?
20:27:30 <audreyt> Dino_: in http://svn.openfoundry.org/pugs/src/DrIFT/
20:27:31 <lambdabot> Title: Revision 11637: /src/DrIFT
20:27:40 <audreyt> vincenz: because it's a common extension for Ruby and Perl and Python and whatnot
20:27:48 <audreyt> vincenz: and their FFIs only support C really well
20:27:52 <vincenz> ah
20:27:54 <vincenz> :)
20:28:00 <vincenz> you're the author of pugs?
20:28:03 <audreyt> yeah.
20:28:06 <vincenz> cool
20:28:07 <dons> int-e, you broke lambdabot :)
20:28:14 <vincenz> dons: what'd he do?
20:28:25 * dons busy fixing..
20:28:43 <Dino_> audreyt: Cool, thanks again.
20:28:53 <int-e> dons: I did?
20:28:58 <dons> > 1+1
20:28:59 <lambdabot>  ghc-6.5: unknown package:lambdabot
20:29:01 <dons> ;)
20:29:19 <vincenz> how?
20:29:25 <vincenz> we want to reproduce this error to ensure it's no anomaly
20:29:27 <int-e> dons: 'works for me' sorry, I should've included a warning in that mail.
20:29:30 <dons> also, the 'exposed' line in .cabal doesn't seem to work very often?
20:29:37 <dons> is it an old cabal, or a new cabal that needs it?
20:29:49 <int-e> dons: I've tested with 6.5
20:29:50 <vincenz> anyways
20:29:55 <vincenz> 5:30am, time to try sleeping again
20:29:57 * vincenz wave
20:29:58 <dons> int-e, interesting.
20:29:58 <int-e> dons: and the cabal that comes with it
20:30:50 <int-e> dons: except for the 'exposed: True' flag. But actually I think cabal ignores that.
20:30:56 <dons> . 1+1
20:31:02 <dons> > 1+1
20:31:03 <lambdabot>  2
20:31:11 <int-e> dons: but ... when you install lambdabot, can it write that package file?
20:31:14 <dons> > fmap id  ==  id
20:31:15 <lambdabot>  add an instance declaration for (Eq (f a -> f a))
20:31:16 <lambdabot>   In the definition of ...
20:31:18 <dons> hehe
20:31:19 <vincenz> > 1+1
20:31:21 <lambdabot>  2
20:31:31 <dons> Cale, can you write me such an instance of Eq ? ;)
20:32:18 <vincenz> dons: at that point you just give the input-output relationship of some program and have it find the optimal version in the Eq-class :)
20:32:43 <dons> in general, we're missing Eq (a -> b) I feel . hehe
20:32:54 * vincenz goes to try to nap
20:32:56 <vincenz> bbye
20:33:00 <int-e> instance Eq a where x == y = True *ducks and runs*
20:33:09 <dons> heh
20:33:21 <vincenz> that's definitely a valid, albeit useless, one
20:33:22 <int-e> (needs overlapping instances)
20:33:33 <audreyt> dons: you can use the perl5 coercion rule
20:33:33 <vincenz> oh wait
20:33:35 <vincenz> nm
20:33:53 <audreyt> instance Eq (a->b) where x == y = unsafeCoerce# x == (unsafeCoerce# y :: Int)
20:33:59 <int-e> but maybe instance (Bounded a, Eq b) => Eq (a->b)  could be done.
20:34:03 <dons> audreyt: just thinking that :)
20:34:10 <audreyt> it's actually not a bad idea
20:34:11 <dons> so we could finally write sqrt sqrt
20:34:21 <audreyt> well, you need a Num instance too
20:34:28 <audreyt> but yeah
20:34:36 <dons> well, that would also be fun.
20:34:38 <int-e> instance Num (a -> a) where (+) = (.)
20:34:47 <dons> oh, interesting.
20:35:02 * audreyt is reminded of Spirit
20:35:02 <dons> what about (*)
20:35:06 <Cale> where + is composition?
20:35:11 <int-e> err. (a -> a) -> a -> a
20:35:22 <dons> now, we aready have
20:35:22 <audreyt> (the C++ equiv of parsec, where they overload prefix * to mean star quantifier)
20:35:24 <dons> instance Functor ((->) r) where
20:35:24 <dons>     fmap = (.)
20:35:24 <dons> instance Monad ((->) r) where
20:35:24 <dons>     return = const
20:35:26 <dons>     f >>= k = \ r -> k (f r) r
20:35:33 <int-e> church numerals.
20:35:34 <dons> so I think we could add some more instances for ->
20:35:36 <audreyt> *foo  // (many foo)
20:36:47 <int-e> I think I messed something up there. oh well. (a + b) f = (a f) . (b f)
20:36:49 <int-e> sorry :)
20:37:12 <int-e> (*) = (.) then.
20:37:47 <int-e> and fromIntegral n f = (!!fromIntegral n) . iterate f
20:42:58 <Dino_> Oho, I see that YAML::Syck exists too.
20:43:34 <audreyt> it is, coincidentally, also mine.
20:44:13 <Dino_> audreyt: I see that. Actually, the reason I asked you about YAML in the first place was the funny note that used to be in YAML's perldoc until recently.
20:44:25 <audreyt> yeah :)
20:44:48 <audreyt> it's now replaced by "NOTE: Audrey Tang has actually completed this module and it works great and is 10 times faster than YAML.pm."
20:46:00 <vincenz> :(
20:46:11 <dons> hehe
20:58:55 * dylan wonders if svk defaults to using YAML::Syck if it is installed.
20:59:33 <audreyt> I think I made that patch. yes.
21:00:25 <dylan> cool.
21:01:15 * dylan mutters things about debian-amd64 and various perl modules.
21:16:19 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]'
21:16:19 --- topic: set by kosmikus on [Mon Jul 17 00:59:42 2006]
21:16:19 --- names: list (clog Bobstopper SamB ramkrsna jewel norpan bdash tessier Stinger_ palomer genneth locksy jmob Pupeno seth_ petekaz satan Philippa |Steve| JohnMeacham Khisanth Nomius AtnNn om Pegazus greenrd araujo wolverian juhp moonlite SamB_XP liyang int-e drbean dylan ksandstr cods Dreadshoot dropdrive Lunar^ Spark Averell svens_ tennin dgoldsmith scsibug vincenz Nioate_ ex__nor Azmo MarcWebe1 slipstream bringert cpatrick ski pimaniac kolmodin Trixsey)
21:16:19 --- names: list (lambdabot bolrod jer danly lilo dons shawn ulfdoz cjay borism mornfall reppie kpk magagr xerox ricebowl gdsx nnunley audreyt earthy jmob| _Codex Twig-raptor david_ Wallbraker ibid eivuokko kosmikus SimonRC rafl gds toyz nomeata df_ dany2k)
21:20:22 <dons> ?yow
21:20:22 <lambdabot> It's a lot of fun being alive ... I wonder if my bed is made?!?
21:34:13 <u221e> Here is another function I don't understand from the All about Monads tutorial
21:34:22 <u221e> http://www.nomaware.com/monads/html/solution3.html
21:34:23 <lambdabot> Title: Solution to exercise 3
21:34:39 <u221e> I assume it's the same thing as last time but with Lists.
21:35:42 <u221e> The grandparent father I'm having trouble with. I understand the parent function
21:51:56 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]'
21:51:56 --- topic: set by kosmikus on [Mon Jul 17 00:59:42 2006]
21:51:56 --- names: list (clog Twig-raptor jmob____ magagr dany2k cjay Dino_ gdsx satan ibid wolverian Averell alec david_ nomeata zarvok locksy tennin rafl woggle palomer sudoer JohnMeacham seth_ om Philippa |Steve| Azmo scsibug genneth juhp araujo Pegazus Pupeno AtnNn danly ex__nor Pete_I ramkrsna _Codex Nomius Dreadshoot moonlite vincenz SamB_XP bdash svens Spark mornfall dropdrive slipstream Khisanth Nioate petekaz cods drbean audreyt ricebowl nnunley gds)
21:51:56 --- names: list (SimonRC liyang dylan_ ksandstr_ reppie_ df Lunar^_ eivuokko_ thedward cmeme LoganH lorne scw Hmm_| jgrimes aleator CLxyz tic johs edwinb integral sieni psnl orbitz mattam neologism dvekravy emertens Igloo _calvin_ Nanar joe_k WillKW Korollary seafood u221e mauke ozone wchogg dcoutts arguile Poeir johnnowak kpreid earthy borism ulfdoz shawn dons lilo jer bolrod lambdabot Trixsey kolmodin pimaniac ski cpatrick bringert int-e greenrd Stinger_)
21:51:56 --- names: list (tessier norpan jewel SamB Bobstopper tessier_ noclouds resiak mux_ sellout Plareplane jargonjustin mathrick blackdog)
21:52:28 <dons> ?fptools
21:52:29 <lambdabot>  not available
21:52:33 <dons> ?fptools Data.List
21:52:33 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
21:52:39 <dons> u221e: look in GHC/Base.hs
21:52:54 <dons> http://darcs.haskell.org/packages/base/GHC/Base.lhs
21:53:21 <dons> well, why not just look at it here:
21:53:23 <dons> instance Functor [] where
21:53:23 <dons>     fmap = map
21:53:23 <dons> instance  Monad []  where
21:53:23 <dons>     m >>= k             = foldr ((++) . k) [] m
21:53:25 <dons>     m >> k              = foldr ((++) . (\ _ -> k)) [] m
21:53:28 <dons>     return x            = [x]
21:53:30 <dons>     fail _              = []
21:53:36 <dons> now, start scratching your head.
21:54:14 <jargonjustin> dons: I thought it was just: (>>=) = concatMap
21:54:30 <jargonjustin> And the definition of >> was implied by the Monad class definition.
21:54:57 <dons> right.
21:55:01 <dons> foldr ((++) . k) [] m == concatMap
21:55:06 <jgrimes> oh ok
21:55:20 <dons> -- | Map a function over a list and concatenate the results.
21:55:21 <dons> concatMap               :: (a -> [b]) -> [a] -> [b]
21:55:21 <dons> concatMap f             =  foldr ((++) . f) []
22:02:53 <u221e> I don't even understand exercise 4
22:03:02 <u221e> http://www.nomaware.com/monads/html/exercises.html
22:03:03 <lambdabot> Title: Exercises
22:03:30 <jargonjustin> u221e: The idea is that you can decouple your code from a particular Monad.
22:03:39 <jargonjustin> You code is the computations and the computation is the pipeline.
22:03:57 <jargonjustin> If you use general operators in the Monad class you can change which Monad you use.
22:04:05 <jargonjustin> (without changing the underlying code)
22:04:30 <u221e> I don't see what they has to do with the sheep example.
22:05:00 <jargonjustin> u221e: Write a grandparent function that can work on an List or a Maybe.
22:05:29 <u221e> oh, hmm...
22:05:56 <jargonjustin> u221e: And that is the best Monad guide for Haskell by the way :-)
22:07:18 <audreyt> I still think they should be renamed Actions for beginners to understand :)
22:07:59 <glguy> monads?
22:08:04 <audreyt> yeah.
22:08:31 <dons> now, idea, I wonder how much the ease of refactoring haskell has contributed to the speed at which new language features have been embraced
22:08:35 <audreyt> and Monad Transformers -> Action Layers
22:08:54 <audreyt> dons: you mean at the GHC level?
22:08:56 <dons> if the language was harder to refactor, we'd be less keen to throw out things, and play with other games
22:09:00 <audreyt> or at the library level
22:09:06 <dons> audreyt: just thinking about language features/haskell'
22:09:09 <audreyt> ah. library rewrite-your-code level
22:09:12 <glguy> or you could just write those two statements in a tutorial
22:09:17 <dons> and a comment that people weren't too worried about backwards compat
22:09:18 <audreyt> glguy: I did just that
22:09:40 <dons> which reminded me of spj's comment in the history of haskell that we were a 'nimble' community
22:10:08 <dons> so, i think if the language was harder to refactor, language development would have been slower
22:10:17 <dons> since the cost of switching to new ideas is higher
22:10:24 <foxy> @djinn a -> b -> c
22:10:25 <lambdabot> -- f cannot be realized.
22:10:28 <audreyt> glguy: http://www.pugscode.org/osdc/haskell.xul?page=44
22:11:11 <glguy> i think that website is misconfigured
22:11:20 <audreyt> glguy: er, Gecko only, sorry
22:11:23 <audreyt> Firefox etc
22:11:27 <audreyt> dons: also the language is not tied to IDEs
22:11:49 <dons> that would help as well. keeps things light and unencumbered
22:11:51 <audreyt> which is imho one of the more important factor to new ideas
22:12:00 <dons> interesting
22:12:11 <audreyt> e.g. the LINQ team spent lots of time tweaking VS to support their ideas
22:12:19 <dons> huh
22:12:21 <audreyt> and had to drop or delay ideas that can't be realized easily in visual studio
22:12:23 <dons> what a pain!
22:12:28 <glguy> linq was neat
22:12:37 <glguy> but felt out of plsce
22:13:09 <audreyt> dons: on the other hand, Programmatica or any of those refactoring browsers never really worked
22:13:18 <dons> yeah, the language moved to fast for them
22:13:25 <audreyt> which is the counterpoint
22:13:37 <dons> oh, not so much refactoring in that sense
22:13:50 <dons> just that users know that they can fix their code with little effort
22:13:55 <dons> say, when we brought in cabal,
22:14:04 <audreyt> right. but I mean that "little effort" can't easily be done automagically
22:14:09 <dons> or broke FiniteMap
22:14:14 <audreyt> precisely because things are allowed to move fast and break stuff
22:14:23 <dons> right. we don't want to be tied to tools
22:14:32 <audreyt> which means it's sorta self-selection
22:14:41 <audreyt> only people who can afford to write or upgrade their tools can keep up
22:14:52 <dons> and companies like galois that really depend on things keep their own branches
22:14:59 <audreyt> yup.
22:15:03 <dons> since they know they're not going to get backwards compat
22:15:04 <audreyt> and that's fine, I think
22:15:06 <dons> hmm
22:15:29 <audreyt> for eternally back compat stable languages, COBOL is down in the hallway, second door to the left.
22:15:34 <dons> maybe 'things are going to break' as our default, is important.
22:15:48 <dons> h98 certainly helped though
22:15:57 <dons> gives people something to teach
22:15:58 <dons> for example
22:16:00 <u221e> The haskell mode for emacs is great ;)
22:16:01 <audreyt> stable snapshots can help
22:16:02 <dons> and write bookes about
22:16:08 <vincenz> hmm
22:16:09 <dons> audreyt: yes. stable is very good
22:16:12 <vincenz> dons: what do you use for webpage
22:16:17 * vincenz needs a new webpage system
22:16:21 <dons> vincenz: ? html/vim :)
22:16:21 <vincenz> the current is just not a good one
22:16:23 <audreyt> but to use hs productively, as in real-world, the experimental branch is very important for evolution
22:16:24 <dons> and a bit of css
22:16:33 <vincenz> dons: that's not very handy for bloggy-style things
22:16:38 <dons> vincenz: you like my layout?
22:16:45 <vincenz> I think so
22:16:46 <vincenz> linky
22:16:49 <bringert> vincenz: have you seen hope?
22:16:49 <vincenz> @version
22:16:49 <lambdabot> lambdabot 4p28, GHC 6.5 (OpenBSD i386 )
22:16:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:16:51 <dons> vincenz: oh, its in darcs
22:16:54 <bringert> @where hope
22:16:55 <lambdabot> http://hope.bringert.net/
22:16:58 <audreyt> though I've yet to see language evolution taking en masse in library space... preprocessors and TH are more often than not proof of concept
22:16:59 <vincenz> bringert: can't use
22:17:02 <dons> sticking it in darcs makes things easier, vincenz
22:17:21 <dons> audreyt: yes. TH might be a failure, in hindsight
22:17:22 <vincenz> bringert: my webserver is ftp only
22:17:25 <vincenz> dons: you mean the website?
22:17:27 <dons> well, its a proof of concept
22:17:30 <dons> vincenz: yes.
22:17:38 <vincenz> dons: I agree, darcs is a cool solution for many things
22:17:38 <bringert> vincenz: no GCI?
22:17:41 <vincenz> I use it for my research as well
22:17:43 <vincenz> bringert: GCI?
22:17:48 <dons> i just edit local files, so its more nimble than hacking the web site directly
22:17:48 <bringert> eg, CGI
22:17:50 <vincenz> bringert: CGI?
22:17:50 <bringert> eh
22:17:52 <vincenz> yeah
22:17:53 <vincenz> possibly
22:17:55 <vincenz> tho not sure what
22:17:57 <vincenz> it does php
22:18:00 <vincenz> that's for sure
22:18:17 <vincenz> dons: well I guess I do have a blog
22:18:24 <vincenz> dons: just that atm, the wiki is handy for our icfcp team :)
22:18:27 <vincenz> and we have a name \o/
22:18:29 <vincenz> Lazy bottoms
22:18:32 <dons> audreyt: this was perl5 (and earlier) philosophy too, yeah? break things/screw compat?
22:18:40 <foxy> dons, do you think having a darcs-like interface between views and internal buffer is overkill (in Yi)?
22:18:45 <dons> hmm.
22:18:58 <dons> a darcs interface to _undo_ makes sense.
22:19:05 <vincenz> bringert: anyways, I'll continue hacking today, the tree itself is done, now I gotta do compos
22:19:06 <audreyt> dons: yes, but most of it takes place in library space
22:19:08 <dons> but views/buffers? how'd it work?
22:19:12 <dons> audreyt: ah true.
22:19:16 <vincenz> bringert: I'm not very familiar with the conferences for FPL.... where do you think this would fit in?
22:19:20 <vincenz> bringert: ICFP pearl/
22:19:21 <vincenz> ?
22:19:25 <dons> audreyt: we're just reaching the start of that point,
22:19:38 <audreyt> yeah. with a solid way to declare dependencies on
22:19:41 <vincenz> bringert: workshop?
22:19:42 <dons> more dev is now happening in libs than compiler, in the last 2 years or so
22:19:45 <audreyt> preprocess-or-dialect-shipped-as-libraries
22:19:48 <foxy> well, the example I'm thinking of is an html document, you could have a source window and a display window, but you want to be able to edit either of them...
22:19:50 <bringert> vincenz: possibly, maybe Haskell workshop would be better
22:19:54 * vincenz nods
22:19:55 <audreyt> then innovation like Omega can happen as library too
22:20:04 <vincenz> bringert: well it'd be cool to get in touch with the community :)
22:20:08 <vincenz> bringert: I might like to migrate postphd
22:20:24 <audreyt> and "part of GHC core library" stops being important
22:20:30 <vincenz> dons: and yeah, nice layout :)
22:20:37 <vincenz> dons: clean, sleek, googlesque
22:20:40 <glguy> I've been listening to NPR all day (National Public Radio, for non-US peeps) and they've really latched onto this term of "disproportionate response" (no I don't care to discuss the actual issue)
22:20:48 <dons> googlesque, eh/
22:20:55 <audreyt> but it took CPAN 10 years to reach this point...
22:20:57 <vincenz> it's the new word for "zen"
22:21:18 <vincenz> glguy: that's not really a new term
22:21:31 <dons> audreyt: yeah. signs are there, but the language is harder to get into, slowing down adoption, wrt. perl
22:21:39 <glguy> vincenz: but I've heard it used over and over and over today :)
22:21:40 <glguy> and over
22:21:51 <vincenz> under what topic?
22:22:00 <audreyt> dons: I think ready libraries with relevant haddocks can ease entry to any language
22:22:09 <audreyt> dons: as a language per se, Hs isn't that harder
22:22:18 <audreyt> people learn from library code that they can put into immediate use
22:22:22 <vincenz> dons: on the +side, I might get a uni account soon, which will give me ssh access so a better manageability of my website \o/
22:22:22 <dons> you think? we dont' have many 'script kiddies'
22:22:28 <glguy> vincenz: the Israel <-> Hezbolla issue
22:22:34 <audreyt> dons: precisely because there are very few rootkits in Hs
22:22:40 <dons> and i suspect its the theory, maybe the culture of haskell is too geeky.
22:22:46 <audreyt> there's nothing inherent in Hs that makes rootkits hard to write in it
22:22:48 <dons> audreyt: heh
22:22:52 <audreyt> it's just the community doesn't produce it
22:22:53 <dons> no, of course
22:23:04 <vincenz> different field of interest
22:23:09 <dons> i should say, we don't have many 14 yo hs hackers
22:23:12 <vincenz> rootkits people are easyfix people
22:23:16 <dons> but theres many kids playing withperl
22:23:17 <vincenz> not algorithmic people
22:23:18 <dons> why?
22:23:29 <vincenz> just get the right bytes in there by any means possible
22:23:35 <dons> perl just works, who cares about runtime bugs -- you learn about testing a few years later
22:23:38 <glguy> How did Haskell based rootkits come up?
22:23:46 <vincenz> glguy: audreyt
22:23:49 <dons> but type theory, too hard maybe? for the kids?
22:23:54 <vincenz> dons: possibly
22:24:10 <vincenz> dons: not to mention how the first tutorials of haskell don't treat IO at all
22:24:13 <vincenz> besides printing :D
22:24:23 <dons> so i suspect dynamically typed langs, that just work (bugs and all) will always be more popular with the masses
22:24:24 <audreyt> dons: though if Helium is made more popular
22:24:40 <dons> since most people don't understand bug theory ;)
22:24:48 <vincenz> dons: yeah and the tutorials typically handle sockets and files much sooner (which is not so in haskell, if they are at all present)
22:24:52 <u221e> I don't see how the All about Monads tutorial can expect a newbie to do exercise 4.
22:24:54 <audreyt> yeah. I think an incrementally-typed language is always like, easier :)
22:24:55 <glguy> Haskell should encasulate bugs in a type class
22:25:11 <glguy> u221e: link?
22:25:23 <audreyt> class Bug a where { error :: x -> a }
22:25:30 <vincenz> haskell is short code for algos, ruby/perl/python is short code for io/socks
22:26:20 <audreyt> chromatic in perl.com observed, after learning haskell for a few weeks
22:26:23 <dons> maybe if we somehow sold ourselves as the Formula1 of programming langauges :)
22:26:25 <glguy> u221e: nm
22:26:31 <audreyt> that if monadic IO was present at the very beginning
22:26:39 <audreyt> then maybe the do-notation will be made even shorter
22:26:41 * aleator wonders if his goal to replace matlab with haskell was misguided..
22:26:49 <dons> i.e. sexy, professional, for engineers, cutting edge
22:26:54 <dons> kids would want to find out
22:27:03 <audreyt> to allow easily nested joins and lifts
22:27:10 <dons> but we sell it in this way: its good for you to suffer these type errors
22:27:12 <vincenz> dons: we don't have the women, champagne and fast cars
22:27:27 <vincenz> (not to mention millions of dollars)
22:27:34 <glguy> vincenz: are you talking about the riposte to Hackers and Painters?
22:27:36 <dons> i think we don't emphasise enough that haskell is the cutting edge of PL dev
22:27:45 <jgrimes> heh, no matter how hard I try I can't sell haskell to any of my other computer science sophomore friends.
22:27:47 <vincenz> lol, from NG: believe that a great part of the future of compiler technology is in
22:27:50 <vincenz> adaptive parsing. I am biased because AP is my main CS love. I'm crazy
22:27:52 <vincenz> enough to believe that separation of syntax and semantics is a Bad Thing if
22:27:55 <vincenz> we consider the kinds of parsing problems that fall just outside of
22:28:04 <vincenz> traditional compiler tasks
22:28:05 <vincenz> whoops
22:28:05 <glguy> jgrimes: that means that they aren't in it for the love of the theory :(
22:28:08 <vincenz> thought that'd be less
22:28:10 <vincenz> glguy: huh?
22:28:14 <vincenz> glguy: never read that
22:28:22 <vincenz> nor the H&P thingy
22:28:27 <dons> instead, we go on and on about high assurance, bug free, productivity. the kids don't care. they just want something cool.
22:28:40 <jgrimes> glguy, yeah, I suppose
22:28:40 <vincenz> dons: like streaming bytes over a socket :)
22:28:42 <audreyt> dons: when I visited MS, I had a task to write some XML tree transformer to bridge ASTs
22:28:45 <glguy> vincenz: hackers and painters is by Paul Graham and he compares Hackers to painters
22:28:49 <vincenz> glguy: oh
22:28:55 <vincenz> glguy: in what way?
22:29:11 <vincenz> "coding is artistic, you don't get money, it's a lifestyle"
22:29:12 <audreyt> dons: I read the arrow-based XML parsing paper of XML Toolbox
22:29:13 <glguy> vincenz: the riposte is written from the POV of a painter that says they have nothing in common and that Paul is jelous that painters get laid all the time
22:29:13 <vincenz> in 100 pages?
22:29:22 <audreyt> dons: and it is indeed very enlightening, and great, and all
22:29:38 <Korollary> jgrimes: That is not unusual. There are still students that are taught scheme in introductory courses and hate its guts.
22:29:46 <audreyt> dons: but the syntax is so unforgiving, it turned out Perl / VB, even JavaScript E4X, would make the task much easier
22:29:48 <vincenz> glguy: yeah the artists don't want to be equated as hackers, we have a bad name :P
22:29:50 <audreyt> (and not really less robust)
22:30:16 <dons> we haskell hackers have this hair shirt to wear, yeah?
22:30:26 <jgrimes> Korollary, heh, it's odd. They complain and complain about Java and then when I show them haskell they aren't even interested.
22:30:29 <glguy> What's this hair shirt you guys keep talking about
22:30:43 <audreyt> and the good syntax in haskell land -- casing over XML literals with HSP -- fails installation due to some cabal API changes :)
22:30:54 <dons> bah
22:31:04 <audreyt> and I suspect nobody is really using HSP to case over XML literals in an application
22:31:14 <glguy> HSP?
22:31:16 <audreyt> at least, it's not in the community report, and google doesn't find an example
22:31:19 <jgrimes> Korollary, of course I don't suppose it is -that- odd at this point. Most of them haven't realized computer science isn't what they are interested in yet.
22:31:20 <JohnMeacham> audreyt: The problem with semi-typing is that it is sort of the worst of several worlds.. The type system of haskell is advanced enough that catching errors is just a side effect, the types actually let you express and control static properties of your program. for simple examples see my JRegex and GetOptions modules, though, they are just a simple example. I think this is something a lot of people raised with C/Java etc style typing don't realize, si
22:31:20 <JohnMeacham> nce they are taught that types are just for catching errors and not a programming tool to let you express things you couldn't otherwise.
22:31:20 <vincenz> glguy: oh it's the latest and greatest in biologically aware clothing, a shirt made from pure horse-ass-hair
22:32:01 <audreyt> JohnMeacham: oh, I totally agree. but a language can provide annotation-based switch of strategy
22:32:03 <vincenz> JohnMeacham: yeah, for even simple example, change the monad of an action
22:32:10 <vincenz> simpler
22:32:12 <JohnMeacham> I am using semi-typing to include a variety of algorithms, not a particular one.
22:32:12 <glguy> java people are taught that types are for catching errors??
22:32:15 <jargonjustin> JohnMeacham: You just articulated why Haskell is the only statically typed language I've really loved.
22:32:15 <audreyt> JohnMeacham: for example, bang patterns allows mixing evaluation strategies much easier
22:32:21 <dons> JohnMeacham: right. its not widely known that types are for properties.
22:32:31 <u221e> After I learn Monads I'll have to write a better tutorial on them then anyone else :(
22:32:32 <JohnMeacham> glguy: java is an error to begin with... "why didn't the type system catch that?!"
22:32:52 <audreyt> JohnMeacham: and at times I'd wished I can have fromDynamic and callDynamic inserted for me by annotations
22:33:08 <audreyt> as well as a good way to note runtime constraint assertions
22:33:15 <audreyt> instead of having to code it all in GADT-level
22:33:17 <vincenz> dons: that's exactly the reason I switched to haskell, behaviour-change through type-change, though I admit, haskell is not tc'ed enough for that yet
22:33:19 <glguy> I don't understand a single argument against a static - inferred type system
22:33:39 <glguy> I don't see why you would want to wait until run time to find the errors
22:33:39 <audreyt> JohnMeacham: none of these is meant to take things away from the static power; it's just making some dynamicness easier to declare
22:33:44 <JohnMeacham> I am not sure how to best explain this to people other than saying "learn haskell, then it will be obvious". perhaps we just need a different name than 'strong typing' to imply things above and beyond just error detection.
22:33:48 <vincenz> dons: for instance "instance (Num a) => Num (Profiled a) where ...
22:33:50 <audreyt> glguy: some errors can't be found in compile time :)
22:34:22 <glguy> audreyt: of course... but why would you want to not catch the ones that you can at compile time
22:34:33 <bringert> glguy: static typing disallows some things which are not errors
22:34:34 <JohnMeacham> audreyt: yeah, I have been meaning to write up a proposal for some sugar dealing with existentials to make them easier to work with...
22:34:35 <dons> we had an interesting conversatoin yesterday, where it was pointed out that any decent engineer in a dynamically typed language has to duplicate the work of the type checker anyway, via unit-tests,
22:34:51 <audreyt> glguy: if it takes more effort to declare those than write spec-based tests, I'll go with spec-based tests any time
22:34:58 <vincenz> there are corner cases where dynlanguages are nicer, imagine using scheme with macros to define new semantics for experimentation
22:35:02 <dons> but yet can't be sure they've exercised all code paths (and hence all runtime type checks) without actually writing a type checker
22:35:08 <vincenz> tho most languages dont' give you that kind of flexibility
22:35:09 <audreyt> JohnMeacham: ok, then I think we are actually in violent agreement
22:35:44 <Korollary> dons: He doesn't need to go that far with unit tests, imho.
22:35:58 <glguy> I've seen examples where people argue that they want to be able to say: if predicate then 42 else "forty-two"
22:35:59 <vincenz> JohnMeacham: you the guy from repetea?
22:36:03 <glguy> yuck
22:36:09 <dons> no, and you wouldn't usually. but then you don't have the same assurance you get from a type check
22:36:17 <audreyt> glguy: to wit: people write QuickCheck code even though they can write the equivalent thing as proof-carrying code in GADT
22:36:25 <audreyt> but the latter is just so much harder
22:36:26 <JohnMeacham> dons: or by being the author of the language you are using and extending it. :) I think this is why these untyped languages keep branching... for instance, perls built in concept of a list vs scalar context can simply be implemented in a much more general way with type classes.
22:36:35 <JohnMeacham> vincenz: yeah,
22:36:38 <araujo> glguy, they really don't wan to say that :-)
22:36:52 <glguy> audreyt: I don't know much about GADTs yet (I have a paper downloaded but have yet to read it)
22:36:55 <vincenz> JohnMeacham: me wants class aliases :)
22:37:00 <Korollary> dons: Possibly they don't value that kind of assurance as much as you do.
22:37:08 <dons> audreyt: interesting. can we say the goal of type systems have been to move more and more unit tests into static checks?
22:37:21 <dons> automated, static checks
22:37:32 <JohnMeacham> vincenz: me too! if someone wants a project to work on... I'll help any way I can, i just don't have time to spearhead it. I already got the okay to integrate them into ghc.
22:37:41 <audreyt> dons: yes.
22:37:42 <vincenz> JohnMeacham: well I've been considering it
22:37:42 <dons> Korollary: yes, that's my statement right from the start: they don't care about the proof
22:37:52 <vincenz> JohnMeacham: just that my knowledge of ghc atm = 0
22:38:05 <audreyt> dons: I've been selling perl6's typesystem to perl5 people by saying
22:38:14 <audreyt> "the compiler writes and runs your unit tests for you"
22:38:22 <vincenz> JohnMeacham: ooc, are you saying that stat-infer-langs are always better than dynlangs/
22:38:23 <audreyt> which is a statement may can appreciate.
22:38:27 <audreyt> s/may/many/
22:38:34 <dons> audreyt: so from that perspective, the real CS _engineer_ should certainly use a strong, statically typed language. any other option is more work.
22:38:35 <JohnMeacham> audreyt: that is the best kind of violence.
22:38:57 <dons> audreyt: yes. i think that's a good way to explain this whole thing
22:39:06 <audreyt> dons: yes, but only if it's less work to do typing than to do testing
22:39:08 <dons> people understand, on some level, why unit tests are good
22:39:30 <audreyt> dons: at a certain point, proof-carrying code becomes very difficult to even think about
22:39:30 <dons> but tell them they have bugs, they glaze over
22:39:43 <audreyt> in which case falling back to runtime QuickCheck'ish things is very reasonable.
22:39:47 <Pseudonym> The best unit test is the one you don't have to write.
22:39:52 <audreyt> (or runtime constraints/assertions)
22:39:56 <audreyt> Pseudonym: exactly
22:39:58 <Pseudonym> Be it static type checking or QuickCheck.
22:40:02 <JohnMeacham> vincenz: well, in a simplistic way, yes. static languages can emulate dynamic ones, but not vice versa. but it obviously isn't that simple. a shitty statically typed language is not going to be more useful than a really good dynamic one. but a really good static one can't be beat. :)
22:40:34 <u221e> Most of this is going straight over my head ;)
22:40:42 <audreyt> one good idea both VB and Perl6 uses is to have annotated regions
22:40:42 <JohnMeacham> I use perl and Haskell both pretty regularly now. I like the extremes. :)
22:40:48 <audreyt> and tell the compiler to skip them for typechecking
22:40:55 <vincenz> JohnMeacham: Well until recently I would've agreed.  However I've seen how with scheme (note the argument of not all statlangs can be applied to not all dynlangs) it was a breeze to basically implement a whole new semantic system with macros.  I doubt htat's possible with haskell unless you go to parsing
22:40:58 <audreyt> and insert toDynamic/fromDynamic calls around them
22:41:01 <vincenz> and basically build a compiler
22:41:07 <audreyt> vincenz: try TH :)
22:41:18 <vincenz> audreyt: I'm talking serious changes
22:41:25 <vincenz> like OO with inner and super
22:41:36 <JohnMeacham> vincenz: Scheme is the best language for writing scheme interpreters. Less so for other tasks :)
22:41:52 <vincenz> JohnMeacham: it's an interesting playground :)
22:41:53 <audreyt> vincenz: oh. well, then you need to apply several units of oleg
22:42:11 <vincenz> audreyt: well yeah, but at that point I can do it in assembly as well, after all assembly is turing complete
22:42:24 <dons> audreyt: i can imagine an interesting haskell tutorial for perl/dynamically typed programmers, based on this unit tests/type check observation
22:42:31 <audreyt> assembly would require metaolegs
22:42:39 <vincenz> metaolegs.. :)
22:42:39 <dons> maybe that would be a useful way to ease people into static typing
22:42:47 <audreyt> or megaolegs
22:43:00 <vincenz> JohnMeacham: do you have a general view on ghc structure?
22:43:01 <audreyt> or omega legs... I'm feeling dsylexic
22:43:05 <dons> ?remember audreyt assembly would require metaolegs (or megaolegs)
22:43:05 <lambdabot> Done.
22:43:16 <JohnMeacham> vincenz: but the main reason I like haskell is it expands my brain-power many-fold. there is a hard limit on how much my brain can deal with, which means in order to write better and bigger programs, I need better tools to offload stuff from my head. Haskell easily lets me tackle projects I would be unable to do in other languages.
22:43:19 <Pseudonym> One thing I like the most about Haskell's type system, is that type safety is extremely cheap.
22:43:35 <dons> Pseudonym: right. compared to some systems, like Hoare logic
22:43:36 <Pseudonym> I almost never use Either, for example, because I can make my own type in one line.
22:44:00 <vincenz> JohnMeacham: Oh I definetely agree, I would never have attempted to write the compiler I'm currently writing in another language.  Maybe in a dynlang for ease, but then you'd so easily get a *load of bugs due to dyntyping (yeah, I often get quite nasty type-errors when I make a small mistake in a pass)
22:44:11 <dons> haskell should really be the default choice for anyone whose serious about correctness, in real world code
22:44:39 <lispy> yeah
22:44:42 <JohnMeacham> vincenz: Well, not as much as I should... but it isn't too hard. class aliases are mostly front-end anyway, so the code you touch is pretty small.
22:44:57 <vincenz> JohnMeacham: yeah frontend and .hi update is what I reckon
22:45:03 <vincenz> JohnMeacham: cause you gotta export em
22:45:24 <vincenz> but you have to get it all the way down to .hi
22:45:28 <JohnMeacham> yup. good error messages will be tricky, but no need to worry about those until later.
22:45:43 <vincenz> which I would presume is far down the chain of ghc
22:45:47 <audreyt> dons: I think the testing-to-typesystem tutorial idea is great. I'll think a bit more aout it
22:46:25 <dons> yeah, after icfp, i wouldn't mind sketching out such a tutorial with you
22:46:27 <JohnMeacham> vincenz: There is just a data type somewhere listing everything in the hi file, just add a field for the class alias structure. it will automatically be serialized to the hi file I think.
22:47:18 <dons> audreyt: so looking at typical testing issues that arise in dynamically typed code, or silently unreported bugs, and how to turn it into a cheap, static check
22:47:28 <vincenz> JohnMeacham: nifty :)
22:47:37 <dons> as a motivator for strong, static typing, and hence learning haskell
22:47:45 <vincenz> anyways
22:47:47 <vincenz> it's 8am
22:47:49 <vincenz> been up for 6 hours
22:47:52 <audreyt> dons: taking that routes, we very quickly run into typeclasses
22:47:53 <vincenz> time to go to the office
22:47:54 <dons> vincenz: you need sleep!
22:47:56 <audreyt> and then exietential types
22:48:00 <vincenz> dons: can't :(
22:48:02 <u221e> How would would a plugin system work for Haskell?
22:48:07 <dons> audreyt: well, we don't want to go into really heavy properties, i think
22:48:12 <dons> type classes are ok though
22:48:15 <vincenz> dons: maybe I'll transcend it :D
22:48:37 <dons> so we intermix teaching the language, with what propeties you now don't have to write tests for :)
22:48:42 <audreyt> dons: I think we can show QuickCheck first
22:48:48 <dons> ah, maybe
22:48:54 <audreyt> and then say there's some QuickCheck properties that can be turned into types
22:48:57 <vincenz> dons: don't forget brainwashing and sending people off with a warm fuzzy feeling!
22:48:59 <audreyt> there are far more that can;'t
22:49:06 <audreyt> but that's fine; they can stay at QC level
22:49:16 <u221e> What's QuickCheck?
22:49:19 <audreyt> and QC is great precisely because it's type deiven
22:49:28 <dons> audreyt: i think that's correct. there are more proprties in the universe than can be expressed in the ghc type checker
22:49:28 <audreyt> perl has had QC for a long time (Test::LectroTest)
22:49:40 <audreyt> but there's no type inference, so you have to write all the generator chain yourself
22:49:44 <dons> audreyt: how do you generate tests?
22:49:46 <dons> ah right
22:49:56 <dons> and you don't get a coverge proof then
22:49:59 * vincenz snickers at a comment in the ICFP-discuss list "Psycho (python JIT) can help but tends to segfault when doing closures and other functional stuff. Pyrex works OK but a hand crafted C extension isn't much harder (an extra 100 lines of C) and is faster and less buggy in my experience."
22:50:09 <vincenz> if you want functional stuff, use an fpl
22:50:15 <dons> whereas a suitable Arbitrary instance will give you a proof via exhaustion
22:50:17 <audreyt> dons: well, you can, if you provide enough annotation, and there is already builtin ones for e.g. Int and Float
22:50:19 <dons> for some careful cases
22:50:34 <audreyt> but yes, the equiv to Arbitrary would require far more code
22:50:36 <dons> ok. very interesting
22:50:41 <audreyt> that nobody iirc has bothered to write them
22:51:31 <JohnMeacham> hmm.. point me to an example of a moderatly small but multi-file program haskell 98 program jhc can compile... I need some better test cases.
22:51:39 <audreyt> in my Hs talk, the prop_sqrt x = sqrt (x * x) == x example really wins them over
22:51:57 <audreyt> because it catches -1, and unit testing people won't even imagine -1
22:52:12 <dons> JohnMeacham: do you have ForeignPtr yet?
22:52:29 <dons> audreyt: hmm!
22:52:32 <dons> yes, good example
22:52:34 <JohnMeacham> dons: no. at least, it doesn't clean up after them.
22:52:34 * dons takes some notes
22:52:48 <JohnMeacham> dons: or maybe it does... hmm.. not sure actually.
22:53:06 <vincenz> JohnMeacham: you're the sole person working on jhc?
22:53:13 <JohnMeacham> I am working on the core -> core optimizer before ho generation right now.
22:53:14 <dons> JohnMeacham: I think musasabi might know. we looked at porting ByteString over at some point
22:53:26 <JohnMeacham> musasabi is the main contributer other than me.
22:53:52 <vincenz> JohnMeacham: what does the core look like? ANF?
22:55:01 <dons> audreyt: so types both a) mean you can write less unit test, compared to a dynamically typed lang, and b) facilitate writing better unit tests (QC) since you have stronger properties on those tests (like coverage)
22:55:03 <JohnMeacham> vincenz: of jhc? it looks like ghc core, but is based on the lambda cube rather than system f, practically, it doesn't affect a whole lot but I find it easier to work with.
22:55:13 <vincenz> JohnMeacham: how do you annotate it?
22:55:28 <u221e> Is jhc usable right now?
22:55:29 <vincenz> JohnMeacham: I'm having issues with how to do clean/transparent annotations on ast
22:55:34 <audreyt> JohnMeacham: have you seen Fc?
22:55:36 <vincenz> JohnMeacham: right now I use indirect composite but it's ugly as hell
22:55:40 <audreyt> the new core for GHC apparently
22:55:46 <dons> since testing is all about properties, and the type system is a DSL for encoding properties.
22:55:48 <audreyt> ("System F with Type Equality Coercions")
22:56:16 <JohnMeacham> vincenz: what do you mean? the data type can be seen here: http://repetae.net/dw/darcsweb.cgi?r=jhc;a=headblob;f=/E/E.hs#l62
22:56:17 <lambdabot> Title: darcs - jhc
22:56:41 <JohnMeacham> audreyt: yeah, I am looking into it.
22:57:07 <vincenz> JohnMeacham: I like "Unknown" :)  But what I mean is, annotating the AST somehow...apparently you don't do that tho
22:57:17 <audreyt> vincenz: I think the JHC tree, like I showed with Pugs's new AST
22:57:25 <audreyt> knows exactly what nodes it wants
22:57:29 * vincenz nods
22:57:30 <audreyt> and hence don't need general annotations
22:57:33 <JohnMeacham> audreyt: though, I have already implemented a different method of dealing with GADTs and assosiated types (though, they arn't in the front end yet, but are used internally). I have been meaning to write to SPJ about it.
22:57:39 <vincenz> audreyt: pity :(
22:57:44 <vincenz> audreyt: it's an unsolved problem
22:57:49 <JohnMeacham> vincenz: ah, see Info/Info.hs
22:58:35 <audreyt> JohnMeacham: is that the pass-types-as-values-around-as-witness scheme?
22:58:47 <JohnMeacham> vincenz: it is type-indexed, so I can just add anything i want to it without modifying a central type somewhere. A smiggon of well placed dynamic typing is all I need. :)
22:58:48 <vincenz> JohnMeacham: don't quite see how that ties into the ASTnodes
23:00:14 <JohnMeacham> audreyt: yeah. but since types can be let-bound, I already had a mechanism for propegating type equality information around so I didn't need to add them specially. I am not sure if it is as powerful, but it seems to be sound for the cases that have occured in practice.
23:00:36 <JohnMeacham> vincenz: each TVr has one.
23:00:39 * vincenz nods
23:00:40 <vincenz> alright
23:02:01 <JohnMeacham> vincenz: then Info.Binary just mentions the ones that automatically get written and read from ho files. so no need to modify anything (much) even to extend those. I have found it very nice.
23:02:02 <audreyt> mm, type-indexed bag thing is actually a good solution to vincenz's problem
23:02:13 * vincenz nods
23:02:20 <audreyt> I think I mentioned HList at some point
23:02:23 <vincenz> audreyt: well that means making unique types for a lot of stuf
23:02:24 <audreyt> but I like thte Dynamic
23:02:25 <JohnMeacham> audreyt: I wish Data.Typeable.TypeRep were an instance of Ord though.
23:02:32 <dons> Ord eh?
23:02:35 <audreyt> JohnMeacham: but I made it so with Show
23:02:41 <audreyt> it's slow, but hey.
23:03:27 * vincenz is off
23:03:28 <JohnMeacham> newtype deriving is the best thing for that vincenz. just create a newtype of whatever you want and derive any properties you want to keep from the underlying type.
23:03:43 <audreyt> (and I can't think of a better comparison than comparing shows exists)
23:03:50 <vincenz> JohnMeacham: atm I use indirect composite system, but if you follow haskell-cafe, you might have seen it bugs me
23:04:28 <JohnMeacham> audreyt: funny you should say that, that is exactly how Info.Info used to work, but I changed it to a linear list and found no difference in speed. not sure why I changed it really, was just sort of typing.
23:04:45 <vincenz> the keyboard did it
23:05:39 <audreyt> JohnMeacham: *nod* in my $job work (OpenAFP), I have some 239 types
23:05:51 <audreyt> and I implement OOish dispatch using TypeRep tokens
23:05:54 <JohnMeacham> audreyt: my thought being that whenever you modify anything, it puts it at the front of the list, since algorithms usually make several passes examining their own data, I thought it might be self-optimizing somehow. didn't seem to acutally make a difference though.
23:06:00 <audreyt> and show-as-Ord so far has been fast enough
23:06:50 <audreyt> those are all machine-generated record types, which did not mix with existentials, so TypeRep is the next best choice
23:07:06 <JohnMeacham> audreyt: Acutally, I used 'Atom's made from show. they were quite fast as an atom is just a newtype of an Int.
23:07:29 <audreyt> however, now that I hacked record types + existentials + GADT into GHC, maybe I should revisit that some day
23:07:33 <JohnMeacham> audreyt: but my info's never get much bigger than 5-7 entries.
23:07:59 <audreyt> atoms are hashes?
23:08:21 <audreyt> ah. clever
23:08:26 * audreyt grokked Atom.hs
23:08:55 <audreyt> bidi-indexed int proxy to strings
23:08:59 <JohnMeacham> audreyt: yeah, I use them everywhere. quite handy.
23:09:00 <audreyt> cool
23:09:31 <audreyt> that reminds me of scheme/ruby Symbols
23:09:33 <JohnMeacham> audreyt: the only drawback is the Ord instance is not necesarily related to Ord on the strings, but that is not really a problem.
23:09:50 <audreyt> sure, as long as there are some order, you don't care about alphabeticals
23:10:08 <JohnMeacham> audreyt: which is where I got the name 'atom' :) scheme... or was it prolog? hmm.. something.
23:10:43 <audreyt> is that known as "interning"?
23:11:10 <audreyt> yeah, apparently, in prolog speak
23:11:18 <JohnMeacham> audreyt: yeah. sounds right. ah, X11, that was it. XInternAtom
23:11:22 <newsham> i dont know atom from eve
23:11:39 <audreyt> you mean eval
23:12:42 <audreyt> "apply is the root of all eval"
23:13:41 <lispy> vincenz: what country do live in?
23:21:51 <u221e> What I don't like about Haskell right now is that it's hard to actually read other programs unless you already know almost everything. :(
23:24:33 <lispy> u221e: i learned a ton from looking at the darcs source code
23:25:21 <palomer> @palomer
23:25:22 <lambdabot> woof
23:25:29 <palomer> lispy: that's impossible! you don't know a ton
23:25:39 <palomer> at most 4 kg
23:25:47 <zenpro> Bruce Tate's article on Haskell: http://www-128.ibm.com/developerworks/java/library/j-cb07186.html
23:25:49 <lambdabot> Title: Crossing borders: Explore functional programming with Haskell
23:27:01 <dons> interesting
23:28:01 <zenpro> hi dons, yeah it's very nice to see the buzz around Haskell  growing
23:28:40 <u221e> When were monads introduced to haskell?
23:29:13 <Korollary> 93 or so
23:29:31 <Korollary> well, it's all in that history of haskell paper
23:30:08 <Korollary> http://haskell.org/haskellwiki/History_of_Haskell
23:30:10 <lambdabot> Title: History of Haskell - HaskellWiki
23:30:12 <Korollary> very good reading
23:30:38 <palomer> and why do we want buzz?
23:30:48 <Korollary> more libraries
23:31:07 <Korollary> maybe even more theory
23:31:15 <zenpro> palomer: more people interested, more libraries, more adoption in the companies, more jobs, and so on...
23:31:18 <u221e> This All about Moands tutorial moves to fast ;(
23:31:34 <palomer> more people interested isn't very interesting
23:31:45 <Korollary> @palomer
23:31:45 <lambdabot> Brump!
23:32:39 <dons> zenpro: yeah, i was just thinking that : "seems to be more buzz going on"
23:32:46 <lispy> palomer: i started at -1995 lbs
23:33:46 <zenpro> dons: and I think it is good (even if it can carry some downsides)
23:33:49 <palomer> buzz also means excess standardization and growth of egos
23:34:11 <palomer> one of the reasons I like haskell is that it has the lowest ego to user ratio around
23:34:18 <palomer> and that it's a small, unassuming community
23:34:28 <palomer> well, mostly unassuming
23:34:49 <zenpro> palomer: the value of a community is shown when the first challenges arrive
23:34:59 <Pseudonym> Actually, I think it's that the egos are controlled.
23:35:16 <palomer> I don't think that any community has intrinsic value, it's all a matter of circumstance
23:35:17 <Pseudonym> I dunno about you, but I have quite an ego.
23:35:28 <Pseudonym> But I know that everyone else here is also cool and smart.
23:35:35 <palomer> ok, the egos are mostly kept in check on irc
23:35:43 <dons> hehe
23:35:45 <palomer> I have quite a big ego too
23:35:56 <zenpro> palomer: the language deserves to be known I think
23:35:57 <palomer> ie, noone takes it too seriously
23:36:07 <palomer> when people start taking things seriously, bad stuff starts to happen
23:36:18 <u221e> I can't believe how much trouble I'm having with Monads, this is insane.
23:36:40 <Korollary> u221e: maybe you'll like Cale's tutorial
23:36:42 <palomer> u221e: when you stop having trouble with monads, I have a bucket full of PhDs to give you
23:36:52 <Korollary> @google monads as containers
23:36:54 <lambdabot> http://haskell.org/hawiki/MonadsAsContainers
23:36:55 <lambdabot> Title: MonadsAsContainers - The Haskell Wiki
23:37:00 <dons> u221e: well, hmm, its a _big_ abstraction. a really fundamental concept. so i'd expect a week or two to ponder it. and more to really start hacking them around
23:37:01 <lispy> heh, are wey going to have an ego size contest :)
23:37:11 <dons> lispy want's in!
23:37:43 * lispy brings his ego up to the scale
23:37:43 <dons> zenpro: would you like to add a link to this article in the tutorials section of the haskell wiki?
23:37:45 <palomer> seriously, I rather have a small, unassuming, fun community than a big, serious, well developed, properly maintained community
23:38:00 <u221e> Cale's article starts like it's in the middle of a large article.
23:38:00 <zenpro> dons: sure I'll do it right now
23:38:39 <dons> probably under http://haskell.org/haskellwiki/Books_and_tutorials#.22Real_world.22_tutorials
23:38:41 <lambdabot> Title: Books and tutorials - HaskellWiki
23:38:43 <dons> ?
23:38:54 <dons> or maybe motivatoin
23:38:55 <palomer> zenpro: wrt to your comment, I don't think the language would mind not being known
23:39:00 <dons> http://haskell.org/haskellwiki/Books_and_tutorials#Motivation_for_Using_Haskell
23:39:01 <lambdabot> Title: Books and tutorials - HaskellWiki
23:40:05 <zenpro> palomer: sure, and the language doesn't have ego either. :) But the programming world can get a lot from Haskell.
23:40:13 <palomer> this "hey, look at us, we have a great and fast and safe language and you should like it too" mentality screams of ego
23:40:34 <dons> don't mind palomer, zenpro. he's a grumblebum
23:40:48 <palomer> @palomer
23:40:49 <lambdabot> woof
23:41:07 <palomer> zenpro: I don't know about you, but what the programming world gets doesn't affect me much
23:41:29 <u221e> All these monad tutorials assume too much.
23:41:39 <palomer> even Cale's?
23:41:46 <dons> u221e: do you think you could take notes on where things make no sense?
23:41:49 <u221e> The worst would have to be the Monad section of Yet Another Haskell Tutorial though.
23:41:56 <dons> Cale could use them to improve his article.
23:42:10 <zenpro> palomer: let's put it this way, I'm an altruist
23:42:20 <dons> u221e: since you've already hacked up some significant haskell, its interesting to get the viewpoint of a good programmer, not just a newbie who doesn't get it at all
23:42:32 <palomer> altruism is selfishness in disguise
23:42:41 <dons> you could just jot down section/paragraph/lines that are confusing.
23:43:05 <u221e> dons, right now I think my main problem isn't so much monads themselves but the library functions that operate on them.
23:43:07 <mlh> what I'd like to see is an exposition of exactly how i/o (for instance) can cause problems .. and then (slowly) introduce monads as the solution
23:43:23 <mlh> in C if possible/feasible
23:43:39 <dons> u221e: ah, the tutorials pull out lots of library functions on you? assuming you know them?
23:43:46 <palomer> when you want other people to use your tools and to notice what you're using and to agree that it's the best thing to use, I find it hard to believe that there's no self interest
23:44:14 <dons> mlh, hmm. yes. a lot of times we just expect the person to have had experience with the issues debugging mutable state/side effects
23:44:23 <dons> and knowledge of why those problems came about
23:44:25 <palomer> don't get me wrong, I don't think you any less of a person or anything; heck, you're normal, but let's be honest here
23:44:50 <dons> mlh, its a good point.
23:45:08 <mlh> yes.  indeed.  my fave prof at uni was emphasised a motivation first, before getting to the solution
23:45:10 * dons notes this down. introduce monads as a solution to a concrete problem
23:45:32 <dons> goes along with introducing static typing to the problem of testing
23:46:01 <dons> of course , the real solution is to avoid state altogether ;)
23:46:08 <dons> as the article above hints
23:46:31 <dons> since then you get a wide array of new, strong properties, making reasoning, and correctness easier
23:47:30 <mlh> a skeleton would be to have a C program, say with two functions say_hello and say_world, and pretend you don't have any way to exec them sequentially. the problem then becomes to modify the program so that it says hello world rather than world hello
23:48:01 <u221e> dons, it sometimes seems like the point of haskell is to pack as much complexity into the shortest number of lines posible.
23:48:11 <dons> u221e: yes, its semantically rich
23:48:19 <dons> a single identifier might introduce some hugh abstraction
23:48:33 <dons> a bit like that <- from the maybe monad earlier
23:48:36 <u221e> Take the traceFamily function in the following for example.
23:48:43 <u221e> http://www.nomaware.com/monads/html/monadfns.html
23:48:44 <lambdabot> Title: Monad support in Haskell
23:48:55 <dons> but you want that. you want to pack more 'oomph' into your code
23:48:59 <dons> content is good :)
23:49:01 <palomer> People behave altruistically for a number of selfish reasons. We are programmed genetically to behave in a way conducive to the sociability of the species: This unconscious species-instinct is the closest thing we have to true sellfless altruism. In nearly every other conscious sense, altruism is an illusion. We behave well because social good behaviour fires off pleasent neurochemicals in our brains (the pleasure reward), because consciously or unconscio
23:49:01 <palomer> usly we want others to see us as a good person (the social reward) or to feel good about ourselves (for pride and self-esteem). All of these selfish reasons surpass the reason that the innocent think is behind their actions: The choice to selflessly help others. Altruism is image and illusion.
23:49:23 <mlh> i blame genes
23:49:26 <mlh> selfish ones :-)
23:49:27 <Korollary> palomer: So why are you sharing this with us?
23:49:38 <u221e> I would say that it's very cute and I even understand how it works... but I don't think it's very readable.
23:49:46 <dons> palomer: OT.
23:49:48 <palomer> Korollary: my ego is telling me that I have to be right
23:50:07 * mlh thought palomer may have pasted into the wrong channel
23:50:20 <palomer> fine fine, I'll stop this topic
23:50:41 <palomer> the more I try to get away from my ego, the more it creeps up in strange places
23:52:34 <JKnecht> well you're part of a politcally neutered class and that stuff had class relation import. (for that reasons such outbursts have few other more appropriate venues, perhaps none) ...
23:52:56 <JKnecht> the level of cooperation in the Haskell community is very high though.
23:53:42 <JKnecht> s/reasons/reason/
23:53:42 <palomer> still, it isn't so much OT since it shows how this obsession with getting media coverage and its justification are ego based
23:54:03 <palomer> and how participating in such activities will lead to a decline in the haskell community fun factor
23:54:21 <JKnecht> yes, the degree of cooperation only extends so far, rather superficial in fact.
23:54:28 <u221e> What would be a "a list of monadic computations"?
23:54:45 <dons> JKnecht: well, we do write research papers together, in some cases.
23:55:04 <palomer> JKnecht: I didn't catch your first comment
23:55:16 <dons> and at least some have tried to actively increase the cooperation, as a general strategy for optimising our output, and hence the language's growth
23:55:35 <dons> u221e: [putChar 'x', putChar 'y'] ?
23:55:44 <dons> which you'd then execute with: sequence_ ...
23:55:46 <zenpro> dions: I've added the article to the wiki. http://haskell.org/haskellwiki/Books_and_tutorials
23:55:48 <lambdabot> Title: Books and tutorials - HaskellWiki
23:56:02 <dons> yi in fact generates a lazy list of monadic actions from each key stroke in the editor
23:56:07 <dons> which are evaluated on demand
23:56:22 <palomer> that's why it's so bloody slow!
23:56:28 <dons> ?karma+ zenpro -- cheers!
23:56:29 <lambdabot> zenpro's karma raised to 1.
23:56:31 <u221e> That's what I thought... just checking...
23:56:48 <zenpro> dons: thanks :)
23:57:12 <zenpro> palomer: are you saying that haskell is 'bloody slow'
23:57:15 <u221e> Is a monadic computation just ANY function that returns a monad?
23:57:25 <palomer> in this case I was goading dons by talking about yi
23:57:48 <palomer> but yes, I don't think idiomatic haskell is a speed demon
23:58:03 <dons> that operates in a monad, yes.
23:58:10 <palomer> night!
23:58:22 <zenpro> palomer: ah ok, because I've found ghc perfomances quite ok (not as fast as C but still good)
23:58:26 <dons> its a general term for expressions of type :: Monad m => m a, I suppose
23:58:26 <u221e> I just grabbed Yi from darcs... had to sit through over 500 patches.
23:59:06 <zenpro> dons: we may consider splitting that page because it's really huge at the moment. What do you think?
23:59:29 <dons> yeah. it needs refactoring
23:59:40 <dons> its structure is legacy from the old static haskell.org
