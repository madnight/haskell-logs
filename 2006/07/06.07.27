00:00:48 <astrolabe> where is dons?  haskell's mister efficiency :)
00:01:03 <dons> what's the story? let me see..
00:01:27 <dons> lots of ++ is slow
00:01:33 <edwardk> woohoo
00:01:40 <edwardk> all that reading wasn't for nothing ;)
00:01:57 <edwardk> its an n^2 vs n kinda thing, no?
00:02:15 <emertens> if it's fixity was reversed
00:02:15 <dons> better to use a dlist, based on (.) for many appends, like showsPrec
00:02:42 <dons> at the bottom of this file, http://www.cse.unsw.edu.au/~dons/code/yi/Yi/Lexers.hs
00:02:48 <dons> a list type with O(1) append
00:03:01 <emertens> dons: I understand why appending is slow, but why is it slow in a lazy environment
00:03:28 <dons> well, you've got to evaluate to the end of the first list , to hook on the 2nd arg
00:03:35 <edwardk> emertens you either have to wrap the previous list in a function or you have to strictly evaluate it to get to the end
00:03:50 <dons> right.
00:03:52 <edwardk> either way you pay the overhead of two reads for every element in that list for each append
00:04:16 <edwardk> so n appends on n elements is O(n^2)
00:05:01 <edwardk> er n appends yielding n elements
00:05:02 <edwardk> i should say
00:05:24 <emertens> I thought htat iwas O(n), and would have been O(n^2) if it was infixl
00:06:12 <dons> (++) :: [a] -> [a] -> [a]
00:06:12 <dons> (++) []     ys = ys
00:06:13 <dons> (++) (x:xs) ys = x : xs ++ ys
00:06:56 <emertens> right
00:07:40 <emertens> but since (++) is right associative, it is O(n) , which is still worse than the O(1) you mentioned earlier
00:07:43 <emertens> for dlists
00:07:45 <emertens> or whatever that was
00:08:16 <dons> yeah, I thought it was O(n) too. copy the spine, attach the 2nd list
00:08:51 <edwardk> emertens: it is O(n). the O(n^2) is for the construction of n appends.
00:09:02 <edwardk> a ++ b ++ c ++ d ..
00:09:03 <dons> ah, yes. we were talking about that
00:09:10 <dons> so its O(n*m)
00:09:14 <edwardk> yeah
00:09:16 <dons> where m is the number of appends
00:09:30 <musasabi> data STree = L String | T [STree] is one solution.
00:09:36 <emertens> (++) is O(length result)
00:09:50 <emertens> it wahat I was trying ot say
00:10:44 <edwardk> yeah
00:10:47 <edwardk> we all agree =)
00:10:49 <emertens> sweet
00:12:49 <edwardk> not bad, the jit is only about 4x the number of lines of the c version. now to make it compile =)
00:18:12 <emertens> now it's way too late
00:18:17 <emertens> good night all
00:18:43 <u221e> How do I draw pixles to the screen with hsSDL?
00:26:11 <Lemmih> u221e: blitSurface?
00:27:09 <u221e> Lemmih, individual pixels...
00:27:46 <Lemmih> u221e: That's quite slow and depends on the dst surface.
00:28:21 <u221e> Then how do I create a surface so I can blit it?
00:29:30 <Lemmih> u221e: See http://andrew.textux.com/tutorials/tut1/tutorial1.html under "Drawing a Pixel".
00:29:32 <lambdabot> Title: Programming with SDL - Tutorial 1
00:31:05 <u221e> Uh, I know how to do it in C...
00:32:18 <Lemmih> Well, in Haskell you do it the same way.
00:33:07 <Lemmih> (except slower and uglier)
00:35:15 <u221e> Anything better then hsSDL?
00:37:20 <Lemmih> No, but as the author of hsSDL I might be biased (:
00:38:15 <u221e> Would using hsSDL and OpenGL with a 2d projection be better?
00:39:44 <Lemmih> For drawing single pixels? I don't know.
00:41:51 <u221e> Well I don't really want to draw single pixels... I have all my image data and I just want to draw it to the screen.
00:44:45 <gavino> ?
00:45:58 <Lemmih> u221e: Ah, that should be fairly simple.
00:46:12 <edwardk> ok,, well, the jit code compiles, but now i have to wrestle with the way i ufxxored my plugins install i think. =/
01:03:08 <Lemmih> @seen shapr
01:03:08 <lambdabot> I saw shapr leaving #haskell-overflow, #haskell, #ScannedInAvian and #unicycling 8 hours, 34 minutes and 25 seconds ago, and .
01:07:04 <dons> edwardk: cool!
01:11:50 <edwardk> basically it looks like ghc-6.4 can't find the plugins install that i installed in it, and ghc 6.5 wants to gripe about the .hi files
01:12:01 <dons> it would do that
01:12:12 <edwardk> *nods*
01:12:23 <edwardk> just trying to get things to a state where i can work in either one =)
01:12:27 <gavino> im such an asshole
01:12:58 <gavino> i despise myself sometimes
01:13:12 <edwardk> not understanding why ghc-6.4 doesn't believe -package plugins exists
01:13:20 <dons> edwardk: ghc-pkg ?
01:13:26 <dons> does it reveal any insights?
01:13:37 <edwardk> heh didn't know about that command. trying it =)
01:13:49 <dons> ghc-pkg list
01:13:50 <edwardk> i ran the .setup.lhs register when i installed
01:13:51 <dons> for example
01:14:14 <edwardk>  
01:14:14 <edwardk>     Cabal-1.1.4, GLUT-2.0, HGL-3.1, HUnit-1.1, OpenGL-2.1,
01:14:14 <edwardk>     QuickCheck-1.0, X11-1.1, base-1.0, fgl-5.2, (ghc-6.5.20060713),
01:14:14 <edwardk>     haskell-src-1.0, haskell98-1.0, mtl-1.0, network-1.0, parsec-2.0,
01:14:14 <edwardk>     plugins-1.0, readline-1.0, rts-1.0, stm-1.0, template-haskell-1.0,
01:14:15 <edwardk>     time-1.0, unix-1.0
01:14:46 <edwardk> er
01:14:54 <edwardk> guess i can't put the 6.4.2 one up
01:14:58 <edwardk> but it doesn't have it
01:16:19 <dons> each version needs its own install of plugins
01:16:29 <edwardk> yeah. thought i had installed in 6.4.2
01:16:32 <edwardk> hence my confusion
01:16:49 <edwardk> just trying to undo the damage now that its done
01:19:10 <Lokadin> say if i wanted to convert 1 string into three, based on the position of the first two ',' how would i go about doing that?
01:19:54 <Lokadin> >convert :: String -> [String]
01:19:54 <Lokadin> >convert [x:xs] =
01:19:54 <Lokadin> >   if x == ','
01:19:54 <lambdabot>  Parse error
01:19:57 <Lokadin> >      then
01:19:58 <lambdabot>  Parse error
01:20:11 <Lokadin> is where i get stuck
01:21:31 <Lokadin> i can do it with sed
01:21:44 <Lokadin> but that would require an io command
01:23:55 <Lokadin> hmmm
01:24:00 <Lokadin> i guess i could just do that
01:25:19 <Lokadin> ooo i know
01:25:41 <Lokadin> " " ++ function ++ " " : " " ++ etc
01:25:44 <Lokadin> or some such
01:27:12 <edwardk> @where newArray_
01:27:13 <lambdabot> I know nothing about newarray_.
01:28:03 <kosmikus> Lokadin: you just want `words' for a comma? then look at the implementation and generalize!
01:29:21 <dons> edwardk: you want @index
01:29:25 <dons> ?index newArray_
01:29:25 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
01:29:35 <edwardk> ah
01:29:36 <edwardk> =)
01:29:47 <dons> ?docs Data.Array.IO
01:29:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IO.html
01:29:53 <dons> ?fptools Data.Array.IO
01:29:53 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/IO.hs
01:30:01 <dons> lambdabot knows all!
01:30:38 <edwardk> heh now that the package problem resolved i have a crap ton of type errors to fix, whee
01:30:59 <edwardk> and some random hey you really need to qualify this import or that one, kinda stuff
01:30:59 <dons> better errors now than when its running, i always say
01:31:02 <edwardk> yeah
01:31:06 <edwardk> i agree completely
01:47:08 <gour> anyone builds latest jhc?
01:51:00 <gavino> jeeesh
01:51:06 <gavino> haskell seems complicated
01:51:12 <gavino> modas combinators
01:51:16 <gavino> n stuff
01:51:28 <gavino> can it outdo java and jboss n stuff?
01:56:03 <ricky_clarkson> Java can outdo JBoss. ;)
02:04:42 <foxy_> Lemmih, got any thoughts about ghc-api and Yi?
02:04:50 <foxy_> @where ghc-api
02:04:51 <lambdabot> http://www.scannedinavian.org/~lemmih/ghc-api/
02:05:06 * foxy_ points at a broken link
02:07:30 <Lemmih> @where+ ghc-api http://www.haskell.org/ghc/
02:07:31 <lambdabot> Done.
02:14:22 <Itkovian> Lemmih: shapr helped me out a bit, and we got the app runner faster, and with less memory ...
02:20:53 <lisppaste2> gour pasted "jhc build" at http://paste.lisp.org/display/23241
02:21:15 <gour_> building jhc from latest darcs on amd64 gives the above error..
02:22:00 * Lemmih gets the exact same error on x86.
02:22:08 <tessier__> Haskell has a perl-review like magazine? Anyone know what it is called?
02:23:33 <edwardk> the monad reader thing?
02:23:39 <edwardk> or something else?
02:23:44 <xerox> See the topic?
02:23:47 <xerox> HCAR.
02:24:14 <Lokadin> why do i get *** Exception: Prelude.(!!): index too large, for convert obu = (take 29 obu) : (getDesc obu) : (getBody obu) : []
02:24:32 <Lokadin> convert :: String -> [String]
02:24:59 <edwardk> is it just me or do type level fixed points not play nice with multiple parameter types?
02:26:09 <edwardk> i keep oscillating back and forth between conflicting constraints. i can't build a fix point newtype that can take the right number of parameters because i have to apply all of them, and if i try to work around that, i run into another problem, etc.
02:26:16 <edwardk> and it winds up sending me into a loop
02:26:42 <edwardk> very much 'there's a hole in the bucket dear liza dear liza' if you know what i mean.
02:27:02 <Itkovian> the GHC opt guide says to look at the interface file, which I presume is the .hi file.
02:27:18 <Itkovian> How can I get anything from that? It's mostly binary stuff
02:27:25 <edwardk> i can solve the probem i have without doing this but the result will not be as clean.
02:27:30 <Lemmih> Itkovian: Yep, you can view it with 'ghc --show-iface ifacefile'.
02:27:40 <Itkovian> ok.
02:27:43 <Itkovian> ah ic ...
02:27:47 <Itkovian> overlooked that
02:27:48 <Itkovian> thx
02:28:51 <greenrd> Lemmih: pong
02:28:52 <lambdabot> greenrd: You have 1 new message. '/msg lambdabot @messages' to read it.
02:29:03 <foxy_> is there a way to develop with ghc 6.5 and do normal compilation with ghc 6.4.* ?
02:29:18 <Lokadin> so why is the index too large when i only have three elements in it?
02:29:42 <Lokadin> or should i make it a tuple so it wont give me all these problems
02:30:05 <Lokadin> i'll do that probably
02:32:05 <dons> > [] !! 0
02:32:06 <lambdabot>  Add a type signature
02:32:11 <dons> > [] !! 0 :: Int
02:32:12 <lambdabot>  Exception: Prelude.(!!): index too large
02:32:18 <dons> > [1,2,3] !! 3 :: Int
02:32:19 <lambdabot>  Exception: Prelude.(!!): index too large
02:32:24 <dons> it just means your index is out of bounds
02:33:12 <Lokadin> >[1,2,3] !! 2
02:33:21 <edwardk> @paste
02:33:21 <lambdabot> http://paste.lisp.org/new/haskell
02:33:34 <lisppaste2> edwardk pasted "catch 22" at http://paste.lisp.org/display/23242
02:33:39 <edwardk> ok
02:34:01 <edwardk> i've been trying to find my way out of this logical pickle. this is a grossly simplified form with the same general shape as the larger problem
02:34:34 <edwardk> I have a state monad. that state monad contains a intmap of jitted functions
02:35:01 <edwardk> the jitted function itself needs to be able to access that dictionary to call the next function to avoid trampolining.
02:35:31 <edwardk> but i can't form the fixed point
02:35:43 <edwardk> because either i can't have the argument for IO or I have too many for FixJ
02:35:55 <edwardk> and i'm not seeing my way out of the pickle
02:36:34 <edwardk> and this code is in the middle of its 900th revision so missing symbols are because I reached the 'random permutation' phase.
02:37:08 <Lokadin> with convert obu = (take 29 obu) : (getDesc obu) : (getBody obu):[]
02:37:29 <Lokadin> oops
02:37:32 <edwardk> any ideas?
02:37:57 <Lokadin> sorry, i don't know nearly enough to be able to help you
02:38:11 <edwardk> not a problem
02:38:47 <edwardk> i really don't want to give up and add a trampoline just because i'm not smart enough to figure out the fixed point =)
02:38:47 <xerox> Lokadin: convert = (`ap` [take 29, getDesc, getBody]) . return -- :-)
02:40:25 <gour> Lemmih: when did you build jhc last time?
02:40:47 <gour> Lemmih: how it looks like?
02:40:54 <Lokadin> xerox: 'ap' is not in scope
02:41:00 <xerox> import Control.Monad
02:41:26 <xerox> > (`ap` [(+1),(*2),subtract 3]) . return $ 0
02:41:27 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
02:41:30 <xerox> Ops.
02:41:38 <Lokadin> kk thanks :) ki'e
02:41:41 <xerox> > return 1 `ap` [(+1),(*2),subtract 3]
02:41:42 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
02:41:44 <xerox> Hmm.
02:42:05 <xerox> Ah woops. The orther of arguments.
02:42:15 <xerox> > ([(+1),(*2),subtract 3] `ap`) . return $ 0
02:42:16 <lambdabot>  [1,0,-3]
02:42:19 <xerox> :-)
02:42:35 <Lokadin> xerox: say, it's not an IO function though
02:43:14 <Lokadin> can i get around it without having to declare it as one?
02:43:41 <xerox> Hmm?
02:44:14 <xerox> The Monad used in that expression is the list one.
02:45:20 <Itkovian> where can one see if a function gets inlined?
02:45:25 <Lokadin> hmmm, then i don't understand the error it's giving me
02:45:39 <xerox> I think some -dump-option shows it, Itkovian.
02:46:55 <Lokadin> Expected type: [b] Inferred type: t -> t1
02:47:08 <Lokadin> hmmm
02:47:16 <llama32> i could imagine how functional languages could bring productivity gains to things like compilers and HTTP servers, but would it have the same effect with things that are inherently state-oriented, like a windowing system [or GUI based programs in general]?
02:47:30 <xerox> Lokadin: sorry, it's my personal retaliation to make points-free code, don't let it blow up your code.
02:47:51 <Lokadin> well it wasn't working earlier
02:47:57 <Lokadin> so i mean it's not really any worse
02:47:58 <Itkovian> xerox: it's --dump-inlinings. thx
02:48:05 <xerox> Itkovian: you're welcome.
02:48:14 <xerox> Lokadin: may you (lisp)paste more context?
02:48:20 <shapr> ?yow?
02:48:21 <lambdabot> Did I say I was a sardine?  Or a bus???
02:48:26 <Lokadin> @paste
02:48:27 <lambdabot> http://paste.lisp.org/new/haskell
02:48:54 <edwardk> night all
02:50:27 <lisppaste2> Lokadin pasted "three string" at http://paste.lisp.org/display/23243
02:51:57 <dons> lambdabot: yeah, since you can manage state in a simpler, safer way, using monads to partition effects
02:52:15 <dons> see the number of gui libs or state-oriented programs written in IO or State monads in haskell
02:52:28 <xerox> Are you talking to lambdabot, dons?^
02:52:46 <xerox> Oh Lokadin strip off the '$ 0' part!
02:52:47 <dons> and you have useful consequences when you partition effects. such as being able to still mechanically verify the non-IO parts
02:52:58 <dons> xerox: more thining of yi, with all the mutable buffers
02:53:02 <shapr> So what's new today? Any fun code?
02:53:10 <dons> its a text editor, entirely centered around mutable state
02:53:11 <sieni> nope
02:53:35 <dons> shapr: edwark is using hs-plugins to jit an abstract machine
02:53:39 <dons> that's kinda cool and fun
02:53:40 * xerox scratches head
02:53:45 <Lokadin> xerox: it changes error to Expected type: String -> [String] Inferred type: (([Char] -> [Char]) -> b) -> [b]
02:54:20 <xerox> Lokadin: the simpler definition is convert xs = [f xs, g xs, h xs]
02:54:47 <xerox> Lokadin: given f, g, h :: String -> String, and xs :: String, you'll have convert :: String -> [String]
02:55:08 <xerox> @pl convert xs = [f xs, g xs, h xs]
02:55:09 <lambdabot> convert = liftM2 (:) f (liftM2 (:) g (return . h))
02:55:13 <Lokadin> oh really? cool i'll try that
02:55:16 <xerox> Oh, blech.
02:55:29 <xerox> convert = ([f,g,h] `ap`) . return -- is more stylish.
02:55:58 <gds> llama32: I think dons intended to address this line to you: "10:51       dons  : lambdabot: yeah, since you can manage state in a simpler, safer way,"
02:56:18 <xerox> gds: ah-ha.
02:56:22 <foxy_> @where Cabal
02:56:22 <lambdabot> http://www.haskell.org/cabal
02:57:23 <Lokadin> xerox: gives me that index is too large error again, if i do covert obu = [f obu , g obu, h obu]
02:57:41 <xerox> Lokadin: what index?
02:57:55 <Lokadin>  Exception: Prelude.(!!): index too large
02:58:05 <xerox> What is using (!!) ?
02:58:19 <Lokadin> i never call anything higher than 2 though
02:58:22 <Lokadin> it should be in the paste
02:58:35 <dons> gds, oh. yes.
02:58:37 <dons> oops
02:58:48 * dons talks to lambdabot too often. we're like an old married couple
02:58:53 <xerox> Lokadin: |args !! 0| is equivalent to |head args|
02:58:58 <dons> ?vixen-on
02:58:59 <lambdabot> What's this channel about?
02:59:02 <dons> want to get married?
02:59:02 <lambdabot> is that really what you want to know?
02:59:10 <dons> yes, i really want to know.
02:59:11 <lambdabot> i know you know
02:59:19 <xerox> dons: we're getting more and more weird as the time goes
02:59:19 <lambdabot> why do you say weird?
02:59:21 <dons> you obfuscate sometimes, my dear
02:59:21 <lambdabot> I'd rather have 5 guys in one week then 1 guy 5 times a week :)
02:59:29 <dons> ah, the true colours are shown
02:59:30 <lambdabot> what's worth more a flush or a full house?
02:59:30 <shapr> dons: That is nifty.
02:59:31 <lambdabot> Whatever
02:59:34 <dons> ?vixen-off
02:59:34 <lambdabot> Bye!
03:00:03 <Lokadin> xerox: so now it says empty list
03:00:05 <xerox> Lokadin: ok, I got it.
03:00:12 <Lokadin> :)
03:00:17 <xerox> Lokadin: you'd better _check_ how many arguments you get passed.
03:00:39 <Lokadin> oh man
03:00:47 <Lokadin> .oiro'a
03:00:53 <Lokadin> that's sooo embarassing
03:01:04 <xerox> do { args <- getArgs; case length args of 0 -> usage; n -> foo n; } -- for example
03:01:17 <xerox> `foo (head args)' even.
03:01:25 <Lemmih> shapr: Join #anglohaskell?
03:01:27 <shapr> Lokadin: xu do tavla bau la lojban
03:01:39 <tessier__> uh
03:01:40 <Lokadin> go'i
03:02:01 <shapr> .uecui'i
03:02:39 <shapr> Lokadin: When did you get into lojban?
03:04:04 <Lokadin> pe'i when do mention la'edi'u
03:04:42 <Lokadin> or i think when you mentioned it
03:04:49 <shapr> oh
03:05:09 <Lokadin> so a few weeks ago
03:05:26 <Lokadin> pu ze
03:05:42 <shapr> Neat
03:06:43 <shapr> Lojban gave me a different viewpoint, much like Haskell does.
03:06:56 <Lokadin> .ie
03:07:17 <Lokadin> mi'u
03:07:21 <xerox> @remember Lemmih <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
03:07:22 <lambdabot> Done.
03:09:14 <Lokadin> well i'm learning it so i could have a language for cross function communication, and even for description of the interactions of functions, i believe i mentioned it earlier though
03:09:41 <Lokadin> er function, meaning in different languages, not haskell functions
03:09:56 <Lokadin> si si just haskell functions
03:18:45 <Itkovian> can ghc ignore explicit INLINE directives?
03:32:51 <nothingmuch> 3/w 21
03:43:20 <dmhouse> Morning channel.
03:49:30 <araujo> morning
03:58:32 <erider> hi araujo
03:59:26 <dcoutts> @seen dons
03:59:27 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 59 minutes and 53 seconds ago.
04:00:52 <araujo> hi there erider
04:01:17 <erider> araujo, how are you doing today?
04:01:43 <araujo> erider, pretty fine thanks , just get up, yourself? :-)
04:01:50 <JohnMeacham> gour: it's a little broken right now. use the pre-built libraries and only compile single-file programs. fix should come shortly.
04:02:17 <erider> I doing fine. going to do some lisp hacking today
04:05:16 <erider> araujo, I thinking about getting a mac
04:14:29 <araujo> nice erider
04:20:18 <ndm> in GHC, after forkIO how do i get the system to wait until that thread has finished?
04:22:55 <xerox> ?index forkIO
04:22:55 <lambdabot> Control.Concurrent
04:22:55 <xerox> ?docs Control.Concurrent
04:22:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
04:23:39 <mahogny> gtk/glade: am I right in assuming that glade creates all widgets when I load the XML file? if so, then I assume glade kind of sucks in case you want multiple instances of a window (ie have to load the file multiple files)
04:27:03 <shapr> Lokadin: Have you written more about that on a blog somewhere?
04:28:18 <ndm> xerox: i couldn't find anything specific, other than creating an MVar and blocking on it through both threads
04:29:37 <xerox> Right :-/
04:29:37 <ndm> mahogny: the time to load an XML file is low, so does it matter if you just load it multiple times?
04:29:37 <mahogny> ndm: well, it means I have to create multiple xml files, one for each window
04:29:37 <mahogny> so it's only about userfriendlyness
04:32:00 <ndm> i was hoping that there would be some way to not have an external .glade file with Gtk
04:35:26 <shapr> @yow !
04:35:27 <lambdabot> Maybe we could paint GOLDIE HAWN a rich PRUSSIAN BLUE --
04:35:32 <shapr> Would that help?
05:22:28 <roconnor> @seen dons
05:22:28 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2 hours, 22 minutes and 54 seconds ago.
05:41:48 <shapr> Since it's so quiet, I have a *totally* off-topic question. Has anyone tried to put carbonated beverages into a thermos?
05:42:13 <psnl> not recently
05:42:32 <shapr> I like to drink sprite/7up clones while coding, but I want them to stay cold over several hours.
05:43:00 <ndm> i've put beers in the freezer before, not a particularly good idea
05:44:01 <psnl> ndm: heh, works if you remember about them
05:44:19 <ndm> psnl: yeah, that rarely happens
05:44:55 <ndm> esp given that i usually keep a few beers in the fridge, so when i want instantly cold beers i've usually drunk a bit first
05:45:01 <malcolm> psnl: I hear you are working on Hat
05:46:14 <psnl> will be working on, I don't have my haskell box here
05:46:32 <psnl> malcolm: my disseration is writing a gui for hat
05:46:43 <malcolm> psnl: undergrad dissertation?
05:46:46 <psnl> aye
05:47:36 * malcolm looks forward to psnl posting to the Hat mailing list about it :-)
05:47:47 <psnl> yeah, I should
05:48:17 <psnl> I wrote up my proposal/lit study at the end of last term, but that was more lit study than proposal
05:48:56 <psnl> I'll write up the proposal properly at some point, and I would like to get it done soon
05:49:21 <ndm> psnl: are you likely to base it starting from hat-gui?
05:49:24 <malcolm> are there some specific goals, e.g. to unite several tools into one?
05:49:52 <psnl> ndm: I need to talk to paul about that, wrt to the copying rules
05:50:20 <ndm> psnl: at the moment its highly incomplete, and certainly only useful as a very slight base, nothing more
05:50:21 <psnl> malcolm: the basic plan is all the tools currently listed on the hat site, but with a gui frontend
05:50:27 <psnl> ndm: cool
05:50:40 <psnl> ndm: it will look like that, I think
05:50:55 <ndm> psnl: but if you need anything, like me to say whats mine/yours etc just ask
05:51:05 <psnl> will do
05:51:26 <psnl> malcolm: do you have any thoughts on it?
05:51:59 <malcolm> I'm sure I'll have some fairly detailed thoughts once the basic plan is set out
05:52:45 <malcolm> But yeah, a nice clickable interface would certainly help many people to get started into Hat.
05:55:10 <psnl> malcolm: I'll try and get the proposal written up for the end of the week
05:56:02 <malcolm> psnl: I'm on holiday from the end of week
05:56:17 <psnl> hum
05:56:22 <psnl> from friday?
05:56:27 <ndm> i'd certainly love to see the proposal :)
05:57:05 <psnl> ndm: good good
05:57:12 <malcolm> psnl: from Sunday, but that does mean you are unlikely to get a response from me for a bit.
05:57:35 <malcolm> but it would still be a good thing to write it up...
05:58:15 <psnl> yeah
05:58:42 <ndm> psnl: are you a Linux or a Windows user? and are you likely to pick Gtk2Hs for the GUI>?
05:58:49 <malcolm> it will give you longer for the ideas to form themselves properly - you can always come back and revise the proposal after more thought.
05:59:43 <psnl> ndm: linux, but I was planning on using gtk2hs
05:59:51 * dcoutts grins
06:00:28 <ndm> dcoutts, i am slightly tempted to port hat-gui to PropLang, but decided not to because of psnl only
06:00:44 <ndm> a bit unfair to force it on someone else at this stage
06:00:50 <dcoutts> mm
06:00:51 <psnl> malcolm: right now I'm picking bits of it and giving them a lot of thought, rather than thinking about it overall
06:01:21 <dcoutts> ndm, I need to take a closer look at your prop code some time
06:01:27 <ndm> psnl: each tool on a tab is a relatively simple first draft, i guess you'll onlly need to plan once you get beyond that
06:01:49 <ndm> dcoutts, give it a week or so, until i've got a first draft on GuiHaskell, as that might cause me to revise bits
06:01:58 <dcoutts> ok
06:02:22 <psnl> ndm: yeahish
06:02:40 <dcoutts> btw, I'm still not convinced that iterating over all the widgets in a window is the best approach, but again I'll need to look into just what you're doing more closely
06:03:06 <ndm> dcoutts, its only to make the startup a bit easier, but i think i can do it now with catching exceptions
06:03:15 * shapr boings
06:03:42 <ndm> the iteration is a very non-critical element of proplang, can easily be ignored
06:06:52 <xerox> ?seen bringerrt
06:06:52 <lambdabot> I haven't seen bringerrt.
06:06:55 <xerox> ?seen bringert
06:06:55 <lambdabot> I saw bringert leaving #haskell.se and #haskell 3 days, 18 hours, 3 minutes and 40 seconds ago, and .
06:07:30 <psnl> ndm: is your code in the york darcs repo?
06:07:54 <ndm> psnl: its in the hat cvs
06:08:08 <ndm> @seen donss
06:08:08 <lambdabot> I haven't seen donss.
06:08:40 <ndm> @tell dons @seen donss says I haven't seen donss, couldn't it do the edit distance on the name if it doesn't find it?
06:08:41 <lambdabot> Consider it noted.
06:09:14 * malcolm still intends to convert Hat from CVS to darcs
06:10:08 <shapr> yay!
06:10:09 <shapr> I like darcs.
06:12:58 <psnl> ndm: cool, looks good
06:13:25 <psnl> ndm: can the hat lowlevel modules handle two traces at once?
06:13:37 <ndm> psnl: even if you don't work starting from my GUI (which would be a shame), you can still use the library split i did
06:13:56 <psnl> ndm: aye
06:13:57 <ndm> psnl: no :(, but Tom has a library which can, and it might be worth porting all the hat tools to that
06:14:12 <ndm> since its a superset of all the other libraries
06:14:40 <psnl> tom shackell?
06:20:53 <ndm> psnl: yep
06:34:11 <petekaz> @seen musasabi
06:34:12 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I last heard musasabi speak 6 hours, 24 minutes and 40 seconds ago.
06:46:53 <bortzmeyer> I need a graph library. I checked Data.Graph (standard library) and FGL. Data.Graph is quite poor (not even a way to label edges). FGL is much better but not "standard". Any other choice or advice?
06:47:04 <bortzmeyer> For instance, FGL is in ghc but not in Hugs.
06:50:24 <ndm> bortzmeyer: what do you want to do?
06:50:57 <shapr> FGL is Data.Graph.Inductive, right?
06:51:03 <ndm> bortzmeyer: I've found Haskell very poor for Graph manipulation...
06:51:07 <bortzmeyer> shapr: Yes, correct
06:51:29 <bortzmeyer> ndm: create a graph, find out if it is connected, translate to Graphviz, the usual stuff
06:51:33 <ndm> bortzmeyer: thats on hugs
06:51:57 <bortzmeyer> ndm: where in Hugs? Data.graph does not allow to label edges, for instance
06:52:03 <ndm> :l Data.Graph.Inductive
06:52:21 <ndm> bortzmeyer: works for me fine
06:52:47 <bortzmeyer> ndm: ERROR - Can't find module "Data.Graph.Inductive"
06:53:02 <ndm> bortzmeyer: which release of Hugs are you on? Windows on Linux?
06:53:27 <ndm> :version will tell you
06:54:03 <bortzmeyer> ndm: -- Hugs Version November 2003
06:54:21 <ndm> bortzmeyer: UPGRADE!!!!! its May 2006 that has it fine
06:55:27 <bortzmeyer> ndm: "sudo emerge hugs" is going on
06:55:53 <ndm> bortzmeyer: with that, the libraries between Hugs and GHC are pretty close to identical, so it should work fine
06:56:54 <bortzmeyer> ndm: OK, I agree and since FGL is *much* better than Data.Graph, I'll use it (but the documentation is quite poor and outdated, I have to read the source)
06:57:41 <ndm> bortzmeyer: have you seen the The Monad Reader tutorial on Data.Graph.Inductive?
06:58:14 <bortzmeyer> ndm: no, sorry, I missed it
06:58:22 <ndm> @where TMR
06:58:23 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
06:58:26 <musasabi> petekaz: pong
06:58:35 <ndm> bortzmeyer: its a tutorial rather than documentation, but might help you
06:58:50 <bortzmeyer> FGL with hugs has some problems. My programs which run fine with ghc fail on hugs :-( Type error in application
07:02:25 <ndm> bortzmeyer: are you using Hugs with extensions?
07:02:35 <ndm> pass the -98 flag when you start Hugs
07:03:58 <bortzmeyer> Yes, without -98, it cannot even load FGL (Data.Graph.Inductive)
07:04:05 <bortzmeyer> But, with -98, I get:
07:04:21 <bortzmeyer> ERROR "mytest.hs":8 - Type error in application
07:04:21 <bortzmeyer> *** Expression     : mkGraph mynodes myedges
07:04:21 <bortzmeyer> *** Term           : myedges
07:04:21 <bortzmeyer> *** Type           : [(Integer,Integer,[Char])]
07:04:21 <bortzmeyer> *** Does not match : [LEdge [Char]]
07:04:28 <bortzmeyer> For a code which works with ghc
07:05:34 <ndm> bortzmeyer: no idea on that, try a mailing list would be my suggestion (haskell-cafe)
07:05:46 <bortzmeyer> ndm: many thanks, yes, I'll try
07:09:03 <petekaz> musasabi: figured out the answer myself, wasn't sure what the 'something#' referred to in GHC/Conc.  Now I realize those are primops.
07:12:12 <petekaz> musasabi: late last night I had a revelation.  I was thrown off by your comment about the extra OS thread being the io manager, so I spent a long time trying to find where the RTS actually spawned off a new OS thread for the io manager.  It turns out (as you already know) that the io manager is simply a Haskell thread, not an OS thread. However the io managen does make a FFI call to select() which happens to be a 'safe' call, thus
07:12:13 <petekaz> running in its own OS thread each time it invokes select().
07:14:06 <petekaz> musasabi: the part that was throwing me off, I didn't realize the io manager threard was being prempted like any other normal haskell thread, for some reason, I thought it was some "special" OS thread.  It turns out I was wrong.  When that select() returns, and the io manager code starts running, it can be prempted like any other thread.
07:16:17 <musasabi> petekaz: your current understanding seems correct.
07:16:55 <petekaz> thanks ... where were you last night at 2am?  :-)
07:18:16 <Philippa> heh
07:19:36 <musasabi> I was on #haskell most of the last night, just few hours I spent away cooking or staring outside.
07:21:29 <petekaz> musasabi: I know but I felt bad bothering you again :-)
07:21:54 <petekaz> It was a good exercise to go through the code.
07:29:19 <vincenz> @seen dons
07:29:19 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 4 hours, 29 minutes and 45 seconds ago.
07:29:22 <vincenz> @localtime dons
07:29:24 <lambdabot> Local time for dons is Fri Jul 28 00:23:08 2006
08:03:54 <dcoutts> vincenz, ping
08:04:45 <boegel> vincenz: ping too
08:04:49 <boegel> @seen vincenz
08:04:50 <lambdabot> vincenz is in #oasis and #haskell. I last heard vincenz speak 35 minutes and 28 seconds ago.
08:12:48 <dcoutts> heh, cool - Gtk2Hs and Cairo in Japanese:
08:12:48 <dcoutts> http://d.hatena.ne.jp/maoe/20060618/1150652151
08:12:51 <lambdabot> Title: maoeのブログ - HaskellとGtk2Hsとモナドとマンデルブロ集合
08:14:43 <xerox> dcoutts: how nice!
08:14:49 <dcoutts> yeah
08:15:03 <dcoutts> we should go pester more people for screenshots for the Gtk2Hs website :-)
08:15:11 * xerox nods
08:25:44 <kuribas> I had an idea about coding an interactive app functionally, I wonder if it has been done before.
08:26:31 <sieni> like functional reactive programming or something like that?
08:27:01 <kuribas> sieni: Could be, I don't know the term...
08:28:02 <kuribas> The idea is that you start from a AST for let's say a word processor (or a browser).
08:28:04 <vincenz> pong
08:28:12 <vincenz> dcoutts: pong
08:28:14 <vincenz> boegel: pong
08:29:09 <kuribas> In a non interactive app this is no problem, but in an interactive one you would need to regenerate the whole output if something changes in the AST.
08:29:46 <kuribas> So the idea is to only generate the changes that are necessary.
08:29:55 <kuribas> Has this been done?
08:31:18 <emertens> when implementing LCS... is there a more efficient algorithm than dynamic programming where time and size are O(m*n) where m and n and are the lengths of the two strings?
08:31:28 <emertens> (4) constrained (optional) specifies that a foreign key constraint on the primary key of the mapped table references the table of the associated class. This option affects the order in which Save() and Delete() are cascaded (and is also used by the schema export tool).
08:31:36 <emertens>  (oops)
08:32:34 <emertens> I don't see how the algorithm could have a time complexity less than O(m*n) but I did wonder about space complexity
08:33:39 <dcoutts> vincenz, I had people asking me where your red-black tree code was
08:33:56 <dcoutts> vincenz, you said it's on your website?
08:34:09 <vincenz> oy
08:34:11 <vincenz> no more
08:34:16 <vincenz> but it's not an actual implementation of RBtrees
08:34:21 <vincenz> just a validation thereof
08:34:38 <vincenz> let me put it online
08:34:49 <sjanssen> emertens: I don't know about your problem specifically, but in many DP problems you can reduce your space from a 2d array to a single dimension
08:35:18 <dcoutts> vincenz, yeah, it was only the GUI code that I was ondering about
08:35:21 <emertens> sjanssen: I know how to do that if I don't want to know how it got to my solution
08:35:47 <emertens> aka AABBCCDD `lcs` ABCDEFG -> 4
08:35:56 <emertens> but when I want to see -> ABCD
08:36:07 <vincenz> dcoutts: it's on there
08:36:08 <emertens> I haven't figured out a way to do it with a single array
08:36:10 <sjanssen> yeah, that is trickier
08:36:15 <vincenz> dcoutts: just wasn't mentioned in a page
08:36:19 <vincenz> http://www.notvincenz.com/wiki/uploads/Personal/tree.hs
08:36:32 <dcoutts> ta
08:39:01 <kuribas> sieni: would reactive programming work for a word processor?
08:40:10 <vincenz> dcoutts: as sooon as I get a hold of dons I'm gonna move my stuff to the uni server where i'll be able to make a more sane webpage and organize it all a bit better with repos and all
08:40:23 <dcoutts> vincenz, right'o
08:43:17 <vincenz> just need to get a hold of him caucse I'd like to use his layout
08:46:05 <vincenz> @seen boegel
08:46:05 <lambdabot> I saw boegel leaving #haskell-blah and #haskell 11 minutes and 21 seconds ago, and .
08:46:24 <kuribas> sieni: No it's not the same as reactive programming.
08:51:21 <kuribas> Are there interactive document editors that are programmed in a functional language?
08:51:45 <emertens> like Yi?
08:52:10 <vincenz> kuribas: Not sure I understand you... is the document in AST format or the appitself  I thought you meant the app, but if the app is a wordprocessor how will one be able to modify it, most wordprocessors are not intended for changing the wordprocessor but for doing word processing
08:52:35 <emertens> vincenz: you mean a word processor processor?
08:52:48 <vincenz> emertens: don't ask me, ask kuribas
08:53:36 * vincenz mutters as he lost the printout version of bringert's paper
08:53:45 <kuribas> No, the document structure is in an AST
08:53:48 <vincenz> oh
08:53:57 <vincenz> sort of like .... XML
08:54:04 <kuribas> yes
08:54:06 <vincenz> and AST is really the wrong terminology
08:54:12 <vincenz> parse-tree at best
08:54:18 <emertens> isn't AST a parsing mechanism?
08:54:20 <vincenz> no
08:54:24 <vincenz> AST = Abstract Syntax tree
08:54:32 <vincenz> aka the cleaned up internal DSL version of a parsetree
08:54:33 <kuribas> vincenz: yes, I thought AST is maybe the wrong term...
08:54:52 <dmhouse> Once you've parsed everything, you're left with an AST (normally).
08:54:56 <vincenz> dmhouse: nope
08:55:02 <vincenz> dmhouse: you're left with a parse-tree
08:55:24 * vincenz ponders
08:55:31 <vincenz> well it depends, maybe you're left with an AST
08:55:33 <dmhouse> vincenz: Oh? Where does an AST come into it then?
08:55:36 <dmhouse> I'd have thought it was:
08:55:50 <dmhouse> Input -(lexer)-> [Token] -(parser)-> AST
08:56:05 <vincenz> officially the steps are
08:56:12 <vincenz> string -> [token] -> parse tree -> AST
08:56:18 <vincenz> but the parse-tree is implicitly encoded in the praser
08:56:24 <vincenz> who'll typically recombine stuff in it's actions
08:56:26 <vincenz> to generate AST on the fly
08:56:40 <dcoutts> anyone here run WordPress? How do I know exactly what version I'm running?
08:56:51 <vincenz> dmhouse: but some c++ parsers do still give a parse-tree and it's horrible
08:56:55 <dmhouse> dcoutts: go into the admin section, right at the bottom.
08:57:05 * dmhouse was a WordPress developer for quite some time.
08:57:17 <dcoutts> dmhouse, I see it says 2.0, but I think I'm using 2.0.x something
08:57:17 <kuribas> let's say it's just a datatype that holds the logical information.
08:57:28 <dmhouse> dcoutts: that's your exact version.
08:57:38 <dmhouse> dcoutts: it's pulled directly from wp-admin/version.php
08:57:41 <dcoutts> dmhouse, ah, ok, so very out of date
08:57:46 <dmhouse> Or wp-includes, perhaps.
08:57:50 <kuribas> vincenz: How would you call that?
08:58:02 <vincenz> kuribas: not certain, not my area
08:58:10 <dmhouse> Yes, wp-includes/version.php.
08:58:12 <dcoutts> dmhouse, yep, wp-includes/version.php
08:58:25 <dcoutts> dmhouse, thansk! I'll got upgrade to 2.0.3
08:58:39 <vincenz> kuribas: study ODF?
08:59:22 <dmhouse> dcoutts: Incidentally, I don't think 2.0.4 is very far away.
08:59:27 <kuribas> vincenz: I didn't have a particular datatype in mind, just a general idea.  Actually I was thinking about a music notation app.
08:59:44 <dmhouse> dcoutts: although I could be wrong.
08:59:56 <dcoutts> dmhouse, aye, but I'd rather not wait. I hear there are security issues with 2.0.x x<3
09:00:04 <dmhouse> Yeah.
09:00:15 <dcoutts> I'll upgrade again if 2.0.4 has more secuirty fixes
09:00:19 <vincenz> kuribas: tree?
09:00:24 <dmhouse> The minor versions often do.
09:00:27 * dcoutts should get on the WP announcements list
09:00:33 <dmhouse> Although 2.0.3's been out a while.
09:00:50 <psnl> dcoutts: I assume you saw thing thing on planet debian
09:01:17 <dcoutts> psnl, or from somewhere yeah, I don't recall now
09:02:41 <kuribas> vincenz: yes.  Well the idea is that the programmer just describes a functional transformation from a tree to a set of graphical objects, and when there is a small change, only the graphical objects that change are regenerated.
09:04:06 <kuribas> That could be done by compiling the transformation into code that would take care of the dependencies.
09:04:58 <kuribas> So a change to a small part of the tree doesn't resolve into regenerating the whole output.
09:06:06 <kuribas> It's an optimization, but a necessary one for an interactive editor.
09:06:11 <kuribas> Does this make sense?
09:07:02 <musasabi> kuribas: it makes sense.
09:07:23 <musasabi> kuribas: except that you want probably directed graphs instead of trees.
09:08:04 <kuribas> why?
09:08:46 <musasabi> kuribas: thus GUI actions become "newtype GT = GT (GuiGraph, GuiGraph -> GuiGraph); handler :: GuiGraph -> GT"
09:09:30 <musasabi> kuribas: because e.g. the same menu may be shared for right clicking and for normal access from the menubar.
09:09:43 <musasabi> kuribas: or simple controls referring to their parents.
09:10:25 <dmhouse> Hmm, the cvs-ghc list has a very low signal to noise ratio.
09:11:13 <musasabi> dmhouse: it is quite usefull. Filtering the test-build results to /dev/null helps
09:11:25 <kuribas> musasabi: Ah I see.  That's interesting.  I hadn't really thought about GUI elements, just the interactive editing part.
09:13:09 <kuribas> It could work for GUI's but I don't think it would easily integrate with existing toolkits.
09:23:22 <vincenz> @seen bringert
09:23:23 <lambdabot> I saw bringert leaving #haskell.se and #haskell 3 days, 21 hours, 20 minutes and 8 seconds ago, and .
09:23:38 <vincenz> @tell dons Would it be possible to get your layout for your site?
09:23:38 <lambdabot> Consider it noted.
09:24:03 <MarcWeber> How can I apply this definition? fmap = (.)   This way? :
09:24:28 <MarcWeber> fmap (*2) [(+1),(+2)] ?
09:24:58 <xerox> I don't think so.
09:25:16 <xerox> What instance does it appear in?
09:25:27 <dmhouse> > (*2) `fmap` (+4) $ 3
09:25:29 <lambdabot>  14
09:25:40 <sjanssen> MarcWeber: do you want foldr (.) instead?
09:25:52 <dmhouse> It looks to me like it's flip (.).
09:25:58 <xerox> ?type ((*2) `fmap`)
09:26:00 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => f a -> f a
09:26:14 <xerox> ?type (`fmap` (*2))
09:26:15 <sjanssen> > foldr (.) 1 [(+2), (*3)]
09:26:15 <lambdabot> forall a b. (Num a) => (a -> b) -> a -> b
09:26:16 <lambdabot>  add an instance declaration for (Num (a -> c))
09:26:38 <sjanssen> > foldr ($) 1 [(+2), (*3)]
09:26:40 <lambdabot>  5
09:26:40 <xerox> > foldr (.) id [(+2),(*3)] $ 1
09:26:41 <lambdabot>  5
09:26:51 <vincenz> @tell bringert When do you want to talk about the 2-parameter GADT case for compos?
09:26:52 <lambdabot> Consider it noted.
09:27:04 <dmhouse> > foldr (flip (.)) id [(+2), (*3)]
09:27:05 <lambdabot>  Add a type signature
09:27:09 <dmhouse> > foldr (flip (.)) id [(+2), (*3)] 1
09:27:10 <lambdabot>  9
09:28:00 <dmhouse> > execState (mapM modify [(+2) (*3)]) 1
09:28:01 <lambdabot>  add an instance declaration for (Num (s -> s))
09:28:06 <dmhouse> > execState (mapM modify [(+2), (*3)]) 1
09:28:08 <lambdabot>  9
09:28:13 <dmhouse> :)
09:28:17 <MarcWeber> dmhouse, sjanssen I was reading the moand reader source of ghc.. and I couldn't imagine how to apply this..
09:28:29 <dmhouse> MarcWeber: not like this.
09:28:35 <dmhouse> MarcWeber: do you know what the Reader monad is for?
09:28:57 <dmhouse> MarcWeber: try http://www.nomaware.com/monads/html/readermonad.html
09:28:57 <emertens> I don't, so if you wanted to explain it... ;)
09:28:58 <lambdabot> Title: The Reader monad
09:29:03 <MarcWeber> dmhouse: You have a value which you can get by using ask and apply it to functions, right?
09:29:10 <dmhouse> Basically, it saves you passing around an argument.
09:29:25 <xerox> a.k.a. Environment Monad.
09:29:27 <dmhouse> Right.
09:29:50 <xerox> Hence the `e' in Reader e a = e -> a.
09:29:55 <dmhouse> It's a convenient way for a bunch of functions to share the same argument (or to draw values from the same environment, if you like).
09:30:34 <dmhouse> And yeah, you fetch the argument using ask.
09:30:59 <dmhouse> Reader's a little funkier in that you can modify the environment for sub-computations (using local).
09:34:17 <xerox> Such utility actions are parametrized under the MonadReader multiparameter typeclass.
09:36:09 <MarcWeber> dmhouse: So can you give me an example on how to use this fmap? I'm still struggling.
09:36:30 <dmhouse> MarcWeber: do you know what fmap does, conceptually?
09:36:42 <MarcWeber> The same as map
09:36:52 <xerox> MarcWeber: just expand the type!
09:37:00 <dmhouse> MarcWeber: not quite.
09:37:02 <xerox> ?type fmap
09:37:02 <MarcWeber> it applies a function to elements of a container such like list, tree, whatever
09:37:03 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
09:37:15 <xerox> ... where f = (e ->)
09:37:19 <dmhouse> MarcWeber: that's okay when you're thinking about Functors, which are typically containers.
09:37:36 <dmhouse> MarcWeber: But not so helpful when you're thinking in terms of monads, which are typically types of computation.
09:37:55 <dmhouse> fmap, in general, 'lifts' a function from being pure to being monadic.
09:38:05 <dmhouse> (It's the same as liftM, if you're familiar with that.)
09:38:34 <dmhouse> So if you have some IO String, say, and wanted to convert the string to be all uppercase, you could do fmap (map toUpper).
09:39:15 <dmhouse> Sorry, fmap (map toUpper) yourIOStringValue.
09:39:19 <MarcWeber> dmhouse: liftM, yes I am.
09:39:25 <dmhouse> (Because map toUpper is the function that converts a string to uppercase.)
09:39:28 <dmhouse> Okay, great.
09:39:50 <dmhouse> Well, in terms of Reader, a monadic function is different from a pure function because it might look at the environment.
09:40:40 <MarcWeber> Yeah... this may be some kind of debugging yes/no value..
09:40:43 <dmhouse> Err, hold on a minute.
09:40:50 <MarcWeber> Np
09:41:26 <dmhouse> Right.
09:41:54 <dmhouse> 'fmap someFunction', when you're looking at Reader, will be of the type Reader a -> Reader b.
09:42:10 <dmhouse> I.e. it transforms one Reader computation into another.
09:42:50 <dmhouse> Argh, it's all gone horribly wrong :)
09:42:54 <dmhouse> Okay.
09:43:17 <dmhouse> Imagine we have some Reader computation:
09:43:27 * MarcWeber is listening closely
09:43:52 <dmhouse> f = do x <- ask; ask (x * 2)
09:43:56 <dmhouse> A bit weird, but it'll do.
09:44:06 <vincenz> Inferred type is less polymorphic than expected
09:44:09 <vincenz> yuck
09:44:17 <dmhouse> Then we do fmap (+3) f
09:44:49 <dmhouse> Wait, no, that's wrong. :)
09:44:55 <dmhouse> f = do x <- ask; return (x * 2)
09:44:58 <dmhouse> We're left with a Reader computation that reads from the environment (x <- ask), then reads again from the environment,
09:45:02 <dmhouse> Err, sorry
09:45:10 <dmhouse> Let's start again. I'll get it right this time.
09:45:12 <dmhouse> f = do x <- ask; return (x * 2)
09:45:15 <dmhouse> Then we do fmap (+3) f
09:45:28 <MarcWeber> Oh. .now I can follow you..
09:45:36 <dmhouse> We're left with a Reader computation that reads from the environment (x <- ask), then returns the result of that environment access mulitplied by two.
09:45:46 <dmhouse> AND with 3 added onto the end.
09:45:46 <MarcWeber> right
09:46:33 <dmhouse> The (+3) is pure (it doesn't access the environment), but we used fmap to 'lift' it to a monadic Reader function.
09:46:34 <MarcWeber> I hope I got it.. wait.. I'll prepare another example
09:46:49 <dmhouse> Now.
09:47:34 <dmhouse> Reader's internals are as follows: newtype Reader e a = Reader { runReader :: e -> a }. That looks a little horrid, but what it means is that some value 'Reader Int Bool' is really just a function Int -> Bool.
09:48:03 <dmhouse> So if you have Int -> String -> Fred -> Reader Foo Bar, then what that expands to is Int -> String -> Fred -> Foo -> Bar.
09:48:23 <dmhouse> Foo is the type of your environment, so you can see that what we're _really_ doing is just passing that environment around.
09:48:29 <MarcWeber> I got that. Give 2 minutes.
09:48:34 <dmhouse> But we use Reader to make it all nice and pretty.
09:48:37 <dmhouse> Sure :)
09:48:48 <dmhouse> (This will lead to a grand finale of why fmap = (.) for Reader.)
09:57:47 <MarcWeber> dmhouse: I take your example ( ask >>= (return.(*2))) 3 which leads to 6 and I prepend it with fmap (+3) = (.) .. Nothing special.. except when using fmap you don't need the shift key..
09:58:49 <dmhouse> ?
10:00:16 <MarcWeber> I have to look at the a. a. monads example again.
10:04:00 <dmhouse> MarcWeber: you shouldn't be using fmap as a replacement (.). It's just interesting that fmap turns out to be equal to (.) in the special case of the Reader monad.
10:06:16 <xerox> Looking at how the type of |fmap :: (Functor f) => (a -> b) -> f a -> f b| expand for f = (e ->), that is |fmap :: (a -> b) -> (e -> a) -> (e -> b)| the most straightforward implementation is exactly |fmap f x = f . x| which reduces to |fmap = (.)|.
10:08:26 <edwardk> hrmm.. could i get some help with a type level fixpoint problem?
10:08:36 <edwardk> @paste
10:08:37 <lambdabot> http://paste.lisp.org/new/haskell
10:09:31 * xerox . o O ( ``Type level fixpoint'' ?! )
10:11:28 <lisppaste2> edwardk pasted "dilemma (trilemma?)" at http://paste.lisp.org/display/23259
10:12:24 <edwardk> I need to jit plugins that need to be able to access the jit function that can make more of them basically
10:12:49 <vincenz> \o
10:12:51 <vincenz> \o/
10:13:10 <edwardk> so i have to find a fixpoint at the type level or i have to mangle them to return their register contents and the new finger and have a trampoline call back into the jit
10:13:58 <edwardk> but i can't seem to take the fixpoint for the state in my monad
10:14:08 <edwardk> it might just be i'm being stupid though
10:15:46 <edwardk> any thoughts?
10:16:15 <kosmikus> I don't get your problem
10:16:19 <edwardk> ok
10:16:45 <edwardk> i have an engine that basially compiles a UM starting from a given address til it encounters a halt or a loadprog
10:16:57 <edwardk> the result becomes a function that i load back in via the hsplugins interface.
10:17:34 <edwardk> then i call into that function, it does its thing monadically, and at the end if it goes to loadprog another program i check my intmap of jitted functions, and if found, tail-call into that func.
10:17:37 <kosmikus> too concrete ;)
10:17:41 <edwardk> if not, i haveto compile another function. =)
10:18:12 <edwardk> the issue at hand is that the JitRState and the JitR monad have a mutually recursive definition
10:18:13 <kosmikus> for the type problem you pasted, the problem is, if I understand the situation correctly, that you need a higher-order fixpoint
10:18:42 <edwardk> ok. suggestions on how to implement it?
10:18:58 <kosmikus> kind annotation?
10:19:13 <edwardk> that was the syntax i was overlooking.
10:19:13 <edwardk> =)
10:19:54 <edwardk> so I can state that JitR' m has kind * -> * and might get off the horns of my dilemma?
10:20:17 <MarcWebe1> xerox, dmhouse thanks. I think I got it now.
10:20:38 <edwardk> got it, found the current ghc syntax in the haskell prime reference =)
10:22:30 <xerox> edwardk: may you annotate the solution? (-:
10:22:48 <edwardk> heh when it works =)
10:22:49 <kosmikus> edwardk: you still have the problem that you're partially applying a type synonym, too
10:23:12 <edwardk> kosmikus: that was because i started randomly permuting the version i had til it was in the form you see
10:23:18 <edwardk> =)
10:23:32 <edwardk> this is actually way stripped down from the version in the code i'm interested in
10:25:36 <edwardk> anyways,, if you can figure out a way to fix it with the kind annotation i'd appreciate it. i'm still banging my head against it
10:25:49 <kosmikus> I can paste a kind-correct piece of code that I got from correcting yours
10:25:54 <kosmikus> I'm not sure if it expresses anything useful
10:25:59 <edwardk> sure
10:26:00 <kosmikus> but it compiles
10:26:06 <edwardk> thats a step in the right direction =)
10:26:38 <lisppaste2> kosmikus annotated #23259 with "kind correct" at http://paste.lisp.org/display/23259#1
10:27:47 <edwardk> hahaha thats the original version plus the (f:: annotation i couldn't figure out how to express) =)
10:28:35 <kosmikus> actually, the annotation is not even needed
10:28:49 <kosmikus> so if you had that already, it should have worked ...
10:28:50 <edwardk> interesting
10:29:30 <edwardk> ahh
10:29:32 <edwardk> i see
10:29:37 <edwardk> i had a type not a newtype in one case.
10:29:44 <edwardk> i overlooked the X
10:31:44 <roconnor> @seen dons
10:31:45 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7 hours, 32 minutes and 11 seconds ago.
10:33:26 <edwardk> there is no way to construct it without the newtype on JitR'?
10:39:13 <sieni> how do I make ghci understand usual command characters like ^D, ^U or arrows or even backspace on freebsd? Nothing seems to work.
10:39:24 <sieni> _every_ other program works fine
10:39:28 <mikael> you could always run it with rlwrap or something
10:40:17 <ulfdoz> sieni: Every other program is broken! ;) No, I think, you just need to write some inputrc for readline. But I have never done that.
10:41:03 <ulfdoz> sieni: As an easy alternative, you could wrap ledit around ghci, although this shouldn't be necessary.
10:51:32 <roconnor> why is sjanssen's UM so fat?
10:51:35 <roconnor> fast.
10:52:37 <dmhouse> It is phat too.
10:52:48 <roconnor> :)
10:53:45 <dmhouse> Time to write a wikibook module, methinks
10:55:00 <xerox> @karma+ dmhouse -- (wi)k(i)nowledge!
10:55:00 <lambdabot> dmhouse's karma raised to 1.
10:57:43 <dmhouse> Are Cont computations normally polymorphic in their final value?
10:58:01 * xerox nods
10:58:18 <xerox> dmhouse: do you remember the first bits of Cale's explanation?
10:58:27 <dmhouse> I.e. do you normally see Cont r Something, or Cont Foo Something?
10:58:35 <dmhouse> I'd guess the former would be more common.
10:58:39 <xerox> I might suggest you to try to type his CPS-ified `f'.
11:04:48 <dmhouse> xerox: URL?
11:05:37 <xerox> Let f x = x + 2, then f' k = k (x + 2).
11:05:53 <dmhouse> Right.
11:06:03 <dmhouse> So with Cont, that becomes:
11:06:12 <dmhouse> f' = calCC (x + 2)?
11:06:33 <xerox> ?type callCC
11:06:35 <lambdabot> Not in scope: `callCC'
11:06:41 <xerox> ?type Control.Monad.Cont.callCC
11:06:43 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => ((a -> m b) -> m a) -> m a
11:07:03 <xerox> @instances MonadCont
11:07:04 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
11:08:25 <dmhouse> @type (^)
11:08:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:14:21 <vincenz> how do I export imported modules?
11:14:34 <xerox> You write `module Foo' in the export list.
11:15:28 <vincenz> thx
11:15:42 <xerox> You're welcome.
11:18:20 <roconnor> how go I get the nice newtype deriving?
11:18:32 <dmhouse> Use -fglasgow-exts.
11:18:34 <sjanssen> roconnor: -fglasgow-exts
11:18:47 <dmhouse> And it's the "cunning newtype deriving" ;)
11:19:00 <roconnor> Is it {-# OPTIONS -fglasgow-ext #-}?
11:19:26 <Igloo> OPTIONS_GHC nowadays
11:19:42 <dmhouse> roconnor: and don't miss the 's'.
11:22:02 <roconnor> right
11:22:45 <dmhouse> roconnor: and don't miss the 's'.
11:25:07 <sieni> ulfdoz: bash works fine. rlwrap didn't have any effect on ghci (rlwrap is similar to ledit, I suppose)
11:25:54 <sieni> ulfdoz: and bash works fine
11:27:30 <roconnor> @hoogle [Either a b] -> ([a],[b])
11:27:32 <lambdabot> No matches, try a more general search
11:27:33 <sieni> but why on earth doesn't ghci react on ^D? do I have to do some stty magic or something?
11:28:09 <roconnor> @djinn [Either a b] -> ([a],[b])
11:28:10 <lambdabot> -- f cannot be realized.
11:28:21 <dmhouse> roconnor: I've got an algorithm for that, hold on.
11:28:27 <roconnor> lies
11:28:35 <roconnor> djinn is broken
11:28:37 <dmhouse> -- | Analoguous to 'catMaybes'.
11:28:37 <dmhouse> splitEithers :: [Either a b] -> ([a], [b])
11:28:37 <dmhouse> splitEithers = foldr accum ([], []) where accum = either (first . (:)) (second . (:))
11:28:50 <sieni> does anyone use ghc on freebsd?
11:28:57 <roconnor> is it a good producer / consumer?
11:29:09 <musasabi> sieni: I have used it to test things, but that machine is offline.
11:29:34 <roconnor> I suppose foldr is a good cosumer.
11:29:42 <sieni> is there some magic i need to tell ghci to work properly on a terminal?
11:30:06 <musasabi> sieni: could it be curses-related?
11:30:22 <sieni> don't know. rlwrap didn't have any effect
11:31:02 <sieni> how would I know that?
11:32:38 * dmhouse grumbles about MediaWiki's rubbish default style
11:37:13 <roconnor> wait, maybe @djinn doesn't do lists
11:37:40 <dmhouse> @djinn [a] -> Int
11:37:40 <lambdabot> -- f cannot be realized.
11:37:46 <dmhouse> @djinn-env
11:37:46 <lambdabot> data () = ()
11:37:47 <lambdabot> data Either a b = Left a | Right b
11:37:47 <lambdabot> data Maybe a = Nothing | Just a
11:37:47 <lambdabot> data Bool = False | True
11:37:47 <lambdabot> data Void
11:37:48 <lambdabot> type Not x = x -> Void
11:38:05 <zarvok> @help djinn-env
11:38:05 <lambdabot> djinn-env.
11:38:06 <lambdabot> Show the current djinn environment
11:38:10 <dmhouse> What a weird definition of Not.
11:38:19 <roconnor> dmhouse: it is standard
11:38:24 <dmhouse> It's all bottom-valued functions whose domain are the type?
11:39:26 <zarvok> It's easier to think about in terms of C-H:
11:39:32 <zarvok> Not x means x is false
11:39:39 <zarvok> so if we could get x, we could derive anything
11:39:47 <zarvok> including bottom
11:40:24 <mikael> what's djinn?
11:40:29 <zarvok> (since from a proof of falsehood we can derive anything, including falsehood)
11:40:37 <zarvok> djinn is a theorem prover
11:40:42 <dmhouse> Bottom =~ inconsistency, right?
11:40:42 <zarvok> you give it a type, and it give you a program of that type
11:40:46 <mikael> oh!
11:40:48 <dmhouse> Or is that divergence
11:41:05 <zarvok> normally we'd say a theory is inconsistent if every WFF is a theorem
11:41:12 <zarvok> if bottom is a theorem then every WFF is a theorem
11:41:14 <dmhouse> WFF?
11:41:18 <zarvok> well formed formula
11:41:29 <dmhouse> Right.
11:41:32 <Lemmih> @seen greenrd
11:41:33 <lambdabot> greenrd is in #haskell and #haskell-blah. I last heard greenrd speak 9 hours, 12 minutes and 31 seconds ago.
11:41:33 <zarvok> so, if bottom is a theorem, then the theory is inconsistent
11:42:18 <zarvok> there are other similar ways to define inconsistency, but they generally amount to the same thing
11:42:23 <dmhouse> What would you define as a WFF?
11:42:34 <vincenz> dmhouse: syntactically correct?
11:42:34 <zarvok> this depends on the specific system
11:42:41 <zarvok> generally you form an inductive definition
11:42:42 <dmhouse> Would that be a WTT? (Well-typed term)
11:43:11 <vincenz> zarvok: what's ne?
11:43:12 <vincenz> new
11:43:24 <zarvok> vincenz: not much, and with you?
11:44:01 <mikael> @djinn (Either a b) -> (Maybe a)
11:44:02 <lambdabot> f a =
11:44:02 <lambdabot>   case a of
11:44:02 <lambdabot>   Left b -> Just b
11:44:02 <lambdabot>   Right _ -> Nothing
11:44:10 <vincenz> zarvok: same, working on my compiler
11:44:12 <dmhouse> Aww
11:44:14 <vincenz> tho it's too fricking hot here to work
11:44:15 <mikael> hee-hee
11:44:16 <dmhouse> Err, ignore that.
11:44:19 <mikael> can I play with this in private?
11:44:33 <dmhouse> mikael: Of course. /msg lambabot :)
11:44:39 <zarvok> @where djinn
11:44:39 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
11:44:41 <zarvok> or download it
11:45:16 <zarvok> dmhouse: sorry for the delay, not quite
11:45:39 <zarvok> if you have a term of a specific type, then you know that type is equivalent to a theorem that is provable
11:45:48 <xerox> (mikael: /QUERY lambdabot usually opens a dedicated communcation window in IRC clients.)
11:45:50 <zarvok> but you might have a formula that is not provable, and therefore has no term
11:46:54 <dmhouse> Okay.
11:46:58 <roconnor> dmhouse: what is first and second?
11:47:05 <dmhouse> (Are we ignoring bottom for now?)
11:47:10 <mikael> thanks :-)
11:47:24 <dmhouse> roconnor: they're arrowic, but in terms of pure functions, first f (x, y) = (f x, y), and you can guess second :)
11:47:26 <roconnor> @hoogle first
11:47:27 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
11:47:27 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
11:47:27 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
11:47:27 <xerox> zarvok: what are terms in this context?
11:47:55 <dmhouse> xerox: terms in whatever calculus you're talking about.
11:47:57 <zarvok> I generally use "term" and "program" interchangeably.  Really by "term" I mean proof-term, but by C-H that's the same as a program
11:48:09 <dmhouse> Function, if you like.
11:48:16 <dmhouse> That's certainly a valid explanation in Haskell.
11:48:29 <xerox> The type terms, or value ones?
11:48:50 <zarvok> xerox: terms are programs, not types, generally
11:48:50 <dmhouse> Value ones.
11:49:04 <cjeris> dmhouse: oh, I get it!  roughly, "Arrow (->)" is true?
11:49:18 <dmhouse> cjeris: exactly 'instance Arrow (->)' is true :)
11:49:24 <xerox> ?fptools Control.Arrow
11:49:24 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
11:49:32 <dmhouse> cjeris: In fact, the best metaphor for thinking about arrows is to analogise them to pure functions.
11:49:42 <xerox> Search for that in the above url, cjeris.
11:51:34 <mikael> can I define types in the djinn bot?
11:51:37 <cjeris> somebody needs to write "How to program Haskell like a real category theory crackhead"
11:52:18 <musasabi> isn't there the product-example?
11:52:22 <dmhouse> cjeris: type classes to the extreme.
11:52:50 <dmhouse> @djinn-add List a = Nil | Cons a (List a)
11:52:51 <lambdabot> Cannot parse command
11:52:57 <dmhouse> @djinn-add data List a = Nil | Cons a (List a)
11:53:08 <xerox> No way, dmhouse :-)
11:53:22 <dmhouse> @djinn List a -> List b
11:53:22 <lambdabot> Cannot parse command
11:53:23 <lambdabot> -- f cannot be realized.
11:53:32 <musasabi> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:53:33 <lambdabot> Title: The Evolution of a Haskell Programmer
11:53:42 <mikael> that's exactly to the letter the type I tried to define :-)
11:53:43 <mikael> thanks
11:53:58 <mikael> oh, check this out:
11:54:00 <mikael> @djinn-env
11:54:01 <lambdabot> data () = ()
11:54:02 <lambdabot> data Either a b = Left a | Right b
11:54:02 <lambdabot> data Maybe a = Nothing | Just a
11:54:02 <lambdabot> data Bool = False | True
11:54:02 <lambdabot> data Void
11:54:03 <lambdabot> type Not x = x -> Void
11:54:05 <lambdabot> Error: Recursive types are not allowed: List
11:54:09 <dmhouse> Aha.
11:54:18 <dmhouse> @djinn-remove List
11:54:19 <lambdabot> Unknown command, try @list
11:54:31 <xerox> @djinn-del List a
11:54:32 <lambdabot> Cannot parse command
11:54:36 <xerox> @djinn-del List
11:54:36 <vincenz> @seen dons
11:54:37 <lambdabot> Cannot parse command
11:54:37 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 8 hours, 55 minutes and 3 seconds ago.
11:56:15 <vincenz> hm
11:56:19 <vincenz> question to the comcpiler experts
11:56:26 <vincenz> (i'll be gone to get dinner so you have time to answer)
11:57:23 <mikael> it makes surprisingly smart functions
11:57:32 <mikael> @djinn Bool -> ((a, b) -> Either a b)
11:57:33 <lambdabot> Cannot parse command
11:57:33 <lambdabot> f :: Bool -> (a, b) -> Either a b
11:57:33 <lambdabot> f a =
11:57:33 <lambdabot>   case a of
11:57:33 <lambdabot>   False -> \ (b, _) -> Left b
11:57:35 <lambdabot>   True -> \ (_, c) -> Right c
11:58:00 <xerox> You think so?
11:58:08 <vincenz> once you've fully typed an AST and you're certain it is correct.  When then flattening this AST to another AST' that is smaller in data constructors, is it ok to flatten into a format that could allow things that are not welltyped but that can't come because it's impossible to flatten to such a structure.  More specifically... in my AST' I will have (ECall :: Value -> [Value] -> Tag)... obviously the Value can not be an integer or som
11:58:20 <mikael> in this case :-)
11:58:26 <xerox> mikael: I think there is nothing special, just biased assumptions :-)
11:59:08 <mikael> @djinn Bool -> Bool -> ((a, b) -> Either a b)
11:59:09 <lambdabot> Cannot parse command
11:59:09 <lambdabot> f :: Bool -> Bool -> (a, b) -> Either a b
11:59:09 <lambdabot> f a b =
11:59:09 <lambdabot>   case a of
11:59:09 <lambdabot>   False -> \ (c, _) -> Left c
11:59:11 <lambdabot>   True -> case b of
11:59:13 <lambdabot>       False -> \ (d, _) -> Left d
11:59:15 <lambdabot>       True -> \ (_, e) -> Right e
11:59:29 <mikael> now you can choose!
12:00:01 <xerox> Choose what?
12:00:42 <mikael> whether true means left or right
12:00:56 <mikael> so it's TWICE as useful
12:01:40 <xerox> Doesn't False always map to Left, and True to Right?
12:02:37 <dmhouse> That's because of the conventional semantics of Either.
12:02:42 <dylan> is djinn is politically biased?
12:02:57 <dylan> s/djinn is/djinn/g
12:02:59 <cjeris> @djinn Bool -> Bool -> ((a, b) -> Either b a)
12:03:00 <lambdabot> Cannot parse command
12:03:00 <lambdabot> f :: Bool -> Bool -> (a, b) -> Either b a
12:03:00 <lambdabot> f a b =
12:03:00 <lambdabot>   case a of
12:03:00 <lambdabot>   False -> \ (_, c) -> Left c
12:03:02 <lambdabot>   True -> case b of
12:03:04 <lambdabot>       False -> \ (_, d) -> Left d
12:03:06 <lambdabot>       True -> \ (e, _) -> Right e
12:03:12 <dmhouse> (That Left is failure and Right is success.)
12:03:37 <xerox> dmhouse: someone should clean the djinn env and re-instantiate it only with proper definitions
12:03:53 <dmhouse> xerox: Go ahead! @djinn-clear or whatever it is.
12:05:11 <xerox> Ah, okay, it is automagically repopulated with the default values.
12:05:18 <xerox> It wasn't last time I tried. Good.
12:06:19 <roconnor> @type not
12:06:21 <lambdabot> Bool -> Bool
12:06:24 <roconnor> oh right
12:07:27 <dmhouse> roconnor: ? What's confusing about not?
12:07:55 <roconnor> I was writing my own bitwise not, and I couldn't think of what it was conflicting with
12:08:03 <dmhouse> ah.
12:10:33 <Numbers> OK, I'm a totaly Haskell Newbie.  I was thinking aobut how I would go about bilding a rogue-like in Haskell.   I was wondering how I can get a file of data, and read it into a data structure so I can get at it's contents later.   I saw about classes and such, and using a FiniteMap to actually store them, but how would I fill it up?  I can think of the imperative way to do it, but...
12:11:08 <roconnor> Numbers: getContents is the simplest way
12:11:31 * zarvok checks to see if #haskell or #nethack is currently open
12:11:32 <roconnor> and if it is in the right format, you can even do a read.
12:11:56 <roconnor> assuming  you have deriving (Read) for your data structure.
12:12:23 <musasabi> of course most people move away from Read after a while
12:12:53 <roconnor> musasabi: yep, but it's probably good for a Newbie
12:13:03 <musasabi> point
12:13:10 <dmhouse> Numbers: by the way, FiniteMaps are deprecated, the new interface is called Map.
12:13:21 <zarvok> readFile might be easier if you're reading from a file and not stdin
12:13:28 <dmhouse> Numbers: what would be the imperative way?
12:15:14 <SamB> Numbers: rejoice, readFile is at hand!
12:15:28 <zarvok> haha
12:15:46 <Numbers> do line <- readLine(f)  line = "END"  _ = addtoFM FM parsekey(line) parseX(line) etc. etc.
12:15:49 <Numbers> Sortof.
12:16:02 <roconnor> @type readFile
12:16:03 <lambdabot> FilePath -> IO String
12:16:17 <dmhouse> Numbers: line = "END"?
12:16:17 <roconnor> even easier :)
12:16:32 <Numbers> dmhouse: I think I needed a where in there...
12:16:42 <Numbers> to catch the 'END'  else add a new entry to the FM.
12:16:53 <dmhouse> Numbers: you'd probably want to read the file into a string, convert that string into a list of lines, then map over that list, adding elements to the Map.
12:17:01 <SamB> skip the END
12:17:05 <SamB> you don't need it
12:17:08 <zarvok> Numbers: Yeah, rather than go line by line, just call readFile and then parse
12:17:35 <emertens> @type openFileEx
12:17:36 <lambdabot> Not in scope: `openFileEx'
12:17:40 <Numbers> What if the file is very big?  (Not that it would be in this case, but...)
12:17:50 <zarvok> readFile is lazy
12:17:55 <Numbers> Ahh.
12:17:56 <Numbers> OK.
12:18:07 <Numbers> I'm stuck in python thinking a lot still.
12:18:12 <dmhouse> No problem :)
12:18:26 <dmhouse> Yeah, readFile is lazy, so it will only read as many lines as you need.
12:18:37 <Numbers> Why wouldn't I need the eld?  WOuldn't I crash out with an IO error eventually?
12:18:48 <Numbers> s/eld/END/
12:18:49 <dmhouse> No, readFile will stop at the end of the file/
12:18:55 <dmhouse> s/\//./
12:19:12 <Numbers> So, it's smart that way
12:19:23 <zarvok> Numbers: and if you're concerned with actual line breaks, the "lines" function can break up the list by newline
12:19:39 <dmhouse> Right.
12:19:45 <Numbers> well, there needs ot be some way to parse record end, so, whichever.
12:20:19 <dmhouse> The general idea is: Read the file in (readFile), split it into a list of lines (lines), then map (map) over that list, adding things to you map.
12:20:37 <mikael> Numbers: if you want to indulge yourself, look at the Parsec library for parsing your structure
12:21:23 <mikael> if it's structured, that is.  if it's just a blob of map tiles, don't bother :-)
12:22:13 <Numbers> so I could like do fileconts <- readfile <CR> let linesfile = lines fileconts in <CR> map linetodatastruct linefile
12:22:18 <Numbers> or somesuch?
12:22:29 <SamB> well.
12:22:35 <SamB> it is called readFile
12:22:45 <jgrimes_> ok, I'm still torn with the environment problem of interpreters. I'm currently using IORefs but I don't really like having everything in the IO monad. I'm thinking about creating my own queue based environment that is threaded through all of the evaluation. Does this sound plausible?
12:23:14 <SamB> threading is generally in the IO monad...
12:23:55 <musasabi> jgrimes_: you might want to define your own monad that wraps either IO or STM + some extra bits.
12:24:28 <Numbers> Also, on a tagnetally related note, is there a curses-like library for windows?
12:24:36 <SamB> indeed
12:24:57 <SamB> try pdcurses if you want that genuine curses API
12:25:19 <jgrimes_> musasabi: I suppose I could, someone said that is how pugs is doing it
12:25:27 <musasabi> jgrimes_: you want to avoid unbounded queues as they tend to cause performance issues.
12:26:10 <musasabi> HAppS used a monad wrapping STM and mostly TVars + few MVars for queue handling.
12:26:12 <SamB> how do you do bounded queues?
12:26:30 <dmhouse> I have decided that callCC simply doesn't make sense.
12:26:38 <SamB> you mean:
12:26:42 <SamB> @hoogle callCC
12:26:43 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
12:26:53 <dmhouse> Yeah.
12:27:00 <SamB> or do you mean @google site:haskell.org callcc done right
12:27:01 <sjanssen> dmhouse: of course, that is a well known fact
12:27:08 <dmhouse> Can anyone give me a simple-as-possible example using it?
12:27:13 <SamB> @google site:haskell.org callcc done right
12:27:16 <jgrimes_> musasabi: I think I'll take a look at STM. People keep saying good things about it.
12:27:16 <lambdabot> http://www.haskell.org/hawiki/ListTDoneRight
12:27:16 <lambdabot> Title: ListTDoneRight - The Haskell Wiki
12:27:19 <SamB> hmm.
12:27:25 <SamB> @google site:haskell.org Continuations done right
12:27:30 <lambdabot> http://www.haskell.org/haskellwiki/Combinatory_logic
12:27:30 <lambdabot> Title: Combinatory logic - HaskellWiki
12:27:33 <SamB> arg
12:27:49 <SamB> @google site:haskell.org "Control.Monad.Cont" done right
12:27:50 <lambdabot> http://www.haskell.org/hawiki/ListTDoneRight
12:27:50 <lambdabot> Title: ListTDoneRight - The Haskell Wiki
12:27:54 <SamB> hmm,
12:29:22 <SamB> http://www.haskell.org/hawiki/ContinuationsDoneRight is the page I *meant*
12:29:23 <lambdabot> Title: ContinuationsDoneRight - The Haskell Wiki
12:29:33 <musasabi> jgrimes_: the trick is to know for which parts MVar and for which MVar. (Chan is usually problematic if you want the last bits of performance)
12:30:37 <SamB> dmhouse: see that page to see a better interface (with a special bonus implementation!)
12:30:55 <dmhouse> I'd rather understand normal continuations first.
12:31:20 <SamB> but, the ones in today's Control.Monad.Cont are not normal
12:31:23 <SamB> they are wierd
12:31:48 <SamB> they are not typed properly
12:38:11 <emertens> does it make sense to test a disjoint-set data structure with Test.QuickCheck?
12:38:41 <sjanssen> emertens: definitely
12:38:50 <lisppaste2> callCC troubles pasted "dmhouse" at http://paste.lisp.org/display/23263
12:39:05 <emertens> I would have to implement Arbitrary for my data type... right?
12:39:13 <dmhouse> Anyone explain why that doesn't print the '20'? Is it a laziness thing?
12:39:23 <emertens> (among other things)
12:39:28 <sjanssen> emertens: depends on what properties you want to check
12:40:19 <emertens> I suppose I don't need to test for arbitrary bounds...
12:40:32 * dmhouse knows he's close to understanding continuations, but this has thrown him off
12:40:48 <emertens> but I would want to verify that given some arbitrary unions performed in an arbitrary order that  the results were the same
12:41:41 <emertens> the problem seems that after any check, that the state of the array I use will change
12:41:44 <emertens> (path compression)
12:41:54 <emertens> so the order that it's tested in could matter if I had a bug
12:45:32 <dmhouse> Oh, I see, the argument to callCC has to return another Cont computation.
12:50:16 <dmhouse> @type callCC
12:50:18 <lambdabot> Not in scope: `callCC'
12:50:26 <dmhouse> @type Control.Monad.Cont.callCC
12:50:27 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => ((a -> m b) -> m a) -> m a
12:50:47 <dmhouse> @instances MonadCont
12:50:48 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
12:50:57 <dmhouse> Gah. I thought I understood callCC, but I don't.
12:51:42 <dmhouse> I figured the function would get passed the (a -> r) bit, but apparently it's not.
13:04:09 <roconnor> @hoogle [(a,b)] -> a -> b
13:04:11 <lambdabot> No matches, try a more general search
13:04:15 <roconnor> @hoogle [(a,b)] -> a -> m b
13:04:16 <lambdabot> No matches, try a more general search
13:04:22 <roconnor> @hoogle [(a,b)] -> a -> Maybe b
13:04:23 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:04:44 <roconnor> is there a lookup that returms an m b for any monad m?
13:06:06 <Lemmih> Not in the standard libraries.
13:06:48 <roconnor> will let (Maybe b)  = lookup ... run fail if the let pattern fails?
13:06:53 <roconnor> if the let is in a monad
13:07:23 <Lemmih> Yes.
13:07:31 <roconnor> > do {let 0 = 1; return 7} :: Maybe Int
13:07:31 <Lemmih> Er, no.
13:07:31 <lambdabot>  Parse error
13:09:09 <Lemmih> > do Just x <- return $ lookup 1 [(1,"one"),(2,"two")]; return x :: [String]
13:09:11 <lambdabot>  ["one"]
13:09:12 <Lemmih> > do Just x <- return $ lookup 3 [(1,"one"),(2,"two")]; return x :: [String]
13:09:13 <lambdabot>  []
13:09:31 <roconnor> > do let 0 = 1; return 7 :: Maybe Int
13:09:31 <lambdabot>  Parse error
13:09:42 <roconnor> why won't it accept let expressions?
13:10:02 <Lemmih> > do let {0 = 1}; return 7 :: Maybe Int
13:10:03 <lambdabot>  Just 7
13:10:20 <roconnor> damn lazy patterns
13:10:50 <roconnor> do let {Left x = Right 1}; return x :: Maybe Int
13:10:54 <roconnor> > do let {Left x = Right 1}; return x :: Maybe Int
13:10:55 <lambdabot>  Irrefutable pattern failed for pattern Data.Either.Left x
13:11:19 <roconnor> I understand
13:11:32 <roconnor> with lazy patterns, it isn't know when the failure will occur
13:12:12 <Lemmih> Sure it is.
13:13:49 <Lemmih> You bind _|_ to 'x' so every computation using it will be _|_.
13:15:01 <vincenz> > let x = _|_ in x
13:15:02 <lambdabot>  Parse error in expression
13:17:20 * Lemmih wonders why GHC doesn't print unicode anymore.
13:20:54 <emertens> > let x = undefined in x
13:20:55 <lambdabot>  Add a type signature
13:20:59 <emertens> > let x = undefined in x :: Int
13:21:01 <lambdabot>  Undefined
13:35:28 <roconnor> @type lookup
13:35:30 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
14:04:03 <zarvok> @hoogle unsafeRead
14:04:03 <lambdabot> No matches found
14:04:09 <zarvok> someone know where this function lives?
14:04:16 * zarvok is reading UMs
14:04:29 <dmhouse> zarvok: probably defined in the UM then.
14:04:34 * dmhouse has never heard of it
14:05:00 <zarvok> don't see it anywhere
14:05:02 <zarvok> hmm
14:05:33 <julian> I cant compile lambdabot :(
14:06:20 <julian> there is a debian package?
14:06:24 <sjanssen> zarvok: Data.Array.Base
14:06:39 <sjanssen> zarvok: does an array lookup without bounds checking
14:06:56 <zarvok> sjanssen: thanks.  actually, I think it's your UM that I'm staring at
14:06:57 <dylan> I, too, seek to get lambdabot working on debian.
14:07:38 <sjanssen> zarvok: good luck!  the code is a bit . . . nasty
14:07:45 <zarvok> heh, so I noticed
14:09:18 <zarvok> sjanssen: where do I read about Data.Array.Base?  I don't see a reference to it in the docs on haskell.org
14:10:59 <zarvok> googling yields some info, is this maybe Hugs libraries stuff or something?
14:11:13 <zarvok> no, looks like GHC has it
14:11:14 <zarvok> hmm..
14:13:30 <roconnor> >lookup 5 ([(0,7),(5,1)]++undefined)
14:14:30 <sjanssen> zarvok: Data.Array.Base is an "under the hood" interface and isn't documented.  You can look at the source or do :browse Data.Array.Base from ghci
14:15:14 <emertens> roconnor: there has to be a space after '>'
14:15:30 <zarvok> sjanssen: Ah, I see.  Thanks!
14:16:03 <roconnor> > lookup 5 ([(0,7),(5,1)]++undefined)
14:16:04 <lambdabot>  Just 1
14:16:12 <roconnor> is RWS strict??
14:17:34 <julian> @:type lookup
14:17:36 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
14:18:30 <sjanssen> roconnor: are you referring to the RWS monad?
14:19:05 <roconnor> yes
14:19:09 <roconnor> seems lazy
14:19:16 <sjanssen> no, it isn't strict
14:19:21 <roconnor> > let (res, (), rec) = runRWS (do m<-ask; tell [5]; return 5) rec () in res
14:19:22 <roconnor> 5
14:19:22 <lambdabot>  Not in scope: `tell'
14:19:32 <julian> @:type (\x -> undefined)
14:19:33 <lambdabot> forall a t. t -> a
14:19:42 <sjanssen> though the Monoid instance for whatever you are writing may be strict
14:20:04 <roconnor> > let (res, (), rec) = runRWS (do m<-ask; tell [5]; return m) rec () in res
14:20:04 <roconnor> [5]
14:20:05 <lambdabot>  Not in scope: `tell'
14:20:11 <roconnor> that's what I ment to test
14:20:15 <roconnor> works great
14:20:59 <julian> what about the funcion (\x -> undefined) from a type theory point of view?
14:22:54 <julian> @:type (\x -> undefined)
14:22:56 <lambdabot> forall a t. t -> a
14:23:27 <julian> it is a proof of A -> B forall A,B ??
14:24:00 <emertens> julian: what are you trying to figure out?
14:25:01 <roconnor> ugh, what is my code doing?
14:25:03 <julian> in haskell, I cant see functions like proof
14:25:16 <roconnor> it just sits there, not even using the CPU.
14:26:50 <sjanssen> roconnor: waiting for input?
14:27:10 <roconnor> nope
14:27:30 <julian> emertens: I'm thinking about how work djinn
14:27:40 <emertens> julian: did you expect (\_ -> undefined) to have a different type?
14:27:52 <julian> emertens: no
14:27:55 <emertens> oh
14:27:56 <emertens> ok
14:28:07 <roconnor> hmm
14:29:04 <julian> emertens: djinn dont use undefined obviously
14:29:15 <roconnor> > let splitEithers = foldr (either (first . (:)) (second . (:))) ([], []) in snd (splitEtihers [Left 5, Right 6])
14:29:16 <lambdabot>  Not in scope: `splitEtihers'
14:29:22 <roconnor> > let splitEithers = foldr (either (first . (:)) (second . (:))) ([], []) in snd (splitEithers [Left 5, Right 6])
14:29:23 <lambdabot>  [6]
14:29:37 <roconnor> > let splitEithers = foldr (either (first . (:)) (second . (:))) ([], []) in head . snd (splitEithers [Left 5, Right 6])
14:29:38 <lambdabot>  Couldn't match `a1 -> [a]' against `[a2]'
14:29:42 <roconnor> > let splitEithers = foldr (either (first . (:)) (second . (:))) ([], []) in head $ snd (splitEithers [Left 5, Right 6])
14:29:43 <lambdabot>  6
14:29:56 <roconnor> > let splitEithers = foldr (either (first . (:)) (second . (:))) ([], []) in head $ snd (splitEithers $ [Left 5, Right 6]++undefined)
14:29:58 <lambdabot>  6
14:30:21 <dmhouse> roconnor: I have lefts = fst . splitEithers; rights = snd . splitEithers defined in addition do that.
14:36:16 <retybok> where can i read about the icfp results? Can't find it on google
14:36:52 <dmhouse> retybok: they're not out yet.
14:36:54 <roconnor> aha!
14:37:07 <retybok> i know
14:37:15 <dmhouse> retybok: you can see the scoreboard as it stood 8 hours before the end of the contest at icfpcontest.org
14:37:15 <retybok> but maybe some unofficial results?
14:37:20 <roconnor> how do I make lazy patterns again?
14:37:23 <dmhouse> roconnor: ~
14:37:39 <dmhouse> > let f ~(x, y) = 4 in f undefined
14:37:40 <lambdabot>  4
14:37:43 <retybok> i'd like to see how different languages performed
14:37:50 <roconnor> how do I make lazy patterns again?
14:37:52 <roconnor> oop
14:37:55 <roconnor> sorry
14:37:58 <retybok> the scoreboard doesn't list the languages
14:37:59 <dmhouse> retybok: I think it was mostly C dominated, sadly.
14:38:08 <retybok> hehe
14:38:12 <dmhouse> retybok: it needed a fast UM implementation.
14:38:19 <dmhouse> Like, really fast.
14:38:44 <retybok> C is still needed for some applications, sure
14:38:58 <dmhouse> It'll pass.
14:39:04 <dmhouse> Functional programming is the future.
14:39:13 <retybok> :)
14:39:27 <dmhouse> (I honestly believe that.)
14:39:50 <retybok> i believe you believe it
14:40:04 <retybok> i don't know enough to have an opinion
14:40:41 <dmhouse> Nor do I, really, but I have one regardless.
14:40:58 <dmhouse> Everyone's entitled to my opinion! :)
14:41:31 <roconnor> there is something about let's being having lazy patterns...?
14:41:50 <dmhouse> roconnor: ?
14:41:57 <roconnor> er
14:42:03 <roconnor> can't type
14:42:11 <emertens> there were a lot of words on that line
14:42:14 <roconnor> isn't there something like, all paterns in lets are lazy?
14:42:45 <dmhouse> I don't think so.
14:42:52 <dmhouse> > let f x = 4 in f undefined
14:42:53 <lambdabot>  4
14:43:01 <dmhouse> There are different types of patterns.
14:43:07 <roconnor> @paste
14:43:08 <lambdabot> http://paste.lisp.org/new/haskell
14:43:12 <dmhouse> I think ones that actually involve a constructor are always strict.
14:44:26 <lisppaste2> roconnor pasted "what's the diff?" at http://paste.lisp.org/display/23271
14:45:06 <roconnor> a case statement also hangs my code
14:45:32 <dmhouse> Weird.
14:45:44 <roconnor> It has something to do with laziness
14:45:49 <roconnor> and pattern matching
14:46:11 <roconnor> I'm using the credit card transform
14:46:12 <sjanssen> what monad is this?
14:46:18 <roconnor> RWS
14:46:37 <dmhouse> > let labels = [f = do l <- ask; let Just i = lookup l labels
14:46:37 <lambdabot>  Parse error
14:46:39 <dmhouse> Oops
14:47:02 <dmhouse> > let labels = zip [1..] "abc" f = do l <- ask; let Just i = lookup l labels; return i in runReader f 1
14:47:02 <lambdabot>  Parse error
14:47:18 <dmhouse> > let labels = zip [1..] "abc" f = do { l <- ask; let Just i = lookup l labels; return i } in runReader f 1
14:47:19 <lambdabot>  Parse error
14:47:27 <dmhouse> > let labels = zip [1..] "abc"; f = do { l <- ask; let Just i = lookup l labels; return i } in runReader f 1
14:47:28 <lambdabot>  Parse error
14:47:43 <sjanssen> dmhouse: parens around Just i
14:47:55 <bolrod> @type runReader
14:47:57 <lambdabot> forall a r. Reader r a -> r -> a
14:47:57 <dmhouse> > let labels = zip [1..] "abc"; f = do { l <- ask; let (Just i) = lookup l labels; return i } in runReader f 1
14:47:58 <lambdabot>  Parse error
14:48:07 <dmhouse> sjanssen: I don't think they're necessary.
14:48:22 <sjanssen> > let Just i = Just 1 in i
14:48:23 <lambdabot>  1
14:48:26 <dmhouse> > let labels = zip [1..] "abc"; f = do { l <- ask; let (Just i) = lookup l labels; return i; } in runReader f 1
14:48:27 <lambdabot>  Parse error
14:48:42 <sjanssen> learn something new every day, I guess
14:48:42 <bolrod> > let {labels = zip [1..] "abc"; f = do { l <- ask; let (Just i) = lookup l labels; return i; }} in runReader f 1
14:48:42 <lambdabot>  Parse error
14:48:44 <roconnor> Let Expressions: Pattern bindings are matched lazily; an implicit ~ makes these patterns irrefutable. For example,
14:48:46 <bolrod> ^.0
14:48:51 <dmhouse> sjanssen: I think the only place they're necessary is with a lambda.
14:49:17 <bolrod> > let {labels = zip [1..] "abc"; f = do { l <- ask; let {(Just i) = lookup l labels; return i; }}} in runReader f 1
14:49:17 <lambdabot>  Parse error
14:49:40 <dmhouse> > let labels = zip [1..] "abc"; f = do { l <- ask; let { Just i = lookup l labels }; return i } in runReader f 1
14:49:41 <lambdabot>  'a'
14:49:45 <dmhouse> Aha.
14:49:51 <bolrod> and what does this do?
14:49:55 <julian> I cant compile lambdabot :( someone can help me?
14:50:04 <dmhouse> roconnor: Why was it hanging?
14:50:19 <dmhouse> julian: what error do you get?
14:50:22 <roconnor> oh
14:50:36 <roconnor>   labels <- ask
14:50:36 <roconnor>   ~(Just i) <- return $ lookup l labels
14:50:36 <roconnor>   return i
14:50:36 <julian> I do darcs ....
14:50:39 <roconnor> this works!
14:50:43 <julian> vi Config.hs
14:50:46 <julian> autoconf
14:50:57 <julian> but I dont see any Makefile
14:51:39 <dmhouse> What about ./configure?
14:51:54 <julian> yes, I do ./configure
14:52:01 <sjanssen> julian: I think lambdabot uses Cabal to build
14:52:14 <julian> mmmm, ok
14:52:19 <dmhouse> julian: what does the README say to do? Does it say 'make'?
14:52:24 <julian> yes
14:52:33 <dmhouse> Or perhaps 'runhaskell Setup.hs build' or similar?
14:52:35 <sjanssen> so: runghc Setup.hs configure; runghc Setup.hs build; runghc Setup.hs install
14:52:59 <julian> Build Lambdabot:
14:52:59 <julian>         $ cd ..
14:52:59 <julian>         $ darcs get --partial http://www.cse.unsw.edu.au/~dons/code/lambdabot
14:52:59 <julian>         $ cd lambdabot/
14:52:59 <julian>         $ autoconf
14:53:00 <julian>         $ ./configure
14:53:00 <lambdabot> Title: Index of /~dons/code/lambdabot
14:53:02 <julian>         -- edit Config.hs to your requirements
14:53:04 <julian>         $ make          # you could try -j2
14:53:06 <julian>         $ ./lambdabot
14:53:12 <dmhouse> julian: I think that's an old version.
14:53:20 <dmhouse> Or perhaps mine's old.
14:53:25 <dmhouse> julian: did you get it from darcs?
14:53:26 <musasabi> @version
14:53:27 <lambdabot> lambdabot 4p28, GHC 6.5 (OpenBSD i386 )
14:53:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:53:32 <julian> yes
14:53:45 <sjanssen> the README is out of date
14:54:10 <sjanssen> julian: run the commands I typed
14:54:11 <dmhouse> Mine says:
14:54:12 <julian> ("build with cabal..." :) )
14:54:13 <dmhouse>     $ vi Config.hs
14:54:13 <dmhouse>     $ chmod +x configure Setup.hs build
14:54:13 <dmhouse>     $ ./Setup.hs configure --bindir=`pwd`
14:54:13 <dmhouse>     $ ./build
14:54:16 <dmhouse>     $ ./lambdabot
14:54:31 <dmhouse> Fresh darcs pull.
14:54:49 <julian> cannot satisfy dependency plugins>=1.0
14:54:56 <dmhouse> You need hs-plugins.
14:55:04 <dmhouse> @where hs-plugins
14:55:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:55:21 <roconnor> sweet! it works!
14:55:23 <julian> dmhouse: ok
14:55:48 <musasabi> dons: @libsrc appears to be broken
14:55:59 <int-e> @run is probably broken.
14:55:59 <lambdabot>  Parse error
14:56:10 <int-e> @botsnack (sorry)
14:56:11 <lambdabot> :)
14:56:16 <dmhouse> @run 2 + 2
14:56:17 <lambdabot>  4
14:56:19 <dmhouse> int-e: ?
14:56:30 <dmhouse> musasabi: that's been broken forever. @fptools works, thouh.
14:56:33 <int-e> na, I mean when following the steps in README :)
14:57:19 <lisppaste2> roconnor pasted "Example of domain specific langauge" at http://paste.lisp.org/display/23272
14:57:20 <dmhouse> int-e: Oh, I think you have to do extra stuff to get @run working.
14:57:46 <int-e> dmhouse: run Setup.lhs install -- I should update the README and send dons a patch.
15:00:33 <int-e> or maybe ask dons to undo my last patch. I'm not completely happy with it.
15:01:43 <dmhouse> So then.
15:01:45 <roconnor> I should write this up for the Monad Reader
15:01:53 <dmhouse> Who wants to explain callCC to me?
15:02:05 <int-e> but  ./build   -->   ./Setup.hs install --user  should do the trick.
15:03:08 <dmhouse> I think once I grok callCC I'll get continuations properly.
15:03:29 <dmhouse> I _thought_ I had it, but it turns out not quite.
15:03:57 <dmhouse> Has anyone got any simple as possible examples?
15:08:11 <int-e> oh. my mistake. the patch isn't in the official lambdabot tree (phew) (I think it was for a short while)
15:09:15 <int-e> dcoutts: ping
15:12:13 <julian> damn
15:12:33 <julian> Building lambdabot-4.0...
15:12:33 <julian> Chasing modules from: scripts/BotPP.hs
15:12:33 <julian> Compiling Main             ( scripts/BotPP.hs, dist/build/BotPP/BotPP-tmp/Main.o )
15:12:33 <julian> Linking ...
15:12:33 <julian> /home/julian/lib/fps-0.7/ghc-6.4.2/libHSfps-0.7.a(ByteString.o): En la funcin `shyK_1_alt':
15:12:34 <julian> ghc28403.hc:(.text+0xff99): referencia a `GHCziHandle_lvl94_closure' sin definir
15:12:36 <julian> /home/julian/lib/fps-0.7/ghc-6.4.2/libHSfps-0.7.a(ByteString.o): En la funcin `shAW_slow':
15:12:38 <julian> ghc28403.hc:(.text+0x10557): referencia a `GHCziHandle_lvl134_closure' sin definir
15:12:40 <julian> /home/julian/lib/fps-0.7/ghc-6.4.2/libHSfps-0.7.a(ByteString.o): En la funcin `sjEn_1_alt':
15:12:42 <julian> ghc28403.hc:(.text+0x10690): referencia a `GHCziHandle_lvl135_closure' sin definir
15:12:44 <julian> /home/julian/lib/fps-0.7/ghc-6.4.2/libHSfps-0.7.a(ByteString.o):(.rodata+0x23c): referencia a `GHCziHandle_lvl134_closure' sin definir
15:12:47 <julian> collect2: ld devolvi el estado de salida 1
15:12:49 <julian> sorry :|
15:12:55 <int-e> julian: please use a paste bot
15:12:56 <int-e> @paste
15:12:57 <lambdabot> http://paste.lisp.org/new/haskell
15:13:19 <julian> int-e: sorry
15:16:09 <int-e> hmm. is the ghc version correct? (are you using 6.4.2?)
15:18:57 <int-e> I get errors like this when I recompile the base package and forget to recompile bytestring (aka fps) before installing it again ...
15:20:55 <ricky_clarkson> shapr: Did you glance at the API for that Java layout, btw?
15:22:08 <edwardk> whats the best way to make sure that a llist has been eagerly evaluated?
15:22:48 <dmhouse> edwardk: compute its length?
15:22:52 <edwardk> ahh that works
15:22:54 <dmhouse> Anything that traverses the list.
15:23:38 <edwardk> ok, so seq a length check on it or something and done?
15:23:47 <dmhouse> Yeah, should work.
15:23:49 <zarvok> edwardk: is it some kind of datatype you could add strictness flags to?
15:24:00 <dmhouse> When Haskell' rolls around, we'll have deepSeq, but for now, that should suffice.
15:24:17 <int-e> julian: so maybe recompiling bytestring will help
15:25:51 <roconnor> @type callCC
15:25:53 <lambdabot> Not in scope: `callCC'
15:25:59 <roconnor> @type Control.Monad.callCC
15:26:00 <lambdabot> Not in scope: `Control.Monad.callCC'
15:26:01 <edwardk> well, i have an IOUArray, i need to read an unknown number of elements from it in order until i get one that matches a predicate and do something with each of them in turn. the explicit IO plumbing makes the intermediate algorithm unreadable through all the lifts, so i was kinda leaning towards unsafeFreezing it, doing my dirty work, making sure the result has been generated, then unsafeThawing it
15:26:05 <roconnor> @type Control.Monad.Cont.callCC
15:26:07 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => ((a -> m b) -> m a) -> m a
15:27:18 <roconnor> edwardk: getElems?
15:27:24 <edwardk> the surrounding code is already riddled with unsafeReads etc, so it can't be too much worse =)
15:27:35 <edwardk> roconnor: i don't want to pay for the front of the list.
15:27:48 <edwardk> and i am jumping in possibly several million values in
15:27:49 <roconnor> what do you mean?
15:27:54 <roconnor> oh
15:28:18 <edwardk> so i need to start evaluating from, say, [finger..] where i don't know the end point =)
15:28:51 <edwardk> if i just sequence the reads, then i'll wind up reading the whole array because of the monad ordering
15:29:09 <edwardk> and there doesnt appear to be a monadic 'takeWhile'
15:29:27 <edwardk> and, even then i also need the first element that fails my predicate
15:29:35 <roconnor> write your own
15:29:48 <edwardk> i was kinda trying to minimize the plumbing in this part
15:29:54 <edwardk> hence the unsafeFreeze =)
15:30:22 <roconnor> takeWhileM p x = do a <- x; if (p a) then takeWhileM p x else return a
15:31:04 <edwardk> ok, add the first one that fails the predicate to that, and i'll happily employ it
15:31:48 <vincenz> blegh
15:31:50 * vincenz hates ASTs
15:32:16 <roconnor> edwardk: what do you mean?
15:32:31 <edwardk> i have a bunch of UM tokens, i need to scan them until i find a halt or a loadprog.
15:32:40 <edwardk> and i want to include the halt or the loadprog in the list of tokens
15:33:09 <roconnor> it returns the a that fails.
15:33:10 <edwardk> (its for a toy jit)
15:33:25 <edwardk> i need the one that returns all of the ones up to and including the one that fails as a list
15:33:25 <roconnor> edwardk: and what about all the self-modifying code?
15:33:35 <edwardk> thats worked around in other ways
15:33:35 <roconnor> oh
15:34:10 <roconnor> takeWhileM p x = do a <- x; if (p a) then do (l <- takeWhileM p x; return a:l) else return [a]
15:34:18 <roconnor> takeWhileM p x = do a <- x; if (p a) then do (l <- takeWhileM p x; return (a:l)) else return [a]
15:34:58 <edwardk> i have two ways to do it, one ignores smc, since i couldn't demonstrate the presence of any self modifying code when i profiled to check for it. the other is to have self-modifying code break out of the jit runtime monad that is executing and fall back on interpreted evaluation if it turns out to be an issue
15:35:48 <edwardk> roconnor: thats clean. i like it =)
15:36:54 <vincenz> @hoogle ap
15:36:54 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
15:36:55 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
15:36:55 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
15:41:29 <dmhouse> I get it!
15:41:41 <dmhouse> Wow. I honestly didn't think I'd ever understand callCC.
15:42:06 <edwardk> heh
15:42:17 <edwardk> now play with delimited continuations =)
15:42:37 <dmhouse> ;)
15:50:58 <dmhouse> I still love http://haskell.org/haskellwiki/Compose. It brilliantly exemplifies the pointless things #haskell algorithm golf can come up with.
15:50:59 <lambdabot> Title: Compose - HaskellWiki
16:03:05 <bringert> good afternoon #haskell
16:03:06 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
16:03:12 <xerox> bringert!
16:03:16 <xerox> Howdy :-)
16:03:25 <bringert> hi xerox
16:03:41 * bringert has been offline vacationing etc
16:03:43 <vincenz> bringert: I did compos2
16:03:47 <xerox> bringert: sorry to bug you about...bugs, as soon as you come here :)
16:03:49 <bringert> vincenz: sweet
16:03:54 <dylan> @tell dylan test
16:03:54 <lambdabot> You can tell yourself!
16:03:57 <xerox> haskelldb-flat doesn't compile, argh!
16:04:01 * vincenz mutters about something
16:04:01 <dylan> XD
16:04:07 <bringert> xerox: that's a good reason to come here
16:04:19 <vincenz> ANF is too much oriented towards C and SSA :(  I don't know how to fit data constructors in it ;(
16:04:20 <bringert> xerox: oops
16:04:25 <xerox> I tried something, but then I gave up
16:04:29 <bringert> xerox: what happens?
16:04:53 <bringert> I only tested with ghc 6.5, maybe it broke on 6.4.x
16:05:07 <xerox> I am on 6.5 too (OS X)
16:05:21 <bringert> xerox: ah, are you useing the haskelldb-flat repo?
16:05:22 <xerox> @paste
16:05:23 <lambdabot> http://paste.lisp.org/new/haskell
16:05:32 <bringert> the code has move into the HaskellDB repo
16:05:39 <lisppaste2> xerox pasted "haskelldb-flat" at http://paste.lisp.org/display/23274
16:05:49 <xerox> Ah!
16:06:08 <bringert> xerox: go to driver-flat in the haskelldb repo
16:06:16 <bringert> and install from there
16:06:25 <bringert> I should get rid of the haskelldb-flat repo
16:06:31 <xerox> Gotcha.
16:06:49 <xerox> Some warnings, but seems to compile.
16:06:55 <xerox> Good, thanks.
16:07:19 <xerox> I have another bug report :)
16:07:48 <xerox> haskell-rss can't successfully `runhaskell Setup.hs register', and neither seem to driver-flat now.
16:07:58 <xerox> They both do:
16:07:59 <xerox> Reading package info from ".installed-pkg-config" ... done.
16:07:59 <xerox> ghc-pkg: invalid package identifier:
16:08:23 <SamB> hmm, did the sand melt in my sandmark?
16:10:11 <bringert> xerox: that's not my fault
16:10:17 <SamB> also, why are the C++ UM's slower than the C UMs? is it because they are 64-bit clean?
16:10:33 <bringert> xerox: that seems to be a runghc bug under OS X/i386
16:10:49 <xerox> Right.
16:10:51 <bringert> xerox: try compiling Setup.hs instead of using runghc
16:11:00 <xerox> If one compiles Set<Interrupted by bringert>
16:11:33 <bringert> ?
16:11:59 <xerox> I was going to say it
16:12:04 <bringert> ah
16:12:05 <xerox> Nevermind :-)
16:13:03 <bringert> xerox: maybe we should report that as a GHC bug
16:13:12 * xerox nods
16:13:36 <bringert> I have had the same problem with some cabal packages
16:14:34 <lispy> what version of ghc?
16:14:50 <lispy> i definitely had problems with runhaskell in older versions of ghc even in linux
16:14:51 <xerox> [ 43 of 112] Compiling Hope.Util.CGI    ( Hope/Util/CGI.hs, Hope/Util/CGI.o )
16:14:51 <xerox> Hope/Util/CGI.hs:81:32: Not in scope: `setStatus'
16:14:51 <xerox> Hope/Util/CGI.hs:82:32: Not in scope: `outputNothing'
16:14:52 <xerox> make: *** [createdb] Error 1
16:14:54 <xerox> woops.
16:15:48 <bringert> xerox: update newcgi
16:16:26 <bringert> hope.cabal should list the current version dependencies (but don't try to use it for building hope yet)
16:16:56 <xerox> OK!
16:17:03 * xerox is eager of getting the new hope running
16:18:57 <vincenz> Anyone familiar with ANF?
16:20:42 <bringert> vincenz: how did the two-variable compos stuff work out? is there some code I can look at?
16:20:52 <bringert> vincenz: did you encounter any problems?
16:24:32 <vincenz> hmm
16:24:37 <vincenz> well I did have to add an extra function
16:24:39 <vincenz> to compos
16:24:54 <vincenz> tho that might be bad design on my part
16:25:18 <vincenz> I could email you it
16:27:09 <vincenz> blegh
16:27:14 <vincenz> I'm rewriting my AST to ANF
16:27:22 <vincenz> but sadly ANF does not have a conccept of patterns or data constructors
16:27:24 * vincenz mutters
16:27:52 <xerox> ?wtf ANF
16:27:53 <lambdabot> No match for "ANF".
16:27:59 <xerox> :-/
16:28:21 <vincenz> @wtf Administrative Normal Form
16:28:25 <lambdabot> *** "administrative" wn "WordNet (r) 2.0"
16:28:25 <lambdabot> administrative
16:28:25 <lambdabot>    adj : of or relating to or responsible for administration
16:28:25 <lambdabot>  
16:28:25 <lambdabot> *** "normal" wn "WordNet (r) 2.0"
16:28:27 <lambdabot> [85 @more lines]
16:28:33 * vincenz smacks lambdabot upside the head
16:29:03 <SamB_XP_> @wtf "Administrative Normal Form"
16:29:05 <lambdabot> No match for ""Administrative Normal Form"".
16:31:29 <SamB_XP_> @wikipedia "Administrative Normal Form"
16:31:30 <lambdabot> No Result Found.
16:31:36 <SamB_XP_> @google "Administrative Normal Form"
16:31:41 <lambdabot> http://www.scannedinavian.com/hope/entry/49
16:32:15 <bringert> vincenz: it'd be fun to see the code, feel free to e-mail me whenever
16:32:18 <vincenz> eivuokko: ping
16:32:21 <vincenz> bringert: email?
16:32:33 <bringert> vincenz: bjorn@bringert.net
16:32:39 * vincenz nods
16:34:39 <dcoutts> int-e, pong
16:35:13 <dcoutts> @localtime dons
16:35:16 <lambdabot> Local time for dons is Fri Jul 28 09:28:55 2006
16:36:35 <vincenz> bringert: btw, feedbcak on the ANF would be great
16:36:39 <int-e> dcoutts: I had a cabal question (about a patch I sent to cabal-devel) but I think I need to ask Isaac Jones instead.
16:36:41 <vincenz> not yet sure if I like it completely
16:37:14 <dcoutts> int-e, I don't see the patch, when did you send?
16:37:56 <int-e> dcoutts: almost two weeks ago.
16:38:09 <vincenz> bringert: tho I get the impression that STG in ghc is like ANF but with data constructors (through the use of case statemets)
16:38:13 <int-e> dcoutts: http://www.haskell.org//pipermail/cabal-devel/2006-July/000035.html
16:38:14 <lambdabot> Title: darcs patch: Add liftField and maybeField to ParseUti... (and 1 more)
16:38:22 <dcoutts> int-e, ah ok
16:38:37 <int-e> just want some feedback :)
16:38:44 <dcoutts> ah for installing hidden packages
16:39:31 <dcoutts> I'll add it to my "to review list"
16:39:45 <dcoutts> but feel free to ping the list again asking for some review
16:39:59 <dcoutts> we probably jsut forgot :-)
16:40:18 <int-e> Ok.
16:40:36 <vincenz> bringert: woops. sent now
16:40:44 <vincenz> bringert: was using wrong email addy (can't acecss work mail server from here)
16:40:55 <vincenz> bringert: if you read it now I can answer Qs :0
16:49:16 <bringert> vincenz: it looks like if you would make the tag the first type argument to ANF, you could use the normal compos functions without modification
16:49:27 <bringert> but maybe I misunderstood what you want to do
16:49:31 <vincenz> maybe
16:49:35 <vincenz> but then ANFTag canc't be handled in the instance
16:49:40 <vincenz> can't even
16:50:14 <bringert> ?
16:50:23 <vincenz> well I wouldn't be able to switch type
16:50:25 <vincenz> of the tag
16:50:28 <vincenz> with compos
16:50:42 <bringert> ah
16:51:26 <xerox> @karma+ bringert -- latest hope rocks.
16:51:26 <lambdabot> bringert's karma raised to 6.
16:51:52 <vincenz> bringert: no?
16:52:05 * bringert is thinking
16:52:28 <bringert> yeah that would be tricky
16:54:30 <vincenz> btw
16:54:31 <vincenz> on another note
16:54:39 <vincenz> ANF comes from the imperative -> functional world
16:54:45 <vincenz> but since I'm coming from the functional world
16:54:51 <vincenz> I need data constructors
16:54:53 <vincenz> say Thoughts?
16:55:26 <bringert> since the tag is basically a phantom type for all constructors except ANFTag, it should be possible to do something nice
16:55:34 <bringert> I'll think about it a bit more
16:55:56 <vincenz> cool
16:59:30 <palomer> ANF?
17:00:05 <vincenz> administrative normal form
17:00:11 <vincenz> But it seems GHC STG is close to it
17:00:14 <vincenz> so I might go to STG
17:00:19 <vincenz> except that STG doesn't sell as well in my comcmunity
17:00:25 <vincenz> though... I only have tuple data constructors
17:00:34 <vincenz> maybe I can hack something into ANF instead of going for full case-statements
17:02:34 <vincenz> bringert: it's sad I can't have different types of tags
17:02:48 <vincenz> bringert: cause as you said, for all other constructors it's just a phantom type
17:10:06 <bringert> vincenz: untag :: ANF tag a -> ANF () a
17:10:06 <bringert> untag x = case x of
17:10:06 <bringert>             ANFTag _ a -> untag a
17:10:06 <bringert>             _          -> unsafeCoerce (composOp untag x)
17:10:22 <bringert> a bit of a nasty hack, but it should be safe
17:11:22 <vincenz> ?
17:11:35 <vincenz> what for?
17:11:43 <vincenz> oh
17:11:45 <vincenz> composOp
17:12:13 <vincenz> yeah
17:12:19 <vincenz> but that'll only be useful for that generic case
17:12:24 <vincenz> I want to do a lot of tagging stuff
17:12:26 <vincenz> and ideally
17:12:29 <vincenz> untag should return
17:12:33 <vincenz> ANF tag2 a
17:12:36 <vincenz> aka polymorphic
17:12:37 <bringert> right
17:12:52 <katana> did anyone write a umachine emulator for this years icfp contest ?
17:13:06 <vincenz> katana: yep
17:13:21 <Numbers> Not in Haskell, but yes.
17:13:38 <katana> did you benchmark it ?
17:13:43 <katana> e.g how many Mips
17:13:53 * vincenz mutters as he doesn't know how to enter data constructors into this fricking ANF
17:13:56 <SamB_XP_> katana: mips?
17:13:59 <SamB_XP_> you silly
17:14:08 <katana> ?
17:14:16 <vincenz> katana: there's some benchmarks on dons' page
17:14:21 <SamB_XP_> you just get dons to sandmark it for you and put it on his page...
17:14:34 <Numbers> Mine is fast, but doesn't run the Sandmark benchmark. :(  (I took out the array copy stuff.  Makes it faster, and it's never used after the first codex)
17:14:35 <katana> url ?
17:14:39 <vincenz> http://www.cse.unsw.edu.au/~dons/um.html
17:14:40 <lambdabot> Title: Haskell UM
17:14:51 <katana> Numbers if it doesnt run the sandmark benchmark its not complete
17:14:56 <katana> thanks
17:15:00 <Numbers> WOrks fiiiiine
17:15:11 <SamB> how does that make it faster
17:15:14 <vincenz> mine's pretty fast and does the sandmark
17:15:16 <sjanssen> somebody needs to write one that is faster than mine
17:15:23 <vincenz> katana: the LazyBottom  one is mne
17:15:24 <SamB> if it isn't used, it won't really take much CPU, will it?
17:15:24 <vincenz> mine
17:15:29 <vincenz> tho the link ccould be out of date
17:15:30 <vincenz> @seen dons
17:15:31 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 14 hours, 15 minutes and 57 seconds ago.
17:15:41 <bringert> vincenz: how about something like this then?
17:15:43 <bringert> tag :: (ANF t1 a -> t2) -> ANF t1 a -> ANF t2 a
17:15:43 <bringert> tag f c = ANFTag (f c) c'
17:15:43 <bringert>     where c' = composOp tag (unsafeCoerce c)
17:15:51 <SamB> I mean how much CPU does it take to check whether something is zero or not?
17:15:59 <Numbers> SamB: It's smaller, it doesn't keep track of size (which is why it doesn't work)
17:16:05 <vincenz> bringert: but composOp is just a bad choice in general in the case I -do- want useful tagging
17:16:07 <SamB> oh
17:16:16 <SamB> that saves you one word on each region...
17:16:20 <vincenz> bringert: or combien tagging info andsuch
17:16:23 <vincenz> bringert: for instance
17:16:29 <vincenz> test :: Int -> ANF a b -> ANF a Int
17:16:29 <vincenz> test i t = case t of ANFTag _ e  -> ANFTag i $ compos2Op (test (i+1)) (const (i+1)) e _           -> compos2Op (test (i+1)) (const (i+1)) t
17:16:30 <SamB> that doesn't help you much.
17:16:34 <Numbers> Plus I reimplimented the memory manager after gettign the first codex, so I never got around to writeing that bit.
17:16:44 <vincenz> test :: Int -> ANF a b -> ANF a Int
17:16:48 <SamB> memory manager?
17:16:48 <vincenz> test i t = case t of
17:16:52 <vincenz>   ANFTag _ e  -> ANFTag i $ compos2Op (test (i+1)) (const (i+1)) e
17:16:55 <SamB> why would you need a memory manager?
17:16:56 <vincenz>   _           -> compos2Op (test (i+1)) (const (i+1)) t
17:17:41 <vincenz> bringert: come to #oasis? More silent htere
17:17:58 <Numbers> SamB: Well, I _had_ a memory manager that I took out in favor of returning the poointer to the memory.
17:18:04 <SamB> oh
17:18:14 <SamB> well, look at edwardk's UM
17:18:22 <palomer> administrative  normal form is a grammar specification format?
17:18:27 <SamB> his is faster and prettier than mine
17:18:33 <SamB> I have no idea why
17:18:45 <Numbers> Well, there's the one that puts the size in the pointer-1.  That's what I would do if I was unlazy.
17:18:47 <SamB> (why it is faster, I mean)
17:19:05 <SamB> I put the size in pointer-1
17:19:09 <SamB> he puts it in a struct
17:19:29 <SamB> which looks nicer in the source and apparantly does not worsen performance
17:19:45 <Numbers> Odd.
17:20:42 <SamB> either that or dons compiled our programs with different options
17:21:13 <SamB> did anyone mention the URL yet?
17:21:20 <Numbers> http://www.cse.unsw.edu.au/~dons/um.html
17:21:21 <lambdabot> Title: Haskell UM
17:21:22 <Numbers> THat one?
17:21:28 <SamB> ah yes ;-)
17:22:26 <SamB> my Haskell version is apparantly so slow dons decided to kill it before it finished the sandmark (or it ran out of memory...)
17:22:33 <katana> heh
17:23:01 <Numbers> heh
17:23:11 <SamB> it did however not experience the nasty wierd bugs the C one had to go through, for some reason
17:23:13 <Numbers> I should send in my shitty python one
17:23:22 <SamB> heh
17:23:23 <Philippa> SamB: that's why I didn't submit mine. Though I'm happy it's correct now
17:23:33 <katana> Numbers how long does it take to run sandmark
17:23:53 <Numbers> Hmm. never tried.
17:23:58 <Numbers> Should work tho...
17:24:04 <SamB> what is Duncomloolump anyway?
17:24:12 <Numbers> It took like 9 hours to dump the codex.
17:24:18 <katana> shiet
17:24:32 <SamB> did it involve dcoutts, Igloo, and hefallump?
17:24:41 <katana> my lisp one takes 18 mins to dump the codex
17:24:42 <dcoutts> SamB, yes
17:24:49 <Numbers> Python is just slow. :/
17:24:55 <SamB> who was the "com" from?
17:25:05 <Philippa> hrmm. I'm not feeling so bad about the performance of mine now. 18 minutes to dump sounds about right, though I never timed
17:25:06 <Numbers> All the bitwise stuff is emulated.   THat hurts a lot.
17:25:21 <Philippa> ouch, it would do
17:25:24 <SamB> emulated?
17:25:28 <katana> Philippa i could get it to ~10
17:25:37 <SamB> you have no bitwise ops in Python?
17:25:38 <katana> but i'm too bored to define types
17:26:15 <Numbers> SamB: Sort of.   But if you do x >> 1 it goes x ** 2
17:26:23 <Numbers> er... well
17:26:26 <Numbers> You know what I mean.
17:26:34 <SamB> hmm, nope!
17:26:45 <Philippa> katana: mine was in Haskell, and I'm not the haskell optimisation guru around here by a long way...
17:27:00 <Philippa> I mean, I used IOUArrays but it's still bounds-checking every read and write for example...
17:27:00 <Numbers> In C, a bitwise shift is faster.  In python, it's slooower.
17:27:33 <int-e> Philippa: use unsafeRead & Write
17:27:50 <Philippa> int-e: so I gather. Those're on C arrays, right?
17:28:11 <int-e> zero-based arrays, yes.
17:28:16 <SamB> Philippa: IOUArrays...
17:28:36 <SamB> or, in this case they would be that
17:28:58 <SamB> @type unsafeRead
17:29:00 <lambdabot> Not in scope: `unsafeRead'
17:29:05 <SamB> @hoogle unsaferead
17:29:06 <lambdabot> No matches found
17:29:10 <SamB> @hoogle unsafeRead
17:29:10 <lambdabot> No matches found
17:29:13 <SamB> ack
17:29:15 * Philippa nods
17:29:19 <int-e> @type Data.Array.Base.unsafeRead
17:29:21 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => a i e -> Int -> m e
17:29:31 <Philippa> that's one of the things that catches me - I think I'd used arrays in haskell once before, admittedly, but not tried to be fast
17:29:50 <Philippa> *ah*. Guess I know where it is for next time
17:30:14 <SamB> somehow I doubt that is at all related to my speed problem ;-)
17:30:33 <SamB> I am guessing my allocation code is the problem
17:30:42 <SamB> since it is extremely inefficient
17:30:43 <Philippa> heh. Data.Array.Base isn't in the hierarchical libs docs as of GHC 6.4?
17:31:06 <SamB> @doc Data.Array.Base
17:31:06 <lambdabot> Data.Array.Base not available
17:31:54 <Numbers> OK
17:32:00 <Numbers> Sandmark started 1 min ago.
17:32:29 <int-e> oh. that's GHC-specific?
17:33:54 <vincenz> hmm
17:34:05 <vincenz> JohnMeacham: ping
17:34:18 <vincenz> @msg JohnMeacham Where would I find literature on GRIN?  IT's a hard to google term
17:34:21 <vincenz> @tell JohnMeacham Where would I find literature on GRIN?  IT's a hard to google term
17:34:22 <lambdabot> Consider it noted.
17:35:10 <Philippa> re
17:35:14 <Philippa> comp crashed. What'd I miss?
17:35:32 <Philippa> (damn CPU fan has a habit of not starting when I power up the comp, it needs a nudge - so sandmark pushed the temperature to the point where the CPU freezes to save itself)
17:35:49 <Philippa> AFAIK I was last receiving five minutes ago
17:36:06 <vincenz> Philippa: right
17:36:07 <vincenz> Philippa: GRIN?
17:36:13 <vincenz> Philippa: got a lik?
17:36:15 <vincenz> link even
17:36:23 <Philippa> vincenz: google "Boquist GRIN" or similar
17:37:09 <int-e> http://www.cs.chalmers.se/~boquist/phd/index.html
17:37:12 <lambdabot> Title: Abstract
17:37:19 <int-e> or just follow some links on the JHC page :)
17:37:21 <vincenz> thx
17:41:25 <vincenz> Philippa: hmm
17:41:31 <vincenz> don't feel like browsing through 300 pages
17:41:36 <vincenz> but from what I gathered GRIN is more complex
17:41:45 <vincenz> ANF is pretty 1-1 with SSA
17:41:48 <vincenz> but then in functional form
17:41:54 <vincenz> it comes close to the paper APPEl wrote
17:41:55 <vincenz> but then without cps
17:42:22 <Philippa> yeah. As an intuition, GRIN seems close to SSI - which (again intuitively) is sorta bidi SSA
17:42:28 <dcoutts> @seen shapr
17:42:29 <lambdabot> shapr is in #ScannedInAvian and #haskell. I last heard shapr speak 10 hours, 51 minutes and 32 seconds ago.
17:42:41 <vincenz> Philippa: but I'm at the moment stuck on ow to get dataconstructors in there
17:42:52 <vincenz> Philippa: although the only ones I support are tuples
17:43:01 <vincenz> I guess expanding my letbiniding?
17:43:08 <Philippa> yeah. GRIN sorta has them already
17:43:21 <Philippa> might still be worth looking at. How does ANF do branches?
17:43:26 <int-e> @docs System.Posix.Types
17:43:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Posix-Types.html
17:43:33 <Philippa> you don't need the entire thesis, much of it's optimisation passes
17:43:38 <dcoutts> @tell shapr re: your blog post. The best graphics cards you can get with Open Source drivers are the ATI Radeon 9250's and they're cheep and fanless.
17:43:39 <lambdabot> Consider it noted.
17:43:49 <vincenz> Philippa: yeah but I canc't find a short succint AST declaration for GIRN
17:43:59 <Philippa> heh
17:44:22 <Philippa> yeah, there's just an abstract syntax. Though those aren't too hard to translate to ASTs usually
17:44:43 <vincenz> it's late... I'm lazy
17:44:44 <Philippa> er, wait
17:44:45 <Philippa> braindeath
17:44:51 <ricky_clarkson> If anyone knows Java and Haskell, does this look like a reasonable approximation of the Maybe monad?  See my post at the bottom of http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=33&t=019663
17:44:52 <Philippa> read as algebraic datatype. Yes, there's an AST
17:45:07 <Philippa> though no AST type for a specific programming language
17:45:20 <ricky_clarkson> That's Java 5, if you don't know generics it might be confusing.
17:45:39 <vincenz> ah
17:45:51 <vincenz> Figure 2.6 : Grin Expression semantics
17:46:07 <vincenz> yet.... they don't describe the AST apriori :(
17:46:14 <vincenz> o.O N olet?
17:46:16 <vincenz> No let?
17:46:25 <Philippa> IIRC they do something odd with case instead
17:46:51 <vincenz> yeah a nice part of ANF is that like AST, each variable is only defined once... in a let
17:46:56 <vincenz> so it's easy to do use-def analysis
17:47:16 <vincenz> I'm just trying to figure out what the cleanest way would be for adding in tuples
17:47:20 <vincenz> maybe doing
17:47:24 <vincenz> ELet (x,y,z) = v
17:47:31 <vincenz> and only allowing one nesting?
17:47:49 * vincenz has only tuples anyways
17:48:13 <vincenz> my issue with case is that it doesn't quite relate to my source lang
17:49:20 <Philippa> it's late here and I've had a long day, odds are my advice will be bad
17:50:03 <vincenz> alright
17:50:06 <vincenz> well thanks for telling me about GRIN
17:51:06 <dcoutts> int-e, I think I'd need more explanation to comment properly on the patch
17:51:30 <dcoutts> int-e, I've got the full diff here but am having trouble understanding the intention
17:52:19 <dcoutts> int-e, if you can convince me then I can ok it and commit it
17:52:33 * dcoutts puts on his Cabal patch reviewer hat
17:53:11 * SamB tries to imagine the hat
17:53:23 <dcoutts> s'very nice
17:53:32 * SamB comes up with something that looks like it came out of Dr. Suess
17:53:40 <dcoutts> mm :-)
17:53:51 * dcoutts would like such a hat
17:53:53 <SamB> I probably misspelled his name again, didn't I?
17:54:10 * dcoutts knows who SamB meant
17:54:16 <SamB> of course
17:59:29 <vincenz> dcoutts: never sleep?
17:59:38 <dcoutts> of course not
17:59:58 <ski> ricky_clarkson : that's an implementation of the 'Maybe' data type (more or less) .. not of the monad operations
18:00:12 <ricky_clarkson> ski: Ugh, got my terminology wrong.
18:00:46 <ski> i assume 'Var' is a workaround for only being able to reference 'final' vars from inside inner classes ?
18:00:50 <ricky_clarkson> Yes.
18:01:05 <ricky_clarkson> Another workaround is an array with only one element.
18:01:17 <ski> yes
18:02:03 <ski> 'UserUtility.getAddress' simulates the monadic bind by explicit casing
18:02:31 <ricky_clarkson> One limitation in Java is that I can't get a convenient-looking chain going, I have to wrap.
18:02:48 <ski> what do you mean ?
18:03:16 <ricky_clarkson> getAddress(database.getUser("fred")) instead of database.getUser("fred").getAddress().
18:03:34 <ricky_clarkson> However, I think I've just thought of a good way around that.
18:04:32 <ski> (btw, instead of setting a 'Var' from inside then "case" (i.e. 'Maybe.accept' call), i think you could maybe parameterize 'Maybe.accept' so that you can "return through" it, instead ..)
18:05:29 <ricky_clarkson> True.
18:07:57 <ski> hm, why does 'UserUtility.getAddress' take a 'Maybe<User>' instead of a 'User' ?
18:08:25 <ricky_clarkson> So that I can pass a Maybe<User> to it.
18:08:43 <ricky_clarkson> I can't make Maybe<User> implement/extend User.
18:10:34 <ski> database.getUser("fred").bind(getAddress)
18:10:36 <ski> hm
18:11:25 <ski> (something like that would be more like 'Maybe' monad)
18:12:03 <ski> though probably one would have to expand 'getAddress' into something larger
18:13:04 <ski> (does Java 1.5 support passing around methods, or must they be wrapped in objects ?)
18:13:42 <SamB_XP_> what, aren't they on Java 3 yet?
18:17:28 <ski> (erm, of course with that above, 'getAddress' would take a 'User')
18:22:37 <ricky_clarkson> ski: Er, methods must be wrapped in objects.  It's loads of extra syntax, but it works.
18:22:42 <lispy> dons: ping?
18:28:17 <Numbers> @type Map
18:28:19 <lambdabot> Not in scope: data constructor `Map'
18:28:23 <Numbers> @type Data.Map
18:28:25 <lambdabot> Couldn't find qualified module.
18:28:25 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
18:32:15 <lispy> @hoogle Map
18:32:16 <lambdabot> Data.Map :: module
18:32:16 <lambdabot> Data.Map.Map :: data Map k a
18:32:16 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:32:31 <lispy> sweet, ndm added the case insensitive stuff
18:32:52 <lispy> @hoogle LOOKUP
18:32:53 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
18:32:53 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
18:32:53 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
18:38:48 <Numbers> @hoogle words
18:38:49 <lambdabot> Prelude.words :: String -> [String]
18:38:49 <lambdabot> Data.PackedString.wordsPS :: PackedString -> [PackedString]
18:38:49 <lambdabot> Prelude.unwords :: [String] -> String
18:51:17 <JohnMeacham> vincenz: http://www.cs.chalmers.se/~boquist/phd/index.html
18:51:17 <lambdabot> JohnMeacham: You have 1 new message. '/msg lambdabot @messages' to read it.
18:51:17 <lambdabot> Title: Abstract
18:51:46 <JohnMeacham> vincenz: http://www.cs.chalmers.se/~boquist/fpca95-abstract.html is shorter and should be read first.
18:51:47 <lambdabot> Title: FPCA'95 Abstract
18:54:04 <vincenz> JohnMeacham: cool thx
18:54:19 <vincenz> JohnMeacham: am I right to observe that GRIN is like ANF but with case statements?
18:54:31 <vincenz> JohnMeacham: and therefore nearly STG (if not just like STG)
18:56:59 <dcoutts> @localtime dons
18:57:01 <lambdabot> Local time for dons is Fri Jul 28 11:50:40 2006
18:58:37 <vincenz> JohnMeacham: basically I'm trying to stic close to the imperative model, although I allow tuples for ease... so I don't have full dataconstructor semantics.. (aka no alternates).... that's why I was thinking of hacking ANF instead of switching for instance to STG
18:59:31 <vincenz> (particularly cause I don't need case statements)
19:05:34 <JohnMeacham> vincenz: grin is monadic, in the grin paper read 'bind' as >>= and 'unit' as return and it is exactly like a haskell monad.
19:05:49 <JohnMeacham> it is fairly different than STG.
19:06:28 <JohnMeacham> what do you mean by ANF?
19:07:36 <vincenz> administrative normal form
19:07:41 <JohnMeacham> vincenz: in my jhc source, I change a lot of the terminology to be more in line with current haskell monadic thinking, but the gist is the same. My grin also has stronger typing, since I don't assume I am on a 32 bit RISC cpu like boquist does.
19:07:48 <vincenz> kinda like appel's stuff but without CPS
19:08:10 <vincenz> it's isomorphic to SSA
19:08:20 <vincenz> according to Chakvarty's 2003 paper
19:08:29 <vincenz> @google chakravarty CKZ03
19:08:30 <lambdabot> http://www.cse.unsw.edu.au/~chak/papers/CKZ03.html
19:08:30 <lambdabot> Title: Research Papers of Manuel Chakravarty
19:08:36 <vincenz> check that one out
19:08:53 <vincenz> but yeah, imperative world doesn't' ahve native tuples
19:09:12 <JohnMeacham> So is grin. but it is a whole lot easier to work with :) the monadic rules give a lot more useful transforamtions than SSA, grin also separatess the flow of values from the values themselves, if that makes sense.
19:09:20 <ricky_clarkson> vincenz: Python does, afaik.
19:09:32 <vincenz> JohnMeacham: yeah, ANF is simpler too
19:09:39 <vincenz> JohnMeacham: it's just let bindings and letrec bindings, basically
19:09:41 <vincenz> and function calcls
19:10:03 <vincenz> so you don't need a graph to represent it (unlike the basicblocks in SSA)
19:10:45 <vincenz> @google PearlANormalForm Transforming CoreScheme into A Normal Form
19:10:49 <lambdabot> http://schemecookbook.org/Cookbook/PearlANormalForm
19:10:49 <lambdabot> Title: PearlANormalForm - Cookbook - s c h e m a t i c s : c o o k b o o k
19:10:54 <vincenz> that's got some interesting stuff too
19:11:04 <vincenz> with a scheme implementation of the tree
19:12:25 <vincenz> JohnMeacham: so your model is more executive than declarative thatn say for instance STG
19:12:29 <JohnMeacham> vincenz: native tuples are orthogonal to imperitive code. C based languages tend not to have them, but that is just for historical reasons.
19:12:42 <vincenz> I know, but they require an extension to the ANF
19:12:51 <vincenz> my original AST actually defines generic data constructors
19:12:56 <vincenz> but I only introduce tuples
19:13:05 <JohnMeacham> vincenz: well, it is as declarative as building IO actions in haskell is.
19:13:10 <ricky_clarkson> Is a Perl list a tuple?
19:13:11 * vincenz nods
19:13:35 <vincenz> JohnMeacham: I guess the cleanest would be to have a let (x,y,z) = ... (with one level of nesting)
19:14:14 <JohnMeacham> is your language lazy? if so, you probably want a distinction between boxed and unboxed tuples
19:14:33 <vincenz> nope
19:14:43 <vincenz> it's a spinoff of miniml
19:14:49 <vincenz> but with recursive toplevel declarations
19:14:55 <vincenz> and a haskellish module system
19:16:27 <vincenz> I use it to model the subset of C++ I'm interested in (Cause honestly... parsing C++ is like climbing the mount everest)
19:18:14 <vincenz> JohnMeacham: do you do alias analysis?
19:36:49 <JohnMeacham> the points-to analysis subsumes it.
19:38:10 <palomer> vincenz: gcc can parse and produce an abstract syntax tree
19:38:36 <vincenz> palomer: a) no, b) too lowlevel
19:39:49 <vincenz> @hoogle ap
19:39:50 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
19:39:50 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
19:39:50 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
19:41:37 <palomer> YES!
19:41:48 <vincenz> no, Gcc does not offer full dumping capabilities
19:49:24 <edwardk> dons: around?
19:56:13 <vincenz> haven't seen him in a bit
19:57:56 <edwardk> shucks
19:58:12 <edwardk> wanted to check to see how bad it was to link to a module with a lot of stuff in it as your plugin API.
19:58:48 <edwardk> my initial attempt to restrain things to a dictionary were causing me to have to jump through some painful hoops.
19:59:00 <edwardk> so i just sort of kitchensinked everything into one module
19:59:25 <edwardk> if nothing else i get a heck of a lot more informative error messages now
20:02:05 <edwardk> hahahaha. found the problem. 6 hours of rewriting because i forgot a constructor to rotate my knot in one place.
20:03:18 <vincenz> @type ap
20:03:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
20:14:52 <dons> hello
20:14:52 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:14:57 <edwardk> heya dons
20:15:43 <edwardk> currently i think i'm down to just having to figure out how to instantiate an AltData.Typeable.Typeable1 instance for StateT (JitRState JitR) IO
20:15:45 <vincenz> dons:  \o/
20:16:20 <dons> vincenz: just replied your @tell
20:16:25 <vincenz> cool
20:16:25 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
20:16:32 <dons> edwardk: well, you could just ignore the typed load
20:16:41 <dons> since you're generating the code, you know already its well typed
20:16:44 <edwardk> true
20:16:48 <vincenz> dons: it's free license?
20:16:49 <edwardk> just being paranoid =)
20:16:54 <dons> vincenz: free for any use
20:16:57 <vincenz> :)
20:17:07 <edwardk> and heh
20:17:13 <edwardk> the type system has been good to me
20:17:24 <dons> vincenz: the whole site is in darcs, but you probably don't want all that. just the .css and an example of how to use it
20:17:26 <edwardk> although 6 hours trying to find that i forgot to rotate my knot in one place in the code wasn't so fun
20:17:31 <dons> :)
20:17:35 <vincenz> dons: yup yup
20:17:58 <edwardk> coz ghc doesn't give very good error messages when StateT monads fail because of fundeps
20:18:09 <vincenz> blegh this is bad
20:18:25 <vincenz> too many aps: http://rafb.net/paste/results/jlkGBM67.html
20:18:42 <edwardk> i figured out a kinda neat trick though that works well with knot-tied data structures.
20:19:48 <dons> vincenz: btw, if you want to look at automating our collective sites, i.e. darcs plus some kind of template generator, i'd be interested
20:19:54 <dons> maybe porting to hope?
20:19:58 <vincenz> hm
20:20:00 <dons> or lambdaFeed
20:20:06 <vincenz> @google lambdafeed
20:20:08 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
20:20:08 <lambdabot> Title: Manuel M T Chakravarty - lambdaFeed
20:20:15 <dons> rss generator
20:20:54 <vincenz> I'll think about it :)
20:21:21 <vincenz> that's too many `ap`'s in my code :(
20:21:27 <vincenz> not to mention the nested crap
20:21:30 <dons> hmm yes.
20:21:41 <dons> you need a notation..
20:21:48 <dons> though, hmm, could that be a foldM ?
20:21:57 <vincenz> don't think so
20:22:01 <dons> looks like some kind of unrolled ap loop
20:22:04 <dons> or fold
20:22:08 <vincenz> yeah but each type is different
20:22:11 <vincenz> @type ap
20:22:13 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
20:23:03 <ski> vincenz : that's generated code ?
20:23:58 <vincenz> no
20:24:16 <vincenz> that's the code I'm writing
20:24:49 <ski> return A.EApply `ap` return fname = return (A.EApply fname)
20:24:57 <vincenz> yeah
20:25:01 <vincenz> removing some apcrap
20:26:15 <ski> that looks suspicuicly like you've read the 'Idiom' paper
20:26:20 <ski> @spell suspicuicly
20:26:22 <lambdabot> suspiciously spicule despicably surgically suspect
20:26:29 <vincenz> Idiom?
20:26:39 <int-e> Applicative, formerly called Idiom
20:26:44 <vincenz> right
20:27:33 <dons> ?pl return A.EApply `ap` return fname
20:27:33 <lambdabot> (line 1, column 17):
20:27:34 <lambdabot> unexpected "`"
20:27:34 <lambdabot> expecting variable, "(", ".", space, operator or end of input
20:27:34 <lambdabot> ambiguous use of a left associative operator
20:27:43 <dons> oh that's a bit sad
20:27:57 <vincenz> @pl return a `ap` return b
20:27:57 <lambdabot> return (a b)
20:27:59 <vincenz> :D
20:28:06 <ski> http://www.cs.nott.ac.uk/~ctm/Idiom.pdf
20:28:46 <vincenz> have it
20:28:47 <vincenz> but no
20:28:52 <vincenz> bringert's icfp paper ;)
20:29:10 <ski> ?
20:29:21 <vincenz> nm
20:30:14 <ski> (btw, that pasted code also looks like it would fit into some ideas i have for alternative monadic syntax)
20:31:23 <tato> why am I getting "not in scope: while"?
20:31:52 <tato> in ghci
20:32:03 <vincenz> while doesn't exist?
20:32:15 <tato> seems so
20:32:22 <vincenz> well it doesn't
20:32:41 <dons> are you after when or unless, tato?
20:32:45 <dons> or possible mapM_ ?
20:32:57 <dons> maybe just map
20:33:03 <vincenz> or sequence
20:33:09 <vincenz> sequence_
20:33:13 <vincenz> mapM
20:33:15 <vincenz> ..
20:33:17 <vincenz> foldr
20:33:19 <dons> tato, got an example of how you tried to use while?
20:33:35 <dons> as I'm pretty sure we have about 10 higher order functions that would do that job ;)
20:33:43 <vincenz> if not more :)
20:33:50 <tato> rl = while (do res <- isEOF
20:33:50 <tato>                return res)
20:33:50 <tato>            (do line <- getLine
20:33:50 <tato>                putStr line)
20:34:05 <tato> from "the craft of functional programming"
20:34:05 <vincenz> ah right
20:34:12 <vincenz> add this
20:34:19 <dons> and what is 'while' doing? testing a IO Bool ?
20:34:23 <vincenz> prolly
20:34:24 <dons> and then recursing?
20:34:52 <vincenz> while a b = do { c <- a; if c then (b >> while a b) else return ())
20:34:53 <vincenz> }
20:35:00 <tato> oh its not built in!
20:35:02 <dons> tato, the best solution then is to just copy'n'paste the defn from the textbook
20:35:05 <tato> sorry I'm an idiot
20:35:07 <dons> or else try vincenz idea.
20:35:11 <vincenz> @type if_
20:35:12 <lambdabot> Not in scope: `if_'
20:35:13 <dons> no no. while is interesting :)
20:35:16 <vincenz> @hoogle if_
20:35:17 <lambdabot> Foreign.C.Error.throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
20:35:17 <lambdabot> Foreign.Marshal.Error.throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
20:35:17 <lambdabot> System.Win32.Types.failIf_ :: (a -> Bool) -> String -> IO a -> IO ()
20:35:19 <vincenz> hmm
20:35:25 <vincenz> there's no functional if?
20:35:27 <vincenz> @hoogle cond
20:35:27 <lambdabot> Language.Haskell.TH.condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
20:35:28 <lambdabot> Data.Graph.Inductive.Query.Monad.condMGT :: Monad m => (m s -> m Bool) -> GT m s a -> GT m s a -> GT m s a
20:35:28 <lambdabot> Data.Graph.Inductive.Query.Monad.condMGT' :: Monad m => (s -> Bool) -> GT m s a -> GT m s a -> GT m s a
20:35:30 <dons> vincenz: there's no if or cond
20:35:35 * vincenz mutters
20:35:37 <dons> it was a proposal
20:35:45 <vincenz> cause you could very nicely built while using concd and `ap`
20:35:52 <dons> it's even called if' in @pl
20:35:53 <hypothesys> wow
20:36:01 <hypothesys> so much bad sotware
20:36:04 <hypothesys> so little time
20:36:13 <hypothesys> can haskell read and write to in memory file?
20:36:17 <vincenz> while a b = return cond `ap` a `ap` (b >> while a b) `ap` return ()
20:36:21 <vincenz> ;)
20:36:23 <dons> to a mmap file, hypothesys ?
20:36:34 <dons> or do you just mean a Ptr Word32 buffer?
20:36:38 <dons> either case, yes.
20:36:43 <vincenz> dons: like that while?
20:37:03 <tessier__> tato: How do you like that book? Is it a good book to learn from? I ordered it last night. Should be here in a week.
20:37:20 <dons> hypothesys: but its a bit unusual. you shouldn't really be mutating buffers unless you know you're supposed to
20:38:07 <hypothesys> hmm
20:38:09 <vincenz> dons: so... index.html and co all man-edited?
20:38:14 <hypothesys> just interviewed with bidz . com
20:38:22 <edwardk> [slipwave@www jit]$ ./a.out decoded.um
20:38:22 <edwardk> Stack space overflow: current size 8388608 bytes.
20:38:22 <edwardk> Use `+RTS -Ksize' to increase it.
20:38:24 <edwardk> hrmm
20:38:25 <hypothesys> the programmer guy said they have custom C++
20:38:32 <hypothesys> and have in memory database
20:38:34 <hypothesys> !
20:38:41 <edwardk> so much for my marvelous jit =)
20:38:41 <hypothesys> write to ni memory files
20:38:42 <int-e> edwardk: looks familiar
20:38:44 <edwardk> ideas? =)
20:38:51 <edwardk> i was trying to be a little too lazy i think
20:39:04 <dons> edwardk: space leaks, yeah!
20:39:54 <dons> hypothesys: sure, you can do anything you like in haskell -- its a general purpose language.
20:40:02 <int-e> I still don't understand why that happens with my UM :/
20:40:09 <dons> int-e, profiled?
20:40:12 <edwardk> http://slipwave.info/icfp/jit/JIT.hs and http://slipwave.info/icfp/jit/Main.hs
20:40:17 <edwardk> are where i'm at so far
20:41:02 <edwardk> i merged the API into the JIT source file. probably going to cause me painful linkage times =/
20:41:09 <jwp> anyone know if any work is being done to get ghc on freebsd/amd64?
20:41:23 <dons> should just work, no? jwp?
20:41:29 <dons> i mean, it works out of the box on openbsd/amd64
20:41:45 <dons> someone would just have to do the hc bootstrap
20:42:04 <vincenz> @type fooldr
20:42:05 <lambdabot> Not in scope: `fooldr'
20:42:06 <vincenz> @type foldr
20:42:08 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
20:42:14 <vincenz> hmm
20:42:19 * vincenz never remembers the order
20:42:29 <jwp> dons: yeah, it doesn't just work; from the searches I've done, the last thing you mention probably needs to be done.
20:42:39 <vincenz> @google foldleft
20:42:43 <lambdabot> http://www.cs.nott.ac.uk/~lad/research/challenges/IWC015.txt
20:42:47 <dons> that's what i mean. when you do the port, it should just work
20:42:54 <jwp> :)
20:42:56 <dons> the port is one person's job for one day, approximately
20:43:03 <vincenz> @type foldl
20:43:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:43:09 <dons> jwp, check the porting instructions in the ghc user's guide.
20:43:20 <vincenz> fold f a bs =
20:43:31 <vincenz> (f bx (f b... (f b0 a))?
20:44:03 * vincenz never remembers the order
20:44:17 <jwp> dons: ok, thanks.
20:44:18 <int-e> uh-oh. ghc-6.5: unknown package: base
20:44:28 <vincenz> > subtract 2 1
20:44:29 <lambdabot>  -1
20:44:30 <dons> uh ho!
20:44:36 <dons> int-e , that sounds super nasty
20:44:42 <vincenz> > foldl subtract 0 [1,2,3]
20:44:44 <lambdabot>  2
20:44:51 <int-e> dons: SPJ is fiddling with the package system
20:44:59 <dons> ah yes.
20:45:06 <dons> that's what's happening
20:45:11 <vincenz> > foldl subtract 0 [1,2,4]
20:45:12 <lambdabot>  3
20:45:23 <vincenz> > foldl subtract 0 [1,2,4,5]
20:45:24 <lambdabot>  2
20:45:38 <ski> foldr f a [b0,b1,...,bx] = b0 `f` (b1 `f` (... `f` (bx `f` a)..))
20:45:39 <vincenz> hmm
20:45:47 <vincenz> ski: and foldl?
20:46:04 * vincenz always forgets the order
20:46:26 <ski> foldl f a [b0,b1,...,bx] = (..((a `f` b0) `f` b1) `f` ...) `f` bx
20:46:32 <vincenz> thx
20:46:49 <tessier__> I'm reading the functional programming faq and it says that haskell is not a concurrent language but erlang is. I thought haskell supported threads also. What's the difference?
20:47:09 <dons> hmm?
20:47:12 <dons> it is a concurrent language
20:47:17 <dons> ?type forkIO
20:47:18 <lambdabot> Not in scope: `forkIO'
20:47:23 <dons> ?hoogle forkIO
20:47:24 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
20:47:28 <dons> ?docs Control.Concurrent
20:47:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
20:47:38 <dons> in fact, we beat erlang in at least some of the concurrent benchmarks in the language shootout
20:47:52 <dons> tessier__: so sounds like the faq is wrong, or about a decade out of date?
20:48:42 <ski> vincenz : in that paste, why do you have a 'return ...' command just before the final 'return ...' command ?
20:48:56 <dons> tessier__: ah, here, http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
20:48:58 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ...
20:49:38 <dons> haskell is really pushing forwards the concurrency and parallel aspects of the language right now. in particular, the new data parallel ghc libraries coming in
20:49:46 <dons> and the new smp runtime system
20:50:02 <edwardk> dons: how bad is it to link to a big module for a hsplugin api?
20:50:15 <dons> hmm. not so bad
20:50:20 <edwardk> good =)
20:50:43 <dons> vincenz: i've updated the um.html link to your um, to point to my localcopy
20:51:34 * dons finally gets through the mountain of patches submitted while icfp was going on
20:52:56 <dons> ?karma+ kpreid -- lambdabot patch
20:52:56 <lambdabot> kpreid's karma raised to 2.
20:53:01 <dons> ?karma+ xerox -- lambdabot patch
20:53:01 <lambdabot> xerox's karma raised to 21.
20:53:25 <hypothesys> hm
20:54:29 <tato> how am I supposed to handle isEOFError  when getLine reaches EOF?
20:56:24 <dons> you handle the EOFError by catch()ing the exceptoin, and testing with isEOFError
20:56:30 <dons> let me find an example
20:57:06 <dons> catch (some io action) (\e -> if isEOFError e then return Nothing else ioError e)
20:57:12 <dons> alternatively
20:57:19 <dons> handle (\e -> if isEOFError e then return Nothing else ioError e) $ do something
20:57:31 <dons> be sure to import Control.Exception to get catch/handle
20:57:56 <dons> tato, do you want an intro to exception handling?
20:58:22 <dons> ?uptime
20:58:23 <lambdabot> uptime: 9 days, 12 hours and 14 minutes
20:58:28 <hypothesys> hmmm
20:58:40 <dons> we seem to have reached a nice stable point in lambdabot's existence
20:58:43 <dons> hypothesys: ?
21:00:02 <tato> what if "some io action" doesn't throw an exception?
21:00:18 <dons> then it just returns the result of the io action
21:00:21 <dons> i.e.
21:00:22 <tato> does catch return the results directly?
21:00:26 <tato> oh ok
21:00:36 <dons> catch (getChar) (\e -> print e)
21:00:58 <dons> catch (getChar) (\e -> print e >> error "failed") -- type correct
21:01:23 <dons> will either return a Char, or if getChar throws an exceptoin, we catch it, and print the error, then throw a new exception out to the top level
21:01:34 <emertens> is 'error' always fatal?
21:01:37 <dons> ?docs Control.Exception
21:01:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
21:01:42 <dons> emertens: no. it can be caught
21:01:50 <dons> everything can be caught, except a few of the signals
21:01:59 <ski> catch (liftM Just getChar) (\e -> print e >> return Nothing)
21:02:06 <dons> even pattern failure, division by 0, undefined, and so on
21:02:23 <dons> one fun trick is to catch 'NoSuchMethodException' in classes, and fall to a backup
21:02:35 <dons> lambdabot uses this to handle plugins that don't implement the full interface .. :)
21:02:42 <dons> very unhaskellish ;)
21:03:06 <emertens> @type catch
21:03:07 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
21:03:14 * ski wonders if a better defaulting system could handle that ..
21:03:15 <dons> ?type Control.Exception.catch
21:03:16 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
21:03:38 <dons> ski, well lambdabot is a special case, since its all runtime loaded plugins
21:03:42 <dons> it also has to be super robust
21:03:47 <int-e> ah. NoMethodError. The other thing was Java I think.
21:03:51 <dons> and handle things like thread failures and so on
21:04:17 <dons> here, for you viewing pleasure:
21:04:18 <dons> catchError
21:04:18 <dons>                                     (process m msg towhere cmd' rest)
21:04:18 <dons>                                     (\ex -> case (ex :: IRCError) of -- dispatch
21:04:21 <dons>                                                 (IRCRaised (NoMethodError _)) ->
21:04:24 <dons>                                                     process_ m cmd' rest
21:04:31 <dons> ah yes, NoMethodError. (brain explosion??)
21:05:06 <dons> int-e, did I actually just slip a bit of java in? now I'm really scared
21:05:31 <int-e> I think you did.
21:05:54 <int-e> It definitely exists in Java (that exception that is)
21:06:00 <dons> that's really really freaky.
21:06:21 <vincenz> ski: ?
21:06:37 <ski> <ski> vincenz : in that paste, why do you have a 'return ...' command just before the final 'return ...' command ?
21:07:10 <ski> also, there seems to be unbalanced parens, on closer look
21:07:21 <edwardk> putStrLn $ "Legacy scroll read"
21:07:21 <edwardk>         arr' <- unsafeFreeze arr :: IO (UArray Int Word8)
21:07:21 <edwardk>         let l2 = fromIntegral l `div` 4
21:07:21 <edwardk>         putStrLn $ "Allocating " ++ show l2
21:07:29 <edwardk> i appear to be crasahing between putStrLn's
21:07:31 <vincenz> ski: it wasn't finished yet
21:07:32 <vincenz> ;)
21:07:34 <edwardk> and i'm not sure whats going on
21:07:54 <edwardk>  
21:07:54 <edwardk> Legacy scroll read
21:07:54 <edwardk> Stack space overflow: current size 8388608 bytes.
21:07:54 <edwardk> Use `+RTS -Ksize' to increase it.
21:08:00 <edwardk> it isn't even making it to the jit parts
21:08:17 <ski> vincenz : i wanted to translate it, for fun
21:08:20 <dons> ?quit code update
21:08:43 <int-e> hmm. unsafeFreeze doesn't really do very much (a unsafeCoerce#?)
21:08:50 <monochrom> Royally bizzare!  You aren't even using the array after freezing!
21:09:04 <edwardk> hahaha
21:09:04 <int-e> so ... what's l?
21:09:06 <edwardk> thats funny
21:09:10 <edwardk> if i add optimizations it works =)
21:09:26 <dons> ?version
21:09:31 <edwardk> -funbox-strict-fields -O2 -optc-O3
21:09:33 <edwardk> made it work =)
21:09:41 <lambdabot> lambdabot 4p35, GHC 6.5 (OpenBSD i386 )
21:09:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:09:46 <edwardk> without it it dies
21:10:02 <int-e> well, it is a stack overflow
21:10:17 <dons> ?uptime
21:10:17 <lambdabot> uptime: 1 minute and 52 seconds
21:10:18 <monochrom> It is advisable to use at least -O if you call unsafeFreeze
21:10:33 <dons> monochrom: it is?
21:10:34 <int-e> maybe the program was just lacking some tail call optimization, or strictification.
21:10:36 <dons> i didn't know that.
21:11:01 <monochrom> The unsafeFreeze doc says so.
21:11:09 <int-e> monochrom: oh. does it give a reason?
21:11:14 <dons> huh. that's interesting
21:11:36 <edwardk> it said that it might use the normal freeze if you don't optimize
21:11:42 <edwardk> but i didn't think it would hurt
21:11:50 <monochrom> However, I can't explain why omitting -O would lead to a stack overflow.
21:12:02 <edwardk> that part of the code is identical to sjannsen's
21:12:05 <dons> well, it happens some times, that the compiler figures something out with -O
21:12:08 <dons> its not unheard of
21:12:19 <int-e> so what ... unless ... that involves a copy, a loop, a list, lots of thunks, ... it could just cause a stack overflow.
21:12:37 <dons> new plugins
21:12:39 <monochrom> Yes that's the only sensible hypothesis.
21:12:40 <dons> ?unquote "x"
21:12:40 <lambdabot> x
21:13:03 <monochrom> How large is your array edwardk?
21:13:26 <int-e> monochrom: actually I was playing with the idea that l might be unevaluated and forcing it could cause a stack overflow
21:13:27 <dons> ?choose a b c d e
21:13:27 <lambdabot> a b c d e
21:13:33 <edwardk> um, about 16 meg =)
21:13:42 <dons> ?help choose
21:13:42 <lambdabot> choose. Lambdabot featuring AI power
21:13:50 <monochrom> I forgot that.  What is l ?  :)
21:13:52 <int-e> monochrom: but in the context that seems unlikely - l should have been used before.
21:14:06 <int-e> The length of the array I guess.
21:14:23 <tessier__> dons: With haskell's support for parallelism is there any noise from the scientific community about using it?
21:14:30 <dons> @. unquote run 'f':'o':'o':[]
21:14:31 <lambdabot> foo
21:14:41 <int-e> oh no!
21:14:44 <tessier__> Seems like it could be a fortran killer were it not for all of the existing fortran code and old farts averse to learning something new.
21:15:07 <dons> tessier__: hmm. there are some physics people moving over. i've been involved in a chemsitry project that uses parallel haskell
21:15:13 <lispy> dons: i had a question for you earlier...can't remember it now...
21:15:38 <int-e> @. unquote run "\1ACTION blinks.\1"
21:15:39 * lambdabot blinks.
21:15:41 <dons> @. unquote run "/me tests lambdabot"
21:15:42 * lambdabot tests lambdabot
21:15:43 <int-e> no good
21:15:45 <dons> ah beat me
21:15:52 <emertens> "Increasing numbers of patients have been missing out on health care because they are too fat to fit into xray machines"
21:15:56 <int-e> /me?!
21:16:06 <dons> int-e, i'll have to insert a space.
21:16:10 <dons> @seen kpreid
21:16:10 <lambdabot> kpreid is in #haskell. I don't know when kpreid last spoke.
21:16:17 <int-e> but how does that /me work?
21:16:23 <emertens> @. unquote run "this command works for others?"
21:16:25 <lambdabot> this command works for others?
21:16:31 <dons> @tell kpreid was your intention with unquote to allow actions? or something else?
21:16:32 <lambdabot> Consider it noted.
21:16:50 <dons> int-e, hmm, magic?
21:16:58 <int-e> @. unqote run "@eval 1+1"
21:16:58 <lispy> i started reading history of haskell, good stuff
21:16:58 <lambdabot> compose module failed: IRCRaised Parse error: "unqote"
21:17:08 <int-e> @. unquote run "@eval 1+1"
21:17:09 <lambdabot>  @eval 1+1
21:17:10 <dons> it shouuld ignore itself
21:17:14 <dons> leading space
21:17:22 <dons> which i will now add to unquote
21:18:01 <lispy> dons: it was a question at work...so i was dealing with dlls or laziness or ffi....
21:18:03 <lispy> hmm...
21:19:04 <int-e> I see. IRC::privmsg does the /me handling
21:19:04 <dons> ?pl (\s -> ' ' : s) . read
21:19:05 <lambdabot> (' ' :) . read
21:21:20 <dons> ?quit buglet
21:22:13 <dons> ?version
21:22:39 <lambdabot> lambdabot 4p36, GHC 6.5 (OpenBSD i386 )
21:22:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:23:34 <dons> @. unquote run "/me tests lambdabot"
21:23:35 <lambdabot>  /me tests lambdabot
21:24:10 <edwardk> hrmm
21:24:10 <edwardk> ok
21:24:14 <edwardk> result where {
21:24:14 <edwardk> result :: JitF JitE
21:24:14 <edwardk> result a b c d e f g h = seq a $ seq b $ seq c $ seq d $ seq e $ seq f $ seq g $ seq h $ do {
21:24:14 <edwardk> let {v = 4237};va <- jit g v;va v b c d e f g h}
21:24:18 <edwardk> seems to be blowing up
21:24:26 <edwardk> =)
21:24:36 <edwardk> but its a parsing error i think on the let
21:24:58 <edwardk> says 'parse error on input 'in'
21:24:59 <edwardk> ideas?
21:25:13 <dons> there's no 'in?
21:25:21 <edwardk> its a let in a do block
21:25:22 <liyang> vincenz: you can write  pure f <*> x <*> y  as  II(f x y)  in GHC. (Where pure = return and (<*>) = ap. And II() are the idiom brackets.)
21:25:28 <edwardk> isn't there not supposed to e? =)
21:25:31 <edwardk> er be?
21:25:33 <monochrom> Very poor { } matching.
21:25:35 <liyang> (I realise my comment is several hours late.)
21:25:39 <dons> ?type do let x = 1; y <- return (); return y
21:25:40 <lambdabot> parse error on input `<-'
21:25:44 <edwardk> the {} are autogenerated
21:25:57 <dons> ?type do { let x = 1; y <- return (); return y }
21:25:59 <lambdabot> parse error on input `<-'
21:26:11 <edwardk> ?type do { let {x = 1}; y <- return(); return y }
21:26:13 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
21:26:13 <dons> ?type do { let x = 1; return () >>= \y -> return y }
21:26:14 <lambdabot> parse error on input `}'
21:26:29 <edwardk> the let is one expression, it would want to use layout, hence the {}'s
21:26:34 <dons> yeah
21:26:50 <monochrom> Join all lines into one.  If still parse error, definitely poor { }
21:26:51 <edwardk> i'm not in a hurry to autogenerate layout with the code =)
21:27:11 <dons> well, you'd just build a Language.Haskell type, and use ppr
21:27:30 <monochrom> That is better!
21:27:38 <edwardk> woops
21:27:40 <edwardk> what was that?
21:27:52 <edwardk> how can i join the result lines with the type annotation cleanly?
21:27:53 <monochrom> "edwardk has left #haskell"
21:28:03 <vincenz> liyang: nice
21:28:29 <monochrom> ... where { x :: Int; x = 1 }    valid syntax
21:29:08 <edwardk> ah
21:29:20 <edwardk> i think it might be that outer where
21:29:36 <edwardk> unbalanced
21:29:43 <edwardk> and no ; between results
21:31:39 <emertens> they keep talking about "iChoons" on BBC world service... is that the common british pronounciation for iTunes?
21:31:59 <emertens> anyone know?
21:34:41 <dons> emertens: sounds reasonable to me.
21:35:14 <dons> that's how I'd say it in Aussie :)
21:35:20 <ski> liyang : idiom brackets are implemented in ghc ?
21:36:42 <edwardk> heh
21:36:43 <edwardk> segfault
21:36:50 <edwardk> maybe i shouldn't start with unsafeEval =)
21:37:15 <emertens> at least you have proven that the function is unsafe
21:37:24 <ski> hm .. unsafeEvil
21:37:48 <int-e> maybeComputeTheRightThing
21:37:50 <emertens> @type unsafeEval
21:37:52 <lambdabot> Not in scope: `unsafeEval'
21:39:29 <emertens> is lambdabot's irc library developed as a separate project from lambda bot?
21:39:42 <edwardk> ok, how do i add the AltData.Typeable thing?
21:39:58 <edwardk> coz i don't see me making headway without types
21:40:55 <dons> emertens: no, but we've moved in that direction over time
21:41:10 <dons> and people have used IRC.hs to implement other programs, notably hircules
21:41:23 <dons> edwardk: you write an instance for AltData.Typeable
21:41:23 <int-e> dons: ah, there're worse things than that package stuff. Now I have: Segmentation fault (core dumped) ;)
21:41:31 <dons> heh
21:41:37 <edwardk> ok, well, the Tycon stuff is a little arcane to me
21:41:41 <dons> try a snapshot from a few days ago, int-e
21:41:44 <edwardk> when its just a deriving statement its easy =)
21:41:55 <dons> i.e ghc-6.5.20060724-src.tar.bz2
21:42:07 <dons> edwardk: there's some examples in the hs-plugins testsuite/
21:43:04 <edwardk> thats what i needed thanks =)
21:43:10 <goltrpoat> i don't suppose anyone has a copy of "forward reasoning and dependency-directed backtracking in a system for computer-aided circuit analysis" by stallman and sussman?  it's a paper from a 1977 issue of artificial intelligence, copyright's expired, but i can't find it online
21:44:19 <dons> goltrpoat: one option is to write to the authors. i've had luck getting mailed copies of the original papers that way
21:44:48 <goltrpoat> oh, good idea
21:45:16 <dons> they're usually happy that someone cares about their old work :) enough that they'll pay for the stamps themselves
21:46:33 <goltrpoat> hehe
21:47:44 <int-e> grr. why does darcs unpull/unrecord fail occasionally on partial repositories?
21:49:00 <goltrpoat> i think both stallman and sussman are famous enough that the "ooh, someone wants my paper" factor won't really figure into it, but this sounds quite a bit easier than hunting down that journal issue
21:49:12 <goltrpoat> so might as well try it :)
21:49:21 <dons> that's possible, goltrpoat. it'll be in someone's library somewhere.
21:49:35 <goltrpoat> -nod-
21:49:39 <dons> probably the complete stallman opus is available
21:55:33 <lispy> dons: i remember!
21:55:39 <lispy> dons: do you have an ncurses binding?
21:55:57 <lispy> dons: i know yi uses ncurses...so i was thinking maybe you had a pretty good binding that could be extracted
21:56:25 <dons> lispy, yes, yes I do.
21:56:50 <dons> http://www.cse.unsw.edu.au/~dons/code/hmp3/Curses.hsc
21:57:21 <dons> and lots of examples of how to use it in hmp3/UI.hs and hmp3/*
21:57:35 <dons> its actually portable to ocurses, curses and irix curses too
21:57:38 <dons> so not just ncurses
21:57:58 <dons> check the hmp3 screenshots for what you ca ndo
21:58:10 <dons> now, if you want widgets and stuff like that, then use stefan wehr's hscurses
21:58:10 <lispy> dons: thanks
21:58:13 <dons> ?where hscurses
21:58:14 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
21:58:21 <dons> its a bit heavier, but has more thingies
21:58:21 <lispy> dons: i had this idea to hack on (just for fun) an angband clone
22:00:27 <lispy> you don't by chance know of an image magic binding do you?
22:00:28 <dons> sounds good
22:00:34 <dons> hmm. no.
22:00:41 <dons> check haskell.org
22:03:28 <lispy> yeah, i checked google but all i found was a thing on gmane about it
22:03:42 <lispy> a friend of mine had the idea that it would be really useful
22:03:45 <lispy> and he's right :)
22:04:21 <lispy> i have to say, haskell binds to C easier than anything else i've used (except maybe C++ but that doesn't count)
22:05:55 <dons> its the easiest language i've used to bind to C, certainly
22:06:41 <lispy> with sbcl it was easy but with ghc it's yet a step easier
22:06:51 * lispy was a lisper before a haskeller
22:07:08 <lispy> i have really fallen in love with static typing
22:07:20 <dons> that's good for your soul
22:07:27 <lispy> which is funny...i came to lisp bacause i grew frustrated with C's types
22:07:29 <dons> ?karma+ lispy -- soul++
22:07:30 <lambdabot> lispy's karma raised to 5.
22:07:33 <lispy> heh
22:08:21 <lispy> i'm still struggling with laziness...but recently i used it to my advantage so that made me happy
22:49:38 <octon> wow
22:49:40 <octon> haskell
22:49:45 <octon> how does haskell compare to c++?
22:50:34 <mlh> octon: very different
22:50:45 <roconnor> haskell is way better
22:51:10 <mlh> too different to effectively describe here; do some reading
22:54:04 <dons> ?pl peekByte ptr i4 >>= \w -> return (w `shiftL` 24
22:54:05 <lambdabot> (line 1, column 48):
22:54:05 <lambdabot> unexpected end of input
22:54:05 <lambdabot> expecting digit, variable, "(", "`", "!!", ".", operator or ")"
22:54:06 <roconnor> @hoogle eof
22:54:07 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
22:54:07 <lambdabot> Text.Read.EOF :: Lexeme
22:54:07 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
22:54:10 <dons> ?pl peekByte ptr i4 >>= \w -> return (w `shiftL` 24)
22:54:11 <lambdabot> (`shiftL` 24) `fmap` peekByte ptr i4
23:59:39 <roconnor> @seen shapr
23:59:40 <lambdabot> shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 17 hours, 8 minutes and 44 seconds ago.
