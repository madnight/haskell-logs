00:00:53 <roconnor> @type replicate
00:00:54 <lambdabot> forall a. Int -> a -> [a]
00:02:00 <roconnor> @hooglereplicate
00:02:01 <lambdabot> Unknown command, try @list
00:02:04 <roconnor> @hoogle replicate
00:02:04 <lambdabot> Prelude.replicate :: Int -> a -> [a]
00:02:04 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
00:02:04 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
00:02:13 <roconnor> @hoogle take
00:02:13 <lambdabot> Prelude.take :: Int -> [a] -> [a]
00:02:13 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
00:02:13 <lambdabot> Data.PackedString.takePS :: Int -> PackedString -> PackedString
00:02:42 <roconnor> @hoogle genericLength
00:02:43 <lambdabot> List.genericLength :: Integral a => [b] -> a
00:02:43 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
00:02:54 <roconnor> @hoogle genericReplicate
00:02:54 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
00:02:54 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
00:40:39 <Itkovian> meuning
00:49:57 <dons> ?uptime
00:49:58 <lambdabot> uptime: 2 days, 9 hours, 36 minutes and 10 seconds
01:21:20 <Lemmih> kosmikus: ping.
01:22:36 <vegai> lambdabot's pretty cool with its memory requirements these days, too
01:24:12 <dons> yeah?
01:24:35 <dons> i haven't done any profiling in months
01:24:40 <dons> so its possible its crept up
01:24:54 <dons> but you think its gone down?
01:25:56 <kosmikus> Lemmih: pong
01:26:04 <vegai> perhaps my memory fails me (wouldn't be the first), but I recall RES being in the 10MB range earlier
01:26:17 <dons> and now?
01:26:19 * kosmikus is reminded that he wanted to contact Lemmih anyway
01:26:59 <vegai> ok, not *much* better, 8MB. But it's always important to have one less digit in there... :P
01:27:42 <dons> yeah, i've got 7 here.
01:27:51 <dons> so that's gone down, yes.
01:27:55 <dons> used to be around 13 or so
01:28:07 <dons> a lot of modules have been converted to use packed string state
01:28:10 <dons> which helps muchly
02:03:48 <dcoutts> dons, re: fps & streams, yes though I'll be away at the weekend and beginning of next week
02:38:20 <dons> dcoutts: ok
02:41:10 <dcoutts> dons, and then more porfiling to see if the streams stuff is faster :-)
02:42:03 <dons> yes. i fixed the benchmark system today (or did I say that?)
02:43:53 <paolino> /ping
02:44:02 <paolino> oops
02:45:27 <Skymarshal> Does Haskell have some sort of exec() or system() call like Perl?
02:45:55 <mux> @info System.cmd
02:45:56 <lambdabot> Unknown command, try @list
02:46:04 <dons> ?hoogle system
02:46:05 <lambdabot> System.system :: String -> IO ExitCode
02:46:05 <lambdabot> System :: module
02:46:05 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
02:46:20 <dons> ?hoogle Process
02:46:22 <lambdabot> System.Process :: module
02:46:22 <lambdabot> System.Win32.Process :: module
02:46:22 <lambdabot> System.Process.ProcessHandle :: data ProcessHandle
02:46:32 <dons> Skymarshal: yes :)
02:46:34 <mux> System.system actually
02:46:37 <mux> oops, late.
02:46:56 <Skymarshal> thanks!
02:53:06 <dcoutts> dons, thanks for all the forwarded emails btw :-)
03:00:45 <isaacd> now using the precompiled libraries, jhc can compile 'main = return () :: IO ()' in a fairly reasonable amount of time
03:00:49 <isaacd> correctly ;-)
03:04:19 <dcoutts> isaacd, great! :-)
03:26:46 <dons> isaacd: so it supports hnop?
03:32:06 <gds> Can I use hoogle to search for cabal dependancies, sortof a la CPAN ?
03:32:10 <kzm> I still need to know the advantages of lumping as much as possible into the 'base' package.
03:32:13 <gds> @hoogle Broswer-any
03:32:13 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-any'
03:32:26 <isaacd> dons: I assume, I'll try that in a moment to be sure
03:32:29 * kzm is trying to anwer Malcolm W.'s mail about the package system.
03:33:35 <isaacd> dons: "Warning: Unknown OPTIONS in pragma module Main ["-Wall","-Werror"]"
03:33:57 <isaacd> dons: and the Makefile only works for GHC in HNOP 0.1
03:34:25 <isaacd> dons: but it compiles properly
03:36:04 <gds> dcoutts: http://www.haskell.org/http/ says that "the http and browser packages have been merged again" at your suggestion - so I guess you're a good person to ask - does this mean I can remove the "Browser" cabal dependancy from the HXT package I'm trying to install?
03:36:05 <lambdabot> Title: "Haskell HTTP package"
03:40:06 <voltaire> Anyone know of any type unification libraries? I am writing a unified graphics converter, where I have various routines which will take certain types and emit others. What I'd like to do, is build a path through functions of various types, from input type to output type. e.g if there exists functions jpg -> png, png -> tif, then given png,tif it will construct the appropriate path.
03:41:11 <voltaire> Unlike normal type proofing, we only need to find a single possible path.
03:42:18 <df_> voltaire, becareful with those, you can get some very stupid paths appearing (see DirectShow for some good examples)
03:43:04 <voltaire> df_ I know. I'd like to add a cost and minimise the path cost.
03:44:40 <df_> ok.  isn't it just a directed graph problem? then pick your faviourite transversal method
03:45:10 <isaacd> Although it doesn't react to your CFLAGS, even though it doesn't need to mangle the C compiler's output or anything -- always -O -foptimize-sibling-calls etc
03:45:23 <isaacd> as far as I can tell
03:47:32 <isaacd> Considering how slow jhc is compared to the C compiler, it may as well crank up those optimization flags
03:48:00 * isaacd is now going to bicycle
03:48:38 <voltaire> df_ Not really, I want to have a way of expressing subtyping and lists
03:48:54 <dcoutts> gds, yes
03:49:16 <gds> Cool :)
03:49:19 <dcoutts> gds, that's exactly what we've done for the gentoo hxt package
03:49:38 <gds> Then presumably the hxt guys know about the change in http ?
03:49:43 <gds> (I don't have to mail them)
03:49:46 <dcoutts> gds, note there is a fix in the http.cabal file
03:49:53 <dcoutts> gds, not sure, probably not yet
03:49:55 <voltaire> df_ i.e I want to be able to have map type constructs.
03:49:57 <dcoutts> the change was only yesterday
03:50:04 <gds> :)
03:53:27 <dcoutts> gds, actually HXT 6.1 was just released :-)
03:55:05 <gds> lol :)
03:55:17 <gds> In which case I'll go get that :)
04:27:46 <dcoutts> JaffaCake, with -threaded being default these days, it makes finding a solution for single threaded foreign libs all the more important
04:39:02 <vincenz> eivuokko: thanks
04:43:55 <Igloo> dcoutts: Is -threaded actually the default for programs compiled by GHC rather than just available by default?
04:45:29 <int-e> dcoutts: I'm not sure if this is the right problem. I've made a simple gtk controlling module that lets all Gtk stuff being handled in a single thread created by forkOS (which creates threads pinned to an OS thread); communication is done through an MVar (IO ()). (possible a queue would be better.) My problem with that is on the gtk end - I'd like to implement my own main loop.
04:46:08 <dcoutts> Igloo, ghci uses it now
04:46:58 <Igloo> Oh I see
04:46:59 <dcoutts> and I JaffaCake has indicated that it will be the defalt for programs compiled by GHC in some future release
04:47:06 <dcoutts> and least that was my understanding
04:47:27 <Igloo> OK, I just thought you were talking about compiled programs today
04:47:38 <dcoutts> not yet
04:53:43 <dcoutts> int-e, that makes for a rather akward programming style if everything has to go via a queue
04:54:01 <dcoutts> we'd prefer something safe and transparent
04:54:11 <dcoutts> and effecient!
04:58:51 <eivuokko> What I've been wondering, is how efficient runInBoundThread is.  I'd like to use it in Win32 for error checking (it's unsafe atm), but if it starts new OS-thread everytime...I'd rather have block-like..don't allow thread switching within this block.
04:58:53 <int-e> Hmm. MVar is quite good without -threaded. I now realize that I've not seen any measurements in the presence of different OS threads.
04:59:35 <int-e> But anyway, you have to deal with thread synchronization there so some sort of locking is to be expected.
05:00:28 <int-e> @hoogle ThreadId
05:00:29 <lambdabot> Control.Concurrent.ThreadId :: data ThreadId
05:00:29 <lambdabot> GHC.Conc.ThreadId :: ThreadId# -> ThreadId
05:00:29 <lambdabot> Control.Concurrent.myThreadId :: IO ThreadId
05:05:20 <int-e> doing it transparently is possible I think, at the cost of comparing the threadId with the right one and going through the Queue if it doesn't match. But I admit I didn't care so much about efficiency or transparency.
05:06:48 <dcoutts> int-e, there are lots of very simple little gtk proerty getter/setters that are currently quite effecient
05:06:50 <isaacd> eivuokko: it's possible that a pool of threads is kept around rather than *starting* a new one every time, although I'm not sure (1) whether that's even true; (2) how much that helps efficiency
05:07:02 <dcoutts> MVAr + thread switching would be a big overhead for those
05:08:12 <int-e> dcoutts: yes. transparency really costs performance there, because you really want to switch threads once, query everything you want to know, and then get back to the original thread.
05:08:19 <eivuokko> isaacd, Indeed.  I'd rather hope to block thread switches.  It's mostly just doing ffi call and maybe afterwards checking error code that needs to be done in one OS thread.
05:08:42 * dcoutts heads off for the weekend
05:08:44 <eivuokko> isaacd, On case of WinApi, it might be ok to add WsaGetLastError cache same as is done for errno
05:08:50 <eivuokko> (in ghc rts)
05:08:57 <int-e> dcoutts: but transparently the best you can do is a huge number of roundtrips.
05:09:34 <dcoutts> int-e, it might be possible to make the current haskell thread move to the right OS thread on the first call and ramin there thereafter
05:09:36 <int-e> (unless you migrate RTS threads to other OS threads, hmm.)
05:09:40 <dcoutts> exactly
05:09:50 * dcoutts really heads off for the weekend :-)
05:09:55 <int-e> I don't know if I like that. But it's RTS stuff. :)
05:09:57 <int-e> bye dcoutts 
05:10:07 <dcoutts> bye
05:19:35 <boegel> dcoutts: you there? >:)
05:21:36 <vincenz> boegel: gtk2hs questions?
05:24:26 <boegel> vincenz: no, just teasing him :p
05:38:23 <vincenz> dons: ping
05:47:41 <dons> vincenz: pong
05:53:25 <ndm> dcoutts, ping?
05:53:33 <ndm> @seen dcoutts
05:53:35 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 43 minutes and 11 seconds ago.
05:54:51 <kzm> @seen igloo
05:54:52 <lambdabot> igloo is in #darcs and #haskell. I last heard igloo speak 1 hour, 7 minutes and 25 seconds ago.
05:55:10 <Igloo> Hello
05:55:31 <anuke> $seen lambdabot
05:55:32 <kzm> Hi there.  You do .debs for a bunch of Haskell things, right?
05:55:38 <Igloo> Right
05:56:09 <kzm> I was wondering whether I should debianize some of my stuff.  Is there a simple package I could look at.
05:56:19 <kzm> (i.e. steal from :-)
05:56:52 <kzm> I also wonder if I shouldn't rebuild for Ubuntu (which I use).
05:57:17 <kzm> Apparently ghc 6.4.2 fixes some troublesome spots with 6.4.1 (cabal version, fps version).
05:58:26 <kzm> ?
05:59:50 <Igloo> I currently use things like http://urchin.earth.li/~ian/cabal/generalised-cstring/debian/ but other people swear by John's dh_haskell stuff
05:59:52 <lambdabot> Title: "Index of /~ian/cabal/generalised-cstring/debian"
06:01:19 <roconnor> @where dh_haskell
06:01:20 <lambdabot> I know nothing about dh_haskell.
06:04:13 <kzm> Okay, will take a look.  (And read some docs :-)
06:11:00 <roconnor> *Shaskell> sha256 (map (fromIntegral . fromEnum) (replicate 1000000 'a'))
06:11:00 <roconnor> *** Exception: stack overflow
06:11:04 <roconnor> :)
06:18:33 <vincenz> dcoutts: ping
06:31:46 <Lemmih> kosmikus: Did you see my mail?
06:32:09 <kosmikus> no
06:32:12 <kosmikus> or which one?
06:32:55 <kosmikus> if you mean the one from a few days ago, then yes, I did, and I meant to contact you again, but I forgot, sorry
06:43:49 <Lemmih> Yeah, I meant the old one.
06:44:00 <kosmikus> pm?
06:46:12 <Cale> whoa, lambdabot seems to have grown to 200MB
06:55:41 <vincenz> @seen dcouts
06:55:43 <lambdabot> I haven't seen dcouts.
06:55:47 <vincenz> @seen dcoutts
06:55:48 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 1 hour, 45 minutes and 25 seconds ago.
06:55:54 <vincenz> Cale: o.O
06:58:46 <gds> vincenz: 13:09    dcoutts really heads off for the weekend :-)
06:59:05 <vincenz> ah right
06:59:05 <vincenz> damn
06:59:10 <vincenz> anyone else knowledgeable of SSA?
07:01:49 <Lemmih> The Social Security Administration?
07:02:12 <vincenz> static single assignment
07:02:19 <Lemmih> Cale: She's just big boned.
07:05:18 <yip> hello Lemmih 
07:06:00 <Lemmih> Greetings yip.
07:06:48 <yip> how is hIDE going?
07:10:41 <Lemmih> Slowly, haven't had a lot of spare time lately.
07:12:49 <yip> do you still think that all of your ideas are technically doable?
07:13:24 <Lemmih> What ideas?
07:13:31 <yip> for the IDE
07:13:41 <yip> all that plugin loading stuff you were having trouble with
07:13:44 <yip> and everything else
07:14:57 <Lemmih> Oh, yeah I do. They are even implemented. The only problem is that my ideas aren't very good (:
07:18:30 <sjanssen> why don't we have instance (Storable a) => Storable (Maybe a)?
07:19:27 <norpan> for the same reason we don'
07:19:34 <norpan> t have it for any complex data structure
07:19:57 <norpan> how would you store Maybe Int64 for instance?
07:20:26 <sjanssen> @hoogle Int64
07:20:27 <lambdabot> Data.Int.Int64 :: data Int64
07:20:50 <norpan> it doesn't have a bit representation
07:21:00 <sjanssen> sure it does
07:21:12 <SamB> it isn't hard to come up with one...
07:21:20 <sjanssen> the alignment for Int64 is 4
07:21:25 <norpan> but the point is that it's not obvious which one is the right one
07:21:42 <norpan> Storable is used to marshal values, right?
07:21:51 <eivuokko> Storable requires types to have constant size
07:22:12 <dfeuer> This is reminding me a bit of my question of a while ago.
07:22:14 <sjanssen> eivuokko: yeah, and Maybe (SomeConstantThing) can have constant size
07:22:31 <norpan> sjanssen: you wan't something like binary read/write, which is not the same as Storable
07:22:38 <sjanssen> I think we ought to have a mechanism like this, so you could write unboxed arrays of tuples
07:23:01 <eivuokko> sjanssen, Sort of unobvious.  But sure, it could be done.
07:23:23 <vincenz> eivuokko: thanks for the link
07:23:32 <norpan> (Storable a, Storable b) => Storable (a,b) sort of makes sense though
07:23:33 <sjanssen> with an Either instance we could model C unions in Haskell too
07:23:54 <norpan> problem with C unions is that they are overlapping
07:23:58 <dfeuer> The problem:  persistent data structures are a natural way to represent advanced undo/redo systems in editors, but the moment you want to save the undo tree in a file, you're screwed.
07:24:09 <vincenz> anyone here know SSA?
07:24:17 <sjanssen> the only problem is that we'd need slightly tricky logic in size and alignment
07:24:44 <norpan> you'd have to know which one of the union values is valid
07:25:15 <sjanssen> dfeuer: there are libraries to serialise things
07:25:16 <eivuokko> vincenz, email?  np.
07:25:36 <sjanssen> norpan: yeah, Either wouldn't work for C unions, but another type could
07:25:53 <dfeuer> sjanssen, do they maintain sharing?  That's the sticky point.
07:26:36 <norpan> sjanssen: problem is you somehow need to store if it was a or b for Either a b
07:26:41 <sjanssen> dfeuer: I think one of them does . . . can't remember though.  SerTH, maybe?
07:26:48 <norpan> which makes the binary representation non-obvious
07:26:52 * dfeuer goes to look up.
07:27:36 <norpan> mapping (,,,) to c structs could be done inside Storable though
07:27:46 <norpan> given that alignment etc is known
07:27:59 <sjanssen> norpan: just a byte that says whether it's left or right.  The byte has to be padded for the alignment requirements of both types
07:28:42 <norpan> sjanssen: well yes you can think up a number of ways, but my point is that there is no obivious *right* way
07:28:45 <Philippa> dfeuer: if you're really worried, serialise the deltas (that is, the commands that caused the changes)
07:28:56 <sjanssen> you're right that much of this isn't applicable to marshaling to/from C -- but you could use Data.Array.Storable as a more general unboxed array
07:29:53 <norpan> well you are welcome to define your own instances of Storable of course
07:30:02 <norpan> but there shouldn't be any by default for those types
07:30:23 <sjanssen> ah yes, dirtying up the namespace might be bad
07:30:58 <norpan> tuples could be there by default, but even that is doubtful :)
07:31:47 <eivuokko> Can't have tuples because it's not clear if the fields are aligned or not.
07:32:02 <norpan> eivuokko: it's clear if your model is a c struct
07:32:16 <norpan> that abi is well-defined
07:32:17 <Phyx-> hello, evening, i was wondering, anyway to get the current date in haskell?
07:32:40 <sjanssen> what use would be an instance that doesn't align your data?
07:32:52 <dfeuer> Philippa, storing the deltas is certainly a reasonable way to do it, but it seems, to me at least, an unfortunate complication.
07:33:36 <eivuokko> norpan, Yeah, ok.  But still there would be people that complain.
07:33:43 <Philippa> it is a little, although one with additional benefits - suppose some of the operations were IO-based and you wanted to redo the IO when you redo the operation after changes?
07:33:47 <norpan> in fact, including tuples would be a good thing as the alignment it slightly involved
07:33:57 <sjanssen> eivuokko: they have the option of not using the instance
07:34:03 <norpan> eivuokko: there are always people who complain :)
07:34:08 <norpan> me for instance
07:34:14 <dfeuer> Philippa, yah... I guess so.
07:34:20 <Phyx-> nvm, found it
07:34:22 <norpan> problem with instances is that you don't have the option of not using them
07:34:25 <sjanssen> I bet nobody uses Storable with tuples right now, how could it harm them if we had it?
07:35:30 <sjanssen> norpan: you can use a newtype of the type instead
07:35:38 <roconnor> is there a ghc --makeclean?
07:36:01 <yip> argh c++ is horibble! :(
07:36:15 <Lemmih> roconnor: That should delete .hi and .o files?
07:36:17 <vincenz> yip: duh?
07:36:37 <Philippa> dfeuer: in most apps you probably at least want a name for what it is you'd be redoing/undoing, so you've already got the mechanism
07:36:53 <yip> vincenz: haskell isn't much better though :P
07:37:14 <dfeuer> Philippa, I guess so...
07:37:37 <norpan> send a suggestion to ffi@haskell.org to add tuples as Storable and see what the reaction is
07:38:17 <norpan> http://www.haskell.org//pipermail/ffi/2006-June/001844.html
07:38:19 <lambdabot> Title: "struct and tuples"
07:39:08 <norpan> the answer to the reaction question is "no reaction at all" :)
07:39:16 <sjanssen> norpan: wonder if anyone is actually subscribed to that list, seems rather slow
07:39:31 <roconnor> Lemmih: exactly, Well, the problem is that I change compiler options, so I want to recompile everything
07:39:43 <eivuokko> Additions to ffi should probably go into haskell-prime at this point.
07:39:48 <roconnor> so a force compile options would be good enough.
07:39:52 <Lemmih> roconnor: ghc --make -no-recomp
07:40:22 <roconnor> Lemmih: brilliant!
07:40:29 <Lemmih> (-no-recomp will turn off recompilation checking)
07:40:30 <roconnor> @karma+ Lemmih
07:40:31 <lambdabot> Lemmih's karma raised to 18.
07:40:31 <isaacd> short for no recompilation checking, not no recompilation, confusingly
07:40:46 <roconnor> how am I going to remember this
07:41:09 <roconnor> isaacd: it's a terrible name
07:41:14 <roconnor> -recomp would be much better.
07:42:07 <vincenz> Lemmih: heh there's ssomething which I find a slight bug with ghc
07:42:07 <norpan> sjanssen: and deriving Storable for single constructor data types
07:42:38 <vincenz> lemmih: assume: ghc --make Foo.hs    and then ghc --make -main-is Foo Foo.hs (cacuse you forgot inside it's not called Main) then you get linker errors
07:42:45 <vincenz> it should do a recompilation of the main module
07:45:19 <norpan> as the rules for alignment for structs are rather complex i now definitely think it should be included
07:47:14 <sjanssen> norpan: it'd also be neat if one could pass a struct to C on the stack, something you can't do with FFI now
07:48:20 <norpan> yes, foreign import/export uses Storable info, right?
07:48:27 <Lemmih> vincenz: File a report and I'll look into it.
07:48:41 <eivuokko> norpan, I don't think it does.
07:48:57 <norpan> well, it has to know it anyway :)
07:49:01 <eivuokko> norpan, It's builtin compiler.  iirc it also bypasses newtypes.
07:50:01 <sjanssen> so passing structs on the stack is a separate matter.  It'd still be nice to have
07:51:16 <eivuokko> Does normal c calling conventions allow copying structs into stack, and not use reference?
07:51:26 <norpan> yes
07:52:10 <norpan> you can allocate structs on the stack too
07:55:09 <sjanssen> is the FFI spec being rolled into Haskell-prime, or will they remain separate?
07:55:38 <norpan> i think separate
07:55:48 <norpan> or at least optional
07:56:05 <eivuokko> http://hackage.haskell.org/trac/haskell-prime/ticket/35
07:56:06 <lambdabot> Title: "#35 (add ForeignFunctionInterface) - Haskell Prime - Trac"
08:01:48 <vincenz> Lemmih: where and hw?
08:05:24 <sjanssen> roconnor: I spent some time with the SHA1 code yesterday, and it now runs in constant space
08:06:04 <Lemmih> vincenz: http://hackage.haskell.org/trac/ghc/
08:06:06 <lambdabot> Title: "GHC - Trac"
08:07:37 <kzm> Whee!  A debian packager is I.
08:07:57 * kzm thanks Igloo.
08:08:56 <norpan> i'm now convinced that the reason tuples are not a member of Storable is that the instance is too hard to define :)
08:09:16 <sjanssen> norpan: how tricky are the alignment rules?
08:10:07 <norpan> they vary from arch to arch and between windows and linux
08:11:12 <sjanssen> so we'd need new instances for each arch/OS
08:11:49 <norpan> well, the compiler knows which arch/OS it's compiling on of course
08:12:07 <norpan> double alignment is different too, 4 on linux and 8 on windows
08:12:23 <sjanssen> sure, it's just some CPP or a built in thing
08:12:56 <roconnor> sjanssen: wee
08:13:03 <roconnor> where do I get it?
08:13:23 <roconnor> I want to add SHA-2 support
08:13:35 <sjanssen> norpan: different alignments for the things in the tuple aren't a big deal -- we can solve that by calling alignment for each thing
08:13:40 <roconnor> Shaskell is even worse (althought more obviously correct)
08:13:49 <norpan> sjanssen: yes i know
08:13:55 <sjanssen> roconnor: shall I darcs send it to you?
08:14:20 <sjanssen> I'll darcs send it to the maintainer too, but you might be impatient
08:14:28 <roconnor> Sound good
08:14:53 <sjanssen> pm me your email address?
08:16:54 <norpan> sjanssen: http://www.caldera.com/developers/gabi/latest/ch4.intro.html#data_representation is for linux (system v abi)
08:16:55 <lambdabot> Title: "Chapter 4: Object Files"
08:18:34 <sjanssen> seems fairly straightforward, unless I'm missing something
08:18:45 <norpan> yes, but still complicated :)
08:20:20 <sjanssen> seems like it's a greedy approach -- you always set your alignment to the first thing, adding padding as you go along
08:21:48 <sjanssen> no, that isn't right
08:24:11 <dmhouse> Good afternoon *.
08:24:34 * offby1 glances around calmly. 
08:24:51 <pejo>  
08:25:35 <norpan> align x = head (filter (>=x) (map (2^) [0..]))
08:25:36 <ProfTeggy> Ben Offby1 Kenobi?
08:26:35 <sjanssen> "Help us Offby1 Kenobi, you're our only hope" doesn't have quite the same ring to it
08:26:47 <dmhouse> offby1: Woah, you confused me there. I thought I was in #emacs.
08:26:57 <dmhouse> pejo, well said.
08:27:58 <sjanssen> norpan: where x is the sum of the sizes?
08:29:07 <roconnor> @pl align x = head (filter (>=x) (map (2^) [0..]))
08:29:07 <lambdabot> align = head . flip filter (map (2 ^) [0..]) . flip (>=)
08:29:16 <offby1> dmhouse: geez :-)
08:29:25 <dmhouse> sjanssen, norpan: what are you writing?
08:29:36 <sjanssen> alignment needs to be the max of the alignments, I think
08:29:38 * offby1 is, after months of procrastination, sitting down with the Haskell tutorial and trying to figure it all out
08:29:44 <int-e> > take 5 $ iterate (*2) 1
08:29:46 <lambdabot>  [1,2,4,8,16]
08:29:48 <sjanssen> dmhouse: norpan and I are contemplating an instance of Storable for tuples
08:29:58 <dmhouse> offby1: bravo! :)
08:36:26 <dmhouse> sjanssen: Eww. Low-level.
08:37:01 <dmhouse> :)
08:40:24 <dmhouse> sjanssen: By the way, how's your SoC project coming along?
08:40:45 <sjanssen> dmhouse: pretty good
08:41:02 <ihope_> Storable?
08:41:15 <ihope_> @index Storable
08:41:16 <lambdabot> Foreign.Storable, Foreign
08:41:18 <dmhouse> @docs Foreign.Storable
08:41:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
08:41:41 <sjanssen> ihope_: useful for marshaling to/from C
08:42:54 <dmhouse> In terms of Data.Traversable, is mapM just traverse specialised to monads>
08:42:58 <dmhouse> s/>/?/
08:45:17 <int-e> @index WrapMonad
08:45:17 <lambdabot> bzzt
08:45:20 <sjanssen> lisppaste2: url
08:45:20 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:46:09 <int-e> oh, that must be Data.Applicative stuff. mapM f = unwrapMonad . traverse (WrapMonad . f) is the default implementation in the Traversable class.
08:46:36 <int-e> Control.Applicative of course
08:47:20 <dmhouse> So... yes?
08:47:41 <dmhouse> I assume WrapMonad and unwrapMonad is just newtype cruft.
08:47:57 <lisppaste2> sjanssen pasted "alignment" at http://paste.lisp.org/display/22210
08:48:06 <sjanssen> norpan: what do you think of that?
08:49:40 <ihope_> C has long longs?
08:50:04 <sjanssen> ihope_: yep
08:50:08 <dmhouse> Hmm, Data.Sequence is introduced with 'General purpose finite sequences.'.
08:50:13 <ihope_> Hmm...
08:50:30 <dmhouse> But how about 'infty = () <| infty'? How is that not infinite?
08:50:41 <dmhouse> Perhaps the take/drop etc. are strict...
08:51:47 <lispy> @hoogle (<|)
08:51:48 <lambdabot> Did you mean: (<|)
08:51:48 <lambdabot> Prelude.undefined :: a
08:51:48 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:51:49 <sjanssen> dmhouse: try "let infty = () <| infty in viewl infty"
08:52:02 <lispy> lambdabot: yes, i did mean (<|)
08:52:23 <dmhouse> lispy: Data.Sequence
08:52:24 <sjanssen> @hoogle <|
08:52:25 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<|?>) :: PermParser tok st (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
08:52:25 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<||>) :: PermParser tok st (a -> b) -> GenParser tok st a -> PermParser tok st b
08:52:25 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<|>) :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a
08:52:42 <dmhouse> > let infty = () <| infty in viewl infty
08:52:48 <lambdabot>  Not in scope: `viewl'
08:53:05 <dmhouse> > let infty = () Data.Sequence.<| infty in Data.Sequence.viewl infty
08:53:07 <lambdabot>  Not in scope: `Data.Sequence.viewl'
08:53:15 <dmhouse> sjanssen: sadly my GHC isn't trunk.
08:53:38 <sjanssen> dmhouse: well, basically it doesn't terminate or yield anything
08:53:48 <dmhouse> sjanssen: is it strict by any chance? :) Or strict in the length of the sequence, more accurately. (As [1..] /= _|_, but length [1..] does)
08:54:25 <sjanssen> Data.Sequence stores the length of parts of the tree in strict fields, so that's your problem
08:55:25 <dmhouse> Hmph.
08:55:26 <dmhouse> data Maybe2 a b = Nothing2 | Just2 a b
08:55:31 <dmhouse> That seems like an odd thing to define.
08:55:46 * dmhouse would have thought that tuples would do just fine.
08:56:33 <sjanssen> from the source of Data.Sequence?
08:57:00 <dmhouse> Yeah.
09:01:30 * dmhouse wonders why the FingerTree datatype is just bunged in Data.Sequence and not stuck in a seperate module.
09:05:58 <sjanssen> dmhouse: strictness and no polymorphism should make it faster
09:07:15 <sjanssen> note the UNPACK pragmas in data definitions
09:07:31 <dmhouse> I suppose so.
09:17:02 <dmhouse> You've got to love theoretical computer science nomenclature. In the middle of a serious and quite mathematical paper, 'Moreover, the banana split theorem [4], ...'
09:17:41 <offby1> <3
09:26:03 <vincenz> hi
09:27:22 <vincenz> @seen bringer
09:27:23 <lambdabot> I haven't seen bringer.
09:27:23 <vincenz> @seen bringert
09:27:25 <lambdabot> I saw bringert leaving #haskell.se and #haskell 7 hours, 52 minutes and 53 seconds ago, and .
09:27:34 <vincenz> @localtime bringert
09:27:45 <sieni> dmhouse: in a mathematical logic monography there was a muffin recipe just before a demanding proof so that people can drink coffee and eat muffins while trying to digest the proof
09:28:12 <dmhouse> Hah, nice :)
09:28:25 <monochrom> fun
09:28:40 <monochrom> Perhaps I should so that in my thesis!
09:29:12 <dmhouse> So then. How are tuples products and Either sums?
09:30:50 <sieni> dmhouse: well, in the mathematical sense
09:31:48 <sieni> if you have two finite sets A and B, then the set of pairs (a,b) (which is called the Cartesian product of A and B) has cardinality A * B.
09:32:00 <sieni> Similarly for disjoint union
09:32:26 <dmhouse> Cardinality |A| * |B|, I assume you mean.
09:32:35 <sieni> whatever
09:32:41 <dmhouse> Ah, so a set-theoretic sum is a disjoin union?
09:33:16 <dmhouse> I suppose that if you view a type as a set of its possible values, then it makes sense to call tuples Carteian products.
09:34:05 <dmhouse> And yeah, I see how Either is a union over two types as well. Fun,
09:34:11 <dmhouse> s/,$/./
09:34:30 <sieni> dmhouse: maybe :-) for infinite sets (at least assuming the axiom of choice) it doesn't matter
09:34:54 <dmhouse> sieni: Is this refering to my || correction?
09:35:00 <mcmackerel> ugh, it's annoying how texts on monads seem to treat "computations" and "results from computations" interchangeably. at least when trying to grok the concept.
09:35:24 <monochrom> Really?
09:35:28 <dmhouse> mcmackerel: How are they different?
09:35:37 <sieni> since if one of two sets A and B is infinite, then the cardinality of their union regardless of whether it's disjoint or if the other set is contained in the other is just max{|A|, |B|}
09:35:50 <dmhouse> mcmackerel: If we ignore petty things like CPU time.
09:35:58 <sieni> gotta go
09:36:08 <mcmackerel> dmhouse: a computation for me is the process of computing something. the results is that which is computed.
09:36:41 <dmhouse> mcmackerel: Ah. Well defining 'computation = executing a function call' isn't very interesting when we're trying to talk at a high level
09:36:57 <dmhouse> Because talking about how you're executing a function is down to the compiler.
09:37:06 <dmhouse> So computation = fully applied function call, really.
09:37:38 <dmhouse> Did that make sense? I have a feeling I was too brief again.
09:37:55 <mcmackerel> dmhouse: i would define it more like, "the process that arrives at the computed values". there's always a process, regardless of how much resources it takes.
09:38:20 <mcmackerel> i see what they mean, but it isn't a very intuitive way to think about it. at least not for me.
09:38:36 <dmhouse> Well defining it your way would be useful if we were writing a compiler.
09:38:46 <dmhouse> Because we would be interested in memory usage, CPU and so on.
09:39:18 <mcmackerel> i'm not talking about strict definitions though, just about explaining concepts in an intuitive way
09:39:56 <dmhouse> Fair enough. It's just a convention.
09:40:15 <mcmackerel> it's like saying "value" instead of "function application". it makes sense, but it's not very intuitive.
09:41:20 <dmhouse> Well, if we used different terminology people might think the concepts were distinct.
09:41:42 <dmhouse> But everywhere you can use "abc" you can use f 5.
09:44:02 <dmhouse> What's a 'functorial map'?
09:44:33 <dmhouse> "When m is specialized to the identity idiom, traversal reduces to the functorial map over lists."
09:44:44 <mcmackerel> dmhouse: synonyms might make for less confusion. i'd rather see "data" or "value" than "computation" for what's inside a monadic structure being passed around.
09:45:11 <Philippa> dmhouse: you can have entirely valid monads that *don't build the results in any shape or form*
09:45:23 <dmhouse> mcmackerel: Ah, see this is where the two terms diverge.
09:45:26 <Philippa> an abstract syntax tree with constructors for bind and return is/can be a valid monad
09:46:04 <Philippa> I use "computation" for the value of monadic type - the program rather than (necessarily) its result, in effect
09:46:05 <dmhouse> mcmackerel: For example, the Maybe monad represents *computations that might fail*. Trying to slot 'data' or 'value' in there doesn't work.
09:46:34 <Philippa> sure it does, there just might not be one
09:46:46 <dmhouse> A value that might fail? :|
09:47:04 <monochrom> A value that might be absent. :)
09:47:06 <Philippa> depends entirely on how you choose to yank if out of the Maybe
09:47:18 <dmhouse> monochrom: Precisely, the terms aren't interchangeable.
09:47:31 <Philippa> Maybe and [] are odd monads anyway, in that normally we don't expose the innards of a monadic type
09:47:53 <mcmackerel> i'd put it like, "the maybe monad represents the result of a computation that might fail". a lot clearer to me, and probably to others who aren't used to the terminology.
09:47:59 <dmhouse> Philippa: right. I've always felt that Maybe and [] stood alone in the monad world.
09:48:10 <Philippa> mcmackerel: it doesn't though, the monad is the type
09:48:32 <Philippa> and it only represents the /result/ because you can see the innards
09:48:33 <mcmackerel> Philippa: ugh, could you elaborate?
09:48:37 <dmhouse> mcmackerel: Perhaps 'Values whose type are wrapped in a maybe type constructor represent the result of a compuation that might fail'.
09:48:47 <dmhouse> mcmackerel: Technically, the type constructor, Maybe, is the monad.
09:48:51 <Philippa> mcmackerel: IO is a monad. IO a is an action/computation. a is the result, but you can't get at it - only pass it around.
09:49:42 <mcmackerel> dmhouse: isn't the binding and unit operations part of the monad as well?
09:49:43 <Philippa> with Maybe, you might be able to get at the a through means other than a "runComputation" style function, and that's the confusing bit
09:50:00 <Philippa> yes, dmhouse's effectively treating the instance as part of the type constructor
09:50:03 <dmhouse> mcmackerel: Yes, I suppose so.
09:50:30 <dmhouse> The instance declaration + type constructor form the monad.
09:50:50 <dmhouse> There's probably some deep category theoretic link in there :)
09:51:26 <dmhouse> (E.g. with Functor, fmap is the part of the category-theoretic functor that acts on the morphisms, and the type constructor acts on the objects.)
09:52:00 <Philippa> yes, there is - it's all equivalent to a CT monad with the category representing Haskell's semantics as a base
09:52:24 <dmhouse> (They're functors from the category of Haskell types, 'Hask', to the category of Haskell types wrapped in the type constructor. E.g. [] is a functor from Hask to the category of list types.)
09:53:38 <Philippa> oversimplification...
09:53:46 <dmhouse> Philippa: re. not exposing the innards of monad -- can't you, say, pattern match on Reader?
09:53:59 <dmhouse> Or are the datatypes abstract?
09:54:04 <Philippa> usually, yes
09:54:13 <dmhouse> Oversimplification?
09:54:27 <Philippa> oh, wait, you were talking about functors not monads, my bad
09:54:31 <Philippa> [] is, of course, also a functor :-)
09:54:36 <Philippa> (and a monad)
09:54:45 <dmhouse> Right.
09:55:03 <dmhouse> Monads, as I recall, are quite complex categorically/
09:55:04 <mcmackerel> as i see it, the monad contains the result from the computation as well as meta-data needed by the bind function for the specific functionality of the monad. is that a bad way to see it? is it wrong the call the object being passed around a monad?
09:55:24 <dmhouse> mcmackerel: Yes, probably.
09:55:33 <dmhouse> Maybe is a monad. [] is a monad.
09:55:35 <mcmackerel> dmhouse: to both questions? :)
09:55:37 <dmhouse> Just 4 is not a monad.
09:55:44 <dmhouse> [1..5] is not a monad.
09:56:22 <dmhouse> do { x <- ask; return (x * 2) } is not a monad.
09:56:26 <dmhouse> They're monadic computations.
09:56:41 <dmhouse> The first is a computation 'in Maybe', the second one 'in []', and the last 'in Reader'.
09:57:04 <Philippa> you might also see computations "in some monad with instances for...", which turns out to be a surprisingly powerful technique
09:57:22 <mcmackerel> is  Just 5 >>= \x -> Just x  a monadic computation in Maybe?
09:57:30 <Philippa> yes
09:57:31 <dmhouse> Yeah.
09:57:42 <mcmackerel> ok
09:57:59 <dmhouse> Of course, that reduces: Just 5 >>= Just    ===>     Just 5 >>= return     ===>     Just 5 :)
09:58:01 <Philippa> or sometimes "a Maybe computation" (cf "IO computation", "IO action" - action being pretty much IO-specific 'cos other monads don't "do something")
09:58:18 <mcmackerel> dmhouse: which is a monadic computation as well?
09:58:24 <dmhouse> Right, 'action' is just 'computation', but normally only used when you're talking about the IO monad.
09:58:33 <dmhouse> mcmackerel: In a weird kind of way, yes.
09:58:41 <Philippa> mcmackerel: yes, although it wouldn't normally be pointed out as such
09:58:49 <dmhouse> It represents the results of a computation that might have failed, but in fact didn't, and had a result of 5.
09:59:02 <Philippa> at least, it does if you choose to squint at it that way
09:59:17 <Philippa> the part about failure is all human interpretation
09:59:43 <Philippa> ("no value" might be a perfectly normal, non-failing result, for example)
09:59:44 <dmhouse> Sure. The part about failure is what Maybe useful in real life :)
10:00:25 <dmhouse> The Maybe monad itself is just a bunch of function definitions and axioms. Cold mathematics. But it turns out it's useful for modelling computations that might fail.
10:02:21 <mcmackerel> yes, i think understand the principle. i'm just trying to get the terminology down.
10:02:26 <mcmackerel> +i
10:02:56 <dmhouse> Okay then.
10:03:09 <dmhouse> Monad are a type constructor and function bodies for return and >>=.
10:03:33 <dmhouse> Values whose type are wrapped in this type constructor (for example, Maybe Int) represent computations in that monad.
10:03:44 <dmhouse> Each monad represents a different type of computation.
10:04:48 <dmhouse> How's that sound, Philippa? mcmackerel?
10:05:03 * SamB wonders if c++ has an operator>>=
10:05:14 <Philippa> FCVO "type". I mentioned ASTs being valid monads before
10:05:30 <Philippa> anyway, gotta go
10:05:52 <dmhouse> FCVO = For Come Value Of (sic)?
10:05:56 <Philippa> Certain
10:06:00 <dmhouse> Ah.
10:06:21 <SamB> For a Certain Value Of or For Certain Values Of?
10:06:22 <Philippa> I know I pun badly sometimes, but that'd be bad even by my standards (but for there being nothing to associate it with)
10:06:23 <pesco> dmhouse: Have you checked out my Tixt code?
10:06:34 <dmhouse> pesco: Your what now?
10:06:40 <Philippa> usually values, although could be one
10:06:55 <dmhouse> pesco: Oh, Markdown.
10:06:56 <Philippa> anyway, really gotta go
10:06:58 <dmhouse> Hehe, sorry. :)
10:07:06 <dmhouse> pesco: No, I haven't had the time.
10:07:11 <dmhouse> pesco: Is it good? :)
10:07:48 <pesco> Yeah, it is. ;)
10:08:01 <pesco> dmhouse: No worries, I was just wandering, because it has been in some flux.
10:09:38 <mcmackerel> dmhouse: what would you call the specific instance of the  M Whatever  that is the result of the functions doing the actual work (excuse me for using terminology i'm having a hard time let go of :) ?
10:09:46 <JKnecht> samb: yes it does.
10:09:57 <pesco> dmhouse: Check out the "maiden voyage": http://khjk.org/~sm/code/advopost/post2.txt is the source of my latest blog post. Or change the .txt in that URL to .html for the XHTML output.
10:11:09 <dmhouse> mcmackerel: For example?
10:11:25 <dmhouse> Perhaps provide an actual function to illustrate your point.
10:12:09 <dmhouse> pesco: Lovely typography on that HTML page"
10:12:12 <dmhouse> s/"/!/
10:13:00 <dmhouse> mcmackerel: I'm sorry, I think I'm going to have to dash as well. 
10:13:10 <mcmackerel> dmhouse: what would you call what the bind operator recieves as its first argument and yields as the final result?
10:14:05 <dmhouse> It perhaps depends on the context, but you can't go far wrong with 'computation'.
10:14:58 <dmhouse> Anyway, g'night all.
10:24:06 <mcmackerel> M  is the monad,  M a  is the type of (result of) a computation in the monad involing a, instances of  M a  is specific computations in the monad involving the type a
10:24:09 <mcmackerel> does that look right?
10:24:47 <mcmackerel> s/a/type a/
10:33:48 <moonfish> Anyone know of a library for manipulating lists of intervals, e.g. something with an 'insert' function s.t. insert [(1,3),(5,7),(8,9)] (2,6) = [(1,7),(8,9)], etc.
10:34:48 <moonfish> Obviously this isn't hard to write, but I figured I should ask first whether it's been done already.
10:36:20 <mcmackerel> shouldn't that be .. = [(1,9)]?
10:39:12 <moonfish> mcmackerel: depends on whether you consider the number type continuous, and whether the intervals are inclusive/exclusive/etc.
10:39:42 <mcmackerel> ah, now i see
10:40:59 <moonfish> I also need the inverse operation, i.e. remove an interval from a list of intervals.
10:58:08 <greenrd> anyone want to look at some incomprehensible code I wrote?
10:59:00 <Cale> greenrd: what's it do?
10:59:09 <Cale> (or what's the trouble?)
10:59:16 <greenrd> got this compilation error: http://pastebin.ca/81611
10:59:28 <greenrd> is it something to do with types escaping?
10:59:30 <greenrd> here's the code:
10:59:39 <greenrd> http://pastebin.ca/raw/81608
10:59:54 <greenrd> (preprocessed for easy compilation)
11:00:05 <johnnowak> my gods, it's hideous!
11:00:39 <monochrom> It is incomprehensible as promised :)
11:01:34 <greenrd> Well yes, as it's preprocessed, the literate haskell explanations are missing
11:03:00 <johnnowak> can i see the original? 
11:04:08 <greenrd> well, the original is lyx, which generates latex, which is processed by lhs2TeX and hscpp into what you see there
11:04:44 <greenrd> oops, cpphs, not hscpp
11:05:02 <greenrd> I can post the latex
11:08:40 <greenrd> http://pastebin.ca/81620
11:08:45 <johnnowak> thanks
11:09:27 <Cale> greenrd: are you certain that gab is an appropriate type for uf to be applied to it?
11:10:17 <Cale> I'd normally be able to tell, but this would involve unravelling the insane number of type declarations you have going there :)
11:11:47 <Cale> what's the inferred type for foo?
11:11:48 <mcmackerel> a@whatever  just makes a a shorthand for whatever, right?
11:11:57 <Cale> yes
11:12:01 <mcmackerel> thanks
11:13:01 <greenrd> Cale: How would I find out what ghc infers its type to be?
11:13:19 <Cale> delete the type signature, load the module up in ghci and type :t foo
11:13:37 <greenrd> ahh
11:15:02 <Cale> I find the fact that you managed to write this code without knowing that somewhat conceptually challenging :)
11:15:10 <greenrd> haha
11:15:59 <vincenz> greenrd: what kind of code is that?
11:16:17 <greenrd> I had done that before, just temporarily forgot about it
11:16:31 <greenrd> Cale: turns out I'd forgotten to do something, so it doesn't type check at all - thanks
11:16:32 <vincenz> what's with all the {-# line  stuff
11:16:52 <Cale> vincenz: it's been run through the preprocessor
11:16:54 <greenrd> vincenz: it's the output of gcc -E
11:16:54 <eivuokko> Preprocessors leave those so that error messages point to the right file and line
11:17:07 <vincenz> ah
11:17:24 <greenrd> vincenz: I posted it so that people could compile it without needing to have my include file and the preprocessing utilities I'm using
11:17:25 <vincenz> funky that it leaves it in a format that's comments for ghc
11:17:44 <vincenz> afaik gcc -E left it as # xx
11:17:55 <eivuokko> ghc understands that too, I think.
12:00:49 <fasta> dons,dcoutts: how did you typeset http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz?
12:03:03 <mux> ugh, merging a patch into a code base that has seen months of changes since the patch was created is unfun.
12:03:24 <mux> not that it's a surprise, but god how I hate this
12:13:35 <lispy> mux: which version control system?
12:15:00 <mcmackerel> is there any problem with likening monads to a kind of design pattern, abstracting out acting on computations from the actual computations?
12:15:41 <lispy> mcmackerel: can you elaborate?
12:15:57 <mux> lispy: you know, the worse one.
12:16:33 <mux> but in that case using a decent VCS wouldn't have helped much.
12:17:34 <lispy> mux: you might be surprised.  Darcs for example doesn't need version numbers to figure out how to apply patches, and then for the lines that conflict you just use an external tool
12:17:54 <mux> I wouldn't be surprised, I've used many VCS extensively
12:17:58 <lispy> some of the conflict/merge tools these days are quite handy
12:18:05 <int-e> How does that help when all you have are conflicts?
12:18:07 <mux> the problem here is hard, unresolvable conflicts
12:18:29 <mcmackerel> lispy: in this case it could be seen as a design pattern that solves the problem of having to pass all the context to a function explicitly in pure functional languages
12:18:50 <mux> unless darcs growed some pretty serious AI while I wasn't looking
12:18:59 <jrmole> mcmackerel, if by "acting on computations" you mean "creating computations from pure values, and combining several computations into one", then that's exactly what monads are
12:19:12 <mux> which I kinda doubt :-)
12:19:13 <lispy> mux: configure --enable-read-mind ;)
12:20:09 <mux> a recipe for disaster :-)
12:20:38 <mux> darcs: "Look bro, after studying your code some more, I came to the conclusion you don't need this at all."
12:20:51 <jrmole> any program that could read minds would just evolve into a porn downloader
12:20:51 <mcmackerel> jrmole: what do you mean by a pure value?
12:21:08 <jrmole> so, what i actually mean is any value
12:21:25 <lispy> jrmole: are you suggesting that firefox can read my mind? ;)
12:21:29 <jrmole> but the point is, sometimes you want a computation which doesn't actually do anything other than giving you some value back
12:22:31 <lispy> @quote+ <jrmole> any program that could read minds would just evolve into a porn downloader
12:22:32 <lambdabot> <jrmole> any program that could read minds would just evolve into a porn downloader hasn't said anything memorable
12:22:36 <mux> if firefox can read my mind, I'm a damn masochist
12:22:54 <lispy> @quote jrmole
12:22:54 <lambdabot> jrmole hasn't said anything memorable
12:22:57 <jrmole> :(
12:23:02 <lispy> @quote+ jrmole any program that could read minds would just evolve into a porn downloader
12:23:03 <lambdabot> jrmole any program that could read minds would just evolve into a porn downloader hasn't said anything memorable
12:23:07 <lispy> @quote jrmole
12:23:07 <lambdabot> jrmole hasn't said anything memorable
12:23:11 <lispy> :(
12:23:15 <Cale> um, hmm
12:23:16 <jrmole> it doesn't like me
12:23:23 <Cale> @help quote
12:23:25 <lambdabot> quote <nick>
12:23:25 <lambdabot> remember <nick> <quote>
12:23:25 <lambdabot> Quote somebody, a random person, or save a memorable quote
12:23:29 <sjanssen> @remember jrmole any program that could read minds would just evolve into a porn downloader
12:23:29 <lambdabot> Done.
12:23:33 <sjanssen> @quote jrmole
12:23:33 <lambdabot>  any program that could read minds would just evolve into a porn downloader
12:23:47 <mux> I can see a bug :-).
12:23:48 <lispy> thanks
12:23:52 <sjanssen> it doesn't automatically prefix the nick?
12:24:02 <mux> we don't want no extra space!
12:24:13 <Cale> It adds the extra space explicitly
12:24:25 <lispy> mux: oh, that space is there to prevent certain exploits
12:24:33 <Cale> To make it slightly harder to get two lambdabots into a quoting loop
12:24:36 <mux> meh.
12:24:50 <lispy> also to avoid dcc exploits via TH
12:25:15 <jrmole> TH?
12:25:17 <mux> I can't see how there could be a bug if you make sure to output the leading ':' from the IRC protocol
12:25:23 <mux> but my memory about IRC is fuzzy.
12:25:24 <lispy> jrmole: template haskell
12:25:35 <Cale> What are these DCC exploits?
12:26:02 <lispy> Cale: i don't know exactly, but someone around here was getting lambdabot to execute irc commands andi think they used TH
12:26:09 <mux> it's true DCC works with CTCP which is just ugly stuff over PRIVMSG
12:26:21 <sjanssen> no TH involved, just clever code injection
12:27:00 <Cale> How do they abuse DCC specifically?
12:27:04 <vincenz> aha #haskell's favourite pasttime: hacking lambdabot
12:27:13 <Cale> Send someone a lot of DCC send requests?
12:27:18 <mcmackerel> jrmole: when i said "acting on computations", i meant acting on the values of the functions doing the actual hard work
12:28:01 <mux> the reminds me of the good old /invite somenick #%s%s%s%s
12:28:05 <Cale> mcmackerel: you can think of monads like that, but you'd only be getting part of the picture
12:28:07 <mux> s/the/this/
12:28:21 <vincenz> mux: what did that do?
12:28:21 <mcmackerel> Cale: what do i miss?
12:28:44 <mux> vincenz: it'd crash some (I don't remember which) IRC client that had printf format bugs
12:28:47 <lispy> mcmackerel: monad transformers?
12:28:47 <Cale> well, for one, http://www.haskell.org/haskellwiki/Monads_as_Containers
12:28:48 <vincenz> heh
12:28:51 <lambdabot> Title: "Monads as Containers - HaskellWiki"
12:29:01 <Cale> and yeah, the container perspective
12:29:02 <vincenz> anyways guys
12:29:05 <vincenz> I'm off
12:29:12 <Cale> Monad transformers is a good point too
12:29:14 <vincenz> got to cross the atlantic tomorrow
12:29:48 <jrmole> mux: /ctcp foo ping +++AT0ATDT1900FONESEX
12:30:00 <jrmole> where foo is your intended target
12:30:06 <Cale> jrmole: how is that supposed to work?
12:30:10 <jrmole> ah, vintage stupid irc tricks
12:30:19 <mux> modem strings over ctcp?
12:30:23 <mux> now that sounds evil
12:30:25 <greenrd> works on ancient insecure modems?
12:30:30 <int-e> yes. and ping sends it back
12:30:35 <Cale> You'd have to have a completely broken protocol stack
12:30:44 <jrmole> the only brokenness is in the modem itself
12:30:46 <vincenz> what Cale says
12:30:51 <mux> yeah, it sure requires several layers of horribly broken code
12:31:00 <jrmole> crappy knockoff modems that disregard the delay after +++
12:31:12 <jrmole> won't work on actual Hayes
12:31:50 <jrmole> also won't work with compressed PPP or anything fancy like that, of course
12:32:22 <lispy> it's like the startlogger/stoplogger crap
12:32:24 <Cale> Or on any connection since 1998, who uses phone modems anymore? ;)
12:32:24 <greenrd> back in 1997 someone asked me to stop using geek code blocks (which contained +++) in emails, because it kept disconnecting him when he downloaded one of my emails
12:33:18 <mux> internet was a much funnier place back in the days
12:33:25 <mux> now we only get to exploit some stupid php code
12:33:54 <lispy> ah, the eternal september...
12:34:09 <mux> mmmm, insecure TCP ISNs...
12:34:12 * mux drops a tear
12:34:59 <lispy> iirc dns still has some exploits right?
12:35:20 <lispy> like what about the thing where you can get the MPAA's dns server to cache the decss code
12:35:23 <mux> depends on what you call "dns" and what you mean by "still"
12:35:30 <vincenz> @tell dons How do you typeset your talk slides/?
12:35:32 <lambdabot> Consider it noted.
12:35:40 * vincenz now really leafs
12:35:50 <lispy> mux: and it seems like there is a way to 'poison' dns servers
12:35:56 <mux> dns cache poisoning
12:35:58 <lispy> vincenz: good luck on your flight
12:36:03 <vincenz> th
12:36:08 <vincenz> +x
12:36:49 <mux> lispy: this is only possible if the dns server is broken
12:37:21 <mux> or of course, if you have access to the authoritative dns server, but that can't be called an exploit then 
12:38:14 <mux> actually, this isn't really true
12:38:24 <mux> but if you're using DNSSEC, it is
12:38:48 <norpan> hello haskell
12:39:27 <mux> I mean, if you can somehow manage to have access to a gateway in between some authoritative DNS server and another that you want to poison, you can fool the target DNS answering prior to the real DNS server
12:39:31 <jrmole> hello norpan
12:40:20 <lispy> mux: hmm...i see
12:40:27 <lispy> mux: dns is a fricken mystery to me ;)
12:43:05 <norpan> mux: well, yes there is no authentication other than ip
12:44:44 <mux> yeah. they try to work around that by using IDs on packets and stuff
12:45:07 <mcmackerel> when monad texts talk about "computations", do they mean the computations represented by the  M a  instances (like outputing an value in the case of an IO monad), the computations of the functions doing the actual work (calculating the value to be output), or both?
12:45:16 <mcmackerel> *a
12:45:29 <norpan> it probably refers to the monad value being a computation
12:46:02 <mcmackerel> that comes from one of the functions doing the hard work in the chain?
12:46:06 <Philippa_> almost always
12:46:11 <Philippa_> you don't know what the chain does or how it works
12:46:14 * mux ponders writing his own monad tutorial
12:46:20 <mux> "Monads are hard, let's go shopping!"
12:46:26 <Philippa_> for all you know, the IO monad could just be an abstract syntax tree the RTS interprets
12:46:29 <Cale> getClockTime >>= \(TOD n _) -> putStrLn ("September " ++ (show $ (n - 746769600) `div` (60 * 60 * 24)) ++ ", 1993")
12:46:53 <jrmole> mcmackerel: generally "computation in monad m returning type a" is a value of type m a
12:47:09 <jrmole> and the word "computation" is used to distinguish these from functions
12:47:28 <mcmackerel> Philippa_: nope, i realize that. but you can assume at least some computation, right?
12:47:40 <Philippa_> only once you get a value back out
12:47:46 <jrmole> although something of type a -> m b will also be called a "computation"... depending on your viewpoint, it's either a computation with an argument or a function that returns a computation
12:48:00 <Philippa_> I'm not just being arsey when I say that either
12:48:27 <Philippa_> jrmole: same situation as a -> b -> c being a function with two parms, pretty much
12:49:03 <jrmole> yeah... just as functions with multiple arguments are curried, you can think of a value of type IO a as being a kind of closure which waits, not for an argument, but just for the signal to do its thing
12:49:16 <jrmole> like delaying things in scheme
12:49:29 <mcmackerel> could you s/computation/evaluation of function doing actual hard work/ and have it still make sense? i hope "actual hard work" is clear enough..
12:49:42 <jrmole> i don't think it is
12:49:53 <Cale> A function A -> B is essentially what it is in mathematics, a set of pairs of values of A and B, such that for each element a of A, there is exactly one pair (a,b).
12:50:21 <jrmole> there are two types of evaluation at work here... the application of a function f to argument a, represented by (f a), and the "execution" of an IO action
12:50:22 <Cale> At least, it can be thought of in that way.
12:50:34 <mcmackerel> in a chain computing fibonnaci numbers and outputing them via the IO monad, the functions doing the calculation of the fib numbers would be the functions doing "actual hard work"
12:50:54 <Cale> So we never call something of type (IO a) a function.
12:51:12 <jrmole> (for IO this actually matters, because it's built in.  for other monads the "execution" is in turn defined in terms of pure functional programming by the definitions of return / (>>=))
12:51:43 <mcmackerel> jrmole: i was thinking of the application of the function f in your case
12:51:52 <jrmole> and f :: a -> IO b is a function, but applying (f x) doesn't "execute" the IO action, it just returns it
12:52:05 <jrmole> returns a description of how to do some IO and result in a value of type b, that is
12:52:22 <Philippa_> mcmackerel: all actual hard work is actually driven by IO, there'd be no need to evaluate anything otherwise...
12:53:02 <mcmackerel> Philippa_: who said it had to do something actually useful? :)
12:53:04 <jrmole> function application always works one way, regardless of monads
12:53:25 <norpan> O a could be World -> (a, World) or [Input] -> (a, [Output]) or something else
12:53:26 <Cale> Right, the best view of monads as computation is to think of a value of type (IO t) as a program which, if it was ever run, would return a value of type t, but the only such program in Haskell which really gets to run is main
12:53:44 <Philippa_> mcmackerel: you don't understand me. Without IO to drive evaluation, *nothing is evaluated*
12:53:51 <jrmole> but in monads in addition to regular application you have this (>>=) operator, which is kind of like application but has an explicit linear order
12:54:17 <jrmole> yeah, he's right... haskell will never do work unless it knows someone's looking, kinda like me
12:54:19 <Philippa_> it's not necessarily any more explicit than application
12:54:26 <mcmackerel> Philippa_: isn't that more of a philosophical point? i don't think i get it..
12:54:26 <Philippa_> jrmole: she
12:54:43 <jrmole> sorry, my bad
12:54:45 <Cale> Philippa_: That really must get tiring
12:54:49 <Philippa_> mcmackerel: no, it's not philosophical. Most Haskell implementations are lazy - they don't evaluate anything unless it's demanded in some way
12:55:09 <Philippa_> Cale: it makes a change from a/s/l
12:55:17 <jrmole> in fact the language spec demands laziness
12:55:23 <Philippa_> no, it demands non-strictness
12:55:38 <jrmole> sorry, i'm not familiar with the difference
12:55:49 <mcmackerel> but it still feels like deviating a bit. i'm trying to understand monads, not haskell..
12:55:52 <Philippa_> laziness is a specific evaluation order: evaluate when demanded, store the result for next time it's demanded so as not to repeat
12:55:56 <Cale> Lazy evaluation is a mechanism for getting non-strict semantics
12:55:58 <fasta> mcmackerel: Read monad articles on okmij.org (they are in Scheme)
12:56:08 <mcmackerel> fasta: i don't know scheme
12:56:14 <Philippa_> non-strictness is when f _|_ doesn't have to evaluate to _|_
12:56:23 <jrmole> ah, right
12:56:31 <fasta> mcmackerel: What do you know?
12:56:33 <Cale> mcmackerel: Did you read that link I pointed you at? Or had you seen it before?
12:57:01 <Philippa_> mcmackerel: there still isn't any hard work happening until something triggers it, you just find a lot more triggers in strict languages
12:57:01 <mcmackerel> fasta: haskell is the only language i've dealt with leaning on the functional side
12:57:04 <Cale> (I have a terrible memory when it comes to recalling whether I've pointed people at various things)
12:57:20 <mcmackerel> Cale: i read some. i'll have a deeper look later.
12:57:50 <Cale> I have a feeling that you'll have a clearer idea of what monads are really about once you get that dual perspective on them.
12:58:59 <mcmackerel> Philippa_: i just assumed there was something using the final result i guess
12:59:05 <Cale> The IO monad is the absolute worst example of a monad you could start with.
12:59:32 <monochrom> haha
12:59:37 <jrmole> yeah, Maybe is probably the easiest
12:59:38 <Cale> It is a monad, but it's rather more abstract than your usual sort, since you can't really inspect its values.
12:59:41 <fasta> Correct me I am wrong, but basically what happens in the IO Monad is this: You can represent an IO action by: (\_->  putStrln "foobar") This is a function you can toss around anywhere in your program, putting it in lists, whatever. When you are done with the tossing and decided on an ordering, you say, ok, IO monad, execute all this stuff. This is basically it. No magic.
12:59:42 * Philippa_ had to use it in an email earlier...
12:59:47 <Philippa_> but that's because it was IO I was asked about
12:59:59 <jrmole> that's not an IO action, it's a function which takes an argument, ignores it, and returns an IO action
13:00:14 <monochrom> Someone please topic <Cale> The IO monad is the absolute worst example of a monad you could start with.
13:00:22 <jrmole> (putStrLn "foobar") itself is an IO action, that is a value of type IO a for some a, in this case ()
13:01:20 <jrmole> but it is trivial to see evaluation order in the IO monad, which is useful when playing with monadic combinators
13:01:26 <fasta> jrmole: I meant that putStrLn does something impure
13:01:37 <Philippa_> it doesn't though
13:01:42 <fasta> jrmole: I.e. the implementation of the IO monad
13:01:46 <Cale> fasta: You could think of IO actions as C programs, if you'd like to.
13:01:47 <jrmole> ah, i see
13:01:47 <monochrom> It is easy for imperative programmers to forget that a functional programming motto is "first-class functions", i.e., pieces of programs can be tossed around too.
13:02:27 <Philippa_> what "does something impure" is the RTS taking a look at putStrln and carrying it out
13:02:36 <fasta> Cale: How do you mean? Do you mean that in an offensive way?
13:02:37 <Cale> fasta: and (>>=), fmap, join, etc. as acting on those programs in various interesting ways to get new ones.
13:02:51 <Cale> fasta: no, I just mean programs in some imperative language
13:02:54 <monochrom> (putStrLn "foobar") is such a program.  You can toss it around.  You can form a long list of this program with: repeat (putStrLn "foobar")
13:03:04 <Cale> fasta: note, not functions, programs
13:03:33 <Cale> you can't force such a program to run by Haskell evaluation
13:03:50 <Cale> But there are various functions for manipulating these abstract programs into larger ones.
13:04:08 <Cale> In the end, the Haskell runtime will execute the program called main.
13:04:34 <Philippa_> I'm inclined to say "at the start" - >>= et al actually get run
13:04:37 <jrmole> right, i think fasta was postulating a hypothetical impure Haskell-like language, on top of which we implement Haskell's IO monad by delaying (impure) evaluation
13:04:37 <fasta> Cale: Indeed, then we have the same view. Oleg (from okmij.org) explained this on his website. He has very nice articles.
13:04:56 <Philippa_> return effectively obliges the RTS to run actual haskell rather than "just" IO :-)
13:05:14 <monochrom> The only thing I can't do is to deconstruct a program.  E.g., if someone forms a program with "p >> q" and hand it to me, I can't discover that it is composed by >> and consists of p and q.
13:05:19 <Cale> well, actually bind does as well...
13:05:28 <Cale> so I should be careful about that
13:05:38 <Philippa_> point
13:06:19 <Philippa_> that'd be one of the big differences between monads and arrows with ArrowApply
13:06:22 <Cale> monochrom: yeah, that's the problem with learning with the IO monad, there's no way to decompose the programs that you have into smaller parts to get an idea of what's happening
13:06:58 <Cale> also, bind makes things sort of complicated, because it interleaves evaluation with execution
13:08:00 <Philippa_> I'm not sure it does so more significantly than return does? I guess there's the possibility of the monad in question dealing with dependencies lazily
13:08:03 <norpan> bind is complicated
13:08:06 <norpan> join is easier
13:08:15 <Philippa_> not always
13:08:53 <Cale> Well, it's simpler to describe here, but maybe a little more unnatural to think about :)
13:09:20 <fasta> join is nice when you are a physicist.
13:09:46 <Cale> If x :: IO (IO t), that is, an IO computation, which when run, produces another IO computation, join x will be the computation which runs x, then runs its result.
13:11:08 <Cale> If f :: a -> b, and x :: IO a, then fmap f x :: IO b, is the IO computation which runs x, then evaluates f applied to its result, returning that.
13:11:24 <Cale> x >>= f  =  join (fmap f x)
13:11:36 <monochrom> Great way to automatically obfuscate IO code: translate >>= into liftM and join!
13:11:49 <int-e> join f = f >>= id
13:11:55 <moonfish> newbie question: what's the best way to write a chain of conditionals? I don't like the nesting I get with if-then-else, and it seems wrong to use 'case' when I am not actually doing any structural pattern matching.
13:12:20 <norpan> if a
13:12:21 <norpan>   then b
13:12:24 <norpan>   else if c
13:12:37 <Philippa_> moonfish: I'd still go with case and guards
13:12:38 <norpan> you don't like that?
13:12:51 <Cale> case () of
13:12:59 <Cale>  _ | cond1 -> 
13:13:06 <monochrom> "An open question in open source software is how to satisfy the license without giving out anything, i.e., code obfuscation. In this paper we show how to desugar the do notation into liftM and join for that purpose."
13:13:10 <Cale>    | cond2 -> ...
13:13:50 <norpan> chain [(cond1, action1), (cond2, action2), ...]
13:13:54 <bolrod> I don't think code ovfuscatio
13:13:54 <Cale> I wish that liftM would go away, and fmap would be renamed to map.
13:13:56 <bolrod> argh
13:14:04 <monochrom> "We conclude that Haskell is a great way to distribute proprietory code in open source software." XD
13:14:22 <bolrod> obfuscation is a good method to hide something. if someone really wants to find out something ...
13:14:28 <norpan> Cale: at least Monads could require Functor
13:14:32 <Philippa_> nah, you're better off putting the lot through a CPS transformation, building a trampoline and translating it to C
13:14:33 <fasta> monochrom: removing comments seems to help. That's what a lot of "open-source" projects do.
13:14:48 <Philippa_> oh, and renaming everything x0, x1, x2...
13:14:58 <bolrod> the C code that ghc outputs seems rather difficult to understand indeed
13:14:58 <monochrom> I like Philippa_'s method more. :)
13:15:00 <moonfish> Cale: ah, I didn't realize you can have multiple | guard -> exp clauses after a pattern.
13:15:09 <Cale> you could apply remorse to the code
13:15:27 <Cale> that makes it completely unreadable :)
13:15:54 <monochrom> Is it more obfuscating to defunctionalize the CPS result or not?
13:16:04 <norpan> most open source licenses require the source to be the "prefered form" or something similar, unfortunately
13:16:23 <Cale> ftp://ftp.cs.york.ac.uk/pub/haskell/contrib/remorse-1.0.tar.gz
13:16:41 <Philippa_> fasta: if code's changing regularly, removing comments can make sense - out-of-date comments're worse than no comments
13:16:41 <monochrom> Philippa_'s method passes.  Of course the author prefers CPS! XD
13:17:24 <Cale> oh, hmm, that link is broken
13:17:25 <norpan> sure
13:17:38 <Cale> http://iohcc.mgoetze.net/remorse-1.0.tar.gz
13:17:58 <fasta> Philippa_: that's true, but I have seen whole OSS projects uncommented. 
13:18:06 <norpan> the gpl says: "The source code for a work means the preferred form of the work for making modifications to it."
13:18:18 <norpan> the question is preferred for whom?
13:18:33 <Cale> (..|-..)('(':(....):(-| ))=(.--.|.-.|.) (....)&&(.-..|.-) (-| )==')'&&(.-|.-..)(??)((..|-) (-| ))
13:18:33 <fasta> norpan: for the receiver. 
13:18:45 <monochrom> for the author, I posit.
13:18:50 <fasta> norpan: I already asked that question once on #gnu. 
13:18:56 <int-e> preferred for our legal department - we don't want *them* to make changes to the code that actually work.
13:19:10 <norpan> but can the receiver really make the author rewrite the code to his prefered form?
13:19:19 <monochrom> I mean, if the author is smarter than the readers, why water down.
13:19:44 <fasta> norpan: I think the receiver needs to convince the judge in such a case that what he wants is reasonable. 
13:19:54 <monochrom> Must I write in dreadful C just because people are too stupid for Haskell?
13:20:05 <bolrod> > (..|-..)('(':(....):(-| ))=(.--.|.-.|.) (....)&&(.-..|.-) (-| )==')'&&(.-|.-..)(??)((..|-) (-| ))
13:20:07 <lambdabot>  Parse error
13:20:17 <norpan> bless you
13:20:47 <Cale> > let (..|-..)('(':(....):(-| ))=(.--.|.-.|.) (....)&&(.-..|.-) (-| )==')'&&(.-|.-..)(??)((..|-) (-| )) in 0
13:20:50 <lambdabot>  Not in scope: `..|-'
13:20:54 <Cale> hehe
13:21:12 <fasta> norpan: You could try writing to the FSF that you want to see gcc written in Haskell. Good luck
13:21:18 <monochrom> And the same argument in a version that appeals to most OSS people (who also happen to like C/C++ and disdain Java): Must I write in dreadful Java instead of the better C/C++ just because more people out there graduate with Java but no C/C++?
13:22:04 <mux> arg, please
13:22:09 <mux> GCC is sufficiently slow as is
13:22:19 <monochrom> haha
13:22:21 <mux> I don't want a FreeBSD buildworld to take weeks.
13:22:35 <bolrod> so how does one compile the remorsed code :p
13:22:35 <int-e> eh, but that doesn't matter anymore once everything is written in java
13:22:38 <norpan> "you distributed gcc as a binary to me. i want to see the source code. i prefer it carved in stone"
13:22:40 <mux> we already got a nasty 50% increase when switching to GCC3
13:22:41 <bolrod> seems it can't
13:22:50 <Cale> bolrod: it compiles, since it's valid code
13:23:01 <bolrod> it doesn't
13:23:04 <Cale> (that was one line taken from a program)
13:23:08 <mux> and then people were saying "why is this new version of FreeBSD so slow?"
13:23:11 <bolrod> it gives  'Not in scope blablabla'
13:23:15 <int-e> imagine - kernel, java ... libc - uhm - deprecated compatibility layer for non-free code ...
13:23:29 <norpan> "if all you have is a chisel, the preferred form for making modifications is stone"
13:23:37 <int-e> Sun will rule the world :P
13:23:51 <Cale> bolrod: run the makefile, if you don't believe it :)
13:23:55 <int-e> Sun MS - Sun Microsystems.
13:24:16 <monochrom> A new acronym everyday.
13:24:26 <int-e> ANAE
13:24:37 <norpan> INTERCAL is a good acronym
13:24:38 <int-e> Nah, doesn't roll of the tongue. Could you rephrase that?
13:25:05 <monochrom> Acronym of The Day.
13:25:06 <bolrod> FibObf.hs:3:7: Not in scope: `.--.|..-|-|...+|-|.-.'
13:25:08 <bolrod> right...
13:25:11 <int-e> Language Without any Pronouncable Acronym?
13:25:18 <norpan> int-e: yes, something like that
13:25:37 <SamB> how would you know you *had* a GCC binary if all you had was a chisel?
13:25:48 <mcmackerel> bolrod: heh, that looks worse than a few ones i've gotten from stl even :)
13:25:54 <int-e>  "Compiler Language With No Pronounceable  Acronym"
13:25:58 <fasta> mux: heh
13:26:06 <int-e> which  is,  for  obvious  reasons, abbreviated "INTERCAL".
13:26:18 <bolrod> :)
13:26:53 <norpan> cps style programming is sort of like the COMEFROM statement in intercal
13:27:18 <bolrod> Cale: it looks nice.. but it doesn't work for me ;)
13:27:21 <Cale> bolrod: you might have to import prelude functions you want to use
13:27:26 <int-e> bolrod: did you see the multithreaded extension of intercal?
13:27:30 <Cale> bolrod: and give them appropriate names
13:27:56 <Cale> (e.g. look at the remorse code itself)
13:28:44 <mux> fasta: the GCC guys have funny objectives :-) I remember they were saying GCC 3 should not be more than 50% slower when building emacs
13:28:46 <norpan> once i looked at tri-intercal but it made my eyes hurt
13:28:51 <mux> looks like they just achieved that
13:29:17 <Philippa_> they have to pick something as the testbench code
13:29:21 <fasta> mux: still FreeBSD developer?
13:29:27 * mux nods
13:29:31 <SamB> but why is it allowed to be 50% slower?
13:29:33 <SamB> I don't like that!
13:29:38 <mux> Philippa_: the code they use for testing is not the problem :-)
13:29:43 <bolrod> int-e: no.. what is intercal? :)
13:30:02 <SamB> bolrod: run away
13:30:07 <SamB> very far away!
13:30:19 <ihope_> @type flip
13:30:21 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
13:30:29 <bolrod> SamB: :x?
13:30:52 <lightstep> @help
13:30:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:30:56 <ihope_> m (a -> c) -> a -> m c...
13:30:58 <int-e> bolrod: hrm. that was for norpan. intercal is an esoteric programming language with a few crazy ideas like having a come from statement.
13:32:35 <ihope_> Can every complete set of monadic primitives can also be used as a complete combinator base?
13:32:48 <ihope_> Like ap and return?
13:35:15 <lightstep> @wikipedia intercal
13:35:19 <lambdabot> No Result Found.
13:35:55 <int-e> @wikipedia INTERCAL
13:35:56 <lambdabot> No Result Found.
13:35:58 <int-e> hmm
13:36:59 <lightstep> @wikipedia INTERCAL programming language
13:37:01 <lambdabot> No Result Found.
13:37:18 <lightstep> @wikipedia INTERCAL_programming_language
13:37:20 <lambdabot> No Result Found.
13:38:02 <int-e> @wikipedia Asia
13:38:03 <lambdabot> No Result Found.
13:38:35 <int-e> That command seems to be broken.
13:40:26 <int-e> http://www.cse.unsw.edu.au/~malcolmr/intercal/threaded.html
13:40:26 <lambdabot> Title: "Threaded Intercal"
13:45:00 <Cale> yeah, using COME FROM?
13:45:15 <Cale> yeah
13:59:46 <norpan> haskell should have an intercal ffi
14:09:50 <lightstep> intercal-72 has latent types, c-intercal only static ones. will you have 2 ffis?
14:10:51 <lightstep> oh, you will probably only need a static interface anyway
14:11:20 <lightstep> since dynamic typing is used only inside expressions, not in bindings
14:18:22 <yip> is there any good scripting language that can be embedded into haskell programs?
14:18:40 <wilx> Haskell!!
14:18:54 <yip> how does that work?
14:19:14 <yip> ghc-api?
14:19:17 <wilx> Voodoo and other kinds of black magic.
14:19:36 <wilx> There is this...hs-plugins? package for that.
14:19:53 <eivuokko> @where hs-plugins
14:19:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:21:09 <yip> yeah, i've used that. i'm wondering if it's possible to use other more lightweight languages, like lua
14:21:40 <Cale> yip: If lua has a C interface, it would be possible to write an FFI wrapper for it.
14:24:52 <yip> it's C api is actually pretty simple. i guess it should be possible to call it from haskell
14:25:06 <yip> guile might also be interesting
14:56:08 <greenrd> Cale: I fixed the error internal to the function, but I still get the original error
14:56:38 <greenrd> Cale: And if I remove the type signature, I get type less polymorphic than expected
14:56:55 <greenrd> to which my usual response is slap a type signature on there, which usually fixes it
14:57:13 <greenrd> What does the original error mean, anyway?
14:57:41 <greenrd> Why can't it match for all a b. Fn something something something against Fn a b pcg?
14:58:41 * greenrd is slightly suspicious about the fact that a and b appear on both sides, even though they don't refer to the same thing
14:59:32 <greenrd> the explicitly quantified a on the LHS of the attempted match is different to the a on the RHS
15:02:32 <ndm> greenrd: can you paste your code?
15:02:34 <ndm> @where paste
15:02:35 <lambdabot> http://paste.lisp.org/new/haskell
15:03:37 <greenrd> ndm: warning, it's ugly!
15:04:09 <greenrd> http://pastebin.ca/raw/81608
15:04:23 <greenrd> that's the preprocessed version, so you can compile it yourself
15:04:52 <ndm> oh dear, i have no idea when it comes to kinds etc
15:05:12 <greenrd> heh
15:05:33 <greenrd> well kinds are not the problem here, kinds are quite simple in my experience
15:10:01 <Cale> greenrd: Type less polymorphic than expected can usually only occur as the result of the inclusion of a type signature. I suppose one thing to try is turning off the monomorphism restriction with -fno-monomorphism-restriction
15:12:37 <greenrd> gah
15:12:44 <greenrd> stupid text editor didn't tell me the disk was full
15:13:03 <greenrd> hang on, got to make space first
15:19:31 <greenrd> gah, lost it... will have to recover it from the latex
15:20:21 <ndm> your text? the stuff you put in a pastebin?
15:24:31 <greenrd> no, the source lyx document
15:24:46 <greenrd> it's not that important
15:35:36 <palomer> @palomer
15:35:37 <lambdabot> I think you're all nuts
15:36:17 <norpan> @norpan
15:36:17 <lambdabot> Unknown command, try @list
15:36:23 <norpan> i want one i want one
15:42:11 <palomer> norpan: sorry, you can't hang with us
15:42:27 <norpan> sniff
15:51:08 <palomer> @palomer
15:51:09 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
15:51:34 <palomer> that was version 2, version 5 takes minutes
16:01:53 <sjanssen> minutes for a two line program?
16:12:49 <ihope_> data Self a = Self (Self a -> a)
16:12:56 <ihope_> Erm.
16:13:08 <ihope_> data Self a = Self {runSelf :: Self a -> a}
16:15:02 <Frederick> hail
16:15:03 <ihope_> Argh, I forgot it...
16:15:09 <norpan> i want to hang with you
16:15:40 <ihope_> fix f = (\(Self x) -> f (x (Self x))) (Self (\(Self x) -> f (x (Self x))))
16:15:53 <ihope_> That and either of the data declarations above.
16:16:29 <ihope_> So does the algorithm handle that one?
16:24:22 <ihope_> Hmm...
16:24:43 <ihope_> @type join join
16:24:45 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m (m a))
16:24:45 <lambdabot>    Expected type: m (m a) -> m (m a) -> a1
16:25:04 <ihope_> Whoo.
16:26:26 <norpan> @type fix fix
16:26:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
16:26:27 <lambdabot>    Expected type: (a -> a) -> a -> a
16:26:56 <ihope_> fix can be used to match any two types.
16:27:08 <ihope_> @type fix (>>=)
16:27:11 <lambdabot>   Occurs check: cannot construct the infinite type: t = (a -> t) -> b
16:27:11 <lambdabot>    Expected type: ((a -> t) -> a) -> (a -> t) -> a
16:27:23 <ihope_> @type fix return
16:27:25 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
16:27:26 <lambdabot>    Expected type: a -> a
16:27:44 <norpan> @type fix (+1)
16:27:45 <lambdabot> forall a. (Num a) => a
16:27:52 <ihope_> As you can see, it's easy to fail the occurs check with that one :-)
16:32:03 <SamB> @type join fix
16:32:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a -> a) -> a1
16:32:05 <lambdabot>    Expected type: (a -> a) -> (a -> a) -> a1
16:32:07 <SamB> @type fix join
16:32:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
16:32:09 <lambdabot>    Expected type: m (m a) -> m (m a)
16:32:21 <norpan> @type return return
16:32:22 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m (a -> m1 a)
16:32:25 <norpan> @type return return return
16:32:27 <lambdabot>   Ambiguous type variable `m' in the constraint:
16:32:27 <lambdabot>    `Monad m' arising from use of `return' at <interactive>:1:14-19
16:32:32 <SamB> heh
16:33:00 <norpan> @type return (return return)
16:33:01 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) a. (Monad m, Monad m1, Monad m2) => m (m1 (a -> m2 a))
16:33:33 <lisppaste2> ihope pasted "And there it hangs" at http://paste.lisp.org/display/22235
16:33:49 <ihope_> Dang these pastebins...
16:34:27 <ihope_> So why's "return return return" an error?
16:35:13 <norpan> because return return has type m (...)
16:37:39 <ihope_> Yes, but that could be something in the Reader monad.
16:38:25 <norpan> yes but we don't know that
16:38:36 <int-e> > lift lift lift
16:38:37 <lambdabot>    The function `lift' is applied to two arguments,
16:38:37 <lambdabot>   but its type `m a -...
16:40:32 <ihope_> @type let return = Control.Monad.Reader.return in return return return
16:40:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = (a -> t) -> a
16:40:34 <lambdabot>    Expected type: a -> t
16:40:40 <ihope_> Um...
16:41:07 <ihope_> @type const const const
16:41:09 <lambdabot> forall a b. a -> b -> a
16:41:22 <ihope_> Those are, like, the same thing...
16:41:38 <ihope_> @type let return = Control.Monad.Reader.return in return return return :: Monad m => a -> m a
16:41:40 <lambdabot>   Couldn't match the rigid variable `m' against `(->) t'
16:41:40 <lambdabot>    `m' is bound by the polymorphic type `forall (m :: * -> *) a.
16:41:59 <ihope_> @type let return = Control.Monad.Reader.return in return return return :: forall (m :: * -> *) a. Monad m => a -> m a
16:42:01 <lambdabot>   Couldn't match the rigid variable `m' against `(->) t'
16:42:01 <lambdabot>    `m' is bound by the polymorphic type `forall (m :: * -> *) a.
16:42:18 <ihope_> @type let return = Control.Monad.Reader.return in return return return :: a -> b -> a
16:42:20 <lambdabot>   Expecting a function type, but found `t_a1Mu'
16:42:20 <lambdabot>    Expected type: b
16:42:29 <ihope_> Oh, that's helpful.
16:53:25 <sjanssen> @type return return return
16:53:26 <lambdabot>   Ambiguous type variable `m' in the constraint:
16:53:27 <lambdabot>    `Monad m' arising from use of `return' at <interactive>:1:14-19
16:54:17 <sjanssen> @type let r = return in r r r
16:54:19 <lambdabot>   Occurs check: cannot construct the infinite type: t = (a -> t) -> a
16:54:19 <lambdabot>    Expected type: a -> t
17:12:35 <iron32> I have a problem with Hugs SOE that I downloaded to work through the examples in "The Haskell school of expression" book and the Win hugs seems to output the answeres in the same color as the background so I can't see the results any ideas ?
17:13:29 <ihope_> @type let r = return in r r
17:13:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (a -> m a)
17:22:42 <freshhawk> if i have a function, let's call it nextValue :: [a] -> a, that takes a sequence and returns the next value of the sequence, how do i get say the first 1000 elements of the sequence?
17:28:08 <freshhawk> i've done it with an accumulator but there has to be a more elegant way. similar to iterate
17:38:55 <u221e> So many library functions and types to learn...
17:46:02 <u221e> What does "msgPrefix :: !String" mean in the record IrcMessage? I'm looking through the lambdabot source and I'm confused about the !String bit.
17:46:55 <freshhawk> the "!" means it's strict and not lazy if i'm not mistaken
17:49:21 <sjanssen> the !String there probably doesn't do much -- just means that the first character of the string has been evaluated
17:54:27 <palomer> my my my
17:54:34 <palomer> it looks like I may start another project in haskell
17:54:45 <palomer> this is exciting
19:06:14 <lispy> who wrote hoogle?
19:06:17 <lispy> was in ndm?
19:06:33 <arjanb> yep
19:06:40 <lispy> cool
19:06:45 <lispy> i have a suggestion for hoogle
19:06:53 <lispy> @hoogle ThreadID -> IO ()
19:06:54 <lambdabot> No matches, try a more general search
19:06:59 <lispy> @hoogle ThreadId -> IO ()
19:07:00 <lambdabot> Control.Concurrent.killThread :: ThreadId -> IO ()
19:07:00 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
19:07:00 <lambdabot> GHC.Conc.labelThread :: ThreadId -> String -> IO ()
19:07:20 <lispy> as you can see, it would give better results if it considered case insensitive matches
19:12:43 <piggybox> a friend shows me a one line of ruby code to calculate prime numbers: (2..1000).inject([]) {|a, e| (a.map {|x| e % x}).include?(0) ? a : a<<e} 
19:12:43 <piggybox> how can I translate it into haskell?
19:15:08 <SamB> ask them to translate it into Python first ;-)
19:15:16 <mauke> what does that do?
19:16:24 <kpreid> piggybox: is that << a bit shift?
19:17:15 <kpreid> or an append of some variety?
19:17:45 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
19:17:47 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:18:30 <SamB> ooooooh
19:18:46 <SamB> > [1..]
19:18:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:18:50 <Cale> I have an inkling that might be related
19:18:54 <SamB> > [10..]
19:18:55 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
19:19:02 <SamB> > [100..]
19:19:03 <lambdabot>  [100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118...
19:19:06 <SamB> aww
19:19:17 <lispy> SamB: it's surprisingly general
19:19:18 <SamB> it doesn't lex a bit
19:19:25 <lispy> > [1.1,1.2..]
19:19:25 <lambdabot>  [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.59999999...
19:19:26 <Cale> > [100000..
19:19:27 <lambdabot>  Parse error
19:19:27 <Cale> > [100000..]
19:19:28 <lambdabot>  [100000,100001,100002,100003,100004,100005,100006,100007,100008,100009,10001...
19:19:38 <SamB> lispy: I was just looking at the ... at the end
19:19:47 <lispy> ah
19:19:54 <kpreid> SamB: the ... is lambdabot's truncation
19:19:59 <SamB> I was trying to see if it was deliberately placed after a comma or if it just fell like that
19:20:07 <SamB> kpreid: yes, yes. I know
19:20:14 <kpreid> ah
19:20:16 <SamB> I don't remember it looking like that before though
19:21:11 <piggybox> cale: cool
19:21:25 <kpreid> > reverse $ foldl (\a e -> if elem 0 (map (e `mod`) a) then a else e : a) [] [2..50]
19:21:26 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
19:21:29 <kpreid> a translation
19:21:35 <SamB> just because I've been hacking on ZSNES lately doesn't make me suddenly a n00b again
19:22:15 <kpreid> SamB: sorry, I don't know who you are at all
19:22:31 <SamB> @quote SamB
19:22:32 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
19:22:38 <SamB> @karma SamB 
19:22:38 <lambdabot> You have a karma of 9
19:23:02 <lispy> SamB: hehe, you n00b ;)
19:23:18 <SamB> @quote SamB
19:23:19 <lambdabot>  Boy, point-free Arrows are worse than Forth...
19:23:31 <SamB> does that sound like something a n00b would say?
19:23:32 <lispy> @pl (\a e -> if elem 0 (map (e`mod`) a) then a else e : a)
19:23:33 <lambdabot> liftM2 ap (flip =<< ((if' . elem 0) .) . flip (map . mod)) (flip (:))
19:23:51 <lispy> @quote lispy
19:23:51 <lambdabot>  I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
19:24:05 <lispy> SamB: no, but that does ;)
19:24:17 <SamB> that one was a lot funnier last night, but I was a lot tireder then...
19:24:36 <kpreid> @pl (\x -> (e `mod` x) == 0)
19:24:36 <lambdabot> (0 ==) . (e `mod`)
19:24:47 <SamB> its still pretty funny though
19:25:31 <SamB> > [time | time <- [1..], time `mod` 10 == 0]
19:25:32 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
19:25:39 <lispy> @hoogle IO () -> IO ()
19:25:40 <lambdabot> System.Mem.Weak.addFinalizer :: key -> IO () -> IO ()
19:25:40 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
19:25:40 <lambdabot> GHC.Conc.addMVarFinalizer :: MVar a -> IO () -> IO ()
19:25:54 <SamB> lispy: there's your list comprehension for the alarm clock
19:25:59 <SamB> ;-)
19:26:04 <lispy> heh, thanks
19:26:10 <kpreid> > reverse $ foldl (\a e -> if any ((0 ==) . (e `mod`)) a then a else e : a) [] [2..50]
19:26:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
19:26:14 <lispy> i don't think that's too far off from what i came up with
19:26:36 <SamB> but you can actually do this when you are asleep?
19:26:37 <lispy> so why isn't there a forever :: IO () -> IO () in the standard libs?
19:26:43 <kpreid> is there some trick that I can use to turn this into something other than an explicit list accumulation while keeping the 'tail so far' visible?
19:26:46 <SamB> because forever is so easy
19:27:06 <lispy> but if we all end up writing it, why doesn't it just get stuck in the libs
19:27:13 <lispy> do threads have a join function?
19:27:18 <lispy> i couldn't find it
19:27:32 <lispy> so i wrote my own, and today my friend say, "I need a join function for threads...'
19:27:47 <kpreid> lispy: forever is just named (sequence_ . repeat)
19:28:06 <SamB> @pl forever x = x >> forever x
19:28:06 <lambdabot> forever = fix (ap (>>))
19:28:36 <lispy> @type sequence_ . repeat
19:28:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
19:28:41 <SamB> @pl forever x = x >> w where w = forever x
19:28:42 <lambdabot> (line 1, column 28):
19:28:42 <lambdabot> unexpected "="
19:28:42 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
19:28:50 <SamB> hmm...
19:29:06 <SamB> don't think thats the version I wanted anyway
19:30:56 <lispy> SamB: you n00b ;)
19:31:23 * lispy has an inside joke now
19:31:36 <dons> moin
19:31:37 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:31:38 <SamB> what was that version I used to write...
19:32:16 <SamB> forever x = p where p = x >> p
19:32:17 <SamB> maybe
19:32:38 <SamB> @pl forever x = let p = x >> p in p
19:32:39 <lambdabot> forever = fix . (>>)
19:32:46 <SamB> hmm
19:32:58 <SamB> @type (\x -> let p = x >> p in p)
19:33:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:33:24 <SamB> oh, and yes, forever does have that type ;-)
19:33:36 <SamB> not Monad m => m () -> m () like you said
19:33:53 <SamB> (or even IO () -> IO ())
19:34:05 <lispy> mmm..okay
19:34:17 <lispy> @type sequence . repeat
19:34:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
19:34:31 <SamB> see, it never returns so it doesn't matter what it returns...
19:34:38 <lispy> fix . (>>) is a bit more general then i would say
19:34:46 <lispy> true
19:35:02 <lispy> so it returns bottom?
19:35:05 <SamB> I was a bit surprised that the type system could tell this ;-)
19:35:10 <lispy> (did i phrase that right?)
19:35:17 <SamB> well, not really
19:35:23 <SamB> because it is monadic...
19:35:45 <Dino_> @type zip
19:35:47 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
19:35:52 <lispy> @type fix . (>>)
19:35:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:35:54 <SamB> ... it just *never returns*, is all...
19:35:56 <Dino_> @type zipWith (,)
19:35:58 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
19:36:16 <lispy> what about join?
19:36:22 <SamB> no idea
19:36:25 <lispy> (not the monadic join either)
19:37:05 <SamB> it isn't a general monadic combinator like forever, so it is a bit grittier ;-)
19:37:29 <lispy> yeah, i used some weird thing with MVars and a custom fork function
19:37:48 <lispy> and after 8-10 months i don't remember how it works now :)
19:38:07 <SamB> well, whats it supposed to accomplish?
19:39:24 <lispy> i called it waitForChildren
19:39:27 <kpreid> ah yes, fix . (>>)'s type is better
19:39:36 <lispy> it makes the main thread wait for the children to finish then exits
19:39:49 <lispy> well, waitForChildren returns so the main thread can exit
19:40:17 <dons> @seen fasta
19:40:18 <lambdabot> I saw fasta leaving #haskell 5 hours, 24 minutes and 30 seconds ago, and .
19:40:29 <lispy> and .?
19:40:40 <kpreid> @type (and .)
19:40:43 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
19:40:46 <lispy> lol
19:40:54 * kpreid bows.
19:54:38 <dons> @seen vincenz
19:54:39 <lambdabot> I saw vincenz leaving #oasis and #haskell 7 hours, 18 minutes and 19 seconds ago, and .
21:30:12 <dons> ?uptime
21:30:12 <lambdabot> uptime: 3 days, 6 hours, 16 minutes and 25 seconds
21:30:16 <dons> ?yow
21:30:17 <lambdabot> LOOK!!  Sullen American teens wearing MADRAS shorts and "Flock of
21:30:17 <lambdabot> Seagulls" HAIRCUTS!
21:39:13 <dons> ?spell foogle
21:39:15 <lambdabot> fool ogle foible goggle googly
21:39:37 <dons> @tell dmhouse @spell is fixified
21:39:38 <lambdabot> Consider it noted.
21:41:46 <Cale> heh, that naturally leads to the use of the word "fixification", as in "This new module is the fixification of the old spell module."
21:42:40 <dons> ah, yes. quite so
21:43:06 <dons> or fixomorphism, perhaps
21:43:45 <dons> so for every bug ridden module, there is a fixomorphism -- the fixification of that module
21:44:18 <dons> its all a matter of finding the fixomorphism that produces the fixification such that the module is fixified
21:45:34 <vincenz> hi
21:45:35 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
21:46:00 <vincenz> dons: thx
21:49:16 <largos> I'm trying to find a safe way to perodically poll a file (a node in /proc, really) and parse the contents to determine battery life, but the string funcitons seem to be at odds with the IO String types I'm getting out of readFile and it's associates
21:49:50 <dons> I think i'd just write a loop in IO, that threadDelay's the period you wish to wait, before peeking at the file
21:50:03 <largos> yeah, I have that much
21:50:16 <dons> sounds like your problem is that you need to return a value from readFile?
21:50:19 <dons> ?type readFile
21:50:22 <lambdabot> FilePath -> IO String
21:50:30 <dons> so your functions would be something like:
21:50:46 <dons> do threadDelay period ; readFile "/proc/foo"
21:51:04 <dons> or possibly
21:51:05 <largos> *nods*
21:51:14 <dons> do threadDelay period ; s <- readFile "/proc/foo"; return s
21:51:30 <largos> that much I have figured out, although not so elegantly..
21:51:46 <dons> you might even consider:
21:51:47 <largos> but I'm not sure how to process the IO String
21:52:05 <dons> ah, using <-
21:52:12 <largos> ?
21:52:27 <dons> so, main = do s <- getStuff ; print s
21:52:44 <dons> where getStuff = threadDelay period >> readFile "/proc/foo"
21:53:02 <largos> s is of type IO String though, and I only know how to search / process types of String
21:53:03 <dons> main = do s <- getStuff ; print s ; main
21:53:10 <dons> no, s :: String
21:53:21 <dons> the <- performs the IO action, recovering the final value
21:53:31 <largos> oh! ok
21:53:53 <largos> awesome, that's exactly what I didn't understand
21:53:58 <dons> yes, you have to perform the action, before you can get its result to manipulate
21:54:17 <dons> a thing of type IO a is an as-yet unevaluted action
21:54:36 <dons> when you finally perform it, using <- or >>=, you'll actually have the action performed
21:55:01 <vincenz> dons: know anything about SSA?
21:55:03 <largos> nice! I had thought the only way to get it out was with unsafePerformIO
21:55:20 <dons> no. that would be nasty, largos :) you stay inside IO for IO stuff
21:55:28 <dons> then its sequencing is correct
21:55:33 <dons> vincenz: somewhat
21:55:48 <largos> dons: yep ;) thanks
21:56:11 <vincenz> dons: I was reading chakvarteys paper
21:56:22 <vincenz> from elsevier, concerning equivalence between SSA and ANF
21:56:36 <dons> yep, ok
21:57:18 <vincenz> At some point he mentions that he annotates variables in phi functions with the labels of the basic blocks they're defined at, even though the variable names are unique
21:57:26 <vincenz> Instead of CFG packing them
21:57:44 <vincenz> But why is either of this necessary, I would think that once you have the phi functions, the CFG information is not explicitly required anymore
21:58:11 <vincenz> (and can be recovered if need be)
21:59:05 <dons> not sure of the details. perhaps it makes the transformation simpler?
21:59:33 <vincenz> but he encodes it in the ast
21:59:38 <vincenz> well the ir- ast
21:59:45 <vincenz> as if it's some conceptually needed info
22:02:33 <vincenz> ooh
22:02:38 <vincenz> "complimentary wireless access"
22:02:44 <vincenz> does that imply I get free wireless with the room?
22:03:13 <dons> you'd think so. is it a hotel?
22:03:17 <vincenz> yep
22:03:29 * vincenz is flying to toronto in a few hours (gotta leave in an hour in fact)
22:03:32 <dons> (most hotels i've been to in the last 3 years have had free wireless)
22:03:42 <vincenz> good :)
22:04:18 <dons> in particular, tallinn, estonia, had free wireless in the entire city. it was amazing. the pub, the shopping centre, the service station, the cafes. all free
22:04:18 <vincenz> btw, sideline question, is chakvarty your promotor?
22:04:28 <vincenz> nice :)
22:04:31 <dons> my supervisor?
22:04:36 <vincenz> hmm, yes
22:04:37 <dons> "promotor" ??
22:04:44 <vincenz> must be a dutch word I guess
22:04:48 <dons> yeah, he's my phd supervisor.
22:05:28 <vincenz> dons: this is the hotel I'm staying: http://www.ramadahotelandsuites.com/sql/content.asp?MainCataID=20
22:05:28 <dons> hmm, promotor, reminds me of the german word for the same roll, was something like that.
22:05:29 <lambdabot> Title: "Welcome to Ramada Hotel and Suites Downtown T"
22:05:37 <largos> :type (<-)
22:05:46 <vincenz> largos: <- is special do syntax
22:05:52 <vincenz> it gets turned into >>=
22:05:54 <dons> its not an operator, its sugar for >>=
22:05:58 <dons> ?type (>>=)
22:06:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
22:06:02 <dons> i.e.
22:06:09 <dons> ?type readFile "x" >>= print 
22:06:10 <lambdabot> IO ()
22:06:12 <largos> ah, and I had the lambdabot syntax wrong :)
22:06:20 <dons> ?type readFile "x" >>= \s -> print s >> return s
22:06:22 <lambdabot> IO String
22:06:24 <vincenz> do{ x <- readFile; print x } == what dons showed
22:06:36 <dons> ?type do s <- readFile "x" ; print s ; return s
22:06:38 <lambdabot> IO String
22:07:01 <vincenz> "In-room coffee maker, iron, board and hairdryer "
22:07:05 <dons> largos: so see if you can perform the transformation ghc does to go from the last form to the first, with explicit >>=
22:07:28 <vincenz> "Steam room, Whirlpool, Sundeck"
22:07:30 <vincenz> :)
22:07:52 <dons> nice :)
22:08:59 <vincenz> dons: heh, the next paper I'll write will most likely refer to you
22:09:08 <vincenz> the fusion stuff you and dcoutts did
22:09:18 <largos> dons: I think I need to burry my head in Simon's akward squad paper again..
22:10:44 <dons> vincenz: yes? how so.
22:10:56 <dons> hmm. perhaps we better hurry up and get our fusion paper written then.
22:11:06 <vincenz> dons: nah, it's related but not the same
22:11:08 <dons> since people are already apparently citing the work :}
22:12:06 <dons> vincenz: how is it related? rewrite rules? array hacking?
22:12:17 <vincenz> removal of intermediata data structures
22:12:24 <vincenz> tho most likely using some sort of rewrite rules
22:12:45 <dons> cool! seems to be a bit of a hot topic atm
22:12:47 <vincenz> not sure where I'll put the emphasis
22:12:51 <dons> in haskell?
22:12:53 <vincenz> dons: oh? who else?
22:12:54 <vincenz> dons: no
22:13:04 <vincenz> in c++
22:13:17 <dons> well, there's the nested data parallel branch of ghc, doing similar for general purpose arrays
22:13:25 <dons> (and parallel arrays)
22:13:40 <dons> and spj's recent work on improving rule matching
22:14:03 <vincenz> ah I see
22:17:30 <vincenz> funky, there's a debian developer on the southpole: http://www.debian.org/devel/developers.loc
22:17:31 <lambdabot> Title: "Debian -- Developer Locations"
22:17:41 <vincenz> and another one in greenland
22:18:12 <dons> hmm, i wonder if they're _really_ at the south pole. it's kind of cold
22:18:28 <dons> it's possible, i suppose.
22:18:32 <vincenz> well antartica as a whole is extreme
22:18:48 <vincenz> dons: free cpucooling?
22:18:53 <dons> heh
22:19:10 <vincenz> actually that might be a useful idea for server farms
22:22:16 <vincenz> flying east is funky: you leave at 1 and arrive at 3
22:22:18 <vincenz> pm
22:22:36 <vincenz> erm, west, not east
22:36:51 <vincenz> well I'm off
22:36:53 * vincenz wave
22:53:55 <Lemmih> @seen mnislaih
22:53:56 <lambdabot> I saw mnislaih leaving #haskell 17 hours, 23 minutes and 52 seconds ago, and .
23:48:21 <vilager> hello
23:48:31 <largos> g'day
23:48:38 <vilager> how to increment a global variable in haskell ?
23:48:52 <sjanssen> eek!  global variable!
23:48:58 <vilager> hmm
23:48:59 <johnnowak> eek! increment!
23:49:06 <vilager> i've tried not using this
23:49:10 * largos shudders
23:49:10 <sjanssen> eek!  haskell!
23:49:21 <vilager> but i don't know how the hell to solve my problem here
23:49:23 <largos> sjanssen: I think that's villager's line
23:49:27 <dons> vilager: there are no global variables in haskell
23:49:40 <sjanssen> anyway, vilager, we don't modify variables in Haskell
23:49:45 <vilager> dons
23:49:47 <vilager> i know
23:49:47 <vilager> but
23:49:49 <Lemmih> (there are lots in GHC, though)
23:49:58 <vilager> there is a constant function
23:49:59 <dons> you probably instead mean to pass that value as an argument to your functions?
23:49:59 <vilager> right ?
23:50:13 <vilager> dons 
23:50:22 <dons> vilager: can you paste the code?
23:50:29 <dons> ?paste
23:50:29 <lambdabot> http://paste.lisp.org/new/haskell
23:50:29 <vilager> yeah
23:50:30 <vilager> but
23:50:33 <vilager> let me explain
23:50:38 <vilager> about it
23:50:48 <vilager> i was solving a problem 
23:51:06 <vilager> and this problem has inputs and outputs right ?
23:51:22 <vilager> my problem is in 1 line of the out put
23:51:26 <vilager> i should be
23:51:40 <vilager> Turma 1
23:51:40 <vilager> 2
23:51:40 <vilager> Turma 2
23:51:40 <vilager> 12601 10111 212
23:51:50 <vilager> Turma 3.....
23:51:53 <vilager> Turma 4 
23:51:57 <vilager> you know ?
23:52:11 <vilager> the logic of the second line i've already done
23:52:17 <dons> ok, so that value needs in increase on each call? 1,2,3,4... 
23:52:21 <vilager> but this "turma x"
23:52:25 <vilager> yeah
23:52:32 <dons> so, turma :: Int -> IO Int
23:52:43 <dons> or perhaps, you just map it over [1..]
23:52:51 <vilager> hmm
23:52:57 <vilager> turma :: Int -> IO Int
23:53:09 <vilager> and then ?
23:53:15 <vilager> let me show you de code
23:53:20 <dons> > map (\s -> "Turma "++ show s) [1..]
23:53:22 <lambdabot>  ["Turma 1","Turma 2","Turma 3","Turma 4","Turma 5","Turma 6","Turma 7","Turm...
23:53:40 <dons> just give it a different argument each time you call it
23:53:46 <dons> using a list of [1..] as a supply
23:53:59 <vilager> hmm
23:54:03 <dons> (this is the lazy fp equivalent of a for loop, when combined with a map)
23:54:28 <vilager> dons
23:54:33 <vilager> let me show you
23:54:45 <dons> probably, since you're actualy printing, you'll want to use mapM_ (print . turma) [1..], or something like that
23:54:53 <vilager> imprime melhores = do { putChar '\n'; putStr ("Turma "++(show turma)); putChar '\n'; imprimeTudo melhores; }
23:54:56 <vilager> here
23:55:14 <vilager> tha show(turma)
23:55:16 <vilager> has to be
23:55:16 <vilager> 1
23:55:16 <vilager> 2
23:55:17 <vilager> 3
23:55:18 <vilager> ...
23:55:20 <dons> ok. but you need 'turma' to be an argument to imprime.
23:55:22 <dons> not a constant
23:55:30 <vilager> yeah
23:55:41 <dons> so it _vary_ (as in variable) each time you can imprime
23:55:41 <vilager> so
23:55:49 <dons> s/can/call
23:55:51 <vilager> what do i do ?
23:56:32 <vilager> let me explain you
23:56:35 <dons> the function that calls imprime, needs to supply a different element each time. either by looping with an incremementing argument, or via map [1.]
23:56:43 <vilager> yeah
23:56:49 <vilager> but that's the problem
23:56:50 <dons> that's what you need to do.
23:57:43 <dons> if you're still stuck, you could paste the code that calls imprime.
23:58:09 <vilager> dons
23:58:16 <vilager> i don't know if you're getting it
23:58:31 <vilager> verificaAluno [] melhores original = imprime melhores
23:58:32 <vilager> here
23:58:38 <vilager> you mean
23:58:39 <vilager> verificaAluno [] melhores original = imprime melhores
23:58:40 <vilager> but
23:58:47 <vilager> with an argument incrementing
23:59:01 <vilager> but i won't work in my case
23:59:11 <vilager> let me explain you about the problem
23:59:15 <dons> if that's the definition, then you'll need to move one level up, and look at the function that calls verificaAluno
23:59:31 <vilager> verificaAluno is called in function main
23:59:32 <vilager> ok ?
23:59:34 <dons> it would become: verificaAluno [] melhores original x = imprime melhores x
23:59:44 <vilager> yeah i know
23:59:45 <dons> and in main then, that's where you provide this extra argument
23:59:45 <vilager> but
23:59:53 <vilager> yeah
23:59:57 <vilager> but i can't
23:59:59 <vilager> cauz
