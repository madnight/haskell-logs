00:00:02 <dobblego> it's a contrived example of formally expressing software requirements, with a nice buzzword touch
00:00:05 <lispy> palomer: in the extreme case you right your tests before you write the code, in the more relaxed case you write the tests in parallel to the code.  When I say tests I mean primarily unit tests.
00:00:09 <Saulzar> Write tests for specification, write code to pass tests 
00:00:57 <lispy> dobblego: i'd say it's more useful than most buzzword instances
00:01:02 <palomer> but, like, I have a very specific example where my code is failing
00:01:05 <palomer> why? who knows
00:01:09 * Saulzar never has the discipline to test anything properly
00:01:38 <lispy> palomer: can you decompose the code into parts that you have verified to be working correctly?
00:01:38 <dobblego> it's more useful than traditional approaches, but far from optimal - this has been known for dcades
00:02:16 <lispy> dobblego: it is very common sensical and not perfect
00:02:19 <lispy> i would agree there
00:02:48 <lispy> and Saulzar makes a good point, it takes some discipline and extra work
00:03:09 <dobblego> it takes less work in fact - this is one of the premises of proponents of TDD
00:03:50 <dobblego> I'm still trying to figure out what sensical is :)
00:03:59 <dobblego> sounds like a type of ice cream or something
00:04:07 <lispy> hehe
00:04:21 * lispy has had a few beers and blames the typos and made up words on the beer
00:04:36 <shapr> (IceCream a) => ...
00:04:40 <lispy> "sensidasical"
00:05:06 <lispy> sensidasical :: IceCream a => a -> b
00:05:09 <shapr> palomer: test driven development roxx
00:05:27 <lispy> dobblego: maybe it's just that it feels like more work at the onset
00:05:45 <lispy> the argument is that you'll save time later by doing less debugging
00:05:48 <dobblego> I urge anyone who believes that to try it
00:05:53 <shapr> and truly TDD is less work than less disciplined coding
00:05:57 <dobblego> I disagree with that reasoning
00:06:15 <shapr> I hacked up TDD extensions to QuickCheck, have you seen them?
00:06:21 <dobblego> it is less work because you have a language with which to apply your requirements that is at the very least, more formal than what is typically available
00:06:25 <lispy> shapr: no, where can i see them?
00:06:31 <dobblego> I wrote a unit test framework for Java
00:06:46 <shapr> http://www.scannedinavian.com/~shae/qc-tdd.tgz
00:07:10 <shapr> lispy: The way I save failing values is fragile, if you can see a better way, I'd be thrilled.
00:07:17 <shapr> The included README should explain it all.
00:07:49 * palomer wishes he could get the addresses of his STRefs
00:07:50 <shapr> dobblego: Are you saying that tests define a domain specific language?
00:08:39 <dobblego> shapr, no, that "unit tests" are just a more formal expression of your requirements, therefore, you get greater accuracy, and therefore, expend less effort (in contrast to the usual ad hoc mess that goes on with a traditional approach)
00:09:17 <dobblego> I use TDD every day - just I don't call it that, since to me, that is just a buzzword which unfortunately obscures some of the reality - people are relarning what has already been learned
00:09:17 <palomer> OH MY GOD
00:09:24 * palomer kills the occurs check
00:09:26 <palomer> PFFFFFFT
00:09:31 <lispy> i wouldn't say unit tests are an expression of the "requirements" but i would say they help define the spec
00:09:59 <dobblego> lispy, that's exactly my beef with the guff that comes with TDD
00:10:06 <kzm> what's up with the certificate on haskell.org (using https)?
00:10:18 <dobblego> they are indistinguishable when placed under analysis to derive a tangible definition
00:11:10 <lispy> indeistinguishable from what?
00:11:19 <shapr> What guff comes with TDD? As far I know Kent Beck wrote a page about it on Ward's Wiki and that's when I started using it.
00:11:38 <palomer> well, erm, after 5 days of work I have a unifier algorithm
00:11:41 <palomer> everyone clap your hands!
00:11:50 * shapr claps palomer's hands.
00:12:11 <palomer> to be fair, it does much more than unify
00:12:15 <palomer> but that stupid occurs check
00:12:16 <palomer> asotehustaoheus
00:12:25 <shapr> dvorak!
00:12:29 <shapr> aoeuaoeuhtnshtns!
00:12:31 <dobblego> I realise it's become mainstream now - it's difficult to argue with orthodox understanding
00:12:49 <dobblego> the definition of "software requirements" is ultimately what it comes down to
00:12:49 <shapr> Um, unit testing isn't even mainstream yet...
00:13:09 <dobblego> sure it is - much more than it was 10 years ago
00:13:25 <dobblego> I could talk about software requirements with academics 10 years ago, and we'd agree on what we were talking about
00:13:51 <shapr> Actually, I'm interested in your point because I've been thinking the same thing since I read the refactoring browser thesis long years ago.
00:13:58 <lispy> dobblego: i'm no expert in software engineering, but to me the requirements are what the program must do and the specificiation is how it happens to do it.  So what bothers you with TDD about those two words?
00:14:21 <shapr> Refactoring is a meaning preserving transformation, but it changes the code, ergo meaning is actually defined by your unit tests.
00:14:52 <dobblego> lispy, it is only that some things have been taken well out of context - I am writing an article now that assumes a certain definition of software requirements that might help highlight the point better
00:14:55 <shapr> Brant & Jones almost make that point in the refactoring browser thesis.
00:15:10 <shapr> dobblego: Refer to the refactoring browser thesis!
00:15:13 <dobblego> it is the premise on which I plan to write a programming language that integrates the hidden good parts of TDD 
00:15:16 <shapr> I want to read your article!
00:15:20 <dobblego> shapr, what is that exactly?
00:15:25 <dobblego> the article is ~80% complete
00:15:25 <shapr> dobblego: Have you seen Eiffel already?
00:15:25 <Korollary> unit testing has been mainstream for a long while. Even the popular frameworks have been around for several years in heavy use.
00:15:31 <shapr> You know Design By Contract?
00:15:35 <dobblego> shapr, only in very small detail
00:15:41 <dobblego> shapr, yes, very well
00:16:01 <dobblego> you might ask "how could I know DBC, and not Eiffel?"
00:16:05 <shapr> DbC is most clearly seen in Eiffel, where it started, imho.
00:16:08 <dobblego> right
00:16:20 <lispy> interesting discussion, but i need to go to sleep
00:16:31 <shapr> and I need to go to work
00:16:35 <dobblego> I plan to devise some new buzzword to distinguish myself from all that - but really, we all have a common objective
00:16:50 <dobblego> my article will be on http://tmorris.net/pubs/ eventually
00:16:57 <shapr> Yeah, all of XP, TDD, DbC, etc have the same goal with slightly different approaches.
00:17:02 <dobblego> I am resigning from my job this Friday, so I have no idea what my spare time will be like
00:17:06 * Korollary wonders if dibblego and dobblego are related.
00:17:14 <shapr> I don't have any spare time at the moment.
00:17:24 <lispy> ah, spare time...
00:17:25 <dobblego> kolmodin, dibblego is me at work (we havbe the same IP because I proxy through home)
00:17:35 <dobblego> I'm just glad I am resigning :)
00:17:58 <shapr> How'd you end up in #haskell?
00:18:04 <shapr> We don't see so many commercial programmers here.
00:18:06 <lispy> i want to write a game engine that becomes a successful game, and a raytracer, a new language, an os, and maybe a replacement for maple...in my "spare time" of course :)
00:18:18 <dobblego> I want to learn how other languages solve the problems I intend to solve
00:18:21 <shapr> And I want to start a successful Haskell company...
00:18:32 <shapr> What's the problem?
00:18:39 <dobblego> there are *lots* of problems
00:18:54 <shapr> What's the problem you intend to solve?
00:19:02 <dobblego> Haskell seems to solve them well more than mainstream languages - though I have nly 20 minutes experience with it
00:19:25 <lispy> haskell solves a lot of problems and introduces some new ones
00:19:37 <dobblego> in summary, the problem is that mainstream languages enforce a contradiction in software requirements - specifically, one must make a trade-off between an accurate expression of requirements and what the language permits
00:19:39 <shapr> The ideas in Haskell are bigger than the ideas in other languages.
00:19:46 <lispy> for example, lazy code is hard to optimize for most people
00:19:47 <dobblego> I'd like to align the two by stating a formal axiom and working from that
00:19:55 <shapr> dobblego: Have you seen QuickCheck yet?
00:20:00 <dobblego> no
00:20:15 <shapr> lispy: I think that's cultural, but ... you're getting tired.. your eyelids are drooping ;-)
00:20:19 <lispy> quickcheck could probably be summarized as randomized unit testing
00:20:29 <lispy> shapr: hehe :)
00:20:31 <shapr> That's a summary, but it's more than that.
00:20:36 <shapr> Especially QuickCheck2 is..
00:20:38 <Korollary> if I understand correctly, dobblego wants more formalized methods (probably with less testing).
00:20:47 <Korollary> or less dependence on testing
00:20:47 <dobblego> I claim that there is an impedance mismatch implied bytraditional languages
00:21:09 <dobblego> what you call "testing", I call expression of requirement - I want more of that, even to a point of completeness
00:21:33 <shapr> Well, do you know the Curry-Howard correspondence?
00:21:39 <dobblego> no
00:21:43 <shapr> Are you familiary with proof programming?
00:21:45 <dobblego> one thing at a time :)
00:21:52 <shapr> You're gonna love this channel =)
00:21:56 <dobblego> I converse with people who are quite a lot
00:22:14 <dobblego> I just take the bits that are meaningful to me, due to time constraints
00:22:30 <astrolabe> One of the biggest problems with haskell is ignoring #haskell for long enough to get some work done.
00:22:32 <Korollary> There's quite a bit of that kind of work going on. The people who are most into it are mission critical devs, etc. who demand so few bugs per line that they don't even trust the compilers anymore unless the are proven, too.
00:22:35 <shapr> astrolabe: heh, true
00:22:55 * Saulzar finds alt-f4 handy
00:22:57 <shapr> dobblego: http://en.wikipedia.org/wiki/Curry-Howard
00:23:01 <dobblego> cheers
00:23:13 <shapr> Roughly, proofs are programs and vice versa.
00:23:28 <shapr> You can generate a provably correct computer program from a proof.
00:23:44 <shapr> That's the end point of unit testing and software requirements.
00:23:47 * lispy signs off for the night
00:23:55 <dobblego> looks like I've reinvented that
00:24:04 <dobblego> I know I am retracing a lot of existing work
00:24:06 <shapr> There are lots of intermediate points on the way there.
00:24:58 <dobblego> if a decent programming language is going to become mainstream, there must be a migration path - the sad reality
00:25:02 <shapr> Well, I could go on at great length, since unit testing and software specification fascinates me... but I have to work.
00:25:11 <shapr> Not necessarily.
00:25:21 <dobblego> yes me too, but I'm at home, and I don't have to work, because I've already been paid until this Friday :)
00:25:21 <Korollary> I don't find becoming mainstream a true necessity.
00:25:40 <dobblego> Korollary, I don't either, but if that were somehow to become an objective
00:26:10 <Korollary> Yes, it becomes a social science experiment.
00:26:24 <dobblego> I have to go warm up for squash, seeya
00:26:33 <shapr> Haskell isn't perfect, but (for me at least) it's the best production quality language I've found.
00:26:44 <shapr> yeah, seeya
00:26:49 * shapr goes back to being a webmonkey.
01:12:30 <shapr> Sure is quiet today.
01:12:44 * shapr yodels to break the silence.
01:13:12 <swiert> Hiya shapr.
01:13:33 <shapr> hoi swiert, hoe gaat het?
01:13:45 <shapr> Having fun with Epigram?
01:14:13 <swiert> not too bad. Kind of dashing to meet a deadline, but other than that, I can't complain.
01:14:35 <swiert> Haven't had much Epigram fun in a while now. 
01:14:44 <swiert> That's scheduled for next week.
01:15:01 <swiert> How 'bout yourself?
01:15:05 <shapr> Epigram looks like the next spiffy research language after Haskell.
01:15:21 <shapr> I'm a webmonkey, and that's my life. But I read lots of research papers when no one is looking.
01:15:44 <swiert> Possibly. There are some other interesting ideas out there (Omega for instance).
01:16:03 <shapr> Yeah, but Omega is quite similar to Epigram from my viewpoint.
01:16:47 <swiert> Besides, I don't think Epigram will become mainstream easily. I think Conor once mentioned it was more likely to become the next Miranda than the next Haskell.
01:16:51 <shapr> In any case, it seems that dependent types are likely to be in the next 'research language.'
01:17:01 <shapr> Hm, why so?
01:17:32 <swiert> No! Omega does all sorts of stuff, but tries very hard to not make the jump to dependent types.
01:17:41 <shapr> huh
01:17:50 <shapr> I'll have to look at Omega again.
01:17:56 * shapr adds that to his todo list.
01:18:35 <swiert> Well - to develop a full compiler ghc sized compiler you need a *lot* of effort - it'd be enough if Epigram gets Haskell people rethinking about the possibilities of dependent types.
01:18:36 <shapr> The demands of being a webmonkey keep me from reading as many research papers as I'd like.
01:19:19 <swiert> I can imagine. I suppose one of the major perks of being a PhD student is you get to spend huge amounts of time reading research papers.
01:19:34 <swiert> It's kind of what you're paid to do in your first year.
01:19:34 <shapr> Truly. I'd like to try being a PhD student myself one day.
01:20:12 <shapr> I figure if I can read this many research papers in my spare time, I could probably absorb an entire field of research in a year of full time reading.
01:20:30 <swiert> It's a good life in many ways.
01:20:46 <shapr> Though most programmers I speak to have never read a research paper in their life.
01:21:30 <shapr> I was at EuroPython 2004 and I spoke to a guy who'd written a make replacement in Python. I asked if he'd used directed acyclic graphs, and he said he didn't use anything academic.
01:21:47 <swiert> That's a bit depressing really.
01:21:51 * shapr agrees
01:22:09 <shapr> But as they say, those who do not know the mistakes of history are doomed to repeat them.
01:22:21 <swiert> There's plenty of research that isn't relevant to programmers in general, but it's important to keep an open mind.
01:22:57 <shapr> ScienceNews.org is an excellent way to keep up on everything non-CS.
01:23:17 <shapr> It's the only dead tree publication subscription I've ever had, and I've had it for five years or so.
01:23:35 <tuomov> it doesn't help using the research when all the information is hidden behind the lock known as Copyright
01:23:45 <shapr> True, but not everything is.
01:24:35 <swiert> my problem with a lot of the wider audience science magazines is that the stuff which really interests me, I've probably heard of already.
01:24:40 <tuomov> and, frankly, the research paper search engines suck
01:24:46 <swiert> But maybe my interests are a bit narrow.
01:24:59 <tuomov> a wikipedia for research papers would be useful..
01:25:09 <swiert> Most authors have copies of their work on their homepage.
01:25:12 <shapr> Yeah, that's what I keep meaning to do with Fermat's Last Margin.
01:25:21 <tuomov> wikipedia is often more useufl than google for looking up information/links anyway
01:25:41 <shapr> swiert: If you haven't tried ScienceNews.org yet, you should. It's the best publication of its type I've come across.
01:25:53 <swiert> I'll give it a look.
01:28:48 <gour> Lemmih: ping
01:29:31 <shapr> swiert: What sort of stuff interests you?
01:29:48 <swiert> shapr: good question.
01:30:34 <swiert> shapr: lately I've been doing quite a bit of category/type theory, although I'm from a functional programming background.
01:31:28 <shapr> I think those two naturally mesh.
01:32:04 <swiert> shapr: At the moment Thorsten and I are writing up a proof that you can (almost) decide whether or not two types are isomorphic. 
01:32:33 <swiert> shapr: after that paper's out the door, I don't know. It's a bit too theoretical for my taste.
01:33:02 <swiert> shapr: There are some neat ideas floating around about Epigram's IO.
01:33:31 <shapr> I think type based refactoring in Epigram looks nifty.
01:33:38 <shapr> If you can reopen sheds...
01:34:06 <swiert> Epigram 2 should have *much* better undo facilities.
01:35:26 <shapr> hoi tromp
01:35:54 <shapr> swiert: Are reopenable sheds on the todo list?
01:36:24 <tromp> hoi shapr
01:37:26 <dcoutts> swiert, so how much do you Epigram folks already know about GUIs & Gtk/Gtk2Hs ? I'm wondering where Axel 7 I should start when we come up to talk you to lot.
01:38:05 <shapr> It would be cool to swap all occurences of a type to something else that will fit into the same place.
01:38:23 <tromp> do you like programming puzzles, shapr?
01:38:28 <shapr> Sometimes...
01:38:31 <swiert> shapr: As in being able to "reopen" a bit of expanded code as opposed to being having to undo the last character you typed several times - definitely.
01:38:56 <tromp> write a constant space linear time function dupe :: (Eq e, Ix e) => Array e e -> e
01:39:12 <swiert> dcoutts: Good question. Some people have been playing arounnd with Gtk2Hs for a bit.
01:39:41 <tromp> that given an array mapping a range (lower,upper) to (lower+1,upper), produces a duplicate element
01:39:58 <shapr> Well, I won't have time to try that puzzle anytime soon...
01:40:03 <swiert> dcoutts: I think it would be fine to give a general introduction at fp-lunch and then discuss some nitty-gritty Epigram specifics with Joel, Conor and myself.
01:40:10 <dcoutts> swiert, I've been thinking about formula layout algorithms, I might write a mini-demo.
01:40:18 <dcoutts> swiert, right 'o
01:40:22 <swiert> dcoutts: Sounds really cool.
01:41:13 <dcoutts> swiert, do you have an example of what the stuff looks like? The best I found was on the wikipedia entry and that was not in colour.
01:41:22 <swiert> dcoutts: We want to have some kind of front-end of the epigram 2 core finished by the time you guys come over. We're hoping your experience with Hide con kind of push us in the right direction.
01:41:49 <swiert> dcoutts: got to go now, bbl.
01:41:55 <dcoutts> swiert, ok, bye
01:49:05 <shapr> tromp: Is this an amortization algorithm puzzle?
01:52:17 <tromp> nope
01:52:24 <tromp> sorry:(
01:58:19 <int-e> tromp: you know a (the? there's basically only one algorithm that I can think of) solution, right?
01:58:30 <tromp> sure
01:59:09 <tromp> there's one that uses just two variables and no counters of any kind
02:00:43 <araujo> Good morning!
02:01:36 <tromp> off to work...
02:10:21 <musasabi> morning
02:11:06 <Saulzar> evening
02:14:09 <tromp_> arrived at work:)
02:14:29 <ProfTeggy> tromp, do you work across the street? ;-)
02:14:40 <tromp_> more like, across the park:)
02:14:47 <ProfTeggy> Isee :)
03:02:23 <srle> hi, all
03:02:32 <araujo> Hi.
03:03:15 <srle> why haskell programms don't run fast as ocaml porgrams? they both have type system that is able to determine types at comiple time.
03:04:00 <srle> I don't want to start falme. I am just quirious.
03:04:10 <flux__> laziness does come at its cost
03:04:23 <dcoutts> ocaml has a good compiler that pays attention to low level stuff
03:04:52 <srle> dcoutts : are you saying that haskell compiler suck?
03:05:17 <flux__> "I don't want to start a flame" :-)
03:05:41 <dcoutts> srle, no, but the ocaml compiler is excelent
03:05:47 <shapr> The OCaml compiler doesn't pay attention to word size or integer overflows though...
03:06:01 <dcoutts> srle, many other ML compilers are not nearly as fast as the ocaml one.
03:06:36 <flux__> shapr, haskell doesn't handle integer overflows either, although it does provide infinitely large integers (too)?
03:06:40 <shapr> Also, parallelizing the OCaml runtime/compiler would be more a reimplementation, whereas GHC has already got one.
03:06:55 <shapr> flux__: Yes, but integers are the word size of the platform, and overflow silently.
03:07:06 <musasabi> By default haskell uses Integer which has infinite size
03:07:12 <shapr> Thus OCaml programs can behave differently on x86-32 vs x86-64 and you won't know the difference.
03:07:20 <musasabi> Of course you can tell it to use Int
03:07:24 <srle> why nobody builds frontend for haskell that generates data for ocaml beckend?
03:07:26 <flux__> shapr, so in haskell Ints are always 32-bit?
03:07:47 <shapr> I've written about the speed fetishism of OCaml vs the speed fetishism of Haskell on my blog.
03:07:49 <musasabi> also Haskell code is usually more polymorphic than OCaml code.
03:08:02 <srle> sharp: can you give me a link?
03:08:16 <dcoutts> srle, that would not be possible because of different execution models for lazy vs strict programs.
03:08:31 <shapr> srle: http://www.scannedinavian.com/2005-04-29.html
03:08:35 <srle> musasabi : that doesn't prevent compiler got generate specialized functions for basic types.
03:08:43 <flux__> well, it could still be converted but no doubt performance would be lost
03:08:46 <pejo> dcoutts, any public scribbles on PE btw? 
03:09:09 <flux__> automatic specialicing would be great both for haskell and ocaml
03:09:19 <musasabi> srle: yes, it does prevent things from time to time.
03:09:21 <dcoutts> pejo, nope. But I think I might have a paper ready in time for a conference in april.
03:09:23 <flux__> did ghc have manual specialicing?
03:09:24 <shapr> SPJ's latest paper unifies lazy and strict with an IL...
03:09:28 <shapr> Haven't read it yet though.
03:09:37 <musasabi> srle: e.g. stricness analysis is much harder if the function is polymorphic
03:10:28 <pejo> dcoutts, nifty! Feel free to tell me when. :-)
03:10:54 <dcoutts> pejo, the most interestign thing I've got in puclic atm is this:
03:10:54 <dcoutts> http://haskell.org/~duncan/gtk2hs/Constraints%20Viewer.png
03:11:56 <dcoutts> though the current results are better, I can colapse the constraints on the askernmann function down to the minimum (which is 2)
03:14:36 <MarcWeber> Looking at the definition of fmap "Functor f where fmap :: (a -> b) -> f a -> f b" I noticed that I don't understand what f a and f b means, yet. Does this mean: type f  must have one type parameter ( in this case a or b)?
03:15:10 <dcoutts> MarcWeber, right
03:15:57 <dcoutts> MarcWeber, examples of such an f include [a], Maybe a and many others
03:16:28 <dcoutts> MarcWeber, so you see they are collection types that are parametersied by the type of thing they contain.
03:20:23 <MarcWeber> and of cause monads  (m a or m b or .. :) Is [a] a synonym for something like  list a (meaning list of type a?)
03:23:13 <Cale> [a] is the same as [] a
03:23:34 <Cale> (a,b) is the same as (,) a b
03:23:50 <Cale> (as types, though the latter applies to values as well)
03:25:04 <MarcWeber> Ah thanks. Now I see it.
03:26:11 <Cale> (so yeah, basically what you said :)
03:27:13 <MarcWeber> But I did guess it ( and this time my guess was right! )
03:27:56 * MarcWeber feels happy as he is starting to read haskell code the way it's meant to be..
04:10:42 <dcoutts> xerox, Cale, jyp, juhp, all other gtk2hs users: we (the gtk2hs devs) are looking for some fedback on a couple ideas we have for improving the TreeView system
04:10:44 <dcoutts> http://sourceforge.net/mailarchive/forum.php?thread_id=9669932&forum_id=8415
04:11:06 <dcoutts> basically it amounts to how much typing people want / are able to put up with
04:11:29 <MarcWeber> All I've done by now is compiling the examples :)
04:11:42 <MarcWeber> and noticing that it did work out of the box
04:11:56 <dcoutts> vincenz, Lemmih, dons, palomer: you might have some opinion on this, we'd like to hear it.
04:12:23 <dcoutts> MarcWeber, you're talking about the gtk2hs demos not compiling?
04:13:27 <MarcWeber> dcoutts: No. They did work! ;-)
04:13:43 <dcoutts> oh, sorry I mis-read!
04:13:50 <dcoutts> :-)
04:13:51 <dcoutts> oops
04:14:10 * dcoutts should be less paranoid :-)
04:14:41 <dcoutts> "what breakage!? where!? Eek!"
04:15:31 * shapr sings cheerfully
04:17:42 <gour> dcoutts: i'd like to merge '+' from #1 with '+' from #2 and put '-' from both #1 &  #2 into /dev/null :-)
04:17:56 <dcoutts> gour, hah!
04:18:19 <dcoutts> gour, the strength of typing is a trade-off
04:18:30 <gour> dcoutts: i cannot escape from my nature. what can i do..
04:19:26 <dcoutts> gour, it's especialyl difficult since we're imposing a typing structure on undrlying system that is dynamiclaly typed
04:21:25 * gour puts #1 & #2 into different files to make it easier to compare...
04:26:54 <gour> dcoutts: i vote for #1 considering these points:  + simpler API
04:26:54 <gour> + uniform with respect to all other widgets, closer to the
04:26:54 <gour>   original C API
04:27:36 <dcoutts> well I think simpler API is a confusing point, it has simpler types in the API but is other wise the same.
04:27:46 <gour> dcoutts: worrying about 'extracting the model from a view cannot be done safel', i.e. what does it mean in practice?
04:27:55 <dcoutts> #2 has more complex types but fewer parameters, so in that repsect the api is simpler.
04:28:48 <MarcWeber> dcoutts: Sorry. I'm not familiar enough with gtk treeviews/listviews by now. I'm not sure what a col of a tree is.. and I've difficulties getting the exact meaning of model, view and renderer from this context..
04:29:09 <gour> ok, let's focus on the 2nd point then - closer to C api
04:29:10 <dcoutts> gour, if a view doesn't know the type of the model then you cannot extract it because the model does have a type parameter (the type of the row data in the model)
04:30:51 <dcoutts> MarcWeber, A TreeView is a widget for displaying data from a model (eg a simple list, a tree or a database). A TreeView can have a number of columns, eg think of a file list box that has columns for the name, type, modificatin date, etc.
04:30:58 <gour> ahh..in #2 model & view have type
04:31:12 <dcoutts> gour, exactly, that's the key difference
04:32:15 <gour> hmm..doesn't that makes #2 a clear winner?
04:32:17 <dcoutts> MarcWeber, then a renderer is something that is stuck in each column. It's responsible for displaying the data. Not all data is text, we can have check buttons, icons, progress bars as well as just text.
04:32:27 <dcoutts> gour, in my opinon, yes.
04:32:35 <MarcWeber> ah
04:32:43 * gour thinks the same
04:33:10 <MarcWeber> So the 3. column of each row is of the same type..
04:33:14 <gour> in haskell we want + compile-time check for type safety, don't we?
04:33:25 <dcoutts> MarcWeber, and even text renderers have lots of properties that can be set from data in the model, eg the text colour, the font style, wether the text is editable etc.
04:33:39 <MarcWeber> got it
04:34:19 <dcoutts> MarcWeber, I'm not sure what you mean about the 3 columns and types
04:34:28 <MarcWeber> don't mind
04:35:10 <MarcWeber> dcoutts: And model can be of type [(Filename,date,permissions)] for instance?
04:35:20 <dcoutts> MarcWeber, yes
04:35:38 <dcoutts> it'd be ListStore (Filename,date,permissions)
04:35:52 <dcoutts> a ListStore is one example of a TreeModel
04:36:03 <dcoutts> there's also TreeStore and you can write custom ones
04:39:29 <shapr> f
04:39:34 <shapr> doh, EWRONGWINDOW
04:42:42 <MarcWeber> dcoutts: The model beeing used in #1 and #2 are the same ? So I can map from arbitrary source (eg. database) anyway?
04:42:58 <dcoutts> MarcWeber, right
04:47:38 <MarcWeber> dcoutts: Where is the difference between a store (model) and a model?
04:49:01 <dcoutts> there isn't any really
04:49:17 <dcoutts> one is an interface and the other an impleentation
04:49:23 <dcoutts> a TreeModel is an interface
04:50:19 <dcoutts> there are a couple existing implementations of that interface called ListStore & TreeStore
04:50:28 <dcoutts> the 'Store' part of the name is just confusing
04:50:55 <dcoutts> I guess they were called that because they store the data themselfes rather than getting it from some external source
04:51:05 <MarcWeber> If I want to use some dtabase I have to write my own implementation of an interface, right? 
04:51:11 <dcoutts> right
04:51:22 <dcoutts> unless someone else wrote it first :-)
04:51:42 <dcoutts> eg a TreeModel implementation based on an HSQL query
04:54:27 <dcoutts> I'm planning to write a TreeModel implementation that gives a live view of a file sytem
04:54:35 <dcoutts> so it can be used as a file browser
05:01:21 <MarcWeber> dcoutts: you have some widget=view displaying your data. You have the data = model. You want some abstraction and will therefore use an interface (to use datat from datatypes, databases, files and so on). You have a renderer which "paints" the contents into each cell. This is common to #1 and #2, isn't it?
05:01:44 <dcoutts> MarcWeber, yes
05:01:44 <MarcWeber> Does the renderer differ from #1 and #2?
05:01:54 <dcoutts> no, the renderer are the same in both
05:02:17 <dcoutts> it's just wether the view knows the type of the data it is displaying or not
05:02:57 <dcoutts> if it does know it then binding renderer attributes to data from the model is easier
05:03:19 <dcoutts> but it also means that the widget carries a type parameter which has some difficulties with it
05:04:00 <MarcWeber> Why should it? It's task is to provide a drawing context, isn't it? Knowing the type isn't enough anyway.. because knowing that it should draw some text dosn't answer the question from left to right? colored? and so on.
05:04:31 <MarcWeber> But you have to tell the view the type first so that it "knows"
05:05:08 <dcoutts> well the view is the thing that remembers the mappings between data in the model and the visual attributes of the renderers
05:05:25 <dcoutts> so it's not jsut an untyped drawing context
05:06:00 <dcoutts> to set up the mapping from the data to the renderers you definatley need to know the type of the data
05:07:04 <dcoutts> under proposal #1, the model gets passed in *again* when you setup the mappings, in proposal #2 the view knows the type of the model so there is no need to pass it in again when setting the mappings
05:07:13 <Beelsebob> so anyway... I'd just like to say... hehehehehhehehehe http://www.cs.kent.ac.uk/people/rpg/tatd2/hehehe.jpg
05:07:57 <dcoutts> Beelsebob, what's that?
05:08:03 <Beelsebob> dcoutts: my new monitor *g*
05:08:11 <dcoutts> oh, nice and large
05:08:12 <Beelsebob> apple 20" cinema display
05:08:30 <Beelsebob> all the better for seeing Haskell with
05:08:32 <dcoutts> it's even bigger than my 21" crt !
05:09:06 * dcoutts got his 21" CRT monitor for £40 so he can't complain
05:09:20 <Beelsebob> hehe
05:09:29 * Beelsebob got his 20" LCD for £450
05:09:36 <shapr> I'd rather have an LCD, CRTs give me a headache.
05:09:40 <Beelsebob> ditto
05:10:01 <shapr> Might not give me a headache if I used them less than fifteen hours a day though.
05:10:10 <Beelsebob> heh
05:10:34 <Beelsebob> tbh, this one's so bright it might give me a headache... *turns brightness down*
05:11:04 <Beelsebob> ohhh wow - it must do some funky work to do that - it does semi-transparent overlays when you fiddle the brightness
05:12:42 <shapr> I just wish I'd gotten an LCD that had DVI... this is a hand-me-down.
05:16:32 <MarcWeber> dcoutts: I think I have problems with passing or storing a type. Can you store a datatype in haskell. Can you do let a=Int or let b=String?
05:17:34 <mauke> whoa, runtime typing?
05:17:38 <dcoutts> MarcWeber, no you can't really. You "pass a type" by having a variable with a polymorphic type.
05:18:47 <MarcWeber> dcoutts: such like Maybe?
05:19:00 <dcoutts> MarcWeber, right
05:20:48 <MarcWeber> dcoutts: I still don't get the point. You can choose different renderers, can you?
05:21:38 <dcoutts> MarcWeber, I'm not sure what the point you're talking about now. Yes we can choose a variety of renderers. See the example in the email.
05:21:42 <dcoutts> http://sourceforge.net/mailarchive/forum.php?thread_id=9669932&forum_id=8415
05:21:56 <dcoutts>   renderer1 <- cellRendererTextNew
05:21:56 <dcoutts>   renderer2 <- cellRendererTextNew
05:21:58 <MarcWeber> If so I think the view should'nt bother bout type because it just takes the renderer and tells it: Paint on my drawing context, right?
05:22:03 <dcoutts> oh they're both text renderers
05:22:12 <dcoutts> but you can use other ones
05:22:42 <MarcWeber> ImageRenderer Or TextRendererUsingAALib ;-)
05:22:51 <dcoutts> MarcWeber, right, but how do you get the data from the model to the renderers if you don't know the type of the data?
05:23:10 <dcoutts> we must know the type of the model to be able to get any data out of it
05:23:39 <dcoutts> the options are that we get the type of the model by passign the model to the treeViewColumnSetAttributes
05:24:16 <dcoutts> or we get it my the view knowing the type itself (which happens automatically when you set the view's model)
05:24:41 <dcoutts> MarcWeber, each view is attached to a model. The model is a property of the view.
05:25:29 <MarcWeber> Why so?
05:25:45 <dcoutts> why is the view attached to a model?
05:26:00 <dcoutts> becaue it is a view of a model, that is its purpose
05:26:13 <dcoutts> to visualise the data in a model
05:26:18 <MarcWeber> Yeah.. the view dosn't need the model data.. All it needs to know is : How is the height of my rows and which renderer to use.
05:26:51 <dcoutts> well in that case you must think that the renderers need to know the type of the data in the model
05:27:09 <dcoutts> something needs to know the type of the data in order to visualise it
05:27:42 <MarcWeber> Yeah.. and they need to know anyway because they have to interpret the data (eg. calling some paintText function.. or some putImageHere function).. But why does the view need to know?
05:27:55 <MarcWeber> That's odd
05:28:12 <dcoutts> the way Gtk+ factors things is that the renderers are generic and just have attributes that can be set, and then the view is the thing that sets the renderer's attributes and tells them to draw themselfes for eahc row that is currently visible.
05:28:24 <dcoutts> the renderers are jsut passive
05:28:33 <dcoutts> they do not actively get the data from the model
05:28:55 <dcoutts> they rely on the view to get the data from the model and tell the renders what data to draw
05:29:23 <dcoutts> this makes sense because it's not just displaying that the model does, it can also do things like interacive search
05:29:42 <dcoutts> so as you type, it looks throguh the data to find a matching row
05:30:03 <dcoutts> that is why the view is connected to a model.
05:30:56 <MarcWeber> Yeah only the view can scroll to the right row asking the user: this one?
05:32:55 <dcoutts> MarcWeber, exactly
05:43:29 <MarcWeber> dcoutts: Is the data handed over to the renderer by pointers in gtk?
05:44:23 <dcoutts> MarcWeber, there are a couple ways we can implement it, either by passing the data via pointers on the C side, or by passing the values on the Haskell side.
05:45:01 <MarcWeber> dcoutts: How can you pass data (from model to renderer) without type?
05:45:07 <dcoutts> Either way, if we don't want to convert all the data via a "GenericValue" then we need to know the type of the data.
05:45:10 <MarcWeber> Because you have to pass the data anyway..
05:45:47 <dcoutts> MarcWeber, on the C side the techique is to use a union of all the different types and a GType code.
05:45:51 <MarcWeber> I have to have look at that data interface (stores or whatever)..
05:46:08 <dcoutts> and the model tells you the type of each column
05:46:18 <dcoutts> but we're trying to make the interface more Haskelly
05:46:30 <dcoutts> so you don't have to deal with the low level stuff
05:47:06 <dcoutts> so we don't want people to think about having int-indexed columns in the model or conversions via generic values.
05:49:29 <MarcWeber> dcoutts: and the haskell way would be provide an interface of your data of type xy (with xy beeing (filename, data, perm) for instance) and to implement a renderer an extra renderer class for type (filename, data, perm) ? with haskell view not bothering because it only sees type xy which it passes to renderer. GHC in turn would implement the rest for us, right?
05:50:07 <dcoutts> MarcWeber, you'd use the standard renderers. No need to implement your own.
05:50:24 <MarcWeber> standard from gtk?
05:50:29 <dcoutts> right
05:50:50 <dcoutts> you'd map the filename to a text renderer and the others probably to text renders too (via some conversion perm -> String for example)
05:51:15 <dcoutts> in the example we had
05:51:16 <dcoutts> data Phone = Phone { name :: String, number :: Int, marked :: Bool }
05:51:27 <dcoutts> and: model <- listStoreNew ...
05:51:36 <dcoutts> which gives us a TreeModel Phone
05:51:48 <dcoutts> we then say:
05:51:49 <dcoutts> treeViewColumnSetAttributes col1 renderer1 model
05:51:49 <dcoutts>     (\phone -> [cellText := name phone,
05:51:49 <dcoutts> 	        cellBackgroundSet := marked phone])
05:52:14 <dcoutts> that is we set the text attribute of the renderer from the name field of the phone data
05:52:34 <dcoutts> or under proposal #2 it is the same except that we don't need to pass the model to treeViewColumnSetAttributes
05:53:32 <dcoutts> so what the above code does is bind the text attribute of renderer1 (which is in column1) to the name field in each row of the model
05:53:49 <dcoutts> ie we display the name field in the model
05:55:39 <MarcWeber> The haskell way would be: here have the types (filename, perm, ..) for each col now choose the right render for me..., wouldn't it? and of cause you would have to implement some filename render which in turn would call standard gtk render telling (this way telling you have type string) and use color orange and underline if isexecutable(filename).. oh it's getting complicated.. Just a thought.
05:57:50 <dcoutts> MarcWeber, I don't think it's sensible to pick the renderer based on the type of the data. There are many options that people might want, not just some default. Besides doing the obvious simple thing (eg String data gets a text renderer) is not difficult to set up.
05:58:13 <MarcWeber> Why not?
05:59:10 <MarcWeber> Can you think of an example where type of data and the data itself isn't enough ta call the correct gtk renderer with attributes?
06:00:15 <MarcWeber> bool would be mapped to chekbox renderer automatically..  if you want to map 0 1 to checkbox you can use a fmap function to "convert" 0, 1 to True/False..
06:00:47 <dcoutts> what about where I have some Bool data in the model that should be mapped to the colour of the cell background of a text renderer.
06:00:59 <dcoutts> eg to highlight some rows
06:01:08 <MarcWeber> the marked example?
06:01:12 <MarcWeber> aeh...
06:01:22 <dcoutts> exactly
06:01:24 <dcoutts> treeViewColumnSetAttributes col1 renderer1 model
06:01:24 <dcoutts>     (\phone -> [cellText := name phone,
06:01:24 <dcoutts> 	        cellBackgroundSet := marked phone])
06:01:46 <dcoutts> the cellBackground attribute gets set to red when the marked field is true 
06:01:50 <MarcWeber> I remember
06:02:00 <MarcWeber> wait.. I have to think.. 
06:02:03 <dcoutts> it's quite flexible
06:02:17 <dcoutts> we're happy to expose all that flexibility
06:02:39 <dcoutts> the stuff we want to hide is the low level nonsense that I've hardly told you about
06:03:11 <dcoutts> just being able to use Haskell types & values is a major improvement and makes it much easier to use.
06:03:34 <MarcWeber> Are you talking about multiple selection now?
06:03:42 <dcoutts> no
06:04:36 <MarcWeber> about checked, unchecked, grayed? 
06:05:09 <MarcWeber> or status as backgroundcolor (red=failure/green=ok/white no check yet) ?
06:07:52 <MarcWeber> You would be able to solve this problem generally this way: (filename, perm, size, marked) -> ((name, marked), (perm, marked), (size, marked))
06:09:14 <MarcWeber> Then you could introduce a renderer of type (a, marked) which paints the background "blue" and then calls standard render for type a to paint the text or image or whatever.
06:11:17 <dcoutts> MarcWeber, is it not simpler just to map the row to attributes of renders using arbitrary Haskell functions?
06:11:33 <dcoutts> eg name :: Phone -> String
06:11:49 <dcoutts> and then: \row -> [ cellText := name row ]
06:13:51 <MarcWeber> Think of having a model like this [(name, phone, sex, birthdate)].
06:15:10 <MarcWeber> Then you would use one map function  maptostandardtypes:: (name, phone, sex, birthdate) -> (String, String, String, String)
06:15:53 <MarcWeber> use fmap maptostandardtypes mymodel and give this result to the view..  haskell will see String, STring, String and will use the default String renderer. Is this more complicated?
06:17:41 <MarcWeber> Of if you want to use some symbol instead of "m","f" you could use another map function (_, _, sex, _) -> (_, _, image,  _) and you would be done
06:19:14 <Beelsebob> shapr: what does the fortune path for lambdabot need to point at?
06:24:31 <goron> If I want to thread the current state of the state monad to subcomputations, (and not let them interfere), then the onyl way to do so it to pass the state to that subcomputation right?
06:24:47 <goron> s/onyl/only
06:29:08 <shapr> Beelsebob: Any fortune file, iirc
06:29:21 <shapr> er, wait, any directory with fortune files in it?
06:29:26 <Beelsebob> oh... odd
06:29:33 <Beelsebob> it can't find mine
06:29:37 <shapr> I should really turn that into a command line program when I get some spare time.
06:29:56 <shapr> Strange.. You're using a file with \n%\n dividers?
06:30:28 <psi> Does anyone know what this error means, which I get when trying to compile the example from the hs-plugins docs:
06:30:33 <psi> /usr/bin/ld: table of contents for archive: /usr/local/lib/plugins-1.0/libHSplugins-1.0.a is out of date; rerun ranlib(1) (can't \
06:30:36 <psi> load from it)
06:30:39 <psi> collect2: ld returned 1 exit status
06:31:28 <shapr> goron: reader monad
06:32:16 <psi> oh, I'm on os x.
06:32:23 <shapr> goron: For example, lambdabot uses a read-only monad to pass around global configuration, and stacks that on top of a readwrite monad.
06:32:30 <psi> and I use the ghc from their website.
06:33:26 <edwinb> I get that error on OSX a lot. I've no idea why, but I just do what it says...
06:36:58 <psi> edwinb: yeah, it worked after that
06:37:49 <psi> when you say you get it a lot, do you mean also with other haskell libraries?
06:39:29 <edwinb> usually with stuff I've built
06:39:38 <edwinb> not just haskell
06:39:45 <edwinb> I should probably try to find out why it happens
06:40:08 <kosmikus> question: does sml support mutually recursive modules?
06:44:38 <MarcWeber> dcoutts: Have to go now
06:44:45 <goron> shapr: indeed, that seems a nice alternative. Still I will first try to do it with the State monad first. 
06:45:41 <shapr> Yeah, simplicity is always a good choice. Still, lambdabot is worth looking at if you want to use the stacked read only and read write pattern.
06:47:04 <goron> shapr: to be honest, I don't think I will understand it in such a way that I would be able to use it. 
06:47:47 <goron> shapr: I need to get some experience first before I can do anything remotely useful, I think.
06:48:05 <shapr> You could read the section of nomaware's monad tutorial that deals with monad transformers.
06:48:08 <shapr> It's really good.
06:48:43 <shapr> It's also really neat from a software engineering perspective.
06:49:11 <shapr> I'm convinced that monad transformers are significantly better than OOP because I believe they have a lower Big O notation complexity for *changes* .
06:49:43 <shapr> I've never heard of anyone else describing the complexity of abstractions with Big O notation, but I've started using it.
06:50:21 <goron> shapr: I read it, and I understood it, but thinking of this stuff myself, is something else.
06:50:49 <goron> shapr: yes, we discussed that earlier. 
06:51:03 <shapr> In my opinion, design changes to an OOP project have a worst case complexity that is the factorial of the number of *instances* used.
06:51:06 <goron> shapr: And we didn't agree :)
06:51:22 <shapr> Well, I'm still refining my thoughts on the matter, so I'd be happy to discuss it further.
06:51:33 <goron> shapr: What about CLOS? 
06:51:45 <shapr> What about CLOS? Do you mean multimethods specifically?
06:51:49 <goron> shapr: That's gigantically dynamic. 
06:52:10 <goron> shapr: I am sure it's possible to use it for good things. 
06:52:23 <goron> shapr: but it's also possible to use it wrongly.
06:52:28 <shapr> Oh sure, OOP is great stuff.
06:52:50 <shapr> I just think that monads have more advantages and fewer disadvantages.
06:53:17 <shapr> Of course, monads' largest disadvantage in comparison to OOP is sheer lack of advertising.
06:53:29 <goron> True
06:54:58 <goron> Can I do case blaat of Foo thingie -> do <monadic code>; OtherFoo otherthingie -> do <other monadic code?? 
06:55:40 <carp> dcoutts: I think the closest approximation for what we'd like epigram code to look like in a gui can be seen in any of Conor's recent papers on his webpage.
06:55:56 <dcoutts> carp, got a url?
06:56:21 <carp> http://www.cs.nott.ac.uk/~ctm/publications.html
06:56:41 <Igloo> carp: Is it different to the 2D syntax from a year or two ago with the ASCII approximations changed to nice parentheses etc?
06:56:41 <dcoutts> thanks
06:57:06 <edwinb> syntax highlighted papers. Excellent :)
06:57:19 <dcoutts> carp, ooh, nice. With colour and everything :-)
06:57:32 <carp> the regular tree types one might be best
06:57:51 <edwinb> An editor that could output the latex would be extra spangly.
06:57:51 <dcoutts> carp, that's the one I'm looking at
06:57:59 <carp> yeah, shame you have to turn the colour off when you submit it :)
06:58:08 <dcoutts> heh, yeah
06:58:39 <dcoutts> yellow sheds? hmm
06:58:54 <shapr> I've often wished for color in research papers.
06:59:03 <Igloo> dcoutts: Weren't you at the AFP we did this at?
06:59:26 <Igloo> Maybe deluxe colour proceedings should be available for suitable extra charge  :-)
06:59:28 <dcoutts> Igloo, yeah, I saw the xemacs ascii graphics with sheds etc
06:59:57 <dcoutts> Igloo, I don't remember exactly what all the colors were or signifiied
07:00:03 <shapr> Who did the gorgeous multi-colored hand-drawn quantum programming presentation at ICFP03?
07:00:05 <Igloo> OK; looks about the same to me
07:00:18 * shapr looks at his copy ofthe proceedings...
07:00:44 <carp> edwinb: have you had a look the recent epigram 2 code?
07:01:09 <carp> edwinb: it would be cool to link up your evil ghc core stuff to that
07:01:09 <gour> Lemmih: ping
07:01:24 <dcoutts> carp, so how do you enter some of the more exiotic notation like the fancy [| |] brackets and superscript and unicode chars \phi \Delta etc?
07:01:29 <edwinb> Yes, it would be a nice fun hack if nothing else
07:01:42 <edwinb> I haven't tried compiling any of the epigram 2 stuff though
07:01:44 <dcoutts> carp, in an editor I mean, not in latex source
07:01:58 <edwinb> I should give it a go, but I should also get back to doing what I'm actually meant to do ;)
07:02:00 <carp> you don't, the paper is written in imaginary epigram
07:02:15 <dcoutts> carp, I mean, I imagine we can draw that stuff but I've no idea how you'd input it! :-)
07:02:28 <carp> or rather, it's translated into it
07:02:32 <dcoutts> carp, except \latex style perhaps :-)
07:02:42 <shapr> I still want a nice presentation of deptypes sometime.
07:03:43 <edwinb> So do I...
07:04:02 <dcoutts> carp, well the imaginary epigram notation is certainly pretty
07:04:12 <edwinb> None of us seem to know how to present it though
07:04:19 <carp> dcoutts: how are you going to deal with ghc's unicode support in hide?
07:04:40 <dcoutts> carp, by using unicode in the editor. That's easy.
07:04:50 <dcoutts> carp, how people input it is less obvious
07:04:54 <carp> latex style commands would be ok i suppose
07:05:01 <dcoutts> there are X/Gtk+ input methods
07:05:01 <carp> dcoutts: that's what i mean
07:05:52 <dcoutts> you can set up system wide XIM stuff to use control sequences to enter special chars
07:06:03 <dcoutts> and that will "Just Work"tm with hIDE
07:06:33 <dcoutts> because it's just using the ordinary X/Gtk+ input system, the prog just recieves UTF8 input
07:06:37 <carp> suppose you could have ascii synoyms (like ->) which get overwritten
07:06:51 <dcoutts> that's a possability, but not everyone will like that
07:07:56 <dcoutts> carp, the most basic thing is just to allow the Russians to write comments/strings/variables in Russian
07:08:08 <dcoutts> because they've already got their keyborads set up to do that
07:08:15 <carp> ah i see
07:08:18 <dcoutts> same with other European languages
07:08:21 <dcoutts> that will just work
07:08:31 <dcoutts> it's non-standard symbols that are the problem
07:08:43 <dcoutts> ordinary XIM doesn't do that much
07:09:36 <resiak> You could use vim-like digraphs?
07:09:52 <dcoutts> what's that?
07:10:11 * dcoutts is not a vim poser user, only a casual user
07:10:15 <dcoutts> poser/power
07:10:24 <carp> :)
07:10:24 <shapr> punny typo :-)
07:10:28 <dcoutts> heh, poser :-)
07:10:46 <resiak> dcoutts: It's like <compose> in X. ^K ' e gives me é, for instance. The digraphs are configurable
07:11:10 <dcoutts> resiak, if that works in X then it will work with hIDE
07:11:13 <shapr> Same for x-symbol in emacs, where C-" e " gives e with dots.
07:11:22 <dcoutts> I think that's what the XIM stuff does
07:11:24 <dcoutts> or can do
07:11:25 <shapr> er, C-=
07:12:04 <resiak> dcoutts: Sure, but vim digraphs are trivially easy to add to, and (for instance) ^K(_ => ⊆ is already set up
07:12:23 <resiak> Anyway, just a suggestion.
07:12:52 <dcoutts> Yeah, I'm sure we could do somthing like that where we map some otherwise unbound control char sequences to unicode symbols
07:13:00 <goron> http://paste.lisp.org/display/16589
07:13:00 <dcoutts> thet'd want to be user configurable
07:13:15 <goron> I get an error about  the use of let. 
07:13:18 <resiak> *nods*
07:13:20 <goron> Could anyone take a look?
07:13:26 <dcoutts> and another easy thing would be to povide a unicode symbol char map in a tool tab.
07:13:49 <resiak> Hmm, someone really ought to write a handy tool to set up X <compose> sequences.
07:13:54 <dcoutts> that'd be easy to use to start with (as in easily discoverable)
07:14:04 <goron> I want to use a let inside the result of a case construct in combination with do. 
07:14:09 <resiak> That someone could be me. *adds to TODO*
07:14:22 <dcoutts> and then as you used them more frequently you could learn/set up shortcuts
07:15:00 <Igloo> goron: What's the problem?
07:15:24 <goron> Igloo: I get a parse error
07:15:35 <goron> Igloo: at baz
07:16:05 <Igloo> Put complete code somewhere please
07:16:48 <carp> the major things i suppose for epigram are a decent representation of inductively defined types and the fact that the system writes some bits of the program for you
07:19:51 <carp> dcoutts: do the undergrads at Oxford do gtk2hs?
07:19:52 <goron> Igloo: Hmm, I don't understand, I made a simple example, and that does work. I can't put the code online. 
07:20:06 <dcoutts> carp, yes, indirectly.
07:20:15 <Igloo> goron: Something I can try loading myself
07:20:22 <dcoutts> carp, we don't make first years use the gtk2hs api directly however.
07:20:52 <goron> Igloo: Yes, I tried to do that, but that didn't expose the error.
07:21:21 <dcoutts> carp, but I did run a practical last term where first years wrote a program which produced lists of lines which got drawn using a gtk2hs GUI module that was provided to them.
07:21:40 <carp> cool, we should do stuff like that in nottingham i think
07:21:52 <dcoutts> http://haskell.org/gtk2hs/archives/2005/11/01/university-courses-using-gtk2hs-for-teaching/
07:21:57 * Igloo can't help if you can't show me the problem
07:23:06 <dcoutts> carp, and they used it this year at mit.jyu.fi too. http://www.mit.jyu.fi/antkaij/opetus/fo/2005-2006/
07:23:58 <gour> dcoutts: which ghc do you use for building  hiDE. the one mentioned by Lemmih (in README) gives: Distribution/Compat/FilePath.hs:2: Cabal/Distribution/Compat/FilePath.hs: No such file or directory
07:24:22 <dcoutts> gour, you need the libs too to build ghc
07:24:39 <carp> So you think it's too complicated to teach the undergrads to write gui's in their first haskell course?
07:24:50 <goron> Igloo: I see, the problem is in the record construction, it had nothing to do with the let. I do MyState{f a1 a2 a3, tree}
07:25:01 <goron> Igloo: I think that syntax is simply invalid. 
07:25:21 <Philippa> carp: I walked out of the first haskell course not knowing how to do IO, and I only missed one lecture IIRC
07:25:24 <Igloo> It is
07:25:30 <edwinb> It's nice to at least show undergrads that you can write "real programs" in Haskell
07:25:32 <goron> Igloo: I.e. that the identifiers are obligatory. 
07:25:35 <Igloo> You want MyState { foo = bar, ... }
07:25:39 <Philippa> edwinb: agreed
07:25:41 <dcoutts> carp, no, actually I think it's great, because althoguh they wern't doing anything very advanced with GUI stuff, it show them that it's possible to do in Haskell, ie Haskell is not a useless toy.
07:25:46 <edwinb> We never learned IO
07:25:50 <Igloo> Or you can use it as a normal constructor   MyState bar ...
07:26:01 <edwinb> And someone did once say to me "It's very nice, but you wouldn't write a compiler in it would you?"
07:26:07 <edwinb> *chortle*
07:26:09 <Philippa> also, FUN happens at a point where people're still really learning the Java GUI libs, it's a bit much to expect most people to latch onto another one in a couple of lectures
07:26:09 <goron> Igloo: that's what I thought. My Haskell knowledge is rusty.
07:26:43 <dcoutts> carp, the practical I ran didn't involve them doing much gui stuff themslves. All the code they wrote was pure. But the fact that we provided a non-trivial GUI to visualise their results made them see that GUIs are possible.
07:26:57 <Philippa> if you just want to do a couple of hello world/fill in a form type things as an example I guess that'd work better than the little game we got as a 'real world example' though
07:27:15 <carp> dcoutts: that's a good way to do courseworks i think
07:27:26 <resiak> dcoutts: I showed someone from my year your practical the other day, actually, because he didn't believe that Haskell could do useful things. He's surprised, but still doesn't see the point :(
07:27:29 <Philippa> yeah
07:27:34 <dcoutts> carp, I think in the past we have had the problem that first years get the impression that Haskell is a useless toy and so they ignore what we're trying to teach them.
07:28:11 <edwinb> Students often don't believe you're teaching them useful stuff ;)
07:28:18 <Philippa> yeah, people I've talked to here think that when I tell them I hack in it
07:28:58 <dcoutts> carp, so by showing them it's possible to build GUIs and database & web stuff - but not actually teaching them those practical things, we get them to pay more attention to the theory we're teaching them because they've not already displissed it as useless.
07:29:11 <carp> yeah, Conor often mentions edinburgh ml practicals where the students write a small component that plugs into something larger that does something interesting
07:29:38 <carp> sounds very sensible
07:29:46 <dcoutts> so show them it's *possible* to do boring practialc businessy things but don't actually make them do it
07:29:48 * edwinb vaguely remembers Conor describing the "Washing Machine" practical...
07:30:02 <carp> edwinb: that's the one ;)
07:30:10 <edwinb> Ah, good, I wasn't imagining it :)
07:30:16 <psi> eek. I get this when I use toUpper in a hs-plugin:
07:30:18 <psi> unknown symbol `_GHCziUnicode_toUpper_closure'
07:30:18 <psi> a.out: user error (resolvedObjs failed.)
07:30:21 <carp> edwinb: he likes to get maximum mileage from his stories :)
07:30:24 <dcoutts> carp, next year I'm going to do it in 3D! :-)
07:30:25 <edwinb> hehe
07:30:43 <dcoutts> so like this, but 3D:
07:30:44 <dcoutts> http://haskell.org/gtk2hs/gallery/apps/oxfordlsystem
07:31:01 <dcoutts> http://haskell.org/gtk2hs/gallery/OpenGL/HaskLS
07:31:18 <carp> cool
07:31:48 <dcoutts> so the 3D pic from the second screenshot there, along with the widgety part from that first screenshot
07:32:09 <dcoutts> well it'd be an optional extension, I'd start with 2D
07:32:16 <kosmikus> edwinb: is there anything in particular I should cite when I'd like to refer to epigram's ability to perform "code inference"?
07:32:56 <dcoutts> carp, this year I had optional extensions like adding randomness to the tree generation and having the colours change etc.
07:33:04 <edwinb> By code inference do you mean, for example, proof of impossible cases?
07:33:05 <carp> cool
07:33:19 <edwinb> I'm not sure there's anything more written down than the rules in View from the Left.
07:33:27 <kosmikus> edwinb: yes, elimination of impossible cases, and filling in cases that have a unique answer
07:34:24 <kosmikus> edwinb: ok
07:34:25 <edwinb> It's all just the elaboration rules really.
07:46:18 <carp> kosmikus: i think the impossible cases are thrown out by the unifier and described in "eliminating dependent patter matching" and the code inference for trivial cases hasn't been implemented and i'm not sure if it's written up anywhere
07:46:47 <carp> not that sure though
07:48:05 <kosmikus> carp: thanks. I thought it was written up somewhere ... But I probably confuse it with a live discussion I had with Conor.
07:48:11 <vincenz> @fptools getContents
07:48:12 <goron> How can I catch error? 
07:48:12 <lambdabot> getContents not available
07:48:16 <vincenz> @libsrc getcontents
07:48:17 <lambdabot> getcontents not available
07:48:19 <vincenz> @libsrc getContents
07:48:20 <lambdabot> getContents not available
07:48:42 <mauke> goron: what error?
07:49:02 <goron> mauke: if a function uses error "oh, no".
07:49:29 <mauke> you can't
07:49:45 <goron> mauke: Data.Map.! uses error when an element can't be found.
07:50:15 <goron> Then how on Earth can I know without killing the program whether there's such an element?
07:50:45 <goron> Never mind
07:50:51 <goron> There's member
07:50:59 <goron> Still it's inefficient
07:51:06 <mauke> use lookup
07:52:50 <goron> mauke: you are right, I was wrong. :)
07:56:23 <edwinb> Hmm, Eliminating dependent pattern matching. I haven't read that. I should...
07:57:28 <goron> mauke: there's a way to catch error though in GHC. 
07:57:44 <goron> mauke: It uses ErrorT and the identity monad.
07:57:58 <mauke> whoa
07:58:29 <goron> Anyway, this algorithm is becoming way too complex. I think I will go back to the drawing board. (Or just implement it in an Algol language(e.g. Java)). 
07:58:54 <goron> But I will give Haskell a try first, later :)
07:58:55 <goron> Bye
08:00:32 * shapr wonders what algorithm goron was implementing...
08:08:51 * vincenz had a nightmare where he was in some browser that resembled a lot to IE, which instead of using google used it's own search cache, and I couldn't find DARCS, and for some reason it was life-threatening to not finid it ini a given amount of time
08:10:04 <shapr> vincenz: wow, nifty
08:10:31 <vincenz> well not nightmare, but one of those struggling dreams
08:10:37 <vincenz> and the problem is that htey make you wake up with a headache
08:10:53 <Igloo> Yeah, if it was a nightmare you'd have had to use CVS instead!  :-)
08:11:01 <vincenz> hehe
08:11:35 <shapr> I had a recent nightmare where I had a Java job and had only tools that could do Haskell, and that I could only think about programming in Haskell. After waking up, I wasn't sure if it was so far off from the truth.
08:12:21 <shapr> I have a Python job, and my clients think Python is risque by itself.
08:12:44 <shapr> I guess the worst nightmare would be to have a life of satisfying Java work, and then find Haskell after retiring.
08:14:40 <tromp_> the worst nightmare would be recycling motherboards in some chinese factory for pennies a day:(
08:14:54 <shapr> Yeah, true.
08:15:00 <tromp_> as far as IT jobs go:)
08:15:55 <vincenz> tromp_: or writing c-code banking code
08:16:00 <resiak> the worst nightmare involves human skins functioning as potato skins, but maybe that's just me
08:16:13 <vincenz> resiak: that's not it-related
08:16:22 <vincenz> resiak: and I fail to see ho
08:16:23 <vincenz> hw
08:16:24 <vincenz> ...how
08:16:40 <shapr> If it's a nightmare, I don't want to know.
08:18:59 <resiak> vincenz: No-one ever explicitly stated it had to be IT-related. I just assumed that these were general worsts :P
08:19:58 <tony2> shapr, is T.M.R. dead, or just hibernating?
08:21:08 <shapr> tony2: dunno really...
08:21:26 <shapr> I think I'm going to kick out one last issue and shut it down after that.
08:21:43 <shapr> I got tired of chasing after authors.
08:22:16 <tony2> Fair enough, I enjoyed it very much, but I suppose you have to compete with the wiki.
08:22:17 <shapr> So when my current insane deadline pressure is over, I'll have time to setup that last issue.
08:22:41 <shapr> Well, not really. TMR was there to be something halfway between a wiki page and a research paper.
08:23:07 <shapr> Plus I was running the wiki and TMR at the same time, so I didn't mind if someone would rather devote their energy to writing wiki pages.
08:23:16 <shapr> I'm glad you enjoyed it :-)
08:23:56 <shapr> The whole idea was to collect and refine some of the brilliant discussions I've seen go past here on #haskell.
08:24:18 <tony2> Well, it's certainly a good concept.
08:24:33 <shapr> I plan on continuing the practice myself, I'm going to pick a subject and write a few pages about it on my blog.
08:25:05 <shapr> In the spirit of 'articles for motivated commercial programmers.'
08:26:04 <shapr> Seems like amortized complexity is an article I should write soon.
08:26:14 <tony2> motiveated commercial programmers? I'd say haskellers are better described as amatuers in their collaborative approach.
08:26:18 <dcoutts> shapr, ohh, that's fun
08:26:28 <shapr> tony2: What do you mean?
08:26:36 <tuomov> Maybe you should set up a Haskell article blog?
08:26:59 <dcoutts> shapr, you've read Okasaki's "Purely Functional Data Structures"?
08:27:02 <tuomov> I think that would be the ideal medium for such things. Publications with fixed publication dates are dead.
08:27:11 <shapr> tuomov: That's a good idea, but I'd rather stay out of community organization for the moment. You want to do it?
08:27:14 <dcoutts> shapr, I never understood amortized complexity until reading that
08:27:41 <dcoutts> shapr, and how closely it's related to careful use of lazyness
08:27:55 <shapr> dcoutts: I don't understand it yet, as I haven't read Okasaki's work. But it seems that amortized complexity has been confused with amortized analysis, so I would do well to understand both of them and then write a compare/contrast article.
08:28:04 <tuomov> You could just mention somewhere (the wiki etc.) that there's a blog for haskell articles, and if someone has an article, please contact
08:28:37 <dcoutts> shapr, unless I'm very much mistaken, one is a technique for proving the other.
08:28:41 <tuomov> I'm not sure what would be the best way to store the articles, though
08:28:55 <shapr> tuomov: Or I could set up a darcs-cgi-push repo and anyone with access add more gpg keys to it, that way any member would be able to add new authors and new articles.
08:29:08 <tuomov> that's one possibility, yes
08:29:31 <shapr> But the current ScannedInAvian.org is going down as soon as I have time to do that.
08:30:01 <shapr> I'm moving to a virtual host because of my current great need to cut costs.
08:30:29 <shapr> That means that anyone with data currently on ScannedInAvian really needs to grab a copy and find a new home for it...
08:31:54 <dcoutts> Lemmih, are you paying attention? we need a new home for the hIDE repos on ScannedInAvian.org
08:32:20 <tony2> Couldn't the article blog be posted to a dedicated section on the wiki? KISS approach, I know it wouldn't be a blog really, but still. 
08:32:26 <tuomov> I've actually started writing rather lengthy blog articles about once every two weeks... I wonder if I could come up with something that would have some relevance to haskell
08:32:45 <shapr> tuomov: Pick a Haskell subject, and someone will probably be interested.
08:33:03 <tuomov> actually, the latest one does mention haskell..
08:33:09 <shapr> Even something as simple as a description of the spirit and uses of unfoldr for example.
08:33:15 <dcoutts> Lemmih, what's left on ScannedInAvian.org that you havn't moved to darcs.haskell.org ? is it just Yi?
08:34:31 <dcoutts> Lemmih, oh, no it's the hIDE repo itself. Should we move that to darcs.haskell.org too?
08:34:48 <shapr> My clients are being difficult at the moment. If anyone can point me to some Haskell or Python contract work, I'd be appreciative :-)
08:35:14 <dcoutts> shapr, I'll tell you if I spot anything
08:35:22 <shapr> Thanks :-)
08:37:32 <lispy> heh, unfoldr makes me head hurt
08:38:38 <shapr> lispy: Does that mean you want to write something about it?
08:39:15 * Speck hums
08:39:48 * shapr sings
08:40:47 <nothingmuch> where can i find a nice doc explaining the Functor class so that i can link it for idiots?
08:41:21 <shapr> You could write up a description and add it to the collection :-)
08:41:24 <Speck> isn't it worth making them smarter? a ct explanation would be nice...
08:49:33 <goron> Ok, I know what I want: I want map f xs, such that the state in the statemonad can be changed by every call of f, and such that every f possibly sees another state. 
08:50:02 <shapr> mapM ?
08:50:46 <shapr> @type Control.Monad.mapM
08:50:47 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
08:51:27 <Speck> @type Control.Monad.sequence
08:51:29 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:53:31 <davidhouse> i have a function that takes a parameter, x and returns [(a,Int)]
08:53:44 <davidhouse> i want to return a list containing just the pair (x,1)
08:53:57 <davidhouse> return [(x,1)] seems to be giving me problems
08:53:58 <araujo> Hello here...
08:54:01 <araujo> @yaw!
08:54:02 <lambdabot> I guess you guys got BIG MUSCLES from doing too much STUDYING!
08:54:04 <shapr> hola araujo 
08:54:10 <araujo> Hola shapr :-)
08:55:17 <akaariai> Is there a way to force ghc compiled program to use certain locale, or how can I make my program to stop converting '' to /204?
08:56:08 <liyang> davidhouse: drop the return, perhaps. :)
08:56:16 <dcoutts> @index unsafeForeignPtrToStorableArray
08:56:17 <lambdabot> bzzt
08:56:26 <dcoutts> @hoogle unsafeForeignPtrToStorableArray
08:56:26 <lambdabot> No matches found
08:56:41 <davidhouse> liyang, thanks, that seems to work.
08:56:52 <davidhouse> eurgh, i really don't understand where and where not to use return in haskell.
08:57:19 <mauke> @type return
08:57:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
08:57:32 <mauke> return is a function that puts things into monads
08:57:44 <edwinb> 'return' is used to inject a value into a monad. If you're not deliberately wanting to do that, you don't need it.
08:58:00 <davidhouse> ah. so it's completely different from 'return' in other languages?
08:58:04 <mauke> yes
08:58:05 <edwinb> yes
08:58:05 <shapr> yup
08:58:19 <edwinb> (actually, return (x,1) would have worked too. But that may just confuse...)
08:58:26 <mauke> [] happens to be a monad, so you could say return (x, 1)
08:58:34 <shapr> Because in Haskell, every function just 'evaluates' instead of 'executing.'
08:58:59 <nothingmuch> shapr, Speck: i used this: http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#functors
08:59:06 <goron> shapr: So, in map f [1,2,3], suppose f 1 puts something in the finitemap which is part of my state, then the f 2 application can find that value?
08:59:21 <shapr> nothingmuch: Oh speaking of which, Graham Klyne expanded that into a TMR article of the same name.
08:59:27 <nothingmuch> ah
08:59:33 <nothingmuch> good to know
08:59:33 <davidhouse> is Integral a subclass of RealFrac?
08:59:36 <shapr> goron: mapM will do that.
08:59:38 <nothingmuch> shapr++; # TMR
08:59:41 <shapr> :-)
08:59:42 <goron> shapr: s/map/mapM
08:59:48 <goron> shapr: great :)
09:00:03 <nothingmuch> now, all i need to do is figure out what this "notes" thing is in haskell. Is that like a monad?
09:00:05 <shapr> But you could also just do liftM2 map
09:00:11 <shapr> notes?
09:00:25 * Speck wishes the maps were unified :-|
09:00:33 <nothingmuch> shapr: it was a joke ;-)
09:00:41 * shapr snickers
09:01:04 <shapr> Anyway, it's worth looking through http://www.haskell.org/tmrwiki/CategoryArticle
09:01:23 <shapr> TMR ended up generating twenty five article so far, though five of them are still on the HaWiki
09:01:48 <goron> shapr: Don't I need a monad transformer for that?
09:02:22 <shapr> Nah, liftM and ap are the 'hard way' to do monad lifting.
09:02:37 <shapr> As the nomaware tutorial explicitly states :-)
09:03:06 <shapr> Look at section three, I think it explicitly compares the liftM / ap approach to monad transformers.
09:04:35 <Speck> I still don't understand monad transformers... I should see if anything clicks if I read about them again.
09:05:21 <shapr> Yes! Read about them again!
09:05:34 <shapr> Even better, do it with a mind to explain the whole thing to someone else, that tends to deepen the understanding.
09:06:34 <Speck> yeah. I've been spending all my time reading about GADTs and Yampa and Arrows...
09:06:53 <Speck> and the STG machine
09:07:08 <shapr> Arrow transformers are trivial.
09:07:39 <Speck> yeah I can conceptualize arrows better than monads usually
09:07:56 <shapr> I've always felt the same way.
09:08:06 <shapr> But once monads click, they're a lot easier to work with than arrows.
09:08:20 <Speck> but maybe it's just because I learned monads first, and I wasn't ready to really appreciate them
09:08:22 <davidhouse> is Integral a subclass of RealFrac?
09:08:35 <shapr> I learned Arrows first.
09:08:35 <Speck> I do identify monadic patterns occasionally tho
09:09:00 <Speck> subclass?! where?! :-P
09:09:28 <shapr> davidhouse: http://www.uni-bonn.de/~manfear/haskell-classhierarchy.php
09:09:46 <shapr> You can also look at the Haskell 98 spec for the same info.
09:09:53 <davidhouse> so no.
09:10:01 <davidhouse> that's weird.
09:10:10 <davidhouse> because i want to be able to feed integers into floor
09:10:26 <dcoutts> > floor 3
09:10:27 <lambdabot> 3
09:10:30 <davidhouse> i have some Integral x, and i want to be able to do floor $ x/2
09:10:40 <Speck> would I be wrong to loosely associate existentials to static duck typing?
09:10:57 <dcoutts> > floor ( fromIntegral (3::Int) / 2)
09:10:58 <lambdabot> 1
09:11:05 <dcoutts> > floor (  (3::Int) / 2)
09:11:06 <lambdabot>  add an instance declaration for (RealFrac Int)
09:11:06 <lambdabot>   In the definition of `jex': jex = floor ((3 :: Int) / 2)
09:11:06 <lambdabot>   In the definition of `v':
09:11:14 <davidhouse> @type fromIntegral
09:11:15 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:11:23 <davidhouse> aha :) thanks, dcoutts.
09:11:27 <dcoutts> np
09:11:49 <dcoutts> davidhouse, fromIntegral is the general purpose number conversion function
09:12:06 <dcoutts> it does integer to integer types and from integer to floating point types
09:12:26 <davidhouse> hang on
09:12:30 <davidhouse> @type floor
09:12:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:12:44 <davidhouse> if that wants a RealFrac, how does feeding it a Num work?
09:12:56 <shapr> fromIntegral can cause trouble sometimes though...
09:14:09 <shapr> in fact, SyntaxNinja is a good person to ask about that.
09:14:51 <dcoutts> evening SyntaxNinja 
09:15:16 <mauke> > 3 `div` 2
09:15:17 <lambdabot> 1
09:15:47 <mauke> > jex
09:15:48 <lambdabot>  Not in scope: `jex'
09:16:14 <davidhouse> > floor (fromIntegral(3::Integer)/2)
09:16:15 <lambdabot> 1
09:16:19 <davidhouse> :t div
09:16:26 <davidhouse> @type div
09:16:27 <lambdabot> forall a. (Integral a) => a -> a -> a
09:16:49 <davidhouse> hehe, that's simpler :)
09:17:40 <davidhouse> yay! it compiles :)
09:18:02 <Speck> is anyone familiar with the discrete event simulator that john hughes presented at AFP Summer 
09:18:05 <Speck> School 2004
09:18:26 <Speck> I haven't been able to find any information about it other than a post on the haskell ml
09:18:59 <shapr> I think I have the source for an early version.
09:19:37 <Speck> am I supposed to pay for it or something? I'd like to compare it to yampa
09:20:24 <shapr> I think it's freely available online. I think I've seen it, but I forget where.
09:20:50 <Speck> "The lecture notes of the school appeared as Lecture Notes in Computer Science, v. 3622 of Springer."
09:20:55 <shapr> John Hughes demonstrated it at EuroHaskell 2004, it ways cool :-)
09:20:58 <Speck> the acm portal doesn't have it :-(
09:24:28 <davidhouse> i need some advice choosing a data structure.
09:25:32 <davidhouse> basically, i want it to store a table of values, two columns (so possibly a list of pairs or some key -> value structure), and i want to be able to easily edit values in column 2 given values in column 1.
09:25:49 <davidhouse> hmm... that's actually sounding a lot like a key value structure.
09:26:24 <_Codex> davidhouse: array
09:26:37 <davidhouse> so, an array? i don't want the keys to necessarily be in ascending order. they might also have gaps, so like 2, 3, 6, 8 etc
09:27:16 <Saulzar> Map, or assoc list then
09:27:18 <dcoutts> davidhouse, so how about a Map
09:27:29 <dcoutts> Map key value
09:27:54 <_Codex> davidhouse: try array first, it might still work fine, even with gaps.
09:28:15 <davidhouse> maps... i've come across FinteMaps, could i use those?
09:28:17 <Saulzar> Why array with Haskell? They're not particually convenient for anything...
09:28:45 <dcoutts> davidhouse, see Data.Map, it's the replacement for FiniteMaps
09:28:50 <_Codex> saulzar: haskell arrays are pretty convinient. :)
09:28:50 <dcoutts> @docs Data.Map
09:28:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
09:29:14 <SyntaxNinja> hi shapr, dcoutts
09:29:26 <cjs_> I dunno, the infinite-length ones are not so convenient....
09:29:26 <Saulzar> _Codex, Compared to arrays in assembler, almost :)
09:29:57 <_Codex> saulzar: I'm thinking of the ixmap and fmap of arrays
09:30:25 <SyntaxNinja> davidhouse: data.map may or may not have come with your compiler.  FiniteMap is a fine choice for many things.
09:30:52 <davidhouse> i've got ghc 6.4.1, is that good enough?
09:30:59 <Saulzar> Yeah
09:31:55 <davidhouse> maps look easy enough.
09:33:19 <SyntaxNinja> @type lookup
09:33:20 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
09:33:24 <SyntaxNinja> @type Data.Map.lookup
09:33:24 <lambdabot> forall a (m :: * -> *) k.
09:33:24 <lambdabot> (Ord k, Monad m) =>
09:33:24 <lambdabot> k -> Data.Map.Map k a -> m a
09:34:25 <davidhouse> do i need to import anything to get maps?
09:34:31 <Saulzar> Monad m? What on earth for?
09:34:44 <mauke> for fail
09:35:13 <Saulzar> Hmm, and Maybe is too specific?
09:35:35 <Saulzar> davidhouse, Just Data.Map (the page you're looking at with the docs)
09:36:27 <mauke> why restrict yourself to Maybe?
09:37:05 <mauke> http://haskell.org/hawiki/NotJustMaybe
09:38:01 <Saulzar> It seems a more natural type, I guess that's fair enough it just seems like over-design
09:40:32 <palomer> why use Map when you can use List!
09:41:30 <Saulzar> why use quicksort when you can use bozo-sort :)
09:44:13 <palomer> bozo-sort!
09:45:16 <davidhouse> @pl \x y -> x + 1
09:45:17 <lambdabot> const . (1 +)
09:47:23 <Lemmih> gour: pong.
09:47:46 * palomer dares the   channel to find a combinator which cannot be pointlessified
09:47:52 * _Codex have been thinking that maybe it'd be possible to make Arrow instance for Map :)
09:48:07 <Lemmih> dcoutts: OK. I'll move hIDE/yi+gtk to darcs.haskell.org
09:48:13 <dcoutts> Lemmih, great
09:48:14 <shapr> Lemmih: thanks
09:49:07 <mauke> @pl \x -> x x
09:49:08 <lambdabot> join id
09:49:16 <mauke> @type join id
09:49:17 <lambdabot> Not in scope: `join'
09:49:56 <mauke> @type Monad.join id
09:49:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
09:49:57 <lambdabot>   Expected type: a -> a -> a1
09:50:26 <davidhouse> i want to print the contents of a map to stdout. what's the easiest way of doing this?
09:50:36 <shapr> show
09:50:57 <gour> Lemmih: i wanted to ask whether on can build hIDE with 6.4.1 & ghc-api - here it complains about ghc-any?
09:51:16 <davidhouse> shapr, that's useful :) thanks
09:51:32 <mauke> print
09:51:41 <mauke> @type print
09:51:42 <lambdabot> forall a. (Show a) => a -> IO ()
09:52:02 <Lemmih> gour: I'm not sure it's possible. You can try changing 'ghc' to 'ghc-api' in HaskellSense.
09:52:27 <gour> Lemmih: ok. and is it possible to use ghc-head?
09:52:31 <Lemmih> gour: Oh actually, I'm sure it's /not/ possible (:
09:53:13 <davidhouse> muake, print = putStr . show ?
09:53:16 <goron> shapr: and how can I make sure that some part is shared (the finite map), while some other part is not, but still avoid the threading issues?
09:53:31 <shapr> huh?
09:53:36 <Lemmih> gour: Sometimes. If you want to be sure then you can use the stable ghc-head.
09:53:37 <shapr> ik begrijp het niet
09:54:31 <Lemmih> gour: I don't think they've made any incompatible changes in ghc-head, yet.
09:54:47 <goron> shapr: I want to compute an intermediate result in "f" and put that in a statemonad, but I don't want that to interfere with the other calls to f within mapM.
09:55:35 <shapr> Do you mean you want to reference a shadowed value or something?
09:55:43 <goron> shapr: so, I want the finite map to be shared, while some other value is not. 
09:56:22 <shapr> Well, a statemonad doesn't really share the value. you have to explicitly go get it.
09:56:52 <shapr> So... just don't write that other value into the state monad?
09:57:00 <shapr> Am I misunderstanding your question?
09:57:04 <goron> I am confused now.
09:57:16 <goron> I will re-explain.
09:57:23 <palomer> Cale: you around?
09:57:32 <palomer> or astrolabe 
09:57:38 <palomer> @seen Cale
09:57:39 <lambdabot> Cale is in #haskell. Last spoke 6 hours, 31 minutes and 27 seconds ago.
09:57:41 <palomer> @seen astrolabe 
09:57:42 <lambdabot> astrolabe is in #haskell, #haskell-blah and #haskell-overflow. Last spoke
09:57:42 <lambdabot> 9 hours, 35 minutes and 11 seconds ago.
09:58:04 <shapr> I've started using Cale's trick of sleep 6.5h && play music
09:58:17 <gour> Lemmih: ok. i tried to build ghc from ghc.hide, but it fails
09:58:19 <shapr> though I've been using at 7am tomorrow \n mpc play 1
09:58:29 <shapr> goron: What algorithm are you implementing?
09:58:41 <Lemmih> gour: Oh, that's bad. How did it fail?
09:58:42 <palomer> cale sleeps at some screwed up hours
09:59:06 <gour> Lemmih: Distribution/Compat/FilePath.hs:2: Cabal/Distribution/Compat/FilePath.hs: No such file or directory
09:59:07 <shapr> Well, if it works for him...
09:59:54 <goron> I want to do some computation for every element of the list. I want that the finitemap basically is a global variable. But some other computations in f must create values, and I want them to be stored, such that they can easily be accessed within f, and I want them to report back. 
10:00:03 <goron> shapr: It's a new algorithm. 
10:00:14 <dcoutts> Lemmih, I guess the instructions need to point out what minimum set of libraries is needed to build ghc
10:00:23 <goron> shapr: No homework, completely new. 
10:00:41 <dcoutts> Lemmih, gour is probably missing all the libs under ghc/libraries/*
10:00:48 <dcoutts> Lemmih, eg base, Cabal etc
10:02:11 <shapr> goron: Oh I don't care if it's homework or not, just wondering if it's an algorithm where I could read a concise description on wikipedia and maybe give you some insights into a simple way to implement it.
10:02:18 <goron> shapr: is the finitemap given to the second element in mapM f xs, different from the first, when I change it in the first?
10:02:35 <goron> shapr: No, you won't find this on wikipedia :)
10:02:40 <shapr> ok
10:03:03 <shapr> If you're using FiniteMap to do something like a histogram, you could use the combine calls...
10:03:24 <goron> "combine calls"?
10:03:43 <goron> I think I should better just use a fold.
10:03:54 <shapr> finitemap has an explicit fold thingy...
10:04:09 <goron> I don't want to fold over the finitemap.
10:04:14 <shapr> Are you using Data.Map or really the old finitemap?
10:04:18 <goron> Data.Map
10:04:22 <shapr> oh, ok
10:04:24 <shapr> nm then
10:04:44 <shapr> It does seem that a fold will do for you.
10:05:05 <goron> shapr: so this mapM does not do what I want?
10:05:14 <shapr> In fact, you could use foldl and exploit the dissimilarity of its parameter types to pass the map along through the fold.
10:07:00 <shapr> goron: Well, you could always stash them in the map
10:07:23 <goron> shapr: We are not talking about the same, I guess.
10:08:23 <Saulzar> mapM is map for monads ... Map is not a monad instance
10:08:37 <shapr> Yeah, but he wants to have state.
10:08:43 <goron> shapr: I want the finite map to be like a global variable, and I want to get a list of results back. 
10:08:54 <goron> shapr: the results should be generated by f.
10:09:04 <goron> shapr: and every f modifies the global variable.
10:09:35 <Saulzar> Sounds right to use State, then you can use mapM
10:09:35 <goron> shapr: Is that more clear?
10:10:13 <goron> But the global variable should be modified by the calls to f.
10:10:21 <shapr> Yeah, should wokr
10:10:23 <shapr> work
10:10:25 <Saulzar> Right, that's the point of State
10:10:30 <goron> And, with mapM, I don't think that works.
10:11:09 <gour> dcoutts: i have gtk2hs-0.9.10.2 - it should be ok for hIDE?
10:11:12 <Saulzar> mapM with state "iterates" your function with state
10:11:23 <Saulzar> Which sounds like exactly what you want
10:11:42 <dcoutts> gour, the latest gtk2hs darcs version probably breaks things for hIDE because of the major treeview changes we're making
10:11:45 <goron> Saulzar: ok, well, then I will try that. Thanks
10:11:49 <goron> shapr: you too.
10:12:10 <shapr> :-)
10:12:40 <gour> dcoutts: it looks like hIDE is a hard nut
10:13:58 <dcoutts> gour, it does depend on dev versions of several packages
10:14:13 <dcoutts> that's why Lemmih made those snapshots of gtk2hs and GHC
10:14:19 <dcoutts> those are the ones that should be used
10:14:48 <goron> shapr: Oh, I see, I can reuse some slot of the statemonad, and put the intermediate value there. 
10:14:50 <dcoutts> Lemmih, can't be expected to make it with arbitrary versions until those other packages make proper releases
10:15:09 <goron> shapr: Then when I am almost done with one call to f, I can report it as result.
10:15:14 <dcoutts> make it/make it work
10:15:16 <goron> shapr: :D
10:15:35 <gour> dcoutts: gtk2hs --partial has 981 patches :-)
10:17:06 <dcoutts> gour, ok, I've run darcs optimise on the server. Is it better now with --partial ?
10:17:31 <gour> dcoutts: this is  for Lemmih's gtk2hs.hide repo
10:17:36 <dcoutts> gour, yes
10:17:55 <dcoutts> gour, the normal gtk2hs repo already had been darcs optimized
10:18:04 <gour> well, my machine is still copying patches ~700
10:18:34 <dcoutts> gour, we'll you'd have to restart the darcs get for you to notice
10:18:43 <gour> yep, obviously
10:19:16 <goron> Can darcs scale up to the Linux kernel? (that is, when it really is stored as a patches structure)
10:19:23 <shapr> Not yet
10:19:28 <shapr> It's getting better though.
10:19:44 <gour> dcoutts: now it's better - 39 patches
10:19:50 <dcoutts> gour, good
10:19:55 <goron> shapr: Still I get lots of code duplication, now.
10:20:08 <shapr> Strange..
10:20:21 <shapr> Sadly, I don't have time to help you any further right now.
10:20:29 * shapr vanishes to do more work before his woman drops by...
10:20:31 <goron> shapr: oh, never mind.
10:20:42 <gour> dcoutts: i still wonder what's wrong with ghc.hide? i pulled the whole repo
10:25:49 <waern> gour, I compiled a week ago
10:25:53 <waern> +it
10:26:23 <gour> waern: ghc.hide ?
10:26:28 <waern> yep
10:26:48 <waern> gour, have you got the separate packages for the libraries as well?
10:27:15 <gour> waern: nope. from where?
10:27:19 <waern> those needs to be in ghc.hide/libraries
10:27:55 <waern> there's a ghc wiki page about the whole thing 
10:28:41 <gour> waern: i wonder why it is not in hide's readme ...let me find it
10:29:06 <psi> dons: are you there? I was wondering if you knew something about the hs-plugins errors I'm getting on OS X.
10:29:20 <waern> gour, yep, the readme file should say so
10:31:58 <davidhouse> @type join
10:31:59 <lambdabot> Not in scope: `join'
10:32:07 <davidhouse> what do i need to import to get that?
10:32:20 <davidhouse> @hoogle join
10:32:20 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
10:32:20 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
10:32:20 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
10:32:34 <davidhouse> oh, perhaps that doesn't do what i want
10:33:05 <mauke> > Monad.join ["hello", " ", "world", "!"]
10:33:06 <lambdabot>  Not in scope: `Monad.join'
10:33:09 <mauke> aw
10:34:22 <davidhouse> i need an equivalent to PHP's implode()
10:35:00 <davidhouse> i want to be able to take all the elements (strings) of a list and concatenate them with a given string in between every two items in the original list
10:35:30 <davidhouse> e.g. something like implode "," ["hello", "there", "foo"] == "hello,there,foo"
10:35:51 <xerox> davidhouse: yup, unwords, I think.
10:35:58 <xerox> Well no...
10:36:04 <davidhouse> well i don't want it to be a comma.
10:36:13 <davidhouse> it might be possible with a combination of foldl and head.
10:36:19 <xerox> Okay
10:36:21 <Beelsebob> concatMap . interleave ","
10:36:24 <Beelsebob> there you go
10:36:28 <Beelsebob> no
10:36:29 <xerox> > unwords ["hi","there"]
10:36:30 <lambdabot> "hi there"
10:36:52 <Beelsebob> foldr ((++) . (++ ",")) []
10:36:59 <davidhouse> > concatMap . interleave "," ["hello", "world", "foo"]
10:37:02 <lambdabot>  Not in scope: `interleave'
10:37:15 <xerox> > (>>= intersperse ",") ["hello","there","foo"]
10:37:16 <lambdabot> Couldn't match `[Char]' against `Char'
10:37:24 <Beelsebob> > foldr ((++) . (++ ",")) [] ["hello", "world", "foo"]
10:37:25 <lambdabot> "hello,world,foo,"
10:37:26 <xerox> Nah :-)
10:37:28 <Beelsebob> :)
10:37:29 <davidhouse> Beelsebob: but then i'll get an extra comma at the end
10:37:37 <mauke> @index interleave
10:37:38 <lambdabot> bzzt
10:37:48 <Beelsebob> oh... it's intersperse
10:38:04 <mauke> > concat $ intersperse "," ["foo", "bar", "baz"]
10:38:06 <lambdabot> "foo,bar,baz"
10:38:13 <Beelsebob> there we go
10:38:14 <Beelsebob> :)
10:38:19 <davidhouse> > let l = ["hello", "world", "foo"] in foldr ((++).(++ ",")) (head l) (tail l)
10:38:21 <lambdabot> "world,foo,hello"
10:38:30 <davidhouse> > let l = ["hello", "world", "foo"] in foldl ((++).(++ ",")) (head l) (tail l)
10:38:31 <lambdabot> "hello,world,foo"
10:38:39 <davidhouse> intersperse will do.
10:38:50 <Beelsebob> > tail $ foldr ((++) . ("," ++)) [] ["hello", "world", "foo"]
10:38:51 <lambdabot> "hello,world,foo"
10:38:55 <xerox> > join . intersperse "," $ ["hello","there","foo"]
10:38:56 <lambdabot> "hello,there,foo"
10:38:58 <Beelsebob> :) alternate
10:39:10 <xerox> Hmm-kay?
10:39:11 <Beelsebob> lots of methods
10:39:16 <bd_> @type join
10:39:17 <lambdabot> Not in scope: `join'
10:39:20 <mauke> > join $ map (',' :) ["foo", "bar", "baz"]
10:39:21 <lambdabot> ",foo,bar,baz"
10:39:27 <mauke> > tail $ join $ map (',' :) ["foo", "bar", "baz"]
10:39:28 <lambdabot> "foo,bar,baz"
10:39:36 <davidhouse> Beelsebob: that tail $ foldr one wont work if you're using a glue of more than one character
10:39:45 <Beelsebob> davidhouse: true
10:40:16 <xerox> bd_: join :: Monad m => m (m a) -> m a, which is 'concat' for the List Monad.
10:40:24 * roconnor relearns DSSSL
10:40:42 <davidhouse> @hoogle intersperse
10:40:43 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
10:40:52 <Beelsebob> > let munge words inter = drop (length inter) $ foldr ((++) . (","++)) [] words in munge ["hello","world","foo"] "..."
10:40:53 <lambdabot> "llo,world,foo"
10:40:58 <Beelsebob> that'll be wrong then
10:41:01 <Beelsebob> oh... dumb bob
10:41:10 <Beelsebob> > let munge words inter = drop (length inter) $ foldr ((++) . (inter++)) [] words in munge ["hello","world","foo"] "..."
10:41:11 <palomer> ok, my .plan is going to consist of sending myself emails
10:41:11 <lambdabot> "hello...world...foo"
10:41:15 <palomer> any objections?
10:41:27 <mauke> Beelsebob: ok, now write explode
10:41:30 <xerox> bd_: you can find in which modules functions are, with lambdabot, using "@index <name>", and then their type with "@type (Complete.Path.To.function)".  @hoogle is meant to combine those two in some sense.
10:41:48 <Beelsebob> mauke: split on the symbol you provide?
10:41:52 <bd_> hm, so is it a more general form of mplus or something?
10:41:56 <roconnor> > concat $ intersperse "..." ["hello","world","foo"]
10:41:57 <lambdabot> "hello...world...foo"
10:42:02 <mauke> Beelsebob: yes
10:42:15 <bd_> @hoogle join
10:42:16 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
10:42:16 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
10:42:16 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
10:42:29 <xerox> bd_: ever saw Cale's article?  It explains that duality quite well.
10:42:31 <roconnor> > join $ intersperse "..." ["hello","world","foo"]
10:42:32 <lambdabot> "hello...world...foo"
10:42:36 <xerox> @wiki MonadsAsContainers
10:42:37 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
10:42:39 <xerox> That one.
10:42:39 <bd_> no, do you have a link?
10:42:41 <bd_> ah
10:42:52 <palomer> that tutorial is really interesting
10:42:55 <mauke> @type (>>= id)
10:42:56 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
10:43:05 <palomer> it's the best monad tutorial out there
10:44:05 <xerox> bd_: point is, you can think of bind (>>=) as \f xs -> join (fmap f xs).  Which is not how it works in Haskell, because the Monad definition only relies on the definition of 'return' and '>>=' (bind).
10:44:50 <palomer> is there a reason fmap and join were not taken as the monad primitive members?
10:45:17 <xerox> bd_: then you can write join = (>>= id) undistishingluy for all monads.
10:45:25 <bd_> ah, I see
10:48:23 <Jammni> can anyone help me with ghc and hopengl?
10:48:24 <davidhouse> i've read a line from stdin. i want to say if (this line contains solely an integer) foo else bar
10:49:10 <davidhouse> how do i code that condition?
10:49:34 <tromp> use reads
10:49:41 <Saulzar> Jammni, What's the problem?
10:49:52 <Jammni> i guess its a problem with the installation
10:49:52 <mauke> @type reads
10:49:53 <lambdabot> forall a. (Read a) => ReadS a
10:49:55 <tromp> if no int can be parsed, it returns an empty list
10:50:07 <Jammni> i downloaded Planet.hs from the hopengl-page and tried to compile it
10:50:41 <davidhouse> tromp, so something like if (not $ null $ reads input) ?
10:50:46 <Jammni> but ghc complies with "cannot find module 'GLU'
10:50:58 <Jammni> and i dont know, what to do
10:51:04 <Jammni> im using windows...
10:51:12 <xerox> > reads "1 bottle" :: [(Int,String)]
10:51:13 <lambdabot> [(1," bottle")]
10:51:16 <tromp> or case reads input of x:_ ...
10:51:23 <Saulzar> What version of ghc do you have?  (and do you have GLU/OpenGL installed?)
10:51:28 <davidhouse> tromp, nice. thanks.
10:51:43 <Jammni> i just downloaded ghc 6.41
10:51:47 <gour> waern: i got libs, but build fails - http://www.rafb.net/paste/results/4LjcQo63.html
10:51:50 <Jammni> thats all
10:52:14 <tromp> case reads input of (i,_):_ 
10:52:19 <Jammni> i triet to install hopengl but i found somewhere, that it is out of date and a newer version is shipped with ghc
10:52:28 <Saulzar> Jammni, Hmm, I think that planet.hs is out of date
10:52:39 <Jammni> that too ;-)
10:53:00 <Jammni> and where can i get GLU/OpenGL?
10:53:03 <Saulzar> GLU is not a module for the recent version... it's installed in the heirarchy
10:53:07 <Saulzar> Graphics.Rendering.OpenGL.GLU
10:53:42 <Jammni> hmm, and what shall i do?
10:54:09 <Saulzar> Jammni, Not sure about GLU, perhaps you can get it from opengl.org somewhere, OpenGL will come with your graphics drivers. 
10:54:30 <Jammni> k, then i have look at opengl...
10:54:49 <Jammni> thx for help :-)
10:54:54 <Saulzar> Jammni, There are some more recent programs on the haskell wiki
10:55:04 <Saulzar> http://www.haskell.org/hawiki/HaskellOpenGl
10:55:12 <Jammni> k, thx :-)
10:55:20 <Jammni> i thought ghc would be most common...
10:56:11 <Saulzar> It is
10:57:01 <Jammni> hey thx - these programs work :-)
10:57:09 <Jammni> then it was just a problem of the old Planet.hs
10:57:11 <davidhouse> > reads "5" of { [(x,[])] -> "hi"; _ -> "no" }
10:57:12 <lambdabot>  parse error on input `of'
10:57:17 <davidhouse> > case reads "5" of { [(x,[])] -> "hi"; _ -> "no" }
10:57:17 <lambdabot> Add a type signature
10:57:22 <xerox> Heh..
10:58:31 <xerox> > let f x = case reads x of { [(x::Int,[])] -> "A number!"; _ -> "Something else." } in (f "10", f "Hi.")
10:58:31 <lambdabot>   Illegal signature in pattern: Int
10:58:31 <lambdabot>    Use -fglasgow-exts to permit it
10:59:50 <mauke> > let f x = case reads x of { [(x,[])] -> const "A number!" (x :: Int); _ -> "Something else." } in (f "10", f "Hi.")
10:59:51 <lambdabot> ("A number!","Something else.")
11:09:55 <goron> I want to print a value for debugging purposes inside a monad. I tried debug.trace "string" value_of_interest, but it doesn't print anything. I also added $!, and I guessed that was a strict call. 
11:10:05 <goron> er Debug.trace
11:11:28 <edwinb> The irritating thing about trace is that it's no use if the value it's attached to never gets used...
11:11:29 <Saulzar> You'll have to make it evaluate with something else, with `seq`  probably.   $! will force value_of_interest to evaluate when the debug.trace is evaluated
11:12:15 <Saulzar> Which isn't quite what you intend, you'll want to pair it with something you know is evaluated (like the return value of the function)
11:15:50 <goron> val `seq` (trace "fbardkasdkasdkasdoo" val) doesn't work, what should it be?
11:16:01 <Saulzar> Other way around :)
11:16:44 <Saulzar> As it is there, that will mean that val is evaluated when (trace ...) is
11:16:45 <goron> Then I don't understand the documentation.
11:16:54 <goron> oh, ok
11:20:53 <goron> I have  State MyState [[Maybe AnswerType]), how can I concat it such that it becomes State MyState [Maybe AnswerType]?
11:22:57 <roconnor> mapM concat
11:24:02 <goron> I am really way too much used to lists... I know a list basically is  a monad, but it confuses me as hell, somehow. 
11:24:08 <goron> roconnor: thanks
11:24:38 <roconnor> it works?
11:26:50 <gour> dcoutts: do you use evolution for sending darcs patches?
11:26:51 <goron> roconnor: no
11:27:41 <roconnor> what is State?
11:27:56 <goron> roconnor: you mean MyState?
11:28:08 <goron> roconnor: State is the State monad.
11:28:53 <edwinb> how about liftM concat?
11:29:16 <xerox> @type liftM join
11:29:17 <lambdabot> Not in scope: `liftM'
11:29:17 <lambdabot>  
11:29:17 <lambdabot> <interactive>:1:6: Not in scope: `join'
11:29:19 <xerox> Ops.
11:29:23 <xerox> @type Monad.liftM Monad.join
11:29:24 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *).
11:29:24 <lambdabot> (Monad m1, Monad m) =>
11:29:24 <lambdabot> m1 (m (m a)) -> m1 (m a)
11:29:29 <xerox> Ah.
11:29:39 <edwinb> liftM join should work too ;)
11:29:45 <edwinb> @type liftM concat
11:29:46 <lambdabot> Not in scope: `liftM'
11:29:46 <goron>  State MyState [[Maybe AnswerType]) --->  State MyState [Maybe AnswerType], ok?
11:29:50 <edwinb> oops
11:29:50 <mauke> @type Monad.liftM concat
11:29:51 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
11:30:06 <roconnor> oh right
11:30:08 <roconnor> liftM
11:30:15 <roconnor> :-/
11:30:34 <roconnor> When dealing with Monads, sometimes I call lift map. ... It's a bit confusing.
11:31:26 <mauke> @type fmap concat
11:31:27 <lambdabot> forall (f :: * -> *) a. (Functor f) => f [[a]] -> f [a]
11:31:43 <gour> dcoutts: well, it looks the best is to use 'darcs send -o file' and then just attach it in the email
11:32:00 <goron> Are you just calling random functions? 
11:32:37 <goron> Oh, I saw the correct one.
11:32:58 * goron wishes he could step through his monad.
11:33:10 <goron> Inspecting types, etc.
11:33:15 <mauke> fmap is liftM, more or less
11:35:45 <dcoutts> gour, I use ssmtp with it configured to forward mail to my isp, then darcs send "Just Works"tm.
11:38:20 <gour> dcoutts: yep. i have qmail running on my localhost, but using dyndns.org, it will be sent with that (fqdn) domain. maybe it's time to get rid of local qmail (after i switched to evo)
11:42:16 <goron> Ok, it compiles, but I think it might be better if I can also use the IO monad. 
11:43:46 <Saulzar> goron, Well, the types aren't going to change when it runs :)
11:44:48 <goron> Saulzar: What do you mean? 
11:45:30 <Saulzar> The types are checked at compile time
11:48:00 <goron> Saulzar: yes, I know, but I read somewhere that you could use a monad transformer to combine two monads.
11:48:06 <goron> (in this case State and IO)
11:48:18 <goron> Ok, my algorithm seems to do something :)
11:48:24 <goron> (useful)
11:50:21 <Saulzar> goron, Yup, but it will have a type representing the fact that it is two monads
11:50:38 <goron> Saulzar: ok, I don't mine that.
11:51:06 <goron> er mind
13:05:39 <nuffer> if I get a handle from listenOn or connectTo
13:05:52 <nuffer> is there something special I need to do in order to be able to read from and write to it asynchronously?
13:22:38 <bensond> ls
13:22:40 <bensond> heya
13:23:08 <SyntaxNinja> oregon state, 'eh?
13:23:31 <bensond> yeah orst
13:24:22 <bensond> just learning about lambda calc in programming languages
13:36:07 <bensond> kewlies: http://en.wikipedia.org/wiki/Lambda_calculus
13:36:37 <SyntaxNinja> <--- working in beaverton
13:37:09 <bensond> do you use haskell in your job?
13:37:36 <SyntaxNinja> yeah
13:37:44 <bensond> what do you use it for?
13:37:53 <SyntaxNinja> security stuff
13:38:11 <bensond> interesting
13:41:07 <bensond> o0o i didn't know haskell could be used like that
13:57:19 <davidhouse> hey all
13:57:32 <davidhouse> i want to tell whether a string i've pulled in from stdin is solely an integer.
13:57:44 <davidhouse> i was advised to use reads, this is my current implementation:
13:58:27 <davidhouse> case reads input of { [(x,[])] -> ...; _ -> ...; }
13:58:42 <davidhouse> it compiles w/o error but the first condition is never hit, as far as i can tell
13:59:36 <ski> > case reads "123" of { [(x,"")] -> Just x; _ -> Nothing } :: Maybe Int
13:59:37 <lambdabot> Just 123
13:59:42 <ski> > case reads "123r" of { [(x,"")] -> Just x; _ -> Nothing } :: Maybe Int
13:59:44 <lambdabot> Nothing
14:00:12 <davidhouse> hmm
14:00:13 <ski> > case reads "123 " of { [(x,"")] -> Just x; _ -> Nothing } :: Maybe Int
14:00:14 <lambdabot> Nothing
14:00:18 <ski> > case reads " 123" of { [(x,"")] -> Just x; _ -> Nothing } :: Maybe Int
14:00:19 <lambdabot> Just 123
14:00:56 <ski> maybe look closer at what strng(s) you try to parse ?
14:00:59 <davidhouse> does getLine stick a \n on the end of the string?
14:01:06 <ski> no
14:01:06 <davidhouse> that could be it.
14:01:11 <davidhouse> right.
14:01:51 <ski> Prelude> print =<< getLine
14:01:51 <ski> 123
14:01:51 <ski> "123"
14:02:29 <davidhouse> http://pastebin.com/545681 <- that's my exact code
14:03:11 <davidhouse> hmm, i can remove that read actually
14:03:28 <davidhouse> ...and that made it work. weird.
14:04:29 <mauke> what is the type of printFactors?
14:05:16 <davidhouse> Int -> IO ()
14:05:25 <davidhouse> it seems to be working once i got rid of that read.
14:05:28 <mauke> ok, so x is a string
14:05:42 <davidhouse> well the type of reads is String -> [(Int,String)]
14:05:42 <mauke> looks like you didn't enter a valid string before
14:05:50 <mauke> no, it isn't
14:06:11 <mauke> it's something like (Read a) => String -> [(a,String)]
14:06:22 <mauke> since read takes a String, x MUST be a string
14:06:37 <ski> yes
14:06:42 <mauke> your getLine expects a line that contains a string that contains an int
14:06:50 <ski> don't use 'reads' and then *also* 'read'
14:07:02 <mauke> because you have two read calls, chained
14:07:06 <ski> 'reads' already parses, so no need to additionally call 'read'
14:07:35 <davidhouse> the extra read was a mistake
14:07:42 <davidhouse> i understand why it's not necessary.
14:08:04 <davidhouse> i used to just be switching on input instead of reads input, so i used to need it.
14:08:07 <ski> do you understand why it was worng, though ?
14:08:16 <davidhouse> then i forgot to remove it when i switched to reads
14:09:14 <mauke> > read (reads "123") :: Int
14:09:15 <lambdabot> Couldn't match `Char' against `(a, String)'
14:09:23 <mauke> yeah, ok
14:10:05 <mauke> > read ((\((x,_):_) -> x) $ reads "123") :: Int
14:10:06 <lambdabot>  Non-exhaustive patterns in lambda
14:10:18 <mauke> > read ((\((x,_):_) -> x) $ reads "\"123\"") :: Int
14:10:19 <lambdabot> 123
14:11:24 <davidhouse> is there not a more convenient way of checking whether a given string is an integer?
14:11:31 <davidhouse> running it through a parser seems a little over the top
14:11:44 <mauke> everything is a parser
14:12:59 <davidhouse> read "hi"
14:13:02 <davidhouse> > read "hi"
14:13:03 <lambdabot> Add a type signature
14:13:11 <davidhouse> hmm...
14:13:44 <davidhouse> perhaps i should write a wrapper to read that has type signiture String -> Maybe Int, then use that.
14:14:43 <ski> @type let readMaybe s = case read s of {[(a,"")] -> Just a; _ -> Nothing} in readMaybe
14:14:43 <lambdabot> forall a. (Read [(a, [Char])]) => String -> Maybe a
14:14:51 <kosmikus> davidhouse: not necessary if it can be inferred from context. also, read doesn't return a Maybe, only reads does
14:14:52 <mauke> > null $ dropWhile Char.isDigit "123"
14:14:53 <lambdabot> True
14:14:55 <kosmikus> > read "2" + 1
14:14:56 <lambdabot> 3
14:15:02 <mauke> > null $ dropWhile Char.isDigit "not a number"
14:15:03 <lambdabot> False
14:15:07 <ski> @type let readMaybe s = case reads s of {[(a,"")] -> Just a; _ -> Nothing} in readMaybe
14:15:08 <lambdabot> forall a. (Read a) => String -> Maybe a
14:15:31 <mauke> that simply checks if it contains nondigits
14:15:38 <davidhouse> muake, nice :) that will work.
14:15:47 <mauke> well, you need another check that it's not empty
14:16:18 <Lemmih> > all Char.isDigit "123"
14:16:19 <lambdabot> True
14:16:27 <ski> > all Char.isDigit "-123"
14:16:28 <lambdabot> False
14:16:40 <mauke> heh, d'oh
14:16:57 <mauke> still thinking in Perl
14:17:30 <mauke> @pl \x -> all Char.isDigit x && not (null x)
14:17:31 <lambdabot> ap ((&&) . (all Char .) . isDigit) (not . null)
14:17:50 <Pseudonym> That's Perl, not @pl.
14:23:02 <davidhouse> if i let isIntString = all Char.isDigit, can i do something like this? case input of { isIntString x -> someFunc; 'quit' -> return (); _ -> putStr 'No'; }
14:23:17 <davidhouse> i.e., have isInputString on the left hand side of a case test
14:23:53 <ski> case input of {_ | isIntString x -> someFunc; ...}
14:24:04 <ski> you can use guards in case
14:24:08 <mauke> x | isIntString x -> ...
14:24:18 <davidhouse> hmm...
14:24:23 <davidhouse> how exactly do they work?
14:24:41 <davidhouse> i want three seperate cases: one for an isIntString, one for 'quit', and a fallback
14:24:42 <mauke> like boolean expressions
14:25:16 <ski> first pattern is tried, if it matches, then guard is evaluated, if it gives True, then that branch is taken, otherwise next guard (or next other pattern-branch) is tried)
14:25:43 <ski> case input of { x | isIntString x -> someFunc; 'quit' -> return (); _ -> putStr 'No'; }
14:26:21 <davidhouse> ah.
14:26:34 <davidhouse> so the 'x' is the pattern, which matches and so the guard is executed.
14:27:33 <shapr> g'day Pseudonym 
14:27:53 <Pseudonym> G'day.
14:27:58 <Pseudonym> Ah, coffee.  BBS
14:28:12 <Pseudonym> (Going to have coffee with a guy who is trying to implement B-trees in Haskell.  He needs some help.)
14:28:28 <Pseudonym> (I'll be sure to get him to cabal-ify it.)
14:29:54 <shapr> coi Taral 
14:29:59 <shapr> ma nuzba
14:30:04 <Taral> coi shapr.
14:30:18 <Taral> One of these days I will sit down and learn the damn lojban vocabulary.
14:30:35 <shapr> Funny, you were the maintainer of the lojban-common deb for how long?
14:30:41 <Taral> Ages.
14:30:47 <Taral> Until I got fed up of keyring management issues.
14:30:57 <Taral> Hell, I *made* the lojban-common deb, iirc.
14:31:00 <shapr> yup
14:31:05 <shapr> That you did.
14:31:14 <shapr> I always thought you knew more lojban than I do.
14:31:19 <Taral> Nope!
14:32:12 <shapr> I've always wanted to implement a lojban interpreter in Haskell and speak programs to it.
14:33:57 <davidhouse> @google defein:lojban
14:33:59 <lambdabot> No Result Found.
14:34:15 <mauke> @google define:lojban
14:34:16 <lambdabot> No Result Found.
14:34:26 <Taral> ha ha ha
14:34:33 <Taral> @google lojban
14:34:34 <lambdabot> http://www.lojban.org/tiki/tiki-index.php?page=Home+Page&bl
14:34:40 <Taral> interesting, that's the wiki
14:34:44 <Taral> @google lojban homepage
14:34:45 <davidhouse> it's because define: searches don't return normal results
14:34:45 <icbt> after i installed Cabal 1.1.3, i am now getting Loading package readline-1.0 ... ghc-6.4.1: can't load .so/.DLL for: readline.5 (dlopen(libreadline.5.dylib, 10): image not found)
14:34:45 <lambdabot> http://www.lojban.org/eo/
14:34:49 <Taral> LOL
14:34:53 <Taral> worse!
14:35:04 <icbt> have you encountered this?
14:37:37 <davidhouse> @hoogle char.isDigit
14:37:38 <lambdabot> Prelude.undefined :: a
14:37:38 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
14:37:38 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:37:47 <davidhouse> @hoogle Char.isDigit
14:37:48 <lambdabot> Prelude.undefined :: a
14:37:48 <lambdabot> Test.QuickCheck.Batch.bottom :: a
14:37:58 <davidhouse> @type Char.isDigit
14:37:59 <lambdabot> Char -> Bool
14:38:08 <davidhouse> is it in the prelude?
14:38:49 <davidhouse> ah, i have to import Char.
14:40:14 <mauke> import qualified Char -- ftw
14:41:08 <psi> @wtf ftw
14:41:10 <lambdabot> No match for "ftw".
14:41:30 <psi> for the win? :)
14:41:38 <Wallbraker> for teh win
14:42:28 <davidhouse> @wtf wtf
14:42:29 <lambdabot> No match for "wtf".
14:42:36 <davidhouse> hehe
14:45:31 <psi> heh. guido wants to keep lambda now.
14:45:46 <davidhouse> yay :) my first ever proper haskell program is finished
14:45:54 <Taral> congrats
14:46:03 <Taral> psi: it was inevitable
14:47:08 <tony2> well done, what was the program? 
14:47:09 <psi> really? he seemed quite keen on removing it, and other functional programming constructs.
14:48:28 <davidhouse> tony2, it finds prime factorisations
14:49:43 <psi> nested def's can do anything that lambda can, etc.
14:49:48 <psi> defs
14:49:58 <integral> then why do they need to keep it in the end?
14:49:58 <tony2> which method?
14:50:56 <davidhouse> tony2, oh, i made the algorithm up. you give it x, it finds the lowest prime divisor lpd, then recurses on x/lpd.
14:51:17 <Taral> I am so *bored*
14:51:33 <psi> http://mail.python.org/pipermail/python-dev/2006-February/060415.html
14:53:47 <Dreadshoot> does haskell work good in win?(the comiplers and so on)?
14:54:03 <Dreadshoot> *compilers
14:55:02 <TuringTest> For a compiler, that would likely be ghc, which should work well
14:55:23 <TuringTest> (several people at Microsoft research are ... involved)
14:55:34 <Taral> lol
14:55:38 <Dreadshoot> ok
14:55:47 <mauke> Haskell.NET?
14:55:51 <TuringTest> Taral: Ask a silly question....
14:55:56 <Dreadshoot> gonna test some haskell
14:55:57 <mauke> Monad Shell?
14:55:59 <Taral> .NET did make specific provision for functional programming
14:56:05 <TuringTest> mauke: no. but there is a Visual Studio plugin for HAskell
14:56:19 <Dreadshoot> there is? :)
14:56:27 <psi> Dreadshoot: there is also a gui for hugs called winhugs. haven't tried it, though.
14:56:46 <davidhouse> winhugs!
14:56:46 <TuringTest> Taral: I hear .Net is better than the JVM for such things.  But not ideal.
14:56:51 <davidhouse> the most optimistic software ever!
14:57:05 <TuringTest> Dreadshoot: yes , there is a visual studio thingie
14:57:08 <Taral> TuringTest: That's what I hear too. Then again, I'm not sure what an ideal VM would look like...
14:57:22 <Dreadshoot> ah gonna check that out
14:58:16 <tony2> F# is the ms functional language on .net.
14:58:42 <TuringTest> @google Visual Studio Haskell
14:58:43 <lambdabot> http://www.cin.ufpe.br/~haskell/vhs/status.html
14:58:46 <TuringTest> There is is
14:58:49 <TuringTest> There it is
14:58:57 <TuringTest> tony2: Link?
14:59:04 <TuringTest> @google .net f#
14:59:06 <lambdabot> http://research.microsoft.com/projects/ilx/fsharp.aspx
14:59:06 <tony2> http://research.microsoft.com/projects/ilx/fsharp.aspx
14:59:10 <TuringTest> heh
14:59:43 <Taral> I'm bored. Someone send me a good paper to read.
15:00:17 <Taral> oh, I know! I'll go review that boxy types paper I never got around to.
15:00:33 <Taral> I wonder if I still have a printed copy somewhere here?
15:00:59 <TuringTest> Taral: http://arxiv.org/abs/quant-ph/0501135
15:01:27 <TuringTest> But then I am not a computer scientist.
15:01:35 <Taral> frp, no... smp, no... proof reconstruction, no... *shuffle* google mapreduce, no... fd via chr, no... dht, no... fusion, no... damn it!
15:01:50 <Taral> oh, and yuk, computability logic, definitely NO.
15:02:17 <Taral> oh, I remember this! "A Cryptanalysis of the High-bandwidth Digital Content Protection System". Ha ha ha ha.
15:02:24 <Taral> no boxy types. :(
15:02:48 <TuringTest> http://arxiv.org/abs/quant-ph/0501151 "Structuring quantum effects: superoperators as arrows"
15:02:50 <Taral> TuringTest: Obviously not. Quantum physics is one of the few topics I have trouble grasping the fundamentals of.
15:03:17 <TuringTest> In that paper, quantum mechanics is translated into arrow notation.
15:03:38 <tony2> wow.
15:04:01 <Taral> hey, does the implementation of boxy types in GHC mean I can have impredicative types now?
15:04:11 <TuringTest> But the static guarantees aren't quite enough to enforce all the physical limits of quantum computing.  You have to depend on programming idiom
15:04:33 <TuringTest> Taral: ...and that question is greek to me...
15:04:37 <Taral> TuringTest: Heh.
15:04:45 <Taral> TuringTest: Sounds like your static guarantees need better types.
15:04:47 <Taral> :)
15:05:11 <TuringTest> The authors want to make a DSL which adds the needed statically enforced limits.
15:05:20 <Taral> interesting
15:05:41 <TuringTest> Making a good representation of quantum computing in a programming language turns out to be tricky.
15:06:03 <dons> @seen musasabi
15:06:04 <lambdabot> musasabi is in #haskell-blah and #haskell. Last spoke 11 hours, 56
15:06:04 <lambdabot> minutes and 26 seconds ago.
15:06:32 <musasabi> and is working right now.
15:06:41 <Taral> so is quantum physics turing complete? :)
15:06:50 <Taral> hi dons
15:06:52 <TuringTest> Taral: overcomplete
15:06:56 <Taral> LOL
15:07:04 <dons> ok, musasabi, just for your queue, I have a faster partial-sums on the wiki.
15:07:04 <Taral> it's nondeterministic turing complete
15:07:14 <TuringTest> Taral: no.
15:07:22 <Taral> no?
15:07:23 <Taral> aw.
15:07:28 <dons> morning Taral, TuringTest
15:07:34 <Taral> oh, yes, there was that paper about the limits of quantum computers
15:07:45 <TuringTest> dons: it won't be AM for 54 more minutes.
15:08:00 <dons> @localtime dons
15:08:03 <lambdabot> Local time for dons is Thu Feb  9 10:07:29 2006
15:08:07 <dons> :)
15:08:09 <Taral> said something about not all classical algorithms being implementable on a quantum computer
15:08:16 <Taral> @localtime TuringTest 
15:08:18 <TuringTest> Taral: quantum computer can turn some exponential classical problems into polynomial ones
15:08:28 <Taral> Yes, yes.
15:08:32 <TuringTest> hmm...how does @localtime work
15:08:35 <Taral> (hm, TuringTest no support ctcp time)
15:08:48 <musasabi> dons: will look at it in some hours.
15:08:49 <dons> yep, depends on the client
15:08:51 <Pseudonym> Back.
15:08:53 <Pseudonym> Fully caffeinated now.
15:08:54 <Taral> hi Pseudonym 
15:08:58 <dons> thanks musasabi. cheers
15:09:07 <Taral> So I ask again: hey, does the implementation of boxy types in GHC mean I can have impredicative types now?
15:09:37 <dons> Taral, did you see the impredicateive types patch?
15:09:54 <Taral> no, I don't follow cvs
15:09:57 <Taral> should I? :)
15:10:06 <dons> no no, it was in the haskell weekly news :)
15:10:08 <Taral> I just started reading the boxy types paper.
15:10:12 <Taral> which hwn?
15:10:39 <SyntaxNinja> dons: I noticed there was no haskell' news. did that person who offered to help out not come through?
15:11:03 <Taral> I saw bang patterns just recently.
15:11:17 <Taral> oh, last week, yes!
15:11:19 <Taral> YAAY
15:11:26 <Taral> Now lambdabot can have a proper unlift.
15:12:25 <TuringTest> ?
15:14:19 * Philippa thinks it's a shame GHC's implementation means the subsumption relationship's more restrictive than it could be
15:14:20 <tony2> I love bang patterns. I just went through some code yesterday, after upgrading my ghc, and it looks so much nicer without so many seqs. Now all I need is to convert to unicode chars...
15:14:41 <dons> Taral, yes, last week. 
15:14:52 <dons> SyntaxNinja, yeah, I got nothing back from him :/
15:15:02 <dons> so I'll do it, I guess
15:15:09 <Taral> So I have have m (forall a. m a -> m' a)
15:15:12 <Taral> woot!
15:15:24 <Taral> now I need to get latest ghc
15:16:04 <TuringTest> dons: I saw the ~10% boost on sum-file. Did using "recip" do anything?
15:16:26 <dons> which 10% boost? missed that.
15:19:46 <TuringTest> sorrry partial-sums
15:19:58 * TuringTest remembered wrong
15:20:42 <psi> dons: you know the stringProcessor example for hs-plugins? I'm having some issues. changing the default "reverse" to e.g., "sort" gives me: unknown symbol `_DataziList_sort_closure'
15:21:17 <psi> many other more advanced variations gives similar errors
15:21:28 <psi> simple prelude functions seem to work
15:22:33 <psi> and I'm on OS X.
15:23:09 <psi> the trouble making OS for haskell, in my experience :)
15:27:53 <Taral> hm
15:28:01 <Taral> ghc still has a bug when you try to build it with -j2
15:32:11 <dons> TuringTest, yep, partial-sums. Not recip (it just expands to 1 / x anyway), but using sqrt for x ** 0.5
15:34:36 <TuringTest> ok
15:34:52 <TuringTest> (I can't really test math on x86 for now)
15:35:57 <MarcWeber> I want to call a process (echo "dummy") and read stdout into haskell. Which function provides a handle to pass it to create Process to take the output? 
15:37:02 <Taral> @hoogle system
15:37:02 <lambdabot> System.Cmd.system :: String -> IO ExitCode
15:37:02 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
15:37:02 <lambdabot> Graphics.UI.ObjectIO.StdMenu.enableMenuSystem :: GUI ps ()
15:37:15 <Taral> hm
15:38:04 <dons> psi, hs-plugins seems to be broken on the mac since Wolfgang made some changes to the ghc backend on the mac. I haven't investigated it yet. there have been similar reports in the last few days.
15:38:27 <Taral> @hoogle popen
15:38:28 <lambdabot> No matches found
15:38:46 <dons> @hoogle interact
15:38:47 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
15:38:47 <lambdabot> System.IO.interact :: (String -> String) -> IO ()
15:38:47 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle,
15:38:47 <lambdabot> Handle, ProcessHandle)
15:39:00 <dons> youwant stuff in System.Processs?
15:39:23 <MarcWeber> dons: Yeah. The function is called runProcess.
15:40:01 <MarcWeber> But I don't know which function to use to create a handle of type GHC.IOBase.Handle.
15:40:04 <ndm> dons, do you maintain statistics on which lamdabot commands are run most often?
15:40:30 <SyntaxNinja> dons: did you ping him?
15:40:32 <psi> dons: ok, thanks.
15:40:41 <Taral> MarcWeber: System.Process.runInteractiveCommand
15:41:11 <dons> ndm, nope but would be easy to gather. My guess: @eval, @type, @hoogle, @where
15:41:36 <ndm> dons, yeah - i just wondered how often hoogle was being used :)
15:41:39 <dons> SyntaxNinja, no, I just ran out of time and published. but i will.
15:41:49 <dons> ndm, just grep the logs
15:41:54 <dons> they're in plain text format
15:42:08 <MarcWeber> Taral: When using runProcess then I can only pass file handles?
15:42:30 <Taral> runProcess expects Handles, which you can make with createPipe/fdToHandle
15:42:41 <Taral> but runInteractiveCommand does that for you
15:42:56 <Taral> it returns (stdin,stdout,stderr,processhandle)
15:44:14 <MarcWeber> Thanks. i didn't see that.
15:48:50 <MarcWeber> Taral: When emulating bash pipe ( echo string | cat ) do you use interactiveProcess again? Should I use create Process and create the pipe by myself?
15:51:48 <Taral> MarcWeber: Um... you could do it yourself, or call out to /bin/sh
15:52:25 <Taral> I think runInteractiveCommand calls out to ${SHELL-/bin/sh}
15:52:33 <Taral> not sure thought
15:52:34 <Taral> -t
15:54:10 <MarcWeber> Taral: Thats why there is runInteractive{Process,Command} ;-)
15:55:39 <MarcWeber> I have found the data structure of a Buffer in IOBase.lhs but I couldn't find a implementation of a pipe..
16:02:50 <Taral> @hoogle createPipe
16:02:51 <lambdabot> No matches found
16:02:57 <Taral> @hoogle pipe
16:02:58 <lambdabot> Foreign.C.Error.ePIPE :: Errno
16:02:58 <lambdabot> Foreign.C.Error.eSPIPE :: Errno
16:03:01 <Taral> bah
16:03:18 <Taral> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#v%3AcreatePipe
16:03:29 <Taral> and fdToHandle later on
16:09:46 <MarcWeber> Thanks again
16:22:04 <Taral> how do I get ghc to show me what it's compiling?
16:22:13 <icbt> -v
16:22:22 <Taral> HAHAHAHAHA
16:22:27 <Taral> make went into an infinite loop
16:22:40 <Taral> ghc is *so* not -j safe
16:22:50 <Taral> ok, something is very wrong
16:22:53 <icbt> maybe to -C or -c first
16:24:09 <Taral> yup, something about 20060205 makes make start looping
16:25:15 <ihope> > (unwords . reverse . words) "table of contents"
16:25:16 <lambdabot> "contents of table"
16:25:17 <ihope> I r 7EH |33t
16:26:23 <ihope> Hmm...
16:26:33 <ihope> @type ((+) >>=)
16:26:34 <lambdabot> forall a b.
16:26:34 <lambdabot> (Monad ((->) a), Num a) =>
16:26:34 <lambdabot> ((a -> a) -> a -> b) -> a -> b
16:27:05 <ihope> @type ((+) >>=) const
16:27:06 <lambdabot> forall a. (Monad ((->) a), Num a) => a -> a -> a
16:27:21 <ihope> > ((+) >>= const) 2 3
16:27:30 <lambdabot> 5
16:27:41 <ihope> I didn't do that, did I?
16:27:48 <Taral> ha ha
16:29:40 <ihope> Oh cool, I can read this channel via the chatlong.
16:29:55 <ihope> s/ng/gs/
16:30:14 <SamB> ihope: no, you didn't do that
16:30:34 <SamB> how could playing with lambdabot cause a netsplit?
16:32:51 <TuringTest> @hoogle split
16:32:52 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
16:32:52 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
16:32:52 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
16:32:57 <TuringTest> It's dead Jim
16:47:31 <musasabi> and is working right now.
16:47:36 <musasabi> grah.
16:47:45 <musasabi> irssi and broken completion.
17:03:25 <musasabi> Why does this not work:
17:03:42 <musasabi> class Imp a b | a -> b
17:03:42 <musasabi> class B a where foo :: Imp a b => b
17:03:42 <musasabi> instance Imp Int String
17:03:42 <musasabi> instance B Int where foo = "test"
17:04:54 <musasabi> Now given the "B Int" instance where is "Imp Int b => b" and because of the fundep it becomes "Imp Int String => String", but this does not work.
17:05:02 <musasabi> What is the correct idiom for this?
17:05:12 <ihope> Wait... "class Imp a b | a -> b" doesn't look right.
17:05:16 <ihope> What is it?
17:05:34 <musasabi> just implication.
17:05:38 <Dreadshoot> have anyone installed hs-plugins in win?
17:05:52 <ihope> So any pair of types is in that class?
17:07:00 <ihope> So the pair Int String is in it...
17:07:23 <ihope> This is saying that "test" :: Imp a b => b.
17:07:30 <ihope> Erm.
17:07:37 <ihope> Well, yeah.
17:07:37 <musasabi> yes, but given the fundeps the class is injective
17:08:12 <ihope> ...Wuh?
17:08:38 <ihope> Well, it doesn't look like Imp a b => b to me.
17:09:39 <ihope> There's nothing stopping me from adding a new instance to Imp which breaks it.
17:10:22 <ihope> And I suppose with Haskell, if code can be broken by adding more declarations, it *is* broken.
17:12:52 <musasabi> ihope: what instance would break it?
17:13:19 <ihope> instance Imp () Int
17:13:26 <ihope> "test" is not an Int.
17:13:45 <ihope> Any instance a b, where b /= String
17:14:53 <musasabi> ihope: so how would it break things?
17:15:09 <musasabi> in the instance the form "a" is bound.
17:15:33 <ihope> Um.
17:16:25 <dons> musasabi, along with the partial-sums entry, I just added a 2-3x faster nsieve entry(after finding a bad unboxing in the Core)
17:16:35 <dons> it's on the wiki http://www.haskell.org/hawiki/NsieveEntry
17:16:48 <ihope> @type const >>= const
17:16:49 <lambdabot> forall a b. (Monad ((->) a)) => a -> b -> a
17:17:08 <ihope> @type Control.Monad.Reader.return
17:17:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
17:17:14 <ihope> Mmh.
17:19:53 <dons> Dreadshoot, it has been done, but not in a couple of months. it can be tricky. It works best natively (not in cygwin, btw).
17:21:36 <Dreadshoot> dons: sounds good to me, i want to interpret haskell in c/c++ code in win, (with eval)
17:21:46 <musasabi> dons: ok.
17:22:20 <ihope> Hmm. I can't /msg channels, can I?
17:22:27 <Dreadshoot> dons: do you remember who did it?
17:22:31 <mauke> why not?
17:24:28 <ihope> Well, how do I work IRC in Haskell? Do I have to hack Hircules or something?
17:25:57 <lambdabot> ahem
17:26:08 <lambdabot> More than one way to do IRC in Haskell.
17:26:52 <ihope> Oh yeah.
17:26:54 <SamB> dons: what are you playing at
17:27:23 <ihope> Aww. He's allowed to use (error . error) when the rest of us are left out of the fun!
17:32:35 <dons> not me.
17:33:05 <SamB> > (error . error) "foo"
17:33:06 <lambdabot> Add a type signature
17:33:09 <SamB> > (error . error) "foo" :: ()
17:33:10 <lambdabot> Exception
17:33:19 <dons> I disabled that ;)
17:33:22 <ihope> Yeah, it's probably some... Arcane Stuff.
17:33:26 <SamB> disabled what?
17:33:31 <ihope> (error . error)
17:33:32 <dons> some people discovered you could msg other channels that way.
17:33:45 <ihope> Me? *hides*
17:34:05 <SamB> > let compose = (.) in (compose error error) "foo" :: ()
17:34:06 <lambdabot> Exception
17:34:13 <Pseudonym> Hang on, how does that work?
17:34:22 <ihope> Or was that boochery on my part?
17:34:38 <Pseudonym> When you type something in an IRC client, doesn't it (by default) /msg to the current channel?
17:35:30 <SamB> lambdabot doesn't support typing things in
17:35:34 <ihope> :-)
17:35:43 <dons> ihope worked out that error.errorr was equiv to msg, and then you could get lambdabot to perform arbitrary irc actions
17:35:52 <Pseudonym> Ah.
17:36:04 <SamB> how did you fix it?
17:36:07 <ihope> I didn't do anything other than /me and the booched whatever.
17:36:30 <dons> so it made lambdabot look like a naughty monkey
17:36:37 <palomer> is there a reason why we don't allow things like      let x = (\y -> y y) in 5  ?
17:36:43 <lambdabot> Ook.
17:36:49 <ihope> palomer: infinite types!
17:36:53 <Pseudonym> Yup.
17:36:57 <SamB> yeah
17:37:01 <ihope> Types aren't lazily evaluated.
17:37:02 <SamB> it says right here:
17:37:07 <SamB> > (\y -> y y)
17:37:08 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:37:08 <lambdabot>   Expected type: t
17:37:08 <lambdabot>   Inferred type: t -> t1
17:37:14 <palomer> well, yes
17:37:22 <Pseudonym> > 
17:37:23 <lambdabot> <stdin>: hGetLine: end of file
17:37:28 <ihope> Uh.
17:37:28 <palomer> but I don't see why let x = <garbage> in 5   isn't allowed
17:37:36 <Pseudonym> > \h -> (\x -> h (x x)) (\x -> h (x x))
17:37:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:37:36 <lambdabot>   Expected type: t
17:37:36 <lambdabot>   Inferred type: t -> t1
17:37:39 <Pseudonym> Same reason.
17:37:44 <ihope> Types aren't lazily evaluated.
17:37:50 <SamB> would look like ... -> t1 -> t1 -> t1 -> t1 -> t1 -> t1
17:38:00 <Pseudonym> We could allow let x = <syntax error> in 5, I suppose...
17:38:12 <palomer> I heard that it breaks type preservation
17:38:14 <palomer> is this true?
17:38:20 <ihope> SamB: I thought more like ... -> t1) -> t1) -> t1)
17:38:42 <ihope> palomer: what do you mean by preservation?
17:38:48 <SamB> ihope: oh, yeah.
17:38:49 <SamB> true.
17:38:52 <Pseudonym> palomer: You could allow it, but it causes a lot of problems.
17:38:56 <SamB> I think.
17:39:07 <palomer> ihope: if a is of type tao, and a reduces to b, then b has type tao
17:39:19 <palomer> Pseudonym: what problems?
17:39:32 <Pseudonym> Weren't we discussing the occurs check yesterday?
17:39:48 <ihope> We could allow it, but not under our current type system.
17:40:09 <palomer> will it break type preservation?
17:40:14 <Pseudonym> No.
17:40:21 <Pseudonym> It will break programmer expectation.
17:40:29 <Pseudonym> And it will make type checking more expensive.
17:40:33 <ihope> A function is never allowed to take itself.
17:40:41 <Pseudonym> And it will require a syntax to express it.
17:40:45 <palomer> ok, let say we replace the typing rule of let with this one:
17:40:55 <palomer> gamma |- [e/x] e' : tao
17:40:56 <palomer> ---------------------
17:41:07 <palomer> gamma |- let x = e in e'
17:41:11 <palomer> :toa
17:41:19 <ihope> Uh...
17:41:27 <palomer> forgetting recursive definitions
17:41:31 <ihope> I don't get it.
17:41:44 <palomer> which means:
17:41:54 <palomer> if [e/x] e' has type tao, then let x = e in e' has type tao
17:42:12 <Pseudonym> First off, there are issues here with let-polymorphism.
17:42:29 <palomer> this would take care of let polymorphism
17:42:36 <Pseudonym> A let-bound definition is generalised, but a lambda-bound definition isn't.
17:42:53 <Pseudonym> Perhaps, but it would also break programmer expectation.
17:43:04 <Pseudonym> I would expect that I can float something in a where clause to the top-level.
17:43:15 <Pseudonym> Without anything breaking.
17:43:58 <palomer> right, but I'm talking about preservation
17:44:08 <Pseudonym> I don't follow.
17:44:17 <ihope> > reverse "erised"
17:44:18 <lambdabot> "desire"
17:44:44 <palomer> Pseudonym: if a reduces to b, and a has type tao, then b has type tao
17:44:50 <palomer> Pseudonym: that's preservation
17:44:58 <Pseudonym> Yes, but let-binding isn't lambda-binding.
17:45:11 <Pseudonym> Converting a let to a lambda doesn't have to preserve anything.
17:45:33 <palomer> I never talked about lambda-bindings!
17:45:33 <SamB> why would you do something silly like that anyways?
17:45:54 <ihope> join id and fix const...
17:45:56 <palomer> but, if you replace the current let rule with this one, would it break preservation?
17:45:58 <ihope> >:-)
17:46:09 <Pseudonym> Ah, I understand.
17:46:11 <Pseudonym> Yes, it would.
17:46:24 <Pseudonym> [e/x] e' is te same as (\x -> e') e
17:46:31 <Pseudonym> So it's the same as a lambda binding.
17:46:32 <palomer> how would it break preservation?
17:46:44 <Igloo> Not if that's capture-avoiding substitution, it's not
17:46:59 <Pseudonym> To pick but one horrible example, let-bindings are subject to the monomorphism restriction.
17:47:01 <ihope> Remove types entirely.
17:47:16 <palomer> oh, forget mr, I'm looking for something more basic
17:47:22 <Pseudonym> I believe it doesn't break preservation in Hindley-Milner.
17:47:28 <palomer> Igloo: hmm?
17:47:32 <palomer> Pseudonym: oh
17:47:34 <Igloo> "hmm?"?
17:47:35 * palomer grumbles
17:47:45 <palomer> Igloo: it's not what?
17:47:46 <Pseudonym> But Haskell uses something closer to F2.
17:47:57 <palomer> Pseudonym: AF_2 ?
17:47:57 <Igloo> [e/x] e' is not the same as (\x -> e') e
17:48:07 <Pseudonym> Whatever.  Second-order lambda calculus, anyway.
17:48:14 <Pseudonym> Igloo: It's not?
17:48:19 <palomer> I didn't know that
17:48:23 <Pseudonym> (Modulo renaming.)
17:48:29 <Igloo> No; on the left the instances of e can have different types
17:48:55 <Pseudonym> Example?
17:49:15 <mauke> .oO( just use ocamlc -rectypes )
17:49:21 <Igloo> let f = id in (f 'c', f "string")
17:50:13 <vincenz> concerning Alex...is iti better to encode the keywords directly into your lexer or to use an identifier table and then just have one regexp for identifiers which then looks up if word is a keyword or identifier
17:50:48 <dons> vincenz, what does ghc do? that's probably the "best" way
17:50:53 <dons> @fptools
17:50:53 <lambdabot>  not available
17:51:07 <SamB> vincenz: I'd go with the latter myself
17:51:13 <Pseudonym> Igloo: I don't follow.  Where's the [e/x] e' and where's the (\x -> e') e in your example?
17:51:19 <dons> @darcs
17:51:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:51:24 <Pseudonym> I see neither a variable substitution nor a lambda expression.
17:51:24 <dons> @libsrc
17:51:25 <lambdabot>  not available
17:51:36 <SamB> vincenz: because it seems simpler
17:51:36 <dons> hmm, where'd @fptools go?
17:51:44 <vincenz> SamB: how is it simpler?
17:51:47 <SamB> @libsrc Prelude
17:51:48 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
17:51:55 <Igloo> Pseudonym: That would be translated to   [id/f] (f 'c', f "string")   and   (\f -> (f 'c', f "string")) id
17:52:21 <Igloo> The former being (id 'c', id "string")
17:52:39 <Igloo> And the latter a type error
17:52:54 <vincenz> SamB: do you suggest a similar approach with symbols?
17:53:07 <dons> vincenz, check http://darcs.complete.org/fptools/ghc/compiler/parser/Lexer.x
17:53:09 <Pseudonym> Hang on.  Haskell doesn't have a [/] operator.
17:53:15 <SamB> vincenz: hmm, possibly not
17:53:34 <vincenz> listToUFM ???
17:53:44 <vincenz> SamB: I was thinking of doing it, but it seems impossible
17:53:49 <vincenz> SamB: consider ([])
17:53:53 <dons> just read it as M.fromList, i think.
17:53:55 <SamB> yeah
17:53:56 <Pseudonym> The type of f internally is actually /\ a -> \ (x :: a) -> x 
17:54:01 <SamB> > [ ] :: String
17:54:03 <lambdabot> ""
17:54:09 <SamB> > ( ) :: String
17:54:10 <lambdabot> Couldn't match `String' against `()'
17:54:13 <vincenz> also in happy
17:54:15 <SamB> > ( ) :: ()
17:54:15 <Pseudonym> Sorry, the definition internally.
17:54:16 <lambdabot> ()
17:54:18 <vincenz> can I hae something like this in the token definition
17:54:31 <SamB> > ( , )
17:54:32 <lambdabot>  add an instance declaration for (Show (a -> b -> (a, b)))
17:54:33 <ihope> > [ ] :: ()
17:54:33 <vincenz> %token '(' { CxxAsciiToken '(' }
17:54:34 <lambdabot> Couldn't match `()' against `[a]'
17:54:35 <Igloo> That's why I said "Not if that's capture-avoiding substitution, it's not"
17:54:52 <vincenz> I use a flyweight of 1-symbol tokens
17:54:53 <Pseudonym> Ah, right.
17:55:00 <vincenz> err
17:55:02 <vincenz> flyweight table
17:55:20 <vincenz> basically anything that's not matched, is matched by a single character, which is then made into CxxAsciiToken thatchar
17:55:23 <SamB> anyway, [] needs to be handled in the parser
17:55:28 <SamB> as does ()
17:55:32 <vincenz> so in happy could I then match against the data in that constructor?
17:55:58 <vincenz> %token '='    { CxxAsciiToken '=' }
17:55:59 <Pseudonym> Gotta go.  Meeting with my boss.
17:56:02 <Pseudonym> BBL
17:56:04 <vincenz> or can one only match against constructors?
17:56:16 <SamB> vincenz: see what GHC does for that one ;-)
17:56:19 <ihope> fix' x = seq (fix x) (return (fix x))
17:56:24 <SamB> or anything biggish
17:56:53 <vincenz> haskell uses a unique name for each symbol
17:57:10 <vincenz> I was just wondering it's possiible to match
17:57:13 <vincenz> but I think it should be
17:57:22 <vincenz> the reason for this is that then I only have to update my parser
17:57:27 <vincenz> if I change my langspec
17:57:54 <vincenz> @hoogle UFM
17:57:55 <lambdabot> No matches found
17:59:24 <vincenz> @hoogle lookup
17:59:24 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
17:59:24 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
17:59:24 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
18:13:51 * vincenz sighs
18:15:50 <ihope> Haskell + something = :-)
18:16:11 <ihope> something = 0
18:16:27 <vincenz> I'm stuck on a decisiion :/
18:32:36 <Cale> vincenz: which decision?
18:35:07 <vincenz> Cale: how to make my langage
18:35:11 <vincenz> s/langage/language
18:37:17 <vincenz> make it close to c, not make it close to c... allow how much complexity such that I can accomodate future decisions without getting mucked down in the gritty details
18:37:20 <vincenz> stuff like that
18:37:47 <Cale> What's the goal?
18:37:48 <vincenz> I'm opting for a somewhat reduced c with a few extra operation
18:38:04 <Cale> just to gain experience?
18:38:05 <vincenz> Cale: make a model to do try out some source-to-source transfos
18:38:11 <Cale> ah
18:38:23 <vincenz> specifically ddt-related ones
18:38:32 <vincenz> so I added a basic type "ddt"
18:38:34 <Cale> Is it supposed to be a practical language for writing actual programs?
18:38:36 <vincenz> which could be a list or vector
18:38:39 <vincenz> Cale: no
18:38:53 <vincenz> but on the other hand, as I expand my possibilities, I don't awnt to redesign the language each time
18:38:57 <vincenz> so I'm opting for a simplified c
18:39:01 <vincenz> with extra ddt-primitives
18:39:08 <vincenz> like add, insert,append,size,remove
18:39:14 <Cale> yeah, you should probably include just enough to make it Turing complete
18:39:21 <vincenz> but for instance
18:39:23 <Cale> plus whatever you're studying
18:39:24 <vincenz> my for loops will be fixed
18:39:33 <vincenz> aka... for(definition, condition, increment)
18:39:42 <vincenz> not allowing , in expressions in the individual statements
18:39:57 <Cale> why a C-like syntax?
18:40:04 <vincenz> Cale: cause I'm coming from c++
18:40:40 * vincenz is studying intermediate variable removal (ddts) in the context of multimedia applications (which are typicallly written in c++)
18:40:58 <vincenz> types are only : int, float and ddt
18:41:04 <vincenz> oh yeah and T
18:41:08 <Cale> do you need for-loops with that level of generality?
18:41:10 <vincenz> for the basic data type stored in a ddt
18:41:21 <vincenz> Cale: originally I had written a parser in ocaml
18:41:23 <Cale> It's probably easier to only include numeric loops.
18:41:24 <vincenz> with the construct
18:41:33 <vincenz> foreach x in (exp..exp)
18:41:41 <Cale> yeah
18:41:55 <vincenz> the problem is that if then I want to allow different iteration than purely incremental, it will no longer work
18:42:09 * vincenz removes float
18:42:10 <Cale> or just while loops
18:42:17 <vincenz> Cale: while loops are hard to analyze
18:42:18 <Cale> if you have mutable variables
18:42:21 <Cale> ah, okay
18:42:43 <vincenz> I have them in my syntax
18:43:04 * vincenz removes FLOAT and adds T
18:43:27 <vincenz> err...I'll call it data
18:43:35 <Cale> aren't general for-loops like that just as bad as while loops?
18:43:43 <vincenz> Cale: depends on how they are written
18:43:56 <vincenz> however typically you can determine more
18:44:02 <vincenz> with while loops you'd first have to do an iterator analysis
18:44:07 <vincenz> to determine what the iterator is
18:44:13 <Cale> is the iterator mutable?
18:44:25 <vincenz> Cale: well obviously you do a quickcheck to determine whether it's being mutated
18:44:38 <Cale> okay
18:44:54 <vincenz> my types are: bool, ,data, ddt, int, void (and const)
18:45:04 <vincenz> that should suffice
18:45:24 <vincenz> not yet sure about pointers vs references
18:45:40 <vincenz> I can probably leave those out for now
18:47:17 <vincenz> it'd be nice if I could make my lexer lazy
18:47:37 <vincenz> it's a sort of state monad (though custom made)
18:47:38 <Cale> If you had lists/generators, you could use foreach
18:49:55 <Cale> I should probably ask what ddt actually stands for :)
18:50:01 <vincenz> Cale: dynamic data type
18:50:12 <Cale> ah, okay
18:52:01 <Cale> So a variable of type ddt is a mutable cell which could be of any of the other types?
18:52:14 <vincenz> Cale: ddt is something like a list or vector
18:52:20 <Cale> hmm
18:52:23 <vincenz> basically a sequence
18:52:31 <Cale> hmm
18:52:38 <Cale> How is the sequence computed?
18:52:44 <vincenz> that's in the code
18:52:58 <Cale> The operations on it are strict?
18:53:05 <vincenz> Cale: it's c++
18:53:14 <Cale> okay, so probably strict then :)
18:54:41 <vincenz> time to add the grammar o.O
18:55:05 <Cale> I'd be interested in seeing an imperative lazy language, which used lists in its basic looping primitives :)
18:55:46 <vincenz> me wonders whether to allow ++ and --
18:59:02 <vincenz> grr
18:59:11 <vincenz> how do I hide List.lookup from the prelude?
19:00:01 <vincenz> time to write my first ever prelude
19:00:13 <vincenz> it sucks you have to duplicate a lot of language choices of the tokens in a Token.hs and the parser
19:00:24 <vincenz> err
19:00:28 <vincenz> not prelude, happy parser
19:01:33 <dons> you can import the token defn, can't you?
19:01:40 <dons> into the parser defn.
19:02:24 <vincenz> dons: you still need to do
19:02:26 <vincenz> %token ...
19:02:39 <dons> ah, true.
19:02:50 <dons> or write a preprocessor... i've done that on occasion
19:03:22 <dons> that generates both Token.hs and splices in the %token stuff
19:03:48 <vincenz> question
19:03:49 <vincenz> can I do this
19:03:59 <vincenz> '('     { TokenAscii '(' }
19:04:20 * vincenz uses flyweights for any singlecharacter symbols that have not been taken by a multicharacter regexp lexer rule
19:08:54 <vincenz> ascii_map           = map TokenAsciiToken $ map toEnum [0..255]
19:08:54 <vincenz> make_ascii_token  s = ascii_map !! (fromEnum $ head s)
19:11:33 <vincenz> I have to admit that the %token bit is quite useful
19:11:38 <vincenz> cause it allows you to define mnemonics
19:11:47 <vincenz> which is much clearer than using the tokendataconstructor names
19:13:24 <vincenz> what's the range of Int in Haskell?
19:13:31 <vincenz> I know I had issues in ocaml cause it's only 31bit
19:13:46 <vincenz> > maxBound::Int
19:13:47 <lambdabot> 2147483647
19:13:52 <vincenz> > minBound::Int
19:13:53 <lambdabot> -2147483648
19:13:56 <vincenz> nice :)
19:14:28 <vincenz> > read "0x56" :: Int
19:14:29 <lambdabot> 86
19:14:31 <vincenz> > read "056" :: Int
19:14:32 <lambdabot> 56
19:14:34 <vincenz> hmm
19:14:36 <vincenz> no octal?
19:14:51 <vincenz> > read "0X56" :: Int
19:14:52 <lambdabot> 86
19:15:51 <vincenz> any quick way to convert a number from octal to decimal?
19:17:46 <tony2> > readOct "0x56" :: Int
19:17:47 <lambdabot> Couldn't match `Int' against `[(a, String)]'
19:18:00 <vincenz> @type readOct
19:18:01 <lambdabot> Not in scope: `readOct'
19:18:05 <vincenz> @hoogle readOct
19:18:05 <lambdabot> Numeric.readOct :: Num a => ReadS a
19:18:05 <lambdabot> Text.Read.Lex.readOctP :: Num a => ReadP a
19:18:13 <vincenz> > readOct "056"
19:18:14 <lambdabot> [(46,"")]
19:18:38 <vincenz> > fst $ head $ readOct "056"
19:18:39 <lambdabot> 46
19:18:43 <vincenz> thx!
19:19:02 <tony2> ;)
19:19:12 <vincenz> oh yeah, I forgot to mention
19:19:14 <vincenz> haskell rocks!
19:19:30 <tony2> indeed it does.
19:20:08 <vincenz> ok, small question about happy
19:20:12 <vincenz> I see you can do
19:20:27 <vincenz> %token '(' { TokenLight '(' }
19:20:34 <vincenz> what about multisymbol ops
19:21:26 <dons> > 0o56
19:21:27 <lambdabot> 46
19:21:43 <vincenz> dons: maybe you know?
19:21:49 <vincenz> would I use "<<"  {TokenShiftLeft}
19:21:50 <vincenz> ?
19:23:31 <dons> the ' and " are not the same as in Haskell.they'ree interchangeable, iirc. i.e.  '->'       { L _ ITrarrow }
19:23:36 <dons> check the ghc parser.
19:23:50 <vincenz> ah ok
19:23:53 <vincenz> cause it's noto well documented
19:23:58 <dons> even  '-<<'      { L _ ITLarrowtail }
19:24:03 <vincenz> thx 
19:26:09 <vincenz> @type True
19:26:10 <lambdabot> Bool
19:27:09 <palomer> I'm an idiot
19:27:27 <vincenz> I concur
19:28:38 <vincenz> jk
19:28:59 <palomer> ouch
19:29:04 <palomer> google videos refuses to play now
19:29:58 <vincenz> palomer: I was just kidding .. :/
19:31:12 <vincenz> how does happy know where to start parsing
19:31:17 <vincenz> I mean what the toplevel parse-rule is
19:32:22 * palomer feels lonely all of a sudden
19:36:04 <vincenz> found it
19:36:32 <vincenz> anyone care to look at my alex lexer and tell me how to make it lazy
19:43:53 <Cale> 9... more... threads...
19:44:05 * Cale tries to catch up with the mailing lists
19:45:07 <vincenz> Cale: do you suggest one "ASTType"
19:45:26 <vincenz> or different ones based on whether it's a return type, definition type or formal parameter
19:45:33 <vincenz> cause the parser-rules *will* be different
19:45:51 <vincenz> nm
19:46:16 <vincenz> ignore
19:47:05 <Cale> vincenz: It really depends on how you plan to compile the language.
19:47:27 * vincenz tries to figure out some good names for his AST units
19:50:16 <vincenz> @hoogle ident
19:50:17 <lambdabot> Text.Read.Lex.Ident :: String -> Lexeme
19:50:17 <lambdabot> Text.Read.Ident :: String -> Lexeme
19:50:17 <lambdabot> Text.Html.identifier :: String -> HtmlAttr
19:51:20 * vincenz wonders how haskell does the vertical layout thingy with alex
19:55:00 <Cale> possibly by desugaring it beforehand
19:55:38 <Cale> there are rules which specify which tokens are to be inserted based on indentation
19:56:06 <vincenz> ah
19:58:00 * vincenz continues hacking
20:03:20 <mae> i am trying to get the value 'c' in this function, but I get an error ... why? snd . head ([(2, 'c'), (5, 'r')])
20:03:52 <Cale> you're composing snd with the head of that list
20:04:05 <sjanssen> > snd . head $ [(2, 'c') (5, 'r')]
20:04:05 <Cale> Perhaps you mean snd . head $ [...]
20:04:06 <lambdabot>   The function `(2, 'c')' is applied to one arguments,
20:04:06 <lambdabot>   but its type `(a, b)' has none
20:04:06 <lambdabot>   In the list element: (2, 'c') (5, 'r')
20:04:07 <mae> yeah - head returns a pair ?
20:04:30 <Cale> > snd . head $ [(2, 'c'), (5, 'r')]
20:04:32 <lambdabot> 'c'
20:04:40 <mae> hmm
20:04:51 <mae> sorry feel dumb - but new to functional programming
20:04:53 <Cale> snd . head [(2, 'c'), (5, 'r')] = snd . (head [(2, 'c'), (5, 'r')])
20:05:02 <Cale> = snd . (2, 'c')
20:05:07 <Cale> which is an error
20:05:13 <Cale> since (2,'c') isn't a function
20:05:22 <mae> head [(2, 'c'), (5, 'r')] returns a function??
20:05:40 <Cale> it would have to if it was to be composed, but it doesn't.
20:05:44 <Cale> > (snd . head) [(2, 'c'), (5, 'r')]
20:05:45 <lambdabot> 'c'
20:05:49 <Cale> that works though
20:05:54 <Cale> as does the variant with $
20:05:58 <mae> oh isee
20:06:00 <mae> wow tahts cool
20:06:11 <mae> so composition derives a new function from two existing ones?
20:06:14 <Cale> right
20:06:18 <Cale> @type (.)
20:06:18 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
20:06:20 <mae> that is so cool!
20:06:30 <mae> you don't have to explicitly tell it how to use it, it infers it all
20:06:37 <Cale> yeah
20:06:49 <mae> what do you guys think of erlang?
20:06:51 <Cale> f . g = \x -> f (g x)
20:07:18 <Cale> I don't really know too much about it. It's supposed to be pretty good at concurrency.
20:07:33 <mae> *Main> foo = snd . head
20:07:33 <mae> <interactive>:1:4: parse error on input `='
20:07:43 <mae> i get this error in ghci, but not if i put it in a source file -- why?
20:07:46 <vincenz> mae: you need to use let
20:08:07 <mauke> you can't have top-level bindings in the interpreter
20:08:11 <Cale> You aren't supposed to really make arbitrary declarations at the ghci prompt
20:08:15 <Cale> it's really for debugging
20:08:22 <Cale> but you can write
20:08:25 <dons> let foo = snd .head
20:08:26 <Cale> let foo = snd . head
20:08:29 <mae> omg
20:08:39 <mae> i'm about to spaz out
20:08:41 <mae> this is so wicked
20:08:45 <Korollary> lol
20:08:48 <Cale> hehe
20:09:06 * Korollary goes back to watching hockey
20:09:12 <dons> @shootout -- and it is fast too, mae! (/me tries to hook him)
20:09:12 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
20:09:12 <lambdabot> all
20:09:23 <mae> i've been using ruby -- and its miles better than kludging around in C++ for my CS classes .. but man this is all new but i can see the potential for coolness if you get good with haskell
20:09:44 <mauke> do you know map?
20:09:51 <mae> yeah
20:09:58 <mae> some haskell concepts are familiar
20:10:03 <mae> i.e. map/collect and select/filter
20:10:07 <Cale> map f = foldr ((:) . f) []
20:10:31 <mae> wow - now thats some voodoo
20:10:44 <dons> yeah, that's pretty much true, mae. if you can use it, you can wipe out just about anything else.
20:11:01 <mauke> > foldr (+) 0 [2, 3, 5, 10]
20:11:02 <mae> are you guys fans of darcs? - i've been using mercurial
20:11:02 <lambdabot> 20
20:11:13 <vincenz> mae: love darcs
20:11:27 <Cale> mae: yeah, we all support darcs. It's written in Haskell after all :)
20:11:37 <dons> darcs is compulsory.
20:11:45 <mae> how does it compare too git/mercurial in terms of decoupled development?
20:12:09 <mae> is there a cgi interface written in haskell?
20:12:13 <Cale> I haven't used git/mercurial, but darcs is fairly nice anyway
20:12:32 <Cale> CGI interface to darcs?
20:12:38 <dons> a cgi interface to darcs? there is one, not sure what it's written in.
20:12:49 <vincenz> mae: there's less of a need
20:12:52 <mae> no cgi interface to haskell
20:13:04 <mae> i'm using rails alot for some business projects
20:13:04 <vincenz> mae: unless you want to see history, the darcs repo shows the file plain 
20:13:12 <Cale> There's a simple CGI library which comes with GHC.
20:13:23 <mae> ic :)
20:13:42 <Cale> It's incredibly simple, but I've found it was enough to get some simple things done.
20:13:49 <mae> how does haskell stack up as far as dynamic features go, and object oriented-ness? i know in ruby i can redefine classes on the fly and metaprogram as needed
20:14:59 <mauke> Haskell is pretty non-OO
20:15:06 <sjanssen> mae: Haskell is static too
20:15:08 <Cale> Haskell isn't an OO language, but GHC has existential types
20:15:20 <Cale> As well as dynamic typing if you really really need it
20:15:24 <sjanssen> mae: that's not to say that we Haskellers don't have far superior alternatives ;)
20:15:55 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
20:16:09 <Cale> Type safe dynamic typing :)
20:16:16 <Korollary> eh
20:16:34 <Cale> I've never really needed it
20:16:38 <Cale> but it's there
20:16:47 <Korollary> I despise untyped stuff anyways
20:17:07 <dons> usually, there's much safer alternatives. and OO is never needed
20:17:17 <Cale> The truth is -- types are one of the best ways to prevent bugs, and help structure the design of your program
20:17:47 <Cale> If you lean heavily on the type system, it can actually prevent some pretty subtle bugs.
20:18:20 <dons> and the great thing is that since you check all these things statically, you can avoid costly runtime checks -- the code just works
20:18:41 <Cale> The major problem in Haskell is interfacing OO designs with Haskell code -- large product types are hard to deal with.
20:18:51 <Cale> and they're common in OO languages
20:19:00 <Cale> (that is, records with lots of fields of different types)
20:19:21 <lispy_> dons: i like OO and i think that while it might not be needed, it does provide useful forms of expression
20:19:26 <Korollary> I find that an extremely bad idea in general. They shouldn't have so much state.
20:19:26 <mae> sjanssen: ok -- tell me about these far superior alternative s:)
20:19:40 <lispy_> hmm...my nick is wrong
20:20:25 <Cale> mae: Well, parametric polymorphism, and bounded parametric polymorphism.
20:20:25 <dons> OO is a bit like Prolog backtracking/search. it's weird to base a whole language on one form of problem solving.. you need something more general.
20:20:31 <Cale> Note the type of map
20:20:50 <Cale> @type map
20:20:51 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
20:20:57 <lispy> dons: i think that of most of the single paradigm languages.
20:20:57 <mae> Korollary: where does the state belong, then ?
20:21:10 <mae> Cale: ugh i hate parametric polymorphism :)
20:21:15 <Cale> mae: why?
20:21:19 <lispy> mae: hate it?
20:21:23 <Cale> It's great :)
20:21:23 <mae> its so .. strict.
20:21:25 <Korollary> mae: Some state is inevitable. However, people just cram too much state together.
20:21:39 <lispy> i can't stand static typing without parametric polymorphism
20:21:43 <dons> mae, it's beautiful. you get code for free. it's particularly lovely in haskell
20:21:46 <Korollary> mae: parametric polymorphism in haskell is so much nicer than everywhere else.
20:21:55 <mae> Korollary: yeah i guess haskell is at the 'extreme' end of non-state :)
20:21:57 <dons> like map or (.)
20:22:03 <Cale> @type (.)
20:22:04 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
20:22:19 <Cale> that's parametrically polymorphic, of course :)
20:22:43 <Cale> then you have bounded parametric polymorphism, through the use of typeclasses
20:22:47 <mae> lispy: i agree with that, but i'm saying through out static typing alltogether :) i realize in compiled form this is a bit tough
20:23:02 <lispy> i tried to seriously use ocaml the other day and the lack of operator oveloading really annoyed me.  So I think operator overloading is really important :)
20:23:05 <Cale> lots of people will tell you that this is ad-hoc polymorphism, but I think 'ad-hoc' is too rough a term for what's going on here
20:23:11 <Cale> @type show
20:23:12 <lambdabot> forall a. (Show a) => a -> String
20:23:14 <sjanssen> mae: if you learn enough Haskell, you will love static typing.  I promise
20:23:21 <Cale> > show 5
20:23:22 <lambdabot> "5"
20:23:27 <Cale> > show [1,2,3]
20:23:29 <lambdabot> "[1,2,3]"
20:23:55 <lispy> i was annoyed at needing to use + vs. +.
20:24:07 <Korollary> lispy: everybody is. But I got over it.
20:24:07 <Cale> @type (+)
20:24:08 <lambdabot> forall a. (Num a) => a -> a -> a
20:24:27 <lispy> i created a num functor and created a module for Int and Float then i realized i couldn't use both modules at the same time
20:24:31 <Korollary> lispy: ocaml bugs me because it doesn't feel as FP as haskell does.
20:24:43 <mauke> > 1 / 2
20:24:44 <lambdabot> 0.5
20:24:49 <vincenz> can the expression for grammar rules be on a separate line?
20:24:49 <mauke> this is important
20:24:58 <vincenz> > 1 /2 :: Rational
20:24:59 <mauke> @type 1
20:24:59 <lambdabot> 1%2
20:25:00 <lambdabot> forall t. (Num t) => t
20:25:02 <lispy> Korollary: because it isn't pure?  or is it syntaxed based, or why do you feel that?
20:25:12 <mae> sjanssen: I loved static typing when i learned c++/c then i learned python/ruby and i like the lazy evaluation :)
20:25:47 <Korollary> lispy: It's not pure, and e.g. doing file i/o feels like writing in C.
20:25:48 <Cale> I think that strict FP languages are missing the boat to some extent. Laziness is an incredible tool for functional programming.
20:26:04 <vincenz> Cale: indeed, like in whyfp "an important glue
20:26:09 <Cale> Rather, non-strict semantics (if you want to be pedantic)
20:26:13 <Cale> vincenz: yes
20:26:28 <vincenz> can I put the grammar-expressions of grammar rules on a separate line with happy?
20:26:35 <vincenz> cause this is rather long
20:26:37 <vincenz>   : for '(' assign_stm ';' expression ';' assign_stm ')' statement     { SFor $3 $5 $7 $9 }
20:26:46 <Cale> vincenz: not sure -- try it?
20:26:51 <lispy> mae: okay, i went static typing good (learned C), then learned lisp and saw how pleasant a dynamic type system can be.  Then I learned haskell and realized that type safety is really important.  Then I realized that parametric polymorphism gives me most of what I liked about dynamic types
20:26:55 <vincenz> Cale: I'll get it to work plainly first :)
20:27:31 <vincenz> Cale: any suggestions on how to do lexical scoping after?
20:27:36 <vincenz> from a highlevel point of view
20:28:22 <lispy> Korollary: for me the syntax of ocaml is a turn off and as i mentioned before the lack of overloading is a drag
20:28:43 <Korollary> the syntax blows. But that's a minor one.
20:29:04 <vincenz> lispy: I used to love ocaml
20:29:08 <lispy> Korollary: and it seems that there are syntatical forms in ocaml that don't have a function equivalent, which totally defeats the purpose of HoF
20:29:13 <vincenz> lispy: now it's second place (and naerly useless) w.r.t haskell
20:29:40 <Cale> vincenz: the reader monad is a good way to keep track of binding environments
20:29:59 <lispy> vincenz: i wanted to see if i could optimize more easily when programming in ocaml but still have as much fun as i do with haskell
20:30:02 <dons> vincenz, I'm so pleased we one you over :)
20:30:11 <dons> s/one/won/
20:30:15 <vincenz> th
20:30:22 <vincenz> I've been wanting to rewrite this tool I made in ocalm
20:30:35 <vincenz> however I'm not sure cause it's basically a logfile (binary data) analyzer
20:30:42 <vincenz> and the logfiles can get huge (> 1GB)
20:30:47 <lispy> i find that haskell has better primitives that ocaml
20:30:50 <mae> lispy: static typing prevents the easiest bugs the way i see it -- its just a whole lot of extra typing and cruft for little gain -- and if i want my function to accept multiple types i have to worry about templates or polymorphic 'extra' functions 
20:31:04 <vincenz> Cale: well the idea is that I build the scoping environment, not sure how tho
20:31:14 <vincenz> Cale: so that if I have "int x;"...from then on x is defined
20:31:21 <vincenz> but "int x = x;" -> two different x's
20:31:27 <dons> mae, extra typing?/
20:31:33 <sjanssen> mae: type inference should save you most of the extra typing
20:31:47 <vincenz> the way I did it in ocaml was really ugly, and whenever I did a variable substitution, I'd have to reparse my entire ast
20:31:53 <dons> you type _less_ in haskell, than any other language.
20:31:57 <sjanssen> mae: it's pretty rare that you *must* write a type signature for a function
20:32:00 <vincenz> suggestions for doing lexical scoping are welcome
20:32:31 <lispy> dons: that's a strong claim, have you compared with APL ;)
20:32:35 <Cale> vincenz: hmm... I'd probably transform things so that a new block starts on each binding
20:32:41 <dons> any language on the shootout ;)
20:32:57 <vincenz> Cale: not sure what you mean
20:33:02 <dons> but the higher level the problem, the more haskell wins, so i think it may be true.
20:33:07 <vincenz> Cale: ah ok...yes but that could mean a lot of blocks
20:33:10 <vincenz> int x = 0;
20:33:12 <vincenz> some stuff
20:33:13 <vincenz> some stuff
20:33:15 <vincenz> int y = 0
20:33:20 <Cale> right, it could
20:33:40 <vincenz> it would severely decrease visibilty of the ast
20:33:46 <Cale> mm
20:33:51 <vincenz> especially if you want to do rule-based transformations
20:34:12 <vincenz> but my biggest issue is with type renaming
20:34:15 <Cale> well, that's the trouble with that sort of scoping though :)
20:34:21 <vincenz> how I did it in ocaml is that I'd share a mutable environment
20:34:26 <vincenz> so that I can just rename in one place, and voila
20:34:35 <Cale> hmm
20:34:41 <vincenz> it wasn't very clean
20:34:44 <Cale> actually, you might still be able to use the Reader monad
20:34:48 <lispy> but here is a problem with haskell: if you work in industry it's very unlikely that you'll be shipping any haskell code in the next release :)
20:34:49 <vincenz> Cale: reader reads...
20:34:55 <Cale> and simply treat it as if there was a block there
20:35:08 <Cale> vincenz: have you seen a lambda evaluator using the reader monad?
20:35:14 <vincenz> I'm afraid not
20:35:20 <dons> mae, check the lines of code -- statically typed functional languages are the shortest --> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all&calc=Calculate&xfullcpu=0&xmem=0&xloc=1
20:35:28 <Cale> okay, let me post one that I grabbed somewhere
20:35:53 <vincenz> thx
20:36:00 <Cale> lisppaste2: url
20:36:00 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:36:15 <Cale> should give you an idea :)
20:36:39 <lisppaste2> Cale pasted "reader lambda evaluator" at http://paste.lisp.org/display/16607
20:36:47 <vincenz> btw
20:36:49 <vincenz> as for my ast
20:36:53 <vincenz> any suggestions on how to make it
20:36:59 <vincenz> I'm thinking of adding an extra blank parameter
20:37:06 <vincenz> so that I can make different types of ast's
20:37:16 <vincenz> parsedast, scopedast, typedast...
20:37:25 <dons> not sure , havne't been following. but sure, paramatersied asts are a good idea.
20:37:27 <vincenz> but typically it's not very llean
20:37:31 <dons> ghc uses them
20:37:34 <lispy> oh that reminds me.  I was learning about xml and xslt today and i think xml is just a syntax for describing ASTs
20:37:35 <vincenz> true
20:37:38 <Cale> Or a typeclass
20:37:47 <vincenz> Cale: how so?
20:38:00 <Cale> Well, work out all the operations which you'd need on an AST
20:38:06 <Cale> and encode that in a typeclass
20:38:25 <Cale> then you can swap the AST representation out and have functions which apply to any type of AST you'd like
20:38:29 <lisppaste2> vincenz pasted "ModelAST" at http://paste.lisp.org/display/16608
20:38:40 <vincenz> note that exp isn't done yet
20:40:44 <Cale> hmm
20:40:45 <vincenz> I do remember from the more limited model that I had done in ocaml, that the biggest pain in ass was the lexical scope analyzer
20:40:50 <vincenz> and the way I had to make my environments
20:41:07 <Cale> Have a close look at the way that lambda evaluator works
20:41:10 <vincenz> cause I have to guarantee ident uniqueness which is more than just string
20:41:27 <vincenz> basically modelIdent will inevitably become (String, Int) with Int a unique id
20:41:53 <Cale> hmm
20:42:08 <mae> dons: i know FL's are shorter :) but -- ugh :) this is all so new to me!
20:42:40 <Cale> mae: what tutorial(s) are you looking at, btw?
20:43:10 <Cale> For those new to functional programming, I really recommend YAHT
20:43:17 <palomer> I find that when you need uniqueness, strefs come in handy
20:43:18 <Cale> @google yet another haskell tutorial pdf
20:43:19 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
20:43:31 <palomer> yaht is great
20:43:40 <palomer> but it could do a better job of explaining monads
20:43:46 <Cale> palomer: I don't understand why you'd use STRefs when integers would do :)
20:44:09 <Cale> palomer: yeah, the monad explanation isn't so great
20:44:17 <mae> Cale: YAHT
20:44:22 <Cale> For monads, I recommend my explanation :)
20:44:28 <palomer> Cale: integers could do for anything, really
20:44:34 <Cale> @wiki MonadsAsContainers
20:44:34 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
20:44:40 <palomer> Cale: but you only explain the contairs perspective
20:44:59 <palomer> you could probably rewrite that tutorial, replacing all allusions to containers to statements about computations
20:45:33 <Cale> palomer: right, but I'd still want people to read the container one first.
20:45:40 <mae> guys -- if FP is the best thing since fried chicken, then why does the world run on imperative languages? i mean is it really possible to build powerful software with haskell quickly? and to a large scale? how come there does not exist more useful haskell programs
20:45:57 <Korollary> It took the world two decades to start using OO as well.
20:46:06 <Cale> mae: Historical reasons
20:46:14 <gzl> mae: Haskell itself is pretty new, that way
20:46:50 <Cale> it's hard to find Haskell programmers, so companies don't write things in Haskell, and since it's hard to get a job writing Haskell code (or at least seems that way), people don't bother to learn it
20:47:35 <mae> ic :)
20:47:40 <gzl> also, lots of companies have lots of legacy code
20:47:42 <palomer> fp a la haskell isn't always the best thing
20:47:55 <palomer> I can't see using haskell to write most of the real world code I do
20:47:55 <mae> well - the way i see it you could apply alot of functional concepts to languages such as python/ruby
20:48:16 <Cale> mae: you could, but a lot of them would come out mutilated
20:48:19 <gzl> python does let you use a functional style
20:48:44 <palomer> gzl: single line lambdas, yay!
20:48:54 <Cale> Monads come out as very awkward in languages without typeclasses.
20:49:10 <palomer> functional style == building things from combinators
20:49:19 <mae> palomer: why is that? is it because keeping everything 'pure' so to speak is difficult? and that quick hackup functions with 'side-effects' are getting the program working the way you want faster or what..
20:49:48 <gzl> actually, I wasn't talking about single line lambdas, but I also don't feel like wasting time arguing about it.
20:50:03 <palomer> mae: sometimes formalising my code would take about 10 times more time, and pointlessly too
20:50:38 <Cale> I don't feel the same way. I think I could do most things in Haskell in about 10 times less time and code.
20:50:41 <palomer> and quite frankly, I don't care if my code is 100% correct sometimes
20:50:52 <palomer> I find haskell overly verbose sometimes, too
20:51:14 <Cale> palomer: the code you write tends to be fairly odd though
20:51:24 <palomer> Cale: what do you mean by odd?
20:51:36 <Cale> I'm not completely sure really :)
20:52:04 <user317> palomer: thats kind of odd, i am comming from C and ml, and i find haskell to be succinct 
20:52:18 <Cale> Usually in Haskell, you want to avoid state as much as possible, by any means necessary. You seem to love ST.
20:52:19 <palomer> user317: it's succinct for certain things
20:52:21 <palomer> verbose for others
20:52:41 <palomer> Cale: when playing around with unification, ST is a _must_
20:53:03 <palomer> if I had to constantly lookup things in maps, I'd go nuts!
20:53:10 <Cale> I'm not sure if it is, really. I remember writing a simple unification algorithm without it at one point.
20:53:39 <palomer> Cale: using substitutions?
20:53:58 <Cale> hmm... I think there were maps involved.
20:54:01 <palomer> ST lets you avoid substitutions, substitutions are slow and prone to error
20:54:31 <dons> yeah, we write them as example tutorial examples in about 20 lines of non-ST code. maybe you should read Typing Haskell in Haskell, palomer.
20:54:32 * lispy needs to learn how to do unit testing
20:54:51 <Cale> Somehow I don't think I needed to make substitutions. I just gave everything a type and solved the system of equations.
20:55:32 <palomer> Cale: solving a system of equations means building a map from variables to types, right?
20:55:40 <Cale> yeah
20:55:43 <vincenz> @type reverse
20:55:44 <lambdabot> forall a. [a] -> [a]
20:55:52 <palomer> this map must carry an invariant: image (image x) = image x
20:55:58 <Cale> I'm a little hazy on what I actually did, but it was reasonably elegant
20:56:01 <palomer> or else you get weird stuff happening
20:56:16 <palomer> to keep this invariant true, you constantly do substitutions inside your map
20:56:23 <palomer> dons: substitutions in 20 lines?
20:56:27 <palomer> yeah, that's about write
20:56:32 <palomer> you need to keep track of a counter too
20:56:33 <palomer> etc...
20:56:36 <palomer> it's a pain
20:56:51 <vincenz> ?
20:57:27 <lispy> keeping track of a counter sounds like something a monad could help with
20:58:00 <Cale> heh, I recall I also had to do some Gauss-Jordan elimination, as some types were allowed to have SI units on them
20:58:09 <dons> ST sounds like you've got "joelr syndome", palomer ;)
20:58:42 <lispy> dons: i have to ask, what is joelr syndrome?  and yes i vaguely know about the poker server
20:58:46 <Cale> Gauss-Jordan elimination is surprisingly easy to do recursively with lists of lists :)
20:58:58 <palomer> joelr?
20:59:23 <palomer> you did gauss-jordan elimination for unification?
20:59:30 <Cale> of SI units, yeah
20:59:37 <palomer> what are SI units?
20:59:55 <Cale> http://en.wikipedia.org/wiki/SI_units
21:00:03 <Cale> Système International d'Unités
21:00:16 <palomer> oh, righto
21:00:24 <palomer> I really don't see where gauss-jordan elimination comes in
21:02:21 <palomer> anyways, ST is ideal when 1) you need to do global subsititutions 2) you need to create unique elements
21:02:53 <Cale> It's not ideal for the creation of unique elements, since it's too big.
21:03:10 <palomer> 1 and 2 combined
21:03:15 <palomer> 2 can be done in a smaller monad
21:11:53 <Cale> I wonder if reference identity is actually right. Something about being able to compare cells for equality seems odd to me, but I can't quite put my finger on what it is.
21:12:53 <vincenz> Cale: what do you suggest for binary operators
21:13:02 <vincenz> EBinary ModelOp ModelExpreession ModelExpression
21:13:05 <Cale> vincenz: translate them into function calls.
21:13:06 <vincenz> or making a unique one for each op?
21:13:49 <Cale> or at a closer-to-source level, you can just represent them specially
21:14:02 <Cale> (like that)
21:14:10 <vincenz> just not sure whether I'd go for EPlus .. EMinus ...
21:14:14 <vincenz> or EBinary OpPlus 
21:14:26 <Cale> EBinary is better
21:14:40 <dons> lispy, joelr syndrom, which I just coined ;) is a syndrom where, against community advice, you write your code in an elaborate and verbose way, and then claim publically that Haskell forces you to write your code in an elaborate and verbose way.
21:14:42 <vincenz> or unary I'll make unique ones
21:14:44 <vincenz> cauase there's only two
21:14:47 <vincenz> negate and not
21:14:51 <vincenz> s/or/for
21:15:01 <Cale> but if you're going to have arbitrary function calls in your language, you almost might as well turn them into those in the AST
21:15:07 <vincenz> Cale: nah
21:15:13 <Cale> why not?
21:15:18 <vincenz> doesn't match c well
21:15:50 <Cale> hmm. It cuts down on the size of your specification though
21:15:59 <vincenz> Cale: but makes source-outputting messier
21:16:05 <Cale> oh, sure
21:16:43 <Cale> but I'd almost recommend moving to another type of tree with things more desugared before compiling.
21:16:49 <Cale> (or interpreting)
21:16:52 <vincenz> I'm not compiling or interpreting
21:16:58 <Cale> oh, right
21:17:04 <Cale> you're just doing source -> source
21:17:07 <vincenz> right
21:17:10 <Cale> okay then :)
21:17:13 <vincenz> :)
21:17:27 <Cale> still
21:17:28 <Cale> hmm
21:17:56 <Cale> There's not much difference between those operators and functions semantically, though I suppose you get purity for free.
21:18:08 <vincenz> possibly later
21:18:17 <vincenz> Kiss
21:20:53 <vincenz> whew, done
21:20:57 <vincenz> let's hope it works :D
21:21:16 <vincenz> @hoogle readOct
21:21:17 <lambdabot> Numeric.readOct :: Num a => ReadS a
21:21:17 <lambdabot> Text.Read.Lex.readOctP :: Num a => ReadP a
21:25:37 <vincenz> oy
21:27:51 <vincenz> damn
21:27:54 <vincenz> talk about compiler errors
21:28:31 <Cale> have a lot? :)
21:28:39 <vincenz> reduced it quite a bit, was something stupid
21:28:41 <vincenz> but yeah, some are long
21:28:48 <vincenz> and they refer to the ModelParser.hs and not the initial parser file :/
21:28:54 <vincenz> Cale: could I ask you a favor?
21:29:01 <Cale> sure, what is it?
21:29:28 <vincenz> well the lexer... a it's rather annoting cause it returns Either String [ModelToken] and then I have to match on Left or right, secondly it's not lazy
21:29:36 <vincenz> s/annoting/annoying/
21:29:55 <lisppaste2> vincenz pasted "ModelLexer" at http://paste.lisp.org/display/16613
21:30:02 <Cale> You're using the Either String monad?
21:30:07 <vincenz> it's not the monad
21:30:11 <vincenz> but that's the return type
21:30:22 <vincenz> I basically copied how the monad wrapper of alex works
21:30:28 <vincenz> andn added some extra stuff to the state
21:30:36 <vincenz> (which is currently not being used but is useful for strings)
21:30:37 <Cale> okay, so if there's a lot of cases there, switching to using the monad will help
21:30:57 <vincenz> Cale: the lexer is already a monad
21:31:03 <vincenz> but it returns Either String [ModelToken]
21:31:04 <Cale> ah, I soo
21:31:06 <Cale> see*
21:33:46 <Cale> okay, so what do you want it to do?
21:34:13 <vincenz> Cale: well I would like it to return lazy token-monad (instead of list)
21:34:24 <vincenz> well list will do actually
21:34:25 <vincenz> but lazy
21:34:31 <vincenz> and not the Either string stuff 
21:34:37 <vincenz> nt sure how tho
21:34:52 <Cale> hmm, I don't know much about Alex, as I've never used it
21:35:05 <vincenz> Cale: all the code is very unalexy
21:35:10 <vincenz> alex only really requires two things
21:35:15 <vincenz> which are the functions that have alex in the name
21:35:19 <vincenz> all the rest is nonalexy
21:35:26 <Cale> okay
21:36:02 <vincenz> just not very clean :/
21:36:11 <vincenz> I already struggled quite a bit to make it return a list of tokens
21:36:14 <Cale> okay, yeah, in scanner, that loop is definitely not lazy
21:36:32 <vincenz> ideally I could do
21:36:33 <vincenz> x <- getToken
21:36:36 <vincenz> or possibly 
21:36:43 <vincenz> [getTokenListwhichislazy]
21:36:48 <vincenz> to be used by the lexer
21:36:52 <vincenz> err...parser
21:38:25 <Cale> does this compile?
21:38:30 <Cale> I'd like to try it
21:38:52 <vincenz> Cale: well given a suitable modelLexer, yes
21:38:53 <vincenz> err
21:38:54 <vincenz> ModelToken
21:39:02 <vincenz> and a main
21:39:13 <vincenz> only 4 shift/reduce conflicts!!!!
21:39:15 <vincenz> wheee
21:40:44 <gFunk> question: i'm trying to foldl' over a really long list (~10 mil lines).  is there a way to allow the runtime to free each element of the list after iterating over it?  currenty, it's exhausting the heap after under 100k lines 
21:41:22 <vincenz> blegh, it won't show which conflicts
21:42:54 <Cale> gFunk: it ought to free anything which isn't needed -- what is the type of the list?
21:43:05 <Cale> you might need stricter data
21:44:00 <gFunk> Cale: list is type IO[(Int,Double,Double)]
21:44:06 <Cale> aha
21:44:11 <gFunk> here's the code: http://pastebin.com/546214
21:44:23 <Cale> replace the (Int,Double,Double) with a new datatype, and make the fields strict
21:44:40 <vincenz> anyone know how to make hapyp actually display the conflicts
21:44:45 <Cale> data MyType = MyCons !Int !Double !Double
21:45:03 <Cale> vincenz: any reason you chose Happy/Alex over Parsec?
21:45:14 <vincenz> Cale: parsec is LL?
21:45:16 <gFunk> ok, do i need to enable that extention explicitly
21:45:20 <vincenz> Cale: people suggested them
21:45:23 <Cale> vincenz: LL(k) for any k :)
21:45:32 <Cale> actually LL(infinity)
21:45:36 <vincenz> Cale: I had a yaccable and lex thingy lying around in ocaml
21:45:50 <Cale> ah, okay, so perhaps more easy to translate
21:46:00 <vincenz> too bad happy won't actually display the conflicts, I think that's actually a severe limitaiton
21:46:08 <Cale> gFunk: I think it's H98
21:46:13 <vincenz> Cale: well it was for the reduced model, now the model is expanded to near-c
21:46:27 <gFunk> Cale: ok, i'll give it a shot.  thanks
21:46:35 <vincenz> next: scope analysis
21:46:37 <vincenz> then type analysis
21:46:45 <Cale> gFunk: the problem is that the seq in foldl' is only evaluating the (,,) constructor
21:46:53 <Cale> and not the contents of the triple
21:47:01 <Cale> so it's basically as bad as foldl
21:47:32 <gFunk> Cale: i see.  so that's what that DeepSeq and $!! are about, eh?
21:47:37 <vincenz> gFunk: I think it builds a really big exp that's not evalled until you use the output data
21:47:40 <Cale> yeah
21:47:49 <Cale> right, it will
21:47:55 <Cale> it'll build 3 really large expressions
21:48:01 <Cale> most likely
21:48:08 <gFunk> alright, thanks guys
21:48:52 <Cale> gFunk: what is that foldl actually doing?
21:49:00 <Cale> hmm...
21:50:39 <Cale> are you certain that you want a foldl and not a scanl or a foldr?
21:51:13 <Cale> oh, it does look like you're collapsing things
21:51:27 <Cale> these type signatures are too general to be useful in some sense :)
21:57:58 <vincenz> woot
21:58:04 <vincenz> only one shift reduce conflict after I remove a bug
21:58:33 <lispy> i'd say shift
21:58:34 <vincenz> and it's the typical one
21:58:41 <vincenz> if else
21:58:52 <gFunk> Cale: too general?  I can tighten that up.  i'm really new to haskell, so I'm just pulling the types straight from ghc
21:59:08 * vincenz considers it a success
21:59:10 <vincenz> \o
21:59:21 <Cale> gFunk: I thought you might be -- it's sometimes nice to set up the types so that they encode more of your intent
21:59:29 <Cale> (pulling them from ghc)
22:00:14 <Cale> It's all a little awkward -- what exactly is this computing?
22:00:20 <gFunk> Cale: ok.  so save generic types for generic resuable operations?
22:00:29 <vincenz> Cale: any thoughts on that lexer (no pressure)
22:00:35 <vincenz> \o/ my parser works
22:01:10 <Cale> gFunk: yeah, to some extent at least, more specific types are useful if you have no intention to apply the function generally (though sometimes it can be good in the future to have general types)
22:01:12 <gFunk> Cale: it's not doing any useful computation at the moment.  the goal is the make a simulator that runs over historical data from the currency exchange
22:01:43 <Cale> vincenz: your problem is that you're recursing monadically before returning any of that list
22:02:22 <Cale> vincenz: try replacing the do with an mdo, just to see if that magically fixes it. (I'm not all that familiar with mdo, but it seems like it might do the trick)
22:03:13 <vincenz> @hoogle mdo
22:03:13 <lambdabot> No matches found
22:03:20 <Cale> mdo is syntax
22:03:22 <vincenz> que es mdo?
22:03:33 <vincenz> [DFunc TInt "main" [FFormal TInt "x",FFormal TInt "y"] (SCompound [SDefinition (FFormal TInt "x") (EInt 1),SReturn (EIdent "x")])]
22:03:36 <vincenz> :)
22:03:44 <Cale> it's a variant of do which allows you to do recursive binding
22:03:49 <vincenz> ah
22:04:02 <vincenz> I think I need to resee my entire monad definition
22:04:06 <gFunk> whoops, i closed the window.  any messages come my way in the last 30 seconds?
22:04:07 <vincenz> I guess for now I'll try mdo and leave it at that
22:04:37 <Cale> vincenz: it's really just that you're calling loop there before returning the first element of the list
22:04:49 <vincenz> right, time to make my ast have an extra parameter 
22:05:12 <vincenz> Cale: yeah I think I need to resee that whole bit
22:05:59 <Cale> gFunk: you have a state computation there
22:06:24 <Cale> but since you call runState on it immediately, you're not getting much benefit at the moment
22:07:02 <gFunk> Cale: i pull the state out after each iteration and pass it on to the next one
22:07:10 <Cale> yeah, you shouldn't do that :)
22:07:15 <gFunk> how come?
22:07:27 <Cale> because that's exactly what the state monad is for
22:07:28 <gFunk> should i use foldM?
22:07:33 <Cale> threading state
22:07:38 <gFunk> what's that?
22:07:52 <Cale> okay, do you know how the State monad is defined?
22:07:59 <gFunk> yes
22:08:14 <Cale> newtype State s a = State { runState :: s -> (a,s) }
22:08:29 <Cale> do you recall what (>>=) looks like?
22:08:38 <Cale> x >>= f = ...
22:08:47 <gFunk> sure, mostly
22:09:43 * vincenz gets ready to go to work
22:09:49 <gFunk> i had orignally implemented it where State is passed all the way though, and used foldM.  it's when i started fighting laziness that I moved to foldl'
22:09:59 <Cale> gFunk: ah, okay
22:10:29 <vincenz> Cale: thx for all the help
22:10:34 <gFunk> i think foldM was blowing the stack, if i remember right
22:10:36 <Cale> vincenz: no problem
22:10:49 <Cale> gFunk: likely not foldM, but the result
22:11:05 <Cale> in fact, if you have strict data, I bet foldM would work fine
22:11:20 <gFunk> alright, i'll give it a go
22:11:35 <Cale> okay, let me know how that works out for you
22:12:23 <Cale> At worst, we'll write a stricter foldM, but I'd actually be kind of surprised if foldM was lazy.
22:13:00 <gFunk> k, thanks Cale
22:13:09 <Cale> I'm going to watch an episode of a show, and I'll be back after :)
22:14:32 <lispy> i can see why foldM might be lazy or strict by default
22:14:51 <lispy> and iirc droundy had a problem recently with laziness of foldM
22:40:50 <dons> @y0w
22:40:50 <lambdabot> I'm also pre-POURED pre-MEDITATED and pre-RAPHAELITE!!
22:46:24 <lispy> @keal
22:46:25 <lambdabot> obviously you never heard of Tier. theoretically it would work using
22:46:25 <lambdabot> nanobots
22:46:33 <lispy> ah, nanobots
22:53:26 <gFunk> Cale: i got it running, but still no luck with the strictness.  http://pastebin.com/546258
22:56:26 <Cale> okay, one sec
22:57:47 <Cale> okay
22:57:49 <Cale> foldM             :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:57:50 <Cale> foldM _ a []      =  return a
22:57:50 <Cale> foldM f a (x:xs)  =  f a x >>= \fax -> foldM f fax xs
22:59:24 <lispy> foldM f a (x:me) = f a x >>= \fax -> foldM f fax me
22:59:33 <lispy> it has an easter egg :)
22:59:48 <lispy> Cale: so i that lazy or strict?
22:59:55 <Cale> that's lazy
23:00:01 <lispy> how can you tell?
23:00:11 <Cale> there's no seq's
23:00:18 <lispy> lol, okay
23:00:32 <lispy> i expect a deeper level of reasoning i guess :)
23:00:36 <Cale> hehe
23:01:28 <lispy> so could you sneak an seq after the first x?
23:01:36 <lispy> f a x `seq` >>= ...
23:01:41 <lispy> @type seq
23:01:42 <lambdabot> forall b a. a -> b -> b
23:02:43 <Cale> gFunk: could I have the data which this runs on?
23:03:09 <gour> Lemmih: hi, ghc.hide does not build here. (http://www.rafb.net/paste/results/ibqYU078.html) any idea?
23:03:22 <joelk> foldM f a (x:xs) = let fax = f a x in fax `seq` foldM f fax me -- is a strict version, lispy
23:03:40 <joelk> s/me/xs/
23:03:41 <joelk> hehe
23:03:53 <Cale> um
23:03:57 <Lemmih> gour: I think they opdated Cabal.
23:04:01 <Cale> that will never do anything
23:04:16 <gour> Lemmih: what to in order to build hIDE?
23:04:25 <lispy> you'd still need a bind right?
23:04:30 <Cale> right
23:04:54 <Lemmih> gour: Pull from the real ghc repo.
23:05:04 <gour> Lemmih: head?
23:05:14 <Lemmih> gour: Yes.
23:05:15 <vincenz> re at work
23:05:28 <gour> Lemmih: ok. will be back to you :-)
23:06:37 * vincenz wonders how to do the scoping
23:06:45 <vincenz> Cale: see my biggest issue is if I were to inline a function...
23:07:09 * Lemmih should go a head and do some administrative work on hIDE.
23:07:23 <lispy> anyone recommend a tutorial on writing good unit tests?  (I don't care what language it uses, java is fine)
23:07:40 <vincenz> lispy: tutorial or bookk?
23:07:48 <lispy> vincenz: books are good too
23:07:59 <lispy> i'm trying to get into TDD, but i find that i suck at it
23:08:08 <vincenz> lispy: there are a few books on it
23:08:26 * vincenz hates the linux version of skypes, you can't enter the options until you're online, but I need to set the proxy...HOW LAME
23:08:33 <Cale> I suppose you can use the QC style of testing.
23:09:03 <Cale> Determine the algebraic properties which your code should satisfy and generate random tests for those properties.
23:09:12 <lispy> Cale: to be honest, i'm mostly worried about using unit tests at work where i don't use languages with QC support
23:09:30 <sieni> qc?
23:09:34 <lispy> quickcheck
23:09:40 <Cale> that's okay, since you could still do the same thing in any language
23:09:49 <Cale> (just not as elegantly)
23:11:36 <Cale> of course, it doesn't work too well with highly stateful computations, but they're brutal to test no matter what you do.
23:12:03 <lispy> well, did anyone have a favorite book or website on the subject?
23:12:09 <lispy> or should i start searching?
23:12:40 <lispy> prehaps i'll need to be the one to find out what is the good site or book and report it back here :)
23:12:46 <Cale> :)
23:12:56 <sieni> In C I prefer to work on a file-by-file basis so that the file can be conveniently tested separately
23:13:13 <sieni> usually this means passing function pointer tables around
23:13:16 <vincenz> Cale: I've been thinking, I think I agree on introducing a new block whenver I define a variable, for the good reason that it leads to less places where I have to explicitly store the environment table
23:14:02 <lispy> sieni: hmm...interesting, and i bet the same would be useful in java
23:14:14 <sieni> In C++ one probably would use some abstract class
23:14:14 <vincenz> I'm just not sure how to do variable renaming
23:14:41 <Cale> vincenz: yeah -- you may want to remember which blocks were constructed algorithmically and which were in the code to begin with
23:14:53 <vincenz> Cale: I think flattening again should be reasonably decideable
23:14:55 <Cale> just for pretty printing's sake
23:15:05 <vincenz> aka, only blocks on if/else and for
23:15:20 <vincenz> my biggest concern is variable renaming
23:15:24 <sieni> lispy: maybe java has some interfaces or something similar for that
23:15:25 <vincenz> which is necessary for inlining
23:15:37 <Cale> shouldn't that be relatively easy?
23:15:47 <vincenz> Cale: it requires a deepcheck
23:15:50 <Cale> Or do you want really pretty names? :)
23:16:03 <vincenz> Cale: well no, but...hmm...
23:16:07 <vincenz> int x = 0;
23:16:10 <vincenz> int y = f(x);
23:16:10 <Cale> Not if you use names which are otherwise illegal :)
23:16:13 <vincenz> int z = x;
23:16:30 <vincenz> and f(int x) { return x;}
23:16:49 <vincenz> well imagine it's more than one line of code, obviously
23:17:11 <vincenz> it would require me to rename all the variables in f so tehy don't conflict with variables in the callee
23:17:14 <Cale> did you read that lambda evaluator
23:17:15 <Cale> ?
23:17:20 <vincenz> not yet fully
23:17:26 <vincenz> but the evaluator is easier
23:17:28 <vincenz> you don't do renaming
23:17:32 <vincenz> which is the big hassle
23:17:34 <Cale> right, you don't
23:18:01 <Cale> However, you do replacement
23:18:07 <vincenz> I mean...I'm in some block at a certain statement...inlinign a function there would require me to pop back out to the surorunding block..
23:18:12 <Cale> which is just as hard as renaming :)
23:18:25 <vincenz> Cale: so rename by default when inlining
23:18:32 <Cale> right
23:18:47 <vincenz> ok
23:18:52 <vincenz> either way, not quite there ye
23:18:55 <vincenz> I have to decorate my AST
23:18:57 <Cale> You might need to add a unique supply to the monad
23:19:00 <vincenz> so I can put in environments and types
23:19:35 <vincenz> oh yeah, on a sidenote, any suggestions on how to write out expressions without having superfluous parentheses
23:20:41 <Cale> hmm
23:21:01 <Cale> I suppose you'd just do it recursively with some rewrite rules
23:21:13 <vincenz> I know that showsPrec uses precedence
23:21:15 <dons> yup.
23:21:18 * vincenz makes a typeclass Pretty
23:21:26 <vincenz> with an extra parameter "ind"
23:21:58 <Cale> I mean, at the algebraic data type level
23:22:11 <Cale> Represent (x + y + z) as Plus [x, y, z]
23:22:15 * vincenz is not familiar with the terminology "algebraic data type"
23:22:33 <Cale> That's the usual sort of data type which Haskell gives you
23:22:37 <Cale> data
23:22:39 <vincenz> o.O
23:22:44 <vincenz> Cale: I meant going from AST -> c
23:22:51 <Cale> right
23:23:02 <Cale> you stick a simplifier in
23:23:08 <Cale> AST -> AST
23:23:14 <vincenz> hmm
23:23:16 <Cale> before translating to c
23:23:23 * vincenz ponders
23:23:27 <vincenz> maybe
23:23:31 <vincenz> so AST1 -> AST2
23:23:43 <Cale> yeah, if they're really going to be different types
23:23:43 <vincenz> two ast's...
23:23:53 <Cale> probably the same type
23:24:04 <vincenz> well BinaryOp OAdd x (BinaryOp OAdd y z) is diff fromo Plus [x,y,z]
23:24:06 <Cale> hmm.
23:24:14 <Cale> right
23:24:16 <vincenz> I'll add a pretty class for now
23:24:23 <vincenz> that should work, so I can pretty anything I want :)
23:24:34 <Cale> maybe you can just do it all while converting to strings
23:24:40 <vincenz> prettyPrint x prec ind
23:25:06 <Cale> with a little 'lookahead' it shouldn't be too bad
23:25:17 <vincenz> (tho of course with a monad, I could store the ind in the monad)
23:26:03 <vincenz> Cale: I'll use the same system as showsPrec except with an extra ind parameter... I think that hsould work, I know the extra param to showsprec is for this reason
23:26:48 <Cale> that should work
23:27:17 <Cale> So what is the interesting part of this like?
23:27:24 <vincenz> o.O
23:27:25 <vincenz> ?
23:27:27 <Cale> (the actual transformations which you're doing)
23:27:30 <vincenz> oh
23:27:34 <vincenz> intermediate variable removals
23:27:39 <vincenz> but first I gotta do scoping and typing
23:27:42 <vincenz> :/
23:28:17 <vincenz> something similar to deforestation for imperative code
23:28:27 <Cale> hmm yeah
23:28:29 <vincenz> (in fact I plan to map ddt code to functional code)
23:28:35 <vincenz> and then use deforestation rules
23:28:38 <Cale> :)
23:29:18 <vincenz> shows is not part of Show?
23:29:21 * vincenz wonders why
23:29:27 <Cale> @type shows
23:29:28 <lambdabot> forall a. (Show a) => a -> ShowS
23:29:39 <vincenz> Cale: open ghci
23:29:42 <vincenz> and type :i Show
23:29:46 <vincenz> ain't in there
23:30:31 <Cale> shows = showsPrec 0
23:30:37 <Cale> and showsPrec is in Show
23:30:44 <vincenz> right
23:30:53 <vincenz> but show x = showsPrec 0 x ""
23:30:58 <vincenz> and that one -is- in Show
23:31:13 <vincenz> rather ununiform
23:31:25 <Cale> yeah
23:31:51 <Cale> I think show wouldn't be in there except that people would complain. (I would complain :)
23:32:13 <Cale> Putting shows in there seems fair enough, I suppose
23:32:23 <vincenz> > showString "bool"
23:32:23 <lambdabot>  add an instance declaration for (Show (String -> String))
23:32:25 <vincenz> > showString "bool" ""
23:32:26 <lambdabot> "bool"
23:32:35 <vincenz> > show "bool"
23:32:37 <lambdabot> "\"bool\""
23:32:38 <vincenz> aha
23:32:58 <vincenz> gotta love typeclasses
23:33:02 <vincenz> isntead of having all these different functions
23:33:06 <vincenz> showExp, showStm.
23:33:07 <vincenz> etc
23:33:07 <vincenz> et
23:33:14 <Cale> for real :)
23:34:48 <vincenz> hmmhmm
23:34:51 <vincenz> how to do indentation
23:40:29 <vincenz> Cale: heh... expressions are more than just precedence level, but also leftassoc vs rightassoc o.O
23:40:34 * vincenz mutters
23:41:53 <gFunk> Cale: you still around?
23:42:37 <Cale> yep
23:42:55 <Cale> vincenz: pretty printing is basically as hard as parsing :)
23:43:12 <vincenz> Cale: hehe
23:43:18 * vincenz keeps the silly parentheses
23:43:38 <vincenz> Cale: I wouldn't fully agree..consider languages such as c++
23:44:13 <gFunk> Cale: the data for that simulator is basically a few thousand files that look like this: http://pastebin.com/546302
23:45:20 <vincenz> gFunk: what kind of data is this?
23:45:46 <vincenz> @hoogle paren
23:45:47 <lambdabot> Text.PrettyPrint.HughesPJ.parens :: Doc -> Doc
23:45:47 <lambdabot> Graphics.UI.GLUT.Window.parentWindow :: GettableStateVar (Maybe Window)
23:45:47 <lambdabot> Text.ParserCombinators.Parsec.Token.parens :: TokenParser st -> CharParser
23:45:47 <lambdabot> st a -> CharParser st a
23:45:48 <gFunk> forex
23:45:53 <vincenz> forex?
23:46:03 <gFunk> foreign exchange
23:46:12 <gFunk> date, bid, ask
23:46:16 <vincenz> ah :)
23:47:10 <gFunk> some days i think i could make money :)
23:47:42 <gFunk> i originally coded a simulator in Ruby, then Nemerle, and now Haskell
23:47:53 <vincenz> gFunk: looked at the paper written by peyton concerning contracts?
23:47:59 <vincenz> @google nemerle
23:48:01 <lambdabot> http://nemerle.org/
23:48:17 <gFunk> vincenz: no i haven't
23:48:35 <vincenz> nemerle = microsoft haskell ripoff?
23:48:41 <vincenz> (like F# = ocaml ripoff)
23:48:58 <Korollary> I dont think so
23:49:06 <gFunk> pretty similar to F#
23:49:29 <gFunk> more like C# with OCaml features
23:49:37 <vincenz> blegh
23:50:16 <Cale> Doesn't look like an MS project
23:50:23 <vincenz> @hoogle interleave
23:50:24 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.InterleavedArrays :: InterleavedA
23:50:24 <lambdabot> rrays
23:50:24 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.interleavedArrays :: InterleavedA
23:50:24 <lambdabot> rrays -> Stride -> Ptr a -> IO ()
23:50:24 <lambdabot> Control.Monad.ST.Lazy.unsafeInterleaveST :: ST s a -> ST s a
23:50:24 <gFunk> no, it's not
23:50:49 <Cale> It's for .net, but you can run .net code on linux too :)
23:51:30 <gFunk> right.  .net/mono aren't bad at all
23:52:18 <wolverian> what's up with the linebreaks from lambdabot?
23:52:52 <dons> faq. please submit a patch ;)
23:52:57 <gFunk> Cale: any idea why my program still isn't being strict with the IO
23:53:01 <vincenz> @pl \x y -> x . i .y
23:53:02 <lambdabot> (. (i .)) . (.)
23:53:03 <Cale> wolverian: it breaks lines at a specified character
23:53:04 <vincenz> yick
23:53:16 <dons> @version <-- code lives here
23:53:17 <lambdabot> lambdabot 3p283, GHC 6.5.20050806 (Linux i686)
23:53:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
23:53:21 <Cale> a patch?
23:53:24 <wolverian> ah. okay :) 
23:53:31 <Cale> wouldn't that just be a simple edit of Config.hs?
23:53:44 <Cale> change the 80 to 200 or so?
23:53:55 <dons> oh, if you just want to lengthen the wrap len, sure.
23:54:25 <dons> maybe we should try that for a couple of days?/and just leave it up to the clients to do the wrapping?
23:54:29 <Cale> well, most IRC clients are smart enough about text wrapping anyway
23:54:33 <Cale> yeah
23:54:49 <dons> who votes to try non-wrapping lambdabot?
23:54:51 <Cale> besides, you can't rely on 80 columns
23:54:54 <Cale> me
23:55:07 <gFunk> Cale: http://pastebin.com/546258 you think that maybe the tuple that contains the strict Quote needs to be a strict type also?
23:55:10 <Cale> though it should wrap eventually, since messages are cut down to a certain length
23:55:19 <dons> ok. lets try it out and see if anyone complains.
23:55:26 <wolverian> something like 450 should be a safe length 
23:55:30 <Cale> what is that length, I wonder....
23:55:36 <integral> I thought it was about 256
23:55:48 <wolverian> 512 is the maximum length, minus server the message metadata
23:55:55 <wolverian> s/server //
23:56:28 <dons> most only just go over our wraplen, so even 100 would catch 90%, I'd reckon.
23:56:30 <Cale> aha, okay
23:56:52 <Cale> my message to myself was cut at 413
23:57:02 <Cale> (xchat is pretty smart)
23:57:52 <Cale> you could probably just write whatever function sends messages such that it automatically breaks things at the max length
23:58:07 <Cale> (and sends multiple messages)
23:58:26 <wolverian> cutting at the last whitespace before max length :)
23:58:47 <dons> @quit lets try wrapping at 256
23:59:14 <dons> @hoogle interleave
23:59:21 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.InterleavedArrays :: InterleavedArrays
23:59:23 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.interleavedArrays :: InterleavedArrays -> Stride -> Ptr a 
23:59:25 <lambdabot> Control.Monad.ST.Lazy.unsafeInterleaveST :: ST s a -> ST s a
23:59:35 <dons> yeah, looks better on my side
23:59:38 <Cale> looks good to me :)
23:59:42 <ski> > [0..]
23:59:43 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,3
23:59:43 <lambdabot> 88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,
23:59:43 <lambdabot> 154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,
23:59:43 <lambdabot> 217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,
23:59:43 <lambdabot> 280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,
23:59:45 <lambdabot> [4 @more lines]
23:59:53 <dons> hmm, not so good.
