00:48:44 <ski> good morning, essiene
01:07:15 <ncalexan> @type newUnique
01:07:16 <lambdabot> Not in scope: `newUnique'
01:07:19 <ncalexan> @hoogle newUnique
01:07:20 <lambdabot> Data.Unique.newUnique :: IO Unique
01:11:02 <Speck> >.>
01:11:05 <Speck> <.<
01:11:33 <ski> >.<
01:11:54 <Speck> are you familiar with oleg's inverted enumerations?
01:14:03 * ski is not
01:14:51 <jyp> @quote
01:14:51 <lambdabot> babel module failed: getRandItem: empty list
01:15:09 <jyp> @yow
01:15:09 <lambdabot> quote module failed: getRandItem: empty list
01:15:15 <Speck> ski: http://okmij.org/ftp/Haskell/misc.html#fold-stream
01:15:25 <Cale> dons! fix it! :) hehe
01:15:37 <jyp> hey Cale 
01:15:40 <Cale> hi
01:16:03 * Speck is having trouble understanding the implementation for Haskell and doesn't grok Scheme (shameful!)
01:20:15 <dons> it's a weird bug. don't know what causes it
01:20:32 <dons> @quit bad bot
01:20:55 <dons> Saulzar, did you turn on the regex highlighting on the wiki page for regex-dna?
01:24:10 <Saulzar> Nope, was somone else. 
02:06:53 <benny> hm... i just had the linux equivilent of a bsod
02:06:53 <Cale> benny: bad driver?
02:06:53 <benny> could be anything, all of the sudden the screen just showed garbage
02:06:53 <benny> anyone here know if the opengl stuff that comes with ghc 6.4.1 is supposed to support texturing?
02:16:39 <alea_tor> How do you handle constants that require IO to make? For example a gtk pixbuf that is used everywhere? 
02:20:33 <benny> unsafePerformIO, or thread it around everywhere, or put it in some global IORef
02:22:21 <ski> (second option could e.g. be a Reader (or more advanced) monad)
02:23:37 <JKnecht> perspectival: Are you a Marxist, Sir?
02:23:49 <alea_tor> Hmm. Pretty much tried all those already.. Didn't feel easy and correct..
02:24:21 <Saulzar> What situation do you require it for?
02:26:43 <alea_tor> Well. I'm pondering about making a nethack clone.. And my first shot was to make a gui and separate game. Interfaced together by a module containing gui actions (such as drawing a sprite).
02:27:18 <alea_tor> And not wanting to load images everytime they are drawn..
02:27:56 <Saulzar> Hmm, I've been doing something similar... 
02:28:33 <alea_tor> Whats your solution? I've thought up a dozen ways of doing this, but they all have lot of unnecessary baggage.
02:28:40 <Saulzar> That is, seperate game/rendering, and not loading images repeatedly.
02:29:58 <Saulzar> I've been using a data structure containing all the stuff relating to rendering, "RenderState" then I have a monad using StateT 
02:30:04 <Saulzar> type Render a = StateT RenderState IO a
02:31:02 <Saulzar> Inside RenderState I've been using a Map to cache loaded images by name
02:32:06 <Saulzar> Then in main I have an IORef which holds the state between times
02:32:40 <Saulzar> I'm not sure if it's the best way, but it seems okay.
02:33:17 <alea_tor> I thought about something similar. How do you load images into renderstate?
02:33:34 <Si\> Can anyone think of a way, other than writing to a temporary file, how you could store global data between TH splices in the same module?
02:34:42 <Saulzar> I pass in a list of Drawing which is a big union of stuff I support drawing, one is Image which just has a String for filename, and the code for drawing will load the image itself if it isn't in the map already
02:37:44 <alea_tor> Saulzar: right. That seems ok. I was just thinking if there was a way that I would not need to put things in a container.. But I guess not.
02:37:52 <ski> (Si\ : hm, can you import a module at compile-time (for use in splices) ?)
02:38:04 <Saulzar> Hmm.
02:38:25 <ski> (Si\ : if so, you could hack a global IORef into that module)
02:45:32 <benny> Si\: you can use unsafePerformIO to make a "singleton" getGlobalPixBuf :: IO PixBuf function that will create the pixbuf only the first time that it is called
02:46:10 <benny> i think that this is an acceptable use for unsafePerformIO
02:56:50 <alea_tor> Hmm.. This is not starting well. How do I get a pixbuf into cairo surface?
02:59:41 <dcoutts> alea_tor, setSourcePixbuf
02:59:45 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Cairo.html#v%3AsetSourcePixbuf
03:00:49 <benny> argh, is anyone here familiar with haskell opengl?
03:01:55 <dcoutts> alea_tor, so a pixbuf can be used as the source for drawing onto a surface but a pixbuf cannot be used directly *as* a surface. (Though the gtk+ people might add that feature in a later release)
03:02:38 <alea_tor> dcoutts: Thank you. I could have sworn that I read through the docs.
03:03:10 <dcoutts> alea_tor, that bit is from the Gtk+ extension part of the cairo api
03:03:20 <gour> dcoutts: once you wrote that (sometimes) you use gedit. have you tried scribes?
03:03:45 <alea_tor> Ah. I seem to have been looking at bit aged docs. Or something.
03:04:32 <dcoutts> alea_tor, basically it comes in two bits, the core Graphics.Rendering.Cairo  and the bits for using cairo with gtk Graphics.UI.Gtk.Cairo
03:05:14 <dcoutts> gour, I use nedit, not gedit :-)
03:05:27 <benny> why oh why isn't texturing working??? :'(
03:07:16 <Saulzar> benny, HOpenGL seems to me that it might, kept on resetting the texture filtering
03:07:32 <benny> Saulzar: i'm using the opengl stuff that came with ghc 6.4.1
03:07:46 <Saulzar> That's HOpenGL :)
03:08:01 <gour> dcoutts: well, it's close :-)
03:08:19 <benny> resetting the texture filtering... my problem though is that i don't see any texture at all
03:08:21 <jyp> Is Bulat around?
03:08:22 <alea_tor> dcoutts: Any chance of getting hoogle to know about about gtk2hs? 
03:08:54 <Saulzar> benny, Well in my case it was because it reset the texture mapping to use mipmaps, where I had none...
03:09:13 <benny> Saulzar: that might be it
03:09:28 <benny> Saulzar: but how would that happen?
03:09:33 <dcoutts> @localtime dons
03:09:34 <Saulzar> Not sure. 
03:09:35 <lambdabot> Local time for dons is Sat Feb  4 22:08:57 2006
03:09:48 <dcoutts> dons, you about?
03:10:08 <dcoutts> alea_tor, I don't control hoogle
03:11:45 <alea_tor> dcoutts: Ok. Thought that everytime I do try something with gtk2hs I end up here, asking you questions :/
03:13:14 <dcoutts> alea_tor, it's not a bad idea
03:13:25 <dcoutts> getting it indexed by hoogle I mean
03:13:37 <dcoutts> @where hoogle
03:13:37 <lambdabot> http://www.haskell.org/hoogle
03:13:45 <Saulzar> benny, It would surely be a bug if you can confirm that it does the same thing
03:13:53 <dcoutts> @seen ndm
03:13:54 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 16 hours,
03:13:54 <lambdabot> 14 minutes and 10 seconds ago, and I have missed 5 seconds since then.
03:14:35 <Saulzar> Yeah, alternative libs in hoogle would be fantastic :)
03:15:26 <benny> Saulzar: w00t it works! it was indeed a mipmap thing... i don't think that this is a bug in hopengl though... i'm pretty sure that this is how opengl is supposed to work
03:15:51 <benny> Saulzar: the only thing that puzzles me is,  type MinificationFilter = (TextureFilter, Maybe TextureFilter)
03:16:02 <benny> what is that snd for?
03:17:12 <orbitz> time flies like an arrow, fruit flies like a banana
03:17:54 <Saulzar> Hmm, corresponds to LINEAR_MIPMAP_NEAREST vs. LINEAR (Nothing)
03:18:39 <benny> hm....
03:19:00 <Saulzar> benny, But if one sets the texture filtering at the start of an GL or HOpenGL app, it should stay set, right?
03:19:11 <Saulzar> It seems to me that it gets reset at each frame..
03:24:04 <benny> argh, another crash :(
03:25:40 <benny> but at least it works :D
03:32:19 <mq_mattr> @localtime mq_mattr
03:34:25 <ski> @yow
03:34:26 <lambdabot> The PINK SOCKS were ORIGINALLY from 1952!!  But they went to MARS
03:34:26 <lambdabot> around 1953!!
04:13:21 <benny> is there something like python's time.time() function?
04:14:25 <resiak> No
04:14:30 <resiak> Perl doesn't know about time.
04:15:03 <benny> i mean in haskell
04:15:16 <resiak> ARGH, sorry, wrong channel
04:15:22 * resiak blushes and hides.
04:17:09 <shapr> jiihaa
04:18:26 <ski> merhaba
04:19:45 <tromp> see System.Time
04:20:49 <benny> hm... cool thanks
04:20:56 <benny> anyone wanna try a cool driving demo?
04:23:02 <benny> http://img145.imageshack.us/img145/7513/drivedrive0020dn.png
04:23:55 <tromp> strange landscape
04:31:50 <benny> http://www.bigupload.com/d=0D0D068C
04:32:00 <mq_mattr> anyone who can give me a few hs-plugins pointers
04:32:27 <mq_mattr> I keep getting segmentation faults - first time I ever got one of those from a Haskell program!
04:33:00 <Saulzar> benny, Sure :)
04:33:05 <musasabi> mq_mattr: do you have unsafePerformIO ?
04:34:44 <benny> Saulzar: this link should work: http://www.justupit.com/1391f84c072764e0ae4e1e0f10a75d6d
04:34:44 <mq_mattr> well, I stopped the seg faults - here is the expression I am giving ghc
04:35:03 <mq_mattr> do{a<-Plugins.dynload "Defn.lhs" [] [] ""; case a of; Plugins.LoadFailure msg -> putStrLn "dead"; Plugins.LoadSuccess _ v -> putStrLn v;}
04:36:31 <mq_mattr> and it is failing to find the module that Defn imports (TestHelper) giving this error
04:36:45 <mq_mattr> unknown symbol `___stginit_TestHelper_'
04:38:00 <musasabi> mq_mattr: dynload takes an object file, not a source file.
04:38:01 <xerox> Maybe you need to unroll the dependencies manyally?
04:38:06 <xerox> manually, even.
04:38:10 <xerox> I don't really know, tho.
04:38:16 <mq_mattr> sorry, I have already changed taht
04:38:27 <mq_mattr> that is what fixed the seg fault
04:38:46 <mq_mattr> How do I tell dynload what the dependencies are?
04:39:12 <xerox> I think hs-plugins an extensive documentation... I have no better ideas.
04:39:30 <Saulzar> benny, Hey this is cool. I managed to turn it upside down. :) 
04:39:47 <mq_mattr> I have been reading the documentation, but I don't think I have the knowledge to fully get it
04:39:49 <Saulzar> How are you doing the movement/physics? 
04:39:52 <musasabi> mq_mattr: the documentation tells " Load the object file specified by the first argument into the address space (the library will preload any module or package dependencies)."
04:40:19 <xerox> benny: nice one :-)
04:40:39 <mq_mattr> turn what upside down?
04:40:40 <xerox> Maybe add a wireframe skeleton?
04:40:42 <benny> Saulzar, xerox: careful not to drive over the edge :)
04:40:49 <Saulzar> Array index out of bounds :)
04:40:57 <mq_mattr> ahhh, the game
04:41:27 <mq_mattr> musasabi: yeah, but it doesn't seem to have done that for me
04:41:41 <mq_mattr> I have a .o file for TestHelper
04:42:01 <xerox> benny: how does one compile it?
04:42:23 <Saulzar> Crazy, manged to get it to do a "head stand" 
04:42:36 <benny> xerox: i use only ghc 6.4.1 and Lemmih's SDL bindings
04:42:46 <xerox> Ah, it's compiled.
04:43:36 <benny> it's all pure yampa also :)
04:44:11 <xerox> Does it forward on automatically?
04:44:22 <xerox> (Constant velocity)
04:45:26 <benny> what do you mean?
04:46:07 <mq_mattr> I have tried a module with no dependencies, I am getting different errors but still can't make it work
04:46:13 <mq_mattr> back to crashing ghci now
04:46:26 <mq_mattr> "Illegal instruction" this time
04:46:37 <xerox> benny: what are the available function keys?
04:47:01 <benny> xerox: keyboard controls? just the arrow keys (and escape to quit)
04:47:11 <xerox> benny: okay, maybe my pc is just too slow
04:47:26 <xerox> Feels like it's going forward automatically
04:48:27 <benny> there is zero friction in the forward/backwards direction
04:55:54 <benny> here's something i did in c# that would be cool in haskell:
04:55:56 <benny> http://die.sourceforge.net/stuff/die3-preview12.jpg
04:56:04 <mq_mattr> what is teh Symbol in the type sig of dynload?
04:56:05 <benny> http://die.sourceforge.net/stuff/die3-preview16.jpg
04:56:24 <mq_mattr> dynload :: Typeable a => FilePath -> [FilePath] -> [PackageConf] -> Symbol -> IO (LoadStatus a)
04:56:25 <benny> http://die.sourceforge.net/stuff/die3-preview20.jpg
04:56:51 <Saulzar> benny, Wow, I did something quite similar... :)
04:57:46 <Saulzar> Terrain editor, right?
04:58:25 <benny> more like a "game engine editor" :) with builtin terrain editing and embedded gameplay
04:59:18 <Saulzar> I wonder if I have a screenshot around still... 
05:03:32 <Saulzar> Hm, that was what I intended too. Though it never got further than a terrain editor
05:03:55 <Saulzar> For a racing game as well :)
05:05:12 <benny> mine pretty much died at around that point too :)
05:05:33 <benny> it was actually the 3rd and final rewrite of the game engine
05:05:44 <benny> previous 2 versions were done in c++/python
05:05:50 <Saulzar> http://saulzar.orcon.net.nz/editor.jpg
05:06:30 <benny> whoah cool... that looks scarily similar
05:06:34 <Saulzar> Yes :)
05:07:15 <Saulzar> It is a muchly broken mess of nasty C++
05:07:33 <benny> i also used gl points for elevation editing:
05:07:34 <benny> http://die.sourceforge.net/stuff/die3-preview10.jpg
05:07:49 <Saulzar> Was going to rewrite it, but it was going to be a mammoth task - too ambitious
05:08:08 <Saulzar> Haha.
05:08:49 <benny> my code was actually pretty clean, and even had almost full undo support
05:10:16 <benny> but large parts of the design were broken :(
05:10:20 <Saulzar> Cool. My code was becoming extremely nasty as it went on. I think i'd want to use something like Ogre if ever that kind of thing was attempted again
05:11:09 <benny> Saulzar: the previous 2 versions of my engine actually used ogre but i dropped it with the 3rd rewrite
05:12:16 <benny> http://die.sourceforge.net/stuff/die-0405104_171130415.jpg
05:12:37 <benny> http://die.sourceforge.net/stuff/die-0404104_200444477.jpg
05:13:33 <Saulzar> Ahh, nice. 
05:14:52 <benny> well, i gotta go for now... i have dozens more screenshot from all stages of development (and also a sweet 15mb divx .avi gameplay video) here:
05:14:59 <benny> http://die.sourceforge.net/stuff/
05:57:57 <ndm> anyone know who vincenz is?
06:02:58 <ski> he's been in #ocaml some, also
06:04:28 <alea_tor> ndm: Are you the one behind hoogle?
06:07:36 <jethr0> ndm: why do you ask?
06:10:57 <ndm> alea_tor: yes
06:11:12 <ndm> jethr0: he left a hoogle bug report on the wiki, i wanted to respond:)
06:12:12 <jethr0> ah, i'm working with him on a project. he should be around soon
06:19:01 <ndm> cool, i'll be around later as well
06:28:27 <jethr0> @seen dons
06:28:27 <dcoutts> ndm, so how do we add gtk2hs's current docs to hoogle?
06:28:27 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 5 hours, 7 minutes and
06:28:27 <lambdabot> 32 seconds ago.
06:29:01 <dcoutts> ndm, or did alea_tor allready ask that
06:29:45 <jethr0> anyone know his way around hs-plugins, or eval'ing in haskell?
06:29:47 <ndm> dcoutts, no one has asked yet - are you after it being on the main hoogle page?
06:30:09 <dcoutts> ndm, not sure. what are the options?
06:30:45 <ndm> dcoutts, you can run a customised hoogle search engine with a modified database, or i can hack in extra module support on teh main hoogle page, like an advanced option thing
06:31:00 <ndm> if you'd like it on the main hoogle page, i'll try and get that done this weekend maybe
06:31:38 <dcoutts> ndm, what alea_tor was asking for in particular was for it to be included in the lambdabot plugin :-)
06:31:50 <ndm> ah, thats a bit easier :)
06:32:11 <ndm> darcs get hoogle
06:32:31 <ski> @hoogle-with-packages [foo,bar] a -> b
06:32:31 <lambdabot> Unknown command, try @listcommands.
06:32:32 <ski> ?
06:32:54 <ndm> run data/hadhtml on the haddock sources
06:33:06 <ndm> cat hoogle.txt newfile.txt
06:33:15 <ndm> replace hoogle.txt on the lamdabot server
06:33:21 <ndm> then all searches will including gtk2hs
06:33:49 <ndm> if you would rather hoogle-with-packages then you only need to modify lamababot to pass the right database as a command line arg to hoogle
06:33:58 <dcoutts> ok
06:35:54 <ndm> it should be a 20 minute job, but if you need help just ask
06:39:22 <dcoutts> ndm, my "hmake hoogle" complains. what dir am I supposed to run that in? does it need any command line flags?
06:39:54 <ndm> dcoutts, don't do hmake, just ghc --make
06:40:04 <ndm> cd src
06:40:17 <ndm> then ghc --make Web or ghc --make CmdLine
06:41:06 <dcoutts> ndm, so where is "data/hadhtml" ?
06:41:33 <ndm> from the root directory
06:41:35 <ndm> go to data
06:41:38 <ndm> then hadhtml
06:41:49 <ndm> ghc --make Main
06:41:57 <ndm> thats not hoogle, its a data collector
06:42:24 <dcoutts> ndm, I don't see any data dir, I've got hi2hoo & src
06:42:37 <dcoutts> ndm, I'm using this repo http://www.cs.york.ac.uk/fp/darcs/hoogle
06:42:45 <dcoutts> which is what the http://www.haskell.org/hoogle/developers.htm says
06:43:04 <ndm> i'm just checking its commited
06:43:09 <ndm> that is the right repo
06:43:50 <ndm> ./data/hadhtml/Main.hs
06:44:13 <ndm> that sounds a lot like the CVS copy, hi2hoo is no longer in data
06:44:22 <dcoutts> hmm I see it on the website, I wonder why darcs didn't download it
06:44:43 <dcoutts> doh!
06:45:05 <dcoutts> I'd already done darcs get some time ago and so darcs make hoogle_0/ but didn't tell me that!
06:45:23 <ndm> ah ha!
06:45:26 <dcoutts> so I was looking at an old repo
06:46:53 <dcoutts> ndm, so I run hadhtml on the gtk2hs.haddock file or on the haddock-generated html files?
06:47:09 <ndm> haddock generated html
06:47:19 <ndm> i think you just specify the directory, and it recursively finds all .html in it
06:48:43 <dcoutts> ndm, ok done
06:49:31 <ndm> it should have generated hoogle.txt
06:49:42 <ndm> thats the gtk2hs hoogle database
06:49:48 <dcoutts> yep
06:49:49 <beelsebob_> ohh, shiny pants
06:50:25 <dcoutts> ndm, so I send that to dons to append to the one on the lambdabot server?
06:50:51 <ndm> dcoutts, yep - or you can name it gtk2hs and patch lambdabot to have a @hoogle-gtk2hs command
06:51:08 <ndm> but just appending will work fine, and put it in the normal hoogle searches
06:51:32 <dcoutts> ndm, you dont think it'll pollute the hoogle searches?
06:51:39 <dcoutts> for normal search I mean
06:51:48 <ndm> it will if you take the append route
06:51:56 <ndm> but i'm not sure how much, or if its a problem
06:52:12 <ndm> given most Gtk2Hs functions will have a Gtk2Hs specific type in, so it won't pollute type searches much
06:52:30 <dcoutts> ndm, ok
06:52:38 <ndm> for the hoogle website, i want people to be able to choose what packages they search
06:55:59 <musasabi> Does "m_ :: Monad m => m a -> m ()" have a standard name?
06:56:09 <musasabi> m_ x = x >> return ()
06:56:58 * ski would call it 'ignore'
06:57:02 <jyp> @where hs-plugins
06:57:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
06:57:09 <xerox> @hoogle m a -> m ()
06:57:10 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
06:57:10 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
06:57:10 <lambdabot> Prelude.id :: a -> a
07:00:37 <jethr0> is there a standard operator for shortcut?: sc f = \c -> f c >> return c
07:01:26 <jethr0> i've tried writing an operator for this, but i failed, because i'm still new to monads.
07:02:16 <jethr0> how would i write the above as operater: "(>>~) x f = \c -> x c >> f c"
07:05:41 <xerox> @pl \x f -> \c -> x c >> f c
07:05:42 <lambdabot> liftM2 (>>)
07:05:46 <xerox> that way, it seems :-)
07:06:06 * jethr0 laughs so hard he has to grab a hold of sth
07:06:17 <xerox> Whoopee.
07:06:46 <Lemmih> dcoutts: ping.
07:06:48 <jethr0> what monad is it lifted to?
07:06:52 <dcoutts> Lemmih, pong
07:07:01 <dcoutts> Lemmih, not seen you about for days!
07:07:14 <Lemmih> dcoutts: I just came back from Tunisia.
07:07:18 <dcoutts> cool!
07:07:21 <dcoutts> was it fun?
07:07:40 <Lemmih> Yeah, I had a great time.
07:10:51 <dcoutts> Lemmih, are you still hacking on hackage? SyntaxNinja wanted to look at reducing the number of external deps of cabal-get so that it could be distributed with Cabal itself (and thus ghc).
07:10:59 <Lemmih> dcoutts: HIDE doesn't display unicode characters correctly. Is there some trick to make it work?
07:11:16 <dcoutts> Lemmih, ok, so where exactly? in the Yi window?
07:11:17 <xerox> ãƒ‚
07:11:19 <xerox> ops
07:11:28 <xerox> Can you write an utf-8 'forall' ?
07:11:54 <dcoutts> Lemmih, gtk will display unicode fine, so perhaps we're doing a utf8 encoding or decoding layer wrong
07:12:19 <dcoutts> Lemmih, does yi handle utf8 / unicode strings ok?
07:12:27 <beelsebob_> âˆ€âˆƒ
07:12:51 <xerox> Hmpf I do not see it.
07:13:08 <beelsebob_> you're probably using ISO-????-??? in your IRC client
07:13:11 <beelsebob_> not UTF-8
07:13:13 <dcoutts> Lemmih, gtk2hs converts the Haskell String type to utf-8 encoded C strings when marshaling things to gtk.
07:13:47 <Lemmih> dcoutts: I'm just using SourceView for now.
07:13:48 <xerox> beelsebob_: would you mind pass it by other mediums, like, email/file/whatever?
07:13:58 <dcoutts> Lemmih, so how are you laoding text into it?
07:14:01 <beelsebob_> sure, email?
07:14:22 <Lemmih> dcoutts: Copy/paste.
07:14:29 <xerox> beelsebob_: paolo at nemail dot it
07:14:40 <dcoutts> Lemmih, oh, that's odd, does it work in gedit?
07:14:52 <dcoutts> gedit uses sourceview when doign syntax highliting
07:15:16 <Lemmih> I'll check. One moment.
07:15:22 <Lemmih> xerox: http://www.mail-archive.com/cvs-all@haskell.org/msg22771.html
07:15:28 <beelsebob_> xerox: gone
07:16:06 <xerox> Thanks Lemmih, beelsebob_.
07:16:48 <dcoutts> Lemmih, using the demo/sourceview prog, I copy'n'pasted the "âˆ€âˆƒ" in fine
07:24:34 <Lemmih> dcoutts: It works with copy&paste but fails if I load the file from the file browser.
07:26:06 <Lemmih> dcoutts: 'readFile' messes up UTF-8?
07:32:06 <dcoutts> Lemmih, yeah, it will do
07:32:13 <dcoutts> Lemmih, readFile reads ASCII
07:33:43 <ski> jethr0 : or 'x >>~ f = \c -> x c >> f c'
07:33:46 <dcoutts> so you need to convert the resulting string from utf-8 to an ordinary Haskell unicode string
07:34:14 <jethr0> ski: i had tried that. but got errors that this function didn't have correct type
07:34:34 <ski> hrm ..
07:34:35 <jethr0> ah, i'll just experiment a bit further with ti
07:34:36 <dcoutts> Lemmih, or we could provide a function to set a text buffer from a utf-8 encoded string rather than an ordinary Haskell unicode string
07:34:47 <ski> (x >>~ f) c = ...
07:34:57 <snk_origamist> hey when somebody says monad comprehensions, is that something to do with list comprehensions and using monads & do-notation?
07:34:58 <ski> is also a possible way, with operators
07:35:04 <snk_origamist> in haskell anyways
07:35:14 <jethr0> *brr*, mixing fixity
07:35:28 <ski> no, it's generalizing list comprehensions to arbitrary monads, instead of using do-notation
07:35:57 <snk_origamist> and haskell has monad comprehensions?
07:37:08 <ski> snk_origamist : iirc, it had
07:37:27 <ski> do-notation was then invented, and monad comprehensions dropped
07:37:33 <snk_origamist> ah i see
07:37:39 <dcoutts> Lemmih, really we should have a method to set the buffer from a FastPackedString containing utf-8
07:37:45 <ski> (though, at times, i think monad comprehensions would be a nice alternative syntax)
07:38:13 <ski> snk_origamist : i think the rationale was that the type errors could scare newbies who only wanted to use a list comprehension
07:38:28 <ben|away> can hs-plugins or ghc 6.5 api compile directly and dynamicly load a Language.Haskell.Syntax.HsModule value?
07:38:53 <snk_origamist> ski: cheers for that ;)
07:39:24 <SamB> ski: perhaps also that [] seem to imply a list is being dealt with
07:40:06 <ski> yes
07:40:13 <SamB> benny: I'm sure you can do it, but I'm not so sure about directly
07:41:01 <benny> SamB: you mean i have to 'show' it to a temporary file first?
07:41:35 <SamB> @type mplus
07:41:36 <lambdabot> Not in scope: `mplus'
07:41:43 <SamB> benny: not sure
07:41:48 <snk_origamist> ski: so it would like some set builder notation to do sequencing, sounds like an elegant method over do-notation
07:42:04 <Lemmih> benny: No, but you can pretty print the module and then load it.
07:42:28 <SamB> benny: I think with ghc 6.5 you should be able to compile it into bytecode
07:43:07 <SamB> hmm, only I don't think GHC supports that representation
07:43:09 <Lemmih> Sorry, didn't see you figured it out by yourself.
07:44:20 <benny> Lemmih: only problem with that is that if there are errors then i have to somehow map the row/column location back to the appropriate node in the syntax tree
07:46:08 <Lemmih> benny: You could map it to a HsSyn.HsModule but it would probably be really hard.
07:47:00 <SamB> benny: why do you need to do that?
07:47:25 <SamB> GHC produces pretty decent error messages
07:51:21 <dcoutts> benny, perhaps you can do something cunning with {-# LINE #-} pragmas to get ghc to report errors with the line locations you want
07:51:53 <benny> dcoutts: perhaps... i need to first learn a lot more about all this stuff, i'm still a beginner
08:08:17 <benny> where can i find more information on System.Mem.performGC?
08:12:11 <waern> benny, are you making a hIDE plugin?
08:13:25 <waern> hm.. probably not :)
08:13:43 <benny> no but hIDE looks cool
08:22:48 <benny> haskell needs a variation of performGC: the idea being that you can call a special IO action at regular intervals and the runtime is only allowed to gc during these calls.
08:23:20 <benny> for example in a network app you could do this in your listen loop right before your select(), since the cpu will be idle here sometimes anyway as it waits for network traffic
08:23:54 * shapr boings
08:24:10 <benny> maybe i should submit this idea to the haskell' committee :P
08:24:11 <musasabi> benny: or simply do collection when there are no active haskell threads.
08:24:27 <musasabi> hello shapr :-)
08:24:47 <benny> musasabi: but how can the runtime know when that is?
08:28:19 <musasabi> benny: the runtime does know that, at least in ghc.
08:28:39 <musasabi> other implementations don't have pre-emptive threads to begin with
08:29:07 <Lemmih> dcoutts: I've patched it to use 'slurpFile' instead.
08:30:07 <benny> musasabi: but if i call a select() function then the thread is still running, only the cpu is idle
08:30:16 <dcoutts> Lemmih, ok, you've added a func to set a TextBufer directly from a Ptr () + length?
08:30:28 <dcoutts> Lemmih, actually dons added that a while ago didn't he?
08:34:11 <musasabi> benny: actually no. When you call select you use a blocking call (when you have a timeout) and the threaded Haskell runtime notices this and can run other threads while the foreign call is in progress.
08:34:56 * jethr0 wonders where vincenz is
08:35:00 <jethr0> @seen vincenz
08:35:00 <lambdabot> I saw vincenz leaving #haskell 10 hours, 31 minutes and 15 seconds ago,
08:35:00 <lambdabot> and I have missed 5 seconds since then.
08:37:23 <benny> musasabi: hm... does this work for all such functions? like an opengl flush command, where the cpu waits until the graphics card finishes buffering?
08:39:38 <musasabi> OpenGL has some extra nastiness due to thread local state, but yes it should work.
08:40:12 <musasabi> benny: of course with GHC you can use System.Mem.performGC if you want.
08:40:40 <benny> musasabi: yeah but the problem with performGC is that you don't know when you need to call it
08:42:46 <shapr> musasabi: hiya, how's code?
08:44:11 <ski> guten tag, shapr
08:44:36 <cm> achtung
08:46:30 <musasabi> nothing terribly exciting, jhc cabal stuff and work mainly.
08:46:44 <jethr0> jawohl, mein general
08:48:00 * ski sings : jawohl, jawohl, ich trinke alkohol, ich trinke keine wasser, ich trinke alkohol, jawohl, jawohl, jawohl, ...
08:51:44 <shapr> hei ski
08:51:50 <shapr> musasabi: What do you do at work?
08:53:42 <shapr> hiya franka 
08:53:50 <franka> Hello, shapr.
08:53:56 <shapr> How's the job?
08:54:27 <franka> Oh, it's OK.  Didn't have much to do for a while but now they want me to help Dave Clarke out with his Reo implementation.
08:54:41 <jethr0> reo?
08:55:19 <franka> It's a "coordination" language.
08:55:33 <jethr0> franka: would you have any idea how/where to look for functional programming jobs in germany or in general?
08:56:19 <franka> Well, I would just make sure to subscribe to the right mailing lists: Haskell, Ocaml, TYPES and maybe LL1.
08:56:37 <shapr> franka: I just spent a few minutes learning about Reo, that's cool!
08:57:04 <franka> Well, it could be worse.  But I was using my time up until now to work on my thesis.
08:57:05 <shapr> jethr0: Let's start the Logical Union of Functional Programmers.
08:57:28 <shapr> Is reo implemented in something non-java, unlike reolite?
08:57:43 <jethr0> yeah, so our non-existant employers can't fire us!
08:57:47 <franka> No, I am talking about the ReoLite implementation.
08:57:49 <SamB> ...
08:57:50 <shapr> oh
08:57:52 <franka> Which is in Java.
08:58:04 <SamB> how can it be light if it is in Java?
08:58:12 <shapr> I loved Java when I learned after I learned Visual Basic. Then I found Python...
08:58:23 <franka> What can I do?  Dave is a Java man.
08:59:00 <franka> I worked on a Haskell implementation for about a week in the beginning, but that didn't go anywhere.
08:59:17 <shapr> too bad...
08:59:27 <shapr> I've had the same problem with some of my websites though.
08:59:53 <shapr> I spend a week trying to get 'em up and running with Haskell, and realize I'll have to use Zope/Plone instead.
09:00:17 <franka> Oh, it wasn't because of Haskell.  It was just because they made me work on something else.
09:00:25 <shapr> oh
09:00:57 <franka> Right now I am working on a website generator in Haskell.
09:01:03 <franka> Since yesterday. :)
09:01:08 <xerox> Yay!
09:01:20 <franka> But I've detoured into something thesis-related again.  I do that a lot.
09:01:25 <shapr> Have you seen the many prior website generators in Haskell?
09:01:25 <jethr0> franka: where do you work?
09:01:34 <franka> I work at CWI.
09:01:45 <tromp_> anyone familiar with ghc -prof?
09:01:46 <franka> No, only pLog, which you sent me.
09:02:00 <franka> And the frameworks like HaXml and WASH.
09:02:01 <shapr> Andrew Cooke wrote Halipeto
09:02:10 <franka> Ah yes, I've looked at that.
09:02:34 <tromp_> hi franka, that makes you my colleague
09:02:40 <shapr> Lemmih hacked halipeto into something that worked as an apache plugin.
09:02:50 <franka> But right now I am just working on the XHTML/CSS implementation.
09:02:50 <shapr> nibro wrote HSP
09:03:02 <shapr> bringert turned text.html into text.xhtml
09:03:07 <franka> Oh, hello, tromp_.
09:03:12 <franka> What theme are you in?
09:03:23 <tromp_> theory of computing
09:03:28 <tromp_> INS4
09:03:38 <franka> I'm in SEN3, coordination languages.
09:03:52 <tromp_> cool
09:03:54 <xerox> It would be nice to have something which understand XML templates, in Haskell.
09:03:59 <xerox> It would be VERY nice.
09:04:17 <tromp_> working with paul klint?
09:04:29 <franka> I am not planning on making anything distributable; only a personal solution.
09:04:40 <franka> No, I don't even know Paul.
09:05:14 <jethr0> tromp_: i'm a little familiar with -prof
09:05:17 <jethr0> but only a little
09:05:22 <jethr0> how can i help?
09:06:06 <franka> I have gotten hung up on type-hacking again.  It always leads back to my thesis material.
09:06:37 <franka> Until I finish my thesis, I think I am useless as a Haskell programmer, because I am always turning everything into a thesis problem.
09:07:19 <shapr> If you put your sources online in a darcs repo, other people can look and learn.
09:07:22 <tromp_> i get this error:
09:07:29 <tromp_> Could not find module `CPUTime':
09:07:30 <tromp_>   locations searched:
09:07:30 <tromp_>     CPUTime.hs
09:07:30 <tromp_>     CPUTime.lhs
09:07:30 <tromp_>     /usr/lib/ghc-6.4.1/imports/CPUTime.p_hi
09:07:50 <tromp_> but there is a /usr/lib/ghc-6.4.1/imports/CPUTime.hi
09:07:59 <shapr> @index CPUTime
09:08:00 <lambdabot> bzzt
09:08:01 <ski> franka : heh
09:08:02 <jethr0> yes, you need profilable libs
09:08:03 <shapr> @hoogle cputime
09:08:04 <lambdabot> System.CPUTime.cpuTimePrecision :: Integer
09:08:04 <lambdabot> System.CPUTime.getCPUTime :: IO Integer
09:08:06 <franka> shapr, I will consider it if it gets a bit bigger.
09:08:10 <jethr0> tromp_: what operating system?
09:08:16 <jethr0> distribution?
09:08:19 <shapr> oh right
09:08:28 <tromp_> Linux capella.ins.cwi.nl 2.6.13-1.1526_FC4 #1 Wed Sep 28 19:15:10 EDT 2005 i686 athlon i386 GNU/Linux
09:08:48 <shapr> Debian has profiling debs.
09:08:49 <jethr0> on debian you can simply install ghc6-prof
09:09:10 <tromp_> it's fedore core 4 
09:09:29 <franka> I think there is more than enough for a paper, if I can actually solve my current problem.
09:09:31 <jethr0> should also have prof packages somewhere
09:09:53 <franka> However, it's probably not practical in Haskell.
09:10:08 <musasabi> shapr: various coding for a small firm.
09:10:49 <franka> I am trying to code CSS selectors as the derivative of HTML types, and share the representations using integration.
09:11:28 <franka> It is a very messy thing in practice but it looks beautiful theoretically.
09:12:28 <shapr> musasabi: nifty
09:12:33 <zamez> franka: you might be interested in a CSS tool I wrote in Haskell, http://zamez.org/factorcss
09:13:22 <franka> Why is it only "almost" equivalent, zamez?
09:13:30 <tromp_> there's no fedora core profile package, so i'll try the general rpm
09:13:34 <zamez> sometimes the order matters
09:13:38 <franka> Oh, heh, I see the last sentence now.
09:13:53 <zamez> plus there are probably bugs ;)
09:14:07 <davidhouse> anyone recommend a nice open source program written in haskell i could learn from?
09:14:25 <davidhouse> i'm doing well reading through the theory and i'm looking for a few nice examples
09:14:47 <musasabi> davidhouse: what kind of code are you looking for?
09:14:55 <franka> I assume you only detect equivalence of selectors.  You don't take into account the box model, etc.
09:15:09 <davidhouse> err... :) haskell code. what do you mean?
09:15:10 <shapr> davidhouse: lambdabot ?
09:15:40 <davidhouse> shapr, i was thinking that, just thought i'd ask in case anyone knew of a program with great educational value
09:16:06 <zamez> yeah
09:16:23 <franka> That is only reasonable.
09:16:29 <franka> Thanks for the link; I will bookmark it.
09:17:23 <davidhouse> is darcs like the svn of the haskell world?
09:18:02 <shapr> Nah, svn is weenie compared to darcs =)
09:18:22 <shapr> audreyt is doing something about that though...
09:18:40 <davidhouse> what advantages does darcs have over svn then?
09:18:54 <davidhouse> is it used for things other than haskell?
09:19:03 <shapr> Definitely.
09:19:05 <benny> i'm also looking for good haskell programs to read
09:19:49 <shapr> http://darcs.net/DarcsWiki/DifferencesFromSubversion
09:20:04 <davidhouse> grr, my suse install doesn't have a darcs package. is the lambdabot source available as a .tar.gz anywhere, or would anyone be willing to email it to me?
09:20:07 <davidhouse> shapr, thanks, i'll read
09:21:26 <gour> @where lambdabot
09:21:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:21:42 <shapr> Darcs' big difference is that each checkout is an independent repository, so you get all the advantages of source control without requiring access to a central repository.
09:22:17 <porok> Hi, I'm a newbie to Haskell and I've a prb with HSQL (in deb testing, updated today). Anybody here familiar with it?
09:22:27 <davidhouse> gour, yes, that's the site i was on that had a link to their darcs repo. i was wondering if there was a .tar.gz source package anywhere
09:22:49 <gour> davidhouse: ok. i can pull & email to you
09:22:57 <davidhouse> gour, much appreciated :)
09:23:00 <Saulzar> Hehe, "Most notably, with darcs you will have to type your password a ridiculous number of times until you break down and set up your ssh keys properly."
09:25:05 <shapr> Saulzar: unless you use -M with ssh 4.x 
09:27:44 <jethr0> @type mapM return xs
09:27:45 <lambdabot> Not in scope: `xs'
09:27:50 <jethr0> @type mapM return []
09:27:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a]
09:28:05 <tromp_> ah, i found the FC4 package on the extras
09:29:02 <ndm> davidhouse, you might want to look at hoogle
09:29:13 <davidhouse> ndm, what's that?
09:29:14 <ndm> thats nice, open source and relatively small
09:29:16 <ndm> @hoogle
09:29:17 <lambdabot> HOOGLE - Haskell API Search
09:29:17 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
09:29:17 <lambdabot>  
09:29:23 <davidhouse> ah.
09:29:26 <davidhouse> nice, i will. thanks.
09:29:27 <ndm> @hoogle (a -> b) -> [a] -> [b]
09:29:28 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
09:29:28 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:29:28 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:29:36 <ndm> @where hoogle
09:29:37 <lambdabot> http://www.haskell.org/hoogle
09:29:51 <tromp_> @hoogle a->b->a
09:29:52 <lambdabot> Control.Parallel.par :: a -> b -> b
09:29:52 <lambdabot> Control.Parallel.seq :: a -> b -> b
09:29:52 <lambdabot> GHC.Conc.par :: a -> b -> b
09:30:07 <tromp_> hmm, no const?
09:30:16 <ndm> @hoogle+
09:30:16 <lambdabot> GHC.Conc.pseq :: a -> b -> b
09:30:16 <lambdabot> Prelude.const :: a -> b -> a
09:30:16 <lambdabot> Prelude.seq :: a -> b -> b
09:30:40 <ndm> argument order is irrelevant, so its just unlucky that it got there
09:30:46 <tromp_> @hoogle+
09:30:46 <lambdabot> Prelude.asTypeOf :: a -> a -> a
09:30:46 <lambdabot> Prelude.max :: Ord a => a -> a -> a
09:30:46 <lambdabot> Prelude.min :: Ord a => a -> a -> a
09:31:17 <ndm> on the website const is first
09:32:39 <alea_tor> ndm:  I got the feeling that this was already asked today, but how do I add libraries to (cmdline) hoogle?
09:33:31 <ndm> alea_tor: darcs get hoogle, look at data/hadhtml - make that and run hadhtml on the directory containing haddock generated .html files
09:33:47 <ndm> it produces a hoogle.txt, rename that to whatever, and pass it as an arguemnt to the command line version
09:34:01 <ndm> if you want to merge with another hoogle database, then cat will do it
09:37:46 <ski> hyvää iltaa, esap
09:39:25 <alea_tor> ndm: Ok. Thanks. 
09:40:32 <esap> ski: iltaa!
09:41:44 <alea_tor> ndm: hoogle: ./Hoogle/TypeSig.hs:(61,0)-(62,20): Non-exhaustive patterns in function typeName ?
09:42:12 <ndm> alea_tor: hmm, what were youy trying to search for?
09:42:37 <tromp_> hmm, this time profile looks pretty useless
09:42:38 <alea_tor> ndm: ./hoogle map
09:43:07 <tromp_>  CAF Main takes 99.8% of all time
09:43:15 <ndm> alea_tor: with a custom database?
09:43:27 <alea_tor> ndm: yes.
09:43:42 <Igloo> tromp_: Did you use -auto-all?
09:43:55 <ndm> alea_tor: can you please either send me the database, or remove lines until it works (at which point i'll have the database line that is at fault)
09:44:08 <tromp_> nope; just ghc -prof and a.out -p
09:44:33 <Igloo> That's your problem, then; you don't have any useful cost centres
09:47:04 <alea_tor> ndm: Sure. I'll try removing stuff. Is there anything that hoogle.txt has to have for it to work?
09:47:33 <ndm> alea_tor: a module header must be the first real line
09:47:42 <ndm> i.e. module Boo above all functions
09:50:18 <tromp_> igloo, is  -auto-all a compiler option or RTS option?
09:50:30 <Igloo> compiler
09:50:33 <tromp_> it sucks not to have ghc man pages:(
09:51:02 <Igloo> You should use Debian  :-)
09:51:25 <ski> esap : any progress on the type system ?
09:51:43 <tromp_> i compiled with ghc -O3 -prof -auto-all --make Main.hs
09:52:36 <tromp_> but don't get any new cost centers
09:52:51 <Igloo> You aren't forgetting the +RTS before the -p?
09:53:09 <tromp_> i run with (haskell 1277) ./a.out +RTS -sstderr -p -RTS < input
09:53:16 <Igloo> And did the module actually get recompiled with -auto-all?
09:53:43 <alea_tor> ndm: I think I narrowed it down: http://pastebin.com/538775 (unless I screwed something else in process)
09:53:50 <tromp_> how do i force recompilation?
09:53:59 <Igloo> Remove the .o file
09:54:04 <tromp_> yuck:(
09:54:17 <tromp_> hoped there'd be a nicer way like -force
09:54:59 <ndm> alea_tor: yep, its the class line thats broken - can you send me the haddock generated html for System.Glib.Flags
09:55:14 <ndm> ndmitchell    -#- gmail -*- com
09:55:17 <tromp_> ok, now i get more data
09:55:19 <tromp_> thx
09:55:36 <shapr> -*- mode: irc -*-
10:00:40 <alea_tor> ndm: done. 
10:01:59 <ndm> alea_tor: thanks very much, i'll hope to get that sorted on monday
10:02:42 <alea_tor> ndm: No hurry on my account. :)
10:03:32 <ndm> alea_tor: the hadhtml code is very hacked sadly, i really need an XML output for Haddock...
10:05:55 <jethr0> how do i pattern match against a record?
10:06:15 <jethr0> i'd like to write "func x | x == Constructor{} = ..."
10:06:25 <dcoutts> ndm, you can't read the .haddock file?
10:06:32 <Saulzar> Foo { label = value }
10:06:46 <jethr0> yes, but in the above case with "|"
10:06:59 <Saulzar> Hmm.
10:07:12 <dcoutts> ndm, the best thing to do would be to extend the ghc lexer/parser to understand haddock comments
10:07:29 <jethr0> i guess i could take a "case"
10:09:25 <tromp_> my haskell program is 25 times slower than my c program.
10:09:33 <jethr0> that's fixable
10:09:37 <tromp_> and spends 22% of its time in a trivial function
10:09:58 <jethr0> most time when my programs were slow i had a simple memory leak
10:10:20 <jethr0> btw, i think the term "memory leak" makes it sound more dire than it is :)
10:10:35 <jethr0> it's not leaking, just resting ^_^
10:10:56 <tromp_> there's no leak. i have between 6 and 20% time spent on GC
10:11:03 <ski> 'func x | Foo _ <- x = ...' ?
10:12:04 <tromp_> the c version spends 25% of its time in the same function
10:12:21 <tromp_> so that function alone is over 20 times slower than c
10:12:37 <Saulzar> Foo <- x   does pattern matching outside of do notation?
10:12:58 <ski> extension iirc called 'pattern guard'
10:13:02 <jethr0> ski: yes, but the constructor have different arg lengths
10:13:41 <ndm> dcoutts, i don't, but i guess there is no fundamental reason i couldn't
10:13:42 <ski> different from what ?
10:13:46 <ndm> as long as it has all the information in
10:14:10 <ndm> dcoutts, i don't really want the haddock information, i just want the data signatures
10:14:14 <dcoutts> ndm, hmm, actually perhaps it only has location info not full type info
10:14:29 <ndm> i might be able to extend Yhc to give all the information quite easily
10:14:33 <ndm> including inferred types
10:14:38 <dcoutts> ndm, so why don't you use the .hi files then, rather than haddock info?
10:15:03 <ndm> dcoutts, because the .hi files are a mess - lots of special cases, inline information etc.
10:15:09 <tromp_> any suggestions how to speed this up?
10:15:11 <tromp_> isWon bb = any ((/= 0) . dir) [1,height,height',height''] where
10:15:11 <tromp_>   dir d = let t = bb .&. (bb `shiftR` d) in t .&. (t `shiftR` (2*d))
10:15:21 <dcoutts> ndm, I don't think it's too hard to seperate out
10:15:28 <ndm> dcoutts, there is a hihoo program in teh darcs repo, which tries this
10:15:30 <tromp_> where bb will be of type Word64...
10:15:38 <dcoutts> ndm, oh yes
10:15:41 <ndm> if anyone can get something better, i'd happily switch
10:15:54 <ndm> currently hihoo is worse than hadhtml
10:16:03 <dcoutts> ndm, it works best on non "-O" .hs files
10:16:11 <dcoutts> .hs/.hi
10:16:45 <dcoutts> ndm, I think you mgiht find it's not that hard to write another output format for haddock
10:16:58 <ndm> dcoutts, i had a rough shot once, and failed
10:17:02 <dcoutts> ndm, it'd be much smaller that the html version since it's a mich simpler format
10:17:15 <ndm> the haddock html and logic were too intertwined
10:17:30 <ndm> but it could be done, i just don't have the time
10:17:44 <dcoutts> yeah, that's a perenial problem :-)
10:17:54 <ndm> but if anyone did have the time, i'd be very happy to use their efforts, and help with any bits of hoogle they don't understand
10:18:31 <jethr0> ski: sry, working. they can have different number of arguments. and the wildcards have to match the args!
10:18:55 <ndm> hoogle still hasn't been released or announced ever, so i'm trying to get it out of beta, and the data generation bugs can wait :)
10:19:36 <dcoutts> ndm, eventually we'll want to use it in hIDE
10:20:48 <Lemmih> We do?
10:22:04 <dcoutts> Lemmih, sure, for type-based search
10:22:17 <SamB> it needs work though...
10:22:31 <dcoutts> Lemmih, we'll want name & type based search of functions in a project
10:22:49 <dcoutts> Lemmih, don't you think? It's not a killer feature, but it'd be nice.
10:22:54 <Lemmih> dcoutts: Hacking something new using the ghc-api would probably be a lot easier and more correct.
10:23:08 <ski> jethr0 : you can of course match against 'Foo {bar = _,baz = _}', but maybe you wanted to avoid enumerating the fields ..
10:23:44 <SamB> jethr0: you could match against Foo {}
10:23:47 <jethr0> yup, i get it now
10:23:56 * Lemmih is still perplexed with hoogles unification algorithm.
10:24:06 <alea_tor> Lemmih: If hIDE digs that information from code won't that be simple input for hoogle?
10:24:09 <ndm> Lemmih: have you seen the slides?
10:24:18 <dcoutts> Lemmih, ok, so the data gathering should probably be via the ghc api but the searching can use hoogle's stuff.
10:24:41 <ndm> http://www-users.cs.york.ac.uk/~ndm/downloads/slides-hoogle-08_dec_2005.pdf
10:25:08 <ndm> that presentation gives a rough overview of hoogles algorithm
10:25:19 <Lemmih> alea_tor: I'd rather use the typechecker from GHC since it can handle all of Haskell.
10:25:22 <ndm> hoogle's data collection code at the moment isn't very good
10:27:17 <basti_> the insight of this http://research.microsoft.com/Users/simonpj/Papers/financial-contracts/contracts-icfp.htm is: financial people are talking a lot about not a lot of stuff
10:29:58 <davidhouse> hey, i'm in the middle of learning haskell, just making my way through a textbook. i've come across arrays:
10:30:23 <davidhouse> my book basically lacks any explanation as to what an array is, how they are different from lists, and so on. could anyone give me a brief run down?
10:30:39 <davidhouse> i've got experience in other languages so you don't need to start from first principles
10:30:53 <ski> an array has O(1) lookup, as opposed to lists, which are O(n)
10:31:24 <ski> also, an array can't be easily extended .. if you need that you usually need to copy the whole array in the process
10:31:58 <davidhouse> hmm...
10:32:01 <ski> @type (Data.Array.!)
10:32:02 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
10:32:07 <ski> that indexes an array
10:32:12 <xerox> How was to show Doubles without 'e' syntax?
10:32:27 <davidhouse> right well from my book i can see that an array is made up of a pair and a list of pairs.
10:32:45 <ski> @type Data.Array.array
10:32:46 <lambdabot> forall e i.
10:32:46 <lambdabot> (GHC.Arr.Ix i) =>
10:32:46 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
10:32:55 <ski> that is one way of creating an array, yes
10:33:18 <Saulzar> xerox, showFFloat seems to give some options
10:33:38 <xerox> @type showFFLoat
10:33:39 <lambdabot> Not in scope: `showFFLoat'
10:33:46 <xerox> @index showFFLoat
10:33:47 <lambdabot> bzzt
10:33:53 <xerox> @index showFLoat
10:33:53 <lambdabot> bzzt
10:33:58 <xerox> @index showFFloat
10:33:58 <lambdabot> Numeric
10:34:00 <xerox> Sorry
10:34:05 <xerox> @type Numeric.showFFloat
10:34:06 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> ShowS
10:34:20 <ski> 'Data.Array.array (0,9) [(i,i*i) | i <- [0..9]]' e.g. will create an array indexed by numbers from 0 to 9, and elements set to the square of each index
10:34:32 <Saulzar> Hmm, actually - I think there are variants on it for different ways of formating floats
10:34:38 <davidhouse> ah, i think i understand: the pair is the bounds of the array (although i would have thought just an integer representing the length of the array would suffice?) and in the list of pairs, the first item is the index and the second the object?
10:34:54 <franka> Yes.
10:34:58 <xerox> Mumble.
10:35:02 <xerox> @docs Numeric
10:35:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
10:35:24 <franka> (@ davidhouse)
10:35:41 <franka> The bounds are there because in Haskell arrays can be indexed by things other than integers.
10:36:00 <davidhouse> franka, right.
10:36:17 <xerox> What is a 'ShowS' ?
10:36:28 <franka> ShowS = String -> String
10:36:38 <xerox> Right!
10:36:42 <Saulzar> ndm, Somone has really searched for hotmail.com or eastenders on hoogle?!!
10:36:44 <xerox> So there is a "" there..
10:36:56 <ndm> Saulzar: yes
10:37:09 <franka> Are you testing me?
10:37:11 <Saulzar> Amazing..
10:37:36 <franka> Oh, you are talking to someone else...
10:37:56 <ndm> yes, its always weird to see what people search for
10:38:06 <ndm> but its useful to get better results in future
10:38:17 <ndm> for example, i never guessed anyone would search for where, but they do!
10:38:36 <Saulzar> It's hard to see how somone would end up at hoogle by mistake..
10:38:58 <Saulzar> Unless they mis-typed "google" when they went to yahoo to search for google first
10:39:37 <ski> 'Data.Array.array ((-10,-10),(10,10)) [((x,y),x*y) | x <- [-10..10],y <- [-10..10]]' e.g. will create a two dimensional array indexed by pairs of numbers each inside -10 to 10, and elements set to the product of the two indices
10:39:49 <franka> You can see recent Hoogle searches?
10:39:55 <xerox> dcoutts: ping!
10:40:02 <ndm> yeah, its totally beyond me - and ?oogle is one of the most popular queries, with various ?'s for letters
10:40:06 <ndm> franka, no - only i can
10:40:09 <xerox> Cale: ping!
10:40:43 <franka> ndm, Look now.
10:40:45 <ndm> and i don't record times/IP's or anything else
10:41:08 <ski> davidhouse : see ?
10:41:25 <ndm> franka, where, showHex ?
10:41:32 <jethr0> isn't it possible to "inherit" from a record data type so that the "children" have their own types not just their own constructors?
10:41:40 <SamB> hmm, my Z-machine interpreter does not work very well on Inform source files...
10:41:42 <franka> I searched for "Britney Spears panties".
10:42:02 * Saulzar searched for "where"
10:42:07 <ndm> franka, lambdabot, or the web interface?
10:42:10 <ndm> only the web interface is logged
10:42:17 <franka> The web interface.
10:42:26 <franka> But nevermind; the joke is spoiled now. :(
10:42:42 <davidhouse> > Data.Array.array ((-10,-10),(10,10)) [((x,y),x*y) | x <- [-10..10],y <- [-10..10]]
10:42:43 <ndm> franka, worrying, but it hasn't shown up in the log...
10:42:43 <lambdabot>  Not in scope: `Data.Array.array'
10:42:50 <davidhouse> > array ((-10,-10),(10,10)) [((x,y),x*y) | x <- [-10..10],y <- [-10..10]]
10:42:51 <lambdabot>  Not in scope: `array'
10:42:58 <ski> jethr0 : hm ?
10:43:10 <SamB> ndm: is it buffered?
10:43:14 <ski> for some reason it's not in scope there
10:43:15 <jethr0> i have "data A = B {...} | C {...}"
10:43:18 <ndm> SamB, no
10:43:28 <jethr0> where B and C share most record labels
10:43:29 <davidhouse> > Array.array ((-10,-10),(10,10)) [((x,y),x*y) | x <- [-10..10],y <- [-10..10]]
10:43:30 <lambdabot>  Not in scope: `Array.array'
10:43:30 <ndm> i just searched for Britney Spears panties, and it came up right away...
10:43:34 <davidhouse> grr.
10:43:45 <franka> I just searched for "ndm can you see this?".
10:43:47 <jethr0> and now i want to make type a tuple (B,C)
10:43:54 <jethr0> but i can't since B and C aren't types
10:44:19 <jethr0> i can type it (A,A), but loose some type safety in contrast to what i _know_
10:44:27 <ndm> Are you up there God?
10:44:29 <davidhouse> ski, i think so. can you get lambdabot to run that code though?
10:44:29 <jethr0> *lose
10:44:42 <davidhouse> ski, it kept giving me not in scope errors, as you can see
10:44:51 <ski> jethr0 : sharing the common fields ?
10:44:59 <jethr0> yup
10:44:59 <ndm> franka, thats th e last query - it seeems yours don't get logged - are you using hoogle 3 or hoogle 2?
10:45:09 <jethr0> like a class, but as a record not for functions
10:45:18 <franka> ndm: 2
10:45:19 <ski> (sounds like a pullback)
10:45:32 <ndm> franka, i recommend 3 now - thats teh only one with active development
10:45:36 <ndm> @where  hoogle
10:45:37 <lambdabot> http://www.haskell.org/hoogle
10:45:56 <franka> Ah, OK.
10:46:20 <ski> jethr0 : i believe you can do 'data A = B BC B | C BC C' .. but that requires splitting like that :/
10:46:37 <jethr0> huh? what am i looking at?
10:47:02 <jethr0> ah, i see
10:47:02 <ski> (common fields inside BC, B-only fields in B, C-only fields in C)
10:47:17 <jethr0> that's where i just refactored from :)
10:47:31 <ski> davidhouse : you need to import 'Data.Array' .. and lambdabot hasn't done that
10:47:53 <davidhouse> ski, okay.
10:47:57 * davidhouse fires up ghci
10:48:07 <ski> i guess if we had a typesystem with subtyping and pullbacks of records, it could possibly be done
10:48:21 <ski> (jethr0 : interesting problem, anyway)
10:48:58 <ski> (well, not arbitrary pullbacks needed)
10:49:46 <jethr0> what are pullbacks?
10:50:16 <franka> A method of birth control.
10:50:51 <JKnecht> like stateful callbacks?
10:50:56 <jethr0> :)
10:51:27 <ski> pullback is a categorical construction
10:51:29 <franka> A pullback is a categorical construction; in Set, a pullback is an equationally defined subset of a binary product.
10:51:46 <jethr0> k
10:51:55 <franka> Like the set of points on a circle.
10:52:07 <ski> in this case, we want to ensure that both versions of overlapping fields have same value .. so they are essentially the same field
10:52:26 <ski> (this is a bit related to "multiple inheritence", i think)
10:52:37 <JKnecht> what's in pull back from, the real field, some ring or what?
10:52:47 <JKnecht> s/in/it/
10:53:10 <ski> f,g : R -> R
10:53:16 <ski> f(x) = x*x
10:53:23 <ski> g(y) = 1 - y*y
10:53:34 <ski> it's pullback of f and g
10:54:09 <franka> if the radius is 1 and it's centered at the origin
10:54:19 <davidhouse> yay, maths in a programming channel :)
10:54:23 <ski> we want {(x,y) | f(x) = g(y)} = {(x,y) | x*x = 1 - y*y} = {(x,y) | x*x + y*y = 1}
10:54:25 <ski> yes
10:54:40 <ski> (and that is what the pullback gives)
10:56:57 <ski> in your case, the wanted pullback would be of  f : B -> BC and g : C -> BC (those functions extracting just the common fields), and the pullback becomes the type you wanted
10:58:52 <xerox> @hoogle windowSetGeometryHints
10:58:53 <lambdabot> No matches found
11:01:23 <mCkaine> hello
11:01:32 <mCkaine> Who speak english?
11:01:33 <ski> hi mCkaine
11:01:44 <mCkaine> Where are you from ski?
11:01:52 <franka> Is this a trick question?
11:02:02 <mCkaine> no
11:02:31 <mCkaine> Isimly asked:Where are you from ski?
11:02:36 <ski> most people here speak english
11:02:46 <mCkaine> it's very good
11:02:47 <benny> i'd say all people here
11:02:51 <franka> In that case, I propose Margaret Thatcher.
11:03:02 <mCkaine> Who is german/
11:03:05 <mCkaine> ?
11:03:09 <mCkaine> or italian?
11:03:12 <ski> mCkaine : sweden, which /whois says
11:03:26 <franka> Peter Maffay is German.
11:03:39 <ski> xerox is italian, i think
11:03:39 <Lor> Umberto Eco is Italian.
11:03:44 <franka> Um, Isabella Rossolini?
11:04:05 <Lor> Rossellini.
11:04:10 <franka> Oh, good one, Lor!
11:04:20 <franka> Ah, scuse.
11:04:48 <ski> are you trying to scare away the good newbie ?
11:05:08 <franka> I am only answering his questions.
11:05:10 * ski tries to stare angrily at franka and Lot
11:05:22 <mCkaine> franka?
11:05:31 <ski> s/Lot/Lor/ (sorry about that .. misspelling)
11:05:32 <mCkaine> you received my melody/
11:05:33 <mCkaine> ?
11:05:35 <franka> At your service, mCkaine 
11:05:49 <franka> Your melody?
11:05:51 <mCkaine> i sent you a melody
11:06:00 <franka> You mean a file?
11:06:07 <mCkaine> doesn't work/
11:06:08 <mCkaine> ?
11:06:20 <mCkaine> fuck with that network
11:06:29 <basti_> mCkaine: I'm from germany
11:06:32 <franka> I probably have file transfer off.
11:06:38 <franka> Why do you want to send me a file?
11:06:48 <mCkaine> Romania-Germany=5-1
11:06:50 <mCkaine> :)))))
11:06:55 <basti_> ?
11:07:02 --- mode: ChanServ set +o shapr
11:07:12 <mCkaine> franka?
11:07:18 <shapr> mCkaine: this channel is about the programming language haskell.
11:07:21 <mCkaine> You have an Id from messenger/
11:07:22 <shapr> Do you want to learn Haskell?
11:07:33 <mCkaine> yes
11:07:38 <shapr> @learn
11:07:39 <lambdabot> http://www.haskell.org/learning.html
11:07:50 <ski> @hawiki HaskellDemo
11:07:50 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
11:07:52 <franka> You probably don't want to chat with me.  I am male.
11:08:10 <franka> ALL male, ALL the time, if I do say so myself.
11:09:07 <mCkaine> This message is for all boys of this chat:i reccomend a romanian beauty girl:www.iubita.ro
11:09:22 <shapr> mCkaine: That's way off topic.
11:09:28 <ski> mCkaine : do have any question about haskell right now ?
11:09:36 <mCkaine> Ijust reccomend it
11:09:45 <mCkaine> I just reccomend it
11:09:46 <ski> mCkaine : which programming languages do you know ?
11:09:46 <shapr> If you want to talk about that, you can do it on some other irc channel.
11:10:01 <mCkaine> C++
11:10:10 <ski> ok
11:10:28 <ski> and how did you come to learn haskell existed ?
11:10:39 <ski> school ?
11:10:58 <ski> friends ?
11:11:05 <Lor> mCkaine, some channels, believe it or not, are actually used for real contentful discussion instead of pointless chitchat. This is one of those. Hint. _Hint_.
11:11:05 <mCkaine> we learn at school C++
11:11:19 <Lor> Not that there's anything wrong with pointless chitchat, but there's a time and a place for everything.
11:11:22 <benny> anyone know what Dirac impulses are?
11:11:42 <basti_> benny: yes.
11:11:57 <astrolabe> benny:  I guess the dirac delta 'function'?
11:12:00 <basti_> they're like: 0,0,0,0,0,1,0,0,0,0,0
11:12:04 <ski> mCkaine : FYI, haskell is a statically typed, but type inferenced, purely functional, non-strict programming language
11:12:05 <mCkaine> I say you Romanian school is the best school in the world
11:12:06 <shapr> benny: http://en.wikipedia.org/wiki/Dirac_delta_function
11:12:12 * Lor has never really understood how dirac impulses work mathematically.
11:12:15 <basti_> just, continuous
11:12:19 <mCkaine> Romanian school is very seriously
11:12:20 <shapr> mCkaine: If you continue off topic discussion, you get removed from the channel.
11:12:25 * davidhouse writes a program to find perfect numbers
11:12:33 <basti_> the integral over them is 1, and they're 0 everywhere except at 0
11:12:56 <Lor> Strange beasts, those.
11:13:12 <Lor> (dirac functions, not perfect numbers)
11:13:13 <basti_> dirac is the unit of the convolution algebra.
11:13:18 <ski> sounds fun
11:13:44 <shapr> Well, that was clear enough.
11:13:48 --- mode: shapr set -o shapr
11:13:51 <basti_> aparrently
11:13:56 <Lor> Talking about math drove him away. :)
11:14:08 <astrolabe> I don't think he wanted to talk about haskell
11:14:16 <shapr> Yeah, it didn't seem so.
11:14:20 <shapr> Thus the gentle reminder.
11:14:39 <basti_> d.mbf.ck.
11:14:42 * ski tried some .. but no real response :/
11:14:43 <Lor> Actually, I'm kind of surprised that these kinds of visitors are so rare here.
11:15:00 <basti_> freenode has too few sex channels
11:15:10 <ski> (possibly obscurity of language ?)
11:15:21 <shapr> They're not rare really. But when I'm around I quickly encourage them to go elsewhere.
11:15:24 <benny> shapr: btw did you see this screenshot? http://img145.imageshack.us/img145/7513/drivedrive0020dn.png
11:15:28 <Lor> And too few regional social channels, I think.
11:15:37 <astrolabe> Strictly the dirac delta function isn't a function, but it exists in the completion of the space of square integrable functions IIRC.  In other words, you can define it as the limit of a sequence of functions.
11:15:37 <basti_> freenode is generally pleasantly devoid of idiots
11:15:45 <basti_> no it isnt a function
11:15:48 <shapr> benny: looks cool
11:16:06 <basti_> it's a "functional", and in L_2
11:16:08 <davidhouse> how does the forall construction work?
11:16:09 <Lor> If you can define it as the limit, then presumably the limit exists?
11:16:13 <basti_> (square integrable)
11:16:14 <benny> shapr: do you have i386 linux, a good opengl card and sdl and want to try it out?
11:16:36 <basti_> Lor: it is not a function. there is no mapping from reals to reals that exhibits these properties
11:16:46 <shapr> Well, except for the last part.. I'm doing work that should get me money...
11:16:48 <ski> davidhouse : where ?
11:17:13 <davidhouse> ski, in general. what does it do, and what is its syntax?
11:17:41 <ski> davidhouse : it introduces (parametric) polymorphism, when used in types
11:17:44 <ski> @type reverse
11:17:45 <lambdabot> forall a. [a] -> [a]
11:18:17 <davidhouse> ah. thanks again ski.
11:18:20 <davidhouse> :)
11:18:25 <ski> this means that, for any actual type substituted in place of 'a', reverse can be used with that full type
11:18:30 <ski> e.g.
11:18:38 <ski> reverse :: [Int] -> [Int]
11:18:46 <ski> reverse :: [Bool] -> [Bool]
11:19:00 <ski> reverse :: [[(Int,String)] -> [[(Int,String)]]
11:19:19 <ski> reverse :: forall b c. [b -> c] -> [b -> c]
11:20:40 <benny> hm... seems like i must finally learn what rank-2 means :/
11:21:02 <ski> and, the 'parametric' means that, the function can't do anything else with elements of type 'a' other than copying,discarding and passing around (since it can't assume anything about the type 'a')
11:21:32 <ski> @type Control.Monad.ST.runST
11:21:33 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
11:21:46 <ski> this is a rank-2 polymorphic type
11:22:01 <ski> since the 'forall' is used inside an argument type
11:22:46 <ski> (and type inference doesn't work generally on these types)
11:25:07 <ski> (in this case, the type means that 'runST' *must* be called on a genuinely polymorphic argument)
11:26:35 <ski> (instead of the user of 'runST' deciding what type 's' should be, it's 'runST' itself which decides what type 's' should be, user have to pass an argument which could potentially work for any type 's')
11:37:58 <jethr0> is there sth like "const" for functions?
11:38:16 <Cale> um... hm?
11:38:32 <jethr0> like "let cnst f = \x -> f"
11:38:41 <Cale> @type const
11:38:42 <lambdabot> forall a b. a -> b -> a
11:38:49 <Cale> @type const (+)
11:38:50 <lambdabot> forall a b. (Num a) => b -> a -> a -> a
11:39:04 <jethr0> huh?
11:39:05 <Cale> @type const zipWith
11:39:06 <lambdabot> forall a b c b1. b1 -> (a -> b -> c) -> [a] -> [b] -> [c]
11:39:27 <jethr0> k
11:39:28 <jethr0> i see
11:43:41 <jethr0> cale, do you know runInteractiveProcess?
11:43:49 <jethr0> or for that matter "runProcess"?
11:45:09 <porok> Hi, here is another newbie having a problem
11:45:29 <porok> a problem related to haskell and hsql
11:45:32 <jethr0> porok: always :)
11:45:53 <porok> oh, is that problem persistent? :)
11:46:10 <jethr0> it's a feature
11:46:34 <jethr0> but i must admit hsql isn't exactly my forté
11:46:44 <xerox> dcoutts: ping
11:46:45 <jethr0> > const (+) 1 2 3
11:46:46 <lambdabot> 5
11:47:02 <jethr0> > (const (+) 1 2) 3
11:47:03 <lambdabot> 5
11:47:12 <porok> aah, then you can tell me right away how to compile a haskell example...
11:47:22 <porok> there is a linking problem 
11:47:26 <Cale> jethr0: yeah
11:47:29 <jethr0> what's it say
11:47:44 <jethr0> Cale: i'm wondering how to find out whether executing the process failed
11:47:54 <palomer> the problem with monads is that you're working in a monad, then you realise you need more capabalities, so you change tons of code, and then you move on, and then you realize that you need even more, so you change even more code, etc...
11:48:00 <porok> it cannot find the hsql package nor the libraries
11:48:01 * palomer spent half the day doing this yesterday
11:48:01 <jethr0> i mean right away (doesnt' exist, not executable, ...)
11:48:14 <Cale> jethr0: getProcessExitCode
11:48:22 <porok> yuep
11:48:49 <jethr0> Cale: yes, but i need to know whether runInteractiveProcess worked. _before_ it exits :)
11:49:02 <jethr0> porok: what's the error message?
11:49:08 <porok> /usr/lib/haskell-packages/ghc6/lib/hsql-postgresql-1.6//libHShsql-postgresql-1.6.a(PostgreSQL.o): In function `DatabaseziHSQLziPostgreSQL_connect_srt': undefined reference to `DatabaseziHSQLziTypes_zdfTypeableSqlError_closure'
11:49:08 <porok> collect2: ld returned 1 exit status
11:49:13 <porok> that was one
11:49:20 <porok> then the other one is
11:49:21 <jethr0> porok: that's not good
11:50:00 <porok> Main.o: In function `s3P6_srt': undefined reference to `DatabaseziHSQLziPostgreSQL_connect_closure'
11:50:00 <porok> collect2: ld returned 1 exit status
11:50:05 <jethr0> porok: as i said, i'm no expert with hsql and maybe this is a common problem. but i'd consider getting newer/different library versions
11:50:25 <porok> I updated my debian testing today
11:50:33 <jethr0> porok: i guess it means that the haskell interfaces are out of sync with the libraries
11:50:46 <jethr0> otherwise haskell should have complained long before the linker
11:51:19 <jethr0> porok: did you have the problem before too? testing doesn't move all that fast :)
11:51:20 <porok> somehow I cannot compile everything with 'ghc -o Main Main.hs Queries.hs -package hsql'
11:51:24 <porok> but
11:51:51 <porok> I have to compile first Main.hs to .hi and to .o and similarly for Queries.hs
11:52:00 <porok> and then try the linking
11:52:10 <porok> but the linking doesn't work
11:52:22 <Cale> add --make ?
11:52:36 <porok> ok, I'll try that - wait a snd
11:53:49 <jyp> is anyone using hs-plugins around ?
11:53:52 <porok> incredible & thanks, the --make option worked! :)
11:54:11 <porok> Can you explain why? I'm totally confused...
11:54:30 <Cale> The package wasn't specified, so it didn't know what to link against.
11:54:52 <Cale> I suspect that something like --package HSQL or some such would also work
11:54:56 <Lemmih> jyp: kinda.
11:54:58 <porok> Even with '-package hsql' at the end?
11:55:18 <porok> ok, I'll try with uppercase 
11:55:29 <Cale> er, with one - yeah
11:55:35 <Cale> I don't know what the case should be
11:55:55 <jyp> Lemmih: I'm updated to latest version and I'm getting "Segmentation fault" whenever I run a program linked with hs-plugins
11:56:00 <Cale> --make is a lot safer :)
11:56:01 <jethr0> @pl \x -> f x || g x
11:56:02 <lambdabot> liftM2 (||) f g
11:56:15 <porok> isto@h200428:~/haskell/haskellsrc/HSQL/examples$ ghc -o Main Main.hs Queries.hs -package hsql
11:56:15 <porok> Main.hs:10:0:
11:56:15 <porok>     Failed to load interface for `Queries':
11:56:15 <porok>         Could not find module `Queries': use -v to see a list of the files searched for
11:56:38 <jyp> Lemmih: Is this a known problem? or did I do something stupid ?
11:56:42 <Cale> must be some other package
11:56:49 <porok> and with uppercase HSQL the cimpiler says it cannot find the package
11:56:52 <jethr0> @type liftM2 (||)
11:56:53 <Cale> okay
11:56:53 <lambdabot> Not in scope: `liftM2'
11:57:03 <Cale> (I'm really not familiar with HSQL)
11:57:22 <ski> @type let ap = Control.Monad.ap in \f g -> return (||) `ap` f  `ap` g
11:57:22 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
11:57:29 <porok> ok, but the --make works and thats fine for some time... :)
11:57:40 <ski> @type let ap = Control.Monad.ap in \f g -> return (||) `ap` (\x -> f x)  `ap` g
11:57:41 <lambdabot> forall t.
11:57:41 <lambdabot> (Monad ((->) t)) =>
11:57:42 <lambdabot> (t -> Bool) -> (t -> Bool) -> t -> Bool
11:58:09 <jethr0> i'm a bit thick today
11:58:19 <porok> Cale: do you need/use sql?  If yes, what packages you use?
11:58:23 <ski> @type Control.Monad.liftM2 (||)
11:58:24 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
11:58:30 <jethr0> *cough stupid monads cough*
11:58:52 * xerox beats jethr0 
11:59:10 <jethr0> it wasn't supposed to be hearable
11:59:15 <jethr0> that's why i coughed
11:59:26 <jethr0> *grumble*
11:59:41 * xerox hands jethr0 a lambda cookie
11:59:46 <jethr0> *yeah*
11:59:54 <jethr0> i still don't get it.
12:00:05 <ski> which ?
12:00:13 <Cale> porok: I haven't needed it yet. There's also HDBC
12:00:14 <jethr0> @type Control.Monad.liftM2 (||)
12:00:14 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
12:00:36 <jethr0> > Control.Monad.liftM2 (||) True False
12:00:37 <lambdabot> Couldn't match `m Bool' against `Bool'
12:00:37 <palomer> Hashtable seems antiquated
12:00:40 <palomer> it doesn't use typeclasses
12:00:49 <jethr0> ok, so the functions i pass are in the (e->) monad, right?
12:01:08 <ski> > Control.Monad.liftM2 (||) (return True) (return False) "x"
12:01:09 <lambdabot> True
12:01:18 <Lemmih> jyp: Got a small test case? Does it segfault when you start your program or when you load an object file?
12:01:20 <jethr0> yes, i understood, i was just checking my sanity
12:01:27 <ski> > Control.Monad.liftM2 (||) id (return False) False
12:01:28 <lambdabot> False
12:01:29 <porok> Cale: ok! I'll check the hdbc if that somehow would be nice for my needs. 
12:01:32 <ski> > Control.Monad.liftM2 (||) id (return False) True
12:01:33 <lambdabot> True
12:01:55 <ski> jethr0 : yes
12:01:59 <jyp> Lemmih: I'm pretty sure it fails right at the start
12:02:12 <jethr0> so, whenever i want to combine two functions on a single value, i just lift the combining function into (e->) to give me (e-> (e->))
12:02:14 <porok> Cale: btw, I think that the standard libraries should have SQL somehow with them 
12:02:15 <jethr0> ??
12:02:16 <jethr0> does any of that make sense?
12:02:53 <Lemmih> jyp: So 'main=putStrLn "Hello world!"' segfaults if you compiled it with '-package plugins'?
12:03:12 <jyp> Lemmih: I'm testing right now
12:03:15 <ski> jethr0 : not (e-> (e -> ..)) ..
12:03:32 <jethr0> hehe
12:03:48 <ski> jethr0 : but converting 'a -> b -> c' into '(e -> a) -> (e -> b) -> (e -> c)'
12:03:59 <jethr0> hmm
12:04:05 <ski> (in the case of the plain environment monad, i.e.)
12:04:08 <jethr0> i'll have to move that around my head a little
12:04:35 <ski> so, that copies the e argument onto the two function arguments
12:04:49 <jethr0> let (&&&) = liftM2 (,) in id &&& id $ 5
12:04:52 <jethr0> > let (&&&) = liftM2 (,) in id &&& id $ 5
12:04:53 <lambdabot> (5,5)
12:04:58 <jethr0> *yeah*
12:05:07 <Cale> > (do x <- (+1); y <- (*2); return (x+y)) 5
12:05:08 <lambdabot> 16
12:05:21 <jyp> Lemmih: hello world runs
12:05:21 <jethr0> that's just crazy
12:05:39 <Cale> 5+1 + 5*2
12:06:05 <ski> it's how ski-calculus work, in a sense
12:06:45 <jethr0> sequence [(+1), (*2), return . (+)] 5
12:06:48 <jethr0> > sequence [(+1), (*2), return . (+)] 5
12:06:49 <lambdabot>   Occurs check: cannot construct the infinite type: a = m (a -> a)
12:06:49 <lambdabot>   Expected type: a -> a
12:06:49 <lambdabot>   Inferred type: a -> m (a -> a)
12:07:02 <jethr0> > sequence [(+1), (*2), return . (+)] $ 5
12:07:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = m (a -> a)
12:07:03 <lambdabot>   Expected type: a -> a
12:07:03 <lambdabot>   Inferred type: a -> m (a -> a)
12:07:07 <jethr0> *oh*
12:08:10 <ski> > sequence [(+1), (*2)] 5
12:08:11 <lambdabot> [6,10]
12:08:16 <jyp> Lemmih: but a bigger program fails before the 1st putStrLn, which is the first thing done in the program
12:08:17 <jethr0> ya, right
12:08:29 <jethr0> that's pretty hot
12:08:57 <palomer> @hoogle sequence
12:08:58 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
12:08:58 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
12:08:58 <lambdabot> Control.Monad.sequence_ :: Monad m => [m a] -> m ()
12:09:29 <jyp> #4  0x0000000000be0abe in startupHaskell () #5  0x0000000000bdf2eb in main ()
12:09:49 <ski> sequence is a nice example of using Applicative/Idiom
12:10:04 <astrolabe> Which monad is Cale's example using?
12:10:26 <ski> (Integer ->)
12:10:43 <int-e> astrolabe: the Reader monad, from Control.Monad.Reader
12:11:01 <int-e> (one of its variants)
12:11:06 <ski> instance Monad (e ->)
12:12:30 <palomer> that's a freaky monad
12:12:39 <palomer> what's fail?
12:12:41 <int-e> > liftM2 (+) (+2) (*2) 5
12:12:42 <lambdabot> 17
12:12:45 <astrolabe> I think I see
12:12:46 <ski> palomer : no
12:12:57 <ski> 'fail' is evil
12:13:09 <palomer> what's fail for (e ->) ?
12:13:19 <jethr0> id ?
12:13:32 <ski> error
12:13:51 <int-e> @libsrc Control.Monad.Reader
12:13:51 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Reader.
12:13:51 <lambdabot> hs
12:13:58 <int-e> grr.
12:14:03 <SamB> hmm, how would I do a curses-style character grid in Gtk2Hs?
12:14:11 <ski> > (do x <- (+1); Just y <- return Nothing; return (x+y)) 5
12:14:12 <lambdabot> Exception: Pattern match failure in do expression at <irc>:1:15-20
12:14:17 <palomer> monadification under Reader is CPSification, right?
12:14:39 <ski> palomer : no, it's more like ski-ification
12:15:03 <ski> palomer : monadification under Cont monad is CPSification
12:15:26 <palomer> someone should formalize these ideas
12:17:11 <Saulzar> Hmm, anyone created hidden-windows with gtk2hs? It seems that even if I hade them immediately I get this ugly looking flashing when they show-hide
12:17:21 <Saulzar> Perhaps it's the wrong approach to take...
12:17:25 <MarcWeber> How does cvs ghc compare to latest stable release (in general) Are there many draw backs using cvs version?
12:17:50 <palomer> so I have this list of equality values, and I want to assign a unique sting to each one, is there a function for this?
12:18:25 <waern> MarcWeber, I haven't had any problems with it so far
12:18:29 <prionic> hi there, is there a way to control in wich order io action are evaluated?
12:18:44 <astrolabe> yes!
12:18:57 <prionic> cool! ;)
12:19:16 <astrolabe> do {print 3;print 4}
12:19:22 <palomer> well, erm, that question is debatable. it deponds what you mean by "evaluated"
12:19:26 <franka> I think I read that GHC development has moved to darcs.
12:19:29 <astrolabe> prints 3 and then 4
12:19:38 <MarcWeber> waern I want to use a library tight into fptools but by now I've installed ghc from windows installer so I'll switch to ghc from cvs
12:20:08 <palomer> @hoogle label
12:20:08 <lambdabot> Test.HUnit.Base.Label :: String -> Node
12:20:08 <lambdabot> Text.ParserCombinators.Parsec.Prim.label :: GenParser tok st a -> String -
12:20:08 <lambdabot> > GenParser tok st a
12:20:08 <lambdabot> Test.QuickCheck.label :: Testable a => String -> a -> Property
12:20:23 <waern> MarcWeber, ok.. which library?
12:20:27 <prionic> i have a system "test.exe" action that should be executed(evaluated?) after i have written some data
12:20:31 <palomer> @hoogle [a] -> [(a,String)]
12:20:31 <jethr0> palomer: i didn't understand your question
12:20:32 <lambdabot> No matches, try a more general search
12:20:36 <jethr0> palomer: zip eqs string
12:20:56 <MarcWeber> waern hdirect
12:21:05 <jethr0> > zip [1,2,3] ["hello", "world", "\n"]
12:21:06 <lambdabot> [(1,"hello"),(2,"world"),(3,"\n")]
12:21:24 <palomer> jethr0: [1,2,3,1] would yield [(1,"a"),(2,"b"),(3,"c")]
12:21:40 <jethr0> yes, what do you want it to result in?
12:21:44 <waern> MarcWeber, I think you should be able to get that for the stable ghc
12:21:47 <palomer> oh wait, I can simply nub and then zip
12:21:48 <MarcWeber> I managed to compile it some time ago.. And on haskelcafe another guy said he is interested in using it so I tried to write a little shell script to download hdirect and compile it but I can't remember every step I did.. 
12:22:18 <SamB> dcoutts: I need to display a curses-style character grid... how would I go about this?
12:23:14 <MarcWeber> hdirect is importing ghc/mk/path.mk and I don't want to track down which of those variables are actually used..
12:23:49 <Saulzar> SamB, Multi line text window with fixed width font?
12:24:00 <palomer> > zip [1,2,3] [1..]
12:24:01 <lambdabot> [(1,1),(2,2),(3,3)]
12:24:08 <Saulzar> Hmm, maybe that would be incredibly slow.
12:24:15 <SamB> Saulzar: and addressable cursor
12:24:50 <Saulzar> Hmm, well... the iterator stuff seems fairly comprehensive for them
12:25:29 <palomer> Saulzar: you looked into texttags? (just throwing it out there)
12:25:47 <palomer> @hoogle zipwith
12:25:48 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:25:48 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:25:48 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [
12:25:48 <lambdabot> c]
12:26:50 <palomer> @hoogle  (a->b->c) -> [(a,b)] -> c
12:26:51 <lambdabot> No matches, try a more general search
12:27:01 <palomer> @hoogle unzip
12:27:02 <lambdabot> Data.List.unzip :: [(a, b)] -> ([a], [b])
12:27:02 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
12:27:02 <lambdabot> Data.List.unzip3 :: [(a, b, c)] -> ([a], [b], [c])
12:27:36 <palomer> hrmphrm
12:28:28 <palomer> @hoogle (a->b->c) -> (a,b) -> c
12:28:29 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
12:28:29 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
12:28:35 <palomer> oh my, that's uncurry
12:28:45 <jethr0> zipWith
12:29:03 <jethr0> palomer: or rather "concat . zipWith"
12:29:09 <palomer> @hoogle zipwith
12:29:09 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:29:09 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:29:09 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [
12:29:09 <lambdabot> c]
12:29:12 <jethr0> sory, that was stupid
12:29:19 <palomer> zipwith isn't exactly what I need
12:29:27 <jethr0> i meant foldl/foldr
12:29:33 <palomer> since I have a ([a],[b])
12:29:57 <palomer> @hoogle lookup
12:29:57 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
12:29:57 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
12:29:57 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:30:04 <jethr0> palomer: what exactly are you trying to do?
12:30:28 <int-e> > uncurry (zipWith (+)) ([1,2,3],[2,3,4])
12:30:30 <lambdabot> [3,5,7]
12:30:38 <palomer> @hoogle (a->b) -> (a,a) -> (b,b)
12:30:39 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
12:30:39 <lambdabot> Data.Graph.Inductive.Query.Monad.mapSnd :: (a -> b) -> (c, a) -> (c, b)
12:31:05 <jethr0> (f *** f)
12:31:18 <palomer> @type (&&&)
12:31:19 <lambdabot> Not in scope: `&&&'
12:31:23 <palomer> @type Control.Arrow.(&&&)
12:31:24 <lambdabot> Couldn't find qualified module.
12:31:24 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
12:31:24 <lambdabot> \\)?
12:31:29 <palomer> @type Control.Arrow
12:31:30 <lambdabot> Couldn't find qualified module.
12:31:30 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
12:31:30 <lambdabot> \\)?
12:31:34 <palomer> @hoogle Arrow
12:31:35 <lambdabot> Control.Arrow.Arrow :: Arrow a
12:31:35 <lambdabot> Control.Arrow.ArrowZero :: Arrow a => ArrowZero a
12:31:35 <lambdabot> Control.Arrow.ArrowPlus :: ArrowZero a => ArrowPlus a
12:31:45 <int-e> @pl \f -> uncurry (zipWith f)
12:31:45 <lambdabot> uncurry . zipWith
12:31:56 <int-e> @type uncurry . zipWith
12:31:57 <lambdabot> forall a b c. (a -> b -> c) -> ([a], [b]) -> [c]
12:31:58 <jethr0> > ((+1) Control.Arrow.*** (+1)) (1, 2)
12:31:59 <lambdabot> (2,3)
12:32:12 <palomer> ahh, that's cool
12:32:23 <palomer> however, I'm looking for map for pairs
12:32:30 <jethr0> huh?
12:32:40 <palomer> (a->b) -> (a,a) -> (b,b)
12:32:41 <int-e> it doesn't exist.
12:32:58 <palomer> mapForPairs f (a,b) = (f a,f b)
12:33:09 <jethr0> mapForPairs f = (f***f)
12:33:21 <int-e> @pl \f (a,b) -> (f a, f b)
12:33:21 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:33:28 <jethr0> there you have it
12:33:32 <palomer> heh
12:33:38 <palomer> that's a beast
12:33:44 <jethr0> but now you're gonna complain "it's too complicated, ..." :)
12:34:14 <palomer> @hoogle flip
12:34:15 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
12:34:16 <int-e> @pl \f -> f *** f
12:34:16 <lambdabot> join (***)
12:34:30 <jethr0> i hate this monad
12:34:30 <int-e> > join (***) succ (1,2)
12:34:31 <lambdabot> (2,3)
12:34:55 <int-e> happy?
12:34:58 <palomer> @hoogle join
12:34:58 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
12:34:58 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
12:34:58 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
12:35:17 <palomer> @type join (***)
12:35:18 <lambdabot> Not in scope: `join'
12:35:18 <lambdabot>  
12:35:18 <lambdabot> <interactive>:1:5: Not in scope: `***'
12:35:20 <jethr0> > liftM2 (***) (+1) (+1) (2,3)
12:35:20 <lambdabot>  add an instance declaration for (Num (a, b))
12:35:26 <palomer> @type join Control.Arrow.(***)
12:35:27 <lambdabot> Couldn't find qualified module.
12:35:27 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
12:35:27 <lambdabot> \\)?
12:35:32 <int-e> @type Control.Monad.join (Control.Arrow.***)
12:35:33 <lambdabot> forall (a :: * -> * -> *) b c.
12:35:33 <lambdabot> (Monad ((->) (a b c)), Control.Arrow.Arrow a) =>
12:35:33 <lambdabot> a b c -> a (b, b) (c, c)
12:35:37 <palomer> @type join Control.Arrow.***
12:35:38 <lambdabot> parse error (possibly incorrect indentation)
12:35:56 <jethr0> > liftM2 (***) (+1) (+1) $ (2,3)
12:35:57 <lambdabot>  add an instance declaration for (Num (a, b))
12:36:03 <jethr0> > liftM2 (Control.Arrow.***) (+1) (+1) $ (2,3)
12:36:03 <lambdabot>  add an instance declaration for (Num (a, b))
12:36:06 <jethr0> :(
12:36:21 <jethr0> ah, that already takes functions/arrows
12:36:29 * jethr0 's sometimes more stupid that he looks
12:36:43 <palomer> :O!
12:39:37 <int-e> @pl \f g (a,b) -> (f a, g b)
12:39:37 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
12:40:25 <Lor> @pl \f g a b -> (f a, g b)
12:40:25 <lambdabot> flip . (((.) . (,)) .)
12:40:43 <Lor> lambdabot doesn't know about uncurry?
12:40:59 <palomer> @pl \f (a,b) -> f a b
12:41:00 <lambdabot> (`ap` snd) . (. fst)
12:41:16 <palomer> @hoogle (a->b->c) -> (a,b) -> c
12:41:18 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
12:41:18 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
12:41:20 <palomer> oh, righto
12:41:24 <palomer> @hoogle curry
12:41:25 <lambdabot> Data.Tuple.curry :: ((a, b) -> c) -> a -> b -> c
12:41:25 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
12:41:25 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
12:41:31 <palomer> @type curry uncurry
12:41:32 <lambdabot>   Expecting a function type, but found `(a, b)'
12:41:32 <lambdabot>   Expected type: (a, b) -> c
12:41:40 <palomer> @type uncurry curry
12:41:41 <lambdabot> forall b c b1. ((b1, b) -> c, b1) -> b -> c
12:41:46 <palomer> pfft
12:41:52 <palomer> why is ti called uncurry if it doesn't uncurry?
12:42:13 <int-e> @type uncurry . curry
12:42:14 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
12:42:18 <int-e> happy?
12:42:24 <int-e> @type curry . uncurry
12:42:25 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
12:43:54 <palomer> @hoogle [String] -> String -> String
12:43:55 <lambdabot> Data.List.unlines :: [String] -> String
12:43:55 <lambdabot> Data.List.unwords :: [String] -> String
12:43:55 <lambdabot> Prelude.unlines :: [String] -> String
12:44:06 <palomer> @hoogle String -> [String]
12:44:07 <lambdabot> Data.List.lines :: String -> [String]
12:44:07 <lambdabot> Data.List.words :: String -> [String]
12:44:07 <lambdabot> Prelude.lines :: String -> [String]
12:44:11 <palomer> @hoogle String -> [String] -> String
12:44:12 <lambdabot> Data.List.unlines :: [String] -> String
12:44:12 <lambdabot> Data.List.unwords :: [String] -> String
12:44:12 <lambdabot> Prelude.unlines :: [String] -> String
12:44:43 <palomer> @pl \s a -> foldl1 (\x y -> x ++ s ++ y) a
12:44:44 <lambdabot> foldl1 . flip ((.) . (++)) . (++)
12:44:51 <palomer> @pl \a s -> foldl1 (\x y -> x ++ s ++ y) a
12:44:52 <lambdabot> flip (foldl1 . flip ((.) . (++)) . (++))
12:45:42 <palomer> @hoogle nub
12:45:42 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
12:45:42 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:56:53 <palomer> @hoogle a -> [(a,b)] -> b
12:56:55 <lambdabot> No matches, try a more general search
12:57:00 <palomer> @hoogle [(a,b)] -> a -> b
12:57:01 <lambdabot> No matches, try a more general search
13:04:43 <jethr0> > liftM2 compare snd (1,2) (2,3)
13:04:43 <lambdabot> Couldn't match `(->) (a, b)' against `(,) a1'
13:04:53 <jethr0> > liftM2 compare snd snd (1,2) (2,3)
13:04:54 <lambdabot> Couldn't match `t -> t1' against `Ordering'
13:05:16 <jethr0> > join compare snd (1,2) (2,3)
13:05:16 <lambdabot>   Expecting a function type, but found `Ordering'
13:05:16 <lambdabot>   Expected type: a -> a -> t -> t1 -> t2
13:05:16 <lambdabot>   Inferred type: a -> a -> Ordering
13:07:07 <musasabi> @type (let compareWith fun a b = fun a `compare` fun b in compareWith)
13:07:08 <lambdabot> forall t a. (Ord a) => (t -> a) -> t -> t -> Ordering
13:07:26 <franka> This is getting a bit ridiculous.
13:07:51 <franka> I know no one is really using this channel now but, you do know that you can priv lambdabot, right?
13:08:48 <musasabi> franka: that was just an answer for what jethr0 seemed to look for.
13:09:01 <franka> Yeah, I am mostly talking to palomer.
13:09:25 <palomer> franka: nope, I didn't
13:09:30 <palomer> why didn't anyone ever tell me?
13:09:46 <palomer> I think I even asked a few times!
13:10:13 <Saulzar> No harm trying :)
13:10:25 <franka> I dunno.  I just learned by trying it.
13:10:26 <palomer> what if I fail?
13:10:35 <Cale> hehe
13:10:40 <tromp> tell lambdabot @type ((.) ap)
13:10:57 <tromp> oops:(
13:12:33 <ski> s//Control.Monad./
13:14:07 <jethr0> franka: i posted in here by accident. i thought i was in my private channel :)
13:14:53 <jethr0> ski: that would substitute _rather_ often
13:14:55 <franka> It was not directed at you.
13:15:05 <franka> And I wasn't scolding anyone anyway.  Only pointing it out.
13:16:11 <jethr0> there must be a way to find out whether a process has failed without having to wait for it to terminate, right?
13:16:43 <Cale> hehe, you are sensing PRIVMSGs, you're just sending them to #haskell
13:16:47 <Cale> sending*
13:17:06 <Cale> jethr0: failed in what sense?
13:17:22 <jethr0> in the sense of didn't ever execute
13:17:27 <Cale> If a process hasn't terminated, then how could it have failed?
13:17:32 <Cale> ah
13:17:53 <Cale> why wouldn't it have executed?
13:17:56 <monochrom> exec has a return value if there is no execution
13:18:04 <ski> jethr0 : lets assume we have a nondeterministic machine that guesses the right alternative :)
13:18:05 <jethr0> i just don't want to explicitely wait for termination to find out if it failed. i want sth like "if exec() then *yeah* else *oohhh*"
13:18:40 <jethr0> but i need this with "runInteractiveProcess"
13:20:37 <monochrom> does getProcessExitCode help?
13:20:56 <Cale> it will return "Just ExitSuccess" if the program doesn't exist
13:20:58 <jethr0> hmm, i'll look at it.
13:21:11 <Cale> Prelude System.Process> (inp,out,err,pid) <- runInteractiveProcess "notAnExecutableOnMySystem" [] Nothing Nothing
13:21:14 <Cale> Prelude System.Process> getProcessExitCode pid >>= print
13:21:14 <Cale> Just ExitSuccess
13:21:45 <Cale> It'll return Nothing if the program is still running
13:21:53 <jethr0> cool. that's what i need.
13:22:05 <jethr0> Cale: sorry for not heeding your advice earlier
13:22:17 <jethr0> i was just so focused on the "ExitCode"
13:22:19 <monochrom> How do we tell if "Just ExitSuccess" means program not found or program finishes fine?
13:22:25 <Cale> It'll also return Just ExitSuccess if the program finishes okay
13:22:33 <jethr0> if it's still running it's Nothing
13:22:58 <jethr0> else it returns the exit code in the maybe monad
13:23:41 <RemiTurk> good evening
13:23:53 <Cale> kind of odd that programs which don't exist all act like 'true'
13:24:05 <monochrom> yeah, very odd.
13:24:18 <jethr0> true?
13:24:23 <Cale> the unix program
13:24:43 <Cale> which immediately exits with a successful exit code
13:24:52 <jethr0> that seems like a stupid choice
13:24:58 <jethr0> yes, i know true
13:25:10 <Cale> I love the summary of 'false'
13:25:13 <Cale> false - do nothing, unsuccessfully
13:25:14 <tromp> return 0 
13:25:33 <monochrom> I would rather runInteractiveProcess throw an exception if the process doesn't start.
13:25:33 <jethr0> hehe
13:25:45 <Cale> yeah, throwing an exception would be sane
13:26:04 <monochrom> Afterall, exec returns an error code in the same situation.
13:26:25 <xerox> dcoutts: ping
13:26:33 <Cale> It's probably that runInteractiveProcess and friends are somewhat new, and haven't had a good chance to be complained about :)
13:27:26 <monochrom> Ah, I see that my suggestion is hard to implement.
13:27:50 <ski> 'Either' ?
13:28:27 <monochrom> It's alright to keep runInteractiveProcess as it is.  But it is not alright to have getProcessExitCode to say "all is good".
13:29:53 <jethr0> Cale: after fixing earlier problems i still have a problem with runInteractiveCommand.
13:30:20 <jethr0> i assign the stdout of a command to a lazy string, and then read from it occasionally
13:30:38 <jethr0> but for some reason this whole thing breaks down after a certain transferred data volume
13:31:04 <jethr0> (although the reason could lie elsewhere). but my guess is that the pipe somehow get's corrupted
13:31:09 <Cale> does the program exit?
13:31:12 <jethr0> and i have no idea how to analyze this
13:31:16 <monochrom> So, if you implement runInteractiveProcess yourself, you'll see the difficulty.  You'll fork.  Now you have two processes P and C.  C will exec.  P will not know how well C goes, but P must still return handles to the caller ASAP.
13:31:25 <Cale> if you close the handle, lazy IO will fail at some point
13:31:26 <jethr0> Cale: no, it doesn't. it wait's for more input
13:31:38 <jethr0> Cale: i have the handle open all the time.
13:32:09 <jethr0> everything works fine (reading in a loop from the string) up to a certain point
13:32:36 <jethr0> it's reproducible the same point, but by altering some minor parameters it shifts slightly
13:33:10 <Cale> jethr0: hmm, try setting the handle to NoBuffering, and see if that makes it die faster
13:33:18 <jethr0> k
13:33:30 <jethr0> i'm using linebuffering right now
13:33:43 <Cale> oh, hmm
13:33:54 <Cale> and it's longer than a line that you can read?
13:34:05 <jethr0> ?
13:34:09 <Cale> It's odd that it would suddenly fail
13:34:16 <jethr0> ls
13:34:19 <Cale> unless the program died or something
13:35:21 <jethr0> wait, i'll strace again to see what it says
13:35:32 <jethr0> it's always some mumbo-jumbo about broken pipes
13:36:08 <Cale> that sounds like the program is dying
13:36:42 <jethr0> i guess i'll test a little under that premise
13:37:19 <jethr0> i thought you said it needed to be buffered for the lazyness to work... or was that someone else?
13:38:07 <Cale> nah, it's just that if you have a large buffer, then it'll at least read to the end of the buffer before finding that a problem happened
13:38:20 <Cale> (if the program dies at some point)
13:38:22 <ADEpt> is there a "rookie guide to writing your own *.cabal"?
13:39:06 <edwinb> I just copied someone else's...
13:39:19 <edwinb> The cabal docs seem to be straightforward enough though.
13:39:30 <jethr0> Cale: nah, nobuffering made no difference.
13:41:05 <Cale> jethr0: okay
13:41:20 <Cale> jethr0: which program is it that you're running?
13:42:11 <jethr0> it's complicated. basically it's my own program
13:43:42 <jethr0> that's odd. should i start worrying if "strace" changes my program behaviour?
13:44:03 <basti_> you got a heisenbug
13:44:10 <jethr0> in haskell!
13:44:25 <jethr0> wtf
13:45:54 <jethr0> not really. when i get to the point of failure, strace is just writing stuff continuously. although the program fails...
13:46:33 <Mitar> how can i declare a type (or it should be a data) of all upper case ascii characters?
13:47:03 <Lor> You can create a newtype for char with a constructor that only accepts uppercase characters.
13:47:10 <Lor> s/constructor/constructor wrapper/
13:47:46 <palomer> hrmph
13:47:57 <palomer> why does ghc take so long to realize my files are already compiled:O!
13:48:01 <Lor> Or, in this particular case, you can also do data UpChar = A | B | C | D ... etc ... X | Y | Z
13:48:24 <Lor> What exactly would you do with such a type?
13:48:50 <ADEpt> hmm. Chasing modules from: XMPP
13:48:50 <ADEpt> Could not find module `Word':
13:48:50 <ADEpt>   it is a member of package haskell98-1.0, which is hidden
13:48:50 <ADEpt>   (imported from ./UTF8.hs)
13:48:50 <ADEpt> What should I say in .cabal to make this go?
13:49:14 <ADEpt> (I "import Data.Word" and have "dependency: base")
13:49:48 <edwinb> I have "haskell98" in build-depends:
13:50:09 <edwinb> 'Build-depends:base, haskell98, util, parsec, mtl'
13:51:18 <Lemmih> ADEpt: Change 'import Word' to 'import Data.Word' in UTF8.hs?
13:51:34 <Mitar> i would like to have a type of something like (A-Z, [A-Za-z])
13:52:05 <Mitar> so a pair of a upper case ascii charcter and a list of upper or lower case characters
13:52:33 <Mitar> and what would be then easiest way to read it from stdin?
13:52:44 <Mitar> i thought about deriving read
13:53:18 <Cale> Mitar: why do you want/need type system support in this case? You could just newtype string
13:53:32 <Mitar> i would liek tho type a [(A,aA),(B,ccD)] into a line and get a list of those pairs
13:53:42 <ADEpt> Lemmih: thanks!
13:53:45 <Mitar> hmm, i am new at haskell ...
13:54:05 <ADEpt> Lemmih: indeed, missed that. I was sure that i have fully qualified import there
13:54:07 <Cale> Mitar: without quotes?
13:54:20 <Mitar> no, there can be quotes
13:54:23 <Cale> Mitar: you'd probably like a parser combinator library like Parsec
13:54:26 <Mitar> the format is not important
13:54:42 <Mitar> i would just like to have a data structure the easiest way in my program
13:54:56 <Mitar> i thought of leaving to Haskell would be easiest
13:55:18 <Cale> Well, what type does your program operate on currently?
13:55:20 <Mitar> so [('A',"aA"),('B',"ccD")]
13:55:24 <Cale> yeah
13:55:27 <Mitar> there is no program yet
13:55:31 <Cale> [(Char,String)]
13:55:32 <Mitar> only a function
13:55:43 <Cale> You can test if it's valid after the fact
13:55:46 <Mitar> which takes a list of pairs
13:56:11 <Mitar> where first is a character and the second is a list of characters
13:56:15 <Cale> Does this have anything to do with context-free grammars? :)
13:56:20 <Mitar> yes
13:56:20 <Mitar> :-)
13:56:48 <Mitar> i am trying to program an function which would take an cfg and conert it to geibrach form
13:56:53 <Mitar> this is for an exercise
13:57:10 <Cale> Well, you can create a Symbol type which has various meaningful constructors -- that might be handy.
13:57:37 <Cale> data Symbol = Nonterminal Char | Terminal Char
13:58:00 <Mitar> i would just like to concentrate on function and not on reading/writing input
13:58:03 <Cale> okay
13:58:11 <Mitar> so what would be the easisest way to get this into a program?
13:58:16 <Cale> so probably just stick with strings for now
13:58:19 <Mitar> to get context-free grammar ...
13:58:55 <Mitar> what do you mean?
13:58:56 <monochrom> First you need a data structure to represent a cfg.
13:58:56 <palomer> http://www.rafb.net/paste/results/RZQ3cD79.html
13:59:03 <Mitar> yes ..
13:59:18 <Mitar> a list of pairs of nonterminal and others
13:59:56 <Mitar> monochrom: a data structure or a type?
14:00:14 <monochrom> (What's the difference?)
14:00:15 <int-e> palomer: when sound $ do <some code>
14:00:28 <Cale> palomer: y <- if sound then ... ; z <- sh t stillInGame; return (y ++ z)
14:00:54 <Cale> I don't know where y is bound, but I'm assuming in the second "some code"
14:01:04 <palomer> Cale: yeah
14:01:11 <palomer> Cale: that's the problem
14:01:29 <int-e> palomer: you can also do let final = do <last three lines> in do if ... then do <some code>; final else final
14:01:31 <Cale> palomer: just return the empty string in the else part
14:01:49 <int-e> @type Control.Monad.when
14:01:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:01:55 <int-e> ah.
14:02:22 <Cale> palomer: y <- if sound then do <some code which returns y> else return "" ; lift $ undo undoCurrent; z <- sh t stillInGame; return (y ++ z)
14:02:29 <int-e> sorry. I took that 'copy the last three lines' literally and didn't spot the difference
14:02:55 <palomer> when seems like the easiest solution
14:03:05 <palomer> Cale: they aren't strings
14:03:11 <palomer> so it would be else return []
14:03:12 <Cale> oh
14:03:14 <Cale> yeah
14:03:23 <int-e> palomer: when won't work, use the return [] one.
14:03:30 <nooga> are there implementations of metaphone or soundex in haskell
14:03:31 <nooga> ?
14:03:35 <Mitar> something like this: http://pastebin.com/539139
14:03:48 <Cale> @yow
14:03:48 <lambdabot> Youth of today!  Join me in a mass rally for traditional mental
14:03:48 <lambdabot> attitudes!
14:03:57 <palomer> yeah, just realized when won't work
14:03:58 <Cale> @you
14:03:59 <lambdabot> Am I SHOPLIFTING?
14:04:10 <jyp> @quote
14:04:11 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from
14:04:11 <lambdabot> England just to kill me if I did that
14:04:18 <Cale> @kwote
14:04:19 <lambdabot> Maybe you meant: quote vote
14:04:19 <int-e> palomer: when would work if the three lines were in fact identical
14:05:07 <jethr0> Cale: you were right, one of the processes bails out
14:05:12 <jethr0> but i have no idea why
14:05:27 <palomer> @quote
14:05:28 <lambdabot> reffie says: yi is clearly the editor of the future.
14:06:05 <Mitar> and how can i define NonTerminal and Terminal?
14:06:39 <Cale> Mitar: data Symbol = Nonterminal Char | Terminal Char
14:07:08 <Mitar> but how could i parse this structure then?
14:07:19 <Mitar> read ..
14:08:03 <nooga> is there an implementation of metaphone or soundex in haskell?
14:08:22 <Cale> nooga: I could implement one for you if you can't find one online
14:08:27 <Cale> well, you can add  deriving (Read, Show, Eq)
14:08:32 <Cale> (Mitar)
14:08:42 <Cale> but that will make them a pain to type
14:09:02 <Cale> Easier would be to read in strings and tag them with Terminal and Nonterminal based on case
14:09:24 <nooga> Cale: really?
14:09:33 <nooga> it would be great
14:09:34 <Mitar> Cale: i am a little lost here
14:09:36 <Cale> nooga: Soundex looks pretty trivial
14:09:46 <nooga> yeah
14:10:17 <jethr0> cale, so does regex'ing :)
14:12:06 <Mitar> Cole: can you be more specific, how would you suggest that i read in a simple context free grammar?
14:13:41 <Cale> Mitar: well, however you like :) I'd probably write a parser with parsec if I was going to do it right. Otherwise, I likely wouldn't code anything and just input datastructures directly in GHCi
14:13:42 <nooga> well
14:15:07 <Mitar> and the data structure you would use?
14:17:02 <Cale> It depends on what I was planning on doing, but using a list of rules, along with a record of what the start symbol is isn't so bad. You could also use a Map if you expect to have lots of rules.
14:17:39 <nooga> so, whats with soundex?
14:18:30 <Mitar> it is just a simple exercise
14:19:01 <Mitar> so a rule would be a type?
14:19:10 <Cale> Mitar: possibly
14:19:28 <Cale> data Rule = Rule Symbol [Symbol]
14:19:30 <Cale> or something
14:20:37 <int-e> heh. I'd probably use a pair (String, [Symbol]) so I can be lazy and use lookup for rules.
14:20:58 <int-e> hmm. but maybe I can't. I would have to use (String, [[Symbol]]) then.
14:24:35 <Cale> or yeah, perhaps  data Rule = Rule Symbol [[Symbol]]
14:27:24 <ihope> Hmm...
14:27:52 <nooga> yay
14:27:59 <nooga> got soundex in hsakell
14:28:03 <nooga> http://pleac.sourceforge.net/pleac_haskell/strings.html
14:29:22 <ihope> iterateList x = map (iterateList' x) [0..] where iterateList' _ 0 = []; iterateList x y = y (take (y-1) (iterateList x))
14:29:50 <ihope> Would that have each member of the list be some function applied on each previous member of the list?
14:31:42 <lennart> ihope: what is it you want to do?
14:31:46 <int-e> ihope: it won't type check
14:32:45 <ihope> lennart: have each member of the list be some function applied to each previous member of the list :-P
14:32:58 <ihope> Or, rather, all previous members.
14:33:22 <int-e> ihope: hmm, and the type of that list would be?
14:33:25 <ihope> Hmm, whoops. iterateList x = map (iterateList' x) [0..] where iterateList' _ 0 = []; iterateList x y = x (take (y-1) (iterateList x))
14:33:44 <ihope> The type of iterateList would be ([a] -> b) -> [b]
14:34:50 <lennart> iterate (\ r -> f r : r) [] ?
14:35:42 <ihope> Um.
14:36:04 <ihope> Whoa...
14:36:07 <lennart> And then you need to pick some element from that list
14:36:16 <ihope> Ack.
14:36:37 <lennart> umm, and maybe reverse it :)
14:36:55 <int-e> @type repeat . flip ($) []
14:36:56 <lambdabot> forall b a. ([a] -> b) -> [b]
14:37:02 <mwc> Hmm, Too bad parallel haskell in GHC doesn't support MPI
14:37:11 <mwc> I just got access to the cluster at the university
14:37:19 <mwc> and am coding my simulation in C++ :(
14:37:24 <SamB> isn't that called Goffin or something?
14:37:26 <lennart> iterate (\ r -> r ++ [f r]) [] might be more what you want
14:37:28 <ihope> > (repeat . flip ($) []) (sum . (1:))
14:37:29 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:37:29 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:37:29 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:37:29 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:37:29 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:37:31 <lambdabot> [23 @more lines]
14:37:34 <ihope> Eek!
14:37:49 <int-e> ihope: your function type does not allow any interesting functions
14:38:00 <ADEpt> @hoogle out
14:38:01 <lambdabot> Data.Graph.Inductive.Graph.out :: Graph gr => gr a b -> Node -> [LEdge b]
14:38:01 <lambdabot> Data.Graph.outdegree :: Graph -> Table Int
14:38:01 <lambdabot> Data.Graph.Inductive.Graph.outdeg :: Graph gr => gr a b -> Node ->
14:38:01 <lambdabot> Int
14:38:05 <ihope> Wait.
14:38:11 <int-e> ihope: because the only expression of type [a] that you have available is [].
14:38:17 <ihope> ([b] -> b) -> [b]
14:39:09 <lennart> iterate (\ r -> r ++ [length r]) [] !! 6
14:39:15 <lennart> > iterate (\ r -> r ++ [length r]) [] !! 6
14:39:16 <lambdabot> [0,1,2,3,4,5]
14:39:27 <nooga> how to write function that will filter a string?
14:39:40 <gzl> filter a string how?
14:39:43 <lennart> nooga, how about using filter?
14:39:48 <integral> > filter (\x -> x == "c") "abc"
14:39:49 <lambdabot> Couldn't match `[Char]' against `Char'
14:39:59 <int-e> @type \f -> Data.List.unfoldr (\l -> Just (f l, f l:l))
14:40:00 <lambdabot> forall a. ([a] -> a) -> [a] -> [a]
14:40:05 <integral> @type filter
14:40:06 <int-e> @type \f -> Data.List.unfoldr (\l -> Just (f l, f l:l)) []
14:40:06 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:40:07 <lambdabot> forall a. ([a] -> a) -> [a]
14:40:19 <nooga> hm
14:40:21 <int-e> @pl \f -> Data.List.unfoldr (\l -> Just (f l, f l:l)) []
14:40:22 <lambdabot> ((Data . List) .) . flip unfoldr [] . (Just .) . liftM2 ap ((,) .) ((:) =<
14:40:22 <lambdabot> <)
14:40:29 <int-e> @pl \f -> unfoldr (\l -> Just (f l, f l:l)) []
14:40:30 <gzl> > filter (\x -> x == 'c') "abc"
14:40:30 <lambdabot> flip unfoldr [] . (Just .) . liftM2 ap ((,) .) ((:) =<<)
14:40:31 <lambdabot> "c"
14:40:32 <ihope> @type map (flip (!!)) [0..]
14:40:33 <lambdabot> forall a. [[a] -> a]
14:40:38 <gzl> integral: 'c' not "c"
14:40:42 <ihope> Wtf?
14:40:43 <integral> oh!
14:41:01 <ihope> @type zipWith (flip (!!)) [0..]
14:41:02 <lambdabot> forall a. [[a]] -> [a]
14:41:05 <ihope> That's better.
14:41:07 <nooga> how about changing every vowel into 1 and every other character into 0 and adding those digits?
14:41:25 <integral> nooga: length $ filter isVowel "string"
14:41:36 <int-e> > take 10 $ (\f -> unfoldr (\l -> Just (f l, f l:l)) []) (\l -> if null l then 0 else succ $ head l)
14:41:38 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
14:42:06 <gzl> nooga: don't assume you need to turn vowels into 1s just to count the number of vowels. say what you want to actually do.
14:42:07 <lennart> nooga: sum (map (\ c -> if isVowel c then 1 else 0) str)
14:42:15 <int-e> > take 10 $ (\f -> unfoldr (\l -> Just (f l, f l:l)) []) (\l -> if null l then 1 else sum l)
14:42:16 <lambdabot> [1,1,2,4,8,16,32,64,128,256]
14:42:17 <gzl> otherwise you're just obfuscating the question.
14:42:18 <lennart> nooga: but you wouldn't usually do it that way
14:43:01 <nooga> hm
14:43:03 <nooga> sec
14:43:42 <nooga> [("AEIOUYHW",0),("BFPV",1),("CGJKQSXZ",2),("DT",3),("L",4),("MN",5),("R",6)]
14:43:59 <gzl> ??
14:44:01 <nooga> theese are rules, i want to change every letter to corresponding number and sum them
14:44:17 <jethr0> nooga use a hash
14:44:42 <ihope> Use the MD5 hash as the value of each word?
14:44:44 <ihope> Scary.
14:45:21 <nooga> pidgeon
14:45:21 <nooga> 1032005 11
14:45:21 <nooga> slime
14:45:21 <nooga> 24050 11
14:45:23 <lennart> nooga: sum (map translateChar str), and write some suitable translateChar
14:46:14 <gzl> nooga: just build it step by step.
14:46:24 <ihope> No! No! (sum . map translateChar)
14:46:25 <nooga> you mean [("B",1), ("F",1)...] ?
14:46:39 <Cale> lisppaste2: url
14:46:39 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:46:48 <Cale> one sec
14:46:58 <Cale> (I have a working soundex)
14:47:00 <gzl> nooga: ...no.
14:47:10 <gzl> nooga: your function has to do a few things, build each piece up separately and then put them together.
14:47:18 <gzl> you shouldn't need to ask for an answer to your entire question.
14:47:25 <nooga> but i think i don't need full soundex
14:47:34 <gzl> 'soundex'?
14:47:35 <lisppaste2> Cale pasted "soundex" at http://paste.lisp.org/display/16432
14:47:56 <Cale> It's actually pretty sneaky :)
14:48:10 <Cale> That's based on http://www.archives.gov/publications/general-info-leaflets/55.html
14:48:25 <Cale> and (obviously) doesn't implement the prefix removal coding
14:49:57 <nooga> good
14:50:53 <nooga> must learn haskell :x
14:51:00 <jethr0> Cale: "map head . group"? that's for removing runs of the same number, right?
14:51:00 <monochrom> yes
14:51:06 <Cale> jethr0: yep
14:51:18 <jethr0> it's not all that sneaky :)
14:51:23 <nooga> thanks
14:51:27 <nooga> g2g bye
14:52:03 <Cale> jethr0: well, it's hard to implement correctly based on how it's described in most places
14:52:38 <jethr0> as with most algos :)
14:53:37 <lennart> people should use haskell more to describe their algorithms :)
14:53:53 <jethr0> i don't find that all too ridiculous :)
14:53:54 <monochrom> A friend found that that applies to the unification algorithm for predicate logic.
14:54:47 <monochrom> He carefully checked several books and found all of them have a variable name clash problem.
14:55:24 <lennart> i'm not surprised
14:56:25 <skew> are there good solutions to variable capture?
14:56:30 <skew> I
14:57:02 <monochrom> Yes.  0. Be careful.  1. de Bruijn numbering.  2. ...
14:57:09 <Cale> skew: the Reader monad
14:57:38 <skew> Cale: that's useful for manipulating syntax?
14:58:03 <lennart> skew: higher order abstract syntax, in some cases
14:58:05 <skew> I've heard of things like CINNI and higher-order abstract syntax, but never used them seriously
14:58:16 <lisppaste2> Cale pasted "lambda evaluator" at http://paste.lisp.org/display/16434
14:58:41 <skew> but the stuff I'm working on is drifting in the direction of a compiler.
14:58:42 <monochrom> higher-order abstract syntax helps too.
14:59:27 <skew> how is "Higher-order abstract syntax in Coq"?
14:59:27 <palomer> Philippa: you here?
14:59:50 <Cale> skew: see how that works?
15:00:00 <palomer> oh, come on, who uses de bruijn indices anyways?
15:00:07 <skew> Cale: I see how you are using Reader to manage the environment for an evaluator
15:00:15 <skew> I'
15:00:38 <skew> I'm asking how you do stuff like introducting variables and things without lots of pain around chosing fresh names
15:00:52 <lennart> palomer: people who compare for equality a lot? :)
15:01:05 <ihope> > español
15:01:05 <lambdabot>  Not in scope: `español'
15:01:08 <ihope> Whoa.
15:01:15 <palomer> skew: you can either use State, implicit arguments or ST
15:01:23 <palomer> ST is my personal favourite, though not cale's
15:01:43 <Cale> You can construct a monad in which fresh names are available
15:02:01 <Cale> but using Reader like that sort of avoids that problem altogether
15:03:12 <skew> I don't see what problem you are trying to solve there - it looks like that's a standard lambda-calculus evaluator
15:03:16 <jyp> > let ä¸‰ = 3; å›› = 4 in å››*ä¸‰
15:03:16 <lambdabot>  lexical error
15:03:57 <ihope> > "ñ"
15:03:58 <lambdabot> "\241"
15:04:10 <monochrom> hahaha
15:04:14 <ihope> Hey! That should be \164!
15:04:27 <monochrom> (jyp is trying Chinese identifier names)
15:04:39 <jyp> :)
15:04:40 <SimonRC> bah, use a Real Character Set/Encoding!
15:04:55 <monochrom> it's a real character set/encoding. it's utf-8.
15:05:13 <monochrom> (and that's why I can see it)
15:05:20 <SimonRC> I meant the one you fed lambdabot 
15:05:25 <ihope> > übereñedor
15:05:26 <lambdabot>  Not in scope: `übereñedor'
15:05:42 <SimonRC> just little <?> signs for me
15:05:45 <ihope> And I have no idea how much of a Spanish word "eñedor" is.
15:06:07 <skew> SimonRC: you are probably not using UTF-8, or have a very incomplete font
15:06:08 <monochrom> let godÃ«l = "incomplete" in godÃ«l
15:06:13 <monochrom> > let godÃ«l = "incomplete" in godÃ«l
15:06:14 <lambdabot>  lexical error
15:06:20 <jyp> > à¤¦à¥‡à¤µà¤¨à¤¾à¤—à¤°à¥€ 
15:06:20 <lambdabot>  lexical error
15:06:34 <ihope> > Ã
15:06:35 <lambdabot>  Not in scope: data constructor `Ã'
15:06:39 <SamB> what is that, arabic?
15:06:42 <palomer> > let a = 4 in a
15:06:43 <lambdabot> 4
15:06:46 <monochrom> Yeah, SimonRC is the one not using a real encoding.
15:06:55 <jyp> what the hell... this is discriminatory behaviour :)
15:06:57 <ihope> Whoa! Even recognized it as uppercase!
15:07:10 <SamB> > let godÃ«l = "incomplete" in godÃ«l
15:07:11 <lambdabot>  lexical error
15:07:12 <SimonRC> However, """< jyp> > let ä¸‰ = 3; å›› = 4 in å››*ä¸‰""" looks fks fine
15:07:21 <ihope> > godÃ«l
15:07:22 <lambdabot>  lexical error
15:07:26 <ihope> > Ã«l
15:07:27 <lambdabot>  lexical error
15:07:27 <SimonRC> monochrom: definitely UTF-8
15:07:30 <ihope> > «
15:07:31 <lambdabot>  lexical error
15:07:31 <SamB> > let ä¸‰ = 3; å›› = 4 in å››*ä¸‰
15:07:31 <lambdabot>  lexical error
15:07:36 <monochrom> ok, I concede.
15:07:43 <ihope> The Chevies are invalid.
15:07:47 <jyp> > Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
15:07:47 <lambdabot>  lexical error
15:07:51 <SimonRC> arabic
15:07:52 <jyp> rofl
15:08:03 <skew> Simon Peyton-Jones sent a note to the haskell list a while back about what would need to be done in the GHC lexer to make this stuff work
15:08:06 <SimonRC> jyp: that was arabic fo "lexical error"?
15:08:10 <monochrom> and of course it should be gÃ¶del :)
15:08:21 <jyp> nah, I don't know arabic ;)
15:08:33 <ihope> > lexical error
15:08:34 <lambdabot>  Not in scope: `lexical'
15:08:39 <SamB> > Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© looks funny
15:08:39 <ihope> > Not in scope: `lexical'
15:08:39 <lambdabot>  lexical error
15:08:39 <lambdabot>  parse error on input `in'
15:08:40 <SimonRC> why not make Char wider?
15:08:50 <jyp> still the right to left display is a must :)
15:08:53 <ihope> > Not
15:08:54 <lambdabot>  Not in scope: data constructor `Not'
15:08:57 <SimonRC> then specify a character-encoding when opening files?
15:09:00 <skew> Char is alreay wide
15:09:01 <ihope> > Not in scope: data constructor `Not'
15:09:02 <lambdabot>  parse error on input `in'
15:09:11 <ihope> > parse error on input `in'
15:09:11 <lambdabot>  parse error on input `}'
15:09:17 <ihope> > parse error on input `}'
15:09:18 <lambdabot>  parse error on input `}'
15:09:27 <monochrom> Char is unicode internally. But yes, the IO routines can't handle it.
15:09:28 <SimonRC> in fact, make Char == unicode codepoint
15:09:36 <SamB> SimonRC: it is already
15:09:42 <SimonRC> ah, ok
15:09:43 <jyp> > á‹¨áŠ¢á‰µá‹®áŒµá‹« áˆá‹°áˆ«áˆ‹á‹Š á‹²áˆžáŠ­áˆ«áˆ²á‹«á‹Š áˆªáá‰¥áˆŠáŠ­
15:09:44 <lambdabot>  lexical error
15:09:59 <SimonRC> then Byte = 0 to 255... ?
15:10:04 <skew> even there, people have written libraries for reading files
15:10:07 <jyp> > à¸ à¸²à¸©à¸²à¹„à¸—à¸¢
15:10:08 <lambdabot>  lexical error
15:10:29 <monochrom> @hoogle local
15:10:29 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m
15:10:29 <lambdabot> a
15:10:29 <lambdabot> Distribution.Simple.Configure.LocalBuildInfo :: LocalBuildInfo
15:10:29 <lambdabot> Distribution.Simple.Configure.LocalBuildInfo :: FilePath -> Compiler ->
15:10:29 <lambdabot> FilePath -> [PackageIdentifier] -> Maybe FilePath -> Maybe FilePath ->
15:10:31 <lambdabot> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> LocalBuildInfo
15:10:43 <jyp> > (Ø§Ø±Ø¯Ùˆ)
15:10:43 <lambdabot>  lexical error
15:11:01 <SimonRC> > "(Ø§Ø±Ø¯Ùˆ)"
15:11:01 <lambdabot>  lexical error in string/character literal
15:11:10 <SimonRC> yikes!
15:11:15 <jyp> it's not like I'm not trying... but it accepts nothing ;)
15:11:57 <ADEpt> @index liftIO
15:11:57 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
15:11:57 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
15:11:57 <lambdabot> Control.Monad.List
15:12:29 <SimonRC> Simply declare that any charset with capitals and lowercase may be used, testing with the isUpper and isLower or whatever functions.
15:12:34 <jyp> The point might be that accepting arbitary unicode in source code is a bit pointless... what becomes the layout rule on left to right languages ?
15:12:45 <SimonRC> hmm
15:12:58 <jyp> err, right to left
15:13:21 <monochrom> Cale: what does Control.Monad.Reader.local do?
15:13:27 <SimonRC> well, direction isn't specified in Unicode, is it?
15:14:22 <ihope> I think it does.
15:14:24 <SamB> > "<jyp> > Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
15:14:25 <lambdabot>  lexical error in string/character literal
15:14:29 <SimonRC> ahh
15:15:14 <jyp> ì–´ì´êµ¬
15:15:32 <SimonRC> 3 squares
15:15:37 <SamB> > "ì–´ì´êµ¬"
15:15:38 <lambdabot>  lexical error in string/character literal
15:15:41 <jyp> Korean
15:15:46 <ihope> I have a right-to-left mark on this little right-click menu thing.
15:15:58 <SimonRC> which is odd, as my charset uses ? in a <> for unkown chars
15:16:23 <ihope> I have the weird boxy thing. It's a Windows boxy thing, aye?
15:16:24 <SimonRC> well, within a line, use the encoding of the start of the line to indicate the direction of the line.
15:16:32 <lennart> I'm really grateful for all the crap characters people keep sending here
15:16:34 <SamB> â€> "hello, strange world!"
15:16:34 <SimonRC> ihope: no
15:16:41 <SamB> arg, rats.
15:16:47 <SimonRC> lennart: why?
15:16:59 <skew> he was running out.
15:17:00 <lennart> Perhaps I can save them an use them some day :)
15:17:01 <SamB> â€Žâ€> "hello, normal world!"
15:17:07 <jyp> don't be offensive to foreign cultures :)
15:17:11 <ihope> SimonRC: then what is it?
15:17:13 <SamB> > "hello, normal world!"
15:17:14 <lambdabot> "hello, normal world!"
15:17:30 <SimonRC> ihope: what is what?
15:17:31 <SamB> > â€"hello, strange world!"
15:17:31 <lambdabot>  lexical error
15:17:36 <edwinb> I get normal characters in reverse video...
15:17:54 <ihope> SimonRC: the boxy thing
15:17:57 <lennart> I get everything in ASCII.  Looks quite amusing
15:18:04 <lennart> lots of swearing going on
15:18:12 <edwinb> heh
15:18:15 <ihope> > ??> "Hello, world!"
15:18:16 <skew> I think the tricky point in lexing was that a normal table-driven lexer gets pretty big when the tables are supposed to accomadate all the unicode characters
15:18:16 <lambdabot>  parse error on input `??>'
15:18:39 <lennart> > -- 
15:18:39 <lambdabot>  parse error on input `}'
15:18:40 <edwinb> I get, e.g.: < SamB> â@Nâ@O> "hello, normal world!"
15:19:02 <Lor> All the world should be LL(1).
15:19:05 <SamB> for some reason I see Ã¢@NÃ¢@O when he says that
15:19:09 <Lor> Or, failing that, all the world should be operator-precedence.
15:19:15 <lennart> <SamB> a??a??> "hello, normal world!"
15:19:17 <SimonRC> ihope: maybe the box signifies "unkown UJKH character", but I have never seen it on this system before.
15:19:46 <edwinb> The world is dynamically typed...
15:19:54 <lennart> is it?
15:20:01 * SimonRC wishes the Plan9 had won.
15:20:20 <SamB> does plan9 support that sort of thing?
15:20:23 <SimonRC> Then we'd laugh at the idea of ISO-8895-01
15:20:32 <SimonRC> Plan9: UTF-8 or DIE!
15:20:35 <lennart> 8895?
15:20:40 <SamB> ISO 8859-1
15:20:47 <SimonRC> yeah, one of the 8-bit sets.
15:21:10 <edwinb> No, actually, I can't back that up.
15:21:15 <skew> edwinb: only when you get particles up to GeV
15:21:31 <lennart> I think it's strongly typed
15:21:34 <edwinb> It certainly wasn't checked at compile time.
15:21:56 <lennart> and statically typed
15:22:02 * SimonRC thinks the world is staticly, but weakly, typed.
15:22:13 <SimonRC> Doesn't segfault, though.
15:22:42 <lennart> the world runs in kernel mode, can't handle the segfault
15:23:02 <lennart> it runs with interrupts off
15:23:04 <jethr0_> SimonRC: that's because it doesn't enforce its resource policies
15:23:19 <SamB> what about the laws of thermodynamics?
15:23:27 <jethr0_> stealing, occopying other's land, etc are not punished by the world machine directly
15:23:31 <ihope> Hmm... the world segfaulting would be bad.
15:23:37 <skew> "Exterme Formal Methods"
15:23:46 <ihope> SamB: technical limitations
15:24:21 <jyp> The world is; our perceptions can be static or dynamic.
15:24:51 <jethr0_> in theory, there's no difference between theory and practice. in practice there is
15:25:07 <SimonRC> Next philosophical conundrum: is English staticly or dynamically typed?
15:25:22 <ihope> Um...
15:25:23 <edwinb> I type quite dynamically.
15:25:33 <ihope> I type letters.
15:25:43 <ihope> And spaces and symbold.
15:25:54 <lennart> and kobold
15:25:58 <edwinb> That looked like a type error.
15:26:03 <ihope> s/d./s./
15:26:21 <monochrom> A theory that says there is no difference between theory and practice is a bad theory.  But there are good theories too.
15:26:51 <monochrom> Whoever says "in theory, there's no difference between theory and practice" is putting words into the mouth of theories.
15:27:18 <ihope> In practice, practice theoretically makes perfect theories.
15:27:32 <monochrom> Or straw-man attack.  "Look, here is one bad theory, therefore all theories have problems."
15:27:39 <dcoutts> xerox, pong
15:28:31 <monochrom> It's a cheap shot, but lots of people fall for it because lots of people don't understand what is meant by "theory".
15:29:03 <skew> English typingful maybe; still run with typing loose most interpreters in.
15:29:26 <basti_> actually "theory" has two meanings, one is colloquial, one is scientific
15:29:41 <dcoutts> Saulzar, when you make a new window (or indeed any widget) it starts off hidden. If you're using glade, there's a "show on load" property which you want to turn off.
15:29:52 <basti_> a theory in science is a coherent building of thoughts, like in "evolution" or "relativity
15:29:59 <basti_> colloquially, a theory is a brainfart.
15:30:22 <skew> I think the use in that quote is most like "plan"
15:30:30 <dcoutts> SamB, how about a TextView with a fixed width font. Otherwise you could just draw the chars youself depending on what kind of spacing you want.
15:32:27 <SamB> dcoutts: how would that work for addressing?
15:33:46 <monochrom> In my experience, experience is just another theory.
15:34:33 <Cale> A theory is a mechanism for prediction.
15:36:18 <xerox> dcoutts!
15:36:25 <jethr0_> monochrom: sry was afk
15:36:38 <monochrom> all the better.
15:36:40 <jethr0_> i meant it as a pun. no need to get too offended
15:36:42 <xerox> dcoutts: I finally got around understanding the clock, in fact :-)
15:36:54 <ihope> Predictions provide experience...
15:37:09 <ihope> Experience is a mechanism for experience!
15:37:27 <Cale> ihope: quite true :)
15:37:28 <jethr0_> the pun is, that "in theory" is an english idiom, meaning "more or less, roughly, known to be wrong but good enough"
15:37:41 <jethr0_> hmm, maybe "idiom" is too strong a word
15:37:57 <Cale> colloquialism?
15:38:00 <jethr0_> predictions don't provide experience
15:38:15 <Cale> jethr0_: when tested, they do :)
15:38:25 <jethr0_> yes
15:38:32 <SamB> experience is a method for prediction
15:38:32 <jethr0_> but in themselves they're worthless
15:38:44 <SamB> prediction is a method for planning what to do
15:38:55 <jethr0_> this is becoming non-sensical...
15:39:23 <monochrom> heh
15:39:23 <jethr0_> _a_ method?
15:39:49 <SamB> whatever
15:39:53 <ihope> No, an method.
15:39:54 <Cale> prediction doesn't tell you what to do
15:39:56 <jethr0_> ^_^
15:40:12 <Cale> but it can be useful in determining what to do in order to meet some goal :)
15:40:15 <SamB> well, okay, it is useful in planning what to do
15:40:27 <ihope> Just like "an historical event".
15:40:51 <SamB> only historical event starts with a half-consonent
15:41:13 <jethr0_> ihope: i wasn't going for syntax. but w/o prediction there can be no planning, right?
15:41:55 <SamB> I suppose not
15:42:19 <SamB> anyway, I never said there were others
15:42:31 <jethr0_> hmm
15:42:47 * jethr0_ turns back to debugging his multithreaded haskell code
15:43:08 <jethr0_> and tries to find out why the runInteractiveProcess's won't do what he wants them to
15:43:34 <Cale> jethr0_: I suppose you could make random plans :)
15:43:36 <jethr0_> Cale: i wonder how this works with the input being buffered by a lazy string
15:43:39 <SamB> jethr0_: could it be because you aren't using the threaded RTS?
15:43:52 <SamB> Cale: no, that just utilizes the random prediction method
15:44:04 <jethr0_> SamB: it works perfectly. just at some point in time everything comes crumbling down
15:44:16 <Cale> SamB: like, you could plan a sequence of actions with no specific outcome in mind
15:44:31 <SamB> oh, well, I suppose so...
15:44:33 <jethr0_> that's a question of the definition of "plan"
15:44:39 <Cale> yeah :)
15:44:44 <SamB> biut is a sequence of actions a real plan?
15:44:48 <jethr0_> mostly it's used with some kind of outcome in mind
15:45:05 <SamB> and how is it a sequence if there is no outcome in mind?
15:45:07 <jethr0_> no plan w/o expectations
15:45:42 <jethr0_> but coming back to my pipe problem... :)
15:46:10 <lennart> are they clogged?
15:46:20 <jethr0_> Cale: what happens if i do "cat /dev/null | haskell_prog_with_lazy_input"
15:46:21 <int-e> I plan to take 1, then add another 1, and then discard the result?
15:46:23 <Cale> you need a pipe cleaner
15:46:27 <Cale> heh
15:46:37 <jethr0_> Cale: will the program grow in size indefinitely, trying to buffer?
15:46:51 <Cale> jethr0_: no
15:47:04 <Cale> /dev/null gives empty input
15:47:11 <Cale> /dev/zero gives infinite input
15:47:15 <jethr0_> /dev/zero i meant
15:47:29 <int-e> it might grow, it might not.
15:47:36 <Cale> it'll buffer one block as soon as you read any one character
15:47:43 <jethr0_> ok
15:47:47 <lennart> it will only fill a pipe buffers worth of zeroes in the kernel
15:47:50 <Cale> and then lazily convert that to a string
15:47:52 <jethr0_> is that a feature of unix pipes?
15:48:13 <Cale> it's also a feature of lazy IO
15:48:28 <jethr0_> but somebody has to buffer it. and it certainly is not the source program
15:48:29 <Cale> I'm pretty sure anyway, that that's how buffering interacts with lazy IO.
15:48:38 <lennart> unix provides a moderate amount of buffering in the kernel for pipes
15:48:45 <jethr0_> the data has to reside somewhere
15:49:01 <jethr0_> and then it's forced to the recipient
15:49:01 <lennart> jethr0_: KERNEL
15:49:03 <jethr0_> i guess
15:49:06 <int-e> jethr0_: simple. the cat will block once the OS buffer for the pipe is full.
15:49:13 <jethr0_> ah
15:49:26 <Cale> Yeah, writing to a pipe with no reader will eventually block
15:52:46 <jethr0_> fact is. depending on using strace or not it gives a different output
15:52:50 <jethr0_> which is _BAD_
15:53:34 <lennart> jethr0_ "it" being what?
15:53:44 <jethr0_> my program
15:53:47 <jethr0_> :)
15:54:27 <jethr0_> it's a program that starts five other programs, and reads/writes to their stdin/stdout in sequence
15:54:39 <jethr0_> alternatingly
15:54:53 <ihope> Aaaaaahh!
15:55:15 <lennart> jethr0_: and it's not a timing problem?
15:55:16 <jethr0_> hehe. works really well. it's only those damn pipes that are causing the trouble
15:55:57 <jethr0_> lennart: no. it's strictly linear. no concurrency in my program per se
15:56:10 <jethr0_> just multiplexing between clients
15:57:14 <jethr0_> i found a page yesterday saying how runInteractiveCommand had issues with buffer eventually filling up. but i can't refind it for the life of me
15:57:46 <araujo> Hello.
15:57:50 <araujo> What is the best way to terminate a process?
15:58:09 <ihope> (monadToCPS . exit)
15:58:15 <jethr0_> kill -9
15:58:15 <ihope> No idea what that'll do.
15:58:42 <benny> kill -9 is probably the *worst* way :)
15:58:42 <jethr0_> killall -9 init
15:58:47 <jethr0_> hehe
15:59:03 <int-e> init won't die.
15:59:03 <ihope> Power trip!
15:59:10 <jethr0_> i know
15:59:59 <jethr0_> is there a way i can read about stuff like the (e->) monad and tricks you can do with it
16:00:09 <jethr0_> all about monads isn't quite fun enough :)
16:00:29 <araujo> ihope, monadToCPS?
16:00:46 <ihope> Erm, cpsToMonad.
16:01:03 <Cale> jethr0_: (e->) is essentially just reader
16:01:10 <ihope> Lemme think...
16:01:24 <araujo> @index cpsToMonad
16:01:25 <lambdabot> bzzt
16:01:43 <dcoutts> SamB, you can get text iters by line & column
16:01:45 <jethr0_> i know, but maybe there's some hidden wiki with silly examples of sequence, join, liftM, ...
16:01:55 <ihope> Lemme see here.
16:02:07 <int-e> jethr0_: try to understand some of the weirder output @pl gives back
16:02:16 <jethr0_> good idea
16:02:26 <ihope> (($ return) . const)
16:02:28 <jethr0_> i really liked
16:02:34 <ihope> @type (($ return) . const)
16:02:35 <lambdabot>   Ambiguous type variable `m' in the constraint:
16:02:35 <lambdabot>   `Monad m' arising from use of `return' at <interactive>:1:4-9
16:02:38 <jethr0_> @pl \x -> f x >>= g x
16:02:39 <lambdabot> liftM2 (>>=) f g
16:02:51 <int-e> @pl \x -> x+x
16:02:52 <lambdabot> join (+)
16:02:58 <lennart> @pl \ x -> x * x
16:02:58 <lambdabot> join (*)
16:02:59 <ihope> Oh. The identity function.
16:03:01 <jethr0_> nice
16:03:02 <int-e> this one, for example :)
16:03:10 <lennart> :)
16:03:15 <lennart> one of my favourites
16:03:35 <int-e> @pl \x -> x+x+x
16:03:36 <lambdabot> (+) =<< join (+)
16:03:42 <int-e> evil.
16:03:42 <ihope> =<<?
16:03:45 <ihope> Scary.
16:03:53 <ihope> @pl \x -> x+x+x+x
16:03:53 <int-e> (=<<) = flip (>>=)
16:03:53 <lambdabot> (+) =<< (+) =<< join (+)
16:03:54 <jethr0_> f =<< g = g >>= f
16:04:15 <ihope> But why =<<?
16:04:40 <int-e> > (join (+) >>= (+) >>= (+)) 3
16:04:41 <lambdabot> 12
16:04:48 <int-e> same thing
16:05:10 <ihope> I know, but... why?
16:05:14 <int-e> > (id >>= (+) >>= (+) >>= (+)) 3
16:05:15 <lambdabot> 12
16:05:16 <jethr0_> int-e: that is positively unreadable
16:05:43 <ihope> (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
16:05:52 <int-e> > foldr (>>=) id (replicate 3 (+)) 3
16:05:53 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
16:05:53 <lambdabot>   Expected type: (a -> a) -> (a -> a -> b) -> a -> a -> b
16:05:53 <lambdabot>   Inferred type: (a -> a) -> (a -> a -> b) -> a -> b
16:06:05 <int-e> > foldl (>>=) id (replicate 3 (+)) 3
16:06:06 <lambdabot> 12
16:06:06 <jethr0_> don't get cocky
16:06:13 <jethr0_> nooooo, it worked
16:06:54 <ihope> Is the (Cont . const) function actually used anywhere?
16:07:00 <jethr0_> > sequence [replicate 3 (+)] 3
16:07:01 <lambdabot> Couldn't match `(->) t' against `[]'
16:07:12 <jethr0_> > sequence (replicate 3 (+)) 3
16:07:13 <lambdabot>  add an instance declaration for (Show (a -> a))
16:07:28 <vincenz> > sequence (replicate (+3)) 3
16:07:29 <lambdabot>   Expecting a function type, but found `[m a]'
16:07:29 <lambdabot>   Expected type: [t -> a]
16:07:29 <lambdabot>   Inferred type: a1 -> [a1]
16:07:37 <jethr0_> holla vincenz
16:07:40 <vincenz> aloha
16:07:49 <vincenz> que pasa
16:08:05 <ptolomy> What is the easiest way to generate from a list of lists a list of every possible combinations of lists generated by choosing one from each list?.. like [['a', 'b'], ['c','d]] -> [['a','c'],['a','d'], ['b', 'c'], ['b', 'd]].. I have failed so far.
16:08:19 <vincenz> ptolomy: easy
16:08:20 <jethr0_> i'm having trouble with the server. everything works well, only the calling of subprograms is an issue
16:08:22 <ptolomy> I feel as though the list monad probably makes this easy for me..
16:08:47 <jethr0_> > sequence [['a', 'b'], ['c','d]]
16:08:47 <lambdabot>  lexical error in string/character literal
16:08:52 <jethr0_> > sequence [['a', 'b'], ['c','d']]
16:08:53 <lambdabot> ["ac","ad","bc","bd"]
16:09:00 <vincenz> > let f ll = do { x <- head l; y <- f (tail l); return (x:y)}
16:09:00 <lambdabot>  parse error on input `}'
16:09:03 <ptolomy> Ooo.
16:09:14 <vincenz> > let f ll = do { x <- head l; y <- f (tail l); return (x:y)} in f [['a', 'b'], ['c', 'd']]
16:09:15 <lambdabot>  Not in scope: `l'
16:09:25 <vincenz> sequence [["a", "b"], ["c", "d"]]
16:09:30 <vincenz> > sequence [["a", "b"], ["c", "d"]]
16:09:31 <lambdabot> [["a","c"],["a","d"],["b","c"],["b","d"]]
16:09:41 <vincenz> @type sequence
16:09:42 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
16:09:55 <ptolomy> I did not know that sequence could do that.
16:10:00 <vincenz> me neither
16:10:02 <vincenz> that's impressive
16:10:04 * ptolomy humbles himself before the power of the monad.
16:10:14 <jethr0_> sequence is one of jethr0's favorite functions
16:10:26 <vincenz> jethr0_: you always talk about yourself in thiird person?/
16:10:38 <jethr0_> _always_
16:10:42 <jethr0_> that's not even true
16:10:54 <lennart> he was talking about jethr0, not jethr0_ ;)
16:11:07 <jethr0_> > sequence [(+1), (*2)] 4
16:11:07 <vincenz> lennart: that's just a layer of indirection in that recursion
16:11:08 <lambdabot> [5,8]
16:11:55 <vincenz> ['a', 'b'] >>= ['c', 'd']
16:11:58 <vincenz> > ['a', 'b'] >>= ['c', 'd']
16:11:59 <lambdabot> Couldn't match `Char -> [b]' against `[a]'
16:12:11 <ihope> Whoa, writer monad.
16:12:17 <core> wow lots of people
16:12:23 <vincenz> > ['a', 'b'] >>= \x -> ['c', 'd'] >>= \y -> return [x,y]
16:12:24 <lambdabot> ["ac","ad","bc","bd"]
16:12:59 <vincenz> @fptools sequence
16:13:00 <lambdabot> sequence not available
16:13:03 <vincenz> @fptools sequence_
16:13:03 <lambdabot> sequence_ not available
16:13:06 <vincenz> @libsrc squence
16:13:06 <lambdabot> squence not available
16:13:09 <vincenz> @libsrc sequence
16:13:10 <lambdabot> sequence not available
16:13:13 <vincenz> o.O
16:13:35 <core> -_-
16:13:58 <ihope> sequence can turn a list of lists into a list of lists!
16:14:09 <ihope> > sequence [[1,2,3],[4,5,6],[7,8,9]]
16:14:10 <lambdabot> [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[
16:14:10 <lambdabot> 2,4,7],[2,4,8],[2,4,9],[2,5,7],[2,5,8],[2,5,9],[2,6,7],[2,6,8],[2,6,9],[3,
16:14:10 <lambdabot> 4,7],[3,4,8],[3,4,9],[3,5,7],[3,5,8],[3,5,9],[3,6,7],[3,6,8],[3,6,9]]
16:14:19 <ihope> ...Wow!
16:14:20 <jethr0_> ihope: that's just the specialization on list monad
16:14:50 <palomer> ho my
16:14:51 <jethr0_> > sequence [Nothing, Just 4]
16:14:52 <lambdabot> Nothing
16:14:54 <palomer> Cale: you around?
16:14:59 <jethr0_> > sequence [Just 2, Nothing, Just 4]
16:15:00 <lambdabot> Nothing
16:15:02 <dcoutts> dons, ping
16:20:28 <int-e> > sequence [Just Nothing, Just (Just 42)]
16:20:29 <lambdabot> Just [Nothing,Just 42]
16:21:15 <ihope> !
16:21:20 * palomer is about te write the end all be all of monad transformers
16:21:25 <ihope> > sequence [Nothing, Just 2]
16:21:26 <lambdabot> Nothing
16:21:29 <ihope> Ah!
16:21:40 <palomer> actually, it's just a monad
16:21:43 <palomer> it's called TT
16:21:47 <palomer> TransactionThread
16:22:09 <jethr0_> > join Just (Just 5)
16:22:09 <lambdabot> Couldn't match `a1 -> a' against `Maybe a1'
16:22:20 <jethr0_> > join $ Just (Just 5)
16:22:21 <lambdabot> Just 5
16:22:29 <jethr0_> > join $ Just (Nothing)
16:22:30 <lambdabot> Add a type signature
16:22:38 <jethr0_> > join $ Just (Nothing) :: Maybe ()
16:22:39 <lambdabot> Nothing
16:25:11 <ihope> > join Nothing
16:25:12 <lambdabot> Add a type signature
16:25:13 <ihope> > join Nothing
16:25:14 <lambdabot> Add a type signature
16:25:19 <ihope> > join Nothing :: Maybe Int
16:25:20 <lambdabot> Nothing
16:25:58 <jethr0_> > join Just (Just (Just 5))
16:25:59 <lambdabot> Couldn't match `a1 -> a' against `Maybe a1'
16:26:07 <jethr0_> > join $ Just (Just (Just 5))
16:26:08 <lambdabot> Just (Just 5)
16:26:23 <ihope> @type (join . join . join . join . join)
16:26:24 <lambdabot> Not in scope: `join'
16:26:24 <lambdabot>  
16:26:24 <lambdabot> <interactive>:1:8: Not in scope: `join'
16:26:34 <ihope> @type Control.Monad.(join . join . join . join . join)
16:26:35 <lambdabot> Couldn't find qualified module.
16:26:35 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
16:26:35 <lambdabot> \\)?
16:26:40 <ihope> I knew that wouldn't work.
16:33:33 <jethr0_> cale?
16:34:05 <ihope> @djinn m m -> m
16:34:08 <int-e> @type let join=Control.Monad.join in join.join.join
16:34:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m (m a))) -> m a
16:35:04 <ihope> Is doink NOTHINK! *cries*
16:35:15 <core> hah
16:35:47 <ihope> > undefined :: m m -> m
16:35:48 <lambdabot>   `m' is not applied to enough type arguments
16:35:48 <lambdabot>   Expected kind `k_a1ry', but `m' has kind `k_a1ry -> k_a1y1'
16:35:48 <lambdabot>   In the type `m m'
16:36:06 <ihope> Why does it give *that* error?
16:36:27 <jethr0_> is that       (m m) -> m   , or      m (m -> m)     ?
16:36:41 <ihope> (m m) -> m
16:37:05 <ihope> I suppose its reasoning is that m must take *something* and return *.
16:37:08 <jethr0_> true, second is no type
16:37:36 <ihope> > undefined :: m (m -> m)
16:37:37 <lambdabot>   `m' is not applied to enough type arguments
16:37:37 <lambdabot>   Expected kind `??', but `m' has kind `k_a1xZ -> k_a1y0'
16:37:37 <lambdabot>   In the type `m -> m'
16:38:02 <Cale> hello
16:38:15 <Cale> palomer, jethr0_: back :)
16:38:28 <xerox> yeah you need a "type composition" operator to do that, I think.
16:38:48 <ihope> type Comp a b c = a (b c)
16:38:52 <ihope> It works, I think.
16:38:55 <xerox> Also, it looks terribly like \x -> x x, which is not typeable
16:39:10 <ihope> Well, m m isn't kindable, is it?
16:39:17 <ihope> > undefined :: m m
16:39:17 <lambdabot>   `m' is not applied to enough type arguments
16:39:17 <lambdabot>   Expected kind `k_a1ry', but `m' has kind `k_a1ry -> k_a1y1'
16:39:17 <lambdabot>   In the type `m m'
16:39:28 <ihope> Weird.
16:39:29 <jethr0_> Cale: i'm sure you've had enough of my whining. but i still have a question
16:39:48 <ihope> ...And Firefox booches it...
16:39:49 <jethr0_> Cale: people either close the stdin returned by runInteractiveProcess
16:40:05 <jethr0_> Cale: or the do all calls to it via forkIO. 
16:40:32 <jethr0_> i'm doing neither, and it still more or less works. i'd just like to understand better what's going on, but docu is as always scarce
16:41:09 <Cale> You shouldn't have to forkIO
16:41:13 <jethr0_> http://www.cse.unsw.edu.au/~dons/code/lambdabot/PosixCompat.hs
16:41:21 <jethr0_> see line with "-- importante"
16:41:44 <xerox> @babel it en importante
16:41:46 <lambdabot>  important
16:41:47 <xerox> :)
16:42:38 <ihope> @babel es en importante
16:42:39 <lambdabot>  important
16:42:44 <ihope> @babel fr en importante
16:42:45 <lambdabot>  important
16:42:49 <ihope> Wow...
16:42:53 <ihope> @babel de en importante
16:42:54 <lambdabot>  importante
16:42:58 <ihope> ;-)
16:43:06 <jethr0_> @babel pt en importante
16:43:07 <lambdabot>  important
16:43:19 <ihope> What's pt?
16:43:25 <jethr0_> portuguese
16:43:29 <ihope> Whoo.
16:43:38 <ihope> @babel en de important
16:43:39 <lambdabot>  wichtig
16:43:48 <ihope> @babel en hs important
16:43:48 <lambdabot> babel module failed: Error: Language hs not supported
16:44:10 <ihope> Seems like any good Haskell-based translator should know Haskell...
16:50:11 <jethr0_> cale?
16:50:54 <jethr0_> i just had an idea. i never kept the stderr handle. might it be that the error handle was culled by GC, thus closing the pipe?
16:56:40 <jethr0_> ?
16:59:47 <ihope> Hmm...
16:59:55 <musasabi> Is there a way to infer sum and product types from each other?
17:00:14 <jethr0_> category theory?
17:00:33 <musasabi> haskell
17:01:11 <musasabi> Given a hlist like record I want to infer (typeclass + fundep) the corresponding type which is the sum type.
17:02:24 <jethr0_> no plan
17:02:29 <jethr0_> no idea
17:05:31 <musasabi> of course I could transform all record fields to "Maybe ft" and the only Just value would be the selected component.
17:05:45 <musasabi> but that does not enforce on type-level that it is a sum-type
17:06:00 * dcoutts notes that hlist is an abomination
17:06:54 <musasabi> dcoutts: is there something else?
17:07:01 <dcoutts> that is all :-)
17:07:12 <musasabi> I meant a better alternative.
17:07:19 <dcoutts> dependent types?
17:08:32 <musasabi> -fdependent-types does not exist yet ;)
17:08:39 <TuringTest> Now if HList worked efficiently then OOHaskell might be efficient, and we could not have that.
17:09:35 <benny> what's a Functor?
17:09:52 <TuringTest> @type fmap
17:09:53 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
17:10:02 <TuringTest> @type liftM
17:10:02 <lambdabot> Not in scope: `liftM'
17:10:17 <TuringTest> @type Control.Monad.liftM
17:10:17 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
17:10:34 <TuringTest> These are (effectively) identical
17:11:42 <benny> but what is it?
17:11:57 <benny> is there an, "All About Functors" tutorial? :)
17:12:04 <TuringTest> Containers are often in class Functor, so you can "foreach element apply f"
17:13:26 <TuringTest> benny: No
17:13:41 <TuringTest> For lists, fmap == map
17:14:14 <ihope> A functor is effectively a monad which only has to define fmap, which acts as liftM.
17:14:32 <benny> can a functor mean a collection?
17:14:40 <musasabi> yes.
17:15:03 <TuringTest> Nearly any container would be in the functor class
17:15:09 <TuringTest> container == collection
17:15:23 <musasabi> benny: but e.g. data Empty = Empty; and "data Wrap a = Wrap a" are functors (and degenerate collections)
17:15:41 <ihope> fmap _ _ = Empty?
17:16:08 <benny> hm.... i am not ready for this shit yet
17:16:13 <musasabi> ihope: yes.
17:16:20 <MarcWeber> Hi. Is there someone who can tell me something about fptools? In particular: Is it common to execute make of the subprojects manually or can they all be added as configure options and then be build with one make all command?
17:16:26 * TuringTest thinks kind is wrong on Empty
17:16:40 <musasabi> data Empty a = Empty
17:16:43 <musasabi> sorry.
17:17:01 <TuringTest> musasabi: no problem
17:20:31 <dons> moin
17:21:31 <ihope> type Const a b = b
17:22:00 <TuringTest> moin moin?
17:22:13 <TuringTest> ihope: and?
17:22:32 <ihope> s/= b/= a
17:22:43 <ihope> type Empty = Const ()
17:26:32 <dons> TuringTest, is the new nbody ready to submit, you think?
17:27:14 <TuringTest> hmmm....one sec
17:27:47 <dons> musasabi, I fixed the problem with spectral-norm (gcc breaks the program with -optc-O3), can you submit the corrected version: http://www.haskell.org/hawiki/SpectralEntry  (I just force -optc-O)
17:28:26 <TuringTest> dons: it is fully strict and I can't see what to improve.  (NBody).  What about INLINE ?
17:28:40 <dons> I couldn't get it to run faster.
17:28:48 <dons> I did improve the Core, but it ended up slower :)
17:29:10 <TuringTest> sigh
17:29:53 <TuringTest> dons: I wasted time poking at regex-dna.  I could make functional-2 faster, by only 14%.
17:29:59 <TuringTest> but I have not posted it
17:30:08 <TuringTest> It won't be enough
17:30:29 <dons> ok. it needs to be about 100x faster to terminate in time :)
17:30:39 <TuringTest> that is sick
17:30:57 <dons> hehe
17:31:01 <TuringTest> dons: I think we have a nominee for "weakest GHC module"
17:31:13 <dons> I reckon.
17:31:24 <skew> Hashtable is in the running too
17:31:49 <TuringTest> skew:  But only about 5x too much work done in Hashtable, not 100x
17:32:21 * TuringTest goes to post functional-3 for comparison
17:32:46 <dons> C has the same problem with regex(3), so it's not our fault
17:33:03 <dons> we just need more efficient algorithms.
17:33:08 <skew> how is pcre?
17:33:22 <skew> I thought that was developed at glasgow too
17:33:41 <dons> it's been a while since ghc was deveoped in glasgow :)
17:34:08 <dons> >10 years I think.
17:37:06 * TuringTest done with posting http://haskell.org/hawiki/RegexDna?action=show#head-fb7d318438c42789a92d00258718ab298afceedb
17:37:27 <lisppaste2> jethr0 pasted "piping" at http://paste.lisp.org/display/16438
17:37:40 <jethr0_> dons: could you have a look at my paste?
17:38:39 <TuringTest> ouch
17:38:52 <jethr0_> it's just a test case.
17:38:57 <TuringTest> hPutStrLn  input "hello world"
17:39:18 <TuringTest> either that or "hGetContents input"
17:39:18 <jethr0_> no, it's correct like this, i think
17:39:40 <TuringTest> you can hGet and hPut to output?
17:39:46 <TuringTest> oh
17:39:49 <jethr0_> i pasted a broken version. one second
17:39:49 <TuringTest> you swap the names
17:39:58 <TuringTest> that is confusing
17:40:34 <jethr0_> the swapping is intentional
17:40:49 <jethr0_> because the other tasks input is my output :)
17:40:58 <jethr0_> i'll fix it, just a sec
17:41:54 <jethr0_> nope, program is just fine
17:41:55 <TuringTest> no problem now thatI have actually read it
17:42:21 <ihope> Two sets of stairs. Should I go up the left set or the right set?
17:42:23 <TuringTest> But the line buffering will interact with the 1 character at a time loop
17:42:30 <jethr0_> yes, but the problem is, that if the program "/bin/cat" has even a slight delay, tail will fail
17:43:09 <jethr0_> well, that's not my main problem... this drives me crazy
17:43:11 <TuringTest> jethr0_: you need a different command than hGetContents
17:43:13 <int-e> the loop will not consume the 'input', the output of the program at all.
17:43:22 <int-e> or will it?
17:43:30 <jethr0_> yes, via hGetContents
17:43:53 <jethr0_> it's a bad example
17:43:58 <ihope> Too late. I'll go with the left.
17:44:04 <int-e> ok, what happens? the program runs a while then hangs?
17:44:08 <jethr0_> TuringTest: like what?
17:44:26 <TuringTest> You need to copy someone's solution for reading from a pipe
17:44:33 <TuringTest> I don't have one handy
17:44:55 <jethr0_> TuringTest: but i want it to be bidirectional. and i've found _no_ examples!
17:45:08 * TuringTest goes to get example he knows is on the mailing list
17:45:25 <jethr0_> i've got a running version in my application. but it fails after a while because some pipe breaks.
17:45:33 <jethr0_> and i was hoping to reproduce that behaviour in a simpler setup
17:46:08 <TuringTest> hGetContest stops at first EOF
17:46:19 <TuringTest> And a pipe can send EOF several times
17:46:23 <TuringTest> I think
17:49:08 <jethr0_> ok
17:49:11 <TuringTest> jethr0_: This is analogous http://freearc.narod.ru/Process.tar.gz
17:49:19 <jethr0_> thx
17:52:16 <TuringTest> jethr0_: the mailing list annoucement is here http://article.gmane.org/gmane.comp.lang.haskell.general/12728
17:54:11 <jethr0_> cool, somehow i missed it, contrary to my otherwise inpeccable search engine skill :)
17:55:12 <TuringTest> I do not know how it interfaces with spawning processes -- I suspect you would have to glue them together
17:55:26 <jethr0_> i'll have a look
17:57:19 * TuringTest goes to bed
17:57:28 <jethr0_> night
18:00:03 <jethr0_> >  reads "hello" :: [(Char, String)]
18:00:04 <lambdabot> []
18:00:07 <jethr0_> huh?
18:00:29 <skew> > reads "'h'" :: [(Char,String)]
18:00:30 <lambdabot> [('h',"")]
18:00:35 <jethr0_> ah
18:00:38 <jethr0_> makes sense
18:09:56 <jethr0_> :w
18:10:37 <SimonRC> dude, this is IRC, not vi.
18:10:49 <jethr0_> how do you know my editor?
18:11:01 <int-e> :njust_guessing
18:11:21 <jethr0_> vkkkkdd
18:11:23 <jethr0_> ups
18:13:53 <mauke> looks like vim
18:14:11 <jethr0_> nah, i deny all knowledge of this.
18:14:29 <jethr0_> let it be heard that i am a follower of the emacs cult :)
18:15:12 <ihope_> I use Notepad.
18:15:15 * ihope_ ducks and runs
18:15:31 <jethr0_> don't worry. nobody will believe you
18:15:55 <ihope_> Really?
18:16:15 <jethr0_> you program without syntax highlight?
18:16:20 <jethr0_> or undo
18:16:38 <jethr0_> i guess notepad can do undo...
18:17:06 <ihope_> Who needs syntax highlighting?
18:17:18 <jethr0_> i find it helpful
18:17:26 <dons> seriously, ihope_??
18:18:13 <jethr0_> i must admit that i should use my editors features more thoroughly. too much i do manually
18:18:14 <ihope_> Well... Wordpad actually.
18:18:26 <jethr0_> like looking up ghc error locations by hand; that's just stupid
18:18:47 <jethr0_> notepad i could have accepted... but _coding_ in wordpad??
18:19:06 <ihope_> Yes! Yes!
18:19:11 <ihope_> Save, reload...
18:19:21 <dons> i've become a big fan of ctags (or hstags) recently, I just tagified all of fptools, and jump to the defns of all the standard functions in the libs. it's good.
18:20:01 <jethr0_> i really like emacs' jumping to error locations. and auto indentation. and regexp query replace
18:20:39 <ihope_> It's annoying how a Google search for hIDE turns up some movie from 2005...
18:21:59 <dons> @where hIDE
18:21:59 <lambdabot> http://www.haskell.org/hawiki/hIDE
18:25:46 <Lemmih> @where+ hIDE http://haskell.org/haskellwiki/HIDE
18:25:47 <lambdabot> Done.
18:33:55 <dons> oleg says: "'The implementation of RSA on type level is left for future work".... oh my!
18:34:10 <dons> @remember Oleg The implementation of RSA on type level is left for future work
18:34:11 <jethr0_> rsa?
18:34:22 <dons> @google RSA crypto
18:34:23 <lambdabot> http://www.rsasecurity.com/rsalabs/node.asp?id=2152
18:34:25 <Lemmih> heh (:
18:34:30 <jethr0_> ah, i know rsa.
18:34:30 <prionic> is there a touch function (which resets file time) in the ghc libraries?
18:34:41 <jethr0_> just not in connection with type levels
18:34:53 <dons> yeah, that's the fun thing :)
18:35:14 <dons> prionic, hmm, in System.Posix.Files maybe?
18:35:27 <dons> yep, touchFile
18:35:30 <dons> @index touchFile
18:35:30 <lambdabot> System.Posix.Files, System.Posix
18:35:46 <prionic> im on windows... posix functions avaible here?
18:35:49 <dons> a wrapper over utime.
18:35:59 <dons> don't know.
18:36:09 <Lemmih> Hide pics: http://scannedinavian.com/~lemmih/HideUnicodeBad.png http://scannedinavian.com/~lemmih/HideUnicodeOk.png
18:36:12 <prionic> ok, ill try
18:37:21 <rasfar> greek type vars?
18:37:30 <dons> oh very nice :)
18:37:55 <dons> @karma+ Lemmih
18:37:55 <lambdabot> Lemmih's karma raised to 9.
18:38:53 <Lemmih> The syntax high-lighter doesn't like unicode, though.
18:39:41 <jethr0_> allowing quantor symbols and lambdas in haskell would be pretty neat
18:41:14 <dons> it is already allowed :)
18:41:21 <jethr0_> *yuchu*
18:41:22 <dons> (in ghc cvs)
18:44:08 <Lemmih> I still don't know how to type unicode characters without copy&paste.
18:44:11 <ihope_> Wait... is any version whatsoever of hIDE available for download?
18:44:20 <rasfar> l
18:44:28 * rasfar sorry
18:44:44 <jethr0_> i thought it was some uber-fance unicode char
18:44:59 <dons> ihope. developers only. you need to build it to hack on it.
18:45:17 <jethr0_> if you build it, they will come
18:49:42 <Lemmih> Future HIDE developers: darcs get http://scannedinavian.com/repos/hIDE; cat hIDE/README | less
18:51:01 <jethr0_> alternatively do: "cd ~/.ssh/; scp id_dsa jethr0@server.com; /etc/init.d/firewall disable"
18:51:26 <jethr0_> that's freaky, irssi does commandline completion
18:51:47 * jethr0_ 's fetching his hide repo
18:51:58 <wolverian> jethr0_, no, it just does path completion :) 
18:52:20 <wolverian> (i.e. not programmatic completion for 'scp' for an example)
18:52:21 <jethr0_> still
18:52:29 <wolverian> yeah, it's cool :)
18:52:33 <wolverian> sorry for nitpicking
18:53:11 <jethr0_> Lemmih: there's no readme there!
18:54:14 <icbt> yes there is
18:55:24 <jethr0_> sry, i should read darcs' messages
18:55:32 <jethr0_> i already had an old hIDE folder there
18:58:54 <ihope_> @babel en es you speak
18:58:55 <lambdabot>  usted habla
18:59:12 <ihope_> @babel en es only Spanish
18:59:13 <lambdabot>  solamente español
18:59:34 <ihope_> @babel en es you know
18:59:35 <lambdabot>  usted sabe
18:59:36 <jethr0_> que esta passando?
18:59:44 <jethr0_> ¿
19:00:02 <Lemmih> @babel es en que esta passando
19:00:04 <lambdabot>  that this passando
19:00:08 <Adamant> @babel en es truck driving neighbors downstairs
19:00:09 <ihope_> Hrm.
19:00:09 <lambdabot>  carro que conduce a vecinos abajo
19:00:33 <ihope_> @babel es en carro que conduce a vecinos abajo
19:00:34 <lambdabot>  car that leads neighbors down
19:01:29 <ihope_> @babel en es when you speak four hundred ninety three languageds
19:01:30 <lambdabot>  cuando usted habla cuatro cientos noventa tres languageds
19:01:34 <Adamant> @babel en es car that leads neighbors down
19:01:35 <lambdabot>  coche que conduce a vecinos abajo
19:02:01 <Adamant> @bable es ru coche que conduce a vecinos abajo
19:02:02 <lambdabot> babel module failed: Prelude.head: empty list
19:02:03 <jethr0_> lenguajes
19:02:16 <mauke> @babel de en Das Salz verzehrt den Leib des Mohren
19:02:17 <lambdabot>  The salt verzehrt the body of the Mohren
19:02:20 <ihope_> @babel es en coche que conduce a vecinos abajo
19:02:22 <lambdabot>  car that leads neighbors down
19:02:23 <Adamant> @babel es ru coche que conduce a vecinos abajo
19:02:23 <mauke> suk
19:02:24 <lambdabot> babel module failed: Prelude.head: empty list
19:02:33 <Adamant> @babel es fr coche que conduce a vecinos abajo
19:02:34 <lambdabot>  voiture qui conduit à des voisins vers le bas
19:10:02 <ihope_> @babel en ru the spirit is willing but the flesh is weak
19:10:03 <lambdabot>  can't parse this language
19:10:09 <ihope_> What's Russian?
19:10:19 <ihope_> @babel en de the spirit is willing but the flesh is weak
19:10:21 <lambdabot>  der Geist ist bereit, aber das Fleisch ist schwach
19:10:29 <ihope_> @babel de en der Geist ist bereit, aber das Fleisch ist schwach
19:10:30 <lambdabot>  the spirit is ready, but the flesh is weak
19:10:33 <ihope_> Wow!
19:10:49 <jethr0_> @babel english deutsch mein name is johannes
19:10:50 <lambdabot> babel module failed: Error: Language deutsch not supported
19:11:01 <jethr0_> @babel english geran hello, how are you
19:11:01 <lambdabot> babel module failed: Error: Language geran not supported
19:11:06 <jethr0_> @babel english german hello, how are you
19:11:07 <lambdabot>  hallo, wie Sie sind
19:11:28 <ihope_> @babel en 17 hello, how are you
19:11:29 <lambdabot> babel module failed: Error: Language 17 not supported
19:11:33 <ihope_> Hmm.
19:11:46 <jethr0_> 17?
19:12:03 <jethr0_> i've got that book around here, somewhere
19:14:23 <int-e> @babel de en Der Geist ist willig, doch das Fleisch ist schwach.
19:14:24 <lambdabot>  The spirit is willing, but the flesh is weak.
19:15:55 <ihope_> jethr0_: leet
19:16:47 <jethr0_> @babel de en Noch ist nicht aller Tage Abend
19:16:48 <lambdabot>  Still is not all days evening
19:17:01 <jethr0_> the translations isn't even all that bad
19:17:32 <mauke> @babel en de the cotton socks are made of grows in egypt
19:17:33 <lambdabot>  die Baumwollsocken werden von wächst in Ägypten gebildet
19:17:51 <mauke> haha
19:17:54 <jethr0_> what are "grows"?
19:18:01 <mauke> wrong question
19:18:10 <mauke> grows is the verb (to grow)
19:18:13 <jethr0_> ah
19:18:23 <jethr0_> didn't see the "the" :)
19:18:59 <jethr0_> but the above is definitely a bug in english. a very weak syntax, in this respect
19:20:46 <ihope_> > (error . error) "\1ACTION doez it werk?\1"
19:20:47 <lambdabot> Add a type signature
19:20:51 <ihope_> > (error . error) "\1ACTION doez it werk?\1" :: ()
19:20:52 * lambdabot doez it werk?
19:20:55 <ihope_> Yay!
19:21:19 <jethr0_> yeah, let's build a bot net
19:21:48 <mauke> bot.NET
19:22:02 <dons> hmm. that's not so good.
19:22:13 <dons> I should reall turn offtis error.error. thing.
19:22:17 <ihope_> Noo, don't fix it!
19:22:24 <dons> and type correctly
19:22:29 <ihope_> :-)
19:22:50 <jethr0_> > (error . error) ("\1ACTION " ++ sequence "hello" ++ "\1") :: ()
19:22:51 <lambdabot> Couldn't match `[a]' against `Char'
19:22:58 <dons> I award hack of the day to ihope_
19:23:09 <jethr0_> > (error . error) ("\1ACTION " ++ (concat . sequence $"hello") ++ "\1") :: ()
19:23:09 <lambdabot> Couldn't match `[a]' against `Char'
19:23:31 * dons sets about spoiling the fun
19:24:18 <ihope_> (error . error) ("\1ACTION " ++ cycle "hello" ++ "\1") :: ()
19:24:19 * jethr0_ apologizes for being childish. "doing nothing, unsucessfully"
19:24:31 <jethr0_> ihope_: that's evil
19:24:37 <jethr0_> at least, mine was bounded
19:25:01 <ihope_> You tried to make it bounded ;-)
19:25:08 <ihope_> Now it's nothing at all.
19:25:29 <jethr0_> you're right
19:25:32 <ihope_> > (error . error) "\1PRIVMSG #esoteric Testing...\1"
19:25:32 <lambdabot> Add a type signature
19:25:38 <ihope_> > (error . error) "\1PRIVMSG #esoteric Testing...\1" :: ()
19:25:44 <mauke> huhu
19:25:54 <dons> please stop.
19:26:02 <dons> I'm disabling this as we speak.
19:26:25 <mauke> you should have used VERSION
19:27:28 <jethr0_> @type (error . error)
19:27:28 <lambdabot> forall c. String -> c
19:28:09 <dons> it just exploits a bug in my runplugs program. I show exceptions without checking that they might in turn throw another exception.
19:32:56 <dons> > (error . error) "\1ACTION doez it werk?\1" :: ()
19:32:57 <lambdabot> Exception
19:33:11 <dons> > error "\1ACTION doez it werk?\1" :: ()
19:33:13 <lambdabot> Exception: ACTION doez it werk?
19:33:16 <jethr0_> > (error . error . error) "\1ACTION doez it werk?\1" :: ()
19:33:17 <lambdabot> Exception
19:33:23 <dons> i'm not that silly ;)
19:33:33 <jethr0_> didn't mean to imply
19:33:39 <dons> joke ;)
19:33:53 <int-e> > let e :: String; e = error e in e
19:33:54 <lambdabot> Exception
19:34:17 <ihope_> > let undefined :: () in undefined :: Int
19:34:18 <lambdabot>  Not in scope: `undefined'
19:34:25 <ihope_> Murp?
19:34:27 <dons> the problem was: catch (putStrLn v) (\e -> show e)
19:34:43 <dons> which would catch the first exception thrown, but then just show that exception.
19:34:55 <dons> but what if the thing throw itself would throw something? then it would not be caught
19:35:05 <ihope_> > let error "Undefined" :: () in "bar of foo"
19:35:05 <lambdabot>  Type signature given for an expression
19:35:26 <ihope_> > let error :: String -> String in error "bar of foo" :: ()
19:35:26 <lambdabot>  Not in scope: `error'
19:35:29 <Lemmih> Good night, #haskell.
19:35:30 <int-e> ow. I just tried that in ghci ... I got "Exception: *** Exception: *** Exception: *** ..."
19:35:47 <ihope_> Um.
19:35:48 <ihope_> > error
19:35:49 <lambdabot>  add an instance declaration for (Show ([Char] -> a))
19:35:53 <ihope_> > undefined
19:35:53 <lambdabot> Add a type signature
19:35:55 <dons> now it: catch (putStrLn v) (handle (const $ putStrLn "Exception") $ do e' <- Control.Exception.evaluate e ; putStrLn $ "Exception: " ++ show e')
19:36:03 <ihope_> Ooh
19:36:16 <ihope_> > let undefined = 3 in undefined
19:36:18 <lambdabot> 3
19:36:30 <dons> so it wraps the show, and closes the door
19:37:28 <dons> > undefined :: ()
19:37:29 <lambdabot> Undefined
19:37:46 <ihope_> @type seq
19:37:47 <lambdabot> forall b a. a -> b -> b
19:37:51 * ihope_ looks around
19:38:03 <ihope_> > seq undefined undefined seq undefined seq seq seq undefined
19:38:04 <lambdabot> Add a type signature
19:38:09 <ihope_> > seq undefined undefined seq undefined seq seq seq undefined :: ()
19:38:10 <lambdabot> Undefined
19:38:15 <dons> just add :: ()
19:38:26 <ihope_> > seq undefined undefined seq undefined seq seq seq undefined :: a
19:38:27 <lambdabot> Add a type signature
19:38:30 <ihope_> > seq undefined undefined seq undefined seq seq seq undefined :: forall a. a
19:38:31 <lambdabot>  add an instance declaration for (Show (. (forall a) a))
19:38:44 <ihope_> Um...
19:39:04 <dons> no glasgow-exts, so I guess hmm, no forall types, anyway
19:39:15 <dons> that's msg is weird though
19:39:29 <dons> it thinks '.' is an infix tycon?
19:39:59 <ihope_> @kind .
19:40:00 <lambdabot> parse error on input `.'
19:40:03 <ihope_> @kind (.)
19:40:04 <lambdabot> parse error on input `.'
19:40:16 <dons> no, it's not a known tycon. strange.
19:40:42 <int-e> > seq (error "1") (error "2") seq (error "3") seq seq seq (error "4") :: ()
19:40:43 <dons> maybe it doesn't bother checking if its defined, but just gives up when it can't find a show instance
19:40:43 <lambdabot> Exception: 1
19:41:20 <dons> > undefined :: Foo
19:41:20 <lambdabot>  Not in scope: type constructor or class `Foo'
19:41:29 <dons> > undefined :: b a
19:41:29 <lambdabot>  add an instance declaration for (Show (b a))
19:41:32 <ihope_> I've never been able to figure out what forall meant anyway.
19:41:41 <ihope_> I guess it's an explicit anything?
19:41:51 <dons> > undefined :: b .*.*. a
19:41:52 <lambdabot>  add an instance declaration for (Show (.*.*. b a))
19:41:55 <dons> ah, see!
19:42:22 <dons> I just made up a tycon, and ghc doen't check that its defined. whereas it does for 'Foo'
19:42:33 <int-e> ohhh, that's forall (.*.*.) b a. Show ((.*.*.) b a)
19:42:56 <ihope_> What is a tycon?
19:43:06 <dons> > undefined :: a b .*.*. b
19:43:06 <lambdabot>  add an instance declaration for (Show (.*.*. (a b) b))
19:43:08 <int-e> type constructor
19:43:31 <int-e> @type  undefined :: b .*.*. a
19:43:32 <lambdabot> b .*.*. a :: forall (.*.*. :: * -> * -> *) b a. .*.*. b a
19:43:32 <dons> see, that's the same as: (. (forall a) a), where 'forall' and 'a' are tyvars
19:44:03 <dons> hmm, curioser and curioser
19:44:23 <dons> > undefined :: (.*.*.) b a
19:44:24 <lambdabot>  add an instance declaration for (Show (.*.*. b a))
19:44:25 <int-e> the error message is bad
19:44:34 <int-e> @type  undefined :: a b c
19:44:35 <lambdabot> a b c :: forall (a :: * -> * -> *) b c. a b c
19:44:49 <int-e> it should recognize the infix type constructor
19:44:49 <dons> well, we didn't even get an error msgs for : undefined :: b .*.*. a
19:45:12 <dons> why? it's not defined anywhere. shouldn't it respond the same as using 'Foo' ?
19:45:47 <int-e> hmm
19:45:52 <ihope_> @kind Foo vs. Bar
19:45:53 <lambdabot> parse error on input `.'
19:45:53 <int-e> @type  undefined :: b :*: c
19:45:54 <lambdabot> Not in scope: type constructor or class `:*:'
19:45:59 <dons> > undefined :: Foo a b
19:46:00 <lambdabot>  Not in scope: type constructor or class `Foo'
19:46:08 <int-e> @type  undefined :: b .*. c
19:46:09 <dons> > undefined :: a .**************************. b
19:46:09 <lambdabot> b .*. c :: forall (.*. :: * -> * -> *) b c. .*. b c
19:46:10 <lambdabot>   add an instance declaration for (Show (.**************************. a b)
19:46:10 <lambdabot> )
19:46:30 <dons> @type  undefined :: Foo a b
19:46:32 <lambdabot> Not in scope: type constructor or class `Foo'
19:46:36 <dons> @type undefined :: a .*******. b
19:46:37 <lambdabot> a .*******. b :: forall (.*******. :: * -> * -> *) a b. .*******. a
19:46:37 <lambdabot> b
19:46:44 <dons> but that shouldn't type check!
19:46:50 <int-e> it treats it as a type variable (of kind * -> * -> *), because it doesn't start with a colon?
19:46:57 <dons> ah! maybe
19:47:08 <dons> a weird tyvar.
19:47:09 <dons> hmm
19:47:20 <ihope_> @kind .*.
19:47:21 <lambdabot> parse error on input `.*.'
19:47:22 <int-e> I don't know if it should be doing that.
19:47:33 <dons> this is h98, so we can check the report
19:48:45 <SamB> @kind (.*.)
19:48:45 <lambdabot> Not in scope: type variable `.*.'
19:49:03 <ihope_> @kind (:)
19:49:04 <lambdabot> parse error on input `:'
19:49:09 <ihope_> @kind :foo
19:49:10 <lambdabot> parse error on input `:'
19:49:24 <ihope_> @kind (:foo)
19:49:25 <lambdabot> parse error on input `:'
19:49:31 <dons> yeah, it's a valid varsym, and tyvars are just variables, so i think that's all that's happening
19:49:58 <dons> we're just unused to seeing varsyms for tyvaars
19:50:39 <SamB> @kind (:::)
19:50:40 <lambdabot> Not in scope: type constructor or class `:::'
19:50:58 <dons> > undefined a :***: b -- should be the same as Foo a b
19:50:59 <lambdabot>  Not in scope: `b'
19:51:08 <dons> > undefined :: a :***: b -- should be the same as Foo a b
19:51:09 <lambdabot>  Not in scope: type constructor or class `:***:'
19:51:12 <dons> yep
19:51:35 <dons> > undefined :: .*.*.* -- should be ok
19:51:36 <lambdabot>  parse error on input `.*.*.*'
19:51:36 <int-e> uh. tyvars are varids though, not varsyms.
19:51:50 <dons> well. hmm. that's the weird bit
19:51:58 <SamB> huh?
19:52:24 <int-e> > undefined :: (.*.)
19:52:25 <lambdabot> Add a type signature
19:52:28 <dons> it says in chp2 : tyvar -> varid
19:52:37 <int-e> yes.
19:52:58 <int-e> and varids start with a lowercase letter
19:53:21 <SamB> doesn't (*) count as one?
19:53:57 <dons> yeah, .*.*. is a varsym, which is valid as a variable identifier on the value level. so it seems consistent to allow it on the type level too
19:54:14 <ihope_> @kind *
19:54:15 <lambdabot> parse error on input `*'
19:54:23 <ihope_> @kind (*) * (*)
19:54:23 <dons> you can't take the kind of a kind  ;)
19:54:24 <lambdabot> parse error on input `*'
19:54:30 <ihope_> Oh...
19:54:36 <int-e> and the syntax of types (4.1.2) only allows -> to be written in infix notation, what am I missing?
19:54:49 <ihope_> ...Erm, I was thinking * would be a valid... kindy-thingy.
19:54:54 <ihope_> Type! That's it!
19:55:05 <ihope_> A valid type!
19:55:17 <dons> let's see what nhc and hugs say
19:55:47 <dons> Hugs.Base> undefined :: a .*.*.*. b
19:55:48 <dons> ERROR - Syntax error in input (unexpected symbol ".*.*.*.")
19:56:47 <dons> > undefined :: a .*.*.*. b
19:56:47 <dons> [Compiling...======     In file: /tmp/Main22018.hs:
19:56:48 <lambdabot>  add an instance declaration for (Show (.*.*.*. a b))
19:56:48 <dons> 10:36-10:42 Found (.*.*.*.) but expected one of 
19:57:04 <dons> so they're all lexical errors in hugs and nhc
19:57:32 <int-e> out of curiosity, what do they say for undefined :: a :+: b ?
19:57:40 <dons> even in hbi: > undefined :: a .*.*.*. b
19:57:40 <dons> # ;
19:57:44 * int-e can't find a production for that either.
19:57:44 <dons> [33] Undefined identifier .*.*.*.
19:57:54 <lennart> hbi!!!
19:58:00 <dons> :)
19:58:29 <lennart> even I don't use hbi :)
19:58:32 <lennart> anymore
19:58:47 <dons> oh, i thought everyone kept an hbi installation handy :)
19:59:22 <lennart> there's something nostalgic about the error messages
19:59:35 <dons> int-e: hugs says: ERROR - Syntax error in input (unexpected symbol ":+:")
19:59:36 <ihope_> @ghc
19:59:37 <lambdabot>  Offending Program
19:59:46 <ncalexan> lol.
19:59:52 <dons> lennart, true! we should add @hbi, I think.
20:00:04 <dons> (to complement @ghc)
20:00:16 <dons> now, where's my gofer installation..
20:00:16 <int-e> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#infix-tycons says infix tycons are a ghc extension
20:00:43 <dons> Gofer session for:
20:00:43 <dons> /usr/local/lib/Gofer/standard.prelude
20:00:43 <dons> Type :? for help
20:00:43 <dons> ? undefined :: a .*.*.*. b
20:00:44 <dons> ERROR: Syntax error in input (unexpected symbol ".*.*.*.")
20:00:47 <dons> :)
20:01:10 <int-e> so we have agreement everywhere. *g*
20:01:40 <dons> 4/5 haskell-ish compilers recommend not using .*.*.*. :)
20:01:42 <lennart> I argued for many of the things that seem to have become popular now.  Infix types.  Sections for ,
20:01:56 <lennart> but that was 10 years ago :)
20:02:02 <dons> hehe :)
20:02:40 <dons> int-e, so the interesting thing is that ghc does this _without_ turning on -fglasgow-exts
20:02:51 <ihope_> Infix types? Like (->)?
20:02:55 <lennart> hmmm, when will people start asking for lower case constructors?
20:02:56 <dons> naughty simons
20:03:04 <dons> hehe. someone asked yesterday
20:03:05 <int-e> ihope_: well, -> has a special production in the grammar
20:04:09 * palomer wonders where cale has done to
20:04:28 <lennart> there are some worms crawling out of the cans for some of these issues
20:04:52 <int-e> dons: 05:04:19 bf3@zombie:~ > ghc ttttt.hs
20:04:52 <int-e> ttttt.hs:3:17:
20:04:52 <int-e>     Warning: Accepting non-standard infix type constructor `:+:'
20:04:52 <int-e>              Use -fglasgow-exts to avoid this warning
20:04:52 <palomer> infix types? (don't you mean infix type constructors?)
20:05:13 <palomer> what does "sections for ," mean?
20:05:13 <dons> int-e, but what about .*.*.* as a tyvar?
20:05:18 <int-e> oh.
20:05:33 <palomer> @type (,,,,,,,,,,,,)
20:05:34 <lambdabot> forall m l k j i h g f e d c b a.
20:05:34 <lambdabot> -> b
20:05:34 <lambdabot> -> c
20:05:34 <lambdabot> -> d
20:05:34 <lambdabot> -> e
20:05:36 <lambdabot> [9 @more lines]
20:05:38 <lennart> palomer: (,5) is (\x -> (x,5))
20:05:48 <palomer> lennart: how is that a section?
20:05:53 <palomer> I always thought a section was a left inverse
20:05:54 <ihope_> > (,5,)
20:05:55 <lambdabot>  parse error on input `5'
20:05:59 <lennart> the same way (+4) is
20:06:00 <ihope_> > (,5)
20:06:01 <lambdabot>  parse error on input `5'
20:06:04 <int-e> dons: same thing.
20:06:04 <ihope_> > (5,)
20:06:05 <lambdabot>  parse error on input `)'
20:06:16 <int-e> dons: gives me a warning (Accepting non-standard infix type constructor `.>.')
20:06:20 <palomer> @type (4+)
20:06:21 <lambdabot> forall a. (Num a) => a -> a
20:06:24 <palomer> @type (+4)
20:06:25 <lambdabot> forall a. (Num a) => a -> a
20:06:36 <palomer> (-1) 2
20:06:39 <palomer> > (-1) 2
20:06:40 <jethr0_> i find it hard to accept (,5,) as usefull
20:06:40 <lambdabot>  add an instance declaration for (Num (t -> a))
20:06:40 <lambdabot>   In the definition of `dqy': dqy = (- 1) 2
20:06:40 <lambdabot>   In the definition of `v': v = let dqy = (- 1) 2 in take 2048 (show dqy)
20:06:49 <palomer> how does (-) work?
20:06:52 <palomer> I never understood it
20:06:54 <int-e> @type (,5,)
20:06:55 <lennart> and I wanted ~ for negation in Haskell
20:06:55 <lambdabot> parse error on input `5'
20:07:01 <jethr0_> > (subtract 1) 2
20:07:02 <lambdabot> 1
20:07:03 <ihope_> > ~
20:07:04 <lambdabot>  parse error on input `}'
20:07:06 <lennart> - is a wart!
20:07:07 <ihope_> > (~)
20:07:08 <lambdabot>  parse error on input `)'
20:07:09 <palomer> @type (-)
20:07:10 <lambdabot> forall a. (Num a) => a -> a -> a
20:07:16 <palomer> @type (-1)
20:07:17 <lambdabot> forall a. (Num a) => a
20:07:21 <int-e> lennart: unary -. yes it is :)
20:07:23 <palomer> this doesn't make any sense to me
20:07:31 <int-e> and (n+k)-patterns
20:07:31 <jethr0_> palomer: well
20:07:37 <ihope_> palomer: nobody understands it
20:07:37 <lennart> no, uniary - makes no sense
20:07:51 <int-e> > negate 42
20:07:52 <lambdabot> -42
20:08:08 <palomer> @type (,) 5
20:08:09 <lambdabot> forall a b. (Num a) => b -> (a, b)
20:08:38 <jethr0_> in a way unary minus is a problem even in maths. 3 - - 2 is a weird expression to parse
20:08:42 <int-e> > (5+2*) 5
20:08:43 <lambdabot>   The operator `*' [infixl 7] of a section
20:08:43 <lambdabot>    must have lower precedence than the operand `(+)' [infixl 6]
20:08:43 <lambdabot>    in the section: `((5 + 2) *)'
20:08:48 <palomer> > 3 - -2
20:08:49 <lambdabot>   precedence parsing error
20:08:49 <lambdabot>    cannot mix `(-)' [infixl 6] and prefix `-' [infixl 6] in the same
20:08:49 <lambdabot> infix expression
20:09:01 <lennart> math doesn't have operator sections
20:09:03 <jethr0_> palomer: you need to put unary minus in parens
20:09:04 <palomer> > 3 - (-2)
20:09:05 <lambdabot> 5
20:09:16 <palomer> @type 3 - 
20:09:17 <lambdabot> parse error (possibly incorrect indentation)
20:09:18 <lennart> nor did Haskell when - was deemed to be negation
20:09:24 <palomer> @type (3-)
20:09:25 <lambdabot> forall a. (Num a) => a -> a
20:09:29 <int-e> palomer: well, that's never needed. - - --> +, + - --> -
20:09:48 <jethr0_> > (2-) (-2) ((-2)-) 2
20:09:49 <lambdabot>  add an instance declaration for (Num ((a -> a) -> t -> a1))
20:10:08 <jethr0_> > (2-) (-2) - ((-2)-) 2
20:10:09 <lambdabot> 8
20:10:17 <jethr0_> hehe
20:10:38 <jethr0_> > (2-) (-(-2)) - ((-2)-) 2
20:10:39 <lambdabot> 4
20:10:39 <int-e> > (0-) (-0) -- some sort of smiley?
20:10:41 <lambdabot> 0
20:11:06 <jethr0_> this gets utterly unreadable fairly quickly
20:11:35 <ihope_> int-e: frog?
20:11:48 <int-e> lennart: what are tuple sections? would (,2,,) :: Num b => a -> c -> d -> (a,b,c,d) ?
20:12:05 <jethr0_> > (,) 2 3
20:12:06 <lambdabot> (2,3)
20:12:18 <palomer> tuple sections have become popular?
20:12:21 <palomer> I've never had a use for them
20:12:22 <jethr0_> but anything beyond that becomes hairy
20:13:06 <int-e> > flip (,) 2 3
20:13:07 <lambdabot> (3,2)
20:13:20 <int-e> > flip (,,,) 1 2 3
20:13:21 <lambdabot>  add an instance declaration for (Show (d -> (a, b, c, d)))
20:13:25 <int-e> > flip (,,) 1 2 3
20:13:26 <lambdabot> (2,1,3)
20:14:08 <int-e> @pl \f a b c d -> f b c d a
20:14:09 <lambdabot> flip . ((flip . (flip .)) .)
20:15:15 <palomer> @pl flip (uncurry flip) (,,0
20:15:16 <lambdabot> (line 1, column 22):
20:15:16 <lambdabot> unexpected ","
20:15:16 <lambdabot> expecting lambda abstraction or expression
20:15:18 <palomer> @pl flip (uncurry flip) (,,)
20:15:19 <lambdabot> flip (uncurry flip) (,,)
20:15:36 <palomer> @pl \x y z -> flip (uncurry flip) (y,x,z)
20:15:37 <lambdabot> ((flip (uncurry flip) .) .) . flip (,,)
20:26:56 <ihope_> @babel es en Tengo una cacahuete en mi ombligo.
20:26:57 <lambdabot>  I have a peanut in my navel.
20:27:17 <ihope_> Not mine; I found it Somewhere.
20:27:32 <ihope_> @babel en es a peanut
20:27:33 <lambdabot>  un cacahuete
20:28:24 <ihope_> Hmm.
20:28:33 <ihope_> @babel es en los perro
20:28:34 <lambdabot>  the dog
20:28:37 <ihope_> @babel es en los pero
20:28:39 <lambdabot>  but
20:28:42 <ihope_> Hmm.
20:30:03 <ihope_> @babel es en "un"
20:30:04 <lambdabot>  ""
20:31:11 <palomer> can two typeclasses have a common member?
20:31:21 <palomer> if they're not in the same hierarchy
20:31:41 <ihope_> ...Yes?
20:31:45 <SamB> um
20:31:47 <ncalexan> Do you mean, can two typeclasses have the same function name?  No.
20:31:48 <SamB> yeah?
20:31:51 <SamB> oh no.
20:32:03 <ihope_> What do you mean, in the same hierarchy?
20:32:04 <int-e> sure, but in different modules
20:32:20 <ncalexan> int-e: sure, if they're in different scopes, I suppose :)
20:32:30 <palomer> ihope_: one is a subclass of the other
20:32:44 <palomer> I guess that's where the power of type classes lies
20:32:46 <int-e> ncalexan: we have quite a few 'lookup's around by now :)
20:32:52 <ihope_> Yep.
20:33:58 <ihope_> @babel en es I love to it
20:33:59 <lambdabot>  Amo a él
20:34:08 <ihope_> @babel es en Amo a él
20:34:10 <lambdabot>  Master to him
20:34:22 <ncalexan> int-e: rather :)  But not many of them are in typeclasses.
20:34:41 <ncalexan> In fact, that's probably a weakness.
20:55:14 <MarcWeber> Can you tell me how to specify --with-gcc="c:\MinGWStudio\MinGW\bin\" correctly when configuring fptools ? It's on windows and I don't know how to escape the backslash correctly
20:55:28 <jethr0_> anyone using VIM with "quickfix" and ghc?
20:56:13 <MarcWeber> Yes, me
20:56:30 <jethr0_> MarcWeber: have you tweaked it?
20:56:36 <MarcWeber> What tweaked?
20:56:45 <MarcWeber> What to tweak?
20:57:00 <MarcWeber> It did work out of the box. Where is your problem?
20:57:06 <jethr0_> it gives me empty screens because it doesn't understand some of the messages
20:57:10 <Korollary> MarcWeber: It's probably "c:\\Min..."
20:57:42 <MarcWeber> Korollary configure likes it, but make of the happy subdir doesn't .. It complains C:Min... not found..
20:57:57 <MarcWeber> jehr0_ What do you mean by empty screens?
20:58:14 <MarcWeber> jehr0_ You know cope?
20:58:15 <jethr0_> i enter ":make"
20:58:21 <jethr0_> and all i get is:
20:58:25 <jethr0_> (4 of 6): 4: Not in scope: `asdfTestCase'
20:58:26 <jethr0_> Hit ENTER or type command to continue
20:58:44 <jethr0_> no, i don't know it
20:58:54 <MarcWeber> asdf??
20:58:57 <MarcWeber> Is this your name?
20:59:09 <jethr0_> just a test
20:59:35 <jethr0_> what is cope?
20:59:54 <MarcWeber> ;-)  jethr0_ It would be much easier for me if you dcc send me the Makefile or paste it somewhere .
21:00:07 <MarcWeber> Just type :cope
21:00:13 <MarcWeber> It will show all output ..
21:00:45 <MarcWeber> Ah.. wait..
21:00:55 <MarcWeber> Are you on win ?
21:01:00 <jethr0_> nope
21:01:27 <jethr0_> it's a general thing. i'm just starting to use vim a little more "professionally"
21:01:46 <jethr0_> and am wondering how you do things...
21:01:47 <MarcWeber> (4 of 6) means it has detected an error. empty screen means it did try to load the file where the error should be but got the name wrong. So it opens a new empty file
21:01:57 <MarcWeber> type :cope and you will perhaps see why
21:02:02 <jethr0_> k
21:02:18 <wolverian> jethr0_, also remember you can always use :h to get help on commands you don't know. i.e. :h cope
21:02:30 <MarcWeber> :h quickfix ;-)
21:02:42 <wolverian> :)
21:02:53 <jethr0_> wolverian: thx. i always tell myself to do so. but the vim online help goes against every grain of my being
21:02:58 <jethr0_> i don't know why
21:03:10 <jethr0_> it just seems hard to remember how to navigate :)
21:05:33 <jethr0_> thx. cope is quite worth its money :)
21:05:34 <MarcWeber> Navigate where? Helpfiles? g-STRG-]  to follow links.. and remember, you can remap ! ;-)
21:06:54 <mauke> why g?
21:09:00 <MarcWeber> Does it work without g, too?
21:09:33 <mauke> did you read the first page of :help? :-)
21:09:43 <mauke> Jump to a subject:  Position the cursor on a tag between |bars| and hit CTRL-].
21:09:50 <int-e> @index UArray
21:09:50 <lambdabot> Data.Array.Unboxed
21:11:17 <MarcWeber> mauke Sometimes I'm using just the keyboard..
21:19:19 <jethr0_> MarcWeber: are you using hunit too?
21:19:38 <MarcWeber> Not yet but I've heard about it
21:19:56 <jethr0_> i was just wondering is there was a way to integreate the summary into cope...
21:20:25 <MarcWeber> jethr0_ :h makeprg?
21:20:36 <MarcWeber> and perhaps :h compiler
21:20:59 <jethr0_> no, the making is easy. i mean the extraction into the cope window
21:21:26 <MarcWeber> errorformat?
21:21:27 <jethr0_> or does the cope window show all compiler output?
21:21:41 <jethr0_> ok, i'll just have to read up a bit on cope, quickfix, etc
21:21:49 <MarcWeber> It does show everything and some || added to show you wether it has recognized some error/warnings..
21:21:53 <jethr0_> don't wanna bother you with FAQ questions
21:21:57 <MarcWeber> You don't 
21:22:56 <jethr0_> i'm just one of those unusual cases that can't decide between emacs and vim.
21:23:13 <jethr0_> so, i use both and only know 50% of the advanced features :(
21:23:52 <SamB> jethr0_: that sounds like an insanely high percentage
21:24:14 <MarcWeber> I'ts quite normal that ghc doesnt find unit GenUtils beeing in GenUtils.lhs when compilng ghc First.lhs without --make?
21:24:38 <jethr0_> SamB: i meant the reasonable features. actually i don't use anything regularly other than copy/paste, regexps, buffers, searching, etc
21:24:54 <jethr0_> the really cool features, i am always too lazy to remember and use actively
21:25:01 <jethr0_> SamB: do you use hunit?
21:25:08 <MarcWeber> jethr0_ He, so you know "+y and Ctrl-R+ ;-)
21:25:41 <int-e> MarcWeber: did you compile GenUtils.lhs?
21:25:55 <jethr0_> i actually like both emacs's and vi's paradigm. i decide on whether i want gui or console :)
21:26:20 <SamB> jethr0_: no
21:26:31 <MarcWeber> int-e see here http://www.rafb.net/paste/results/2TS7rn27.html
21:26:39 <jethr0_> my favorite emacs binding (that i actively use) is: alt-strg-shift-5
21:26:47 <MarcWeber> jethr0_ Both can both
21:26:57 <int-e> MarcWeber: I believe it'll find it then, and without --make it won't compile it itself. So my answer is, yes, that's normal.
21:27:01 <SamB> I suppose you are referring to the lack of mouse support in console emacs?
21:27:14 <jethr0_> MarcWeber: i know. but i have serious problems with function keys under console (like ctrl-backspace for example)
21:27:21 <jethr0_> and vim gui i don't particularly like
21:27:29 <MarcWeber> int-e But thats the happy make file from fptools (?) 
21:27:51 <MarcWeber> Is it "normal" that it can't compile?
21:27:59 <jethr0_> SamB: never tried. i've always been too lazy for console mouse support. especially since i used terminals other than xterm, and thus had no chance anyways :)
21:28:27 <SamB> what abominations be those?
21:28:42 <jethr0_> i went through all of them. aterm, Eterm
21:29:14 <jethr0_> terminal support is one of the _HUGE_ vices of unix/linux. there's nothing worse on this planet than the intricacies of terminal emulation
21:29:15 <MarcWeber> I see them all and think eterm: "apple" aterm : "apple" .. ;-)
21:29:28 <jethr0_> so many warts, backwart compatibility to some 1960s hardware, ...
21:29:42 <int-e> MarcWeber: heh. I read that as a question about ghc behaviour.
21:29:47 <MarcWeber> Even worse than VB 6.0 ? ;-)
21:30:10 <MarcWeber> int-e How do I make that compile? Patching the Makefile?
21:30:36 <SamB> jethr0_: well, would you rather plan9's solution?
21:31:09 <jethr0_> i think nothing can be worse than linux's current situation. (which hasn't changed for 30 years or so)
21:31:54 <jethr0_> getting function keys working, and resizing of windows possible goes beyond the keenest dreams of the linux fan
21:32:01 <MarcWeber> And it's still competetive ;-)
21:32:25 <jethr0_> MarcWeber: have you looked at windows console recently
21:32:57 <SamB> jethr0_: they still have no shell
21:33:04 <MarcWeber> You can use vim with colors, Mouse, .. but you can't resize the window after having started an application
21:33:07 <jethr0_> yes they have: command.com
21:33:13 <SamB> um
21:33:17 <SamB> thats the wrong one
21:33:22 <SamB> that is the DOS shell
21:33:23 <jethr0_> MarcWeber: isn't there a shortcut for that ctrl-l or so?
21:33:38 <jethr0_> SamB: well, it's dos emulation, or some such
21:34:00 <SamB> jethr0_: you presumably meant cmd.exe
21:34:05 <MarcWeber> Don't know, I'm using cygwin
21:34:10 <SamB> which is still not much of a shell if you ask me
21:34:17 <MarcWeber> Ctrl-l = clear scren
21:34:21 <jethr0_> but even with monad shell, i don't think that many windows guys will use it more. they've been so focused on gui by MS during the past 10 years
21:34:23 * int-e will try to reproduce that on linux.
21:34:29 <jethr0_> SamB: yes, same thing :)
21:34:35 <SamB> not really
21:34:52 <jethr0_> ...
21:34:52 <MarcWeber> int-e It's a checkout from today
21:34:54 <SamB> on 9x there is just command.com, which is kinda crazy
21:35:18 <jethr0_> last time i actively used windows was with win 98
21:35:23 <MarcWeber> But you can use linux tools on win, too *g*
21:35:28 <jethr0_> a little win2k after that, but marginal
21:35:28 <int-e> MarcWeber: yes, that's what I was going to try with
21:35:34 <MarcWeber> There are some nice project such like geoshell
21:36:01 <jethr0_> i've got a windows for gaming on my computer. and it's running a nice blackbox :)
21:36:06 <jethr0_> looks almost like home
21:36:19 <MarcWeber> int-e MSys, Cygwin and another one I don't remember.. are the projects I know about
21:36:19 <int-e> yep, it does that here, too.
21:36:35 <MarcWeber> bug?
21:36:44 <int-e> yes.
21:37:02 <MarcWeber> How to fix this? Adding --make?
21:38:25 <MarcWeber> It's some knid of typicall error because it reveals when doing make clean; make and not when using make.. without altering that .lhs file.
21:38:51 <MarcWeber> int-e Are you familiar with fptools makefiles?
21:41:55 <MarcWeber> int-e Run make boot first ! ;-)
21:42:12 <MarcWeber> I don't know what it does but it works *lol*
21:42:23 <MarcWeber> ?? int-e ??
21:45:05 <int-e> MarcWeber: sorry. trying to figure out what those makefiles are doing :)
21:46:51 <MarcWeber> I find that reading Makefiles is as hard as reading lisp is said to be ;-)
21:47:32 <int-e> ah. one of the things it does is /usr/bin/ghc -M -optdep-f -optdep.depend  -osuf o -H16m -O -cpp -fglasgow-exts -O [lots of source files here]
21:47:35 <int-e> nice.
21:47:55 <MarcWeber> ?
21:48:06 <jethr0_> bad readability of reasonably formatted lisp code is overhyped, IMHO
21:48:32 <MarcWeber> jethr0_ I don't know that much about it, unfortunately.. I have heard that once.
21:49:04 <int-e> MarcWeber: that creates a .depend file with dependencies, and one of the Makefile templates includes that.
21:49:11 <jethr0_> it's simply not true. apart from syntax lisp/scheme code is remarkably similar to haskell in structure
21:49:53 <int-e> MarcWeber: so after that's there, make compiles the files in a different order, one that works.
21:50:28 <mauke> http://www.willamette.edu/~fruehr/haskell/evolution.html
21:50:32 <jethr0_> it's simply not true. apart from syntax lisp/scheme code is remarkably similar to haskell in structure(define (func xs)
21:50:35 <jethr0_>   (map (lambda (x y)
21:50:37 <jethr0_>           (+ x y)
21:50:40 <jethr0_>         xs)))\
21:50:55 <MarcWeber> int-e But why use makefiles at all? ghc --make is meant to replace make, isn't it? because it's faster as you dan't have to restart ghc again and again..?
21:51:06 <mauke> fac = (\(n) -> (if ((==) n 0) then 1 else ((*) n (fac ((-) n 1)))))
21:51:14 <jethr0_> would be the equivalent of "func xs = map (\x y -> x + y) xs
21:51:37 <jethr0_> d'oh, got right into a traffic jam
21:51:58 <int-e> MarcWeber: because the process can't rely on an existing ghc perhaps?
21:52:28 <int-e> MarcWeber: I don't know.
21:52:49 <jethr0_> mauke: prefix operators are actually quite cool. enabling stuff like (+ 3 4 5 6)
21:52:52 <MarcWeber> int-e That doesn't make any sense because ghc is used to make that right order .. 
21:53:10 <int-e> uh right.
21:53:10 <MarcWeber> But you are right: happy can be used with other compilers ,too
21:53:20 <int-e> historical reasons?
21:53:35 <MarcWeber> So there might be other tools doing the job of ghc (boot)...
21:53:46 <MarcWeber> ugly! I don't like that idea. But I thought of that, too
21:56:19 <int-e> MarcWeber: maybe the idea is to ship the packages with prepared .depend files.
21:56:34 <MarcWeber> Ah!
21:56:55 <MarcWeber> That's kind of genious ;-)
21:57:17 <MarcWeber> And thats why make boot is so uncommon.
22:03:46 <jethr0_> \x y -> compare (f x) (f y)
22:03:50 <jethr0_> @pl \x y -> compare (f x) (f y)
22:03:50 <lambdabot> (. f) . compare . f
22:04:04 <Cale> jethr0_: I call that comparing
22:04:15 <jethr0_> how'd you write it?
22:04:29 <Cale> comparing f x y = compare (f x) (f y)
22:04:31 <jethr0_> i keep typing this for sortBy and groupBy... is there a non-idiotic way?
22:04:41 <jethr0_> ah, good to know :)
22:04:43 <Cale> just include that definition somewhere
22:04:48 <jethr0_> @hoogle comparing
22:04:48 <lambdabot> No matches found
22:04:55 <jethr0_> *grmph*
22:05:01 <Cale> I think they were going to put it in Data.Ord
22:05:08 <Cale> but that's not around yet anyway
22:06:02 <jethr0_> but it's still too long. would be so nice to say "groupBy snd"
22:06:26 <jethr0_> and "groupBy (flip snd)"
22:06:39 <Cale> groupBy (comparing snd) :)
22:06:59 <jethr0_> at a realistic nesting that takes up a good part of 80 cols
22:07:19 <Cale> 80 cols?
22:07:33 <jethr0_> 80 columns file width
22:07:37 <Cale> Who uses 80 column terminals? :)
22:07:59 <Cale> my default terminal in X is 120 cols
22:08:00 <jethr0_> me, as a standard. it prevents me from nesting too deep
22:08:44 <Cale> hmm :)
22:08:49 <jethr0_> for example in linux kernel, 80 cols is mandatory
22:08:55 <Cale> that's odd
22:09:21 <jethr0_> there are many people who like to have several editors next to each other and prefer narrow code
22:10:34 <Cale> what about when that starts getting in the way of how you structure your code?
22:11:17 <jethr0_> hmm. it get's pretty damn close in haskell. two nested where's already take up a substantial part of screen space
22:11:43 <jethr0_> but, personally i even like continued lines...
22:11:53 <jethr0_> when they are indented in a sensible fashion
22:12:34 <Cale> Sure, in some places that's quite sensible
22:12:51 <Cale> I think you'd hate gap :)
22:13:02 <jethr0_> what's that?
22:13:30 <Cale> A programming language/environment for group theory
22:13:37 <Cale> It has identifiers like AbelianNumberFieldByReducedGaloisStabilizerInfo
22:14:19 <Cale> CanonicalRepresentativeDeterminatorOfExternalSet
22:14:21 <jethr0_> yup, that would make it hard for me
22:14:37 <Cale> ColumnIndexOfReesZeroMatrixSemigroupElement
22:14:40 <Cale> heh
22:15:05 <jethr0_> it's not like a religion to me. put as i've worked with people who expected this, i've made it a habit. and you DO get better screen usage (signal to empty ratio) this way
22:15:26 <MarcWeber> int-e There is another strange thing.. when adding --with-ghc= you can specify e.g c:\ghc\ghc\ghc-6.4.1 and configure won't complain but make will fail  because it can't filnd ghc. (tries to execute the directory) .. 
22:15:41 <jethr0_> long Constructor names and telling variable names can get pretty taxing already
22:16:47 <Cale> I suppose it depends what you're optimising for. I think that spacing things out is usually good if it helps to make sense of them. After all, you wouldn't write everything in one dense block, even though you could :)
22:19:43 <Cale> I can see if you wanted to fit lots and lots of editors/terminals on your screen, you could do that
22:20:05 <Cale> (write things with fairly restrictive widths)
22:20:59 <Cale> I had a 23" display when I was working for McMaster, and so my lines tended to become incredibly long :)
22:22:50 <jethr0_> using an obscene amount of let bindings definitely helps
22:26:26 <sh10151> 80 column rule forever
22:27:23 <jethr0_> was that sarcastic?
22:34:05 <Saulzar> It's the age old argument tabs vs tiling
22:37:22 <int-e> @index IORef
22:37:22 <lambdabot> Data.IORef
22:54:56 <palomer> hrm
22:56:17 <palomer> given that I know a function is of type Term int -> int and of type Term bool -> bool and Term [String] -> String, how can I surmise it's of type forall a. Term a -> a?
22:57:23 <dons> hmm? but you have a Term [a] -> a?
22:57:40 <dons> in your last case.
22:58:41 <palomer> err, I meant Term [String] -> String
22:59:11 <dons> ? isn't that the problem
22:59:20 <palomer> err, I meant Term [String] -> [String]
22:59:26 <dons> ah. :)
22:59:37 <palomer> so, I've infered that my function is a bunch of types, and I want to find a most general type
23:00:28 <dons> well, just folow the mgu steps? substitute a fresh tyvar etc etc.
23:02:06 <palomer> mgu steps?
23:02:42 <dons> are you trying to unify these things by hand or something?
23:02:55 <palomer> no, by computer
23:03:02 <palomer> Term may be a GADT
23:03:40 <dons> ah, so by surmise, you meant "I need a GADT decl"?
23:04:18 <palomer> decl?
23:04:32 <palomer> but, anyways, I can't unify these things, since [String] != Bool
23:19:06 * palomer wonders why haskell picked /= and not !=
23:27:28 <gour> @where yi
23:27:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
23:27:35 <gour> @where hIDE
23:27:36 <lambdabot> http://haskell.org/haskellwiki/HIDE
23:27:42 <gour> @where hs-plugins
23:27:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
23:27:44 <sh10151> palomer: similarity to ‚
23:27:56 <sh10151> palomer: no confusion with other uses of ! in haskell
23:31:50 <int-e> /= seems to originate in Lisp.
23:34:40 <int-e> so the right question is, why didn't C use /= ;)
23:35:12 <palomer>  /= means something else in C
23:35:17 <int-e> I know.
23:35:19 <int-e> :)
