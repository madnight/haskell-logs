00:03:29 --- topic: '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20060123","HCAR 11/2005:","http://haskell.org/communities/"]'
00:03:29 --- topic: set by SimonRC on [Wed Jan 25 01:54:56 2006]
00:17:08 <gizban> why did a billion people just quit and rejoin?
00:17:41 <gizban> nevermind
00:23:26 <skew> is anybody here familiar with the happy internals?
00:24:01 <skew> I put together a simple c-like grammar, and found that it was approximately as unambigous after reversing the productions
00:24:56 <skew> (the traditional if/if/else shift/reduce conflict turned into two reduce/reduce conflicts)
00:25:53 <skew> I'm thinking that an interesting way of doing parsing around edits for an IDE would be to keep parser state for parsing forward from the beginning, and parsing backwards from the end
00:26:17 <skew> or more generally, to parse fragments of text into relations on the possible parser states on each side
00:48:26 <essiene> moin *
00:48:31 <essiene> ski: ping?
00:48:46 <jethr0_> moin
00:49:08 <ski> essiene : pong
00:49:30 <essiene> ski: hola... i'm having a ball here :)
00:49:41 <essiene> ski: that tutorial... YAHT.. is just great
00:49:46 <ski> the dance kind ? :)
00:49:52 <ski> glad to hear
00:49:57 <essiene> ski: haha... maybe brain dance ;)
00:50:39 <essiene> i'm currently on the section introducing IO... trying to solve the excercise... and i just want to understand something
00:51:07 <essiene> as i know it currently... a function returns a value with no side effects...
00:51:30 <essiene> and we'd define functions as: afunc param = (expression)
00:51:42 <ski> (http://lambdadance.spacebar.org/)
00:51:53 <ski> yes
00:52:37 <ski> wb
00:53:00 <essiene> bah to the link :)
00:53:16 <ski> hehe
00:53:19 <essiene> anyways... i've now come across these *things* that you use like:
00:53:28 <essiene> word <- getLine
00:53:51 <ski> yes, do-notation with monads
00:54:02 <essiene> what are they actualy called? also, are they only created with the 'do' call?
00:54:08 <ski> (in this case the IO monad)
00:54:19 <ski> 'do-expression'
00:54:25 <ski> and yes, for the latter question
00:54:50 <essiene> thnx
00:54:57 <ski> a do-expression creates an action, that *when*run/performed*, will do some effects
00:55:15 <ski> so, e.g. if you do
00:55:34 <essiene> hmmm... so is IO.getLine a monad?
00:55:56 <ski> > length [(do putStrLn "hello"),(do s <- getLine; putStrLn (reverse s))]
00:55:57 <lambdabot> 2
00:56:20 <ski> then that doesn't perform any IO-effects, just constructing two IO-actions and putting them in a list
00:56:29 <essiene> hmmm...
00:56:30 <ski> no, 'getLine' is an IO-action
00:56:37 <ski> 'IO' itself is a monad
00:56:41 <essiene> oh... i c
00:56:43 <ski> @type getLine
00:56:44 <lambdabot> IO String
00:56:48 <ski> @type putStrLn
00:56:49 <lambdabot> String -> IO ()
00:56:56 <ski> @type putStrLn "hello"
00:56:57 <lambdabot> IO ()
00:57:14 <essiene> oh... i c
00:57:33 <ski> 'putStrLn' is a function that when given a string, returns an IO-action, that when run will print the string and monadicallt return nothing interesting
00:57:46 <essiene> hmm... interesting...
00:57:59 <ski> 'getLine' is an IO-action, that when run will read a line monadically return that line
00:59:03 <ski> note, that as the effects are encapsulated inside IO-actions (a kind of values), there is no *side*-effects, since there's is no effects happening on the side of evaluating an expression (e.g. calling a function)
00:59:09 <essiene> hmmm...
00:59:20 <essiene> ok... i think its a bit clearer now...
01:00:21 <ski> (also, the only way to start of running IO-actions is by 'main' .. pure functions can't on their own execute IO-actions)
01:00:32 <ski> hope this helps
01:00:57 <essiene> yeah... you've explained a lot... i'll chew on them gently... and return if i have prbs..
01:01:00 <essiene> thnx a mill :)
01:01:08 <ski> np
01:01:36 <essiene> i'm enjoying the brain stretch :)
01:02:20 <ski> (one more note .. 'do-notation' is actually syntactic sugar for (some) ordinary haskell expressions .. nothing magic about the syntax)
01:02:46 <essiene> oh... i c
01:03:00 <ProfTeggy> Hi all.
01:03:16 <ski> good morning ProfTeggy and all
01:10:08 <ProfTeggy> Hmm, invitation to chair PLAN-X 2007.  I will if the Haskell community promises to submit good stuff.  Will you? ;-)
01:26:16 <kosmikus> ProfTeggy: congratulations.
01:26:48 <ProfTeggy> Andres, hi.  Thanks.
01:27:13 <ProfTeggy> kosmikus, collocated with POPL in Nice.
01:28:31 <kosmikus> heh. you go ahead and submit to the Haskell Workshop 2006, and then ... maybe ... ;)
01:28:32 <ProfTeggy> Btw, the XQuery community is in bad need of a true-to-the-book of the XQuery static typing feature.  This features is considered 'at risk' and may be removed from the final W3C Recommendation if no such implementation exists by mid-2006.
01:29:12 <ProfTeggy> I was thinking if one could do a 'Typing XQuery in Haskell' along the lines of Mark Jones' 'Typing Haskell in Haskell'...
01:29:26 <ProfTeggy> Andres ;-)
01:30:02 <ProfTeggy> err, 'true-to-the-book implementation' I meant
01:30:27 <kosmikus> depends on how complex the XQuery type system is.
01:30:44 <ProfTeggy> It is specifiec in the W3C XQuery Formal Semantics document.
01:30:48 <kosmikus> 'Typing Haskell in Haskell' lives from the fact that the end result, including good explanations, is conference-paper-size
01:30:56 * ProfTeggy nods.
01:31:04 <ProfTeggy> I re-read it yesterday (partly).
01:31:23 <ProfTeggy> This should be do-able for XQuery, too.
01:31:43 <ProfTeggy> No type classes, context reductions, type schemes, kind or such.
01:31:45 <kosmikus> sound like a good project, then :)
01:32:16 <ski> (literate ?)
01:32:32 <ProfTeggy> XQuery types essentially are regular expressions over XML element names and XML Schema atomic types.
01:32:40 <pejo> ProfT, you have a perfect excuse to go to Nice then, I guess. ;)
01:32:57 <ProfTeggy> xs:integer | xs:boolean+ | element(a)*
01:33:00 <ProfTeggy> etc...
01:33:10 <ProfTeggy> ski, yeah, literate
01:33:31 <ProfTeggy> pejo, i guess so.  Makes it easier to explain it to my wife at least
01:34:09 <dcoutts> skew, it's partly that it really is that slow and partly that it wait a bit before redrawing in the pretty view. You can see now why we don't redraw the pretty veiw every time the clock changes size, like the origianal C version did.
01:34:52 <dcoutts> skew, the original C version was intolerably slow except on really fast machines, now it's just tolerably slow :-)
01:35:34 <dcoutts> skew, it seems that the gradients are the expensive part. Compositing is cheap.
01:35:37 <kosmikus> ProfTeggy: ah yes, I remember now, I even followed a course on XQuery by Phil Wadler at AFP 2002 in Oxford
01:38:57 <dcoutts> SamB, so what would you have used ideally rather than a TextVeiw ?
01:41:33 <araujo> hiya dcoutts !
01:41:40 <araujo> hi kosmikus !
01:41:44 <araujo> Hello everyone!
01:42:43 <dcoutts> morning araujo 
01:42:52 <araujo> :-)
01:51:31 <vincenz> literate programming is cooler than I thought
01:55:05 <skew> vincenz: what are you doing?
01:57:52 <vincenz> nothing, was reading thih
01:58:52 <gour> vincenz: have you tried leo editor?
01:59:44 <skew> lhs2tex is great, if you have some lhs
02:03:49 <ProfTeggy> kosmikus, is this an agreement to help with the work on the TXIH idea? :-) 
02:10:49 <ski> > map chr [0x77,0x62]
02:10:50 <lambdabot> "wb"
02:16:10 <Si\Uni> is there anyway of figuring out the fully qualified name of type from its TypeRep?
02:20:23 <shapr> That would be nice.  You'd be able to pass types around on the wire.
02:21:25 <Si\Uni> I really could do with either an Ord instance or hashing algorithm so I can store them in an efficient map
02:31:38 <shapr> Several times I've wished for access to the typetable inside GHC.
02:34:07 <Si\Uni> I think I'll just have to made do with hash of the string given by show
02:40:52 <tic> How do you deal with references in, say, a tree structure? Say you want to reference another tree at two leafs.
02:44:22 <nooga> hi
02:44:36 <nooga> i'm new to haskell
02:44:54 <ProfTeggy> nooga, we like you anyway
02:45:35 <nooga> I'm reading Yet Another H Tutorial and playing with ghci atm
02:45:58 <nooga> tutorial says that to define function i can just type: f x = x*2
02:46:08 <ProfTeggy> And rightly so!
02:46:15 <nooga> but ghci forces me to write: let f x = x*2
02:46:34 <ProfTeggy> Yes, to define values at the ghci prompt, you need to use let.
02:46:42 <nooga> mhm
02:46:47 <Saulzar> You'll have to put that in a file and load it to directly define stuff
02:46:47 <ProfTeggy> In an Haskell script, you can just write 'f x = ...'
02:47:05 <nooga> thank you
02:47:07 <ProfTeggy> Haskell scripts live in *.hs files (or .lhs, but that's a different story)
02:47:27 <nooga> ah yes, i just wondered what is literate Haskell
02:47:36 <nooga> or something like this 
02:47:50 <ProfTeggy> It's a specific variant of Haskell script where the role of comments and code has been swapped.
02:48:02 <ProfTeggy> Lines prefixed by '> ' contain code.
02:48:07 <ProfTeggy> All other lines contain comments.
02:48:18 <ProfTeggy> These are literate Haskell (or .lhs) scripts.
02:49:00 <nooga> so it must be easy to change .lhs to .hs and vice versa
02:49:06 <shapr> From my viewpoint, Haskell code can be so expressive that it makes sense to have special delimiters for the content rather than the comments.
02:49:25 <ProfTeggy> nooga, you can certainly transform between both, yes.
02:50:38 <nooga> btw. Haskell seems very good for writing parsers
02:50:53 <ProfTeggy> You bet.
02:50:56 <shapr> My experience agrees with that.
02:51:13 <ProfTeggy> Haskell is good for writing foo for many instantiations of foo.
02:51:24 <nooga> hehe
02:51:28 <shapr> Nowadays when I see long IBM Developerworks articles about writing recursive parsers in $LANGUAGE, I just grin and think about Parsec.
02:55:52 <nooga> wohoa
02:56:09 <nooga> I think I like Parsec :D
02:56:45 <nooga> looks much better than lex&yacc with C
02:58:34 <ibid> hrm
02:58:45 <ibid> anybody know any good monad-related exercises? ;)
02:59:52 <sieni> parsec is nice
03:00:47 <nooga> g2g, bye
03:05:23 <tuomov> yeah, parsec is nice
03:07:13 <shapr> ibid: Already tried the sheep from nomaware and Steve Atkins step-by-step rewriting of an explicit interpreter to a monadic version?
03:30:47 <dcoutts> JohnMeacham, so what's the overhead that concurrency would impose in JHC? I understand that it'd need more runtime stuff to do the IO multiplexing etc, but what would it impose on ordinary single threaded code?
03:39:14 <benny_> lisppaste2: help
03:39:14 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:41:29 <benny_> hello, is the best way to improve this code to use the State monad? if so how would i do it?
03:41:41 <lisppaste2> benny pasted "state" at http://paste.lisp.org/display/16376
03:47:27 <Saulzar> Something like,  foo = do modify f; modify g; modify h
03:48:16 <benny_> hm...
03:49:24 <benny_> without do that would be,  foo = mofity f >>= modify g >>= modify h
03:49:25 <Saulzar> Or make f g and h primitives themselves of type State ... most liekly you have 1 or two routines which modify the state which you can seperate out.
03:49:25 <benny_> ?
03:49:59 <Saulzar> >> rather than >>=    (>>= binds a variable)
03:50:08 <benny_> hm...
03:51:07 <jethr0_> @hoogle \(r:cs) -> (r,cs)
03:51:07 <lambdabot> hoogle: Unexpected character when parsing: \(r:cs) -> (r,cs)
03:51:07 <lambdabot>  
03:51:12 <JohnMeacham> dcoutts: it depends on the type of concurrency.
03:51:34 <dcoutts> JohnMeacham, preemptinve, like ghc
03:51:39 <Saulzar> benny_, Have you had a look at the state example in All about Monads? 
03:52:01 <dcoutts> JohnMeacham, well, preemptive for threads that allocate memory occasionally
03:52:04 <benny_> Saulzar: sort of
03:52:05 <JohnMeacham> dcoutts: concurrency as ghc implements it now would likely not be possible. cooperative may or may not be, I am not sure. I do want to support some form of concurrency, but it may end up not looking like ghcs version.
03:52:11 <Saulzar> If you cut out all the random number stuff, and play around with the simple example 
03:52:39 <dcoutts> JohnMeacham, but don't you also have to put things in a consistent state before asking the memory manager for another chunk of memory?
03:52:59 <dcoutts> JohnMeacham, does that not give an opportunity to do a thread switch?
03:53:32 <JohnMeacham> dcoutts: it would be a problem for any implementation not based on self-executing thunks. and the runtime machinery needed to ensure things like work isn't duplicated is substantial.
03:53:42 <ndm> @type \(r:cs) -> (r,cs)
03:53:43 <lambdabot> forall a. [a] -> (a, [a])
03:53:51 <ndm> @hoogle [a] -> (a, [a])
03:53:52 <lambdabot> No matches, try a more general search
03:54:19 <JohnMeacham> dcoutts: but what if the new thread starts evaluating a thunk that was already halfway through evaluating by another one?
03:55:26 <dcoutts> JohnMeacham, right, so it's not the problem of getting an opportunity to re-schedule but how to allow threads to use the same thunks/values without too much overhead.
03:55:42 <JohnMeacham> halfway through being evaluated I should say.
03:55:48 <dcoutts> JohnMeacham, so how does ghc's self-executing thunks allow that?
03:56:20 <JohnMeacham> dcoutts: yeah. that is the main one.
03:56:43 <dcoutts> JohnMeacham, the other possability is to just let some duplicated work happen, that's what the nwe smp ghc rts does, though it tries to minimise it.
03:57:30 <dcoutts> JohnMeacham, so perhaps if the "no duplicate work" is relaxed slightly it might be possible?
03:57:51 <JohnMeacham> dcoutts: it would be an issue for most implementations I think. ghc has a particularly advanced runtime that makes things like imprecise exceptions and concurrency possible, but they could be extremely difficult with other models. ghcs runtime imposes some heavy costs, but it makes good use of them. I'd hate to rule out other models though in the language spec.
03:58:42 <dcoutts> JohnMeacham, sure, there's certainly room for the Haskell equivalents of both ocaml and mlton.
03:59:00 <JohnMeacham> dcoutts: perhaps. but I worry about other execution models that might be invented in the future. I'd like to see concurrency as a standardized option, not as a requirement for the language.
03:59:23 <dcoutts> JohnMeacham, I was just wondering what the issue was with the leaner haskell execustion models
04:01:38 <JohnMeacham> dcoutts: since ghcs thunks can contain pointers to arbitrary code, it can just place context switching code in thunks it is currently evaluating, so if they are reentered, the context gets switched automatically. jhc just calls the appropriate evaluation routine directly so there isn't a place to "hook in".
04:03:05 <dcoutts> JohnMeacham, oh I see so if a thread would be about to re-evaluate a thunk then it get's context switched to let the original thread complete the evaluation of the thunk and the clling thread blocks until that is done.
04:03:44 <dcoutts> yeah that's neat, and does take advantage of the extra indirection
04:04:26 <dcoutts> JohnMeacham, I am sympathetic to the point about a lot of perf problems on modern cpus being due to taking indirect jumps
04:04:34 <dcoutts> since it stalls the pipeline
04:05:18 <JohnMeacham> I think it was equal to the cost of 22 instructions on the pentium II, and more on modern CPUs... I have a paper somewhere that is specifically about implementing abstract machines.
04:05:53 <dcoutts> JohnMeacham, perhaps it could be done by a runtime test (where the outcome is predicted to be false) when the ealuator enters a thunk?
04:06:10 <dcoutts> jumps that are correctly prdicted are cheap
04:06:12 <JohnMeacham> which is why I was so horrified that the inner loop of the simple accumulating factorial had 2 indirect jumps in it! when it should be 3 instructions with no memory accesses at all.
04:06:23 <dcoutts> yeah, right
04:06:35 <JohnMeacham> dcoutts: indirect jumps are never predicted.
04:06:38 <dcoutts> indeed
04:06:45 <JohnMeacham> only conditional ones are.
04:06:48 <dcoutts> yes
04:07:02 <dcoutts> I mean a flag inside the thunk that could be set and tested
04:07:16 <dcoutts> it says "I'm already being evaluated!"
04:07:29 <JohnMeacham> dcoutts: well, thats the thing, there is no concept of thunk or evaluation point by the time it gets to grin, most evals have been optimized completely away.
04:07:32 <dcoutts> testing that with the expectation that it's false would be cheap for the normal case
04:07:38 <dcoutts> oh, ok
04:08:09 <dcoutts> I'm not sufficiently familiar with jhc :-)
04:09:25 <JohnMeacham> yeah, it would be interesting to come up with a type system that enforced 'strict interfaces' because if you can guarentee only strict values are passed between threads, then you don't have issues. it would also be good for calling ml code or strict language code directly. though, this is not a very well thought out concept.
04:10:23 <dcoutts> JohnMeacham, SPJ has a paper on a core that'd be common between ML and Haskell style languages/compilers/runtimes
04:10:37 <dcoutts> so that conversion of ML->HS is a noop
04:10:45 <dcoutts> and HS->ML is a deepseq
04:11:23 <dcoutts> or to allow some future language that is more of a mixture of strict/lazy
04:11:48 <JohnMeacham> dcoutts: yeah, I saw that, it was interesting.
04:22:02 <MarcWeber> Have you ever heard of an RTS command?
04:22:30 <MarcWeber> RTS some options Parser.y? Where does it belong to?
04:24:48 <kosmikus> ProfTeggy: TXIH: I don't exactly suffer from a lack of projects right now, but you're welcome to try to convince me :)
04:27:08 <ProfTeggy> kosmikus: I'll take a look at this these days (starting now), trying to come up with a strategy and then come back to you, OK?
04:29:06 <ProfTeggy> I'm off for a meeting, bbiab
04:40:15 <jethr0_> hmm, i've written this rather dense popen code. but i keep getting SIG_PIPEs...
04:40:32 <jethr0_> would "waiting" between reads/write help, you think?
04:43:52 <bosie> howdy
04:44:17 <bosie> monad question: why is the >@> operator for monads so important ?
04:48:47 <bosie> monad question: why is the >@> operator for monads so important ?
04:50:25 <Saulzar> I've never seen a >@> operator, where is it from?
04:51:07 <bosie> well here we go:
04:51:37 <bosie> >@>:: Monad m -> (a -> m b) ->
04:51:43 <bosie> (b -> m c) ->
04:51:53 <bosie> (a -> m c)
04:52:31 <bosie> we did define that at university, and i am wondering what exactly it does do and why i would even define such a method (our prof called it an specical haskell/monad function)
04:56:05 <earthy> that type seems wrong. could it be  >@> :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)  ?
04:56:11 <earthy> plus, it's very simple
04:56:32 <bosie> i did write the same tho
04:56:47 <integral> that's >>> for Kleisli arrows...
04:56:49 <bosie> ah yea
04:56:56 <bosie> you are right it was =>
04:57:27 <bosie> kleisli ?
04:57:53 <bosie> earthy,  what does it do ? it randomly returns a container/monad of type c although i "feed" it with a ?
04:58:03 <earthy> bosie: it does not
04:58:07 <bosie> hm
04:58:22 <integral> newtype Kleisli m a b = Kleisli (a -> m b)
04:59:00 <earthy> >@> f g = \a -> f a >>= g
04:59:19 <bosie> isnt that functioncomposition for monads?
04:59:26 <earthy> almost
04:59:50 <bosie> almost ?
04:59:53 <integral> arrows are a sort of generalisation of functions in that regard, where (>>>) is like flip (.)
04:59:55 <bosie> some important part missing
05:00:23 <earthy> oh, there is also function composition for monads
05:00:32 <earthy> which is different, and works on functions on monads
05:00:44 <earthy> this is functions injecting into monads
05:00:51 <shapr> kosmikus: Silly question, why don't you and ProfTeggy use german with each other?
05:00:52 <earthy> and a mode of composing those
05:02:02 <bosie> hmmm
05:02:15 <bosie> i guess i take it as an answer and learn it ;)
05:02:29 <shapr> Too bad irc doesn't include metadata like which languages you prefer to speak.
05:02:37 <shapr> I wonder if SILC could do that...
05:03:17 <bosie> thank you earthy 
05:03:44 * earthy tunes in the offspring with 'come out and play'
05:04:04 <earthy> (you gotta keep 'm separated)
05:05:06 <earthy> basically, (.) also has type  (m a -> m b) -> (m c -> m a) -> m a -> m b
05:05:16 <earthy> which is function composition for monads... :)
05:06:10 <integral> @karma+ Data.Typeable -- comp :: (a -> b) -> (b' -> c) -> Maybe (a -> c)
05:06:10 <lambdabot> Data.Typeable's karma raised to 1.
05:06:27 <benny_> 2 ??? (+1)
05:06:41 <benny_> what do i use instead of ??? so that 2 is applied to the (+1) function and i get result 3?
05:07:25 <oxygene> hi
05:08:17 <aleator> @pl \x y -> y x
05:08:17 <lambdabot> flip id
05:08:24 <oxygene> what's necessary to get a ghc-6.4.1 tree to generate the .hc files that I need for a build on a different OS (same arch)? I built ghc, but there's only one .hc file in the entire tree...
05:09:12 <aleator> benny_: let (<>) = (flip id) in  2 <>  (+1)
05:09:40 <integral> why (flip id) instead of the more obvious (flip ($)) ?
05:10:22 <aleator> integral: Because I typoed that first and then didn't bother to think :)
05:10:29 <integral> :)
05:10:58 <integral> ($ 2) (+ 1)
05:11:34 <benny_> > 2 (flip id) (+1)
05:11:34 <SamB> dcoutts: I'm not sure what would have been more ideal...
05:11:35 <lambdabot>   add an instance declaration for (Num ((b -> (b -> c) -> c) -> (a -> a) -
05:11:35 <lambdabot> > a1))
05:11:35 <lambdabot>   In the definition of `scj': scj = 2 (flip id) ((+ 1))
05:11:35 <lambdabot>   In the definition of `v':
05:11:44 <benny_> > (+1) 2
05:11:45 <lambdabot> 3
05:12:05 <benny_> > ($ 2) (+1)
05:12:06 <lambdabot> 3
05:12:40 <Igloo> oxygene: Probably best to follow the instructions for porting to a new arch in the building guide
05:12:59 <aleator> benny_: you can't use expressions as misfix? (Whats the right word for this?)
05:13:16 <dcoutts> SamB, what are you doing then? Z thingy?
05:14:03 <benny_> > 2 `(flip id)` (+1)
05:14:04 <lambdabot>  parse error on input `('
05:14:13 <benny_> aleator: "infix" i think :)
05:14:21 <benny_> (flip id) 2 (+1)
05:14:27 <benny_> > (flip id) 2 (+1)
05:14:28 <lambdabot> 3
05:14:54 <SamB> dcoutts: yeah, that Z thingy
05:14:56 <frobenius_> Problem: I get illegal instance declaration for a Show instance when important type constructors from two different modules. Is this normal? I use Name(..) for export
05:15:11 <oxygene> Igloo: thanks, thought that was for an initial port only
05:15:14 <dcoutts> SamB, I don't know what that Z thingy is! :-)
05:15:38 <vincenz> gour: leo editor?
05:15:39 <SamB> basically, I want to let the user edit most of the last line of the text
05:15:45 <aleator> benny_: Ah. confused it with prefix. Friday evening.. Hour before getting home from work.. 
05:16:06 <SamB> you know how in the shell you can't backspace over the prompt or anything like that?
05:16:37 <vincenz> SamB: you could take a look at ledit
05:17:05 <dcoutts> SamB, you can make just the last line of text in a text view editable
05:17:19 <SamB> vincenz: not the thing called Z
05:17:27 <vincenz> ?
05:17:34 <SamB> dcoutts: well, I don't want the prompt to be editable, exactly...
05:17:43 <vincenz> Z?
05:17:51 <SamB> vincenz: what is ledit?
05:17:52 <dcoutts> SamB, you can make arbitrary ranges of text ediable or non-editable
05:17:53 <frobenius_> are we allowed to mix type constructors from different modules in type class instantiations? particularly for Show ... ?
05:17:56 <gour> vincenz: http://leo.sourceforge.net/ (bbl, lunch-time)
05:18:27 <SamB> dcoutts: but it doesn't seem to work well with empty ranges, sadly :-(
05:18:40 <dcoutts> SamB, I don't understand
05:18:51 <vincenz> SamB: it's a single-line line editor that you can use to wrap other tools (it's typically used with ocaml, it's written in ocaml)
05:19:12 <vincenz> not the word processor you find while googling
05:19:50 <SamB> vincenz: I don't think that will work well
05:20:14 <SamB> I'm writing a Z-machine interpreter, trying to implement the "read" opcode at least partly...
05:20:22 <vincenz> http://caml.inria.fr/cgi-bin/hump.en.cgi?contrib=301
05:20:26 <SamB> anyway, my current solution is to use an Entry
05:23:35 <dcoutts> SamB, that sounds reasonable
05:23:46 <kosmikus> shapr: why don't earthy and dblhelix use Dutch when they are talking on this channel?
05:24:42 <vincenz> waarom moeten ze dan nederlands spreken?
05:25:05 * dcoutts wants to learn Dutch
05:25:29 <vincenz> dutch is a useless language
05:26:20 <SamB> dcoutts: I figure if MUD clients can get away with it, I can do it too
05:26:31 <frobenius_> why is dropWhile primitive recursive?
05:26:39 <dcoutts> SamB, yeah, most irc clients do that too
05:26:43 <jethr0_> ick kenn garkeen nederlands spreken, det wör mer vel zu schwer zu lernige.
05:26:57 <SamB> dcoutts: true
05:27:31 <SamB> though it is not by any means ideal...
05:27:48 <SamB> for an infocom interpreter, I mean
05:27:53 <jethr0_> vincenz: hey, hard at work :)
05:28:19 <frobenius_> is there something special about Show instances in module exports at all? I am having some bizarre problems here
05:28:42 <SamB> frobenius_: you can't hide instances
05:28:56 <SamB> they are pretty well nigh global across all modules
05:29:07 <jethr0_> vincenz: it was definitely a good way we implemented the "Basics". that made writing the server much easier!
05:29:18 <frobenius_> That was clear from The Report too, yes, but now I import from two different modules A and B and then write a new show instance which uses a type constructor from A applied (higher order) to a type constructor from B
05:29:38 <SamB> frobenius_: oh?
05:29:42 <SamB> and what happens?
05:29:48 <vincenz> jethr0_: cool :)
05:30:44 <frobenius_> SamB, it says illegal instance declaration for 'Show (MyType (MySecondType MyThirdType))' ... The instance must be of form (T a b c) where T is not a synonym etc etc    ... I get this for all Show instances
05:31:03 <SamB> ah, right
05:31:09 <frobenius_> despite having module FirstImportedModule (MyType (..)) where ...
05:31:10 <frobenius_> etc
05:31:25 <benny_> man where is Cale when you need him :\
05:31:27 <SamB> you are only supposed to have one contstructor per instance
05:31:35 <SamB> type constructor, that is
05:32:09 <SamB> there is actually a very good reason for this
05:32:27 <frobenius_> but it worked fine before I split it up into three modules
05:32:35 <frobenius_> I have {-# OPTIONS -fglasgow-exts #-}     too
05:32:52 <SamB> did you have three type constructors at that point?
05:32:52 <frobenius_> but in literate mode, so perhaps the problem is that I now need >  (I was in .hs mode before) ... Yes, That's gotta be it
05:33:29 <frobenius_> yes, thanks SamB, that worked
05:33:36 <SamB> hmm?
05:33:39 <frobenius_> yes I did
05:33:45 <SamB> I didn't do anything!
05:33:49 <sieni> Any yhc folks here? Is there any fundamental problems in compiling standard ml to haskell bytecode?
05:33:55 <SamB> are you using overlapping/undecidable instances?
05:34:08 <frobenius_> ;-) anyway (better be polite on irc, never know who you speak to)
05:34:30 <SamB> do I look like a Simon?
05:34:31 <frobenius_> not that I am aware of
05:34:38 <frobenius_> PJ?
05:34:43 <SamB> it says clearly Sam in my name
05:34:48 <SamB> Sam, not Simon!
05:35:05 <frobenius_> sure
05:35:09 <SamB> if you look at my RealName, it is Samuel Bronson
05:35:16 <frobenius_> congratulations.
05:35:19 <sieni> would you like green eggs and ham?
05:35:48 <frobenius_> thanks Samuel anyways.
05:35:51 <SamB> hehe
05:36:03 <SamB> I was trying to help but you fixed it yourself :-(
05:36:55 <frobenius_> yes - but I asked questions criticising lisp in the lisp channel (and did not know what the REPL was) and got banned from pure politeness with the comment "we do not welcome closed minds" ... argh.
05:37:06 <SamB> oh, okay
05:37:14 <SamB> that is clearly messed up
05:37:17 <ndm> sieni, i guess i'm a Yhc folk :)
05:37:26 <frobenius_> irc is not decidable.
05:37:33 <SamB> but you know they are probably old and bitter
05:37:46 <frobenius_> yes, I got a little bit upset actually by that.
05:37:52 <ndm> i can't think of any fundamental problems in ML -> .hbc, but it would probably be a lot slower since .hbc is designed for lazy languages
05:37:56 <frobenius_> but nevermind - I am new to irc, I guess there are fights and such all the tijme
05:38:01 <SamB> what was the question?
05:38:14 <ndm> a better bet would be Clean's .abc format, since that does have strict calling
05:38:41 <frobenius_> what can be done with Ocaml's object model anyway? (if one may discuss Ocaml for a while, for comparison with Haskell, that is)
05:38:56 * SamB doesn't know Ocaml
05:39:52 <frobenius_> SamB, I guess the main problem was that there was no question at all, but evidently I started a (in my opinion interesting) discussion  about Lisp's ability to e.g. update its own code
05:40:13 <frobenius_> ;-)
05:40:20 <frobenius_> trauma here
05:40:51 <SamB> frobenius_: oh, right
05:40:58 <SamB> I think you mentioned that before
05:41:08 <frobenius_> I am in a REPL loop
05:41:13 <frobenius_> ;-) bye
05:41:25 <SamB> somebody brought up CLOS, which is wierd
05:41:44 <SamB> because I don't see what the commonality is between CLOS and self-updating code
05:41:44 <frobenius_> but rather interesting with its pre and postmethods imo
05:42:41 <frobenius_> apart from the meta object protocol etc the relationship to self-updates is probably quite deep down in the theory, but nevermind that
05:42:49 <frobenius_> (untyped lambda calculus have Y combinator etc)
05:43:11 <frobenius_> gotta work now, SamB
05:43:45 <shapr> kosmikus: I don't know...
05:44:51 <frobenius_> sometimes it is good not to know
05:46:05 <earthy> shapr: the reasons are varied. 1. using english is almost as easy 2. it's more polite 3. switching languages takes more effort than staying within one language 4. language usage is context defined
05:46:20 <earthy> e.g.: I wouldn't use english when speaking to dblhelix face to face
05:46:58 <earthy> (2 is in relation to others)
05:51:17 <ADEpt> @hoogle [a] -> ([a],[a])
05:51:18 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
05:51:18 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
05:51:18 <lambdabot> Graphics.UI.ObjectIO.CommonDef.split :: Int -> [x] -> ([x], [x])
05:53:11 <ndm> @hoogle partition
05:53:11 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
05:53:11 <lambdabot> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
05:53:11 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
05:53:23 <shapr> Strange, it doesn't cost me any mental effort to switch languages.
05:53:38 <shapr> I do try to useful patterns from one language in all the languages I speak/write.
05:54:42 <shapr> My Python code looks like Haskell, and my English is starting to have Swedish structures.
05:55:35 <benny_> i wish my haskell code looked more like python, i'm trying to convert some python code to haskell and it's really ugly :(
05:56:33 <shapr> Have a short chunk of that python code I can look at?
05:56:46 <benny_> shapr: yeah
05:57:06 <benny_> shapr: problem is it's very stateful
05:57:13 <shapr> I started with Python about when 1.5 was released, and started with Haskell nearly five years ago.
05:58:21 <xerox> What does that code do?
05:58:36 <benny_> shapr: http://rafb.net/paste/results/qd7YLX83.html
05:58:47 <benny_> xerox: does simple physics simulation of a car
05:59:06 <xerox> Woot.
05:59:22 <earthy> shapr: ah, but then you're commingling languages...
05:59:53 <benny_> i am breaking up each 2-5 lines of that python code into a 5-10 line haskell function :(
05:59:55 <earthy> there's a number of 'interesting' mistakes speakers of dutch manage to make when switching to english naively
06:00:16 <shapr> benny_: I think you can turn that chunk of code into about ten lines of Haskell.
06:00:47 <earthy> 'what do you do for a living?' -- 'I fuck horses' (where the dutch native speaker thought that 'to fuck' was a good translation of 'fokken', which is better translated with 'to breed')
06:00:58 <benny_> shapr: yes, i also think that it is eventually possible but it will take me several revisions. i am not an expert haskell programmer yet :(
06:01:46 <earthy> benny: then you're probably binding yourself to the low-level implementation of your data
06:01:56 <earthy> sounds like you haven't abstracted the operations you need yet
06:01:57 <shapr> benny_: Can you generalize wheelSpacing to a wheelDistance function?
06:02:48 <benny_> shapr: i don't think it's needed, wheelSpacingX and wheelSpacingY are both constants
06:03:22 <benny_> shapr: but take for instance the 4 Particle.solveStickConstraint calls, the first 2 arguments are modified
06:03:32 <benny_> shapr: so in haskell i have to thread this state through the 4 calls
06:04:08 * earthy nods. that's *exactly* where your problem is. you're running the entire calculation within the state representing your car
06:04:45 <benny_> earthy: yeah, and the CarState is a record and so modying it each time is a real pain using the record syntax
06:05:20 <earthy> you might want to transform that into a calculation running on a list of all consecutive states the car will be in, calculating each one from the previous
06:05:23 <shapr> I'd probably generalize wheelSpacing so I could build all sorts of cars, and vehicles with more or less than four wheels, but if you prefer it the way you have it...
06:06:10 <shapr> I'd cut the non-changing car state out into a reader monad, and stuff that inside a read/write monad. lambdabot does that for example.
06:06:27 <benny_> earthy: that might be difficult since i am using yampa for maintaining the actual state
06:06:34 <earthy> hm. right.
06:06:51 <shapr> But you can give yampa arrows a state changing function, and they do it all for you.
06:06:59 <shapr> Have you looked at the space invaders demo?
06:07:11 <earthy> what shae says. :)
06:07:24 <SamB> the space invaders demo doesn't build right unless you make a lot of changes...
06:07:35 <earthy> let the framework do the work for you
06:07:36 <shapr> I think I had the patches around here somewher.
06:07:41 <benny_> shapr: yeah, i want the actual car stepping function to be independant from yampa though, it is stepCar :: CarState -> CarState
06:07:53 <SamB> and it is too hard to hit the aliens
06:07:57 <shapr> hah
06:08:08 <shapr> SamB: I tried running it with 2k aliens. That was fun.
06:08:31 <shapr> I quickly realized it wasn't exploiting the shortcut semantics of arrows.
06:09:05 <SamB> shortcut?
06:09:11 <shapr> benny_: That's pretty much what you have to do to use it with yampa. Yampa arrows get composed with the step functions. That's pretty much how it works.
06:09:31 * shapr opens the paper to get references...
06:10:13 <shapr> SamB: Yeah, the great benefit of arrows is that they can get around the halting problem in a limited fashion.
06:10:40 <kosmikus> shapr: I was thinkin mainly of reason 2 from the list that earthy gave.
06:10:49 <shapr> kosmikus: ok, I see your point.
06:10:50 <kosmikus> /s/thinkin/thinking/
06:10:55 <benny_> shapr: i already have the yampa "integration" working
06:11:12 <shapr> kosmikus: My viewpoint is different because I like to hear a variety of languages.
06:11:23 <benny_> shapr: and i sort of have collision detection with the terrain working, so the car falls onto the terrain and rolls around :D
06:11:28 <shapr> benny_: wow, cool!
06:11:34 <shapr> That's impressive!
06:11:53 <shapr> I wanna see!
06:12:22 <shapr> kosmikus: I'll try to remember that, maybe other people think I'm being impolite when I switch among languages.
06:15:08 <benny_> shapr: here's a screenshot:
06:15:14 <shapr> Of course, maybe other people enjoy speaking a variety of languages too... that could explain why they would use English.
06:15:43 <shapr> Was it an ASCII screenshot?
06:15:49 <shapr> tuomov: y0, ion roxx.
06:15:53 <aleator> He shot his screen..
06:15:58 <shapr> :-)
06:16:46 <SamB> but it says "lost terminal"
06:16:46 <benny> oops... still gotta get used to this window manager
06:17:12 <SamB> you need to do more than just shoot your screen to convince the computer that you have lost your terminal
06:17:14 <benny> shapr: here's a screenshot, unfortunately there's something screwy with the surface normals of the terrain that i haven't figured out yet so the lighting is a bit weird:
06:17:24 <benny> http://img96.imageshack.us/img96/7723/drivedrive0010tu.png
06:17:33 <oxygene> SamB: depends on the terminal used
06:17:38 <shapr> wow spiffy!
06:19:51 <benny> shapr: this is what it will eventually look like(this is the python version):
06:19:53 <benny> http://img312.imageshack.us/img312/7599/screenshot8vn.jpg
06:21:01 <SamB> oxygene: I suppose
06:21:30 <ProfTeggy> re
06:22:13 <shapr> benny: neat
06:24:44 <SamB> that title bar looks quite messed up
06:25:07 <SamB> it almost looks like shift JIS
06:26:31 <benny> SamB: yeah, i'm not sure yet if it's a bug in SDL, a bug in lemmih's SDL bindings, or a bug in my window manager
06:27:21 <SamB> benny: it could be none of the above...
06:27:36 <SamB> but just an ambiguity
06:28:14 <benny> cosmic rays
06:28:26 <shapr> @seen darius
06:28:27 <lambdabot> I haven't seen darius.
06:28:33 <benny> i'm pretty sure that it's a bug in the haskell sdl bindings
06:28:34 <shapr> Man, I need to talk to Derek Elkins.
06:30:42 <kosmikus> ProfTeggy: shapr moechte, dass wir uns kuenftig auf deutsch unterhalten. er liebt die kulturelle vielfalt, sagt er.
06:30:45 <vincenz> is there an efficient way to read binary files byte/by/byte
06:30:52 <shapr> yay!
06:31:12 <vincenz> benny: what is that screenshot?
06:32:07 <vincenz> what's an efficient way to read a byte
06:32:14 <vincenz> or four bytes
06:32:24 <vincenz> (32bit values)
06:37:44 <benny> vincenz: it's supposed to be a car :)
06:37:54 <vincenz> benny: ah :)
06:39:22 <benny> @seen dons
06:39:22 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 7 hours, 48 minutes and
06:39:22 <lambdabot> 3 seconds ago.
06:40:34 <bosie> whats the name of the manual on the utrecht's website?
06:40:40 <Itkovian> right, and now in english?
06:40:49 <Itkovian> hmm, oops
06:40:57 <vincenz> so how do you read in binary data?
06:41:00 <Itkovian> my scrollbar was not located at the bottom
06:41:06 <bosie> @search uu
06:41:07 <lambdabot> Unknown command, try @listcommands.
06:42:36 <bosie> i need the monad list manual guys please
06:43:29 <shapr> bosie: http://www.nomaware.com/monads/
06:45:37 <bosie> shapr i know there is a list showing ie the list monad, io monad etc
06:45:40 <bosie> but cnat find it so far
06:46:09 <shapr> http://www.nomaware.com/monads/html/introII.html
06:47:04 <bosie> thank you very much
06:47:24 <shapr> When in doubt about monads, check out the nomaware guide.
06:47:49 <vincenz> anyone know how to read in binary data from a file
06:47:50 <bosie> kk
06:48:26 <shapr> vincenz: Lots of discussion about that on the mailing lists in december. You can probably find more info on google.
06:51:28 <bosie> shapr,  do you know by any chance the word "constructor class" ?
06:51:52 <bosie> which is by definition a class which elements are from type type constructors
06:52:48 <xerox> Howdy bosie :-)
06:54:36 <bosie> howdy ;)
07:00:55 <xerox> shapr: how was called the timer looking like that thing filled with sand?
07:00:58 <xerox> Ah, sand-hur.
07:01:08 <shapr> sanduhr
07:01:51 <shapr> hourglass or sandglass in english - http://c2.com/cgi-bin/wiki?SandglassProgramming
07:02:00 <xerox> It would be nice to port it to Gtk2+Cairo.
07:03:05 <shapr> Yeah, you could do lots more with it then. I always wanted it to support skins that would gradually fill according to shading, and allow animations. That way I could make a bomb with a fuse that burns down =)
07:04:07 <xerox> ...but then, every time you think about it, your sandhurs are all about to yell 'focus!', right?
07:04:56 <bosie> who is using sanduhrs anyway ;)
07:05:15 <bosie> i hope you do not use them to get the starting time of the olympic events :D
07:06:48 <xerox> The sandhur program is pretty nice, I just ran 'sandhur -m Mousse! +1h'
07:15:18 <shapr> xerox: Yes, two points.. When I get distracted, I realize the sanduhr is there to show I'm doing something time-critical.  Also, when I know I need to have something done in five minutes, I take the shortest path rather than considering all the options and possibly taking two days extra to write a new library that will save me four of those five minutes for the rest of my life.
07:17:21 <xerox> So the answer is that we need a more powerful, extendable, and pretty looking, Haskell sandhur.
07:17:48 * vincenz adds something to the haskellwiki page concerning hoogle
07:18:29 <nooga> how to get n-th element of list?
07:19:27 <shapr> nooga: !!
07:19:42 <vincenz> where does hoogle store it's actual data?
07:19:49 <shapr> I wish english had different words for from zero and from one.
07:20:00 <nooga> what is the index operator? i tried: let a = [1,2,3]; show a[1]
07:20:07 <nooga> ut it's wrong
07:20:16 <earthy> show (a !! 1)
07:20:20 <nooga> omigosh
07:20:38 <nooga> thanks
07:20:43 <earthy> > let a = [1..5] in a !! 1
07:20:44 <lambdabot> 2
07:21:00 <xerox> > [] !! 1
07:21:00 <lambdabot> Add a type signature
07:21:04 <xerox> > [] !! 1 :: ()
07:21:05 <lambdabot> Exception: Prelude.(!!): index too large
07:21:12 <xerox> > [] !! (-1) :: ()
07:21:13 <lambdabot> Exception: Prelude.(!!): negative index
07:21:20 <earthy> > [] !! 0 :: ()
07:21:21 <lambdabot> Exception: Prelude.(!!): index too large
07:21:25 <xerox> Take care.
07:21:31 <xerox> Take extra care.
07:21:40 <nooga> > [1..6] !! [2..3]
07:21:40 <lambdabot> Couldn't match `Int' against `[a]'
07:21:53 <vincenz> nooga: like this maybe
07:22:29 <vincenz> > let a !!! b = map (\i -> a !! i) b in [1..6] !!! [2..3]
07:22:30 <lambdabot> [3,4]
07:22:35 <xerox> > [2..3] >>= ([1..6] !!)
07:22:36 <lambdabot>  add an instance declaration for (Num [b])
07:22:36 <lambdabot>   In an arithmetic sequence: [1 .. 6]
07:22:39 <xerox> Hmpf.
07:22:44 <xerox> > [2..3] >>= return . ([1..6] !!)
07:22:45 <lambdabot> [3,4]
07:22:50 <nooga> ooh
07:23:21 <vincenz> > let a !!! b = map (a !!) b in [1..6] !!! [2..3]
07:23:22 <psi> > map ([1..6] !!) [2..3]
07:23:23 <lambdabot> [3,4]
07:23:23 <lambdabot> [3,4]
07:23:36 <vincenz> > let a !!! b = map (a !!) b in ['a'..'z'] !!! [2..3]
07:23:37 <lambdabot> "cd"
07:23:54 <nooga> can i overload operators in haskell?
07:23:58 <xerox> aha!
07:24:05 <earthy> nooga: yes, you can
07:24:12 <earthy> not all though
07:24:22 <vincenz> who is neil mitchell
07:24:27 <shapr> ndm
07:24:28 <earthy> only those that you put in classes, or that already are in classes
07:24:41 <xerox> > (fmap . (!!)) ['a'..'z'] [0,25]
07:24:42 <lambdabot> "az"
07:24:43 <xerox> Nice eh?
07:24:58 <earthy> schweet, yeah
07:24:58 <xerox> (!!!) = fmap . (!!)
07:25:05 <vincenz> hmm
07:25:10 <vincenz> @type fmap
07:25:11 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
07:25:13 <earthy> nasty schweetness. :)
07:25:17 <vincenz> ah cool
07:25:27 <vincenz> shouldn't it be 
07:25:31 * xerox schweets.
07:25:58 <vincenz> xerox: freaky
07:26:12 <xerox> Oh yeah!
07:26:27 <vincenz> @define (!!!) = fmap . (!!)
07:26:27 <lambdabot> Unknown command, try @listcommands.
07:26:28 <xerox> It's just what you wrote, anyway.
07:26:45 <xerox> \xs ys -> map (xs !!) ys
07:26:50 <xerox> \xs -> map (xs !!)
07:27:01 <vincenz> and then
07:27:01 <xerox> map . (!!)
07:27:09 <vincenz> ah
07:27:22 <xerox> If you want to see it explictly
07:27:25 <vincenz> @type map . (!!)
07:27:25 <xerox> \xs -> map (xs !!)
07:27:26 <lambdabot> forall a. [a] -> [Int] -> [a]
07:27:27 <vincenz> @type fmap . (!!)
07:27:28 <lambdabot> forall (f :: * -> *) a. (Functor f) => [a] -> f Int -> f a
07:27:31 <xerox> \xs -> map ((!!) xs)
07:27:40 <xerox> \xs -> map . (!!) $ xs
07:27:44 <xerox> map . (!!)
07:27:49 <vincenz> I know
07:31:24 <nooga> how to make list lik this: [1,2,3,1,2,3,1,2,3,...]
07:31:29 <xerox> cycle [1,2,3]
07:32:36 <xerox> > (++"...]") $ take 18 $ show $ take 9 $ cycle [1,2,3]
07:32:37 <neologism> did you know that monad is a greece name for "unique" ?
07:32:37 <lambdabot> "[1,2,3,1,2,3,1,2,3...]"
07:32:39 <xerox> :-P
07:32:52 <xerox> Missed a coma, heh.
07:34:41 <vincenz>  > (++",..]") $ take 18 $ show $ take 9 $ cycle [1,2,3]
07:34:46 <vincenz> > (++",..]") $ take 18 $ show $ take 9 $ cycle [1,2,3]
07:34:47 <lambdabot> "[1,2,3,1,2,3,1,2,3,..]"
07:34:50 <nooga> > show $ take 5 $ [1,1/4..]
07:34:51 <lambdabot> "[1.0,0.25,-0.5,-1.25,-2.0]"
07:34:55 <nooga> why?
07:35:31 <vincenz> nooga: it's [a,b..] = a, b, b+(b-a), b+2*(b-a)
07:35:33 <vincenz> it's not a delta
07:35:33 <xerox> I was kidding.
07:35:35 <vincenz> it's the next element
07:35:37 <vincenz> nooga: 
07:35:42 <vincenz> > [1,5,..]
07:35:42 <lambdabot>  parse error on input `..'
07:35:47 <vincenz> > [1,5..]
07:35:48 <lambdabot> [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,
07:35:48 <lambdabot> 101,105,109,113,117,121,125,129,133,137,141,145,149,153,157,161,165,169,
07:35:48 <lambdabot> 173,177,181,185,189,193,197,201,205,209,213,217,221,225,229,233,237,241,
07:35:48 <lambdabot> 245,249,253,257,261,265,269,273,277,281,285,289,293,297,301,305,309,313,
07:35:48 <lambdabot> 317,321,325,329,333,337,341,345,349,353,357,361,365,369,373,377,381,385,
07:35:50 <lambdabot> [24 @more lines]
07:35:57 <vincenz> > take 10 [1,3..]
07:35:58 <lambdabot> [1,3,5,7,9,11,13,15,17,19]
07:36:12 <vincenz> > take 10 [1,1/1/2..]
07:36:13 <lambdabot> [1.0,0.5,0.0,-0.5,-1.0,-1.5,-2.0,-2.5,-3.0,-3.5]
07:36:19 <vincenz> > take 10 [1,1+1/2..]
07:36:20 <lambdabot> [1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5]
07:40:26 <nooga> how to make geometrical progression?
07:40:26 <vincenz> > (++",..]") $ (take =<< substact 1 . length) $ show $ take 10 $ cycle [1,2,3]
07:40:27 <lambdabot>  Not in scope: `substact'
07:40:52 <vincenz> nooga: easy
07:41:03 <vincenz> iterate (*3) 1
07:41:05 <xerox> Cale: ping.
07:41:10 <earthy> (++",..]") $ (take =<< substract 1 . length) $ show $ take 10 $ cycle [1..3]
07:41:10 <vincenz> >take 10 $ iterate (*3) 1
07:41:16 <earthy> > (++",..]") $ (take =<< substract 1 . length) $ show $ take 10 $ cycle [1..3]
07:41:17 <lambdabot>  Not in scope: `substract'
07:41:20 <vincenz> earthy: subtract ..
07:41:24 <earthy> > (++",..]") $ (take =<< subtract 1 . length) $ show $ take 10 $ cycle [1..3]
07:41:24 * xerox started a new game...
07:41:25 <lambdabot> "[1,2,3,1,2,3,1,2,3,1,..]"
07:41:28 * earthy noted. :)
07:41:33 <vincenz> notice the way it's generic
07:41:36 <earthy> after hitting enter. ;)
07:41:37 <vincenz> instead of previously take 18
07:41:42 <vincenz> > take 10 $ iterate (*3) 1
07:41:43 <lambdabot> [1,3,9,27,81,243,729,2187,6561,19683]
07:41:46 <vincenz> nooga: like that?
07:41:50 <nooga> mhm
07:42:01 <nooga> omg, haskell is so cool
07:42:06 <xerox> It indeed is!
07:42:09 <vincenz> :D
07:44:12 <nooga> can i define a list of function values that: l[n] = f(n) for n in N ? (used [] for indexing)
07:44:24 <xerox> "take =<< subtract 1 . length" is a Monad (->) glitch, heh.
07:44:40 <xerox> nooga: you mean two lists of same elements?
07:44:55 <vincenz> nooga: easy
07:45:00 <xerox> Ah no.
07:45:20 <vincenz> > map f [1..]
07:45:21 <lambdabot>  Not in scope: `f'
07:45:29 <vincenz> > let f = (+2) in map f [1..]
07:45:30 <lambdabot> [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,
07:45:30 <lambdabot> 29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
07:45:30 <lambdabot> 53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
07:45:30 <lambdabot> 77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
07:45:30 <lambdabot> 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
07:45:32 <lambdabot> [24 @more lines]
07:45:38 <vincenz> like that?/
07:46:03 <xerox> > map ((*2) . (+1)) [1,3,5,7]
07:46:04 <lambdabot> [4,8,12,16]
07:46:17 <nooga> OMG
07:46:32 <vincenz> > (*2)  (+1)
07:46:33 <lambdabot>  add an instance declaration for (Num (a -> a))
07:46:35 <vincenz> > (*2)  (+1) 2
07:46:36 <lambdabot>  add an instance declaration for (Num (a -> a))
07:50:05 <benny> "Error in array index" what operations will give that runtime error, and can ghc compile my code in debug mode so that it will tell me where in the source this error occurs?
07:51:06 <xerox> @type Data.Array.(!)
07:51:07 <lambdabot> Couldn't find qualified module.
07:51:07 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
07:51:07 <lambdabot> \\)?
07:51:10 <xerox> @type (Data.Array.!)
07:51:11 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
07:51:17 <xerox> @type Data.Array.array
07:51:18 <lambdabot> forall e i.
07:51:18 <lambdabot> (GHC.Arr.Ix i) =>
07:51:18 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
07:51:29 <xerox> > array (0,0) [] ! 100
07:51:30 <lambdabot>  Not in scope: `!'
07:51:35 <xerox> > array (0,0) [] Data.Array.! 100
07:51:36 <lambdabot>  Not in scope: `Data.Array.!'
07:51:51 <xerox> > (Data.Array.!) (array (0,0) []) 100
07:51:52 <lambdabot>  Not in scope: `array'
07:51:54 <xerox> Bah.
07:52:47 <nooga> . and $ and : are still werid for me, but i feel i'm gonna like them
07:52:54 <benny> you're sure that this error will only happen with an array? because i'm not using arrays
07:53:31 <vincenz> > (Data.Array.!) (Data.Array.array  (0,) []) 100
07:53:32 <lambdabot>  parse error on input `)'
07:53:36 <vincenz> > (Data.Array.!) (Data.Array.array  (0,0) []) 100
07:53:37 <lambdabot>  Not in scope: `Data.Array.array'
07:53:42 <vincenz> @hoogle array
07:53:43 <lambdabot> Data.Array.IArray.Array :: Array i e
07:53:43 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a
07:53:43 <lambdabot> i e
07:53:43 <lambdabot> Data.Array.Array :: Array i e
07:53:48 <vincenz> > (Data.Array.!) (Data.Array.IArray.array  (0,0) []) 100
07:53:49 <lambdabot>  Not in scope: `Data.Array.IArray.array'
07:54:01 * vincenz palmslaps
07:54:10 <vincenz> > (Data.Array.!) (Data.Array.Array (0,0) []) 100
07:54:11 <lambdabot>  Not in scope: data constructor `Data.Array.Array'
07:55:29 <shapr> Greetings oh Kiwi'd one.
07:56:19 <Saulzar> Hey shapr'd one :)
07:58:11 <Saulzar> How goes?
07:58:39 <jonkri> what does ambigous type mean?
07:58:48 <xerox> jonkri: that the type is not decidable
07:59:29 <shapr> The code flows...
07:59:47 <jonkri> hmm... ok
08:00:08 <jonkri> but i have specified the type
08:01:13 <xerox> Mind to tell us more details?
08:02:00 <Saulzar> What is the current project?
08:02:27 <xerox> The one we do all the night, pinky!
08:03:09 <jonkri> xerox: it's an assignment so i don't want to (may not) ask on any specifics :-(
08:03:28 <jonkri> but i understand if you can't help me with that little information
08:03:42 <xerox> @karma+ jonkri
08:03:43 <lambdabot> jonkri's karma raised to 1.
08:03:46 <xerox> ^_^
08:03:51 <jonkri> yay! :o)
08:04:02 <jonkri> thanks, h0h0
08:04:08 <xerox> That's positive karma!
08:04:40 <jonkri> :-)
08:04:56 <jonkri> and you're the god that may hand it out?
08:05:16 * xerox looks around scared, for help
08:06:02 <jonkri> xerox: ? ;-)
08:07:04 <shapr> Saulzar: trying to wring payment from clients...
08:07:38 <vincenz> > print 
08:07:39 <lambdabot>  add an instance declaration for (Show (a -> IO ()))
08:07:40 <vincenz> > print 1
08:07:41 <lambdabot> No IO allowed
08:09:33 <jonkri> i have a function which returns an Int, but i want to have an integer. can i add "::Integer" after the function? i'm getting "couldn't match..." errors
08:10:04 <nooga> how to use . ?
08:10:52 <neologism> > (+1) . (+2) 1
08:10:52 <lambdabot>  add an instance declaration for (Num (a -> b))
08:10:59 <neologism> > ((+1) . (+2)) 1
08:11:00 <lambdabot> 4
08:11:17 <xerox> nooga: f . g = \x -> f (g x)
08:11:28 <Saulzar> jonkri, Is it an Int or is it an Integer? Or do you want to convert an Int to an Integer?
08:11:49 <xerox> nooga: it's function composition, it sequences two unary functions taking the result of the second as the argument of the first one.
08:12:13 <jonkri> it's a int which i want to make an integer
08:12:15 <nooga> (f . g)(x) = f(g(x)) ? 
08:12:23 <neologism> yes
08:12:23 <nooga> like in maths
08:12:27 <Saulzar> jonkri, fromIntegral
08:12:32 <xerox> nooga: right
08:12:36 <vincenz> > fromIntegral 1 :: Int
08:12:37 <lambdabot> 1
08:12:39 <Saulzar> You can't cast numbers as you might do in C
08:12:44 <xerox> nooga: proper Haskell syntax (f . g) x = f (g x)
08:12:59 <xerox> Be back later, seeya folsk!
08:13:03 <xerox> *folks, woops.
08:13:30 <nooga> i see
08:13:32 <Saulzar> A type signature helps when it is ambiguous otherwise, but it isn't the same as a cast
08:13:56 <jonkri> thanks
08:23:26 <jonkri> if i compile a haskell program, can other people use it?
08:23:43 <vincenz> blegh, you can't cancel a darcs get
08:23:44 <Philippa> yes
08:24:08 <Philippa> and without a haskell environment or anything like that. Plain ol' binary executable
08:24:26 <essiene> hello *
08:24:48 <jonkri> Philippa: that's nice. where is the binary?
08:24:57 <essiene> ski: ping?
08:25:34 <Philippa> jonkri: wherever the compiler put it
08:25:44 <benny> a.out
08:25:55 <ADEpt> jonkri: "ghc --make src.hs" will put it in a.out
08:26:02 <Philippa> not under windows it won't
08:26:16 <ADEpt> Philippa: a.out.exe ? :)
08:26:23 <essiene> jonkri: if you use ghc you can also specify -o outfilename
08:26:27 * ADEpt haven't seen windows too long
08:26:27 <Philippa> ADEpt: nope
08:26:44 <jonkri> ok, thanks
08:26:46 <Philippa> IIRC you get main.exe or sourcefile.exe (minus the .hs)
08:26:58 <jonkri> i didn't have any binary in my local dir
08:27:03 <essiene> jonkri: ghc --make bleh.hs -o progname
08:27:18 <ADEpt> jonkri: then look for errors in ghc output
08:27:50 <jonkri> ghc-6.4: cannot use `--interactive' with `--make'
08:28:02 <Igloo> ghc, not ghci
08:28:26 <jonkri> ah!
08:28:56 <essiene> i need a take on a problem i finally solved... i want to know the behind the scenes... lemme paint the picture
08:29:14 <essiene> i wrote a function that uses the getLine action, to build a list and return it
08:29:33 <essiene> i call it from main with a function that takes a list as an arg... and i get silly type errors...
08:29:34 <jonkri> i got "Warning: output was redirected with -o, but no output will be generated because there is no Main module." but i had "main = runGame implementation" in my file
08:30:05 <essiene> but immedietly i wrap the call from main in a putStrLn call... the errors sieze to exist... and the code works
08:30:10 <vincenz> darcs failed:  Can't remove ocaml/gui/spiff
08:30:14 <Saulzar> jonkri, Try adding "module Main where" at the top
08:30:15 <vincenz> any reasons why
08:30:18 <Philippa> jonkri: you need a module called Main
08:30:29 <Philippa> although it's supposed to assume source files with no module header're Main by default
08:30:30 <essiene> any ideas? alternatively, where can i paste haskell code for review?
08:30:48 <jonkri> hmm, i have "module BlackJack where" at the top
08:31:15 <essiene> jonkri: your main program should be a Module called Main, with a function called main as well
08:31:23 <essiene> jonkri: prefarably in a file called Main.hs as well
08:31:35 <Saulzar> essiene, If you are using IO you have a type like IO Foo, but that is not of type Foo. But when you bind a variable from IO Foo, that gives you a Foo directly..
08:31:38 <Philippa> I wouldn't insist on a Main.hs filename for single-module programs
08:31:44 <jonkri> ok, thanks
08:31:55 <Igloo> essiene: It sounds like main's IO () wasn't matching an IO somethingelse
08:32:02 <essiene> Saulzar: hmmm...
08:32:13 <dcoutts_> xerox, would you be interested in helping building a pure layer above your existing cairo binding?
08:32:33 <vincenz> dcoutts_: pure how?
08:32:35 <dcoutts_> xerox, imagin, rotate :: Double -> Picture -> Picture
08:32:52 <dcoutts_> vincenz, by pure cunning :-)
08:33:18 <dcoutts_> all the ops would be pure except for one operation to actually draw a picture to a surface
08:33:26 <vincenz> ah
08:33:39 <dcoutts_> but all the functions for constructing and transforming a picture would be pure
08:33:47 <essiene> Igloo: i'm not sure  i had gotten to where main's IO () was to be evaluated yet... i think Saulzar's point may be the key to what happened.... hmm...
08:33:58 <jonkri> ah, it works now, thanks!
08:34:13 <Saulzar> essiene, Paste the code? :)
08:34:14 <ADEpt> ah. the joys of reuse: 250 lines of code + 60 lines of imports :)
08:34:27 <Saulzar> Wow, that's a lot of imports.
08:34:33 <ADEpt> Saulzar: yep :)
08:34:51 <essiene> Saulzar: here? no flood rules? ;;)
08:34:51 <ADEpt> Saulzar: and i already cleaned about 15 of them. there were more :)
08:35:11 <Saulzar> essiene, At the lisp paste site paste.lisp.org, I think?
08:35:30 <ADEpt> lisppaste2: help
08:35:30 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:35:41 <essiene> Saulzar: ok... going to paste there
08:36:08 <jonkri> what does "Non-exhaustive patterns in function ..." means?
08:36:40 <Saulzar> Means it doesn't cover every potential case
08:37:14 <ADEpt> jonkri: and if you get it during runtime, it means that you actually stumbled upon such uncovered case
08:38:17 <jonkri> ok :-)
08:40:16 <ihope> I need a foreign language.
08:40:31 <ihope> What's the code thingy for Chinese?
08:41:38 <ihope> Ooh, Russian.
08:44:02 <ADEpt> ihope: what about russian?
08:44:03 <gour> dcoutts: the idea (for pure layer) is great
08:44:03 <lisppaste2> essiene pasted "IO Strangeness" at http://paste.lisp.org/display/16384
08:44:20 <dcoutts_> gour, ta
08:44:23 <ADEpt> ihope: i can provide you with a text of your choice in russian :)
08:44:42 <ihope> Hmm, well this webforum doesn't like Russian.
08:45:16 <essiene> Saulzar: pasted at http://paste.lisp.org/display/16384
08:45:23 <dcoutts_> gour, i'm not 100% sure how it's work yet, it needs some design work. I'm hoping to recruit xerox and/or Cale since they understand the cairo stuff.
08:45:28 <gour> dcoutts_: according to my understanding, the whole concept of abstraction is to hide ugly/unikportant details :-)
08:45:35 <essiene> aha... here comes pastebot ;)
08:45:39 <dcoutts_> gour, indeed
08:45:42 <sproingie> essiene: try adding a type annotation to main.  it thinks you're in the list monad
08:46:19 <essiene> sproingie: hmmm...
08:46:42 <gour> dcoutts_: and it would be a pity not to take (full) advantage from what haskell gives 
08:46:50 <essiene> sproingie: my 2nd day haskelling :), explain that a bit? ;)
08:47:18 <gour> dcoutts: i'm interested how this concept can be extended to the rest of gtk+...
08:47:53 <Saulzar> essiene, Igloo was right - my_mul isn't an IO action, so it has the wrong type, but you can still use it in an expression or bind it with "let x = my_mul"
08:48:04 <dcoutts_> gour, that's much harder
08:48:08 <essiene> hmmm...
08:48:17 <ihope> return (my_mul nums)?
08:48:29 <gour> dcoutts_: sure...i'd say it's a (real) challenge
08:48:35 <dcoutts_> gour, with the rest of gtk you've got signals, widget state and object identiy
08:48:56 <dcoutts_> gour, drawing is easy by comparison
08:49:03 <nooga> is there a Set in Haskell?
08:49:11 <dcoutts_> nooga, see Data.Set
08:49:19 <dcoutts_> @docs Data.Set
08:49:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
08:49:35 <nooga> ty
08:49:36 <gour> dcoutt_: true, but it must be possible to find a way for looking at gui programmming from a different perspective
08:49:53 <gour> ahh..my irc client
08:49:55 <dcoutts_> gour, we hope people will look into that
08:50:18 <dcoutts_> gour, there is an experimental arrows layer for gtk2hs
08:50:26 <essiene> heck... got disconnected :(
08:50:27 <sproingie> essiene: oh actually i got it wrong, main is always expected to be IO (), but the first one looks like it's just trying to return a list.  the type annotation won't help, you actually do need something like the second version
08:50:49 <essiene> sproingie: ok
08:51:07 <essiene> Saulzar: sorry... i got disconnected... did i miss anything you said?
08:51:29 <essiene> Igloo: do you mind explaining what you meant previously... my newbie brain didn't quite grab it
08:52:32 <gour> dcoutts_: xerox did a 'revolution' with gui...what do you think about arrows, i.e. what's the advantage?
08:53:02 <gour> dcoutts_: or is it gui programming too imperative in the nature, so not much can be done with the present toolkits?
08:53:17 <ADEpt> am I the only one who wants to have "hGetContentsWithTimeout t h" for network I/O? :)
08:53:23 <dcoutts_> gour, to be honest I have not investigated the how much can be done with arrows 
08:53:42 <dcoutts_> gour, but I don't think it is inherantly too imperative
08:53:51 <gour> dcoutts_: me too - i didn't even arrived to the monads :-)
08:54:01 <dcoutts_> gour, there are certainly opportunities for doing guis in a more declarative style
08:55:12 <phas> dcoutts_:saying mine, it's not a matter of "stile", programming a GUI IS altering a state, so it's imperative in his concept
08:55:32 <gour> dcoutts_: maybe this is opportunity for myself not being too emerged in imperat. style (yet) :-)
08:56:26 <phas> dcoutts_:of course you can argue that a computer itself it's a machine that works altering a state, but i don't see a way to apply a valido abstraction to the GUI's problem
08:56:43 <dcoutts> phas, yes a GUI is IO, but there are several places where there are higer abstractions where we can relate one aspect of a GUI functionally to another bit.
08:57:02 <dcoutts> phas, like with model view things, the view is a function of the model
08:57:20 <dcoutts> it's a function the maps the data in the model to a graphical represnetation
08:57:41 <dcoutts> or we can have a functional relationship between two bits of state in a GUI
08:57:53 <nooga> is ocaml like haskell?
08:58:11 <gour> nooga: don't think about ocaml :-)
08:58:16 <ProfTeggy> nooga, it lacks a cool IRC channel
08:58:41 <nooga> my friend just asked me
08:58:46 <dcoutts> phas, eg "the disabled property of this widget shall be equal to the status of that toggle button"
08:58:56 <gour> nooga: tell him to come to haskell ;)
08:59:07 <nooga> when i showed him haskell he told me that he heard abt ocaml, but we don't know what ocaml really is :D
08:59:25 <phas> dcoutts: uhm yes, i undestand what you mean
08:59:37 <dcoutts> phas, that's a functional style, where as the imperative style is to say "whenever the status of this toggle button changes set the disabled property of that widget"
08:59:47 <gour> nooga: well, check http://caml.inria.fr/pub/docs/manual-ocaml/
09:00:15 <dcoutts> phas, we basically want things to allow us to eliminate lots of IORefs
09:00:26 <dcoutts> phas, threads are another possability
09:01:13 <gour> dcoutts: the declarative 'style' sounds good...i'm thinking about xslt and 'rules' how to convert doc from one format to another by applying the rules
09:01:15 <phas> dcoutts: how?
09:02:28 <nooga> eeee
09:02:37 <dcoutts> phas, how threads you mean?
09:02:38 <nooga> ocaml sux when you compare it to haskell
09:02:44 <nooga> werid syntax
09:02:52 <xerox> dcoutts: hey!
09:02:56 <dcoutts> hia xerox 
09:03:04 <xerox> Thanks gour :-)
09:03:13 <xerox> dcoutts: Yes, I am!
09:03:18 <dcoutts> xerox, pure cairo layer? what do you think?
09:03:40 <dcoutts> xerox, do you see how it'd be done?
09:03:40 <xerox> It's a very good idea
09:03:44 <xerox> I didn't think about it much tho
09:04:01 <xerox> I made a BIG cup of chocolate mousse, and I just coveret it with fluffy cream.
09:04:06 <dcoutts> ;-)
09:04:11 <xerox> :-D
09:04:28 <dcoutts> xerox, have you seen my SOE implementaion? it uses cairo (or gdk)
09:04:34 <dcoutts> and it's pure in most places
09:04:40 <xerox> I was thinking of SOE yes
09:04:42 <dcoutts> we basically say:
09:04:46 <xerox> I remember your trick
09:04:54 <dcoutts> newtype Picture = Picture (Render ())
09:05:30 <dcoutts> then we can write things like rotate :: Double -> Picture -> Picture
09:06:26 <dcoutts> rotate angle (Picture r) = Picture (save >> Cairo.rotate angle >> r >> restore)
09:06:35 <nooga> what was that trick with returning multiple cells from list? 
09:06:36 <dcoutts> see pure!
09:06:58 <gour> dcoutts: your funcs looks like simon's in his craft book :-)
09:06:59 <nooga> i eman something instead of [1..10]!![1..4]
09:07:15 <dcoutts> gour, he's probably using the same trick
09:08:04 <dcoutts> xerox, and then at the top level we have renderPicture :: Picture -> Render ()
09:08:19 <dcoutts> renderPicture (Picure r) = r
09:08:41 <xerox> dcoutts: yep, yep.
09:08:45 <dcoutts> xerox, it should be a slick transformation :-)
09:08:52 <xerox> dcoutts: Cale had pretty interesting ideas too.
09:09:00 <dcoutts> xerox, there are some bits that need to be distingusied though, like paths and patterns
09:09:12 <Saulzar> Hmm, what advantage does that have over combing "Render"s with monads?
09:09:15 <xerox> We could compose arcs to make circles...
09:09:30 <gour> dcoutts: maybe it is also due to using type Picture = [[Char]] :-)
09:09:37 <xerox> Saulzar: there are both pedagogical and practical advantages.
09:09:55 <xerox> nooga: (!!!) = fmap . (!!)
09:09:58 <dcoutts> xerox, they'd get their own types
09:09:58 <dcoutts> but internally they'd just be Render () as well
09:09:59 <dcoutts> so the thing should hardly introduce any performance problems at all
09:10:03 <ProfTeggy> nooga, map ([1..10] !!) [1..4]
09:10:08 <nooga> ah right
09:10:08 <xerox> dcoutts: I understand, yep.
09:10:23 <Saulzar> gour, Make the binding to aalib :)
09:10:25 <xerox> dcoutts: I was thinking what to wrap up.
09:10:30 <dcoutts> xerox, ?
09:10:36 <dcoutts> wrap up?
09:10:53 <xerox> What transformation to write?
09:11:03 <dcoutts> xerox, I don't follow
09:11:21 <essiene> phew... time to take a break from brain_twist(tm) :)
09:11:29 <xerox> dcoutts: what function do you think we should make?
09:11:29 <gour> Saulzar: :-)
09:12:24 <essiene> haskell is really feat, i can't believe i've made this much progress... i used to *tremble* at the thought of functional languages :)
09:12:35 <dcoutts_> xerox, as many as make sense
09:12:41 <Saulzar> The major difference is that it will be state-less, right? Hm - and nicely wrap heirarchial stuff I suppose.
09:12:58 <dcoutts_> xerox, we'd want to expose as much of cairo as possible in a pure layer
09:13:28 <xerox> dcoutts_: agreed, I was just saying that I remember Cale talking of having complete shapes, instead of only arcs, for example, for ease of use.
09:13:43 <dcoutts_> xerox, well one can be done in terms of the other
09:13:52 <xerox> Yep.
09:13:58 <dcoutts_> xerox, I think we want to expose the cairo model as a pure api
09:14:12 <dcoutts_> then building complete shapes for convenience should be easy on top of thet
09:14:12 <benny> what are you guys talking about?
09:14:33 <xerox> dcoutts_: for that we prolly need an 'interspersePicture' or something? :)
09:14:48 <dcoutts_> benny, what does that do?
09:14:53 <dcoutts_> oops I mean xerox
09:15:09 <xerox> dcoutts_: how do you sequence Pictures?
09:15:13 <dcoutts_> benny, we're talking about a pure api for a graphics lib
09:15:24 <dcoutts_> xerox, it's pure remember, no sequencing!
09:15:36 <dcoutts_> xerox, it's called 'over' not 'after' :-)
09:15:40 <xerox> Well yes...
09:15:42 <xerox> Heh.
09:15:50 <Saulzar> Hmm, maybe a scene graph structure would be useful?
09:15:53 <xerox> And how does a drawing start?
09:16:05 <dcoutts_> xerox, declaratively one picture is above another, imperatively one is drawn after the other
09:16:11 <xerox> plaseDraw $ rotate (square 1 2 3 4)
09:16:17 <dcoutts_> exactly
09:16:25 <xerox> I like it
09:16:26 <dcoutts_> plaseDraw :: Picture -> Render ()
09:16:36 <nooga> may i paste 5 lines?
09:16:40 <benny> interesting... please support infinite pictures :)
09:16:49 <xerox> nooga: yep
09:16:50 <dcoutts_> xerox, or one can go higher level and say:
09:16:51 <nooga> Prelude> let (!!!) = fmap . (!!)
09:16:51 <nooga> <interactive>:1:12:
09:16:51 <nooga>     Ambiguous type variable `f' in the constraint:
09:16:51 <nooga>       `Functor f' arising from use of `fmap' at <interactive>:1:12-15
09:16:51 <nooga>     Probable fix: add a type signature that fixes these type variable(s)
09:16:59 <nooga> what now?
09:17:02 <xerox> nooga: switch fmap with map
09:17:18 <dcoutts_> set widget [ widgetPicture := myPicture ]
09:17:19 <nooga> as i expected
09:18:00 <xerox> dcoutts_: right...
09:18:02 <dcoutts_> xerox, so you just declare that a widget has something as it's picture
09:18:05 <xerox> dcoutts_: that seems sensible!
09:18:14 <dcoutts_> xerox, and the widget takes care of redrawing etc
09:18:19 <xerox> We should write sandhur after writing that API.
09:18:22 <dcoutts_> xerox, or it might cache it
09:18:46 <xerox> You and your DWIM ideas :-)
09:18:53 <dcoutts_> xerox, and then you can go higher level and have type Animation = Time -> Picture
09:19:32 <xerox> dcoutts_: I wonder how does it work
09:19:49 <xerox> It is not calculating a 'scene' from a previous one, but as a function of time
09:19:57 <dcoutts_> set animWidget [ anim := myAnim ]
09:20:15 <dcoutts_> xerox, yeah, so it redraws efery so often using the time parameter
09:20:37 <dcoutts_> xerox, it's a standard continuous time representation of animations
09:20:40 <xerox> dcoutts_: and there is some standard..
09:20:44 <xerox> okay :-)
09:20:49 <dcoutts_> ;-)
09:21:06 <xerox> You get something like [1..] ?
09:21:38 <dcoutts_> well probably Time is a double or something like that
09:21:52 <dcoutts_> which gets incremented in small steps
09:22:05 <dcoutts_> there are various ways of doing it
09:22:25 <dcoutts_> but that sort of thing is easier after one has pure drawing funcs
09:22:40 <xerox> I'm asking because I have to do one for some purposes these days
09:22:46 <dcoutts_> oh right
09:23:11 <dcoutts_> so you can take a discrete or continuous time
09:23:15 <xerox> I want to do a simple physical phenomena representator
09:23:16 <dcoutts_> eg Double or Int
09:23:38 <dcoutts_> and at some point one does have to pick the time increment that one uses for the animation
09:23:43 <dcoutts_> hia SyntaxNinja 
09:24:04 <xerox> I.e. particles hitting eachothers some dimensions
09:24:21 <xerox> dcoutts_: but if you get the Time in, and you're not stateful...
09:24:52 <Saulzar> Yampa is Time in, but also stateful... 
09:25:37 <dcoutts_> xerox, ah I see, yeah you could use various thing, eg arrows like yampa, or just do a discrete simulation with state passed from on step to the next
09:25:59 <xerox> That's why 'Time -> Thing' representation bothers me :-\
09:25:59 <Saulzar> Maybe simpler to have something like Time -> State -> (Picture, State) 
09:26:13 <xerox> Time -> State a MyThings
09:26:18 <xerox> Hmm.
09:26:39 <dcoutts_> xerox, the Time -> Thing was what pan used. But it wasn't particularly reactive animation.
09:26:45 <dcoutts_> pan was stateless
09:27:17 <Saulzar> xerox, That won't seem to help unless you require State within your update, rather than external state
09:27:29 <xerox> Saulzar: yep.
09:27:32 <xerox> Mumble mumble.
09:27:44 <xerox> I do not know about yampa.  Mind to elaborate on that?
09:27:52 <SyntaxNinja> hey dcoutts_
09:28:06 <dcoutts_> xerox, you know I'm off to demo gtk2hs & cairo to the people building epigram 2 at Nottingham next month. :-)
09:28:26 <xerox> dcoutts_: setup some webcam please!!! :-D
09:28:32 <dcoutts_> xerox, heh :-)
09:28:54 <dcoutts_> xerox, if only you were in the country you could come along :-)
09:29:05 <xerox> How much is it to come there?
09:29:08 <dcoutts_> @where epigram
09:29:08 <lambdabot> http://sneezy.cs.nott.ac.uk/epigram/
09:29:11 <xerox> I'd love to.
09:29:26 <Philippa> dcoutts: got a date fixed yet?
09:29:34 <dcoutts_> Philippa, 3rd March
09:29:53 <dcoutts_> xerox, well they're already paying for Axel and me, I don't think they could stretch that far. :-(
09:30:36 <Philippa> dcoutts: cool. Don't think I've anything else going on then either, will see if I can drop by
09:30:44 <xerox> dcoutts_: maybe it's worth a try, but I don't know if I could ask for that much.
09:30:47 <Saulzar> xerox, Well, you end up with something which is a bit like Time -> Output, which is an arrow which stores some internal state
09:31:14 <dcoutts_> Philippa, see http://sneezy.cs.nott.ac.uk/fplunch/
09:32:48 <dcoutts_> xerox, so I'm hoping they'll want to build a gui with cairo that looks like:
09:32:48 <dcoutts_> http://en.wikipedia.org/math/4/7/6/476e2f5cccde2bc8a5a3bafb05818518.png
09:33:06 <xerox> WOOOO
09:33:08 <xerox> Google money arrived \o/
09:33:12 <dcoutts_> yay!
09:33:28 <dcoutts_> that only took, what, 6 months?
09:33:31 <xerox> Maybe I could fly there
09:33:35 <xerox> :-(
09:33:45 <dcoutts_> xerox, it's not worth that
09:33:59 <dcoutts_> xerox, hey I'm coming to Italy this easter
09:34:07 <xerox> Wow!
09:34:09 <xerox> Where exactly?
09:34:12 <dcoutts_> xerox, stopping in Rome & Naples
09:34:20 <dcoutts_> possibly also Milan
09:34:46 <dcoutts_> train: London -> Paris -> Milan -> Rome -> Naples
09:34:56 <dcoutts_> it'll be a long journey :-)
09:35:04 <xerox> If you come to Milan I could do Turin -> Milan, I think.
09:36:31 <dcoutts_> I think we're only stopping to change trains in Milan
09:36:42 <dcoutts_> we're in Rome for 4 days and Naples for a week
09:36:49 <xerox> Vacations?
09:36:53 <dcoutts_> yeah
09:37:02 <dcoutts_> with my gf and her family
09:37:13 <xerox> Nice :-)
09:38:19 <phas> Uhm, i've problem trying to write a main() for an Haskell program
09:38:26 <phas> following http://haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html#using-own-main
09:38:29 <lispy> train :: London -> Paris -> Milan -> Rome -> Naples?
09:38:45 <dcoutts_> lispy, hah, that's not a function :-)
09:39:06 <xerox> You feed it with Cities, and dcoutts_ lazily go to Naples :-)
09:39:10 <phas> i have to export functions that i'll use in C
09:39:11 <lispy> train _ _ _ _ = Naples
09:39:19 <phas> using foreign export like
09:39:29 <phas> foreign export ccall foo :: Int -> IO Int
09:39:46 <dcoutts_> xerox, hmm Torino is a long way from Roma.
09:39:48 <phas> my function is server :: IO()
09:40:11 <phas> but using foreign export ccall server :: IO() i get
09:40:19 <xerox> dcoutts_: yep :(
09:40:26 <phas> PoppyServer.hs:3:0: Type signature given for an expression
09:40:33 <dcoutts_> xerox, I'll check if we can take one fewer day in Roma and spend it in Milano instead
09:40:43 <xerox> dcoutts_: it would be great, but I don't want to mess your plans
09:41:04 <dcoutts_> xerox, I'll check if we've booked the hotel yet
09:41:27 <xerox> Yep.
09:41:51 * dcoutts_ goes home
09:42:03 <xerox> See you later!
09:42:27 * xerox now fears his horrible english pronunciation
09:42:33 <xerox> I need to fix it in time ;-)
09:47:30 <SyntaxNinja> so for some reason, I can't connect to openprojects from home.  does anyone know if they block certain ip ranges or something?
09:49:18 <phas> dcoutts_: if you stop to Milan some days and xerox come to see you, i could go with him, of course if i don't disturb
09:49:56 <dcoutts_> phas, if we do stop there for a while, yeah, that'd be fun
10:10:34 * SyntaxNinja pokes dons
10:13:38 <ndm> hsapr
10:13:49 <ndm> shapr (just got back from pub, typing fingers are misplaying :)
10:14:16 <tuomov> that can only be due to lack of exercise
10:18:38 <vincenz> why does this faiil
10:18:47 <vincenz> > let perms l = l >>= (\x -> (perms $ delete x l) >>= (\y -> return (x:y))) in perms [1,2,3]
10:18:48 <lambdabot> []
10:24:06 <tromp> try permute l = foldM (\s _ -> [a:s | a <- l\\s]) [] l
10:28:16 <SyntaxNinja> hm. no lemmih
10:36:59 <imix> can anyone explain me why: main = do catch (error "error") (\e -> print "caught")  does not print "caught" ? (if I use ioError it works as expected)
10:37:46 <Saulzar> imix, I think maybe it depends on the catch you're using - there's one in Exception and one in IO
10:39:28 <imix> when using catch from Control.Exception it works, thanks
10:40:53 <xerox> It arrived the olympic torch, heeh
10:41:05 <dcoutts> SyntaxNinja, yeah, I've not seen Lemmih for days
10:41:35 <palomer> sTypeToType :: (MonadSupply.MonadSupply [Char] (MonadSupply.SupplyT [Char] (GHC.ST.ST s))) => SType s -> t -> GHC.ST.ST s Type.Type <--where does the t come in?
10:45:32 <palomer> @hoogle (&&&)
10:45:32 <lambdabot> No matches found
10:45:35 <palomer> where is &&& located?
10:45:46 <Saulzar> Control.Arrow
10:45:47 <xerox> Arrow.
10:45:48 <lispy> @index (&&&)
10:45:49 <lambdabot> Control.Arrow
10:46:20 <ndm> has anyone had any experience with writing an autoconf file to detect GHC?
10:46:47 <palomer> ahh, gotcha
10:48:14 <lispy> ndm: maybe check the darcs source?
10:48:40 <ndm> lispy: i am now, but hte GHC autoconf is big and horrible
10:48:48 <palomer> is Map always faster than using List?
10:50:57 <nooga> trying to learn Parsec, but i thinnk it's too early
10:51:18 <palomer> parsec takes a while to get used to
10:51:33 <palomer> http://cristal.inria.fr/attapl/ <--this is a beast!
10:52:20 <palomer> Cale, you here?
10:55:05 <Philippa> am just starting to read that (I've got the printed version sitting next to me, but more detail is always good)
10:56:30 <benny> how does one make a (Ptr a) value(probably only possible in IO monad) ?
10:56:55 <Saulzar> palomer, Map is log n for various operations (eg. insert, find, erase) where as list is not, but probably has more overhead.
10:57:03 <benny> like how can i allocate the memory and then set it to what i want, get the Ptr a and finally free the memory?
10:57:20 <nooga> and one, big question wtf is monad ?:D (started with Haskell several hours ago)
10:57:40 <ADEpt> btw, is there such thing as sourceforge.net, but with darcs space? :)
10:58:44 <palomer> Saulzar: yeah
10:58:56 <Saulzar> Only way to know for sure is to test :)
10:59:12 <oxygene> ADEpt: every webhoster that doesn't mangle your data should do, or not?
10:59:30 <oxygene> that's the whole point of using a dumb protocol..
11:00:02 <ADEpt> oxygene: well, almost
11:01:20 <liyang> nooga: http://haskell.org/hawiki/UsingMonads
11:01:44 <ADEpt> oxygene: the ability to do "darcs put"/rsync/... to the dedicated corner of some system is much less maintenance than keeping a hosting just for myself. 
11:05:55 <palomer> oh my, it's taken me 2 days, but I can finally work on my algorithm
11:06:01 <palomer> whew the scaffolding took a while
11:09:28 <palomer> ugh, I have to write 2 unify functions
11:09:38 <palomer> one checks to see if unification changes anything
11:09:43 <palomer> and the other changes things during unification
11:09:48 <palomer> is there any way to combine the two?
11:29:08 <palomer> @hoogle fail
11:29:09 <lambdabot> Control.Monad.fail :: Monad m => String -> m a
11:29:09 <lambdabot> Prelude.fail :: Monad m => String -> m a
11:29:09 <lambdabot> Test.HUnit.Base.failures :: Counts -> Int
11:29:36 <palomer> fail = const Nothing for Maybe?
11:30:33 <palomer> @hoogle MaybeT
11:30:34 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
11:30:42 <palomer> gah, there's no MaybeT!
11:30:46 <Saulzar> Looks that way
11:30:53 <Saulzar> You could use ErrorT ...
11:31:00 <palomer> @hoogle ErrorT
11:31:01 <lambdabot> Control.Monad.Error.ErrorT :: ErrorT e m a
11:31:01 <lambdabot> Control.Monad.Error.ErrorT :: m (Either e a) -> ErrorT e m a
11:31:01 <lambdabot> Control.Monad.Error.runErrorT :: ErrorT e m a -> m (Either e a)
11:34:14 <palomer> we should have like a supermonad, which is a combination of all the monad transformers in the library
11:34:41 <Saulzar> Hmm, "slow" comes to mind
11:44:07 <palomer> Saulzar: slow to compile?
11:44:27 <Saulzar> I don't know, I guess the masses of indirection won't help in general
11:46:05 <ihope> @djinn Monad m => Maybe a -> m a
11:46:06 <lambdabot> Cannot parse command
11:46:16 <ihope> I knew that wouldn't work.
11:46:19 <SyntaxNinja> I finally put up detailed directions on how to install cabal-get and cabal-put.  someone want to try them out: http://hackage.haskell.org/trac/hackage/wiki/CabalPut
11:46:37 <ihope> Well, just what's all this MonadT stuff?
11:49:23 <jethr0_> how can i get a "m (a, b)" from an "(m a, m b)"?
11:49:49 <jethr0_> i.e. something similar to sequence :)
11:49:52 <palomer> ihope: MonadTs are the best thing in the world
11:50:07 <ihope> jethr0
11:50:09 <ihope> oops.
11:50:19 <ihope> jethr0_: you can't. >:-)
11:50:27 <ihope> palomer: but what *are* they?
11:50:45 <jethr0_> ihope: what do you mean "i can't"?
11:50:50 <ihope> Erm, wait.
11:51:02 <jethr0_> do you know how sequence is implemented?
11:51:15 <ihope> @type \(x,y) -> x >>= \a -> y >>= \b -> return (a,b)
11:51:16 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (m a, m a1) -> m (a, a1)
11:51:30 <jethr0_> nice!
11:51:43 <jethr0_> thank you
11:51:46 <dcoutts> SyntaxNinja, I've started on a cabal wrapper program, I'll keep you posted
11:51:46 <ihope> Erm. (\(x,y) -> do {a <- x; b <- y}) if you want.
11:51:57 <jethr0_> *brr*
11:52:34 <SyntaxNinja> dcoutts: did you look at cabal-install? it does a couple of non-trivial things
11:52:45 <SyntaxNinja> at least with --with-runhugs and similar
11:52:47 <palomer> ihope: oh, let's say you want the capabalities of two monads, you use a monad transformer
11:53:04 <dcoutts> SyntaxNinja, yeah I've seen it
11:53:54 <dcoutts> SyntaxNinja, if you don't specify --hugs --ghc to a cabal Setup.lhs prog, which impl does it select? ghc I guess yeah?
11:54:44 <dcoutts> SyntaxNinja, the cabal prog should use the same impl to build/run the setup program as the setup will build the package for/with.
11:55:36 <jonkri> thanks everyone, cya!
11:55:50 <SyntaxNinja> dcoutts: right, but cabal itself has no use for runhugs or runghc, whereas cabal-install does.
11:56:29 <SyntaxNinja> dcoutts: I'm very interested in your wrapper, as I want to release cabal soon, and cabal-install is the main thing hollding it up, I'd like to know what your wrapper will do that is different from cabal-install, so I can make good decisions about releasing it
11:56:49 <ihope> @kind ContT
11:56:50 <lambdabot> Not in scope: type constructor or class `ContT'
11:56:54 <ihope> @index ContT
11:56:55 <lambdabot> Control.Monad.Cont, Control.Monad.Cont
11:57:02 <ihope> @kind Control.Monad.Cont.ContT
11:57:03 <lambdabot> * -> (* -> *) -> * -> *
11:58:26 <ihope> palomer: I know that, at least with the Cont monad, there's (Cont.(>>=))
12:00:14 <benny> in State monad, how can i do modify x; modify x; modify x; modify x; ... n times?
12:00:23 <xerox> heh
12:00:27 <xerox> @index repeatM_
12:00:27 <lambdabot> bzzt
12:01:12 <palomer> @hoogle m [[a]] -> m [a]
12:01:13 <lambdabot> No matches, try a more general search
12:01:16 <palomer> @index concatM
12:01:17 <lambdabot> bzzt
12:01:17 <tromp> use replicateM
12:01:22 <palomer> @hoogle concatM
12:01:22 <lambdabot> Data.List.concatMap :: (a -> [b]) -> [a] -> [b]
12:01:22 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
12:01:39 <xerox> @type let repeatM_ = flip mapM_ . enumFromTo 1 in repeatM_
12:01:40 <lambdabot> forall (m :: * -> *) a b.
12:01:40 <lambdabot> (Num a, Enum a, Monad m) =>
12:01:40 <lambdabot> a -> (a -> m b) -> m ()
12:01:43 <xerox> ah, replicate...
12:01:47 <xerox> @index replicateM
12:01:48 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
12:01:48 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
12:01:48 <lambdabot> Control.Monad.Error, Control.Monad.List
12:01:53 <xerox> @hoogle replicateM
12:01:54 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
12:01:54 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
12:02:22 <xerox> @type let repeatM_ = flip mapM_ [1..] . const in repeatM_
12:02:23 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m ()
12:02:25 <xerox> Maybe that way.
12:02:45 <benny> so modify x >> modify x ===> replicateM_ 2 (modify x) ?
12:03:02 <xerox> Yep.
12:03:32 <benny> cool thanks
12:03:49 <ihope> @index modify
12:03:50 <lambdabot> Control.Monad.State, Control.Monad.RWS
12:03:57 <astrolabe> @type uncurry $ Control.Monad.liftM2 (,)
12:03:58 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => (m a1, m a2) -> m (a1, a2)
12:04:00 <ihope> @type Control.Monad.State.modify
12:04:01 <lambdabot> forall (m :: * -> *) s.
12:04:01 <lambdabot> (Control.Monad.State.MonadState s m) =>
12:04:01 <lambdabot> (s -> s) -> m ()
12:04:23 <xerox> @type sequence_ . repeat
12:04:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:06:30 <astrolabe> jethr0_:   ^^^^^^^^^^^^^^^^^^
12:06:44 <jethr0_> ^^^
12:07:02 <ihope> "jet"?
12:07:14 <jethr0_> yes
12:42:04 <jyp> @quote
12:42:04 <lambdabot> babel module failed: getRandItem: empty list
12:42:18 <jyp> @botsnack
12:42:18 <lambdabot> :)
12:42:33 <palomer> hrm
12:42:47 <palomer> what would you guys recommend? Either a a or (Bool,a) ?
12:44:21 <xerox> Maybe Either would be better, because it's a Monad.
12:44:28 <glasser> Are there cases where you want to do the same thing no matter which one it is?
12:45:25 <glasser> (I bet you can't do:
12:45:30 <palomer> Maybe Either? how would that work?
12:45:39 <glasser> foo :: Either Int Int
12:45:47 <glasser> foo (_ x) = x
12:45:52 <glasser> (er, :: Either Int Int -> Int)
12:45:54 * benny recommends to define a new type that is syntactically clearer then those two
12:46:17 <glasser> yeah, I guess it's easy enough to get around my objection with like
12:46:27 <xerox> palomer: no no, 'Maybe' is part of the phrase, not the type :-)
12:46:35 <glasser> doToA :: (a->b) -> Either a a -> b
12:46:37 <palomer> ahh, gotcha
12:46:46 <glasser> doToA f (Left x) = f x
12:46:46 <glasser> etc
12:46:53 <xerox> palomer: yep.
12:46:56 <palomer> glasser: foo (Left x) = x ; foo (Right x) = x
12:47:18 <xerox> Indeed.
12:47:31 <glasser> well, that's copy and paste code :) but you can say foo = doToA foo' where foo' x = x
12:48:07 <glasser> (I guess the real difference might be that you can be lazy about the bool but not about the Left/Right construtor)
12:48:18 <palomer> Either isn't lazy?
12:48:19 <palomer> eh?
13:01:29 <phas> I've a problem exporting function for using in C, someone could help?
13:03:06 <lispy> phas: asking in a general way is less likely to get help.  Is there an error messsage you're stumped by?  Do you have some code you could show us?
13:03:13 <palomer> @hoogle newstref
13:03:14 <lambdabot> Data.STRef.Lazy.newSTRef :: a -> ST s (STRef s a)
13:03:14 <lambdabot> Data.STRef.newSTRef :: a -> ST s (STRef s a)
13:04:12 * lispy sits down to enjoy some sweet midget pickles
13:06:40 <ihope> @type Either a a -> a
13:06:41 <lambdabot> not an expression: `Either a a -> a'
13:06:47 <ihope> ...Oops.
13:06:51 <ihope> @djinn Either a a -> a
13:06:52 <lambdabot> f a =
13:06:52 <lambdabot>   case a of
13:06:52 <lambdabot>   Left b -> b
13:06:52 <lambdabot>   Right c -> c
13:08:10 <lispy> @djinn Either a b -> a
13:08:10 <lambdabot> -- f cannot be realized.
13:08:17 <phas> lispy, of course
13:08:29 <phas> lispy, wait a moment until i paste the code
13:08:56 <lispy> phas: well, i've never used thee FFI, so i won't be able to help, but maybe someone else can
13:09:36 <lispy> @type \x -> case x of Left a -> a
13:09:37 <lambdabot> forall a b. Either a b -> a
13:09:48 <lispy> so why does djinn say that's not possible?
13:10:02 <lisppaste2> Phas pasted "esport test" at http://paste.lisp.org/display/16397
13:11:01 <liyang> > (\x -> case x of Left a -> a) (Right 0)
13:11:02 <lambdabot> Add a type signature
13:11:14 <liyang> -_-;;
13:11:52 <lispy> phas: i'm looking at the code and i don't see main
13:12:08 <xerox> lispy: because djinn only does constructive functions.
13:12:15 <lispy> phas: but maybe that's not important
13:12:36 <phas> lispy, of course, this is supposed to export functions for using in another program...
13:12:40 <lispy> xerox: so my function is non-constructive?
13:12:49 <lisppaste2> Phas annotated #16397 with "Error" at http://paste.lisp.org/display/16397#1
13:12:51 <Cale> lispy: it's partially undefined
13:13:01 <xerox> @djinn a -> ()
13:13:01 <lambdabot> f _ = ()
13:13:11 <Cale> lispy: djinn only gives totally defined functions
13:13:44 <liyang> @djinn Either a b -> Maybe a
13:13:45 <lambdabot> f a =
13:13:45 <lambdabot>   case a of
13:13:45 <lambdabot>   Left b -> Just b
13:13:45 <lambdabot>   Right _ -> Nothing
13:13:49 <lispy> phas: and if you remove ":: Int->IO Int" from line 3?
13:16:29 <palomer> @djinn Int -> Bool
13:16:29 <lambdabot> f _ = False
13:16:35 <palomer> @djinn Bool -> Int
13:16:35 <lambdabot> -- f cannot be realized.
13:16:39 <palomer> eh?
13:16:40 <palomer> why not?
13:17:00 <phas> lispy, i got a parse error
13:17:00 <lispy> maybe it won't invent values
13:17:28 <phas> lyspy, but this a copy-paste of the example in GHC doc...
13:17:36 <palomer> it's not hard to invent 0
13:17:40 <lispy> phas: oh weird
13:17:53 <lispy> palomer: it would need to construct it tho
13:17:57 <palomer> @djinn Int -> Maybe Bool
13:17:58 <lambdabot> f _ = Nothing
13:18:16 <lispy> @djinn Bool -> Maybe Int
13:18:17 <lambdabot> f _ = Nothing
13:18:30 <vincenz> Cale: how do I return a file from a FileChooserDialog?
13:19:39 <lispy> @djinn String -> Int
13:19:40 <lambdabot> -- f cannot be realized.
13:19:55 <lispy> @djinn [a] -> Int
13:19:56 <lambdabot> -- f cannot be realized.
13:20:18 <lispy> djinn, ever heard of "length"
13:20:32 <phas> lispy, i may think that is a matter of compilation options
13:21:05 <palomer> @djinn Either a a -> a
13:21:06 <lambdabot> f a =
13:21:06 <lambdabot>   case a of
13:21:06 <lambdabot>   Left b -> b
13:21:06 <lambdabot>   Right c -> c
13:21:45 <palomer> hah, I'm actually going to use djinn code for my program
13:21:46 <palomer> hah!
13:21:58 <xerox> Cool!
13:22:36 <palomer> woops, turns out I won't
13:22:54 <lispy> @index runEither
13:22:54 <lambdabot> bzzt
13:22:59 <lispy> @index runError
13:22:59 <lambdabot> bzzt
13:23:08 <lispy> @hoogle Either a b -> a
13:23:09 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
13:23:09 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:23:09 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
13:23:47 <lispy> i guess the error monad doesn't have a run?
13:24:00 <lispy> @hoogle Either a b -> Maybe a
13:24:00 <lambdabot> Data.Maybe.Nothing :: Maybe a
13:24:00 <lambdabot> Prelude.Nothing :: Maybe a
13:24:18 <Cale> right, it doesn't need one
13:24:26 <Cale> vincenz: hmm?
13:24:30 <benny> is there something like elem function, but instead of the condition being the Eq == function i can supply a custom condition function?
13:24:40 <lispy> Cale: true, but i thought it might just to be consistent
13:24:55 <palomer> Cale: would you use Either a a or (Bool,a) ?
13:24:57 <Cale> It'd probably be the identity function :)
13:25:08 <lispy> benny: you want maybe equivalence relations on sets?
13:25:15 <Cale> palomer: depends :)
13:25:47 <palomer> Cale: depends on what?
13:25:52 <palomer> (are there other alternatives?)
13:26:05 <palomer> I have this datastructure  that may become unsound at any moment
13:26:06 <Cale> You could also create a custom datatype
13:26:10 <palomer> and I want to flag it
13:26:12 <benny> lispy: let's say i have a [Maybe Int] list, and i'd like to have a true/false answer: does the list contain 1 or more just values?
13:26:29 <lispy> i'd be tempted to write an Eqiv class and define an interface with things like (===) and cosetMember
13:26:59 <lispy> benny: ah, that should be easy to do with other functions
13:27:03 <palomer> so I have newtype Struct = Struct{unStruct::STRef s (Either a a)}
13:27:05 <lispy> let's see....
13:27:06 <Cale> wow, a lot of the suggestions on Haskell' are scary :)
13:27:08 <lispy> @index concatMaybe
13:27:08 <lambdabot> bzzt
13:27:17 <lispy> @index concatMaybes
13:27:18 <lambdabot> bzzt
13:27:19 <ihope> @djinn a -> m a
13:27:20 <lambdabot> -- f cannot be realized.
13:27:23 <ihope> Whee.
13:27:31 <lispy> @hoogle concatMaybe
13:27:31 <lambdabot> No matches found
13:27:36 <benny> lambdabot: my problem is similar, but not identical, so nothing Maybe specific please :)
13:27:39 <Cale> @hoogle catMaybes
13:27:39 <lispy> grr...what function am i thinking of
13:27:40 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
13:27:44 <Cale> that one
13:27:52 <lispy> benny: ah
13:27:56 <ihope> Where's @djinn's classes?
13:28:01 <xerox> catMaybes xs = [x | Just x <- xs]
13:28:23 <lispy> benny: maybe 'any' is your function?
13:28:29 <lispy> @type any
13:28:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:28:48 <benny> ah yes, that's it, but what would be really cool if i could somehow pattern match like
13:29:07 <benny> any' (Just _) [Nothing, Nothing, Just 3, Just 5]
13:29:20 <ihope> ...Wuh?
13:29:36 <palomer> what would that mean?
13:29:41 <lispy> @type isJust
13:29:42 <lambdabot> Not in scope: `isJust'
13:29:46 <benny> any (\x -> case x of Just _ -> True; _ -> False) []
13:29:46 <lispy> @index isJust
13:29:47 <lambdabot> Data.Maybe
13:29:56 <lispy> @type Data.Maybe.isJust
13:29:57 <lambdabot> forall a. Maybe a -> Bool
13:30:05 <xerox> > map (Just x -> x) [Nothing, Just 1, Nothing]
13:30:06 <lambdabot>  parse error on input `->'
13:30:08 <xerox> > map (\Just x -> x) [Nothing, Just 1, Nothing]
13:30:09 <lambdabot>   Constructor `Just' should have 1 argument, but has been given 0
13:30:09 <lambdabot>   When checking the pattern: Just
13:30:09 <lambdabot>   In a lambda abstraction: \ Just x -> x
13:30:22 <ihope> @type any
13:30:23 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:30:25 <benny> lispy: yeah, i guess i basicly have to write the equivilent of "isJust" for my type
13:30:54 <ihope> > any (\x -> case x of Just _ -> True; _ -> False) []
13:30:55 <lambdabot> False
13:31:25 <lispy> > any Data.Maybe.isJust []
13:31:26 <lambdabot> False
13:31:53 <ihope> @djinn a -> Maybe b
13:31:53 <lambdabot> f _ = Nothing
13:32:01 <ihope> @djinn Maybe a
13:32:01 <lambdabot> f = Nothing
13:32:06 <lispy> @djinn a -> b
13:32:06 <lambdabot> -- f cannot be realized.
13:32:23 <ihope> Wouldn't we all "love" a fully-functional (a -> b)?
13:32:37 <lispy> @hoogle a -> b
13:32:38 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:32:38 <lambdabot> Prelude.id :: a -> a
13:32:38 <lambdabot> Prelude.undefined :: a
13:33:00 <lispy> ihope: well, we could use undefined for now
13:33:37 <ihope> Just why do we want this function?
13:33:44 <lispy> i wonder what it would be like if haskell allowed you to inspect a function's type at run time
13:34:11 <ihope> Ooh, yeah.
13:34:19 <ihope> @djinn _ -> a
13:34:20 <lambdabot> Cannot parse command
13:34:24 <ihope> :-P
13:34:49 <lispy> @djinn (Maybe a, Maybe b) -> Either a b
13:34:49 <lambdabot> -- f cannot be realized.
13:35:04 <lispy> @djinn Either a b -> (Maybe a, Maybe b)
13:35:05 <lambdabot> f a =
13:35:05 <lambdabot>   case a of
13:35:05 <lambdabot>   Left b -> (Just b, Nothing)
13:35:05 <lambdabot>   Right c -> (Nothing, Just c)
13:35:25 <liyang> (Nothing, Nothing) :)
13:35:38 <lispy> Nothing appears to the trump card of djinn
13:35:53 <liyang> @djinn (Maybe a, Maybe b) -> Maybe (Either a b)
13:35:54 <lambdabot> f (a, b) =
13:35:54 <lambdabot>   case a of
13:35:54 <lambdabot>   Nothing -> Nothing
13:35:54 <lambdabot>   Just c -> case b of
13:35:54 <lambdabot>      Nothing -> Just (Left c)
13:35:56 <lambdabot>      Just d -> Just (Right d)
13:36:32 <liyang> Not what I'd expected. :-/
13:36:35 <lispy> @djinn Maybe (Maybe a, Maybe b) -> Maybe (Either (Maybe a) (Maybe b))
13:36:36 <lambdabot> f a =
13:36:36 <lambdabot>   case a of
13:36:36 <lambdabot>   Nothing -> Nothing
13:36:36 <lambdabot>   Just (b, c) -> case b of
13:36:36 <lambdabot>        Nothing -> Nothing
13:36:37 <lambdabot>        Just d -> case c of
13:36:39 <lambdabot>           Nothing -> Just (Left (Just d))
13:36:41 <lambdabot>           Just e -> Just (Right (Just e))
13:37:53 <lispy> @djinn [Maybe a] -> Maybe [a]
13:37:54 <lambdabot> f _ = Nothing
13:38:18 <lispy> @djinn Maybe [a] -> [Maybe a]
13:38:19 <lambdabot> -- f cannot be realized.
13:38:28 <lispy> alright, i should stop spamming the channel
13:39:48 <lispy> i wonder if the peano numerals could be added to djinn to give it he ability to generate numbers from other types
13:40:15 <ihope> Where are those, anyway?
13:47:24 <jonkri> if i have a arbitary class, how can i create a random value using that in a function?
13:47:56 <palomer> @hoogle runState
13:47:57 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
13:47:57 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
13:48:01 <glasser> by arbitrary class do you actually mean Arbitrary?
13:48:09 <glasser> (from QuickCheck?)
13:48:38 * palomer wonders why it takes so long for ghc to skip the already compiled files
13:48:51 <jonkri> glasser: yes, i think so
13:48:57 <dcoutts> dons, you about?
13:48:59 <glasser> then use arbitrary
13:49:36 <jonkri> i don't know how to get the value
13:49:50 <ihope> @djinn (a -> m b) -> m a -> m b
13:49:50 <lambdabot> -- f cannot be realized.
13:49:56 <ihope> @type flip (>>=)
13:49:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
13:50:02 <ihope> Gasp.
13:50:13 <jonkri> i have a function which i want to pass a random arbitrary value to, but i don't know how to type it
13:51:20 <ihope> The value or the function?
13:51:46 <xerox> @type random
13:51:47 <lambdabot> Not in scope: `random'
13:51:50 <jonkri> funktion :: Bool
13:51:54 <xerox> @type System.Random.random
13:51:55 <lambdabot> forall a g.
13:51:55 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
13:51:55 <lambdabot> g -> (a, g)
13:51:58 <xerox> @type System.Random.randomIO
13:51:59 <lambdabot> forall a. (System.Random.Random a) => IO a
13:52:00 <jonkri> funktion = funktion' <my random value>
13:52:03 <jonkri> how would i do it?
13:52:12 <xerox> jonkri: check there:
13:52:14 <xerox> @docs System.Random
13:52:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.
13:52:15 <lambdabot> html
13:52:28 <jonkri> i want to use a arbitrary function, not those functions
13:52:48 <jonkri> i have a arbitrary function which is defined and ready to go, but i don't know how to use it :)
13:54:07 <xerox> jonkri: what's its type?
13:54:58 <jonkri> StdGen
13:55:12 <ihope> @index StdGen
13:55:12 <lambdabot> System.Random
13:55:28 <jonkri> hmm, ok
13:57:09 <benny> am i the only one who's code always comes out horribly ugly and fat?
13:57:36 <ihope> benny: probably.
13:57:55 <lisppaste2> benny pasted "ugly shit" at http://paste.lisp.org/display/16398
13:58:37 <ihope> AAH!
13:58:40 <benny> now i need to do something similar to that but with a bit more extra and i want to cry since it will be so ugly :(
13:58:55 <benny> i feel like this function should be able to be only 5 lines
14:00:03 <ihope> You can write an entire Haskell program in just one line.
14:00:10 <ihope> It's a very bad idea, however.
14:00:43 <benny> i meant 5 _short_ lines :)
14:01:00 <palomer> you can write any haskell function in 1 line
14:01:16 <palomer> unless there's a limit to the line length
14:01:20 <palomer> (is there?)
14:01:22 <jonkri> so if i want to pass a newStdGen to my function, i can't write "function newStdGen arg"?
14:01:23 <xerox> palomer: not if it should contain operations on user-defined types, right? :)
14:01:40 <palomer> xerox: hmm?
14:02:05 <xerox> 'data' statements should stay on lines for theirself, I think.
14:02:13 <ihope> Theirselves?
14:02:32 <ihope> Hmm. No semicolonation...
14:03:14 <benny> any ideas how i can clean up this code?
14:03:40 <palomer> xerox: I didn't say functions and datatype declarations
14:03:44 <TheHunter> if p then True else q ==> p || q
14:04:01 <benny> TheHunter: hm...
14:04:07 <ihope> @type (==>)
14:04:08 <lambdabot> Not in scope: `==>'
14:04:12 <ihope> @index ==>
14:04:13 <lambdabot> Test.QuickCheck, Debug.QuickCheck
14:04:22 <ihope> @fixity
14:04:23 <lambdabot> Unknown command, try @listcommands.
14:04:25 <jonkri> @type newStdGen
14:04:26 <lambdabot> Not in scope: `newStdGen'
14:04:36 <jonkri> how can i pass a new stdgen to a function?
14:04:43 <xerox> @hoogle StdGen
14:04:44 <lambdabot> System.Random.StdGen :: StdGen
14:04:44 <lambdabot> System.Random.mkStdGen :: Int -> StdGen
14:04:44 <lambdabot> System.Random.getStdGen :: IO StdGen
14:05:00 <xerox> In those (two last) ways.
14:05:58 <TheHunter> benny, I'm not too familiar with the arrow notation, I assume lifting all the lets one level higher doesn't work?
14:05:58 <palomer> @hoogle StateT
14:05:59 <lambdabot> Control.Monad.State.StateT :: StateT s m a
14:05:59 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
14:05:59 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
14:06:04 <jonkri> oh ok
14:06:22 <TuringTest> benny: I'll have a suggestion posted in a minute
14:06:27 <palomer> @kind StateT
14:06:28 <lambdabot> Not in scope: type constructor or class `StateT'
14:06:35 <palomer> @kind Control.Monad.State.StateT
14:06:35 <jonkri> i don't want to specify an int... what does io stdgen mean?
14:06:36 <lambdabot> * -> (* -> *) -> * -> *
14:06:42 <palomer> @hoogle ST
14:06:43 <lambdabot> Control.Monad.ST.Lazy.ST :: ST s a
14:06:43 <lambdabot> Control.Monad.ST.ST :: ST s a
14:06:43 <lambdabot> Graphics.UI.ObjectIO.CommonDef.St :: s -> (a, s)
14:06:48 <palomer> @kind Control.Monad.ST.ST
14:06:49 <lambdabot> * -> * -> *
14:07:36 <ihope> jonkri: IO is an abstract monad
14:08:06 <ihope> So IO StdGen can pretty much mean anything.
14:08:40 <ihope> I guess the Cont monad can be anything as well...
14:08:51 <ihope> @djinn m a -> Cont (m b) a
14:08:52 <lambdabot> -- f cannot be realized.
14:09:02 <jonkri> is there a way i can convert IO StdGen to StdGen so i can pass it to my function...?
14:09:11 <ihope> You can use (>>=)
14:09:17 <ihope> @type (>>=)
14:09:18 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
14:09:30 <ihope> Substitute IO for m and you've got it.
14:10:00 <palomer> but then you need to convert the result back to an IO, or the result of any computation involving that result
14:10:28 <ihope> @type returns
14:10:29 <lambdabot> Not in scope: `returns'
14:10:30 <ihope> @type return
14:10:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
14:10:42 <ihope> @type Control.Monad.LiftM
14:10:42 <lisppaste2> TuringTest annotated #16398 with "anaylze inp once" at http://paste.lisp.org/display/16398#1
14:10:43 <lambdabot> Not in scope: data constructor `Control.Monad.LiftM'
14:10:53 <ihope> @type Control.Monad.liftM
14:10:54 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
14:10:58 <ihope> Etc. etc.
14:11:14 <jonkri> ok.....
14:11:17 <jonkri> thanks
14:11:29 <TuringTest> benny: less ugly version at http://paste.lisp.org/display/16398#1
14:11:35 <TuringTest> but not optimal
14:11:57 <jonkri> ihope: but i can't use >>= when i'm sending an argument to a function=
14:12:37 <ihope> Um...
14:12:38 <benny> TuringTest: hm... very interesting, thanks
14:13:00 <ihope> Well, that'll allow any function to take an IO value.
14:13:05 <TuringTest> You can replace 1,2,3,4 with a meaningful Enum
14:13:31 <benny> instead of "any (==1)" we can use "elem 1" though i think
14:13:34 <jonkri> it doesn't take an io value. it takes an stdgen
14:13:40 <xerox> Anybody knows how does it work the compilation of an Haskell program using an own C main() function?
14:13:53 <xerox> Should I pass through that evil mess called make?
14:14:11 <palomer> @hoogle runStateT
14:14:11 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
14:14:40 <ihope> jonkri: that's the point of (>>=). Give it an IO value and a function which takes its contained type, and it'll return whatever the function returns, more-or-less.
14:14:42 <benny> i guess one must read lots of code in order to learn about all these cool techniques like "sifting"
14:15:05 <ihope> IO StdGen -> (StdGen -> IO a) -> IO a
14:15:38 <lisppaste2> TuringTest annotated #16398 with "Another way" at http://paste.lisp.org/display/16398#2
14:15:53 <TuringTest> benny: I made that word up
14:16:02 <jonkri> how would i use >>= to pass that argument to my function?
14:16:08 <jonkri> how would i type it?
14:16:20 <TuringTest> benny: I also just posted a variation on the nested if's
14:16:22 <ihope> Well, you can use liftM.
14:16:31 <ihope> @type Control.Monad.liftM
14:16:32 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
14:17:05 <ihope> Apply liftM to a (StdGen -> a) and it'll turn it into (IO StdGen -> IO a).
14:17:21 <jonkri> but i don't want a IO StdGen
14:17:40 <lispy> if you're lifting to IO use liftIO when you can
14:17:50 <jonkri> ok...
14:17:56 <jonkri> i have to read up on io
14:17:58 <TuringTest> xerox: All I know about main is here: http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/sec-ffi-ghc.html#using-own-main
14:18:11 <TheHunter> benny, as I suspected: |rec (d, f, r) <- arr foo -< (inp, f', r')| can be replaced by |rec let (d, f, r) = foo (inp, f', r')|
14:18:17 <lispy> jonkri: if you don't want IO StdGen what do you want? (sorry, just came to the conversation)
14:18:25 <jonkri> but for the moment, can you give me an expression which properly returns a stdGen i can use to my function which takes a StdGen
14:18:34 <jonkri> nothing more :-)
14:18:44 <TheHunter> which in turn can be straighforwardly simplified in your case.
14:20:05 <ihope> Well, just what is this IO StdGen we were looking at?
14:20:12 <ihope> I forgot.
14:20:16 <lispy> jonkri: there is a way, but it's unsafe
14:20:19 <ihope> @hoogle IO StdGen
14:20:21 <lambdabot> System.Random.getStdGen :: IO StdGen
14:20:21 <lambdabot> System.Random.newStdGen :: IO StdGen
14:20:21 <lambdabot> Prelude.readLn :: Read a => IO a
14:20:30 <ihope> Yeah, what are those?
14:21:02 <jonkri> lispy: why is it unsafe?
14:21:08 <lispy> jonkri: generally when you need to use IO to get some values you lift your functions into IO and they'll work there
14:21:41 <ihope> jonkri: because you don't know when the action is going to be performed
14:21:52 <lispy> jonkri: well, a value computed in IO depends on the state of the world, or at least the state of your program at that point.  When you take the value out of IO you loose all that context.  So the compiler could optimize incorrcetly or other things could happen.
14:22:06 <jonkri> ok, in this case, it doesn't matter
14:22:10 <jonkri> it's just about shuffling a deck
14:22:17 <lispy> @index unsafePerformIO
14:22:17 <lambdabot> System.IO.Unsafe, Foreign
14:23:33 <lispy> jonkri: okay, so if you take the random number calls out of IO the compiler might think they don't change (referential transparency) so you have to make sure that the compiler won't optimize incorrectly.  I don't know ghc well enough to explain that part
14:23:55 <lispy> jonkri: BUT, you have several options
14:24:31 <lispy> jonkri: 1) lift other functions into the IO monad.  Go ahead and write as much of your code as you can in a functional style and just use them inside the IO monad.  It's very common and a nice way to code in haskell.
14:24:53 <lispy> jonkri: 2) instead of using IO StdGen, try to use ST StdGen, that is, use the state monad instead of the IO monad
14:25:40 <jonkri> lisppaste2: alternative 2 sounds best. i just want a quick fix for a fun function that wont be used
14:25:52 <jonkri> lisppaste2: and i want to finish it now :-)
14:26:08 <TuringTest> jonkri: Look at http://haskell.org/hawiki/MonadRandom
14:26:22 <jonkri> so what would i type as an argument to my function that expects a StdGen value?
14:26:24 <lispy> option #2 doesn't always work.  Sometimes you need to enter the IO monad
14:26:28 <jonkri> TuringTest: ok
14:26:38 <xerox> TuringTest: my problem was just about compiling things in the right order.
14:27:17 <xerox> TuringTest: point being, you need to manually compile things in the dependency order...  or use make, for which GHC generates a .depend file, but I do not have time/will to understand the workings.
14:27:58 <TuringTest> xerox: As I said, I have no idea beyond the user's guide, sorry.
14:28:14 <jonkri> but in one place in my file there's a line that does this: "g <- newStdGen"
14:28:27 <jonkri> what's that? isn't that something i could do?
14:28:40 <jonkri> "my file" = another file than the one i'm coding on
14:29:17 <TuringTest> jonkri: you could use mkStdGen
14:29:21 <lispy> x <- newStdGen; x + x; would be the same as newStdGen >>= (+)
14:29:34 <lispy> er oops
14:29:39 <lisppaste2> TheHunter annotated #16398 with "cleaned up the mess" at http://paste.lisp.org/display/16398#3
14:29:52 <lispy> x <- newStdGen; x + x; would be the same as newStdGen >>= (\x -> x + x)
14:29:53 <xerox> no..
14:30:04 <xerox> hehe, return . ap (+)
14:30:12 <jonkri> i want to type "where x = newStdGen" and be done with it
14:30:19 <xerox> or (return .) . (+)
14:30:32 <lispy> jonkri: yeah, that's what " x <- newStdGen" does
14:30:44 <TuringTest> TheHunter: Nice use of case & pattern guards.
14:30:58 <lispy> jonkri: it does it "inside" the monad
14:31:08 <lispy> and now x is a normal value you're used to
14:31:12 <lispy> lke 4
14:31:29 <jonkri> but i get an error if i type: where \n do x <- newStdGen
14:31:37 <jonkri> and try to use x
14:31:46 <xerox> lispy: i.e. you missed a return.
14:31:55 <lispy> xerox: shame on me
14:31:55 <TuringTest> jonkri: You need a seed to create the StdGen.   The IO Monad can seed from the environment or you can use mkStdGen and pass in a seed.
14:32:22 <jonkri> TuringTest: how do i get a seed from the environment?
14:32:39 <TuringTest> jonkri: newStdGen
14:32:43 <TuringTest> But that is IO
14:32:51 <TuringTest> Since it is system environment dependent
14:32:53 <TheHunter> benny, I'm not sure if it's worth to factor out the common parts of the computations of f1 and f2, in any event, reordering the logical operations might speed things up.
14:32:58 <jonkri> ok
14:33:06 <jonkri> i don't care, i think i'll drop this
14:33:26 <jonkri> coming from a non-functional language, i'm not used to this much work just to create a generator
14:33:40 <jonkri> i wont understand this tonight...
14:33:49 <lispy> it's not a lot of work, so much as a very different technique
14:34:03 <ihope> Analogy time!
14:34:25 <jonkri> i'm not saying it's bad, or good, it's just that it's hard for me
14:34:26 * TuringTest looks at watch
14:34:47 <lispy> jonkri: it's hard for everyone at first.  Monads are a mystery until you work with them for a time
14:34:52 <ihope> Since we all know a scarecrow couldn't accept an organ transplant, we'd have to use (brain >>= scarecrow) to get the results we need.
14:35:02 <lispy> and there are some great explanations of them hanging around the net...
14:35:24 <lispy> ihope: wtf? ;)
14:35:43 <lispy> i get your point, but i don't tihnk it's very clear :)
14:35:59 <lispy> you mean to inject the brain into the scarecrow right?
14:36:25 <ihope> Yep.
14:36:55 <lisppaste2> TheHunter annotated #16398 with "actually..." at http://paste.lisp.org/display/16398#4
14:37:10 <lispy> jonkri: are you familiar with any monads?  have you used any of these before, >>=, >> or return?
14:37:26 <jonkri> lispy: no, and i don't think it's necessary for this program
14:37:28 <TheHunter> benny, you don't have recursion, so there's no need for 'rec' if you reorder the operations.
14:37:47 <lispy> jonkri: prehaps not, is it possible to show me the code?
14:38:16 <jonkri> lispy: yes, but it's an assignment so i can't ask on specifics
14:38:24 <lispy> jonkri: ah, i see
14:38:46 <jonkri> just that i want to shuffle a deck, and i can do that if i have a StdGen thingy to send to the function
14:39:00 <jonkri> that's as much randomization i need
14:39:06 <lispy> jonkri: in that case, i'd write all the code assuming you have some random number generator and for now just manually create the seeds
14:39:06 <jonkri> so it's not critical in any way
14:39:35 <jonkri> lispy: wouldn't the result be the same every time then?
14:39:40 <lispy> jonkri: yes
14:39:54 <jonkri> i don't think the teacher would like that
14:39:59 <jonkri> hehe :o)
14:40:15 <lispy> is the assignment supposed to be in haskell?
14:40:20 <jonkri> i don't get what's so hard about asking the environment to do it
14:40:21 <jonkri> yes
14:40:27 <ihope> Well, surely everything but the monad stuff would be worth partial credit, at least.
14:40:52 <ihope> I don't know how StdGen works, so...
14:41:04 <lispy> jonkri: if your teacher assigned it in haskell, and wants you to use the random number generator, then they are assuming you'll run into monads
14:41:21 * edwinb wonders why a 'darcs get' has to get all the patches rather than just the current working version.
14:41:21 <jonkri> yes, but i don't have to know that for this lab
14:41:28 <jonkri> it's comming in a forthcoming assignment
14:41:35 <lispy> edwinb: did you try 'darcs get --partial'?
14:41:38 <TuringTest> edwinb: --partial ?
14:41:45 * palomer wishes he could do a <- f <- foo instead of temp <- foo, a <- f temp
14:41:50 <edwinb> hoorah! I knew there'd be a sensible answer.
14:41:51 <edwinb> thanks ;)
14:42:12 <TuringTest> palomer: foo >>= a . f
14:42:14 <edwinb> I wish I'd know that last week when someone was complaining how long it took to grab ghc...
14:42:32 <TuringTest> palomer: foo >>= return . f 
14:42:36 <TuringTest> (oops)
14:42:42 <lispy> edwinb: the ghc website even says to use --partial :)
14:42:47 <xerox> TuringTest: that is fmap.
14:42:50 <palomer> a <- (foo >>= return . f) ?
14:42:53 <xerox> @pl \f xs -> xs >>= return . f
14:42:53 <lambdabot> fmap
14:43:07 <edwinb> I was actually following instructions on the CabalGetBootstrap wiki page.
14:43:12 <xerox> (or liftM if you prefer)
14:43:13 <TuringTest> palomer: a <- liftM f foo
14:43:19 <xerox> Dang.
14:43:19 <palomer> but yeah, arrows should be composable
14:43:32 <lispy> edwinb: ah, it's the trac site that mentions --partial
14:43:34 <TuringTest> xerox: imperssive
14:43:56 <xerox> It's an Haskell glitch ;-)
14:44:18 <lispy> haskell glitch?
14:44:32 <TuringTest> Monad vs Functor
14:44:38 <lispy> oh, right
14:45:03 <lispy> liftM is sort of nice in that situation because there is liftM2 and so on but only fmap
14:45:21 <palomer> liftM2 = lift.lift ?
14:45:29 <TuringTest> palomer: no
14:45:31 <edwinb> after all that cabal-get fails to build anyway. I think not doing this on Friday night might be a better idea.
14:45:40 <lispy> palomer: it's for functions of arity 2
14:45:56 <TuringTest> palomer: liftM2 f x y = do x1 <-x ; y1 <- y; f x1 y1
14:46:13 <lispy> but there was a more elegant way to define it...what was that...
14:46:17 <TuringTest> saves alot of typing
14:46:32 <xerox> If you add a f <- action, that becomes ap
14:47:18 <TuringTest> liftM5 (,,,,) can save alot of line 
14:47:18 <lispy> @pl \x y -> x >>= (x1 -> y >>= flip f x1)
14:47:19 <lambdabot> (line 1, column 19):
14:47:19 <lambdabot> unexpected ">"
14:47:19 <lambdabot> expecting variable, "(", operator or ")"
14:47:32 <lispy> @pl \x y -> x >>= (\x1 -> y >>= flip f x1)
14:47:33 <lambdabot> (. ((. flip f) . (>>=))) . (>>=)
14:47:41 <lispy> hm...i thought that would be liftM2
14:47:50 <vincenz> any graph geniuses?
14:47:56 <lispy> @pl \x y -> x >>= (\x1 -> y >>= f x1)
14:47:57 <lambdabot> (. ((. f) . (>>=))) . (>>=)
14:48:16 <lispy> @pl \f x y -> x >>= (\x1 -> y >>= f x1)
14:48:16 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
14:48:19 <lispy> bleh
14:48:19 <jyp> vincenz: no, but ask out :)
14:48:25 <vincenz> jyp: it's rather invovled
14:48:42 <lispy> vincenz: i know some very basic graph theory, certainly not a genious
14:48:45 <lispy> genius*
14:48:46 <jyp> any 3 word summary available ?
14:48:50 <vincenz> I'm afraid not
14:49:13 <jyp> 3 keywords then ?
14:49:15 * vincenz does some back of the envolve calculations
14:49:16 <lispy> is the problem famous enough to have a name?
14:49:27 <vincenz> basically
14:49:32 <vincenz> you have a graph...
14:49:41 <vincenz> and a set of nodes (let's define it an area)
14:50:21 <vincenz> oh wait
14:50:21 <vincenz> nm
14:50:32 <jyp> aye :)
14:51:13 <lispy> hehe
14:51:22 <lispy> i think we found our graph genius ;)
14:51:33 <vincenz> no it's hard to define
14:51:53 <lispy> what problem domain is this?
14:52:06 <vincenz> icfp 2005
14:52:18 <lispy> ah
14:52:55 <palomer> don't you guys think it would be cool to compose arrows?
14:53:02 <vincenz> I'm trying to define the 'seal' of an area such that given a minimum number of nodes where cops reside, the robber can not escape that area
14:53:44 <TuringTest> vincenz: That sound very non-unique
14:53:49 <vincenz> I know
14:53:54 <vincenz> all possible seals then
14:54:30 <lispy> who won the 2005 icfp?
14:54:34 <lispy> or do we know yet
14:54:42 <vincenz> yes we know, since last year september
14:54:55 <jyp> it turns out I did a bit of stuff on fully gated graphs
14:55:19 <jyp> might be worth looking it up on google ?
14:55:28 <TuringTest> ICFP 2005 results http://developers.slashdot.org/article.pl?sid=05/09/27/1811252&tid=156
14:59:46 <palomer> ghc needs better error messages!
14:59:47 <palomer> gah!
14:59:50 * palomer explodes head
15:00:13 <TuringTest> palomer: They are still shorter than C++
15:00:25 <edwinb> I got a 200 line error message the other day...
15:01:06 <palomer> edwinb: 190 of those lines were code quotations?
15:01:08 <edwinb> I think it was trying to be helpful, but I didn't really want all the functions in the where clauses too...
15:01:31 <palomer> "parse error in pattern" is rarely ever in the pattern
15:02:12 <edwinb> eventually you get to be able to interpret ghc's errors, but they rarely actually explain what the problem is directly...
15:02:35 <TuringTest> I find the line number the most useful part
15:03:11 <TuringTest> Unless it makes a specific "Add Context Foo" suggestion that isn't bogus
15:04:12 <lispy> palomer: i reviewed a paper that proposed a better type checker once...i wonder if the implementation is usabel...
15:04:32 <palomer> if I had more time, I would release my type checker
15:04:39 <palomer> it's really quite neat
15:04:42 <edwinb> Bruce McAdam did some work on fixing type errors, but I don't know what came of it.
15:05:04 <lispy> palomer: my suggestion would be to spend a little time googling for something that help with ghc type errors
15:05:18 <lispy> and if you find something cool, share it with us :)
15:05:23 <edwinb> Someone must have written "What ghc says and what it really means"...
15:07:45 <palomer> oh my god
15:07:54 <palomer> I've spent the last 2 hours switching things in my code without ever running it
15:07:57 <palomer> I'm going nuts!
15:08:27 <edwinb> Well if it compiles you already know it works, so you never need to run it, right? :)
15:09:30 <TuringTest> but he has errors
15:09:37 <palomer> I do?
15:10:03 <TuringTest> "ghc needs better error messages!"
15:10:22 <palomer> oh, yes, that thought runs through my head every 20 minutes or so
15:11:44 * ihope cries
15:11:45 <ihope> > (sort . map toLower . filter (\x -> x == ' ' || isLetter x)) ("I am reminded of when our book discussion group was reading Mary Shelley's FRANKENSTEIN. Somebody bought and read a book whose title was MARY SHELLEY'S FRANKENST" ++ "EIN. That turned out to be a very different book. Simply calling the book FRANKENSTEIN helps to assure that it really is Mary Shelley's FRANKENSTEIN, but calling...
15:11:46 <SyntaxNinja> most people just look at the line number, and then check the code for what's wrong, I think :)
15:11:46 <lambdabot>  lexical error in string/character literal
15:11:47 <ihope> ...it MARY SHELLEY'S FRA" ++ "NKENSTEIN guarantees that it is not Mary Shelley's FRANKENSTEIN, but a novelization of a film script. Actually, in the book world MARY SHELLEY'S FRANKENSTEIN is less Mary Shelley's" ++ " FRANKENSTEIN than is FRANKENSTEIN. However, in the film world MARY SHELLEY'S FRANKENSTEIN is more Mary Shelley's FRANKENSTEIN than is FRANKENSTEIN. But MARY SHELLEY'S" ++ "...
15:11:49 <ihope> ...FRANKENSTEIN is less Mary Shelley's FRANKENSTEIN than is TERROR OF FRANKENSTEIN. TERROR OF FRANKENSTEIN really is very much Mary Shelley's FRANKENSTEIN and deserve" ++ "s to be called MARY SHELLEY'S FRANKENSTEIN, but that was not what it was called. It was called VICTOR FRANKENSTEIN and then renamed for television. (I could not say that on the r" ++ "adio, and I am not sure it will make...
15:11:53 <ihope> ...sense even here.) -Mark R. Leeper")
15:11:59 <ihope> See? See? It doesn't work!
15:12:00 * TuringTest ducks
15:12:19 <TuringTest> ihope: Use http://paste.lisp.org/
15:18:58 <palomer> hrm
15:19:19 <palomer> I think ihope went nuts
15:20:35 <palomer> I've developed a system where I'm systematically keeping track of the changes I've made to undo them
15:21:30 <Philippa> good idea
15:23:11 <palomer> but, like, isn't there a monad for this:o
15:23:14 <palomer> or a framework
15:24:41 <palomer> Philippa: was adding patterns to your language a lot of work?
15:26:23 <TuringTest> palomer: ...darcs...
15:27:19 * palomer thinks of adding this capability to ST
15:27:27 <edwinb> I didn't think he meant changes to code...
15:27:38 <TuringTest> ah
15:27:58 <edwinb> changes to state, perhaps
15:27:59 <TuringTest> palomer: http://haskell.org/hawiki/MonadUndo is along those lines
15:30:00 <vincenz> question
15:30:02 <vincenz>  Ihave a read
15:30:07 <vincenz> for several classes
15:30:19 <vincenz> I would like to output the haskell code that would generate the same thing as reading the input would
15:30:25 <vincenz> but then in terms of those data constructors
15:30:52 <benny> TheHunter, TuringTest: hm...
15:31:42 <TuringTest> benny: I never wrote a project that needed arrows, so TheHunter is much better at cleaning up that code
15:34:51 <palomer> http://www.rafb.net/paste/results/IRUTi632.html
15:35:05 <TuringTest> palomer: reading...
15:37:02 <TuringTest> The type signature of comb is clearly wrong
15:37:40 <TuringTest> Unless "Undo s" is a pair?
15:37:48 <TuringTest> Define "Undo s" for us
15:37:58 <palomer> type Undo s= ([Unifier s],(UndoVars s))
15:38:16 <TuringTest> But no
15:38:27 <TuringTest> You claim on line 11:
15:38:28 <TuringTest>               return (remaining,(finalUndo::Undo s))
15:38:56 <TuringTest> which tells me that the snd member of "Undo s" is "Undo s" which can never type check
15:39:18 <palomer> oh, righto
15:40:03 <TuringTest> And that is the error GHC reports : Undo is not UndoVars
15:41:13 <palomer> but I'm not using UndoVars!
15:41:45 <TuringTest> comb takes hornclauses and return a monad which returns (Undo s)
15:42:01 <TuringTest> Undo s is defined as you said: with UndoVars in the snd position
15:42:20 <palomer> oh, right
15:42:27 <Philippa> palomer: pattern-matching wasn't /too/ hard, but could've been more trivial IYSWIM
15:42:47 <Philippa> it might help to start with non-nested patterns, as nested ones can be translated into them anyway
15:43:01 <palomer> IYSWIM?
15:43:01 <vincenz> how do you make a multiline string
15:43:11 <TuringTest> if you see what i mean
15:43:14 <palomer> "foo\nbar"
15:43:18 <vincenz> non
15:43:21 <vincenz> as in multiple source lines
15:43:33 <TuringTest> "hello\n" ++ 
15:43:36 <TuringTest> "world\n"
15:43:39 <vincenz> heh...
15:43:43 <lispy> i think you can do
15:43:48 <lispy> "blah" \
15:43:53 <lispy> \"foo"
15:43:56 <lispy> or something like that
15:44:56 <TuringTest> http://www.haskell.org/onlinereport/lexemes.html#sect2.6
15:45:02 <TuringTest> vincenz: for multiline strings
15:45:07 <vincenz> thx
15:45:23 <TuringTest> but you need \n\ to include a newline
15:45:32 <palomer> http://www.rafb.net/paste/results/MWhky329.html <--gah!
15:45:37 <palomer> this function is driving me nuts
15:46:09 <palomer> Philippa: so you simply call a function which analyzes the pattern and enriches the context, right?
15:46:25 <TuringTest> palomer: What is the addUndo definition??
15:46:41 <palomer> addUndo:: Undo s -> Undo s -> Undo s
15:46:47 <palomer> addUndo (a,b) (c, d) = (a++c,b++d)
15:46:50 <TuringTest> That is pure
15:47:05 <TuringTest> You use "let finalUndo = addUndo und  undos"
15:47:07 <TuringTest> not <-
15:47:13 <Philippa> palomer: yup. The typechecking's mildly more irritating
15:47:20 <Philippa> although less so in the absence of subtyping
15:47:38 <palomer> TuringTest: oh, very good point
15:47:45 <palomer> man, 5 hours of haskell makes me dumb
15:47:56 <palomer> (I've done over 35 hours this week)
15:47:59 <monochrom> haha
15:48:06 <TuringTest> The error message expected StateT, but addUndo is a tuple, thus the (,) in the error msg
15:48:28 <palomer> ahh, gotcha
15:50:33 <TuringTest> palomer: http://www.rafb.net/paste/results/9s8COY88.html
15:50:52 <TuringTest> Where unVars could be replaced by _
15:51:02 <TuringTest> Same for h and t
15:52:07 <palomer> TuringTest: yeah, that's what I did
15:52:18 <palomer> @karma +1 TuringTest 
15:52:18 <lambdabot> +1 has a karma of 0
15:52:23 <palomer> @karma TuringTest  +1
15:52:24 <lambdabot> TuringTest has a karma of 2
15:52:49 * TuringTest notices that @karma is not type checked
15:53:09 <bd_> @karma TuringTest +id
15:53:09 <lambdabot> TuringTest has a karma of 2
15:53:18 <TuringTest> oh
15:53:20 <TuringTest> cool
15:53:21 <bd_> tsk
15:53:41 <bd_> @karma TuringTest +(+)
15:53:41 <lambdabot> TuringTest has a karma of 2
15:53:48 <TuringTest> uh oh
15:56:19 <TuringTest> Anyone here have haskell code that implements regex matching?
15:56:29 <xerox> GHC has
15:56:37 <xerox> @hoogle Regex
15:56:37 <lambdabot> Text.Regex.Posix.Regex :: Regex
15:56:37 <lambdabot> Text.Regex.Regex :: Regex
15:56:37 <lambdabot> Text.Regex.Posix.regExtended :: Int
15:56:40 <xerox> @docs Text.Regex
15:56:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.
15:56:41 <lambdabot> html
15:56:48 <TuringTest> xerox: That is too slow for the shootout
15:56:54 <xerox> Aww :(
15:57:08 <vincenz> dcoutts_: ping
15:57:10 <vincenz> Cale: piin
15:57:10 <vincenz> Cale: piing
15:57:30 <vincenz> xerox: ping
15:57:30 <TuringTest> Tcl 2.5 seconds , Ruby 12.6 second, Haskell > 3000 seconds with Text.Regex
15:57:47 <TuringTest> xerox: It is really quite bad
15:58:24 <vincenz> xerox: how do I add a mouselistener to a drawingarea?
15:58:32 <TuringTest> It is the only shootout entry that does not work ( http://haskell.org/hawiki/RegexDna )
16:07:53 <dons> TuringTest, we have JRegex?
16:08:05 <TuringTest> I *just downloaded that 3 seconds ago
16:08:21 * TuringTest is freaked out
16:09:56 <TuringTest> But it uses hsc
16:10:42 <benny> dons: hi! did you ever get a chance to look into that hs-plugins bug with file closing?
16:14:56 <dons> hey, I've put some timing notes on regex-dna, TuringTest. did you see?
16:15:20 <TuringTest> yes
16:17:17 <benny> w00t! this shit works!
16:17:19 <palomer> yay, everything type checks!
16:17:58 <TuringTest> dons: hsregex has a template haskell thing for regex
16:18:22 <TuringTest> oops...based on PCRE
16:24:00 <palomer> @hoogle mapM_
16:24:01 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:24:01 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:24:01 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
16:24:51 <TuringTest> dons: what is #type ??
16:26:15 <TuringTest> ah
16:26:18 <TuringTest> I found the docs
16:26:24 <palomer> @hoogle zip
16:26:25 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
16:26:25 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
16:26:25 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [
16:26:25 <lambdabot> c]
16:31:58 * TuringTest signs off
16:34:25 * palomer wishes there was a shorter word for correspondence
16:35:39 <benny> how can i compile a program with -prof if it uses some library?
16:57:00 <palomer> whew
16:57:06 <palomer> I've written al the functions I need
16:57:20 <palomer> is there any way to trace an error?
17:01:05 <palomer> I'm quite generous with my error calls
17:02:33 <lispy> palomer: hat
17:02:39 <palomer> hat?
17:02:41 <lispy> palomer: and there is a part of the ghc manual on doing that
17:02:58 <palomer> what hat?
17:05:13 <astrolabe> http://www.haskell.org/haskellwiki/Projects#Tracing_.26_debugging
17:08:44 <palomer> oh my, which to use?
17:08:56 <palomer> oh, hat
17:12:02 <palomer> grrr, hat doesn't want to install
17:12:08 <palomer> make
17:12:08 <palomer> /home/palomer/src/hat-2.04/lib/ix86-Linux/config:11: *** missing separator.  Stop
17:14:08 * araujo is gonna try something, and if it works, he will yell at the neighbourhood from his rooms windows "Haskell Rulez!!!"
17:14:25 <palomer> it won't work
17:15:21 <araujo> it's a bit crazy, let's hope it works
17:18:47 * araujo is scared
17:20:01 * lispy shivers in fear
17:20:54 <vincenz> if you make a generic data struct
17:21:02 <vincenz> data MyStruct a = X a deriving (Eq,Ord)
17:21:07 <vincenz> how does it check that a is Eq and ord
17:23:01 <lispy> vincenz: try it
17:24:35 <int-e> deriving does that for the instances it generates; they'll be instance Eq a => Eq (MyStruct a) and instance Ord a => Ord (MyStruct a)
17:25:14 <int-e> So if a isn't an Eq instance, MyStruct a will not be, either.
17:27:23 <vincenz> ah cool
17:41:40 <lennart> howdy
17:45:13 <palomer> hey lennart 
17:45:27 <palomer> lennart: is doing static analysis with patterns hard at all?
17:47:29 * araujo sings.. "don't take money, don't take fame, .. don't take credit card to ride this train...."
17:48:19 <vincenz> hmm
17:48:34 * vincenz is in an IO ()
17:48:37 <vincenz> (onClick)
17:48:41 <lennart> palomer: what kind of static analysis?
17:48:42 <vincenz> and I would like to be able to change some state
17:48:45 <vincenz> how do I do this?
17:48:53 <vincenz> wait nm
17:48:57 <vincenz> I'll just use an IO ref
18:16:44 <palomer> lennart: err, type inference
18:17:37 * vincenz made a gui
18:17:42 <vincenz> but for some reason the response is a bit slow
18:18:33 <lennart> palomer: nah, patterns doesn't really make much of a difference
18:21:49 <vincenz> how hard is it to do unsafeEval code
18:22:22 <palomer> lennart: you simply add bindings to the context, right?
18:26:30 <palomer> bbl
19:22:47 <vincenz> is it posisble to hae
19:22:56 <vincenz> data xxx a = (Eq a) => ...
19:28:28 <Speck> would anyone be interested in explaining oleg's left fold inside out thing? I don't understand it from the material on his site -- it's presented a little too academically for me
19:48:01 <int-e> vincenz: data Eq a => X a = Y a | Z
19:48:40 <int-e> data (Eq a) => X a = Y a | Z will work, too.
19:50:35 <lennart> but contexts on data declarations are pretty meaningless
19:51:08 <vincenz> thx
19:51:22 <ncalexan> vincenz: data Blah = forall e . (Foo e) => Blah e also creates an existential.
19:51:48 <ncalexan> creates? declares an existential type.
19:57:55 <user317> existential??? can i only understand that type if i am that type?
19:58:12 <Korollary> to type or not to type
20:44:53 <vincenz> how do I profile with cairo
20:49:14 <Lemmih> Like with any other Haskell program?
20:50:38 <vincenz> no
20:50:47 <vincenz> vincenz@AbstractOasis:~/work/repos/icfp$ ghc -prof --make Cop.hs
20:50:47 <vincenz> Chasing modules from: Cop.hs
20:50:49 <vincenz> Could not find module `Graphics.Rendering.Cairo':
20:51:10 <Lemmih> Well, you need to compile Cairo with profiling enabled.
20:51:14 <vincenz> how?
20:51:33 <Lemmih> './Setup.lhs configure --enable-library-profiling' when configuring Cairo.
20:51:41 <vincenz> there is no Setup.lhs
20:51:50 <Lemmih> Gtk2hs probably has a neater way of doing it.
20:52:50 <vincenz> nothing
20:53:26 <int-e> gtk2hs just has a configure; autoreconf then ./configure with appropriate options, then make, make install
20:54:10 <vincenz> yeah but no options for profiling
20:58:43 <vincenz> int-e: there's no option for profiling
20:59:11 <int-e> hmm
20:59:21 <int-e> true.
20:59:22 <vincenz> @seen dcouts
20:59:22 <lambdabot> I haven't seen dcouts.
20:59:25 <vincenz> @seen ddcouts
20:59:25 <lambdabot> I haven't seen ddcouts.
20:59:28 <vincenz> @seen dcoutts
20:59:28 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. Last spoke 3 hours, 7 minutes
20:59:28 <lambdabot> and 34 seconds ago.
20:59:32 <vincenz> @seen cale
20:59:32 <lambdabot> cale is in #haskell. Last spoke 7 hours, 31 minutes and 46 seconds ago.
20:59:37 <vincenz> dcoutts: ping
20:59:39 <vincenz> @seen xerox
20:59:40 <lambdabot> xerox is in #haskell.it, #haskell-overflow, #haskell-blah and #haskell.
20:59:40 <lambdabot> Last spoke 5 hours, 2 minutes and 45 seconds ago.
21:01:16 <int-e> configure:  --with-hcflags=HCFLAGS  flags for Haskell tools, default: -O
21:01:41 <int-e> You can add some flags for ghc there.
21:02:32 <vincenz> tx
21:02:43 * vincenz crosses his fingers
21:03:18 <vincenz> caif I install this then my normal cairo will be gone, right
21:03:41 <vincenz> is there a possibility not to install this globally and tell it to look there for cairo instead of sys
21:04:49 <int-e> Hmm. for the C libs you can install them with a different prefix. for haskell with ghc-pkg, I believe that's not possible (but I don't really know)
21:05:06 <vincenz> int-e: how about not installing it and telling it to look elsewhere
21:05:30 <int-e> I've never tried.
21:43:34 <dons> musasabi, fixed version of spectral-norm on the wiki (gcc miscompiles this with -O3 as well)
21:45:05 <palomer> I'm addicted
21:45:13 <palomer> I went out dancing, and all I could think about was haskell
21:45:50 <SamB> can you figure out how to code dances in Haskell?
21:45:58 <palomer> :o
21:46:03 <palomer> @hoogle unique
21:46:04 <lambdabot> Data.Unique.Unique :: Unique
21:46:04 <lambdabot> Data.Unique.newUnique :: IO Unique
21:46:04 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
21:46:13 <palomer> is there a function that removes duplicates from a list
21:46:14 <palomer> ?
21:46:20 <ncalexan> @type nub
21:46:21 <lambdabot> Not in scope: `nub'
21:46:25 <ncalexan> @type List.nub
21:46:25 <palomer> @hoogle nub
21:46:25 <lambdabot> forall a. (Eq a) => [a] -> [a]
21:46:26 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
21:46:26 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:46:32 <palomer> what's it stand for?
21:46:41 <ncalexan> But I think you want sort . nub.
21:47:02 <ncalexan> nub removes only consecutive duplicates, IIRC.
21:47:02 <palomer> why sort?
21:47:12 <palomer> I can't sort:(
21:47:31 <Lemmih> > nub [1,2,3,1]
21:47:32 <lambdabot> [1,2,3]
21:47:38 <palomer> ah hah!
21:47:44 <ncalexan> Sorry, not consecutive dups at all :)
21:47:50 <palomer> had me worried there
21:48:04 <palomer> is there a module for linked list?
21:48:19 <palomer> with O(1) back insertion, front insertion and appending?
21:48:19 <Lemmih> Data.List?
21:50:13 <Lemmih> There's Data.Sequence in newer GHC's.
21:53:42 <palomer> yay for infinite loops!
21:54:33 <palomer> what's the best way to find out where a program is looping?
21:57:28 <vincenz> palomer: which version
21:59:28 <palomer> 6.4.1
22:00:45 <vincenz> don't see it
22:16:55 <palomer> well, finished writing my code, time to debug
22:16:55 <palomer> ugh.
22:19:47 <palomer> I have a set of equality type values, and I want to assign a unique string to each one
22:19:51 <palomer> is there a generic way of doing this?
22:54:14 <Saulzar> dons, Seems a little strange if it's a GCC issue, although O3 is "risky" I don't think I've ever had a C or C++ program go wrong with -O3 ...
22:55:00 <Saulzar> My current project doesn't work with gcc -O3 either
