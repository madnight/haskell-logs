00:11:19 <maus> A question about gtk2hs. Is there any way to make widget stop interacting with user? Something like 'widgetSetSensitivity' but without changing a visual appearance.
00:26:40 <araujo> Cale, it's odd, but im testing if the handle is closed and it returns False
00:26:51 <araujo> Nevertheless, i get that error when i use hGetcontents
00:27:18 <Cale> do you ever accidentally call hClose on the handle later?
00:27:35 <Cale> (though that should just cut the list off, not throw an exception)
00:28:10 <Cale> (you should never close a handle which has had hGetContents applied to it)
00:28:53 <araujo> mm.. not, im not doing that really....
00:29:11 <Cale> hmm
00:33:17 <araujo> well.. it's odd..im testing if the handle is closed, the first time it says it is open, then i use hGetContents, it returns the value right. 
00:33:31 <araujo> After that i test if the handle is closed now, and it does say it is closed.
00:33:41 <araujo> Nevertheless, it ends up with that exception....
00:34:35 <Cale> odd
00:34:50 <Cale> I really should sleep
00:35:11 <Cale> but if you're still having trouble, ask me again when I'm awake, and I'll look at the code
00:35:34 <araujo> haha ok, i also should go sleep  actually :-]
01:34:23 <dons> gour, still #1 fromm what I can see: http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
01:35:01 <dons> and still #1 on p4 as well.
01:37:04 <gour> dons: hmm..strange. i remembered seeing it as #1 few days ago, and today i got #5. now it's #1 again. don't know how #5 entered in cache. anyway. thanks for bringing good news (again :-)
01:48:09 <TeR-> hi there, a have a problem with one recursive function..
01:48:14 <TeR-> can somebody help me? 
01:49:05 <TeR-> it seems that putStrLn makes another Term unvalid
01:51:12 <TeR-> przejdz [] = []
01:51:12 <TeR-> przejdz (one:rest) = do 
01:51:12 <TeR->     putStrLn ("silnia numeru "  ++ show(one) ++  " to " ++ show(silnia one))
01:51:12 <TeR->     przejdz rest
01:51:42 <Lemmih> TeR-: przejdz [] = return []
01:51:47 <TeR-> the 'przejdz test' is treated like continuation of putStrLn, as it prompts Type error
01:51:55 <TeR-> Lemmith: why ?
01:52:12 <Lemmih> TeR-: If you don't want przejdz to be monadic then you can't use putStrLn.
01:52:13 <TeR-> why , f.e. factorial 0 =1 , and przejdz [] = return [] ?
01:52:50 <Lemmih> @type \x -> do putStrLn ""; x
01:52:51 <lambdabot> forall t. IO t -> IO t
01:53:02 <TeR-> unlucky, i don't know what monads stands for right now, cose i'm newbie :P
01:53:04 <Lemmih> ^^ 'x' _must_ be an IO action.
01:54:35 <Lemmih> TeR-: Short answer: You can't use 'putStrLn' there.
01:55:02 <TeR-> Lemmih :thanks :]
01:55:15 <TeR-> what should i do then, if i want to do what i want? :]
01:56:13 <Lemmih> Use Debug.Trace.trace.
01:56:16 <Lemmih> @oldwiki ThatAnnoyingIoType
01:56:17 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
01:57:10 <TeR-> thanks guys
01:57:42 <TeR-> very much
01:59:56 <Lemmih> TeR-: Why aren't you using 'mapM_', btw?
02:01:24 <davidhouse> przejdz = mapM_ (\a -> putStrLn "silnia numeru" ++ (show a) ++ " to " ++ (show $ silnia a))
02:02:44 <davidhouse> or use a let clause to get rid of that ugly lambda.
02:03:11 <Lemmih> or use UTF-8 to get a pretty lambda (:
02:03:41 <davidhouse> how well is utf supported in compilers?
02:04:28 <Lemmih> ghc-head supports utf-8 in source files.
02:04:44 <davidhouse> right.
02:07:33 <sieni_> lambadabot: que?
02:08:41 <davidhouse> hehe... lambadabot :) you mean lambdabot? ;)
02:10:12 <ValarQ> :)
02:50:08 * sieni_ wonders if fink and darwinports work nicely together
02:50:13 <sieni_> probably
03:16:30 <xerox_> G'day.
03:17:57 <ValarQ> hi xerox_ 
03:20:41 * shapr boings
04:04:16 <astrolabe> "The haskell school of expression" says that Ix can be derived, but the report says it can't.  I suppose the report is correct ?  :(
04:07:35 <dons> try it?
04:08:46 <dons> yep. you can derive it, if you''e got Eq and Ord.
04:09:10 <dons> gour, I'm thinking you saw the intermediate result of a run? or possibly just a cache issue.
05:05:34 <JohnMeacham> astrolabe: it can be, but it is in an odd place in the report that it says so. I remember it confusing me too.
05:08:35 <astrolabe> thanks guys
05:14:37 <astrolabe> "It is possible to derive an instance of Ix automatically, using a deriving clause on a data declaration ...Such derived instance declarations for the class Ix are only possible for enumerations (i.e. datatypes having only nullary constructors) and single-constructor datatypes, whose constituent types are instances of Ix.
06:04:18 <shapr> Can I use {-# OPTIONS #-} for include -i paths?
06:08:40 <shapr> Hm, doesn't seem so.
06:08:57 <pesco> shapr: did you try?
06:09:19 <shapr> pesco: yeah
06:09:39 <pesco> Okay.
06:09:43 * pesco makes a mental note.
06:09:44 <shapr> But I want to use it in GHCi, so that maybe the only problem.
06:09:53 <pesco> Hm.
06:13:50 <xerox_> Hey shapr!
06:13:54 <shapr> hiya xerox_
06:14:19 <xerox_> I'm busy trying to package libsvg-cairo in .deb, then I'll try to code out the graphical part of our beloved hourglass.
06:14:41 <xerox_> (That's why there is no darcs repo yet)
06:15:18 <shapr> cool :-)
06:16:05 <shapr> Speaking of debian, I need to setup this spare hardware I have...
06:16:47 <jethr0> hi shapr
06:17:01 <xerox_> The thing is: if I compile libsvg in the usual rite 'sh configure && make', it works nicely.  But if I dpkg-buildpackage -rfakeroot, it fails spitting out a list of 'undefined references'.  Grumble.
06:17:06 <shapr> hiya jethr0 
06:17:15 <shapr> How's code?
06:17:39 <jethr0> always good :)
06:17:57 <xerox_> shapr: do you have any experience in crafting deb packages?  I'm going quite mad.  I also have flu, dang.
06:17:59 <jethr0> i've got my 2-layer neural net working. and it's like 6 lines of haskell code :)
06:18:16 <jethr0> xerox_: have you tried what happens as real root?
06:18:18 * dcoutts feels dirty, he's fixing & testing the wxhaskell ebuilds
06:18:32 <shapr> xerox_: sadly no
06:18:38 <xerox_> jethr0: if I 'sh configure && make' it compiles nicely.  What do you mean?
06:18:49 * xerox_ pets dcoutts
06:18:53 <sethk> xerox, I've heard they are a bit of a PITA, but this is the first time I've heard that they cause flu
06:19:05 <jethr0> xerox_: i mean if it's maybe a problem with fakeroot.
06:19:08 * xerox_ laughs
06:19:15 <dcoutts> xerox_, thanks :-)
06:19:46 <xerox_> jethr0: mumble.  Do you know what else I could try, without getting my installation in troubles?  I'm sorry I'm not quite fond on the subject.
06:20:25 <jethr0> troubles?
06:20:43 <shapr> jethr0: nifty, is the source online?
06:21:15 <xerox_> Let's try to run it as root.  They're nice in providing a 'make uninstall', in case.
06:21:19 <jethr0> shapr: yup, http://jethr0.dyndns.org/repos/neural/, but it's still very experimental
06:21:37 <shapr> spiffy
06:21:53 <xerox_> BANG, it fails.
06:23:13 <shapr> Anyone know if jabber connections can be end to end encrypted with standard clients?
06:24:50 <jethr0> xerox_: have you maybe got some LD_LIBRARY_PATH stuff in .bashrc or otherwise user-related that won't be used as (fake)root?
06:26:02 * JKnecht counts 131 lines in Neuron.hs :)
06:26:53 <xerox_> I found a difference...
06:28:13 <xerox_> dpkg-buildpackage does '... -Wl,-z -Wl,defs -Wl,-soname -Wl,libsvg.so.1 ...'
06:28:21 <xerox_> make does '... -Wl,-soname -Wl,libsvg.so.1 ...'
06:29:40 <jethr0> hmm
06:30:12 <xerox_> Let's see if it changes anything if I remove '-Wl,z'
06:30:53 * xerox_ bounces happily here and there, singing victory
06:31:03 <xerox_> \o/
06:31:17 <jethr0> ^_^
06:32:03 <jethr0> shapr: i think you're one of the _very_ few people introduced to haskell by their financee :)
06:33:19 <davidhouse> dcoutts, you around now?
06:33:26 <dcoutts> davidhouse, yep :-)
06:34:50 <davidhouse> dcoutts :) (gtk2hs) remember a couple of days ago when i asked the easiest way to block, waiting on a signal then return the contents of some entry? you recommended IORefs and threading. IORefs worked but it's a little ugly, so i was wondering if you knew of any docs/tutorials on threading?
06:36:06 <dcoutts> davidhouse, yes.
06:36:07 <dcoutts> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
06:36:53 <dcoutts> davidhouse, you also might like to look at the gtk/soe implementation, it has to turn async events into sync events.
06:37:07 <dcoutts> it doesn't use threads, but it's pretty similar
06:37:11 <davidhouse> dcoutts, thanks, i'll have a look.
06:43:15 <davidhouse> @index forkIO
06:43:15 <lambdabot> Control.Concurrent
06:44:50 * xerox_ growls
06:51:47 <shapr> jethr0: Where'd you read that?
06:51:54 <jethr0> on your homepage
06:51:57 <shapr> oh
06:52:07 <jethr0> by apache just died mysteriously
06:52:23 <shapr> your apache?
06:52:30 <jethr0> yup
06:52:40 <shapr> Where's your website?
06:53:02 <jethr0> just my own computer. but w/o apache there's not much "website", is there :)
06:53:09 <shapr> true
06:53:10 * ValarQ has stopped using apache
06:53:22 <shapr> You know something better than apache?
06:53:38 <ValarQ> no, but i know something which works better for me
06:53:40 <shapr> jethr0: My homepage has been down for a few days now, are you using a local copy?
06:53:46 <shapr> ValarQ: what is it?
06:53:49 <jethr0> no
06:53:52 <ValarQ> shapr: twisted.web
06:53:57 <shapr> oh
06:54:27 <jethr0> http://www.scannedinavian.org/output/en/haskell.html
06:55:14 <shapr> oh right
06:55:18 <shapr> The 'other' webpage.
07:02:33 <davidhouse> @pl \_ -> return ()
07:02:34 <lambdabot> const return
07:03:14 * xerox_ is going nuts
07:04:01 * dcoutts rattles xerox 
07:04:35 * dcoutts concludes that xerox has indeed truned into a nut
07:09:33 * shapr builds ginsu
07:19:15 <araujo> Good morning.
07:31:15 <shapr> JohnMeacham: autoreconf fails on the ginsu repo, should it work?
07:32:49 <shapr> hola araujo 
07:32:58 <araujo> Hola shapr :-]
07:33:01 <shapr> wassup?
07:33:51 <araujo> shapr, amazed how you can't fix stupid bugs when you are so tired :-)
07:34:20 <araujo> been trying to get this bug fixed last night, and today i woke up and fixed it immediately
07:34:26 <araujo> how about you?
07:34:59 * xerox_ sings loudly
07:35:16 <shapr> For once, I am fixing interesting bugs :-)
07:35:34 <xerox_> I got around this dpkg-foo madness!  I admit .debs got a very appealing look, now that I understand more the machinery behind them.
07:36:04 <shapr> Oh, I'll have to ask you to give me a tutorial when you can :-)
07:36:11 <shapr> I wonder if they give IRC deb classes...
07:37:05 <araujo> haha
07:37:22 <shapr> I'm sort of surprised there are regular classes on freenode.
07:37:23 <araujo> shapr, what kind of bugs of you fixing?
07:37:24 <xerox_> Will do.
07:37:53 <shapr> araujo: Bugs for my Evil Project, which I can't talk about right now. It may turn into paying Haskell work.
07:37:53 <xerox_> darcspulling gtk2hs...
07:38:03 <araujo> shapr, sweet :-]
07:39:12 <xerox_> shapr: could you point me again to the monkey-eek and the other scream-like sound?
07:39:14 * araujo thinks that getting paid by coding on Haskell should be cooool
07:39:27 <xerox_> araujo: it _is_
07:39:34 * xerox_ blinks
07:40:16 <shapr> xerox_: They come with xemacs21, I can put them online for you.
07:40:18 <araujo> well, i think that actually many people is paid with Haskell, but mainly for teaching and researching. 
07:40:30 <araujo> I wonder how many developers are paid for Haskell projects
07:40:55 <araujo> developers in the sense of people developing applications :-]
07:41:10 * shapr mentally calculates...
07:41:17 <xerox_> shapr: I have them on some harddrive, but it's a pain to move around, connect things & co.  I would love if you could put them online (do you also have the .bashrc function I made at the time?)
07:41:24 <shapr> At least thirty...
07:41:45 <araujo> We need more!
07:41:49 <araujo> ;_)
07:42:05 <shapr> xerox_: You could keep those sorts of useful config files in a public darcs repo, and then just get it to new systems :-)
07:42:16 <xerox_> shapr: indeed.
07:42:37 <xerox_> Okay, I'll take the occasion to connect that device and get back the ssh public keys too.
07:42:49 * xerox_ chomps a cookie
07:42:52 <shapr> I don't have your .bashrc function, I use zsh
07:43:08 <xerox_> Maybe it worked seamlessy with zsh too?
07:43:13 * shapr doesn't know
07:43:46 <shapr> The function you wrote isn't in my .zshrc, sorry.
07:44:07 <xerox_> No problem.
07:51:33 <xerox_> Wee.
07:51:35 <xerox_> It's snowing!
07:52:03 <gour> dcoutts: you are moving to another camp?
07:58:12 * xerox_ pokes dcoutts
07:58:58 <gour> xerox_: snowing? here is +15C
07:59:04 <xerox_> Yay.
07:59:24 <xerox_> Do you know what is the proper way to install Gtk2Hs after a darcs pull && autoreconf && sh configure && make?
07:59:54 <xerox_> 'ghc-pkg unregister' everything and manually remove the files installed before?
08:00:46 <gour> xerox_: what's wrong with 'make install' ?
08:00:57 <xerox_> Oh I see...
08:01:10 <xerox_> I mean, if I didn't compile yet, I could 'make uninstall'.
08:01:32 <xerox_> But nevermind, it just install things under /usr/local/lib/gtk2hs/, hence no problem.
08:02:28 <gour> xerox_: i'm not sure whether (and how) 'make uninstall work. fortunately there is not much to clean manually
08:04:59 <xerox_> It's all right.
08:06:08 <gour> xerox_: fine
08:09:05 <dcoutts> xerox_, yeah, make install should just work, even if you've got an old version gtk2hs installed/registered
08:10:19 * shapr uses Gale
08:11:01 <wli> shapr!
08:11:34 <shapr> heya wli, how's code?
08:11:59 <wli> shapr: Not much has happened recently, but there is some code you've not picked up yet.
08:12:05 * shapr picks...
08:13:44 <xerox_> Cale: ping
08:17:31 * xerox_ yows
08:17:36 <shapr> @yo
08:17:36 <lambdabot> All of life is a blur of Republicans and meat!
08:17:38 <jethr0> hi bjoernz 
08:17:51 <bjoernz> hi
08:20:24 <xerox_> http://img219.imageshack.us/img219/762/1902061717hourglass6fz.png
08:20:32 <xerox_> That's something!  Finally.
08:22:14 <taw> hello
08:22:22 <taw> anyone using eclipse with haskell ?
08:22:56 <taw> i'm getting plug-in was unable to load class errors
08:23:18 <xerox_> I'm not, sorry.
08:27:14 <xerox_> dcoutts: I'd love to have libnotify bindings, do you think they could go into gtk2hs?
08:27:31 <Beelsebob> taw: why on earth would you want to use that?
08:27:45 <dcoutts> xerox, oh the desktop notification things?
08:27:50 <sh10151> Beelsebob: it's the future!
08:27:52 <sh10151> :)
08:27:53 <xerox_> Yeah.  Those are *great*, impo.
08:27:57 <xerox_> imo, even.
08:27:59 <dcoutts> xerox_, if you write the binding, sure! :-)
08:28:29 <xerox_> dcoutts: did you see them recently?  They're cairo powered in gnome, and they make very nice-looking shapes (with transparent backgrounds!)
08:28:33 <taw> Beelsebob: well, i want to un-1980s myself and move from command line to some real IDE :-)
08:29:05 <wli> Command lines are good.
08:29:33 <xerox_> Emacs is too.
08:29:55 <jyp> taw: with tuomov around, those are very risky statements :)
08:29:56 <xerox_> dcoutts: another idea... what about "animate" svg?
08:30:10 <wli> uh-oh, emacs vs. vi
08:30:26 <shapr> I like yi. It's got the bets of both worlds.
08:30:37 <xerox_> Yi!  We need more Yi.
08:30:56 <jyp> Are you the knights who say Yi?
08:30:59 <shapr> definitiely
08:31:18 <taw> emacs vs. vi is so early 1990s
08:32:08 <jethr0> but it somehow never stopped inciting flame wars. probably because each "camp" had very specific dislikes for the other editor
08:32:25 * shapr shrugs
08:32:38 <shapr> They both have advantages and disadvantages.
08:32:51 <dcoutts> xerox_, I'm not sure how we'd do animated svg easily. Do any of the C libs do svg animations?
08:33:03 <xerox_> dcoutts: http://www.w3.org/TR/SVG/animate.html
08:33:17 <xerox_> It seems that it's a pure-SVG property...
08:33:25 <sh10151> this seems to be eclipse vs. emacs/vi though?
08:33:27 <dcoutts> xerox_, yeah sure, but what about implementations?
08:33:56 <taw> sh10151: well, emacs is somewhere between the two actually :-)
08:34:00 <dcoutts> xerox_, animation & interaction involves quite a bit more that just renderSVG :: SVG -> Render ()
08:34:06 <shapr> I think SVG was going to get animation from SMIL.
08:34:09 <xerox_> dcoutts: well, right... I was trying the example on firefox and it didn't animate.
08:34:32 <xerox_> http://www.w3.org/TR/SVG/images/animate/anim01.svg
08:34:34 <taw> are people using any other ide for haskell maybe ?
08:35:05 <dcoutts> xerox_, yeah, I don't think it's there yet, it'd need to be like a Gtk+ widget to allow for the interaction. Doesn't it also reqires java script & a DOM ?
08:35:16 <xerox_> taw: to sum up what had been said: people use Emacs and vim, but there's Yi coming from distance.
08:36:00 <xerox_> dcoutts: that's possible.  I know so little in fact, I was just approaching the idea--it would be probably cool for hourglass.
08:36:37 <dcoutts> xerox_, I think it's a bit of a way off yet - animated svg in free software impls.
08:37:02 <xerox_> dcoutts: I'd better go for drawing the thing programmatically, and Time -> Render () ?
08:37:17 <dcoutts> xerox_, probably yes
08:37:40 <xerox_> Well in fact I could draw the static background with the SVG, and draw the dynamic parts programmatically.
08:38:45 <xerox_> It wouldn't make the GUI 'skinnable'... but hey.
08:46:57 <xerox_> I need Bézier splines.
09:55:24 * shapr boings
09:55:27 <shapr> Sure is quiet here tonight.
09:55:44 <shapr> Everybody is writing useful code?
09:57:38 <Lemmih> Yes!
09:57:44 <shapr> Yay!
09:58:07 <Lemmih> Writing useful code while waiting for the Simons to return.
09:59:04 <Lemmih> I'm hacking a dead code analyzer for Cabal projects.
09:59:18 <shapr> neat
10:01:30 <Lemmih> I wonder how much of GHC is dead code.
10:02:03 <Lemmih> What about you, shapr? Stuck with boring Python work?
10:02:31 <shapr> Nah, today is dedicated to my Evil Project, so I'm hacking Haskell and enjoying it.
10:02:36 <dcoutts> yay
10:02:52 * dcoutts is trying to fix wxhaskell
10:03:11 <shapr> Tomorrow is boring Python work.
10:03:34 <dcoutts> it seems there is no working version of wxGTK-2.4.x which means the stable version of wxhaskell does work :-(
10:03:39 <dcoutts> does/does not
10:04:16 <Lemmih> Then more people will use gtk2hs, no?
10:04:17 <dcoutts> Lemmih, yay!
10:04:33 * xerox_ found his Bézier splines and his having fun drawing something resembling an hourglass :)
10:04:34 <dcoutts> wxWidgets it a pita to build
10:06:32 <gour> true, especially on gentoo :-)
10:19:02 <camio> Are there any XML libraries out there better than "Haskell Xml Toolbox"?
10:20:30 <dcoutts> camio, there's haxml too
10:20:31 <dcoutts> dunno about better
10:20:43 <camio> hrm, bummer
10:21:12 <camio> looked like hxt is supposed to be all of haxml but better.
10:21:42 <jyp> 'better' in which direction are you looking for ?
10:22:05 <camio> I'm looking for good docs and easy to jump into. Sorta like etree for python.
10:22:34 <camio> I've written a Relax NG compact parser and I want to convert my input into RelaxNG XML output.
10:23:14 <camio> So, whichever lib I end up going with will probably be used by the end users.
10:23:33 <jyp> As far as I can tell, HaXml is rather of straightforward use
10:23:37 <shapr> Both HaXml and HXT have advantages.
10:24:19 <xerox_> dcoutts: help :!
10:24:24 <dcoutts> xerox_, !!!
10:24:54 <camio> I'll check out haxml then and see if it will work better. I'm hesitant to use something where the doc is an outdated thesis.
10:25:36 <xerox_> dcoutts: my code behaves strangely, do you have a second to try it out?  it's a modified Clock.hs
10:26:06 <shapr> camio: HXT has acquired more docs in the unit tests since then.
10:26:19 <dcoutts> xerox_, in a moment
10:26:26 * xerox_ uploads
10:26:27 <shapr> hej lennart_
10:27:00 <Cale> what's wrong with the Haddock?
10:27:07 <xerox_> dcoutts: http://haskell.galois.com/~paolo/Main.hs
10:27:21 <camio> shapr: Alright, I'll look into it, but that doesn't seem reall accessable.
10:28:08 <camio> Cale: If you are asking me, haddoc=reference documentation but most people find a users guide or tutorials more useful when starting.
10:29:04 <xerox_> Cale!
10:29:22 <shapr> hiya Cale 
10:30:27 <xerox_> Cale: http://img219.imageshack.us/img219/762/1902061717hourglass6fz.png  Do you know why it doesn't display just the hourglass itself, without the space around?  I tried copying the objects in a 'no border' inkscape without success, too :-\
10:30:31 <camio> Yikes, haxml doesn't have any docs either. Darn.
10:30:52 <dcoutts> camio, it does I think
10:31:11 <camio> dcoutts: I don't see it linked on the homepage.
10:31:20 <dcoutts> http://www.cs.york.ac.uk/fp/HaXml/#how
10:32:19 <camio> dcoutts: Yeah, I know ... it's really misleading. No real docs there, just papers and haddock stuff.
10:32:39 <shapr> Hm, papers are often better that standard docs in my experience.
10:33:04 <dcoutts> and the ibm dev tutorial
10:33:07 <shapr> Rather than just saying how you can accomplish tasks, they often describe why a library was designed a certain way. Knowing the spirit of a design can give a big boost in using that design.
10:33:12 <camio> dcoutts: The IBM tutorial is too specific.
10:33:13 <dcoutts> camio, you see academics don't write docs, they write papers :-)
10:33:36 <camio> shapr: Yeah, but I don't care about why they made it X way. I want to just use it as quickly as possible.
10:33:47 <camio> dcoutts: lol. Tragic flaw :)
10:34:18 <dcoutts> yeah sadly academics get funded to write papers, not docs (not even code, at least not directly)
10:34:20 <camio> dcoutts: And they write papers only because they have to.
10:34:54 <dcoutts> academics are machines for turning tea/coffee into papers
10:34:55 <shapr> I dunno, I think a lot of them really enjoy writing papers to help everybody else get a leg up.
10:35:39 <camio> shapr: Yeah, I'm just a bit disenchanted about there being no decent (IMHO) XML lib in Haskell.
10:35:53 <Beelsebob> whats wrong with HaXmL?
10:36:06 <camio> Beelsebob: Docs for one.
10:37:08 <jyp> Have you at least given a look to the papers ?
10:37:31 <shapr> camio: I've been paid to use HXT, and I've done other significantly useful stiff with HaXml, so they both seem more than decent to me.
10:37:31 <jyp> I found them a good way to understand what's going on.
10:38:00 <camio> jyp: Nope. I guess I'll give them a look although it will be painful since I'm certainly not the target audience.
10:38:36 <camio> shapr: But you probably enjoy reading academic papers when coding, etc.
10:38:43 <dcoutts> camio, you may find that understanding the design of the lib helps with using it
10:39:19 <camio> dcoutts: I agree, but that is no replacement for docs.
10:39:48 <shapr> My client wanted 40mb or so of ms.doc files converted to a custom XML flavor, so I used python scripting in openoffice to save them all as the native sxw xml flavor, and then used HXT to map the OOo xml to their custom flavor. Took me three days, and their on-site geek had given up after 1+ month of coding.
10:39:49 <wolverian> hm, no b-tree in the standard lib?
10:39:51 <jyp> camio: If you're really in a hurry, skip to section 2 of the 1st paper. It's sort of a tutorial
10:40:00 <camio> jyp: hehe, just got there :)
10:40:07 <dcoutts> shapr, sounds pretty good
10:40:32 <shapr> camio: True, I enjoy reading academic papers. Doesn't everyone? :-)
10:40:50 <shapr> Seriously though, what's the difference between a paper and docs?
10:41:06 <camio> shaper: Docs start with code. Papers start with rambling?
10:41:47 <shapr> I always understand faster once I know the 'big picture.' I think that's the idea of the rambling start.
10:42:07 <camio> jyp: It looks as though haxml doesn't handle comments so it won't work for me.
10:43:22 <shapr> It does sort of sound like you have something against research papers...
10:43:49 <camio> shapr: No, more against libraries without docs.
10:44:17 <shapr> Well, ok.
10:44:23 <xerox_> dcoutts: any ideas?
10:44:29 <camio> shapr: I love reading papers when I'm not working. But when I want to get something done.
10:44:52 <dcoutts> xerox_, I'll take a look in a sec
10:44:54 <jyp> camio: apparently not so: http://www.cs.york.ac.uk/fp/HaXml/HaXml/Text.XML.HaXml.Types.html#Misc
10:45:23 <shapr> I've had to read RFCs for some of my jobs, I don't think that's so different.
10:45:44 <shapr> It also depends on the author too, some docs are painful, and some research papers a joy.
10:45:50 <jyp> I'd love to get paid for reading papers :)
10:45:55 <shapr> me too
10:46:07 <shapr> There's just so much cool stuff out there in the world.
10:46:14 <jyp> yup
10:46:43 <shapr> On the other hand, I'd feel grumpy if I didn't get to apply the cool stuff I find in research papers.
10:46:48 <camio> jyp: Heh, the paper would lead you to believe otherwise.
10:47:53 <palomer> f (x:xs) = x+1;f (x:xs) = x || True <--I think this should be a valid function with type [a] -> a
10:47:55 <palomer> who's with me?
10:48:13 <xerox_> || True ?
10:48:21 <palomer> yeah
10:48:25 <jyp> camio: I guess the doc is outdated :)
10:48:35 <xerox_> || doesn't have type "Num a => ... -> a"
10:48:49 <xerox_> Neither (+) returns a Bool.
10:48:49 <Beelsebob> palomer: don't you mean Num a => [a|Bool] -> a|Bool?
10:48:54 <Beelsebob> sorry no
10:49:02 <palomer> I mean [a] -> a
10:49:10 <Beelsebob> Num a => [a] -> a | [Bool] -> Bool
10:49:17 <xerox_> palomer: do you want binary or?
10:49:22 <Beelsebob> palomer: but I can't pass it a string and expect it to work
10:49:27 <palomer> do you guys agree that if you pass an [alpha] that function will always return a value of alpha?
10:49:35 <Beelsebob> palomer: no
10:49:36 <xerox_> No.
10:49:38 <Beelsebob> I can't give it a string
10:49:39 <lennart_> palomer: why should it have type?  looks like a wrong function
10:49:51 <palomer> Beelsebob: sure you can, and it will return bottom
10:49:55 <Beelsebob> palomer: I think what you're trying to get at is intersection types
10:50:01 <palomer> (I'm proposing an extension of the haskell type system here)
10:50:27 <Beelsebob> palomer: but that would imply that *all* functions have type a->b, and return bottom when a type error occurs
10:50:34 <Beelsebob> sounds like dynamic typing to me
10:50:52 <palomer> Beelsebob: I don't understand your argument
10:51:12 <Beelsebob> palomer: well, if that function returns bottom when no rule works, then surely all functions do
10:51:17 <palomer> lennart_: if you pass an [a] it will return a value of a
10:51:19 <Beelsebob> thus all functions have type a -> b
10:51:33 <Beelsebob> and return bottom when a type mismatch occurs
10:51:38 <palomer> do you mean forall a b. a -> b?
10:51:43 <Beelsebob> yes
10:51:46 <camio> http://www.flightlab.com/~joe/hxml/ <- Yeah! A documented XML lib. Back to coding :)
10:52:01 <palomer> Beelsebob: well, no, my particular function is not of type [int] -> bool, for example
10:52:17 <lennart_> palomer: I don't agree.  It returns a Num or a Bool
10:52:36 <lennart_> So, a type like Beelsebob's might work
10:52:57 <Beelsebob> (Num a => [a] -> a) | ([Bool] -> Bool) ?
10:53:09 <lennart_> yeah, something like that
10:53:19 <xerox_> I do agree too.
10:53:21 <palomer> lennart_: i don't see how that contradicts my statement
10:53:33 <Beelsebob> I suspect it would make writing the type checker er... "fun"
10:53:34 <lennart_> you say it has type [a]->a
10:53:40 <palomer> yup
10:53:51 <Beelsebob> palomer: does that mean that bottom has type Char?
10:54:02 <lennart_> so I can do f['a'], but what would that give me?
10:54:27 <Beelsebob> lennart: I asked that... apparently it would give _|_ :: Char
10:54:33 <palomer> lennart_: bottom
10:54:36 <lennart_> ah, ok
10:54:51 <palomer> yes, bottom has type Char
10:54:58 <lennart_> yes, then i guess you could say it has type [a]->a
10:55:14 <lennart_> but why not say it has type a->b
10:55:26 <xerox_> ...it does mean that you get runtime problems.
10:55:26 <palomer> forall a b. a -> b?
10:55:34 <palomer> because it does not have type [int] -> bool
10:55:39 <palomer> xerox: for example?
10:55:54 <xerox_> What does 'bottom' do to program flow?  *bang*, I presume.
10:56:01 <Beelsebob> palomer: what do you do with a bottom?
10:56:02 <lennart_> palomer: why doesn't it have type [Int]->Bool?
10:56:12 <Beelsebob> the type checker can't confirm that you don't have any
10:56:16 <lennart_> you seen to return bottom when types don't match, so why not here also?
10:56:18 <palomer> lennart: because when you pass an [Int], it returns an Int
10:56:58 <lennart_> what does it return if I pass it an Int?
10:57:05 <palomer> bottom
10:57:12 <xerox_> I think he means that it's more 'f a -> a' than 'a -> b', with f :: * -> *.
10:57:20 <lennart_> so it has a type more general than [a]->a
10:57:35 <xerox_> Oh, then yes, lennart's holds.
10:57:38 <palomer> lennart: well we still want to be as strict as possible
10:57:50 <palomer> this extension would allow a little more freedom with a little less security
10:57:53 <lennart_> what do you mean by strict?
10:58:05 <dcoutts> xerox_, I've got to go out, I'll look at it later.
10:58:07 <xerox_> palomer: anyway, what do you do with a bottom?
10:58:09 <palomer> lennart: we want to avoid as many bottoms as possible
10:58:18 <xerox_> dcoutts: Okay, see you later.
10:58:20 <palomer> xerox: same as a non-exhaustive bottom
10:58:30 <palomer> > let f 0 = 4 in f 6
10:58:31 <lambdabot>  Non-exhaustive patterns in function f
10:58:35 <lennart_> palomer: if you want to avoid bottom, then I think Belseboob's type is better
10:58:40 <Beelsebob> palomer: I like bottoms!
10:58:44 <Beelsebob> especially naked bottoms!
10:59:18 <palomer> well, yes, but Beelsebob's type is harder to read and use
10:59:39 <Beelsebob> palomer: it's not harder to read - it gives *much* better documentation of what you can do
10:59:42 <lennart_> well, i find the type you give it very non-intuitive
11:00:00 <palomer> what if there are 5 alternatives?
11:00:05 <Beelsebob> and use - well, if you add oddities to the type system you can expect it to become more complex
11:00:12 <palomer> it's pattern matching on the type, really
11:00:56 <palomer> f x = case (Type t) of [Int] -> head t; [Bool] -> head t
11:01:20 <palomer> this looks like dependent types to me
11:01:48 <lennart_> palomer: not really
11:01:52 <Beelsebob> no, oposite of dependant types
11:02:04 <Beelsebob> dependant types has th type depend on the values
11:02:11 <Beelsebob> this has the values depend on the type
11:02:50 <lennart_> palomer: Haskell can already do your f function, it's just a little more verbose
11:03:07 <palomer> lennart: with GADTs, right?
11:03:16 <lennart_> no, with classes and instances
11:03:34 <palomer> how would that work?
11:04:13 <lennart_> class F a where f :: [a]->a; instance F Int where f (x:xs) = x+1; instance F Bool where f (x:xs) = x || True
11:05:01 <palomer> that is pretty verbose
11:05:07 <lennart_> that's what i said
11:05:20 <lennart_> but how often do you need functions like f?
11:06:03 <lennart_> furthermore, if you really need them that often, you could imagine introducing a shorthand for that kind of thing
11:06:14 <palomer> it makes type inference for GADTs a breeze
11:06:25 <palomer> and has other nice properties
11:06:49 <palomer> it really is a nicer system (though less safe)
11:06:53 <lennart_> looks like it has nasty properties.  runtime type errors
11:07:23 <palomer> lennart: oh, -Wall would tell you when you have a non-exhaustive pattern error
11:07:36 <palomer> you could require the user to cover all cases
11:07:48 <lennart_> but you can't for f
11:07:56 <lennart_> well, i guess you can
11:09:46 <lennart_> but if you can't statically guarantee absence of runtime type errors it's gonna be a hard seel to typish people :)
11:10:35 <palomer> oh, I don't see why you couldn't guarantee it
11:11:11 <palomer> btw, do you have any papers on pattern matching on types? (typecase x of Int -> ... , ie ad-hoc polymorphism)
11:11:12 <Beelsebob> because 46% of statistics are made up on the spot
11:14:09 <lennart_> palomer: but how would you guarantee it?  Say I have your definition of f.  How will you stop me from doing f['a'] ?
11:14:32 <palomer> lennart_: f wouldn't type
11:14:46 <lennart_> I thought you said it had type [a]->a
11:15:13 <palomer> lennart_: I said you could guarantee it, but I wouldn't want to
11:16:12 <lennart_> well, if you can't guarantee it, i don't want to use it :)
11:16:14 <palomer> you could write something like this though: f (x:xs) = x + 1 ; f (x:xs) = x || True ; f (x:xs) = x
11:16:38 <palomer> which will never give me a type error
11:17:18 <lennart_> yes, but i might not have anything sensible to write in the last branch.  i might only want it to work for Int and Bool
11:17:42 <palomer> and you want the compiler to statically check this?
11:17:50 <lennart_> yes
11:17:59 <palomer> then you probably want union types:o
11:17:59 <lennart_> why not?  Haskell does
11:18:32 <palomer> well, yes, your request doesn't fit into the goal of this extension
11:19:23 <lennart_> what i'm really trying to say is, that if you remove the basic premise of static type checking (absence of runtime type errors), then of course you can get more pwerful systems with lots of nice properties
11:19:46 <lennart_> letting everything have type forall a.a also makes many things easy
11:20:05 <palomer> but, my system can enforce the absence of runtime type errors
11:20:25 <lennart_> you have yet to show me how
11:20:42 <palomer> well, the compiler simply has to check that all types are covered
11:20:44 <Beelsebob> palomer: so what's the result of f "jam"?
11:20:57 <palomer> Beelsebob: in my latest f it would be 'j'
11:21:05 <Beelsebob> palomer: I meant in your first f
11:21:07 <lennart_> having a third branch for f is not an option, because there might not be anything sensible to write there
11:21:09 <palomer> f (x:xs) = x + 1 ; f (x:xs) = x || True ; f (x:xs) = x
11:21:19 <palomer> my first f isn't acceptable to either of you:o
11:21:21 <Beelsebob> palomer: and you wouldn't call that just type checking?
11:21:42 <palomer> lennart_: then you'd use type classes
11:21:51 <Beelsebob> palomer: so you disalow the useful function you wanted in favour of something that *may* be meaningless?
11:21:58 <lennart_> No, your new f isn't at all the same as the old.  you've made it total by giving some arbitrary behavior for the other types
11:22:15 <Beelsebob> I may end up having to define my last case as f _ = error "A runtime type error occurred"
11:22:27 <lennart_> exactly
11:22:48 <palomer> well, yes, this feature isn't appropriate in all cases
11:23:10 <lennart_> that we agree on
11:23:26 <lennart_> i'm yet to be convinced it's appropriate in any case :)
11:24:08 <palomer> well, first we have to agree that it can be made safe
11:24:24 <Beelsebob> I think it can - if you use my proposed typing
11:24:34 <palomer> with my proposed typing
11:24:34 <Beelsebob> but you'll get a lot of fun with the checker
11:24:45 <Beelsebob> palomer: I don't think it can me
11:24:47 <Beelsebob> be*
11:24:54 <palomer> why not?
11:25:12 <Beelsebob> because I've seen no evidence that it's possible to make it safe
11:25:21 <Beelsebob> and a reasonable number of problems with it
11:25:35 <palomer> Beelsebob: force the union of all case statements to cover all the types
11:26:00 <Beelsebob> palomer: so what do you do when you don't want a function to cover all types?
11:26:00 <palomer> this seems to be easily decidable, since types are defined inductively
11:26:16 <palomer> Beelsebob: you can't
11:26:22 <Beelsebob> what do you do when you *want* a type error when you pass "jam" to +
11:26:22 <palomer> (if you want safety)
11:26:35 <palomer> oh, then f _ = error "bad" is fine
11:26:37 <palomer> and still safe
11:26:50 <Beelsebob> that's not safe though
11:26:55 <palomer> how so?
11:26:58 <Beelsebob> that's just renaming a runtime type error to "bad"
11:27:00 <palomer> you don't get a type error
11:27:09 <palomer> you get runtime errors anyways
11:27:09 <Beelsebob> you do... it's just called "Bad"
11:27:16 <Beelsebob> yes... but not type errors
11:27:26 <palomer> this isn't a type error!
11:27:37 <palomer> you may think of it as a type error, but it's not
11:27:46 <Beelsebob> yes it is! It's explicitly, "you passed the wrong type to this function, and now there's an error"
11:27:52 <Beelsebob> sounds very much like a type error
11:27:56 <lennart_> i agree
11:28:14 <palomer> f (x:xs) = 4 ; f _ = 8 has type a -> int
11:28:33 <palomer> does that second alternative seem like a type error to you?
11:28:49 <Beelsebob> palomer: no, I didn't say it was *always* a type error, I said it could be
11:28:52 <Beelsebob> that's not sound
11:29:10 <palomer> error "bad" is a value, I don't see how values are type errors
11:29:28 <Beelsebob> because it's explicitly an error caused by passing the wrong type to the function
11:29:46 <Beelsebob> the point is that I can't catch the error "you passed "jam" to +" at compile time
11:29:53 <lennart_> just because you force me to generate the type error message doesn't make it less of a type error
11:30:19 <ihope> @pl \a -> a a a
11:30:20 <lambdabot> join (join id)
11:30:31 <palomer> Beelsebob: if you wanted to make sure that only certain types are passed to a function, you wouldn't use this
11:30:45 <Beelsebob> palomer: but isn't that the point of the type system?
11:30:56 <palomer> lennart_: I can do the same thing as I'm doing now with GADTs
11:31:18 <palomer> Beelsebob: to stop us from calling error?
11:33:13 <Beelsebob> palomer: no, to catch it at compile time
11:33:19 <Beelsebob> to stop error needing to be called
11:33:38 * Beelsebob goes
11:45:25 <wolverian> haskell++ # I'm having fun again, challenging myself to learn the language 
11:47:14 <Lemmih> Yay.
11:47:23 <Lemmih> @karma+ haskell
11:47:23 <lambdabot> haskell's karma raised to 1.
11:52:59 <ihope> @karma haskell
11:53:00 <lambdabot> haskell has a karma of 1
11:53:03 <ihope> Hmm.
11:56:47 <ValarQ> :/
11:57:52 <wolverian> oh, wow, my definition of a B+-Tree is very very inadequate 
12:00:32 <wolverian> fixe
12:00:33 <wolverian> d
12:16:27 <jyp> @quote
12:16:27 <lambdabot> dons says: And you wonder why the monad transformers are hurting? You're
12:16:27 <lambdabot> not supposed to use them after midnight, or you turn into a type-level
12:16:27 <lambdabot> pumpkin..
12:17:35 <lispy> heh
12:17:45 <lispy> i always wanted to be a type-level pumpkin
12:18:21 <shapr> @karma+ haskell
12:18:22 <lambdabot> haskell's karma raised to 2.
12:28:39 <palomer> that was actually directed to me
12:44:16 <ihope> @quote
12:44:17 <lambdabot> dons says: And you wonder why the monad transformers are hurting? You're
12:44:17 <lambdabot> not supposed to use them after midnight, or you turn into a type-level
12:44:17 <lambdabot> pumpkin..
12:44:21 <ihope> Um...
12:44:22 <ihope> @quote
12:44:23 <lambdabot> dons says: And you wonder why the monad transformers are hurting? You're
12:44:23 <lambdabot> not supposed to use them after midnight, or you turn into a type-level
12:44:23 <lambdabot> pumpkin..
12:44:29 <jyp> @yow
12:44:30 <lambdabot> I KAISER ROLL?!  What good is a Kaiser Roll without a little COLE
12:44:30 <lambdabot> SLAW
12:44:30 <lambdabot> on the SIDE?
12:44:36 <ihope> @quote ihope
12:44:37 <lambdabot> ihope hasn't said anything memorable
12:45:27 <ihope> Tee hee.
12:45:30 <ihope> @qout
12:45:30 <lambdabot> Not enough privileges
12:46:37 <jyp> @arr
12:46:37 <lambdabot> Yeh scurvy dog...
12:47:11 <ihope> @. pl arr
12:47:12 <lambdabot> (line 2, column 1):
12:47:12 <lambdabot> unexpected end of input
12:47:12 <lambdabot> expecting space or simple term
12:48:06 <ihope> Aha! One of them parsed!
12:48:12 <ihope> It was "Smartly me lass"
12:48:34 <xerox_> @state Smartly me lass
12:48:38 <xerox_> @. pl state
12:48:39 <lambdabot> Smartly me lass
12:48:49 <ihope> @help state
12:48:49 <xerox_> @. pl yow
12:48:49 <lambdabot>  @state - we all know it's evil
12:48:50 <lambdabot> (line 3, column 1):
12:48:50 <lambdabot> unexpected end of input
12:48:50 <lambdabot> expecting space or simple term
12:49:02 <ihope> @state
12:49:09 <xerox_> It's a flip-flop.
12:49:17 <ihope> @state State state state
12:49:24 <ihope> @state Stately states.
12:49:24 <lambdabot> State state state
12:49:27 <ihope> @state
12:49:28 <lambdabot> Stately states.
12:49:32 <ihope> Yay!
12:49:38 <xerox_> :-)
12:49:51 <xerox_> @. pl code
12:49:51 <lambdabot> compose module failed: getRandItem: empty list
12:50:08 <ihope> @. elite code
12:50:09 <lambdabot> compose module failed: getRandItem: empty list
12:50:11 <ihope> @code
12:50:12 <lambdabot> code module failed: getRandItem: empty list
12:50:15 <ihope> @help code
12:50:16 <lambdabot>  @code, print random line of code from $fptools
12:50:31 <ihope> @pretty darn good
12:50:32 <lambdabot> "Parse error" at column 10
12:51:33 <xerox_> Got some time free this night, eh?  :-)
12:52:09 <ihope> Hmm.
12:52:11 <ihope> state module failed: getRandItem: empty list
12:52:14 <ihope> @state
12:52:15 <lambdabot> Got some time free this night, eh? :-)
12:52:18 <ihope> Oh.
12:56:58 <ihope> Hmm...
12:57:03 <ihope> @arr Hello, world!
12:57:03 <lambdabot> quote module failed: getRandItem: empty list
12:57:07 <ihope> @arr
12:57:08 <lambdabot> quote module failed: getRandItem: empty list
12:57:12 <ihope> Mmh.
12:57:19 <benc__> any people here work on interfacing git stuff into haskell? (I'm thinking mostly of the darcs stuff, potentially, I suppose)
12:57:40 <benc__> I'm trying to write some custom merge code in haskell for dealing with maildir merging inside git
13:13:36 * palomer considers implementing patterns into his language
13:15:19 <jyp> @code
13:15:19 <lambdabot> code module failed: getRandItem: empty list
13:15:38 <jyp> @reboot
13:15:39 <lambdabot> Unknown command, try @listcommands.
13:15:44 <jyp> darn :)
13:15:47 <ihope> @bot
13:15:48 <lambdabot> :)
13:15:50 <ihope> @bo
13:15:50 <lambdabot> :)
13:15:52 <ihope> @b
13:15:53 <lambdabot> Maybe you meant: babel botsnack .
13:15:55 <ihope> Aww.
13:16:08 <jyp> @snack
13:16:08 <lambdabot> Unknown command, try @listcommands.
13:17:27 <palomer> how would you guys parse types with parsec?
13:20:23 <ihope> I'd use parsec to do it.
13:21:47 <benc__> parse what types?
13:22:51 <palomer> types = int | bool | constructor [types]
13:24:49 <palomer> or patterns for that matter
13:25:12 <palomer> it seems that parsing types and parsing patterns is exactly the same thing
13:31:23 <ulfdoz> wat macht das?
13:31:27 <ulfdoz> 7echan
13:31:33 <palomer> what are upper case identifiers and lower case identifiers reffered as?
13:31:36 <shapr> das macht spaß!
13:31:40 <ulfdoz> Damn, you know, what I mean.
13:32:02 <benc__> constructors?
13:32:11 <benc__> for upper?
13:35:29 <benc__> report 3.2 section seems to call them Literals and Constructors, I think
13:35:43 <benc__> or constructors and variables
13:35:54 <benc__> anyway the choice is constructors and {variables, literals} there...
13:38:31 <imix> I want to read some (binary)data from a handle which has a certain type. I have many types of the form Foo X Y... , where X and Y are simple types (like Int). Is there an easy way to do this (instead of writing a simple reader and writer functions vor every type)? e.g. can I make something like Foo X Y deriving (MyDataReader)
13:39:45 <ihope> If it's simple enough to derive, I think you can make functions to do it.
13:40:14 <ihope> instance Monad Foo where (>>=) = derive blah blah...
13:41:42 <imix> so far i was not successful finding out how to make a class 'deriving'-able. Where can I find some examples/documentation? (your line already helps alot :)
13:42:16 <benc__> you can make derivables?
13:43:01 <imix> I don't know, just thought it would be a solution to my problem if one could
13:45:12 <benc__> shouldn't be too hard to just write the code by hand...
13:45:21 <benc__> boring though ;-)
13:45:48 <astrolabe> @where yaht
13:45:48 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
13:46:04 <astrolabe> imix   ^^^^^^^^^^^^^ page 89
13:46:35 <imix> oh, writing it by hand is trivial, I just thought ther could be a more elegant solution
13:47:53 <imix> astrolabe: thanks, i have a look at it
14:03:13 <xerox_> dcoutts: nevermind about the code.
14:11:52 <xerox_> Cale: ping
14:27:10 <integral> @index peekCString
14:27:10 <lambdabot> Foreign.C.String, Foreign.C
14:27:15 <integral> @Type Foreign.C.peekCString
14:27:16 <lambdabot> Foreign.C.String.CString -> IO String
14:30:57 <Cale> hello
14:31:07 <Cale> what's up xerox?
14:34:52 <xerox_> Oi Cale, do you have some time to try to write the Hourglass animation with me?
14:35:20 <Cale> oh, you're animating an hourglass? :)
14:35:29 <xerox_> I'm trying :-)
14:35:41 <xerox_> I've a _*VERY*_ rough shape.
14:36:27 <xerox_> http://haskell.galois.com/~paolo/Main.hs
14:36:46 <xerox_> I think that if you can peel off some part of Hourglass.svg I could use it as background.
14:37:14 <xerox_> Then invent something for the sand, and draw onto the remaning parts, like the glass, the sticks, and the top.
14:37:21 <Cale> hmm, it appears to need newer libraries
14:37:30 <xerox_> Mumble.
14:37:58 <xerox_> In fact I recompiled Gtk2Hs today, I also made libsvg and libsvg-cairo deb packages.
14:38:16 <xerox_> But it sould compile anyway, it's based on demo/cairo/Clock.hs.
14:38:29 <Cale> let me pull new patches for gtk2hs
14:38:35 <xerox_> Okay.
14:38:45 <integral> @type Foreign.C.withCString
14:38:46 <lambdabot> forall a.
14:38:46 <lambdabot>          String -> (Foreign.C.String.CString -> IO a) -> IO a
14:39:03 <xerox_> If you do not have libsvg and libsvg-cairo I can upload the debs.
14:52:09 <Cale> xerox_: actually, yeah, that would be good
14:52:56 <xerox_> What exactly? :-)
14:54:45 <palomer> what do people call "uppercase identifiers" and "lowercase identifiers" ?
14:55:04 <xerox_> Foo vs. foo, I think it refers to the first letter.
14:55:15 <xerox_> Or even all of them, FOO vs. foo.  Whatever.
14:55:18 <palomer> no, I mean "what are their lexical names"
14:55:23 <xerox_> Cale: ok, uploading.
14:55:32 <palomer> upperIdentifiers and lowerIdentifiers?
14:57:18 <astrolabe> varid and conid in haskell
14:58:14 <palomer> thx
14:58:35 <xerox_> Cale: http://haskell.galois.com/~paolo/debs/
15:01:02 <Cale> hmm, I installed them, but it still doesn't want to build the svgcairo package
15:02:08 <xerox_> Hmm.  Gtk2Hs' configure found it automatically.
15:02:54 <Cale> checking for SVGCAIRO... checking whether to build svgcairo package... no
15:03:32 <palomer> how does one usually parse types? ie type = int | bool | constructor string [type]
15:03:37 <palomer> (in parsec)
15:04:46 <xerox_> Cale: --enable-svg-cairo ?
15:05:13 <Cale> checking for SVGCAIRO... configure: error: libsvg-cairo requirement not met. Perhaps you need to install libsvg-cairo or libsvg-cairo-devel
15:05:29 <Cale> I don't have the development files for libsvg-cairo probably
15:05:40 <xerox_> Did you install the -devs too?
15:05:56 <Cale> you didn't upload them :)
15:06:03 <xerox_> Oh, sorry!!
15:06:09 <Cale> oh, there they are
15:06:34 <xerox_> Hmm, yes.  They are there.
15:06:40 <Cale> I suppose you just hadn't when you'd first given me the url
15:07:02 <xerox_> It is possible, it was still uploading
15:13:02 <palomer> what do you call the number of toplevel arrows in a type?
15:13:17 <palomer> like (a -> b -> c) has 2 toplevel arrows
15:13:26 <Cale> well, really it has one :)
15:13:26 <palomer> while ((a->b) -> c) only has 1
15:13:33 <palomer> I"m defining it!
15:13:40 <Cale> a -> b -> c = a -> (b -> c)
15:13:42 <palomer> yeah
15:13:46 <Cale> but okay :)
15:13:54 <palomer> but I'm trying to figure out the arity of my constructors based on their types
15:13:55 <Cale> I'd probably call that the arity
15:14:00 <palomer> gotcha
15:14:00 <Cale> of the function
15:25:48 <astrolabe> Are there  fromLeft and fromRight functions defined anywhere?
15:25:59 <astrolabe> @hoogle fromLeft
15:25:59 <lambdabot> No matches found
15:26:23 <xerox_> Cale: any luck?
15:26:34 <Cale> hmm
15:26:35 <Cale> oh
15:26:38 <astrolabe> @hoogle Either a b -> a
15:26:39 <Cale> it's failed :/
15:26:39 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
15:26:39 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:26:39 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
15:26:47 <xerox_> Ouch, what exactly?
15:26:56 <Cale> gtk/Graphics/UI/Gtk/TreeList/TreeView.chs:339:24:
15:26:56 <Cale>     Not in scope: type constructor or class `StoreClass'
15:27:02 <Cale> gtk/Graphics/UI/Gtk/TreeList/TreeView.chs:344:5: Not in scope: `storeGetModel'
15:27:07 <ihope> > not
15:27:07 <lambdabot>  add an instance declaration for (Show (Bool -> Bool))
15:27:10 <ihope> > xor
15:27:10 <xerox_> Maybe you need to start with a fresh repo? :-|
15:27:11 <lambdabot>  add an instance declaration for (Show (a -> a -> a))
15:27:22 <ihope> @type xor
15:27:23 <lambdabot> Not in scope: `xor'
15:27:28 <astrolabe> ihope: use ==
15:27:29 <ihope> @index xor
15:27:30 <lambdabot> Data.Bits, Foreign
15:27:34 <xerox_> ihope: xor = (/=)
15:28:33 <ihope> ((.) . (.) not xor
15:28:38 <ihope> Erm.
15:28:41 <ihope> ((.) . (.)) not xor
15:28:56 <ihope> (.) (not .) xor
15:28:59 <Cale> @where gtk2hs
15:29:00 <lambdabot> http://haskell.org/gtk2hs/
15:29:11 <ihope> ((not .) . (/=))
15:29:14 <ihope> There we go.
15:29:29 <xerox_> Cale: darcs get --partial http://darcs.haskell.org/gtk2hs/ IIRC.
15:29:35 <Cale> yeah, got it
15:29:44 <dcoutts> xerox_, so did you figure out the problem?
15:29:46 <xerox_> @pl \x y -> not (x /= y)
15:29:47 <lambdabot> (==)
15:29:50 <xerox_> dcoutts: yea!
15:30:00 <dcoutts> xerox_, what was it?
15:30:07 <xerox_> dcoutts, I was using the wrong aspect ratio.
15:30:22 <xerox_> I thougth '1' meant 'keep it as it is'
15:30:29 <ihope> @pl ((not .) . (/=))
15:30:29 <lambdabot> (==)
15:30:36 <xerox_> ihope: I told you.
15:30:40 <ihope> :-)
15:30:44 <dcoutts> xerox_, oh ok
15:30:47 <xerox_> dcoutts: http://haskell.galois.com/~paolo/Main.hs
15:31:13 <xerox_> dcoutts: it seems that the SetGeometryHints' documentation doesn't show up anywhere in the Haddock docs :-(
15:31:22 <dcoutts> xerox_, it's new
15:31:33 <dcoutts> xerox_, I added it specially for the clock demo :-)
15:31:36 <xerox_> Heh!
15:31:42 <xerox_> It does its job.
15:34:09 <ihope> @type ((not .) . (/=))
15:34:11 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:34:19 <xerox_> ihope: why do not use (==) ?
15:35:00 <ihope> Just thinking of alternate definitions.
15:35:18 <ihope> You know, constructs like ((.) . (.) . (.)) are sorta weird...
15:35:27 <xerox_> They're ok :-)
15:35:45 <astrolabe> They're weird!
15:35:51 * xerox_ giggles
15:36:16 <ihope> @type ((.) . (.) . (.))
15:36:17 <lambdabot> forall a a1 b c a2.
15:36:17 <lambdabot>        (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
15:36:50 <xerox_> Yup, it composes a function with a tree-argument function.
15:36:59 <ihope> What would that be--ReaderT (ReaderT Reader)?
15:37:05 <xerox_> Like ((.) . (.)) does with a two-argument.
15:37:13 <astrolabe> @djin (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
15:37:14 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-
15:37:14 <lambdabot> ver
15:37:25 <astrolabe> @djinn (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
15:37:25 <lambdabot> f a b c d e = a (b c d e)
15:37:28 <ihope> @. pl djinn (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
15:37:28 <lambdabot> f = (.) . (.) . (.)
15:37:44 <xerox_> :-)
15:41:42 <palomer> people usually consider Int as a type constructor, right?
15:41:51 <palomer> of kind *
15:41:55 <palomer> @kind Int
15:41:55 <lambdabot> *
15:46:15 <ihope> Control.Monad.Cont.Cont Control.Monad.Fix.fix
15:46:22 <ihope> It's a long name for a simple value.
15:46:33 <ihope> @type Control.Monad.Cont.Cont Control.Monad.Fix.fix
15:46:33 <lambdabot> forall r.
15:46:33 <lambdabot>                  Control.Monad.Cont.Cont r r
15:46:51 <ihope> It is anything! Muahaha...
15:48:00 <palomer> someone remind me why runState needs an initial state
15:48:46 <ihope> @index runState
15:48:47 <lambdabot> Control.Monad.State, Control.Monad.RWS
15:48:58 <ihope> @type Control.Monad.State.runState
15:48:58 <lambdabot> forall s a.
15:48:58 <lambdabot>            Control.Monad.State.State s a -> s -> (a, s)
15:49:39 <palomer> oh, I'm an idiot
15:49:47 <palomer> I was using readerstateT over ST
15:49:51 <palomer> all I needed was ST
15:54:12 <ihope> > SPAM == spam
15:54:12 <lambdabot>  Not in scope: `spam'
15:54:16 <ihope> Bleh.
16:04:23 * palomer doesn't like the word constructor
16:05:39 <palomer> it's too vague
16:06:33 <Cale> well, when it's not obvious which is meant, you can say 'data constructor' or 'type constructor'
16:10:42 <xerox_> Cale: any luck... again?
16:11:04 <Cale> just installed, let me try it
16:11:05 * beelsebob_ wonders what cale would have luck with
16:11:16 <xerox_> Great.
16:11:19 <Cale> okay, neat
16:11:36 <xerox_> beelsebob_: Gtk2Hs + libsvg-cairo (that I just packaged)
16:11:43 <beelsebob_> ah, fun
16:11:51 <xerox_> Well, my drawing is just a very, very, very rough sketch.
16:11:56 <dcoutts> xerox_, you're makeing .debs for Gtk2Hs ?
16:12:15 <xerox_> dcoutts, no!  Just libsvg and libsvg-cairo (and the -dev versions)
16:12:20 <dcoutts> ah ok
16:12:21 <Cale> I get a white window with some arcs and a line on it :)
16:12:31 <xerox_> dcoutts: do you think we should get one?
16:12:50 <xerox_> Cale: in fact they aren't arcs, but splines... I agree it doesn't look very good :-)
16:12:57 <xerox_> The line represent the sand <grin>
16:13:01 <Cale> :)
16:13:08 <dcoutts> xerox_, there's a couple people who were thinkign about it, if you know much about debs I'm sure they'd apreciate your help
16:13:38 <xerox_> dcoutts: I've started understanding the .debs machinery more lately.
16:14:19 <xerox_> Anyway, care to split up the svg, Cale?  I also got into troubles with your Hourglass.svg because it had un-removable borders or something.
16:14:36 <Cale> un-removable borders?
16:14:46 <Cale> what are you using to edit it?
16:15:03 <Cale> I made it with inkscape
16:15:22 <xerox_> Yeah.  If you run it in the demo/svg/svgviewer you get big-sized image which doesn't shrink to the actual drawing's dimension.
16:15:58 <xerox_> I tried opening it in inkscape, select *all* and copy it, paste to a no-border newly created image, and save it.  But I had no luck, it always missed some part...
16:15:58 <Cale> oh, hmm
16:21:28 <Cale> odd
16:21:48 <xerox_> !
16:24:43 <Cale> could it be svg rendering bugs in libsvg?
16:24:51 <dons_> @quit rand list bug. too lazy to hunt it down.
16:24:52 <lambdabot> Not enough privileges
16:24:57 <dons_> really?/
16:25:02 <Cale> you're dons_
16:25:30 <xerox_> Cale: mumble.  Let me investigate it again.
16:25:32 <dons> @quit rand list bug. too lazy to hunt it down.
16:25:58 <Cale> xerox: I get the same problem. A bunch of the stuff is missing.
16:26:04 <dons> @quote
16:26:04 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
16:26:12 <ihope> Um.
16:26:21 <dons> that random list thing is weird. 
16:26:26 <beelsebob_> @quote dons
16:26:26 <lambdabot>  And you wonder why the monad transformers are hurting? You're not
16:26:26 <lambdabot> supposed to use them after midnight, or you turn into a type-level
16:26:26 <lambdabot> pumpkin..
16:26:26 <Cale> @quote
16:26:27 <lambdabot> dons says: And you wonder why the monad transformers are hurting? You're
16:26:27 <lambdabot> not supposed to use them after midnight, or you turn into a type-level
16:26:28 <lambdabot> pumpkin..
16:26:33 <ihope> Not many quotes
16:26:40 <ihope> @state Statement!
16:26:41 <beelsebob_> @quote
16:26:41 <lambdabot> dons says: And you wonder why the monad transformers are hurting? You're
16:26:41 <lambdabot> not supposed to use them after midnight, or you turn into a type-level
16:26:41 <lambdabot> pumpkin..
16:26:44 <Cale> @yowza
16:26:45 <lambdabot> There's enough money here to buy 5000 cans of Noodle-Roni!
16:26:46 <dons> hmm.
16:27:11 <dons> maybe I didn't copy the quotes across when I moved lambdabot's box.
16:27:15 <ncalexan> @keal
16:27:15 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
16:27:21 <ncalexan> @keal
16:27:22 <lambdabot> T could perform expressions 600mb and bigger
16:27:29 <ihope> @. state . elite state
16:27:51 <xerox_> @help keal
16:27:52 <lambdabot> Talk like Keal
16:27:55 <Cale> @keal
16:27:55 <lambdabot> #haskell needs to take its meds
16:27:58 <xerox_> Hah, and who is Keal.
16:28:01 <Cale> @. elite keal
16:28:02 <lambdabot> gh( n3eD TO H4v3 p1U9in THA7 aLLo\/\/ CopY PaztE In xp
16:28:31 <Cale> @keal
16:28:32 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing
16:28:32 <lambdabot> blew up
16:28:43 <xerox_> @keal
16:28:43 <lambdabot> haskell always said undefined
16:28:57 <ihope> @keal
16:28:58 <lambdabot> 99% of my book has been erased by faulty hdd's
16:29:08 <jethr0_> haha
16:29:11 <ihope> @keal Let's kealhaul him!
16:29:12 <lambdabot> i lack in verbal and social expression
16:29:29 <ihope> @vixen Does this do what I think it does?
16:29:30 <lambdabot> first you tell me.
16:29:36 <Cale> @. vixen keal
16:29:37 <lambdabot> i'm not sure what i mean
16:29:44 <ihope> @. vixen vixen
16:29:45 <lambdabot> nevermind about that
16:29:48 * xerox_ laughs
16:29:58 <xerox_> @keal
16:29:58 <lambdabot> haskell always said undefined
16:30:04 <xerox_> Who is Keal!
16:30:06 <jethr0_> @. elite vixen
16:30:06 <lambdabot> I'm 4 hUge B4$3B4Ll F4n
16:30:07 <beelsebob_> @. vixen djinn a -> b
16:30:07 <lambdabot> tell me a joke.. I like men that makes me laugh
16:30:48 <jethr0_> @. elite (vixen asl?)
16:30:48 <lambdabot> compose module failed: Parse error: "(vixen"
16:33:32 <sethk> hey, all, I have a bit of a problem.  I want my main thread to block indefinitely while my other threads do various things.  When I do this I get a "thread blocked indefinitely" exception
16:33:47 <xerox_> Cale: seems so... wah :|
16:33:50 <sethk> I got around it by doing a blocking read on stdin, but that's obviously a bad thing
16:34:52 <jethr0_> sethk: don't you rather want to block until the children have accomplished sth? is this for a daemon?
16:35:15 <sethk> jethr0_, I could do that, yes.  In fact, earlier in the program I block on a list of child threads
16:35:29 <sethk> jethr0_, just seems artificial, since they aren't going to die, at least not voluntarily
16:35:52 <sethk> jethr0_, I have a thread running that will kill the program after a certain amount of elapsed time
16:36:05 <sethk> I could make the main thread the killing thread, I guess
16:36:28 <jethr0_> hmm, i think waiting on the children even if they won't die is an OK solution...
16:36:33 <sethk> but it's cleaner the way I have it, because the requirement is that the elapsed time is from program start, not after everything is set up and running
16:36:53 <sethk> jethr0_, yes, I guess.  But when I go back to read it six months from now, I'll wonder what the hell I was thinking  :)
16:36:57 <jethr0_> alternatively you could block on a signal and send that, instead of killing
16:37:02 <sethk> jethr0_, I guess I'll put in a comment
16:37:46 <sethk> jethr0_, I could have the main thread wait on the timer thread
16:38:00 <sethk> jethr0_, that's better.  just let the timer thread end, instead of killing the program.
16:38:26 <xerox_> Doesn't STM get around this kind of problems?
16:38:43 <sethk> xerox, Not sure.
16:39:35 <sethk> xerox, I'll have to look at it.  It wasn't at all clear to me from the haddock doc what the intention is there.
16:39:51 <xerox_> sethk: the paper is pretty good.  If only I could remember the details...
16:39:53 <xerox_> @where stm
16:40:34 <jethr0_> xerox_: could you point me to the stm paper, again, please
16:40:38 <dons> just fixing lambdabot. back soon...
16:40:53 <xerox_> Sure.
16:40:55 <sethk> xerox, actually, though, the thing is working very well.  It's a substantial amount of work, and it took me about a day.  Would have taken at least a week in C.
16:40:57 <xerox_> <http://research.microsoft.com/~simonpj/papers/stm/>
16:41:01 <jethr0_> thx
16:44:53 <sethk> xerox, thanks also  :)
17:19:14 <mq_mattr> quite today
17:19:21 <mq_mattr> quite = quiet
17:21:12 * wli wishes there were an eigensolver that didn't explode quite so trivially.
17:21:40 <ihope> class Foo f where toFoo :: (Foo a) => f -> a
17:22:00 <ihope> A class such that every member can be converted into any other member.
17:22:35 <ihope> So you have things like toFoo (Just a) = toFoo a; toFoo Nothing = toFoo ()...
17:23:01 <xerox_> class Coercible a b | a -> b where coerce :: a -> b
17:23:14 <xerox_> Well, without the fundep, in fact.
17:23:55 <ihope> Hmm...
17:24:08 <xerox_> class Coercible a b where coerce :: a -> b -- ?
17:24:27 <ihope> Well, no. Foo only operates on one type.
17:25:09 <ihope> So Foo f implies Foo g => Coercible f g... or something.
17:25:15 <xerox_> Okay.
17:25:40 <xerox_> Hmm.
17:25:46 <ihope> There exists a (Foo f, Foo g) => f -> g
17:26:03 <ihope> toFoo, I guess.
17:26:30 <ihope> It can only be defined in terms of itself or other things which can only be defined in terms of themselves.
17:27:06 <ihope> It's like a letter addressed to "anybody, but you can't open it".
17:27:15 <xerox_> swap :: (IC a, IC b) => a -> b -- where 'IC' stands for InterChangable or something :-)
17:27:47 <ihope> Aha. Delivery instructions: have someone follow these instructions.
17:28:07 <ihope> It will, of course, never get delivered.
17:28:21 <ihope> Therefore toFoo can never actually yield a useful result.
17:28:43 <xerox_> I don't think so, hmm...
17:29:15 <ihope> You'd have to add something to it:
17:29:41 <ihope> class Foo f where {toFoo :: Foo a => f -> a; foo :: f}
17:29:55 <ihope> ...Does that work?
17:30:22 <ihope> Yeah, it does. toFoo _ = foo
17:30:41 <xerox_> o_0
17:31:24 <ihope> It's simple enough, I'm sure...
17:32:56 <xerox_> I don't get the point.
17:33:06 <ihope> Who says there's a point?
17:33:43 <xerox_> It's 02:33 am, don't shake me too hard please.  :(
17:34:58 <ihope> You know, I guess any toFoo would eventually return foo, thus rendering the whole thing useless.
17:35:36 <ihope> Here we go.
17:35:47 <ihope> class Foo f where cross :: Foo g => (f -> g) -> g
17:36:20 <ihope> Oops.
17:36:26 <ihope> Foo g => (g -> f) -> f
17:36:38 <xerox_> Isn't that the same?
17:36:59 <ihope> No.
17:37:21 <ihope> Well, I don't think so.
17:37:59 <xerox_> What's the difference?
17:38:18 <ihope> Well, an instance declaration would have to account for any g.
17:38:29 <ihope> Or, rather, every g.
17:38:40 <ihope> You know what f is ahead of time.
17:40:28 <xerox_> Goodnight.
17:40:41 <ihope> Good night.
17:46:57 <sethk> ok, I'm about to deploy a commercial application written in haskell at a site four thousand miles from here.
17:47:13 <sethk> with users who don't speak english 
17:47:16 <sethk> :)
17:48:20 <jethr0_> go for it
17:48:37 <sethk> hey, has anyone seen this on Ubuntu?  I get, when I try to install pretty much anything, "libghc6-hunit-dev:  subprocess post-installation script returned error exit status 1"
17:49:05 <sethk> that seems quite odd because I installed haskell from the tarball, not a package
17:49:29 <jethr0_> i get these kinds of errors in debian from time to time. can be quite annoying
17:49:38 <dons> @karma+ sethk
17:49:39 <lambdabot> sethk's karma raised to 2.
17:50:50 <dons> sethk, how large is this app? big? is this the hardware moitor thingey you were looking at a few months back?
17:51:01 <sethk> dons, yes, it's part of that suite
17:51:11 <sethk> dons, I'm installing it onto the production line in Taiwan
17:51:11 * dons gets excited at the phrase "a commercial application written in haskell"
17:51:24 <dons> wow. that is really excellent.
17:51:39 <sethk> the learning curve with haskell, at least for me, was huge, but it is really paying off for me lately.
17:52:08 <dons> you could writee a paper about it and submit it to the "Commerical Users of Haskell" conference.
17:52:40 <sjanssen> sethk: does your company have a web site describing what this application does?
17:53:02 <sethk> sjanssen, no, it wasn't even stable until last week.  :)
17:53:14 <dons> or at least jot down some notes at some point on your experience.. maybe just on the wiki?
17:53:18 <sethk> sjanssen, and I have to deploy it in Seattle this week, and a second phase also.
17:53:30 <sethk> dons, I'd love to, but it will be a few weeks yet before I have the time.
17:53:36 <gzl> what does it do?
17:54:07 <dons> (it would be refreshing to have a success story, after joelk's problems).
17:54:13 <sethk> gzl, the main idea is to erecise the system under load, heat it up, and just generally abuse it and see if we cna break it.  :)
17:54:21 <sethk> dons, I don't know about joelk's problem, tell me.
17:55:34 <gzl> what kind of system is it?
17:55:36 <dons> he was writing a poker server (i.e. card games) using 1000s of threads, stm, lots of other hard stuff, and learning haskell at the same time. he ended up switching to erlang, which was a bit disappointing. but he did jump in at the deep end.
17:56:31 <sethk> dons, seems to me that you don't switch until you've gotten things working.  Otherwise, how can you judge?  Unless he just decided he would never learn it.
17:57:37 <gzl> what about Haskell paid off in the project?
17:58:28 <sethk> gzl, well, a few days ago they asked me to produce a program to max out the network load.  I was able to refactor the other program into doing that in one day.
17:58:57 <sethk> gzl, I'm a very strong believer in readable well structured code.
17:59:19 <sethk> gzl, plus, once the compiler finally does what I think I'm telling it, the programs almost always work the first time, which is really amazing.
17:59:39 <gzl> yeah, that is neat. I guess what I was asking more was what features of Haskell facilitated that.
17:59:48 <lispy> sethk: iirc, he did have a "working" version before switching to erlang.  But the haskell version aparently had some unresolved performance issues
17:59:55 <gzl> I mean, if you obey good programming practices, that goes a long way regardless of the language.
18:00:31 <Rawr321> Will someone help me with using GHC?
18:00:32 <sethk> gzl, true, but with any substantial effort in C or C++, you are going to have hidden problems tracable to type errors.
18:01:02 <lispy> sethk: yes, those are type unsafe languages :)
18:01:03 <sjanssen> Rawr321: what is your problem?
18:01:10 <gzl> oh, definitely. I was just curious which features in particular you found especially helpful.
18:01:23 <Rawr321> My problem is I dont know how to use ghc
18:01:46 <sethk> gzl, I'm not sure I can point to any one thing.  It just seems to me that once I understood the language, I'm able to crank out working programs much more quickly than I can with other languages.
18:01:54 <gzl> ok, that's fair.
18:01:55 <Rawr321> like how do I make a function?  Its not the same as the tutorials say
18:01:57 <sethk> gzl, and the reason is because I'm not spending time debugging.
18:02:06 <gzl> god, debugging is a pain.
18:02:07 <dons> sethk, I wonder if your work is worth a small mention in this weeks Haskell Weekly News? Just a sentence or two to make us feel happy :)
18:02:12 <sethk> Rawr321, be more specific
18:02:14 <sjanssen> Rawr321: I've got a guess: you're using ghci right now?
18:02:20 <Rawr321> yes
18:02:21 <sethk> dons, sure, why not?
18:02:30 <dons> I could come up with 3 sentences based on what you've said here.
18:02:39 <dons> let me see..
18:02:53 <sethk> dons, fine.  if you like, email them to me and I'll comment.  or just put them here if you want to do it right now.
18:02:54 <gzl> sethk: dunno if you can answer this or not, but what kind of system were you load testing?
18:03:03 <sjanssen> Rawr321: put the stuff that the tutorials show you in a text file (say foo.hs), then run "ghci foo.hs"
18:03:17 <sethk> gzl, the first batch are firewall/routers
18:03:25 <dons> sethk, yep. I'm preparing the issue right now. i'll msg you.
18:03:30 <Rawr321> k
18:03:37 <gzl> sethk: ok
18:03:39 <sjanssen> Rawr321: with ghci, declaring things go in a file, and then you can test everything out with ghci
18:03:40 <sethk> gzl, they may bring out other similar products on the same basic hardware platform.
18:03:56 <skylan> http://wagerlabs.com/articles/2006/01/01/haskell-vs-erlang-reloaded - this is joelk's post-morteum, it seems.
18:04:00 <gzl> did you write it all yourself or was it a group project?
18:04:13 <gzl> haha, sorry for all the questions, I'm just kind of curious
18:04:17 <lispy> Rawr321: if you want to experiment with one line functions you can use "let", let foo = 3
18:05:16 <lispy> Rawr321: there is syntax for using let with multiline, but it's ugly and you really should be writing your functions down in a ifle
18:05:30 <sethk> gzl, actually this has been one of those rare projects where the people I'm working for just want results, and let me produce them any way I want to.
18:05:43 <sethk> gzl, I've been working in software for 30 years, and I've only had a few of those.
18:06:05 <sethk> gzl, they are hardware engineers, and don't really know much about software.
18:07:06 <lispy> i was just realizing during this last week that if i really want to work in the game industry i'll have to use C++ quite a bit.  At least until people realize that modern games can be written more effectively in functional languages
18:08:12 <sethk> lisppy, I imagine that's true, yes.  There are probably legitimate performance issues related to game software.  Although maybe they are solvable; I'm hardly an expert in that area, the last game I liked was breakout
18:08:23 <lispy> i was also realizing i need some type of portfolio to show that i'd be a good hire.  So I'm now trying to figure out if i really want to write an example game in C++ or not :)
18:08:47 <sethk> lispy, well, of course, if you show an example in c++ you are liikely to get hired to do c++.
18:09:09 <lispy> sethk: i think FP langs can do the trick, the hard part would be convincing a gamedev team that haskell or ML is right for them
18:09:30 <tic> isn't there a presentation on that?
18:09:44 <lispy> tic: yes by Sweeny (sp?) of epic
18:09:48 <sethk> lispy, in that case, perhaps the strategy would be to show some good performing examples written in a functional language.
18:09:50 <lispy> tim sweeny iiirc
18:09:50 <tic> lispy, right, that's the one.
18:09:58 <jethr0_> glancing over joelk's "post mortem", i must say that his problem is pretty much a showcase for what erlang was designed for.
18:09:59 <Saulzar> Library support is a big factor, for a major game they're not going to start from the ground up
18:10:12 <tic> ffi!
18:10:14 <tic> or h/direct
18:10:18 <Rawr321> My goal is to write a game in haskell.  Ive been wondering if haskell is suitable for game dev
18:10:23 <jethr0_> so, even though it might have been well possible in haskell, it's no shame to lose out to erlang on this one, IMHO
18:10:27 <Rawr321> I usually use C++ with opengl....dunno how its gonna work in haskell
18:10:28 <Saulzar> Those libraries are probably not written in C
18:10:33 <lispy> Saulzar: yeah looks like middleware is a big deal
18:10:41 <tic> *Zzz*
18:11:21 <Saulzar> Rawr321, There is HOpenGL which is a binding for OpenGL, which is quite nice
18:11:27 <jethr0_> Rawr321: have you seen frag?
18:11:33 <Rawr321> yea I saw it
18:11:35 <jethr0_> @oldwiki frag
18:11:36 <lambdabot> http://www.haskell.org/hawiki/frag
18:11:37 <lispy> i'm trying to figure out 1) if i would like gamedev (I think i would, but i hear it's terrible) 2) what i need to do to improve my chances of getting a nice job in industry
18:11:44 <lispy> Saulzar: quite nice?
18:11:45 <jethr0_> Rawr321: what did you think of it?
18:11:53 <Rawr321> Looks pretty cool
18:11:58 <Rawr321> But does haskell make gamedev easier?
18:12:01 <Saulzar> lispy, Well, it wraps some of the tedious stuff 
18:12:23 <lispy> Saulzar: i tried using it but found it didn't match the opengl api very closely and there were gob and gobs of types to chew through without much resuse in sensible places
18:12:42 <jethr0_> i guess haskell for game design is rather a niche historically and therefore much infrastructure isn't as far advanced as in other domains
18:12:51 <Saulzar> lispy, Example?
18:12:58 <skylan> lispy: You've heard of the Haskell Quake rewrite "Frag"?
18:13:03 <gzl> sethk: ah, I see. I was wondering, since usually there's some resistance to coding stuff in a fringe language like Haskell.
18:13:08 <dons> @wiki Frag
18:13:09 <lambdabot> http://www.haskell.org/haskellwiki/Frag
18:13:10 <lispy> skylan: yeah, i played it a little
18:13:25 <lispy> Saulzar: well, Vector3 a vs. Color3 a
18:13:25 <Rawr321> @oldwiki Frag
18:13:26 <lambdabot> http://www.haskell.org/hawiki/Frag
18:13:36 <sethk> gzl, oh, absolutely, the resistance can be massive.
18:13:38 <lispy> Saulzar: i didn't understand why you'd need both
18:14:24 <lispy> Saulzar: and very often you have to add type annotations in experssions
18:14:34 <palomer> newtype Environment = Environment {typeTable::(M.Map String Kind),constructorTable::(M.Map String Monotype)} <--what's wrong with this declaration?
18:14:59 <Saulzar> Rawr321, Well, HOpenGL is a binding to the C library, so you're not gaining anything there - you'd have to write libraries around it as with any other low level stuff.
18:15:07 <sjanssen> palomer: first, replace newtype with data
18:15:17 <palomer> sjanssen: why?
18:15:25 <palomer> oh, good point:o
18:15:35 <Rawr321> Well ive been writing a engine in C++, been working on it for 6 months.  I would hate to give up 6 months work just to redo it in haskell
18:15:37 <palomer> no, wait, why?
18:15:40 <lispy> writing a scene graph library on top of HOpenGL would be a huge start in showing that haskell is good for graphics
18:15:57 <Rawr321> -_- I just finished a scene graph lib in C++ for opengl
18:16:09 <Saulzar> lispy, Well, you never need to interchange them - why would they be the same type? I guess it would be easier if it was just a synonym
18:16:24 <Rawr321> and a renderer, resource manager, input lib, and html logger
18:16:30 <sjanssen> palomer: newtypes can only be wrappers around one piece of data, you need to use data if you want several pieces of data
18:16:53 <palomer> err, there's only one constructor here
18:17:13 <Rawr321> can someone help me with ghc?  I ran it and loaded my source file.  But when I try to call the function it says not in scope of it
18:17:19 <lispy> Saulzar: i disagree, but more importantly, why don't the functions take something like Num a => a -> a -> a -> b, ?
18:17:23 <jethr0_> Rawr321: you could do Foreign Function Calls to your C++ library.
18:17:42 <Rawr321> seems like it would be easier to just use C++
18:17:44 <jethr0_> Rawr321: could you lisppaste the source file and the error message?
18:17:58 <Rawr321> lisppaste?
18:18:04 <jethr0_> http://paste.lisp.org/new/haskell
18:18:05 <lispy> lisppaste2: ping
18:18:18 <palomer> oh wait, it was correct
18:18:19 <palomer> nevermind
18:18:30 <Rawr321> k
18:19:17 <Saulzar> lispy, I guess they could, a matter of style. In any high level library you would expect to use "structures" rather than 30 parameters
18:19:53 <lispy> i wouldn't consider opengl to be a highlevel library tho
18:19:59 <lisppaste2> Rawr321 pasted "Function in ghc not working" at http://paste.lisp.org/display/17007
18:20:02 <sjanssen> you're saying that the "newtype ..." line you pasted above is correct?
18:20:04 <Saulzar> Well, it's not - but HOpenGL is slightly higher level...
18:20:51 <lispy> Saulzar: maybe that's what bothered my about HOpenGL it tried to be higher level without really providing anything convient and requiring me to add (0::Float) all over the place just so it would type check was annoying
18:21:09 <jethr0_> Rawr321: are you using ghci?
18:21:12 <Rawr321> yes
18:21:26 <Rawr321> maybe im trying to call the function wrong?
18:21:29 <Saulzar> I never found it an issue, I just made a few tiny wrappers and everything was fine and dandy
18:21:41 <Saulzar> (So I put the 0::Float in one place rather than everywhere)
18:22:07 <Saulzar> Though I agree there are rather a lot of types..
18:22:09 <jethr0_> Rawr321: when i open the file with ghci and use fac it just works fine. what exactly are you doing?
18:22:32 <Saulzar> But for any application I guess you would only use a fairly limited set which you can wrap easily
18:23:10 <Rawr321> I made a batch that runs ghci with the text file...then typing fac 5
18:23:10 <lispy> Saulzar: i had a problem with needing so many type constructors to wrap up floating point values.  The C code I was converting used arrays, and so I would pull values out of the array, wrap them up with a data constructor and then fire them off.  It was actually causing performance issues
18:23:47 <jethr0_> Rawr321: try it without the batch file. "ghci fac.hs" and then "fac 5". that should work
18:23:48 <Saulzar> lispy, Well - for any serious code you would be using vertex buffers/arrays, drawElements etc.
18:23:56 <lispy> Saulzar: well, i should say, I think that was the bottle neck.  Finding the source of a performance problem in haskell is non-trivial
18:24:12 <Saulzar> Which use packed arrays ie. Ptr a   
18:24:53 <palomer> @type \x -> lift (flip x)
18:24:54 <lambdabot> Not in scope: `lift'
18:25:18 <lispy> Saulzar: yeah, i found that computing the values as i needed them was faster than precomuting them as in C
18:25:20 <jethr0_> lispy: i guess finding the approximate source of a performance bottleneck is relatively easy with profiling. but fixing the concrete, exact location is the real hassle!
18:26:12 <lispy> no programming language is perfect :)
18:26:26 <Rawr321> jethr: I found the problem, but now its saying "ignoring unrecognized input"
18:26:32 <Saulzar> lispy, Well, you can make C pointers/arrays in Haskell code
18:27:03 <lispy> Saulzar: i used IOUArray, but someone mentioned for what I was doing other things may have actually been faster
18:27:45 <jethr0_> Rawr321: you're under windows, right? how did you install ghc?
18:27:59 <Rawr321> the installer
18:28:36 <jethr0_> my guess at that error message would be windows-style newlines "\n\r". but that's obviously just guessing. and the windows version of ghc should be able to handle it...
18:28:44 <Saulzar> lispy, StorableArray gives you a way to grab a C pointer to the data, seems quite useful
18:28:48 <palomer> http://www.rafb.net/paste/results/95vlUS49.html
18:29:41 <palomer> why isn't nameAndRef in that scope?
18:30:00 <Rawr321> wanna know why haskell isnt popular? its too damn hard to get to work...
18:30:30 <lispy> well, regardless of how much i love haskell I think I'll need to make an example game in C++ if I want to get a job in the current game industry
18:30:40 <sethk> Rawr321, it's not, actually, it just has a steep learning curve, which is quite a different thing
18:30:51 <sjanssen> palomer: I think that the where is applying to the top level function, rather than within the do block
18:31:06 <palomer> that sucks
18:31:09 <jethr0_> Rawr321: actually it's usually not a problem...
18:31:23 <lispy> Rawr321: i'd say C++ has a pretty steep learning curve and isn't that easy to get going with, but you seem to have mastered it?   I'd say just give haskell more time
18:31:25 <palomer> sjanssen: how is that even possible?
18:31:30 <Rawr321> well it keeps saying "ignoring unrecognized input: foo.txt"
18:31:43 <Saulzar> Rawr321, Do you need to call it foo.hs ?
18:31:45 <lispy> try changing it to foo.hs
18:31:54 <Rawr321> alright
18:31:54 <jethr0_> Rawr321: try renaming it to ".hs". and make sure there's no "weird" input :)
18:32:00 <sethk> Rawr321, I'm sure I can get my c++ compiler to say the same thing.  :)
18:32:02 <sjanssen> palomer: I'm not entirely certain, but I don't think where ever scopes within the do block
18:32:46 <Saulzar> lispy, I don't know - games are fun, but not that fun. Seems you have to be super-hardcore to work in the games industry
18:32:47 <jethr0_> sethk: with a turing-complete preprocessor that should be a breeze :)
18:33:03 <Rawr321> im getting a lexical error
18:33:19 <jethr0_> Rawr321: could you elaborate?
18:33:35 <Rawr321> fac n | n > 0 = n *fac (n-1)
18:33:45 <Rawr321> says theres an error on that line
18:34:08 <jethr0_> Rawr321: you don't actually need the "| n> 0" part
18:34:22 <lispy> Saulzar: i think there are a lot of fun technical challenges and creative work.  But hearing things like that is helpful :)
18:34:28 <jethr0_> well, except you want to prevent negative input
18:35:00 <Rawr321> still, lexical error it says
18:35:04 <lispy> Saulzar: what i should probably do is find an internship in gamedev as a sort of "try it before you buy it"
18:35:13 <jethr0_> > let fac 0 = 1; fac n | n > 0 = n * fac (n-1) in fac 3
18:35:13 <lambdabot> 6
18:35:16 <jethr0_> hmm
18:35:17 <Saulzar> lispy, I used to think it might be fun, but I don't think I have what it takes really :)
18:35:31 <lispy> Saulzar: what does it take?  the hardcore love for games?
18:35:46 <Rawr321> no it takes insanity to wanna be in gamedev
18:35:48 <Saulzar> Not sure, lots of smarts I guess :)
18:35:56 <lispy> Rawr321: wry?
18:35:58 <lispy> er why
18:36:18 <Rawr321> lol its a lot of work and isnt too fun
18:36:46 <sethk> Rawr321, it isn't my idea of fun either, but for some people it is
18:36:55 <Rawr321> not really
18:37:02 <Rawr321> they just do it because it can be rewarding
18:37:07 <Saulzar> I much rather stick to "simple" games :)
18:37:20 <Rawr321> I dont think anyone actually finds the process fun, its just fun when you finish 5 years of working on a game
18:37:30 <Rawr321> whats wrong with my code:
18:37:31 <Rawr321> fac :: Integer -> Integer
18:37:31 <Rawr321> fac 0 = 1
18:37:31 <Rawr321> fac n = n *fac (n-1)
18:37:50 <jethr0_> Rawr321: it works fine for me. maybe there's sth wrong with your file or your install
18:37:56 <lispy> i don't see anything wrong with taht code
18:38:23 <jethr0_> Rawr321: could you post the error msg?
18:38:46 <lispy> > let { fac :: Integer -> Integer; fac 0 = 1; fac n = n * fac (n - 1)} in fac 3
18:38:47 <lambdabot> 6
18:38:59 <lispy> that code should be fine, lambdabot accepted it
18:45:17 <Saulzar> As project tends to infinity, fun tends to zero
18:46:12 <dons> @remember Saulzar As project tends to infinity, fun tends to zero
18:46:21 <dons> that's a good  one.
18:47:40 <jethr0_> i guess small and frequent iterations can somewhat alleviate that problem...
18:55:05 <lispy> heh, nice quote
18:55:26 <lispy> refactoring is supposed to help too
18:59:18 <Dreadshoot> whats the name of that thing that let you link haskell <-> c++ and so on?
18:59:37 <sethk> foreign function interface
19:12:37 <Rawr321> so do you guys think C/C++ with lazy expressions would be cool?
19:15:51 <lispy> Rawr321: laziness is nice, but I don't beleive C++ is really setup for really being able to do higher order programming
19:15:56 <Dreadshoot> lazy evaluation you mean? well, maybe in a few cases for less code but not really
19:17:20 <Dreadshoot> its not totally strict though since compiler can do some optimizations
19:21:22 <Rawr321> well what makes haskell so special over say C++
19:23:06 <wolverian> lispy, the stl's functional parts do make an attempt at hop 
19:23:42 <dons> yeah, it doesn't make much sense adding it to a low-level language. the code around it is just not expressive enough to make much use of it, I reckon.
19:24:25 <dons> without a lot of gunk, perhaps.
19:54:40 <palomer> > [2,3] \ [4,5]
19:54:40 <lambdabot>  parse error on input `\'
19:54:44 <palomer> > [2,3] \\ [4,5]
19:54:45 <lambdabot> [2,3]
19:54:47 <palomer> > [2,3] \\ [1,5]
19:54:49 <lambdabot> [2,3]
19:54:49 <palomer> > [2,3] \\ [2,5]
19:54:50 <lambdabot> [3]
20:01:28 <lispy> wolverian: i can't argue, but it does seem to me that you have to fight C a bit to do it
20:01:56 <wolverian> lispy, yes. I didn't say it makes a good attempt..
20:02:23 <lispy> i'm also planning on using a GC if I go through with this project
20:02:57 <lispy> i don't want to get knee deep in garbage, especially if that sweeny guy says a GC is good enough for Unreal3
20:03:21 <lispy> time to meet a friend, peace out
20:05:35 <palomer> I have two datatypes, polyType and monoType, and I want to write a function that will unify polyType with polyType, polyType with monoType or monoType with monoType, how do I do this (with typeclasses maybe?)
20:12:01 <palomer> http://www.rafb.net/paste/results/Dxz8Vk37.html
20:14:38 <palomer> anyone have any clues?
20:17:32 <lambdabot> Issue 25 of the Haskell Weekly News is out : sequence.complete.org
20:19:35 <Cale> palomer: class Unifiable c d where
20:20:03 <palomer> hrmph
20:20:09 <palomer> that s bothers me
20:20:11 <Cale> and delete the ss from the instance declarations
20:20:55 <palomer> ss?
20:21:06 <Cale> instance Unifiable MonoSType MonoSType where
20:21:20 <palomer> oh, yeah
20:21:28 <palomer> ok, what's the s doing there?
20:21:41 <Cale> hm?
20:21:54 <Cale> in ST?
20:22:58 <Cale> It's making sure that referential transparency is preserved, by marking the types of everything which relies on the state of an ongoing ST computation, and not letting it escape.
20:23:32 <palomer> how does it not let it escape?
20:25:13 <Cale> Well, the type of runST
20:25:17 <Cale> @type runST
20:25:17 <lambdabot> Not in scope: `runST'
20:25:24 <Cale> @type Control.Monad.ST.runST
20:25:25 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
20:25:58 <Cale> if you try to call it on something of type  ST s (... s ...), it will fail
20:26:41 <Cale> because s isn't even in scope in the outer type
20:27:00 <palomer> ahh, but if you had switched around the quantifiers you could
20:27:04 <Cale> yeah
20:27:07 <Cale> or if it was
20:27:16 <Cale> forall a s. ST s a -> a
20:27:30 <palomer> and how does this help us?
20:27:33 <Cale> but that would mean that you could smuggle out an STRef
20:27:44 <Cale> which would kill referential transparency
20:28:09 <Cale> It would be nearly as bad as unsafePerformIO :)
20:30:55 <palomer> <Cale> if you try to call it on something of type  ST s (... s ...), it will fail <--how does this help us?
20:31:18 <Cale> Well, what sorts of things have that s on them?
20:31:33 <Cale> Just STRefs and STArrays, and anything which contains those.
20:32:04 <Cale> suppose that we were allowed to return an STRef
20:32:30 <Cale> let rx = unsafeRunST (newSTRef 0)
20:33:59 <palomer> oh, so this stops us from returning an stref
20:34:11 <Cale> yes
20:34:15 <palomer> and why can't you instantiate s?
20:34:18 <Cale>     y = unsafeRunST (do v <- readSTRef rx; writeSTRef rx (v+1); return v)
20:34:44 <Cale> well, the forall there means that runST only accepts fully polymorphic arguments
20:34:52 <Cale> (fully polymorphic in s)
20:35:50 <Cale> You can imagine that runST will instantiate s with some kind of reference table type.
20:36:08 <Cale> Really, it just uses IO, I think, but the s still makes sure that everything is safe.
20:36:29 <palomer> but why must the argument be fully polymorphic?
20:37:37 <Cale> well, what else would you have in mind?
20:38:39 <palomer> exists ?
20:39:03 <Cale> as I mentioned, if it we had  unsafeRunST :: forall s a. ST s a -> a  then we'd be in trouble
20:39:25 <palomer> yeah
20:39:26 <Cale> in fact, with some evil extensions to the type system, you can write that
20:39:37 <Cale> (incoherent instances)
20:39:40 <palomer> forall a. exists s. ...
20:40:05 <palomer> @hoogle runST
20:40:05 <lambdabot> Control.Monad.ST.Lazy.runST :: ST s a -> a
20:40:05 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
20:40:05 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i
20:40:05 <lambdabot> e
20:40:19 <Cale> Hoogle gets the type wrong
20:40:28 <Cale> Because it doesn't know about foralls
20:40:37 <palomer> forall a. (exists s. GHC.ST.ST s a) -> a
20:40:57 <Cale> isn't that basically the same as  forall a s. ST s a -> a?
20:42:15 <palomer> forall a (exists b. P(a,b)) -> a -||- forall a b. P (a,b) -> a         <---is this what you're claiming?
20:43:12 <Cale> I don't know what that relation symbol is, but possibly.
20:43:46 <palomer> -||- means inter provable
20:44:31 <palomer> well, that would be the same as (exists b. P(a,b)) -> a 
20:44:38 <palomer> -||- forall b. P(a,b) -> a
20:44:56 <palomer> surely you don't think those two formulas are equivalent?
20:45:25 <palomer> the second one implies the first, but not the other way around
20:45:46 <palomer> let's ask djinn
20:46:16 <palomer> @djinn (forall a b. P (a,b) -> a) -> (forall a . (exists b. P(a,b)) -> a)
20:46:17 <lambdabot> Cannot parse command
20:46:34 <palomer> @djinn (forall a. forall b. P (a,b) -> a) -> (forall a . (exists b. P(a,b)) -> a)
20:46:35 <lambdabot> Cannot parse command
20:46:43 <palomer> @djinn A -> A
20:46:44 <lambdabot> f a = a
20:46:45 <Cale> djinn doesn't have explicit quantification
20:46:49 <palomer> gah!
20:46:55 <palomer> what a silly theorem prover
20:46:57 <dons> it's not going to fly palomer. djinn only handles a subset of the type language.
20:47:11 <Cale> exists isn't even in the type language :)
20:47:31 <dons> that too...
20:47:35 <Cale> (but I suppose it could be :)
20:47:52 <palomer> it should be!
20:48:14 <Cale> I don't actually agree
20:48:46 <Cale> well, I can see it in the syntax for defining data constructors, and that's it
20:49:01 <palomer> Cale: and for getting rid of the s in ST
20:49:10 <palomer> as well as higher order modules
20:49:13 <Cale> hm?
20:49:28 <taw_> hello :-)
20:49:33 <taw_> ERROR "/home/taw/lava/Lava2000/Modules/MyST.hs" - Unknown entity "fixIO" imported from module "IOExts"
20:49:35 <Cale> we still wouldn't be getting rid of it
20:49:37 <taw_> any idea how to fix it ?
20:50:08 <dons> @hoogle fixIO
20:50:08 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:50:33 <dons> fixIO isn't in IOExts anymore (not for a few years...) so you'll need to change that import
20:50:38 <Cale> that, or import Control.Monad.Fix instead, and replace fixIO with mfix
20:51:01 <palomer> we'll have to wait until ski gets back here
20:51:12 <palomer> he told us how mercury uses existentials for ST
20:51:17 <taw_> i don't have even the slightiest idea of what you're talking about, just trying to run someone else's program
20:51:19 <taw_> :-)
20:51:37 <Cale> taw_: then you'll have to get them to update it
20:52:13 <Cale> but that change is easy
20:52:20 <Cale> look for a line that says
20:52:25 <Cale> import IOExts
20:52:31 <Cale> and replace it with
20:52:33 <taw_> yeah
20:52:36 <Cale> import System.IO
20:52:47 <taw_> i see some import IOExt
20:52:49 <taw_> i see some import IOExts
20:52:59 <taw_> what to do with it ?
20:53:01 <palomer> don't you guys feel tempted sometimes to write a Convert typeclass and just stick everything that's convertible into it?
20:53:11 <Cale> taw_: replace it with  import System.IO
20:53:21 <Cale> palomer: convertible?
20:54:59 <taw_> wow, it did something :-)
20:55:18 <palomer> yeah, like instance Convert Int Float, instance Convert Car Truck, instance Convert Flower Plant
20:55:23 <palomer> call it coerce if you want
20:55:44 <Cale> but there's usually more than one way to do things
20:56:38 <palomer> yeah, this is the really sloppy way
20:57:25 <palomer> Cale: oh, I was having problems with the where syntax
20:57:39 <palomer> Cale: if you put a where in a do block, can I use the <- bindings in that do block?
20:57:54 <Cale> a where in a do block?
20:58:09 <Cale> where is attached to the end of a function declaration
20:58:23 <Cale> (it's part of declaration syntax, not expression syntax)
20:58:32 <palomer> oh my
20:58:51 <Cale> that's what sets it apart from let
20:58:56 <Cale> where scopes over guards
20:59:00 <palomer> why not let us put it in a do block?
20:59:17 <Cale> what would that mean?
20:59:32 <Cale> would it be any different from let in a do-block?
20:59:34 <palomer> do {y <- foo; z where z = ...}
20:59:44 <palomer> Cale: prettier syntax
20:59:56 <palomer> much easier to read sometimes
21:00:14 <Cale> usually you can write the where after the do-block
21:00:32 <palomer> do {y <- foo; z where z = y}
21:00:43 <Cale> okay, you can't do that
21:01:03 <Cale> but  do {y <- foo; let z = y; z}  is allowed
21:01:18 <palomer> so what's the advantage of where?
21:01:42 <Cale> where scopes over multiple guards
21:01:47 <Cale> I can write
21:01:57 <Cale> f x | x < 0 = a
21:02:05 <Cale>     | x >= 0 = 2 * a
21:02:15 <Cale>    where a = 5
21:02:49 <palomer> oh, so it's the equivalent of the "local" keyword in sml
21:03:00 <Cale> I don't know, maybe
21:04:05 <dons> the ordering is the advantage. some code becomes clearer with 'where' instead of 'let'
21:04:11 <palomer> dons: agreed
21:04:21 <palomer> so I think we should make it part of expression syntax!
21:04:24 <Cale> yeah, the ordering is quite nice like that
21:05:05 <palomer> why not have it part of both?
21:05:26 <Cale> I suppose that might be possible. You'd need a way to resolve ambiguities.
21:05:39 <dons> just about every question we answer here Cale should go on the wiki :)
21:05:53 <Cale> this already is on the wiki
21:06:00 <dons> i.e. LetVersusWhere should be a page.
21:06:11 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fLetAndWhere
21:06:50 <dons> ah, but do we need to rewrite everything to get it on thew new wiki? there's an explicit directive not to port pages we don't have the copyleft to, which is a problem.
21:07:05 <palomer> there's a newer wiki?
21:07:27 <Cale> haskell.org is now a wiki :)
21:07:35 <dons> i have to work up enough steam to be botherered rewriting a whole page coherently to port it. tehen again, maybe that's good.
21:10:55 <ncalexan> @hoogle member
21:10:55 <lambdabot> Data.IntMap.member :: Key -> IntMap a -> Bool
21:10:55 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
21:10:55 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
21:11:04 <ncalexan> @hoogle elem
21:11:05 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
21:11:05 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
21:11:05 <lambdabot> Data.Array.IArray.elems :: (IArray a e, Ix i) => a i e -> [e]
21:21:04 <palomer> ok, get this guys
21:21:19 <palomer> I have MonoTypes and PolyTypes
21:21:29 <palomer> and PolyTypes is a subtype of MonoTypes
21:21:50 <palomer> but in haskell I find myself constantly rewriting functions and fighting against the type system
21:22:00 <palomer> what's the best way to deal with this?
21:22:08 <Pseudonym> Write them correctly to start with. :-)
21:22:17 <Pseudonym> Actually, that's not as glib as it sounds.
21:22:22 <Pseudonym> Write the type signature first.
21:22:47 <Pseudonym> You'll fight the type system less if you be clear about what you mean first.
21:23:00 <palomer> http://www.rafb.net/paste/results/rhGxiK28.html
21:23:46 <Pseudonym> OK...
21:23:52 <palomer> any operation on a PolyType can be applied to  a MonoType
21:24:29 <palomer> and if a is a polytype which quantifies over nothing, it can be considered a monotype
21:24:36 <Pseudonym> Right.
21:24:44 <palomer> currently doing H-M, btw
21:24:55 <Pseudonym> Yup, figured that.
21:25:11 <Pseudonym> Well, technically Damas-Milner, if you have let-polymorphism.
21:25:16 <Pseudonym> But I digress.
21:25:35 <Pseudonym> So what's a sample oepration?
21:26:00 <palomer> http://www.rafb.net/paste/results/pqQiGe62.html <--this is where the trouble starts
21:26:12 <palomer> infer returns a PolyType
21:26:59 <palomer> I can't get my head around how I'm supposed to do this
21:27:41 <palomer> the problem is that from and to are polytypes
21:27:45 <palomer> but that doesn't make sense, really
21:29:01 <palomer> so I'm guessing I only instantiate at the axiom rule?
21:29:12 <Pseudonym> Hang on a moment.
21:29:24 <Pseudonym> OK.
21:29:28 <Pseudonym> Had to think for a moment.
21:29:38 <Pseudonym> Polytypes are for top-level lets, right?
21:30:45 <palomer> yup
21:30:59 <Pseudonym> So infer of an App shouldn't return a polytype.
21:31:19 <palomer> true, true
21:31:42 <palomer> so types are instantiated only when you retrieve them from the context (gamma), right?
21:31:53 <Pseudonym> Yes, that sounsd right.
21:32:00 * Pseudonym tries to remember back to when he implemented this
21:32:15 <sieni> http://ircquotes.net/?93355
21:32:16 <Pseudonym> Yes, that's right.
21:32:19 <sieni> sorry
21:32:29 <sieni> wrong channel
21:32:44 <Pseudonym> So like I said, she was dead when I got there.  Complete misunderstanding.
21:32:48 <Pseudonym> Sorry!  Wrong channel.
21:32:59 <palomer> well, I've done enough work for today
21:33:00 <palomer> whew
21:33:02 <palomer> this is tough stuff
21:33:21 <Pseudonym> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/PAGES/163.HTM
21:33:25 <Pseudonym> That's if you want to cheat.
21:33:34 <Pseudonym> Don't feel you have to.
21:34:01 <palomer> I think I have it down pretty well
21:34:17 <palomer> patterns might become a problem though:o
21:34:38 <Pseudonym> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/PAGES/078.HTM
21:34:47 <Pseudonym> More cheat code. :-)
21:37:08 <Pseudonym> Note that fatbar and fail are actually deprecated.  A modern FP implementation would use let expressions to compile pattern matching.
22:40:51 <mq_mattr> any darcs users who can answer a _very_ general question?
22:42:05 <dons> sure.
22:42:13 <dons> if it is very general  :)
22:42:18 <mq_mattr> can i use it for backup?
22:42:28 <dons> yes.
22:42:48 <mq_mattr> If I have an external drive, is darcs suitable for incremental backup of my whole main drive?
22:43:11 <dons> ah, no. use rsync or dd or sometihng.
22:43:32 <ptolomy> http://video.google.com/videoplay?docid=-5830318882717959520&q=erlang
22:43:35 <mq_mattr> what's dd
22:43:36 <ptolomy> I love google video so much.
22:43:37 <mq_mattr> ?
22:43:49 <ptolomy> So much quality old PL stuff.
22:43:49 <mq_mattr> I have never had much luck with rsync
22:44:02 <mq_mattr> perhaps I will just suck it up and try again
22:44:09 <dons> rsync is the standard method, afaik.
22:44:18 <audreyt> but unison is imho better.
22:44:36 <audreyt> (faster on subsequent runs after the first)
22:44:38 <mq_mattr> I know, but it never really worked that smoothly, as I say, I will just suck it up and try agian.
22:44:45 <mq_mattr> I used unison, but it was terrible
22:45:01 <mq_mattr> It kept complaining about corrupted thingies
22:45:10 <audreyt> weird, never happened here
22:45:16 <mq_mattr> I would have to delete all the little files it makes and start again.
22:45:22 <audreyt> (2.13.16)
22:45:27 <mq_mattr> It was a while ago, but it drove me mad
22:45:28 <dons> ah, unison, that's the one.
22:45:47 <mq_mattr> looks like unison is worth trying again
22:45:55 <mq_mattr> plus it boosts my FP karma :)
22:46:03 <audreyt> indeed, coming from bcpierce
22:46:46 <mq_mattr> I got his book today, can't wait to get home and start reading
22:47:13 <audreyt> TaPL?
22:47:19 <mq_mattr> That;s the one.
22:47:28 <mq_mattr> Had to go all the way into liechardt
22:47:36 <mq_mattr> (which is a ways from my place)
22:47:43 <audreyt> good book, that. changed my life (hopefully for the better).
22:48:26 <mq_mattr> me and another phd student are going to be going front to back through it together over the next few weeks.
22:48:49 <mq_mattr> don't get many chances to do things like that.  I am always reading things on my own.
22:48:57 <mq_mattr> Much prefer having another brain to pick
22:48:57 <audreyt> it could be very much fun
22:49:16 <audreyt> even better if you just have one copy :)
22:49:26 <audreyt> (of the book, that is)
22:49:33 <mq_mattr> haha - we have one each :(
22:49:57 <audreyt> you can always destroy^Whide^Wforget to bring one
22:50:06 <Korollary> I have a list to sort with sortBy, and the comparison function is a -> a -> IO Ordering. What's an elegant way of doing the sort?
22:50:55 <audreyt> Korollary: use sortByM?
22:51:01 <audreyt> # http://svn.openfoundry.org/pugs/src/Pugs/Prim/List.hs
22:51:46 <Korollary> oh crap
22:52:58 <Korollary> I guess that's why I couldn't think of a short way of doing it.
22:57:26 <Lemmih> Why does the ordering depend on IO?
22:58:21 <mq_mattr> bye all
22:59:32 <dons> oh, um, that means mp_mattr was about 1km from my house :)
22:59:50 <dons> and he might be Tony Sloane's student. 
23:01:19 <dons> HyperPostfix, eh?
23:05:25 <tic> C++ is growing polymorphism and partial function-application. Soon, we'll all be programming in Haskell or a Lisp. The prophecy has come true! All hail the prophet.
23:06:02 <integral> *we* will,   but they'll be stuggling with a broken half implementation with dire syntax :)
23:07:02 <dons> yeah :)
23:07:36 <Cale> hehe
23:07:58 <Cale> It's somewhat amazing to me that people are even bothering to extend C++.
23:08:07 <Cale> Even C!
23:08:18 <dons> flogging a long dead horse.
23:08:41 <tic> integral, --Philip Greenspun, right? :)
23:08:50 <Cale> It's like, if you're going to change a language that's that old, why not just make a new language?
23:09:21 <tic> Cale, you get okay performance and numerous ways to shoot yourself in the foot.  And let's not forget about Tradition(tm).
23:09:26 <dons> and, as we know "even the #lisp people say go with haskell"
23:09:27 <jcreigh> Cale: They *are* new languages, they just have the same name and similar semantics in order to attract mindshare.
23:10:31 <Cale> jcreigh: right, which means that they don't actually fix the problems inherent in those languages, while breaking compatibility.
23:10:37 <dons> I would love to see stats on how many people are leaving lisp for haskell. lispy, any idea? ;)
23:11:24 <jcreigh> Cale: Oh, killer quote. Pithy, sad and true.
23:34:02 <lispy> what, huh? leaving lisp?  hm...i'd say that many lispers are cranky old hackers that just like to complain :)
23:35:12 <lispy> i stopped hanging around #lisp quite a while ago...seemed like the community was too angry :)
23:39:23 <lispy> lisp is still a nice language, but static typing has won my heart...now if laziness could win my over...
23:42:14 * wli is getting progressively less enamored of indexless linear algebra.
23:44:42 <Cale> wli: why?
23:45:42 <wli> Householder reflections are nasty indexless, the Jacobi method is even worse indexless, etc.
23:47:25 <wli> All the methods that appear to be feasible to write indexlessly appear to be barfing on my PCA issues.
23:47:41 <wli> (eigenvalues and eigenvectors of correlation matrices)
23:48:15 <Cale> oh, indexless computational linear algebra?
23:48:32 <wli> That's the stuff.
23:48:47 <Cale> I'd expect that to often be difficult
23:52:41 <wli> it shouldn't be
23:52:47 <wli> I'm just sort of dumb on these things.
23:53:37 <Cale> so how are you representing linear maps? Just as functions?
23:54:22 <wli> Matrices of linear transformations?
23:54:32 <wli> atm. [[Double]]
23:54:48 <Cale> oh, okay, that's not as indexless as I was thinking then :)
23:55:03 <wli> UArray seems like the more plausible method.
23:55:18 <wli> Cale: Well, (!!) isn't being touched due to inefficiency.
23:55:45 <Cale> wli: yeah, but the matrix representation is still there :)
23:56:37 <Cale> UArrays can be quite usable
23:57:03 <wli> It probably makes sense to have special representations for sparse matrices, band diagonal matrices, and symmetric band diagonal matrices.
23:57:20 <wli> That's a bit of a tall order, though.
23:58:07 <wli> I'm really only going to be dealing with a limited subset of shapes, i.e. dense symmetric, Givens/Householder, and symmetric tridiagonal.
23:58:19 <cpatrick> yeah. and GHC optimises updates of UArrays so they're in-place, too
