00:00:03 * ibid wonders why anybody would choose anything else than <> :)
00:07:02 <Cale> not everything is ordered
01:27:10 <Mitar> i am trying to implement an algorithm in haskell which is something like: you have an empty set V, in some case (V is used in this testing) add v to V, repeat until V does not change anymore
01:27:24 <Mitar> any Haskell contruct for this?
01:39:16 <jethr0_>  @hoogle iterate
01:39:23 <jethr0_> @hoogle iterate
01:39:24 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
01:39:24 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
01:40:10 <jethr0_> Mitar: couldn't you use a fold?
01:41:05 <poro> Hi! I have an irda-dev connected to usb-port through com-2-usb converter (and another irda-reader on the laptop). 
01:41:23 <Mitar> fold?
01:41:24 <poro> How could I read the devices with some Haskell prg? 
01:41:34 <poro> Any ideas?
01:42:40 <jethr0_> Mitar: i'll have to thinkg about this. but basically it's not all too hard
01:42:46 <jethr0_> poro: what do you mean?
01:43:14 <poro> At the moment I have to use win and some proprietary sw to read the dev.
01:43:29 <poro> and I'm not happy with the sw that handles the results
01:43:43 <poro> I'd like to write the entirely with Haskell 
01:43:53 <poro> I mean 
01:44:18 <poro> read the values from the device and store them to db and then some reports etc.
01:44:41 <poro> db and reports are easy but reading the values from the device are not
01:44:42 <jethr0_> Mitar: "func vx (v:vs) = let n = join vx v in if n == vx then vx else func n vs"
01:44:58 <jethr0_> but i'm sure that's a fold. i just can't see it yet
01:45:01 <poro> (is not I had to say)
01:45:06 <Mitar> i thought about recursion, if i want to add v to V, then i recurse and add it as a argument, otherwise i return
01:45:26 <Mitar> yes yes ...
01:45:29 <Mitar> the same ide
01:45:30 <Mitar> a
01:46:28 <jethr0_> poro: basically that's well possible. 
01:46:34 <poro> ok
01:46:52 <jethr0_> poro: is there anything concrete you'd like to ask?
01:46:55 <poro> do you know any pointers where I could start (readings or something)
01:47:09 <poro> yes :) (above line)
01:47:57 <poro> I can Haskell a bit and I know linux  a bit but internals are not so familiar to me...
01:49:21 <poro> My first goal would be to see that the device is trying to communicate and somehow get hold on to that 
01:49:51 <jethr0_> let me see
01:50:59 <jethr0_> > let func _ vx [] = vx; func comb vx (v:vs) = let n = comb v vx in if n == vx then vx else func comb n vs in func (:) [] [1,2,3]
01:51:00 <lambdabot> [3,2,1]
01:51:13 <jethr0_> Mitar: is this what you wanted?
01:51:26 <jethr0_> Mitar: as i said, there is a shorter form :)
01:51:30 <jethr0_> @pretty let func _ vx [] = vx; func comb vx (v:vs) = let n = comb v vx in if n == vx then vx else func comb n vs in func (:) [] [1,2,3]
01:51:31 <lambdabot>  i = let func _ vx [] = vx
01:51:31 <lambdabot>    func comb vx (v : vs)
01:51:31 <lambdabot>     = let n = comb v vx in if n == vx then vx else func comb n vs
01:51:31 <lambdabot>    in func (:) [] [1, 2, 3]
01:51:38 <jethr0_> :(
01:52:09 <jethr0_> poro: it certainly is an unusual point to start ones haskell "career" at
01:52:53 <jethr0_> doing IO and bit twiddling can take some getting used to, but is generally quite ok
01:53:11 <jethr0_> poro: is your application performance heavy?
01:53:23 <poro> jethr0_: I have some other personal "projects", too, it is not the only one...
01:53:56 <jethr0_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
01:54:04 <poro> app is not very heavy, there are some blood measurements (time, value)-pairs, maybe ten times a day.
01:54:12 <jethr0_> it's the general docu for the IO functions. not very helpful, i guess
01:54:22 <poro> I collect them, say two-three weeks and then read them from the dev.
01:54:25 <Mitar> i think it is a little mess, but it gives me an idea, thanks
01:54:33 <jethr0_> poro: what kind of device? serial?
01:55:29 <poro> The dev is hand-help measurement dev that has irda. The other dev is the irda-dev with com to usb cable.
01:55:50 <jethr0_> any idea what protocol they speak?
01:55:57 <poro> Its name is "irmate 210" or something (and it should have linux drivers)
01:56:06 <poro> no idea about the protocol
01:57:10 <jethr0_> hmm, i'm not sure how suitable haskell will be for this... although the technical issues aren't the problem. but the examples, tutorials, documentation can be sparse for this kind of haskell task
01:57:26 <poro> I could try to ask the specs from the manufacturer, though
01:58:17 <poro> ok
01:59:04 <poro> because there are so few measurements, I could input the manually 
01:59:18 <poro> I mean them
01:59:22 <jethr0_> but i don't mean to turn you away. better ask again when some of haskell's champions return :)
01:59:33 <poro> ok :)
01:59:45 <jethr0_> it really depends how much low-level stuff you have to write.
01:59:51 <poro> ok
02:00:20 <jethr0_> if the data is there for the taking, like in a file, then its "trivial". if you have to delve into linux drivers and bit-masking, and pointer arithmetic it gets more hairy
02:00:23 <poro> Anyway, I need the db and reporting sections and there is a lot of things to do with them
02:00:40 <poro> ok
02:00:54 <poro> How could I see, if the device has a file systems?
02:01:06 <poro> It is now connected to usb-port?
02:02:07 <poro> oh, but then there is the irda-communication: at least the communication has to be initiated somehow
02:03:15 <poro> Maybe I'll start with the "visual" parts...
02:03:24 <jethr0_> the "irmate 210" seems well supported on linux
02:03:45 <jethr0_> lirc supports it, so you're already on level higher
02:03:58 <jethr0_> with what is it communicating?
02:05:01 <poro> and this is something I don't know yet (maybe the easiest way is to try to get some specs from the Roche that has made the blood-measurement dev)
02:05:23 <jethr0_> i think usually a virtual serial connection is setup over infrared
02:05:49 <Mitar> how can i make a pattern which would match (a,b) but also "store" the whole pair in a c?
02:05:56 <jethr0_> so, you'd only have to send and receive data on a virtual /dev/tty0
02:06:05 <olliej> Mitar c@(a,b)
02:06:12 <Mitar> thanks
02:06:16 <poro> ok, this sounds possible
02:06:17 <jethr0_> > \a@(c,d) -> a $ (5,6)
02:06:18 <lambdabot>   Expecting a function type, but found `t_a1rz'
02:06:18 <lambdabot>   Expected type: a -> b
02:06:18 <lambdabot>   Inferred type: (a1, b1)
02:06:30 <jethr0_> > (\a@(c,d) -> a) $ (5,6)
02:06:31 <lambdabot> (5,6)
02:06:52 <jethr0_> Mitar: can i help you with your function ^_^
02:07:22 <Mitar> you wanna?
02:07:23 <Mitar> :-)
02:07:26 <jethr0_> sure
02:07:34 <olliej> anyone know of a repository of haskell test cases? 
02:07:47 <jethr0_> test cases for what? or just in general?
02:07:55 <olliej> testcases for the compiler :)
02:08:32 <olliej> jethr0_: basically some large and chunky tests :)
02:08:32 <jethr0_> i'd guess with the compiler sources, but i really don't know
02:08:39 <olliej> righto
02:08:48 <olliej> currently using the base libraries
02:09:03 <olliej> but it's difficult to confirm the output code is 100% correct
02:09:12 <Mitar> thanks, but currently i know what to do ... :-)
02:09:27 <Mitar> but i have not seen someone so eager to help ... nice to see
02:09:51 * olliej knows almost no haskell
02:10:01 <poro> very nice indeed! Thank you 
02:10:26 <jethr0_> olliej: http://darcs.haskell.org/testsuite/
02:10:44 <Mitar> i am making a program which converts context free grammar into a greibach normal form
02:10:51 <jethr0_> welcome
02:11:01 <jethr0_> aahh
02:11:05 <olliej> jethr0_: cheers
02:11:21 <olliej> Mitar: I am writing a haskell compiler :)
02:11:42 <Mitar> i have written this already
02:11:43 <Mitar> :-)
02:11:50 <Mitar> interpreter that is
02:11:53 <olliej> hehe
02:12:01 <olliej> I'm targetting .NET
02:12:15 <olliej> compile once, run slowly everywhere
02:13:11 <jethr0_> olliej: http://galois.com/~sof/hugs98.net/
02:13:15 <jethr0_> but it's an interpreter
02:13:22 <olliej> jethr0_: that doesn't target .NET
02:13:37 <jethr0_> "Hugs98 for .NET is an extension of the Hugs98 Haskell interpreter, providing good interoperation between the world of Haskell and the world of .NET and the .NET Framework."
02:13:38 <olliej> it basically does an interface between hugs and .net
02:13:43 <jethr0_> k
02:13:52 <olliej> mine compile to native .net
02:14:01 <olliej> with completel type safety and non-strictness
02:14:10 <olliej> or rather
02:14:18 <olliej> it does when it isn't busy breaking
02:14:23 <jethr0_> i thought there already was one. but maybe i mixing it up with iron python, and .net ruby, and scheme for .net :))
02:14:53 <olliej> jethr0_: the big problems are getting non-strictness, higher rank, and higher kinded types
02:15:09 <olliej> or at least that's what i'm saying in my masters :)
02:15:49 <jethr0_> olliej: it's been done :). but having "good" and transparent interoperability with other .net languages is gonna be tricky
02:16:01 <jethr0_> would be my guess
02:16:18 <olliej> jethr0_: i haven't found anything that indicates it's been done
02:16:26 <olliej> jethr0_: there have been a few attempts
02:16:28 <jethr0_> i mean writing haskell compilers
02:16:35 <olliej> yes
02:16:42 <olliej> but not for the .net type system
02:17:04 <jethr0_> what are the semantical bottleneck in the type system?
02:17:17 <araujo> Good morning.
02:17:24 <jethr0_> i.e. what makes your life hardest :)
02:17:25 <olliej> jethr0_: how do you mean?
02:17:39 <olliej> jethr0_: it's difficult to say
02:18:00 <olliej> there's about 20kLOC (of C# :) ) getting to its current point
02:18:16 <olliej> hoping to have everything bar higher kinded/ranked types done by the end of the week
02:19:09 <olliej> but, so far, getting classes/instances fast has been the biggest concern
02:19:19 <jethr0_> are you planning on compiling directly to MSIL?
02:19:44 <olliej> jethr0_: atm it compiles to CodeDOM which is passed through to C# compiler
02:19:50 <jethr0_> k
02:20:00 <olliej> however, no C# compiler generates trailcalls
02:20:04 <olliej> tailcalls rather
02:20:11 <jethr0_> the old problem
02:20:19 <olliej> .NET supports tail calls
02:20:24 <olliej> but they're hideously slow
02:20:32 <olliej> (slower than an ordinary call)
02:20:36 <jethr0_> how can they be slower than normal calls?
02:20:39 <jethr0_> weird
02:20:54 <olliej> jethr0_: basically it's to do with updating the security info
02:20:56 <jethr0_> seemingly it wasn't very high on their priorities to get unbounded recursion :)
02:21:01 <olliej> because security, etc is per frame
02:21:11 <olliej> jethr0_: i know how to deal with it
02:21:19 <olliej> from my work on mondrian
02:21:23 <jethr0_> right, i heard about that. i think they even added tail recursion only in a later version, right?
02:21:28 <olliej> nope
02:21:34 <jethr0_> k
02:21:35 <olliej> its been there for a while
02:21:43 <olliej> the ugly hack solution:
02:21:49 <jethr0_> i meant later than "initial"
02:21:54 <olliej> catch StackOverflowException
02:21:58 <olliej> and then spawn a new thread
02:22:00 <jethr0_> *yuch*
02:22:05 <olliej> muwhahaha
02:22:16 <jethr0_> that has nothing to do with tail call conversion
02:23:00 <olliej> i handle direct tail recursion already 
02:23:00 <jethr0_> how's the thread content transferred. and how does this deal with interrupted side effects?
02:23:11 <jethr0_> k, you seem to be pretty far along already
02:23:21 <olliej> jethr0_: the generated code has no side effects
02:23:33 <jethr0_> uhu
02:23:34 <olliej> jethr0_: it can compile most of the ghc base libraries
02:23:59 <olliej> as in 90% of any given library
02:24:08 <olliej> rather than the more useful 90% of the libraries
02:24:09 <jethr0_> that's pretty far
02:24:15 <jethr0_> :)
02:24:18 <olliej> i cheated though
02:24:32 <olliej> and actually compile Core (the IL produced by GHC)
02:24:45 <olliej> which means i can skip the type inference
02:24:47 <olliej> :)
02:24:48 <jethr0_> aren't there compiler toolkit that target .net though? did you use any or is it "hand written" code?
02:25:04 <olliej> the parser is generated with antlr
02:25:09 * jethr0_ wipes his eyes... you _skip_ type inference :))
02:25:10 <olliej> but everything else is hand written
02:25:34 <olliej> jethr0_: well there is no research component to getting type inference going
02:25:44 <olliej> jethr0_: but it takes a large amount of work
02:25:45 <jethr0_> so, how hard would is a haskell compiler compared with other languages. just a guestimate...
02:26:04 <olliej> hard to say
02:26:05 <jethr0_> but isn't it quite necessary for haskell?
02:26:13 <olliej> hehe
02:26:20 <olliej> Core is completely types
02:26:22 <olliej> typed
02:26:45 <olliej> just a mo...
02:27:58 <olliej> http://pastebin.com/539786
02:28:32 <olliej> an haskell function, and the resultant Core representation
02:29:13 <jethr0_> weird. i've done a bit of template haskell... but this is even more "verbose"
02:29:17 <olliej> hehe
02:29:40 <olliej> jethr0_: DataziTuple.Z3T is (a,b,c)
02:29:52 <jethr0_> k
02:30:41 <olliej> starting with Core means that i didn't have to do type inference
02:30:49 <jethr0_> so, what are the main components of your compiler, i.e. the parts you wrote manually? type checker, AST transformations, Core code generator, ...?
02:30:56 <olliej> but reprocessing the instance definition is *really* painful
02:31:08 <olliej> okay
02:31:23 <olliej> at core everything is correctly typed
02:31:41 <olliej> the compiler has *many* stages
02:31:41 <jethr0_> but someone has to type it in the first place, right?
02:31:46 <olliej> ghc does :)
02:31:50 <olliej> ghc produces Core
02:31:58 <jethr0_> ah, but that's really cheating :)
02:32:12 <jethr0_> now i understand what you mean by *painful*.
02:32:26 <jethr0_> you're working directly on that mess *brr*
02:32:38 <olliej> jethr0_: remember i'm doing a masters, and have quite a tight timeframe
02:32:53 <jethr0_> i know. i was already wondering how you fit it all in there
02:32:57 <olliej> hence if it isn't new/research it's just time consuming
02:33:04 <olliej> with no reason
02:33:07 <jethr0_> i did nothing so fabulous for my masters...
02:33:29 <olliej> jethr0_: oh? what did you do?
02:34:01 <jethr0_> 3d model creation from laserscans.
02:34:19 <jethr0_> it was a _really_ cool topic, but somehow i was a little overwhelmed by it :)
02:34:27 <olliej> hehe
02:35:14 <olliej> jethr0_: my uni probably couldn't afford any laser scanning stuff
02:35:38 <olliej> jethr0_: given my department can no longer afford to pay tutors to marks assignments :)
02:36:22 <jethr0_> hmm, where do you study?
02:36:39 <olliej> canterbury, new zealand
02:36:42 <olliej> :)
02:36:58 <olliej> it's a nice enough university, but numbers have been plummeting for years
02:37:23 <olliej> (just the generic it downturn thing)
02:37:34 <jethr0_> alright
02:37:45 <olliej> we have <20 postgrads atm
02:38:04 <jethr0_> is that post-bachelor or post-master?
02:38:09 <olliej> post bahelor
02:38:23 <olliej> so masters, honours, and phd
02:38:40 <jethr0_> omg, that's one small community
02:38:53 <jethr0_> what are "honours"?
02:38:59 <olliej> hehe
02:39:10 <olliej> NZ has the UK education system
02:39:14 <olliej> or model
02:39:16 <olliej> basically
02:39:28 <olliej> BSc is 3 year
02:39:29 <olliej> s
02:39:51 <olliej> BSc(Honours) is 4 years, but has a minimum grade of a B+/A-
02:40:45 <jethr0_> but master is only one year, right? so what's the difference?
02:40:55 <olliej> Masters is two years
02:40:58 <jethr0_> ah
02:41:05 <olliej> unless you've a BSc(Hons)
02:41:17 <olliej> in which case you can do it in 12months
02:41:19 <jethr0_> :)
02:41:28 <olliej> it's convoluted
02:41:47 <olliej> but we've always done it that way -- and millions of dead people can't be wrong
02:41:59 <olliej> jethr0_: you in the US?
02:42:07 <Beelsebob> that's the system in Scotland
02:42:12 <Beelsebob> not in England though
02:42:23 <olliej> Beelsebob: oh?
02:42:28 <olliej> Beelsebob: are you sure?
02:42:31 <Beelsebob> yes
02:42:42 <Beelsebob> in england BSc (Hons or not) is 3 years
02:42:49 <Beelsebob> MSc is 1
02:42:50 <olliej> oh thats right
02:43:00 <jethr0_> nah, germany
02:43:05 <olliej> BSc(Hons) is just given if you are in the top x%?
02:43:08 <jethr0_> my brother studied in britain though
02:43:11 <olliej> jethr0_: ah
02:43:34 <Beelsebob> olliej: yeh, 60% and above get you hons
02:43:41 <Beelsebob> (1st, or II/i)
02:43:41 <olliej> jethr0_: the other reason for small number of pstgrads (and to an extent undergrad) at my university
02:43:46 <jethr0_> he's now an aeronautical engineer...
02:44:06 <olliej> is that NZ has 3.8 million people and 7 universities
02:44:31 <jethr0_> and don't know the "normal" ratio, really...
02:44:32 <Beelsebob> hmm? That's not too small is it?
02:44:53 * Beelsebob checks how many unis there are in scotland
02:45:11 <olliej> Beelsebob: it's equivalent to 14 universities in london
02:45:32 <Beelsebob> scotland has a population of 5.6m, and 14 unis
02:45:36 <Beelsebob> fairly similar
02:45:44 <olliej> hmm
02:46:01 <olliej> they government (under) funded as well?
02:46:10 <Beelsebob> indeed they are
02:46:58 <jethr0_> germany has roughly 80mil. and 350 universities
02:47:24 <Beelsebob> which is a significatly higher ration of unis to people
02:47:29 <olliej> yeah
02:47:31 <Beelsebob> about half the people per uni
02:47:38 <jethr0_> :)
02:47:47 <olliej> are you including polytechs as unis?
02:47:53 <jethr0_> yup
02:48:12 <olliej> ah
02:48:17 <olliej> i wasn't :)
02:48:35 <jethr0_> it's becoming politically incorrect to make the distiction :)
02:48:38 * Beelsebob notes that there are 26 universities in london
02:48:47 <olliej> jethr0_: it's a legal distinction here :)
02:49:15 <jethr0_> here too, although i don't know if "legal" describes it well...
02:49:19 <olliej> jethr0_: polytechs can't issue masters/phds/anything higher
02:49:27 <Beelsebob> olliej: certainly in England polytechs are now officially unis
02:49:29 <jethr0_> at least people from polytechs get considerably lower wages here
02:49:38 <Beelsebob> but everyone is sniffy about jumped up polytechs
02:50:15 <jethr0_> the do masters here. and you can do phds at a university with such a master
02:51:48 <Beelsebob> hmm, see here, I somehow ended up on my PhD course with no masters
02:52:22 <olliej> Beelsebob: what's your phd on?
02:52:33 <Beelsebob> olliej: debugging
02:52:50 <jethr0_> nice! functional languages?
02:52:59 <Beelsebob> indeed
02:53:09 <Beelsebob> Haskell specifically atm
02:53:11 <jethr0_> that's sth that would interest me too
02:53:16 <olliej> cool
02:53:24 <jethr0_> and it definitely needs some fixing
02:53:24 <Mitar> hmm, what about yout opinions about bologna reform?
02:53:30 <Mitar> declaration
02:53:42 <Beelsebob> jethr0_: most of the problem with debugging haskell is that no body uses Haskell
02:53:45 <jethr0_> the current situation is dire (at least w/o me having check hat, buddha, ...) ^_^
02:53:57 <Mitar> we are just in process of reforming our programs at my university
02:53:57 <Beelsebob> jethr0_: I'm working on Hat
02:54:06 <Beelsebob> just now on hat-delta
02:54:15 <Mitar> and do not know if we should go to 3+2 model or 4+1 ...
02:54:17 <jethr0_> Beelsebob: i guess generally i would even be easiert because of ref. transp.
02:54:25 <Mitar> is 3 years of undergrad enough to learn CS?
02:54:35 <jethr0_> there's nothing worse than debugging code with corrupt stack frames or some such
02:54:41 <Mitar> (we had 4.5 years before)
02:54:42 <Beelsebob> jethr0_: indeed
02:54:45 <astrolabe> Is there a '--' operator in haskell?
02:54:49 <Beelsebob> astrolabe: no
02:54:57 <Beelsebob> but there are lots of operators that look like it
02:54:58 <Mitar> it is, a comment
02:55:00 <Beelsebob> e.g. -->
02:55:22 <jethr0_> could be the comment operator :)
02:55:23 <olliej> Mitar: 3 years of almost nothing but CS
02:55:25 <Beelsebob> g --> f -- Look how cocked up Haskell's comment syntax is
02:55:28 <astrolabe> Beelsebob.  Sorry misunderstanding.  I meant a decrement operator.
02:55:57 <Beelsebob> astrolabe: (-1)
02:56:06 <Mitar> so are you familiar with 3 years undergrad?
02:56:10 <astrolabe> @eval (-1) 4
02:56:11 <lambdabot>  add an instance declaration for (Num (t -> a))
02:56:11 <lambdabot>   In the definition of `pmc': pmc = (- 1) 4
02:56:11 <lambdabot>   In the definition of `v': v = let pmc = (- 1) 4 in take 2048 (show pmc)
02:56:13 <jethr0_> Mitar: i think it really depends on the courses. i had only two really cool courses, and those i could have done in half a year.
02:56:17 <Beelsebob> Mitar: I did a three year undergrad
02:56:19 <jethr0_> the rest was mediocre
02:56:21 <olliej> Mitar: did 3 years
02:56:26 <Beelsebob> damn fucking unary minus
02:56:36 <Beelsebob> astrolabe: there's one in haskell'
02:56:40 * jethr0_ did 4 year undergrad
02:56:49 <olliej> Mitar: +1 year for honours
02:56:52 <Mitar> hmm
02:56:58 <Mitar> we will have 3+2 probably
02:57:08 <Mitar> 3 for bac, and 2 for masters
02:57:23 <Beelsebob> Mitar: I think it really does depend on the course - I had a much better understanding of CS after 3 years than anyone at Kent does after 4 years
02:57:32 <Mitar> but they have not yet came to a solution how would they name degrees
02:57:56 <Mitar> because there will be now bachelors with 4 years and 3 years
02:58:02 <Mitar> so this could not be the same
02:58:04 <Mitar> a mess
02:58:12 <Beelsebob> Mitar: hons or not hons?
02:58:29 <jethr0_> the best course i ever had was computer algebra. with category theory, chinese remainder theorem, algebra, ...
02:58:41 <jethr0_> that was great because we had a charismatic prof
02:58:45 <olliej> jethr0_: that sounds like pain
02:59:08 <jethr0_> it was hard work and it didn't pay off at _all_. but i wouldn't miss it for the world
02:59:10 <Mitar> can you give me some good curses
02:59:16 <Mitar> i could suggest to implement
02:59:17 <Mitar> :-)
02:59:22 <Beelsebob> I think the best course I had was Semantics of Programming... aka how to do Small/Big step semantics, denotational semantics, axiomatic semantics, latice theory etc in 2 months
02:59:24 <Mitar> computer algebra sounds nice
02:59:28 <jethr0_> never have fast fourier transforms and wavelets looked so cool :)
02:59:38 <olliej> jethr0_: we had a course on design patterns in functional languages last year
02:59:59 <jethr0_> *whoa*, what did you do? functional data structures, an HOF?
03:00:45 <Mitar> do you have any good example of good 3 year curriculum?
03:01:03 <olliej> Mitar: www.cosc.canterbury.ac.nz?
03:01:36 <Beelsebob> olliej: you're at the uni of canterbury?
03:01:40 <olliej> Mitar: although actually the course has lost a few of its more worthwhile courses this year
03:01:46 <olliej> Beelsebob: yeah
03:01:47 <Beelsebob> SNAP!
03:01:52 <olliej> ?
03:02:10 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/
03:02:16 <Beelsebob> University of Kent at Canterbury :)
03:02:21 <olliej> hehe
03:04:15 <Mitar> any othere gread curses?
03:04:30 * Beelsebob wonders what a gread curse is
03:04:55 <olliej> hehe
03:04:59 <jethr0_> gread and gutter courses
03:05:02 <olliej> Mitar: at canterbury?
03:05:11 <Mitar> no no
03:05:14 <Mitar> anywhere
03:05:20 <olliej> programming language courses
03:05:21 <Mitar> ideas for good curses
03:05:24 <Mitar> :-)
03:05:31 <olliej> architecture courses
03:05:41 <jethr0_> SICP is nice, at least the book :)
03:05:42 <Beelsebob> FUN here was great
03:05:53 <Mitar> do you think undergrad should teach theory or be focused on practical things?
03:05:59 <Beelsebob> jethr0_: indeed - we basically duplicated the SICP course in our first year
03:06:05 <olliej> Mitar: i think a mix
03:06:06 <Beelsebob> Mitar: theory
03:06:11 <Beelsebob> it's an accademic degree
03:06:14 <Beelsebob> not a vocational one
03:06:15 <jethr0_> Mitar: how do you do practical things w/o theory?
03:06:24 <Beelsebob> jethr0_: badly
03:06:30 <Mitar> learn XML and php and do some pages - practical
03:06:36 <Mitar> without theory
03:06:42 <Mitar> and gets you a job
03:06:47 <jethr0_> but not very academic
03:06:51 <Mitar> (i am also for theory)
03:06:52 <olliej> jethr0_: but how do you implement theaory with no practical training
03:07:13 <jethr0_> olliej: that's a true conundrum...
03:07:15 <Mitar> but you do not get job with just theory
03:07:29 <olliej> you need a real comparative languages course
03:07:39 <Mitar> or at least no one is interested in that you know theory
03:07:40 <jethr0_> olliej: but look at how easy it is to get started with scheme or haskell. the hard part is the structured approach!
03:07:42 <Beelsebob> olliej: as an example, on my course we were *never* tought a language
03:08:06 <Beelsebob> but by the end of it we could somehow write scheme, Ada, Haskell, C, Java, C++, C--,...
03:08:20 <jethr0_> Mitar: true, but if you look at the world today, a little more theory might have done some good at places
03:08:26 <Mitar> Beelsebob: and how was that accomplished?
03:08:31 <olliej> i was "taught" java, c, haskell, and prolog
03:08:41 <Mitar> jethr0: i agree with you fully ...
03:08:53 <Beelsebob> Mitar: it was just assumed that we would absorb syntax, we were shown examples that just happened to be in real life languagegs
03:09:07 <Beelsebob> the information just gets absorbed if you're being tought the theory
03:09:09 <olliej> the big one you need though is a decent comparative languages course, basically to teach people that all imperative languages are the same
03:09:13 <jethr0_> i was taught nothing, because programming is supposedly too low a job. but i learnt almost any languages in existance anyways
03:09:15 <Beelsebob> it's just a simple specialisation
03:09:31 <jethr0_> and now i've finally ended up with the uberlanguage haskell ^_^
03:09:36 <Beelsebob> hehe
03:10:16 <jethr0_> olliej: i'm not sure that everyone would agree. do you count smalltalk and ruby to the imperative languages?
03:10:18 <Mitar> and in which year should comparative languages course be?
03:10:32 <Beelsebob> Mitar: comparative languages?
03:10:58 <Mitar> (olliej suggestion)
03:11:08 <olliej> jethr0_: tricky... all statically typed imperative languages are the same :p
03:11:10 <Beelsebob> ah, yes, I see
03:11:14 <jethr0_> Mitar: i think some basic stuff is important: grammars, complexity, computability, maths
03:11:26 <olliej> jethr0_: the important ones is teaching people that there are different ways to express things
03:11:30 <Beelsebob> jethr0_: surely that's just a compilers course
03:11:33 <pejo> Mitar, people need some code written before they could abstract and see similarities, is my guess. So a later year than first.
03:11:43 <jethr0_> olliej: tell that the java guys and the c guy when they're in the same room *g*
03:11:51 <pejo> Beelsebob, or computational theory.
03:11:58 <Saulzar> Hmm, what does ruby/smalltalk have which makes it stand out as exceptionally different from say, Java?
03:12:03 <jethr0_> Beelsebob: just from the top of my head
03:12:52 <Beelsebob> I think we'd understood that within a paradigm all languages were the same essentially by our second year
03:13:02 <jethr0_> Saulzar: compare java to smalltalk to ocaml to lisp
03:13:14 <jethr0_> i don't see a clear line of demarcation
03:14:55 <Saulzar> I guess it's just another dimension
03:15:02 <jethr0_> :)
03:15:17 <Mitar> any interesting idea how to implement the first algorithm on second page: http://www.cs.ucr.edu/~marek/TEACHING/CS150_W06/NOTES/CFG_USELESS_PRODS/useless.pdf
03:15:30 <Mitar> (in haskell)
03:15:32 <pejo> Beelsebob, how many years ago since you were in school, and do you honestly believe that all in your class had the level of understanding you're describing?
03:15:52 <jethr0_> Mitar: that wouldn't be homework, would it *G*
03:15:54 <Mitar> i think that there is better way then just transcribe it ...
03:15:56 <Mitar> no
03:16:02 <jethr0_> just kidding
03:16:19 <Beelsebob> pejo: I was at uni 2000 - 2003, and I do think most people on the course understood it as well as me
03:16:20 <Mitar> i am making it as an exercise, coverter to greibach form
03:17:22 <Mitar> i have a ([Char],[Char],[(Char,[String])],Char) grammar type
03:18:17 <Mitar> i do not like idea of "loop until does not change" - it is so unhaskell
03:19:33 <Beelsebob> mitar doWhile :: Eq a => (a -> a) -> a -> a; doWhile f x = if f x == x then x else doWhile f (f x)
03:20:07 <jethr0_> nice
03:20:12 <jethr0_> @hoogle doWHile
03:20:13 <lambdabot> No matches found
03:20:21 <jethr0_> @hoogle doWhile
03:20:22 <lambdabot> No matches found
03:20:32 <jethr0_> *pah*
03:20:32 <Beelsebob> @hoogle Eq a => (a -> a) -> a -> a
03:20:33 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
03:20:33 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
03:20:33 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
03:20:41 <Beelsebob> nope, nothing
03:21:09 <Beelsebob> actually, that's just a fixed point function
03:21:13 <jethr0_> you can do it with a fixpoint, but i'm always too stupid to figure those out
03:21:29 <Mitar> with fixpoint?
03:21:40 <Mitar> i have not learned those yet ...
03:21:50 <Beelsebob> Mitar: you're just trying to calculate the fixed point of the thing within the loop
03:21:51 <jethr0_> @hoogle fix
03:21:52 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
03:21:52 <lambdabot> Graphics.UI.ObjectIO.StdIOCommon.Fix :: ItemLoc
03:21:52 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
03:22:22 <Mitar> Beelsebob, ok and so doWhile is the only waz?
03:22:24 <Mitar> way?
03:22:36 <Beelsebob> Mitar: no, it's just one neat function for it
03:22:47 <jethr0_> no, "fix" is far nicer, but harder to figure out
03:23:16 <Mitar> ok, but this would be just transcribing the algorithm
03:23:28 <Beelsebob> jethr0_: why is it nicer?
03:23:41 <Mitar> but i do not see if it is really necessary to have dowhile structure
03:23:56 <jethr0_> Beelsebob: i like it better :!
03:24:01 <Beelsebob> Mitar: because you need to calculate a fixed point, that's what do while does
03:24:21 <Beelsebob> jethr0_: personally, I prefer the pure functional version with no monads that you can understand at a glance, but hey
03:24:55 <jethr0_> Beelsebob: it's more of an unattainable fruit effect...
03:25:05 <Beelsebob> jethr0_: hmm?
03:25:09 <Beelsebob> how do you mean?
03:26:02 <jethr0_> it's new to me and i'm struggling with it. so, it must be cooler than the old stuff, right :)
03:26:09 <Beelsebob> ah, okay
03:26:11 <Beelsebob> fair enough
03:26:29 <Mitar> Beelsebob: this doWhile is not declared in standard?
03:26:36 <Mitar> i have to decalare it manually?
03:27:09 <jethr0_> you make it sound like chores
03:27:34 <Mitar> chores?
03:28:20 <jethr0_> duties you're unhappy to perform
03:28:51 <Mitar> he he
03:29:13 <Mitar> i do not like to use in code a function which is exactly the same in core
03:29:16 <Mitar> or prelude
03:29:22 <Mitar> would be a little strange
03:31:56 <Beelsebob> mitar... do a hoogle for the type and see what it gives back... if it gives back nothing then it's not in the prelude
03:32:15 <Beelsebob> interestingly... ndm is writing something to warn you when you've re-written the prelude
03:32:29 <Beelsebob> it compares the bydecode that yhc produces, and uses that as semantic equivalence
03:32:49 <Mitar> aha, i see you already tryed that
03:35:52 <Mitar> does not in your doWhile haskell compute f x twice?
03:36:00 <Mitar> first to check if it is the fixed point
03:36:13 <Mitar> and second time to run it recursively
03:36:25 <Mitar> or does it optimize?
03:37:14 <astrolabe> @pl \x -> x-1
03:37:15 <lambdabot> subtract 1
03:38:15 <Beelsebob> Mitar: it does...
03:38:25 <Beelsebob> so probably it can be made better
03:38:56 <Mitar> doWhile f x = let x' = f x in if x' == x then x else doWhile f x'
03:39:08 <Beelsebob> fixPoint :: Eq a => (a -> a) -> a -> a; fixPoint f x = if y == x then x else fixPoint f y where y = f x
03:39:11 <Beelsebob> there you go
03:39:26 <Mitar> :-)
03:39:28 <jethr0_> @hoogle fixPoint
03:39:29 <lambdabot> No matches found
03:42:28 <astrolabe> @hoogle fix
03:42:29 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
03:42:29 <lambdabot> Graphics.UI.ObjectIO.StdIOCommon.Fix :: ItemLoc
03:42:29 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
03:43:01 <dons> when you've rewritten the prelude. hmm! very interesting.
03:43:59 <dons> ndm, hmm, or suggesting possible completions based on the expression's type, hoogle-style, would be cool.
03:44:06 <jethr0_> dons: i've got a tiny question regarding hs-plugin and eval
03:44:09 <dons> yo
03:44:22 <dons> @localtime dons
03:44:26 <lambdabot> Local time for dons is Sun Feb  5 22:43:47 2006
03:44:27 <dons> ask quick!
03:44:41 <jethr0_> in how far can eval'ed/plugin code access data structures of the running program?
03:45:05 <dons> hmm. hard... you have to pass them in
03:45:13 <jethr0_> i've seen you can pass some stuff serialized as string,
03:45:21 <dons> or have the eval code return a function that you apply to your data structures
03:45:32 <jethr0_> but it's not possible then to write a command line to alter the state of the current program.
03:45:39 <jethr0_> barring IORef evil doings?
03:46:01 <dons> unsafeCoerce# could do anything.
03:46:10 <dons> you can overwrite arbitrary locations in memory
03:46:13 <jethr0_> *yuch*
03:46:23 <dons> but otherwise, no, you can't get at stuff 
03:46:43 <dons> are you trying to enable or disable this possibility?
03:46:59 <jethr0_> so, if i had a dynamically generated data structure, even reading that would be hard, if i didn't foresee it in the interface, right?
03:47:23 <dons> yup. you'd have to plan to apply the result of the eval.
03:47:31 <jethr0_> just curious. i was thinking about writing a command line thingey for a gui of mine. but this limits the possibilites somewhat
03:48:25 <dons> what do you mean by:  dynamically generated data structure?
03:49:48 <dons> anyway, if you have, say, an editor buffer and you want to eval some code and have it modify the buffer, just eval the code to a function that you then apply to the buffer.
03:49:50 <jethr0_> never mind, i wasn't thinking straight
03:50:26 <dons> no problem. what you working on?
03:50:30 <Mitar> is there already a function which would tell if a list is a subset of another list?
03:50:50 <Mitar> or should i do if null a \\ b?
03:51:02 <jethr0_> i'm working with vincenz on last years ICFP and adding all kinds of bells and whistles :)
03:51:24 <dons> geez.. plugns to the icfp cops and robbers... cool!
03:51:25 <jethr0_> we got a nice gui, our own server, ...
03:51:34 <jethr0_> :)
03:51:54 <dons> when I worked on it, our group thought it would be cool to test different strategies with plugins somehow, but you know, time constraints..
03:52:19 <jethr0_> yup...
03:52:40 <jethr0_> it's actually quite challenging. more so than it looks at first glance
03:52:51 <jethr0_> what were your key insights into robber and cop strategy?
03:53:28 <jethr0_> i've got a nice cop sub-strategy that calculates shortest loop and lets n-1 cops tour n banks, while the others guard the rest
03:53:48 <jethr0_> and the robber is a simple shortest path search in a graph weighted with cop proximity values
03:53:59 <dons> oh, it's been a while. though our code is here: http://www.cse.unsw.edu.au/~dons/code/icfp05/
03:54:03 <jethr0_> but of course i have no idea how those would fare against any competetion
03:54:11 <jethr0_> cool
03:54:41 <dons> check the slides that summarise the contest. the best strategies are mentioned there, I think.
03:55:18 <jethr0_> i don't want to cheat too much.
03:55:27 <jethr0_> we're stretching the time limit already :)
03:55:28 <dons> doing this with infinite time is quite different to having 3 days. then it was more about unit testing and just making sure everything worked
03:55:52 <jethr0_> i see that
03:55:57 <dons> using fgl for the graph was a good idea.
03:56:02 <dons> it made things easy
03:56:05 <jethr0_> yup, i agree
03:56:20 <jethr0_> although some algos don't seem to work right.
03:56:53 <jethr0_> connected components fails on the street map. and minimum span tree gives me a data structure i don't know what to do with
03:57:08 <jethr0_> it's got like 1000s of nodes. must be ALL possible span trees or something
03:58:11 <dons> we got kind of carried away with optimising search depth, and ended up having resumable searching carried out through all phases of the clock. it was unneccessary in the end.
03:58:36 <jethr0_> btw, could you calculate when it was not your turn? i.e. with threading?
03:59:18 <dons> you got 5 seconds on each msg send until you had to do something.
03:59:47 <dons> so we calculated for 4.2 seconds on each tick, then sent a msg, then resumed searching, till wee had to make a move. and took the result of the combined 20s of searching.
04:00:22 <jethr0_> you wrote _tons_ of code!
04:00:40 <jethr0_> yup, as i thought
04:00:53 <Mitar> what is the function for swaping the order of two arguments around?
04:00:58 <Mitar> parameters
04:01:01 <jethr0_> what did you search so long for? did you search exhaustively?
04:01:02 <dons> flip?
04:01:07 <jethr0_> flip
04:01:09 <Mitar> aa
04:01:25 <dons> we have a alpha-beta game search thingy
04:01:30 <Mitar> i have (\x -> subset x v') and would like to eta reduce (without infix format)
04:01:41 <jethr0_> not bad
04:01:48 <dons> using heuristics to find the most optimal move, looking I think n=15 into the future
04:01:48 <jethr0_> although a bit boring :)
04:02:05 <jethr0_> ahh, heuristics is good
04:02:20 <jethr0_> hmm, i guess our bots haven't got a chance against that yet
04:03:37 <dons> ok, time for bed. night!
04:03:49 <jethr0_> nite
04:04:38 * jyp waves
04:04:57 <Mitar> ehm
04:05:02 <Mitar> how can i use flip?
04:05:21 <jyp> @type flip
04:05:22 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
04:05:42 <Mitar>  (\x -> subset x v') => (subset . flip $ v')
04:05:56 <jethr0_> flip (<) 3 4
04:05:58 <jethr0_> > flip (<) 3 4
04:05:59 <lambdabot> False
04:06:04 <Mitar> hmm
04:06:05 <Mitar> a
04:06:09 <Mitar> the other way around
04:06:35 <Mitar> (flip subset v')
05:03:40 <pejo> l
05:03:42 <pejo> Ups.
05:05:24 <dcoutts> dons, ping
05:05:44 <dcoutts> Lemmih, nice pics
05:06:07 <ndm> @seen vincenz
05:06:08 <lambdabot> I saw vincenz leaving #haskell 12 hours, 30 minutes and 38 seconds ago.
05:11:22 <araujo> dcoutts, hiya!
05:11:32 <dcoutts> hi araujo 
05:22:13 <davidhouse> what do i need to import to get mathematics functions like 'ceil'?
05:24:05 <dcoutts> > ceil 3.3
05:24:05 <lambdabot>  Not in scope: `ceil'
05:24:29 <Saulzar> > ceiling 3.3
05:24:30 <lambdabot> 4
05:25:03 <dcoutts> @hoogle ceil
05:25:03 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
05:25:06 <davidhouse> cheers Saulzar.
05:25:06 <dcoutts> nice
05:25:15 <Saulzar> davidhouse, you can use lambdabot/ haskell.org/hoogle to lookup such functions
05:25:25 <davidhouse> so i see :)
05:26:15 <davidhouse> @hoogle all
05:26:16 <lambdabot> Data.List.all :: (a -> Bool) -> [a] -> Bool
05:26:16 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
05:26:16 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO
05:26:16 <lambdabot> b
05:27:52 <Mitar> is it possible to construct a set like: v = union v func(v)
05:28:31 <Mitar> egh
05:28:42 <Mitar> haskell syntax: v = union v (func v)
05:28:57 <jyp> in other words, you want the fixpoint of func ?
05:29:05 <jyp> the/a
05:29:08 <Mitar> this has fixed point (resulting v) if func in some point return empty set
05:29:20 <Mitar> yes ...
05:29:22 <Mitar> exactly
05:29:33 <Mitar> does haskell know how to do this automatically?
05:29:38 <jyp> no
05:29:42 <Mitar> sad
05:29:46 <Mitar> it would be interesting feature
05:29:59 <jyp> sad indeed, but you can write a fixpoint function easily
05:30:04 <Mitar> i know
05:30:05 <Mitar> i have
05:30:06 <dcoutts> Mitar, you can iterate 'til fixpoint
05:30:15 <Mitar> i just want to know if there is some other way
05:30:48 <Mitar> just wanted to check if there is some syntax for this
05:42:04 <davidhouse> how can i tell whether an object is of a given type class?
05:42:13 <davidhouse> e.g. i want to test whether 'x' is a RealFrac
05:44:23 <Saulzar> At runtime, not sure you can?  You can specify a type constraint like: Foo :: RealFrac a => a  for example
05:44:26 <dcoutts> davidhouse, you can't
05:44:46 <dcoutts> you simply have to require it to be in the type class
05:44:50 <davidhouse> hmm... okay.
05:45:01 <davidhouse> are integers RealFracs?
05:45:24 <davidhouse> yes, they must be
05:45:37 <dcoutts> no, only Float, Double and Ratios
05:45:52 <dcoutts> -- type class
05:45:52 <dcoutts> class (Real a, Fractional a) => RealFrac a where
05:45:52 <dcoutts>   properFraction :: Integral b => a -> (b,a)
05:45:52 <dcoutts>   truncate :: Integral b => a -> b
05:45:52 <dcoutts>   round :: Integral b => a -> b
05:45:53 <dcoutts>   ceiling :: Integral b => a -> b
05:45:55 <dcoutts>   floor :: Integral b => a -> b
05:45:57 <dcoutts> -- instances:
05:45:59 <dcoutts> instance RealFrac Float
05:46:01 <dcoutts> instance RealFrac Double
05:46:03 <dcoutts> instance Integral a => RealFrac (Ratio a)
05:46:32 <dcoutts> Int is an instance of the Real class however
05:46:35 <davidhouse> @hoogle ceiling
05:46:36 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
05:46:42 <davidhouse> > ceiling 2
05:46:43 <lambdabot> 2
05:46:53 <davidhouse> doesn't that show 2 is a RealFrac?
05:47:01 <dcoutts> > ceiling (2::Float)
05:47:03 <lambdabot> 2
05:47:06 <dcoutts> > ceiling (2::Int)
05:47:07 <lambdabot>  add an instance declaration for (RealFrac Int)
05:47:07 <lambdabot>   In the definition of `qcn': qcn = ceiling (2 :: Int)
05:47:07 <lambdabot>   In the definition of `v':
05:47:11 <dcoutts> nope
05:47:25 <davidhouse> okay. so when i say ceiling 2, it treats 2 as a float? hmm...
05:47:36 <dcoutts> @type 2
05:47:36 <lambdabot> forall t. (Num t) => t
05:47:42 <dcoutts> see, any Num
05:47:48 <SamB> @type ceiling
05:47:49 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:48:44 <SamB> it treats it as a member of RealFrac, and defaults it to Float or Double if the type is ambiguous
05:48:59 <davidhouse> what's the difference between float and double?
05:49:14 <SamB> about the same as in C
05:49:20 <dcoutts> floating point precision
05:49:42 <davidhouse> okay.
05:49:50 <SamB> that is, Float is typically IEEE single precision, and Double typically IEEE double precision
05:50:18 <SamB> I think hugs uses the same format for both, though
05:51:17 <davidhouse> okay, well i can't figure this out then:
05:51:28 <davidhouse> i'm trying to write a function to tell whether a given number is prime or not.
05:51:48 <davidhouse> at the moment it looks like this: let isPrime x = (all (\y -> x `mod` y /= 0) [2..ceiling(x/2)])
05:52:13 <SamB> ah
05:52:24 <SamB> replace ceiling(x/2) by x `div` 2
05:52:24 <davidhouse> :t isPrime is (RealFrac b, Integral b) => b -> Bool
05:52:43 <SamB> @type (/)
05:52:44 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:52:47 <SamB> @type div
05:52:48 <lambdabot> forall a. (Integral a) => a -> a -> a
05:53:22 <ndm> div rounds, down, ceiling rounds up
05:53:39 <ndm> hence it would need to be (x `div` 2)+1 - to be sure you covered greater range
05:54:05 <davidhouse> well, actually rounding down suffices, i think.
05:54:17 <ndm> of course, takeWhile (\i -> i * i < x) [2..] would be better
05:54:42 <ndm> actually, that should be <=
05:55:03 <davidhouse> very true.
05:56:43 <davidhouse> any reason to use i * i instead of i^2?
05:57:29 <tromp> matter of taste
05:57:41 <ndm> davidhouse: have you seen the definitino of ^?
05:57:42 <EdLin> davidhouse: I'd think the latter would avoid looking up the variable, it would know "2" is a constant
05:57:53 <ndm> (^)            :: (Num a, Integral b) => a -> b -> a
05:57:55 <ndm> x ^ 0           = 1
05:57:56 <ndm> x ^ n  | n > 0  = f x (n-1) x
05:57:58 <ndm> 		  where f _ 0 y = y
05:57:59 <ndm> 			f x n y = g x n where
05:58:01 <ndm> 				  g x n | even n    = g (x*x) (n`quot`2)
05:58:02 <ndm> 					| otherwise = f x (n-1) (x*y)
05:58:04 <ndm> _ ^ _           = error "Prelude.^: negative exponent"
05:58:05 <ndm> (^^)           :: (Fractional a, Integral b) => a -> b -> a
05:58:07 <ndm> x ^^ n          = if n >= 0 then x ^ n else recip (x^(-n))
05:58:17 <ndm> it basically expands to x*x, but a lot slower
05:58:37 * EdLin blushes
05:58:39 <davidhouse> ah. thanks.
05:59:11 <tromp> choose the one you think is clearer
05:59:28 <tromp> more important than a few cycles
06:00:59 <ndm> true, i wouldn't be surprised if GHC optimised them to the same thing anyway
06:01:31 <ndm> although another strategy might be to calculate sqrt x, and compare to that without a multiple
06:01:45 <ndm> essentially perform a more expensive operation (sqrt), but only once
06:15:58 <ndm> does anyone here use WinHugs?
06:18:58 <MarcWeber> Do you have any hints to track down why a Makefile would try to execute /bin/sh <ghc> which obviously doesn't work?  sh -c ghc might work.
06:23:37 <musasabi> How does YHC plan to solve C source files in a cabal library package?
06:24:01 <dcoutts> musasabi, it probably can't
06:24:21 <musasabi> hmm, so no easy solution from there.
06:24:40 <vincenz> @yow
06:24:40 <lambdabot> My mind is a potato field ...
06:25:33 <musasabi> jhc could either compile them with gcc and add objects to the library or just keep the c-sources around.
06:25:34 <dcoutts> musasabi, the best that could be done I expect is to build the C files into their own .o/.so and link them in at runtime. So the .c files would need to be compiled on each platform.
06:28:10 <vincenz> what's better? happy or parsec?
06:28:31 <tibbe> vincenz, I like happy
06:28:56 <norpan> it all depends on what you want
06:29:22 <vincenz> to write a c-parser (possibly c++)
06:29:51 <norpan> i'd say parsec
06:29:53 <musasabi> vincenz: why not use the c2hs one ?
06:29:54 <norpan> it's more haskell
06:30:02 <vincenz> musasabi: what does it get you?
06:30:13 <musasabi> vincenz: much of the work already done.
06:30:28 <musasabi> it is quite efficient.
06:30:34 <vincenz> musasabi: I mean what can you get acecss to?
06:31:44 <musasabi> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
06:31:46 <dcoutts> vincenz, the c2hs parser give you back an AST
06:31:59 * dcoutts wrote the c2hs C lexer/parser
06:32:15 <vincenz> but header file only?
06:32:19 <vincenz> or all c?
06:32:21 <dcoutts> no, the whole lot
06:32:24 <vincenz> the website is minimal on info
06:32:36 <vincenz> dcoutts: how do you represent variables?
06:33:06 <dcoutts> http://www.cse.unsw.edu.au/~chak/repos/c2hs/c2hs/c/
06:33:31 <vincenz> thx
06:33:51 <vincenz> what toolkit does it use?
06:33:55 <vincenz> cause I notice a .y file
06:34:23 <norpan> but that's just for c header files
06:34:34 <vincenz> that's what I thought as well
06:34:50 <dcoutts> data Ident = Ident String	-- lexeme
06:34:50 <dcoutts> 		   Int		-- ambiguousness resolving number
06:34:50 <dcoutts> 		   Int		-- id. number to speed up equality check
06:34:50 <dcoutts> 		   Attrs    	-- attributes of this ident. incl. position
06:34:52 <norpan> or isn't it?
06:35:03 <dcoutts> norpan, the c2hs C parser doe all of C
06:35:20 * dcoutts should know
06:35:26 <norpan> if you say so
06:35:45 <dcoutts> take a look at the grammar & AST if you're sceptical
06:36:00 <dcoutts> header files can contain inline funcs, so we need all of C anyway
06:36:15 <vincenz> damn
06:36:20 <dcoutts> vincenz, it uses alex for the lexer and happy for the parser
06:36:31 <vincenz> that codes is rather extensive
06:36:34 <vincenz> if I see how posoF is done
06:36:39 <dcoutts> C is complex
06:36:53 <vincenz> right but isn't there a more succint way of doing that?
06:37:19 <dcoutts> I agree, I don't like the posOf stuff either, I inherited that
06:37:28 <vincenz> possibly: CToken = CToken CtokenType Position
06:37:33 <dcoutts> indeed
06:37:46 <dcoutts> I just re-wrote the lexer & parser, I didn't change the AST
06:37:51 <vincenz> possibly: CToken = CToken {tokentype::CtokenType, posof:: Position}
06:38:01 <dcoutts> vincenz, rip out the AST if you like
06:38:04 <vincenz> nah
06:38:07 <vincenz> it's done
06:38:14 <vincenz> don't fix it if it works
06:38:16 <vincenz> :)
06:38:32 <vincenz> what kind of parsers doe shappy generate?
06:38:37 <vincenz> lR(1)?
06:38:48 <dcoutts> no, C is no LALR(1)
06:38:52 * vincenz is on someone else's laptop....
06:38:56 <vincenz> I meant HAPPY
06:39:07 <vincenz> C is LALR(1) with context, I thought
06:39:30 <vincenz> the one I'm worried about is c++
06:39:35 <dcoutts> yeah, with the context dependency
06:39:38 <vincenz> afaik, the only people that did it is with gLR
06:39:59 <vincenz> which is LR with ambiguous trees that get removed at later passes (namely typechecking)
06:40:21 <vincenz> so what kind ofparsers does happy give?
06:40:25 <dcoutts> actually, there's still a bug in the c2hs parser in it's treatment of typedef'ed identifiers
06:40:33 <dcoutts> happy does LALR(1)
06:40:47 <vincenz> hmm
06:40:52 <vincenz> :/
06:41:01 <dcoutts> but you can extend that my using a monadic lexer, that's how I do the C context dependnecy
06:41:06 <ndm> vincenz: ping
06:41:08 <vincenz> pong
06:41:18 <dcoutts> vincenz, if you can help me fix it, I'd be most pleased
06:41:24 <ndm> i wrote hoogle, you submitted a but report in hihoo
06:41:27 <vincenz> dcoutts: i'll take a look at it
06:41:39 <vincenz> ndm: yes indeed
06:41:47 <musasabi> Now who wants to write the C->Haskell compiler? ;)
06:41:52 <dcoutts> vincenz, it's to do with a typedefed name being re-used as a variable name.
06:41:53 <ndm> i didn't actually write hihoo, and its currently unmaintained
06:42:03 <ndm> hadhtml is the recommended way to go with generating data files
06:42:03 <vincenz> ndm: ah, ok :)
06:42:13 <vincenz> dcoutts: yick
06:42:20 <ndm> if you find a bug in that, i stand a better chance of fixing it
06:42:30 <vincenz> musasabi: I'm actually working on imperative -> functional for a more restricteddomain
06:42:40 <vincenz> ndm: problem is that some libs don't come with haddokcs
06:42:54 <dcoutts> vincenz, so in one place in the grammar I don't allow a typedefned name and an ordinary name where I ought to. I only allow one of them. If I allow both I get lots of shift/reduce & reduce/reduce conflicts.
06:43:06 <vincenz> dcoutts: oh, so you reject more... not accept more
06:43:11 <dcoutts> vincenz, yes
06:43:14 <vincenz> good
06:43:19 <vincenz> at least you won't generate crap :)
06:43:23 <vincenz> better reject early than get bugs
06:43:40 <dcoutts> vincenz, I tried to partition the grammar in the same way as the gcc one does, but couldn't get it to work without shift/reduce conflicts.
06:43:41 <vincenz> pity that happy is only lalr
06:43:42 <musasabi> vincenz: I am mostly thinking of a dumb solution allowing one to take a small C source and automatically getting a pure-haskell (which uses Foreign.*) counterpart.
06:44:18 <vincenz> dcoutts: did you use the multiple excesisve rules it uses to not have to do operator precednece?
06:44:24 <vincenz> and do you remove those form the AST ?
06:44:27 <ndm> vincenz: i know, but its not usually that hard to generate happy documentation. hihoo would be a better solutino if it worked, but i don't know perl so can't fix it (patches very welcome!)
06:44:36 <ndm> * happy -> haddock
06:45:16 <vincenz> ndm: rewrite to haskell of hihoo?
06:45:36 <ndm> vincenz: i don't have the time, but i'd certainly welcome that
06:45:46 <vincenz> alright
06:46:02 <ndm> but renamed as hshihoo, since its quite easy to have multiple data input tools
06:46:13 <ndm> and it seems a shame to throw away the original
06:46:17 <vincenz> ndm: what do you work on currently?
06:46:37 <ndm> vincenz: lots! http://www-users.cs.york.ac.uk/~ndm/
06:46:38 <vincenz> dcoutts: ping about the excessive parse rules in c to not do operator precedence?
06:46:48 <ndm> currently CATCH and Yhc
06:46:54 <ndm> but I hope to get back to hoogle quite soonish
06:47:51 <vincenz> :)
06:48:16 * vincenz oughta make his own webpage, but i'm not certain that the company I do my phd at would like me distributing sources :(
06:48:35 <dcoutts> vincenz, for the operator rules, yeah you could probably do it with happy precedence rules, but I was trying to follow as closely to the C spec as possible.
06:48:43 <ndm> thats the good thing about being at a uni, they pretty much don't mind anything
06:49:00 <vincenz> dcoutts: right ,so do you remove thos superfluous states from the AST?
06:49:08 <dcoutts> vincenz, I was recently trying to update it to match the C99 spec if that mgiht be of use to you.
06:49:11 <dcoutts> vincenz, huh?
06:49:36 <vincenz> multiplicative expression -> additive expression -> constant expression -> constant 1
06:49:39 <vincenz> once you've done parsing
06:49:43 <vincenz> you can flatten the expression space
06:49:49 <vincenz> so you don't have to go so deep when doing reasoning
06:49:49 <dcoutts> vincenz, oh I see, yes the AST doesn't have that in
06:50:11 <dcoutts> see http://www.cse.unsw.edu.au/~chak/repos/c2hs/c2hs/c/CAST.hs
06:50:13 <vincenz> but for the rest the AST is close to the parsetree?
06:50:23 <dcoutts> pretty close
06:50:27 <vincenz> cool
06:50:27 <tromp> p
06:50:48 <vincenz> Idents = std haskell?
06:51:09 <dcoutts> vincenz, there are some bits we ignore, like asm statements and most of gcc's attributes
06:51:24 <dcoutts> ie we parse them but don't enter them into the AST
06:51:25 * vincenz nods
06:51:31 <vincenz> I can live with that :)
06:51:44 <dcoutts> or you can extend the ast if you care
06:51:54 <dcoutts> eg you can then make pure functions
06:52:05 <vincenz> instance Eq CStat where
06:52:13 <vincenz> you don't have a _ == _ = False
06:52:40 * vincenz has to go
06:52:46 <vincenz> bbtn
06:52:49 <dcoutts> vincenz, good point, that was probably never used
06:52:59 * vincenz is at family, going to visit the grannies now
06:53:00 <vincenz> cya
06:53:03 <dcoutts> bye
06:53:04 <vincenz> be back tonight
07:00:08 <SimonRC> hi
07:02:26 <JohnMeacham> dcoutts: well, the best would be to reimplement everything in haskell, if the ForeginData proposal gets added then we can finally say "haskell can do everything C can do but better"
07:03:09 <dcoutts> JohnMeacham, :-)
07:03:25 <dcoutts> so automatic C->HS translation, not just binding :-)
07:04:11 <dcoutts> well when vincenz gets it working, I'll use it on Gtk+ :-)
07:08:21 <jtza8> What course of action would be recommended for a newbe like me that is not fimilliar with functional programming but would like to learn Haskell through playing with it?
07:09:40 <essiene> jtza8, do like me (i started last week), grab a copy of yet another haskell tutorial, and go play :)
07:09:48 <essiene> @google yet another haskell tutorial
07:09:49 <lambdabot> http://www.isi.edu/~hdaume/htut/
07:10:11 <jtza8> essiene: Thank you.
07:10:26 <essiene> jtza8, so far... my brain is spinning with the paradigm shift... but its worth it :)
07:10:32 <essiene> yw
07:13:17 <jtza8> Yes, I got shocked by what lisp could do, found out that alot of it was due to functional programming and so found haskell that was described as idealistic which told me that it was the right language to learn if you want to know about functional programming. :) I talk too much, don't I?
07:13:49 <SimonRC> jtza8: nah
07:13:50 <essiene> jtza8, hehe... not nearly as much as i do ;)
07:21:30 <davidhouse> jtza8, have you looked at functional programming before?
07:26:20 <SimonRC> hi
07:29:36 <Pupeno> Hello.
07:30:54 <essiene> jtza8, you probably want to read this article: http://www.haskell.org/haskellwiki/Why_Haskell_Matters
07:31:50 <Pupeno> If I want to play with a language of my own, I should write an interpreter, righ ? because that's easier than writting a compiler, right ?
07:32:11 <essiene> jtza8, i read quite a lot of these "borderline" articles to *set my mind* first... sort of like skinny dipping in winter... you need to splash some water on first... ;)
07:33:04 <edwinb> Pupeno: what kind of language is it? Some kind of interpreter or evaluator is almost certainly easier
07:33:26 <Pupeno> edwinb: a smalltalk-like language.
07:33:50 <SimonRC> yeah, 'terp
07:34:00 <edwinb> It's usually best to worry about making the language go first.
07:34:06 <edwinb> You can make it go fast later.
07:34:12 <SimonRC> indeed
07:34:37 <Pupeno> that's what I though, if it sucks, no matter how fast it is, it'll suck (kinda reminds me of C)
07:35:39 <_Codex> Making a good language is unbelievably difficult.
07:36:03 <Pupeno> anyway, tring to find books to learn this 'craft', I find many on compilers and none on interpreters, why is that ? is writting an iterpreter a subset of writting a compiler ? and then, by reading a book about compilers I'll get the knoweldge I need ?
07:37:22 <edwinb> An interpreter would often execute an intermediate byte code type language
07:37:31 <edwinb> which you'd compile to. The distinction is somewhat blurred.
07:38:17 <edwinb> For experimental purposes, some kind of evaluator on the parse tree might be fine.
07:42:22 <SimonRC> yup
07:43:33 * SimonRC realises another good point of Haskell: all the thinking you have to do to simply write a program that compiles is *instead* of having to debug it so much afterwards
07:44:56 <_Codex> simonrc: even haskell program can work oddly :)
07:45:27 <edwinb> At least they don't segfault.
07:45:32 <edwinb> Unless you're doing really odd stuff.
07:46:03 <ndm> SimonRC: and debugging a haskell program is often harder than debugging a C one, esp if you have Visual Studio's debugger
07:46:12 <_Codex> pattern matching can cause runtime errors, much like segfaults :)
07:46:37 <edwinb> I don't completely agree with that. The class of bug you get in a Haskell program is usually much harder to track down than the class you can solve with Visual Studio
07:46:41 <ndm> _Codex: bug usually with "i failed on line ...", which makes them a bit easier to track down
07:47:10 <_Codex> ndm: that's what segfaults do, you get a call stack :)
07:47:14 <Pupeno> any recomended book on compilers/interpreters ?
07:47:19 <edwinb> I used to use the VS debugger a lot when I had to do C++ programming, but I don't miss it at all now.
07:47:29 <ndm> edwinb: i disagree, visual studio makes most C bugs relatively shallow, while most haskell bugs are quite hard
07:47:37 <ndm> i really do miss a good debugger
07:47:52 <edwinb> That's because you're writing different kinds of programs in Haskell usually.
07:48:15 <edwinb> Most of my C++ bugs were memory management issues, rather than logical stuff.
07:48:17 <edwinb> YMMV
07:49:18 <ndm> true, haskell programs are usually cleverer
07:49:36 <ndm> but while you can examine how an algorithm works with C++, there is no way with Haskell
07:49:52 <ndm> (well, apart from reading the source)
07:49:56 <edwinb> I find "trace" perfectly adequate for that.
07:50:08 <ndm> the problem with trace is that it can alter the behaviour of your program
07:50:24 <ndm> and you need to know what to trace before you can detect the bug
07:50:35 <edwinb> I have never had such problems.
07:50:39 <ndm> take for example a non-termination caused by a non-transitive equality
07:50:46 <edwinb> Sometimes I have to force an evaluation, though.
07:50:51 <ndm> in C++ you hit pause, see the call stack, and its obvious
07:50:54 <xerox> Needing particular tools to examine a source is partial sign of poor expressivity.
07:51:09 <ndm> in haskell you spend 3 hours with your friend debugging it, wondering what is going wrong
07:51:17 <SimonRC> Instead of VS, haskell has interpreters.
07:51:19 <ndm> (and that really happened!)
07:51:38 <SimonRC> It is tricky to just "test out" function calls in C++.
07:51:54 <ndm> oh, true - haskell is a lot better - but still no debugger
07:52:53 <edwinb> I suspect the kind of debugger you want is close to impossible.
07:53:41 <SimonRC> I think it should be possible to write a Haskell debugger that allows you to evaluate a function in bits:  you click on a function application and it performed, or, you ight click and select "deep eval" and all subexpressions are performed.
07:53:56 <edwinb> I wonder how Hat development is getting on.
07:54:11 <SimonRC> dunno if that would be any use for Real World debugging, though.
07:56:52 <ndm> edwinb: a Hat trace creator is being integrated into Yhc
07:57:03 <ndm> that may "answer" all the debugging needs of everyone
07:57:13 <ndm> its a few weeks away from being done, but not that far off
08:00:01 <SimonRC> hi
08:00:05 <edwinb> Hmm, nice.
08:32:30 <tibbe> is cons left or right associative?
08:32:45 <tibbe> right right?
08:34:27 <musasabi> Think about ((1:2):[]) or (1:(2:[])) and about the types.
08:34:53 <tibbe> @type ((1:2):[])
08:34:54 <lambdabot> forall a. (Num a, Num [a]) => [[a]]
08:35:21 <tibbe> @type (1:(2:[]))
08:35:22 <lambdabot> forall a. (Num a) => [a]
08:42:31 <palomer> does Ord assume a total order?
08:42:44 <palomer> or, rather, do functions using Ord assume a total order
08:43:10 <kevind> yes
08:43:13 <palomer> darn
08:43:35 <palomer> is there a portial ordering typeclass?
08:44:15 <kevind> you could use Ord but be careful with it, there is no check that you have defined a total order
08:44:29 <palomer> max would be hard to implement
08:44:33 <kevind> just don't use it with things expecting a total order
08:44:49 <kevind> ah, yes
08:46:04 <palomer> ie impossible to implement:o
08:48:19 <Mitar> i have two strings, for example "BACABBA" and "B" and would like to get a list of all possible combinations of a first string when any combination of characters from second string is removed from first
08:48:21 <Mitar> any idea?
08:48:43 <eckhart> hi
08:49:23 <palomer> TotalOrder should be a subclass of PartialOrder
08:49:31 <musasabi> Mitar: is this homework?
08:49:38 <Mitar> no
08:49:40 <Mitar> :-))
08:50:10 <eckhart> in haskell, i can write: (+) 1 1
08:50:31 <eckhart> is there a way to write a+2*b the same way
08:50:34 <Lokadin> ha i remmber they ask me the same thinng all the time :P
08:50:37 <Lokadin> :D
08:50:38 <musasabi> well get the set of all substrings of the second string.
08:50:51 <kevind> (+) a ((*) 2 b)
08:50:52 <Lokadin> well no, once a year and a half ago
08:51:12 <eckhart> kevind: no, not exactly
08:51:14 <musasabi> and then for each of them all possiblities of them being removed from the first string.
08:51:58 <kevind> then what do you mean?
08:52:03 <eckhart> i want to use this function that takes a and b and return a+c*b as argument for another function
08:52:10 <Mitar> hmm
08:52:58 <eckhart> in fact i could write: (myfunc) a b where myfunc x y = x + 2 * y
08:53:03 <musasabi> eckhart: like (\a b -> a + 2*b )
08:53:34 <musasabi> @pointless (\a b -> a + 2*b )
08:53:35 <lambdabot> (. (2 *)) . (+)
08:53:52 <eckhart> musasabi: yes, exactly
08:54:14 <musasabi> I prefer the form with the arguments, the pointless one is not very readable.
08:54:36 <eckhart> thanks for the answer :-)
08:55:53 <davidhouse> musasabi: what's that first period inside the first bracket doing? function composition with nothing?
08:56:22 <resiak> It's a section of a function composition, no?
08:56:33 <musasabi> yes.
08:57:44 <musasabi> davidhouse: Think about (2 +) and (+ 2). Now just add (. someFunction)
08:58:36 <Mitar> but it does not good, i need to remove all possible combinations of letter in first string
08:59:25 <Mitar> for example, if i have "ABAB" and "B" then i would have to get "ABAB", "AAB", "ABA", "AA
08:59:26 <Mitar> "
08:59:45 <palomer> @type .
08:59:46 <lambdabot> parse error on input `.'
08:59:49 <palomer> @type (.)
08:59:50 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
09:00:01 <davidhouse> musasabi, aha.
09:00:03 <palomer> we should all switch to japanese
09:00:06 <palomer> so the verb comes at the end
09:00:08 <palomer> who's with me?
09:00:23 <davidhouse> palomer, that life complicated make would.
09:00:40 <palomer> davidhouse: but application would be from the right!
09:00:41 <musasabi> complicated not bad is.
09:00:56 <palomer> crazy you all are
09:00:57 <davidhouse> german has the verb at the end after some conjunctions
09:01:03 <davidhouse> like yoda we sound.
09:01:07 <palomer> yes, but german sounds awful
09:03:52 <SimonRC> Mitar: I recommend using list as a monad: ...
09:06:21 <palomer> function application should soooo be from the right!
09:07:25 <SimonRC> foo (x:xs) = case x of 'B' -> (do ys <- foo xs ; yy <- ['B':ys,ys] ; return yy) ; _ -> return (x : foo xs)
09:07:27 <tromp> you want x f to be f applied to x?
09:07:31 <SimonRC> I think that's right
09:07:46 <palomer> tromp: yes
09:18:40 <JKnecht> Seperable verbs and phrase stacking in Hochdeutsch gefaelt mich. It's synthetic nature is refreshing after the over the top analyticality of English.
09:18:57 <ihope> @index Natural
09:18:57 <lambdabot> bzzt
09:19:00 <ihope> Hmm.
09:19:44 <davidhouse> JKnecht: isn't it vers and phrase stacking in Hochdeutsch gefallen mir?
09:20:01 <ihope> > signum (-1)
09:20:02 <lambdabot> -1
09:20:05 <ihope> > signum 3
09:20:06 <lambdabot> 1
09:20:07 <ihope> > signum 0
09:20:08 <lambdabot> 0
09:20:28 <ihope> @type signum (-2 :: Integer)
09:20:29 <lambdabot> Integer
09:20:31 <davidhouse> anyway, a question:
09:20:38 <ihope> @type signum (-2 :: Double)
09:20:39 <lambdabot> Double
09:22:19 <davidhouse> my book says this: http://pastebin.com/540291
09:22:23 <davidhouse> what does that 'id' mean?
09:22:34 <ihope> id is the identity function.
09:22:40 <ihope> It returns whatever is passed to it.
09:22:59 <davidhouse> ah.
09:23:03 <davidhouse> okay, makes sense.
09:23:09 * JKnecht was referring to seperable verbs and sentence structure as a single object, the architectonic of teutonic speech if you like.
09:23:44 <davidhouse> JKnecht: but it should still be mir not mich right? (i'm only studying german, so i might be wrong)
09:23:46 <ihope> Is defining Show enough for a type to be an instance of Show?
09:24:14 <JKnecht> yes thinks so, reflexive/dative.
09:25:05 <JKnecht> s/thinks/think/
09:25:57 <davidhouse> okay :)
09:32:29 <ihope> Yay! Natural numbers!
09:32:46 <ihope> @index Zero
09:32:47 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment, Graphics.Rendering.OpenGL.GL,
09:32:47 <lambdabot> Graphics.Rendering.OpenGL, Graphics.UI.GLUT
09:32:51 <ihope> @index Succ
09:32:51 <lambdabot> bzzt
09:33:42 <ihope> I can do stuff like Succ 3 and get 4 >:-)
09:33:58 <_Codex> T ==0==> N ==succ==> N. :)
09:34:27 <ihope> Yes, exactly. Now what does that mean?
09:34:28 <ihope> :-)
09:34:39 <ihope> s/)/P/
09:35:46 <ihope> Whoops. Houston, we are havink problem...
09:35:48 <davidhouse> @pointless (\x -> ((/=0) . mod x))
09:35:48 <lambdabot> ((0 /=) .) . mod
09:36:30 <ihope> Okay. Succ x + y = ?
09:36:47 <ihope> y + x * y, aye?
09:37:21 <_Codex> more likely (x+1) + y?
09:37:27 <ihope> So how come, say, Succ 3 * 4 turns up 0?
09:38:01 <davidhouse> > Succ 3 * 4
09:38:01 <lambdabot>  Not in scope: data constructor `Succ'
09:38:13 <ihope> data Natural = Zero | Succ Natural
09:38:21 <ihope> Zero   * _            = Zero
09:38:26 <ihope> _      * Zero         = Zero
09:38:33 <ihope> Succ x * y            = y + x * y
09:38:48 <_Codex> oh.
09:39:02 <_Codex> that's different from what I thought
09:40:16 <ihope> Do you know why it's not working?
09:41:00 <ihope> Succ 3 = 4, so 4 * 4
09:41:51 <ihope> 4 * 4 = 4 + 3 * 4 = 4 + 4 + 2 * 4 = 4 + 4 + 4 + 1 * 4 = 4 + 4 + 4 + 4 + 0 * 4 = 4 + 4 + 4 + 4
09:43:17 <ihope> Weird. /me grabs an unsafe IO function
09:43:36 <Cale> ihope: can I see your whole module?
09:43:45 * ihope pastebins
09:44:33 <ihope> http://pastebin.com/540322
09:45:18 <edwinb> x+Zero = Zero ????
09:45:29 <Cale> er, yeah
09:45:30 <ihope> Heh. That's it!
09:45:32 <ihope> Thanks.
09:45:33 <Cale> that's not right :)
09:45:43 <_Codex> x+zero = zero? :)
09:46:00 <ihope> Yay, it works!
09:47:40 <Cale> you should only need 2 rules for +. I usually use Zero + x = x, and (Succ x) + y = Succ (x + y)
09:48:01 <ihope> I know.
09:48:30 <ihope> Just hoping to add a bit of minor optimization.
09:49:15 <ihope> To avoid stuff like 10 * 0 = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 too :-)
09:49:39 <Cale> :)
09:49:56 <davidhouse> how useful is eta-reduction in real life?
09:50:07 <davidhouse> it's very elegant and all, but it's about as readable as a pineapple.
09:50:09 <Cale> davidhouse: plenty useful :)
09:50:22 <Cale> davidhouse: It's not always bad.
09:50:31 <davidhouse> Cale, could you exemplify?
09:50:35 <ihope> @pl \x y -
09:50:36 <lambdabot> (line 1, column 6):
09:50:36 <lambdabot> unexpected end of input
09:50:36 <lambdabot> expecting "->"
09:50:39 <ihope> @pl \x y -> x y
09:50:39 <lambdabot> id
09:51:05 <Cale> I think  not . null is better looking than \x -> not (null x)
09:51:06 <Cale> filter (> 0)
09:51:06 <edwinb> map fst xs is more readable than map (\x -> fst x) xs ...
09:51:44 <davidhouse> okay, fair enough
09:51:54 <palomer> http://www.rafb.net/paste/results/bOXHhS89.html <--does this completely encode pairs?
09:51:59 <Cale> map f = foldr ((:) . f) []
09:52:04 <edwinb> @pl \a b c -> a*b+2+c
09:52:04 <lambdabot> ((+) .) . flip flip 2 . ((+) .) . (*)
09:52:07 <Cale> that one is rather nice, I think :)
09:52:08 <edwinb> that sort of thing is bad ;)
09:52:23 <ihope> palomer: I think so
09:52:27 <Cale> Points-free is better when you're thinking about the manipulation of functions
09:52:48 <ihope> @djinn (a -> b) -> a -> b
09:52:48 <Cale> rather than the points on which they act
09:52:48 <lambdabot> f a = a
09:53:04 <davidhouse> @help
09:53:04 <lambdabot>  @help <command> - ask for help for <command>
09:53:09 <davidhouse> @help djinn
09:53:09 <lambdabot> Generates Haskell code from a type.
09:53:09 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
09:53:18 <Cale> @. pl djinn (a -> b) -> a -> b
09:53:19 <lambdabot> f = id
09:53:27 <davidhouse> @help pl
09:53:27 <lambdabot>  @pointless <expr> - play with pointfree code
09:53:33 <davidhouse> ah.
09:53:44 <ihope> It looks imperative. Imperative code is, put simply, better than functional in some cases.
09:53:51 <palomer> of course
09:54:05 <palomer> you didn't actually think that functional code is the best, did you?
09:54:06 <ihope> That's the whole reason for using CPS, aye?
09:54:42 <Cale> well, looking imperative is better than looking functional in some cases :)
09:54:56 <ihope> :-)
09:55:20 <neologism> @. pl djinn (a -> b) -> c -> d
09:55:20 <lambdabot> (line 1, column 1):
09:55:20 <lambdabot> unexpected "-"
09:55:20 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
09:55:20 <lambdabot> expression
09:55:28 <ihope> Um.
09:55:31 <Cale> @djinn (a -> b) -> c -> d
09:55:32 <lambdabot> -- f cannot be realized.
09:55:40 <ihope> @pl -- f cannot be realized.
09:55:41 <lambdabot> (line 1, column 1):
09:55:41 <lambdabot> unexpected "-"
09:55:41 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
09:55:41 <lambdabot> expression
09:55:43 <ihope> :-)
09:56:05 <palomer> what's the alternative GADT syntax with kinds?
09:57:18 <neologism> @djinn (a -> b) -> c -> b
09:57:19 <lambdabot> -- f cannot be realized.
09:57:33 <neologism> @djinn (a -> b) -> b
09:57:33 <lambdabot> -- f cannot be realized.
09:57:41 <neologism> doest that work at all?
09:57:52 <Cale`> hm?
09:57:54 <ihope> @djinn a -> (a -> b) -> b
09:57:55 <lambdabot> f a b = b a
09:58:17 <ihope> @. pl djinn a -> (a -> b) -> b
09:58:18 <lambdabot> f = flip id
09:58:28 <ihope> @pl (Cont . flip id)
09:58:29 <lambdabot> Cont . flip id
09:58:33 <ihope> Eh.
09:58:40 <ihope> Cont . flip id = return
09:58:59 <Cale> ihope: not necessarily
09:59:11 <ihope> Cale: when's it not true?
09:59:17 <Cale> I suppose when restricted to the same type :)
09:59:40 <Cale> though I don't think @pl knows about Cont at all
10:00:04 <ihope> Cont . flip id = return `asTypeOf` (Cont . flip id)
10:00:05 <ihope> :-P
10:00:22 <palomer> main = do{let x = foo; bar} <--how do I force foo to evaluate?
10:00:37 <Cale> palomer: Control.Exception.evaluate
10:00:47 <Cale> (or use x somewhere
10:00:51 <Cale> )
10:00:57 <palomer> I can't use x anywhere
10:00:58 <ihope> main = do {x <- foo; bar}?
10:01:07 <palomer> foo isn't of type IO
10:01:13 <palomer> or, rather, IO x for some x
10:01:45 <ihope> seq foo (do {let x = foo; bar})?
10:01:46 <palomer> how do you derive with a GADT?
10:02:00 <palomer> @hoogle seq
10:02:00 <_Codex> @djinn (a->b)->(b->c)->a->c
10:02:00 <lambdabot> Control.Parallel.seq :: a -> b -> b
10:02:00 <lambdabot> Prelude.seq :: a -> b -> b
10:02:00 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
10:02:01 <lambdabot> f a b c = b (a c)
10:02:26 <palomer> does seq actually evaluate?
10:02:35 <ihope> palomer: yeah, something like that
10:02:38 <ihope> > seq undefined 3
10:02:39 <lambdabot> Undefined
10:02:44 <palomer> oh, nice
10:02:53 <ihope> > seq (error "foo") (error "bar")
10:02:54 <lambdabot> Add a type signature
10:02:57 <ihope> > seq (error "foo") (error "bar") :: ()
10:02:58 <lambdabot> Exception: foo
10:03:01 <Cale> yeah, it forces its left parameter to evaluate up to the top-level constructor before returning its right parameter
10:03:36 <ihope> Ah. So that's why (seq [1..] 3) returns.
10:03:45 <Cale> In a similar vein, we have  f $! x = x `seq` f x
10:04:17 <ihope> > seq [error "foo"] [error "bar"] :: [()]
10:04:18 <lambdabot> Exception: bar
10:04:19 <Cale> ihope: yeah, that only evaluates to 1 : enumFrom 2
10:04:45 <ihope> Is there any full evaluation thingy?
10:05:04 <Cale> Control.Parallel.Strategies includes some
10:05:07 <SimonRC> @type deepSeq
10:05:07 <lambdabot> Not in scope: `deepSeq'
10:05:11 <Cale> but not in general
10:05:13 <SimonRC> @hoogle deepSeq
10:05:13 <lambdabot> No matches found
10:05:16 <Cale> deepSeq is a common library
10:05:19 <SimonRC> @hoogle seq
10:05:19 <lambdabot> Control.Parallel.seq :: a -> b -> b
10:05:19 <lambdabot> Prelude.seq :: a -> b -> b
10:05:19 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
10:05:40 <Cale> though equivalent functionality already is in GHC, it's just not so well-known
10:05:48 <Cale> @hoogle rnf
10:05:49 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
10:06:00 <Cale> @hoogle using
10:06:00 <lambdabot> Control.Parallel.Strategies.using :: a -> Strategy a -> a
10:06:58 <ihope> What's a Strategy?
10:07:27 <flux__> they are strategies for deciding how to parallelize stuff
10:07:50 <flux__> (something I picked up from the documentation, I haven't actually used them ;))
10:08:07 <ihope> @type filter
10:08:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:08:42 <ihope> @pl filter (\x -> x `isFrom` japan || x `isFrom` china)
10:08:43 <lambdabot> filter (liftM2 (||) (`isFrom` japan) (`isFrom` china))
10:09:44 <Cale> ugh, so annoying
10:09:59 <Cale> did you catch that? :)
10:10:33 <ihope> Catch what?
10:10:40 <Cale> <Cale> (x `using` rnf) is the same as (deepSeq x)
10:10:41 <Cale> <Cale> only Control.Parallel.Strategies has lots of other cool strategies :)
10:10:41 <Cale> <Cale> whereas with deepSeq, you're stuck with full evaluation
10:13:03 <ihope> Hmm. Need to fix the subtraction function.
10:14:46 <ihope> it wekrs!!!!one11onej!!!1
10:15:19 <Cale> threeleet
10:20:49 <dcoutts> @seen dons
10:20:50 <lambdabot> dons is in #haskell. Last spoke 6 hours, 17 minutes and 12 seconds ago.
10:26:11 <gFunk> question: what's an easy way to generate a list lazily from IO?
10:26:28 <tromp> getContents
10:26:45 <Cale> Apart from the built-ins which do this, there's unsafeInterleaveIO
10:27:03 <gFunk> what built-ins?
10:27:45 <gFunk> getContents is good for one file.  i need to generate my list from many files.  is it still possible?  i can't seem to figure it out
10:28:20 <Cale> getContents, hGetContents and some others
10:28:20 <Cale> readFile
10:28:22 <Cale> Sure
10:28:43 <Cale> you get a bunch of lazy lists via hGetContents on the various handles, then you ++ them together or something
10:28:44 <gFunk> k, thanks, i'll take a look
10:29:22 <gFunk> the problem i was having with hGetContents and getContents is that by the time the data was actually read, the file handle was already closed
10:29:50 <Cale`> urk, sorry
10:30:25 <Cale`> The files automatically close when you finish reading the list. A common mistake is to call hClose on a handle which has had hGetContents applied to it
10:30:42 <gFunk> ah ha!  thanks!
10:31:26 <Cale``> heh, my connection is brutal
10:31:28 <Cale``> The files automatically close when you finish reading the list. A common mistake is to call hClose on a handle which has had hGetContents applied to it
10:32:06 <gFunk> hmm, so if you don't finish reading the entire file, you should close the list with hClose?
10:32:52 <Cale> You should never call hClose on a handle which has had hGetContents applied to it unless you really want to cut off the file wherever it's been read to.
10:33:13 <Beelsebob> unicode really does make Haskell' look beautiful
10:33:19 <ihope> So call it once you're done?
10:33:46 <monochrom> No, just don't hClose.
10:33:53 * Beelsebob just suggested making cross product usable as a syntax for tuples in types
10:33:54 <Cale> ihope: once you're done *all i/o* involving data generated from that file's contents.
10:34:04 <Beelsebob> so fst :: (a,b) -> a would become fst ::     
10:34:15 <Cale> But just don't call it. It's silly.
10:34:50 <monochrom> The runtime will close it at the right time.
10:34:54 <Cale> Beelsebob: are we replacing (,) with  ?
10:34:59 <gFunk> k, so if the file handle leaves scope, the runtime will take care of it?
10:35:05 <Cale> gFunk: yep
10:35:10 <Beelsebob> Cale: no, I'm suggesting being allowed to use it
10:35:12 <jyp> Beelsebob: imho this is best left as an editor feature
10:35:13 <ihope> I see a capital A with a tilde. Is that right?
10:35:19 * resiak wonders how to type  with vim.
10:35:20 <Cale> ihope: no
10:35:21 <jyp> Beelsebob: ... or typesetting
10:35:32 <Beelsebob> so    is equiv to (,)
10:35:38 <gFunk> Cale: thanks a bunch
10:35:39 <Beelsebob> jyp: ?
10:35:42 <Cale> I type Compose-x-x to get 
10:35:44 <resiak> Woah, irssi doesn't like what Beelsebob is typing.
10:35:47 <Beelsebob> how is that an editor feature?
10:35:56 <resiak> Oh, and so do I. Thanks Cale.
10:35:58 <Beelsebob> resiak: you're using ISO-Latin-1 encoding
10:36:01 <Beelsebob> use UTF-8
10:36:04 <monochrom> No, the runtime takes care of the file handle, not because it leaves scope, but because hGetContents is in effect.
10:36:06 <resiak> Beelsebob: No, I'm using UTF-8
10:36:13 <Cale> (which should display as a multiplication sign)
10:36:15 <resiak> Beelsebob: but it's getting the character positioning wrong. Either it on urxvt
10:36:17 <davidhouse> resiak, not well, i can see it
10:36:19 <Beelsebob> resiak: then your font doesn't support greek chars?
10:36:20 <resiak> s/on/or/
10:36:36 <resiak> No, all the chars are there, the comma and  are just kinda mialigned.
10:36:58 <Beelsebob> oh, okay
10:36:59 <Beelsebob> odd
10:37:09 <monochrom> I saw everything alright.
10:37:26 <Beelsebob> jyp: how would that be an editor support it?  Every time you type    it saves (,)?
10:37:29 * resiak thwacks urxvt about a bit, shrugs, and gets on with life.
10:37:38 <jyp> Beelsebob: basically yes
10:37:39 <Beelsebob> sounds really irritating to type one thing and save something different
10:37:44 <ihope_> Now it looks okay.
10:38:02 <jyp> or even, you type (a,b) and it shows a x b
10:38:17 <Beelsebob> jyp: but what if I want the choice of using one or the other?
10:38:31 <Beelsebob> word proved that auto-replacing things is BAD
10:38:38 <ihope_> Haskell with Unicode. That
10:38:42 <ihope_> would be tricky to type.
10:39:00 <Beelsebob> ihope: indeed, but fine on a mac :P
10:39:09 <ihope_> I like Macs.
10:39:13 <jyp> Word just sucks, it's another problem :)
10:39:44 <ihope_> I was going to wait until those fancy Intel things came out.
10:39:53 <Beelsebob> ihope: they're out
10:39:58 <Beelsebob> apple.com/imac
10:39:59 <ihope_> I know...
10:40:03 <Beelsebob> and apple.com/macbookpro
10:40:24 <jyp> Beelsebob: have you ever tryedd lyx ?
10:40:30 <monochrom> I haven't seen one in an Apple Store in Canada a week ago.
10:40:31 <ihope_> Well, I sorta hopped right on this Windozer.
10:40:34 <Beelsebob> jyp: yes, why?
10:40:48 <jyp> well, you don't see what you type either
10:40:54 <Beelsebob> monochrom: they were released on the 3rd
10:41:08 <monochrom> Aha, need to visit the store again :)
10:41:08 <Beelsebob> jyp: yes, that's why I use a plain text editor and pdflatex, not lyx
10:41:46 <monochrom> Why must you see what you type?
10:41:56 <ihope_> So where can I get hIDE?
10:42:03 <Beelsebob> monochrom: because editors that replace what I'm typing as I do it really really irritate me
10:42:08 <dcoutts> @where hIDE
10:42:08 <lambdabot> http://haskell.org/haskellwiki/HIDE
10:42:17 <Beelsebob> I damn well want the computer to do what I tell it to
10:42:22 <monochrom> Why are you irritated, may I ask?
10:42:31 <Beelsebob> because the computer isn't doing what I tell it to
10:43:08 <jyp> Beelsebob: But your keyboard isn
10:43:12 <monochrom> I mean this. As more layers of abstractions are introduced (inevitable trend), you will not see what you type.
10:43:22 <jyp> Beelsebob: But your keyboard isn't equipped with a crossproduct key, is it ?
10:43:24 <gzl> wait, I'm confused. what do you mean by "see what you type"?
10:43:27 <Beelsebob> I already have a way of typing    and (,) why would I want the computer to second guess me?
10:43:40 <Beelsebob> jyp: no, but Mac OS supports quick ways of getting them
10:43:44 <monochrom> If I use ssh, the bits transmitted are no longer what I type.
10:44:00 <Beelsebob> monochrom: no, but what I see on screen is
10:44:11 <monochrom> If I use utf-8, the number of octets is no longer the number of characters.
10:44:21 <Beelsebob> monochrom: so?
10:44:35 <jyp> Beelsebob: The point is that the computer already has a translation from what you type to what you see; using something slightly more advanced is not really a problem imho
10:44:44 <Beelsebob> if I type , I expect to see , not (,)
10:44:53 <Beelsebob> I don't care how it represents it
10:44:55 <Beelsebob> I want to see it
10:44:58 <gzl> why?
10:45:10 <Beelsebob> because that's the order I gave the god damn computer
10:45:17 <Beelsebob> because a computer is there to do what I tell it to
10:45:20 <astrolabe> You don't what to see 'shift' or 'ctrl' I suppose?
10:45:24 <gzl> but there's no difference between \times and the actual symbol.
10:45:28 <dcoutts> generally the symbol on the keyboard matches the character on the screen, it seems reasonable
10:45:49 <monochrom> Actually, you have never seen what you type.
10:45:51 <gzl> I'm confused about which product you have a problem with. you don't like LaTeX? or you don't like Word?
10:45:56 <ihope_> A question: why type  if you can type (,)?
10:46:22 <Beelsebob> gzl: I don't like Word, and I don't like the idea of me typing (,) and the editor replacing it with .
10:46:27 <monochrom> When you press a key, you are typing a keycode.  Some magic maps that to 'a'.  You never typed 'a'.  You typed a keycode.
10:46:30 <Beelsebob> because I want the choice of  and (,)
10:46:45 <ihope_> monochrom: you pushed the key labeled A
10:46:56 <monochrom> Yes yes, now my next point.
10:46:57 <ihope_> That's typing A in my book.
10:47:08 <ihope_> When you press A, you get a?
10:47:34 <dcoutts> monochrom, that's all just macinery to make it such that the symbols on your keyboard match what comes out on the screen
10:47:58 <gzl> Beelsebob: so ... turn it off. 
10:48:00 <monochrom> So there is a way to relabel your keyboard so that you are not typing (,).
10:48:20 <Beelsebob> gzl: my point is that I don't want it to be a feature of the editor, I want it to be a feature of Haskell'
10:48:33 <gzl> you don't want what to be a feature of the editor?
10:48:47 <tuomov> sigh. 
10:48:59 <Beelsebob> um, go read the log?
10:49:09 <tuomov> what most sucks about haskell is the lack of support for circular dependencies
10:49:13 <tuomov> at least in ghc
10:49:36 <tuomov> it's impossible to write anything big with this
10:49:51 <ihope_> tuomov: you mean recursion?
10:50:03 <tuomov> I mean two files importing each other
10:50:06 <Beelsebob> ihope_: no, circular module dependanciess
10:50:12 <dcoutts> tuomov, you can do that with ghc
10:50:15 <gzl> I did look at it. it wasn't clear to me what you were saying. anyway, whatever.
10:50:28 <tuomov> dcoutts: yeah, with a lot of work
10:51:13 <Beelsebob> oh ffs... bbiab
10:51:27 <dcoutts> tuomov, not more work that ML folk have to suffer for every module (since they have separate interface & impl files)
10:52:29 <tuomov> it's easier to have one huge file that takes ages to compile and becomes unmaintainable eventually
10:53:13 <astrolabe> Usually you can find 'modules' that are independent I think.
10:53:16 <jyp> tuomov, dcoutts: this is a job for the upcoming hIde, probably
10:53:30 <tuomov> wimp gui ides, yuck.
10:53:35 <jyp> computer aided refactoring into module
10:53:55 <tuomov> I want my editor to run in the terminal.
10:54:09 <Lokadin> tuomov: use vim
10:54:16 <Lokadin> or yi
10:54:18 <Lemmih> hIDE will eventually get an ncurses interface.
10:54:34 <jyp> fine; I meant any haskell-refactorer
10:54:41 <tuomov> with all the recent gtk fanboyism over here, I wonder when that "eventually" will be..
10:55:13 <jyp> please
10:55:55 <Lemmih> I have a personal interest in a text interface so it'll definitely happen.
10:59:02 <tuomov> I guess I'll have to write 10 modules instead of 1..
10:59:16 <tuomov> which means exposing a zillion things.. sigh
10:59:30 <dcoutts> Lemmih, interesting.
11:00:25 <dcoutts> Lemmih, do you expect to be able to do that in one binary that can do either?
11:00:56 <Lemmih> dcoutts: Yeah.
11:02:06 <dcoutts> Lemmih, so components that wanted to support either kind of UI would just hook into the GUI and the TUI modules?
11:03:04 <dcoutts> Lemmih, I doubt we could get much more unified than that, though many bits would be common, or similar
11:03:32 <dcoutts> Lemmih, eg just adding a menu entry could be the same, but adding an EditorView would be different
11:04:16 <dcoutts> Lemmih, yeah, sounds plausible
11:04:52 <dcoutts> Lemmih, one could even have a TUI and GUI bits running simultatiniously and sharing buffers.
11:07:05 <dcoutts> since it's possible to have multiple top level GUI windows open at once, there's no resaon one couldn't have one or more text/console view open too.
11:10:30 <tuomov> bleah, I'd rather not have any *tk deps.
11:10:39 <tuomov> I'm trying to rm -rf gtk on my system
11:10:54 <palomer> hrm
11:10:56 <palomer> what's a value to you guys?
11:11:00 <tuomov> just needs to find replacement for gqview
11:11:17 <Lemmih> tuomov: GTK plugins are loaded at runtime. You don't need them if you don't want them.
11:12:37 <dcoutts> tuomov, xlib only eh?
11:12:41 <tuomov> Qt's ok
11:12:48 <tuomov> don't like it, but I can tolerate it
11:13:00 <tuomov> I'm totally fed up with the gnome/gtk folk, though
11:14:21 <dcoutts> qt might be nice but it'd be a pain to bind in Haskell because it's C++ and automatic memory management would be a pain or just impossible.
11:14:40 <dcoutts> the gtk+ folk at least pay attention to language bindings
11:14:47 <tuomov> you just need a higher-level layer between.. Vis
11:15:04 <palomer> gtk2hs is sweeeet
11:15:19 <tuomov> any toolkit is sour
11:15:31 <tuomov> too low-level
11:15:31 <dcoutts> tuomov, a higher-level layer between what?
11:15:38 <palomer> it's the easiest toolkit I've ever used
11:15:42 <palomer> a million times easier than swing
11:15:48 <tuomov> UIs should _not_ be written for widget sets
11:15:59 <tuomov> it's the completely wrong abstraction level
11:16:02 <tuomov> i.e. no abstraction at all
11:16:14 <jyp> For my information, what makes you hate gtk so much, tuomov ?
11:16:21 <dcoutts> tuomov, everyone wants something higher level but it's a lot of work to implement the lower layers.
11:16:36 <jyp> maybe you have written an article about it already... ?
11:16:42 <dcoutts> hence building higher level things on top of existing well mainteined toolkits
11:16:49 <tuomov> how about gnome file chooser for starters?
11:17:04 <tuomov> how about it taking years to fix really annoying bugs?
11:17:23 <tuomov> rather concentrating on adding new crappy features than fixing their shit
11:18:28 <tuomov> http://modeemi.fi/~tuomov/b/archives/2006/01/27/T21_38_15/
11:18:35 <tuomov> http://modeemi.fi/~tuomov/b/archives/2005/12/16/T23_40_03/
11:18:39 <jyp> In a lot of fronts, people seem more interested in the 'cutting edge new features' than stabilization... but ok, I see your points.
11:18:41 <tuomov> that's what little I've written recently
11:19:01 <tuomov> on UIs
11:20:59 <dcoutts> I'm not sure what all these major bugs are. Perhaps they don't affect that many people for them to be a top priority.
11:21:24 <tuomov> there was this focus bug that took over two years to fix
11:21:36 <dcoutts> the focus stealing thing?
11:21:42 <tuomov> maybe
11:21:58 <dcoutts> or the mozilla focus stealing bug
11:22:09 <flux__> I wish there was a tool that allowed to change focus from one head to another, with keyboard
11:22:13 <tuomov> and of course there are a zillion gnome file chooser bugs over two years old in the database as well
11:22:41 <tuomov> dcoutts: probably the same bug
11:23:03 <tuomov> Ion has Mod1+Shift+12,. bound to that (no more though by deafult)
11:27:43 <elk> Lemmih, haskellSense depends on ghc package now, where would i get it, ghc-6.5 ?
11:29:46 <Lemmih> elk: Yes.
11:31:04 <elk> Leemih, does that mean that i should use ghc-6.5 for building hide?
11:33:55 <elk> Lemmih,  there was a problem building gtk2hs with 6.5
11:34:40 <dcoutts> Lemmih, you need to apply that ghc-6.5 patch to the gtk2hs.hide repo. I don't have permissions to push the patch.
11:36:54 <dcoutts> Lemmih, or you can make the repo group writable and then I can push patches.
11:37:03 <Lemmih> elk: Yes, you need to build hIDE with ghc-6.5.
11:38:24 <dcoutts> Lemmih, chgrp darcs -R /home/darcs/gtk2hs.hide; chmod g+w -R /home/darcs/gtk2hs.hide
11:38:30 <Lemmih> elk: The README have the URLs for ghc, gtk2hs and hs-plugins which are guaranteed to build OK.
11:40:47 <Lemmih> dcoutts: You should have access now.
11:41:26 <dcoutts> Lemmih, ta.
11:47:17 <ihope> Okay. The English language is dynamically types.
11:47:32 <ihope> s/s./d./
11:48:03 <jyp> ?
11:48:59 <edwinb> oh no, not this again ;)
11:52:00 <davidhouse> > sin pi
11:52:01 <lambdabot> 1.2246063538223773e-16
11:52:10 <davidhouse> does sin do what i think it does?
11:52:15 <davidhouse> > sin 2*pi
11:52:16 <lambdabot> 2.856642116043664
11:52:20 <davidhouse> that's obviously wrong.
11:52:45 <tromp> > sin $ 2*pi
11:52:46 <lambdabot> -2.4492127076447545e-16
11:52:51 <tromp> better?
11:52:55 <davidhouse> almost
11:53:02 <davidhouse> it should be 0, but i guess that's down to rounding errors
11:55:07 <gFunk> "mapM readFile paths" doesl this open a file handle for every item in 'paths' immediately or does it lazily open the file when you first try to read from the file?
11:55:50 <xerox> lazily.
11:56:52 <tromp> try on a non existing file, then sleep 10 secs before reading from it
11:57:15 <gFunk> hmm, that's what i thought too, but when i attempt to read 1800 files, i get 'Permission denied' error
11:57:53 <tromp> i expect it will open them but not read until needed
11:58:31 <gFunk> that's what i'm thinking too.  i wonder if there's a way to postpone opening
11:58:42 <elk> Lemmih, thanks, dcoutts, will you push the patch for gtk2hs ?
11:59:48 <Mitar> what is an operator for not equal?
12:00:10 <Lemmih> > 10 /= 5
12:00:11 <lambdabot> True
12:05:59 <TuringTest> > let s x = (x/pi)== round (x/pi) in s (2*pi)
12:06:00 <lambdabot> Add a type signature
12:06:15 <TuringTest> > 2*pi/pi
12:06:17 <lambdabot> 2.0
12:06:32 <TuringTest> let s x = (x/pi)== round (x/pi)
12:06:44 <TuringTest> > let s x = (x/pi)== round (x/pi) 
12:06:44 <lambdabot>  parse error on input `}'
12:06:51 <TuringTest> heh
12:07:15 <TuringTest> >let s x =( (x/pi)== round (x/pi) ) in s 0
12:07:52 <TuringTest> 1+1e-16
12:07:59 <TuringTest> > 1 + 1e-16
12:08:00 <lambdabot> 1.0
12:08:07 <TuringTest> > 1 + 2e-16
12:08:08 <lambdabot> 1.0000000000000002
12:08:18 <TuringTest> That's the rounding limit all right
12:08:40 <TuringTest> >1 + (2^-51)
12:08:46 <TuringTest> > 1 + (2^-51)
12:08:47 <lambdabot>  Not in scope: `^-'
12:09:00 <TuringTest> > 1 + recip (2^51)
12:09:01 <lambdabot> 1.0000000000000004
12:09:10 <TuringTest> > 1 + recip (2^54)
12:09:11 <lambdabot> 1.0
12:09:16 <TuringTest> > 1 + recip (2^53)
12:09:17 <lambdabot> 1.0
12:09:23 <TuringTest> Yup
12:16:51 <eckhart> is there any specific mime type for hs files?
12:36:14 <davidhouse> a little puzzle from #math: "The number 25 can be written as 5^2, simply by reordering the digits of 25 ... the same thing goes for 121 which is 11^2 ... are there any other numbers of this kind?"
12:36:23 <davidhouse> any ideas as to how this could be solved with haskell?
12:36:52 <jethr0> reordering digits calls rather for exhaustion than algorithm (?)
12:38:12 <palomer> how are orderings usually ordered?
12:38:24 <SamB> jethr0: there are algorithms for exhaustive searches
12:38:37 <jethr0> i know just mentioning :)
12:39:11 <SamB> it would probably involve Read and Show
12:39:18 <jethr0> jup
12:39:20 <davidhouse> yeah.
12:39:37 <jethr0> checking all 2+1 combinations of (show n)
12:39:49 <SamB> uh, does anyone happen to know what an RSI feels like?
12:40:23 <palomer> err, I meant relations
12:40:27 <palomer> how are relations usually ordered
12:40:39 <SamB> huh?
12:40:45 <jethr0> ? relations are orders...
12:40:53 <jethr0> or half orders
12:40:54 <SamB> @type compare
12:40:55 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:40:58 <davidhouse> doesn't mean you can't order them
12:41:03 <palomer> this is more of a math question
12:41:23 <astrolabe> relations can include (ie imply) each other.  This makes the set of relations a partially ordered set.
12:41:36 <jethr0> ah, you mean ordering relations among each other...
12:41:37 <SamB> > [minBound..maxBound] :: [Ordering]
12:41:38 <lambdabot> [LT,EQ,GT]
12:42:09 <palomer> jethr0: yeah
12:42:17 <palomer> like, I have a relation that relates to a single point
12:42:21 <palomer> and I have the identity relation
12:42:27 <palomer> which is greater than which?
12:43:06 <astrolabe> palomer: Do you know the definition of a relation as a set of ordered pairs?
12:43:11 <eckhart> what's wrong with these lines: http://rafb.net/paste/results/N82LPX39.html
12:43:14 <palomer> astrolabe: of course
12:43:23 <palomer> astrolabe: I mean, I could order them by inclusion, but that seems silly
12:43:36 <eckhart> if i load them with hugs, and then enter "(CRat 1 1) > (CRat 1 2)" into hugs
12:43:42 <palomer> namely, the 1 point relation and the id relation are incomparable
12:43:42 <eckhart> i get a memory access error
12:44:10 <astrolabe> What set is the id relation defined on?
12:44:42 <palomer> we'll assume that all relations have the same domain
12:45:02 <palomer> actually, these are functions
12:45:21 <astrolabe> What is the '1 point' relation?
12:45:39 <palomer> it maps everything to a single point
12:45:48 <astrolabe> hmmm. Well no function contain other functions so perhaps this is the wrong idea.
12:45:50 <palomer> (the exact point sohuldn't matter)
12:46:19 <palomer> astrolabe: functions in the sense of "relation where the first coordinates are uniques"
12:46:20 <astrolabe> Could the question be about ordering functions instead of relations?
12:46:31 <jethr0> these are functions defined by listing all source,target pairs. and those lists of pairs can include each other
12:46:46 <palomer> s/uniques/unique
12:46:58 <astrolabe> jethr: they couldn't.
12:47:18 <astrolabe> Could the question be about ordering functions instead of relations?
12:47:23 <jethr0> [(1,2)] element of [(1,2),(2,3)]
12:47:26 <jethr0> subset
12:47:32 <palomer> yeah, sure, ordering functions
12:47:33 <davidhouse> subset, yes.
12:47:40 <astrolabe> but [(1,2)] isn't a function
12:47:46 <palomer> why not?
12:47:48 <astrolabe> from [1,2
12:48:03 <astrolabe> from [1,2].  I mean it has a different domain.
12:48:16 <davidhouse> [1,2] isn't a function.
12:48:17 <palomer> [(1,2)] is a function in my sense
12:48:25 <davidhouse> a function should be a list of (ordered) pairs
12:48:26 <astrolabe> palomer: Is the target set of the functions a partially ordered set?
12:48:43 <palomer> anyways, I have [(1,1),(2,2),(3,3)] compared with [(1,1),(2,1),(3,1)]
12:49:00 <palomer> which is greater?
12:49:12 <davidhouse> depends how you defined 'greater'
12:49:20 <palomer> I like to think as the second list as "bottom"
12:49:25 <palomer> davidhouse: i'm asking how it's usually defined
12:49:27 <palomer> ugh.
12:49:33 <tromp> they're incomparable as sets
12:49:34 <jethr0> you could define greater by the size of the image
12:49:40 <astrolabe> If the target is ordered, you can order functions by f >= g  iff   for all x<-domain, f(x) >= g(x)
12:49:47 * palomer gives up
12:49:52 <tromp> and the first is >= the second as total functions
12:50:15 <palomer> assume the domain and codomain are not ordered
12:50:19 * davidhouse shudders at astrolabe's pseudo-maths :)
12:50:40 <davidhouse> palomer, then it's more difficult, as you can't say that f(x) is greater than some g(x)
12:50:47 <lennart> palomer: why would you like to consider the second list bottom?
12:50:56 <palomer> lennart: YES!
12:51:02 <palomer> lennart: oh, that was a why
12:51:09 <palomer> lennart: because it says that everything is equal to everything else
12:51:09 <lennart> yes, why?
12:51:20 <palomer> lennart: under all mappings from codomain to domain
12:51:37 <davidhouse> lennart, because f(x) <= g(x) for all x \in domain
12:51:41 <palomer> whereas the first mapping says that everything is distinct
12:51:54 <davidhouse> where f is that first function, g is the second
12:51:59 <astrolabe> I don't believe there is any natural order on the set of functions from a general set X to a general set Y.
12:52:06 <davidhouse> *other way round
12:52:21 <lennart> so by bottom you don't mean the domain theoretical bottom
12:52:30 <palomer> I don't think so
12:52:30 <jethr0> astrolabe: well, y is a subset of x for relations, right?
12:52:44 <lennart> there
12:52:47 <lennart> there'
12:52:49 <palomer> actually, in this case the domain is equal to the codomain, so the second one is clearly bottom since everything is equal to 1
12:52:54 <lennart> arg!  can't type!
12:53:08 <astrolabe> palomer: so you're target has 1 in it?
12:53:09 <Cale> what's up?
12:53:15 <palomer> yay for cale!
12:53:17 <jethr0> hey cale
12:53:17 <davidhouse> Cale, we're talking about ordering functions
12:53:22 <jethr0> relations
12:53:24 <lennart> there's the domain theoretic ordering of functions.  but it's not a total order
12:53:25 <palomer> astrolabe: target?
12:53:33 <palomer> lennart: oh, I don't care about total orders
12:53:41 <Cale> ordered by what?
12:53:42 <palomer> this is going to be a  partial order
12:54:01 <astrolabe> functions are defined from one set into another.  These sets are called the domain and the target.
12:54:01 <palomer> Cale: take the function [(1,1),(2,1),(3,1)]
12:54:19 <palomer> Cale: I consider this function "bottom", since everything is equal to 1 (so everything is equal to anything)
12:54:26 <Cale> by that you mean the constant 1 function on {1,2,3}
12:54:30 <Cale> ?
12:54:34 <palomer> Cale: sure
12:54:37 <davidhouse> palomer, you can't say it's "bottom". you can say it's lower than some other function
12:54:41 <palomer> Cale: now take id
12:54:46 <Cale> Everything is equal to 1?
12:55:04 <Cale> oh, the range of the function is {1}
12:55:05 <palomer> Cale: oh, right, f(x) = y means x is equal to y in some sense
12:55:05 <davidhouse> as f(x) = 0 for x \in {1,2,3} is lower
12:55:20 <Cale> um, that's an odd interpretation, but okay
12:55:24 <jethr0> not equal, in relation
12:55:29 <palomer> lennart: what's the domain theoretic ordering?
12:55:33 <lennart> so in the domain theoretic ordering those two are not comparable
12:55:34 <kevind> looks like you want some kinda graph theoretic thing
12:55:39 <palomer> ugh
12:55:43 <Cale> will you be using this function to construct an equivalence relation?
12:55:52 <palomer> Cale: yes, among other things
12:56:12 <Cale> okay
12:56:13 <palomer> so [(1,1),(2,1),(2,1)] is equivalent to [(1,2),(2,2),(2,3)]
12:56:15 <lennart> palomer: where the lowest element is bottom (no information) and you built things up from that
12:56:19 <palomer> so [(1,1),(2,1),(2,1)] is equivalent to [(1,2),(2,2),(3,2)]
12:56:22 <Cale> I take it the domain is the same as the codomain?
12:56:40 <palomer> Cale: there is a 1-1 correspondence from domain and codomain
12:56:43 <Cale> What are the domain and codomain here anyway?
12:56:55 <palomer> unspecified
12:57:05 <davidhouse> that makes life more difficult :P
12:57:16 <astrolabe> So f >= g if for all x,y   f(x) = f(y) => g(x) = g(y)?
12:57:16 <palomer> how so?
12:57:22 <davidhouse> well, i suppose not if you don't want wellorders.
12:57:26 <kevind> how about you count the number of connected components
12:57:32 <Cale> Well, you can't properly have a function if you don't know the domain or codomain, as far as I'm concerned :)
12:57:55 <palomer> Cale: ok, the domain is {1,2,3} and the codomain is {a,b,c}
12:57:58 <Cale> okay
12:58:10 <Cale> and you say there's a bijection between them
12:58:14 <palomer> yes
12:58:23 <palomer> 1<=>a,2<=>b,3<=>c
12:58:26 <astrolabe> Palomer: is this what you mean?
12:58:28 <Cale> is there a reason not to treat them as the same set?
12:58:32 <astrolabe> So f >= g iff for all x,y   f(x) = f(y) => g(x) = g(y)?
12:58:41 <palomer> astrolabe: err, not quite
12:58:48 <Cale> So you're working with functions A -> A for some set A?
12:58:49 <palomer> that's by inclusion
12:59:02 <palomer> Cale: a priori, no
12:59:15 <Cale> palomer: okay, so let's do that for now
12:59:22 <astrolabe> It's not the same as inclusion of the functions considered as relations.
12:59:25 <Cale> since you're interested in generating an equivalence relation
12:59:26 <kevind> palomer, how do you want the rest of the ordering to work, besides the minmum
12:59:35 <palomer> Cale: I also need the ordering though
12:59:35 <kevind> err, minimum
12:59:44 <Cale> palomer: is A ordered?
12:59:48 <palomer> kevind: const 1 == const 2 == const 3
12:59:49 <palomer> Cale: no
12:59:54 <Cale> okay
13:00:07 <davidhouse> palomer, then you can't say x > y for some x, y in A, yeah?
13:00:09 <kevind> palomer, and those are all equivalent and minimum, rigt?
13:00:15 <palomer> forall functions. const 1 <= functions
13:00:20 <palomer> kevind: right
13:00:24 <palomer> I want id to be the top
13:00:28 <kevind> you could just count connected components (viewing the pairs as graph edges)
13:00:35 <palomer> davidhouse: nope
13:00:47 <davidhouse> palomer, what about id + 1. wouldn't that be "above" id?
13:00:49 <kevind> that will give you consts = bottom, id = top
13:00:52 <Cale> palomer: sorry, could you precisely define the order which you're talking about?
13:00:53 <palomer> kevind: that's a possible ordering, though it's not what I'm looking for
13:00:57 <astrolabe> palomer.  That sounds like what I said.  What do you want that my formulation doesn't give you?
13:01:07 <palomer> ok, I'll define the ordering
13:01:23 <palomer> wait, I'll probably lose you if I do
13:01:32 <Cale> I'm not sure what you mean by those examples
13:01:49 <davidhouse> palomer, try us
13:01:50 <palomer> Cale: you know in graph theory, each homomorphism defines a set of equivalence classes in the codomain
13:01:54 <palomer> err, group theory
13:02:06 <astrolabe> in the domain
13:02:16 <Cale> in the domain, in both graph and group theory
13:02:29 <palomer> err, right, in the domain
13:02:44 <palomer> well, you have a notion of "finer" homomorphism
13:02:52 <Cale> basically, it's the kernel of the map (in groups, the cosets of the kernel)
13:03:00 <palomer> where the equivalence classes of one are subsets of the equivalence classes of others
13:03:09 <astrolabe> You are comparing the equivalence relations induced by the function?
13:03:22 <palomer> everything is finer than the trivial homomorphism
13:03:34 <palomer> astrolabe: yes
13:03:35 <astrolabe> That is exactly what I've been saying I think.
13:03:47 <Cale> yeah, that's what astrolabe has been talking about.
13:03:49 <palomer> astrolabe: yeah, you were the closest thus far
13:03:55 <Cale> and kevind
13:04:04 <palomer> however, I want permutations of id to be equivalent to id
13:04:12 <palomer> that's the rub
13:04:15 <Cale> that's fine
13:04:59 <palomer> oh, you're right, it still works
13:05:00 <kevind> ok, view each function as a set of sets of connected components and say S <= T if for every c \in T there is a c' \in S with c \subseteq c'
13:05:02 <palomer> what's this ordering called?
13:05:27 <Cale> how about the functions {(1,1), (2,1), (3,3)} and {(1,1),(2,2),(3,1)} -- are they considered equivalent?
13:06:00 <Cale> (do you care more about the exact partition, or the number/size of the parts)
13:06:08 <astrolabe> What do you mean by a permutation of a function?  Is the permutation on the left or the right?
13:06:12 <palomer> Cale: no, they are incomparable
13:06:20 <Cale> okay
13:06:28 <palomer> astrolabe: ignore that bit, cale corrected me
13:06:46 <palomer> yeah, I think astrolab's ordering works
13:06:47 <Cale> so you're just looking at the set of fibres
13:06:57 <palomer> Cale: yeah
13:07:31 <kevind> I think his order almost works
13:07:35 <palomer> however, {(1,2),(2,2),(3,3)} is equivalent to {(1,1), (2,1), (3,3)}
13:07:51 <palomer> which is fine
13:08:10 <palomer> kevind: why almost?
13:08:20 <palomer> so, yeah, this ordering must have a name, what is it?
13:08:28 <kevind> do you want [(1,1),(2,1),(3,2)] equivalent to [(1,1),(2,1),(3,1)] ?
13:08:42 <palomer> no
13:08:53 <kevind> ahh, ok, then it works
13:09:02 <palomer> but [(1,1),(2,1),(3,2)] is equivalent to [(1,1),(2,1),(3,3)]
13:09:10 <Cale> So I think if f,g : A -> B, then f <= g when for every b in B, f^(-1)(b) is a superset or equal to g^(-1)(b).
13:09:16 <astrolabe> palomer: So why don't you want what I said?
13:09:43 <Cale> hmm, no
13:09:43 <palomer> astrolabe: I do I do!
13:09:47 <palomer> that's what I've been saying
13:09:59 <astrolabe> Ah ok.
13:10:13 <astrolabe> I'm not sure it's got a unique simplest name.
13:10:22 <Cale> If f,g : A -> B, then f ~ g when {f^(-1)(b) | b in B} = {g^(-1)(b) | b in B}
13:10:25 <Cale> that's for sure.
13:10:27 <palomer> it must be something that appears often
13:11:29 <palomer> is there an algorithm for deciding <= which does not involve compairing each pair
13:11:36 <astrolabe> I'd say 'the partial order defined by inclusion of the fiber equivalence relation' I think.
13:11:40 <Cale> and when you have two such sets of fibres F and G, then F <= G when for each u in F, there is some v in G such that v is a subset of u.
13:12:07 <Cale> It's sort of an odd kind of inclusion.
13:12:18 <palomer> people use it all the time though
13:12:26 <palomer> they call it "being finer"
13:12:34 <palomer> the finest being the identity
13:12:39 <Cale> ah, as partitions, sure
13:13:05 <astrolabe> So, is there an efficient way for testing equivalence relations for inclusion?
13:13:32 <Cale> I'd say probably not in general.
13:13:40 <palomer> is this what I'm trying to do?
13:13:50 <Cale> why are you doing this? :)
13:13:54 <astrolabe> I'm sure you can do better than testing all pairs.
13:14:24 <palomer> Cale: I'll tell you once I publish:O
13:14:38 <Cale> You're not likely to do much better than O(n^2) where n is the min of the number of parts of the two partitions.
13:14:53 <astrolabe> How about finding the eqivalence classes of f, choosing a representative of each, and testing that each point is g-equivalent to it's representative.
13:17:10 <palomer> err
13:17:14 <palomer> in simpler terms?
13:18:11 <astrolabe> palomer: first make a list of lists of elements of the domains.  Things go in the same list if and only if they have the same image under f.
13:18:40 <palomer> ok, the equivalence classes
13:19:00 <astrolabe> Then for each list of elements, check that each member has the same g-image as the first element of the list.
13:19:36 <palomer> that's O(n)
13:19:39 <astrolabe> Yes, the f-equivalence classes.
13:20:11 <astrolabe> I think the first bit isn't O(n) unless the image is an Ix or something.
13:20:26 <palomer> n*log(n)
13:20:31 <astrolabe> I mean the co-domain, not the image.
13:20:37 <astrolabe> Yeah, that would be my guess.
13:22:38 <palomer> so no examples of this ordering in practice?
13:23:57 <palomer> I think I'll call it finess
13:32:16 <jethr0> davidhouse: ping
13:32:25 <davidhouse> jethr0, hey
13:32:30 <jethr0> > let f n = map (take n) . take n . iterate (drop 1) . cycle; num = show 123; n = length num in map (\xs -> map (`splitAt` xs) [1..n-1]) $ f (length num) num
13:32:31 <lambdabot> [[("1","23"),("12","3")],[("2","31"),("23","1")],[("3","12"),("31","2")]]
13:33:04 <jethr0> does that help :)
13:33:16 <jethr0> @pretty let f n = map (take n) . take n . iterate (drop 1) . cycle; num = show 123; n = length num in map (\xs -> map (`splitAt` xs) [1..n-1]) $ f (length num) num
13:33:16 <lambdabot>  i = let f n = map (take n) . take n . iterate (drop 1) . cycle
13:33:16 <lambdabot>    num = show 123
13:33:16 <lambdabot>    n = length num
13:33:16 <lambdabot>    in
13:33:16 <lambdabot>    map (\ xs -> map (`splitAt` xs) [1 .. n - 1]) $ f (length num)
13:33:18 <lambdabot> num
13:33:30 <jethr0> *pah*
13:33:32 <davidhouse> jethr0, it might if you explain what that is
13:33:45 <palomer> > let <=~ a b = a in 1 <=~ 2
13:33:46 <lambdabot>  parse error on input `<=~'
13:33:55 <jethr0> davidhouse: it's for your puzzle
13:33:57 <palomer> > let  a <=~ b = a in 1 <=~ 2
13:33:59 <lambdabot> 1
13:34:23 <davidhouse> jethr0, how are they the solutions? i don't understand
13:34:34 <jethr0> davidhouse: it's only a first step
13:34:39 <davidhouse> ah.
13:35:33 <davidhouse> those are... all the ways of splitting a 3 digit number?
13:36:00 <palomer> man, I love you guys
13:36:13 <geneticp> does anyone tried to compile HWS-WP, the haskell web server?
13:36:45 <geneticp> I got the error: "cpp: too many input files
13:36:51 <davidhouse> > let f n = map (take n) . take n . iterate (drop 1) . cycle; num = show 2345; n = length num in map (\xs -> map (`splitAt` xs) [1..n-1]) $ f (length num) num
13:36:52 <lambdabot> [[("2","345"),("23","45"),("234","5")],[("3","452"),("34","52"),("345","2"
13:36:52 <lambdabot> )],[("4","523"),("45","23"),("452","3")],[("5","234"),("52","34"),("523","
13:36:52 <lambdabot> 4")]]
13:37:27 <davidhouse> > let f n = map (take n) . take n . iterate (drop 1) . cycle; num = show 2345; n = length num in map (\xs -> map read $ map (`splitAt` xs) [1..n-1]) $ f (length num) num
13:37:28 <lambdabot> Couldn't match `String' against `([a], [a])'
13:38:57 <Mitar> the easiest way to replace one element in a list with another?
13:39:02 <palomer> how would I do the list comprehension {(x,y) | x,y in someList} ?
13:39:43 <Cale> [(x,y) | x <- someList, y <- someList]
13:40:53 * palomer writes his first list comprehension
13:41:13 <jethr0> > let f n = map (take n) . take n . iterate (drop 1) . cycle; num = show 121; n = length num; combis = concat $ map (\xs -> map (`splitAt` xs) [1..n-1]) $ f (length num) num; numPairs = map (read *** read) combis :: [(Int,Int)] in filter (\(x,y) -> x^y == (read num :: Int)) numPairs
13:41:14 <lambdabot> [(11,2)]
13:41:16 <palomer> and what's the quickest way to check forall a,b. f(a) = f(b) -> g(a) = g(b) ?
13:41:19 <jethr0> davidhouse: :)
13:41:33 <geneticp> does anyone tried to compile HWS-WP, the haskell web server?. I got the error: "cpp: too many input files
13:41:34 <SamB> @hoogle [a] -> [b] -> [(a,b)]
13:41:35 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
13:41:35 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
13:41:42 <SamB> hmm. not that one...
13:41:50 <SamB> @hoogle cross
13:41:51 <lambdabot> Graphics.UI.GLUT.Callbacks.Window.Crossing :: Crossing
13:41:51 <lambdabot> Graphics.UI.GLUT.Callbacks.Window.CrossingCallback :: Crossing -> IO ()
13:41:51 <lambdabot> Graphics.UI.GLUT.Callbacks.Window.crossingCallback :: SettableStateVar (
13:41:51 <lambdabot> Maybe CrossingCallback)
13:41:57 <SamB> @hoogle crossProduct
13:41:57 <lambdabot> No matches found
13:41:57 <palomer> @hoogle exists
13:41:58 <lambdabot> System.IO.Error.isAlreadyExistsError :: IOError -> Bool
13:41:58 <lambdabot> System.IO.Error.alreadyExistsErrorType :: IOErrorType
13:41:58 <lambdabot> System.IO.Error.isAlreadyExistsErrorType :: IOErrorType -> Bool
13:42:15 <palomer> @hoogle forall
13:42:16 <lambdabot> Test.QuickCheck.forAll :: (Show a, Testable b) => Gen a -> (a -> b) ->
13:42:16 <lambdabot> Property
13:42:16 <lambdabot> Language.Haskell.TH.Lib.forallC :: [Name] -> CxtQ -> ConQ -> ConQ
13:42:16 <lambdabot> Language.Haskell.TH.Lib.forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
13:42:21 <davidhouse> jethr0, nice! :) can it now be made to find those pairs?
13:42:32 <palomer> @hoogle (a -> Bool) -> [a] -> Bool
13:42:33 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
13:42:33 <lambdabot> Data.List.all :: (a -> Bool) -> [a] -> Bool
13:42:33 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
13:42:42 <jethr0> just gotta map the function over [1..] :)
13:42:58 <jethr0> i think i'm gonna paste it
13:43:22 <jethr0> davidhouse: but it's gonna be slow as hell, as it is
13:43:30 <palomer> @hoogle ==>
13:43:31 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
13:43:44 <palomer> @hoogle Bool -> Bool -> Bool
13:43:44 <davidhouse> jethr0, i can run it up to, say, 1000 on my pc, shouldn't be unbearable
13:43:45 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
13:43:45 <lambdabot> Data.Bool.(||) :: Bool -> Bool -> Bool
13:43:45 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
13:44:07 <jethr0> it's gonna take a minute or two. but this was just a base case. many optimizations ahead :)
13:44:31 <Mitar> the easiest way to replace one element in a list with another?
13:47:41 <palomer> @hoogle [a] -> a -> a -> [a]
13:47:42 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
13:47:42 <lambdabot> Data.List.delete :: Eq a => a -> [a] -> [a]
13:47:42 <lambdabot> Data.List.insert :: Ord a => a -> [a] -> [a]
13:47:54 <palomer> Mitar: delete and then insert?
13:48:12 <palomer> oh, nevermind
13:48:36 <Mitar> i find only map suitable
13:48:41 <Mitar> and an if ...
13:49:16 <palomer> @hoogle find
13:49:16 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
13:49:16 <lambdabot> Data.IntMap.findWithDefault :: a -> Key -> IntMap a -> a
13:49:16 <lambdabot> Data.List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
13:51:06 <davidhouse> jethr0, could you paste or /msg me the final function?
13:53:18 <palomer> henceforth, I will use Maybe () instead of Bool
13:53:22 <palomer> any objections?
13:53:38 <astrolabe> Why would you do that?
13:53:49 <Cale> Yeah, that's inconvenient
13:54:08 * astrolabe hugs Bool
13:54:09 <Cale> Since you can't use a Maybe () with if or many other functions.
13:54:14 <lennart> palomer: go ahead!  some pain is good for you!
13:54:41 <phredpenguin> s
13:55:47 <lennart> but why Maybe ()?  Why not Either () ()?
13:56:22 <palomer> ooh, tantalizing
13:56:29 * palomer goes nuts
13:57:00 <palomer> hmm
13:57:11 <palomer> Either should be a monad
13:57:16 <palomer> Either a String should certainly be a monad
13:57:46 * palomer is off
13:57:57 <palomer> Either String, I meant
13:58:12 <Cale> Either String is a monad.
13:59:04 <Cale> import Control.Monad.Error
14:03:45 <lisppaste2> jethr0 pasted "number combinations" at http://paste.lisp.org/display/16486
14:04:04 <jethr0> davidhouse: those two seem to be the only ones under 1000.
14:04:13 <davidhouse> jethr0, thanks.
14:04:23 <jethr0> "502" is nother one
14:04:59 <jethr0> huh? sth is wrong...
14:05:06 <davidhouse> yeah...
14:05:22 <jethr0> no, it's just my number conversion. takes leading zeros out
14:05:33 <jethr0> i think
14:05:54 <davidhouse> ... so what should it be?
14:06:01 <davidhouse> perhaps they should be left as string
14:06:02 <davidhouse> *strings
14:07:15 <jethr0> *dang*
14:10:02 <lisppaste2> jethr0 annotated #16486 with "fixed" at http://paste.lisp.org/display/16486#1
14:10:33 <jethr0> 2500 it is
14:11:23 <davidhouse> thanks :)
14:11:36 <maihem> I'm trying to define a monad that simply wraps ST to defin its own interface to the state thread concept, such that the existing ST functions can't be used. I can't figure out how to define MyType s a = MyCtor (ST s a), or how to define >>=. Any clues?
14:11:39 <davidhouse> lovely program!
14:11:45 <jethr0> davidhouse: although leading zeros are rather undefined...
14:11:47 <jethr0> :)
14:12:53 <davidhouse> jethr0, what does that *** operator do?
14:13:04 <davidhouse> i haven't seen it before
14:15:32 <jethr0> it's an arrow operator. "(f *** g) (x,y) = (f x, f y)"
14:15:43 <Cale> @type (Control.Arrow.***)
14:15:44 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
14:15:44 <lambdabot> (Control.Arrow.Arrow a) =>
14:15:44 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
14:15:47 <jethr0> similarly "(f &&& g) x = (f x, g x)"
14:16:26 <Cale> Replace a by (->) for the most common case :)
14:16:36 <wolverian> that just blew my mind.
14:17:06 <Cale> maihem: I have some examples of that
14:17:31 <Cale> one sec, let me find one
14:17:35 <maihem> Cale, great, thanks.
14:17:50 <Cale> lisppaste2: url
14:17:51 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:18:01 <jethr0> maihem: also note: "first f $ (x,y) = (f x, y)"
14:18:08 <jethr0> second, in a similar vein
14:18:53 <maihem> jethr0: ?
14:19:03 <lisppaste2> Cale pasted "STO" at http://paste.lisp.org/display/16487
14:19:10 <jethr0> ?   :)
14:19:34 <jethr0> sorry, got the threading mixed up :)
14:20:03 <maihem> Cale: That lisppaste2 thing looks cool, does it automatically notify the channel of new/haskell pastes?
14:20:24 <Cale> yeah
14:20:45 <maihem> pretty damned cool
14:20:45 <jethr0> happens
14:20:47 <Cale> that code was from when Palomer wanted a version of ST with references that were ordered.
14:23:09 <maihem> Thanks cale
14:23:55 <Cale> You just use the module boundary to ensure that the constructor for your new monad isn't exported, so you control the ways in which things happen.
14:24:40 <Cale> There are some more examples of wrapping State monads on the (old) wiki.
14:24:43 <vincenz> re
14:24:54 <jethr0> vincenz: rer
14:25:04 <Cale> @arr
14:25:05 <lambdabot> Har de har har!
14:26:55 <vincenz> how does that deriving (Monad) work
14:27:42 <jethr0> huh?
14:28:04 <musasabi> it needs -fglasgow-exts
14:29:37 <palomer> magic
14:31:57 <int-e> vincenz: in a newtype?
14:32:13 <vincenz> yeah
14:32:17 <vincenz> or data
14:32:36 <int-e> vincenz: newtype Foo = Foo <something that's a monad> deriving Monad works - it just creates the appropriate (un)wrappers. I don't think it works for a data.
14:32:56 <jethr0> vincenz: btw, i wrote unit tests for the voting function and your impl. passed instantly :)
14:33:02 <vincenz> jethr0: cool :)
14:33:08 <jethr0> i was impressed
14:33:31 <vincenz> and that was written in one go :D
14:34:02 <jethr0> exactly. i didn't test my own version, to remain in the phantasy that mine works too...
14:34:07 <vincenz> hehe
14:34:33 <vincenz> jethr0: for some reason  Ihave no VvoteTest.hs
14:34:43 <jethr0> it's in Server.hs
14:34:54 <vincenz> removed VoteTest
14:34:55 <vincenz> ?
14:34:59 <jethr0> i have some library issues
14:35:04 <jethr0> vincenz: ah sorry
14:35:31 <vincenz> WOAH
14:35:35 <jethr0> i compiled gtk2hs with profiling enabled, but now i can compile _only_ with profiling enabled :(
14:35:50 <vincenz> :/
14:36:02 <B0neTruper> hey ppl
14:36:38 <Cale> hello
14:43:01 <palomer> hullo
14:43:12 <jethr0> hullu
14:47:08 <vincenz> @where c2hs
14:47:09 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
14:47:52 <vincenz> dcoutts: ping
14:48:53 <vincenz> what kind of grammars can parsec handle?
14:51:28 <jethr0> ll, but some context sensitve ones too
14:52:02 <lennart> mmmm, parsek :)
14:52:05 <vincenz> ll > lr?
14:52:09 <jethr0> It can parse context-sensitive, infinite look-ahead grammars but it performs best on predictive (LL[1]) grammars
14:52:12 <jethr0> ll < lr
14:52:26 <vincenz> hmm
14:52:27 <jethr0> ll(x) < lr(x)
14:52:33 <geneticp_> hi
14:52:40 * vincenz should really buy a book on parsing
14:52:41 <jethr0> but most parser generators are lr(1), and parsec is ll(n)
14:53:01 <geneticp_> I got  "ghc.exe: unknown package: posix"
14:53:02 <jethr0> still, there are some lr-grammars parsec won't be able to parse
14:53:09 <vincenz> jethr0: fr inistnace?
14:53:14 <vincenz> for instance even
14:53:24 <jethr0> i'd have to look an example up in one of my compiler books :)
14:53:38 <lennart> parsec fails on anything left recursive
14:53:50 <jethr0> yes, but you can remove left recursion
14:53:53 <Lemmih> geneticp_: Try '-package unix'.
14:54:03 <vincenz> jethr0: could you in theory parse c++?
14:54:04 <lennart> jethr0: sure
14:54:05 <Cale`> you can use chainl to avoid left recursion
14:54:15 <jethr0> Lemmih: as lr parsers fail on right recursive grammars
14:54:39 <lennart> lr parsers don't fail in the same way, normally
14:54:42 <jethr0> vincenz: for _really_ complex grammars the manual approach of parsec seems error prone
14:54:50 <vincenz> jethr0: what do you suggest?
14:54:53 <jethr0> and i'd prefer real generation from a BNF grammar
14:55:01 <geneticp_> okay, Im a dummy ugly bloody newbie unwortly of being helped, but.... anyone knows why I have this compilation message... "ghc.exe: unknown package: posix"  ?
14:55:07 <jethr0> take one of the many yacc/bison clones
14:55:36 <lennart> i much prefer combinator parsers because they have abstraction
14:55:40 <geneticp_> tell me or die forever
14:55:57 <edwinb> I've recently found it useful to be able to add grammar rules dynamically.
14:56:09 <jethr0_> sry, disconnected
14:56:18 <vincenz> jethr0: c++ ain't doable by yacc
14:56:19 <jethr0_> vincenz: what do you need to parse?
14:56:22 <edwinb> But I usually prefer happy because it tells me when I've been stupid in some definable way...
14:56:35 <jethr0_> vincenz: there is a nearly complete subset of c++ for yacc
14:56:55 <jethr0_> but especially the template stuff is AFAIK non-lalr(1)
14:57:54 <musasabi> geneticp_: there is no package called posix shipping with GHC
14:58:04 <edwinb> geneticp_: you may mean 'unix' rather than posix?
14:58:05 <jethr0_> @google jim roskind lalr
14:58:06 <lambdabot> http://www.empathy.com/pccts/roskind.html
14:58:06 <geneticp_> thanks
14:58:19 <vincenz> that link does not exist anymore
14:58:22 <jethr0_> vincenz: that's a c++ grammar as lalr(1)
14:58:25 <vincenz> I know tha tGLR is the way to go
14:58:39 <jethr0_> tglr?
14:58:47 <geneticp_> but in the makefile for the haskell web server, it uses a  "-package posix" option....
14:58:58 <vincenz> ooh
14:59:01 <vincenz> happy can do glr :)
14:59:18 <geneticp_> it is posix, not unix
14:59:38 <jethr0_> vincenz: why do you want to parse c++?
14:59:47 <edwinb> hmm, the docs I'm looking at now call the package 'unix'...
15:00:02 <jethr0_> vincenz: btw, i seem to remember that you found parsing pretty uncool :)
15:01:24 <geneticp_> -packae unix does not work too
15:01:46 <Lemmih> geneticp_: Using Windows?
15:01:52 <geneticp_> yes
15:01:57 <geneticp_> I confess that
15:02:23 <jethr0_> geneticp_: that might be a problem if the application needs a real posix subsystem
15:02:27 <geneticp_> I have posix mentioned in the GHC documentation...
15:02:30 <jethr0_> cygwin?
15:02:34 <geneticp_> yes
15:02:34 <Lemmih> Well, then you can't use Haskell software which depends on System.Posix, iirc.
15:02:56 <vincenz> jethr0_: right but I need to parse c++
15:03:21 <geneticp_> but cgywin simulares all the posix standard , as far as I know
15:03:30 <jethr0_> vincenz: _why_? parsing full c++ is sth not to be taken lightly. what for?
15:03:33 <edwinb> I don't think there is a cygwin ghc binary though is there?
15:03:56 <edwinb> so ghc knows nothing of such things...
15:04:13 <vincenz> jethr0_: it would be useful to my work?
15:04:43 <jethr0_> if you told me what you need it for, maybe i could make suggestions how to get around writing a full c++ parser. which is IMHO a humongous task
15:04:43 <geneticp_> but the package posix implements the poxis API calling win32 primitives directly
15:05:18 <geneticp_> I guess
15:05:24 <edwinb> does it?
15:05:31 <geneticp_> i suppose that
15:05:36 <Lemmih> geneticp_: Did you install GHC from source?
15:05:42 <edwinb> "Portabilitynon-portable (requires POSIX)"
15:05:44 <edwinb> It Says Here
15:06:01 <geneticp_> it does that way with file handling and so on...
15:06:36 <geneticp_> I installed it form a windows installable binary
15:07:43 <Lemmih> I doubt that the Windows binary ships with the (Haskell) posix library.
15:08:40 <sh> I'm a beginner in Haskell.. Does anyone know any site that has tons of source codes? except Haskell.org?
15:08:51 <geneticp_> requires posix, I see
15:09:27 <geneticp_> no, sorry. I installed  binary distribution for windows
15:09:38 <jethr0_> sh: http://paste.lisp.org/list  , channel #haskell
15:09:39 <Lemmih> sh: scannedinavian.com/~lemmih/
15:09:43 <geneticp_> and posix is not included
15:10:05 <sh> Thanks guys.
15:10:21 <geneticp_> merde
15:10:31 <geneticp_> thanks too
15:10:45 <jethr0_> vincenz: http://www.parashift.com/c++-faq-lite/compiler-dependencies.html#faq-38.11
15:14:04 <jethr0_> vincenz: since you're not replying... you could for example write a backend for gcc, and thus work only on gcc intermediate language/abstract syntax tree...
15:16:46 <vincenz> no
15:16:52 <vincenz> cause I need to do source-to-source trafos
15:17:29 <jethr0_> this is getting more and more evil ^_^
15:17:39 <vincenz> ooh nice
15:17:41 <vincenz> a yaccable version
15:17:57 <vincenz> how hard you reckon it is to port this to haskell
15:18:18 <jethr0_> unless very restricted, source trafos in a language like c++ can wreak unimaginable havoc 
15:19:02 <jethr0_> last time i looked at the annotated grammar it was huge. i would seriously suggest you not to do this
15:19:14 <jethr0_> i am not sure if you are aware of the magnitude of this project
15:21:04 <SamB> there is that gcc-xml thing that will parse C or C++ and spit out an XML tree, I think
15:21:05 <jethr0_> but as far as porting the yacc file to sth haskell is concerned i think it's very doable
15:21:15 <jethr0_> nice
15:21:35 <vincenz> jethr0_: trust me in knowing what I'm doing
15:22:04 <jethr0_> Why are C++ function bodies not dumped in XML?
15:22:06 <jethr0_> The original sponsors of the project had no need for function bodies.
15:22:21 <jethr0_> "Is there a DTD specifying the XML format dumped? Not currently. "
15:22:42 <jethr0_> "Why don't I see templates in the output? This feature has not been implemented"
15:22:45 <jethr0_> :)))
15:22:52 <jethr0_> vincenz: k
15:24:10 <jethr0_> i'll stop pestering you :)
15:28:26 <jethr0_> afk
15:37:56 <dcoutts> vincenz, pong
15:39:04 <dcoutts> jethr0_, so how did you compile gtk2hs with profiling enabled? I'm interested. I might be able to extend the build system to make that a bit easier (and have it build both profiled and normal versions.)
15:41:03 <Lemmih> Isn't it just a matter of passing --enable-library-profiling to the gtk libraries?
15:42:57 <jethr0_> dcoutts: i really didn't know what i was doing and still don't :)
15:43:04 <vincenz> dcoutts: hiya
15:43:18 <dcoutts> Lemmih, gtk2hs doesn't use cabal, so no
15:43:24 <dcoutts> yet.
15:43:34 <dcoutts> I want to get it using cabal
15:43:35 <jethr0_> dcoutts: i set -hcflags=-prof
15:43:51 <dcoutts> jethr0_, right
15:44:03 <jethr0_> dcoutts: sry, gotta go. i'll be back in an hour or so.
15:44:07 <dcoutts> np
15:44:26 <dcoutts> vincenz, you pinged me
15:44:36 <vincenz> yi
15:44:41 <vincenz> but no longer an issue
15:46:38 <vincenz> does happy come with ghc?/
15:47:47 <dcoutts> vincenz, no, happy is separate
15:47:55 <dcoutts> @where happy
15:47:55 <lambdabot> http://www.haskell.org/happy/
15:47:56 <vincenz> okies
15:49:13 <vincenz> ubuntu has a package :D
15:51:12 <vincenz> how about a lexer?
15:52:14 <musasabi> alex
15:52:51 <musasabi> NIH-syndrome sneaking up?
15:56:01 <dcoutts> I'd love to send in the c2hs C parser as a standard lib Language.C.Parser except that I still can't solve this typedef'ed name issue
15:56:29 <dcoutts> peehaps I should post it on the libs list and see if anyone else can help fix it
15:56:52 <dcoutts> it'd probably want a different AST too
15:57:33 <dcoutts> or even no AST, just take a parse-tree fold functions
15:58:05 <dcoutts> since different people have different uses for a C parser
16:09:58 <dcoutts> @seen dons
16:09:58 <lambdabot> dons is in #haskell. Last spoke 12 hours, 6 minutes and 20 seconds ago.
16:12:16 <Mitar> is it possible to eta reduce this: isunit x = (&&) (1 == length x) (isNonTerminal . head $ x)
16:12:22 <Mitar> @eta isunit x = (&&) (1 == length x) (isNonTerminal . head $ x)
16:12:22 <lambdabot> Maybe you meant: eval vera
16:13:59 <Mitar> @eval isunit x = (&&) (1 == length x) (isNonTerminal . head $ x)
16:14:00 <lambdabot>  parse error on input `='
16:14:07 <Mitar> @help
16:14:08 <lambdabot>  @help <command> - ask for help for <command>
16:14:09 <dcoutts> isunit [x] = isNonTerminal x
16:14:15 <dcoutts> isunit _ = False
16:14:58 <dcoutts> Mitar, how about that?
16:15:34 <Mitar> oho
16:15:39 <Mitar> not bad
16:32:53 <jethr0_> dcoutts: --with-hcflags="-prof"
16:33:32 <dcoutts> jethr0_, and that worked ok? (appart from it then only produced profiled libs)
16:33:35 <jethr0_> problem was, i tried doing "-hisuf p_hi", but then it wouldn't compile because of non-generic makefiles
16:33:42 <dcoutts> right
16:33:45 <jethr0_> so i compiled, and moved all .hi files to .p_hi.
16:33:50 <dcoutts> ah I see
16:34:01 <jethr0_> as well as the libraries .a to _p.a
16:34:03 <dcoutts> because ghc only looks for .p_hi right?
16:34:12 <dcoutts> I see, hmm
16:34:18 <jethr0_> but now i can only use the profiled version :)
16:34:28 <jethr0_> so, that's only been a partial success
16:34:56 <jethr0_> and recompiling that thing takes pretty long...
16:37:20 <jethr0_> i guess if i moved .hi and .p_hi files together i could compile  normally again. but this solution is a quick hack at best
16:39:50 <dcoutts> jethr0_, I'll look at the makefiles and see if it might not be too hard to support profiled versions
16:40:32 <jethr0_> i ought to have done that myself. but it seemed a bit overwhelming at the time :)
16:44:36 <vincenz> how has worked with hs-pluginis
16:44:46 * vincenz is wondering about the complexity of unsafeEval
16:46:32 <dcoutts> jethr0_, sure, the gtk2hs build system is sadly not terribly easy to hack on.
16:46:49 * SimonRC goes to bed
16:47:20 <jethr0_> vincenz: i had a talk about hs-plugins with dons too
16:47:34 <vincenz> ah coo
16:47:41 <vincenz> btw is this gonna enter ghc-libs?
16:47:45 <vincenz> it looks easy tho
16:47:47 <vincenz> just have
16:47:53 <vincenz> "xxx" :: IO (Maybe Type)
16:48:37 * dcoutts goes to bed
16:48:53 <jethr0_> problem is doing unrestrained stuff with eval and module loading. everything has to go through interfaces and if you want to alter data structures in non-eval'ed code you have to pass them in.
16:49:12 <vincenz> jethr0_: well I don't plan to allow that
16:49:16 <vincenz> just "map selected ..."
16:49:19 <jethr0_> k
16:50:08 <jethr0_> i thought of sth like i once did with python: allowing unrestrained code (at least non-io) in a "shell". so i could alter c++ data structures at program runtime
16:50:27 <jethr0_> "map selected"?
16:50:38 <vincenz> jethr0_: where selected = selected nodes
16:50:57 <jethr0_> uhu
16:51:20 <vincenz> "concat $ map Gr.suc selected"
16:51:55 <vincenz> and you'd see those
16:51:57 <jethr0_> yes, that should be easy
16:52:16 <vincenz> a few small typing issues involved, but overall it should be ok
16:52:42 <SimonRC> anyone know of Guile bindings for Haskell?
16:52:54 <SimonRC> Should be fairly simple to write if not.
16:53:29 <jethr0_> vincenz: as long as the interface is simple, there are no real typing issues AFAI can see
16:53:53 <jethr0_> SimonRC: scripting haskell with scheme would certainly add a nice touch :)
16:54:29 <SimonRC> Well, GNU went to all that effort inventing it, so someone ought to use it :-)
16:54:38 <jethr0_> SimonRC: you want it for a gnu project? otherwise, why not script haskell with haskell
16:55:06 * SimonRC thought that that would be rather tricky.
16:55:06 <jethr0_> SimonRC: "inventing"? i thought it was mainly scheme with a bit of interoperability on top?
16:55:13 <jethr0_> SimonRC: why?
16:55:26 <vincenz> SimonRC: you can use hs-plugins :D
16:55:41 <SimonRC> hmm, maybe not too ahrd
16:55:42 <vincenz> eval "randomcode" :: IO (Maybe Type)
16:55:44 <Lemmih> hs-plugins is a dirty hack.
16:56:20 <vincenz> be nice if ghc built it in without hacks
16:56:20 <SimonRC> vincenz: ouch
16:57:47 <jethr0_> Lemmih: ghci too?
16:58:51 <Lemmih> jethr0_: No, GHCi compiles to bytecode.
16:59:12 <jethr0_> k
17:02:29 <dons> thanks Lemmih ;) i would at least say it's a nice interface to the dynamic linker.. :)
17:03:08 <dons> but ghc-api is the future for eval (except for specialised high-perf progs needing native code perhaps)
17:03:39 <Lemmih> I meant no disrespect. It's a /useful/ dirty hack (:
17:03:58 <dons> I know , I'm teasing :)
17:04:27 <jethr0_> dons: is there a chance of having a linkable scripting thingey (like guile) for haskell someday
17:04:38 <dons> yep, with ghhc-api
17:04:43 <jethr0_> or does haskell's static character make that nonsensical?
17:04:44 <dons> embed ghci in your prog
17:04:48 <jethr0_> yup
17:04:49 <dons> nope.
17:05:06 <dons> check the hs-plugins paper. you just type check fragments as you splice them in.
17:05:16 <jethr0_> dons: i've read all about it :)
17:05:39 <jethr0_> dons: btw, why'd you use TH in your unit tests in the icfp entry?
17:06:22 * vincenz would like to see dons' entry
17:06:38 <jethr0_> almost done
17:09:44 <jethr0_> there was someone in here yesterday who wanted to do a serial line protocol in haskell. are there any precedents/examples?
17:09:58 <jethr0_> i guess it wouldn't be to hard..
17:13:00 <dons> TH is there as sugar for the unit testing.
17:13:15 <dons> it's stefanw's nice layer over hUnit
17:31:02 <dons> is this graph a sign about what's happening to the language: http://dir.gmane.org/gmane.comp.lang.haskell.cafe
17:32:52 <jethr0_> at the end of the year haskell-cafe seems to peak (based on a sample size of 2)... projecting short term history, negative traffic will be eating up past posts soon.
17:36:03 <musasabi> haskell-prime has seen a very large number of posts
17:58:23 <dons> musasabi, if you have time, there are entries on the wiki for nbody, spectral-norm and recursive. the spectral-norm one is a fix for a gcc bug, and recursive is an attempt to run a bit faster. nbody  is Chris' stuarray version.
17:59:40 * musasabi looks at the wiki
18:02:58 <araujo> Hello !
18:03:34 <araujo> Im forking two consecutive threads, is there a way in which i can give more priority to one of them?
18:04:41 <musasabi> spectral-norm committed.
18:06:22 <musasabi> dons: is -funbox-strict-fields allowed in {-# OPTIONS ?
18:07:53 <musasabi> recursive committed.
18:09:28 <dons> ,yes, regarding -funbox-strict-fields, it is legal.
18:11:07 <musasabi> ok, I added it as options pragma and committed nbody too.
18:13:07 <dons> cheers.
18:20:30 <dons> joelk, sorry, it's your nbody entry that is fastest :) 
18:25:23 <dons> ah!! Alson Kemp gets a beer. he wrote a regex-dna entry that uses parsec( brilliant), that runs in 20 seconds or so.
18:25:48 <dons> instead of > 1 hour
18:26:44 <dons> and it is pure H98.
18:29:30 <jethr0_> dons: i thought it had to be done using regular expressions...
18:29:58 <jethr0_> @shootout
18:29:59 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
18:29:59 <lambdabot> all
18:32:05 <jethr0_> nice. i've always (i.e. for the last 6 months) said how cool haskell is :)
18:32:33 <dons> parsec provides regexes -- that's the great idea
18:32:52 <jethr0_> :)
18:33:16 <dons> then entry hasn't be profiled yet, so I thikn we can do really well here.
18:34:10 <tony2> are other communites throwing as much effort in to the shootout does anyone know?
18:34:33 <dons> Ocaml and  SML have, previously.
18:34:42 <dons> and the C guys havve some kind of grand plan, apparently
18:36:38 <tony2> I'm sure they do. It helps not to have a grand plan in C though I find. Normally to busy with the detail.
18:37:20 <jethr0_> dons, i'd be profiling the code now. does that make sense?
18:37:29 <jethr0_> or is chris working actively on it?
18:39:10 <jethr0_> hmm, output differs from reference output...
18:42:40 <jethr0_> ah, sry, i gave it htmlized input *ups*
18:43:20 <dons> hehe
18:43:30 <dons> it's not a legal entry though, yet.
18:43:39 <dons> it doesn't use regexes for the cleaning pass, for one.
18:44:08 <jethr0_> hmm
18:51:34 <dons> should be easy to write a pure parsec version. it would be a good advertisement for haskell
18:52:08 <jethr0_> cool, should i try?
18:52:31 <jethr0_> you mean not trying to adhere to the regex necessity?
18:53:03 <dons> sure, go for it. there's plenty of fame for you if you can do it :)
18:53:24 <dons> just use parsec-based regexes
18:53:47 <jethr0_> hmm
18:53:58 <int-e> hmm. I envision a Parsec based parser that generates Parsec parsers ...
18:54:18 <jethr0_> i actually considered parsing reg-expressions with parsec and generate an determistic automaton from it
18:54:26 <jethr0_> because i couldn't believe that haskell should be so slow
18:54:31 <dons> I think a good argument can be made that the regexes don't have to be "some .* string*" style.
18:54:47 <jethr0_> what do you mena by "parsec-based regexes"?   <|>, many, ...
18:56:44 <int-e> oh. or just provide a proper read instance for that Pattern type. That shouldn't be hard either. (yes, I agree that it shouldn't be a fundamental requirement)
18:56:50 <jethr0_> the ruby entry is actually painfully pretty :)
18:57:06 <jethr0_> it's like 3 lines of real code!
19:03:27 <dons> oh, a read that produces parsec combinators, that'd be clever
19:03:38 <jethr0_> :), nice idea
19:03:56 <jethr0_> you could implement the read in parsec, too
19:04:09 <dons> then there's no problem convincing non-haskellers that it isn't a regex -based entry
19:04:22 <jethr0_> could get longer than 23 lines though
19:04:59 <dons> doesn't matter here.
19:05:09 <dons> we get 10 points or so if we enter anything
19:05:18 <dons> no points at all if we timeout
19:19:26 <SamB> could make a library out of it too
19:19:32 <jethr0_> hmm
19:19:40 <jethr0_> i'm trying to unit test parsec stuff.
19:19:53 <jethr0_> but i'm having slight problems with the monadicity :)
19:19:59 <SamB> hmm?
19:20:13 <jethr0_> hunit is inside a monad, as is parsec...
19:20:20 <SamB> runParser?
19:20:25 <jethr0_> ah, right
19:20:49 <jethr0_> sry, stupid me
19:20:55 <jethr0_> shouldn't be coding this late
19:20:59 <SamB> no problem, not really stupid
19:21:08 <jethr0_> SamB: btw, i'm still eagerly awaiting your BF tut :)
19:21:09 <SamB> well, maybe stupid atm
19:21:37 <SamB> oh, yeah, I need to type in some stuff I have in a notebook...
19:23:46 <jethr0_> :), just telling you that you have a motivated audience *poke*
19:24:49 <SamB> thanks ;-)
19:25:40 <SamB> ouch, don't poke there, that hurts!
19:25:43 <jethr0_> now
19:26:14 <jethr0_> this is the time it took me to set my unit test up :( 15 minutes
19:26:50 <jethr0_> man, i'll be glad when haskell will be more like a reflex... why did i ever spend so much time with all these other languages
19:26:56 * jethr0_ sighs
19:47:58 <jethr0_> dons, samb?
19:50:39 <jethr0_> parsec anyone?
20:03:04 <araujo> Anybody goiod with concurrenmcy could giove me some insights about this problem:
20:03:06 <araujo> getProcessExitCode: interrupted (Interrupted system call)
20:03:23 <jethr0_> in what context?
20:03:30 <araujo> I keep getting that while forking two processes.
20:03:30 <jethr0_> operating system?
20:03:43 <araujo> Gentoo linux
20:03:46 <jethr0_> are you calling getProcessExitCode yourself?
20:04:12 <araujo> jethr0_, yes
20:04:30 <araujo> jethr0_, im using it to check when the process finished
20:04:43 <jethr0_> "when"?
20:05:01 <araujo> No.
20:05:24 <araujo> Using my own looping function
20:05:41 <jethr0_> not good. you're supposed to sleep while you're waiting
20:05:48 <jethr0_> blocking wait
20:05:52 <araujo> So it tests the value of getProcessExitCode, and if it gets the exitcode finishes.
20:06:10 <jethr0_> waitForProcess
20:06:16 <araujo> mmm... ok, let's see
20:06:34 <jethr0_> active waiting is evil. is results in 100% cpu load
20:06:34 <araujo> jethr0_, i should wait inside the same thread right?
20:06:52 <jethr0_> huh?
20:06:56 <araujo> Because im doing something like :
20:07:20 <araujo> forkIO $ do ... runInteractiveProcess 
20:07:27 <araujo> forkIO $ do ... other functions
20:07:43 <jethr0_> yes...
20:07:51 <araujo> jethr0_, so i imagine i should wait inside each thread?
20:08:41 <jethr0_> you want to synchronize N threads with on other thread?
20:08:45 <jethr0_> one
20:08:56 <jethr0_> could you paste some code, i'm not following you
20:10:51 <araujo> jethr0_, i just actually wanna them running in parallel if possible.
20:11:01 <jethr0_> that's the idea of threads :)
20:11:07 <araujo> Right :-)
20:11:27 <araujo> it's just that gives me the impression im not getting that behaviour :-P
20:11:36 <araujo> But i'll give a try with waitForProcess
20:11:48 <int80_h> hi guys
20:11:51 <araujo> jethr0_, though as far as i know, waitForProcess blocks all the threads in the oprocess?
20:11:54 <Roboguy> Hello
20:12:24 <jethr0_> araujo: i'm not sure. but i'm pretty sure it only block the thread that calls it
20:12:28 <jethr0_> Roboguy: hi
20:12:38 <int80_h> this is not channel approporiate but I thought I would turn to the haskell people for some direction. I'm looking for a channel that can advise me on pc hardware purchases.
20:12:41 <jethr0_> otherwise it would _never_ return
20:12:49 <int80_h> I have no idea which one...perhaps #hardware?
20:14:25 <araujo> jethr0_, ok, let's give it a try
20:15:12 <jethr0_> araujo: i'm 95% certain that it's exactly what you're looking for
20:15:21 <Cale> ahh, so much better. Man that router sucked.
20:20:21 <jethr0_> man, arbitrarilyw
20:20:53 <jethr0_> nested reg-exps are harder to parse than i thought...
20:20:58 <jethr0_> but i'm getting there
20:34:13 <araujo> mm... nothing
20:34:40 <araujo> jethr0_, but what exactly could mean this getProcessExitCode error?
20:34:56 <jethr0_> you mean, no change?
20:35:03 <jethr0_> are you still running through your loop?
20:35:08 <araujo> it blocks all the process now :-/
20:35:12 <araujo> No.
20:35:30 <araujo> Now, now it blocks all the process.
20:35:32 <jethr0_> "(Interrupted System Call)" is bad
20:35:34 <araujo> No*
20:35:55 <jethr0_> could you please paste code?
20:36:54 <araujo> ok, let me clean it a bit
20:37:04 <jethr0_> not necessary, i just need an overview
20:37:47 <araujo> no, but i mean, i got it around a bunch of files :-P
20:38:02 <jethr0_> i don't need all of it :)
20:39:00 <araujo> ok :-]
20:39:48 <araujo> lisppaste2, help?
20:39:48 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:43:34 <lisppaste2> araujo pasted "concurrency" at http://paste.lisp.org/display/16498
20:43:45 <araujo> jethr0_, there you got it :-)
20:46:52 <jethr0_> k
20:47:21 <jethr0_> you can't do a blocking wait, because you want to update the visualization
20:47:46 <jethr0_> you shouldn't actually need the forkIO before runInteractiveProcess
20:47:53 <jethr0_> because rIP already forks itself
20:48:22 <jethr0_> where is/was your loop?
20:50:13 <araujo> mm.. let's see
20:51:02 <araujo> jethr0_, updateBarWithTask and showOutput
20:51:10 <araujo> Those are the two loops i talked
20:52:12 <jethr0_> but showOutputLoop is looping too fast
20:54:17 <araujo> mmm...
20:56:12 <jethr0_> maybe a delay?
20:57:31 <araujo> Ok, i just did something following your advise, and it seems not getting that error anymore
20:57:52 <araujo> well.. i actually just removed the forkIO of the rIP
20:58:11 <araujo> jethr0_, ok, let me try with a delay too
20:58:30 <araujo> Because now it seems like showOut is stealing the exit code of progressBar :-)
20:58:37 <jethr0_> k, maybe he didn't like splitting twice at the same location/time
21:00:25 <araujo> *nods*
21:00:40 <araujo> jethr0_, there exist now some kind of race condition for the exitcode
21:01:40 * araujo testing with several delays level
21:01:41 <jethr0_> with what effect?
21:03:29 <araujo> jethr0_, with the effect that *sometimes* each function gets the value of the other :-/
21:04:12 <araujo> mm.. it's more like a synchronization problem....
21:04:34 <jethr0_> ?? "value of the other"?
21:04:44 <jethr0_> they're both querying the exitstatus of the same thread!
21:05:09 <araujo> jethr0_, uhu :-P
21:05:28 <araujo> mm...
21:05:39 <araujo> jethr0_, seems pretty much solved now with a delay inside showOut
21:05:58 <jethr0_> "pretty much solved" :)
21:06:09 <araujo> haha
21:06:19 <jethr0_> sounds like you're giving up
21:06:28 <araujo> haha
21:06:30 <araujo> never!
21:06:51 <araujo> well.... both functions are receiving the correct values now it seems...
21:07:07 <araujo> and im not getting this exitcode error anymore....
21:07:20 <araujo> jethr0_, wanna see new code?
21:07:56 <jethr0_> sure
21:08:10 <araujo> The *weird* thing is that, if i remove the showOut function, it receives again this exitcode error... which i particulary don't understand at all..., let's see if you can give me some insights about it too.
21:10:43 <lisppaste2> araujo pasted "concurrency 2" at http://paste.lisp.org/display/16499
21:10:50 <araujo> there we go
21:16:20 <araujo> jethr0_, the weirdest thing really, and that i yet don't fully understand is that if i remove "forkIO $ showOutput out ph"
21:16:26 <araujo> it gets the exitcode error
21:17:38 <jethr0_> uh
21:17:52 <jethr0_> why don't you ever kill the output thread?
21:18:17 <jethr0_> i have no idea why it should behave like that. but then i've got my own haskell forking problem :)
21:18:33 <araujo> haha
21:18:39 <araujo> oh, yeah, missed that one, thanks
21:19:02 <araujo> jethr0_, aren't they sweet? :-)
21:19:11 <jethr0_> who?
21:19:38 <jethr0_> i'm doing a runInteractiveProcess and then after an indeterminate time the running process dies with a SIGPIPE
21:19:59 <jethr0_> and the behaviour changes when i use strace to try to find out what happens. _that_'s annoying
21:20:15 <araujo> jethr0_, the forking problems :-)
21:20:57 <jethr0_> well, i'd say "at least it's better than in c", but c was really kinda written around "fork" :)
21:21:46 <araujo> forking problems are like women, you just can't understand them :-]
21:22:17 <araujo> jethr0_, well, C is.. well... C :-P
21:24:34 * araujo gives other try removing showOut
21:25:42 <araujo> mm.. this is weird...
21:28:47 <Cale> Well-C is a subterranean-level programming language for bucket management.
21:29:58 <jethr0_> Cale: hmm, for forking it's pretty close to the (unix) OS
21:30:37 <Cale> um, that was a joke :)
21:30:40 <araujo> ive used fork in C several times... but very simple things, 
21:30:49 <araujo> i think Haskell makes it far easier and better
21:31:04 <Cale> (think of the other sort of 'well' :)
21:31:21 <araujo> Cale, sure, we all know well-C is a contradiction :-)
21:31:29 <Cale> heh
21:33:18 <Cale> Well-C supports low-level dihydrogen monoxide resource management.
21:34:34 <araujo> jethr0_, seems working pretty well here now.... though i can't remove the showOut :-/
21:36:09 <jethr0_> no idea
21:36:58 * araujo thinks it's ok becaus ehe needs that function anyway, though he'd like to understand why happens
21:37:25 <araujo> Thanks for the help jethr0_ 
21:39:14 <jethr0_> np
21:40:00 <user317> what does the => mean in a signature?
21:41:27 <jethr0_> i can't say it in the correct terms, but the part before the "=>" is a type restriction
21:41:37 <Roboguy> It defines a context.  Basically, it defines what type classes the type variables have to be an instance of.
21:42:03 <jethr0_> therefore "(Num a) => a -> a" means: a function taking a "Num"ber and returning a "Num"ber
21:42:14 <triplah> so Int=>Int would define a function that takes an int and returns an int
21:42:16 <user317> oh i see
21:42:18 <SamB> constraints, the things on the left are called
21:42:27 <SamB> triplah: no
21:42:30 <jethr0_> triplah: that confused me
21:42:31 <Roboguy> triplah: No, that would be Int -> Int
21:42:36 <triplah> yeah :)
21:42:51 <user317> you mean (Int a) => a -> a 
21:42:58 <SamB> user317: no!
21:43:07 <jethr0_> they are like meta-bindings
21:43:09 <Roboguy> user317: That would only work if Int was a type class
21:43:26 <SamB> @type (`div`2)
21:43:27 <lambdabot> forall a. (Integral a) => a -> a
21:44:58 <Roboguy> jethr0_: Well, maybe more like meta-meta-bindings.
21:45:17 <jethr0_> Roboguy: you're right
21:45:27 <user317> so in this tutorial they define "mapTreeM :: Monad m => (a -> m b) -> Tree a -> m (Tree b)"  basically it tells me that m is a Monad?
21:46:20 <Roboguy> Pretty much.  It says that m is an instance of the Monad type class.  Which basically means it's a monad.
21:46:44 <user317> oh i think i get it
21:50:37 <user317> so what does that function return?
21:50:52 <jethr0_> a tree in a monad
21:51:05 <sh> Hi guys, I'm a newbie in Haskell, and want to implement Djiksta's shortest path...Can anyone let me where I should start? 
21:51:14 <jethr0_> so, if we're talking about Maybe monad, it returns a "Maybe (Tree b)"
21:51:31 <jethr0_> sh, have you got a graph representation to work on?
21:51:36 <sh> I know the algorithm and did it in other non-functional languages.
21:52:29 <sh> jethr0_,  I would work on data such that lines have src dst weight. 
21:52:37 <Roboguy> sh: Well, convert the loops to recursion and/or foldr/foldl/map and get rid of the mutation (or use the State monad) =)
21:53:14 <jethr0_> i meant rather how you'd lookup the successors or a node
21:53:22 <sh> Roboguy, thanks, but what about priority queue? 
21:53:29 <jethr0_> and if you've done it before, it should be no harder in haskell :)
21:53:29 <Roboguy> What about it?
21:53:48 <Roboguy> How would you make the data type?
21:54:01 <sh> Roboguy, Does haskell have that kinda structure?
21:54:06 <Roboguy> Yes
21:54:14 <user317> so is the first argument (a -> m b), a function that returns a monad?
21:54:18 <Roboguy> Well, depends on what you mean
21:54:33 <Roboguy> Do you mean does it specifically have a priority queue?
21:54:41 <sh> jethr0_, ya, people say that..but for me, it's kinda hard to think in Haskell way.
21:54:59 <sh> Roboguy, yes, or can I implement it?
21:55:13 <jethr0_> at least there's Data.Queue.
21:55:17 <Roboguy> Yes, you can implement it.  Not sure if the standard library has it (I kind of doubt it though)
21:55:28 <jethr0_> but it is just a simple queue
21:55:46 <Roboguy> You can definitely define data types in Haskell, if that is what you are asking.
21:56:27 <sh> Oh.. I see.. thank you guys, I'll try, study more and come back to ask later.
22:07:50 <user317> in "mapTreeM :: (a -> State state b) -> Tree a -> State state (Tree b)"   what does (a -> State state b) mean?  does it mean it takes a function that takes a tree and returns a state?
22:08:59 <jethr0_> isn't this possible?   "do x<-func; do {return x}"
22:09:14 <jethr0_> it says "Not in scope: 'x'"
22:10:44 <jethr0_> weird. because sth like "f >>= \x -> g >>= \y -> return (x,y)" works too?!?
22:11:35 <jethr0_> ah, found the problem, i had forgotten one pair of parens
22:20:03 <Cale> Wow, there are a lot of people with strange opinions on the Haskell' list.
22:22:00 <dons> hehe. true..
22:23:01 <Cale> Some of the proposed changes would completely and drastically alter the way that Haskell code looks, and it's not obvious that it would be better.
22:24:38 <Cale> dons: were you around for monad comprehensions?
22:25:09 <dons> that was before my time.
22:25:57 <dons> btw, I suspect that the committee will remember that its job is to only include stable, implemented extensions..
22:26:09 <Cale> What do you think of the idea of bringing them back?
22:26:29 <Cale> They have been implemented. I wonder if the code is still in GHC.
22:26:50 <dons> I'd be ok with that. keeping things safe for newbies is a bit flakey, imo.
22:27:10 <Cale> Personally, I think they're a great complement to the view that monads are an abstraction of container types, which is actually kind of newbie-friendly.
22:27:33 <Cale> We have do-syntax for the dual view that monads are computation types :)
22:34:08 <Cale> I also just had the funky idea that [x1,x2,x3] perhaps should get a monadic (MonadPlus) type. Perhaps that's going too far :)
22:57:51 <user317> i dont get what "tick :: State Int Int" type means
22:58:50 <user317> does it take a state and an integer?
23:01:41 <dcoutts> dons, did you see SyntaxNinja's message about cabal-get?
23:02:00 <dons> yep, expect a reply tomorrow
23:02:27 <dcoutts> dons, so do you think it's reasonable or possible to strip down the deps of cabal-get?
23:03:15 <dcoutts> I thought it could get away with a much simpler http & xml module
23:03:33 <dons> i think it is reasonable, i don't knew yet if it is possible.
23:04:26 <dcoutts> I was looking at the http package, we use very little of it
23:05:03 <dcoutts> similarly I don't believe that we need a full featured xml encoder/decoder
23:05:05 <dons> yeah, we should be able to use mini http perhaps.
23:05:14 <dons> (like lambdabot does)
23:05:19 <dcoutts> afterall we control the server side content
23:05:37 <dcoutts> dons, oh right, there already is a mini http. that's helpful.
23:05:47 <dcoutts> mini xml perhaps?
23:07:13 <Cale> user317: It's a State computation which works on a state of type Int, before returning an Int.
23:07:55 <Cale> user317: It may manipulate the initial state coming in to it into a new state value, and base its response on that state.
23:07:59 <user317> Cale: in the tick example in http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html  how do i use tick?  res <- tick 1 doesnt work
23:08:14 <Cale> res <- tick
23:08:35 <user317> Cale: i dont understand, doesn't it need some initial value?
23:08:59 <Cale> A value of type State s a is internally just a function s -> (a,s)
23:09:16 <Cale> that is, it takes a state, and returns a value and a new state
23:09:43 <Cale> Do notation, or the monad operations, will manage threading the state through.
23:10:16 <Cale> runState, evalState, or execState take an initial state parameter to get things started.
23:10:51 <Cale> you can also use 'put' to set the state to a desired value
23:11:34 <user317> hmm, how would i get a number out of tick?
23:11:50 <Cale> Prelude Control.Monad.State> runState (do x <- get; put (x*2); return (x+1)) 5
23:11:50 <Cale> (6,10)
23:11:52 <dons> mmm. the regex-dna shootout entry down under 30s now :) lazy regex combinators forever!
23:12:44 <jethr0_> dons: i've gotten pretty far with my regex parser :)
23:12:47 <Cale> Prelude Control.Monad.State> let tick = do n <- get; put (n+1); return n in runState (do x <- tick; y <- tick; z <- tick; return (x,y,z)) 1
23:12:48 <Cale> ((1,2,3),4)
23:13:27 <Cale> (note that runState returns a pair consisting of the return value and the final state)
23:14:10 <dons> jethr0, I wrote a completely new entry based on regex combinators. hopefully we could use that to write a fast parsec entry too.
23:14:22 <Cale> user317: does that make sense?
23:14:37 <dons> going from 1 hour to 30s is a pretty good speed up :)
23:14:40 <user317> Cale: i am not sure yet
23:15:00 <Cale> tick increments the state and returns the old state
23:15:02 <user317> Cale: what is x after x<- tick
23:15:19 <Cale> in this example, 1
23:15:27 <Cale> (just an Integer)
23:15:49 <user317> Cale: so its a number?, but how is it 1, when was tick initialized with 0?
23:16:20 <Cale> the second parameter to runState was 1
23:16:31 <user317> oh i see
23:16:58 <Cale> sorry if it was unclear, it was sort of all squashed on one line there :)
23:17:38 <Cale> It's more common to write your computations in a place separate from the runState
23:17:59 <lisppaste2> jethr0 pasted "regexp parser" at http://paste.lisp.org/display/16506
23:18:30 <jethr0_> i've got to switch from PString to PChar, because string is not a legal regexp atom.
23:18:41 <jethr0_> but apart from that i works nicely :)
23:19:02 <jethr0_> oh, and concatenation
23:20:39 <user317> Cale: so runState x 1 should return an integer?
23:21:12 <Cale> runState returns a pair consisting of the return value and the final state
23:21:53 <Cale> In my example, it gave ((1,2,3),4)
23:22:08 <Cale> since I returned (x,y,z), and the final state was 4
23:22:50 <Cale> x, y, and z being the states just before tick was called (since tick returns the old state, not the new one)
23:24:26 <user317> so whats wrong with: x <- tick; putStrLn (show (runState x 1))
23:24:40 <Cale> tick isn't in the IO monad
23:25:06 <Cale> and even if it was, since tick returns an integer, you can't pass it to runState
23:25:14 <Cale> you want
23:25:31 <Cale> let x = tick; print (runState x 1)
23:25:48 <Cale> ( print = putStrLn . show )
23:25:52 <Cale> (it's in the Prelude :)
23:26:57 <user317> let x = tick , is just an alias right?
23:27:04 <Cale> yeah
23:27:22 <Cale> you can also write   print (runState tick 1)
23:27:37 <Cale> which should print (1,2)
23:27:44 <user317> so what type is x in x <- tick?
23:27:58 <Cale> whatever the return type of tick is
23:28:02 <Cale> so, Int
23:28:08 <user317> why cant i print that?
23:28:27 <Cale> you can, but you can't runState it, since it's just an Int
23:28:36 <Cale> also, you can't run tick in the IO monad
23:28:45 <Cale> only in the State monad
23:31:04 <user317> so runState executes tick in the state monad and x  <- tick executes tick in the IO monad, since i am in main.  is that correct?
23:31:15 <Cale> right
23:31:35 <Cale> (and since there's print right after, which also implies you're in IO)
23:32:20 <Cale> runState/evalState/execState produce ordinary pure values too, so there's a guarantee of no side effects in the end
23:32:55 <Cale> and really, the code is just translated into the usual functional-programming idiom of passing an extra parameter around to keep track of state
23:33:17 <Cale> because of the way that return and (>>=) are defined
23:33:50 <user317> i am still not clear on why x <- tick is a of type Int
23:33:56 <palomer> @pl all (==True)
23:33:56 <lambdabot> all (True ==)
23:34:10 <palomer> is there a shorter version to all (==True)?
23:34:19 <Cale> x <- tick in the state monad binds x to the result of executing tick
23:34:21 <palomer> btw, is (op a) the same as (a op) ?
23:34:39 <dons> @type all
23:34:40 <Cale> palomer: no, they're different
23:34:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:34:51 <Cale> palomer: unless op is commutative
23:34:56 <dons> all id  ?
23:35:29 <Cale> user317: do {x <- tick; <code>} = tick >>= \x -> do {<code>}
23:35:39 <Cale> user317: That's the translation
23:36:07 <Cale> (more or less, anyway)
23:36:28 <dons> a [Bool] is not a common type, I wonder if there's something else you should be doing, palomer.
23:36:45 <sieni> palomer: id?
23:36:58 <palomer> how does @pl detect that == is commutative?
23:37:02 <sieni> palomer: (short for (True ==), that is)
23:37:11 <palomer> all (==True) is the same as id?
23:37:21 <palomer> foldl1 && is another good one
23:37:39 <Cale> and
23:37:50 <Cale> > and [True, True, False]
23:37:51 <lambdabot> False
23:37:58 <Cale> > and [True, True, True]
23:37:59 <lambdabot> True
23:38:03 <user317> Cale: so x doesn't have a value untill runState is called?
23:38:12 <Cale> user317: right
23:38:15 <palomer> @hoogle and
23:38:15 <lambdabot> Data.List.and :: [Bool] -> Bool
23:38:15 <lambdabot> Prelude.and :: [Bool] -> Bool
23:38:15 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment.And :: LogicOp
23:38:15 <sieni> well, it's not the same, since id is polymorphic, but it's the same for booleans :-)
23:38:28 <Cale> user317: apart from "whatever the heck tick returns"
23:38:35 <user317> Cale: ok, i think i get it now.  Thanks a lot
23:39:51 <Cale> palomer: note that haskell cleverly doesn't have an infix operator for xor
23:39:58 <Cale> since it's the same as /=
23:40:01 <palomer> all id == and == foldl &&
23:40:14 <palomer> Cale: oh, righto
23:40:26 <palomer> foldl1 &&, that is
23:40:46 <Cale> foldr1
23:41:08 <palomer> oh, right, we want it to work on infinite lists
23:41:15 <Cale> right
23:41:24 <palomer> why do people always use infix `elem` ?
23:41:51 <Cale> because they're thinking of the mathematical "is an element of" symbol.
23:42:01 <palomer> oh yes, epsilon
23:42:09 <palomer> or, rather, that weird epsilon
23:42:17 <Cale> well, stylised epsilon :)
23:42:20 <Cale> yeah
23:42:42 <Cale> It was actually just epsilon for a while, but that's kind of annoying :)
23:42:58 <palomer> for a while?
23:43:00 <palomer> when was this?
23:43:10 * palomer kicks emacs indenting in the nuts
23:43:17 <palomer> oh my, I've gotten used to monads
23:43:22 <palomer> I use mapM everywhere now
23:43:26 <Cale> When set theorists first introduced it, back around 1890 or something.
23:44:15 <Cale> (that's my guess as to when -- I've seen old books which use epsilon for it)
23:44:33 <palomer> bourbaki!
23:44:52 <Cale> ah, quite possibly
23:44:57 <Cale> http://members.aol.com/jeff570/mathsym.html -- this probably has an answer
23:45:19 <Cale> Membership. Peano used the symbol for membership in the introduction to volume I of his Formulaire de mathematiqus, which was published in Turin in 1895, although the introduction itself is dated 1894 (Cajori vol. 2, page 300).
23:45:28 <Cale> hey, my guess was right :)
23:45:49 <Cale> Peano's symbol for membership was an ordinary epsilon ; the stylized epsilon now used was adopted by Bertrand Russell in Principles of Mathematics in 1903 (Julio Gonzlez Cabilln).
23:48:27 <Cale> Use of arrows. Saunders Mc Lane, in Categories for the working mathematician (Springer-Verlag, 1971, p. 29), says: "The fundamental idea of representing a function by an arrow first appeared in topology about 1940, probably in papers or lectures by W. Hurewicz on relative homotopy groups. (Hurewicz, W.: "On duality theorems," Bull. Am. Math. Soc. 47, 562-563) His initiative immediately attracted the attention of R. H. Fox and N. E. Steenrod, whose ... paper u
23:48:28 <Cale> sed arrows and (implicitly) functors... The arrow f: : X (arrow) Y rapidly displaced the occasional notation f(X) (subset of ) Y for a function. It expressed well a central interest of topology. Thus a notation (the arrow) led to a concept (category)".
23:49:28 <palomer> Cale: is there an implication arrow in haskell?
23:49:49 <Cale> nope
23:49:53 <palomer> why not!
23:49:58 <palomer> haskell has everything under the sun
23:50:01 * tic read as "when set terrorists first introduced it...."
23:50:07 <Cale> you can add one yourself
23:50:36 <Cale> also...
23:50:39 <Cale> @hoogle ==>
23:50:40 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
23:51:01 <Cale> is sort of like implication in its use
23:51:33 <palomer> how do I annotate operators?
23:52:04 <Cale> (++) :: Blah -> Blah -> Foo
23:52:19 <Cale> x ++ y = ...
23:54:24 <palomer> @hoogle m Bool -> m Bool -> m Bool
23:54:25 <lambdabot> No matches, try a more general search
23:54:39 <palomer> is there a monadic (==)?
23:54:52 <Cale> liftM2 (==)
23:55:06 <palomer> what's the differente between liftM2 and liftM1 ?
23:55:17 <Cale> @type Control.Monad.liftM2 (==)
23:55:18 <lambdabot> forall a2 (m :: * -> *). (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
23:55:26 <Cale> @type Control.Monad.liftM
23:55:27 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
23:55:31 <Cale> @type Control.Monad.liftM2
23:55:32 <lambdabot> forall r (m :: * -> *) a2 a1.
23:55:32 <lambdabot> (Monad m) =>
23:55:32 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:55:45 <Cale> liftM is essentially fmap
23:55:58 <palomer> I thought that mapM was fmap
23:56:05 <Cale> liftM2 generalises it to 2 parameters
23:56:06 <Cale> mapM is different
23:56:10 <Cale> @type mapM
23:56:11 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
23:56:20 <Cale> @type fmap
23:56:21 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
23:56:58 <Cale> > liftM (+1) [1,2,3,4,5]
23:56:59 <lambdabot> [2,3,4,5,6]
23:57:14 <Cale> > liftM (+1) (Just 7)
23:57:15 <lambdabot> Just 8
23:57:34 <palomer>                 let a ==_ b =  a (lifM2 (==)) b <--this gives me a syntax error
23:58:21 <Cale> let a ==* b = liftM2 (==) a b
23:58:43 <palomer> liftM and mapM are very similar
23:58:52 <Cale> putting an infix operator in parens makes it into an ordinary function syntactically
23:58:59 <palomer> quite frankly, I should be using liftM instead of mapM most of the time
23:59:10 <Cale> well, sort of, but not that similar -- mapM is tied to lists
23:59:23 <palomer> > let (==*) = liftM2 (==)
23:59:24 <lambdabot>  parse error on input `}'
23:59:26 <palomer> > let (==*) = liftM2 (==) in 5
23:59:27 <lambdabot> Add a type signature
23:59:32 <palomer> > let (==*) = liftM2 (==) in 5::Int
23:59:33 <lambdabot> Add a type signature
23:59:36 <palomer> what?
23:59:45 <Cale> and it sequences the results of applying a function to a list
