00:00:00 <Cale> ah, that's still breaking the lines
00:00:24 <Cale> set it to break around 350
00:00:44 <Cale> that should basically never mess up if the limit is 512
00:00:57 <sieni> > [0,-1..]
00:00:58 <lambdabot> [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-2
00:00:58 <lambdabot> 66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-
00:00:58 <lambdabot> -124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,
00:00:58 <lambdabot> -175,-176,-177,-178,-179,-180,-181,-182,-183,-184,-185,-186,-187,-188,-189,-190,-191,-192,-193,-194,
00:00:58 <lambdabot> -226,-227,-228,-229,-230,-231,-232,-233,-234,-235,-236,-237,-238,-239,-240,-241,-242,-243,-244,-245,
00:01:00 <lambdabot> [4 @more lines]
00:01:04 <wolverian> hm, well, cut at the last \b before the max len..
00:01:06 <vincenz> sieni: try take
00:01:13 <vincenz> > take 1 0 $ [0,-1..]
00:01:14 <lambdabot>   Expecting a function type, but found `[a]'
00:01:14 <lambdabot>   Expected type: a -> b
00:01:14 <lambdabot>   Inferred type: [a1]
00:01:16 <vincenz> > take 10 $ [0,-1..]
00:01:17 <lambdabot> [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
00:01:30 <sieni> > [0,-1..-9]
00:01:31 <lambdabot>  Not in scope: `..-'
00:01:35 <sieni> > [0,-1.. -9]
00:01:36 <lambdabot> [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
00:01:46 <vincenz> ouch
00:01:52 <Cale> hehe
00:01:52 <vincenz> that's a parser bug
00:01:56 <Cale> no
00:01:59 <vincenz> :P
00:02:27 <Cale> I think that spaces between operators and what they're applied to should perhaps be mandatory
00:02:54 <ski> > let a ..- b = a + b in [0,-1..-9]
00:02:55 <lambdabot> [0,-10]
00:03:00 <vincenz> > " "*10
00:03:01 <lambdabot>  add an instance declaration for (Num [Char])
00:03:25 <sieni> > let a ..- b = a .. (-b) in [0,-1..-9]
00:03:26 <lambdabot>  parse error on input `..'
00:03:27 <vincenz> > show $ take 10 $ repeat ' '
00:03:29 <lambdabot> "\"          \""
00:03:59 <sieni> show $ show []
00:04:07 <vincenz> > show $ show [][
00:04:07 <sieni> > show $ show []
00:04:07 <lambdabot>  parse error on input `}'
00:04:08 <lambdabot> Add a type signature
00:04:08 <vincenz> > show $ show []
00:04:09 <lambdabot> Add a type signature
00:04:12 <vincenz> > show $ show [] :: Int
00:04:13 <lambdabot> Couldn't match `Int' against `String'
00:04:16 <sieni> > show $ show ""
00:04:18 <lambdabot> "\"\\\"\\\"\""
00:04:24 <sieni> >show $ show $ show ""
00:04:27 <vincenz> it's odd you need a type sig for a list
00:04:33 <sieni> > show $ show $ show ""
00:04:34 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\"\\\"\""
00:04:36 <vincenz> I guess cause Char and other liss are different
00:04:46 <ski> > []
00:04:47 <lambdabot> Add a type signature
00:04:54 <ski> > [] :: [Int]
00:04:55 <lambdabot> []
00:04:59 <ski> > Nothing
00:05:00 <lambdabot> Add a type signature
00:05:03 <vincenz> wait!!!
00:05:13 <vincenz> how does show disambiguate between [int] and [Char]
00:05:22 <dons> @quit trying 356
00:05:22 <vincenz> there's only one list instance
00:05:23 <ski> ?
00:05:29 <vincenz> > show [1,2,3]
00:05:37 <sieni> > show $ show ([]::[Char])
00:05:44 <vincenz> gotta wait
00:05:47 <lambdabot> "[1,2,3]"
00:05:51 <vincenz> > show [1,2,3]
00:05:55 <vincenz> > show ['a', 'b']
00:05:57 <lambdabot> "\"\\\"\\\"\""
00:05:59 <lambdabot> "[1,2,3]"
00:06:01 <lambdabot> "\"ab\""
00:06:04 <vincenz> see...
00:06:05 <vincenz> iti's different
00:06:11 <ski> @type show
00:06:11 <vincenz> how does it do that?
00:06:12 <lambdabot> forall a. (Show a) => a -> String
00:06:13 <sieni> > show $ show ([]::[Int])
00:06:14 <vincenz> there's only one instance for list
00:06:15 <lambdabot> "\"[]\""
00:06:25 <vincenz> instance Show a -> Show [a]
00:06:32 <ski> it doesn't disambiguate
00:06:39 <dons> 'zactly :)
00:06:41 <vincenz> ski: it shows it differently
00:07:10 <vincenz> @fptools show
00:07:11 <ski> instance Show a => Show [a] where shows = showsList
00:07:12 <lambdabot> show not available
00:07:28 <vincenz> ski: and the behaviour is diff for [Int] and [Char]
00:07:32 <vincenz> oh!
00:07:33 <vincenz> duh
00:07:34 * vincenz shuts up
00:07:39 <ski> s/showsList/showList/
00:07:39 <vincenz> showList a ..
00:07:44 <ski> no
00:07:53 <vincenz> and then showList for Char is diff than for others
00:07:58 <ski> the behaviour is different for 'Int' and 'Char'
00:08:03 <ski> exactly
00:08:03 <vincenz> that's what I said
00:08:06 <vincenz> :)
00:10:43 <vincenz> @hoogle [a->a] -> a -> a
00:10:45 <lambdabot> No matches, try a more general search
00:11:17 <vincenz> what has higher prec? . or $
00:11:42 <dons> Prelude> :i ($)
00:11:42 <dons> $ :: (a -> b) -> a -> b         -- Imported from GHC.Base
00:11:42 <dons> infixr 0 $
00:11:42 <dons> Prelude> :i (.)
00:11:42 <dons> . :: (b -> c) -> (a -> b) -> a -> c     -- Imported from GHC.Base
00:11:45 <dons> infixr 9 .
00:11:47 <dons> :)
00:11:59 <vincenz> )mm
00:12:03 <vincenz> 9??
00:12:07 <vincenz> that's incredibly high
00:12:10 <vincenz> so what is funcappl?
00:13:12 <vincenz> dons: concerning decorating the AST do you suggest using a separate data constructor to do the decoration, or stick it straight into the ast?
00:14:30 <dons> paramaterise the AST, no? like ghc: newtype GenCmm d i = Cmm [GenCmmTop d i]
00:14:45 <vincenz> I guess
00:15:01 <vincenz> dons: one type for both exps or stms?
00:15:08 <vincenz> or decorate stms with two parameters and exps wiith one
00:15:18 <vincenz> (where the second for stm is the one for exp)
00:33:11 <srle> [1..10]
00:43:58 <sieni> eek, what does "cannot satisfy dependency fps-any" mean when configuring yi?
00:48:47 <araujo> Hello!
00:49:00 <araujo> that you need fps?
00:49:03 <araujo> @where fps
00:49:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
00:55:35 <sieni> ok
00:57:09 <srle> @help
00:57:10 <lambdabot>  @help <command> - ask for help for <command>
00:57:19 <srle> @h
00:57:20 <lambdabot> Maybe you meant: help hitchcock hoogle hoogle+ .
00:57:28 <srle> @
00:57:29 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose devils dice dict dict-help d
00:57:29 <lambdabot> shapr ghc google help hitchcock hoogle hoogle+ id index jargon join karma karma+ karma- keal kind la
00:57:29 <lambdabot> shootout source spell state todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc to
00:57:47 <srle> @help commands
00:57:47 <lambdabot>  @help <command> - ask for help for <command>
00:58:07 <srle> 1 + 2
00:58:33 <srle> How to use lambdabot to evaluate expressions?
00:58:38 <gour> dons: building of fps with ghc-head fails with: Data/FastPackedString.hs:1142:0: Parse error in pattern
00:59:13 <joelk> > 1 + 2
00:59:14 <lambdabot> 3
00:59:29 <srle> ok
01:05:44 <sieni> cool, yi started
01:07:28 <vincenz>  Illegal instance declaration for `Pretty [Char]'
01:07:34 <vincenz> :/
01:22:39 <gour> anyone knows why 'make dist' in ghc packages _darcs/* dir udner libraries folder?
01:26:21 <dcoutts> because no-one has fixed it yet
01:26:47 <dcoutts> presumably it ignores dirs beginning with CVS
01:26:55 <dcoutts> beginning with/called
01:27:00 <gour> dcoutts: ahh..ok. i wondered why my src is so big
01:27:27 <gour> there are no CVS. it's ghc-6.5-head. only _darcs
01:28:21 <gour> dcoutts: fps build fails with ghc-head..
01:28:25 <vincenz> hmm
01:28:26 <vincenz> hmm
01:28:46 <dcoutts> gour, try editing the top level ghc Makefile, line 428
01:28:50 <vincenz> data Exp = Enop | EBool Bool | EBinary Op Exp Exp  (simple example)
01:28:54 <dcoutts> change CVS for _darcs
01:28:59 <vincenz> should I do
01:29:02 <vincenz> data Exp a ...
01:29:15 <vincenz> or data E a = Exp a and then in Exp a replace Exp by E a
01:29:24 <vincenz> err
01:29:29 <vincenz> data E a = E a (Exp a)
01:29:48 <vincenz> data Exp a = ENop | EBool Bool | EBinary Op (E a) (E a)
01:30:18 <vincenz> or not use the E indirection and put the a straight into all the different Exps
01:31:56 <gour> dcoutts: it (seemingly) works. is ghc-6.2.hardened.patch obsolete for ghc-6.5?
01:32:15 <dcoutts> gour, I'm not sure
01:35:27 <vincenz> what do you guys recommend?
01:39:29 <ski> vincenz : if you use the indirection, then it's easier to add annotations, i think
01:39:34 <vincenz> true
01:39:39 <vincenz> alright, thx
01:39:41 <ski> hrm
01:40:03 <ski> data Exp a = ENop | EBool Bool | EBinary Op a a
01:40:11 <vincenz> o.
01:40:12 <vincenz> o.O
01:40:13 <ski> newtype E = E (Exp E)
01:40:23 <ski> is what i'd use, if i wanted the indirection
01:40:24 <vincenz> where is the annotation
01:40:33 <ski> (but maybe i misunderstood what you wanted)
01:40:40 <vincenz> ski: annotate asts
01:40:55 <vincenz> (with for instance a lexical environment, or a type)
01:41:23 <ski> data AnnotE a = AE a (Exp (AnnotE a))
01:41:31 <vincenz> o.O
01:41:42 <vincenz> freaky
01:41:43 <ski> that is parametric in annotation
01:41:53 <vincenz> why that over what I suggested?
01:42:00 <ski> if you only need to annotate by one thing, you can of course specialize
01:42:12 <ski> hrm
01:42:13 <vincenz> why that inistead of
01:42:15 <ski> let me check
01:42:21 <vincenz> data E a = E a (Exp a)
01:42:26 <sieni> is there a gtk ui for yi?
01:42:27 <vincenz> and in Exp a I use E a instead of Exp
01:42:34 <dcoutts> hmm, cvs-ghc is a members-only list and yet is set as the destinatin for darcs send patches in the ghc repo
01:43:00 <ski> vincenz : ah, yes, you have already built-into your 'Exp' that it has an annotation, i haven't in mine
01:43:12 <vincenz> ski: ehmm no
01:43:20 <ski> (i acually misread your decl. first)
01:43:20 * gour is emerging ghc-head
01:43:40 <vincenz> data Exp a = ENp | EBool Bool | EBinary Op (E a) (E a)  and data E a = E a (Exp a)
01:43:58 <ski> 'E' there is the annotated expr
01:44:07 <vincenz> right
01:44:09 <vincenz> no
01:44:12 <ski> and 'Exp' is forced to have annotated children
01:44:13 <vincenz> the annotionation is on E
01:44:17 <ski> yes
01:44:38 <vincenz> so what is the advantage of your system?
01:44:57 <ski> i can express exprs witout any annotation
01:44:59 <vincenz> it seems that with your system, and Exp could have a binaryop that can take anything
01:45:09 <vincenz> ski: yes and you can express exprs with something else as chilid
01:45:17 <ski> there's a wiki page, lemme find it
01:45:21 <vincenz> thx
01:48:58 <vincenz> ski: any luck?
01:49:03 <vincenz> and what if I have multiple different things
01:49:30 <vincenz> (statements (of three different kinds), func-declarations, and expressions)
01:50:51 * ski hates when firefox crashes
01:50:54 <vincenz> oy
01:51:01 <ski> (i only had some 80 tabs open)
01:51:06 <ski> anyway, i think it was this
01:51:13 <ski> @hawiki IndirectComposite
01:51:14 <lambdabot> http://www.haskell.org/hawiki/IndirectComposite
01:51:32 <vincenz> thx, I'll take a look :)
01:52:17 <ski> yes, if you have mutually recursive datatypes, then you need as many tyargs to each as number of types
01:52:37 <ski> (this is, btw, a good reason to want type-level records)
01:53:20 <vincenz> type-level records?
01:53:30 <ski> instead of
01:53:44 <ski> data Expr expr stmt = ... expr ... stmt ...
01:53:47 <ski> you'd have
01:54:09 <ski> data Expr foo = ... foo.expr ... foo.stmt ...
01:54:12 <vincenz> fortunately they're not recursive but rather treelike
01:54:20 <ski> (or something, depending on actual syntax)
01:54:22 <vincenz> ski: ah, I see, indeed cleaner
01:54:47 <ski> so  foo :: {expr :: *,stmt :: *}
01:54:53 <ski> a record of types
01:54:54 <vincenz> right
01:54:57 <vincenz> :)
01:55:01 <ski> (not to be confused with a record type)
01:55:26 <vincenz> I still don't fully see the advantage over the indirectcompositve over the "wrap each pointer"-way
01:55:34 <vincenz> http://www.haskell.org/hawiki/DecoratingStructures
01:55:37 <vincenz> (all the way at bottom)
02:00:20 <ski> ah, yes, now i recall
02:00:59 <ski> with IndirectComposite, you can have several versions at the same type, without having to duplicate the constructors of the main type
02:01:21 <vincenz> I disagree
02:01:52 <vincenz> with the pointer way..
02:01:59 <ski> look at the PExpr' example at bottom of DecoratingStructures
02:02:03 <vincenz> right
02:02:19 <ski> that is fixed into using decoration
02:02:19 <vincenz> where is the constructor duplication?
02:02:25 <vincenz> so?
02:02:30 <vincenz> if you want no decoration just use ()
02:02:33 <ski> if we wanted a version with IORef-indirections
02:02:42 <ski> then we'd have to duplicate
02:02:45 <vincenz> why
02:03:00 <ski> since PExpr' mentions PExpr
02:03:12 <ski> and PExpr embodies the decoration
02:03:43 <ski> so, if one just are interested in decorations, then DecoratingStructures is enough
02:03:53 <vincenz> ah
02:03:58 <ski> however, if one also want other ways of indirecting
02:03:59 <vincenz> I think I see it
02:04:08 <vincenz> ok
02:04:11 <vincenz> I'll try it out :)
02:04:15 <vincenz> basically
02:04:17 <ski> (more specifically, want those other ways, *additionally*)
02:04:17 <vincenz> given a regular AST
02:04:21 <vincenz> wherever yoou have a Type
02:04:24 <vincenz> you replace it by a variable
02:04:27 <ski> yes
02:04:35 <vincenz> so if my BasicStm only use Exp
02:04:38 <vincenz> and not themselves
02:04:39 <ski> that stands for the recursive "invication"
02:04:42 <vincenz> it only needs an exp part
02:04:51 <ski> it's like making a function nonrecursive, for use with fix
02:04:58 <ski> only on type level
02:05:00 <vincenz> alright :)
02:05:13 <vincenz> I'll try it out :)
02:05:19 * ski ponders
02:05:21 <vincenz> it's spooky
02:05:55 * vincenz fans himself
02:05:57 <ski> i wonder if one could define generic traversals if the indirection is, say, a monad
02:06:34 <vincenz> let's hope I get this to work
02:06:36 <ski> (otherwise one'd possibly need to have several versions of functions for traversing)
02:06:55 <vincenz> oh right...
02:06:59 <vincenz> how does traversal work?
02:07:08 <vincenz> must be icky.
02:07:17 <ski> vincenz : anyway, if you only need decoration (or, any *single* kind of indirection), then DecoratingStructures is enough
02:07:20 <ski> er
02:07:31 <ski> i didn't mean generic in the datatype
02:07:40 <ski> only generic in the decoration/indirection/whatever
02:07:43 <vincenz> so how would traversal of this structure work?
02:08:12 <ski> you can either define it directly
02:08:21 <ski> or you can make helping functions
02:08:25 <vincenz> (or for that matter my pretty print class)
02:08:36 <vincenz> seems like a lot of hassle
02:08:42 <vincenz> :(
02:10:44 * vincenz hacks
02:19:14 <vincenz> how does the compiler do the automated "Show" for deriving
02:19:20 <vincenz> and can I use this for custom generated typeclasses?
02:19:26 <vincenz> (add a default behaviour)
02:19:38 <vincenz> deriving
02:20:05 <Cale> http://haskell.org/onlinereport/derived.html
02:21:01 <vincenz> ah, thx
02:21:16 <Cale> hmm, does that actually say?
02:21:27 <vincenz> only for prelude
02:21:32 <vincenz> or compiler known stuff
02:21:40 <Cale> Oh, in that sense, yes
02:21:48 <Cale> you can't add your own classes to deriving
02:22:05 <Cale> though with GHC, you can derive any class through a newtype
02:22:30 <Cale> (any class implemented on the base type)
02:23:07 * ski seems to recall something about experiments with generic classes, or something
02:23:18 <vincenz> that makes indirect composite an annoying pattern, no?
02:23:24 <Cale> oh, perhaps with -fgenerics you can
02:23:42 <ski> what do you want to derive ?
02:23:53 <vincenz> ski: my prettyprinter
02:24:01 <vincenz> I want the combinators I use around my basic types to be transparent
02:24:09 <Cale> indirect composite?
02:24:21 <vincenz> http://www.haskell.org/hawiki/IndirectComposite
02:25:24 <Cale> yeah, that can be somewhat annoying to actually use
02:26:04 <vincenz> oh well
02:26:05 <Cale> It's doable, but you have to balance what you gain with what you lose :)
02:26:09 <vincenz> right
02:26:16 <vincenz> either way I have to annoate
02:26:21 <vincenz> I'll just put the pretty printer defs local
02:26:26 <vincenz> to wherever I make a new typecombinator
02:31:05 <vincenz> what's the diff between newtype and data?
02:31:27 <Cale> newtype creates a new type which has the same representation as an existing type
02:31:41 <vincenz> .O
02:31:42 <vincenz> so why
02:31:43 <Cale> data creates a type with a new representation
02:31:53 <vincenz> newType Expr = Expr (Expr' Expr)
02:31:57 <vincenz> you're still adding a constructor
02:32:06 <Cale> right, the constructor is just a tag though
02:32:10 <ski> yes, but it's represented as nothing, at run-time
02:32:14 <vincenz> and you can only have one
02:32:14 <Cale> eventually to be compiled away
02:32:23 <vincenz> ?
02:32:39 <ski> newtype Foo = F Bar
02:32:49 <ski> 'Foo' is represented in the same way as 'Bar'
02:32:50 <vincenz> F somoevalue?
02:32:54 <Cale> data D = DCon String -- here, DCon exists at runtime
02:33:00 <vincenz> right
02:33:06 <vincenz> so fr newtype you can only have one constructor (obviously)
02:33:11 <Cale> newtype N = NCon String -- NCon doesn't exist at runtime
02:33:12 <ski> DCon _|_ /= _|_
02:33:18 <ski> F _|_ = _|_
02:34:26 <vincenz> oki, thx :)
02:34:55 <ski> hm .. tuples, do the constructor of those have any run-time existance ?
02:35:52 <ski> erm
02:36:06 <vincenz> there we go
02:36:11 <vincenz> indirectcomp
02:36:20 <ski> (take a 'data' with only one constructor, with just strict args, instead, hmm ..)
02:36:20 <vincenz> newtype PExp          = PE (Exp ParseExp)
02:36:20 <vincenz> newtype PBasicStm     = PB (BasicStm PExp)
02:36:20 <vincenz> newtype PStm          = PS (Stm PExp PBasicStm PStm)
02:36:20 <vincenz> newtype PDeclaration  = PD (Declaration PStm)
02:36:20 <vincenz> newtype PProgram      = PP (Program PDeclaration)
02:36:34 <vincenz> :/
02:38:24 <vincenz> adding the prettyprint stuff is actually quite easy, just oneliners
02:38:32 <dcoutts> @seen JaffaCake
02:38:32 <lambdabot> I saw JaffaCake leaving #haskell 5 days, 17 hours, 28 minutes and 12 seconds ago, and I have missed 
02:38:54 <vincenz> is deriving needed on newtypes?
02:39:14 <ski> needed for what ?
02:39:29 <vincenz> deriving (Eq, Show)
02:39:39 <ski> if you want to derive instances on them, then you need a 'deriving' yes
02:39:48 <vincenz> okies
02:40:18 <ski> ('Show' will of course show the newtype constructor)
02:40:23 <vincenz> right
02:47:31 <tibbe> (eval '(eq N NP))
02:48:21 <tibbe> The void says: (eq N NP) is a NP-C problem
02:48:28 <tibbe> @quote
02:48:29 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
02:48:51 * tibbe laughs
02:56:35 <vincenz> \o.
03:00:25 <Cale> ?h%
03:00:35 <vincenz> \o/
03:00:41 <vincenz> I moved to indirect composite ::)
03:00:52 <vincenz> finally lexing/parsing done in a clean fashion, time to move to scoping
03:00:56 <vincenz> (and then typing)
03:02:52 * Cale reads some alt.adjective.noun.verb.verb.verb posts
03:04:41 <Cale> http://groups.google.ca/group/alt.adjective.noun.verb.verb.verb/browse_thread/thread/5e2f361ddcf8ec79/427896e408d129c8?hl=en#427896e408d129c8
03:05:10 <olliej> vincenz: what you working on?
03:06:33 <olliej> Cale: wtf?
03:07:10 <Cale> It's a newsgroup in which all legitimate postings are a sequence of lines of exactly the form given by the group's name.
03:07:28 <olliej> ah
03:07:32 <olliej> of course
03:07:37 <olliej> why didn't i think of that
03:07:38 <Cale> alt.sacred.format.have.require.must-use:
03:07:38 <Cale> alt.one.alt.appears.leads-off.starts
03:07:38 <Cale> alt.one.adjective.appears.initiates.introduces
03:07:38 <Cale> alt.one.noun.appears.appears.is-modified-by-adjective
03:07:38 <Cale> alt.grammatical.subject.have.have.have 
03:10:15 <edwinb> Hmm, that link briefly didn't work.
03:10:25 <edwinb> I wonder if it was the #haskell version of the slashdot effect...
03:11:32 <olliej> on google???
03:11:53 <rep> haha
03:13:28 * shapr is part of the higher order
03:57:02 * shapr boings
03:57:23 <shapr> So, anyone read any good research papers lately?
03:58:48 <olliej> none about haskell.. well none less than 10 years old anyway :)
03:58:58 <wolverian> I liked the Haskell is not not ML paper.
03:59:25 <shapr> Yeah, that is is a cool paper.
03:59:42 <wolverian> not very easy to follow for a freshman, but oh well.. :)
03:59:57 <shapr> I'm a 34-year old freshman.
04:00:07 <shapr> Assuming I get back to school someday...
04:00:21 <wolverian> I'm a fresher freshman. :)
04:00:25 <shapr> heh
04:00:44 <shapr> Any neat research papers to recommend?
04:01:00 * shapr is always looking for something new to load onto his 770 for bus-trip reading.
04:01:11 <wolverian> this is not strictly research, but did you read the haskell in game programming slides, or see tha talk?
04:01:19 <wolverian> by tim weeny, iirc 
04:01:48 <shapr> No, sounds cool, have an url?
04:01:53 <wolverian> yeah, let me dig it up
04:01:54 <shapr> Sweeney does awesome stuff.
04:02:43 <wolverian> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
04:02:57 <wolverian> oh, sweeny :)
04:03:01 * wolverian apologises 
04:05:39 <wolverian> I don't know what he means with 'lenient evaluation' though 
04:05:43 <wolverian> if I remember the phrase correctly
04:08:25 <shapr> wolverian: This is quite interesting.
04:08:33 <wolverian> good :) I thought so too
04:10:50 <kzm> Anybody use EclipseFP?
04:10:55 <kzm> (or Eclipse at all?)
04:11:24 <wolverian> I use Eclipse.
04:11:38 <wolverian> (unfortunately I have to code some Java for university projects)
04:11:48 <shapr> wolverian: This part on page 31 is nifty!
04:12:25 <kzm> wolverian, Okay - so I started a project, wrote some code - but then I get sort of lost.  What else can I do?  
04:12:40 <kzm> I guess I need some kind of tutorial :-)
04:12:48 <shapr> Sadly, I can't read part of the text on page 32
04:12:51 <wolverian> shapr, I glossed it over since the syntax is juts horrible
04:12:57 <wolverian> me neither.
04:13:00 <wolverian> s/juts/just/
04:13:20 <shapr> aha, dependent functions
04:13:26 <kzm> There's a bunch of menu items (Run for instance) but it's not clear what it does (one can guess what it is supposed to do, but not how to get it to do exactly that)
04:13:28 <shapr> I had to copy'n'paste the text.
04:13:57 <wolverian> kzm, well, Run runs the project..
04:14:11 <wolverian> shapr, do you know what he means with lenient evaluation?
04:14:16 <wolverian> (page 36)
04:14:32 <shapr> Nope, but I can look around.
04:14:38 <shapr> I was about to ask you the same thing :-)
04:15:02 <shapr> @foldoc lenient evaluation
04:15:05 <lambdabot> No match for "lenient".
04:15:05 <lambdabot>  
04:15:05 <lambdabot> *** "evaluation" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
04:15:05 <lambdabot> evaluation
04:15:05 <lambdabot>  
04:15:07 <lambdabot> [9 @more lines]
04:15:13 <shapr> @foldoc "lenient evaluation"
04:15:15 <lambdabot> *** "lenient evaluation" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
04:15:15 <lambdabot> lenient evaluation
04:15:15 <lambdabot>  
04:15:15 <lambdabot>    An {evaluation strategy}, described in [Traub, FPCA 89], under
04:15:17 <lambdabot>    which all {redex}es are evaluated in parallel except inside
04:15:19 <lambdabot> [3 @more lines]
04:15:23 <shapr> @more
04:15:24 <lambdabot>    the arms of conditionals and inside {lambda abstraction}s.
04:15:24 <lambdabot>    This is an example of an {eager} evaluation strategy.
04:15:25 <lambdabot>  
04:15:56 <wolverian> hm.. I'm not good enough at abstractions to figure out what that means in practice
04:16:12 <kzm> wolverian, hmm...there's a huge menu there, and I don't quite understand what the different items do.  *shrug*
04:16:12 <shapr> I don't know either, but I'll think about it when I have more spare time.
04:16:22 <wolverian> kzm, in eclipsefp or eclipse?
04:16:34 <wolverian> hm, LtM has talked about it
04:16:38 <kzm> How can I tell them apart?
04:16:39 <wolverian> er, LtU
04:16:45 <Dreadshoot> dons: there?
04:16:55 <wolverian> shapr, http://lists.seas.upenn.edu/pipermail/types-list/2004/000340.html
04:19:24 <wolverian> hm.. that reminds me of perl6, where list context is lazy and scalar is eager
04:21:57 <shapr> wolverian: That's wild stuff
04:22:12 <wolverian> it's interesting :)
04:22:16 <shapr> I want to work with Tim Sweeny!
04:22:26 <wolverian> he seems like a smart person
04:22:50 <wolverian> too few working in CS applications know how to apply mathematics on this kind of scale
04:23:02 <shapr> yeah, I agree.
04:23:25 <shapr> Though in some cases it's just impossible to persuade clients to accept languages or viewpoints they've never encountered.
04:23:31 <wolverian> or perhaps "level" instead of "scale" .. you could call it metacomputing, I guess.. but I'm digressing
04:23:37 <shapr> How would I persuade my webmonkey clients to let me use Haskell?
04:23:56 <dcoutts> shapr, by saying you can do it quicker that way
04:24:07 <dcoutts> shapr, but would that be true?
04:24:36 <shapr> At this point I think I could do it at the same speed because I wouldn't have to backtrack so often.
04:24:43 <shapr> but after the first time it'd be faster.
04:24:54 <dcoutts> right
04:25:04 <wolverian> webmonkeying seems faster to me if you have a framework you understand well to work with. then the language doesn't matter so much
04:25:22 <dcoutts> yes, I expect the framework is very important
04:25:36 <shapr> There really are major benefits to using the right language.
04:25:48 <dcoutts> I expect you can build a nicer framework in Haskell, but building that framework takes time
04:26:01 <shapr> Yeah, that's my biggest problem right now.
04:26:04 <dcoutts> and that's not something you can easily bill to the first customer
04:26:30 <vincenz> I think for webmonkeying, the framework is slightly more imiportant than the language, unless you plan to design a framework from the ground up
04:26:31 <shapr> I have a good framework in mind, but I'm not sure it's superior, and I don't have the funds to stop doing Python work for awhile and write it.
04:27:01 <dcoutts> shapr, you need more buisness partners :-)
04:27:07 <shapr> Yeah, I agree :-)
04:27:43 <dcoutts> shapr, advertise on #haskell for an unpaid haskell webmonkey to help you write a framework :-)
04:27:59 <vincenz> I wonder how suitable haskell is for that tho
04:28:11 <vincenz> web tends to be very textile, and I think python or ruby is better for that area
04:28:13 <dcoutts> mmm, well typed xhtml documents
04:28:34 <vincenz> dcoutts: honestly...when are you ever gonna check if the type is correct 
04:28:45 <vincenz> dcoutts: it's not like you're doing semantical calculatioins on those documents
04:28:48 <dcoutts> it's correct by construction
04:28:56 <vincenz> dcoutts: it's a webpage, not a calculation
04:29:10 <wolverian> correct by construction reminds me of xsl... 
04:29:11 <vincenz> use the right tool for the job, haskell isn't ideal for web
04:29:15 * wolverian feels sick
04:29:22 <dcoutts> the structure of the xml is such that it is a well formed xhtml document
04:29:26 <dcoutts> then you pretty print it
04:29:40 <shapr> @quote darius
04:29:41 <lambdabot>  Well profiling does add a bit of reflection, but it should have the good sense not too go near the 
04:29:42 <shapr> @quote darius
04:29:43 <lambdabot>  Well profiling does add a bit of reflection, but it should have the good sense not too go near the 
04:29:46 <shapr> doh
04:29:48 <shapr> @quote darius
04:29:48 <lambdabot>  Well profiling does add a bit of reflection, but it should have the good sense not too go near the 
04:29:52 * shapr gives up
04:29:58 <shapr> I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner."
04:30:11 <wolverian> I weep at the phrase "XSLT programmers"
04:30:25 <dcoutts> xml is not text
04:30:26 <shapr> What's up with @quote not wrapping lines?
04:31:00 <dcoutts> xml/xhtml is a structured data type which has a textual serialisation
04:31:07 <wolverian> anyway, text templates have always worked for me well enough, checking for correctness afterwards. 
04:31:20 <wolverian> I've never needed structural templating. some people do swear by it.
04:31:27 <goron> shapr: hi
04:31:37 <dcoutts> wolverian, text xml they could be preoprcessed into well typed functions xml -> xml
04:31:38 <shapr> hoi goron 
04:31:47 <goron> shapr: I got my monad to work :)
04:31:51 <shapr> yay!
04:31:59 <goron> shapr: (and my algorithm, more importantly :D)
04:32:09 <shapr> vincenz: I'm not thinking about a text based framework
04:32:21 <vincenz> shapr: web is mostly a text-medium imho
04:32:30 <shapr> I'm thinking about a combination of Oleg's ZipperFS and a Data.Graph value.
04:32:37 <shapr> Hm, not so much recently.
04:32:48 <wolverian> dcoutts, hm. but I think you can only check for the correctness of the individual xml fragments, not the whole
04:32:51 <shapr> With the work I do the i18n support is the most important feature.
04:32:56 <vincenz> rightio
04:32:59 <vincenz> scope-analysis
04:33:01 <vincenz> ;/
04:33:23 <shapr> wolverian: You can check for the correctness of an entire site if you use subDTD type checking in your templates.
04:33:36 <wolverian> shapr, subDTD? 
04:33:40 <wolverian> doh.. that seems logical
04:33:47 <dcoutts> wolverian, no you can do the whole, a template is jsut a function that inserts a subtree into an xml tree, that can easily be typed. If the thing that gets inserted is well typed then we can guarantee the overall thing is well typed.
04:33:56 <shapr> Yeah, what fits inside a body tag in XHTML?
04:34:05 <dons> shapr, we're experimenting with having lambdabot leave wrapping up to the client. any comments?
04:34:16 <wolverian> dcoutts, that's assuming things about the template. the template could as well insert "foo><bar" .. but yes, if you define it that way.
04:34:19 <shapr> dons: I only get part of the line I think.
04:34:21 <shapr> @quote darius
04:34:22 <lambdabot>  I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one li
04:34:28 <shapr> @quote
04:34:29 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math? Is there an undocumented 
04:34:35 <dcoutts> wolverian, that's not a well formed template
04:34:47 <wolverian> dcoutts, but the output could be
04:34:48 <dons> ah. ok, that's weird.
04:34:55 <wolverian> dcoutts, you might notice I'm a dynamic typing person..
04:35:01 <shapr> dons: 111 chars?
04:35:03 <dcoutts> wolverian, yeah, I'd ban such untyped templates
04:35:12 <dcoutts> they're not useful anyway I bet
04:35:16 <dcoutts> they're just dangerous
04:35:29 <wolverian> dcoutts, yeah, then it works, if you can do the subdtd thing. 
04:35:37 <wolverian> (I haven't worked with dtd internals)
04:35:39 <dcoutts> there are a few things in a xml dtd that cannot be checked statically with types, such bits need runtime checks.
04:36:15 <dcoutts> but mostly an xml dtd has a corresponding Haskell type
04:36:22 <dons> nah, i just upped the wraplen to 350 chars.
04:36:34 <dons> i'll revert it till i figure out why it's chopping.
04:37:38 <dons> @quit revert tweak
04:41:21 <shapr> @quote
04:41:22 <lambdabot> Oleg says: The implementation of RSA on type level is left for future
04:41:22 <lambdabot> work
04:41:33 <shapr> @quote
04:41:34 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike
04:41:34 <lambdabot> rode up next to me and said, "There's always a show off." I offered to
04:41:34 <lambdabot> teach him to ride and help set up a unicycle patrol squad, but he
04:41:34 <lambdabot> declined.
04:41:40 <shapr> ah, much nicer
04:42:47 <wolverian> @quote darius
04:42:48 <lambdabot>  Well profiling does add a bit of reflection, but it should have the good
04:42:48 <lambdabot> sense not too go near the barbed wire fences and armed guards.
04:42:50 <wolverian> (just checking
04:42:51 <wolverian> )
04:45:25 <gour> dons: fps fails with ghc-6.5: Data/FastPackedString.hs:1142:0: Parse error in pattern
04:47:14 <dons> hmm, cpp maybe?
04:47:23 <dons> i've not seen this.
04:47:40 <gour> dons: pulled ghc-head today
04:48:03 * gour tries to build hIDE
04:48:25 <dcoutts> dons, just wondering about the status of fps. Should we be putting it into gentoo or wairint for it to get included in the ghc base package?
04:48:29 * sieni tries to hide a build
04:48:43 <dcoutts> wairint/waiting
04:49:33 <dons> dcoutts, an fps will be in 6.6, and I won't be extending the current fps any further. i'll be working on the version going into 6.6.
04:49:59 <dcoutts> dons, ok so perhaps we should just wair for that, we don't really want to package dead-end libs
04:50:05 <dons> yep.
04:50:44 <dons> gour, can you seen anything on that line that ghc wouldn't like?
04:51:16 <dcoutts> does anyone know hoe to stop hugs building the X11 and OpenGL packages?
04:51:58 <dcoutts> dons, in OpenBSD do you just make hugs98-2005 depend on X11 & OpenGL C libs or do you make them optional? or disable them completely?
04:51:58 <dons> kill -KILL ;) --me is cheeky
04:52:21 <dons> they build by default, iirc.
04:52:29 <dons> i remember being asked to enable them specifically
04:52:32 <shapr> kill -KILL # kill! blood guts and veins in the teeth!
04:52:52 <shapr> first person shooter?
04:52:53 <shapr> oh
04:53:13 <dcoutts> dons, do you recall how you edabled/disabled them?
04:53:23 <dcoutts> dons, I can't seem to disable them
04:53:53 <dcoutts> using "./configure --without-OpenGL --without-X11" makes the hugs build unhappy
04:54:28 <dcoutts> Skipping base package
04:54:28 <dcoutts> runhugs: Error occurred
04:54:28 <dcoutts> ERROR "../../../libraries/bootlib/Data/Bits.hs":187 - Undefined data constructor "SIZEOF_HSINT"
04:54:31 <dcoutts> it says :-(
04:54:47 <dons> ah, there's a patch somewhere. let me see.  hmm.
04:55:20 <gour> dons: hmm, the line looks (PS x s _l) but i'm totally unfmiliar with fps
04:55:28 <dons> I see: we had to add $XFLAGS into the configure scripts for each lib . to get them _enabled_
04:55:51 <dons> gour, I wonder if ghc doesn't like _l for some reason? (since it's the head)
04:55:56 <dons> no, that couldn't be it.
04:56:28 <dcoutts> dons, did they make '_' in idents lower case / upper case?
04:56:38 <dons> gour, you'll have to snoop around. i won't be able to look at this till tomorrow.
04:56:52 <gour> dons: ok
04:56:57 <gour> 1141-1143:
04:57:00 <gour> (!) :: FastString -> Int -> Word8
04:57:00 <gour> (PS x s _l) ! i = unsafePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+i)
04:57:00 <gour> {-# INLINE (!) #-}
04:57:08 <gour> error on 1142
04:57:15 <dons> such lovely code :)
04:57:43 <dons> ghc 6.4.x likes it, but maybe the head is playing games.
04:57:51 <dons> or could it be Cabal setting funny flagsS?
04:58:13 <dons> check that cpp is going through to ghc (run Cabal with -v flagsS)
04:58:18 <dcoutts> dons, gour is usong ghc-6.5 I think
04:58:23 <shapr> Like, a spinnaker?
04:58:31 <dcoutts> very good shapr 
04:58:59 * shapr ran out of meds...
04:59:09 <dons> hehe. hoist the mainsil. that usually helps, ye scurvey dog.
04:59:19 <dcoutts> @yarr!
04:59:20 <lambdabot> I heard andersca is a pirate
04:59:48 <shapr> Spinnaker is a kind of flag too.. I always thought it was a bit funny.
04:59:50 <dons> actually, I added some new pirate quotes... :)
04:59:59 <dcoutts> dons, excelent :-)
05:00:04 <shapr> Pennants are neat too.
05:00:44 <shapr> ooh, never heard of a burgee flag before - http://www.flags.com/Attention-Flags/c224_5982/index.html
05:01:34 <dons> ok, night guys. keep hacking :)
05:02:12 <dcoutts> g'night dons 
05:02:15 <dcoutts> @localtime dons 
05:02:18 <lambdabot> Local time for dons is Fri Feb 10 00:01:45 2006
05:03:05 <shapr> @arr
05:03:05 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
05:03:07 <shapr> @arr
05:03:08 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
05:03:12 * shapr wants new quotes!
05:06:23 <wolverian> hm, eclipsefp didn't actually install any documentation apparently, just the doc index..
05:06:51 <wolverian> oh, wait, there it is. it's just a .jar file 
05:09:53 <moonlite_> if i add the flag --user when i configure a package with cabal. will it then for sure link to my personal libraries?
05:27:03 <goron> Why do I always write programs that eat up CPU and memory?
05:29:09 <mauke> because you're a programmer?
05:29:31 <goron> eat up *all* CPU
05:30:04 <mauke> oh
05:32:42 <aleator> goron: My program is expanding towards the point where it starts eating my supervisors cpu as well :)
05:32:58 <mauke> zomg skynet
05:33:16 <aleator> Well it is genetic programming style thingy..
05:33:43 <goron> Yes, they are bad for CPU's.
05:34:44 <aleator> Intelligence times CPU power is constant.
05:34:53 <goron> http://en.wikipedia.org/wiki/ZOMG
05:35:46 <aleator> mauke: To scare you further - it does atr. :)
05:35:59 <wolverian> meh, eclipsefp says "Can't find your executable" (roughly) when compiling, yet creates the executable fine. oh well, it's alpha :)
05:36:25 <goron> aleator: atr.?
05:36:46 <aleator>  automatic target recognition.. 
05:36:53 <goron> hehe
05:37:10 <goron> My AIBO does that daily ;)
05:37:39 <aleator> :)
05:54:58 <goron> My screen: http://img260.imageshack.us/my.php?image=schermafdruk43gq.png
05:55:41 <vincenz> goron: duthh?
05:55:43 <vincenz> dutch
05:55:49 <goron> vincenz: yes
06:01:37 <vincenz> module Decorations where 
06:01:37 <vincenz> data DExp de                  = DE de (Exp (DExp de)) deriving (Eq, Show)
06:01:37 <vincenz> data DBasicStm de db          = DB db (BasicStm (DExp de)) deriving (Eq, Show)
06:01:37 <vincenz> data DStm de db ds            = DS ds (Stm (DExp de) (DBasicStm db) (DStm ds)) deriving (Eq, Show)
06:01:41 <vincenz> data DDeclaration de db ds dd = DD dd (Declaration (DStm de db ds)) deriving (Eq, Show)
06:01:44 <vincenz> data DProgram de db ds dd dp  = DP dp (Program (DDeclaration de db ds dd)) deriving (Eq, Show)
06:01:48 <vincenz> enough indirect composites?
06:01:59 <vincenz> :P
06:03:08 <goron> Maintain that, mf! 
06:03:13 <vincenz> ??
06:03:36 <goron> It was a joke. 
06:04:12 <goron> Oh, that's your genetic programming thingie.
06:04:17 <vincenz> o.O
06:04:18 <vincenz> ???
06:04:42 <goron> Nm
06:04:45 <goron> Cool program :)
06:06:26 <vincenz> it's a not-quite c-language AST 
06:08:46 <vincenz> anyone have a nice pattern/idiom to effectively use Indirect composite to do lexical scoping?/
06:08:56 * vincenz repeats for Saulzar 
06:08:57 <vincenz> anyone have a nice pattern/idiom to effectively use Indirect composite to do lexical scoping?/
06:10:02 * Saulzar isn't aware of what Indirect composite is
06:10:18 <vincenz> http://www.haskell.org/hawiki/IndirectComposite
06:10:58 * vincenz wonders to keep an env table on each statement or to make the variable names internally unique
06:11:13 <vincenz> or to force it into a monad
06:12:58 <vincenz> should prolly force it into a reader monad
06:13:16 <Saulzar> What are you trying to do?
06:13:31 <vincenz> Saulzar: lexically scope my ast so I can do typechecking and transfos
06:16:05 <vincenz> basically the readermonad is great and all that but I dont want to have to recalculate my lexical scoping each time, and when I do function iniling it'll be more involved... so I'd like to build up the lexical environments only once ad I'm trying to decide what the best way of annotating my ast is
06:17:51 <Saulzar> Hmm, not sure what is meant by "to lexically scope", you talking about attaching line numbers or other context?
06:18:06 <vincenz> Saulzar: no to define (this x refers to that defintion, and is not equal to that x)
06:18:12 <vincenz> in haskell:
06:18:20 <vincenz> (\x -> x * (\x -> 2*x))
06:18:23 <vincenz> those two x's are different
06:19:08 <goron> vincenz: don't you normally do that in your parser?
06:19:37 <vincenz> goron: no
06:19:38 <Saulzar> Right, I understand what lexical scope is about - you mean to traverse your AST and disambiguate the "x"s ?
06:19:44 <vincenz> Saulzar: correct
06:19:58 <goron> vincenz: Hmm, well, I have seen it work like that earlier. 
06:20:12 <vincenz> goron: and then do what? give em unique names initernally?
06:20:20 <vincenz> the issue is that I want source->source so I want to keep original naming
06:20:31 <vincenz> (as much as possible)
06:21:05 <goron> vincenz: then I don't really understand you. I thought you wanted to add lexical scoping to your language.
06:21:14 <vincenz> goron: correct
06:21:21 <goron> vincenz: anyway, in Stratego there's newname
06:21:24 <vincenz> goron: so that later when I'm doing transformations I can check the lexical table
06:21:29 <vincenz> o.O
06:21:32 <Saulzar> Can you just use an internal id and keep the old name as a string?
06:21:42 <goron> vincenz: Stratego is better suited for program transformation, I think.
06:21:48 <vincenz> Saulzar: either way I -will- need a lexical table
06:21:52 <vincenz> ...
06:21:58 <vincenz> goron: not helping
06:22:13 <goron> vincenz: then you have to emulate what Stratego does. 
06:22:18 <vincenz> ...
06:23:02 <vincenz> I'll use the reader monad for now
06:23:46 <Saulzar> Ah, I see the issue - you'd rather not do the work twice...
06:23:52 * Saulzar is slow.
06:23:54 <vincenz> Saulzar: correct
06:23:58 <vincenz> I want to annotate my ast
06:25:31 <Saulzar> What's wrong with just transforming the whole thing?  Label String -> Label ID String or something?
06:25:49 <vincenz> Saulzar: well if I later do code substitution
06:25:57 <vincenz> Saulzar: and rely purely on id's it might get ugly
06:26:06 <vincenz> cause they might have the same name
06:26:10 <Saulzar> Hmm
06:26:21 <Saulzar> What about picking unique names for everything?
06:26:36 <vincenz> Saulzar: I want fromsource compatibilty as much as I can
06:26:58 <Saulzar> But if you keep the real  Label around you can still use that to give errors and whatnot ..
06:27:01 <vincenz> I'll just do typechecking first
06:27:08 <vincenz> Saulzar: it's not for errors
06:27:11 <vincenz> source -> source
06:27:26 <goron> vincenz: newname string creates a unique identifier which resembles string very much.
06:27:40 <Saulzar> Hmm..
06:27:45 <vincenz> goron: creating a unique id is not difficult
06:27:49 <vincenz> there's a zillion ways
06:27:58 <goron> vincenz: then why not do that?
06:28:07 <vincenz> ergh
06:28:25 <goron> vincenz: : you will get myvar -> myvar_01 or something like that. 
06:28:27 <vincenz> goron: I only want to rename when I have to
06:28:34 <vincenz> aka
06:28:35 <vincenz> no transfos
06:28:41 <vincenz> inp = outp (except for indentation)
06:28:42 <Saulzar> Seems hard
06:28:46 <vincenz> shouldn't be
06:28:59 <vincenz> I'm just not sure how to represent my lex-env
06:29:04 <Saulzar> If you want the original names, but ...
06:29:11 <goron> vincenz: Ah, well, IRC is no place to discuss difficult problems. Sorry
06:29:12 <vincenz> (aka whether to hang a env table on every statement, on every exp... on..)
06:29:16 <Saulzar> Maybe just re-compute them all the time is simplest then
06:32:26 <vincenz> I guess
06:33:22 * Saulzar is a languages novice, never even bothered to create a trivial interpreter
06:33:26 * shapr cackles evilly
06:33:43 <shapr> Saulzar: Go through the Parsec tutorial, you'll never be the same...
06:35:01 * vincenz cackles
06:35:29 * dcoutts crackles
06:35:37 <vincenz> me got a cool idea
06:35:41 * vincenz too
06:35:52 <vincenz> shows 'c'
06:35:57 <vincenz> > shows 'c'
06:35:59 <lambdabot>  add an instance declaration for (Show (String -> String))
06:36:09 <dcoutts> > shows 'c' []
06:36:11 <lambdabot> "'c'"
06:36:42 <ihope> > shows "foo" "bar"
06:36:44 <lambdabot> "\"foo\"bar"
06:36:48 <ihope> Hmm.
06:36:58 <ihope> "But why, Mommy?"
06:37:04 <vincenz> > showString "foo" "bar"
06:37:06 <lambdabot> "foobar"
06:37:13 <vincenz> :0
06:39:39 <ski> @type showString
06:39:40 <lambdabot> String -> ShowS
06:40:01 <ski> showString s = (s ++)
06:44:36 <essiene> hola *
06:45:18 <shapr> como est as?
06:45:29 <shapr> hiya JaffaCake 
06:45:37 <shapr> How's code?
06:45:38 <JaffaCake> hiya
06:45:47 <JaffaCake> complicated :/
06:45:49 <vincenz>  Couldn't match kind `k_a1rU -> *' against `*'
06:46:12 <shapr> Complicated and nifty?
06:46:15 <ihope> k_a1r eh?
06:46:23 <JaffaCake> shapr: well, I hope so...
06:46:32 <ihope> Well... meh.
06:46:39 <shapr> :-)
06:47:16 * essiene is trying to grok continuation passing style and would appreciate the usual helpfull explanations
06:47:22 <essiene> :)
06:47:43 <mauke> I don't know how to do it in Haskell but I've seen the concept in Perl
06:47:57 * shapr waits for essiene to return...
06:49:37 <azuroth> morning
06:49:45 <shapr> g'day azuroth 
06:49:50 <vincenz> can you use record syntax for newtype?
06:50:00 <vincenz> newtype ABC = ABC {unABC :: pllop}
06:50:37 <Saulzar> Yep
06:51:15 <vincenz> cool
06:51:22 <azuroth> when I go say, unlines ["a","b"] it shows up as "a\nb\n" in ghci.. is there any way to make them show as actual enters?
06:51:44 <vincenz> azuroth: putStr?
06:52:13 <azuroth> thanks :-)
06:52:59 <vincenz> types and values are not in the same namespace in haskell, are they?/
06:53:03 <vincenz> I can perfectly do
06:53:07 <vincenz> data Formal id = ...
06:53:13 <ihope> Not in the same space.
06:53:29 <vincenz> ihope: lexical environment
06:54:35 <jonkri> which one is up to date: test.quickcheck or debug.quickcheck
06:54:40 <vincenz> Saulzar: I did something neat
06:54:46 <vincenz> Saulzar: basically my ident also becomes part of the annotation
06:54:50 <vincenz> so my parsetree will make strings
06:54:58 <vincenz> and then later on it'll turn into something else :D
06:55:20 <dcoutts> @seen jyp
06:55:21 <lambdabot> I saw jyp leaving #haskell 3 days, 15 hours and 56 minutes ago, and I
06:55:21 <lambdabot> have missed 12 seconds since then.
06:55:21 <vincenz> :D
06:55:54 <jonkri> i know quickcheck was moved but i don't know from what to what
06:58:17 <Saulzar> vincenz, Don't see what you mean, example? :)
07:00:22 <vincenz> Saulzar: old ast
07:00:27 <shapr> Test.QuickCheck, I'm pretty sure.
07:00:35 <vincenz> Exp exp = Add exp exp | Ident String
07:00:40 <vincenz> new ast
07:00:48 <vincenz> Exp ident exp = Add exp exp | Ident ident
07:02:05 <dcoutts> @type GHC.Base.build
07:02:06 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
07:02:09 <Saulzar> Ah, then you switch between different types of Exp for different purposes?
07:02:14 <vincenz> Saulzar: yeah
07:02:20 <Saulzar> Cool.
07:02:21 <dcoutts> so what's this build all about then?
07:02:25 <dcoutts> I don't get how it works
07:02:25 <vincenz> Saulzar: well no...but using IndirectComposite
07:02:36 <dcoutts> > GHC.Base.build (\_ b -> b)
07:02:37 <lambdabot>  Not in scope: `GHC.Base.build'
07:02:43 <dcoutts> bah
07:02:53 <jonkri> shapr: ok, thanks
07:03:20 <vincenz> > build
07:03:21 <lambdabot>  Not in scope: `build'
07:03:27 <vincenz> > Data.list.build
07:03:29 <lambdabot>  Not in scope: `build'
07:03:33 <vincenz> :/
07:04:37 <shapr> jonkri: I think HUnit and QuickCheck are under Test. now.
07:05:07 <jonkri> shapr: thanks
07:06:08 <Saulzar> Strange type, (forall b. (a -> b -> b) -> b -> b) -> [a]
07:06:54 <shapr> jonkri: ar du svensk?
07:07:05 <jonkri> shapr: yes, i'm from sweden :-)
07:07:18 <shapr> haftigt...
07:07:29 <jonkri> shapr: how did you guess?
07:07:31 <shapr> Sadly I turned of x-symbol so I can't make all those dots and rings.
07:07:55 <shapr> Well, you're an admin on #dedikerad and its website is .se, so...
07:08:27 <jonkri> shapr: haha, ok. you searched the web for dedikerad or did you know about dedikerad in advance?
07:08:40 <shapr> I'm looking for mjukvaru utveckling contacts in Stockholm, especially with an OSS slant.
07:09:04 <shapr> I just did /wi jonkri and then /msg chanserv info #dedikerad and then looked at http://www.dedikerad.se/
07:09:12 <shapr> It was pretty easy :-)
07:09:24 <jonkri> shapr: haha, neat
07:10:02 <jonkri> shapr: unfortunately i'm from gothenburg, but what is it you need to do?
07:10:41 <shapr> I'm a self employed contract programmer, looking for work and looking for OSS contacts in the south of Sweden. I live in Boden now, but I'm moving to Stockholm in the summer.
07:11:30 <shapr> If I didn't need to work, I'd put all my time into working on OSS, but that's not the case, sadly.
07:11:52 <shapr> Nice website
07:11:52 <jonkri> shapr: i know what you mean...
07:12:01 <jonkri> shapr: thank you :o)
07:12:09 <jonkri> shapr: it's a bit political, but...
07:12:20 <araujo> Hello.
07:12:23 <shapr> I assume you're Jon Kristensen?
07:12:25 <jonkri> araujo: hi man
07:12:28 <jonkri> shapr: that's correct
07:12:31 <shapr> hola araujo 
07:12:37 <araujo> Hello jonkri 
07:12:45 <araujo> Hoal shapr , what's up? :-)
07:13:08 <shapr> araujo: Lookin for work, doing work, learning new stuff. Same as always. What about you?
07:13:35 <shapr> jonkri: How'd you get into Haskell? Chalmers?
07:13:46 <jonkri> shapr: yes, i'm on my first course now. the introduction
07:14:30 <jonkri> shapr: i'm studying mathematical sciences, this course along with 5p java are the only non-mathematical courses i will take
07:14:33 <shapr> Is John Hughes your teacher?
07:14:42 <shapr> Haskell isn't exactly non-mathematical.
07:14:51 <jonkri> shapr: oh, i understand that
07:14:58 <shapr> Imho, java isn't exactly mathematical =)
07:15:10 <jonkri> shapr: no, he's not, he has another group. i have nils anders
07:15:30 <shapr> If you're interested in the connection between math and Haskell, check out "The Haskell Road to Maths and Sciences".
07:15:39 <shapr> It's nifty.
07:15:59 <shapr> I don't know Nils Anders. I do know John Hughes, he's way cool.
07:16:19 <araujo> shapr, fun!, pretty well here, next to do some haskell gentoo work and hacking at http://dev.gentoo.org/~araujo/screens/newhimerge.jpeg
07:16:21 <jonkri> shapr: oh, thank you for the advice :-)
07:16:40 <jonkri> shapr: did you mean "The Haskell Road To Logic, Maths And Programming", http://www.amazon.com/gp/product/0954300696/002-0833468-1197616?v=glance&n=283155 ?
07:16:59 <shapr> Er, yes, that one.
07:17:22 <shapr> I have one of the preview copies the authors had online before publication.
07:17:27 <jonkri> araujo: a gentoo dev? cool :o)
07:17:30 <shapr> araujo: looks cool
07:17:36 <jonkri> araujo: i'm using gentoo at home
07:17:41 <araujo> jonkri, yeah, i guess so :-)
07:18:12 <jonkri> shapr: what kind of people are you searching for? haskell coders?
07:18:34 <jonkri> araujo: that's a graphical interface for emerge?
07:18:44 <araujo> jonkri, yup
07:19:31 <jonkri> araujo: which is the most common graphical interface for emerge?
07:20:15 <araujo> jonkri, mm.. well, there exist this one called porthole, i think it is the most widely used.. 
07:20:21 <araujo> but it has a problem
07:20:54 <jonkri> araujo: and what is that?
07:21:45 <araujo> jonkri, not written in haskell
07:21:47 <araujo> :-)
07:21:55 <shapr> jonkri: Python or Haskell. It's hard to find commercial Haskell work still. I think that will change though.
07:23:01 <jonkri> araujo: :D
07:23:30 <jonkri> shapr: ok. i don't know enough python to help you out yet ;-) i'm learning
07:23:47 <jonkri> shapr: does your business has a web site or something?
07:24:50 <shapr> Hm, not really.
07:24:59 <shapr> My former business does, but that's been dissolved now.
07:25:07 <shapr> I should really change that...
07:26:07 <jonkri> shapr: can i see your former business site? :-)
07:28:52 <goron> getFoo = do mystate<-get
07:28:52 <goron>              return $ (foo mystate)
07:29:03 <shapr> jonkri: http://www.webwitches.com/
07:29:12 <goron> How can I abstract over this pattern in the state monad?
07:29:39 <goron> I need a setter for every part of the record in mystate.
07:30:56 <goron> Never mind
07:32:06 <mauke> return $ ( ) is redundant
07:33:11 <ndm> anyone know if there is any way to change the prompt in GHCi?
07:33:31 <goron> mauke: because it's in a do block?
07:33:49 <essiene> (ahem)
07:34:11 <essiene> i'm trying to understand continuation passing style...
07:34:31 <essiene> i basically understand the concept but staring at a real example... i'm coming up null void
07:34:46 <Saulzar> essiene, I am guessing you ran into the cpsFold example? 
07:34:50 <mauke> goron: f $ g x is the same as f (g x)
07:34:52 <goron> mauke: it was necessary in this case. 
07:35:06 <goron> mauke: I mean the return
07:35:12 <goron> mauke: nm, you meant something else.
07:36:40 <essiene> oops... was disconnected
07:36:59 <essiene> Saulzar, i was saying yup... the very same fold example in YAHT
07:37:13 <essiene> you mind explaining it some?
07:37:34 <Saulzar> essiene, Yeah - I think it's rather hard, I would skip it and come back later
07:38:01 <essiene> oh.. cool.. i don't have to feel guilty about skiping it then ;)
07:38:22 <essiene> i felt bad not being able to implement map and filter as continuation passing bleh...
07:38:36 <essiene> ;)
07:38:57 * essiene pretends not to have seen the exercises on CPS and moves onto IO in all its glory
07:55:06 <goron> setState fieldName value = do mystate<-get
07:55:06 <goron>                               put mystate{fieldName=value}
07:55:22 <goron> Can I do something like this, which does work?
07:56:11 <ihope> @index put
07:56:12 <lambdabot> Control.Monad.State, Control.Monad.RWS
07:57:02 <musasabi> goron: you cannot do that. Record field names are not first class entities, but rather plain functions.
07:57:18 <goron> musasabi: yes, I noticed. How unfortunate.
08:05:42 <jonkri> cya ppl
08:06:38 <jak> musasabi, goron, it's a bit weird because you can pass around the accessor function, but not the setter
08:06:41 <jonkri> shapr: good luck with your stuff :-)
08:07:09 * vincenz has the freakiest indirect composites ever
08:09:05 <musasabi> jak: one can use Drift to derive the setter functions and pass those around.
08:09:06 <Saulzar> Hmm, DriFT seems to have stuff to create getters/setters/update for labels
08:10:34 * vincenz wootwoots
08:10:54 <musasabi> dons: committed nsieve and partial-sums.
08:12:29 <Saulzar> Record updates would certainly be a nice thing to have around, seem to waste a lot of lines with ugly \s -> s { foo =  }  code
08:13:25 <vincenz> ???
08:13:34 <vincenz> Saulzar: and how would the syntax be
08:14:04 <goron> I think the only thing you would end up with is reinventing Lisp.
08:14:21 <Saulzar> Why's that?
08:14:22 <Saulzar> Well, drift seems to make a function   g_foo  s_foo and u_foo
08:15:12 * vincenz loves indirect composite
08:15:13 <goron> Every time some guy designs a language, the users come after some time: "Why don't we have foo?"
08:15:16 <vincenz> though it's a bit spammy at first
08:16:16 * vincenz wonders what people think of his func name "scopalize"
08:16:16 <goron> Template Haskell does not solve it completely. 
08:16:16 <Saulzar> vincenz, Not immediately obvious what it does :P
08:16:16 <vincenz> Saulzar: well if you were italian...
08:16:38 <Saulzar> Oh, scopealise :)
08:16:38 <vincenz> yah
08:16:38 <vincenz> but scopalize has a nicer undertone
08:16:38 * Saulzar thought it was a random jumble of letters
08:16:39 <vincenz> Saulzar: not yet sure whether to use a reader
08:17:17 <vincenz> is it possible to make dataconstructors (aka typeS) transpaprent through monads?
08:17:22 <vincenz> like 
08:17:26 <vincenz> data Me x = M x
08:17:29 <vincenz> make that M transparent
08:17:37 <vincenz> so you can just do transfos on x
08:18:44 <Saulzar> ??
08:20:31 <goron> I have a beautiful program with zero performance. :-(
08:22:26 <vincenz> who is andrew bromage
08:31:32 <vincenz> I should prolly make scopalize a monad
08:31:59 <vincenz> hmm
08:51:18 <azuroth> is there any function in the prelude like \o r x -> if x == o then r else x ..?
08:52:05 <mauke> @pl \o r x -> if x == 0 then r else x
08:52:06 <lambdabot> const (join . flip (if' . (0 ==)))
08:52:10 <mauke> hm
08:52:18 <mauke> @pl \o r x -> if x == o then r else x
08:52:20 <lambdabot> flip flip id . (ap .) . flip . (if' .) . (==)
08:52:50 <azuroth> at pl?
08:53:15 <mauke> it stands for "pointless"
08:53:32 <mauke> sometimes it can simplify code, but most of the time it makes a horrible mess :-)
08:53:41 <azuroth> heheh, excellent
08:54:43 <mauke> why do you need this function?
08:56:51 <azuroth> just to change a list of strings such as "     ***" to  "     @@@". it's not important at all, I was just wondering because before I really thought about it, I thought it was common
08:57:26 <mauke> ah, hmm
08:58:31 <vincenz> @which lift
08:58:32 <lambdabot> Unknown command, try @listcommands.
08:58:33 <vincenz> @type lif
08:58:35 <lambdabot> Not in scope: `lif'
08:58:35 <vincenz> @type lift
08:58:37 <lambdabot> Not in scope: `lift'
08:58:42 <vincenz> @hoogle lift
08:58:44 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
08:58:44 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
08:58:44 <lambdabot> a
08:58:44 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
08:58:51 <vincenz> @hoogle liftS
08:58:53 <lambdabot> No matches found
09:16:33 <xerox> @type flip id
09:16:35 <lambdabot> forall b c. b -> (b -> c) -> c
09:39:17 <vincenz> @hoogle runstate
09:39:19 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
09:39:19 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
09:40:13 <vincenz> me mutters at typing
09:41:27 <vincenz>     No instance for (Scope PIdent b)
09:41:27 <vincenz>       arising from use of `scopalize' at Analysis.hs:21:20-28
09:41:27 <vincenz>     Probable fix: add an instance declaration for (Scope PIdent b)
09:41:38 <xerox> > Control.Monad.State.runState (return ()) () :: ((),())
09:41:39 <vincenz> instance Scope PIdent MIdent where
09:41:40 <lambdabot>  Not in scope: `Control.Monad.State.runState'
09:41:49 <vincenz> wtf
09:42:40 <vincenz> why?
09:43:03 <xerox> Dunno.
09:43:11 <vincenz> pisses me off
09:43:42 <xerox> How is Scope defined?
09:44:00 <vincenz> class Scope a b where scopalize :: a -> State Env b
09:44:00 <vincenz> instance Scope PIdent MIdent where scopalize x = return . MI . unPI $ x
09:44:24 <vincenz> -fglasgow-exts
09:44:30 <gFunk> @hoogle deepSeq
09:44:31 <lambdabot> No matches found
09:44:38 <xerox> Try a monomorphic type on the error's line.
09:45:01 <gFunk> @hoogle $!!
09:45:02 <lambdabot> No matches found
09:45:07 <xerox> ...or add '| a -> b' in the class definition.
09:45:16 <vincenz> xerox: thx
09:45:21 <xerox> You're welcome!
09:45:22 <vincenz> xerox: what does that mean?
09:45:26 <vincenz> | a -> b
09:45:38 <xerox> It means that the type 'a' selects the type 'b' uniquely.
09:45:45 <xerox> They're called functional dependencies.
09:45:46 <vincenz> where do I puit this?
09:45:56 <xerox> class Foo a b | a -> b where ...
09:45:59 <vincenz> coo
09:46:06 <xerox> Indeed.
09:46:20 <vincenz> hmm
09:46:22 <vincenz> dum dum
09:46:28 <xerox> Any luck?
09:46:32 <vincenz> I could use some typeclass help
09:46:33 <vincenz> xerox: yep
09:46:40 <xerox> Okay then.
09:47:31 <lisppaste2> vincenz pasted "typeclasses with IndirectComposite" at http://paste.lisp.org/display/16626
09:48:03 <vincenz> xerox: PXXX and MXXX are both derived from the same indirectcomposite
09:48:17 <vincenz> so I would like to have the P ->M specific stuff lifted
09:48:20 <xerox> What is an IndirectComposite?
09:48:22 <vincenz> and then a generic XXX -> XXX traversal
09:48:28 <vincenz> http://www.haskell.org/hawiki/IndirectComposite
09:48:30 <xerox> Oh-hum.
09:48:33 <dcoutts> JaffaCake, is there any easy way to disable the X11 & HGL packages that ghc-6.4.x builds?
09:49:07 <vincenz> xerox: basically traversal should only be defined on the composite
09:49:11 <dcoutts> JaffaCake, for the OpenGL, OpenAL & GLUT packages there are corresponding --enable-foo/--disable-foo flags
09:49:21 <vincenz> xerox: while the specific acitions should be in in Txxx -> Yxxx typeclasses
09:49:23 <vincenz> I hope that makes sense
09:49:37 * xerox mumbles
09:49:43 <dcoutts> JaffaCake, I'm wondering if it's possible without patching the configure.ac or Makefile files
09:49:53 * vincenz is a pain
09:50:00 <vincenz> :P
09:50:16 <xerox> It's the first time I see those things, woop.
09:50:25 <vincenz> I'm doing pretty disgusting thigns
09:51:19 <lisppaste2> vincenz annotated #16626 with "My types" at http://paste.lisp.org/display/16626#1
09:51:40 <xerox> vincenz: can we reduce the problem to simpler terms?
09:51:45 <vincenz> xerox: sure
09:54:39 <lisppaste2> xerox annotated #16626 with "is this the right idea?" at http://paste.lisp.org/display/16626#2
09:54:49 <vincenz> no
10:00:07 <vincenz> I might have it
10:01:14 <gour> Lemmih: fps (from repo mentioned in README) does not build with ghc-head. any other solution regarding fps?
10:05:07 <lisppaste2> vincenz annotated #16626 with "There you go" at http://paste.lisp.org/display/16626#3
10:05:15 <vincenz> doesn't work yet
10:05:18 <vincenz> but that's the idea
10:06:10 <vincenz> oh yeah, m shoul dobviously be a mona
10:06:25 <vincenz> it complains on the class def :/
10:07:49 <vincenz> :/
10:10:01 <xerox> This is malformed: data MExp d = ME d (Exp (MExp d))
10:10:19 <xerox> Because of 'data Exp id exp = ..'
10:10:21 <vincenz> getting somewhere
10:11:51 <vincenz>     Probable fix:
10:11:51 <vincenz>       add (MonadState [String] m) to the class or instance method `transform'
10:11:51 <vincenz>       or add an instance declaration for (MonadState [String] m)
10:11:59 <vincenz> how do I do that?/
10:12:09 <xerox> I got a working module, I don't know if it matches what you want, tho.
10:12:17 <vincenz> xerox: lemme see?
10:13:04 <lisppaste2> xerox annotated #16626 with "Inducted, we'll see." at http://paste.lisp.org/display/16626#4
10:14:25 <vincenz> woo
10:14:29 <xerox> Uh.
10:15:33 <xerox> I just intuitively adjusted the Haskell, I still do not know purposes and meanings.  Your 'woo' is both creepy and cool to some degree.
10:16:15 <vincenz> still one bug
10:17:07 <xerox> What, if I may ask?
10:17:22 <vincenz> well there were a lot
10:17:25 <vincenz> now almost one left
10:19:39 <lisppaste2> vincenz annotated #16626 with "one bug" at http://paste.lisp.org/display/16626#5
10:19:48 <vincenz> obviously
10:19:52 <vincenz> traverse will be a typeclass too
10:19:58 <vincenz> like traverseDeep or TRaversebreadth
10:22:04 * xerox fails to understand
10:24:30 * vincenz too
10:25:00 <vincenz> @hoogle transform
10:25:02 <lambdabot> Graphics.Rendering.OpenGL.GL.SavingState.TransformAttributes :: ServerAttri
10:25:02 <lambdabot> buteGroup
10:25:32 <vincenz> why won't htis work
10:26:52 <vincenz> it should wokr!
10:28:10 <vincenz> why o why!
10:28:10 <xerox> Should it?
10:28:17 <vincenz> of course
10:29:16 <vincenz> it's like the ME is not being applied
10:30:28 * vincenz sniffs
10:30:35 <Saulzar> Some funky looking types there
10:30:35 <xerox> Mumble.
10:30:52 <xerox> There is some problems with wrapping...
10:31:16 <vincenz> xerox: how so
10:31:35 <xerox> Because you call transform inside traverse, hence, you can get back a "Exp .. (Exp .. (Exp .."
10:31:44 <vincenz> xerox: so?
10:31:46 <vincenz> xerox: that's correct
10:31:48 <Lemmih> gour: Maybe you can just remove the fps dependency from the projects needing it (commonsense?). I don't think hide is actually using FPS just yet.
10:31:58 <vincenz> any type-experts arond?
10:32:06 <xerox> That's not what you meant to mean, in my opinion, with (MExp [String]) is it?
10:32:15 <Lemmih> gour: Did you poke dons.
10:32:29 <vincenz> xerox: but ... transform returns a Mexp
10:32:53 <xerox> ....but it calls traverse, which calls transform without unwrapping!  As I see it.
10:32:58 <vincenz> xerox: huh?
10:32:59 <xerox> Err, wrapping.
10:33:04 <vincenz> xerox: I don't need to unwrap
10:33:09 <vincenz> xerox: and I wrwap
10:33:11 <vincenz> notice the ME 
10:33:23 <vincenz> doh!
10:33:39 <vincenz> of course!!!
10:33:49 <xerox> :-)
10:34:05 * xerox blushes
10:34:08 <vincenz> \o
10:34:11 <vincenz> I forgot a <-
10:34:19 <vincenz> instance TransformT (State [String]) PExp (MExp [String]) where
10:34:19 <vincenz>   transform x = do
10:34:19 <vincenz>       x' <- traverse . unPE $ x
10:34:19 <vincenz>       return . (ME []) $ x'
10:34:26 <vincenz> \o/
10:37:52 <vincenz> @hoogle runState
10:37:53 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
10:37:53 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
10:39:31 <vincenz> woot!
10:39:51 <vincenz> \o/
10:40:14 <vincenz> I should write a paper on this
10:40:26 <vincenz> decoupling ast traversal from ast-actions
10:40:36 <lisppaste2> vincenz annotated #16626 with "IT WORKS!" at http://paste.lisp.org/display/16626#6
10:40:53 <xerox> Whoopee.
10:40:58 <vincenz> nifty huh?
10:41:08 <xerox> It's all in your mind
10:41:14 <vincenz> xerox: nah it's actually useful
10:41:22 <vincenz> xerox: see now I only define the traversal over my AST ONCE
10:41:23 <xerox> Just kidding :-)
10:41:30 <vincenz> and I can do many traversals for typechecking, etc, etc
10:41:38 <vincenz> ;)
10:42:00 <vincenz> let me demonstrate in that example
10:42:51 <vincenz> is tere a "do nothing" monad?
10:42:59 <xerox> The Identity Monad.
10:43:04 <vincenz> what's it name
10:43:11 <xerox> @hoogle Identity
10:43:12 <lambdabot> Control.Monad.Identity.Identity :: Identity a
10:43:12 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
10:43:12 <lambdabot> Control.Monad.Identity.runIdentity :: Identity a -> a
10:43:45 <vincenz> be prepared to be shocked
10:43:57 * xerox trembles
10:45:51 * Saulzar runs out of stack space
10:45:58 <vincenz> Saulzar: ?
10:46:49 <Saulzar> Just reading the code, it's pretty neat :)
10:47:00 <vincenz> blegh, identity ain't good
10:47:56 <vincenz> @hoogle II
10:47:57 <lambdabot> Data.Char.isAscii :: Char -> Bool
10:47:57 <lambdabot> GHC.Unicode.isAscii :: Char -> Bool
10:47:57 <lambdabot> GHC.Unicode.isAsciiUpper :: Char -> Bool
10:48:36 <vincenz>     Couldn't match `Identity IIdent' against `t -> t1'
10:48:36 <vincenz>       Expected type: Identity IIdent
10:48:36 <vincenz>       Inferred type: t -> t1
10:48:40 <vincenz> but Identity is a MONAD!
10:54:18 <lisppaste2> vincenz annotated #16626 with "one traversal, multiple actions" at http://paste.lisp.org/display/16626#7
10:54:24 <Saulzar> Erg, my code for initialisation really stinks
10:54:29 <vincenz> @hiii;)
10:54:30 <lambdabot> Unknown command, try @listcommands.
10:54:32 <vincenz> ;)
10:54:35 <vincenz> check out that link
10:54:44 <vincenz> shapr: can I write an article on that?
10:55:23 <vincenz> time to apply this to my ast
10:56:09 <tibbe> what's the simplest way to get the first command line argument? (i.e. argv[1] in C)
10:56:20 <vincenz> args <- getAgs
10:56:24 <mauke> @type getArgs
10:56:24 <vincenz> args !! 0
10:56:26 <lambdabot> Not in scope: `getArgs'
10:56:31 <vincenz> @hoogle getArgs
10:56:32 <lambdabot> System.Environment.getArgs :: IO [String]
10:56:32 <lambdabot> Graphics.UI.GLUT.Initialization.getArgsAndInitialize :: IO (String, [
10:56:32 <lambdabot> String])
10:56:33 <vincenz> ;)
10:56:35 <mauke> @type System.getArgs
10:56:37 <lambdabot> IO [String]
10:56:57 <tibbe> thanks
10:57:10 <tibbe> I only found GetOpt and it was a bit of an overkill
11:00:01 <xerox> vincenz: [first] <- getArgs
11:00:11 <vincenz> o.o
11:00:15 <vincenz> that will fail on multiparams
11:00:18 <vincenz> you prolly mean
11:00:20 <vincenz> first:_
11:00:30 <xerox> It's the same.
11:00:34 <vincenz> no
11:00:39 <vincenz> [first] binds a single element list
11:00:47 <xerox> Mmh.
11:02:22 <xerox> Right.
11:02:50 <xerox> > (do { [x] <- ["foo"]; return x }, do { (x:_) <- ["foo"]; return x })
11:02:51 <lambdabot> ("","f")
11:03:03 <vincenz> firsto ne fails
11:05:21 <vincenz> @hoogle mapM
11:05:23 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:05:23 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:05:23 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
11:05:40 <vincenz> @hoogle sequence
11:05:42 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
11:05:42 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
11:05:42 <lambdabot> Control.Monad.sequence_ :: Monad m => [m a] -> m ()
11:25:11 <wanahogalugi> Is gtk2hs cvs no longer a subdirectory of fptools?
11:25:51 <Lemmih> gtk2hs isn't even in cvs anymore.
11:26:04 <wanahogalugi> darcs?
11:26:08 <Lemmih> Yep.
11:27:15 <wanahogalugi> Lemmih Can you tell me where to find the link to download it? I didn't find it on www.haskell.org/gtk2hs
11:30:42 <liyang> Is Set a Functor?
11:31:02 <vincenz> > fmap :: (Set a -> Set b)
11:31:04 <lambdabot>  Not in scope: type constructor or class `Set'
11:31:11 <vincenz> > fmap :: (Data.Set a -> Data.Set b)
11:31:13 <lambdabot>  Not in scope: type constructor or class `Data.Set'
11:31:17 <xerox> liyang: nope.
11:31:23 <vincenz> > fmap :: (Data.Set.Set a -> Data.Set.Set b)
11:31:25 <lambdabot>  Not in scope: type constructor or class `Data.Set.Set'
11:31:39 <xerox> liyang: there are problems with the Ord instance.
11:31:39 <vincenz> bleh
11:32:19 <liyang> It ought to be, in other words...
11:34:32 <liyang> :(
11:35:06 <Lemmih> wanahogalugi: http://darcs.haskell.org/gtk2hs
11:40:32 <astrolabe> @hoogle Set
11:40:34 <lambdabot> Data.Set.Set :: Set a
11:40:34 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment.Set :: LogicOp
11:40:34 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar.set :: [IO ()] -> IO ()
11:40:59 <gour> Lemmih: i poked dons and he said he'll look at it tomorrow. i'll try be removing fps deps
11:41:24 <sieni> hmm... ghc takes an eternity to compile on this powerbook
11:46:01 <wanahogalugi> Ah
11:50:07 <dcoutts> wanahogalugi, the link to the darcs repo is on the gtk2hs web site: haskell.org/gtk2hs/development
11:52:54 <MarcWeber> I think I haven't seen it because I was still looking for cvs ;-)
12:00:20 <shapr> vincenz: Hey man, write any article you like :-)
12:03:34 <gour> Lemmih: hide-CommonSense-0.1 reqs fps
12:21:00 <sieni> it would be fun to autotime these compilation sessions
12:59:41 <Jarod_> hi everyone
13:00:09 <Lemmih> Hi Jarod_.
13:01:27 <Jarod_> I just discovered functionnal programming and Haskell that i find cool and i wonder if some of you could give me urls for good tutorials
13:02:09 <mauke> what language(s) do you know?
13:03:14 <Jarod_> basic (lol), a bit of C++ (disastrous language), a bit of Python (cool language)
13:03:40 <gzl> there are some tutorials linked on haskell.org.
13:03:45 <gzl> yet another haskell tutorial, etc.
13:04:30 <mauke> http://haskell.org/haskellwiki/Books_and_tutorials#General_Introductions_to_Haskell
13:05:12 <Jarod_> ok thanks
13:05:54 <Jarod_> is it not so hard to learn functional programming ?
13:08:38 <gzl> Jarod_: shouldn't be much worse than anything else
13:08:53 <Lemmih> @where yaht
13:08:54 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
13:08:57 <gzl> conceivably you might have less trouble since you don't have much experience with other languages
13:09:20 <gzl> if you had more experience it might be harder to switch thinking style
13:09:58 <neologism> Jarod_: functional languages are more math oriented then imperative ones
13:10:01 <jethr0> moin moin, #haskell
13:10:32 <Jarod_> ok, thanks for your help
13:11:00 <Jarod_> and a final question, is any french people here ?
13:11:05 <Jarod_> ^
13:11:08 <Jarod_> ^^
13:11:43 <musasabi> Probably yes.
13:12:15 <gzl> yeah, they're mathier in flavor.
13:12:51 <Lemmih> gzl: French people?
13:14:04 <gzl> actually, French people too. but I meant FP languages.
13:14:20 <Jarod_> ok i will work on tutorials, bye and thanks
13:21:13 <ulfdoz> Is there a function, which makes every element in a List unique?
13:21:36 <sieni> ulfdoz: nub
13:21:47 <sieni> > nub [1,2,3,3,4]
13:21:48 <lambdabot> [1,2,3,4]
13:22:10 <ulfdoz> thx
13:22:18 <sieni> import List might be necessary
13:25:10 <Cale> If you don't mind sorting the list,  (map head . group . sort)  is faster.
13:26:31 <jethr0> btw, is List.sort stable (i.e. retains order of elements that are equal under the metric)?
13:33:19 <Igloo> yes
13:33:29 <lightstep> @hoogle Handle -> IO [Word8]
13:33:29 <lambdabot> No matches, try a more general search
13:33:41 <lightstep> @hoogle Handle -> IO [Char]
13:33:43 <lambdabot> No matches, try a more general search
13:34:55 <jethr0> lightstep: hGetBufNonBlocking?
13:35:04 <jethr0> @hoogle hGetBufNonBlocking
13:35:05 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
13:37:09 <lightstep> i'm still wondering what i want to do
13:37:10 <jethr0> and then "peek :: Ptr Word8 -> IO Word8"
13:37:12 <jethr0> maybe
13:37:18 <jethr0> lightstep: that's always a good start :)
13:37:37 <lightstep> i think i'll read byte-by-byte, and hope that the default buffering if good
13:37:39 <jethr0> what _do_ you want to do? read a file as bytes
13:37:40 <lightstep> *is
13:37:55 <jethr0> you can always switch to NoBuffering
13:37:55 <lightstep> i heard that Char is 21-bit
13:38:02 <jethr0> huh?
13:38:11 <lightstep> unicode and stuff
13:38:11 <jethr0> under what circumstances?
13:38:25 <mauke> I hope it's 24-bit
13:38:35 <jethr0> isn't the length of a char in utf8 undetermined in advance?
13:38:54 <lightstep> so i want to read the file in units of Word8
13:39:04 <lightstep> (since i don't know what a Char is)
13:39:19 <lightstep> @index Bit
13:39:20 <lambdabot> bzzt
13:39:29 <jethr0> @index Bits
13:39:30 <lambdabot> Data.Bits, Foreign
13:40:22 <jethr0> i wouldn't think that patching several 21-bit thingeys together into 24-bit thingeys in haskell would be a lot of fun...
13:40:49 <jethr0> and i honestly can't imagine anyone chosing 21bit width for anything sane...
13:42:01 <lightstep> i want to do IO in bits or in bytes (each file handled uniformly). what library does that?
13:42:55 <jethr0> i'm no expert in that, but my guess would be "hGetBufNonBlocking" and "peek"
13:43:23 <jethr0> you mean, you want to do _file_ IO in bits or bytes, right?
13:43:30 <lightstep> yes
13:44:10 <lightstep> i thought that higher-level libraries for these already exist
13:44:15 <jethr0> hmm
13:44:31 <jethr0> as i said, no expert :)
13:44:48 <jethr0> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html is always a good place to look
13:47:04 <tony2> I use NewBinary for that.
13:47:39 <tony2> file IO in bits and bytes I mean.
13:49:22 <lightstep> does it come with ghc?
13:49:39 <tony2> no it's a library.
13:50:04 <tony2> @google newbinary haskell
13:50:06 <lambdabot> http://www.isi.edu/~hdaume/haskell/NewBinary/
13:51:01 <lightstep> thanks
13:51:38 <tony2> That new streams extensibile IO library posted on the mailing list can read utf8 I think, if thats what your trying to do.
13:52:43 <lightstep> i'm actually trying to show someone how simpler her programs to learn/use huffman encoding could be simpler in haskell
13:53:31 <tony2> Ahh very good, thats an example in umm... craft of fp I think.
13:54:37 <lightstep> that seems like cheating
13:55:00 <lightstep> (i have a local copy of sicp, and didn't look at that exercise there)
13:55:32 <tony2> well, it's the postmodern approach. Cheating, using other peoples code, call it what you will :)
14:04:28 <lightstep> @hoogle comparing
14:04:29 <lambdabot> No matches found
14:05:11 <Dreadshoot> anyone used hs plugins in win?
14:08:37 <Cale> lightstep: comparing p x y = compare (p x) (p y)
14:08:47 <Cale> It's not currently in the libraries
14:09:23 <lightstep> thanks, i just wanted to check if it's in the libraries
14:10:04 <lightstep> is there a Num without Ord?
14:10:14 <lightstep> oh, of course, complex
14:10:33 <Cale> yeah, and, say, polynomial or power series rings
14:11:06 <neologism> lightstep: I think you can compare complex.. 
14:11:21 <lightstep> i think i can
14:11:39 <lightstep> but i don't wanna
14:11:48 <neologism> there's ordering defined for complex
14:11:57 <neologism> but its not... shit I dont remember the terminology
14:12:00 <Pseudonym> There shouldn't be.
14:12:00 <Cale> No instance for (Ord (Complex a))
14:12:08 <Cale> It's not an ordered field.
14:12:14 <neologism> Cale: I mean in math :)
14:12:18 <Pseudonym> You can define all sorts of orderings if you want.
14:12:20 <Cale> In math
14:12:38 <Cale> There's no way to make it satisfy the axioms of an ordered ring
14:12:43 <Pseudonym> Right.
14:12:51 <lightstep> since they are categoric?
14:12:55 <Cale> hm?
14:13:11 <lightstep> one model up to isomorphism
14:13:28 <neologism> Cale: I think you can
14:13:31 <Pseudonym> The axioms of an ordered ring are:
14:13:41 <Pseudonym> If a <= b, then a + c <= b + c
14:13:51 <Pseudonym> If 0 <= a and 0 <= b, then 0 <= a*b
14:13:55 <jethr0> what's speaking against ordering: 1. length 2. angle in polar coords
14:14:02 <Pseudonym> I think it's the last one that gets you.
14:14:18 <Cale> jethr0: it won't satisfy those two axioms
14:14:25 <jethr0> *damn*
14:14:30 <neologism> ordering by lenght satisfies those two axioms
14:14:36 <Pseudonym> No it doesn't.
14:14:37 <neologism> or not?
14:14:37 <Cale> You can put some arbitrary order on them, but it won't cooperate with the ring structure.
14:14:44 <neologism> Pseudonym: show me
14:14:47 <jethr0> neologism: it's a half order, isn't it?
14:14:54 <neologism> whats half order?
14:14:57 <lightstep> it satisfies those axioms, but not the full-order axioms
14:15:00 <Cale> partial order
14:15:08 <jethr0> sorry, what i meant
14:15:10 <Pseudonym> Length is magnitude, right?
14:15:13 <lightstep> yes
14:15:16 <neologism> Cale: yes.. probably yes
14:15:21 <jethr0> i'm not so firm in english algebra terminology :)
14:15:24 <neologism> yes! thats it! now I remember
14:15:44 <Pseudonym> Length ordering doesn't satisfy the first axiom.
14:16:08 <neologism> hm.. you're right
14:16:17 <Cale> i and 1 are in C
14:16:28 <Cale> i <= 1 under that order
14:16:38 <Pseudonym> Right.
14:16:44 <neologism> Pseudonym: 
14:16:46 <neologism> http://planetmath.org/encyclopedia/PartialOrder.html
14:16:47 <Cale> so i - 1 <= 1 - 1 if axiom 1 holds
14:16:55 <Cale> so i - 1 <= 0
14:16:58 <Cale> but it's not.
14:17:02 <Pseudonym> Of course magnitude is a partial order.
14:17:09 <neologism> Pseudonym: from that page it seems like its total order
14:17:11 <Cale> It's also not a ring order.
14:17:13 <Pseudonym> Much like Euchlidean distance.
14:17:41 <Pseudonym> Oh, yeah, one of the axioms of an ordered ring is that <= is a partial order.  Or a total order.
14:17:42 <Pseudonym> Or something.
14:17:53 <jethr0> neologism: many "different" vectors are the "same" under magnitude
14:17:55 <Pseudonym> Total order.
14:17:59 <neologism> jethr0: yes
14:18:08 <Cale> In an ordered ring, no negative element is a square.
14:18:13 <jethr0> :)
14:18:36 <neologism> I am not strong in english naming of the things ;(
14:18:48 <Pseudonym> Fair enouigh.
14:18:56 <jethr0> neologism: never mind. my algebra is really subpar. but i thought that in a total order no two different elements could be equal. but then again that might not be general enough (or even plain wrong)
14:19:15 <neologism> jethr0: I think they can
14:19:24 <Pseudonym> The totality criterian is that any two elements must be comparable.
14:19:26 <neologism> at least from what I remember and what the web page I posted says
14:19:46 <Cale> If a /= 0 and a = b^2, then b /= 0 and a = (-b)^2. As b is nonzero, either b or -b is positive. Since the product of positive numbers is positive, a must be positive.
14:20:22 <jethr0> Cale: are we in a field?
14:20:30 <Cale> jethr0: yeah.
14:20:33 <jethr0> k
14:20:46 <Cale> jethr0: we were talking about trying to order the complex numbers
14:20:50 * Igloo sighs as recursive module imports and ghc
14:20:51 <jethr0> :)
14:20:53 <Igloo> s/as/at/
14:21:45 <jethr0> i guess finding an isomorphism to something "easier" to order would do perfectly
14:22:07 <Cale> jethr0: but it can't be done in a meaningful way
14:22:17 <jethr0> i.e. another ring with over-countable(?) elements
14:22:27 <neologism> jethr0: dont think of equality as of a==a... think of it as a relation
14:22:28 <jethr0> i don't know the english term for that...
14:22:31 <Cale> you can of course totally order C, but the ordering will not make it an ordered field
14:22:38 <Cale> http://en.wikipedia.org/wiki/Ordered_ring
14:22:43 <neologism> for example relatio is_man means we all here are equal :)
14:23:01 <jethr0> neologism: first off, you don't know that
14:23:19 <Pseudonym> Some animals are more equal than others.
14:23:41 <jethr0> Cale: so there is no iso/homomorphism of C with an ordered field?
14:23:47 <neologism> Pseudonym: who says + must be defined the "clasic way"?
14:23:50 <Cale> jethr0: right
14:23:55 <Pseudonym> There's a homomorphism.
14:24:01 <Cale> oh
14:24:02 <Pseudonym> Re is such a homomorphism.
14:24:05 <neologism> because I think the first axiom holds for C
14:24:07 <Cale> sure, there's a hom
14:24:21 <Pseudonym> Re : C -> R
14:24:38 <jethr0> isn't there an isomorphism of R and C? but i guess it would be slightly recursive :)
14:24:43 <Cale> jethr0: more directly, there's no (partial) order <= which makes (C, <=) an ordered field.
14:24:46 <Pseudonym> It's a field/ring homomorphism, but it doesn't preserve ordering.
14:24:49 <astrolabe> That's not a ring homomorphism 
14:25:01 <Pseudonym> It isn't?
14:25:14 <Pseudonym> Oh, right.
14:25:16 <jethr0> i thought homomorphism was defined by preserving things like relations... (i'm totally out of my depth there)
14:25:18 <Pseudonym> It doesn't preserve *.
14:25:42 <astrolabe> -1=Re(i*i), Re(i)*Re(i)=0*0=0
14:25:45 <Pseudonym> It's not even a semi-ring homomorphism.
14:25:48 <Cale> wait, right, there can't be a hom C -> R
14:26:13 <astrolabe> How do you see that?
14:26:19 <astrolabe> Oh of course
14:26:29 <astrolabe> C is a field!
14:27:11 <astrolabe> The kernal of a ring homomorphism is an ideal, and the only ideals in C are {0} and C.
14:27:33 <Cale> f(i^2) = f(i)^2, so f(-1) = f(i)^2, so -1 = f(i)^2, but there is nothing in R which could possily satisfy that
14:27:45 <Pseudonym> Right,.
14:27:46 <Cale> that too :)
14:27:54 <Pseudonym> That's because R isn't algebraically closed.
14:28:15 <Pseudonym> Whereas C is.
14:28:36 <Pseudonym> So there is no homomorphism from C to R because algebraic closed-ness can't be preserved.
14:29:20 <Pseudonym> Well, that proves there's no field homomorphism, anyway.
14:29:29 <Pseudonym> Cale proves there's also no ring homomorphism.
14:30:14 <astrolabe> But there are ring homomorphisms from algebraically closed fields to not algebraically closed fields (excercise :)  )
14:30:27 * Pseudonym thinks
14:30:46 <Pseudonym> They'd have to be finite fields.
14:31:06 <Pseudonym> From GF(p^n) to GF(p)?
14:31:12 <astrolabe> They wouldn't be algebraically closed if they were.
14:31:18 <Pseudonym> Ah, good point.
14:31:25 <shapr> g'day Pseudonym 
14:31:28 <Pseudonym> G'day.
14:31:41 <jethr0> hey shapr
14:31:44 * Pseudonym vaguely recalls his Galois theory
14:32:07 <astrolabe> Another maths guy?
14:32:23 <Pseudonym> I learned this stuff before I knew what a normal subgroup was.
14:32:28 <Pseudonym> Which made it hard slog.
14:33:09 <astrolabe> I hope you don't mean galois theory.
14:33:19 <Pseudonym> I mean Galois theory, yes.
14:33:27 <astrolabe> Ug
14:33:35 <Pseudonym> I had the Galois theory textbook in one hand and the group theory textbook in the other.
14:33:40 <Pseudonym> Flipping backwards and forwards.
14:33:46 * astrolabe salutes you
14:34:05 <Pseudonym> Yeah, but I'm left not realising that finite fields aren't algebraically closed.
14:34:13 <Pseudonym> So don't salute too hard. :-)
14:34:44 <astrolabe> I'm trying to think why it's true.  My intuition says it is.
14:35:02 <Pseudonym> Thankfully I knew a little category theory first, so I wasn't thrown by terms like "subobject automorphism".
14:35:12 <Pseudonym> Well, they didn't call it that precisely.
14:35:53 <lightstep> astrolabe, you can make (x-a1)(x-a2)...(x-an) which is 0 over all elements except a0
14:36:10 <lightstep> then you can make a polynom that doesn't have a root over the entire field
14:36:39 <lightstep> perhaps (the coefficients may cancel each other)
14:36:46 <Pseudonym> Hmmm.
14:36:52 <astrolabe> A field must have p pth roots of unity.
14:37:07 <astrolabe> lightstep, I don't follow that.
14:37:10 <Pseudonym> I'm not so certain about this, now that I think about it.
14:37:40 <Pseudonym> In cryptography, they rely on polynomials over GF(2^n) having lots of possible solutions all of the time.
14:37:51 <astrolabe> I'm pretty sure
14:38:12 <Pseudonym> OK, let's answer a simpler question.
14:38:19 <Pseudonym> Is GF(2) algebraically closed?
14:38:32 <shapr> hiya jethr0, wassup?
14:38:35 <astrolabe> An algebraically closed field must have p pth roots of unity. (is what Imeant to say)
14:38:39 <jethr0> hey shapr 
14:38:51 <jethr0> shapr: i don't mean to be nagging, but what happened to the tmr?
14:38:55 <jethr0> shapr: need any help?
14:39:07 <shapr> With TMR? sure!
14:39:07 <astrolabe> pseudonym x^2+x+1 has no roots
14:39:08 <lightstep> Pseudonym, no, x^2+x+1 doesn't have any root
14:39:15 <shapr> What happened was that my clients stretched the crisis out ever further...
14:39:19 <shapr> It's still not finished.
14:39:26 <jethr0> shapr: what's there to do. i don't have too much time, but maybe some small things?
14:39:30 <Pseudonym> Oh, duh, of course.
14:39:33 <shapr> hm
14:39:50 <Pseudonym> If there weren't irreducible polynomials over GF(p), you couldn't construct GF(p^n).
14:40:00 * Pseudonym slaps forehead
14:40:09 <jethr0> shapr: i don't want to push you. just know that i'd be glad to help a little
14:40:11 <Pseudonym> In my defence, I have not had caffeine today.
14:40:35 <shapr> jethr0: You could look at the other articles that will be in issue six and check them over for bugs in grammar, spelling, or code/ideas.
14:40:44 <Pseudonym> A similar argument shows that all finite fields are not algebraically closed.
14:40:46 <astrolabe> Pseudonym: right!
14:40:49 <shapr> Of course, I'd have to be sure which articles might be in IssueSix...
14:40:56 <astrolabe> ah I spoke too soon
14:41:06 <Pseudonym> Because from GF(p^n) you can build GF(p^mn).
14:41:09 <shapr> I still wish esap and peti would kick out their articles, they have some might fine stuff.
14:41:20 <astrolabe> I can see why no finite field is ac, but the argument is a bit long.
14:41:33 <jethr0> shapr: sure, where do i look? at the IssueWhenever page?
14:41:34 <astrolabe> Oh ok. That works
14:42:19 <Pseudonym> That's probably a circular argument, because you probable prove this method of constructing fields FROM the fact that finite fields aren't AC.
14:42:19 <astrolabe> But relies on non-trivial knowledge about the existence of finite fields.
14:42:25 <Pseudonym> Right.
14:42:50 <Pseudonym> But at least it convinces us.  If it wasn't true, you couldn't do something that we know we can do.
14:42:53 <shapr> jethr0: Realistically, I should track down all the people who said they might have an article in this last issue and see what might go in.
14:43:58 <shapr> Philippa_: You think your TMR WIP article is ready to go?
14:44:10 <shapr> Cale: What about your scratchpad article?
14:44:11 <musasabi> How is one supposed to build the packages from http://darcs.haskell.org/packages/ in isolation?
14:45:08 <shapr> kzm's article looks finished - http://www.haskell.org/tmrwiki/LazyBackDoor
14:46:07 <astrolabe> if 'a' is a pth root of unity  in a field satisfies then |<a>| divides p.  If |<a>| = 1 for all such roots then x^p-1 = (x-1)^p, which isn't true if we choose p different to the characteristic of the field.
14:46:15 <jethr0> yes, i've glanced at it, already
14:46:47 <astrolabe> and delete 'satisfies' from what I just said.
14:47:31 <musasabi> and what is the email address where one is supposed to send those changes?
14:49:00 <Pseudonym> Coffee.  BBS
14:49:40 <jethr0> afk
14:55:56 <ulfdoz> How is NaN handled for orderings?
14:56:06 <ulfdoz> Is everything bigger and smaller?
15:00:09 <Cale> all comparisons with NaN return false
15:00:38 <Cale> including self-equality
15:00:58 <ulfdoz> thx, sounds more reasonable than my stupid idea.
15:01:19 <astrolabe> Are NaN, infinity and -infinity supported at the chip level?
15:01:37 <Cale> I think so
15:02:02 <Cale> Almost certainly in fact
15:02:50 <astrolabe> Hmmm.  Is it ok practise to use them non-trivially do you think?
15:03:04 <Cale> what do you mean by non-trivially? :)
15:03:28 <astrolabe> @eval 1/0 > 1
15:03:29 <lambdabot> True
15:03:41 <Cale> @eval 1/(-0) > 1
15:03:43 <lambdabot> False
15:04:06 <Cale> Floating point is a bit crazy :)
15:04:07 <astrolabe> eh? how did that happen?
15:04:19 <Cale> -0 isn't the same as 0
15:04:22 <Cale> in floating point
15:04:24 <astrolabe> Ah, sign bit.
15:04:34 <Cale> @eval 1/(-0)
15:04:36 <lambdabot> -Infinity
15:05:16 <Cale> > 0 == (-0)
15:05:18 <lambdabot> True
15:05:32 <Cale> > isNegativeZero 0 == isNegativeZero (-0)
15:05:34 <lambdabot> False
15:05:39 <astrolabe> > 0 == -0
15:05:40 <lambdabot> True
15:05:47 <astrolabe> wtf
15:06:04 <Cale> == isn't equality :)
15:06:14 <astrolabe> What is ==?
15:06:18 <shapr> Cale: Want to publish your scratchpad for the last TMR?
15:06:31 <Cale> shapr: you think it's enough? :)
15:06:43 <Philippa_> I should get round to finishing off the WIP monad thing, too
15:06:58 <Cale> astrolabe: it's nearly an equivalence relation, but NaN puts a stop to that
15:07:31 <astrolabe> Do you know how it's tested?
15:07:51 <Cale> look up IEEE floating point
15:08:00 <astrolabe> good idea
15:08:29 <astrolabe> I should probably know that anyway for my job
15:11:15 <shapr> Philippa_: Yes please!
15:11:44 <shapr> My client panic is nearly over, and I'll probably have time to kick out that last issue of TMR in the next few days.
15:12:49 <Philippa_> hmm. Guess that gives me something to do saturday
15:13:12 <shapr> Cale: You have a few TODO and MAYBE spots, have you decided whether to fill them out or leave them out?
15:13:33 <shapr> I think the isSubstringOf is an excellent discussion point.
15:18:21 <musasabi> dons: Number one again (shootout) :-)
15:19:00 <SyntaxNinja> yay!
15:20:11 <musasabi> it is scary to see Haskell beating C in imperative code which does not look horrible.
15:21:28 <astrolabe> hooray!
15:22:03 <musasabi> e.g. http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
15:22:38 <nuffer> um, anyone know where I can find docs for Graphics.UI.SDL?
15:22:43 <astrolabe> What do you people think the ultimate haskell / c  speed ration is (for an infinite amount of programming effort).
15:22:56 <astrolabe> *ratio
15:23:44 <Lemmih> nuffer: You can build them yourself.
15:24:12 <nuffer> how-so?
15:24:22 <Lemmih> `runhaskell Setup.lhs haddock`
15:25:31 <nuffer> thanks
15:25:38 <nuffer> you made those bindings, right?
15:26:32 <Lemmih> Yeah.
15:27:07 <nuffer> is it possible to get them working under windows?
15:27:11 <nuffer> because I was having a hell of a time
15:29:04 <Lemmih> Under cygwin?
15:29:32 <nuffer> um, yeah, under cygwin
15:29:37 <nuffer> I got it to build and install
15:29:39 <nuffer> and compile
15:29:42 <nuffer> but programs just didn't work
15:30:53 <Lemmih> Nothing happened when you ran them or did you get an error message?
15:31:43 <nuffer> nothing happened, I believe
15:31:55 <nuffer> this was a couple months ago, I don't remember the details
15:32:10 <Lemmih> And the program ran fine in Linux?
15:32:48 <nuffer> yes
15:32:58 <Lemmih> Weird.
15:33:30 <nuffer> have you personally gotten SDL programs to work under windows?
15:33:51 <Lemmih> I don't use windows.
15:34:11 <nuffer> hmmmm
15:50:00 <kowey> could somebody please explain this system.time inconsistency? i'm sure it's something stupid and obvious
15:50:47 <kowey> on my computer, this works, addToClockTime (noTimeDiff {  tdYear = 104 }) `liftM` getClockTime 
15:50:56 <kowey> but not with tdYear = 105
15:51:17 <kowey> ok, so maybe it's some kind of maxint type deal... but why is it that for somebody else's computer, it's 87 years that it can't handle?
16:03:01 <kowey> and here's another weird thing: normalizeTimeDiff $ noTimeDiff { tdYear=105 }
16:03:04 <kowey> 17 years?!
16:05:05 <TuringTest> I have not used those functions, sorry.
16:05:37 <kowey> TuringTest, give it a shot, if you have a minute... might be amusing
16:05:48 <TuringTest> one minute...
16:08:15 <TuringTest> > 2037 - 2006
16:08:17 <lambdabot> 31
16:08:21 <TuringTest> hmmm
16:12:14 <TuringTest> normalizeTimeDiff does stupid things
16:13:00 <TuringTest> It is clearly buggy
16:13:12 <TuringTest> And I bet addToClockTime uses it internally
16:13:13 <musasabi> Is there a way to create type signatures inside Template Haskell?
16:13:32 <TuringTest> What an interesting idea
16:14:53 <musasabi> I have "data Proxy a = Proxy" and need to create values inside TH, thus needing to insert a type signature.
16:16:18 <TuringTest> I have (a) never used TH but (b) I have read tutorials and docs and (c) I have never seen that mentioned
16:16:26 <musasabi> hmm, found SigP
16:17:22 <TuringTest> data Type ...
16:18:03 <TuringTest> ForAllT
16:18:12 <TuringTest> oops... ForallT
16:20:39 <TuringTest> got it
16:21:26 <lisppaste2> TuringTest pasted "TH" at http://paste.lisp.org/display/16638
16:21:31 <TuringTest> I learned this trick from http://haskell.org/hawiki/TemplateHaskell
16:21:38 <TuringTest> musasabi: Did that help?
16:22:35 <musasabi> thanks :-)
16:22:59 <TuringTest> I think SigE  works the same way as SigD
16:23:53 <TuringTest> runQ [| let a :: Int ; a = 7 in a |] >>= print
16:23:56 <dons> morning
16:24:00 <TuringTest> LetE [SigD a_1 (ConT GHC.Base.Int),ValD (VarP a_1) (NormalB (LitE (IntegerL 7))) []] (VarE a_1)
16:24:07 <TuringTest> dons: morning here, too!
16:24:20 <TuringTest> dons: Good trick with nsieve
16:24:58 <dons> yeah, made a big difference. i notice ghc now does a similar thing with mapM_ in the darcs version
16:25:41 <TuringTest> That explains why I could never use mapM_ for the looping for other beanchmarks.
16:25:56 * dons checks the shootout ranks
16:26:00 <TuringTest> ?
16:26:16 <jethr0_> hey dons
16:26:21 <dons> oh my!
16:26:24 <TuringTest> oh dear
16:26:35 <dons> @shootout
16:26:36 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
16:26:36 <lambdabot> all
16:26:41 <TuringTest> Everyone go look at http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:26:47 <TuringTest> before it changes
16:27:04 <jethr0_> dons: *yeah*
16:27:06 <dons> well, they have to do a bit now.
16:27:14 <dons> hmm, was that just from nsieve?
16:27:25 <jethr0_> why are we looking at pentium 4 all the time?
16:27:36 <dons> it gets updated nightly
16:27:37 <ihope> Yay!
16:28:00 <jethr0_> but i guess "C" implementing the 3 missing tests will boost them over 90 as well, no?
16:28:15 <dons> yep.
16:28:31 <dons> hehe. we beat C in nsieve now :)
16:29:02 <jethr0_> but still... "Haskell is still the language of choice for performance-aware hackers" (who don't mind optimizing ugly, non-idiomatic code :)
16:29:03 <TuringTest> jethr0_: OCaml is missing nsieve...
16:29:16 <jethr0_> yes, but they are _10_ points behind
16:29:34 <dons> yeah, they're unlikely to catch up without a lot of work
16:29:51 <dons> jethr0_, ccheck nsieve. it's very idiomatic
16:30:05 <dons> oh, and big speedup in partial-sums too.
16:30:18 <dons> hehe. we beat C there too!
16:30:26 <dons> with idiomatic code :)
16:30:42 <jethr0_> i didn't mean to be rude. but some of the entries aren't how one would write them in haskell on the first try (i.e. nbody)
16:30:49 <dons> sure.
16:30:51 <TuringTest> dons: Very carefully chosen idomatic code
16:30:52 <dons> it's a shootout.
16:31:05 <dons> very careful
16:31:20 <dons> lots of Core inspection and some C and asm output inspection too
16:31:25 <dons> in that partial-sums entry
16:31:28 <TuringTest> jethr0_: nbody was the 4th or 5th try
16:32:01 <TuringTest> jethr0_: It was very hard to get it to run 2x slower than Java
16:32:11 <dons> jethr0_, but this is always the story. write it 'normally', if it doesn't work, profile >> hack >> repeat
16:32:11 <jethr0_> TuringTest: i've tried too, but my pure version just didn't cut it speedwise. although it was _only_ 12 slower than the final version
16:32:22 <TuringTest> heh
16:32:27 <dons> so as long as you know how to profile, anyone can get to the same spot
16:32:56 <dons> sometimes we have breakthroughs though. like in regex-dna and nbody. we were stuck for a while there.
16:33:09 <jethr0_> yes, but being realistic, nbody would be a perfect example of clean, and feasible FFI!
16:33:33 <TuringTest> jethr0_: And necessary, since Haskell can't go faster.
16:34:00 <TuringTest> But the *worst* library was Text.Regex
16:34:19 <dons> all the marshalling makes it infeasible.
16:34:25 <jethr0_> yes, but when you look at the imperative languages, their solutions are more concise as well. it's just not a very suitable program for lazyness and side-effect freeness to come to effect
16:34:32 <jethr0_> TuringTest: i know
16:35:25 <TuringTest> On the CPU ranking (with Memory and Code lines set to zero) Haskell is second, between C and D
16:35:28 <dons> ah, Chris I see your regex email!
16:35:31 <jethr0_> i still wonder though how that was written... the only problem i had writing my own regexps with parsec was getting greedy evaluation. and it's so much faster than Text.Regex (judgin from dons/chris' entry)
16:35:45 <dons> it reminds me: I hacked  the lexer specifically for yi, so that it wouldn't advance one char after a lexeme matches
16:35:49 <TuringTest> dons: I could not fix it, just explain it.
16:35:57 <dons> and that's the version I'm using. that's the answer I think.
16:36:12 <dons> I should revert to the original one, not the 'return immediately' one.
16:36:22 <jethr0_> TuringTest: you regexes don't do greedy matching either, do they?
16:37:05 <jethr0_> my regex still won't work correctly with "a.*b", not even with an appended "$". i'll have to figure out what's going wrong there
16:37:10 <TuringTest> jethr0_: Mine?  I modified the entry by Alson Kemp to do both greedy and non-greedy matching
16:37:21 <jethr0_> k, i'll have a look then
16:37:27 <dons> cool, we beat D now. excellent.
16:37:36 <TuringTest> But I don't have carat ^ or dollar $ yet.
16:37:40 <TuringTest> dons: :)
16:38:00 <jethr0_> TuringTest: they are easy. $==eof, and ^==(getLine*getColumn==1)
16:38:29 <TuringTest> No, $ = end of line
16:38:36 <jethr0_> ah, ok
16:38:43 <musasabi> dons: I think nsieve is very very nice. We beat GCC and the code is still very pretty :-)
16:38:48 <dons> :)
16:38:57 <jethr0_> TuringTest: i'm not sure that's so. let me research :)
16:39:05 <TuringTest> jethr0_: man re_format
16:39:08 <TuringTest> (on OS X)
16:39:12 <dons> and now we're actually within distance of #1 cputime overall. only 3 pts off C.
16:39:17 <jethr0_> yup, you're right
16:39:33 <jethr0_> i just use multiline regexes with $ so rarely that i thought it was end-of-input
16:39:42 <dons> musasabi, and we beat GCC with partial-sums too -- implementing the same algo.
16:40:31 <TuringTest> @karma
16:40:33 <lambdabot> You have a karma of 2
16:40:36 <TuringTest> @karma+ dons
16:40:37 <lambdabot> dons's karma raised to 22.
16:40:51 <jethr0_> ^_^
16:40:53 <dons> @karma+ TuringTest
16:40:54 <lambdabot> TuringTest's karma raised to 3.
16:40:57 <dons> @karma+ musasabi
16:40:58 <lambdabot> musasabi's karma raised to 9.
16:41:43 <dons> and to think, 3 weeks ago we weren't sure we could ever beat SML ;)
16:41:59 <TuringTest> dons: OCaml is short an nsieve entry.  If I remove that from the benchmark, then OCaml is ranked higher on the CPU scale
16:42:21 <dons> we had an inferiority complex.
16:42:42 <tony2> Theres a certain irony in out performing gcc with ghc -O2 -whatever
16:42:46 <dons> yeah, fair enough. they are fast. though their concurrency doesn't seem very good.
16:43:00 <TuringTest> Yeah, Haskell is better at that
16:43:01 <dons> tony2, it's amazing. ghc generates 1k or more lines of C.
16:43:22 <tony2> yeah it is amazing.
16:43:37 <tony2> I'd of thought it was a fundamental limitation, you know using gcc.
16:43:39 <jethr0_> speaks for the good optimization of gcc to compile all that code to a faster version than the no-nonsense manual version
16:44:12 <jethr0_> i find it even a little paradox, how a more abstraction heavy version can outperform the straight-forward solution on such "easy" problems
16:44:52 <TuringTest> jethr0_: Haskell's use of constant expressions instead of variables helps in optimization
16:45:13 <tony2> with rts overheads also it's crazy really.
16:45:45 <TuringTest> tony2: The Haskell rts is very very lightweight, aside from the Garbage Collector.
16:45:57 <TuringTest> Which is not triggered by the small numeric programs
16:45:59 <tony2> indeed aside from the gc.
16:46:09 <tony2> tthats true.
16:46:30 <tony2> good thing binary size isn't a factor though.
16:46:53 <dons> and we have no C stack -- remember that ghc post-processes gcc's output to speed it up
16:47:20 <TuringTest> dons: Oh right -- I had forgotten reading about that
16:47:44 <tony2> dons, I didn't know that. I mean I kinda did .hc files and all I guess.
16:50:34 <dons> ghc runs the mangler over gcc's output'ed asm
16:50:48 <dons> @karma+ thhe_evil_mangler
16:50:49 <lambdabot> thhe_evil_mangler's karma raised to 1.
16:51:33 <dons> also, we have tailcalls
16:51:59 <tony2> I really must dig into ghc at some point.
16:52:39 <tony2> It's a more than a bit daunting though.
16:52:59 <tony2> does ghc work with gcc 4.x
16:53:09 <tony2> ?
16:53:35 <dons> sure.
16:54:07 <TuringTest> dons: Did you see the mailing list discussion of http://www.soi.city.ac.uk/~ross/instance-termination.patch ?
17:03:21 <TuringTest> good night,all
18:14:12 <azuroth> has anyone read "craft of functional programming?"
18:22:31 <Lemmih> Is it just me or does bang patterns mess things up?
18:22:38 <Lemmih> azuroth: Yes.
18:25:15 <azuroth> lemmih: in the ADT bit, he's talking about sets, he exports "eqSet" and makes Set an instance of Eq? does that seem weird to you?
18:27:11 <dons> Lemmih, did you see the discussion between John Hughes and SPJ on how tihngs get messed up?
18:27:18 <dons> they're a work in progress, I think.
18:27:21 <Lemmih> dons: No.
18:27:28 <dons> on haskell-prime@
18:27:49 <dons> since they got comitted, the semantics have  been revised a bit, I think.
18:28:03 <Lemmih> dons: I just know that I can't build ghc anymore because 'arr@(Array ...) ! i = ...' doesn't mean what it used to.
18:28:23 <dons> oh. hmm. 
18:28:31 <dons> that's weird..
18:28:38 <Lemmih> Blessed be `darcs unpull`.
18:28:47 <dons> presumably ghc still builds itself nightly?
18:30:55 <dons> (my point about SPJ and Hughes was that there are some subtle pattern issues, particularly with ~ patterns)
18:31:14 <Lemmih> Hm, the build reports say that it fails compiling Control.Monad.Writer.hs
18:33:19 <Lemmih> That last successful build report is from 02/05/06 /-:
18:34:05 <Lemmih> s/That/The/
18:34:35 <Lemmih> azuroth: A bit. It shouldn't be necessary to export eqSet.
18:41:00 <azuroth> okay, cool
18:49:51 <Bobstopper> I understand purely functional programming means the compiler can automatically arrange for parallel programming without the programmer needing to explicitly program threads in, yeah? Do any haskell compilers provide this kind of automatic concurrency? ghc perhaps? The user guide looks like it might
18:51:24 <dons> nope. it's theoretically possible, but practically, very tricky. however, ghc does have really nice concurrency support. it's very simple, just due to the normal fp reasons.
18:52:21 <dons> there is on going work to provide automatically parallel data structures, for example, but they're not in the main ghc branch yet. it may be come a hot topic in the next few years though.
18:52:51 <Bobstopper> ok, thanks.
18:53:10 <dons> check out here: concurrency is simple and fast in ghc -- it's a joy to use: http://shootout.alioth.debian.org/gp4/benchmark.php?test=message&lang=all
18:53:41 <dons> it's very easy to create bug free concurrent programs. everything else i've used has been a headache in comparison to the forkIO/MVar api GHC has.
18:55:05 <dons> i would say, we toss around threads like candy in ghc programs. as you know you're not suddenly going to mess up your program's semantics
18:56:17 <Bobstopper> yeah, pretty nice.
19:04:29 <Cale> you still can't get stupid with them :)
19:05:06 <Cale> It's probably not so good to have thousands of threads running
19:05:44 <Cale> but yeah, the concurrency stuff is pretty nice
19:09:46 <Korollary> I wonder if Haskell can be compiled into vliw archs like Itanium better than some other langs.
19:46:06 <Pseudonym> Ah, long lunch breaks.
19:46:08 <Pseudonym> I remember them well.
20:21:01 <dons> musasabi, a 10% faster nsieve-bits is on the wiki (I walked the Core and got some more args to the main loop unboxed). Should be 2nd or 3rd fastest entry.
20:41:38 <musasabi> Is there any way to get exist-types with Haskell?
20:42:42 <musasabi> I want write class like: class Foo a where foo :: exist t => X t a -> Y t a
21:06:36 <Lemmih> @seen gour
21:06:37 <lambdabot> I saw gour leaving #haskell 8 hours, 28 minutes and 18 seconds ago.
21:11:22 <gFunk> is this how to implement a strict foldM?  http://pastebin.com/547901
21:13:37 <palomer> hrmph
21:13:47 <palomer> it sucks that the jhc entries will be no faster than the ghc entries in the shootout
21:13:58 <palomer> since the ghc entries are optimized by hand
21:15:14 <azuroth> jhc, eh?
21:16:00 <dons> palomer? the jhc entries _could_ be faster. it's all haskell
21:16:12 <dons> depends on its clever code gen, etc etc.
21:16:38 <dons> i don't understand your argument
21:17:57 <palomer> my argument is that it's hard to beat hand optimized code 
21:18:13 <palomer> especiall if jhc is lacking primitive types
21:18:52 <dons> ah. ok. but the jhc code could also be hand optimized. we don't use unboxed types very often either.
21:19:18 <dons> i don't understand why 'hand optimized' is a big deal. surely you can 'hand optimize' a jhc program.
21:19:53 <dons> are you saying that jhc can't beat hand -unboxed code?
21:20:08 <dons> (maybe it can, I would argue -- it's all in the code gen)
21:20:47 <dons> anyway, it should be hard to beat hand optimised code :)
21:20:54 <palomer> I'm saying that jhc won't be able to apply many optimizations on hand optimized code
21:21:15 <palomer> furthermore, I think there should be a shoot out with only the most idiomatic of solutions
21:21:15 <dons> hand optimized, or hand unboxed?
21:21:21 <palomer> where jhc would shine
21:21:29 <palomer> I put hand unboxed in the hand optimized category
21:21:39 <dons> the "optimized" code just tends to use loops. i don't see why jhc can't handle that.
21:21:56 <dons> but unboxed types, you can't do much with, except generate efficient code
21:22:38 <dons> so, I say: hand optimizied is too vague. its manually unboxed code that would possibly pose problems
21:24:13 <palomer> spending time on the code to make sure the compiler generates the fastest possible executable is hand optimizing, and it's hard for an optimizing compiler to beat hand optimizations. unboxed types gives ghc an edge. that's all I'm saying
21:24:19 <palomer> anywho, I should get to bed
21:24:20 <palomer> night
21:24:24 <dons> anyway, all you'd do is rebox the code, and let jhc go nuts, if it really did generate fast code that way. no issue.
21:38:55 <gFunk> what's a good way to debug haskell?  Hat?
21:40:54 <Lemmih> GHCi, refactoring and Debug.Trace.
21:43:43 <gFunk> as debug tools?
21:44:12 <Lemmih> Yep.
21:44:25 <dons> bugs are rare enough that nothing further is needed
21:44:41 <dons> usually just stepping through the code with some input, in ghci, is enough
21:44:54 <gFunk> oh, i didn't know you can step in ghci
21:44:55 <dons> you can prevent bugs also with QuickCheck and HUnit
21:45:12 <dons> I meant, 'step in your head' -- your functions are short, right ;)
21:45:54 <dons> beginners seem to often think they need some kind of gdb-style debugger. but then you find you don't ever need such a thing
21:46:43 <gFunk> nah, i'm not one of those
21:46:54 <gFunk> although, i am a beginner
21:46:56 <dons> since the code is functional, debugging can be done in isolation, rather than in , say C, wheree you first have to reproduce the exact program state to get anywhere
21:47:00 <gFunk> i'm fighting laziness
21:47:10 <gFunk> and don't know what $!! is doing
21:47:31 <dons> ah, so its a perforamance issue?
21:47:41 <gFunk> heap exhausted
21:47:43 <dons> in that case, you profile.
21:47:51 <gFunk> reading a few million lines
21:47:58 <gFunk> foldM' _ a []     = return a
21:47:58 <gFunk> foldM' f a (x:xs) = do 
21:47:58 <gFunk>    aNow <- do return $!! a
21:47:58 <gFunk>    xNow <- do return $!! x
21:47:58 <gFunk>    y <- f aNow xNow 
21:47:59 <gFunk>    yNow <- do return $!! y
21:48:01 <gFunk>    foldM' f yNow xs
21:48:09 <gFunk> tried this, but doesn't seem to do anything
21:48:23 <dons> hmm. well, compile with -prof -auto-all,, then run with +RTS -p
21:48:28 <dons> inspect foo.prof
21:48:37 <gFunk> alright
21:49:33 <dons> you can annotate individual expressions to be profiled, if need be: {-# SCC "here" #-} yNow <- ... ; 
21:50:16 <dons> deepSeq is rarely needed. but i guess  a few  M lines is a fair bit. possible even enough that you'd need to use packed strings.
21:51:27 <gFunk> is there some way to fold and free the list as you fold?
21:51:52 <gFunk> as in, when you're on line 10, to have let go all references to the first 9 list items
21:52:56 <dons> so you've looked at the normal foldM?
21:52:58 <dons> foldM             :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:52:58 <dons> foldM _ a []      =  return a
21:52:59 <dons> foldM f a (x:xs)  =  f a x >>= \fax -> foldM f fax xs
21:53:04 <gFunk> yes
21:53:51 <gFunk> :r
21:53:53 <gFunk> oops
21:54:31 <dons> I'd stricitfy that as: f a x >>= \fax -> fax `seq` foldM f fax xs
21:54:52 <dons> ah, like: 
21:54:53 <dons> foldl'           :: (a -> b -> a) -> a -> [b] -> a
21:54:53 <dons> foldl' f a []     = a
21:54:54 <dons> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:55:23 <dons> yours seems to do far too much work.
21:56:13 <gFunk> i'm all right with doing too much work at the moment.  even so, i'm not seeing any strictness
21:56:33 <dons> well, profile, and find out where the problem is
21:56:47 <dons> otherwise you're just guessing 
21:56:59 <gFunk> i'll give it a shot.  thanks for the help
21:57:19 <dons> usually only very little strictness is need to make things very fast. also, you're compiling with -O2?
21:57:45 <user317> what does the >>= operator do?
21:58:18 <int-e> @index $!!
21:58:19 <lambdabot> bzzt
21:58:37 <dons> it's monad bind. iit's what the do notation actually translates to. so: a >>= \x -> b  ==  do x <- a; b
21:58:53 <user317> oh i see
21:59:06 <dons> @type (>>=)
21:59:08 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
22:02:00 <user317> hmm, thats confusing, do x <-a; b  where does b come from?
22:02:53 <dons> gFunk, just inspecting how foldM' is compiled -- you get a  lot _less_ code generated with the version I posted (using seq)
22:04:04 <dons> and ghc even marks the following as strict in the accumulator:
22:04:04 <dons> foldM' _ a xs     | a `seq` False = undefined
22:04:04 <dons> foldM' _ a []     = return a
22:04:05 <dons> foldM' f a (x:xs) = f a x >>= \a' -> foldM' f a' xs
22:04:45 <dons> user317, oh, b is just some monadic expression
22:05:39 <dons> i.e. getArgs >>= \a -> print a  is the same as   do a <- getArgs ; print a
22:08:37 <dons> user317, do much haskell coding?
22:08:43 <user317> dons: just started
22:08:59 <dons> great! welcome :)
22:09:01 <user317> i am pretty familiar with ml and lisp
22:09:06 <dons> even better
22:09:06 <gFunk> dons: that foldM' of yours looks to be working great
22:09:29 <gFunk> dons: the memory is climbing, but way way less than before
22:09:38 <dons> gFunk, did your try the one with 'undefined' in it above? i think that might be even better.
22:09:48 <gFunk> yes
22:09:57 <dons> ghc actually annotates it as a strict function.
22:10:00 <gFunk> now i get a stack overflow instead :)
22:10:08 <dons> good. now you can profile to work out what else is happening.
22:10:57 <gFunk> that foldM' would be optimized for tail recursion, right?
22:10:59 <dons> what's on the top of the profile table?
22:11:11 <dons> yep, all function calls are
22:11:19 <dons> it's just a goto
22:12:25 <dons> user317, what made you decide to pick up haskell?
22:12:31 <user317> dons: so  "\a -> print a"  is a function?
22:12:40 <user317> dons: well, i've been sort of toying with it for a while
22:12:51 <dons> yep
22:12:51 <dons> @type \a -> 
22:12:52 <user317> dons: just felt like really learning it
22:12:53 <lambdabot> parse error (possibly incorrect indentation)
22:12:59 <dons> @type \a -> print a
22:13:01 <lambdabot> forall a. (Show a) => a -> IO ()
22:13:09 <dons> @type print
22:13:11 <lambdabot> forall a. (Show a) => a -> IO ()
22:13:46 <user317> dons: and the fact that its a pure functional language is pretty neat
22:14:20 <gFunk> dons: "then run with +RTS -p" what do you mean?
22:15:46 <dons> gFunk, compile your program as: ghc F.hs -O2 -prof -auto-all; then run it as: ./a.out +RTS -p
22:16:03 <dons> when it terminates, a file, a.out.prof is created
22:16:06 <dons> with all the stats
22:16:26 <dons> user317, and fast! have you seen the Great Language Shootout results?
22:17:03 <user317> dons: yea i've seen them, although all the compiled languages should run at the same speed
22:17:12 <dons> they should?/
22:17:33 <user317> dons: yea, why not?  you can hand optimize any compiled language
22:17:37 <dons> why? they might have completely different runtime systems
22:18:09 <dons> i.e. a C stack versus a tail call. or GC versus no GC.
22:18:30 <dons> hence there's a wide variation in the performance of all compiled langs
22:18:50 <gFunk> hey, this is handy
22:18:54 <gFunk> generateList                   Main                 100.0   98.2
22:19:02 <dons> ah!
22:19:11 <dons> that's your problem :)
22:19:20 <dons> so what's this function?
22:19:28 <gFunk> hehe, everything
22:19:49 <gFunk> http://pastebin.com/547968
22:19:55 <dons> looks like it might space leak though -- if you get a stack overflow. they're very rare.
22:21:53 <dons> that unsafeInterleaveIO is a bit suspicious, I must say..
22:22:34 <user317> dons: but you can hand optimize anything and make it part of the standard library, lisp bignum multiplication is just as fast as C's 
22:22:56 <dons> gFunk, now to narrow it down, you can rewrite that expression as a do-block, and annotate each line with SCC flags
22:23:30 <dons> user3167, you _theoretically_ can, but in practice, there's a wide difference in performance :)
22:23:43 <gFunk> dons: SCC flags?
22:23:49 <user317> dons: i think the main advantage of functional program is that its correct the first time you write it
22:24:12 <gFunk>    parse                 Main                                                 197           3  13.0   30.0    76.1   91.5
22:24:12 <gFunk>     toQuote              Main                                                 203       10000  63.0   61.5    63.0   61.5
22:24:22 <gFunk> and incorrect the first 1000 times you try to compile it!
22:25:10 <dons> something like:
22:25:16 <dons> generateList dir currency = do
22:25:16 <dons>       ds <- {-# SCC "1" #-} getDirectoryContents dir
22:25:16 <dons>       v  <- {-# SCC "2" #-} (mapM (\p -> unsafeInterleaveIO $ putStrLn p >> readFile p) . paths) ds
22:25:19 <dons>       let v' = {-# SCC "3" #-} concatMap parse
22:25:22 <dons>       return v'  
22:26:24 <dons> @remember gFunk [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
22:28:01 <dons> gFunk, if 'read' turns out to be too slow, you might want to write a little parsec parser to grab the lines
22:29:44 <user317> hehe, whats this @remember thing
22:29:55 <int-e> @quote gFunk
22:29:55 <dons> @quote 
22:29:55 <lambdabot>  [the main advantage of functional programs are that they're] incorrect
22:29:55 <lambdabot> the first 1000 times you try to compile it!
22:29:56 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
22:30:00 <gFunk> ha
22:30:03 <gFunk> i like it
22:30:04 <user317> hehe
22:30:11 <Lemmih> gFunk: Or use Numeric.readDec.
22:30:38 <gFunk> k
22:30:47 <dons> I always envy Clean's fread. I suspect it's implemented in some evil way though.
22:31:23 <Lemmih> What's the type of 'fread'?
22:32:05 <dons> don't know. I can't mentally infer types for Clean's pseudo-IO ;)
22:32:31 <dons> it looks like a 'read' on a Handle though.
22:32:49 <dons> and I wonder if its really a wrapper over fread(3)
22:32:57 <dons> (which would be kind of useful for us too..)
22:34:08 <Lemmih> It would?
22:34:25 <dons> I think it's how Clean wins the sum-file shootout ;)
22:35:05 <dons> darcs uses it to read packed strings, iirc
22:35:06 <Lemmih> Ah, that kind of useful.
22:35:13 <gFunk> how do you use readDec?
22:35:17 <dons> hehe
22:35:19 <gFunk> @hoogle readDec
22:35:19 <Lemmih> > (readDec :: ReadS Int) "0x10"
22:35:20 <lambdabot> Numeric.readDec :: Num a => ReadS a
22:35:20 <lambdabot> Text.Read.Lex.readDecP :: Num a => ReadP a
22:35:21 <lambdabot> [(0,"x10")]
22:35:21 <Lemmih> > (readDec :: ReadS Int) "10"
22:35:22 <lambdabot> [(10,"")]
22:35:38 <Lemmih> > read "0x10" :: Int
22:35:39 <lambdabot> 16
22:35:54 <Lemmih> > read "0o10" :: Int
22:35:55 <lambdabot> 8
22:37:20 <gFunk> i see
22:37:22 <gFunk> thanks
22:43:24 <gFunk> wow, that really speeds things up
22:43:52 <gFunk> 3 times faster
22:44:14 <dons> is it reasonable yet, or does it need more work?
22:46:26 <dons> hehe, hmp3 is up to 1300 hours uptime. 
22:46:30 <gFunk> stack still blows up
22:47:09 <dons> what does the profile list on top now?
22:47:16 <gFunk> does 'map' use foldr or foldl?
22:47:47 <user317> i think it has to use foldr
22:48:21 <dons> map _ []     = []
22:48:22 <dons> map f (x:xs) = f x : map f xs
22:48:50 <dons> however, there are also some fun rewrite rules:
22:48:51 <dons> "map"       [~1] forall f xs.   map f xs        = build (\c n -> foldr (mapFB c f) n xs)
22:48:54 <dons> "mapList"   [1]  forall f.  foldr (mapFB (:) f) []  = map f
22:50:04 <Cale> foldr is better than foldl in most cases
22:50:05 <gFunk> hmm, maybe that's the problem
22:50:31 <dons> gFunk, how big are these data files? how many k?
22:51:12 <dons> ah, but as long as you can keep the IO lazy, should be ok (I think, trying to recall the exact problem to solve)
22:51:34 <gFunk> ~200 KB per file
22:51:41 <dons> oh, that's nothing then
22:51:44 <gFunk> 1.2 GB for all the files
22:51:46 <palomer> can't sleep
22:51:47 <palomer> ugh.
22:51:52 * palomer resists the urge to code
22:51:56 <palomer> coding urges never end well
22:52:21 <palomer> are there any performance issues with darcs?
22:52:34 <gFunk> parse                          Main                  54.4   74.8
22:53:00 <gFunk> parse = map (toQuote . words) . lines
22:53:09 <dons> cool. maybe write a pattern-matching based parse?
22:53:56 <gFunk> regex?
22:54:33 <dons> nope. maybe write your own toQuote. words?
22:54:49 <dons> (or profile first with SCC, to work out where the expensive bit is.
22:55:24 <dons> pattern matching, like: f (' ':xs) = f xs ; f (x:xs) |  isAlpha x = ... and so on.
22:56:09 <dons> I was thinking of this fast program: http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=4
22:56:10 <lightstep> i have a function, encodings tree = runSTArray (collect tree). is there a way to write it in point-free style?
22:56:38 <dons> @pl \tree -> runSTArray (collect tree)
22:56:39 <lambdabot> runSTArray . collect
22:56:54 <dons> not sure if runST likes that though. it plays tricks sometimes.
22:56:59 <lightstep> it doesn't
22:57:32 <dons> so: encodings = runSTArray . collect -- fails?
22:57:37 <lightstep> yes
22:57:43 <dons> shrug. there you go.
22:57:51 <gFunk> dons: i see, but i don't see how that will fix the stack
22:57:59 <lightstep> since `s' cannot be passed from one side to the other
22:58:36 <dons> gFunk, I can't see where the stack issue is yet. usually its fold-related though. sometimes just rewriting things in a different way makes the issue go away.
22:58:52 <gFunk> ok, thanks
22:59:44 <dons> my suspicion is that the bits where you split up the line and read it will be a problem, until you split up the llinne yourself (like in the  link i posted)
23:08:29 <user317> are constants like E and Pi built into haskell somewhere?
23:08:52 <Lemmih> > pi
23:08:54 <lambdabot> 3.141592653589793
23:09:01 <user317> e?
23:09:05 <Lemmih> > e
23:09:06 <lambdabot>  Not in scope: `e'
23:09:30 <joelk> > exp 1
23:09:32 <lambdabot> 2.718281828459045
23:13:01 <user317> thanks
23:13:52 <dons> i like this language more and more
23:47:06 <gour> dons: #1 on shootout. congrats :-)
23:53:31 <twb> What are those functions that are the inverse of `lines' and `words'?
23:54:34 <twb> Oh, unlines/unwords.
