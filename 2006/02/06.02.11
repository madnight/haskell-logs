00:02:15 * wli hunts for the Image and Video bits of the library hierarchy Simon Marlow's referred to.
00:23:38 <ncalexan> > listArray ((1,5) (2, 3)) "test"
00:23:39 <lambdabot>  Not in scope: `listArray'
00:23:49 <ncalexan> > Data.Array.listArray ((1,5) (2, 3)) "test"
00:23:50 <lambdabot>  Not in scope: `Data.Array.listArray'
00:23:56 <ncalexan> @hoogle listArray
00:23:57 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i
00:23:57 <lambdabot> e
00:23:57 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
00:23:57 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] ->
00:23:57 <lambdabot> m (a i e)
00:24:23 <ncalexan> Data.Array.IArray.listArray ((1,5) (2, 3)) "test"
00:24:34 <ncalexan> > Data.Array.IArray.listArray ((1,5) (2, 3)) "test"
00:24:35 <lambdabot>  Not in scope: `Data.Array.IArray.listArray'
00:24:48 <ncalexan> > import Data.Array; listArray (1,5) "test"
00:24:49 <lambdabot>  parse error on input `import'
00:29:11 <TuringTest> @type listArray
00:29:12 <lambdabot> Not in scope: `listArray'
00:29:23 <TuringTest> @type  Data.Array.IArray.listArray
00:29:26 <lambdabot> forall e i (a :: * -> * -> *).
00:29:26 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.IArray a e) =>
00:29:26 <lambdabot> (i, i) -> [e] -> a i e
00:29:45 <TuringTest> @type  Data.Array.IArray.listArray  ((1,5), (2, 3)) 
00:29:47 <lambdabot> forall a b (a1 :: * -> * -> *) e.
00:29:47 <lambdabot> (GHC.Arr.Ix (a, b), Data.Array.Base.IArray a1 e, Num a, Num b) =>
00:29:47 <lambdabot> [e] -> a1 (a, b) e
00:29:51 <TuringTest> Note the extra comma
00:30:06 <TuringTest> @type  Data.Array.IArray.listArray  ((1,5), (2, 3))  "test"
00:30:07 <lambdabot> forall a b (a1 :: * -> * -> *).
00:30:07 <lambdabot> (GHC.Arr.Ix (a, b),
00:30:07 <lambdabot> Data.Array.Base.IArray a1 Char,
00:30:07 <lambdabot> Num a,
00:30:07 <lambdabot> Num b) =>
00:30:09 <lambdabot> a1 (a, b) Char
00:30:30 <TuringTest> @type  Data.Array.DiffArray.listArray  ((1,5), (2, 3)) 
00:30:31 <lambdabot> Couldn't find qualified module.
00:30:31 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
00:30:31 <lambdabot> \\)?
00:30:45 <ncalexan> Cheers.
00:30:52 <ncalexan> I figured out where I was wrong :)
01:00:28 <gour> dons, Lemmih: yesterday ghc-head, fps (still) does not build: Data/FastPackedString.hs:1142:0: Parse error in pattern
01:02:37 <Lemmih> gour: Ah. That's because of the new bang patterns.
01:06:35 <Lemmih> I'm amazed that SPJ didn't realize that highjacking (!) would cause trouble.
01:10:51 <Saulzar> Hmm, what's the double ! in data constructors, some kind of GHC thing? :info Data.Map.Map shows  "| Bin !!Data.Map.Size"
01:13:07 <Lemmih> Saulzar: It means that Size is unboxed.
01:13:55 <Saulzar> Ah, so it's a property of compiled code?
01:18:28 <gour> Lemmih: so, i'm cursed not to build hiDE:-(
01:19:01 <Lemmih> gour: I'll undo the patch in ghc.hide
01:19:28 <gour> Lemmih: i was pulling from ghc (HEAD)
01:20:11 <gour> anyway, let's go to take (late) breakfast
01:24:05 * wli could've sworn he saw some minimalistic codec affairs sitting around as Haskell libraries for the taking.
01:25:12 <wli> Looking for PNG, JPEG, MPEG, and the like.
01:37:56 * vincenz has some issues on pattern matching
01:38:06 <vincenz>   transform (SB s@(SDDTAppend _ _)) = do
01:38:12 <vincenz> and generiically
01:38:14 <vincenz>   transform s = do
01:38:21 <vincenz> however for some reason it never evokes the prior
01:39:02 <lispy> never?
01:39:12 <lispy> even if you try using it from ghci?
01:39:29 <lispy> manually creating the SDDTAppend object for example
01:39:34 <vincenz> hmm
01:39:39 <vincenz> I could try
01:40:23 <lispy> i'm thinking of two possible reasons, 1) a case before it is being triggered instead 2) your SB object doesn't have the structure you think it does
01:40:35 <vincenz> lispy: Ii'm pretty certain of 2
01:40:56 <lispy> certain it has the right structure?
01:40:59 <vincenz> yes
01:41:20 <lispy> certain or you have proven it :)
01:41:33 <vincenz> lispy: there is no other case
01:41:59 <lispy> try this: transform s = error (show s)
01:42:26 <vincenz> o.O
01:43:10 <lispy> that will let you see exactly the structure of s, assuming you derive show
01:44:11 <vincenz> lispy: I know for a fact it's correct
01:44:50 <Saulzar> wli, SDL bindings or gtk2hs have media loading routines
01:44:57 <lispy> if it's not (1) or (2) then i don't know what would cause the problem
01:46:31 <Lemmih> vincenz: Did you try it in GHCi?
01:46:57 <vincenz> Lemmih: too much hassle
01:46:58 <vincenz> it's a monad
01:48:14 <vincenz> and indeed, it iis what I thought it was
01:48:57 <Lemmih> It's a (SB (SDDTAppend _ _))?
01:49:12 <vincenz> that's odd
01:49:16 <vincenz> the case does get invoked
01:49:22 <vincenz> it just doesn't do all the do stuff
01:52:38 <vincenz>   transform (SB s@(SDDTAppend _ _)) = do
01:52:38 <vincenz>     s'@(SDDTAppend n a) <- traverseBStm s
01:52:38 <vincenz>     assertType TDDT (getType n) False 
01:52:38 <vincenz>     assertType TData (getType a) True
01:52:38 <vincenz>     return $ TB s'
01:52:40 <vincenz> it enters
01:52:43 <vincenz> it exits
01:52:45 <vincenz> but it doesn't do the assert-types
01:53:25 <vincenz> (i checked by trracing the arguments)
01:55:22 <vincenz> why o why
01:55:48 <Cale> um, by tracing the arguments?
01:56:05 <Cale> what if assertType somehow manages not to force its arguments?
01:56:09 <vincenz> Cale: it does
01:56:12 <vincenz> it checks equality
01:56:48 <vincenz>   transform (SB s@(SDDTAppend _ _)) = trace "Entering" $ do
01:56:48 <vincenz>     s'@(SDDTAppend n a) <- traverseBStm s
01:56:48 <vincenz>     trace "Asserting" $ assertType TDDT (getType n) False 
01:56:48 <vincenz>     trace "Asserting" $ assertType TData (getType a) True
01:56:48 <vincenz>     return $ TB (trace "Returning" s')
01:56:52 <vincenz> entering and returning are printed
01:56:54 <vincenz> not asserting
01:57:30 <Cale> huh, which monad is this?
01:57:33 <vincenz> state
01:57:40 <Cale> hmm
01:57:58 <vincenz> and I know that other assertions (like for expressions) do fire
01:57:59 <Cale> will the assertions always succeed?
01:58:08 <vincenz> no
01:58:20 <vincenz> assertType lhs rhs canConst = do
01:58:20 <vincenz>   if lhs' == rhs'
01:58:20 <vincenz>     then
01:58:20 <vincenz>       if canConst || (isConst lhs) || not (isConst lhs || isConst rhs)
01:58:20 <vincenz>         then return ()
01:58:23 <vincenz>         else fail $ "Mismatched types: " ++ show rhs ++ " -> " ++ show lhs
01:58:24 <Cale> what happens if you force them to fail?
01:58:26 <vincenz>     else fail $ "Mismatched types: " ++ show rhs ++ " -> " ++ show lhs
01:58:28 <vincenz>   where rhs' = deConst rhs
01:58:31 <vincenz>         lhs' = deConst lhs
01:58:47 <dcoutts> Saulzar, what sort of media loading do you mean?
01:58:58 <Cale> construct an input to transform on which the assertions fail, and see what it does
01:59:03 <vincenz> LOL
01:59:12 <vincenz>   transform (SB s@(SDDTAppend _ _)) = trace "Entering" $ do
01:59:12 <vincenz>     s'@(SDDTAppend n a) <- traverseBStm s
01:59:12 <vincenz>     trace "Asserting" $ fail "LALA"
01:59:18 <vincenz>     return $ TB (trace "Returning" s')
01:59:20 <vincenz> doesn't fai
01:59:31 <Saulzar> dcoutts,  wli: Looking for PNG, JPEG, MPEG, and the like.
01:59:57 <vincenz> why does that not fail?
02:00:04 <Cale> you're sure you're recompiling?
02:00:07 <vincenz> yah
02:00:24 <vincenz> I did a make clean make 
02:00:26 <vincenz> still the same
02:00:28 <Cale> hm
02:00:41 <vincenz> yet I know that for expressions it does fine
02:00:47 <vincenz> could it have to do with sequence_
02:00:54 <Cale> fail is an expression
02:01:03 <Cale> as is assertType
02:01:06 <dcoutts> xerox, cool
02:01:06 <vincenz> cause I sequence
02:01:25 <vincenz> Cale: I sequence that transform thingy
02:01:35 <Cale> yeah, that shouldn't matter
02:02:06 <Cale> you're loading this in GHCi?
02:02:12 <vincenz> Cale: no
02:02:18 <dcoutts> Saulzar, gtk can load png & jpeg. For video you'll need something like GStreamer.
02:02:24 <Cale> okay, compiling and running it then
02:02:28 <vincenz> yip
02:02:35 <Cale> I don't know what would cause it to ignore that code...
02:04:47 <vincenz> it seems to be so for all basicstms
02:05:54 <UncleD> Cale's goin haskell crazy!
02:06:05 <UncleD> Cale, seen any nice programs done with the gtk?
02:06:20 <Cale> UncleD: did you see the nice clock?
02:06:51 <Cale> xerox and I wrote an LSystem renderer
02:07:09 <vincenz> actually not for all sts
02:07:12 <vincenz> asicstm's
02:08:03 <vincenz> bug?
02:08:46 <Cale> I'm really not sure without being able to try it myself... perhaps you can play around with it in GHCi?
02:09:25 <vincenz> Cale: it's rather ugly to play with manually
02:11:14 <vincenz> hmm, that's odd
02:12:18 <vincenz> woah
02:12:19 <vincenz> very odd
02:12:26 <vincenz> o.O
02:12:55 <vincenz> it's apparently input dependent
02:12:59 <vincenz> of how much input comes after it
02:13:23 <vincenz> like if the failure can't catch up to the output
02:13:40 <vincenz> even wehn it fails, it still outputs the ast for the part that failed
02:13:51 <vincenz> must be lazy-eval?
02:14:11 <vincenz> here is a sample input
02:14:15 <vincenz> http://rafb.net/paste/results/osCTNJ93.html
02:14:20 <vincenz> notice how the two loops are identical
02:14:26 <vincenz> except for the second ... a is const
02:14:31 <vincenz> if I make the first a const, it fails
02:14:39 <vincenz> if I remove the second loop with the first a const, it doesn't fail
02:14:43 <vincenz> it prints out the code just fine
02:15:10 <vincenz> when it fails, it still prints out the failing line and the closing }
02:15:13 <vincenz> so it's a lazy issue
02:15:21 <vincenz> how do I -force- it to do
02:15:22 <vincenz> everything
02:15:42 <vincenz> (and how come outputting dooesn't force through the failures until much later?)
02:15:56 <vincenz> @type seq
02:15:58 <lambdabot> forall b a. a -> b -> b
02:16:05 <vincenz> @type deepseq
02:16:06 <Cale> well, "fail" is sort of misguided anyway
02:16:07 <lambdabot> Not in scope: `deepseq'
02:16:11 <vincenz> Cale: well it fails
02:16:15 <vincenz> Cale: but only a bit after where it should fail
02:16:19 <vincenz> like if I make the first a const
02:16:22 <Cale> I don't recommend strictifying things to make it fail earlier
02:16:22 <vincenz> it should fail on the insert
02:16:35 <vincenz> yet it prints out that insert line and the next line just fine before failing
02:16:39 <Cale> It's better to encode errors in your type
02:16:42 <Cale> and return them
02:16:49 <vincenz> won't do
02:16:56 <vincenz> but do you know why it fails only after printing it?
02:16:57 <Cale> why?
02:17:03 <vincenz> shouldn't printing have made it go through that failure?
02:17:18 <Cale> because it hasn't evaluated those fails until it comes to that part
02:17:25 <vincenz> yes it has
02:17:31 <vincenz> it can only prettyprint once it has the returned value
02:17:35 <vincenz> which comes after hte lines causing failure
02:17:56 <vincenz>   transform (SB s@(SDDTInsert _ _ _)) = do
02:17:56 <vincenz>     s'@(SDDTInsert n a b) <- traverseBStm s
02:17:56 <vincenz>     assertType TDDT (getType n) False 
02:17:56 <vincenz>     assertType TInt (getType a) True
02:17:58 <vincenz>     assertType TData (getType b) True
02:18:00 <Cale> well, look at bind in the state monad
02:18:01 <vincenz>     return $ TB s'
02:18:03 <vincenz> see...it prints the return value
02:18:06 <vincenz> and only fails later
02:18:15 <vincenz> @fptools Monad
02:18:17 <lambdabot> Monad not available
02:18:19 <vincenz> @fptools State
02:18:20 <lambdabot> State not available
02:18:22 <vincenz> @fptools runState
02:18:23 <lambdabot> runState not available
02:18:26 <vincenz> blegh
02:18:41 <Cale> Prelude Control.Monad.State> evalState (undefined >>= \x -> return 5) 0
02:18:41 <Cale> 5
02:19:06 <Cale> If it knows what it's going to return without evaluating the rest, it's fine.
02:19:38 <Cale> In State:
02:19:40 <vincenz> so how do I force the final structure?
02:20:19 <Cale> well, you can recursively seq it, but I think you'd be better off Error transforming your monad
02:20:26 <vincenz> ??
02:20:30 <vincenz> it's a state monad
02:20:39 <Cale> You're using State Foo a
02:20:42 <vincenz> right
02:20:56 <Cale> Use something along the lines of ErrorT String (State Foo) a
02:21:04 <vincenz> blegh
02:21:19 * vincenz thinks this is a bug
02:21:28 <UncleD> Cale, do you like cryptography?
02:21:32 <Cale> vincenz: it's not at all
02:21:33 <UncleD> and cryptoanalysis
02:21:54 <Cale> UncleD: I haven't really studied it all that much
02:21:55 <vincenz> Cale: how do you reckon?
02:22:12 <UncleD> Cale: Ah. I thought with your interest in programming and math, you'd have looked into that field a bit.
02:22:15 <Cale> vincenz: Those fails only throw an exception when they're evaluated
02:22:27 <vincenz> Cale: right but I'd think do syntax is "sequential"
02:22:34 <UncleD> Cale: I'd love to have your math background :)
02:22:46 <lispy> UncleD: i think crypto is pretty cool, but i've only study a tiny bit.  For example, I coded up the rsa algorithm for fun.
02:22:51 <Cale> vincenz: Do notation is only sugar for a bunch of applications of combinators.
02:23:21 <Cale> vincenz: it doesn't force anything to be evaluated in any particular order
02:23:25 <vincenz> so how do I run it now
02:23:32 <vincenz>   fst $ runState (transform x) ((TVoid, M.empty) :: Env)
02:23:36 <vincenz> that's prior to ErrorT
02:23:45 <Cale> fst . runState = evalState
02:24:04 <vincenz> right and now in Error?
02:24:48 <Cale> evalState (runErrorT (transform x)) ((TVoid, M.empty) :: Env))
02:25:03 <vincenz> and instead of fail "throwError"
02:25:08 <Cale> right
02:25:12 <Cale> note that the return type will now be Either String a
02:25:25 <Cale> (for whatever return type 'a' you had before)
02:25:53 <Cale> well, technically, it's polymorphic over error types, but you probably just want string errors
02:26:11 <Cale> you shouldn't have to lift the gets and puts
02:26:26 <Cale> since there's an instance  (Error e, MonadState s m) => MonadState s (ErrorT e m)
02:27:13 <vincenz> ah, better
02:27:25 <vincenz> thx
02:27:40 <Cale> 'fail' is really a wart, and you should probably avoid it
02:27:48 <Cale> I'd like it removed from the language
02:29:44 <vincenz> okies, much better
02:30:16 <vincenz> any solution to
02:30:23 <vincenz> http://rafb.net/paste/results/0hEDkC42.html
02:30:33 <MarcWeber> Is HSQL=HToolkit?
02:31:13 <Cale> vincenz: that's the Either String monad.
02:31:18 <vincenz> oh
02:32:19 <lispy> MarcWeber: it's been a while since i looked at either one of those...I thought they were different but maybe I just misremember.
02:32:29 <chucky> @seen bringert
02:32:30 <lambdabot> I saw bringert leaving #haskell 16 days, 11 hours, 51 minutes and 50
02:32:30 <lambdabot> seconds ago, and I have missed 21 seconds since then.
02:33:13 <vincenz> thx
02:33:28 <MarcWeber> lispy Would you mind going to http://www.haskell.org/communities/11-2004/html/report.html and searching for HSQL and clicking on the link "further reading"?
02:33:30 <Cale> no problem
02:34:21 <lispy> MarcWeber: what link?
02:34:28 <vincenz> much better
02:34:43 <lispy> oh
02:34:45 <vincenz> I should prolly use this for my lexer and parser too, right now I use a custom monad which in effect is an ErrorT (State x)
02:34:52 <Cale> :)
02:35:34 <lispy> MarcWeber: oh, looking at the documentation link i see documentation for HSQL so they do appear to be related
02:35:48 <Cale> Monad transformers are a really efficient way to create a large portion of the monads you'd probably want to actually use
02:36:30 <MarcWeber> lispy Can you paste the documentation link to hsql? I didn't find hsql.. just htoolkit.. which is described as gui library
02:37:46 <Cale> A really cool technique is to transform some base monad, and then restrict the way in which you can use the new functionality by newtyping the result, not exporting the constructor, and deriving Monad, Functor, etc. but not the transformer's class. Then create the operations you want within that module.
02:38:04 <Cale> (using the constructor you don't export)
02:38:41 <lispy> MarcWeber: http://htoolkit.sourceforge.net/
02:38:48 <lispy> er...
02:38:55 <lispy> god, i hate frame
02:38:55 <MarcWeber> ;-)
02:39:07 <lispy> http://htoolkit.sourceforge.net/doc/hsql
02:39:10 <vincenz> Cale: not sure I follow
02:39:22 <lispy> my internet is really spotty night
02:39:51 <lispy> i keep hitting bit spots of latency where i won't see any traffic for a couple minutes then it will all catch up again
02:40:01 <Cale> vincenz: I have some examples on the wiki
02:40:04 <MarcWeber> lispy I'm sorry. I haven't been on the documentation page.. I 've visited the features link only.. (/me is apologizing for making much trouble)
02:40:38 <Cale> http://www.haskell.org/hawiki/MonadRandom
02:40:39 <lispy> MarcWeber: well, when you read the documentation you'll see you're not missing much
02:41:48 <Cale> That uses a state monad to keep track of a random generator, and makes sure that each generator only gets used once
02:42:04 <MarcWeber> I was missing the word SQL on the features page
02:42:47 <Cale> http://www.haskell.org/hawiki/MonadUndo -- this is for managing undo/redo histories sanely
02:43:02 <araujo> Good morning.
02:43:07 <vincenz> type InputMonad a = ErrorT (State InputState) a
02:43:14 <lispy> araujo: lies! ;)
02:43:16 <vincenz> nm
02:45:05 <araujo> lispy, :-(
02:45:34 <lispy> araujo: it would probably be a fine morning if i'd just go to bed
02:45:46 * lispy notices it is almost 3am
02:46:32 <vincenz> woot
02:46:46 <vincenz> moved lexer and parser
02:48:25 * lispy has been working out some details on a game ruleset that he's had brewing for quite a while now
02:48:43 <lispy> this means i can write it down and never think about it again right?
02:49:48 <vincenz> lispy: ruleset of what?
02:50:37 <lispy> vincenz: for an RPG style game world
02:51:18 <vincenz> lispy: ooh interesting
02:52:16 <lispy> vincenz: it's taken me a couple years just to write down some of the vague basics, so don't expect to hear how it turns out any time soon :)
02:53:13 <vincenz> lispy: If you ever wanna talk
02:53:20 <vincenz> anyways
02:53:23 * vincenz loves indirectcomposite
02:53:27 <vincenz> I think i can do something really neat
02:53:33 <vincenz> right now I ihave BasicStm and ControlStm
02:53:41 <vincenz> where in the latter it's things like loops, ifthenelse..
02:53:48 <lispy> but, one idea i've had is to come up with a formal definition of magic so that you can define the basics the rest is just inferred from that.  Sort of like how a type system works.
02:54:02 <vincenz> by using indirect composite, I can make a new AST where the controlFlowStm is something completely different (for instance a graph)
02:54:22 <lispy> vincenz: cool, are you writing a compiler?
02:54:28 <vincenz> lispy: more like an analyser
02:54:38 <vincenz> no backend
02:54:52 <lispy> ah
02:54:55 * vincenz considers adding parametric types
02:56:09 <vincenz> ddt f(ddt a) { return a;
02:56:09 <vincenz> }
02:56:11 <vincenz> what do you think
02:56:17 <vincenz> template <a> ddt<a>
02:56:27 <vincenz> or ... forall a: ddt<a> ...
02:57:40 <vincenz> or just plainly
02:57:47 <vincenz> a => ddt<a> f(ddt<a> x) { return x;}
02:59:30 <Cale> unless you're planning on scoped type variables, the implicit (last) form looks nice.
02:59:42 <Cale> er hmm
03:00:02 <Cale> that's not quite implicit
03:00:08 <Cale> a => means forall a. ?
03:00:16 <vincenz> yeah
03:00:22 <vincenz> it's only at the func-def level
03:00:24 <Cale> eh, write the forall :)
03:00:42 <vincenz> Cale: it's more verbose and just doesn't look nice :/
03:00:58 <Cale> well, whatever you like :)
03:01:00 <vincenz> basically I'm doing a simplistic template syste
03:01:09 <vincenz> where only ddt's can be templatized on keys and values
03:01:18 <vincenz> (well for now values, I assume keys are integers)
03:01:52 <vincenz> :)
03:02:19 <A-Tui> is it possible to convert any expresion from do notation to (>>=) and (>>) notation?
03:02:48 <lispy> A-Tui: yes
03:02:57 <vincenz> A-Tui: very carefully
03:03:18 <A-Tui> i cant do it :(
03:03:20 <vincenz> Cale: right now my biggest issue is that I have little context available for errors :/
03:03:26 <vincenz> do
03:03:27 <vincenz>   some action
03:03:30 <lispy> A-Tui: the compiler does this automaticly to compile the code.  The transformation uses the properties of monads, also knows as the monad laws.
03:03:31 <vincenz>    x <- some action
03:03:36 <vincenz> do
03:03:37 <vincenz>   on
03:03:39 <vincenz>   x <- two
03:03:40 <vincenz>    three
03:03:42 <vincenz> ==
03:03:48 <vincenz> one >> two >>= \x -> three
03:03:56 <Cale> yes
03:04:29 <A-Tui> mmm i hace some x <- getLine (about 5) and at the end a use all in a simple expresion
03:05:01 <Cale> A-Tui: sure
03:05:06 <A-Tui> a <- getLine; b <- getLine ; [...]; doSome a b c ...
03:05:38 <Cale> getLine >>= \a -> getLine >>= \b -> ... >> doSome a b c
03:05:44 <A-Tui> ops
03:05:47 <A-Tui> :)
03:06:29 <A-Tui> ok i see
03:06:33 <A-Tui> thnx
03:07:38 <A-Tui> another question is posible to buil a function with type (Monad m) => ma -> a?
03:07:38 <Cale> vincenz: In case you haven't seen it before, I put a monadic sudoku solver on the wiki just now, which illustrates using a newtyped monad in a module to restrict the actions available in the monad
03:07:49 <Cale> http://www.haskell.org/hawiki/SudokuSolver
03:08:08 <vincenz> cool
03:08:21 * vincenz considers putting his code for his lexer/parser/scoper/typer up for review
03:08:38 <vincenz> to get some suggestions on how to clean it
03:10:23 <gour> Lemmih: with the undo, ghc.hide fails with: Data/Array/Base.hs:
03:10:23 <gour>     unknown flags in  {-# OPTIONS #-} pragma: -fno-bang-patterns
03:11:09 <gour> Lemmih: probably due to missing 'bang-patterns'. huh...maybe i should wait a bit that ghc & hIDE stabilizes before attempting to build it...
03:11:59 <gour> Lemmih: i'll stay with ghc-head as main compiler and wait until hIDE catches on
03:17:18 <vincenz> Cale: put it up for review?
03:18:18 <Cale> sure :)
03:18:42 <vincenz> ls
03:19:17 <Cale> I'm going to sleep though, remind me to have a look at it
03:19:22 <vincenz> okies
03:21:38 <int-e> wow. Cale sleeps?
03:23:03 <lispy> int-e: it's just an elaborate lie, but we know the truth
03:32:48 <waern> gour, what compiler are you building ghc.hide with?
03:33:02 <waern> I built ghc.hide with ghc 6.4.1 and I had no problems
04:07:48 <huga> heya, i have a noobie question if anyone have time to answer; ill just paste it;  [ (x, y) | x <- [-1..1], y <- [-1..1], (x /= 0 && y /= 0) ] <-- what I want is to have all the numbers in that range except [0,0], instead of removing every zero as it currently does.. but I can't seem to figure out how i would do that
04:08:15 <vincenz> &&?
04:08:31 <vincenz> oh..
04:08:36 <lispy> (x,y) /= (0,0)
04:09:17 <lispy> [x,y] /= [0,0] would work also
04:09:38 <flux__> or just && -> ||
04:09:44 <edwinb> x <- [-1,1] ...?
04:10:00 <lispy> flux__: sssh...we'll have none of DeMorgan's laws here! ;)
04:10:18 <flux__> huga, for example (1, 0) does not satisfy condition 1 must be different from 0 and 0 must be different from 0
04:11:20 <lispy> > [ (x,y) | x <- [-1..1], y <- [-1..1], (x,y) /= (0,0)]
04:11:22 <lambdabot> [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
04:11:41 <edwinb> oh, I misunderstod the question...
04:11:56 * edwinb hasn't had coffee yet
04:12:06 <vincenz> edwinb: same here
04:12:32 <lispy> > take 5 [ (x,y) | x <- [-1,-0.9..1], y <- [-1,0.9..1], (x,y) /= (0,0)]
04:12:34 <lambdabot> [(-1.0,-1.0),(-1.0,0.8999999999999999),(-0.9,-1.0),(-0.9,0.8999999999999999
04:12:34 <lambdabot> ),(-0.8,-1.0)]
04:12:40 <lispy> ;)
04:12:48 <vincenz> > [-1..1] >>= \x -> [-1..1] >>= \y -> if (x,y) == (0,0) then fail "nada" else return (x,y)
04:12:49 <lambdabot> [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
04:13:07 <lispy> heh
04:14:29 <vincenz> > [ (x,y) | x <- "lispy", y <- "vincenz", x > y]
04:14:31 <lambdabot> [('l','i'),('l','c'),('l','e'),('i','c'),('i','e'),('s','i'),('s','n'),('
04:14:31 <lambdabot> s','c'),('s','e'),('s','n'),('p','i'),('p','n'),('p','c'),('p','e'),('p','
04:14:31 <lambdabot> n'),('y','v'),('y','i'),('y','n'),('y','c'),('y','e'),('y','n')]
04:14:46 <vincenz> > [ x | x <- "lispy", y <- "vincenz", x > y] 
04:14:48 <lambdabot> "llliissssspppppyyyyyy"
04:14:57 <lispy> haha
04:15:08 <vincenz> interesting
04:15:44 <lispy> @pl \me you -> [ x | x <- me, y <- you, x > y]
04:15:45 <lambdabot> (. ((: [x > y]) . (y <-))) . (:) . ((x | x) <-)
04:15:46 <vincenz> > [ x | x <- "lispy", y <- take (toIntegral x) (repeat 1), x > y] 
04:15:48 <lambdabot>  Not in scope: `toIntegral'
04:15:54 <huga> oh, that's a lot of answers :) (x,y) /= (0,0) .., ofc. thanks
04:16:00 <lispy> omg, i love the point free version!
04:16:16 <vincenz> lispy: looks like a spaceshiip
04:16:23 <vincenz> > fromEnum 'c'
04:16:24 <lambdabot> 99
04:16:35 <lispy> (. ((: [x > y]) . (y <-))) . (:) . ((x | x) <-) "lispy" "vincenz"
04:16:38 <lispy> > (. ((: [x > y]) . (y <-))) . (:) . ((x | x) <-) "lispy" "vincenz"
04:16:39 <lambdabot>  parse error on input `<-'
04:16:49 <vincenz> > [ x | x <- "lispy", y <- take (fromEnum x - fromEnum 'a' +1) (repeat 1), x > y] 
04:16:50 <lambdabot>  add an instance declaration for (Num Char)
04:16:51 <Saulzar> Hehe, it doesn't understand list comprehension..
04:16:56 <vincenz> > [ x | x <- "lispy", y <- take (fromEnum x - fromEnum 'a' +1) (repeat 1)] 
04:16:58 <lambdabot> "lllllllllllliiiiiiiiisssssssssssssssssssppppppppppppppppyyyyyyyyyyyyyyyyyy
04:16:58 <lambdabot> yyyyyyy"
04:17:51 <vincenz> > [ x | x <- "lispy", liftIO $ print x] 
04:17:52 <lambdabot> Couldn't match `Bool' against `m ()'
04:17:59 <vincenz> > [ x | x <- "lispy", x <- liftIO $ print x] 
04:18:01 <lambdabot>  add an instance declaration for (MonadIO [])
04:18:26 <vincenz> > let x = True in [x | x]
04:18:28 <lambdabot> [True]
04:18:31 <vincenz> > let x = 1 in [x | x]
04:18:33 <lambdabot>  add an instance declaration for (Num Bool)
04:18:33 <lambdabot>   In the definition of `x': x = 1
04:18:33 <lambdabot>   In the definition of `joi': joi = let x = 1 in [x | x]
04:18:42 <vincenz> > let x = False in [x | x]
04:18:44 <lambdabot> []
04:19:24 <lispy> (> \me you -> me >>= \x -> you >>= \y -> if (x > y) then x else fail []) "lispy" "vincenz"
04:19:31 <lispy> > (\me you -> me >>= \x -> you >>= \y -> if (x > y) then x else fail []) "lispy" "vincenz"
04:19:32 <lambdabot> Couldn't match `[a]' against `Char'
04:19:50 <vincenz> > let loveMatch me you = [x | x <- me, x `elem` you]
04:19:51 <lambdabot>  parse error on input `}'
04:20:08 <vincenz> > let loveMatch me you = [x | x <- me, x `elem` you] in loveMatch "vincenz" "chick"
04:20:10 <lambdabot> "ic"
04:20:17 <lispy> heeh
04:20:58 <lispy> (> \me you -> me >>= \x -> you >>= \y -> if (x > y) then x else fail "huh?") "lispy" "vincenz"
04:21:07 <lispy> > (\me you -> me >>= \x -> you >>= \y -> if (x > y) then x else fail "huh?") "lispy" "vincenz"
04:21:08 <lambdabot> Couldn't match `[a]' against `Char'
04:21:09 <vincenz> return x!
04:21:14 <lispy> oh
04:21:15 <lispy> right
04:21:37 <lispy> > (\me you -> me >>= \x -> you >>= \y -> if (x > y) then (return x) else fail []) "lispy" "vincenz"
04:21:38 <lambdabot> "llliissssspppppyyyyyy"
04:21:43 <lispy> @pl (\me you -> me >>= \x -> you >>= \y -> if (x > y) then (return x) else fail []) "lispy" "vincenz"
04:21:44 <lambdabot> ("vincenz" >>=) . flip flip (fail []) . ap (flip . (if' .) . (>)) return =
04:21:44 <lambdabot> << "lispy"
04:21:49 <lispy> @pl (\me you -> me >>= \x -> you >>= \y -> if (x > y) then (return x) else fail [])
04:21:50 <lambdabot> (. ((. flip (flip . ap (flip . (if' .) . (>)) return) (fail [])) . (>>=)))
04:21:50 <lambdabot> . (>>=)
04:21:57 <vincenz> @type if
04:21:58 <lambdabot> parse error (possibly incorrect indentation)
04:21:59 <vincenz> @type if'
04:22:00 <lambdabot> Not in scope: `if''
04:22:04 <vincenz> @hoogle if'
04:22:06 <lambdabot> Prelude.undefined :: a
04:22:06 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
04:22:06 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
04:22:11 <vincenz> .O
04:22:15 <vincenz> > if' True 1 2
04:22:15 <lispy> if' is a convention used by @pl not a real fuction
04:22:16 <lambdabot>  Not in scope: `if''
04:22:21 <vincenz> odd
04:22:31 <lispy> if' b t e = if b then t else e
04:23:30 <lispy> hm..anyway to get rid of the if?
04:23:54 <lispy> @pl \b t e = if b then t else e
04:23:55 <lambdabot> (line 1, column 8):
04:23:55 <lambdabot> unexpected "="
04:23:55 <lambdabot> expecting pattern or "->"
04:24:00 <lispy> @pl \b t e -> if b then t else e
04:24:01 <lambdabot> if'
04:24:16 <vincenz> @state Lispy's funky
04:24:18 <vincenz> @state
04:24:19 <lambdabot> Lispy's funky
04:25:23 <vincenz> I always wondered whether I can consider state a cell or not
04:25:25 <vincenz> @state a
04:25:37 <vincenz> @combine (combine state) state b
04:25:38 <lambdabot> Unknown command, try @listcommands.
04:25:43 <vincenz> @combine combine state state 
04:25:45 <lambdabot> Unknown command, try @listcommands.
04:25:47 <vincenz> @listcommands
04:25:50 <lispy> > (\me you -> me >>= \x -> you >>= \y -> when (x > y) x) "lispy" "vincenz"
04:25:50 <lambdabot> Couldn't match `[()]' against `Char'
04:25:50 <lambdabot> use listcommands [module|command]. Modules are:
04:25:50 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
04:25:50 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
04:25:50 <lambdabot> seen spell state system todo topic type version vixen where
04:25:54 <vincenz> @combine
04:25:55 <lambdabot> Unknown command, try @listcommands.
04:26:07 <lispy> @type Control.Monad.when
04:26:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:26:25 <vincenz> > when True 1
04:26:27 <lambdabot>  add an instance declaration for (Num (m ()))
04:26:30 <vincenz> > when False 1
04:26:31 <lambdabot>  add an instance declaration for (Num (m ()))
04:26:48 <vincenz> @help .
04:26:49 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>=
04:26:49 <lambdabot> f
04:26:58 <vincenz> @. (. state state) state a
04:27:00 <lambdabot> compose module failed: Parse error: "(."
04:27:05 <vincenz> @. . state state state b
04:27:06 <lambdabot> Not enough arguments to @.
04:27:15 <vincenz> @. . state state b state c
04:27:16 <lambdabot> b
04:27:33 <vincenz> @. . state state c state a
04:27:34 <lambdabot> compose module failed: Parse error: "b"
04:27:48 <lispy> @. vixen keal
04:27:49 <lambdabot> tell me more about yourself.
04:27:54 <lispy> @. vixen keal
04:27:55 <lambdabot> You choose a topic, any will do
04:28:00 <vincenz> @. vixen
04:28:01 <lambdabot> Not enough arguments to @.
04:28:04 <vincenz> @. keal vixen
04:28:05 <lambdabot> all i know is i have experienced my own death unhappening...
04:28:40 <vincenz> I was just wondering whether using . with state could lead to more memorycells
04:28:45 <vincenz> by having a sort of pipeline
04:28:48 <lispy> @hoogle Bool -> a -> b -> a
04:28:50 <lambdabot> Control.Exception.assert :: Bool -> a -> a
04:28:50 <lambdabot> Control.Parallel.par :: a -> b -> b
04:28:50 <lambdabot> Control.Parallel.seq :: a -> b -> b
04:28:58 <vincenz> > assert True 1
04:29:00 <lambdabot>  Not in scope: `assert'
04:29:27 <vincenz> @. is pretty useless
04:29:28 <lambdabot> compose module failed: Parse error: "is"
04:29:36 <lispy> vincenz: not entriely
04:30:02 <lispy> @. vixen google pizza
04:30:03 <vincenz> @. state eval 1+1
04:30:03 <lambdabot> i don't have internet access, sorry
04:30:04 <lambdabot> state c state a
04:30:08 <vincenz> @state
04:30:09 <lambdabot> 2
04:30:09 <lambdabot>  
04:30:14 <vincenz> @. state eval 1+1
04:30:20 <vincenz> @. eval state
04:30:22 <lambdabot> 2
04:30:29 <xerox> @>.> would pheraphs be more useful.
04:30:30 <lambdabot> compose module failed: Parse error: "would"
04:30:39 <vincenz> @help >.
04:30:40 <lambdabot>  @help <command> - ask for help for <command>
04:30:42 <vincenz> @help >.>
04:30:43 <lambdabot>  @help <command> - ask for help for <command>
04:31:02 <xerox> (>.>) = flip (.)  -- or even >>>.
04:31:39 <vincenz> @. karma+ eval reverse "znecniv"
04:31:41 <lambdabot> "vincenz"'s karma raised to 1.
04:32:05 <xerox> heheh
04:32:15 <Saulzar> Loophole :)
04:32:21 <dcoutts> @yarr!
04:32:22 <lambdabot> Drink up, me 'earties
04:32:37 <vincenz> @. yarr eval  reverse "znecniv"
04:32:38 <lambdabot> compose module failed: Parse error: "yarr"
04:32:43 <vincenz> @. yarr eval reverse "znecniv"
04:32:44 <lambdabot> compose module failed: Parse error: "yarr"
04:32:51 <vincenz> the bad part is that it requires
04:32:53 <vincenz> . f g a
04:32:55 <vincenz> and not 
04:32:56 <vincenz> .f g
04:32:59 <vincenz> cause then you can't do more
04:33:01 <vincenz> like
04:33:05 <vincenz> . . f g h something
04:33:15 <vincenz> or..
04:33:36 <vincenz> @. state . state state a
04:33:36 <vincenz> @. state . state state b
04:33:37 <lambdabot> a
04:33:37 <lambdabot>  
04:33:38 <vincenz> @. state . state state c
04:33:39 <lambdabot> b
04:33:39 <lambdabot>  
04:33:41 <vincenz> @. state . state state a
04:33:42 <lambdabot> c
04:33:42 <lambdabot>  
04:33:48 <vincenz> @. state . state state 
04:33:49 <lambdabot> a
04:33:49 <lambdabot>  
04:33:52 <vincenz> @. state . state state 
04:34:00 <vincenz> nope, one memory cell
04:34:16 <xerox> It's a flip-flop
04:34:19 <vincenz> yeah
04:34:26 <vincenz> but I was hoping like electronics...put a few in a pipeline
04:34:30 <vincenz> and you have several D-flipflops
04:35:01 <xerox> They're seqenced in time, not in space :-)
04:35:05 <vincenz> @. eval . eval eval "\"1+1\""
04:35:08 <lambdabot> "\"1+1\""
04:35:14 <vincenz> @. eval . eval eval "1+1"
04:35:17 <lambdabot> "1+1"
04:35:25 <vincenz> @. eval . eval eval showString "1+1"
04:35:26 <lambdabot>  parse error on input `}'
04:35:29 <vincenz> @. eval . eval eval showString "1+1" ""
04:35:32 <lambdabot> "1+1"
04:35:40 <vincenz> > showString "1+1"
04:35:42 <lambdabot>  add an instance declaration for (Show (String -> String))
04:35:45 <vincenz> > showString "1+1" ""
04:35:47 <lambdabot> "1+1"
04:35:49 <vincenz> blegh
04:36:27 <vincenz> I stand by my point, @. is rathre useless
04:36:29 <vincenz> and now I stop spamming
04:36:42 <xerox> @. eval eval error "1+1"
04:36:44 <lambdabot>  parse error on input `type'
04:36:45 <xerox> @. eval eval error "1+1" :: ()
04:36:48 <lambdabot>  Not in scope: data constructor `Exception'
04:36:55 <xerox> @eval error "1+1" :: ()
04:36:57 <lambdabot> Exception: 1+1
04:36:59 <xerox> hehe.
04:38:26 <tibbe> how do I invert a binary tree? I don't even know what that means
04:38:56 <xerox> How many children do your branches have?
04:39:01 <xerox> Err, it's binary...
04:39:04 <tibbe> ;)
04:39:07 <xerox> Swap the children!
04:39:22 <tibbe> it's a completly unbalanced binary tree with either 0 or 2 children
04:39:40 <xerox> In the zero case, do nothing.
04:39:58 <tibbe> a) A node has either both a left and right child OR no children
04:39:58 <tibbe> b) The right child of a node is either a leaf or NULL 
04:40:14 <tibbe> oh, I think I get what they're after now
04:40:22 <tibbe> I thought it meant turning it upside down...
04:40:28 <tibbe> and that made no sense at all
04:40:29 <xerox> Gee :-)
04:40:56 <tibbe> it should really have said, mirror
04:41:35 <vincenz> tibbe: only if it's a vertical mirror
04:41:41 <vincenz> if it's a horizontal mirror it'd make no sense
04:41:52 <vincenz> mirror Leaf = Leaf
04:42:03 <vincenz> mirror Tree a b c = Tree a c b
04:42:05 <tibbe> The problem is stated as:
04:42:06 <tibbe> Given a binary tree with the following constraints:
04:42:06 <tibbe> a) A node has either both a left and right child OR no children
04:42:06 <tibbe> b) The right child of a node is either a leaf or NULL 
04:42:19 <vincenz> b makes no sense
04:42:21 <tibbe> write code to invert this tree
04:42:34 <tibbe> vincenz, it makes it completly unbalanced right?
04:42:39 <xerox> It does
04:42:42 <vincenz> oh wait
04:42:43 <xerox> If Leaves carry values.
04:42:57 <vincenz> Tree a = Leaf a | Binary Tree Tree | Solitary Tree
04:43:02 <vincenz> err
04:43:06 <xerox> tibbe: there is no problem about unbalance
04:43:28 <vincenz> tibbe: b makes noe sense
04:43:31 <xerox> data Tree a = Nil | Leaf a | Branch (Tree a) (Tree a)
04:43:34 <vincenz> nope
04:43:34 <tibbe> I'm just trying to figure out what they want me to do
04:43:37 <vincenz> that's not what it says!
04:43:39 <vincenz> listen
04:43:48 <xerox> Oh, right...
04:43:58 <vincenz> a) :: Node a = Binary Child Child | NoChildren
04:44:06 <vincenz>   Child a = Leaf | Empty
04:44:12 <vincenz> b)  Child a = Leaf a | Empty
04:44:35 <vincenz> nope, b is even more constraining
04:44:40 <tibbe> Node a = Binary Node Child
04:44:42 <xerox> I think mine is correct.
04:44:49 <vincenz> yeaah
04:44:51 <vincenz> seems like a list to me
04:44:55 <vincenz> tbh
04:45:07 <tibbe> it looks like huffman encoding to me
04:45:14 <xerox> Except you do not have invariants here.
04:45:27 <vincenz> well emh
04:45:35 <vincenz> the right side of any node will always be either singletone or empty
04:45:37 <vincenz> meaning you get something like this
04:45:42 <vincenz> (warning spam)
04:45:46 <tibbe> cant be empty
04:45:58 <tibbe> or rather then the "node" is a leaf
04:46:03 <tibbe> since it needs both or no children
04:46:41 <vincenz>         /\
04:46:42 <vincenz>        Y  X
04:46:42 <vincenz>       /
04:46:42 <vincenz>      Z
04:46:42 <vincenz>     / \
04:46:45 <vincenz>    w  R
04:47:01 <vincenz>  that's what it looks like
04:47:04 <vincenz> it's basicaly a list of
04:47:16 <vincenz> [Either a (a,a)]
04:47:17 <tibbe> yes
04:47:26 <vincenz> ;)
04:47:31 <tibbe> Y can't have only a left child
04:47:35 <vincenz> yes it can
04:47:40 <vincenz> considering the right child == NULL
04:47:45 <vincenz> so I just left it blank
04:47:51 <tibbe> a) A node has either both a left and right child OR no children
04:47:55 <vincenz> yes
04:48:03 <xerox> Yes but if you do not care about invariants and write 'mirror' for 'data Tree a = Nil | Leaf a | Branch (Tree a) (Tree a)' it will work for the subset of trees that the problem talks of.
04:48:03 <vincenz> right child = Leaf or Null
04:48:05 <vincenz> right child = Leaf or Null
04:48:10 <vincenz> so
04:48:12 <vincenz> in more gneeric terms
04:48:28 <vincenz> [Either (_, Leaf a) (_, Null)]
04:48:30 <vincenz> or more generically
04:48:30 <tibbe> I interpret NULL as meaning, no child there
04:48:36 <vincenz> [Either (_, Leaf a) (_)]
04:48:37 <vincenz> or
04:48:45 <vincenz> [Either (b,a) (b)]
04:49:02 <vincenz> tibbe: no a child is a child is null or a leaf
04:49:30 <vincenz> so I take it that inverting would basically mean inverting the list
04:49:33 <tibbe> see, that's the problem I'm having with this, it's unclear exactly what it means
04:49:38 <vincenz> tibbe: no it's not
04:49:58 <vincenz> a) Node = Binary Child Child | Empty
04:50:00 <tibbe> to me ;)
04:50:03 <vincenz> a) Node = Binary LeftChild Child | Empty
04:50:06 <vincenz> a) Node = Binary LeftChild RightChild | Empty
04:50:09 <vincenz> b) LeftChild = Node
04:50:15 <vincenz> c) RightChild = Leaf | Null
04:50:43 <vincenz> it's a [Either a (a,a)] list assuming both Node and Leaf have data a
04:50:46 <tibbe> then it's reminicent of lisp conses?
04:50:51 <vincenz> what I said
04:50:57 <vincenz> except some have an extra element (the right leaf)
04:50:58 <tibbe> yes
04:51:13 <vincenz> so inversion is easy
04:51:16 <vincenz> ;)
04:51:22 <vincenz> let me invert the drawing I made
04:51:27 <vincenz> (no right branch == null)
04:51:59 <tibbe> but NULL is not the same as no child then, rather it's a NULL child (with no value)
04:52:08 <vincenz> tibbe: yes so valuewise
04:52:10 <vincenz> that's equivalent to null
04:52:11 <vincenz> look
04:52:17 <vincenz> [Either (a, Leaf) (a, Null)]
04:52:19 <vincenz> ==
04:52:24 <vincenz> Either (a, Leaf) a
04:53:21 <vincenz> E = empty in my drwaing
04:53:26 <vincenz>          A             W
04:53:27 <vincenz>         / \           /
04:53:27 <vincenz>        Y   X         Z
04:53:27 <vincenz>       /             / \
04:53:27 <vincenz>      Z             Y   R
04:53:29 <vincenz>     / \           /
04:53:32 <vincenz>    W  R          A
04:53:34 <xerox> Take a breath! :-)
04:53:34 <vincenz>   /             / \
04:53:37 <vincenz>  E             E   X
04:53:59 <vincenz> no right branch = rightbranch= null
04:54:32 * vincenz is on sleepdeprv
04:54:40 <vincenz> that's my excuse for my jumpiness
04:54:44 <vincenz> so sorry :/
04:55:10 <tibbe> :)
04:55:20 <vincenz> basically you draw the tree upside down
04:55:25 <vincenz> and flip the right side ones to poin down instead of up
04:55:30 <vincenz> and add an empty on the bottom side
04:56:26 * tibbe fetches a pen and paper
04:56:38 <vincenz> and obviously when you flip it upside down you mirror it
04:57:21 <MarcWeber> Is anyone using HSQL on Windows?
04:59:11 <MarcWeber> Is anyone using another SQL library for haskell?
04:59:26 <tibbe> oh, now I get it, the left children can't be null
04:59:30 <vincenz> tibbe: right
05:00:03 <tibbe> so Node = Binary Node RightChild | Empty
05:00:09 <vincenz> yes
05:00:12 <tibbe> RightChild = Null | Leaf
05:00:16 <vincenz> aka
05:00:19 <vincenz> the list thingy
05:00:22 <tibbe> yeah
05:00:35 <vincenz> [(a,Just Leaf)]
05:00:51 <lightstep> how can i define a function decode::Bits n=>Handle->IO n?
05:01:01 <lightstep> i'm having trouble calling bitSize
05:01:12 <lightstep> and i don't want to use unsafePerformIO
05:01:25 <vincenz> odd structure, I must say
05:01:36 <vincenz> [(a,Maybe Leaf)] (obviously
05:01:44 <vincenz> and if the Binary have no data...
05:01:46 <vincenz> [Maybe Leaf]
05:02:00 <vincenz> :D
05:02:15 <vincenz> and then you use some nice renaming to make it more obvious
05:02:18 <vincenz> [Maybe Stupid]
05:02:47 <vincenz> which is of course semantically correct, you don't yet know if this data structure is stupid or useful
05:03:36 * vincenz shuts up with his bad humor
05:03:54 <vincenz> Anyone know about any control-flow libs written in haskell for imperative languages?
05:04:38 <tibbe> vincenz, I interpreted Leaf a carrier of data, I think it a programming problem written for C
05:04:53 <vincenz> tibbe: see how much haskell eases your life
05:05:00 <tibbe> :D
05:05:02 <vincenz> tibbe: in c you would've prolly made a tree
05:05:14 <vincenz> in that case
05:05:16 <vincenz> we can say
05:05:18 <vincenz> [Maybe a]
05:05:27 <vincenz> or more generically
05:05:28 <vincenz> [m a]
05:05:32 <tibbe> bah
05:05:56 <vincenz> ?
05:07:35 <xerox> @index bitSize
05:07:36 <lambdabot> Data.Bits, Foreign
05:07:43 <xerox> @type Data.Bits.bitSize
05:07:45 <lambdabot> forall a. (Data.Bits.Bits a) => a -> Int
05:07:49 <vincenz> xerox: know of any cfg-analyzers?
05:07:50 <tibbe> vincenz, the last one was almost http://haskell.org/~shae/pseudocode1.pdf ;)
05:10:00 <vincenz> tiime to do control flow analysis
05:10:05 <vincenz> ;/
05:10:17 <lightstep> xerox, the problem is that i can't get a value of type n
05:10:25 <lightstep> or even an expression with that type
05:11:11 <xerox> @type \h -> System.IO.hGetLine h >>= return . Data.Bits.bitSize . (read :: String -> Int)
05:11:12 <lambdabot> GHC.IOBase.Handle -> IO Int
05:11:15 <xerox> Hm.
05:11:31 <xerox> vincenz: hs-plugins ?
05:11:55 <vincenz> xerox: huh?
05:12:32 <xerox> vincenz: hs-plugins lets you do Config.hs config files.  If it's what you mean.
05:12:37 <vincenz> config?
05:12:43 * vincenz scratches his head
05:12:49 <vincenz> cfg = control flow graph
05:12:58 <xerox> Ah, dunno.
05:13:19 <lightstep> xerox, that gives the bitSize of Int, since read returns Int
05:13:59 <xerox> Oh-uhm.
05:14:26 <xerox> lightstep: what are Bits instances?
05:15:46 <lightstep> Int, Word*, Int*, Integer, some of the C types
05:16:19 <xerox> Okay.
05:16:23 <lightstep> all the things that have bitwise operations
05:16:28 <xerox> How do you get a polimorphic result out of an Handle?
05:16:43 <xerox> Interpreting a String?
05:16:53 <lightstep> it depends
05:17:22 <lightstep> in this instance, i would read the correct amount of bytes from the file
05:17:32 <lightstep> then combine them into a value of the correct type
05:18:11 <lightstep> decode hdl = readBytes hdl (size `div` 8) >>= return . combine
05:19:31 <lightstep> the size is stored somewhere in the dictionary that the function gets (at run-time)
05:20:29 <lightstep> i could define decode hdl = let x = readBytes hdl (size `div` 8) >>= return . combine; size = bitSize (unsafePerformIO x) in x
05:20:57 <lightstep> that unsafePerformIO would give me the result type without the IO wrapping, but there has to be some easier way
05:23:58 <Saulzar> Huh?
05:24:26 <Saulzar> What type is x meant to have?
05:25:11 <lightstep> n
05:25:29 <lightstep> as in "decode :: Bits n => Handle -> IO n"
05:26:47 <vincenz> -prof           Compile for cost-centre profiling
05:26:47 <vincenz>                      (add -auto-all for automagic cost-centres on all
05:26:47 <vincenz>                       top-level functions)
05:26:50 <vincenz> I did that
05:26:51 <vincenz> nada
05:28:05 <Saulzar> You don't need some wierd magic for that, you can call bitSize on any value of Bits n ... 
05:28:36 <Saulzar> > 0 :: Data.Bits.Bits n => n
05:28:38 <lambdabot> Add a type signature
05:29:56 <lightstep> i gen an "ambiguous type variable" error
05:30:00 <lightstep> *get
05:32:09 * vincenz heads to sleep
05:32:11 <Saulzar> > let foo :: Data.Bits.Bits n => n; foo = 0 in foo :: Data.Word.Word8
05:32:11 <vincenz> way too tired
05:32:13 <lambdabot> 0
05:33:16 <lightstep> but i want a polymorphics function, so i can't use Word8
05:33:58 <Saulzar> Right, you're going to have to specify your "size" value as 0 :: Data.Bits.Bits n => n
05:34:13 <Saulzar> Then use bitSize on that
05:34:27 <xerox> undefined :: maybe?
05:34:38 <Saulzar> Yeah, I guess that's better
05:35:02 <xerox> But it seems it gives him some error back :-\
05:35:16 <lightstep> that definition that gives me the error is "size = bitSize (0::(Bits n=>n))"
05:35:31 * Saulzar mutters
05:35:43 <lightstep> i think that somehow ghc treats the n here as different from the n in the type annotation for decodeNumbe
05:35:46 <lightstep> r
05:37:02 <lightstep> actually, i think i shouldn't need the "Bits n=>" part
05:37:09 <xerox> Maybe you can enforce them?
05:37:11 <xerox> Yeah.
05:37:14 <lightstep> if these were the same type
05:37:25 <xerox> foo = (bar :: a) + baz :: a 
05:37:32 <xerox> Prolly GHC unifies the 'a's
05:38:04 <xerox> (The last 'a' being foo's type)
05:38:53 <lightstep> here i hape the opposite effect, the n's are different
05:39:17 <xerox> That's probably the reason of 'ambiguous type variable' error...
05:43:26 <Saulzar> I swear I've seen something like this before...
05:44:38 <lightstep> so, if i put the result in the variable, it would have type IO n with the correct n, and unsafePerformIO would get that n, but that's very ugle
05:44:40 <int-e> @type let x h :: IO n = let size = Data.Bits.bitSize (undefined :: n) in return (fromIntegral size) in (x 0 :: IO Int) >>= print
05:44:41 <lambdabot> IO n = let size = Data.Bits.bitSize (undefined :: n) in return (fromIntegra
05:44:41 <lambdabot> l size) in (x 0 :: IO Int) >>= print :: IO ()
05:44:49 <lightstep> and seems very not-general
05:45:19 <int-e> (that uses -fglasgow-exts though)
05:45:48 <MarcWeber> Is an instance for fromIntegral CTime declared by default? (Think is part of ffi, but I'm not sure)
05:47:13 <int-e> > let x h :: n = let size = Data.Bits.bitSize (undefined :: n) in fromIntegral size in x :: Word.Word8
05:47:14 <lambdabot>  Not in scope: type constructor or class `Word.Word8'
05:47:19 <int-e> > let x h :: n = let size = Data.Bits.bitSize (undefined :: n) in fromIntegral size in x :: Data.Word.Word8
05:47:20 <lambdabot>   Illegal signature in pattern: n
05:47:20 <lambdabot>    Use -fglasgow-exts to permit it
05:47:25 <int-e> :/
05:48:02 <Saulzar> Still gives the same "ambiguous ..."
05:48:12 <lightstep> yes, it does
05:54:06 <MarcWeber> Is it possible to use in another module beeing separated from its data definition?
05:58:04 <chrisbrown> hi all
05:58:20 <Saulzar> MarcWeber, ?
05:58:33 <Saulzar> Sure, you can define data in one module and use it in another...
05:58:35 <chrisbrown> does anybody here know about ghc on mac os x?
06:00:38 --- topic: set to '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion","HCAR 11/2005:","http://haskell.org/communities/"]' by shapr
06:00:58 <int-e> yay. ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1): getLinkDeps No iface for GHCziNum
06:01:33 <shapr> Well, zi becomes . and GHC.Num should have a .hi file so...
06:03:45 <int-e> lisppaste2: url
06:03:45 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:06:24 --- mode: shapr set -o shapr
06:06:31 <lisppaste2> int-e pasted "the `impossible'" at http://paste.lisp.org/display/16687
06:07:45 <basti_> int-e: does the :: bind tight enough to be put like that in the next-to-last line ?
06:07:47 <chrisbrown> ghc seems to be running very strangely - either that or ghc just doesn't like DrIFT
06:08:16 <int-e> basti_: yes. if I add an y :: Num a => a; y = 0  to the file, it does what I expected it to do.
06:08:32 <basti_> hmm
06:09:18 <lightstep> scoped type variables solved my problem: i defined decodeNumber hdl :: IO n = ... where size = bitSize (0::n)
06:09:19 <int-e> if I remove the () -> and _, it fails to compile, I wonder what evil thing I'm doing.
06:09:39 <basti_> hmm
06:12:21 <lightstep> are your ghc and ghci compatible?
06:12:44 <int-e> well, they are from the same build :)
06:15:16 <int-e> loading GHC.Num explicitely in ghci helps, too.
06:17:38 <MarcWeber> How can I convert CTime (beeing of C type long from Foreign.C) to Int?
06:18:13 <basti_> enumToInt?
06:18:19 <lightstep> if you delete X.hi before calling ghci?
06:19:00 <MarcWeber> basti_ Is it an enumeration?
06:19:04 <MarcWeber> I'll try
06:19:12 <basti_> it says in the docs, at least
06:19:35 <int-e> lightstep: then it works, too. even printing a number is enough (which implicitely loads Num.GHC, apparently)
06:20:23 <MarcWeber> basti_: Thanks!
06:20:51 <lightstep> int-e, that looks like a bug in ghci (not linking enough modules
06:22:10 <int-e> I agree
06:23:27 <xerox> MarcWeber: what kind of int do you get?
06:23:45 <xerox> MarcWeber: a delta from that 1980-whatever?
06:24:00 <basti_> that would have been my next question ;)
06:24:16 <basti_> but I'd think/hope it just transfers the int...
06:24:53 * JKnecht finds the combination of All about Monads and the Wikipaedia Monad entry startlingly clear.
06:25:17 * xerox slurps a spoon of honey
06:25:44 <xerox> JKnecht: Cale's article is very interesting too.
06:27:08 <MarcWeber> basti_ Can you also tell me how to get the module name of enumToInt?
06:27:20 <xerox> @index enumToInt
06:27:21 <lambdabot> bzzt
06:27:28 <xerox> @index enumTo
06:27:30 <lambdabot> bzzt
06:27:32 <basti_> uhmm
06:27:33 <xerox> @hoohle enumTo
06:27:34 <lambdabot> No matches found
06:27:40 <xerox> Meh.
06:27:43 <basti_> wtf.
06:27:43 <MarcWeber> typo
06:27:51 <MarcWeber> @hoohle enumToInt
06:27:53 <lambdabot> No matches found
06:28:15 <int-e> @index fromEnum
06:28:16 <lambdabot> Prelude
06:28:21 <basti_> its in the Prelude
06:28:24 <int-e> @type fromEnum
06:28:26 <lambdabot> forall a. (Enum a) => a -> Int
06:28:27 <basti_> ah and called differently now or what?
06:28:30 <xerox> @type toEnum
06:28:31 <int-e> @type fromIntegral
06:28:32 <lambdabot> forall a. (Enum a) => Int -> a
06:28:32 <lambdabot> forall b a. (Num b, Integral a) => a -> b
06:28:51 <MarcWeber> But it fits fromIntegral. Thanks!
06:29:36 <JKnecht> xerox: you mean 'collection of related ..."?
06:30:16 <xerox> @wiki MonadsAsContainers
06:30:17 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
06:30:21 <xerox> That one.
06:35:14 <JKnecht> thanks!
07:01:33 <greenrd> Is there an unsafePrint command or something like that?
07:01:42 <xerox> greenrd: yup.
07:01:49 <greenrd> ok, what is it called?
07:01:52 <xerox> @type Debug.Trace.trace
07:01:53 <lambdabot> forall a. String -> a -> a
07:02:07 <xerox> It prints its first argument and evaluates its second one.
07:02:48 <greenrd> cool!
07:03:13 <xerox> Well... "creepy!" fits better :-)
07:03:19 <greenrd> haha
07:39:09 <greenrd> This time I really think I've found a ghc bug
07:39:43 <greenrd> I have a function quicksort which just calls a method af, nothing more
07:40:01 <xerox> Method?
07:40:07 <greenrd> Yes
07:40:21 <greenrd> My program gets stuck
07:40:42 <greenrd> If I comment out the code of quicksort, and replace it with return (), my program does not get stuck, it finishes
07:41:00 <greenrd> However, if I comment out the code of af, and replace it with return (), my program still gets stuck
07:41:17 <greenrd> This seems to violate referential transparency
07:41:32 <xerox> Can you reduce it to a simple test-case?
07:42:05 <greenrd> *grumbles* I guess I'll have to try that
07:44:51 <greenrd> I thought it might be something to do with method dispatch, but my Debug.Trace.trace shows that it does get dispatched, but after the return () nothing happens
07:45:17 <greenrd> pretty much
07:45:20 <A-Tui> hi all
07:46:02 <xerox> greenrd: I suggest you to try to chop out the interested bits and write a test case.
07:55:30 * palomer can't believe people still use common lisp
07:57:01 <Saulzar> AI people seem to like lisp
08:00:49 <greenrd> xerox: ok, I think I've isolated the problem to a "dummy" instance declaration
08:01:05 <xerox> Ah, please tell me.
08:01:24 <greenrd> I had to create an extra instance declaration to say that all instances of my subclass were also instances of my superclass
08:01:35 <greenrd> because otherwise ghc wouldn't recognise that
08:01:48 <greenrd> I guess that was because I was using multi-parameter type classes
08:03:30 <greenrd> When I rewrite the instance declaration to be more specific - even though it doesn't contain any code in this test case! - that fixes the divergence
08:04:58 <greenrd> but that only works for my test case with most of the methods chopped out
08:05:37 <greenrd> for the real program, I would like to find a way of doing OO-style subclassing properly, so I can override methods in superclasses
08:06:38 <greenrd> The thing is, I'm not sure I actually need to use multi-parameter type classes at all
08:06:59 <greenrd> I only used them because it was the only way I could get the code to compile without errors
08:12:55 <greenrd> So let's start further back
08:13:53 <greenrd> I want to create a class and impose multiple type constraints on its methods
08:14:59 <greenrd> But in order to do that, it seems the most convenient way is to make all the type variables that need to be constrained, parameters to the class, and then put the constraints in one place, instead of repeating them for each method
08:15:41 * Ord a => [a] -> [a]
08:15:48 <greenrd> haha
08:15:59 <basti_> >_<
08:16:26 <greenrd> But then, I end up putting multiple constraints on the subclass, which seems to break method overriding (ghc doesn't recognise the superclass methods as methods of the subclass!!)
08:25:48 <greenrd> Does anyone know what I'm talking about?
08:26:09 <greenrd> the last bit I mean, multiple constraints breaking overriding
08:30:01 <greenrd> In Java 1.5 this is of course no problem - you can put lots of constraints on class parameters, without affecting overriding
08:30:34 <greenrd> because constraints are treated fundamentally differently from subclass relationships
08:30:45 <greenrd> whereas in Haskell, as I understand it, they aren't
08:31:32 * greenrd is struck by a thought
08:31:41 <greenrd> You can override methods in subclasses in Haskell, right?
08:35:31 <jethr0> greenrd: haskell's "classes" have little to do with java's
08:36:04 <Beelsebob> haskell has classes of types, not classes of objects
08:36:08 <greenrd> That's what people keep telling me, but I haven't read a good explanation of the differences
08:36:15 <Beelsebob> I guess you'd call them meta-classes in java
08:36:24 <greenrd> So, can you or can you not override methods in subclasses in Haskell?
08:36:52 <Beelsebob> the 'methods' (actually functions) are defined in the instances, not in the class
08:37:00 <greenrd> That's not correct
08:37:04 <greenrd> You can define methods in classes
08:37:10 <greenrd> as well
08:37:13 <jethr0> and adding constraints isn't as unproblematic in OO as you say either. take the old Rectangle/Square example, where scaleX and scaleY don't work in the specialized case of Square
08:37:18 <Beelsebob> yes, but they're merely default methods for when you create an instance
08:37:24 <greenrd> Right, ok
08:37:31 <greenrd> So can you override default methods in subclasses?
08:38:33 <jethr0> see: Lyskov Substitution principle (LSP)
08:38:44 <greenrd> jethr0, sure when it violates LSP you can't, but I mean in many cases you can, it seems in Haskell you can't at all
08:39:08 <Beelsebob> probably because the analysis is too hard
08:39:18 <Beelsebob> you can't expect the programmer to know when you can and can't
08:39:29 <Beelsebob> so you make a conservative and safe version - don't allow it
08:39:35 <jethr0> greenrd: as i said, haskell's classes are distinctly different from java's.
08:39:48 <Saulzar> instances are similar to java subclasses
08:39:57 <greenrd> jethr0, ok, but can you override default methods in subclasses?
08:40:22 <Saulzar> classes are most like java interfaces
08:40:38 <greenrd> ok I guess I'll just write the code and try it
08:40:42 <jethr0> :)
08:40:48 <Beelsebob> what are you trying to do?
08:40:57 <Saulzar> so there's no such thing as subclasses, they're instances :)
08:41:21 <Beelsebob> yes there are class Num a => A a where... <-- A is a subclass of Num
08:41:33 <Beelsebob> but it's a type subclass
08:41:34 <Saulzar> Yeah, but that's entirely different...
08:41:56 <greenrd> Type subclasses is what I'm talking about
08:42:14 <jethr0> Beelsebob: that's a meta-instance. as Num is not a specific class, but rather a type constraint, right?
08:42:19 <Saulzar> They don't even relate to Java inheritance
08:42:36 <Beelsebob> jethr0: Num is a class???
08:42:39 <greenrd> ok, and the answer is no, ok
08:42:44 <Beelsebob> it's not an instarce
08:42:48 <Beelsebob> instance*
08:43:58 <greenrd> So, I used an instance instead to get the equivalent to overriding superclass methods in a subclass
08:44:02 <Saulzar> It means "a" is an instance of Num...
08:44:03 <jethr0> as i've understood it the above could be written (theoretically) as: class A a ... :: Num a
08:44:04 <greenrd> But this caused my program to diverge
08:44:05 <Saulzar> Which is a class
08:44:17 <greenrd> If I make the instance just for my type, it doesn't diverge
08:44:30 <greenrd> If I make the instance for the whole subclass, it does diverge
08:44:37 <Beelsebob> Saulzar: yes, it means in order to be in A, you must also be in Num -- i.e. As are all Nums
08:44:54 <Beelsebob> is a relation - it's a subclass
08:44:58 <Saulzar> Right.. 
08:46:14 <jethr0> yes, but "class (Num a, Ord b) => X a b where ..." doesn't make X a subclass of either Num or Ord.
08:46:29 <greenrd> Oh, I thought it did
08:46:35 <greenrd> I thought I'd read that somewhere
08:46:54 <jethr0> it was meant more as a question :)
08:47:06 <Beelsebob> jethr0: I think it does
08:47:13 <Beelsebob> multiple inheritance as it were
08:47:25 <jethr0> but you can't calculate with X's, as the b element has no Num operations defined on it
08:47:41 <Beelsebob> true
08:47:43 <Saulzar> Num a  => means that a must be a member of Num...  so there can be no X a b otherwise :)
08:47:52 <jethr0> so, X can't be a subclass of Num
08:48:00 <Beelsebob> true
08:49:06 <Saulzar> Ahh .. yeah, so it's really not even similar to inheritance
08:49:23 <Saulzar> Just the same names used
08:49:59 <jethr0> Num and Ord are used a meta-types here, so to say. and X is an instance of both :)
08:50:32 <jethr0> well, that's kinda contradicting what i said earlier. at least Num and Ord are type constraints here.
08:50:36 <palomer> how do I set the precedence of an operator?
08:50:36 <greenrd> OK, next time someone tells me Java subclassing is not the same as subtyping, I'll say "it near as damned is, but if you really want to look at a language where they a different, look at Haskell" ;)
08:51:46 <jethr0> i'm still not sure there is such a thing as "subclassing" in haskell
08:51:49 <Saulzar> palomer, infix 
08:52:00 <palomer> infixr :@ 5 ?
08:52:56 <Saulzar> Doesn't ":" at the start mean it is an infix constructor rather than a function?
08:53:25 <palomer> aren't constructors functions too?
08:53:51 <Saulzar> Hmm, I suppose so
09:05:10 <jethr0> well, that's kinda contradicting what i said earlier. at least Num and Ord are type constraints here.
09:05:19 <jethr0> sry
09:05:39 <jethr0> how would i catch a generic error?
09:07:16 <Saulzar> Control.Exception
09:07:59 <jethr0> what monad is a generic error in, anyways? or is it an evil hack?
09:11:08 <Saulzar> Hmm. Well it's value is equivalent to undefined, but you can catch it in IO, I guess it qualifies as an evil hack :)
09:11:54 <jethr0> and it's got plenty of "payload" for an "undefined", too
09:13:40 <Saulzar> Things would be a little awkward otherwise
09:14:33 <Saulzar> fac (-66)  would have to have type Maybe Integer :)
09:21:17 <palomer> someone remind me...higher precedence means it binds tighter?
09:21:21 <palomer> (the tightest being application)
09:21:40 <Igloo> Right
09:21:59 <palomer> yay for Philippa 
09:22:04 <palomer> too bad I have to leave:P
09:22:15 * palomer is going to implement patterns soon
09:22:24 <Philippa> have fun
09:22:48 <Philippa> they're pretty simple to start off with so long as you've picked a reasonably trivial representation for algebraic datatypes
09:23:01 <palomer> you'll have to tell me about them later!
09:23:02 <palomer> cyas
09:34:08 * JKnecht wonders what patterns could mean in a haskell/fp context and if any relation to patterns as in 'design patterns'.
09:36:14 <JKnecht> hmmm, XSLT by gosh, by golly!
09:36:22 <astrolabe> (a:as) is a pattern in   length (a:as) = length as + 
09:36:25 <astrolabe> (a:as) is a pattern in   length (a:as) = length as + 1
09:38:48 <JKnecht> oh, yeah forget about that relatively low-level equivocation on the same term as in regexs and pattern matching. That would be the default connotation I should think.
09:40:04 <nshm> Hi all and specially basti_ :)
09:42:27 <Saulzar> There was a lecturer (Jeremy Gibbons?) who came to our Uni to teach a course on Haskell/FP design patterns, at the time I had no interest in FP - but he had a seminar on them and talked about folds unfolds etc. 
09:46:42 <Saulzar> Monads and other 'combinator' libraries would have to be FP design patterns
09:47:31 <Philippa> as would a number of producer/consumer patterns
09:47:42 <Philippa> (but folds and unfolds cover a lot of those)
09:49:57 <andrew_p> hello!
09:50:15 <andrew_p> i am a haskell  beginner
09:50:41 <Philippa> evenin'
09:50:49 * Beelsebob licks Philippa 
09:51:01 <andrew_p> and would be thankful is anyone explains what is wrong if i define innersum x = sum [0..x] and fermat n = sum [y | y <- innersum [0..n]]
09:51:01 <Philippa> 'sup? :-)
09:51:25 <andrew_p> i just want to calculate these nested sums :)
09:51:36 <tromp_> innersum [0..n] is not a list
09:51:51 <tromp_> you can't select y <- from it
09:52:03 <Philippa> repeat (innersum [0..n]) might be what you want?
09:52:06 <andrew_p> oh, thanks .. i should map innersum to a list, i guess ... will try that
09:52:10 <Philippa> (an infinite list of innersums?)
09:52:38 <Beelsebob> let innersum x = sum [0..x]; fermat n = sum [y | y <- map innersum [0..n]] in fermat 4
09:52:44 <Beelsebob> > let innersum x = sum [0..x]; fermat n = sum [y | y <- map innersum [0..n]] in fermat 4
09:52:46 <lambdabot> 20
09:53:16 <tromp_> of course  innersum x = x*(x+1)`div`2 is much more efficient...
09:53:25 <Beelsebob> indeed
09:54:41 <andrew_p> thanks, i need a minute to try that :)
09:54:51 <xerox> > let p x = sum (map (^3) [1..x]) == (sum [1..x])^2 in p 10
09:54:53 <lambdabot> True
09:57:42 <franka> It is a bit of an insult to call folds, unfolds and monads "design patterns".
09:57:54 <franka> These things have mathematical characterizations; design patterns in general do not.
09:58:09 <Philippa> that's largely a flaw in the OO community though
09:58:32 <Philippa> to a lesser extent, people still talk about "fold-like things" when they've got something related that's not been given a mathematical characterisation yet
09:58:49 <Saulzar> I think the exact term he used was "patterns in functional programming" :)
09:59:49 <franka> As long as we acknowledge it is a flaw.
10:00:04 <andrew_p> hm, i can't find out why ghc says "parse error (possibly incorrect indentation)" in function proposed by both xerox and Beelsebob
10:01:05 <andrew_p> ... if i save it into a file only ... in i type it in interactive mode, it's OK, thanks for that :)
10:01:33 <andrew_p> but what's the difference here between interactive typing and :load'ing from file?
10:01:58 <beelsebob_> you'll have indented it incorrectly in the file
10:02:12 <Philippa> I don't think allowing non-mathematically-precise patterns to be discussed is a flaw. I do think that there're a lot of them that should be made mathematically precise but which the OO crowd lack the ability to do so and/or are too busy looking at the OO kludge for implementing the pattern
10:02:27 <beelsebob_> or possibly not closed enough brackets somewhere else
10:02:31 <franka> It is not a flaw to allow them to be discussed.
10:02:53 <franka> It is a flaw to always stop there and not characterize them more precisely.
10:03:13 * JKnecht concurs w Phillipa and is ready to equate the monad w the pattern.
10:03:48 <Philippa> it'd be nice to do a "GoF in Haskell" type book
10:04:37 * JKnecht nominates Phillipa as a GOO :)
10:04:42 <beelsebob_> goths in haskell?
10:04:48 <JKnecht> s/GOO/GoO/
10:05:04 <xerox> GooOoOoOOoO
10:05:13 <beelsebob_> :o
10:05:18 <Philippa> JKnecht: if I didn't have a history of failing to get stuff done for a number of reasons that aren't going away any time soon...
10:05:26 <beelsebob_> s/G[oO]*/Stop it damn it/
10:05:28 <franka> heh (goths)
10:05:58 <JKnecht> let it be written here and considered done.
10:06:03 <franka> Jeremy is trying to write such a book, I think.
10:06:12 <franka> Or planning to.
10:10:45 <pesco> Philippa: Flippi won't find its data! :(
10:10:55 <Philippa> it might be interesting to try defining the entire class of systems that support some of the patterns, too
10:11:22 <Philippa> pesco: where've you got it installed, where's the data and where does it think it should be (according to Config.hs)?
10:11:34 <Philippa> PM if you'd rather not tell people how your box's set up
10:12:00 <Philippa> oh, and shapr kept having an issue with having forgotten to set the priviledges up right
10:12:27 <pesco> Philippa: Flippi is /var/www/flippi.cgi, data is in /var/www/flippidata, this path is hardcoded in Config.hs by me.
10:13:21 <pesco> Philippa: In fact it seems to be half-aware of its presence. If I remove the directory, I get an error report about the dir being missing, but it doesn't want to find the pages.
10:13:36 <pesco> Philippa: This is Flippi as pulled from darcs five minutes ago.
10:14:21 <pesco> Philippa: If I understand my webserver right, it should be running as user www-data, which owns flippidata and all eth files inside.
10:15:36 <Philippa> interesting... what plugins (if any) does it reckon you're using?
10:15:45 <pesco> Philippa: How do I tell?
10:16:04 <Philippa> in the first instance, by looking at the plugins var in Config.hs
10:16:29 <pesco> plugins = [DefaultSyntax.defaultSyntax,
10:16:29 <pesco>            ScriptSyntax.scriptSyntax,
10:16:29 <pesco>            ChangeHistory.changeHistory,
10:16:29 <pesco>            RecentChanges.recentChanges,
10:16:29 <pesco>            GetFields.getFields
10:16:31 <pesco>           ]
10:17:21 <Philippa> so everything I'd expect and nothing broken. Hrmm. Could you load Flippi.hs into a ghci instance so we can poke around at what it thinks it's doing a bit?
10:18:07 <pesco> Philippa: Unfortunately, no, since GHCi blows up on my architectur.
10:18:41 <Philippa> d'oh. What does the layout of the data dir look like? I might've forgotten to change the filesystem layout of the supplied data
10:19:05 <pesco> Just a flat dir with files like FlippiSyntax, RecentChanges, ...
10:19:12 <Philippa> yup, that's the old format. D'oh.
10:19:28 <pesco> :) Okay. I copied it from the 0.03 zip.
10:19:35 <Philippa> these days, pages go in their own subdir with a text.field containing the actual text
10:19:44 <Philippa> create a new FrontPage and see if it works OK?
10:20:41 <Philippa> (it should do once it realises it's trying to show a page that doesn't exist)
10:21:38 <pesco> Philippa: Okay, works. Thanks!
10:21:59 <pesco> Philippa: Maybe you should put the example data in darcs, too?
10:23:06 <Philippa> I should, yeah
10:23:33 <Philippa> I should write a quickie program to do the upgrade, too
10:23:51 <pesco> Lemme paste the bash one-liner I just used. ;)
10:24:00 <pesco> for x in *; do mkdir ../$x; mv $x ../$x/text.field; echo '[]' > ../$x/ChangeHistory.field; done
10:24:17 <pesco> That was in a subdir "old" of flippidata.
10:24:37 <Philippa> would rather have something in haskell so as to retain the same level of portability as Flippi has
10:24:58 * pesco ponders.
10:25:04 <Philippa> in fact, I should probably build it anyway, and designed to work with two different plugin sets too
10:25:22 <Philippa> ah crap, why does Haskell have such a trivial module system? :-)
10:25:27 * adu wonders
10:25:54 <Philippa> (this would be trivial if PageIO were effectively parameterised on the config it's built with, I'd import two loads of PageIO into the same module and just do a successive read/write)
10:26:29 <pesco> Yeah, don't we all wish for first-class modules? ;-)
10:27:55 <pesco> Philippa: How hard is it to add support for Mediawiki-style [[Links]].
10:27:56 <pesco> ?
10:28:03 <Philippa> trivial
10:28:11 <pesco> Which file?
10:28:22 <Philippa> DefaultSyntax
10:28:38 <Philippa> it's already got something similar you could mod
10:28:52 <pesco> [foo|bar] you mean?
10:28:56 <Philippa> yeah
10:29:37 <Philippa> another case in the linkPattern parser'd work, or if you want to yank something out that's cool too. I'd suggest creating a PescoSyntax plugin that's a mod of DefaultSyntax?
10:30:04 <pesco> Yeah, what do you think is better [Arbitrary Text Link] and _[editor's comment] or [[Mediawiki]] and [ed. comment]?
10:30:27 <pesco> I'd say the first is better, right?
10:30:28 <Philippa> I'm happy to admit my initial syntax choices may suck :-)
10:30:52 <pesco> Nah, I just don't like CamelCase.
10:30:53 <Philippa> I'm in two minds, I'd just not done much thinking when I bashed stuff out
10:31:06 <pesco> Yeah, hack away! :)
10:31:13 <Philippa> [[Arbitrary link]] would work just as easily
10:31:41 <pesco> I always get into much too much philosophical thinking about details.
10:31:48 <Philippa> camel case and choice of brackets're pretty much orthogonal issues - I just support camel case because I use it myself
10:32:04 * pesco nods.
10:32:05 <Philippa> and Flippi started out as "I need a wiki for personal use and everything sucks" :-)
10:32:14 <pesco> Hehe. Cool. :)
10:32:41 <Philippa> ironically enough, the personal wiki doesn't run because I need to either set up a local web server on another box or get round to installing and securing apache on this one ('cos I game online from this machine so it spends time in our router's DMZ)
10:33:24 <pesco> Why don't you block outside access to the local httpd?
10:33:32 <pesco> I'm running thy on this machine, personally.
10:34:03 <pesco> www.khjk.org runs fnord.
10:34:08 <Philippa> in short: I don't know I can do it from the router, and I'm running windows on here and I don't trust local measures any further than I can throw them (and you can't throw software)
10:34:41 <pesco> Oh, you're on windows, well... I don't know anything about it. :)
10:34:51 <pesco> But you should be able to firewall a port, no?
10:34:53 <Philippa> if and when we get a media machine set up in the bedroom we'll probably run a small local-only web server on it
10:35:13 <Philippa> yes. OTOH, I don't trust the firewall to be implemented early enough to avoid possible exploits
10:35:28 <pesco> Hr. What a healthy amount of paranoia.
10:35:42 <Philippa> heh
10:36:07 <Philippa> I've not actually DMZed this box in a long time anyway - and I should probably make a personal policy of never doing so
10:36:20 <pesco> :)
10:37:02 <Philippa> these days, any game that won't run through a NAT-style router has serious problems
10:37:22 <pesco> True.
10:40:18 <pesco> Philippa: What is the purpose of pagenamePattern?
10:40:37 <pesco> It's only used in linkPattern (which I want to modify) but is it meant for something broader?
10:41:04 <Philippa> it defines the set of possible pagenames - it's used in the PageIO module as well
10:41:28 <Philippa> (which is why it comes from Config)
10:41:30 <pesco> Ah, so it is what I want to change if I want [Arbitrary Page Name] to work?
10:41:51 <Philippa> pagenamePattern should define how to match "Arbitrary Page Name"
10:41:59 <pesco> Yes. Cool.
10:42:02 <Philippa> (it should also subsume any other patterns, of course)
10:42:10 <Philippa> it's an ordinary Parsec parser
10:42:33 <pesco> Great, so I'll change it from studlyCapsPattern to something more general, okay?
10:42:41 <Philippa> many1 (alphaNum <|> (char ' ')) or something, yeah
10:42:48 <pesco> Yeah.
10:42:57 <Philippa> (it does need to return the pagename it matched)
10:43:05 <pesco> Right.
10:47:22 <Philippa> I really do need to document Flippi's internals properly sometime
10:47:38 <Philippa> I started doing that on the online copy of the previous version (big mistake, it got defaced)
10:48:36 <pesco> Oops.
10:49:21 <Philippa> no prizes for spotting the first non-trivial plugin I wrote...
10:49:32 <pesco> :)
10:49:47 <jethr0> i'm trying to "catch" an exception. but although it no longer reaches the toplevel, it's also not properly caught :(
10:50:00 <Philippa> there's no wiki-visible interface to the data yet, which'd be on my 'to fix' list if I were expecting to do much more coding on it
10:50:10 <Philippa> which I should do sometime, of course
10:50:27 <Philippa> (if you're interested enough in carrying on with Flippi as a project that might change things - someone to talk to always helps)
10:51:03 <pesco> Philippa: I'm interested in seeing how it fits with my filesystem plans. Maybe we can intergrate things, if you're interested.
10:51:20 <Philippa> might well be
10:51:39 <Philippa> had a look at how the page IO system works and interacts with plugins yet?
10:51:46 <pesco> No.
10:52:22 <Philippa> effectively I'm faking a better module system and the IO components of plugins are functors from PageIOSigniature -> PageIOSigniature
10:54:48 <pesco> Er... will have to look at it to understand.
10:55:51 <pesco> Okay, I'm making defaultPagenamePattern = sepBy1 (char ' ') (many1 alphaNum)
10:55:54 <Philippa> the PageIOTrans module defines the records that're equivalent to the functors. PageIO contains the 'base' implementations and exports what happens when you apply the functors from the plugins in sequence
10:56:15 <Philippa> cool
11:05:52 <pesco> Philippa: How do I regenerate the hs-boot file?
11:06:14 <Philippa> er?
11:06:28 <Philippa> Should only be the .hi-boot that needs regenerating
11:06:36 <Philippa> the .hs-boot is effectively GHC source
11:06:41 <pesco> Identifier `Config.pagenamePattern' has conflicting definitions in the module and its hs-boot file
11:06:51 <pesco> That's what it says.
11:07:11 <Philippa> ah. Sounds like it's inferring a different type for it
11:07:29 <Philippa> copy out the type annotation, slap it in the module and watch it fall over?
11:09:10 <pesco> Philippa: no effect
11:09:38 <Philippa> interesting - it still falls over the same way?
11:09:42 <pesco> Yes.
11:10:01 <Philippa> okay. What changes've you made?
11:10:04 <pesco> Well, I did change the definition to point to defaultPagenamePattern.
11:10:09 <pesco> But what do I do?!
11:10:21 <Philippa> ah. Where's that?
11:10:39 <pesco> In DefaultSyntax, just like studdlyCapsPattern
11:10:42 <Philippa> there're a bunch of circularity going on, it might need defaultPagenamePattern mentioned in an .hs-boot now
11:10:46 <Philippa> there's, even
11:10:56 <pesco> Probably.
11:11:02 <Philippa> hrmm, odd
11:11:11 <Philippa> tried clearing out all the .hi and .hi-boot files before rebuilding?
11:11:27 <Philippa> (just an "is GHC doing something stupid?" check)
11:12:38 <pesco> Aha, I think I fixed it. Needed to change the type sig in the hs-boot.
11:12:46 <pesco> Sorry, was this what you meant earlier?
11:12:47 <Philippa> What to?
11:13:01 <Philippa> would've been if I weren't fairly sure there shouldn't be much room for that type to change
11:13:05 <Philippa> beware things falling over on you...
11:13:09 <Philippa> (what's the new type?)
11:13:21 <pesco> s/GenParser Char a String/GenParser Char () String/
11:13:38 <pesco> I suppose that's wrong...
11:13:39 <Philippa> that'll fall over
11:13:45 <pesco> I noticed. :)
11:13:49 <Philippa> the wiki parsing stuff uses the state
11:13:57 <Philippa> how're you managing to fix the state type?
11:14:11 <pesco> Ah nothing...
11:14:16 <Philippa> (when I say it uses the state... go take a look at how, you may be amused in a 'highly sick' kind of way ;-)
11:14:17 * pesco waves his hands.
11:14:32 <Philippa> you set () when you could've been polymorphic, I take it?
11:14:40 <pesco> I think so.
11:14:44 <Philippa> that's definitely something I should document then
11:14:51 <Philippa> (if you do it, somebody else will sooner or later)
11:15:17 <pesco> Probably. Just giving explicit type signatures in DefaultSyntax will help.
11:15:22 <Philippa> part of the problem is that the darcs version of flippi's had a bit of an explosion of internal complexity since 0.03. It's not all that complicated for the complexity involved, but...
11:15:27 <pesco> I was happily assuming those were all "Parser String" or something.
11:15:43 <Philippa> (that's another way of saying 'it's a 2KLoC system not a 20KLoC one, but it's still confusing if you're not careful')
11:15:47 <pesco> Yes, I noticed the large difference in file count...
11:16:08 <Philippa> it's even worse if you draw dependency or dataflow diagrams
11:16:14 <Philippa> lots of loops where it was a tree shape before
11:16:53 <Philippa> the file count difference isn't as big as it seems if you ignore the plugins and the .hs-boot files...
11:17:10 <pesco> Yah.
11:18:14 <Philippa> I'm tempted to put the plugins under Plugin.*
11:18:22 <Philippa> makes the config file a bit more verbose though
11:18:36 <pesco> Oh, I'm just noticing, paragraphs don't seem to be noticed. Did the syntax change?
11:19:07 <Philippa> slightly, yeah. I finally got a coherant cross-platform policy about CR/CRLF/LF
11:19:30 <pesco> Aha... What is it?
11:19:46 <Philippa> the on-disk format's CR
11:20:01 <pesco> Heheh, good choice.
11:20:19 <pesco> But maybe you should make it still recognize the others?
11:20:26 <pesco> Just for reading?
11:20:37 <Philippa> it should probably be CRLF to match the format we get from the web
11:20:45 <pesco> Ueach.
11:20:47 <Philippa> um. PITA. Get a better text editor ;-)
11:21:20 <pesco> ?
11:21:31 <Philippa> well, 'smore like me getting the better editor...
11:22:13 <Philippa> but basically, it's a pain in the arse and I'd rather tell people to not fuck with the data unless they know what they're doing. If it's that big a problem, cut'n'paste it into a live running copy or something
11:22:30 <Philippa> (or, gee, run the conversion yourself)
11:22:41 <pesco> Yah, but my problem was that I got the data from Flippi-0.3.zip
11:22:48 <pesco> :-P
11:22:50 * Philippa nods
11:23:10 <Philippa> the darcs repo needs a big "many things break compatability with 0.03" note
11:23:36 <Philippa> and then a changelist. Like I said, a proper convertor should be written - if I'd done it right it would've caught this without the need for me to think, for example
11:23:41 <pesco> I think programs should read all kinds of line endings, treat them all equal, but only ever write one kind (preferably '\n' I'd say).
11:23:58 <Philippa> I think requiring plugin authors to be aware of that is asking for it
11:24:59 <pesco> ?
11:25:23 <Philippa> at the moment, I'm not doing a linefeed-conversion pass on page data load
11:25:29 <Philippa> which means it needs resolving at the parsing step
11:25:45 <Philippa> (doing it on /field/ data load is very much the Wrong Thing, btw - said data could quite legitimately be binary)
11:28:19 <pesco> Philippa: [Arb Link] support works. Should I send you the patch?
11:30:41 <Philippa> was it anything more than extending the pagenamePattern appropriately? If not, I'm more likely to use it as a textual example in documentation somewhere
11:31:04 <Philippa> (though I think it probably should be the default pattern, I've residual memories of systems where spaces are wrongly significant)
11:32:08 <pesco> I've also added a third case to linkPattern (removing the need for the label).
11:32:30 <pesco> But that's all.
11:32:41 <Marc> Have you met this error message from a cabal install before?  'Could not find module: MyPackage with any suffix: ["hi"]'
11:33:28 <Philippa> yeah, I should've included the labelless case
11:33:36 <pesco> :) my pleasure.
11:33:55 <pesco> Anyway, you should have the patch mailed.
11:34:07 <Philippa> at one point shapr was going to take over as maintainer, want to prod him, check if he's doing so and if you should send him the patch?
11:34:22 <pesco> *shrug*
11:34:26 <Philippa> the third linkPattern case and the pagenamePattern change as separate things'd be a good thing IMO
11:34:48 <Philippa> okay, I'll do the prodding and forward any patches? :-)
11:36:10 <pesco> Philippa: Oh. Right about seperation...
11:36:25 <pesco> Philippa: I need to improve my patch seperation skills.
11:36:32 <Philippa> I'm godawful at it
11:36:41 <Philippa> one of the reasons I don't think I should be maintainer...
11:36:49 <Philippa> ...I should be forced to split my own patches up more
11:36:58 <pesco> Philippa: Haven't worked in actual collaborative software development for quite some time.
11:37:25 <Philippa> I just haven't, if I'm realistic about it
11:37:46 <Philippa> I'm generally better as a meme source/propagator than a producer of actual code
11:39:03 <pesco> Well, I did some stuff for university a few years back. I helped the Mesa3D guys with their autotools system even further back and _yet_ even further back, I did some work on a little game somebody was writing.
11:39:52 <Philippa> I was involved in a failed project a while back. My not producing code was one of the reasons for failure - I'd been contributing so much at the ideas stage that it'd been kinda expected I'd produce enough actual code to provide the proof of concept
11:40:13 <Philippa> right now you're holding a substantial proportion of my code output for the last three years. 'nuff said?
11:40:33 <pesco> Got it. ;)
11:41:19 <pesco> My not keeping up with Mesa development is pretty much the reason they don't have an autoconf system anymore. :)
11:41:41 <Philippa> I do prefer projects that won't fall over if I stop contributing :-)
11:42:05 <Philippa> the problem is, I'm a unique enough thinker that usually there's at least something that my presence'll improve significantly
11:42:21 <pesco> :)
11:42:35 <Philippa> I was vaguely surprised a while back when I realised I was writing small haskell programs that contained large architectural thoughts
11:42:46 <pesco> Heheh, like what?
11:43:01 <Philippa> 'cos I've never really written a program > 5KLoC, and never made substantial changes to one much bigger
11:43:12 <Philippa> Flippi's plugin model is a good example :-)
11:43:35 <Philippa> as (if written) would be some of the thinking I've done on extracting a web app architecture from it
11:43:39 <JKnecht> not in any lang? you mustbea youngling.
11:44:12 <JKnecht> or sumthin. Like tenured.
11:44:16 <Philippa> heh
11:44:31 <Philippa> uni-wise I'm still an undergrad (and it's questionable if I'll ever manage to graduate)
11:44:33 <Philippa> I'm 23
11:44:55 <JKnecht> I see.
11:45:24 <malcolm> 5kLoC would be a fairly large app if written in haskell
11:45:31 <Philippa> yeah. Less so in C though
11:45:45 <lscd> and less yet in java
11:45:56 <Philippa> I'm comfortable with haskell apps in the kLoC range, I'm just not necessarily productive enough
11:46:14 <Saulzar> Depends how you write it I think, I'm sure my haskell has a lot of baggage 
11:46:33 <pesco> Yay! I've got one. 5103 lines I did for my last job.
11:46:34 <Philippa> I tend to end up going on baggage hunts as soon as the baggage gets in the way of my continued productivity
11:46:41 * JKnecht resists the urge to wc darcs.
11:46:50 <Philippa> so my code does tend to end up reasonably concise as time goes on
11:47:12 <pesco> What are baggage hunts?
11:47:18 <Saulzar> I wish my programs would not get larger ... they are more or less doomed to getting out of hand when that happens
11:47:25 <Philippa> hrmm, now there's a thought. I should try visualising (or rather, drawing the visualisation) the structure of Flippi's current codebase sometime
11:47:39 <Philippa> I suspect it's turning into something Escher would've enjoyed...
11:47:46 <pesco> Heheh.
11:47:47 <Philippa> pesco: refactoring, essentially
11:48:09 <pesco> Philippa: What does "baggage" refer to? Stuff that makes the program ... bulky?
11:48:14 <Philippa> pesco: followed through at least how the IO component of the plugin model works yet? The parsing's similarly complicated, if anything slightly more involved
11:48:25 <Philippa> yeah. Extra weight it's carrying around
11:48:33 <pesco> Ah, of course.
11:49:05 <Philippa> and if you've got too much it ends up all over the place and starts tripping you up
11:49:22 <pesco> Philippa: WRT Flippi, no, I need to get on with what I actually need to do, which is to collect my learning about algebra/lattices/geometry :0
11:49:41 <Philippa> heh, fair enough :-)
11:49:50 <Philippa> gimme a yell if you need something explained later?
11:50:05 <pesco> Philippa: Sure. Like I said, exam's on monday (morning).
11:50:29 <pesco> Philippa: After that, I'm all business.
11:50:35 <Philippa> ah. Don't think I'm doing anything monday evening yet :-)
11:50:43 <pesco> :) Coo.
11:51:16 * malcolm went looking for LoC in various of his Haskell projects
11:51:44 <Saulzar> I am continually amazed how haskell programs "Just work" after rewriting bits everywhere with a lot of guesswork.
11:52:39 <pesco> Philippa: Har, we need mathematical notation support. :)
11:52:56 <malcolm> hscolour = 469, cpphs = 1200, hat-trans = 6255, Blobs=4818
11:53:08 <pesco> what's Blobs?
11:53:20 <malcolm> @where Blobs
11:53:21 <lambdabot> http://haskell.org/Blobs
11:53:41 <pesco> Ugh!
11:54:06 <pesco> I was just going to ask something along the lines of "Anybody know a good diagram editor?".
11:54:08 <Philippa> malcolm: if Flippi grew into everything I want it to be then it'd be >5kLoC including all the plugins
11:54:33 <Philippa> that's one of the reasons the plugin model's there in the first place - a way of forcing myself not to get things all tangled up
11:55:23 <Philippa> if the core program hit 5kLoC that'd suggest I'd got something wrong though
11:56:11 * malcolm wonders how big JaffaCake's Haskell web server code was
11:56:16 <Philippa> (I suspect I probably need to be thinking about modules with potential interdependencies rather than simple plugins though, and faking a state-of-the-art module system in Haskell can be painful)
11:56:53 <nuffer> is an (Int, Int) an Ord?
11:57:11 <pesco> nuffer: Yes.
11:57:17 <nuffer> excellent
11:57:36 <pesco> bigendian, iirc.
11:57:46 <pesco> I.e. (1,0) > (0,1)
11:57:47 <nuffer> doesn't matter to me
11:57:53 <nuffer> I just want to put it in a Map
11:58:32 <pesco> Philippa: Yeah, if you have so much circularity, I'd think a lot of it can probably be avoided.
11:59:45 <Philippa> most of it's avoidable if you ditch the plugin model
11:59:53 <pesco> Hm...
12:00:21 <Philippa> plugins tend to be dependant on the PageIO module
12:00:37 <Philippa> which is dependant in turn on the plugins for more directly obvious reasons
12:01:15 <malcolm> Found the quote - hws was <1500 LoC.  Oh, and I see that a student at Chalmers added plugins to the basic hws too.  So yeah, the core code of any app in Haskell should be pretty manageable I'd say.
12:01:32 <Philippa> at least, if it has that kind of structure
12:01:37 <Philippa> I'm not sure that applies so easily to GHC
12:02:15 <Philippa> not unless you choose to define a tiny core that looks like "parse . typecheck . (optimisations) . codegen" or something
12:02:49 <Philippa> but yeah, haskell does pretty well at allowing you to code architectural thoughts for a language with a trivial module system
12:03:06 <malcolm> well, compilers are a special case, mainly because they do an awful lot of stuff
12:03:31 <Philippa> yeah, most apps're really a parallel accumulation of stuff rather than a serial one the way compilers are
12:03:39 <malcolm> thankfully, the architectural model of a compilers is ultra simple - straight pipeline in the main
12:03:42 <Philippa> "we need a search function and a wordcount function and..."
12:04:02 <Philippa> that's less true if you're thinking about IDEs as well though (as per discussion on LtU)
12:04:18 <Philippa> I mean, it's straight pipeline + lots of backlinks, sure...
12:04:27 <Saulzar> Hmm, I guess for most application like haskell apps a lot of the code goes into the fluff around the edge, presentation and whatnot.
12:06:00 <Philippa> it's not necessarily fluff at all - it's on 'the edge' in terms of a certain kind of system diagram, sure
12:06:21 <Saulzar> Rearranging data and packing it in and out of records seems to take a fair amount of space in my code
12:06:25 <Philippa> but for something like yi, for example, the presentation's a fundamental part of what it does even if the exact nature of it isn't
12:06:26 <malcolm> My view of interactive apps is that essentially they are a command interpreter, so you have a "parser"  (or graphical interaction), an evaluation loop (interpreter), and a bunch of more-or-less independent "command" modules each of which does one thing only
12:06:28 <Saulzar> Hmm.
12:06:37 <Philippa> malcolm: mostly the same here
12:07:00 <Philippa> certainly that's how I was structuring my IRC client before I lost half the code
12:07:24 <Philippa> Flippi has the advantage of not having to loop, and the disadvantage of not being able to - but that's the usual webapp conundrum
12:09:35 <Philippa> Actually, there's a point - a more powerful module system (or a genuinely effective substitute) really does need to be one of the goals for the next non-conservative extension of haskell
12:10:02 <Philippa> I don't think anyone's going to implement experimental (for Haskell) module-level stuff without something like that to encourage it
12:10:53 <malcolm> what do you mean by more powerful?  something like the mergers of records/classes/modules that have been suggested for years?
12:11:01 <Philippa> and that kind of code's a PITA to write at the moment - there's no real way to build the relevant abstractions properly
12:11:08 <Philippa> that'd be one way to do it, yeah
12:11:47 <Philippa> certainly I'm finding use for first class 'modules' (and if modules need initialisation /and/ you need to do some weird stuff as well, I suspect that's the only way it's doable)
12:12:19 <Philippa> module-to-record and record-to-top-level-binding transformations'd be a good start
12:12:30 <davidhouse> you know what
12:12:37 <davidhouse> integration can be really ugly.
12:12:55 <malcolm> would dynamic loading of code be what you're really after?
12:13:11 <Philippa> it'd be a nice bonus but doesn't do what I'm doing without even more tedium
12:13:32 <Philippa> it doesn't solve how to put that code together, essentially :-)
12:14:07 <malcolm> I was thinking that being able to choose which module (amongst several that implement an interface) at runtime, might be a solution
12:14:10 <Philippa> also, you don't get a 'module' out of it - you have to pass the resulting stuff around in a record again, and currently said record has to appear in the module itself
12:14:15 <greenrd> Is there any code available for simplifying points-free code?
12:14:26 <Philippa> that doesn't solve anything if you're transforming modules though
12:14:30 <Philippa> (which I am)
12:14:42 <Saulzar> I don't see a real need for that kind of thing, what's an example where it is clearly the best way?
12:15:01 <greenrd> i.e. some kind of translator is what I was thinking of, although a library would also be interesting
12:15:02 <Saulzar> I kind of liked the simplicity of Haskell modules, they're just modules... nothing else
12:15:15 <malcolm> transforming modules how?  are you simulating parameterised modules?
12:15:19 <Philippa> Saulzar: Flippi's plugin architecture. In general, applications where the implementation behind an interface needs shuffling about at runtime
12:15:39 <waern> extensible records for first class modules would strike two flies at once for the next haskell
12:15:48 <Philippa> only functors at the moment, though it wouldn't be any harder to implement parameterised modules
12:16:04 <Philippa> waern: that's pretty much what I'm talking about, yeah
12:16:18 <vincenz> > 1::2
12:16:19 <lambdabot>  Only unit numeric type pattern is valid
12:16:23 <vincenz> > 1::[2]
12:16:25 <lambdabot>  Only unit numeric type pattern is valid
12:16:29 <vincenz> what does that mean?
12:16:38 <Philippa> what I'm doing at the mo is building up a transformer stack that modifies some core functionality (it looks a little like ad-hoc AOP)
12:16:59 <Philippa> so something in the stack might log all calls to one of the functions (it's already in the IO monad, of course)
12:17:21 <Philippa> in Flippi's case, doing exactly that nets you an edit log
12:17:22 <liyang> vincenz: maybe you meant : instead of :: ?
12:17:28 <vincenz> liyang: no
12:17:42 <vincenz> liyang: I was curious about the lexing of symbols
12:17:44 <vincenz> so wondered what :: did
12:18:04 <Philippa> Saulzar: suppose you've got a 'core program' that runs a webapp architecture, and a bunch of webapps being dynamically loaded and passed modules for things like database access, authentication etc
12:18:22 <Philippa> you're doing that dynamically so you can hotswap apps and modules without bringing anything down...
12:18:31 <Lemmih> @type undefined :: 1
12:18:32 <lambdabot> 1 :: GHC.Base.Unit
12:19:04 <Philippa> ...that system needs first class modules
12:19:16 <Lemmih> @type GHC.Base.Unit
12:19:17 <lambdabot> GHC.Base.Unit
12:19:27 <Saulzar> Philippa, That seems more like dynamic loading than parameterised modules/functors...
12:19:34 <Philippa> Saulzar: it does and needs both
12:19:46 <Philippa> suppose I want to set something up to use the debug database for a while?
12:20:14 <waern> philippa, how you checked out Daan Leijens latest stuff? He's built a compiler with extensible records and an impredicative type system to experiment with modules
12:20:30 <Philippa> waern: I've skimmed the paper, didn't realise it was to experiment with modules
12:20:56 <malcolm> it's called Morrow, and you know, tomorrow never comes...
12:21:23 <Philippa> and haskell sounds like some horribly impractical teaching language
12:21:27 <Saulzar> Certainly seems to, at least when the assignment is due
12:21:44 <Philippa> right now the radio times site can't even tell me what's on today
12:22:13 <malcolm> Casualty, CSI:NY, ...
12:22:41 <Philippa> I don't watch either (although I guess I should be glad Damien's off with Dan then - he'd insist on snagging the TV for Casualty)
12:22:52 <malcolm> Sounds like hot-swapping code a la Erlang.
12:23:23 <Philippa> building the architecture to do it with, yeah
12:23:54 <Philippa> obviously I don't have this web app server up and running - I'd like to take a shot at it as my dissertation project if I ever resume my studies though
12:24:15 <malcolm> yhc should be able to hot-swap code
12:24:21 <Philippa> cool
12:24:38 <Philippa> is there any chance of serialisable functions via the bytecode?
12:24:57 <malcolm> Tom is thinking about how to send bytecodes across the network and run them on other machines, then transmit the result back
12:25:38 <Philippa> cool
12:26:02 <Philippa> generally I'd be willing to build the architecture to do that given the ability to serialise bytecode at all...
12:26:11 <Philippa> ...but clearly you're going to have that much?
12:26:35 <malcolm> serialising a function is just(!) wrapping up a closure as bytecode+argument graph, plus the transitive closure of the functions mentioned in the closure's constant table
12:26:37 <Philippa> if you do, I may just have cause to use something other than GHC for some of my projects :-)
12:26:40 * Philippa nods
12:27:39 <Philippa> the ! being why I bothered to ask, of course
12:27:54 <malcolm> in the worst case, it could be the size of the entire program...
12:27:57 <Philippa> I was doing some thinking last night about what'd be involved in having a GRIN-based compiler support dynloaded code
12:28:25 <Philippa> yeah, that's a bit scary. Possibly it'd be a good idea to allow functions serialised as patches against a specified bunch of modules?
12:28:34 <Philippa> ("please don't give me 200 copies of Parsec!")
12:28:51 <Philippa> though then you run into module versioning issues
12:29:14 <Philippa> (potentially even worse if you deliberately wish to allow differing implementations)
12:29:18 <malcolm> well Tom's scheme is going to be on-demand transmission of bytecode
12:29:31 <Philippa> um. Damn - you quite probably /do/ need to for IO purposes, right?
12:29:40 <Philippa> "we implemented that module differently on this platform"
12:29:48 <Philippa> makes sense
12:30:04 <pejo> May I ask which "Tom" you guys are talking about?
12:30:11 <malcolm> so you don't bother with sending the functions in the constant table, until of course the remote machine needs them
12:30:22 <Philippa> suppose I want to persist it rather than send it over the network?
12:30:26 <Philippa> (continuation-based web apps, say)
12:30:36 <malcolm> Tom shackell, yhc hacker
12:30:40 <Saulzar> Hehe, when lazy evaluation becomes really important.
12:32:14 <malcolm> Philippa: I'm sure there are ways to do that.  Once you have the RTS ability to package up bytecodes, it is just a matter of creating a reflection API in Haskell to access it.
12:32:53 <Philippa> that reminds me, I'd love to see a way of a) giving suitably canonical names to modules and b) having persistable typeids against some set of canonical modules
12:33:07 <Philippa> persistant typed storage being the goal, unsurprisingly
12:34:09 <malcolm> the persistence of types is the trickiest bit.  maybe we should assign 64-bit IDs to types.  Should take a while until we run out.
12:34:30 <malcolm> like RFID tags...
12:35:37 <SimonRC> malcolm: Did you mention a *person* called Shackell?
12:35:40 <Philippa> I'd rather not try to make them globally unique
12:35:45 <Philippa> not at this stage, anyway
12:36:57 <malcolm> SimonRC: yes, nearly an anagram
12:37:04 <SimonRC> That's odd , I have a small, unfinished programming language called Shakell (Anagram of Haskell, implemented in Haskell, and quite *like* Haskell.)
12:37:39 <malcolm> SimonRC: what makes it different?
12:37:54 <SimonRC> It's an esoteric language.
12:37:58 <SimonRC> very small AT<
12:38:01 <SimonRC> *ATM
12:38:43 <SimonRC> \-calculus with simple pattern-matching but LISP-style CONS
12:39:09 <SimonRC> Shakell has a pattern-matching feature I have ever seen anywhere else.
12:39:20 <SimonRC> Pure functional.
12:39:30 <lscd> what pattern-matching feature?
12:40:22 <xerox> Howdy SimonRC!
12:41:27 <xerox> Does it match coalgebraic datatypes?
12:41:33 <SimonRC> (Because it was easy to implement:) An operator that takes two functions, and returns a function that tries to match a pattern and evaluate the corresponding expression from first function, and if no pattern matches, tries to match a pattern for the second function
12:41:38 <SimonRC> xerox: eh?
12:42:12 <xerox> Ah, np.
12:42:59 <SimonRC> so, you could write a function f which can't deal with the empty list, and a function g which can, and the function "|fg would be like f, but use g to deal with the empty list.
12:43:28 <SimonRC> In fact, the | operator is the only way to create a function with multiple patterns.
12:43:34 <malcolm> Philippa: for persistent typed storage, you would probably need to give the compiler access to both old and new versions of the code - so it could tell whether to invalidate already-stored data due to a change in the underlying types
12:43:49 <Philippa> SimonRC: sort-of equivalent to catching pattern-match failure exceptions, then?
12:43:57 <ski> SimonRC : adding partial functions, thus ?
12:44:02 <SimonRC> Philippa: yeah
12:44:09 <Philippa> malcolm: I'd very deliberately insist "these aren't the same type!" myself :-)
12:44:31 <Philippa> on a running system, loading in a new version of an old module should be a task that requires you to consider your upgrade path
12:44:32 <SimonRC> ski: ?
12:44:37 <malcolm> Philippa: that's what I meant, checked by the compiler
12:45:04 <Philippa> and I'd probably want a fairly explicit module registration system, with no persisting of types from non-registered modules
12:45:10 <Philippa> 'cos ultimately you're going to need a type registry
12:45:17 <ski> SimonRC : those are partial functions, since they can fail
12:45:34 <malcolm> but you /do/ want to be able to retrieve old data if its type has not changed.
12:46:06 <SimonRC> ski: ah, ok.  But Pattern-matching is the only sort of failure ATM
12:46:06 <Philippa> sure. Being me, I'd also like a chance to automagically upgrade if I know how to perform the translation, too
12:46:31 <vincenz> > show "\0x04"
12:46:33 <lambdabot> "\"\\NULx04\""
12:46:34 <ski> SimonRC : sure
12:46:38 <vincenz> > show "\x04"
12:46:39 <lambdabot> "\"\\EOT\""
12:46:45 <vincenz> eot??
12:46:51 <malcolm> Another requirement is to be able to write code that converts stuff from the old version of the type to the new version, but then that would imply their names are different etc., so there are your unique IDs anyway.
12:46:54 <SimonRC> End Of Transmission
12:47:10 <Philippa> exactly :-)
12:47:19 <SimonRC> vincenz: stuff from the teletype days.  when TTYs were *really* TTYs
12:47:42 <vincenz> ah
12:47:44 <vincenz> it's in haskell
12:47:49 <ski> (SimonRC : i recently pondered something like this, in relation to partial morphisms etc in CT)
12:47:50 <vincenz> $unisymbol = \x04
12:48:37 * Philippa pondered building an equivalent by passing pattern-match-failure continuations around ('have a _ case that calls this') and/or a monad to do it
12:49:35 <davidhouse> i need a project.
12:49:37 <ski> combining several equations defining a function is basically this
12:50:01 <malcolm> Philippa: your type registry would only need to be local to your compiler installation I guess, not global across the Haskell world
12:50:11 <davidhouse> it should not be too big (say, a couple weeks' work, perhaps more) and should be suitable for someone that's almost a complete haskell beginner
12:50:15 <SimonRC> First-class patterns(!)
12:50:18 <SimonRC> :-D
12:50:31 <ski> ('f (Left x) = foo x' defines a partial morphism from 'Either a b' to 'c' (given 'foo :: a -> c'))
12:50:34 <SimonRC> how ... useful *they* would be
12:50:42 <Philippa> malcolm: exactly. Preferably I wouldn't even have it that wide-scoped - I'd like to be able to register against different registries and specify one to the RTS on program invocation
12:50:45 <SimonRC> ski: ok
12:50:49 <ski> SimonRC : what would it mean ?
12:51:15 <SimonRC> waht would what mean?
12:51:17 <Philippa> though that needs a separate scheme for canonically naming modules s.t. you can ask for the ID for Module.Type
12:51:27 <ski> SimonRC : the first-class patterns
12:52:14 <SimonRC> you could invent first-class expression as well and make lambda a function
12:52:15 <vincenz> @hoogle stringbuffer
12:52:17 <lambdabot> No matches found
12:52:30 * ski wonders how copartial functions would work in practice, too
12:52:42 <malcolm> Do you mean, disallowing the re-export of types from secondary modules, because then you don't know their "real" name?
12:52:45 <Philippa> SimonRC: why bother? Why not just have lambda bind nothing but variables and then do the case manually?
12:52:49 <ski> SimonRC : err, 'make lambda a function' ??
12:53:21 <Philippa> malcolm: hrmm, didn't think about whether that'd be necessary. Probably not if the "real" name isn't a value
12:53:30 <SimonRC> yeah, \ :: Pattern a -> Expression a b -> (a -> b)
12:53:32 <SimonRC> :-)
12:53:53 <ski> but a pattern doesn't just have a type
12:54:00 <SimonRC> Philippa: Shakell doesn't have cases
12:54:03 <ski> it also has free vars, with types
12:54:17 <SimonRC> okay, that wouldn't work really
12:54:33 <malcolm> davidhouse: what kind of projects interest you? what kind of things have you written before (in other languages)?
12:55:38 <ski> (SimonRC : but, in a meta-system, you can type an object-lambda, yes)
12:55:48 <davidhouse> malcolm, well i've come from a web-dev background. i'm also interested in maths but i've written quite a few mathy programs so far and there's only so much you can do with them and i'd like to get used to some different sides of haskell.
12:55:56 <davidhouse> i was thinking perhaps a basic text browser
12:55:59 <davidhouse> minus HTML parser.
12:56:18 <SimonRC> Perhaps a roguelike game?
12:57:15 <malcolm> what do you mean by "text browser minus HTML parser"
12:58:18 <davidhouse> malcolm: well it would basically be curl, plus perhaps some features like "count the number of links on this page", somethinig like this
12:58:27 <davidhouse> but i don't want to have to build an entire HTML parser into it
12:58:50 <davidhouse> SimonRC: rouge?
12:58:59 <malcolm> Don't write one - use an existing one.
12:59:15 <SimonRC> davidhouse: no, Rogue.
12:59:34 <malcolm> (e.g. there is an HTML parser in HaXml), but that might be throwing you in at the deep end a bit
12:59:50 <SimonRC> davidhouse: See Wikipedia, and rec.games.roguelike.development
13:02:40 <pesco> "WHAT, a Human in a Precursor service vessel?
13:03:03 <pesco> How did you escape the SLAVE SHIELD, or are you A ROGUE?!"
13:03:25 <vincenz> @hoogle StringBuffer
13:03:26 <lambdabot> No matches found
13:03:35 <vincenz> @fptools StringBuffer
13:03:37 <lambdabot> StringBuffer not available
13:08:43 <davidhouse> okay, well a browser it is.
13:08:51 <davidhouse> so what network libraries does haskell have?
13:08:57 <davidhouse> i.e., how do i make an HTTP request?
13:10:07 <pesco> davidhouse: I believe http://haskell.org/http/ is the library to look at.
13:10:21 <davidhouse> thanks pesco :)
13:12:47 <pesco> God, I hate web browsers. ;-)
13:23:05 <jethr0> vincenz: hey
13:43:45 <davidhouse> hey, i'm trying to install http://haskell.org/http/
13:44:00 <davidhouse> it's saying "cannot satisty dependancy Crypto-any"
13:44:08 <davidhouse> which i've just installed to /usr/local/bin
13:44:14 <davidhouse> do i need to edit some path or something?
13:44:36 <SimonRC> which compiler are you using?
13:44:49 <davidhouse> GHC.
13:45:02 <davidhouse> 6.4.1
13:45:44 <Lemmih> How did you install it?
13:47:03 <davidhouse> crypto? the way it says to in the manual:
13:47:17 <vincenz> jethr0: hi! wb
13:47:20 <vincenz> jethr0: join the cha
13:48:02 <davidhouse> ghc -o Setup Setup.hs -package cabal; ./Setup configure --prefix=/usr/local; ./Setup build; ./Setup install --user
13:48:17 <vincenz> binary42: ping
13:48:23 <davidhouse> tests ran without failute (i think)
13:48:26 <binary42> hi
13:48:44 <vincenz> binary42: join the chan?
13:48:54 <binary42> sure.
13:49:33 <Lemmih> davidhouse: Does `ghc-pkg list` mention Crypto?
13:49:58 <davidhouse> Lemmih: no
13:51:47 <Lemmih> Then the installation went wrong.
13:51:49 <davidhouse> i did run the last command as root, would that affect anything?
13:53:23 <davidhouse> and i used "--user" as the flag, is that perhaps meant to be replaced with the user name or something?
13:53:51 <SimonRC> Should he try manually exposing the package?
13:54:02 <SimonRC> I did that for HSCurses.
13:56:19 <davidhouse> SimonRC: how is that done?
13:56:43 <SimonRC> see `ghc-pkg --help`
13:59:59 <pesco> Philippa: Do you do anything in Flippi to support Unicode input or is it just luck on my side that it works out?
14:00:04 <davidhouse> SimonRC, Lemmih, sorry, kopete froze up
14:00:21 <davidhouse> SimonRC, do i want ghc-pkg register or ghc-pkg expose?
14:01:23 <SimonRC> davidhouse: expose
14:01:48 <SimonRC> HSCurses at least registers stuff for you.
14:01:52 <Lemmih> Exposing it won't help if it isn't installed.
14:02:13 <davidhouse> i ran the tests the manual told me to, they worked.
14:02:32 <davidhouse> perhaps it ghc-pkg just didn't get told about it
14:03:22 <Lemmih> `Setup install` should register it with ghc-pkg.
14:04:20 <Philippa> pesco: I do nothing either way. I get the impression that so long as the compiler handles it all OK it should 'just work'
14:04:56 <Philippa> poke around Network.CGI a little if you're interested?
14:05:10 <davidhouse> Lemmih, SimonRC: http://pastebin.com/550262 is the output from ./Setup install --user
14:05:45 <Lemmih> davidhouse: Why did you install it in roots local package conf?
14:06:33 <davidhouse> i figured it was analoguous to `make install`, which normally needs root's privs.
14:06:38 <Lemmih> davidhouse: Either run 'Setup install --user' as yourself or 'Setup install' as root.
14:06:55 <davidhouse> what does the --user flag do then?
14:06:57 <Lemmih> `Setup install --user` is a local install.
14:07:42 <pesco> Philippa: Yeah, I suppose Network.CGI should take care of getting it all in correctly from me, but I'm wondering about saving it to disk. Last time I checked, GHC did nothing in the way of handling UTF-8...
14:07:56 <davidhouse> Lemmih++
14:07:57 <davidhouse> it works :)
14:09:59 <pesco> Hah, this is fun, I'm going to make my own little Mathworld. :)
14:10:40 <pesco> Mathworld is way too sparse on explanations anyway.
14:33:04 <davidhouse> is there a command for something like 'quit this function now'?
14:33:25 <davidhouse> (i'm inside a do statement so the normal that's-not-very-function doesn't really apply)
14:34:43 <davidhouse> *that's-not-very-functional
14:34:48 <Lemmih> No, there isn't.
14:35:13 <Lemmih> And it isn't very functinal even in a do block (:
14:35:23 <ski> (in a continuation monad, you could jump out)
14:35:41 <Lemmih> > do x <- [1 .. 10]; return (x*2)
14:35:43 <lambdabot> [2,4,6,8,10,12,14,16,18,20]
14:54:46 <MarcWeber> Have you met this error message from a cabal install before?  'Could not find module: ><MyPackage> with any suffix: ["hi"]' I don't know what this should tell me (?)
14:56:31 <Lemmih> MarcWeber: Do you have a module called '><MyPackage>'?
14:57:58 <MarcWeber> Lemmih I have mypackage.cabal and mypackage.hs
15:00:26 <MarcWeber> Lemmih:  I'm getting this error with my one one hs file test cabal package which worked once and with port of htoolkit.. (But here I had to rewrite the format to use the new package description format)
15:02:09 <Lemmih> I don't follow.
15:09:46 <davidhouse> is Result a standard constructor/monad/whateve? I'm seeing it used in the 
15:10:00 <davidhouse> aargh, stupid enter/backspace being next to each other
15:10:16 <davidhouse> is Result a standard constructor/monad/whateve? I'm seeing it used in the Network.HTTP library http://haskell.org/http but I haven't seen it before
15:10:50 <MarcWeber> Lemmih: http://www.rafb.net/paste/results/CEbshb10.html
15:12:13 <Lemmih> davidhouse: Result is defined in the http package.
15:13:07 <davidhouse> Lemmih, it wasn't in the API docs at http://haskell.org/http/api/Network.HTTP.html so i thought it might be standard. it's a monad?
15:13:15 <Lemmih> MarcWeber: Where's MyPackage.hi located?
15:13:41 <MarcWeber> Doesn't ghc create this file? hi=haskell interface belongs to MyPackag.o ?
15:14:08 <jethr0_> can anyone tell me how to use haddock? when doing "haddock file.hs" i get the weirdest of error messages
15:14:52 <MarcWeber> jethr0:   I've never used haddock but one way to get to now is take project which is using haddock and do make -n.
15:15:03 <jethr0_> good idea
15:15:21 <jethr0_> MarcWeber: are you using sth else or simply doing without generated docs?
15:15:43 <MarcWeber> Lemmih: ?
15:16:40 <MarcWeber> Will be afk for some minutes
15:18:39 <MarcWeber> jethr0: I've never had to use it, yet.
15:18:49 <pesco> Anybody here familiar with lattice theory? Am I correct that a complete lattice is just one with a greatest and a least element?
15:18:55 <MarcWeber> I'm struggling compiling existing libs.. I'm still a haskell noob ;-)
15:19:16 <Lemmih> MarcWeber: Yes. And where is it?
15:20:04 <MarcWeber> Lemmih: Nowhere. But why?
15:21:16 <Lemmih> MarcWeber: Cabal can't find it.
15:22:29 <MarcWeber> Neither can I
15:22:37 <Lemmih> MarcWeber: Try running 'Setup.lhs build -v'.
15:22:48 <Lemmih> *Setup.hs
15:22:53 <MarcWeber> I already did this.. but I can do it again.
15:23:24 <Lemmih> What did it say?
15:23:45 <Lemmih> (notice the extra -v flag)
15:23:54 <MarcWeber> I did
15:25:13 <MarcWeber> Lemmih http://www.rafb.net/paste/results/6zhcsj58.html
15:27:07 <davidhouse> hey, my understanding of monads is failing me:
15:27:20 <davidhouse> i'm writing a little program around the Network.HTTP library
15:27:32 <MarcWeber> Oh build returns exit status 5
15:28:04 <davidhouse> there's a function, simpleHTTP, which returns a Result Response, where Result is a monad used around HTTP quite a bit and Response is a datatype containing some information on the http response.
15:28:51 <davidhouse> right. so i've made an http request and i'm trying to extract the response body, and print it to stdout. the accessor function for the response body is simply rspBody.
15:28:52 <MarcWeber> Lemmih runhaskell -v Setup or runhaskell Setup -v?
15:29:00 <Lemmih> type Result a = Either ConnError   {- error  -}
15:29:00 <Lemmih>                        a           {- result -}
15:29:31 <Lemmih> MarcWeber: runhaskell Setup build -v
15:29:33 <davidhouse> i've tried both putStr $ rspBody resp and rspBody resp >>= putStr, but netheir are working. what accomplishes what i need?
15:31:20 <davidhouse> Lemmih, so i need to do a case on the result, and then do what i'm trying to do on Right?
15:31:46 <Lemmih> davidhouse: Yep.
15:31:59 <davidhouse> thanks.
15:32:16 <davidhouse> Lemmih: is Result actually a monad then? it seems a bit simple
15:33:14 <Lemmih> davidhouse: It /is/ possible for Either to be a Monad.
15:43:27 <MarcWeber> Lemmih http://www.rafb.net/paste/results/CmkbD552.html ?
15:44:21 <vincenz> what's the diff between ST and State?
15:53:08 <MarcWeber> What is going wrong?
15:53:39 <Lemmih> MarcWeber: Is 'dist' writable?
16:02:27 <MarcWeber> Lemmih: I'm on windows so it should be but I'll check
16:03:19 <MarcWeber> It was write protected. shit.
16:16:40 <vincenz> type TyperMonad a = ErrorT String (State Env) a
16:16:42 <vincenz> this won't work
16:16:45 <vincenz> what are the solutions?
16:17:18 <jethr0_> vincenz: i think ST is a state transformer, isn't it?
16:17:51 <Philippa> not exactly
16:17:59 <Philippa> it gives you a proper heap and references
16:18:01 <vincenz> why can't I do
16:18:08 <vincenz> type TyperMonad a = ErrorT String (State Env) a
16:18:09 <Philippa> it's supposed to be State Thread
16:18:15 <jethr0_> ah, ok
16:18:30 <vincenz> and then use TyperMonad in classes that require a monad
16:18:48 <Philippa> at a guess without having checked the docs, you mean ErrorT String (State Env a)?
16:19:03 <vincenz> oh!
16:19:17 <vincenz> nope
16:19:46 <Philippa> like I said, I haven't checked the docs
16:20:03 <Philippa> ErrorT String (State Env a) a?
16:20:12 <vincenz> noe
16:20:17 <vincenz> errorT expects kind * -> *
16:21:00 <Philippa> okay. What error's it throwing up when you try to use TyperMonad?
16:21:23 <vincenz> Type synonym `TyperMonad' should have 1 argument, but has been given 0
16:21:38 <MarcWeber> Lemmih:  It's really strange! The property page of Windows tells me: Write Protected. I can "remove it" but going to the property page it tells me again: write protected (???) Nevertheless echo test > dist/test works.. So it's writable. Damn I hate win for that.
16:21:39 <vincenz>  In the instance declaration for `TransformT TyperMonad ScopedIdent TypedIdent
16:22:17 <Philippa> OK, so I need to see your instance declaration...
16:22:56 <Lemmih> MarcWeber: chmod +rw dist (:
16:23:13 <Philippa> (but as a guess, you're using it somewhere that expects kind * and thus you need to apply it to a type variable - (TyperMonad a) )
16:24:04 <vincenz> Philippa: nope
16:24:12 <vincenz> I'm using it in a place that expects kind *->*
16:24:15 <vincenz> but I guess it's not possible for type
16:24:20 <vincenz> cause they can't be parametrize
16:24:26 <Philippa> ah, yeah
16:24:29 <vincenz> I tried newtype with proper deriving to no avails
16:24:52 <Philippa> um, you know you can't derive every class, right?
16:25:05 <vincenz> Philippa: apparently
16:25:19 <MarcWeber> Lemmih: Why the hell can I write there nevertheless??? I'm getting crazy  ;-)
16:25:48 <Philippa> so where does TransformT come from?
16:26:27 <Philippa> any class you've defined yourself won't be derivable
16:26:37 <Philippa> (OK, this isn't entirely true but you'll know when it isn't)
16:27:05 <vincenz> Philippa: afaik you can derive monad
16:28:05 <Philippa> no, you can't
16:28:14 <vincenz> I've seen it done
16:28:35 <Philippa> where?
16:28:54 <vincenz> http://www.haskell.org/hawiki/SudokuSolver
16:28:54 <Philippa> having an instance of monad available by default for a transformer stack, sure, I've seen that
16:29:01 <Philippa> deriving monad? That's a whole different ballgame
16:30:59 <vincenz> is it possible to have a case with multiple values do the same thing
16:31:02 <vincenz> like case x of
16:31:05 <vincenz>  A, B, C ->
16:31:17 <Philippa> nope
16:31:27 <vincenz> ;/
16:31:30 <Philippa> you can have them all call the same local function though
16:31:47 <vincenz> dan
16:31:50 <vincenz> they should allow that
16:32:11 <Philippa> it's not a big deal
16:33:10 <Philippa> if you've really got enough constructors to check over that it's actually painful, you may as well provide an Eq instance or similar and write a function that matches anything in a supplied list
16:33:36 <Philippa> about the only time I've seen it crop up in practice, it was a job for a parsing library anyway
16:40:56 <MarcWeber> OT: Lemmih http://support.microsoft.com/?kbid=326549 You cannot view the writeable attributes of folders ..  only with the attrib command from windows command shell.. ! Ha. windows I love you
16:41:01 <MarcWeber> So that's not my problem
16:42:49 <Lemmih> The setup script failed with error code 5, right?
16:45:43 <MarcWeber> Yeah
16:45:50 <Lemmih> errno 5 == EIO.
16:45:51 <Lemmih> hm.
16:46:25 <MarcWeber> Lemmih ls-l and totalcommander are not showing the write protected flag.. and its writeable.. Thans for that info
16:50:10 <MarcWeber> Lemmih: I'll create a thread at haskell-cafe
16:50:59 <dons> moinmoin
16:52:26 <MarcWeber> moin.
16:52:29 <eivuokko> MarcWeber, have you tried actually modifying ACLs? (Simple gui is available in Security-tab for file properties - if that tab is enabled for you)
16:52:37 <MarcWeber> ACL?
16:52:44 <eivuokko> Access Control List
16:53:02 <MarcWeber> user management? No
16:53:21 <vincenz> > True && False || True
16:53:23 <lambdabot> True
16:53:31 <MarcWeber> eivuokko:  Is ghc using another user on windows to compile?
16:53:46 <vincenz> > False && False || True
16:53:48 <lambdabot> True
16:54:01 <eivuokko> MarcWeber, no.  I don't know what the issue is, just that writable right isn't usually easy to control via attrib
16:54:14 <eivuokko> (Nor is anything else than system flag, I think)
16:54:26 <lispy> > False && undefined || True
16:54:28 <lambdabot> True
16:54:29 <MarcWeber> ;-) I can't install the most simple cabal package and I have no glue why
16:54:31 <kevind> && has lower precedence than || ?
16:54:49 <lispy> > undefined || True
16:54:50 <lambdabot> Undefined
16:55:30 <lispy> > False && undefined
16:55:31 <lambdabot> False
16:55:55 <eivuokko> MarcWeber, my guess is that you have for some reason lost "inherited" ACL for your directory.  As for how to fix that..you need to open security tab and take advanced-dialog there and check a box, it might help.
16:55:55 <lispy> > (False && undefined) || True
16:55:56 <lambdabot> True
16:56:06 <lispy> > False && (undefined || True)
16:56:07 <lambdabot> False
16:56:37 <lispy> kevind: according to that, && would have higher precedence
16:56:55 <lispy> > True || (False && undefined)
16:56:56 <lambdabot> True
16:59:08 <lispy> > True || undefined && False
16:59:09 <lambdabot> True
16:59:23 <lispy> hmm...so they have the same precedence?
17:00:11 <MarcWeber> eivuokko: Have you seen the link I've pasted? It stats that you cannot view this property...!
17:00:17 <MarcWeber> without using attrib
17:00:35 <eivuokko> MarcWeber, the link says it can't be done using "General" tab.
17:01:12 <eivuokko> And indeed, it is very stupid the flag is there anyway, because it makes no sense with ACLs.
17:01:16 <MarcWeber> Why the hell is it shown then??
17:01:43 <eivuokko> I have no answer to that.
17:01:51 <MarcWeber> Let's stop that discussion. Because that is not my problem. I can write to that directory.. How it's shown I do not mind.
17:05:54 <eivuokko> Hmh
17:08:20 <eivuokko> Do not feel need to answer, but FYI: Writable flag doesn't control if you can write to files in a directory, I think, but that you can delete, rename etc the file.  There is another (set of) permission for files and directories inside a directory.
17:19:48 <MarcWeber> eivuokko:  You might be right. Doesn't solve my problem. ;)
17:49:22 <vincenz> > True > False
17:49:24 <lambdabot> True
17:49:49 <jethr0_> vincenz: i'd say, using that knowledge could be considered evil :)
17:49:56 <vincenz> hmm
17:49:58 <vincenz> anywayss
17:50:05 <vincenz> people on ##C++ are useless
17:50:14 <vincenz> anyonoe here have some typing knowhow of c++ references?
17:50:28 <vincenz> http://rafb.net/paste/results/bP5DSw61.html
17:50:28 <jethr0_> like what?
17:50:31 <vincenz> I wonder if this is correct or not
17:50:58 <jethr0_> you mean concerning const-correctness?
17:51:03 <vincenz> well that
17:51:06 <vincenz> and concerning ref-correctness
17:51:10 <vincenz> you can't store a nonref in a ref
17:51:46 <vincenz> only the const for TDefine is incorrect
17:51:49 <vincenz> it should be >=
17:52:12 <jethr0_> looks ok at first glance. but no idea whether it's complete
17:52:14 <vincenz> I need to reexpress
17:52:19 <vincenz> http://rafb.net/paste/results/bP5DSw61.html
17:52:21 <vincenz> whoops
17:52:27 <vincenz> (isConst lhs == (isConst . getType $ rhs))
17:52:32 <vincenz> so that I can store nonconst (rhs) in const
17:52:33 <vincenz> lhs
17:52:44 <jethr0_> yup
17:52:58 <vincenz> so I figured >=
17:53:07 <vincenz> aha
17:53:17 <vincenz> ic lhs || not ic rhs
17:55:01 <vincenz> damn it
17:55:06 <vincenz> people on ##C++ are serious trolls
17:55:52 <vincenz> > [(x,y,z) | x <- [True, False], y <- [True, False], z = x || (not y)]
17:55:53 <lambdabot>  parse error on input `='
17:55:57 <vincenz> > [(x,y,z) | x <- [True, False], y <- [True, False], z <- x || (not y)]
17:55:59 <lambdabot> Couldn't match `Bool' against `[a]'
17:56:00 <vincenz> hmm
17:56:07 <vincenz> > [(x,y,z) | x <- [True, False], y <- [True, False], z = (x || (not y))]
17:56:08 <lambdabot>  parse error on input `='
17:56:16 <vincenz> suggestions?
17:56:25 <jethr0_> "z =" ??
17:56:35 <dons> 'let'
17:56:47 <jethr0_> "z ==" ?
17:57:13 <dons> > [ (x,y,z) | x <- [True, False], y <- [True, False], let z = x || not y ]
17:57:14 <lambdabot> [(True,True,True),(True,False,True),(False,True,False),(False,False,True)]
17:57:18 <dons> do you mean?
17:57:22 <vincenz> PlasmaHH> vincenz: how should we know what those rules mean ?
17:57:28 <dons> hehehe
17:57:32 <vincenz> that's the response I get from ##C++
17:57:35 <vincenz> I mean come ON!
17:57:37 <vincenz> look at that page
17:57:40 <vincenz> it looks nearly like engliish
17:57:56 <vincenz> < PlasmaHH> haskell == plain english ??
17:58:00 <vincenz> anyways
17:58:03 <vincenz> I think they look fiine
17:58:07 <vincenz> except for the const modification
17:58:08 <dons> @remember ##C++ [asking about C++ rules] vincenz: how should we know what those rules mean ?
17:58:19 <vincenz> LOL
17:58:23 <jethr0_> i'm not sure how many on that channel know about lhs and rhs...
17:58:36 <dons> @remember ##C++  haskell == plain english ??
17:58:36 <vincenz> jethr0_: that should be the basis
17:58:38 <vincenz> at first they told me
17:58:50 <vincenz> "I typically let the compiler do that"
17:58:52 <vincenz> so I explained ..
17:58:58 <vincenz> "You're writing a C++ compiler in haskel??"
17:59:30 <dons> plain english, that's just so funny
17:59:58 <vincenz> dons: have you looked at the page?
18:00:09 <dons> you know you got the syntax right, when newboes think it's plain english :)
18:00:23 <vincenz> LOL
18:00:24 <dons> nah, I tend to run far from C++
18:00:28 <vincenz> 02:58 < vincenz> Eelis: for plain data
18:00:28 <vincenz> 02:58 < Eelis> what's that?
18:00:28 <vincenz> 02:58 < vincenz> pod
18:00:28 <vincenz> 02:58 < Eelis> ah
18:00:39 <vincenz> pod = plain old data
18:00:46 <vincenz> honestly
18:00:48 <vincenz> there's a bot there
18:00:58 <vincenz> and for some humorous reason it only remembers one of my lines that Ichatted there
18:01:03 <vincenz> "This channel is degrading by the moment"
18:01:33 <vincenz> > [ (x,y,z) | x <- [True, False], y <- [True, False], let z = x || not y]
18:01:35 <lambdabot> [(True,True,True),(True,False,True),(False,True,False),(False,False,True)]
18:01:49 <vincenz> perfect
18:02:03 <vincenz> sorry about the spam 
18:02:23 <MarcWeber> eivuokko, Lemmih If you want to help me once again try executing this: http://www.rafb.net/paste/results/5etBFO15.html
18:02:29 * liyang takes a peek in ##C++
18:03:12 <Lemmih> HIDE is scaring me. I "fixed" an 'EVACUATED object entered!'-panic by forcing a GC before running GHC's typechecker.
18:03:15 <vincenz> anyways... I might add templates later
18:03:17 <vincenz> so I might add unification
18:03:26 <vincenz> just not sure how easy that will go with the current assertion-based code :/
18:04:05 <dons> Lemmih.... hmmm. stress test ghc, why don't you ;)
18:05:25 <vincenz> Gotta love c++
18:05:27 <vincenz> < Eelis> vincenz: whether it is illegal depends on context
18:05:37 <vincenz> it was a simple question
18:05:42 <vincenz> is int & x; (no definition) illegal
18:06:23 <dons> vincenz, if they don't know what haskell is, point them to the shootout, and tell them that it's this language that is  faster, more concise, more expressive and has less bugs than C++...
18:06:33 <vincenz> dons: nah, they'll just troll
18:07:10 <dons> oh, good point.
18:07:21 * dons always wants to wage war
18:08:25 <Dreadshoot> vincenz: a referencevariable must be initiated when declared
18:08:28 <jethr0_> > (1.0 + (11.0-1.0) * (5.0/8.0))
18:08:30 <lambdabot> 7.25
18:08:31 <vincenz> Dreadshoot: yeah
18:09:08 <MarcWeber> Lemmih: , eivuokko Oh I removed a file accidently
18:11:48 <Dreadshoot> int & x = y; would do the same as int * const n = y;
18:12:01 <vincenz> woot
18:12:02 <vincenz> it compiles
18:12:05 <vincenz> time to do some test cases
18:12:32 <Dreadshoot> a c++ compiler? :)
18:12:46 <vincenz> nah
18:12:48 <vincenz> c--++
18:13:00 <Dreadshoot> ah well, at least something
18:13:41 <Dreadshoot> myself im trying haskell a little, have hardly used it
18:13:58 <liyang> Does this have to compile existing code?
18:13:59 <vincenz> :)
18:14:40 <kevind> c--++?
18:14:58 <kevind> is that the same as c?
18:15:02 <liyang> I mean, if it doesn't, then make up your own rules. :)
18:15:12 * qwr wouldn't have thought it, but int &x; seems to be legal code as a c++ class field
18:15:56 <vincenz> qwr: I'm not doing classes
18:16:44 <Dreadshoot> qwr: can you even assign a value to it?
18:16:55 <Dreadshoot> or another variable that is
18:17:34 <qwr> Dreadshoot: you can assign value by constructor initializer
18:18:33 <vincenz> good thing I made tests
18:18:35 <vincenz> just found a bug
18:18:45 * jaredj cheers for tests
18:18:56 <vincenz> :)
18:19:05 <vincenz> this code could use some serious cleaning :/
18:19:18 <Dreadshoot> well it can ofc change the value, but can it be assigned to another variable?
18:19:30 <vincenz> no
18:19:45 <dons> vincenz, so you've written a C-ish compiler in waht, 3 days? Cool -- good ad for Haskell :)
18:19:50 <vincenz> thx
18:20:04 <vincenz> with being a complete newb at : alex ... happy
18:20:14 <dons> nice way to learn, as well.
18:20:17 <vincenz> true :)
18:20:19 <jaredj> whoa
18:20:23 <vincenz> it's not a choioce tho
18:20:25 <vincenz> it's a must
18:20:26 <vincenz> for my research
18:20:31 <jaredj> can i see it?
18:20:35 <vincenz> And I did have lexer and parser rules lying around
18:20:37 <vincenz> jaredj: it's not real c
18:20:39 <vincenz> it's some pseudo c
18:21:09 <jaredj> whatever, that's cool
18:21:11 <vincenz> I don't have pointers, I don't allow statements in exps, I don't allow casts, I have a reduced type-set, no typedef, and an added type "ddt" with primitive operations like "insert, remove, clear, append"
18:21:25 <dons> I remember when I studies Adv. Compilers early in my PhD, the lecturer wouldn't let me write my compiler in Haskell, as it "wouldn't be fair to the other students" writing theirs in C++
18:21:33 <vincenz> hehe
18:21:56 <dons> even though I promised to implement twice as many optimisations. he feared the power of the  lambda :)
18:22:04 * vincenz thinks that || should have lower fixity than $
18:22:55 <lispy> dons: we had a prof make everyone one use C for a graph theory class
18:23:16 <lispy> not even C++ but just plain C.  he said a similar thing about haskell
18:23:20 <jaredj> ow
18:23:40 <dons> jaredj, it's similar to pugs. they had the first Perl6 interpreter up and running in about 3 days.
18:23:43 <jaredj> well - not ow. feh.
18:24:01 <dons> (it's written in haskell)
18:24:05 <jaredj> quite so
18:24:07 <vincenz> \o/
18:24:10 <vincenz> all definition tests work
18:28:19 <Dreadshoot> if you use ghc for example: Prelude> 2 + sqrt 2 can you output this to a file?
18:29:08 <dons> yep. hPrint, iirc.
18:29:14 <dons> or hPutStr
18:29:25 <Dreadshoot> ok
18:29:56 <Dreadshoot> going to do a workaround until i get hs-plugins to work in win ;)
18:30:39 <dons> oh, you want to output the expression? not the evaluated result?
18:31:02 <Dreadshoot> naah, its the result i want
18:31:40 <dons> import System.IO
18:31:40 <dons> main = do
18:31:40 <dons>     h <- openFile "/tmp/f" WriteMode
18:31:40 <dons>     hPutStrLn h . show $ 2 + sqrt 2
18:31:41 <dons>     hClose h
18:31:49 <dons> paprika$ cat f
18:31:49 <dons> 3.414213562373095
18:31:50 <dons> :)
18:32:11 <vincenz> \o/
18:32:23 <Dreadshoot> ah :)
18:33:16 <Dreadshoot> how is an expression evaluated if you run it at the compiler without having it in a file with main and so on. Still compiled in some temporary way?
18:33:43 <dons> run it at the compiler? like in ghci? 
18:34:20 <Dreadshoot> http://www.isi.edu/~hdaume/htut/tutorial.pdf at page 24 here
18:34:23 <dons> in ghci, it is run in a bytecode interpreter (combined with native-code libraries). with ghc, it's compiled to native code objects
18:34:56 <Dreadshoot> okay
18:35:10 <dons> so, just like gcc: ghc -c A.hs will create a linkable chunk of native code.
18:36:57 <Dreadshoot> btw is that a good tutorial or are there any better?
18:38:56 <rasterfar> I have a question about "reserved" in Parsec ... anyone used makeTokenParser?
18:39:35 <dons> @learn <-- some other well-regarded tuts are here
18:39:36 <lambdabot> http://www.haskell.org/learning.html
18:40:26 <dons> YAHT (hdaume's one) is one of the best.
18:40:40 <dons> also, you can ask here :) we love answering questions and hacking up code
18:41:00 <vincenz> anyone care to look through my code for some cleaning or suggestions?
18:41:16 <vincenz> specificially the portion that's not lexer or parser
18:41:48 <dons> vincenz, ok, you got me. got a link?
18:41:59 <vincenz> yip
18:42:01 <vincenz> got a darcs repo
18:42:09 * vincenz hmms
18:42:13 <vincenz> I should prolly add a license file
18:42:29 <rasterfar> There appears to be a typo in the parsec manual, which I think is trivial -- but the example also gives me type errors...
18:42:36 <vincenz> anyone know a nice template for a license?
18:42:54 <ncalexan> On the haskell wiki, there's CaleGibbard/BSDLicense.
18:43:01 <ncalexan> If you're into BSD.
18:43:04 <vincenz> more like a proprietary license
18:43:13 <ncalexan> No idea, IANAL.
18:43:20 <vincenz> something simple
18:43:25 <vincenz> "This is property of Christophe Poucet and IMEC
18:43:32 <lispy> is GPL proprietary enough?
18:43:37 <vincenz> I doubt it
18:43:55 <vincenz> well the analysis phase, which is innovative, isn't in my repo yet
18:43:58 <vincenz> so I guess I could show it
18:44:01 <vincenz> ok, GPL will do for now
18:45:27 <rasterfar> If search for "reservedOpNames" in the http://www.cs.uu.nl/~daan/download/parsec/parsec.html ... the first few places ... shouldn't there be a closing parenth?
18:45:41 * vincenz goes for BSD
18:47:10 <vincenz> what's the license where modifs should be sent to me?
18:47:35 <rasterfar> The "receipts" example won't work for me ... get Couldn't match `TokenParser st' against `[Char]' error.  Anyone worked through this?
18:47:38 <jaredj> neither gpl nor bsd requires modifications be sent to you
18:47:46 <vincenz> OT : what's the diff between GPL and BSD?
18:48:02 <rasterfar> BSD allows you to profit
18:48:11 <vincenz> so GPL > BSD > LGPL
18:48:14 <jethr0_> rasterfar: you can profit with gpl too
18:48:17 <liyang> GPL allows you to profit too. :)
18:48:26 <jaredj> gpl: downstream modifications must be gpl-licensed and source available
18:48:28 <jethr0_> no, i'd say LGPL > BSD
18:48:35 <vincenz> really?
18:48:51 <jaredj> bsd: do what you like, but (maybe) credit me, and certainly don't sue me
18:49:12 <jaredj> (used to require that a notice be shown, doesn't anymore)
18:49:44 <jethr0_> bsd = copyright notice and license must be kept. everything else is allowed 
18:49:50 <vincenz> how about the bit that the company who made the original can't be used to endorse like BSD?
18:49:55 <vincenz> is that in GPL?
18:50:20 <jaredj> uh... ! it isn't is it?
18:51:02 <vincenz> safest bet = GPL?
18:51:25 <ncalexan> Well, if you're worried about licensing, GPL is probably the worst for you.
18:51:27 <jethr0_> depends on your beliefs :)
18:51:47 <vincenz> suggestions
18:51:47 <vincenz> ?
18:51:48 <ncalexan> You're talking about proprietary ideas.  GPL is not the place if you want to protect them in a traditional intellectual property protection sense.
18:51:49 <jethr0_> gpl is intended to be restrictive
18:51:56 <jethr0_> bsd is intended to be non-restrictive
18:52:09 <vincenz> thx
18:52:13 <ncalexan> If you just want to keep others from profiting in obvious 'idea-stealing' ways, GPL is the place to be.
18:52:36 <ncalexan> I think the OSI has a good review of licenses:
18:53:11 <ncalexan> http://www.opensource.org/licenses/
18:53:47 <vincenz> ok, dons, ready
18:54:55 <vincenz> http://abstractoasis.dyndns.org:8080/repos/modelparser
18:55:34 <vincenz> as soon as I start to add analyses that are relevant to my phd, I'll have to take it offline... *is doing his phd at a research company, and doesn't want to get in trouble over patents"
18:56:21 <vincenz> if you don't care about lexing/parsing, then the relevant files are: AST, Scoper, Typer
18:57:37 * vincenz continues to add tests for his typer
19:14:53 <Philippa> vincenz: don't get me wrong, but how sure are you the analysis is innovative? There's a lot out there that's been tried
19:15:06 <vincenz> Philippa: pretty
19:15:12 <Philippa> also, copyright isn't really a sufficient defence against idea-stealing
19:15:14 <vincenz> I've done the necessary background research
19:15:27 <vincenz> Philippa: the innovative ideas aren't in the code yet
19:15:29 <Philippa> (and IMO, software patents are pretty evil things on the whole)
19:15:38 <vincenz> not my choice
19:16:33 <Philippa> 'k. "Copyright <owners> <date>, all rights reserved" is a good default license if you don't wish to let people do things with the code
19:16:48 <vincenz> :)
19:17:04 <Philippa> if you wish to allow more, include a list of things you'll allow before the "all rights" clause and make it "all other rights reserved"
19:18:38 <Philippa> more realistically, if you're working for someone else they should be able to provide you a default license (or tell you off for releasing the code at all, of course)
19:21:39 <vincenz> I should prolly write a test-generator
19:21:43 <vincenz> this is an inane amount of work
19:22:26 <Philippa> QuickCheck
19:22:31 <lispy> there are algorithms for generating random sentences given a grammar, perhaps that's what you need?
19:23:13 <dons> try QuickCheck, it generates test for you ;)
19:24:11 <vincenz> yeah
19:24:21 <vincenz> but rather difficultiliy
19:26:39 <Philippa> are we allowed to know anything about what your analysis does, btw?
19:29:40 <vincenz> not sure
19:31:01 * jaredj doesn't ask
19:31:55 * lispy still hasn't figured out when/how something qualifies for being "innovative"
19:32:19 <Philippa> lispy: "hasn't been tried or suggested before"
19:32:51 <lispy> oh, so research contribution == innovatitive, eg. "useful" or "worthwhile" are not part of the definition
19:33:16 <vincenz> well given that I'm in a company, it must be more useful, hence me working with c++(--)
19:33:50 <Philippa> lispy: indeed, you may well find a particularly innovative way of achieving nothing whatsoever
19:33:59 <lispy> so it's not just innovative, it is useful also?
19:34:29 <lispy> Philippa: yeah, that was very disappointing to find out about research
19:35:26 <lispy> man, i need to hire a cleaner just to get my desk organized...geez...how did it get like this :)
19:35:37 <Philippa> sometimes negative results have some value
19:35:43 <vincenz> yes
19:35:50 <vincenz> especially towards industrial conferences
19:35:51 <Philippa> like if you can succesfully prove an entire class of attack is useless
19:35:54 <vincenz> it's liike "don't try this"
19:36:18 <vincenz> anyone have any suggestions on how to clean up my typer or scoper
19:36:20 <lispy> Philippa: i'm all for showing that something isn't a good idea or doesn't work.  But I find a lot of research that really doesn't find or say anything and get's published anyway.
19:36:36 <vincenz> lispy: I know plenty of those papers
19:36:48 <vincenz> or "copy, paste, alter number, publish"
19:36:59 <Philippa> I find a lot that seems to because I don't understand the maths well enough. Then again, I seem to mostly get the papers that've been through everybody else's BS filter
19:37:08 <Philippa> any I'm likely to've read you think of that way?
19:37:22 <vincenz> anyone else happen to look at the code?
19:37:40 <lispy> Philippa: go look at the CHI proceedings some time
19:38:12 <vincenz> next thing to do... control-flow analysis
19:38:13 * vincenz mutters
19:38:22 <dons>   /win 11
19:38:25 <lispy> vincenz: not I, but I doubt I'd have any insight.  I'm still too new to haskell.
19:38:35 <vincenz> lispy: I started coding haskell just a few weeks ago
19:38:44 <vincenz> 3 weeks
19:38:56 <Philippa> lispy: ah. The last I read around the field was a while back, but I can see how it'd be a lot more susceptible to it
19:39:03 <lispy> vincenz: you've used monad transforms and i've yet to employ them :)
19:39:36 <vincenz> lispy: with lots of input and help from Cale :)
19:39:47 <Philippa> it's too late for me to be helpful, I suspect
19:39:50 <Philippa> and I should be in bed by now
19:40:21 <lispy> i've been trying to look at the MonadRandom code Cale posted on the wiki and i keep getting caught up in not understanding what it will do.  "deriving (Function, IOMonad,...)" really throws me off
19:40:30 <Speck> @hoogle a -> b
19:40:31 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
19:40:31 <lambdabot> Prelude.id :: a -> a
19:40:31 <lambdabot> Prelude.undefined :: a
19:40:56 <lispy> er not Function, but Functor
19:41:15 <lispy> i had no idea you could derive that or how it is derived
19:45:01 <Speck> I can't think of what (***) does... conceptually I guess
19:45:32 <Speck> parallel?
19:47:41 <bd_> @hoogle catchError
19:47:42 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) ->
19:47:42 <lambdabot> m a
19:47:47 <bd_> @hoogle catch
19:47:48 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
19:47:48 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
19:47:48 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
19:54:31 <dons> I actually found a nice use of ***: map (c2w *** c2w) [('A','T'),('C','G'),('B','V'),('D','H'),('K','M') ...
19:55:27 <dons> nice pointfree way to do things to tuples without fst/snd
19:55:52 <jaredj> er 
19:56:15 <jaredj> blargh arrows!
19:56:21 <jaredj> haskell make me feel dumb
20:00:12 <kevind> yep, *** is cool
20:00:36 <dons> @type (Control.Arrow.***)
20:00:37 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
20:00:37 <lambdabot> (Control.Arrow.Arrow a) =>
20:00:37 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
20:00:41 <dons> > map (toUpper *** toLower) [('a','B'), ('c','D')]
20:00:43 <lambdabot> [('A','b'),('C','d')]
20:04:56 <dons> > map (toUpper &&& toLower) ['a'..'i'] -- arrows are fun
20:04:58 <lambdabot> [('A','a'),('B','b'),('C','c'),('D','d'),('E','e'),('F','f'),('G','g'),('
20:04:58 <lambdabot> H','h'),('I','i')]
20:08:39 <vincenz> why won't this not work
20:08:41 <vincenz> instance (Pretty b, IsAst a b) => Pretty a where
20:09:16 <vincenz> class IsAst a b | a -> b where
20:23:53 <Speck> does anyone have an example of a GADT+Arrow parsing library? Or a pretty printing library?
20:24:28 <Speck> or really GADT+Arrow anything except the Yampa optimizations -- which I'm familiar with.
21:23:47 <ncalexan> @hoogle MaybeT
21:23:47 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
21:23:55 <ncalexan> @index MaybeT
21:23:56 <lambdabot> bzzt
21:29:38 * vincenz does some major cleaning on his code
21:36:04 <JKnecht> hmmm, none of the Xeon MP motherboards seem to have 1Ghz FSBs
21:42:47 * jaredj amd ooga
21:46:41 <JKnecht> now I see why: none of the Xeon MP has FSB > 666 Mhz
21:52:07 <JKnecht> "ooga" not returning anything at the AMD site, I take it to be an exclamation. They also don't seem to have anything competetive with Xeon MP.
21:58:55 <Cale> lispy: You can derive arbitrary classes with newtype if they're implemented for the base types.
22:41:17 <bd_> @hoogle evalState
22:41:18 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
22:41:18 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m
22:41:18 <lambdabot> a
22:54:10 <Lemmih> SamB: ping.
23:14:06 <gFunk> Given: foldM' f a (x:xs) = f a x >>= \fax -> foldM' f fax xs
23:14:19 <gFunk> how do i make "f a x" evaluate strictly?
23:15:46 <Lemmih> You don't.
23:16:26 <Lemmih> Didn't you find out that the fold wasn't the problem?
23:17:32 <gFunk> well there was more than one problem
23:17:47 <gFunk> actually, there were quite a few
23:18:06 <Lemmih> And profiling said the fold was to blame?
23:18:11 <gFunk> strictly evaluating the accumulator in the fold fixed the heap problem
23:18:26 <gFunk> but then i had a stack overflow
23:18:46 <gFunk> and i found that as soon as i change the state in the state monad, the stack blows
23:19:02 <gFunk> if i don't modify state, everything works really well
23:19:35 <Lemmih> Make the state strict, then.
23:19:37 <gFunk> makes me consider strictly evaluating the state inside the state monad after each iteration of the fold
23:20:01 <gFunk> k
23:21:42 <gFunk> something like: Double -> (Int,Double,Double) -> State !Double Double
23:21:44 <gFunk> ?
23:21:59 <gFunk> do i need to create a 'data'?
23:23:10 <Lemmih> That shouldn't be necessary.
23:23:30 <gFunk> putting the bang in front of the Double doesn't compile
23:23:31 <Lemmih> Just make sure that you update the State with strict values.
23:24:25 <gFunk> hmm, i tried that:
23:24:25 <gFunk> do{ st <- get; put $! st + x; return z}
23:25:18 <bd_> @hoogle seq
23:25:19 <lambdabot> Control.Parallel.seq :: a -> b -> b
23:25:19 <lambdabot> Prelude.seq :: a -> b -> b
23:25:19 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
23:26:11 <Lemmih> gFunk: That doesn't force anything.
23:26:35 <gFunk> is there a difference between 'seq' and $! ?
23:27:05 <Lemmih> f $! x = x `seq` f x
23:29:33 <gFunk> how to i 'force' anything?
23:30:13 <Lemmih> Hm, $! should've worked actually.
23:31:19 <Lemmih> Got the code online?
23:31:35 <gFunk> well, i think i need to strictly evaluate the 'put' call, not the parameter to it
23:31:44 <gFunk> hold on, lemme clean it up really quick
23:33:27 <gFunk> http://pastebin.com/550787
23:33:57 <gFunk> function 'alg' is the one that uses state
23:34:25 <gFunk> commenting out "put $ st + bid", neither the stack or heap grows
23:39:30 <Lemmih> hm
23:42:34 <gFunk> feels like using a monad kinda screws with the attempt to do tail-end recursion
23:43:00 <gFunk> maybe just returning a new state, and the return value in one call might fix it
23:43:02 <gFunk> but how?
23:44:10 <gFunk> is it possible to pattern match the monad?
23:47:44 <Lemmih> Are you using GHCi, btw?
23:49:14 <gFunk>  nope, ghc -O2
23:54:17 <Lemmih> Resorting to a strict State monad would be the easiest fix, I think.
23:56:14 <gFunk> how do i do it?
23:57:17 <Lemmih> newtype State' s a = State' {runState' :: (s -> (a,s))}
23:57:18 <Lemmih> instance Monad (State' s) where
23:57:18 <Lemmih>     State' f >>= fn = State' $ \s -> let (a,s') = f s in s' `seq` runState' (fn a) s'
23:57:20 <Lemmih>     return a = State' $ \s -> (a,s)
23:57:21 <gFunk> odd, this doesn't even work:
23:57:21 <gFunk> simOnQuote f (algZ,simZ) x = (runState $! (f algZ x)) simZ
23:57:21 <gFunk> sim f z money lst = foldl' (simOnQuote f) (z,money) lst
23:57:22 <Lemmih> instance MonadState s (State' s) where
23:57:25 <Lemmih>     get = State' (\s -> (s,s))
23:57:28 <Lemmih>     put s = s `seq` State' (\s' -> ((),s))
