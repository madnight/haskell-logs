02:22:27 <tromp_> quiet here:(
02:28:30 <dblhelix> tromp: it's been a while since I had a day that I could spend on research entirely, so I probably should not waste it on irc ;)
02:30:51 <tromp_> on what research will you spend it?
02:31:24 * shapr sings
02:31:33 <shapr> bok gour 
02:31:34 <dblhelix> tromp_:  program analysis... binding-time analysis at the moment, to be more specific
02:31:57 <dblhelix> glad to see that you're in good spirit, shapr... keep on singing :)
02:32:58 <shapr> dblhelix: Glad to hear you're doing research... that always gets me into a good spirit :-)
02:33:55 <dblhelix> shapr: well, education takes a lot of time too, these days... spreading the joy to 100+ novice functional programmers ;)
02:34:07 <gour> shapr: bok, the Scribes dev (the one i was 'preaching to' ) has become interested for haskell (reading yaht), but he keeps saying that he does not plan to use it for general production. i know you'd like to use haskell for general production, so i'm interested if you can throw some particles of wisdom on my head?
02:34:51 <dblhelix> mmm... "you found an ancient scroll of wisdom"
02:41:40 <shapr> gour: I'd start with Hughes' "Why Functional Programming Matters"
02:42:39 <gour> shapr: i already gave him such references, i'm thinking about something on the level python <---> haskell
02:42:53 <gour> shapr: i.e. why would someone jump from python to haskell?
02:44:05 <rep> because it's superior :)
02:46:44 <gour> rep: but for one who does not use it, he cannot realize it. i.e. i'm looking for some 'selling points' 
02:46:55 <dons> gour, it's faster and more concise :) as well as having less bugs and being more expressive
02:47:50 <tromp_> it's more fun!
02:53:43 <gour> dons: what do you mean by 'having less bugs'?
02:54:09 <gour> dons: otoh, many people are considering functional languages restrictive, ie. less expressive
02:55:28 <pejo> gour, a friend who knows perl found that Python was a lot worse at telling when there were errors in the code during compile time, compared to perl. 
02:56:09 <pejo> My experience is that usually when you get things through the compiler things will 'just work', in Haskell. 
02:56:32 <pejo> Not statistically significant, but still a small observation from the side. 
03:03:17 <shapr> gour: When I work on Zope, and when I worked on J2EE, one big problem was that I never knew when a variable would vary. I couldn't count on things staying the same.
03:03:22 <shapr> That's not a problem in Haskell.
03:04:12 <shapr> Partial application / closures give you something that works much like an instance, and can't change when you're not looking.
03:06:15 <shapr> gour: I'm pretty sure that monads are a more expressive abstraction than objects for less brain cost. (And I think I can give real numbers for that too.)
03:06:49 <gour> shapr: this monad argument is an appealing one..
03:06:56 <aleator> shapr: What kinds of monads do see use in your code?
03:07:32 <shapr> Well, lots... that's sort of like asking what sort of objects you use :-)
03:08:22 <aleator> shapr: Thats what I'm missing. Besides from standard ones I rarely find any need new monads.
03:09:08 <shapr> gour: I've been looking at the paper "Are ours really smaller than theirs?" and I'm nearly positive the metrics it uses will say that monads are more expressive that objects.
03:09:13 * gour does not use even the standard monads (yet)
03:09:47 <shapr> On the other hand, monads are not limited to Haskell or purely functional languages, so I suspect they'll be commonly used in imperative languages in a few years.
03:10:12 <shapr> I'd guess that Perl6 will have a big headstart there.
03:10:19 <dons> gour, http://haskell.org/haskellwiki/Why_Haskell_Matters
03:10:28 <shapr> aleator: Have you studied monad transformers yet?
03:11:02 * gour found Are ours ...paper
03:11:18 <aleator> Oh yes. I've even used continuation-state-error-writer (Perhaps not in that order). But that was very very specific case.
03:11:24 <gour> dons: i already submitted that one. thanks
03:11:45 <aleator> Now, the most advanced In-production-code monad is state monad holding random number generator :/
03:13:11 <shapr> Do you use the Maybe/Either/Error monad(s)?
03:14:46 <aleator> shapr: No.. I tried to. I had a simple search algorithm that would have seemed reasonable to "fail" when search stops going anywhere. But then I figured that I must put everything in such monad and it no longer made sense.
03:15:27 * gour throws arguments in #sandbox
03:16:23 <shapr> I'd try to make a clear single function for the search algorithm, and wrap the failure and flow control code around that.
03:16:51 <shapr> Of course, I doubt that helps much...
03:18:29 <shapr> gour: Anyway, I'm truly interested in answering the question "Is Haskell really better for production code?" and all the evidence and experience I've gotten says that Haskell only needs libraries and bug finding.
03:19:31 <gour> shapr: his argument is "All I care about is producing applications very quickly with minimal fuss"
03:20:00 <shapr> phone, brb
03:26:37 <dons> gour, perhaps point to the ICFP contest: producing lots of code, fast with no fuss. Haskell wins.
03:29:41 * dcoutts_ grins
03:30:03 <gour> dons: that's very good one. thank you.
03:30:54 * dcoutts_ should really publish the ICFP04 GUI he made
03:31:40 <dcoutts_> dons, heh, the ICFP04 simulator should be a shootout program
03:31:58 * dcoutts_ has one that is already optimised :-)
03:32:50 <gour> dcoutts_: i must say: nice exchange with axel
03:32:57 * gour grins
03:33:01 <dcoutts_> gour, yeah
03:34:06 <gour> dcoutts_: i'm just not sure whether the rules say something about kicks under the belt :-)
03:36:14 <shapr> gour: One concept I've thought up recently is "abstractional complexity" or 'how many pieces of an abstraction are involved when changing a program?'
03:36:48 <shapr> I think that monad transformers have a lower abstractional complexity than objects.
03:37:16 <shapr> Though I guess they could be compared to multiple inheritance...
03:37:18 * shapr considers that...
03:37:22 <gour> shapr: it looks some people are just satisfied to put something together thinking "it works", but later usually re-write everything from the scratch
03:38:39 <shapr> They have a point...
03:38:48 <shapr> Do you know Worse is Better?
03:39:33 <shapr> The next question is, can Haskell be better than Python at just making something work?
03:39:36 <shapr> I think it can :-)
03:39:39 <shapr> I think it already is...
03:40:21 <shapr> Haskell needs libraries most of all.
03:40:41 <shapr> I first used Python 1.4, and it was not as productive as Haskell is now, because there weren't many libraries.
03:44:28 <JohnMeacham> yay! jhc now offially supports rank-n types :)
03:44:38 <JohnMeacham> officially. I should say.
03:44:49 <JohnMeacham> in that I tested it and said so in the darcs changelog.
03:46:34 <shapr> gour: I firmly believe that Haskell would obviously kick Python's butt if it had all the same libraries.
03:48:25 <dblhelix> JohnMeacham: are you planning to include full impredicativity any time soon?
03:48:41 <neologism> shapr: most people dont understand functional programming so I doubt that
03:49:39 <dcoutts_> JohnMeacham, you'll tell me when jhc is ready for packaging for ditros, right? How well are ordinary progs working atm?
03:51:20 <dcoutts_> eg, when can we add jhc to the great language/compiler shootout? :-)
03:56:22 <shapr> neologism: OOP had the same problem in the beginning, then people wrote Design Patterns books and lots more.
03:56:37 <shapr> neologism: So maybe we just need to write the libs and publish the books...
03:58:45 <neologism> shapr: oop is quite trivial compared to functional programming
03:58:57 <neologism> I see it on my classmates
03:59:04 <neologism> they jsut "learn C" and they think its all done
03:59:09 <neologism> and now they are programmers
03:59:15 <JohnMeacham> dblhelix: it already works :)
03:59:31 <dblhelix> JohnMeacham: great!
04:00:07 <JohnMeacham> dblhelix: but the back end chokes on some of the impredicative stuff. but that is mainly turning off some type checks for things I used to think were illegal :)
04:00:36 <JohnMeacham> dcoutts_: not for a while.
04:00:39 <taw__> hello :)
04:01:13 <JohnMeacham> dcoutts_: I hope to make an LVM back end though, to give it comparable stats to yhc I am guessing in terms of speed of compile and execution.
04:02:16 <JohnMeacham> nologism: I assume by 'trivial' you mean 'painful' :)
04:02:16 <dcoutts_> JohnMeacham, you couldn't target Yhc's byte code?
04:02:19 <shapr> neologism: I don't think the basic viewpoint of FP is difficult. I do think that the skill of doing 'real programming' with functional, imperative, or logic programming is nontrivial.
04:02:51 <neologism> shapr: yes.. but most people just learn programming as making recipes for cooking
04:03:01 <JohnMeacham> dcoutts_: perhaps. but LVM has a nice spec and a compiler from a nice written form to its bytecode. and a java implementation as well as a C one.
04:03:31 <taw__> uhm
04:03:35 <dcoutts_> JohnMeacham, oh I see. (I'm not really familiar with the LVM.)
04:03:41 <taw__> what are the arrows ? :)
04:03:44 <JohnMeacham> dcoutts_: the main issues are primitive impedence matching. I'll probably have to compile seperate libraries depending on what back end you are targeting. which is anoying.
04:03:53 <dcoutts_> yeah
04:04:03 <shapr> taw__: Do you mean arrows the generalization of monads?
04:04:09 <taw__> shapr: yeah
04:05:02 <JohnMeacham> dcoutts_ it is what helium uses. however, it might not be low level enough, like. I have unboxed types in core I can't really get rid of. they are sort of fundamental in my translation from haskell to core and I am not sure how to translate them to LVM properly.
04:05:10 <shapr> taw__: Roughly, they're first class transformers.
04:05:33 <taw__> shapr: what do you mean by "transformer" ?
04:05:38 <shapr> taw__: I wrote an unfinished introduction http://www.haskell.org/tmrwiki/ArrowsIntroduction
04:06:39 <shapr> taw__: arrows are usually of type 'foo :: Arrow Input Output' where Arrow is the arrow type itself, and the next two are obvious.
04:07:17 * taw__ reading that introduction
04:10:11 <Philippa> <neologism> shapr: yes.. but most people just learn programming as making recipes for cooking <- pro cookbooks use a pseudo-functional style :-)
04:10:36 <dcoutts_> JohnMeacham, so why do you want to add an LVM backend? What's wrong with the ISO C backend?
04:10:39 <neologism> Philippa: I cannot imagine that :)
04:10:53 <Philippa> they use recursion rather than iteration, stuff like that
04:11:19 <neologism> recursion in a recipe?
04:11:49 <shapr> Yeah, definitely.
04:12:03 <neologism> its hard for me to imagine that
04:12:16 <shapr> There was even a thread about that on LtU.
04:12:47 <JohnMeacham> dcoutts_: so people can compile large programs without waiting all day :) I would add some sort of separate compilation as part of the LVM back end.
04:14:19 <dcoutts_> JohnMeacham, ah, so it's not the back end so much as the middle? So you want to test your front end with a middle/back that doesn't do so much whole program stuff.
04:19:11 <JohnMeacham> dcoutts_ yes. exactly. I also think it would make it much more useful to other people who don't want to hack on the back end right away so I can start getting more feedback and contributions.
04:19:39 <dcoutts_> JohnMeacham, right, and it'd flush out the bugs in the front end.
04:22:34 <dcoutts_> JohnMeacham, I think it'd be interesting to do a Haskell type checking using constraint handling/solving rather than traditional unification.
04:23:55 <JohnMeacham> That is what helium does. you can even use pragmas to choose a custom solving order for your function.
04:25:05 <JohnMeacham> My new typechecker pretty much follows the boxy types paper exactly. with typeclass stuff sprinkled throughout.
04:25:12 <dcoutts_> JohnMeacham, have you seen "Generalizing Hindley-Milner Type Inference Algorithms" ?
04:25:30 <shapr> Doesn't Chameleon use CHR?
04:25:32 <JohnMeacham> Yeah.
04:25:36 <dcoutts_> it's a really nice intro to the constraint style of HM and it's extensions
04:25:53 <JohnMeacham> I think it uses them for typeclassses but not inference... but am not sure.
04:26:03 <JohnMeacham> in any case. gotta go for a bit.
04:27:02 <JohnMeacham> another new extension I implemented today: http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantifier
04:30:52 <gour> shapr: i've got (from the other party) the following http://seanmcgrath.blogspot.com/archives/2006_02_12_seanmcgrath_archive.html#113990937907520100 as argument that "that's what the Haskell community should be doing - Writing libraries"
04:31:24 <gour> shapr: ..Not showing off algorithms.
04:39:00 <shapr> That may not be quite so true in the world of Haskell....
04:39:51 <shapr> Another issue I'm investigating is "libraries are a crutch for inexpressive languages."
04:41:03 <shapr> I think there does exist an elegant and simple balance of programming language design that will make writing a new library something that anyone can do. But I don't know if anyone has found that yet.
04:41:25 <shapr> That doesn't help with our original question though...
04:47:10 <shapr> gour: I know I'd like to have all the functionality of Python's libs available to my Haskell programs, however it might become available.
04:48:56 <gour> well, your 'libraries are a crutch..' sounds OK
04:50:11 <viblo> when speaking of libraries, do you know if its possible to use(=compile) hsSDL on windows?
04:56:04 <Lemmih> viblo: It's very problematic.
04:58:18 <viblo> I tried building it (from cygwin), but got some errors: c:\ghc\ghc-6.4\bin\hsc2hs.exe -I/usr/local/include/SDL -Dmain=SDL_main -I/usr/in
04:58:18 <viblo> clude/mingw -DWIN32 -Uunix -mno-cygwin -oGraphics\UI\SDL\General.hs Graphics\UI\
04:58:18 <viblo> SDL\General.hsc
04:58:18 <viblo> unrecognized option `-U'
05:00:42 <viblo> do you think its possible to do at all, or should I give up? :)
05:02:04 * Itkovian wonders is something alike to RoR would be feasible in Haskell
05:08:06 <araujo> Good morning.
05:10:13 <Lemmih> viblo: Might be possible if you're willing to do a bit of work.
05:13:19 <viblo> "a bit"? maybe its easier to use wxhaskell then? I thought about doing a small 2d-game with yampa.
05:14:43 <Lemmih> Probably.
05:16:21 <viblo> oki
05:17:55 <dcoutts_> viblo, or there is gtk2hs & cairo! :-)
05:18:30 <dcoutts_> someone should build a yampa version using cairo
05:22:11 * resiak wonders whether he should take on the building of gtk2hs for Debian
05:22:35 * gour wonders why not
05:23:37 <resiak> (a) relatively inexperienced both with building of haskell things and of Debian things; (b) not a DD; (c) there may well be a good reason why newer ones haven't been built
05:23:51 <gour> dcoutts_: i consider that it would be good (for my future application) to write a 'core lib' with a nice api and then have simple cli app, as well as gui
05:24:25 <dcoutts_> resiak, there is no good reason why newer ones haven't been built - except lack of DD time & interest
05:25:00 <dcoutts_> resiak, in fact someone did build 0.9.9 & 0.9.10 but then he dissapeared and his packages with him.
05:25:01 <gour> resiak: a) is not a problem, i'm not experienced with debianism b) i'm on gentoo - haskell team is very active c) gtk2hs is in constant development
05:25:46 <dcoutts_> @seen marcot
05:25:47 <lambdabot> I saw marcot leaving #haskell 1 month, 18 days, 16 hours, 56 minutes and
05:25:47 <lambdabot> 55 seconds ago, and I have missed 17 days, 22 hours, 22 minutes and 50
05:25:47 <lambdabot> seconds since then.
05:25:48 <resiak> I envy Gentoo for this, and for this alone :-). dcoutts_: Okay, good to know.
05:26:40 <dcoutts_> Haskell support on Gentoo is great :-)
05:27:16 <dcoutts_> disclamer: I am the lead dev in Gentoo's Haskell team :-)
05:27:23 <resiak> I know, and I know :-)
05:28:07 <dcoutts_> resiak, if you can find marcot you might be able to find out what happened to the packages he built.
05:28:24 * resiak puts on his PI hat.
05:33:43 <dcoutts_> heh
05:33:56 <dcoutts_> is that a white, grey or black hat?
05:34:02 <resiak> technicolour
05:34:06 <dcoutts_> ooooh
05:34:16 <resiak> It doubles as my shower cap ;-) *gone*
05:34:28 <dcoutts_> nice
05:35:31 <dcoutts_> resiak, you might also want to check with Igloo or another DD/Haskell person
05:38:09 <resiak> dcoutts_: Will do. By the way, thanks for fixing things so that I can actually compile it with my puny amount of RAM :-)
05:38:37 <dcoutts_> resiak, oh gtk2hs, oh yeah
05:40:02 <dcoutts_> resiak, how much ram do you have btw? was it 128 or 256?
05:40:32 * dcoutts_ is currently trying to get gentoo's ghc ebuild to work for people with 128Mb
05:40:55 <resiak> dcoutts_: 256. I have another box with only 128 which I could install Gentoo on at some point if you reall want :-)
05:41:22 <dcoutts_> ghc's SplitObjs feature makes ar use loads of ram
05:41:54 <dcoutts_> resiak, s'ok, I can just boot with mem=128Mb
05:42:00 <resiak> dcoutts_: Heh, good point.
05:42:24 <dcoutts_> resiak, I was just wondering if you'd ever build ghc from source on your machine
05:42:59 <resiak> I never have done. Never had the need.
05:45:01 <gour> dcoutts_: in that was library can be separately improved/extended and work on gui can be done independently. what do you think?
05:46:07 <Igloo> resiak: AFAIK no-one is working on it now, but you might want to ask on http://urchin.earth.li/mailman/listinfo/debian-haskell JIC
05:47:14 <resiak> Igloo: Already subscribed, I think. Thanks, I'll do that when I decide to get stuck in.
05:52:59 <dcoutts_> gour, I'm not sure what you're asking exactly
05:54:27 <gour> dcoutts_: it is wise to put core engine of the app in a separate lib, and then have clear interface for either cli of gli version of the app?
05:56:58 <gour> s/it is/is it
05:57:21 <gour> s/cli of gli/cli or gli
06:00:51 <Philippa> where sensible, yes
06:01:17 <Philippa> (if there's a sensible 'command language' you can use as an interface or something like that, say)
06:03:29 <gour> Philippa: thanks. i believe it is possible to create a 'language' for the interface, at least experts on the field can say what would be convenient for them
06:27:48 <int-e> @index Array i e -> [(i,e)]
06:27:48 <lambdabot> bzzt
06:27:55 <int-e> @hoogle Array i e -> [(i,e)]
06:27:56 <lambdabot> No matches, try a more general search
06:28:54 <liyang> :t Array.assocs
06:29:00 <liyang> Gah.
06:29:06 <liyang> @t Array.assocs
06:29:07 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
06:29:07 <lambdabot> null topic-snoc topic-tail topic-tell type .
06:29:12 <liyang> @type Array.assocs
06:29:13 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> [(i, e)]
06:32:11 <int-e> thank you
06:32:21 <liyang> Sorry about the spammage. :)
07:03:59 <handB> I want to remove a element from the midle of a list. Help
07:04:54 <tromp_> a++b where (a,_:b) = spliAt i list
07:05:32 <handB> ok.tnx
07:06:20 <tromp_> but it's better if you can rewrite your algorithm to avoid such removals
07:08:38 <handB> ok. I have a list comprehension that creats a list of nine elemnets like a 3x3 matrix and I make it from the center element ( i,j) and makes a list from (i-1) ,( j-1) to (i+1),(j+1) and want to get rid of the (i,j)
07:11:44 <tromp_> [(i+di,j+dj) | di <- [-1..1], dj <- [-1..1], di /= 0 || dj /= 0]
07:11:56 <Itkovian> handB: add i /= j in the comprehension?
07:12:09 <tromp_> or even (di,dj) /= (0,0)
07:12:11 <handB> then it removes the diagonal
07:12:13 <Itkovian> hmm
07:12:14 <Itkovian> yeah
07:12:18 <Itkovian> my brain is clogged
07:12:20 <Itkovian> sorry
07:12:27 <Itkovian> use tromp_ 's example
07:12:31 <handB> ok
07:13:11 <handB> tnx
07:22:15 * shapr has arrived on #haskell, w00!
07:23:05 <Lemmih> Welcome to #haskell, shapr!
07:23:26 <shapr> Hi Lemmih!
07:23:35 <shapr> I heard about this crazy language where the variables don't vary.
07:24:04 <shapr> handB: Do you know anything about this crazy language?
07:24:15 <tromp_> as long as your function function...
07:24:18 <tromp_> as long as your functions function...
07:28:05 <SimonRC> okay...
07:28:13 <palomer> shapr!
07:28:22 <SimonRC> > let f x = 2 * x in f 5 + f 6
07:28:24 <lambdabot> 22
07:28:30 <handB> shapr : no not realy.
07:28:30 <palomer> shapr: I need some music tips
07:28:33 <SimonRC> x isn't always the same, is it?
07:28:44 <SimonRC> so x varies
07:29:02 <SimonRC> Tada!  Variables vary in Haskell too!
07:29:11 <SimonRC> (Just not in as many ways.)
07:29:29 <palomer> well, erm, one could argue that x is a bound variable, so x doesn't vary, and every application uses a different copy of f
07:30:17 <bd_> Obviously, the variable is simply syntactic sugar for f = (2*) ;)
07:36:14 <shapr> palomer: see #haskell-blah
08:24:17 * shapr boings
08:24:42 <_Codex> (->)
08:55:34 <audreyt> @pl concatMap (\(x, y) -> [f x, f y]) xs
08:55:37 <lambdabot> uncurry ((. (return . f)) . (:) . f) =<< xs
09:12:05 <jethr0_> audreyt: wouldn't that maybe work with lifting to list/(e->) monad/
09:12:06 <jethr0_> ?
09:13:32 <audreyt> not sure what you are talking about :)
09:13:57 <dcoutts_> SyntaxNinja, I should have some time tomorrow to hack on cabal/cabal-install/whatever-we're-calling-it
09:22:23 <jethr0_> audreyt: anyways, it wouldn't get any shorter/more readable than your version
09:22:30 <shapr> hiya SyntaxNinja 
09:26:24 <SyntaxNinja> dcoutts_: ok cool.
09:26:26 <SyntaxNinja> hiya shapr
09:29:11 <neologism> a functor is a catamorphism?
09:29:23 <SyntaxNinja> dcoutts: I would be inclined to call it cabal-setup, since it does the same thing as the ./setup script, more or less, but if you have better names?
09:29:43 <dcoutts_> SyntaxNinja, yeah that's ok
09:30:25 <dcoutts_> SyntaxNinja, so I'll add the first version to the cabal repo with that name and darcs send you the patch
09:31:22 <SyntaxNinja> dcoutts_: sounds good!
09:32:27 <dcoutts_> chrisbrown, have you ever thought of porting your syntax directed editor to have a Haskell front end?
09:32:52 <chrisbrown> dcoutts: I havn't done any work on my SDE since graduating!
09:33:00 <dcoutts_> heh, ok :-)
09:33:28 <chrisbrown> unfortunately im not in a position too either - my research is taking over my life!
09:33:32 <chrisbrown> *to
09:33:39 <dcoutts_> tell me about it! :-)
09:33:51 <chrisbrown> dcoutts: are you a PhD student also?
09:34:13 <dcoutts_> chrisbrown, yep and in my spare time I work with Axel Simon on gtk2hs
09:34:20 <dcoutts_> you must know Axel
09:34:21 <chrisbrown> ah cool - I know Axel
09:34:38 <chrisbrown> where are you studying?
09:34:52 <dcoutts_> my supervisior had a structure editor and was asking me about getting some MSc student to port it to gtk2hs as a masters project
09:34:58 <dcoutts_> chrisbrown, ox.ac.uk
09:35:23 <chrisbrown> i used java at the time because my concern was not to write an interface
09:35:50 <dcoutts_> because you know how do to guis in Java or because there was already one written?
09:36:04 <chrisbrown> guis in java is easy - which was why i did it
09:36:09 <dcoutts_> right
09:36:22 * dcoutts_ thinks guis are easier in Haskell these days :-)
09:36:31 <dcoutts_> on button clicked $ do ...
09:36:37 <chrisbrown> and it was more intersting to get haskell to link with java at the time, and it was made more interesting the fact that the back-end called the front end
09:36:43 <dcoutts_> right
09:37:06 <chrisbrown> if i did it again it would be totally different :)
09:37:13 <dcoutts_> I bet
09:37:18 <chrisbrown> i wouldn't write a parser for a start
09:37:28 <chrisbrown> just use a compiler front end
09:37:59 <dcoutts_> I would implemented my undergrad project totally differently if I re-did it now
09:38:13 <chrisbrown> what was it?
09:38:24 <dcoutts_> oh, just a compiler for a little language
09:38:46 <chrisbrown> ah
09:38:59 <dcoutts_> chrisbrown, so HaRE uses a compile front end now right?
09:39:04 <dcoutts_> programatica?
09:39:10 <chrisbrown> pes
09:39:11 <chrisbrown> *yes
09:39:20 <chrisbrown> which means no-eno can actually use it!
09:39:23 <dcoutts_> I heard rumours about the GHC api
09:39:38 <chrisbrown> we tried that - but didn't have time to finish the implementation
09:39:38 <dcoutts_> hIDE is using the GHC api for a few things
09:40:01 <dcoutts_> but HaRE still an active project right
09:40:02 <chrisbrown> and I am the only person on the project now, and porting to ghc is not really research :(
09:40:08 <dcoutts_> right
09:40:29 <chrisbrown> its a shame - hopefully haskell' will sort us out
09:40:56 <dcoutts_> it'd be great to get HaRE integrated in hIDE (when hIDE is ready at least)
09:41:05 <chrisbrown> do you work on hIDE?
09:41:16 <dcoutts_> yeah, when I'm not hacking on gtk2hs
09:41:59 <chrisbrown> it wouldn't be too hard to incorporate
09:42:05 <dcoutts_> probably not
09:42:13 <chrisbrown> but it would mean you would also need the programatica front end
09:42:19 <chrisbrown> :/
09:42:30 <dcoutts_> so long as the core can be built as a ghc package (or packages)
09:42:46 <dcoutts_> then one would write a wrapper layer for hooking it into the UI
09:43:19 <chrisbrown> well it works at the moment by using a refactoring server, which we run as a background process and then feeding it commands
09:43:42 <dcoutts_> that's ok so long as there is something that loads as a ghc package
09:43:50 <chrisbrown> what do you mean?
09:43:52 <dcoutts_> the plugin can spawn other processes
09:44:01 <dcoutts_> a HIDE plugin is a ghc package
09:44:12 <dcoutts_> with a designated main module
09:44:13 <chrisbrown> ah....
09:44:20 <chrisbrown> hmmmm
09:44:25 <chrisbrown> its doable
09:44:43 <chrisbrown> in effect the pfe is just a main module anyway
09:45:00 <musasabi> Wouldn't it be quite simple to add a generic plugin that just pipes commands and responses to an external process?
09:45:01 <dcoutts_> the plugin get's a main function which is run and in that, it can register itself with various bits of the UI
09:45:14 <chrisbrown> ok
09:45:35 <chrisbrown> and how does it take information from the user? it passes these as a parameter to the main function of the refactorer?
09:45:47 <dcoutts_> the plugin can also link with other hIDE plugins and can user their services, eg project managenemt info
09:46:00 <chrisbrown> this sounds like a neat idea
09:46:15 <chrisbrown> currently it only works with vim and emacs
09:46:16 <dcoutts_> well it can add menu items or hook into the editor
09:46:24 <dcoutts_> so that's how it can get some user input
09:46:30 <chrisbrown> can it add menu items via a script?
09:46:41 <dcoutts_> it's just Haskel code
09:46:53 <chrisbrown> so i can generate that?
09:47:24 <chrisbrown> the idea is that when a user adds a new refactoring - HaRe generates emacs and vim scripts to allws this new refactoring to be called from a menu
09:47:43 <dcoutts_> well one can add new menu items at any point
09:47:48 <chrisbrown> ok
09:48:00 <dcoutts_> so if you do that by reading in files whatever, that's ok
09:48:01 <chrisbrown> cool
09:48:15 <dcoutts_> for a simple static set of menu items you'd just do it in the plugins main function
09:48:26 <dcoutts_> but it could be done later in response to other input
09:48:56 <chrisbrown> well, tbh most of it will be static - i can't see many people writing their own refactorings
09:49:11 <dcoutts_> so how do you add a new refactoring at the moment?
09:50:08 <chrisbrown> you write the refactoring - and then add it to a file. compile it and during the compilation a script is run to generate the vim and emacs scripts that includes menu commands for all the refactorings
09:50:23 <dcoutts_> oh you have to restart vim to get it
09:50:27 <chrisbrown> yes
09:50:31 <shapr> neologism: Wouldn't a functor be a hylomorphism? Or am I confused?
09:50:31 <chrisbrown> well no
09:50:40 <chrisbrown> you restart the refactorer from within vim
09:50:44 <dcoutts_> ah ok
09:50:51 <chrisbrown> there is an option to turn it on and off
09:50:52 <dcoutts_> so there is a menu item to restart it?
09:50:53 <shapr> chrisbrown: oh HEY, are you working on HaRe?
09:51:15 <chrisbrown> dcoutts: there is an option to turn it on - and when it is on there is an option to turn it off
09:51:21 <neologism> shapr: what is a hylomorphism?
09:51:22 <chrisbrown> shapr: yep - certainly do!
09:51:47 <shapr> Whoa cool, I'm a devoted fan of refactoring browsers and would love to talk about HaRe in great detail at some point.
09:51:50 <dcoutts_> chrisbrown, well that'd be easy to do the same
09:51:55 <chrisbrown> ok
09:52:10 <chrisbrown> dcoutts_:  what stage is at?
09:52:16 <dcoutts_> chrisbrown, just regenerate the menu items in response to selecting some other reload/restart menu item
09:52:50 <dcoutts_> chrisbrown, well it does syntax highliting, typececking, multiple views of files, file browsing, basic cabal/project info.
09:53:05 <chrisbrown> are you planning on releasing a prototype soon?
09:53:19 <chrisbrown> it uses ghc api right?
09:53:41 <dcoutts_> chrisbrown, it's available now, but it's rather hard to build atm, since it depends on deve versions of just about everything
09:53:43 <shapr> I started the Bicycle Repair Man project long ago and far away... and had some email exchanges with Claus Reinke about it.
09:54:12 <dcoutts_> chrisbrown, yes, it uses the ghc api for interactive typechecking 
09:54:18 <shapr> About HaRe that is... I still think HaRe could have been bootstraped from the MetaEnvironment.
09:54:25 <chrisbrown> dcoutts: once you have a solid prototype i would be very interested in getting HaRe to work with it...
09:54:31 <dcoutts_> chrisbrown, cool
09:54:39 <chrisbrown> shapr: what do you mean?
09:54:44 * dcoutts_ ought to go
09:55:00 <shapr> Have you seen ATerm and SDF from the MetaEnvironment?
09:55:08 <chrisbrown> heard of them...
09:55:38 <dcoutts_> chrisbrown, nice talking to you, I might see you in some time if I ever get round to taking up Axel's invitation to come speak at your FP group
09:55:40 <shapr> The MetaEnvironment is a really general purpose language agnostic framework.
09:55:57 <chrisbrown> dcoutts: same to you! hope your work goes well...
09:56:49 <chrisbrown> im not sure i understand
09:57:22 <shapr> SDF is a 'syntax description format' and ATerm is a generic abstract syntax tree library.
09:58:10 <shapr> So I suggested that a Haskell to ATerm parser written in SDF would be able to leverage the existing library that can manipulate ATerms.
09:58:22 <shapr> And could be implemented rather quickly as well.
09:58:30 <shapr> On the downside, not that much of the code would be in Haskell itself.
09:59:44 <shapr> ATerm libraries exist for Haskell, C, and Java at least, probably more.
09:59:54 <shapr> And it's a memory efficient representation as well.
10:03:04 <shapr> chrisbrown: Then again, I haven't actually tried to use all those libs for something like HaRe, so there could be hidden problems I've never considered.
13:41:44 <palomer_> y0
13:41:50 <jethr0> hi
13:41:56 <jethr0> no traffic since 1902 :)
13:42:00 <palomer_> what's nominal subtyping?
13:42:01 <MarcWeber> http://www.rafb.net/paste/results/dw1l0875.html why isn't end printed here?
13:43:38 <ezraburgh> palomer: i think it's when subtypes are explicit, rather than based on the structure...
13:44:11 <palomer_> my teacher claims that java has nominal subtpying
13:44:13 <palomer_> subtyping
13:44:20 <mauke> yeah, inheritance
13:44:21 <palomer_> but they also have subtyping based on the structure
13:44:21 <jethr0> nominal?
13:44:39 <palomer_> ever since they got generics
13:44:41 <mauke> I think it's when you say class Foo inherits Bar {...}
13:45:09 <palomer_> what about Foo<x> extends Bar<y> ?
13:45:42 <ezraburgh> the point is that the subtyping is due to the declaration, rather than due to the structure of the types themselves.
13:45:50 <mauke> no idea, I don't know how java's generics work
13:45:58 <MarcWeber> which tutorial do you recommend to learn all about haskell exceptions?
13:46:37 <palomer_> but subtyping is always due to declarations, at some point
13:46:44 <ezraburgh> if you think of objects as records, then a record {x : Int} is automatically a subtype of {x : Int, y : String} in a structural subtyping system
13:46:57 <ezraburgh> rather, a supertype.
13:50:13 <palomer_> ok, so, looking at two types, one can decide if one is a subtype of the other, than it's not nominal
13:50:24 <palomer_> if one has to look at previous declarations to decide, then it's nominal
13:51:22 <ezraburgh> i think that's correct, yes
13:52:22 * jethr0 's still struggling with subtype vs. subclass. there are some topics that i never have enough energy to finish conclusively :)
13:52:54 <ezraburgh> 'subtype
13:52:56 <ezraburgh> oops
13:53:12 <ezraburgh> 'subtype' is a broader notion, applying not just to OOP
13:54:20 <jethr0> yes, but with things like Liskovs Substituion Principle there's a distinct difference between them, i think...
13:54:45 <ezraburgh> dunno that one.
13:55:11 <jethr0> http://okmij.org/ftp/Computation/Subtyping/#Problem-cause
13:56:02 <jethr0> there's also an article: W.R. Cook, W.L.Hill, P.S. Canning, "Inheritance Is Not Subtyping,"
13:57:08 <Saulzar> What more can you do though? In Haskell you can make an Ord type which doesn't compare properly too...
13:58:14 <jethr0> LSP and fragile base class are just things one has to be keenly aware of.
13:58:22 <jethr0> otherwise strange things might happen out of nowhere
13:59:22 <ezraburgh> jethr0--just having gotten to page two, LSP sounds like the same notion of subtype that I had in mind
14:00:24 <jethr0> as i said. i never got my head wrapped around it. it's just a thing of subclassing things that are not subtypes in a domain (for example inheriting circle from ellipse or vice versa, depending on the domain)
14:01:12 <jethr0> if you did weird things to the implicit invariants, changes in the base class may cause havoc in subclasses
14:02:21 <ezraburgh> yeah, this example of the square and the rectangle is giving me some cognitive dissonance.
14:03:06 <ezraburgh> It seems right that a square is a rectangle; it seems right that "A is a B" is the concept for "A subclasses B"; yet it seems wrong to have square as a subclass of rectangle
14:04:05 <jethr0> neither is correct (depending on the problem domain)
14:04:21 <Saulzar> That's where this notion of "is a" which is fairly intiuitive to beginners falls down
14:04:32 <jethr0> hehe, exactly
14:04:46 <ezraburgh> yeah, I think intuition about "is a" is leading us in the wrong direction.
14:04:55 <jethr0> it's more like "substituting inequals for inequals" :)
14:07:41 <Saulzar> Though the whole square/rectangle works in some cases too...
14:07:54 <jethr0> yes, depending on domain
14:08:12 <ezraburgh> Like what, for example?
14:08:16 <jethr0> but if rectangle defines a function "scaleX", subclassing square from it is bad
14:08:44 <jethr0> because someone might have the (implicit) invariant in mind "getY a = getY (scaleX a)"
14:09:21 <jethr0> if, on the other hand only a uniform scaling function is present, subclassing square from rectangle is possible
14:09:23 <Saulzar> Well, if square and rectangle are immutable and operations are from rectangle -> rectangle .. 
14:09:34 <Saulzar> then square can substitute for rectangle in all cases
14:09:40 <jethr0> hmm
14:10:04 <ezraburgh> I think the idea of "a square is a rectangle" is that a square obeys all the (geometric)  constraints that define a rectangle, and possibly more.
14:10:14 <jethr0> http://okmij.org/ftp/Computation/Subtyping/#Immutability
14:10:22 <ezraburgh> In a programming context, providing a method is a constraint: you *must* be able to handle that method.
14:11:13 <jethr0> ezraburgh: that's not enough. a square can obey "scaleX" by also scaling Y. but this might break (implicit) notions about rectangles
14:11:57 <mauke> that's not a problem if rectangle inherits from square
14:12:11 <ezraburgh> i think it depends on what the contract of "scaleX" is.
14:12:36 <ezraburgh> Thinking of the contract as a constraint, subclasses should obey all those constraints.
14:12:56 <jethr0> yes, that's exactly what LSP says
14:13:25 <Saulzar> jethr0, Yeah, mutability is irrelavant - since you can just replace the whole object anyway..
14:13:31 <ezraburgh> So I think subclassing is a kind of subtyping.
14:14:26 <jethr0> mauke: yes it is. because you might add a method "scaleX" to rectangle afterwards. and it would violate a square's contract of height==width.
14:14:32 <Saulzar> It's not enough to just make the data immutable, but you still have to enforce the right constraints on your subclasses .. eg. ScaleX :: square -> square is wrong  :)
14:14:46 <mauke> jethr0: huh? how does adding a method to rectangle change square?
14:14:54 <Saulzar> But ScaleX :: square -> rectangle is fine
14:15:12 <jethr0> mauke: it doesn't. but you can always pass a base class where you can pass a subclass
14:15:22 <mauke> no, that's wrong
14:15:26 <jethr0> huh?
14:15:33 <mauke> you can always pass a subclass where you can pass a base class
14:15:45 <jethr0> sry, my fault
14:16:33 <mauke> so, class Square { method scale; } class Rectangle is Square { method scaleX; method scaleY; }
14:16:49 <jethr0> well, in that case, square has no "offending" methods. but there are many ways of breaking this. and it should be fairly easy to devise a problematic method in square that would "break" the subclassing
14:17:01 <palomer_> @seen shapr
14:17:01 <lambdabot> shapr is in #khjk, #haskell-blah, #haskell and #ScannedInAvian. Last
14:17:01 <lambdabot> spoke 1 minute and 5 seconds ago.
14:17:08 <shapr> ?
14:17:20 <palomer_> #haskell-blah
14:17:24 <shapr> That bot is way confused about time.
14:17:30 <shapr> I spoke just a few seconds before.
14:18:06 <Saulzar> jethr0, So? You shouldn't add those methods :)
14:18:47 <jethr0> mauke: for example. for rectangle to sensible inherit from square, square would have to have two members (width,height) and an invariant of them being equal. (yes, that's stupid and contrived).
14:19:14 <Saulzar> Hmm..
14:19:19 <jethr0> subclassing rectangle from that instantly breaks the invariant (for non-square rectangles)
14:19:20 <Saulzar> I don't see that ever works
14:19:31 <mauke> why couldn't it just have one member?
14:19:38 <mauke> rectangle could add the other side
14:19:42 <jethr0> because there's not much inheritance going on
14:20:19 <Saulzar> mauke, Ok, then we may as well just use square and rectangle as arbitrary words
14:20:20 <jethr0> how would you inherit "scale (Square x) 4 = Square 4*x" without rewriting it for rectangle?
14:20:32 <Saulzar> Replace square with horse and rectangle with fred and it makes as much sense
14:20:39 <jethr0> :))
14:20:47 <mauke> I'd rewrite it
14:21:00 <jethr0> what's the point of inheriting then?
14:21:19 <ezraburgh> what are you saying about fred's mother if he inherits from a horse? 
14:21:41 <jethr0> ezraburgh: that with 50% probability she's a horse :)
14:21:49 <mauke> no idea, I don't really use OO that often
14:21:49 <Saulzar> a rectangle only substitutes for a square in 1 exact case, so you may as well call it "rectangle-with-equal sides", or - "square"
14:22:34 <jethr0> bbl
14:22:37 <ezraburgh> :-)
14:23:41 * Saulzar wonders if the world has gone insane, OO in the Haskell channel? :)
14:23:55 <ezraburgh> it is a sign of the apocalypse
14:57:38 <Pseudonym> G'day.
15:01:50 <ezraburgh> g'day
15:02:57 <vann_> d'gay
15:08:13 <Pseudonym> Oh, shapr, you're here.
15:08:32 <Pseudonym> Good.  Tom Conway wants me to co-write a TMR article with him.
15:08:37 <Pseudonym> End of the month, right?
15:10:21 <jethr0_> which month :)
15:10:29 <TuringTest> Pseudonym: On what?
15:11:07 <Pseudonym> We implemented an efficient LRU using STM.
15:11:21 <Pseudonym> AFAIK nobody has done it using STM before.
15:11:39 <jethr0_> lru = least recently used??
15:11:43 <Pseudonym> Yes,.
15:11:52 <jethr0_> for scheduling?
15:11:54 <Pseudonym> The thing about LRU lists is normally they require a lock on every access.
15:11:59 <Pseudonym> Well, for caches.
15:12:09 <Pseudonym> That's what we were most interested in.
15:12:25 <TuringTest> tricky
15:12:46 <Pseudonym> Yes, but not tricky enough for a journal paper. :-)
15:13:06 <Pseudonym> Although we are going to propose another STM data structure which we think would be handy.
15:13:12 <TuringTest> ?
15:13:34 <Pseudonym> Read the paper.
15:13:36 <Pseudonym> :-)
15:13:48 <TuringTest> I would like a TMVar with as close to the same wake-one semantics as MVar
15:13:48 <Pseudonym> It's only about half-written at the moment, so don't read it yet.
15:14:06 * TuringTest nods
15:15:25 <Pseudonym> Wow, my boss is about to submit a paper to Science.
15:15:31 <Pseudonym> That's a bit more impressive than TMR. :-)
15:15:43 <TuringTest> Biological or Physical science?
15:15:59 <TuringTest> (I am writing a physics paper at the moment)
15:16:10 <Pseudonym> He's a physical chemist.
15:16:14 <Pseudonym> So I'm guessing the latter.
15:16:30 <TuringTest> Good guess
15:16:41 <xerox_> You're having fun eh?  Goodnight chaps.
15:16:47 <TuringTest> bye
15:17:01 <Pseudonym> Night.
15:17:04 <jethr0_> are (>),(<=),(>=),max,min automatically defined when instancing "Ord" and implementing (<)?
15:17:19 <Pseudonym> Yup.
15:17:25 <jethr0_> cool
15:17:26 <Pseudonym> And compare.
15:17:35 <jethr0_> k
15:17:36 <Pseudonym> Obviously you also need to have implemented ==
15:17:59 <Pseudonym> It's more customary to implement compare, I believe.
15:18:01 <jethr0_> hmm, i'm deriving Eq, but i might need to customize that...
15:18:24 <jethr0_> is compare in typeclass Ord?
15:18:32 <TuringTest> yes
15:19:00 <jethr0_> yup, i was looking at old docu :)
15:19:29 <Pseudonym> Must have been VERY old.
15:20:07 <jethr0_> just what google came up with
15:22:27 <chrisbrown> does anyone know where i can get hsplugins from?
15:23:33 <chrisbrown> ah its ok - found it :)
15:25:38 <palomer> @seen shapr
15:25:38 <lambdabot> shapr is in #khjk, #haskell-blah, #haskell and #ScannedInAvian. Last
15:25:38 <lambdabot> spoke 12 minutes and 32 seconds ago.
15:38:15 * chrisbrown pokes dcoutts 
15:44:22 <dcoutts> chrisbrown, I'm not here :-)
15:44:50 <chrisbrown> dcoutts: you are busy?
15:51:07 <MarcWeber>   Control.Exception.catch ( return ((div 3 0)::Int)) (\e -> print "catched" >> return 7)  Why doesn't this print "catched"?
15:53:06 <Cale> MarcWeber: because nothing forces the evaluation of div 3 0
15:53:27 <Cale> so the error never happens inside the catch
15:54:05 <Cale> Use Control.Exception.evaluate to force the evaluation to occur
15:54:07 <MarcWeber> ;-) So I should assign and print that value.....
15:55:40 <MarcWeber> When using c<-Control.Exception.catch ([...]
15:55:42 <MarcWeber> print c
15:56:03 <TuringTest> > error "foo"
15:56:04 <lambdabot> Add a type signature
15:56:19 <MarcWeber> the evaluation is done.. but the exception isn't cauht but the program is terminated.. it should print "catched" and "7", shouldn't it?
15:57:24 <TuringTest> print =<< Control.Exception.catch ( return ((div 3 0)::Int)) (\e -> print "catched" >> return 7)  
15:57:31 <TuringTest> That may fail
15:57:57 <TuringTest> Because the div is done after the catch is over
15:58:23 <TuringTest> print =<< Control.Exception.catch ( Control.Exception.evaluate ((div 3 0)::Int)) (\e -> print "catched" >> return 7)
15:58:25 <TuringTest> That works
15:58:42 <TuringTest> Because the div is performed while the catch is running
15:58:52 <TuringTest> Lazy error are hard to catch
15:59:02 <TuringTest> s/error/errors/
15:59:06 <MarcWeber> Ah.. thanks
16:05:13 <MarcWeber> This also works (I've forgotten how it's called):   c <-(\future -> Control.Exception.catch ( future ( return ((div 3 0)::Int))) (\e -> print "catched" >> future(return 7))) (\x -> do c<-x; print c).. yeah.
16:08:31 <TuringTest> That may be referentially equivalent to putting the print c inside the catch statement.  So yeah, I could see that working.
16:09:21 <TuringTest> But it does look quite strange
16:13:22 * TuringTest leaves
16:50:46 <jethr0_> where is everyone?
16:51:00 <Taral> Somewhere.
16:52:54 <jethr0_> channel has been eerily quiet all evening
16:53:16 <mauke> I could flood it with colorful ascii art
16:53:37 <jethr0_> sure :)
16:53:43 <dons> @yow
16:53:44 <lambdabot> I have seen these EGG EXTENDERS in my Supermarket ...
16:54:08 <jethr0_> @vixen where did everyone go?
16:54:09 <lambdabot> let me answer that later, okay?
16:54:36 <jethr0_> @vixen i wish there would be some typing discussion i couldn't follow, as usual :)
16:54:37 <lambdabot> really, so am i!
16:54:52 <SyntaxNinja> @yow
16:54:52 <lambdabot> for ARTIFICIAL FLAVORING!!
16:55:17 <jethr0_> what the heck is "yow" all about?
16:56:34 <the_ez> @yow
16:56:35 <lambdabot> I have a VISION!  It's a RANCID double-FISHWICH on an ENRICHED BUN!!
16:58:13 <Taral> @help yow
16:58:14 <lambdabot> Yow!
16:58:18 <Taral> not helpful
16:58:37 <jethr0_> @yow not helpful!
16:58:38 <lambdabot> Am I in GRADUATE SCHOOL yet?
16:58:46 <Taral> @help vixen
16:58:47 <lambdabot> sergeant curry's lonely hearts club
16:58:54 <Taral> also not helpful
16:59:11 <jethr0_> @vixen your help command proved unhelpful!
16:59:12 <lambdabot> I dunno
16:59:21 <jethr0_> @vixen huh?
16:59:21 <lambdabot> do i confuse you?
16:59:25 <jethr0_> @vixen yes
16:59:25 <lambdabot> i guessed that
16:59:43 <dons> @keal
16:59:44 <lambdabot> i can explain why something is without knowing what the rules decided by
16:59:44 <lambdabot> man are
17:00:00 <jethr0_> @help keal
17:00:00 <lambdabot> Talk like Keal
17:01:33 <araujo> @keal
17:01:34 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
17:01:43 <Adamant> @vixen flirt
17:01:43 <Taral> ghc's -fasm produces pretty good code
17:01:43 <lambdabot> Uh-huh
17:02:12 <jethr0_> Taral: you have gone through assembly compiler output?
17:02:18 <Cale> @keal
17:02:19 <lambdabot> someone needs to write a boids for haskell that emulates humans going on
17:02:19 <lambdabot> and off topic
17:02:25 <dons> Taral, yeah, it beats gcc on occasion. and is much faster to compile.
17:02:56 <Taral> jethr0_: Yes, I did.
17:03:04 <Taral> Then again, this is amd64, where we have a sane number of registers.
17:03:10 <jethr0_> i haven't done that for ages...
17:03:34 <dons> ah, yeah, may be even better on amd64. it's pretty good on x86
17:05:28 <Taral> O.o
17:05:30 <Taral> I think I found a bug
17:05:59 <Taral> yup, bug!
17:06:22 <Taral> /tmp/ghc31156.s:3254: Error: suffix or operands invalid for `add'
17:06:39 <dons> cool!1
17:07:22 <Taral>         addq $2400959708,%rsi
17:07:25 <Taral> it doesn't like that
17:07:56 <dons> better submit a bug report
17:08:35 <Taral> where?
17:08:48 <dons> (and compile -fvia-C for now)
17:08:53 <dons> the ghc bug tracker
17:09:02 <dons> i'll find you the link..
17:09:12 <dons> http://www.haskell.org/ghc/reportabug
17:09:38 <dons> @where+ ghc-bugs http://www.haskell.org/ghc/reportabug
17:09:39 <lambdabot> Done.
17:10:03 <Taral> I can mix -fasm and -fvia-C, right?
17:10:12 <dons> yep.
17:10:41 <Taral> okay, I'll just hit that with via-C then
17:11:03 <dons> but you should report the bug, yeah? seems like a pretty easy one to fix.
17:11:15 <Taral> Yeah.
17:11:19 <Taral> I might see about fixing it too.
17:11:38 <dons> even better. then you get to be a Hero :)
17:12:04 <Taral> first to check if this is fixed in ghc cvs
17:12:35 <dons> hmm. probably not, is my guess. haven't seen much ncg work recently
17:15:41 <Taral> @version
17:15:41 <lambdabot> lambdabot 3p283, GHC 6.5.20050806 (Linux i686)
17:15:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
17:15:48 <Taral> wow, old ghc cvs
17:16:24 <dons> ? ghc cvs is in darcs now.
17:16:30 <Taral> I know
17:16:33 <Taral> I still call it ghc cvs.
17:16:36 <Taral> Old habit.
17:16:55 <dons> so do i :)
17:18:43 <Taral> ok... not finding the NCG instruction set files
17:19:40 <dons> grep in fptools/ghc/compiler/nativeGen/
17:24:33 <Taral> I don't suppose there's any decent documentation for this, is there?
17:25:06 <Taral> gah! there's still something wrong with ghc that makes make go into an infinite loop
17:25:33 <Cale> Taral: I thought that was a Make bug
17:25:41 <Taral> I think it is
17:25:48 <Taral> I can bypass it by (cd ghc/compiler; make boot)
17:25:55 <Taral> but it gets stuck again
17:26:30 <dons> Taral, yep, in the commentary, i think. (though depends what you mean by decent)
17:26:36 <Taral> commentary?
17:26:42 <dons> let me find it..
17:28:16 <dons> @where+ commentary http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
17:28:16 <lambdabot> Done.
17:28:58 <dons> the ncg section is out of date, since we rewrote the ncg last year
17:29:09 <dons> some of it is still valid.
17:29:18 <dons>  but not the stuff talking about Stix
17:30:09 <Taral> ok
17:30:16 <Taral> Cale: Do you have a pointer to it being a make bug?
17:39:05 * Taral downgrades make.
17:40:32 <Cale> Taral: I don't actually know much about it apart from people talking on here
17:40:44 <Taral> Found it.
17:42:34 <Taral> http://savannah.gnu.org/bugs/?func=detailitem&item_id=15584
17:48:29 <Igloo> It doesn't look like the make people will be fixing it, sadly. I thought I'd wait to see if there was any further discussion before mailing the list, though, what with the Simon's away for the week
17:48:38 <Igloo> Gack, Simons
17:56:08 <Taral> what?
17:56:20 <Taral> the make thing?
17:56:25 <Taral> It looks like the problem is a bad implicit rule
17:56:53 <Taral> ok... I think I found the problem with my code, but I need a way to dump the cmm from ghc
17:57:56 <dons> -ddump-cmm ?
18:01:46 <Taral> gah, can't find the dump list in the docs. Yeah, that's probably it
18:02:06 <Taral> I think that bad addq is supposed to have a negative argument
18:02:16 <Taral> but I need to see the cmm to check
18:02:52 <dons> it's in options-debugging.html, iirc
18:03:06 <Taral> ah thank you
18:03:22 <Taral> (docs still say -ddump-stix, ha)
18:12:59 <Dreadshoot> how do you compile a program in ghci?
18:13:22 <Dreadshoot> or whats the command for help in ghci
18:13:55 <mauke> try :? or :h
18:16:36 <Dreadshoot> ok, well there is nothing there about compiling, dont you do something like "--make d:\prog\test.hs -o main"?
18:17:47 <Lemmih> You want to build a binary from GHCi?
18:17:48 <mauke> you use ghc for compiling
18:18:34 <Dreadshoot> aha ok, thought i could build from inside ghci :)
18:21:56 <Dreadshoot> ok i got a test.hi and a test.o file
18:23:22 <Dreadshoot> but i want an executable file in some sort
18:23:38 <dons> it should have created a file: 'main'
18:23:47 <dons> that's what -o main means.
18:23:57 <dons> usually, you just say: ghc Foo.hs, and you get a.out
18:24:02 <Lemmih> Does test.hs contain the Main module?
18:24:47 <dons> or you could try: runhaskell Foo.hs
18:26:30 <Dreadshoot> "compilation is NOT required
18:26:45 <Dreadshoot> im in win btw using it
18:29:16 <Lemmih> Dreadshoot: It didn't create a binary called 'main'? Does test.hs contain a module called Main? How are you invoking ghc?
18:29:53 <Dreadshoot> yeah, w8 a sec, gonna make a hello world version instead to start with ;)
18:32:29 <Dreadshoot> and no i dont think it created any binary, just a .hi and a .o
18:33:00 <Korollary> those are binaries, eh?
18:33:13 <Korollary> do you mean an .exe?
18:33:42 <dons> a.hi? so you have a file a.hs, containing a declaration for 'main'?
18:34:04 <Lemmih> Dreadshoot: Are you sure it didn't create a binary called 'main'? Does test.hs contain a module called Main? How are you invoking ghc?
18:34:24 <dons> $ echo 'main = putStrLn "hello"' > a.hs
18:34:25 <dons> $ ghc a.hs$ ./a.out 
18:34:28 <dons> hello
18:38:56 <Taral> on windows it's called "a.exe"
18:40:11 <Dreadshoot> dons, what is ./a.out?
18:41:38 <Dreadshoot> i got a a.hs file now containing main = putStrLn "hello"
18:41:39 <dons> the name of the executable that is created. it'd be a.exe onD[D[D[D[D[D[D[D[D[D windows.
18:43:16 <Dreadshoot> "ghc a.hs a.exe" compilation is NOT required gcc: a.exe: No sutch file or directory
18:43:21 <Taral> zsh: segmentation fault  ./genprimopcode
18:43:27 <Taral> THAT bug I am not fixing
18:44:01 <Lemmih> Dreadshoot: Use 'ghc a.hs -o a.exe' or 'ghc a.hs'
18:44:20 <dons> Dreadshoot, that's not the right command; "ghc a.hs"  then run "a.exe"
18:44:26 <dons> as Lemmih says.
18:44:40 <Dreadshoot> ahh finally, that worked
18:44:50 <Taral> ?!
18:44:56 <Taral> I registered on trac, but I can't create a ticket
18:44:58 <Taral> that's willy
18:45:00 <Taral> *silly
18:46:01 <Dreadshoot> ghc a.hs -o a.exe works fine, ghc a.hs just created a a.hi and a a.o file
18:46:59 <Dreadshoot> yikes 469kb
18:47:39 <Dreadshoot> is there any optimization flags that should be used?
18:49:38 <Taral> -O
18:52:47 <Dreadshoot> well thats what i used?
18:52:57 <mauke> I thought you used -o a.exe
18:53:22 <Dreadshoot> yes, is -o and -O different flags?
18:53:33 <mauke> yes, of course
18:53:52 <mauke> -o FILE means "write output to FILE", -O means "enable optimizations"
18:54:01 <Dreadshoot> ok, well size is the same of the hellow world
18:54:21 <Taral> haskell is not very efficient size-wise for small programs
18:54:26 <Taral> the RTS has to be included and it is not small
18:54:34 <Dreadshoot> ghc a.hs -O -o a.exe
18:55:14 <Dreadshoot> runtimesystem?
18:56:52 <Taral> yup
18:58:02 <Dreadshoot> what is the .hi and .o files that is also created?
18:58:12 <Dreadshoot> object maybe and..?
18:59:43 <mauke> haskell interface, I guess
19:00:34 <Taral> yup
19:00:48 <Dreadshoot> ok thx
19:23:32 <Lemmih> *GHC* is not very efficient size-wise for small programs.
19:54:22 <lispy> heh, is it efficient with large ones?
19:56:49 <shapr> Pseudonym: Tom Conway?
19:57:04 <Pseudonym> G'day.
19:57:18 <shapr> Ah, parallel mercury?
19:57:37 <Pseudonym> Yes, parallel Mercury.
19:58:07 <Pseudonym> He decided parallel Haskell is far more interesting. :-)
19:58:12 <shapr> Anyway, I'm planning to stop editing TMR after the next one.. as soon as I can get the next one out.
19:58:17 <shapr> You want to take it over?
19:58:17 * Pseudonym nods
19:58:19 <Pseudonym> Nope.
19:58:26 <Pseudonym> I mean I'd _like_ to...
19:58:39 <Pseudonym> But realistically, if I can't even write articles regularly...
19:58:40 <shapr> In any case, sure, put up a LRU in STM article.
19:59:22 <shapr> Maybe I'll have time to get the last TMR out for the 1st of the next month.
20:12:18 <glasse> Assuming the operating system supports it, a Haskell program can get partially paged to disk while running, right? I mean, there's nothing in ghc that calls mlock() or anything, right?
20:15:40 <Lemmih> lispy: More so than with small programs.
20:30:43 <Dreadshoot> how do you make so it overwrites a file?
20:30:54 <dons> so what overwrites a file?
20:31:07 <Dreadshoot> h <- openFile "haskell.txt" WriteMode
20:31:13 <Dreadshoot> hPutStrLn h . show $ 5+5
20:31:17 <Dreadshoot> hClose h
20:31:36 <Dreadshoot> if the file exists, i want to overwrite it, or alternative.. append to it
20:31:55 <dons> it'll overwrite it, by default, afaik
20:32:16 <Dreadshoot> tested and it doesnt, it does create one though if noone exists
20:33:00 <dons> works for me.
20:33:15 <dons> it'll create one, and it'll overwrite too.
20:34:05 <dons> you might want to read the IO library docs: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
20:34:33 <dons> @docs System.IO
20:34:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
20:34:42 <Dreadshoot> ah it does, must be something else that is wrong
20:35:56 <Korollary> WriteMode truncates if the file exists. Use AppendMode.
20:46:42 <dons> Dreadshoot, you're learning haskell, yeah? what's kind of project are you starting with?
20:59:25 <Dreadshoot> dons: well, lets test it .. ;)
20:59:33 <Dreadshoot> !haskell 4+4
20:59:39 <Dsentinel> 8
20:59:51 <Dreadshoot> !haskell sum ([n^n | n <- [1..1000]]) `mod` 10^10
20:59:56 <Dsentinel> 9110846700
21:00:27 <Dreadshoot> :)
21:00:47 <dons> !haskell System.Cmd.system "dir"
21:00:48 <Dsentinel> No (forbidden content).
21:00:54 <dons> good good
21:01:10 <dons> !haskell let f () = f () in f () :: ()
21:01:24 <dons> ah, sorry :}
21:01:30 <Dreadshoot> well that didnt work ;)
21:01:40 <dons> !haskell last [1..]
21:01:58 <dons> have you looked at the @eval plugin?
21:02:12 <Dreadshoot> !haskell 5*8
21:02:17 <dons> > sum ([n^n | n <- [1..1000]]) `mod` 10^10
21:02:18 <lambdabot> 9110846700
21:02:53 <Dreadshoot> !haskell 9*5
21:02:59 <Dsentinel> 45
21:03:01 <dons> how does it work?
21:03:51 <dons> !haskell :?
21:03:56 <Dsentinel> 45
21:04:03 <dons> hmm
21:04:04 <Lemmih> heh
21:04:13 <Saulzar> Hmm, how is the best way to do the forbidden content/No IO thing?
21:04:30 <dons> well, having a type constraint enforced by the type checker seems a good way
21:04:38 <dons> that's how @eval/> works
21:04:48 <Dreadshoot> dons: not satified but.. it uses "a cheating workaround method" i create a .hs file, add the string to be evaluated. executed ghc.. compiles it, runs the exe that writes to a file, and then i read from that file
21:04:49 <Dreadshoot> :D
21:05:01 <dons> ok, that's reasonable
21:05:16 <Saulzar> I guess with eval it is not so hard, I wonder with modules how to allow local imports but disalow importing Foreign or the like
21:05:17 <dons> it's basically System.Eval.Haskell ;)
21:05:35 <Dreadshoot> dons: you have to use hs-plugins to use eval though?
21:05:42 <Cale> !haskell hPutStrLn stdout "hello"
21:05:42 <dons> Saulzar, check the hs-plugins paper. you can parse the module and filter out things you don't want
21:05:47 <Dsentinel> 45
21:05:56 <dons> Dreadshoot, yup.
21:06:09 <dons> !haskell 2+1
21:06:11 <Saulzar> Ah, cool. I had been reading the docs - thought that maybe parsing the sources was going to be easiest.
21:06:15 <Dsentinel> 3
21:06:25 <dons> !haskell last [1..]
21:06:27 <Cale> !haskell [1..]
21:06:29 <Saulzar> At least superficially for import statements
21:06:50 <Dreadshoot> cale: yours resultet in compilation error, allready got hPutStrLn in the file
21:07:14 <Cale> hmm
21:07:31 <dons> !haskell ; putStrLn "foo" ; --
21:07:35 <dons> (just guessing)
21:07:45 <Dreadshoot> string haskellstring = "import System.IO\nmain = do\nh <- openFile \"haskell.txt\" WriteMode\nhPutStrLn h . show $ " + haskellevaluate + "\nhClose h";
21:07:58 <Dreadshoot> thats what i write into the .hs file
21:08:08 <Cale> !haskell "" >> readFile "/etc/passwd" >>= (print . lines)
21:08:08 <Dsentinel> No (forbidden content).
21:08:30 <Dreadshoot> !version
21:08:31 <Dsentinel> Dsentinel: version 0.04, the C++ bot. Memory usage: 6 902 Kb.
21:09:25 <Cale> !haskell "" >> openFile "/etc/passwd" ReadMode >>= \hdl -> hGetContents hdl >>= (print . lines)
21:09:26 <Dsentinel> No (forbidden content).
21:09:39 <dons> !haskell "" >> putStrLn "foo"
21:09:46 <Dreadshoot> dons: eval with hs plugins would be really good, i havent bothered trying to get it to work in windows though
21:10:17 <dons> it's just that we already went through all the issues with locking down security :)
21:10:38 <Dreadshoot> ?
21:10:52 <dons> > last [1..]
21:11:00 <lambdabot> Terminated
21:11:01 <dons> for example.
21:11:20 <Cale> > print [1..]
21:11:21 <lambdabot> No IO allowed
21:11:35 <Cale> > [1..]
21:11:37 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
21:11:37 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
21:11:37 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
21:11:37 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
21:11:37 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
21:11:38 <lambdabot> [24 @more lines]
21:11:54 <dons> !haskell 1+1
21:12:29 <Dreadshoot> !haskell 4+5
21:12:34 <Dsentinel> 9
21:13:03 <Dreadshoot> dons: aha but what i would need is a direct connection with c++ to haskell, so i can execute a c++ string in haskell and return a string to c++. But i guess i cant do that without hs-plugins
21:13:36 <Cale> !haskell 1 + 1; writeFile "happyFile" "Whee!";
21:13:36 <Dsentinel> No (forbidden content).
21:14:01 <Dreadshoot> Cale: hehe well thats from when i made protections to mathematica functions
21:14:07 <dons> !haskell  "" ; print "IO"
21:14:09 <Saulzar> !haskell Foreign.unsafePerformIO $ putStrLn "foo"
21:14:13 <Dsentinel> ""
21:14:18 <Dsentinel> ""
21:14:25 <Dreadshoot> !math Solve[5x^2+9x-5 == 0]
21:14:26 <Dsentinel> {{x -> (-9 - Sqrt[181])/10}, {x -> (-9 + Sqrt[181])/10}}
21:15:38 <Dreadshoot> !google hs-plugins
21:15:39 <Dsentinel> http://www.cse.unsw.edu.au/~dons/hs-plugins/
21:18:17 <Dreadshoot> wonder if you can get ghci to just output an expression you type in to a file
21:19:09 <dons> !haskell [1..100]
21:19:15 <Dsentinel> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]
21:20:14 <Dreadshoot> i put in a 5sek delay in the code, instead of writing proper function just for testing now, thats why the haskell evaluation is so slow
21:29:37 <dons> !haskell 1+1
21:29:57 <Dreadshoot> its gone! ;)
21:30:23 <dons> ah, I see.
21:31:26 <Dreadshoot> im not satisfied at all with the solution yet, all the workaround i do, kindof sucks. time consuming/very small protection/no error handling
21:32:35 <dons> yeah. so I say: use System.Eval.Haskell ;)
21:33:00 <dons> or at least have a look at: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/RunPlugs.hs
21:33:13 <dons> which is how '>' is implemented.
21:34:01 <joelk> @google haskell
21:34:01 <lambdabot> No Result Found.
21:34:07 <joelk> what's up with that?
21:34:11 <shapr> @google google
21:34:12 <lambdabot> No Result Found.
21:34:15 <Dreadshoot> http://www.haskell.org/haskellwiki/Haskell
21:34:33 <dons> poossible the net is playing tricks at my end
21:34:38 <dons> s/my/lambdabot/
21:34:54 <joelk> @wikipedia Stewart
21:34:55 <lambdabot> No Result Found.
21:35:09 <dons> @quit try again
21:35:24 <dons>  connect: does not exist (Connection refused) !
21:35:27 <dons> bizarre
21:35:39 <dons> so it is the net at my end.
21:36:46 <dons> lambdabot can't connect. boo hoo
21:37:04 <Dreadshoot> dons: but i cant use System.Eval.Haskell since it is in hs-plugins and that doesnt work by default in win and that jap guy havent answered yet
21:37:07 <joelk> dons, did you put the "-- ?" comment on a line I added to in Plugins/Search.hs?
21:37:23 <audreyt> dons: this is your irregularly scheduled prodding about hs-plugins, nudge nudge
21:37:37 <dons> Dreadshoot, you just need to install it. you've haven't told me why it doesn't work for you.
21:38:01 <dons> audreyt, hey. thanks :) soon soon. /me tries to stop procrastinating
21:38:09 <dons> joelk?
21:38:28 <dons> joelk, don't know. check the src.
21:38:34 <joelk> there's a "-- ?" tacked onto a line there...
21:38:40 <Dreadshoot> dons: no problems really, i havent even tried nor am i used to working with makefiles and so on so dont know how it should be properly installed
21:39:10 <dons> doesn't ring any bells, joellk
21:40:03 <joelk> Well, I'll just pull and look for patch comments.
21:40:20 <dons> if it put it there, i don't know why i put it there :)
21:40:44 <dons> must be the vim macro I wrote that automatically adds -- ? to joelk's patches ;)
21:41:50 <joelk> hmmm... no remote changes... and almost only keal patches since...
21:42:08 <dons> maybe YOU put it there ;)
21:42:12 <joelk> heh, I must have put it in... not the strangest thing I've ever done
21:42:16 <joelk> he
21:49:32 <joelk> Ah, it was in there originally. Stupid long-term memory (or lack thereof).
23:24:12 <dons> hmm. network trouble. lambdabot can't connect. someone might have to run an instance of lambdabot temporarily until the network here is fixed.
23:26:37 <vincenz> re
