00:02:01 <ski> hm, there's a new version of winhugs
00:02:06 <ski> @where winhugs
00:02:07 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
00:02:22 <ski> but i'm not so sure of how stable/mature it is yet (haven't tried)
00:02:40 <essiene> i c... thnx for that pointer too...
00:03:23 <ski> btw, if you haven't guessed it yet, the main haskell site is at http://www.haskell.org
00:03:41 <ski> the topic has a few more links, too
00:05:03 <essiene> oi vei!!! been there... done that ;)
00:06:50 <SimonRC> @djinn (a,b,c,d,e,f)->(f,e,d,c,b,a)
00:06:51 <lambdabot> f (a, b, c, d, e, f) = (f, e, d, c, b, a)
00:06:55 <SimonRC> hmm
00:07:04 <SimonRC> @pl reverse
00:07:05 <lambdabot> reverse
00:07:25 <SimonRC> @pl \[a,b,c,d,e,f]->[f,e,d,c,b,a]
00:07:26 <lambdabot> (line 1, column 2):
00:07:26 <lambdabot> unexpected "["
00:07:26 <lambdabot> expecting pattern
00:07:52 <SimonRC> @pl g [a,b,c,d,e,f]=[f,e,d,c,b,a]
00:07:52 <lambdabot> (line 1, column 16):
00:07:52 <lambdabot> unexpected "="
00:07:52 <lambdabot> expecting variable, "(", operator or end of input
00:08:12 <gour> how is that Haskell #2 on the shootout (missing 1 script) with gcc missing 2 scripts ?
00:08:16 <SimonRC> @pl g a:b:c:d:e:f:[] = f:e:d:c:b:a:[]
00:08:17 <lambdabot> (line 1, column 18):
00:08:17 <lambdabot> unexpected "="
00:08:17 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
00:08:23 <ski> pl doesn't like all haskell syntax, right, now
00:08:39 <SimonRC> gour: it was #1 a coule of days ago, and #2 a couple of days before that.
00:08:54 <SimonRC> @pl g (a:b:c:d:e:f:[]) = f:e:d:c:b:a:[]
00:08:55 <lambdabot> (line 1, column 20):
00:08:55 <lambdabot> unexpected "="
00:08:55 <lambdabot> expecting variable, "(", operator or end of input
00:09:09 <SimonRC> @pl \(a:b:c:d:e:f:[]) -> f:e:d:c:b:a:[]
00:09:10 <lambdabot> (line 1, column 15):
00:09:10 <lambdabot> unexpected "["
00:09:10 <lambdabot> expecting natural, identifier, "_" or "("
00:09:14 <SimonRC> @help pl
00:09:15 <lambdabot>  @pointless <expr> - play with pointfree code
00:09:28 <SimonRC> @pl \(a:b:c:d:e:f:nil) -> f:e:d:c:b:a:nil
00:09:37 <SimonRC> hmm
00:09:38 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . (
00:09:38 <lambdabot> (.) .) . flip flip tail . (flip .) . ((ap .) .) . flip flip head . (flip .
00:09:38 <lambdabot> ) . (((.) .) .) . flip flip tail . (flip .) . ((flip .) .) . (((ap .) .) .
00:09:38 <lambdabot> ) . flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip
00:09:38 <lambdabot> flip tail . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .
00:09:40 <lambdabot> [4 @more lines]
00:09:42 <lambdabot> optimization suspended, use @pl-resume to continue.
00:09:43 <SimonRC> @more
00:09:46 <ski> ouch ! :)
00:09:56 <gour> SimonRC: yep. that's why i wonder why it slipped to #2 with 3missing scripts, while few days ago all the scripts were running :-/
00:10:15 <SimonRC> @pl-resume
00:10:20 <SimonRC> @more
00:10:22 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . (
00:10:22 <lambdabot> (.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . (flip .)
00:10:22 <lambdabot> . (((.) .) .) . flip flip tail . (flip .) . ((flip .) .) . (((ap .) .) .)
00:10:22 <lambdabot> . flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip flip
00:10:22 <lambdabot> tail . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) .
00:10:24 <lambdabot> [4 @more lines]
00:10:26 <lambdabot> optimization suspended, use @pl-resume to continue.
00:10:32 <SimonRC> @pl-resume
00:10:32 <SimonRC> @more
00:10:52 <SimonRC> @more
00:10:52 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . (
00:10:52 <lambdabot> (.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip .
00:10:52 <lambdabot> ((.) .)) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) . flip
00:10:52 <lambdabot> flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip flip tail . (
00:10:52 <lambdabot> flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip
00:10:54 <lambdabot> [4 @more lines]
00:10:55 <SimonRC> @more
00:10:56 <lambdabot> optimization suspended, use @pl-resume to continue.
00:11:00 <SimonRC> hm
00:11:21 <SimonRC> @pl \(a:b:c:d:nil) -> d:c:b:a:nil
00:11:27 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((
00:11:27 <lambdabot> .) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . (
00:11:27 <lambdabot> ((.) . flip ((.) . (:))) .) . flip ((.) . (:))) .) . flip ((.) . (:)) . (:
00:11:27 <lambdabot> ) . head) tail
00:11:30 <gour> dcoutts: ping
00:11:45 <dcoutts_> gour, pong
00:12:03 <gour> dcoutts_: do you have 10mins free?
00:12:03 <SimonRC> This is wonderfully pointless.
00:12:11 <dcoutts_> gour, I guess so
00:12:52 <gour> dcoutts_: thanks. before starting with the 16th chapter's exercises (and do some reading before), i'd like to check few exercises from the 15th chapter
00:13:05 <gour> dcoutts_: should i pm you?
00:13:12 <dcoutts_> yep
00:13:40 <SimonRC> @hoogle ap
00:13:41 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
00:13:41 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
00:13:41 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
00:14:07 <dcoutts_> gour, oh, I can't pm you since this nick is not registered
00:14:41 <dcoutts_> gour, you'd need to say  /msg nickserv set unfiltered on
00:16:33 <gour> dcoutts_: i did. do you see pm?
00:24:47 <shapr> dang, blackdog just left.
00:29:21 <boegel> how can I (using Vim) delete each line in a file containing some string ?
00:30:50 * shapr yodels
00:31:32 <musasabi> boegel: /foobar
00:31:39 <musasabi> boegel: nddk
00:31:46 <musasabi> boegel: repeat after done
00:31:53 <musasabi> s/after/until
00:34:27 <ski> wb
00:36:25 <boegel> musasabi: :g/foobar/d
00:40:31 <essiene> thnx
00:41:36 <ski> @yow
00:41:36 <lambdabot> quote module failed: getRandItem: empty list
00:41:42 <ski> hrmm
00:46:43 <ihope> @quote module failed: getRandItem: empty list
00:46:43 <lambdabot> module failed: getRandItem: empty list hasn't said anything memorable
00:47:10 <ski> @seen dons
00:47:10 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 7 hours, 43 minutes and
00:47:10 <lambdabot> 24 seconds ago.
00:47:15 <ihope> @module failed: getRandItem: empty list hasn't said anything memorable
00:47:15 <lambdabot> Unknown command, try @listcommands.
00:47:24 <ihope> @Unknown command, try @listcommands.
00:47:25 <lambdabot> Unknown command, try @listcommands.
00:47:25 <ski> hm, he's prolly asleep
00:47:35 <ski> ihope : just playing around ? :)
00:47:39 <ihope> Yep.
00:50:13 <tibbe> anyone have experience of lhs2TeX?
01:04:32 <kosmikus> tibbe: yes
01:06:25 <phas> Hi, anyone knows how to mace a "service" (pratically: a daemon) for microsft windows with haskell?
01:08:43 <phas> e.c. mace == make
01:14:07 <eivuokko> Look up how to write your own c-main, then lookup on msdn docs how to write service, there is nothing really special there.
01:31:47 <rasfar> Anyone got some advice for creating smaller binaries with GHC?  Trying to use for CGI.  "Hello World" is 2.3 MB (1.5 MB once stripped)...
01:38:39 <maitscha> > (((+) 2) 3)
01:38:40 <lambdabot> 5
01:43:59 <mcnster> hello
01:45:19 <maitscha> > concat ["i","s","ob"]
01:45:20 <lambdabot> "isob"
01:45:52 <maitscha> > reverse $ concat ["i","s","ob"]
01:45:53 <lambdabot> "bosi"
01:46:07 <mcnster> newb q:  is there a fn to take two lists A, B and return AxB by concatenation?
01:46:16 <basti_> AxB?
01:46:24 <basti_> you mean the cartesian product?
01:47:20 <mcnster> basti, ["1","2"] ["3","4"] -> ["13","14","23","24"]
01:48:04 <basti_> > [a++b | a<-["1","2"], b<-["3","4"]]
01:48:05 <lambdabot> ["13","14","23","24"]
01:48:13 <basti_> sure this isn't a homework question? ^^
01:48:34 <mcnster> hehe :) no.  i'm just another clueless newb
01:48:56 <basti_> so, yes this "list comprehension" notation gives you cartesian products
01:49:01 <mcnster> i forgot about list comp.
01:49:19 <mcnster> thanks much
01:53:16 <maitscha> @define (+)
01:53:17 <lambdabot> Unknown command, try @listcommands.
01:53:35 <maitscha> @t (+)
01:53:36 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
01:53:36 <lambdabot> null topic-snoc topic-tail topic-tell type .
01:53:46 <maitscha> @type (+)
01:53:47 <lambdabot> forall a. (Num a) => a -> a -> a
01:59:45 <snk_kid> ahoy hoy
02:00:06 <snk_kid> it's Q time ;)
02:00:29 <snk_kid> are there parallizable dependently typed languages?
02:01:03 <vincenz> @seen dons
02:01:03 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 8 hours, 57 minutes and
02:01:03 <lambdabot> 14 seconds ago.
02:03:35 <snk_kid> okay i'll rephase it, do any of the currently available dependently typed languages do they have support for parallelism and concurrency?
02:04:41 <snk_kid> if your wondering why ask such a question it has to do with this: http://lambda-the-ultimate.org/node/1277#comment
02:25:57 <jonkri> @docs System.Random
02:25:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.
02:25:57 <lambdabot> html
02:28:11 <jonkri> what does this means: "RandomGen g => (a, a) -> g -> (a, g)"?
02:28:27 <jonkri> if i ignore "g =>" i would understand it
02:28:51 <basti_> you're reading it wrong
02:28:56 <basti_> the term before the => is "RandomGen g"
02:29:06 <jonkri> what about it?
02:29:06 <liyang> Ignore the RandomGen g => part.
02:29:14 <jonkri> what is it?
02:29:16 <liyang> It says g must be an instance of the RandomGen class.
02:29:20 <jonkri> oh, ok
02:29:36 <jonkri> so i could basically define a function which does this:
02:29:40 <liyang> (well, don't ignore it, but you know what I mean.)
02:29:49 <jonkri> first :: (Int, StdGen) -> Int
02:29:54 <jonkri> yeah :o)
02:30:07 <jonkri> first (x, y) = x
02:30:38 <liyang> that's just fst...
02:30:56 <liyang> @type fst
02:30:57 <lambdabot> forall a b. (a, b) -> a
02:31:01 <jonkri> @typ snd
02:31:03 <lambdabot> forall b a. (a, b) -> b
02:31:07 <jonkri> hahaha
02:31:17 <jonkri> what a jerk i am, i was going to define it myself
02:31:38 <jonkri> would my definition work?
02:32:05 <basti_> yes of course
02:32:52 <jonkri> basti_: ok, it wasn't obvious to me... feels like i'm cursed here ;-)
02:32:58 <jonkri> @type StdGen
02:32:59 <lambdabot> Not in scope: data constructor `StdGen'
02:34:00 <basti_> oh its far better when the noobs actually reinvent working wheels
02:34:06 <basti_> as opposed to C ;)
02:34:30 <jonkri> why?
02:35:06 <basti_> i'm j/k, but there is some truth to it
02:35:27 <jonkri> hehe, ok
02:35:36 <basti_> In "other languages" people reinvent the wheel just as often, but later in their careers and in far more serious contexts
02:35:57 <jonkri> ok
02:36:14 <jonkri> why does  (snd (randomR (0,10) stdGen)) generate this error: Ambiguous type variable `a' in the constraints:  `Random a' arising from use of `randomR' at... ?
02:36:47 <basti_> because you didnt specify the type of 0 and 10
02:38:11 <jonkri> thanks
02:56:16 <Si\Uni> Is it possible to use unsafePerformIO to count how many modules there are by having a global variable and an updater in each module?
03:00:02 <xerox> Si\Uni: I don't think so.
03:14:26 <maitscha> > foldl (+) 0 [1..100]
03:14:27 <lambdabot> 5050
03:14:48 <maitscha> foldl (+) 0 [1..1000]
03:15:08 <bosie> lern doch lieber map oder filter :D
03:15:24 <maitscha> > foldl (+) 0 [1..1000]
03:15:25 <lambdabot> 500500
03:15:46 <maitscha> schau nur wieviel rechenleistung lamdabot hat...
03:17:32 <basti_> > (\x->x*(x+1)/2) 1000
03:17:33 <lambdabot> 500500.0
03:17:36 <basti_> > (\x->x*(x+1)/2) 10000
03:17:37 <lambdabot> 5.0005e7
03:17:38 <basti_> > (\x->x*(x+1)/2) 100000
03:17:39 <lambdabot> 5.00005e9
03:17:40 <basti_> :D
03:17:47 <basti_> hi maitscha & bosie 
03:17:53 <maitscha> hi basti_
03:17:53 <bosie> servus
03:18:15 <basti_> how did your course go?
03:18:39 <bosie> tomorrow.... :(
03:19:25 <palomer> hrm
03:19:35 <basti_> np: hooverphonic - tomorrow
03:19:36 <basti_> heh
03:19:45 <basti_> whats up tomorrow? the test?
03:19:50 <bosie> hell yea
03:20:06 <basti_> all the best, then
03:20:11 <maitscha> thx!
03:20:19 <bosie> oh well its just oral ;)
03:20:24 <maitscha> hope we have enough luck...
03:20:40 <bosie> thx
03:21:22 <maitscha> basti_ what do you do tomorrow between 17:45 and 18:00 ??
03:22:11 <bosie> maitscha hell yea i thought the same, faking the ID with a diff photo of someone would make the whole thing alot easier ;)
03:22:39 <basti_> uhm i don't know yet, any suggestions?
03:22:59 <basti_> faking EU ID's is near to hopeless I fear
03:23:06 <maitscha> speaking with my prof a little bit about haskell?
03:23:18 <maitscha> i pay you the ticket to vienna... ;)
03:23:37 <bosie> basti_ well its primarly just a sheet of paper with our names
03:24:06 <bosie> and you wouldnt have to fake it
03:24:10 <basti_> uhm?
03:24:14 <bosie> since you just order it form the univ
03:24:20 <bosie> and you can pass whatever photo you like
03:24:21 <basti_> btw. there is #haskell-blah for this sort of conversation ;)
03:24:25 <bosie> :D
03:24:32 <basti_> oh your uni ID, yes those are easier
03:25:02 <bosie> yea not even plastic ;)
03:25:46 <basti_> we always had to bring official ID's to the tests
03:27:05 <bosie> official as in?
03:27:52 <basti_> the green plastic thing that the police asks for
03:28:00 <bosie> oh boy
03:28:11 <bosie> because you guys are so close to france?
03:28:37 <basti_> no?!
03:28:43 <basti_> so nobody fakes the tests??
03:28:49 <basti_> france? ;)
03:28:49 <bosie> right lol
03:28:53 <bosie> karlsruhe?
03:28:56 <basti_> marburg
03:29:06 <bosie> oops verwechselt sorry
03:29:21 <bosie> lol sorry
03:29:29 <basti_> ^^
03:29:38 <basti_> let's switch to #haskell-blah
03:46:53 <SyntaxNinja> lambda the ultimate is talking about Haskell'
03:55:21 <basti_> bosie: 
03:55:27 <basti_> > (\x -> x) 5
03:55:28 <lambdabot> 5
04:00:41 <beelsebob_> > "Anyway don't listen to her coz everyone knows her fanny goes sideways."
04:00:42 <lambdabot> "Anyway don't listen to her coz everyone knows her fanny goes sideways."
04:03:03 <dany2k> joint #haskell-blah
04:03:41 <dany2k> > "f.."
04:03:42 <lambdabot> "f.."
04:04:26 <ski> > ['f'..'z']
04:04:27 <lambdabot> "fghijklmnopqrstuvwxyz"
04:10:44 <vincenz> ["f","i".."z"
04:10:47 <vincenz> > ["f","i".."z"]
04:10:48 <lambdabot>  add an instance declaration for (Enum [Char])
04:10:48 <lambdabot>   In an arithmetic sequence: ["f", "i" .. "z"]
04:10:48 <lambdabot>   In the definition of `kog': kog = ["f", "i" .. "z"]
04:10:56 <orbitz> is that guranteed to be in roder
04:11:05 <vincenz> > ['f','i'..'z']
04:11:06 <lambdabot> "filorux"
04:11:12 <vincenz> hehe
04:11:28 <vincenz> orbitz: yes
04:11:33 <orbitz> k
04:11:35 <vincenz> [1,3..10]
04:11:40 <vincenz> > [1,3..10]
04:11:41 <lambdabot> [1,3,5,7,9]
04:11:51 <vincenz> > [2,4..10]
04:11:52 <lambdabot> [2,4,6,8,10]
04:11:56 <ski> > ['9','8'..'0']
04:11:57 <lambdabot> "9876543210"
04:12:04 <vincenz> nice
04:12:10 <vincenz> > [9,8,..0]
04:12:11 <lambdabot>  parse error on input `..'
04:12:15 <vincenz> > [9,8..0]
04:12:16 <lambdabot> [9,8,7,6,5,4,3,2,1,0]
04:13:13 <ski> > map chr [0x30..0x39]
04:13:14 <lambdabot> "0123456789"
04:18:58 <beelsebob_> > let boobies = (x,x); x = [] :: [Int] in show boobies
04:18:59 <lambdabot> "([],[])"
04:19:06 <essiene> ski: first official question... :)
04:19:21 <Philippa> lo and behold, you really *can* use haskell as a calculator...
04:19:28 <essiene> i want to write a function divbyfive which will determine if x is divisible by 5
04:19:46 <ski> ok
04:20:07 <essiene> i have an innitial description like: divbyfive x = iszero x or isfive x
04:20:20 <ski> (aside .. camelCase is commonly used in haskell)
04:20:36 <ski> mh ?
04:21:05 <ski> wb
04:21:08 <ski> (aside .. camelCase is commonly used in haskell)
04:21:16 <essiene> phew... thnx
04:21:26 <essiene> oh.. i c...
04:21:35 <ski> > 4 > 8 || 2 < 9
04:21:36 <lambdabot> True
04:21:51 <essiene> anyways... my question is how do i return different functions based on boolean shortcutting (to use a term i'm familiar with)
04:22:13 <ski> you could use '(||)' ("or")
04:22:19 <ski> or you can use if-then-else
04:22:24 <ski> or you can use "guards"
04:22:28 <essiene> ahhhh...
04:22:32 <essiene> guards? ;)
04:22:39 <essiene> they sound *strong* ;)
04:22:48 <ski> yes, i'll show example
04:23:08 <essiene> ok
04:23:12 <ski> factorial n = if n == 0 then 1 else n * factorial (n - 1)
04:23:19 <ski> this is using if-then-else
04:23:42 <ski> factorial n
04:23:54 <essiene> ok
04:23:56 <ski>   | n == 0    = 1
04:24:05 <ski>   | otherwise = n * factorial (n - 1)
04:24:14 <ski> that is using guards
04:24:31 <essiene> hmmm...
04:24:57 <ski> (you can of course have more than two guards)
04:25:06 <essiene> i'll just pretend as if i understand for now... and i'll double back on it later :D (shame on me) 
04:25:55 <ski> it checks first '| ..foo..' part, if it evaluates to 'True', then it chooses the corresponding '= ...' branch .. otherwise it tries the next guard
04:26:31 <essiene> ohh...
04:27:07 <ski> in if-then-else, the part after 'if' (the condition), decides if it should evaluate the part after 'then' or the part after 'else' (and return the result as value of the whole if-expression)
04:28:08 <essiene> ok
04:28:27 <ski> (btw, the 'else'-part is not optional)
04:28:56 <essiene> ok... let me try to solve the same problem using possibly all these methods...
04:29:04 <ski> if you're wondering ..
04:29:08 <ski> otherwise = True
04:29:16 <ski> that's how 'otherwise' is defined
04:29:48 <ski> (so, it's just a catch-all, usually used at end of guards)
04:30:10 <essiene> noted
04:30:15 <essiene> thnx again
04:30:22 <ski> np
04:37:50 <palomer> there should be a key to switching to greek letters on the keyboard
04:38:17 <essiene> lastdigitofnum x = read (head (reverse (show x)))
04:38:27 <monochrom> you think installing some input method for Greek will do?
04:38:55 <essiene> i have a problem with this declaration... it seems to be seeing x as Char instead of [Char] which is what i need
04:39:07 <essiene> any idea how to coerce that?
04:39:14 <palomer> haskell' doesn't look that interesting
04:39:33 <SyntaxNinja> palomer: no?
04:39:47 <SyntaxNinja> palomer: s/interesting/interesting to palomer/
04:40:11 <Cale> essiene: [x]
04:40:25 <essiene> Cale: ohh...
04:40:33 <Cale> > let x = 'c' in x
04:40:34 <lambdabot> 'c'
04:40:36 <Cale> > let x = 'c' in [x]
04:40:38 <lambdabot> "c"
04:40:43 <Cale> @type let x = 'c' in x
04:40:44 <lambdabot> Char
04:40:48 <Cale> @type let x = 'c' in [x]
04:40:48 <lambdabot> [Char]
04:41:32 <essiene> hmm..
04:41:36 <essiene> thnx
04:42:35 <palomer> I mean, really, all the stuff that will be in haskell' will already be in ghc
04:43:08 <Philippa> that's not a certainty, although anything new will have to be fairly simple to implement
04:46:16 <ski> palomer : that's sorta the point
04:47:35 <zce> I heard someone wrote a Malbolge text generator, but I can't seem to find it.
04:47:52 <zce> I want to make a t-shirt with the Malbolge listing that prints "Holier than Thou"
04:53:43 <essiene> whooopee... gotta leave for today... 
04:53:50 <essiene> ski: thnx for all the pointers...
04:54:01 <ski> ok, cya later
04:54:16 <essiene> and thnx all for being an enviable community...
04:54:20 <essiene> and of course...
04:54:24 <essiene> @muahaha ;)
04:54:25 <lambdabot> Unknown command, try @listcommands.
04:54:30 <essiene> hahaha
04:54:33 <essiene> ok.. gnite
05:13:25 <beelsebob_> @get-shapr
05:13:25 <lambdabot> shapr!!
05:43:09 <palomer> what do you guys call the label for newtypes, usually
05:44:49 <monochrom> I usually write "newtype MyType = MyType {unmytype::Int}" for example.  Using the same name for both the type and the constructor, and calling the field un-whatever.
05:49:56 <palomer> seems reasonable
05:59:21 <kevind> what does newtype do
05:59:41 <ADEpt> @index base64
05:59:42 <lambdabot> bzzt
05:59:56 <basti_> kevind: its somewhere between "type" and "data"
06:00:06 <icbt> what is the main difference between yampa and rhaskell?
06:00:15 <basti_> much like data, allowing just one constructor though
06:00:22 <basti_> icbt: yampa is implemented in haskell
06:00:49 <icbt> aren't they both DSLs
06:01:04 <basti_> uhm
06:01:09 <basti_> not strictly speaking, no
06:01:37 <dwaern> what's rhaskell?
06:01:46 <icbt> rhaskell is published in 2004, yet there is no signs of RFP relevance in the bibliography
06:01:56 <icbt> http://www.informatik.uni-freiburg.de/~wehr/haskell/
06:02:00 <basti_> i thought a typo of haskell?
06:02:07 <basti_> ohh
06:02:08 <SamB> Yampa is an EDSL
06:02:35 <basti_> forget what i said ok
06:02:49 <SamB> sortof
06:03:30 <icbt> i guess, i will read the rhaskell paper in detail to make a determination
06:04:46 <TuringTest> @seen dons
06:04:46 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 13 hours and 48 seconds
06:04:46 <lambdabot> ago.
06:04:51 <ski> palomer : i usually do 'newtype Foo = MkFoo {unFoo :: Bar}'
06:05:03 <icbt> @seen lemmih
06:05:04 <lambdabot> I saw lemmih leaving #haskell-blah and #haskell 6 days, 4 hours, 41
06:05:04 <lambdabot> minutes and 59 seconds ago, and I have missed 4 seconds since then.
06:05:14 <icbt> vacation?
06:21:47 <palomer> well, 2 for 2
06:21:49 <palomer> I'm sold
06:22:00 <Cale> hm?
06:22:02 <palomer> ski: do you miss higher order modules when working in haskell?
06:22:12 <palomer> Cale: 2 people who use "unFoo" to unbox their newtypes
06:22:29 <SamB> palomer: either that, or runFoo
06:22:34 <Cale> that's quite common. Sometimes there are better names :)
06:22:41 <Philippa> I've several times wanted the first-class modules hacks (that is, records-from-modules and preferably some sugar to deconstruct a record into a new module). I'd like signiatures, too
06:23:04 <Philippa> Cale: raw pattern-matching's nice when it's sensible :-)
06:23:08 <Philippa> "runMaybe" my arse ;-)
06:23:08 <palomer> Philippa: hoogle would be much more useful if we had signatures
06:23:09 <Cale> yeah, runFoo is common when you're newtyping a function type in order to think of it as an abstract computation
06:23:27 <Cale> Like in runState, runReader, etc.
06:23:29 <ski> palomer : sometimes
06:23:32 <SamB> Cale: or in order to make it typeable
06:23:59 <ski> palomer : mind, i haven't used sml vrey much, so i haven't used them so much there .. but i have an idea of where it can be appropriate
06:24:08 <ski> s/vrey/very/
06:24:57 <ski> sometimes i want a module-scope type-parameter
06:26:18 <ski> apropos 'runState'
06:26:35 <jethr0> @hoogle runProcess
06:26:35 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath ->
06:26:35 <lambdabot> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -
06:26:35 <lambdabot> > IO ProcessHandle
06:26:43 * ski would like to be able to define 'return','get','put', etc like
06:27:00 <ski> runState (return a) s = (a,s)
06:27:07 <ski> runState get s = (s,s)
06:27:19 <ski> runState (put s) _ = ((),s)
06:27:29 <Philippa> ski: build a GADT AST, do the obvious
06:27:29 <jethr0> anyone know about forking in haskell?
06:27:31 <Philippa> it works
06:27:36 <Philippa> I've *done* that for the state monad
06:27:42 <lightstep> @index forkIO
06:27:42 <lambdabot> Control.Concurrent
06:27:48 <ski> Philippa : no, return should not be a constructor
06:27:56 <jethr0> lightstep: my question is _way_ more complicated :)
06:27:57 <ski> i want
06:28:04 <ski> instance Monad (State s)
06:28:04 <Philippa> why not? (or at least, a wrapper around one)
06:28:06 <ski>   where
06:28:17 <ski>   runState (return a) s = (a,s)
06:28:19 <ski>   ...
06:28:20 <ski> ...
06:28:37 <jethr0> i want to open several program (popen-style), write to their stins and read from their stdouts in turn
06:28:38 <ski> instance MonadState s (State s)
06:28:39 <ski>   where
06:28:48 <ski>   runState get s = (s,s)
06:28:50 <ski>   ...
06:28:51 <ski> etc
06:28:53 <jethr0> i've tried runInteractiveCommand but have run into blocking issues
06:29:05 <ski> i.e. not a definition of a 'runState' function
06:29:15 <ski> 'runState' is defined by
06:29:31 <palomer> Philippa: how's your GADT AST tutorial coming along? I think ill be ready to tackle it in a few weeks
06:29:34 <ski> newtype State s a = MkState {runState :: s -> (a,s)}
06:29:37 <jethr0> anyone used "runInteractiveComannd"?
06:29:46 <ski> i.e. it should just be a deconstructor
06:29:55 <Philippa> palomer: haven't written any more in a while :-( Mostly doing haskell' work atm, though if you keep prodding me I may well get back to it
06:29:57 <Philippa> (I'd like to)
06:30:05 <ski> Philippa : see ?
06:30:18 <jethr0> .
06:30:36 <Philippa> ski: hrmm, yeah. Did I show you the tutorial palomer mentioned btw?
06:30:51 <ski> (Philippa : btw, i think your 'return',etc as constructors breaks monadic laws (unless you make an ADT))
06:30:55 <Philippa> (it proceeds to translate away the AST to give a normal implementation via one that doesn't compile)
06:31:05 <ski> hm, which tutorial ?
06:31:24 <Philippa> 'snot finished yet. Have a poke around my WIP stuff on the TMR wiki, I think it's still publically readable
06:31:27 <palomer> Philippa: will haskell' contain anything that ghc doesn't?
06:31:35 <Philippa> palomer: not known yet, but a possibility
06:31:38 <ski> Philippa : ah, that, yes i've looked at
06:32:11 * palomer hits the sml/nj build system
06:32:16 <Philippa> while strictly speaking I didn't fill in the export info to make it abstract, that was the intention
06:32:35 <ski> ok
06:32:47 <ski> (since you need a quotient)
06:33:51 <ski> anyway, i think the above definition forms reads nicely, equationally ..
06:33:52 <Philippa> ?
06:34:44 <ski> Bind m Return = m   -- according to monadic law, i.e.
06:35:29 <ski> so, you need to ensure the difference can't escape from the ADT .. i.e. you represent equivalence classes by representants of them
06:36:39 <Philippa> yeah, the equivalance on the AST'd be equivalent-upon-evaluation
06:37:07 <Philippa> although admittedly once abstract the only thing you could do with the AST's build another computation or run it anyway
06:37:20 <cinema> Philippa, can you give me the URL of your tutorial about GADT ?
06:37:37 <Philippa> cinema: it's not a GADT tutorial, it just happens to use them because some of the code doesn't type without them
06:37:52 <ski> yes, and by running it, you can't extract info about what representant was used to encode an equivalence class
06:38:04 <cinema> Philippa, that's Ok, I'd like to have a look
06:38:10 <Philippa> also, it's not complete yet - it's mostly about implementing monads, and why it shouldn't be a black art
06:39:19 <cinema> I'm using GADTs to implement DSELs, and I'd like to look at algebraic simplification examples
06:39:36 <Philippa> http://www.haskell.org/tmrwiki/PhilippaCowderoy_2fWIP_2fMonadArticleThingy
06:40:11 <cinema> Philippa, Thanks, I'm looking at it
06:40:25 <Philippa> I eliminate the AST type entirely in the first transformation - which IIRC I don't get around to specifying exactly what it is yet, but hopefully you'll figure it out
06:43:17 <cinema> Philippa, It's interesting. I'll try it (Monads via GADTs)
06:44:06 <ski> Philippa : i remember doing similar things on a course, only we didn't have GADTs then, so we had to CPS-encode the stuff
06:44:29 <cinema> A lot of things have been written using phantom types, and could now be rewritten with GADTs
06:44:45 <Philippa> yeah, that figures. Sticking something like that on the web'll help shift it beyond just being folklore passed on to a few students though
06:44:55 <cinema> For instance Pan & Vertigo, but also examples from SYB
06:50:48 <jethr0> @hoogle fdClose
06:50:48 <lambdabot> No matches found
06:52:47 <jethr0> @hoogle closeFd
06:52:48 <lambdabot> No matches found
06:53:07 <jethr0> @hoogle fdToHandle
06:53:07 <lambdabot> No matches found
06:55:45 <shapr> @hoogle spjSecretBackDoor
06:55:46 <lambdabot> No matches found
06:56:46 <jethr0> :)
06:57:10 <shapr> hiya jethr0 
06:57:15 <jethr0> hey
06:57:28 <jethr0> you know anything about forking in haskell?
06:57:40 <jethr0> i want to open several program (popen-style), write to their stins and read from their stdouts in turn
06:57:45 <jethr0> i've tried runInteractiveCommand but have run into blocking issues
06:58:03 <basti_> jethr0: did you try forkIO?
06:58:07 <jethr0> hmm
06:58:15 <shapr> I've seen a bunch of discussion about forking on the mailing lists.
06:58:24 <shapr> juhp wrote a Popen module.
06:58:29 <jethr0> problem is, i want to bind the process' stdin and stdout to some handle, and use them
06:58:46 <basti_> dup?
06:58:47 <jethr0> maybe i'll go look there
06:58:59 <jethr0> hmm, nah
06:59:34 <jethr0> like, i want to start to programs A and B. read output from A, alter it, pass it to B, read output from B, alter it, pass it to A, etc
06:59:53 <jethr0> s/to/two/
07:00:30 <shapr> Have you looked at hsshellscript?
07:00:34 <shapr> Maybe it already does something like that?
07:00:43 <jethr0> k, also a good idea
07:01:47 <shapr> I know I've seen mailing list discussion about that specific subject, but I don't remember the results.
07:02:10 <jethr0> result is, that it seems hard in haskell
07:02:21 <jethr0> unidirectional is doable. bidirectional _hard_
07:02:22 <jethr0> :(
07:03:38 <Cale> jethr0: really? I thought they added stuff to handle that well
07:04:09 <Cale> what about runProcess?
07:05:00 <Cale> oh, runInteractiveProcess, as you want to keep the handles
07:05:04 <jethr0> cale: all solutions i've seen with runProcess up till now were unidirectional
07:05:13 <jethr0> same problem there
07:05:26 <Cale> hmm
07:05:52 <jethr0> although, maybe i could do sth with runInteractiveProcess and evil forking...
07:07:29 <jethr0> i'm looking at a solution with runProcess right now
07:07:42 <jethr0> but it says: "/bin/cat: -: Resource temporarily unavailable"
07:07:50 <jethr0> whatever that's supposed to mean
07:17:48 <Cale> Prelude System.IO System.Process> (inp, out, err, ph) <- runInteractiveCommand "cat"
07:17:48 <Cale> Prelude System.IO System.Process> hPutStrLn inp "hello"
07:17:48 <Cale> Prelude System.IO System.Process> hClose inp
07:17:48 <Cale> Prelude System.IO System.Process> hGetLine out >>= print
07:18:39 <Cale> "hello"
07:19:19 <Cale> hFlush works as well as hClose
07:20:00 <Cale> you just have to make sure that the line is actually sent
07:21:02 <Cale> The stdin handle is defaulted to BlockBuffering Nothing
07:21:29 <Cale> If you set it to LineBuffering or NoBuffering, you'll save yourself the need to call hFlush
07:22:01 <jethr0> cool, thx
07:22:39 <jethr0> i've tried that, but maybe i did sth wrong...
07:23:13 <jethr0> i'll try again
07:25:01 <Cale> lisppaste2: url
07:25:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:26:01 <jethr0> i'll paste in a sec :)
07:26:28 <jethr0> nothing specific yet :)
07:26:37 <jethr0> let me try a second on my own...
07:26:58 <lisppaste2> Cale pasted "example" at http://paste.lisp.org/display/16351
07:30:04 <jethr0> ah, i remembered the difference. i was trying to do a single "hGetContents" and work an that lazy string...
07:34:03 * jethr0 slaps himself senseless.
07:34:39 <jethr0> Cale: thx for your help. i had made so many stupid mistakes that not even a psychic could have made sense out of my code, let alone a decent compile *arg*
07:34:51 <basti_> mmmh? ;)
07:35:18 <jethr0> compiler*
07:38:47 <ptolomy> Are IORefs considered "good style"? Or are they more of a last resort thing?
07:38:56 <basti_> hmm
07:38:58 <SamB> for what?
07:39:06 <basti_> they are a thing that you may use in some circumstances
07:39:24 <basti_> though you should (be able to) avoid them in normal code
07:41:05 <Philippa> ptolomy: they're a last resort in one sense, in that if you could use STRefs instead that's probably preferable
07:41:28 <Philippa> if you were going to use a monad with some notion of a reference then there's no shame in using one with a fast implementation though
07:42:08 <Philippa> and if you're building some notion of reference and looking the references up in something with state-like propagation, that's not necessarily a bad thing to do at all
07:42:23 * basti_ nods
07:42:43 <Philippa> and if you need all that /and/ IO, there's not really much room for discussion ;-)
07:42:52 <basti_> the thing is: don't use them to implement a loop counter
07:43:08 <SamB> mmm?
07:43:22 * ptolomy had no intended purpose for them yet.
07:43:45 <basti_> if you're just looking for state, ST is easier
07:43:55 <basti_> you can get stuff out of the ST monad
07:44:08 <basti_> you'd have to thread IO all the way through your program
07:44:08 <Philippa> yeah. Basically, most things are good style when they fit the problem well
07:44:09 <ptolomy> I've seen a few pieces of code using them recently, and I had always placed them up there with unsafeXXX..
07:44:21 <Philippa> they're nowhere near as bad as unsafeXXX
07:44:25 <basti_> -g-
07:44:28 <SamB> I'd place them up further a bit, myself...
07:44:33 <SamB> probably...
07:44:44 <Philippa> references to unsafe code, now /that's/ evil
07:44:48 <SamB> I don't know what I'd want them for
07:44:53 <Philippa> but it's evil because you don't need the IO monad
07:45:31 <Philippa> SamB: I might use them if I had a unification problem that also directly involved IO, for example
07:45:38 <ptolomy> They just look like pointers, malloc, etc in haskell code, and that rather frightens me.
07:45:40 <SamB> mmm
07:45:44 <Philippa> ptolomy: they're not
07:45:53 <SamB> ptolomy: I know what those are for
07:46:07 <Philippa> you can't do anything with an IORef but dereference it to read or write, AFAIK
07:46:24 <ski> in a sense they are (minus pointer arithmetic etc)
07:46:26 <Philippa> pointers and malloc're available elsewhere if you /really/ want them...
07:46:28 <SamB> @hoogle IORef a -> b
07:46:28 <ski> yes
07:46:29 <lambdabot> Prelude.undefined :: a
07:46:29 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
07:46:29 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:46:46 <SamB> okay...
07:46:49 <Philippa> ski: minus pointer arithmetic and all the memory management. newIORef is fundamentally *not* malloc
07:47:04 <SamB> plus, garbage collection
07:47:09 <ski> i guess it depends on how you use malloc ..
07:47:14 <Philippa> you can't accidentally allocate too little space for your value, for example
07:47:14 <ski> m
07:47:29 <Philippa> hell, you can't /deliberately/ do it, however hard you try
07:47:41 <SamB> that is because they are all the same size...
07:47:47 <ski> foo = malloc(sizeof *foo)
07:48:00 <Philippa> ski: sure. But you need that idiom
07:48:19 <ski> granted
07:48:22 <SamB> @type Foreign.Ptr.malloc
07:48:23 <lambdabot> Not in scope: `Foreign.Ptr.malloc'
07:48:30 <SamB> @type Foreign.C.Ptr.malloc
07:48:31 <lambdabot> Couldn't find qualified module.
07:48:31 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
07:48:31 <lambdabot> \\)?
07:48:40 <SamB> @type Foreign.malloc
07:48:41 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
07:49:37 <ptolomy> Foreign.* is a mysterious jungle to me. I peek in meekly, but I lack the courge to step in. Also, I haven't had to.
07:49:41 * ski tends to use named 'pointer' and 'reference' quite interchangeably
07:51:10 <Philippa> IMO they're different things - a pointer when talking code tends to mean something 'physical', whereas a reference is the general concept
07:51:23 <SamB> mmmhmm
07:51:32 <SamB> only StablePtrs aren't
07:51:48 <SamB> or at least, they are not what you would think they are
07:52:05 * Philippa nods
07:52:10 <Philippa> but that's overextended analogy for you
07:53:17 <Philippa> I wouldn't say Java object variables hold pointers though, to give an example
07:53:43 <Philippa> or "foo is bound to bar, it now points to it"
07:54:56 <ski> you'd s/points/references/ ?
07:55:11 <ptolomy> Okay, this question is general as all get-out, but what is a reasonable way to implement a mulit-threaded thing where they all share a mutable data structure? For example, a server that generate ___ for clients, then keeps the results for other clients?
08:05:46 <ptolomy_> blasted work network.
08:06:28 <Philippa> ski: "refers to"
08:06:39 * ptolomy_ hopes he didn't miss the answer to the question he posed..
08:06:40 <Philippa> ptolomy: MVar
08:07:06 <Philippa> although, the server you described can keep all the state in one thread anyway, and just communicate over Chans
08:07:44 <ptolomy> Excellent.
08:08:52 <jonkri> why do i get "Can't find module `Test.QuickCheck'" when i'm using gentoo and ghci? the first line in my program is import Test.QuickCheck
08:09:04 <jonkri> i must have used quickcheck before, this is really wierd. thanks in advance
08:09:36 <Philippa> ptolomy: did you get the "although" line too?
08:09:56 <ptolomy> I did. I'm looking at the Chan docs right now.
08:11:13 <lispy> i must have the best luck
08:11:33 <lispy> i can't count the number of times i've won the internet or international lottery, and i haven't even bought a ticket
08:12:10 <ptolomy> Does chapter 10 of YAHT exist somewhere?
15:16:41 <SamB> @index liftIO
15:16:41 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
15:16:41 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
15:16:41 <lambdabot> Control.Monad.List
15:17:35 <TuringTest> :type Control.Monad.Tracs.liftIO
15:37:16 <jonkri> what does "Non-exhaustive patterns in function ..." means in general?
15:37:36 <Philippa> there's some value that isn't covered by any of the patterns
15:37:56 <Philippa> for example: foo (Just a) = bar; <- inexhaustive, doesn't cover the Nothing case
15:38:03 <jonkri> hmm
15:38:14 <jonkri> thanks
15:41:18 <SamB> whats an easy way to create a textbox in Gtk2Hs?
15:45:22 <dcoutts> SamB, like a single line edit box or a big multi-line text editor?
15:45:45 <jonkri> Philippa, apparantly it could also mean that i had forgot the base case ;-)
15:46:50 <SamB> dcoutts: multi-line
15:47:13 <SamB> dcoutts: I'm trying to get that Z-machine emulator going
15:47:41 <dcoutts> SamB, See Graphics.UI.Gtk.Multiline.*
15:47:50 <dcoutts> in particular:
15:47:51 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Multiline-TextBuffer.html
15:47:56 <SamB> okay
15:47:58 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Multiline-TextView.html
15:48:08 <SamB> I said *easy*
15:48:28 <dcoutts> textview <- textViewNew
15:48:35 <dcoutts> SamB, there, easy :-)
15:48:42 <SamB> okay
15:50:17 <dcoutts> buffer <- get textview textViewBuffer
15:50:41 <dcoutts> set buffer [ textBufferText := "blah \n blah" ]
15:51:21 <palomer> @hoogle (x -> ST s y) -> [z] -> ST s y
15:51:22 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
15:51:22 <lambdabot> Control.Monad.ST.fixST :: (a -> ST s a) -> ST s a
15:51:29 <SamB> do I need some kind of a frame around this?
15:51:34 <palomer> @hoogle (x -> ST s y) -> [x] -> ST s y
15:51:35 <lambdabot> No matches, try a more general search
15:51:39 <palomer> is there a function like that?
15:51:42 <palomer> (similar to sml's app)
15:52:46 <SamB> hmm. Apparantly GHC is not smart enough to detect that my program will not work.
15:53:07 <palomer> ghc isn't sound?
15:53:07 <palomer> whoa.
15:53:23 <SamB> no, it just doesn't notice my program is deadlocked
15:53:28 <palomer> oh
15:53:42 <SamB> I thought it would, its a pretty simple deadlock...
15:54:30 <Beelsebob> > let fac 0 = 1; fac n = n * (fib (n - 1)); choose n m = ((fac n) / ((fac m) * (fac (n - m)))) in choose 50 5 * choose 9 2
15:54:31 <lambdabot>  Not in scope: `fib'
15:54:34 <Beelsebob> bah
15:54:43 <Beelsebob> > let fac 0 = 1; fac n = n * (fac (n - 1)); choose n m = ((fac n) / ((fac m) * (fac (n - m)))) in choose 50 5 * choose 9 2
15:54:44 <lambdabot> 7.627536e7
15:55:26 <Beelsebob> > let fac 0 = 1; fac n = n * (fac (n - 1)); choose n m = ((fac n) / ((fac m) * (fac (n - m)))) in (choose 50 5 * choose 9 2) / 4
15:55:27 <lambdabot> 1.906884e7
15:55:33 <palomer> @hoogle app
15:55:34 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
15:55:34 <lambdabot> Data.PackedString.appendPS :: PackedString -> PackedString -> PackedString
15:55:34 <lambdabot> Data.Ratio.approxRational :: RealFrac a => a -> a -> Rational
15:55:49 <Igloo> fac n = product [2..n], incidentally
15:57:06 <palomer> app f [x] = f x ; app f (h:t) = f h >> app t <--does this function already exist?
15:57:28 <palomer> or, rather, app f [] = return () ; app f (h:t) = f h >> app t
15:57:51 <Igloo> You probably want mapM_ f
15:58:03 <palomer> @hoogle mapM_
15:58:04 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
15:58:04 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
15:58:04 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
15:58:12 <palomer> yes, actually
15:58:14 <palomer> why the underscore?
15:58:23 <Igloo> mapM returns m [b]
15:58:35 <palomer> why not call it something else than?
15:58:46 <Igloo> It is called something else. mapM_
15:59:09 <palomer> something else than mapM_
15:59:45 <Igloo> Have you got a better name? There are others that append an _, incidentally; sequence is the only one that I can remember OTTOMH
16:02:40 <jethr0_> hi, anyone done state arrows before?
16:03:18 <Beelsebob> > let fibs = mkFibs 1 1; mkFibs n m = n:(mkFibs m (n+m)) in fibs !! 10
16:03:19 <lambdabot> 89
16:05:21 <SamB> dcoutts: so what do I put my TextView into?
16:05:41 <dcoutts> SamB, usually a scroll area
16:05:51 <SamB> a scroll area...
16:06:27 <SamB> what do I put that in?
16:06:28 <dcoutts> ScrolledWindow
16:06:40 <dcoutts> is the name, not scroll area
16:06:53 <dcoutts> you can put that in whatever you like
16:07:05 <dcoutts> a top level window, whatever
16:07:14 <SamB> I don't care if it is in *anything*, I just want to see it on the screen ;-)
16:07:28 <dcoutts> well start with a simple window
16:07:34 <SamB> which kind is that?
16:07:36 <dcoutts> win <- windowNew
16:08:12 <SamB> how do I run the loop then?
16:08:17 <dcoutts> mainGUI
16:08:26 <dcoutts> SamB, take a look at the hello world program
16:11:24 <ADEpt> @index toHex
16:11:24 <lambdabot> bzzt
16:11:41 <ADEpt> @index hex
16:11:42 <lambdabot> bzzt
16:13:06 <ADEpt> whats the best way to dump String into it's hexadecimal representation? something like hexa str = concatMap (hex.ord) str ?
16:14:04 <Igloo> concatMap (flip Numeric.showHex "" . ord)
16:14:44 <Igloo> Or you could fold it, but that would probably not be worth the reduced readability
16:14:53 <Cale> foldr showHex "" (map ord str)
16:15:10 <Cale> It's not so bad, showHex is designed to be foldable
16:15:29 <Igloo> Oh, yeah, it's not as bad as I thought it would be
16:16:45 <ADEpt> cool. now I only need to find a way to make 9 into "09", not "9" :)
16:17:29 <ADEpt> or maybe I dont
16:17:40 <ADEpt> Igloo, Cale: thanks a lot!
16:18:35 <palomer> Igloo: yeah, app
16:19:12 <Igloo> palomer: So you want 2 functions that do almost the same thing but have completely different names?
16:19:20 <SamB> hmm, my program won't compile right with -fvia-C because of header issues...
16:19:37 <jethr0_> > let fill x n = reverse . take n . (++ repeat "0") . reverse in fill "9" 2
16:19:37 <lambdabot>  add an instance declaration for (Show ([[Char]] -> [[Char]]))
16:19:42 * SamB tries updating to more recent GTK
16:19:49 <jethr0_> > let fill n = reverse . take n . (++ repeat "0") . reverse in fill 2 "9"
16:19:50 <lambdabot> Couldn't match `[Char]' against `Char'
16:20:00 <palomer> @hoogle join
16:20:00 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
16:20:00 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
16:20:00 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
16:20:08 <palomer> @hoogle inject
16:20:09 <lambdabot> No matches found
16:20:19 <palomer> Igloo: yes
16:20:46 <palomer> or we should start having conventions for naming functions that deal with lists of length equal or greater than 1
16:20:49 <araujo> Hello.
16:22:32 <palomer> mapM0 would have been more intuitive
16:22:42 <palomer> the _ doesn't tell us anything!
16:23:11 <Philippa> I dunno, I see it as an analogy to the wildcard in pattern-matches - "don't care"
16:23:53 <Igloo> The 0 suffix is used by functions that deal with NUL-terminated C strings
16:25:42 <palomer> mapMNil
16:25:51 <Philippa> that's even worse
16:26:04 <Philippa> I don't think _ is any less mnemonic than that in the context of Haskell
16:27:15 <musasabi> _ means in haskell usually something that is not cared about
16:27:48 <musasabi> thus having mapM_ translates to "it is a map", "monadic" and "we don't care about the result"
16:29:44 <palomer> we need to start a linguistic revolution in variable naming
16:30:08 <palomer> @hoogle mapM
16:30:08 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:30:08 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:30:08 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:30:49 <musasabi> we could just switch to greek letters for all type names to begin with?
16:30:50 <palomer> @hoogle concat
16:30:51 <lambdabot> Data.List.concat :: [[a]] -> [a]
16:30:51 <lambdabot> Prelude.concat :: [[a]] -> [a]
16:30:51 <lambdabot> Data.List.concatMap :: (a -> [b]) -> [a] -> [b]
16:31:05 <palomer> @hoogle join
16:31:05 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
16:31:05 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
16:31:05 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
16:31:27 <palomer> is there a function (a -> a -> a) -> m [a] -> m a ?
16:31:34 <palomer> kind of like foldl1
16:31:37 <palomer> @hoogle foldl1
16:31:38 <lambdabot> Data.List.foldl1 :: (a -> a -> a) -> [a] -> a
16:31:38 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
16:31:38 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
16:31:47 <palomer> yeah, foldl1 for monads
16:31:56 <palomer> @hoogle mfold
16:31:56 <lambdabot> No matches found
16:32:18 <musasabi> @type foldM
16:32:19 <lambdabot> Not in scope: `foldM'
16:32:26 <musasabi> @type Control.Monad.foldM
16:32:27 <lambdabot> forall a (m :: * -> *) b.
16:32:27 <lambdabot> (Monad m) =>
16:32:27 <lambdabot> (a -> b -> m a) -> a -> [b] -> m a
16:33:10 <musasabi> @type (\f (x:xs) -> Control.Monad.foldM f x xs)
16:33:11 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> a -> m a) -> [a] -> m a
16:33:28 <musasabi> and you can get the monadic version easily.
16:34:49 <SamB> dcoutts: how can I make this textview not so freely editable?
16:35:41 <dcoutts> set textview [ textViewEditable := False ]
16:35:59 <dcoutts> SamB, it's in the docs :-)
16:36:09 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Multiline-TextView.html#6
16:38:46 <dons> moin
16:39:13 <dcoutts> moin dons
16:39:46 <dcoutts> dons, so what do you think about this EclipseFP thing then?
16:40:07 <dons> ah, need to read that thread.
16:40:20 <dons> (I've been reading my mail from the bottom up today :)
16:40:23 <dcoutts> they have the problem that it's done in java
16:40:36 <dons> that's a problem.
16:40:39 <dcoutts> just like the MS VS is done ine Com/.net whatever
16:40:48 <dcoutts> so we still have definate advantages
16:40:52 <dcoutts> dons, oh, other interesting news on the hIDE front...
16:40:58 <dons> yep?
16:41:37 <dcoutts> I got an email from the Epigram team asking me and Axel to come up to talk to them about Gtk2Hs and "your own 
16:41:37 <dcoutts> efforts in implementing a Haskell development system."
16:41:51 <dons> ah, interesting.
16:42:04 <dons> they had some ideas for yi about a year ago, as well.
16:42:09 <dcoutts> I'm going to see them at the beginning of next month
16:42:15 <dons> cool.
16:42:25 <dcoutts> show off some demos etc
16:42:49 <dcoutts> try and persuade them that gtk+/pango/cairo can make really nice Epigram editor
16:42:59 <dons> :)
16:43:03 <dcoutts> with nice latex style output, but wisiwig
16:43:34 <dons> yah, it would be good to get some more hands on deck...
16:43:48 <dcoutts> their previous emacs thing was wysiwyg but ascii
16:44:27 <Philippa> dcoutts: if this means you're in nottingham at some point, feel free to gimme a yell... and cool
16:44:34 <dcoutts> anyway, and the hIDE angle is that it might be possible to add an epigram as just another browiser view
16:44:39 <dcoutts> like we've done with Yi
16:45:05 <dcoutts> Philippa, are you in the nottingham CS dept?
16:45:43 <dons> yeah, that would be good for epigram
16:45:43 <dcoutts> if so I'm sure you can come to the presentation
16:45:56 <Philippa> I'm a suspended undergrad atm
16:46:03 <Philippa> so... "possibly"
16:46:06 <dcoutts> :-)
16:46:40 <dcoutts> dons, it ought to be easy actually, we can already do different editors based on file type or url type
16:46:49 <dons> yeah, I reckon.
16:46:54 <dons> @seen musasabi
16:46:55 <lambdabot> musasabi is in #haskell-blah and #haskell. Last spoke 13 minutes and 26
16:46:55 <lambdabot> seconds ago.
16:47:11 <dcoutts> eg we'll probablby have a custom gui editor for .cabal files
16:48:09 <dcoutts> a bit like a file manager, where you get a default editor for a file but you can select a different if there are multiple suitable ones
16:48:09 <dons> musasabi, I asked Isaac about why some of our programs haven't been rerun, and so on. He says: to get a program rerun, you have to touch the file, *and* changes to the  Makefile aren't copied to gp4 (you have to make a "feature request").
16:48:39 * dcoutts goes off to bed
16:48:47 <dcoutts> g'night folks
16:48:54 <Philippa> seeya
16:48:59 <dons> night
16:52:47 <musasabi> dons: grah. But I touched the file at least in the mandelbrot case.
16:53:07 <musasabi> dons: the changes in the Makefile are not copied sounds very evil.
16:53:14 <dons> ye!
16:53:15 <dons> yes
16:53:53 <dons> do you know what a "feature request" is? is that a request for Isaac to manually update his files on the gp4?
16:54:35 <dons> ah, also, I have a faster spectral-norm for you: http://www.haskell.org/hawiki/SpectralEntry
16:55:01 <dons> using IOUArrays unboxed much better than the arrays in ST. I don't know why
16:55:09 <ihope> @babel fr en Chrie, je t'adore!
16:55:11 <lambdabot>  Chrie, I adore you!
16:56:44 <musasabi> dons: yes, via the tracker system on the alioth webpages.
16:56:52 <dons> ah. I see.
16:57:06 <dons> it's weird, isn't it that -fexcess-precision can't go in an OPTIONS pragma
16:57:16 <dons> can you think of why that is, or is it a ghc bug?
16:57:31 <dons> i guess it must be a 'static' flag
16:57:41 <dons> but it seems strange that it would be
16:57:50 <musasabi> yes, that is probably the explanation.
16:59:13 <lispy> for those of you that do research, do you find that you only want to work on things that will yield a publication?
16:59:26 <dons> NO
16:59:28 <dons> :)
16:59:41 <dons> I want to work on things that hardly ever yield a publication ;)
17:00:17 <lispy> yeah, me too
17:00:54 <dons> maybe phd students aren't quite the same though. they have more freedom (at least in comp sci)
17:01:00 <lispy> i mentioned the code coverage tool and one of my advisors cautioned against it, on the grounds that functional researchers are more interested in proving than testing :)
17:01:02 <dons> (at least in some unis)
17:01:29 <dons> bah. we'd encourage you to hack on it, at unsw at least.
17:01:40 <lispy> but my motivation for wating to work on it is related to how useful it would be for darcs
17:01:47 <dons> maybe it depends on the supervisor
17:01:51 <lispy> true
17:02:16 <lispy> yeah, i need to look at ghc a bit more, i was going to build the latest source on my machine and then start looking at the code, but the build doesn't terminate
17:02:59 <lispy> it was on the same part of the build after 3 days
17:06:04 <vincenz> dons: hey, I have some questions about lambdabot
17:06:58 <dons> ah, yes. ask away
17:07:06 <vincenz> well how did you get it to compile
17:07:07 <dons> I notice you've been building it?
17:07:15 <vincenz> I get a lot of warnings when compiling it
17:07:15 <dons> did you check the build notes on the wiki?
17:07:22 <vincenz> and actually had to change the makefile to remove -Wall to make it work
17:07:24 <dons> which version of ghc?
17:07:27 <vincenz> 6.4
17:07:32 <vincenz> dons: I did all the prereqs
17:07:35 <vincenz> but for instance
17:07:41 <dons> ah, 6.4 has a bogus warning about multiple imports
17:07:44 <vincenz> LambdaBot imports Prelude and GHC;IO
17:07:47 <dons> thiis goes away with 6.4.1
17:07:57 <vincenz> and why does lambdabot export the std liftIO?
17:08:06 <dons> not sure.
17:08:09 <vincenz> also
17:08:16 <vincenz> if I disable some files in config.mk.in
17:08:16 <dons> oh, to avoid an extra import.
17:08:20 <vincenz> it still compiles e
17:08:22 <vincenz> em
17:08:30 <musasabi> dons: have you tried using STUArray instead of IOUArray? that is faster sometimes.
17:08:31 <vincenz> so I renamed em
17:08:50 <dons> well, I tried optimising your STUArray, and couldn't get it to unbox
17:09:05 <dons> so I wrote a new entry with IOArray, which did unbox properly, and ran a  bit faster
17:09:17 <dons> possibly I do other magic though.
17:09:33 <dons> vincenz, they still compile but they're not loaded or linked
17:09:45 <dons> which plugins are loaded are separate from which ones are compiled
17:10:04 <dons> config.mk only specifies which plugins to load.
17:10:13 <dons> the build system by default compiles everything.
17:10:17 <vincenz> ah
17:10:27 <vincenz> cause I removed some options from Config.hs
17:11:03 <vincenz> also... i compiled hoogle yet when I @hoogle it tells me there's an error
17:11:18 <dons> I'd need more info than that to debug it :)
17:11:34 <vincenz> ary.hs:1:0:
17:11:34 <vincenz>     Warning: `IO' is imported more than once:
17:11:34 <vincenz>                imported from GHC.IOBase at Binary.hs:28:25-30
17:11:34 <vincenz>                imported from Prelude at Implicit import declaration
17:11:51 <dons> yes, that's a 6.4 bug. you can ignore it.
17:11:56 <dons> I suggest updating to 6.4.1
17:12:07 <vincenz> and a lot of these
17:12:09 <vincenz> Plugins/System.hs:1:0:
17:12:09 <vincenz>     Warning: `liftIO' is imported more than once:
17:12:09 <vincenz>                imported from Control.Monad.Trans at Plugins/System.hs:16:33-38
17:12:09 <vincenz>                imported from Lambdabot at Plugins/System.hs:6:0-15
17:12:18 <SamB> argh!
17:12:24 <vincenz> why does Lambdabot export liftIO?
17:12:30 <SamB> dcoutts has gone to bed!
17:12:49 <dons> vincenz, to avoid other modulles needing to also import an mtl module
17:12:59 <dons> all they need to do is import Lambdaboot, and they get everything they need
17:13:02 <SamB> who will provide me with information I could easily find in the documentation (according to him)!
17:13:03 <vincenz> dons: but...liftIO is not defined in lambdabot...it's the std liftio
17:13:07 <dons> sure.
17:13:11 <dons> it's reexported
17:13:36 <dons> it saves one import in the plugins. which makes writing plugins easier.
17:13:37 <lispy> that seems to be a common practice actually
17:13:37 <vincenz> ah, I thought it had to do with security... like plugins only allwoed to load stuff from lambdabot or something
17:13:53 <vincenz> also, why is fastpackedstring nommap needed?
17:14:06 <vincenz> instead of mmap one
17:15:21 <palomer> is there a function that acts like foldl . map ?
17:15:35 <vincenz> palomer: foldlmap
17:15:43 <vincenz> where foldlmap = foldl. map
17:16:01 <vincenz> 02:14 <@vincenz> @hoogle a
17:16:01 <vincenz> 02:14 < oasisbot> An error occured.
17:16:16 <palomer> @hoogle foldlmap
17:16:17 <lambdabot> No matches found
17:16:26 <palomer> @hoogle mapconcat
17:16:27 <lambdabot> No matches found
17:16:37 <vincenz> @hoogle concatmap
17:16:37 <lambdabot> Data.List.concatMap :: (a -> [b]) -> [a] -> [b]
17:16:37 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
17:19:27 <dons>   vincenz, it isn't really. if mmap works for you, use it. i was just trying to save the user one decision to make.
17:19:36 <vincenz> ah ok
17:19:38 <palomer> why don't constructor names have the same lexical structure as normal function names?
17:19:39 <vincenz> which is better
17:19:51 <palomer> (ig, they  can't start with >)
17:19:52 <palomer> eg
17:20:42 <SamB> anyone know how text tags work in Gtk?
17:20:53 <palomer> SamB: sure
17:21:32 <vincenz> dons: where are the todos stored?
17:21:49 <palomer> oh crap
17:21:56 <palomer> I just spent 2 weeks working on something
17:21:58 <palomer> and I lost it
17:22:14 <SamB> palomer: It looks like I can use them to make only part of my text buffer editable?
17:22:20 <dons> vincenz, in State/todo, I think
17:22:24 <tony2> dons, I read your really quite excellent post on analysingi core output, and learned a lot I think. I am assuming it's the same don? 
17:22:24 <dons> also, in TODO
17:22:31 <dons> yes :)
17:22:34 <dons> I'm glad it was useful
17:22:40 <vincenz> thx
17:22:48 <tony2> :)
17:22:58 <palomer> oh, phew, still there
17:23:10 <tony2> the shootout has been good for learning from examples in general.
17:23:38 <dons> it certainly improved my skills at convincing ghc to generate the right code
17:23:46 <palomer> SamB: yeah, you can
17:24:04 <musasabi> dons: committed.
17:24:11 <SamB> palomer: can you tell me anything about how to use tags?
17:24:12 <palomer> SamB: actually, I'm not proof positive which has higher priority, the textview attributes or the text tag attributes
17:24:16 <araujo> SamB, yes you can
17:24:35 <dons> musasabi, cheers. what should we do about the two makefile issues for nbody and mandelbrot?
17:25:35 <musasabi> dons: file a request on the alioth tracker probably.
17:25:45 <dons> and we should try to get a regex entry that actually terminates inside of an hour. it's worth 5 points just to terminate.
17:25:46 <palomer> SamB: http://www.rafb.net/paste/results/4FeQmo85.html
17:25:51 <araujo> SamB, Generally speaking goes like, you need to create a tag, then add this tag into a tag-table, and this tag-table should be used to create the text-buffer
17:25:54 <dons> hmm. tricky tricky
17:26:06 <araujo> It's pretty straightforward following the api
17:26:18 <araujo> dons, hiya!!!
17:26:55 <palomer> SamB: then you need       textViewApplyTag textview tagName iter1 iter2
17:26:57 <dons> hey araujo.
17:28:44 * palomer wishes there was a combination ReaderT and StateT
17:29:10 <araujo> palomer, Well, he just could apply the tag to the buffer and this one to the textview too.
17:29:16 <araujo> Assuming he uses a textbuffer.
17:29:28 <palomer> apply the tag to the buffer?
17:29:36 <palomer> there's a textBufferApplyTag ?
17:29:46 <palomer> they probably do the same thing
17:29:47 <araujo> Yup
17:29:56 <palomer> I like to ignore that text buffers exist
17:30:02 <araujo> I don't
17:30:09 <araujo> It's the object im working aroudn actually.
17:30:22 <palomer> why not work around textviews?
17:30:43 <araujo> Because i need to tweak the textbuffer
17:30:58 <araujo> Those are kind of layers on top of this tweaked buffer.
17:31:02 <palomer> oh, in that case
17:31:37 <palomer> so, erm, how does one combine ReaderT and StateT?
17:33:48 <palomer> @hoogle Reader
17:33:49 <lambdabot> Control.Monad.Reader.Reader :: Reader r a
17:33:49 <lambdabot> Control.Monad.Reader.Reader :: r -> a -> Reader r a
17:33:49 <lambdabot> Control.Monad.Reader.ReaderT :: ReaderT r m a
17:34:07 <palomer> @hoogle runST
17:34:08 <lambdabot> Control.Monad.ST.Lazy.runST :: ST s a -> a
17:34:08 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
17:34:08 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i
17:34:08 <lambdabot> e
17:34:17 <palomer> @hoogle State
17:34:18 <lambdabot> Test.HUnit.Base.State :: State
17:34:18 <lambdabot> Test.HUnit.Base.State :: Path -> Counts -> State
17:34:18 <lambdabot> Control.Monad.State.State :: State s a
17:34:23 <dons> ah, chris has written a (yet faster) nbody :)
17:34:28 <dons> @karma+ TuringTest
17:34:28 <lambdabot> TuringTest's karma raised to 2.
17:37:07 <palomer> @hoogle runReaderT
17:37:08 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
17:43:09 <palomer> @hoogle readerStateT
17:43:10 <lambdabot> No matches found
17:43:15 <palomer> @hoogle ReaderT
17:43:16 <lambdabot> Control.Monad.Reader.ReaderT :: ReaderT r m a
17:43:16 <lambdabot> Control.Monad.Reader.ReaderT :: r -> m a -> ReaderT r m a
17:43:16 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
17:43:30 <palomer> @kind Control.Monad.Reader.ReaderT
17:43:31 <lambdabot> * -> (* -> *) -> * -> *
17:44:21 * palomer 's brain is going to fry
17:45:30 <palomer> @hoogle Reader
17:45:30 <lambdabot> Control.Monad.Reader.Reader :: Reader r a
17:45:30 <lambdabot> Control.Monad.Reader.Reader :: r -> a -> Reader r a
17:45:30 <lambdabot> Control.Monad.Reader.ReaderT :: ReaderT r m a
17:45:37 <palomer> @kind Control.Monad.Reader.Reader
17:45:38 <lambdabot> * -> * -> *
17:45:41 <ihope> Hmm.
17:46:48 <palomer> @hoogle StateT
17:46:49 <lambdabot> Control.Monad.State.StateT :: StateT s m a
17:46:49 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
17:46:49 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
17:47:11 <palomer> oh my god, ReaderStateT takes 3 parameters!
17:47:35 <palomer> err, 4 parameters
17:47:35 <palomer> whoa.
17:48:43 <palomer> where's cale when you need'em
17:50:22 <palomer> Urk! Inventing strangely-kinded void TyCon:
17:50:22 <palomer>     ZCt{tc a1vW}
17:50:22 <palomer>     (* -> *) -> * -> *
17:50:32 <palomer> what kind of an error message is this?
17:52:12 <palomer> http://www.rafb.net/paste/results/FdmMeF82.html <--shouldn't this work?
17:53:49 <palomer> http://www.rafb.net/paste/results/mXuY7S80.html
17:53:57 <palomer> forgot the error messages
17:55:17 <palomer> http://www.rafb.net/paste/results/9sDpVU30.html
17:55:42 <palomer> oh my, it compiles with -fno-monomorphism-restriction
17:55:46 <Cale> hello
17:55:53 <palomer> why isn't -fno-monomorphism-restriction on by default?
17:56:20 <Cale> Because H98 says that the monomorphism restriction is part of the language
17:56:39 <palomer> is there a reason for this?
17:57:07 <Philippa> yes
17:57:10 <Philippa> RTFReport
17:58:11 <palomer> but I only run into it sporadically:o
17:58:49 <Cale> yeah, it's pretty annoying
17:59:26 <Cale> I kind of think it should be removed, and compilers/runtimes should just find smarter ways to optimise code and restore sharing.
18:01:17 <Cale> Wow, those look like pretty internal messages
18:01:18 <SyntaxNinja> (10:57:00) palomer: haskell' doesn't look that interesting
18:01:49 <SamB> palomer: how do I wait for the user to hit enter?
18:01:53 <Cale> You should probably report that. (The 'Urk!' messages)
18:02:03 <palomer> SamB: you catch the signal
18:02:18 <SamB> palomer: but I just want to do it once :-(
18:02:36 <palomer> SamB: so use state!
18:02:45 <SamB> state!
18:02:57 <SamB> I don't want to write my state out longhand!
18:02:59 <palomer> SamB: or, you can do it and then clear the event handling 
18:04:25 <palomer> whoa, I coded my first monad by myself
18:04:43 <palomer> SyntaxNinja: it doesn't! I mean, it's only interesting for people who don't use ghc
18:04:47 <Philippa> palomer: from scratch, or from transformers?
18:04:49 <Philippa> no, it's not
18:04:50 <dons> it's a known message, though, the Urk
18:04:53 <palomer> Philippa: transformers
18:04:58 <dons> it's even in @ghc :)
18:05:02 <Philippa> it's interesting for people who write code that's ever expected to be used with something other than ghc
18:05:14 <palomer> Philippa: yeah, that's what I meant
18:05:24 <Philippa> and that *should* be most people
18:05:30 <SyntaxNinja> palomer: it sounded to me like you were interested in defaults :)
18:05:31 <palomer> but it isn't :P
18:05:37 <Philippa> it's me, amongst others
18:05:42 <palomer> http://www.rafb.net/paste/results/MYG8yO60.html
18:05:50 <palomer> SyntaxNinja: default what?
18:06:06 <SyntaxNinja> palomer: defaults like whether or not the monomorphism restriction is enforced
18:06:09 <Philippa> thus far I've been surprisingly conservative in what Flippi uses (although it does use the current hierarchical libs because they're as effective a choice of standard library as any other)
18:06:32 <SyntaxNinja> for production code, IMO, it would be very attractive to be able to rely on more than just GHC.
18:06:36 * Philippa should put more work into her proposal, too
18:07:29 <SyntaxNinja> Philippa: go forth!
18:07:43 <Philippa> I can happily implement it for H-M because I already have most of the code for that lying about on my HD, but that's not really what's meant by "implemented" :-)
18:08:16 <Philippa> 'k. Be warned I'm pushing tired enough to do stupid stuff again though
18:08:24 <palomer> @hoogle lift
18:08:24 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
18:08:24 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
18:08:24 <lambdabot> a
18:08:24 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
18:08:30 <palomer> lift is part of which typeclass?
18:08:38 <Philippa> MonadTrans
18:09:32 <Philippa> internally when I'm stacking a load of transformers I tend to write liftToSomeLevel funcs so if I find cause to add another transformer I only have to alter those
18:09:46 <Philippa> I just don't expose them to the outside world unless there's a really good reason to
18:10:13 <palomer> the lift is going to be the lift of the inner most transformer
18:10:44 <palomer> @hoogle get
18:10:45 <lambdabot> Text.ParserCombinators.ReadP.get :: ReadP Char
18:10:45 <lambdabot> Text.ParserCombinators.ReadPrec.get :: ReadPrec Char
18:10:45 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
18:10:46 <SyntaxNinja> gotta go home
18:10:47 <Cale> yeah, I don't tend to think of monad transformed monads as something which you'd write a lot of code in directly. You always newtype them and derive the stuff you need.
18:11:22 <SamB> Cale: I do?
18:11:36 <Cale> well, you might not personally :)
18:11:36 <palomer> is MonadTrans derivable?
18:11:37 <Philippa> depends what you're doing. Often I don't want to expose all the state-like layers directly, for example
18:11:47 <Cale> but it tends to be a good idea
18:11:48 <Philippa> palomer: Not that I know of
18:11:53 <Cale> yeah, it is
18:11:54 <SamB> Cale: I admit that my Z-machine interpreter would probably benefit from such treatment
18:11:56 <palomer> oh, cale was using derive informally
18:11:58 <Philippa> :-)
18:11:59 <Cale> newtype derivable
18:12:13 <palomer> so, for my ReaderStateT monad transformer, what classes should I instantiate?
18:12:14 <Philippa> (I qualify my statements for a reason ;-)
18:13:18 <Cale> well, you might derive the outer of the two transformers, and write the other instance by lifting
18:13:19 <palomer> @hoogle ask
18:13:19 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
18:13:19 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
18:13:19 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer.indexMask :: StateVar GLuint
18:13:46 <Cale> (that's a little mangled, hope it's clear what I mean)
18:14:54 <lispy> @hoogle interactive
18:14:54 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle,
18:14:54 <lambdabot> Handle, ProcessHandle)
18:14:54 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe
18:14:54 <lambdabot> FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle,
18:14:54 <lambdabot> ProcessHandle)
18:14:55 <Cale> Like, if you have something like  newtype ReaderStateT r s m a = ReaderStateT (ReaderT r (StateT s m) a)
18:15:03 <Cale> then you'd derive MonadReader r
18:15:14 <Cale> and write an instance for MonadState s
18:15:18 <palomer> so I'd write instance  (MonadReader r) (ReaderStateT r s) where ...
18:15:31 <Cale> actually hmm
18:15:33 <palomer> Cale: how would you derive?
18:15:42 <Cale> I wonder if you get the derived State for free too
18:16:00 <Cale> newtype ... deriving (MonadReader r, MonadState s)
18:16:12 <Cale> also derive Monad and Functor
18:16:36 <Cale> and maybe MonadTrans too
18:17:07 <palomer> but MonadTrans isn't derivable!
18:17:11 <Cale> sure it is
18:17:24 <Cale> with newtype deriving
18:17:33 <palomer> oh, newtype deriving is different
18:18:03 <palomer> if I derive everything, I only need to instantiate the inner monad, right?
18:18:20 <palomer> oh wait, I don't need to do anything
18:18:35 <Cale> You only have to write the run function, basically
18:18:45 <ihope> @babel fr en Tu sais que ceci est en franais quand ...
18:18:47 <lambdabot>  You know that this is in franais when...
18:18:49 <Cale> and any extras you might want
18:18:58 <palomer> that run function is part of which class?
18:19:05 <palomer> newtype ReaderStateT r s m deriving (MonadReader r, MonadState s, Monad r s m, MonadTrans r s)
18:20:18 <palomer> newtype ReaderStateT r s m = ReaderStateT ReaderT r (StateT s m)  deriving (MonadReader r, MonadState s, Monad r s m, MonadTrans r s)
18:21:40 <TheHunter> you can't derive MonadTrans that way.
18:21:44 <Cale> oh, that's interesting
18:21:49 <palomer> :/
18:21:54 <Cale> perhaps you can't
18:22:19 <Cale> should be an easy instance to write anyway
18:22:33 <TheHunter> but you can derive a lot of other stuff, e.g. MonadIO or MonadWriter w
18:22:53 <palomer> why can't I derive MonadTrans?
18:23:00 <Cale> instance MonadTrans (ReaderStateT r s) where
18:23:00 <Cale>     lift x = ReaderStateT (lift (lift x))
18:23:04 <Cale> newtype ReaderStateT r s m a = ReaderStateT (ReaderT r (StateT s m) a)
18:23:04 <Cale>     deriving (Functor, Monad, MonadReader r, MonadState s)
18:23:05 <SamB> dons would hate me for writing code like this...
18:23:08 * palomer wishes there was a derive max directive
18:23:11 <Cale> runReaderStateT (ReaderStateT x) r s = runStateT (runReaderT x r) s
18:23:22 <SamB> it isn't anything like safe for a threaded RTS
18:23:24 <palomer> Cale: why the 2 lifts?
18:23:36 <Cale> you have to lift through State and then Reader
18:23:49 <dons> bad SamB
18:24:12 <SamB> however, it should work wonderfully in the non-threaded RTS
18:24:14 <palomer> oh, righto
18:24:41 <SamB> does GTK use TLS anyway?
18:24:48 <Cale>     lift = ReaderStateT . lift . lift
18:24:50 <Cale> :)
18:25:05 <palomer> Cale: won't let me derive Functor
18:25:13 <Cale> hm?
18:25:17 <Cale> what's the error?
18:25:39 <palomer> oh, righto
18:25:39 <Cale> Mine is working
18:25:39 <palomer> forgot the extensions
18:25:39 <Cale> ah
18:28:08 <SamB> hmm, how do I confine the cursor?
18:28:55 <palomer> seriously, why can't <> be a constructor?
18:29:21 <ihope> > <>
18:29:21 <lambdabot>  parse error on input `<>'
18:29:29 <SamB> why can't :<> be a variable name?
18:29:29 <ihope> Dunno.
18:29:33 <SamB> > (<>)
18:29:34 <lambdabot>  Not in scope: `<>'
18:29:39 <ihope> > (:<>)
18:29:39 <lambdabot>  Not in scope: data constructor `:<>'
18:29:45 <Cale> palomer: because it doesn't start with :
18:29:51 <ihope> Looks like it can.
18:29:59 <ihope> ...That was to SamB.
18:30:00 <Cale> :<> is fine
18:30:31 <ihope> Oh... why would one want <> to be a constructor?
18:30:32 <SamB> ihope: that is not a variable name
18:30:38 <SamB> it is a dataconstructor
18:30:41 <ihope> Oh, right.
18:30:52 <ihope> Well, because it starts with a colon...
18:31:08 <SamB> yeah, I was just answering palomer's question with another ;-)
18:31:14 <ihope> Ah.
18:33:02 <SamB> palomer: I want to keep the cursor inside a particular tag. Can it be done?
18:35:28 <palomer> SamB: never tried
18:35:52 <SamB> I'm trying to do a frontend for a Z-machine interpreter...
18:35:55 <palomer> I don't know if you can move the cursor, but if you can then it's trivial
18:36:07 <SamB> I have to move it myself?
18:37:02 <palomer> you might
18:42:07 <palomer> why can't :<> be a variable name :P?
18:42:29 <palomer> seriously, I don't see why constructor names are a seperate lexical group
18:42:34 <palomer> separate
18:42:55 <Philippa> because they need marking out in patterns one way or another
18:44:05 <palomer> oh, very good point
18:46:43 <Philippa> trust me, you notice it if you implement an interpreter for a haskell-like language and /don't/ have a separation like that at first :-)
18:46:57 <Philippa> (using characters to mark out the pattern variables got old fast...)
18:48:21 <dons> yeah, you really want to know what's a constructor
18:50:46 <palomer> Philippa: how many constraints when type inferencing an application?
18:50:55 <palomer> how many constraints do you generate, rather
18:53:53 <SamB> hmm, I've added a ScrolledWindow and an Entry to a VBox, and the Entry gets way too much space when I resize it...
18:57:59 <SamB> any idea how to fix this?
18:59:03 <araujo> SamB, you are using boxPackStartDefaults?
18:59:32 <SamB> no
18:59:44 <SamB> oh, now I see it...
18:59:44 <araujo> SamB, What are you using to pack the entry?
19:08:58 <palomer> is it possible to get the final State of a computation?
19:09:06 * araujo thinks thet we could have a #gtk2hs channel
19:09:07 <Cale> execState
19:09:13 <palomer> @hoogle execState
19:09:14 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
19:09:14 <lambdabot> Control.Monad.State.execStateT :: Monad m => StateT s m a -> s -> m
19:09:14 <lambdabot> s
19:09:15 <araujo> dcoutts, what you think? :-]
19:09:16 <palomer> @hoogle execStateT
19:09:17 <lambdabot> Control.Monad.State.execStateT :: Monad m => StateT s m a -> s -> m
19:09:17 <lambdabot> s
19:10:06 <Philippa> palomer: you asked about constraints when inferencing an application - I didn't, the language didn't have type classes or anything else to encourage a constraint-based checker so it just does plain ol' unification (albeit in the presence of subtyping)
19:10:31 <palomer> Philippa: well, yeah, you can either generate constraints or unify in place
19:10:31 <Philippa> I would've done something constraint-based if I'd fancied playing with union and intersection types, but I didn't
19:10:48 <palomer> Philippa: how many new variables do you create with application?
19:11:29 <jethr0_> hmm, i've got a state monad problem. i think state arrows might help...
19:11:37 <Philippa> the application itself creates one
19:11:41 <jethr0_> anyone tried those?
19:11:45 <palomer> @hoogle runStateT
19:11:46 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
19:12:03 <palomer> oh, runStateT returns both the state and the return value, nice
19:13:02 <palomer> Philippa: you see, I'm generating two new type variables, from and to. when doing inferencing on (Application u v), I check that u is of type from -> to, and that v is of type to
19:13:17 <palomer> s/v is of type to/v is of type from
19:16:55 <palomer> and infer::context -> term -> (constraints and type)
19:17:43 <palomer> oh, yes, I'm an idiot
19:17:57 <palomer> you can get away with creating a single new variable
19:18:11 <Philippa> yeah, my new one just gets unified with from -> to where from and to're results from inference
19:19:02 <palomer> hm?
19:24:56 <Philippa> actually, no. It finds the result by making a new variable for it, and unifying (parmtype -> result) and the function's type
19:25:02 <Philippa> probably what you were thinking
19:25:04 <Philippa> it's late here :-)
19:25:38 <palomer> yeah, that's what I did
19:25:54 <palomer> the result type is new
19:26:58 <Philippa> anyway, I'm going to bed
19:27:56 <palomer> night
19:28:25 <SamB> well, I seem to have a kinda-working frontend for my ZMachine emulator
19:28:53 <SamB> now I just need to get it to actually accept input in a meaningful way
19:29:02 <skew> Hi, is anybody using gtk2hs 0.9.10 here? I built it from the tgz with --enable-cairo, but the CairoGhci.hs and Clock.hs examples both fail on missing imports
19:29:38 <SamB> hmm, I am, but my GTK/GDK is too old to actually support using Cairo with it...
19:30:11 <palomer> SamB: get the latest darcs version, it has some stuff I found very useful
19:30:15 <palomer> (I even contributed to it)
19:30:25 <skew> grepping the source, they seem to be coming from Graphics.UI.Gtk.Cairo
19:30:28 <palomer> SamB: are you working on hIDE?
19:30:33 <SamB> no
19:30:41 <SamB> I'd need to update my GHC for that, I think
19:30:53 <skew> ghci can import that module, but :browse doesn't show anything in it
19:31:06 <palomer> when using a monad transformer, I don't need to lift return, right?
19:31:19 <SamB> of course not
19:32:41 <dons> ah, so maybe I have a better regex-dna after all
19:33:11 <palomer> do you guys bother annotating your functions when stacking monad transformers?
19:33:47 <palomer> the types get huge!
19:33:48 <dons> yeah
19:33:53 <dons> make type aliases
19:34:18 <dons> type ModuleT s m a = (?ref :: MVar s, ?name :: String) => m a
19:35:46 <palomer> what does that syntax mean?
19:36:24 <dons> oh, I was just pointing out a type alias we used in lambdabot, forget the ? stuff
19:36:32 <dons> thats the implice parameter thingies
19:36:37 <dons> implicit
19:36:58 <palomer> ho hum
19:37:04 <palomer> you mean existential?
19:37:20 <dons> nope, you're asking about the ? things, right?
19:37:48 <palomer> yeah
19:37:52 <dons> check: 7.4.5.Implicit parameters
19:37:58 <lispy> looks like trouble to me, i'll stick with my fortran
19:38:04 <dons> in the ghc user's guide. but they're not relevant to the discussion.
19:38:31 <dons> I'm just saying, keep using type annotations, but lift out common subexpressions^h^htypes with type aliases :)
19:38:41 <lispy> can do write do loops in haskell with gotos?  nope...that's why fortran > haskell
19:39:02 <dons> with gotos, yes :) they're called tail calls
19:39:10 <lispy> dons: ssshhh
19:39:16 <dons> oh, sorry ;)
19:39:29 <lispy> integer*4 :: iwin
19:40:50 <lispy> I should try to implement "error resume next" and explicit gotos in haskell
19:40:58 <lispy> thath would be a worthwhile extension for haskell'
19:41:01 <dons> you could write a paper :)
19:41:08 <lispy> Yes!
19:41:39 <dons> monadic error resume next, sounds good for this year's icfp :)
19:42:06 <lispy> "In this paper we present ImperativeHaskell, a new language extension that allows legacy-language features like goto and 'on error resume next'"
19:42:09 <palomer> it probably isn't too hard to get something close to full fledged gotos in haskell
19:42:33 <SamB> lispy: shouldn't that be called BASICHaskell?
19:42:43 <lispy> BASKELL
19:42:53 <palomer> grr,ghci says that my function takes 2 arguments when it clearly only takes 1
19:43:17 <lispy> palomer: submit a bug report
19:43:30 <SamB> palomer: maybe it actually *does* take two?
19:43:36 <palomer> lispy: it's obviously that I'm an idiot
19:43:42 <palomer> I don't actually believe I'm smarter than ghci
19:44:00 <palomer> SamB: but I don't see how, it's a do block
19:44:15 <lispy> palomer: can you prove it's not a ghc bug?
19:44:23 <palomer> foo x = do {...}
19:44:26 <lispy> if not assume the worst
19:44:28 <palomer> and then it says that foo takes 2 arguments
19:44:39 <SamB> palomer: or maybe you've accidentally invoked the (-> a) MonadReader?
19:44:43 <skew> palomer: is it deciding to use the instance Monad (a -> b)?
19:44:48 <palomer> generateUniversals :: Term a                      -> t                      -> Data.Map.Map String (ST s (SType s))
19:45:06 <palomer> generateUniversals t =     do {u1 <- newUniversal;...}
19:45:51 <skew> if you accidentally appply (generateUniversals x) somewhere, type inference could decide you must be using that MonadReader instance
19:46:08 <palomer> Reader isn't imported
19:46:21 <palomer> anyways, generateUniversals isn't recursive
19:47:09 * palomer is baffled
19:47:14 <palomer> how can a do block be a function?
19:47:38 <skew> a do block starts out with a type like (Monad a) => a
19:47:42 <dons> @type \x -> do x ; return ()
19:47:43 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m ()
19:47:52 <dons> it's got an arrow, it's a function :)
19:48:06 <palomer> dons: that's a lambda, not a do block
19:48:07 <dons> but not a /function/, if you know what I mean :)
19:48:37 <dons> a nullary function then :)
19:48:57 * palomer is very confused
19:49:23 <palomer> http://www.rafb.net/paste/results/zhOzOo14.html <--here's the function
19:50:20 <palomer> and, yes, StateT would have been appropriate
19:50:43 <Cale> > (do x <- (+1); y <- (*2); return (x + y)) 5
19:50:44 <lambdabot> 16
19:50:57 <lispy> palomer: my suggestion would be to get rid of the 'where' clause
19:51:17 <lispy> palomer: or add type signatures to the functions you define in the where
19:53:06 <lispy> how will you define unit tests for e, insertAll and extractParameter if you write it the current way :)
19:53:14 <palomer> the funny part is that I've been using this function extensively
19:54:11 <palomer> Cale: which monad is that working in?
19:54:19 <Cale> ((->) a)
19:54:25 <palomer> hah
19:54:28 <skew> what's the error?
19:54:29 <Cale> (basically reader)
19:54:30 <palomer> I didn't know it had an instance
19:54:39 <palomer> skew: what's what error?
19:54:54 <palomer> Reader is ((->) a)?
19:54:58 <Cale> yeah
19:55:02 <Cale> they're isomorphic, anyway
19:55:18 <skew> palomer: what is the error message from GHCi?
19:55:23 <Cale> Which is why the instance for Monad ((->) a) is in Control.Monad.Reader
19:55:38 <lispy> palomer: several of your cases are just = return sofar, why don't you put them all at the end and have e _ sofar = return sofar ?
19:56:03 <skew> hmm, guess I shouldn't try to optimize shootout entries while buidling gtk2hs
19:56:06 <palomer> lispy: that's dangerous...what if I extend my datatype?
19:56:22 <palomer> skew: it doesn't give me an error message, just this really strange type
19:56:33 <skew> the code works?
19:57:20 <palomer> well, no, my code is really broken
19:57:26 <palomer> and I'm annotating to fix it
19:58:24 <palomer> oh my, it seems to think it is ((->)  t)
19:59:04 <skew> has anyone provided to the shootout people an alternate test file for sum-file?
20:01:08 <dons> an alternate test file?
20:01:24 <skew> a few K of 127-digit numbers, maybe
20:01:29 <dons> ah :)
20:01:46 <skew> I'd say test coverage on the current spec is a bit weak
20:02:22 <lispy> palomer: fair enough, i'd recommend grouping them at the bottom then, and adding whitespace between the first parameter and the second, that way visually it will be one big homogeneous blob that you can glance at and grok :)
20:02:38 <dons> you could have a  look at http://www.haskell.org/hawiki/ShootoutEntry to see which ones haven't had much work on them
20:02:49 <dons> I have a feeling we could get more out of `recursive`, and its pretty small
20:02:56 <dons> depends on how much Core-diving you want to do
20:03:15 <skew> do you know if that Clean entry uses arbitrary precision integers?
20:03:18 <lispy> palomer: we have to get you using hunit or quickcheck and testing your functions too :)
20:03:50 <dons> skew, don't know.
20:04:10 <dons> good idea though -- follow some of the Clean entries, often they've got some quick ideas in them.
20:04:10 * lispy goes off to try out eclipseFP
20:04:37 <skew> I guess those functions are already being inlined
20:05:12 <palomer> lispy: yeah, I have to get comfortable with quickcheck
20:05:20 <palomer> the problem is, you see, is that I'm constantly working in ST
20:06:05 <rasfar> Can anyone tell me how to produce smaller executables with GHC?  HelloWorld gives 2.3 MB (1.5 stripped).  NHC gives 102 K (68 K stripped).
20:06:31 <lispy> palomer: quickcheck can do st monads, there is a paper on it at least (I have to admit i didn't read it yet)
20:06:44 <skew> rasfar: I think ghc statically links libraries
20:06:47 <lispy> rasfar: heh, wow
20:06:49 <dons> rasfar, shoule around 200k stripped on linux
20:07:05 <dons> it uses split objects. sounds like you're don't have split objs?
20:07:14 <dons> /shoule/should be/
20:07:35 <rasfar> oh ... must be a bsd issue?...  says it's dynamically linked unless use ...
20:07:36 <rasfar>   set cc_cmnd='env LDFLAGS=-static ghc --make Main.hs -optc-static -optl-static -static -o scheder'
20:08:03 <skew> I'm getting 178k
20:08:26 <rasfar> hmmm...  okay, good to know.  I'll be running ubuntu within a month here anyhow.
20:09:03 * palomer shoots self
20:09:15 <palomer> ok, seriously, we need a better way to find type errors
20:09:20 <palomer> I just spent one hour hunting down a typo
20:10:48 <dons> just takes practice
20:12:21 <skew> a constraint based type checker might give better line numbers
20:13:21 <lispy> hmm...a haskell compiler written in prologIII
20:13:58 <palomer> http://www.rafb.net/paste/results/ZGCfrm55.html
20:14:21 <palomer> skew: actually, an in place type checker simply fails in place and gives the current line number
20:14:28 <palomer> err, type inferencing system
20:14:40 <palomer> dons: I've been practicing for ages!
20:15:36 <skew> palomer: if you explicitly accumulate constraints, you can say which earlier lines made the current line unacceptable
20:16:24 <skew> I mean, if the type checker is built around a bag of constraints, rather than side-effecting a substitution
20:16:31 <palomer> skew: yeah, I was actually developing a system like that
20:16:45 <skew> maybe you could attach line numbers to the substitution
20:16:45 <palomer> it was extra cool
20:17:02 <palomer> I might get around to finishing it up
20:17:17 <palomer> getUniversals = ask  <--this code fails, I'm very confused
20:17:32 <palomer> oh, MR again
20:20:26 <palomer> hrm
20:20:32 <palomer> if I try to do getUniversals x = ask x
20:20:38 <palomer> getUniversals isn't the same as ask
20:21:04 <palomer> namely, getUniversals isn't part of monadtrans
20:21:06 <palomer> how can I fix this?
20:23:12 <palomer> newtype ReaderStateT r s m a = ReaderStateT (ReaderT r (StateT s m) a)    deriving (Functor, Monad, MonadReader r, MonadState s)
20:23:17 <palomer> do I have to lift to use get and put?
20:25:23 <skew> Does Clock.hi work with gtk2hs 0.9.10?
20:25:32 <Cale> no
20:25:40 <Cale> palomer: no, you don't have to
20:25:45 <Cale> skew: I have no idea :)
20:25:59 <lispy> god, eclispe manages to be some of the worst software i've seen
20:26:02 <skew> Some of the functions it uses seem to be missing entirely from the source
20:26:03 <Cale> The Clock is new though, I think
20:26:11 <lispy> why do i keep trying to make it work?  am i screwed up?
20:26:28 <Cale> lispy: I have no idea why people get so excited about it.
20:26:42 <palomer> @hoogle runReader
20:26:43 <lambdabot> Control.Monad.Reader.runReader :: Reader r a -> r -> a
20:26:43 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
20:27:00 <palomer> @hoogle runStateT
20:27:00 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
20:27:10 <skew> at extreme abstraction, moving away from the regexp-based language processing in emacs is a good idea
20:27:22 <palomer> runReaderStateT x startRead startState = runReaderT (runStateT x startState) startRead <--is this correct?
20:27:23 <lispy> Cale: if it actually parses haskell code and does something intelligent with the AST it might be really nice
20:28:02 <lispy> but this eclipseFP plugin failed to upgrade correctly, and when i tried to manually uninstall it eclipse couldn't handle it, so now i'm reinstalling eclispe
20:28:14 <skew> it might be easier to just write an AST based mode for emacs, though
20:28:18 <Cale> lispy: yeah -- I'd like an IDE or even just a text editor which flagged type errors and coloured things based on actual parses of the language rather than regular expressions
20:28:44 <Cale> *Main> evalReaderStateT (do x <- ask; y <- get; return (x + y)) 2 3 >>= print
20:28:44 <Cale> 5
20:28:44 <skew> has anybody tried running a reversed grammar through GLR?
20:29:02 <lispy> eclispe has ponetnial, but i've yet to have a satisfying experience
20:29:15 <skew> Cale: do you have any idea what I would need to do to fix Clock.hs?
20:29:38 <Cale> skew: you should run the latest darcs version of Gtk2hs
20:30:03 <lispy> skew: when emacs gets an industrial strength run-time it might be worth tring.  But right now its a pretty inefficent application platform
20:30:49 <lispy> emacs started out as a domain specific language for document manipulation...then it became an OS
20:31:14 <rasfar> It seems like Yi would be the natural place to implement Haskell-optimized semantic colouration etc...
20:31:17 <lispy> people should try rewriting emacs knowing what it will actually be used for and optimizing for that case :)
20:31:28 * rasfar is out of touch; wonders what's up with Yi these days...
20:31:42 <lispy> yi is cool, but i think it lacks a critical mass of devs
20:32:09 <skew> lispy: speaking of reimplementing emacs, maybe we need to make sure the yi and house developers overlap enough
20:32:47 <lispy> heeh
20:32:50 <rasfar> With the GHC Language lib (whichever that one is with the Haskell syntax on a silver platter) ought to be pretty simple?
20:33:08 <lispy> iirc, that's called ghc-api
20:33:31 <skew> that would be a good start, but it's probably not so nice for stuff like incremental parsing around edits
20:33:35 <lispy> i think that's being worked onin hIDE but I could be wrong
20:34:02 <skew> although, the story about parallelizing GHC from the paper on the multithreaded runtime was pretty inspiring
20:34:48 <lispy> lispM may have failed, but in 2008 we can have haskellM
20:35:31 <skew> STM + multicore processors might just do it
20:37:49 <lispy> one thing that might be neat is an embeddable haskell spec.  Have it assume it will have a nice generous run-time.  Have it assume that reflection is more important than speed, but otherwise it's still haskell.
20:38:02 <lispy> could make a neat scripting language to plug into things like webbrowsers :)
20:39:57 <dons> yeah, hopefully we see some fun things in the nnext year or two with the ghc-api, lispy.
20:51:57 <lispy> i reinstalled eclipse now it can't find the plugin i just installed, wtf?
20:54:40 <palomer> eclipse sucks
20:54:43 <palomer> :P
20:55:59 <palomer> @hoogle [(a,a)]->[a]
20:56:00 <lambdabot> No matches, try a more general search
20:56:07 <palomer> bastard
20:56:16 <Cale> map fst?
20:56:24 <palomer> well, no, I want to combine both branches
20:56:33 <Cale> how exactly?
20:56:41 <skew> zipWith . uncurry?
20:56:54 <palomer> @type zipWith.uncurry
20:56:55 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> [(a, b1)] -> [b] -> [c]
20:57:11 <palomer> Cale: squish them together, get a list twice the size
20:57:27 <palomer> map fst ++ map snd could work
20:57:57 <skew> @type map . uncurry
20:57:58 <lambdabot> forall a b c. (a -> b -> c) -> [(a, b)] -> [c]
20:58:02 <Cale> > (do x <- map fst; y <- map snd; return (x ++ y)) [(1,2),(3,4),(5,6)]
20:58:03 <lambdabot> [1,3,5,2,4,6]
20:58:11 <Cale> :)
20:58:37 <palomer> oh my, you're using Reader again
20:59:09 <Cale> > (\xs -> map fst xs ++ map snd xs) [(1,2),(3,4),(5,6)]
20:59:10 <lambdabot> [1,3,5,2,4,6]
20:59:34 <skew> > [(1,2),(3,4),(5,6)] >>= \(a,b) -> [a,b]
20:59:35 <Cale> @pl \xs -> map fst xs ++ map snd xs
20:59:35 <lambdabot> [1,2,3,4,5,6]
20:59:35 <lambdabot> ap ((++) . map fst) (map snd)
21:00:04 <skew> palomer: is it necessary to put the fsts before the snds
21:00:20 <joelk> skew beat me; I had just typed the same thing!
21:00:44 <palomer> skew: nope
21:00:47 <palomer> order is irrelevant
21:01:05 <skew> then it might be better to interleave them like my thing, to avoid hanging onto the list
21:02:46 <Cale> yeah, the list monad version is saner :)
21:04:31 <palomer> @hoogle zip
21:04:32 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
21:04:32 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
21:04:32 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [
21:04:32 <lambdabot> c]
21:04:44 <Cale> @hoogle unzip
21:04:44 <lambdabot> Data.List.unzip :: [(a, b)] -> ([a], [b])
21:04:44 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
21:04:44 <lambdabot> Data.List.unzip3 :: [(a, b, c)] -> ([a], [b], [c])
21:06:29 <palomer> (&&& (+)) (2,3)
21:06:34 <palomer> > (&&& (+)) (2,3)
21:06:34 <lambdabot> Couldn't match `b -> c' against `(a, b1)'
21:07:04 <Saulzar> > (&&& (+ 2)) (2,3)
21:07:05 <lambdabot> Couldn't match `b -> c' against `(a, b1)'
21:12:43 <palomer> @hoogle mapM_
21:12:44 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
21:12:44 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
21:12:44 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
21:21:45 <palomer> whew
21:21:49 <palomer> @type (&&&)
21:21:50 <lambdabot> Not in scope: `&&&'
21:21:54 <palomer> liar
21:30:59 <lispy> @index (&&&)
21:31:00 <lambdabot> Control.Arrow
21:31:06 <lispy> @type Control.Arrow
21:31:08 <lambdabot> Couldn't find qualified module.
21:31:08 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
21:31:08 <lambdabot> \\)?
21:31:26 <lispy> @type Control.Arrow.(&&&)
21:31:27 <lambdabot> Couldn't find qualified module.
21:31:27 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
21:31:27 <lambdabot> \\)?
21:31:38 <lispy> @type Control.Arrow.&&&
21:31:39 <lambdabot> parse error on input `Control.Arrow.&&&'
21:31:45 <lispy> weird
21:31:47 <skew> @type (Control.Arrow.&&&)
21:31:48 <lambdabot> forall (a :: * -> * -> *) c' c b.
21:31:48 <lambdabot> (Control.Arrow.Arrow a) =>
21:31:48 <lambdabot> a b c -> a b c' -> a b (c, c')
21:31:53 <skew> as the error message suggested
21:32:17 <lispy> the error message was illegible on my screen :(
21:32:31 <skew> it's pretty confusing too
21:32:53 <lispy> the line: < lambdabot> \\)?
21:32:56 <lispy> doesn't help at all
21:33:06 <skew> you didn't see the two preceeding lines?
21:33:29 <skew> "Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List."
21:33:46 <skew> that cairo clock runs pretty slow for me
21:33:48 <lispy> hmm...yeah, didn't realize it was connected
21:34:26 <skew> it ticks okay, but takes more than a second to switch to the pretty view after resising
21:40:41 <palomer> @hoogle runReaderT
21:40:42 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
21:42:33 <palomer> hrmphrmphrachostauohaou
21:43:03 <palomer> ghc wants runReaderT and not runReaderStateT
21:43:07 <palomer> I'm flabbergasted
21:43:20 <palomer> am I going nuts?
21:43:26 <palomer> I'm using ask, put and get in the same code
21:43:30 <palomer> and its letting me runReaderT
21:43:46 <palomer> in fact, it's imposing it!
21:50:18 <palomer> Cale: in your code, should ask be of a different type?
21:50:36 <palomer> ask :: (Control.Monad.Reader.MonadReader r m) => m r
21:50:47 <palomer> shouldn't that be ReaderStateT?
21:51:30 <Cale> ReaderStateT ought to be a valid m in ask's type
21:56:29 <palomer> http://www.rafb.net/paste/results/ZvtUkV99.html
21:57:46 <Cale> palomer: what happened to the nicely newtyped monad?
21:57:59 <palomer> it's the one
21:58:07 <Cale> hm?
21:58:18 <Cale> then runReaderStateT has a totally wrong type
21:58:33 <palomer> http://www.rafb.net/paste/results/Fdp8Pk97.html
21:59:17 <Cale> right
21:59:53 <Cale> so  runReaderStateT :: ReaderStateT r s m a -> r -> s -> m a
22:01:23 <palomer> runReaderStateT :: Control.Monad.Reader.ReaderT r (Control.Monad.State.StateT s m) a -> r -> s  -> m (a, s)
22:01:33 <palomer> don't forget,
22:01:37 <palomer> @hoogle runReaderT
22:01:38 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
22:01:40 <palomer> @hoogle runStateT
22:01:41 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
22:02:05 <Cale> oh!
22:02:16 <Cale> runReaderStateT (ReaderStateT x) startRead startState = runStateT (runReaderT x startRead) startState
22:02:18 <Cale> there
22:02:20 <Cale> :)
22:02:58 <palomer> whoa
22:03:05 <palomer> thx
22:03:11 <palomer> but the error messages were incomprehensible
22:03:16 <palomer> I would never have figured it out!
22:03:29 <Cale> I didn't really read them carefully :)
22:03:55 <Cale> oh
22:04:06 <Cale> it says it can't match ST against StateT
22:04:47 <palomer> yeah
22:04:54 <palomer> why would it say such a thing?
22:07:29 <Cale> well, let's look at it carefully
22:07:48 <Cale> infer returns something with type  t (ST s) (SType s)
22:08:08 <palomer> yeah, I don't get that type either
22:08:11 <Cale> where t (ST s) is a Reader monad and a State monad.
22:08:55 <Cale> well, when things get complicated be a little mechanical and algebraic :)
22:09:16 <Cale> so then we're applying runReaderStateT to it
22:09:54 <Cale> and runReaderStateT takes something of type  ReaderT r (StateT s m) a
22:10:06 <palomer> sure
22:10:09 <palomer> that I get
22:10:23 <Cale> so  t = ReaderT r, and ST s = StateT s m, and SType s = a
22:10:32 <Cale> oops, that second equation is inconsistent
22:10:42 <Cale> so that's what it's complaining about
22:10:57 <Cale> because  t (ST s) (SType s) = ReaderT r (StateT s m) a
22:11:36 <palomer> oh, righto
22:13:28 <palomer> well, I think I wored hard enough for today
22:13:29 <palomer> phew
22:13:42 <palomer> but however says that 1 line of haskell is worth 10 lines of C code is just plain wrong!
22:13:55 <palomer> it's the opposite
22:13:59 <palomer> but then again, it's safer
22:14:04 <jethr0_> man, writing monadic code can result in some very cool pseudo domain specific language :))
22:15:27 <dons> I will personally by a beer for anyone who writes a regex-dna shootout entry that completes in less than 1 hour for N=5M :)
22:15:41 <dons> (without ffi calls to tcl )
22:15:44 <jethr0_> :) nice challenge
22:15:53 <jethr0_> T_C_L ??
22:16:02 <jethr0_> do they have the fastest impl?
22:16:05 <dons> 1 hour is the timeout limit, we can't get under that yet. tcl finishes in a few seconds..
22:16:22 <dons> the problem is regex(3) I think, since the C entry has similar woeful performance
22:16:57 <dons> i.e the packed string Haskell entry runs around the same complexity as the C entry. around 1000x too slow.
22:16:58 <palomer> wait, tcl finishes in a few seconds and haskell takes over an hour?
22:17:31 <jethr0_> MAN, c is bad in this!
22:17:41 <dons> i have a packed string version that takes 30 mins or so, same as the C entry
22:17:46 <palomer> I didn't know people still used tcl
22:17:48 <dons> we both use regex(3)
22:18:00 <dons> unfortunately, my entry is illegal
22:18:03 <SamB> @karma+ dcoutts
22:18:04 <lambdabot> dcoutts's karma raised to 9.
22:18:04 <dons> (it needs hsc2hs)
22:18:09 <jethr0_> and python finishes in 6secs. something can't be right :((
22:18:10 <SamB> @karma+ palomer
22:18:11 <lambdabot> palomer's karma raised to 2.
22:18:18 <palomer> yay!
22:18:20 <palomer> what's the karma for?
22:18:21 <dons> they have efficient regex libs, I reckon.
22:18:36 <shrimpx> what? haskell is slow at something?
22:18:47 <skew> I thought ghc used the pcre library?
22:18:49 <dons> yeah, weird huh?
22:18:53 <dons> nope. 
22:18:54 <shrimpx> crazy
22:19:00 <palomer> shrimpx: that something is most things
22:19:11 <shrimpx> ya sarcasm
22:19:11 <SamB> well, I was thinking about my z-machine interpreter and all the help you guys were
22:19:32 <shrimpx> there's been all this talk on the ml about how it's #2 in the shootout - i'd already dismissed it as the 2nd fastest compiler ever
22:19:35 <palomer> I've heard java wonks who thought that java was similar in performance to C
22:19:45 <SamB> and I thought that I ought to give you guys karma for all the help ;-)
22:19:56 <dons> java can't get close. at least we have objective numbers :)
22:20:01 <palomer> ahh, np
22:20:06 <palomer> SamB: so can you control the cursor?
22:20:22 <SamB> eh, I decided to give up on that and just use a text entry
22:20:29 <palomer> there should be an "idiomatic shootout"
22:20:36 <SamB> if all the MUD clients do, why can't I?
22:20:43 <skew> how are multiple entires handled?
22:20:46 <palomer> SamB: what exactly were you trying to do?
22:21:08 <skew> there are plenty of idiomatic entries, and plenty of fast ones
22:21:13 <dons> exactly.
22:21:15 <skew> sometimes even the smae
22:21:19 <SamB> the front-end handling of the "read" opcode
22:21:48 <palomer> SamB: and why didn't you want the cursor to escape?
22:22:08 <skew> even a few that again look idiomatic, after spending some time unboxed
22:22:33 <dons> skew, yeah :) like partial-sums :)
22:22:38 <jethr0_> is there a way to find out how far a lazy string has already been eval'ed?
22:22:42 <SamB> palomer: you know how when you are at the shell prompt, you can't move onto the prompt or backspace over it?
22:22:52 <SamB> its kinda like that
22:22:58 <jethr0_> i've got a lazy string that represents stdin and i want to only print what's there yet :)
22:23:01 <dons> jethr0_, interesting question. print the elem as you eval?
22:23:16 <dons> you some how need to print where you are as you eval the list. 
22:23:30 <jethr0_> dons: but it's stdin. it's not like the other side produced on demand
22:23:45 <SamB> in fact, its exactly like that, only instead of a shell you have a work of interactive fiction
22:23:52 <SamB> aka text adventure game
22:24:51 <palomer> I thought you were writing an interpreter
22:24:59 <SamB> well, yes
22:25:24 <skew> does anybody have a Happy grammar for some language lying around?
22:25:44 <SamB> skew: yes, someone does
22:26:42 <dons> @google ParserCore.y
22:26:44 <lambdabot> http://cvs.coverproject.org/marcin/cgi/viewcvs/ghcCore2Agda/src/ParserCore.
22:26:44 <lambdabot> y
22:27:03 <dons> just a stab in the dark
22:27:20 <ncalexan> skew: there's a C-- Happy grammar in CMM, the Haskell project, IIRC.
22:27:22 <SamB> @google CmmParser
22:27:24 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg17759.html
22:27:30 <skew> oh, that sounds good
22:27:32 <ncalexan> Cheers.
22:27:44 <SamB> @google Language/Cmm/Parser/
22:27:46 <lambdabot> http://blog.gmane.org/gmane.comp.lang.haskell.general/day=20051206
22:28:01 <SamB> oh, yuck!
22:28:02 <skew> it doesn't really matter what language, I want to test an idea I had about incremental parsing with Happy
22:28:06 <SamB> spam spam spam spam!
22:31:46 <dons> here's the current timings: http://www.haskell.org/hawiki/RegexDna
22:31:54 <dons> the best we can do so far is 20mins.
22:32:03 <SamB> palomer: http://www.inform-fiction.org/zmachine/standards/z1point0/sect15.html#read
22:32:11 <dons> maybe a better regex lib is needed to progress on this, though.
22:32:36 <SamB> steal steal whatever Python is using or something
22:32:57 <dons> yeah.
22:33:04 <dons> or Ocaml.
22:34:04 <Cale> I really like JRegex
22:34:24 <Cale> http://repetae.net/john/computer/haskell/JRegex/
22:34:42 <Cale> perhaps that should be adapted to work on fast strings
22:36:05 <SamB> palomer: obviously I'm not trying to support it in its full generality at this point
22:37:07 <SamB> in fact I do not even appear to have implemented the common usage in my backend...
22:37:26 <shrimpx> it's annoying how GHC is cool a lot of the time but then some mundane pedestrian task mops the floor with it
22:51:18 <dons> we don't have a regex lib. it's not ghc's fault
22:53:35 <skew> we should be organizing the attempted entries that didn't compile well, to make test cases for ghc
23:29:44 <jethr0_> does haskell have a standard accumulating map, or sth. i mean sth that transforms a list AND keeps and accumulator
23:31:24 <ncalexan> @type scanl
23:31:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:32:56 <ncalexan> @type head . scanr
23:32:57 <lambdabot>   Expecting a function type, but found `b'
23:32:57 <lambdabot>   Expected type: (a1 -> b -> b) -> [a]
23:33:02 <ncalexan> @type (head . scanr)
23:33:03 <lambdabot>   Expecting a function type, but found `b'
23:33:03 <lambdabot>   Expected type: (a1 -> b -> b) -> [a]
