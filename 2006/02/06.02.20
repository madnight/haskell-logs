00:00:14 <wli> I'm just sort of agonizing because this sort of thing should really already be out there.
00:01:42 <wli> It kind of reminds me of Jacobian elliptic functions and other special functions that are a PITA but I appear to need to write myself.
00:34:40 <xerox_> Good mooooorning Haskellers!
00:37:31 <astrolabe> morning xerox
00:39:35 <astrolabe> wli: You shouldn't represent householder transformations as matrices.
00:40:43 <wli> astrolabe: data Matrix t = House [t] | Givens [t] | Tridiag [t] [t] | ...
00:41:10 <astrolabe> You can write them as something like   I-(aa^T)/(a^Ta) which gives an efficient method of applying them
00:41:24 <astrolabe> What is t here?
00:41:39 <wli> likely Double
00:42:11 <astrolabe> Won't random access on lists be too slow?
00:42:17 <wli> Probably.
00:42:34 <astrolabe> :)
00:42:58 <astrolabe> with House[t] are you using the form I suggest?
00:43:24 <wli> The analogous dense full matrix would be [[t]]
00:43:36 <astrolabe> Ah ok
00:43:49 <astrolabe> So what do you store for Givens?
00:44:44 <wli> I just belted it out as a plausible explanation of what I meant when I said I was representing a matrix as a Householder transformation.
00:45:56 <astrolabe> heh
00:45:58 <wli> I don't have any code resembling that in the least.
00:46:05 <astrolabe> Off to work now.  Good luck.
00:46:31 <astrolabe> Maybe Givens Int Int t
00:46:56 <astrolabe> er where Maybe is the english word, not the haskell word
01:15:51 <shapr> @yo
01:15:51 <lambdabot> if it GLISTENS, gobble it!!
01:19:20 <xerox_> Yow!
01:34:14 <shapr> shazam!
01:55:00 <shapr> So, what's up?
01:58:44 <aleator> Conclusion: Brain * CPU = Constant.
03:07:45 <flowolf> hi all
03:09:42 <shevegen> "ghc-6.4.1: error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory" anyone has a hint for me what to do? its the binary package of ghc, i searched and only found libreadline.so.5 but not .4 references 
03:11:42 <Lemmih> Using RedHat?
03:12:56 <shevegen> rpath linux actually
03:13:43 <qwr> you installed the ghc from some other distributions package?
03:13:55 <shevegen> no, i didnt install ghc so far :)
03:14:58 <shevegen> would i need to use readline < 5 ?
03:15:27 * qwr thinks that you must install the libreadline libraries version 4... and hope that it works so
03:15:45 <qwr> shevegen: because the ghc binary you have is linked against it?
03:16:21 <shevegen> ok, lets see
03:20:04 <shevegen> yes
03:20:07 <shevegen> works now, thanks
04:00:20 * earthy gives big ass kudos to Donald Bruce Stewart for doing the HWN
04:04:47 <dons> thanks earthy :)
04:05:29 <earthy> well, it allows me to play catchup after by now 2 weeks of first flu and then pneumonia
04:05:33 <earthy> so.  :)
04:05:40 <earthy> THANK YOU!
04:05:44 <dons> hehe. good good :)
04:18:37 <MarcWeber> Is Hs-Source-Dirs ( Dir_s_ ?) a valid cabal entry?
04:19:34 <MarcWeber> I'm trying to install c2hs
04:20:23 <dons> for newer Cabals, iirc.
04:21:23 <dons> hs-source-dir is always valid, hs-source-dirs means you need Cabal 1.1.x (or a new one, at least)
04:25:05 <MarcWeber> Thanks. you are right.. on linux I have 1.1.3 installed and it did work there (the ebuild didn't patch it).
04:25:30 <MarcWeber> Why am I getting a lot of module blah is exposed by Cabal-1.0 and Cabal 1.1.3 errors although I've hidden Cabal-1.0?
04:26:33 <shevegen> thanks for the help, cu guys later
04:42:58 <kosmikus> @seen dcoutts
04:42:58 <lambdabot> dcoutts is in #gentoo-haskell and #haskell. I don't know when dcoutts
04:42:58 <lambdabot> last spoke.
04:52:56 <MarcWeber> Ah.. I had to remove the hi file
05:24:11 <MarcWeber> Anyone using c2hs on windows/linux? I can't run c2hs on the simple example. My commandline has been : c2hs simple.h Simple.chs
05:24:37 <dcoutts_> MarcWeber, you're having trouble with the c2hs ebuild?
05:25:31 <MarcWeber> On windows I get a path not found error (when c2hs tries to call the C preprocessor) on linux I get a simple.h:1:1 #include nested to deeply error while invoking c2hs. (but this file has to be generated, hasn't it?)
05:25:55 <MarcWeber> dcoutts That did work fine, dcoutts_, thanks
05:27:05 <MarcWeber> Because of that I did know that Hs-Source-Dirs is valid with Cabal later than 1.0 ;-)
05:27:32 <MarcWeber> dcoutts But I can't compile the examples from the latest source distribution
05:28:48 <MarcWeber> I'll learn that stuff and do everything manually then I'll also know what is really going on.
05:29:18 <dcoutts_> MarcWeber, what does your Simple.chs look like? does it #include anything?
05:30:16 <dcoutts_> MarcWeber, I bet c2hs adds #include "simple.h" to your simple.h
05:30:34 <dcoutts_> which is why it says it nests too deeply
05:30:50 <MarcWeber> dcoutts It looks like this, no include http://www.rafb.net/paste/results/QJ6ORx96.html
05:31:04 <MarcWeber> If it would have been my .chs file.. but it's from the test directory of the c2hs distribution
05:31:22 <dcoutts_> MarcWeber, and what does the simple.h look like after running c2hs?
05:32:56 <MarcWeber> There is none.
05:33:11 <dcoutts_> oh, hmm
05:33:23 <MarcWeber> running make -n  shows that the Makefile itself just calls c2hs simple.h Simple.chs
05:34:19 <MarcWeber> Am I right that c2hs should create this h file for "some haskell implementation which do need them"? .. *lol* only ghc will work anyway
05:34:51 <MarcWeber> No hugs and nhc, too
05:36:03 <dcoutts_> MarcWeber, it's supposed to work with hugs & nhc
05:36:20 <dcoutts_> MarcWeber, I don't see the problem, when I run c2hs simple.h Simple.chs it works
05:36:27 <dcoutts_> but the simple.h *does* exist
05:36:43 <MarcWeber> C->Haskell Compiler, version 0.14.5 Travelling Lightly, 12 Dec 2005
05:36:43 <MarcWeber>   build platform is "i686-pc-linux-gnu" <1, True, True, 1>
05:36:47 <MarcWeber> Which version are you using?
05:36:51 <dcoutts_> same
05:36:56 <dcoutts_> cd c2hs/tests
05:37:01 <MarcWeber> dcoutts Which os?
05:37:02 <MarcWeber> gentoo?
05:37:25 <MarcWeber> ebuilds  from darcs repo?
05:37:27 <dcoutts_> yes, but I'm looking at the darcs source  of c2hs
05:37:39 <MarcWeber> Then it should work here, too
05:37:41 <dcoutts_> $ cat simple.h
05:37:41 <dcoutts_> void foo ();
05:37:46 <MarcWeber> I'll try reemerging
05:37:59 <dcoutts_> wait
05:38:07 <dcoutts_> does simple.h exist?
05:38:27 <MarcWeber> scroll up ;-)
05:38:32 <MarcWeber> no it doesn't
05:38:41 <dcoutts_> well if it's missing then that's what's wrong
05:39:10 <MarcWeber> So this .h file should be included? .. wait I'll re tar xvf...
05:39:11 <dcoutts_> you can't generate a binding without looking at the header file that defines the C functions
05:39:40 <dcoutts_> the simple.h is in the c2hs darcs repo
05:40:02 <dcoutts_> I'm using http://www.cse.unsw.edu.au/~chak/repos/c2hs
05:40:18 <dcoutts_> c2hs/tests/simple.h
05:41:51 <MarcWeber> dcoutts Thanks a lot.. I think I did remove it accidently
05:42:08 <dcoutts_> np, so it works now?
05:42:13 <xerox_> dcoutts_: hollash
05:42:16 <MarcWeber> I'm currently reemerging c2hs
05:42:25 <dcoutts_> ok
05:42:34 <dcoutts_> xerox_, ?!
05:42:46 <xerox_> Hi.  :-)
05:42:51 <dcoutts_> hi :-)
05:45:28 <MarcWeber> hollash? Never heard
05:45:39 <dcoutts_> nope
05:45:59 * dcoutts_ is clearly ignorant :-)
05:46:12 <xerox_> Some Scottish friend of mine seldom welcomes me that way :-)
05:48:07 <MarcWeber> Thats odd: Neither merriam-webster nor wikipedia did now it ;-) It seems to work now.. At least I get my hs file now. *beeing happy and jumping and embarassing everyone*
06:00:25 <taw_> hello :-)
06:01:40 <chris2> hi
06:05:43 <taw_> are there any good free (preferably open source) and easy to use theorem provers for propositional calculus ?
06:18:37 <ihope> Indeed. a ~> b = (b ~> a) -> b.
06:20:40 <xerox_> ihope: what does that mean?
06:21:57 <ihope> It's an arrow.
06:22:16 <ihope> type Hyper a b = H (Hyper b a -> b)
06:22:30 <ihope> Or, rather, newtype.
06:23:16 <ihope> The above is just an alternate way of writing it.
06:24:04 <ihope> So I'm looking for something of type (a -> b) -> a ~> b
06:26:25 <xerox_> id
06:26:48 <xerox_> well... arr.
06:27:39 <xerox_> @type (Control.Arrow.arr :: (Control.Arrow.Arrow (~>)) => (a -> b) -> (a ~> b))
06:27:40 <lambdabot> forall a
06:27:40 <lambdabot>                             b
06:27:40 <lambdabot>                             (~> :: *
06:27:42 <lambdabot>                                -> *
06:27:44 <lambdabot>                                 -> *).
06:27:46 <lambdabot>                           (Control.Arrow.Arrow ~>) =>
06:27:48 <lambdabot>                           (a -> b) -> ~> a b
06:27:54 <xerox_> ^__^
06:35:05 <ihope> Well, I'm looking for the definition of arr.
06:35:42 <ihope> (a -> b) -> a ~> b
06:35:51 <ihope> (a -> b) -> (b ~> a) -> b
06:36:12 <ihope> (a -> b) -> ((a ~> b) -> a) -> b
06:36:35 <xerox_> @libsrc Control.Arrow
06:36:35 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Arrow.hs
06:37:48 <xerox_> ihope: instance Arrow (->) where arr f = f.
06:37:59 <ihope> :-)
06:39:32 <shapr> subject of an email I just got: "Check out this huge enlargement patch sale" ... Silly programmers, the best patches SHRINK YOUR SOURCES!
06:39:34 <ihope> Whoa... returnA actually has a definition?
06:40:33 <ihope> Hmm. ArrowPlus... that could get interesting ;-)
06:40:52 <ihope> Has anybody ever used it?
06:42:31 <shapr> It's cool.
06:43:00 <shapr> I think Ross Paterson used it for automata in his FoP chapter.
06:45:35 <ihope> Okay. If arrows are a monad, then for any arrow (~>), there needs to be a (() ~> () ~> a) -> () ~> a
06:46:09 <shapr> It's the other way around. All monads are arrows.
06:46:12 <shapr> Not all arrows are monads.
06:46:22 <xerox_> How do you use <+> ?
06:46:24 <shapr> In fact, that's what motivated the discovery of arrows.
06:46:51 <shapr> Swierstra & Duponcheel's parsers were seriously badass and absolutely would not fit into the monadic interface.
06:47:13 <shapr> ihope: Have you seen the unfinished ArrowsIntroduction on TmrWiki?
06:47:19 <ihope> Nope.
06:47:46 <shapr> http://www.haskell.org/tmrwiki/ArrowsIntroduction
06:47:47 <kowey> shapr: can we integrate this into wikibooks?
06:48:00 <shapr> Yikes, unfinished for .75 year.
06:48:03 <kowey> http://en.wikibooks.org/wiki/Programming:Haskell_arrows
06:48:12 <shapr> kowey: sure, steal it.
06:48:17 <shapr> You have my explicit permission.
06:48:19 <kowey> many thanks :-)
06:48:31 <shapr> Plus I've learned lots more about arrows since then.
06:48:41 <shapr> Sadly, I've lost some of the demonstrative sources though :-/
06:52:22 <wli> short book
06:54:00 <xerox_> So with <+> you can get around ((->) a) not being a MonadPlus ?
06:54:52 <ihope> You know, I keep parsing ((->) a) as (-> a)...
06:58:10 <xerox_> > let f = return . (*2); g = return . (+10) in runKleisli ((Kleisli f) <+> (Kleisli g)) 1 :: [Int]
06:58:12 <lambdabot> [2,11]
07:04:25 <MarcWeber> dcoutts It works fine now
07:09:04 <ihope> Whoa, there's a declaration I haven't seen before.
07:09:23 <ihope> data Foo where Bar :: baz -> Foo
07:14:43 <kosmikus> ihope: it's a GADT declaration, but it isn't a GADT. doesn't actually make much sense in this form, if "baz" is a variable.
07:15:11 <ihope> What is a GADT?
07:15:23 <kosmikus> would be equivalent to "data Foo = forall baz. Bar baz"
07:15:49 <kosmikus> GADT = "generalized algebraic data type"
07:15:54 <ihope> Ah.
07:16:22 <kosmikus> usually, if you declare "Foo a b c", then all data constructors of "Foo" must have result type "Foo a b c".
07:16:44 <kosmikus> for GADTs, they must produce "Foo something1 something2 something3" only
07:17:00 <kosmikus> so, some of the variables can be fixed to concrete types
07:18:17 <ihope> Whoo. Boomies!
07:18:24 <ihope> data Foo = forall a. Foo a
07:18:29 <ihope> foo (Foo a) = a
07:20:24 <kosmikus> yes, that won't work
07:28:35 <MarcWeber> dcoutts I know the problem now: The tar contains a Simple.h and a simple.h .. one windows that doesn't work ;-)
07:28:37 <ihope> Now, what was that thing I wanted to do here?
07:28:38 <ihope> >:-)
07:31:32 <ihope> Whoa, it worked.
07:34:57 <shapr> kosmikus: I rather like GADTs for 'screechingly obvious code' in data declarations, as audreyt demonstrated.
07:36:01 * shapr throws generic aliens at kosmikus!
07:36:04 <musasabi> Does runProcess with Nothing for the "Maybe Handle" parameters use the process stdin for something?
07:36:21 <shapr> kosmikus: Hey, did the collection of lambda alien drawings even make it online?
07:36:25 <ihope> Gasp! It works!
07:37:32 <shapr> yay!
07:38:40 <ihope> Now I can convince everyone that functions in Haskell are just syntactic sugar!
07:38:41 <kosmikus> shapr: which one?
07:38:51 <kosmikus> shapr: my thesis is online
07:39:09 <shapr> Yeah, but I thought the collection of nifty lambdaliens might make it online by itself?
07:40:22 * shapr goes back to boring Python code...
07:45:00 <ihope> Spam, spam, spam, spam...
07:45:35 <kosmikus> shapr: there are so many lambda drawings ;)
07:45:48 <kosmikus> shapr: it would probably take me an afternoon to scan them all in
07:46:41 <musasabi> Has anyone used waitForProcess in threaded code? (or anything using it internally like system, rawSystem, runProcess, etc)
07:55:43 <Igloo> kosmikus: Don't you already have htem in electronic form to print the thesis?
07:56:20 <musasabi> Please tell me that System.Cmd and System.Process are not really this broken - http://youzen.b2.fi/~musasabi/bug.hs - very short example breaking them.
07:56:58 <Igloo> musasabi: What happens?
07:58:21 <musasabi> When run the program will print "hello: start" and then freeze. After pressing enter (the first getChar) System.Cmd.system will complete, but without that it will freeze for all eternity.
07:59:24 <jethr0> musasabi: i don't get it. why shouldn't a blocking getChar "freeze" the program?
08:00:12 <jethr0> and you might consider using NoBuffering if you want to read char-wise
08:01:00 <musasabi> jethr0: well with -threaded and all having a getChar freeze all threads is kind of problematic.
08:01:28 <kosmikus> Igloo: there are more drawing than those in my thesis. I assumed that shapr was referring to a larger set ... just the ones from the thesis would be easy to put online separately.
08:01:38 <Igloo> Ah, OK
08:02:08 <musasabi> (yes the real code has NoBuffering + a few thousends line of other code.
08:03:39 <shapr> kosmikus: It would be a good start!
08:04:15 <Igloo> musasabi: I'm no expert, but I suspect the dup2 of stdin can't be done while getChar is blockin
08:05:10 <musasabi> seems quite icky, any idea how to solve it, or should I just post to -cafe ?
08:05:46 <Igloo> I'd go for -cafe
08:09:29 <kowey> musasabi: this might be completely unrelated, but
08:09:50 <kowey> when i was having trouble with System.Process... i discovered that one thing i *have* to do is read from the subprocess's stderr
08:10:08 <kowey> or else, it just sits there waiting
08:15:16 <jethr0> musasabi: you're right. as always, i didn't read your example carefully enough, sry :)
08:17:24 <musasabi> kowey: setting up pipes + runInteractive process (or the System.Posix.*) is possible but I have to care about windows too.
08:17:48 <jethr0> musasabi: i've had severe problems with pipes and runInteractiveProcess
08:18:32 <jethr0> i tried to do a twoway pipe and everything worked well, until at some point the pipes just broke. i haven't been able to figure it out yet, but it sure cost me a lot of time trying :(
08:18:47 <kowey> jethr0: maybe you ran into the same problem i did with the whole stderr thing?
08:19:10 <jethr0> true
08:19:23 <jethr0> kowey: but i don't _want_ to read from stderr :)
08:20:38 <kowey> :-) ooh, i don't remember why the code looks like this, but forkIO (Control.Exception.evaluate (length errput) >> return ()) 
08:22:02 <kowey> well, anyway, http://trac.loria.fr/projects/geni/changeset/351
08:22:33 <jethr0> thx, i'll try that
08:23:23 <jethr0> bbl
08:25:21 <ihope> Is Stream like a list without the [] value?
08:26:05 <kowey> musasabi: maybe i'm being dense here, but isn't System.Process supposed to abstract around all this portability stuff?
08:26:23 <musasabi> ihope: yes. data Stream a = a :< Stream a
08:26:49 <musasabi> kowey: yes, actually System.Cmd > System.Process > System.Posix.Process
08:27:04 <musasabi> each layer calls the one under it (except on win32)
08:29:45 <musasabi> hmm, I think runInteractiveProcess may be enough.
08:31:14 <rgo_> Is there are papers/tutorials describing how to use Control.Concurrent?
08:31:49 <shapr> Yup, it's based on a single paper by Simon Marlow, iirc.
08:34:11 <eivuokko> Peyton-Jones' akward squad-paper is nice, too.
08:34:45 <eivuokko> awkward...I think I never learn to spell that word.
08:35:07 <shapr> It's an ak-word ;-)
08:35:20 <neologism> eivuokko: do you know awk the language?
08:35:28 <eivuokko> Unfortunately.
08:35:35 <rgo_> awkward-squad is good, but... i need examples
08:35:44 <neologism> so... awkward the word is created from it :0
08:35:51 <eivuokko> lol
08:38:16 <eivuokko> Is it considered terribly bad practice not to have async exception safety?  I don't feel like adding it...
08:42:10 <musasabi> got it working.
08:47:41 <jethr0> this might be dumb question, seeing how many papers he wrote, but which papers by SPJ are the most impressive? i.e. which ones should i "start" with?
08:48:10 <audreyt> @pl \x y -> text (x++y)
08:48:10 <lambdabot> (text .) . (++)
08:48:22 <shapr> That's really hard to answer. His books on implementing functional languages are great, and out of date ...
08:49:13 <jethr0> i think i'm going to read the composable mem. transactions now...
08:49:33 <shapr> jethr0: I'd say, 'follow your own interests'
08:49:34 <jethr0> shapr: you've read many of his papers, right? which one impressed you most (while understanding it :)?
08:49:39 <jethr0> k
08:49:47 <shapr> hmm
08:49:54 <Philippa> really, follow your interests
08:49:56 <shapr> I don't know.
08:50:07 <Philippa> possibly the most impressive thing for me about many of his papers is that they don't actually seem impressive on first reading
08:50:15 <Philippa> until you do a context check
08:50:18 <shapr> Yeah, they seem easy to absorb.
08:50:19 <jethr0> i'm really more interested in applications than pure research. but i guess i'll have a look around
08:50:29 <shapr> What sort of apps?
08:51:11 <jethr0> no, i mean applicable. as opposed to purely theoretical. i.e. i won't be programming my own type checker soon, but am rather interested in CMTransactions for their practical value..
08:57:54 <jethr0> k, got some shopping to do, bbl
08:57:55 <palomer> > [2,3]  - [1,2]
08:57:56 <lambdabot>  add an instance declaration for (Num [a])
08:57:56 <lambdabot>   In the definition of `puy': puy = [2, 3] - [1, 2]
08:57:56 <lambdabot>   In the definition of `v': v = let puy = [2, 3] - [1, 2] in take 2048 (
08:57:56 <lambdabot> show puy)
08:58:02 <palomer> > [2,3]  // [1,2]
08:58:03 <lambdabot>  Not in scope: `//'
08:58:05 <palomer> > [2,3]  \\ [1,2]
08:58:07 <lambdabot> [3]
09:12:19 * palomer wishes where clauses could encompass 2 declarations
09:13:24 <jethr0> palomer: huh?
09:13:47 <jethr0> ah, now i get it
09:13:55 <palomer> (foo  x= b; blah x = b) where b = ...
09:14:16 <jethr0> yup, that would be nice. although you might create those functions in the "where" and return them lisp-style
09:14:41 <jethr0> hmm, somehow that should be possible at least
09:15:14 <jethr0> i guess with helper functions.
09:15:51 <ski> 'where'-clauses can acces arguments
09:16:00 <palomer> ski!
09:16:08 <palomer> ski: you were talking about mercury and the ST monad before
09:16:19 <ski> (so you want a different thing .. SML 'local' :)
09:16:22 <palomer> ski: in mercury, you don't have that silly s parameter haunting you all the time, right?
09:16:33 <palomer> ski: where is pretty much like local, methinks
09:16:34 <ski> well
09:16:39 <ski> no
09:16:44 <ski> 'where' is like 'let'
09:16:48 <ski> (almost)
09:17:10 <palomer> local is like let too
09:17:15 <ski> no
09:17:19 <int-e> well, let works in more places than where.
09:17:25 <palomer> ski: ??
09:17:33 <ski> 'let' declares local things over an expression
09:17:40 <jethr0> what i mean is that sometimes you have function declarations with pattern matching and don't want to contract them into one declaration, but they share calculations that could be put into a common "where"
09:17:43 <ski> 'local' declares local things over a declaration
09:18:06 <palomer> ski: doesn't where declare local things over a declaration?
09:18:27 <ski> yes, over an atomic declaration
09:18:38 <ski> and you can use the arguments if it's a function
09:18:42 <ski> so it's like a let
09:19:31 <ski> ('atomic declaration' here = single clause/equation)
09:19:50 <palomer> ok, how is  where different from local?
09:20:12 <ski> 'local' can scope over non-atomic declarations
09:20:16 <ski> 'where' can use arguments
09:20:26 <palomer> ahh, gotcha
09:20:30 <ski> (vice versa for both is not possible)
09:21:02 <palomer> non atomic declaration == declaration of more than one thing?
09:21:03 <ski> but, yes, a 'local' in haskell would be nice
09:21:10 <ski> yes
09:21:21 <ski> like a sequence of several declarations
09:21:46 <ski> SML also have sequential and parallel decl.
09:22:20 <palomer> ski: are there any real advantages to have where part of the declarative syntax? (as opposed to having it as an inverted let)
09:22:50 <ski> are you just asking about syntax (i.e. order of things) ?
09:23:12 <palomer> I mean, have where do exactly the same thing as let
09:23:13 <ski> if not, then 'where' can scope ever several guards (both conditions and bodies, of course)
09:23:56 <palomer> have you ever used that fact?
09:23:56 <ski> to do that with 'let' you have to turn the pattern-matching into a 'case' (with 'let' outside)
09:24:08 <ski> yes
09:24:35 <ski> it's not essential, i guess .. but it can be nice
09:25:08 <ski> you asked something about Mercury ?
09:25:15 <palomer> yeah
09:25:29 <ski> both yes and no
09:25:31 <palomer> you had previously said that mercury uses existentials to get rid of the pesky s parameter I have to carry around with state
09:25:39 <ski> ah
09:25:47 <ski> that's not exactly what it does
09:26:36 <ski> you still have an 's' parameter
09:26:48 <ski> but instead of
09:27:12 <ski> runST :: forall a. (forall s. ST s a) -> a
09:27:17 <ski> you have basically
09:27:31 <ski> newStore :: exists s. Store s
09:27:52 <ski> so, the monad is decomposed
09:28:13 <palomer> and then you have runStore?
09:28:18 <ski> nono
09:28:40 <ski> think of it as   ST s a = Store s -> (Store s,a)
09:28:41 <ski> and
09:29:07 <ski> runST ma = snd (ma newStore)
09:29:12 <ski> or something like that
09:29:30 <Philippa> plus some enforced linearity?
09:29:35 <ski> indeed :)
09:30:00 <palomer> and how are STRefs typed?
09:30:09 <ski> same as in haskell, basically
09:30:25 <palomer> STRef s Int ?
09:30:35 <palomer> so you still have the pesky s variable floating around
09:30:37 <ski> newRef :: a -> Store s -> (Store s,Ref s a)
09:30:40 <ski> yes
09:30:47 <ski> for same reasons
09:30:49 * palomer is bothered by that s variable
09:31:20 <Philippa> don't be
09:31:23 <Philippa> it makes perfect sense
09:31:40 <ski> god kväll, shapr
09:31:42 <Philippa> suppose I do this within an ST computation: return (runST foo)
09:32:09 <Philippa> the cells used by foo can be deallocated once that runST finishes evaluation
09:32:34 <ski> (Philippa : didn't you think some on relating these vars to regions, btw ?)
09:32:52 <Philippa> A bit, though Oleg had an implementation before I did the thinking :-)
09:33:03 <ski> ('runST' is a bit like 'letregion', i think)
09:33:09 <ski> ok
09:33:33 <Philippa> you have to do a lot of extra legwork to get proper scoping on them
09:33:38 <Philippa> (that is, a stack-like discipline)
09:34:09 <Philippa> it might be possible to do it "for free" in some variant of Fsub, I don't know
09:34:10 <ski> mm
09:36:42 <palomer> Fsub?
09:36:51 <Philippa> System F + subtyping
09:38:12 <ski> (hm .. Fshub ..)
09:45:21 <palomer> ski: are there any advantages to doing it mercury's way?
09:45:27 <gzl> dammit, I'm blanking. what are |- and |= called again?
09:46:25 <palomer> |= is models, I think
09:46:48 <Philippa> palomer: um, arguably more information available for type-directed optimisation, I guess
09:46:59 <gzl> ah, no, |= is satisfaction
09:47:03 <Philippa> but you could implement the monad with a linear type and get the same result
09:47:14 <palomer> what's a linear type?
09:47:40 <Philippa> one whose values are used once and once only
09:48:07 <palomer> ie they only appear once in the term?
09:48:48 <ski> depends
09:49:12 <Philippa> not necessarily: consider case analysis, for example
09:49:16 <ski> 'if blah then foo x else bar x' uses 'x' in a linear way
09:49:41 <palomer> so how does one define "used only once" ?
09:49:53 <Philippa> used once in any given execution path
09:50:31 <Philippa> (where "used" = passed to a function, used as a scrutinee, that kind of thing)
09:50:31 <palomer> and when is a variable used?
09:50:37 <palomer> ahh
09:50:50 <ski> Gamma0 |- e0 : Bool   Gamma1 |- e1 : tau   Gamma1 |- e2 : tau
09:50:54 <ski> --------------------------------------------------------------
09:51:05 <ski> Gamma0,Gamma1 | if e0 then e1 else e2 : tau
09:51:28 <ski> also
09:51:31 <ski> --------------
09:51:36 <ski> x : tau |- x : tau
09:51:41 <ski> etc
09:51:58 <palomer> ski: ...?
09:52:07 <palomer> (oh, linear referers to linear logic, right?)
09:52:22 <ski> 'referers' ?
09:52:26 <palomer> refers
09:52:30 <ski> yes
09:53:25 <palomer> ski: what were those rules about?
09:53:33 <ski> type rules
09:54:01 <ski> (note that first rule uses 'Gamma1' in both branches)
09:54:25 <palomer> yeah, but what were they supposed to demonstrate?
09:54:47 <ski> that a linear variable can be used twice, if in parallel branches
09:55:43 <palomer> ahh, gotcha
09:55:50 <ski> 'if foo x then bar x else blah' is ill-typed if 'x' is linear
09:56:07 <ski> but 'if foo then bar x else baz x' is not
09:56:30 <ski> though 'if foo then bar x else blah' is ill-typed (in linear logic, as opposed to affine)
09:57:00 <palomer> I've been reading the re-release of the wobbly paper, and I can't quite get my head around it
09:57:07 <palomer> ski: have you read it?
09:57:11 <ski> no
09:58:08 <palomer> are there advantages to linear variables?
09:58:18 <ski> compared to what ?
09:58:35 <ski> affine ? ordinary ?
09:58:57 <ski> (relevant ? :)
09:59:16 <palomer> ordinary?
09:59:42 <ski> the usual kind, which you can discard and duplicate however you like
10:00:27 <palomer> no, I meant compared to ordinary variables
10:00:33 <ski> well
10:00:47 <ski> you can describe resources without the use of a monad
10:01:35 <palomer> is this what clean does?
10:01:49 <Philippa> once you use it, you can de-allocate it
10:02:02 <Philippa> if you know the maximum size, you can instead allocate it's state-like replacement there
10:02:06 <Philippa> *its
10:02:24 <Philippa> also, they allow you to type a number of things you can't otherwise: "must do things in this order"
10:02:53 <Philippa> for example, no more dangling resources if you can't hang on to the handle after you close/free it
10:02:53 <palomer> sounds neat, why doesn't everyone do this?
10:03:22 <audreyt> oh wow, "data MinHeap h a = H a (h a) deriving Show" becomes legal
10:03:47 <audreyt> and the context rules now makes sense (i.e. the way I imagined it must be, way back when I first learned of them)
10:03:58 <audreyt> # http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#instance-decls
10:03:59 <musasabi> audreyt: in GHC head ?
10:04:24 <audreyt> musasabi: yes
10:05:01 <musasabi> nice, that plagued some code for a long time :-)
10:05:04 <audreyt> musasabi: this is great news to me -- I'll no longer feel incoherent, overlapping, and undecidable in my daily use of typeclasses
10:05:54 <shapr> hej ski
10:08:28 <ski> you can describe resources without the use of a monad
10:08:30 <ski> e.g. arrays, worlds, files, gfx, etc
10:08:32 <TeR-> hi there, i type in my .hs file:   "module Main where main=  data Duo a b = Char a Char b" and i get  <<unexpected keyword "data">> . what i am doying wrong ?
10:08:35 <ski> palomer
10:08:45 <palomer> ski: why don't we all do things this way?
10:09:21 <ski> TeR- : you can't declare types inside your 'main' (or any other value declaration)
10:09:39 <TeR-> ski: so what should i do if i want to use it?
10:09:47 <TeR-> if i cant declare in it prompt either
10:09:53 <ski> module Main where
10:10:06 <ski>   data Duo a b = D Char a Char b
10:10:10 <ski>   main = ...
10:10:17 <ski> something like that, prolly
10:10:41 <ski> palomer : do all things in a linear way ?
10:11:05 <ski> or what did you mean ?
10:14:05 <palomer> @hoogle Monad m => [m a] -> m [a]
10:14:06 <lambdabot> No matches, try a more general search
10:14:27 <mauke> @hoogle [m a] -> m [a]
10:14:28 <lambdabot> Data.List.head :: [a] -> a
10:14:28 <lambdabot> Data.List.last :: [a] -> a
10:14:28 <lambdabot> Prelude.head :: [a] -> a
10:14:38 <ski> @type sequence
10:14:39 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
10:15:21 <ski> (palomer : i seem to remember ndm saying something about searching for 'Monad' typeclass things doesn't work, atm)
10:15:34 <ski> (palomer : also, may you clarify your question ?)
10:15:44 <palomer> ski: I mean, why even use monads when we could simply use linear variables
10:15:59 <ski> it requires a more complex type-system
10:16:10 <ski> also, Monads are not just for handling linear state
10:20:52 <palomer> ski: could you do all of IO in this way?
10:21:49 <ski> yes
10:21:58 <ski> Clean and Mercury do
10:22:56 <ski> (also, another nice things is e.g. that append on linear lists will perform-update-in-place on the tail)
10:23:18 <ski> (with the usual implementation of append)
10:23:27 <palomer> so monads can do more than linear variables
10:23:45 <palomer> but linear variables are nicer most of the time
10:23:57 <ski> they are for different things
10:24:04 <ski> only partly overlapping
10:25:14 <musasabi> I think it is more higher order types and linear variables.
10:25:33 <musasabi> things like ST
10:26:34 <ski> (what is more higher ... ?)
10:27:05 <audreyt> more $ higher
10:27:47 <davidhouse> @hoogle higher
10:27:47 <lambdabot> No matches found
10:27:50 <davidhouse> @hoogle more
10:27:51 <lambdabot> No matches found
10:28:19 <palomer> I intepreter "it is more higher ..." as "the following is more appropriate: higher..."
10:28:27 <musasabi> the problems one uses linear variables and higher order types have a quite large overlap.
10:28:29 <palomer> at least, that's how it is in montreal english
10:28:47 <palomer> higher order types == parameterized types?
10:28:54 <musasabi> woke up too early to code.
10:29:08 <Philippa> nope, Fomega rather than F
10:29:16 <ski> musasabi : example ?
10:29:16 <shapr> musasabi: Not enough sleep? or what?
10:29:57 <palomer> higher order types == type constructors?
10:30:03 <Philippa> palomer: I would not go so far as to say linear variables are nicer most of the time. There's no equivalent to monad transformers, for example
10:30:24 <palomer> but would you need monad transformers?
10:30:28 <Philippa> yes
10:30:32 <ski> this is due to different purposes
10:30:35 <Philippa> not all monads do mere state analogues
10:30:36 <musasabi> ski: ST, or the file handle code by oleg.
10:31:23 <ski> musasabi : one can have ST-like things at same time as linear things (like Mercury)
10:32:33 <ski> (even Clean has a few monad stuff, also)
10:32:58 <Philippa> I also can't see how to do a "withFewerCapabilities" kind of pattern safely with linear variables
10:33:12 <ski> what is that ?
10:33:56 <Philippa> for example, running a restricted version of the IO monad from within the IO monad itself
10:34:00 <Philippa> (say, concurrency only)
10:34:49 <Philippa> the linear equivalent leaves you performing an unsafe cast on anything you get back out and want to carry on using with full capabilities again
10:35:06 <ski> (*RestrWorld -> *RestrWorld) -> (*World -> *World)
10:35:22 <ski> would that work ?
10:35:50 <Philippa> if you had the function, yes. You've no way to prove it's safe though
10:36:02 <ski> just ADT ?
10:36:12 <Philippa> oh, wait, my bad
10:36:19 <flux__> philippa, hmm.. maybe you could have operations that 'split' the monad to limited IO and to a key, and afterwards you can merge those again to get the full IO monad
10:36:25 <Philippa> works for world. Doesn't work if you then need to play with eg restricted file access
10:36:53 <ski> in what sense ?
10:37:05 <flux__> key maybe being the function that casts the limited IO into full IO.
10:37:32 <TeR-> shit, i still don't know what's going on with this data types
10:37:44 <Philippa> flux__: you'd have to type-tag it, I guess (ala ST). Doable
10:37:52 <ski> TeR- in my example, 'D' was the data constructor
10:37:53 <TeR-> how can i test if my data type is really 'working' ?
10:37:58 <Philippa> but extremely type-invasive
10:37:59 <TeR-> hmm
10:38:08 <TeR-> i found an example in tutorial
10:38:18 <ski> TeR- : try typing "D 'a' 12 'b' False"
10:38:39 <ski> Philippa : i don't see the issue, yet
10:38:49 <TeR-> ok, i'll experiment more :]
10:38:55 <ski> (TeR- without the quotes, of course)
10:39:20 <Philippa> ski: all of a sudden, every damn datatype you can think of needs either rampant boxing-and-unboxing or a spare type parameter for the key
10:39:37 <ski> you're talking about "s" ?
10:39:49 <micty> hi
10:40:05 <ski> Philippa : i thought you were talking about linearity
10:40:07 <ski> hi micty
10:40:16 <micty> Is haskell good for servers that serves many users?
10:40:19 <micty> hi ski
10:40:37 <micty> (i.e. threads??)
10:40:44 <Lemmih> micty: Sure.
10:41:07 <TeR-> module Test
10:41:07 <TeR->     where
10:41:07 <TeR-> data Triple a b c = D Int a Char b String c
10:41:12 <TeR-> that's my file
10:41:15 <ski> (Philippa : btw, (un/)boxing for what purpose ?)
10:41:20 <TeR-> how can i check if it works ?
10:41:25 <Philippa> ski: we're talking about preserving capabilities on a state-like thing in a linear var across a stretch of code that deliberately reduces those capabilities
10:41:25 <Lemmih> micty: Glasgow Haskell got excellent interfaces to lightweight threads and OS threads.
10:41:26 <ski> try
10:41:45 <micty> Lemmih:: Good - ..... any pointer?
10:41:51 <ski> Test> D 12 'a' 'b' False "True" 13.7
10:41:54 <Philippa> the boxing/unboxing'd be to get your value, of some type that didn't know it'd get keyed in for greater capabilities, in and out of a container that carries that key
10:41:56 <micty> (to the doc?)
10:42:19 <gour> @where hIDE
10:42:19 <lambdabot> http://haskell.org/haskellwiki/HIDE
10:42:38 <TeR-> ski : 6 elements ?
10:42:46 <TeR-> i thought i declare only 3
10:42:49 <TeR-> module Test
10:42:50 <TeR->     where
10:42:50 <TeR-> data Triple a b c = D Int a Char b String c
10:42:58 <TeR-> a,b,c
10:43:00 <ski> that is 6
10:43:07 <ski> Int,a,Char,b,String,c
10:43:21 <TeR-> oh
10:43:25 <ski> three have fixed types, three have parametric types
10:43:32 <ski> if you just want fixed types, do
10:43:33 <TeR-> that means i really dont know what am i doing :P
10:43:45 <ski> data Triple = T Int Char String
10:44:19 <ski> if you want just parameterized, do
10:44:19 <micty> Lemmih: thanks, missed one message, I see it now
10:44:19 <ski> data Triple a b c = T a b c
10:44:24 <TeR-> and what if i want 2 of 4 be the same, but not declared?
10:44:49 <ski> what do you mean ?
10:44:59 <ski> data Foo a = F String a Bool a
10:45:00 <ski> ?
10:45:27 <TeR-> nope
10:45:33 <ski> that will have second and fourth of same type (but parameterized, so not fixed)
10:45:36 <TeR-> i want to have, i.e, 3 parameters
10:45:43 <TeR-> oh yes
10:45:50 <musasabi> data Foo a b c = F a b c ?
10:45:54 <TeR-> yes, it's the situation i am talking about
10:46:19 <TeR-> but a don't have to be the _same_ value in every apearence in this data type ?
10:46:21 <ski> if you want to fix args to have same type, just write same type in the decl :)
10:46:29 <ski> 'a' is the type
10:46:33 <TeR-> i see
10:46:36 <ski> can be 'Int' e.g
10:46:39 <Lemmih> micty: See Control.Concurrent
10:46:44 <Lemmih> @docs Control.Concurrent
10:46:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.
10:46:44 <lambdabot> html
10:47:32 <ski> Philippa : yes, but i'm not clear whether you were talking about linear things .. or ST-like things (those can be combined, of course)
10:47:46 <Lemmih> gour: hIDE should be buildable now.
10:48:50 <TeR-> data Triple a b c = D Int Char String
10:49:01 <Philippa> ski: ST-like as the way of carrying the improved capability tag. Linear as the underlying "what's going on", with linear values being cast to weaker types keyed to stronger ones
10:49:06 <TeR-> i type in hugs: D 3 'a' "34gefdg"
10:49:11 <ski> TeR- : that is pretty useless, most of the time
10:49:12 <Philippa> eg general file handles to read-only ones
10:49:14 <TeR-> and i get error
10:49:25 <TeR-> yes i know, it's only didactic :]
10:49:34 <ski> what error ?
10:49:34 <gour> Lemmih: what are the reqs?
10:50:12 <TeR-> cannot find 'show' function for:
10:50:15 <ski> Philippa : by 'linear values' do you mean stuff like references (STRef, etc) ?
10:50:18 <ski> ah
10:50:20 <TeR-> ***This Expression
10:50:24 <ski> data Triple a b c = D Int Char String
10:50:27 <ski>   deriving Show
10:50:35 <TeR-> i don't understand
10:50:38 <Lemmih> gour: Same as before; FilePath, FPS, gtk.hide, ghc.hide.
10:50:40 <ski> (or define your own 'show')
10:51:05 <ski> how to show values of a datatype is not automatically define, unless you demand it
10:51:08 <TeR-> so what the heck those user defined types stands for, when i can't use it !
10:51:11 <ski> (by 'deriving Show')
10:51:46 <gour> Lemmih: i'll try it
10:52:10 <ski> if you want,   D 3 'a' "34gefdg"  could be shown as  <"34gefdg",3,'a'>
10:52:22 <astrolabe> There are other ways of using something than showing it.
10:52:57 <ski> TeR- : so, just add 'dericing Show' after your type declaration
10:53:11 <TeR-> ski: i really don't see any sense of using those types if i can't do it in a source file :]
10:53:33 <ski> i'm meaning you should write that in your source file
10:54:16 <ski> hm
10:54:19 <TeR-> 'deriving Show' make's an error "unexpected keyword <<deriving>>"
10:54:25 <ski> indent
10:54:35 <ski> (there might be another prob, since you had params)
10:54:50 <ski> skip the 'a b c' part, for now (or use them on the RHS)
10:55:06 <ski> data Triple = D Int Char String
10:55:09 <ski>   deriving Show
10:55:18 <ski> see how i indented the second line
10:55:35 <ski> (you can indent it more if you like, or even put it on same line as the first part)
10:56:10 <TeR-> indeed, it works
10:56:54 <TeR-> the a,b,c,'s are necessary only if there's no fixed parameters ?
10:57:14 <ski> no
10:57:30 <TeR-> so what are they for ?
10:57:48 <astrolabe> data Triple a = D Int Char a
10:57:53 <ski> you use those (called type parameters/arguments) when you want to have part of the datastructure with non-fixed type
10:58:05 <ski> D 12 'a' False
10:58:09 <ski> D 12 'a' "foo"
10:58:13 <ski> both those are allowed
10:58:17 <ski> first has type
10:58:21 <ski> Triple Bool
10:58:24 <ski> other has type
10:58:27 <ski> TRiple String
10:58:33 <ski> (s/R/r/)
10:59:02 <ski> TeR- : do you know any of C,C++,Pascal,Ada,Java,C# ?
10:59:23 <TeR-> yes, c/c++ and c# a little bit
11:00:05 <ski> ok, then these type parameters are for defining types similar to "array of", "list of", "tree of"
11:00:25 <astrolabe> a bit like templates in C++
11:00:34 <ski> [1,2,3] :: [Int]   -- this has type "list of int"
11:00:38 <TeR-> yes, i think i understand what's it's all about :} [ those parameters, ofcourse]
11:00:48 <ski> ['a','b','c'] :: [Char]   -- this has type "list of char"
11:00:59 <ski> data Tree a = Leaf a
11:01:11 <ski>             | Branch (Tree a) (Tree a)
11:01:17 <TeR-> yes, templates is a good comparission, i think
11:01:19 <ski> this defines "tree of"
11:01:39 <ski> Branch (Leaf 1) (Leaf 2) :: Tree Int
11:01:41 <TeR-> ski: taken from tutoria, AFAIR ? :]
11:01:49 <ski> Branch (Leaf False) (Leaf True) :: Tree Bool
11:01:56 <ski> (taken from memory)
11:02:22 <TeR-> i'm impressed then
11:02:31 <TeR-> thank you very much ski
11:02:35 <ski> np
11:02:46 <TeR-> i wish i wouldn't need to ask another time
11:02:48 <TeR-> but i doubt it :P
11:30:59 <micty> @docs ~
11:30:59 <lambdabot> ~ not available
11:31:14 <vincenz> blegh
11:31:15 <vincenz> I hate c++
11:31:36 <micty> what is ~
11:31:38 <micty> ?
11:31:55 <vincenz> @type (~)
11:31:56 <lambdabot> parse error on input `)'
11:31:58 <araujo> ?
11:35:06 <Lemmih> > case undefined of ~(a,b) -> ()
11:35:07 <lambdabot> ()
11:35:09 <Lemmih> > case undefined of (a,b) -> ()
11:35:10 <lambdabot> Undefined
11:35:52 <roconnor> omg.
11:36:06 * roconnor 's head explodes
11:36:17 <ibid> why?
11:36:52 <roconnor> what's the syntax for case?
11:37:11 <roconnor> case undefined of ~(a,b) -> () | ~(0,1) -> ()
11:37:17 <roconnor> > case undefined of ~(a,b) -> () | ~(0,1) -> ()
11:37:18 <lambdabot>  parse error on input `|'
11:37:23 <Igloo> ; not |
11:37:24 <roconnor> > case undefined of ~(a,b) -> () ; ~(0,1) -> ()
11:37:24 <lambdabot>   Warning: Pattern match(es) are overlapped
11:37:24 <lambdabot>      In a case alternative: ~(0, 1) -> ...
11:37:26 <ski> s/|/;/
11:37:33 <roconnor> > case undefined of ~(1,2) -> () ; ~(0,1) -> ()
11:37:34 <lambdabot> ()
11:37:45 <roconnor> > case undefined of ~(1,2) -> 5 ; ~(0,1) -> 4
11:37:46 <lambdabot> 5
11:37:53 <roconnor> ?
11:38:00 <Igloo> ~pat always matches
11:38:10 <Igloo> You just might get failures if you try to use vars bound in pat
11:38:10 <roconnor> always matches?
11:38:13 <ski> so aren't those also overlapping ?
11:38:16 <Igloo> always matches
11:38:22 <Igloo> Yes
11:38:29 <Igloo> GHC's overlapping warnings aren't as good as they could be
11:38:36 <ski> m
11:38:52 <roconnor> what is the use?
11:39:13 <ski> Dialogue I/O was one use
11:39:35 <Igloo> They can fix space leaks by delaying evaluation of single-constructor datatypes
11:40:27 <Igloo> And they can sometimes allow code to be written more nicely, where you know you'll never need vars in cases where the pattern match would fail
11:45:18 <roconnor> the space leak optimization ought to be done automatically?
11:46:10 <Igloo> No - that optimisation would change the semantics
11:46:22 <roconnor> it would?
11:46:40 <roconnor> wouldn't it only make more computations converge?
11:47:52 <Igloo> Which changes the semantics
11:48:01 <musasabi> roconnor: think about errors happening inside or outside a catch.
11:48:14 <Igloo> It can probably also give worse performance in some cases
11:48:23 <roconnor> oh
11:49:29 <roconnor> musasabi, divergence doesn't cause expetions to be thrown.
11:50:06 <musasabi> Control.Exception catches matching failures.
11:50:37 <roconnor> a pattern match on a one constructor data type can't fail.
11:51:45 <ski> one would not like a program that seems to work on one compiler (+ optimisation flags) yield bottom on another, just because the optimisation wasn't done
11:52:28 <roconnor> I suppose that is true.
11:52:39 <ski> (turning bottom into non-bottom changes semantics)
11:53:07 <roconnor> Are let patterns lazy?
11:53:35 <roconnor> and do patterns.
11:53:54 <roconnor> > let (a,b) = undefined in ()
11:53:55 <lambdabot> ()
11:53:58 <roconnor> yay
11:54:21 <roconnor> So what is the use of ~ again?
11:55:02 <ski> lazy matching
11:55:24 <roconnor> where can I use it where I couldn't just use let?
11:56:02 <int-e> in patterns
11:56:48 <roconnor> the case example above isn't very convincing.
11:57:14 <ski> > let (x,Just y) = ('a',undefined) in x
11:57:15 <lambdabot> Undefined
11:57:21 <ski> > let (x, ~(Just y)) = ('a',undefined) in x
11:57:22 <lambdabot> 'a'
11:57:48 <roconnor> ?
11:58:00 <roconnor> bizare.
11:58:09 <ski> (just shows that '~' can still be relevant in 'let' bindings)
11:58:19 <roconnor> that seems broken.
11:58:29 <ski> if you use a variable from a 'let'-binding, whole pattern is matches
11:58:37 <ski> matched*
11:58:56 <roconnor> oh
11:59:30 <ski> 'let (x, ~(Just y)) = ('a',undefined) in x' is like 'case ('a',undefined) of ~(x, ~(Just y)) -> x'
11:59:50 <ski> (not generally, though)
12:00:01 <dcoutts_> because if the pattern didn't match then it was an error - but only if something from the pattern is used
12:00:39 <dcoutts_> as the translation to 'case' makes more obvious
12:01:08 <roconnor> let (x, (Just y)) = foo in bar ought to be the same as let (x, z) = foo in let (Just y) = z in bar.
12:01:12 <roconnor> ;)
12:01:50 <dcoutts_> > let (x, (Just y)) = 3 in 4
12:01:51 <lambdabot>  add an instance declaration for (Num (a, Maybe a1))
12:01:51 <lambdabot>   In a pattern binding: (x, (Just y)) = 3
12:01:51 <lambdabot>   In the definition of `vmk': vmk = let (x, (Just y)) = 3 in 4
12:01:56 <dcoutts_> bah
12:02:11 <roconnor> no type check for you ;)
12:02:18 <dcoutts_> > let (x, (Just y)) = undefined in 4
12:02:19 <lambdabot> 4
12:02:52 <ski> roconnor : you may have a point ..
12:03:14 <ski> (but it's not how it works)
12:03:15 <roconnor> ski, it is an interesting program transformation that you'd expect to have.
12:03:26 <roconnor> something to be careful of.
12:03:43 <ski> one should be carful with refutable patterns in 'let'
12:04:07 <roconnor> refutable patterns?
12:04:19 <ski> those that can fail, when matched
12:04:31 <ski> '~pat' is irrefutable
12:05:01 <roconnor> let (x, (y, z)) = ('a',undefined) in x
12:05:04 <roconnor> > let (x, (y, z)) = ('a',undefined) in x
12:05:05 <lambdabot> Undefined
12:05:08 <TuringTest> The let to case translation is specified here http://www.haskell.org/onlinereport/exps.html#sect3.12
12:05:13 <roconnor> > let (x, (y, z)) = ('a',undefined) in ()
12:05:14 <lambdabot> ()
12:05:27 <TuringTest> The lazy-matching irrefuatable  ~ patterns are here http://www.haskell.org/onlinereport/exps.html#sect3.17
12:05:27 <roconnor> this isn't a issue with refutability.
12:06:15 <ski> (mh, perchance not)
12:07:01 * palomer considers learning how to use quickcheck properly
12:07:10 <palomer> but checking my code would take as much time as writing it!
12:08:00 <TuringTest> palomer: Only as much as the first time.  The 2nd-10th time you need to maintain and debug  and refactor...
12:08:47 <palomer> only as much as the first time I write my code?
12:08:50 <palomer> oh, righto
12:12:31 <palomer> yes, I have polymorphic type checking!
12:12:35 <palomer> someone give me a term to type
12:12:55 <int-e> \a -> a a
12:13:13 * int-e cackles madly.
12:13:15 <TuringTest> @type (>>=)
12:13:16 <lambdabot> forall (m :: * -> *) b a.
12:13:16 <lambdabot>    (Monad m) =>
12:13:16 <lambdabot>    m a -> (a -> m b) -> m b
12:13:27 <palomer> ah crap, it loops
12:13:48 <ibid> occurs check?
12:14:52 <palomer> of course
12:15:38 <ibid> of course you have it or of course that's what's missing? ;)
12:15:43 <palomer> I have it
12:15:47 <palomer> but it's apparently broken
12:15:54 <roconnor> *LOL*
12:16:07 <roconnor> int-e: you're cruel
12:16:38 <palomer> the occurs check is incredibly simple, though
12:16:43 <int-e> hey, it doesn't get much simpler than that, I have one of everything: one variable, one abstraction, one application :-P
12:16:47 <ibid> palomer: are you using mutating unification or do you keep a substitutio?
12:16:54 <palomer> http://www.rafb.net/paste/results/VddV0C44.html
12:17:01 <palomer> ibid: mutating
12:17:52 <Phyx-> hi guys, one guestion, if i have a list like (a,b) how do i get the a and the b out? since i'm guessing they're not an array i can't use head
12:18:08 <roconnor> fst and snd
12:18:13 <roconnor> > fst (0,1)
12:18:14 <lambdabot> 0
12:18:17 <roconnor> > snd (0,1)
12:18:18 <lambdabot> 1
12:18:30 <Phyx-> ohh
12:18:35 <Phyx-> thank roconnor :)
12:18:36 <roconnor> btw, (a,b) is called a tupple.
12:18:41 <Phyx-> ahh, ok
12:18:41 <roconnor> or is it tuple.
12:18:45 <Phyx-> heheh
12:18:50 <ibid> Phyx-: (a,b) is not a list. [a,b] is a list :)
12:18:58 <ibid> Phyx-: head does not work on arrays
12:18:58 <ibid> :)
12:19:07 <ski> > let (a,b) = (3,4) in a + b
12:19:08 <lambdabot> 7
12:19:24 <Phyx-> errr, what's defined as an array then?
12:19:32 <Phyx-> thought [] was :P
12:19:35 <Muad_Dib> Phyx-: you don't want to go into array's yet
12:19:37 <roconnor> ski has a good point.  Pattern matching is the typical way of geting the data out.
12:19:37 <Muad_Dib> [] is a list
12:19:47 <Phyx-> well, you learn something new everyday :P
12:19:50 <int-e> palomer: are you sure it isn't the occurs check that's looping?
12:19:55 <ibid> Phyx-: arrays are an advanced topic in pure functional programming
12:19:55 <Philippa> and also generalises to n-tuples rather than just pairs
12:20:02 <Phyx-> k
12:20:10 <Phyx-> lemme see if this function works
12:20:14 <ibid> Phyx-: but if you like, have a look at the Data.Array module
12:20:15 <palomer> int-e: err, no, I'm not sure
12:20:15 <Muad_Dib> and although they look like each other, you should not confuse them
12:20:48 <ibid> Phyx-: just remember, arrays don't work like you'd think they do in pure fp
12:20:56 <Philippa> (n-tuple in the sense (1,2,3) is a 3-tuple)
12:21:34 <Phyx-> ibid: hehe, nah, i'll stick to the basics for now, we just started with haskell in school so
12:22:06 <Muad_Dib> Phyx-: what school
12:22:06 <Muad_Dib> ?
12:22:11 <palomer> man, I wish there was a really easy way to figure out where a program is looping from ghc
12:22:22 <int-e> palomer: err, the 'and' needs to be an 'or'
12:22:28 <Phyx-> Muad_Dib: UU
12:22:31 <ski> Phyx- : if you have pairs (or tuples) in the argument(s) of a function, you usually use pattern-matching to get the parts out
12:22:43 <Muad_Dib> Phyx-: nice :) using helium then
12:22:53 <ski> foo ((a,b):abList) = ...
12:23:03 <Phyx-> hmmm k
12:23:07 <Phyx-> Muad_Dib: yep ^_^
12:23:10 <Phyx-> Muad_Dib: you go there 2?
12:23:26 <Muad_Dib> Phyx-: i'm a master student
12:23:28 * int-e wonders if there's an orM
12:23:31 <int-e> @index orM
12:23:31 * Phyx- wonders if Muad_Dib is his teacher
12:23:32 <lambdabot> bzzt
12:23:34 <Phyx-> ohh, ok
12:23:42 <Phyx-> :)
12:23:43 <dcoutts_> Igloo, do you do ppc64 on debian or ppc32 or both?
12:23:59 <Igloo> 32 AFAIK
12:24:11 <int-e> @index foldM
12:24:12 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
12:24:12 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
12:24:12 <lambdabot> Control.Monad.Error, Control.Monad.List
12:24:25 <int-e> @type Control.Monad.foldM
12:24:26 <lambdabot> forall a (m :: * -> *) b.
12:24:26 <lambdabot>         (Monad m) =>
12:24:26 <lambdabot>         (a -> b -> m a) -> a -> [b] -> m a
12:24:33 <Phyx-> btw, while you guys re being so helpfull, i wrote this function, http://www.rafb.net/paste/results/XSCBvx79.html i was wondering, it works fine, just wondering if it can be smaller, or if something's wrong with it
12:24:52 <Phyx-> Muad_Dib: you went quiet after a i said that :P
12:25:07 <dcoutts_> Igloo, yeah, ghc-6.4.1 works for us with ppc32 but the ppc64 people seem to be getting build errors and high level makefile ones not bit level ones.
12:25:33 <int-e> Phyx-: not ((filter (==b) e)==[] --> any (==b) e
12:25:45 <Muad_Dib> Phyx-: == True isn't needed
12:25:46 <Muad_Dib> :P
12:26:17 <Phyx-> int-e: really?
12:26:18 <Phyx-> cool
12:26:25 <int-e> and the whole function seems to be a filter?
12:26:26 * Phyx- looks it up in functions refernce
12:26:42 <Phyx-> int-e: what can i say, beginners function :P
12:26:59 <Muad_Dib> Phyx-: int-e is right
12:27:14 <Muad_Dib> what your function does is filter all items that are in the category
12:27:15 <Phyx-> nice :D "returns True if at least one item in the list fulfills the condition"
12:27:25 <flux__> we need a code simplifier module to lambdabot.. ;)
12:27:38 <Muad_Dib> nah
12:27:44 <Phyx-> Muad_Dib: yeah, that's what we were supposed to write.
12:27:48 <Muad_Dib> flux__: we need a module to lambdabot that writes the code we want
12:27:56 <flux__> yeah.
12:27:58 <Phyx-> thanx Muad_Dib , int-e , usefull function :)
12:28:01 <flux__> once you describe what you want, in haskell?
12:28:05 <Muad_Dib> Phyx-: http://www.cs.uu.nl/helium/docs/TourOfPrelude.html#filter
12:28:57 <Phyx-> Muad_Dib: that ==true is there since i build that function up from 3 functions and kept collapsing it into one
12:29:10 <Phyx-> why it may have been to much :P
12:30:01 <ski> flux__ : we have @pl
12:30:12 <flux__> ski, yeah, but it doesn't exactly simplify it..
12:30:19 <flux__> most often it just obscures :P
12:30:26 <ski> bah :)
12:30:29 <flux__> ski, I've made a wish for unpl too ;)
12:30:38 <Muad_Dib> Phyx-: so, look at filter; if you use that you won't need the recursion anymore
12:31:01 * Phyx- looks again
12:31:29 * Phyx- thinks he sees it
12:32:32 <Phyx-> actually... no....
12:32:56 <Phyx-> lol, you have for instance [[a],[b]] and i need to filter something in [a]
12:33:32 <Phyx-> or use nested filters.. if i'm getting you Muad_Dib 
12:33:49 <Muad_Dib> you dont have [[a],[b]] isnt a type
12:34:12 <ski> (the inner 'filter' could be replaced by 'any', see above)
12:34:43 <Phyx-> ski: i already did that, i looked it up also to learn what it does :P
12:35:18 <ski> so, you want a 'filter' with an 'any', "inside", i think
12:35:48 <TuringTest> @type elem
12:35:49 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:36:07 <TuringTest> > elem 'b' "Phyr"
12:36:08 <lambdabot> False
12:36:14 <TuringTest> >elem 'y' "Phyr"
12:36:27 <TuringTest> > elem 'y' "Phyr"
12:36:28 <lambdabot> True
12:36:28 <Phyx-> o.O
12:36:34 <TuringTest> @type notElem
12:36:35 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:36:45 <TuringTest> > notElem 'z' "Phyr"
12:36:46 <lambdabot> True
12:36:50 <Muad_Dib> >notElem 'y' "Phyr"
12:37:00 <Muad_Dib> > notElem 'y' "Phyr"
12:37:00 <TuringTest> notElem 8 [2,3,5,7,11,13,17]
12:37:01 <lambdabot> False
12:37:04 <TuringTest> > notElem 8 [2,3,5,7,11,13,17]
12:37:05 <lambdabot> True
12:37:31 <TuringTest> Phyx-:  Do you see how to recode your test now?
12:37:37 * ski mutters something about putting in '> '
12:37:57 <int-e> dang. elem, of course :)
12:38:31 <Muad_Dib> > ski or about not putting it in
12:38:32 <lambdabot>  parse error on input `in'
12:38:32 <Muad_Dib> :)
12:39:15 <Phyx-> TuringTest:  i think so, already trying :P
12:39:34 <Muad_Dib> can you define functions on lambdabot so he remembers them? :P
12:40:13 <TuringTest> Muad_Dib: lambdabot is not a 'he'
12:40:53 <TuringTest> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:41:00 <Muad_Dib> i know, but when she dates me on saturday evening i dress as a girl and she as a guy.
12:41:24 <Muad_Dib> err
12:41:34 <Muad_Dib> let us take offtopic talk to #haskell-blah and stay on haskell in here.
12:42:08 * TuringTest returns to Phyx-
12:42:11 <TuringTest> Working?
12:42:32 <roconnor> @spell tupple
12:42:32 <lambdabot> tipple tuple topple tippler duple
12:42:38 <roconnor> @spell tuple
12:42:38 <lambdabot> tuple
12:42:41 <gour> dcoutts_: hi, what is the consensus regarding treeview api?
12:42:45 <ski> tuple
12:42:58 <dcoutts_> gour, that we need to get it finnished :-)
12:43:16 <gour> dcoutts_: that is a good one :-)
12:44:11 <Phyx-> TuringTest: not yet, sorry, kinda slow, will figure it out soon, 2nd week of haskell :P and first time actually reading trying it, heheh
12:44:41 <TuringTest> understood
12:45:04 <MarcWeber> Which is the module to import to get the C Types? base.foreign.C.Types?
12:47:51 <dcoutts> import Foreign.C
12:49:03 <MarcWeber> dcoutts Thanks again
12:52:27 <Phyx-> TuringTest: just came back to the notebook :P went to get soom food
12:52:38 <Phyx-> oops, sorry was scrolled up
12:52:44 <Phyx-> thought you asked again :P
12:52:45 <Phyx-> heeh
13:02:47 <ihope_> Whoo boy...
13:03:24 <ihope_> newtype NT a = Fix (NT a -> a)
13:03:43 <ski> cool, yes ?
13:04:50 <ski> NT (\f -> f (NT f))
13:05:40 <ihope_> Um...
13:05:55 <ihope_> Hmm, wait a minute...
13:06:57 <ski> no, skip the outer 'NT'
13:07:44 <ski> NT (\x@(NT f) -> f x)   -- i think
13:08:16 <ihope_> s/NT/Fix/?
13:09:47 <ski> er, ya
13:10:06 <ski> (why 'NT', btw ?)
13:10:06 <Phyx-> ski: lol, maybe it's me, but i don't see any diff between using elem and any, in this case
13:10:24 <ski> 'elem' is simpler
13:10:49 <ski> elem x xs = any (== x) xs
13:11:22 <Phyx-> yes, i figured that part out
13:11:38 <Phyx-> one thing i can't, is this.
13:11:39 <Phyx-> 21:30:13 < Muad_Dib> Phyx-: so, look at filter; if you use that you won't need 
13:11:39 <Phyx->                      the recursion anymore
13:11:40 <ihope_> ski: non-termination
13:12:12 * ski 's seen 'U' used for that type
13:13:19 * Phyx- wishes you could debug haskell like in c++
13:13:28 <Phyx-> visual haskell :P
13:16:11 <shapr> Have you ever seen a non-strict stack trace?
13:19:53 * Phyx- thinks he finally gets what Muad_Dib was saying
13:19:54 <Phyx-> heheh
13:19:59 <Philippa> yes. I've forgotten what I'd taken at the time, and I don't want to remember
13:20:04 <Phyx-> atleast now i won't forget it
13:26:21 <Muad_Dib> Phyx-: if you get it, show your new code :)
13:31:49 <Phyx-> Muad_Dib: heheh, busy on it :P
13:35:25 <tibbe> what type of assembler would one generate if one would like to compile an eager functional language (with partial application? Alot of one argument functions?
13:35:48 <tibbe> lazy use graph reduction, would that be the way to go for eager as well?
13:37:00 <shapr> Have you read SPJ's latest paper that does both lazy and strict on a single intermediate language?
13:37:11 <tibbe> shapr, nope, link?
13:37:22 <tibbe> on his MS page?
13:37:27 <shapr> I think so.
13:37:50 <tibbe> [Jan 2006] Haskell is not not ML (ESOP'06; main credit to Ben Rudiak-Gould and Alan Mycroft) describes a CPS-based intermediate language that can serve as a target for both call-by-name and call-by-value.
13:38:04 <shapr> Yup
13:41:11 <tibbe> is there a difference between strict and eager?
13:44:37 <shapr> Yees, sort of...
13:44:58 <shapr> For example, there was the speculative branch of GHC for awhile...
13:45:43 <shapr> So you can have non-strict and eager.
13:46:32 <tibbe> but what does it mean?
13:47:12 <tibbe> i thought strict = eager = call by value
13:49:18 <shapr> According to Wikipedia, you are correct. http://en.wikipedia.org/wiki/Eager_evaluation
13:49:20 <Cale> well, strict/nonstrict refer to semantics, lazy/eager refer to evaluation mechanisms
13:49:47 <shapr> But from what I've read, I think there's a difference.
13:50:20 <Cale> Normally eager evaluation doesn't have non-strict semantics, but you can get "mostly eager" evaluation mechanisms which still guarantee non-strict semantics.
13:51:13 <Cale> Innermost-first-until-that-seems-to-not-be-working :)
13:51:31 <tibbe> :D
13:51:53 <tibbe> I read something about linient (sp?) evaluation somewhere
13:52:04 <ski> lenient
13:52:54 <tibbe> thanks
13:53:09 <Phyx-> in an n-tupple list, how can i get a spefic item in that index at a chosen index
13:53:26 <Phyx-> like in (a,b) fst returns a
13:53:36 <Phyx-> but in (a,b,c,d,e) for instance, how do i get c
13:53:52 <tibbe> third? ;)
13:53:52 <Philippa> pattern-match
13:53:56 <tibbe> @type third
13:53:56 <lambdabot> Not in scope: `third'
13:54:06 <Philippa> you can't write a function that works on tuples of any length - if you want that, use a list
13:54:08 <Cale> Phyx-: use case
13:54:12 <Muad_Dib> third (_,_,c,_,_) = c
13:54:46 <Cale> (case myTuple of (_,_,c,_,_) -> c)
13:54:54 <Cale> or even
13:55:03 <tibbe> "In an attempt to combine some of the benefits of lazy and eager evaluation, I have implemented a language with an evaluation strategy which is strict with respect to divergence, but performs lazy evaluation on certain intermediate subterms to allow a more expressive use of recursion."
13:55:08 <Maddas> Isn't call by value/not call by value orthogonal to lazy/eager evaluation?
13:55:15 <tibbe> what does divergence mean in this context?
13:55:31 <Phyx-> hmmm k
13:55:42 <Cale> Phyx-: well, I'm sure you can imagine other places to pattern match (you can do it with a lambda too)
13:56:10 <ski> foo blah ... = ...
13:56:13 <ski>   where
13:56:18 <ski>   (_,_,c,_,_) = bleh
13:56:36 <ski> (or 'let')
13:57:02 <Phyx-> Cale: i wanted to do it without making another function if possible, but i'll keep my current approach
13:57:07 <ski> tibbe : nontermination (and possibly partiality)
13:57:20 <Phyx-> i'm using unzip4 on a list, and i need the last items in the list to work with
13:57:49 <tibbe> ski, ah
13:58:41 * Phyx- is still to damn used to imperative programming languages
14:00:28 <Cale> Phyx-: long tuples are uncommon in Haskell code
14:01:16 <Cale> Phyx-: I hardly ever use anything over a pair
14:01:50 <Phyx-> i c
14:01:54 <Cale> If you really need lots of data of different types, you should create a custom datatype
14:02:05 <Phyx-> like i said, i'm still way to used to imperative programming
14:02:45 <Phyx-> :P
14:03:21 <Cale> yeah, there are some pretty big stylistic changes that happen :)
14:05:06 <Muad_Dib> but thats what doaitse will help you with Phyx- :)
14:05:12 <Muad_Dib> he probably didnt teach you about data types yet?
14:05:47 <Phyx-> wow, i'm supprised you remembered how to spell his name :O i keep forgetting it.
14:06:04 <Phyx-> nah, no datatypes yet, though he does use them in the assignment, so i think we'll cover em soon
14:06:32 <Phyx-> i just like to learn on my own :P i think the assignment hasn't officially started yet
14:06:37 <Phyx-> think this week
14:07:51 <Muad_Dib> thats a good thing :)
14:08:31 <imix> cale: hi, you remember the program we had a look at? you mentioned some simplifications that would make the program clearer to debug. Any hints on what i could do with my program to make it more debugable?
14:08:33 <Phyx-> btw, have i seen you before? maybe on efnet?
14:10:08 <Muad_Dib> me?
14:10:12 <Phyx-> yeah
14:10:19 <Phyx-> your nick looks familiar
14:10:57 <Muad_Dib> Phyx-: yeah well, i'm such a cool guy, people tend to steal my nick on networks where i do not hang around :)
14:11:03 <Phyx-> rofl
14:11:12 <lscd> lol
14:11:14 <Phyx-> hahahaha :P
14:11:34 <lscd> they're duned to imitate you, eh?
14:11:52 <Phyx-> well, yeah, i'd agree that this channel is helpfull, must channel say "google it" and then i get banned :P
14:12:56 <Muad_Dib> lscd: lmao
14:13:35 <Phyx-> ohh noes... *phew* thought i was getting a bsod
14:21:15 <micty> how is the performance of haskell program vs.?
14:23:03 * ptolomy looks around.
14:23:05 <Saulzar> micty, Typically it's harder to get great performance out of a naive haskell program, but there are areas where it excells
14:23:07 <ptolomy> micty, vs what?
14:23:30 <Saulzar> micty, For example if you look at http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all,  you can see that it is very possible to optimise haskell code
14:24:54 <micty> ptolomy Java/C/C++
14:25:01 <TuringTest> micty: Haskell has types and is compiled, so it can create as optimal an executable as similar systems.
14:26:29 <ptolomy> but, depending on the problem domain, it is not unfair to say that idiomatic haskell tends to not be as fast as idiomatic C/C++/Java.
14:26:39 <ptolomy> It is also not unfair to say that it makes up for it in other areas, imho.
14:29:59 <jyp> The crucial point is that for most applications, the time you save by using haskell allows you to optimize much more than an equivalent C/... app
14:31:07 <micty> jyp how do you optimize?
14:31:26 <ptolomy> there are a lot of ways to answer that one..
14:31:43 <jyp> micty: finding better algorithms, etc.
14:31:57 <micty> jyp - I mean is it a 'compile -O9' or manual
14:32:43 <jyp> what do you mean ?
14:33:06 <micty> jyp- I wrote it and got your answer as I pressed enter
14:33:12 <jyp> k :)
14:33:47 <jyp> A good example is that it's much easier to have a scalable architecture in haskell
14:34:10 <jyp> even more with the upcoming parallel GHC
14:34:34 <micty> jyp - I can believe that, though I just started to read about it a couple of days ago
14:36:17 * ptolomy drools in anticipation of GHC 6.6
14:36:29 <micty> but from what I read, I worry when I see things like: "fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]" I like things to be a little longer and clearer
14:37:02 <araujo> Greetings.
14:37:13 <jyp> It's extremely clear when you take time to read it :)
14:37:20 <micty> maybe I just need some time to adjust
14:38:34 <jyp> Only half joking... Haskell is much more concise, so you need to read a bit slower.
14:38:40 <ptolomy> Haskell is a profound language. You can say more in two lines than some languages can say in 200. I don't really consider it density so much as very abstract clarity.
14:38:56 <jyp> heh :)
14:45:41 <gzl> micty: yeah, the longer thing really isn't clearer.
14:46:49 <ptolomy> although, the given example is kinda yucky.
14:47:42 <gzl> yeah.
14:47:54 * ptolomy would've gone with "fibs = 1 : 1 : zipWith (+) fibs (tail fibs)". 
14:48:34 <ptolomy> Of course, that probably still isn't obvious to someone not familiar with recursion, the fibonacci series, and haskell.
14:49:39 <gzl> sure. but what is such a person doing reading a recursive fibonacci series program in Haskell? :)
14:50:00 <ptolomy> heh. True.
14:50:10 <lscd> trying to learn about one or more of the above? ;)
14:50:48 <gzl> if you're learning you probably shouldn't be judging so quickly.
14:51:27 <lscd> oh, sure; i'm not saying that a beginner would be judging these alternatives against each other; it's just one reason why someone might read such code
14:51:37 <micty> That fib is from the gentel tutorial
14:51:49 <gzl> oh, sure.
14:52:45 <lscd> the gentle tutorial isn't
14:52:57 <micty> they wanted to explain lazy ~, and  as paterns @, and then was this
14:53:48 <ihope_> > let (x:xs) = [1,2,3] in (x,xs)
14:53:49 <micty> fib
14:53:49 <lambdabot> (1,[2,3])
14:53:53 <ihope_> Yay!
14:53:53 <jyp> "A scary introduction to haskell"
14:54:13 <micty> do you have a better one?
14:55:13 <ihope_> Well, the one at Wikibooks is one.
14:55:25 <ihope_> I dunno about "better".
14:55:58 <micty> I got to IO on this one
14:56:20 <micty> next next is Monads
14:56:32 * micty shivers
14:56:47 <lscd> micty: i've been trying to go through yet another haskell tutorial; it's ok, though chapter 4 threw me
14:58:31 <micty> are there already sub languages derived of haskell
14:58:33 <micty> ?
14:59:20 <kowey> lscd: is chapter 4 about continuation passing style?
15:01:19 <lscd> kowey: no, 'type basics'
15:01:49 <kowey> oh... ok, i was going to say, i skipped that bit, and am surviving without it
15:02:15 <ihope_> > take 3 []
15:02:16 <lambdabot> Add a type signature
15:02:22 <ihope_> > take 3 [] :: [()]
15:02:23 <lambdabot> []
15:02:30 <lscd> yeah; type basics are important, though the part that was stumping me was sort of confusing this channel too, so meh
15:04:18 <micty> What I have got from 4, is that if you want to overload a function you need it to  be in a type class
15:05:52 <micty> but that was something I was looking for. I read SML tutorial which don't have overloading, so I liked it, that haskell has it.
15:06:44 <ihope_> > (\~(Just x) -> x) Nothing
15:06:44 <lambdabot>  parse error on input `->'
15:06:58 <ihope_> > case Nothing of ~(Just x) -> x
15:06:58 <lambdabot> Add a type signature
15:07:05 <ihope_> > case Nothing of ~(Just x) -> x :: ()
15:07:06 <lambdabot>  Irrefutable pattern failed for pattern (Data.Maybe.Just x)
15:07:21 <ihope_> > case Nothing of Just x -> x :: ()
15:07:22 <lambdabot>  Non-exhaustive patterns in case
15:09:44 <Lokadin> what's the award website for discriminating hackers?
15:10:12 <Lokadin> slipstream: how much does adsl cost in russia?
15:11:00 <micty> Good night
15:11:05 * micty go to sleep
15:13:55 <astrolabe> Lokadin: http://icfpc.plt-scheme.org/
15:18:50 <Lokadin> astrolabe: thanx
15:20:46 <palomer> ok, what's a full proof way of finding out where my code is looping?
15:23:08 <astrolabe> Stare at it for ages, until you say 'doh'.
15:27:09 <palomer> what's that app that people use to find this out?
15:28:15 <eivuokko> Debug.Trace.trace is common, I think
15:30:19 <astrolabe> Do you mean the compiler finds a loop? or that it won't finish running?
15:30:33 <palomer> it doesn't finish running
15:31:20 <astrolabe> I guess I'd either try what eivuokko says, or play with GHCi
15:31:38 <astrolabe> Though I'm not very knowledgeable :(
15:32:10 <palomer> I remember there was an application for this
15:32:13 <palomer> hat maybe?
15:32:28 <astrolabe> Yeah, I think hat would do it.
15:32:38 <astrolabe> But I can't get it.
15:33:06 <palomer> me neither
15:33:12 <palomer> won't compile on my system
15:34:05 <palomer> ah yes, profiling
15:37:08 <slipstream> Lokadin: ~$20..25 for 128k..256k/unlimited
15:38:02 <palomer> hrm
15:43:06 <palomer> ghcprof: UDG_HOME environment variable not set <---??
15:47:55 <ihope_> I have too much email now.
15:55:40 <sethk> anyone know how to get rid of this message?  It's related to ghc and the package manager with ubuntu (which is the debian package manager):  trying to register HUnit-1.0 as exposed, but HUnit-1.1 is also exposed
15:55:47 <sethk> I actually don't need HUnit at all
15:56:54 <xerox_> sethk: ghc-pkg hide HUnit-1.0  maybe
15:57:11 <sethk> xerox, ok.  I just tried an uninstall of hunit, if that doesn't work...
15:57:40 <xerox_> Type "ghc-pkg" to see what it could do, it's quite simple.
15:57:43 <sethk> that's what I hate about these package managers.  once screwed up they are virtually impossible to fix
15:57:51 <ihope_> @type foldr
15:57:52 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
15:58:42 <xerox_> G'night.
15:58:51 <ihope_> Aha, I think. foldr (:) []
15:59:00 <ihope_> s/foldr (:) []//
15:59:20 <xerox_> > let r = foldr (flip (:)) [] in r [1..10]
15:59:21 <lambdabot>   Occurs check: cannot construct the infinite type: c = [c]
15:59:21 <lambdabot>   Expected type: c -> [c] -> c
15:59:21 <lambdabot>   Inferred type: c -> [c] -> [c]
15:59:25 <xerox_> prrrr.
15:59:52 <ihope_> > foldr (flip (:))
15:59:53 <lambdabot>   Occurs check: cannot construct the infinite type: c = [c]
15:59:53 <lambdabot>   Expected type: c -> [c] -> c
15:59:53 <lambdabot>   Inferred type: c -> [c] -> [c]
15:59:59 <ihope_> Whoo.
16:01:10 <palomer> hrmph
16:01:16 <palomer> isn't there any way whatsoever to have a printf in ST?
16:04:09 <ihope_> Um...
16:04:11 <jethr0> palomer: maybe with MonadIO?
16:04:18 <ihope_> MonadIO?
16:04:26 <palomer> hrm, performUnsafeIO seems to be the only option
16:06:04 <jethr0> palomer: yes, but performUnsafeIO is slightly evil. on the other hand trace uses it...
16:06:22 <ihope_> What are you trying to do?
16:07:16 <palomer> find out exactly where my program is looping
16:07:19 <palomer> how does trace work?
16:07:51 <jethr0> palomer: you just put it in front of any expression  "x = trace "hello" 2"
16:09:02 <jethr0> palomer: is it short enough to lisppaste?
16:09:42 <jethr0> alternatively profiling might help, as it will pinpoint the function that's executed most of the time, and it even works if you kill the process prematurely
16:09:51 <palomer> trace rocks!
16:09:55 <jethr0> :)
16:10:03 <MarcWeber> Any idea why Setup.hs files work after compiling with ghc, but not with runhaskell on windows? With package Cabal-1.0 it worked both fine
16:10:28 <MarcWeber> Do you know of a haskell make project?
16:10:44 <palomer> why didn't anyone tell me about trace before?
16:10:45 <palomer> WHY
16:10:59 <jethr0> should've asked :)
16:11:50 <jethr0> although there can be issues with evaluation time. trace is executed only as often as the expression it "prefixes". so if you want it to appear more often you might have to pull function params into the expression
16:12:08 <jethr0> like "f a b = \c -> trace "hello" a*b*c" or something like that
16:12:26 <sethk> in case anyone else has that hunit problem with ubuntu I, well, I didn't really fix it but I worked around it.
16:12:38 <palomer> man trace rocks
16:12:52 <palomer> jethr0: that shouldn't be a problem in ST
16:13:00 <jethr0> palomer: no, probably not
16:13:34 <palomer> man that was a silly bug
16:13:45 <jethr0> the most annoying ones always are!
16:36:54 <ihope_> @type fromEnum
16:36:55 <lambdabot> forall a. (Enum a) => a -> Int
16:37:00 <ihope_> > fromEnum ','
16:37:01 <lambdabot> 44
16:47:07 <ihope_> @type fromIntegral
16:47:08 <lambdabot> forall b a. (Num b, Integral a) => a -> b
16:47:27 <ihope_> @type fromIntegral (3 :: Int)
16:47:28 <lambdabot> forall b. (Num b) => b
16:48:00 <ihope_> Does that use fromInteger?
16:50:56 <ihope_> > 1/0 :: Integer
16:50:57 <lambdabot>  add an instance declaration for (Fractional Integer)
16:50:57 <lambdabot>   In the expression: 1 / 0 :: Integer
16:50:57 <lambdabot>   In the definition of `ify': ify = 1 / 0 :: Integer
16:51:05 <ihope_> > 1 `div` 0 :: Integer
16:51:06 <lambdabot> Exception: divide by zero
16:52:40 <joelk> @yow --hmm...
16:52:41 <lambdabot> quote module failed: getRandItem: empty list
16:53:44 <dons> oh, that bug really annoys me
16:53:52 <dons> @quit try again.
17:05:51 <palomer_> do some people call "constructors" something else?
17:06:30 <Philippa> not that I'm aware of, though they're sometimes grouped into data constructors and type constructors for example
17:08:29 <palomer_> constructors should be renamed to "value constructors"
17:08:37 <palomer_> data is too vague:o!
17:10:45 <Philippa> ITYM data constructors should be renamed value constructors...
17:11:04 <palomer_> ITYM?
17:11:04 <Philippa> wanna talk about algebraic value types too? :-)
17:11:08 <Philippa> I Think You Mean
17:11:12 <palomer_> yeah
17:11:22 <palomer_> when people say "constructor" they usually mean "data constructor"
17:11:46 <Philippa> context. People write more values than types
17:11:57 <palomer_> true
17:12:05 <dons> yep, it's reasonable to make common things cheaper to write/say
17:12:06 <palomer_> but yes, data constructors should be renamed to value constructors
17:13:19 <araujo> Then we should change, 'data type' to 'value type' too :-]
17:13:34 <Philippa> quite. The association between data constructors and data types is clear enough IMO
17:13:36 <araujo> And i don't think many people will like that 
17:13:53 <Philippa> especially not if you force them to talk about abstract value types
17:14:10 <palomer_> datatype is really just a type
17:14:33 <Philippa> no. See "codata"
17:14:49 <palomer_> that sounds evil
17:16:40 <Philippa> really it's just coalgebraic datatypes, but hey
17:17:56 <palomer_> things like codata List a = Cons a (List a) ?
17:18:47 <ihope_> So what's this "data Foo a where bar :: Baz a" stuff called again?
17:19:02 <palomer_> generalized algebraic data types?
17:19:24 <Philippa> yeah. Though that's not a valid one
17:19:40 <palomer_> yeah, the return type has to be of the form Foo x
17:19:53 <ihope_> type Baz a = Qux -> Foo a?
17:19:55 <Philippa> palomer_: there's a paper on codata and comonads if you want to read
17:20:24 <palomer_> can't right now, working hard and heavy on H-M
17:20:31 <Philippa> ihope_: data Foo a where Bar :: Baz -> Foo Quux
17:20:36 <palomer_> Philippa: btw, the only time you instantiate types in H-M is at axiom, right?
17:20:37 <ihope_> If monad : comonad :: data : codata, then "eek!"
17:21:16 <ihope_> Philippa: but will my two definitions work?
17:21:17 <Philippa> palomer_: um. IANATypeTheorist, much as I dabble
17:22:13 <Philippa> ihope_: the type synonym'll work because it's valid H98. The first one won't because bar (aside from not being a Constructor) has the wrong return type
17:22:49 <ihope_> s/bar/Bar/
17:23:26 <Philippa> now you just have the problem of a constructor belonging to type Foo that yields a value of type Baz a
17:23:28 <ihope_> And isn't it being of type Baz a equivalent to it being of type Qux -> Foo a, which works?
17:23:47 <Philippa> ah, the two lines to be taken together, my bad. Maybe, if you're lucky
17:23:58 <Philippa> try it, don't be too surprised if it falls over
17:24:29 <Philippa> still wouldn't be a /useful/ GADT though. The useful ones instantiate the type variables to something more constrained
17:25:31 <ihope_> data SKI a where S :: SKI ((a -> b -> c) -> (a -> b) -> a -> c)?
17:27:15 <Philippa> now that's useful - doable with existentials alone, but GADTs generalise 'em
17:27:38 <ihope_> What's an existential?
17:29:16 <Philippa> existentially-quantified (sort of) datatypes. Common extention - basically the constructors get to use types containing variables not on the LHS of the =
17:38:43 <Beelsebo1> anyone here using OS X?
17:38:48 <lscd> yep
17:39:17 <Beelsebo1> lscd: try grabbing this will you (warning, this may run a harmless shell script on your computer) http://www.cs.kent.ac.uk/people/rpg/tatd2/test.zip
17:40:39 <lscd> k, just a second while i  grab my osx machine [i took a look at that on this machine, which runs linux, first]
17:40:51 <Beelsebo1> ah, okay
17:41:07 <ihope_> @type Control.Arrow.ReturnA
17:41:08 <lambdabot> Not in scope: data constructor `Control.Arrow.ReturnA'
17:41:13 <ihope_> @type Control.Arrow.returnA
17:41:14 <lscd> any particular way you want me to grab it? i generally use wget
17:41:14 <lambdabot> forall b (a :: * -> * -> *).
17:41:14 <lambdabot>          (Control.Arrow.Arrow a) =>
17:41:14 <lambdabot>          a b b
17:41:25 <Beelsebo1> lscd: just visit the URL in safari
17:41:38 <lscd> ah, ok; i next to never use safari :)
17:41:51 <Beelsebo1> hehe, probably sensible when you see what this does ;)
17:42:28 <lscd> fuck :p
17:42:31 <Beelsebo1> indeed
17:42:31 <lscd> that really is nasty
17:42:31 <lscd> hehe
17:42:42 <Philippa> what'd it do, and as which user?
17:42:59 <lscd> Philippa: it ran the shell script (which has a .jpeg extension) which was in the tarball
17:43:03 <Beelsebo1> Philippa: it ran a shell script `echo "PWNED"` as the current user
17:43:09 <lscd> the shell script is quite harmless; it just echos 'pwned', but....
17:43:22 <Beelsebo1> the zip archive preserves the meta data, which sets the jpg to be opened with terminal
17:43:34 <Beelsebo1> the malformed shebang line stops safari picking it up as an executable
17:43:48 * Philippa nods
17:45:15 <Philippa> check your PMs, btw?
17:45:16 <lscd> at least firefox on macos isn't that trusting
17:45:28 <Beelsebo1> Philippa: *nods* check your PMs btw
17:45:30 <Beelsebo1> :P
17:45:34 <Beelsebo1> lscd: indeed
17:45:35 <Philippa> there ain't any
17:45:39 <Beelsebo1> :o
17:45:40 <Philippa> you might want to identify
17:45:45 <Beelsebo1> oddness...
18:19:12 <palomer_> what's the syntax for guards exactly?
18:23:56 <palomer_>                        True | ((STyvar alpha) == beta) = return Nothing;                            | otherwise = return $ Just "occurs check failed" 
18:24:04 <palomer_> one would expect this to be syntactically correct, no?
18:25:46 <palomer_> isn't it possible to use guards with case?
18:26:32 <dons> that ; looks a bit funny.
18:26:41 <mauke> palomer_: isn't it -> instead of =?
18:26:54 <dons> ah, in a 'case'. certainly.
18:27:20 <dons> f = case True of
18:27:21 <dons>         x | x == False -> 1
18:27:21 <dons>           | otherwise  -> 2
18:28:31 <palomer_> ahh, so it's ->
18:28:52 <palomer_> why don't we simply use = all the time or -> all the time?
18:29:13 <mauke> I only know because I've just written http://rafb.net/paste/results/z2cofk90.html :-)
18:34:45 <palomer_> omg that's evil
18:34:49 <Cale> palomer_: the = which applies is already there
18:35:22 <palomer_> I think we should do away with the -> after patterns
18:35:25 <palomer_> and replace it with a =
18:35:33 <Cale> in case?
18:35:42 <Cale> I think it wouldn't read as nicely
18:35:59 <Cale> it would look more like you're defining what the pattern is equal to
18:36:08 <Cale> which isn't what you're doing
18:36:42 <palomer_> oh, is there ever any trouble with adding to the semantic mapping of =?
18:37:10 <palomer_> anyways, I'm a big fan of reusing keywords (like where) when it's unambiguous
18:40:56 <cpatrick> wow, you can use guards inside a case?
18:42:26 <palomer_> yeah, I'm shocked too
18:42:30 * palomer_ is going to start using guards all the time
18:43:25 <Cale> in fact, you can even do things like
18:43:30 <Cale> case () of
18:43:39 <Cale>   _ | cond1 ->
18:43:52 <Cale>     | cond2 -> ... 
18:44:02 <cpatrick> C-style case :-)
18:44:09 <cpatrick> only with added ugliness
18:44:56 <Cale> is it?
18:45:06 <cpatrick> thinking about it, not really
18:45:08 <Cale> those are arbitrary conditions
18:45:26 <Cale> hehe, and there's no fall-through :)
18:45:32 <cpatrick> C would be: case x of _ | x == foo1 ->; | x == foo2 ->; ....
18:45:38 <Cale> yeah
18:46:01 * cpatrick ponders Duff's Device in haskell
18:46:10 <Cale> hehe, I was just thinking about that too
18:52:56 <wolverian> hm, I have a graph Gr User [String], and giving it to graphviz' gives out dot files with edges that look like '0 -> 1 [label="["lines"]"]', which is rather broken. what's the easiest way to fix this?
18:57:09 <Cale> hmm, concat the lists of strings on the edges?
18:57:38 <wolverian> yeah, that works, but I have to change my algorithm to do that, which feels ugly
18:57:48 <wolverian> (or add a filter before giving it to graphviz', I guess..)
18:57:55 <Cale> the latter
18:58:11 <Cale> or you could, of course, try just applying show to them
18:58:31 <Cale> (at the end)
18:58:45 <wolverian> yeah. 
19:10:48 <wolverian> hm. I assume I should use gmap here? I'm confused about Context
19:12:54 <wolverian> oh, heh, I've been misreading gmap's type all this time
19:13:03 <wolverian> er, Context's
19:15:13 <wolverian> okay, I just don't get what Adj is
19:18:07 <wolverian> oh, duh. emap :)
19:19:19 * wolverian should learn to read the WHOLE doc before coding
19:24:46 <Korollary> In a do block, I need to sort a list of files by their modification times. The comparison function would be of type String -> String -> IO Ordering. How can I use sortBy to sort the list?
19:26:48 <sjanssen> Korollary: do you know the function to get a files modification time?
19:27:12 <Korollary> sjanssen: getModificationTime :: FilePath -> IO ClockTime from System.Directory
19:28:57 <sjanssen> Korollary: the idea is to make a new list of type [(ClockTime, FilePath)], sort that, and then use "map snd" to strip out the mod times
19:29:56 <sjanssen> Korollary: that works because the default ordering for pairs is to compare the first thing, and if they're equal, compare the second thing
19:29:56 <Korollary> sjanssen: I used to do that. I don't find it elegant anymore :)
19:30:57 <sjanssen> Korollary: it's the only way (without unsafePerformIO)
19:31:20 <Korollary> sjanssen: sadly, it seems so
19:35:25 <sjanssen> Korollary: I don't think it is all that inelegant, it only takes two lines of fairly straightforward code
19:36:11 <Korollary> sjanssen: It's not long, but the list of pairs is artificial.
19:42:49 <dons> What's the swedish #haskell channel's name? #haskell.se? Is it active?
19:42:59 <Korollary> I think that's the name.
19:47:36 <Cale> sjanssen: sortBy (comparing snd) xs  where comparing p x y = compare (p x) (p y)
19:48:31 <Cale> er
19:48:35 <Cale> Korollary rather
19:48:53 <dons> shapr, Pseudonym, anyone else, when was #haskell founded, and was it shapr's idea?
19:49:27 <Cale> I don't think that the list of pairs is artificial. This is exactly what pairs are for.
20:22:45 <ncalexan> When profiling with GHC, I get columns labeled "no." and "entries.".
20:23:17 <ncalexan> What is the number column?  And what does it mean if entries is 0, but a lot of time is spent in that call?
21:32:17 <lispy> ncalexan: entries should be pretty obivous, that's how many times that cost center was entered...as for the second question and meaning of "no.", i'm clueless
21:34:36 <palomer> ok, guys, seriously, what's the deal with the if indenting in a do block
21:39:37 * palomer loves trace
21:41:29 <Cale> palomer: hm? indenting?
21:41:43 <Cale> you always indent the 'then' and 'else' the same
21:43:01 <palomer> the else is flush wit hthe then?
21:44:53 <palomer> I can't believe that ST s a is an instance of show
21:46:34 <Cale> yeah, it just prints <<ST action>>
21:46:46 <palomer> that seems pretty silly:o!
21:46:59 <palomer> anyways, emacs always wants to flush the else with the if in a do block
21:47:05 <palomer> if ... then
21:47:06 <palomer>         a
21:47:08 <palomer> else
21:47:09 <palomer>               b
21:47:15 <palomer> which is totally wrong
21:47:21 <Cale> yeah, that's wrong
21:47:29 <sieni_> emacs should be stabbed in the face
21:47:32 <Cale> turn off smart indenting, I found it to be a pain
21:47:42 <Cale> simple indent mode was good though
21:47:51 <palomer> Cale: so you indent everything manually?
21:47:53 <palomer> that must be nuts!
21:48:00 <Cale> nah
21:48:07 <Cale> it's fine
21:48:14 <palomer> so you press tab a lot, right?
21:48:31 <palomer> man, we need to get yi up to speed so we can get some decent parsing!
21:48:32 <Cale> not that much, only when starting a new level
21:48:42 <Cale> It lines up the next line with the previous
21:49:41 <palomer> oh, that's fine
21:49:46 <palomer> how do I turn off smart indenting?
21:50:18 <Cale> well, when you set up Haskell-mode it's one of the things which you add to your dotfile
21:50:42 <Cale> (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
21:50:42 <Cale>   is what I have in my .emacs
21:51:01 <Cale> there's also 'turn-on-haskell-smart-indent which seems bad
21:51:50 <palomer> I just apt-got it
21:52:04 <palomer> well, I add-hooked that line
21:52:07 * palomer prays that it will work
21:52:58 <palomer> wait, if I turn off smart indent
21:53:02 <palomer> then I have to manually indent my ifs
21:53:09 <palomer> so it doesn't solve anything!
21:53:24 <Cale> well, at least it lets you manually indent them :)
21:53:46 <Cale> I found that smart indent would usually cycle between 3 or 4 incorrect indentations
21:53:50 <palomer> btw, if I want to trace in ST, but I have no expression to attach to the trace, what do i do? trace "blah" $ return () ?
21:54:00 <Cale> and I'd have to hold down the spacebar to get it to where I wanted it
21:54:12 <palomer> you had to hold down the spacebar? that's nuts!
21:54:33 <Cale> that's why I turned it off
21:54:58 <palomer> hrm, 
21:55:00 <Cale> not having a real tab key is really really annoying
21:55:10 * palomer wishes he could runST inside ST :p
21:55:19 <Cale> you can
21:55:27 <Cale> sort of
21:55:33 <palomer> how so?
21:55:42 <Cale> but you can't carry any state into the inner invocation
21:55:52 <Cale> actually
21:55:54 <Cale> join does that
21:55:59 <Cale> @type join
21:56:00 <lambdabot> Not in scope: `join'
21:56:04 <palomer> @hoogle join
21:56:04 <Cale> @type Control.Monad.join
21:56:04 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
21:56:04 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
21:56:04 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
21:56:05 <lambdabot> forall a (m :: * -> *).
21:56:05 <lambdabot>         (Monad m) =>
21:56:06 <lambdabot>         m (m a) -> m a
21:56:23 <Cale> really ought to be in the prelude :)
21:56:41 <palomer> I have an ST s Type, are you saying I can get a Type out of that?
21:56:57 <Cale> well, in one of two ways :)
21:57:11 <palomer> actually, I'm dumb
21:57:13 <Cale> er, actually you just run that to get the type
21:57:32 <Cale> t <- mySTType
21:58:01 <palomer> yeah
21:58:10 <Cale> If you had something like  ST s (ST s a) and you wanted an ST s a, then you'd use join.
22:00:29 <mwc> I have a semantic question. Suppose I have a function lattice = array bnds [((x,y), generator lattice (x,y) | x <- [..], y <- [..]] which uses the laziness of array values to calculate certain values of the array based on neighbours and boundaries (I know it terminates). I'm trying to figure out how to make generator a parameter, I don't know what to pass as lattice since it's a function now
22:00:59 <mwc> lattice gen = array bnds [(x,y), gen (lattice gen) (x,y) | ... ]
22:01:38 <mwc> would that lattice gen in the initializer list comprehension be the same as the lattice under construction? I'm not sure
22:02:39 <Cale> hm?
22:02:58 <mwc> suppose I have f x = g (f x)
22:03:05 <Cale> okay
22:03:13 <mwc> would the f x in the paramter of g be the same as the f x being calculated?
22:03:26 <Cale> well, it's recursive, yes
22:03:48 <palomer> @type \g -> let f x = g (f x) in f
22:03:49 <lambdabot> forall t t1. (t -> t) -> t1 -> t
22:04:04 <mwc> yeah, so now suppose I have a function that creates an array: lattice gen = array bnds [(x,y), gen (lattice gen) (x,y) | ... ]
22:04:11 <mwc> so then lattice gen is an array that's under construction
22:04:21 <Cale> oh
22:04:32 <Cale> but you want to know if it will be memoised?
22:04:42 <mwc> I guess so
22:04:59 <mwc> I need to pass the lattice into the generator
22:05:11 <palomer> this is more of a performance question than a semantic question, imo
22:05:11 <mwc> so that it can look points up 
22:05:43 <mwc> No, it's not really, this is a loop in an interpretive context
22:05:50 <mwc> I'm just making the loop into a recursion
22:06:28 <mwc> so then I need to know how I can take the first form, generator not being an parameter, make it a parameter, and still be able to refer to it
22:06:31 <Cale> let lattice = array bnds [((x,y), gen (x,y)) | ...]; gen = ... lattice ... in lattice ?
22:07:18 <mwc> hmmm, I think that will do it, let me get back to you
22:10:01 * palomer thinks trace should have type forall a. String -> a
22:10:05 <palomer> who's with me?
22:13:15 <Cale> that's the type of error
22:13:27 <Cale> @type Debug.Trace.trace
22:13:28 <lambdabot> forall a. String -> a -> a
22:14:46 <palomer> but it would be so much more pratical if trace and error had the same type
22:14:47 <TheHunter> how would I do |cont <- readFile "largeFile"| in ghci?
22:15:14 <TheHunter> ...without ghci spewing out the whole contents of the file.
22:15:48 <Cale> uh, it doesn't spew out anything
22:16:24 <TheHunter> mine does :(
22:17:10 <Cale> which version?
22:17:43 <TheHunter> ghci-6.5.20060205
22:17:57 <Cale> oh
22:17:58 <TheHunter> that's a misfeature, if you ask me.
22:18:01 <Cale> I'm using 6.4.1
22:18:16 * TheHunter uses the Identity monad...
22:18:27 <palomer> who'd want to use the identity monad?
22:18:29 <palomer> seriously.
22:19:00 <Cale> I use it to build other monads
22:19:49 <TheHunter> Identity doesn't implement show, so |Identity cont <- Identity `fmap` readFile "largeFile"| is exactly what I want.
22:20:22 <TheHunter> I figured that'd be easier than finding out how to turn off that nasty behavior.
22:22:16 <dons> hey TheHunter. how's things?
22:22:52 <TheHunter> hey dons. Alright.
22:23:49 <TheHunter> currently making a list of all the (initial/final) consonant clusters in English...
22:24:54 <TheHunter> And i've almost managed to catch up with the haskell' discussion today.
22:25:45 <dons> :)
22:27:07 <palomer> why not have trace x = runIO $ print x       ?
22:27:18 <palomer> or unsafePerformIO
22:28:23 <dons> um, trace :: String -> a -> a
22:28:23 <dons> trace string expr = unsafePerformIO $ do
22:28:23 <dons>     putTraceMsg string
22:28:23 <dons>     return expr
22:29:07 <palomer> trace_:: String -> a  could also be useful
22:29:35 <benc_> thats called "error", isn't it?
22:31:03 <lispy> trace_ looks like error, but trace is not meant to cause an exception
22:32:09 <lispy> i've heard that trace can change the evaluation order in your program and can hence make things change or fail to be reproducible when debugging
22:32:11 <palomer> I want to do things like do {trace "blah"; x <- readSTRef foo}
22:32:29 <TheHunter> omg, there is (are?) a ridiculous number of consonant clusters
22:32:46 <lispy> TheHunter: what does that mean?
22:33:10 <lispy> palomer: you're in the ST monad?
22:33:35 <lispy> palomer: could you use the writer monad and a transformer to get logging?  would that be close enough to tracing?
22:33:41 <TheHunter> lispy, sequences of consonants in words that aren't seperated by vowels.
22:34:05 <benc_> qwglhm?
22:34:19 <TheHunter> things like ngkbl...
22:34:33 <lispy> what word contains ngkbl?
22:34:59 <palomer> lispy: could be
22:35:24 <lispy> palomer: i think the nomeaware(sp?) monad page has an example like that
22:35:45 <TheHunter> INKBLOT, whatever that means...
22:36:11 * TheHunter realizes he shouldn't have used nub.
22:43:33 <lispy> oh, cool
22:45:32 <lispy> i've often thought it would be cool to have a dictionary that clusters words by rhyms
22:46:12 <TheHunter> sadly, ghci isn't the right tool for the job. not with only 512MB of ram anyway.
22:46:56 <lispy> time to upgrade :)
22:52:30 <TheHunter> this is getting on my nerves. It seemed like such a trivial task...
22:54:10 <ski> making a rhythming program ?
22:55:05 <TheHunter> no, trying to improve my pronunciation.
23:05:47 <TheHunter> scary... 1479 consonant clusters
23:14:26 <lispy> TheHunter: trying to figure out which letter combinations would be most important to practice?
23:16:00 <TheHunter> no, the opposite, trying to figure out which are so rare that I most likely haven't practised them enough.
23:16:22 <lispy> ah
23:19:02 <lispy> for the rhyming dictionary, i have no idea how one would do it without doing it manually
23:19:02 * TheHunter wonders how "Z Z" snuck into the list.
23:19:02 <lispy> if i had a rhym relation, rhym :: String -> String -> Bool then you could use something like todd coxeter algo for coset generation
23:19:02 <TheHunter> hmm, ZZZZ(2)  Z Z
23:19:02 <lispy> buzzzz? :)
23:19:33 * Cale snores... zzzz...
23:19:37 * lispy runs off to sleep
23:19:45 <lispy> night all
23:19:54 <TheHunter> night
23:20:09 * TheHunter goes to bed, too.
23:20:45 <TheHunter> 41353 combinations of final-initial cluster combinations is way too much.
23:21:55 <TheHunter> then again, cmudict's pronunciations are weird sometimes. word-final /w/, wtf?
23:25:30 <TheHunter> looking at the list, the information is nearly worthless without information about syllable breaks (which cmudict doesn't provide).
23:25:38 * TheHunter zzzzzz.
