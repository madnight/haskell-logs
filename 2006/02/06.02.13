00:04:02 <Speck> @type \f g x = (f x, g x)
00:04:03 <lambdabot> parse error on input `='
00:04:07 <Speck> err
00:04:11 <Speck> @type \f g x -> (f x, g x)
00:04:12 <lambdabot> forall a b t. (t -> a) -> (t -> b) -> t -> (a, b)
00:08:27 <ProfTeggy> Moin all
00:30:49 <ProfTeggy> kosmikus: what would be the recommend way to process a multi-module program by lhs2TeX if modules need to share %format directives?  Include a common *.fmt file in all module files?
00:31:05 <ProfTeggy> recommended, even
00:53:31 <tibbe> @quote
00:53:31 <lambdabot> gFunk says: [the main advantage of functional programs are that they're]
00:53:31 <lambdabot> incorrect the first 1000 times you try to compile it!
00:53:48 <tibbe> @quote
00:53:48 <lambdabot> Oleg says: The implementation of RSA on type level is left for future
00:53:48 <lambdabot> work
00:53:57 <tibbe> @quote
00:53:57 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math?
00:53:57 <lambdabot> Is there an undocumented -funleash-fortran parameter?
01:12:40 <gour> dcoutts_: ping
01:13:56 <boegel|home> gour: hehe :)
01:14:14 * boegel|home thinks gour is a magician for summoning dcoutts like that
01:14:30 <gour> boegel|home: why?
01:15:06 <dcoutts> @yarr!
01:15:06 <lambdabot> Ahoy mateys
01:15:20 <kosmikus> ProfTeggy: one resulting .pdf, or multiple?
01:15:26 <gour> boegel|home: ahh..now is see :-)
01:16:11 <gour> dcoutts: can ffipkg help with c2hs & gtk2hs?
01:16:16 <ProfTeggy> kosmikus, I'd prefer to have a single PDF file
01:16:30 <dcoutts> gour, what is ffipkg?
01:16:43 <gour> dcoutts: http://www.haskell.org/haskellwiki/FFI_Imports_Packaging_Utility
01:17:00 <kosmikus> ProfTeggy: You can either (A) just %include the other modules from the main file, or you (B) \input them.
01:17:32 <dcoutts> gour, probably not
01:17:43 <kosmikus> ProfTeggy: (A) should work without any problems. For (B), you have to %include lhs2TeX.sty only in the master file, not in the others, and to %include all the .fmt's you need everywhere
01:18:23 <gour> dcoutts: so cabal has to get some add-on to support builf of gtk2hs-like lins
01:18:34 <dcoutts> gour, cabal supports c2hs
01:19:12 <gour> dcouuts: but gtk2hs build cannot be cabalized (yet) ?
01:19:26 <ProfTeggy> kosmikus, ah... OK
01:19:41 <ProfTeggy> I'll go for (A) then, i think
01:19:46 <ProfTeggy> Thanks!
01:20:45 <kosmikus> ProfTeggy: yes, that's the simplest solution. it only fails if for some reasons you need to call lhs2TeX separately on the files, because you need really incompatible setting or something like that. The lhs2TeX manual is an example for the (B) approach, because the code examples are compiled using different lhs2TeX styles etc.
01:21:10 <gour> dcoutts: but gtk2hs build cannot be cabalized (yet) ?
01:21:40 <dcoutts> gour, it could be cabalixed if gtk2hs moves to main line c2hs rather than its own fork, cabal also needs better dependency tracking for proper support of c2hs
01:22:00 <dcoutts> gour, but it's not impossible
01:22:36 <ProfTeggy> kosmikus, I see.
01:23:15 * ProfTeggy hacks happily away ...
01:23:16 <gour> dcoutts: it would be nice to have gtk2hs under cabal...
01:23:39 <kosmikus> for all those who are looking for something to read: three new papers as http://www.iai.uni-bonn.de/~loeh/GFP.html
01:24:25 <gour> dcoutts: btw, the scribes dev has started to read yaht and likes hIDE concept thinking similarly (i.e. to make scribes full plugin-able)
01:25:40 <dcoutts> gour, yes it would be good, though there are higher priorities at the moment
01:26:39 <ProfTeggy> kosmikus, tw: http://www.iai.uni-bonn.de/~loeh/DFG-Proposal.pdf is a dead link
01:26:44 <ProfTeggy> s/tw/btw/
01:29:51 <kosmikus> ProfTeggy: thanks, fixed now, I hope
01:33:53 * ProfTeggy nods
01:53:21 <foxy> Hi, if I modify a module in the GHC source tree and then recompile will the whole kit-and-caboodle be recompiled or just the dependent modules?  I ask because my poor little machine has spent over ten hours compiling so far and is still not finished.  Obviously if it took ten-plus hours every time I want to check a modification I it might end up being prohibitive.
01:55:22 <Lemmih> It only recompiles what's needed.
01:55:43 <foxy> phew, thanks
01:55:48 <gour> true. very handy whan you work wiht ~400pages book
01:55:50 <Lemmih> Disabling optimizations and profiling would speed up the compilation a lot.
01:56:00 <gour> oops...wrong channel
01:56:32 <foxy> I've disabled optimizations and profiling but enabled debugging in stage 2
01:57:12 <Lemmih> And it still took more than 10 hours? Impressive.
01:57:48 <foxy> <- has a 7 year old machine!
02:00:20 <triplah> ouch :P
02:03:42 <wolverian> argh. now gtk2hs won't build with ghc.hide
02:04:06 <dcoutts> wolverian, use the gtk2hs.hide repo
02:04:43 <Lemmih> Building hIDE is such a pain );
02:05:06 <Lemmih> I have to fork base and Cabal, too.
02:06:25 <triplah> built no worries here
02:06:27 <triplah> gentoo tho
02:06:33 <wolverian> dcoutts, aaggh!!!!
02:06:34 <triplah> no skill involved :P
02:06:34 <dons> fork base?
02:06:42 <Lemmih> fork base!
02:06:53 <dcoutts> fork base?!
02:06:57 <dons> why?
02:07:23 <Lemmih> It contains lots of {-# OPTIONS -fno-bang-patterns #-}.
02:07:27 <dons> ah.
02:07:51 <dons> pity GHC HQ went on holidays this week.
02:08:14 <dcoutts> wolverian, I will eventually make the normal gtk2hs repo build with ghc-6.5 but it requires more conditional build stuff. The gtk2hs.hide repo just unconditionally requires ghc-6.5
02:11:55 <wolverian> dcoutts, I have ghc.hide
02:12:26 <dcoutts> wolverian, yeah, that's ghc-6.5, so you need the gtk2hs.hide repo which works with ghc-6.5
02:13:09 <wolverian> yeah. thanks, getting it now
02:14:59 <JohnMeacham> Are there any haskell implementations that support first class existentials?
02:15:19 <dcoutts> JohnMeacham, I think EHC might
02:15:45 <JohnMeacham> dcoutts: because I realize I can implement them in jhc, and they could be pretty cool.
02:16:08 <gour> wolverian: hIDE does not build here neither with ghc.hide nor ghc-head
02:16:09 <JohnMeacham> so you can have a function be like  Int -> exists a . (a, a -> b)
02:16:16 <gour> wolverian: there is problems with fps
02:16:21 <foxy> dcoutts: on http://www.haskell.org/haskellwiki/HIDE/Design it has Win32 support as unassigned, does that mean that you need people to do windows porting type stuff?
02:16:39 <wolverian> gour, oh. should I just give up now, before even getting to hide compilation? :)
02:16:40 <dcoutts> JohnMeacham, cool, [exists s. IOStream s => s]
02:16:49 <JohnMeacham> or, even better,  Char -> exists a . FooClass a => a
02:17:00 <dcoutts> foxy, yes win32 porters would be great
02:17:16 <Lemmih> I think it would be a bit premature.
02:18:08 <dcoutts> Lemmih, well it should mostly build right?
02:18:11 <JohnMeacham> dcoutts: indeed. well, its easy enough in contravariant position (it just expands into a forall, jhc does this now) the interesting thing is when it is in a covariant position, in which case it gets desugared into an unboxed tuple of is type (or dictionary in ghc) and its value.
02:18:29 <dcoutts> foxy, though it's not so easy to build gtk2hs on win32, I can tell you how to do it
02:18:30 <Lemmih> dcoutts: It doesn't even build on Linux!
02:18:35 <dcoutts> Lemmih, heh :-)
02:18:44 <JohnMeacham> I believe a translation to System F should be straightforward if ghc wanted to do the same thing... 
02:18:47 <gour> wolverian: i did so. try to build fps first
02:19:00 <foxy> dcoutts: yeah, if you remember about a year ago I was having problems with gtk2hs
02:19:04 <dcoutts> JohnMeacham, interesting
02:19:19 <dcoutts> foxy, is it still giving you problems?
02:19:44 <wolverian> gour, oh, I've already done that. albeit with ghc 6.4..
02:19:46 <foxy> dcoutts: haven't looked at it in ages, I gave up (can't remember what exactly)
02:20:07 <dcoutts> foxy, well we've had a few win32 releases since then
02:20:16 <JohnMeacham> foralls translate into new arguments to pass in the dictionary and the value, exists translate into a tuple of the dictionary you got  and the value. it is all quite symmetric. it would  be a neat feature for haskell'
02:20:26 <dcoutts> foxy, the 0.9.8 & 0.9.10 releases have .exe installers
02:20:27 <foxy> dcoutts: OK, I'll give it a go.
02:20:30 <ski> JohnMeacham : s/=>/*>/
02:20:48 <gour> wolverian: well, fps does not build with 6.5 and hIDE does not build with 6.4.1
02:20:53 <dcoutts> foxy, but for hIDE you'd need to build a dev version of gtk2hs from source
02:20:58 <wolverian> gour, I just built fps with ghc.hide
02:21:18 <dcoutts> JohnMeacham, yeah it would be useful.
02:21:19 <foxy> dcoutts, ah... OK
02:22:03 <ski> JohnMeacham : so you need other syntax for output constraints
02:22:33 <foxy> what do I need to do to build ghci after I've compiled GHC?
02:22:36 <ski> (JohnMeacham : btw, Mercury have this feature (plus type classes))
02:22:46 <Lemmih> foxy: GHCi == GHC.
02:23:45 <tromp_> > "GHCi" == "GHC"
02:23:46 <lambdabot> False
02:24:00 <JohnMeacham> ski: why would you need other syntax?
02:24:25 <ski> since 'Char -> exists a . FooClass a => a' would mean another thing
02:24:35 <gour> wolverian: good luck with the rest. i gave it up (atm)
02:24:36 <foxy> Lemmih: I see ghc-inplace, is there a separate executable for the interactive shell?
02:25:02 <JohnMeacham> ski: hrm? another thing than what. there is only one interpretation I can think of.
02:25:07 <ski> JohnMeacham : you want that constraint to be output, and not input, there
02:25:38 <Lemmih> foxy: ghc --interactive = ghci. But I don't think the inplace ghc is built for interactive use.
02:26:05 <ski> JohnMeacham : iirc, 3 (not 2) of the 4 possibilities are useful
02:26:08 <JohnMeacham> exactly, which is what the exists does. you don't need any other syntax for the same reason you don't need to say Int -> Int *-> Char and have a special syntax for the final argument in types.
02:26:09 * ski tries to remember
02:26:59 <ski> exists a. Foo a *> forall b. Bar a b => ...
02:27:04 <ski> hm
02:27:17 <JohnMeacham> it actually means the exact same thing in argument and final position. it would just be confusing to have a different syntax.
02:27:48 <ski> you want it to mean same yes
02:28:12 <ski> you're suggesting it to sometimes mean an implication and sometimes a product
02:28:19 <JohnMeacham> when it is in contravarient position, however you can pull apart the tuple and lift the value to the front. which makes it isomorphic to a universal 'forall'.
02:28:21 <foxy> dcoutts: The reason I gave up with gtk2hs 0.9.8 was because of a bug in GHC 6.4.1 and hsc2hs invocation (on Win98)
02:29:57 <ski> hm .. it might be ok if you only allow constraints constraing existentially quantified vars directly after the 'exists'
02:30:31 <pesco> Philippa_: I have some more patches for Flippi for you. :)
02:30:34 <JohnMeacham> ski: no, it is always the exact same thing. it is _always_ a product, the translation just happens to seperate out the product and pass its components seperatly when in contravarient position.
02:31:59 <dcoutts> foxy, oh, so you couldn't build from source on win98? I think the .exe ought to install & work on win9X however.
02:32:55 <JohnMeacham> (which makes it equivalant to a forall, which also pasess its types at the beginning of a function). in any case, when you get into things like higher order functions, you don't want to constantly keep track of what the variance is of your types by hand. :)
02:33:31 <JohnMeacham> for instance 'type Any = exists a . Typeable a => a' should be able to be used in both positions. 
02:37:26 <ski> (JohnMeacham : let me try to find the article i have in mind ..)
02:38:10 <JohnMeacham> ski: well, I would love to read any articles on the issue.
02:39:41 <kosmikus> the only reason I see to prefer *> for existentials is that in the context of existentials, as constraint isn't passed as an argument, but stored as a pair. => is clearly derived from the function arrow and the idea of implication.
02:40:11 <kosmikus> nothing to do with position though
02:42:09 <foxy> dcoutts: but I need to compile from source for hIDE, don't I?
02:43:25 <dcoutts> foxy, to build hIDE you need to build ghc and gtk2hs from source using the ghc.hide and gtk2hs.hide darcs repos.
02:44:10 <foxy> dcoutts, so ghc.hide is separate from the ghc HEAD?
02:44:28 <dcoutts> foxy, it's a snapshot of the ghc darcs repo
02:45:07 <foxy> dcoutts, can I not use yesterdays ghc darcs repo?
02:45:25 <dcoutts> foxy, probably not, it has things which break stuff aparantly
02:45:41 <JohnMeacham> is there a reasonable translation of  Int -> exists a . a  into a form just using foralls?
02:46:07 <dcoutts> foxy, it might be better to wait, it's not going to be easy to build on win32 yet
02:46:11 <JohnMeacham> (allowing rank-n)
02:46:28 <foxy> dcoutts, OK, I'll keep an ear to the ground then
02:48:18 <JohnMeacham> Ah, I see why you want *> now, but always, not just in covariant position. that is what was confusing me.
02:49:27 <JohnMeacham> BTW: is there a good introduction to this whole covariant/contravariant stuff as it applys to functional programming languages? The terms are overloaded, pretty much all search results return the OO terms which are sort of related, but not what I am looking for.
03:12:53 <ski> JohnMeacham : yes, no difference in interpretation re variance of position
03:13:37 <ski> JohnMeacham : covariant and contravariant functors in CT, i think
03:15:42 <ski> (JohnMeacham : it could have been the "[some] and existential types" thread in http://www.cs.mu.oz.au/research/mercury/index.html that i was thinking of .. if you check that, http://www.cs.mu.oz.au/research/mercury/information/doc-latest/mercury_ref/Existential-types.html in the manual could also be helpful)
03:44:26 <Si\Uni> does there exist any defaulting mechanism for implicit parameters; i.e. if a parameter is unbound when a function which requires one is called some default value can be assigned?
03:44:57 <pesco> Si\Uni: I think not.
03:47:04 <JohnMeacham> Si\Uni: implicit parameters are a bad idea anyway.
03:47:32 <JohnMeacham> I wish ghc would drop them.
03:51:30 <audreyt> JohnMeacham: what's wrong with sugar for commutative reader monad?
03:52:10 <JohnMeacham> audreyt: the sugar is not a very good sugar.
03:52:25 <audreyt> you mean the explicit declaration in type level?
03:52:31 <audreyt> I happen to agree :)
03:52:32 <JohnMeacham> audreyt: though, a better sugar for commutative monads in general would be very interesting.
03:52:43 <audreyt> yup
03:53:01 <audreyt> so it's a "not sweet nor generic enough" critique
03:53:06 <audreyt> thanks for the clarification :)
03:53:27 <audreyt> ok, I need to board on the plane to tel aviv now
03:53:30 <audreyt> bbl :)
03:55:53 <gour> dcoutts_: have you seen axel's response to my post?
03:55:59 <Lemmih> Board the plane, matie! Arr!
04:00:01 <ski> (JohnMeacham : isn't co vs. contra in OO basically same issue ?)
04:02:05 <Speck> I'm reading about comonadic attribute grammar evaluators, and Tarmo Uustalu gives a very good account, but I wonder if anyone here knows about an existing application of this research -- too soon?
04:07:23 <ski> Speck : possibly
04:07:33 <Speck> eh?
04:08:25 <Speck> possibly too soon, or you possibly know about an existing application ;-)
04:09:01 <JohnMeacham> ski: yeah, but a degenerate case, not very interesting without higher order functions.
04:09:28 <JohnMeacham> ski: and user defined data types, themselves possibly containing higer order functions.
04:09:58 <ski> or just datatypes containing functions (so tyargs aren't always covariant)
04:10:19 <JohnMeacham> ski: yup. mutually recursive datatypes at that.
04:10:30 <ski> hm ?
04:11:00 <JohnMeacham> data Foo a = Foo (a -> Foo a)
04:11:30 <JohnMeacham> actually newtype Foo a = Foo (a -> Foo a) is more interesting. try and desugar that newtype :)
04:12:41 <ski> hm, are you refering to recursive object types ?
04:14:32 <JohnMeacham> I have been thinking about it since my horribly flawed restricted types proposal. I determined it is valid for exactly those classes where each method is linear in the contravariant mentions of the class parameter. not sure if that is useful though, seeing as how those are exactly the same times you can solve it via extistetials rather than restricted types :) which gave me the existential bug which made me implement them fo
04:14:32 <JohnMeacham> r jhc...
04:14:44 <Speck> audreyt: is there a high-level overview of the perl 6 rules system?
04:15:54 <ski> JohnMeacham : 'it' being desugaring ?
04:17:17 <JohnMeacham> ski: 'it' being my flawed proposal. though, thinking about it. it is somewhat more complicated than just being linear in the contravariant mentions... hmm..
04:17:29 <JohnMeacham> will give it more thought.
04:17:52 <wolverian> hm, hs-plugins build errors with ghc.hide 
04:18:14 <ski> (JohnMeacham : is it available online ?)
04:19:04 * ski is not sure what the issue is wrt 'linear in contravariant parm'
04:19:56 <JohnMeacham> ski: me neither now that I think about it... 
04:20:34 <ski> (i.e. i don't understand what the problem you were trying to solve/whatever was)
04:20:45 <wolverian> could be because of leftover files from ghc6.4 build, I guess
04:21:21 <Lemmih> wolverian: What error?
04:21:51 <wolverian> src/AltData/Typeable.hs:452:0:  parse error (possibly incorrect indentation)
04:22:04 <Lemmih> (you need a special hs-plugins for hIDE)
04:22:13 * wolverian should have guessed
04:22:18 <Lemmih> (:
04:22:21 <wolverian> I'm going by the hIDE README
04:22:26 <wolverian> which didn't say that
04:22:40 <wolverian> (I'm using ~lemmih/hs-plugins)
04:22:43 <wolverian> (is that incorrect?)
04:23:58 <Lemmih> Are you sure you are? There shouldn't be any traces of AltData.
04:24:16 <wolverian> no, I'm not sure. I'll make sure, now
04:25:14 <wolverian> ah, better now
04:25:24 <wolverian> Lemmih, thanks, obviously I've forgotten already what I was doing last night :)
04:27:57 <wolverian> hmm
04:28:27 <wolverian> boot/Static.hs:25:17: Could not find module `Yi'
04:28:44 <wolverian> this yi should be the hide yi.. 
04:30:31 <Lemmih> Try removing the executables from the yi.cabal file.
04:31:41 <wolverian> only the Executable lines or the blocks they're in? sorry, I'm not familiar with the cabal config files
04:32:11 <Lemmih> The blocks.
04:32:33 <wolverian> worked
04:32:40 <wolverian> I assume that means I can't run yi standalone? 
04:32:47 <wolverian> (which makes sense with hide)
04:33:51 <wolverian> hm, now the hIDE build failed :)
04:33:58 <Lemmih> *sigh*
04:34:17 <wolverian> src/Hide/CommonSense/Haskell.hs:55:27: Couldn't match expected type `Maybe String' against inferred type `[a]'
04:34:25 <Lemmih> Oh right.
04:35:31 <wolverian> hm?
04:35:51 <araujo> Hello!
04:35:53 <araujo> @yaw!
04:35:54 <lambdabot> Somewhere in DOWNTOWN BURBANK a prostitute is OVERCOOKING a LAMB
04:35:54 <lambdabot> CHOP!!
04:36:00 <araujo> haha
04:36:20 * vincenz peers at lambdabot 
04:36:43 <Lemmih> wolverian: Pull and try again.
04:36:47 <wolverian> Lemmih, ah. thanks :)
04:37:35 <wolverian> worked. Lemmih++ 
04:37:57 <wolverian> yay, hIDE!!!
04:38:08 * vincenz mutters
05:05:11 <ski> guten tag, shapr
05:05:21 <shapr> heippa hei ski
05:05:33 <shapr> wie geht es?
05:06:53 <ski> gut
05:08:54 <tibbe> @quote
05:08:55 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from
05:08:55 <lambdabot> England just to kill me if I did that
05:09:04 <shapr> @quote
05:09:04 <lambdabot> mwc says: I actually got away with running Haskell through a TeX pretty
05:09:04 <lambdabot> printer and handing it in as pseudocode
05:09:09 * shapr grins
05:09:21 <shapr> bringert: hej! how's code?
05:09:45 <bringert> hej shapr
05:10:05 <bringert> finding bugs in a voicexml interpreter
05:10:10 <bringert> you?
05:10:46 <shapr> Living la Vida Webmonkey.
05:11:20 <shapr> Is your vxml interpreter written in Haskell?
05:11:42 <bringert> it's not mine unfortunately
05:11:48 <bringert> I don't even have the code
05:11:59 <shapr> Black box testing is no fun.
05:12:13 <shapr> Using QuickCheck?
05:12:29 <bringert> no, my purpose isn't to find bugs
05:12:33 <shapr> ah :-)
05:12:37 <bringert> it's to use the bloody thing
05:12:54 <bringert> the bugs show up without me looking for them
05:13:04 <shapr> That's no fun.
05:13:15 <shapr> Sounds much like the WebMonkey life though :-)
05:13:54 <bringert> I should get involved in JVoiceXML, http://jvoicexml.sourceforge.net/
05:14:07 <bringert> it seems to be far from ready
05:14:14 <bringert> but it is free software
05:16:10 <vincenz> rats do backward propagation
05:16:22 <vincenz> http://science.slashdot.org/article.pl?sid=06/02/13/0614258&from=rss
05:17:26 <Si\Uni> how come typeOf "hello" in some places is "[Char]" and in other places "[] Char"?
05:17:36 <vincenz> [] Char == [Char]
05:17:46 <vincenz> [Char] is actually special notation for [] Char
05:18:02 <Si\Uni> yes, but why should typeOf give different representations?
05:21:30 <Si\Uni> Or, to put it another way, is there any reliable way of creating an efficient map with TypeRep as key, since clearly it won't work with hashString.Show?
05:22:16 <chrisbrown> does anyone happen to know what strictness annotations are in data types? or where I can learn about strictness annotations?
05:22:54 <bringert> chrisbrown: !
05:23:38 * chrisbrown bringert: perhaps this makes more sense... i have a data type data Kind = K !(K Kind) | Kvar KVar deriving (Eq,Show,Read)
05:23:54 <chrisbrown> i think its strictness but i don't really understand what it is doing
05:24:11 <beelsebob_> chrisbrown: ! - it forces data to be evaluated so (Jam  x !y) forces y to be fully evaluated
05:24:41 <chrisbrown> ok
05:24:56 <chrisbrown> what about this: newtype IDB i = Idb (M.Map i [Instance i])
05:25:06 <chrisbrown> that doesn't have strictness?
05:25:25 <bringert> chrisbrown: newtypes are always strict
05:25:37 <taw> hello
05:25:51 <bringert> or, rather, the data constructor for a newtype is strict in its argument
05:25:59 <bringert> hi taw
05:26:06 <chrisbrown> ok cheers
05:26:11 * taw trying to compile some haskell program, but the makefile wants to run runhaskell
05:26:25 <taw> runhaskell Setup.hs configure --ghc 
05:26:27 <taw> etc
05:26:37 * chrisbrown patches drift to cope with strictness annotations
05:26:37 <taw> i have ghc here, but not this runhaskell thing
05:26:43 <taw> any idea what is it ?
05:27:02 <edwinb> I got runhaskell with ghc, as far as I know.
05:27:15 <Heffalump> do you have runghc ?
05:27:21 <Heffalump> if so, alias or symlink runhaskell to it
05:27:35 <chrisbrown> i have runhaskell - it came with ghc
05:27:52 <edwinb> Did it not appear until 6.4 though?
05:28:35 <Heffalump> possibly not
05:28:52 <edwinb> It isn't on an install I have on another machine with 6.2.2, now I've checked.
05:29:04 <taw> i don't see anything with ruin in name in ghc5 package
05:29:33 <taw> (it's university machine, everything is pretty old here)
05:29:37 <Heffalump> ghc5 certainly won't have it
05:29:48 <Heffalump> you'll have to write one yourself or simulate the effect
05:30:02 <Heffalump> ghc -o setup Setup.hs ; ./setup configure --ghc
05:32:20 <Si\Uni> This is bizarre: What a TypeRep string shows changes if I do a reload in GHCi
05:32:31 <taw>     failed to load interface for `Distribution.Simple':
05:32:50 <taw> i perlscripted a runhaskell, but still no luck
05:33:03 <taw> should i just give up and look for a machine with a newer haskell ?
05:33:27 <Heffalump> yes, I think so.
05:34:55 <shapr> Si\Uni: amazing... what does it show?
05:38:48 <Si\Uni> It still looks the same to me
05:38:56 <Si\Uni> I don't get it
05:39:10 <Si\Uni> I've got a HashMap TypeRep [String]
05:39:30 <Si\Uni> first load lookups work fine, i.e. lookup (typeOf "hello") does indeed work
05:39:37 <Si\Uni> on reload it stops working
05:39:50 <Si\Uni> something really strange is happening
05:40:19 <musasabi> How do you hash typereps?
05:40:53 <shapr> I think that GHCi has its own type table. That caused problems in lambdabot early on because dynamically loaded types could never be checked against statically built types.
05:41:43 <dcoutts_> gour, heh, yeah, funny stuff
05:42:28 <Si\Uni> musasabi: That's what I'm asking
05:42:38 <Si\Uni> atm. I'm just doing hashSting . show
05:42:55 <Si\Uni> but since what show shows seems to change this is unreliable
05:45:29 <Si\Uni> and my database is too big to just use associative lists
05:47:26 <Si\Uni> plus HAIFA _will_ eventually be dynamically linking these things in, so its crucial that the TypeRep representation under no circumstances changes
05:47:44 <musasabi> Si\Uni: this is what I am using: http://www.cs.helsinki.fi/u/ekarttun/SerTH/SerTH/Codec/Serialize/SerTH/SDyn.hs
05:49:34 <Si\Uni> musasabi: How does it work?
05:51:56 <tibbe> @quote
05:51:57 <lambdabot> Itkovian says: real programmers don't write docs, if it was hard to write,
05:51:57 <lambdabot> it should be hard to understand
05:52:10 <tibbe> ah, a classic
05:52:15 <musasabi> Si\Uni: It seems to use show, but I think you have to blame GHCI
05:56:32 <JohnMeacham> musasabi: I wish typereps were in Ord.
05:57:02 <Si\Uni> hmmm, I suppose I could use '', the problem is I'm already using TH to generate the modules and I don't think '' works on in module names
05:57:20 <musasabi> JohnMeacham: that would solve many issues.
05:59:03 <JohnMeacham> musasabi: Yeah, the Info.Info tables in jhc are so darn useful, but slow.
06:03:53 <musasabi> JohnMeacham: well one could define an Ord instance using template haskell...
06:04:30 <Si\Uni> musasabi: How?
06:04:35 <musasabi> It is quite simple but dirty.
06:04:46 <musasabi> Si\Uni: just use an accessor and use compare to the keys.
06:06:34 <musasabi> I can paste the code in 10min
06:09:40 <Si\Uni> the problem you're gonna have though is that the TypeRep changes
06:10:05 <Si\Uni> so when you do the equality check the TypeReps are still going to be different
06:11:00 <Si\Uni> it may not matter if hs-plugin has only one type table, but I don't know
06:13:43 <ihope> Okay here.
06:13:57 <ihope> callCC :: ((lead -> m gold) -> m lead) -> m lead
06:14:53 <ihope> callCC alchemist = Cont $ \idunno -> runCont (alchemist (\lead -> Cont $ \_ -> idunno lead)) idunno
06:15:13 <ihope> Can anybody tell me what "idunno" is?
06:16:30 * gour hopes dcoutts will protect him from axel's anger
06:16:33 <musasabi> hmm seems it even hides the Key, which makes things harder
06:19:37 <Si\Uni> I'm not sure it would help anyway, because the fundamental problem is is that the TypeRep itself changes, so even though the hash check succeeds, the equality check fails
06:19:49 <JohnMeacham> musasabi: yeah, if we had the key it would be trivial, as it should be.
06:21:20 <musasabi> JohnMeacham: I can get the Key out of the typerep, but as the Key type is not exported I cannot get through the newtype.
06:22:37 <xerox_> ihope: it's the function, which you pass the continuation to?
06:22:58 <ihope> I thought "alchemist" was that function.
06:24:37 <ihope> And that (\lead -> Cont $ \_ -> idunno lead) was the continuation.
06:26:18 <ihope> Let's see here...
06:26:55 <ihope> callCC :: ((a -> (b -> r) -> r) -> (b -> r) -> r) -> (b -> r) -> r
06:27:38 <ihope> callCC f = \k -> (f (\a _ -> k a)) k
06:27:39 * xerox_ pass himself as continuations and runs away
06:28:39 <ihope> Well, that type up there's not right.
06:28:49 <ihope> @type \f k -> (f (\a _ -> k a)) k
06:28:50 <lambdabot> forall t t1 t2 t3.
06:28:50 <lambdabot> ((t2 -> t -> t1) -> (t2 -> t1) -> t3) -> (t2 -> t1) -> t3
06:31:57 <JohnMeacham> musasabi: yeah, that is what I mean.
06:55:38 <vincenz> so no comments on ARM vs tc++s?
06:55:54 <Heffalump> on what?
06:56:05 <vincenz> their differentiating value w.r.t. each other
06:56:17 <Heffalump> tc++s?
06:56:20 * vincenz has the tc++s
06:56:28 <vincenz> the c+++ standard
06:57:00 * Heffalump is confused.
06:57:29 <vincenz> DOH
06:57:31 <vincenz> wrong channel
06:57:35 <jethr0> hey vincenz
06:57:35 <vincenz> no wonder people didn't start trolling
06:57:41 <vincenz> jethr0: hi
06:57:48 <vincenz> Heffalump: sorry
07:00:22 <vincenz> I had a nice realization this morning
07:00:34 <jethr0> vincenz: what was it?
07:01:16 <vincenz> well basically, you can't solve a problem (effectively) without the right notation in mathematics... you try stating physics laws for instance without differentials 
07:01:34 <vincenz> the same can be applied to programming, the right notation will lead to a more efficiient and succint solutioin
07:01:40 <vincenz> and haskell is a very nice notation :)
07:02:25 <jethr0> true, but sometimes it can be cumbersome. for example changing the nth element of a list is more of a hassle than in other languages
07:02:47 <jethr0> well, if other languages used lists :)
07:03:09 <vincenz> you mean
07:03:13 <vincenz> ddt.set(x,y)
07:03:31 <musasabi> Is it possible to use fundeps inside TH code?
07:03:46 <jethr0> i mean "arr[5] += 1" or sth similar
07:03:53 <vincenz> right
07:04:00 <vincenz> ddt.set(5,ddt.get(5)+1)
07:04:07 <musasabi> i.e. given "class Imp a b | a -> b" and a Type of a is there a way to get the corersponding b?
07:05:25 <shapr> vincenz: For a simpler example, try doing long division with roman numerals, and you'll see why arabic numerals won the popularity contest.
07:05:30 <jethr0> multi-parameters classes aren't in haskell98,right?
07:05:54 <vincenz> shapr: yip :)
07:06:08 <vincenz> jethr0: no
07:06:12 <shapr> vincenz: That realization fits into my overall thread of "programming is not for computers" and has led me to read "Dead Reckoning" by Doerfler and pursue a bunch of other interesting stuff.
07:06:24 <vincenz> shapr: oh?
07:06:30 <shapr> That realization also got me to start writing a scifi book =)
07:06:41 <vincenz> what's dead reckning?
07:07:31 <shapr> It's a book about mental calculation, but it follows the general idea that programming is about finding the most efficient representation for a problem before solving.
07:07:42 <vincenz> ah :)
07:07:47 <jethr0> musasabi: ghci -fth -fglasgow-exts
07:07:53 <jethr0> :m +Language.Haskell.TH
07:08:04 <jethr0> runQ [d|class Imp a b | a -> b|] >>= print . show
07:08:11 <shapr> vincenz: http://www.scannedinavian.com/2005-11-18.html
07:08:13 <jethr0> : "[ClassD [] Imp [a_0,b_1] [FunDep [a_0] [b_1]] []]"
07:11:17 <piggy_> Is haskell much slower under win32 than linux?
07:12:01 <jethr0> musasabi: did that help?
07:12:47 * vincenz kicks jethr0  to meta-science
07:13:08 <piggy_> I happen to read about the win32 shootout benchmark: http://dada.perl.it/shootout/craps.html
07:14:08 <jethr0> my guess would be that noone has submitted the new shootout entries to that page
07:15:49 <vincenz> what's the easiest way of doing mutable data?
07:16:08 <piggy_> well, if you look at the source, even simple 'hello world' is just ranked at 18th under GHC
07:16:44 <jethr0> vincenz: IORef?
07:16:50 <vincenz> hmm
07:17:12 <jethr0> depends on your definition of "easiest", i guess
07:17:16 <vincenz> IO is a rather 'strict' monad
07:17:40 <vincenz> basically I'm doing control-flow analysis on my ast
07:17:46 <jethr0> true
07:17:53 <vincenz> which means that I'll have to update the "next-pointer" of each exp or stm once I get there
07:18:20 <jethr0> ah, i thought you meant IO mutability. won't a writer monad do?
07:18:35 <vincenz> well no
07:18:40 <vincenz> cause I'm changing what I'm iterating over
07:18:43 <vincenz> anti-causally
07:19:29 <vincenz> so I have to keep a references to the previous exp where I'll have to update the "next" one
07:20:24 <ihope> What's a good data constructor for a type called True?
07:20:34 <vincenz> o.O
07:20:46 <vincenz> what's a type called True look like
07:20:52 <vincenz> True = Always?
07:20:55 <ihope> data True = Duh
07:21:00 <ihope> Something like that.
07:21:04 <vincenz> yeah but what do you mean by True
07:21:13 <vincenz> unless you explain what you mean by it, I doubt people will come up with a good nam
07:21:17 <vincenz> data True = Always?
07:21:20 <resiak> True = IsThePopeAPope
07:21:28 <vincenz> data True = False
07:21:34 <ihope> Eh, lemme think...
07:21:55 <ihope> True is a type such that it's trivial to prove that there's a value of that type.
07:22:04 <ihope> Hence the data constructor name "Duh".
07:22:04 <vincenz> o.O
07:22:22 <vincenz> data True = Always
07:22:31 <ihope> Okay, it's Always.
07:22:34 <vincenz> data True = :()
07:22:41 <vincenz> or just :)
07:22:58 <ihope> Is that legal?
07:23:03 <vincenz> doubt it
07:23:13 <vincenz> but
07:23:19 <marcellus> Is anyone familiar with Functional Metapost? I am having troubles generating stair-like figure.
07:23:21 <vincenz> data True = (:-) should work
07:23:46 <Igloo> type True = ()
07:24:08 <ihope> Oh, right. (:-) would have to take two parameter.s
07:24:23 <Igloo> No it wouldn't
07:24:27 <ihope> No?
07:24:44 <Igloo> You can just use the infix form if you do apply it to two parameters
07:24:53 <vincenz> this wors
07:24:56 <vincenz> data True = (:-)
07:24:56 <vincenz> f (:-) = 1
07:24:56 <vincenz> main = print $ f (:-)
07:25:20 <vincenz> (:-) makes it noninfix and it takes no params
07:25:30 <ihope> Well, Djinn doesn't like data True = (:-)
07:25:53 <vincenz> not my fault it's not a happy creature
07:26:06 <vincenz> I bet it will take data True = (:-()
07:26:07 <ihope> Hmm, this is weird.
07:26:15 <vincenz> > reverse ":)"
07:26:16 <lambdabot> "):"
07:26:29 <ihope> I have the declaration "data False".
07:26:38 <ihope> And "data True = Always"
07:26:49 <ihope> I type "test ? False -> True"
07:26:56 <ihope> I get test = void
07:27:04 <vincenz> > void
07:27:05 <lambdabot>  Not in scope: `void'
07:27:16 <ihope> void :: Void -> a
07:27:23 <vincenz> which is correct
07:27:28 <vincenz> False = Void
07:27:32 <vincenz> bottom only
07:27:34 <ihope> But...
07:27:38 <vincenz> > Void
07:27:39 <lambdabot>  Not in scope: data constructor `Void'
07:27:43 <vincenz> > undefined :: Void
07:27:43 <lambdabot>  Not in scope: type constructor or class `Void'
07:27:48 <vincenz> @hoogle Void
07:27:48 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
07:27:51 <vincenz> oh
07:27:51 <vincenz> hmm
07:27:57 * vincenz coughs
07:28:12 <xerox_> @type let bot = bot in bot
07:28:13 <lambdabot> forall t. t
07:28:20 <ihope> Hmm. Are types within Djinn defined entirely by their constructors, or something?
07:28:41 <vincenz> ihope: all types are like that
07:28:46 <vincenz> or you'd have coonflicting constructors
07:29:04 <ihope> ...I mean, um...
07:29:22 <ihope> I guess my question is "should Void = False"?
07:29:44 <vincenz> ihope: well it's ratehr hard
07:29:53 <vincenz> ihope: both types have -no- constructors
07:29:56 <vincenz> they're both purely bot
07:30:03 <vincenz> so... I guess this is a gray area
07:40:08 <ihope> Okay. I defined types TRUE and FALSE and constructors OR, XOR, AND, NOT, and NXOR.
07:41:07 <ihope> Now cancel :: NOT (NOT a) -> a
07:41:27 <Igloo> What are you trying to do, OOI?
07:41:53 <ihope> What's OOI?
07:41:59 <vincenz> ihope: use classes
07:42:01 <Igloo> Out Of Intertest
07:42:06 <Igloo> Interest too
07:42:06 <ihope> Oh.
07:42:29 <vincenz> class Nottable a where notT :: a ->b
07:42:35 <vincenz> class Nottable a b | a -> b where notT :: a ->b
07:42:36 <ihope> I'm defining logic gates and stuff that use Djinn as a theorem prover.
07:42:47 <vincenz> Nottable True False
07:42:49 <Igloo> Ah
07:42:50 <vincenz> Nottable False True
07:43:25 <ihope> Um... there's no notT for Nottable True False, is there?
07:43:31 <ihope> notT :: True -> False
07:43:34 <vincenz> yes
07:43:38 <vincenz> notT:: False -> True
07:43:59 <ihope> Um...
07:44:01 <vincenz> what
07:44:06 <vincenz> you want to use types
07:44:07 <vincenz> overload the not method
07:44:14 <vincenz> so that for not True it returns a false type
07:44:19 <vincenz> and for not False it returns a True type
07:44:30 <vincenz> then do the same for the XOR OR AND 
07:44:35 <vincenz> using three-parameter typeclasses
07:44:43 <vincenz> well
07:44:47 <ihope> Um...
07:44:52 <vincenz> class BINARYLOGIC a b c where 
07:44:57 <vincenz>   and :: a -> b -> c
07:45:00 <ihope> I don't want anything with type True -> False.
07:45:11 <vincenz> ihope: NOT (True ) = False
07:45:12 <vincenz> no?
07:45:24 <ihope> NOT is a type constructor.
07:45:28 <vincenz> oh!
07:45:48 <vincenz> I don't see how it'll work the
07:45:54 <vincenz> I'd go for overloaded classes
07:45:55 <ihope> type NOT TRUE = TRUE -> FALSE -- the same as FALSE
07:46:22 <ihope> type NOT FALSE = FALSE -> FALSE -- can be converted into TRUE and back
07:46:28 <vincenz> ????
07:46:40 <vincenz> tat makes no sense
07:46:44 <vincenz> you're defining functions?
07:46:50 <ihope> No. Type constructors.
07:46:51 <vincenz> I'd go for typeclasses
07:46:59 <vincenz> well yes ... functions on types
07:47:07 <ihope> Yes.
07:47:07 <vincenz> TRUE -> TRUe
07:47:17 <vincenz> type NOT TRUE = TRUE -> FALSE
07:47:20 <vincenz> NOT TRUE is a function
07:47:39 <ihope> Well, anything with type NOT TRUE is a function.
07:47:55 <vincenz> either way the only way I see this is working is by using multi-param typeclasses
07:48:16 <ihope> Well, it seems to be working fine as I'm doing it.
07:48:23 <vincenz> oki then
07:48:38 <vincenz> so how do you do
07:48:42 <vincenz> NOT (NOT TRUE)
07:48:45 <vincenz> or
07:48:50 <vincenz> NOT (NOT (NOT TRUE))
07:49:01 <ihope> I defined the symbol cancel :: NOT (NOT a) -> a
07:49:11 <vincenz> hmm
07:49:32 <vincenz> oh wlel
07:50:35 <ihope> The law of contrapositives now works both ways...
07:51:04 <vincenz> ST is strict, in contrast to State, correct?
07:51:48 <Igloo> ST comes in both lazy and strict flavours
07:52:21 <vincenz> it's jsut that when I used State and used fail, it woldn't always faili
07:52:34 <vincenz> therefore I had to use ErrorT (State Env) 
07:52:51 <vincenz> but now I need mutable cells so I need ST, so I was curious whether I'll still need the ErrorT (ST)
08:09:56 <vincenz> @hoogle Typeable
08:09:57 <lambdabot> Data.Typeable.Typeable :: Typeable a
08:09:57 <lambdabot> Data.Typeable.Typeable1 :: Typeable1 t
08:09:57 <lambdabot> Data.Typeable.Typeable2 :: Typeable2 t
08:10:08 <vincenz> @hoogle Typed
08:10:09 <lambdabot> Language.Haskell.TH.Lib.newtypeD :: CxtQ -> Name -> [Name] -> ConQ -> [
08:10:09 <lambdabot> Name] -> DecQ
08:10:09 <lambdabot> Language.Haskell.TH.Syntax.NewtypeD :: Cxt -> Name -> [Name] -> Con -> [
08:10:09 <lambdabot> Name] -> Dec
08:10:09 <lambdabot> Language.Haskell.TH.NewtypeD :: Cxt -> Name -> [Name] -> Con -> [Name] ->
08:10:10 <lambdabot> Dec
08:14:01 <vincenz> is it possible to define a record with some fields unnamed?
08:14:13 <Igloo> Sadly not
08:14:29 <Igloo> I should bring that up again for H', I guess
08:15:00 <vincenz> it would be useful
08:15:06 <vincenz> especially if some fiields are gotten through a class anyways
08:27:11 <ihope> Cool. I can break out of a CPS value if the return value doesn't exist.
08:28:31 <ihope> Of course, it's not like I can do this in normal Haskell.
08:29:13 <ihope> f a b = cancel (\c -> void (a (b (\
08:29:15 <ihope> Oops.
08:29:57 <ihope> f a b = cancel (\c -> void (a (b (\d -> void (c d))))) -- where a is a proof that the return value of b doesn't exist
08:33:58 <ihope> Hey, cool. And True True :: AND TRUE TRUE
08:35:35 <kosmikus> lhs2TeX users: I've uploaded a release candidate for lhs2tex-1.11 to http://www.iai.uni-bonn.de/~loeh/lhs2tex/index.html  --  feedback very welcome.
08:37:18 <vincenz> @hoogle Position
08:37:19 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors.position :: Light -> StateVar (
08:37:19 <lambdabot> Vertex4 GLfloat)
08:37:19 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans.Position :: Position
08:37:19 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans.Position :: GLint -> GLint ->
08:37:19 <lambdabot> Position
08:54:54 * vincenz hmms
08:55:23 * ihope hmm?s
08:57:58 <vincenz> trying to figure out how to add src-locs to my ast 
08:57:59 <palomer> hmm!
08:58:04 <ihope> So what's that logic symbol thing that looks like a ^ mean?
08:58:09 <ihope> AND or OR?
08:58:16 <vincenz> XOR
08:58:18 <integral> AND.  v is or, from the latin /vel/
08:58:25 <vincenz> | = OR
08:58:27 <vincenz> ^ = XOR
08:58:32 <ihope> Um...
08:58:42 <jethr0> vincenz: that's c notation. in math /\ is an and
08:58:43 <integral> in C at least vincenz is right :)
08:58:44 <ihope> I'm seeing ^, V and ->.
08:58:46 <vincenz> oh well
08:58:59 <vincenz> . /\ = AND   ^ = XOR
08:59:06 <vincenz> depending on logical or mathematical notation
08:59:13 <vincenz> in the second AND = . and OR = +
08:59:31 <vincenz>  /\ != ^
08:59:41 <basti_> >_<
08:59:45 <jethr0> isn't it "x" or "o", rather than "."
08:59:57 <jethr0> :)
09:00:21 <vincenz> depends
09:00:30 <vincenz> it's a . at o-height
09:00:30 <vincenz> ;)
09:00:55 <jethr0> hehe
09:06:39 * vincenz has some hakell issues
09:07:10 <vincenz> http://rafb.net/paste/results/08F21w57.html
09:07:34 <vincenz> ./Basics.hs:25:22:
09:07:34 <vincenz>     Couldn't match the rigid variable `m' against `Located'
09:07:34 <vincenz>       `m' is bound by the instance declaration at ./Basics.hs:24:0
09:07:34 <vincenz>       Expected type: m (Located b)
09:07:34 <vincenz>       Inferred type: Located b1
09:07:36 <vincenz>     In the expression: (transform a) >>= (L l)
09:07:39 <vincenz>     In the definition of `transform': transform (L l a) = (transform a) >>= (L l)
09:08:50 <vincenz> changed it to do notation
09:08:51 <jethr0> shouldn't that be "transform ((L 1) a)"?
09:09:15 <vincenz> ehm no
09:09:20 <JohnMeacham> ihope: it could also be a capital lambda, used for type abstraction.
09:09:25 <jethr0> ah, sry
09:09:40 <vincenz> no worries ;)
09:09:42 <jethr0> that code is a little more complex than i usually deal with (i.e. mine ;)
09:09:55 <jethr0> i'm not the typing kinda guy...
09:09:58 <vincenz> hehe
09:09:58 <vincenz> yeah
09:10:06 <vincenz> my code won't work without -fglasgow-exts :/
09:29:47 <wolverian> hm, I have a function parseLine :: String -> IRCLog -> IRCLog, and I want to apply it over IO [String]. does that make any sense? I can't figure out how to do it.
09:30:01 <integral> @type mapM_
09:30:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
09:30:56 <integral> wolverian: do { xs <- thing_with_that_IO_listy_type; mapM_ (return . parseLine) xs }
09:31:04 <integral> except that's for parseLine :: String -> IRCLog
09:31:08 <wolverian> hm.. I want to feed the return value back to parseLine though, or otherwise grow the IRCLog. 
09:31:23 <integral> wolverian: do { xs <- thing_with_that_IO_listy_type; return $ map parseLine xs } -- change map to foldl etc
09:31:41 <integral> well that's a fold.  (or a writer monad)
09:31:44 <wolverian> right. I thought that's what I'm doing :) let's see
09:34:00 <wolverian> integral, thanks! it works now. using the do notation was easier than >>= apparently
09:34:06 <integral> :-)
09:35:10 <wolverian> is there a perltidy equivalent for haskell, btw?
09:35:30 <wolverian> ..or is that not required given the layout constraints? :)
09:39:22 <Saulzar> You can always format it badly :)
09:42:13 <integral> @type liftM
09:42:13 <lambdabot> Not in scope: `liftM'
09:42:18 <integral> @type Control.Monad.liftM
09:42:19 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
09:42:51 <integral> oh, interesting
10:28:00 <xerox_> Igloo: how often is the debian ghc-cvs package updated, more or less?
10:28:35 <Igloo> xerox_: Currently not at all, due to a make bug
10:29:22 <xerox_> Igloo: what debian GHC package do you advice using then?
10:29:29 <Igloo> For what?
10:29:40 <xerox_> Haskell developing :-)
10:29:47 <Igloo> ghc6
10:30:09 <xerox_> Do you know why GHC packages install hugs too?
10:30:18 <Igloo> Yes
10:30:42 <xerox_> (Why?)
10:30:59 <Igloo> A not very interesting, and probably temporary, reason
10:31:38 <xerox_> Okay.  Thanks for the informations.
10:33:18 <davidhouse> anyone recommend a decent terminal library?
10:43:24 <nuffer> so I have a socket, and I open a connection, and I get a handle on both sides
10:43:35 <nuffer> one side writes to this handle with hPutBuf
10:43:46 <nuffer> and the other calls hGetBuf, but that blocks forever and ever
10:43:48 <nuffer> what's the deal?
10:45:00 <wilx> Buffering? 
10:45:06 <wilx> Forgot to flush?
10:45:11 <nuffer> um, how would one flush?
10:45:27 <wilx> Dunno, hFlush probably?
10:45:37 <nuffer> heh, thanks
10:45:54 <jethr0> nuffer: alternatively you can set the handle to NoBuffering, i think
10:46:11 <nuffer> oh yay, it works now
10:55:35 <wolverian> hm, ghc insists I can't import my data constructor :( 
10:58:18 <musasabi> did you export it?
10:59:16 <davidhouse> anyone know of an HTML parser lib?
10:59:26 <jethr0> wolverian: did you do "Type(Constructor)"?
10:59:41 <wolverian> yes. in both the import and export list 
10:59:49 <jethr0> i mean "import Module (Type(Constructor))"
10:59:55 <musasabi> davidhouse: the XML toolkits have things like that.
10:59:56 <wolverian> yes.
11:00:06 <davidhouse> musasabi: URL?
11:00:15 <wolverian> er, actually.. never mind.
11:00:19 <musasabi> HaXML and Haskell XML Toolkit.
11:00:20 <wolverian> silly typo :)
11:00:28 <musasabi> (google will tell the URLs)
11:00:34 <davidhouse> @google HaXML
11:00:35 <lambdabot> http://www.cs.york.ac.uk/fp/HaXml/
11:01:00 <musasabi> I think toolkit was more lax about non-standard html while haxml is simpler.
11:01:22 <davidhouse> @google haskell xml toolkit
11:01:24 <lambdabot> http://www.cs.york.ac.uk/fp/HaXml/icfp99.html
11:03:02 <wolverian> when working with Data.Graph, do I really need to give my nodes integer ids myself? maybe I'm missing something..
11:07:42 <musasabi> Sorry. Toolbox - http://www.fh-wedel.de/~si/HXmlToolbox
11:08:16 <jethr0> wolverian: yes, if i understand you correctly
11:08:47 <jethr0> though it would be quite neat to be able to use non-ints as node indices!
11:28:57 <Cale> I really wish Data.Graph.Inductive didn't use such ugly names for everything
11:31:16 <jethr0> hehe, like what? you mean all those acronyms that aren't even explained by the haddock docu? :-)
11:33:20 <Cale> yeah
11:33:37 <Cale> I mean, a lot of them are kind of obvious, but still not pretty
11:37:37 <ADEpt> wolverian: about data.gaph and int IDs - take a look at d.g.NodeMap - it will enumerate your nodes for you
11:38:43 <wolverian> ADEpt, oh, neat! thanks
11:38:53 <Cale> the overuse of type synonyms doesn't help much either
11:41:15 <wolverian> hm, using NodeMap might just complicate things, at least in the edge constructor. 
11:41:58 <ADEpt> wolverian: why?
11:42:18 <jethr0> i'm just too thick to get alpha-beta searching... *argh*
11:43:01 <jethr0> _and_ i can't find a decent description with examples :(
11:43:34 <Buggaboo> alpha-beta pruning?
11:43:35 <wolverian> ADEpt, I'm not sure. I'm unclear on what it would look like, in code, and just creating the nodes beforehand seems easier, albeit I'll have to prune the graph afterwards 
11:43:50 <Buggaboo> jethr0: you know minimax?
11:44:10 <Buggaboo> jethr0: alpha-beta pruning is actually just an optimization of minimax.
11:44:34 <wolverian> ADEpt, oh, mkNodes is very useful, though
11:44:58 <jethr0> Buggaboo: i understand all the general stuff. but how to chose the alpha and beta-level escapes me
11:45:08 <ADEpt> wolverian: exactly. you obtain nodemap from it and reuse during edge creation
11:46:30 <wolverian> ADEpt, thanks! 
11:47:40 <nuffer> jethr0: alpha and beta are a known best and worst case scenario
11:47:58 <nuffer> obtained from the incomplete minimax
11:48:23 <jethr0> nuffer: thx. i think i'm getting there. but sometimes it just takes me longer to fully comprehend these things :)
11:50:19 <jethr0> i've looked at many pages via google, but the descriptions all lack a certain understandability. i still don't know where to get my beta, in practice
11:52:24 <Saulzar> There's a nice analogy here
11:52:26 <Saulzar> http://www.seanet.com/~brucemo/topics/alphabeta.htm
11:53:03 <jethr0> thx
11:55:40 <wolverian> hm, I can't figure out how to use NodeMap.new :)
11:59:28 <wolverian> anyone have an example for using NodeMap.new? this is kind of pathetic.. 
11:59:31 <wolverian> (of me)
12:03:07 <wolverian> oh, figured it out.
12:03:13 <jethr0> wolverian: untested: "new :: NodeMap Int"
12:04:10 <Cale> hmm, annoying. It would be awfully nice if the parameters to gr in the Graph class were the other way around.
12:05:33 <jips> is there some light version of type classes where you can sort of somehow define anonymous instances?
12:05:34 <Cale> or if it was  class Graph gr a b | gr -> a b
12:05:43 <Cale> jips: nope
12:05:49 <Cale> anonymous?
12:06:02 <jips> unnamed
12:06:06 <Cale> Instances right now don't have names
12:06:37 <jips> i mean you don't have to even have a type
12:06:44 <Cale> what would that mean?
12:07:03 <jips> i'm not sure yet... i still don't really understand all this stuff yet :O
12:07:21 <Cale> I suppose you'd have a nullary predicate on types...
12:07:34 <Cale> You'd either have an instance of the class in your program, or you wouldn't.
12:07:44 <Cale> It wouldn't be too interesting :)
12:08:04 <jips> ok maybe there is a totally different answer to my problem
12:08:20 <Cale> what is your problem?
12:08:45 <jips> let's say i have a function foo :: X -> Int
12:08:59 <Cale> sure
12:09:26 <jips> X is some kind of record or tuple that has a way to get values of fields representing "a" "b" and "c"
12:10:27 <jips> now i need a type called Y, that is just like X, but it has additional things, fields represting the concepts of "d" and "e"
12:10:34 <jips> how can i call foo function with Y values?
12:10:43 <Cale> you can't
12:10:55 <Cale> You have to project down from Y to X
12:11:04 <Cale> by dropping the "d" and "e" fields
12:11:08 <jips> if X is a type class then i can have functions getA getB and getC and then have Y an instance or something and it should work, right?
12:11:10 <Saulzar> You could use a type class X and Y...
12:11:19 <Cale> yeah
12:11:30 <jips> but you think that i should have a dropYtoX function?
12:11:31 <Cale> if you have a typeclass  HasABC
12:11:47 <Cale> then you can have instances  HasABC X, and HasABC Y
12:12:54 <Cale> but depending on what you're doing, it seems simpler to just write a function to convert from Y to X.
12:13:14 <wolverian> argh, I don't want to put IO actions into my graph! 
12:13:21 <Cale> wolverian: hm?
12:13:32 <wolverian> I read the node data from a file. 
12:13:32 <Saulzar> X and Y have to be types rather than classes?
12:13:37 <Cale> wolverian: so?
12:13:50 <Cale> wolverian: you don't put the actions for reading the file into the graph
12:13:59 <wolverian> Cale, yes, but I see 'IO String' going there.
12:14:11 <Cale> wolverian: Have you used the IO monad much?
12:14:24 <Cale> you have to run the IO actions
12:14:26 <Saulzar> Extract the string first, x <- myIOString
12:14:27 <wolverian> no, I finally started really learning Haskell today
12:14:32 <Cale> oh, okay
12:14:39 <wolverian> oh, right. okay. thanks :)
12:14:39 <Cale> let me give you a link
12:14:51 <Cale> http://www.haskell.org/hawiki/IntroductionToIO
12:15:01 <araujo> wolverian, nice, Haskell is cool :-)
12:15:22 <wolverian> Cale, thanks!
12:16:32 <jips> hm.... an idea is boiling in my head
12:16:56 <Cale> jips: could you give me a little more context about your situation?
12:17:42 <wolverian> hmm.. okay. I get the lines with liftM lines $ readFile, how do I remove the IO? still not getting it, I guess..
12:17:57 <jips> Cale: i sort of forgot most of it :O i was thinking about it some time ago and eventually drifted to the thought about the X and Y types but i forgot the details of where i started from
12:17:59 <wolverian> just x <- liftM... gives me IO in x 
12:18:01 <araujo> wolverian, you cannot remove the IO
12:18:17 <araujo> The IO is a one-way monad.
12:18:30 <Cale> wolverian: inside the do-block, x will have the result type
12:18:35 <Cale> for example
12:18:44 <Cale> if I have  rollDice :: IO Int
12:18:58 <Cale> and I write  do x <- rollDice; ...
12:19:11 <Cale> then x :: Int
12:19:19 <wolverian> oh!
12:19:21 <Cale> but I can only access it inside that ... part
12:19:22 <wolverian> of course!
12:19:29 <wolverian> sheesh. thanks :) 
12:21:53 <jips> i just had this weird idea. records aren't fun, but they are pretty much the only thing for types with fields. wouldn't it be cool if haskell had better building-blocks so that you could sort of build your own record-like system?
12:24:23 <Cale> jips: yeah, there are a lot of people playing around with ideas of that sort
12:24:32 <wolverian> another silly question: is it normal to mix <- and let .. = .. in main? 
12:24:39 <Cale> wolverian: yeah
12:25:07 <Cale> wolverian: if you find yourself writing   x <- return (...)  you should replace it with  let x = ...
12:25:19 <Cale> (you don't need the 'in' with do notation)
12:25:31 <jips> Cale: i think a really cool feature would values like ruby's :foo
12:25:57 <Cale> do { let x = e; ... }  =  let x = e in do {...}
12:26:00 <jips> :bar is just a value(it's type doesn't really matter) that's only useful in that it is equal to :bar
12:26:17 <jips> and :bar is not equal to :foo
12:26:37 <Cale> jips: yeah, someone proposed something like this where labels were the only elements of their own implicitly declared types
12:27:23 <Cale> types which would always be system-wide, so that two modules using the label #foo wouldn't conflict when imported by a third module
12:27:27 <jips> Cale: i actually think that all labels need to be of the same type
12:27:46 <Cale> Oh, in that case, you can just use strings. :)
12:28:17 <Cale> The neat thing about making them different types is that you can use some typeclass magic to get generic extractors and write Has and Lacks predicates.
12:28:21 <jips> Cale: 1) performance 2) what would such labels that are the only elements of their type be good for at all?
12:28:37 <Cale> one sec, I'll find the posting
12:28:50 <Cale> this is currently being discussed on the mailing lists
12:29:02 <jips> Cale: does this have anything to do with haskell'?
12:29:11 <Cale> yeah
12:29:36 <Cale> Claus Reinke is suggesting that we do something regarding first-class labels.
12:29:46 <jips> Cale: are you familiar with that project where someone implemented an oo style object system in pure haskell?
12:29:56 <Cale> yes
12:30:11 <Cale> it would simplify that work to have labels which were all members of their own type
12:30:13 <jips> what did they use for querying members of objects?
12:30:48 <Cale> Exactly that -- you need to declare new singleton data types for each of your labels, iirc.
12:32:39 <Cale> http://article.gmane.org/gmane.comp.lang.haskell.prime/525
12:33:02 <jips> thanks
12:33:24 <k1ngz0r> Write a Haskell function that, given a String, removes all characters from the string that are not digits. ANybody that could help me with this?
12:33:44 <Cale> k1ngz0r: sure
12:33:58 <Cale> k1ngz0r: do you have a function which tells you if a character is a digit?
12:34:10 <jips> > isDigit '3'
12:34:11 <lambdabot> True
12:34:12 <k1ngz0r> Yea the isDIgt func
12:34:20 <k1ngz0r> I can use that 
12:34:21 <jips> :type filter
12:34:28 <jips> @type filter
12:34:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:34:34 <Cale> k1ngz0r: right, so you can compose it with not to get a predicate that tells you when something isn't a digit
12:34:46 <Cale> and use filter :)
12:34:52 <k1ngz0r> ok thanks
12:35:06 <jips> (not . isDigit) '3'
12:35:12 <jips> > (not . isDigit) '3'
12:35:13 <lambdabot> False
12:37:09 <Cale> http://www.haskell.org//pipermail/haskell-prime/attachments/20060210/a8120fae/Records.obj
12:38:06 <Cale> (that should be called Records.hs, but the mailing list software mutilated the name)
12:38:51 <jips> cool thanks
12:39:30 <jips> gotta go watch some tube now... bbiab
12:39:35 <Cale> I kind of have the impression that large records are just poor design in a functional language, but we do need ways to interface with the rest of the world.
12:44:26 <Saulzar> What about interfacing with different parts of a program?
12:45:28 <k1ngz0r> [ x | x <- s , x == (isDigit 'x') ] how do I get this list compehension to work? I want to take out all digits and discard the chars  I know its wrong now but do the idea looks ok?
12:45:48 <Cale> k1ngz0r: why x == ?
12:45:57 <Trevion> k1ngz0r, how is [x | x <- s, isDigit x] not what you want?
12:46:11 <Cale> [x | x <- s, not (isDigit x) ]
12:46:20 <Cale> oh
12:46:28 <Cale> discard the non-digit chars?
12:46:30 <k1ngz0r> when i trie a string in it I get the result ""
12:46:33 <Cale> [x | x <- s, isDigit x]
12:46:50 <Trevion> > [x | x <- "12abc4s23  ", isDigit x]
12:46:51 <lambdabot> "12423"
12:47:19 <k1ngz0r> ok. I had ' around the x  Thanks guys.
12:48:27 <Saulzar> For example, say I'm writing a little game - each object needs to export some properties, it's graphical representation, physical state, messages to other objects etc. etc.
12:48:42 <Saulzar> How do you concievably deal with that kind of thing where you might have 10 or so fields, without records?
12:52:03 <Cale> Saulzar: well, that sounds pretty stateful, so you'd want some kind of monad for dealing with changing states of things. As for the actual data, you usually determine things later on rather than figuring them out early and tupling the results together.
12:52:22 <Cale> For instance, you might have a Map from objects in your game to their graphical representations.
12:53:07 <Saulzar> Well, say I've got all this state handled internally - no problems there. 
12:53:11 <Trevion> Cale, doesn't that just result in a large record in your state monad instead of records for each object?
12:53:30 <Saulzar> Then I'll have a record of Maps rather than a list of objects?
12:54:07 <Cale> Trevion: possibly constructed by monad transformers, but that would be hidden from you
12:55:13 <Saulzar> Hmm..
12:55:53 <Cale> Of course, for some things, a large tuple is the only thing you can do, but even in the cases where it becomes necessary, I recommend abstracting over it, and only allowing access to those tuples via a class which hides their implementation.
12:56:57 <Cale> In stateful things, it can be hard to avoid carrying around tuples in one way or another.
12:57:03 <Saulzar> How do you mean? Say I have an objects internal state (hidden) and I'm exporting a public state 
12:57:04 <k1ngz0r> is there an command that does this ( 3,4) = 3*4 ??
12:57:18 <Trevion> k1ngz0r, uncurry (*)
12:57:26 <Trevion> > uncurry (*) (3,4)
12:57:27 <lambdabot> 12
12:57:31 <k1ngz0r> tnx
12:57:33 <Cale> @type uncurry
12:57:34 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
12:58:01 <Cale> Uncurry is to pairs what foldr is to lists :)
12:58:28 <ihope> @type uncurry
12:58:29 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
12:58:32 <ihope> @type foldr
12:58:33 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
12:58:34 <Saulzar> It just seems that in order to transport stuff to unrelated parts of a program, records are unavoidable (either that or an abstract type with a whole lot of selectors)
12:59:33 <Cale> You usually want to pass as little as possible to each part of your program.
13:01:24 <ihope> No \a b c d e f g h i j k l m n o p q r s t u v w x y z -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,(x z (y z)))
13:01:38 <Saulzar> That's true I suppose, best to make adaptors to only give out what is absolutely required...
13:01:46 <Cale> right
13:02:04 <Cale> Only pass functions exactly what they need to do their work and no more than that. You may end up with a lot of parameters in some cases, but it makes your design clear, and keeps things fairly extensible.
13:02:36 <Cale> If you need to add extra data, you don't end up with the problem of adapting the functions which don't actually need that data to handle it.
13:03:50 <Cale> Now, proper record systems are another way to solve that problem, and there are cases where it's a good idea to do things that way (especially when interfacing with an external OO design), but it shouldn't be the first thing you try.
13:06:09 <Cale> Data types should usually strive to be reasonably small and universal. Things like trees, lists, and other abstract containers. It doesn't always work out that way, but the best data types seem to not be application-specific.
13:07:29 <wolverian> I like my IRCLog... :/ 
13:08:07 <Cale> Of course, there's something to be said for encoding application specific design issues into the type system too, but that's usually a matter of newtyping things.
13:09:07 <Trevion> Cale, gets and modify are my normal solutions there.
13:09:28 <Saulzar> Seems to depend fairly heavily on the application to me
13:11:10 <Cale> Well, even with the State monad, note that you're using the State monad first, and a particular instance of it second. You can specialise the State monad to your application to control access to your state and enforce program invariants, but that doesn't involve writing a whole new monad (it's just a newtype away, with newtype-deriving)
13:12:53 <Saulzar> My current program I must have 50 records, though ~3 with > 10 items
13:15:35 <k1ngz0r> Help again please. I want to multiply two vectors  ( a,b) *  (c,d) = ac + bd . Using list comprehention . I doesnt get it to work. I gues ypu should  use zip and sum but i dont know how...
13:15:39 <Cale> Did you read my sudoku solver? That's a good example of how I like to handle state.
13:16:11 <Cale> k1ngz0r: well, you can't do it with zip and sum if your vectors are pairs
13:16:25 <Saulzar> Yeah, I like your sudoku solver greatly...
13:16:26 <Cale> they have to be lists, like [a,b] rather than pairs like (a,b)
13:16:37 <Trevion> but if they're lists, you can use \v1 v2 -> sum (zipWith (*) v1 v2)
13:16:59 <k1ngz0r> ok. But i want them to work in the n-vector to
13:17:20 <Trevion> > sum (zipWith (*) [1,3,2] [4,3,4])
13:17:21 <lambdabot> 21
13:17:31 <k1ngz0r> U rock in here!!
13:18:00 <Trevion> @pl \v1 v2 -> sum (zipWith (*) v1 v2)
13:18:01 <lambdabot> (sum .) . zipWith (*)
13:18:29 <ihope> f ? (p -> q) -> OR (NOT p) q
13:18:34 <ihope> -- f cannot be realized.
13:18:49 <k1ngz0r> how does With work? 
13:18:50 <Saulzar> But it's something where you have quite a nice natural representation, (arrays) and it can be all bottled up nicely in the one algorithm
13:19:02 <Cale> @type zipWith
13:19:03 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
13:19:12 <Cale> > (,) 1 2
13:19:13 <lambdabot> (1,2)
13:19:21 <Cale> > zipWith (,) [1,2,3] [4,5,6]
13:19:22 <lambdabot> [(1,4),(2,5),(3,6)]
13:19:26 <Cale> > zip [1,2,3] [4,5,6]
13:19:29 <lambdabot> [(1,4),(2,5),(3,6)]
13:19:34 <Cale> zip = zipWith (,)
13:19:48 <k1ngz0r> ok.
13:20:01 <Cale> zipWith f [x1,x2,...] [y1,y2,...] = [f x1 y1, f x2 y2, ...]
13:20:31 <Cale> In other words:
13:20:40 <Cale> zipWith f [] ys = []
13:20:44 <Cale> zipWith f xs [] = []
13:21:01 <Cale> zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
13:21:32 <flux__> cale, haskell' will support that more concise syntax you showed?-)
13:21:45 <Cale> flux__: no
13:21:49 <flux__> ;(
13:21:52 <Cale> flux__: my syntax was imprecise
13:22:02 <flux__> it wouldn't be if it were specified!
13:22:22 <vincenz> re
13:22:25 <Cale> Note that nothing in what I said mentioned what to do with the empty list.
13:22:31 <vincenz> Cale: hi :)
13:22:35 <Cale> hi :)
13:23:00 <flux__> true, infact that specification should make it fail when given either empty or lists of different length
13:23:05 <vincenz> my code is becoming more and more SYBP
13:23:23 <Cale> vincenz: heh
13:23:31 <vincenz> for instance
13:23:31 <Cale> vincenz: working with AST's?
13:23:45 <vincenz> instance TransformT m a b => TrasformT m (Located a) (Located b)
13:23:51 <vincenz> where Located is the source-code loc
13:23:52 <vincenz> Cale: yeah
13:24:16 <vincenz> sadly I can not do
13:24:17 <vincenz> also
13:24:27 <vincenz> instance TransformT m a b => transformT m (Located a) b
13:24:31 <vincenz> :(
13:24:40 <vincenz> basically located can be seen as a comonad
13:24:57 <vincenz> so the first is basically a cobind of the second instance
13:25:58 <vincenz> also I ahd a second bug
13:26:00 <vincenz> typewise
13:26:22 <vincenz> for the first instanced where Located a = L location a
13:26:25 <vincenz> I had
13:26:45 <vincenz> transform (L l a) = transform b >>= L _
13:26:47 <vincenz> but this didn't work
13:26:52 <vincenz> so I had to do
13:26:57 <vincenz> transform (L l a) = do
13:27:03 <vincenz>    b <- transform a
13:27:03 <k1ngz0r> sum [ x * y | (x, y) <- zip xs ys ] 
13:27:05 <vincenz> return L l b
13:33:25 <k1ngz0r> ok My last question for tonight. I want a generator for positive integers 
13:33:54 <Cale> [1..]
13:33:57 <Cale> > [1..]
13:33:58 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
13:33:58 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
13:33:58 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
13:33:58 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
13:33:58 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
13:34:00 <lambdabot> [24 @more lines]
13:34:17 <basti_> i recently was told that CoMonads are not the Co-constructions of Monads, which makes sense. I just want to warn about the pitfall
13:34:32 <Cale> what?
13:34:40 <Cale> They are though.
13:34:45 <basti_> they are?
13:34:50 <k1ngz0r> OK but i just want one number in return 
13:34:52 <basti_> o.0
13:35:04 <basti_> then somebody was talking out of his butt and I fell for it
13:35:45 <Cale> I suppose it depends on how you look at it, but the definition for a comonad is just the definition for a monad with the arrows swapped around.
13:36:00 <basti_> you mean the CT representation of the monad laws?
13:36:35 <Cale> yes
13:37:19 <basti_> hmm ok, the guy who told me that obviously was working on a lower level, which explains why the reasoning was broken
13:37:24 <basti_> (or so i think)
13:37:24 <Cale> A comonad for the category C is a monad for the category C^op which is the category with the same objects as C but in which every arrow has been reversed.
13:37:43 * basti_ nods
13:38:18 <gzl> it would be pretty annoying if somebody misused 'co' like that
13:38:25 <basti_> yes that would suck
13:39:17 <taw_> hello :-)
13:39:21 <Cale> hi
13:39:27 <basti_> hi
13:39:39 <taw_> what would that error message be ... Could not find module `Data.Array.IO':
13:39:39 <taw_>   it is a member of package base-1.0, which is hidden
13:39:45 <k1ngz0r> thanks for all help Good night! 
13:40:16 <basti_> thats "lib not found, because somebody set a flag"
13:40:29 <Cale> ghc-pkg expose base
13:40:42 <basti_> why would base be hidden?
13:40:52 <Cale> I don't know, it shouldn't be
13:40:57 <Cale> if that doesn't help, try compiling with --make
13:42:37 <taw_> ghc-pkg: /usr/lib/ghc-6.4.1/package.conf: you don't have permission to modify this file
13:42:47 <taw_> uhm, just trying to compile something ^_^
13:43:36 <Cale> taw_: hmm, could you type "ghc-pkg list | grep base" and tell me if base-1.0 is enclosed in parens?
13:43:53 <taw_>     rts-1.0, base-1.0, haskell98-1.0, template-haskell-1.0, unix-1.0,
13:44:02 <Cale> taw_: okay, hmm
13:44:08 * basti_ .o ( ? )
13:44:15 <Cale> so that's not it
13:44:29 <Cale> what are you compiling?
13:44:34 <taw_> lava
13:46:58 <Cale> well, the homepage doesn't have a download link (they say there are licensing issues) but the filename was easy to guess :)
13:47:13 <taw_> ghc -odir $(LAVAP) -hidir $(LAVAP) -fglasgow-exts -prof -ignore-package lava-0.1 --make Lava.hs
13:47:19 <taw_> ;-)
13:47:41 <taw_> i got the tarball from some other website
13:47:53 <taw_> is one of these flags responsible ?
13:48:03 <astrolabe> In the report, there is a function   insert::Ord a => a->[a]->[a].
13:48:08 <astrolabe> @hoogle insert
13:48:08 <lambdabot> Data.HashTable.insert :: HashTable key val -> key -> val -> IO ()
13:48:08 <lambdabot> Data.IntMap.insert :: Key -> a -> IntMap a -> IntMap a
13:48:08 <lambdabot> Data.IntSet.insert :: Int -> IntSet -> IntSet
13:48:19 <astrolabe> it isn't one of those.
13:48:25 <Cale> taw_: not that I can tell
13:48:29 <Cale> @type insert
13:48:31 <lambdabot> Not in scope: `insert'
13:48:32 <astrolabe> What do I need to import to use it?
13:48:37 <Cale> @type Data.List.insert
13:48:38 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
13:48:48 <astrolabe> Thanks Cale!
13:48:52 <Cale> no problem
13:50:27 <taw_> od, the tarball lava seems to be pretty much different than the one from the other website
13:52:30 <Cale> aha
13:52:35 <taw_> i tried this one http://raintown.org/lava/lava-0.1a.tar.gz
13:52:44 <Cale> right, the other one sucks :)
13:53:01 <Cale> edit lava.cabal and replace haskell98 in the Build-depends line with base
13:53:01 <taw_> well, doesn't really matter which one, i'd like to get either compiled :-)
13:53:16 <Cale> then do a runhaskell ./Setup.hs configure
13:53:24 <Cale> and then runhaskell ./Setup.hs build
13:53:24 <taw_> ok
13:53:30 <taw_> configure: No greencard found
13:53:34 <taw_> by the way, what is this one ?
13:53:38 <Cale> install greencard :)
13:53:41 <taw_> (doesn't seem to be fatal)
13:53:50 <Cale> oh
13:53:54 <Cale> Perhaps it's optional
13:54:04 <Cale> greencard is an automatic FFI generator
13:58:17 <vincenz> Hello
13:58:40 <vincenz> how would I generate [[(a,b)]] from a and b such that the result is all the possible maps
13:59:02 <vincenz> given two lists (aka input set, output set)
13:59:11 <vincenz> I'm doing some studying of categories
13:59:11 <taw_> thx, it compiled
13:59:18 <vincenz> and I Want to generate all the possible mappings from set a to set b
13:59:23 <vincenz> (well here a set is just a list)
13:59:27 <taw_> now it wants some weird xilinx tools, but that's a non-haskell problem i guess
13:59:41 <Trevion> vincenz, why not [(a,b) | a <- as, b <- bs]?
13:59:50 <vincenz> Trevion: that's not all mappings
13:59:58 <Cale> that's just all pairs
14:00:34 <Trevion> Ohhhh.  Sorry, brain-death.
14:00:55 <vincenz> stupid question the number of mappings from A to B  = |A| * |B|?
14:01:19 <Cale> no
14:01:23 <vincenz> no?
14:01:26 <Cale> B^A
14:01:27 <astrolabe> |B|^|A|
14:01:29 <vincenz> ah
14:01:37 <vincenz> see why I want the little code?
14:01:42 <Cale> Which explains the use of B^A for the set of such mappings :)
14:01:55 <vincenz> so
14:02:00 <vincenz> to generate all mappings given conditions?
14:02:47 <Cale> sequence [[(a,b) | b <- bs] | a <- as]
14:02:58 <Cale> that's all mappings
14:03:24 <Cale> > sequence [[(a,b) | b <- [4,5,6]] | a <- [1,2,3]]
14:03:25 <lambdabot> [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,4),(3,6)],[(1,4),(2,5),
14:03:25 <lambdabot> (3,4)],[(1,4),(2,5),(3,5)],[(1,4),(2,5),(3,6)],[(1,4),(2,6),(3,4)],[(1,4),
14:03:25 <lambdabot> (2,6),(3,5)],[(1,4),(2,6),(3,6)],[(1,5),(2,4),(3,4)],[(1,5),(2,4),(3,5)],[
14:03:25 <lambdabot> (1,5),(2,4),(3,6)],[(1,5),(2,5),(3,4)],[(1,5),(2,5),(3,5)],[(1,5),(2,5),(
14:03:25 <lambdabot> 3,6)],[(1,5),(2,6),(3,4)],[(1,5),(2,6),(3,5)],[(1,5),(2,6),(3,6)],[(1,6),(
14:03:27 <lambdabot> [3 @more lines]
14:03:52 <Cale> of course, there are usually quite a lot of them :)
14:03:56 <astrolabe> > sequence [[(a,b) | b <- [5,6]] | a <- [2,3]]
14:03:57 <lambdabot> [[(2,5),(3,5)],[(2,5),(3,6)],[(2,6),(3,5)],[(2,6),(3,6)]]
14:04:10 <astrolabe> Wow, it works!
14:04:12 <vincenz> Cale: can you explain me why?
14:04:25 <jips> can Data.Dynamic be implemented in pure haskell, or does it need special magic?
14:04:27 <astrolabe> @type sequence
14:04:27 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:05:03 <Cale> vincenz: sequence takes a list of lists and picks one member from each
14:05:25 <astrolabe> That way of getting the maps is lovely
14:05:26 <Cale> and constructs a list of all possible ways of doing that
14:05:40 <Cale> here, we're using the list monad specifically
14:05:43 <vincenz> hmm
14:05:46 <vincenz> Cale: so...
14:05:50 <Cale> sequence [[1,2],[3,4]]
14:05:51 <vincenz> Cale: now if I wanted to add a condition
14:05:52 <Cale> > sequence [[1,2],[3,4]]
14:05:53 <lambdabot> [[1,3],[1,4],[2,3],[2,4]]
14:06:15 <Cale> so all you need to do is to generate possible pairings for each element of the domain
14:06:16 <vincenz> like f o f = f
14:06:43 <astrolabe> One way is to generate them all, and then filter
14:06:44 <Cale> okay, for that, you'll want to define composition on these functions
14:06:46 <Cale> yeah
14:06:49 <vincenz> ok
14:06:55 <Cale> probably filtering is easiest here
14:06:57 <vincenz> thx
14:07:11 <Cale> if you'd like to generate those functions specifically, we can do that
14:08:39 <Cale> The domain of every function f such that f . f = f is a disjoint union of two components, A and B such that f restricted to A is the identity map, and the image of B under f is a subset of A.
14:08:53 <vincenz> Cale: not there yet :)
14:09:05 * vincenz is doing the book "Conceptual Mahtematics" - A first introduction to categories
14:09:11 <vincenz> I never studied category theroy
14:09:28 <Cale> well, that's more a set-theoretic thing, or perhaps a combinatorial thing
14:09:36 <vincenz> Cale: yeah just intro to categories
14:10:08 <Cale> I mean, what I'm talking about there isn't properly category theory (though I suppose it's the theory of a particular category).
14:15:44 <vincenz> right but it's intro
14:15:53 <vincenz> blegh
14:16:02 <vincenz> let compose f g = map (\(a,b) -> (a, apply f b)) g
14:16:05 <vincenz> it won't work
14:16:09 <vincenz> apply is defined correctly
14:16:49 <vincenz> whoops
14:18:33 <vincenz> now to define equality
14:23:48 <vincenz> why is |S| where S = f for which f = f.f  for f:A -> B |A| = 3 |B| = 3 == 10
14:24:27 <astrolabe> A=B?
14:24:31 <vincenz> yeah
14:24:35 <vincenz> sorry
14:24:43 <vincenz> and for |A| == 2 it's 3
14:25:39 <astrolabe> In Cale's classification, there are 3+3+1 possible images of f
14:25:48 <astrolabe> for |A| = 3
14:26:19 <astrolabe> The image of size three determines f completely (it is the identity)
14:26:52 <astrolabe> Each of the three images of size 2 give rise to two fs
14:27:10 <astrolabe> Each image of size 1 determines f completely
14:27:41 <astrolabe> So the total number of fs is 3*1+3*2+1*1 = 10
14:29:19 <vincenz> how about
14:29:59 <vincenz> |f| : A -> B, |g| : B -> A, |A| = 3, |B| = 2... g.f = idB
14:30:46 <astrolabe> I don't understand
14:31:01 <vincenz> number of function)pairs that satisfy the above
14:31:02 <astrolabe> what is |f|?
14:31:24 <vincenz> err
14:31:29 <vincenz> f : A -> B, g : B -> A, |A| = 3, |B| = 2... g.f = idB
14:31:40 <astrolabe> what is idB?
14:31:53 <vincenz> B -> B where idB(x) =x
14:31:55 <astrolabe> Ah ok
14:32:18 <astrolabe> but g.f :A->A
14:32:27 <vincenz> erm no
14:32:44 <vincenz> oh whoops
14:32:45 <vincenz> yeah
14:32:53 <vincenz> f.G sorry
14:33:04 <astrolabe> ok
14:33:39 <astrolabe> So, g can be anything as long as it is injective
14:33:39 <vincenz> I get 12
14:33:43 <vincenz> after a lot of work
14:33:57 <vincenz> injective == ?
14:34:01 <astrolabe> So there are 3*2 = 6 possible gs
14:34:11 <vincenz> how do you do that so fast?
14:34:20 <astrolabe> injective means   gx=gy => x=y
14:34:32 <astrolabe> I'm a slow thinker!
14:34:42 <astrolabe> Just practise I guess.
14:34:58 <vincenz> it doesn't have to be injective
14:35:10 <vincenz> does it?
14:35:20 <astrolabe> For each g, f restricted to im g is determined by g
14:35:51 <vincenz> how do you know there are 3*2 injective g's?
14:36:17 <astrolabe> If g x = g y then x=f g x = f g y = y
14:36:59 <astrolabe> The first element of B can go anywhere (3 possiblities) and then the second can go anywhere else (2 possiblities).
14:37:06 <vincenz> ah right
14:37:29 <xerox_> One sweet lambda candy to the first person that comes up with a way to list the contents of a given path!!
14:37:54 <vincenz> astrolabe: ok... so why the if g x = g y then ...
14:37:55 <astrolabe> So, given g, we the only freedom for f is on the point that isn't in the image of g, and there are 2 possiblities.
14:38:23 <vincenz> right
14:38:25 <astrolabe> Therefore 6*2 (f,g) pairs.
14:38:27 <TuringTest> xerox_: A filesystem path?
14:38:34 <vincenz> astrolabe: thx
14:38:41 <xerox_> TuringTest: yup.
14:38:48 <vincenz> astrolabe: how about the math f.f = f
14:38:49 <Saulzar> @hoogle directory
14:38:49 <lambdabot> System.Directory.createDirectory :: FilePath -> IO ()
14:38:49 <lambdabot> System.Directory.removeDirectory :: FilePath -> IO ()
14:38:49 <lambdabot> System.Directory.renameDirectory :: FilePath -> FilePath -> IO ()
14:39:03 <ihope> join renameDirectory
14:39:10 <TuringTest> > System.Directory.getDirectoryContents "."
14:39:11 <lambdabot>  Not in scope: `System.Directory.getDirectoryContents'
14:39:32 <TuringTest> @t System.Directory.getDirectoryContents
14:39:33 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
14:39:33 <lambdabot> null topic-snoc topic-tail topic-tell type .
14:39:34 <xerox_> @docs System.Directory
14:39:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.
14:39:35 <lambdabot> html
14:39:38 * Saulzar substitutes the response if it was in scope 
14:39:41 <Saulzar> No IO allowed
14:39:55 <xerox_> getDirectoryContents :: FilePath -> IO [FilePath]
14:39:57 <xerox_> Nice one.
14:40:33 <TuringTest> xerox_: The libraries are small enough that I have found more useful things than I have actually used
14:42:34 <ihope> Why doesn't it say something akin to "add an instance declaration for (Show (IO a))"?
14:42:36 <TuringTest> xerox_: doesFileExist and doesDirectoryExist are two ways to decide what the things in the [FilePath] are
14:42:59 <ihope> Well, not so much akin to that as... that.
15:08:24 <xerox_> @hoogle doesFileExist
15:08:25 <lambdabot> System.Directory.doesFileExist :: FilePath -> IO Bool
15:08:36 <xerox_> @hoogle when
15:08:36 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
15:31:39 <dons> @y0w
15:31:39 <lambdabot> Hello.  Just walk along and try NOT to think about your INTESTINES
15:31:39 <lambdabot> being almost FORTY YARDS LONG!!
15:31:57 <jethr0_> hi dons
15:32:01 <tromp> yards? how many furlongs is that?
15:33:11 <dons> @google 40 yards in furlongs
15:33:12 <lambdabot> 40 yards = 0.181818182 furlongs
15:33:19 <dons> :D
15:33:46 <tromp> thx, dons:)
15:34:50 <jethr0_> @google 20 dollars in euro
15:34:52 <lambdabot> 20 U.S. dollars = 16.7210099 Euro
15:35:14 <tromp> @google worldwide oil supplies in years
15:35:16 <lambdabot> http://www.petroleumequities.com/OilSupplyReport.htm
15:35:33 <jethr0_> ^_^
15:36:00 <tromp> @google lightspeed in furlongs per fortnight
15:36:01 <lambdabot> http://snoozebuttondreams.com/archives/018792.html
15:38:22 <jethr0_> @google 0x7d3 in roman numerals
15:38:23 <lambdabot> 0x7d3 = MMIII
15:40:10 <TuringTest> dons: I posted a new version of Trie w/ Asscoc #2 on KNucleotide
15:41:46 <jethr0_> let's say i had a lazy which i wanted to annotate with weights. but as the evaluation has changing parameters, i can't put it directly into the lazy tree, but have to traverse the tree in a second step
15:41:48 <dons> yep. benchmarking as we speak :)
15:42:07 <TuringTest> :)
15:42:20 <jethr0_> i thought about doing it with state monad, but i only have one branch of the tree and can't write that in state monad...
15:42:24 <jethr0_> any ideas?
15:42:29 <TuringTest> dons: On G4, the -A works better than -H for runtime
15:42:46 <dons> ok. i think it depends on the amount of ram in the machine
15:45:03 <jethr0_> ?
15:59:39 <dons> TuringTest, FAST!
15:59:47 * TuringTest goes to look
15:59:51 <dons> 3.548s with 2.5M :) no thrashing
15:59:57 <dons> lovely work
16:00:15 <dons> @karma+ TuringTest
16:00:15 <lambdabot> TuringTest's karma raised to 4.
16:00:25 <TuringTest> I explained my change -- never ever construct a data type you are not going to keep
16:00:39 <TuringTest> the old Trie violated that something awful
16:00:43 <dons> yep. great idea.
16:01:05 <dons> . and we don't need weird runtime flags :)
16:01:12 <dons> it just works.
16:01:14 <TuringTest> dons: (I still need them on G4)
16:01:41 <TuringTest> dons: I had to pass in the whole list of strings instead of foldl' over them to make it work.  Once I did that the rest was easy.
16:03:48 <TuringTest> dons: I could detect no difference with !Int versus Int strictness in my testing.
16:04:30 <dons> ah, I see. that's interesting.
16:04:39 <dons> so .... is it legal?
16:05:10 <TuringTest> It is not an associative data structure like a Hashtable or Map
16:05:46 <TuringTest> And there is no update function that is explicitly required (we never update, only declare lazily...)
16:05:54 <dons> true.
16:06:01 <TuringTest> So no, it is an interesting alternative, not a real entry.
16:07:32 <Saulzar> Hmm, I was wondering if a map of Integer -> String might work well, coding the ATCG chars in an Integer
16:08:38 <Saulzar> I guess it gets much worse with the size of the Integer, since it's an exact representation not a hash
16:08:56 <dons> oh, update. yuck. that's where it gets nasty.
16:09:15 <dons> Saulzar, I tried that. the cost of packing/unpacking dominates
16:09:26 <Saulzar> Hmm
16:09:58 <TuringTest> Heh...given the size of the wiki page at http://haskell.org/hawiki/KnucleotideEntry I think half of everything has been tried.
16:10:00 <dons> in fact, I packed small values into a Word32, and large strings into a Integer. still, unpack /pack were no good.
16:10:13 <dons> hehe
16:11:06 <TuringTest> The consensus is that Data.Hashtable is quite poor, and we look forward to the new implementation in the next GHC version
16:12:33 <TuringTest> Haskell is just not optimized for created many short lived pieces of data
16:12:51 <jethr0_> dons, saulzar, any ideas how to traverse/rebuild a tree using state monad or similar?
16:12:54 <TuringTest> s/created/creating/
16:13:52 <Saulzar> jethr0_, What do you need the state monad for? Unless you need to keep some state in doing so...
16:14:53 <Saulzar> Or build a tree as a state in doing something else I guess, hmm.
16:14:56 <palomer> Data.Hashtable needs to be typeclassified
16:15:05 <jethr0_> Saulzar: well, passing updated branches up again might get messy if the computation were complex in itself
16:15:09 <palomer> and Hashable should become a typeclass
16:15:14 <dons> yeah, packed strings + hashtable, then it'll run like C, I'd think.
16:15:40 * palomer doesn't even think that rewriting Data.Hashtable will be that much work
16:18:12 <Saulzar> jethr0_, Not sure I understand the problem :)
16:18:55 <jethr0_> Saulzar: i've got a lazy "Tree a = Branch (Maybe Double) [Tree a] | Leaf (Maybe Double) a"
16:19:12 <Saulzar> Would a hashtable using alloc and Ptr with the FFI, do poorly as well?
16:19:34 <jethr0_> the "Maybe Double"s are set to Nothing initially. and then i want to traverse the tree and annotate it with somehow calculated values
16:19:51 <jethr0_> and i was wondering how a stateful version of that might look like, if possible
16:20:35 <TuringTest> palomer: I think there is a  new Hashtable in GHC darcs somewhere
16:21:17 <TuringTest> Saulzar: I used a c hash table with FFI -- it was 4 or 5 times faster
16:21:17 <Saulzar> jethr0_, Is the calculated value requiring state?
16:21:53 <TuringTest> Saulzar:  But I can't submit that to the shootout benchmark.  And the c hash table was overspecialized for this code.
16:22:25 <TuringTest> dons: I made only a minor edit (and cleaned up insertAll in the FASTEST code)
16:22:28 <jethr0_> Saulzar: no. but if the functions got sufficiently complex, state would be nice in order to not worry about rebuilding the tree in returning. but instead do it in a state monad somehow
16:22:34 <jethr0_> maybe it was just a dumb idea...
16:22:43 <TuringTest> jethr0_: You could use partial continuations...
16:23:13 <jethr0_> yes, i've thought about that. but i want to alter/annotate the tree
16:24:05 <TuringTest> jethr0_: You cannot alter the three, as it is immutable data.  You can only build new nodes and maybe re-use subtrees.
16:24:11 <TuringTest> three->tree
16:24:14 <Saulzar> Could you just have your traverse/rebuild take a function   node -> node? 
16:24:14 <jethr0_> i know
16:24:28 <jethr0_> i'll post code in a minute
16:24:45 <jethr0_> Saulzar: that would be one solution
16:25:49 <Saulzar> Not sure state would make sense, updating the whole tree as a state seems awkward
16:30:20 <lisppaste2> jethr0 pasted "minimax" at http://paste.lisp.org/display/16791
16:30:23 <Saulzar> Is (a predecessor of) ghc-api the lower level mechanism behind hs-plugins? Was thinking about limiting module imports... and the dependency graph thing looks useful. 
16:30:52 <Saulzar> Hmmm..
16:30:52 <TuringTest> dons: For amusement, I found that "GATTACA" shows up 126 times.
16:32:15 <Saulzar> Creating a tree for minmax? Won't that be a _big_ tree?
16:32:52 <TuringTest> (And evaluate only works on "Tree Double")
16:32:57 <jethr0_> Saulzar: yes. i want to implement alpha-beta search and thought a lazy tree might be a good idea
16:33:09 <jethr0_> TuringTest: it's work in progress
16:33:16 * TuringTest nods
16:33:18 <Saulzar> Hmm
16:34:06 <jethr0_> Saulzar: how would you do min-max then?
16:34:30 <Saulzar> Interesting, I wonder if you could implement transpositions by making a cyclic "tree" :)
16:34:40 <jethr0_> huh?
16:34:56 <Saulzar> jethr0_, The usual way is with a recursive function (for game search)
16:35:17 <jethr0_> as i said: ideally i would put the evaluation into the lazy tree already. but alpha and beta change...
16:35:41 <jethr0_> Saulzar: well, a lazy tree has pretty much to do with recursive functions
16:36:04 <jethr0_> once i go one/two levels down, the now historic part of the tree should be garbage collected
16:36:24 <Saulzar> Hmm, alpha beta won't change the evaluation, just will prune a large number of nodes requiring to be searched
16:36:59 <vincenz> how many isomorphisms A->A are there? |A|!?
16:37:48 <TuringTest> vincenz: that sounds right, since it has to be reversable.
16:37:55 <jethr0_> i meant "tree = let cs = ... in Branch (alpha_beta cs) cs"
16:38:26 <jethr0_> but alpha and beta value have to change while traversing the tree, so i can't put the call to the algorithm into the lazy tree already
16:38:43 <vincenz> TuringTest: that's fac |A|
16:38:48 <vincenz> if I understood correctly?
16:38:51 <Saulzar> Ahh, I see.. right, evaluation changes depending on search depth
16:39:13 <TuringTest> vincenz: Yes (Disclaimer: I am not CS)
16:40:25 * TuringTest pulls the plug and goes to bed
16:40:39 <jethr0_> night
16:40:40 <Saulzar> jethr0_, Hmm, maybe the evaluation could be defined as a "full" evaluation for some fixed depth...
16:41:04 <Saulzar> jethr0_, So it won't change, but a tree represents a certain depth of evaluation only
16:41:53 <Saulzar> Then you can use a recursive alpha-beta function to search that tree
16:42:21 <Saulzar> Wait, alpha-beta won't change either when it is fully evaluated
16:42:35 <jethr0_> Saulzar: you got me thinking... maybe the alpha, and beta values change locally enough for it being possible to embed into the tree
16:42:48 <jethr0_> i'll play around with it a little...
16:43:30 <jethr0_> but evaluating to a certain depth still gives me a headache.
16:43:35 <Saulzar> If you put alpha-beta in the tree too, then your tree could represent the whole search algorithm :)
16:43:50 <jethr0_> you're right
16:44:09 <Saulzar> But you'll be implementing a recursive alpha-beta to build the tree, I think..
16:44:22 <jethr0_> but with restricted depth comes another problem. guessing an evaluation of a branch will give a different result that evaluation of a the final leaves. so depending on depth the whole tree values change :(
16:44:31 <jethr0_> sure
16:44:43 <Saulzar> Right..
16:45:25 <Saulzar> That's a hard problem, you could re-use your old tree as a cache probably for iterative-deepening
16:45:34 <jethr0_> i hadn't thought about that previously. so you never _can_ reuse your old results in alpha-beta search
16:45:45 <jethr0_> but in a sense you start from scratch every time :(
16:46:10 <Saulzar> That's how just about all (good) chess programs do it
16:46:32 <Saulzar> Except they just use a giant hashtable of positions to represent the old search tree rather than a tree
16:46:41 <jethr0_> yes, but naively i had thought that you could reuse your previous n-ply search and _add_ to that
16:46:56 <Saulzar> But you can..
16:47:02 <Speck> would this tree be a comonad?
16:47:04 <jethr0_> but instead you start from zero every time (discounting valuable things you learnt from past traversals)
16:47:27 <jethr0_> Saulzar: how?
16:48:04 <Saulzar> If your old tree is a tree of infinite size (representing the whole game search tree), but still only for a fixed depth _search_ of that tree..
16:48:53 <Saulzar> I guess you run into troubles if you try to read off the evaluation of a previous search when you hadn't actually searched it
16:49:27 <jethr0_> no, that part is clear (and it's rather finite). but you have to "guess" the value of a position if you're searching to a limited depths. and when you come back, but search one ply deeper, all values above will change due to correcting the "guess"
16:49:51 <Saulzar> Right..
16:50:20 <Saulzar> An extremely important part of alpha-beta is that you search best-first
16:51:23 <Speck> attribute grammar where alpha is a synthesized attribute of beta?
16:51:54 <Saulzar> jethr0_, I suspect using a plain recursive algorithm will be much easier to start with
16:52:45 <jethr0_> Saulzar: *pah*, starting the hard way is always the most fun :)
16:53:02 <jethr0_> Speck: it got nothing to do with that. this is an optimization of min-max-searching
16:53:16 <Speck> oh ok
16:53:30 * Speck is being silly
16:53:32 <Saulzar> (When you have a good idea of the best moves, you have a better estimate of search bounds - so the previous search is very valuable)
16:53:44 <jethr0_> Saulzar: i'm aware of that
16:53:48 <Saulzar> jethr0_, Yeah, then you go and do it the easy way :)
16:54:08 <jethr0_> if it turns out, my plan was too ambitious, yes :)
16:55:34 <Saulzar> Are you doing search for cops/robbers?
16:57:28 <jethr0_> Saulzar: partially, but no. i've got dons' solution for cops and robbers. and they were using alpha-beta search.
16:57:48 <jethr0_> and as i'm trying to implement all kinds of algos at the moment i wanted to try ab-search as well
16:58:01 <jethr0_> my genetic algorithm is finished already and works like a charm :)
16:58:46 <Saulzar> Cool - how are you applying that?
16:59:12 <jethr0_> not to cops/robbers. but i've wanted to write a genetic algo for othello/reversi for ages.
16:59:19 <Saulzar> Ahh
16:59:39 <jethr0_> and alpha-beta is pretty applicable to that as well. so i'm going for a genetic algo on top of alpha-beta for othello *gg*
16:59:49 <Saulzar> For deciding the evaluation?
17:00:16 <jethr0_> it's amazing how fast the genetic algo found a "good" weighting table for the board. based on single moves (without lookahead).
17:00:24 <Saulzar> Cool, some people do that kind of thing for pawn structure in chess. Though I think it never really beats brute force hardcoded asm :)
17:01:06 <jethr0_> in othello it's pretty straight-forward. corners count most, edges are pretty good, and fields that lead the enemy to get the corners/edges are bad
17:01:22 <jethr0_> s/count/are valuable/
17:01:46 <jethr0_> and the genetic algo got that extremely fast. w/o me giving any pointers to that end
17:01:50 <Saulzar> Hmm, so you are evaluating a weighting table? 
17:02:16 <jethr0_> i let a population of weighting tables compete against each other and let the winners have a better chance at reproducing
17:02:43 <Saulzar> Hmm, how do you decide which is "best"? Databse of games?
17:03:46 <jethr0_> no. i've got a population of 48 tables. then i let pairs of two play each other, then the same with only the winners until an ultimate winner is established. fitness is determined by how far you got and by how many stones you won
17:05:17 <Saulzar> Oh wow, games are fast with no search I guess :)
17:05:45 <jethr0_> ya, well. my implementation of othello is exceedingly slow. but it's a good start
17:06:20 <jethr0_> at a population of 48, that's 48*24*12*6*3 games played per generation. and on an 8x8 board that takes about 1-2 seconds
17:07:28 <jethr0_> but astonishingly, at generation 20 there emerge pretty good weighting tables already
17:08:38 <Saulzar> That's neat
17:09:00 <jethr0_> :)
17:09:56 <Saulzar> They should have game program entries in the shootout :)
17:10:51 <Saulzar> For simple games, I guess un-solvable games. Is othello solved?
17:11:10 <jethr0_> true, some of the shootout entries are just not complex enough for haskell's lazyness to shine
17:11:43 <nuffer> othello is solvable
17:11:56 <nuffer> all games with no chance and no hidden information are
17:11:59 <jethr0_> Solved on a 44 and 66 board as a second player win. On 8x8, 10x10 and greater boards the game is strongly supposed to be a draw. Nearly solved on 8x8 board (the standard one): there are thousands of draw lines.
17:13:04 <Saulzar> nuffer, By that definition chess is solvable... which century?
17:13:22 <nuffer> I said solvable, not easily or even feasibly solvable
17:13:28 <jethr0_> hehe, i was quoting
17:13:58 <jethr0_> is it _that_ easy to force a draw in chess? i didn't think so
17:14:14 <Saulzar> No
17:15:17 <jethr0_> i find othello a nice game to work on. it has a simple strategy (getting the corners and edges) but getting there can be tough. so it's the perfect test-case for alpha-beta for me :)
17:15:46 <Saulzar> Many games are drawn, I think around 30-40%, but there are no lines even close to solved
17:33:13 <Igloo> FWIW I'm told the strategy is deeper than you think, e.g. http://www.boardgamegeek.com/thread/5799
17:33:32 <Igloo> But I've hardly played it myself
17:34:05 <jethr0_> Igloo: i'm sure it is. but the corners/edges heuristic works pretty well against "normal" adversaries
17:35:38 <jethr0_> after all, i'm trying to do some naive AI here. and the results that emerged (i.e. corners and edges) emerged solely from the genetic algorithm w/o my interference.
17:36:07 <jethr0_> only the tool of weighting tables was given, but then again that limits the "AI" considerably already
17:44:14 <vincenz> jethr0_: how does it work
17:44:26 <jethr0_> vincenz: what?
17:44:39 <vincenz> jethr0_: the ga with AB-pruning
17:45:03 <jethr0_> hmm, still slightly stuck on AB-pruning... but making (slow) progress
17:45:07 <jethr0_> and yourself?
17:45:27 <vincenz> learning about categories
17:46:20 <jethr0_> so i saw. i really liked cat. theory. although it can be pretty taxing at times
17:46:49 <vincenz> the book I have is pretty good
17:46:53 <vincenz> very newbie oriented
17:46:57 <vincenz> the other one I have is much harder
17:47:05 <vincenz> "category theory for the working mathematician"
17:47:07 <vincenz> so I plan to tackle that later
17:50:10 <jethr0_> what specifically in cat. th. interests you?
17:50:55 <vincenz> just to get the fundamentals
17:50:58 <vincenz> so I understand it
17:51:13 <jethr0_> :)
17:55:07 <vincenz> stuck on an excercise
17:56:14 <vincenz> f : A -> B, h : A -> C, forall a1,a2 elof 1 -> A, fa1 = fa2 => ha1 = ha2..... |-?  thereexists g s.t. g.f = h
17:58:57 <jethr0_> don't ask me... i gave up cat. th. a long time ago :)
17:59:37 <vincenz> I'm supposed to be able to do this without too much knowledge
17:59:40 <vincenz> I'm still in early chapters
18:02:41 <vincenz> I guess not
18:02:45 <vincenz> I think it should be <=>
18:02:51 * vincenz works out an example case
18:06:01 <vincenz> err, actuall I think it holds
18:06:03 <vincenz> but I can't prove it
18:08:36 <jethr0_> don't you know anything else about the relation of B and C?
18:11:10 <vincenz> no
18:11:16 <vincenz> that's the generic problem of "determination"
18:11:24 <vincenz> determine a g s.t. g*f = h
18:11:30 <vincenz> the question is, is thre a g?
18:11:33 <vincenz> intuitively, there is
18:11:36 <vincenz> basically
18:11:47 <vincenz> if f(a) = f(b) => g(a) = g(b)
18:11:51 <vincenz> err
18:11:55 <vincenz> if f(a) = f(b) => h(a) = h(b)
18:11:57 <vincenz> then
18:12:04 <vincenz> take g(f(a)) = h(a)
18:12:10 <vincenz> but I can't prove it
18:13:25 <vincenz> if f(a) != f(b) -> g(f(a)) = h(a) & g(f(b))
18:13:30 <vincenz> =h(b)
18:13:35 <vincenz> and if h(a) = h(b)
18:13:40 <vincenz> just map em to the same element
18:13:43 <vincenz> but how to prove that
18:13:57 <vincenz> that htat g exists
18:14:58 <vincenz> I guess it's by defintion... domain = B ... all elements not reached by f ... just map em to some random C
18:15:02 <vincenz> however I can't prove that
18:15:04 <vincenz> in math
18:18:49 <Cale> what if there's no arrows B -> C at all?
18:19:54 <vincenz> well it's in sets
18:20:01 <vincenz> I assume all arrows exist
18:20:08 <Cale> oh, in sets, okay
18:20:10 <vincenz> It's not that detailed yet
18:20:19 <vincenz> so is it true? (I think yes) but I can't prove it
18:20:21 <vincenz> similarly
18:21:07 <vincenz> h : A -> C, g : B->C ... forall a in A . exists b in B s.t. h(a) = g(b) ...is there an f: A-B s.t. g*f=h?
18:21:10 <vincenz> I think yes as well
18:21:13 <Cale> well, yeah
18:21:15 <vincenz> but I can't prove it
18:21:43 <vincenz> how do I prove it?
18:21:59 * vincenz has no CS background so never saw sets or any of that :/
18:22:04 <Cale> Well, an arrow B -> C is a function, so we have to say where elements of B are being sent.
18:22:13 <vincenz> right
18:22:18 <vincenz> for the frst one it's easy
18:22:55 <vincenz> if f(a) = f(b)... Then g(f(a)) = h(a)... and it g(f(b)) will be h(b)
18:22:59 <vincenz> so it's fullfilled
18:23:11 <vincenz> err that's backward I guess?
18:23:29 <Cale> right, and if any point of B is not in the image of f, we can just send it anywhere
18:23:33 <vincenz> right
18:23:39 <vincenz> so is that enough?
18:23:40 <Cale> (we know that C is nonempty)
18:23:43 <vincenz> it doesn't feel "formal" enough
18:24:56 <vincenz> now the second question "choice"
18:25:01 <vincenz> same f, g, h
18:25:42 <vincenz> forall a:A . exists b:B. h(a) = g(b).... exists? f:A->B s.t h = g.f?
18:25:51 <Cale> Let b be an element of B. Then there are two cases: 1) b = f(a) for some a in A, or 2) b /= f(a) for any a in A. Case 1: Let g(b) = h(a).
18:26:17 <Cale> Note that this is well-defined
18:26:29 <vincenz> case 2: send anywhere
18:26:39 <Cale> since if f(a) = f(a'), then h(a) = h(a')
18:27:36 <vincenz> Cale: that was the starting condition
18:27:41 <Cale> right
18:27:44 <Cale> I'm using it
18:27:53 <vincenz> ah
18:28:08 <vincenz> but we have to start with that, not end with that?
18:28:14 <Cale> Well, okay
18:28:37 <vincenz> I just wonder when it's ok to say "function exists"
18:28:53 <Cale> We want to check that g(b) = h(a) will not result in g being ill-defined.
18:29:15 <Cale> g has to be a function, so we have to make sure that it sends any particular b to only one value in C.
18:29:19 <vincenz> right
18:29:46 <vincenz> (I mean I know it's intuitive, just trying ot see it "formally")
18:30:04 <Cale> Okay, suppose that f(a) = f(a') = b
18:30:15 <vincenz> then g(... = h(b)
18:30:20 <vincenz> for both
18:30:23 <vincenz> but these have to be the same
18:30:32 <Cale> right
18:30:33 <vincenz> cause f(a) = f('a) => ..
18:30:35 <vincenz> okies :)
18:30:47 <vincenz> now the secnod
18:30:52 <vincenz> forall a:A . exists b:B. h(a) = g(b).... exists? f:A->B s.t h = g.f?
18:30:59 <Cale> You can always get more formal, but I think this is good :)
18:31:26 <vincenz> oki :)
18:31:31 <Cale> sorry, is this a new problem?
18:31:33 <vincenz> yip
18:31:37 <vincenz> it's "choice"
18:31:39 <vincenz> define the f
18:31:39 * lispy puts on a tuxedo
18:31:40 <vincenz> not the g
18:31:49 <Cale> okay, so we just have two objects?
18:31:54 <vincenz> A, B,C
18:32:04 <vincenz> g:B->C
18:32:07 <vincenz> h:A->C
18:32:11 <vincenz> f?:A->B
18:32:24 <vincenz> same triangle
18:32:28 <vincenz> different missing func
18:32:57 <Cale> okay
18:33:24 <Cale> oh, certainly.
18:33:38 <vincenz> yeah, I feel it's there, just trying to formalize it
18:33:38 <Cale> Fix an a in A.
18:33:56 <Cale> We want to determine how to define f(a) in B.
18:33:59 <vincenz> right
18:34:11 <lispy> h(a) in C, and g^(-1)(h(a)) in B
18:34:23 <lispy> well, g^(-1)(h(a)) is a subset of B
18:34:25 <vincenz> lispy: you assume inverses
18:34:26 <Cale> Since a is in A, the condition applies to it, so there exists some b in B such that h(a) = g(b)
18:34:38 <lispy> vincenz: nope
18:34:39 <vincenz> and we map a -> b with f
18:34:42 <Cale> so let f(a) = b
18:35:04 <Cale> then g(f(a)) = g(b) = h(a)
18:35:04 <vincenz> this is unique... and spans A cause it's forall a
18:35:09 <Cale> so g . f = h
18:35:18 <vincenz> so it's welldefined?
18:35:22 <Cale> yeah
18:35:28 <vincenz> okies
18:35:31 <Cale> there's no problem with it being well-defined here
18:35:32 <lispy> so h and g are surjective?
18:35:36 <vincenz> I was trying to use equational reasoning
18:35:45 <vincenz> lispy: not perse
18:35:47 <Cale> lispy: no, not necessarily
18:36:07 <Cale> but the image of g contains the image of h
18:36:21 <lispy> how do you know b exists?  don't you need that?
18:36:33 <Cale> You know it by the condition we started with
18:36:34 <vincenz> lispy: forall a. exists b.s.t
18:36:35 <lispy> hmm
18:36:40 <vincenz> that's the given
18:36:43 <lispy> ah
18:36:46 <lispy> okay
18:36:51 <Cale> for all a in A there exists some b in B such that h(a) = g(b)
18:38:05 <Cale> basically, we're assuming here that we can construct functions by determining a logical rule for assigning values in the codomain to each of the values in the domain.
18:38:24 <vincenz> right
18:38:25 <Cale> This is actually valid in any sane set theory :)
18:38:29 <lispy> codomain = image or a superset of the image?
18:38:46 <Cale> the codomain is always a superset of the image
18:38:59 <Cale> well, superset or equal to
18:39:04 <lispy> of course
18:39:36 <lispy> under those definitions i agree with your proof
18:39:37 <lispy> ;)
18:39:47 <lispy> please carry on
18:39:55 * lispy wanders off again
18:40:01 <Cale> If I write f: R -> R, f(x) = x^2, then the image of f is {x | x >= 0}, and the codomain is just all of R.
18:40:30 <Cale> also known as the range
18:40:51 <lispy> yeah, it's just that when people talk about range/codomain/image i like to double check that we are on the same page about the meanings
18:41:09 <vincenz> range == image <= codomain
18:41:14 <Cale> right
18:42:24 <Cale> We're considering the codomain as an extra piece of information which is needed to talk about the function. So in some sense, functions aren't just sets of pairs, but sets of pairs together with a specific domain and codomain. (though the domain can be determined from the pairs)
18:43:29 <vincenz> right
18:43:49 <vincenz> I was thinking
18:43:57 <vincenz> you can think of set and set-mappings as a category
18:44:04 <Cale> right
18:44:06 <vincenz> each mapping maps elements of A to B
18:44:13 <vincenz> for some object(set) A and B
18:44:17 <Cale> right
18:44:19 <vincenz> now
18:44:27 <vincenz> what if you took the arrows from sets to sets
18:44:31 <vincenz> then your elements are the sets
18:44:35 <vincenz> and the objects are supersets
18:45:02 <Cale> um, hmm
18:45:08 <Cale> ?
18:45:14 <vincenz> set category
18:45:17 <vincenz> elements = elements of sets
18:45:18 <vincenz> objects = sets
18:45:22 <vincenz> superst category
18:45:24 <vincenz> elements = sets
18:45:26 <vincenz> objects = supersets
18:45:31 <Cale> sets only have sets as elements
18:45:43 <vincenz> well I assume "primitives"
18:45:48 <Cale> okay
18:45:49 <vincenz> a,b,c,..
18:46:01 <vincenz> tho I fail to see how this is true
18:46:06 <vincenz> cause for each superset to superset
18:46:07 <Cale> and sets are not permitted normally to contain other sets?
18:46:14 <vincenz> each element(set) has multiple arrows to other sets
18:46:33 <vincenz> if you take the super-arrows to be the collection of arrows of sets
18:46:35 <Cale> (normally in mathematics, the only thing sets really contain is other sets, or the empty set)
18:46:39 <vincenz> yeah
18:46:57 <vincenz> Set Theory :)
18:47:00 <vincenz> another course I never had
18:47:06 <Saulzar> What? No unboxed integers? :)
18:47:17 <vincenz> I need a pragmatic view
18:47:20 <vincenz> like unboxed integers
18:47:22 <vincenz> or characters
18:47:24 <vincenz> or symbols
18:47:34 <vincenz> those are the elements of sets in the set category
18:47:35 <Cale> well, all of those could be represented with sets :)
18:47:40 <vincenz> so how do you go from that category to the superset category
18:47:52 <vincenz> cause for each set At
18:47:55 <vincenz> there are many arrows
18:47:59 <vincenz> which is an illdefined function
18:48:30 <vincenz> let's reduce the scop
18:48:35 <Cale> Well, there are lots of categories you could be talking about...
18:48:42 <vincenz> category set:
18:48:46 <vincenz> two sets A and B
18:48:48 <vincenz> one of 2 elements
18:48:50 <vincenz> one of Three elements
18:48:55 <Cale> okay
18:48:57 <vincenz> you can think of many maps from A -> A
18:49:04 * rasterfar enjoying using xterm colour escape codes in my Show instances for the first time -- cool!
18:49:06 <vincenz> a -> B, B -> A, B->B
18:49:17 <Cale> vincenz: hm?
18:49:30 <vincenz> Cale: well you have many maps "arrows" in that category
18:49:33 <Cale> yeah
18:49:38 <vincenz> each arrow
18:49:47 <vincenz> maps an element of X to Y
18:49:49 <vincenz> for X -> Y
18:49:58 <vincenz> now take the superset category
18:50:18 <vincenz> so you map
18:50:28 <vincenz> {}, {A}, {A,B}, {B}
18:50:29 <vincenz> to one of those
18:50:46 <Cale> hmm
18:50:48 <vincenz> how do you define the arrows there in functio nof the arrows of the set category
18:51:12 <Cale> What are the objects in this category? Those you just listed?
18:51:16 <vincenz> yes
18:51:24 <Cale> well, there are a few ways
18:51:34 <Cale> you could define them as just the functions on those new sets
18:51:52 <vincenz> right but how do you "bundle" the arrows of the Set category to form arrows in the SuperSet category
18:51:58 <Cale> or you could take the union of each of those sets and talk about the functions between the results.
18:52:10 <Cale> well, in any way that you like
18:52:26 <Cale> as long as it satisfies the axioms of a category
18:52:59 <vincenz> hmm
18:53:17 <vincenz> so in the set category there are...let's see 27+4+8+9 arrows
18:53:32 <Cale> yeah
18:53:36 <vincenz> how many in the superset
18:53:49 <Cale> treated as part of the category of all sets?
18:54:12 <vincenz> of all sets containing the sets of the set category
18:54:50 <Cale> since they contain those sets as elements, the result doesn't depend on the contents of A and B
18:55:08 <vincenz> sure tehy do
18:55:08 <Cale> (unless you're defining the arrows some other way)
18:55:21 <vincenz> simpler example
18:55:26 <vincenz> Set category, only one object *1
18:55:28 <vincenz> Set category, only one object *1*
18:55:31 <vincenz> only one arrow
18:55:36 <vincenz> 1->1
18:55:40 <Cale> right
18:55:41 <vincenz> superset
18:55:45 <vincenz> {} {1} as objects
18:55:56 <vincenz> err too simple
18:56:02 <vincenz> let's do *2*
18:56:04 <vincenz> so four arrows
18:56:06 <Cale> are there any extra arrows?
18:56:18 <Cale> 2 is what?
18:56:24 <vincenz> set category, one object
18:56:25 <vincenz> *2*
18:56:28 <vincenz> a 2 element set
18:56:30 <Cale> okay
18:56:32 <vincenz> 4 arrows
18:56:36 <vincenz> SuperSet:
18:56:43 <vincenz> objects: {} {*2*]
18:56:51 <vincenz> so you have
18:56:54 <vincenz> {} -> {}
18:57:00 <vincenz> {} -> {*2*}
18:57:07 <vincenz> {*2*} -> {}
18:57:11 <vincenz> three arrows so far
18:57:16 <Cale> do you have an arrow {} -> {2}?
18:57:22 <vincenz> I guess
18:57:25 <Cale> okay
18:57:31 <vincenz> well that would be two arrows I guess
18:57:32 <Cale> I mean, you get to pick the arrows
18:57:33 <vincenz> const a and const b
18:57:37 <Cale> why const?
18:57:47 <vincenz> *2* = {a, b}
18:57:53 <vincenz> {} -> {*2*}
18:57:57 <vincenz> two arrows
18:58:01 <Cale> If you're thinking of arrows as set-functions, then there are no arrows from the empty set to any nonempty set.
18:58:05 <vincenz> {} ->{{a}}
18:58:18 <vincenz> {} ->{{}}
18:58:19 <vincenz> {} ->{{b}}
18:58:20 <vincenz> {} ->{{a,bb}}
18:58:26 <vincenz> I guess
18:58:37 <Cale> I'm confused :)
18:58:38 <vincenz> wait that can't be
18:58:43 <vincenz> {} -> {a,b}
18:58:50 <vincenz> {a,b} -> {a,b}
18:58:55 <vincenz> {a,b} -> {}
18:58:58 <Cale> okay, I don't know what your category is
18:59:03 <vincenz> {} -> {}
18:59:10 <Cale> could you give me a definition of an arrow in your new category?
18:59:14 <vincenz> category objects = {} and *2* or {a,b]
18:59:32 <vincenz> Cale: any arrow
18:59:40 <Cale> the objects don't tell you anything about the arrows
18:59:48 <vincenz> well all possible arrows
18:59:53 <vincenz> I can see 7
19:00:08 <vincenz> o wait
19:00:08 <Cale> "all possible arrows"?
19:00:11 <vincenz> yes
19:00:15 <vincenz> that you could define
19:00:17 <vincenz> but never mind
19:00:17 <Cale> the arrows are purely formal
19:00:22 <vincenz> there's only four
19:00:26 <Cale> here, let me give you a good example of a category
19:00:26 <vincenz> cause *2* -> *2*
19:00:30 <vincenz> must map 2 elements to 2 elements
19:00:33 <vincenz> there are many different kinds
19:00:34 <Cale> that should make things clearer
19:00:36 <vincenz> but they are effectively all the same
19:00:49 <Cale> this category has all the natural numbers as objects
19:01:04 <vincenz> right
19:01:09 <vincenz> many possible functions
19:01:15 <Cale> and the set of arrows n -> m is the set of linear maps R^n -> R^m
19:01:29 <vincenz> no but I see my problem
19:01:31 <Cale> that is, n by m matrices
19:01:31 <vincenz> see
19:01:38 <vincenz> when you go to the supercategor
19:01:42 <vincenz> N maps to N
19:01:44 <vincenz> you can do it in different way
19:01:47 <vincenz> but you only allow N
19:01:49 <vincenz> not subsets of N
19:02:00 <vincenz> so only isomorphic category mappings
19:02:04 <vincenz> but at a higher category level
19:02:06 <vincenz> they're all the same
19:02:09 <vincenz> they map full N to full N
19:02:23 <vincenz> how they do it is of little relevance
19:02:39 <vincenz> I was thinking they'd be different arrows in supercategory
19:02:41 <vincenz> but they're not
19:02:44 <vincenz> they map full N to full N
19:03:00 <vincenz> the internal mapping matters not
19:03:08 <vincenz> cause it's not a list, it's a set
19:03:11 <Cale> I'm still not clear what your supercategory is. The objects are the power set of the objects in your starting category
19:03:24 <Cale> but I don't know what your arrows are at all
19:03:32 <vincenz> base category
19:03:33 <Cale> and there's no obvious way
19:03:35 <vincenz> objects in N
19:03:36 <jethr0_> stupid hunit has the very bad habit of colliding with other modules' names regularly
19:03:37 <Cale> to determine them
19:03:41 <Saulzar> arrow == unique mapping?
19:03:45 <vincenz> super category
19:03:52 <vincenz> object = N
19:03:57 <vincenz> not subset of N
19:04:03 <vincenz> so there's only one arrow
19:04:08 <vincenz> even though
19:04:09 * Saulzar is tempted to find something on catagory theory, seems to come up almost as much as Haskell :)
19:04:17 <vincenz> you can think of many functions : N -> N
19:04:21 <vincenz> they all map a set N to a set N
19:04:25 <vincenz> so they're all iedentical
19:04:33 <vincenz> at the super category
19:04:46 <Cale> hehe, I still don't know what you're talking about :)
19:04:55 <vincenz> ok
19:05:05 <vincenz> base category, 2 objects
19:05:06 <vincenz> a, b
19:05:07 <Cale> When you define a category, you really have to say what your arrows are going to be
19:05:13 <Cale> exactly what they are
19:05:14 <vincenz> four arrows
19:05:25 <vincenz> a-> b, b->a, a->a,b->b
19:05:29 <Cale> okay
19:05:35 <vincenz> superset category
19:05:37 <vincenz> one object
19:05:39 <vincenz> {a,b}
19:05:44 <vincenz> so only one arrow
19:05:52 <Cale> why only 1?
19:05:57 <vincenz> only one object
19:06:03 <Cale> that's not necessary
19:06:05 <vincenz> the set {a,b}
19:06:23 <Cale> I can have a single object category with infinitely many arrows if I want.
19:06:31 <vincenz> they're the same
19:06:34 <Cale> no
19:06:40 <Cale> not necessarily
19:06:42 <vincenz> f({1,2}) = {1,2}
19:06:43 <vincenz> for all f
19:06:49 <Cale> oh
19:07:01 <Cale> hmm
19:07:07 <vincenz> but I wqs still thinking of the element mapping in the base level
19:07:10 <vincenz> but it does not matter
19:07:17 <vincenz> you only have two base functions that suffice this
19:07:18 <vincenz> namely
19:07:34 <vincenz> id or 'swap"
19:07:38 <vincenz> but at a the super level
19:07:40 <vincenz> they do the same
19:07:44 <vincenz> they map a full set to a full set
19:07:49 <vincenz> even though they internally do different thigns
19:08:14 <Cale> the internal changes can matter
19:08:25 <Cale> do you know about groups?
19:08:32 <vincenz> if you remind me
19:08:59 <Cale> Okay, a group G is a set, together with a binary operation * : G x G -> G such that:
19:09:20 <Cale> 1) there exists an e in G such that e * g = g * e = g for all g in G.
19:09:28 <vincenz> right
19:09:36 <vincenz> square matrices form a group
19:09:41 <Cale> 2) (a * b) * c = a * (b * c) for all a,b,c in G
19:09:50 <vincenz> square matrices of a distinct size that is
19:09:57 <Cale> 3) For all a in G, there exists b in G such that a * b = e
19:10:02 <vincenz> nm
19:10:04 <vincenz> then not
19:10:15 <vincenz> ok all invertible matrices are a group :)
19:10:18 <Cale> Square invertible matrices
19:10:20 <Cale> yeah
19:10:20 <vincenz> all matrices where det 1= 0
19:10:25 <vincenz> != even
19:10:33 <Cale> right
19:10:42 <vincenz> I learned groups and all that in the course on linear algebra
19:10:42 <Cale> that's called the general linear group
19:10:46 <vincenz> so it was all with matrices
19:10:49 <Cale> okay
19:10:53 <vincenz> but ok
19:10:54 <vincenz> I remember now
19:11:02 <Cale> we can take any group and turn it into a 1-object category
19:11:10 <vincenz> right
19:11:19 <Cale> which encodes all that group structure
19:11:35 <vincenz> <R,+>
19:11:37 <Cale> You have a single object X, and as arrows, you take the elements of G
19:11:53 <Cale> and composition is defined by multiplication in G.
19:11:59 <vincenz> Cale: ah
19:12:05 <vincenz> Cale: but then you also allow as objects the elements of G
19:12:10 <Cale> no
19:12:12 <vincenz> hmm
19:12:16 <Cale> (you could, but I'm not)
19:12:24 <vincenz> hmm
19:12:32 <Cale> There's only one object, but lots of arrows
19:12:40 <vincenz> so G -2> G
19:12:47 <Cale> hm?
19:12:48 <vincenz> multiple all elements by 2
19:12:52 <vincenz> - 2 ->
19:13:10 <Cale> ah, for that group you gave above?
19:13:13 <vincenz> yeah
19:13:16 <vincenz> R,*
19:13:19 <Cale> (R,+) is a group homomorphism
19:13:22 <Cale> er
19:13:24 <Cale> (R,+) is a group
19:13:29 <vincenz> right
19:13:30 <vincenz> in that case
19:13:32 <Cale> and multiplication by 2 is a group hom
19:13:43 <vincenz> it's multiplication or addition in this case?
19:13:45 <Cale> and that turns into an endofunctor on our new category
19:13:50 <Cale> addition
19:13:56 <vincenz> so - 2 -> 
19:14:00 <vincenz> addition by 2
19:14:03 <vincenz> for group R,+
19:14:06 <vincenz> not multiplication
19:14:08 <Cale> addition by 2 isn't a hom
19:14:27 <Cale> because homomorphisms have to fix the identity element
19:14:31 <vincenz> ah
19:14:32 <vincenz> right
19:14:36 <vincenz> but
19:14:38 <vincenz> given the G
19:14:44 <vincenz> I could define arrows to be - e ->
19:14:48 <vincenz> such that it does + 2
19:14:52 <Cale> oh, sure
19:14:56 <vincenz> just not homomorphic arrows
19:15:02 <vincenz> but!
19:15:07 <vincenz> aren't they effectively all the same arrow
19:15:11 <Cale> no
19:15:11 <vincenz> cause they map G to G
19:15:14 <vincenz> the elements are the same
19:15:17 <Cale> no, that doesn't matter
19:15:27 <vincenz> but
19:15:30 <vincenz> 2(G) = G
19:16:04 <Cale> \x -> x + 1 and \x -> x + 2 are both valid maps R -> R
19:16:08 <vincenz> right
19:16:11 <Cale> but that doesn't make them the same function
19:16:12 <vincenz> but if the object is R
19:16:18 <vincenz> they both map the entire R to the entire R
19:16:21 <Cale> sure
19:16:29 <Cale> but they're still different
19:16:29 <vincenz> ah, but this is only if we consider "set" objects
19:16:31 <vincenz> not group
19:16:43 <vincenz> Cale: afaik, it told me that you should look at arrows from an external perspective
19:16:48 <vincenz> so says the book
19:17:08 <Cale> right, but that doesn't mean that there's only one arrow between any two objects
19:17:09 <vincenz> (multiplying by 1/2 and dividing by 2 are both specific "rules", but they dfine the same arrow)
19:17:19 <Cale> no they don't
19:17:33 <vincenz> that's what it told me about arrows
19:17:33 <Cale> (not usually, anyway)
19:17:37 <Cale> okay, that's odd
19:17:41 <vincenz> just look at input output behaviour at theobject levle
19:18:00 <Cale> yeah, that's not true at all
19:18:18 <Cale> You can have distinct arrows between the same domain and codomain
19:18:18 <vincenz> hmm
19:18:21 <vincenz> right
19:18:24 <vincenz> oh right
19:18:27 <dons> does this graph mean that hugs has few bugs? http://dir.gmane.org/gmane.comp.lang.haskell.hugs.bugs
19:18:27 <vincenz> but now ifyou go to the supercategory
19:18:35 <vincenz> where your object is {G}
19:18:41 <vincenz> so the singleton set of G
19:18:43 <Cale> and your arrows are what?
19:18:43 <dons> but ghc is gaining bugs? http://dir.gmane.org/gmane.comp.lang.haskell.glasgow.bugs
19:18:45 <vincenz> call it A
19:18:50 <vincenz> A -> A
19:19:00 <vincenz> then ther's only one
19:19:02 <Cale> see, we could choose the arrows to be anything
19:19:03 <vincenz> cause if you step one down
19:19:10 <vincenz> the element(s) is G
19:19:21 <vincenz> instead
19:19:23 <vincenz> if G is your object
19:19:26 <vincenz> then if you step one down
19:19:31 <vincenz> your element is for instance R
19:19:35 <vincenz> I mean all values in R
19:19:52 <Cale> okay, I see what you're saying
19:19:52 <vincenz> I guess I shouldn't stick to 'step one level down'
19:20:03 <Cale> but that isn't always available
19:20:19 <Cale> and what constitutes an arrow is not always a function
19:20:35 <vincenz> it has the same limitations
19:20:44 <vincenz> it's contrasurjective and contrainjective
19:20:52 <Cale> another example... take as objects all sets, and take as arrows only the identity arrows
19:20:58 <vincenz> right
19:21:08 <vincenz> #sets = #objects
19:21:10 <vincenz> err
19:21:14 <Cale> that's a boring category, but it's still a category
19:21:14 <vincenz> #arrow = #objects
19:21:23 <Cale> yeah, sort of :)
19:21:32 <Cale> though you might not be able to count them :)
19:21:35 <vincenz> yeah
19:21:43 <Cale> (even with infinite cardinals)
19:21:43 <vincenz> well |arrow| = |object|
19:21:45 <vincenz> that is correct
19:21:50 <Cale> hm?
19:21:56 <vincenz> Cale: depends if you use cantor or not
19:22:04 <Cale> are you saying that the number of arrows is equal to the number of objects?
19:22:10 <vincenz> cantor sets are infinitely countable
19:22:12 <vincenz> Cale: yes
19:22:29 <Cale> that's only true in my funky category
19:22:38 <vincenz> how are sets not infinitely ocuntable
19:22:43 <vincenz> sets have to be made by construction
19:22:47 <vincenz> otherwise you get sets like
19:22:52 <vincenz> {X | X not elofX}
19:23:02 <vincenz> and if you make em by construction you can count em
19:23:18 <Cale> Suppose there was some cardinal which was in bijection with the class of all sets
19:23:24 <vincenz> yes
19:23:30 <vincenz> Cale: wait
19:23:31 <vincenz> define sets
19:23:32 <vincenz> cantor sets
19:23:36 <vincenz> or even the illegal ones?
19:23:46 <Cale> Sets according to ZFC
19:23:50 <vincenz> right
19:24:02 <Cale> http://mathworld.wolfram.com/Zermelo-FraenkelAxioms.html
19:24:05 <vincenz> yeah
19:24:09 <vincenz> contructive sets
19:24:15 <vincenz> I read the postulate by...What his name
19:24:18 <vincenz> not cantor but...
19:24:21 <Cale> constructive sets are something else
19:24:32 <vincenz> they are?
19:24:40 <vincenz> hmm
19:24:48 <vincenz> who was that guy again
19:24:54 <vincenz> damn I could say his name  a million times
19:24:57 <Cale> Well, there are sets here where it's undecidable whether some element is contained in them.
19:25:05 <Cale> (formally undecidable)
19:25:12 <vincenz> philosopher/mathematician
19:25:26 <vincenz> he discovered undecidable sets
19:25:38 <Cale> Russel
19:25:42 <vincenz> RIGHT!
19:25:53 <Cale> Russel discovered paradoxical sets
19:26:04 <vincenz> and cantor made the logic to bypass it
19:26:18 <vincenz> sorry about all the spam :/
19:26:22 <vincenz> I hope I'm not taking your time
19:26:24 <vincenz> anyways
19:26:28 <vincenz> cantor sets are infinitely countable
19:26:31 <Cale> it's okay
19:26:40 <Cale> Cantor did some work on infinite sets
19:26:55 <Cale> he wasn't responsible for really formalising things, afaik
19:27:00 <vincenz> ah
19:27:08 <vincenz> bertrand russell
19:27:10 <vincenz> :)
19:27:21 <vincenz> great philosopher
19:27:22 <vincenz> but ocntinue
19:27:24 <jethr0_> well, the diagonalization argument comes from cantor, doesn't it?
19:27:24 <vincenz> sorry for the interlude
19:27:35 <Cale> jethr0_: yeah
19:27:49 <Cale> the diagonalisation argument which I was about to use
19:27:56 <jethr0_> :)
19:28:00 <vincenz> I vaguely remember it
19:28:39 <Cale> Okay, so we say that card A <= card B if there exists an injective function A -> B
19:28:54 <Cale> "card" stands for "cardinality"
19:28:55 <vincenz> right
19:29:00 <vincenz> |A| <= |B|
19:29:18 <vincenz> injective : f(a) = f(b) => a =b
19:29:27 <vincenz> ok
19:29:49 <Cale> and we say that card A = card B when there is a bijective function A -> B
19:29:53 <vincenz> right
19:30:17 <Cale> and it can be shown that card A <= card B and card B <= card A together imply that card A = card B
19:30:18 <vincenz> f(a) != f(b) => a !=b => |a| = |b&
19:30:27 <Cale> hm?
19:30:41 <vincenz> f(a) != f(b) => a !=b => |A| = |B|
19:30:46 <Cale> no
19:30:47 <vincenz> f:a->b
19:30:51 <vincenz> f:A->B
19:31:00 <vincenz> whoops
19:31:08 <vincenz> f(a) != f(b) => a !=b => |A| => |B|
19:31:11 <vincenz> and injective is <=
19:31:14 <vincenz> so bijective is =
19:31:15 <Cale> A bijective function is a function which is both injective and surjective
19:31:30 <vincenz> yes
19:31:38 <vincenz> I was just mentally typoing
19:31:42 <vincenz> I'm with you
19:31:47 <Cale> surjective means that for all elements b of the codomain, there is some element a of the domain such that f(a) = b
19:31:55 <Cale> okay
19:32:30 <Cale> If we have a set A, then the power set of A, denoted 2^A (or sometimes P(A)) is the set of all subsets of A.
19:32:38 <vincenz> yep
19:32:40 <lambdabot> Issue 24 of the Haskell Weekly News is out: http://sequence.complete.org/
19:33:16 <Cale> It can be shown that card A <= card 2^A fairly easily, but also card A is never equal to card 2^A
19:33:32 <vincenz> ok
19:33:33 <Cale> even if A is an infinite set
19:33:52 <Pseudonym> Which shows that data A = A (A -> Bool) doesn't have any meaning if you assume that types are modelled by sets.
19:34:14 <vincenz> Pseudonym: o.O
19:34:39 <Pseudonym> Well, you're looking for an isomorphism between A and A -> Bool
19:34:41 <Cale> okay, so suppose that the class of all sets was itself somehow a set, then it would have some cardinality
19:34:43 <Pseudonym> That's impossible if A is a set.
19:34:51 <Cale> but then its powerset would have greater cardinality
19:34:58 <Pseudonym> That's why A is _not_ a set.
19:35:03 <vincenz> Cale: right
19:35:09 <Cale> which is a contradiction
19:35:21 <vincenz> it's just a bigger infinite
19:35:25 <Cale> because every set is already in it
19:35:32 <vincenz> og!
19:35:35 <vincenz> oh! even
19:35:41 <vincenz> Cale: right, but this is not allowed by constructive sets
19:35:45 <vincenz> cause you can't have X elof X
19:35:50 <vincenz> except as fixpoint
19:35:56 <Cale> well, that's also true
19:36:06 <vincenz> (even the last part of fixpoint?)
19:36:07 <Cale> it's not permitted by ZFC
19:36:13 <Cale> fixpoint?
19:36:19 <Pseudonym> This is ALSO why when you add the fixpoint operator to a typed lambda calculus, it becomes inconsistent.
19:36:21 <Cale> X is never a member of X
19:36:21 <vincenz> by going to infinite
19:36:30 <vincenz> Cale: even not for X approach infinity?
19:36:38 <Cale> that doesn't mean anything :)
19:36:49 <vincenz> well keep constructing at infinitu
19:36:49 <Pseudonym> Because, as you say, allowing all fixpoints means you get to construct things like X \in X.
19:37:13 <Cale> in ZFC we have the following axiom:
19:37:14 <vincenz> Pseudonym: so...coming back to your statement
19:37:25 <vincenz> A (A-> Bool)
19:37:28 <Pseudonym> The fixpoint operator is isomorphic to Russell's paradox under Curry-Howard.
19:37:30 <vincenz> how *do* you model that
19:37:37 <Pseudonym> You don't use sets.
19:37:40 <vincenz> then what?
19:37:41 <Pseudonym> You use things with more structure.
19:37:51 <Cale> for all S, if S is not the empty set, then there exists an x in S such that S intersect x is empty.
19:38:09 <foxy> I'm trying to make install GHC from darcs on Win98 and I get an error when trying to install helper tools (like gcc, ld, as,dlltool, perl, etc.) from ghc directory.  I can't find any of these tools in the repo directories, so I assume that the build was using copies already on my system.  Could someone please help me by telling how to rectify this situation.  Following is an example error:
19:38:11 <foxy>   cp -rp ./../lib/gcc-lib/mingw32/3.4.2/* /usr/local/ghc/gcc-lib
19:38:12 <Cale> that's called the axiom of foundation
19:38:13 <foxy>   cp: cannot stat `./../lib/gcc-lib/mingw32/3.4.2/*': No such file or directory
19:38:14 <foxy>   make: [install] Error 1 (ignored)
19:38:29 <Pseudonym> Obviously whatever you do use needs exponents like 2^A.
19:38:37 <Pseudonym> But all Cartesian closed categories do.
19:38:42 <Pseudonym> Sets are but one example.
19:38:48 * vincenz will read more on categories then :)
19:38:53 <vincenz> I4m reading Lawvere
19:38:56 <Pseudonym> Yup. :-)
19:39:04 <vincenz> "Conceptual MAthematics - A first introduction to categories"
19:39:11 <vincenz> I find it more grokkable than the one by Pierce
19:39:12 <Pseudonym> There's a whole chapter on this in Asperti and Longo.
19:39:16 <vincenz> Pierce was rather terse
19:39:33 <vincenz> and I also have Mac  Lane
19:39:35 <Pseudonym> After that, go for Barr and Wells.
19:39:36 <vincenz> but I'll keep that for after Lawvere
19:39:46 <Pseudonym> Mac Lane is nice if you know some topology.
19:39:47 <Pseudonym> Which I don't.
19:39:52 <vincenz> Pseudonym: lawvere is good?
19:40:03 <Pseudonym> Yeah, I thought so.
19:40:12 <Pseudonym> It's simple, but it's so damn easy to read.
19:40:21 <vincenz> yeah
19:40:25 <vincenz> it's a good newbie course
19:40:28 <vincenz> with lots of redundancy
19:40:29 <Pseudonym> It's even, dare I say it, fun to read.
19:40:34 <vincenz> too bad the excercises aren't posted
19:40:34 <Cale> It's quite a problem that there are suddenly all these nonmathematicians wanting information about category theory, since until recently, the only people who cared about CT had at least a full undergrad degree's worth of algebra and topology to provide examples :)
19:40:46 <vincenz> Cale: well all haskell typing papers use categories
19:40:50 <vincenz> of which I understand nothing
19:40:52 <Cale> (so the books tend to assume lots)
19:40:56 <vincenz> Cale: btw, I have a paper that might interest you
19:41:09 <Pseudonym> I have a book planned out entitled "Abstract Nonsense: Category Theory for the Armchair Computer Scientist".
19:41:23 <Pseudonym> I think it needs to be written.
19:42:27 <Pseudonym> The target audience is someone who did a computer science degree some time ago.
19:42:48 <vincenz> http://abstractoasis.dyndns.org:8080/boute.pdf
19:43:01 <vincenz> Pseudonym: the one by pierce was really terse
19:43:05 <vincenz> Pseudonym: I got nothing out of it
19:43:24 <vincenz> Cale: check that link
19:43:32 <vincenz> so what's good about barr and wells?
19:43:49 <Pseudonym> It's terse enough, yet not too terse.
19:43:54 <Pseudonym> I find it a good second book.
19:43:56 <vincenz> but what's new?
19:44:08 <Pseudonym> BTW, I haven't read that Pierce book, but I thought TaPL was fabulous.
19:44:15 <vincenz> yeah
19:44:17 <Pseudonym> So I know he can write well.
19:44:20 <vincenz> but his category book is less than 100 pages
19:44:25 <vincenz> it's like a soft cover, coarsegrained booklet
19:44:28 <Pseudonym> Haven't read ATTaPL.;
19:44:32 <vincenz> nor I
19:44:33 <vincenz> don't have it
19:44:46 <vincenz> but it seems to tackle problems too specific for my taste
19:44:47 <Pseudonym> Nor do I, but I work at a university, which has a great library.
19:44:51 <vincenz> liked typed assemby language
19:44:58 * vincenz has a lib of his own
19:45:15 <Pseudonym> My copy of Asperti and Longo is probably technically stolen.
19:45:17 <vincenz> barr and wells = book or downloadable pdf?
19:45:25 <Pseudonym> Book.
19:45:34 <vincenz> and asperti longo, needed lecture too?
19:45:47 <vincenz> it's a pdf
19:45:49 <vincenz> that one :)
19:45:51 <Pseudonym> Asperti and Longo is available as a download.
19:46:17 <Pseudonym> http://www.let.uu.nl/esslli/Courses/barr-wells.html
19:46:26 <Pseudonym> There are the lecture notes which are very similar to the book.
19:47:43 <vincenz> woah
19:47:49 <vincenz> asperti longo book has same name as the one by pierce
19:47:57 <Pseudonym> Huh>?
19:48:15 <Pseudonym> "Categories, Types and Structures: An Introduction to Category Theory for the Working Computer Scientist"
19:48:16 <vincenz> http://www.amazon.com/gp/product/0262660717/sr=8-1/qid=1139888852/ref=sr_1_1/002-9822603-6496809?%5Fencoding=UTF8
19:48:39 <Pseudonym> http://www.di.ens.fr/~longo/download.html
19:48:40 <Pseudonym> Top one.
19:48:50 <vincenz> got it
19:49:35 <Pseudonym> The book isn't bad, but it goes by pretty quickly.
19:49:48 <vincenz> I have too many pdfs and books that I still have to read :/
19:49:50 <Pseudonym> You'd be better off with Barr and Wells first, I think.
19:50:09 <vincenz> okies
19:51:15 <vincenz> he
19:51:16 <vincenz> heh
19:51:20 <vincenz> 664 pdfs in my Oasis/Dox
19:51:26 <vincenz> and several books still to read o.O
19:51:38 <vincenz> I even have trouble categorizing my pdfs
19:51:45 <vincenz> 58 uncategorized
19:51:55 <vincenz> Cale: checked the link?
19:52:24 <vincenz> Pseudonym: what's diff between book and lecture notes?
19:54:54 <Pseudonym> No idea.
19:55:01 <Pseudonym> Sorry, haven't read them bost.
19:55:04 <Pseudonym> both
19:55:24 <vincenz> ok
19:55:31 <vincenz> is category theory useful?
19:55:35 <vincenz> can you use it for something
19:55:38 <vincenz> to deduct something new?
19:56:08 <gzl> sure
19:56:34 <vincenz> for instance?
19:56:51 <gzl> you just want me to cite a theorem in category theory?
19:56:55 <gzl> the Yoneda Lemma
19:57:21 <vincenz> I meant in an applied context
19:57:27 <gzl> what do you consider applied?
19:57:35 <vincenz> not pure categories
19:57:38 <gzl> you use theorems like this to prove results outside category theory
19:57:52 <vincenz> so what do you use category theory for
19:58:26 <gzl> in fields like algebraic topology and algebraic geometry, categories provide the right language for expressing what's going on
19:58:38 <vincenz> ah
19:58:42 <vincenz> it's just that
19:58:47 <vincenz> often it seems very broad
19:58:56 <vincenz> I just wondered if anyone ever described a system in category
19:58:59 <gzl> well, it's a very general theory, so that's going to be the case
19:59:04 <gzl> described a system in category?
19:59:06 <vincenz> and this led him to discover things about a similar system
19:59:07 <Pseudonym> Category theory is most useful as a language (provider of vocabulary) and as a way of thinking.
19:59:50 <gzl> what Pseudonym said, but it's also the case that theorems from "pure category theory" get used very frequently to show non-category theoretic results
19:59:53 <vincenz> cause if you have just a modelling language without extrapolated reasoning abilities...
19:59:55 <gzl> especially in those two fields I named
19:59:59 <gzl> it's not a modelling language
20:00:10 <Pseudonym> It turns up all the time in Haskell.
20:00:13 <vincenz> oki
20:00:19 <vincenz> but only typesystems
20:00:33 <Pseudonym> No, in the programming part too.
20:00:37 <vincenz> oh
20:00:41 <Pseudonym> Terms like "functor", "monad" etc.
20:00:46 <Pseudonym> All straight from category theory.
20:00:59 <vincenz> I was just curious if you take your current problem, forumate it into category theory, you can somehow get to a solutoin
20:01:03 <vincenz> if that makes sense
20:01:03 <gzl> you have to understand to some degree that if you want to see a convincing application of category theory you're going to need a basic understanding of category theory as well as the ability to understand the problem domain.
20:01:07 <gzl> yes, you can
20:01:15 <vincenz> oki :)
20:01:20 <vincenz> then I'll continue reading
20:01:20 <vincenz> btw
20:01:24 <vincenz> gzl: what do you do?
20:01:25 <gzl> and in algebraic * you do this quite often
20:01:51 <gzl> I'm a professional do-nothinger (student)
20:02:20 <vincenz> in what field
20:02:38 <gzl> math and computer science
20:04:12 <gzl> another thing it can help with is generalization
20:04:20 <Pseudonym> That's also its weakness.
20:04:27 <Pseudonym> It's hard to understand stuff which is so abstract.
20:05:30 <gzl> though it is, there are also situations where you don't need to. if you can prove categorically that some method works in all categories of some type, you can then apply the method in a bunch of specific instances without having to go nuts trying to understand the general thing.
20:05:38 <gzl> but of course you're right
20:05:41 <Pseudonym> Ues.
20:05:58 <Pseudonym> Oh, once you've gotten the abstract concept, it simplifies so many things.
20:06:15 <Pseudonym> BTW, to truly understand category theory, you have to realise where it sits in the history of maths.
20:06:33 <Pseudonym> The late 19th/early 20th century was all about finding the limits of maths.
20:06:41 <Pseudonym> Here's something you definitely can't do.
20:06:47 <Pseudonym> e.g. Goedel, Turing etc
20:06:57 <Pseudonym> The Hilbert programme, sort of thing.
20:07:23 <gzl> that said, it originally came out of algebraic topology, not foundations
20:07:27 <Pseudonym> The late 20th/early 21st century is about showing that the situation isn't such bad.
20:07:29 <vincenz> hmm
20:07:31 <Pseudonym> isnt' so bad
20:07:50 <Pseudonym> That many disparate areas of maths are, in fact, the same if you ignore all the irrelevant details.
20:07:52 <gzl> one example of categorical generalization I really like is Galois theory
20:08:11 <Pseudonym> The classic example is the Taniyama-Shimura conjecture, aka Weil's Theorem.
20:08:21 <gzl> Weil's Theorem?
20:08:36 <gzl> Wiles
20:08:40 <Pseudonym> Right.
20:08:41 <Pseudonym> Wiles.
20:08:43 <Pseudonym> Duh.
20:08:45 <gzl> :)
20:08:45 <Pseudonym> Need caffeine.
20:08:47 <Pseudonym> Anyway.
20:09:07 <Pseudonym> Proof that two completely different areas of maths are, in fact, related in deep ways.
20:09:12 <vincenz> oh?
20:09:22 <Pseudonym> And this is where category theoryu comes in.
20:09:22 <vincenz> did you check the boute pdf?
20:09:25 <vincenz> it might interest you
20:09:28 <gzl> well, same situation with galois theory
20:09:32 <Pseudonym> Right.
20:09:50 <Pseudonym> The Langlands programme is the modern-day Hilbert programme.
20:10:15 <gzl> which Hilbert program? the problems or formalism?
20:11:26 <Pseudonym> The problems.  They were a kind of manifesto.
20:12:25 <vincenz> 5AM
20:12:27 <vincenz> I'm hitting the sak
20:12:29 <vincenz> sack
20:12:31 <vincenz> was up since 6Am
20:12:37 <vincenz> at the office between 8Am an 9pm
20:12:48 <gzl> Pseudonym: yeah
20:12:51 <vincenz> thx for all the info and teaching :
20:12:54 <vincenz> :
20:12:57 <vincenz> :)
20:13:07 <gzl> just wondering because the formalism stuff is also referred to as Hilbert's program :)
20:13:38 <Pseudonym> Well, yes.
20:13:45 <Pseudonym> The programme is inherent int he problems.
20:13:57 <Pseudonym> The manifesto was, basically: Maths can be mechanical.
20:14:10 <Pseudonym> It just needs to be put on the right footint.
20:14:12 <gzl> yeah, but what does that part have to do with Langlands?
20:14:13 <Pseudonym> footing
20:14:26 <Pseudonym> Well, the Langlands programme is also a manifesto of sorts.
20:14:46 <gzl> I thought you were saying that they were the same in the sense that Langlands is a series of conjectures about connections between various fields
20:14:51 <palomer> anyone got a link?
20:14:53 <gzl> and as such it directs research
20:15:00 <Pseudonym> Well, that's true.
20:15:14 <gzl> in the similar way that Hilbert's problems did
20:15:16 <Pseudonym> But Langlands is a series of conjectures that states that different areas of maths are deeply connected.
20:15:18 <gzl> * 
20:15:33 <gzl> sure, but there's nothing about this mechanical stuff
20:15:37 <Pseudonym> No.
20:15:43 <Pseudonym> Because that's all been resolved.
20:15:47 <Pseudonym> By Goedel, Turing etc.
20:15:50 <gzl> right.
20:15:59 <gzl> I'm just trying to figure out what comparison you're trying to draw. :)
20:16:23 <gzl> maybe I'm just being dense and missing the obvious, though
20:16:30 <gzl> palomer: to?
20:16:39 <palomer> langlands programme
20:16:42 <palomer> found it
20:16:51 <palomer> btw, gzl is a huge math wonk
20:16:56 <palomer> watch out when you talk math with him
20:17:07 <Pseudonym> The point I'm making is that the over-arching goal of modern maths is to show that the fact that Hilbert's foundations aren't complete, consistent whatever isn't really that much of a problem.
20:17:15 <Pseudonym> OK, not "the" goal.
20:17:22 <Pseudonym> But the undercurrent is there.
20:17:45 <Pseudonym> The Curry-Howard isomorphism, and other things like it, are a good example.
20:17:56 <Pseudonym> Yeah, maybe logic is incomplete.  But it's the same as type theory.
20:17:58 <palomer> C-H is crap.
20:18:10 <Pseudonym> And THAT is significant.
20:18:19 <gzl> why is that significant?
20:18:37 <gzl> I mean, why is it less bad that logic is incomplete just because type theory is also incomplete?
20:18:45 <Pseudonym> It's significant because even if you can't solve a problem mechanically, you may be able to transport it over into some other area of maths where it's easier to solve.
20:19:17 <gzl> well, only if you're not dealing with one of those problems you can't solve at all
20:19:27 <Pseudonym> I know that.
20:19:51 <Pseudonym> My point is that even though maths has its limits, it's also a unified whole in ways that we can't even conceive of yet
20:19:51 <gzl> I know you know. :)
20:19:58 <gzl> ah, ok. that's fair.
20:20:03 <Pseudonym> Right.
20:20:08 <Pseudonym> And THAT is where maths is going right now.
20:20:16 <gzl> yeah
20:21:05 <Pseudonym> There might be a day when if I'm having trouble coming up with a new type extension for Haskell'''', it might be easier to look at it as a differential geometry problem.
20:21:27 <gzl> on the one hand, that's pretty cool
20:21:37 <gzl> on the other, now you have to know differential geometry to write your type extension
20:21:41 <palomer> just because there are true statements which are unprovable, I don't think that makes math "incomplete"
20:21:45 <Pseudonym> Well, yes. :-)
20:22:03 <Pseudonym> palomer: That's what "incomplete" means in this context.
20:22:18 <Pseudonym> It is precisely the property whereby any true statement is provable.
20:22:26 <gzl> I think it's pretty neat that these kinds of connections actually work, but at the same time, I think it makes some things harder
20:22:29 <Pseudonym> Er... that's "complete".
20:22:47 <Pseudonym> And on the other hand, it may make some things easier.
20:22:50 <gzl> just from the point of view of the range of material that one needs to be familiar with to be able to work properly
20:22:53 <Pseudonym> You said so yourself of category theoryl;
20:23:06 <palomer> I'm simply objecting to the use of the word math in "math is incomplete"
20:23:09 <Pseudonym> The other handy thing is you might get theorems for free, so to speak.
20:23:23 <palomer> gzl: are you objecting to category theory?
20:23:27 <gzl> no
20:23:30 <Pseudonym> palomer: The correct statement is, "any sufficiently powerful formalism is incomplete".
20:23:31 <palomer> because I'd like to object to category theory
20:23:36 <gzl> I rather like it
20:23:43 <Pseudonym> i.e. if it's complete, it's insufficiently powerful
20:23:59 <palomer> Pseudonym: even then, I think you're being a little vague
20:24:06 <Pseudonym> But you're right in a sense.  By this definition, Euclidean geometry is insufficiently powerful.
20:24:17 <Pseudonym> And it is.  You can't square the circle, for example. :-)
20:24:24 <palomer> anyways, I don't think I'll ever get over my objection to category theory
20:24:34 <palomer> which is that it only models useless aspects of our theories
20:24:45 <Pseudonym> I disagree about that.
20:24:53 <gzl> huh?
20:25:13 <gzl> I don't even understand that.
20:25:35 <palomer> a theory is a set of non contradictory sentences (in some language, in some logical framework)
20:25:35 <Pseudonym> My favourite example is the Conor McBride paper, where he showed that a zipper data structure is the derivative of a functor.
20:25:44 <Pseudonym> That's damned useful.
20:25:47 <Pseudonym> I've used it myself.
20:25:49 <gzl> what's a derivative of a functor?
20:25:59 <gzl> oh, in the sense of derived functors?
20:26:02 <Pseudonym> Do you know what the zipper is?
20:26:06 <gzl> no, I don't.
20:26:16 <Pseudonym> Ah.
20:26:21 <Pseudonym> Let me give you an example.
20:26:27 <Pseudonym> A list zipper is a pair of lsits.
20:26:28 <Pseudonym> lists
20:26:40 <Pseudonym> data ListZipper a = ListZipper [a] [a]
20:26:53 <gzl> ok
20:26:56 <Pseudonym> What that is, is a list with a "finger" pointing to one element.
20:27:09 <Pseudonym> You can think of one list as what's "left" and the other as what's "right" of the element.
20:27:24 <gzl> ok
20:27:28 <Pseudonym> So, for example, suppose you had [1,2,3,4,5]
20:27:33 <Pseudonym> You could represent the element 3 as:
20:27:39 <Pseudonym> data ListZipper [2,1] [3,4,5]
20:27:56 <Pseudonym> You move left and right across the list by popping data off the front of one list and pushing it on the other.
20:28:17 <gzl> ok
20:28:29 <Pseudonym> This is invaluable in Haskell, because it lets you modify internal parts of data structures in a pure functional way.
20:28:36 <Pseudonym> OK?
20:28:40 <Pseudonym> @wiki TheZipper
20:28:40 <lambdabot> http://www.haskell.org/hawiki/TheZipper
20:28:42 <Pseudonym> More details there.
20:28:44 <Pseudonym> Anyway.;
20:28:52 <gzl> I was with you until the invaluable bit
20:28:54 <Pseudonym> What he showed is how to derive zippers from normal Data structures.
20:28:59 <gzl> but I'll check out the link
20:29:18 <Pseudonym> List a = () + (a * (List a))
20:29:48 <Pseudonym> Hang onj.
20:30:00 <Pseudonym> List(a) = 1 + (a * List(a))
20:30:02 <Pseudonym> There we go.
20:30:18 <Pseudonym> 1 is the terminal object, + is category sum and * is category product.
20:30:44 <gzl> hm. ok
20:30:59 <Pseudonym> Now the zipper version of this is just the symbolic derivative:
20:31:23 <Pseudonym> List'(a) = 0 + (() * (List a)) + (a * List'(a))
20:31:40 <Pseudonym> Which, if you work it out, is isomorphic to (List a)*(List a).
20:32:26 <Pseudonym> It's a rather beautiful practical application of the theory.
20:36:03 <palomer> category theory is great, if you don't care about proving meaningful things
20:36:17 <Pseudonym> Hang on, isn't this precise example meaningful?
20:36:44 <palomer> how is it meaningful?
20:37:03 <Pseudonym> That sounds like a philosophical question.
20:37:12 <Pseudonym> It's certainly useful.
20:37:21 <palomer> err, give me the language and the model
20:37:27 <palomer> and the statement
20:37:39 <gzl> I don't even understand how you can look at the huge amount of meaningful stuff proved with categories outside computer science and claim that categories are only used to prove meaningless things
20:37:40 <Pseudonym> It's a result in haskell.
20:38:05 <palomer> gzl: ok, it's mostly meaningless
20:38:08 <Pseudonym> Using this theorem, you can make zipper data structures.
20:38:11 <palomer> some of it isn't
20:38:11 <gzl> I also fail to understand why everything has to be turned into formal logic
20:38:25 <Pseudonym> Because that's the only way you can meta-reason about it.
20:38:33 <palomer> gzl: it's our only common ground, it gives meaning
20:38:39 <Pseudonym> You can get through life using only Aristotelian syllogisms.
20:38:54 <Pseudonym> But you can't ask if it's consistent or not.
20:39:02 <palomer> well, you can't survive without a specific language to make your statements in
20:39:07 <palomer> and then you need to interpret your statements
20:39:15 <gzl> I don't really want to meta-reason about it. I just want to make the point that you can prove a lot of useful stuff with it, and you don't need any logic for that at all.
20:39:18 <Pseudonym> And more to the point, a constructive proof is a computer program.
20:39:30 <Pseudonym> And THAT'S useful.
20:39:31 <palomer> an integer is a computer program
20:39:59 <palomer> without a language and interpretation all you have is hand-waving
20:40:03 <Pseudonym> If you can reduce what you want to do into a constructive proof, you can mechanically turn that proof into a computer program that solves the problem.
20:40:18 <Pseudonym> And computer programs are useful.
20:40:22 <Pseudonym> Well, some of them are.
20:40:23 <palomer> Pseudonym: that solves what problem, exactly?
20:40:34 <Pseudonym> Well, let's pick an example.
20:40:53 <gzl> I really don't think you need to formalize these things to this degree simply to get work done. in the context of programming languages it's much more relevant, but in the more purely mathematical areas that use category theory, who really cares
20:40:56 <Pseudonym> If you formalise what it means for Java virtual machine code to be "safe", you can turn that into a program which checks safety.
20:40:56 <palomer> not a forall exists formula
20:41:32 <palomer> Pseudonym: I really, really doubt that
20:41:41 <palomer> the semantic meaning of constructive proofs is not that straightfoward
20:41:44 <Pseudonym> Well I happen to know that it's been done.
20:41:50 <palomer> s/straightfoward/straightforward
20:41:58 <Pseudonym> Proof-carrying code is another example.
20:42:11 <palomer> well, yes, the formalism becomes the computer program
20:42:33 <palomer> but that's silly, really, because it wasn't formalised in standard first/second/third order language
20:42:46 <Pseudonym> In the case of proof-carrying code, you can supply a proof of whatever along with the assembly language.
20:42:53 <Pseudonym> In such a way that the property can be checked.
20:43:19 <palomer> I can give you constructive proofs of statements in arithmetic which do not do what you'd expect
20:43:22 <Pseudonym> That makes it possible to upload arbitrary assembler into the kernel without it compromising system security.
20:43:42 <Pseudonym> Because you ALSO supply a checkable proof that it won't do anything bad.
20:43:50 <palomer> with proof carrying code, you're actually writing the proof out , it happens that the language you're writing the proof in is identical to the programming language
20:44:21 <Pseudonym> You don't have to.  Your proof could be in some other language.
20:44:44 <Pseudonym> Compiler writers use constructive proofs all the time.
20:44:48 <palomer> but you're statement is that "constructive proofs are programs which do exactly what you'd expect"
20:44:59 <Pseudonym> Err... I suppose, yes.
20:45:27 <palomer> but, really, they aren't, constructive proofs of _certain statements_ do what you'd expect
20:45:43 <Pseudonym> So?
20:45:46 <palomer> for example, we have no idea what a constructive proof of the mean value theorem does
20:45:51 <Pseudonym> The full employment theorem aplpies here.
20:46:32 <palomer> and yes, we have the associated program (check out krivine's work)
20:46:33 <Pseudonym> Right, but a constructive proof that a compiler transformation doesn't change the semantics of the program that you feed it does exactly what you'd expect.
20:46:52 <palomer> but the constructive proof is not a program!
20:47:15 <Pseudonym> And the proof that a program is type correct assigns types to expressions.
20:47:45 <Pseudonym> No, but it's isomorphic to one.
20:48:13 <palomer> express "this program is type correct" in standard second order logic and then find the proof
20:48:32 <palomer> I can assure you that the proof is not going to do what you'd expect
20:49:00 <Pseudonym> I don't follow.
20:49:41 <palomer> instead, you have to say something like "if this program is proof correct, then I will show that this statement written in some weird logical system is provable, and the associated program in this contrived system assigns a type to every term"
20:49:46 <Pseudonym> A proof that (\x . x) : A -> A assigns type A to x.
20:50:13 <palomer> what are your axioms?
20:50:31 <Pseudonym> They are such axioms as:
20:50:32 <palomer> what terms do you assign to your axioms?
20:50:40 <Pseudonym> { x : A } |- x : A
20:50:51 <Pseudonym> And:
20:51:22 <Pseudonym> { x : A }, G |- e : B   =>   G |= (\x. e) : A -> B
20:51:24 <palomer> those axioms are written in a language I have never seen before
20:51:33 <Pseudonym> It's sequent calculus.
20:51:53 <palomer> but, you see, this is very important
20:51:57 <Pseudonym> Sorry, I typed |= instead of |-.;
20:52:00 <Pseudonym> |-
20:52:28 <palomer> we must express our statement in second order predicate calculus
20:52:53 <palomer> something of the sort models(Type(x,A),Type(x,A))
20:53:10 <palomer> models is a binary predicate, Type is a binary predicate
20:53:18 <Pseudonym> Why must we express our statement in second order predicate calculus?
20:53:40 <palomer> how else are we going to convert the proof into a program?
20:55:06 <Pseudonym> That's easy.  You can do it automatically using a Curry-Howard-like transformation.
20:55:34 <palomer> but that applies for proofs of statements in second order logic (or first order logic)
20:55:52 <Pseudonym> Ah, true, yes.
20:57:33 <Pseudonym> So, let's see then.
20:57:45 <palomer> you see, this is the problem! you guys do this all the time! drives me nuts
20:57:59 <Pseudonym> But hang on.
20:58:18 <gzl> actually, I don't ever do this. :)
20:58:20 <Pseudonym> Sequent calculus is just a notation.
20:58:36 <gzl> (logic in general, that is.)
20:58:54 <Pseudonym> Transforming it into second order predicate calculus is just a syntactic transformation.
20:59:30 <palomer> whenever someone says a statement of the sort " a proof of blah does foo ", it's been wrong. sometimes it's "a proof of this sequent does foo", which is fine
20:59:50 <palomer> Pseudonym: try doing it, and then look at the terms you get
20:59:56 <Pseudonym> Ah, I see what you're getting at.
21:00:32 <Pseudonym> You're (quite reasonably) quibbling that I wasn't being anal enough in what I said.
21:01:43 <palomer> but, quite frankly, I work with statements
21:01:57 <palomer> it's the only way to communicate
21:02:42 <palomer> I mean, you can say things like: a proof of (X -> (X -> X) -> X) is a church numeral
21:02:58 <palomer> and other meaningless statements of the sort
21:03:09 <palomer> and you can even get some interesting programs
21:03:26 <Pseudonym> I'm still unsure why you think that's meaningless.
21:03:36 <palomer> like "a proof of forall x. exists y. t" is a lambda term that, given x, will compute y making t true
21:03:53 <palomer> Pseudonym: well, it's not very meaningful outside lambda calculus
21:04:18 <palomer> however, even to make certain statements like that, you need to assign certain terms to the peano axioms
21:04:39 <palomer> until krivine came along, it was the only meaningful way to produce programs from proofs
21:05:00 <foxy> @djinn (a -> (a -> a) -> a_
21:05:00 <lambdabot> Cannot parse command
21:05:16 <foxy> @djinn (a -> (a -> a) -> a)
21:05:16 <lambdabot> f a b = b a
21:05:24 <palomer> @pl f a b = b a
21:05:25 <lambdabot> f = flip id
21:05:30 <Pseudonym> Interestingly, in the Girard-Reynolds isomorphism, the expression of the Peano axioms gives you Church numerals, too.
21:05:46 <palomer> expression of the peano axioms?
21:05:56 <Pseudonym> Errr.
21:05:59 <palomer> you mean the induction axiom?
21:06:04 <Pseudonym> No, sorry.  The induction axiom, yes.
21:06:10 <palomer> that was the induction axiom in System F
21:06:12 <Pseudonym> I just realised that after I typed it.
21:07:27 <palomer> in AF_2 it would be:  \Pi X. (X0 -> forall y. (Xy -> Xs(y)) -> forall x.Xx)
21:07:34 <palomer> grrr
21:07:40 <palomer> my co supervisor does exactly the type of thing you just did
21:07:45 <palomer> drives me batshit
21:08:15 <palomer> "just repeat what everyone says and don't dig any deeper, and everything will be ok"
21:08:52 <Pseudonym> Huh?
21:09:10 <palomer> proofs are programs, programs are proofs, la la la la la la
21:09:27 <palomer> why not add "integers are programs, programs are integers"
21:09:32 <Pseudonym> The thing you've got to realise, BTW, is that I'm a compiler writer by trade.
21:09:46 <Pseudonym> Compiler writer's data are programs.
21:10:10 <Pseudonym> And constructive proofs leading to algorithms are whas they do for a living.
21:10:19 <palomer> right right, I'm talking about the people who think they know anything about logic, and start babbling about things they know nothing about
21:10:37 <Pseudonym> What a compiler writer does is come up with some transformation they want to apply.
21:10:38 <palomer> Pseudonym: I'm sure there is some truth to what you say, however the exact statements you're making are certainly not true
21:10:46 <Pseudonym> OK, fair enough.
21:11:10 <Pseudonym> So you've come up with this transformation.  For it to work without changing the meaning of the program, some preconditions need to be true.
21:11:34 <Pseudonym> So you need to write a theorem prover which proves those preconditions to be true.
21:11:58 <Pseudonym> If you express the logic system in a constructive way, that translates directly into a program which does the proof.
21:12:36 <Pseudonym> So while I'm not claiming that all proofs result in useful programs, there are certainly areas of computer science where this is almost true.
21:13:16 <Pseudonym> I should rephrase that as: I'm not claiming that all constructive proofs of useful theorems result in useful programs.
21:13:22 <palomer> Pseudonym: right right, you have to construct your own logical system with your own interpretations and your own language, etc, etc, ...
21:13:41 <palomer> and then your proofs will be meaningful, sure
21:15:26 <Pseudonym> And I guess this is the central point.
21:15:36 <palomer> I mean, people have always said statements of the sort "if this program works, then this transformation is correct", all you've done is automated the process of finding such programs
21:15:39 <Pseudonym> Second-order predicate calculus or whatever isn't always the most appropriate logic.
21:15:49 <Pseudonym> You use the simplest logic that works comfortably.
21:16:11 <palomer> Pseudonym: but then the theorems and programs are meaningless to anyone working outside your field
21:16:29 <palomer> furthermore, you still have a lot of work to do on your side, and this is work which has to be done for every set of problems
21:16:37 <palomer> C-H isn't a magic pill
21:16:45 <Pseudonym> For that matter, Wiles' theorem is meaningless to me.
21:17:10 <Pseudonym> Not true.  I understand what it _means_, kind of.  But a fat lot of good it does me.
21:17:23 <Pseudonym> C-H isn't a magic pill, no.
21:17:31 <Pseudonym> BUT, and this comes back to the earlier point...
21:17:32 <palomer> and well, we lose the "every proof can be trivially made into a program" aspect of things, since it depends on your underlying logic
21:17:34 <Pseudonym> It s a tool.
21:17:58 <Pseudonym> It does mean that you don't have to solve every logic problem in logic.
21:18:09 <Pseudonym> You can transport it over to lambda calculus and solve it there.
21:18:41 <Pseudonym> C-H specifically is also remarkable because simply-typed lambda calculus is also equivalent to Cartesian closed categories.
21:18:44 <palomer> and, well, given a set of problems, giving meanings to the proofs is really, really tough work. most of the time we don't bother
21:18:57 <palomer> Pseudonym: that's the lambek correspondence
21:19:02 <Pseudonym> Right.
21:19:14 <palomer> Pseudonym: ok, so cartesian closed categories model lambda calculus with product types
21:19:21 <palomer> do you agree with that statement?
21:19:37 <Pseudonym> Errr... I think so.  I think you left out "simply typed" somewhere in there.
21:19:38 <palomer> do you agree that that's the gist of lambek's correspondence?
21:20:20 <palomer> ok, it models it in the strictest of sense, meaning "a subset of the statements made in the language of CCCs is true in simply typed lambda calculus with product types"
21:20:20 <Pseudonym> Let's say "yes", and I'll chime in if I've forgotten anything.
21:20:44 <palomer> what are these statements? they aren't very insightful
21:21:01 <Pseudonym> Well actually, they are.
21:21:09 <palomer> ok, let's do things very carefully
21:21:15 <Pseudonym> Earlier, I mentioned this example:
21:21:20 <Pseudonym> data A = A (A -> Bool)
21:21:23 <palomer> we'll take second order preducate calculus as our language
21:21:24 <Pseudonym> That's a Haskell type.
21:21:45 <Pseudonym> It's a genuine type in Haskell.  It makes sense.
21:21:48 <palomer> s/preducate/predicate
21:21:59 <Pseudonym> But it does NOT make sense for A to be a set of values, which is the usual way of thinking about types.
21:22:13 <Pseudonym> Because it would require there to be an isomorphism from A to A -> Bool, which is impossible.
21:22:14 <palomer> gah! no haskell!
21:22:24 <Pseudonym> Hang on, I'm making a point.
21:22:31 <palomer> but I was making a point!
21:22:53 <Pseudonym> The point is that the statements in category theory give you models of the language.
21:23:03 <palomer> well, no
21:23:22 <Pseudonym> i.e. to come up with a concrete model for the language, here's what your model needs to be able to do.
21:23:22 <palomer> erm, well it is possible you mean what you say, but I doubt it
21:23:43 <palomer> a concrete model for the language?
21:23:47 <Pseudonym> Sure.
21:23:57 <palomer> do you mean an L-model? (for language L)?
21:24:05 <palomer> Pseudonym: do you know any model theory?
21:24:20 <Pseudonym> Being a compiler writer, I speak in terms of "programming language semantics".
21:24:28 <Pseudonym> And I don't know enough model theory.
21:24:29 <Pseudonym> :-)
21:24:33 <palomer> hrm
21:24:43 <palomer> well, then we can't discuss meaning in the strictest of sense
21:25:15 <palomer> programming language semantics is wishy washy, it assumes that everyone gives the same meaning to certain sentences
21:25:34 <palomer> hrmph
21:25:43 * palomer thinks model theory should be mandatory
21:25:48 <Pseudonym> Which is why categorical semantics is so popular these days.
21:26:02 <Pseudonym> It moves the problem over to an area which model theorists can grok.;
21:26:13 <Pseudonym> :-)
21:26:19 <palomer> but, you see, categorical semantics is based on the fact that you can then bring things back into your model
21:26:26 <palomer> you start with a model and a formula
21:26:29 <Pseudonym> Sure.
21:26:29 <palomer> you move it to category theory
21:26:34 <palomer> work with it in category theory
21:26:36 <palomer> then move it back
21:26:53 <palomer> or, leave it in category theory
21:27:18 <palomer> however, I've yet to see a useful formula morphed into the language of a certain category
21:27:42 <palomer> anyways, it's getting late
21:28:04 <Pseudonym> OK.  I'll mull over this a bit.
21:28:05 <Pseudonym> Night.
21:28:10 <palomer> night
22:12:33 <newsham> hi
22:12:47 <newsham> are there good libraries for interacting with urls, html and http?
22:15:28 <jethr0_> @google haskell http
22:15:29 <lambdabot> http://www.haskell.org/http/
22:16:50 <newsham> cool, what else, html?  urls?
22:17:33 <jethr0_> i don't know, never used it
22:22:05 <joelk> newsham, just looking at the heirarchical libraries page, there's Text.Html and Network.URI. Should be a good start along with the http package jethr0_ showed.
23:00:57 <gour> shapr: ping
23:01:18 <gour> shapr: ohh, i mean 'bok' !
23:10:13 <dons> @where http
23:10:14 <lambdabot> http://www.haskell.org/http/
23:27:01 * neologism wonders how ENIAC could be turing-complete without conditional jump
23:29:09 <jethr0_> Until 1948, to program ENIAC actually meant to rewire it
