00:10:45 <gFunk> strict Mond worked like a champ
00:10:50 <gFunk> no more stack blowing up
00:11:16 <rasterfar> neat
00:11:19 <gFunk> Lemmih: thanks so much!
01:09:28 <gour> shapr: bok
02:12:43 <tibbe> @quote
02:12:44 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up
02:12:44 <lambdabot> monad on wikipedia, find the category theory page, and crap themselves
02:12:49 <JKnecht> yum ghc x86_64 does the right thing (unlike the links on the FC4 extras page).
02:13:30 * JKnecht had just the opposite reaction.
02:14:02 <JKnecht> yummy darcs on same platform.
02:22:09 <srle> hi
02:23:02 <srle> is floating point arithmetic with NaN equavalent with Maybe monad?
02:28:06 <JKnecht> you mean with NaN as the value of a function?
02:29:45 <srle> NaN as Nothing, number as Just number
02:30:16 <srle> arithmetic operations as zero in Monad
02:30:49 <tibbe> @quote
02:30:50 <lambdabot> Taral says: How do you add an @quote?
02:31:02 <tibbe> @quote
02:31:03 <lambdabot> babel module failed: getRandItem: empty list
02:31:08 <tibbe> @quote
02:31:09 <lambdabot> babel module failed: getRandItem: empty list
02:31:11 <tibbe> @quote
02:31:13 <lambdabot> babel module failed: getRandItem: empty list
02:31:15 <tibbe> ;(
02:31:41 <xerox> @arr
02:31:42 <lambdabot> quote module failed: getRandItem: empty list
02:31:47 <xerox> @code
02:31:48 <lambdabot> code module failed: getRandItem: empty list
02:49:55 <lispy> @. vixen arr
02:49:56 <lambdabot> compose module failed: getRandItem: empty list
02:49:59 <lispy> @. vixen arr!
02:50:00 <lambdabot> compose module failed: Parse error: "arr!"
02:50:09 <lispy> @vixen
02:50:09 <lambdabot> vixen module failed: getRandItem: empty list
02:59:41 <foxy> @help
02:59:42 <lambdabot>  @help <command> - ask for help for <command>
03:00:08 <foxy> @commands
03:00:09 <lambdabot> Unknown command, try @listcommands.
03:00:16 <foxy> @listcommands
03:00:17 <lambdabot> use listcommands [module|command]. Modules are:
03:00:17 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
03:00:17 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
03:00:17 <lambdabot> seen spell state system todo topic type version vixen where
03:00:32 <foxy> @version
03:00:33 <lambdabot> lambdabot 3p283, GHC 6.5.20050806 (Linux i686)
03:00:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
03:01:59 <foxy> @todo
03:02:00 <lambdabot> 0. SamB: A way to get multiple results from a google search
03:02:00 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
03:02:00 <lambdabot> 2. SamB: stop mangling long urls
03:02:00 <lambdabot> 3. dons: improve formatting of @dict
03:02:00 <lambdabot> 4. dons: write Haskell Manifesto
03:02:02 <lambdabot> [27 @more lines]
03:02:21 <foxy> @more
03:02:22 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @foo
03:02:22 <lambdabot> across lines
03:02:22 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
03:02:22 <lambdabot> 7. TheHunter: @type 1 :: Int
03:02:22 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.  It
03:02:24 <lambdabot> [22 @more lines]
03:02:36 <foxy> @more
03:02:37 <lambdabot> would be nice if it also let you find functions in the given module that
03:02:37 <lambdabot> use a type.
03:02:37 <lambdabot> 9. dons: Implement @whatis
03:02:37 <lambdabot> 10. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
03:02:37 <lambdabot> 11. dons: there's some bug in the 'when i left' code of @seen
03:02:39 <lambdabot> [17 @more lines]
03:02:48 <foxy> @more
03:02:49 <lambdabot> 12. dons: sarahbot style @tell
03:02:49 <lambdabot> 13. beelsebob_: @tell command - relays a message to someone when they
03:02:49 <lambdabot> next speak
03:02:49 <lambdabot> 14. dons: @seen on lambdabot should report lambdabot's channels too
03:02:49 <lambdabot> 15. ski: when printing first lines of infinite things (or all cases with
03:02:51 <lambdabot> [12 @more lines]
03:03:00 <foxy> @more
03:03:01 <lambdabot> nonexact), should say 'at least'
03:03:01 <lambdabot> 16. ski: provide '@more <number>', at least for privmsg
03:03:01 <lambdabot> 17. ski: '@todo-remove <number>' for priviledged users, and possibly the
03:03:01 <lambdabot> user who added the todo note (is @todo-replace worth it ?)
03:03:01 <lambdabot> 18. dons: BUG: @pl (\_ -> return ()) --> const return
03:03:03 <lambdabot> [7 @more lines]
03:03:17 <foxy> @more
03:03:19 <lambdabot> 19. beelsebob_: "@tell command to make lambdabot give someone a message
03:03:19 <lambdabot> when they're next seen"
03:03:19 <lambdabot> 20. beelsebob_: "@remind command formatted as '@remind <person> {at <time>
03:03:19 <lambdabot> | in <time interval>} {to | about} <reminder message>' to get lambdabot
03:03:19 <lambdabot> to remind someone to do something"
03:03:21 <lambdabot> 21. beelsebob_: "@pester command to make lambdabot pester you in PM to do
03:03:23 <lambdabot> something"
03:03:33 <lispy> oh hey, i noticed #18 yesterday
03:03:45 <foxy> @more
03:04:42 <foxy> @karma lambdabot
03:04:43 <lambdabot> lambdabot has a karma of 10
03:04:57 <xerox> Err...
03:08:15 <lispy> @karma chameleon
03:08:16 <lambdabot> chameleon has a karma of 0
03:08:53 <lispy> i like when the karma increment is aliased to foo++, in those cases @karma c usually givea surprise :)
03:08:55 <tic_> lambdabot, pfft. :)
03:09:08 <tic_> err, lispy
03:16:23 <foxy> what do people think about programmable brackets as a syntax extension for haskell''?  Such as:
03:16:25 <foxy> (| _ |) :: a -> Foo a
03:16:34 <int-e> lispy: but chances are that here, the result would be negative.
03:16:59 <int-e> lispy: at least if you also alias foo--.
03:20:39 <integral> foxy: excellent idea for lifting.   and fwiw, perl6 supports "circumfix" as that type of operator
03:21:42 <foxy> I wrote an email to the haskell list about it and got not one comment %(
03:21:58 * lispy wonders if it would be better if macrology was supported instead of needing language extensions just to extend the syntax
03:29:40 <lispy> @type Control.Monad.liftM
03:29:42 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
03:29:57 <lispy> @type return
03:29:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
03:30:12 <lispy> foxy: so it would be a generalized return?
03:31:21 <foxy> well, I thought you could do fancier things like actually define the behaviour of list comprehensions as well:
03:31:22 <foxy>   [ _ | _ ... ] :: a -> [b] -> [a] -- for example
03:32:09 <foxy> (althought there's a trickier bit with the rhs of '|' since generators and conditions can be mixed
03:34:06 <foxy> http://www.mail-archive.com/haskell@haskell.org/msg17242.html
03:39:15 <Lemmih> foxy: I think you'd get more attention if you hacked a proof-of-concept in GHC.
03:39:57 <foxy> I was afraid someone would say that! :) -- I guess I'll have to
03:43:19 <A-Tui> hi all
03:43:42 <Lemmih> Hiya A-Tui.
03:46:31 <A-Tui> good morning Lemmih 
03:56:22 <araujo> Good morning.
03:56:44 <A-Tui> good morning araujo 
04:51:06 <foxy> I'm running "darcs get --partial http://darcs.haskell.org/ghc" and it seems to not be doing anything, should there be any feedback while getting the repository?  there is only one file in the directory I'm running it from "darcs48ea6d" and my processor is almost completely idle.
04:55:32 <Igloo> It's downloading the snapshot
04:55:52 <Igloo> I'd guess that files is getting bigger, BICBW
04:55:56 <foxy> OK, thanks...
04:56:06 <foxy> BICBW?
04:56:13 <Igloo> But I Could Be Wrong
04:57:10 <foxy> it just got bigger after being 0Kb for about 10 minutes (it's now 1116Kb)
05:04:18 <jethr0> foxy: i had instances where darcs would thrash weirdly. it would open hundreds of files with names like "darcs48ea6d", close them and open another...
05:04:31 <jethr0> no idea what that was. but usually you get feedback when it's downloading
05:04:50 <dons> hey foxy, long time no chat :)
05:05:02 <dons> you going to hack brackets into ghc?
05:05:22 <foxy> dons, Hiya, yeah, I'm gonna give it a go!
05:05:47 <foxy> I'm reading the GHC Commentary at the moment :)
05:05:51 <dons> cool. that's the best way to get people talking. code code code!
05:07:40 <foxy> dons, is it possible to store compiled code in a database and load it from memory, not disk (hs-plugins talk)
05:09:46 <dons> from memory. hmm. maybe. with a little patch to the rts, definitely.
05:18:49 <gour> dons: Lemmih unpulled some patch from ghc.hide ( bang-patterns) but fps still does not build. any idea when fps will go into ghc-head?
05:20:23 <dons> before 6.6. but I still suspect it's ghc that's breaking things. can you not use 6.4.x?
05:21:17 <gour> dons: then i'm missing ghc-any dependency, and Lemmih told me it's not possible to build hIDE with 6.4.x
05:21:40 <dons> hmm.
05:22:02 <dons> you'll have to ask Lemmih how to proceed I think.
05:22:20 <dons> I'll look at fps and ghc-head soon, unless you work out what the issue is first.
05:22:37 <Igloo> Is fps going to be used internally by GHC?
05:25:24 * Igloo disappears
05:25:50 <gour> dons: nice to hear that fps is going into head soon :-)
05:25:56 <dons> yup, or a version thereof
05:27:54 * dons -> night!
05:33:21 <ezraburgh> @hoogle unsafePerformIO
05:33:22 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
05:33:22 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
05:33:52 <foxy> how large is the HEAD darcs repository?
05:51:15 <JohnMeacham> woot! impredicative rank-n types are more or less working in jhc.
05:51:34 <wolverian> more or less? how can it be more than working? :)
05:51:41 <JohnMeacham> so you can have types like [forall a . a -> a]
05:52:07 <JohnMeacham> classes currently arn't checked, (but do work, assuming your program is correct :) )
06:25:16 <tibbe> @quote
06:25:17 <lambdabot> babel module failed: getRandItem: empty list
06:40:36 <Adamant> @quote Lennon
06:40:37 <lambdabot> Lennon hasn't said anything memorable
06:40:47 <Adamant> @quote John Lennon
06:40:48 <lambdabot> John Lennon hasn't said anything memorable
06:41:37 <Adamant> @quote dons
06:41:38 <lambdabot> babel module failed: getRandItem: empty list
06:56:00 <ihope> The Not types are all about proving that types don't exist, correct?
06:56:57 <ihope> At least, fully defined values with those types
06:57:00 <ihope> @type head
06:57:02 <lambdabot> forall a. [a] -> a
06:57:10 <ihope> @djinn Not ([a] -> a)
06:57:10 <roconnor> Not types?
06:57:11 <lambdabot> -- f cannot be realized.
06:57:16 <ihope> @djinn-env
06:57:18 <lambdabot> data () = ()
06:57:18 <lambdabot> data Either a b = Left a | Right b
06:57:18 <lambdabot> data Maybe a = Nothing | Just a
06:57:18 <lambdabot> data Bool = False | True
06:57:18 <lambdabot> data Void
06:57:20 <lambdabot> type Not x = x -> Void
06:58:51 <ihope> If you can turn something of some type into a type with no fully-defined members (Void), the type doesn't have any fully-defined members itself.
06:58:51 <roconnor> Well, sort of. ... Is Void really a type?
06:58:57 <ihope> Yes.
06:59:09 <ihope> It just has no fully-defined members.
07:00:07 <roconnor> Well, sometimes types can be uninhabited and still you can't get void.
07:00:15 <ihope> True.
07:00:23 <ihope> Like ((a -> b) -> a) -> a
07:00:53 <roconnor> or Either a (Not a)
07:01:07 <ihope> But this can prove some things don't exist:
07:01:15 <ihope> @djinn Not (Maybe a -> a)
07:01:17 <lambdabot> -- f cannot be realized.
07:01:20 <ihope> Um...
07:01:44 <ihope> ($ Nothing) has that type, doesn't it?
07:01:49 <int-e> @djinn Not (a -> b)
07:01:50 <lambdabot> -- f cannot be realized.
07:02:02 <ihope> > ($ Nothing) :: Not (Maybe a -> a)
07:02:04 <lambdabot>  Not in scope: type constructor or class `Not'
07:02:29 <ihope> > ($ Nothing) :: (Maybe a -> a) -> Void
07:02:30 <lambdabot>  Not in scope: type constructor or class `Void'
07:02:45 <roconnor> Not everything knows about Void I guess
07:02:52 <roconnor> Void isn't Haskell 98 afaik
07:03:00 <SimonRC> yeah
07:03:14 <ihope> It seems that only @djinn knows about Void, and it can't work with it,
07:03:23 <int-e> @type ($ Nothing)
07:03:24 <lambdabot> forall a b. (Maybe a -> b) -> b
07:04:08 <ihope> ...Ah, so it's a Not (Not (Maybe a)).
07:04:29 <int-e> @djinn Not (Maybe a -> Void)
07:04:32 <lambdabot> f a = a Nothing
07:05:08 <ihope> @djinn Not (Not a) -> a
07:05:09 <lambdabot> -- f cannot be realized.
07:05:16 <ihope> Figured that wouldn't work.
07:05:21 <ihope> @djinn a -> Not (Not a)
07:05:23 <lambdabot> f a b = b a
07:05:32 <ihope> flip ($)?
07:06:06 <ihope> Lemme think. That's a -> (a -> Void) -> Void... I see.
07:07:45 <ihope> It's a CPSificationer!
07:08:07 <ihope> But dang, a Cont Void a would be useless!
07:09:11 <ihope> Now, there exists a (Void -> a) that's fully-defined.
07:09:29 <ihope> Oddly enough, it's (error "Type system booched!").
07:10:36 <int-e> @djinn Maybe a
07:10:37 <lambdabot> f = Nothing
07:10:38 <roconnor> there is a relationship beteen double negation and CPS
07:14:07 <kosmikus> @index fst3
07:14:08 <lambdabot> bzzt
07:14:24 <int-e> @djinn (Not a -> Not b) -> b -> a
07:14:25 <lambdabot> -- f cannot be realized.
07:14:34 <int-e> @djinn b -> a -> (Not a -> Not b)
07:14:35 <lambdabot> f _ a b = void (b a)
07:15:01 <ihope> What's void?
07:15:43 <ihope> Is that Void -> a?
07:15:47 <ihope> @index void
07:15:48 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign
07:15:53 <ihope> Hmm.
07:16:06 <int-e> @type Foreign.void
07:16:07 <ihope> @type Foreign.void
07:16:08 <lambdabot> forall a. IO a -> IO ()
07:16:08 <lambdabot> forall a. IO a -> IO ()
07:16:25 <ihope> Somehow I feel that that's not @djinn's void.
07:18:02 <int-e> @type f _ a b = const (b a)
07:18:03 <lambdabot> parse error on input `='
07:18:14 <int-e> @type \_ a b -> const (b a)
07:18:15 <lambdabot> forall a t b t1. t1 -> t -> (t -> a) -> b -> a
07:18:21 <ihope> @type f void a b -> void (b a)
07:18:22 <lambdabot> Parse error in pattern
07:18:29 <ihope> @type f void a b = void (b a)
07:18:31 <lambdabot> parse error on input `='
07:18:39 <ihope> @type \void a b -> void (b a)
07:18:40 <lambdabot> forall t t1 t2. (t -> t2) -> t1 -> (t1 -> t) -> t2
07:19:11 <ihope> And that unifies with a -> ((a -> Void) -> b -> Void) how?
07:19:55 <ihope> a = t -> t2; (a -> Void) = t1; b = (t1 -> t); t2 = Void
07:20:05 <int-e> you mean b -> a -> (a -> Void) -> b -> Void
07:20:44 <ihope> Well, @djinn didn't pay any attention to that b in front.
07:21:31 <int-e> @djinn a -> b -> c -> c
07:21:32 <lambdabot> f _ _ a = a
07:21:36 <int-e> @djinn a -> b -> c -> b
07:21:36 <lambdabot> f _ a _ = a
07:21:46 <int-e> hmm, strange.
07:21:47 <ihope> @type [undefined :: a -> (a -> Void) -> b -> Void, \void a b -> void (b a)]
07:21:48 <lambdabot> Not in scope: type constructor or class `Void'
07:21:48 <lambdabot>  
07:21:48 <lambdabot> <interactive>:1:39: Not in scope: type constructor or class `Void'
07:21:50 <tibbe> anyone up for some problem solving?
07:22:03 <ihope> @type [undefined :: a -> (a -> c) -> b -> c, \void a b -> void (b a)]
07:22:05 <lambdabot> a -> (a -> c) -> b -> c, \void a b -> void (b a)] :: forall c t.
07:22:05 <lambdabot> [(t -> c) -> ((t -> c) -> c) -> (((t -> c) -> c) -> t) -> c]
07:22:24 <int-e> @where djinn
07:22:25 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
07:22:27 <ihope> Wait... so void :: a -> Void?
07:22:39 <ihope> Doesn't sound good...
07:22:57 <int-e> maybe it's really just a const?
07:23:22 <ihope> Wait...
07:23:25 <ihope> @djinn b -> a -> Not a -> Not b
07:23:26 <lambdabot> f _ a b = void (b a)
07:23:39 <int-e> @type \_ a b -> const (b a)
07:23:40 <lambdabot> forall a t b t1. t1 -> t -> (t -> a) -> b -> a
07:23:48 <ihope> @djinn b -> a -> (a -> Void) -> b -> Void
07:23:49 <lambdabot> f _ a b = void (b a)
07:23:57 <ihope> Heh, looks like it.
07:24:19 <ihope> t1 = b; t = a; a = Void; b = b
07:24:41 <ihope> And don't confuse those a's. That would make it all look Confusing.
07:26:29 <int-e> but it's really a -> Void. from Djinn's help: Since Djinn handles propositional calculus it also knows about the absurd proposition, corresponding to the empty set.  This set is called Void in Haskell, and Djinn assumes an elimination rule for the Void type: void :: Void -> a
07:27:09 <ihope> Ah.
07:27:37 <ihope> So it is the type system booched error? ;-)
07:27:52 <int-e> hmmmm. and a is b -> Void in our case. That's cheap.
07:28:21 <ihope> @djinn forall a. Maybe a
07:28:22 <lambdabot> -- f cannot be realized.
07:28:29 <int-e> @djinn a -> (Not a) -> anything
07:28:29 <lambdabot> f a b = void (b a)
07:28:59 <ihope> Cool.
07:29:16 <ihope> Of course, that itself could be the booched type system error as well.
07:31:25 <ihope> Hmm...
07:32:25 <ihope> undefined ((error "foo") 3)
07:32:33 <ihope> > undefined ((error "foo") 3)
07:32:34 <lambdabot> Add a type signature
07:32:38 <ihope> > undefined ((error "foo") 3) :: ()
07:32:40 <lambdabot> Undefined
07:32:45 <int-e> @djinn (b -> a) -> Not a -> Not b
07:32:45 <lambdabot> f a b c = b (a c)
07:33:18 <ihope> If from b you can get a and a does not exist, then b does not exist.
07:33:20 <ihope> Cool.
07:33:25 <int-e> @djinn (Not b -> Not a) -> a -> b
07:33:26 <lambdabot> -- f cannot be realized.
07:34:00 <ihope> If from the fact that b does not exist you can prove that a does not exist, and a exists, b must exist as well.
07:34:08 <ihope> Hmm.
07:34:42 <ihope> Ah yes. Law of contrapositives.
07:34:51 <int-e> @djinn Nod (Not a) -> a
07:34:52 <lambdabot> -- f cannot be realized.
07:34:58 <int-e> you tried that before, didn't you?
07:35:09 <int-e> @djinn Not (Not a) -> a
07:35:10 <lambdabot> -- f cannot be realized.
07:40:49 <int-e> intuitionistic propositional logic is not so intuitive.
07:41:06 <gour> @seen shaprt
07:41:07 <lambdabot> I haven't seen shaprt.
07:41:08 <gour> @seen shapr
07:41:09 <lambdabot> I saw shapr leaving #ScannedInAvian, #haskell-blah and #haskell 4 hours,
07:41:09 <lambdabot> 7 minutes and 37 seconds ago.
07:44:17 <gour> @where yi
07:44:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
07:47:44 <palomer> is pierce's law intuitive?
07:47:46 <gour> @where c2hs
07:47:48 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
07:48:50 <int-e> @djinn ((p -> q) -> p) -> p
07:48:51 <lambdabot> -- f cannot be realized.
07:49:16 <palomer> man, I'm starving
07:50:54 <int-e> @djinn ((Void -> q) -> Void) -> Void
07:50:55 <lambdabot> f a = void (a void)
08:01:22 <lisppaste2> jethr0 pasted "roulette wheel" at http://paste.lisp.org/display/16726
08:01:44 <jethr0> i'm trying to return elements from a list with a customized distribution
08:02:11 <jethr0> but my solution takes up 60% of the processing time of my application... any ideas how to speed this up?
08:05:34 <Saulzar> Which bit is slow?
08:05:42 <jethr0> the whole thing :)
08:06:17 <jethr0> makeWheel = 23.1% time, rouletteWheel = 15.4% time
08:06:37 <jethr0> the values are changing, as it's randomized
08:07:01 <jethr0> i was just wondering if there's a nice, idiomatic way of doing customized random distributions
08:08:01 <jethr0> at least it seems as if "dropWhile" were not the speediest way ^_^
08:08:34 <Saulzar> Yeah, lots of O(n) searching
08:08:44 <Saulzar> Hmm
08:09:08 <SimonRC> I believe Finitemap may be able to help
08:09:12 <jethr0> i don't even mind that so much. O(n) still shouldn't make up for 40-60% of the runtime. unless everything else is unrealisticly fast
08:09:43 <Saulzar> How many is howMany?
08:09:59 <jethr0> around 100
08:10:28 <jethr0> it should be the same size as (length generation)
08:11:38 <jethr0> funnily the function that does all the work (roulette) doesn't appear. and instead makeWheel which is called only a few times takes up all the time :-?
08:11:53 <Saulzar> Ahh
08:11:57 <jethr0> SimonRC: in what way?
08:12:49 <Saulzar> I guess you could use it for lookups .. ie. find the value before x
08:12:49 <jethr0> one possibility would be to fill an array with elements, pushing each element in as often as the distribution needs it.
08:13:06 <Saulzar> But if makeWheel is the expensive bit...
08:13:07 <jethr0> but i really need a non-integer distribution and that array might become pretty big
08:13:07 <Saulzar> That seems odd
08:13:17 <jethr0> exactly
08:13:56 <int-e> jethr0: you could make a Huffmann tree for your roulette thingy - that will minimize the average number of comparisons while you walk the tree.
08:15:02 <jethr0> hmm, a tree is definitely a possibility...
08:15:25 <SimonRC> jethr0: oops, I mean Data.Map.
08:15:34 <SimonRC> It has a partitioning function, I believe
08:15:40 <jethr0> SimonRC: still, i don't see how i should use it...
08:15:43 <jethr0> ah
08:16:17 <jethr0> it's only a binary partition though
08:17:40 <jethr0>   let wheel    = makeWheel generation
08:17:40 <jethr0>       makeElmt = return . roulette wheel =<< randomRIO (0.0, 1.0)
08:17:40 <jethr0>   sequence $ replicate (fromIntegral howMany) makeElmt
08:18:03 <jethr0> what could be so slow in that, if "makeWheel" and "roulette" are already accounted for?
08:18:17 <SimonRC> have you tried profiling?
08:18:37 <jethr0> yes, and the randomRIO is not very expensive in this case
08:18:49 <jethr0> leaving only functions that should be pretty fast
08:19:09 <int-e> how many genotypes are there?
08:19:19 <jethr0> 100 or so
08:19:34 <ihope> Lemme think...
08:19:44 <ihope> type And a b = Not (a -> Not b)
08:19:54 <ihope> @djinn Not (() -> Not ())
08:19:55 <lambdabot> f a = a () ()
08:20:07 <ihope> @djinn Not (Void -> Not ())
08:20:08 <lambdabot> -- f cannot be realized.
08:20:17 <ihope> @djinn Not (() -> Not Void)
08:20:18 <lambdabot> -- f cannot be realized.
08:20:26 <ihope> @djinn Not (Void -> Not Void)
08:20:29 <lambdabot> -- f cannot be realized.
08:21:08 <Beelsebob> @help djinn
08:21:08 <lambdabot> Generates Haskell code from a type.
08:21:08 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
08:21:38 <Beelsebob> @djinn [Int] -> [Int]
08:21:39 <lambdabot> f a = a
08:21:42 <ihope> type Or a b = Not a -> b
08:21:43 <Beelsebob> I see :/
08:22:03 <ihope> Hmm...
08:22:04 <jethr0> the expensive expression is "let wheel = makeWheel generation" with "makeWheel" already accounted for... ?!?!???
08:22:09 <ihope> @djinn Not () -> ()
08:22:10 <lambdabot> f a = void (a ())
08:22:18 <ihope> @djinn Not Void -> ()
08:22:20 <lambdabot> f _ = ()
08:22:25 <ihope> @djinn Not () -> Void
08:22:26 <lambdabot> f a = a ()
08:22:34 <ihope> @djinn Not Void -> Void
08:22:35 <lambdabot> -- f cannot be realized.
08:22:37 <ihope> Nice.
08:22:41 <int-e> jethr0: oh wait. makeWheel is cheap, the time is spent in library functions
08:23:16 <int-e> jethr0: or could be
08:25:06 <jethr0> the weird thing is that everything else get's a boost from "-O2". but makeWheel and rouletteWheel seem to stay the same and therefore their relative costs rise dramatically
08:25:16 <jethr0> i seem to be doing sth that the compiler doesn't optimize...
08:26:03 * Saulzar goes to put some numbers into it
08:26:08 <ihope> Xor a b = Not (Or a b -> And a b)
08:26:23 <ihope> @djinn-env
08:26:24 <lambdabot> data () = ()
08:26:24 <lambdabot> data Either a b = Left a | Right b
08:26:24 <lambdabot> data Maybe a = Nothing | Just a
08:26:24 <lambdabot> data Bool = False | True
08:26:24 <lambdabot> data Void
08:26:26 <lambdabot> type Not x = x -> Void
08:26:29 <ihope> @help djinn-add
08:26:30 <lambdabot> Define a new function type or type synonym
08:26:58 <ihope> @djinn-add type And a b = Not (a -> Not b)
08:30:41 <ihope> Yay, the logic's in.
08:31:32 <ihope> @djinn And True True
08:31:34 <lambdabot> f a = a () ()
08:31:38 <ihope> @djinn Xor True False
08:31:40 <lambdabot> f a = void (a (\ b -> b ()) (\ _ c -> c))
08:31:44 <ihope> @djinn Or False False
08:31:45 <lambdabot> -- f cannot be realized.
08:31:47 <ihope> ;-)
08:31:48 <roconnor> @djin ((),())
08:31:49 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-
08:31:49 <lambdabot> ver
08:31:55 <roconnor> @djinn ((),())
08:31:56 <lambdabot> f = ((), ())
08:32:10 <roconnor> @djinn A -> (A,A)
08:32:11 <lambdabot> f a = (a, a)
08:33:38 <ihope> ...Oh yeah, And = (,).
08:33:55 <ihope> Ah well.
08:35:08 <jethr0> Saulzar: obviously profiling it in isolation will yield 100% (d'oh). but for 10000 elements it took 10 seconds user time.
08:35:26 <jethr0> something _is_ slow here... maybe the randomRIO
08:36:04 <lisppaste2> jethr0 annotated #16726 with "standalone" at http://paste.lisp.org/display/16726#1
08:38:38 * jethr0 is confused
08:40:51 <ihope> ...And Or is Either?
08:40:59 <ihope> @djinn Either () ()
08:41:00 <lambdabot> f = Left ()
08:41:05 <ihope> @djinn Either () Void
08:41:07 <lambdabot> f = Left ()
08:41:11 <ihope> @djinn Either Void ()
08:41:12 <lambdabot> f = Right ()
08:41:18 <ihope> @djinn Either Void Void
08:41:19 <lambdabot> -- f cannot be realized.
08:41:24 <ihope> Hmm.
08:42:53 <tibbe> @where logs
08:42:54 <lambdabot> http://tunes.org/~nef/logs/haskell/
08:43:09 <Saulzar> Yep, definately makeWheel is the cuplrit
08:43:59 <jethr0> Saulzar: weird. not in my isolated profilings... still, any ideas for a generally "better" solution?
08:44:40 <Saulzar> makeWheel                      Main                  62.4   58.7
08:44:40 <Saulzar> rouletteWheel                  Main                  27.2   41.2
08:44:40 <Saulzar> roulette                       Main                  10.4    0.0
08:44:59 <ihope> There we go.
08:45:19 <ihope> type Xor a b = (Either a b -> (a, b)) -> Void
08:45:25 <ihope> I still don't understand it, but it works.
08:45:33 <jethr0> k
08:45:47 <tibbe> @seen vincent
08:45:47 <lambdabot> I haven't seen vincent.
08:46:00 <tibbe> @seen vincenz
08:46:01 <lambdabot> vincenz is in #haskell. Last spoke 11 hours, 16 minutes and 22 seconds
08:46:01 <lambdabot> ago.
08:46:12 <tibbe> vincenz, you there?
08:46:32 <ihope> Ah, now I get it.
08:46:49 <ihope> @djinn Xor Int Bool
08:46:51 <lambdabot> -- f cannot be realized.
08:46:58 <ihope> @djinn Xor Int Void
08:46:59 <lambdabot> -- f cannot be realized.
08:47:10 <ihope> Hmm...
08:47:13 <ihope> @djinn Int
08:47:14 <lambdabot> -- f cannot be realized.
08:47:20 <ihope> @djinn Not Int
08:47:21 <lambdabot> -- f cannot be realized.
08:47:28 <ihope> @djinn Bool
08:47:29 <lambdabot> f = False
08:50:50 <ihope> So a Xor type exists if and only if given one of its argument types, it is impossible to reliably get the other.
08:52:05 <ezraburgh> @djinn Xor Int Int
08:52:06 <lambdabot> -- f cannot be realized.
08:52:17 <Saulzar> jethr0, Seems reddiculous to me that for 10000 elements it should take so long
08:52:32 <jethr0> exactly, but i can't really find the problem
08:53:14 <jethr0> it _is_ randomizing 10000 times, but profiling showed that randomRIO had very little influence on the cpu time
08:53:28 <ihope> @djinn False -> Boot
08:53:29 <lambdabot> f = void
08:53:32 <Saulzar> If I remove the randomRIO and use (return 1) then it's about 50/50 makeWheel and roulette
08:53:40 <ihope> Ah well. It works.
08:53:41 <Saulzar> Since then it's traversing the whole list each time...
08:53:45 <ihope> @djinn True -> Bool
08:53:46 <lambdabot> f _ = False
08:54:10 <Saulzar> Which means that traversing n^2 times is as fast as creating once... !
08:54:26 <Saulzar> Rather, traversing n times :)
08:54:39 <jethr0> hmm
08:55:21 <jethr0> fastest would be a pseudo-hash which you can feed double values and that returns an element from the matching section
08:55:40 <jethr0> i guess some kind of binary tree might not be too bad
08:56:00 <jethr0> but this won't address the "makeWheel" problem at all
08:58:18 <lisppaste2> int-e annotated #16726 with "using tree. way faster." at http://paste.lisp.org/display/16726#2
08:58:25 <Beelsebob> if random is taking up the time, could you not use a pseudo-random generator, and seed it with randomIO?
09:00:11 <jethr0> i thought randomIO was a PRG... is it using /dev/random?
09:00:36 <jethr0> int-e: thx, i'll have a look
09:00:47 <int-e> randomIO is a PRNG.
09:01:28 <ihope> @djinn Not (Not a -> a)
09:01:29 <lambdabot> -- f cannot be realized.
09:01:35 <ihope> @djinn Not (a -> Not a)
09:01:38 <lambdabot> -- f cannot be realized.
09:01:40 <ihope> Hmm...
09:08:50 * Saulzar managed to make a version 4 times sower
09:10:02 <jethr0> Saulzar: not bad. i made mine 2 times slower by using inline accumulation instead of "scanl . map"
09:10:34 <Saulzar> Yeah, that's what I did too.
09:10:35 <ihope> Sheesh. Why don't you guys just store all your data as SHA-512 hashes?
09:10:54 <jethr0> hehe
09:11:46 <Saulzar> I have a feeling it's lying to us about where the cost is....
09:11:58 <Saulzar> Or at least we're misinterpreting it :)
09:12:11 <ihope> > product [1..5]
09:12:13 <lambdabot> 120
09:12:13 <ihope> > product [1..15]
09:12:15 <lambdabot> 1307674368000
09:13:31 <tromp_> product [p]
09:13:39 <tromp_> > product []
09:13:41 <lambdabot> 1
09:14:06 <jethr0> > product [] + sum []
09:14:07 <lambdabot> 1
09:14:44 <Saulzar> Hm, I can't seem to get it to go slow anymore outside of profiling
09:15:03 <jethr0> ?
09:15:24 <jethr0> i think i'll try the tree approach of int-e, profile and find out that it's even more expensive...
09:18:13 <tibbe> @type \x -> x x
09:18:15 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:18:15 <lambdabot>   Expected type: t
09:18:30 <tibbe> come on lambdabot !
09:18:32 <Saulzar> Hmm, actually this seems to work much better with little change .. I thought I hadn't changed it, but I had
09:18:56 <Saulzar> I would guess the tree approach would certainly work better for lookups in any case..
09:18:58 <ihope> @type join id
09:19:00 <lambdabot> Not in scope: `join'
09:19:13 <ihope> @type Control.Monad.Reader.join id
09:19:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
09:19:15 <lambdabot>   Expected type: a -> a -> a1
09:26:53 <lisppaste2> int-e annotated #16726 with "refactor build in makeWheel' using CPS" at http://paste.lisp.org/display/16726#3
09:30:00 <int-e> Well, I'd believe lookups dominate the running time, whatever the profile says.
09:32:11 <jethr0> int-e: me too. but profiling is really the only thing one can rely on. i've more often "guessed" wrong than right :)
09:32:15 <Saulzar> int-e, That's what I suspect..
09:33:20 <jethr0> afk
09:33:22 * int-e begins to like his huffmann tree builder
09:33:33 <Saulzar> Hmm, the tree solution seems to run even slower here - 2 seconds for 1000, and doesn't seem to finish for 10000
09:33:40 <jethr0> :)
09:34:15 <jethr0> there's actually no need to order the tree... i'll be away a while, but then i'll tackle my own tree version.
09:34:25 <Speck> does anyone have an example of a GADT+Arrow library like the optimized Yampa implementation?
09:35:03 <Saulzar> The optimized Yampa implementation?
09:35:15 <int-e> jethr0: I wanted to build a huffmann tree, so I had to sort it and also write some obscure code that uses three lists to represent two lists that are being merged.
09:35:33 <jethr0> i understand
09:35:35 <Speck> Saulzar: www.cs.nott.ac.uk/~nhn/Publications/icfp2005.pdf
09:39:26 <int-e> Saulzar: hmm. which tree solution are you talking about?
09:39:54 <Saulzar> int-e, The one you pasted 
09:40:22 <Saulzar> I just blindly substituted the main routine with rouletteWheel' 
09:41:27 <int-e> Saulzar: hrm. in my tests (I plugged it in into the program jethr0 pasted) it's about 50 times faster than the original (using ghc -O2)
09:41:57 <int-e> Saulzar: right, rouletteWheel' is a drop-in replacement for rouletteWheel
09:43:01 <tromp_> Haskell for gambling?
09:44:12 <Saulzar> Gentic algorithms, I think?
09:44:19 <musasabi> A
09:44:45 <Saulzar> int-e, Odd - seems to take forever here, also compiled with -O2 ..
09:45:00 * greenrd wonders idly... if it is acceptable to discuss gambling code in here, is it acceptable to discuss pornography-related code? ;-)
09:46:05 <musasabi> well there is #haskell-blah for all your haskell pornography needs ;)
09:46:16 <greenrd> well, that's not quite what I meant
09:46:44 * greenrd had never considered the possibility of Haskell programming per se being erotic
09:47:58 <greenrd> I meant code for running porn sites, code for doing useful stuff for porn users, etc.
09:48:10 <greenrd> Purely a hypothetical
09:50:01 * int-e wonders if Saulzar's ghc comes with a bad sortBy implementation.
09:50:07 <musasabi> What kind of special needs would that have?
09:50:38 <musasabi> Mostly authorization and hanling large amounts of images/videos?
09:51:48 <Saulzar> I'm getting  100 -> 0.021, 200 -> 0.075, 400 -> 0.321, 800 -> 1.782, 1600 -> 7.585
09:51:59 <Saulzar> 10000 -> never finish
09:52:03 <greenrd> musasabi, I don't know, I haven't really thought about it
09:52:23 <Saulzar> I'm using ghc 6.4.1 on x86 ... athlon 2600+
09:54:01 <int-e> which sortBy are you using?
09:54:05 <int-e> @index sortBy
09:54:06 <lambdabot> Data.List
09:54:12 <Saulzar> Yeah, Data.List
09:57:04 <tibbe> I have an interview at Google coming up tomorrow and I'm a bit nervous. Anyone have any tips for technical subjects I should look into tonight. I've done some algorithm reading today.
09:58:00 <int-e> Saulzar: hmm, could you try http://fuchur.t-link.de/~bf3/wheel.hs ?
09:58:49 <A-Tui> hi
09:58:54 <zamez> tibbe: not very technical, but how about "sleep" ;)
09:58:59 <int-e> Saulzar: that runs in 0.17 seconds here (Athlon XP 2500+, also ghc 6.4.1)
09:59:12 <Saulzar> Instant..
09:59:40 <tibbe> zamez, good point, I don't have to get up early tomorrow so I plan to sleep until i wake %)
09:59:43 <tibbe> by my own
09:59:49 <Saulzar> Hmm, strange - did you change anything?
10:00:29 <int-e> Saulzar: I refactored the build (as in the paste page) and that's it - that didn't have any noticable impact on the speed though.
10:00:40 <Saulzar> I tried both (from the paste page)
10:00:50 * Saulzar goes to diff them
10:02:26 <Saulzar> Wow, the only real difference seems to be this:
10:02:28 <Saulzar> < import Data.List
10:02:28 <Saulzar> ---
10:02:28 <Saulzar> > import Data.List (sortBy, insertBy)
10:02:29 <lambdabot>  parse error on input `import'
10:04:11 <int-e> very strange (changing that has no impact here)
10:05:16 <ibid> dcoutts: good evening :)
10:05:24 <dcoutts> ibid, evening
10:05:32 <Saulzar> Try adding at the top module Main where
10:05:39 <ibid> dcoutts: i heard rumors that you have some sort of darcs mail script
10:05:55 <Saulzar> I removed that and it is identical wheel.hs
10:06:01 <ibid> dcoutts: is that true?
10:06:21 <int-e> yes, that does it. what the hell is happening there?
10:06:41 <Saulzar> Good question... I wonder if it does something odd with comparing
10:06:47 <dcoutts> ibid, oh, yeah, it's not terribly advanced, but yeah
10:07:07 <int-e> @index comparing
10:07:08 <lambdabot> bzzt
10:07:08 <ibid> dcoutts: is it available somewhere?
10:07:53 <dcoutts> ibid, darcs.haskell.org:~dcoutts/bin/commit-messages-split.sh
10:08:21 <ibid> dcoutts: i doubt i have shell access there
10:09:31 <dcoutts> ibid, http://haskell.org/~duncan/darcs-commit-email.sh
10:09:44 <Saulzar> int-e, That's really bizzare...
10:10:07 <Saulzar> Does it suddenly make the functions polymorphic when they were specialised before, or something?
10:10:35 <ibid> dcoutts: thanks
10:10:37 <MarcWeber> Hi. I've found the documentation of how to build ghc on www.haskell.org/ghc. It is said that I need some special versions of sed, perl and so on.. Isn't this checked automatically by configuring?
10:10:45 <palomer> high
10:11:05 <_Codex> Why is loops so rarely used in haskell programs?
10:11:14 <palomer> @hoogle loop
10:11:15 <lambdabot> Control.Arrow.loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
10:11:15 <lambdabot> Data.Graph.Inductive.Example.loop :: Gr Char ()
10:11:15 <lambdabot> Data.Graph.Inductive.Example.loop' :: IO (SGr Char ())
10:11:18 <palomer> we have loops?
10:11:22 <palomer> what kind of loops?
10:11:40 <musasabi> loops tend to be error prone
10:11:53 <musasabi> and for simple iteration over something we use hofs
10:11:57 <palomer> keeping track of loop context is tricky business
10:12:05 <_Codex> I mean things like: fib_{n+1} = fib(n-1) + fib(n) with all values of n
10:12:30 <int-e> Saulzar: the really bizarre thing is that it changes the asymptotic running time.
10:12:44 <palomer> well, that's the definition of the fibonacci sequence
10:13:11 <palomer> _Codex: a programming language is like a normal language: you want to express things succinctly, clearly and with the least amount of context possible
10:14:04 <palomer> anyways, this definition of the fibonacci mimicks how most of us would describe the fibonacci sequence in our own language
10:14:25 <_Codex> but why is that implemented with a function which restricts the resulting values to just one, while we might want to get all values out of it, the whole fib(n) set?
10:14:54 <palomer> _Codex: that's no problem
10:15:02 <palomer> @hoogle zipwith
10:15:03 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
10:15:03 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
10:15:03 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [
10:15:03 <lambdabot> c]
10:15:22 <Saulzar> Hmm, inlining /specialisation and substituting Int directly don't seem to change anything
10:15:40 <palomer> > let fib = 0 : (zipWith (+) fib (tail fib)) in fib
10:15:41 <lambdabot> Exception: <<loop>>
10:16:01 <palomer> > let fib = 0 : (zipWith (+) (tail fib) (tail $ tail fib)) in fib
10:16:02 <Speck> musasabi: I saw your GADT+Arrow example in the logs; have you done anything else with that technique?
10:16:03 <lambdabot> Exception: <<loop>>
10:16:15 <palomer> ugh, someone give me the standard definition of the fibonacci sequence
10:16:59 <palomer> > let fib = 0 : (zipWith (+) (tail fib) (tail $ tail fib)) in take 5 fib
10:17:01 <lambdabot> Exception: <<loop>>
10:17:37 <palomer> musasabi: do you have examples of uses of GADTs?
10:17:38 <Saulzar> 0 : 1 ...
10:17:42 <palomer> if so, I'd be very interested
10:17:43 <musasabi> Speck: comonads + GADT, but I didn't find the time to formalize that yet.
10:17:50 <int-e> > let fib = 0:scanl (+) 1 fib in take 5 fib
10:17:50 <tromp_> remove some tails
10:17:51 <lambdabot> [0,1,1,2,3]
10:18:02 <Speck> musasabi: ah! when you have something to show for it I'd love to see :-)
10:18:13 <palomer> int-e: the version with zipWith
10:18:14 <musasabi> palomer: yes, random code lying around. oh and parrows.
10:18:23 <int-e> palomer: see Saulzar's comment
10:18:28 <jyp> > let fib = 0 : (zipWith (+) (tail fib) (tail $ tail fib)) in take 5 fib
10:18:30 <lambdabot> Exception: <<loop>>
10:18:37 <jyp> > let fib = 0 : 1 : (zipWith (+) (tail fib) (fib)) in take 5 fib
10:18:39 <lambdabot> [0,1,1,2,3]
10:18:48 <palomer> oh, righto
10:19:10 <palomer> musasabi: how do you use them?
10:20:25 <musasabi> palomer: to capture dependencies and force the shape of a type parameter
10:20:41 <palomer> shape in which sense?
10:21:22 <palomer> musasabi: sounds like GADT solving?
10:21:42 <palomer> or GADT inference
10:22:34 <Speck> also useful for abusing invariants :-D
10:23:09 <palomer> musasabi: btw, do you know of any good literature on shapes (and their uses) ?
10:23:22 <palomer> to me, they just look like existentially quantified types
10:23:56 <musasabi> http://youzen.b2.fi/~musasabi/comonad.lhs
10:25:02 <Speck> nice!
10:25:22 <musasabi> palomer: not really. I think uustalu might have a new paper coming up which may have things about comands & GADT.
10:26:49 <Speck> I wonder if first class AGs would promote an idiom that would allow more aggressive deforestation optimizations... it has been a while since I read much on AGs but it seemed like that was a plus
10:27:33 <palomer> AG?
10:27:38 <Speck> attribute grammars
10:27:55 <Speck> (mentioned in the comonad code)
10:28:11 <palomer> what's STM?
10:28:30 <Speck> Concurrent.STM?
10:28:36 <palomer> @hoogle STM
10:28:37 <lambdabot> GHC.Conc.STM :: STM a
10:28:37 <lambdabot> Language.Haskell.TH.Lib.StmtQ :: Q Stmt
10:28:37 <lambdabot> Language.Haskell.TH.Syntax.Stmt :: Stmt
10:28:43 <palomer> righto
10:28:52 <palomer> grr
10:29:00 <palomer> to understand the stratified types paper, you need to understand shapes
10:29:22 <Speck> what are shapes? (or is that what you're asking :-P)
10:30:04 <palomer> well, yes, that is what I'm asking
10:32:55 <jethr0> Saulzar: what was that you found out? difference between general and specialized import?
10:35:07 <int-e> jethr0: no, a difference between specifying 'module Main where' or not
10:35:15 <Saulzar> jethr0, If we add "module Main where" at the top of int-e's code, performance suddenly goes through the floor - makes it exponential (or something like that) time
10:35:17 <jethr0> weird
10:37:47 <Saulzar> I can't figure out why, I guess the core would show it up
10:43:06 <ndm> Saulzar: try module Main(main) where
10:43:17 <int-e> Saulzar: exporting rouletteWheel' causes it, hmm.
10:43:43 <ndm> if something is exported, then GHC can't inline and specialise it so much, which makes the code slower
10:44:26 <Saulzar> Surely it would make 2 versions if inling were occuring?
10:46:42 <Saulzar> rouletteWheel' is a high level function too
10:46:56 <Saulzar> It's only run once...
10:47:06 <jethr0> in my application the old rouletteWheel isn't exported and it's still damn slow
10:48:15 <int-e> FWIW, adding {-# NOINLINE rouletteWheel' #-} to the code has the same effect - huh?
10:48:17 <Saulzar> I thought I was told that GHC was capable of inlining across modules as well?
10:48:37 <Saulzar> (Even though this is in the same module...)
10:52:03 <int-e> explicitely forcing wheel before the sequence helps.
10:52:32 <jethr0> interesting. although sequence should force it itself as an IO action, no?
10:54:00 <ndm> GHC has different flexibility over private vs public functions
10:54:25 <Saulzar> Hmm, right - a `seq` for wheel and it works ok
10:54:39 <ndm> if something is private it has more chance to optimise - only something like Jhc does whole program analysis
10:55:08 <int-e> ndm: well, in that case the opposite happened
10:56:02 <Saulzar> I thought the usual technique was 2 versions, 1 exported one locally specialised 
10:56:55 <MarcWeber> Lemmih My cabal config ghc-pkg install problem is gone (I've upgradet to ghc 6.4.2 snapshot)
11:01:16 <int-e> Saulzar: anyway. replace the sequence by wheel `seq` sequence and all is good. for some reason the wheel ended up not being shared ... and recalculating it 10000 times is a bit too much (the resultung running time is O(n^2 log(n)) then)
11:01:55 <Saulzar> No wonder
11:02:53 <Saulzar> Why would wheel not be shared?
11:03:01 <Saulzar> It has all it's arguments applied
11:04:00 <int-e> Saulzar: probably some inlining happening between that and the next line ... but who knows? I don't really feel like wading through Core code right now.
11:04:09 <Saulzar> Hmm
11:04:22 <Saulzar> I see, if it was inlined into makeElmt ..
11:06:35 <int-e> Saulzar: adding a {-# NOINLINE wheel #-} helps ...
11:07:37 <int-e> Saulzar: and adding {-# NOINLINE makeElmt #-} *also* helps
11:07:50 <int-e> Saulzar: so it seems to inline that into replicate ...
11:09:57 <Saulzar> Hmm!
11:10:39 <jethr0> what do you mean "inline into replicate"? why would that make it slower?
11:11:14 <Saulzar> I wonder how it decides when to inline, seems it gets the heuristics wrong here
11:11:53 <Saulzar> Inlining functions is just about always good, inlining completely applied expressions seems a worry
11:13:15 <palomer> grrr, shape inference makes me mad
11:13:36 <jethr0> shape inference?
11:13:56 <palomer> yeah, a shape is a type with "holes"
11:14:00 <Saulzar> Primary school kids can do shape inference :)
11:14:11 <jethr0> ah
11:14:21 <palomer> pottier and regis-gianas use it in their stratified types paper
11:14:55 <jethr0> i've glanced over it. but as usual it would take me super-human discipline to work through that kinda paper :)
11:18:46 <palomer> hrmph
11:18:52 <palomer> I have to start reading plotkin's papers now
11:19:00 <int-e> well ghc says that it inlines sequence and randomRIO ... so all bets about evaluation order of randomRIO and the pure functions are off.
11:21:46 <jethr0> nice, my tree version totally solved the problem... very weird indeed
11:22:01 <Saulzar> Cool
11:22:19 <jethr0> but i still don't know what happened before. you think it was the inlining?
11:22:34 <int-e> yes.
11:22:42 <Saulzar> Even on the original?
11:22:49 <jethr0> how would one have found that out?
11:22:55 <int-e> no, not on the original
11:22:58 <Saulzar> That would make sense though. 10 seconds was reddiculous
11:23:23 <int-e> not really. traversing a list of length 10000 halfway 10000 times takes time
11:23:30 <int-e> (halfway is the average)
11:23:51 <Saulzar> Well, that's true... but the profile still showed most of the time in the creation function
11:23:59 <palomer> hrm
11:24:03 <int-e> hmm
11:24:22 <palomer> my supervisor said that plotkin published a paper that I may want to read, and he threw a few keywords at me
11:24:38 <palomer> like "lattice", "machine learning", "unification", ..
11:24:43 <palomer> .how would I go about finding this paper?
11:25:14 <int-e> Saulzar: well, adding that wheel `seq` to the program saves 0.4 seconds ...
11:25:21 <int-e> Saulzar: that's not too impressive
11:25:40 <Saulzar> True, adding it for mkElemt saves about 4 /10 ..
11:26:59 <int-e> @type foldr seq
11:27:00 <lambdabot> forall a b. b -> [a] -> b
11:27:39 <jethr0> Saulzar: where did you add the `seq`? in rouletteWheel?
11:27:46 <int-e> yes
11:27:51 <int-e> I did that :)
11:28:22 <int-e> the last line there now reads:  wheel `seq` sequence $ replicate (fromIntegral howMany) makeElmt
11:28:33 <jethr0> ah
11:29:10 <jethr0> stupid randomization. that makes comparative profiling impossible *grr*
11:29:39 <Saulzar> Could set the seed..
11:29:52 <jethr0> yup, just had that idea myself :)
11:37:02 <araujo> Hello.
11:37:14 <orbitz> hi
11:38:30 <araujo> oh no, you're here
11:41:57 <tibbe> @quote
11:41:58 <lambdabot> babel module failed: getRandItem: empty list
11:42:05 <TuringTest> @seen dons
11:42:07 <lambdabot> dons is in #haskell. Last spoke 6 hours, 14 minutes and 11 seconds ago.
11:42:23 <lisppaste2> int-e annotated #16726 with "alternative makeWheel' - just create a balanced tree" at http://paste.lisp.org/display/16726#4
11:44:01 <jethr0> int-e: that's pretty much what i did
11:44:29 <jethr0> but with "-O2" profiling tells me that my new makeWheel takes 50% of the time :(
11:44:41 <jethr0> stupid profiler
11:45:13 <TuringTest> jethr0: How big the input data?  If you use the wheel often, the startup time will be less than 50%...
11:45:38 <jethr0> yes, but i thought that this would show on input sizes of 100+ already
11:46:01 <jethr0> my new method isn't much more complex than my old... well, i guess i'll have to live with it :(
11:46:09 <int-e> well, mine takes 50% of the time, too. I think that's ok.
11:46:41 <jethr0> but it's such a stupid place to spend your time in :)
11:47:01 <lisppaste2> jethr0 annotated #16726 with "my tree" at http://paste.lisp.org/display/16726#5
11:47:29 <int-e> hmm. actually it's only 1/4 of the time.
11:47:40 * int-e measured the wrong version (the huffmann tree)
11:48:08 <jethr0> :), i've got a whole application hanging on it anyways
11:49:13 <int-e> you should replace take and drop by splitAt
11:50:00 <jethr0> k, i thought splitAt would be implemented using take and drop :)
11:50:25 <TuringTest> Everyone thinks splitAt should work better than it does.
11:51:34 <int-e> it works slightly better than matching split and drop 'calls'.
11:51:40 <int-e> usually
11:51:44 <jethr0> k, i'll use it
11:52:54 <TuringTesint> int-e: The only problem with splitAt that I have seen myself is when it caused the fst part to be non-lazy and so killed RAM.
11:53:23 <int-e> TuringTesint: right. but I think this is not an issue here.
11:53:45 <Cale> @libsrc Data.List
11:53:46 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
11:54:53 <Cale> @libsrc GHC.List
11:54:54 <lambdabot> GHC.List not available
11:55:07 <Cale> http://darcs.complete.org/fptools/libraries/base/GHC/List.lhs
11:55:56 <int-e> #ifdef USE_REPORT_PRELUDE #else /* hack away */
11:56:05 <Cale> :)
11:56:08 * int-e thinks happy thoughts
11:56:22 <TuringTesint> nice
11:59:13 <TuringTesint> GHC.List.takeUInt_append
11:59:16 <TuringTesint> hmmm
12:01:11 <TuringTesint> Anyway...They lazy data structure challenge at the moment is seeing if Ketil's Trie-based solution to http://haskell.org/hawiki/KnucleotideEntry can be made generic and still fast. (#5 in the table of contents)
12:04:05 <palomer> :o
12:05:05 <TuringTest> palomer: ?
12:05:31 <palomer> ??
12:06:03 <TuringTest> palomer: And you are happiness incarnate because...?
12:06:49 <chrisbrown> does anyone happen to know the unix command to search a directory for a string (i.e. a data type name)?
12:07:05 <jethr0> grep -r
12:07:21 <jethr0> grep -ri "data type name" *
12:07:25 <chrisbrown> ah
12:07:36 <jethr0> r for recursive, i for case invariant
12:07:45 <ihope> @djinn Not (Not (And True True))
12:07:46 <lambdabot> f a = a ((), ())
12:07:49 <TuringTest> But you may with . instead of * if you have hidden files
12:07:50 <ihope> Whoa.
12:07:59 <ihope> @djinn Not (Not a) -> a
12:08:00 <lambdabot> -- f cannot be realized.
12:08:09 <ihope> @djinn Not (Not (Not a) -> a)
12:08:09 <chrisbrown> cheers!
12:08:10 <lambdabot> -- f cannot be realized.
12:08:23 <TuringTest> @type And
12:08:25 <lambdabot> Not in scope: data constructor `And'
12:08:28 <ihope> @djinn-env
12:08:29 <lambdabot> data () = ()
12:08:29 <lambdabot> data Either a b = Left a | Right b
12:08:29 <lambdabot> data Maybe a = Nothing | Just a
12:08:29 <lambdabot> data Bool = False | True
12:08:29 <lambdabot> data Void
12:08:31 <lambdabot> type Not x = x -> Void
12:08:33 <lambdabot> type And a b = (a, b)
12:08:35 <lambdabot> type Or a b = Either a b
12:08:38 <lambdabot> type False = Void
12:08:39 <lambdabot> type True = ()
12:08:41 <lambdabot> type Xor a b = Not (Or a b -> And a b)
12:08:46 <ihope> And, Or, False, True, and Xor are my additions.
12:08:58 <Cale> @djinn Not (Not (Not a)) -> Not a
12:08:59 <lambdabot> f a b = void (a (\ c -> c b))
12:09:10 * TuringTest nods
12:09:35 <ihope> Hmm...
12:09:45 <ihope> I was thinking what it would be like if Not were a monad.
12:09:55 <ihope> But that would be tricky to implement :-P
12:10:09 <ihope> You'd need both a -> Not a and Not (Not a) -> Not a.
12:10:14 <ihope> Neither is possible to do.
12:11:00 <int-e> const undefined ...
12:11:33 <Cale> @djinn a -> Not (Not a)
12:11:34 <lambdabot> f a b = b a
12:11:52 <Cale> @djinn Not (Not (Not (Not a))) -> Not (Not a)
12:11:53 <lambdabot> f a b = void (a (\ c -> void (c b)))
12:12:16 <Cale> @djinn (a -> b) -> (Not (Not a) -> Not (Not b))
12:12:18 <lambdabot> f a b c = void (b (\ d -> c (a d)))
12:12:46 <Cale> Not . Not is possibly a monad.
12:13:18 <ihope> True.
12:13:28 <Cale> you still have to check the laws
12:13:43 <ihope> Should I add the law of double negation or whatever to @djinn?
12:14:19 <lispy> what is voeid?id?
12:14:21 <Cale> @djinn-add type NotNot a = Not (Not a)
12:14:22 <lispy> er void
12:14:30 <Cale> @djinn-env
12:14:31 <lambdabot> data () = ()
12:14:31 <lambdabot> data Either a b = Left a | Right b
12:14:31 <lambdabot> data Maybe a = Nothing | Just a
12:14:31 <lambdabot> data Bool = False | True
12:14:31 <lambdabot> data Void
12:14:33 <lambdabot> type Not x = x -> Void
12:14:35 <lambdabot> type NotNot a = Not (Not a)
12:14:36 <ihope> void :: Void -> a
12:14:37 <lambdabot> type And a b = (a, b)
12:14:39 <lambdabot> type Or a b = Either a b
12:14:41 <lambdabot> type False = Void
12:14:43 <lambdabot> type True = ()
12:14:45 <lambdabot> type Xor a b = Not (Or a b -> And a b)
12:14:57 <ihope> Hmm, NotNot...
12:14:59 <lispy> void = const undefined
12:15:04 <lispy> ?
12:15:11 <ihope> Well, it could be.
12:15:21 <ihope> That is, there's no reason for it not to be.
12:15:24 <int-e> @djinn (a -> b) -> NotNot a -> NotNot b
12:15:24 <lambdabot> f a b c = void (b (\ d -> c (a d)))
12:15:25 <palomer> not not being a monad would make me happy
12:15:40 <ihope> It will never actually be evaluated.
12:16:03 <ihope> Well... it might, but you're going to produce an error anyway.
12:16:17 <lispy> actually, void = undefined woudl work too because of the polymorphic nature of undefined
12:16:54 <ihope> @djinn (a -> b) -> Not b -> Not a
12:16:55 <lambdabot> f a b c = b (a c)
12:17:07 <ihope> @djinn (Not a -> Not b) -> b -> a
12:17:08 <lambdabot> -- f cannot be realized.
12:17:14 <ihope> Should I add that last one?
12:17:19 <Cale> add it?
12:17:27 <ihope> I can do that, right?
12:17:30 <int-e> no you should not
12:17:32 <Cale> as a type
12:18:18 <ihope> > case 2 of 3 -> 4
12:18:20 <lambdabot>  Non-exhaustive patterns in case
12:18:39 <Cale> @djinn-add type Contrapositive a = (Not a -> Not b) -> (b -> a)
12:18:44 <Cale> @djinn-add type Contrapositive a b = (Not a -> Not b) -> (b -> a)
12:18:46 <lambdabot> Cannot parse command
12:19:22 <ihope> Well, in the @djinn docs it says it's possible to enter things like contpos :: (Not a -> Not b) -> b -> a
12:19:35 <ihope> Is that possible in the lambdabot version?
12:19:54 <Cale> @help djinn
12:19:56 <lambdabot> Generates Haskell code from a type.
12:19:56 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
12:20:05 <Cale> @listcommands djinn
12:20:06 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-
12:20:06 <lambdabot> ver
12:20:12 <Cale> hmm
12:20:34 <Cale> @djinn-add contrapositive :: Contrapositive a b
12:20:35 <lambdabot> Cannot parse command
12:21:00 <Beelsebob> @help djinn-add
12:21:02 <lambdabot> Define a new function type or type synonym
12:21:03 <ihope> Guess it won't work...
12:21:05 <Beelsebob> :/
12:21:18 <ihope> There's also Not (Not a) -> a.
12:23:06 <palomer> type aliases are considered type constructors, right?
12:23:28 <ihope> You mean the ones defined with type?
12:23:36 <palomer> type foo a = bar a 
12:23:39 <ihope> Oh. Yes.
12:23:47 <ihope> ...I think.
12:24:13 <lispy> i always thought of it as a 1 for 1 text substitution :)
12:24:19 <ihope> @djinn a -> (Or a a)
12:24:20 <lambdabot> Cannot parse command
12:24:20 <lambdabot> f :: a -> Or a a
12:24:20 <lambdabot> f = Left
12:24:32 <ihope> @djinn Or a a -> a
12:24:33 <lambdabot> Cannot parse command
12:24:33 <lambdabot> f :: Or a a -> a
12:24:33 <lambdabot> f a =
12:24:33 <lambdabot>   case a of
12:24:33 <lambdabot>   Left b -> b
12:24:35 <lambdabot>   Right c -> c
12:24:41 <ihope> Hmm. Something's... weird.
12:24:46 <ihope> Ah well.
12:25:23 <ihope> Now, I know (a -> And a a) and (And a a -> a) would work...
12:25:51 <ihope> @djinn Or a (Or b c) -> Or (Or a b) c
12:25:55 <lispy> ihope: yeah, lambdabot was acting strange last night too, couldn't find the getRandomList or something was returning []
12:25:58 <lambdabot> Cannot parse command
12:26:00 <lambdabot> f :: Or a (Or b c) -> Or (Or a b) c
12:26:02 <lambdabot> f a =
12:26:04 <lambdabot>   case a of
12:26:06 <lambdabot>   Left b -> Left (Left b)
12:26:07 <palomer> type a b= ((->) b) <--is a a monad?
12:26:08 <lambdabot>   Right c -> case c of
12:26:10 <lambdabot>      Left d -> Left (Right d)
12:26:12 <lambdabot>      Right e -> Right e
12:26:21 <ihope> palomer: Reader monad, I think.
12:26:31 <palomer> so a must be a constructor
12:27:28 <int-e> @libsrc Control.Monad.Reader
12:27:29 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Reader.
12:27:29 <lambdabot> hs
12:28:10 <ihope> Oops. I've been transforming Either into Or...
12:28:17 <ihope> That's somewhat pointless.
12:28:56 <ihope> Here's another one, I think:
12:28:57 <ihope> Not (And a b) -> Or (Not a) (Not b)
12:29:32 <ihope> Switching Or and And works, though.
12:29:47 <palomer> wait, is NotNot a -> a provable?
12:29:59 <ihope> @djinn NotNot a -> a
12:30:01 <lambdabot> Cannot parse command
12:30:01 <lambdabot> -- f cannot be realized.
12:30:12 <int-e> palomer: not in inuitionistic logic (as I learned today)
12:30:41 <ihope> So it looks like DeMorgan's law works, except for that one case there.
12:30:53 <palomer> the formulae djinn parses aren't exactly in the language of intuitionistic language
12:31:11 <palomer> I don't know if the logical rules match (under the obvious morphism)
12:31:28 <palomer> btw, proving that not not a -> a is unprovable can be done semantically
12:31:30 <palomer> which is really cool
12:32:16 <ihope> @djinn-add (<->) a b = And (a -> b) (b -> a)
12:32:17 <lambdabot> Cannot parse command
12:32:23 <ihope> @djinn-env
12:32:24 <lambdabot> data () = ()
12:32:24 <lambdabot> data Either a b = Left a | Right b
12:32:24 <lambdabot> data Maybe a = Nothing | Just a
12:32:24 <lambdabot> data Bool = False | True
12:32:24 <lambdabot> data Void
12:32:26 <lambdabot> type Not x = x -> Void
12:32:28 <lambdabot> Error: type variable not bound b
12:32:30 <lambdabot> type NotNot a = Not (Not a)
12:32:32 <lambdabot> type And a b = (a, b)
12:32:34 <lambdabot> type Or a b = Either a b
12:32:36 <lambdabot> type False = Void
12:32:38 <lambdabot> type True = ()
12:32:40 <lambdabot> type Xor a b = Not (Or a b -> And a b)
12:32:52 <ihope> Um...
12:32:58 <ihope> @djinn True <-> True
12:32:58 <int-e> @mode
12:32:58 <lambdabot> Maybe you meant: code more
12:32:59 <lambdabot> Cannot parse command
12:32:59 <lambdabot> Cannot parse command
12:33:02 <int-e> @more
12:33:19 <palomer> here's the basic idea: assign a to any set. pick any two lambda terms a and b. not {a} = {}, not not {a} = all lambda terms, so not not {a} -> {a} must be K a
12:33:24 <palomer> repeat with b
12:34:49 <palomer> such an easy proof, so elegant
12:35:51 <palomer> of course, you need pages and pages on the interpretations of AF_2 to understand this proof
12:35:52 <palomer> :P
12:36:04 <palomer> the syntactic proof is lame, imho
12:36:06 <ihope> Heh.
12:36:08 <palomer> it relies on cut elimination
12:36:11 * palomer pukes
12:37:56 <ihope> True -> Either a (Not a)
12:38:15 <palomer> @djinn True -> Either a (Not a)
12:38:16 <lambdabot> Cannot parse command
12:38:16 <lambdabot> -- f cannot be realized.
12:38:22 <palomer> @djinn Either a (Not a)
12:38:24 <lambdabot> Cannot parse command
12:38:24 <lambdabot> -- f cannot be realized.
12:38:34 <ihope> Heh...
12:38:47 <palomer> what's wrong with djinn?
12:38:54 <ihope> I suppose that doesn't work for some types, like ((a -> b) -> a) -> a
12:39:17 <palomer> the proof that it cannot be proven?
12:39:19 <palomer> that's also trivial
12:39:39 <palomer> (the proof is almost identical, actually)
12:40:05 <palomer> you can also use this methods to categorize all intutionistic proofs of (X -> (X -> X) -> X) (the church numerals)
12:40:22 <palomer> s/methods/method
12:40:48 <ihope> Given that if A implies B then A is true, prove that A is true.
12:40:50 <int-e> @djinn (f -> g) -> (f -> Not g) -> Not f
12:40:51 <lambdabot> Cannot parse command
12:40:51 <lambdabot> f :: (f -> g) -> (f -> Not g) -> Not f
12:40:51 <lambdabot> f a b c = b c (a c)
12:41:14 <ihope> Suppose A is false. This would mean that A does not imply B.
12:42:16 <ihope> False does not imply B...
12:42:25 <ihope> But False implies everything.
12:42:25 <palomer> what are you trying to prove?
12:42:38 <ihope> I'm trying to prove that there's an ((a -> b) -> a) -> a.
12:42:44 <ihope> Oddly enough, I think I was successful.
12:42:49 <palomer> a what?
12:42:51 <palomer> a proof of?
12:43:06 <palomer> well, that formula is true in every non empty model
12:43:14 <mattam> i don't think there is a constructive proof of this formula
12:43:21 <palomer> but, intutionistically, it's not provable
12:43:28 <ihope> Eh, I'm confusing myself.
12:43:31 <palomer> and, quite frankly, it's a very strange formula
12:43:35 <Cale> @djinn a -> Not a -> b
12:43:36 <lambdabot> Cannot parse command
12:43:36 <lambdabot> f :: a -> Not a -> b
12:43:36 <lambdabot> f a b = void (b a)
12:43:46 <palomer> cannot parse command?
12:43:50 <palomer> is djinn broken?
12:43:56 <Cale> @djinn a -> a
12:43:58 <lambdabot> Cannot parse command
12:43:58 <lambdabot> f :: a -> a
12:43:58 <lambdabot> f a = a
12:43:58 <ihope> Yes. Temporarily.
12:44:02 <ihope> @djinn-env
12:44:03 <lambdabot> data () = ()
12:44:03 <lambdabot> data Either a b = Left a | Right b
12:44:03 <lambdabot> data Maybe a = Nothing | Just a
12:44:03 <lambdabot> data Bool = False | True
12:44:03 <lambdabot> data Void
12:44:06 <lambdabot> type Not x = x -> Void
12:44:07 <lambdabot> Error: type variable not bound b
12:44:09 <lambdabot> type NotNot a = Not (Not a)
12:44:11 <lambdabot> type And a b = (a, b)
12:44:14 <lambdabot> type Or a b = Either a b
12:44:16 <lambdabot> type False = Void
12:44:17 <lambdabot> type True = ()
12:44:18 <Cale> oh
12:44:20 <lambdabot> type Xor a b = Not (Or a b -> And a b)
12:44:22 <Cale> oops
12:44:29 <ihope> @djinn-clr
12:44:37 <ihope> @djinn-env
12:44:38 <lambdabot> data () = ()
12:44:38 <lambdabot> data Either a b = Left a | Right b
12:44:38 <lambdabot> data Maybe a = Nothing | Just a
12:44:38 <lambdabot> data Bool = False | True
12:44:38 <lambdabot> data Void
12:44:40 <lambdabot> type Not x = x -> Void
12:45:01 <ihope> Okay, now to put it all back...
12:45:57 <ihope> @djinn Xor Bool Void
12:45:58 <lambdabot> -- f cannot be realized.
12:46:05 <ihope> Where'd Xor go?
12:47:08 <int-e> you deleted it along with much of the rest
12:47:20 <MarcWeber> Is network the right library to retrieve files via http?
12:47:44 <ihope> Let's see...
12:48:21 <ihope> @djinn-add Xor a b = Not (Or a b -> And a b)
12:48:22 <lambdabot> Cannot parse command
12:48:27 <ihope> Ee.h
12:48:41 <ihope> @djinn-add type Xor a b = Not (Or a b -> And a b)
12:48:51 <ihope> I broked it again...
12:48:55 <ihope> Ah well.
12:49:31 <ihope> Oh. It's not broken.
12:49:59 <davidhouse> @djinn a -> b -> a
12:50:01 <lambdabot> f a _ = a
12:50:07 <davidhouse> yeah, it's not broken
12:50:16 <davidhouse> (although it could just have said 'const' :) )
12:50:28 <ihope> @. pl djinn a -> b -> a
12:50:30 <lambdabot> f = const
12:52:02 <davidhouse> MarcWeber: http://haskell.org/haskell
12:52:19 <davidhouse> err
12:52:23 <davidhouse> haskell.org/http
12:54:30 <MarcWeber> ah thanks!
12:55:30 <ihope> Is it possible to define Void in "normal" Haskell?
12:55:42 <ihope> Or, rather, GHC's rendition?
13:00:12 <davidhouse> @hoogle ResponseCode
13:00:13 <lambdabot> No matches found
13:15:48 <ihope> @djinn Not ((a -> a) -> a)
13:15:49 <lambdabot> -- f cannot be realized.
13:16:04 <ihope> Oh, right.
13:23:16 <musasabi> Is there a good way to implement bit-fields in Haskell?
13:24:26 <musasabi> data Field1 = A | B; data Field2 = C | D | E | F; ... ; data Config = Config { a :: Field1, b :: Field2, ... } ?
13:31:11 <Baughn> What sort of editor do you use? Emacs' (haskell-mode's, rather) automatic identation doesn't match other code at all
13:31:36 <Baughn> So I'm wondering if I've misconfigured something
13:33:07 <ihope> Let
13:33:15 <ihope> 's see...
13:33:39 <davidhouse> "data Header = Header HeaderName String". how do i extract the HeaderName, given a Header?
13:34:09 <ihope> @pl interleave [] [] = []; interleave (x:xs) (y:ys) = x:y:interleave x xs
13:34:10 <lambdabot> (line 1, column 18):
13:34:10 <lambdabot> unexpected "="
13:34:10 <lambdabot> expecting variable, "(", operator or end of input
13:35:00 <ihope> @pl Control.Monad.Fix.fix \interleave x y -> case (x,y) of ([],[]) -> []; (x:xs,y:ys) -> x : y : interleave xs ys
13:35:02 <lambdabot> (line 1, column 23):
13:35:02 <lambdabot> unexpected "\\"
13:35:02 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
13:35:11 <ihope> @pl Control.Monad.Fix.fix (\interleave x y -> case (x,y) of ([],[]) -> []; (x:xs,y:ys) -> x : y : interleave xs ys)
13:35:11 <lambdabot> (line 1, column 65):
13:35:11 <lambdabot> unexpected ">"
13:35:11 <lambdabot> expecting variable, "(", operator or ")"
13:35:35 <ihope> @pl case foo of bar -> baz
13:35:36 <lambdabot> (line 1, column 17):
13:35:36 <lambdabot> unexpected ">" or "-"
13:35:36 <lambdabot> expecting variable, "(", operator or end of input
13:35:43 <ihope> Grh.
13:37:59 <davidhouse> anyone?
13:39:45 <edwinb> foo (Header h s) = h
13:41:51 <ihope> You could define a function called "header", too:
13:42:11 <jethr0> davidhouse: alternatively use "data Header {headerName :: HeaderName, headerStr :: String}"
13:42:31 <ihope> header f (Header h s) = f h s
13:42:38 <jethr0> data Header = Header ...
13:43:25 <ihope> Whoa... I'm in Madison, Wisconsin?
13:43:37 <ihope> Well, /whois never lies...
13:44:04 <davidhouse> jethr0: well, Header's part of Network.HTTP, so i can't change its definition :)
13:44:07 <jethr0> it's called whois, not whereis!
13:44:26 <ihope> whereis Unknown command
13:44:32 <jethr0> :)
13:44:51 <ihope> Hmm...
13:45:06 <ihope> I typed /:) and hit enter. Nothing happened.
13:45:10 <ihope> No error message...
13:45:38 <jethr0> on console 1: Irssi: unknown command: :)
13:46:27 <jethr0> a
13:54:49 <MarcWeber> I get this error wehn trying to install MySQL (from HSQL): Couldn't match `PackageDescription' against `LocalBuildInfo'
13:55:02 <MarcWeber> Have there been any recent changes to cabal?
13:57:41 <Lemmih> MarcWeber: Yeah.
13:59:33 <MarcWeber> Lemmih Have there also been same changes concerning substitutioins ${name}  of .pkg files?
14:00:42 <Lemmih> I don't know.
14:01:10 <MarcWeber> Is the problem easy to fix, what do you think?
14:02:26 <Lemmih> Updating your Cabal will probably fix it.
14:02:30 <Baughn> What sort of editor do you use? Emacs' (haskell-mode's, rather) automatic identation doesn't match other code at all, so I'm wondering if I've misconfigured something.
14:03:29 <MarcWeber> vim
14:03:40 <Lemmih> I'm using Emacs with haskelll-mode's indentation.
14:04:13 <MarcWeber> Lemmih Which source to take to update cabal?
14:05:04 <Baughn> Lemmih: Does "if num = 0\nthen num" sound right, with the t immediately under the 0?
14:05:06 <MarcWeber> make boot of fptools/libraries/Cabal seems to require ghc-inplace.. which I wasn't able to build yet. Or must I exclude ghc from build targets to force using another compiler?
14:06:33 <Lemmih> Baughn: You can cycle through several levels of indentation by pushing 'tab'.
14:06:55 <musasabi> and usually different projects have different indentation styles
14:06:57 <Baughn> Lemmih: Yes, but the level left of that leaves it under the 'i' in if.
14:08:21 <Lemmih> Baughn: Yep, haskell-mode's indentation sucks (: I just put two spaces manually on 'if' and 'case'.
14:08:34 <Lemmih> MarcWeber: Did you get Cabal from http://cvs.haskell.org/darcs/cabal?
14:08:56 <MarcWeber> Not yet.Thanks
14:09:03 <Baughn> Lemmih: Guess I'll have a shot at fixing it, then
14:11:03 <musasabi> Is there a darcsweb for haskell.org projects?
14:12:09 <ihope> Lambdabot doesn't like the joke about Descartes and the beer.
14:12:26 <ihope> @djinn (iThink -> iAm) -> Not iThink -> Not iAm
14:12:27 <lambdabot> -- f cannot be realized.
14:12:50 <Baughn> Oh, but that's wrong.
14:13:06 <Baughn> @djinn iThink -> iAm ; Not iThink -> Not iAm
14:13:07 <lambdabot> Cannot parse command
14:13:31 <ihope> Um...
14:13:53 <Baughn> ..doesn't make much sense, no
14:14:06 <pundai> which compilers do you use
14:14:12 <ihope> GHCi
14:14:17 <Lemmih> GHC.
14:14:28 <ihope> You know, I find it amazing that it's possible to implement XOR in Haskell's type system.
14:15:05 <Heffalump> in what sense?
14:15:05 <ihope> It's, like, a type that exists if and only if exactly one of its component types exists.
14:15:16 <ihope> @djinn Xor True False
14:15:17 <pundai> so can the lambdabot tell me a tutorial for haskell
14:15:17 <lambdabot> f a =
14:15:17 <lambdabot>   case a (Left ()) of
14:15:17 <lambdabot>   (_, b) -> b
14:15:23 <ihope> @djinn Xor True True
14:15:24 <lambdabot> -- f cannot be realized.
14:15:28 <ihope> @where tutorial
14:15:29 <lambdabot> I know nothing about tutorial.
14:15:31 <ihope> Hmm...
14:15:44 <ihope> http://www.haskell.org/tutorial/
14:15:52 <ihope> @wher
14:15:54 <lambdabot> Maybe you meant: where where+
14:15:57 <ihope> @help where+
14:15:59 <lambdabot>  @where+ <key> <elem>, define an association
14:16:05 <Lemmih> @where yaht
14:16:06 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
14:16:09 <Lemmih> @learning
14:16:10 <lambdabot> Unknown command, try @listcommands.
14:16:13 <ihope> @where+ tutorial http://www.haskell.org/tutorial/
14:16:14 <lambdabot> Done.
14:16:28 <pundai> does haskell have closures
14:16:50 <ihope> Maybe in a monad...
14:17:14 <Lemmih> What do you mean by closures?
14:18:00 <ihope> Like variables that certain functions have access to, I think.
14:18:06 <musasabi> pundai: aren't closures usually associated with a halted context with *mutable* variables.
14:18:17 <ihope> Like one that returns a higher value every time it's called.
14:18:29 <ihope> I think it's possible in a monad, or maybe an arrow.
14:18:49 <musasabi> if it is a pure value, then it is just about implementation. (if I understood the question right)
14:19:14 <musasabi> pundai: You can do the things you would use closures in other languages in Haskell.
14:19:25 <wolverian> @where hide 
14:19:26 <lambdabot> http://haskell.org/haskellwiki/HIDE
14:19:33 * MarcWeber is going for sleep while downloading 700 Cabal patches..
14:20:15 <pundai> erg, how are you
14:20:17 <wolverian> damn, hide needs a crapload of manually compiled things :)
14:20:56 <pundai> Lemmih, i meant being able to pass around functions like values
14:21:14 <Lemmih> pundai: Sure, Haskell got higher-order functions.
14:21:16 <musasabi> MarcWeber: complain to SyntaxNinja. I think a darcs optimize may solve it, but I don't remember much of that.
14:21:42 <Heffalump> closures are not normally automatically associated with mutable variables.
14:21:59 <Heffalump> In a language where most variables are mutable, it's often the case that a closure will have them too.
14:22:13 <pundai> Heffalump,  ithink the mutable refers to variables that persist
14:22:14 <Lemmih> pundai: There's no difference between values and functions in Haskell.
14:22:23 <pundai> Lemmih, so are types first class too?
14:22:40 <pundai> im sorry, im gonna read the tutorial but the one that i came across, none of it even ran in ghci
14:22:54 <musasabi> Heffalump: but if the values are immutable isn't it just a very simple thing? (if sharing does not need to be preserved)
14:23:43 <musasabi> pundai: for tutorial use, you might want to run ghci inside emacs and edit the source file in one buffer and then look at the evaluated results in the ghci buffer.
14:23:44 <pundai> musasabi, values of what
14:23:45 <Lemmih> pundai: Write the code to a file and then load the file in GHCi.
14:23:59 <pundai> so ghci is not a haskell interpreter
14:24:06 <ndm> musasabi: darcs tag, not darcs optimise
14:24:06 <musasabi> ghci is a haskell interpreter
14:24:21 <Cale> GHCi is an interactive Haskell environment.
14:24:25 <Heffalump> musasabi: well, closures are quite simple.
14:24:33 <Cale> You can load compiled modules in it too.
14:24:34 <Lemmih> pundai: It is, but it only evaluates statements at the top-level.
14:24:43 <pundai> ok thats all i want to do
14:24:48 <ndm> pundai: are you using windows or linux?
14:24:49 <musasabi> pundai: but the read-eval loop does not parse e.g. data type declarations.
14:25:11 <pundai> ndm, linsux
14:25:19 <pundai> musasabi, oh k
14:25:33 <musasabi> Heffalump: closures + mutation + GC can be quite painfull when optimizing things.
14:25:51 <Cale> heh, winblows and linsux
14:26:35 <davidhouse> Lemmih, how far away from being usable is hIDE?
14:27:05 <davidhouse> if it's not so already
14:27:35 <Lemmih> davidhouse: Well, it can't save files yet.
14:27:46 <davidhouse> a minor drawback.
14:28:26 <davidhouse> Lemmih, so how long?
14:28:29 <Lemmih> Yeah, who needs to save files when we got typechecking while you type!
14:29:47 <lispy> heh, it seems like saving a file would be a relatively easy thing to implement :)
14:29:59 <Lemmih> davidhouse: It would go a /lot/ faster if I got some help with the design. (:
14:31:50 <Baughn> Lemmih: I'll probably burn for this, but I've put an  (extremely hackish) indentation fix at http://rafb.net/paste/results/nKufbB68.html. Do with it what you will.
14:35:14 <davidhouse> Lemmih: sorry, had to change rooms. what help do you need with the design?
14:36:33 * lispy sets Baughn on fire ;)
14:37:03 * jethr0 can't read elisp fluently, but is certain that Baughn deserves it
14:37:29 <Baughn> Well, yeah, but consider what I had to work with. Only the first function is mine.
14:38:03 <pesco> What's the current state of the art in Haskell-Land wrt. web apps?
14:38:18 <Baughn> Decoding this properly is going to take time; might as well rewrite the whole thing, really.
14:38:21 <Lemmih> davidhouse: HIDE is based on plugins. Everything is a plugin! The GUI, the editor, the syntax-highlighting, Cabal-integration, everything. This makes designing it a bit difficult.
14:38:53 <davidhouse> Lemmih: right, so jEdit to the extreme :) but you mean visual design?
14:38:55 <jethr0> i liked the part in the yi docs, where it goes on about rebooting yi while its running :)
14:39:11 <davidhouse> or code architecture design?
14:39:16 <jethr0> edit-compiling yi in itself while it's running
14:39:20 <Lemmih> davidhouse: I'm trying to figure out how plugins should interact with the editor.
14:40:17 <waern_> Lemmih, what about an irc channel for hide? I propose #haskell.hide 
14:45:58 <lispy> pesco: iirc there are two systems available, wash and hsp
14:47:46 <musasabi> HAppS works quite nicely.
14:48:21 <lispy> happs?
14:48:49 <pesco> musasabi: Can you comment on how "mature" happs is?
14:48:51 <lispy> that's not very googleable
14:48:59 <pesco> lispy: happs.org :)
14:49:11 <davidhouse> anyone recommend a terminal library?
14:49:18 <davidhouse> (terminal as in tty)
14:50:39 <musasabi> pesco: currently I am using it quite a lot for real needs and it works quite well.
14:50:56 <musasabi> but I am not really neutral.
14:51:01 <pesco> musasabi: Cool, what kind of real needs are those?
14:52:05 <lispy> musasabi: where can a see an example webapp running that uses happs?
14:54:28 <davidhouse> @hoogle listToMaybe
14:54:29 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
14:55:26 <lispy> > Data.Maybe.listToMaybe [1,2]
14:55:28 <lambdabot> Just 1
14:55:41 <lispy> > Data.Maybe.listToMaybe []
14:55:41 <lambdabot> Add a type signature
14:55:53 <musasabi> client code (thus I cannot contractually release anything)
14:55:53 <lispy> > Data.Maybe.listToMaybe ([]::[Int])
14:55:55 <lambdabot> Nothing
14:55:56 <wolverian> hm.. cabal refuses to configure yi.
14:56:30 <lispy> list to maybe is an odd function.  Can't say i've ever wanted it
15:01:01 <wolverian> ah, too old cabal.
15:04:02 <wolverian> hm.. now ghc-api doesn't build. not sure if I need it, though.
15:04:24 <Lemmih> You don't.
15:04:55 <Lemmih> You need the real ghc api from ghc-head.
15:05:12 <wolverian> argh.
15:05:17 <wolverian> I need to pull ghc too? :)
15:05:23 <Lemmih> It's all in the README (:
15:05:29 <wolverian> which one?
15:05:33 <wolverian> hide's?
15:05:36 <MarcWeber> Is cabal configured/ compiled with cabal? I can't find the GNUMakefile mentioned in README/
15:05:55 <Lemmih> wolverian: Yes.
15:05:57 <wolverian> oh, there we go.
15:06:03 <wolverian> Lemmih, thanks.
15:06:12 <wolverian> what the heck is ghc.hide? :)
15:06:30 <MarcWeber> ghc-package.exe hide ;-)
15:06:39 <Lemmih> wolverian: It's a stable version of ghc head.
15:06:40 <MarcWeber> aeh.. ghc-pkg.exe hide 
15:07:04 <MarcWeber> (?)
15:07:06 <wolverian> Lemmih, hide really doesn't hide its dependencies, eh! heh heh heh cough
15:08:12 <MarcWeber> Lemmih: How to make Cabal?
15:08:27 <Lemmih> MarcWeber: Cabal is a cabal package (:
15:08:29 <wolverian> I pulled gtk2hs, not gtk2hs.hide. is that sufficient?
15:09:05 <Lemmih> wolverian: Yeah, it should be.
15:09:25 <MarcWeber> Yeah... shi..! Setup.hs:52:1: lexical error..
15:09:26 <wolverian> good..
15:09:51 <Lemmih> MarcWeber: runhaskell -i Setup.lhs ...
15:10:44 <wolverian> does ghc.hide behave with ghc already installed?
15:10:54 <MarcWeber> That helps till line 91 : <interactive>:1:91:
15:10:54 <MarcWeber>     Failed to load interface for `Main':
15:11:01 <Lemmih> wolverian: You can install it locally.
15:11:18 <wolverian> doing that.
15:11:21 <wolverian> thanks 
15:11:32 <wolverian> hm, do I need ALUT? it didn't find a header
15:11:38 <wolverian> oh, OpenAL..
15:11:39 <MarcWeber> and -i isn't listed in runhaskell --help
15:11:49 <wolverian> I would hope hIDE doesn't need it.. :)
15:12:25 <Lemmih> No need for ALUT (yet!) (:
15:12:30 <wolverian> heh
15:12:53 <wolverian> curiosity carries me infinitely far sometimes
15:14:35 <MarcWeber> Lemmih:  Will there be atime when cabal supports binary distributions ? :-)
15:16:02 <MarcWeber> Lemmih: There is main missing in Setup.hs
15:21:59 <MarcWeber> Recommended way of installing: ghc-pkg.exe unregister Cabal.. haha can't work. Can I reregister Cabal from my ghc distribution?
15:28:48 <foxy> Is the GHC lexer/parser compiled in phase 1  or phase 2?  Is there a way to have phase 1 compiled for performance and phase 2 for debugging?
15:29:10 <wolverian> I don't know, but it's taking ages! 
15:30:12 <foxy> and is there a way to use the version of GHC I've compiled in-place so that my 6.4.1 is the one normally used?
15:32:42 <Cale> what platform are you on?
15:32:53 <Cale> are you planning to work on GHC?
15:33:21 <Lemmih> foxy: You can use the ghc-inplace binary or install it locally.
15:33:44 <greenrd> wolverian, is it stuck on compiling the compiler? if so look at top, and if it's stuck on make you might be seeing a make bug
15:33:45 <foxy> lemmih, OK, thanks.
15:34:19 <foxy> Cale: Win98 :) -- I'm going to try to hack a prototype for programmable bracket syntax
15:34:34 <wolverian> greenrd, yes. 
15:34:50 <wolverian> 19 minutes of cpu time now.. 
15:34:53 <greenrd> ok, use make 3.80, that works
15:34:54 <foxy> cale: like infix operators (I also have a linux platform)
15:35:23 <wolverian> greenrd, sheesh. :) what's the easiest way to obtain that? 
15:35:26 <incomplete> What are brackets?
15:35:46 <incomplete> (I'm xerox but unfortunately cut out of "xerox"'s shell)
15:35:53 <incomplete> ( Howdy (: )
15:36:34 <foxy> incomplete: -> e.g. [ x + 1 | x <- [1..] ]
15:36:36 <Cale> foxy: okay cool. Just making sure that you're compiling it for a good reason :)
15:37:03 <Cale> foxy: list comprehensions
15:37:20 <incomplete> I see :-)
15:37:33 <foxy> incomplete: or (| _ |) :: a -> Cata a
15:38:05 <astrolabe> can I have more than one '<-' in a list comprehension?
15:38:06 <incomplete> 'Cata' being what?
15:38:11 <incomplete> astrolabe: yup.
15:38:20 <astrolabe> goody
15:38:36 <foxy> incomplete: catamorphism (please don't ask me any more about catamorphisms, I'm a bit rusty)
15:38:37 <incomplete> astrolabe: you could also have multiple '|' (parallel list comprehensions), but you'd need -fglasgow-exts.
15:39:07 <wolverian> greenrd, got past it now, thanks!
15:39:15 <Cale> > [(x,y) | x <- [1..3], y <- [1..3]]
15:39:17 <lambdabot> [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:40:00 <astrolabe> > [(a,b) | a<-[1..3], b<-[a..4]]
15:40:02 <lambdabot> [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4)]
15:40:14 * astrolabe hugs haskell
15:40:28 <gzl> how does the multiple '|' work?
15:40:51 <gzl> I mean, what does it do?
15:40:52 <astrolabe> Yeah what's the advantage to it?
15:41:11 <Cale> > [(x,y) | x <- [1..3] | y <- [1..3]
15:41:13 <lambdabot>  parse error on input `}'
15:41:13 <Cale> > [(x,y) | x <- [1..3] | y <- [1..3]]
15:41:14 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
15:41:20 <Cale> well, anyway
15:41:28 <Cale> that would give [(1,1),(2,2),(3,3)]
15:41:32 <gzl> aha
15:41:48 <astrolabe> I see. Thanks.
15:43:19 <greenrd> wolverian, did you switch make versions, or did you just wait for it to finish? for me I left it overnight and it was still going, so I switched
15:43:55 <wolverian> greenrd, switched
15:44:08 <greenrd> ah ok
15:44:11 <incomplete> Cale: how does it translate exactly?
15:44:28 <TuringTest> incomplete: it desugars into a zip
15:45:28 <TuringTest> http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/syntax-extns.html#parallel-list-comprehensions
15:45:48 <incomplete> Ah-ha!  Thanks.
15:46:50 <TuringTest> incomplete: It is not the best extensions, as it doe not document what happens to more complex expressions.
15:47:52 <TuringTest> > [x | y <- [1..10], let x = 2*y, mod x 3 == 1]
15:47:54 <lambdabot> [4,10,16]
15:48:02 <ihope> Now how do we implement numbers in Haskell's type system?
15:48:13 <TuringTest> But I would not know how to combine things like that with parallel list comprehensions
15:48:27 <ihope> Zero = Void; Succ = Maybe?
15:48:40 <incomplete> data Nat = Zero | Succ Nat -- ?
15:48:51 <TuringTest> ihope: I prefer balanced ternary
15:48:55 <ihope> The types.
15:49:02 <ihope> TuringTest: eep.
15:49:17 <ihope> All the numbers as types.
15:49:29 <incomplete> Oleg's work...
15:50:01 <TuringTest> There is that base-10 system for types.
15:50:22 <incomplete> G'night!
15:50:37 <ihope> Base-10? Eew... who'd ever want to use base-10?
15:50:44 <ihope> ;-)
15:51:16 <TuringTest> If you ever have to type it.
15:51:36 <TuringTest> ihope: http://www.haskell.org/tmrwiki/NumberParamTypes
15:52:41 <lispy> (looking at angband source code) for being old C code and having a very long project life, this code is really well commented.
15:53:10 <sh10151> lispy: Ben Harrison cleaned it up at 3.0
15:53:22 <sh10151> lispy: a lot is scripted in Lua now I think
15:53:29 <lispy> sh10151: ah cool
15:53:58 * lispy was thinking of writing a game engine (some day) and borrowing ideas from angband's engine
15:55:38 <lispy> i always find that angband never really loses its charm and that the game is amazingly complex
15:55:44 <sh10151> indeed
15:56:08 <sh10151> there's also langband
15:56:16 <sh10151> judging by your nick you may be interested
15:56:18 <lispy> the lisp based angband?
15:56:20 <sh10151> yes
15:56:45 <lispy> i looked at it a little, but it was very alpha back then
15:56:46 <ihope> Would Zangband be a Z-machine?
15:57:03 <lispy> ihope: zangband is a very popular variant actually :)
15:57:44 <ihope> Is that to say that Z-machine isn't very popular?
15:57:57 <rep> nethack!
15:58:08 <ihope> Yay, NetHack!
15:58:10 <lispy> heh, i just meant that the name zangband is already taken :)
15:58:11 <astrolabe> Hey angband was created at Warwick Uni while I was there I think.
15:58:16 <ihope> Go Team Ant!
15:59:57 <foxy> ihope: check out http://www.mail-archive.com/haskell@haskell.org/msg18263.html and Oleg's homepage
16:00:10 <lispy> heh, so much of the code is labeled "hack" that it starts to lose its meaning :)
16:02:40 <sh10151> angband is a great game
16:02:53 <sh10151> unfortunately I need to learn roguelike commands to play conveniently
16:02:58 <sh10151> since I use my laptop a lot
16:03:03 <lispy> same here
16:03:33 <lispy> the normal commands are very engrained in my hands
16:03:52 <dons> @quit more randoms..
16:04:24 <Pseudonym> Haskell should get a roguelike interface.
16:04:30 <Pseudonym> You hit. The compiler hits...
16:04:30 <ihope> :-D
16:04:55 <Pseudonym> Killed by a monomorphism restriction on level 6.
16:05:06 <Heffalump> Oh, *that*'s what game semantics is all about.
16:05:22 <ihope> Well, I never use the keypad commands in NetHack.
16:05:23 <lispy> The type checker cannot unify [x3].  ****LOW HITPOINT WARNING****
16:05:26 * jethr0_ just set his genetic othello/reversi program to run. but right now it doesn't look very converging :(
16:05:56 <ihope> So the roguelike commands were "nice".
16:08:27 <musasabi> I think 
16:08:31 <musasabi> or not.
16:09:13 <musasabi> fighting the typechecker with compile time programs could be fun.
16:09:49 <musasabi> like the largest fac computable in binary numbers with GHCs typechecker (that terminates)
16:11:36 <wolverian> argh, ghc.hide build failed with unknown flags in  {-# OPTIONS #-} pragma: -fno-bang-patterns
16:12:39 <Yagi> hi
16:12:54 <TuringTest> musasabi: "Farther away, galaxy-sized intelligences beat incomprehensible rhythms against the darkness of the vacuum, trying to hack the Planck substrate into doing their bidding. " --Accelerando
16:15:44 <ihope> Let's see...
16:16:11 <ihope> ...Nope. Don't get it.
16:16:20 <ihope> Hmm...
16:17:05 <musasabi> wolverian: -fno-bang-patterns was added very recently into GHC, I think it exists only in the darcs version.
16:17:27 <musasabi> wolverian: you should be able to just remove them if you are using an older compiler.
16:17:34 <wolverian> oh. okay.
16:17:39 <wolverian> thanks
16:19:23 <TuringTest> ihope: ?
16:19:40 <Lemmih> wolverian: What file failed?
16:19:49 <ihope> Xor with types other than () and Void.
16:20:22 <wolverian> Lemmih, sorry, I lost it to the terminal void already. one of them with no-bang-patterns in it. I just removed all the no-bang-patterns and am recompiling
16:20:36 <ihope> Is it possible to define infix type constructors, or is -> special syntax?
16:21:03 <musasabi> ihope: it is possible.
16:21:12 <Heffalump> it is?
16:21:24 <ihope> What does the first character have to be?
16:21:32 <ihope> Or what set does it have to belong to, if...
16:22:00 <musasabi> data (:*:) a b = a :*: b
16:22:06 <musasabi> for example.
16:22:17 <ihope> So... a colon?
16:22:25 <Heffalump> oh, I didn't know that was possible.
16:22:27 <musasabi> of course one can have an infix type and a normal constructor etc.
16:22:54 <musasabi> ihope: at least a colon works, I don't remember the specifics, but the report should have them.
16:22:57 <ihope> @djinn a (:*:) b
16:22:58 <lambdabot> Cannot parse command
16:23:07 <ihope> Does @djinn like them?
16:23:22 <musasabi> probably not, djinn parses a subset of haskell
16:23:43 <musasabi> I don't think it likes anything infix
16:25:28 <Cale> Infix type constructors don't start with a colon
16:26:47 <musasabi> hmm, it wants -fglasgow-exts for that one?
16:27:26 <Cale> data a * b = a :*: b  -- this works fine in GHC with no options
16:27:42 <ihope> > blerh :: a :*: b
16:27:43 <lambdabot>  Not in scope: type constructor or class `:*:'
16:28:10 <ihope> @where djinn
16:28:10 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
16:28:18 <Cale> Which means that the type constructor is just called *, not :*:
16:28:21 <musasabi> hmm, seems that GHC deviates from Haskell98
16:28:34 <musasabi> "Unlike data constructors, infix type constructors are not allowed (other than (->))."
16:29:02 <musasabi> So GHC accepting those data declarations in H98 mode is wrong.
16:29:17 <ihope> So I can't use (&&) instead of AND in this @djinn stuff?
16:29:55 <Cale> GHC doesn't pretty print infix type constructors correctly either (except for (->))
16:30:06 <dons> musasabi, there's a few things like that. ! annotations for one.
16:35:18 <dons> my mistake, ! is valid H98.
16:35:21 <ihope> Let's see here...
16:35:24 <musasabi> Cale: yes, that is quite annoying.
16:35:26 <ihope> @djinn ((Either (Either True False, False) ((Either True True -> ((),())) -> Void) -> ((Either True False, False),(Either True True -> ((),())) -> Void)) -> Void) -> Void
16:35:26 <lambdabot> -- f cannot be realized.
16:35:29 <ihope> Ooh.
16:36:03 <dons> ihope, your intermixing types and values?
16:36:17 <ihope> No.
16:36:26 <ihope> s/True/()/ and s/False/Void/
16:37:18 <ihope> @djinn ((Either (Either () Void, Void) ((Either () () -> ((),())) -> Void) -> ((Either () Void, Void),(Either () () -> ((),())) -> Void)) -> Void) -> Void
16:37:18 <lambdabot> f a =
16:37:18 <lambdabot>   void (a (\ b ->
16:37:18 <lambdabot>      void (case b of
16:37:18 <lambdabot>        Left (c, d) -> case c of
16:37:18 <lambdabot>             Left _ -> d
16:37:21 <lambdabot>             Right e -> e
16:37:23 <lambdabot>        Right f -> f (\ _ -> ((), ())))))
16:37:38 <ihope> Um, so that means it works.
16:39:07 <ihope> I had a nice logic system going here.
16:39:48 <ihope> But I suppose the stuff you add with @djinn-add is about as permanent as chalk drawings on a sidewalk.
16:41:37 <foxy> could someone explain Pierce's law to me?  I know that it is not valid in intuitionistic logic.
16:41:45 <Pseudonym> Sure.
16:41:50 <Pseudonym> (A -> B) -> A -> A
16:42:01 <Pseudonym> Your exercise is to write a Haskell function with this type:
16:42:05 <Pseudonym> f :: (a -> b) -> a -> a
16:42:18 <Heffalump> The dungeon collapses. You die.
16:42:40 <ihope> const id
16:42:49 <ihope> Or, rather, f = const id
16:42:51 <Pseudonym> @type const id
16:42:52 <lambdabot> forall a b. b -> a -> a
16:43:17 <Pseudonym> Oh, hang on.
16:43:21 <Pseudonym> That's not Pierce's law, is it.
16:43:24 <foxy> @hoogle unsafeCoerce
16:43:25 <lambdabot> No matches found
16:43:28 <Pseudonym> ((a -> b) -> a) -> a
16:43:34 <Pseudonym> That's it.
16:43:44 <ihope> ($ const undefined)
16:43:50 <Pseudonym> Without using undefined.
16:43:52 <Pseudonym> Or recursion.
16:44:06 <ihope> ($ const (error ":-P"))
16:44:16 <jethr0_> f _ a = a
16:44:33 <foxy> @hoogle unsafeCast
16:44:33 <lambdabot> No matches found
16:44:55 <foxy> yeah, but what does it untuitively mean in classical logic?
16:45:27 <Pseudonym> Try solving it using a truth table.
16:45:43 <Pseudonym> Basically, (A -> B) -> A is logically equivalent to A.
16:45:46 <Pseudonym> In classical logic.
16:46:31 <ihope> Eh-whathuh?
16:46:41 <ihope> Where's the (A -> B) come from?
16:46:53 <Pseudonym> ((A -> B) -> A) -> A
16:46:54 <foxy> from a truth table I get that it has the same value as a?
16:47:01 <Pseudonym> It's the left-hand-side of the implication.
16:47:04 <Pseudonym> Right.
16:47:04 <ihope> Um.
16:47:39 <ihope> If (A -> B) -> A is logically equivalent to A, that means that there's some (A -> B) floating around, yes?
16:48:09 <Pseudonym> Actually, you can think of it this way.
16:48:15 <Pseudonym> forall B. A -> B
16:48:19 <foxy> ihope you're missing -> A on the RHS
16:48:28 <Pseudonym> That means that no matter what B is, A -> B.
16:48:40 <ihope> Um.
16:48:43 <Pseudonym> i.e. from A, you can prove anything.
16:48:51 <ihope> So A is false?
16:48:53 <Pseudonym> There's only one possible A that this can apply to, and that's false.
16:49:01 <Pseudonym> No, if the implication is true, A is false.
16:49:08 <ihope> Ah.
16:49:14 <Pseudonym> So forall B. A -> B means not A.
16:49:18 <Pseudonym> With me?
16:49:19 <ihope> Implication implies A implying falsehoos.
16:49:28 <Pseudonym> So you can think of it as:
16:49:33 <ihope> Yeah, I am.
16:49:36 <Pseudonym> (not A -> A) -> A
16:49:48 <ihope> That I don't get...
16:50:06 <Pseudonym> Under what circumstances is (not A -> A) true?
16:50:12 <Pseudonym> Basically, only if A is true.
16:50:24 <ihope> Um.
16:50:45 <ihope> Oh! (not A -> A), not (not (A -> A)).
16:50:58 <Pseudonym> Right.
16:51:04 <ihope> Yeah, I think I get it.
16:51:08 <Pseudonym> Cool.
16:51:25 <Pseudonym> The key thing here is that Pierce's law relies on the axiom not not A -> A
16:51:30 <Pseudonym> Or not not A |- A
16:51:35 <Pseudonym> Or something.
16:51:42 <foxy> so it's equivalent to double negation elimination (which is of course not valid in IL)?
16:51:46 <Pseudonym> Right.
16:51:56 <Pseudonym> Because there are Heyting algebras where it doesn't hold.
16:53:47 <ihope> If the double negation thing magically got added to this @djinn stuff, would every logical theorem thingy be provable by @djinn?
16:55:03 <TuringTest> dons: http://www.haskell.org/hawiki/KnucleotideEntry
16:55:47 <dons> ooh...
16:56:00 <TuringTest> dons: Also, The OCaml#4 Chameneos entry is cheating.  I have submitted a "protest" entry
16:56:22 <TuringTest> dons: Yeah, I made two variants of the Trie code
16:56:31 <dons> yep, I saw that. No threads at all in the chameneos?
16:56:41 <TuringTest> They put pairs of int's into a queue
16:56:51 <TuringTest> Not even functions or continuations
16:56:56 <TuringTest> PAIRS OF INTS!
16:57:13 <dons> pretty low :/ but at least they acknowledge it is a cheat
16:57:18 <TuringTest> (Well the color is an enum, but I call it as I see it)
16:57:34 <dons> not sure why they did it. maybe frustration with the OCaml threads? ;)
16:57:37 <TuringTest> dons: Yeah, that is why I submitted a Data.Queue based entry for Haskell
16:57:44 <TuringTest> dons: I would guess so.
16:58:05 <TuringTest> They should have written a lightweight scheduler for continuations or closures
16:58:25 <TuringTest> I could understand that, given their other entry's performance
16:58:34 <TuringTest> We did that to replace Text.Regex
16:58:41 <TuringTest> (correction -- you did that)
16:58:54 <dons> an unordered assoc list outperforms a map? interesting.
16:59:03 <TuringTest> Only 4 elements...very lightweight
16:59:07 <dons> yeah, they could have written a schedular 
16:59:08 <TuringTest> (On my machine)  
16:59:40 <TuringTest> dons: I did not performance tune or profile the modified Trie code
16:59:46 <dons> so, would you like me to benchmark these, and have a snoop around the code?
17:00:03 <TuringTest> I can't benchmark on x86
17:00:19 <TuringTest> Thus the ball is in whoever's court wishes to run it on x86
17:00:28 <dons> ok. nice and short too. looks good.
17:00:32 <TuringTest> (And x86 vs G4 matters for this one)
17:00:46 <TuringTest> dons: Yeah, it is much short than hardcoding the cases
17:00:51 <TuringTest> (But slower)
17:01:14 <ihope> @where djinn
17:01:14 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
17:01:15 <TuringTest> And it is not "length optimized"
17:02:01 <dons> btw, I was thinking of submitting a protest entry ttoo. iD[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D was going to wait a week to see if they spotted it.
17:02:02 <TuringTest> The garbage collection was a real problem on my powerbook for the Trie variants.
17:02:08 <dons> oops. silly wifi.
17:02:16 <TuringTest> dons: I wrote the Haskell entry.  I care more.
17:02:19 <dons> hmm. yeah, I see on your benchmarks
17:02:19 <ihope> Let's hope all this stuff won't get dumped right into my system32 folder.
17:02:30 <dons> true.
17:02:41 <ihope> If it does, I'll have some major cleanup to do!
17:04:08 <dons> there's this thing called linux , ihope ;)
17:04:44 <ihope> And there's this thing called a wireless network adapter driver...
17:05:23 <ihope> There are two alternatives: Ethernet and Windows.
17:05:46 <TuringTest> ihope: This is now free as in beer: http://www.vmware.com/products/server/
17:06:28 <ihope> ...What is it?
17:06:32 <TuringTest> ihope: Or you could buy a linux friendly wireless PC Card or USB widget for Wifi
17:06:50 <dons> is it a very new card, ihope? i've only ever had problem (on OpenBSD!) with really new cards.
17:06:57 <TuringTest> ihope: It lets you run one OS on top of another, like Virtual PC
17:07:07 <ihope> dons: yeah, I guess.
17:07:41 <TuringTest> dons: My work here is done.  I will read the benchmarks over breakfast.  But now I must go to bed.
17:07:50 <dons> ok, night!
17:07:53 * TuringTest reaches for the plug
17:08:08 <jethr0_> *yeah*, my genetic othello/reversi works
17:08:33 <dons> i wish google had a language-count-lines-of-code search feature :)
17:08:42 <dons> so we could find out how many lines of haskell are out there
17:08:51 <jethr0_> hehe
17:09:13 <jethr0_> better still would be to actively collect code and present it in a more readable manner than google
17:09:32 <dons> yeah. that'd be cool.
17:09:48 <ihope> Hmm. Now it's impossible to tell my sandboxy GHCi from my Djinn GHCi.
17:09:51 <jethr0_> small, idiomatic, readable code samples for beginners and those starting in a new field (monads, arrows, IO, ...) would be absolutely major
17:09:58 <ihope> So I toss the boxers...
17:10:26 <dons> jethr0_, we've started something like this on the wiki. but just grabbing .hs files off google-- maybe there's something to that..
17:10:39 <Revision17> Type classes have to be the coolest thing ever!
17:10:41 <Revision17> <- haskell novice
17:10:51 <dons> hehe :)0
17:11:06 <dons> that's the right attitude!
17:11:43 <Revision17> I was just writing an instance for Show when I was writing a little thing to automate some redundant set operations in my discreet math course
17:12:11 <dons> ah, cool. I wish I'd used Haskell when I did discrete math.
17:13:59 <jethr0_> dons: how did you come up with the heuristics for your icfp alpha-beta-pruning? i'd like to write an ab-pruning myself, but i don't really know where to start...
17:15:11 <jethr0_> i'm pretty confident about the algo in general, but it said, evaluation order was vital...
17:15:31 <dons> we had a heuristics guy, who just spent the 3rd day thinking up tactics.
17:15:40 <jethr0_> what luxury
17:15:52 <dons> we'd run 20 instances in parallel on a cluster, while we kept working, and then check to see if things got better or worse
17:16:12 <dons> that kind of data was invaluable.
17:16:19 <jethr0_> hehe
17:17:02 <Revision17> dons:  I also like how haskell's syntax is very close to the formal math syntax, I'm being extra lazy and just copy and pasting ghci sessings between \begin{verbatim} tags
17:17:20 <Revision17> s/sessings/sessions
17:18:10 <dons> Rrevision17, there's an faq somewhere on the net called: "Why mathematicians should use Haskell" you might be interested.
17:21:21 <Revision17> ah, yes this appears interesting; thanks :)
17:21:58 <br1> How should I indent if-then-else?
17:22:22 <dons> the 'then' and 'else' should line up.
17:22:45 <dons> if x == y
17:22:46 <dons>     then do something
17:22:46 <dons>     else do someotherthing
17:24:04 <br1> ghci doesn't like:
17:24:05 <br1>     if x*x == y*y + z*z
17:24:05 <br1>     then return (x,y,z)
17:24:05 <br1>     else mzero
17:24:15 <edwinb> then and else also have to be indented
17:24:43 <dons> sometimes: 1 + (if True then 1 else 2). also, ghci only accepts 1 liners
17:24:53 <Cale> the 'then' and 'else' are part of the expression starting with 'if', and so have to be indented more than it
17:26:00 <br1> OK. Now it works. :) 
17:26:03 <br1> Thank you
17:30:46 <palomer> @seen shapr
17:30:47 <lambdabot> I saw shapr leaving #ScannedInAvian, #haskell-blah and #haskell 13 hours,
17:30:47 <lambdabot> 57 minutes and 15 seconds ago.
17:31:03 <palomer> he'll probably wake up soon
17:36:29 <ncalexan> @where curses
17:36:30 <lambdabot> I know nothing about curses.
17:36:34 <ncalexan> @where ncurses
17:36:34 <lambdabot> I know nothing about ncurses.
17:36:52 <ncalexan> dons: did you ever package your ncurses bindings?
17:37:09 <ncalexan> other than with yi or hmp3?
17:37:31 <dons> stefanw packaged one version.
17:37:42 <ncalexan> Any idea where that is?
17:37:56 <dons> hmp3 has a newer lightweigth version (works on old curses, as well as ncurses)
17:38:02 <dons> @where hscurses
17:38:03 <lambdabot> I know nothing about hscurses.
17:38:17 <dons> but you might want to use the one in hmp3
17:38:20 <ncalexan> @where hmp3
17:38:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
17:38:31 <dons> @google hscurses
17:38:32 <lambdabot> http://www.stefanwehr.de/haskell/
17:40:09 <dons> i'd just grab the Curses.hsc file  and build system from hmp3. but it depends on what your goals are
17:41:15 <ncalexan> quick and dirty.
17:41:48 <ncalexan> I'd use interactive but the redraw is pretty slow.
17:44:28 <dons> grab the Curses.hsc out of hmp3 then. thate most lightweight
17:45:08 <ncalexan> It seems that requires a few cbits.  To build those I probably need more than ghc --make?
17:46:30 <dons> it just gives you the bare minimum
17:47:14 <dons> hmm, actually, hmp3s's needs fps too. perhaps stefan's package is better
17:49:03 <ncalexan> Well, thanks for the URLs.
17:50:13 <ihope> > (1 + sqrt 5) / 2
17:50:15 <lambdabot> 1.618033988749895
17:50:26 <ihope> > 1 + 2 / (1 + sqrt 5)
17:50:27 <lambdabot> 1.618033988749895
17:51:32 <ihope> > (1 + sqrt 5) / 2 == 1 + 2 / (1 + sqrt 5)
17:51:33 <lambdabot> True
17:55:26 <ihope> > sqrt 1000000
17:55:27 <lambdabot> 1000.0
17:57:47 <lispy> generally you don't want to use == on floating point values
17:58:51 <lispy> and i'm surprised that it evaluated to true :)
18:01:03 <ihope> Yep...
18:01:14 <ihope> Well, iterate (+1.0) 0 works fine.
18:01:38 <ihope> But stuff like iterate (+1.11) 0 doesn't.
18:01:54 <Revision17> is there a more terse way of filtering a list of maybes to as than this: http://pastebin.com/552051 ?
18:01:57 <ihope> Indeed, iterate (+0.1) 0 fails.
18:02:09 <jethr0_> catMaybes?
18:02:26 <ihope> sequence?
18:02:29 <ihope> > sequence [Nothing,Just 4,Nothing,Just 9]
18:02:31 <lambdabot> Nothing
18:02:34 <ihope> Oh.
18:02:51 <lispy> @type Control.monad.mplus
18:02:52 <lambdabot> Couldn't find qualified module.
18:02:52 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
18:02:52 <lambdabot> \\)?
18:03:02 <lispy> @type Control.Monad.msum
18:03:02 <lambdabot> forall a (m :: * -> *). (Control.Monad.MonadPlus m) => [m a] -> m
18:03:02 <lambdabot> a
18:03:03 <ihope> > catMaybes [Nothing,Just 4,Nothing,Just 9]
18:03:04 <lambdabot> [4,9]
18:03:21 <jethr0_> > catMaybes [Nothing, Just 4, Just 2, Nothing, Just 3]
18:03:22 <lambdabot> [4,2,3]
18:03:31 <Cale> also
18:03:35 <Revision17> awesome, thanks
18:03:46 <lispy> > Control.Monad.msum [Nothing, Just 4, Just 2]
18:03:47 <Cale> > [a | (Just a) <- [Nothing, Just 4, Just 2, Nothing, Just 3]]
18:03:47 <lambdabot> Just 4
18:03:48 <lambdabot> [4,2,3]
18:04:00 <ihope> > '\12'
18:04:01 <lambdabot> '\f'
18:04:12 <ihope> Um.
18:04:32 <ihope> Ooh...
18:04:35 <lispy> for some reason i expect msum to do something besides returning the first non-mzero value
18:04:40 <Revision17> Cale:  even better, :)
18:04:45 <ihope> @pl \x -> [ a | (Just a) <- x ]
18:04:45 <lambdabot> return . ((a | Just a) <-)
18:04:47 <jethr0_> Cale: why did that list comprehension work?
18:05:04 <ihope> If the pattern match fails, it just skips that element.
18:05:10 <jethr0_> ah, k
18:05:24 <lispy> if the pat match fails it must be monad fail?
18:05:34 <ihope> Aye.
18:05:46 <jethr0_> i forget again and again the parallelity between "[a | a <- ...]" and "... >>= \a ..."
18:05:51 <ihope> > do {Just a <- Nothing; a}
18:05:52 <lambdabot> Add a type signature
18:05:53 <anduril1> umm, was the code that lambdabot just printed Haskell?
18:06:14 <ihope> anduril: it thought | was an infix operator, I think
18:06:35 <ihope> It figured I was making a list with the single element a | (Just a) <- x
18:06:36 <lispy> anduril1: no, there is a bug in @pl with list comps, monads (return), and the do notation
18:06:57 <ihope> > do {Just a <- Nothing; a} :: Maybe ()
18:06:58 <lambdabot> Nothing
18:07:07 <ihope> Mmh.
18:07:41 <lispy> > do { x <- []; x} :: [Int]
18:07:42 <lambdabot> []
18:07:52 <jethr0_> it's the same as "Nothing >>= \(Just a) -> a", although there should be a return. ah, never mind
18:08:21 <jethr0_> i guess "a" could lie in the/a monad itself
18:09:07 <ihope> Hmm, I read that as "the a monad", and was wondering just what the a monad was.
18:09:39 <lispy> wouldn't that require (Monad m1, Monad m2) => m1 (m2 a)  = Monad m => m a
18:10:32 <lispy> hehe, the a monad is a monad that contains only a's ;)
18:10:40 <ihope> aaaaa
18:10:46 <lispy> exactly
18:10:51 <ihope> aaaaa
18:10:54 <ihope> aaa
18:11:09 <lispy> > return 'a'
18:11:10 <lambdabot>  add an instance declaration for (Show (m Char))
18:11:25 <ihope> aaaaaaaaaaa
18:11:44 * ihope aaaa
18:11:57 <ihope> :-P
18:12:54 <lispy> irc is so much more torelable with all the joins, parts and quits turned off
18:13:33 * lispy could idle here all day ;)
18:14:31 <jethr0_> exactly. i just turned them off and those splits don't bother me anymore! it's much more relaxed in here w/o people coming and going as they please :)
18:15:45 <ihope> You mean I can't go?
18:16:06 <ihope> Help! I'm being held hostage my people with numbers in their names!
18:16:25 <anduril1> ihope: you can go, it's just that jethr0 won't know or care ;)
18:17:08 <lispy> "by people with numbers in their names!"  hehe, i love that part
18:17:31 <lispy> @leet hi
18:17:32 <lambdabot> I haven't seen hi.
18:17:41 <lispy> hm...what is that command...
18:17:50 <lispy> @elite hi
18:17:50 <lambdabot> hi
18:17:56 <lispy> @elite lispy
18:17:56 <lambdabot> 1IsPY
18:18:11 <lispy> there we go
18:18:13 * jethr0 ignores the criticism of his name (which is correctly spelled JEthR0 BTW)
18:18:19 <lispy> oh it didn't work
18:19:22 <ihope> So if I want JEthR0 BTW to notice me leaving, I have to say I'm doing it?
18:19:44 <lispy> yes, but use /msg please :)
19:07:00 <orbitz> is the order parameters are evaluated defined to be left to right?
19:07:35 <anduril1> orbitz: do you mean evaluated or pattern matched?
19:07:44 <orbitz> evaluated
19:07:55 <anduril1> orbitz: it isn't defined, due to laziness
19:08:00 <orbitz> ok
19:10:35 <dons> lazyness means you don't have to ever consider `order'. things are evaluated when they're needed.
19:11:01 <Cale> laziness is a particular order
19:11:16 <Cale> (together with sharing)
19:11:29 <Cale> non-strict semantics mean that you don't need to worry about order :)
19:11:43 <Cale> basically, things are evaluated outermost-first
19:11:47 <Cale> in lazy evaluation
19:12:33 <Cale> except that parameters which are duplicated are shared -- that is, they're pointers to the same value/computation
19:13:12 <Cale> for instance, if I write  let double x = x + x in double (double 5), only two additions are carried out
19:13:18 <Cale> because of sharing
19:15:53 <Cale> double (double 5) = (double 5) + (double 5) = (5+5) + (5+5) = 10 + 10 = 20 is how the reduction goes
19:16:49 <jethr0> are there any sane alternatives to haddock? to suit haddocks syntax, the source becomes completely uglified :(
19:17:23 <dons> how so?
19:18:15 <jethr0> getting newlines in the html, requires to add blank lines in the comments...
19:18:19 <jethr0> that drives me crazy!
19:23:59 <anduril1> so, let's say I have 'f [] [] = ()', and I try to execute 'f (error "a") (error "b")', is it defined which error I get?
19:26:00 <Cale> oh, in that sense. I wouldn't really expect it to be defined.
19:28:23 <Cale> Different kinds of nontermination are treated as indistinguishable in the standard, though the string parameter is provided as a hint as to what to display.
19:29:15 <Speck> http://cs.ioc.ee/~tarmo/papers/tfp05-book.pdf this paper has a really good definition of comonads
19:29:42 <Speck> but I don't know what it means when a category (called C) is shown like this: |C|
19:30:25 <Speck> context is a comonad over a category C is given by a mapping D :: |C| -> |C|
19:31:25 <Cale> I don't think it means anything special here.
19:31:34 <Cale> A comonad is a specific kind of functor
19:32:10 <Cale> Perhaps |C| means the class of objects of C
19:32:20 <Speck> that's what I was thinking
19:32:46 <Speck> if that were the case, it wouldn't preserve morphisms, correct?
19:33:31 <Cale> we'd need to make sure that it did somehow
19:33:43 <Speck> because then it wouldn't be a functor?
19:33:53 <Cale> right
19:34:09 <Cale> I get the feeling that the |'s aren't even supposed to be there
19:34:09 <Speck> this CT stuff is perhaps starting to come together in my head
19:34:14 <jethr0> somebody pasted a vim script in here to automatically add type annotations...
19:34:19 <jethr0> is that still around?
19:34:34 <Speck> in the type for J (a lifting functor?) the |'s don't appear
19:35:54 <Speck> jethr0: have you tried the logs?
19:36:05 <jethr0> not yet. it's kinda hard to search for
19:37:08 <Speck> blarg, especially since the one with a search function requires one register
19:39:01 <Speck> I don't see anything useful in my lastlog, but that doesn't go back very far
19:41:40 <jethr0> nah, this is long ago
19:41:46 <dons> oh.
19:43:23 <jethr0> dons: was it you or cale?
19:43:36 <dons> jethr0, here, let me find it.
19:43:52 <dons> (it was mine)
19:43:54 <jethr0> sorry, that i didn't keep it better. any hints to how you did it would be appreciated
19:45:32 <dons> firstly, add this to your .vimrc:  :map ty :.!typeOf %, and install this script: http://www.cse.unsw.edu.au/~dons/typeOf
19:45:42 <jethr0> cool, thx
19:45:53 <dons> so when you hit 'ty' on a top-level decl, it inserts its type above that line.
19:46:39 <jethr0> hehe
19:46:46 <dons> (or any type errors, if the file doesn't type check)
19:47:14 <jethr0> what does the ".!" mean?
19:47:43 <dons> exec an external script, with the current line as input
19:48:03 <jethr0> ah, good to know. i think i should have a look at my vim manual once again
19:48:08 <jethr0> time to learn some new tricks
20:27:32 <palomer> > let a += b = temp <- getSTRef a >>= a <- writeSTRef b
20:27:32 <lambdabot>  parse error on input `<-'
20:28:02 <jethr0> "<-" without do?
20:28:23 <palomer> oh, righto
20:28:36 <jethr0> and missing in, but IO won't work in here anyways :)
20:29:14 <jethr0> good night
20:29:17 <palomer> this isn't IO!
20:29:21 <palomer> it's ST
20:29:28 <jethr0> ah, ok
20:41:10 <Speck> what do 'inductive' and 'coinductive' mean (wrt streams being coinductive and lists being inductive)
20:51:26 <palomer> @seen shapr
20:51:27 <lambdabot> I saw shapr leaving #ScannedInAvian, #haskell-blah and #haskell 17 hours,
20:51:27 <lambdabot> 17 minutes and 54 seconds ago.
21:19:24 <Pseudonym> Speck: I'm not certain, because lists are streams in Haskell.
21:19:42 <Pseudonym> But as I understand it, you produce lists, but you consume streams.
21:19:49 <Pseudonym> You ONLY consume streams.
21:19:58 <Pseudonym> And they are therefore codata instead of data.
21:20:20 <Speck> Pseudonym: http://cs.ioc.ee/~tarmo/papers/tfp05-book.pdf <-- context is here / comonadic implementation of dataflow processing
21:20:54 <Speck> where the dataflow is modeled by a comonad that has an inductive list part and a coinductive stream part
21:22:53 <Speck> the definitions for List and Stream are commented with inductive and coinductive respectively, and I wasn't sure what that meant
21:52:26 <palomer> Cale: you around?
21:54:56 <palomer> ahh, proved it:P
21:54:58 <palomer> wasn't hard 
22:05:32 <vincenz> re
