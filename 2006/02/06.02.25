00:16:33 <xinming> lisppaste2: url
00:16:34 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
00:53:06 <palomer> > 2 + 4
00:53:07 <lambdabot> 6
00:53:11 <palomer> yay!
00:53:24 <mbot> 6
00:55:49 <sieni> > product [1..10]
00:55:50 <lambdabot> 3628800
00:56:00 <mbot> 3628800
00:57:36 <sieni> > map (2^) [0..10]
00:57:37 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024]
00:57:48 <mbot> [1,2,4,8,16,32,64,128,256,512,1024]
00:58:05 <sieni> [1..]
00:58:12 <sieni> > [1..]
00:58:13 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
00:58:13 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
00:58:13 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
00:58:13 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
00:58:13 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
00:58:15 <lambdabot> [24 @more lines]
00:58:23 <mbot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,
00:58:23 <mbot> 115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,
00:58:23 <mbot> 202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,
00:58:23 <mbot> [3 @more lines]
00:58:25 <fluxx> it always does that
00:58:29 <fluxx> never counts to infinity
00:58:32 <fluxx> stupid bot ;(
00:58:48 <sieni> fluxx: I was just demonstrating haskell for my friend
00:58:52 <fluxx> hm, mbot missed something
00:59:17 <jyp> @quote
00:59:18 <lambdabot> babel module failed: getRandItem: empty list
00:59:26 <mbot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too 
00:59:30 <fluxx> btw, does lambdabot also answer in private?
00:59:35 <sieni> > take 10 [1..]
00:59:36 <jyp> yup
00:59:36 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
00:59:37 <ncalexan> fluxx: yes.
00:59:42 <ncalexan> Just private message it.
00:59:46 <mbot> [1,2,3,4,5,6,7,8,9,10]
00:59:51 <fluxx> whee
01:00:13 <fluxx> cool, now I can just write a raytracer that can send work units over irc!
01:00:21 <fluxx> free computing power!
01:00:21 * wli experiences linear algebra -related exasperation.
01:00:53 <wli> (I want principal components analysis in Haskell)
01:01:34 <wli> The GSL wrapper library is unfortunately painful on large matrices and doesn't handle sparse cases well.
01:01:57 <wli> The webpage sitting in front of the CLAPACK wrapper is broken so I can't grab that.
01:02:44 <roconnor> morning
01:03:17 <roconnor> @where yhc
01:03:17 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
01:03:26 <mbot> http://www.cs.york.ac.uk/~ndm/yhc
01:03:44 <roconnor> thanks you two
01:03:50 <wli> I've tried rolling my own but coping with degenerate/unstable/etc. cases requires too much sophistication to bang out on my own.
01:05:42 * roconnor wonders if yhc can build darcs
01:13:37 <araujo> @hoogle Ptr
01:13:38 <lambdabot> Foreign.Ptr.Ptr :: Ptr a
01:13:38 <lambdabot> GHC.Exts.Ptr :: Ptr a
01:13:38 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
01:13:52 <roconnor> wow, can I really compile with yhc and use a java bytecode interpreter!
01:14:04 <mbot> search module failed: thread killed
01:18:17 <araujo> mm...
01:18:33 <araujo> im importing Foreign.Prt, nevertheless, i keep getting:
01:18:35 <araujo> Not in scope: data constructor `Ptr'
01:18:38 <araujo> Any idea?
01:20:23 <roconnor> Um, I don't think you can use the constructor.
01:20:40 <roconnor> but I don't know much about FFI
01:21:28 <roconnor> What are you trying to do with your pointer?
01:23:21 <roconnor> @hoogle Ptr a -> b
01:23:22 <lambdabot> Prelude.undefined :: a
01:23:22 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
01:23:22 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
01:23:50 <mbot> search module failed: getHostByName: does not exist (no such host entry)
01:24:06 <marnix> araujo: you shouldn't use 'Ptr' as a data constructor, but only in types.  What's the code that it complains about?
01:25:51 <araujo> oh, i see
01:26:15 <araujo> marnix, well, im just trying to use this function, http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/System-Glib-GObject.html#v%3AobjectRef
01:28:26 <araujo> marnix, what exactly should i pass to that function then?
01:29:25 <roconnor> Something created by objectNew perhaps?
01:31:08 <roconnor> although I suppose you shouldn't be directly using objectNew
01:31:09 <marnix> well, yes, something like that.  I mean, for this function you already need a value of type Ptr a.  You don't create Ptr objects yourself, you always get them from other functions.
01:35:20 <araujo> i see
01:36:38 <xerox> G'morning.
01:52:02 <dcoutts> liyang, yes, gtk2hs doesn't have a --with-ghc-docdir flag yet. If you have a patch that'd be great.
01:53:34 <roconnor> xerox: morning
02:13:09 <ski> morning, xerox
02:13:22 <ski> @type (\(x :: forall a. a -> a) -> x x)
02:13:23 <lambdabot> forall a.
02:13:23 <lambdabot>              (forall a1. a1 -> a1) -> a -> a
02:13:25 <mbot> forall a.
02:13:25 <mbot>              (forall a1. a1 -> a1) -> a -> a
02:13:28 <ski> @type (\(x :: forall a. a -> a) -> x x) id 1
02:13:29 <lambdabot> forall a. (Num a) => a
02:13:29 <mbot> forall a. (Num a) => a
02:13:42 <ski> > (\(x :: forall a. a -> a) -> x x) id 1
02:13:42 <lambdabot>   Illegal signature in pattern: forall a . (a -> a)
02:13:42 <lambdabot>    Use -fglasgow-exts to permit it
02:13:44 <mbot>   Illegal signature in pattern: forall a . (a -> a)
02:13:44 <mbot>    Use -fglasgow-exts to permit it
02:15:14 <xerox> Hollash ski, I found this definition of the symbol dy/dx which is rather nice, imo: "a change in y less than any assignable quantity divided by a change in x less than any other assignable quantity."
02:15:16 <ski> xerox : also 'forall a. let f = f -> (a -> a) in f -> (a -> a)' is the same as 'forall a. let f = f -> (a -> a) in f', but 'forall a. let x = x -> a' is more general
02:15:32 <ski> er .. 'forall a. let x = x -> a in a', i meant
02:15:38 <ski> bah
02:15:41 <ski> er .. 'forall a. let x = x -> a in x', i meant
02:15:58 <xerox> I see.  Thanks.
02:17:26 <ski> [slj@Tsaia][~]> ocaml -rectypes
02:17:26 <ski>         Objective Caml version 3.08.3
02:17:26 <ski> # let w x = x x;;
02:17:26 <ski> val w : ('a -> 'b as 'a) -> 'b = <fun>
02:17:26 <ski> # let w : 'a -> 'b as 'a = fun x -> x x;;
02:17:26 <ski> val w : 'a -> 'b as 'a = <fun>
02:18:08 * xerox shrinks the eyelids trying to decypher
02:18:48 <ski> xerox : though that's not definition above of leibniz derivative notation is not so clear, i think
02:19:28 <ski> (both those typings for 'w' are equivalent, but the second is shorter)
02:19:41 <xerox> Ah, I see that now.
02:19:51 <xerox> <fun> !
02:21:27 <ski> i think the usual rationaly for not allowing equ-recursive types is that errors in code can get strange cyclic types inferred, instead of type-error
02:25:21 <xerox> Right, Cale told me once that Haskell Type System is hindered from turing-completeness on purpose.
02:29:26 <ski> xerox : that definition assumes an ambient relation between 'x' and 'y' ..
03:29:55 <xerox> Cale: ping
06:17:00 <pierre-> hello. 
06:24:52 <ski> hello pierre-
06:30:41 <ihope> > intersperse ' ' "The quick brown fox jumps over the lazy dog, but the lazy dog doesn't know he's being jumped over because he is asleep. The quick brown fox laughs at the lazy dog and runs away."
06:30:42 <lambdabot> "T h e   q u i c k   b r o w n   f o x   j u m p s   o v e r   t h e   l
06:30:42 <lambdabot> a z y   d o g ,   b u t   t h e   l a z y   d o g   d o e s n ' t   k n o
06:30:42 <lambdabot> w   h e ' s   b e i n g   j u m p e d   o v e r   b e c a u s e   h e   i
06:30:42 <lambdabot> s   a s l e e p .   T h e   q u i c k   b r o w n   f o x   l a u g h s
06:30:42 <lambdabot> a t   t h e   l a z y   d o g   a n d   r u n s   a w a y ."
06:30:44 <mbot> "T h e   q u i c k   b r o w n   f o x   j u m p s   o v e r   t h e   l a z y   d o g ,   b u t   t
06:30:44 <mbot> a y ."
06:32:23 <resiak> Is there a built-in for splitting "abcdef" into ("ace","bdf")?
06:32:45 <Igloo> no
06:33:02 <resiak> Obviously it's easy enough to write, so. :)
06:34:06 <int-e> @pl \(a,b) -> (b,a)
06:34:06 <lambdabot> uncurry (flip (,))
06:34:06 <mbot> uncurry (flip (,))
06:34:28 <jethr0> > let f "" x = x; f (x:y:xs) (a,b) = f xs (a++[x], b++[y]) in f "abcdef" ("","")
06:34:29 <lambdabot> ("ace","bdf")
06:34:30 <mbot> ("ace","bdf")
06:34:37 <int-e> > foldr (uncurry (flip (,))) ("","") "abcdef"
06:34:38 <lambdabot> Couldn't match `b -> b' against `(b1, a)'
06:34:39 <mbot> Couldn't match `b -> b' against `(b1, a)'
06:35:23 <jethr0> ya, i guess it's a fold alright
06:35:32 <int-e> > foldr (\a (b,c) -> (a:c, b)) ("","") "abcdef"
06:35:33 <lambdabot> ("ace","bdf")
06:35:34 <mbot> ("ace","bdf")
06:35:53 <int-e> @pl \a (b,c) -> (a:c, b)
06:35:53 <lambdabot> (`ap` snd) . (. fst) . flip . ((,) .) . (:)
06:35:54 <mbot> (`ap` snd) . (. fst) . flip . ((,) .) . (:)
06:36:13 <LordL> > (\x -> take 3 x ++ "," ++ drop 3 x) "abcdef"
06:36:14 <lambdabot> "abc,def"
06:36:14 <mbot> "abc,def"
06:36:27 <azuroth> mbot don't lie
06:36:37 <Igloo> Any chance mbot can not respond unless addressed?
06:36:54 <azuroth> I pity that fool
06:37:47 * resiak looks at int-e's answer
06:37:55 <roconnor> @where sinc
06:37:56 <lambdabot> I know nothing about sinc.
06:37:56 <mbot> I know nothing about sinc.
06:37:56 <jethr0> int-e: you're solution is pretty neat :)
06:39:00 <resiak> int-e: That's neat. I'd forgotten about that trick when folding. Thank :)
06:39:28 <int-e> :)
06:40:16 <roconnor> @hoogle sinc
06:40:16 <lambdabot> No matches found
06:40:18 <mbot> http://mathworld.wolfram.com/SincFunction.html
06:42:28 <pierre-> hmm what is "mbot"?
06:42:55 <astrolabe> It belongs to Cale I think.
06:43:08 <roconnor> what is numeric_limits<double>::epsilon()?
06:43:14 <astrolabe> Perhaps the child of lambdabot and mathematica
06:43:24 <pierre-> nice. So powerful as lambdabot?
06:43:40 <astrolabe> I don't think it has all the modules
06:43:55 <ski> @listmodules
06:43:55 <mbot> babel base dict dynamic haddock help karma localtime math more pl plugs search seen system type vers
06:43:56 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
06:43:56 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
06:43:56 <lambdabot> seen spell state system todo topic type version vixen where
06:44:42 <astrolabe> @help haddock
06:44:42 <mbot> haddock provides: index
06:44:42 <lambdabot> haddock provides: index
06:46:48 <astrolabe> @karma dons
06:46:49 <mbot> dons has a karma of 13
06:46:49 <lambdabot> dons has a karma of 21
06:46:55 * ihope laughs
06:47:04 <astrolabe> @karma Cale
06:47:05 <lambdabot> Cale has a karma of 5
06:47:05 <mbot> Cale has a karma of 1
06:47:08 <roconnor> > floatRadix (0::Double)
06:47:09 <lambdabot> 2
06:47:10 <ihope> He has a Fibonacci karma.
06:47:10 <mbot> 2
06:47:15 <roconnor> > floatRadix (500::Double)
06:47:15 <lambdabot> 2
06:47:16 <mbot> 2
06:47:37 <ihope> @karma
06:47:38 <mbot> You have a karma of 0
06:47:38 <lambdabot> You have a karma of 1
06:48:02 <ihope> @karma mbot
06:48:02 <lambdabot> mbot has a karma of 0
06:48:02 <mbot> mbot has a karma of 0
06:48:07 <ihope> :-)
06:48:11 <ihope> @karma lambdabot
06:48:11 <mbot> lambdabot has a karma of 5
06:48:12 <lambdabot> lambdabot has a karma of 10
06:49:11 <roconnor> > floatDigits (500::Double)
06:49:12 <lambdabot> 53
06:49:13 <mbot> 53
06:49:16 <roconnor> > floatDigits (0::Double)
06:49:16 <lambdabot> 53
06:49:17 <mbot> 53
06:49:23 <roconnor> 2^(-53)
06:49:26 <roconnor> > 2^(-53)
06:49:29 <lambdabot> Exception: Prelude.^: negative exponent
06:49:29 <mbot> Exception: Prelude.^: negative exponent
06:49:32 <roconnor> > 2^^(-53)
06:49:33 <lambdabot> 1.1102230246251565e-16
06:49:34 <mbot> 1.1102230246251565e-16
06:49:51 <roconnor> > 2^^(-52)
06:49:52 <lambdabot> 2.220446049250313e-16
06:49:53 <mbot> 2.220446049250313e-16
06:50:09 <roconnor> that is numeric_limits<double>::epsilon()?
06:50:15 <roconnor> that is numeric_limits<double>::epsilon()
06:51:24 <roconnor> > 2**(-52)
06:51:25 <lambdabot> 2.220446049250313e-16
06:51:25 <mbot> 2.220446049250313e-16
06:52:12 <roconnor> > let epsilon = 2.0**(1-floatDigits epsilon) in epsilon
06:52:12 <lambdabot>  add an instance declaration for (RealFloat Int)
06:52:14 <mbot>  add an instance declaration for (RealFloat Int)
06:52:26 <roconnor> > let epsilon = 2.0**(fromInteger $ 1-floatDigits epsilon) in epsilon
06:52:27 <lambdabot> Couldn't match `Integer' against `Int'
06:52:27 <mbot> Couldn't match `Integer' against `Int'
06:52:33 <roconnor> > let epsilon = 2.0**(fromIntegral $ 1-floatDigits epsilon) in epsilon
06:52:34 <lambdabot> 2.220446049250313e-16
06:52:35 <mbot> 2.220446049250313e-16
06:53:22 <roconnor> @hoogle epsilon
06:53:22 <lambdabot> No matches found
06:53:23 <mbot> http://www.epsilon.com/
06:54:23 <astrolabe> roconnor: I think it is, yes.
07:02:42 <roconnor> @where paste thingy
07:02:43 <lambdabot> http://paste.lisp.org/new/haskell
07:02:43 <mbot> http://paste.lisp.org/new/haskell
07:03:18 <lisppaste2> roconnor pasted "sinc function" at http://paste.lisp.org/display/17196
07:03:51 <roconnor> oops
07:04:02 <roconnor> I need to check the size of (abs x)
07:05:10 <lisppaste2> roconnor annotated #17196 with "use abs" at http://paste.lisp.org/display/17196#1
07:07:23 * roconnor wants sinc in the Prelude
07:07:51 <roconnor> maybe I can get in into Haskell'
07:11:28 <lpb-oberon> int-e: would you please explain the line to me - or where do i find a quick-reference of haskell commands (currently i am using http://cs.wwc.edu/KU/PR/Haskell.html)      foldr (\a (b,c) -> (a:c, b)) ("","") "abcdef"
07:11:58 <int-e> *sigh* why can't '-1' be a single token. having to put parentheses around negative numbers is ugly.
07:13:06 <roconnor> lpb-oberon: http://haskell.org/onlinereport/standard-prelude.html isn't so bad
07:14:18 <jethr0> lpb-oberon: do you know foldr?
07:15:00 <lpb-oberon> no:(
07:15:02 <jethr0> lpb-oberon: what it does is take the element of the given string one element/char at a time and prepending them to the first and second tuple value alternatingly
07:15:33 <jethr0> as it's doing this right-associatively, this results in correctly ordered tuple values
07:16:15 <jethr0> but for odd string length it will produce rather weird behaviour
07:16:26 <jethr0> > foldr (\a (b,c) -> (a:c, b)) ("","") "abcde"
07:16:27 <lambdabot> ("ace","bd")
07:16:28 <mbot> ("ace","bd")
07:16:33 <jethr0> hmm, or not
07:17:55 <jethr0> ah, because it does it "backwards", even odd string length is handled correctly. quite nice :)
07:18:31 <jethr0> lpb-oberon: would you like me to explain foldr to you?
07:18:56 <ski> jethr0 : because it does it one step at a time, instead of two steps at a time, rather
07:18:57 <int-e> The foldr definition above is equivalent to   f [] = ("", "") {- the empty string is split into two empty strings -} f (c:cs) = let (s1, s2) = f cs in (c:s2, s1) {- if we want to split a string, first split the tail, swap the two result strings, and put the first character in front of the first string -}
07:19:44 <jethr0> ski: no, i expected it to return ("bd","ace") or sth like that for odd string lengths...
07:20:12 <ski> jethr0 : ah (misunderstood you, then)
07:20:17 <jethr0> :)
07:22:04 <ski> > foldr (\n x -> n + 10 * x) 0 [1,2,3]
07:22:05 <lambdabot> 321
07:22:06 <mbot> 321
07:22:07 <ski> > foldr (\n x -> concat ["(",show n," + 10 * ",x,")"]) "0" [1,2,3]
07:22:08 <lambdabot> "(1 + 10 * (2 + 10 * (3 + 10 * 0)))"
07:22:09 <mbot> "(1 + 10 * (2 + 10 * (3 + 10 * 0)))"
07:22:10 <lpb-oberon> thx jethr0 i have to think(/translate) a and understand what you have said for a moment:)
07:23:40 <jethr0_> could somebody with the appropriate priviliges shut down mbot?
07:36:48 <ihope> Hmm...
07:45:23 <lpb-oberon> (\a (b,c) -> (a:c, b)) 1 (2,[3])
07:45:31 <lpb-oberon> > (\a (b,c) -> (a:c, b)) 1 (2,[3])
07:45:32 <lambdabot> ([1,3],2)
07:45:36 <mbot> ([1,3],2)
07:46:22 <Cale> mbot: @part #haskell
07:46:30 <Cale> sorry :)
07:46:43 <Cale> lambdabot was gone the other day, so I made it join
07:47:15 <ski> > (\a (b,c) -> (a:c, b)) 1 ([2],[3])
07:47:16 <lambdabot> ([1,3],[2])
07:47:34 <ski> > (\a (b,c) -> (a:c, b)) 1 . (\a (b,c) -> (a:c, b)) 2 $ ([3],[4])
07:47:35 <lambdabot> ([1,3],[2,4])
07:47:39 <Cale> http://cale.yi.org/autoshare/folds.png
07:48:16 <Cale> I should perhaps do a Visual Tour of the Prelude at some point :)
07:51:56 <chris2> Cale: what tool did you use to make that graphics?
07:52:04 <Cale> inkscape
07:52:28 <Cale> Quite a nice free vector drawing app.
07:52:30 <chris2> and the trees manually?
07:52:35 <chris2> yeah, i know it
07:52:40 <Cale> yeah
07:52:49 <chris2> ow, quite some work then :)
07:53:20 <Cale> hehe
07:53:31 <Cale> not as much as the Cabal logo
07:54:02 <Cale> http://cale.yi.org/autoshare/Cabal-With-Text-Light-Dark.png
07:55:15 <Cale> I should perhaps turn that into an actual typeface :)
07:55:53 <lpb-oberon> what kind of operaotors are (.) and ($)
07:56:10 <Cale> (.) is function composition and ($) is function application
07:56:18 <xerox> f . g = \x -> f (g x)
07:56:23 <xerox> f $ x = f x
07:56:27 <ski> > (\a (b,c) -> (a:c, b)) ((\a (b,c) -> (a:c, b)) 2 ([3],[4]))
07:56:28 <lambdabot>   add an instance declaration for (Show ((a2, [([a], [a1])])
07:56:28 <lambdabot>                -> ([([a], [a1])], a2)))
07:56:32 <ski> er
07:56:46 <ski> > (\a (b,c) -> (a:c, b)) 1 ((\a (b,c) -> (a:c, b)) 2 ([3],[4]))
07:56:47 <lambdabot> ([1,3],[2,4])
07:57:06 <ski> (f . g) x = f (g x)
07:57:45 <roconnor> fundeps likely won't be in haskell'  :'(
07:57:57 <ski> lpb-oberon : see that pic link of Cale's for how 'foldr' works
07:57:58 <xerox> I know but that syntax seem more difficult to grok than the lambda one when teaching that combinator.
07:58:13 * xerox joins roconnor's lament
07:58:43 <Speck> they'll still be an extension I imagine
07:58:51 * roconnor tries to find where to submit his sinc suggestoin
07:59:13 <ski> foo 1 . foo 2 $ bar  =  (foo 1 . foo 2) $ bar  =  (foo 1 . foo 2) bar  =  foo 1 (foo 2 bar)
08:01:04 <roconnor> what's the common pitfull with do-notation and if-then-else?
08:01:08 <roconnor> s/pitfull/pitfall
08:01:09 <lpb-oberon> got it as Cale told me what it was - but thats a nice example - thx:)
08:02:12 <ski> roconnor : that the arms of the if-then-else aren't command sequences, but expressions ?
08:02:20 <lpb-oberon> foldr f z   is z a function?
08:02:36 <ski> 'z' is the bottom value
08:02:40 <mauke> lpb-oberon: not necessarily
08:02:48 <ski> what the end of the list (i.e. the empty list) gets replaced by
08:03:31 <ski> > foldr (\n x -> n + 10 * x) 0 [1,2,3]
08:03:32 <lambdabot> 321
08:03:34 <ski> > foldr (\n x -> concat ["(",show n," + 10 * ",x,")"]) "0" [1,2,3]
08:03:35 <lambdabot> "(1 + 10 * (2 + 10 * (3 + 10 * 0)))"
08:03:43 <ski> lpb-oberon : did you see that ?
08:04:09 <ski> '0' (respectively '"0"') here is your 'z'
08:05:30 <ihope> @type fix show
08:05:30 <lambdabot> Not in scope: `fix'
08:05:34 <ihope> @type Control.Monad.Fix.fix show
08:05:35 <lambdabot> String
08:05:43 <ihope> > fix shoiw
08:05:46 <lambdabot>  Not in scope: `shoiw'
08:05:46 <ihope> > fix show
08:05:46 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\
08:05:46 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\
08:05:46 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:05:46 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:05:46 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:05:48 <lpb-oberon> ah.) yes
08:05:49 <lambdabot> [23 @more lines]
08:05:59 <ski> :)
08:06:20 <roconnor> *l*
08:09:21 <chrisbrown> hi all
08:09:39 <roconnor> hi
08:09:52 <pierre-> @type fix
08:09:53 <lambdabot> Not in scope: `fix'
08:11:23 <roconnor> @type Control.Monad.Fix.fix
08:11:26 <lambdabot> forall a. (a -> a) -> a
08:11:28 <roconnor> @type Control.Monad.Fix.fixM
08:11:28 <lambdabot> Not in scope: `Control.Monad.Fix.fixM'
08:11:30 <ihope> @type Control.Monad.Fix.mfix
08:11:30 <lambdabot> forall (m :: * -> *) a.
08:11:30 <lambdabot>          (Control.Monad.Fix.MonadFix m) =>
08:11:30 <lambdabot>          (a -> m a) -> m a
08:11:33 <mauke> @type Control.Monad.Fix.fix id
08:11:33 <lambdabot> forall a. a
08:11:33 <pierre-> fix id
08:11:33 <ihope> Muahaha,.
08:11:33 <ihope> s/,//
08:11:33 <pierre-> > fix id
08:11:33 <lambdabot> Add a type signature
08:11:33 <roconnor> ;)
08:11:33 <ski> > fix id :: ()
08:11:33 <lambdabot> <stdout>: hPutStr: illegal operation (handle is finalized)
08:11:33 <ski> er
08:11:33 <ihope> !
08:11:40 <roconnor> > undefined :: ()
08:11:40 <mauke> > fix id :: String
08:11:41 <lambdabot> Undefined
08:11:41 <lambdabot> <stdout>: hPutStr: illegal operation (handle is finalized)
08:11:42 <pierre-> @hoogle fix
08:11:42 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
08:11:42 <lambdabot> Graphics.UI.ObjectIO.StdIOCommon.Fix :: ItemLoc
08:11:42 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
08:11:46 <jyp> > fix (const "whatever")
08:11:46 <lambdabot> "whatever"
08:12:07 <ski> > fix id :: Int
08:12:28 <lambdabot> <stdout>: hPutStr: illegal operation (handle is finalized)
08:12:29 <mauke> > fix id :: forall a. a -> a
08:12:29 <lambdabot>  add an instance declaration for (Show (. (forall a) a -> a))
08:12:34 <roconnor> > undefined :: Int
08:12:34 <lambdabot> Undefined
08:12:36 <roconnor> > undefined
08:12:37 <lambdabot> Add a type signature
08:12:41 <ski> > let x = x in x :: ()
08:12:42 <lambdabot> <stdout>: hPutStr: illegal operation (handle is finalized)
08:12:54 <ihope> > let x = x + 1 in x
08:12:55 <lambdabot> <stdout>: hPutStr: illegal operation (handle is finalized)
08:13:03 <ski> dons !
08:13:12 <roconnor> > let x = show x in x
08:13:12 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\
08:13:12 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\
08:13:12 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:13:12 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:13:12 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:13:14 <lambdabot> [23 @more lines]
08:13:34 <ihope> Many backslashes.
08:13:54 <pierre-> @more
08:13:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:13:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\
08:13:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:13:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:13:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:05 <lambdabot> [18 @more lines]
08:14:12 <ihope> > let x = show ('!' : x) in x
08:14:14 <lambdabot> "\"!\\\"!\\\\\\\"!\\\\\\\\\\\\\\\"!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"!\\\\\\
08:14:17 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"!\\\\\\\\\\\\\\\
08:14:33 <pierre-> @more
08:14:33 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:33 <bejs> "<ihope> Many backslashes" sounds like some sort of punishment
08:14:33 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:33 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:33 <lambdabot> [23 @more lines]
08:14:33 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:33 <ihope> Heh.
08:14:38 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
08:14:38 <lambdabot> !\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:38 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:38 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
08:14:38 <lambdabot> [18 @more lines]
08:14:38 <pierre-> this one is good for spamming :-)
08:14:38 <ihope> No @more!
08:15:10 <chrisbrown> has anyone here used darcs?
08:15:18 <jyp> yah :)
08:15:19 <pierre-> yes
08:15:42 <chrisbrown> i have set up the repository - and if i do a darcs get from another direcotry it seems to work ok...
08:15:50 <roconnor> is joing the haskell prime mailing list moderated?
08:16:09 <chrisbrown> but I am trying to make it accessible on a webpage so you can get it from another machine
08:16:12 <jyp> roconnor: not afaict
08:16:26 <chrisbrown> but i get the error that it is an invalid repository
08:16:51 * roconnor waits for mailman to get back to him.
08:17:25 <jyp> chrisbrown: you don't need a webpage, you need ssh.
08:17:38 <jethr0_> chrisbrown: the published repo dir should contain the _darcs directory. and then you should be able to do "darcs get repo_dir"
08:23:16 <chrisbrown> the published repo dir?
08:23:21 <chrisbrown> i want to be able to use a command like this: darcs get http://your.server.org/repos/yourproject
17:51:23 --- topic: '["Submit a paper to the Haskell Workshop:","http://haskell.org/haskell-workshop/2006","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]'
17:51:23 --- topic: set by kosmikus on [Thu Feb 16 05:43:08 2006]
17:51:52 <mauke> huhu, optional c p = fmap return p `c` fail "no match"
17:52:38 <Cale> mauke: hmm
17:52:43 <Cale> that looks a little evil :)
17:53:08 <mauke> optional :: (Monad m) => Combine (Parser tok st (m a)) -> Parser tok st a -> Parser tok st (m a)
17:54:00 <roconnor> it the ? in a regular expression, ya?
17:54:33 <mauke> yep
17:54:36 * Cale refuses to admit that fail is a member of the Monad class :)
17:54:48 <lispy> heh
17:55:00 <lispy> everyone has their idiosyncrasies i guess :)
17:56:06 <mauke> wait, I forgot to use st anywhere
17:58:06 * roconnor tries to figurout how to carve up his modules into pieces
17:58:23 <roconnor> I can't have mutually dependent modules right?
17:58:39 <Cale> roconnor: you should be allowed to have them, but they're harder to use than they should e
17:58:40 <Cale> be*
17:58:42 <Cale> in GHC
17:59:11 <roconnor> oh
17:59:40 <roconnor> harder as in, don't bother trying?
17:59:55 <Cale> harder as in maybe not worth it
18:00:43 <roconnor> I can't figure out how to cut up my module.
18:00:51 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
18:01:12 <roconnor> I have a piece that wants access to the internals of the other
18:01:28 <roconnor> but I don't want the internals genearally accessable.
18:01:59 <Saulzar> Mutually dependant modules seem not too bad, mutually dependant data structures don't seem possible?
18:02:06 <Saulzar> (In different modules)
18:02:22 <Cale> Saulzar: they're possible
18:02:52 <Saulzar> Really? I never figured it out - ie. I put the structure in the .hs-boot and now the .hs-boot reports the circular dependancy :)
18:03:10 <mauke> can I make my Parser an instance of MonadState? if so, how?
18:04:27 <Cale> instance MonadState s (MyParserType tok s) where 
18:05:02 <Cale> or if your parser is a StateT of some other monad, then just add deriving (MonadState s) to the newtype :)
18:05:04 <mauke> Illegal instance declaration for `Control.Monad.State.MonadState st (Parser tok st)'
18:05:33 <mauke> it isn't
18:06:24 <Cale> hmm
18:06:26 <Cale> odd
18:07:04 <Cale> Is Parser a synonym?
18:07:21 <Cale> if it is, change it to a newtype
18:07:34 <Cale> anyway, bbiab
18:07:42 <mauke> no, it's a data
18:07:57 <mauke> the instances for Monad and Functor work fine
18:27:46 <roconnor> @type splitAt
18:27:47 <lambdabot> forall a. Int -> [a] -> ([a], [a])
18:27:56 <roconnor> @hoogle split
18:27:56 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
18:27:56 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
18:27:56 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
18:27:59 <roconnor> @hoogle splitAt
18:28:00 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
18:28:00 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
18:28:00 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString,
18:28:00 <lambdabot> PackedString)
18:28:09 <roconnor> @hoogle splitWith
18:28:09 <lambdabot> Data.PackedString.splitWithPS :: (Char -> Bool) -> PackedString -> [
18:28:09 <lambdabot> PackedString]
18:30:40 <roconnor> @hoogle splitWhile
18:30:41 <lambdabot> No matches found
18:31:31 <roconnor> aha
18:31:33 <roconnor> @type span
18:31:34 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:40:48 <roconnor> @hoogle [a] -> [[a]]
18:40:49 <lambdabot> Data.List.inits :: [a] -> [[a]]
18:40:49 <lambdabot> Data.List.tails :: [a] -> [[a]]
18:40:49 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
18:43:44 <roconnor> let p (h:t)=(p t)++map(h:)$p t;p x=[x] in p [1,2,3]
18:43:49 <roconnor> >  let p (h:t)=(p t)++map(h:)$p t;p x=[x] in p [1,2,3]
18:43:50 <lambdabot> Couldn't match `[a]' against `t -> t1'
18:44:22 <roconnor> >  let p (h:t)=(p t)++map(h:)(p t);p x=[x] in p [1,2,3]
18:44:23 <lambdabot> [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:45:35 <roconnor> >  let p (h:t)=p t++map(h:)(p t);p x=[x] in p [1,2,3]
18:45:36 <lambdabot> [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:52:03 <grob> @pl
18:52:04 <lambdabot> (line 1, column 1):
18:52:04 <lambdabot> unexpected end of input
18:52:04 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
18:52:04 <lambdabot> expression
18:53:10 <grob> @pl \lst -> zipWith (/) lst [1..]
18:53:11 <lambdabot> flip (zipWith (/)) [1..]
18:53:41 <roconnor> Yay, I've figured out how to compute the geometric product.  It was actually pretty easy
18:54:22 <jbc> can someone give me a quick hand with the textbook for this course I'm doing? 
18:54:28 <roconnor> now I can do it for 4 and 5 dimensions
18:54:34 <jbc> I'm drowning in terminology here
18:55:23 <roconnor> try me
18:56:23 <jbc> k
18:56:28 <jbc> http://www.cs.cmu.edu/~rwh/plbook/online.pdf
18:56:35 <jbc> section 1.3, page 17
18:57:16 <jbc> I'm just wondering what P x-> refers to
18:58:51 <roconnor> It seems to me like P is a predicate.
18:58:59 <roconnor> x-> is a list of arguments for P
18:59:32 <roconnor> they have some examples if you keep reading
19:02:13 <carp> the -> on top is standard vector notation for a sequence of arguments
19:03:14 <jbc> yep, the arrow makes sense, I was just trying to parse the P. So, just to make sure I have this nailed down:
19:05:21 <jbc> "P x" ~ "P(x)" :. "P x->" ~ "Ax, P(x)"
19:05:55 <roconnor> no
19:06:28 <roconnor> "P x->" ~ "P(x0,x1,...,xn)"
19:08:31 <jbc> Ax e x0..xn, P(x). Gotcha. 
19:08:49 <carp> no
19:09:25 <roconnor> P can take multiple parameters
19:09:43 <jbc> not hugely taken with the pedagogical style - he requires you to buffer a HUGE amount of stuff before the context is revealed
19:09:46 <jbc> ah
19:09:49 <jbc> I see
19:10:32 <roconnor> he should probably do the examples first, then the definition.
19:12:35 <jbc> or just a little prose, dammit. This is topic X. It covers concepts such as a, b and c, which will introduce Y.
19:13:19 <jbc> thanks for the help :)
19:16:20 <roconnor> my powerset function doesn't work on infinite lists
19:16:29 <roconnor> hmmm
19:16:37 <jbc> try baking soda andlemon juice instead
19:16:39 <roconnor> but I suppose it can't 
19:17:14 <roconnor> power set, not baking powder
19:17:21 <jbc> hehe
19:17:27 <roconnor> ;)
19:18:32 <roconnor> *sigh* I need a sorting function that also returns the parity change.
19:19:42 <carp> the Js in 1.4 should have arrows on too
19:19:44 <sieni_> ro: you'd need support for uncountable lists ;-)
19:20:24 <carp> possibly two
19:20:39 <roconnor> sieni_: I suppose I won't be able to memoize 2^aleph_0 possible function calls
19:21:31 <roconnor> I'll just memoize the first few
19:21:59 <roconnor> 2^10 ought to be enough
19:22:26 <roconnor> all the computation I plan to do will be in that range
19:26:12 <roconnor> hmmm I don't actually need 2^aleph_0
19:26:23 <roconnor> I just want all the finite subsets of [0..]
19:46:40 <xerox> G'day.
19:48:00 <roconnor> @type scanr
19:48:01 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> [b]
19:48:04 <roconnor> @type foldr
19:48:05 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
19:48:40 <roconnor> @type scanl
19:48:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
19:49:45 <sieni_> roconnor: well that should be easy
19:54:06 <roconnor> bah
19:54:14 <roconnor> let x = []:([0..]>>=(\n -> (map (n:) (take (2^n) x)))) in take 10 x
19:54:17 <roconnor> > let x = []:([0..]>>=(\n -> (map (n:) (take (2^n) x)))) in take 10 x
19:54:18 <lambdabot> [[],[0],[1],[1,0],[2],[2,0],[2,1],[2,1,0],[3],[3,0]]
19:54:27 <roconnor> must be an nicer way
19:54:37 <xerox> @pl \x -> []:([0..]>>=(\n -> (map (n:) (take (2^n) x))))
19:54:38 <lambdabot> ([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2 ^))
19:54:43 <xerox> If you will.
19:54:48 <roconnor> thanks :P
19:54:51 <xerox> :D
19:54:56 <Cale> what is that?
19:55:10 <roconnor> all finite subsets of [0..]
19:55:12 <olliej> Cale: hideous?
19:55:15 <Cale> ah, okay
19:55:34 <roconnor> xerox: you need a fix in there somewhere I think
19:56:43 <xerox> Ah, I see.
19:56:54 <xerox> @pl x = []:([0..]>>=(\n -> (map (n:) (take (2^n) x))))
19:56:55 <lambdabot> x = fix (([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2 ^)))
19:56:58 <xerox> :-)
19:57:04 <roconnor> better
19:57:28 <roconnor> blah, it looks like perl
19:57:32 <xerox> How to fix it?  Use fix.
19:57:57 <roconnor> take 10 $ fix (([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2 ^)))
19:58:01 <roconnor> > take 10 $ fix (([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2 ^)))
19:58:02 <lambdabot> [[],[0],[1],[1,0],[2],[2,0],[2,1],[2,1,0],[3],[3,0]]
19:58:13 <xerox> That's funny.
19:59:21 <roconnor> > take 10$ map sort $ fix (([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2 ^)))
19:59:22 <lambdabot> [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3]]
19:59:54 <xerox> Wrooom.  Wrooom.
20:00:11 <roconnor> > take 10$ map reverse $ fix (([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2 ^)))
20:00:12 <lambdabot> [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3]]
20:00:12 <xerox> (There's some guy making noise out of my window, in the street.)
20:00:56 <roconnor> @pl map reverse $ fix (([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2 ^)))
20:00:57 <lambdabot> map reverse (fix (([] :) . ([0..] >>=) . liftM2 map (:) . flip (take . (2
20:00:57 <lambdabot> ^))))
20:01:06 <roconnor> oh
20:01:32 <roconnor> okay now that it is in point free form we can reason about it to opitmize it right?
20:01:42 <roconnor> How does map interact with fix?
20:05:11 <roconnor> @pl finiteSubsets l = fix (([] :) . (l >>=) . liftM2 map (:) . flip (take . (2 ^)))
20:05:11 <lambdabot> finiteSubsets = fix . (([] :) .) . (. (liftM2 map (:) . flip (take . (2 ^)
20:05:11 <lambdabot> ))) . (>>=)
20:05:57 <roconnor> > fix (([] :) . ([0..2] >>=) . liftM2 map (:) . flip (take . (2 ^)))
20:05:58 <lambdabot> [[],[0],[1],[1,0],[2],[2,0],[2,1],[2,1,0]]
20:07:19 * xerox rubs his eyes
20:09:15 <audreyt> so, my talk at OSDC.il is coming up in ~2 hours
20:09:30 <roconnor> audreyt: what is it about?
20:09:31 <audreyt> I've revamped my slides quiet a bit, so feedback welcome:
20:09:32 <audreyt> http://xrl.us/j7no
20:09:38 <audreyt> (requires firefox)
20:09:38 <xerox> What is OSDC.il ?
20:09:48 <xerox> Oh, takashi?
20:09:52 <audreyt> http://osdc.org.il/
20:09:56 <audreyt> takahashi, yeah
20:09:59 <xerox> Great :-)
20:10:37 <roconnor> oh, this isn't that european open source conference.
20:10:45 <xerox> Are you related to Autrijus somehow? :-)
20:10:51 <audreyt> no, that's the debut to this talk
20:10:57 <audreyt> xerox: I'm a better version of Autrijus
20:11:06 <xerox> Stunning.
20:11:07 <audreyt> # http://pugs.blogs.com/audrey/2005/12/runtime_typecas.html
20:11:10 <roconnor> autrijus 2.0
20:14:14 <xerox> audreyt: how's pugs?
20:15:10 <audreyt> xerox: very well
20:15:14 <audreyt> I'm larry's ghost writer now
20:15:22 <xerox> What's a ghost writer?
20:15:22 <audreyt> so spec/implementation happens in a very fast iteration cycle
20:15:28 <roconnor> how do I make .xul slides like that?
20:15:31 <audreyt> he has bare ideas, I put them into spec
20:15:35 <audreyt> roconnor: just copy that single .xul file
20:15:40 <audreyt> and takahashi.js and euroscon.cs
20:15:41 <xerox> roconnor: save the xul, and move the pointer up!
20:15:41 <audreyt> that's all
20:15:44 <audreyt> try (view source)
20:19:25 <roconnor> the Takahashi method
20:19:50 <roconnor> audreyt: how long are you talking?
20:23:07 <roconnor> Yay for variables never changing!
20:23:29 <roconnor> variables doing as they should: staying constant
20:26:04 <xerox> Hmpf, after ":i name" my firefox crashes.
20:26:45 <roconnor> It's a big lambda afterwards ;)
20:27:30 <xerox> The 18th :(
20:27:49 * xerox blames audreyt 
20:28:25 <roconnor> works for me under mozilla 1.7.12
20:29:21 <roconnor> oh
20:29:29 <mauke> works in my firefox
20:29:30 <roconnor> does data Foo where actually work?
20:30:22 <roconnor> @type partition
20:30:22 <lambdabot> Not in scope: `partition'
20:30:29 <integral> roconnor: that's the GADT stuff in GHC 6.4
20:30:37 <roconnor> nice
20:31:01 <xerox> It crashes for a friend of mine too O_o
20:31:06 <roconnor> I wonder if this will make Haskell extraction from Coq easier
20:31:14 <xerox> @hoogle partition
20:31:15 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
20:31:15 <lambdabot> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
20:31:15 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
20:31:45 <roconnor> @type span
20:31:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:31:58 <roconnor> what's the difference between partition and span?
20:32:05 <roconnor> oh wait
20:32:07 <roconnor> I see
20:33:32 <xerox> audreyt: you did a very good job with colors, imo.
20:35:53 <roconnor> @hoogle forAll
20:35:53 <lambdabot> Test.QuickCheck.forAll :: (Show a, Testable b) => Gen a -> (a -> b) ->
20:35:53 <lambdabot> Property
20:35:53 <lambdabot> Language.Haskell.TH.Lib.forallC :: [Name] -> CxtQ -> ConQ -> ConQ
20:35:53 <lambdabot> Language.Haskell.TH.Lib.forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
20:43:50 <xerox> Heh, Nymphaea again!
22:00:44 <dons> I like thee smiley way to write: ([] :)
22:01:03 * dons should scroll down first.
22:01:19 <xerox> Yay,.
22:02:35 <dons> a haskell idiom based soley on [] and :) would be good:  lots of ((: []) :)
22:02:39 <dons> @type ((: []) :)
22:02:39 <lambdabot> forall a. [a -> [a]] -> [a -> [a]]
22:03:09 <dons> and then maybe some other silly smilies
22:03:54 <dons> @type ((((: []) :) [] :) :)
22:03:54 <lambdabot> forall a.
22:03:54 <lambdabot>          [[[a -> [a]]] -> [[a -> [a]]]] -> [[[a -> [a]]] -> [[a -> [a]]]]
22:04:02 <dons> smileys for all!
22:04:18 <olliej> dons: hehe
22:04:51 <mauke_> @djinn [[[a -> [a]]] -> [[a -> [a]]]] -> [[[a -> [a]]] -> [[a -> [a]]]]
22:04:51 <lambdabot> f a = a
22:04:56 <dons> @type (((((((((((((: []) :) [] :) :) :) :) :) :) :) :) :) :) :) -- dare I?
22:05:00 <lambdabot> forall a.
22:05:00 <lambdabot>                      [[[[[[[[[[[[a -> [a]]] -> [[a -> [a]]]]
22:05:00 <lambdabot>                         -> [[[a -> [a]]]
22:05:00 <lambdabot>                          -> [[a -> [a]]]]]
22:05:00 <lambdabot>                        -> [[[[a -> [a]]]
22:05:02 <lambdabot> [3095 @more lines]
22:05:08 <xerox> FOO.
22:05:17 <olliej> hehe
22:05:39 <dons> djinn did a surprisingly good job there. it understands lists now?
22:06:22 <xerox> Does it?
22:06:37 <dons> well, that tricky list type didn't confuse it.
22:06:46 <dons> @djinn-ennv
22:06:47 <lambdabot> data () = ()
22:06:47 <lambdabot> data Either a b = Left a | Right b
22:06:47 <lambdabot> data Maybe a = Nothing | Just a
22:06:47 <lambdabot> data Bool = False | True
22:06:47 <lambdabot> data Void
22:06:49 <lambdabot> type Not x = x -> Void
22:06:51 <lambdabot> data Example
22:06:55 <xerox> @djinn a -> [a] -> [a]
22:06:56 <lambdabot> f _ a = a
22:07:15 <xerox> That's cheating.
22:07:26 <dons> @djinn-ver
22:07:26 <lambdabot> Djinn version 2005-12-15.
22:07:47 <Lemmih> @djinn (a -> b) -> [a] -> [b]
22:07:47 <lambdabot> -- f cannot be realized.
22:07:47 <dons> @djinn [a] -> a
22:07:47 <lambdabot> -- f cannot be realized.
22:08:06 <dons> ah, that's polymorphism for you
22:08:51 <dons> deriving map would be a good trick
22:18:25 <astrolabe> Is there a standard technique for having a monad that keeps track of a state, and does IO?
22:18:50 <astrolabe> where the state has a type defined by me.
22:19:04 <mauke> something with monad transformers, probably
22:19:11 <Lemmih> StateT YourType IO?
22:19:11 <mauke> @index (<<)
22:19:12 <lambdabot> Text.Html
22:19:18 <mauke> what the
22:19:24 <astrolabe> I suppose I could just chuck it all into IO?
22:19:36 <mauke> @type Text.Html.(<<)
22:19:37 <lambdabot> Couldn't find qualified module.
22:19:37 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
22:19:37 <lambdabot> \\)?
22:19:42 <mauke> @type (Text.Html.<<)
22:19:42 <astrolabe> @hoogle StateT
22:19:43 <lambdabot> forall b a.
22:19:43 <lambdabot>       (Text.Html.HTML a) =>
22:19:43 <lambdabot>       (Text.Html.Html -> b) -> a -> b
22:19:43 <lambdabot> Control.Monad.State.StateT :: StateT s m a
22:19:43 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
22:19:45 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
22:21:06 <astrolabe> Thanks guys
22:23:22 <liyang> cd d
22:23:30 <liyang> yo all
22:23:37 <olliej> yoyo
22:27:04 <roconnor> > let f l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$f l} in take 10$["0"..]
22:27:04 <lambdabot>  add an instance declaration for (Enum [Char])
22:27:23 <roconnor> > let f l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$f l} in take 10$['0'..]
22:27:23 <lambdabot> "0123456789"
22:27:37 <roconnor> > let f l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$f l} in take 10$f ['0'..]
22:27:37 <lambdabot> ["","0","1","10","2","20","21","210","3","30"]
22:27:42 <mauke> @pl f p q = p >>= \x -> q >> return x
22:27:42 <lambdabot> f = (. ((. return) . (>>))) . (>>=)
22:27:48 <mauke> ew
22:28:08 <roconnor> @pf f l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$f l}
22:28:08 <lambdabot> (line 1, column 10):
22:28:08 <lambdabot> unexpected "{"
22:28:08 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++" or end of
22:28:08 <lambdabot> input
22:28:16 <roconnor> oh yea, no do
22:28:24 <sieni_> > ['A'..'z']
22:28:25 <lambdabot> "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
22:29:22 <bejs> > sum . takeWhile (/= 0) . (map (\x -> 1/(product [1..x]))) $ [1..]
22:29:23 <lambdabot> 1.7182818284590455
22:31:07 <bejs> > exp 1
22:31:08 <lambdabot> 2.718281828459045
22:31:22 <bejs> does anyone know why that happens?
22:31:34 <mauke> @pl sum . takeWhile (/= 0) . (map (\x -> 1/(product [1..x]))) $ [1..]
22:31:35 <lambdabot> sum (takeWhile (0 /=) (map ((1 /) . product . enumFromTo 1) [1..]))
22:31:38 <sieni_> bejs: what?
22:32:03 <bejs> If you take 1/1! + 1/2! + 1/3! + 1/4! etc. you get e-1
22:32:27 <sieni_> bejs: because that's the usual series of e-1?
22:32:36 <bejs> I did not know that
22:32:49 <bejs> (about e)
22:33:25 <sieni_> http://en.wikipedia.org/wiki/Exponential_function#Formal_definition
22:33:52 <bejs> aha
22:34:02 <bejs> thanks
22:34:05 <mauke> > take 12 $ scanr (+) 0 $ filter (\n -> n `mod` 2 == 1) [0..] -- does that work?
22:34:08 <lambdabot> Terminated
22:38:13 <sieni_> bejs: that's nice one: http://en.wikipedia.org/wiki/Definitions_of_the_exponential_function
22:39:05 <roconnor>  > sum . takeWhile (/= 0) . (map (\x -> 1/(product [1..x]))) $ [0..]
22:40:00 <bejs> I seee
22:42:56 <roconnor> mauke: [1,3..]
22:43:36 <mauke> do you think defining << as p << q = do { x <- p; q; return x } makes sense?
22:44:11 <roconnor> not really
22:44:21 <roconnor> hmmm
22:44:40 <mauke> what's a better name for it?
22:45:33 <roconnor> @type (<<)
22:45:34 <lambdabot> Not in scope: `<<'
22:45:37 <roconnor> @type (>>)
22:45:37 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
22:45:45 <roconnor> @type (>>=)
22:45:45 <lambdabot> forall (m :: * -> *) b a.
22:45:45 <lambdabot>    (Monad m) =>
22:45:45 <lambdabot>    m a -> (a -> m b) -> m b
22:45:51 <roconnor> @type (=<<)
22:45:52 <lambdabot> forall b (m :: * -> *) a.
22:45:52 <lambdabot>    (Monad m) =>
22:45:52 <lambdabot>    (a -> m b) -> m a -> m b
23:00:34 <mauke> @type \n p -> sequence $ replicate n p
23:00:35 <lambdabot> forall (m :: * -> *) a.
23:00:35 <lambdabot>             (Monad m) =>
23:00:35 <lambdabot>             Int -> m a -> m [a]
23:05:41 <roconnor> @info Data.Map
23:05:42 <lambdabot> Unknown command, try @listcommands.
23:05:51 <roconnor> @docs Data.Map
23:05:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
23:25:26 <mauke> >> is associative, right?
23:27:30 <roconnor> I would assume so
23:28:50 <mauke> because now I have  between open close p = open >> p << close  :-)
23:29:13 <xerox> heh
23:30:06 <mauke> sepEndBy, sepEndBy1 :: (forall b. Combine (Parser tok st b)) -> Parser tok st a -> Parser tok st sep -> Parser tok st [a]
23:30:20 <mauke> sadly, this type requires -fglasgow-exts
23:31:32 <integral> that's sad?
23:31:51 <mauke> yeah, the rest of the file is standard haskell
23:32:23 <integral> I mean you can do cool stuff with glasgow-exts like take a list of functions, and fold a composition over that, but with the functions being of different types!
23:33:11 <mauke> I just want to combine parsers :/
23:34:22 <integral> there's always other parsing libraries like PArrow, or I think Text.Parser.Rule (a PGE port?)
23:37:48 <mauke> where's the fun in that?
23:39:46 <tibbe> anyone have a dependecy sorting algorithm laying around?
23:40:18 <tibbe> say: depSort :: [(String, [String])] -> [String]
23:49:15 <audreyt> @pl \f -> (!! 2) . iterate f
23:49:16 <lambdabot> ((!! 2) .) . iterate
23:53:14 * xerox wants hIDE
23:53:27 <xerox> Who's up-to-date about hIDE and yi technologies?
23:54:32 <Lemmih> I am, kinda.
23:55:09 <xerox> Do I need ghc-cvs to get into that?
23:56:10 <Lemmih> You need ghc.hide. The README in hIDE can tell you where to get it and how to build it.
23:58:27 <roconnor> Heh, my implemenation of Clifford algebra is 40 lines
23:59:07 <roconnor> +11 lines from another file.
