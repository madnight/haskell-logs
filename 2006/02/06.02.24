00:00:24 <ncalexan> I will read it, but what kind of comments are you interested in?
00:03:22 <tibbe> code quality
00:03:29 <tibbe> suggestions on improvements
00:03:39 <tibbe> better ways of doing things
00:03:40 <xerox> post it!
00:03:50 <tibbe> http://www.itstud.chalmers.se/~larssont/Interpreter.hs
00:04:07 <tibbe> http://www.itstud.chalmers.se/~larssont/Syntax.hs could be useful
00:04:26 * wli ponders his Special function library.
00:04:38 <xerox> That's pretty nice tibbe.
00:04:52 <tibbe> I think the binary function is messy
00:04:59 <tibbe> and not general enough
00:05:26 <tibbe> I want to parameterize it over the data constructor so I can use it for both VInt and VBool
00:06:32 <ncalexan> Well, that's easy enough.
00:06:43 * wli wonders if function names like sn, cn, dn will pass namespace pollution filters.
00:07:07 <ncalexan> They wouldn't pass mine.
00:07:16 <ncalexan> Not at the top level, at least.
00:07:50 <wli> There's a problem, then. Those are the standard names for those functions (Jacobian elliptic functions).
00:08:29 <wli> There are probably a few others that wouldn't pass muster, either.
00:08:48 <ncalexan> tibbe: the code looks fine, i.e. it looks idiomatic to me.
00:08:54 <wli> Polynomial families.
00:09:36 <ncalexan> wli: well, that's a matter of choice, I'd say.  Why not lagrangeLambda instead of l for lambda, or jacobiTheta2 for the theta series... or ellipticJ for the j-invariant or whatever.
00:09:40 <wli> Lambert W, Bessel, Hankel, hypergeometric (the closest approximation is "f"), etc.
00:09:51 <ncalexan> If you need the short names, import them as such.
00:10:25 <wli> jacobiSN, jacobiCN, jacobiDN, alrighty
00:10:36 <ncalexan> Is the n a subscript?
00:10:41 <wli> j-invariants don't come up much.
00:10:53 <wli> No, it's Glaisher's notation for them.
00:11:11 <wli> The 'n' denotes a "null" or factor of 1.
00:11:29 <wli> So dn has no denominator, but sd is sn/dn
00:11:37 <wli> cs is cn/sn
00:11:47 <wli> Shorthand for ratios.
00:11:59 <wli> (also, nc is 1/cn, etc.)
00:12:55 <wli> It's sometimes written as pq = pn/qn = 1/qp or pq*qp = 1
00:18:25 <wli> sn(x,k)^2 + cn(x,k)^2 = 1, dn(x,k)^2 + k^2*sn(x,k)^2 = 1, int_0^{sn(x,k)}dt/\sqrt{(1-t^2)(1-k^2t^2)} = x, etc.
00:18:39 <sieni> -funbox-strict-fields <3
00:26:03 <wli> Do the libraries have some sort of norm yet?
00:26:27 <xerox> Could anybody share its haskell-mode configuration for Emacs?
00:26:44 <wli> e.g. class Normed t where norm :: t -> Double or some such?
00:30:36 <ValarQ> xerox: i could, but i don't think you'll have much use for it :(
00:31:38 * ValarQ is having problem tweaking haskell-mode
00:32:28 <xerox> Me too.
00:34:12 <ValarQ> the worst problem is that of indentation at do-notation
00:36:16 <ProfTeggy> Use >>= then and lambdas then. ;-)
00:36:24 <ProfTeggy> (sorry)
00:36:50 <ProfTeggy> I'm not all too fond of haskell-mode either
00:36:51 <ValarQ> hmm, that might just work :)
00:37:14 <ncalexan> ValarQ: it seems nobody like the haskell-mode indentation.  The good thing is that it respects your first line, so you only need to indent once and it will obey your choice.
00:37:14 <ProfTeggy> Especially if you write literate Hasekll
00:37:29 <ValarQ> ncalexan: yeah, thats how i use it now
00:37:31 <xerox> In fact configuring haskell-mode is a tricky thing.
00:37:52 <xerox> Maybe there's something on the wiki... but *allt* the pages seem to be outdated.
00:38:05 <ValarQ> xerox: and still its not enough settings to tweak...
00:41:46 <gour> xerox: have you ltest hIDE built, i.e. does it use Yi or gtk editor cmponent?
00:42:05 <xerox> gour: No, I have not.
00:42:55 <gour> xerox: ahh..here (amd64) hIDE blows ghc stack while building haskellSense :-(
00:43:12 <xerox> :-\
00:43:22 <xerox> I ought to try it sometime again.
00:46:03 <Maddas> ski: ping
00:52:14 * xerox sigs at pretty symbols <http://img46.imageshack.us/img46/2135/emacs8qp.png>
00:52:43 <ValarQ> :/
01:04:18 * gour sighs that life is too short to master emacs and exclaims "simplify! simplify!"
01:23:44 <tibbe> Could someone help me generalize this function?
01:23:52 <tibbe> binary f = VFun $ \(VInt v1) ->
01:23:52 <tibbe>            return $ VFun $ \(VInt v2) ->
01:23:52 <tibbe>            return $ VInt (f v1 v2)
01:24:11 <xerox> binary f = undefined
01:24:25 <tibbe> I want it to work on a VBool data constructor also, and f should be either Int -> Int -> Int or Bool -> Bool -> Bool
01:24:31 <tibbe> :p
01:24:41 <xerox> That's the MOST general :-)
01:24:54 <xerox> What type would this function have?
01:25:26 <xerox> Either (Int -> Int -> Int) (Bool -> Bool -> Bool) -> ... ?
01:26:21 <tibbe> dunno
01:26:31 <tibbe> it should return Value
01:26:42 <tibbe> data Value = VFun (Value -> Eval Value)
01:26:42 <tibbe>            | VInt Int
01:26:42 <tibbe>            | VBool Bool
01:27:04 <tibbe> a VFun
01:27:28 <tibbe> it's from the code I posted before
01:27:36 <tibbe> earlier today that is
01:28:04 <tibbe> I was thinking something along the line of (a -> Value) (a -> a -> a) -> Value
01:28:08 <xerox> binary :: Either (Int -> Int -> Int) (Bool -> Bool -> Bool) -> Value
01:28:08 <xerox> binary (Left f) = VFun $ \(VInt v1) -> return $ VFun $ \(VInt v2) -> return $ VInt (f v1 v2)
01:28:11 <xerox> binary (Right f) = ...
01:28:16 <xerox> But I don't know if it's what you want.
01:28:40 <tibbe> lets say that I want to be able to add extra data contructors such as VChar, VDouble etc
01:28:52 <xerox> I think you need a typeclass.
01:29:07 <xerox> (To being able to dispatch on types as you want)
01:29:28 <tibbe> the problem is the stripping of the data constructors
01:29:28 <tibbe> I thought that too, but what would it look like?
01:29:28 <tibbe> the data constructors makes me a bit confused
01:29:52 <tibbe> like: instance Binary VInt where .... ?
01:29:58 <xerox> class Binary t where binary :: t -> t -> Value t
01:30:26 <xerox> Err, 'Value'.
01:30:37 <xerox> Oh-uhm. No way.
01:30:59 <xerox> What is 'binary's purpose?
01:31:18 <tibbe> http://www.itstud.chalmers.se/~larssont/Interpreter.hs
01:31:33 <xerox> Any wordy explanation available?
01:31:36 <tibbe> to construct VFun's for the built-in functions in my environment
01:32:05 <tibbe> so I can say binary (+) and get a nested lambda the uses +
01:32:15 <xerox> I think you can go this way:
01:32:35 <xerox> Let me try if, before telling you other crap.
01:32:43 <tibbe> so basically I want to build an environment of Value:s
01:32:51 <tibbe> sure
01:36:03 <xerox> OK, it doesn't work.
01:36:08 <tibbe> no
01:36:15 <xerox> My idea, that is.
01:36:17 <tibbe> i tried to instance Binary VInt
01:36:21 <tibbe> okay
01:36:29 <tibbe> but I couldn't do what I just said
01:36:59 <xerox> Idea!
01:37:33 <tibbe> :)
01:39:26 <xerox> You'd have to restrict (+) Num a => a -> a -> a to some defined 'a', is it ok with you?
01:40:26 <tibbe> hmm
01:40:37 <tibbe> does that mean I can't use booleans? 
01:40:41 <xerox> You can.
01:40:43 <xerox> class Binary t where
01:40:43 <xerox>   binary :: (t -> t -> t) -> Value
01:40:44 <tibbe> isn't (+) already restricted
01:40:49 <xerox> baseEnv = [("+", binary ((+) :: Int -> Int -> Int)),
01:40:52 <xerox>          ..
01:40:57 <xerox>            ("/=", binary (/=))]
01:41:01 <xerox> instance Binary Int where
01:41:19 <xerox>   binary f = VFun $ \(VInt v1) -> return $ VFun $ \(VInt v2) -> return $ VInt (f v1 v2)
01:41:23 <xerox> instance Binary Bool where
01:41:26 <xerox>   binary f = ...
01:41:29 <xerox> ...and so on.
01:41:29 <tibbe> ah
01:41:41 <tibbe> that's good, too bad that the explicit type is neccesary
01:41:46 <xerox> Indeed.
01:42:15 * xerox goes hunting for breakfast
01:42:47 <tibbe> thanks, enjoy your brakfast
01:43:45 <xerox> You're welcome.
01:44:52 <tibbe> s/brakfast/breakfast
01:57:39 <tibbe> @type (+)
01:57:40 <lambdabot> forall a. (Num a) => a -> a -> a
02:25:29 <taw> hello again :-)
02:25:48 <taw> how do people typically code preconditions to various functions ?
02:26:30 <taw> like assert(n>=0) in some other language
02:26:56 <Lemmih> @type Control.Exception.assert
02:26:57 <lambdabot> forall a. Bool -> a -> a
02:27:13 <Lemmih> assert (cond) $ [rest of function body]
02:28:33 <taw> nice :-)
03:09:07 <xerox> > let f x = Control.Exception.assert (x > 2) x in f 1
03:09:08 <lambdabot>  Not in scope: `Control.Exception.assert'
03:09:59 <sieni> hmm... I suppose lambdabot can be reconfigured while running
03:10:38 <xerox> http://www.menzelphoto.com/gallery/big/dnafingerprinting3.htm
03:16:08 <tibbe> @type Either
03:16:08 <lambdabot> Not in scope: data constructor `Either'
03:16:15 <tibbe> @index Either
03:16:16 <lambdabot> Data.Either, Prelude
03:16:29 <tibbe> @type Left
03:16:30 <lambdabot> forall b a. a -> Either a b
03:17:16 <tibbe> if I have a data constructor c (for all c) which takes one argument, is there a way to write a general unC that strips away the constructor?
03:19:00 <xerox> Heh.  That seems an hot topic.
03:21:22 <Lemmih> tibbe: No.
03:22:30 <tibbe> xerox, ;)
03:22:40 <tibbe> I don't like the repetition in my source
03:22:49 <tibbe> it screams duplicated code at me
03:23:19 <tibbe> even a textual replace macro would do it so I feel that it ought to be doable in haskell
03:23:43 <Lemmih> You can do it with TH.
03:24:12 <Lemmih> But 'newtype/data X = X {unX :: ...}' isn't that much to write.
03:25:21 <tibbe> can I post the relevant code? it's 6 lines
03:25:58 <Lemmih> @paste
03:25:59 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:26:26 <tibbe> @where paste
03:26:26 <lambdabot> http://paste.lisp.org/new/haskell
03:27:01 <tibbe> bah, http://www.itstud.chalmers.se/~larssont/Interpreter.hs
03:27:07 <tibbe> the two instance declarations
03:27:25 <tibbe> they are identical except for the VInt <-> VBool
03:29:15 <xerox> Don't be picky, heh.
03:29:52 <tibbe> but don't you agree that it "feels" like it should be parallizable?
03:30:24 <xerox> Possibly.
03:30:56 <xerox> Sounds like a work for '... deriving', but on pre-defined types.   So hey.
03:31:05 <Lemmih> How about: VFun $ \a1 -> return $ VFun $ \a2 -> return (mkT (unT a1 `op` unT a1)) ?
03:31:24 <Lemmih> Then you just provide 'mkT', 'unT' and 'op'.
03:31:57 <tibbe> hmm
03:32:06 <xerox> Howdy ndm, how's hoogle?
03:32:12 <Lemmih> 'instance Binary Int where binary = mkBinary mkInt unInt'
03:32:39 <tibbe> I'll try that
03:32:39 <ndm> xerox, making slow progress - don't have much time to work on it. Have almost finished hacking haddock to generate hoogle files - hopefully a patch will be sent this weekend
03:33:01 <ndm> i just need a day to crush a few complex bugs, but alas time is in short supply
03:33:07 <Lemmih> tibbe: 'data Value = VInt {unInt :: Int}' and mkInt = VInt.
03:33:33 <xerox> Lemmih: I think he needs GADTs for the interpreter
03:33:42 <tibbe> I get the mkInt, is the unInt some kind of record?
03:33:46 <xerox> One could still use records there?
03:34:29 <xerox> Prolly,yes.
03:34:40 <Lemmih> xerox: That would make it even easier I think. Then he could make a general 'unValue'.
03:35:22 <xerox> Agreed.
03:36:20 <tibbe> so what does data Value = VInt {unInt :: Int} mean, that there's a function unInt somewhere that takes an int and returns a VInt?
03:36:42 <tibbe> would GADTs solve this?
03:36:42 <xerox> The other way around.
03:36:47 <Lemmih> tibbe: Other way around. It takes a Value and gives an Int.
03:36:57 <tibbe> that's what I meant ;)
03:37:09 <tibbe> but do I define that function on the top level somwhere?
03:37:28 <Lemmih> No, Haskell defines it for you.
03:39:55 <mauke> unInt . VInt = id
03:40:42 <tibbe> alright, what GHC version is needed for that? I guess it's not haskell 98
03:41:17 <Lemmih> tibbe: Is /is/ Haskell98.
03:41:27 <xerox> VInt . unInt = id :: VInt -> VInt
03:41:39 <tibbe> oh
03:41:46 <mauke> tibbe: http://haskell.org/onlinereport/decls.html#field-labels
03:42:21 * tibbe is reading
03:48:18 <gour> dcouuts: ping
03:49:19 <gour> dcoutts: ping
03:49:30 <dcoutts> ih gour 
03:49:33 <dcoutts> ih/hi
03:50:13 <gour> dcoutts: two days ago i received reminder for updating gtk2hs.org domain. what do you think?
03:50:30 <dcoutts> gour, I'd say let it go
03:50:37 <dcoutts> don't pay again
03:54:46 <gour> you don't count an gtk2hs world-wide conquering tour?
03:54:59 <vincenz> 2darcs failed:  (sftp) failed to fetch files.
03:55:50 <dcoutts> gour, of course! :-) but I'm happy for it to be hosted at haskell.org
03:56:30 <gour> dcoutts: huh...now 'm relieved :-) so haskell.org hosting should be stable enough
03:56:46 <dcoutts> gour, I'm pretty sure, yes
03:57:58 <gour> dcoutts: fine. another Q: what would be preferrable common denominator for distributing app-documentation (manual) for multi-OS application?
03:58:25 <gour> win32 used to have chm, linux has several option, don't know about mac os?
03:59:37 <dcoutts> gour, plain html
03:59:58 <gour> dcouuts: thanks
04:01:14 <gour> dcoutts: have you seen http://sourceforge.net/projects/wyneken
04:01:58 <dcoutts> gour, sounds like txt2tags
04:02:17 <gour> dcoutts: yep
04:02:50 <gour> dcoutts: "Wyneken documents are written in a bbcode-style markup that gets converted into a LaTeX document."
04:27:13 <Lemmih> Hurrah. My dead code analyzer is finally working with all Glasgow Haskell code.
04:27:21 * Lemmih will make some screenshots.
04:27:43 * mauke whispers: "I see dead code!"
04:28:54 <kosmikus> Lemmih: sounds great
04:29:20 <vincenz> Is is possible to check the return code of darcs "pull" to see if changes were done or not in a bash script?
04:29:26 <dcoutts> Lemmih, cool! are there any obvious interesting dead bits?
04:33:00 <roconnor> @seen roconnor
04:34:04 <lambdabot> Unknown command, try @listcommands.
04:34:37 <roconnor> @vixen
04:34:37 <lambdabot> You should add me to your buddy list!
04:35:06 <Lemmih> http://darcs.haskell.org/~lemmih/ MoreHaskell.png exposedButUnused.png Effect.png
04:35:13 <alar> @vixen
04:35:14 <lambdabot> i find it hard to masturbate when the lights are on.
04:35:23 <alar> @yow
04:35:23 <lambdabot> MMM-MM!!  So THIS is BIO-NEBULATION!
04:36:25 <dcoutts> Lemmih, looks great, so that's using the ghc api?
04:38:35 <Lemmih> dcoutts: Yep.
04:38:52 <dcoutts> Lemmih, imprssive
04:38:54 <Lemmih> dcoutts: It works with all of Glasgow Haskell and all Cabal libraries.
04:39:05 <dcoutts> @karma+ Lemmih 
04:39:05 <lambdabot> Lemmih's karma raised to 11.
04:44:07 <xerox> Gerdnere?
04:44:11 <xerox> Gardener?
04:44:41 <tibbe> Lemmih, I've implemented the changes now :) I'm not sure if I increased or decreased readability though %)
04:45:24 * xerox wants to understand Lemmih-fu 
04:45:46 <Lemmih> @dict Gardener
04:45:47 <lambdabot> Supported dictionary-lookup commands:
04:45:47 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
04:45:47 <lambdabot> jargon @lojban @vera @web1913 @wn @world02
04:45:47 <lambdabot> Use "@dict-help [cmd...]" for more.
04:46:20 <xerox> Well, I understand what it means.  It's very cool.
04:46:46 <dons> @y0w
04:46:46 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me to
04:46:46 <lambdabot> Minnesota but don't EMBARRASS me!!
04:46:59 <xerox> Lemmih: is the code highlighted somehow?
04:47:17 <xerox> I can see a yellowish background if I move around the LCD screen.
04:47:33 <dons> Lemmih, cool! are you going to write a HW paper? :)
04:48:02 <dons> this ghc-api stuff is really very impressive, Lemmih.
04:50:33 <Lemmih> xerox: Hm, I should probably make it more noticeable.
04:50:49 <xerox> What does the highlight mean?
04:51:38 <tibbe> are there any Haskell code documentation guidelines?
04:51:42 <Lemmih> xerox: It highlights the code that can be removed.
04:51:50 <musasabi> JohnMeacham: Have you use http://darcs.haskell.org/testsuite/ with jhc?
04:51:56 <xerox> tibbe: Haddock?
04:52:25 <xerox> Lemmih: can you tell me more about ghc-api?  Where what who when.. :-)
04:52:27 <Lemmih> xerox: Gardener tries to find the smallest blocks of code that can be removed and then askes the user whether to delete it or to keep it.
04:53:11 <Lemmih> xerox: ghc-api is GHC (:
04:53:54 <Lemmih> The greatest library ever.
04:54:10 <Lemmih> And the ugliest, I think. (:
04:54:20 <gour> Lemmih: why ghc-api?
04:55:14 <tibbe> xerox, well, I'm not going to generate any documentation, I was thinking of in code documentation (and also code style/formatting)
04:55:44 <Lemmih> gour: I need the renamed (aka. qualified) source.
04:55:56 <dons> tibbe, check out the style pages on the old and new wikis on haskell.org
04:56:14 <JohnMeacham> musasabi: no, but I'd love a real testsuite framework. I have a sort of cobbled together one from the 'nofib' suite.
04:56:50 <gour> Lemmih: any other usage?
04:57:06 <dons> @oldwiki HaskellStyle
04:57:06 <lambdabot> http://www.haskell.org/hawiki/HaskellStyle
04:57:44 <tibbe> dons, hmm, I found the old HaWiki, where's the new one?
04:57:47 <tibbe> oh
04:58:30 <Lemmih> gour: No, not really.
04:58:50 <Lemmih> gour: Oh, wait, I also use the typechecking.
04:59:18 <musasabi> JohnMeacham: I just would like a nice way to notice introducing subtle bugs in E generation.
04:59:26 <musasabi> (my own code in this case)
04:59:59 <xerox> Lemmih: how big is the code?
05:00:00 <Lemmih> gour: 'fn = someExpr' depends on the type of the expr. If the type of the expr is 'X' then it wont remove 'X' without removing 'fn'.
05:01:00 <Lemmih> xerox: 644 loc with the GUI code.
05:01:03 <JohnMeacham> musasabi: I have been quite good at introducing such bugs as of late.
05:01:18 <gour> Lemmih: i see. thanks
05:01:52 <xerox> Lemmih: compliments, very good work.
05:13:32 <dons> tibbe, here, it's a new page (the page is in the wrong place, but the content seems ok) : http://haskell.org/haskellwiki/User:Maeder
05:20:52 <tibbe> dons, thanks
05:25:26 <dcoutts_> any MacOS X hackers/users about? What version of gcc does ghc use on MacOS X ?
05:26:11 * dcoutts_ was under the impression that ghc didn't work with gcc 4.x yet, but apparently recent MacOS X only comes with gcc 4.
05:29:02 <JKnecht> checking ...
05:29:56 <JKnecht> 3.3.2 on 10.3
05:30:22 <JKnecht> 10.3.9 to be specific.
05:32:04 <JKnecht> newer 'nix do seem to come with gcc 4, e.g.: FC4.
05:34:11 <musasabi> A small FFI question 'foreign import ccall dynamic ...' or 'foreign import ccall "dynamic" ...' ?
05:34:47 <dcoutts_> JKnecht, good point about FC4, I'll ask juhp 
05:35:07 <dcoutts_> juhp, does your ghc package for FC4 use gcc 3 o4 4?
05:35:07 <JKnecht> and I have ghc on x86_64 w gcc 4.
05:35:18 <dcoutts_> JKnecht, really? oh
05:35:26 <dcoutts_> why doesn't it work for me? :-)
05:35:36 <dcoutts_> JKnecht, is that a vanilla ghc-6.4.1 ?
05:35:49 <musasabi> GHC seems to accept the first, but I think the latter was the standard one?
05:36:02 <dcoutts_> JKnecht, or a distro package or something with extra pactches?
05:36:11 <JKnecht> Macs are problematic. Some consider quais-nix.
05:36:23 <JKnecht> s/quais/quasi/
05:38:05 <JKnecht> dcoutts: yeah, it's standard 6.4.1, yum installed , iirc.
05:38:51 <JKnecht> the stuff in FC extras didn't seem to work/be coordinated.
05:38:57 <dcoutts_> JKnecht, that's on FC4 right? and you're sure it's not using gcc3?
05:39:18 <dcoutts_> FC4 comes with 'gcc' which is 4.x and it also has 'gcc3' I think
05:40:02 <juhp> dcoutts: gcc4
05:40:10 <JKnecht> no gcc3 apparently at least in FC4 x86_64.
05:40:57 <juhp> JKnecht: well there is compat-gcc-32
05:42:00 <dcoutts_> juhp, and gcc4 just works? or did you need any parches to ghc-6.4.1 ?
05:42:02 <jbc> heh, I just realised. I'm doing a haskell-based course (never even looked at functional programming before), alongside an assembly-based course
05:42:18 <jbc> switching mindsets back and forth is going to be severely weird. 
05:42:23 <juhp> JKnecht: I'm actually planning to submit gtk2hs to Fedora Extras "soon", but
05:42:33 <juhp> dcoutts: yeah it works
05:42:41 <juhp> I'm not aware of any problems
05:42:47 <juhp> JKnecht: what are you seeing?
05:43:27 <JKnecht> no compat-gcc-32 either and I did an install "everything".
05:43:29 <dcoutts_> juhp, hmm, ok I'll have to try it on a box where ghc already works. I was getting reports that it didn't work with gcc4 on ppc.
05:43:34 <juhp> JKnecht: have you tried the packages at haskell.org/fedora ?
05:44:07 <dcoutts_> juhp, I used your FC packages for the first time yesterday. Flawless. :-)
05:44:13 <juhp> dcoutts_: at least darcs builds with it ok on ppc
05:44:19 <JKnecht> No, I presume not, since I assume yum gets stuff from RH.
05:44:21 <juhp> dcoutts_: :)
05:44:52 <dcoutts_> juhp, I'm getting gtk2hs working on a FC4 laptop to take to Nottingham to do some demos.
05:44:52 <juhp> JKnecht: yup - but you can find some Haskell packages not yet in Extras there :)
05:45:01 <juhp> dcoutts_: cool
05:45:19 <JKnecht> but I'm not having any problems. So far at least.
05:46:10 <juhp> JKnecht: oh ok - was wondering about "the stuff in FC extras didn't seem to work/be coordinated." :)
05:46:23 <dcoutts_> juhp, the only ones I needed from the extra haskell coolection that were not in FC-extras was alex & happy. Needed to build the darcs version of gtk2hs.
05:46:53 <dcoutts_> juhp, you said a moment ago you might add gtk2hs to fedora extras but...
05:46:56 <juhp> dcoutts_: nod - I'd like to add those too - but lower priority
05:47:01 <dcoutts_> what was the "but..." ?
05:48:25 <juhp> dcoutts_: sorry, dunno -- s/, but//
05:48:38 <juhp> dcoutts_: maybe lack of time ;)
05:48:45 <dcoutts_> juhp, ok :-)
05:48:53 <dcoutts_> that's not something I can help with :-)
05:49:33 <juhp> dcoutts_: well you're free to submit my package... :)  ;)
05:49:44 <dcoutts_> heh
05:50:15 * dcoutts_ has enough to do, getting more haskell packages into gentoo
05:50:35 <juhp> dcoutts_: now that fc5 is nearing completion, I hope to have some moments for it :)
05:50:47 <dcoutts_> juhp, with gtk+ 2.8 and cairo! :-)
05:50:55 <juhp> yay
05:51:15 <juhp> and mono |:
05:51:32 <dcoutts_> juhp, and if Axel & I get round to finnishing up our current stuff, then we'll also have opengl, soe & the new treeview api.
05:51:46 <juhp> wow
05:51:47 <dcoutts_> oh, and svg for cairo
05:51:58 <juhp> lovely
05:52:03 <dcoutts_> renderSVG :: SVG -> Render ()
05:52:11 <dcoutts_> simple
05:52:16 <juhp> cool
05:52:32 * xerox mutters about librsvg
05:52:42 <dcoutts_> xerox, I know! I know!
05:52:43 <dcoutts_> ;-)
05:52:57 <juhp> librsvg?
05:53:08 <dcoutts_> xerox, i'm sure you'll be the first to tell me when librsvg do a release with cairo support
05:53:20 <juhp> heh
05:53:22 <xerox> Agreed.
05:54:24 <dcoutts_> juhp, at the moment I'm using libsvg-cairo for the binding, but it'll move to librsvg when they do a proper release. libsvg is a dead end. librsvg is the future.
05:54:41 <juhp> ah, ok
05:58:44 <Itkovian> boegel: did you continue work on HRay lately?
06:04:51 <bvd> anybody here?
06:05:10 <Lemmih> Yeah.
06:05:35 <bvd> I'm searching for a function in the standard liberaries that goes like this:
06:05:39 <bvd> fld f e []     = e
06:05:39 <bvd> fld f e (x:xs) = f $ fld f e xs
06:06:07 <bvd> You can use it in functions like length = fld (+1) 0
06:06:18 <bvd> Is there a standard function for this?
06:06:30 <ski> why is 'x' not used ?
06:06:59 <bvd> Well in functions like length you do not care about the elements in the list
06:07:28 <bvd> However I don't know if fld has more applications besides length
06:08:15 <bvd> So I gues there isn't a fld in the standard libraries... Hoogle also doens't it
06:08:57 <roconnor> @type iterate
06:08:58 <lambdabot> forall a. (a -> a) -> a -> [a]
06:09:05 <roconnor> @type replicate
06:09:06 <lambdabot> forall a. Int -> a -> [a]
06:09:14 <ski> @type let fld f e [] = e; fld f e (x:xs) = f $ fld f e xs in fld
06:09:14 <lambdabot> forall b
06:09:14 <lambdabot>                        a.
06:09:14 <lambdabot>                      (b -> b) -> b -> [a] -> b
06:09:16 <ski> @type let fld f e = foldr ($) e . map (const f) in fld
06:09:17 <lambdabot> forall b a.
06:09:17 <lambdabot>                   (b -> b) -> b -> [a] -> b
06:10:51 <ski> > let fld f e [] = e; fld f e (x:xs) = f $ fld f e xs; length = fld (+1) 0 in length [0,1,2,3]
06:10:52 <lambdabot> 4
06:11:03 <roconnor> fld f e l = church (length l) f e
06:11:06 <ski> @type let fld f e = foldr ($) e . map (const f); length = fld (+1) 0 in length [0,1,2,3]
06:11:07 <lambdabot> forall b.
06:11:07 <lambdabot>                              (Num b) =>
06:11:07 <lambdabot>                              b
06:11:19 <ski> @type let fld f e = foldr ($) e . map (const f); length = fld (+1) 0 in length [0,1,2,3] :: Int
06:11:19 <lambdabot> Int :: Int
06:11:22 <ski> er
06:11:26 <ski> > let fld f e = foldr ($) e . map (const f); length = fld (+1) 0 in length [0,1,2,3]
06:11:27 <lambdabot> 4
06:12:38 <boegel> Itkovian: no, not really... I'd like to though, why ?
06:16:28 <Itkovian> for stealing stuff
06:16:37 <Itkovian> erm, did I say stealing?
06:16:43 <Itkovian> I meant reusing
06:19:32 <boegel> :)
06:19:46 <boegel> you're free to, as long as you mention your progress to me ;)
06:21:17 <xerox> foldr . const
06:21:29 <Itkovian> @type const
06:21:30 <lambdabot> forall a b. a -> b -> a
06:24:12 <ski> indeed :)
06:24:17 <ski> @type foldr . const
06:24:18 <lambdabot> forall a b. (b -> b) -> b -> [a] -> b
06:25:06 <roconnor> > (foldr . const) (+1) 0 [0..3]
06:25:07 <lambdabot> 4
06:26:01 * roconnor doesn't understand (foldr . const)
06:26:26 <Itkovian> it will ditch all the arguments from the list foldr is appplied to, no?
06:26:41 <roconnor> @type foldr
06:26:42 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
06:26:47 <Itkovian> so the function essentially rolls on its own, disregarding the list items
06:26:56 <roconnor> now I see
06:27:01 <Itkovian> I think
06:27:08 <roconnor> it just affect the first parameter
06:27:19 <roconnor> turning it from binary to unary
06:27:28 <Itkovian> sorta, yeah. I guess
06:27:38 * Itkovian is a newbie. sorta
06:28:25 <roconnor> so the reason that fld isn't in the standard prelude is that you can just use (foldr . const)
06:28:29 <roconnor> ;)
06:29:16 <roconnor> > foldr (const (+1)) 0 [0..3]
06:29:17 <lambdabot> 4
06:29:25 <tibbe> @type seq
06:29:26 <bvd> roconnor Cool!
06:29:26 <lambdabot> forall b a. a -> b -> b
06:29:30 <ValarQ> thats pretty neat
06:29:49 <roconnor> bvd:  It's ski's idea
06:30:03 <bvd> ski: Cool :-)
06:30:22 <roconnor> bvd:  I mean it is xerox's idea
06:31:19 <int-e> > let null = foldr (const (const False)) True in map null [[],[1],[1,2]]
06:31:20 <lambdabot> [True,False,False]
06:31:39 <xerox> :-)
06:32:05 * xerox hugs roconnor 
06:32:13 <Itkovian> erm
06:32:14 <roconnor> xerox: did you derive foldr . const, or are you just a genius?
06:32:45 <xerox> I just thought it up.
06:33:01 <roconnor> I guess that makes you a genius
06:33:04 <xerox> 'folding ignoring the first argument'
06:33:10 <xerox> A translator, I'd say :)
06:33:11 <roconnor> @karma+ xerox
06:33:11 <lambdabot> xerox's karma raised to 12.
06:33:16 <Itkovian> wow
06:33:16 <xerox> Thanks!
06:33:29 <xerox> Now I'm dons/2 + 1.
06:33:30 <vincenz> @type foldr . const
06:33:31 <lambdabot> forall a b. (b -> b) -> b -> [a] -> b
06:33:42 <roconnor> @karma dons
06:33:42 <lambdabot> dons has a karma of 22
06:33:59 <xerox> I exceeded half a dons!
06:34:20 <vincenz> @karma
06:34:21 <lambdabot> You have a karma of 2
06:34:38 <Itkovian> will the foldr of const(const False) stop after a single element?
06:34:46 <int-e> sure
06:34:49 <xerox> Yup.
06:34:53 <Itkovian> > let null = foldr (const (const False)) True in [1..]
06:34:54 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
06:34:54 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
06:34:54 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
06:34:54 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
06:34:54 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
06:34:54 <roconnor> go lazyness
06:34:56 <lambdabot> [24 @more lines]
06:34:56 <Itkovian> erm
06:35:03 <Itkovian> > let null = foldr (const (const False)) True in null [1..
06:35:03 <lambdabot>  parse error on input `}'
06:35:07 <Itkovian> grmbl
06:35:11 <Itkovian> > let null = foldr (const (const False)) True in null [1..]
06:35:12 <lambdabot> False
06:35:15 <Itkovian> cool
06:35:18 <xerox> :-)
06:36:02 <tibbe> @type liftIO
06:36:03 <lambdabot> Not in scope: `liftIO'
06:36:06 <Itkovian> actuallly const is the K-combinator, right?
06:36:10 <tibbe> @type liftIo
06:36:11 <lambdabot> Not in scope: `liftIo'
06:36:15 <tibbe> @index liftIO
06:36:15 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
06:36:15 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
06:36:15 <lambdabot> Control.Monad.List
06:36:16 <Itkovian> aka true
06:36:22 <int-e> foldr (const (const False)) True [1..] -> const (const False) 1 (foldr (const (const False)) [2..]) -> const False (foldr (const (const False)) [2..] -> False
06:36:32 <int-e> Itkovian: yep
06:36:34 <tibbe> @type Monad.State.liftIO
06:36:35 <lambdabot> Couldn't find qualified module.
06:36:35 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
06:36:35 <lambdabot> \\)?
06:36:42 <tibbe> @type Control.Monad.State.liftIO
06:36:43 <lambdabot> forall (m :: * -> *) a.
06:36:43 <lambdabot>           (Control.Monad.Trans.MonadIO m) =>
06:36:43 <lambdabot>           IO a -> m a
06:36:48 <xerox> @type (Control.Monad.Trans.liftIO)
06:36:51 <lambdabot> forall (m :: * -> *) a.
06:36:51 <lambdabot>            (Control.Monad.Trans.MonadIO m) =>
06:36:51 <lambdabot>            IO a -> m a
06:36:59 <vincenz> what's the use of foldr const??
06:37:20 <Itkovian> vincenz: see higher
06:37:29 <xerox> vincenz: thinking in terms of length (presence/absence of values) instead of values' values.
06:37:32 <int-e> Itkovian: and S is Control.Monad.app, in the reader monad.
06:37:38 <Itkovian> vincenz: it ignores the items on the list and lets you use a unary function
06:37:51 <int-e> @index app
06:37:52 <lambdabot> Control.Arrow
06:38:05 <int-e> @index ap
06:38:05 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
06:38:05 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
06:38:05 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
06:38:05 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
06:38:07 <xerox> app ((+2),1)
06:38:09 <xerox> >app ((+2),1)
06:38:11 <int-e> ah. typo.
06:38:12 <xerox> > app ((+2),1)
06:38:13 <lambdabot> 3
06:38:23 <xerox> > return (+2) `ap` return 1
06:38:24 <lambdabot>  add an instance declaration for (Show (m a))
06:38:34 <xerox> > return (+2) `ap` [1]
06:38:34 <int-e> > ap const const 42
06:38:35 <lambdabot> [3]
06:38:35 <lambdabot> 42
06:38:37 <Itkovian> anything for B and C ?
06:38:39 <vincenz> > (foldr . const) (+1) [4,7,9]
06:38:39 <lambdabot>  add an instance declaration for (Show ([a1] -> [a]))
06:39:00 <vincenz> @type foldr . const
06:39:01 <lambdabot> forall a b. (b -> b) -> b -> [a] -> b
06:39:03 <int-e> that's (S K K) = I
06:39:16 <Itkovian> :-)
06:39:18 <vincenz> > (foldr . const) (+1) 0 [4,7,9]
06:39:19 <lambdabot> 3
06:39:28 <xerox> @type (const Control.Monad.ap id)
06:39:28 <vincenz> > (foldr . const) (+1) 0 [4,7,9,1]
06:39:29 <lambdabot> forall (m :: * -> *) a b.
06:39:29 <lambdabot>            (Monad m) =>
06:39:29 <lambdabot>            m (a -> b) -> m a -> m b
06:39:29 <lambdabot> 4
06:39:56 <vincenz> > (foldr . const) (*2) 1 [4,7,9,1]
06:39:57 <lambdabot> 16
06:40:20 <Itkovian> a really neat way to take powers of 2 :-)
06:40:30 <Itkovian> obfuscation, here we come
06:41:05 <arguile> Heh, I can't wait to golf in Haskell
06:41:36 <mauke> > foldr (flip id) 1 (map (const (2 *)) [4,7,9,1])
06:41:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
06:41:36 <lambdabot>   Expected type: (a -> t) -> a -> a -> t
06:41:36 <lambdabot>   Inferred type: (a -> t) -> a -> t
06:42:10 <int-e> > product $ map (const 2) [4,7,9,1]
06:42:11 <lambdabot> 16
06:42:38 <vincenz> que es golf?
06:43:24 <xerox> > (product . map (const 2) . flip replicate undefined) 16
06:43:24 <lambdabot> 65536
06:43:27 <mauke> d'oh
06:43:33 <mauke> > foldr id 1 (map (const (2 *)) [4,7,9,1])
06:43:34 <lambdabot> 16
06:43:44 <xerox> > (product . flip replicate 2) 4
06:43:45 <lambdabot> 16
06:43:54 <vincenz> > (\l -> (foldr . const) (*2) (produce $ map (const 1) l) l)
06:43:55 <lambdabot>  Not in scope: `produce'
06:44:00 <vincenz> > (\l -> (foldr . const) (*2) (product $ map (const 1) l) l) [1,2,3]
06:44:01 <lambdabot> 8
06:44:15 <xerox> > let exp = (product .) . flip replicate in exp 2 5
06:44:16 <lambdabot> 32
06:44:40 <vincenz> > reverse ":)"
06:44:41 <lambdabot> "):"
06:44:57 <vincenz> > performUnsafeIO x
06:44:57 <lambdabot>  Not in scope: `x'
06:45:04 <vincenz> > performUnsafeIO (print "1")
06:45:05 <lambdabot>  Not in scope: `performUnsafeIO'
06:45:08 <vincenz> @hoogle unsafe
06:45:09 <lambdabot> Language.Haskell.TH.Lib.unsafe :: Safety
06:45:09 <lambdabot> Language.Haskell.TH.Syntax.Unsafe :: Safety
06:45:09 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
06:45:16 <vincenz> > unsafePerformIO (print "1")
06:45:17 <lambdabot>  Not in scope: `unsafePerformIO'
06:45:20 <vincenz> hmm
06:45:23 <int-e> vincenz: getting a program done in the minimum number of shots - err, characters.
06:45:26 <vincenz> > Debug.Trace.trace "lala" 1
06:45:27 <lambdabot>  Not in scope: `Debug.Trace.trace'
06:45:29 <int-e> vincenz: or tokens, or whatever
06:45:52 <mauke> strokes
06:45:56 <vincenz> @hoogle perform
06:45:56 <lambdabot> System.Mem.performGC :: IO ()
06:45:56 <lambdabot> Test.HUnit.Base.performTest :: ReportStart us -> ReportProblem us ->
06:45:56 <lambdabot> ReportProblem us -> us -> Test -> IO (Counts, us)
06:45:56 <lambdabot> Test.HUnit.Lang.performTestCase :: Assertion -> IO (Maybe (Bool, String))
06:46:02 <vincenz> @hoogle performunsafe
06:46:03 <lambdabot> No matches found
06:46:06 <vincenz> @hoogle unsafe
06:46:07 <lambdabot> Language.Haskell.TH.Lib.unsafe :: Safety
06:46:07 <lambdabot> Language.Haskell.TH.Syntax.Unsafe :: Safety
06:46:07 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
06:46:08 <vincenz> hmm
06:46:11 <vincenz> where is the IO one?
06:46:13 <xerox> vincenz: it is called unsafePerformIO, and you can't use it.
06:46:24 <vincenz> > unsafePerformIO (print "1") 
06:46:25 <lambdabot>  Not in scope: `unsafePerformIO'
06:46:32 <mauke> @index unsafePerformIO
06:46:32 <vincenz> > IO.unsafePerformIO (print "1") 
06:46:32 <lambdabot> System.IO.Unsafe, Foreign
06:46:33 <lambdabot>  Not in scope: `IO.unsafePerformIO'
06:46:41 <vincenz> > System.IO.Unsafe.unsafePerformIO (print "1") 
06:46:42 <lambdabot>  Not in scope: `System.IO.Unsafe.unsafePerformIO'
06:46:45 <vincenz> oh
06:46:46 <Phyx-> anyone know if there are haskell compilers for pocketpc?
06:46:47 <vincenz> how does that work
06:46:58 <xerox> vincenz: it was explicitly taken out.
06:47:03 <vincenz> xerox: ah :)
06:47:17 <Lemmih> No, it just wasn't imported.
06:47:17 <xerox> Don't want IO?  No module IO.
06:47:25 <vincenz> xerox: how?
06:47:30 <xerox> Lemmih: "... from the import list" ;-)
06:47:32 <vincenz> I know that typiicallly it uses typing
06:47:35 <vincenz> > "print 1"
06:47:36 <lambdabot> "print 1"
06:47:38 <vincenz> > print 1
06:47:39 <lambdabot> No IO allowed
06:47:42 <xerox> vincenz: @type has it.
06:48:05 <roconnor> we don't have type constraints on data type definitions yet do we?
06:48:05 <vincenz> xerox: no what I mean is ... how does it remove those modules when evalling code
06:48:17 <xerox> vincenz: Lemmih told you
06:48:24 <xerox> roconnor: invariants?
06:49:00 <roconnor> I want newType Vector3 = Vector3 (a,a,a) where a is RealFloating, or whatever it is called.
06:49:04 <vincenz> xerox: ermm when evalling code you can import anythign you want
06:49:20 <vincenz> just use the fullpath
06:49:22 <xerox> Lemmih: maybe you could add some words here <http://haskell.org/haskellwiki/GHC/As_a_library>
06:49:51 <tibbe> @type foldr
06:49:51 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
06:49:53 <tibbe> @type foldl
06:49:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:50:02 <tibbe> are there any other folds?
06:50:12 <roconnor> @type foldl'
06:50:13 <lambdabot> Not in scope: `foldl''
06:50:16 <mauke> @type foldr1
06:50:17 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:50:32 <xerox> vincenz: maybe you can investigate lambdabot's sources further.
06:50:34 <tibbe> keh, fold left and right?
06:50:36 <vincenz> > Data.Version.showVersion
06:50:37 <lambdabot>  Not in scope: `Data.Version.showVersion'
06:50:43 <roconnor> @hoogle foldl
06:50:43 <vincenz> xerox: oh...hmm I see
06:50:43 <lambdabot> Data.List.foldl :: (a -> b -> a) -> a -> [b] -> a
06:50:43 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
06:50:43 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
06:50:52 <roconnor> @type Data.List.foldl'
06:50:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:50:57 <xerox> tibbe: there are also accumulating versions.
06:51:06 <xerox> @type scanl (and l1, r, r1)
06:51:06 <lambdabot> Not in scope: `l1'
06:51:06 <lambdabot>  
06:51:06 <lambdabot> <interactive>:1:15: Not in scope: `r'
06:51:10 <xerox> Ops.
06:51:14 <xerox> @type scanl -- (and l1, r, r1)
06:51:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:51:24 <xerox> @type mapAccumL -- (and R)
06:51:25 <lambdabot> Not in scope: `mapAccumL'
06:51:31 <xerox> @type List.mapAccumL -- (and R)
06:51:32 <lambdabot> forall y acc x.
06:51:32 <lambdabot>       (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:51:39 <vincenz> what's the and stuff
06:51:51 <mauke> @type and
06:51:51 <lambdabot> [Bool] -> Bool
06:52:36 <vincenz> I meant in the comments
06:52:42 <vincenz> @type and -- (and a)
06:52:43 <lambdabot> [Bool] -> Bool
06:53:17 <xerox> vincenz: scanl, scanl1, scanr, scanr1
07:02:59 <roconnor> let a [*] b = a * b in 5 [*] 6
07:03:09 <roconnor> > let a [*] b = a * b in 5 [*] 6
07:03:09 <lambdabot>  parse error on input `*'
07:03:13 <roconnor> :(
07:03:34 <ski> can't use those chars in operator name, i think
07:03:52 <roconnor> what are good characters to build operators out of?
07:05:20 <vincenz> @type scanl
07:05:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:05:26 <roconnor> I should probaby just use <*> and fundeps
07:05:26 <ski> +-*/\.:?!@#$%&<>|^~
07:05:28 <ski> iirc
07:05:41 <ProfTeggy> I often use |-> and |=>
07:05:49 <ProfTeggy> And the |--> and |=====> variants
07:05:57 <ski> (yes, '=' too, of course)
07:07:05 <mauke> @type \ÿ -> ÿ
07:07:06 <lambdabot> forall t. t -> t
07:08:18 <mauke> why can't I use unicode operators?
07:10:20 <roconnor> let a /\ b = a * b in 3 /\ 4
07:10:25 <roconnor> > let a /\ b = a * b in 3 /\ 4
07:10:26 <lambdabot> 12
07:10:29 <roconnor> oooh
07:10:35 <roconnor> it really looks like a wedge
07:11:46 <roconnor> what comment do I add to enable fundeps?
07:12:03 <xerox> {-# OPTIONS_GHC -fglasgow-exts #-}
07:12:11 <mauke> > let (/!\) = const in 1 /!\ 2
07:12:12 <lambdabot> 1
07:12:22 <roconnor> er, isnt' that a little broad?
07:12:55 <int-e> > let (|>) = (*); (||>) = (+); (|>>) = (-) in (6|>9)||>(0|>>12)
07:12:56 <lambdabot> 42
07:14:06 <int-e> > let (><) = 0 in (><)
07:14:07 <lambdabot> 0
07:14:32 <xerox> roconnor: I can't find anything more detailed than that.
07:14:34 <ValarQ> :/
07:22:28 <MarcWeber> Do you know an introduction about typeable?
07:36:11 <tibbe> @type foldl
07:36:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:36:13 <tibbe> @type foldr
07:36:14 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
07:36:46 <tibbe> i get confused by these two guys
07:37:48 <mauke> foldr f x [a,b,c,d,...] = a `f` (b `f` (c `f` (... `f` x)))))
07:38:57 <tibbe> i want to evaluate the last element last
07:40:05 <tibbe> I want to evaluate the first element and use the result in the evaluation of the next
07:40:08 <xerox> foldl f k [a,b,c..] = (((k `f` a) `f` b) `f` c) `f` ..
07:40:36 <xerox> tibbe, see <http://cale.yi.org/autoshare/folds.png>.
07:42:57 <tibbe> what's the purpose of the scan functions?
07:43:48 <roconnor> scanl (*) 1 [1..
07:43:52 <roconnor> > scanl (*) 1 [1..
07:43:53 <lambdabot>  parse error on input `}'
07:43:56 <roconnor> > scanl (*) 1 [1..]
07:43:57 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800
07:43:57 <lambdabot> ,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,
07:43:57 <lambdabot> 121645100408832000,2432902008176640000,51090942171709440000,112400072777760
07:43:57 <lambdabot> 7680000,25852016738884976640000,620448401733239439360000,155112100433309859
07:43:57 <lambdabot> 84000000,403291461126605635584000000,10888869450418352160768000000,
07:43:59 <lambdabot> [23 @more lines]
07:44:09 <roconnor> > take 10 $ scanl (*) 1 [1..]
07:44:10 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880]
07:44:24 <roconnor> good for memoizing factorials
07:44:31 <tibbe> i see
07:44:56 <tibbe> so it creates sublist with f folded?
07:45:09 <roconnor> its like the trace of the fold 
07:45:18 <tibbe> ah
07:46:42 <int-e> > let fib = 0:scanl1 (+) 1 fib in take 10 fib
07:46:43 <lambdabot> Couldn't match `[a]' against `t -> t1'
07:47:00 <int-e> > let fib = 0:scanl (+) 1 fib in take 10 fib
07:47:01 <lambdabot> [0,1,1,2,3,5,8,13,21,34]
07:53:28 <roconnor> which way do my new operators associate?
07:54:00 <int-e> roconnor: you can define that with infixr and infixl declarations
07:54:56 <roconnor> can I make it nonassociative?
07:55:35 <int-e> roconnor: http://haskell.org/onlinereport/decls.html#fixity
07:57:13 <MarcWeber> Anyone using pescos commandline parser library?
07:59:52 <tibbe> finally got it right!  foldl ( \env (Def id vars e) -> (id, runEval (foldr Lam e vars) env) : env ) baseEnv funs
08:00:07 <tibbe> it's an interpreter for top-level functions ;)
08:10:39 <lispy> > take 10 $ scanl (++) "a" ["a".."z"]
08:10:40 <lambdabot>  add an instance declaration for (Enum [Char])
08:10:40 <lambdabot>   In an arithmetic sequence: ["a" .. "z"]
08:10:50 <lispy> > take 10 $ scanl (++) "a" ['a'..'z']
08:10:50 <lambdabot> Couldn't match `[Char]' against `Char'
08:11:10 <lispy> > take 10 $ scanl (++) "a" ["a","b","c","z"]
08:11:11 <lambdabot> ["a","aa","aab","aabc","aabcz"]
08:11:32 <lispy> > take 10 $ scanl (++) "a" ["b","c","d","e"]
08:11:33 <lambdabot> ["a","ab","abc","abcd","abcde"]
08:14:43 <tibbe> haskell is so darn powerful
08:16:32 <jethr0> @hoogle until
08:16:32 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
08:17:07 <jethr0> > until null (++) "" "abcde"
08:17:07 <lambdabot> Couldn't match `[a]' against `t -> t1'
08:17:48 <mauke> does anyone here understand japanese?
08:18:21 <jethr0> > until (>100) (*2) 1
08:18:22 <lambdabot> 128
08:19:23 <jethr0> > until ((>5) . length) (\x -> (++x)) "" "abcde"
08:19:24 <lambdabot> Couldn't match `[a]' against `t -> t1'
08:25:09 <tibbe> > ((+ 1) 2)
08:25:10 <lambdabot> 3
08:25:22 <ihope> mauke: did you get a Japanese haiku error message?
08:26:47 <gour> ghc is on the amd shootout list #1, but on pentium4 #2. true?
08:30:52 <ihope> @state !message
08:30:53 <lambdabot> * TuringTest vomits on ihope
08:31:10 <ihope> Whoa.
08:31:15 <Lemmih> eh?
08:31:30 <ihope> Nobody's using the @state thingy!
08:31:42 <Lemmih> @state !message
08:31:43 <lambdabot> !message
08:31:54 <ihope> @state !othermessage
08:31:54 <lambdabot> !message
08:31:56 <ulfdoz> @help state
08:31:56 <lambdabot>  @state - we all know it's evil
08:32:03 <Lemmih> @state
08:32:03 <lambdabot> !othermessage
08:32:10 <ihope> @state It's a laggy cat.
08:32:11 <ulfdoz> That could be a reason.
08:32:17 <roconnor> > -0.0*0.0
08:32:18 <lambdabot> -0.0
08:32:24 <roconnor> heh
08:32:27 <ihope> > -0.0 == 0.0
08:32:29 <lambdabot> True
08:32:35 <ihope> > -0.0
08:32:36 <lambdabot> -0.0
08:32:41 <ihope> > 0.0
08:32:42 <lambdabot> 0.0
08:32:47 <ihope> Boochery?
08:32:59 <ValarQ> > 1/0
08:33:00 <lambdabot> Infinity
08:33:07 <ValarQ> > 1/(-0)
08:33:08 <lambdabot> -Infinity
08:33:28 <jethr0> @state 1
08:33:29 <lambdabot> It's a laggy cat.
08:33:30 <jethr0> @state 2
08:33:30 <lambdabot> 1
08:33:31 <ValarQ> > (1/0) == (1/(-0))
08:33:32 <lambdabot> False
08:33:32 <jethr0> @state 3
08:33:32 <lambdabot> 2
08:33:36 <ValarQ> :)
08:33:46 <jethr0> *weird*
08:34:26 <roconnor> let f = (1/) in let (a,b) = (-0.0,0.0) in (a==b,(f a)==(f b))
08:34:29 <roconnor> > let f = (1/) in let (a,b) = (-0.0,0.0) in (a==b,(f a)==(f b))
08:34:30 <lambdabot> (True,False)
08:34:35 <roconnor> very bad!
08:34:45 <roconnor> IMHO
08:34:59 <jethr0> > (-1)/(-1) == 1/1
08:35:00 <lambdabot> True
08:35:12 <jethr0> > -((-1)/1) == 1/1
08:35:13 <lambdabot> True
08:35:16 <jethr0> roconnor: i agree
08:35:26 * roconnor will make a note of this
08:35:34 <ValarQ> i believe hugs works differently
08:35:51 <jethr0> roconnor: i guess haskell is extracting the minus sign to put it in front of the ratio. and then the maths breaks down at this "infinity" mumbo-jumbo
08:36:04 <ValarQ> (it doesn't try to handle -infinity)
08:36:06 <ihope> Oh, right.
08:36:08 <roconnor> I understand what it is doing.
08:36:18 <ihope> Infinity = -Infinity, though Haskell doesn't think so.
08:36:30 <ihope> At least, GHC doesn't.
08:36:32 <jethr0> i don't think so either
08:36:34 <roconnor> But still it is bad in general to have functions such that (f a) /= (f b) when a == b
08:36:41 <tibbe> > -1
08:36:42 <lambdabot> -1
08:36:49 <tibbe> > 2 + -1
08:36:50 <lambdabot>   precedence parsing error
08:36:50 <lambdabot>    cannot mix `(+)' [infixl 6] and prefix `-' [infixl 6] in the same
08:36:50 <lambdabot> infix expression
08:36:55 <ihope> jethr0: 1/0 = -1/0, yes?
08:36:58 <tibbe> > 2 + (-1)
08:36:59 <lambdabot> 1
08:37:19 <jethr0> ihope: i don't want to get into that argument again... but certainly "1/0 == 1/-0"
08:37:26 <ihope> Yep.
08:37:37 <roconnor> jethr0: again?
08:38:00 <jethr0> ya, we had a lengthy discussion about 1/0 and infinity, and so on, a few days ago
08:38:02 <ValarQ> roconnor: i bring it up every friday :)
08:38:23 <ihope> Did you already bring it up today?
08:39:11 <musasabi> jethr0: I think it would be better to just claim that "dividing by zero is undefined" ;)
08:39:33 <jethr0> ihope: it's like the x^x derivation issues with (x->0). there might be a definite solution, but you can go on arguing about it forever, because it's just complex enough for people to understand, but too complex for people to look it up in google :)
08:40:17 <ValarQ> > 0/0
08:40:18 <lambdabot> NaN
08:40:23 <ValarQ> > 0/-0
08:40:24 <lambdabot>  Not in scope: `/-'
08:40:29 <roconnor> I don't care about 0 or infinity or whatever, it just that a == b ought to (almost) always imply (f a)==(f b)
08:40:29 <ValarQ> > 0/(-0)
08:40:30 <jethr0> > 0^0
08:40:30 <lambdabot> NaN
08:40:31 <lambdabot> 1
08:40:33 <tibbe> > div 0 0
08:40:34 <lambdabot> Exception: divide by zero
08:40:39 <ihope> > 0.00000001**0.00000001
08:40:40 <lambdabot> 0.9999998157932095
08:40:58 <roconnor> does python do the same?
08:41:03 <ihope> > 0.00000001**(-0.00000001)
08:41:04 <lambdabot> 1.0000001842068245
08:41:35 <jethr0> ihope, with that argumentation you could "prove" a lot of wrong math arguments :)
08:42:09 <ihope> Like what?
08:42:22 <jethr0> like 1/0 goes towards infinity
08:42:39 <jethr0> > [1/0.1, 1/0.001, 1/0.00001, 1/0.000000001]
08:42:41 <lambdabot> [10.0,1000.0,99999.99999999999,9.999999999999999e8]
08:43:06 <jethr0> sorry, that 1/0 _is_ infinity
08:43:08 <jethr0> my bad
08:43:13 <ValarQ> but that would give a very large number
08:43:22 <ihope> And you're saying 1/0 isn't infinity?
08:43:32 <jethr0> ihope: is it?
08:43:36 <tibbe> it isn't
08:43:39 <musasabi> 1/0 is not infinity in maths.
08:43:40 <tibbe> it's undefined
08:43:43 <ihope> That's how I define infinity.
08:43:49 <ValarQ> no, i'm just saying ghc could be right about -Infinity
08:44:22 <tibbe> it's undefined since division is defined from a = bc
08:44:39 <jethr0> 1/epsilon goes towards infinity and -infinity at the same time. therefore it's a singularity
08:45:01 <tibbe> yes, it depends on from what side you approach 0
08:45:13 <sjanssen> > 1/0
08:45:14 <lambdabot> Infinity
08:45:22 <tibbe> proof by lambdabot ;)
08:45:29 <ihope> :-)
08:45:44 <ihope> > (-1)/0
08:45:45 <lambdabot> -Infinity
08:45:49 <ihope> > (-1)/(-0)
08:45:50 <lambdabot> Infinity
08:45:54 <ihope> > 1/(-0)
08:45:55 <jethr0> hehe
08:45:55 <lambdabot> -Infinity
08:46:14 <sjanssen> this behavior matches IEEE standards
08:46:41 <jethr0> sjanssen: huh? doesn't division by zero cause an exception or a signal or something?
08:46:42 <musasabi> floating point behaviour is very different from maths.
08:46:55 <tibbe> jethr0, on div but not on /
08:46:58 <jethr0> ah, i remember the "inf" and "nan" thingeys
08:48:06 <jethr0> 1/0 returning infinity is bad, IMO. because if "1/0" were legal, "1/0 - 1/0" should be zero. but calculating with infinities doesn't work that way. ergo, 1/0 != infinity, but rather an undefined value
08:49:14 <jethr0> the way things are, doing "algebraic" transformations and partial evaluation on "1/0" must be pretty hairy.
08:49:41 <ihope> Things work exactly as they are defined to work. The end?
08:51:13 <jethr0> if the definition is coherent then maybe. but it should also match our expectations, especially in domains so close to maths.
08:51:32 <ihope> I expect 1/0 to be infinity.
08:52:00 <jethr0> and "a == b /<=> (f a) == (f b)" might have catastrophic effects in some situations.
08:52:26 <jethr0> sry, should be "/=>"
08:54:17 <jethr0> for example, hashes rely on that property.
08:56:23 <jethr0> *arg*, writing _any_ kind of documentation for yampa might have been a good idea to encourage adoption *grmpf*
08:57:53 <tromp_> 1/0 could be -infinity as well
08:58:20 <tromp_> anyway it's clear that x-x==0 only holds for finite values
08:58:56 <ihope> > (1/0.000000001) - (1/0.000000001)
08:58:57 <lambdabot> 0.0
08:59:06 <ihope> > (1/0.000000001) - (1/10.000000001)
08:59:07 <lambdabot> 9.999999998999999e8
08:59:11 <ihope> > (1/0.000000001) - (1/-0.000000001)
08:59:12 <lambdabot>  Not in scope: `/-'
08:59:17 <ihope> > (1/0.000000001) - (1/(-0.000000001))
08:59:18 <lambdabot> 1.9999999999999998e9
08:59:24 <jethr0> tromp_: yes, but 1/0 is a singularity. and how do you produce non-finite values with rational operators?
09:00:21 <jethr0> > (1/0.000000001::Rational) - (1/(-0.000000001)::Rational)
09:00:22 <lambdabot> 2000000000%1
09:00:25 <tromp_> i dont understand the question:(
09:01:18 <jethr0> tromp_: i agree that x-x==0 holds only for finite values. but i wonder if it is even possible to get a non-finite, defined value with operators +,-,/,* on rational numbers...
09:01:31 <Cale> jethr0: no, you can't
09:01:45 <Cale> there are no infinite values in the rationals
09:01:51 <jethr0> therefore x-x==0 holds for all defined rational numbers "x"
09:02:13 <Cale> yes, by virtue of Q being a ring
09:02:34 <jethr0> cale, but doesn't them being a ring imply closedness? but isn't 1/0 outside of Q?
09:02:43 <palomer> is there a language which has case constructs in its types?
09:03:07 <Cale> 1/0 = 1 * 0^(-1). 0 isn't invertible in most rings.
09:03:25 <Cale> In fact, if 0 is invertible, let's call the inverse x
09:03:35 <Cale> then 0 * x = 1
09:03:47 <jethr0> k, so 1/0 is an invalid rational number even before evaluation :)
09:04:29 <sjanssen> jethr0: the thing to take away from this is: the math done on your computer isn't real math
09:04:32 <jethr0> so, is Q = N * (N/0)?
09:04:41 <jethr0> s/*/x/
09:04:45 <Cale> N/0 ?
09:04:55 <Cale> Q is the field of fractions of Z
09:04:57 <jethr0> N without the 0
09:05:19 <jethr0> is zero in Z?
09:05:33 <ihope> > 0^(-1)
09:05:34 <lambdabot> Exception: Prelude.^: negative exponent
09:05:40 <ihope> > 0**(-1)
09:05:40 <palomer> N/{0} = {0}, methinks
09:05:41 <lambdabot> Infinity
09:05:47 <ihope> > 0.000000001**(-1)
09:05:48 <lambdabot> 9.999999999999999e8
09:05:53 <ihope> > (-0.000000001)**(-1)
09:05:54 <lambdabot> -9.999999999999999e8
09:05:54 <Cale> It's (Z x Z\{0}) / ~ where (a,b) ~ (c,d) iff ad = bc
09:05:57 <sjanssen> > 0 ^^ (-1)
09:05:58 <lambdabot> Infinity
09:06:01 <int-e> > 1/0 - 1/0
09:06:02 <lambdabot> NaN
09:06:07 <Cale> you need that equivalence relation
09:06:08 <jethr0> Cale: k, that's what i thought
09:06:15 <davidhouse> hi all
09:06:20 <int-e> > 1/0 - 1/0 == 1/0 - 1/0
09:06:21 <lambdabot> False
09:06:45 <jethr0> int-e: that's even more evil than "a == b /=> (f a) == (f b)" :)
09:06:52 <int-e> > 1/0 - 1/0 /= 1/0 - 1/0
09:06:53 <lambdabot> True
09:07:10 <int-e> hmm, but that's not IEEE conforming.
09:07:10 <jethr0> yup, that's IEEE float/double alright, but it's still evil
09:07:12 <sjanssen> > 1/0 * 0 == 0
09:07:12 <Cale> anyway, it's possible to show that if 0 is invertible, and all the other rules of a ring hold, then the ring has only one element
09:07:13 <lambdabot> False
09:07:20 <roconnor> let ~x = -x in ~4
09:07:21 <Cale> and 0 = 1 :)
09:07:22 <davidhouse> i've got a [Int] and a constructor. i want to feed each item in the list as a constructure. is there an easy way, other than pattern matching, to do this?
09:07:28 <davidhouse> *constructor
09:07:30 <ihope> > 1/0 * 0
09:07:32 <lambdabot> NaN
09:07:35 <roconnor> > let ~x = -x in ~4
09:07:35 <lambdabot>  Pattern syntax in expression context: ~4
09:07:40 <davidhouse> eurgh, that was horribly stated.
09:07:45 <palomer> Cale: did you show it?
09:07:48 <roconnor> no ~ operator for me
09:07:51 <davidhouse> i've got a [Int] and a constructor. i want to feed each item in the list as a parameter to the constructor. is there an easy way, other than pattern matching, to do this?
09:07:52 <Cale> palomer: I could
09:08:02 <jethr0> > map Just [1,2,3]
09:08:03 <lambdabot> [Just 1,Just 2,Just 3]
09:08:04 <sjanssen> > map (Just) [1..10]
09:08:05 <lambdabot> [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
09:08:07 <jethr0> hehe
09:08:12 <sjanssen> jethr0: I have more!
09:08:27 <jethr0> sjanssen: but you've got superfluous parens
09:08:34 <davidhouse> sjanssen, jethr0: not what i want
09:08:37 <ihope> > let ~x = -x in x
09:08:38 <lambdabot> <stdout>: hPutStr: illegal operation (handle is finalized)
09:08:47 <ihope> Oh my.
09:08:47 <davidhouse> the constructor takes five parameters. i have a list, length five.
09:08:48 <jethr0> davidhouse: it conforms to your request, methinks
09:08:48 <xerox> 1/0 isn't infinity
09:08:55 <davidhouse> jethr0, then i was unclear
09:08:55 <sjanssen> jethr0: yes, old habit, for some reason I always want to do that after map
09:08:56 <ihope> xerox: define infinity
09:08:56 <xerox> It isn't defined.
09:09:08 <tibbe> > Just Right
09:09:08 <xerox> As a number. that is.
09:09:08 <lambdabot>  add an instance declaration for (Show (b -> Either a b))
09:09:12 <ihope> Infinity isn't defined or 1/0 isn't defined?
09:09:27 <Cale> davidhouse: no way to do that apart from binding all the values of the list and applying the constructor to them
09:09:28 <xerox> 1/0 isn't defined.  Infinity isn't a number.
09:09:38 <jethr0> davidhouse: i fear you'll have to do "\[a,b,c,d,e] -> C a b c d e"
09:09:45 <Cale> even when infinity is a number 1/0 usually isn't defined :)
09:09:54 <int-e> > let nan = 1/0 - 1/0 in a < a || a == a || a > a
09:09:55 <lambdabot>  Not in scope: `a'
09:10:01 <int-e> > let a = 1/0 - 1/0 in a < a || a == a || a > a
09:10:02 <davidhouse> Cale, okay. maybe i'll just change my constructor to a type C = [Int] then...
09:10:02 <lambdabot> False
09:10:14 * xerox is largely ignorant too, believe Cale :)
09:10:34 <int-e> > let a = 1/0 - 1/0 in a `compare` a
09:10:34 <lambdabot> GT
09:10:38 <int-e> pfft :)
09:10:39 <ihope> xerox: define a number.
09:10:53 <xerox> ihope: I didn't go that far in the textbook yet.
09:10:59 <jethr0> @quote-add xerox xerox is largely ignorant too, believe Cale :)
09:11:15 <xerox> Foo!
09:11:23 <ihope> Put an asterisk before it...
09:11:27 <ihope> @quote xerox
09:11:28 <lambdabot>  > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l"
09:11:28 <lambdabot> ) lol
09:11:30 <Cale> xerox: There's a field which is otherwise isomorphic to the real numbers, but which has an unusual ordering on it such that there are numbers which are larger than every integer
09:11:31 <xerox> hah.
09:11:34 <int-e> @quote
09:11:35 <lambdabot> ##C++ says: [asking about C++ rules] vincenz: how should we know what
09:11:35 <lambdabot> those rules mean ?
09:12:07 <ihope> > take 10 lol where lol = "ol" : zipWith (:) (intersperse '0' $ cycle "l") lol
09:12:08 <lambdabot> ["ol","lol","0lol","l0lol","0l0lol","l0l0lol","0l0l0lol","l0l0l0lol","
09:12:08 <lambdabot> 0l0l0l0lol","l0l0l0l0lol"]
09:12:09 <xerox> Cale: why the "otherwise" ?
09:12:30 <Cale> xerox: it's ring isomorphic, but not ordered ring isomorphic
09:12:30 <ihope> Aah.
09:12:34 <ihope> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
09:12:35 <lambdabot> ["ol","lol","olol","lolol","ololol","lololol","olololol","lolololol","
09:12:35 <lambdabot> ololololol","lololololol"]
09:12:43 <ihope> @type intersperse
09:12:43 <xerox> ihope: lol.
09:12:44 <lambdabot> Not in scope: `intersperse'
09:12:50 <ihope> @index intersperse
09:12:51 <lambdabot> Data.List
09:12:58 <ihope> @type Data.List.intersperse
09:12:59 <lambdabot> forall a. a -> [a] -> [a]
09:13:07 <xerox> @you can use it privately too when conversation are going on ;)
09:13:07 <lambdabot> Everywhere I look I see NEGATIVITY and ASPHALT ...
09:13:21 <xerox> Cale: I see thanks.
09:13:30 <xerox> Cale: well, I "see".
09:13:33 <ihope> > intersperse ' ' "This makes things look \"important\"."
09:13:34 <lambdabot> "T h i s   m a k e s   t h i n g s   l o o k   \" i m p o r t a n t \" ."
09:13:50 <Cale> The ring is called the hyperreal numbers.
09:14:00 <xerox> I heard of them before!
09:14:17 <Cale> it's actually a field
09:14:23 <ihope> @help you
09:14:23 <lambdabot>  @help <command> - ask for help for <command>
09:14:30 <ihope> ...
09:14:32 <ihope> @you
09:14:33 <lambdabot> Uh-oh -- WHY am I suddenly thinking of a VENERABLE religious leader
09:14:33 <lambdabot> frolicking on a FORT LAUDERDALE weekend?
09:15:03 <Cale> heh
09:15:24 <xerox> Cale: how do addition and multiplication work on them?  Or maybe the real question is, what are them?
09:15:45 <xerox> ihope: "yow" is being corrected to "yow".
09:15:48 <Cale> there are a few constructions, but they're actually pretty tricky to construct
09:15:59 <ihope> Ah.
09:17:18 * xerox looks them up.
09:17:24 <Cale> The one that I learned involves taking sequences of real numbers and modding out by a strange equivalence which at least guarantees that you can cover up finitely many of them when comparing them.
09:17:34 <Cale> (but actually does a bit more than that)
09:17:54 <palomer> are we ever going to get mutually recursive modules?
09:18:42 <xerox> Put your hopes in Haskell' ?
09:18:45 <Cale> that is, you can compare the sequence (1,1/2,1/3,1/4,1/5,...) to (1/n,1/n,1/n,1/n...) by covering up the first n spots in each and doing the comparison on all the rest.
09:19:48 <Cale> but the actual formal construction is pretty bizarre, since it involves something called a nonprincipal ultrafilter on the natural numbers.
09:20:06 <xerox> "A hyperreal number x is said to be finite iff |x| < n for some integer n, x is said to be infinitesimal iff |x| < 1/n for all integers n."
09:20:17 <int-e> fun
09:20:49 <Cale> and it's impossible to get one of those without the axiom of choice iirc.
09:22:45 <Trevion> palomer, we have mutually recursive modules.  I think SimonM was quite upset the last time someone suggested that GHC was doing a poor job of them.
09:23:07 <ihope> haskell = fix improve
09:23:48 <Trevion> (Granted, I think they're doing a poor job of it, but that's just me.)
09:24:16 <palomer> Trevion: I've had ghc choke on mutually recursive modules before
09:24:42 <Trevion> palomer, with or without .hi-boot files?
09:24:51 <Trevion> (I mean .hs-boot)
09:25:54 <palomer> hs-boot?
09:26:03 <palomer> I don't know what that is
09:26:43 <Trevion> palomer, check out section 4.6.9 in the GHC user's guide.
09:26:52 <Trevion> It's an ugly hack, but it's the best we have.
09:26:57 <Trevion> (as far I as know)
09:29:01 <palomer> why is mutually recursive modules a problem in every programming language?
09:29:24 <Trevion> The claim has been made that Modula-3 got them right.  I've never used it, though.
09:30:05 <ptolomy_> Is there some trick to get my progrma that uses FPS to build with "-prof"?
09:30:19 <Igloo> You need to have FPS libraries built with -prof
09:30:43 <davidhouse> what's that function to find the first item in a list for which a given predicate is true?
09:30:53 <davidhouse> other than take 1 . filter :P
09:30:55 <palomer> @flip \x y z -> x z y
09:30:56 <lambdabot> Unknown command, try @listcommands.
09:31:00 <palomer> @pl \x y z -> x z y
09:31:01 <lambdabot> flip
09:31:09 <palomer> @pl \x y z a -> x y a z
09:31:10 <lambdabot> (flip .)
09:31:16 <palomer> oh, that's evil
09:31:16 <ihope> @type take 1 . filter
09:31:17 <lambdabot>   Couldn't match `[a]' against `t -> t1'
09:31:17 <lambdabot>   Expected type: [a]
09:31:47 <davidhouse> @type \f l -> take 1 $ filter f l
09:31:48 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:31:57 <davidhouse> @hoogle (a -> Bool) -> [a] -> [a]
09:31:58 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
09:31:58 <lambdabot> Data.List.dropWhile :: (a -> Bool) -> [a] -> [a]
09:31:58 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
09:32:11 <davidhouse> okay, i thought there was a nice function for that, never mind
09:32:36 <Igloo> Data.List.find
09:33:01 <xerox> @hoogle (a -> Bool) -> [a] -> Maybe a
09:33:02 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
09:33:02 <lambdabot> Data.List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:33:25 <davidhouse> ah, thanks Igloo.
09:34:11 <tibbe> @type \x -> x x
09:34:12 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:34:12 <lambdabot>   Expected type: t
09:34:42 <tibbe> > (\x -> x x) id
09:34:42 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:34:42 <lambdabot>   Expected type: t
09:34:42 <lambdabot>   Inferred type: t -> t1
09:35:00 <tibbe> > ((\x -> x x) id) 1
09:35:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:35:00 <lambdabot>   Expected type: t
09:35:00 <lambdabot>   Inferred type: t -> t1
09:35:19 <tibbe> can I make haskell type that?
09:35:54 <xerox> No.
09:36:08 <davidhouse> what about a function which returns the _index_ of the first item in a list which matches a given predicate?
09:36:15 <Trevion> davidhouse, findIndex
09:36:20 <xerox> @hoogle (a -> Bool) -> [a] -> Maybe a
09:36:21 <tibbe> but it's a sensible function, it should be typeable with higher rank polymorphism right?
09:36:21 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
09:36:21 <lambdabot> Data.List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:36:25 <xerox> Those, davidhouse.
09:36:32 <Trevion> xerox, isn't the type of that something like (forall x. x -> x) -> (forall x. x -> x)
09:36:49 <xerox> Trevion: I don't think so.
09:36:49 <davidhouse> Trevion, xerox, brilliant, thanks
09:37:33 <ProfTeggy> Nice weekend, all
09:38:49 <tibbe> it's omega, I think it has type: forall a. (forall b. b -> b) -> a -> a
09:39:05 * xerox prods Trevion.
09:39:12 <xerox> @type ((\x -> x x) :: (forall a. a -> a) -> (forall a. a -> a))
09:39:13 <lambdabot> forall a.
09:39:13 <lambdabot>                      (forall a1. a1 -> a1) -> a -> a
09:39:16 <Trevion> eh.
09:39:28 <xerox> AH!
09:39:31 <Trevion> I know it's discussed in the ML-F paper...
09:39:36 <xerox> I thought it was in the form (a -> a) -> a -> a.
09:39:38 <Trevion> I seem to have misremembered where, though.
09:39:51 <xerox> But it's really forall a. (forall a. a -> a) -> a -> a.
09:40:00 <Trevion> ah, right.
09:40:14 <xerox> Thank you.
09:41:09 <tibbe> but what forms of higher order polymorphism does haskell support?
09:42:42 <Trevion> So, wait, xerox: why doesn't GHCi like that expression?
09:42:45 <xerox> (I found a nice document, it's not Haskell related at all (well.. maybe not) <http://haskell.galois.com/~paolo/Okinawa.pdf>)
09:44:42 <davidhouse> @type maybe
09:44:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:47:49 <xerox> Trevion: I guess that is because there are no semantic restriction in lambda calculus (all expressions ggiven by the syntax are legal), but not all lambda expressions make sense as programs.
09:49:16 <tibbe> xerox, agreed but the above one does
09:49:40 <tibbe> that is, omega = \x -> x x does but for example omega omega doesn't
09:49:42 <Speck> can I do infix type constructors with GADTs?
09:53:24 <palomer> Speck: a priori I don't see any reason not to be able to
09:53:50 <xerox> Maybe it is related to H-M using unification?
09:53:59 <Speck> palomer: would I do it like this?  (:+) :: <type sig>
09:54:06 <palomer> Speck: sure
09:54:25 <Speck> I guess I should check :-| it just means I need to actually think harder about it
09:54:56 * palomer goes for his second type system rewrite in 2 days
09:55:00 <palomer> thank god for type inference
09:55:06 <palomer> it makes rewriting code _soooo_ much easier
09:55:16 <Speck> yeah... definitely a great refactoring tool
09:55:31 <tibbe> > 1 `id` 2
09:55:32 <lambdabot>  add an instance declaration for (Num (t -> a))
09:55:33 <palomer> Speck: there's no reason why it shouldn't work
09:55:38 <palomer> and checking takes 30 seconds
09:55:51 <Speck> yeah I just am not sure exactly how I want to structure my GADT
09:56:03 <tibbe> hmm, is there an op such that: a `op` b  is the same as just a b ?
09:56:05 <Speck> so now I need to figure that out
09:56:36 <palomer> op a b = a b
09:56:46 <Speck> :t ap
09:56:48 <xerox> tibbe: id used like that resembles ($).
09:56:54 <Speck> err, this isn't ghci
09:56:58 <palomer> Speck: when you figure it out, could you let me know? I need GADT functions to do some tests
09:57:00 <tibbe> is there a way I could get that out of the logs? ;)
09:57:06 <palomer> @type ap
09:57:07 <lambdabot> Not in scope: `ap'
09:57:18 <xerox> > (+1) `id` 1
09:57:19 <palomer> (op) = id
09:57:19 <lambdabot> 2
09:57:35 <Speck> palomer: sure
09:57:45 <xerox> tibbe: from the backstage: it is because of unification as I presumed.  You'd need recursive types.
09:58:11 <Speck> palomer: I'm playing around with a self-optimizing regexp using arrows and dep. types
09:58:25 <Speck> as a precurser to something more substantial
09:58:37 <tibbe> xerox, if I understand it correctly it's undecidable because the unification can't tell when to instantiate the type variable
09:58:52 <tibbe> xerox, you know of any papers on recursive types?
09:59:30 <palomer> Speck: that's nuts
09:59:55 <palomer> tibbe: what's undecidable?
10:00:05 <Speck> nuts? nuts bad?
10:00:11 <palomer> Speck: nuts cool
10:00:13 <tibbe> palomer, the type checking/inference on \x -> x x
10:00:19 <xerox> tibbe, the type is really:  forall a. Let f be f -> (a -> a) in f -> (a -> a).
10:00:22 <Speck> oh ok :-d
10:00:29 <xerox> (Again, credits go to the backstage.)
10:00:35 <palomer> you can do type inference with infinite types, I believe
10:01:36 <tibbe> palomer, but can you always infer types in cases that require higher order polymorphism?
10:01:47 <palomer> and, erm, \x -> x x is typeable in many calculi
10:02:00 <palomer> (even in ghc)
10:02:12 <xerox> palomer: but you can't get any useful definition of that type.
10:02:16 <tibbe> I've been told that Haskell and ML uses let polymorphism and thus only allows polymorphic variables at the top-level without explicit type declarations
10:02:31 <palomer> well, yes, that's true
10:02:31 <tibbe> @type \x -> x x
10:02:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
10:02:33 <lambdabot>   Expected type: t
10:02:47 <xerox> Idea..
10:02:57 <tibbe> @type \x -> x x :: forall a. (forall b. b -> b) -> a -> a
10:02:59 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> (b -> b) ->
10:02:59 <lambdabot> a -> a
10:02:59 <lambdabot>   Expected type: t
10:03:03 <palomer> @type (\x (forall x.x) -> x x)
10:03:04 <lambdabot> Parse error in pattern
10:03:10 <palomer> @type (\(x::forall x.x) -> x x)
10:03:11 <lambdabot> forall t. (forall x. x) -> t
10:04:08 <tibbe> yes, so my original question was if there are cases when it's not possible and in which cases higher order polymorphic types could be infered
10:04:33 <palomer> rank-2 inference is decidable
10:04:35 <palomer> but noone does it
10:04:49 <tibbe> since you are doing what the type system can't by giving it the point at which to instantiate the type
10:04:51 <xerox> > const () $ (\(x :: forall a. a) -> x x)
10:04:51 <lambdabot>   Illegal signature in pattern: forall a . a
10:04:51 <lambdabot>    Use -fglasgow-exts to permit it
10:04:53 <tibbe> variable *
10:05:06 <tibbe> palomer, okay, I thought it wasn't
10:05:25 <palomer> in fact, it is possible that rank-n for any n is possible
10:05:30 <palomer> (a priori)
10:05:42 * roconnor is enjoying fundeps
10:06:08 <xerox> > (\(x :: forall a. a) -> x x) (const 1)
10:06:08 <tibbe> so why doesn't language do rank-2 ?
10:06:08 <lambdabot>   Illegal signature in pattern: forall a . a
10:06:08 <lambdabot>    Use -fglasgow-exts to permit it
10:06:09 <palomer> but, given an n, finding an algorithm that will do rank-n inference is undecidable
10:06:20 <tibbe> :/
10:06:21 <palomer> tibbe: too hard. not very useful.
10:06:41 <palomer> roconnor: I heard you worked on Coq, were you one of the main authors?
10:06:43 <tibbe> palomer, do you know of any sensible functions that requires it?
10:07:01 <roconnor> palomer: I only work *with* Coq
10:07:05 <palomer> @hoogle runST
10:07:06 <lambdabot> Control.Monad.ST.Lazy.runST :: ST s a -> a
10:07:06 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
10:07:06 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i
10:07:06 <lambdabot> e
10:07:11 * roconnor not as fond of ML
10:07:25 <palomer> @hoogle ST
10:07:26 <lambdabot> Control.Monad.ST.Lazy.ST :: ST s a
10:07:26 <lambdabot> Control.Monad.ST.ST :: ST s a
10:07:26 <lambdabot> Graphics.UI.ObjectIO.CommonDef.St :: s -> (a, s)
10:07:33 <xerox> roconnor: I thought you were Coq author, doh.
10:07:34 <palomer> @type Control.Monad.ST.runST
10:07:35 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
10:07:41 <palomer> tibbe: there
10:07:45 <tibbe> :)
10:07:59 <roconnor> One day I will rewrite Coq in Haskell
10:08:01 <roconnor> ;)
10:08:06 <palomer> a lofty goal
10:08:23 <xerox> palomer is our type expert!
10:08:29 <tibbe> :)
10:08:37 <tibbe> then I can be your type newbie
10:08:58 <palomer> certainly not, both Philippa and ski know much more (of the stuff you guys are interested in)
10:10:06 <roconnor> what does ST mean?
10:10:22 <palomer> state thread
10:10:49 <palomer> some people think of it as a store, a heap, etc...
10:11:08 <Izu> heffalumps ?
10:11:09 <roconnor> what does runST do?
10:11:21 <palomer> it runs a computation inside a store
10:11:37 <Izu> are there any heffalumps in here ?
10:11:42 <Izu> i was told there were some 
10:11:48 <roconnor> s is the store?
10:11:53 <Lemmih> @seen Heffalump
10:11:54 <lambdabot> Unknown command, try @listcommands.
10:12:07 <roconnor> hmmm
10:12:09 <palomer> s is a trick to stop us from exporting references to the store
10:12:09 <Izu> hmm
10:12:14 <palomer> I'm talking in very vague terms
10:12:24 <roconnor> oh
10:12:31 <Izu> man those heffalumps are really tricky to spot...if u see any...call the batphone
10:12:39 <Izu> thnx
10:12:48 <roconnor> so s is kinda like the store.
10:13:12 <roconnor> when building ST s a
10:13:27 <Philippa> yup
10:13:34 <Philippa> each store 'comes' from a call to runST
10:13:45 <palomer> I've never thought of s representing a store
10:13:46 <roconnor> what is Control.Monad.ST.ST
10:13:57 <palomer> the datatype
10:14:16 <palomer> and Control.Monad.ST is the module
10:14:18 <roconnor> why does it have a type?
10:14:42 <roconnor> is Control.Monad.ST.ST a constructor?
10:14:50 <xerox> Because you have no side-effects in Haskell that aren't effects! (I.e. explicitly told in the type).
10:14:51 <palomer> no, it's the actual type
10:15:01 <roconnor> @type Control.Monad.ST.ST
10:15:02 <lambdabot> Not in scope: data constructor `Control.Monad.ST.ST'
10:15:19 <palomer> ST s Int is a stateful computation returning an Int
10:15:23 <roconnor> Okay, hoogle is just returing confusing results.
10:15:24 <palomer> @kind Control.Monad.ST.ST
10:15:25 <lambdabot> * -> * -> *
10:15:47 <roconnor> what are the primitives on ST?
10:15:48 <tibbe> @kind Maybe
10:15:49 <lambdabot> * -> *
10:16:06 <palomer> ST is a monad
10:16:11 <palomer> and you also have runST and evalST
10:16:18 <palomer> no, wait, only runST
10:16:20 <palomer> @hoogle evalST
10:16:21 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
10:16:21 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m
10:16:21 <lambdabot> a
10:16:32 <palomer> you'll have to hoogle for the rest
10:18:41 <roconnor> Only runST?
10:18:57 <roconnor> what about put and get?
10:19:45 <xerox> You use STrefs.
10:19:59 <xerox> @hoogle STRef
10:19:59 <lambdabot> Data.STRef.Lazy.STRef :: STRef s a
10:19:59 <lambdabot> Data.STRef.STRef :: STRef s a
10:19:59 <lambdabot> Data.STRef.Lazy.newSTRef :: a -> ST s (STRef s a)
10:20:19 <roconnor> @hoogle QuickCheck
10:20:20 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
10:23:36 <araujo> Morning.
10:28:38 <tibbe> > (1:2):1:[]
10:28:38 <lambdabot>  add an instance declaration for (Num [a])
10:28:44 <tibbe> > (1:2):1:[] :: [Int]
10:28:45 <lambdabot> Couldn't match `Int' against `[a]'
10:28:56 <tibbe> ?
10:29:01 <roconnor> crap: Falsifiable, after 0 tests:
10:29:30 <tibbe> cons is right associative right?
10:29:31 <mauke> tibbe: list elements must have the same type
10:29:40 <tibbe> @hoogle (:)
10:29:40 <lambdabot> No matches found
10:29:44 <tibbe> gah
10:29:45 <mauke> @type (:)
10:29:45 <lambdabot> forall a. a -> [a] -> [a]
10:29:52 <mauke> and 2 isn't a list
10:29:56 <palomer> > [1,2]:1:[]
10:29:56 <roconnor> a:b:c:[] == [a,b,c]
10:29:57 <lambdabot>  add an instance declaration for (Num [a])
10:30:14 <roconnor> a:b:c:[] == a:(b:(c:[]))==[a,b,c]
10:30:16 <tibbe> > 1:2:[]
10:30:17 <lambdabot> [1,2]
10:32:09 <palomer> @pl \x y -> do{_ <-x;y}
10:32:09 <lambdabot> (line 1, column 11):
10:32:09 <lambdabot> unexpected "{"
10:32:09 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
10:32:21 <palomer> @pl \x y -> (do{_ <-x;y})
10:32:22 <lambdabot> (line 1, column 12):
10:32:22 <lambdabot> unexpected "{"
10:32:22 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
10:32:23 <roconnor> yay: OK, passed 100 tests
10:32:56 <mauke> pl doesn't grok do syntax
10:33:02 <pierre-> how does lambdabot's @pl work,
10:33:05 <pierre-> *?
10:33:48 <jethr0> "do _ <- x; y" seems like a _really_ ugly version of "do x;y"
10:33:53 <tibbe> > (1:2):(3:[])
10:33:54 <lambdabot>  add an instance declaration for (Num [a])
10:33:57 <tibbe> > (1:2):(3:[]) :: [Int]
10:33:58 <lambdabot> Couldn't match `Int' against `[a]'
10:34:08 <palomer> jethr0: it does, but is it?
10:34:12 <mauke> tibbe: 1:2 is invalid
10:34:31 <jethr0> palomer: as far as i understand monads they should be identical
10:34:54 <tibbe> mauke, okay, I'm comparing the result to my implementation
10:34:58 <jethr0> because "do {a <- x;y}" is desugared to "x >>= \a -> y"
10:35:11 <tibbe> > (1:[]):(2:[]):[]
10:35:12 <lambdabot> [[1],[2]]
10:35:17 <tibbe> that's what I  want
10:35:25 <jethr0> and thus "do {_ <- x;y}" should become "x >>= \_ -> y", which is "x >> y", no?
10:36:05 <palomer> x >> y == x >>= const y == x >>= \_ -> y 
10:36:17 <jethr0> yup
10:38:10 <jethr0> bbl
10:38:15 <palomer> well, most of the time anyways
10:38:25 <jethr0> most of the time?
10:39:11 <jethr0> > do {_ <- Just 5; return 3}
10:39:12 <lambdabot> Just 3
10:39:23 <jethr0> > Just 5 >> return 3
10:39:24 <lambdabot> Just 3
10:39:30 <jethr0> well, as i said, bbl :)
10:39:31 <palomer> monads are free to define their own >> operator
10:41:42 <xerox> pierre-: it works by substitution rules.  The source is in lambdabot's repository.
10:43:18 <palomer> does the algorithm always terminate?
10:44:52 * palomer ponders annotating all his subterms
10:46:02 <xerox> Beats me.
10:48:11 <int-e> @pl (\x -> x x) (\x -> x x) 
10:48:22 <lambdabot> ap id id (ap id id)
10:48:22 <lambdabot> optimization suspended, use @pl-resume to continue.
10:49:39 <astrolabe> @type ap
10:49:40 <lambdabot> Not in scope: `ap'
10:49:49 <int-e> @type Control.Monad.ap
10:49:50 <lambdabot> forall b (m :: * -> *) a.
10:49:50 <lambdabot>        (Monad m) =>
10:49:50 <lambdabot>        m (a -> b) -> m a -> m b
10:50:03 <tibbe> what do you type in the source file to get glasgow-exts?
10:50:28 <astrolabe> for ghc?
10:50:33 <tibbe> yeah
10:51:00 <int-e> {-# OPTIONS -fglasgow-exts #-}  at the beginning of the file
10:51:04 <tibbe> thanks
10:52:06 <astrolabe> {-# OPTIONS_GHC -fglasgow-exts #-}  is the one I found.
10:53:11 <int-e> ah. "Previous versions of GHC accepted OPTIONS rather than OPTIONS_GHC, but that is now deprecated."
10:53:17 <tibbe> okay
10:53:27 <int-e> thanks
10:57:09 <tibbe> can I restrict a function so that has one of two types?
10:57:24 <astrolabe> If I've got f :: a -> b and x :: m a, what is the most concise way of getting the thing in m b?
10:57:36 <tibbe> I want to give (==) a type signature so it's either Int -> Int -> Bool or Bool -> Bool -> Bool
10:57:49 <xerox> liftm astrolabe.
10:58:01 <xerox> astrolabe: or fmap, they're equivalent.
10:58:37 <tibbe> can I make a union type some way?
10:58:43 <tibbe> how*
10:58:46 <astrolabe> thank xerox
10:58:52 <xerox> you're welcome.
10:59:43 <xerox> tibbe: There are many ways to do couple types, 'data U = T1 | T2', '(T1,T2)', 'Either T1 T2'.
10:59:49 <astrolabe> tibbe.  I guess you could define a class.
11:00:11 <tibbe> xerox, I want to limit a preexisting polymorphic function (==)
11:00:23 <tibbe> astrolabe, I use it in a type class, that's the problem
11:00:35 <xerox> What's the exact problem?
11:00:36 <astrolabe> why is that a problem?
11:00:54 <tibbe> sec, let me www the code snippet
11:01:51 <tibbe> http://www.itstud.chalmers.se/~larssont/Interpreter2.hs
11:01:51 <jethr0> i'd like to make a list of instances of a typeclass and know that it's not naively possible. but is there a way of doing it that won't screw your whole sourcecode?
11:02:41 <tibbe> xerox and astrolabe, I'm trying to create values of type Value, look at the four applications of binary I've commented out
11:03:05 <palomer> tibbe: so you want to say that (==) is of type Int -> Int or of type Bool -> Bool?
11:03:17 <palomer> "union type" has many meanings
11:03:19 <tibbe> I get
11:03:20 <tibbe> Interpreter.hs:52:17:
11:03:20 <tibbe>     No instance for (Binary a Bool)
11:03:20 <tibbe>       arising from use of `binary' at Interpreter.hs:52:17-22
11:03:20 <tibbe>     Probable fix: add an instance declaration for (Binary a Bool)
11:03:20 <tibbe>     In the list element: ("<", binary (<))
11:03:24 <tibbe>     In the definition of `baseEnv':
11:03:24 <tibbe>         baseEnv = [("+", binary ((+) :: Int -> Int -> Int)),
11:03:28 <tibbe>                    ("-", binary ((-) :: Int -> Int -> Int)),
11:03:30 <tibbe>                    ("*", binary ((*) :: Int -> Int -> Int)),
11:03:32 <tibbe>                    ("/", binary (div :: Int -> Int -> Int)), ("<", binary (<)), (":", cons)]
11:03:34 <tibbe> palomer, right
11:03:49 <tibbe> palomer, I don't know the "correct" meaning, it felt like a union thingy
11:04:24 <xerox> @type (<)
11:04:24 <lambdabot> forall a. (Ord a) => a -> a -> Bool
11:04:52 <davidhouse> a really dumbass question but it's something i haven't come across before: what's the easiest way to change a value in a list?
11:05:02 <davidhouse> i.e. copy a list except for one value, which is different
11:05:12 <xerox> davidhouse: filter.
11:05:14 <jethr0> davidhouse: map. but doing it by index is rather evil
11:05:33 <palomer> tibbe: I think you want existential types here
11:05:34 <jethr0> > map (\x -> if x == 3 then 4 else x) [1,2,3]
11:05:35 <lambdabot> [1,2,4]
11:05:43 <palomer> (which have much to do with union types)
11:05:43 <tibbe> palomer, okay, what's that?
11:05:56 <palomer> ignore the binary, for now
11:05:58 <tibbe> palomer, or better yet, does haskell have them?
11:06:04 <palomer> no, haskell doesn't have them
11:06:07 <tibbe> :/
11:06:14 <palomer> (the haskell type system is in some ways much overly restrictive)
11:06:21 <jethr0> > let set idx val = map (\(i,v) -> if i == idx then val else v) . zip [0..] in set 3 2 [1,2,3,4]
11:06:22 <lambdabot> [1,2,3,2]
11:06:36 <palomer> tibbe: what's the type of binary?
11:06:52 <palomer> actually, you could also get away with it with my new type system
11:06:57 <tibbe> palomer, binary :: (a -> a -> b) -> Value
11:07:26 <palomer> that's a really screwed up type
11:07:34 <palomer> you know you lose all type information when you do that
11:07:39 <tibbe> palomer, actually I could let binary be a -> b -> c but that's probably unneccery for what I'm doing
11:07:53 <tibbe> palomer, you seen the code?
11:08:11 <palomer> how do you use Value?
11:08:39 <tibbe> palomer, when I evaluate expressions they return Values, so it's either VInt, VBool or a closure
11:08:51 <palomer> so what's Value?
11:09:08 <tibbe> data Value = VFun (Value -> Eval Value)
11:09:08 <tibbe>            | VInt Int
11:09:08 <tibbe>            | VBool Bool
11:09:08 <tibbe>            | VCons Value Value
11:09:08 <tibbe>            | VNil
11:09:11 <Cale> xerox: http://mathforum.org/dr.math/faq/analysis_hyperreals.html -- this seems like a good intro
11:09:21 <tibbe> I want to use binary to contruct built-in functions
11:09:25 <Cale> (if you're still awake :)
11:09:41 <palomer> tibbe: paste the code for binary
11:10:02 <tibbe> class Binary a b where
11:10:02 <tibbe>     binary :: (a -> a -> b) -> Value
11:10:15 <tibbe> instance Binary Int Bool where
11:10:15 <tibbe>     binary = bin VBool (\(VInt n) -> n)
11:10:17 <xerox> Cale: yes I am :-)
11:10:20 <palomer> paste it in a paste bin
11:10:21 <tibbe> bin :: (a -> Value) -> (Value -> b) -> (b -> b -> a) -> Value
11:10:21 <tibbe> bin c unC op = VFun $ \n1 -> return $ VFun $
11:10:21 <tibbe>                \n2 -> return $ c $ (unC n1) `op` (unC n2)
11:10:25 <palomer> gah!
11:10:25 <tibbe> palomer, where?
11:10:26 <palomer> @paste
11:10:30 <tibbe> sorry for that
11:10:32 * palomer slaps lambdabot
11:10:33 <xerox> Cale: I just read the lines on Mathworld, thanks for the link.
11:10:47 <int-e> lisppaste2: url
11:10:48 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:10:48 <tibbe> palomer, the lisp paste bin i use is down today
11:10:59 <palomer> rafb.net/paste then
11:11:09 <tibbe> works now
11:11:34 <lisppaste2> tibbe pasted "binary" at http://paste.lisp.org/display/17161
11:11:48 <tibbe> there
11:12:13 <palomer> > 4
11:12:55 <jethr0> 4
11:13:08 <tibbe> palomer, so what I'm doing with binary is creating a function Value that return a function Value (think parital application of a binary op)
11:13:15 <davidhouse> hi all. i have a monadic computation, which i want to repeat until it starts returning (). how can i do this?
11:13:47 <jethr0> davidhouse: how can it start returning ()? doesn't it return the same type all the time?
11:14:09 <jethr0> @hoogle until
11:14:11 <davidhouse> true. okay, well until it starts returning [[]] or something
11:15:01 <jethr0> until null (>>= func) initialValue -- or sth like that
11:15:11 <palomer> tibbe: this looks like HOAS to me
11:15:18 <roconnor> let F f = {do x <- f; unless (null x) F x}
11:15:24 <roconnor> let F f = do {x <- f; unless (null x) F x}
11:15:31 <tibbe> palomer, sounds bad, what's that?
11:15:34 <davidhouse> > null [[]]
11:15:34 <roconnor> let F f = do {x <- f; unless (null x) (F x)}
11:15:41 <jethr0> > until (Just 0 ==) (fmap (-1)) (Just 5)
11:15:47 <palomer> tibbe: no no, quite good
11:15:50 <roconnor> let F f = do {x <- f; unless ([[]]==x) (F x)}
11:15:52 <palomer> tibbe: anyways, your cons won't work
11:15:53 <jethr0> > until (Just 0 ==) (fmap (subtract 1)) (Just 5)
11:15:54 <davidhouse> hey, lambdabot. what's up?
11:16:01 <palomer> I don't know why binary (<) isn't working
11:16:06 <tibbe> palomer, it does, I just threw it in there
11:16:19 <roconnor> let F f = do {x <- f; unless ([[]]==x) (F f)}
11:16:25 <roconnor> There we go
11:16:34 <davidhouse> thanks jethr0, roconnor.
11:16:36 <palomer> @type (:)
11:16:41 <tibbe> palomer, so if I try to do binary (<) then (<) has type a -> a -> Bool so there isn't an instance for it
11:17:03 <palomer> oh, right, (<) :: Int -> Int -> Bool
11:17:11 <jethr0> i guess lifting "until" would also work
11:17:11 <palomer> that should work
11:17:20 <palomer> tibbe: but, erm, what exactly is the problem?
11:17:23 <tibbe> with (+) I gave it an explicit type but (<) needs two, Int -> Int -> Bool and Bool -> Bool -> Bool
11:18:05 <palomer> tibbe: right, or exists a. a -> a -> Bool
11:18:11 <jethr0> help with typeclass lists, anyone?
11:18:13 <tibbe> or at least since only ints can be compare with < I only need one but for == I need two
11:18:20 <palomer> or, rather, forall a. a -> a -> Bool
11:18:22 <xerox> Wah
11:18:30 <xerox> Why existential types?
11:18:37 <palomer> nevermind the existentialism
11:18:37 <xerox> Yes indeed.
11:18:42 <xerox> :)
11:20:00 <tibbe> palomer, if there's a better solution to all this I don't mind rewriting it
11:20:44 <tibbe> palomer, the expression that'll be evaluated will be type safe since I've written a type checker for them
11:21:02 <tibbe> so I don't need to think about falling of any case statement
11:21:07 <palomer> binary:: (forall a b. a ->a->b) -> Value might work
11:21:24 <palomer> oh wait, no
11:21:26 <palomer> that won't work
11:22:07 <palomer> binary :: (exists a b. a -> a -> b) ->Value
11:22:29 <palomer> however, this isn't supported by ghc
11:22:38 <palomer> I'm pretty sure you can pull this off with GADTs though
11:22:53 <tibbe> :/
11:22:58 <tibbe> so, what's existential types
11:23:01 <tibbe> ?
11:23:08 <tibbe> how to solve it with GADTs?
11:25:29 <palomer> oh, I'm an idiot
11:25:39 <palomer> disregard everything I've been babbling about in the last half hour
11:25:46 <jethr0> :)
11:25:48 <Cale> hehe
11:25:55 <Cale> what's up?
11:26:04 <palomer> just wrap it in a list
11:26:19 <tibbe> wrap what?
11:26:25 <jethr0> Cale: can you give me a pointer concerning typeclass lists. is there a way of doing it that won't take up 100s of lines and look like a science project?
11:26:36 <Cale> typeclass lists?
11:26:48 <jethr0> lists of instances of typeclass.
11:27:04 <davidhouse> @index get
11:27:10 <xerox> jethr0: :info
11:27:11 <jethr0> like a heterogenous list of instances that all implement "show" or whatever
11:27:12 <tibbe> palomer, how?
11:27:17 <palomer> ("<",[binary (<)::Int ->Int ->Bool, binary (<)::Bool ->Bool->Bool])
11:27:25 <jethr0> xerox: huh?
11:27:40 <Cale> data Showable where Showable :: (Show a) => a -> Showable
11:27:51 <xerox> jethr0: fire up GHCI, :info Class.  ?
11:27:56 <palomer> have your env be of type [(String,[Value])]
11:27:58 <Cale> instance Show Showable where
11:28:06 <Cale>     show (Showable x) = show x
11:28:26 <tibbe> palomer, but then I don't know which Value to use when evaluating
11:28:27 <jethr0> no, i mean i want to make a list of ["hello", 2, True]
11:28:41 <jethr0> i know it won't work like this, but there is a workaround somewhere
11:28:43 <Cale> [Showable "hello", Showable 2, Showable True]
11:28:47 <jethr0> ah
11:28:49 <palomer> tibbe: you use the first one applicable
11:29:15 <jethr0> cool, i thought of sth like this, but good to know it works so nicely :)
11:29:16 <tibbe> palomer, but how do I know which one that is?
11:29:17 <palomer> Cale: that's a nice way to simulate existentials
11:29:19 <Cale> The Showable constructor throws away the type of the value passed to it, and asserts that it has the class Show
11:29:29 <Cale> palomer: it is existentials :)
11:29:49 <jethr0> what does the "->" mean in the data declaration?
11:30:01 <Cale> Just the usual meaning :)
11:30:09 <Cale> It's the function type constructor
11:30:16 <lisppaste2> tibbe annotated #17161 with "binary 2" at http://paste.lisp.org/display/17161#1
11:30:19 <Cale> Showable has type  (Show a) => a -> Showable
11:30:23 <jethr0> so, it's a type constructor taking an instance and returning another?
11:30:26 <palomer> tibbe: well, erm, this is your type system. if you're going to allow variables to have several types you have to figure out to evaluate them
11:30:28 <Cale> yeah
11:30:43 <jethr0> nice
11:30:46 <Cale> It'll take a value of any type which is an instance of Show and make a Showable from it
11:30:53 <Cale> but you can never extract that value again
11:31:00 <Cale> just apply the methods of Show
11:31:16 <palomer> tibbe: then again, I think (<)::Bool -> Bool -> Bool is pretty strange, considering it isn't a valid haskell type for (<)
11:31:17 <jethr0> k, good enough. extracting would cause all kinds of problems i guess
11:31:23 <Cale> that's GADT syntax, btw
11:31:34 <Cale> you can do it with slightly older syntax as well
11:31:36 <jethr0> @where gadt
11:31:38 <tibbe> palomer, well, it's really (==) that's gives me head aches
11:31:42 <xerox> Or you could make a precise list of what types you want in, and you can get their values out.
11:32:33 <Cale> data Showable = forall a. (Show a) => Showable a
11:32:35 <xerox> @where+ gadt http://haskell.org/ghc/docs/latest/html/users_guide/gadt.html
11:32:43 <jethr0> lambdabot is down
11:32:45 <xerox> If only lambdabot wasn't died.
11:32:49 <tibbe> palomer, I haven't introduced polymorphism into the typesystem yet so I guess I have to backtrack and think again
11:33:53 <tibbe> palomer, btw, what was wrong with my cons?
11:34:29 <Cale> either way, you'll be forced to use the -fglasgow-exts switch :)
11:34:51 <jethr0> k
11:34:56 <jethr0> but good to know it's possible
11:35:42 <ihope> Either a b -> (a,b) -> Void
11:36:11 * xerox sedates ihope 
11:36:16 <Cale> *Main> [Showable "hello", Showable 2, Showable [1,2,3]]
11:36:16 <Cale> ["hello",2,[1,2,3]]
11:36:19 <jethr0> ihope: if that was a djinn request, lambdabot is down :)
11:36:21 <Cale> hehe
11:36:28 <ihope> It wasn't...
11:36:36 <jethr0> looked like one
11:36:47 <ihope> @comeback
11:36:57 <ihope> @please!
11:36:59 <jethr0> @whereArtThou
11:37:12 <palomer> tibbe: cons has type a -> [a] -> [a]
11:37:20 * jethr0 is voting for mbot to make its reappearance
11:37:20 <Cale> Doesn't have all the modules though :)
11:37:22 <palomer> which is not of type a -> a -> b
11:38:38 <kolibrie> I have a very short parsec parser I wrote as I try to learn parsec and haskell (http://sial.org/pbot/15999). I'd like to learn how separate scanning works, and rewrite my example that way.  Is someone willing and available to tutor me?
11:39:47 <Cale> kolibrie: well, I might have an example somewhere
11:40:11 <kolibrie> Cale: that would be great
11:40:21 <tibbe> palomer, right, how stupid of me
11:40:25 <Cale> basically, you can just write your scanner as a parsec parser which produces a list of tokens, together with source positions (which are easy to obtain)
11:40:40 <Cale> then you write a parser which parses that list of tokens :)
11:41:02 <tibbe> palomer, then I need my a -> b -> c type
11:41:05 <tibbe> for binary
11:41:49 <kolibrie> Cale: sounds so easy - a small working example will still help, since I haven't managed to do it on my own yet
11:42:07 <tibbe> palomer, but wait, I don't use binary to create cons so v1 will be of type a and v2 of type [a] if my typechecking is correct
11:42:10 <Cale> http://www.haskell.org/hawiki/ScanningInHaskell has a start -- I hadn't bothered to include the source positions though
11:42:26 * kolibrie goes to look
11:43:31 <tibbe> > (if True then \x y -> x else \x y -> y) 1 2
11:43:33 <mbot> 1
11:43:39 <tibbe> > (if False then \x y -> x else \x y -> y) 1 2
11:43:40 <mbot> 2
11:44:18 <xerox> tibbe: \x y -> x  =  const
11:44:35 <tibbe> xerox, yes, I was testing the precedence of if and lambda
11:44:49 * xerox shrugs
11:45:08 <Cale> lambda extends as far to the right as possible, but no farther :)
11:45:09 <tibbe> testing beats thinking ;)
11:45:22 <tibbe> Cale, it's the as possible I was testing...
11:45:41 <xerox> tibbe: so untrue!  It took years to me to understand it, tho :-)
11:46:03 <tibbe> I'm not a 100 % serious
11:46:12 <Cale> it won't eat the else because \x y -> x else \x y -> y isn't syntactically valid
11:46:16 * tibbe might be 100% lazy though
11:46:32 <tibbe> Cale, well I thought about it after I tested it
11:46:51 <tibbe> that that parse will fail and it will backtrack
11:47:03 <astrolabe> So does lambda bind tighter than anything?
11:47:32 <Cale> tibbe: yeah
11:47:55 <Cale> astrolabe: well, it's not exactly an operator, but in some sense, yes
11:48:21 <Cale> Everything which can be captured by the right side of a lambda will be
11:48:29 <astrolabe> Excellent.  I can remove some parentheses.
11:48:37 <xerox> No trespassing.
11:49:26 <Cale> this is what makes the old layout for using monads work
11:49:48 <xerox> You mean standard function application?
11:50:03 <Cale> getLine >>= \name ->
11:50:08 <xerox> Yes.
11:50:21 <Cale> putStrLn ("Hello " ++ name!)
11:50:30 <Cale> er
11:50:30 <Cale> hehe
11:50:37 <Cale> the ! escaped there :)
11:50:43 <xerox> name!
11:51:38 <xerox> putStrLn . ("Hello "++) . (++ "!") =<< getLine
11:51:40 <bejs> ooh, hello everyone
11:52:05 <astrolabe> hello
11:52:18 <Cale> hi
11:52:32 <kolibrie> Cale: ha ha! it worked!  Thank you
11:55:02 <bejs> Unfortunately my first time here must be a help request
11:55:22 <bejs> Is there any way to overload (not sure of the term, overload is nearest) == so it can return a Num?
11:55:34 <xerox> Yup.
11:55:40 <tromp> hide the original
11:55:43 <xerox> import Prelude hiding (==)
11:56:04 <xerox> Err, ... hiding ((==))
11:56:07 <Cale> but you'll lose the original use of (==)
11:56:14 <Cale> and all the instances along with it
11:56:18 <bejs> Would that mean I'd have to redefine (==)?
11:56:23 <xerox> Yep.
11:56:23 <bejs> oh, Cale is faster
11:56:24 <Cale> and you won't be able to derive Eq
11:56:31 <tromp> it wld be totally insane though
11:56:40 <Cale> you basically shouldn't do that
11:56:43 <bejs> heh
11:56:46 * xerox hides
11:56:53 <Cale> It would be better to define another operation
11:56:58 <Cale> ==* or something
11:56:59 <xerox> <==>
11:57:03 <Cale> or yeah
11:57:18 <bejs> I am trying to do probabilities
11:57:18 <xerox> /==\, |==
11:57:21 <astrolabe> You're the second person who's wanted to do that in an hour though!
11:57:29 <astrolabe> poor (==)
11:57:41 <Cale> who else wanted to do that?
11:57:46 <bejs> such as == would return 0.25 if there was a 1 in 4 chance of something was going to happen
11:57:53 <astrolabe> bejs:  There is a nice monadic approach.
11:58:18 <ihope> So what's this syntactic sugar for arrows all about?
11:58:48 <astrolabe> 10tibbe: 01I want to give (==) a type signature so it's either Int -> Int -> Bool or Bool -> Bool -> Bool
11:59:05 * xerox stares blankly at astrolabe 
11:59:06 <bejs> And the syntax in math is P(X == 3) which gives a value from 0 to 1
11:59:19 <liyang> ooh, magic marker
11:59:33 <xerox> @type ((>>>) :: (Control.Arrow.Arrow (~>)) => (a ~> b) -> (b ~> c) -> (a ~> c))
11:59:34 <mbot> Not in scope: `>>>'
11:59:43 <xerox> @type (Control.Arrow.(>>>) :: (Control.Arrow.Arrow (~>)) => (a ~> b) -> (b ~> c) -> (a ~> c))
11:59:44 <mbot> Couldn't find qualified module.
11:59:44 <mbot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
11:59:44 <tibbe> astrolabe, I actually wanted to limit the existing == though
11:59:52 <xerox> @type ((Control.Arrow.>>>) :: (Control.Arrow.Arrow (~>)) => (a ~> b) -> (b ~> c) -> (a ~> c))
11:59:53 <mbot> forall (~> :: *
11:59:53 <mbot>                                    -> *
11:59:53 <mbot>                                     -> *)
11:59:53 <mbot> [7 @more lines]
11:59:55 <astrolabe> maths doesn't have a '==' relation as far as I know.
11:59:59 <xerox> Sorry for the flood.
12:00:03 <astrolabe> tibbe: true.
12:00:45 <bejs> It has a = relation, which sometimes means ==
12:00:53 <astrolabe> bejs: right
12:01:14 <astrolabe> I think it would better to change the notation a bit than to break the prelude.
12:01:38 <Cale> === isn't taken :)
12:02:01 <bejs> astrolabe: I've been messing round a bit and am thinking that's best
12:02:35 <astrolabe> xerox: staring about the monad comment?
12:03:21 * astrolabe can feel xerox's eyes boring into him.
12:04:13 <liyang> dcoutts: gtk2hs 0.9.10 doesn't make use of --with-ghc-docdir yet, right?
12:04:31 <astrolabe> ihope: Maybe thats covered here http://www.haskell.org/tmrwiki/ArrowsIntroduction
12:04:52 * jethr0 wants a --warn-tabs option in ghc...
12:06:58 <tibbe> @where list of precedence of haskell operators
12:06:58 <mbot> I know nothing about list.
12:07:36 <astrolabe> @where report
12:07:37 <mbot> I know nothing about report.
12:07:57 <tibbe> @where shorter version then the report
12:07:57 <mbot> I know nothing about shorter.
12:08:11 <tibbe> s/then/than
12:08:48 <roconnor> http://haskell.org/onlinereport/decls.html#fixity
12:11:36 <jethr0> tibbe, the report isn't _that_ long...
12:14:10 <ihope> So is mbot just lambdabot under a different nick and/or something?
12:15:43 <jethr0> it's lambdabots hot cousin
12:16:04 <jethr0> @vixen how is your cousin doing?
12:16:05 <mbot> Unknown command, try @listcommands.
12:16:08 <jethr0> :(
12:16:44 <Beelsebob> logicbot: however you want
12:17:13 <jethr0> logicbot: @vixen asl?
12:18:03 <Beelsebob> logicbot: 19/f/California
12:18:34 <jethr0> Beelsebob: you know you've spent too much time in #haskell when you know lambdabot's asl by heart :))
12:18:49 <Beelsebob> jethr0: I run logicbot in a different channel
12:19:07 <jethr0> ah, ok, so you're just relaying, huh
12:19:11 <Beelsebob> :P
12:19:51 <astrolabe> In ghc, if I import a module, but don't use it, will the module get compiled?
12:21:52 <jethr0> astrolabe: i don't really know. are you having issues with this?
12:22:21 <astrolabe> No.  I'll find out myself in a minute.  Thanks.
12:31:12 <roconnor> In haskell2 will (+) (-) (*) all be in their own multi-parameter type classes?
12:31:39 <astrolabe> single parameter I think.
12:32:09 <roconnor> I won't be able to define (*) :: Matrix -> Vector -> Vector
12:32:34 <astrolabe> They're all in Num
12:32:52 <roconnor> yeah, but in the future they will all be separate?
12:32:57 <roconnor> so we can overload the hell out of them?
12:33:41 <astrolabe> I guess the implied semantics is that Num is a ring.
12:34:05 <Saulzar> I hope so.
12:34:34 <astrolabe> It would be nice to have (+) and (-) in an abelian group class
12:35:56 <jethr0> but values in Double aren't commutative
12:36:29 <astrolabe> hmmm Num has abs but not Ord :(
12:36:36 <astrolabe> jethr0: true.
12:36:47 <astrolabe> or associative
12:36:50 <Cale> Allowing the use of * for scalar multiplication gets a little ugly
12:37:18 <Cale> and for matrix-vector multiplication etc
12:37:25 <astrolabe> It would be nice to have it for matrix multiplication maybe?
12:37:34 <jethr0> i don't find it unacceptable to create sth like "|*|" or similar for this
12:37:35 <Cale> but yeah
12:37:42 <Cale> it should be the general monoid operation :)
12:38:07 <jethr0> it would be nice to have group, ring, field operations with all kinds of proven attributes, which might even be used for algebraic optimizations...
12:38:11 <Cale> and use + for abelian groups
12:38:48 <Cale> one big problem is that one of the most common sorts of numbers to use (floating point) doesn't satisfy the axioms for anything
12:38:49 <jethr0> then you could implement functors between fields or whatever and retain some kinds of constraints
12:38:58 <jethr0> yep
12:38:58 <astrolabe> Cale: That appeals to me too.
12:39:00 <Cale> The operations are not even associative
12:39:35 <Cale> so for Float and Double, the usual algebraic optimisations don't apply and may be harmful
12:39:50 <jethr0> > 0.0000001 * (1000000 + 1) == 0.0000001 * 1000000 + 0.0000001 * 1
12:39:52 <mbot> True
12:40:14 <jethr0> i always underestimate that damn precision
12:40:28 <Cale> you'd have to do a much more complicated analysis to determine whether a particular rule was safe or not.
12:40:34 <jethr0> hmm, that might be a bad example anyways
12:40:39 <Cale> well, depending on what you want to preserve
12:41:08 <fluxx> jethr0, something like 57 might be a better number than 1..
12:41:09 * roconnor finishes his Haskell Clifford algebra implemenation
12:41:16 <jethr0> ya
12:41:19 <astrolabe> oooh
12:41:40 <astrolabe> What's in it?
12:41:49 <roconnor> inner product
12:41:51 <roconnor> outer product
12:41:55 <roconnor> geometric product
12:42:25 <TuringTest> Any physics examples in it yet?
12:42:40 <roconnor> No, just a library of operations at the moment
12:42:49 <roconnor> I'm planning to write a ray-tracer with it.
12:43:29 <roconnor> (/\) is the outer product
12:43:40 <roconnor> (.:) is the inner product, or contraction.
12:43:49 <roconnor> (<*>) is the geometric product
12:44:14 <roconnor> But it is hard coded for 3-D
12:45:04 <roconnor> @list-paste
12:45:04 <mbot> Unknown command, try @listcommands.
12:45:17 <roconnor> @where paste thingy
12:45:17 <mbot> http://paste.lisp.org/new/haskell
12:45:31 <bejs> sounds good
12:45:48 <Cale> might be fun to allow an arbitrary generating vector space and quadratic form :)
12:46:20 <lisppaste2> roconnor pasted "geometric product" at http://paste.lisp.org/display/17167
12:46:38 <roconnor> Cale: Template Haskell!
12:47:03 <roconnor> quickCheck (now) tells me that my product is associative.
12:47:12 <roconnor> whew.
12:49:07 <xerox> roconnor: where did you learn quickCheck usage?
12:50:19 <roconnor> @wiki quickcheck
12:50:21 <mbot> No Result Found.
12:50:39 <roconnor> @wiki QuickCheck
12:50:41 <mbot> No Result Found.
12:50:46 <roconnor> http://www.haskell.org/hawiki/QuickCheck
12:51:01 <roconnor> xerox: but that's a little unfair, because I wrote that wiki page.
12:51:31 <roconnor> I originally read stuff on the quickcheck website
12:51:54 <mwc> Should an implementation of Ix guarantee the same ordering relation for two elements as for their indexes?
12:54:03 <jethr0> i've never seen the use for coarbitrary. random functions seem so... random
12:54:17 <roconnor> jethr0: I've never used it
12:54:29 <roconnor> not that I have used quickCheck that much either
12:54:46 <xerox> Thank you roconnor.
12:56:12 <jethr0> yampa is driving me crazy. stupid lack of documentation!
12:56:40 * xerox yamps
12:56:56 <jethr0> xerox: you think you can help me?
12:57:13 <xerox> Not really.
12:57:18 <jethr0> hehe
12:57:25 <lisppaste2> kolibrie pasted "Cale: almost working hello world scanner" at http://paste.lisp.org/display/17168
12:57:37 <jethr0> i want to create the identity arrow "SF a b"...
12:57:57 <xerox> What does 'SF' stand for?
12:58:10 <jethr0> yampa signal function
12:58:15 <kolibrie> Cale: I'm having a problem with the 'comma' token
12:58:36 <jethr0> i think i just had an insight
12:58:39 * jethr0 b0ings
12:58:58 <ihope> Hmm, let's see here...
12:59:11 <ihope> Well, that's not going to work very easily.
12:59:34 <xerox> jethr0: call it '~>'  yay.
12:59:44 <jethr0> hmm
13:00:01 <int-e> ~> is ugly in many fonts.
13:00:37 <ihope> With the tilde at the top?
13:00:37 <xerox> :(
13:00:42 <int-e> yep
13:00:44 <xerox> At the middle of course.
13:00:48 <xerox> Well, ok.
13:01:15 <ihope> @state Is state really as evil as we think it is?
13:01:15 <mbot> Unknown command, try @listcommands.
13:01:24 <ihope> Aww.
13:02:00 <int-e> I think we keep underestimating state in that regard.
13:02:14 <ihope> Why is it evil?
13:02:46 <int-e> seriously, I don't know. but it's hard to deal with.
13:03:33 <astrolabe> it's a variable variable.  It is easier to mistake its value than for a constant.
13:03:44 <kolibrie> Cale: looks like my error was in the 'data' section
13:04:03 <ihope> So... are there any Haskell IRC libraries floating around?
13:04:15 <int-e> Does anyone have an idea how to best represent a document-view-controller model in Haskell?
13:05:05 * int-e is also open for good alternative approaches to that problem - but from a user perspective I want modifiable data with multiple views.
13:05:37 <xerox> ihope: yes, lambdabot's sources.
13:05:44 <xerox> They do have an IRC Monad.
13:06:00 <jethr0> i'm not convinced that a "normal" MVC would fit snugly into haskell. but as an idea maybe you can use channels for sending the messages to views?
13:06:01 <ihope> IRC monad?
13:06:59 * ihope downloads lambda once again
13:07:14 <xerox> lambdas are good.
13:08:21 <ihope> \x -> good
13:09:18 <xerox> That could be called... dictatorship.
13:10:21 <int-e> jethr0: I've pondered using MVars (asynchronous, may lose messages; good for 'changed' notifications), Channels (asynchronous notification) or a list of 'notifier' closures (synchronous notification) that can do whatever they like.
13:10:27 <ihope> > (\Nothing -> True) Nothing
13:10:29 <mbot> True
13:10:30 <int-e> jethr0: I don't really like either approach.
13:10:35 <ihope> > (\Nothing -> True) (Just 3)
13:10:37 <mbot>  Non-exhaustive patterns in lambda
13:10:51 <jethr0> i'm sure there lurks a monad somewhere that represents MVC pretty closely :)
13:10:59 <int-e> jethr0: but I guess that's because MVC doesn't fit snugly, as you suspected.
13:11:29 <int-e> jethr0: hmm. there's a good monad in the controller aspect of the MVC model.
13:11:36 <jethr0> not without slight modifications. but using composable memory transactions and some magic, this shouldn't be a problem (just talking here :)
13:11:59 <jethr0> do you need dynamically addable views?
13:12:28 <int-e> Hmm. I think I do.
13:13:56 <jethr0> hmm, "Model :: World -> Control -> World"
13:14:03 <TuringTest> @hoogle parserTest
13:14:05 <mbot> http://www.wiwiss.fu-berlin.de/suhl/bizer/d2rq/javadoc/de/fuberlin/wiwiss/d2rq/ParserTest.html
13:14:36 <ihope> Does FFI work with Java?
13:14:53 <jethr0> int-e: i'd have to think about that for a while. what are you trying to do?
13:15:12 <int-e> jethr0: I guess the stuff will have to live in the IO monad and then it's not difficult, just ugly.
13:15:34 <jethr0> int-e: i'm just starting to experiment with yampa. and it solves some of the MVC problems. but as i haven't understood it yet, i can't say how well it applies
13:16:02 <int-e> jethr0: (and I can implement controllers with their own monad, executed with something like: withModel modle $ do <modifying stuff>)
13:16:18 <jethr0> int-e: yampa represents events in lazy lists. sth similar would work for view notifications
13:17:05 <int-e> jethr0: Ah. I'll read some Yampa stuff then and see if it applies, or if I can steal some ideas.
13:17:12 <jethr0> after all things like wxFruit use arrows to do GUIs. so there must be papers/solutions out there for sth similar to MVC
13:17:30 <valez> hello, why the: (read "1+2") :: Int  does not give a result back? is there a way to evaluate expressions in strings?
13:17:36 <int-e> heh, where is our beloved lambdabot?
13:17:37 <xerox> jethr0: could you link us to yampa's relevant docs?
13:17:53 <xerox> valez: that's a tought topic.
13:17:55 <TuringTest> @where hs-plugins
13:17:56 <mbot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
13:18:03 <xerox> What TuringTest said.
13:18:08 <TuringTest> valez: hs-plugins
13:18:25 <jethr0> xerox: unfortunately there are no relevant docs. just papers. "yampa arcade", "arrows, robots and functional reactive programming" and "functional programming and 3d games"
13:19:59 <ihope> Say... what's Template Haskell?
13:20:20 <jethr0> Haskell 98 extension allowing type-safe compile time metaprogramming
13:20:42 <ihope> With Haskell both as the manipulating language and the language being manipulated, correct?
13:20:45 <valez> thanx ill have a look
13:20:49 <jethr0> so you can transform haskell programs as abstract syntax trees, and generate code
13:21:49 <jethr0> valez: depending on what you're trying neither hs-plugins nor template haskell might be the right thing. where do you want to evaluate code?
13:21:51 <int-e> @oldwiki TemplateHaskell
13:21:52 <mbot> Unknown command, try @listcommands.
13:21:58 <int-e> http://haskell.org/hawiki/TemplateHaskell
13:22:08 <jethr0> haskell.org/hawiki/TemplateHaskellTutorial
13:25:34 <valez> im writing a parser for haskell, i was wondering if there is a way to evaluate arithmetical expressions in strings or if i have to do something else
13:26:40 <jethr0> valez: when you're parsing anyways, the parser should cut up the string and do the evaluation, no?
13:26:46 <xerox> Did you see the Language.Haskell module, valez?
13:26:47 <xerox> @docs
13:26:48 <mbot> Supported dictionary-lookup commands:
13:26:48 <mbot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @
13:26:48 <mbot> Use "@dict-help [cmd...]" for more.
13:27:13 <jethr0> so "1+2" would become "(read "1"::Int) + (read "2"::Int)
13:27:18 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:27:47 <astrolabe> What has happened to lambdabot?  I miss her.
13:28:02 <ulfdoz> It is a female?
13:28:16 <astrolabe> definitely.
13:28:17 <int-e> @karma+ lambdabot
13:28:18 <mbot> lambdabot's karma raised to 5.
13:28:30 <ihope> @karma ihope
13:28:30 <mbot> You have a karma of 0
13:28:59 <Beelsebob> ulfdoz: it's 19, female and from california
13:29:07 <ihope> @krama
13:29:08 <mbot> You have a karma of 0
13:29:12 <ihope> @help karma
13:29:12 <mbot> return a person's karma value
13:29:19 <ihope> @help karma-
13:29:20 <mbot> decrement someone's karma
13:29:25 <ihope> @help karma+
13:29:26 <mbot> increment someone's karma
13:30:38 <ulfdoz> Beelsebob: Hm, too far away. I still try to get something local.
13:31:40 <Beelsebob> Beelsebob|Home: @vixen want to go move in with ulfdoz?
13:31:40 <Beelsebob> lambdabot: let me answer that later, okay?
13:32:30 <ihope> Um...
13:37:39 <lpb-oberon> hi
13:38:34 <valez> hmm if u have a function that gets a string and returns an int, if the string is "1+2" what steps shall i follow so that the function will return 3? is there a way to do it like that?
13:39:07 <lpb-oberon> how am i supposed to read this expression: (\x -> \y -> x+y) ((\x  -> x +1 ) 1) 1 ?
13:39:43 <lpb-oberon> or evaluate
13:40:04 <int-e> > (\x -> \y -> x+y) ((\x  -> x +1 ) 1) 1
13:40:05 <mbot> 3
13:40:19 <ptolomy_> dang. mbot beat me.
13:40:35 <jethr0> how do i convert a Double into a Float?
13:40:42 <ihope> lpb-oberon: (\x -> \y -> x+y) is (+)
13:40:53 <ihope> (\x -> x +1 ) is (+1)
13:41:06 <ihope> So that's (+) ((+1) 1) 1
13:41:14 <int-e> lpb-oberon: we need more context but my guess is that you should use beta-reduction
13:41:16 <ihope> Or 1+1+1
13:41:27 <ihope> Oh, wait a minute...
13:41:31 * ihope giggles
13:41:39 <astrolabe> ipb-oberon: how much do you understand?
13:42:18 <lpb-oberon> thx ihope :) i could write \x y -> x+y as well for (+) ?
13:42:32 <int-e> yes.
13:42:41 <int-e> you can also write \x -> (x+) for (+)
13:42:42 <lpb-oberon> astrolabe: i just started reading the tutorial today:)
13:42:47 <int-e> to make the confusion complete :)
13:44:04 <astrolabe> lpb-oberon: :)  and how much of the expression you typed do you understand?
13:44:13 <jethr0> > (fromRational (3::Double)) + (4::Float)
13:44:14 <mbot> Couldn't match `Rational' against `Double'
13:45:14 <jethr0> hmm, i have a double and need a float...
13:45:17 <lpb-oberon> astrolabe: i think/hope that i understand the entire by now:)
13:46:16 <jethr0> > toRational (1/3::Double)
13:46:18 <mbot> 6004799503160661%18014398509481984
13:46:27 <jethr0> *yuch*
13:47:38 <int-e> > flip elemIndex (iterate (2*) 1) 18014398509481984
13:47:39 <mbot> Just 54
13:47:40 <TuringTest> > toRational (1/3::Double)
13:47:42 <mbot> 6004799503160661%18014398509481984
13:47:53 <jethr0> anyone?
13:47:58 <TuringTest> > approxRational (toRational (1/3::Double)) (toRational 0.00001)
13:48:00 <mbot> 1%3
13:48:16 <int-e> > fromRational (1/3::Double) :: Float
13:48:18 <mbot> Couldn't match `Rational' against `Double'
13:48:25 <int-e> > fromFractional (1/3::Double) :: Float
13:48:26 <mbot>  Not in scope: `fromFractional'
13:48:43 <TuringTest> > toWhatIMean (1/3)
13:48:44 <mbot>  Not in scope: `toWhatIMean'
13:48:50 <jethr0> hehe
13:49:48 <int-e> > realToFrac (1/3::Double) :: Float
13:49:50 <mbot> 0.33333334
13:50:05 <jethr0> ah, cool
13:50:13 <jethr0> thx
13:50:25 <TuringTest> > 1%3
13:50:25 <vincenz> jethr0: hi
13:50:26 <mbot> 1%3
13:50:31 <jethr0> hey vincenz
13:50:42 <vincenz> :)
13:50:42 <int-e> (realToFrac = fromRational . toRational
13:50:48 <vincenz> > 1%3 * 6
13:50:49 <mbot> 2%1
13:51:05 <jethr0> vincenz: i'm trying to write pong/tetrix/a jump'n'run game with yampa. but until now i'm still stuck with getting _anything_ to run :)
13:51:15 <vincenz> what's yampa?
13:51:31 <TuringTest> @where yampa
13:51:31 <mbot> I know nothing about yampa.
13:51:37 <TuringTest> @google yampa
13:51:38 <mbot> http://haskell.org/yampa/
13:51:48 <jethr0> functional reactive programming with arrows
13:55:13 <lpb-oberon> valez: do you got a solution to your question?
14:02:38 <ihope> Question: Who is the President of the United States?
14:02:48 <ihope> Answer: the President of the United States is tried, the chief justice shall preside: and no person shall be convicted without the concurrence of two thirds of
14:04:02 <jethr0> @google who is president of the united states of america?
14:04:03 <mbot> http://www.whitehouse.gov/history/presidents/
14:04:39 <jethr0> @google 10 oz in kilotons
14:04:41 <mbot> http://www.treasurefish.com/gold-outlook.htm
14:04:49 <jethr0> @google 10 ounces in kilotons
14:04:51 <mbot> http://en.wikipedia.org/wiki/Kiloton
14:07:17 <TuringTest> @google 10 ounces in pounds
14:07:18 <mbot> 10 ounces = 0.625 pounds
14:07:28 <jethr0> @google 10 ounces in tons
14:07:29 <mbot> 10 ounces = 0.0003125 short tons
14:07:40 <ValarQ> short?
14:08:00 <jethr0> those americans. between british and american units you could create a whole universe of confusion
14:08:28 <jethr0> british/american fluid/solid ounces *brr*
14:08:34 <ValarQ> which of them am i using?
14:08:49 <jethr0> which of what?
14:09:00 <ValarQ> american or british?
14:09:11 <jethr0> how would i know
14:09:18 <lpb-oberon> <valez> hmm if u have a function that gets a string and returns an int, if the string is "1+2" what steps shall i follow so that the function will return 3? is there a way to do it like that?
14:09:37 <ValarQ> jethr0: you sound like an expert in the field :)
14:09:37 <lpb-oberon> how could i do something like that?
14:09:58 <mauke> > let func = const 3 in func "1+2"
14:10:00 <mbot> 3
14:10:14 <jethr0> ValarQ: i just researched it a little on wikipedia and was horrified by the non-metric systems. how could anyone possibly remember this stuff
14:10:21 <jethr0> @google 1 acre in square feet
14:10:22 <mbot> 1 acre = 43,560 square feet
14:10:31 <Cale> hehe
14:10:32 <jethr0> that's just ridiculous
14:10:33 <ValarQ> jethr0: yeah, thats quite scary
14:10:39 <integral> @google 1 are in square metres
14:10:40 <mbot> http://home.bitworks.co.nz/trivia/data.htm
14:10:45 <lpb-oberon> eval :: string -> int
14:10:46 <jethr0> @google 1 mile in feet
14:10:47 <mbot> 1 mile = 5,280 feet
14:10:49 <Cale> lpb-oberon: you probably want to write a parser with parsec
14:10:53 <ValarQ> @google 1 candlesquare in candlemeters
14:10:55 <mbot> No Result Found.
14:10:58 <ValarQ> :/
14:10:58 <jethr0> haha
14:11:11 <ValarQ> @google 1 candlefeet in candlemeters
14:11:13 <mbot> No Result Found.
14:11:14 <Cale> lpb-oberon: you'll want to parse your string into some structure which can be evaluated
14:11:16 <lpb-oberon> Cale: so i parse the sting in some tree structure?
14:11:20 <Cale> yeah
14:11:20 <ValarQ> @google 1 candlefeet in candlesquare
14:11:21 <mbot> No Result Found.
14:11:25 <ValarQ> dang
14:11:29 <int-e> jethr0: how many minutes are there in a day?
14:11:34 <jethr0> ValarQ: what kind of a unit is that supposed to be?
14:11:34 <Excedrin> what's a simple example to define Show for a new type?
14:11:47 <ValarQ> jethr0: lummination (i believe)
14:11:57 <ValarQ> jethr0: also one of those weird things
14:12:10 <Cale> Excedrin: apart from just putting 'deriving (Show)'?
14:12:16 <jethr0> int-e: i know. i would be much happier with a 10-based time unit.
14:12:18 <int-e> jethr0: I think that stuff is easy to memorize if actually use it.
14:12:25 <int-e> +you
14:12:47 <jethr0> int-e: you can't tell me that it's easy to judge the size of an area in acres
14:12:53 <mauke> I happen to have in my possession a simple expression evaluator written in functional style, despite the fact that ploki doesn't have functions: http://home.cs.tum.edu/~mai/ploki/ploki-0.6.4/examples/calc.pk
14:12:57 <Excedrin> Cale: nope, that's all I needed, thanks
14:13:42 <int-e> jethr0: sure, because I don't know, and never see areas measured in acres. I also took a lot of time to figure out how much a psi - pound per square inch - is, and forgot the result again
14:13:53 <jethr0> int-e: it's unnecessarily complicated and many "users" get confused very easily about how many "a" fit into one "b"
14:13:53 <ValarQ> @google 1 footcandle in metercandle
14:13:55 <mbot> http://www.2lightu.com/glossary.htm
14:13:56 <ihope> @google 1 eon in years
14:13:57 <mbot> http://www.eon.com/en/investoren/1023.jsp
14:14:07 <ihope> @google define:eon
14:14:08 <mbot> No Result Found.
14:14:29 <ValarQ> gave me a pretty good page thought
14:14:33 <int-e> jethr0: mind you, I'm happy with only having to deal with the (mostly) metric system.
14:14:39 <Maddas> mauke: heh, KTHX :-)
14:15:06 <jethr0> as am i. converting liters into cubic meters, etc is hard enough without totally random multiplication factors
14:15:12 <vincenz> yampa looks interesting
14:15:21 <vincenz> jethr0: it's easy
14:15:27 <vincenz> 1 m^3 = 1000 liters
14:15:30 <jethr0> vincenz: it also looks very hard to get started with
14:15:31 <vincenz> 1 dm^3 = 1 liter
14:15:31 <jethr0> thx
14:15:36 <astrolabe> The Scottish acre is 1.27 English acres. The Irish acre is 1.6 English acres.
14:15:37 <vincenz> (decimeter)
14:15:58 <vincenz> jethr0: need some help?
14:16:04 <jethr0> the worst is still ounces. and the reason for there being 5280 feet in a mile
14:16:11 <jethr0> vincenz: yes
14:16:19 <vincenz> cool
14:16:32 <vincenz> and why don't you just work in metric?
14:16:39 <jethr0> give me a second to darcs sth
14:16:41 <vincenz> hmm
14:16:47 <jethr0> vincenz: i do
14:16:51 <vincenz> did you do the excercises in the paper?
14:16:52 <jethr0> i'm just ranting
14:17:01 <jethr0> exercises? no
14:17:11 <vincenz> is there a darcs repo?
14:17:15 <vincenz> ... for yampa
14:17:18 <jethr0> for what?
14:17:27 <int-e> jethr0: luckily, programs like 'units' exist (or google if you prefer that)
14:18:34 <vincenz> how do I install yampa?
14:18:59 <jethr0> vincenz: good question. you download it. and then i got stuck. most users just put the AFRP directory inside their working dir :(
14:19:00 <lpb-oberon> Excedrin: data Graph a = Empty | Edge a a (Graph a) deriving Show - but i am not sure:)
14:19:17 <astrolabe> To estimate how many acres a piece of land covers, simply plough the land using two oxen.  The number of days it takes is the number of acres.
14:19:20 <vincenz> hmm
14:19:22 <TuringTest> @google G*(mass of earth)/(radius of earth)^2 in furlongs per fortnight^2
14:19:24 <mbot> (G * mass of Earth) / (radius of Earth^2) = 7.12759299 x 10^10 furlongs per (fortnight^2)
14:19:26 <vincenz> jethr0: you on #meta-science?
14:19:29 <jethr0> sure
14:19:32 <vincenz> I have a question
14:41:05 <ihope> @google G
14:41:06 <mbot> http://gmail.google.com/
14:41:12 * ihope giggles
14:41:22 <ihope> @google gravitational constant
14:41:24 <mbot> http://www.npl.washington.edu/eotwash/gconst.html
14:44:56 <ihope> @google mass of earth * G * 3 meters^-1 / c^2 * 1 year in fortnights
14:44:57 <mbot> ((mass of Earth * G * (3 (meters^-1))) / (c^2)) * (1 year) = 0.347163169 fortnights
14:45:01 <TuringTest> ihope: And then there is http://tinyurl.com/5eojo  (via http://www.metafilter.com/mefi/37363 )
14:47:06 <ihope> Whoo.
14:48:11 * ihope runs that through TTS
14:49:29 <TuringTest> It returns "= 38.445738 microseconds"
14:49:33 <TuringTest> (per day)
14:49:47 <ihope> The server at wwwtts.research.bell-labs.com is taking too long to respond.
14:50:22 <ihope> The server at www.research.att.com is taking too long to respond.
14:50:59 <TuringTest> GPS satellites run 38.44 microseconds slow out of everyday, on account of general relativity.  That is my favorite google-calculator link.
15:00:25 <ihope> > product [1..7010]
15:00:28 <mbot> 2517340195501359340399604151017754330582676099136961555955398807684815794329389302274322166580170352
15:00:28 <mbot> 2057614513503132438916479044393321328919876567817640267820161554845325347888788240280582602597504206
15:00:28 <mbot> 9849359377432014683348588455855463841429245284207001510121767725255855182506761542675504517172972089
15:00:28 <mbot> [3 @more lines]
15:01:15 <vincenz> > product [1..100000]
15:01:17 <roconnor> @seen roconnor
15:01:20 <mbot> Terminated
15:01:20 <mbot> You are in #haskell. Last spoke 2 seconds ago.
15:01:23 <vincenz> > product [1..10000]
15:01:26 <mbot> 2846259680917054518906413212119868890148051401702799230794179994274411340003764443772990786757784775
15:01:26 <mbot> 0973695786036701910715127305872810411586405612811653853259684258259955846881464304255898366493170592
15:01:26 <mbot> 1217040268086769210451555840567172555372015852132829034279989818449313610640381489304499621599999359
15:01:26 <mbot> [3 @more lines]
15:01:41 <ihope> Three?
15:01:44 <vincenz> @hoogle log
15:01:45 <mbot> http://www.statcounter.com/
15:02:00 <vincenz> I think mbot doesn't know it's math
15:02:02 <vincenz> > product [1..5000]
15:02:04 <mbot> 4228577926605543522201064200233584405390786674626646748849782402181358052708108200690899047871706387
15:02:04 <mbot> 2306174894755428309761781724040805324809927809328784055486199364548291211876258248802189173977900050
15:02:04 <mbot> 3308862599830285986485757874944596311528697088671004626842364817898990545469086139161321834417414880
15:02:04 <mbot> [3 @more lines]
15:03:20 <ihope> How fast does the function \x -> log (fac x) grow?
15:05:22 <TuringTest> fac ~ n^n so n log n ?
15:06:19 <TuringTest> http://mathworld.wolfram.com/StirlingsSeries.html has the answer
15:06:38 <TuringTest> leading term is (z - 1/2) * ln z
15:06:57 <ihope> I only speak English and a bit of Spanish, you know.
15:07:11 <vincenz> What does this mean
15:07:14 <vincenz> Could not find module `IORef': it is a member of package lang-1.0, which is hidden
15:08:15 <TuringTest> what implementation printed that?
15:08:19 <Saulzar> Depreciated in favor of the heirachial libs (use Data.IORef)
15:09:40 <vincenz> ah thx
15:10:05 <Lemmih> dons: I don't think Gardener represents a large enough amount of work to merit a WH paper.
15:11:17 <TuringTest> I have not seen dons recently
15:15:54 <ndm> Lemmih: as a case study in using the GHC API you might have a chance
15:16:34 <ihope> type Const a b = a
15:16:40 <ihope> Const () is a monad :-P
15:17:23 <ihope> (>>=) = const; return = const (); fail = const ()
15:18:07 <Cale> or just data Trivial a = Trivial
15:18:17 <Lemmih> ndm: Yeah, I was just thinking about that.
15:18:30 <Cale> satisfies all the laws real nicely
15:19:07 <ndm> i'm still trying to decide if i should try a hoogle paper...
15:36:40 <ndm> woohoo, i've now patched haddock to generate hoogle information directly :)
15:51:44 <palomer> > 4
15:51:46 <mbot> 4
15:52:00 <palomer> so are lambdabot's problems software or hardware in nature?
15:58:30 <astrolabe> @paste
15:58:30 <mbot> Not enough privileges
15:59:00 <Lemmih> heh
15:59:20 <astrolabe> I'm pretty unprivileged :(
15:59:58 <mauke> what does @paste do?
16:00:05 <Lemmih> @where paste
16:00:06 <mbot> http://paste.lisp.org/new/haskell
16:00:16 <astrolabe> It used to give the address of a paste page
16:00:31 <mauke> ah
16:01:30 <metaperl> @seen Pseudonym
16:01:31 <mbot> I haven't seen Pseudonym.
16:03:04 * palomer clamours for lambdabot
16:06:35 <lisppaste2> astrolabe pasted "Inferred type is less polymorphic than expected" at http://paste.lisp.org/display/17177
16:06:55 <palomer> well, I'll be spending the weekend learning to use quickcheck
16:06:57 <palomer> yay
16:07:11 <palomer> this means I'l have to generate random terms
16:07:12 <palomer> hmm
16:08:51 <jethr0> it would be cool if there were a better quickcheck mechanism for creating nested data types
16:09:07 <jethr0> generating lists with a certain distribution of length, or even trees can be pretty annoying
16:09:49 <jethr0> apart from that quickcheck absolutely RULEZ
16:10:21 <Lemmih> astrolabe: Write: forall node. Ix node =>
16:10:36 <astrolabe> Lemmih: thanks, I'll try it.
16:11:02 <astrolabe> is that an extension?
16:12:09 <Lemmih> Omitting the type signatur for 'empty' is probably easier.
16:12:33 <Lemmih> 'forall' is GHC specific. It needs -fglasgow-exts, iirc.
16:13:03 <astrolabe> I need the type signature to make it use a DiffArray
16:13:27 <Lemmih> Hm, right.
16:13:51 <astrolabe> Can you see a way to do it without extensions?
16:14:36 <astrolabe> It works at least!
16:14:57 <Lemmih> Yeah, but it's not very pretty. You can specialize 'array' to make a DiffArray.
16:15:04 <astrolabe> I'd karma you if lambdabot was around.
16:15:59 <astrolabe> Hmm could I define array'   ?
16:17:29 <Lemmih> Perhaps 'diffArray :: Ix i => (i, i) -> [(i, e)] -> DiffArray i e; diffArray = array'
16:21:28 <palomer> it takes 10 seconds for ghc to realize that it already compiled everything once
16:22:10 <astrolabe> Thanks Lemmih.  That works, and is moderately nice.
16:24:31 <palomer> 10 seconds!
16:24:36 <palomer> I don't get it
16:29:05 <palomer> whew, just finished a massive rewrite. Time to debug
16:36:30 <ihope> @djinn (a -> b -> c -> d -> e) -> (a -> b -> c -> d) -> (a -> b -> c) -> (a -> b) -> a -> e
16:36:31 <mbot> Unknown command, try @listcommands.
16:36:38 <ihope> Aww.
16:37:10 <palomer> those are neat chains
16:37:15 <palomer> what kind of terms do you get out of them?
16:37:19 <palomer> a 
16:38:29 <ihope> Lemme see...
16:38:42 <ihope> To get e we need a, b, c and d.
16:38:54 <ihope> Well...
16:38:55 <palomer> a -> a gives \x -> x, (a->b) -> a -> b is \x y -> x y, (a->b->c) -> (a->b) -> a -> b is \x y z ->x z (y z)
16:39:07 <palomer> that last term is S, I believe
16:39:46 <ihope> @type \a b c d e -> a e (d e) (c e (d e)) (b e (d e) (c e (d e)))
16:39:47 <mbot> forall t
16:39:47 <mbot>                         t1
16:39:47 <mbot>                         t2
16:39:47 <mbot> [8 @more lines]
16:39:50 <ihope> @more
16:39:50 <mbot>                         t3
16:39:50 <mbot>                         t4.
16:39:51 <mbot>                      (t2 -> t3 -> t4 -> t -> t1)
16:39:53 <mbot> [5 @more lines]
16:39:55 <ihope> @more
16:39:55 <mbot>                      -> (t2 -> t3 -> t4 -> t)
16:39:57 <mbot>                      -> (t2 -> t3 -> t4)
16:39:59 <mbot>                      -> (t2 -> t3)
16:40:01 <mbot>                      -> t2
16:40:03 <mbot>                      -> t1
16:42:16 <palomer> you could probably get a simple series out of the SKI calculus
16:42:28 <palomer> s/out of/in terms of
16:44:18 <int-e> @pl \x y z ->x z (y z)
16:44:19 <mbot> ap
16:44:33 <IHOPE> @pl \a b c d e -> a e (d e) (c e (d e)) (b e (d e) (c e (d e)))
16:44:35 <mbot> (. ((. ap) . ap . (ap .) . ap)) . ap . (liftM2 ap .) . (. ap) . ap . (ap .) . ap
16:45:32 <sili> :(
16:45:58 <ihope> Next would be...
16:46:11 * palomer considers writing a toSK function
16:46:12 <int-e> @type Control.Monad.liftM2 Control.Monad.ap
16:46:13 <mbot> forall (m :: * -> *)
16:46:13 <mbot>                 (m1 :: * -> *).
16:46:13 <mbot>               (Monad m1, Monad m) =>
16:46:13 <mbot>               m1 (m (a -> b)) -> m1 (m a) -> m1 (m b)
16:46:40 <ihope> @pl \a b c d e f -> a f (e f) (d f (e f)) (c f (e f) (d f (e f))) (b f (e f) (d f (e f)) (c f (e f) (d f (e f))))
16:46:56 <mbot> (. ((. ((. ap) . ap . (ap .) . ap)) . ap . (liftM2 ap .) . (. ap) . ap . (ap .) . ap)) . ap . (liftM
16:46:56 <mbot> optimization suspended, use @pl-resume to continue.
16:48:00 <palomer> http://en.wikipedia.org/wiki/Combinatorial_logic_%28mathematics%29 <--check out the proof on this page
16:48:05 <palomer> it seems they're showing the halting problem
16:48:07 <palomer> but it's a lie
16:48:19 <palomer> (seriously)
16:49:14 <ihope> Where?
16:49:20 <ihope> And what proof?
16:49:50 <palomer> that there is no combinator that distinguishes normal forms
16:49:56 <palomer> (which is a true statement)
16:50:54 <palomer> but it's not a very, erm, insightful statement (it is almost completely unrelated to the halting problem)
16:51:55 <yome> Hi.  Is there any distributed programming system based on Haskell?
16:56:09 <ihope> I really, really hate this every-type-variable-on-a-different-line thing.
16:57:00 <ihope> (a -> b -> c -> d -> e -> f) -> (a -> b -> c -> d -> e) -> (a -> b -> c -> d) -> (a -> b -> c) -> (a -> b) -> a -> f should NOT take up 36 lines.
16:58:53 <Philippa> palomer: not entirely. In many systems it's a prerequisite for the halting problem: can I tell if the system has in fact halted?
16:59:26 <palomer> what's a prerequisite?
16:59:45 <palomer> I agree that "x has a normal form" and "x halts" can be used interchangeably here
17:00:27 <ndm> yome, describe distributed programming ?
17:00:27 <Philippa> something you must have first in order to have the thing it's a prerequisite for
17:00:49 <palomer> no, I mean what is a prerequisite in your statement "it's a prerequisite..."
17:01:07 <Philippa> knowing if something's a normal form
17:02:11 <palomer> ok, if you prove to me that there is no program that can tell if a combinator has a normal form, then I'll agree that termination is undecidable
17:02:45 <palomer> however, that isn't what the author of that page does
17:02:54 <Philippa> nor what I wrote
17:03:24 <Philippa> which was that if you show you can't tell if a combinator's already in normal form or not, you've effectively shown you can't tell if it has one
17:03:31 <Philippa> (because you wouldn't know it even if you saw it)
17:04:15 <Philippa> (this doesn't mean they've not been sloppy, just that it's not as bad as it might seem)
17:04:29 <palomer> you can easily tell if a combinator is in normal form or not
17:04:31 <palomer> just try to reduce it
17:04:49 <Philippa> so what you wrote, unless I've misunderstood, was incorrect :-)
17:05:10 <palomer> oh, righto, I mean a combinator to decide its argument is normalizable
17:05:42 <palomer> there obviously isn't a combinator that can tell if its argument is in normal form
17:06:10 <palomer> brb
17:10:30 <astrolabe> @pl \(i,j)-> i /= j
17:10:34 <mbot> uncurry (/=)
17:11:09 <astrolabe> @pl \(i,j)-> i /= j && f (i,j)
17:11:09 <mbot> uncurry (ap (ap . ((&&) .) . (/=)) ((f .) . (,)))
17:14:49 <yome> "distributed programming" as in concurrent programming where processes might execute on physically remote computers linked by a network.
17:15:08 <yome> Oh, ndm left...
17:21:09 <ihope> > sum [1..26]
17:21:11 <mbot> 351
17:25:42 <ihope> Djinn asplodey soon...
17:25:49 <ihope> s/ soon//
17:49:47 <Cale> > 19 * 19
17:49:48 <mbot> 361
18:02:14 <ihope> > iterate (\x -> 3*x + 2) 1
18:02:17 <mbot> [1,5,17,53,161,485,1457,4373,13121,39365,118097,354293,1062881,3188645,9565937,28697813,86093441,258
18:02:17 <mbot> 100063090197999413,300189270593998241,900567811781994725,2701703435345984177,8105110306037952533,243
18:02:17 <mbot> 97,4307387926151115532621493,12922163778453346597864481,38766491335360039793593445,11629947400608011
18:02:17 <mbot> [3 @more lines]
18:02:43 <ihope> Weird
18:03:11 <Cale> what's weird?
18:03:37 <ihope> That sequence matches one here:
18:03:43 <ihope> http://paste.lisp.org/display/17180
18:03:59 <int-e> (the numbers are the number of times that program prints 'Hello, world!')
18:11:59 <palomer> hmmm
18:12:17 <palomer> is quickcheck still under active development?
18:35:26 <lennart_> palomer: yes
19:06:38 <ihope_> Has the "Hello, world!" problem been solved yet?
19:08:20 <astrolabe> @type some
19:08:21 <lambdabot> Not in scope: `some'
19:08:22 <mbot> Not in scope: `some'
19:08:37 <ihope_> Hmm.
19:08:38 <astrolabe> Yay.  Lambdabot is back.
19:08:44 <astrolabe> @hoogle some
19:08:45 <lambdabot> Data.Generics.Schemes.somewhere :: MonadPlus m => GenericM m -> GenericM
19:08:45 <lambdabot> m
19:08:45 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe
19:08:45 <lambdabot> u)
19:08:45 <lambdabot> System.Console.Readline.setIgnoreSomeCompletionsFunction :: Maybe ([
19:08:45 <mbot> http://www.some.org/
19:08:47 <lambdabot> String] -> IO [String]) -> IO ()
19:08:53 <ihope_> > 1+2
19:08:54 <lambdabot> 3
19:08:54 <mbot> 3
19:08:58 * ihope_ laughs
19:16:37 <dons> moin moin
19:24:44 <astrolabe> morning dons
19:28:57 <azuroth> given `instance Monad [] where,` [] is a constructor right, not a type?
19:30:12 <ihope_> Correc.t
19:31:06 <azuroth> and that works? what about `instance Monad 5 ...`?
19:31:19 <astrolabe> It looks odd to me
19:31:40 <astrolabe> It looks like pseudocode
19:33:31 <azuroth> hmm. I think it might just be a typo. would you just change [] to [a]?
19:33:32 <Cale> azuroth: [] is a type constructor. In the type language, "[] String" is the same as "[String]"
19:33:52 <azuroth> oh, okay
19:35:42 <azuroth> wait, I'm even more confused now. be simple, does "instance Monad []" work? :-)
20:01:46 <dons> roman leshchinskiy is a type-level hacking god: x = undefined :: Eval (App (Lam (App X X)) (Lam (App X X))) u => u
20:18:14 <dons> testabot: @seen dons
20:18:19 <testabot> You are in #haskell. Last spoke just now.
20:18:41 <Korollary> testabot: @seen testabot
20:18:41 <testabot> Yes, I'm here. I'm in #scannedinavian, #haskell.es, #haskell.it, #gentoo-
20:18:41 <testabot> haskell, #haskell-overflow, #flippi, #haskell-blah and #haskell
20:18:51 <Korollary> it's conscious!
20:19:00 <dons> testabot: @quit
20:31:57 <dons>     Couldn't match the rigid variable `u' against `Lam X'
20:31:59 <dons>       `u' is bound by the polymorphic type `forall u. (Eval (Lam X) u) => u'
20:32:08 <dons>     When using functional dependencies to combine
20:32:08 <dons>       Eval (Lam t) (Lam t), arising from the instance declaration at A.hs:16:0
20:32:08 <dons>       Eval (Lam X) u,
20:32:08 <dons>         arising from the polymorphic type `forall u. (Eval (Lam X) u) => u'
20:32:22 <dons> :}
20:32:46 <dons> and they say ghc has some bad error messages. what noonsense.
21:38:19 <Cale> dons: I'm not sure if that counts as a bad error -- it's pretty detailed about what's wrong
21:38:49 <dons> not bad, just "deep" :)
21:39:07 <dons> you have to know a few things to read the message.
21:39:30 <Cale> Yeah, the 'rigid variable' thing is new :)
21:39:47 <Cale> ever since they introduced GADTs, I think
21:40:59 <dons> Cale, would you like to respond to the message from `minh thu' on the mailing list about how to write stateful programs in Haskell? He's scared he has to thread all state around manually.
21:50:25 <Cale> I'll do it tomorrow :)
22:19:51 <araujo> Hiya!
22:20:11 <skew> hi
22:20:44 <skew> I'm coding up some stuff from Goodstein's theorem
