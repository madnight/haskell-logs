00:00:53 <beelsebob_> > let fac 0 = 1; fac n = n * fac (n-1); choose n m = ((fac n) `div` ((fac m)*(fac (n - m)))) in (choose 50 5) * (choose 10 2)
00:00:54 <lambdabot> 95344200
00:02:27 <beelsebob_> ohh, wow
00:02:35 <beelsebob_> I should buy all the tickts then!
00:13:14 <kosmikus> JohnMeacham: do you have a bibtex entry for jhc?
00:30:49 * vincenz just had an exame
00:31:06 <jethr0> how'd it go?
00:31:12 <vincenz> ah jethr0 there you are
00:31:23 * vincenz never had a more relaxed exam than this one
00:31:27 <vincenz> I walked in
00:31:47 <vincenz> sat down "haev you read the book" "yes"...some very generic design questions, done in 10 minutes, and then chatted a bit about other stuff in CS field
00:32:01 <jethr0> hehe
00:36:17 <jethr0> vincenz: you seen my visualization with path?
00:36:22 <vincenz> not yet no
00:36:28 <vincenz> jethr0: I cleaned your code, do a pull
00:36:31 <vincenz> no longer need to do
00:36:33 <vincenz> getDisplayText
00:36:34 <vincenz> displayText
00:36:40 <vincenz> just do displayText
00:36:47 <vincenz> no need for liftIO either
00:36:51 <jethr0> yup, i wanted to propose doing withouth them :)
00:36:52 <vincenz> (same for others)
00:36:56 <jethr0> very nice
00:39:40 <jethr0> haskell is _so_ cool
00:40:24 <shapr> yeah!
00:40:54 <vincenz> jethr0: I had a neat analogy this morning
00:41:04 <jethr0> ya?
00:41:26 <vincenz> 10:03 < vincenz> "haskell data structures are like flowers...they slowly grow out with the energy, for flowers it's the sun, for haskell it's computation"
00:41:40 <jethr0> nice
00:41:51 <jethr0> do you ever sleep?
00:41:57 <vincenz> I slept this night
00:42:27 <vincenz> jethr0: want to be a team for this year's?
00:42:47 <jethr0> depends what my job status is at the time. but generally i'd love to
00:43:15 <vincenz> when I was a consultant I'd take a day vacation break on monday (it typically rusn from friday night until monday night ...)
00:43:43 <jethr0> i guess smell is along directed routes only for cars, right?
00:43:52 <vincenz> yes
00:43:58 <jethr0> that would explain why my graph looks slightly off in places
00:44:12 <vincenz> join meta-science?
00:44:12 <jethr0> it's because the cars can't smell against the direction :)
00:44:25 <vincenz> jethr0: not unless there's wind
00:44:30 <jethr0> i _created_ meta-science
00:44:37 <vincenz> o.O
00:44:39 <vincenz> it's my channel
00:44:51 <jethr0> hehe
00:45:39 <vincenz> come on in
00:45:44 <vincenz> need to discuss something
00:46:10 <jethr0> you're not in there
00:46:24 <vincenz> DOH
00:46:24 <jethr0> i'm all alone
00:46:28 <vincenz> I was ni meta-scienece the whole time
00:50:55 <musasabi> @seen SyntaxNinja
00:50:56 <lambdabot> I saw SyntaxNinja leaving #haskell 13 hours and 1 minute ago.
01:11:33 <xerox> What's the meaning of the Monad law '(return x) >>= f == f x' ?
01:20:43 <Itkovian> xerox: isn't that when you have a thingie that produces x, and bind that into a function f, f gets applied to it?
01:21:01 <xerox> Itkovian: yep, I'm looking for the wordy explanation :-)
01:21:07 <Itkovian> hmm
01:21:09 <Saulzar> I guess it's equivalent to saying y <- (return x)   y == x
01:21:22 <Itkovian> that's even less wordy
01:21:27 <xerox> Saulzar: uh-oh.
01:22:07 <xerox> I wonder if that property has a name.
01:22:09 <Saulzar> Hmm, badness? :)
01:22:18 <xerox> I don't think so :)
01:22:19 <Igloo> The == isn't Haskell, if that's what's confusing you?
01:22:32 <xerox> Igloo: nope, I can understand what does it mean, intuitively.
01:22:36 <Igloo> It says (return x) >>= f and f x must be identical
01:22:40 <xerox> Igloo: I'm trying to make 'formal' sense of it.
01:24:23 <Saulzar> If you insert a value with return, that value better well be the value bound to f...
01:24:25 <xerox> For example, why should they?
01:24:36 <xerox> Ah-uhm
01:26:03 <lispy> actually, i'm looking at that and i'm puzzling over it a bit..."return x >>= f" has monadic type right? but "f x" doesn't have to, rigt?
01:26:27 <lispy> @type return 1 >>= (1+)
01:26:28 <lambdabot> forall (m :: * -> *) b. (Monad m, Num (m b)) => m b
01:26:37 <Saulzar> It has to, because of the type of >>=
01:26:38 <lispy> @type (1+) 1
01:26:39 <lambdabot> forall a. (Num a) => a
01:26:41 <Saulzar> @type (>>=)
01:26:42 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
01:27:00 <Saulzar> f :: a -> m b, so it has a monadic type
01:27:03 <lispy> so == is equivalence in some sense?
01:27:30 <gour> is it possible to have two values under one case, i.e.
01:27:36 <gour> case (exp) of
01:27:44 <gour> a,b -> x
01:27:47 <gour> c -> y
01:27:48 <gour> ?
01:28:21 <lispy> gour: c would be a tuple as well, right?
01:28:53 <gour> lispy: no, i just need the same value for two cases
01:28:55 <xerox> gour: by pattern matching, or guards?
01:29:28 <Saulzar> You mean c == (a, b) ?
01:29:32 <gour> i.e for both a & b, result should be c
01:29:47 <lispy> case (exp) of c@(a,b) -> x
01:30:37 <lispy> gour: i'm not sure you understand the case syntax if you think a,b results in c
01:31:02 <lispy> but, more importantly, i don't understand the question :)
01:31:04 <gour> e.g. if (exp == LT ) || (exp == EQ) then x else y
01:31:50 <gour> the same thing with the case?
01:32:39 <Saulzar> Ah, I don't think you can do that. There was some discussion extending case to do that...
01:32:42 <lispy> > let {foo exp = | exp == LT = 1; | exp == EQ = 2} in foo LT -- not sure if that's entered on one line correctly
01:32:42 <xerox> gour: guards.
01:32:43 <lambdabot>  parse error on input `|'
01:32:50 <gour> lispy: i don't think that a,b results in c
01:33:06 <lispy> gour: good :)
01:33:17 <xerox> gour: case <exp> of | <condition> || <condition> -> <exp2> ..
01:33:56 <Saulzar> Hmm
01:33:59 <gour> xerox: yep. i was thinking in terms of Saulzar
01:36:20 <gour> iirc, ruby has such a case
01:36:21 <Saulzar> If you get rid of some plumbing lispy's example seems to work, seems useful..
01:36:28 <Saulzar> > let foo exp | exp == LT = 1 | exp == EQ = 2 in foo LT
01:36:29 <lambdabot> 1
01:38:03 <gour> ruby has: 
01:38:06 <gour> case exp
01:38:17 <gour> when a,b 
01:38:18 <gour> x
01:38:22 <gour> when c
01:38:23 <gour> y
01:38:36 <gour> maybe something for Haskell'
01:38:55 <gour> thank you for your input
01:39:07 <lispy> i think you can do that in haskell
01:40:59 <lispy> > let foo exp = case exp of (a,b) -> 1; c -> 2 in foo (1,2)
01:41:00 <lambdabot>   Warning: Pattern match(es) are overlapped
01:41:00 <lambdabot>      In a case alternative: c -> ...
01:41:01 <vincenz> > let x = 1 in case x of [1..3] -> 0 | 4 -> 1 
01:41:02 <lambdabot>  Parse error in pattern
01:41:23 <lispy> in my example, lambdabot gives a warning but if you try it in ghci you'll see you can do it
01:42:24 <lispy> generally, when ghc says patterns are overlapped you're doing something that could lead to a bug
01:43:34 <vincenz> blegh
01:43:40 * vincenz has a dual boot system
01:43:52 <vincenz> why can't putty use the private ky that I have in my .ssh/ folder on linux
01:46:03 <gour> vincenz: for exp of type Int, it would work, however my exp is of type Ordering
01:46:35 <vincenz> @where lambdabot
01:46:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:46:51 * vincenz hates mozilla
01:47:42 <vincenz> what does "darcs get --partial" do
01:47:57 <lispy> vincenz: only grabs the portion of the history that in needed
01:48:34 <lispy> vincenz: the owner of the repository can use 'darcs optimize' and 'darcs checkpoint' in some order or manner to decrease the number of patches you'll need to download
01:48:52 <vincenz> ah
01:48:58 <vincenz> darcs rocks
01:49:11 <lispy> duh! :)
01:52:07 <dcoutts> vincenz, I take it you didn't get mozilla to build
01:53:01 <vincenz> dcoutts: no that's not the issue
01:53:11 <vincenz> but on my work computer (redhat) mozilla is installed, not firefox
01:53:16 <vincenz> and usability wise, mozilla SUCKS
01:53:20 <dcoutts> heh
01:53:32 <vincenz> i maen if I click on a link in this window
01:53:33 <vincenz> and do ope
01:53:52 <vincenz> and mozilla is already open it asks you all this bs about another .... instance or something
01:54:29 <xerox> That behaviour is configurable.
01:54:40 <xerox> Try writing in the url bar: about:config.
01:54:51 <xerox> Then search for 'open', I think.
01:55:22 <vincenz> yeah well I instaleld firefox on a local drive
01:55:58 <vincenz> @fortune
01:55:58 <lambdabot> We Klingons believe as you do -- the sick should die.  Only the strong
01:55:58 <lambdabot> should live.
01:55:58 <lambdabot> 		-- Kras, "Friday's Child", stardate 3497.2
01:57:17 <vincenz> @where hoogle
01:57:17 <lambdabot> http://www.haskell.org/hoogle
01:58:43 <vincenz> @where fptools
01:58:43 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
01:59:26 <phas> dcoutts, i have a question on glade/gtk2hs
01:59:38 <dcoutts> go ahed
02:00:03 <phas> dcoutts, i have a label and i need to set its labes as a string
02:00:07 <phas> dcoutts, no problem on it
02:00:30 <phas> dcoutts, but if the string is too long the label resizes only horizontally
02:00:50 <dcoutts> that's because nothing is constraining it's size
02:01:00 <dcoutts> if it is constrained then it will wrap
02:01:03 <phas> dcoutts, how can i make it resizing vertically when the string is longer than some value?
02:01:11 <dcoutts> (if you've allowed it to wrap at all)
02:01:35 <dcoutts> if you try it in the glade editor you'll see what's going on
02:01:54 <vincenz> @yow
02:01:55 <lambdabot> Will this never-ending series of PLEASURABLE EVENTS never cease?
02:02:25 <phas> dcoutts, yeah i tried something, but  i didn't found a proper option nor i understood if it must be an option of the label or of the window
02:03:01 <dcoutts> the wrap property of the label must be True and the label's size but be constrained by the thing it is packed into
02:04:32 <phas> dcoutts, uhm i'll do some test
02:05:47 * lispy elbows the peeps in #ocaml to improve their shootout ranking
02:05:50 <vincenz> @code
02:05:50 <lambdabot> code module failed: Text.Regex.Posix.regcomp: error in pattern
02:07:36 <vincenz> where do I get the fptools binary?
02:08:04 <lispy> @where fptools
02:08:05 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
02:08:12 <lispy> oh, that's probably only the source
02:08:36 <vincenz> I meant the bniary that lambdabot seems to use
02:10:28 <lispy> no, clue, but dons can probaby answer that
02:12:10 <SimonRC> @where ap
02:12:11 <lambdabot> I know nothing about ap.
02:12:20 <SimonRC> @help ap
02:12:21 <lambdabot>  @help <command> - ask for help for <command>
02:13:15 <lispy> @index ap
02:13:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
02:13:16 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
02:13:16 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
02:13:16 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
02:13:51 <SimonRC> what's that command that turns a type into a guess at the function?
02:14:47 <lispy> SimonRC: hoogle
02:14:53 <lispy> @hoogle a -> b
02:14:54 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
02:14:54 <lambdabot> Prelude.id :: a -> a
02:14:54 <lambdabot> Prelude.undefined :: a
02:15:40 <SimonRC> lispy: no
02:16:19 <SimonRC> I mean, I can give it (a->b)->(b->c)-(a->c), and it will reply with (flip (.))
02:16:36 <SimonRC> I've seen it in use before
02:16:42 <lispy> djinn and pl are the only ones i can think that would be close
02:16:42 <SimonRC> in lambdabot
02:16:52 <SimonRC> @help pl
02:16:53 <lambdabot>  @pointless <expr> - play with pointfree code
02:17:01 <SimonRC> @help djinn
02:17:02 <lambdabot> Generates Haskell code from a type.
02:17:02 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
02:17:03 <lispy> @pl \x -> x + x
02:17:04 <lambdabot> join (+)
02:17:20 <lispy> @djinn (a->b)->(b->c)->(a->c)
02:17:20 <lambdabot> f a b c = b (a c)
02:19:00 <lispy> @djinn (a,b)
02:19:01 <lambdabot> -- f cannot be realized.
02:19:22 <lispy> @djinn (a,b) -> a
02:19:23 <lambdabot> f (a, _) = a
02:19:33 <lispy> that's not at all what i expected
02:19:44 <lispy> @pl \(a,b) -> a
02:19:44 <lambdabot> fst
02:19:52 <dcoutts> phas, it looks like you have to limit the width of the label using widgetSetSizeRequest
02:20:10 <dcoutts> phas, otherwise it requests enough space to fit all on one line
02:20:25 <dcoutts> and you have to turn wrapping on obviously
02:22:36 <vincenz> how do I build lambdabot?
02:22:52 <lispy> vincenz: do you have the code yet?
02:22:55 * vincenz downloaded and installed hs-plugins
02:22:58 <vincenz> lispy: yeah
02:23:03 <phas> dcoutts, i have to do it from source code or i can do it from glade?
02:23:04 <vincenz> but do I need that other stuff like "Cabal .."
02:23:14 <dcoutts> phas, you can do it from glade
02:23:14 <lispy> vincez: alright, that's theonly part ic an help with :)
02:23:39 <vincenz> lispy: did oyu compile it?
02:23:42 <lispy> nope
02:23:46 <vincenz> dar
02:23:59 <lispy> never downloaded it, just know that @where lambdabot will tell you where to download it
02:24:08 <lispy> or is it @version
02:24:11 <lispy> @version
02:24:12 <lambdabot> lambdabot 3p283, GHC 6.5.20050806 (Linux i686)
02:24:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
02:24:29 <bosie> what does "<-" in monads?
02:25:13 <SimonRC> bosie: how much do you know about monads?
02:25:21 <bosie> just learning it
02:25:26 <bosie> started like 30minutes ago
02:25:40 <SimonRC> what you just started learning Haskell, or monads?
02:25:47 <bosie> latter
02:25:54 <SimonRC> do have experience with the IO monad
02:25:57 <bosie> no
02:26:04 <SimonRC> hmm
02:26:27 <SimonRC> do you understand things like the type of "Maybe a".
02:26:34 <SimonRC> s/of //
02:26:57 <bosie> i hope so yes
02:27:00 <SimonRC> That is, parameterized types.
02:27:09 <bosie> isntance Monad Maybe where
02:27:09 <bosie> Nothing >>= k = Nothing
02:27:12 <bosie> ...
02:27:29 <bosie> mean that?
02:27:36 <SimonRC> Well, a monad is a parameterised type of kind * -> *
02:27:51 <ihope> What's the status on non-recursive Haskell?
02:28:10 <SimonRC> bosie: well, not that, simpler than that: the difference between Maybe Int and Maybe Char, for example
02:28:20 <SimonRC> bosie: anyway...
02:28:49 <vincenz> @ghc
02:28:49 <lambdabot>  Use -fallow-incoherent-instances
02:28:52 <bosie> a monad is a generic container which you parameterise by putting a type in front of it (kinda) right? ;)
02:28:53 <vincenz> @ghc
02:28:53 <lambdabot>  For basic information, try the `--help' option.
02:28:55 <vincenz> @ghc
02:28:55 <lambdabot>  Occurs check: cannot construct the infinite kind
02:28:59 <vincenz> @babel
02:28:59 <lambdabot>  bzzt.
02:29:27 <SimonRC> bosie: Actually, I recommend you read a tutorial on monads... I'l find the one I'm thinking of...
02:29:44 <ihope> Hmm, infinite kinds.
02:29:44 <bosie> http://www.haskell.org/hawiki/MonadsAsContainers
02:30:06 <bosie> SimonRC mean that?
02:30:30 <ihope> @ghc
02:30:30 <lambdabot>  parse error on input
02:30:45 <SimonRC> bosie: waitamo
02:31:20 <SimonRC> bosie:   http://www.nomaware.com/monads/html/  <-- this one
02:31:57 <SimonRC> (also, note that the similarity between list comprehensions and monds if not just a co-incidence)
02:32:19 <SimonRC> @help djinn
02:32:20 <lambdabot> Generates Haskell code from a type.
02:32:20 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
02:32:36 <SimonRC> @help pl
02:32:36 <lambdabot>  @pointless <expr> - play with pointfree code
02:32:45 <SimonRC> @where pl
02:32:46 <lambdabot> I know nothing about pl.
02:32:50 <SimonRC> @where pointless
02:32:50 <lambdabot> I know nothing about pointless.
02:33:20 <vincenz> @repos
02:33:21 <lambdabot> Unknown command, try @listcommands.
02:33:24 <vincenz> @listcommands
02:33:25 <lambdabot> use listcommands [module|command]. Modules are:
02:33:25 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
02:33:25 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
02:33:25 <lambdabot> seen spell state system todo topic type version vixen where
02:33:30 <vincenz> @lShell
02:33:31 <lambdabot> Unknown command, try @listcommands.
02:33:34 <vincenz> @lShell ls
02:33:34 <lambdabot> Unknown command, try @listcommands.
02:33:44 <vincenz> @help lShell
02:33:44 <lambdabot> lShell provides: lam
02:33:48 <vincenz> @lam
02:33:49 <lambdabot> Terminated
02:33:51 <bosie> SimonRC right
02:33:53 <vincenz> @help @lam 
02:33:54 <lambdabot>  @help <command> - ask for help for <command>
02:33:57 <vincenz> @help lam 
02:33:57 <lambdabot> Evaluate terms of the pure, untyped lambda calculus
02:33:57 <lambdabot> darcs get http://www.eecs.tufts.edu/~rdocki01/lambda
02:34:33 <ihope> @lam (
02:34:33 <lambdabot> expecting white space, "(", "\\" or letter
02:34:37 <ihope> Bleh.
02:34:47 <ihope> @lam (\x -> x x) (\x -> x x)
02:34:48 <lambdabot> expecting space, letter or "."
02:34:57 <ihope> @lam (\x . x x) (\x . x x)
02:35:08 <lambdabot> Terminated
02:36:59 <vincenz> dons: ping
02:37:18 <vincenz> @seen dons
02:37:18 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 9 hours, 26 minutes and
02:37:18 <lambdabot> 29 seconds ago.
02:42:20 <vincenz> Anyone have any experience with building lambdabot?
02:46:10 <jak> anybody used scrap-your-boilerplate style generics to provide unification for use with a backtracking monad?
02:46:57 <vincenz> jak: ?
02:47:11 <vincenz> in english?
02:47:14 <jak> lol
02:48:01 <jak> erm, I remember reading a paper about doing unification in haskell in a generic way, but it relied on structuring your datatypes in a special way
02:48:26 <jak> Now with scrap-your-boilerplate, that structuring shouldn't be necessary anymore
02:48:45 <vincenz> scrap-your-boilerplat?
02:48:56 <vincenz> and you mean type unification?
02:49:13 <jak> I mean to implement a data-type unifier
02:49:38 <jak> i mean not types, to actually implement unification as in prolog between terms
02:49:38 <vincenz> ...
02:49:51 <vincenz> sorry, not familiar with that lingo
02:50:05 <jak> vincenz, have you seen http://www.cs.vu.nl/boilerplate/
02:50:50 <vincenz> nope
02:51:10 <tibbe> anyone have any tips for an interview with google?
02:51:27 <jak> it's a way in which you can write functions to traverse arbitrary data types 
02:52:04 <vincenz> moce
02:52:15 <vincenz> tibbe: ooh you're interviewing at google? where
02:52:50 <SimonRC> tibbe: read up on "MapReduce"
02:53:01 <SimonRC> Think creatively.
02:53:28 <SimonRC> Go for a walk and get a good night's sleep.
02:53:48 <vincenz> SimonRC: hehe... read up on the document from microsoft bashing the document of google about mapreduce
02:53:52 <vincenz> :P
02:53:57 <liyang> (Which isn't really reduce . map)
02:54:01 <Philippa_> tibbe: don't panic about coming across as sociable or things like that
02:54:09 <liyang> lol
02:54:13 <vincenz> tibbe: come accross as sociable
02:54:22 <liyang> come across as yourself. :p~~
02:54:29 <Philippa_> exactly
02:54:30 <vincenz> tibbe: comme accross
02:54:44 <SimonRC> liyang: I know *that*
02:54:51 <vincenz> btw, anyone ever buitl lambdabot
02:56:25 <tibbe> vincenz, not sure if I am yet, it's for Geneva
02:56:34 <tibbe> SimonRC, have read that paper
02:56:55 <vincenz> tibbe: cool
02:57:02 <tibbe> vincenz, where's that document?
02:57:08 <vincenz> tibbe: MapReduce?
02:57:33 <tibbe> vincenz, the MS one
02:57:52 <vincenz> http://www.cs.vu.nl/~ralf/MapReduce/
02:58:00 <SimonRC> vincenz: google for it, it is a parallellisation technique used by google
02:58:15 <vincenz> SimonRC: I know the mapreduce one
02:58:16 <SimonRC> based on the map and reduce functions
02:58:20 <vincenz> SimonRC: I was asking which he meant
02:58:28 <vincenz> SimonRC: there's another paper by microsoft that bashes it :P
02:58:48 <vincenz> that just really gives you a picture about corporate mentality of employees
02:58:52 <vincenz> http://www.cs.vu.nl/~ralf/MapReduce/
02:59:14 <vincenz> uses haskell as type language to say "google's mapreduce document is faulty
02:59:55 <Philippa_> lemme guess, it then turns out that's just because haskell's type system isn't sufficiently powerful?
03:02:18 <vincenz> nah
03:02:29 <vincenz> it usesh askell as a design-language
03:02:35 <vincenz> it's rather simplistic as document
03:02:41 <vincenz> and I wonder why the guy took the time to write it
03:02:58 <vincenz> cnocerning lambdabot...do I really need to locally install that faststring thingy
03:03:05 <Philippa_> beginning to read it, it looks like to pimp the idea of haskell as design languaged
03:03:08 <vincenz> FastPackedString library without the mmap extensions:
03:03:08 <Philippa_> *language
03:03:15 <Philippa_> I think so, yeah
03:03:27 <vincenz> cause in the example, dons installs it locally
03:03:36 <liyang> It's not very well written, that paper. 
03:03:42 <vincenz> liyang: which one?
03:03:50 <vincenz> liyang: mapreduce or the response
03:03:52 <vincenz> runhaskell Setup.hs configure --prefix=/home/dons
03:05:41 <vincenz> why the no-mmap version?
03:05:59 <liyang> vincenz: Ralf's one. But read it for yourself. :)
03:06:05 <Philippa_> presumably because it doesn't use mmap and not everywhere has it?
03:06:23 <vincenz> liyang: I already have
03:07:26 * vincenz wonders why lambdabot specifically requires the no-mmap version
03:08:15 <Philippa_> easier than requiring one-or-the-other?
03:08:16 <shapr> hiya franka 
03:08:35 <Philippa_> I forget whether it's easy to represent that in the version of cabal currently shipping with GHC releases
03:08:47 <franka> Hi, shapr.
03:10:48 <SyntaxNinja> shapr!
03:13:51 <gour> have you seen post on ml: Internships at Microsoft Research available for haskell projects
03:14:20 <liyang> !link?
03:17:19 <gour>  http://research.microsoft.com/aboutmsr/jobs/internships/
03:18:43 <SimonRC> Hmm, that MS paper is basically saying that Google's MR description is vague and imprecise.
03:21:05 <vincenz> yip
03:21:13 <vincenz> it's true, but still it feels liek bashing
03:21:31 <vincenz> the one 'type-error' is in fact what I got stuck on in the MR paper
03:22:08 <Saulzar> Hehe, It does come across that way... "We are not clearly told .... but we can infer the nesescary details from the text"
03:22:13 <gour> in the email Simon lists concrete projects..
03:22:31 <Philippa_> he does also say they're open to suggestions though
03:22:43 <gour> yep
03:23:41 <liyang> Guess it's time to re-subscribe to the MLs.
03:26:19 <tibbe> @quote
03:26:19 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype;
03:26:19 <lambdabot> deriving the newtype is recursive. Great leaders brings less pain.
03:26:34 <basti_> lol
03:27:19 <SimonRC> hi
03:31:44 <vincenz> @quote 
03:31:45 <lambdabot> vincenz says: I'm not looking at a way to do hetero
03:31:59 <vincenz> hmm...that is a serious pull out of context
03:32:28 <shapr> @quote
03:32:28 <lambdabot> HavocPennington says: Haskell is the least-broken programming language
03:32:28 <lambdabot> available today.
03:33:02 <shapr> hey SyntaxNinja 
03:33:07 <shapr> @quote
03:33:08 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl
03:33:08 <lambdabot> didn't teach us in 3e03
03:33:17 <shapr> What's up with desrt these days?
03:34:17 <Saulzar> vincenz, Aren't all the best quotes? :)
03:34:43 <vincenz> :D
03:35:13 <vincenz> @type conv
03:35:14 <lambdabot> Not in scope: `conv'
03:36:33 * vincenz tries to figure out how the Paste module works
03:37:56 <vincenz> > sum $ enumFrom 1
03:38:01 <lambdabot> Terminated
03:38:35 <vincenz> @contineu
03:38:35 <lambdabot> Unknown command, try @listcommands.
03:38:37 <vincenz> @continue
03:38:37 <lambdabot> Unknown command, try @listcommands.
03:38:43 <vincenz> @resume
03:38:44 <lambdabot> Unknown command, try @listcommands.
03:38:58 <vincenz> @listcommands
03:38:58 <lambdabot> use listcommands [module|command]. Modules are:
03:38:58 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
03:38:58 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
03:38:58 <lambdabot> seen spell state system todo topic type version vixen where
03:39:04 <vincenz> @listcommands lambda
03:39:05 <lambdabot> No module "lambda" loaded
03:39:18 <SimonRC> @where ltu
03:39:18 <lambdabot> I know nothing about ltu.
03:39:23 <SimonRC> ooh dear
03:39:34 <palomer> someone explain to me how to solve hornsat with unit propagation
03:39:42 <SimonRC> @where+ ltu http://lambda-the-ultimate.org/
03:39:43 <lambdabot> Done.
03:39:46 <SimonRC> @where ltu
03:39:47 <lambdabot> http://lambda-the-ultimate.org/
03:39:55 <SimonRC> that's better
03:41:39 <franka> hornsat = Horn-clause satisfaction?
03:42:07 <vincenz> @help todo
03:42:07 <lambdabot>  @todo, list todo entries
03:42:10 <vincenz> @listcommands todo
03:42:11 <lambdabot> todo provides: todo todo-add
03:42:12 <vincenz> @todo
03:42:12 <lambdabot> 0. SamB: A way to get multiple results from a google search
03:42:12 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
03:42:12 <lambdabot> 2. SamB: stop mangling long urls
03:42:12 <lambdabot> 3. dons: improve formatting of @dict
03:42:13 <lambdabot> 4. dons: write Haskell Manifesto
03:42:15 <lambdabot> [27 @more lines]
03:42:16 <palomer> franka: yup
03:42:33 <franka> Can't help you.
03:42:36 <palomer> satisfiability even
03:43:26 <franka> The only ways I know to solve logic clauses are resolution and semantic tableaux.
03:45:14 <vincenz> @type \x -> let ?x = x in x
03:45:15 <lambdabot> forall t. t -> t
03:45:19 <vincenz> @type \x -> let ?x = x in ?x
03:45:19 <lambdabot> forall t. t -> t
03:45:31 <vincenz> what is the ? syntax?
03:45:35 <vincenz> > ? x
03:45:36 <lambdabot>  parse error on input `?'
03:45:36 <vincenz> > ?x
03:45:37 <lambdabot>  parse error on input `?'
03:45:50 <Cale> implicit parameters
03:46:10 <vincenz> let ?ref = ref
03:46:14 <vincenz> isn't that redundant?
03:47:23 <Cale> actually, I have no idea why you're getting that
03:47:33 <vincenz> Cale: LambdaBot.hs
03:47:35 <Cale> oh
03:47:37 <Cale> it's a lambda
03:47:46 <vincenz> o.O?
03:47:50 <Cale> no, it's not redundant
03:47:55 <Cale> ?x and x are different
03:48:22 <vincenz> ah
03:49:58 <palomer> hrm
03:50:06 <palomer> okay, now I've come to the crux of my algorithm
03:50:53 <vincenz> ut-oh's
03:53:13 <palomer> what's the easiest way to create a list of n new STRefs?
03:54:20 <Saulzar> mapM, I guess
03:54:29 <Cale> rs <- replicateM n (newSTRef 0)
03:55:33 <palomer> does every "list function" have a monadic equivalent?
03:55:51 <int-e> > replicateM 3 [1,2]
03:55:53 <lambdabot> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
03:55:58 <Cale> well, you can usually construct one with sequence
03:56:23 <Cale> Control.Monad doesn't have everything though
03:56:33 <Cale> notably, repeatM is missing
03:56:51 <palomer> is there a good reason for this?
03:56:59 <Cale> no
03:57:00 <dcoutts> SyntaxNinja, I've finished that patch to make Cabal ignore unknown fields with just a warning.
03:57:32 <palomer> I keep writing functions like foo (h:t) = .. ; foo [] = ..., is there a canonical way to transform this into a 1 liner?
03:57:34 <dcoutts> SyntaxNinja, which is the primary darcs repo for Cabal? which one should I be using? darcs.haskell.org/cabal/ or something else?
03:57:58 <int-e> palomer: foldr?
03:58:13 <Cale> yeah, foldr
03:58:43 <int-e> foldr captures the foo (h:t) = ... (foo t) ...; foo [] = ... pattern.
03:59:13 <palomer> foo (h:t) = x; foo [] = y transforms into foldr (\a b -> x) y ?
03:59:15 <int-e> and can also be (ab?)used for the case where foo t is not used.
03:59:27 <int-e> yep
04:00:33 <Cale> well, it can be
04:00:44 <palomer> wait, a and b don't appear on the lhs!
04:01:30 <Cale> you replace (foo t) with b
04:01:55 <int-e> foo (h:t) = let f' = foo t in x; foo [] = y --> foldr (\h f' -> x) y
04:02:46 <Cale> sum [] = 0; sum (x:xs) = x + (sum xs) ==> sum = foldr (\x y -> x + y) 0
04:03:42 <dcoutts> SyntaxNinja, and I've made it ignore fields in the .cabal file that begin with "x-"
04:04:09 <palomer> @hoogle mapM
04:04:10 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:04:10 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:04:10 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
04:07:49 <palomer> @hoogle sequence
04:07:50 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
04:07:50 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
04:07:50 <lambdabot> Control.Monad.sequence_ :: Monad m => [m a] -> m ()
04:08:12 <palomer> @hoogle (a -> m b) -> [a] -> something
04:08:13 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
04:08:13 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
04:08:13 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
04:08:19 <SyntaxNinja> dcoutts: sweet. the one from the cabal web page, still. darcs.haskell.org/cabal
04:08:24 <palomer> hrmph
04:08:40 <palomer> I want to iterate through a list, and while iterating through that list I want to update STRefs
04:08:51 <palomer> mapM doesn't seem to be what I want
04:08:52 <SyntaxNinja> dcoutts: are you going to darcs send me the patch? do you have any test cases?
04:09:04 <dcoutts> SyntaxNinja, yeah, I'll darcs send
04:09:18 <dcoutts> SyntaxNinja, how/where do I add my test cases?
04:09:21 <palomer> @hoogle lookup
04:09:22 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
04:09:22 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
04:09:22 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
04:10:26 <SyntaxNinja> dcoutts: I can add it if you want, just an example program that should fail to build if it doesn't work is fine; you can add it under tests/ and read ModuleTest if you want to add the test case yoursel.f
04:11:08 <SyntaxNinja> dcoutts: I'm still working w/ simonMar to figure out the multiple darcs repos problem.  thing is that the fptools makefile doesn't work on its own, and the standalone makefile gets int he fptools build system's way.
04:12:09 <palomer> @hoogle writestref
04:12:09 <lambdabot> Data.STRef.Lazy.writeSTRef :: STRef s a -> a -> ST s ()
04:12:09 <lambdabot> Data.STRef.writeSTRef :: STRef s a -> a -> ST s ()
04:12:43 <SyntaxNinja> dcoutts: you rule.
04:12:51 <franka> Cale, if a backslash is a lambda, is a slash an adbmal?
04:12:57 * dcoutts grins
04:13:19 <vincenz> while building lambdabot
04:13:21 <waern> SyntaxNinja, btw. The fptools darcs Makefile says version: 1.0 even though the repository seems to be 1.1.4
04:13:21 <vincenz> Binary.hs:1:0:
04:13:21 <vincenz>     Warning: `IO' is imported more than once:
04:13:21 <vincenz>                imported from GHC.IOBase at Binary.hs:28:25-30
04:13:21 <vincenz>                imported from Prelude at Implicit import declaration
04:13:35 <waern> SyntaxNinja, argh.. I mean Cabal, not darcs
04:13:46 <SyntaxNinja> cabal kicks darcs butt
04:14:23 <Cale> franka: I suppose if you have a language which supports adbmals.
04:14:30 <vincenz> suggestions are welcome
04:15:25 <SyntaxNinja> waern: thanks. fixed!
04:15:51 <dcoutts> SyntaxNinja, so for a test I should add a new dir under tests/ with a .cabal file that produces a warning for an unknown field?
04:16:30 <franka> Cale, how do I use Haskell to write an operating system?
04:17:19 <vincenz> anyone know how to deal with taht error/
04:17:22 <Cale> @where House
04:17:22 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
04:18:05 * SimonRC goes
04:18:07 <Cale> vincenz: It's just a warning, but hide one of the imports of IO.
04:18:21 * SyntaxNinja pulls patches from "real" cabal repo
04:18:25 <SyntaxNinja> so they should match up again.
04:19:03 <dcoutts> SyntaxNinja, hmm I don't understadn the cabal test setup.
04:19:06 <SyntaxNinja> dcoutts: hm. not exactly sure... I guess that would work, since that'll fail if the feature ever breaks or something.
04:19:27 <SyntaxNinja> dcoutts: it's a little complicated, yeah.
04:19:41 <franka> Cale, how do I turn an IO String into a String?
04:19:55 <dcoutts> SyntaxNinja, the test is just adding a couple lines to a .cabal file like "foo:bar\nx-foo:bar"
04:20:03 <SyntaxNinja> dcoutts: fine.
04:20:04 <vincenz> Cale: it breaks off the make process
04:20:08 <dcoutts> SyntaxNinja, one should elicit a warning and the other should not
04:20:11 <vincenz> make: *** [Binary.o] Error 1
04:21:30 <palomer> $ should become part of the syntax, and should become part of patterns
04:21:34 <palomer> discuss.
04:22:47 <vincenz> Cale: it fails to compile it
04:24:31 * vincenz turns off in -Werr in the makefile
04:24:31 <dcoutts> SyntaxNinja, the darcs.haskell.org/cabal repo doesn't have a default email address. it should be in _darcs/prefs/email
04:24:35 <vincenz> I wonder how dons ever got it to compile 
04:25:03 <vincenz> blegh... lambdabot has a lot of dual imports
04:25:08 <dcoutts> SyntaxNinja, sent
04:27:31 <vincenz> @seen dons
04:27:31 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 11 hours, 16 minutes
04:27:31 <lambdabot> and 37 seconds ago.
04:28:56 <SyntaxNinja> dcoutts: what's the diff btw author and email?
04:32:16 <Igloo> author is who makes the patches, email is where patches should be sent to
04:33:43 <palomer> @hoogle [a] -> [b] -> [(a,b)]
04:33:44 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
04:33:44 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
04:35:19 <tony2> Does anyone here know anything about Lolita? It's listed in the free applications section of the haskell.org web-site but I can't find it anywhere.
04:35:57 <vincenz> @help Djinn
04:35:57 <lambdabot>  @help <command> - ask for help for <command>
04:36:02 <vincenz> @helpcommands djinn
04:36:03 <lambdabot> Unknown command, try @listcommands.
04:36:08 <vincenz> @listcommands djinn
04:36:09 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-
04:36:09 <lambdabot> ver
04:36:12 <vincenz> @djinn
04:36:12 <lambdabot> Cannot parse command
04:38:07 <vincenz> djinn-
04:38:10 <vincenz> @help djinn
04:38:11 <lambdabot> Generates Haskell code from a type.
04:38:11 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
04:41:41 <dcoutts> SyntaxNinja, if you fill in _darcs/prefs/email on the repo on the server with your email then it'll all "Just Work"tm when people darcs send
04:44:19 <vincenz> @elite lala
04:44:19 <lambdabot> lA|a
04:44:39 <vincenz> @hello
04:44:39 <lambdabot>  @help <command> - ask for help for <command>
04:44:41 <vincenz> @goodbye
04:44:42 <lambdabot> Unknown command, try @listcommands.
04:46:34 <vincenz> @state
04:46:35 <lambdabot> foo
04:46:39 <vincenz> @state
04:47:37 <vincenz> @vixen
04:47:38 <lambdabot> help help!
04:47:44 <vincenz> @vixen
04:47:44 <lambdabot> I hear ya!
04:47:54 <liyang> so... what does @state actually do?
04:48:09 <liyang> @help state
04:48:10 <lambdabot>  @state - we all know it's evil
04:48:49 <vincenz> @help vixen
04:48:50 <lambdabot> sergeant curry's lonely hearts club
04:48:52 <vincenz> @vixen
04:48:52 <lambdabot> Crazy little wanker!
04:48:56 <vincenz> @state 1
04:48:59 <vincenz> @state
04:48:59 <lambdabot> 1
04:49:02 <vincenz> @state
04:49:06 <vincenz> it's like an mvar :)
04:49:10 <vincenz> @state 1
04:49:11 <vincenz> @state 2
04:49:12 <lambdabot> 1
04:49:14 <vincenz> @state
04:49:14 <lambdabot> 2
04:49:19 <vincenz> @state Old
04:49:21 <vincenz> @state New
04:49:22 <lambdabot> Old
04:49:23 <vincenz> @state Someone
04:49:23 <lambdabot> New
04:49:25 <vincenz> @state Yaya
04:49:26 <lambdabot> Someone
04:49:46 <vincenz> @help combine
04:49:47 <lambdabot>  @help <command> - ask for help for <command>
04:49:55 <vincenz> @listcommands
04:49:55 <lambdabot> use listcommands [module|command]. Modules are:
04:49:55 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
04:49:55 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
04:49:55 <lambdabot> seen spell state system todo topic type version vixen where
04:49:58 <vincenz> @listcommands compose
04:49:58 <lambdabot> compose provides: . compose
04:50:00 <vincenz> @help compose
04:50:00 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>=
04:50:00 <lambdabot> f
04:50:46 <vincenz> @compose @state @eval take 100 $ repeat 1
04:50:46 <lambdabot> compose module failed: Parse error: "@state"
04:50:56 <vincenz> @compose state eval take 100 $ repeat 1
04:50:57 <lambdabot> Yaya
04:51:01 <vincenz> @state
04:51:01 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:51:01 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:51:01 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
04:51:01 <lambdabot>  
04:51:04 <vincenz> nice
04:51:16 <xerox> ?!
04:51:27 <vincenz> you can use it as a temporary variable between two computations
04:51:31 <xerox> Wow!
04:51:33 <vincenz> @compose state eval take 100 $ repeat 1
04:51:56 <vincenz> or not
04:51:59 <vincenz> @compose state state
04:52:00 <ski> good evening, #haskell
04:52:04 <vincenz> @state
04:52:05 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:52:05 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:52:05 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
04:52:05 <lambdabot>  
04:52:25 <xerox> @compose state eval "\f xs -> xs >>= return . f"
04:52:25 <vincenz> @compose eval sum state
04:52:26 <lambdabot> compose module failed: Parse error: "sum"
04:52:31 <xerox> @compose pl state
04:52:32 <lambdabot> "\f xs -> xs >>= return . f"
04:52:35 <xerox> heh
04:52:41 <xerox> @compose state eval error "\f xs -> xs >>= return . f"
04:52:43 <xerox> @compose pl state
04:52:43 <lambdabot> Add a type signature
04:52:45 <xerox> Yay
04:52:48 <xerox> @compose state eval error "\f xs -> xs >>= return . f" :: ()
04:52:51 <xerox> @compose pl state
04:52:51 <lambdabot> (line 1, column 17):
04:52:51 <lambdabot> unexpected ">" or "-"
04:52:51 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
04:52:58 <vincenz> @compose state eval \f xs -> xs >>= return . f
04:53:06 <vincenz> @compose pl state
04:53:06 <lambdabot> (line 1, column 44):
04:53:06 <lambdabot> unexpected ">"
04:53:06 <lambdabot> expecting variable, "(", operator or ")"
04:53:31 <vincenz> @state
04:53:36 <vincenz> @compose state eval \f xs -> xs >>= return . f
04:53:37 <vincenz> @state
04:53:37 <lambdabot>  add an instance declaration for (Show ((a -> b) -> m a -> m b))
04:53:37 <lambdabot>  
04:53:41 <vincenz> aha!
04:55:21 <liyang> o.o
04:55:40 <vincenz> @state 1
04:55:42 <vincenz> @state 2
04:55:43 <lambdabot> 1
04:55:47 <vincenz> @compose state state 1
04:55:47 <lambdabot> 1
04:55:48 <vincenz> @compose state state 1
04:55:49 <lambdabot> 1
04:55:52 <vincenz> @state
04:55:52 <lambdabot> 2
04:55:52 <lambdabot>  
04:55:59 <vincenz> it's a flipflop
04:56:50 <vincenz> @compose state compose state state 123
04:56:56 <vincenz> @state
04:56:56 <lambdabot> 123
04:57:01 <vincenz> @state 1
04:57:03 <vincenz> @state 2
04:57:04 <lambdabot> 1
04:57:06 <vincenz> @compose state compose state state 1
04:57:06 <lambdabot> 2
04:57:12 <vincenz> @compose state compose state state 1
04:57:12 <lambdabot> 1
04:57:12 <lambdabot>  
04:57:14 <vincenz> @compose state compose state state 1
04:57:14 <lambdabot> 1
04:57:14 <lambdabot>  
04:57:20 <vincenz> blegh
04:58:20 <prionic> is it possible to include the ghci interpreter in your own haskell or c program?
04:58:55 <vincenz> prionic: yes, that's being done in haskell 6.5
04:59:03 <vincenz> well not interpreter but evaluator
04:59:17 <vincenz> I meant...ghc 6.5
04:59:38 <prionic> thatll take some while i fear... 
05:00:57 <prionic> no other way?
05:01:21 <vincenz> @poll-list
05:01:21 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
05:01:25 <vincenz> @help poll-list
05:01:25 <lambdabot>  @poll-list                 shows all current polls
05:01:40 <vincenz> @help poll-vote
05:01:40 <lambdabot>  @help <command> - ask for help for <command>
05:07:27 <Saulzar> prionic, Take a look at hs-plugins, I think that has bindings for C 
05:07:35 <palomer> @hoogle writeSTRef
05:07:35 <lambdabot> Data.STRef.Lazy.writeSTRef :: STRef s a -> a -> ST s ()
05:07:35 <lambdabot> Data.STRef.writeSTRef :: STRef s a -> a -> ST s ()
05:13:47 <prionic> i tried hs-plugins eval, but its pretty slow
05:15:40 * palomer head hurts
05:38:07 <bosie> quick question:
05:38:24 <bosie> does haskell cache variables and pathes during recursion ?
05:40:05 <monochrom> sorry, I don't understand the question
05:40:23 <bosie> say i have:
05:40:29 <bosie> fib :: Int -> Int
05:40:29 <bosie> fib b  | b > 0 = fib (b-1) + fib(b-2)
05:40:42 <Cale> that will be slow
05:40:50 <bosie> doesnt matter for now ;)
05:41:00 <bosie> would haskell cache the pathes since b-1 and b-2 would cross pathes
05:41:11 <Cale> in that it will recompute fib 0 many times
05:41:17 <Cale> (and every other fib)
05:41:35 <bosie> ok that was my question
05:41:37 <monochrom> Current executers won't.
05:41:40 <bosie> i thought/hoped it wouldnt do that
05:41:41 <Cale> it doesn't memoise applications of functions to values
05:41:47 <bosie> well
05:42:11 <bosie> how can i understand that phrase then:
05:42:23 <bosie> haskell does evaluate a variable maximum once
05:42:31 <bosie> but can be 0 too
05:42:33 <Cale> a variable
05:42:45 <bosie> ok
05:42:46 <monochrom> "fib 0" is not a variable.
05:42:59 <bighead> hi , i'm new to haskell, and have been reading Yet Another Haskell Tutorial to get started. I was trying some code out of the book, but when I type "fib 1 = 1" on the prompt in GHCi, it gives me a parse error
05:43:11 <bosie> so if i have fib b-1 + fib b-1 it would at least not calculate b-1 twice right?
05:43:13 <Cale> bighead: you have to put your source code in a file
05:43:22 <monochrom> "let x = 1+1 in [x,x,x,x,x]"   the 1+1 there will be done once and saved for x.
05:43:35 <bighead> Cale: ok. so i can't write functions in interactive GHC?
05:43:54 <monochrom> "fib whatever" is still not a variable.
05:43:59 <Cale> bighead: you can write them with let, but there's lots of other things you can't write interactively
05:44:06 <bosie> monochrom i said b-1 not fib
05:44:32 <monochrom> "b-1" is still not a variable.
05:44:51 <Cale> bighead: you can write:  let fib 1 = 1; fib n = fib (n-1) + fib (n-2)
05:44:52 <bosie> well
05:44:58 <Cale> all on one line
05:45:18 <bighead> Cale ok. thanks
05:45:24 <monochrom> However, I know GHC does common subexpression elimination and turns "f(b-1) + f(b-1)" into "let x=b-1 in f x + f x"
05:45:27 <bosie> damn stupid behaviour kinda
05:45:39 <Cale> bighead: but it's much nicer to just keep a file going alongside your GHCi and type :r in GHCi whenever you save your changes
05:46:08 * bighead wonders if haskell-mode for emacs runs GHCi in a inf-mode
05:46:51 <jethr0> @pl \(_,n) -> (wt n nd, n)
05:46:52 <lambdabot> ((,) =<< flip wt nd) . snd
05:46:54 <monochrom> I can also see a future Haskell implementation memoizes fib 0.  Nothing in "Haskell" forbids, that, you know.  You just need someone to write a compiler...
05:47:47 <Cale> bosie: the trouble is that it's hard to tell what would be good to memoise, and how it should be memoised (how the lookups in the memo table should be made)
05:48:31 <Cale> http://citeseer.ist.psu.edu/peytonjones99stretching.html -- this is a decent paper about the situation
05:48:38 <bighead> hmm what is the keybinding to run GHCi in emacs when in haskell-mode? any emacs users around?
05:48:44 <bosie> well monochrom so i guess haskell isnt popular enough or woot? ;)
05:49:20 <Cale> bosie: it's not quite that simple
05:49:22 <bosie> Cale i guess its like that, thank you
05:49:35 <monochrom> C is popular but I have yet to see a C compiler doing memoisation.
05:50:04 <bosie> monochrom no but at least for what i have seen it would be alot more appropriate in haskell
05:50:20 <Cale> memoisation can lead to bad memory leaks
05:50:44 <monochrom> I don't think many programmers are ready to spend memory to save time.
05:51:12 <monochrom> If you impose a memoising compiler on them I think they're going to complain rather than celebrate.
05:52:20 <bosie> hmm what programs are developed with haskell ?
05:52:26 <bosie> do they run on low-budget computers?
05:53:23 <Saulzar> All sorts of programs, and sure, why not?
05:53:26 <monochrom> Even if you impose a compiler on them that recognizes a Theta(n^2) sorting algorithm and replaces it with a Theta(n log n) one, they are going to complain.  Apparently they don't like smartass compilers.  I had actually suggested that on comp.lang.functional and the people posted back saying please don't do that.
05:53:54 <Cale> bighead: C-c C-s, C-c C-l
05:54:29 <bosie> hmmm
05:54:36 <bosie> thats quite something
05:54:49 <Saulzar> Well, I guess the problem is that for every situation that it is smart there will be one where it is a pain
05:55:09 <Saulzar> Unless you can ensure that it's either optional or sufficiently general that it's always useful
05:55:29 <Cale> monochrom: can you actually do that though?
05:55:33 <monochrom> No no no, the people are saying, "even if it has no pitfall, I don't like the compiler decreasing my time complexity!"
05:55:42 <Cale> that's silly
05:56:12 <Cale> If the compiler can decrease time complexity without hurting space complexity, it should.
05:56:17 <int-e> having the option would be nice, actually - although I'
05:56:24 <int-e> d prefer a source level tool for that
05:56:40 <Cale> (and vice versa)
05:56:41 <Saulzar> Cale, Or adding large constant time complexity...
05:56:54 <ski> (mercury has pragma for memoizing)
05:56:56 <Cale> Saulzar: sure.
05:57:40 <bighead> Cale thanks
05:57:58 <Saulzar> Anyway, I guess the reason protest is that they don't believe it's possible (and it probably isn't, right?)
05:58:57 <Cale> It's not generally possible.
05:59:12 <Cale> You might be able to notice some nice things
05:59:55 <Cale> Laziness is a transform which can reduce time complexity already.
06:01:20 <tuomov> yeah, time allocation is easy when you're too lazy to do anything :)
06:01:34 <Cale> > let isSubstringOf x y = any (isPrefixOf x) (tails y) in isSubstringOf "ere" "Hello there, world!"
06:01:36 <lambdabot> True
06:02:33 <Cale> In a strict language, that's a really stupid way to write that, but laziness makes it practical.
06:04:44 <Cale> (It's  O(length x * length y) rather than O(length x * (length y)^2)
06:04:46 <Cale> )
06:05:51 <thisisadeal> these absolutely have to go today.  2 alienware area51-m 5700 laptops $550 each includes shipping, case, wireless router and 1 alienware area51 7500 desktop $700 includes monitor, keyboard, mouse,. speakers.  message me if you wnat to buy any of these items at mcsltd@telusmail.net, aim at ogd443 or yahoo at mcsltd2 thanks and have a good day.
06:06:39 <bosie> hey guys, now that you are so into laziness and so... what is graphtransformation in lazyniess?
06:21:24 <tibbe> anyone know of any additional documentation available on Alex that's not on haskell.org/alex ?
06:26:03 <dcoutts> tibbe, the ghc lexer might be helpful to look at
06:26:15 <dcoutts> or c2hs's C lexer
06:26:29 <tibbe> dcoutts, alright
06:26:55 * dcoutts wrote c2hs's C lexer after studying ghc's lexer closely.
06:34:38 <cinema> Anyone knows if there is somewhere a Haskell program that reads and parses files in /proc (on Linux) ?
06:35:50 <TuringTest> I have not heard of one
06:35:58 <TuringTest> Text or Binary?
06:36:47 <cinema> Well, data concerning each process (memory, CPU used...)
06:37:34 <TuringTest> I think most /proc files contain ASCII not BINARY, so using Parsec will work well
06:37:36 <jethr0> @hoogle spLength
06:37:36 <lambdabot> Data.Graph.Inductive.Query.SP.spLength :: (Graph gr, Real b) => Node ->
06:37:37 <lambdabot> Node -> gr a b -> b
06:37:53 <TuringTest> jethr0: What does that function do?
06:38:22 <jethr0> it calculates the length of the shortest path in a weighted graph
06:38:35 <jethr0> whereas "sp" calculates the actual path
06:48:14 <palomer> Cale: do you still object using STRef s () as a unique label?
06:48:37 <TuringTest> @seen Cale
06:48:37 <lambdabot> Cale is in #haskell. Last spoke 43 minutes and 49 seconds ago.
06:50:56 <TuringTest> palomer: did you ever see the paste I left you last night? http://www.rafb.net/paste/results/BiRO4038.html
06:51:34 <srle> Hi, A..
06:52:05 <srle> I need some help with O'caml. I beleive that you can help me.
06:52:14 <Lor> There's #ocaml
06:52:20 <srle> I there in ocaml something like: infix 6 (+++)
06:52:28 <Lor> No.
06:52:48 <Lor> The associativity and precedence of ocaml's operators is determined by their names.
06:52:53 <srle> I have adked the question in that chanel and nobody answered the question. I apoligize for posting that question here
06:53:38 <Cale> palomer: for the most part. :) I suppose it's doable, but I don't see it as really the right way to do things
06:53:40 <srle> Lor : What does that mean? What has higher priority (++) or (-+)
06:53:44 <palomer> TuringTest: yeah, I'm basing my code for it
06:53:49 <Lor> http://caml.inria.fr/pub/docs/manual-ocaml/manual015.html
06:53:54 <TuringTest> :)
06:53:55 <palomer> Cale: why not? guarenteed unique labels, and it seems like the right model
06:53:56 <Lor> Please read the docs first.
06:54:00 <srle> Lor : thanks.
06:54:02 <palomer> s/for/on
06:54:15 <palomer> and if you're already working in ST, why not?
06:55:06 <palomer> s/guarenteed/guaranteed
06:55:30 <Cale> I suppose you can if it's convenient of course.
06:56:27 <Cale> I think I'd be pretty confused if I saw code that was doing that until I found out what was going on.
06:56:46 * ski 's seen it done in sml
06:57:16 <palomer> ski: and what were your thoughts on it?
06:57:21 <Cale> If you're in ST, you can create better unique generators.
06:57:37 <ski> palomer : weird :)
06:57:37 <palomer> Cale: with I'd have to use strings or integers
06:57:46 <palomer> s/with/
06:58:12 <Cale> palomer: yeah, of course.
06:58:31 <Cale> or values of a new type
06:58:54 <palomer> and then comparison is done in O(n) time the size of the label
06:59:02 <palomer> for strings
06:59:07 <palomer> and integers overlap, no?
06:59:16 <Cale> overlap?
06:59:26 <palomer> Cale: they're finite in size
06:59:29 <Cale> no
06:59:34 <Cale> Integers are unbounded
06:59:37 <palomer> whoa
06:59:38 <Cale> > 2^500
06:59:39 <lambdabot> 327339060789614187001318969682759915221664204604306478948329136809613379640
06:59:39 <lambdabot> 467455488327009232590415715088668412756007100921725654588539305332852758937
06:59:39 <lambdabot> 6
06:59:53 <palomer> well big integer comparison isn't the quickes thing in the world
06:59:55 <Cale> > product [1..100]
06:59:56 <lambdabot> 933262154439441526816992388562667004907159682643816214685929638952175999932
06:59:56 <lambdabot> 299156089414639761565182862536979208272237582511852109168640000000000000000
06:59:56 <lambdabot> 00000000
07:00:05 <palomer> > 2 ^ 100000000
07:00:10 <lambdabot> Terminated
07:00:10 <Cale> It uses machine integers when the numbers are small.
07:00:27 <palomer> Cale: so it uses runtime checks to convert?
07:00:29 <Cale> and switches to GMP integers when necessary
07:00:33 <Cale> yeah
07:01:10 <palomer> so every call to + has a runtime check?
07:01:24 <Cale> the result is faster than always using GMP integers
07:01:42 <Cale> It ought to
07:06:11 <Cale> *Main Control.Monad.ST> runST (do fresh <- createSupply; x <- fresh; y <- fresh; return (x == x, x == y))
07:06:11 <Cale> (True,False)
07:06:17 <Cale> how about something like that?
07:06:39 <Cale> http://www.haskell.org/hawiki/STSupply
07:07:06 <palomer> yeah, they use integers
07:07:10 <int-e> @hoogle (a->b) -> (b->b->b) -> a -> a -> b
07:07:11 <lambdabot> hoogle: Hoogle/Parser.hs:(82,8)-(85,38): Non-exhaustive patterns in
07:07:11 <lambdabot> function g
07:07:11 <lambdabot>  
07:07:13 <palomer> still, I can't think of any objections to STRef s ()
07:07:29 <Cale> STRef s () will probably use integers at some level.
07:07:38 <int-e> @djinn  (a->b) -> (b->b->b) -> a -> a -> b
07:07:39 <lambdabot> f a b c _ = b (a c) (a c)
07:07:45 <Cale> (even if they're only memory locations)
07:08:06 <Cale> This wraps the integers so that they're not visible as numbers from outside the module
07:08:19 <Cale> they're only comparable for equality and creation ordering
07:08:23 <xerox> @pl f a b c _ = b (a c) (a c)
07:08:24 <lambdabot> f = ((const .) .) . (flip =<< (ap .) . flip (.))
07:08:37 <xerox> @pl f b a c _ = b (a c) (a c)
07:08:38 <lambdabot> f = ((const .) .) . join . liftM2
07:08:40 <int-e> @pl f a b c d = b (a c) (a d)
07:08:41 <lambdabot> f = flip =<< ((flip . ((.) .)) .) . flip (.)
07:08:45 <xerox> Nicer.
07:09:05 <int-e> @pl f b a c d = b (a c) (a d)
07:09:06 <lambdabot> f = join . ((flip . ((.) .)) .) . (.)
07:09:21 <int-e> too ugly :(
07:09:31 <xerox> ((const .) .) . join . liftM2
07:09:34 <xerox> is nice, isn't it?
07:09:43 <int-e> xerox: but it's not the function that I want
07:09:48 <xerox> :-\
07:11:53 <int-e> (I wanted to write, say, f fromIntegral (+) (1 :: Int) (2 :: Int) :: Float)
07:15:31 <palomer> TuringTest: type Env s a = ReaderT (SType s) (ST s) <---what does the a do?
07:15:44 <TuringTest> one sec
07:16:04 <TuringTest> It says " type Env s a = ReaderT (SType s a) (ST s) "
07:16:12 <TuringTest> You cut and pasted wrong?
07:16:22 <palomer> oh, righto
07:16:28 <palomer> no, I had changed it in my code
07:16:45 <palomer> SType is of kind (*->*) in my code
07:17:19 <araujo> Hello.
07:17:26 <palomer> type Env s = ReaderT [SType s] (ST s);value::SType s -> Env s <---it says Env s is not applied to enough arguments
07:18:24 <ski> @kind Control.Monad.Reader.ReaderT
07:18:25 <lambdabot> * -> (* -> *) -> * -> *
07:18:54 <ski> so  Env :: * -> * -> *
07:19:09 <palomer> oh my
07:19:28 <palomer> type Env s a = ReaderT (SType s a) (ST s) <-- so how does this work?
07:19:42 <palomer> why does ReaderT take so many bloody arguments:P
07:19:52 <shapr> shazam!
07:20:10 <TuringTest> palomer: ST always causes too many type arguments
07:20:11 <ski> greetings, shapr
07:20:19 <shapr> hej ski, hur laget?
07:20:24 <TuringTest> And Monad Transformers cause too many type arguments
07:20:31 <ski> shapr : bra, men lite trtt
07:20:37 <ski> (som vanligt)
07:20:41 <Cale> palomer: So many?
07:21:04 <shapr> ski: kanske du behover sova lite mer? :-)
07:21:07 <Cale> It takes no more than it has to :)
07:21:18 <ski> palomer : in that latter 'Env', it's kind is * -> * -> * -> *
07:21:23 <palomer> TuringTest: so how is Env parameterized?
07:21:58 <TuringTest> palomer: Env takes the needed "s" for (ST s) and an "a" representing the type you get from "ask"
07:22:01 <ski> shapr : vaknade fr ca 3 timmar sen .. kunde inte sova lngre
07:22:14 <shapr> ski: Ngon satte up oss bomben
07:22:15 <palomer> TuringTest: and something else...what?
07:22:24 <shapr> alla era baser r tillhrande oss
07:22:38 * shapr snickers hysterically
07:22:42 <TuringTest> Ah yes...  (Env s a) is a Monad
07:23:10 <TuringTest> So "(Env s a) b" is a monad which returns a type b
07:23:11 <ski> ni har ingen chans att verleva, ta den tid ni behver
07:23:23 <Cale> ReaderT r m a is the type of computations returning a value of type a, which are allowed to read from an environment of type r, and perform computations in the monad m.
07:23:33 * dcoutts notes that shapr has been educating the monad disbelivers on LWN.net
07:23:36 <TuringTest> I could add parenthesis everywhere in the types, but it would not be much clearer
07:23:42 <Cale> LWN?
07:23:49 <dcoutts> Linux Weekly News
07:23:50 <Cale> ah
07:24:03 <Cale> just guessed as you said it :)
07:24:09 <TuringTest> So "(Env s a) a" means that readSType returns the same "a" type as "ask"
07:24:12 <dcoutts> it covered the "Everything Your Professor Failed to Tell You About Functional Programming" article on Linux Journal
07:24:35 <TuringTest> And "(Env s a) ()" means that the writeSType returns the unit type ()
07:24:39 <shapr> gor er tid
07:24:50 <TuringTest> palomer: I hope that hels
07:24:54 <TuringTest> helps
07:25:09 <ski> shapr : har funderat en del p ett typsystem fr reflekterade monader (i haskell, sklart)
07:25:11 * shapr repossesses his keyboard from his gf...
07:25:14 <dcoutts> there was a guy commenting (almost boasting) that pure languages had to be very hard to write IO code
07:25:28 <dcoutts> so shapr put him write
07:25:32 <dcoutts> right
07:25:55 <shapr> I got a reply to that message today.
07:26:43 <SamK> hi
07:26:45 <shapr> http://lwn.net/Articles/169974/
07:26:46 <SamK> say I had a list of 3D vectors [(x1,y1,z1),(x2,y2,z2)...] how would I sort it by the length of each vector?
07:27:38 <jethr0> SamK: map snd . sort . map (mylength &&& id)
07:28:00 <shapr> dcoutts: Oh you replied to that post already.
07:28:29 <dcoutts> shapr, but I misspelt SPJ's quote. (Doh!)
07:28:34 <jethr0> SamK: it's faster than "sortBy (\x y -> compare (mylength x) (mylength y))"
07:28:48 <shapr> Can you edit your posts?
07:28:52 <jethr0> SamK: because in the second case nearly all lenghts are calculated twice
07:28:54 <shapr> Oh, you're not a subscriber.
07:29:39 <shapr> oh and ccshan replied as well.
07:30:25 <palomer> @hoogle ST
07:30:25 <lambdabot> Control.Monad.ST.Lazy.ST :: ST s a
07:30:25 <lambdabot> Control.Monad.ST.ST :: ST s a
07:30:25 <lambdabot> Graphics.UI.ObjectIO.CommonDef.St :: s -> (a, s)
07:30:30 <SamK> jethr0: what does &&& do? - I'm a bit new to this ;)
07:30:50 <palomer> @kind Control.Monad.ST.ST
07:30:51 <lambdabot> * -> * -> *
07:31:17 <jethr0> it's an arrow operator, instead you could write "(\x -> (mylength x, x))"
07:31:30 <SamK> ah ok
07:31:36 <jethr0> instead of "(mylength &&& id)"
07:31:53 <flux__> jethr0, wouldn't you in best case have a rule that rewrote sortBy.. to that zip-with-pair-version?
07:31:57 <palomer> gah, I haven't decided what I'm going to return in the end!
07:32:28 <jethr0> flux__: maybe
07:32:35 <palomer> TuringTest: do you still have the code handy?
07:32:45 <TuringTest> http://www.rafb.net/paste/results/BiRO4038.html
07:32:46 <jethr0> flux__: the sortby notation is so clunky and long
07:32:54 <TuringTest> palomer: so yes.
07:33:23 <flux__> jethr0, well, yeah, but I think so is the concept of needing to zip and unzip 'manually' too ;)
07:33:36 <palomer> oh, I can just shove any old type variable, right?
07:34:05 <jethr0> flux__: maybe you're right. that's why i gave both versions
07:34:16 <jethr0> SamK: does that help you any further?
07:34:20 <TuringTest> palomer: Into SType? Yes
07:34:44 <SamK> jethr0: Yes, thanks, just trying it out
07:34:45 <flux__> maybe sortOn criteria = sortBy (\x y -> compare (criteria x) (criteria y))..
07:35:12 <jethr0> flux__: would be nice to have in List...
07:35:46 <jethr0> flux__: because that's how you'd use sortBy almost always. at least i do
07:36:00 <palomer> TuringTest: no, into Env, if I'm not sure what it's going to be
07:36:09 <flux__> jethr0, that might actually be true for me too
07:36:15 <palomer> TuringTest: Env s a anyOldTypeVariable
07:36:26 <TuringTest> palomer: That is okay.
07:36:31 <palomer> does haskell have existential type annotations?
07:36:41 <TuringTest> yes...but you do not need them
07:36:51 <TuringTest> :t ask
07:36:57 <TuringTest> @type ask
07:36:58 <lambdabot> Not in scope: `ask'
07:37:02 <TuringTest> @type print
07:37:03 <lambdabot> forall a. (Show a) => a -> IO ()
07:37:13 <ski> @type Control.Monad.Reader.ask
07:37:14 <lambdabot> forall r (m :: * -> *).
07:37:14 <lambdabot> (Control.Monad.Reader.MonadReader r m) =>
07:37:14 <lambdabot> m r
07:37:17 <TuringTest> The forall is what Haskell has
07:37:38 <snk_kid> ~_^
07:37:49 <palomer> how do you write foo :: (exists t. a -> t) ?
07:37:56 <ski> no
07:38:36 <TuringTest> palomer: That type makes no sense
07:38:56 <TuringTest> You can write things like fromInteger
07:38:59 <TuringTest> @type fromInteger
07:39:00 <lambdabot> forall a. (Num a) => Integer -> a
07:39:04 <palomer> TuringTest: why not?
07:39:47 <ski> you could write in CPS .. fooK :: a -> (forall t. t -> o) -> o
07:40:20 <TuringTest> palomer: The "exists" as you mean it is implicit
07:41:34 <palomer> hmm?
07:41:59 <TuringTest> palomer: What are you actually trying to do?  Try writing it like before, without types, so I can see what  you want to do.
07:42:49 <palomer> this is a general question
07:43:02 <jethr0> @pl (\x -> x > minWt && x < maxWt)
07:43:02 <palomer> (I'm studying the stratified types paper, and they allow existentials in their annotations)
07:43:02 <lambdabot> liftM2 (&&) (> minWt) (< maxWt)
07:43:49 <jethr0> what is that lifting to?
07:44:01 <jethr0> @type liftM2 (&&) (> minWt) (< maxWt)
07:44:02 <lambdabot> Not in scope: `liftM2'
07:44:02 <lambdabot>  
07:44:02 <lambdabot> <interactive>:1:15: Not in scope: `minWt'
07:44:32 <ski> jethr0 : environment/reader monad, of course
07:44:46 <jethr0> how could i not see that :)
07:44:51 <ski> instance Monad (e ->)
07:45:42 <jethr0> so what's it do with "maxWt"?
07:45:50 <jethr0> ah, never mind
07:46:28 <TuringTest> palomer: GHC User's guide: http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/type-extensions.html#existential-quantification and http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/type-extensions.html#universal-quantification
07:47:22 <SamK> jethr0: mmm, I've written this expression to get the length of a 3D vector (a,b,c): (\(x,y,z)->sqrt(x*x+y*y+z*z))
07:47:37 <musasabi> SyntaxNinja: in Cabal the package manager should in configure action detect the list of packages present, yet there appears to be no information about the place designated for the package-install yet.
07:47:47 <flux__> samk, btw, for comparing lengths you can just drop the sqrt
07:47:57 <SamK> jethr0: but am having trouble inserting it in "map snd . sort . map (mylength &&& id)"
07:48:18 <jethr0> import Control.Arrow ((&&&))
07:48:38 <jethr0> otherwise it should work, and as flux__ says you can drop the sqrt in here
07:48:41 <flux__> add for instance "where mylength (x, y, z) = sqrt..."
07:49:04 <int-e> @type Data.List.sortBy
07:49:05 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
07:49:22 <jethr0> SamK: it's faster than "sortBy (\x y -> compare (mylength x) (mylength y))"
07:49:30 <musasabi> SyntaxNinja: how is one supposed to feed correct parameters to the package manager?
07:50:06 <jethr0> SamK: did you remember to pass the list of vectors as an argument?
07:50:15 <palomer> TuringTest: thx
07:50:47 <int-e> ah. it's faster because mylength is an expensive calculation. ok.
07:50:51 <palomer> @hoogle mapm
07:50:52 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:50:52 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:50:52 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:51:14 <jethr0> int-e: i'm not so sure. flux__ thought sortBy might be optimized internally
07:51:22 <SamK> jethr0: yes remembered the argument
07:51:23 <palomer> whoa, I got my program to typecheck, after 2 hours
07:51:26 <palomer> :)
07:51:32 <palomer> I learned a great deal though
07:52:05 <SamK> flux: not sure I understand, are you saying you dont need the sqrt when you say "you can just drop the sqrt"
07:52:06 <jethr0> SamK: :)
07:52:42 <jethr0> SamK: sqrt leaves ordering of positive numbers intact
07:52:43 <int-e> jethr0: I doubt that.
07:52:46 * Cale posts a comment on LWN too
07:52:56 <SamK> ah yeah, I get it
07:53:10 <palomer> @hoogle runlocal
07:53:11 <lambdabot> No matches found
07:53:14 <palomer> @hoogle local
07:53:15 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m
07:53:15 <lambdabot> a
07:53:15 <lambdabot> Distribution.Simple.Configure.LocalBuildInfo :: LocalBuildInfo
07:53:15 <lambdabot> Distribution.Simple.Configure.LocalBuildInfo :: FilePath -> Compiler ->
07:53:15 <lambdabot> FilePath -> [PackageIdentifier] -> Maybe FilePath -> Maybe FilePath ->
07:53:17 <lambdabot> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> LocalBuildInfo
07:53:22 <jethr0> SamK: therefor: "x<y   <=>  sqrt(x)<sqrt(y)" for all positive numbers
07:53:29 <SamK> clever
07:53:36 <jethr0> SamK: and sqrt doesn't make sense for negative real numbers
07:54:58 <palomer> is there a datatype with a single nullary constructor?
07:55:28 <Cale> ()
07:56:04 <palomer> oh, right, forgot about that one
07:56:20 * palomer wonders if Either a () is isomorphic to Maybe a
07:56:38 <SamK> not sure I explained myself properly, I want: [(5,6,7),(1,2,3),(4,5,6)] becomes [(1,2,3),(4,5,6),(7,8,9)].. i.e. find the length of each 3D vector (x,y,z) and then sort
07:56:49 <jethr0> palomer: probably not in strictness
07:56:58 <jethr0> or am i wrong?
07:57:15 <Cale> right
07:57:16 <jethr0> is there a _|_ for ()
07:57:21 <Cale> there is
07:57:21 <ski> yes
07:57:47 <jethr0> SamK: i understood, what's the problem?
07:57:49 <Cale> so in Either a (), you have Right () and Right _|_, as well as Left x for any x :: a
07:58:20 <Cale> oh, and _|_ too
07:58:59 <SamK> well, being each 3D vector is 3 components, x,y,z how can you sort them by length without sqrt
07:59:26 <jethr0> SamK: you sort by length^2
07:59:42 <jethr0> SamK: which results in same ordering as sorted by length (for positive numbers)
08:01:08 <SamK> got it, sorry momentary lapse of brain function ;)
08:01:14 <jethr0> np
08:02:29 <palomer> @hoogle isLeft
08:02:30 <lambdabot> Graphics.HGL.Window.isLeft :: Event -> Bool
08:02:30 <lambdabot> Graphics.SOE.isLeft :: Event -> Bool
08:02:30 <lambdabot> Graphics.HGL.Key.isLeftKey :: Key -> Bool
08:02:48 <palomer> @hoogle left
08:02:49 <lambdabot> Control.Arrow.left :: ArrowChoice a => a b c -> a (Either b d) (Either c
08:02:49 <lambdabot> d)
08:02:49 <lambdabot> Data.Either.Left :: a -> Either a b
08:02:49 <lambdabot> Prelude.Left :: a -> Either a b
08:03:40 <ihope_> isLeft (Left _) = True; isLeft (Right _) = False?
08:03:48 <palomer> @hoogle Maybe a -> a
08:03:49 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
08:03:49 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
08:03:49 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
08:04:02 <ihope_> @djinn Either a b -> Bool
08:04:03 <lambdabot> f a =
08:04:03 <lambdabot>   case a of
08:04:03 <lambdabot>   Left _ -> False
08:04:03 <lambdabot>   Right _ -> True
08:04:12 <ihope_> Hmm.
08:04:18 <ihope_> @djinn [a] -> Bool
08:04:19 <lambdabot> f _ = False
08:04:22 <ihope_> :-P
08:04:44 <ski> @djinn Either a (Either b c) -> Bool
08:04:45 <lambdabot> f a =
08:04:45 <lambdabot>   case a of
08:04:45 <lambdabot>   Left _ -> False
08:04:45 <lambdabot>   Right b -> case b of
08:04:45 <lambdabot>      Left _ -> False
08:04:47 <lambdabot>      Right _ -> True
08:07:53 <ihope_> @djinn Either (Either a b) (Either c d) -> Either Bool Bool
08:07:54 <lambdabot> f a =
08:07:54 <lambdabot>   case a of
08:07:54 <lambdabot>   Left b -> case b of
08:07:54 <lambdabot>      Left _ -> Left False
08:07:54 <lambdabot>      Right _ -> Left True
08:07:56 <lambdabot>   Right c -> case c of
08:07:58 <lambdabot>      Left _ -> Left False
08:08:00 <lambdabot>      Right _ -> Left True
08:08:50 <ihope_> @djinn [a] -> Either () (a,[a])
08:08:50 <lambdabot> f _ = Left ()
08:10:11 <palomer> Cale: so what did people think of your proposal to use equality in patterns?
08:11:34 <zce> @hoogle Char->Int
08:11:35 <lambdabot> Data.Char.digitToInt :: Char -> Int
08:11:35 <lambdabot> Data.Char.ord :: Char -> Int
08:11:35 <lambdabot> Text.Regex.Posix.regExtended :: Int
08:12:49 <Cale> palomer: It didn't receive too many comments either way
08:13:21 <palomer> I'm only worried about the bugs it will cause
08:13:28 <palomer> I mean sometimes I put the same variable twice in a pattern
08:13:34 <palomer> by mistake
08:13:39 <Cale> yeah, that could be an issue
08:13:48 <palomer> maybe if we marked the equality variables with a symbol
08:13:52 <palomer> like & or something
08:13:55 <Cale> also, it's quite difficult syntax-wise
08:14:11 <Cale> well, parts of it
08:14:35 <Cale> because if you're treating some parameters as expressions, which ones?
08:14:50 <Cale> it adds some context sensitivity
08:18:59 <JohnMeacham> kosmikus: no. not that I know of.
08:19:35 <palomer> http://www.rafb.net/paste/results/DwZONS27.html
08:19:37 <kosmikus> so, I should cite the webpage if I want to refer to it? there's no "standard document"?
08:19:45 * palomer got his library to purchase "craft of functional programming"
08:20:02 <palomer> Cale: the s is escaping, but where?
08:20:36 <jethr0> is there an opposite function to "null"?
08:20:52 <Cale> palomer: write a type signature for blah
08:21:04 <Cale> not . null
08:21:37 <palomer> Cale: oh, very clever
08:21:44 <jethr0> Cale: i mean inbuilt :)
08:22:00 <jethr0> but i guess it's not necessary
08:22:44 <Cale> palomer: it sure looks like it's returning an 's'
08:23:09 <Cale> but I don't have the definition of Env handy
08:24:31 <palomer> Cale: it is returning an s
08:24:36 <palomer> that's why I said "very clever"
08:24:46 <Cale> :)
08:24:48 <kosmikus> kosmikus: JohnMeacham ^^
08:26:07 <ski> Cale : nonlinear use of vars in pattern invoking '(==)' ?
08:26:59 <palomer> my algorithm is shaping up!
08:27:04 <Cale> ski: f x x = x; f _ _ = 0 would be equivalent to f x y = if x == y then x else 0
08:27:29 <ski> Cale : right
08:27:30 <orbitz> is there an efficient means of shuffling a list?
08:27:52 <Cale> ski: basically, if variables occur in patterns which have been bound earlier, then they're turned into equality testing
08:28:40 <ski> ok, like in erlang, then
08:28:45 <Cale> orbitz: there are some hanging around
08:29:20 <Cale> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
08:29:27 <TuringTest> type SType s a = (STRef s a)
08:30:32 <palomer> @hoogle [(a,b)] -> [(b,a)]
08:30:33 <lambdabot> No matches, try a more general search
08:31:13 <palomer> @type map (\(a,b) -> (b,a))
08:31:14 <lambdabot> forall a b. [(a, b)] -> [(b, a)]
08:31:27 <palomer> @hoogle flip
08:31:28 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
08:31:45 <palomer> @hoogle (a,b) -> (b,a)
08:31:46 <lambdabot> No matches, try a more general search
08:32:03 <palomer> @hoogle lookup
08:32:04 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
08:32:04 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
08:32:04 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
08:32:11 <ski> @type uncurry (flip (,))
08:32:12 <lambdabot> forall a b. (a, b) -> (b, a)
08:32:35 <ski> @type snd Control.Arrow.&&& fst
08:32:35 <lambdabot> forall a b. (a, b) -> (b, a)
08:39:13 <palomer> @type Control.Arrow.&&&
08:39:14 <lambdabot> parse error on input `Control.Arrow.&&&'
08:39:22 <palomer> @hoogle (&&&)
08:39:22 <lambdabot> No matches found
08:39:29 <palomer> !!!
08:39:34 <ski> @type (Control.Arrow.&&&)
08:39:34 <lambdabot> forall (a :: * -> * -> *) c' c b.
08:39:34 <lambdabot> (Control.Arrow.Arrow a) =>
08:39:34 <lambdabot> a b c -> a b c' -> a b (c, c')
08:39:39 <jethr0_> palomer: Control.Arrow
08:39:57 <palomer> @type Control.Arrow
08:39:58 <lambdabot> Couldn't find qualified module.
08:39:58 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
08:39:58 <lambdabot> \\)?
08:39:59 <jethr0_> but those signature need getting used to :)
08:42:24 <vincenz> dons: ping
08:50:35 <jethr0_> @type onClick
08:50:36 <lambdabot> Not in scope: `onClick'
08:52:16 <Cale> @hoogle (a -> Bool) -> m a -> m a
08:52:17 <lambdabot> No matches, try a more general search
08:55:43 <lambdabot> No matches, try to start a fire some other way.
09:27:12 <dons> vincenz?
09:27:53 <jethr0> yes dons :)
09:28:15 <jethr0> anyone have tried cairo around here?
09:31:28 <wolverian> I have, but I guess you mean the Haskell bindings..?
09:35:06 <jethr0> wolverian: not necessarily.
09:35:37 <jethr0> i am drawing to a gtk canvas and was wondering how to cache part of my cairo graphic for speedup
09:41:35 <jethr0> bad net day, huh?
09:52:26 <jethr0> anyone here?
09:52:55 <ralejs> Yeh, I'm here.
09:54:32 <jethr0> yeah
09:54:39 <jethr0> let's have a netsplit party
09:55:36 <ralejs> A what?
09:56:12 <jethr0> never mind. i was just wondering where everyone went...
09:56:23 <ralejs> right...
10:03:01 <ralejs> @type until
10:03:02 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
10:06:49 <musasabi> SyntaxNinja: ping
10:13:45 <jethr0> musasabi: i compiled gtk2hs from source and am now trying to profile a program linking against it. but the compile produced no profiling headers. any suggestions?
10:14:22 <SyntaxNinja> musasabi: y0
10:14:30 <dcoutts> jethr0, did you build gtk2hs with profiling on?
10:14:49 <jethr0> dcoutts: didn't find the switch.
10:15:20 <jethr0> ./configure --help didn't give one
10:15:28 <dcoutts> jethr0, I've never tried it but I'd suggest
10:15:48 <dcoutts> ./configure --with-hcflahs=<ghc prof flags>
10:15:54 <dcoutts> oops
10:16:00 <dcoutts> ./configure --with-hcflags=<ghc prof flags>
10:16:00 <musasabi> SyntaxNinja: hello, I am hacking jhc things for cabal and have some questions.
10:16:43 <musasabi> SyntaxNinja: If I want to use filenames instead of modulenames in Distribution.Simple.Build, where do I get those?
10:17:40 <SyntaxNinja> musasabi: I don't understand. the .cabal file has module names, so presumably you have to figure out the mapping of module names to file names
10:17:55 <dcoutts> jethr0, as for your other question about caching part of a cairo graphic for speedup, see the new cairo clock demo
10:18:08 <jethr0> cool
10:18:24 <musasabi> SyntaxNinja: but the preprocessing step already does that, and may change the facts.
10:18:45 <SyntaxNinja> musasabi: I don't understand what you're asking.
10:18:51 <dcoutts> jethr0, that demo does exactly that, it caches static elements of the animation and composites all the layers (dynamic & static) together each frame
10:19:35 <jethr0> dcoutts: using pixbuf? where do i find this demo?
10:20:25 <dcoutts> it's linked from here: http://haskell.org/gtk2hs/archives/2006/01/26/cairo-eye-candy/
10:20:46 <dcoutts> jethr0, it uses cairo image surfaces rather than pixbufs
10:21:10 <dcoutts> cairo image surfaces and pixbufs are more or less the same though
10:21:20 <dcoutts> though the pixel format is different
10:21:36 <jethr0> thx
10:23:28 <jethr0> dcoutts: another question. i've got a gtk2hs application which will go into the next state on the push of a button.
10:23:38 <dcoutts> right
10:23:55 <jethr0> dcoutts: and now i would like to add a toggleButton or similar to let it advance by itself
10:24:01 <jethr0> in a certain period
10:24:17 <dcoutts> using a timer/timout perhaps?
10:24:27 <jethr0> so, i guess i need an event source and somehow pass that depending on the button state
10:24:38 <jethr0> yes, or so
10:25:06 <musasabi> SyntaxNinja: I was looking for a builtin way of getting the filenames of the modules, but seems like I have to do it in a normal way.
10:25:07 <jethr0> so, i build a timer, query state of toggle button and then send an event
10:26:06 <jethr0> dcoutts: re profiling. i don't know the ghc flags to create debug-able libraries (.p_hi)...
10:26:57 <dcoutts> jethr0, oh they have to have a different extension? hmm I don't think our build system will cope with that.
10:27:56 <jethr0> i don't know much about all that. just that i'm lacking profiling library versions *g*
10:29:01 <int-e> dcoutts: what do you think of providing a createSimilarSurface? the purpose would be the same as createImageSurface but cairo would get the chance to use, say, a pixmap, where appropriate.
10:29:53 <dcoutts> int-e, yeah it's an obvious one to do given that we've now got createImageSurface
10:30:07 <SyntaxNinja> musasabi: yeah. ghc and hugs both allow me to pass the module name, and they'll worry about finding the files.
10:30:46 <musasabi> oh well, jhc can do that under the hood, just need a way communicate it on the command line.
10:33:28 <dons> musasabi, did you see we're ranked 1 on the shootout :)
10:33:45 <SyntaxNinja> dons: that's awesome. you should tell slashdot :)
10:33:57 <SyntaxNinja> dons: a surefire way to change our ranking, but still.
10:34:05 <dons> hehe
10:34:40 <jethr0> how's the syntax in haskell/ghc to ifdef a region out?
10:34:52 <dons> {- -}
10:36:05 <jethr0> dons: no, i mean depending on compiler flags or sth
10:36:14 <dcoutts> int-e, done.
10:36:51 <int-e> heh. that was quick :)
10:37:10 <musasabi> dons: nice :-)
10:37:16 <musasabi> dons: what changed the balance?
10:37:37 <dons> a gcc entry was disqualified
10:37:41 <dcoutts> int-e, but you might want to darcs pull just that patch, there are some big changes in the tree view stuff that you might not want to pull
10:38:02 <dons> jethr0, you can use cpp.
10:38:08 <jethr0> ok
10:38:13 <dons> Add -cpp to ghc, and then go nuts, if thats what you want.
10:38:32 <jethr0> i thought there was an inbuilt thingey
11:13:16 <jethr0> @hoogle getArgs
11:13:17 <lambdabot> System.Environment.getArgs :: IO [String]
11:13:17 <lambdabot> Graphics.UI.GLUT.Initialization.getArgsAndInitialize :: IO (String, [
11:13:17 <lambdabot> String])
11:19:25 <musasabi> Why is there no unzipWith :: (a -> (b,c)) -> [a] -> ([b],[c]) ?
11:19:43 <musasabi> of course one can compose that from map and unzip.
12:36:04 <icbt> @seen lemmih
12:36:04 <lambdabot> I saw lemmih leaving #haskell-blah and #haskell 5 days, 11 hours, 13
12:36:04 <lambdabot> minutes and 39 seconds ago, and I have missed 4 seconds since then.
12:54:22 <elk> @seen waern
12:54:23 <lambdabot> I saw waern leaving #haskell 4 hours and 42 minutes ago.
12:56:40 <elk> so is hide being developed with ghc 6.5 now ?
13:02:58 <elk> any hide hackers around ?
14:25:03 <sethk> ghc 6.5 isn't released yet, is it?
14:28:07 <Korollary> I dont think so
14:28:45 <sethk> Korollary, hey.  going out to Seattle again on Sunday or Monday.
14:31:55 <araujo> Hello all.
14:34:14 <Korollary> cool
14:34:29 <Korollary> I bought my third umbrella recently
14:35:25 <sethk> Korollary, do they wear out?
14:35:39 <Korollary> no, they broke in the wind
14:36:10 <lispy> so the first monad law is:(return x) >>= f == f x, but shouldn't that be (return x) >>= f == return (f x) ?
14:36:55 <joelk> f :: a -> m a, right?
14:37:29 <lispy> hmm...i dont' see that, but it sounds familiar
14:37:39 <joelk> @type (>>=)
14:37:40 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
14:38:21 <lispy> > return 1 >>= (+1)
14:38:23 <lambdabot>  add an instance declaration for (Num (m b))
14:38:46 <Roboguy> lispy: It works if f :: a -> m a
14:39:12 <lispy> > (return 1) >>= \x -> [x]
14:39:13 <lambdabot> [1]
14:39:20 <Roboguy> @type (+1)
14:39:20 <lambdabot> forall a. (Num a) => a -> a
14:39:21 <lispy> > \x -> [x] 1
14:39:22 <lambdabot>   The function `[x]' is applied to one arguments,
14:39:22 <lambdabot>   but its type `[a]' has none
14:39:22 <lambdabot>   In a lambda abstraction: \ x -> [x] 1
14:39:33 <lispy> > (\x -> [x]) 1
14:39:35 <lambdabot> [1]
14:39:44 <lispy> alright, if f :: a -> m a then yes, i agree
14:57:19 <lispy> i feel like laziness needs more research
15:08:38 <Cale> lispy: that's what Haskell is for :)
15:11:42 <lispy> Cale: yeah, but if i need to do "real" work i feel like i need to leave haskell (and all it's wonder) behind
15:11:58 <lispy> if i need to prototype something or do some homework then haskell is perfect...
15:12:11 <Cale> You can certainly use Haskell for real work
15:12:57 <Cale> It was originally created to further research in lazy languages, but I find it quite practical anyway
15:13:07 <Cale> what kind of applications are you thinking about?
15:13:46 <lispy> it seems like all the "real" work i need to do involves large datasets, and haskell is weak with those.
15:14:09 <Cale> It's great with large datasets, laziness can help quite a lot with them
15:14:13 <lispy> i'm trying to get into graphics/animation for research and at work i deal with simulations and large models
15:14:53 <lispy> darcs uses laziness to deal with large datasets and it's a mess to debug and it doesn't work out.  Plus anytime someone changes some core code we have to figure out if things are still lazy enough
15:15:27 <blackdog> hello my peeps. long time no typey.
15:15:28 <Cale> Well, yeah, laziness can be important to performance.
15:15:35 <lispy> laziness is unpredictable and when performance is key that's hard to deal with
15:16:02 <Cale> Well, it can also let you do things which you wouldn't otherwise be able to attempt.
15:16:31 <lispy> yeah, and that's really nice for prototyping or when you're working on homework where performance is often not that improtant
15:17:16 <Cale> Well, I found that it was quite nice when I was writing my pipeline scheduler
15:18:04 <lispy> in the case of darcs, i'm trying to develop a case for getting rid of the lazy patch reading and replacing it with bounded buffers, but i know it will be resisted (for good reasons) but i don't see anyway darcs will get better without explicit memory controls
15:19:20 <blackdog> lispy: is the prob that darcs occasionally goes off into the never-never?
15:19:27 <Cale> Why would you want to defeat laziness? I find it's usually the case that you want to improve laziness, rather than remove it altogether.
15:20:05 <Cale> Sometimes if things aren't being garbage collected soon enough, then strictness can be an answer, but you can also fix the problem by getting the data to be produced later.
15:20:09 <blackdog> yeah - you want to be as strict as possible without computing unnecessary stuff...
15:20:28 <Cale> blackdog: sort of
15:20:47 <blackdog> well, if you know you'll need it, why build a thunk?
15:20:51 <Cale> which usually means being quite lazy
15:21:06 <lispy> 1) everytime we change code that works with patches we'll have to retest all the known cases where laziness is needed, 2) if there is a problem it's hard to track down 3) we need some garantees
15:21:07 <Cale> often you can't know that you'll need it
15:21:47 <Cale> lispy: okay, then maybe restructure the code to make sure that laziness will be preserved more easily
15:22:06 <blackdog> Cale: which is generally the crux of the problem, yes.
15:22:30 <lispy> Cale: how?
15:23:25 <Cale> like, make sure that there are good places to plug in extra processing without damaging laziness -- usually elementwise maps. I don't actually know the code, so I'm not sure what kind of structure would be good
15:24:25 <Cale> How is the patch handling code structured, and why is it fragile?
15:25:12 <Cale> Usually you can tell when something breaks laziness because it causes the algorithm to need more than the start of the input to produce any output.
15:25:20 <lispy> i don't know how to answer the first part, but it's fragile because it's easy to work with too much of a patch at once.  To be honest, it might not be the patch manipulation code, it might be the patch reading code.  It's just really hard to tell.
15:25:52 <Cale> If that amount can be bounded to a few elements, you can make sure that the whole thing runs smoothly.
15:27:03 <Cale> right, okay, so you need to break up patches better and make sure that the point at which it swaps from handling the breaking up process to handling each individual part is clearly separated
15:27:25 <Cale> so that the code which handles one little part doesn't have access to the rest of the stuff
15:27:42 <Cale> (and can't harm the laziness by reading more than it should)
15:27:52 <lispy> that sounds like the stuff Igloo did
15:28:28 <lispy> but i think this demonstrates one of the problems i mentioned.  It's hard to tell when things are lazy enough
15:28:44 <Cale> nah, you just need to think about it the right way
15:29:23 <Cale> At each stage, you think about the first part of the output and ask "What part of the input do I need to compute this?"
15:29:41 <joelk> dons, please check the nbody haskell wiki page. I put up my stuarray version, which is faster on my machine. I have to step out for a bit now. thanks
15:29:55 <Cale> if the answer is "all of it" (for example, if you sort the input) that's bad
15:30:31 <Cale> (well, it's bad if the input to that stage is large)
16:11:50 <shapr> g'day blackdog 
16:13:04 <blackdog> hey shapr
16:13:39 <blackdog> off to a meeting - see you later
16:13:45 <lispy> bye
16:15:15 * araujo wonders if 26 letters are Ok for a function name
16:16:12 <Cale> abcdefghijklmnopqrstuvwxyz = ...
16:16:34 <araujo> Yeah, like that :-]
16:17:28 <dons> > let abcdefghijklmnopqrstuvwxyz x = x in abcdefghijklmnopqrstuvwxyz ()
16:17:29 <lambdabot> ()
16:17:37 <dons> yeah, it's ok :)
16:18:29 <lispy> > let abcdefghijklmnopqrstuvwyz x = "abcdefghijklmnopqrstuvwxyz" in abcdefghijklmnopqrstuvwyz "x"
16:18:31 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
16:18:44 <araujo> I just like to write functions names that forms a statement with the args, like, task1 `isProcessedWithColor` Blue
16:19:33 <lispy> araujo: that's really confusing code.  Fortran has taught me that that, call IPWC(it1, ib) is much easier to read
16:19:59 <lispy> actually, i forgot all the obligatory line numbers
16:20:19 <lispy> 1010 call IPWC(it1, ib, err=1299)
16:20:22 <lispy> there, that's better
16:20:47 <lispy> none of this hard to read english looking code
16:20:53 <shapr> I wish keyboards had a better way to enter unicode chars.
16:21:11 <shapr> Maybe if chars were compositional... does CJK work that way?
16:21:26 <lispy> shapr: oh next you'll be hugging trees and celebrating multicultural holidays.  Geez.  ascii is all the rage.
16:22:21 <lispy> > write(msg, *) "Fortran Rules"
16:22:22 <lambdabot>  parse error on input `*'
16:22:32 <shapr> I hugged a tree once, and multicultural holidays here are flat out hedonistic.
16:22:42 <lispy> shapr: awesome
16:24:00 <lispy> why is that * a parse error?
16:24:04 <lispy> > (+, *)
16:24:05 <lambdabot>  parse error on input `,'
16:24:15 <lispy> oh, right it needs parens
16:24:31 <lispy> > write(msg, (*)) "Fortran Rules"
16:24:32 <lambdabot>  Not in scope: `msg'
16:28:10 <araujo> lispy,  smalltalk taught me the opposite :-P
16:28:51 <lispy> fortran > * ;)
16:31:12 <mfgl> Do you care if I ask you about a memory leak that has been tormenting me for five days in a row?
16:31:28 <mfgl> I've tried to fix it but I don't know why.
16:31:53 <araujo> mfgl, what's up?
16:32:09 <JohnMeacham> musasabi: jhc can do that, just specify --main Foo.main and it will find it. 
16:32:33 <araujo> lispy, you should nickname yourself fortrapy instead :-P
16:32:42 <mfgl> I've been trying to make a simple program to map (+1) to a mutable array several times.
16:33:01 <mfgl> But the program seems to copy the whole array in each step.
16:33:35 <JohnMeacham> musasabi: at least it should. I intended you to just use a module on the command line or a file.
16:33:36 <mfgl> If I pass STUArray s Int Int  to a function, I'm passing the whole array to the function?
16:34:33 <JohnMeacham> musasabi: if I understand what you want properly...
16:34:39 <mfgl> or STUArray is something like a "pointer" to the mutable array.
16:37:54 <Cale> mfgl: things are pretty much always passed like pointers
16:38:48 <Cale> Even in the case of unboxed arrays, the arrays as a whole are boxed, and won't be evaluated until needed (the unboxing means that their elements will all be evaluated when they are though)
16:40:56 <mfgl> Cale: I see. The program is a toy to understand mutable arrays, so I make sure that I use all the entries of the array.
16:41:36 <Cale> You're not even really passing a pointer to the array itself, but to code which will either compute the array, or return the already computed array in the case that it's been computed.
16:44:15 <mfgl> Using the ST monad, could I make a monadic code that only works on the array, without duplicating it? For example, maping the array into itself?
16:44:54 <Cale> yep, that's what all the stuff in MArray is for
16:45:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
16:46:40 <mfgl> Yes, I was using that page as inspiration, together with some fine papers by Symon P. Jones, but somehow the code is still leaking memory.
16:48:30 <mfgl> I think it doen't matter. I will eventually find out what I'm doing wrong. Thanks for the help :) .
16:48:56 <Cale> If you'd like I could take a look
16:50:26 <mfgl> I've pasted my ST version of mapArray in http://rafb.net/paste/results/zaGYwt57.html .
16:50:51 <mfgl> But please don't bother yourself too much with it.
16:51:36 <dons> mfgl, you might be interested in some fast array code I wrote today: http://www.haskell.org/hawiki/SpectralEntry
16:51:53 <lispy> araujo: hehe
16:52:34 <mfgl> dons: Thankyou, good example code is the best advice I could ask for.
16:52:54 <dons> using unsafeRead and unsafeWrite are much faster, as you avoid the bounds checks that normally occur. Also, your 'mfor' probably leaks. Try adding some `seq`s to get ghc to unbox the loop.
16:54:03 <Cale> hmm, I'd make n the last parameter of update, since it's the one most often changing
16:54:49 <Cale> then you could implement nfor as mapM (update a f) [0..n]
16:55:25 <dons> good idea
16:55:28 <lispy> i love that about haskell
16:55:34 <dons> mapM_ even better.
16:55:40 <Cale> yeah, mapM_
16:55:47 <dons> you get a very nice loop from ghc out of mapM_
16:56:56 <dons> mfgl, also this is an interesting read: http://www.haskell.org/pipermail/glasgow-haskell-bugs/2005-March/004814.html
16:57:06 <shapr> lispy: Will you become Haskelly? ;-)
16:57:26 <dons> he should, he spends so much time around here ;)
16:57:29 <lispy> or maybe i'll generalize to lambdy
16:57:38 <shapr> Oh I like that.
16:57:52 <shapr> We can call you Alonzo.
16:58:00 <lispy> heh
16:58:05 * shapr wants to go to the matresses with those imperative guys.
16:58:22 <shapr> 'mattress'
16:58:24 * lispy tries not to misinterpret that
16:58:26 <shapr> yeesh
16:58:55 <shapr> lispy: C'mon, you've seen The Godfather?
16:59:02 <lispy> no i haven't :(
16:59:12 * lispy doesn't watch much on a TV
17:00:05 <shapr> Nor do I, but it's worth watching the top rated 100 or 250 movies rated on the IMDB.
17:00:34 <lispy> hmm...good call, my gf just joined netflicks and asks what to rent
17:00:40 <lispy> i'll pass on that advice
17:00:41 <shapr> For two reasons, first it's decent entertainment, and second, most humans consider those movies so much a part of the shared culture they're necessary vocabulary.
17:02:28 <shapr> After years of being an alien, I have learned a few useful tricks to blend in...
17:02:28 <Korollary> it's mandatory education
17:02:28 <Korollary> I quote Office Space constantly
17:02:28 <shapr> I still haven't seen it.
17:02:28 <shapr> I quote TaPL though...
17:02:57 <Korollary> not in mixed company
17:03:29 <dons> is that the american version of The Office?
17:03:47 <Korollary> no, it's a movie. Although, there's an american version of that show as well.
17:04:02 <Korollary> the movie predates the british tv show iirc.
17:05:31 <TheHunter> wtf? *All* pattern and variable bindings are monomorphic unless a type signature is given. How come everybody thinks that's a good idea?
17:06:05 * lispy doesn't even know what it means
17:06:06 <Cale> TheHunter: not everybody thinks that's a good idea
17:06:12 <Cale> I'm opposed to it
17:06:24 <TheHunter> I'm *strongly* opposed to it.
17:06:29 <Cale> actually, the push is more for removing the MR altogether now
17:06:33 <lispy> is it open to debate with Haskell'?
17:06:46 <TheHunter> I like Hughes' original proposal
17:06:48 * TheHunter ducks.
17:06:59 <Cale> I don't
17:07:11 <TheHunter> I've always been hating inadvertent sharing.
17:07:16 <Speck> it's M-R important for optimizations in implementations (that have it)
17:07:30 <Speck> s/it's/isn't + ? at the end
17:07:41 <Cale> MR is a good as a compiler option or pragma.
17:07:54 <Cale> I don't see it as an essential part of the language.
17:08:17 <Cale> a smart enough compiler/runtime could deal with the problems with sharing in another way
17:08:27 <TheHunter> the MR aside, there is some benefit in seperating call-by-name and call-by-need.
17:09:03 <Speck> I still need to read Haskell is not ML, but it looks interesting
17:09:41 <TheHunter> compiler options altering the semantics of programs are a bad idea.
17:09:59 <Speck> sorry I'm so tired I'm just one big non sequitur -- I'm going to bed
17:11:48 <lispy> geez, vim is slow at text processing :)
17:11:55 <Cale> I think that types should be inferred as polymorphic as possible. Let people specify when they want more restrictive types.
17:12:01 <lispy> wish i had yi on this machine
17:13:11 <TheHunter> I think the question whether something is shared shouldn't be decided by type annotations.
17:13:41 <Cale> well, it must be, in many cases
17:14:02 <Cale> unless you want to make certain kinds of polymorphism impossible altogether
17:14:28 <TheHunter> it can probably alter the semantics.
17:15:20 <Cale> TheHunter: did you see my suggestion?
17:15:39 <TheHunter> No, I'm still catching up.
17:17:33 <Cale> The idea is that whenever you have potential loss of sharing, add a memo map from instances/types at which the value has been computed to final values, so that sharing can be restored in the cases where it's possible.
17:18:09 <Cale> Of course, you'd want the values of that map to expire and be garbage collected separately.
17:18:45 <Cale> So you keep polymorphism and sharing at the same time.
17:19:11 <eivuokko> Such magic is disgusting, imo.
17:19:11 <TheHunter> oh, yes, I read that. I'm not sure I like it though.
17:19:19 <Cale> why?
17:19:28 <Cale> It's just an optimisation
17:19:41 <Cale> and the semantics remain nice
17:19:44 <eivuokko> It is not very clear when it's optimisation and when not
17:20:09 <eivuokko> And it certainly is a dark corner, hard to understand when trying to optimise something or finding possibly related bug etc..
17:20:10 <Cale> the memo table should only hang onto things as long as they'd be held on to anyway
17:20:42 <TheHunter> doesn't everything have to know it's own time during runtime, then?
17:20:48 <TheHunter> *type*
17:21:14 <Cale> you're passing dictionaries anyway
17:21:26 <Cale> you give each dictionary a key
17:21:45 <Cale> hmm
17:22:24 <Cale> determining when to remove entries might be a bit of an issue. I suppose that if the values in the map were just weak pointers, it ought to be fine.
17:22:30 <eivuokko> Dictionaries have (fairly) dependable runtime complexity and implementation.
17:23:10 <Cale> well, they don't, since you end up with this problem with type signatures changing the runtime complexity of code. This would remove that problem.
17:24:21 <Cale> and we wouldn't need the M-R
17:24:50 <Cale> anyway, there are likely other clever methods of implementing typeclasses which also don't suffer from these sharing problems.
17:25:25 <Cale> full-program optimisation would surely be able to catch this
17:29:02 <TheHunter> this just calls for space-leaks.
17:29:16 <Cale> how?
17:30:00 <TheHunter> when do you want to garbage collect the result of a top-level binding?
17:32:11 <TheHunter> it seems you can't as long as there is still some dictionary of that type lurking around somewhere.
17:33:41 <TheHunter> And it's hard enough to get around sharing already.
17:33:52 <Cale> when are monomorphic top-level bindings currently GC'd?
17:34:17 <Cale> (in GHC)
17:34:42 <TheHunter> i guess if there's no pointer to them left.
17:34:58 <joelk> dons, I see your comment on the wiki nbody page. Bummer. What flags did you use?
17:35:26 <Cale> we just make the pointers in the memo table weak, so that they don't count toward the GC count
17:36:12 <TheHunter> but then we might end up recomputing the value.
17:36:34 <Cale> not any more than we'd recompute a monomorphic value, no?
17:37:23 <TheHunter> we never recompute the monomorphic value.
17:37:27 <Cale> right
17:38:49 <TheHunter> Anyway, there are situations where you don't want any sharing.
17:39:01 <Saulzar> What is sharing exactly? Polymorphic values (not functions)?
17:39:42 <Cale> Saulzar: let x = 1 + 1 in x + x
17:39:43 <TheHunter> Say, you want to traverse all the permutations of [1..n] simultaneously and at different speeds (or even allow forking).
17:39:55 <Cale> Saulzar: how many times should + get called?
17:40:04 <TheHunter> that's a huge pain in the ass right now.
17:40:31 <Saulzar> Hmm, 3? (I am guessing that is not the answer)
17:40:45 <Cale> Saulzar: 3 is the answer if there's no sharing
17:41:05 <Korollary> it's the same x. Why not two?
17:41:52 <Cale> with sharing, the x's in x + x are pointers to the same thing
17:42:09 <TheHunter> hmm, apart termination/non-termination, sharing should not effect semantics.
17:42:11 <MarcWeber> Hi lispy!!
17:42:36 <jethr0> how do i (round (x/y)) with x,y :: Integer?
17:42:46 <jethr0> sry, ceil(x/y)
17:43:07 <Cale> ceiling (fromIntegral x / fromIntegral y)
17:43:09 <Saulzar> convert them with fromIntegral 
17:43:33 <TheHunter> - ((-x) `mod` y)
17:44:05 <jethr0> thx
17:44:26 <TheHunter> using floating-point-computations will probably give you the wrong result in some cases
17:44:34 <Cale> TheHunter: `div`
17:44:50 <TheHunter> thx, of course.
17:46:10 <Korollary> if x & y are integers, actually the floating point result could be always accurate.
17:46:28 <Korollary> but I dont remember enough about that stuff
17:47:00 <Korollary> the integer version surely is better
17:48:07 <TheHunter> > ceiling (fromIntegral (-1) / fromIntegral 1)
17:48:08 <lambdabot> -1
17:48:33 <TheHunter> > -((-(-1)) `mod` 1)
17:48:34 <lambdabot> 0
17:48:47 <TheHunter> sorry...
17:49:10 <Cale> > -((-(-1)) `div` 1)
17:49:11 <lambdabot> -1
17:49:18 <TheHunter> Prelude Debug.QuickCheck> test $ \(x::Int) y -> y /= 0 ==> -((-x) `div` y) == ceiling (fromIntegral x / fromIntegral y)
17:49:18 <TheHunter> OK, passed 100 tests.
17:50:00 <TheHunter> the integers qc comes up with are ridiculously small, tho.
17:50:34 <TheHunter> *generates, man my english sucks tonite.
17:50:56 <Saulzar> I guess one can always break it with overflowing the floating point numbers...
17:51:16 <Korollary> TheHunter: you're getting used to the overuse of informal american english
17:51:52 <Saulzar> > ceiling (fromIntegral (111111111111111111111111111) / fromIntegral 1)
17:51:53 <lambdabot> 111111111111111104952008704
17:52:00 <TheHunter> fwiw, m-w doesn't even flag the spelling 'tho' as informal
17:52:37 <Korollary> TheHunter: I saw "gotta" in a scrolling text line on tv tonight.
17:54:22 * Saulzar would not be supprised to see it every day
17:54:35 <TheHunter> hmm, "gotta" seems pretty informal (at least when not used in the first person)
17:55:25 <Korollary> It's weird that you criticized yourself, but I too try not to use "come up with" as much as possible. I'm sick of hearing it.
17:56:03 <TheHunter> I thought I just used it incorrectly in that context.
17:56:57 <Korollary> come up with = supply
17:57:07 <Korollary> so it was ok imho
17:58:00 <TheHunter> can things really come up with stuff (well, maybe figuratively, but personifying qc seems weird)?
17:58:01 <Cale> tho is actually a word in English in two ways, dating back to the 890's
17:58:29 <Cale> neither of which is associated too closely with though
17:58:42 <ncalexan> 890's?  Or 1890's.
17:58:53 <Cale> 890's
17:59:25 <ncalexan> That seems very precise.  How do we know?
17:59:40 <Cale> OED has a usage dating back that far
17:59:50 <TheHunter> what does it mean?
18:00:31 <Cale> One of them is "at that time", "after that", "upon that"/"thereupon", and various similar senses
18:01:06 <TheHunter> wow, OED subscriptions are expensive.
18:01:47 <Cale> the other is basically equivalent to "those", "they", "them"
18:02:02 <Cale> a plural of "that"
18:02:19 <TheHunter> Modern English?
18:02:29 <Korollary> not likely
18:02:30 <Cale> both senses are marked obsolete
18:03:20 <Korollary> I read somewhere that Shakespeare used some 15k words in his works, and 10k of them went obsolete.
18:04:36 <TheHunter> I'm such an idiot. I actually have access to the OED here. Should have checked that a long time ago.
18:04:47 <Cale> I wonder how many were invented by him? :)
18:06:22 * Korollary notices a pattern of self critique in TheHunter 
18:07:17 <joelk> Cale, a lot.
18:07:21 <joelk> :-)
18:08:38 <Korollary> "Firefox 1.5.0.1 ready to install"
18:16:32 <TheHunter> Damn, I gotta go to bed.
18:17:30 <TheHunter> good night, folks.
18:27:59 <Itkovian> yeah
18:58:44 <michaelw> hey there.  i am looking for a specific mutable array data structure which allows sharing.  i recall it was a functional pearl, but for the life of me, i cannot find it.  any ideas?
19:01:34 <nibro> dons: ping
19:01:56 <michaelw> the idea was IIRC something like this: an array keeps the bulk of the data, and a tree keeps the updates
19:02:14 <joelk> perhaps Data.Array.Diff
19:02:16 <ski> @index DiffArray
19:02:16 <lambdabot> Data.Array.Diff
19:02:17 <ski> ?
19:18:50 <jethr0> @seen vincenz
19:18:50 <lambdabot> vincenz is in #haskell. Last spoke 10 hours, 36 minutes and 1 second ago.
19:33:47 <araujo> I love Higher Order Functions!!!!!!!!!!!!!!!!!!!!!!!!!!!!
19:34:16 <michaelw> chill, dude
19:34:57 <shapr> I love 'em too!
19:34:57 <araujo> Wait.. im gonna do something first.......
19:35:06 <shapr> y0 michaelw, long time no see.
19:35:25 <michaelw> hi shapr
19:35:48 <shapr> Nice to see you're writing Haskell again :-) Weren't you doing ML or something else for awhile?
19:35:49 <michaelw> joelk: sounds like it, now i need to find the paper :)
19:36:12 * beelsebob_ joins the HOF lovin
19:36:21 <shapr> @google mutable array haskell sharing functional perl
19:36:23 <shapr> oops
19:36:23 <lambdabot> http://merd.sourceforge.net/pixel/language-study/various/mutability-and-
19:36:23 <lambdabot> sharing/
19:36:38 <shapr> @google mutable array haskell sharing functional pearl
19:36:39 <lambdabot> http://www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
19:36:58 * araujo goes and yells from his room's window to the neighbourhood "I love Haskell!"
19:37:01 <michaelw> shapr: nah, ML syntax is ugly like sin ;)
19:39:48 <dcoutts> JohnMeacham, I like your suggestion about how to resolve the issues of the comment syntax and the M-R! :-)
19:41:44 <dcoutts> @quote JohnMeacham There will also be a karaoke competition to determine the fate of the
19:41:44 <dcoutts>  monomorphism restriction.
19:41:45 <lambdabot> JohnMeacham There will also be a karaoke competition to determine the
19:41:45 <lambdabot> fate of the hasn't said anything memorable
19:42:08 <ski> use @remember
19:42:15 <dcoutts> @remember JohnMeacham There will also be a karaoke competition to determine the fate of the monomorphism restriction.
19:42:23 <dcoutts> ski, ta
19:42:33 <araujo> dcoutts!!!!
19:42:41 <dcoutts> araujo!!!!
19:43:15 <ski> HOF!!!!
19:47:08 <araujo> :-)
19:47:16 <araujo> Good morning everyone!
19:47:22 * araujo throws lambdas at everyone
19:47:29 * Itkovian catches
19:48:30 <Si\Uni> Does anyone know how to add more syntax to TH? (Other than adding it to Language.Haskell.TH.Syntax that is)
19:49:08 <jethr0> Si\Uni: what do you mean "add more syntax"?
19:50:22 <ski> hm, can TH do macro-like things ?
19:50:41 <Si\Uni> no, I want to add import alongside foreign import
19:51:32 <jethr0> ski: depends on what you mean by macro. you can't recognize new keywords with TH as far as i'm aware.
19:51:42 <jethr0> nor new abstractions
19:52:47 <Si\Uni> yes, so what parts of GHC need updating to add new syntax?
19:53:38 <ski> jethr0 : i mean being able to give normal haskell expressions as arguments to a TH function, so it can put the ASTs of those inside a bigger AST (and possibly also analyze and deconstruct those said argument ASTs)
19:54:39 <ski> jethr0 : i haven't looked at TH, but seems to recall one can splice in compile-time generated ASTs .. so i'm wondering if one can parameterize these with normal expressions
19:55:04 <jethr0> things that aren't written inside quasi-quotes can't easily be used. generally it's just a question of fitting Language.Haskell.Syntax to Language.Haskell.TH.Syntax.
19:55:23 <jethr0> then you could put any code parsable by Language.Haskell.Parser into TH and splice it back
19:55:30 <jethr0> or output as code again
19:55:51 <jethr0> ski: i'm not sure what you mean by "normal expressions"
19:56:27 <jethr0> you can do: $([|4 + $([3 -2])|])
19:56:35 <jethr0> so, splices/quasi-quotes are nestable
19:57:02 <ski> what would that expand to ?
19:57:15 <jethr0> 4 + (3-2)
19:57:36 <Si\Uni> so how does TH work? Does it use the pretty printer to output code and let GHC parse that or what?
19:57:51 <maitscha> somewhere I have read that functions in haskell are monadic. what does that mean?
19:57:56 <ski> so, it might be that what i'm after is just '$(foo [|...|])', then
19:58:12 <jethr0> technically i don't know. i think it interfaces with the GHC internals and presents them as a nice haskell data structure (i.e. an abstract syntax tree)
19:58:15 <ski> Si\Uni : i think it works on internal ASTs
19:58:35 <jethr0> then you can transform the tree, and pass it back to the compiler
19:58:45 <jethr0> ski: yes, you can write haskell code that transforms the tree
19:58:52 <ski> maitscha : generally, functions in haskell don't need to be monadic
19:58:59 <jethr0> http://www.haskell.org/hawiki/TemplateHaskellTutorial
19:59:35 <ski> maitscha : a function is called monadic if it's type is of form 'Foo -> Bar -> ... -> M Baz', where 'M' is a monad
19:59:35 <Si\Uni> because if it interfaces with the GHC internals, surelys there's more to be done that just updating Language.Haskell.TH?
20:00:05 <jethr0> if you want to change TH per se, you might have to delve pretty deep in evil GHC internals
20:00:19 <jethr0> although i haven't understood why you'd have to do so?
20:00:49 <maitscha> hmmm.... is it something beeing related with the fact, that the function constructor -> is right associative?
20:01:13 <Si\Uni> Because I want to be able to splice native imports
20:01:22 <ski> jethr0 : it seems Si\Uni want to extend syntax .. i.e. not just use TH splicing etc
20:01:33 <Si\Uni> correct
20:02:07 <jethr0> ya, i'm not so sure that's a good idea. but maybe it's feasible with TH. i haven't look at its inner workings
20:02:18 <ski> maitscha : more or less, if the type of the "result" of a function is of form 'M Baz', with 'M' a monad, then the function is monadic
20:02:27 <jethr0> Si\Uni: what kinds of syntax features do you want to add?
20:02:36 <Si\Uni> import
20:02:51 <ski> maitscha : haskell functions usually take arguments in a curried way, instead of in a tuple (/"argument-list")
20:02:54 <jethr0> Si\Uni: i don't even know how well TH handles import
20:02:57 <Si\Uni> as a new declaration constructor
20:03:16 <Si\Uni> well at the moment it doesn't handle it at all, as it isn't in the syntax...
20:03:23 <Si\Uni> but it does handle foreign import
20:03:58 <ski> that's not quite similar thing, yes ?
20:04:29 <ski> 'foreign import' always specifies what is being imported .. a plain 'import' need not
20:08:30 <Si\Uni> I don't know, I've never used foreign import
20:09:26 <Si\Uni> Although yes, the syntax for import is somewhat different. But I'm not sure why that should matter
20:09:46 <Si\Uni> All it has to do is splice a declaration into the syntax tree
20:14:01 <Si\Uni> The other thing is, is anyone around who knows how the Haskell HTTP implementation works?
20:16:18 <ski> (hm, yes, i'm not sure the difference is relevant here)
20:16:35 <maitscha> and what does partial evaluation mean?
20:19:08 <maitscha> does it mean: add :: Int -> Int -> Int     could be written to     add 4711 :: Int -> Int ?
20:20:09 <tibbe> @t share
20:20:10 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
20:20:10 <lambdabot> null topic-snoc topic-tail topic-tell type .
20:20:17 <tibbe> @type share
20:20:18 <lambdabot> Not in scope: `share'
20:20:26 <tibbe> can I search for a function?
20:20:58 <nibro> @hoogle share
20:20:59 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable.SharedTexturePalett
20:20:59 <lambdabot> e :: ColorTable
20:21:17 <tibbe> thanks
20:21:32 <ski> maitscha : partial evaluation /= partial application
20:21:46 <ski> maitscha : what you mentioned was an example of the latter
20:22:07 <resiak> > take 5 ([1..])
20:22:08 <lambdabot> [1,2,3,4,5]
20:22:28 <resiak> Not really sure what my point was, but oh well.
20:22:36 <shapr> tibbe: Would be nice if lambdabot spell-corrected statiscally.
20:25:28 <tibbe> shapr, it would
20:25:49 <maitscha> ski: but what does partial evaluation is for? If I have a function add :: Int -> Int -> Int I will always call that function with 2 arguments. I will never call the function with add 4711...
20:26:19 <dcoutts> maitscha, well then that function is not a good example
20:26:27 <ski> how can you be sure of that ?
20:26:34 <tibbe> incAll = map (add 1) [1,2,3]
20:26:47 <dcoutts> maitscha, there are plenty of examples where one would like to specialise on one or more args of some function
20:27:06 <ski> maitscha : also, i think you mean 'partial *application*', not 'partial evaluation'
20:27:07 <maitscha> tibbe: a really better example...
20:27:23 <dcoutts> maitscha, the practical examples often involve some kind of interpretation of some data structre
20:27:27 <maitscha> ski: I dont know what I mean, because I dont know the difference...
20:27:59 <dcoutts> oh I was thinking of partial evaluation, not partial application
20:28:11 * dcoutts will go away now
20:28:15 <ski> maitscha : 'partial evaluation' is, loosely speaking', a kind of optimisation technique
20:30:13 <maitscha> hmmm... than my docu is not very good. I have here "why do use curryied functions ... only curried functions supports partial evaluation"
20:30:31 <ski> 'partial application' is when you don't pass all arguments to a function, leving out some
20:30:50 <ski> where are you reading that ?
20:31:34 <ski> (partial *evaluation* can surely be used with non-curried functions)
20:32:23 <maitscha> http://www.complang.tuwien.ac.at/knoop/lehre/ws0506/fp185161/fp04_051117.pdf   page 16
20:35:15 <maitscha> I also have "The craft of functional programming" from Thomson, but currifying isn't described very well there.
20:37:47 <tibbe> maitscha, I use this to convert a list of identifiers (function parameters) to a nested lambda for: foldr Lam Exp [Id]
20:38:08 <tibbe> here Lam is a function of two argument (actually a constructor) applied to 0 arguments
20:38:42 <tibbe> converts Lam [Id] Exp to (Lam Id (Lam Id (Lam Id Exp)))
20:39:33 * ski wonders if "partielle auswertung" really should translate to "partial evaluation" here (and not "partial application")
20:40:01 <tibbe> maitscha, I use it twice here: http://www.itstud.chalmers.se/~larssont/Main2.hs
20:40:15 <tibbe> but now, *lunch*
20:40:17 <ski> @babel de en partielle auswertung
20:40:19 <lambdabot>  partial evaluation
20:40:22 <ski> hm
20:41:24 <ski> maitscha : you could ask your teacher if s/he really meant 'partial evaluation' and not 'partial application', as i'm doubtful
20:44:41 <maitscha> like here http://www.haskell.org/hawiki/PartialApplication
21:27:25 <maitscha> what are "operator sections" ?
21:28:09 <maitscha> size = (*2) . length
21:28:26 <maitscha> is it partial application which is used there?
21:28:49 <maitscha> partial application combined with function composition...
21:30:59 <Igloo> (*2) is an operator section
21:32:58 <eivuokko> http://haskell.org/onlinereport/exps.html#sections is fairly clear and shows more interesting stuff you can do with sections.
21:35:02 <ski> > (/ 2) 10
21:35:03 <lambdabot> 5.0
21:35:08 <ski> > (2 /) 10
21:35:09 <lambdabot> 0.2
21:35:39 <ski> > map ("**" ++) ["a","bc","def"]
21:35:40 <lambdabot> ["**a","**bc","**def"]
21:35:46 <ski> > map (++ "**") ["a","bc","def"]
21:35:47 <lambdabot> ["a**","bc**","def**"]
21:36:15 <jethr0> map (("**"++) . (++"**")) ["a", "bc", "def"]
21:36:22 <jethr0> > map (("**"++) . (++"**")) ["a", "bc", "def"]
21:36:23 <lambdabot> ["**a**","**bc**","**def**"]
21:53:34 <maitscha> cool.
21:55:00 <maitscha> ok. i think i have understood.
21:56:11 <maitscha> > (* 3) 2
21:56:13 <lambdabot> 6
21:56:18 <maitscha> > (3 *) 2
21:56:19 <lambdabot> 6
21:57:06 <maitscha> > (2 *) ((* 2) 2)
21:57:07 <lambdabot> 8
21:57:33 <maitscha> > (/ 4) ((2 *) ((* 2) 2))
21:57:34 <lambdabot> 2.0
21:58:25 <maitscha> 2 'mod' (2 + (/ 4) ((2 *) ((* 2) 2)))
21:58:41 <maitscha> > 2 'mod' (2 + (/ 4) ((2 *) ((* 2) 2)))
21:58:41 <lambdabot>  lexical error in string/character literal
22:01:27 <musasabi> > 2 `mod` (2 + (/ 4) ((2 *) ((* 2) 2)))
22:01:28 <lambdabot> Add a type signature
22:01:38 <musasabi> > 2 `mod` (2 + (/ 4) ((2 *) ((* 2) 2))) :: Int
22:01:39 <lambdabot>  add an instance declaration for (Fractional Int)
22:01:56 <musasabi> mod is for integer and / for fractionals.
22:06:22 <ski> you can also use it like
22:06:46 <ski> > (`mod` 3) 17
22:06:47 <lambdabot> 2
22:07:02 <ski> in fact, sometimes i use this idiom :
22:07:32 <ski> > (`map` [1,2,3]) $ \x -> x*x
22:07:33 <lambdabot> [1,4,9]
22:08:03 <ski> this can be especially nice with mapM or friends, and do-notation inside the lambda
22:08:30 <ski> of course, one can also use
22:08:39 <ski> > flip map [1,2,3] $ \x -> x*x
22:08:40 <lambdabot> [1,4,9]
22:09:19 <maitscha> > (2:) [4,6..10]
22:09:20 <lambdabot> [2,4,6,8,10]
22:18:26 <SimonRC> @pl tee f g h x = f (g x) (h x)
22:18:27 <lambdabot> tee = liftM2
22:21:35 <tibbe> @quote
22:21:36 <lambdabot> mikaeli says: My friend bought a new laptop; it had MSBLASTER preinstalled.
22:21:36 <lambdabot> I couldn't believe it either and installed XP and the apps many times,
22:21:36 <lambdabot> run virus killers and everytime the blaster came back. Everything was
22:21:36 <lambdabot> packed on a rescue cd. And virus was in m$ works installation files.
22:24:46 <tibbe> @google lambdabot
22:24:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:25:05 <tibbe> @where lambdabot
22:25:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:08:19 <ski> @quote
23:08:20 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating
23:08:20 <lambdabot> breakfast crashed with bsod. I guess that's what you get for running
23:08:20 <lambdabot> windows in production use
23:08:37 <ski> @quote
23:08:38 <lambdabot> samc says: monads are hard, let's go shopping
23:12:57 <ski> @quote
23:12:58 <lambdabot> babel module failed: getRandItem: empty list
23:14:55 <Saulzar> @quote
23:14:56 <lambdabot> babel module failed: getRandItem: empty list
23:15:06 <Saulzar> @quote
23:15:06 <lambdabot> babel module failed: getRandItem: empty list
23:20:35 <musasabi> Does anyone have a pristine jhc at the moment? (just want to see if my bug is due to my modifications or something real)
23:29:42 <essiene> hello world :)
23:30:06 <essiene> i'm just starting my journey of functional languages... basically... i've picked up the bravery to cross the great devide...
23:30:15 <essiene> so here i am... paying my homage :D
23:30:46 * essiene retires to compulsory noob lurking mode
23:31:15 <ski> greetings essiene
23:31:29 <ski> @learn
23:31:29 <lambdabot> http://www.haskell.org/learning.html
23:31:39 <ski> that contains links to learning material
23:31:45 * blackdog is back from very cool gig
23:31:52 <blackdog> shapr: still around?
23:31:59 <ski> @google yet another haskell tutorial pdf
23:32:00 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
23:32:20 <ski> that is one tutorial you could start with
23:32:50 <ski> essiene : do you have any questions right now ?
23:32:51 <essiene> ski: wow... thnx
23:33:10 <essiene> i've just installed hugs... no questions right now... but i must warn you... they'll soon be _lots_ :)
23:33:19 <ski> maybe you would like to see a few small examples ?
23:33:46 <essiene> ski: any bookmarks you send to me now... i will _really_ appreciate... especially small code doing obvious stuff
23:34:01 <ski> @wiki HaskellDemo is a quick show of basic syntax of things
23:34:01 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo is a quick show of basic syntax
23:34:01 <lambdabot> of things
23:34:24 <essiene> ski: cool... cool.. cool...
23:34:31 <essiene> thnx again ski
23:34:43 <ski> @wiki also contains much good material
23:34:44 <lambdabot> http://www.haskell.org/hawiki/also contains much good material
23:34:56 <ski> essiene : yw
23:35:33 <essiene> now... i dive in :)
23:35:35 <ski> > map (9 *) [0..5]
23:35:36 <lambdabot> [0,9,18,27,36,45]
23:35:57 <ski> > 16 `divMod` 7
23:35:58 <lambdabot> (2,2)
23:36:06 <ski> > 26 `divMod` 7
23:36:07 <lambdabot> (3,5)
23:36:24 <tibbe> > 9 `div` 0
23:36:25 <lambdabot> Exception: divide by zero
23:36:36 <essiene> ahhh... interesting
23:36:49 <ski> > 26 `div` 7
23:36:50 <lambdabot> 3
23:36:52 <ski> > 26 / 7
23:36:53 <lambdabot> 3.7142857142857144
23:37:17 <ski> > let square x = x * x  in  map square [10,9..0]
23:37:18 <lambdabot> [100,81,64,49,36,25,16,9,4,1,0]
23:37:24 <essiene> 26 'Mod' 7
23:37:29 <essiene> :D
23:37:32 <essiene> i had to try that :)
23:37:58 <essiene> wow.... lambdabot is pretty cool
23:38:06 <ski> you need "`mod`", i.e. back-quotes, and you need to prefix with "> "
23:38:22 <essiene> oi... i just noticed that now
23:38:56 <ski> putting two "`" around a function name makes it into an infix operator
23:39:01 <ski> > div 26 7
23:39:02 <lambdabot> 3
23:39:25 <ski> is the normal prefix form of calling functions (no parens or commas for arguments)
23:39:46 <ski> > let square x = x * x  in  square `map` [10,9..0]
23:39:47 <lambdabot> [100,81,64,49,36,25,16,9,4,1,0]
23:39:54 <binary42> > (\) 26 6
23:39:55 <lambdabot>  parse error on input `)'
23:39:55 <essiene> ahhh... nice way to migrate gently
23:40:12 <binary42> I guess sections need one half :-|
23:40:21 <ski> > (/) 26 7
23:40:22 <lambdabot> 3.7142857142857144
23:40:25 <binary42> hehe
23:40:36 <ski> '\' is reserved for something else
23:40:47 <ski> btw, you can define you own infix operators
23:40:50 <binary42> yeah
23:41:03 <binary42> lambda forms... I should watch my typing.
23:41:30 <ski> > let x -*- y = (x - y) * (y - x) in  15 -*- 8
23:41:31 <lambdabot> -49
23:41:38 <maitscha> > putChar 'c'
23:41:38 <lambdabot> No IO allowed
23:42:44 <ski> @type "abc"
23:42:45 <lambdabot> [Char]
23:42:58 <ski> > ['a','b','c']
23:42:59 <lambdabot> "abc"
23:43:10 <ski> strings are just lists of characters
23:43:23 <maitscha> hehe, it always remembers me on C.
23:43:51 <ski> > reverse [0,8,42]
23:43:52 <lambdabot> [42,8,0]
23:43:59 <ski> > reverse "xyzzy"
23:44:00 <lambdabot> "yzzyx"
23:44:09 <maitscha> reverse "ski"
23:44:15 <maitscha> > reverse "ski"
23:44:16 <lambdabot> "iks"
23:44:21 <ski> :)
23:45:07 <ski> > map reverse ["a","bc","def"]
23:45:08 <lambdabot> ["a","cb","fed"]
23:45:16 <ski> > reverse (map reverse ["a","bc","def"])
23:45:17 <lambdabot> ["fed","cb","a"]
23:45:23 <ski> > concat (reverse (map reverse ["a","bc","def"]))
23:45:24 <lambdabot> "fedcba"
23:46:33 <binary42> > take 8 [ (x, x*x) | x <- [1..] ]
23:46:34 <lambdabot> [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64)]
23:46:39 <maitscha> > concat (reverse (map reverse ["a","hcst","iam"]))
23:46:40 <lambdabot> "maitscha"
23:46:44 <ski> essiene : the prefixing with "> " is of course just the syntax of the bot so it knows when to try to evaluate something said here
23:47:09 <essiene> yup.. :)
23:47:19 <binary42> (or one way to designate code in literate style, .lhs)
23:47:38 <essiene> btw, lambdabot is the most advanced irc bot i've seen yet... maybe untill i pop into #lisp :)
23:47:40 * ski nods vaguely
23:48:19 <ski> lambdabot can dynamically load new plugins
23:48:33 <binary42> essiene: check out the code sometime. It has a bunch of modular plugins that are fun to play with.
23:49:14 <essiene> binary42: i'll keep that in mind
23:49:26 <ski> we can also use it to find in which module(s) a function is defined
23:49:31 <ski> @index concat
23:49:31 <lambdabot> Data.List, Prelude
23:49:57 <essiene> very impressive...
23:50:52 <ski> ok, maybe we should leave you for the tutorials, now, until you've got questions :)
23:51:12 <ski> (or want to see more examples)
23:52:21 <essiene> i have enough to play with... i'm glancing thru the HaskellDemo now... trying to wet my feet... then i'll go on to the pdf
23:52:36 <essiene> and is 'hugs' good enuff? or should i get ghc?
23:52:43 <essiene> hugs98 that is
23:52:55 <ski> it is good enough for learning
23:53:15 <ski> it is quite fast when reloading source files
23:53:25 <binary42> hugs is good. I personally learned with ghci along side tweaking real code from assorted projects I found.
23:53:36 <essiene> ok...
23:53:47 <essiene> there's prolly something i'm doing wrong then...
23:53:59 <ski> (having fast reloading is good for testing and debugging, also)
23:54:08 <essiene> on the demo... there are the assignment examples which i try to follow... 'somenumber = 1'
23:54:17 <ski> are you trying to define functions/values inside hugs ?
23:54:18 <ski> heh
23:54:26 <ski> yes, put definitions in a file
23:54:28 <essiene> in hugs i get 'unexpected ='
23:54:31 <ski> then load that file
23:54:31 <essiene> oh... i c
23:54:48 <essiene> ok... so its not interactive like that?
23:54:54 <essiene> k.. lemme try that then
23:54:57 <ski> hugs evaluates expressions, and shows types etc, not for definition functions and stuff
23:55:25 <ski> in ghci, you *can* define values and functions .. but you can't define types, etc
23:55:44 <ski> try saving in something like Test.hs
23:55:53 <essiene> i c
23:56:08 <essiene> anyways... i just done the load stuff... and its working pretty well... thnx :)
23:56:09 <ski> and then load that from inside hugs with ":l Test.hs" (":l" is short for ":load")
23:56:14 <essiene> i'm a happy camper so far
23:56:50 <ski> when you change your file(s) (and save), you then can reload by ":reload", short ":r"
23:57:18 <essiene> cool
23:57:50 <ski> (hm, are you using console version of hugs ?)
23:58:40 <ski> (if you're on windows, there's winhugs, which has some buttons and menus stuff)
23:58:49 <essiene> yeah... console
23:59:28 <essiene> i'm on linux currently.... but i'm downloading hugs for windows so i can do that also
