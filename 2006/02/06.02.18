00:00:35 <Lokadin_> lisppaste2: url
00:00:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
00:01:29 <lisppaste2> Lokadin pasted "Process with newline problem" at http://paste.lisp.org/display/16932
00:01:37 <Cale> it might be safer to have:  '\n' -> process (' ':xs)
00:01:48 <Lokadin_> kk i'll try that
00:02:45 <Lokadin_> er well it's better, but i'm still getting strange results
00:03:50 <Lokadin_> what's really wierd is that it outputing things that were infront after, but not backwards' just like the second line is printed before the first
00:04:32 <Lokadin_> and when i do putStrLn, it gives me vastly different output than if i try outputting it in chunks so say first 80 charaters
00:04:51 <Cale> odd
00:05:09 <Lokadin_> yep
00:05:17 <Cale> maybe print the string and see what special characters are in it
00:05:45 <Lokadin_> hmmm you know i should probably try it with a simpler file
00:05:52 <Cale> (print = putStrLn . show is a prelude function)
00:05:53 <Lokadin_> i guess that might work better
00:06:00 <Lokadin_> o
00:06:23 <Lokadin_> so er 
00:06:34 <Lokadin_> say the string is called processed
00:06:40 <Lokadin_> then i would write?
00:06:51 <Cale> print processed
00:06:57 <Lokadin_> kk thanks :)
00:07:27 <Cale> which will apply show to the string, which turns '\n' into an actual backslash and n, for example.
00:07:48 <Cale> (and also puts quotes around it)
00:08:07 <Lokadin_> cool it's a really neat function
00:10:54 <Cale> what are you writing?
00:11:18 <Lokadin_> :|
00:11:21 <Lokadin_> wow it works
00:11:24 <Lokadin_> er
00:11:52 <Lokadin_> i'm writing a typing practicing thingy, i was thinking how it's boring to type the same words over and ovre
00:12:06 <Lokadin_> and it's also no fun to type seperate different words
00:12:36 <Lokadin_> nor is meaningless sentenses 
00:12:53 <Lokadin_> so i want to maybe convert wikipedia pages, or rss feeds
00:13:07 <Lokadin_> and use those to type from
00:13:25 <Cale> cool
00:13:32 <Lokadin_> :)
00:13:48 <Lokadin_> i don't really understand it but it decided to start working
00:14:07 <Lokadin_> with the original formating to as in '\n'-> process xs
00:16:31 <Lokadin_> say i can't seem to use backspace when entering text for getLine
00:16:40 <Lokadin_> it shows a bunch of ^H's
00:18:01 <Lokadin_> Lisppaste pastes can be made by anyone at any time. Imagine a fearsomely comprehensive disclaimer of liability. Now fear, comprehensively.
00:18:04 <Lokadin_> lol
00:18:35 <Lokadin_> should i have perhaps something other than getLine?
00:19:05 <Lokadin_> eh
00:19:07 <Lokadin_> well okay
00:19:12 <Cale> um
00:19:13 <Lokadin_> it's really late
00:19:18 <Lokadin_> and i have work in 5 hours
00:19:22 <Lokadin_> so i'm goin to bed
00:19:28 <Cale> you should make sure that stdin is line buffered
00:19:30 <Lokadin_> thanks for all the help :D
00:19:38 <Lokadin_> er?
00:19:43 <Lokadin_> how do i do that?
00:19:48 <Cale> hSetBuffering stdin LineBuffering
00:19:55 <Cale> and import System.IO
00:20:08 <Cale> It really should be set on something like that anyway
00:20:15 <Cale> (to begin with)
00:20:18 <Lokadin_> hmmm
00:20:26 <Lokadin_> where would i put it? in main?
00:20:29 <Cale> yeah
00:20:31 <Lokadin_> kk
00:20:36 <Cale> before the first getLine
00:21:49 <Lokadin_> nope :( doesn't help
00:21:55 <Lokadin_> still a bunch of ^H
00:21:58 <Lokadin_> maybe it's xterm
00:22:03 <Lokadin_> let my try gnome terminal
00:22:34 <Lokadin_> yep
00:22:36 <Lokadin_> :)
00:22:43 <Lokadin_> in gnome-terminal it works fine
00:22:46 <Lokadin_> how very odd
00:24:19 <Lokadin_> actually
00:24:24 <Lokadin_> it works in xterm to
00:25:06 <Lokadin_> only doesn't work
00:25:10 <Lokadin_> if i have a screen
00:25:14 <Lokadin_> in an xterm
00:25:24 <Lokadin_> but works if i have screen in gnome terminal
00:25:33 <Lokadin_> do you think that would classify as a bug?
00:25:51 <Lokadin_> ?
00:26:22 <Lokadin_> oh man hold on i think this xterm just died
00:26:51 <Lokadin_> odd
00:26:54 <Lokadin_> oh well
00:26:59 <Lokadin_> definatly not even
00:27:04 <Lokadin_> i go sleep
00:27:14 <Lokadin_> thanks for all the help Cale :D
00:29:54 <Cale> Lokadin_: goodnight (sorry I stepped out there)
01:00:47 <Cale> > let sols n = length [x | x <- [n+1..2*n], (x * n) `mod` (x - n) == 0] in [i | (x,i) <- zip (map sols [1..]) [1..], x == 2]
01:00:51 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,
01:00:51 <lambdabot> 101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
01:00:51 <lambdabot> 193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,
01:00:51 <lambdabot> 293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,
01:00:51 <lambdabot> 409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,
01:00:52 <lambdabot> [24 @more lines]
01:03:25 <cpatrick> whee, primes! cute...
01:04:20 <Cale> if you change x == 2 to x == 3, it appears that you get squares of primes
01:09:56 <Cale> of course, this has to break down...
01:15:16 <Saulzar> Seems to be true for quite a few...
01:16:29 <Cale> (I mean the general pattern that you get only cubes of primes when x == 4, and so on.)
01:16:46 <Saulzar> Ah
01:16:58 <Cale> Obviously, there are indices which are not powers of primes, and there has to be some number there :)
01:31:14 <lispy> maybe keal could prove it
01:31:16 <lispy> @keal
01:31:16 <lambdabot> my proof show math is broken right now
01:31:47 <Cale> heh, what an apt quote :)
02:06:42 <jips> good morning haskell
02:11:39 <imix> Maybe someone can help me on this? I let two threads communicate with stm channels (taken from the paper Composable Memory Transactions). One reads from a socket, the other prints the received text. So far the second thread only reads from the channel when I send an ETX or EOT on the socket. Has this something to do with lazy evaluation?
02:12:26 <Cale> imix: just to check, you know that Control.Concurrent.STM.TChan is in GHC, right? :)
02:13:03 <Cale> That sounds like it has to do with buffering
02:13:47 <Cale> Check with hGetBuffering/hSetBuffering that the buffering on the handle is set to NoBuffering or LineBuffering
02:14:18 <imix> cale: aehm now i know. I set the socket already to NoBuffering (also tried LineBuffering)
02:15:50 <imix> I observed that the text is read from the socket correctly and the write function is called and the writing thread continues. The receiving thread seems to block on an empty channel though
02:16:19 <Cale> oh, it will
02:16:35 <Cale> that's just how channels work
02:17:05 <Cale> use isEmptyTChan to check first
02:19:06 <Cale> well,
02:19:11 <Cale> readTChan :: TChan a -> STM a
02:19:11 <Cale> readTChan (TChan read _write) = do
02:19:11 <Cale>   listhead <- readTVar read
02:19:11 <Cale>   head <- readTVar listhead
02:19:11 <Cale>   case head of
02:19:12 <Cale>     TNil -> retry
02:19:14 <Cale>     TCons a tail -> do
02:19:18 <Cale> 	writeTVar read tail
02:19:20 <Cale> 	return a
02:19:29 <Cale> if the channel is empty, it retries, so yeah, it'll basically block
02:20:11 <imix> I see that, what i don't get, why does it still block when i successfully wrote an item on the channel? (even multiple)
02:20:32 <Cale> it ought not to...
02:20:41 <imix> the atomic block that does the write terminates properly
02:21:10 <imix> I will try and use TChan and see if I have a problem in my Channels then
02:28:07 <imix> the problem seems to be somewhere else, the behaviour is identical with TChans
02:28:17 <Cale> hmm
02:28:54 <Cale> I can simulate the TChan code by hand and it works. Let me actually try it.
02:29:42 <Cale> http://darcs.complete.org/fptools/libraries/stm/Control/Concurrent/STM/TChan.hs -- it's here, btw
02:30:23 <imix> i put the code here: http://ste.aeschbacher.ch/temp/haskell/ 
02:46:55 <Cale> Is there a good reason to use the low-level network API here/
02:46:56 <Cale> ?
02:48:46 <imix> actually no real good reason
02:51:38 <imix> did you see something wrong with it?
02:52:21 <Cale> not yet, just reading the code
02:53:15 <Cale> okay
02:53:20 <Cale> what's the actual bug?
02:54:34 <imix> if I run it, i can connect to it (via telnet or netcat) and send data but the data is only printed from the manager when i send a ^D or ^C
02:55:13 <Cale> hmm...
02:56:48 <Cale> yeah
02:57:44 <Cale> not to mention the 100% CPU usage
02:58:34 <imix> that should come from the constant polling, will have to do something about that
03:02:31 <Cale> wait a minute... this doesn't quite seem to be using channels, just parts of their implementation
03:03:13 <Cale> an MChan doesn't seem to carry enough information to be a channel
03:03:41 <Cale> a TWChan does, though you didn't give it a name
03:04:19 <Cale> let me rewrite what I think the intent is in terms of the library TChans
03:04:53 <imix> that would be nice :)
03:25:47 * JKnecht has noticed that on P4s programs in an infinite loop can cause thermal events.
03:35:21 <Cale> JKnecht: especially when said P4's have gone a long time without a cleaning. 
03:35:55 <JKnecht> huh? are you serious?
03:36:42 * JKnecht is humour challenged.
03:37:55 <Cale> somewhat so. If the thermal paste is sufficiently old, it seems to become less effective, and dust seems to be quite good at trapping hot air where you don't want it.
03:39:24 <JKnecht> yeah, I was thinking about the grease. Overgreased most recent CPU set due to thermal solution SNAFU and had to clean em up with q-tips.
03:41:04 <Cale> It seems you can actually use almost anything reasonable as thermal paste, as long as it doesn't dry up.
03:41:28 <JKnecht> program has to do more than go into loop though, has to clobber the OS, which may be why I've only seen it on DOS in a year or so of using P4. One CPU goes to 100% then eventually produces a thermal even.t
03:42:05 <Cale> oh, yeah, I suppose so.
03:42:28 <Cale> I bet you could even use vegemite for thermal paste :) I don't know how long it would last though.
03:42:57 <JKnecht> funny how Artic Silver seems to be the best.
03:44:31 <JKnecht> the 6.5 ghc line is for dev purposes, yes?
03:44:43 <Cale> haha, someone actually tried that
03:44:57 <Cale> http://www.dansdata.com/goop.htm
03:45:32 <Cale> http://www.dansdata.com/images/goop/nofibgraph2.gif
03:47:19 <imix> i think i go with toothpaste (wonder what brand he used)
03:48:18 <Cale> the only problem with toothpaste is that it seems to dry up sooner than you might like. I've mixed it with noncorrosive soldering flux and had quite decent results.
03:49:40 <JKnecht> omg, you're serious
03:50:28 <Cale> yeah, pretty much anything you can put in there is going to be a better heat conductor than air.
03:50:35 * JKnecht consider a call to CPU protective services
03:50:52 <Cale> usually sufficiently better :)
03:51:15 <JKnecht> s/consider/considers/
03:52:33 <Cale> The toothpaste/soldering flux solution lasted about 2 years, and only very gradually dried up at the end, so I had plenty of time to notice the CPU temperature becoming a problem with long computations.
03:53:50 <Cale> Right now I have just flux, and it works about as well, maybe just marginally less good than with the tootpaste mixed in, but it probably will take longer to dry.
03:54:47 <JKnecht> Artic Silver is only like 12 USD
03:55:31 <Cale> Yeah, but it's hard to find a place which sells thermal paste around this city.
03:56:40 <JKnecht> I'm in a smaller town near you and I just go to CompUSA.
03:57:10 <Cale> There's no such thing as CompUSA here :)
03:57:59 <JKnecht> yeah, I know but there oughta be a Canuck work-alike
03:58:13 <Cale> (I'm not in Toronto)
03:58:19 * resiak wonders if CompUK would be worth having
03:58:36 <JKnecht> oh, though you were in the GTA
03:58:44 <JKnecht> s/though/thought/
03:58:44 <Cale> no, I'm in Brantford.
03:59:03 <Cale> Which, despite its population, is astoundingly dead.
04:00:11 <Cale> (my hostname lies -- sometimes it even says I'm in Quebec)
04:00:54 <imix> cale: i now completely removed the MChan and replaced it with TChan (only one left is my TWChan). Unfortunately de behaviour is still the same.
04:01:46 <Cale> imix: the usual idiom when you want to pass only one end of the TChan is to just pass a partially applied version of readTChan or writeTChan
04:02:20 <imix> cale: sounds reasonable
04:08:45 <dcoutts> jips, you need alex & happy if you're building from the darcs dev version of gtk2hs. If you use a released tarball then you don't need either.
04:10:48 <Cale> ah, it's almost certainly buffering of some sort
04:11:15 <Cale> imix: try entering some stuff in telnet, then hold down the enter key for a while
04:11:57 <Cale> What's the more abstract view of the way that you want this program to work?
04:14:02 <imix> what should happen when i hold down the enter key? (i only get many empty lines written)
04:14:32 <Cale> eventually, I get a large block of Received: foo lines
04:16:22 <imix> I never got a large block of received (maybe we have other definitions of 'a while')
04:17:08 <imix> maybe my changes i did so far made the behaviour worse
04:18:30 <Cale> let me count the lines :)
04:20:17 <imix> i want to accept connections from multiple 'applications' parse the messages (only strings so far, they will be of a binary format similar to RPC) manage the connected applications and react on incoming messages (the whole should give a simulator which should help to develop such applications)
04:20:35 <imix> react -> send back answers or on messages
04:20:37 <Cale> 115
04:20:45 <JKnecht> as in yampa?
04:22:03 <imix> i had 497
04:22:54 <Cale> hmm
04:24:17 <Cale> actually, it seems kind of random
04:24:56 <imix> JKnecht: was the question about yampa directed at me?
04:25:05 <Cale> but if I hold my enter key down, it tends to happen withing about 10 seconds
04:27:51 <imix> i tried the version i put on the web and it does not show the behaviour you describe
04:27:57 <Cale> hmm
04:28:17 <JKnecht> imix: sorry, just reacted to "react" and the arrows. My bad.
04:29:00 <imix> ah
04:29:32 <dcoutts> anyone know of a good intro to the FFI that I could reccomend to a newbie ?
04:29:39 <imix> cale: maybe some OS specific differences in the implemenation of socket? (i kno it's far fetched...)
04:30:22 * gour is also interested for such intro
04:30:25 <Cale> I'm running Debian
04:30:30 <JKnecht> http://www.haskell.org/hawiki/FfiTutorial
04:30:33 <dcoutts> the chap who reported this bug needs an into to the FFI: http://bugs.gentoo.org/show_bug.cgi?id=123244
04:30:54 <imix> I'm using FreeBSD
04:34:13 <araujo> Good morning.
04:35:22 <Cale> dcoutts: The actual FFI spec is pretty readable, but I suppose I wouldn't give it to a complete newbie.
04:35:50 <dcoutts> Cale, the chap needs to know how to link C & Haskell code
04:35:52 <musasabi> imix: there are lots of socket differences between different operating systems
04:36:12 <dcoutts> Cale, I guess that's ghc-specific, the FFI spec doesn't cover it much.
04:36:21 <Cale> dcoutts: yeah
04:36:38 <Cale> the GHC user guide covers that somewhere, I think
04:37:20 <imix> musasabi: i know, but i'm not sure whether the problem i have is related to sockets at all (thats why I wrote 'far fetched')
04:50:37 <imix> have to go now, thanks for the help and bye :)
04:51:58 <Cale> imix: come back at some point when I'm less tired and we'll have a better look at it -- certain changes would make it clearer what's going on
04:52:54 <imix> cale: i will, thanks again
04:58:09 <Cale> dcoutts: I also can't replicate the problem he had, though I'm not on a 64 bit machine, so probably uint64_t means something else.
04:58:46 <dcoutts> Cale, but I really don't think it is supposed to work anyway, wouldn't you agree?
04:58:59 <dcoutts> ghci doesn't just load up any old .o file
04:59:08 <Cale> sure it does
04:59:19 <dcoutts> especially if that .o file depends on other libs
04:59:21 <Cale> though it won't look for other libraries it might need
05:00:14 <dcoutts> Cale, ok, so it works mostly but it's not what you'd actually want to do
05:00:58 <Cale> you might want to do it if you were going to ffi import things from that .o file.
05:01:44 <Cale> of course, you'd need a .hs for that as well
05:02:13 <dcoutts> but if you were going to do that then you'd make a package
05:02:22 <dcoutts> a .a file linked by ghc
05:02:28 <dcoutts> and then confert it to a ghci .o files
05:05:23 <Cale> uh, I guess you could
05:05:33 <Cale> I probably actually wouldn't think to do that.
05:05:48 <Cale> import Foreign.C.Types
05:05:48 <Cale> foreign import ccall "foo" foo :: CDouble -> CInt
05:06:03 <Cale> this works with that .o linked in
05:06:27 <Cale> cale@zaphod[~]$ ghci -fffi foo.o foo.hs
05:06:28 <Cale> ...
05:06:36 <Cale> *Main> foo 5.6
05:06:36 <Cale> 5
05:07:15 <Cale> (I changed the uint64_t to int in the c file though)
05:12:30 <Cale> It's interesting that ghci doesn't accept the .c file as input.
05:14:57 <Cale> heh, calling it foo.hs is a bad idea though :)
05:16:02 <Cale> ghc -fffi -o bar bar.hs foo.c
05:16:23 <Cale> this works after renaming foo.hs to bar.hs and adding a main
05:24:11 <astrolabe> Is there a standard monadic wrapper for a pseudo-random number generator?
05:25:09 <wilx> Random, RandomGen?
05:25:26 <wolverian> getStdGen :) 
05:25:31 <wolverian> (use hoogle!)
05:26:32 <astrolabe> @hoogle getStdGen
05:26:33 <lambdabot> System.Random.getStdGen :: IO StdGen
05:26:53 <wolverian> @hoogle random 
05:26:54 <lambdabot> System.Random.Random :: Random a
05:26:54 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
05:26:54 <lambdabot> System.Random.RandomGen :: RandomGen g
05:26:59 <wolverian> hoogle is great. 
05:27:17 <astrolabe> I meant a wrapper to hold and update the seed.
05:29:55 <musasabi> astrolabe: I think there was something like that in the wiki
05:30:55 <astrolabe> thanks
05:32:30 <tenmon> hi, I like the idea of pure-functional languages. Do you know a language like Haskell but with syntax more resembling to C-family languages?
05:32:52 <musasabi> tenmon: you can write Haskell with C-like syntax
05:33:00 <Lemmih> tenmon: See O'caml or SML.
05:33:03 <musasabi> tenmon: do { foo; bar; baz }
05:33:16 <musasabi> SML has a quite nice syntax
05:33:32 <musasabi> the OCaml one is quite hard and not very much like C
05:33:37 <araujo> tenmon, Haskell syntax is beautiful!
05:33:39 <tenmon> I'll take a look. Anyways I'm more worried about the performance
05:33:50 <Philippa> C syntax is a pain once you're using a language with currying anyway
05:34:21 <tenmon> araujo: yes, to someone who is used to, but telling other coworkers that, I guess you've tried that before :P
05:34:23 <musasabi> tenmon: like Haskell beating C in some performance (micro)benchmarks? ;)
05:34:33 <Philippa> what do you want/need the performance to be equivalent to?
05:35:16 <tenmon> to the best functional languages, from what I know, they beat imperative regarding difficult to program a threaded program
05:36:02 <tenmon> basically I'm looking at the best performer, and with syntax more resembling to C++
05:37:04 <araujo> tenmon, actually, my experience is quite the opposite, they get impressed by the cleanness of the code
05:37:16 <astrolabe> the syntax of function application?
05:37:22 <araujo> They are more usually concer with performance issue and such
05:37:28 <araujo> concerned*
05:38:40 <musasabi> You could of course use FC++
05:38:50 <tenmon> I know that with time you can get used, but there are some syntax in Haskell for example that could have been from other form, being more friendly to already C/C++
05:39:13 <Philippa> and being considerably more painful to those who're actually used to Haskell
05:39:15 <tenmon> musasabi: I'll take a look
05:39:22 <araujo> You are confusing being more friendly with being more like C/C++ :-)
05:39:28 <araujo> And that's 'ironic' :-)
05:39:29 <astrolabe> A lot of the syntax seems to be the way it is because it is a functional language
05:39:30 <tenmon> Philippa: yes, but it's not the concern for me
05:39:54 <Philippa> it's a concern for pretty much anyone with any actual sense who uses the language for more than five minutes, though
05:39:56 <tenmon> araujo: I'm not looking for one more friendly, I'm looking for one more like C/C++, but purely functional
05:40:21 <Philippa> being like C or C++ makes a purely functional language painful to use. It's pretty much that simple
05:40:53 <tenmon> Philippa: I know I shouldn't have asked here it seems, but it's not what I'm looking for
05:40:54 <Philippa> you could use {<definitions> <expression>} or similar as a replacement for let, sure. It'd make records a PITA to use though
05:41:02 <musasabi> Philippa: actually it can look quite pretty with the right amount of operator overloading, but the error messages are horrible.
05:41:13 <ValarQ> the C syntax isn't that great outside C
05:41:17 <ValarQ> just look at C++ and objc
05:41:48 <tenmon> see, I want first to convert co-workers to use a functional language resembling C/C++. When they get a grasp about it, they can use Haskell or any other
05:41:50 <Philippa> what you can do, which may help if somebody's layout-averse, is use braces and semicolons explicitly for that kind of thing
05:41:51 <ValarQ> not to mention php...
05:42:14 <tenmon> *syntax
05:42:22 <Philippa> let {a = b; c = d; e = f} in expr
05:42:35 <Philippa> case (foo) of {Bar -> baz}
05:42:36 <Philippa> etc etc
05:42:56 <tenmon> that would be more fine, if for example the compiler would enforce it
05:43:11 <tenmon> (in my case)
05:43:50 <tenmon> anyways, I'll take a look after SML
05:43:55 <Philippa> you could just tell your coworkers that when they don't it's their problem when they get confusing stuff
05:44:13 <Philippa> or write something to check it's being done, it's a reasonably easy lexical thing to do
05:44:27 <araujo> yeah
05:44:37 <araujo> you could write some QA-like tool to do it
05:44:41 <tenmon> yeah, I know I could do that, but I hope there's a language more simmilar to what I'm looking
05:44:55 <musasabi> just compare "wc -l" and "grep ';'" outputs with each other and use that to score the files ;)
05:45:39 <Philippa> in short, there's not
05:45:46 <Philippa> nobody'd use it for more than one project before moving on
05:46:15 <xerox_> G'day.
05:46:47 <araujo> tenmon, you are looking for an imperative language actually
05:46:52 <tenmon> Philippa: mm I'm not asking for a C/C++ functional language, if not, one like haskell, but with some C resemblances
05:47:14 <Philippa> even then, nobody'd use it for more than one project because the syntax'd still be a PITA
05:47:17 <Philippa> which is why it never happens
05:47:19 <tenmon> araujo: no, I'm looking for a Haskell but with touches of C/C++
05:47:27 <Philippa> nobody wants to burden their own pretty language with that stuff
05:47:51 <astrolabe> tenmon:  Can you give an example of the syntax you'd like?
05:47:51 <araujo> tenmon, you can make your Haskell code look like C code with the do notation
05:48:29 <astrolabe> I don't know why haskell doesn't use the C++ comment style
05:48:38 <tenmon> araujo: yes, but it wasn't designed for that
05:48:47 <araujo> ?
05:48:48 <Philippa> actually, it pretty much was
05:48:55 <tenmon> guess I'll have to create my own language or wait then =P
05:49:08 <araujo> tenmon, that's one of the do notation main goal :-)
05:49:14 <astrolabe> A long wait :(
05:49:17 <Philippa> granted most people use the layout rule rather than braces and semicolons...
05:49:39 <tenmon> astrolabe: I hope not
05:49:43 <xerox_> Just do { it; } !
05:49:47 <astrolabe> I don't think the syntax is the hard thing with switching to a functional language.
05:49:50 <araujo> tenmon, also, i see no point on what you wanna do
05:50:23 <araujo> you wanna pet a dog but that looks like a cat
05:50:27 <tenmon> araujo: of course, you're already using it
05:50:29 <araujo> That's.... scary :-)
05:50:52 <araujo> And i wasn't a few years ago....
05:50:54 <tenmon> araujo: but guess what, that's why languages like C++ first, Java after, and PHP then, become mainstream
05:51:02 <araujo> My first PL was C actually
05:51:09 <tenmon> they had resembling of C
05:51:10 <kosmikus> tenmon: and Python ;)
05:51:41 <tenmon> of course, with switching paradigms the syntax will be totally different, but some things can be conserver
05:51:43 <araujo> And ive found my way better over Haskell during these last years than i was able to do with C 
05:51:54 <tenmon> as pointed out: the coments tokens, the braces, etc
05:52:26 <astrolabe> It might be interesting to try to teach someone haskell by pretending everything had to be inside a do  at first.
05:52:39 <kosmikus> I think the syntax is one of the biggest advantages that Haskell has over C-style languages. I find it almost more important than being functional.
05:52:47 <Philippa> any serious coder can handle a different comment token
05:53:06 <Philippa> and anyone with an editor with syntax highlighting doesn't need to look for the actual tokens unless they're writing comments anyway
05:53:10 <tenmon> kosmikus: syntax is about user-preference, whenever someone likes one way, other does another...
05:53:14 <astrolabe> Philippa:  :p
05:53:28 <araujo> tenmon, that's not _that_ true at functional languages
05:53:38 <Philippa> syntax isn't just user-preference
05:53:40 <araujo> tenmon, syntax plays an important role in this paradigm imho
05:54:10 <Philippa> no kidding. When everything's the same kind of syntactic entity, you really don't want a load of visual clutter making it harder to follow the intended decomposition
05:54:12 <tenmon> araujo: yes, but I was pointing that whenever for example a Haskell programmer find it's syntax best, a Erlang programmer would say otherwise
05:54:30 <tenmon> so yes, it's a matter of preference
05:54:34 <araujo> tenmon, you've got all these nifty things like lazy evaluation, higher-order functiosn and such, that needs to play nice with the syntax and viceverse
05:55:08 <Philippa> tenmon: note that Erlang and Haskell have some rather fundamental differences in what they do
05:55:24 <tenmon> Philippa: it was just an example
05:55:53 <araujo> tenmon, i think that's different
05:55:59 <Philippa> yes. I think you'll find that once you look at more similar languages, for the most part Haskell's syntax is considered 'nicer' than that of most of the ML languages for example
05:56:31 <araujo> The fact that you prefer one syntax over the other doesn't mean that all programming languages should have it.
05:56:34 <Philippa> even then, the ML languages don't need do notation *for semantic reasons*, and similarly need to support some different constructs
05:57:44 <astrolabe> So syntax isn't just a layer painted on top of a language.
05:57:45 <araujo> tenmon, and regarding purely functional languages, the syntax (as i said) plays an important role to get that paradigm well-expressed
05:58:11 <tenmon> araujo: yes, but it's not the only important point when designing the syntax
05:58:25 <araujo> I never said that.
05:58:57 <Philippa> C familiarity in a language that's already going to seriously mess with a C coder's head isn't worth the cost that comes with it for the most part though
05:58:59 <tenmon> araujo: sometimes, looking after some things for example (trying to use some syntax of an existing mainstream language), can be very important to mainstream adoption
05:59:16 <Philippa> Haskell was never designed to be a mainstream language
05:59:29 <tenmon> Philippa: and that's why I'm asking for another language
05:59:42 <tenmon> but there isn't a #Functional channel here
05:59:44 <tenmon> =(
05:59:49 <Philippa> and I can tell you for free that obsessively C-like syntax will shoot that language in the foot
06:00:16 <pesco> Because all the functional coders will want it to look like Haskell!
06:00:32 <tenmon> Philippa: please try to read, I'm not looking for a C with touches of Haskell, I want Haskell with touches of C
06:00:32 <Philippa> if you want to borrow the comment tokens that's fair enough. Insisting on braces and semicolons /will/ damage the cool factor that you need to pull users in in the first place
06:00:33 * kosmikus recalls how hard it was to teach some students that "return" is a function, not a keyword, in Haskell
06:00:48 <kosmikus> sometimes, C resemblance can actually lead to wrong assumptions
06:01:16 <tenmon> kosmikus: sometimes, that depends on the language design
06:01:22 <araujo> tenmon, That's true.. now the question is, is that good for designing innovative programming languages ?
06:01:32 <Philippa> quite. IMO, encouraging a C-style indentation discipline is also a bad thing
06:01:37 <araujo> tenmon, Look at C++ ..... a programming language that even his author got problems with
06:02:05 <tenmon> as pointed out over: Haskell wasn't never meant to be a mainstream language
06:02:12 <tenmon> and I'm looking for the opossite
06:02:15 <Philippa> white space is too important for that, and we don't have a good equivalent to blocks to insist on always indenting
06:02:17 <araujo> tenmon, The main goal of C++ was to resemble as much as possible of C since the beginning, and what did you get?, people who knows C++ , also know it is a disaster
06:02:23 <tenmon> seeing a functional language becoming mainstream
06:02:42 <jips> @seen dcoutts 
06:02:43 <lambdabot> dcoutts is in #gentoo-haskell and #haskell. Last spoke 20 minutes and 46
06:02:43 <lambdabot> seconds ago.
06:02:55 <Philippa> having a functional language become mainstream needs things like records with substructural typing far more than it needs C-like syntax
06:03:05 <kosmikus> jips: he said he's going to be away for a while
06:03:18 <Philippa> er, not substructural. Structural subtyping even
06:03:24 <jips> kosmikus: :'(
06:03:24 <tenmon> Philippa: identation is about personal preference, it's like telling a Python coder to use tabs instead of spaces, or telling a C programmer about braces...
06:03:25 <Philippa> (mixing my buzzwords up - d'oh!)
06:03:32 <jips> @seen Cale
06:03:33 <lambdabot> Cale is in #haskell. Last spoke 47 minutes and 9 seconds ago.
06:03:39 <Philippa> tenmon: it's not /just/ about personal preference
06:03:43 <araujo> I prefer not to have Haskell becoming a mainstream language if that means turning into a Java-like language
06:03:47 <Philippa> if you don't believe me, you've not read enough haskell code
06:03:58 <jips> haskell is already a mainstream language :D
06:04:16 <pesco> Just the old mainstream hasn't noticed it's obsoleteness, yet. ;)
06:04:19 <araujo> tenmon, i also think that youv'e got a mis-conception about 'mainstream languages'
06:04:23 <kosmikus> araujo: me too; it feel like if I would have to use KDE for Linux to become a mainstream OS ;)
06:04:30 <astrolabe> I do find it annoying that the three languages I use most each have different symbols for '--' and '/='.  It is trivial to understand, but it is pointless.
06:04:32 <araujo> kosmikus, hahaha
06:05:23 <tenmon> Quoting: <Philippa> Haskell was never designed to be a mainstream language
06:05:28 <Philippa> tenmon: if you remove room for writing style from a functional language by encouraging everybody to use a C-like indentation style, you make it considerably harder to read good code
06:05:37 <Philippa> tenmon: that doesn't stop it becoming one. It just means it wasn't a goal
06:05:45 <Philippa> perl wasn't designed to be one either
06:06:29 <astrolabe> I'm having second thoughts about trying to introduce haskell at work.
06:06:56 <tenni1> anyone know of a site with a list/table of comment characters/conventions used in various languages?
06:07:00 <araujo> tenmon, The problem is the conception of getting a language maintream, which means for *many* people, 'be it like C'
06:07:24 <astrolabe> I think that if you aren't very fussy about your code, then being encouraged to use objects is probably a good thing, if only for the sake of modularisation.
06:07:26 <jips> not ture, look at visual basic, it's very different from c :)
06:07:35 <araujo> And bcause of that conception is that we currently have the market full of atrocities like java/c++/c# , among other things.....
06:07:42 <tenmon> araujo: no, actually there are other languages mainstream very different from C (VB, Python, Perl, etc)
06:08:25 <araujo> tenmon, VB is not a language, it is a programm to make programms actually ... but well.. that's other topic
06:08:51 <Philippa> araujo: VB is a language. It happens that much VB code is generated by an IDE, but it's a complete language and has been for some time
06:08:54 <wolverian> vb.net isn't bad. it's the dynamic equivalent of C#.
06:09:01 <tenmon> araujo: saying atrocities to that is personal preference (and I don't know to what language "GREAT" are you comparing to), because I guess you're not comparing paradigms
06:09:13 <Philippa> (since the option to save to ASCII format, pretty much)
06:09:37 <Philippa> tenmon: it's not personal preference at all. I don't know any experienced C++ coder who won't admit the language is a complete mess
06:09:51 <araujo> Philippa, a language should be able to get typed directly into a text editor and compiled in more than one platform imho
06:09:54 <tenmon> I personally hate Java, but I can't say it's an attrocity
06:10:18 <araujo> That's because it is called a language, you can speak it with other persons
06:10:19 <Philippa> then you've not thought about it enough
06:10:22 <tenmon> araujo: I hate VB too, but I must say you're wrong, there are implementations opensource/crossplatform of VB
06:10:34 <Philippa> or possibly just not had to implement the visitor pattern enough times
06:10:51 <astrolabe> araujo: but you imply that there were no programing languages for half of the history of computers.
06:10:54 <Philippa> or realised that the reason the libraries encourage such verbosity is because the language can't support better libraries
06:11:18 <araujo> tenmon, saying atrocity?, how would you call a language that even his own author got problems with?
06:11:31 <araujo> Im not joking about that
06:11:38 <astrolabe> No language is perfect.
06:11:40 <tenmon> araujo: every language has it's own problems
06:11:46 <ozone> haskell sucks, by the way
06:11:48 <ozone> :}
06:11:55 <araujo> Yes, and some got more problems than other
06:11:58 <ozone> (sorry for feeding the trolls)
06:12:04 <tenmon> araujo: that's relative
06:12:14 <musasabi> ozone: but it does it in an elegant and refined manner.
06:12:17 <ozone> Philippa: how goes your supertypes research, btw?
06:12:18 <tenmon> araujo: it depends on what paradigm you are
06:12:35 <araujo> tenmon, ?
06:12:37 <xerox_> musasabi++
06:12:37 <tenmon> of course, C sucks for doing OOP programming, that's what you get C++
06:12:49 <tenmon> and the same for other paradigms
06:12:52 <ozone> musasabi: i wouldn't call easy-to-write space leaks elegant nor refined :)
06:13:51 <Philippa> ozone: 'snot really research by now, it's just a corner of the design space nobody cares about. I'm not sure how much I do these days
06:14:16 <Philippa> the inference algo's effectively covered by any treatment of H-M+subtyping (like all the HM(x) stuff or the one in ATTaPL)
06:14:33 * jips needs an expert
06:14:58 <Philippa> tenmon: if you refuse to acknowledge that it's possible for one language to be outright better than another, we're going to have difficulty talking
06:15:12 <Philippa> C++ is *not* a good OO language
06:15:14 <ozone> Philippa: ah, right
06:15:33 <ozone> Philippa: oh well, at least it kept you amused for a while
06:15:39 <tenmon> Philippa: that's about personal preference in my opinion
06:15:54 <tenmon> but anyways, being it personal preference or not, is relative
06:15:59 <musasabi> ozone: but those are just implementation woes, a suitably clever implementation could warn the user about them.
06:16:06 <tenmon> lol, that could go on forever
06:16:07 <Philippa> tenmon: then you've not been around long enough to remember a succession of imperative languages some of which really were unarguably better than others
06:16:25 <ozone> musasabi: i dunno, i'd consider ghc to be a suitably clever implementation of haskell...
06:16:32 <tenmon> Philippa: any language haves their own strengts and weak points
06:16:43 <Philippa> sure. That doesn't mean they're all "equally good"
06:16:50 <tenmon> some have more strengts and less weak points that others
06:17:06 <tenmon> but it's really relative to say that an "overall" language is better than other
06:17:07 <Philippa> or that it's impossible to have the same strengths as another but more weak points, or to have weaker versions of another language's strengths
06:17:20 <tenmon> because it depends on what features are you comparing and you care more than others
06:17:46 <tenmon> Philippa: no, it's not impossible, you can look for lots of examples
06:18:08 <tenmon> Java haves more features than C++, but haves weak points (the virtual machine) IMHO
06:18:15 <tenmon> anyways, you could argue
06:18:20 <tenmon> but sure there are examples
06:18:27 <flux__> indeed you can :-)
06:18:33 <Philippa> modern C versus original Wirthless Pascal
06:18:40 <flux__> because doesn't java have less features, and the virtual machine is its strong point?-)
06:18:53 <tenmon> flux__: for me it's the worst point
06:19:02 <Philippa> there are significant things that Pascal just *could not do*
06:19:04 <tenmon> any language that haves a virtual machine = NO for me
06:19:22 <tenmon> so you can't say that's not relative or developer preference
06:19:27 <araujo> tenmon, do you find the java-syntax nice?
06:19:30 <Philippa> every language has a VM implied by its semantics
06:19:36 <flux__> all languages are virtual machines, because the cpu provides a virtual memory environment and decodes the instructions to something else ;)
06:19:42 <cpatrick> tenmon: that's an implementation issue. there are java compilers which don't emit JVM code
06:19:44 <flux__> [are run by]
06:19:46 <jips> anyone good with yampa?
06:19:50 <Philippa> it's a question of whether you get to see it as an explicit component along the way
06:20:00 <tenmon> Philippa: not every languages have VMs of 30MB developed by one company
06:20:13 <tenmon> if you see what I mean
06:20:13 <Philippa> no, they just end up with similarly large RTSes and base libraries
06:20:19 <musasabi> The Java VMs are usually large and hard to port.
06:20:31 <Philippa> and I believe there are third-party JVMs available
06:20:46 <tenmon> as also I can't stand languages that haves Garbage Collecting always on
06:20:54 <cpatrick> :-O
06:20:59 <tenmon> but someone could argue that it's a feature
06:20:59 <tennin> no free ones that are compatible with actually existing Java code, though
06:21:00 <flux__> I had been thinking it's not the vm that's difficult to port/reimplement, but rather the provided runtime library, which can be lots of work
06:21:03 <tenmon> for me it's a miss feature
06:21:19 <tennin> at least last I checked
06:21:21 <Philippa> if you don't like GC, WTF are you interested in pure functional languages?
06:21:37 <tenmon> Philippa: because the paradigm
06:21:41 <Philippa> it's technically possible to have a pure functional language with explicit resource control, but I wouldn't want to code in it
06:21:45 <flux__> atleast haskell provides explicit allocation/deallocation?
06:21:53 <tenmon> I can't stand "imperative GC"
06:21:57 <flux__> obviously you must use the language-provided features too
06:22:10 <Philippa> flux__: insofar as Haskell provides the ability to fuck yourself sideways in any manner you choose via the IO monad, yes
06:22:25 <flux__> mm.. sideways..
06:23:06 <Philippa> tenmon: you know that impure functional languages and sufficiently advanced imperative languages are pretty much the same thing, right?
06:23:21 <Philippa> (for values of 'sufficiently advanced' that support an equivalent of higher-order functions)
06:23:21 <tenmon> but that goes, language talking is all relative, whenever one likes one way, other likes other way. That's why there are lot's of languages there, and not only "English" or "Haskell", whatever you say
06:23:26 <flux__> it hadn't occurred to me that memory allocation also has side effects, yet haskell provides that outside the IO monad.. ;)
06:23:44 <xerox_> alloca/malloc ?
06:24:03 <Philippa> flux__: I don't believe it does as such. It provides value construction, and from an IO monad POV that carries side-effects - but they're not visible from elsewhere
06:24:04 <tenmon> Philippa: and that's why I want a pure functional
06:24:09 <flux__> f.ex function call may of may not succeed depending on the amount of available memory.
06:24:18 <flux__> philippa, hmm, that's a good point
06:24:31 <flux__> oom-condition causes an exception that can only be caught inside the IO monad
06:24:32 <xerox_> Philippa: "POV" ?
06:24:47 <xerox_> nm
06:24:47 <flux__> point of view
06:25:09 <jips> the thing that confuses me when they say that haskell has "garbage collection" is that it implies that when during your programming you must explicitly allocate memory, which isn't true for most functional programming
06:25:25 <flux__> I waited a second too short for you to think that ;)
06:25:37 <Philippa> jips: it doesn't imply that at all
06:25:42 <cpatrick> jips: well, type constructors allocate memory
06:25:54 <cpatrick> and cons, of course
06:25:56 <Philippa> cpatrick: no they don't. Data constructors do :-)
06:26:01 <flux__> I can see why it might seem like there's no dynamic memory allocation going on
06:26:14 <cpatrick> Philippa: urgh, true. my bad
06:26:23 <flux__> because there are no references that have 'null' and then they have a value, which is clearly allocated (explicitly), in java and c++
06:26:36 <jips> even data constructors don't really in a sense, since without the step-by-step execution order, it's unclear when exactly the allocation happens
06:26:37 <Philippa> jips: the whole "use of new" thing is recent, lisp&co didn't do it
06:26:39 <flux__> hmh, I was a bit unclear, but maybe I got the message through :)
06:27:19 <Philippa> jips: so if I knowingly call malloc via an unsafeInterleaveIO that's not really explicit memory allocation?
06:27:21 <flux__> so maybe assignment and dynamic allocation are viewed in the java/c++-world to go hand-in-hand
06:27:41 <jips> Philippa: that is, but then you don't get garbage collection :)
06:27:46 <flux__> unsafeInterleaveIO is not haskell98?-)
06:28:23 <Philippa> jips: so suppose I call its GCed equivalent...
06:28:41 <Philippa> flux__: since when did that matter? ;-)
06:28:49 <jips> then you aren't really programming in haskell anymore
06:28:52 <tenmon> do you happen to know if there is a pure functional GUI toolkit? I mean, not an imperative wrapped one
06:29:00 <jips> tenmon: there is fruit
06:29:03 <Philippa> jips: that's sophistry
06:29:05 <flux__> well, I think you're off the track if you're comparing that to a java programmer using new ;)
06:29:23 <Philippa> especially as such a facility is, IIRC, actually part of the FFI
06:29:47 <jips> anyone here good with yampa btw?
06:30:08 <Philippa> for the most part, the current consensus is to bite the bullet and write your GUI in the IO monad. Fruit's worth a look, but it's nowhere near production-ready
06:30:17 <tenmon> what, why it requieres Java?
06:30:57 <Philippa> er, WTF?
06:31:15 <jips> yeah, fruit uses java2d library for graphics
06:31:32 <jips> there is also fudgets but it's not as good as fruit
06:31:34 <tenmon> no thanks, I'll pass
06:31:34 <Philippa> ah, thought it was using something else. What happened to wxFruit?
06:31:37 <astrolabe> jips:  I find it better to ask a technical question here than to try to get people to claim expertise before they know what the question is.
06:32:03 <Philippa> tenmon: it's not ready for real use anyway. If you're going to take a look to see what's possible, don't let the use of a poor implementation technology for the prototype put you off
06:32:04 <jips> well, i'm trying to do a yampa interface to gtk2hs and it's pretty hard
06:32:12 <tenmon> oh, wxFruit?
06:32:20 <jips> wxFruit is also pretty expirimental
06:32:28 <tenmon> that would be great, as I'm using wxWidgets in imperative programs
06:33:02 <Philippa> there's a wxHaskell binding that's fairly usable, though I ended up using gtk2hs for an IRC client in the end because I couldn't get wxHaskell to behave how I wanted
06:33:13 <Philippa> (and then I lost half the source including all the GUI code anyway - d'oh)
06:33:52 <tenmon> from what I've looked at wxHaskell, it's pretty wrapping the toolkit (which is imperative) with Haskell syntax
06:33:54 <jips> i'm trying to do a gtk2hs-fruit now... but it's hard
06:33:57 <Philippa> yes
06:34:04 <jips> tenmon: that's pretty much also the way gtk2hs works
06:34:09 <Philippa> that's the only way available to do good GUIs at the mo
06:34:10 <jips> but gtk2hs is cooler then wxhaskell :)
06:34:16 * xerox_ agrees!
06:34:27 <xerox_> What is this '-fruit' thing?
06:34:43 <tenmon> jips: it must be the api, because otherwise...
06:34:45 <pesco> functional reactive user interface toolkit, I believ.
06:34:47 <Philippa> put simply, purely functional GUIs in a sense more meaningful than "but the IO monad's purely functional!" are still a research topic
06:35:10 <Philippa> xerox: GUIs on top of yampa. Or if you prefer to look at it another way, functionally reactive GUIs
06:35:13 <tenmon> yeah, I know that. Good to know there is progress on that
06:35:28 <Philippa> there's not been huge progress for a year or two now, sadly
06:35:47 <jips> well, it's something that i'm really interested in, and i'm doing my own "research" :D
06:35:56 <Philippa> I'm not sure to what extent the problems were theoretical, to what extent they were practical-and-hard and to what extent it's just lack of effort
06:36:20 <tenmon> HS!! seems google is my friend 
06:36:35 <tenmon> I've found some ideas simmilar to what I was talking about
06:36:41 <tenmon> here : http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
06:36:45 <astrolabe> Sure, as long as you aren't chinese ;)
06:36:59 <tenmon> astrolabe: lol, true
06:37:14 <tenmon> I have hopes again :D
06:37:28 <tenmon> seems I'll not have to create my own language after all
06:37:30 <Philippa> in fairness, I suspect the alternative was the chinese government blocking Google outright
06:37:51 <astrolabe> I'm always hopeful when I start to read a paper.
06:38:03 <pesco> What is it with China and Google?
06:38:08 <tenmon> anyways Haskell or SML could be the intermediate step :)
06:38:28 <tenmon> pesco: censorship of the chinese government
06:38:37 <tenmon> over google searches
06:38:50 <astrolabe> Philippa: Yeah, to be honest, I know it's a problematic issure and I don't understand it.  That's why I put the smiley.
06:39:13 <pesco> tenmon: Wow.
06:39:24 <Philippa> tenmon: true mainstreamability requires more features than either language actually has
06:39:38 <Philippa> we need to offer more power outright than Java et al, not merely different power
06:39:40 <jips> tenmon: yeah, that's a cool presentation. tim sweeney is awesome
06:39:52 <Philippa> (modulo VM-related stuff, I guess - reflection's less of a big deal)
06:39:56 <tenmon> I'm getting very excited about that
06:41:20 <Philippa> myself I'm getting a lot more interested in module systems having realised I've been trying to do some of the advanced stuff and running up against Haskell's capacity to cope
06:42:02 <Philippa> but Haskell and SML can't even adequately type "this function accepts these message types and no others: " without a scary blowup in the number of types you need to declare and the amount of work you need to do converting between them
06:42:28 <xerox_> Coalg types?
06:43:04 <Philippa> for?
06:43:18 <xerox_> Message passing
06:43:32 <Philippa> it doesn't fix the message type problem, you need structural subtyping or the likes
06:43:34 <flux__> philippa, how about ocaml and it's variants?
06:43:40 <flux__> s/'//
06:43:43 <Philippa> flux__: ocaml handles that one okay
06:43:44 <astrolabe> Philippa: Do you know of any languages that could do that elegantly?
06:43:51 <ozone> Philippa: there's a dude in our research group who did a thesis on using associated types in haskell to model ML's functors
06:43:55 <Philippa> at least, AIUI. Haven't done it myself
06:43:57 <xerox_> What is exactly structural subtyping?
06:44:27 <ozone> Philippa: sorry, a comparison of ATs vs functors, to be more exact
06:44:29 <Philippa> xerox: when you do your subtyping based on the presence/absence of fields or possible constructors, rather than on the 'name' of the types ("A <: B")
06:45:07 <Philippa> so for example, {x=1; y = 2} <: {x=1}
06:45:15 <Philippa> (because both have an x field of the appropriate type)
06:45:45 <astrolabe> How do people here cope when they need to look at more than one source file at a time?
06:45:56 <Philippa> with an MDI text editor
06:46:22 <Philippa> I tend not to actually have both visually in view at the same time unless I really really need to though
06:46:38 <astrolabe> I'm using emacs, which is a bit fiddly, but maybe it's just a fiddly job.
06:46:39 <ozone> astrolabe: get a 24" widescreen LCD :}
06:46:54 <astrolabe> ozone:  I lust after those!
06:47:03 <tenmon> talking about that, what Haskell GUI IDEs do you use?
06:47:12 <jips> vim :D
06:47:14 <tenmon> and what features do expect in them?
06:47:26 <jips> there are people making a haskell IDE using haskell
06:47:33 <tenmon> GUI IDEs
06:47:45 <astrolabe> @where hIDE
06:47:45 <lambdabot> http://haskell.org/haskellwiki/HIDE
06:47:53 <Philippa> I'm not using an IDE, just a reasonable text editor and GHCi
06:47:58 <tenmon> vim is a text editor, and emacs is an operating system
06:48:08 <Philippa> I should give the Visual Haskell add-on for Visual Studio another go sometime I guess
06:48:09 <astrolabe> Yeah, I just use emacs and GHCi
06:48:40 <Philippa> I'd /like/ some serious interaction with the typechecker, up to and including letting me check how it reached its conclusions when I've been doing some complicated type hackery or something
06:49:08 <musasabi> There is also Eclipse Haskell support.
06:49:11 <Philippa> it'd be nice to have a (visual but not text-affecting) de-layouter on occasion, I guess
06:50:03 <tenmon> seems doing that wouldn't be easy :P
06:50:35 <astrolabe> I think it would be nice to have subtle sort-of-concentric boxes around sub-expressions.
06:50:46 <xerox_> There is also VisualHaskell.
06:51:00 <xerox_> Ah ops, just said.
06:51:12 * xerox_ has flue
06:51:46 <Philippa> tenmon: it'd be a piece of piss to do so long as the IDE in question already had support for adding characters to the display
06:51:53 <Philippa> the layout rule's well-specified
06:52:09 <tenmon> anyways, I'll add support for Syntax coloring and Compiling, for an IDE I'm in, anyone uses another compiler (other than the default) ?
06:52:28 <Philippa> I suspect I'll find myself using yhc some at some point in the future
06:52:33 <tenmon> Philippa: I see, I missunderstood
06:53:03 * musasabi uses jhc from time to time
06:53:21 <jethr0> Philippa: from what i read, i got the feeling that yhc is a whole program compiler, is that right?
06:54:35 <Philippa> jethr0: nope. I think you're thinking of jhc
06:54:35 <sieni> jethr0: jhc? isn't yhc a byte code compiler?
06:55:38 <jethr0> ah, sry, easy to mix them up :)
06:56:04 <jethr0> @where jhc
06:56:04 <lambdabot> http://repetae.net/john/computer/jhc/
06:56:47 <jethr0> @where yhc
06:56:47 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
06:56:57 <musasabi> jhc is a whole program compiler, although one can create hl-files from libraries which means that the whole library does not need to be recompiled each time you compile a program.
06:58:31 <jethr0> looking at the performance of mlton that seems like a nice approach. although it supposedly doesn't scale for huge programs/libraries.
06:58:37 <MarcWeber> Is someone using hs-plugins? I want to add a haskell scripting interface to vim but I'm not sure how some things are done the best way.
06:58:44 <jethr0> what are the advantages of yhc over ghc then?
07:00:39 <MarcWeber> jethr0 As far as I know does it produce smaller binaries..
07:02:25 <sieni> MarcWeber: hs-plugins might be a good guess
07:02:30 <sieni> MarcWeber: (or improving yi)
07:03:32 <jethr0> MarcWeber: if you're looking for examples, lambdabot and yi are using hs-plugins.
07:03:34 <ozone> MarcWeber: i believe don (the hs-plugins author) has already done a fair bit of research into that; you may want to ask him
07:03:44 <ozone> (as well as writing that 'yi' thing)
07:08:11 <MarcWeber> I'm not sure how to expose the vim scripting functions to to be loaded haskell module or to be compiled haskell code. One way would be passing an interface containing the vim functions. But perhaps there is another way?
07:08:16 <MarcWeber> dons, are you listening?
07:08:43 <ozone> it's 2:11am where he is marc, so i doubt it :)
07:08:47 <astrolabe> @localtime dons
07:08:49 <lambdabot> Local time for dons is Sun Feb 19 02:08:28 2006
07:08:56 <MarcWeber> ;-)
07:09:03 <MarcWeber> @localtime MarcWeber
07:09:04 <lambdabot> Local time for MarcWeber is Sa Feb 18 16:08:48 2006
07:09:16 <MarcWeber> That late? ;-)
07:09:41 <astrolabe> They speed the clocks up at the weekend
07:11:35 <MarcWeber> Wow. lambdabot is great!! You can talk to him privately!
07:11:57 <Igloo> Cool, that must mean I'm great too!  :-)
07:12:15 <astrolabe> Yeah.  But he's a she, so be careful what you say.
07:12:36 <MarcWeber> Igloo or lambdabot?
07:12:42 <MarcWeber> @sex lambdabot
07:12:43 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #haskell.es, #haskell.it, #gentoo-
07:12:43 <lambdabot> haskell, #haskell-overflow, #flippi, #haskell-blah and #haskell
07:12:44 <cpatrick> @vixen Should I be careful what I say to you?
07:12:45 <lambdabot> what about me?
07:12:57 <MarcWeber> lol
07:13:16 <astrolabe> @vixen male or female?
07:13:16 <lambdabot> i'm a girl
07:13:40 <astrolabe> wow
07:28:51 <jips> @seen dcoutts 
07:28:52 <lambdabot> dcoutts is in #gentoo-haskell and #haskell. Last spoke 1 hour, 46 minutes
07:28:52 <lambdabot> and 54 seconds ago.
07:29:12 <jethr0> @vixen asl?
07:29:12 <lambdabot> 19/f/California
07:30:16 <jethr0> @vixen who is the weather in california?
07:30:17 <lambdabot> i dunno, who?
07:30:22 <jethr0> @vixen how is the weather in california?
07:30:23 <lambdabot> it's warm here
07:32:16 <Yagi> hi
07:35:22 <jethr0> hi yagi
07:47:02 * araujo thinks he found a way around the bug
08:40:19 <jethr0> how can i round Doubles to 2 digits?
08:41:00 <andrew_p> hello!
08:41:28 <palomer> jethr0: (/2.0) . round . (*100)
08:41:29 <andrew_p> could you tell me please which module should i import to use Char.isLower in GHC?
08:41:36 <palomer> err
08:41:42 <palomer> jethr0: (/100.0) . round . (*100)
08:41:46 <jethr0> Data.Char
08:41:53 <andrew_p> thanks, jethr0 
08:42:06 <jethr0> palomer: hehe, well, isn't there another way?
08:42:25 <palomer> @hoogle round
08:42:26 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
08:42:26 <lambdabot> Text.Html.background :: String -> HtmlAttr
08:42:27 <andrew_p> jethr0: well, still Not in scope: `Char.isLower'
08:42:54 <jethr0> andrew_p: hugs or ghc?
08:43:17 <andrew_p> nm, jethr0 :) i had to write isLower, not Char.isLower ... GHC 6.4.1
08:43:17 <jethr0> do: "import qualified Data.Char as Char" if you want the "Char." prefix
08:43:38 <andrew_p> thanks for explanation, jethr0 
08:43:43 <jethr0> np
08:44:22 <jethr0> palomer: round produces an integral, and (/) needs a fractional. so this solution is getting longer and longer :)
08:45:04 <palomer> fractional isn't a subclass of integral?
08:46:30 <jethr0> not sure, but i think they are siblings under Num
08:48:09 <palomer> that's odd
08:48:26 <palomer> why in the world are they siblings?
08:49:17 <jethr0> i'll look it up in the standard some time
08:50:07 <palomer> @hoogle round
08:50:08 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
08:50:08 <lambdabot> Text.Html.background :: String -> HtmlAttr
08:50:20 <palomer> @type (/100.0) . round . (*100)
08:50:21 <lambdabot> forall b a.
08:50:21 <lambdabot>           (Fractional b, Integral b, RealFrac a) =>
08:50:21 <lambdabot>           a -> b
08:50:26 <palomer> that works
08:50:36 <palomer> and it returns an instance of two classes
08:50:40 <palomer> what more could you want?
08:51:19 <palomer> > let a = (/100.0) . round . (*100) in a 5.923857987
08:51:20 <lambdabot> Add a type signature
08:51:42 <palomer> > let a = (/100.0) . round . (*100) in a (5.923857987:: (Fractional a => a))
08:51:43 <lambdabot> Add a type signature
08:51:54 * palomer slaps lambdabot
08:52:50 <jethr0> > let a :: Double -> Double; a = (/100.0) . round (*100) in a 3.232
08:52:51 <lambdabot>   add an instance declaration for (Integral (Double -> Double), RealFrac (
08:52:51 <lambdabot> a -> a))
08:53:08 <jethr0> > let a :: Double -> Double; a = (/100.0) . round . (*100) in a 3.232
08:53:09 <lambdabot>  add an instance declaration for (Integral Double)
08:53:19 <jethr0> > let a :: Double -> Double; a = (/100.0) . fromIntegral . round . (*100) in a 3.232
08:53:19 <lambdabot> 3.23
08:53:28 <andrew_p> i'm a haskell beginner and wanted to solve one excercise: write the function that return a number of lowercase letters in a string. here's what i've just written: http://rafb.net/paste/results/0y1Cft28.html ... the problem is that a list and a String are not equal types, so i can't do everything that simple... will study YAHT more, then :)
08:53:40 <palomer> wow, that code sucks
08:54:09 <andrew_p> sure, i haven't written yet anything larger than one-two lines in haskell :)
08:54:23 <xerox_> andrew_p: do you know of higher-order functions yet?
08:54:39 <palomer> andrew_p: countLower x = countLower_ x
08:54:49 <jethr0> > lenght $ filter isLower "Hello World"
08:54:50 <palomer> andrew_p: not your code, jethr0's
08:54:50 <lambdabot>  Not in scope: `lenght'
08:54:50 <andrew_p> xerox_: yes, i have read a lot of theoretical aticles on FP
08:54:54 <jethr0> > length $ filter isLower "Hello World"
08:54:54 <lambdabot> 8
08:54:59 <xerox_> andrew_p: use filter.
08:55:16 <xerox_> They always spoil the fun.
08:55:46 <andrew_p> oh, thanks a lot :) i've knew there's a filter function but didn't guess i should combine it with length :)
08:56:00 <jethr0> xerox_: i'm sorry. sometimes i can't help it. i will restrain myself in the future *i promise*
08:56:32 * xerox_ hands jethr0 a lambda-cookie
08:56:48 * jethr0 accepts it humbly and thanksfully
08:56:51 <palomer> show off
08:57:03 <jethr0> :)
08:57:19 <jethr0> xerox_: any idea how to round a Double to two decimal digits (nicely)?
08:58:01 <xerox_> Yup.
08:59:00 * palomer still thinks (*100.0) . round . (/100.0) should work 
08:59:10 <jethr0> care to tell me? in small educational steps, if you like :)
08:59:18 <xerox_> Hmm... at least I knew it...
08:59:44 <jethr0> palomer: what you just wrote might work. but it has the division/multiplication order reversed :)
08:59:53 <palomer> hmm?
09:00:02 <palomer> oh, righto
09:00:11 <palomer> I meant (/100.0) . round . (*100)-
09:00:47 <xerox_> Let me find it.
09:01:14 <jethr0> xerox_: i know how to do it complicated (thx to palomer). i was wondering about a simple prelude solution
09:02:20 <Cale> I don't think there is one.
09:02:24 <jethr0> :(
09:02:27 <palomer> Cale: why doesn't my solution work?
09:02:33 <xerox_> Gotcha.
09:02:35 <andrew_p> btw, i did not see the '$' sign in YAHT before .. i see that "length $ filter isLower string" is the same as "length (filter isLower string)", interesting...
09:02:53 <palomer> Cale: oh, it's because ghci has to choose between two different show functions?
09:02:57 <Cale> palomer: type error :)
09:03:00 <jethr0> anything to do with numbers is a drag in haskell. i've had to continuously battle the type system, because it wouldn't accept [1,2,3] as list of Doubles without annotation *grr*
09:03:26 <xerox_> > Numeric.showFFloat (Just 2) pi
09:03:27 <lambdabot>  add an instance declaration for (Show (String -> String))
09:03:29 <xerox_> > Numeric.showFFloat (Just 2) pi ""
09:03:30 <lambdabot> "3.14"
09:03:35 <SimonRC> well, you'd have to annotate it in most other langs
09:03:37 <jethr0> nice, thank you very much
09:03:44 <xerox_> You're welcome.
09:04:09 <palomer> one should be able to apply all the double operations to the elements of [1,2,3]
09:04:18 <palomer> jethr0: do you have an example of where it would be useful?
09:04:20 <jethr0> SimonRC: many langs do type coercion for numbers. not that i want that necessarily, but a little more inference would be nice
09:04:21 <Cale> > (* 0.2) [1,2,3]
09:04:22 <lambdabot>  add an instance declaration for (Fractional [a])
09:04:26 <Cale> > map (* 0.2) [1,2,3]
09:04:27 <lambdabot> [0.2,0.4,0.6000000000000001]
09:04:36 <palomer> why isn't fractional a subclasso f Integral?
09:04:50 <Cale> palomer: Fractional and Integral are disjoint.
09:04:55 <palomer> why is this?
09:05:11 <palomer> err, I meant integral a subclass of fractional
09:05:34 <palomer> there should be an uber class real which encompasses all numbers. fractional should go under it and under that should be integral
09:05:36 <SimonRC> jethr0: a rule of thumb is that whenever you find yourself uing explicit recursion, you should see if you can avoid it by using an existing recursive function (fold, filet, map, etc).
09:05:43 <jethr0> palomer: then you could divide 3/4, and the result is not in Integral
09:05:52 <Cale> Fractional is for types of numbers where division always works cleanly (fields) whereas Integral is for rings with division algorithms (Euclidean domains)
09:06:16 <Cale> Sure, every field is an ED
09:06:24 <Cale> but not in an interesting way
09:06:25 <SimonRC> It would be nice to have Nat in the hierarchy, too.
09:06:31 <xerox_> Indeed.
09:06:35 <jethr0> yup
09:06:38 <palomer> Cale: yes, but operationally one would think that integers are a subclass of fractionals
09:06:48 <Cale> oh, no, they aren't
09:06:57 <Cale> There is no integer 3/4
09:07:08 <jethr0> palomer: Integrals aren't closed under all of Fractional's operators (division for example)
09:07:08 <Cale> since 4 isn't invertible in Z
09:07:10 <palomer> right, so / should not be applicable to integers
09:07:21 <Cale> right, and (/) is a method of Fractional
09:07:24 <palomer> we should use div (or mod) instead
09:07:32 <Cale> @type div
09:07:33 <lambdabot> forall a. (Integral a) => a -> a -> a
09:07:36 <Cale> @type (/)
09:07:36 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:07:45 <palomer> Cale: right, and if Integral was a subclass of Fractional, (/) would be applicable 
09:07:49 <SimonRC> Did I tell you that I found a use for the type "data Nat = Zero | Succ Nat"?
09:07:59 <xerox_> Oh, tell us.
09:08:14 <jethr0> palomer: it's again a problem of Liskov Substitution Principle
09:08:20 <Cale> palomer: div would be applicable to fractionals, I suppose
09:08:23 <SimonRC> I think I could use it in a strange way of find shortest-paths in graphs with unit-cost edges.
09:08:31 <Cale> and mod would always give 0
09:08:35 <palomer> Cale: oh no, div should only be for integral values
09:08:48 <palomer> div would be part of the integral class
09:08:56 <Cale> it already is :)
09:09:11 <jethr0> palomer: but Integral would inherit (/) from it's parent class
09:09:22 <xerox_> instance Fractional Integer would give you runtime problems.
09:09:23 <Cale> jethr0: no it wouldn't
09:09:45 <Cale> er
09:09:49 <jethr0> huh?
09:09:51 <SimonRC> The idea is that you consider all possible routes away froma point, most of which would have infinite length.  The advantage or Nat in this circumstance is that you can find the minimum of a finite number and an infinite one, throught laziness
09:10:00 <Cale> maybe it's me who is backwards, let me think about that
09:10:00 <jethr0> Cale: i meant it would inherit the signature
09:10:01 <Cale> yeah
09:10:10 <Cale> I assumed that the sane thing was meant
09:10:11 <xerox_> SimonRC: ah-ha!  Nice one.
09:10:16 <jethr0> :)
09:10:21 <Cale> namely that fractional was a subclass of integral
09:10:31 <SimonRC> I'm not sure the runnign time is actually shorter, though.
09:11:26 <Cale> oh, one bad thing about that is that Integral has toInteger as a method.
09:11:43 <palomer> Cale: so are there still objections to making integral a subclass of fractional?
09:11:43 <Cale> So it's not general Euclidean domains
09:11:53 <Cale> palomer: definitely
09:11:58 <palomer> like what?
09:12:06 <Cale> that makes even less sense conceptually than the other way around
09:12:24 <palomer> oh, righto, I meant fractional a subclass of integral
09:12:38 <jethr0> @type Integral
09:12:39 <lambdabot> Not in scope: data constructor `Integral'
09:12:49 <Cale> @type div
09:12:50 <lambdabot> forall a. (Integral a) => a -> a -> a
09:13:20 <Cale> Integral has quot, rem, div, mod, quotRem, divMod, and toInteger
09:13:32 <Cale> Fractional has (/), recip, and fromRational
09:14:01 <palomer> quot would do the same as (/), rem would almost always return 0, so would mod, etc...
09:14:03 <Cale> 'toInteger' makes it a problem for Integral to be a superclass of Fractional
09:14:18 <palomer> why is toInteger a member of Integral?
09:15:14 <Cale> hmm...
09:15:28 <Cale> Probably not a really good reason
09:15:49 <Cale> I can see putting something like norm :: a -> Integer there, but it wouldn't do the same thing
09:16:20 <palomer> so we agree, integral should be a superclass of fractional
09:16:23 <Cale> probably would want to call it something more obscure than 'norm' too, since not many people would use it
09:16:48 <Cale> yeah, every fractional could be an integral, but only in a trivial way
09:16:59 <palomer> and then we wouldn't have the rounding problem!
09:17:43 <palomer> are fractional exact representations?
09:17:44 <Cale> Well, you'd get another rounding problem
09:17:47 <Cale> :)
09:18:02 <Cale> Rationals are exact, and they're an instance of Fractional
09:18:13 <Cale> but Floats and Doubles aren't.
09:19:06 <palomer> why not make 2 classes, exactfractionals and approximatefractionals
09:19:13 <palomer> one would be the subclass of integral, the other not
09:20:19 <Cale> Well, the Ratio type constructor takes care of most of the common cases of that (fraction fields, anyway)
09:20:37 <jethr0> palomer: then you'd have to "cast" between rationals and doubles!
09:20:38 <palomer> or, we could break the Integral class into 2
09:20:58 <Cale> jethr0: you already do
09:20:59 <palomer> jethr0: that seems logically acceptable to me
09:21:11 <jethr0> hmm
09:21:15 <palomer> BasicIntegral and ExtendedIntegral
09:21:26 <Cale> It's good to require explicit conversions between numeric types.
09:21:45 <palomer> > 1.00000000000001 - 1.00000000000001 
09:21:46 <lambdabot> 0.0
09:22:12 <palomer> do floats and doubles satisfy the addition and subtraction laws?
09:23:58 <palomer>  a - a = 0, a + a - a - a = 0 , etc...
09:24:15 <palomer> > let a = 1.00000000000000001 in a+a+a-a-a
09:24:16 <lambdabot> 1.0
09:24:23 <palomer> > let a = 1.00000000000000001 in a+a+a-a-a-a==0
09:24:24 <jethr0> > (1/3 :: Double) * (2/3 :: Double) - (2/9 :: Double)
09:24:24 <lambdabot> True
09:24:25 <lambdabot> 0.0
09:24:28 <jethr0> damn
09:24:46 <palomer> > (1/3 :: Double) * (2/3 :: Double) - (2/9 :: Double) == 0
09:24:47 <lambdabot> True
09:25:07 <jethr0> pretty amazing. but unless i understand it this is even more dangerous than usual :)
09:25:55 <palomer> this is dangerous
09:25:55 <palomer> bbl
09:26:42 <jethr0> well, in the first place this is great. but when you start to inadvertantly rely on it, then it becomes dangerous
09:39:02 <Cale> > let a = 0.00000001; b = 1000000000 in a + b - a
09:39:02 <lambdabot> 1.0e9
09:39:23 <Cale> > let b = 0.00000001; a = 1000000000 in a + b - a
09:39:24 <lambdabot> 0.0
09:39:37 <Cale> > let b = 0.00000001; a = 1000000000 in a + b - a == b
09:39:38 <lambdabot> False
09:39:47 <Cale> > let b = 0.00000001; a = 1000000000 in a + b - a == a - a + b
09:39:48 <lambdabot> False
09:40:34 <jethr0> yup. is there sth like long double?
09:40:54 <jethr0> and why aren't these number interpreted as fractionals?
09:41:03 <jethr0> ah, rationals
09:41:09 <Cale> @type 0.0001
09:41:10 <lambdabot> forall t. (Fractional t) => t
09:41:22 <Cale> Double is the default Fractional type
09:41:35 <Cale> you can change that using a default declaration
09:41:50 <jethr0> > let b = 1/10000000; a = 10000000 in a + b - a == a - a + b
09:41:51 <lambdabot> False
09:42:06 <Cale> > let b = 0.00000001 :: Rational; a = 1000000000 in a + b - a == a - a + b
09:42:07 <lambdabot> True
09:42:26 <jethr0> k. wouldn't rational make more sense as default case?
09:42:26 <Cale> (or a type signature :)
09:42:31 <Cale> yeah, probably
09:42:38 <jethr0> because it's really hard to input non-rationals in code
09:42:47 <Cale> except that the show instance for rationals isn't too pretty :)
09:43:01 <jethr0> > 0.0000001 :: Rational
09:43:02 <lambdabot> 1%10000000
09:43:23 <Cale> I guess it's sensible
09:43:50 <jethr0> > 1/3 :: Rational
09:43:51 <lambdabot> 1%3
09:44:04 <Cale> > 3%9 
09:44:05 <lambdabot> 1%3
09:44:19 <jethr0> but i guess rational arithmetic is much slower than double...
09:44:30 <Cale> yeah
09:53:53 <jethr0> > 3%9 * 9
09:53:54 <lambdabot> 3%1
09:53:59 <jethr0> > 3%9 * 9.0
09:54:00 <lambdabot> 3%1
09:54:08 <jethr0> > 3%9 * (9.0 :: Double)
09:54:08 <lambdabot> Couldn't match `Ratio a' against `Double'
09:58:13 <dcoutts> jips, pong
09:58:59 <dcoutts> jips, gtkFruit ?! sounds cool.
09:59:55 <dcoutts> jips, if you need more support from gtk2hs then do tell us
10:00:12 <dcoutts> we would like high level apis on top of gtk2hs
10:02:23 <jyp> yes, we do :)
10:08:29 <jips> dcoutts: well, my mission is to take baby steps, so don't expect anything too spectatular or production-ready soon :)
10:09:33 <dcoutts> jips, ok, I hope it goes well
10:09:45 <jips> well, so far i'm still stuck on step zero :|
10:09:57 <dcoutts> what's that?
10:10:54 <jips> i've written a simple "counter" example with a button that increments a number in a text entry. i'm still trying to convert it to FRP style, using yampa
10:11:05 <jips> but i'm stuck how exactly i should do it
10:11:48 <jips> i think i need to build my own layer on top of the yampa SF layer
10:12:18 <jips> and then somehow transform this structure back down to the yampa system
10:12:51 <jips> during the transformation i need to add all the plumbing for the gtk widget signals and actions to modify widgets
10:13:14 <jips> but i think this stuff may be a bit over my head
10:15:18 <araujo> Anyone knows if there exist a way to get the exit code of a process handle other than using getProcessExitCode? 
10:17:36 <musasabi> waitForProcess ?
10:19:05 <dcoutts> jips, sounds complicated :-)
10:19:44 <dcoutts> jips, something that might prove useful is that it is possible to get notified whenever (almost) any widget attribute changes.
10:20:48 <ihope> So if I disable digest mode for the Haskell mailing lists, will I recieve messages individually?
10:25:17 <jips> dcoutts: yes, all widgets attributes will be available, but some sort of analysis will be used to determine only the necessary signals that must be connected to
10:26:26 <dcoutts> jips, we have a semi-automatic way of generating the gtk2hs bindings, you might find some of the same infrastructure useful if you end up trying to cover the whole Gtk+ api.
10:27:51 <ihope> > let foobar in foobar
10:27:52 <lambdabot>  parse error on input `in'
10:28:11 <SimonRC> ihope: What are you trying to do?
10:29:02 <ihope> Just wondering if that was a valid definition.
10:29:22 <ihope> I wanted to defined a "void" function other than void x = seq x (error "Oops!")
10:34:54 <ihope> @djinn Int
10:34:55 <lambdabot> -- f cannot be realized.
10:34:58 <ihope> @djinn Integer
10:34:59 <lambdabot> -- f cannot be realized.
10:35:01 <ihope> Grr.
10:35:03 <ihope> @djinn Bool
10:35:04 <lambdabot> f = False
10:37:00 <ihope> @. pl djinn (a -> b) -> (e -> a) -> e -> b
10:37:01 <lambdabot> f = (.)
10:37:54 <palomer> Philippa: you around?
10:40:20 <ihope> @djinn Not (Not Void) -> Void
10:40:21 <lambdabot> f a = void (a (\ b -> b))
10:40:36 <ihope> @djinn Either Void Void -> Void
10:40:37 <lambdabot> f a =
10:40:37 <lambdabot>   case a of
10:40:37 <lambdabot>   Left b -> b
10:40:37 <lambdabot>   Right c -> c
10:41:16 <ihope> @djinn Not (Either () Void -> ((),Void))
10:41:16 <lambdabot> f a =
10:41:16 <lambdabot>   case a (Left ()) of
10:41:16 <lambdabot>   (_, b) -> b
10:43:36 <ihope> So a value of type (Not (Not a) -> a) depends on either an a or a Not a existing...
10:45:18 <palomer> that's deep
10:46:05 <palomer> if a not a exists, then anything is a not a
10:46:59 <ihope> If a value of type a exists, we can produce a value of type a.
10:48:19 <palomer> say t:: not a, then certainly there are no value of type a, then certainly , given a proof of a, then anything can give us a proof of void
10:48:37 <palomer> bbl
10:48:53 <ihope> Well, yes.
10:49:01 <ihope> @djinn a -> Not a -> Void
10:49:02 <lambdabot> f a b = b a
10:57:29 <jethr0> this is so far beyond me, that i can't even express it :)
10:57:35 <basti_> @index isDigit
10:57:36 <lambdabot> Data.Char
10:57:47 <jips> dcoutts: you mean the bindings to the c api?
10:58:16 <ihope> jethr0: well, it's not important.
10:58:22 <ihope> It's cool, but not important.
10:58:36 <basti_> now i gotta join freenode to find a function  ;)
10:58:52 <araujo> Would anyone of you know what kind of exception gives this kind of message: interrupted (Interrupted system call) ?
10:59:27 <basti_> araujo: interrupted system call is an os-level error
10:59:36 <basti_> which is apparently not handled correctly here
10:59:49 <araujo> basti_, is it the equivalent of EINTR?
10:59:52 <dcoutts> jips, right.
11:00:01 <basti_> i think so yes
11:00:06 <araujo> I see....
11:00:18 <jips> dcoutts: ah well, i plan on using only the gtk2hs api, it seems to support most of gtk, right?
11:00:27 <dcoutts> jips, indeed.
11:00:57 <jips> dcoutts: are you familiar at all with fruit/yampa?
11:00:59 <dcoutts> jips, but what I mean is that you could generate much of your stuff that uses the gtk2hs api.
11:01:33 <dcoutts> jips, I'm not very familiar with them. I only know a little about them.
11:01:35 <jips> dcoutts: i see.. you mean instead of manually going through all of the widgets and their specific signals, automatically generate all this?
11:01:50 <dcoutts> jips, yes, semi-automatically generate most of it
11:02:26 <dcoutts> it'd save you quite a bit of time anyway
11:02:33 <jips> dcoutts: that's an interesting idea, but for way in the future... i still need to figure out the basic design of the system
11:03:32 <dcoutts> jips, indeed, so when you know what you'd do for each widget/attribute/signal etc you can mostly generate it. But yes to start with you just need a design and something that works with a few sample widgets.
11:03:43 <jips> exactly
11:03:44 <dcoutts> before it can be scaled up to cover the whole lot
11:04:50 <ihope> Nucular, nucular...
11:26:34 <jethr0> araujo: it is possible to get that error when you fork too frequently or call getProcessExitCode too frequently.
11:41:47 <micty> what is . ?
11:41:56 <basti_> function composition
11:41:59 <basti_> @type (.)
11:41:59 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
11:42:17 <basti_> pronounce it "after"
11:42:21 <ihope> (x . y) z = x (y z)
11:43:25 <micty> ah
11:43:33 <micty> 10x
11:48:14 <araujo> ugh, he's gone
11:53:11 <ihope> What's the fastest known Haskell prime number list?
12:22:33 <tenmon> Haskell rulez, Tim too!
12:22:40 <tenmon> bye
12:25:25 <ihope> I'd love a logarithmic time prime list.
12:26:20 <musasabi> Generating a list of N elements in O(log(n)) ?
12:28:06 <ulfdoz> would make more sense, if n is highest prime, I think. But that could also be quite hard as not much is known about the distribution of primes over all numbers.
12:28:25 <basti_> i thought.
12:28:52 <ihope> E.g. the first prime takes 1 millisecond, the 10th takes 2ms, the 100th takes 3ms...
12:29:20 <ihope> Would that be O(n log n)?
12:29:33 <palomer> no, that would be O(log n)
12:29:34 <basti_> no thats O(log n)
12:29:51 <basti_> n log n would be 1, 20, 300
12:29:56 <ihope> Erm, generating a list of n elements, I mean.
12:30:45 <musasabi> ihope: think of generating a list of the numbers 1,2,3,...
12:31:14 <musasabi> ihope: if generating 100 numbers takes 1ms, how long does generating 1000 take?
12:31:39 <ihope> At least 10ms...
12:33:32 <musasabi> ihope: ok.
12:34:11 <musasabi> ihope: now if generating 100 primes takes 1ms, how would generating 1000 of them takes less than 10ms ?
12:34:25 <ihope> It wouldn't.
12:34:44 <ihope> I'm suggesting O(log n) for each prime.
12:36:14 <palomer> how do I get a term foldM1_ of type (a -> a -> m b) -> [a] -> m () ?
12:36:41 <palomer> heck, (a -> b -> m c ) -> [a] -> m ()
12:36:51 <basti_> copy foldM1 and forget the results?
12:36:59 <basti_> and/or use >>
12:37:06 <ihope> @index foldM1
12:37:07 <lambdabot> bzzt
12:37:11 <palomer> @hoogle foldM1
12:37:12 <lambdabot> No matches found
12:37:21 <palomer> @hoogle foldlM1
12:37:21 <lambdabot> No matches found
12:37:31 <basti_> uhmh.
12:37:33 <palomer> @hoogle foldM
12:37:34 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m
12:37:34 <lambdabot> a
12:37:34 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
12:37:34 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c ->
12:37:34 <lambdabot> c) -> c -> m (gr a b) -> m c
12:37:39 <basti_> ahh.
12:37:54 <ihope> @djinn Maybe a -> Maybe ()
12:37:55 <lambdabot> f a =
12:37:55 <lambdabot>   case a of
12:37:55 <lambdabot>   Nothing -> Nothing
12:37:55 <lambdabot>   Just _ -> Just ()
12:38:02 <palomer> foldlM1 =  (\f (x:xs) -> Control.Monad.foldM f x xs)
12:38:12 <palomer> foldlM1_ =  (\f (x:xs) -> Control.Monad.foldM_ f x xs)
12:38:22 <palomer> however, the second one isn't general enough
12:38:27 <palomer> @type (\f (x:xs) -> Control.Monad.foldM_ f x xs)
12:38:28 <lambdabot> forall a
12:38:28 <lambdabot>                   (m :: * -> *).
12:38:28 <lambdabot>                 (Monad m) =>
12:38:28 <lambdabot>                 (a -> a -> m a) -> [a] -> m ()
12:39:05 <palomer> that should be (a -> b -> m c) -> [a] -> m ()
12:39:51 <ihope> @type Control.Monad.Cont.Cont (\x -> x True EQ)
12:39:51 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
12:39:51 <lambdabot>   Expected type: t1 -> t
12:40:54 <palomer> foldM1_ f (x:xs) = f x >> foldM1_ f xs ; foldM1_ f [] = return () <-is there a way to shorten this?
12:42:09 <ihope> Hmm...
12:42:26 <ihope> Something with ((f x >>=) . (foldM1_ f))
12:43:12 <ihope> @type sequence
12:43:13 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:43:52 <ihope> @type foldM1_ f (x:xs) = f x >> foldM1_ f xs ; foldM1_ f [] = return () in foldM1_
12:43:53 <lambdabot> parse error on input `='
12:44:03 <ihope> @type let foldM1_ f (x:xs) = f x >> foldM1_ f xs ; foldM1_ f [] = return () in foldM1_
12:44:04 <lambdabot> forall a
12:44:04 <lambdabot>                                (m :: *
12:44:04 <lambdabot>                                  -> *)
12:44:04 <lambdabot>                                a1.
12:44:04 <lambdabot>                             (Monad m) =>
12:44:06 <lambdabot> [3 @more lines]
12:44:10 <ihope> @more
12:44:10 <lambdabot>                             (a -> m a1)
12:44:10 <lambdabot>                             -> [a]
12:44:12 <lambdabot>                             -> m ()
12:44:35 <palomer> that's not quite it
12:44:36 <arjanb> @type mapM_
12:44:36 <lambdabot> forall (m :: * -> *) a b.
12:44:36 <lambdabot>    (Monad m) =>
12:44:36 <lambdabot>    (a -> m b) -> [a] -> m ()
12:45:21 <palomer> @type \f lst -> foldl (>> f) lst
12:45:22 <lambdabot> forall a b.
12:45:22 <lambdabot>           (Monad ((->) b)) =>
12:45:22 <lambdabot>           (b -> b -> a) -> (b -> a) -> [b] -> b -> a
12:47:11 <palomer> @type \f lst -> foldl (\x -> f >> return x ) lst
12:47:12 <lambdabot> forall a a1 b.
12:47:12 <lambdabot>                 (Monad ((->) b)) =>
12:47:12 <lambdabot>                 (b -> a1) -> a -> [b] -> a
12:47:34 <palomer> that's a freaky one:o
12:48:43 <ihope> @type \a -> a (\x y z -> x z (y z)) (\x y -> x)
12:48:44 <lambdabot> forall t
12:48:44 <lambdabot>                   t1
12:48:44 <lambdabot>                   t2
12:48:44 <lambdabot>                   t3
12:48:44 <lambdabot>                   t4
12:48:46 <lambdabot> [5 @more lines]
12:48:56 <ihope> Why the line breaks?
12:49:06 <palomer> @more
12:49:07 <lambdabot>                   t5.
12:49:07 <lambdabot>                (((t3 -> t2 -> t1) -> (t3 -> t2) -> t3 -> t1)
12:49:07 <lambdabot>                 -> (t4 -> t5 -> t4)
12:49:07 <lambdabot>                 -> t)
12:49:07 <lambdabot>                -> t
13:44:52 <davidhouse> dcoutts, ping
13:46:08 <davidhouse> okay, i'll ask generally.
13:47:01 <palomer> so there are normal function and infix operators
13:47:02 <davidhouse> hmm... actually hang on, i might have just thought of a solution
13:47:06 <palomer> what would (,) be called?
13:47:09 <palomer> outerfix?
13:47:21 <basti_> "different"? ;)
13:47:36 <davidhouse> yeah, what do you call operators used (+) 5 3 like that?
13:47:36 <Mortis_kruuul> http://www.metalcave.ovh.org ;)
13:47:40 <basti_> circumfix?
13:47:42 <davidhouse> polish notation or something
13:47:51 <basti_> davidhouse: prefix or polish notation yes
13:47:55 <gzl> prefix
13:49:04 <palomer> I like circumfix
13:49:22 <palomer> so a function is either infix, prefix or circumfix
13:49:25 <palomer> why not have postfix functions?
13:49:31 <basti_> some people have it
13:49:36 <palomer> I mean, as part of haskell
13:49:37 <basti_> HP calculators, or forth people for example
13:49:46 <basti_> because it's hard to parse -both- ways
13:49:52 <basti_> you have to pick one way
13:50:00 <palomer> well, prefix would be the default
13:50:08 <davidhouse> what's circumfix?
13:50:22 <davidhouse> "5 + 3" <- that?
13:50:32 <davidhouse> wait no, that's infix
13:50:32 <palomer> (5,3) <-this
13:50:41 <palomer> or [5]
13:50:53 <davidhouse> palomer: what are the operators there
13:51:10 <palomer> davidhouse: []
13:51:17 <davidhouse> hmm
13:51:26 <davidhouse> and in the first?
13:51:30 <ihope> (:[])?
13:51:33 <palomer> (,)
13:51:34 <davidhouse> (,) or something?
13:52:18 <ihope> @kind
13:52:19 <lambdabot> parse error (possibly incorrect indentation)
13:52:23 <ihope> @kind (,)
13:52:24 <lambdabot> * -> * -> *
13:52:25 <davidhouse> @type ((,))
13:52:26 <lambdabot> forall a b. a -> b -> (a, b)
13:52:45 <palomer> @type (,)
13:52:46 <lambdabot> forall b a. a -> b -> (a, b)
13:52:53 <xerox_> G'night.
13:52:57 <palomer> night xerox 
13:55:20 <palomer> > let a -> b = a + b in 3 -> 4
13:55:21 <lambdabot>  parse error on input `->'
13:55:36 <palomer> hrmphrm
13:56:49 <davidhouse> > let (->) a b = a + b in 3 -> 4
13:56:49 <lambdabot>  parse error on input `->'
13:56:57 <davidhouse> guess that can't be made prefix
13:57:15 <palomer> it's a keyword
13:57:18 <palomer> \x -> 5
13:57:24 <davidhouse> it has special meaning, i.e. in lambda, case
13:58:13 <ihope> Does pattern matching on numbers use (==)?
13:58:18 <palomer> how does haskell decide if a type constructor is infix or not?
13:59:42 <davidhouse> palomer: i think if the name is alphanumeric, it's prefix, otherwise infix
14:00:31 <palomer> numeric?
14:00:47 <palomer> btw, is it possible to put guards at function definitions (and not just at case statements) ?
14:00:59 <davidhouse> palomer: yep
14:01:30 <davidhouse> > let a <=> b | a < b = -1 | a > b = 1 | a == b = 0 in 10 <=> 20
14:01:30 <palomer> how would the syntax work?
14:01:31 <ihope> > 4four
14:01:31 <lambdabot> -1
14:01:32 <lambdabot>  Not in scope: `four'
14:01:36 <ihope> Whoa.
14:01:39 <ihope> > 4undefined
14:01:40 <lambdabot>  add an instance declaration for (Num (a -> a1))
14:01:40 <lambdabot>   In the definition of `fjj': fjj = 4 undefined
14:01:40 <lambdabot>   In the definition of `v': v = let fjj = 4 undefined in take 2048 (show
14:01:40 <lambdabot> fjj)
14:02:29 <ihope> So these things can't begin with numbers.
14:02:39 <palomer> can you nest guards?
14:02:53 <ihope> Like how?
14:03:00 <jethr0> *yuch*, nesting guards would be really evil
14:03:18 <davidhouse> can you use guards in lambda expressions?
14:03:21 <jethr0> why not use case
14:03:33 <davidhouse> true.
14:03:37 <dcoutts> davidhouse, ask me tomorrow, I'm off to see a film
14:03:42 <davidhouse> dcoutts: sure.
14:03:47 <jethr0> aren't pattern guards just slight syntactic sugar for case anyway?
14:03:48 <davidhouse> dcoutts, have a nice time :)
14:03:52 <dcoutts> ta
14:05:03 <ihope> jethr0: isn't pattern matching just syntactic sugar?
14:05:31 <davidhouse> ihope: for what?
14:05:34 <jethr0> i meant that in a constructive way :).
14:05:57 <ihope> davidhouse: if and lambdas?
14:06:16 <ihope> Isn't "foo bar = baz" just syntactic sugar?
14:06:17 <jethr0> so instead of writing "(\x | x == 1 = 2 | otherwise = x)" you write "(\x -> case x of ...)"
14:06:26 <jethr0> so guards are not really necessary here
14:06:51 <ihope> \x -> if x == 1 then 2 else x
14:07:10 <jethr0> yes, but that doesn't scale so nicely for more than 2 cases.
14:07:36 <ihope> Does (>>=) scale well for really big monadic things?
14:08:08 <jethr0> and maybe complicated functions shouldn't be done as lambda anyways in haskell. that's what we have "where" for
14:08:34 <jethr0> ihope: are you in your sceptical phase right now?
14:08:56 <jethr0> and yes, if the complexity is hidden by the monad.
14:09:22 <ihope> Aren't classes just syntactic sugar?
14:10:04 <sieni> ihope: syntactic sugar for what?
14:10:08 <jethr0> yup, you're definitely in a phase :)
14:10:12 <ihope> :-)
14:10:14 <jethr0> lambda calculus
14:10:18 <davidhouse> don't tell me, if and lambdas.
14:10:43 <ihope> Aren't lambdas just syntactic sugar?
14:11:56 <jethr0> ihope: if you mean lambda-calculus lambda, then rather "no"
14:12:41 <ihope> Syntactic sugar for SK calculus? >:-)
14:13:00 <jethr0> hmm, or maybe even there. "\x -> x" might be syntactic sugar for "(x,x)"
14:13:08 <jethr0> true
14:13:08 <palomer> do you guys agree that strings have no place in internal representations?
14:13:17 <jethr0> ?
14:13:19 <ihope> Um...
14:13:24 <ihope> Boxed strings?
14:13:28 <jethr0> ah, you mean dispatching on strings?
14:13:54 <jethr0> as in "if whichAction = "enter" then enter else leave" ?
14:14:03 <palomer> for example, to represent a type constructor internally
14:14:07 <palomer> when you're doing type inference
14:14:17 <palomer> I'm tempted to represent it with an STRef ()
14:14:35 <jethr0> compiler construction?
14:14:38 <palomer> yeah
14:15:10 <davidhouse> > 1/0
14:15:11 <lambdabot> Infinity
14:15:29 <palomer> @index Infinite
14:15:30 <lambdabot> bzzt
14:15:34 <davidhouse> @index Infinity
14:15:35 <lambdabot> bzzt
14:15:51 <palomer> @type Infinity
14:15:52 <lambdabot> Not in scope: data constructor `Infinity'
14:16:01 <palomer> eh?
14:16:01 <davidhouse> @type (/)
14:16:02 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:16:15 <ndm> @hoogle inf
14:16:16 <lambdabot> Data.Generics.Basics.Infix :: Fixity
14:16:16 <lambdabot> Graphics.UI.GLUT.Window.Info :: Cursor
14:16:16 <lambdabot> Graphics.UI.ObjectIO.CommonDef.Infinite :: Bound
14:16:25 <ndm> @hoogle+
14:16:25 <lambdabot> Text.ParserCombinators.Parsec.Expr.Infix :: GenParser t st (a -> a -> a) -
14:16:25 <lambdabot> > Assoc -> Operator t st a
14:16:25 <lambdabot> Language.Haskell.TH.Lib.InfoQ :: Q Info
14:16:25 <lambdabot> Language.Haskell.TH.Lib.infixP :: PatQ -> Name -> PatQ -> PatQ
14:16:25 <palomer> I think that's the error message
14:16:29 <davidhouse> 1/0 != Infinity in mathematics.
14:16:38 <palomer> oh, let's not get started with that
14:16:51 <palomer> if we add 1/0 sa an axiom and we remove other axioms then it's fine
14:16:56 <palomer> 1/0=infinity
14:17:03 <davidhouse> okay, yes.
14:17:19 <ihope> > (\(1/0) -> 3)
14:17:20 <davidhouse> just wondering why it might be useful to return "Infinity" when someone does 1/0
14:17:20 <lambdabot>  Parse error in pattern
14:17:38 <ihope> > 1/(1/0)
14:17:38 <araujo> jethr0 araujo: it is possible to get that error when you fork too frequently or call getProcessExitCode too frequently.
14:17:39 <lambdabot> 0.0
14:17:49 <araujo> jethr0, yeah, precisely, im doing both thngs :-)
14:17:55 <palomer> > 1/(2/0))
14:17:55 <lambdabot>  parse error on input `)'
14:17:58 <palomer> > 1/(2/0)
14:17:59 <lambdabot> 0.0
14:18:02 <jethr0> so, have you solved it?
14:18:10 <ihope> > 1/(0/0)
14:18:12 <lambdabot> NaN
14:18:15 <davidhouse> > 0/0
14:18:16 <lambdabot> NaN
14:18:20 <ihope> > (0/0)/0
14:18:21 <lambdabot> NaN
14:18:22 <davidhouse> that would be more useful to return.
14:18:31 <davidhouse> > (0/0)/(0/0)
14:18:31 <ihope> NaN /= infinity
14:18:32 <lambdabot> NaN
14:18:45 <ihope> > (1/0)/(1/0)
14:18:46 <lambdabot> NaN
14:19:08 <davidhouse> ihope, why should 1/0 be infinity?
14:19:23 <ihope> Because it's infinite.
14:19:29 <davidhouse> says who?
14:19:44 <ihope> ...
14:19:49 <ihope> Define infinity.
14:20:09 <jethr0> the question is what "1/0 - 1/0" is.
14:20:22 <ihope> > 1/0 - 1/0
14:20:23 <lambdabot> NaN
14:20:25 <davidhouse> an entity (not a number) which we define some basic arithematic on.
14:20:31 <Palle> lim x->\infty 1/x = \infty ... but 1/0 is an illegal operation..
14:20:32 <jethr0> no, i mean "should be"
14:20:38 <davidhouse> jethr0: in mathematics, infinity - infinity is undefined.
14:20:47 <davidhouse> Palle, right.
14:21:03 <ihope> Well, why make it NaN when it can be Infinity?
14:21:05 <davidhouse> Palle, but it's possible to construct other limits of the form 1/0 that aren't equal to infinity
14:21:50 <Palle> Such?
14:21:52 <davidhouse> ihope, what are you planning to do, usefully, with infinity?
14:22:06 <jethr0> davidhouse: it isn't all that simple. there's the matter of several infinities with different "sizes"
14:22:20 <Palle> Such as? even
14:22:27 <jethr0> i haven't studies it myself, but |Real| > |Natural|
14:22:31 <davidhouse> jethr0: yeah, i'm a mathematician, i know what you mean.
14:22:52 <davidhouse> two sets are said to be the same size if you can match up every element of one with an element of the other.
14:22:59 <jethr0> yup
14:23:13 <davidhouse> it's easy to do with with, say, the naturals and the evens. just divide every even number by 2, or multiply every natural by two.
14:23:21 <jethr0> a friend of mine studied transfinite induction, or whatever it was called :)
14:23:36 <davidhouse> you probably mean the ordinals.
14:23:48 <davidhouse> transfininty induction is a useful technique that uses the ordinals.
14:23:55 <jethr0> k
14:24:01 <davidhouse> *transfinite
14:24:55 <davidhouse> Palle: 1/x -> -infty (x->0-)
14:24:59 <jethr0> yes, but my point was that this makes infinite hard to define. although i'm sure there's a definition. i would go with "a value greater than any arbitrarily picked one"
14:25:42 <jethr0> s/picked/high picked/
14:25:44 <Palle> davidhouse, Ofcourse yes.
14:26:00 <davidhouse> Palle, -infty /= infty
14:26:09 <Palle> Transfinite induction would be a nice thing to know to prove some function programs
14:26:13 <davidhouse> jethr0: yeah. you could define infinity as whatever you like
14:26:21 <jethr0> hehe. _|_
14:26:39 <davidhouse> jethr0: what you've basically described is omega, the first ordinal that isn't the successor to any other ordinal. it's |Integers|.
14:26:40 <Palle> davidhouse, Makes sense. :)
14:27:49 <jethr0> ah, good to know
14:28:20 <davidhouse> and |integers| = |any infinite subset of the integers|
14:28:24 <jethr0> so, is omega in the Reals or is that thinking too linearly
14:28:26 <Palle> (omega is not the a lower bound in this context i guess :))
14:28:45 <davidhouse> jethr0: no, the reals are something different.
14:28:46 <jethr0> i was using _|_ as a value outside the domain :)
14:29:02 <davidhouse> i'm not entirely sure how the ordinals fits into talking about reals, etc.
14:29:08 <jethr0> out-of-band information
14:29:45 <jethr0> so, ordinals are degrees of infinity? i though ordinal numbers == natural number
14:29:58 <jethr0> but then i'm not very good at math terms in english
14:30:55 <davidhouse> "ordinal number" in normal english means something like 1st, 2nd, 3rd as opposed to cardinals which are 1, 2, 3.
14:31:08 <jethr0> k
14:31:11 <Palle> Afair, The definition of ordinal is that you know the successor and the precessor of a number.
14:31:14 <Palle> right?
14:31:27 <davidhouse> no, that misses a basic property of the ordinals.
14:31:54 <davidhouse> the ordinals has a lot of values which have successors and predecessors.
14:32:13 <Palle> Hm?
14:32:28 <davidhouse> a naive way to picture it is that the ordinals go 1, 2, 3, ... omega, omega + 1, omega + 2 ... omega_2, ...
14:32:31 <astrolabe> An ordinal is an isomorphism class of totally ordered sets with the property that every non-empty subset has a least element IIRC
14:33:07 <davidhouse> there are successor ordinals (those that have predecessors: those that are the successor to some other ordinal) and there are non-successor ordinals (those that aren't).
14:33:10 <Palle> Aha
14:33:32 <davidhouse> 1, 2, 3, omega + 1, omega + 2 are successor ordinals, omega, omega_2 etc. are nonsuccessor ordinals.
14:33:56 <astrolabe> I like the ordinals
14:35:55 <astrolabe> the first few are 0,1,2,...,\omega,\omega+1,\omega+2,...,2\omega,2\omega+1,...,3\omega,...,4\omega,...,\omega^2,...,\omega^3,...,\omega^\omega,...,\omega^\omega^omega  etc.
14:36:39 <davidhouse> http://efnet-math.org/~david/mathematics/ordinals.pdf is a nice set of notes on ordinals, although it's quite mathematical.
14:36:52 <davidhouse> it was written by the wonderful Kit in efnet's #math.
15:30:26 <jethr0_> which packages would i use for screen scraping in haskell? i.e. recursing over links, extracting parts of pages, ...?
15:30:42 <palomer> foldM is a fold left or a fold right?
15:31:40 <jethr0_> @hoogle foldM
15:31:41 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m
15:31:41 <lambdabot> a
15:31:41 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
15:31:41 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c ->
15:31:41 <lambdabot> c) -> c -> m (gr a b) -> m c
15:31:42 <palomer> grr, there's no scanM
15:32:02 <palomer> I'm guelling foldM is from the left
15:32:07 <jethr0_> hmm, i think right, but i might be wrong
15:32:40 <jethr0_> Note that foldM works from left-to-right over the list arguments
15:34:02 <palomer> yeah, like foldl
15:37:47 <jethr0_> yup
15:38:24 <palomer> http://www.rafb.net/paste/results/H0lmOA31.html
15:40:28 <palomer> (if anyone has anything to say about that post, would be appreciated)
15:41:35 <sieni_> \omega_2 is a nice example of a limit ordinal especially since it's the first ordinal with cardinality larger that the first uncountable ordinal
15:41:39 <jethr0_> hmm, i can't see a difference. but it's a lot to take in :)
15:42:09 * Saulzar is bewildered by the indent style
15:42:46 <jethr0_> Saulzar: that's lisp style. i do it like that too. but try not to get too deep
15:44:55 <jethr0_> palomer: i take that back. i don't understand the code...
15:49:42 <palomer> you guys don't understand the code?
15:49:51 <palomer> I could do this with scanM much cleaner
15:50:31 <jethr0_> palomer: it's hard to get up to speed, not knowing what it's doing or what the function interfaces are
15:50:59 <astrolabe> make a scanM then
15:52:02 <Saulzar> Yep, and the variables are all different 
15:52:21 <palomer> hmm?
15:52:38 <palomer> each can fit in the same context
15:53:25 <jethr0_> nm
15:56:14 <jethr0_> *grr*, crypto lib seems to need greencard, but greencard won't compile with "unrecognised flags: -fno-prune-tydecls"
16:04:30 <Saulzar> Hmm, I take it that it is nesescary to unload modules before loading them again with plugins
16:06:35 <jethr0_> i'm trying to install cabal-get, but it aborts with "Setup: can't find source for System.GPG in ["."]"
16:07:16 <jethr0_> this is starting to annoy me. http->crypto->greencard->cabal-get and at every point i get missing deps or non-compiling packages
16:10:02 <jethr0_> as nobody is answering i'll just go on ranting
16:10:53 <ndm> jethr0_: have you reported all these issues to the package maintainers?
16:11:53 <dons> Saulzar, yes. or use reload. you're talking about hs-plugins?
16:11:56 <jethr0_> it's really too bad that the prelude / standard libs aren't extended more regularly. the existance of missingh and need of all realistic packages for non-standard libs proves this
16:12:09 <jethr0_> ndm: no, i'm still in the process of figuring things out
16:12:12 <dons> ndm, btw, thanks for the wiki hints. i hadn't spotted them (using w3m, a text-mode browswer)
16:12:46 <ndm> jethr0_: the last time the Prelude was extended wsa by hugs,. and there are still non-compiling books/source as a result!
16:12:55 <ndm> dons, no probs
16:12:59 <jethr0_> :)
16:13:18 <Saulzar> dons, Yeah - I was just naively calling pdynload again, which gave the same value back
16:13:29 <jethr0_> but IMHO there are some non-debatable functions that might be added. like "comparing" for instance
16:13:48 <dons> Saulzar, unless you don't trust the src at all, I'd use load/unload/reload
16:14:12 <dons> pdynload is really for when you only know that it's haskell, but nothing else.
16:14:28 <dons> if you wrote the code yourself, its more efficient to use load/reload
16:14:54 <Saulzar> It is intended for untrusted code
16:14:59 <dons> ok.
16:15:25 <dons> so you'll have to do your own unload.
16:15:29 <jips> hi dons, any word about that file closing bug?
16:15:42 <dons> haven't looked at it yet. bit swamped with work.
16:15:45 <Saulzar> It seems very cool :)
16:15:57 <dons> perhaps if it's holding you up, you could submit a patch, jips?
16:16:09 <dons> that would be the fastest way I suspect.
16:16:17 <dons> and you get @karma points ;)
16:16:26 <jips> hm... ok i guess i'll take a deeper look at it next weekend :)
16:16:57 <dons> i can guide you, if you like. you'll probably just want to look at the 'merge' functoin
16:17:48 <jips> ok
16:24:37 <jethr0_> dons: you think you could give me some hints to get the http package going?
16:26:19 <jethr0_> nm, i'm giving up for today
16:27:19 <dons> ndm, a question, do you think I should link to the HWN wiki page from the haskell.org frontpage in "The Community" section?
16:27:40 <ndm> dons, yes
16:27:41 <dons> or is there a subpage that is more appropriate?
16:28:24 <ndm> dons, its updated once a week - so shows that haskell is alive and active
16:29:06 <ndm> and HWN wiki page?
16:29:20 <ndm> i didn't realise it was a wiki (would be a good idea)
16:30:33 <dons> oh, I just have a page pointing to the archives and so on.
16:30:43 <dons> but maybe actually taking articles via the wiki would be good..
16:40:20 <MarcWeber> dons: I'd like to add haskell scripting support to vim (using hs-plugins). I'd like to use the eval command. Of cause the script should be able to access some vim funcions. Is this done by passing an interface containing wrappers of vim functions to the haskell script passed to eval?
16:42:30 <dons> ah, very interesting. i actually have an honours project here at unsw for someone to do just this :)0
16:45:04 <MarcWeber> My problem: I'm still lacking some knowledge ;-)
16:45:34 <dons> so if you're looking to study in .au... ;)
16:45:44 <dons> ok. let me think..
16:46:29 <MarcWeber> It would be cool to add this and then implement some kind of intellisense, code aids whatsoever
16:46:42 <dons> I think you'll need two things. 1) a binding to the hs-plugins eval from C. (you get this pretty much for free with hs-plugins). and 2) an FFi bindings from Haskell back into the vim api.
16:47:08 <dons> so then vim can call some haskell code, which can freely call back into vim for data and  library stuff
16:47:35 <dons> have a look at some of the other language bindings to vim for a sense of how this works
16:48:29 <dons> (it should be easier to do in Haskell as our FFI is so powerful)
16:48:44 <MarcWeber> I did that already.. The python binding just calls a eval function so that you can use eval("whatever vim command") ;-)
16:49:53 <dons> ah, so they have an eval that calls back into vim?
16:50:07 <dons> that's point 2. in my list above.
16:50:37 <MarcWeber> Yes.
16:51:51 <MarcWeber> They define a python module consinting of some functions.. This python module is not much more than an array of (name, function pointer, how to call info) for python
16:53:03 <dons> ah, it's simpler than I state - you probably don't need hs-plugins to start with.
16:53:29 <dons> so I'd start by trying to write a small Haskell function, say 'reverse', that you can call from vim.
16:53:36 <MarcWeber> There are some tools like c2hs, hdirect.. Which one would you recommend?  Concerning 1) There is an example in hs-plugins returning a 0 terminated string
16:58:24 <dons> i think at first you don't need to consider hs-plugins. Try jsust linking in a single Haskell object file (not a dynamically created one).
16:58:44 <dons> i.e. write a haskell module to modify some string. then try to call it from vim, and get the resullt.
17:03:02 <dons> step 2 would then be to have that Haskell module call back into vim for some operatoins.
17:03:32 <dons> then step 3 and finally, you'd link in hs-plugins to create new haskell code on the fly.
17:05:55 <MarcWeber> Is there also a step 4 such like compiled module caching as the eval progs from the hs-plugins testsuite directory need about 0,6 seconds to run... But I agree that I should try the first steps first.
17:08:31 <dons> yep, or step 5. use ghc-api to call the ghci interpreter for the eval.
17:08:59 <dons> with hs-plugins you'd be writing larger amounts of code, I think. to offset the cost of the 0.5s time  to compile to native code.
17:09:09 <dons> so things like syntax parsers and such.
17:09:47 <dons> so you'll have to get very familiar with the FFI, from C and to C.
17:11:30 <MarcWeber> I know now. I thought hdirect can do this for me but I get some errors ;-)
17:20:23 <dons> c2hs can be another option
17:20:38 <dons> it's used in gtk2hs, for exampl.
17:20:46 <dons> or maybe the api is small enough thht you can do the binding by hand?
17:20:52 * dcoutts reccomends c2hs
17:20:53 <dons> or with hsc2hs for a little syntactic support
17:21:20 <dons> I'm not sure anything but c2hs has been used in the last couple of years?
17:21:24 <dons> (is that fair to say?)
17:21:58 <dons> or is the ffi binding community a bit more diverse?
17:21:59 <dcoutts> sure, xerox's cairo bindings are a very nice example of the use of c2hs
17:23:01 <MarcWeber> Thanks. That is exactly what I wanted to know.
17:36:50 <palomer> hrmph
17:36:56 <palomer> @seen Philippa 
17:36:57 <lambdabot> Philippa is in #scannedinavian, #haskell-overflow, #haskell-blah and #
17:36:57 <lambdabot> haskell. I don't know when Philippa last spoke.
17:37:07 <palomer> you don't know?
17:37:17 <palomer> you useless dog of a bot!
17:39:09 <Korollary> Philippa doesn't speak. She waits.
17:52:09 <Rawr321> Can someone help me understand Haskell?  I dont get any of the tutorials and I have been using C/C++ for years
17:52:30 <Rawr321> I read somewhere that its not procedural and the order of things really dont matter...can someone explain that to me?
17:52:31 <palomer> understanding haskell is a lifelong journey
17:52:59 <palomer> Rawr321: in C++, when you write add(x,y), first you evaluate x, then you evaluate y, then you evaluate add(x,y)
17:53:09 <palomer> this is not so in haskell
17:53:32 <MarcWeber> Rawr321 Where are you struggling? Can you give one line that you don't understand?
17:53:32 <Rawr321> how is it in haskell
17:53:40 <palomer> or, rather, it wouldn't make a difference if it was so in hsakell
17:54:09 <palomer> Rawr321: you can calculate add(x,y) in terms of x and y (unevaluated), then evaluate x and y in that expression
17:54:30 <Cale> Rawr321: basically, things are evaluated by demand
17:54:55 <Cale> If something needs to be printed on the screen, then the least amount of computation necessary to compute it is performed.
17:55:03 <Saulzar> The big difference is side effects - in C++ the order matters because one of the arguments might cause a side effect, if there are no side effects the order doesn't matter
17:55:22 <palomer> for example, add(add(1,2),add(3,4)) could evaluate to add(3,add(3,4))  or to add(add(1,2),7), both of which could evaluate to add(3,7)
17:55:56 <palomer> which could in turn evaluate to 10
17:56:28 <Cale> Well, most Haskell implementations use lazy evaluation.
17:56:35 <Rawr321> so your saying stuff such as the parameters arnt evaluated until needed?
17:56:42 <Cale> Rawr321: right
17:57:15 <Rawr321> I see! So no side effects means if you call a function as a parameter, it wont call that function like it would in C
17:57:22 <Rawr321> in haskell it wouldnt call it until needed?
17:57:25 <Cale> Basically, when evaluation is needed, functions are evaluated outermost first (rather than innermost first like in C/C++/etc.) and if parameters are repeated, the results are shared.
17:57:52 <Cale> If we have  double x = x + x
17:57:54 <jethr0_> that sounded more complicated than it really is :))
17:58:05 <Cale> and we write:  double (double 5)
17:58:13 <Rawr321> is my last few statements correct?
17:58:14 <Cale> then the outer double is first expanded
17:58:24 <Rawr321> hmmm
17:58:25 <Cale> Rawr321: right
17:58:26 <MarcWeber> Rawr321 If you do this: try 1 div 0 catch error 1 div 0 is never evaluated because it's never used ;-) So you don't get any error..
17:58:39 <Cale> so we first get: double 5 + double 5
17:59:01 <Rawr321> wow thats a nifty feature
17:59:03 <Cale> (but those are really pointers to the same computation, since they both came from filling in 'x' in double
17:59:05 <Cale> )
17:59:09 <dons> Cale, that's the second time we've had this question in a couple of day. Maybe you should write a little intro, "Purity and Lazyness for the Impure and Strict"?
17:59:12 <Cale> and then that expands
17:59:35 <Cale> giving  (5 + 5) + (5 + 5) all at once
17:59:45 <Cale> then 10 + 10, evaluating the addition once
17:59:54 <Cale> (since it notices the sharing)
17:59:55 <Cale> then 20
18:00:56 <Cale> Because of this outermost-first evaluation, functions which can return part of the result early might not have to continue evaluation if there is no demand for the rest.
18:01:08 <Rawr321> see im actually trying to implement a language with some functional aspects.  Ive became interested in math latly so I wanted to implement some features from haskell
18:01:11 <Cale> > take 10 [1..]
18:01:12 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
18:01:27 <Cale> > [1..]
18:01:28 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
18:01:28 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
18:01:28 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
18:01:28 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
18:01:28 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
18:01:30 <lambdabot> [24 @more lines]
18:01:43 <Cale> so you can have things like infinite lists
18:02:03 <Cale> simpler example:
18:02:07 <Cale> ones = 1 : ones
18:03:08 <Cale> If we do  head ones,  it first expands the definition of head
18:03:14 <Cale> head (x:xs) = x
18:03:18 <Rawr321> wouldnt a C compiler be capable of something such as 10 [1..] (ignoring the fact that it doesnt have ranges like that)
18:03:32 <Cale> Well, it would get caught up computing [1..]
18:03:45 <Cale> you'd eat up all of your memory
18:03:56 <Rawr321> haskell doesnt?
18:04:00 <Cale> right
18:04:06 <Rawr321> how does that work O.o
18:04:10 <Cale> it only ever generates the elements it needs to print
18:04:19 <Cale> and throws things away once it's printed them
18:04:31 <Cale> (or dealt with them however it needs to)
18:04:57 <Rawr321> wow man I want to implement lazy expressions into my language
18:05:09 <Cale> let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
18:05:12 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
18:05:13 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,
18:05:13 <lambdabot> 101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
18:05:13 <lambdabot> 193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,
18:05:13 <lambdabot> 293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,
18:05:13 <lambdabot> 409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,
18:05:15 <lambdabot> [24 @more lines]
18:05:16 <MarcWeber> Rawr321 In C,C++ you would implement something like an iterator.. with "getnextItem" .. But you need much more time to write that..
18:05:21 <Cale> There's the infinite list of primes
18:06:03 <Cale> by the Sieve of Eratosthenes applied to an infinite list :)
18:06:41 <Cale> That's a painful way to implement it in C, but easy here.
18:06:53 <Rawr321> also should I implement an "infinitely" sized int? 
18:07:16 <Cale> Rawr321: there are good libraries for it -- GMP is what GHC uses to implement Integer
18:07:44 <Cale> I don't know how people get by without unbounded integers myself :)
18:07:48 <Rawr321> I know, thats a bignum type yea.  And I made one for C# (.net) but im curious if the speed issues are worth it
18:08:11 <Rawr321> .net also has a native datatype built in thats huge.  Tell me if this is big enough:
18:08:13 <Rawr321> 79,228,162,514,264,337,593,543,950,335
18:08:20 <Rawr321> is the max value
18:08:28 <Saulzar> How many bits is that? 128? 
18:08:29 <Cale> > 2^500
18:08:30 <lambdabot> 327339060789614187001318969682759915221664204604306478948329136809613379640
18:08:30 <lambdabot> 467455488327009232590415715088668412756007100921725654588539305332852758937
18:08:30 <lambdabot> 6
18:08:34 <jethr0_> > let fac n = product [1..n] in fac 20
18:08:35 <lambdabot> 2432902008176640000
18:08:47 <Rawr321> thats not 128 ;)
18:08:53 <Saulzar> > 2^128 - 1
18:08:53 <Cale> > 2^128
18:08:54 <lambdabot> 340282366920938463463374607431768211455
18:08:55 <lambdabot> 340282366920938463463374607431768211456
18:08:59 <Rawr321> its like 3 billion times the size of int64 I read
18:09:05 <dons> you can provide both arbitrarily large intgers, and machine word-sized ints.
18:09:20 <Cale> Integer is actually a tagged union
18:09:29 <Cale> It uses machine ints when the values are small
18:09:33 <Rawr321> I was wanting to not have types in my language but I think I may have to...
18:09:40 <Rawr321> but you see
18:09:45 <dons> Rawr321, coming from C++, how'd you learn about Haskell?
18:09:46 <Cale> but does some tests to check when overflow would occur and switch to large ints.
18:09:47 <jethr0_> Rawr321: do you know scheme?
18:09:48 <Rawr321> what you just said Cale doesnt work too well
18:10:06 <Rawr321> you would have to test the value every single time its used
18:10:10 <Saulzar> It's a 96 bit integer
18:10:17 <Rawr321> 2^96
18:10:29 <Cale> Rawr321: well, every time you perform operations constructing a new integer
18:10:41 <Cale> It's not actually that much of a hit
18:11:02 <Cale> Haskell also has Int which is always a machine integer
18:11:24 <jethr0_> you can also store the size of the number as a tag-on. and then you know that multiplication yields n+m length while additions yields max(n,m)+1
18:11:45 <Rawr321> well I was thinking of not having types in my language and for all numbers, just using an arbitrary sized int for all numbers
18:11:49 <flux__> cale, how do you what to do on addition when you are provided two such integers?
18:12:01 <flux__> cale, as there are three cases to handle?
18:13:02 <Cale> well, the source is available -- I actually don't recall what the exact test is
18:13:17 <dons> Rawr321, it's actually a pretty efficient way to do it. Check this arbitrary precision arithmetic benchmark: http://shootout.alioth.debian.org/gp4/benchmark.php?test=pidigits&lang=all 
18:15:11 <Cale> Types in Haskell are really great.
18:15:13 <Rawr321> should I have types in my language or no?
18:15:42 <Cale> You should learn Haskell and see if you like its type system.
18:16:02 <Rawr321> well im on windows, what compiler/interpreter should I use?
18:16:17 <jethr0_> Rawr321: you should compare "scheme" with "haskell" and decide for yourself which you like better
18:16:20 <Cale> GHC/GHCi, or WinHugs
18:16:28 <Cale> I can see that, if you were coming from C++ or Java or something, a hatred of types would be pretty healthy.
18:16:36 <jethr0_> :)
18:16:57 <Rawr321> it just depends on the language really
18:16:58 <Cale> Haskell actually has a type system which doesn't get in your way, but makes sure that your programs usually work if they compile.
18:17:07 <Rawr321> k
18:17:19 <Rawr321> Though I do have bad memories with type restricitons in C...
18:17:24 <Saulzar> Types aren't much trouble in C++/Java... unless you're really lazy and coming from a dynamic typed language
18:17:25 <jethr0_> Cale: true, but building your own type inference isn't as easy as writing a simple scheme eval-apply cycle
18:17:25 <Rawr321> *restrictions
18:17:32 <Cale> jethr0_: right
18:17:39 <Cale> It is a lot of work
18:17:56 <Cale> but if you do it right, the results are rather good :)
18:18:16 <Cale> In Haskell, you don't have to give type signatures for anything (except if you use some language extensions)
18:18:23 <jethr0_> i couldn't agree more. but i'd be pretty unwilling to write it just for a DSL of kinds.
18:18:34 <Cale> The compiler can infer all of the types and make sure that they're consistent at compile time.
18:18:57 <Cale> If you give things types explicitly, it makes sure that the types you give work with everything it infers.
18:19:05 <Cale> (it still does the full inference)
18:19:09 <jethr0_> it's like duck typing all the way :). it's even check whether the duck can actually quack :)
18:19:32 <flux__> imo type errors provided by the compiler may be sometimes look confusing, whereas in dynamically typed languages the error, if discovered, is often quite clear
18:19:32 <Rawr321> Im trying to find winhugs and this site says it doesnt work
18:19:47 <Cale> Rawr321: you'd want ndm's new version
18:19:54 <flux__> I think error reporting for type inference is still a research subject, and there was actually one promising paper on it
18:19:56 <Cale> http://www-users.cs.york.ac.uk/~ndm/projects/winhugs.php
18:20:00 <Rawr321> ty
18:20:05 <flux__> which would neatly highlight the relevant parts
18:20:08 <jethr0_> "it is a member of package network-1.0, which is hidden"
18:20:15 <jethr0_> anyone cabal savvy around?
18:20:30 <MarcWeber> >  (log (read ( filter ( /= ',' ) "79,228,162,514,264,337,593,543,950,335") :: Double) / log 2)::Integer
18:20:30 <lambdabot> Couldn't match `Integer' against `Double'
18:20:32 <Rawr321> wow winhugs is huge!
18:20:36 * Saulzar usually grabs the last line of compiler output and slaps on -package network-1.0
18:20:55 <MarcWeber> >  (log (read ( filter ( /= ',' ) "79,228,162,514,264,337,593,543,950,335") :: Double) / log 2)::Double
18:20:55 <Cale> jethr0_: try adding 'network' to the list of package dependencies in the .cabal
18:20:56 <lambdabot> 96.0
18:21:09 <Cale> jethr0_: and runhaskell ./Setup.hs configure again
18:21:47 <jethr0_> Cale: thx a lot. that did the trick
18:22:10 <Rawr321> if anyone has any suggestions or ideas for what my language should include, speak up.  Though I plan on learning haskell better before I implement this language of mine
18:22:32 <Saulzar> You may be some time :)
18:22:43 <Cale> Rawr321: did you hear about pugs?
18:23:00 <jethr0_> Rawr321: there's a trend that people casually studying haskell tend to stay with it.
18:23:53 <Rawr321> maybe I can write the compiler for my lang in haskell then ;)
18:24:22 <Rawr321> Thing is...this lazy expression deal doesnt look like it would work in a compiled language.  Looks like it needs to be interpreted
18:25:00 <Cale> Rawr321: no
18:25:09 <Cale> Rawr321: GHC is a production Haskell compiler :)
18:25:23 <Cale> If you'd like, I could point you at the paper which explains the mechanism for it
18:26:21 <Rawr321> please
18:26:32 <Cale> Well, there are a number of ways, but the basic idea is that values are not just values, but pointers to either code or data.
18:26:51 <dons> Rawr321, check the language shootout benchmarks - compiled lazyness rocks: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
18:27:06 <Cale> When the value is first needed, the code executes, and the pointer is rewritten to point to the result.
18:27:26 <Cale> (and a flag is set, or some other mechanism is used to record the fact that value has been computed)
18:28:05 <Cale> the mechanism that GHC uses, is I think still the spineless tagless G-machine
18:28:10 <Rawr321> hmmm where can I get GHC?  Is it worth using over WinHugs btw?
18:28:12 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
18:28:17 <jethr0_> Rawr321: are you familiar with "scheme"? that might be a nice start to write your own language. there's even a tutorial out there "scheme to c in 90 minutes"
18:28:29 <Rawr321> ive heard of it
18:28:39 <Cale> Rawr321: GHC has more language features than WinHugs, but WinHugs looks like it has a prettier interface
18:28:57 <Rawr321> ill stick with winhugs then for now
18:29:13 <jethr0_> it's pretty simple to implement and (apart from typing) is very powerful
18:29:20 <Cale> GHC is a compiler. It comes with GHCi which is an interactive environment for testing and debugging Haskell programs (and it can work with compiled code or interpret it)
18:29:57 <Rawr321> I know haskell works well for small progs and math stuff but what about big things, games even
18:30:09 <Cale> Well, it should be fine
18:30:12 <Rawr321> I read that it turns into a mess with big things
18:30:20 <Cale> nah, that's not really true
18:30:32 <Cale> There's a person writing an FPS in it
18:30:43 <Cale> which runs, but there's not much game to it yet :)
18:30:52 <Cale> @wiki Frag
18:30:52 <lambdabot> http://www.haskell.org/haskellwiki/Frag
18:31:00 <Cale> argh
18:31:11 <Cale> not that wiki :)
18:31:24 <Cale> http://www.haskell.org/hawiki/Frag
18:31:29 <Rawr321> well there are 2 things I make usually.  Games and Compilers for my own languages.  Was thinking of adding a haskell perspective to a language that you can make games and big apps easier with
18:31:33 <Cale> (there's a transition in progress)
18:31:38 <Saulzar> There are some awkward points, but once you figure out the techniques for dealing with it is is no trouble
18:32:05 <Cale> Haskell is an ideal language for writing compilers.
18:32:13 <Cale> It's absolutely beautiful.
18:32:19 <Cale> You might be interested in Parsec
18:32:26 <Cale> which is a parser combinator library
18:32:35 <Rawr321> for haskell?
18:32:38 <Cale> yeah
18:32:42 <Rawr321> Ill look into it
18:32:54 <Cale> Parsers are first-class Haskell values, and can be manipulated with functions
18:33:33 <Cale> For example, I can take a list of parsers and fold the combiner which takes the OR of those parsers into that list to construct a parser which parses the first one to succeed.
18:33:35 <Saulzar> There are some interesting experiments for writing games in Haskell, and plenty of libraries for things like GUIs graphics etc.
18:34:17 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
18:34:36 <Cale> Oh, and you might be interested in browsing through http://www.haskell.org/ghc/docs/latest/html/libraries/index.html 
18:34:43 <Rawr321> thanks
18:34:57 <Cale> those are the libraries which come with GHC, similar libraries are provided with Hugs
18:35:15 <jethr0_> Cale: i'm trying to rollback the last 8 patches of a repo. would you know that?
18:35:31 <Rawr321> heck, I could have my language compile to haskell then use GHC or w/e to compile that to asm for me
18:35:48 <MarcWeber> Rawr321 And as long as you are not a genious: read a tutorial first ;-)
18:36:06 <Rawr321> ?
18:36:16 <Cale> Rawr321: yeah, I suppose you could :)
18:36:29 <Rawr321> ill see, need to learn haskell first
18:36:41 <Cale> Haskell as a target language would be a little odd :)
18:36:56 <Cale> but it's been done before :)
18:37:08 <dons> Cale, we now have @oldwiki for the old wiki :)
18:37:13 <Cale> dons: ah
18:37:29 <dons> (and funny you point to Frag, I'm moving it to the new wiki as we speak)
18:37:35 <Rawr321> the reason I had that idea is because it already has lazy expressions and bignum types
18:37:36 <Cale> :)
18:37:52 <Cale> Rawr321: yeah, it would save quite a bit of trouble
18:38:42 * MarcWeber has to go to bed
18:39:28 <Rawr321> Bleh this tutorial's code doesnt work in winhugs
18:41:02 <Cale> Rawr321: you can't type source directly into winhugs
18:41:14 <Cale> you type your declarations into a file
18:41:25 <Cale> then load it in winhugs, which evaluates expressions
18:41:32 <Rawr321> ah...
18:41:58 <Rawr321> thats kind of annoying
18:42:31 <Cale> you can easily tell winhugs to reload your file
18:42:34 <Cale> with :r
18:42:44 <Cale> (or maybe there's a key)
18:42:59 <Cale> so the common thing to do is to keep an editor open with your session
18:43:22 <Rawr321> I ment that I have to make a file and tell it to open that file is annoying lol...just for variables and stuff
18:43:55 <Cale> well, you can use:  let x = 1 in x + x
18:44:19 <Cale> I'm not sure if WinHugs allows you to just type  'let x = 1' and have that definition carry over the rest of the session
18:44:25 <Cale> ghci does
18:44:29 <Rawr321> ahhh I see, its a one time thing
18:44:48 <Rawr321> k im a pro at haskell now :-p
18:44:55 <Cale> but traditionally, hugs only evaluates expressions, and if you want declarations, you put them in a file
19:16:28 <jethr0_> @hoogle cmdlineOpts
19:16:28 <lambdabot> No matches found
19:50:52 <wli> shapr: boo
21:34:40 <araujo> hGetContents: illegal operation (handle is closed)
21:34:54 <araujo> Shoudln't i be able to catch that exception?
22:37:38 <Cale> araujo: yeah, probably
22:38:16 <Cale> but you also probably could check if the handle is closed before calling hGetContents
22:44:10 * wli tries to dredge up docs on how to use Text.Html
22:47:52 * wli has, to date, just spewed HTML by ++ and similar.
22:50:06 <dons> @yow
22:50:06 <lambdabot> Are we on STRIKE yet?
22:50:48 * wli decides to continue generating HTML with raw string manipulation and goes about learning how to do cookies by hand
22:52:25 <wli> heh, cookies are butt simple
23:30:46 <maus> hello
23:31:00 <Lemmih> Hi maus.
23:31:15 <maus> is there any way to make smaller binaries then using gtk2hs?
23:31:28 <maus> i read something about -split-objs flag
23:31:57 <maus> but have no idea how to use it
23:31:57 <Lemmih> Yeah, the next release will use -split-objs.
23:32:51 <maus> so it's impossible with gtk2hs-0.9.10?
23:33:03 <Lemmih> I think so.
23:34:06 <dons> stripping the application is a good idea too.
23:34:28 <dons> split-objs + strip is usually good enough.
23:36:29 <maus> dons: how to make use of split-objs? Is it automatic?
23:45:07 <gour> dons: how is it that haskell dropped to #5 on amd shootout list?
