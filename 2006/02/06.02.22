00:04:22 <joelk> ... where bliss == AthlonX2 + make -j3
00:05:03 <joelk> s/==/=
01:21:26 <toruhikaru> anyone know how to do coefficients of Pascal’s triangle??
01:21:38 <basti_> always sum the two above
01:21:57 <toruhikaru> in dev c++??
01:22:06 <basti_> uhm? ^^
01:28:57 <tromp_> pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
01:38:37 <toruhikaru> C(m,0) = 1 and C(m, m) = 1 for m >= 0. 
01:38:38 <toruhikaru> <toruhikaru> C(m,n) = C(m-1, n-1) + C(m-1, n) for m > n > 0.
01:45:36 <ski> > map (take 10) . take 10 $ scanl (flip (scanl (+))) (repeat 1) (repeat 0)
01:45:37 <lambdabot> [[1,1,1,1,1,1,1,1,1,1],[0,1,2,3,4,5,6,7,8,9],[0,0,1,3,6,10,15,21,28,36],[
01:45:37 <lambdabot> 0,0,0,1,4,10,20,35,56,84],[0,0,0,0,1,5,15,35,70,126],[0,0,0,0,0,1,6,21,56,
01:45:37 <lambdabot> 126],[0,0,0,0,0,0,1,7,28,84],[0,0,0,0,0,0,0,1,8,36],[0,0,0,0,0,0,0,0,1,9],
01:45:37 <lambdabot> [0,0,0,0,0,0,0,0,0,1]]
01:45:41 <ski> > let (.:) = (.) . (.) in  map (take 10) . take 10 $ scanl (tail .: flip (scanl (+))) (repeat 1) (repeat 0)
01:45:42 <lambdabot> [[1,1,1,1,1,1,1,1,1,1],[1,2,3,4,5,6,7,8,9,10],[1,3,6,10,15,21,28,36,45,55]
01:45:42 <lambdabot> ,[1,4,10,20,35,56,84,120,165,220],[1,5,15,35,70,126,210,330,495,715],[1,6,
01:45:42 <lambdabot> 21,56,126,252,462,792,1287,2002],[1,7,28,84,210,462,924,1716,3003,5005],[
01:45:43 <lambdabot> 1,8,36,120,330,792,1716,3432,6435,11440],[1,9,45,165,495,1287,3003,6435,
01:45:45 <lambdabot> 12870,24310],[1,10,55,220,715,2002,5005,11440,24310,48620]]
02:01:16 <lispy> hah, that's great
02:02:16 <lispy> it so nice that haskell is so readable :)
02:02:30 <lispy> i would have guessed in an instance that the output was such
02:03:10 <lispy> now I wonder...can you work in unfoldr?
02:03:12 <Cale> tromp_'s version is pretty clear
02:03:19 <lispy> @index unfoldr
02:03:20 <lambdabot> Data.List
02:03:35 <lispy> @type Data.List.unfoldr
02:03:36 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
02:04:48 <lispy> > Data.List.unfoldr (\b -> Just (1, b) 2
02:04:48 <lambdabot>  parse error on input `}'
02:05:10 <lispy> hm...
02:05:22 <lispy> @type \b -> Just (1, b)
02:05:23 <lambdabot> forall a b. (Num a) => b -> Maybe (a, b)
02:05:31 <Beelsebob> > Data.List.unfoldr (\b -> Just (1, b) 2)
02:05:32 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
02:06:04 <lispy> oh silly me, the wrong bracket was reported, but i should have realized
02:06:35 <lispy> > Data.List.unfoldr (\b -> Just (1, (b::Int)) 2) 
02:06:36 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
02:06:46 <lispy> > Data.List.unfoldr (\b -> Just (1, (b::Int)) (2::Int)) 
02:06:47 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
02:07:08 <lispy> > Data.List.unfoldr (\b -> Just ((1::Int), (b::Int)) (2::Int)) 
02:07:09 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
02:07:15 <lispy> um...
02:07:51 <ski> > take 10 $ unfoldr (\s -> Just (1,s)) ()
02:07:51 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
02:08:25 <lispy> so why did yours work and mine fail?
02:08:51 <roconnor> @type (.) . (.)
02:08:52 <lispy> > Data.List.unfoldr (\b -> Just ((1::Int), (b::Int)) (2::Int)) ()
02:08:52 <lambdabot> forall a b c a1.
02:08:52 <lambdabot>      (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:08:52 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
02:08:57 <ski> you were giving 2 args to 'Just'
02:09:24 * roconnor wonders if (.:) ought to be part of the Prelude
02:09:50 <lispy> > Data.List.unfoldr (\b -> Just (1, b)) ()
02:09:51 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
02:09:51 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
02:09:51 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
02:09:51 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
02:09:51 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
02:09:53 <lambdabot> [23 @more lines]
02:10:03 <lispy> > Data.List.unfoldr (\b -> Just (1, b+1)) ()
02:10:03 <lambdabot>  add an instance declaration for (Num ())
02:10:17 <lispy> > Data.List.unfoldr (\b -> Just (1+b, b)) ()
02:10:18 <lambdabot>  add an instance declaration for (Num ())
02:10:33 <lispy> obviously i still haven't grasped unfoldr
02:10:44 * lispy goes to fumble in ghc
02:10:44 <ski> > take 10 $ unfoldr (\b -> Just (1+b, b)) 0
02:10:45 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
02:10:54 <ski> > take 10 $ unfoldr (\b -> Just (b,1+b)) 0
02:10:55 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
02:11:47 <roconnor> > iterate (+1) 0
02:11:48 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
02:11:48 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
02:11:48 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
02:11:48 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
02:11:48 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
02:11:50 <lambdabot> [24 @more lines]
02:12:07 <roconnor> > take 10 $ iterate id 1
02:12:08 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
02:13:43 <lispy> > take 10 $ unfoldr (\b -> Just (2, b*b+b)) 10000
02:13:44 <lambdabot> [2,2,2,2,2,2,2,2,2,2]
02:13:51 <ski> > take 6 $ iterate (2 ^) 0
02:13:52 <lambdabot> [0,1,2,4,16,65536]
02:14:34 <ski> lispy : you need to emit something dependant on the state 'b'
02:14:57 <lispy> ski: and b*b+b isn't?
02:15:04 <cpatrick> > take 7 $ iterate (2^) 0
02:15:06 <ski> '2' isn't
02:15:06 <lambdabot> [0,1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926
02:15:06 <lambdabot> 501697371089405955631145308950613088093334810103823434290726318182294938211
02:15:06 <lambdabot> 881266886950636476154702916504187191635158796634721944293092798208430910485
02:15:06 <lambdabot> 599057015931895963952486337236720300291696959215610876494888925409080591145
02:15:06 <lambdabot> 703767520850020667156370236612635974714480711177481588091413574272096719015
02:15:08 <lambdabot> [23 @more lines]
02:15:46 <ski> lispy : first part is emitted, second part is new state
02:16:00 <roconnor> > take 10 $ unfoldr (\b -> Just (b, b*b+b)) 10000
02:16:00 <lambdabot> [10000,100010000,10002000200010000,100040008001000090006000300010000,
02:16:00 <lambdabot> 10008003200840162024402980302025801880118006400300012000400010000,
02:16:00 <lambdabot> 100160128068026928458192882131671297466100700003112707855210337075712013050
02:16:00 <lambdabot> 303753583386548994401416560630022000700020000500010000,10032051254603555728
02:16:00 <lambdabot> 266546441450312631969540527316394496812926212849395674013669342771874612449
02:16:02 <lambdabot> [23 @more lines]
02:16:09 <lispy> hmm...okay
02:16:13 <lispy> brb
02:16:18 <roconnor> > take 10 $ unfoldr (\b -> Just (b/10000, b*b+b)) 10000
02:16:19 <lambdabot> [1.0,10001.0,1.000200020001e12,1.000400080010001e28,1.0008003200840162e60,
02:16:19 <lambdabot> 1.0016012806802692e124,1.0032051254603554e252,Infinity,Infinity,Infinity]
02:16:32 <ski> > take 4 $ iterate (\b -> b*b+b) 10000
02:16:32 <lambdabot> [10000,100010000,10002000200010000,100040008001000090006000300010000]
02:17:44 <ski> iterate f = unfoldr (\s -> Just (s,f s))
02:18:12 <tromp_> > mapM print $ iterate inc [(0,1)] where inc ((i,a):l) = ack (succ i) (succ a) l where ack i a l = (i,a): case if null l then [(-1,1)] else l of (j,b):r -> if i==b then ack (succ j) a r else l
02:18:13 <lambdabot> No IO allowed
02:18:39 <turok> .o0(this is like haskell tv)
02:18:49 <Cale> hehe
02:19:09 <tromp_> > unlines $ map show $ iterate inc [(0,1)] where inc ((i,a):l) = ack (succ i) (succ a) l where ack i a l = (i,a): case if null l then [(-1,1)] else l of (j,b):r -> if i==b then ack (succ j) a r else l
02:19:11 <lambdabot> "[(0,1)]\n[(1,2),(0,2)]\n[(2,3),(1,3),(0,3)]\n[(3,4),(2,4),(0,3)]\n[(4,5),
02:19:11 <lambdabot> (3,5),(1,5),(0,5)]\n[(5,6),(4,6),(1,5),(0,5)]\n[(6,7),(5,7),(2,7),(0,5)]\
02:19:11 <lambdabot> n[(7,8),(6,8),(2,7),(0,5)]\n[(8,9),(7,9),(3,9),(0,5)]\n[(9,10),(8,10),(3,
02:19:11 <lambdabot> 9),(0,5)]\n[(10,11),(9,11),(4,11),(0,5)]\n[(11,12),(10,12),(4,11),(0,5)]\
02:19:11 <lambdabot> n[(12,13),(11,13),(5,13),(1,13),(0,13)]\n[(13,14),(12,14),(5,13),(1,13),(
02:19:12 <lambdabot> [23 @more lines]
02:19:39 <tromp_> hmmm;(
02:20:50 <ski> 'case if' :D
02:24:43 <lispy> unfolder is so weird to me
02:24:55 <lispy>  take 5 $ unfoldr (\b -> Just (2^b, b+1)) 0
02:24:59 <lispy> > take 5 $ unfoldr (\b -> Just (2^b, b+1)) 0
02:25:00 <lambdabot> [1,2,4,8,16]
02:25:21 <lispy> so that is squaring the value at each step, and at each step it is incrementing the input?
02:25:30 <ski> yes
02:25:35 <lispy> hm...cool
02:25:41 <ski> err
02:26:08 <ski> it raises to power of two, not squaring
02:26:11 <Muad_Dibber> @type unfoldr
02:26:11 <lambdabot> Not in scope: `unfoldr'
02:26:24 <lispy> ski: oh right, misstatement on my part
02:26:29 <ski> @type Data.List.unfoldr
02:26:30 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
02:26:32 <lispy> > take 5 $ unfoldr (\b -> Just (b+b, b+1)) 0
02:26:33 <lambdabot> [0,2,4,6,8]
02:27:05 <xerox_> Ciao.
02:27:20 <lispy> so this is sort of a nice way to express many for loops
02:27:27 <Muad_Dibber> > unfoldr (\b -> if b < 5 then Just (2^b, b+1) else Nothing) 0
02:27:28 <lambdabot> [1,2,4,8,16]
02:27:30 <lispy> just non obvious at first
02:28:43 <lispy> so the natural question is 1) how to express fibonacci 2) how is unfoldr defined
02:29:15 <lispy> > unfoldr \b -> Just (b+(b-1), b) 1
02:29:15 <lambdabot>  parse error on input `\'
02:29:26 <ski> > take 10 $ unfoldr (\(a,b) -> Just (b,(b,a+b))) (1,0)
02:29:26 <lambdabot> [0,1,1,2,3,5,8,13,21,34]
02:29:39 <lispy> ah, perfect
02:30:01 <lispy> so then, what would i have to type before @pl replies with unfoldr?
02:30:19 <ski> maybe it doesn't know about it
02:30:29 <ski> unfoldr f s = case f s of
02:30:33 <ski>   Nothing -> []
02:30:43 <ski>   Just (a,s) -> a : unfoldr f s
02:31:01 <ski> err
02:31:13 <ski> no, it's fine
02:31:20 <lispy> hm...okay
02:31:40 <ski> (thought for a moment i had committed offby1)
02:32:14 <lispy> @typel let { unfoldr' _ Nothing = []; unfoldr' f Just (a,s) = a : unfoldr' f s} in unfoldr'
02:32:14 <lambdabot> Varying number of arguments for function `unfoldr''
02:32:35 <lispy> @typel let { unfoldr' _ Nothing = []; unfoldr' f (Just (a,s)) = a : unfoldr' f s} in unfoldr'
02:32:35 <lambdabot>   Occurs check: cannot construct the infinite type: b = Maybe (a, b)
02:32:35 <lambdabot>   Expected type: Maybe (a, b)
02:33:21 <ski> @type let { unfoldr' _ Nothing = []; unfoldr' f (Just (a,s)) = a : unfoldr' f (f s)} in unfoldr'
02:33:22 <lambdabot> forall b
02:33:22 <lambdabot>                                   a.
02:33:22 <lambdabot>                                 (b
02:33:22 <lambdabot>                                 -> Maybe (a,
02:33:22 <lambdabot>                                    b))
02:33:24 <lambdabot> [3 @more lines]
02:33:29 <ski> @more
02:33:29 <lambdabot>                                 -> Maybe (a,
02:33:29 <lambdabot>                                    b)
02:33:30 <lambdabot>                                 -> [a]
02:33:41 * ski wonder why the weird indenting
02:34:09 <ski> forall b a. (b -> Maybe (a,b)) -> Maybe (a,b) -> [a]
02:34:14 <lispy> because lambdabot has always had indenting that seems weird to me :)
02:34:20 <lispy> @type unfoldr
02:34:20 <lambdabot> Not in scope: `unfoldr'
02:34:28 <lispy> @type Data.List.unfoldr
02:34:29 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
02:34:48 <lispy> so we have the wrong type, no?
02:35:02 <ski> in a way, i think that's the 'odd' version of 'unfoldr', if see as 'even'
02:35:13 <ski> s/see/seen/
02:35:21 <lispy> hmmm
02:35:33 <lispy> odd as in odd/even functions like sin vs. cos?
02:35:46 <ski> no, as in odd vs. even streams
02:36:09 <ski> (do you know any ML ?)
02:36:21 <xerox_> Oh my gosh... http://www.swmoore.com.nyud.net:8090/ultimatepaint.html
02:37:10 <ski> hm, well i thought of another example
02:37:51 <lome> what is a difference between `rem` and `mod`?
02:37:59 <ski> type EvenRefList a = IORef (OddRefList a)
02:38:06 <lispy> ski: i don't know enough ML to know about odd vs. even streams
02:38:13 <ski> data OddRefList a = Nil | Cons a (EvenRefList a)
02:38:29 <ski> lispy : that is more or less the same concept
02:38:41 <lispy> > 10 `mod` 3
02:38:42 <lambdabot> 1
02:38:47 <lispy> > 10 `rem` 2
02:38:48 <lambdabot> 0
02:38:49 <lispy> > 10 `rem` 3
02:38:50 <lambdabot> 1
02:39:05 <lome> i dont see a difference
02:39:18 <ski> > mod `ap` [17,-17] `ap` [7,-7]
02:39:18 <lambdabot> Couldn't match `(->) a' against `[]'
02:39:19 <lome> also between `div` and `quot`
02:39:22 <ski> > rem `ap` [17,-17] `ap` [7,-7]
02:39:22 <lambdabot> Couldn't match `(->) a' against `[]'
02:39:26 <ski> erm
02:39:29 <xerox_> heh
02:39:31 <xerox_> [rem]
02:39:35 <ski> yes
02:39:35 <lispy> > -10 `rem` 3
02:39:36 <lambdabot> -1
02:39:41 <lispy> > -10 `mod` 3
02:39:42 <lambdabot> -1
02:39:42 <ski> > return mod `ap` [17,-17] `ap` [7,-7]
02:39:43 <lambdabot> [3,-4,4,-3]
02:39:48 <ski> > return rem `ap` [17,-17] `ap` [7,-7]
02:39:49 <lambdabot> [3,3,-3,-3]
02:39:56 <xerox_> ski: why do they differ?
02:40:14 <ski> xerox : odd vs. even ? or rem vs. mod ?
02:40:40 <ski> lispy : understand ?
02:40:48 <xerox_> ski: the latter
02:40:54 <lispy> lome: i don't think modulus is different than remainder, but i'll look it up real quick on google
02:40:54 <lome> ski: thank you!
02:40:59 <ski> 'rem' is like '%' in C
02:41:13 <ski> 'mod' is somewhat nicer, from math POV
02:41:28 <xerox_> ski: how do they differ?
02:41:28 <lome> ski: yes, i understand it now
02:41:55 <lispy> er, i'm still not seeing the difference :) (but i was also at the pub tonight so slower than usaual :)
02:42:11 <ski> (with 'mod' denominator sign controls result sign .. with 'rem' it's the numerator sign that controls result sign)
02:42:30 <int-e> > ((-1) `mod` 3, (-1) `rem` 3)
02:42:31 <lambdabot> (2,-1)
02:42:52 <cpatrick> `mod` is the same as Python's % operator
02:42:56 <lome> > -17 `mod` (-7)
02:42:56 <lome> > -17 `rem` (-7)
02:42:57 <lambdabot> 4
02:42:57 <lambdabot> -3
02:43:09 <cpatrick> my understanding is that % in C is implementation-dependent (!)
02:43:25 <lome> 'cause mod considers a sign
02:43:44 <lispy> ah, right mod behaves the way you'd expect
02:43:49 <lispy> well, the way i would expect
02:43:53 <ski> lispy : an odd stream contains the first part (nil or cons) directly, and the tail is behind some indirection (like a reference, or a thunk)
02:44:05 <lispy> ski: hmm...okay
02:44:17 <ski> lisppy : an even stream has first part also behind an indirection
02:44:40 <ski> 'even' streams are more symmetric
02:44:59 <lispy> i would expect that from something labeled even
02:45:02 <kzm> I have one question regarding the unboxed arrays - and now refs etc.
02:45:09 <xerox_> > (-14) - (-17)
02:45:10 <ski> but usually requires a little extra work
02:45:10 <lambdabot> 3
02:45:12 <xerox_> ?!
02:45:22 <kzm> Isn't the unboxed part just implementation detail, and semantically they are just strict?
02:45:48 <kzm> E.g., shouldn't UArray really be named StrictArray or something like that?
02:45:55 <lispy> xerox_: what is surprising?
02:46:04 <xerox_> The result of `mod`.
02:46:11 <lispy> > -14 `mod` -17
02:46:12 <lambdabot>   precedence parsing error
02:46:12 <lambdabot>    cannot mix `mod' [infixl 7] and prefix `-' [infixl 6] in the same
02:46:12 <lambdabot> infix expression
02:46:22 <lispy> > (-14) `mod` (-17)
02:46:22 <lambdabot> -14
02:46:36 <lispy> > (-14) `rem` (-17)
02:46:38 <lambdabot> -14
02:46:50 <xerox_> Wait I got it.
02:46:58 <lispy> > (-14) `rem` (17)
02:46:59 <lambdabot> -14
02:47:02 <ski> 'mod' and 'rem' only differ in answer if args have opposite signs
02:47:04 <lispy> > (-14) `mod` (17)
02:47:05 <lambdabot> 3
02:47:18 <lispy> mod gives the answer i'm used to
02:47:34 <roconnor> basically mod gives the ``right'' answer
02:47:52 <lispy> which is to say it gives the remainder in the range [0,n) for mod n
02:47:56 <ski> most often, the denominator (modulus) is more "fixed" than the numerator
02:48:15 <jethr0_> wasn't there a speed issue also. i heard that "rem" was faster then "mod", or is that just bogus?
02:48:30 <ski> so, if you want in range (-n,0], you give negative denominator
02:48:35 <lispy> jethr0_: oh i could see something silly like that being true
02:48:40 <cpatrick> jethr0_: that's correct. `rem` is a CPU instruction, `mod` does post-processing
02:48:54 <cpatrick> (on Intel, anyway)
02:49:11 <lispy> would you say rem is then implementation defined?
02:49:31 <lispy> or it just happens to correspond nicely to a machine instruction on intel
02:50:31 * cpatrick checks
02:51:03 <cpatrick> http://www.haskell.org/onlinereport/basic.html section 6.4 suggests they have sensibly-defined semantics
02:51:55 <int-e> cpatrick: a/b for integers is specified to truncate towards 0 in C99
02:51:58 <lispy> this reminds me that after reading Tom (or was it Tim) Sweeny's presentation on making game engines that the game industry needs a language which is half way between C/Fortran and Haskell in the same sense that Java is quite popular in industry and brough the C++ programmers half way to lisp
02:55:12 <cpatrick> lispy: yeah, I recall that too
02:55:44 <cpatrick> hopefully Haskell can become that language ;-)
02:57:06 <lispy> i think there is a lot of psychology, investment and learning to overcome if you wanted indstry to switch directly to haskell.  I think, given the success of java the secret is to provide an intermediate language and a company that will sponsor it
02:58:01 <cpatrick> well, to some extent it's also the available libraries and prewritten code that matters
02:58:21 <lispy> oh true, i hear that toted as a reason to use java and C#
02:58:44 <cpatrick> yeah. and it's why the most recent small programming project I started was in Python, not Haskell
02:59:05 <cpatrick> though Haskell is a heck of a lot better library-wise than people give it credit for
02:59:31 <cpatrick> especially people who do one semester of it at uni as "Intro to Function Programming"
02:59:43 <Saulzar> lispy, That presentation seemed wierd - he seemed to have his own psychological issues with haskell syntax :)
02:59:50 <cpatrick> and heardly even end up learning IO
03:00:33 <lispy> Saulzar: i think his issues were most likely based on the feedback of members of his team.  iirc Sweeny understands haskell and quite respects the language
03:01:27 <lispy> Saulzar: i know i've had conversations with people that feel that C style syntax is the only way to fly
03:01:34 <cpatrick> Saulzar: Haskell syntax is very alien if you're not used to it. personally it's something I've loved from the word go...
03:01:41 <Saulzar> Yep, haskell has some great libraries. 
03:02:37 <roconnor> @djinn (a ->b) -> (c -> d -> a) -> c -> d -> b
03:02:38 <lambdabot> f a b c d = a (b c d)
03:02:57 <roconnor> @pl f a b c d =a (b c d)
03:02:58 <lambdabot> f = (.) . (.)
03:03:26 <Saulzar> Oh I thought it was strange too, once you're past the shock I can't see anyone having real issues with the syntax...
03:05:20 <Saulzar> Some things are a little unwieldy, record update and arrays etc. but nothing's perfect :)
03:06:40 <jethr0_> i'm still struggling for a nice way to do inplace constructor matching...
03:07:19 <jethr0_> i'd be hoping for sth like (if (Just x <- y); x > 4 then x else 4)
03:07:40 <jethr0_> writing a whole case with two possibilities is usually too long for simple "inline" kinda stuff
03:07:46 <Saulzar> In place constructor matching?
03:07:55 <jethr0_> sry, inline
03:08:21 <Saulzar> What about making a function which switches on Just instead?
03:08:53 <Saulzar> (Or using one of the built in - maybe for example)
03:08:56 <jethr0_> yes, exactly, but i need this kinda thing all the time and writing mini-functions doesn't seem like the perfect solution. but it's pretty much how i deal with it right now
03:09:09 <jethr0_> yes, i was just using Maybe as an example
03:09:14 <Saulzar> Ah
03:09:42 <jethr0_> for a better example: "data X = A Int | B Int | C"
03:09:45 <Saulzar> Seems a reasonably way to do it to me, I guess if you have 7 or 8 cases then maybe not :)
03:10:29 <Saulzar> I guess you can use case on one line if you really want to save space... 
03:10:43 <jethr0_> hmm, just sth i'm missing. also altering data in deeply nested records (i.e. depth 2) is very annoying!
03:11:05 <Saulzar> Hmm?
03:11:51 <jethr0_> data B = {i :: Int}; data A = A {b :: B}
03:12:33 <jethr0_> a{b = b{i = (i (b a)) + 1}}
03:12:54 <jethr0_> and yes, usually the records are more complex!
03:13:02 <Saulzar> Hmm..
03:13:10 <jethr0_> no, still an error in there
03:13:20 <jethr0_> but you get my point
03:13:46 <Saulzar> I guess you could use drift or something, and use the get/set functions 
03:14:29 <lispy> yeah, i'd hazard a guess that you are violating laws of OO programmming if you are explicitly manipulating the structure of A and B
03:14:33 <jethr0_> hmm, i don't think that would solve the problem. or do you mean deep accessors?
03:15:02 <int-e> Saulzar: what you want is a modify function, I think
03:15:06 <lispy> eiher, way, it is past my bed time.  ttyl all!
03:15:26 <Saulzar> Well, you could at least combine them more easily (ie. function composition)
03:15:29 <Saulzar> Hmm
03:15:35 <jethr0_> lispy: but records can't have functions associated with them directly. so you OO argument isn't quite valid, i'd think
03:16:00 <int-e> Saulzar: then, you could write this as modify_i (modify_b (1+)) a
03:16:38 <jethr0_> hmm, i might think about it. but i guess you really need drift for this unless you want to write millions of these functions
03:16:40 <Saulzar> drift provides such a function for record members, I've never got around to trying it though
03:16:47 <jethr0_> cool
03:18:44 <Saulzar> I guess it can be a sign that design is not quite right even without thinking about OO - manipulating structures by deeply accessing from the outside is probably a red flag
03:19:02 <jethr0_> hmm
03:21:28 <Saulzar> Cale always argues that big records are a bad design - I'm not convinced myself, it seems hard if you need the data in different parts.
03:22:05 <Saulzar> I have found that it seems cleaner to provide different views to data rather than give out the records directly though.
03:22:34 <jethr0_> i mean records are clearly more comfortable than pure data types (wrt to accessors). and if you need to store data your records are either gonna be big or deeply nested.
03:22:40 <jethr0_> i don'd see the alternative
03:23:29 <Saulzar> Well, I guess that's true - but you don't nesescarily need to use the record everywhere - you can filter it and munge it to best suit where it is being used
03:24:11 <jethr0_> hmm, i guess i'll just have to learn some more idiomatic haskell patterns with respect to modular design
03:24:21 <jethr0_> that's something i'm not quite happy with, yet
03:24:35 <jethr0_> i.e. how to structure a big program into modules, functions, data types
03:25:17 <MarcWeber> Hello.  I need some help about Existential Types. Have you any idea how to fix this? http://www.rafb.net/paste/results/a4CgrF10.html
03:29:09 <xerox_> Hmm.
03:31:03 <cpatrick> >> hasBeenChanged =isOneResult True True hasBeenChanged << - that's defining hasBeenChanged in terms of itself, which I don't think is what you want to do
03:33:13 <xerox_> I wonder why I can't see the solution to this:  I have |type Foo a = ReaderT String IO a|, and I can do |res <- lift $ ioaction|.  But then, if I use |newtype Foo a = Foo { unFoo :: ReaderT String IO a } deriving (Monad,MonadIO)| I cannot use lift anymore...  any ideas?
03:34:38 <ski> cpatrick : that's not recursive
03:34:48 <dcoutts> xerox_, lift or liftIO ?
03:35:54 <ski> 'lift' is in MonadTrans
03:35:58 <ski> @type Control.Monad.Trans.lift
03:35:59 <lambdabot> forall (t :: (* -> *) -> * -> *)
03:35:59 <lambdabot>             a
03:35:59 <lambdabot>             (m :: * -> *).
03:35:59 <lambdabot>           (Control.Monad.Trans.MonadTrans t, Monad m) =>
03:35:59 <lambdabot>           m a -> t m a
03:36:21 <xerox_> dcoutts: that's right... thanks.
03:36:31 <xerox_> @type Control.Monad.Trans.liftIO
03:36:32 <lambdabot> forall (m :: * -> *) a.
03:36:32 <lambdabot>           (Control.Monad.Trans.MonadIO m) =>
03:36:32 <lambdabot>           IO a -> m a
03:36:39 <xerox_> Why the difference, tho?
03:37:00 <xerox_> (and it seem to require deriving |MonadReader String|, too)
03:39:15 <xerox_> It would be cool to have syntactic sugar for lifting..
03:40:10 <jethr0_> you mean "^func^" instead of "lift func" :)
03:40:30 <ski> MarcWeber : 'isOneResul:: t ->(Target t) => Bool -> Bool -> (TargetObj -> IO Bool) -> t -> IO Bool' ?
03:40:34 <xerox_> heh.
03:44:36 <MarcWeber> ski ;-) Yeah.. typo .. the "t" should belong to Resul_t_ and the first -> should be removed.. Either way.. If removing the whole type declaration of isOneResult I get the same error.
03:44:57 <ski> instance Target TargetObj
03:45:04 <ski> do you want such an instance ?
03:46:03 <MarcWeber> ski I don't see the difference because TargetObj is defined as object beeing instance of Target..
03:46:39 <ski> (since '  hasBeenChanged =isOneResult True True hasBeenChanged' in 'instance Target VirtualTarget' requires that one)
03:46:50 <ski> ahh
03:46:51 <ski> yes
03:47:23 <ski> make 'TargetObj' an instance of 'Target' (that is not done automatically)
03:47:41 <ski> (hm .. wonder if you can derive that ?)
03:48:12 <MarcWeber> ??? How should that look like?
03:48:16 <ski> (hm, prolly not)
03:48:19 <MarcWeber> instance Target TargetObj where
03:48:26 <MarcWeber> hasBeenChanged=hasBeenchanged
03:48:28 <MarcWeber> a=a
03:48:33 <MarcWeber> b=b [...]?
03:48:36 <ski> no
03:49:03 <ski>   hasBeenChanged (TargetObj t) = hasBeenChanged t
03:49:06 <ski>   ...
03:50:06 <MarcWeber> Then it's no longer a member of class Target.
03:50:16 <ski> ?
03:50:46 <ski> it never was
03:50:49 <ski> it's just a datatype where the single argument happens to be in class Target
03:51:08 <ski> that doesn't mean the new datatype automatically gets into that class
03:56:46 <MarcWeber> ski Do I have to change it at the class ... where and instance ...where definitions?
03:57:03 <ski> just make an instance of it
03:57:14 <ski> a new instance, i.e.
03:57:27 <ski> no change of the existing, i think
03:58:04 <kowey> hi #haskellers, i have made some progress on the wikibooks module on arrows - http://en.wikibooks.org/wiki/Programming:Haskell_arrows
03:58:20 <kowey> but i've hit a stopping point in my understand - perhaps some of you might want to make comments on what i have so far?
03:59:10 <kowey> (in the meantime, i'll go off and learn things - please post comments on the talk page :-) )
04:01:27 <MarcWeber> Multiple declarations of `HCaMakeLib2.hasBeenChanged'    ;-((
04:02:18 <ski> did you put it inside
04:02:26 <ski> instance Target TargetObj where
04:02:27 <ski> ?
04:02:56 <MarcWeber> indenting... no I didn't Marc, wake up! switch on your brain!
04:06:48 <MarcWeber> ski: This way: http://www.rafb.net/paste/results/4DI2Gg46.html ? (see <<<<<)
04:09:04 <ski> instance Target (TargetObj t) where
04:09:04 <ski>   hasBeenChanged (TargetObj t)= hasBeenChanged t
04:09:27 <ski> you need lines for all the other class members, too (except default ones)
04:09:58 <MarcWeber> But missing members can't cause this error..
04:10:04 <MarcWeber> You will get a warning then.
04:10:05 <ski> (yes, s/standard implementations/default implementations/ i think is more common/standard vocabulary)
04:10:28 <MarcWeber> you're right, default would be better
04:10:38 <ski> ah, didn't see the error down there, yet :)
04:10:47 <ski> (you need to add the missing members anyway)
04:11:06 <ski> instance Target TargetObj where
04:11:29 <ski> you confused this because you used same name for the type constructor as for the data constructor
04:11:44 * ski 'd prolly use
04:11:51 <ski> data TargetObj = forall t. Target t => SomeTargetObj t
04:12:08 <ski> i this kind of case
04:12:12 <ski> s/i/in/
04:13:25 <MarcWeber> ski Thanks. How would the deriving clause look like in case it can do that?
04:13:50 <ski> data TargetObj = forall t. Target t => SomeTargetObj t  deriving Target
04:13:55 <ski> but i think it can't do this
04:14:00 <ski> (even with extenstions)
04:14:13 <ski> (since, e.g. it's not a newtype)
04:14:17 * ski ponders
04:15:43 <MarcWeber> Target is not a derivable class. You're right
04:16:35 <joolss> hi!  Is there a function that could convert uppercharts to lower charts?
04:16:37 <ski> (yet again) i wonder about existential newtypes
04:16:46 <tic> joolss, "charts" ?
04:16:52 <tic> joolss, you mean upper- vs lower-case?
04:17:00 <joolss> ok. I mean that yes
04:17:01 <ski> > toLower 'A'
04:17:02 <lambdabot> 'a'
04:17:13 <joolss> ok thanks!
04:17:15 <tic> > isUpper 'A'
04:17:16 <lambdabot> True
04:17:19 <ski> in Data.Char, i think
04:17:56 <joolss> ok thanks
04:18:13 <tic> flipString s = map flipCase s where flipCase x | isUpper x = toLower x | otherwise = toUpper x
04:18:13 <tic> :)
04:19:53 <tic> ungrateful first-year students! :)
04:20:03 <xerox_> > (isUpper &&& isLower) '1'
04:20:04 <lambdabot> (False,False)
04:20:13 <xerox_> Ah, otherwise, hehe.
04:20:18 <tic> gotcha. ;)
04:20:41 <tic> Is there an easier way of writing my function, by the way? I'd consider myself an haskell-newbie still based on the constructs I use
04:20:51 <tic> or well, not easier but more compact. :-)
04:21:04 <xerox_> it seems pretty good, to me.
04:22:25 <tic> but there must be something better. :(
04:22:26 <jethr0_> flipString = map (\x -> if isUpper x then toLower x else toUpper x)
04:22:41 <tic> yeah, that's a bit better. Thanks!
04:22:51 <jethr0_> not necessarily. i liked your version
04:23:17 <xerox_> Once a while it's good to make right things ;-)
04:23:32 <tic> Heh. I'm just trying to learn how to write more terse code using more primitives than I do, rather than manually inventing foldr and whatnot.
04:23:39 <tic> I guess in this case it's hard to get by without the cond.
04:26:38 <ski> @pl flipString = map (\x -> if isUpper x then toLower x else toUpper x)
04:26:39 <lambdabot> flipString = map (ap (liftM2 if' isUpper toLower) toUpper)
04:26:40 <musasabi> tic: ifApp a b c x = if a x then b x else c x
04:27:10 <musasabi> flipString = map (ifApp isUpper toLower toUpper)
04:27:22 <tic> Nifty :-)
04:27:32 <ski> ifApp = liftM3 if'
04:30:35 <jethr0_> ski: only that if' isn't in prelude...
04:30:53 <ski> yes
04:31:19 <jethr0_> @hoogle liftM3
04:31:20 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -
04:31:20 <lambdabot> > m a3 -> m r
04:32:04 <xerox_> @type Control.Monad.liftM3 (\c t f -> if c then t else f)
04:32:05 <lambdabot> forall a3
04:32:05 <lambdabot>                      (m :: * -> *).
04:32:05 <lambdabot>                    (Monad m) =>
04:32:05 <lambdabot>                    m Bool -> m a3 -> m a3 -> m a3
04:33:54 <ski> > Control.Monad.liftM3 (\c t f -> if c then t else f) `ap` [False,True] [1,2,3] [10,20,30]
04:33:54 <lambdabot> Couldn't match `[Bool]' against `t -> t1 -> t2'
04:34:05 <ski> > Control.Monad.liftM3 (\c t f -> if c then t else f) `ap` [False,True] `ap` [1,2,3] `ap` [10,20,30]
04:34:06 <lambdabot> Couldn't match `(->) (m Bool)' against `[]'
04:34:31 <ski> > Control.Monad.liftM3 (\c t f -> if c then t else f) [False,True] [1,2,3] [10,20,30]
04:34:32 <lambdabot> [10,20,30,10,20,30,10,20,30,1,1,1,2,2,2,3,3,3]
04:36:05 <jethr0_> huh?
04:36:57 <ski> ah
04:36:58 * beelsebob_ prods dons
04:37:02 * ski hits self
04:37:19 <ski> not (ifApp = liftM3 if')
04:38:16 <jethr0_> we just lifted one function to list monad... instead of one function into (e->)
04:38:31 <ski> m
04:49:56 <Lemmih> I think some of GHC was written before the do-notation was invented.
04:55:45 <xerox_> Lemmih: heh.
04:58:07 * dcoutts grumbles about how hard it is to build Wash
04:58:33 <dcoutts> by default Wash uses 700Mb to build and mis-uses c2hs.
04:59:17 <dcoutts> and it doesn't play nicely with setting where it should install
04:59:21 <dcoutts> grrr
05:00:10 <Lemmih> Anyone know why darcs commit messages aren't being mailed to cvs-ghc@haskell.org anymore?
05:01:50 <dcoutts> Lemmih, they should be, there's a script that does it
05:02:14 <dcoutts> see darcs.haskell.org:/home/darcs/ghc/_darcs/prefs/defaults
05:02:22 <ski> (MarcWeber : hm, one reason for not allowing deriving (generally) on existentials is "binary methods")
05:06:20 <ProfTeggy> kosmikus (Andres), are you there>
05:06:24 <ProfTeggy> s/>/?/
05:16:17 <dcoutts> @seen CosmicRay
05:16:18 <lambdabot> I saw CosmicRay leaving #haskell 9 hours, 16 minutes and 1 second ago,
05:16:18 <lambdabot> and I have missed 1 second since then.
05:23:54 <Lemmih> dcoutts: I think it's my fault )-:
05:24:07 <dcoutts> Lemmih, how so?
05:24:28 <dcoutts> or you just wern't recieving the emails?
05:24:46 <Lemmih> No, I think I messed up the repo.
05:25:13 <Lemmih> I checked the archive and the messages aren't being mailed.
05:25:46 <dcoutts> oh, so what's wrong?
05:26:07 <Lemmih> The last message was me accidently tagging the repo as Hide-0.1 )-:
05:26:17 <dcoutts> heh :-)
05:26:50 <dcoutts> cat ghc/.current-hash
05:26:50 <dcoutts> 20060125122617-26c35-37146072187ae5e9b8855e53dd4feb8031fcd9e6.gz
05:27:39 <dcoutts> Lemmih, that's the hash of the patch the last email contained
05:29:18 <Lemmih> How do I find out what patch that is?
05:29:31 <Lemmih> ah.
05:33:18 <Lemmih> Ah, so .curent-hash got messed up when I unpulled the erroneous tag?
05:41:04 <dcoutts> Lemmih, hmm, possibly
05:41:49 <dcoutts> Lemmih, it's not that robust. It looks for the patches since the .current-hash and sends those
05:42:08 <dcoutts> if the patch mentioned in .current-hash doesn't exist, I don't know what it does
05:42:25 <dcoutts> probably it continues to not send any email :-)
05:42:32 <Lemmih> I entered the correct value in .current-hash
05:43:05 <Lemmih> (And I re-ran the script so the emails should pop in anytime now)
05:43:21 <dcoutts> Lemmih, if you feel like it you can correct the script so it updates the .current-hash even if that hash didn't exist
05:43:36 <dcoutts> so it at least doesn't get stuck again
05:43:54 <dcoutts> I'm using the same script for the gtk2hs darcs repo
05:54:22 <roconnor> @pl f a b c d =a (b c d)q
05:54:23 <lambdabot> f = flip flip q . ((flip . (flip .)) .) . (.) . (.)
05:57:38 <Lemmih> Whee!
05:57:44 <dcoutts> ?
05:58:10 <Lemmih> It works.
05:59:34 <Lemmih> dcoutts: I'm not sure how to fix the script, though. My bash-fu is weak.
05:59:39 <dcoutts> ok :-)
06:00:23 <shapr> @yo
06:00:24 <lambdabot> PUNK ROCK!!  DISCO DUCK!!  BIRTH CONTROL!!
06:00:36 * dcoutts continues to bludgeon the borken WashNGo package
06:02:15 <dcoutts> no wonder people can't get it to build
06:05:04 <ndm> anyone here a GHCi hacker?
06:05:57 <dcoutts> ndm, try askign anyway
06:06:09 <araujo> Good morning.
06:06:19 <ndm> i want someone to add a custom prompt feature to GHCi
06:06:23 <SamB> ndm: why?
06:06:23 <SamB> not that I am
06:06:40 <ndm> winhaskell, http://www-users.cs.york.ac.uk/~ndm/projects/winhaskell.php
06:07:02 <SamB> ndm: why would such a person need to be a GHCi hacker?
06:07:04 <ndm> if i can set GHCi to a custom prompt, then i can detect when a computation in GHCi has finished
06:07:13 <ndm> because they need to modify GHCi in some way
06:07:24 <ndm> ideally the way which will make the prompt a user settable option
06:07:43 <ndm> it probably wouldn't take that long
06:07:47 <SamB> that sounds a fairly easy compared to most GHCi-related hacking
06:07:53 <ndm> but i certainly don't have time to figure out how to build GHCi
06:08:05 <ndm> which is probably the hardest bit....
06:08:13 <ndm> (esp given it requires cygwin)
06:08:43 <SamB> oh, I have no idea how to build on windows
06:08:54 <ndm> exactly, but if a unix user was able to do it
06:08:59 <ndm> then submit a patch
06:09:06 <ndm> i could download a nightly and work from that, probably
06:09:21 <ndm> i looked at the building guide once, its pages long
06:09:32 <ndm> (contrast with yhc, "makefile yhc")
06:09:59 <Lemmih> Quick guide: autoreconf && ./configure && make
06:10:09 <SamB> it isn't harder than building GHC, really... you just have to build stage2 on a platform supported by Linker.c...
06:10:18 <dcoutts> ndm, we removed nhc98 from gentoo the other day - is yhc ready to go in :-)
06:10:36 <ndm> dcoutts, probably not - you can add it if you want but it still doesn't compile many programs
06:10:51 <ndm> we're adding a cpphs tomorrow, heirarchical libs next week, then it should be ready
06:10:59 <dcoutts> ndm, heh, it'll compile more programs than nhc98 did :-)
06:11:25 <ndm> hehe, it still doesn't compile nhc's regression tests....
06:11:32 <dcoutts> nhc98 compiled no programs
06:11:53 <ndm> ah, true - the high memory bug...
06:12:28 <dcoutts> yep, nhc98 doesn't work with the linux 2.6 kernel
06:12:30 <xerox_> mauke: same mauke from #perl?
06:12:35 <mauke> yes :-)
06:12:50 <xerox_> *** Exception: Text.Regex.Posix.regcomp: error in pattern
06:12:55 <xerox_> It doesn't like (?:..) :-\
06:13:00 <ndm> ah, yhc does work in those cases, but give it a few more weeks before its nearly ready - although i am using it on a daily basis
06:13:10 <mauke> surprise, Regex.Posix isn't perl
06:13:49 <xerox_> mauke: what could I use?
06:13:58 <mauke> perl :-)
06:14:14 <xerox_> ...
06:15:45 <mauke> this interface sucks
06:16:00 <mauke> I'd use something like parsec
06:16:04 <xerox_> Agreed.
06:17:23 * xerox_ trashes Text.Regexp
06:32:40 <dcoutts> ndm, well remember to prod me when you think yhc should go into gentoo :-)
06:33:26 <ndm> dcoutts, will do
06:33:31 <xerox_> I wonder why I took in consideration Regex at first glance...
06:33:42 <xerox_> I should write a post-it.
06:34:11 * xerox_ hunts for a yellowish-partially-sticky-little-paper.
06:34:36 <kosmikus> ProfTeggy: here now
06:37:43 <xerox_> How would you consume the input until you find a string, in Parsec?
06:39:23 <xerox_> Something like "manyTill"...
06:40:02 <ProfTeggy> hi kosmikus
06:40:25 <ProfTeggy> kosmikus, I have a question regarding lhs2TeX and identifiers with underscores '_'
06:40:51 <ProfTeggy> Do I need to have %format instructions for each id containing '_'?
06:41:37 <ProfTeggy> Or is it advisable to change the Varid{} macro?
07:19:10 <kosmikus> ProfTeggy: if you want subscript formatting, then yes, you need one formatting directive for each identifier (although you can use formatting directives without a rhs)
07:19:31 <kosmikus> ProfTeggy: redefining \Varid is another option that might work for you
07:26:36 <ProfTeggy> losmikus, no, subscripting isn't what I am after here
07:27:16 <ProfTeggy> I'd like to name identifiers as they are named in the W3C XQuery formal semantics draft; and you've got names like xpath10_compatibility there
07:46:08 <xerox_> Hm.
07:46:17 <xerox_> How was to find if a string is substring of another?
07:46:23 <xerox_> @type isPrefixOf
07:46:24 <lambdabot> Not in scope: `isPrefixOf'
07:46:26 <xerox_> @type isPrefix
07:46:27 <lambdabot> Not in scope: `isPrefix'
07:46:33 <xerox_> @index isPrefix
07:46:34 <lambdabot> bzzt
07:46:37 <xerox_> @hoogle isPrefix
07:46:38 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:46:40 <xerox_> ..
07:46:44 <xerox_> @index isPrefixOf
07:46:44 <lambdabot> Data.List
07:47:13 <mauke> @hoogle [a] -> [a] -> Bool
07:47:14 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:47:14 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
07:47:14 <lambdabot> Graphics.UI.ObjectIO.CommonDef.disjointLists :: Eq x => [x] -> [x] ->
07:47:14 <lambdabot> Bool
07:47:15 <xerox_> > isPrefixOf "fu" (tails "kung fu")
07:47:16 <lambdabot> Couldn't match `Char' against `[a]'
07:47:30 <xerox_> > any (isPrefixOf "fu") (tails "kung fu")
07:47:31 <lambdabot> True
07:47:36 <xerox_> Phew.
07:49:00 <ski> > any (isPrefixOf "fu") (tails "kung fu boom")
07:49:01 <lambdabot> True
07:49:40 <int-e> > head [(x, y) | x' <- map tails (tails "abracadabra"), let (x:ys) = x', y <- ys, isPrefixOf y x]
07:49:41 <lambdabot> ("abracadabra","abra")
07:50:26 <xerox_> suppose you have:
07:50:38 <xerox_> "...TOKENfoo&...TOKENbar&..."
07:50:50 <xerox_> TOKEN being a String, '&' the char '&'.
07:51:04 <xerox_> How do you parsec-match foo, bar, and possibly more?
07:51:13 <xerox_> '...' represent random babbage.
07:53:08 <lispy> xerox_: it looks like you need to break the problem up and use a tokenizer first
07:53:28 <xerox_> Should I say that the random babbage is HTML?  :-\
07:54:09 <lispy> xerox_: if you had a stream of tokens ['TOKEN',foo,'&',...,'TOKEN',bar,'&',...] would it be easier to work with?
07:54:10 <xerox_> I really can't do it parsecish...
07:54:43 <xerox_> lispy: possibly.
07:55:09 <lispy> you can write a lexer in parsec, and that's what i would recommend.
07:55:44 <lispy> the lexer creates the stream of tokens, your parser creates a parse tree from those tokens
07:55:58 <lispy> it tends to be a good logical separation of responisbility
07:57:10 <prionic> i would recommend alex for creating the lexer
07:57:26 <tromp_> occurance of map in Data.Map is such a PITA
07:59:39 <jethr0_> xerox_: what do you mean "foo, bar and possibly more"?
08:00:30 <xerox_> jethr0_: that I'd not only match *two* things
08:01:34 <jethr0_> i still don't get it... parsec takes care of what happens _after_ applying a combinator/parser
08:02:27 <jethr0_> so, you'd say "string "foo"; string "bar"" and if you want to accept more it would simply go behind that
08:04:17 <jethr0_> and if you're line-terminated or sth, then maybe "string "foo"; string "bar"; many(noneOf "\n") ; eol;
08:05:29 <jethr0_> or instead of "many(...)" rather "manyTill anyChar eol"
08:05:37 * roconnor wonders if I should teach a computer graphics course in Haskell.
08:05:50 <xerox_> jethr0_: they're not line-separated :-\
08:06:02 <shapr> Didn't ibid have some graphics assignments in his course?
08:06:06 <jethr0_> xerox_: i'd love to help, but i don't see your problem yet
08:06:28 <xerox_> Let me try a thing and I'll be back in a second.
08:07:23 <jethr0_> np
08:07:54 <xerox_> jethr0_: if I gave you the .html you would give it a try?
08:10:03 <jethr0_> hmm, a short try, sure
08:11:08 <xerox_> http://images.google.com/images?q=foo&svnum=10&hl=en&lr=&sa=N&imgsz=xxlarge
08:11:09 <xerox_> :-)
08:11:21 <jethr0_> what do you want to parse out? or is it self-evident?
08:13:47 <xerox_> imgurl=*****&
08:13:52 <xerox_> Those "*****"
08:13:59 <jethr0_> k
08:14:04 <jethr0_> all have a go at it
08:16:07 <jethr0_> although that would be _MUCH_ easier with regular expressions or even the HTML parser...
08:16:20 <jethr0_> because defining a whole html grammar in parsec can't be much fun
08:18:36 <xerox_> I trie
08:18:39 <xerox_> Believe me, it is not.
08:18:55 <jethr0_> yes, but why not use the already existing html parser?
08:34:26 <jethr0_> xerox_: i got sth whipped up, but still having problems with parsec finishing on eof, or sth
08:36:29 <jethr0_> no, my fault, i think it's working now...
08:37:21 <ndm> i'm trying to build GHC from source and getting errors...
08:37:26 <ndm> in Sound/OpenAL/ALC/Capture.hs:85:3:
08:37:38 <ndm> any idea what i might have done wrong?
08:37:52 <ndm> (Linux, GHC from CVS, following instructions)
08:41:56 <Igloo> I suspect OpenAL is rarely built, so it may just be broken
08:46:35 <beelsebob_> :o
08:46:36 <lisppaste2> jethr0 pasted "if xerox is still with us" at http://paste.lisp.org/display/17093
08:46:43 <beelsebob_> I do believe wget just broke the laws of maths!
08:46:52 <beelsebob_> 100% transfered at 0.00kB/s
08:47:50 <jethr0_> beelsebob_: must have been a pretty small file
08:47:58 <beelsebob_> jethr0_: 32MB
08:48:05 <beelsebob_> 32.6 to be precice
08:49:34 <jethr0_> well, if it took so long as to be rounded off to "0.00" that would be also possible.
08:49:45 <beelsebob_> nope 0:00:00 seconds
08:49:48 <jethr0_> > 32*1024*1024 / 0.004
08:49:49 <lambdabot> 8.388608e9
08:49:55 <beelsebob_> I think it defaults to 0 when you get a div by zero
08:50:00 <jethr0_> > 32*1024*1024 / 0.004 / 3600 / 24
08:50:01 <lambdabot> 97090.37037037038
08:50:12 <beelsebob_> but how the hell it transfered 32.6MB that fast I don't know...
08:50:13 <jethr0_> so, you must have waitet 97090 days for that file...
08:50:17 <beelsebob_> and I suspect it didn't
08:50:24 <beelsebob_> dunno, set it to do it last night
08:50:30 <beelsebob_> so I doubt it
08:50:35 <beelsebob_> unless my computer's in a time warp
08:51:02 <jethr0_> xerox_: i think it should also work with "anyChar" instead of "anyToken"...
08:53:11 <ndm> Igloo, how do i stop it building
08:53:27 <jethr0_> CTRL-C :)
08:53:42 <beelsebob_> ndm: kill -0
08:53:44 <beelsebob_> -9*
08:54:08 <ndm> anyone any real ideas? (building GHC is not particularly fun...)
08:54:27 <Igloo> ndm: Either by not having the -dev openal libraries installed or by saying something like --disable-openal to configure
08:54:28 <xerox_> jethr0_: WEEE!
08:54:28 <ndm> and i would have thought that everyone who follows the instructions by default ends up bulding it...
08:54:47 <Igloo> Only if they have the C -dev libraries for it
08:55:07 <jethr0_> xerox_: there you are :)
08:55:50 <ndm> Igloo: thanks very much, will try that!
08:55:57 <ndm> is it worth filing a bug against?
08:56:03 <Igloo> Yes
08:56:39 <xinming_> lisppaste2: url
08:56:40 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:57:12 <ndm> ok, seems like its in the bug database already, so no need
08:58:13 <ihope> newtype Tree a = forall b . ENC (Black a b) -- parse error on input `forall'
08:58:26 <ihope> :set -fglasgow-exts
08:58:28 <ihope> :reload
08:58:36 <jethr0_> ihope: good try
08:58:39 <ihope> parse error on input `forall'
08:58:58 <ihope> So why doesn't it work?
08:59:08 <jethr0_> should the forall go into parens? never used it myself
08:59:12 <jethr0_> (forall b =>)
08:59:21 <ihope> Nope. forall foo. bar
08:59:34 <xerox_> Thank you jethr0_, I wonder what I was doing erroneously
09:00:04 <jethr0_> xerox_: does it work? the thingy i posted is absolutely evil with all its tries, etc. but it's a concise parsec solution :)
09:01:04 * shapr shoots parser arrows
09:01:26 * palomer thinks the Forall typeclass would be interesting
09:01:29 <jethr0_> shapr: how's your python hackery coming along?
09:01:38 <shapr> SSDD
09:01:59 <ihope> So why doesn't it work?
09:02:06 <ihope> Hmm...
09:02:45 <jethr0_> shapr: you don't have an easy life...
09:03:12 <xerox_> jethr0_: it's more or less what I was doing, but I read the description of some combinators wrongly :-\
09:03:17 <ihope> Bah.
09:04:08 <xerox_> jethr0_: thanks for the valuable support, I was stuck and I needed to distract (and a friend came to visit ;-))
09:04:27 <palomer> ok, someone explain to me why subtyping is undecidable
09:04:31 <palomer> and.......go!
09:05:14 <xerox_> I found a paper telling that some type of structural subtyping was decidable I think...
09:05:31 <xerox_> Well, it was some time ago, I could lookup and search it again if you will
09:06:39 <ndm> grr, and now i get a failure in Sound/ALUT, is that still OpenAL, and if so how do i really disable it?
09:07:41 <dcoutts> evening SyntaxNinja 
09:07:53 <Lemmih> @time SyntaxNinja 
09:07:58 <jethr0_> xerox_: always a pleasure to help
09:08:14 <dcoutts> ndm, is that building the OpenAL package that comes with ghc?
09:08:23 <ndm> dcoutts, i think...
09:08:28 <dcoutts> ndm, we had to patch that in gentoo to get it to build.
09:08:36 <ndm> i don't really care about it
09:08:45 <ndm> all i wnat to do is write a 10 line patch for GHCi....
09:08:55 <ndm> (or find someone who will write it for me, ideally)
09:09:11 <Igloo> dcoutts: Why not send the patches upstream, then?
09:09:17 <dcoutts> http://www.gentoo.org/cgi-bin/viewcvs.cgi/dev-lang/ghc/files/ghc-6.4.1-openal.patch?rev=1.1&view=auto
09:09:26 <dcoutts> Igloo, I'll get round to it...
09:09:34 <Igloo> Heh
09:10:02 <Igloo> If you put it off you'll only waste more time fixing the patch up for future releases  :-)  (well, maybe not in such a quiet piece of code)
09:10:15 <dcoutts> I know, I know :-)
09:10:33 <ndm> if you put it off, people like me will cry while building ghc
09:11:04 <ndm> i still seem to get those errors, even with --disable-openal (assuming ALUT is from openal)
09:11:28 <dcoutts> ndm, we only added it 2 days ago! it's hardly been tested
09:11:35 <ndm> hehe, fair enough
09:11:50 <ndm> anything i have to do after rerunning configure, make clean or anything?
09:11:51 <Igloo> Oh, I assumed it was something you'd had hanging around since at least the 6.4.1 release
09:11:54 <palomer> I mean full out, no holds bar subtyping
09:12:20 <gour> dcoutts or Lemmih: any url with some of the latest hiDE (mocking) snapshots?
09:12:27 <dcoutts> Igloo, we only recently noticed that we'd never enabled openal
09:12:27 <Igloo> ndm: I'd try just disabling opengl too
09:12:43 <ndm> Igloo: --disable-opengl ?
09:12:52 <Igloo> No idea, ask configure --help
09:13:38 <Lemmih> gour: Have you seen the screenshots page on the new wiki? I think it contains the most recent screenies.
09:14:04 <gour> @where hIDE
09:14:04 <lambdabot> http://haskell.org/haskellwiki/HIDE
09:14:24 <gour> Lemmih: where is new wiki?
09:14:50 <dcoutts> Igloo, turns out it's already been fixed upstream :-)
09:14:59 <Lemmih> gour: http://haskell.org/haskellwiki/Screenshots_of_HIDE
09:15:23 <gour> Lemmih: thanks
09:25:39 <gour> dcoutts: any amd64 news?
09:25:51 <dcoutts> gour, about hIDE you mean?
09:26:22 <gour> dcoutts: yep, i'm preaching about itm, but cannot build it myself :-(
09:26:34 <dcoutts> gour, I've not tried yet
09:27:29 * gour preaches (hIDE) theory (again) :-)
09:31:50 <Lemmih> How do you downgrade 'make' under Debian?
09:33:11 <gour> dcoutts, Lemmih i'm chatting with scribes dev about the possibility to embed the editor in hIDE
09:33:39 <dcoutts> gour, sounds unlikely
09:33:43 <gour> he says it would be easy if hIDE speaks dbus
09:33:54 <dcoutts> we don't have dbus bindings yet
09:33:59 <gour> but this is probably not on the agenda
09:34:18 <dcoutts> dbus bindings would be cool, but I don't have the time
09:35:22 <gour> how hard would be by making dbus bindings to make hIDE dbus-aware?
09:35:53 <xerox_> Lemmih: there are many automake1.# packages.
09:36:15 <xerox_> Lemmih: then you use update-alternatives.
09:36:47 <xerox_> What is 'scribes' ?
09:37:24 <Lemmih> xerox_: How do I use update-alternatives?
09:37:45 <gour> xerox_: http://scribes.sourceforge.net/
09:38:11 <xerox_> Lemmih: update-alternatives --list automake
09:38:23 <xerox_> Lemmih: update-alternatives --set automake <path>
09:38:43 <Lemmih> ah.
09:39:02 <Lemmih> xerox_: Thanks.
09:39:07 <Lemmih> @karma+ xerox
09:39:07 <lambdabot> xerox's karma raised to 11.
09:39:13 <xerox_> Lemmih: you're welcome :-D
09:43:11 <Lemmih> 'make' still loops when compiling GHC. *sigh*
09:47:33 <Igloo> Lemmih: Use make 3.80
09:51:44 <xerox_> Do we have a random-filename-generation function a-la mkstep?
09:51:47 <xerox_> *temp
09:53:16 <jethr0_> @hoogle mkstemp
09:53:16 <lambdabot> No matches found
09:53:27 <jethr0_> xerox_: System.Posix.Temp.mkstemp
09:53:33 <xerox_> Hmm!
09:53:45 <xerox_> In fact I do not need a "temporary" location, but whatever.
09:54:16 <xerox_> Once I'll put up a darcs repo people could give me they're opinions :-)
09:55:31 <jethr0_> xerox_: darcs repo of what?
09:55:46 <xerox_> A random wallpaper changer ^_^
09:55:53 <ndm> Lemmih: for me it doesn't look, it just doesn't work :)
09:56:20 <jethr0_> xerox_: you mean like this "new" apple thing. where you fetch the wallpapers out of the internet right away?
09:56:39 <xerox_> I do not know about any apple thing :-\  But the description kinda matches.
09:56:54 <xerox_> It's fun :-)
09:57:05 <jethr0_> i'm sure
10:00:35 <SyntaxNinja> howdy all
10:02:22 <rep> http://www.gearthblog.com/blog/archives/2006/02/cheney_shooting.html
10:07:39 <mwc> good afternoon everybodh
10:08:11 <Lemmih> Igloo: Is it a problem with make or the GHC makefiles?
10:08:40 <Igloo> make, but it won't be fixed for 3.81, so effectively the GHC Makefiles too
10:09:36 <Lemmih> Igloo: Has the bug been reported? Got an URL to it?
10:10:07 <palomer> yay for ada!
10:10:44 <Igloo> glasgow-haskell-bugs@ earlier this week links to the make bug discussion
10:11:38 <tromp_> what
10:11:53 <tromp_> what's the best way to show a byte as 2 hex digits?
10:14:03 <musasabi> use an array of 16 chars and index it with the nibles
10:16:46 <tromp_> i have showHex2 byte = let s = showHex byte [] in if length s == 1 then '0':s else s
10:17:01 <musasabi> tromp_: there is a function in Numeric to do that also
10:17:02 <tromp_> seems it'll be ugly no matter what:(
10:18:38 <palomer> data -> :: (* -> * -> *) where Lambda :: Term a -> Term b -> (Term (a,b)) <--does anyone get the spooks when they read this?
10:19:13 <xerox_> Please beat me with something.
10:19:39 <xerox_> I'm writing all my io actions as '... >> return undefined' in order to keep their type general...
10:20:03 * xerox_ hates exceptions.
10:22:10 <musasabi> > let hex x = [f mod, f div] where f op = "0123456789ABCDEF" !! (op x 16) in hex 63
10:22:11 <lambdabot> "F3"
10:22:20 <musasabi> tromp_: is that ugly?
10:22:32 <roconnor> return undefined?
10:22:57 <tromp_> about as ugly as what i have:(
10:24:37 <MarcWeber> What did I do wrong this time (kind error) http://www.rafb.net/paste/results/9jWn9V49.html
10:26:46 <basti_> MarcWeber: i'm puzzled
10:27:11 <MarcWeber> What do you mean?
10:27:29 <roconnor> wow, can you really name type variables like that.  cool.
10:27:42 <basti_> MarcWeber: i dont have a clue why it breaks
10:28:42 <sjanssen> @hoogle fork
10:28:43 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
10:28:43 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
10:29:59 <MarcWeber> basti_ You would have said that it works, wouldn't you? mmhh..
10:30:10 <basti_> MarcWeber: yes i would, had i checked it.
10:30:31 <basti_> I trusted your statement that it's broken.
10:34:21 <MarcWeber> basti: would you mind trying to compile the whole file? http://www.rafb.net/paste/results/9a0zkx43.html.. Do you get this error, too?
10:35:33 * basti_ tries
10:36:08 <Lemmih> MarcWeber: r -> Dep -> Bool?
10:36:25 <basti_> yes i line 82
10:36:45 <basti_> which is obvious, because Dep wasn't given a parameter
10:37:06 <araujo> Hi there.
10:37:30 <basti_> hi araujo 
10:37:52 * ValarQ waves at araujo 
10:39:45 <araujo> Hello basti_ , ValarQ 
10:39:53 <araujo> What's up in the lambda world? :-)
10:39:56 <sjanssen> @hoogle sleep
10:39:56 <lambdabot> No matches found
10:40:30 <sjanssen> @hoogle wait
10:40:30 <lambdabot> Graphics.UI.GLUT.Window.Wait :: Cursor
10:40:30 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
10:40:30 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
10:41:43 <basti_> my back is aching and i will move tomorrow
10:43:13 <basti_> Then I'll be without 'net for a few days
10:45:04 <MarcWeber> Very misleading error message
10:45:26 <basti_> MarcWeber: why?
10:45:39 <MarcWeber> because the error is caused 2 lines above..
10:46:58 <pierre-> hello
10:47:02 * basti_ doesnt understand, his ghc gives the right line number
10:47:05 <basti_> hi pierre- 
10:47:38 * pierre- finally found "the craft of fp"
10:47:52 * pierre- danses
10:48:38 <ulfdoz> A good book.
10:50:50 <xerox_> Wee, it works.
10:56:33 <xerox_> jethr0_: ping
10:58:16 <xerox_> http://haskell.galois.com/~paolo/woopee.png
11:02:31 <Cale> xerox: what does it do? Find new backgrounds on the web?
11:02:47 <xerox_> Yup.
11:02:58 <Cale> cool :)
11:03:03 <xerox_> Let me share it :-)
11:16:34 <pierre-> @type foldr
11:16:35 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
11:17:42 <pierre-> can someone explain me how this works? (it transposes the matrix some way): 
11:17:47 <pierre-> transp = foldr (zipWith (:)) inflist
11:17:47 <pierre-> where
11:17:47 <pierre-> inflist = []:inflist
11:18:13 <mauke> @pl inflist = []:inflist
11:18:14 <lambdabot> inflist = fix ([] :)
11:18:53 <xerox_> Cale and whoever is interested (and has HTTP package) darcs get http://haskell.galois.com/~paolo/darcs/woopee/
11:19:18 <xerox_> Hmm, I'd better write the dependices somewhere.
11:20:29 <Cale> pierre-: nice :)
11:21:03 <mauke> I don't get it
11:22:06 <Cale> > let inflist = []:inflist in zipWith (:) [1,2,3] inflist
11:22:07 <lambdabot> [[1],[2],[3]]
11:22:22 <xerox_> heh
11:22:31 <Cale> > let inflist = []:inflist in zipWith (:) [1,2,3] (zipWith (:) [4,5,6] inflist)
11:22:33 <lambdabot> [[1,4],[2,5],[3,6]]
11:22:48 <xerox_> ski discovered it some time ago...
11:23:10 <Cale> It's a beautiful rendition of transpose :)
11:23:12 <xerox_> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
11:23:13 <lambdabot> [[1,4,7],[2,5,8],[3,6,9]]
11:23:22 <xerox_> It's great yeah.
11:23:34 <Cale> of course :)
11:23:35 <xerox_> It has some problems with some kind of infinite lists tho.
11:23:48 <pierre-> so, how does this work? i can't get it at all...
11:23:50 <xerox_> OK, a little patch, try out woopee! :-)
11:23:56 <xerox_> Pizza calls ;-)
11:24:03 <Cale> pierre-: did you see my examples?
11:24:10 <pierre-> yes
11:24:43 <Cale> pierre-: picture (foldr f z) as the function which replaces each (:) in its argument with f and the [] at the end with z
11:25:06 <jlenor1_> @seen ski
11:25:06 <lambdabot> I saw ski leaving #haskell-overflow, #haskell-blah and #haskell 2 hours,
11:25:06 <lambdabot> 39 minutes and 21 seconds ago.
11:25:35 <Cale> http://cale.yi.org/autoshare/folds.png -- this has some pictures of common folds and scans
11:25:59 <Cale> of course, in this case, you have a list of lists which you're folding over
11:27:00 <Igloo> That scanl pic is really quite pretty, but I can't imagine it helping your average UG much  :-)
11:27:19 <Cale> Igloo: well, if you look at it closely, it can help
11:27:52 <Igloo> Yeah, it took me a couple of seconds to work out what was going on, and then my head stopped hurting  :-)
11:28:07 <jlenor1_> anyone here used LF?
11:28:33 <Igloo> The others are immediately really clear, though. Looks nice  :-)
11:28:39 * Igloo vanishes
11:28:47 <jethr0_> xerox_: pong
11:29:29 <jethr0_> xerox_: bbl
11:29:36 <Cale> pierre-: zipWith (:) takes a list xs and a list of lists xss, and conses each of the elements of xs on to the heads of corresponding elements of xss
11:30:26 <Cale> and that's exactly what transposing is all about, turning a row into a column :)
11:31:25 <jlenor1_> @type zipWith (:)
11:31:26 <lambdabot> forall a. [a] -> [[a]] -> [[a]]
11:31:42 <mauke> hmm, transpose == zip
11:31:48 <jlenor1_> so the length of the 2 first arguments have to be the same?
11:32:04 <Cale> jlenor1_: well, the longer one gets truncated
11:32:17 <Cale> but ideally, they're the same
11:32:41 <musasabi> dons: ping
11:33:30 <sjanssen> STM is way too easy
11:33:43 <musasabi> until you mix IO into it.
11:33:49 <mauke> ah, transpose (x : xs) = zipWith (:) x (transpose xs)
11:34:08 <Cale> mauke: sure
11:34:19 <mauke> I get it :-)
11:34:20 <pierre-> @type (:)
11:34:20 <lambdabot> forall a. a -> [a] -> [a]
11:34:57 <jlenor1_> \@type zipWith
11:35:10 <jlenor1_> @type zipWith
11:35:11 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
11:36:26 <palomer_> hrmm
11:36:34 <palomer_> I wonder if haskell 2 will have existential types
11:36:52 <palomer_> does anyone know if let-polymorphic existentialism is decidable?
11:37:03 <Beelsebob> haskell' you mean?
11:37:15 <Cale> haskell' and haskell 2 are different :)
11:37:24 <Beelsebob> ohh, really?
11:37:33 <Cale> haskell' isn't likely to have anything new in it
11:37:43 <palomer_> anything ghc doesn't already have
11:38:14 <palomer_> in fact, it won't even have GADTs!
11:38:28 <palomer_> Cale, btw, type inference for GADTs is decidable
11:38:40 <Cale> palomer: really? That's neat.
11:39:22 <Cale> The goal of Haskell' is to standardise current practice and clean up any small things which couldn't be fixed due to conflicts with Haskell 98.
11:39:53 <palomer_> so it's pretty irrelevant to all those who use ghc extensions without flinching
11:40:07 <palomer_> Cale, do you think they'll remove the monomorphism restriction?
11:40:12 <Cale> well, even so, there are a lot of those details
11:40:14 <Cale> I'm not sure
11:40:25 <Cale> There are a lot of people who are for the monomorphism restriction
11:40:31 <palomer_> because...?
11:40:51 <Cale> because it makes the language more consistent in terms of performance
11:41:17 <Beelsebob> palomer: the problem with the ghc extensions is that they make it impossible for a tool implementer to support what people are using
11:41:22 <int-e> because, ironically, it saves them writing type signatures
11:41:25 <Beelsebob> the tool implementer never knows what to support
11:41:39 <musasabi> Just having liberal single parameter classes + some irks killed + module system changes (gtk2hs) + ffi into the standard proper will be quite a lot.
11:42:06 <palomer_> this is a performance issue?
11:42:11 <palomer_> surely some static analysis can fix this
11:42:19 <palomer_> static analysis can fix _anything_
11:42:32 <int-e> uhm, the problem are overly polymorphic bindings together with separate compilation
11:42:42 <Cale> well, actually, you need some runtime support here too
11:42:51 <Cale> but I think it's fixable
11:43:00 <Cale> which is why I don't want it standardised
11:43:14 <palomer_> don't want what standardised?
11:43:20 <Cale> We shouldn't standardise on limitations of current technology :)
11:43:25 <Cale> the M-R
11:43:48 <dcoutts> musasabi, mm, yes I'd really like the module system stuff to allow us to do Button.new rather than having to do buttonNew
11:43:50 <palomer_> oh, righto
11:44:17 <palomer_> dcoutts, you can do that with import qualified, no?
11:44:23 <musasabi> M-R usually goes away with eta-expanding / type signature, so it is not that annoying.
11:44:33 <Cale> Basically, the problem is that typeclass bounded polymorphism has this common implementation where an extra dictionary parameter gets passed.
11:44:46 <dcoutts> palomer_, not when Graphics.UI.Gtk export over 100 modules, it doesn't scale
11:44:58 <Cale> Which can turn pattern bindings into function bindings silently.
11:45:09 <musasabi> But some class work needs to go in - it is silly that "instance Foo String" is still not allowed.
11:45:11 <Cale> Which means that results no longer get shared.
11:45:29 <dcoutts> palomer_, each user's program would need dozens and dozens of lines of qualified imports just to import Gtk
11:45:31 <palomer_> dcoutts, so we need a hierarichal module system?
11:45:51 <palomer_> oh, this is a different problem
11:45:53 <palomer_> hmm
11:45:58 <palomer_> and haskell' is going to fix this?
11:46:03 <dcoutts> palomer_, we've got hierarichal module names
11:46:04 <Cale> possibly, yeah
11:46:09 <dcoutts> palomer_, I hope so :-)
11:46:17 <Cale> It'll fix things where the fix is relatively trivial :)
11:46:40 <palomer_> Button.new would be nice
11:46:41 <palomer_> indeed
11:47:13 <palomer_> so the fix for this is what exactly?
11:48:06 <Cale> allow modules to reexport identifiers qualified
11:48:08 <palomer_> higher order modules isn't even proposed in haskell'!
11:48:21 <palomer_> Cale, export Foo as F ?
11:48:42 <palomer_> you guys know this can all be done with higher order modules, right:o?
11:49:17 <palomer_> module F = Foo
11:50:40 <Cale> I suppose you'd be able to put something like  module Foo qualified as F  in export lists.
11:51:17 <palomer_> well, gotta go!
11:51:20 <palomer_> cyas
11:58:17 <andersca> hello
12:02:51 <xerox_> jethr0_: http://haskell.galois.com/~paolo/darcs/woopee
12:03:21 <sjanssen> @hoogle Word
12:03:22 <lambdabot> Data.Word.Word :: Word
12:03:22 <lambdabot> GHC.Exts.Word :: Word
12:03:22 <lambdabot> Data.List.words :: String -> [String]
12:06:19 <xerox_> Cale: did you try it out?
12:11:40 <chrisbrown> hi all
12:12:17 <ValarQ> hi you
12:14:06 <chrisbrown> can anyone think of a good domain name involving haskell?
12:14:49 <gour> Cale: is there any of proposal in Haskell' which should not be present in e.g. Haskell-2
12:15:04 <mauke> 4CHAN.org -- comprehensive haskell archive network
12:20:01 <xerox_> mauke: haha.
12:20:20 <sieni_> mauke: :-D
12:20:56 <sieni_> startkeylogger
12:21:06 <xerox_> sorry?
12:21:16 <sieni_> http://www.hm2k.org/news/1137968795.html
12:21:26 <sieni_> xerox_: just testing if anybody quits
12:21:47 <sieni_> it actually works, people are teasing this one guy eith norton personal firewall on a finnish channel :-)
12:22:17 <xerox_> really?
12:22:25 <sieni_> yes
12:22:35 <xerox_> It's though to believe :-)
12:22:51 <sieni_> tough ;-)
12:32:41 <gizban> if I create a algebraic type and make it deriving(show).  How do I change the format that the algebraic type get's displayed.
12:33:25 <sjanssen> gizban: remove the deriving clause, and write the Show instance yourself
12:35:26 <gizban> sjanssen: you mean write  a show function that takes my algebraic type as a parameter?
12:35:52 <sjanssen> gizban: sort of, have you learned how to work with classes yet?
12:35:58 <gizban> sort of
12:37:10 <gizban> I read my insturctions wrong.  I wasn't supposed to use deriving.  It says to make "Instruction" an instance of Show.
12:45:07 <jethr0_> xerox_: cool
12:45:13 <xerox_> :-D
12:45:42 <jethr0_> xerox_: you working at galois?
12:45:47 <xerox_> Nope.
12:51:15 <kolmodin> sieni_: I just typed startkeylogger in another channel and it works, great fun :)
12:51:27 <sieni_> kolmodin: ^_^
12:51:45 <kolmodin> muhahhaah :)
12:51:59 <integral> kolmodin == jeek? o_O
12:52:18 <integral> err, ignore that
12:52:28 <kolmodin> integral: they rejoin in like 1 sec :)
12:53:00 * integral was just getting confused after seeing "startkeylogger" pop up on another _network_ not just channel
12:53:29 <kolmodin> ah
12:53:58 <kolmodin> well, I did it on another network
12:54:50 <kolmodin> my guess is that quakenet has far more norton users than freenode :)
12:58:23 <gizban> how do I convert an Int to String?   I want to     show "asdf " ++ 5
12:58:33 <xerox_> > show 1
12:58:34 <jethr0_> "asdf" ++ (show 5)
12:58:35 <lambdabot> "1"
12:59:27 <gizban> thanks
13:01:25 <JKnecht> "asdf " ++ (show 5)
13:02:32 <xerox_> > "asdf " ++ (show 5)
13:02:33 <lambdabot> "asdf 5"
13:07:28 <Lemmih> > printf "asdf %d" (5::Int) :: String
13:07:29 <lambdabot> "asdf 5"
13:08:20 <gizban> > show "DAT" ++ (show 15)
13:08:21 <lambdabot> "\"DAT\"15"
13:08:35 <gizban> how do I get rid of the \" ?
13:08:58 <gizban> > show DAT ++ (show 15)
13:08:59 <lambdabot>  Not in scope: data constructor `DAT'
13:09:28 <Lemmih> > "DAT" ++ show 15
13:09:28 <lambdabot> "DAT15"
13:10:32 <jethr0_> xerox_: don't you think that the multiple liftIOs are more of a hassle then passing the search term "manually"?
13:10:42 <gizban> Lemmih: thanks
13:11:40 <xerox_> jethr0_: my subcoscious told me that!
13:13:06 <jethr0_> i must say i really like the program. although i'm not sure how good a source of wallpapers google image search is...
13:13:29 <xerox_> jethr0_: thank you :-D
13:13:49 <xerox_> Patches are welcome!
13:19:31 <kolmodin> a friend tested the startkeylogger thingie in another channel, we counted 20 quits :)
13:19:50 <jethr0_> why would people quit?
13:20:06 <kolmodin> norton kills their connection to the irc network
13:20:12 <jethr0_> :)
13:20:15 <jethr0_> why???
13:20:20 <xerox_> Really?
13:20:21 <kolmodin> 21:20 < sieni_> http://www.hm2k.org/news/1137968795.html
13:20:27 <jethr0_> k
13:20:30 <kolmodin> yes, it works great :)
13:20:57 <kolmodin> jethr0_: some antivirus / antitrojan thing I suppose
13:21:18 <jethr0_> that would seriously p*ss me off if it happened more than casually
13:21:32 <gizban> is there rule that functions can't start with a capital?
13:21:42 <xerox_> gizban: yes.
13:21:50 <jethr0_> gizban: yes, capital names are reserved for constructors
13:22:00 <gizban> ok, thanks
13:22:13 <kolmodin> exactly, but constructors are themselves functions
13:23:10 <jethr0_> nobody disputed that. maybe the answer should have been "no, but ..."
13:24:01 <Cale> xerox: yeah, it works well :)
13:24:23 <Cale> (your background finder :)
13:24:48 <xerox_> Oh-yeah! :-)
13:25:55 <jethr0_> cale, is there a place to submit code that isn't "good" enough for cabal?
13:28:09 <xerox_> kolmodin: I think the threat does not exist...
13:28:27 <kolmodin> xerox_: what?
13:28:33 <jethr0_> coz' i've been writing all kinds of small, nice programs and don't know what to do with them :)
13:28:37 <xerox_> startkeylogger
13:28:47 <kolmodin> xerox_: you don't think it works?
13:28:53 <xerox_> Yeah.
13:29:05 <basti_> the comments say the chance of having a Quit is about 1:100
13:29:14 <basti_> that firewall is pretty rare
13:29:21 <kolmodin> xerox_: it does work, just find a channel with lots of windows users
13:29:32 <kolmodin> and the norton firewall :)
13:29:34 <xerox_> I tried in some places where certainly were *many*.
13:30:12 <kolmodin> I tried in a channel with 16 people, one quit
13:30:25 <xerox_> 65 there.
13:30:28 <kolmodin> and rejoined after 1 sec, so no harm done
13:30:32 <xerox_> 0 quits.
13:31:00 <xerox_> Ouch.
13:31:07 <xerox_> A *possible* quit.
13:31:21 <kolmodin> a friend made over 20 people quit in #pokersnack on quakenet
13:31:56 <xerox_> hehe
13:32:03 <xerox_> I retried, and he falled again.
13:32:17 <kolmodin> I think there are less windows users on freenode than on quakenet :)
13:32:49 <xerox_> maybe more...
13:33:00 <xerox_> Pingtimeouts.
13:33:01 <kolmodin> maybe
13:33:15 <kolmodin> yes, some get ping timeouts, some read errors
13:33:31 <xerox_> *many*, in fact.
13:33:53 <jethr0_> maybe i should doubt xerox' account now and start my own little experiment :)
13:34:20 <xerox_> If I coult ping timeouts as *all* caused by me they would be...
13:34:44 <xerox_> 1
13:34:44 <xerox_> 16
13:35:19 <kolmodin> how many got ping time-outs the minutes before you typed it? not that many, huh? :)
13:35:23 <xerox_> Two.
13:35:30 <xerox_> Well, it seem to work.
13:35:37 <kolmodin> :D
13:35:54 <kolmodin> the read error is more fun, though, since it happens directly :)
13:36:08 <xerox_> 22:35 < xxxx> Gr33nMi|3: startkeylogger
13:36:08 <xerox_> 22:35 -!- Gr33nMi|3 [~killall@xd-85-20-75-127.bo1.albacom.net] has quit [Connection reset by peer]
13:36:55 <xerox_> Well, ok, now Haskell :-)
13:37:20 <kolmodin> :)
13:37:26 * jethr0_ quickly disables his norton firewall for linux
13:37:43 <kolmodin> heh :)
13:37:59 <xerox_> There exist?
13:38:05 <jethr0_> no, i don't think so
13:38:10 <kolmodin> no way :)
13:38:14 <ndm> @index showSDoc
13:38:14 <lambdabot> bzzt
13:40:36 <Lemmih> Outputable
13:40:42 * jethr0_ is going to get started with yampa now
13:40:46 <jethr0_> i think so, at least
13:40:53 <jethr0_> any yampa gurus around?
13:40:58 <xerox_> I want to get started with yampa too!
13:41:22 <jethr0_> i'm not quite sure how much of a hassle it will be. but i'd really like to write a simple game with it
13:41:31 <xerox_> Do you have some url?
13:41:44 <xerox_> I was never been able to find the right sources
13:41:59 <jethr0_> url? not really. there's the "yampa arcade" paper and "frag"...
13:42:03 <jethr0_> not much to go on
13:42:14 <jethr0_> and some examples in the yampa distribution
13:42:37 <jethr0_> oh, and the thesis describing "frag"
13:44:54 <jethr0_> oh, and the space invaders example of one of the original yampa papers
13:45:37 <ndm> does anyone have any experience with GHC, in particular <> <+> showSdoc combinators?
13:46:34 <ndm> or just have a clue which module they are defined in!
13:47:18 <jethr0_> outputable
13:48:21 <ndm> jethr0_: thanks
13:48:32 <ndm> have you ever used them?
13:48:39 <jethr0_> i just echoed what lemmih said after googling for it inconclusively :)
13:48:50 <jethr0_> no, are those pretty printing combinators?
13:49:10 <jethr0_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
13:50:28 <xerox_> kosmikus: i succeeded to talk with one of this people and hunt down the bug, it is a switchable option or something, hehe.
13:51:20 <Lemmih> ndm: Problems?
13:51:34 <ndm> Lemmih: i think i've figured it out now, thanks
13:51:59 <ndm> wsa just trying to determine if text (a++b) was equal to text a <> text b (answer: yes)
13:55:47 <ndm> is there an easy and faster way to rebuild part of ghc?
13:56:01 <ndm> i.e. i have changed a single file in ghci, and want to rebuild faster
13:56:26 <Lemmih> It should only rebuild what's needed.
14:24:29 <kowey> question about arrows and the S+W parser:
14:24:52 <kowey> if i simplify the static parser by removing the bool flag (telling us if the parser accepts the empty string)
14:25:12 <kowey> would i have simplified things so far that they are useless?
14:25:36 <kowey> (simplifying for expository purposes, this is for the arrows wikibook module)
14:30:46 <jyp> Anyone coming to fosdem this weekend ? http://www.fosdem.org/2006
14:31:07 <jyp> (David Roundy will give a talk)
14:31:43 <kowey> a handful of darcs people will be there, at least 5
14:32:44 <kolmodin> I would if I could
14:34:26 <jyp> Too bad... Well, just to let you know that I'll be around.
14:37:46 <palomer> does unification commute?
14:38:49 <palomer> and does it associate?
14:42:29 <palomer> @seen ski
14:42:30 <lambdabot> I saw ski leaving #haskell-overflow, #haskell-blah and #haskell 5 hours,
14:42:30 <lambdabot> 56 minutes and 43 seconds ago.
14:45:11 <Yagi> hi
15:01:26 <palomer> ok, someone guess who can now pattern match on both integers and booleans
15:01:34 <palomer> not everyone at once!
15:02:57 <basti_> Either?
15:03:32 <palomer> no, it's me!
15:03:49 <basti_> why not leave the job to either?
15:05:37 <palomer> no, I can pattern match, gah!
15:05:55 <basti_> hmm
15:06:01 <basti_> you yourself?
15:06:11 <basti_> like, you look at "True" and know it's a bool? ;)
15:06:38 <basti_> I don't understand what you want to say
15:11:57 <xerox_> palomer: you did write the extension?
15:13:17 <palomer> http://www.rafb.net/paste/results/Dg0ybm96.html <--how do you write this properly?
15:13:20 <palomer> xerox: which extension?
15:13:35 <palomer> s/write/indent
15:13:36 <Philippa> he means his own language/implementation
15:13:55 <palomer> xerox_: I'm currently implementing it
15:14:01 <palomer> xerox: it'll be done by this weekend (hopefully)
15:14:21 <palomer> it's a really trivial extension,though
15:14:23 <Philippa> personally, I figured for testbed purposes it was OK if the constructors for every type went in one really /big/ set (I figured using Int rather than Integer was okay, mind)
15:14:57 <palomer> Philippa: they're not supposed to?
15:16:25 <palomer> oh, forgot a paren
15:16:32 <Philippa> heh
15:17:17 <Philippa> point is, once you've got that the built-in types're fairly trivial to define if you don't have a Num class or similar to worry about
15:17:33 <Philippa> (even then the types're easy - the type-checking a little less so but still plenty doable)
15:18:03 <palomer> oh, I don't have any built in types
15:18:30 <palomer> i don't find them useful for demonstrative purposes
15:18:45 <xerox_> palomer: http://www.rafb.net/paste/results/K6ep3x85.html
15:18:50 <xerox_> palomer: I didn't try it, tho
15:19:10 <Philippa> I find having to include datatype definitions in everything a PITA for demonstrative purposes :-)
15:19:23 <Philippa> though ints and bools're as far as I generally bother with
15:20:04 <palomer> ints and bools add 4 lines of code!
15:20:24 <palomer> oh, you mean writing S(S(Z)) ?
15:21:12 <dons> musasabi, yo.
15:21:27 <palomer> actually, 6 lines with the new syntax
15:27:01 <xerox_> Anybody following the Haskell' discussion know if it was talked about lifting sugar?
15:27:13 <xerox_> Well.. sugar for liting :-)
15:30:11 <palomer> Philippa: you could always include a prelude
15:33:38 <Philippa> true. By the time you want support for integer literals it's easier to hardcode though
15:33:50 <Philippa> (you effectively get a hardcoded prelude + sugar, but hey)
15:34:06 <Excedrin> if I have a file created by a C program via something like "float ar[100]; ... write(fd, &ar, sizeof(ar))", what's the easiest way to read the result in Haskell?
15:37:41 <tromp> can't you write the floats in text format?
15:40:58 <Excedrin> tromp: I didn't generate the file(s) originally, so I could translate them, but it would take a while. I guess writing a small C program and using the FFI is the easiest way?
15:41:29 <tromp> u cld write a c program that reads them in binary, and just rewrites them in text
15:42:31 <Excedrin> yes, but as I said, I have a lot of data like this, so translating would take a long time and lots of disk space
15:42:45 <tromp> then getContents >= map read . unlines
15:42:53 <tromp> no you cld just pipe it
15:42:56 <musasabi> dons: do you think using TH to generate a specialized lexer for regexdna would do well?
15:43:16 <tromp> bintotext < floatfile | haskellprog
15:43:43 <Excedrin> I see, yea, that's a possibility
15:44:21 <davidmccabe> if f is a function that evaluates to 10, how come I can say:
15:44:26 <davidmccabe> g = 10 ** 2
15:44:27 <davidmccabe> but not
15:44:32 <davidmccabe> g = (f) ** 2
15:44:41 <tromp> 10 is polymorphic
15:44:41 <davidmccabe> the later tells me:
15:44:53 <davidmccabe> polymorphic?
15:45:01 <davidmccabe> so, I have to specify what type f is?
15:45:07 <tromp> 10 can be Int or Integer or Float
15:45:21 <tromp> ** doesn't work on Ints
15:45:31 <davidmccabe> oh.
15:45:32 <davidmccabe> thanks!
15:45:54 <tromp> 10 is really (fromIntegral 10)
15:46:01 <davidmccabe> that's kinda bizarre.
15:46:13 <tromp> it's useful
15:46:23 <davidmccabe> ok, I'll trust you for now :P
15:46:45 <tromp> use ^ for integer powers
15:46:52 <davidmccabe> that doesn't work either, though.
15:47:02 <tromp> > 10^2
15:47:04 <lambdabot> 100
15:47:07 <davidmccabe> no wait, it does.
15:47:19 <davidmccabe> but ^^ doesn't.
15:47:25 * davidmccabe wimpers.
15:52:17 <davidmccabe> so, how do I convert an Int to a Float? (I can find float->int but not the other way around in the docs)
16:02:21 <Excedrin> there's GHC.Float.int2Float
16:05:02 <resiak> could you just divide by 1? :)
16:05:23 <wilx> > (fromIntegral 1) :: Float
16:05:24 <lambdabot> 1.0
16:25:36 <dons> musasabi, possibly. I've rewritten our entry to parse string-based regexes into combinators dynamically -- with no performance lost (but another 70 lines for the String -> Regex parser)
16:26:15 <dons> i..e (regex "\n|>[^\n]+\n" `action` const Nothing)
16:26:25 <dons> yay for obscurity. i hope they like it :)
16:27:11 <gizban> I have a function that returns Maybe (Int,[Integer]).  The function that receives the result has an if statement that says "if result == Nothing then 0  else fst(result).    But fst(result is not allowed).   What's wrong?
16:27:45 <mauke> fst takes a pair, not Just pair
16:27:54 <gizban> how do I convert it to a pair?
16:28:04 <mauke> @type maybe
16:28:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:28:07 <davidmccabe> > 1 :: Float
16:28:08 <lambdabot> 1.0
16:28:20 <davidmccabe> wilx: what's the (fromIntegral) part for?
16:28:29 <dcoutts> @seen CosmicRay
16:28:30 <lambdabot> I saw CosmicRay leaving #haskell 20 hours, 28 minutes and 8 seconds ago,
16:28:30 <lambdabot> and I have missed 1 second since then.
16:28:34 <mauke> > maybe 0 fst (Just (23, []))
16:28:35 <lambdabot> 23
16:28:45 <mauke> > maybe 0 fst Nothing
16:28:46 <lambdabot> 0
16:28:58 <mauke> gizban: in general, you use pattern matching
16:32:28 <wilx> @type fromIntegral
16:32:29 <lambdabot> forall b a. (Num b, Integral a) => a -> b
16:42:11 <davidmccabe> so are you saying that in Haskell, if I want to divide two integers i and k and get a non-truncated result, I have to say:
16:42:30 <davidmccabe> ((fromIntegral i) :: Float) / ((fromIntegral k) :: Float)
16:42:37 <davidmccabe> is that really the easiest way to do it?
16:43:58 <mauke> > let fdiv a b = fromIntegral a / fromIntegral b in 1 `fdiv` 2
16:43:59 <lambdabot> 0.5
16:44:02 <Saulzar> Well, you usually don't need the type annotation - ::Float if you use the result as a float (return it from a function annotated as float for example)
16:48:17 <davidmccabe> http://zvon.org/other/haskell/Outputprelude/fromIntegral_f.html
16:48:20 * davidmccabe blinks.
16:49:09 <sjanssen> davidmccabe: problem?
16:49:20 <davidmccabe> the Description and Example fields are blank.
16:49:29 <davidmccabe> so, let me get this straight.
16:49:42 <davidmccabe> in haskell, you cast *from* the type you already have, instead of *to* the type you want. is that right?
16:50:10 <sjanssen> davidmccabe: in Haskell, there is no "cast"
16:50:14 <mauke> Integral isn't a type, actually
16:50:24 <mauke> fromIntegral     =  fromInteger . toInteger
16:50:43 <davidmccabe> I guess I'll have to read up more on the type system.
16:50:49 <sjanssen> fromIntegral is a function that turns some kind of integral number (Int and Integer are the notable ones) to any kind of number
16:50:57 <davidmccabe> Haskell seems to be obsessed with types.
16:51:21 <mauke> yes!
16:51:37 <davidmccabe> I understand the virtue of declarative programming,
16:51:46 <davidmccabe> but what good does being obsessed with types really do?
16:52:07 <Blicero_> thats like asking "what good does being obsessed with writing correct programs do"
16:52:17 <davidmccabe> no it's not.
16:52:25 <mauke> the compiler can tell you about obviously wrong expressions
16:53:09 <araujo> davidmccabe, it is not an obsession, it is a help
16:53:23 <gzl> davidmccabe: generally by the time you get the program to compile the program is more or less correct
16:53:25 <davidmccabe> I'm sort of used to the utility of a language being inversely proportional to the amount one has to worry about that sort of thing.
16:53:37 <Saulzar> You fight the type system, you run it and it almost always works
16:53:59 <gzl> I mean, saying "worry" is kind of vague
16:54:01 <Saulzar> Rather than you can compile almost anything, you run it and get a segmentation fault
16:54:09 <gzl> in Java, you have to worry in the sense that you have to put explicit type annotations all over the place
16:54:18 <gzl> in Haskell you don't, but it's also strict when it comes to type checking
16:54:19 <davidmccabe> Saulzar: or, you run it and you get a wrong answer,
16:54:28 <davidmccabe> Saulzar: which the types don't really prevent.
16:54:37 <araujo> davidmccabe, what do you mean with 'worry'?
16:54:37 <davidmccabe> in fact, I have a terminal here with a wrong answer printed out on it.
16:54:48 <Saulzar> They prevent a large catagory of errors, though
16:54:59 <davidmccabe> gzl: so, fromIntegral wouldn't count as a type annotation in any sense?
16:55:11 <davidmccabe> araujo: I mean, think about.
16:55:11 <Saulzar> I am continually amazed how I can compile some haphazardly put together program at 4am and it seems to work :)
16:55:29 <gzl> davidmccabe: not really
16:55:33 <davidmccabe> gzl: how not really?
16:55:50 <davidmccabe> because in, say, ruby, or common-lisp, I could just divide.
16:55:51 <davidmccabe> and it would just work.
16:55:58 <davidmccabe> I'm not complaining.
16:56:10 <araujo> davidmccabe, you need to think about something when programming :-]
16:56:11 <davidmccabe> I'm just trying to figure out why this is the way it is.
16:56:15 <gzl> on the one hand, that's convenient, and on the other hand, you frequently get dynamic typing errors at runtime in languages like python or what have you
16:56:16 <davidmccabe> araujo: not types.
16:56:29 <araujo> davidmccabe, mmm.. Why not?
16:56:43 <araujo> davidmccabe, Programming is only about types :-]
16:56:47 <davidmccabe> araujo: there are more important things to think about, like what your program shoudl be doing.
16:57:06 <gzl> but thinking about the types IS thinking about what the program should be doing
16:57:07 <araujo> Reasoning about types helps you to be a better programmer at any language therefore
16:57:10 <davidmccabe> gzl: not really.
16:57:19 <gzl> if you don't think so, you need to sit down and write some Haskell
16:57:37 <davidmccabe> well, that's just what I'm doing.
16:57:46 <davidmccabe> but so far I think it's ridiculous.
16:57:47 <gzl> you're also arguing about stuff in the abstract before you really see how things work
16:57:48 <araujo> davidmccabe, such as?
16:58:14 <Pseudonym> Let me put it this way.
16:58:16 <sjanssen> davidmccabe: give it a little while -- the type system _will_ impress you eventually
16:58:27 <Pseudonym> The time you spend thinking about types early in Haskell is time you're not spending debugging in Lisp later.
16:58:53 <Pseudonym> Fixing a design problem is easier the earlier you catch the problem.
16:59:04 <araujo> davidmccabe, and you receive this extra flavor on Haskell of type inference that rapid prototyping possible too.
16:59:17 <araujo> that makes rapid...*
16:59:26 <davidmccabe> I just don't see how all this type declaration can save you from badly mangling the design and implementation of a program.
16:59:43 <araujo> davidmccabe, see what i just said :-]
16:59:55 <davidmccabe> araujo: see, this is where I'm coming from
17:00:00 <Pseudonym> Nothing will stop you from mangling a design if you try hard enough.
17:00:06 <gzl> but you're frequently *not* declaring types
17:00:11 <Pseudonym> The point is to prevent mistakes that a compiler CAN catch.
17:00:12 <sjanssen> davidmccabe: can you show the channel what you're working on?  I bet we could take away all of your explicit type declarations
17:00:12 <davidmccabe> araujo: up until this point I've always thought that the less the language imposses upon you, the more rapidly you can prototype.
17:00:13 <gzl> much of the time the type inference will do that automatically
17:00:13 <Blicero_> obviously types cant save a bad programmer from himself
17:00:28 <Saulzar> It forces you to think things through... if you annotate your types you can more easily see where things are going wrong (and the compiler gives you better error messages back)
17:01:04 <araujo> davidmccabe, You first need to understand something, this is not an obstacle, it is a help.
17:01:08 <Pseudonym> It's true that the less the compiler asks of you, the more bugs you can write.
17:01:16 <araujo> davidmccabe, now imagine how fast you can rpototype with such a help :-]
17:01:20 <Pseudonym> But personally, I like programming and hate debugging.
17:01:29 <Blicero_> you may be able to prototype faster, but you're only trading off time later spent debugging and writing the actual implementation
17:01:58 <Pseudonym> Yes, your compiler will accept your code faster.  But the bugs will still be there.
17:02:01 <davidmccabe> well, I'll keep giving it a try and we'll see if I see the light.
17:02:36 <davidmccabe> at this point it's mysterious to me how type obsession can catch non-trivial bugs. but we'll see.
17:02:41 <davidmccabe> I assume you guys aren't all on crack.
17:03:08 <araujo> davidmccabe, it is not obsession, it is type help :-]
17:03:41 <Pseudonym> I will be honest with you.  There's a deep sense in which it's no better or worse.
17:03:59 <Pseudonym> In Real Programming(tm), you have to test anyway.
17:04:05 <Pseudonym> And I mean test systematically.
17:04:20 <davidmccabe> I know.
17:04:24 <davidmccabe> That's why I don't see what good it does.
17:04:31 <Pseudonym> The time that you spend getting your types right is _actually_ time that you don't have to spend writing certain kinds of test.
17:04:57 <Pseudonym> The plus side is that once you've got the types right, the program is often correct.
17:05:00 <Pseudonym> As in, completely correct.
17:05:33 <Pseudonym> Until you have one of these moments where once your compiler accepts your program it turns out to be bug-free, you really won't get it.
17:05:48 <davidmccabe> oh, that's already happened.
17:05:55 <Pseudonym> There you go. :-)
17:05:55 <davidmccabe> In haskell and a number of other languages.
17:06:09 <davidmccabe> On the other hand, I have a haskell program here that compiles, runs, and gives a wrong answer.
17:06:15 <davidmccabe> And so far I haven't figured out where the math is wrong.
17:06:32 <davidmccabe> (but it's the math, not haskell, because it does this in both languages I've written it in)
17:06:45 <davidmccabe> (kind of thing typing won't do anything about)
17:07:14 <Pseudonym> Right.
17:07:28 <Pseudonym> But for programs that do structure hacking, this property often holds in Haskell.
17:07:51 <Saulzar> I once had a robocode robot which had a faulty aim because of integer casting by accident :)
17:08:07 <davidmccabe> in other languages, I often will have structures like ((string, float), (string, float) ...)
17:08:11 <davidmccabe> can I do that kind of thing in haskell?
17:08:19 <Blicero_> yes
17:08:23 <davidmccabe> ok good.
17:08:27 <mauke> a map or a list of pairs?
17:08:33 <davidmccabe> a list of pairs.
17:08:44 <davidmccabe> and other kinds of type mixing.
17:08:53 <Pseudonym> @type [("Hello", 1), ("world", 2)]
17:08:54 <lambdabot> forall b. (Num b) => [([Char], b)]
17:08:59 <Pseudonym> Errr...
17:09:02 <Pseudonym> @type [("Hello", 1), ("world", 2 :: Int)]
17:09:03 <lambdabot> [([Char], Int)]
17:09:06 <Pseudonym> Right.
17:09:11 <Pseudonym> Or [(String,Int)]
17:09:20 <mauke> @type [("foo", 1.2), ("bar", 3.4)]
17:09:21 <lambdabot> forall b.
17:09:21 <lambdabot>            (Fractional b) =>
17:09:21 <lambdabot>            [([Char], b)]
17:09:27 <davidmccabe> is () a distinct type from []?
17:09:31 <Pseudonym> Yes.
17:09:35 <Pseudonym> () is the empty tuple
17:09:38 <mauke> @type ((), [])
17:09:38 <lambdabot> forall a. ((), [a])
17:09:40 <davidmccabe> ok.
17:09:48 <Pseudonym> Pairs and lists are distinct.
17:10:12 <davidmccabe> can you have mixed types in lists or tuples that don't follow a regular pattern?
17:10:23 <davidmccabe> brb.
17:10:54 <Pseudonym> The short answer is: Not quite.
17:11:14 <Pseudonym> Yes, you can do it.  No, not in the same way you'd do it in Lisp or Python.
17:14:05 <ihope> Any good red-black trees out there?
17:14:41 <ihope> Or maybe a better self-balancing tree?
17:15:02 <sjanssen> ihope: Data.Map not doing it for you?
17:15:19 <ihope> Never heard of it.
17:15:44 <ihope> I guess I should have, as it sounds standard.
17:16:18 <sjanssen> ihope: do you need the guts of a tree, or just a data structure with O(log n) lookup and such?
17:16:33 <ihope> Just fast lookup.
17:16:44 <sjanssen> ihope: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
17:17:18 <ihope> Looks good. Thanks.
17:19:32 <davidmccabe> back.
17:19:44 <davidmccabe> Pseudonym: I see.
17:20:59 <davidmccabe> can you do it in a way that would actually be useful, or would it just be a kind of trick?
17:21:16 <davidmccabe> in the way that partial function application in python is a trick.
17:21:54 <Pseudonym> No, it'd be useful.
17:22:07 <Pseudonym> Can you give me a concrete example where you'd want it?
17:22:35 <davidmccabe> I do that kind of thing from time to time in Python for a variety of reasons.
17:22:41 <davidmccabe> Let me think of one.
17:24:29 <davidmccabe> Usually I'm using that kind of thing as a table that a function will do something in accordance with.
17:24:33 <Pseudonym> The reason why I ask is that the way to do it depends on what you want.
17:24:45 <Pseudonym> For example, sometimes what you really want is variant records.
17:25:03 <Pseudonym> In which case the best thing to do is declare a variant record type.
17:26:32 <ozone> behold le procrastinat0r
17:26:49 <Saulzar> davidmccabe, Maybe for that you can use a list/table of functions and hide the (arbitrary) data that way
17:26:51 <blackdog> actually, no - I was just looking for shapr. plone sucks...
17:29:20 <Pseudonym> And you thought he might be hanging around with us losers?
17:29:47 <blackdog> something like that :)
17:30:10 <blackdog> man, i miss haskell. i haven't coded something i can actually be proud of for months.
17:30:14 <davidmccabe> Saulzar: ok. I'll check back when I get to that complicatedness of programs in Haskell.
17:32:05 * Pseudonym plays with lilypond
17:32:15 <davidmccabe> mmmm, lilypond.
17:32:20 <Pseudonym> Good stuff.
17:32:22 <davidmccabe> we have at least something in common :)
17:32:26 <Pseudonym> :-)
17:32:35 <davidmccabe> I still don't really understand the fromIntegral.
17:32:36 <Pseudonym> Well, I have an old copy of Finale 2000, but it won't install cleanly on XP.
17:32:43 <Pseudonym> @type fromIntegral
17:32:43 <lambdabot> forall b a. (Num b, Integral a) => a -> b
17:32:47 <davidmccabe> but who wants to use Finale?
17:32:54 <Pseudonym> Well, I did until this morning.
17:33:16 <davidmccabe> when you can type your music into Emacs and have in printed so it doesn't look like it was printed on a teletype.
17:33:19 <Pseudonym> fromIntegral is one of a number of functions which are used to get around the fact that implicit casts don't make sense in Haskell.
17:33:33 <Pseudonym> But who wants to use Emacs?
17:33:39 * Pseudonym basks in the vim goodness
17:33:52 <davidmccabe> either way.
17:34:02 <davidmccabe> s/Emacs/a fine text editor/
17:34:07 <Pseudonym> Indeed.
17:34:16 <Pseudonym> Get a decent text editor.  Learn to use it well.
17:34:42 <Pseudonym> The only thing I think I'd miss is the ability to play music in.
17:34:51 <gzl> I dunno. I find vim a little lacking for programming.
17:35:01 <davidmccabe> well if this were emacs you could write up a lilypond-mode that did just that :P
17:35:02 <Pseudonym> But it'd be nice post-editing it in my favourite text editor.
17:36:06 <Pseudonym> gzl: What does it lack for you?
17:36:22 <davidmccabe> an IRC client.
17:36:26 <davidmccabe> (for me)
17:36:30 <Pseudonym> An implementation of Eliza, yes.
17:36:32 <Pseudonym> All that crap.
17:36:49 <mauke> davidmccabe: there is an irc plugin
17:36:51 <davidmccabe> see, you talk about types
17:36:58 <Pseudonym> As they say, Emacs is a nice operating system, but it's a terrible text editor.
17:37:00 <davidmccabe> I don't see how you can get anything done without doctor-mode.
17:37:07 <gzl> well, to take something from Emacs, you can't really interact with a toplevel with vim (as far as I could tell)
17:37:20 <gzl> the language support in general seems to be minimal beyond syntax highlighting
17:37:51 <mauke> gzl: there's also indenting and possibly folding
17:37:57 <mauke> davidmccabe: http://www.vim.org/scripts/script.php?script_id=931
17:38:02 <Pseudonym> vim has indenting and folding
17:38:08 <Pseudonym> Folding == nice.
17:38:10 <gzl> yeah, it does indenting and folding, but beyond that, there's very little
17:38:27 <davidmccabe> Pseudonym: for example, there probably isn't a haskell-eval-line.
17:38:28 <Pseudonym> Well, it also has keyword/identifier completion.
17:38:36 <gzl> does it?
17:38:41 <Pseudonym> Sure.
17:38:44 <Pseudonym> ^X
17:38:57 <mauke> and jump-to-definition, and jump-to-error-location
17:39:22 <Pseudonym> You're right that it doesn't have a haskell-eval-line.
17:39:26 <gizban> first of all, everything works fine if I export everything instead of only exporting my algebraic type called Instruction.  I'm getting the error "Undefined constructor function ADD".  ADD is an enum type of Instruction.   I'm exporting Instruction, but how do I export the constructors of Instruction too?
17:39:34 <gzl> well, I'm talking about stuff in general, not just Haskell.
17:39:41 <gzl> like there's nothing comparable to the Emacs python mode either.
17:39:41 <davidmccabe> Pseudonym: that kind of thing is really nice.
17:39:49 <gzl> and there are lots of IDE features that neither Emacs nor vim reasonably support.
17:39:50 <Pseudonym> I guess because I use GUI interfaces a lot, I find alt-tab very natural.
17:39:50 <eivuokko> gizban, Foo(..)  to export all ctors
17:39:52 <gzl> without a lot of scripts and crap.
17:39:55 <davidmccabe> python-mode is *reallllyyyy* nice.
17:40:07 <gzl> for vim?
17:40:13 <mauke> what is python mode?
17:40:16 <davidmccabe> for emacs; were you talking about vim?
17:40:22 <gizban> eivuokko: thanks
17:40:24 <davidmccabe> mauke: python-mode is emacs editing a python file.
17:40:34 <gzl> ah yes
17:40:38 <gzl> the emacs python mode is nice
17:40:45 <mauke> and?
17:41:01 <davidmccabe> mauke: and it's really nice.
17:41:33 <davidmccabe> sorry, I might be a little confused as to how that thread flowed.
17:41:37 <gzl> I find it annoying to use editors like Emacs or vim when a lot of language features are introduced. like vim won't support most of these things at all, and when Emacs does, the keyboard shortcuts are nonexistent or awkward.
17:42:34 <gzl> M-x haskell-perform-some-action is pretty annoying in my book
17:42:42 <davidmccabe> yes.
17:42:48 <davidmccabe> but less annoying that switching to an xterm to do it.
17:43:02 <Pseudonym> I'm not convinced of that.
17:43:05 <Pseudonym> But each to their own.
17:43:06 <gzl> but more annoying than using some GUI editor that has more logical keybindings.
17:43:13 <Pseudonym> I like having lots and lots of open windows.
17:43:16 <gzl> or where you can access stuff more easily in a menu
17:43:28 <Pseudonym> And virtual desktops to put them in.
17:43:34 <gzl> I like text-based editing fine up to a point, but it just doesn't scale.
17:44:02 <davidmccabe> text-based editing as opposed to?
17:44:19 <gzl> er, sorry. I meant CLI vs GUI. not editing something other than text
17:44:23 <davidmccabe> ah.
17:45:40 <Pseudonym> Gotta go.  Dentist.
17:45:56 <Pseudonym> I'll be one tooth shorter and less wise in a couple of hours.
17:46:00 <davidmccabe> bye Pseudonym.
17:46:02 <Pseudonym> BBL
17:46:06 <davidmccabe> good luck!
18:25:02 <ihope> Yay, subliminal popup ad.
18:55:51 <palomer> ski: you around?
19:12:35 <palomer> it's like the internet died or something
19:17:24 <palomer> ok guys ,something deeply wrong
19:17:34 <palomer> I'm consistently getting code to run
19:17:44 <benc_> yeah, the internet's off today.
19:19:29 <palomer> s/something/something's
19:21:21 * lispy reboots the Internet
19:21:37 <palomer> hullo lispy 
19:21:41 <palomer> how's it hanging?
19:21:53 <lispy> like a monkey :)
19:21:58 <palomer> btw, you should consider changing your nick to hasky 
19:22:19 <lispy> i'm a little ruffled about amazon not taking my money...they have the book i want but they can't seem to charge my card
19:22:39 <lispy> iirc the proposal was to change to lambdy
19:22:52 <dons> typey?
19:22:57 <palomer> dopey
19:22:58 <lispy> curry?
19:23:05 <dons> curry. yes. i like that.
19:23:13 <palomer> curryy
19:23:16 <lispy> mmm mmm curry
19:23:22 <dons> classy.
19:23:32 <lispy> classy is the OO lispy
19:23:54 <palomer> I like classy
19:24:13 <palomer> we have classes too, you know
19:24:23 <lispy> originally i was lispservice but that was just too long
19:24:54 <palomer> goofy
19:26:51 <Korollary> lispy: use the call me button
19:27:54 <lispy> Korollary: what page can i got to that from?  I've been looking for something liket hat
19:28:15 <Korollary> lispy: it should be on every help page
19:30:01 <lispy> Korollary: ah, i just didn't click through far enough
19:34:30 <lispy> my call is very important
19:37:04 <palomer> how do you pattern match with records?
19:38:13 <Cale> Either the usual way (positionally) or by giving a record with variables in it, like MyRec { label1 = x }, which may leave out some of the fields.
19:39:13 <Cale> There is one notable case where no fields are matched, which is actually always available, regardless of whether record syntax was used when defining the type
19:39:30 <Cale> as in, MyRec {}
19:40:43 <palomer> Myrec {} is the "I am a record  but you know nothing else about me" pattern?
19:43:11 <dons> hehe, "if you cannot see this message, you do not have cookies enabled" umm...
19:44:20 <palomer> addDataDeclaration (dataDeclaration s k lst) (SEnvironment {sTypeTable = stt,sFunctionTable = sft,sConstructorTable = sct}) =  <--what's wrong with this definition?
19:45:42 <palomer> I get a parse error
19:51:24 <palomer> I really don't see what could be the parse error?
19:52:46 <palomer> oh my
19:53:34 * wli oohs at Haskell server pages.
20:09:01 <palomer> do you guys see a problem with adding constructors after the type has been declared?
20:10:04 <astrolabe> I don't, if you have access.
20:10:53 <sjanssen> @pl fst . snd . id . id
20:10:53 <lambdabot> fst . snd
20:30:09 <palomer> http://www.rafb.net/paste/results/Pm3fNP62.html
20:30:43 <palomer> http://www.rafb.net/paste/results/nRBKmT92.html
20:31:12 <palomer> using many to parse things can lead to some interesting results
20:37:18 <palomer> is the following legal in ghc 6.5: data Foo:: (*->*) -> * where Bar :: (Foo Maybe) ?
20:43:17 <palomer> grrr
20:43:21 * palomer pokes ski
20:57:22 <palomer> hmmm, I have to understand type constructors better
21:04:42 <Pseudonym> Lilypond == pure distilled goodness
21:10:51 <palomer> the annotation software?
21:11:29 <Pseudonym> Errr... notation, yes.
21:13:14 <palomer> oh, righto
21:16:15 <palomer> the grammar for types is almost identical to the grammar for expressions
21:16:16 <palomer> very strange
21:16:59 <Pseudonym> Deliberate, too.
21:17:04 <Pseudonym> Well, happy coincidence, anyway.
21:19:53 <palomer> it's also strange that the interpretations of types is dependent on a specific type constructor
21:19:53 <palomer> ->
21:22:55 <palomer> actually the grammar isn't identical
21:22:56 <palomer> phew
21:23:22 <palomer> for example (a b) c is not a valid type
21:23:25 <palomer> while (a b c) is
21:25:27 <palomer> hmm, specifying this grammar is proving harder than I thought
21:27:05 * palomer slaps this whole channel
21:27:09 <palomer> is everyone out on a date?
21:27:36 <juhp> anyone have a pointer to gtk2hs packages for sid?
21:27:53 <juhp> (someone is asking me)
21:28:39 <palomer> there's a link to a repository on the webpage
21:28:50 <palomer> however, the newest cvs has many improvements
21:30:01 <juhp> http://haskell-unsafe.alioth.debian.org/archive/i386/unstable/g/gtk2hs/ seems a little old
21:32:08 <juhp> ok, this http://mentors.debian.net/debian/pool/main/g/gtk2hs/
21:32:47 <palomer> I seriously recommend the cvs version
21:32:53 <palomer> I even contributed to it:O)!
21:33:00 <palomer> my first open source contribution
21:33:58 <palomer> whew, the grammar for types is really, really interesting
21:37:07 <Cale> darcs version now :)
21:38:20 <palomer> oh, yeah, darcs
21:38:28 <palomer> cale! you come when I have no need for you
21:38:32 <palomer> what bad timing:p
21:38:34 <Cale> hehe
21:38:47 <palomer> Cale: what do you think of this:
21:39:12 <palomer> data Foo :: (* -> *) -> * where Bar :: Int -> Foo Maybe
21:40:20 <palomer> (this is, unfortunetly, illegal)
21:40:36 <palomer> why? I have no idea (thought you could enlighten me)
21:40:59 <Cale> ought to work
21:41:02 <Cale> but it might not, you'd have to try it
21:41:03 <Cale> probably no good reason. GADTs are experimental
21:41:09 <Cale> I wouldn't consider the implementation of GADTs to be complete
21:41:16 <dons> morning Cale ;)
21:41:34 <dons> hehe
21:41:34 <Cale> morning :)
21:41:36 <Cale> heh
21:41:41 <Cale> midnight :)
21:43:11 <palomer> so forall a b c. (a b c) -> (a (b c) (b c a)) is a syntactically valid type, right?
21:43:59 <palomer> woot, I now have custom declared datatypes
21:45:52 <Cale> syntactically, it ought to be. Looks like something which is probably a kind error
21:46:13 <palomer> yeah, probably
21:46:41 <palomer> what about forall a b c. (a b) c ?
21:46:59 <Cale> yeah, that should be equivalent to forall a b c. a b c
21:47:10 <Cale> (I'd hope :)
21:47:20 <palomer> hrm, let's ask ghci
21:47:30 <Cale> > (3,5) :: ((,) Int) Int
21:47:32 <lambdabot> (3,5)
21:47:34 <Cale> yeah
21:47:46 <palomer> that makes parsing a bitch
21:48:34 <palomer> what about forall (a :: *->*) a ?
21:48:56 <palomer> what would be a value of that type?
21:52:59 <dons> ask djinn to find one ;)
21:53:34 <palomer> kinds boggle the mind
21:53:44 <palomer> I don't know how to reason with them
21:55:29 <Cale> Identity
21:55:54 <Cale> @type Control.Monad.Identity.Identity
21:55:55 <lambdabot> forall a.
21:55:55 <lambdabot>             a -> Control.Monad.Identity.Identity a
21:56:02 <Cale> oh
21:56:04 <Cale> hehe
21:56:25 <dons> type constructors need to be saturated no? so let v :: forall (a :: * -> *) (b :: *) . a b = undefined
21:56:43 <palomer> saturated?
21:56:47 <dons> or am I on crack?
21:57:24 <palomer> what does saturated mean?
21:57:55 <Cale> yeah, they do
21:57:59 <ncalexan> Not partially applied.
21:58:16 <Cale> There's no values of a type constructor with kind * -> *
21:58:39 <dons> you can't write the one you originally wanted. but the value 'v' above is ok, palomer
21:59:20 <dons> Prelude> let v :: forall (a :: * -> *) . a = undefined
21:59:20 <dons> <interactive>:1:32:
21:59:20 <dons>     `a' is not applied to enough type arguments
21:59:20 <dons>     Expected kind `*', but `a' has kind `* -> *'
22:00:43 <palomer> and, erm, where can we read about the saturation restriction?
22:00:49 <palomer> in fact, where can one read about type constructors?
22:01:24 <dons> Haskell 98 report, presumably. (for point 1). Point 2, TaPL?
22:03:14 <dons> palomer, check section 4.1.2 of the H98 report (regarding poin 2).
22:03:55 <palomer> tapl it is
22:07:56 <Cale> palomer: basically all he's saying is that there are no values of type 'Maybe', since it's not a type, but a type constructor
22:08:36 <palomer> ok
22:08:58 <palomer> but how would one interpret something of the sort forall a. t where t has kind * -> * ?
22:09:04 <palomer> logically, what does it represent
22:09:52 <Cale> well, the quantifier doesn't bind anything there
22:10:18 <Cale> it's certainly not a type
22:10:21 <palomer> I meant that t represents a type term which has kind * -> *
22:10:36 <palomer> forall a. Either a
22:10:57 <Cale> that's part of a type
22:11:07 <Pseudonym> Night.  Gotta go.
22:11:22 <palomer> if you saw forall a. Either a, what would you think?
22:11:42 <Cale> I'd think kind error
22:12:01 <Cale> You're allowed to have constructors in classes though
22:12:10 <Cale> but not with foralls, as far as I know
22:13:48 <palomer> there must be an interpretation
22:14:17 <palomer> it must represent something!
22:14:22 <palomer> it would be so natural if it did
22:14:39 <palomer> (there is, of course, the obvious interpretation)
22:14:50 <palomer> I'm sure E gives it some meaning
22:16:03 <Cale> the odd part is that you're quantifying
22:16:13 <Cale> "Either a" by itself is fine
22:16:52 <Cale> It's a type constructor
22:17:14 <Cale> but normally you wait until you have an actual type (possibly with variables in it) before quantifying
22:34:23 <palomer> yeah
22:36:42 * palomer will have to ponder this
22:40:47 <wolverian> hm, why is Maybe a monad? can't it be represented with [a] and []?
22:42:10 <dons> you could have a list monad too :)
22:42:11 <araujo> [] is also a monad
22:42:14 <ncalexan> It can be.
22:42:14 <dons> so, why not?
22:42:34 <wolverian> oh, duh.
22:42:37 <wolverian> thanks :)
22:43:11 <Cale> It's not always good to have more functionality in your monad than needed.
22:43:36 <ncalexan> True that.  Singleton lists contain traps of great variety and danger.
22:44:46 <eivuokko> In this case, yeah, they do. (if by singleton list you mean list of one element)
22:45:02 <ncalexan> I do.
22:45:43 <eivuokko> And anyway, even if that wasn't the case, it would be pretty inconvient to apply a wrapper between maybe and [] just to use monadic operations.
22:48:43 <dons> @remember ncalexan Singleton lists contain traps of great variety and danger.
22:49:23 <ncalexan> That is a permutation of a Cale quote: ...contain Sprynges of Great Danger or something similar.
22:49:28 <wolverian> so, why is [] a monad? 
22:49:54 <ncalexan> Well, it satisfies the monad laws... and is convenient for use.
22:50:15 <ncalexan> It represents non-deterministic computations.
22:50:22 <ncalexan> Those with many possible answers
22:50:46 <dons> yeah, it has:     m >>= k             = foldr ((++) . k) [] m which is good enough for me :)
22:50:57 <ncalexan> Ah yes: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
22:51:06 <ncalexan> dons: does not set and some other things satisfy that too?
22:51:06 <dons> can you say: M is for Monad, it's good enough for me :)
22:52:10 <dons> or are cookie-monster references too obscure?
22:52:19 <Cale> hehe
22:52:20 <ncalexan> Nope, I got that :)
22:52:21 <dons> ncalexan, Set, hmm.
22:53:09 <ncalexan> Cale is the Set-as-monad evangelist.
22:53:13 <ncalexan> s/as/is/
22:55:55 <dons> Cale is the forall a. a-as-monad evangelist ;)
22:56:29 <ncalexan> Yes, I think that's true.  I like it, though -- reasoning about computation gets easier with a monad.
22:56:38 <ncalexan> It would be nice if set was in class Monad.
22:57:11 <dons> hmm, it's not even in Functor?
22:57:37 <Cale> dons: right
22:57:38 <ncalexan> I think there are key-monotonicity issues.  Should it map \v->v or \(k,v)->(k,v)?
22:57:45 <dons> it's in Monoid though
22:57:49 <ncalexan> Is that correct, Cale?
22:58:03 <ncalexan> Like how (,) is not in Functor.  (Which I hate, BTW.)
22:58:12 <Cale> Well, (,) can be in Functor
22:58:15 <Cale> er
22:58:21 <Cale> ((,) a) can be in Functor
22:58:26 <ncalexan> :)
22:58:32 <Cale> but Set can't
22:58:38 <Cale> @type Data.Set.map
22:58:39 <lambdabot> forall b a.
22:58:39 <lambdabot>       (Ord b, Ord a) =>
22:58:39 <lambdabot>       (a -> b) -> Data.Set.Set a -> Data.Set.Set b
22:58:48 <Cale> The Ord constraints kill it
22:59:22 <dons> ah, yes, but this is ok: instance Ord a => Monoid (Set a) where 
22:59:31 <Cale> If you define
22:59:36 <Cale> class Functor f a where
22:59:39 <Cale> er
22:59:42 <Cale> class Functor f a b where
22:59:53 <Cale>    map :: (a -> b) -> (f a -> f b)
23:00:14 <Cale> then you can define an instance (Ord a, Ord b) => Functor Set a b
23:00:19 <Cale> but this is ugly
23:00:35 <ncalexan> Why ugly?
23:01:22 <Cale> well, you conceptually don't really want the implementation of map to vary on the types a and b
23:01:43 <Cale> (up to the differences in the implementation of Ord)
23:01:44 <ncalexan> Mmm, I see that, thanks.
23:02:06 <dons> anyone know how to get 'Raw' src of the new wiki pages?
23:02:12 <dons> a la the old wiki?
23:25:41 <davidmccabe> heh.
23:25:46 <davidmccabe> the gnome icon for haskell has a lambda.
23:25:55 <davidmccabe> that's funny, since haskell doesn't really use lambdas a lot, right?
23:26:34 <dons> sure it does!
23:26:50 <dons> > map (\x -> x +1) [1..10]
23:26:51 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
23:26:59 <dons> we're lambda-crazy!!
23:29:34 <dons> (check the 'officiial logo on haskell.org -- it's got a  big lambda)
23:30:27 <ncalexan> I suppose we don't explicitly write a lot of lambdas.  I personally prefer where clauses, and read a lot of code that does as well...
23:31:45 <Lemmih> I write lots of lambdas.
23:32:27 <Lemmih> 'withX someData $ \x -> ' is just so amazingly useful.
23:33:11 <Lemmih> And 'flip mapM_ elems $ \elem -> '
23:41:44 <dons> Interesting, I count 800 lambdas in the base libraries, 660 lets and 1600 'where's
23:41:48 <davidmccabe> dons: oh. right.
23:42:15 <davidmccabe> I saw on the wiki "don't overuse lambdas", so I assumed that haskell was a bit less lambdaful than lisp.
23:42:28 <dons> anyway, the lambda is because Haskell is based on lambda calculus. Not that it has a lambda :)
23:42:37 <davidmccabe> heh.
23:43:14 <dons> well, if you only programmed in lambdas -- used it exclusively as your binding form -- that would be very bad style :)
23:43:16 <davidmccabe> and here I thought the icon artist had just used lambda as a generic icon for weird languages.
23:43:25 <davidmccabe> ;P
23:43:27 <davidmccabe> gnight.
23:57:01 <dons> @yow
23:57:02 <lambdabot> I don't believe there really IS a GAS SHORTAGE ... I think it's all
23:57:02 <lambdabot> just a BIG HOAX on the part of the plastic sign salesmen -- to sell
23:57:02 <lambdabot> more numbers!!
23:57:15 <dons> that's pretty funny 
