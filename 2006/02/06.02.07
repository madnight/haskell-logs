00:00:00 <lambdabot> System.Win32.Types not available
00:00:01 <pierre-> i mean the current process instance, usually passed to WinMain() in C
00:00:11 <dons> yeah, we don't lik in -package win32
00:00:13 <dons> s/lik/look/
00:01:42 <pierre-> i tried write "main :: HINSTANCE -> IO ()", but it seems to be impossible 
00:01:53 <Korollary> That's not likely to be valid anyways
00:02:54 <Korollary> System.Win32's description says "An FFI binding to the system part of the Win32 API. " That sounds like you need to have winmain elsewhere.
00:03:37 <pierre-> in C code?
00:05:01 <Korollary> It could be already in package win32. I'm just guessing here.
00:15:52 <gour> dcoutts_: ping
00:16:54 <vincenz> Hello
00:17:13 * vincenz is on a redhat system without ghc and would like to install it, but sadly for rpm installation you need to be root, any suggestions?
00:18:05 <gour> vincenz: download ghc-bin and then compile from the source
00:18:15 <vincenz> gour: where do I get ghc-bin
00:18:28 <gour> vincenz: on gentoo there is one
00:18:50 <vincenz> rpms suck
00:20:05 <gour> vincenz: i agree. this is in gentoo ghc-bin ebuild: mirror://gentoo/${P}-x86.tbz2
00:20:29 <gour> vincenz: so, you should be able to download e.g. 6.4.1 from some mirror
00:20:35 <vincenz> thx
00:21:17 <pierre-> wow... i found it -- hinstance is got by calling getModuleHandle
00:21:25 <vincenz> gour: I only need the bin?
00:21:43 <gour> vincenz: afaik, yes
00:21:49 <vincenz> not libs?
00:22:04 <vincenz> downloading the i386-unknown leads to a version without bin
00:22:53 * vincenz tries again
00:23:13 <gour> vincenz: see e.g. http://gentoo.osuosl.org/distfiles/ghc-bin-6.4.1-x86.tbz2 (22M)
00:23:40 <vincenz> ghc-6.4.1: missing -B<dir> option
00:25:27 <gour> vincenz: you downloaded it?
00:25:38 <vincenz> I downloaded the unknown i386 from ghc site
00:26:53 <gour> no idea. i bootstrapped via gentoo's ghc-bin
00:28:52 <vincenz> they should really build a minimal haskell98 compiler in c, then you compile that with gcc, and then comiple ghc with that haskell98 compiler (with no fancy stuff)
00:29:58 <Saulzar> Is ghc even haskell98 code though?
00:30:06 <vincenz> well bootstrap
00:30:12 <shapr> yhc is something like that
00:30:26 <vincenz> c -> simple h98 -> ghc -> recompile ghc with ghc to make it efficient
00:30:43 <dons> mostly H98, yep.
00:30:49 <vincenz> would be a good idea
00:30:56 <dons> (or earlier)
00:30:59 <vincenz> just make a minimalistic compiler with no fancy stuff
00:31:06 <dons> though it uses unboxed stuff. 
00:31:08 <vincenz> just to get ghc compiled so you can recompile ghc with ghc
00:31:12 <shapr> The YHC plan is to have a platform independent bytecode runtime written in portable C.
00:31:16 <vincenz> crud
00:31:23 <vincenz> Could not find module `System.Directory': use -v to see a list of the files searched for (imported from Compat/Directory.hs)
00:31:44 * vincenz is trying to compile ghc after having downloaded the unknown-bin one to bootstrap with
00:33:12 <vincenz> suggestions?
00:34:42 <gour> vincenz: now you can maybe try with rpm-src?
00:34:46 <vincenz> how do I tell it the libdir?
00:34:59 <vincenz> cause right now I'm using
00:35:17 <vincenz> ./configure --with-ghc="/scratch/ghc-6.4.1/bin/i386-unknown-linux/ghc -B/scratch/ghc-6.4.1/lib/i386-unknown-linux" --with-prefix=/scratch
00:35:30 <vincenz> I might have to tell the i386-unknown-linux one where to find it's own libs
00:41:10 <gour> vincenz: http://www.haskell.org/ghc/docs/latest/html/building/index.html
00:41:38 <vincenz> all this just to get darcs :P
00:42:01 <gour> vincenz: you have darcs binaries..
00:42:03 <vincenz> honestly: c -> uneff h98 compiler -> ghc -> recompile ghc with ghc
00:42:11 <vincenz> odd...
00:42:14 <vincenz> very odd
00:42:22 <Cale> what's up?
00:42:24 <vincenz> I did a make install of the unknown binary one
00:42:31 <vincenz> just to compile a new one
00:42:36 <vincenz> Could not find module `System.Directory':
00:42:51 <vincenz> the unknwon i386 one... I can invoke it, so it's in my path
00:42:53 <vincenz> I installed it
00:42:59 <vincenz> but now when recompiler ghc
00:43:00 <vincenz> I get that
00:43:43 <Cale> what are you doing?
00:43:47 <vincenz> compiling ghc
00:43:50 <Cale> why?
00:43:55 <vincenz> cause I don't have it installed?
00:44:06 <Cale> Compiling GHC is a bad idea if you just want to run it
00:44:13 <vincenz> I'm temporarily using the i386-unknown one
00:44:26 <vincenz> Cale: this shouldn't be
00:44:36 <vincenz> but "can not find System.Directory"
00:44:41 <vincenz> compiled or not, that's an issue
00:44:45 <Cale> well, it's easy to compile if you already have it installed :)
00:44:50 <vincenz> Cale: no I get that
00:44:51 <musasabi> dons: pong
00:44:57 <vincenz> `System.Directory'
00:45:02 <vincenz> could not find that module
00:45:05 <Cale> well, obviously the package is broken
00:45:12 * vincenz did a download of i386-unknonw one
00:45:19 * vincenz then did ./configure --prefix=/scratch
00:45:20 <vincenz> make 
00:45:21 <vincenz> make install
00:45:23 <Cale> from where?
00:45:24 <vincenz> then I wnet to the source
00:45:28 <vincenz> Cale: official site
00:45:31 <vincenz> then I went to the source dir
00:45:37 <vincenz> ./configure --prefix=/scratch
00:45:37 <vincenz> make
00:45:43 <vincenz> and that's what I get when it starts making
00:45:47 <Cale> http://haskell.org/ghc/dist/6.4.1/ghc-6.4.1-i386-unknown-linux.tar.bz2 -- this?
00:45:51 <vincenz> Cale: yes
00:46:07 <vincenz> I checked
00:46:16 <vincenz> System.Directory is in there
00:46:19 <Cale> do you even have to compile that?
00:46:30 <Cale> there should be a script to run it in-place
00:46:42 <Cale> at least, from what I remember
00:46:47 <vincenz> you don't have to compile
00:46:50 <vincenz> make does nothing
00:46:52 <vincenz> make install install
00:46:54 <vincenz> ..s
00:47:45 <vincenz> and I checked
00:47:55 <vincenz> /scratch/lib/ghc-6.4.1/imports/System/Directory.hi exists
00:48:08 <vincenz> (I did a local install into /scratch of the linuxn-unknown one
00:49:56 <vincenz> heh
00:50:00 <vincenz> it looks in local/lib
00:50:04 <vincenz> even though I isntalled in /scratch/lib
00:50:16 <vincenz> Could not find module `System.Directory':
00:50:16 <vincenz>   locations searched:
00:50:16 <vincenz>     System/Directory.hs
00:50:16 <vincenz>     System/Directory.lhs
00:50:16 <vincenz>     /usr/local/lib/ghc-6.4.1/imports/System/Directory.hi
00:50:18 <vincenz>     /usr/local/lib/ghc-6.4.1/imports/System/Directory.hs
00:50:21 <vincenz>     /usr/local/lib/ghc-6.4.1/imports/System/Directory.lhs
00:52:43 <vincenz> it keeps looking in usr/local
00:53:14 <ProfTeggy> bbl
00:55:07 * vincenz fixes package.conf
00:55:22 <vincenz> apparently it doesn't chagne this if you ./configure it to install elsewhere
00:55:31 <vincenz> it only tells it to look in the right place for pacakge.cong
00:55:36 <vincenz> but does not fix the innards of it
01:02:09 <dons> musasabi, I've got a regex-dna entry for you, using lazy regex combinators. damn fast: http://www.haskell.org/hawiki/RegexDna
01:02:53 <dons> (going from 1200s to 6s is a good speedup ;)
01:03:36 <dons> if you submit that, then we win :)
01:04:22 <dons> it even uses 'interact', my favourite
01:11:56 <musasabi> dons: committed, it looked quite pretty :-)
01:12:24 <dons> yeah, and _pure_. also, it's great to refer to the literature in a shootout entry :)
01:16:04 <mq_mattr> hi, anyone feel like helping me out with some hs-plugins issues?
01:16:21 <mq_mattr> I am trying it out and not getting all that far
01:17:28 <dons> ok, you're lucky. ask away :)
01:17:57 <mq_mattr> first thing - after I load up my code in ghci and run it
01:18:04 <mq_mattr> I get an error (it is busted)
01:18:15 <mq_mattr> then no it no longer seems to reload my code
01:18:33 <mq_mattr> even after I change it, it just keeps doing nothing and giving the same error.
01:18:44 <mq_mattr> The error I am currently up against is
01:18:55 <mq_mattr> nknown symbol `___stginit_TestHelper_'
01:18:55 <mq_mattr> *** Exception: user error (resolveObjs failed with <<False>>)
01:18:57 <dons> hmm. firstly, running in ghci is a bit tricky. can you compile the code and test it that way?
01:19:14 <mq_mattr> I am running makeAll "Defn.lhs" []
01:19:25 <mq_mattr> Defn.lhs imports TestHelper
01:19:32 <mq_mattr> Both are getting compiled
01:19:35 <mq_mattr> but then 
01:19:50 <mq_mattr> load "Defn.o" [] "pattID"
01:19:53 <mq_mattr> gives this error
01:20:00 <dons> hmm. I wonder if calling it a .lhs file would break things? I don't know. 
01:20:13 <mq_mattr> (pattID is a nullary function in Defn.lhs)
01:20:30 <mq_mattr> So you think it might be because I am using literate haskell files?
01:20:38 <mq_mattr> I will try it with .hs files
01:20:59 <dons> Anyway, a) compile it and try that. b) rewrite the .lhs as a .hs file and try that. c) if all that fails, send a reproducible test case to me at dons >at> cse.unsw.edu.au
01:21:16 <mq_mattr> can do
01:21:23 <dons> it's possible, i've never tested it on .lhs files so i'm suspicious that it might break something.
01:26:20 <mq_mattr> dons: It is definately me doing something wrong.
01:26:43 <mq_mattr> dons: I have broken it down to the simplest possible code and it is still not working
01:26:53 <mq_mattr> dons: here is my plugins code
01:27:07 <mq_mattr> module Misc where
01:27:07 <mq_mattr> import Plugins
01:27:07 <mq_mattr> main = do
01:27:07 <mq_mattr>   res <- makeAll "A.hs" []
01:27:07 <mq_mattr>   case res of
01:27:08 <mq_mattr>     MakeSuccess _ _ ->
01:27:10 <mq_mattr>       do 
01:27:12 <mq_mattr>         res2 <- load "A.o" [] [] "func"
01:27:14 <mq_mattr>         return ()
01:27:16 <mq_mattr>     _             -> putStrLn (show res)
01:27:18 <mq_mattr>   return ()
01:27:22 <mq_mattr> A is just func="huh?"
01:27:27 <mq_mattr> but it does import B
01:27:40 <mq_mattr> B is just funcy="hmm.."
01:27:48 <mq_mattr> and I get the following error
01:28:00 <mq_mattr> <interactive>: 
01:28:00 <mq_mattr> unknown symbol `___stginit_B_'
01:28:03 <mq_mattr> *** Exception: user error (resolveObjs failed with <<False>>)
01:28:09 <dons> ah, you're using an old version of hs-plugins?
01:28:27 <dons> update to the latest darcs versoin, and try again. also, what ghc version are you using?
01:28:39 <mq_mattr> I am on macosX and I am using whatever came from port
01:28:53 <mq_mattr> ghc v6.4.1
01:29:11 <dons> hmm, also, the mac is hard. they now do some magic symbols hacks on that os. I think it does still work though.
01:29:20 <mq_mattr> Actually the move to 6.4.1 took away a day as a whole bunch of stuff got deprecated :)
01:29:23 <dons> the darcs repo is at: http://www.cse.unsw.edu.au/~dons/code/hs-plugins/
01:29:43 <dons> (your version of hs-plugins is quite old, by the looks of it)
01:30:13 <mq_mattr> cheers, I will go and update and see what happens.  If it fixes things maybe I will pass on the details to the port maintaner
01:30:20 <dons> ok.
01:30:54 <gour> dons: is yi usable for normal work?
01:30:56 <vincenz> anyone ever use happy?
01:31:24 <gour> dons: and what about gtk interface?
01:31:25 <dons> gour, hmm, some people do use yi-ncurses for real work, yep.
01:31:34 <dons> but not many. the gtk version, not useable yet.
01:31:40 <dons> vincenz, yes.
01:31:54 <gour> any estimation?
01:32:03 <vincenz> dons: is it possible to use %prec clauses on grammar rules, and is there any possibility for backtracking?
01:32:04 <mq_mattr> I am a Parsec man myself
01:32:22 * vincenz is trying to port the yaccable c++ spec to alex and happy
01:32:50 <dons> vincenz, %prec, yep I think. check the manual. backtracking? won't that just work by default ?
01:33:02 <vincenz> dons: afaict I saw nothing about %prec on grammar rules
01:33:16 <vincenz> dons: the author of the yacc file for c++ uses some custom backtracking for templates
01:33:18 <dons> you can set precedence somehow, I know
01:33:26 <vincenz> dons: yes on tokens, not on grammar ruels
01:33:36 <dons> oh, custom backtraacking. hmm. you might have to plug in your own custom function, 
01:33:48 <vincenz> dons: but it's possible to resuem parsing then?
01:34:29 <dons> not sure. sounds like you're trying some hard things. better look at the low level operations (you can unget input and so on)
01:34:39 <dons> or try to come up with a more regular grammar?
01:34:40 <vincenz> dons: either way, my input will come from alex which is a list
01:34:51 <vincenz> (or possibly a monad)
01:35:03 <vincenz> dons: it's c++...you find a more regular grammar :P
01:35:17 <dons> someone might haave written a saner yacc version though
01:35:22 <vincenz> not afaik 
01:35:26 <vincenz> and I've checked quite a bit
01:35:33 <vincenz> the closest I can come to somethign else is the glr by elkhound/elsa
01:35:39 <dons> that sucks if they need underhand tricks to just parse their lang ;)
01:35:41 <vincenz> however tehre the parse actions are tightly coupled to the actual parsing
01:35:55 <vincenz> and it doesn't handle template template parameters
01:47:52 <olliej> dons: C++ is widely regarded as the most horrific (serious) language to parse ever made
01:49:03 <olliej> dons: i believe gcc has, or is planning to replace their incredibly hacked yacc parser with a hand written one
01:50:41 <psi> I was told in compiler class a few days ago that gcc had a handwritten one
01:53:20 <olliej> I have a friend doing a phd in software analysis, although it has turned almost entirely into a phd on parsing c++
01:55:40 <vincenz> olliej: they already have in 4.0
01:55:48 <vincenz> olliej: and who is this friend?
01:56:16 <pejo> psi, from 3.4, yeah. 4.1 has a hand written one for C/Objective-C.
01:56:29 <olliej> one of the lecturers/phd guys at my uni
01:56:37 <vincenz> olliej: got a link to his page?
01:56:43 <vincenz> or something
01:56:54 <olliej> a moment
01:56:55 <vincenz> thx
01:58:13 <olliej> not one that contains any information it seems
01:58:37 <olliej> i'll harass him tomorrow see if he can actually put up some of his papers
01:58:55 <vincenz> olliej: that would be great
01:58:56 <olliej> but he's working flat out on getting his thesis done atm, so no idea how long it'll take
01:59:07 <vincenz> olliej: maybe I could give you my email in private?
01:59:25 <olliej> vincenz: fire away
01:59:50 <olliej> effectively his generator produces a varying strength parser
01:59:59 <olliej> from LL -> GLR
02:00:15 <olliej> depending on the required strength in a given portion of the grammar
02:00:35 <vincenz> olliej: what uni is this?
02:02:15 <olliej> canterbury
02:02:31 <vincenz> olliej: and his name?
02:02:58 <vincenz> @help poll
02:02:58 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
02:02:58 <lambdabot> poll-close poll-remove
02:03:02 <vincenz> @poll-list
02:03:02 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
02:03:14 <vincenz> @help @poll-list
02:03:15 <lambdabot>  @help <command> - ask for help for <command>
02:03:17 <vincenz> @help poll-list
02:03:18 <lambdabot>  @poll-list                 shows all current polls
02:03:32 <vincenz> @poll-add
02:03:32 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
02:03:39 <vincenz> @poll-add New nickname for vincenz
02:03:39 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
02:04:17 <vincenz> @help poll-add
02:04:17 <lambdabot>  @poll-add <name>             adds a new poll, with no candidates
02:04:27 <vincenz> @poll-add "New nickname for vincenz"
02:04:28 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
02:04:30 <vincenz> o.O
02:04:41 <vincenz> @poll-add NewNickNameForVincenz
02:04:42 <lambdabot> Added new poll: "NewNickNameForVincenz"
02:04:51 <vincenz> @help choice-add
02:04:51 <lambdabot>  @choice-add <poll> <choice>  adds a new choice to the given poll
02:05:04 <vincenz> @choice-add NewNickNameForVincenz cpoucet
02:05:05 <lambdabot> New candidate "cpoucet", added to poll "NewNickNameForVincenz".
02:05:07 <vincenz> @choice-add NewNickNameForVincenz chrisp
02:05:08 <lambdabot> New candidate "chrisp", added to poll "NewNickNameForVincenz".
02:05:10 <vincenz> @choice-add NewNickNameForVincenz poucetc
02:05:11 <lambdabot> New candidate "poucetc", added to poll "NewNickNameForVincenz".
02:05:52 <vincenz> @poll-list
02:05:52 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
02:06:01 <vincenz> @poll-show
02:06:02 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
02:06:20 <vincenz> @poll-remove NewNickNameForVincenz
02:06:20 <lambdabot> Poll should be closed before you can remove it.
02:06:26 <vincenz> @poll-close NewNickNameForVincenz
02:06:27 <lambdabot> Poll "NewNickNameForVincenz" closed.
02:06:27 <vincenz> @poll-remove NewNickNameForVincenz
02:06:28 <lambdabot> poll "NewNickNameForVincenz" removed.
02:06:29 <vincenz> l
02:08:26 <vincenz> It's time I got a new nickname, any suggestions?
02:09:00 <Saulzar> Fred
02:09:08 <vincenz> hehe
02:09:10 <vincenz> right
02:09:33 <vincenz> no problem is that vincenz is a) not uniquely googleable b) is not related to my real name
02:10:03 <gour> @where missingpy
02:10:04 <lambdabot> I know nothing about missingpy.
02:10:10 <gour> @where Missingpy
02:10:11 <lambdabot> I know nothing about missingpy.
02:11:37 <olliej> wow olliej is surprisingly unique
02:11:38 <gour> @where lambdabot
02:11:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:11:45 <olliej> i'm most of the first page
02:12:01 <olliej> @where am i?
02:12:02 <lambdabot> I know nothing about am.
02:12:05 <olliej> :(
02:13:22 * pierre- loves haskell
02:13:32 <ProfTeggy> :-)
02:14:37 * vincenz wonders if anyone ever expresses pure unadultrated affection towards c++ 
02:14:51 <gour> lol
02:14:56 <olliej> muwhahaha -- according to at least one person on the haskell wiki i'm black belt 5th dan
02:15:19 <JKnecht> in haskell?
02:15:20 <olliej> vincenz: i will if someone pays me enough
02:15:29 <vincenz> olliej: that's not unadultraetd
02:15:41 <olliej> :(
02:16:08 <JKnecht> adulterate, I'm pretty sure.
02:16:09 <olliej> how about if I were acting like i believed C++ were great
02:16:15 <olliej> is that adulterated?
02:16:31 <olliej> JKnecht: yeah, it's funny given i can't use Monads... i barely know haskell
02:16:44 <olliej> but am writing a haskell compiler
02:16:45 <vincenz> olliej: where is this page with the 5dan stuf?F
02:16:52 <vincenz> olliej: in what lang?
02:16:57 <olliej> http://haskell.org/hawiki/HaskellIrcChannel
02:17:02 <olliej> vincenz: C# :)
02:17:05 <vincenz> oy
02:17:09 <vincenz> C#?
02:17:18 <vincenz> they even have such thing as lexing and parsing tools?
02:17:20 <olliej> well, i'm targetting .NET :)
02:17:27 <olliej> vincenz: yup -- antlr
02:17:33 <olliej> eg. tools stolen from java
02:17:33 <vincenz> for c#?
02:17:37 <olliej> yup
02:17:38 <vincenz> ah
02:18:39 <vincenz> woah
02:18:53 <olliej> hehe
02:18:59 <olliej> today has been great
02:19:12 <olliej> i can now compile ghc.base and ghc.show completely
02:19:15 * vincenz is having haskell nistall issue
02:19:18 <vincenz> olliej: nice :)
02:19:29 <vincenz> olliej: compile it to what?
02:19:31 <olliej> vincenz: what platform?
02:19:38 <olliej> vincenz: .NEt, via C# :)
02:19:44 <vincenz> olliej: nonroot fedora
02:19:49 <olliej> eek
02:19:54 <vincenz> work
02:20:00 <olliej> Saulzar might be able to help
02:20:03 * vincenz has ubuntu on his lappy
02:20:22 <olliej> i'm not sure whether our department has ghc installed by default, but he certainly has it
02:20:34 <olliej> (we're at same uni)
02:20:37 <vincenz> :)
02:20:52 <JKnecht> ghc is in FC xtras
02:21:08 <olliej> i think Saulzar got a tarball
02:21:15 <Saulzar> Hmm, yeah. I just installed the binaries to a directory (/local - but I guess any will do) and set the paths.
02:21:36 <Saulzar> It just went
02:23:13 <vincenz> anyone know some software to easily visualize/edit decision trees
02:23:21 <vincenz> such that I can collapse nodes I dno't have an answer for yet?
02:23:32 <vincenz> mindmapping software sadly doesn't put stuff on edges, only on nodes
02:25:32 <gour> hi, i'm preaching about haskell in some #channel. anyone can give a short & powerful example for real-use of lazy programming (not fibonacci func)
02:26:10 <olliej> gour: raytracing + CSG?
02:26:34 <gour> olliej: some example, url
02:26:46 <olliej> as an url? nope
02:26:48 <tromp_> how about pascal's triangle?
02:26:56 <tromp_> pascal :: [[Integer]]
02:26:56 <tromp_> pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
02:27:09 <aleator> gour: I used it for genetic programming. Just map eval over everything, but it still only calculates those indeviduals that actually are compared.
02:27:21 <gour> well, those are python folks, wants some practicall thing used in daily programming
02:27:31 <olliej> gour: i only know those cases where i haven't had lazy evaluation and would have liked it
02:27:44 <olliej> gour: proxy design pattern
02:28:17 <gour> i showed them fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)], but the guy replied he does not need such things
02:28:17 <tromp_> pascal's triangle is practical whenever you need binomial coeficients
02:28:42 <olliej> gour: anything where you want to transparently delay loading info
02:28:52 <olliej> gour: so images in a webpage
02:29:04 <olliej> gour: information in a symbol table
02:29:36 <gour> olliej: hmmm..loading imge is a good one
02:31:18 <shapr> gour: pi-spigott
02:31:19 <Saulzar> Heuristic search... make a list of everything examine them one by one
02:31:43 <tromp_> whatever you show him, he will turn out not to need:(
02:31:43 <shapr> also the string search that looks at all tails (heads?)
02:32:06 <gour> well, one will take it (dev of Scribes editor :-)
02:32:29 <Saulzar> Ask Cale about that one, with his pipeline scheduler - he's the Lazy evaluation advocate :)
02:32:44 <gour> where is boegel's raytracer?
02:33:05 <gour> scribes dev found http://wiki.python.org/moin/PythonVsHaskell
02:33:11 <gour> to get a taste
02:34:10 <shapr> boegel's raytracer is on tmrwiki
02:34:32 <jethr0> hey shapr
02:34:36 <shapr> http://www.haskell.org/tmrwiki/HRay
02:34:38 <shapr> hiya jethr0 
02:35:01 <gour> shapr: thanks
02:35:20 <vincenz> anyone know some software to show trees with the ability to easily collapse nodes or subtrees
02:35:23 <vincenz> show/edit
02:35:31 <vincenz> jethr0: hiya
02:35:35 <jethr0> hey vincenz
02:35:37 <vincenz> jethr0: still have a screenshot of our gui lying around?
02:35:46 * vincenz has his lappy in windows atm
02:35:57 <jethr0> just a sec
02:36:27 <vincenz> thx
02:42:49 <boegel> gour: wow, interested in my work ? :)
02:43:22 <jethr0> boegel: _everyone_ liked your raytracer :)
02:43:26 <gour> boegel: well, i'm using it as a preaching tool for glorifying haskell. comment was 'nice'
02:43:42 <vincenz> Both Haskell and Python have strong (not weak) typing
02:43:45 <vincenz> LOLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
02:43:56 <vincenz> in my eyes : dynamic typing = no typing
02:44:01 <boegel> gour: just 'nice' ? :)
02:44:14 <boegel> jethr0: thanks man ! ;)
02:45:05 <gour> boegel: well, python folks. take in small bites :-)
02:45:51 <olliej> vincenz: i was wondering about that -- i would have said dynamic typing != strong typing
02:46:07 <olliej> i would have said they're complete opposites
02:46:33 <olliej> of course what do i know? :)
02:46:44 <olliej> woot compiled ghc.enum
02:47:03 <vincenz> olliej: well it's stronger than c
02:47:17 <vincenz> olliej: c allows you to do type-illegal stuff (or c++)
02:47:39 <vincenz> even java :P
02:48:12 <olliej> how does java let you do type illegal stuff?
02:48:24 <vincenz> (MyObject[]) SomeObject_array
02:48:30 <olliej> oh yes
02:48:34 <olliej> those damn arrays
02:48:43 <olliej> i keep forgetting about that piece of idiocy
02:48:52 <vincenz> hehe
02:49:08 <olliej> or maybe it's a repressed memory
02:49:15 <vincenz> even if c++ and java were typesafe, I'd still not call them strongly typed
02:49:23 <olliej> why not?
02:49:36 <vincenz> well maybe templates
02:49:56 <vincenz> but having to go through object is just ridiculous for generic methods
02:50:07 <olliej> ?
02:50:15 <olliej> what do you mean go through object?
02:50:27 <vincenz> maybe I'm babbling
02:50:51 <olliej> are you referring to javas pseudo generics?
02:50:57 <vincenz> olliej: until templates, type-parametric methods weren't possible
02:51:13 <olliej> oh your talkijng about that
02:51:17 <olliej> :)
02:51:19 <vincenz> and templates themselves are not based on typing but ducktyping
02:51:29 <vincenz> at compiletime that is
02:51:43 <olliej> vincenz: in c++ yes
02:51:49 <vincenz> not in java?
02:51:54 <olliej> but not java/.net
02:51:59 <vincenz> interface based/
02:52:04 <vincenz> s/\//?
02:52:16 <binary42> strong typing is a guarantee about operations IMO, not about type. It operates on the level of kind. If I try to cast something illegally or use something illegally this rule is kept in most languages that are strong typed will either fail to compile (static) or execute some sort of exceptional behavior (most dynamic languages).
02:52:51 <vincenz> binary42: I know, but once you have the platform of typesafeness, I think strong typing should imply more
02:52:53 <olliej> java generics allow contraints -- basically turning object to a specific interface
02:52:53 <binary42> The difference of being at compile or runtime is an orthogonal argument. 
02:53:08 <vincenz> binary42: not really, dynamic languages are by definition nutyped
02:53:16 <vincenz> expressiosn don't have types, objects do
02:53:27 <essiene> moin *
02:53:37 <olliej> .NET generics are as powerful as haskell generics with two exceptions -- higher ranked, and higher kinded types
02:53:40 <binary42> vincenz: I know what you mean. Io is a mind boggling example of a strong typed language.
02:53:50 <vincenz> binary42: I've looked at io
02:53:55 <essiene> i have a quick question ;)
02:54:12 <vincenz> binary42: I fail to see how it's typed
02:54:32 <vincenz> it's untyped, dynamic dispatch prototype-oo, where is the typing in that
02:54:38 <essiene> can i use the Either type to create a function that returns more than two optional result?
02:55:02 <binary42> vincenz: there is only one type (disregarding internal use of tags). Behavior of a message send is a guarantee. 
02:55:08 <vincenz> oh
02:55:14 <vincenz> well in that case, ruby is too
02:55:14 <essiene> for instance. data Tuple a b c d = Tuple1 a | Tuple2 a b | Tuple3 a b c | Tuple4 a b c d
02:55:20 <vincenz> all things are objects
02:55:25 <Saulzar> essiene, Well you could use Either a (Either b c), but that's not much fun - maybe you'd make your own type instead
02:55:27 <vincenz> but I think that's a rather low platform
02:55:45 <essiene> funcTupleConv :: Tuple a b c d -> Either a, (a,b)
02:55:57 <essiene> funcTupleConv (Tuple1 a) = Left a
02:56:08 <essiene> funcTupleConv (Tuple2 a b) = Right (a,b)
02:56:19 <vincenz> essiene: of course :)
02:56:42 <essiene> vincenz, the crux now is...
02:57:14 <essiene> can i extend funcTupleConv to also match against (Tuple3 a b c) to give a (a,b,c) and (Tuple4 a b c d) to give (a,b,c,d)
02:57:17 <vincenz> binary42: it's amazing tho that a lot of stuff that io tries to achieve, haskell does type-strongerly... I can't remember right now the example that popped to mind a while ago, but if I can remember it during lunch, I'll tell you after
02:57:20 <essiene> is that possible?
02:57:34 <vincenz> essiene: why not have it return a list?
02:57:39 <binary42> vincenz: right (well, mostly right -- ruby is has a slightly richer type with the addition of class). The thing is that that is mostly a dimension of being static or dynamic not string or weak. I think being strongly typed has been so common that it is taken for granted in most cases.
02:57:40 <vincenz> oh nm...
02:57:59 <binary42> vincenz: I am working on a Io interpreter in Haskell. Quite fun to try.
02:58:03 <essiene> i'm tackling an excercise that asked me to implement it as _one_ function... tho i currently do it as two functions... and i'm wondering if there's still something i don't get about them pesky Either types
02:58:39 <jethr0> binary42: huh?
02:58:40 <binary42> I think Haskell's type system could be applied to running systems. It only is a question of how lazy we make certain assertions. 
02:58:43 <vincenz> binary42: I can see where you're coming from, but within the searchspace of langauges, one should have miniimal platforms, aka firstclass behaviour and typesafefulness. and only by then raising the bar can we achieve meaningfull definitiosn for such terms as typestrong
02:58:52 <Saulzar> essiene, What is your goal?
02:58:52 * vincenz hates his keyboard
02:59:09 <jethr0> vincenz: but still, you're quite the fast typist.
02:59:17 <vincenz> jethr0: yeah and making more typos than usual
02:59:20 <jethr0> binary42: what do you mean by io interpreter?
02:59:21 <vincenz> pisses me off
02:59:23 <vincenz> but...lunch time
02:59:26 <vincenz> jethr0: it's a language
02:59:28 <vincenz> jethr0: check out #io
02:59:38 <jethr0> ah, i thought Input/Output...
02:59:39 <vincenz> or was it #iolanguage... can't remember, I know I idled there a while in the past
02:59:41 <binary42> vincenz: probably true.
02:59:45 <jethr0> wouldn't have made much sense :)
02:59:57 <binary42> note that I capitalize the I in Io when I talk about the language :-)
03:00:02 <jethr0> k, gotta go
03:00:03 <vincenz> binary42: sadly, many languages fail even at that
03:00:10 <jethr0> vincenz: i won't be around for the next 3 days..
03:00:13 <binary42> it is #io
03:00:16 <vincenz> jethr0: take care
03:00:25 <jethr0> vincenz: but afterwards maybe we can work on that graph editor together!
03:00:28 <essiene> Saulzar, to be able to write one function funcTupleConv that matches against all the constructors of type Tuple a b c d, and returns either a single value (if its Tuple1), a haskell pair if its Tuple2, a triple, if its Tuple3 and a quad if its Tuple4
03:00:29 <binary42> the website is iolanguange.com 
03:00:33 <vincenz> I remember evaluating io when I wanted to make a runtime system where I could change code online
03:00:45 <vincenz> sadly at that point it was not 1.0 yet and the oodb wasn't there yet
03:00:54 <vincenz> anyways, lunch bbin30
03:01:29 <essiene> Saulzar, currently, i've implemented it as funtTupleConv :: Tuple a b c d -> Either a, (a,b) and funcTupleConv1 :: Tuple a b c d -> Either (a,b,c), (a,b,c,d)
03:01:33 <jethr0> essiene: Either builds a union of two other types
03:01:44 <Saulzar> essiene, I'm not sure they're wanting you to use "either", but that was just part of the sentence :)
03:01:49 <jethr0> essiene: apart from that you can't return values of different types in haskell.
03:02:02 <essiene> hmmm...
03:02:35 <essiene> Saulzar, they actually specified "you'll use an Either to acheive this" ;)
03:02:36 <jethr0> you could build a type "data T a b c = X a | Y b | Z c"
03:02:41 <essiene> jethr0, hmmm...
03:03:00 <jethr0> or maybe an "Either (Either a b) c" :)
03:03:32 <essiene> wow... recursive Either?
03:03:42 <olliej> Saulzar: i wonder how nigel will respond.. i just asked him if python was strongly typed... am hoping we won't elect to stop being my supervisor :)
03:03:45 <jethr0> why not :). but it's not nice
03:03:52 <Saulzar> This is YAHT right? I seem to remember this exersize...
03:03:55 <jethr0> @type (1,2)
03:03:56 <lambdabot> forall a b. (Num a, Num b) => (a, b)
03:04:00 <Saulzar> olliej, Haha. 
03:04:04 * essiene has a faint deja vu... burnt brain cell... fried grey matter
03:04:10 <essiene> Saulzar, yup... YAHT!!! ;)
03:05:28 <Saulzar> If that's what strongly typed means then it doesn't mean much. Almost in the same way that C is safe with memory operations because it gives a segmentation fault when you write out of allocation :)
03:05:28 <essiene> jethr0, hmmm... lemme see if i can solve it in terms of recursive eithers... but if no one hear from me after two days... please contact Google Earth... try to see if i survived ;)
03:05:29 <essiene> @location
03:05:29 <essiene> :D
03:05:29 <lambdabot> Unknown command, try @listcommands.
03:05:49 <olliej> Saulzar: that was my opinion
03:05:57 <olliej> but i'll wait for his response
03:05:58 <jethr0> essiene: don't make it sound so dramatic. recursive either is ugly, but nothing mind-boggling, really :)
03:05:59 <dcoutts_> gour, pong
03:06:03 <jethr0> k, gotta go, cu
03:06:08 <olliej> and then use it as though it was from the mouth of god
03:06:19 <essiene> jethr0, ok then
03:06:22 <essiene> ;)
03:06:41 <olliej> which ir more or less is
03:06:59 <Saulzar> Heh, especially if you write it in your thesis.
03:07:06 <olliej> hehe
03:07:48 <olliej> wow... GHC.Err appears to be failing in a myriad of ways
03:09:42 <mq_mattr> dons: you still around
03:09:44 <mq_mattr> ?
03:11:53 <kzm> Anybody familiar with the (any) DB/SQL libraries?  Is there a good summary of their differences and relative advantages?
03:14:55 <mq_mattr> anyone feel like helping me with a plugins problem?
03:15:56 <gour> dcoutts_: hi, i'm preaching on #sandbox about haskell, hIDE...to python folks
03:16:24 <mq_mattr> they are probably the best targets
03:16:38 <gour> dcoutts_: after showing them autrijus' slides 'learning haskell' they were impressed (both with the content & slides :-)
03:17:25 <gour> dcoutts_: Scribes' editor dev likes hIDE and remarked: "Man they should have released it."
03:18:01 <gour> dcoutts_: so the  question on the table is if you have some guess when hIDE will have basic functionality ready 8at least saving files)
03:18:55 <dcoutts_> gour, sorry, don't know yet.
03:19:18 <dcoutts_> I have some basic improvements to the UI infrastructure that need doing
03:19:38 <dcoutts_> like making the file browser robust and react to changes in the file system
03:19:39 <kzm> URL for the slides?  (Or must I resort to google? :-)
03:20:23 <dcoutts_> and this is help up by the work on the major tree/view changes that are going on in gtk2hs
03:20:38 <dcoutts_> which btw, look really good.
03:21:06 <gour> kzm: http://pugscode.org/talks/euroscon05/haskell.xul
03:22:25 <dcoutts_> actually I had a question about that for people in general:
03:22:26 <dcoutts_> would it be confusing or intuitative for widgets which are for viewing list/tree models to be parameterised by the type of the model rows?
03:22:26 <dcoutts_> eg if you've got a list of strings for a model
03:22:26 <dcoutts_> you'd have ListStore String and TreeView String
03:22:28 <gour> dcoutts_: have you tried Scribes (http://scribes.sf.net) dev also likes non-bloated editors and plan to refactor to code to have hs-plugins--like functionality.
03:22:55 <gour> dcoutts_: and he wrote that haskell is worth of learning 
03:23:10 <dcoutts_> gour, I've seen Scribes demos, they were showing off this templating thing. I didn't really get it.
03:23:12 <gour> but is aware it won't be as easy as python
03:23:26 <gour> dcoutts_: yes, snippets
03:23:47 <dcoutts_> yeah, I wasn't convinced that it would just be annoying :-)
03:23:59 <gour> dcoutts_: i also didn't get it. will try to take a look again, but he says he cannot live without them (ex-vim zealot)
03:38:59 <tromp_> haskell has no here-documents, right?
03:40:14 <dcoutts_> tromp_, yeah.
03:40:33 <dcoutts_> hugs implemented it as an extension but it didn't catch on
03:42:53 <MarcWeber> Which functions are used to get a list of files (e.g. to find some file)?
03:45:50 <dcoutts_> @docs System.Directory
03:45:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.
03:45:51 <lambdabot> html
03:45:57 <dcoutts_> MarcWeber, try that
03:49:37 <MarcWeber> I only have the base/System directory. Did you mean that?
03:52:24 <dcoutts_> MarcWeber, I mean the System.Directory module which is indeed in the base package
03:56:52 <essiene> Saulzar, i have returned...  a happy man (albeit twisted in the head :D),
03:59:04 <essiene> Saulzar, i solved that problem... function declaration looks like:  Tuple a b c d -> Either a (Either (a,b) (Either (a,b,c) (a,b,c,d)))
03:59:13 <essiene> ;)
03:59:31 <Saulzar> Great.
03:59:37 * essiene goes back to YAHT'ing after a shameless fit of self promotion
03:59:38 <essiene> :D
03:59:52 <Saulzar> Yeah, it's probably not something you'd find any real purpose for
04:00:16 <essiene> phew... i hope so ;)
04:00:46 <essiene> but i've cleared that hurdle now... i can move forward with a clear concience... and more understanding too :)
04:01:08 <Saulzar> I don't think I understood what that was all about at the time
04:10:40 <vincenz> re
04:15:46 <pierre-> i wrote some silly app in WinApi... While running, it wastes memory every second. How can i stop it?
04:16:08 <ProfTeggy> Alt-F4
04:17:01 <Philippa> or use the task manager (called up by ctrl-alt-del)
04:17:02 <pierre-> :-) hmm and how can i make it not memory-eating?
04:17:12 <Philippa> stop allocating memory
04:17:22 <ProfTeggy> garbage collect every now and then
04:17:35 <pierre-> bFl <- allocaMessage (\msg -> do 
04:17:36 <pierre->     peekMessage msg (Just hwnd) 0 0 0
04:17:48 <pierre-> -- here it the problem i think...
04:18:11 <essiene> :)
04:18:14 <pierre-> but i can't figure out how to rewrite it
04:24:13 <gour> @where yaht
04:24:13 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
04:30:33 <vincenz> is it my impression or is darcs bandwidth hungry?
04:36:29 <binary42> I've not had too much problem with bandwidth. use --partial if you can.
04:38:32 <pierre-> strange... In general, where can be reasons of memory leaks in simple WinApi app? Is there any good example on WinApi in haskell?
04:45:21 <dcoutts_> pierre-, I don't think people use it much. You could look at the windows version of the HGL though. It uses the System.Win32.* modules I think.
04:52:01 <gour> @where hIDE
04:52:02 <lambdabot> http://haskell.org/haskellwiki/HIDE
04:52:46 <shapr> @where am I
04:52:46 <lambdabot> I know nothing about am.
04:52:57 <pierre-> @where glut
04:52:58 <lambdabot> I know nothing about glut.
04:53:04 <shapr> @where hopengl
04:53:05 <lambdabot> http://haskell.org/HOpenGL/
04:53:08 <pierre-> @where GLUT
04:53:09 <lambdabot> I know nothing about glut.
04:53:13 <dcoutts_> poor shapr :-)
04:53:14 <gour> shapr: i know where are you - cold sweden :-)
04:53:18 <shapr> gour: yes!
04:53:27 <gour> lol
04:53:36 <dcoutts_> shapr, where in sweden btw?
04:53:38 <shapr> I would email snow to you... if only I knew the correct MIME type...
04:53:53 <pierre-> @where HGlut
04:53:53 <lambdabot> I know nothing about hglut.
04:53:55 <dcoutts_> I might be visiting Sweden later this year
04:54:25 <dcoutts_> pierre-, the glut is documented with HOpenGL
04:54:38 <binary42> Is there a way to force runhaskell/runghc to use stdin for source?
04:54:45 <shapr> dcoutts_: http://maps.google.com/maps?f=q&hl=en&q=boden,+sweden&ll=65.830001,21.7&spn=7.187597,27.685547
04:55:03 <pierre-> dcoutts_: and where can i get glut package for windows?
04:55:11 <shapr> hm, looks better with hybrid graphics
04:55:33 <dcoutts_> pierre-, it comes with ghc I think
04:56:16 <gour> @where jhc
04:56:17 <lambdabot> http://repetae.net/john/computer/jhc/
04:58:12 <pierre-> dcoutts_: i has ghc-6.4.1 -- and no glut included
05:01:19 <dcoutts_> pierre-, are you sure? I used the standard ghc-6.4.1 installer and when I run ghc-pkg.exe list GLUT, it says I've got GLUT-2.0
05:03:29 <dcoutts_> shapr, that looks a long way from anywhere :-) I'll probably be in Stockholm or Goteburg
05:03:42 <dcoutts_> Goteburg/Goteborg
05:04:16 <boegel> dcoutts: it isn't supoosed to speak, it's haunted !
05:04:23 <boegel> throw it out ! NOW ! 
05:05:30 <dcoutts_> boegel, mmm, good idea
05:06:00 * dcoutts_ logs off the win32 server
05:08:10 <pierre-> dcoutts_: sorry, i was using ghc6.5, which came with Visual Haskell. In my ghc-6.4 glut is working
05:08:32 <pierre-> Is there any way to import it in 6.5?
05:09:25 <moonlite_> i'm trying to compile trhsx. it won't build, complaining that base-1.0 is hidden. running Setup.hs build -v reveals that the flag "-hide-all-packages" is added to ghc. why is that?
05:10:24 <moonlite_> and how do i remove it ? :)
05:10:49 <dcoutts_> pierre-, no, you can't mix packages compiled for different versions of ghc
05:13:19 <vincenz> anyone have any suggestions as alternatives to tgif
05:15:59 <shapr> dcoutts_: I'm moving to Stockholm in the summer.
06:04:36 <gour> dcoutts_: is there somee feedback on your module-extension proposal?
06:12:04 <gour>  http://quux.org/devel/missingpy url for missingpy does not work. anything up to date?
06:57:47 * shapr chortles merrily
06:59:24 <shapr> gour:  darcs get http://darcs.complete.org/missingpy/
07:00:34 <gour> shapr: thanks. i've found it, but thought there is some 'homepage' 
07:04:53 <vincenz> > reverse "):"
07:04:55 <lambdabot> ":)"
07:05:32 <vincenz> yep, haskell can even do emotional analysis like this, pl
07:05:39 <vincenz> s/pl/ppl
07:05:44 * shapr grins
07:10:01 <ProfTeggy> vincenz, this should be featured in any Haskell tutorial
07:10:38 <vincenz> I fully agree :)
07:27:33 <araujo> @index evaluate
07:27:34 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
07:34:43 <goron> Is there an efficient balanced binary tree in GHC(like an AVL tree)? 
07:42:42 <ProfTeggy> http://homepages.nildram.co.uk/~ahey/HLibs/Data.Tree.AVL/
07:43:53 <shapr> Has anyone here tried the Finger Trees?
07:44:13 <ProfTeggy> Another Hinze'ism? :-)
07:44:16 <goron> ProfTeggy: I found that one already, but it seems amateur work.
07:44:31 <shapr> ProfTeggy: How'd you guess?
07:44:34 <ProfTeggy> goron, that's the only pointer I can give, sorry
07:44:39 <Mitar>   test <- getContents
07:44:39 <Mitar>   putStrLn "test"
07:44:39 <Mitar>   putStr test
07:44:55 <Mitar> will test be printed out before all stdin is send to the program?
07:44:58 <ProfTeggy> shapr, I came across them (recalling vaguely only)
07:46:36 <shapr> I read the paper yesterday on the bus to shopping, it's a neat datastructure.
07:47:26 <essiene> sample error message: "This will never work out... I'm a computer... you're an Idiot!"
07:47:27 <essiene> ;)
07:48:24 <vincenz> Mitar: no... getContents gives you one big string
07:48:33 <goron> What is .lgs? Literate Generic Haskell?
07:48:39 <vincenz> oh...sorry, misread, yes
07:48:42 <vincenz> Mitar: don't forget do
07:48:45 <Mitar> then why it is printed?
07:48:46 <vincenz> shapr: what's nice about em?
07:48:49 <Mitar> i have do ..
07:49:02 <vincenz> Mitar: I misread your statement as "before each line"
07:49:04 <Mitar> and immediately when i run a program i get test
07:49:14 <Mitar> ok
07:49:16 <Mitar> then why
07:49:16 <Mitar> ?
07:49:24 <vincenz> why why?
07:49:27 <vincenz> you print test
07:49:38 <Mitar> why it would be printed out before i send all input in
07:49:44 <vincenz> Mitar: haskell is laz
07:49:49 <vincenz> it only actually reads when you use input
07:49:59 <vincenz> whiich is at putStr test
07:50:18 <Mitar> hmm, interesting 
07:50:25 <vincenz> indeed :)
07:50:31 <vincenz> you can do a lot of cool stuff with that
07:50:37 <vincenz> like input-backtracking
07:50:45 <Mitar> i was not aware of this consequences
07:50:46 <vincenz> it will only read when you require new input
07:51:37 <vincenz> I used this in conjunction with a statemonad represining the remaining input to do a state machien
07:52:27 <shapr> > ones = 1 : ones in take 5 ones
07:52:28 <lambdabot>  parse error on input `='
07:52:36 <shapr> > let ones = 1 : ones in take 5 ones
07:52:37 <lambdabot> [1,1,1,1,1]
07:53:00 <shapr> Mitar: It's difficult to handle structures like [1..] in C, for example.
07:53:08 <shapr> or [1,1..]
07:53:35 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens in take 10 $ transpose [odds,evens]
07:53:36 <lambdabot> [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]
07:53:44 <goron> shapr: do you have any idea of where I can get an efficient balanced binary tree?
07:53:58 <shapr> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 5 primes
07:53:59 <lambdabot> [2,3,5,7,11]
07:54:20 <shapr> Mitar: is that cool or what?
07:55:09 <tromp_> > map (g 2) [0..3] where g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
07:55:11 <lambdabot> [2,3,5,7]
07:55:19 <Mitar> it is it is
07:55:45 <xerox> tromp_: ?!
07:55:46 <neologism> tromp_: thats evil :)
07:55:59 <shapr> gour: I think Adrian Hey's trees will work. I think Poetix has some code for randomly balanced binary trees.
07:56:03 <tromp_> very evil:(
07:56:14 <shapr> @google balanced binary tree filetype:lhs
07:56:16 <lambdabot> http://okmij.org/ftp/Haskell/stanamically-balanced-trees.lhs
07:56:31 <shapr> Or you could try Oleg's stanamically balanced trees :-)
07:56:35 <goron> shapr: I tried Adrian Hey's stuff, but it doesn't compile.
07:56:37 <Mitar> tomp, what is this?
07:56:47 <goron>   Couldn't match kind `(#)' against `*'
07:56:48 <goron>     When matching the kinds of `(# AVL e, Int# #) :: (#)' and `a :: *'
07:56:48 <goron>       Expected type: (# AVL e, Int# #)
07:56:48 <goron>       Inferred type: a
07:56:48 <goron>     In the application `error "pushHR_: Bug0"'
07:56:49 <tromp_> a very fast growing sequence
07:57:12 <tromp_> don't try to compute g 2 4
07:57:17 <tromp_> it's big....
07:57:38 <Mitar> do .. not .. try ... i ... cannot ... resist
07:58:31 <shapr> goron: hm, are you using -fglasgow-exts ?
07:58:44 <goron> shapr: I am just doing make install
07:59:26 <goron> shapr: I expect that when someone distributes something, that it compiles, but maybe I shouldn't. Should I?
07:59:58 * goron doesn't have time to test all broken libs in the world.
08:01:46 <shapr> Well, one benefite of open source is transparency. You get the ability to hack around on it until it does exactly what you need.
08:02:09 <shapr> I'm usually willing to hack on something for half an hour to an hour and then drop it if it's more trouble than that.
08:02:41 <shapr> I know Rabhi & Lapalme's FP Algorithms book includes binary trees, not sure if it has balanced binary trees.
08:02:50 <shapr> In any case, their code is online at the book's website.
08:03:01 * SamB wonders how to decompile Inform's switch statements
08:04:07 <shapr> InForM ?
08:04:17 <goron> shapr: I can implement AVL trees, or whatever else, but well implementing these basic things is...not focusing on the real problem, which is vastly more interesting.
08:04:18 <gour> shapr: how do you like FPA book?
08:04:59 <SamB> shapr: Inform
08:05:06 <shapr> gour: I like it lots. It was my first exposure to systematic optimization of algorithms via Burstall & Darlington as used in the book.
08:05:28 <shapr> SamB: oh, not the big equational workbench written in Haskell then?
08:05:43 <Mitar> how can i this type: Eq a => (a -> a) -> a -> a
08:05:51 <Mitar> convert so it will incldue a Show class
08:05:51 <Mitar> ?
08:05:53 <goron> shapr: I don't have that book. I have Introduction to Algorithms next to me. 
08:05:53 <gour> shapr: good to know. i'm thinking to get it (after i finish craft of fp)
08:06:17 <goron> shapr: oh, gour was there ;)
08:06:24 <shapr> goron: Not sure I know that book, what authors?
08:06:52 <goron> shapr: Cormen, Leiserson, Rivest, Stein
08:07:39 * Igloo looks confused
08:08:12 <Mitar> anybody?
08:08:16 <Mitar> it is just a syntax
08:08:17 <Igloo> Ah, they gained Stein in the second edition
08:08:36 <Igloo> Mitar: DYM (Show a, Eq a) => (a -> a) -> a -> a?
08:08:54 <Mitar> thanks
08:10:06 <goron> Igloo: I have the 2nd edition indeed
08:13:23 <goron> I think I will just use a FiniteMap with the keys being the same as the values
08:15:15 <SamB> shapr: nope
08:16:15 <shapr> goron: Oh, I think I have the 1st edition of that somewhere around here. I like FP Algorithms because it takes a purely functional approach and uses Haskell - http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
08:17:04 <shapr> I reported the errata on page 176 of that book.
08:17:15 <gour> shapr: how does it compare with e.g. okasaki's book?
08:17:31 <shapr> I haven't read Okasaki's book yet. It's on my list of things to buy when I have more money :-)
08:18:11 <shapr> I am definitely looking forward to studying amortized algorithms in some detail.
08:18:37 <shapr> I still don't know what properties mean an algorithm cannot be amortized, and I wish I did.
08:21:36 <goron> Introduction to algorithms discusses those concepts very well.
08:22:32 <shapr> It discusses amortization?
08:22:33 <vincenz> shapr: great book :)
08:22:39 <goron> shapr: yes
08:23:01 <shapr> wow cool
08:23:05 <goron> amortization is not that hard
08:23:58 <gour> shapr: so, if you are living without okasaki's book, then FPA is definitely the right one for myself :-)
08:24:26 <shapr> Probably not, but I still haven't gotten around to learning amortization well enough to apply it to everything I do. The FP Algorithms book has a lazy queue, but that's as much as I've seen so far.
08:24:55 <psi> what are amortized algorithms? I know about amortized *analysis*
08:25:11 <goron> psi: that's what he meant, I hope.
08:25:36 <shapr> psi: Where you do something at the very last moment possible, usually later than a strict language.
08:25:45 <psi> ah
08:26:02 <psi> I don't think introduction to algorithm covers that
08:26:06 <shapr> For example, amortized balanced binary trees will put off balancing themselves until the next request.
08:26:26 <goron> No, indeed it doesn't.
08:26:43 <shapr> Same for the lazy queues in FP Algorithms, the input list isn't reversed and put into the output list until the output list is empty and another item is requested.
08:27:05 <goron> But I don't really see how lazyness helps you in your complexity.
08:27:29 <shapr> Okasaki's greatest contribution to algorithm theory is that he proved that algorithms that allow amortization are always more efficient than their strict counterparts.
08:28:13 * shapr scurfles for references...
08:28:26 <goron> shapr: oh, ok, so it's basically a class of algorithms which can efficiently return a small part of the correct answers?
08:29:25 <vincenz> goron: basically lazyness is needed to only do the actual heavy processing when it's needed
08:29:39 <shapr> http://citeseer.ist.psu.edu/okasaki95amortization.html - "It is possible, albeit somewhat more complex, to support append, head and tail all in constant (amortized) time"
08:31:14 <vincenz> goron: basically you offset a certain calculation thereby reducing it's complexity to O(1), and you guarantee that by the time that value isi needed you have had enough low cost operations that the average of those with the heavy operation is less than doing it all strictly
08:31:59 <shapr> Yeah, what vincenz said :-)
08:32:06 <goron> vincenz: sounds like amortized analysis to me, still.
08:32:08 <vincenz> he refers to it in term of credits and debits
08:32:16 <vincenz> goron: right, but that kind of thing is only feasible with lazy evaluation 
08:32:25 <goron> vincenz: oh, ok :)
08:32:33 <vincenz> well you don't actually need a lazy language, you could do it with thunks, but it'd be less efficient codingwise
08:32:42 <goron> vincenz: That's what I wanted to say
08:32:58 <Saulzar> That actually works in terms of practical efficiency rather than just the theoretical time complexity?
08:33:02 <shapr> In any case, that's why I still want to get Okasaki's book at some point, to absorb the sections on amortized algorithms.
08:33:03 <vincenz> goron: take the example of a queue, normally you'd have to reverse append each time, meaning O(N) addition, O(1) getting...
08:33:10 <vincenz> Saulzar: it still uses big O(notatiion)
08:33:49 <vincenz> goron: basically what you do is delay the reverse until the front list is empty... and then addition becomes O(1), and only every O(n) rounds do you need to reverse your reverse_tail...meaning effectively O(1) queues
08:33:53 * shapr goes back to doing paying (sort of) work...
08:34:11 <vincenz> cause the O(n) is credited over n O(1) additions
08:34:32 <goron> Ok
08:34:52 <shapr> And, delaying that reverse in a lazy language is about as complicated as not delaying it. That's not so in a strict language though.
08:35:01 <vincenz> shapr: correct, though not unfeasible
08:35:07 <shapr> Right
08:35:08 <Saulzar> Hmm..
08:35:20 <vincenz> if you read his book
08:35:26 <vincenz> he explains why he chose for lazy language
08:35:26 <shapr> Which I haven't sadly...
08:35:31 <vincenz> its' freely available
08:35:41 <vincenz> basically his thesis text
08:38:00 * gour has his thesis, but didn't have time to take a (deeper) look at
08:38:14 <shapr> My long term theory is that non-strict evaluation has a bunch of advantages that more than make up for the extra complexity that strict programmers see. I've found a bunch of advantages, but I haven't quite reached a conclusion one way or the other.
08:38:18 <vincenz> "purely functional data structures" okasaki
08:38:19 <vincenz> google for that
08:38:28 <shapr> I do hope that Cale will have time to write more about laziness for modularity.
08:38:45 <vincenz> shapr: I've been a strict programmer up until ocaml, and I have to say, I really like the switch to haskell, note how many channels I'm in nwo :P
08:39:04 <vincenz> it's a very interesting document, the one by okasaki, and very grokkable
08:39:11 * Saulzar expected to see 30
08:39:22 <vincenz> of course it only deals with persistent data structures
08:39:49 <shapr> vincenz: Well, I did recommend Haskell from the beginning, remember?
08:39:53 <goron> shapr: The semantics of lazy and strict evaluation basically is the same, only with strict evaluation you need to check some more things, unless you emulate lazyness. 
08:40:05 <vincenz> shapr: at the time it was not an option for the problem I had at hand
08:40:18 <goron> shapr: Isn't that the sole reason why lazy algorithms are simpler?
08:40:20 <shapr> Oh, too bad.
08:40:55 <gour> today, while preaching to python programmers about haskell, again that idea cropped up that 'haskell is academic language, while python is for practical things..'
08:40:58 <vincenz>                                                                                        $-notation
08:41:01 <vincenz> offers a lightweight syntax for integrating lazy evaluation into a predominantly strict language
08:41:01 <shapr> vincenz: In any case, I'm glad you made your way back to #haskell :-)
08:41:32 <shapr> gour: Yeah, that's why Python has a recursion limit....
08:41:51 <shapr> Since recursion is obviously not good for being practical, and is only of academic value.
08:41:57 <gour> lol
08:42:09 <vincenz> "We have shown that memoization, in the form of lazy evaluaiton, can resolve the apparent conflict between amortization and persistience"
08:42:17 <Saulzar> Haskell makes use of recursion heavily, it must be 
08:42:31 <gour> shapr: where can i found out more about recursion limit?
08:42:41 <vincenz> shapr: recursion and looping are semantically equivalent
08:42:44 * shapr blows the stack limit on a regular basis while writing code for Zope/Plone.
08:42:58 <shapr> vincenz: I should have included a sarcastic smiley =)
08:43:09 <vincenz> shapr: I know, tha's what you should tell the python gits
08:43:32 <Saulzar> Hmm, sounds interesting. I can see how a two list queue would work, but I don't see why it would be different in a lazy language (yet) :)
08:43:34 <vincenz> http://citeseer.ifi.unizh.ch/okasaki96functional.html
08:43:41 * gour googles 'python recursion limit'
08:44:03 <vincenz> Saulzar: the lazy language only eases the otherwise need for explicitly forcing computations into their memoized value
08:44:38 <vincenz> Saulzar: he doesn't claim it's not feasible in a strict language, just that there's more effort
08:45:31 <shapr> vincenz: What year did you pick up OCaml anyway? I haven't been on Ward's Wiki much in the last few years.
08:45:38 * Saulzar goes to read the paper
08:45:46 <vincenz> shapr: I haven't been on ward's wiki much either lately
08:46:15 <vincenz> shapr: last year? two years ago tops
08:46:34 <vincenz> wait
08:46:36 <vincenz> more than two years
08:46:40 <vincenz> I did icfp 2004 with part ocaml
08:46:54 <vincenz> but not 03
08:47:16 <shapr> I found a message from you May 2003 on the OCaml list, so nearly three years.
08:47:26 <vincenz> wow
08:47:57 <vincenz> shapr: want to see a cool screenshot?
08:48:08 <vincenz> http://img61.imageshack.us/my.php?image=screenshot2va.png
08:48:08 <shapr> sure!
08:48:35 <vincenz> gtk2hs, concurrency, stateT monad, all haskell (with basics checked with hunit)
08:48:40 * vincenz is learning haskell :)
08:48:43 <shapr> cool :-)
08:48:50 <shapr> Have you looked at QuickCheck yet?
08:48:54 <vincenz> we used tat
08:48:57 <vincenz> s/tat/that/
08:49:13 <vincenz> too bad you can't iterate over types
08:49:24 <shapr> You can with Generic Haskell.
08:49:37 <vincenz> checkRead x =  case (reads $ show x) of [(y,u)] -> x == y && (null u) _ -> False
08:49:38 <shapr> I dunno about any of the Generic library extensions.
08:49:43 <vincenz> and then I have like ..
08:49:51 <vincenz> quickCheck (checkRead :: World -> Bool)
08:49:56 <vincenz> and several more with Worrld replaced by other types
08:50:14 <shapr> Yeah, I have that same problem.
08:50:57 <vincenz> I plan to use hs-plugins to add a little text box at the bottom
08:51:08 <shapr> I'd very much like to have a property that's (Read a, Show a) => a -> a; (read . show) x == x
08:51:10 <vincenz> so you can do computations on selected nodes (I allow clickselection) and then displaying it
08:51:40 <vincenz> "map Gr.suc selectedNodes" or something
08:51:45 <vincenz> err
08:51:49 <vincenz> "concat $ map Gr.suc selectedNodes" or something
08:52:20 <xerox> (>>= Gr.suc selectedNodes)
08:52:25 <shapr> Lotsa good stuff happening in the Haskell world, like hs-plugins.
08:52:27 <xerox> ops.
08:52:33 <xerox> selectedNodes >>= Gr.suc
08:52:48 <vincenz> > [1,2,3] >>= (\x -> [x,y])
08:52:49 <lambdabot>  Not in scope: `y'
08:52:51 <vincenz> > [1,2,3] >>= (\x -> [x,x])
08:52:52 <lambdabot> [1,1,2,2,3,3]
08:52:55 <vincenz> aha :)
08:53:00 <vincenz> yeah, still have to learn some common idioims
08:53:15 <vincenz> if you want to code review the code (it's very clean) I can give you the darcs addy
08:53:35 <shapr> I don't have time, sadly.
08:53:44 <goron> Ok, I need to thread my finitemap though my program, and I am building a backtracking algorithm which uses that finitemap. What structure can I use best?
08:53:45 <vincenz> or just take a glance ;)
08:53:46 <shapr> But you could give out the address and see what people have to say.
08:53:52 <vincenz> goron: state mona
08:54:31 <xerox> vincenz: for the list monad, fmap = map, and join = concat, hence bind = concatMap.
08:55:23 <vincenz> http://abstractoasis.dyndns.org:8080/repos/icfp
08:55:33 <vincenz> xerox: yeah :)
08:55:48 <vincenz> xerox: how doesfmap have to do anything with monad's tho?
08:55:51 <vincenz> fmap = Functor
08:56:25 <xerox> Monads are Functors, bind = (join .) . fmap
08:56:36 <vincenz> bind == ?
08:56:40 <vincenz> >>= ?
08:56:53 <vincenz> @hoogle ??=
08:56:54 <lambdabot> No matches found
08:56:56 <vincenz> @hoogle >>=
08:56:57 <xerox> Yep, (>>=) is also called bind.
08:56:57 <lambdabot> Control.Monad.(>>=) :: Monad m => m a -> (a -> m b) -> m b
08:56:57 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
08:56:58 <vincenz> @hoogle bind
08:56:59 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
08:56:59 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects.bindBuffer :: BufferTarget ->
08:56:59 <lambdabot> StateVar (Maybe BufferObject)
08:56:59 <lambdabot> System.Console.Readline.bindKey :: Char -> Callback -> IO ()
08:57:02 <vincenz> xerox: ah thx
08:57:13 <vincenz> and join = ?
08:57:19 <xerox> join is join :-)
08:57:23 <vincenz> hmm never used it
08:57:29 <vincenz> @type join
08:57:30 <lambdabot> Not in scope: `join'
08:57:35 <xerox> @type Monad.join
08:57:35 <vincenz> @type Control.Monad.join
08:57:36 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:57:36 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:57:44 <vincenz> ah
08:57:52 <vincenz> like sequence
08:58:02 <xerox> @type Monad.sequence
08:58:03 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:58:03 <vincenz> @type sequence
08:58:04 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:58:07 <vincenz> nearly..
08:58:09 <xerox> Not exactly
08:58:37 <vincenz> can you give me a typical use-case (preferably not list-based, cause that'd be too obvious)
08:59:11 <vincenz> aha
08:59:16 <vincenz> x = return someaction
08:59:19 <vincenz> join x
09:00:03 <xerox> > join (+) 1
09:00:04 <lambdabot> 2
09:00:07 <xerox> <blink>
09:00:07 <vincenz> o.O
09:00:13 <vincenz> btw
09:00:15 <vincenz> how should I read
09:00:17 <vincenz> (f .) . g
09:00:23 <xerox> \x y -> f (g x y)
09:00:34 <vincenz> hmm
09:00:55 <vincenz> (f .) . g $ x -> (f . (g x))
09:00:56 <xerox> Sorry I wrote it in point free form unintentionally.
09:00:56 <vincenz> indeed
09:01:32 <vincenz> @pl \x y z -> f (g x y z)
09:01:33 <lambdabot> ((f .) .) . g
09:01:43 <vincenz> I see the pattern now
09:01:58 <xerox> Good :-)
09:02:03 <vincenz> @pl \x y z -> f (g x y) z
09:02:03 <lambdabot> (f .) . g
09:02:07 <vincenz> @pl \x y z -> f z (g x y)
09:02:07 <lambdabot> (flip f .) . g
09:02:12 <vincenz> yup
09:02:54 <vincenz> great song... mary j blige & u2 - one
09:03:24 <xerox> np: Jefferson Airplane - Somebody to Love
09:03:42 <vincenz> xerox: care to take at the visualization.hs file on that darcs rep?
09:04:28 <xerox> Okay.  Fix your Apache configuration for the .hs mime type, too :-)
09:04:39 <vincenz> xerox: it's a darcs rep
09:04:51 * vincenz would've gone for lighttpd but it doesn't come in package format for ubuntu
09:04:56 <vincenz> lighttdp is so much easier and better
09:05:36 <xerox> How are you drawing the map?
09:05:42 <vincenz> xerox: cairo :)
09:05:50 <vincenz> it's great
09:05:55 <vincenz> and the whoel gui is in a separate thread
09:05:57 <vincenz> hence all the MVar's
09:06:04 <vincenz> that way my main program is input driven
09:06:13 <vincenz> by using a statemonad that contains my current stdin
09:06:29 <vincenz> (Engine is the main engine both for robber and cop)
09:07:30 <Saulzar> Are you using threads to run the programs in the background?
09:07:37 <vincenz> hmm
09:07:38 <vincenz> ?
09:07:42 <vincenz> n
09:07:43 <vincenz> no...
09:07:45 <Saulzar> (Wondering why the MVars)
09:07:47 <vincenz> I do launchGui
09:08:00 <vincenz> which loads my guii so that it's not tightly coupled to the input fsm
09:08:06 <vincenz> and makes a thread
09:08:20 <xerox> Gee, the text mangling functions are so verbose
09:08:24 <vincenz> huh?
09:08:25 <Saulzar> Ah
09:08:25 <vincenz> which ones
09:09:27 <xerox> Buffer,Iter,BufferInsert,IterForwardToEnd,ViewScrollToIter
09:09:33 <vincenz> o.O
09:09:33 <vincenz> oh
09:09:34 <xerox> map ("text"++)
09:09:38 <vincenz> I thought you were referring to my code
09:09:47 <xerox> No no.
09:10:09 <xerox> I'm still trying to understand the reason of all the whitespace in the first column ;-)
09:10:14 <vincenz> me?
09:10:25 <vincenz> baggage from ocaml modules
09:10:33 <vincenz> and I think it's more legible
09:10:36 <xerox> Urgh.
09:11:10 <gour> anyone familiar with gobby?
09:11:11 <xerox> We really need to do a layer of pure drawing primitives, it would make the code look so better.
09:11:16 <vincenz> gour: yes
09:11:18 * xerox raises hand in gour's direction
09:11:29 <gour> how can one increase font size?
09:11:44 <xerox> Modifying the system theme is one option...
09:11:49 <gour> on win32?
09:11:55 <xerox> I think you could probably mess with gconf settings?
09:12:03 <gour> (my friend uses win xp)
09:12:14 <xerox> But in the end, is more like an hack than a well-thought feature.
09:12:42 <gour> xerox: so, we should ask for it...
09:12:50 <xerox> gour: indeed.
09:13:08 <xerox> Let's do an online petition!
09:13:12 <gour> yep
09:13:27 <xerox> i.e. mail a feature request :(
09:14:17 <gour> xerox: will do, now i'm busy gobbing :-)
09:14:26 <xerox> What are you gobbying out, if I may ask?
09:15:49 <xerox> vincenz: I wonder why do the curves on your viewer look like that.
09:16:27 <vincenz> curves?
09:16:37 <xerox> arrows?
09:16:39 <vincenz> cause I painstakingly make em look that way
09:18:47 <palomer> hrm
09:18:55 <palomer> the latest LtU post is old news
09:19:23 <palomer> Constraint solving is decidable, at least for some instances of X, but prohibitively expensive. <---lies!
09:19:35 <gour> xerox: some stuff for educational program about vedic philosophy, i.e. non-programming task
09:19:35 <xerox> Uh-oh?
09:19:44 <xerox> gour: it's always fun.
09:20:25 <palomer> it is not prohibitively expensive! Unless you have several constructors with the same type
09:20:29 <gour> xerox: yep, although my friend has small font
09:20:33 <palomer> grrr
09:20:43 <xerox> vincenz: how does one try your GUI?
09:20:53 <xerox> palomer: reply it!
09:21:03 <vincenz> xerox: two possibilities
09:21:13 <vincenz> a) download the bdk-toolkit for the ICFP 2005 thingy
09:21:24 <vincenz> b) use our own implementation of the server (yes overachievers)
09:21:25 <vincenz> make
09:21:27 <vincenz> ./Server
09:21:41 <vincenz> make sure to have gtk2hs
09:21:47 <xerox> Yes I have.
09:21:55 <xerox> Server: command "./bdk/no-op-robber" couldn't be executed
09:21:56 <ProfTeggy> Nice evening, all
09:22:01 <xerox> Howdy Pr0f!
09:22:08 <vincenz> whoops
09:22:15 <vincenz> lemme fix
09:22:43 <vincenz> xeror the hard way
09:23:12 * xerox shrugs
09:23:12 <vincenz> ./Server "./Robber nogui" "./Cop nogui" "./Cop nogui" "./Cop nogui" "./Cop nogui" "./Cop"
09:23:53 <vincenz> 1 nogui robber, 4 nogui cops, and then a gui cpo
09:24:00 <xerox> Whoa, cool!
09:24:00 <vincenz> s/cpo/cop
09:24:13 <xerox> You should've made the GUI resizable for greater effect ;-)
09:24:17 <vincenz> it is
09:24:39 <vincenz> xerox: if you want it to pause
09:24:41 <vincenz> open Visualization
09:24:45 <vincenz> go down to pauseStep
09:24:52 <vincenz> and uncomment then takeMVar line
09:25:00 <vincenz> and comment the return() or threadDelay line (can't remember which)
09:25:03 <xerox> I mean setting a fixed aspect ratio, adding the possibility of stretching and enlarging the image.
09:25:14 <vincenz> xerox: you can click on nodes too :)
09:25:20 <xerox> UH!
09:25:21 <Saulzar> Hmm, is there a good way of doing that for gtk widgets?
09:25:43 <vincenz> xerox: open Visualization, go down to guiPauseStep
09:25:47 <xerox> Saulzar: read up on Duncan's clock, I tried that way, and it works nicely.
09:25:48 <vincenz> uncomment the takeMvar line
09:25:56 <vincenz> so it pauses at each step
09:26:00 <vincenz> then you can try clicking
09:26:04 <vincenz> or hiding/showing graphs
09:26:15 <vincenz> (basically as user of the lib you do "drwGrapg "sometitle" ..."
09:26:19 <vincenz> and then you can hide the different graphs
09:26:22 <vincenz> or show em
09:26:35 <vincenz>     guiGraphTable   :: MVar (M.Map String (Button, (Bool, Render ())))
09:26:53 <vincenz> each graph has a name, a button to hide/show, a state if it's shown, and the actual Render ()
09:27:01 <xerox> Saulzar: even more than nicely, in fact.  It caches static things, and can choose between low and high quality drawings on the fly - e.g. when resizing (leading to very LOW cpu usage times!)
09:27:35 <xerox> vincenz: I see, it's pretty nice.
09:27:54 <Saulzar> Ah, this is a cairo specific thing? I was trying to do it for a GL area, gave up and just added fixed-aspect ratio stuff to the drawing code.
09:27:56 <vincenz> tried clicking yet?
09:27:59 <xerox> Yup.
09:28:10 <xerox> Saulzar: mumble.
09:28:11 <vincenz> xerox: I plan to decouple the visualization (already have a lot) so you can do
09:28:18 <vincenz> (with some textbox at the bottom)
09:28:29 <vincenz> "concatMap Gr.suc selectedNodes"
09:28:34 <palomer> I laways knew type inference for algebraic datatypes was decidable
09:28:35 <vincenz> and it'll show the resulting ndoes/edges
09:28:40 <palomer> my supervisor never believed me
09:28:53 <xerox> I'm very interested in the onClick things.
09:29:02 <vincenz> xerox: it's ugly
09:29:02 <palomer> what's the deal with the 2 first articles on LtU?
09:29:07 <vincenz> I basically use a custom quadmap
09:29:14 <vincenz> check out grid
09:29:46 <xerox> vincenz: I want to code up a clean solution, yep.
09:29:48 <vincenz> (the nice thing of the structure is that you can use more intelligent ways of partitioning, right now I just partition the way that'll divide up nicest)
09:30:53 <vincenz> xerox: anyways, we want to make the gui a separate thing to experiment with graphs and graphalgos
09:31:03 <vincenz> have two textboxs at the bottom "Edges" "Nodes"
09:31:08 <vincenz> and then you type "
09:31:15 <vincenz> concatMap Gr.suc selectedNodes
09:31:29 <vincenz> and it runs and displays thos enodes that result from the computation, with selectedNodes being those you had clicked
09:32:15 <xerox> vincenz: sounds neat!
09:32:24 <vincenz> I'm not too happy about one thing, I use specific primitives "GUINode" and "GUIEdge" cause they all have to be more or less the same size (cause my clicking and grid thingy relies on it)
09:32:47 <vincenz> and I just realize I have a bug with the onclick
09:40:24 <adept> haskell ascii art :) http://thesz.livejournal.com/155164.html?mode=reply
09:41:16 <vincenz> xerox: any code comments/
09:41:24 <vincenz> adept: nice behinds
09:41:46 <edwinb> that is a splendid error message :)
09:42:40 <adept> yep. I wonder what the code looks like :)
09:48:55 <palomer> @y
09:48:55 <lambdabot> YOW!!  Everybody out of the GENETIC POOL!
09:49:45 <shapr> @ow
09:49:46 <lambdabot> WHOA!!  Ken and Barbie are having TOO MUCH FUN!!  It must be the
09:49:46 <lambdabot> NEGATIVE IONS!!
09:49:53 <palomer> @w
09:49:53 <lambdabot> Maybe you meant: web1913 what where where+ wiki wikipedia wn world02 .
09:50:07 <palomer> I like that last one
09:50:53 <Saulzar> @wn emu
09:50:55 <lambdabot> *** "emu" wn "WordNet (r) 2.0"
09:50:55 <lambdabot> emu
09:50:55 <lambdabot>   n 1: any of various systems of units for measuring electricity
09:50:55 <lambdabot>     and magnetism [syn: {electromagnetic unit}]
09:50:55 <lambdabot>   2: large Australian flightless bird similar to the ostrich but
09:50:57 <lambdabot>    smaller [syn: {Dromaius novaehollandiae}, {Emu
09:50:59 <lambdabot>    novaehollandiae}]
09:51:04 <vincenz> xerox: taken a look?
10:02:18 <palomer> @hoogle foldlM
10:02:19 <lambdabot> No matches found
10:02:23 <palomer> @hoogle foldM
10:02:23 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m
10:02:23 <lambdabot> a
10:02:23 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
10:02:23 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c ->
10:02:23 <lambdabot> c) -> c -> m (gr a b) -> m c
10:02:28 * araujo back form lunch
10:02:31 <palomer> @hoogle fold1M
10:02:31 <lambdabot> No matches found
10:02:36 <palomer> is there a foldl1M?
10:03:05 <palomer> @hoogle Monad m => (a->a-> m a) -> [a] -> m a
10:03:06 <lambdabot> No matches, try a more general search
10:04:14 <palomer> nevermind
10:12:41 <MarcWeber> Do you have some examples on how to use runProcess with pipes (in,out and so on?)
10:16:40 <Cale> MarcWeber: runProcess is only useful of course if you can get hold of the handles you want before calling it. So basically, open up some files in appropriate modes and pass those.
10:16:50 * SimonRC goes.
10:17:55 <Cale> runInteractiveProcess lets you have back the handles for the process so that you can communicate with it. The only tricky part there is remembering to flush the handles every once in a while, or turning off buffering.
10:20:04 <MarcWeber> ah.. I've found some examples with google. I simply haven't used it, yet.
10:57:37 <pierre-> can someone explain me what "arrows" are?
10:58:18 <araujo> it's the functinal operator
10:58:56 <pierre-> and what's the functinal operator? 
11:02:13 <_Codex> arrows are pretty much like functions.
11:04:39 <_Codex> there is even conversion from a function: arr :: (b->c) -> a b c :)
11:05:31 <_Codex> think of arrow as "explicit interface that reveals many properties of functions".
11:11:44 <_Codex> (all we need is elem :: (Arrow a) => b-> a Top b )
11:12:24 <_Codex> I wonder why that is not provided by default :-)
11:14:24 <nooga> hw to make geometric progression in haskell?
11:15:50 <kowey> got a random question here: anybody know any blind haskellers?
11:16:06 <xerox> > take 20 $ iterate (*2) 2
11:16:07 <lambdabot> [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,
11:16:07 <lambdabot> 262144,524288,1048576]
11:16:08 <araujo> uh?
11:16:11 <xerox> Like that, nooga ?
11:16:32 <nooga> ah, iterate
11:16:38 <xerox> kowey: Yes, partially.
11:16:45 <kowey> i've a got a blind friend who programs in Caml, and is nervous about the white-space
11:16:58 <kowey> i wonder what i could suggest
11:17:13 <kowey> his terminal is 80x1 and he can only look at 40 chars at a time
11:17:26 <SyntaxNinja> kowey: there are whitespace issues in Haskell as well, but I I think you can always use braces and ';' instead.
11:17:43 <xerox> kowey: I think delYsid wrote some Haskell programs some time ago, every once a while shows up on IRC too, and he has a site (google for his nick).
11:17:56 <kowey> SyntaxNinja: well, he's currently a Caml hacker, and he's nervous about having to deal with whitespace if he ever has to pick up Haskell
11:18:51 <kowey> hmm... so i guess what might be useful for him is a quick converter to add {} and ; to code
11:19:09 <kowey> xerox: thanks
11:23:48 <SyntaxNinja> kowey: right, if he needs to read others' code, a converter might help, and for his own code, he can use {} and ;.
11:26:28 <kowey> heh: my blind friend is unsurprised about delysid; says he maintains a ton of debian packages, including the one for his braille-board drivers
11:27:05 <xerox> kowey: yeah, that's right.
11:28:21 <SyntaxNinja> kowey, xerox: how do blind hackers do it?  they use text-to-speech and keep track of things in their heads?
11:28:36 <SyntaxNinja> do they usually highlight a line and the computer reads it aloud to them?
11:29:03 <kowey> well, my friend just uses his 40x1 display and keeps track of things in his head
11:29:12 <xerox> SyntaxNinja: I saw a video sometime ago of that guy using a braille terminal, and a classica keyboard I think.  Or maybe it had braille glyphs too.
11:29:17 <kowey> he's great for proofreading, because he never skims
11:29:24 <astrolabe> Does he have some sight?
11:29:51 <SyntaxNinja> interesting
11:29:53 <xerox> SyntaxNinja: delYsid went on the national television or something for his works, that is
11:30:08 <kowey> although to make a random plug: anybody who publishes, please consider putting your tex online :-)
11:30:23 <kowey> pdf and ps are not very blind-friendly
11:31:03 <xerox> kowey: talking of that kind of sources... maybe literate haskell files do help. (.lhs extension, TeX formatting)
11:31:57 <kowey> xerox: i suppose just by virtue of the comments-to-code ratio being flipped upside down
11:32:27 <kowey> although, my friend says now that if he really had to learn haskell, the whitespace probably wouldn't hold him back
11:32:32 <xerox> kowey: that's right, code is "commented" with '>' being the first char of the line
11:33:31 <SyntaxNinja> kowey: what is the problem w/ whitespace?
11:33:38 <kowey> hmm... i tend to use \begin{code} \end{code} ; but i still haven't settled on what the 'best' practices are for me needs
11:34:03 <kowey> well, SyntaxNinja, indentation is useful if you're looking at code in 2D
11:34:09 <kowey> because you see columns line up
11:34:42 <kowey> but if you only read one line at a time, physically moving from character to character, it's not so convenient
11:35:05 <kowey> because you have to remember where the identation was on the previous line
11:35:21 <SyntaxNinja> kowey: I see.
11:35:57 <kowey> i mean, of course, he could just bump the cursor up and down to check, so it's not really a huge problem
11:36:10 <kowey> just enough to give him extra inertia, the "i'm happy with Caml for now"
11:36:12 <kowey> :-)
11:38:09 <Cale> not to mention that if he wanted, he could include the semicolons and braces, and not have to worry about whitespace
11:39:05 <kowey> indeed... i guess it's mostly a matter of reading other people's code (and sharing your code with other haskellers)
11:43:01 * nooga desmn't like syntax where whitespace matters
11:45:30 * sieni agrees
11:46:12 <astrolabe> I think it has pros and cons
11:46:53 <sieni> although Haskell has actual substance as a programming language as opposed to some other whitespace sensitive languages
11:47:23 <astrolabe> I think of formatting as a kind of comment.  If this comment is enforced/meaningful to the compiler, that acts as a check.
11:48:02 <nooga> and i dont understand if then else then construction
11:48:34 <astrolabe> you mean 'if then else'?
11:49:01 <astrolabe> @eval if False then 1 else 2
11:49:02 <lambdabot> 2
11:49:07 <nooga> can i use {} afyet then?
11:49:10 <nooga> after
11:50:01 <nooga> eval if True then {1;3;} else 0
11:50:08 <nooga> @eval if True then {1;3;} else 0
11:50:08 <lambdabot>  parse error on input `{'
11:50:15 <nooga> maybe do?
11:51:09 <astrolabe> I don't think you can use {} after then
11:51:21 <astrolabe> do should work though.
11:51:32 <nooga> then how to place multiple instructions there?
11:51:45 <astrolabe> You mean monadic instructions?
11:51:51 <davidhouse> if True then do { 1; 3; } else 2;
11:51:57 <davidhouse> > if True then do { 1; 3; } else 2
11:51:58 <lambdabot>  add an instance declaration for (Num (m b))
11:51:58 <lambdabot>   In the definition of `jcn':
11:51:58 <lambdabot>    jcn = if True then
11:52:09 <astrolabe> You don't get multiple instructions normally in haskell.
11:52:23 <davidhouse> > if True then do { putStrLn $ show 1; putStrLn $ show 3; } else 2
11:52:24 <lambdabot>  add an instance declaration for (Num (IO ()))
11:52:24 <lambdabot>   In the definition of `lvy':
11:52:24 <lambdabot>    lvy = if True then
11:52:28 <davidhouse> screw it.
11:53:02 <astrolabe> Even the word 'instruction' sounds a bit imperitive to me.
11:59:13 <nooga> HUYH
11:59:15 <nooga> huh
11:59:42 <nooga> most languages i've tried are imperative or semi-impeartive
12:00:10 <nooga> so it must take time to learn "putting funk in funktion" ;p
12:00:45 <astrolabe> You can do imperative stuff in haskell, but it is a little harder than functional stuff.
12:01:17 <astrolabe> lambdabot can't return an action I don't think, or I'd show you.
12:02:38 <nooga> @eval (\a b -> a*10^(length $ show a)+b) 123 666
12:02:39 <lambdabot> 123666
12:02:42 <nooga> ha :D
12:02:59 <nooga> my iggest achievement !
12:04:20 <vincenz> re
12:04:42 <astrolabe> @eval (if False then (* 2) else do{(+1);(*3)}) 4
12:04:43 <lambdabot> 12
12:05:21 <nooga> thx
12:05:23 <nooga> g2g
12:06:03 <nooga> bye
12:06:12 <astrolabe> bye
12:07:45 <flux__> astrolabe, hmm.. that doesn't work in ghci, do I need to import something?
12:09:02 <xerox> flux__: Monad.Reader :-)
12:09:45 <vincenz> @type (if False then (* 2) else do{(+1);(*3)}) 
12:09:46 <lambdabot> forall a. (Monad ((->) a), Num a) => a -> a
12:10:26 <vincenz> funky type
12:13:11 <vincenz> Anyone use happy?
12:13:43 <kowey> i used to
12:14:09 <vincenz> is it possible to add something like %prec to grammar rules
12:15:08 <kowey> does this answer your question? http://www.haskell.org/happy/doc/html/sec-Precedences.html
12:15:17 <kowey> (i don't know enough to answer it myself)
12:15:26 <vincenz> ah cool :)
12:15:27 <vincenz> thx
12:15:30 <vincenz> I hadn't found that bit
12:15:51 <vincenz> time to continue on my c++ parser
12:18:13 <xerox> Mumble.
12:18:37 <vincenz> ?
12:28:21 <xerox> Ooooh.
12:28:22 <vincenz> as for alex
12:28:28 <xerox> flux__: that is:
12:28:30 <xerox> > runReader (if False then Reader (+1) else Reader (+1) >> Reader (*3)) 4
12:28:31 <vincenz> is it possible to do different token rules?
12:28:31 <lambdabot> 12
12:28:55 <vincenz> for alex
12:29:11 <vincenz> such that I can go into a different token mode to handle multiline comments
12:29:25 <xerox> ski: how were (a -> a) called, sorry?
12:29:31 <xerox> endofunctors?
12:31:39 <kowey> vincenz: how about http://www.haskell.org/alex/doc/html/alex-files.html#startcodes ?
12:33:03 <flux__> xerox, does it come with ghc 6.4?
12:33:51 <xerox> flux__: sure.  :m + Control.Monad.Reader
12:34:08 <vincenz> kowey: cool, thx
12:34:21 <kowey> vincenz: why not parsec, out of curiosity?
12:34:28 <vincenz> kowey: parsing or lexing?
12:34:34 <kowey> both
12:34:41 <vincenz> you try doing c++ with LL
12:34:42 <vincenz> ;)
12:34:49 <flux__> right, I missed the Control-part
12:34:53 <flux__> @index Reader
12:34:53 <lambdabot> Control.Monad.Reader, Control.Monad.RWS, Control.Monad.Reader, Control.
12:34:53 <lambdabot> Monad.RWS
12:35:01 <kowey> hmm... what's the difference with Java syntax?
12:35:06 <vincenz> kowey: I found a minimalistic .l and .y file ... I'm moving it to hasell
12:35:09 <vincenz> kowey: a fricking lot
12:35:12 <kowey> k :-)
12:35:13 <vincenz> kowey: c++ is by definition ambigious
12:35:22 <vincenz> I could prolly write a java parser in a weekend
12:35:46 <vincenz> from scratch
12:35:48 <vincenz> not c++
12:35:49 <vincenz> it's inane
12:35:51 <xerox> I think there are some presets hanging around in the Parsec module hierarchy.
12:35:52 <kowey> wow, ok, i was basing this on the superficial similiarities
12:36:11 <vincenz> kowey: there's a lot of syntax ambiguities that require semantical analysis to fix (even some in c)
12:36:58 <vincenz> let me try to remember an example
12:37:16 <xerox> *(void *)&x :P
12:37:19 <vincenz> for instance
12:37:27 <vincenz> xerox: not to mention how to parse < in the context of templates
12:37:39 <xerox> Brrr.
12:37:39 <vincenz> A < B , C > a;
12:37:45 <vincenz> a < B and C > a
12:37:50 <vincenz> or is the first A a template
12:37:56 <vincenz> in which case it's a declaration instead of two exps
12:38:26 <kowey> huh... i wonder if parsec handles java 1.5 stuff with the template-like stuff
12:38:57 <kowey> but perhaps the presets have a very loose definition, where "java-style" means "uses /* */ and braces"
12:39:17 <vincenz> shit
12:39:22 <vincenz> I was hoping to copy an updated .l file from gc
12:39:24 <vincenz> gcc even
12:39:29 <vincenz> gcc even has the lexer manually coded
12:39:31 * vincenz mutters
12:49:16 <vincenz> whew
12:49:20 <vincenz> literals are the same in c and C++
12:49:25 <vincenz> so I can jsut copy what I had written in ocaml
12:57:10 <davidhouse> what's the type class for whole numbers?
12:57:26 <xerox> Num
12:57:33 <vincenz> Integral
12:57:36 <davidhouse> doesn't that cover things like RealFracs as well?
12:57:43 <davidhouse> vincenz: cool, that's what I though.
12:57:47 <xerox> Hmm?
12:57:53 <xerox> Why so?
12:58:04 <vincenz> davidhouse: for all RealFrac a => Num a, not viceversa
12:58:47 <davidhouse> vincenz: yes, but Num a does not imply a is a whole number
12:58:56 <davidhouse> so Num is too general. Integral is what i want
12:59:03 <xerox> What do you mean by "whole number" ?
12:59:03 <vincenz> davidhouse: that's why I said Integral
12:59:08 * vincenz pokes davidhouse 
12:59:17 <vincenz> davidhouse: xerox said num
12:59:34 <davidhouse> vincenz: yes, but... never mind.
12:59:41 <davidhouse> xerox, a number without a fractional part
12:59:45 <davidhouse> an integer.
12:59:47 <vincenz> davidhouse: my point is that... not all Num's are Realfrac's
12:59:53 <davidhouse> vincenz: i knew that.
12:59:56 <vincenz> okies
12:59:57 <xerox> I thought 'whole' meant "all"
13:00:13 <davidhouse> it does, but 'whole number' usually means an integer.
13:00:15 <vincenz> xerox: is that what you eat when you eat "whole-bran"?
13:00:20 <vincenz> xerox: the *entire* box???
13:00:25 <xerox> I don't know what is it o_O
13:00:33 <davidhouse> the thing is, just using Int isn't good enough, it could be an Integer etc.
13:00:40 <sieni> http://en.wikipedia.org/wiki/Whole_number
13:00:47 <davidhouse> so i wondered what the type class was.
13:00:49 <vincenz> *shuts up the sarcasm*
13:01:17 <vincenz> davidhouse: Integral covers Int and Integer
13:01:34 <vincenz> davidhouse: but I would define the needed class by operations, not by fuzzy definition
13:01:45 <xerox> Thanks for the explanations!
13:01:54 <vincenz> davidhouse: :i Integral or :i Num will give you what operations they support
13:01:56 <vincenz> in ghci
13:02:04 <xerox> (The instances)
13:02:14 <xerox> (What datatypes are in the class, that is)
13:02:33 <vincenz> xerox: peano numbers are whole
13:03:21 <davidhouse> vincenz: well i want to say my function maps whole numbers to whole numbers. my current type definition is f a :: (Integral a) => a -> a. is this not what you'd choose?
13:03:30 <vincenz> davidhouse: why not use Num a?
13:03:37 <vincenz> davidhouse: I'd only limit by what the function uses
13:04:07 <davidhouse> vincenz, because i want it to be undefined for nonintegers :)
13:04:21 <vincenz> davidhouse: why
13:04:30 <davidhouse> this wil be a function that finds the prime factorisation of a number. this is only defined for integers.
13:04:45 <vincenz> davidhouse: I don't think you can limit
13:04:52 <davidhouse> (so i lied slightly, it will in fact have type signiture f a :: (Integral a) => a -> a)
13:05:07 <davidhouse> err, f a :: (Integral a) => a -> [(a,a)]
13:05:12 <vincenz> s/f a/ f
13:05:24 <davidhouse> that too,
13:05:47 <davidhouse> vincenz: will that type definition not limit my functions to Ints and Integers?
13:06:09 <vincenz> let O = subsetof
13:06:14 <vincenz> I think that RealFrac O Integral
13:06:31 <vincenz> (we really need unicode irc)
13:06:48 <davidhouse> ? that makes no sense
13:06:56 <vincenz> whatever is realfrac is also integral
13:06:57 <davidhouse> as 3.4 is a RealFrac but not an Integral
13:07:03 <vincenz> hmm
13:07:05 <vincenz> oy
13:07:06 <davidhouse> so RealFrac superset Integral.
13:07:06 <vincenz> sorry
13:07:19 <davidhouse> yes.
13:07:20 <vincenz> not thinking and haskell newb
13:08:06 <davidhouse> but my function will only be defined on integers. so I think the correct definition is f :: (Integral a) => a -> [(a,a)].
13:08:20 <vincenz> yip
13:08:29 <vincenz> althoguh
13:08:31 <vincenz> a -> a works too
13:08:39 <vincenz> since the second a is just inp/outp
13:08:45 <vincenz> err
13:08:48 <vincenz> inp `div` outp
13:08:48 <davidhouse> well it will return a list of pairs.
13:09:01 <ihope> @djinn a -> [(a,a)]
13:09:01 <lambdabot> -- f cannot be realized.
13:09:12 <vincenz> @djinn a -> [a]
13:09:13 <lambdabot> -- f cannot be realized.
13:09:16 <vincenz> @djinn a -> a
13:09:16 <lambdabot> f a = a
13:09:27 <davidhouse> @hoogle a -> [a]
13:09:28 <lambdabot> Data.List.repeat :: a -> [a]
13:09:28 <lambdabot> Prelude.repeat :: a -> [a]
13:09:28 <lambdabot> Data.List.replicate :: Int -> a -> [a]
13:09:28 <ihope> @type (return . join (,))
13:09:29 <lambdabot> Not in scope: `join'
13:09:37 <ihope> @type (return . Control.Monad.Reader.join (,))
13:09:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m (a, a)
13:09:49 <ihope> @type (return . Control.Monad.join (,))
13:09:50 <lambdabot> forall (m :: * -> *) a. (Monad m, Monad ((->) a)) => a -> m (a, a)
13:10:35 <ihope> > 3 :: String
13:10:36 <lambdabot>  add an instance declaration for (Num String)
13:10:36 <lambdabot>   In the expression: 3 :: String
13:10:36 <lambdabot>   In the definition of `val': val = 3 :: String
13:10:49 <ihope> @type \a -> 3 ++ a
13:10:50 <lambdabot> forall a. (Num [a]) => [a] -> [a]
13:10:55 <ihope> Tee hee.
13:11:34 <vincenz> funky that's typeable
13:11:47 <vincenz> how do you define an instance of Num
13:11:55 <vincenz> ah...fromInteger
13:12:08 <ihope> (+), (-), fromInteger, negate
13:12:10 <ihope> (*)
13:12:28 <vincenz> negate (a,b) = (b,a)
13:12:32 <vincenz> or
13:12:34 <ihope> If you have either negate or (-), the other probably isn't necessary.
13:12:37 <vincenz> negate Left a = Right a
13:12:48 <vincenz> ihope: - = substractioin
13:13:20 <ihope> I know. So there are the definitions negate x = 0 - x and x - y = x + negate y
13:13:26 <ihope> But those don't always work.
13:13:47 <ihope> For example, there's natural numbers. Defining only negate, 3 - 1 = 3 + -1.
13:13:56 <ihope> However, -1 isn't a natural number, so it fails.
13:15:37 <ihope> Which is correct: "I American, me!" or "Me American, me!"?
13:17:52 <neologism> ihope: this is circular definition
13:18:00 <neologism> you define - by using -
13:18:21 <ihope> neologism: that's why one or the other has to be defined in the instance declaration
13:18:49 <neologism> whats the point of defining it then?
13:19:32 <vincenz> who wants a small lecture in the emotional semantics of haskell
13:19:43 <vincenz> (yes, haskell understands emotional states)
13:19:53 <neologism> vincenz: if they are embeded in a monad why not :)
13:19:56 <vincenz> > reverse "):"
13:19:58 <lambdabot> ":)"
13:20:22 <vincenz> notice how it properly identifies that the reverse of sad is happy
13:20:33 <neologism> > reverse ":-)"
13:20:34 <lambdabot> ")-:"
13:21:01 <ihope> neologism: if those aren't defined, then *both* have to be defined in the instance declaration
13:21:06 <psi> > reverse ";_;"
13:21:06 <ihope> > reverse ">:-)"
13:21:07 <lambdabot> ";_;"
13:21:07 <lambdabot> ")-:>"
13:21:11 <vincenz> indeed, it is a 'reverse'able definition
13:21:28 <vincenz> and of course a pair of ... t*ts are ambiguous
13:21:33 <vincenz> > reverse "(.) (.)"
13:21:35 <lambdabot> ").( ).("
13:21:38 <vincenz> err
13:21:43 * vincenz shuts up
13:23:49 <vincenz> (sleepdepr, what are you high on?)
13:27:18 <vincenz> out of curiousity, are states in alex  only doable with monad?
13:27:26 <shapr> sleepdeprivation?
13:28:12 * shapr knows all about that.
13:28:16 <neologism> @hoogle ohsix
13:28:17 <lambdabot> No matches found
13:28:30 <neologism> ehm.. whats the url of haskell '06 draft?
13:28:39 <vincenz> and is it possible to bundle em together
13:30:02 <tony2> shapr, when can I look forward to the next TMR?
13:30:16 <tony2> is it dead?
13:33:34 <ihope> I'd like to be able to define primitives.
13:34:09 <neologism> pls pls.. whats the url of the draft?
13:34:28 <ihope> Like some datatype with constructors Return and (:>>=) that were also used for the Monad instance declaration.
13:34:42 <ihope> But it'd be tricky to implement, of course.
13:43:12 <ValarQ> ihope: that was a weird smiley
13:44:57 <ihope> :-)
13:45:04 <ihope> How about :=<<?
13:56:46 * vincenz struggles with monad alex
13:57:29 <vincenz> CxxLexer.x:193:18: The last statement in a 'do' construct must be an expression
13:57:38 <vincenz> part of the code I copied literally from somewhere else that compiles
14:01:08 <vincenz> grr
14:01:10 <vincenz> stupid code
14:02:09 <vincenz> scanner str = runAlex str $
14:02:09 <vincenz>   let loop i = do
14:02:09 <vincenz>     tok <- alexMonadScan
14:02:09 <vincenz>     if tok == "stopped." || tok == "error."
14:02:09 <vincenz>       then return i
14:02:11 <vincenz>       else let i' = i+1 in i' `seq` loop i'
14:02:14 <vincenz>     in loop 0
14:02:16 <vincenz> it complains on an empty do construct
14:02:59 <Lemmih> Remove two space before the 'in'?
14:03:10 * vincenz uses where and breathes easier
14:03:41 <vincenz> now the hardest part
14:03:46 <vincenz> apparently you can enter another state
14:03:59 <vincenz> and then you can run a monadic action while there to accumulate
14:04:03 <vincenz> but not sure how to achieve that
14:05:12 <vincenz> suggestions are welcome
14:07:16 <vincenz> oh nm, apparently you can make your own monads
14:16:50 <davidhouse> i need a function for determining whether a given RealFrac is an Integral.
14:17:03 <davidhouse> i.e., whether a given rational is an integer.
14:19:05 <vincenz> @type seq
14:19:07 <lambdabot> forall b a. a -> b -> b
14:19:14 <vincenz> o.O
14:26:52 <davidhouse> @hoogle a -> Bool
14:26:53 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
14:26:53 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
14:26:53 <lambdabot> Data.Bool.False :: Bool
14:27:03 <davidhouse> @hoogle Num -> Bool
14:27:04 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
14:27:04 <lambdabot> Data.Bool.False :: Bool
14:27:04 <lambdabot> Data.Bool.True :: Bool
14:27:48 <Lemmih> davidhouse: You can't check whether a type is an instance of a typeclass at runtime.
14:28:38 <davidhouse> Lemmih, hmm...
14:28:45 <davidhouse> okay, i'll have to work round it.
14:28:51 <davidhouse> that still seems like a weird limitation to me.
14:31:18 * SamB wonders if you could use a *real* type system to simplify Inform decompilation...
14:31:54 * TuringTest wishes SamB would ponder in English
14:32:22 * SamB expects it wouldn't work
14:32:44 <SamB> TuringTest: oh, I'm just playing with this Z-machine to Inform decompiler called reform...
14:32:48 <SamB> its written in Haskell
14:32:59 <SamB> I've got some local mods made to it too
14:33:35 <SamB> the type inference isn't very good, though
14:34:33 <Lemmih> davidhouse: Check whether a type is an instance of a typeclass doesn't make sense.
14:34:48 <SamB> and switch statements and such tend to throw it off completely...
14:36:37 <SamB> Lemmih: sure it does... at runtime!
14:36:41 <Lemmih> davidhouse: You wouldn't be able to use a type as an Integral even if you were sure it was a member of the class.
14:36:55 <TuringTest> Lemmih: It's could work like GADT's 
14:37:09 <Lemmih> TuringTest: eh?
14:37:37 <TuringTest> if (num `instanceOf` Real) then (we know num is real here) else (we know it isn't)
14:37:42 <davidhouse> Lemmih, yeah, i see that now.
14:38:17 <Lemmih> TuringTest: But you wouldn't be able to use 'num' as a Real.
14:38:24 <SamB> oh, nice, I didn't know Reform supported enums...
14:38:53 <SamB> Lemmih: which is why you'd have to also be able to grab the instance dictionary or whatever ;-)
14:38:57 <TuringTest> Lemmih: You could if the dictionary for that Real instance was handy.
14:39:55 <Lemmih> SamB, TuringTest: Where would you get the dictionary from?
14:40:41 <SamB> Lemmih: well, presumably it isn't any harder to get the dictionary than it is to check whether the type is an instance of a class...
14:40:44 <TuringTest> That is an implementation detail that is beyond my ability to comment.
14:41:31 <TuringTest> I think C++ can let you do safe casts to subtypes via a mechanism like this.  There the v-table holds the needed data.
14:41:54 <TuringTest> And of course Java can do scary things via reflection.
14:41:57 <Lemmih> dicts = [(Type,Dictionary)]; getDict x = lookup (typeOf x) dicts?
14:42:15 <Lemmih> Yak, yak.
14:42:32 <TuringTest> Or each Type would have a pointer to the dicts already.
14:42:52 <davidhouse> @type (/)
14:42:53 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:42:54 <TuringTest> So (pointerToDicts aType) would be the Dicts.
14:43:05 <TuringTest> Hypothetically speaking
14:43:22 <Lemmih> I'm pretty happy things are as they are.
14:43:57 <TuringTest> I would be happier if something like Associate Types appeared.
14:44:04 <TuringTest> Associated
14:44:22 * goron would be happier if a great free Lisp implementation existed
14:44:48 <goron> Then write a parser for Haskell in Lisp and we would have utopia.
14:44:50 <goron> ;)
14:45:25 <davidhouse> write a lisp implementation in haskell.
14:45:39 <davidhouse> and revel in circular definitions :)
14:46:12 <TuringTest> Or everything at once: http://home.cs.tum.edu/~mai/poly.sh.pl.tcl.cpp.bf.py.c.lhs.txt
14:46:16 <goron> davidhouse: Wouldn't that be a slow language?
14:46:56 <vincenz> Could someone explain me the following idion
14:46:59 <vincenz> idio
14:47:03 <TuringTest> ...
14:47:07 <goron> idiom
14:47:16 <TuringTest> idiot
14:47:25 <vincenz> MyMonad $ \s -> case s{someupdates} of s@(X{}) -> Right (s,())
14:47:25 <TuringTest> ?
14:47:30 <vincenz> why the case
14:47:38 <vincenz> and not a direct update on the right side
14:48:01 <TuringTest> case is strict, he may be avoiding laziness...hmm...
14:48:04 <goron> idio is a word... who'd have thought that?
14:48:12 <vincenz> s/idio/idiom
14:48:27 <goron> Oh, so you did mean idiom :)
14:48:41 <vincenz> alexGetInput :: Alex AlexInput
14:48:41 <vincenz> alexGetInput
14:48:41 <vincenz>  = Alex $ \s@AlexState{alex_pos=pos,alex_chr=c,alex_inp=inp} ->
14:48:41 <vincenz>   Right (s, (pos,c,inp))
14:48:48 <vincenz> whoops
14:48:54 <vincenz> alexSetInput (pos,c,inp)
14:48:55 <vincenz>  = Alex $ \s -> case s{alex_pos=pos,alex_chr=c,alex_inp=inp} of
14:48:55 <vincenz>       s@(AlexState{}) -> Right (s, ())
14:49:01 <goron> I have my StateMonad working on something which is allmost non-trivial :)
14:49:39 <goron> s/allmost/almost
14:50:08 <davidhouse> @pointless (\y -> x `mod` y == 0)
14:50:09 <lambdabot> (0 ==) . (x `mod`)
14:50:31 <xerox> I'd suggest to define a 'divides'
14:50:49 <xerox> Unfortunately '|' is took ;-)
14:51:01 <xerox> s/took/already taken/
14:52:21 <kampasky> Hello, I would like to have my program spit out debugging prints. Can I do it easily somehow?
14:52:31 <kampasky> Something like error but without terminating program execution
14:52:34 <Cale> kampasky: Debug.Trace
14:53:18 <kampasky> thanks!
14:53:41 <davidhouse> what's the easiest way to find the first value in a list for which a certain predicate is true
14:53:41 <davidhouse> ?
14:53:44 <Cale> lazy evaluation can make the results a bit confusing, but it can be helpful to capture test data
14:54:03 <davidhouse> something like take 1 $ filter p l seems a bit wasteful
14:54:05 <Cale> head . filter p
14:54:11 <Cale> why wasteful?
14:54:35 <davidhouse> hmm... when doing head . filter p, is the entire list filtered?
14:54:39 <Cale> no
14:54:43 <Cale> of course not :)
14:54:43 <davidhouse> okay, good.
14:55:47 <davidhouse> another thing, is there much difference between . and $ in most cases?
14:55:54 <davidhouse> i.e. head $ filter p would work as well
14:56:07 <Cale> head $ filter p is ill-typed
14:56:11 <tony2> find
14:56:11 <dibblego> one is hard to see and the other helps you buy cheeseburgers
14:56:34 <Cale> @type (.)
14:56:35 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
14:56:37 <Cale> @type ($)
14:56:38 <lambdabot> forall b a. (a -> b) -> a -> b
14:56:47 <tony2> find (==1) [2,3,4,1,5]
14:57:05 <davidhouse> > find (==1) [2,3,4,1,5]
14:57:06 <lambdabot> Just 1
14:57:13 <davidhouse> > find (<2) [2,3,4,1,5]
14:57:14 <lambdabot> Just 1
14:57:20 <davidhouse> cool :)
14:57:24 <xerox> (a . b . ... . z) x   ===   a . b . ... . z $ x
14:57:30 <musasabi> davidhouse: basically "(foo . bar) arg" vs "foo $ bar arg"
14:57:59 <davidhouse> musasabi: right... so its just syntaxically different?
14:58:08 <musasabi> mostly.
14:58:16 <davidhouse> thanks :)
14:58:33 <musasabi> (there are a few issues with runST, but you probably won't hit that for a while)
14:58:41 <Cale> davidhouse: the types of (.) and ($) are quite different
14:58:52 <Cale> (.) is an operation on functions
14:59:14 <Cale> ($) takes a function and a value to apply it to
14:59:44 <davidhouse> yes, but in practice (foo . bar) arg == foo $ bar arg in most places, right?
14:59:55 <Cale> yes
14:59:59 <Cale> by definition
15:00:17 <musasabi> usually if you have all the args use ($), if you have partial application use (.)
15:00:18 <Cale> but what if you don't have arg? You'll need a lambda
15:00:28 <davidhouse> ah. yeah, i see.
15:00:44 <Cale> I usually use a bunch of (.)'s and then one ($) at the end to apply the resulting function
15:01:08 <Cale> f . g . h $ x
15:02:52 * musasabi likes f $ g $ h x
15:03:00 <musasabi> it is a matter of style most of the time
15:03:17 <Cale> I suppose it depends on whether you're thinking more about the functions or the values.
15:07:45 <vincenz> @hoogle begin
15:07:46 <lambdabot> Graphics.UI.ObjectIO.StdKey.beginKey :: SpecialKey
15:07:46 <lambdabot> Graphics.Rendering.OpenGL.GL.BeginEnd.BeginsInteriorEdge :: EdgeFlag
15:07:46 <lambdabot> Graphics.Rendering.OpenGL.GL.BeginEnd.BeginsBoundaryEdge :: EdgeFlag
15:09:57 * vincenz grrs
15:13:56 <vincenz> typing doesn't like me
15:21:35 <musasabi> A
15:21:36 <Beelsebob> @where lambdabot
15:21:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:22:42 <vincenz> @type take
15:22:43 <lambdabot> forall a. Int -> [a] -> [a]
15:23:01 * Beelsebob tries to figure out lambdabot
15:23:51 <vincenz> at last
15:28:11 <SamK> do you get many circular references in haskell?
15:28:32 <musasabi> > let a = a in ()
15:28:33 <lambdabot> ()
15:28:46 <musasabi> they can be a good tool.
15:28:57 <musasabi> for infinite datastructures.
15:29:39 <SamK> do you have to go out of your way to get a circular dependency, or does it just happen using standard functions?
15:32:36 <SamK> musasabi: like the infinite list of all 1's [1,1,1,1...] ?
15:33:26 <SamK> one list element whos tail refers to itself
15:34:38 <SamK> > reverse ":/"
15:34:39 <lambdabot> "/:"
15:34:57 <Pseudonym> > reverse "naive"
15:34:59 <lambdabot> "evian"
15:35:23 <musasabi> let ones = 1 : ones in take 10 ones
15:35:32 <musasabi> > let ones = 1 : ones in take 10 ones
15:35:33 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
15:35:43 <musasabi> and so forth
15:36:54 <Pseudonym> > let pf (p:ps) = p : filter (\x -> x `mod` p /= 0) ps in take 20 (pf [2..])
15:36:55 <lambdabot> [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39]
15:37:40 <Pseudonym> > let g q r t k n l = if 4*q+r-t<n*t then shows n.g(10*q)(10*(r-n*t))t k(10*(3*q+r)`div`t-10*n)l else g(q*k)((2*q+r)*l)(t*l)(k+1)((q*(7*k+2)+r*l)`div`(t*l))(l+2)in g 1 0 1 1 3 3""
15:37:43 <lambdabot> "31415926535897932384626433832795028841971693993751058209749445923078164062
15:37:43 <lambdabot> 862089986280348253421170679821480865132823066470938446095505822317253594081
15:37:43 <lambdabot> 284811174502841027019385211055596446229489549303819644288109756659334461284
15:37:43 <lambdabot> 756482337867831652712019091456485669234603486104543266482133936072602491412
15:37:43 <lambdabot> 737245870066063155881748815209209628292540917153643678925903600113305305488
15:37:45 <lambdabot> [23 @more lines]
15:38:05 <Pseudonym> The cool part is that there are only 23 more lines.  Apparently this computation terminates.
15:41:35 <Lemmih> > repeat '1'
15:41:36 <lambdabot> "11111111111111111111111111111111111111111111111111111111111111111111111111
15:41:36 <lambdabot> 111111111111111111111111111111111111111111111111111111111111111111111111111
15:41:37 <lambdabot> 111111111111111111111111111111111111111111111111111111111111111111111111111
15:41:39 <lambdabot> 111111111111111111111111111111111111111111111111111111111111111111111111111
15:41:41 <lambdabot> 111111111111111111111111111111111111111111111111111111111111111111111111111
15:41:43 <lambdabot> [23 @more lines]
15:41:54 <dons>   yeah, it doesn't mean it terminates.
15:43:11 <Cale> There's an arbitrary cut off of how much it will read.
15:44:41 <SamK> i guess what i'm getting at is: would it be possible *in theory* to implement a haskell like language using reference counting, rather than gc? or is there some fundemental part of haskell that causes lots of cycles?
15:45:55 <Pseudonym> It is possible in theory to write a reference-counting GC which collects cycles.
15:46:16 <Pseudonym> The bookkeeping isn't as simple as one integer, but it can be kept to one word per object.
15:47:39 <musasabi> SamK: reference counting usually needs a GC to collect cycles in all languages
15:47:57 <musasabi> SamK: but why would you want that? reference counting is usually slower than GC
15:48:11 <ihope> @djinn a -> (a,a)
15:48:12 <lambdabot> f a = (a, a)
15:48:18 <ihope> @djinn a -> [a]
15:48:18 <lambdabot> -- f cannot be realized.
15:48:24 <ihope> Hmm.
15:48:34 <musasabi> ihope: djinn does not support lists.
15:49:10 <mq_mattr> can you tell ghci to set #defines
15:49:12 <mq_mattr> ?
15:49:27 <mq_mattr> I want to turn tracing on and off while in the one ghci session
15:49:43 <musasabi> mq_mattr: -DFLAG=Value
15:49:53 <musasabi> if you mean cpp flags.
15:50:12 <SamK> i probably wouldn't want refcounting. was just curious if it was possible (easier?) in a purely functional lazy language
15:51:42 <musasabi> I think there would be more cycles than in typical imperative languages, but not so many as to make it impossible. However given the style lazy functional languages are compiled it would probably kill any resemblance to good cache behavior.
15:52:25 <vincenz> @type interact
15:52:26 <lambdabot> (String -> String) -> IO ()
15:52:41 <SamK> right, I see. out of interest what is the main cause of "there would be more cycles than in typical imperative languages"?
15:53:49 <vincenz> how do I trace ghc code?
15:53:54 <vincenz> so that I can see where my code is hanging
15:54:02 <mq_mattr> break it down
15:54:07 <ihope> Debug.Trace.trace?
15:54:11 <ihope> Erm.
15:54:21 <ihope> @index trace
15:54:22 <lambdabot> Debug.Trace
15:54:25 <mq_mattr> rI don't think dtrace will work in this example
15:54:26 <vincenz> no more generic way?
15:54:35 <ihope> unsafePerformIO.
15:54:38 <mq_mattr> I had this problem last week
15:54:39 <vincenz> seriously
15:54:41 <vincenz> no ghc switch?
15:54:46 <musasabi> I think lazy evaluation makes it easy for the thunks to have cyclic references, but I may be wrong.
15:54:50 <mq_mattr> after stuffing around for a few days I went back to basics
15:54:53 <mq_mattr> and all was weel
15:54:55 <mq_mattr> well
15:55:00 <musasabi> hat
15:55:11 <mq_mattr> back to basics = run the smallest part of your code to see what that does
15:55:16 <mq_mattr> then run the next part
15:55:20 <mq_mattr> then the next part
15:55:26 <ihope> musasabi: if there weren't any cyclic references, Haskell wouldn't be Turing-complete.
15:55:27 <mq_mattr> until you find the bit that breaks
15:55:34 <mq_mattr> you need ghci/hugs for this
15:55:44 <musasabi> mq_mattr: most of us test all our small functions as we code.
15:56:00 <mq_mattr> I do the same, I even write HUnit test for them
15:56:27 <musasabi> (or we just develop an intuition for the relevant places to look)
15:56:32 <mq_mattr> but sometimes you write a function with comples subfunctions (let x = ... in x*x)
15:56:46 <musasabi> debugging Haskell is partly a black art.
15:57:05 <mq_mattr> I don't think it is a black art
15:57:33 <mq_mattr> I just don't think the people who know how to do it take the time to explain it to those who don't (in which I count myself)
15:58:05 <mq_mattr> debuggins c *seemed* like magic when I started out, but I had unii professors to explain it to me
15:58:10 <mq_mattr> now it is obvious
15:58:21 <mq_mattr> gradually I am picking up the same with Haskell
15:58:28 <musasabi> well debugging C is much more easier
15:58:34 <mq_mattr> it is different, but not necessarily harder
15:58:48 <ihope> I'd like a safe way of debugging.
15:58:59 <mq_mattr> hat looks cool
15:59:10 <mq_mattr> but I could not get it to compile/run on my machine
15:59:14 <mq_mattr> :(
15:59:37 <mq_mattr> It actually looks really nice, talking about it makes me think of taking another crack and getting it installed
15:59:49 <musasabi> e.g. errors in concurrent Haskell programs that result in a Loop-exception or a segfault can be quite frustrating.
15:59:59 <mq_mattr> anyone else in Sydney heading off to see Philip Wadler today?
16:00:12 <mq_mattr> yesterday's talk at Macquarie was very interesting
16:00:27 <ihope> @djinn a -> IO a
16:00:27 <lambdabot> -- f cannot be realized.
16:00:34 <ihope> @djinn a -> Maybe a
16:00:35 <lambdabot> f = Just
16:00:39 <mq_mattr> musasabi: errors in concurrent anything can be quite frustrating
16:00:45 <musasabi> because usually every piece of code works when tested in separation and sometimes even debugging prints don't help any
16:01:39 <Pseudonym> I saw Wadler last week when he was at unimelb.
16:01:40 <musasabi> one of my favorites was a bug in the random number generator code used that caused it to loop with a combination of IO and STM
16:01:44 <Pseudonym> Great talk.
16:01:46 <Pseudonym> Definitely go.
16:02:05 <Pseudonym> Is he doing the Curry-Howard thing or the links thing today?
16:02:12 <mq_mattr> today is links
16:02:17 <vincenz> for some reason my parser is mucking up
16:02:22 <mq_mattr> which I am really looking forward to
16:02:26 <musasabi> of course the real bug was in pure code, but it passed the tests fine.
16:02:30 <mq_mattr> I had already read the curry/howard paper
16:02:41 <mq_mattr> but I am a bit in the dark about links
16:03:14 <mq_mattr> I think Barry Jay at UTS is particularly interested as he want the pattern calculus to do something similar to links
16:03:24 <TuringTest> musasabi: I found STM very tricky to combine with inter-thread communication
16:04:01 <Pseudonym> The most interesting thing that I got from Wadler's talk was that there is no Curry-Howard-like logic for concurrency.
16:04:16 <mq_mattr> ihop: The upshot of all this is 1) try the basics 2)try hat 3)try Debug.Trace
16:04:26 <Pseudonym> This strongly suggests that current formalisms for concurrency aren't "natural" in the same way that typed lambda calculus is.
16:05:05 <mq_mattr> yeah - I have never had a particular interest in concurrency, but I know enough to know that it _feels_ half-baked in all the incarnations I have seen it
16:06:08 <TuringTest> mq_mattr: Even STM is still only half-baked.  But I think it is because it is new.  I think it will improve.
16:07:12 <mq_mattr> What we got from Wadler (and I have heard from others I respect) is that there is something seriously wonderful about the simplicity of the lambda-calc
16:07:15 <TuringTest> (For instance: you currently can't get MVar wakeup sematics with STM)
16:07:25 <mq_mattr> and that is is just *so obvious* in retrospect.
16:07:39 <mq_mattr> I don't think any concurrency systems can say this.
16:08:01 <mq_mattr> It is one of those elegance things
16:09:09 <mq_mattr> I loved the way Wadler presented the lambda-calc.  When I was first learning it, all the texts/papers would quickly go to the detail.
16:09:16 <ihope> Hmm. According to this, Python is the world's best programming language...
16:09:26 * ihope steals all its best ideas and sticks them into Haskell
16:09:52 <tromp> how did wadler avoid details?
16:09:54 <mq_mattr> The detail is complex and thus it obscures the beauty of the calculus, seeing the beauty first is really useful
16:10:11 <mq_mattr> He just presented why it is great, how it is universal and all that
16:10:27 <mq_mattr> nothing about free varaibles, variable capture
16:10:36 <mq_mattr> no real-world examples that will break
16:10:43 <mq_mattr> without complex detail
16:10:53 <mq_mattr> he talked about fix but did not show it
16:11:12 <mauke> Python has really cool features, like indentation-based code blocks and list comprehensions!
16:11:16 <mq_mattr> I think that is the best indication of his approach - talk about fix, but don't show it 0
16:11:19 <Pseudonym> Python got all its best ideas from functional languages, duh
16:11:37 <Pseudonym> Scheme, mostly.
16:11:40 <tromp> good to hear everybody got their fix:)
16:12:02 <mq_mattr> python is a harbinger of languages to come - less about "mine is better than yours" and more about just getting good features into programmer's hands
16:12:16 <sebell> Pseudonym: What Scheme features exactly?
16:12:20 <Pseudonym> Except that the plan is to take the good features out.
16:12:26 <mq_mattr> but of course, all pl discussions eventually degenerate to "mine is better than yours"
16:12:38 <Pseudonym> sebell: Scheme is a clean dynamically typed Lisp-like language.
16:12:45 <mq_mattr> pseu: hehe :)
16:13:13 <Pseudonym> So pretty much all of the more functional parts (map/filter etc) are based on Scheme's formulations rather than Haskell's.
16:13:13 <sebell> Pseudonym: I know what it is
16:13:36 <Pseudonym> Yeah, I know you do.  It was just the context for my main point.
16:13:50 <mq_mattr> pseu: I agree - what haskell brought to the world is not in Python
16:13:56 <Pseudonym> Right
16:14:07 <Pseudonym> Though Python did get its list comprehensions direct from Haskell.
16:14:16 <Pseudonym> Though Haskell did not invent them.
16:14:20 <mq_mattr> ahh! I stand corrected
16:14:28 <Pseudonym> They date back to KRC, I believe.
16:14:29 <mq_mattr> kinda :)
16:14:44 <sebell> Pseudonym: I would describe map and filter as being more generally Lisp (IE: family of Lisp languages) like features
16:14:52 <Pseudonym> Right.
16:15:13 <TuringTest> And weird infix operators?  Where did they descend from?
16:15:21 <Pseudonym> Prolog.
16:15:24 <mq_mattr> C++!!!!
16:15:29 <mq_mattr> :)
16:15:43 <TuringTest> mq_mattr: nope.  You cannot invent >||<* as an operator in C++
16:15:52 <Pseudonym> But you can in Prolog!
16:16:00 <TuringTest> So i have just learned
16:16:10 <mq_mattr> I know - I am just being silly - you can do all kinds of things with macros though
16:16:26 <Pseudonym> In Edinburgh Prolog, you can even define so many operators that you need a global backtracking parser.
16:16:39 <Pseudonym> ISO Prolog only requires an operator precedence parser.
16:16:52 <TuringTest> Whee....Haskell #2 is up on http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
16:17:22 <TuringTest> That was the last missing piece on the shootout.
16:17:23 <Pseudonym> One Edinburgh-like Prolog implementation that I used once had the helpful error message: "Your program contains one or more syntax errors."
16:17:25 <vincenz> @type join
16:17:26 <lambdabot> Not in scope: `join'
16:17:29 <vincenz> @hoogle join
16:17:30 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
16:17:30 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
16:17:30 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
16:17:35 <vincenz> @hoogle lift
16:17:36 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
16:17:36 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
16:17:36 <lambdabot> a
16:17:36 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
16:17:46 <vincenz> @hoogle [m a] -> m [a]
16:17:47 <lambdabot> Data.List.head :: [a] -> a
16:17:47 <lambdabot> Data.List.last :: [a] -> a
16:17:47 <lambdabot> Prelude.head :: [a] -> a
16:17:50 <ihope> Pseudonym: Haskell has lexical errors, aye?
16:17:55 <vincenz> @hoogle Monad m => [m a] -> m [a]
16:17:56 <lambdabot> No matches, try a more general search
16:18:00 <vincenz> @hoogle liftM
16:18:01 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
16:18:01 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
16:18:01 <lambdabot> r
16:18:01 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -
16:18:01 <lambdabot> > m a3 -> m r
16:18:04 <vincenz> grr
16:18:08 <Pseudonym> ihope: Sure.
16:18:16 <Pseudonym> > foobar
16:18:17 <lambdabot>  lexical error
16:18:23 <Pseudonym> There's one of them now.
16:18:26 <vincenz> @hoogle Monad m => [m a] -> m [a]
16:18:27 <lambdabot> No matches, try a more general search
16:18:30 <ihope> Hmm...
16:18:33 <vincenz> @hoogle mapM
16:18:34 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:18:34 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:18:34 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:18:42 <vincenz> @hoogle sequence
16:18:43 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
16:18:43 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
16:18:43 <lambdabot> Control.Monad.sequence_ :: Monad m => [m a] -> m ()
16:18:51 <ihope> > ?
16:18:51 <lambdabot>  parse error on input `?'
16:18:57 <ihope> Hmm.
16:19:02 <ihope> >
16:19:05 <Pseudonym> I believe that ? is a valid kind.
16:19:13 <Pseudonym> In GHC, anyway.
16:19:18 <vincenz> > sequence [Just 1, Just 2, Nothing]
16:19:19 <lambdabot> Nothing
16:19:20 <ihope> > 3 :: Integer :: *
16:19:21 <lambdabot>  parse error on input `::'
16:19:23 <vincenz> grr
16:19:25 <ihope> > 3 :: (Integer :: *)
16:19:26 <lambdabot>  parse error on input `*'
16:20:01 * vincenz is stuck with a recursive monad issue
16:20:25 <TuringTest> vincenz: Yes?
16:20:41 <vincenz> ok my monad internall is = Either String a
16:20:47 <vincenz> scanner str = runCxxLex str $ loop 
16:20:47 <vincenz>   where loop = do
16:20:47 <vincenz>                   tok <- cxxLexMonadScan
16:20:47 <vincenz>                   case tok of 
16:20:47 <vincenz>                     CxxEOF      -> [CxxEOF]
16:20:50 <vincenz>                     CxxError _  -> [tok]
16:20:52 <vincenz>                     _           -> tok:loop
16:20:55 <vincenz> how do I return a list
16:21:00 <ihope> return?
16:21:01 <vincenz> of tokens up until CxxEof
16:21:09 <vincenz> or error
16:21:12 <ihope> ...Hmm...
16:21:14 <vincenz> (which should actually become a fiail
16:21:20 <TuringTest> vincenz: can you use paste.lisp.org ?
16:21:23 <vincenz> sorry
16:21:41 <vincenz> runCxxLex        :: String -> CxxLex a -> Either String a
16:21:43 <ihope> @type maybe
16:21:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:22:18 <ihope> @type maybe (fail "Nothing) return
16:22:19 <lambdabot> lexical error in string/character literal
16:22:22 <ihope> @type maybe (fail "Nothing") return
16:22:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
16:22:26 <ihope> Yay!
16:22:29 <vincenz> basically I want to sequence some parse actions that should return once I hit a certain token
16:22:34 <vincenz> aka, eof
16:22:48 <Cale> fail is evil though
16:23:34 <TuringTest> vincenz: And so you are looking to Maybe for inspiration.
16:23:40 <vincenz> TuringTest: nono, that is fixed
16:23:42 <Cale> use throwError
16:23:51 <ihope> @type throwError
16:23:52 <lambdabot> Not in scope: `throwError'
16:23:54 <TuringTest> Or a continuation monad
16:23:59 <ihope> @index throwError
16:23:59 <lambdabot> Control.Monad.Error
16:24:00 <vincenz> nope
16:24:02 <Cale> @type Control.Monad.Error.throwError
16:24:03 <lambdabot> forall e (m :: * -> *) a.
16:24:03 <lambdabot> (Control.Monad.Error.MonadError e m) =>
16:24:03 <lambdabot> e -> m a
16:24:23 <ihope> Um...
16:24:25 <Cale> Error e => MonadError e (Either e)
16:24:25 <Pseudonym> BBL
16:24:37 <ihope> fail isn't VERY evil.
16:24:47 <Cale> It is pretty evil :)
16:24:52 <ihope> Yeah.
16:25:11 <ihope> Eh.
16:25:38 <ihope> (maybe (error "Nothing") return)?
16:25:56 <TuringTest> vincenz: http://haskell.org/hawiki/MonadError 
16:26:01 <TuringTest> ?
16:26:08 <vincenz> I have monads set up
16:26:15 <vincenz> a monad that will parse one token
16:26:19 <vincenz> and return Either string a
16:26:46 <TuringTest> And so "Left string" is an error that aborts...and...
16:26:51 <TuringTest> ... Right a is a token
16:26:52 <vincenz> yes
16:27:01 <vincenz> but now I want to do a list of tokens until I hit CxxEOF token
16:27:01 <TuringTest> But you want a special aborting token
16:27:07 <TuringTest> ah
16:27:13 <TuringTest> Like a Writer
16:27:13 <vincenz> which != fail
16:27:15 <vincenz> cause fail = error
16:27:19 <dons> @shootout -- TuringTest, did you see the results?
16:27:19 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
16:27:19 <lambdabot> all
16:27:24 <TuringTest> dons: :)
16:27:38 <dons> so close! :}
16:27:40 <TuringTest> 0.13 behind C
16:27:41 <ihope> Whoa. Is (Cont . const) really my own invention?
16:27:45 <vincenz> and preferably this would be a monad as well instead of a list of tokens perse
16:28:02 <dons> yeah, I thought we'd get them, actually. oh well.
16:28:27 <vincenz> so : runCxxLex :: (String -> CxxLex a -> Either String a)  and I want to use this so I can do str -> Either String m a
16:28:34 <vincenz> so : runCxxLex :: (String -> CxxLex a -> Either String a)  and I want to use this so I can do str -> Either String (m a)
16:28:44 <TuringTest> dons: For 0.13 ... eh  It may be possible to squeeze that out of all the entries.  But not worth the effort.
16:29:38 <dons> yeah, I might look at speeding up something. but then again, they just  need to work out how to do concurrency in C, and we're doomed :)
16:29:51 <vincenz> http://rafb.net/paste/results/QnomLm16.html
16:29:55 <vincenz> this is the bottom part of alex
16:29:58 <vincenz> of my alex file
16:30:07 <vincenz> it's basically like wrapper alex
16:30:12 <dons> maybe we just wait for packed strings, and then win with all those lines of code points
16:30:15 <ihope> Has anybody made a "while" loop in the Cont monad?
16:30:15 <vincenz> except I allow a stack of unprocessed stuff when I go in a substate
16:30:32 <TuringTest> dons: Beating hand coded c is essentially impossible.  But waiting for GHC 6.6 is good strategy
16:30:38 <vincenz> scanner should be : (Monad m) => String -> Either String (m a)
16:30:54 <dons> well, we win with our abstractions. our lines of code.
16:31:11 <dons> speed, yes. we can't win there. we're compiling via C after all.
16:31:25 <dons> (except where the abstractions are sufficiently clever enough -- i.e. MVars)
16:31:40 <Beelsebob> dons: you're implying that C coders are better at writing C than ghc
16:31:44 <TuringTest> dons: You say "our" as if I were going to spend yet more time on it.  I think I have to back off.
16:31:52 <Beelsebob> which I'm not sure is a valid statement
16:31:57 <dons> Beelsebob, well, potentially better ;)
16:32:03 <Beelsebob> *g*
16:32:10 <Igloo> GHC is pretty bad at writing the sort of C that matters for benchmarks
16:32:11 <TuringTest> Beelsebob: They could always take the ghc output and hand tune it.
16:32:15 <vincenz> TuringTest: any suggestion?
16:32:28 <dons> Igloo, surprisingly good for the partial-sums test though.
16:32:28 <TuringTest> vincenz: Uh...no.  Alex is greek to me.
16:32:31 <Beelsebob> TuringTest: I'd love to see you do that
16:32:40 <dons> hehe.
16:32:43 <ihope> @index Nat
16:32:43 <lambdabot> bzzt
16:32:44 <TuringTest> Beelsebob: I would love to have time to do it.
16:32:44 <vincenz> TuringTest: it's not alex specific
16:33:00 <TuringTest> vincenz: sorry I am on two threads here....I will look at it again.
16:33:09 <Beelsebob> dons: how long does lambdabot usually take to build?
16:33:42 <Beelsebob> at the moment it seems to be building Djinn.hs
16:33:49 <Beelsebob> oh... and now it's died :(
16:34:18 <Beelsebob> dons: Could not find module `System.Console.Shell': use -v to see a list of the files searched for (imported from ./LambdaShell.hs)
16:34:21 <TuringTest> vincenz: The current monad is CxxLex .  and CxxLex a = CxxLexState -> Either String (CxxLexState, a) 
16:34:36 <vincenz> correct
16:34:55 <TuringTest> Where "a" is a single token type
16:34:59 * vincenz nods
16:34:59 <TuringTest> And you want [a]
16:35:02 <vincenz> right :)
16:35:23 <TuringTest> If there is a Left "string" error then you do not get any "a"
16:35:27 <TuringTest> is that true?
16:35:28 * vincenz nods
16:35:33 <musasabi> Actually beating C should be quite easy given suitable libraries, as if we are 2*X slower and have X/3 loc we still win.
16:35:33 <vincenz> basically error during parsing
16:35:36 <vincenz> errr lexing
16:35:53 * TuringTest looks up the answer in the big book of monads.
16:36:15 <vincenz> would be even nicer if it was (m a) for any monad so I can couple it with my parser instead of lexing it all into memory first
16:36:37 <TuringTest> vincenz: one thing at a time!
16:36:40 <vincenz> oki
16:36:50 <dons> Beelsebob, hmm, 30 seconds with the new -fasm flags?  
16:37:01 <Beelsebob> :o
16:37:03 <dons> you need to install Shellac, if you want the @lam plugin
16:37:18 <Beelsebob> ah, okay... how do I tell it to not bother building it?
16:37:38 <dons> oh, you could comment it out in the Makefile. that's the only way.
16:38:04 <Beelsebob> which directory?
16:38:05 <dons> the line right at the bottom about "lambda:"
16:38:12 <dons> Makefile, top level
16:38:14 <TuringTest> vincenz:  monad transformers may help here
16:38:19 <vincenz> ok
16:38:28 <Beelsebob> ah, cool :)
16:38:32 <dons> and remove "lambda" as a dep: all: lambdabot modules runplugs djinn lambda
16:38:40 <dons> in that code ^^^
16:38:58 <Beelsebob> yep, makes sense
16:39:12 <ihope> Hmm..
16:39:18 <ihope> s/../.../
16:39:28 <dons> musasabi, agreed. we'd hvae done it if the lazy regex combinators were distributed with parsec..
16:39:32 <ihope> @type \x -> let g = x g in g
16:39:33 <Beelsebob> :o
16:39:34 <lambdabot> forall t. (t -> t) -> t
16:39:36 <Beelsebob> MiniBob-tatd2:~/lambdabot tatd2$ ./lambdabot 
16:39:36 <Beelsebob> lambdabot: 
16:39:37 <Beelsebob> lambdabot: user error (resolvedObjs failed.)
16:39:41 <ihope> It's... it's...
16:39:42 <vincenz> @hoogle lift
16:39:43 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
16:39:43 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
16:39:43 <lambdabot> a
16:39:43 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
16:39:47 <Beelsebob> huh...
16:39:55 <dons> hmm
16:39:58 <Beelsebob>  /usr/local/lib/fps-0.1/ghc-6.4.1/HSfps-0.1.o: unknown symbol `_GHCziIOBase_returnIO_closure'
16:40:02 <Beelsebob> that got lost
16:40:08 <Beelsebob> as a command
16:40:10 <TuringTest> hmmm... WriterT a (Error string () ) looks promising
16:40:30 <ihope> @pl \x -> fix (\y -> map ($ y) x)
16:40:31 <lambdabot> fix . flip (map . flip id)
16:40:43 <TuringTest> vincenz: runError (runWriterT bar)  has the right return type
16:40:50 <dons> weird. you could build it 'static' just to get it working.
16:40:51 <ihope> @type fix . flip (map . flip id)
16:40:51 <lambdabot> Not in scope: `fix'
16:40:56 <TuringTest> vincenz: I will code up a toy example
16:40:57 <dons> you'll have to make distclean and start over
16:41:01 <ihope> Grr. Why isn't that in the Prelude?
16:41:03 <Beelsebob> hmm, I could
16:41:08 <ihope> @type Control.Monad.Fix.fix . flip (map . flip id)
16:41:09 <lambdabot> forall c. [[c] -> c] -> [c]
16:41:22 <dons> and then make static=yes
16:42:03 <ihope> > (Control.Monad.Fix.fix . flip (map . flip id)) [head]
16:42:04 <lambdabot> Add a type signature
16:42:13 <ihope> > (Control.Monad.Fix.fix . flip (map . flip id)) [head] :: ()
16:42:14 <lambdabot> Couldn't match `()' against `[c]'
16:42:19 <ihope> > (Control.Monad.Fix.fix . flip (map . flip id)) [head] :: [()]
16:42:20 <lambdabot> Exception: <<loop>>
16:43:50 <vincenz> TuringTest: thx ;)
16:44:01 <TuringTest> vincenz: ...one more minute
16:48:39 * vincenz crosses his finges
16:50:26 <lisppaste2> TuringTest pasted "For vincenze" at http://paste.lisp.org/display/16567
16:50:44 <TuringTest> It is my idea, I am not sure it will help
16:51:03 <TuringTest> It has the right semantics for what you talked about.
16:51:10 <vincenz> thx
16:51:29 <dcoutts> vincenz, glad to see your gui bots stuff is working out. I'm still hoping for a mini-writup for the gtk2hs web site - with screenshots!
16:51:31 <TuringTest> The etest  and etest2 parts are just Either String a
16:51:37 <vincenz> dcoutts: oh right
16:51:44 <dcoutts> :-)
16:51:55 <vincenz> TuringTest: yes, the only problem is that the thingy returning an Either String a is a runMonad that automatically sets the start state
16:52:07 <dons> TuringTest, I'm going to cabalise the lazy regex module, hopefully I can get it into Text.ParserCombinators -- it's more than a decade old, and has a paper written on it, so it's a suitable candidate  ;)
16:52:18 <TuringTest> dons: That would be really cool
16:52:50 <dons> we have alex and happy, we should have lazy lexers and parsec, to balance things.
16:52:54 <TuringTest> dons: Can you make a "a.*b+[foo]" interpreter for it using the lexer itself?
16:53:13 <dons> yeah, I reckon that would be a good interface, as well as the combinator style
16:53:28 <TuringTest> dons: (Or you could have the interpreter that I wrote in parsec)
16:53:28 <dons> maybe a TH expander?
16:53:37 <TuringTest> dons: One thing at a time
16:53:43 <dons> so $(run "a.*b") expands...
16:53:57 <dons> ah well, that'd  be fun though.
16:54:01 <TuringTest> dons: That would be cool and Jregex does that
16:54:12 <dons> ah, yeah, I should loook at that.
16:54:18 <TuringTest> But runtime interpreting first, compile time interpreting second
16:54:38 <dons> yeah yeah ;)
16:54:45 <musasabi> well given a "compile :: Monad m => String -> m RegEx" $run would be trivial to write.
16:54:45 <TuringTest> dons: It calls the regex c library from TH to compile the regex to binary -- at compile time.
16:55:01 <TuringTest> A bit sick
16:55:10 <dons> and then we can stick it in a "foo"# string.
16:55:17 <vincenz> maybe I should inverse my monads
16:55:27 <dons> musasabi, exactly. I wrote such a thing for printfs, and it's pretty easy
16:55:28 <TuringTest> vincenz: And reverse the polarity
16:56:01 <TuringTest> vincenz: If you reverse my monads then the semantics change.  They do not trivially commute
16:56:46 <TuringTest> dons: I looked at the paper behind the lazy lexer tonight -- it does not entertain the idea of non-greedy matching.
16:57:31 * vincenz scratches his head
16:57:43 <dons> anything is possible, the author is my supervisor, so I can hassle him about it :)
16:58:21 <TuringTest> dons: then what about "[^baz]" patterns?  If you make an array, it is the size of unicode!
16:58:39 <TuringTest> (unless you cut down to ascii like you did)
16:59:01 <dons> ah, but a _lazy_- array
16:59:08 <dons> so its not all constructed
16:59:25 <TuringTest> But isn't the space reserved? Hmm...
16:59:51 <TuringTest> I suspect there should be a "small list" "medium array" "huge map" approach
17:00:03 <dons> the best way would be to match baz, and then tie a handler to the non-match error case.
17:00:26 <TuringTest> dons: It would not merge with >|< properly
17:00:28 <dons> there's many ways to program this, so I guess that's why it hasn't been a problem.
17:00:39 * TuringTest shrugs
17:01:04 <TuringTest> I only read the paper tonight, and I'm a physicist.  So it is not obvious to me.
17:01:09 <dons> yeah, it's a good point. i haven't thooght hard about it yet. i'm planning on reimplementing it from scratch, as the lib uses some old-style pre-h98 code
17:02:05 <TuringTest> dons: I also suspect that non-greedy matching is not isomorphic to a  DFA table.  But I have not looked up the answer to that.
17:02:25 <dons> yeah, i'm not sure either 
17:02:44 <vincenz> @type lift
17:02:45 <lambdabot> Not in scope: `lift'
17:02:48 <dons> been ages since i studied the dragon book.
17:02:48 <vincenz> @hoogle lift
17:02:49 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
17:02:49 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
17:02:49 <lambdabot> a
17:02:49 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
17:02:54 <TuringTest> @type Control.Trans.lift
17:02:55 <lambdabot> Couldn't find qualified module.
17:02:55 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
17:02:55 <lambdabot> \\)?
17:03:08 <TuringTest> @type Control.Monad.Trans.lift
17:03:09 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
17:03:09 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
17:03:09 <lambdabot> m a -> t m a
17:03:14 <vincenz> yeah I think my monads are setup the wrong way
17:03:32 <TuringTest> vincenz: Should I switch me monads in the example code?
17:03:40 <TuringTest> s/me/my/
17:03:45 <vincenz> TuringTest: I'm still trying to figure out how they're setup in m code
17:03:52 <vincenz> the core issue is runCxxLex
17:04:05 <TuringTest> Right...which I did not bother to study very hard.
17:04:19 <vincenz> basically it invokes a monad of CxxLex a with a start state
17:04:38 <vincenz> to return the Either String a
17:04:59 <vincenz> so I guess the func I pass to it should already return [a]
17:05:27 * vincenz wants lazy lexing with backtracking
17:05:31 <vincenz> I guess it's too much to ask
17:05:43 <vincenz> :D
17:07:53 <TuringTest> dons: I have not read any compiler books.  But the simple regex engine Alson wrote runs in 35s versus you 25s and my front end lets it work on greedy and non-greedy regular expressions.
17:08:35 <dons> ah, right.
17:09:03 <dons> yeah, maybe a traditional pure haskell regex lib would be very useful
17:09:08 <TuringTest> dons: It depends on non-deterministic binary-Or that is left-biased.  With fix-point cycles it can handle greedy * and non-greedy * depending on whether the right or left branch has the cycle
17:09:23 <TuringTest> (That was my addition)
17:09:32 * vincenz gets it to work nonlazily
17:09:35 <vincenz> I'll think about it some more
17:09:41 <TuringTest> vincenz: ok
17:09:45 <vincenz> thx for the help
17:10:20 <TuringTest> dons: And I have not put it on the wiki, but my last version could handle "a{3,5}b{4}?c{5,}" patterns
17:10:55 <TuringTest> But it is not as state-clever as the lazy lexer.  It is really really just for regexp.
17:11:52 <dons> ah right. threading state is really powerful.  
17:12:47 <TuringTest> dons: But parsec is already is a combinator library with state.  The lazy lexer is strictly less expressive, but has the lazy DFA table generation for speed.
17:13:35 <TuringTest> What we really need is a replacement for Text.Regex -- not everyone will be able to use a future fast-packed string version.
17:13:46 <dons> sure. i'm not suggesting we replace parsec ;) this is really tuned for lexing. 
17:13:57 <dons> and yes, regexes suck atm, we need something better.
17:14:30 <TuringTest> So we need (1) FPS for new Text.Regex bindings with fast marshalling
17:14:52 <TuringTest> (2) The combinator lazy lexer that runs very fast 
17:14:58 <dons> I added these two points to the regex-dna page :)
17:15:09 <dons>   * we add a Word8 interface to the existing Text.Regex
17:15:15 <TuringTest> (3) Something that can process regex for non-FPS, such as the Alson entry I built up
17:15:19 <dons>   * we add the lazy regex combinators to the Text.ParserCombinators suite
17:15:44 <dons> and 3. yes, good, pure Haskell regexes
17:16:02 <TuringTest> unless (1) is good for (3), which I suspect is not the case.
17:16:22 <dons> no, I'd suspect 2) is good for 3), but maybe it's limited as you poinnt out
17:16:30 <TuringTest> I also made the "all parsec entry" but the Alson engine is better tuned for simple regex
17:18:58 <TuringTest> dons: Haskell should have one library for every computational plateau.
17:19:15 <Philippa> a first-order fragment of Parsec would be worth looking at
17:19:28 <Philippa> as IIRC first-order Parsec ~= PEGs, as in packrat parsing
17:19:40 <Philippa> but... what the hell, everybody's caught up on regexes ;-)
17:20:19 <dons> TuringTest: Haskell should have one library for every problem in the language shootout ;)
17:20:28 <TuringTest> dons: No
17:20:31 <TuringTest> dons:  Isn't the lazy lexer from the compiler toolkit light?
17:20:32 <dons> hehehe
17:20:38 <dons> yep
17:21:19 <TuringTest> dons: It has the lazy parser in it, as well.  That looked much more like parsec's interface, of course.
17:21:56 <dons> yeah, it's superseded by parsec, but the lexer combinators still stand up, I think.
17:22:36 <TuringTest> dons: stands up in the shooutout at least
17:22:59 <dons> no no, I mean in general, i've  used it in a number of projects, and find it simple and elegant
17:23:09 <dons> but it isn't maintained, so people don't know about it.
17:23:31 <dons> yi uses it all over the place, it's critical to the keystroke handler
17:23:32 <TuringTest> dons: I noticed that the Action and Meta were separate in the paper and merged in your code
17:24:10 <TuringTest> dons: Oh..I forgot to ask.  What the heck was the bug that count' was working around?
17:24:38 <TuringTest> (asking you is much easier than reproducing the bug here)
17:25:10 <dons> oh, it's weird. one particular pattern was returning a slightly wrong count when folded into the the larger set of variants. but if I run it over the input on its own, it adds up correctly
17:25:21 <dons> and if i take out some of the other regexes, it also works
17:25:24 <TuringTest> dons: That is a bad sign.
17:25:38 <dons> so maybe I introduced a bug somewhere, to do with the sparse/dense boundary, I think.
17:25:48 <dons> or maybe there's always been a bug
17:26:09 <TuringTest> dons: You could crank up the sparse tolerance to 1024 and it would not trigger?
17:26:22 <dons> yeah, that's my theory, i haven't tested it yet.
17:27:12 <dons> it only turns up on the 5M input file, not on the 100k one.
17:27:43 <TuringTest> dons: Also...the IntMap....is the insertWith (+) strict ?
17:28:10 <TuringTest> dons: For only a few hundred hits like the shootout it does not matter
17:28:17 <dons> ah, not sure. that could be a src of the leak.
17:28:26 <dons> but as you say, it doesn't matter.
17:28:48 <dons> anyway, I hacked the state to be moomorphic,. in the original library that's a parameter
17:28:49 <TuringTest> dons: Try a DiffUArray
17:29:41 <TuringTest> You have a small bounded range of keys and that way it has to be strict
17:29:49 <TuringTest> (I think)
17:30:26 <dons> oh well, modifying the denseMin cutoff doesn't help. i'll have to quick check it.
17:30:53 <dons> anyway, it runs ok on the shootout, so i'm ok with it for now.
17:31:27 <TuringTest> dons: At least you have a test case
17:34:30 * TuringTest waves goodnight
17:35:40 <dons> night
17:38:50 <olliej> does anyone know whether GHC.Prim.and# performs logical or bitwise and?
17:39:24 <dons> hmm, you'll have to chec the code gen. I think it generates a bitwise and op
17:39:41 <olliej> dons: cheers
17:39:47 <olliej> i'm think bitwise as well
17:40:41 <dons> you can write a program, and compile ti via C, then peruse the output. i.e. 0xdeadbeef `and#` 1, and see what is generated with -keep-tmp-files 
17:41:21 <olliej> true
17:41:23 <dons> ah, cmm/ says:
17:41:25 <dons>   -- Bitwise operations.  Not all of these may be supported at all sizes,
17:41:25 <dons>   -- and only integral MachReps are valid.
17:41:26 <dons>   | MO_And   MachRep
17:41:50 <dons> CmmParse.y:     | expr '&' expr                 { mkMachOp MO_And [$1,$3] }
17:42:00 <dons> PprC.hs:        MO_And          _ -> char '&'
17:45:45 <olliej> dons: cheers
17:46:02 <olliej> i'd just done the see what it outputs approach :)
17:49:31 <Beelsebob> :o
17:49:39 <Beelsebob> lambdabot engages in watersports!
17:52:25 <Beelsebob> dons: you cheeky git!
17:52:45 <dons> not me. blame blackdog.
17:52:51 <Beelsebob> oh, okay
17:53:04 <Beelsebob> it ways "logicbot: i'm the type of girl that finds Don Knotts very sexy" that I was surprised by
17:53:24 <dons> check lambdabot/Plugins/Vixen/VixenState.hs
17:53:32 <Beelsebob> hehe, okay
17:59:31 <pasky> is there a function which takes x and returns [x] ?
17:59:38 <pasky> (prelude function)
17:59:57 <dons> musasabi, I have a faster partial-sums (should be around the speed of C again): http://www.haskell.org/hawiki/PartialSumsEntry
18:00:26 <dj_cristian> HOLASSSSS
18:00:39 <dj_cristian> ALGUIEN Q HABLE ESPAOL
18:03:04 <wilx> @hoogle x -> [x]
18:03:05 <lambdabot> Data.List.repeat :: a -> [a]
18:03:05 <lambdabot> Prelude.repeat :: a -> [a]
18:03:05 <lambdabot> Data.List.replicate :: Int -> a -> [a]
18:03:21 <arjanb> pasky: no but you can use either (:[]) or \x -> [x]
18:04:18 <Lemmih> > return () :: [()]
18:04:19 <lambdabot> [()]
18:04:27 <dons> return in the list monad.
18:05:00 <dons> but perhaps that is getting a bit obscure.
18:05:09 <dons> I usually use (:[]) for this kind of thing
18:06:56 <pasky> arjanb: yes I did the latter.. the former looks funny but it's clever :)
18:07:17 <pasky> thanks
18:08:09 <Cale> It's always good to consider the list monad when manipulating lists though, since it's often the simplest way to do a lot of things.
18:08:14 <dons> not as funny as ($[]) ;)
18:08:17 <Cale> hehe
18:08:30 * pasky didn't get to monads yet ;)
18:08:48 <pasky> I mean I use them for I/O but with no real clue what's going on
18:09:08 <Cale> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) }
18:09:09 <lambdabot> [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:09:12 <mauke> @type ($ [])
18:09:13 <lambdabot> forall a b. ([a] -> b) -> b
18:09:30 <pasky> monads look way too imperative
18:09:41 <Cale> pasky: well, do-notation looks imperative
18:09:49 <Cale> they're actually really functional :)
18:09:56 <dons> ($[]) is used in differencee lists (O(1) append, I used them yesterday, in fact)
18:10:04 <Cale> do-notation translates into a bunch of uses of >>=
18:10:09 <Cale> @type (>>=)
18:10:10 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:10:14 <dons> closeDL :: DList a -> [a]
18:10:15 <dons> closeDL  = ($[])
18:10:20 <dons> snocDL      :: DList a -> a -> DList a
18:10:21 <dons> snocDL dl x  = \l -> dl (x:l)
18:10:26 <dons> zeroDL :: DList a
18:10:27 <dons> zeroDL  = id
18:10:35 <dons> type DList a = [a] -> [a]
18:10:37 <Chinju> hey
18:10:44 <dons> joinDL :: DList a -> DList a -> DList a
18:10:45 <dons> joinDL  = (.)
18:10:59 <Cale> Chinju: hello
18:11:06 <Chinju> I have a question about a small Haskell point
18:11:20 <Chinju> specifically, an area where Hugs and GHC seem to disagree
18:11:23 <Chinju> and I'm curious what the proper thing is
18:11:23 <Cale> okay
18:11:31 <Cale> what is it? :)
18:11:38 <Chinju> if I do "newtype (Eq a) => Blah a = mkBlah a"
18:11:45 <Chinju> what should the type of mkBlah be?
18:12:13 <Cale> That should give an error, mkBlah needs to be capitalised
18:12:17 <Chinju> oh, yes, sorry
18:12:20 <Chinju> that's what I mean
18:12:20 <Chinju> *meant
18:12:38 <Cale> and then it should have type (Eq a) => a -> Blah a
18:12:43 <Chinju> yes, that's what Hugs gives
18:12:47 <Chinju> but GHC seems to drop the (Eq a) constraint
18:12:52 <Cale> I would think, anyway
18:12:56 <Cale> hmm
18:12:58 <Chinju> yes, that's what I would think too
18:12:58 <Lemmih> That's the right thing too.
18:13:01 <Chinju> when GHC didn't do it
18:13:02 <Chinju> I got confused
18:13:04 <Chinju> and tried Hugs
18:13:24 <Chinju> and when Hugs _did_ do it, I was rather confused
18:13:34 <Chinju> at the divergence in behavior
18:14:05 <Lemmih> Don't put class constrains on data/newtype. They don't do what you want them to.
18:14:21 <Chinju> how so?
18:14:24 <Cale> yeah, they're sort of broken anyway
18:14:40 <Chinju> how so?
18:15:54 <Cale> That doesn't prevent you from forming the type Blah T where T is not in Eq
18:16:06 <Cale> It just means that you can't construct a value of that type.
18:16:09 <Chinju> ah
18:16:15 <Cale> Also, if you have something like
18:16:38 <Chinju> so a function that took Blah a as input would still need to additionally specify Eq a as a constraint; that wouldn't be inferred automatically?
18:16:41 <Cale> data (Eq a) => Blah a = Foo | Blah a
18:16:51 <Cale> Foo won't have that type constraint
18:16:57 <Cale> right
18:17:01 <Cale> well, it'd be inferred
18:17:09 <Chinju> well, if I used it, I guess it'd be inferred
18:17:09 <Cale> but the type would have to be there
18:17:12 <pasky> hmm, is there a simple way to do "take N items from the list end" without doing two reverses?
18:17:19 <Chinju> I mean, if I used (==), I guess it'd be inferred
18:17:37 <Cale> Chinju: even if you just used the constructor
18:17:43 <Chinju> right
18:17:44 <pasky> or, do the reverses hurt a lot performance-wise?
18:18:27 <Cale> pasky: taking items from the end of a list has inherently bad performance
18:19:17 <Chinju> but, basically, like you said, the type "Blah T", for example, would still exist, even if T wasn't an instance of Eq
18:19:25 <Cale> Chinju: right
18:19:38 <pasky> all right.. so I suppose if I want to change n-th item in a list, the best I can get is
18:19:41 <pasky> poke (i:list) 0 fun = (fun i):list
18:19:44 <pasky> poke (i:list) pos fun = i:(mpoke list (pos-1) fun)
18:19:55 <Cale> Chinju: and if there were constructors which didn't mention the type variable 'a' used in the constraint, you could still construct values
18:20:02 <Chinju> yeah
18:20:03 <pasky> s/mpoke/poke/
18:20:09 <Chinju> alright
18:20:20 <Chinju> is there anyway to get the behavior that "Blah T" only exists when T is an instance of Eq?
18:21:26 <Cale> pasky: poke xs i f = zipWith (\i -> if i == n then f else id) [0..] xs
18:21:47 <Cale> Chinju: no, I don't think so.
18:22:24 <mauke> @type \xs i f -> zipWith (\i -> if i == n then f else id) [0..] xs
18:22:25 <lambdabot> Not in scope: `n'
18:22:34 <Cale> oh, sorry
18:22:35 <mauke> @type \xs n f -> zipWith (\i -> if i == n then f else id) [0..] xs
18:22:36 <lambdabot> forall a b. (Num a, Enum a) => [b] -> a -> (b -> b) -> [b]
18:23:12 <pasky> oh, thanks.. I've been a bit afraid of zips, thinking that it would make the performance even worse
18:23:19 <Chinju> alright, thanks for the help
18:23:42 <Cale> Chinju: such a feature has been the topic of a fair bit of research
18:23:53 <Cale> I could suggest at least one paper
18:23:57 <Chinju> sure
18:24:07 <Cale> http://www.cs.chalmers.se/~rjmh/Papers/restricted-datatypes.ps
18:24:29 <Chinju> thanks
18:24:31 <mauke> pasky: why would it?
18:25:21 <Chinju> heh
18:25:26 <Chinju> that paper opens with the exact situation I'm dealing with
18:25:31 <Cale> Chinju: right
18:25:32 <Chinju> an abstract datatype for sets
18:25:41 <pasky> mauke: oh, it's a zipwith.. yes, that might be quite cheaper.. cool!
18:25:55 <Cale> Chinju: you'll also be interested in the very recent postings to the haskell-prime mailing list.
18:26:08 <Chinju> ah
18:30:54 <araujo> Hello!
18:39:32 <dons> hey araujo!
19:07:10 <gFunk> anyone know why i would be getting these error messages http://pastebin.com/544381 when compiling a single-file with GHC from a win32 command-line?
19:09:12 <Lemmih> gFunk: Use '-package mtl' or '--make'
19:10:03 <gFunk> that's it! thanks!
19:38:37 <araujo> dons!!!
19:46:03 <SamB> @quote SamB
19:46:03 <lambdabot>  Boy, point-free Arrows are worse than Forth...
19:46:10 <SamB> @quote SamB
19:46:10 <lambdabot>  because sliced bread gives horribly uninformative error messages?
19:46:25 <lispy> @quote lispy
19:46:25 <lambdabot>  I just remembered this dream i had the other morning.  I was trying to
19:46:25 <lambdabot> tell my alarm clock how to snooze by using a list comprehension
19:46:38 <SamB> @quote SamB
19:46:39 <lambdabot>  because sliced bread gives horribly uninformative error messages?
19:46:41 <SamB> @quote SamB
19:46:41 <lambdabot>  because sliced bread gives horribly uninformative error messages?
19:46:45 <SamB> stop that!
19:46:48 <SamB> @quote SamB
19:46:48 <lambdabot>  because sliced bread gives horribly uninformative error messages?
19:46:56 <SamB> okay, what in the world is going on
19:46:59 <SamB> @quote
19:47:00 <lambdabot> malcolm says: Most software doesn't need to be fast.  But all software
19:47:00 <lambdabot> needs a fighting chance of correctness
19:47:07 <SamB> @quote SamB
19:47:07 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it
19:47:07 <lambdabot> printed
19:47:11 <SamB> @quote SamB
19:47:12 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it
19:47:12 <lambdabot> printed
19:47:14 <SamB> @quote SamB
19:47:14 <lambdabot>  because sliced bread gives horribly uninformative error messages?
19:47:19 <Korollary> random means random. What you want is shuffle.
19:47:19 <SamB> arg
19:48:02 * lispy shuffles off to hang out with friends
19:48:10 <lispy> my random friends that is
19:48:14 * lispy waves
19:48:39 <SamB> arg
19:48:42 <SamB> @quote SamB
19:48:43 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it
19:48:43 <lambdabot> printed
19:48:46 <SamB> @quote SamB
19:48:46 <lambdabot>  C is a good language. If what you want is an assembly language where you
19:48:46 <lambdabot> can't be sure what anything does
19:49:26 * Philippa wonders...
19:49:28 <Philippa> @quote Philippa
19:49:29 <lambdabot> Philippa hasn't said anything memorable
19:49:31 <SamB> does anyone know of anything surprising or amusing that I have discovered
19:49:37 <Philippa> bah! Lies!
19:49:50 <SamB> Philippa: hmm. I can't remember anything!
19:49:57 <Korollary> I should have quoted that c*ntpaste comment
19:50:32 <Philippa> which one? I use the term fairly randomly, though I think I've at least once punned further...
19:50:50 <Korollary> I don't remember. It was the first time I heard it.
19:52:00 <Korollary> @quote Korollary
19:52:00 <lambdabot> Korollary hasn't said anything memorable
19:52:05 <Korollary> @quote Gahhh
19:52:05 <lambdabot>  monads are usually a personal experience.
19:52:15 <Korollary> That's my only one.
19:53:14 <SamB> @quote SamB
19:53:14 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it
19:53:14 <lambdabot> printed
19:54:07 <dons> ? is @quote playing tricks?
19:54:27 <SamB> dons: well, I thought there were more quotes of me than that...
19:54:34 <Korollary> dons: I am guessing quote uses random and doesn't actually shuffle the quotes to ensure no repeats.
19:54:48 <SamB> @quote SamB
19:54:48 <lambdabot>  because sliced bread gives horribly uninformative error messages?
19:55:01 <dons> sure. but the quotes printed are actually associated with those people?
19:55:11 <SamB> yes
19:55:16 <dons> ok, alles gut
19:55:27 <SamB> I'm sure I was explaining why Parsec was better than sliced bread.
19:55:48 <dons> well, I agree that slice bread is pretty poor on the error msgs
19:55:54 <dons> so that seems reasonable
19:57:48 <SamB> hmm, I want something surprising that I discovered to send with a Y Combinator application
19:57:57 <SamB> or at least amusing
19:59:04 <dons> @remember malcolm I don't believe you need to invoke the full awesome majesty of Template Haskell
20:02:31 <dons> I think we should plan to revise the language every couple of years -- so many good ideas get suggested on the mailing lists :)
20:04:08 <Philippa> actually revising it being another matter? ;-)
20:04:24 <dons> yeah, don't bother revising, just plan to revise.
20:04:35 <dons> and get everyone writing libraries, and making ghc extensions :)
20:04:52 <Philippa> I guess I started the rush, but I was a bit annoyed to be cited as an example of dangerous behaviour on LtU
20:05:22 <dons> oh hmm? really? got a ref?
20:05:55 <Philippa> especially as the simplest form of the extension I suggested is... the only reason I'm not doing it myself is I don't know GHC well enough to know the exact scope of the mod. It's as trivial an extension to the type system as you could hope for though
20:06:22 <Philippa> http://lambda-the-ultimate.org/node/1281
20:06:35 <Philippa> the "being" link
20:07:15 <Philippa> and in fairness it's more the inevitable comments that start labelling it as undesirable rather than mildly questioning the desirability
20:07:28 <dons> ah.
20:09:05 <dons> one interesting (semi-related) thing: look at the increase in haskell-cafe traffic, http://dir.gmane.org/gmane.comp.lang.haskell.cafe, versus the decrease(?) in ghc commits:  http://dir.gmane.org/gmane.comp.lang.haskell.cvs.ghc
20:09:15 <dons> or maybe I'm imagining
20:09:25 <Korollary> I had the same impression
20:09:26 <dons> and it has picked up in the last year.
20:09:41 <dons> maybe that explains much of the move to open up ghc to more devs
20:10:02 <Korollary> They're dying to find people to hack on ghc afaics
20:10:24 <dons> well, not quite dying. but darcs is helping
20:10:38 <dons> and so is cabal
20:10:45 <dons> (other people hack on the libs now)
20:11:51 <Korollary> The associativity of $ thread was a bit of a bad PR.
20:14:51 <Philippa> I'd love to have an idiot's guide to adding new language features to GHC
20:15:01 <Philippa> that is, something that explains all the places that'll require modification
20:15:34 <Philippa> the ramifications of altering the abstract syntax of terms and/or types aren't something I understand at the mo, for example
20:15:36 <SamB> probably depends on the feature
20:15:37 <dons> we used to have "Adding a new optimisation pass to ghc" but its about 10 years out of date
20:15:49 <SamB> 10 years? wow!
20:16:01 <dons> well, they've been working on it since around 1990
20:16:16 <Philippa> SamB: add a 'potentially' and some explanation of likely conditions
20:16:21 <dons> you can't win the shootout rankings with a compiler you wrote yesterday ;)
20:16:46 <SamB> true
20:17:01 <Philippa> (for example, if it's just sugar it's trivial, if it's a type system extension then obviously you'd better understand the implications of it...)
20:17:31 <dons> i found it fairly easy to add a new backend interface, a couple of years ago
20:17:31 <palomer> GADTs!
20:17:41 <dons> though it took about 1 week, and 1k loc.
20:17:47 <dons> but it was fairly straight forward
20:18:13 <Philippa> yeah. Unfortunately what I'm interested in doing'd involve mods to the parser, type AST, typechecker...
20:18:20 <SamB> 1k loc only sounds bad because this is Haskell we are talking about
20:18:22 <Philippa> and therefore most likely a number of other sites I don't know to worry about yet
20:18:27 <Philippa> (prettyprinter?)
20:18:33 <dons> yeah, an "extension" from top to bottom would be trickier
20:18:53 <dons> pretty printer aint so hard, just a new Outputable instance (like Show)
20:19:02 <Philippa> 1kloc is bad. Admittedly I'm talking from the perspective of someone who's been known to spend months thinking about the perfect 50 lines because they'll get written where 1000 won't...
20:19:28 <Philippa> yeah, that doesn't surprise me at all. But still makes an example of something I could've missed
20:19:35 <SamB> Philippa: for a compiler backend?
20:19:37 <palomer> if I export a type alias, will the export remember what the type alias is?
20:19:48 <dons> yup, or it wouldn't be an alias, right?
20:19:53 <SamB> Philippa: how could you miss it?
20:20:02 <SamB> Philippa: you'd get a type error...
20:20:05 <palomer> righto
20:20:12 <palomer> we should have oblique aliases
20:20:17 <Philippa> which is a relief, but I'd still have missed it until after I'd started hacking
20:20:17 <palomer> where we forget it's an alias
20:20:23 <Philippa> which is a wee bit disheartening if nothing else
20:20:37 <dons> palomer, data, hide the constructors.
20:21:06 <Philippa> granted, if you make me happy you'll have covered the needs of 99% of potential GHC hackers - everyone else's mild irritation is my offputting enough to shelve it for the day, which tends to imply not getting started again
20:21:37 <SamB> dons: you mean newtype, right?
20:21:43 <dons> that'd work too ;)
20:22:06 <dons> I meant 'data', but it was a muscle-memory reflex
20:22:14 <SamB> hehe
20:22:22 <palomer> Philippa: I wouldn't be surprised if people were irritated by lack of monadic sorting
20:22:35 <SamB> ??
20:22:48 <Philippa> palomer: yup. Post about it somewhere?
20:23:04 <Philippa> More generally, the lack of monadic versions of all the List operations not already covered
20:23:24 <Philippa> SamB: sort with a monadic comparison operation
20:23:30 <Philippa> sortByM, I guess
20:23:55 <araujo> http://wagerlabs.com/articles/2006/01/01/haskell-vs-erlang-reloaded
20:24:08 <dons> is that joelr's critique? ;)
20:24:15 <dons> *sigh*
20:24:23 <araujo> seems so :-]
20:24:36 <dons> he really really tried to do things the hard way.
20:24:42 * SamB tries to figure out the meaning of the sigh
20:25:16 <dons> just the critique. I think he went about things kind of crooked, not that ghc is inherently unsuitable for binary IO and concurrency
20:25:36 <dons> for example, those pickler combinators that we'd never heard of, he used, instead of class Binary
20:25:52 <dons> also, Windows is way way more unstable
20:26:00 <dons> anyway, I don't want to go down that path
20:26:10 <dons> my opinion is that Erlang's concurrency is overrated
20:26:17 <dons> it's good, but so is Haskell's
20:26:29 <Philippa> Windows being way more unstable isn't much of an excuse IMO. Of course, I'm on windows
20:26:35 <SamB> well, erlang is good at its job
20:27:17 <araujo> *nods*
20:27:18 <palomer> windows is so much more usable than linux
20:27:32 <dons> we reached the point, iirc, where he was doing things the recommended way, except those damn picklers, which were the computation bottleneck. that's when he gave up
20:27:46 <Philippa> I'm not sure I find it substantially so allowing for the difference in accumulated experience I have on each
20:28:21 * SamB wonders: what the heck is bluemud.org and why was it taken down for homaland security
20:28:38 <Philippa> there is a bit of a problem with people trying to use random research or hacks because that's what they found when they googled for "haskell <keywords for task>"
20:28:48 <dons> yeah, good point
20:28:53 <dons> we need hackageDB :)
20:28:56 <Philippa> I remember having to smack someone around the head and tell them to stop fucking around with extensions and listen to us...
20:29:02 <palomer> would anything blew up if we tried to combine all the monads we know into a super monad?
20:29:05 * dons -> off to a talk.
20:29:16 <Philippa> ...because they were trying to do fancy crap when they needed to just implement the maths they knew the easy way
20:29:21 <Philippa> yes
20:29:31 <palomer> s/blew/blow
20:29:31 <Philippa> try implementing the equivalent of IOT List
20:29:44 <Philippa> (IOT doesn't exist for a reason, of course)
20:29:55 <SamB> what isn't IOT?
20:30:16 <palomer> what's IOT?
20:30:30 <Philippa> um... IOT List is the "many universes, no, really, I mean it" monad :-)
20:30:41 <Philippa> palomer: a hypothetical monad transformer that adds IO
20:30:49 <Philippa> it doesn't exist for good reason
20:30:58 <palomer> could it exist?
20:31:09 <SamB> oh, the transformer version of IO?
20:31:15 <SamB> crazy
20:31:36 <Philippa> yes, if you didn't mind evaluating the list being impossible from within this universe
20:32:33 <Philippa> (or ran the lot on a universe-emulator emulating a boring universe, or...)
20:33:19 <palomer> I have to admit, I'm a little confused
20:33:33 <palomer> then we go have a runIO !
20:33:55 <palomer> in fact, why don't we have a runIO function?
20:34:16 <Lemmih> runIO == unsafePerformIO?
20:34:21 <palomer> seriously, we could do some IO, then get back into haskell land, then do some IO
20:34:56 <Philippa> let's go a step further and 'unwrap' the (hypothetical, denotational semantics) IO implementation:
20:35:13 <Philippa> data IO a = IO (World -> (a,World))
20:35:31 <Philippa> that is, the IO monad is a State monad where the state is of type World
20:35:40 <Philippa> where World is the state of the entire damn universe at a given point
20:35:46 <palomer> sure
20:35:57 <Philippa> (because you need that to know if anything interacts and affects the program - how 'bout that meteorite heading towards the computer?)
20:36:35 <Philippa> that suggests that we could write programs with the type World -> (a,World) and run 'em...
20:38:06 <Philippa> winLottery start = let {future1 = waitForLotteryResults start; numbers = lookupLotteryResults future1; future2 = buyLotteryTickets numbers start} in future2
20:38:34 <Philippa> what does that function do, and what's wrong with trying to run it?
20:39:13 <palomer> win the lottery
20:39:22 <palomer> but what are your types?
20:39:29 <palomer> (ie, how is everything typed)
20:39:41 <Philippa> er, sloppily
20:40:06 <palomer> winLottery is of what type?
20:40:19 <Philippa> start's a World, future1's a World, future2's a World. So I should be returning (future2, ()) I guess
20:40:21 <Philippa> World -> World
20:40:35 <Philippa> lookupLotteryResults :: World -> LotteryNumbers
20:40:40 <palomer> I'll argue that World is actually a monad !
20:40:57 <Philippa> bad argument. There's a monad implementable using world, sure
20:41:02 <Philippa> I'm doing monad-like things with it
20:41:09 <Philippa> that's the insight that led to monadic IO in the first place
20:41:24 <Philippa> but as being used here, there aren't any invariants associated with that structure
20:42:10 <Philippa> now, that explains why no IOT
20:42:26 <palomer> how did you use IOT here?
20:42:42 <Philippa> I didn't. But the existance of an IOT would allow equivalently broken code
20:43:05 <Philippa> because IOT List would attempt to use Worlds in a non-linear fashion
20:43:18 <Philippa> (linearity being the constraint that stops us looking into the future)
20:43:47 <Philippa> similarly, unsafePerformIO breaks the semantics of the language because functions are no longer pure in any sense if you have it
20:44:07 <Philippa> so, it exists as a compiler hack. It's unsafe because it breaks the semantics of the language
20:44:21 <palomer> Philippa: what about runIo?
20:44:23 <palomer> runIO rather
20:44:48 <Philippa> runIO is unsafePerformIO
20:45:06 <Philippa> the only 'safe' runIO has a type like IO a -> IO a
20:45:22 <Philippa> (or, I guess, is join in the IO monad - IO (IO a) -> IO a)
20:45:50 <palomer> oh, righto ,breaks referential transparency and all that jazz
20:45:58 <palomer> so there really is no difference between runIO and unsafePerformIO?
20:46:11 <Philippa> nope, none at all
20:46:22 <palomer> they should have called it runIo
20:46:26 <palomer> err, runIO rather
20:46:28 <Philippa> no, they shouldn't
20:46:36 <Philippa> unsafeRunIO, perhaps
20:46:42 <palomer> yeah, sure
20:47:08 <Philippa> but they got there first. The runFoo convention grew up after monadic IO was first implemented
20:47:18 <palomer> ahh
21:15:21 <palomer>     mapM identityCopy domain where identitycopy = newSTRef 0 <
21:15:31 <palomer> <---this is not what I want, is it
21:15:49 <palomer> how would I do this:o
21:15:56 <palomer> I've just spent the last 2 days chasing this bug
21:17:28 <Lemmih> I don't understand what you're trying to do.
21:17:37 <palomer> I want to create a new stref for every element in domain
21:17:48 <Lemmih> let ic = newSTRef 0 in mapM (const ic) domain?
21:18:20 <palomer> that works? are you sure?
21:18:32 <Lemmih> > map (const ()) [1,2,3]
21:18:33 <lambdabot> [(),(),()]
21:19:00 <palomer> yes, but won't that simply create the stref once?
21:19:44 <Lemmih> Of course not.
21:20:18 <Lemmih> palomer: Try 'mapM (const (putStrLn "Hello world")) [1,2,3]'
21:20:52 <palomer> ok, what about ic =do{ u <- newSTRef ; return Just u}
21:21:28 <Lemmih> do fmap Just (newSTRef 0)?
21:21:37 <Lemmih> s/do /
21:21:53 <palomer> yeah, that's equivalent
21:29:00 <palomer> omg, once I find this bug, I'll be a new man
21:29:52 <Lemmih> Got the problem posted somewhere?
21:30:38 <palomer> well, I'm trying to pinpoint where things are going wrong
21:37:53 <palomer> @hoogle (a,b) -> (b,a)
21:37:54 <lambdabot> No matches, try a more general search
21:38:11 <palomer> @pl \(a,b) -> (b,a)
21:38:12 <lambdabot> uncurry (flip (,))
21:38:25 <twb> Say, anybody remember where the documentation/paper for Clean's parser combinator stuff is?
21:44:30 <marnix> twb: there's a chapter under "Case studies" on http://www.cs.ru.nl/~clean/support.html, both PS and PDF.
21:45:05 <palomer> is there a reason we don't use clean instead of haskell?
21:46:10 <palomer> hrmph
21:46:44 <marnix> twb: more papers on http://www.cs.ru.nl/~pieter/parscomb/parscomb.html
21:46:48 <twb> marnix: cheers.
21:47:07 <twb> marnix: I was looking at the main page, which claims that section is out of date and doesn't list urls :-/
21:48:37 <marnix> twb: well, I can't guarantee up-to-dateness obviously :-)
21:49:12 <twb> marnix: it's adequate for my purposes, thanks.
21:50:02 <marnix> palomer: yes, I guess I would have to agree, living as I do close to the university where it was created...  But I've never used it, and before I heard about it, I was already heavily into Haskell.
21:50:33 <marnix> [oops, got to go.  Have a nice day all]
21:50:42 <palomer> it wasn't a statement! simply a question
21:52:21 <palomer> don't you guys hate it when there's an invariant you're sure about 5 lines of code, and the invariant is wrong, and you don't know why?
21:55:08 <sieni> I haven't noticed that to happen, but please tell us more :-)
21:58:27 <palomer> http://www.rafb.net/paste/results/PH66hQ79.html
21:58:46 <palomer> that code gives me an "imageCheckError"
21:58:52 <palomer> but that's clearly impossible!
22:00:00 <palomer> http://www.rafb.net/paste/results/HnaNOe20.html
22:01:22 <palomer> http://www.rafb.net/paste/results/P2ijXI14.html
22:01:27 <palomer> there, that should give enough background
22:01:49 <Cale> btw,  and (map p xs) = all p xs
22:02:13 <palomer> oh, righto
22:02:42 <palomer> so yeah, translate with the inverse correspondence should only return STypes which are in my domain
22:04:16 <Cale> so, it's an error that ret is in dom?
22:04:38 <palomer> oh, woops, forgot a not
22:04:52 <Cale> or swap the two branches of the if
22:05:59 <palomer> http://www.rafb.net/paste/results/BuIkyP99.html
22:07:33 <Cale> palomer: what's image?
22:07:42 <Cale> oh
22:08:11 <Cale> shouldn't y be an element of the codomain of u?
22:08:20 <palomer> how so?
22:08:31 <Cale> well, I'm not sure what the intent of the code is
22:08:46 <Cale> image x u sounds like it's computing the image of x in u
22:08:46 <palomer> there's a domain and a codomain
22:09:05 <palomer> and there's a function value which maps elements in the domain to elements in the domain
22:09:11 <palomer> and elements in the codomain to elements of the codomain
22:09:23 <Cale> mm
22:09:27 <palomer> image translates, then applies value, then translates with the inverse correspondence
22:09:41 <palomer> my terminology sucks, do you have anything better?
22:09:59 <Cale> It's not too bad
22:10:06 <Cale> you have a commutative square?
22:10:22 <Cale> (or a category theoretic square anyway)
22:10:45 <palomer> well, no
22:10:53 <palomer> since value should be the identity on elements of the domain
22:11:20 <Cale> D -> C
22:11:31 <Cale> |    |
22:11:37 <Cale> D -> C
22:11:40 <Cale> er
22:11:45 <Cale> D <- C
22:11:54 <Cale> sorry for the poor ascii art :)
22:12:08 <palomer> well ,yes, you can think of it that way
22:12:17 <palomer> image is the leftmost morphism
22:12:25 <Cale> okay
22:12:25 <palomer> translate correspondence is the top arrow
22:12:29 <Cale> or the composition of the other 3
22:12:41 <palomer> translate (invert correspondence) is the bottom arrow
22:12:44 <Cale> okay
22:12:50 <Cale> and the right arrow is id?
22:12:51 <palomer> and value is the rightmost arrow
22:12:51 <Chinju> whoa, category theoretic stuff flying everywhere
22:13:04 <Cale> ah
22:14:04 <palomer> so, yeah, if the image of x under u is not in the domain of u, then that should be caught with an "imageCheckError", no?
22:14:40 <palomer> instead of a BLARGH error
22:14:56 <Cale> map (\y -> y `elem` dom) (map snd invCorrespondence) = map (\y -> y `elem` dom) (map snd (map (\(a,b)->(b,a)) correspondence))
22:15:22 <palomer> correspondence is a set of pairs (a,b) where a is in the domain and b in the codomain
22:15:23 <Cale> = map (\y -> y `elem` dom) (map fst correspondence)
22:15:35 <Cale> = map (\y -> y `elem` dom) dom
22:15:47 <Cale> so it's a list of trues :)
22:15:51 <palomer> Cale: yeah, that was a sanity check 
22:15:55 <palomer> checking my own sanity, that is
22:15:55 <Cale> so that part is good
22:15:59 <Cale> yeah
22:16:18 <Cale> how is domain defined?
22:16:50 <Cale> and what are the parameters to image called inside image?
22:17:20 <palomer> http://www.rafb.net/paste/results/5hJu6T63.html
22:17:29 <palomer> domain is an [SType s]
22:18:08 <palomer> ditto for codomain (which I haven't used anywhere)
22:18:20 <Cale> um
22:18:26 <Cale> it's a function surely
22:19:07 <palomer> oh, right
22:19:27 <palomer> domain x = map fst (getCorrespondence x)
22:19:32 <Cale> ah, okay
22:20:30 <Cale> could you have the error message print the elements of the domain and see if it's sane?
22:20:58 <Korollary> g'day
22:21:03 <Pseudonym> G'day.
22:21:09 <palomer> what do you mean by sane?
22:23:18 <palomer> ok, it says here that my domain is 3 distinct elements
22:23:38 <palomer> (which I've printed as 'a, 'b and 'c)
22:24:16 <palomer> Cale: but following the logic of the code, clearly it should work, and if it doesn't I should get an imageCheckError
22:24:20 <palomer> this is wrong on so many levels!
22:28:31 <Saulzar> You want to be careful with that word "clearly" and "should" :)
22:32:03 <Pseudonym> G'day./quit
22:32:07 <Pseudonym> Whoops.
22:32:20 <Pseudonym> I did not mean to /quit
22:32:24 <Pseudonym> Which is good since I didn't.
22:32:43 <palomer> freudian slip
22:33:18 <Pseudonym> No, it wasn't a Freudian penis.
22:34:19 <palomer> not penis, a freudian butt-sex
22:34:43 <palomer> ok, this is getting silly:P
22:36:33 <palomer> Cale: any luck?
22:36:54 <palomer> oh wait, I'm being stupid
22:36:55 <Cale> hmm
22:37:04 <palomer> check out the definition of image:P
22:38:39 <palomer> http://www.rafb.net/paste/results/EDsy5S73.html <--updated version
22:38:41 <palomer> now I'm confused
22:38:47 <palomer> it doesn't give me an out of domain error
22:39:06 <palomer> yet gives me a BLARGH error
22:39:21 <palomer> clearly image should only return values in the domain, right?
22:40:52 <palomer> oh my god
22:40:53 <palomer> I'm an idiot
22:42:50 <Cale> what was it?
22:43:58 <palomer> well, notice translate may not return things in the domain
22:44:05 <palomer> for translate (invert correspondence)
22:44:54 <palomer> sometimes it will return a :~> b where a and b are in the domain
22:44:58 <palomer> but a may not be
22:45:48 <palomer> err, remove that last line
22:47:26 <Pseudonym> Gotta go.  Nytol!
22:54:09 <palomer> oh my god it works
22:54:43 <palomer> OH MY GOD
22:54:47 <palomer> I don't know what I did
22:59:56 <palomer> ok, someone tell me I'm nuts
23:00:06 <palomer> [("","'a=(Int -> 'c)"),("","('b -> 'b)=(('d -> 'd) -> 'a)")] <---does everyone agree that this is unifiable?
23:03:08 <Cale> palomer: yeah
23:03:51 <Cale> I get a = b = Int -> Int, c = d = Int
23:07:35 <palomer> c = int?
23:08:05 <palomer> eyah, that works
23:08:12 <palomer> (though it's not the most general unifier)
23:10:41 <Cale> It's not?
23:12:14 <Cale> (b -> b) = ((d -> d) -> a), so b = (d -> d), and b = a. Hence (d -> d) = a = (Int -> c), so d = Int. So a = Int -> Int, and c = Int.
23:12:55 <palomer> oh, you're right, it is
23:18:03 <palomer> (and that's exactly what I get:O))
23:29:42 <gour> dons: i built latest yi, but i cannot enter e.g. croatian chars (i'm on utf8 locale)
23:49:36 <lispy> gour: are those keys on your keyboard or do you use special codes?
23:49:52 * lispy asks out of ignorance
23:50:29 <gour> lispy: normal keys
23:51:53 <palomer> I'm sooooooo close
23:53:18 <lispy> palomer: close?
23:53:44 <palomer> to finding a bug
23:53:55 <lispy> gour: ak okay.  I live in the US so i'm not exposed to those sort of things so I have to ask :)
23:54:03 <lispy> palomer: in your code?
23:54:22 * lispy whispers to palomer, "test driven development"
23:55:33 <palomer> someone tell me this is unifiable:
23:55:35 <palomer> ('a=(Int->'c)),('b=('d->'d)),('a=('d->'d))
23:55:59 <gour> lispy: thanks for concern ;)
23:56:10 <palomer> a=b=Int->Int, c=d=Int
23:57:19 <lispy> palomer: perhaps i'm missing the point, but why wouldn't it be unifiable
23:57:51 <palomer> it is unifiable
23:57:54 <palomer> but my algorithm can't see that
23:57:57 <palomer> grrr
23:59:13 <palomer> test driven development?
23:59:16 <palomer> what the bejeezus is that?
