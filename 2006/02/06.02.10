00:00:29 <Lemmih> gour: FPS builds fine with the latest ghc-head for me.
00:02:09 <gour> Lemmih: let me try...
00:57:11 <ProfTeggy> Moin
01:11:25 <ProfTeggy> Hmm, making lhs2TeX yields a linker error on Mac OS X (undef'd symbol ___DISCARD__).  Removing -O from GHCFLAGS cures it.
01:30:37 * Lemmih stabs readline.
01:30:52 <olliej> Lemmih, hehe
01:31:11 <musasabi> Lemmih: write a libedit binding ;)
01:32:10 <tuomov> I wish readline etc. could be used within a curses program
01:32:53 <tuomov> so it would forgo terminal handler and just act as a pure function blackbox for editing commands
01:33:35 <tuomov> a zillion curses programs atm reinvent their own line editors
01:33:47 <tuomov> and I'm going to do the same :(
01:35:28 <tuomov> but I wonder if I should just write it in Haskell, or actually create such a blackbox library in C
01:36:05 <tuomov> the C library is mostly written infact, in Ion. It just needs to be turned into a blackbox
01:36:25 <tuomov> and a separate package
01:38:56 <Cale> "The established procedure to generate discussion about language
01:38:57 <Cale> design issues is to propose either syntactic sugar or complex type
01:38:57 <Cale> system extensions, and my proposal was careful to do neither :-("
01:39:01 <musasabi> tuomov: something alternative to readline would be nice in GHC for license reasons too.
01:39:08 <Cale> Claus Reinke
01:47:40 <kosmikus> ProfTeggy: strange. The whole UU gang is using it on MacOS, and this is the first time I hear about such a problem.
01:47:53 <kosmikus> ProfTeggy: which lhs2TeX version, which ghc version?
01:52:34 <dons> __DISCARD__ is a mangler symbol. so maybe gcc is leaving gunk behind? is it a newer gcc?
01:53:17 <dons> if so, it should be reported, so the appropriate fix can be added to the (evil) mangler.
01:54:00 <dons> also, compiling via -fasm should fix it.
02:07:39 * shapr beats cvs with a rock
02:11:29 <Itkovian> shapr: welcome in the 21st century. we now have WMD's to help you there
02:12:35 * shapr nukes cvs
02:13:12 * jethr0 tries to prevent shapr from incurring heavy injuries at CVS's sharp edges
02:18:31 * shapr bleeds
02:18:50 <shapr> Maybe I should use tailor.py to create a darcs repo from this cvs repo
02:19:10 * jethr0 tends to his wounds which are already infected with versioning-rabies
02:20:50 <shapr> :-)
02:21:00 <jethr0> cvs can be pretty gruesome
02:21:56 <shapr> Yay, the House TCP/IP stack still works.
02:22:11 <jethr0> :)
02:22:46 <jethr0> shapr: i still have parts of a libc written in haskell lying around for House :)
02:22:54 <shapr> nifty!
02:23:07 <jethr0> but without file handling, i couldn't implement many calls
02:23:28 <shapr> Hm, should I upgrade my existing code to use QC2?
02:24:04 <shapr> jethr0: You should send it in to Thomas Hallgren and the rest, they'd probably be entertained.
02:24:10 <jethr0> :)
02:24:16 <jethr0> i might
02:34:28 * shapr cheers - *QuickUDP> quickCheck prop_Id \n OK, passed 100 tests.
02:35:01 <jethr0> are you quick-generating packets?
02:35:33 <jethr0> a
02:36:19 <shapr> Yeah, though not across the network yet, just in memory.
02:36:47 <jethr0> still, quite nifty
02:37:56 <shapr> Should be interesting to see how the Linux TCP/IP stack handles random packets.
02:38:51 <jethr0> it's been done extensively AFAIK
02:39:16 <jethr0> regression testing with garbage to try finding overflows or similar
02:39:39 <shapr> Yeah, but the step after that has only been done once or twice...
02:40:32 <jethr0> which step is that?
02:41:17 <MarcWeber> Can you tell me what minimal imports improve compared to not minimal imports?
02:41:27 <MarcWeber> Will the result differ?
02:41:41 <shapr> Rather than generating garbage, generate entire streams and test for conformance. After that, generate streams with one error, and see if they're rejected.
02:42:07 <eivuokko> MarcWeber, do you mean style of only importing exactly stuff you use?
02:43:28 <MarcWeber> I've read about -dump-minimal-imports.
02:43:38 <MarcWeber> Yes exactly
02:43:57 <MarcWeber> Perhaps I should try and compare compilation time and final executable size?
02:44:23 <eivuokko> Ah, the idea is probably to have import Foo (foo).  It's usefull when you have lots of imports and need to find where function foo came from and hence finding it's docs.
02:45:24 <MarcWeber> So there is no advantage using it if you don't have to.
02:45:49 <eivuokko> There is a significant advantage after you have forgotten about the code and need to get back to it :)
02:46:04 <shapr> jethr0: Have you seen the PROTOS tool out of Oulu?
02:46:22 <MarcWeber> :)
02:46:35 <eivuokko> There is no runtime advantage, and maybe neglible compilte time advantage.
02:47:07 <jethr0> shapr: no, what's it about?
02:47:38 <jethr0> a
02:47:49 <jethr0> *damn*, stupid window switching
02:48:21 <MarcWeber> jethr0:  Which os?
02:48:35 <jethr0> someday i'm gonna write some secret correspondence in here instead of in the secret-mailing-window
02:48:46 <shapr> jethr0: http://www.ee.oulu.fi/research/ouspg/protos/index.html
02:49:02 <jethr0> MarcWeber: it's got nothing to do with the o/s. just my stupidity of thinking that the focus lies in the window _i'm_ focussing on :)
02:49:14 <shapr> Right now, PROTOS is the only tool I'm aware of that does the sort of testing I'm interested in...
02:49:15 <jethr0> debian with ion3 as wm
02:49:34 <shapr> But with QuickCheck and a TCP/IP stack written in Haskell, it should be pretty easy to duplicate.
02:49:42 <MarcWeber> *g* My favourite wm is now wmii (and virtual win on windows.. ;-)
02:50:05 <shapr> jethr0: Oh, I like that combination :-)
02:50:21 <jethr0> it's not uncommon around here...
02:50:38 <shapr> I'm using H-n to switch apps inside the workspace, and S-n to switch workspaces.
02:51:02 <MarcWeber> shapr but you can't use F1-F12 ;-)
02:51:13 <shapr> Why would I want to?
02:51:21 <jethr0> i haven't configured it properly yet... always a bit lazy when it comes to administrative tasks. i'm more of the bold explorer type ^_^
02:51:24 <shapr> I have to stretch way off of the home keys to do that.
02:51:36 <jethr0> MarcWeber: you can easily rebind them
02:51:43 <flux__> H-n doesn't seem that much better. but H-s/d rules!
02:52:00 <shapr> flux__: Are you using dvorak on kinesis?
02:52:02 <tuomov> I ues the defaults! They rock! :-P
02:52:04 <flux__> oh, right, no
02:52:13 <flux__> oh, but shapr wasn't either?
02:52:22 <shapr> I've moved all my modifier keys under my thumbs in my "I am not a koala" modified dvorak mapping.
02:52:39 <shapr> I've even written about it on my blog if you want details.
02:52:47 <shapr> tuomov: Thanks for Ion, it roxx!
02:52:48 <jethr0> tuomov: that's cheating...
02:53:12 <MarcWeber> shapr I'm interested.
02:53:16 <jethr0> tuomov: i'll rebind f3 someday because i can't continue searches in firefox now
02:53:43 <tuomov> ^G?
02:53:56 <MarcWeber> jethr0: In wmii you have som special "block" mode where eny key combination is sent to the current window except M-Esc which is used to get back to normal mode
02:53:58 <dons> i use vi bindings. Alt-hjkl
02:54:14 <jethr0> k, as i said, i haven't configured much yet. and haven't looked into firefox bindings that diligently either
02:54:19 <jethr0> *brr*
02:54:28 <tuomov> Ion has Mod1+K Q for sending next key to an app, but it doesn't work always
02:54:31 <int-e> Ow, ^G is awful.
02:54:32 <dcoutts> JaffaCake, any thoughts on how to disable the X11 & HGL packages in ghc-6.4.x ? some gentoo users complain that they want to be able to do: USE="-X" emerge ghc so that they can install on headless machines that do not have X.
02:54:41 <tuomov> and there's  a script in the script repository for disabling most bindings
02:54:53 <MarcWeber> dons:  I would like to use Ctrl-K instead of Ctrl-w-k in vim.. but I don't konw where to patch vim code to support case.
02:55:01 <dcoutts> JaffaCake, so we're tring to optionally build the X11 package (& HGL since it deps on the X11 package)
02:55:05 <JaffaCake> dcoutts: I don't think there's a knob for that right now, but shouldn't be hard to add one to configure
02:55:32 <shapr> MarcWeber: http://www.scannedinavian.com/2005-11-03.html
02:55:46 <dcoutts> JaffaCake, is there a standard way you do it? should I send a patch?
02:56:57 <JaffaCake> dcoutts: look at --enable-opengl, for example
02:57:14 <JaffaCake> it's all done in the local configure script in libraries/OpenGL
02:57:35 <dcoutts> JaffaCake, right 'o. I'll try and do something similar and apply a patch in our ebuild. I can send you the patch too.
02:59:17 <MarcWeber> shapr Have you also heard of half-keyboard (using space to shift? mirror left/right handed keys?)
02:59:31 <shapr> MarcWeber: Yeah, JohnMeacham wrote that.
03:00:14 <shapr> http://repetae.net/john/computer/hk/
03:01:04 <MarcWeber> I read about it on his website .. and about the fuc.. patent..
03:01:12 <MarcWeber> I love this idea.
03:02:01 <shapr> #haskell, the center of keyboard innovation...
03:02:12 <shapr> Did you hear about my hidden markov model keyboard layout? :-)
03:02:27 <shapr> It's sort of a joke, I think.
03:02:57 <int-e> heh
03:03:16 <int-e> it reorders the keys on the fly such that the most likely letters are in the center?
03:03:19 <MarcWeber> shapr The "U" key generates g, G, downarrow, and uparrow. Does this mean you use one key to get 4 key codes? Which Meta-do you use except shift?
03:03:24 <shapr> int-e: yup, you got it :-)
03:03:36 <int-e> Now there's an idea, I'm sure we could sell it as ergonomic ...
03:03:57 <shapr> int-e: Though I'd rather not do it on the fly, I'd rather retrain every month or so.
03:04:25 <int-e> shapr: you might be right. doing it on the fly is too obviously unusable.
03:04:41 <MarcWeber> There has been another idea to use accords like piano players (press many keys at once).. as you can even press several keys with one finger ....
03:04:43 <shapr> It's so bizarre it should be a joke, but it just might work...
03:04:57 <shapr> Yeah, the five button chording keyboard works that way.
03:04:58 <MarcWeber> I'ts like huffman tree?
03:05:25 <MarcWeber> my sp! .. oh..
03:05:37 <jethr0> although repressing the same key all the time isn't the most ergonomical
03:06:05 <jethr0> so, writing "dear sir, madam" would be pressing the "f" key 15 times :)
03:06:07 <shapr> MarcWeber: I use Control, Meta, Super, and Hyper.
03:06:28 <MarcWeber> -> vim modes ;-) imagine a keyboard with twice as much keys.. (normal and insert mode) ;-)
03:06:58 <azuroth> aVRs saTs GeDDR. I like it.
03:07:18 <Saulzar> jethr0, That's how it is with vim/emacs anyway isn't it?
03:08:04 <jethr0> MarcWeber: i'm starting to use vim like that. binding all kinds of keys in normal mode to actions, etc. for example "space" now saves my file *g*
03:08:10 <jethr0> Saulzar: not quite
03:08:38 <MarcWeber> jethr0:  How to insert space then? Will Meta-a Meta-b be mapped to "a " and "b " ?
03:09:23 <int-e> you switch to insert mode first
03:09:30 <jethr0> MarcWeber: in vim i meant. in normal mode you don't enter characters :)
03:09:32 <MarcWeber> jethr0: I'm using autowrite, swapfiles and normal bindings ZZ.. Is there any need to save more often?
03:10:07 <jethr0> *grmpf*, no, there isn't. i've just started using vim for real, so i haven't set up autowrite yet.
03:10:22 <jethr0> also, it reminds me of MS office and gives me the shivers for some weird reason
03:11:20 <MarcWeber> jethr0 You know how to set it up? Either use autocommands or .vim/ftplugin/<filetypename>.vim files to set commands like this
03:12:10 <jethr0> thx
03:13:23 <jethr0> MarcWeber: how do you deal with the only-one-open-buffer at a time "feature"?
03:13:36 <MarcWeber> jethr0:  And get familiar with quickfix cycle (and perhaps also have look at :h compiler just to know that it exists)
03:13:48 <MarcWeber> jethr0 Never used split?
03:14:14 <MarcWeber> vim -c ":h split" -c ":split" -c ":h vsplit" ;-)
03:14:42 <jethr0> yah, but i've usually got more files open than i'd like to split
03:15:06 <jethr0> i'm using :make and :cope already
03:15:27 <MarcWeber> There is a Tab plugin on vim.org but I don't use it. I use :b partoffilename<Tab>
03:15:49 <MarcWeber> DrChampell as a nice zoom plugin so you can split and zoom to one window..
03:16:19 <MarcWeber> If you map \b in normal mode to ":b " it's quite fast
03:16:34 <MarcWeber> Perhaps we should start to use a dialog?
03:18:41 <jethr0> i'm not registered on freenode
03:18:51 <shapr> register!
03:19:11 <jethr0> i'll have to get back to work anyways. thx MarcWeber for your suggesstions
03:19:20 <jethr0> shapr: all in due time :)
03:19:20 <MarcWeber> jethr Try also :e filename
03:19:20 <MarcWeber> Ctrl-o Ctrl-i
03:19:57 <jethr0> k
03:20:22 <MarcWeber> We should enhance Yi so that it can replace vim some time.. But my skills are not sufficient, yet
03:20:41 * gour agrees
03:20:47 <qwr> yeah, configure all custom bindings, get used to them, and then sit behind someone elses computer ;)
03:22:52 <MarcWeber> Lets build a brainwaive interface (such like openeeg on freenode) ;-) An just think you were typing ...
03:27:44 <shapr> Yi is pretty close to vim.
03:30:57 <MarcWeber> shapr I have configured many things (such like taglist plugin, shortcuts) which are very handy. A lot of custom maps. Does Yi support some quickfix cycle? (goto error lines?)
03:33:54 <tuomov> btw, joe has nice format for its syntax highlighting engine that might be quite easy to parsecify
03:34:38 <tuomov> none of this regexp shit but a nice finite state machine (with its own problems with nesting, of couse)
03:44:39 <kzm> In case anybody cares, I did some updating to the trie-based knucleotide entry.  
03:45:14 <kzm> (Sped it up 70% or so by adding exactly two characters.)
03:45:42 <shapr> I bet dons is interested.
03:48:30 <jethr0> kzm: what characters where they? two "!"s ?
03:49:51 <int-e> one ! one ' (read the wiki)
03:57:12 <jethr0> k
04:00:50 <ProfTeggy> kosmikus lhs2TeX 1.10pre
04:01:09 <ProfTeggy> kosmikus, GHC 6.4 
04:01:31 <ProfTeggy> kosmikus, works fine without -O, though
04:02:59 <ProfTeggy> dons, gcc version 4.0.0 20041026 (Apple Computer, Inc. build 4061)
04:03:02 <ProfTeggy> quite recent
04:05:45 <shapr> MarcWeber: I don't think Yi supports that.
04:06:01 <shapr> I'd like to get back into the ncurses Yi
04:06:12 <MarcWeber> So not for daily use yet
04:10:19 * azuroth wonders how much effort FFI to C is
04:10:54 <ibid> effort for who?
04:11:41 <azuroth> me. connecting haskell to a C library?
04:12:48 <ibid> depends on the library
04:13:10 <ibid> but the haskell ffi system is the best i've encountered among languages
04:13:41 <dcoutts> ndm, just in case you're not aware, as of about a month ago, yhc builds on alpha bug segfaults on simple Haskell progs like: main = putStrLn "Hello World"
04:13:59 <dcoutts> ndm, do you have it working on any 64bit arches? perhaps it's just a 64bit thing.
04:14:20 <ndm> dcoutts, i'll pass on the error to Tom
04:14:27 <azuroth> I might look into it further.
04:14:38 <ndm> i haven't build yhi in teh last month, i'll get someone to check on our 64 bit machine
04:15:09 <dcoutts> ndm, you can tell Tom that I've got a keep tester with access to an alpha linux machine.
04:15:14 <dcoutts> keep/keen
04:15:21 <ndm> dcoutts, cool
04:15:39 <dcoutts> ndm, he really wants yhc with gtk2hs apparently :-)
04:16:10 <ndm> dcoutts, cool! probably best to get him to email the list
04:16:12 <Igloo> Why does he prefer it to GHC, OOI?
04:16:15 <ndm> that way we have it in writing
04:16:22 <dcoutts> ndm, ok I'll tell him
04:18:07 <dcoutts> Igloo, btw thanks for the alpha port. I just added alpha support to our ghc package in gentoo.
04:18:29 <dcoutts> Igloo, that's the second arch we've pinched off you :-). We appreciate it! :-)
04:18:44 <ProfTeggy> kosmikus, dons: -O -fasm works fine, indeed
04:18:53 <Igloo> Ah, so that's why he prefered it  :-)
04:18:54 <Igloo> np
04:19:06 <dcoutts> so we now cover x86, amd64, pp, ppc64, sparc & alpha
04:19:12 <dcoutts> pp/ppc
04:29:14 <JKnecht> the ghc x86-64 rpms appear to be bolixed.
04:33:00 <JKnecht> and the source tarball won't build without an installed ghc.
04:34:55 * shapr hops cheerfully
04:35:02 <JKnecht> (i.e. the rpms on Fedora Haskell)
04:36:31 <kzm> jethr0, one ! and one '  (sorry about the delay)
04:36:43 <MarcWeber> vim-related: jethr0 I got this idea while talking to you: http://www.vim.org/tips/tip.php?tip_id=1127 ;-)
04:36:52 <kzm> jethr0, no point for guessing the five characters preceding the ' :-)
04:37:18 <gour> JaffaCake: hi, i try to build ghc-head in order to build hIDE. it fails http://pastebin.com/548220
04:37:50 <JaffaCake> gour:  that was fixed a few minutes ago, darcs pull in libraries/mtl
04:38:01 <gour> JaffaCake: thanks
04:38:36 <musasabi> hmm, how do I pass a module name to template haskell? 'ModuleName ?
04:39:21 <jethr0> MarcWeber: nice idea :)
04:44:20 <ski> hm, where's code for parsing haskell ?
04:52:03 <jethr0> quit
04:56:10 <greenrd> Is ghc supposed to take over 12 hours to compile on a 3GHz machine?
04:56:48 <Lunar^> It's not uncommon
04:56:50 <greenrd> I am just using the configuration from the fedora .src.rpm pretty much, i.e. the default configuration
04:57:14 <greenrd> ok cause I should really move offices today - I just picked a really bad time to start compiling ghc :)
04:57:37 <gour> greenrd: nah, on amd64 (3000) it takes ~ 1order of magnitude less
04:58:33 <greenrd> I am on an x86_64 system but it's an intel box - shouldn't make much difference tho
04:59:11 <gour> greenrd: probably not 'cause 64-bit port is not, afaik, heavy optimized
04:59:32 <gour> greenrd: ask JaffaCake
04:59:37 <greenrd> so how much time does it take for you?
05:00:05 <gour> iirc, 90-120min
05:01:52 <gour> (i'm on gentoo and often compile something else, but it could be even less)
05:03:35 <Igloo> greenrd: That sounds broken. What does it say at the moment?
05:05:51 <greenrd>  in /r/conary/greenix/builds/ghc/ghc-6.4.1/ghc/compiler
05:06:05 <greenrd> ------------------------------------------------------------------------
05:06:05 <greenrd> and make is hogging the CPU
05:06:05 <Igloo> Sounds like the make bug. Try with 3.80 if possible
05:06:26 <greenrd> Yeah I'm using a -test version of make - I'll try that, thanks
05:07:48 <x3m> do you have to use hs-plugins to use haskell(eval) from C in runtime?
05:25:02 <shapr> x3m: nah, http://www.haskell.org/hawiki/FfiTutorial
05:25:15 <shapr> See the "Calling Haskell from C" section.
05:30:49 <x3m> shapr: ok, ive hardly used haskell, but could you do so it would evalute haskell code(like math expressions for example by sending a string from C) in runtime somehow?
05:31:36 <shapr> You could write a simple interpreter with Parsec for eval'ing math bits.
05:32:36 <x3m> havent used that either ;)
05:32:51 * ski wonders what purpose x3m has in mind
05:33:03 <x3m> i guess eval is hs-plugins specific and not something in the language includes
05:33:32 <x3m> ski: implementing haskell evaluation from a c++ bot ;)
05:34:57 <ski> if you want to eval arbitrary haskell (dynamically generated), then i guess hs-plugins is best
05:35:18 <shapr> Yeah, look at the @eval plugin for lambdabot 
05:35:21 <x3m> yeah, except it has hardly been used on win
05:35:22 <ski> (unless you're willing to make a new haskell implementation :)
05:37:14 <x3m> guess i could do a workaround and save the haskell output to a file and read later
05:53:36 <araujo> Hello.
05:57:19 <azuroth> hullo araujo
06:22:41 <Igloo> JaffaCake: What's +RTS -N2? +RTS -? doesn't seem to tell me
06:23:06 <JaffaCake> Igloo: use 2 CPUs 
06:23:33 <Igloo> OK, thanks
06:23:40 <JaffaCake> +RTS -? should tell you if you compile with -threaded
06:23:48 <JaffaCake> in latest HEAD, that is
06:24:30 <Igloo> OK; mine from mid-Jan doesn't
06:24:58 <JaffaCake> you needed -smp until yesterday
06:25:06 <JaffaCake> now -smp is merged with -threaded
06:25:58 <Igloo> Aha, OK
06:36:56 <j> any hacker wanna make money should im me now~~~~
06:37:19 <xerox> Howdy j, Haskell work?
06:45:21 <ndm> does anyone know if there is any way to set the prompt in GHCi?
06:45:42 <ndm> there is in Hugs, with -p, but i can't find one in GHCi
06:46:42 <j> any hacker wanna make money should im me now~~~~
06:46:56 <ValarQ> j: yeah, you said that
06:49:13 <j> are u hacker
06:49:16 <lightstep> is there a way to freeze an MArray to an IArray (or IOArray to Array)?
06:49:33 <j> I need a real Hacker for a Grate deal
06:49:55 <kzm> lightstep, isn't that what freeze does?
06:51:14 <kzm> Hi J.  Yes, I am a hacker, and I'm very interested in grates.
06:51:16 <lightstep> oh, i searched for "run", but not for "freeze"
06:52:03 <j> im me... and lets get it done
06:53:25 <kzm> You are you, sure.  And I agree that lets are nice, but I often find myself preferring wheres instead.
06:55:54 <j> kzm.. what re you waiting for?
06:59:25 <araujo> mmm....
07:00:02 <kzm> araujo, don
07:00:06 <kzm> (grr)
07:00:13 <araujo> j, you should propose it here in the channel and if someone is interested could msg you
07:00:56 <kzm> Oh no - peddling grates is a very important activity, and I'm sure everybody is really interested in the details!
07:02:47 --- mode: ChanServ set +o shapr
07:02:53 <lightstep> @hoogle peek
07:02:55 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
07:02:55 <lambdabot> Foreign.C.String.peekCString :: CString -> IO String
07:02:55 <lambdabot> Foreign.C.String.peekCStringLen :: CStringLen -> IO String
07:03:17 <lightstep> @hoogle alloca
07:03:19 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO
07:03:19 <lambdabot> b
07:03:19 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO
07:03:19 <lambdabot> b
07:03:19 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b)
07:03:21 <lambdabot> -> IO b
07:04:39 <shapr> j: This channel is for the programming language Haskell. If you wish to discuss something else, please do it elsewhere.
07:04:55 <j> ok
07:09:58 * kzm waves.
07:10:29 <kzm> spam on IRC, what will they think of next.
07:10:30 <musasabi> Would a pragma FFI_LIB make sense?
07:10:32 <musasabi> Pragma FFI_LIB contains a library name and is similar to a INCLUDE pragma. FFI_LIB causes all subsequent foreign import declarations in the module to add a dependency to the library specified.
07:10:36 <musasabi> This allows to create e.g. a database library that has multiple modules each depending on a given database library and executables can link to a subset of them (those actually used).
07:13:11 <kzm> With GHCI, when loading fails, I thought I ended up with any imports loaded... what exactly, determines which modules remain in scope?
07:14:17 <kzm> I do wish GHCI could retain as much as possible of the failed module - but I guess it is hard to decide what to retain when there are conflicts?
07:17:12 <shapr> Have you seen type error slicing?
07:28:51 <kzm> If I have seen it, I haven't recognized it as such :-)
07:36:04 <Lemmih> JaffaCake: ping.
07:36:10 <JaffaCake> pong
07:36:21 <JaffaCake> hi Lemmih ;)
07:40:26 <Lemmih> JaffaCake: I hacked up some auto-completion code for :set in ghci. However, breaking words on "-" messes things up. Have you thought about how to get around this?
07:41:49 <JaffaCake> not really... I'm not a readline expert by any means
07:42:06 <JaffaCake> completion is nice though, isn't it :)
07:42:16 <Lemmih> It sure is.
07:42:37 <xerox> @karma+ Lemmih -- :-)
07:42:38 <lambdabot> Lemmih's karma raised to 10.
07:42:44 <JaffaCake> one thing you can do is ignore the word that readline gives you, and parse the line buffer directly
07:43:48 <JaffaCake> the word breaking is really messed up right now... we can't complete symbol names, for example
07:43:58 <Lemmih> I'll try that.
07:44:19 * JaffaCake is looking forward to a patch :)
07:50:36 <lightstep> @hoogle Word8 -> Char
07:50:36 <lambdabot> Distribution.Compat.FilePath.pathSeparator :: Char
07:50:36 <lambdabot> Distribution.Compat.FilePath.searchPathSeparator :: Char
07:50:36 <Lemmih> JaffaCake: And is it trivial to add another 64bit register to the StgRegTable?
07:50:36 <JaffaCake> yes... what for?
07:50:36 <Lemmih> Optimizing 64bit operators. They'd be a lot faster if they were implemented as out-of-line primops instead of ccalls.
07:56:34 <Lemmih> I'm guessing that a missing 64bit register is why my c-- implementation of the ops didn't work. I might be wrong, though. Cmm and the STG machine are still greek to me.
07:56:36 <kzm> shapr?
07:58:16 <kzm> shapr, there is a possible bug in the hawiki; in code sections, the string "output in -" seems to be inserted here and there.  (See e.g. a previous revision of the knucleotide entry, or I think, the current Fasta entry.
07:58:58 <kzm> Anybody else use Data.Graph.Inductive?
08:01:06 <MarcWeber> Does ghc import packages by default if they aren't hidden?
08:01:17 <srle> asin 1.0
08:01:39 <srle> asin 1.0;;
08:01:42 <srle> asin 1.0
08:01:59 <srle> @he
08:02:01 <lambdabot>  @help <command> - ask for help for <command>
08:02:33 <srle> hi all
08:04:14 <MarcWeber> srle I think it was > to execute a command
08:05:23 <kzm> > asin 1.0
08:05:24 <lambdabot> 1.5707963267948966
08:05:25 <kzm> ?
08:05:31 <kzm> > sin it
08:05:32 <lambdabot>  Not in scope: `it'
08:05:48 <kzm> Hmm.. missing functionality, there? :-)
08:06:15 <srle> MarcWeber : tnx
08:06:21 <srle> > asin 1.1
08:06:23 <lambdabot> NaN
08:06:33 <MarcWeber> I get a lot of error messages like this: comlib/libHScom.a(PointerPrim.o)(.text+0x696):ghc2648.hc: multiple definition of `__stginit_PointerPrim_'
08:06:33 <MarcWeber> when using --make but not when compiling the object files manuallly with a makefile.
08:06:33 <MarcWeber> Is there an option for ghc to fix this? (You're right, I not very familiar with this stuff, yet )
08:08:39 <srle> what is better? asin 1.1 to return NaN or to create myAsin 1.1 that throws exception?
08:09:23 <srle> or to create myAsinVer2 x where x is subtype of Float in range [-1, 1].
08:17:11 <Saulzar> srle, Depends on what you want to do with it
08:17:16 <kzm> srle: well, you can easily wrap it with a range checking function, and NaNs have a long tradition in floating point...
08:18:44 <MarcWeber> .hc files are the generated C files by ghc, right?
08:19:11 <Igloo> yes
08:19:17 <Lemmih> JaffaCake: Btw, have you been able to build 'base' after bang patterns were included? GHC appears to have problems compiling (!).
08:19:27 <xerox> MarcWeber: there is a way to have GHC to generate Makefile's depend-icies for you.
08:19:54 <Igloo> Lemmih: The HEAD built for me today
08:19:55 <MarcWeber> xerox: fptools does this as far as I know (but I didn't understand them completely).
08:20:05 <xerox> MarcWeber: I'm sorry I have to point you in the direction of the User Manual, I do not remember, neither I have ever tried, the details.
08:21:01 <MarcWeber> If a package has been compiled -fvia-C can I use this package without adding -fvia-C to compiler options?
08:21:33 <Igloo> Yes
08:27:13 <dcoutts_> Lemmih, that autocompletion sounds great
08:30:33 <dcoutts_> JaffaCake, have a good holiday!
08:32:47 * palomer had 10 gvs open
08:33:50 * Igloo notices the other parsing of "-- XXX this leaks FunPtrs for fun"
08:41:07 <srle> > asin 1.0
08:41:08 <lambdabot> 1.5707963267948966
08:41:13 <srle> > asin 1.1
08:41:15 <lambdabot> NaN
08:45:09 <tromp_> > asin 1.0000000000000000000000000000000000001
08:45:11 <lambdabot> 1.5707963267948966
08:47:38 <ski> > 1.0000000000000000000000000000000000001
08:47:39 <lambdabot> 1.0
08:47:42 <xerox> > (asin 1.000000000001, asin 1.0000000000001)
08:47:43 <lambdabot> (NaN,NaN)
08:50:37 <xerox> > asin 1.000000000000000111
08:50:39 <lambdabot> 1.5707963267948966
08:50:44 <xerox> 111...
08:53:29 <tromp_> > asin 1.00000000000000011103
08:53:31 <lambdabot> NaN
08:54:24 <tibbe> can someone give me an example of a useful function that can't be typed with rank one polymorphism?
08:54:37 <lightstep> is there a combination of catch and bracket, like unwind-protect, of `finally' in some languages?
08:55:09 <tibbe> lightstep, Error monad, Maybe data type
08:55:41 <Igloo> tibbe: (\x -> (x "foo", x [True, False])) reverse
08:55:52 <lightstep> tibbe, i want to close a file disregarding whether an excception happened
08:56:06 <lightstep> tibbe, and, you have runST in the standard library
08:56:47 <tibbe> lightstep, haven't done much file IO in haskell, what can throw?
08:57:07 <tibbe> > (\x -> (x "foo", x [True, False])) reverse
08:57:09 <lambdabot> Couldn't match `Char' against `Bool'
08:58:04 <lightstep> tibbe, openFile can throw
08:58:42 <tibbe> @hoogle openFile
08:58:44 <lambdabot> System.IO.openFile :: FilePath -> IOMode -> IO Handle
08:58:44 <lambdabot> Graphics.UI.ObjectIO.StdGUI.ProcessOpenFiles :: ProcessOpenFilesFunction
08:58:44 <lambdabot> ps -> ProcessAttribute ps
08:58:44 <lambdabot> Graphics.UI.ObjectIO.StdGUI.ProcessOpenFilesFunction :: [String] -> ps ->
08:58:44 <lambdabot> GUI ps ps
09:00:15 <tibbe> lightstep, have a look at System.IO.Error.catch
09:00:25 <tibbe> @type System.IO.Error.catch
09:00:26 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
09:00:55 <tibbe> my guess is that you could do something like: myIoOps `catch` handler
09:01:53 <lightstep> yes, i see now. i can wrap stuff with bracket and catch, and add a throw in the third clause of cracket
09:03:07 <tibbe> lightstep, sorry, guess I misundertood you then, you want a final?
09:03:24 <lightstep> yes
09:03:51 <tibbe> what about a nested do? "do (do bla catch bla) always"
09:04:04 <tibbe> or hmm
09:11:22 <dcoutts_> g'evening SyntaxNinja 
09:23:00 <SyntaxNinja> hiya dcoutts
09:23:28 <SyntaxNinja> dcoutts_: hows that cabal-setup (or whatever) tool going?
09:30:27 <dcoutts_> SyntaxNinja, I've got something working
09:30:44 <dcoutts_> SyntaxNinja, I need to make it grok a few more command line args
09:30:57 <dcoutts_> to handle all the corner cases
09:31:58 <dcoutts_> SyntaxNinja, one thing I was wondering, currently it checks for the right Cabal package every time you run it, so it'd do that each time you say build, clean, etc. I'm wondering if I can avoid doing it every time
09:32:25 <dcoutts_> eg to build the setup binary and then reuse that unless the user does clean or configure again
09:33:23 <dcoutts_> SyntaxNinja, so I'd stash the setup binary somewhere under dist/ eg dist/setup/
09:33:42 <dcoutts_> and put the .hi/.o files for the Setup.lhs there too
09:34:16 <lightstep> is there a combined read and write operation for arrays?
09:34:47 <SyntaxNinja> dcoutts_: sounds pretty good
10:15:23 <Lemmih> No more trouble writing :set -fno-monomorphism-restriction -fglasgow-exts! (:
10:16:19 <xerox> Great :-)
10:16:48 <xerox> You found that it is possible to setup a startup file?  <blink>
10:35:49 <Igloo> Hmm, how am I meant to get an alignment for a Storable instance with hsc2hs?
10:41:55 <dcoutts_> Igloo, I thought I knew, but actually I don't. :-)
10:42:18 <dcoutts_> in gtk2hs we hack it with things like: alignment _ = alignment (undefined::#type gint)
10:43:15 <dcoutts_> Igloo, I reckon you could add to hsc2hs by adding a macro that expands to something that uses gcc's __alignof extension
10:44:32 <Igloo> Hmm, I can do that with #const __alignof(Foo), but not being portable is irritating
10:45:45 <dcoutts_> Igloo, are you planning on porting to a platform that doesn't have gcc ?
10:46:23 <Igloo> Even if I don't, someone else might
10:46:46 <dcoutts_> I think it'd be the least of your/their worries
10:50:00 <Lemmih> You record an UNDO patch with `darcs rollback', right?
10:51:34 <Igloo> Yup
10:55:12 <Lemmih> How do I undo a tag? ssh + unpull?
10:59:19 <Igloo> yup
11:06:44 <greenrd> I'm trying to combine the use of two kinds of state: an STArray, for in-place update, and a random number generator (for which I've previously used the State monad)
11:07:23 <greenrd> Do I need to use both the ST and State monads, or can I use one ST monad for both purposes at once?
11:08:46 <monochrom> I would use StateT over ST.  The StateT part will add the random number generator.
11:11:52 <monochrom> i.e., something like: type Mine a = StateT StdGen ST a
11:13:28 <monochrom> Thus, all calls to the STArray commands need a lifting. But I think your existing code for manipulating the random generator state needs little change.
11:13:35 <ski> if you put the RNG in ST, then you need to pass around the ref to it, somehow
11:13:46 <ski> (e.g. by wrapping a ReaderT around ST)
11:13:48 <tromp> to avoid all the lifting you can put the rng in an stref
11:14:19 <tromp> seems easier
11:14:40 <ski> tromp : how to you propose passing around the stref ?
11:15:00 <tromp> just by scoping
11:15:10 <ski> hm, yes, just thought of that
11:16:07 <monochrom> There is a module import-hide trick for alleviating the lifting.
11:16:46 <tromp> once you do rng <- newSTRef you can use it anywhere in the monadic computation
11:16:51 <monochrom> e.g., import qualified STArray(newSTArray); newSTArray = lift STArray.newSTArray
11:17:09 <tromp> with a readSTRef
11:17:36 <monochrom> Thus, just need to add the lifting in one place.  Then the existing code need little change.
11:18:05 <monochrom> Ain't I smart?  Someone please increase my Karma :)
11:18:37 <pesco> @karma+ monochrom
11:18:38 <tromp> i'll refrain from lowering it. how's that:-?
11:18:38 <lambdabot> monochrom's karma raised to 1.
11:18:54 <monochrom> heh tromp 
11:18:54 <pesco> Yep, just hope that begging for karma isn't bad karma. ;)
11:24:14 <ibid> instant karma's gonna get you
11:27:52 <pesco> Hm, is there a particular reason why STM is not in MonadFix?
12:01:14 <greenrd> Some of my function types are inferred as returning GHC.ST.ST () ()
12:01:18 <greenrd> This looks bogus - is it?
12:01:30 <Lemmih> dcoutts_: I'm starting to think that the dynamic architecture of hIDE is more trouble than it's worth.
12:04:23 <greenrd> @hoogle elems
12:04:24 <lambdabot> Data.Array.IArray.elems :: (IArray a e, Ix i) => a i e -> [e]
12:04:24 <lambdabot> Data.Array.elems :: Ix i => Array i e -> [e]
12:04:24 <lambdabot> Data.IntMap.elems :: IntMap a -> [a]
12:05:31 <greenrd> Yup, it is bogus
12:05:51 <greenrd> I get "Inferred type is less polymorphic than expected"
12:06:00 <greenrd> "Quantified type variable `s' is mentioned in the environment"
12:11:51 <UncleD> I broke haskell.
12:12:13 <pesco> Nooooo!
12:12:17 * pesco runs around screaming
12:12:20 <UncleD> it's ok. I fix it too!
12:12:30 <UncleD> altho it's called UncleDaskell now!
12:12:37 <pesco> Nooooooo!
12:12:42 <monochrom> I prefer Haskell'
12:12:49 <UncleD> well nobody asked u :P
12:12:50 <pesco> Haskell Prime!
12:13:02 <UncleD> prime encryption! factor haskell!
12:13:38 <pesco> Haskell' is good.
12:13:56 <greenrd> @hoogle traverse_
12:13:57 <lambdabot> No matches found
12:15:03 * pesco imagines Giedi Prime.
12:15:39 <UncleD> pesco, i noticed it's doing wlell in that competition
12:15:57 <pesco> Maybe we can get H.R. Gieger to draw us a logo...
12:16:03 <pesco> UncleD: Which competition?
12:16:40 <greenrd> bizarre
12:16:47 <greenrd> I think I've found a ghc bug
12:18:24 <Lemmih> I think you've found the monomorphism restriction.
12:21:39 <star-trekio> is haskell more powerful than perl?
12:21:45 <star-trekio> or scheme?
12:21:58 <monochrom> No.
12:22:01 <pesco> No.
12:22:02 <pesco> :)
12:22:31 <Saulzar> What is "more powerful" ?
12:22:45 <monochrom> permits more bugs
12:22:55 <greenrd> Lemmih, no, it was inferring the type of a previous function completely incorrectly
12:23:11 <greenrd> Once I put in the correct type signature for that function, it compiled
12:23:40 <Lemmih> greenrd: Exactly.
12:24:23 <greenrd> But why would this "monomorphism restriction" (whatever that is) cause it to get the type signature just plain wrong?
12:26:42 <ibid> are the fuctions toplevel or local?
12:26:56 <ibid> functions
12:28:33 <ibid> (this doesn't sound like the monomorphism restriction to me, but not sure, not having seen the code)
12:29:24 <ibid> hrm, adding the type signature worked? ok. not what i was thinking about
12:29:26 <greenrd> toplevel
12:30:20 <Lemmih> greenrd: Try compiling with -fno-monomorphism-restriction
12:30:29 <ibid> are they defined as foo = ... or as foo x y z = ... ?
12:31:14 <Beelsebob> Beelsebob|Home: @seen andi
12:31:15 <Beelsebob> lambdabot: seen module failed: SeenModule.nickIsNew: Nothing
12:31:21 <Beelsebob> @seen andi
12:31:22 <lambdabot> I haven't seen andi.
12:32:02 <star-trekio> can haskell do abstractions that scheme cant?
12:32:06 <star-trekio> or something?
12:32:10 <star-trekio> is haskella lisp?
12:32:33 <Lemmih> star-trekio: No.
12:34:18 <Lemmih> @wiki HaskellDemo
12:34:19 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
12:34:25 <jonkri> how can i with list comprehension do so that the list [1, 2, 1, 1, 2] is converted to [3, 4, 3, 3, 4]?
12:35:08 <Lemmih> > [ i+2 | i <- [1, 2, 1, 1, 2]]
12:35:09 <lambdabot> [3,4,3,3,4]
12:35:29 <Beelsebob> let f xs = [x + 2 | x <- xs] in f [1,2,1,1,2]
12:35:39 <Beelsebob> > let f xs = [x + 2 | x <- xs] in f [1,2,1,1,2]
12:35:40 <lambdabot> [3,4,3,3,4]
12:37:06 * resiak hands out map
12:37:53 <monochrom> head [ [3, 4, 3, 3, 4] | s <- [[1, 2, 1, 1, 2]] ]
12:38:08 <Lemmih> heh (:
12:38:39 <cm> hey
12:38:45 <tromp> :-P
12:38:46 <Lemmih> Heya cm.
12:40:51 <star-trekio> so what in hell is haskell for?
12:40:58 <star-trekio> why did someone create haskell?
12:41:00 <Beelsebob> star-trekio: *EVERYTHING*
12:41:01 <star-trekio> I dont get it
12:41:10 <Beelsebob> because it's better than anything else out there
12:41:10 <star-trekio> can u build things fast in haskell?
12:41:14 <Beelsebob> yes
12:41:16 <greenrd> star-trekio, for research purposes
12:41:19 <wilx> Some people wanted lazy language.
12:41:21 <star-trekio> so its better than smalltalk
12:41:26 <star-trekio> and clsip?
12:41:27 <star-trekio> clisp?
12:41:33 <star-trekio> those guys say their langs are good
12:41:38 <wilx> Heh.
12:41:39 <wilx> Trolling?
12:41:41 <star-trekio> how does the haskell beat em
12:41:49 <Beelsebob> greenrd: actually, that's debatable, CR wanted it for research for example, but a lot of others didn't
12:41:55 <star-trekio> so lazy=modify 1 part and other ats of program dont care
12:42:05 <star-trekio> makes buildinig big programs ez?
12:42:08 <Beelsebob> star-trekio: no, that's refferentially transparent
12:42:17 <Beelsebob> in fact no...
12:42:19 <Beelsebob> it's not even that
12:42:24 <Beelsebob> that's just good design
12:43:07 <astrolabe> star-trekio: You'll have to try it to be sure.  I find coding in haskell makes me think more than coding in other languages, but that the final code is nicer.
12:43:12 <tromp> haskell just hits the spot
12:43:28 <astrolabe> Yeah
12:44:57 * astrolabe assumes tromp is wondering what my code in other languages is like, and shudering.
12:45:30 <jonkri> oh, thank you, and of course, Lemmih and Beelsebob, allthough this was not the desired effect (my fault): i want to change them without using math. example: ['a', '%', '%', 'a'] to [6, 'g', 'g', 6]
12:45:53 <Beelsebob> hmm, you want a random mapping?
12:46:10 <Beelsebob> and the latter list is not type safe
12:46:15 <Beelsebob> so that one's not possible
12:46:31 <jonkri> ok, i don't want random, and i want type safe
12:46:35 <monochrom> No one beats anyone.
12:46:43 <Beelsebob> so what do you want in the second list?
12:46:45 <jonkri> say ['a', '%', '%', 'a'] to ['6', 'g', 'g', '6']
12:46:49 <pesco> monochrom restoring order. :)
12:46:59 <tromp> i guess it's more verbose:)
12:46:59 <tromp> haskell is the worst possible language
12:47:03 <tromp> for writing buggy code
12:47:08 <Beelsebob> jonkri: so how does what's in the second list relate to what's in the first?
12:47:25 <jonkri> Beelsebob: it doesn't, that's what's make it tricky
12:47:32 <Beelsebob> so you want a random mapping?
12:47:52 <jonkri> ok, it's related like: 'a' -> '6', '%' -> 'g'
12:48:03 <jonkri> sorry :o)
12:48:43 <Lemmih> > let fn 'a' = '6'; fn '%' = 'g' in [ fn c | c <- ['a', '%', '%', 'a'] ]
12:48:45 <lambdabot> "6gg6"
12:49:00 <jonkri> that's nice
12:49:04 <Beelsebob> you'd have to generate a random mapping in the IO monad, and then pass it to the function
12:49:18 <jonkri> i don't want random mapping, sorry i confused you
12:49:29 <jonkri> i didn't think that i could write a function :-)
12:49:31 <astrolabe> An arbitrary mapping?
12:49:44 <jonkri> astrolabe: i have two types i want to replace with another type
12:49:49 <tromp> a specific but unspecified mapping:)
12:49:54 <jonkri> astrolabe: a given value for each value
12:50:08 <jonkri> tromp: yeah, something like that :-)
12:50:12 <astrolabe> Sounds like a map to  me.
12:50:31 <jonkri> yeah, ok
12:51:09 <musasabi> I had an idea for a FFI_LIB pragma to carry around library dependencies (like INCLUDE does for include files). Is this worth formulating better or a flawed concept?
12:51:20 <pesco> jonkri: So define a function f :: Char -> Char. To give the definition for each input, just write an equation like "f 'a' = '6'" for each case, one ofter another.
12:51:27 <musasabi> http://youzen.b2.fi/~musasabi/ffi_lib.txt has a tiny description.
12:51:45 <greenrd> Can I import just individual functions from a module?
12:51:50 <jonkri> pesco: yeah, thanks :-)
12:51:56 <pesco> jonkri: Then apply that function to each element of your list. (map)
12:52:11 <jonkri> local functions (functions defined with 'where') can't have defined input and output, right?
12:52:28 <Beelsebob> alternatively...
12:52:28 <Beelsebob> > let mapping = [('a','6'),('%','g')]; f x = lookup x mapping in [f x | x <- "a%%a"]
12:52:30 <lambdabot> [Just '6',Just 'g',Just 'g',Just '6']
12:52:35 <pesco> jonkri: Don't know what you mean, but I suspect the answer is "yes they can"
12:52:58 <Beelsebob> > let mapping = [('a','6'),('%','g')]; f x = (\(Just y) -> y) $ lookup x mapping in [f x | x <- "a%%a"]
12:53:00 <lambdabot> "6gg6"
12:53:06 <pesco> jonkri: Definitions in a where clause work the same as at the top-level.
12:53:12 <musasabi> greenrd: use import ModuleName(functionName)
12:53:17 <greenrd> musasabi, thanks
12:53:30 <greenrd> Is there a way to automatically generate such specific imports?
12:53:30 <jonkri> ok
12:53:37 <jonkri> pesco: can you give me an example?
12:54:01 <greenrd> I guess that would be an ideal feature for the haskell plugin for eclipse, if it doesn't already have it
12:54:10 <Beelsebob> > let mapping1 = [('a','6'),('%','g')]; mapping2 = [('a','b'),('%','#')]; f x m = (\(Just y) -> y) $ lookup x m in [f x mapping1 | x <- "a%%a"] ++ [f x mapping2 | x <- "a%%a"]
12:54:12 <lambdabot> "6gg6b##b"
12:54:16 <tibbe> @type \x -> x x
12:54:18 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
12:54:18 <lambdabot>   Expected type: t
12:54:56 <tibbe> shouldn't id be appliable to itself?
12:55:14 <pesco> > xs = take 5 $ iterate f 0; where f 0 = 1; f 1 = 1; f n = f (n-1) + f (n-2)
12:55:16 <lambdabot>  parse error on input `='
12:55:40 <ibid> @type id id
12:55:41 <lambdabot> forall a. a -> a
12:56:14 <pesco> jonkri: xs = take 5 (iterate f 0)
12:56:28 <pesco> jonkri:   where f 0 = 1
12:56:33 <pesco> jonkri:   where f 1 = 1
12:56:42 <pesco> jonkri:   where f n = f (n-1) + f (n-2)
12:56:48 <pesco> eek.
12:56:55 <pesco> strike the last two "where"
12:56:55 <ibid> pesco: you had an extra semicolon in your original, i think
12:56:55 <jonkri> aha, ok
12:56:59 <pesco> ibid: Yes.
12:57:07 <ibid> > xs = take 5 $ iterate f 0 where f 0 = 1; f 1 = 1; f n = f (n-1) + f (n-2)
12:57:08 <lambdabot>  parse error on input `='
12:57:12 <ibid> hrm
12:57:13 <pesco> ibid: But I also noticed that eval whon't take the where.
12:57:20 <pesco> ibid: Because it expects an expression.
12:57:26 <jonkri> pesco: but what if you would want to specify the type of the output on one of those where lines?
12:57:27 <ibid> > let xs = take 5 $ iterate f 0 where f 0 = 1; f 1 = 1; f n = f (n-1) + f (n-2) in xs
12:57:28 <lambdabot> [0,1,1,1,1]
12:57:53 <ibid> pesco: actually, the problem was you gave it an equation, and it expects and expression :)
12:58:00 <ibid> pesco: let is a useful thing to have ;)
12:58:09 <pesco> ibid: Yes, I noticed.
12:58:39 <pesco> jonkri: You can also give a type signature in the where clause.
12:58:49 <jonkri> pesco: how?
12:59:04 <pesco> jonkri: Just like on the top level, just indented to the where.
12:59:23 <jonkri> hmm, ok
12:59:32 <ibid> > let xs = take 5 $ iterate f 0 where f::Int->Int; f 0 = 1; f 1 = 1; f n = f (n-1) + f (n-2) in xs
12:59:33 <lambdabot> [0,1,1,1,1]
12:59:35 <ibid> :)
13:00:36 <tromp> > let xs = take 5 $ iterate $ product $ enumFromTo 1
13:00:37 <lambdabot>  parse error on input `}'
13:00:55 <jonkri> :r
13:00:57 <jonkri> hahaha
13:00:59 <jonkri> sorry for that
13:01:38 <tromp> > take 5 $ iterate $ product $ enumFromTo 1
13:01:39 <lambdabot>   Expecting a function type, but found `a'
13:01:39 <lambdabot>   Expected type: [a]
13:01:39 <lambdabot>   Inferred type: a1 -> [a1]
13:01:59 <tromp> > take 5 $ iterate $ product . enumFromTo 1
13:02:00 <lambdabot> Couldn't match `[a]' against `a1 -> [a1]'
13:02:20 <ibid> > take 5 $ iterate product $ enumFromTo 1
13:02:21 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:02:21 <lambdabot>   Expected type: [a] -> [a]
13:02:21 <lambdabot>   Inferred type: [a] -> a
13:02:30 <ibid> hrm
13:02:45 <ibid> @type iterate
13:02:46 <lambdabot> forall a. (a -> a) -> a -> [a]
13:03:12 <ibid> ok. i have no idea what you're trying to say with that haskell bit :)
13:03:28 <jonkri> can i type:
13:03:33 <jonkri> f :: Int -> Int
13:03:41 <tromp> > take 5 $ iterate (product . enumFromTo 1) 0
13:03:42 <jonkri> f x = f2 x
13:03:43 <lambdabot> [0,1,1,1,1]
13:03:45 <jonkri> where
13:03:53 <jonkri> f2 :: Int -> Int
13:04:02 <jonkri> f2 y = 2y
13:04:02 <jonkri> ?
13:04:21 <ibid> 2y is a syntax error
13:04:45 <ibid> well, type error, actually
13:04:48 <ibid> > 2y
13:04:49 <lambdabot>  Not in scope: `y'
13:04:58 <ibid> > let y = 4 in 2y
13:04:59 <lambdabot>  add an instance declaration for (Num (t -> a))
13:04:59 <lambdabot>   In the definition of `bxk': bxk = let y = 4 in 2 y
13:04:59 <lambdabot>   In the definition of `v': v = let bxk = let ... in ... in take 2048 (
13:04:59 <lambdabot> show bxk)
13:05:07 <jonkri> well, but would it work otherwise?
13:05:23 <Cale> > let y = 4 in 2 * y
13:05:25 <ibid> jonkri: depends on what the "2y" is supposed to be :)
13:05:25 <lambdabot> 8
13:05:30 <jonkri> ibid: 2 * y
13:05:33 <ibid> ok
13:05:41 <ibid> jonkri: i don't see why not
13:05:50 <jonkri> ok, thanks
13:06:27 <ibid> @type let f :: Int -> Int; f x = f2 x where f2 :: Int -> Int ; f2 y = 2 * y in f
13:06:28 <lambdabot> Int -> Int; f x = f2 x where f2 :: Int -> Int ; f2 y = 2 * y in f :: Int -
13:06:28 <lambdabot> > Int
13:06:43 <ibid> whaaa?
13:07:01 <ibid> > let f :: Int -> Int; f x = f2 x where f2 :: Int -> Int ; f2 y = 2 * y in f 2
13:07:02 <lambdabot> 4
13:07:07 <ibid> seems to work
13:07:10 <xerox> ouch
13:07:20 <jonkri> thanks
13:08:59 <palomer> don't you guys think it's a pain that you have to have two sets of functions in the library, one monadic and one not monadic?
13:09:26 <palomer> @hoogle sortby
13:09:27 <lambdabot> Data.List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
13:09:30 <Cale> In cases where the polymorphic version takes care of it, yeah
13:09:45 <palomer> like sortBy and sortByM
13:09:59 <flux__> @hoogle sortByM
13:10:00 <lambdabot> No matches found
13:10:21 <ibid> well, just define instance Monad a where  ;)
13:11:25 <palomer> sortByM would have type  (Monad m) => (a -> a -> m Ordering) -> [a] -> m [a]
13:12:09 <jonkri> i have a datatype called "Maybe World"
13:12:13 <ibid> i'm sure there's a liftSomethingM that'll take care of that ;)
13:12:18 <palomer> ibid: nope
13:12:39 <palomer> or, rather, I highly doubt it
13:12:40 <ibid> palomer: yeah, it's actually impossible, i'd wager
13:12:46 <jonkri> sorry, it's world
13:12:54 <palomer> ibid: to write such a function?
13:13:01 <ibid> palomer: yes
13:13:03 <palomer> ibid: how so?
13:13:27 <ibid> palomer: i mean, so that liftSomethingM sortBy yields sortByM
13:13:33 <palomer> oh, righto
13:13:46 <jonkri> let me rephrase: i have a datatype which should return Maybe World (that is a "World", or "Nothing"). but when i call my function that creates the world (and outputs "World") i get type error, because it should return "Maybe World". can i get around this?
13:13:47 <Cale> I don't think it's doable like that
13:13:58 <palomer> but, yeah, if you're doing everything monadically (which I am), you end up needing a monadic copy of everything
13:14:13 <jonkri> i have another function that creates the world, which should always return a world (i have already validated the input)
13:14:20 <Cale> jonkri: It needs to return 'Just x' for some x or 'Nothing'
13:14:35 <jonkri> ah, that's right
13:14:40 <jonkri> thanks cale
13:14:44 <Cale> no problem
13:15:09 <Cale> palomer: well, sortByM has a rather different flavour from sortBy
13:15:19 <Cale> sortByM is a lot harder to think about
13:15:37 <palomer> how so?
13:15:47 <Cale> you have to know the internal sorting algorithm it uses to have any idea what it's going to do in terms of side-effects
13:16:04 <Cale> With sortBy, the internal sorting algorithm can't be observed.
13:16:28 <palomer> give me a function that, given two values, gives me a way to compute their ordering, and give me a list of these values, and I'll give you a way to compute the sorted list
13:16:55 <Cale> Right, but you're allowing that computation of the ordering to have side effects
13:17:19 <monochrom> I agree with Cale.  Your sortByM is highly underspecified.
13:17:36 <palomer> monochrom: but is nonetheless incredibly useful
13:17:46 <palomer> and, besides, sometimes it doesn't have any side effects
13:17:54 <Cale> Each sorting algorithm will give rise to different computations
13:17:59 <palomer> like, for example, I need to readSTRef to be able to compare
13:18:09 <palomer> readSTRef does not have any side effects
13:18:46 <palomer> Cale: so there is a sortByM for every sorting algorithm? this doesn't bother me
13:19:06 <monochrom> Well, I think you have a particular monad in mind and sortByM is sensible and useful for that particular monad for sure.  But I think asking for generalizing it to all monads is gratuitous.
13:19:06 <palomer> note that sorting, by itself, isn't completely specified either
13:19:15 <Cale> I noticed that it's (a -> a -> m Ordering) -- so the elements you're sorting aren't in the monad?
13:19:47 <palomer> Cale: what do you mean "aren't in the monad"?
13:20:01 <ibid> Cale: it's rare to have monadic arguments
13:20:25 <ibid> Cale: for any function that's not controllish
13:20:55 <Cale> palomer: could you make it clearer what the (a -> a -> m Ordering) which you'd pass looks like?
13:21:24 <palomer> sure, say I have a list of STRef s Int
13:21:55 <palomer> \x y -> liftM2 (<) (readSTRef x) (readSTRef y)
13:22:05 <palomer> that should work (I think)
13:22:47 <Cale> why not read the STRef's efore sorting?
13:22:49 <palomer> actually, no, that seems wrong
13:22:50 <Cale> before*
13:23:00 <palomer> you have  a point
13:23:56 <palomer> hrmph, my datatype is much more complicated than that though
13:24:20 <palomer> and I have a function D s -> D s -> ST s Bool
13:24:27 <palomer> you're right, I want (m a -> m a -> m Ordering)
13:24:43 <Cale> I thought you might :)
13:24:50 <palomer> so (m a -> m a -> m ordering) -> m [a] -> m [a]
13:24:59 <Cale> (m a -> m a -> m ordering) -> [m a] -> m [a]
13:25:05 <palomer> oh,righto
13:28:15 <palomer> so...can this be done?
13:28:40 <Cale> well, you can write a monadic sorting algorithm
13:29:17 <tromp> but wouldnt the first arg just be a lifted comparison?
13:29:55 <tromp> in which case you can just use sequence and sortBy
13:30:09 <Cale> hmm
13:30:14 <palomer> Cale: right, but I have to do this for everything function i meet, including nub, partition, etc...
13:30:24 <palomer> s/everything/every
13:30:48 <ibid> just make all take monadic arguments and define instance Monad a ;)
13:31:38 <palomer> ibid: hmm?
13:31:40 <flux__> hmm.. one could use (m a -> m a -> m ordering) -> [m a] -> m [m a], which is the same as (a -> a -> m ordering) -> [a] -> m [a]?
13:31:49 <Cale> palomer: I'd avoid that sort of design. Those functions become control nightmares if you allow side effects to happen in the middle of them
13:31:50 <ibid> palomer: a lame joke
13:31:59 <flux__> because a may be m a?
13:32:26 <palomer> Cale: I'm working in ST, I have no choice, really
13:32:30 <Cale> palomer: it's much better if you can bind/sequence things beforehand and then do the comparison.
13:32:58 <Cale> Like we did with the STRefs
13:33:04 <palomer> hmm?
13:33:23 <palomer> ok, I have a list of list of STRef s Int, how do I sort them?
13:34:39 <tromp> do a mapM readSTRef and sort the result
13:34:54 <tromp> oh, a list of lists?
13:35:29 <palomer> so you guys are suggesting that I should runST every time I want to sort?
13:35:30 <tromp> you don't want to flatten them?
13:35:51 <Cale> not runST
13:35:51 <palomer> isn't that...inefficient?
13:35:53 <Cale> you're in ST
13:36:02 <Cale> you don't have to call runST to run things :)
13:36:08 <tromp> no, the sorted stuff is just another ST computation
13:36:59 <tromp> i'm reminded of the ole Atari ST computer:)
13:37:05 <Cale> sortSTRefs :: [STRef s Int] -> ST s [STRef s Int]
13:37:05 <Cale> sortSTRefs xs = do
13:37:05 <Cale>     ys <- mapM readSTRef xs
13:37:05 <Cale>     let (ys', xs') = unzip $ sortBy (comparing fst) (zip ys xs)
13:37:05 <Cale>     return xs'
13:38:43 <tromp> what does your application do?
13:38:57 <palomer> ok, but I have a newtype Blah = Blah ([SType s])
13:39:06 <palomer> tromp: solves unification problems
13:39:09 <monochrom> do { xs <- mapM readSTRef rs; let sorted = sortBy (\(x,_) (y,_) -> compare x y) (zip xs rs); return (map snd sorted) }
13:40:01 <palomer> err, Blah s = Blah [SType s]
13:40:21 <palomer> and I have a function [SType s] ->[SType s] -> ST s Bool
13:40:38 <monochrom> @hoogle comparing
13:40:40 <lambdabot> No matches found
13:40:58 <Cale> comparing p x y = compare (p x) (p y)
13:46:49 <palomer> Cale: hmm?
13:46:54 <UncleD> whatchoo doin cale!
13:46:59 <UncleD> don't be breakin haskell
13:59:06 <palomer> if I have an [m a], how do I get an m [a] out?
13:59:24 <basti_> sequence
13:59:34 <basti_> @type Control.Monad.sequence
13:59:35 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:59:49 <basti_> @hoogle [m a] -> m [a]
13:59:50 <lambdabot> Data.List.head :: [a] -> a
13:59:50 <lambdabot> Data.List.last :: [a] -> a
13:59:50 <lambdabot> Prelude.head :: [a] -> a
14:00:10 <palomer> why is it called sequence?
14:00:39 <basti_> because it sequences the list elements
14:00:56 <basti_> it folds something like >>= over the list
14:01:03 <basti_> thats like, doing everything sequentially
14:01:40 <basti_> a >>= b >>= c >>= d   does a, b, c, d sequentially, too. Or something pretty close to that notion.
14:19:49 <palomer> http://www.rafb.net/paste/results/tl3YaQ25.html <---eh?
14:22:38 * wli could've sworn there were libraries for image file formats in Haskell floating around somewhere.
14:23:53 <SyntaxNinja> hi wli!
14:24:12 <wli> re SyntaxNinja
14:25:40 <SyntaxNinja> wli: you really should get sushi with us sometime.
14:26:35 <Cale> wli: I'd written a binding to Imlib 2 at one point.
14:26:43 <wli> hmm
14:27:04 * palomer kills self as algorithm doesn't seem to want to work
14:27:12 <wli> The least common denominator is probably ppm if I can't be arsed to deal with imlib2.
14:28:31 <palomer> how do you generate all sublists of a list?
14:28:42 <wli> (you really can't get any stupider than ppm; google for "PPM format specification")
14:28:57 <palomer> @hoogle [a] -> [[a]]
14:28:59 <lambdabot> Data.List.inits :: [a] -> [[a]]
14:28:59 <lambdabot> Data.List.tails :: [a] -> [[a]]
14:28:59 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
14:29:37 <wli> I shudder to think how long a 5-minute-long silent video would be encoded as a bunch of PPM frames, though.
14:33:21 <palomer> let sublists (h:t) =    (h:t) ++ (sublists t) ++ (h:sublists t) ; sublists [] = [] in sublists [1,2,3]
14:33:26 <palomer> > let sublists (h:t) =    (h:t) ++ (sublists t) ++ (h:sublists t) ; sublists [] = [] in sublists [1,2,3]
14:33:28 <lambdabot> [1,2,3,2,3,3,3,2,3,3,1,2,3,3,3,2,3,3]
14:33:41 <palomer> > let sublists (h:t) =    (h:t) ++ (sublists t) ++ (h:sublists t) ; sublists [] = [[]] in sublists [1,2,3]
14:33:42 <lambdabot>  add an instance declaration for (Num [a])
14:33:42 <lambdabot>   In the list element: 3
14:33:52 <Marc> Are most fptools used by other compilers than ghc as well?
14:33:59 <palomer> > let sublists (h:t) =    (h:t) : ((sublists t) ++ (h:sublists t)) ; sublists [] = [[]] in sublists [1,2,3]
14:34:00 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:34:00 <lambdabot>   Expected type: [[a]]
14:34:00 <lambdabot>   Inferred type: [a]
14:34:15 <Marc> I'm asking because most seems to be done with Makefiles which isn't necessary when using ghc, is it?
14:34:42 <palomer> I use makefiles with ghc
14:34:43 <xerox> palomer: what are you trying to code?
14:34:46 <palomer> I use makefiles with everything
14:34:50 <palomer> xerox: all sublists of a list
14:35:01 <xerox> palomer: permutations?
14:35:06 <Cale> > (map inits . tails) [1,2,3,4]
14:35:08 <lambdabot> [[[],[1],[1,2],[1,2,3],[1,2,3,4]],[[],[2],[2,3],[2,3,4]],[[],[3],[3,4]],[[
14:35:08 <lambdabot> ],[4]],[[]]]
14:35:11 <Marc> palomer:  Why?
14:35:23 <xerox> > [1,2,3,4] >> inits . tails
14:35:24 <lambdabot>   Expecting a function type, but found `m b'
14:35:24 <lambdabot>   Expected type: [b]
14:35:24 <lambdabot>   Inferred type: [a] -> [[[a]]]
14:35:27 <Cale> > (map (drop 1 . inits) . tails) [1,2,3,4]
14:35:29 <palomer> > length (map inits . tails) [1,2,3,4]
14:35:29 <lambdabot> [[[1],[1,2],[1,2,3],[1,2,3,4]],[[2],[2,3],[2,3,4]],[[3],[3,4]],[[4]],[]]
14:35:31 <lambdabot>   The function `length' is applied to two arguments,
14:35:31 <lambdabot>   but its type `[a] -> Int' has only one
14:35:31 <lambdabot>   In the definition of `kfq': kfq = length ((map inits) . tails) [1, 2, 3,
14:35:31 <lambdabot> 4]
14:35:31 <xerox> err.
14:35:44 <palomer> > length  (map inits . tails) [1,2,3,4]
14:35:46 <lambdabot>   The function `length' is applied to two arguments,
14:35:46 <lambdabot>   but its type `[a] -> Int' has only one
14:35:46 <lambdabot>   In the definition of `ugr': ugr = length ((map inits) . tails) [1, 2, 3,
14:35:46 <lambdabot> 4]
14:35:47 <palomer> > length $ (map inits . tails) [1,2,3,4]
14:35:49 <lambdabot> 5
14:35:52 <Cale> > length $ (map (drop 1 . inits) . tails) [1,2,3,4]
14:35:54 <lambdabot> 5
14:36:10 <palomer> that should be 16
14:36:11 <Marc> palomer:  Isn't it less work to just have one target in your makefile: ghc --make?
14:36:11 <Cale> > concatMap (drop 1 . inits) . tails) [1,2,3,4]
14:36:11 <xerox> > length $ (concatMap (drop 1 . inits) . tails) [1,2,3,4]
14:36:13 <lambdabot>  parse error on input `)'
14:36:13 <lambdabot> 10
14:36:16 <palomer> xerox: no, subsets
14:36:21 <Cale> oh, combinations
14:37:00 <palomer> Marc: yeah, but a program is rarely just a ghc build
14:37:06 <Cale> > let combs [] = [[]]; combs (x:xs) = combs xs ++ map (x:) (combs xs) in combs [1,2,3,4]
14:37:08 <lambdabot> [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[
14:37:08 <lambdabot> 1,2,4],[1,2,3],[1,2,3,4]]
14:37:24 <palomer> nice
14:37:30 <Cale> > let combs [] = [[]]; combs (x:xs) = map (x:) (combs xs) ++ combs xs in combs [1,2,3,4]
14:37:32 <lambdabot> [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,
14:37:32 <lambdabot> 4],[2],[3,4],[3],[4],[]]
14:37:41 <palomer> what did you understand by sublist?
14:38:06 <Cale> I took that to mean a contiguous interval of elements from the list
14:38:28 <palomer> I see a list as a sequence
14:38:33 <palomer> subsequence == sublist in my mind
14:38:55 <Cale> yeah, that's another way to interpret the word :)
14:39:38 <palomer> why would sublists be contiguous?
14:40:06 <Saulzar> If a list is a sequence...
14:40:42 <Saulzar> I would assume a sequence was continuous
14:40:52 <Saulzar> subset would be less ambigous
14:41:07 <Cale> depends if you're preserving adjacency, or just containment, or containment + order
14:42:31 <palomer> @hoogle filterM
14:42:32 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
14:42:32 <lambdabot> Graphics.UI.ObjectIO.CommonDef.filterMap :: (x -> (Bool, y)) -> [x] -> [y]
14:42:32 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context
14:42:32 <lambdabot> a b -> Bool) -> GT m (gr a b) [Context a b]
14:42:35 <Marc> palomer. It's just: fptools is using some strange meachnism: it seems that you call make boot to create .depends files which in turn are read by a makefile to do all the stuff. I don't see the reason.
14:49:17 <palomer> ok, here's another challenge, given x, return all (a,b) where a U b = x 
14:50:12 <xerox> U ?
14:50:34 <palomer> union
14:50:45 <xerox> What are the types of x, a and b ?
14:51:27 <palomer> the function has type [a] -> [([a],[a])]
14:52:10 <monochrom> Set -> [(Set, Set)]
14:52:27 <Saulzar> Is that not the same as finding for each permutation of x, also split at each point?
14:52:27 <xerox> \u x -> filter (\a b -> (a `u` b) == x)
14:52:28 <xerox> ?
14:52:35 <Beelsebob> f x = [(a,b) | a <- comb x, b <- comb x, union a b == x]
14:52:43 <Beelsebob> there's a naïve one
14:52:43 <xerox> Uh.
14:53:05 <Cale> should we assume that the elements of the list are distinct?
14:53:14 <palomer> Cale: yes
14:53:27 <palomer> and we don't have a computable union function
14:54:23 <monochrom> Why is it not computable?
14:54:42 <xerox> Goodnight.
14:54:45 * Saulzar guesses it is because they're STRefs 
14:54:51 <monochrom> (How do you represent a set? What can a set be?)
14:55:04 <palomer> they're lists
14:55:26 <monochrom> If they're finite lists, List.union should do.
14:55:29 <Beelsebob> why not a Data.Set?
14:55:42 <palomer> because I don't have equality between terms
14:55:51 <palomer> thats the deal
14:56:03 <Beelsebob> so, you're going on trust that they are not equal?
14:56:26 <palomer> what's not equal?
14:56:34 <palomer> I can assume that all the elements in my list are distinct
14:56:35 <Beelsebob> the items in the 'set'
14:57:41 <monochrom> If you know how to answer "is x member of set S" you're game.
14:57:42 <Cale> > let splits [] = [([],[])]; splits (x:xs) = do {(u,v) <- splits xs; [(x:u,v), (u,x:v)]} in splits [1,2,3]
14:57:44 <lambdabot> [([1,2,3],[]),([2,3],[1]),([1,3],[2]),([3],[1,2]),([1,2],[3]),([2],[1,3]),
14:57:44 <lambdabot> ([1],[2,3]),([],[1,2,3])]
14:58:15 <palomer> yeah, that should work
14:58:22 <palomer> how does it work:O?
14:58:28 <Beelsebob> let comb [] = []; comb (x:xs) = comb xs ++ (map (:x) $ comb xs); f x = [(a,b) | a <- comb x, b <- comb x, List.union a b == x] in f [1,2,3]
14:58:35 <Beelsebob> > let comb [] = []; comb (x:xs) = comb xs ++ (map (:x) $ comb xs); f x = [(a,b) | a <- comb x, b <- comb x, List.union a b == x] in f [1,2,3]
14:58:36 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:58:36 <lambdabot>   Expected type: [a]
14:58:36 <lambdabot>   Inferred type: [[a]]
14:58:39 <Beelsebob> no then
14:58:40 <Beelsebob> hehe
14:59:12 <Beelsebob> > let comb [] = [[]]; comb (x:xs) = comb xs ++ (map (:x) $ comb xs); f x = [(a,b) | a <- comb x, b <- comb x, List.union a b == x] in f [1,2,3]
14:59:12 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:59:12 <lambdabot>   Expected type: [[a]]
14:59:12 <lambdabot>   Inferred type: [[[a]]]
14:59:16 <Beelsebob> again... no
14:59:33 <Cale> you have a spurious $ in there
14:59:34 <palomer> Cale: I can't believe I didn't see it before
14:59:49 <Beelsebob> no, that's meant to be there
14:59:59 <Beelsebob> I want to map cons x over the combinations of xs
15:00:09 <Cale> oh, sorry, I didn't see the enclosing parens
15:00:48 <Beelsebob> > let comb [] = [[]]; comb (x:xs) = comb xs ++ (map (:x) $ comb xs) in comb [1,2,3]
15:00:49 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:00:49 <lambdabot>   Expected type: [[a]]
15:00:49 <lambdabot>   Inferred type: [[[a]]]
15:01:10 <Beelsebob> :/
15:01:23 <Beelsebob> > let comb :: [a] -> [[a]]; comb [] = [[]]; comb (x:xs) = comb xs ++ (map (:x) $ comb xs) in comb [1,2,3]
15:01:24 <lambdabot> Couldn't match the rigid variable `a' against `[a1]'
15:01:31 <Beelsebob> where, you bastard?
15:01:40 <Cale> (x:)
15:01:43 <Cale> not (:x)
15:01:45 <Beelsebob> ah yes
15:01:54 <Beelsebob> > let comb :: [a] -> [[a]]; comb [] = [[]]; comb (x:xs) = comb xs ++ (map (x:) $ comb xs) in comb [1,2,3]
15:01:55 <lambdabot> [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
15:01:58 <Beelsebob> that's better
15:02:21 <Beelsebob> > let comb :: [a] -> [[a]]; comb [] = [[]]; comb (x:xs) = comb xs ++ (map (x:) $ comb xs); f x = [(a,b) | a <- comb x, b <- comb x, List.union a b == x] in f [1,2,3]
15:02:22 <lambdabot> [([],[1,2,3]),([1],[2,3]),([1],[1,2,3]),([1,2],[3]),([1,2],[2,3]),([1,2],[
15:02:22 <lambdabot> 1,3]),([1,2],[1,2,3]),([1,2,3],[]),([1,2,3],[3]),([1,2,3],[2]),([1,2,3],[
15:02:22 <lambdabot> 2,3]),([1,2,3],[1]),([1,2,3],[1,3]),([1,2,3],[1,2]),([1,2,3],[1,2,3])]
15:02:29 <Beelsebob> :)
15:02:36 <Beelsebob> that'll work then
15:03:25 <Beelsebob> but if you have no equality over terms it isn't applicable
15:04:39 <Beelsebob> and the splits based one doesn't produce all solutions
15:04:49 <Beelsebob> only those where no items are shared between a and b
15:05:09 <Cale> yeah, it's cutting it into disjoint unions
15:06:14 <Beelsebob> ohh...
15:06:34 <Beelsebob> no, that needs equality too
15:06:46 <Beelsebob> was gonna say you could add the combinations of a to b
15:07:00 <Beelsebob> but then you need equality to keep them sets
15:07:22 <Cale> > let splits [] = [([],[])]; splits (x:xs) = do {(u,v) <- splits xs; [(x:u,v), (u,x:v), (x:u,x:v)]} in splits [1,2,3]
15:07:25 <lambdabot> [([1,2,3],[]),([2,3],[1]),([1,2,3],[1]),([1,3],[2]),([3],[1,2]),([1,3],[1,
15:07:25 <lambdabot> 2]),([1,2,3],[2]),([2,3],[1,2]),([1,2,3],[1,2]),([1,2],[3]),([2],[1,3]),([
15:07:25 <lambdabot> 1,2],[1,3]),([1],[2,3]),([],[1,2,3]),([1],[1,2,3]),([1,2],[2,3]),([2],[1,
15:07:25 <lambdabot> 2,3]),([1,2],[1,2,3]),([1,2,3],[3]),([2,3],[1,3]),([1,2,3],[1,3]),([1,3],[
15:07:25 <lambdabot> 2,3]),([3],[1,2,3]),([1,3],[1,2,3]),([1,2,3],[2,3]),([2,3],[1,2,3]),([1,2,
15:07:26 <lambdabot> 3],[1,2,3])]
15:07:38 <Beelsebob> that appears to work
15:07:42 <Beelsebob> but overgenerate?
15:07:49 <Beelsebob> I'm trying to see duplicates
15:07:51 <Beelsebob> but I can't
15:07:55 <Beelsebob> so why are there more than mine?
15:07:56 <Cale> it shouldn't
15:08:28 <Beelsebob> indeed
15:08:32 <Cale> For each x in the input list, there are only 3 cases: x is only in the first part, x is only in the second part, x is in both.
15:08:41 <Beelsebob> yeh, that makes sense
15:13:26 <SyntaxNinja> there's an mbox library for Haskell somewhere, right?
15:13:33 <SyntaxNinja> has anyone ever seen a tool for summarizing an MBox?  like, I'd like to point this tool at a group of messages and have it say "these are the hot topics, these are the top posters lately" and maybe to give me a list of subjects by individual poster
15:14:01 <Beelsebob> Apple Mail.app?
15:18:29 <A-Tui> hi
15:18:36 <Cale> hello
15:18:45 <A-Tui> i have a little problem
15:19:08 <Beelsebob> I really think you ought to see your doctor about that
15:19:14 <Beelsebob> sorry, couldn't resist
15:19:15 <A-Tui> :)
15:19:38 <Cale> what is it?
15:19:47 <A-Tui> i use getChar function, but it waits for a \n
15:20:05 <A-Tui> and after the getChar there is a getLine
15:20:05 <Cale> hmm, really?
15:20:20 <A-Tui> and, the getLine catchs the \n :)
15:20:39 <Cale> let me see how that's written
15:20:50 <A-Tui> ok
15:20:56 <Cale> It probably shouldn't be doing that :)
15:21:32 <A-Tui>  o <- getChar
15:21:33 <A-Tui>     doAction o
15:21:57 <A-Tui> and then ....
15:22:02 <A-Tui> askForTorrentInfo = do
15:22:03 <A-Tui>     putStr "Cual es el nombre del torrent: "
15:22:03 <A-Tui>     name <- getLine
15:22:03 <A-Tui>     return (newTorrent name "1" "1" "1")
15:22:53 <A-Tui> a more simple example where happens the same:
15:23:02 <A-Tui> main = do
15:23:03 <A-Tui>     c <- getChar
15:23:03 <A-Tui>     print c
15:23:03 <A-Tui>     d <- getLine
15:23:03 <A-Tui>     print d
15:23:39 <Cale> Prelude> do c <- getChar; print c; d <- getLine; print d
15:23:39 <Cale> a'a'
15:23:39 <Cale> Hello
15:23:39 <Cale> "Hello"
15:23:54 <Cale> I typed aHello\n
15:24:20 <Cale> which Haskell implementation are you using?
15:24:36 <A-Tui> mmm i'm using ghc
15:24:42 <Beelsebob> which version?
15:24:45 <Beelsebob> on what platform?
15:24:46 <Beelsebob> from where?
15:24:49 <Cale> oh
15:24:56 <Cale> input might be line buffered
15:25:07 <Beelsebob> yeh, could well be the terminal buffering
15:25:09 <Cale> setBuffering stdin NoBuffering
15:25:40 <A-Tui> 6.4.1 on slackware
15:25:51 <A-Tui> and from Spain :)
15:26:12 <Cale> er
15:26:18 <A-Tui> ok, i would try to set the buffering
15:26:30 <Cale> hSetBuffering rather
15:27:34 <Cale> odd, that doesn't fix the problem in hugs for me
15:28:16 <A-Tui> ghci runs ok
15:28:42 <A-Tui> hugs has the same problem what happened when compile the code with ghc
15:31:01 <A-Tui> Cale, setting the Buffering runs now ok wher compiled 
15:31:03 <A-Tui> thanks :)
15:47:16 <palomer> man, I can't think on an empty stomach
15:47:20 <palomer> bbl
16:01:00 <dons> @seen kzm
16:01:02 <lambdabot> kzm is in #haskell. Last spoke 7 hours, 43 minutes and 44 seconds ago.
16:02:19 <dons> kzm, you sped up knuc! excellent! is it on the wiki? we need to keep up our lead...
16:16:11 <dons> musasabi, there's a faster nsieve-bits on the wiki, to commit when you have time.
16:21:58 <musasabi> dons: committed
16:22:13 <vincenz> is it possible to have clashing instances if they're ini different files?
16:26:20 <vincenz> apparently not
16:28:27 <dcoutts> Lemmih, really? what's the problem with the dynamic architecture?
16:30:05 <dons> Ocaml is within distance to catch us. they must have optimised something :S
16:30:12 <dcoutts> my PhD supervisor says I should write papers on anything an everything, even if it's not related to my PhD. In that case I should write: a paper on gtk2hs with simona, a paper on cairo with xerox and a paper on hIDE with Lemmih and dons. :-)
16:30:36 <palomer> and a paper on GADTs with me!
16:30:41 <dons> cool. that's the best kind of supervisor :)
16:31:06 <dons> my supervisor won't explictitly say that, but he generally doesn't complain too much
16:32:12 <dcoutts> dons, Lemmih, so yeah we should write a paper on hIDE for the next Haskell workshop :-)
16:32:44 <palomer> how would you guys combine a function foo :: a -> m b to transform a [[a]] into an m [[b]] ?
16:33:12 <dcoutts> xerox, and actually it's not unrealistic that we could get a paper out of doing a pure layer for cairo. It's just a matter of finding the time :-(
16:33:20 <dons> is that a sequence . map, palomer?
16:33:59 <dons> @type sequence . map
16:34:01 <lambdabot>   Expecting a function type, but found `b'
16:34:01 <lambdabot>   Expected type: (a1 -> b) -> [m a]
16:34:36 <palomer> @type \x -> sequence . map x
16:34:37 <lambdabot> forall (m :: * -> *) a a1.
16:34:37 <lambdabot> (Monad m) =>
16:34:37 <lambdabot> (a1 -> m a) -> [a1] -> m [a]
16:35:08 <palomer> @type sequence $ map (\x -> sequence . map x) 
16:35:10 <lambdabot>   Expecting a function type, but found `a'
16:35:10 <lambdabot>   Expected type: [m a]
16:35:21 <palomer> @type map (\x -> sequence . map x) 
16:35:22 <lambdabot> forall (m :: * -> *) a a1.
16:35:22 <lambdabot> (Monad m) =>
16:35:22 <lambdabot> [a1 -> m a] -> [[a1] -> m [a]]
16:36:01 <Cale> sequence . map f = mapM f
16:36:38 <palomer> @type \y x -> mapM (mapM x) y
16:36:39 <lambdabot> forall a (m :: * -> *) b.
16:36:39 <lambdabot> (Monad m) =>
16:36:39 <lambdabot> [[a]] -> (a -> m b) -> m [[b]]
16:36:47 <palomer> there we go
16:38:24 <palomer> @type \x -> mapM (mapM x)
16:38:26 <lambdabot> forall a (m :: * -> *) b.
16:38:26 <lambdabot> (Monad m) =>
16:38:26 <lambdabot> (a -> m b) -> [[a]] -> m [[b]]
16:38:49 <dons> it would be nice to have a @hoogle that composes functions too, to find a type
16:39:18 <dons> just from a limited set, and only with (.), ($) and say map.
16:39:22 <palomer> to find the function associated with a type?
16:39:37 <dons> ask a type, get a function (or a code fragment)
16:39:49 <dons> @hoogle [a] -> m [a]
16:39:50 <lambdabot> Data.List.head :: [a] -> a
16:39:50 <lambdabot> Data.List.last :: [a] -> a
16:39:50 <lambdabot> Prelude.head :: [a] -> a
16:40:13 <dons> but I'd also like it to try some combinations
16:40:21 <dons> ndm -- though of this?
16:40:24 <dons> thought.
16:44:18 <palomer> silly: unifier.hs:15:12-50: Non-exhaustive patterns in lambda <--does this refer to the function called lambda?
16:44:30 <palomer> because unifier.hs doesn't have a function called lambda
16:44:38 <dons> to a \
16:44:47 <dons> or maybe to 'lambda' if you have such a function
16:44:59 <palomer> to a \ ?
16:45:04 <dons> look on line 15, chars 12-500
16:45:15 <palomer> foldlM1 =  (\f (x:xs) -> Control.Monad.foldM f x xs)
16:45:17 <palomer> that's the line
16:45:25 <liyang> Yup.
16:45:29 <dons> what if it's [] ?
16:45:29 <liyang> Not covering []
16:45:35 <palomer> oh, righto
16:45:39 <palomer> so it's literally a lambda
16:45:45 <liyang> You need Epigram. :)
16:45:53 <dons> good ghc :)
16:46:35 <dons> finding missing code. I always impress beginners with this error.
16:46:52 <palomer> which error?
16:47:29 <vincenz> simple question
16:47:34 <vincenz> given a list of Map's
16:47:37 <vincenz> I want to find the first key
16:47:40 <vincenz> err...value
16:47:41 <vincenz> for a given key
16:47:58 <vincenz> [{"a":=1},{"a":=2},{"b":=3}] "a" -> 1, "b" -> 3
16:48:12 <vincenz> I tried using sequence but thatdidn't do it
16:48:26 <liyang> Compose a bunch of Map.findWithDefaults?
16:48:42 <dons> liyang, sounds reasonable.
16:48:53 <vincenz> mapM (Data.Map.lookup "a") l gives me back a monad that does an error on the looku
16:49:37 <dons> palomer, the missing pattern error -- ghc is detecting that there is code you haven't written yet. newbies love that.
16:49:41 <vincenz> sequence doesn't do it either
16:49:44 <liyang> (too tired to work it out. Left as an exercise for the reader. :)
16:50:03 <dons> oh, is it in Maybe, because of the lookup?
16:50:07 * palomer is confused
16:50:23 <palomer> I'm calling error inside ST, and sometimes the error isn't thrown
16:51:22 <palomer> nevermind
16:51:52 <palomer> yes, it works!
16:51:53 <palomer> wooot
16:52:28 * palomer does a dance
16:52:29 <palomer> omg
16:52:35 <palomer> I'm backing up this stuff tonight!
16:54:49 <vincenz> This is great
16:54:55 <vincenz> using indiriect composite I can do some neat things
16:55:04 <vincenz> only it requires glasgow-exts :/
16:57:08 <wilx> Almost any a little bit complex requires that.
16:57:31 <wilx> Err, s/complex/complex programme/
16:57:59 <vincenz> still not sure whether it's ideal
16:58:09 <liyang> indirect composite?
16:58:12 <vincenz> but basically I can easily define transformations over ast's without having to redefine the traversal each time
17:02:34 <liyang> (What do you mean by an indirect composite?)
17:03:42 <vincenz> http://www.haskell.org/hawiki/IndirectComposite
17:05:41 <liyang> Ah, cheers. :)
17:10:28 <SyntaxNinja> dons:  any luck finding someone to write summaries of the maliing list? I emailed JohnMeacham to see if he'd be interested too.
17:10:38 <SyntaxNinja> dons: since he seems to follow it so very closely :)
17:11:03 <dons> oh good idea. No , I've not found anyone yet.
17:11:11 <dons> I'll do it tomorrow though
17:11:15 <dons> so we'll get something this week.
17:15:34 <vincenz> I should write an article on that
17:15:42 <vincenz> how to use indirectcomposite to eas traversal
17:21:17 <vincenz> @hoogle runState
17:21:19 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
17:21:19 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
17:40:20 <vincenz> \o/
17:40:20 <akemp> DonS: are you on?
17:40:26 <dons> yep :)
17:40:42 <akemp> I read your note about unsafeWrite.  Thanks for the reply.
17:40:48 <dons> welcome , I don't think I've seen you here before?
17:41:01 <akemp> [I'm on quite rarely...]
17:41:43 <akemp> I think that I was confused because undafe* seems to imply **unsafe**, not just "not bounds checked", but I checked the src and, sure enough, it's just not bounds checked.
17:42:07 <dons> ah, right. it's not really "unsafe" in the unsafePerformIO sense :)
17:42:14 <akemp> But unsafeWrite still operates within the ST monad, so should be "safe".
17:42:31 <akemp> Exactly..........  unsafePerformIO.  That's what was confusing me.
17:42:37 <dons> it doesn't break the type system. it just has this extra constraint the programmer needs to satisfy.
17:42:59 <dons> perhaps it should be renamed. the equivalent peek/poke aren't scarily named
17:43:15 <akemp> This seems to be a consistent problem that I have with Haslell ibraries: they don't seem to have consistent naming.
17:43:28 <akemp> The whole IArray, MArray thing gets me, too
17:43:53 <dcoutts> akemp, that's because they're written by different people over many years
17:44:22 <dcoutts> the IArray/MArray thing is quite elegant when you get what's going on
17:44:22 <SyntaxNinja> akemp: I hope that the Haskell' standard can clean some of that up.
17:44:42 <akemp> many hands: that's what I figured, but it sometimes confusing for a newbie.
17:45:15 <SyntaxNinja> akemp: most of the haskell libraries are unstandardized and have never really gone through any process to make them consistent.
17:45:24 <SyntaxNinja> we should do that sometime,b ut it's a lot of work.
17:45:36 <akemp> I understand MArray and IArray, but I don't understand why the same functions are named different things (except because they were designed by different people).
17:47:18 <dcoutts> akemp, that have different names because they do different things and have different types
17:49:27 <akemp> They certainly have different types, but they seem to do much the same thing using different mechanisms.
17:50:37 <akemp> listArray and newListArray both create arrays from lists, but one creates an IArray instance and one creates an MArray instance.
17:51:06 <dcoutts> mm, fair point
17:52:15 <akemp> Means that I have to remember 2X names for X funtionalities.
17:55:03 <akemp> Is there any ability or desire to refactor and revise some of the libraries?  A painful, time consuming and backwards-compatibility breaking thought...
17:57:10 <dons> akemp, have you seen Bulat's "Array library story" about all the in-tricky-cies of the Array library interface for beginners?
17:57:18 <dons> it's on the haskellwiki
17:57:53 <int-e> akemp: if you were to unify newListArray and listArray, where would you stick the monad?
17:58:40 <akemp> Not sure what you mean.
17:59:12 <akemp> I think that I would use two functions: listToArray and lisToMArray.
18:00:34 <int-e> I see.
18:01:05 <akemp> MArray is defined as "Mutable Array", but I think that MArray is better defined as "Monad-wrapped Array".
18:04:05 <MarcWeber> Can you tell me what the ghc option -D does?
18:04:12 <SyntaxNinja> I was recently thinking about those arrays. 
18:05:31 <SyntaxNinja> definitely lots of room for improvement
18:05:53 <SyntaxNinja> likewise with the various refs and mvars
18:05:54 <dons> -D hmm. have to look it up.
18:05:54 <SyntaxNinja> hm
18:06:00 <dons> oh, x-Dsymbol[=value]xDefine a symbol in the C pre-processor 
18:06:03 <akemp> dons: I haven't seen the array story.  I just looked and couldn't find it on the HaskellWiki (haskell.org/haskellwiki)
18:06:21 <MarcWeber> It's used this way: ghc-6.4.1/bin/ghc -M -optdep-f -optdep.depend  -osuf o -cpp -DBEGIN_SUPPORT_TYPELIBS='-}' -DEND_SUPPORT_TYPELIBS='{- [...]
18:06:39 <dons> akemp, http://haskell.org/haskellwiki/Arrays
18:06:55 <dons> MarcWeber, usual thing. it defines a cpp symbol.
18:07:14 <MarcWeber> What does this mean?
18:07:51 <MarcWeber> So you can check in CPP files wether an option is set and comment things out.
18:08:27 <akemp> Yup.  I think that I'm fairly clear on arrays, I'm just whining about the function names.  Whenever I switch array types, I have to refer back to documentation to figure out what the new array function names are.
18:08:28 <MarcWeber> Does this also work for ghc? It's used this way in hdirect... That's my impression
18:10:07 <akemp> SyntaxNinja: it sounds as if you have a Haskell' effort going.  How will this fold into Haskell?
18:10:28 <MarcWeber> akemp:  SyntaxNinja is gone
18:11:04 <akemp> Ah... so he is.
18:11:14 <MarcWeber> dons ?
18:12:25 <vincenz> @type deepseq
18:12:26 <lambdabot> Not in scope: `deepseq'
18:12:28 <vincenz> @type deepSeq
18:12:30 <lambdabot> Not in scope: `deepSeq'
18:12:34 <vincenz> @hoogle deepSeq
18:12:36 <lambdabot> No matches found
18:13:48 <akemp> Anyone know where the Haskell' docs are kept?
18:14:46 <MarcWeber> Do you think a preprocessor might have been used to accomplish commenting out some lines in combination with cpp symbol -D flag?
18:15:03 <MarcWeber> akemp: online or source?
18:15:15 <akemp> both
18:15:24 <akemp> any
18:15:24 <akemp> all
18:15:27 <MarcWeber> first: ask google ;-)
18:16:02 <MarcWeber> source: don't know exactly I might try the doc target in fptools and see wether I get them...
18:16:06 <akemp> ah...  That was easy.  See I knew I'd get the answer if I just asked... ;)
18:17:13 <MarcWeber> He and I did knew it (www.haskell.org/ghc -> documentation)
18:19:14 <vincenz> @hoogle !!
18:19:16 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
18:19:16 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
18:19:20 <vincenz> @hoogle $!!
18:19:21 <lambdabot> No matches found
18:21:15 <MarcWeber> Which is the option of ghc to invoke a preprocessor?
18:22:50 <dons> -cpp
18:23:23 <MarcWeber> dons Do you think a preprocessor might be used to comment out blocks of code using a -D flag?
18:24:01 <dons> sure. but why not just use {- -} ?
18:24:54 <dons> you'd #if SYM, and then -USYM, I guess.
18:25:08 <MarcWeber> I'm still struggling with hdirect. It's two stage build: first normal ihc.exe 2. ihc.exe with COM support. the second one is using the libs created by the first run..
18:27:03 <MarcWeber> lol cpp doesn't mean c++ but c PreProcessor of course ;-)
18:45:08 <TuringTest> @seen dons
18:45:09 <lambdabot> dons is in #haskell. Last spoke 20 minutes and 14 seconds ago.
18:45:31 <TuringTest> dons: ping http://haskell.org/hawiki/KnucleotideEntry
18:47:54 <dons> yo
18:47:58 <MarcWeber> dons: Thanks! It's tricky.  he defines {- begin <code> end -} options and uses the preprocessor to substitute  begin with -} and end with {- .. so the <code> will be compiled.
18:48:20 <TuringTest> dons: Ah there you are.  
18:48:30 <dons> ah, ok, I'll try to benchmark them again.
18:48:35 <TuringTest> :)
18:48:57 <dons> but I couldn't even get Ketil's to compile?
18:49:05 <TuringTest> I fixed that too
18:49:11 <TuringTest> See my comment below yours
18:49:19 <dons> ok. looking..
18:49:56 <TuringTest> the Trie without GC is the snappy
18:50:55 <TuringTest> It will make a tasty "Alternative Solution" entry
18:51:58 <dons> you think we can't use functional data structures? or just not tries?
18:52:17 <dons> _requiring_ a mutable hashtable seems braindead, since we never use it in Haskell anyway
18:52:20 <TuringTest> "# define a procedure/function to update a hashtable of k-nucleotide keys and count values,"
18:52:38 <dons> maybe they're sloppy though, and just mean assoc map?
18:52:50 <TuringTest> dons: The Trie is way too specialized.  It hard codes 'A' 'T' 'C' 'G'
18:52:59 <dons> I reckon Isaac would ok the canonical Data.Map though.
18:53:14 <dons> maybe the Trie is too much though, yep.
18:53:16 <TuringTest> dons: Which in v2 is faster than Data.Hastable
18:53:34 <dons> I'll bencharm now.
18:53:42 <dons> benchmark. weird.
18:53:56 <TuringTest> Sounded like you were going to the gym
18:55:35 <TuringTest> The Trie is beautiful for this problem -- It lazily computes any length of match you require -- but it is not an associative data structure and can't pretend to be one.
18:57:29 <dons> fair enough.
19:00:38 <TuringTest> It is 3am ...I'm going to wait to be surprised by the results in the morning.
19:00:51 * TuringTest pulls the plug
19:33:16 <vincenz> @type (\=)
19:33:18 <lambdabot> Not in scope: `\='
19:33:21 <vincenz> @type (=\)
19:33:23 <lambdabot> Not in scope: `=\'
19:33:25 <vincenz> @type (=/)
19:33:27 <lambdabot> Not in scope: `=/'
19:33:29 <vincenz> @type (!=)
19:33:30 <lambdabot> Not in scope: `!='
19:33:33 <vincenz> @type (.=)
19:33:35 <vincenz> @type (/=)
19:33:35 <lambdabot> Not in scope: `.='
19:33:36 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:33:49 * palomer loves his new algorithm
19:33:59 <palomer> but I need to implement patterns to take advantage of it
19:34:00 <palomer> grrrrrr
19:34:11 <palomer> Cale: you around?
19:39:07 <palomer> ok, how am I supposed to parse patterns?
19:39:22 <palomer> err, or rather, how am I supposed to deal with patterns (type-wise)
19:44:12 <palomer> woot, my algorithm takes 2 seconds to infer the most general type of: (\x -> \y -> \z -> \t -> x y z t) (\y -> y) (\x -> x) (\x -> x) (\x -> x) 5
19:45:28 <palomer> Philippa_: you around?
19:49:32 <liyang> prolly not at this hour. :)
20:09:35 <palomer> grrr
20:09:45 <palomer> implementing patterns seems like it's going to be a pain
20:54:41 <Bobstopper> Is tail-call-optimisation still a "good thing" in haskell or does lazy evaluation somehow remove its need in some way I can't see?
21:03:45 * vincenz wootwoots
21:21:13 <Cale> Bobstopper: it's good, but in lots of cases, it's not as important
21:21:24 <Cale> Bobstopper: foldr is usually better than foldl, for instance.
21:21:34 <Cale> (because foldr preserves laziness)
21:22:02 <Cale> When you want to get the most out of tail-call optimisation, you usually need some additional strictness.
21:22:17 <Cale> Bobstopper: shall I illustrate?
21:22:49 <Bobstopper> ok, sure
21:23:06 <Cale> Okay, so let's have a look at foldl
21:23:27 <Cale> foldl f z []     =  z
21:23:28 <Cale> foldl f z (x:xs) =  foldl f (f z x) xs
21:23:37 <Cale> foldl (+) 0 [1,2,3]
21:23:48 <Cale> = foldl (0+1) [2,3]
21:23:57 <Cale> = foldl ((0+1)+2) [3]
21:24:01 <Cale> er
21:24:18 <Cale> = foldl (+) (((0+1)+2)+3) []
21:24:29 <Cale> (I missed a few (+) args there)
21:24:38 <Cale> = (((0+1)+2)+3)
21:24:44 <Cale> = ((1+2)+3)
21:24:48 <Cale> = (3+3)
21:24:50 <Cale> = 6
21:24:59 <Cale> that's the order that the computation proceeds
21:25:29 <Cale> the first bunch of steps can still be implemented with a tight loop, but at the end, you have a large expression to reduce
21:26:04 <Cale> which can result in lots of extra memory use, or worse, a stack overflow if the expression is too large.
21:26:33 <Cale> We can fix foldl by making it reduce the intermediate expression as it goes along.
21:26:41 <Cale> (making it stricter)
21:26:51 <Cale> foldl' f z []     =  z
21:27:20 <Cale> foldl' f z (x:xs) = let y = (f z x) in y `seq` foldl f y xs
21:27:43 <Cale> er
21:27:46 <Cale> foldl' f z (x:xs) = let y = (f z x) in y `seq` foldl' f y xs
21:28:43 <Bobstopper> I see
21:29:19 <Cale> That's quite handy when you're collapsing a list into a single value.
21:29:39 <Cale> For compound values, where laziness is important, foldr is better.
21:29:49 <Bobstopper> cool, thanks.
21:30:10 <Cale> foldl always recurses to the end of the list before it returns anything, which obviously doesn't work on infinite lists :)
21:30:52 <Cale> Whereas foldr can return some data early, which can make for much larger savings in time than tail recursion.
21:32:04 <palomer> foldl is tail recursive, right?
21:32:09 <Cale> yeah
21:32:15 <palomer> and foldr can be faster?
21:32:19 <Cale> it can be
21:32:26 <palomer> have you ever seen foldr be faster?
21:32:31 <Cale> sure :)
21:32:51 <palomer> hmph
21:32:54 <palomer> interesting
21:33:11 <palomer> so, given the choice, we should always use foldr
21:33:29 <Cale> well, it depends
21:33:46 <Cale> if you need laziness, you can't use foldl
21:34:38 <Cale> here's a silly example
21:34:47 <Cale> mapl f = foldl (\x y -> (x++[f y])) []
21:35:10 <Cale> > let mapl f = foldl (\x y -> (x++[f y])) [] in take 5 (mapl (+1) [1..])
21:35:16 <lambdabot> Terminated
21:35:53 <Cale> > let mapr f = foldr ((:) . f) [] in take 5 (mapr (+1) [1..])
21:35:55 <lambdabot> [2,3,4,5,6]
21:37:10 <Cale> There is a sense in which foldr is much more natural an operation
21:37:41 <Cale> foldr f z replaces (:) with f and [] with z in the list structure it's passed.
21:38:14 <palomer> good point, lists are built from the right
21:38:21 <palomer> I never thought of that
21:38:40 <Cale> http://cale.yi.org/autoshare/folds.png
21:38:59 <palomer> yeah, I've seen that one
21:39:12 <palomer> well, except the scans
21:39:26 <palomer> Cale: btw, I was thinking about the information ordering
21:39:45 <palomer> and is it true that if a < b, then there exists a unifier c such that composed(a,c) = b ?
21:40:00 <vincenz> Cale: nice
21:40:18 <Cale> palomer: yes
21:40:28 <palomer> Cale: how so?
21:40:56 <palomer> @hoogle scanl
21:40:58 <lambdabot> Data.List.scanl :: (a -> b -> a) -> a -> [b] -> [a]
21:40:58 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
21:40:58 <lambdabot> Data.List.scanl1 :: (a -> a -> a) -> [a] -> [a]
21:40:58 <Cale> palomer: if I understand your notation
21:41:32 <Cale> > take 20 $ scanl (+) 0 [1..]
21:41:33 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190]
21:42:28 <palomer> oh, nice, I should use scanl more often
21:42:37 <Cale> It's a pretty nice operation
21:42:43 <palomer> why is it called scanl?
21:44:56 <Cale> It's the list of intermediate results produced by foldl
21:45:29 <palomer> > take 20 $ foldl\ (+) 0 [1..]
21:45:30 <lambdabot>  parse error on input `\'
21:45:31 <palomer> > take 20 $ foldl (+) 0 [1..]
21:45:33 <lambdabot>  add an instance declaration for (Num [a])
21:45:42 <palomer> > foldl (+) 0 [1..]
21:45:47 <lambdabot> Terminated
21:46:00 <palomer> yes, yes, I see
21:48:36 <palomer> Cale: so do you have a convincing argument for your composition argument?
21:49:06 <Cale> palomer: I think so
21:49:13 <palomer> I guess a unifier can be represented by partitions of the type space, right?
21:49:20 <Cale> right
21:49:35 <palomer> so what does composition do to the partition?
21:49:56 <palomer> Cale: btw, has this stuff been studied? and if so, in which field?
21:49:58 <Cale> Well, by composition, do you mean union of the sets of equations?
21:50:13 <palomer> Cale: no, that's combining (in my terms)
21:50:26 <Cale> oh, okay
21:50:31 <Cale> so what's composition?
21:50:33 <palomer> composed (u,v) t = u(v(t))
21:50:43 <Cale> mm
21:50:44 <palomer> or, if you want
21:50:50 <palomer> u . v = u(v t)
21:50:57 <palomer> u . v $ t= u(v t)
21:51:03 <Cale> that's composition of relations?
21:51:24 <palomer> well, unifiers are functions
21:51:35 <palomer> however, equivalence classes of unifiers are relations
21:51:49 <Cale> ah, okay
21:51:51 <palomer> ie partitions of the type space
21:52:01 <Cale> I was only thinking of them as partitions :)
21:52:03 <palomer> u may not be equal to v as functions, but u == v
21:52:33 <palomer> so, when I talk about the equivalence classes, I'll use [u]
21:52:51 <Cale> Okay, let me check some things
21:53:00 <Cale> Is this the same as simply composing the relations?
21:53:10 <palomer> good questions
21:53:15 <Cale> (the smallest equivalence relation containing the unifier function?)
21:54:13 <palomer> composing the relation means: u S v iff exists z s.t. u R1 z and z R2 v, right?
21:55:05 <Cale> yes
21:55:46 <palomer> so, the question is, does this correspond to function composition of equvialence classes
21:55:56 <palomer> s/equvialence/equivalence
21:56:03 <palomer> I'm thinking it does
21:56:11 <Cale> me too
21:56:16 <palomer> ok, so we'll say it does
21:56:33 <Cale> S . R = {(a,c) | exists b. (a,b) in R, (b,c) in S}
21:56:52 <palomer> so uppercase is for relations, and lowercase is for functions (unifiers)
21:57:04 <Cale> okay
21:57:39 <palomer> so, if a <= b, then we need to find a C such that [a] . [c] = [b]
21:57:59 <palomer> (another question is, odes [a . b] = [a] . [b], but I'm thinking it does)
21:58:07 <Cale> yeah, originally I was thinking in terms of union, so I'll have to have a look :)
21:58:32 <Cale> that's essentially the question I asked, actually
21:58:37 <palomer> union is what I call "combination", it has other interesting properties
21:58:50 <palomer> it gives the lub
21:59:01 <Cale> right
21:59:17 <palomer> does intersection give the glb?
21:59:35 <Cale> I don't think so, but perhaps.
22:00:15 <palomer> so, to say one unifier is less than another, is to say that the partitions of one wholle fit in the partitions of the other
22:00:22 <palomer> wholy
22:00:35 <palomer> partitions induced by the equivalence class, that is
22:00:50 <Cale> which way round is it again?
22:01:03 <palomer> the smallest partitions are on the bottom
22:01:27 <Cale> That is, the full relation is on the bottom
22:01:33 <palomer> (ie, the least amount of information is on the bottom)
22:01:38 <palomer> the full relation?
22:01:42 <palomer> A x B ?
22:01:48 <Cale> yeah
22:01:51 <palomer> that's the top
22:01:55 <Cale> oh, okay
22:02:02 <palomer> A x B gives a single partition
22:02:06 <palomer> everything is related to everything
22:02:13 <Cale> a single part :)
22:02:20 <palomer> righto
22:03:03 <palomer> composition seems to merge partitions together
22:03:29 <Cale> These are all relations T -> T ?
22:03:39 <palomer> yeah, you can think of them that way
22:03:40 <palomer> sure
22:05:06 <palomer> I'm not sure you can think of them as partitioning the type space though
22:05:22 <palomer> bah, we'll assume we can
22:05:47 <Cale> If it's an equivalence relation, we can
22:06:03 <palomer> the equivalence relation is on the unifiers
22:06:05 <palomer> not on the types
22:06:40 <Cale> oh, I mean
22:06:52 <Cale> each unifier gives rise to one of these relations on types
22:06:59 <Cale> doesn't it?
22:07:08 <palomer> a unifier is a function, so it can be seen as a relation
22:07:14 <Cale> right
22:08:24 <palomer> so I guess we can take the reflexive, transitive and symmetric closure to get an equivalence relation
22:08:39 <palomer> two unifiers are considered equal if their partitions line up
22:08:46 <Cale> Let me make sure I understand the purpose here - if f is a unifier, and f(a) = b, then we think of this as saying "a = b" in some sense?
22:08:50 <palomer> (I'm hoping this agrees with the previous definition)
22:09:30 <palomer> Cale: not a priori, but it may make sense under my equivalence relation
22:09:56 <palomer> a unifier is considered under another if the partitions are finer
22:10:14 <palomer> so the only way to go up is to merge partitions together
22:10:32 <Cale> I mean, when you're type checking a program or inferring types
22:10:42 <palomer> Cale: yeah, they're equal in some sense
22:10:47 <palomer> (I hope)
22:10:57 <palomer> but then again, to come to that conclusion, I had to resort to my equivalence relation
22:11:05 <Cale> the information which you're using unifiers to record is essentially that certain type variables are equal to certain others
22:11:14 <Cale> or to more concrete types
22:11:21 <palomer> Cale: or type constructors applied to certain others
22:11:26 <Cale> okay
22:12:40 <palomer> are there any books on this?
22:13:06 <Cale> hmm, I guess one could read up some stuff on set theory, relations and all that
22:13:26 <palomer> okay
22:13:53 <Cale> We can take the closure [f] = {(a,b) | a = b or (a,b) in f or (b,a) in f or exists c. (a,c) in [f] and (c,b) in [f]}
22:14:10 <palomer> yeah, the closure
22:14:14 <vincenz> Cale: where do I get that cairo program that draws Lfractals?
22:14:25 <Cale> vincenz: you can get it from me :)
22:14:36 <vincenz> that works
22:14:44 <Cale> I wonder if where knows :)
22:14:44 <palomer> and f == g iff [f] == [g]
22:14:47 <Cale> @where nymphaea
22:14:48 <palomer> this we have to prove, of course
22:14:49 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
22:15:07 <Cale> palomer: oh, that's not true
22:15:14 <palomer> Cale: how so?
22:15:41 <vincenz> cool thx
22:15:42 <Cale> unless by == you mean that they give rise to the same partition?
22:15:47 <palomer> f == g means forall x y. f (x) = f(y) <=> g(x) = g(y)
22:15:53 <vincenz> `Graphics.UI.Gtk.Glade
22:15:55 <vincenz> could not find it
22:15:59 <vincenz> yet I have gtk2hs installed
22:16:01 * vincenz scratches his hed
22:16:09 <Cale> vincenz: make sure it builds the glade support
22:16:24 <Cale> It won't do it if you don't have glade installed
22:16:36 <vincenz> Cale: how do I comile it with that?
22:16:54 <Cale> vincenz: it should automatically determine that it can compile with that
22:16:59 <vincenz> Cale: based on what
22:17:21 <Cale> libglade and its development files are installed
22:18:01 <vincenz> ah, didn't have the dev
22:18:05 <Cale> Paolo had a newer, cooler website for Nymphaea. I wonder where it went
22:18:48 <palomer> and unifiers have other conditions on them
22:19:04 <palomer> (consistency conditions)
22:19:08 <vincenz> palomer: they might just define a different equvalence class
22:19:14 <vincenz> not ==
22:19:17 <palomer> hmm?
22:19:18 <vincenz> but some other =:=
22:19:20 <palomer> I'm defining ==
22:19:39 <vincenz> then I missed too much of the conversation
22:20:58 <palomer> hrmph, I'll have to write all this down
22:21:08 <palomer> well, I'm getting really tired
22:21:14 <palomer> night, and sweet dreams!
22:21:40 <Cale> 'night
22:39:26 <xerox> dcoutts: I'm very interested, I'll ping you as soon as possible.
23:05:43 * vincenz wonders about his language whether to use a 'template'-style
23:06:04 <vincenz> and my code is ugly :/
23:06:08 <vincenz> I mean verbose
23:08:10 * vincenz introduces parametric typing
23:09:12 <vincenz> forall a: ddt[a] g(ddt[a] x) { return x;
23:09:12 <vincenz> }
23:09:39 <vincenz> bad syntax maybe
23:27:20 <vincenz> any happy experts?
23:56:10 <vincenz> how do you get the last element of a list
23:56:16 <vincenz> @hoogle last
23:56:17 <lambdabot> Data.List.last :: [a] -> a
23:56:17 <lambdabot> Prelude.last :: [a] -> a
23:56:17 <lambdabot> Graphics.UI.ObjectIO.CommonDef.initLast :: [x] -> ([x], x)
23:56:21 <vincenz> >last [1,2,3
23:56:22 <vincenz> >last [1,2,3]
23:56:24 <vincenz> > last [1,2,3]
23:56:26 <lambdabot> 3
23:56:42 <gaal> Hey. In the GHC source tree, where is the Prelude code located?
23:59:48 <gaal> (libraries/base, apparently.)
