00:00:10 <roconnor> really, the notation should involve the keyword exists somewhere rather than forall
00:00:21 <roconnor> well, maybe
00:00:35 * ski thinks the 'forall' in that position is intuitive
00:00:56 <ski> Shape :: forall a. Shape_ a => a -> Shape
00:01:07 <roconnor> I wouldn't say Haskell's data declarations are intuitive in any sense of the word ;)
00:01:36 <ski> well, as intuitive as BNF, then :)
00:01:47 * tibbe agrees with ski
00:02:10 <roconnor> Can you have class constraints in data types?
00:02:19 <ski> how do you mean ?
00:02:24 <roconnor> is data Shape a = Shape_ a => Shape a legal haskell?
00:02:38 <ski> not haskell 98, iirc
00:02:50 <tibbe> @type data Shape a = Shape_ a => Shape a
00:02:50 <lambdabot> parse error on input `data'
00:03:03 <roconnor> data declarations aren't typeable.
00:03:10 <tibbe> @oh-come-on
00:03:10 <lambdabot> Unknown command, try @listcommands.
00:03:37 <tibbe> roconnor, I just wanted her to tell me if the declaration was well-formed
00:04:49 <ski> roconnor : neither hugs nor ghci likes that one
00:05:03 <ski> data Shape_ a => Shape a = Shape a
00:05:04 <ski> otoh
00:06:28 <ski> that works in (without extensions) both hugs and ghci 
00:06:35 <roconnor> hmmm
00:07:47 * beelsebob_ bimbles about looking bored
00:08:12 <ski> (though, sadly, whenever the type constructor 'Shape' is applied to a type, it doesn't add a constraint to check for that type being in class 'Eq'
00:08:48 <ski> instead it just adds that constraint to each of the type constructors of the datatype (or at least those ctors that mention the tyvar, not sure)
00:08:53 <ski> this means that
00:09:00 <ski> data Ord a => Set a = ...
00:09:10 <ski> can't be made into a 'Functor', e.g.
00:13:09 <ski> (hm .. basically, i think one'd need semi-deterministic type constructors (and it must be plain visible when a type is well-formed) ... hmm, i wonder if an extension like 'Set :: (a :: *) -> Ord a => *' could work ..)
00:15:07 * roconnor wonders if x^2 is considered a shared subexpression in 1 - (x^2/6) + (x^4/120).
00:15:49 <ski> probably not, unless maybe, if it unfolds '(^)'
00:16:11 <roconnor> if it unfolds (^) it will find the share.
00:16:20 <roconnor> hmmm
00:16:22 <tromp_> depends
00:16:28 <tibbe> anyone know how show is defined?
00:16:34 <tibbe> in terms of showsPrec
00:16:36 <tromp_> not if i do   let (^) = .... in  ....
00:16:41 <ski> show a = shows a ""
00:16:45 <vincenz> roconnor: I have read papers that do that
00:16:46 <tibbe> thanks
00:16:53 <ski> i think that is default
00:17:32 * ski doesn't recall starting precedence, for 'showsPrec'
00:17:42 <tibbe> 0
00:17:48 <tibbe> shows = showsPrec 0
00:17:56 <ski> m
00:18:00 <roconnor> maybe I should write it in horner form 1 + x^2/6*(-1 + x^2/20)
00:18:00 <vincenz> > showsPrec 0 "1" "2"
00:18:01 <lambdabot> "\"1\"2"
00:18:11 <vincenz> roconnor: there's better forms than horner
00:18:14 <vincenz> roconnor: horner ain't ideal
00:18:20 <roconnor> oh?
00:18:38 <vincenz> especaily in the case of multiple polynomials in multiple variables
00:18:41 <roconnor> well, monomials form is worse.
00:18:47 <vincenz> I reviewed a paper about it a few months ago
00:18:58 <vincenz> they found a more ideal repr
00:19:24 <vincenz> let me fish it up
00:19:47 <jethr0> hey vincenz 
00:19:52 <vincenz> hi
00:19:54 <xerox> vincenz: pong!
00:20:13 <vincenz> roconnor: google for "Hosangadi" polynomial expressions
00:20:14 <jethr0> vincenz: i got a _very_ simplistic version of pong running :)
00:20:37 <vincenz> @google hosangadi fallah polynomial
00:20:39 <lambdabot> http://www.fujitsu.com/us/about/other/fla/publications/lowpowerdesign.
00:20:39 <lambdabot> html
00:20:41 * xerox wants to point out that other search engines do exist beside google.
00:20:48 <vincenz> xerox: like what?
00:20:51 <jethr0> xerox: i don't believe you
00:21:09 <vincenz> @google hosangadi fallah common subexpression elimination
00:21:10 <roconnor> there is google scholar
00:21:11 <lambdabot> http://csdl.computer.org/comp/proceedings/asap/2004/2226/00/22260202abs.
00:21:11 <lambdabot> htm
00:21:15 <Saulzar> Also there is hoogle
00:21:16 <roconnor> and google images
00:21:21 <vincenz> and google desktop
00:21:25 <jethr0> google news
00:21:30 <vincenz> google mail
00:21:34 <roconnor> all sorts of different search engines
00:21:35 <jethr0> :)
00:21:37 <vincenz> google video
00:21:47 <roconnor> I don't think google mail is a search engine
00:21:49 <xerox> I found two nice other ones: http://clusty.com/ (especially wrt wikipedia), and http://grokker.com/ (the zoomable map is pretty cool, it worked well on math subjects).
00:21:57 <Saulzar> and edit - find, F3
00:22:31 <ski> @type lookup
00:22:32 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
00:22:43 <tibbe> I'm going to interview for Google next week :)
00:22:47 <vincenz> roconnor: http://www.engineering.ucsb.edu/~anup/Research.html
00:23:03 <tibbe> perhaps I could convince them to add Hoogle ;)
00:23:06 <vincenz> tibbe: cool
00:23:22 <vincenz> google is a drooly company to work for
00:23:24 <Saulzar> clusty.com puts "Welcome to Haskell Indian Nations University!" ahead of Haskell.org
00:23:37 <vincenz> clusty is old
00:23:37 <Saulzar> Clearly no good :)
00:23:47 <vincenz> clusty is from the pregoogle era
00:24:13 <xerox> vincenz: do you know other ones?
00:24:24 <vincenz> xerox: google
00:24:30 * Saulzar thought we had a good summary a minute ago
00:24:48 <vincenz> msn, altavista, yahoo
00:24:52 <vincenz> but they all suck
00:24:56 <xerox> Bah.
00:25:00 <Saulzar> alltheweb
00:25:02 <vincenz> lycoos
00:25:05 <xerox> I don't care about the brands.
00:25:05 <vincenz> lycos even
00:25:35 <Saulzar> There's google, google knock offs and very bad search engines 
00:25:41 <tibbe> there are some that do clustering pretty well but I can't remember any names
00:25:50 <xerox> I never tried others extensively to see that, anyway.
00:25:52 <vincenz> tibbe: clustering is just reusing other searchengines....
00:26:07 <vincenz> tibbe: which means they reuse gooogle and the very bad search engines
00:26:12 <vincenz> effectively making them equal to google
00:26:16 <vincenz> without anything new
00:26:24 <tibbe> vincenz, I remember I had a lecturing on performing clustering in a linear algebra course ones
00:26:26 <xerox> How are the other ones "very bad" ?
00:26:34 <vincenz> xerox: they're not good?
00:26:49 <xerox> That's tautological
00:26:55 <vincenz> correct
00:27:05 <vincenz> roconnor: checked it out?
00:27:20 <tibbe> vincenz, just to make sure that we're talking about the same thing, with clustering I mean searching for one term and getting grouped pages (like searching for "abortion")
00:27:27 <vincenz> oh!
00:27:39 <vincenz> ever seen that demo of touchgraph?
00:27:42 <roconnor> well, I just have one polynomial.  so i didn't look at it very hard
00:27:51 <xerox> tibbe: try grokker!
00:28:08 <vincenz> roconnor: well even if you have one polynomial...if it's multivariate, then horner ain't ideal
00:28:28 <roconnor> it's 1-x^2/6 +x^4/120
00:28:40 <vincenz> horner aint ideal even for that
00:28:49 <vincenz> the shared term should be (x^2/6)
00:29:03 <roconnor> wouldn't it be good to resuse x^2?
00:29:07 * tibbe is trying to add a generalization rule to his type checker
00:29:11 <roconnor> reuse
00:29:19 <vincenz> roconnor: x^2/6 would give you better results
00:29:22 <roconnor> yes
00:29:25 <roconnor> of course
00:29:26 <vincenz> you'd need no multiplication for the second term
00:30:18 <vincenz> 1-u+u^2*3/20
00:30:26 <vincenz> err
00:30:29 <vincenz> 1-u+u^2*3/10
00:30:46 <roconnor> > take 5 $ scanr (*) 1 [1..]
00:30:48 <lambdabot> Exception: stack overflow
00:30:57 <vincenz> o.O
00:31:07 <vincenz> > take 5 $ scanl (*) [1..]
00:31:08 <lambdabot> Couldn't match `[a]' against `t -> t1'
00:31:20 <vincenz> > take 5 $ scanl (*) 1 [1..]
00:31:21 <lambdabot> [1,1,2,6,24]
00:33:02 <roconnor> > take 5 $ scanl (*) 1 [1..]
00:33:03 <lambdabot> [1,1,2,6,24]
00:33:03 <roconnor> hmmm
00:33:05 <roconnor> clearly I'm doing something wrong
00:33:49 <roconnor> > take 6 $ scanl (*) 1 [1..]
00:33:50 <lambdabot> [1,1,2,6,24,120]
00:34:00 <vincenz> Holy crap
00:34:04 <vincenz> that's the second time oasisbot crashes today
00:34:11 <vincenz> anyone know why oasisbot would crash?
00:34:28 <vincenz> (make that lambdabot for the question)
00:34:35 <roconnor> @where oasisbot
00:34:35 <lambdabot> I know nothing about oasisbot.
00:34:42 <roconnor> @where lambdabot
00:34:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
00:35:53 * vincenz mutters
00:36:25 <roconnor> vincenz: she probably uses dynamic types
00:36:33 <roconnor> ;)
00:37:18 <vincenz> ??
00:39:03 <tibbe> are there any really good arguments in favor of dynamic "typing"?
00:39:21 * tibbe realizes that this might be the wrong forum for such a question
00:39:23 <vincenz> roconnor: oasisbot is an instance of lambdabot
00:39:35 * beelsebob_ jibbles lambdabot to see if it can be made to connect to multiple servers
00:39:58 <roconnor> oh in that case it must be a stack overflow ;)
00:40:10 <vincenz> yeah but I wonder why
00:41:08 <roconnor> > 1 `div` 0
00:41:08 <lambdabot> Exception: divide by zero
00:43:35 <xerox> Enlightening!
00:44:56 <audreyt> > error "divide by zero"
00:44:56 <lambdabot> Add a type signature
00:45:15 <audreyt> > error "divide by zero" :: a type signature
00:45:16 <lambdabot>  parse error on input `type'
00:45:22 <audreyt> > error "divide by zero" :: a signature
00:45:23 <lambdabot>  add an instance declaration for (Show (a signature))
00:45:29 <audreyt> I give up
00:45:30 <audreyt> ;)
00:45:32 * xerox hands '()' to audreyt 
00:45:40 <roconnor> > error "divide by zero" :: Integer
00:45:41 <lambdabot> Exception: divide by zero
00:46:01 <xerox> > error "No exceptions."
00:46:01 <lambdabot> Add a type signature
00:46:04 <xerox> GÃ¶del++
00:46:08 <xerox> Ouch.
00:46:21 <wilx> @type error
00:46:22 <audreyt> > error "No exceptions." :: Exception
00:46:22 <lambdabot> forall a. [Char] -> a
00:46:22 <lambdabot>  Not in scope: type constructor or class `Exception'
00:46:28 <audreyt> > error "No exceptions." :: IOError
00:46:29 <lambdabot> Exception: No exceptions.
00:46:33 <audreyt> yay.
00:46:40 <tibbe> @hoogle appSTM
00:46:40 <lambdabot> No matches found
00:46:55 <xerox> @hoogle SearchT
00:46:55 <lambdabot> No matches found
00:46:57 <vincenz> @die
00:46:58 <lambdabot> "dice" (line 1, column 1):
00:46:58 <lambdabot> unexpected end of input
00:46:58 <lambdabot> expecting digit
00:47:08 <vincenz> I really made it die :)
00:47:18 <vincenz> (that was unexpected)
00:47:25 <xerox> I was curious abut SearchT audreyt, do you know where could I find it?
00:47:28 * roconnor wonders if one can use yhc to compile to C++ to submit to topcoder
00:47:29 <audreyt> aha, 
00:47:34 <audreyt> x=y=z=1 in haskell is written as
00:47:43 <audreyt> let x@y@z = 1
00:47:47 <xerox> !!!
00:48:10 <roconnor> oh the wrongness of that
00:48:11 <vincenz> > let x@y@z = 2 in x*y*z
00:48:12 <lambdabot> 8
00:48:16 <ski> (: <wilx> @type error
00:48:24 <vincenz> > reverse ":("
00:48:25 <lambdabot> "(:"
00:48:27 <audreyt> xerox: it's in the standard package tree 
00:48:29 <audreyt> http://darcs.haskell.org/packages/monads/Monad/
00:48:41 <xerox> Uh-oh.
00:48:46 <ski> wilx : but that wasn't a type error :)
00:48:46 <xerox> Gret.
00:48:48 <xerox> +a
00:48:54 <vincenz> Who is greta?
00:49:11 <ski> hansel und gretel ?
00:49:27 <vincenz> so you're saying that a = el?
00:49:34 <vincenz> big claim
00:50:30 <ski> well, iirc SML often uses 'el' as name of element type in collections .. that that case : sorta
00:50:31 <audreyt> > let { a = el ; el = a }
00:50:32 <lambdabot>  parse error on input `}'
00:50:33 <ski> :)
00:50:53 <mauke> > let a = el; el = a in a
00:50:54 <audreyt> > let { a = el ; el = a } in "el a"
00:50:54 <lambdabot> Add a type signature
00:50:55 <lambdabot> "el a"
00:51:08 <xerox> @type let a = el; el = a in (a,el)
00:51:09 <lambdabot> forall a b. (a, b)
00:51:18 <xerox> Wee, bottoms.
00:51:19 <ski> @type let a = el; el = a in el a
00:51:20 <lambdabot> forall t. t
00:51:24 * xerox snickers
00:51:35 * vincenz smacks xerox' bottoms
00:51:53 <ski> baad
00:53:20 <xerox> http://videos.humpingfrog.com/13903/2006/02/pinky-the-wild-cat.html
01:03:22 <roconnor> why does yhc need gcc?
01:10:29 <beelsebob_> roconnor: because the runtime is written in C
01:10:38 <beelsebob_> so that it's portable to any platform you can compile C on
01:11:56 <roconnor> ah
01:12:11 <roconnor> where is the java backend for yhc bytecode?
01:12:23 <beelsebob_> someone's writing one... can't remember who
01:16:02 <beelsebob_> http://www.brianweb.net/personal/blog/entry.php?id=18
01:17:07 <beelsebob_> @where yhcjvm
01:17:08 <lambdabot> I know nothing about yhcjvm.
01:17:14 <beelsebob_> @where+ yhcjvm http://darcs.brianweb.net/yhcjvm/
01:17:14 <lambdabot> Done.
01:18:20 <roconnor> @dijnn (Maybe a) -> (a->b) -> b
01:18:20 <lambdabot> -- f cannot be realized.
01:18:23 <roconnor> @dijnn (Maybe a) -> (a->b) -> a ->b
01:18:24 <lambdabot> f a b c =
01:18:24 <lambdabot>   case a of
01:18:24 <lambdabot>   Nothing -> b c
01:18:24 <lambdabot>   Just d -> b d
01:18:47 <roconnor> @dijnn (Maybe a) -> (a->b) -> b -> b
01:18:48 <lambdabot> f a b c =
01:18:48 <lambdabot>   case a of
01:18:48 <lambdabot>   Nothing -> c
01:18:48 <lambdabot>   Just d -> b d
01:19:17 <roconnor> @where dijnn
01:19:18 <lambdabot> I know nothing about dijnn.
01:19:31 <cpatrick> hrm. why doesn't this work for the first one: f a b = case a of Nothing -> bot; Just x -> x
01:19:58 <beelsebob_> cpatrick: because partial functions are bad
01:20:11 <cpatrick> yeah, I suppose they are kind of cheating
01:20:22 <beelsebob_> @djinn (Maybe a) -> (a -> b) -> (Maybe b)
01:20:22 <lambdabot> f a b =
01:20:22 <lambdabot>   case a of
01:20:22 <lambdabot>   Nothing -> Nothing
01:20:22 <lambdabot>   Just c -> Just (b c)
01:20:25 <beelsebob_> thought so
01:20:35 <beelsebob_> that gives you those semantics
01:21:40 <fluxx> ghc should just generate the missing functions, if their signature is provided ;)
01:22:03 <earthy> ghe
01:22:11 <beelsebob_> lol
01:22:13 <earthy> problem is that the functions may not be unique. :)
01:22:22 <fluxx> well, provide an implementation yourself then :)
01:22:24 <beelsebob_> the functions *are* not unique
01:22:47 <fluxx> but for those kinds of signatures there is essentially only one solution?
01:22:53 <cpatrick> beelsebob_: sure they are for some functions
01:22:59 <cpatrick> like id :: a -> a
01:23:11 <roconnor> nah, there are multiple solutions for these sigs
01:23:12 <fluxx> @djinn a -> a -> a -> a
01:23:13 <lambdabot> f _ _ a = a
01:23:27 <roconnor> const (const Nothing) :: (Maybe a) -> (a -> b) -> (Maybe b) 
01:23:41 <beelsebob_> data Jam = Jam
01:23:41 <beelsebob_> f :: Jam -> Jam -- only has one reasilation
01:23:46 <roconnor> const (const id) :: (Maybe a) -> (a->b) -> b -> b
01:23:57 <xerox> cpatrick: I can think of two implementaions of id :-)
01:24:12 <fluxx> yeah, but those are just throwing data away?-)
01:24:14 <beelsebob_> I can think of two with different semantics
01:24:21 <roconnor> xerox: does one return bottom?
01:24:23 <beelsebob_> but not different to the user
01:24:25 <xerox> roconnor: right.
01:24:32 <roconnor> that doesn't count ;)
01:24:35 <xerox> ^_^
01:24:44 * xerox counts bottoms
01:24:51 <cpatrick> xerox: but total functions are bad. (beelsebob, 23:37)
01:24:51 <roconnor> (fix id) :: a -> a
01:24:57 <beelsebob_> lol
01:25:03 <xerox> Haha.
01:25:10 <beelsebob_> do we need @fp-bible?
01:25:23 <xerox> @foldoc beta-reduction
01:25:24 <lambdabot> No match for "beta-reduction".
01:25:28 <xerox> Whatever.
01:25:48 <beelsebob_> beelsebob_: @fp-bible (Beelsebob, 23:27)
01:25:48 <beelsebob_> lambdabot: and the lord spake, and he said, lo, the partial functions are bad
01:26:08 * cpatrick laughs
01:27:26 <roconnor> god has a list of all total functions
01:28:03 <roconnor> can god build a total function that isn't on his list?
01:28:04 <beelsebob_> Beelsebob: @fp-bible (Runciman, 1:1)
01:28:04 <beelsebob_> lambdabot: And lo, the Integers shall be represented as church numerals
01:28:04 <beelsebob_> Beelsebob: @fp-bible (Peyton-Jones, 1:1)
01:28:04 <beelsebob_> lambdabot: No they won't, that's horrifically inefficient
01:28:10 <Cale> total functions with what domain and codomain?
01:28:21 <roconnor> Integer -> Integer
01:28:43 <Cale> oh, those are uncountable
01:28:47 * xerox shows his favourite hyperreal number
01:28:52 <fluxx> does god know the function that identifies a function's termination property?
01:28:54 <beelsebob_> Cale: not by god
01:29:14 <cpatrick> Cale: no-one said god's list had to be countable...
01:29:19 <roconnor> cale, computeable total functions, (the other's don't exist)
01:29:27 <tromp_> a single number determines all termination properties
01:29:38 <tromp_> known as Omega
01:29:51 <xerox> You're the proof hat everybody likes to joke.
01:29:52 <roconnor> ah, the Omega cult.
01:29:56 <xerox> *that
01:30:13 <Cale> roconnor: oh yeah? :)
01:30:19 <tromp_> the halting probability of a universal machine...
01:30:20 <xerox> Maybe mathematical jokes are the proof that everybody likes to joke.
01:31:12 <tromp_> i shld say captures instead of determines though:)
01:32:38 <roconnor> god COULD make a list of all turing machines that are total, but CHOOSES not to.
01:35:40 <pierre--> hello
01:38:51 <EtnaRosso> morning all i need to install the haskell compiler on my ubuntu, some sugggestions?
01:39:04 <roconnor> aptitude install ghc
01:39:29 <EtnaRosso> using apt-get?
01:39:46 <roconnor> sudo apt-get install ghc
01:40:05 <EtnaRosso> it seems that aptitude work
01:40:43 <beelsebob_> sudo apt-get install yhc
01:40:46 <roconnor> If you are doing serious development you should get ghc-prof as well
01:41:01 <roconnor> sudo aptitude install ghc-prof
01:41:39 <EtnaRosso> what is that?
01:41:49 <roconnor> extensions for profiling
01:42:25 <EtnaRosso> ok do you think I need an user manual for ghc? or simply an Haskell's one?
01:42:43 <roconnor> I rarely refer to the ghc manual
01:42:53 <roconnor> I usually look online in those cases
01:43:13 <EtnaRosso> may you suggest me a "full" haskell manual?
01:43:25 <roconnor> sudo aptitude install haskell-doc
01:44:09 <EtnaRosso> thank you very much!
01:45:22 <xerox> roconnor: it's the same
01:45:39 <roconnor> what's the same?
01:46:03 <xerox> The online doc versus the the installed one
01:46:11 <roconnor> yes
01:46:47 <roconnor> I guess I was thinking that I sometimes write haskell code without internet connection
01:47:01 <roconnor> so having the haskell docs on your laptop is useful.
01:48:38 <sieni_> usually, installing $1-doc is a good idea, if (.*) is installed.
01:49:04 <roconnor> sieni_: maybe you are right
01:49:54 * roconnor see that he actually does have ghc6-doc installed
01:57:14 * roconnor finds these darc commands in makefiles a bit strange.
02:00:11 <roconnor> yhcjvm doesn't build for me :(
02:02:01 * Cale feels like part of a computer program. :)
02:02:51 <Cale> I'm combining the sections of Numerical Recipes in C into a single PDF, and the pages overlap, so I have to compare them visually.
02:04:04 <Cale> (luckily, nautilus' thumbnailer makes that easy :)
02:04:39 <roconnor> do you / did you spend lots of time in the CSC?
02:04:57 <viblo> humm, I just noticed getStdGen always return the same g when in ghci (but worked as I expected when compiling).. is this a bug or a feature? 
02:05:06 <Cale> roconnor: I did
02:05:10 <xerox> viblo: try 'newStdGen'.
02:05:22 <roconnor> rumour has it Haskell is pretty popluar around there
02:05:27 <Cale> really?
02:05:33 <xerox> viblo: the latter behaves as you espect, splitting the stdgen and giving you the "next" one.
02:05:37 <Cale> Amongst me? :)
02:05:38 <roconnor> I don't know
02:05:51 <Cale> who did you hear from?
02:05:57 <roconnor> a friend was whining about how people drone on and on about Haskell
02:05:57 <viblo> aha, thx :)
02:06:06 <Cale> roconnor: would that be Julie?
02:06:06 <xerox> viblo: it is explained here:
02:06:11 <xerox> @docs System.Random
02:06:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.
02:06:11 <lambdabot> html
02:06:25 <roconnor> I refuse to answer that question.
02:06:30 <Cale> haha
02:08:02 <sieni_> I first read "rumour has it Haskell is pretty popular around here" and was about to reply "O RLY?", but then I re-read the sentence :-)
02:08:21 <Cale> I infected a few other people with the Haskell bug before I left, so it's possible that it's finished its incubation period and started to spread :)
02:08:58 <roconnor> They teach haskell instead of ML in the programing languages course, right?
02:09:00 <Maddas> Heh. Does it spread electronically, too?
02:09:05 <Cale> hehe
02:09:09 <Cale> roconnor: yeah
02:09:16 <Cale> but not much about Haskell
02:09:30 <Cale> i.e. they don't even learn about typclasses
02:09:32 <roconnor> well, with 5 languages to get through, not much time.
02:09:35 <Cale> type*
02:09:37 <Cale> yeah
02:09:37 * xerox yows at Maddas 
02:09:50 <Maddas> yoW! Are we having FUN yet??
02:09:56 <Cale> @yow
02:09:56 <lambdabot> I'm shaving!!  I'M SHAVING!!
02:10:02 <vincenz> > reverse "lol"
02:10:03 <lambdabot> "lol"
02:10:18 <xerox> Sounds like a counter-attack move.
02:10:20 <viblo> while speaking about Random, it feels like its a bit small.. Compared with for example python, I miss choice and shuffle
02:10:35 <vincenz> @hoogle choice
02:10:35 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
02:10:35 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec
02:10:35 <lambdabot> a
02:10:35 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] ->
02:10:35 <lambdabot> GenParser tok st a
02:10:38 <vincenz> @hoogle oneOf
02:10:39 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st
02:10:39 <lambdabot> Char
02:10:41 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
02:10:43 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st
02:10:45 <lambdabot> Char
02:10:47 <xerox> Ouch.
02:11:01 <roconnor> Test.QuickCheck.oneof
02:11:21 <xerox> import MonadRandom
02:11:24 <xerox> shuffle = evalRandom . permutations
02:11:30 <xerox> Err.
02:11:33 <Cale> Yeah, there could be more tie-ins between lists and random elements
02:11:33 <xerox> choice = evalRandom . permutations
02:11:42 <roconnor> @hoogle permuntations
02:11:42 <lambdabot> No matches found
02:11:48 <Cale> a good permutation generator would be nice
02:11:49 <xerox> evalRand, too, and it needs a g.
02:12:13 <roconnor> doesn't QuickCheck have all this stuff?
02:12:16 <vincenz> @hoogle evalRandom
02:12:16 <lambdabot> No matches found
02:12:22 <vincenz> roconnor: yeah
02:12:26 <xerox> @wiki MonadRandom
02:12:26 <lambdabot> http://www.haskell.org/haskellwiki/MonadRandom
02:12:27 <xerox> There.
02:12:33 * xerox blesses Cale
02:12:41 <vincenz> xerox: no page
02:12:46 <Cale> wrong wiki :)
02:12:47 <vincenz> (There is currently no text in this page)
02:12:49 <xerox> Ah, ouch.
02:12:52 <Cale> @oldwiki MonadRandom
02:12:52 <lambdabot> http://www.haskell.org/hawiki/MonadRandom
02:12:56 <xerox> oldwiki, duh.
02:13:01 <xerox> Cale knows everything!
02:13:25 <vincenz> shouldn't it be System.Random?
02:13:48 <Cale> hm?
02:13:54 <xerox> Cale: did you posed the question to haskell' about getting it into mtl?
02:13:59 <vincenz> "import Random"
02:14:00 <Cale> no
02:14:02 <xerox> I can't phrase today
02:14:02 <Cale> oh
02:14:07 <xerox> Please do!
02:14:09 <Cale> vincenz: it could be
02:14:17 <vincenz> xerox: I know the feeling, abstract typos suc
02:14:19 <vincenz> s/suck/
02:14:39 <vincenz> abstract typos = typos on the AST instead of at the lexical level
02:14:43 <vincenz> semantic typos are even worse
02:15:02 <Cale> Of course, just importing Random works because it's the same as System.Random
02:17:14 * Philippa uses the term "thinko"
02:17:38 <vincenz> for abstract or semantical typops?
02:17:42 <xerox> The latter
02:17:42 <vincenz> I typically use "mental typo"
02:18:21 <vincenz> it's amazinig however that other people can read your text with mental typos included and still make a proper conclusion
02:18:31 <vincenz> compilers should have that type of robustness
02:18:45 <vincenz> but this is more a topic for #meta-science
02:18:45 <xerox> Like
02:18:46 <xerox> @yarr!
02:18:47 <lambdabot> Shiver me timbers!
02:18:53 <Cale> heh, with my family, I hardly have to form coherent words at times :)
02:19:12 <vincenz> Cale: well with my family I typically communicate in 3 or more languages in one sentence
02:19:18 * esap thinks it's amazing how people can also misunderstand a perfectly spelled statement :-)
02:19:41 <vincenz> esap: bad starting environment, statements are functions not complete programs
02:19:46 <xerox> Semantic bovinator jokes.
02:19:50 <vincenz> we are the program
02:20:17 <xerox> That's from the GEB!
02:20:28 <xerox> Where is the sound?  In the disc, or the reader?  Or both?
02:20:43 <xerox> If you change interpretation you could produce different sounds, for instance, and so on...
02:20:44 <vincenz> anyways, at home it's a confluence of italian english and dutch in sentences, with many bastardized words, like conjugating an italian word in english
02:21:13 <vincenz> quite nifty :)
02:22:49 <vincenz> let (=>) = flip ($) in [1,2,3] => map (+1) => map (*2)
02:22:55 <vincenz> > let (=>) = flip ($) in [1,2,3] => map (+1) => map (*2)
02:22:55 <lambdabot>  parse error on input `=>'
02:23:05 <vincenz> > let (:=>) = flip ($) in [1,2,3] :=> map (+1) :=> map (*2)
02:23:06 <lambdabot>  Not in scope: data constructor `:=>'
02:23:08 <vincenz> grr
02:23:11 <vincenz> stupid lexical rules
02:23:20 <integral> constant [1,2,3] >>> map (+1) >>> map (*2)
02:23:22 <vincenz> > let (==>) = flip ($) in [1,2,3] ==> map (+1) ==> map (*2)
02:23:22 <lambdabot> [4,6,8]
02:23:52 <vincenz> heh with some bastardized vertical rule
02:24:04 <vincenz> you could prolly do arrows in text in a more graphical way
02:25:16 <xerox> That sounds like ap
02:25:30 <vincenz> @type (***)
02:25:31 <lambdabot> Not in scope: `***'
02:25:39 <vincenz> @type (Control.Arrow.***)
02:25:40 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
02:25:40 <lambdabot>         (Control.Arrow.Arrow a) =>
02:25:40 <lambdabot>         a b c -> a b' c' -> a (b, b') (c, c')
02:25:58 <xerox> Ah, (==>) is (>.>).
02:26:02 <xerox> No it is not, wee ok.
02:26:09 <vincenz> something like
02:26:10 <Cale> It's just flip ($)
02:26:11 <vincenz>        +---> map (*2)---+
02:26:11 <vincenz> [1..] <|                |>--> id
02:26:11 <vincenz>        +---> map (*2)---+
02:26:18 <xerox> Hah.
02:26:18 <vincenz> and then have a vertical rule thingy generate the arrow code
02:26:29 <vincenz> that would rock
02:26:43 <xerox> What does that mean?
02:26:44 <mauke> oh god, someone did something like this in C++
02:26:55 <vincenz> mauke: oh?
02:27:00 <mauke> it lets you define numbers as areas of stuff
02:27:05 <vincenz> ??
02:27:08 <mauke> it had even 3d support
02:27:08 <vincenz> areas
02:27:09 <vincenz> ?
02:27:16 <vincenz> err mine stands for
02:27:33 <mauke> int n = i_dont_remember_the_syntax()----------------------+
02:27:41 <mauke>                +                                                 +
02:27:47 <mauke>                       +------------------------------------------+
02:27:51 <mauke> or something lke that
02:27:54 <vincenz> [1..] >>= \x -> zip x x >>= map (*2) *** map(*2) >>= id
02:27:58 <mauke> it had horrible operator overloads
02:28:12 <xerox> Hmm.
02:28:18 <vincenz> well it would have to be refined
02:28:28 <vincenz> but if you read the paper on Arrows by the people that made yampa
02:28:35 <vincenz> and you saw the diagram with the squares
02:28:41 <vincenz> and then the diagrams with the flow
02:28:43 <vincenz> the flow is much easier
02:28:50 <vincenz> and using some kind of graphical diiagram for flow would be ideal
02:29:05 * xerox pokes vincenz with some cairo
02:29:15 <vincenz> xerox: what about cairo?
02:29:22 <vincenz> xerox: I'm not tlaking about displaying graphics
02:29:32 <vincenz> I'm talkking about using some kind of textual graphics to ease the process of coding with arrows
02:29:39 <vincenz> to do yampa stuff
02:29:53 <esap> It's all too easy for C++ people to write libraries with strange rules warped by the constraints imposed by the language.
02:29:54 * vincenz kicks his fingers
02:29:55 <xerox> Why do textual graphics when you can do proper graphics?
02:30:11 <vincenz> xerox: touche
02:30:31 <vincenz> I already did some cool cairo stuff
02:30:41 <xerox> I remember :-)
02:30:42 <vincenz> been thinking of generalizing it to have a generic graph editor
02:30:53 <xerox> That would be something I'd love to see.
02:31:07 <vincenz> but it would be graphs
02:31:09 <vincenz> not diagrams
02:31:12 <vincenz> aka nodes are not resizable
02:31:28 <xerox> You should talk with bourbaki, he had some ideas about "code as graphs" or something.
02:31:54 <xerox> Proper 2d coding! :-)
02:31:57 <vincenz> lambdabot: @notify bourbaki:connect
02:31:57 <lambdabot> Unknown command, try @listcommands.
02:32:05 <vincenz> was worth a try
02:32:30 <vincenz> xerox: it prolly only makes much sense in context of data-flow style ode
02:32:32 <xerox> Since we have correction we could do better messages than "Unknown command".
02:32:43 <vincenz> lambdabot: @unknowncommand
02:32:43 <lambdabot> Unknown command, try @listcommands.
02:32:55 <vincenz> @silly
02:32:56 <lambdabot> Unknown command, try @listcommands.
02:32:57 <xerox> Like "@dwim = undefined" or something.
02:33:03 * roconnor realizes he was using the crappy gcj to compile java
02:33:52 <roconnor> I bet I can build yhc under OS/2
02:34:25 <xerox> Gambling is for losers.
02:34:25 <vincenz> xerox: my biggest concern is how to store the points cause they are constantly being mutaed when you drag em, forcing a total redraw
02:34:43 <vincenz> xerox: Gambling = betting for money
02:35:04 <xerox> vincenz: Mutable Arrays?  The first thing that pops up in my head.
02:35:08 <vincenz> besides if it weren't, isn't every written a paper a gamble for acceptance?
02:35:20 <vincenz> s/written a paper/written paper
02:35:29 * xerox pushes Cale with a mutable array
02:35:44 * vincenz pops a result
02:35:53 <vincenz> Cale: thx!
02:36:10 <xerox> Hiya Lemmih!
02:36:14 <vincenz> I should rename my chhannel to #nonsequitur
02:36:15 <Lemmih> Hi!
02:36:42 <xerox> #aftertrichotomy
02:36:49 <vincenz> que es trichotomy?
02:37:27 <xerox> It's a way to say that only one of a = b, a < b, and a > b are true for some a and b.
02:37:32 <xerox> s/are/is/
02:37:56 <Cale> hehe
02:38:00 <xerox> ;-)
02:38:19 * vincenz kicks people to #meta-science so he can babble there
02:38:28 <vincenz> #haskell's about haskell *cough*
02:43:04 <palomer> xerox: word has it that you've used lhs2tex, is this true?
02:43:25 * xerox doesn't understand
02:49:01 <gour> Lemmih: any progress with amd64-hIDE?
02:49:14 <vincenz> assert $ xerox `used` lhs2tex
02:49:28 <xerox> Exception: fromJust.Nothing
02:49:38 <Lemmih> gour: Nope.
02:50:09 <vincenz> xerox: lhs2tex is not in your dictionary?
02:50:19 <vincenz> wouldn't that imply False?
02:50:19 <xerox> palomer: what about it?
02:50:26 <vincenz> _ `used` Nothing = False
02:50:33 * xerox is Exceptional
02:54:07 <Lemmih> gour: I probably wont get my hands on an amd64 for a long time. dcoutts is your best hope, I think.
02:54:21 <gour> Lemmih: ok
02:59:08 <dcoutts> Lemmih, I'm trying to build hide on x86 at the moment
02:59:52 <SyntaxNinja> good morning
03:00:06 <dcoutts> Lemmih, so I'm doing this demo to the epigram people on Friday. I'm going to show off hIDE a little too. Got anything you'd like me to show?
03:00:09 <xerox> dcoutts: then make a binary deb please, <grin>
03:00:23 <dcoutts> xerox, I can't do debs :-(
03:00:24 <xerox> dcoutts: best luck with your demo.
03:00:30 <dcoutts> xerox, ta -)
03:00:42 <ihope> -), eh?
03:00:47 <xerox> %)
03:00:51 <palomer> xerox: I can't get it to work
03:00:55 <xerox> palomer: aww.
03:00:58 <palomer> or rather, I don't understand how it works
03:00:59 <palomer> what it does
03:01:02 <ihope> Oh noes: no nose!
03:01:20 <xerox> palomer: it generates LaTeX code from literate Haskell sources.
03:01:37 <Lemmih> dcoutts: Not really. Haven't hacked on hIDE for a while.
03:01:49 <palomer> xerox: so pass it any .lhs file and it will output a .tex file, right?
03:01:56 <xerox> palomer: I think so.
03:02:18 <palomer> oh, you've never used it?
03:02:54 <xerox> I don't exactly remember, I didn't write lots of lhs'.
03:03:00 <Lemmih> dcoutts: The auto-indentation is really tricky.
03:04:23 <dcoutts> Lemmih, is that in there already? What would you reccomend I demo that works?
03:04:34 <gour> anyone (gnome users) saw: http://tw.apinc.org/weblog/2006/02/26#a-closer-look-to-gedit-214
03:05:25 <Lemmih> dcoutts: It isn't there and it doesn't work. It's just driving me nuts (:
03:06:13 <palomer> oh, the .lhs files have to be written in latex
03:07:09 <Lemmih> 'morning, SyntaxNinja.
03:09:02 <dcoutts> Lemmih, so what makes it so tricky?
03:10:39 <Plex> What does the "getServiceEntry: does not exist" exception mean when I try to connectTo? (using ghci, on windows)
03:11:54 <Lemmih> dcoutts: The wanted information can't be extracted from the current lexer, unfortunately. One would need an almost complete lexer and a special parser (I think).
03:14:08 <SyntaxNinja> Lemmih: how's life?
03:16:49 <xerox> Lemmih: was your auto-completition code included in GHC?
03:17:39 <Lemmih> SyntaxNinja: Pretty good. I moved apartment two days ago and got some new hardware (:
03:17:59 <dcoutts_> Lemmih, mmm, that does sound tricky.
03:18:13 <dcoutts_> @where FilePath
03:18:13 <lambdabot> http://darcs.haskell.org/~lemmih/FilePath/
03:18:16 <Lemmih> xerox: Yeah, it's in ghc-head.
03:18:56 <dcoutts_> Lemmih, is that FilePath ok for the project management plugin?
03:19:23 <Lemmih> dcoutts_: Yes.
03:19:31 <dcoutts_> Lemmih, ta
03:19:51 <xerox> FilePath?
03:20:48 <SyntaxNinja> ahh, filepath.
03:21:46 <dcoutts_> @where fps
03:21:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:44:54 <dcoutts_> Lemmih, I'm getting a linking error on loading the HaskellSense plugin in hIDE. loading it in ghci-6.5 works ok but not in hIDE. It complains of an undefined symbol BC in readline.so
03:45:11 <dcoutts_> everything else seems to work though
03:46:23 <roconnor> $ yhc darcsman.hs
03:46:28 <roconnor> yhc: Error: File not found, Time
03:46:31 <roconnor> :)
03:48:15 <pkhuong> I'm implementing what's starting to look a lot like a monad in a DSL, and I'm wondering if "(done >>= a)" is legal when a is nullary?
03:48:47 <roconnor> @type (>>=)
03:48:48 <lambdabot> forall (m :: * -> *) b a.
03:48:48 <lambdabot>    (Monad m) =>
03:48:48 <lambdabot>    m a -> (a -> m b) -> m b
03:49:05 <roconnor> @type (>>)
03:49:05 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
03:49:15 <roconnor> maybe you want (done >> a)
03:51:00 <pkhuong> It does feel cleaner. I guess the real reason I would want it to work is that I could use (>>= a b c d...) [the DSL is in CL] instead of (>> (>>= ...) (>>= ...))
03:51:43 <ihope> Would do-notation work at all?
03:51:43 <roconnor> why not use a do block?
03:52:45 <pkhuong> roconnor: do? What's that? I'm really not used to thinking with monads, but i've gotten annoyed that I seem to have 2-3 almost-monads and want to clean it up.
03:53:23 <ihope> It's some syntactic sugar for monads.
03:54:56 <roconnor> do {x <- a; b} === a >>= \x -> b
03:55:29 <roconnor> do {x <- a; b; c} === a >>= \x -> b >> c
03:55:40 <ihope> do {xa; b} = a >> b
03:55:41 <roconnor> do {a; b; c} === a >> b >> c
03:56:17 <pkhuong> cool. Interesting :)
03:58:37 <Lemmih> dcoutts_: )-:
03:59:51 <ihope> do {x <- a; b} === a >>= \x -> b
03:59:51 <ihope> do {x; :roconnor!n=roconnor@n032173.cs.kun.nl PRIVMSG #haskell :do {x <- a; b; c} === a >>= \x -> b >> c                                    a; b} = a >> b
03:59:51 <ihope> do {a; b; c} === a >> b >> c
03:59:51 <ihope> cool. Interesting :)
04:00:03 <ihope> dcoutts_: )-PRIVMSG #haskell Oopsie.
04:00:47 <dcoutts_> ihope, ?
04:00:51 <Beelsebob> interesting... clients with broken parsers?
04:00:58 <ihope> Did I just send any scraps of junk over here?
04:01:06 <pkhuong> 5 lines or so.
04:01:08 <Beelsebob> ihope: muchly
04:01:19 <ihope> Eep.
04:01:46 <dcoutts_> Lemmih, which version of hs-plugins do you reccomend?
04:01:46 <ihope> Maybe I shouldn't use PuTTYtel as an IRC client.
04:02:12 <Beelsebob> ihope: PuTTy and irssi?
04:02:12 <Lemmih> dcoutts_: The version linked from in the README.
04:02:31 <ihope> >
04:02:47 <ihope> > 3+2
04:02:48 <lambdabot> 5
04:02:54 <dcoutts_> Lemmih, ah :-) I was using dons' latest darcs version. I'll try your repo copy.
04:04:36 <ihope> Beelsebob: nothing but PuTTYtel.
04:04:50 <Beelsebob> ihope: indeed you should change then
04:04:57 <Beelsebob> I recommend a mac and Colloquy
04:05:03 <ihope> :-)
04:05:16 <ihope> What's Colloquy?
04:05:25 <Beelsebob> a decent IRC client
04:05:39 <Beelsebob> (but make sure to get the svn version, the release is a bit unstable)
04:05:48 <Beelsebob> (odd way round, I know, but that's the way it is)
04:06:52 <ihope> PuTTYtel's working fine.
04:06:59 <Beelsebob> not if it did that
04:07:24 <pkhuong> i'm guessing it's a drag&paste issue.
04:07:40 <ihope> Well, that's because I accidentally pasted some stuff...
04:08:11 <ihope> Well, one problem is getting a message while you're typing and not knowing how much to backspace to get where you want.
04:08:24 <gour> @where hIDE
04:08:25 <lambdabot> http://haskell.org/haskellwiki/HIDE
04:11:01 <roconnor> what is hs-plugins?
04:11:43 <dcoutts_> Lemmih, sadly I get the same problem with the reccomended hs-plugins
04:12:36 <dcoutts_> Lemmih, I'll go try in on my nromal desktop rather than this little FC4 laptop.
04:13:47 <Lemmih> dcoutts_: Maybe we shouldn't use plugins?
04:14:00 <gour> @where hs-plugins
04:14:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
04:14:08 <gour> roconnor: ^^^
04:15:15 <dcoutts> Lemmih, maybe. I could try to do a static build.
04:15:16 <gour> Lemmih: just make it (easily) buildable, it does not matter if it's pre-pre-alpha
04:15:38 <dcoutts> gour, easily buildable is tricky :-)
04:16:38 <gour> dcoutts: i know. however there  are non-haskell people interested for the project
04:17:56 <ihope> I'll admit: this "IRC client" is a bit slow to use.
04:20:15 <Lemmih> Moving away from the plugin architecture would make it a lot easier to build and a lot easier to hack. It looks like the project is dying/halting so perhaps it's worth trying.
04:21:00 <xerox> It would be cool to be able to choose, maybe.
04:21:05 <Lemmih> Then we could have more high-level plugins via ghc-api.
04:24:41 <gour> using ghc-api would be nice and probably more easy to build :-)
04:24:48 <dcoutts> Lemmih, yep, buildability is probably more important at the moment
04:31:54 <JKnecht> @where ghc-api
04:31:55 <lambdabot> http://www.scannedinavian.org/~lemmih/ghc-api/
04:32:41 <Lemmih> Uh, that's not it.
04:32:44 <Lemmih> @where- ghc-api
04:32:44 <lambdabot> Maybe you meant: where where+
04:32:58 <Lemmih> @where+ ghc-api http://haskell.org/ghc
04:32:59 <lambdabot> Done.
04:41:51 <dcoutts_> Lemmih, I've got a static build working for the base + shell plugins. HaskellSence is next...
04:42:08 <dcoutts_> Lemmih, it starts up much quicker :-)
04:42:23 <dcoutts_> the runtime linking is really slow :-(
04:42:55 * JKnecht suggests http://www.haskell.org/haskellwiki/GHC/As_a_library for ghc-api instead of the main TOC.
04:43:18 <Lemmih> @where+ ghc-api http://www.haskell.org/haskellwiki/GHC/As_a_library
04:43:19 <lambdabot> Done.
04:45:41 <JKnecht> FWIW I like the hs-plugins concept. 
05:02:57 <dcoutts_> Lemmih, ok it's all linked in statically. I just run each plugin's "plugin_main" function in order and then call runInitialisationEndHook
05:03:31 <dcoutts_> Lemmih, do I need to be using Yi or the demo editor to get the interactive type checking etc working?
05:04:04 <Lemmih> I've only tested it with the demo editor.
05:04:19 <dcoutts_> Lemmih, ok
05:04:36 <dcoutts_> Lemmih, it's printing "libdir: /usr/lib/ghc-6.4.1"
05:04:41 <dcoutts_> which isn't right
05:04:54 <dcoutts_> It should be my gh-6.5 install
05:05:00 <dcoutts_> where do I fix that?
05:05:51 <dcoutts_> Lemmih, I've turned off yi and now it's trying to use the haskell sense
05:06:01 <dcoutts_> I just need to fix the libdir
05:06:23 <Lemmih> The GHC path is hardcoded somewhere.
05:06:27 <dcoutts_> ok
05:06:29 * dcoutts_ greps
05:06:53 <dcoutts_> Lemmih, heh, but the messages is working, it's reporting that the .hi file magic numbers are not right :-)
05:10:37 <dcoutts_> Lemmih, woo hoo! it's working :-)
05:11:23 <dcoutts_> I'm getting error messages and red underlining as I change a Test.hs file
05:12:21 * dcoutts_ is off home now
05:13:01 <dcoutts_> Lemmih, I just changed the bit where it calls ghc to ask ghc what it's libdir is to look for "ghc-6.5" rather than "ghc"
05:14:40 <gour> hey guys, we also want to enjoy free hIDE ride :-)
05:14:59 <gour> btw, what we are losing/gaining by (not) using hs-technology?
05:15:18 <Lemmih> dcoutts_: The cabal script should set GHC_BINARY, or something like that.
05:15:51 <Lemmih> gour: On the fly change of components.
05:16:15 <gour> Lemmih: how is it different from hs-plugins?
05:18:14 <Lemmih> With hs-plugins, everything was a plugin. That meant that we could change the GUI/editor/everything at runtime.
05:19:39 <gour> afaik, with hs-plugins we got tiny static core + rest in plugins
05:20:40 <gour> Sonarman, although changing gui/editor, is (maybe) not required, 'everything (else)' could be
05:20:49 <Lemmih> Indeed. But it's easier to have a static core and then have lightweight plugins in the form of Haskell scripting.
05:22:17 <Lemmih> What do you think, Sonarman? (:
05:23:44 * gour does not understand how Sonarman ended up in the channel :-/
05:24:09 <gour> my irc-client sometimes acts mystically
05:27:14 * ihope_ tests
05:27:35 <ihope> That's too bad...
05:33:00 <gour> Lemmih: what does it mean 'lightweight plugins? light in features or light to write?
05:35:59 <Lemmih> gour: I plan to use Haskell like Lua or Guile.
05:40:31 <gour> Lemmih: that sounds 'good enough' for typical plugin usage?
05:52:15 <xerox> @quote
05:52:16 <lambdabot> roconnor says: I'd like to propose a new law. As an online discussion of
05:52:16 <lambdabot> static types vs dynamic types grows longer, the probability of mentioning
05:52:16 <lambdabot> hetrogenous lists approaches 1. Godwin's law for language design.
05:54:50 <Lemmih> gour: I think it'll be powerful enough to create stuff like a darcs plugin.
06:03:37 <ihope_> Haskell can pretend to be dynamically types.
06:10:02 <Cale> but it can't pretend to be weakly typed
06:11:12 <ihope_> Just what do you mean by waekly typed?
06:13:05 <Cale> Even values of type Dynamic still have some particular type which is the only type they cast back to
06:13:39 <Cale> @type Data.Dynamic.fromDyn
06:13:40 <lambdabot> forall a.
06:13:40 <lambdabot>         (Data.Typeable.Typeable a) =>
06:13:40 <lambdabot>         Data.Dynamic.Dynamic -> a -> a
06:13:46 <Cale> @type Data.Dynamic.fromDynamic
06:13:47 <lambdabot> forall a.
06:13:47 <lambdabot>           (Data.Typeable.Typeable a) =>
06:13:47 <lambdabot>           Data.Dynamic.Dynamic -> Maybe a
06:14:09 <ihope_> Couldn't you have some set of functions that work on all Dynamics, and that everything else can be built up from?
06:15:11 <ihope_> Thus eliminating the need for casting entirely?
06:15:35 <Cale> Well Dynamic doesn't support much
06:17:17 <Cale> well, I suppose that with unsafePerformIO, you can write unsafeCoerce :: a -> b, but that's a real fast way to get a segfault.
06:17:46 <ihope_> How? Is there some forall a. IO a floating around or something?
06:17:50 <Cale> It's hard to usefully apply unsafeCoerce in most cases
06:17:59 <Cale> hm?
06:18:08 <dcoutts> ihope_, it's the problem of polymorphic references
06:18:08 <ihope_> Oh, right... maybe...
06:18:28 <ihope_> Well, just how would this unsafeCoerce be written?
06:21:12 <audreyt> @type unsafeCoerce#
06:21:12 <lambdabot> Not in scope: `unsafeCoerce#'
06:21:19 <audreyt> @type GHC.Exts.unsafeCoerce#
06:21:20 <lambdabot> forall b a. a -> b
06:21:24 <xah> when i do â@eval (\x -> x + 2) 1â, why do i get a parsing error?
06:21:51 <ihope_> @eval (\x -> x + 2) 1
06:21:52 <lambdabot> 3
06:22:03 <ihope_> ?
06:22:53 <xah> ihope_: i'm running it in ghci
06:23:04 <xah> i get <interactive>:1:0: parse error on input `@'
06:23:14 <sieni_> xah: you should leave the @eval off
06:23:25 <xah> oh ok. thx
06:23:42 <Cale> coerce x = let r :: IORef a
06:23:42 <Cale>                r = unsafePerformIO (newIORef undefined)
06:23:42 <Cale>            in unsafePerformIO (do writeIORef r x; readIORef r)
06:23:52 <Aphex_Twin> how can I define a find function? I've tried this:
06:24:05 <Aphex_Twin> find x [] = False
06:24:05 <Aphex_Twin> find x [y] = x == y
06:24:05 <Aphex_Twin> find x (y:ys) = if x == y then True else find x (tail ys)
06:24:21 <ihope_> elem?
06:24:21 <gour> Lemmih: darcs-like plugin? nice. is it enough for the rest of hIDE?
06:24:28 <ihope_> @type elem
06:24:29 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:24:43 <Cale> elem x xs = any (== x) xs
06:25:05 <ihope_> > elem 3 [1,2,3]
06:25:06 <lambdabot> True
06:25:08 <Cale> but elem is a Prelude function too :)
06:25:11 <ihope_> > elem 3 [4,5,6]
06:25:12 <lambdabot> False
06:25:28 <Lemmih> gour: I think so.
06:25:32 <Aphex_Twin> oh
06:25:34 <Aphex_Twin> ty
06:25:47 <Cale> ihope_: did you catch that awful piece of code? :)
06:25:59 <Cale> (coerce)
06:26:03 <ihope_> Yes.
06:26:04 <gour> Lemmih: wonderful, let it just become buildable (soon)
06:26:10 <ihope_> It includes undefined, though.
06:26:20 <Cale> undefined = undefined
06:26:22 <Cale> :)
06:26:41 <Cale> or really,  undefined = error "Prelude: undefined"
06:26:46 <ihope_> Can you give undefined to me using only constructors, lambdas and case statements?
06:26:55 <Cale> yes
06:27:00 <ihope_> Erm.
06:27:13 <Cale> well, not quite
06:27:14 <ihope_> Complete case statements.
06:27:19 <Cale> I can't make it throw an exception
06:27:26 <Cale> but I can make it non-terminating
06:27:30 <audreyt> case x of _ -> x
06:27:32 <Cale> which is just as good for this purpose
06:27:41 <audreyt> hm, no
06:27:44 <audreyt> that'd need a letrec
06:27:58 <ihope_> Well, Cale, can you give it to me?
06:28:02 <Cale> sure
06:28:40 <ihope_> Will you give it to me?
06:28:57 <Cale> can I use a recursive binding, or do you want a lambda term?
06:29:09 <ihope_> Lambda. No recursion.
06:29:24 <audreyt> data Wrap a = Wrap (Wrap a -> a) ; y f = (\ (Wrap x) -> f (x (Wrap x))) (Wrap (\ (Wrap x) -> f (x (Wrap x))))
06:29:56 <ihope_> audreyt: yikes
06:30:14 <Aphex_Twin> how can I state in Haskell that a is an element of list X?
06:30:21 <integral> audreyt: doing the impossible again?
06:30:31 <integral> Aphex_Twin: a `elem` xs ?
06:30:37 <ihope_> s/xs/X/
06:30:44 <integral> you don't normally state that at the type level if that's what you mean
06:30:50 <integral> ihope_: vars can't start with capital letters
06:31:07 <ihope_> Well, he said a list X...
06:31:11 <Cale> well, you just need a fixpoint combinator
06:31:19 <ihope_> :-)
06:31:26 <audreyt> interestingly, that kills ghci
06:31:39 <audreyt> and also ghc itself
06:31:45 * ihope_ dangles a fixpoint combinator just out of Cale's reach
06:32:11 <ihope_> Now that I think of it...
06:32:21 <ihope_> undefined = (\x -> x x) \x -> x x
06:32:30 <ihope_> I didn't say it had to typecheck ;-)
06:33:00 <Cale> heh
06:33:08 <int-e> That seems to be standard ... omega = S I I (S I I)
06:33:23 <ihope_> Can it get any simpler?
06:34:06 <int-e> I suppose all smaller lambda terms have a normal form.
06:34:15 <audreyt> ihope_: if it doesn't have to typecheck, undefined = 1 1
06:34:18 <audreyt> ;)
06:34:32 <audreyt> or rather, () ()
06:34:42 <ihope_> Maybe undefined = ()
06:34:50 <Cale> coerce :: a -> b
06:34:50 <Cale> coerce x = let r = unsafePerformIO (newIORef (coerce x))
06:34:50 <Cale>            in unsafePerformIO (do writeIORef r x; readIORef r)
06:35:01 <Cale> hwh
06:35:03 <Cale> heh*
06:35:19 <ihope_> coerce = const undefined
06:35:26 <Cale> but it's not
06:35:34 <audreyt> it actually coerces nicely
06:35:42 <ihope_> It does?
06:35:47 <Cale> *Main> coerce 5 :: Integer
06:35:47 <Cale> 5
06:35:56 <ihope_> Heh.
06:35:58 <Cale> *Main> coerce 'a' :: Integer
06:35:58 <Cale> 97
06:36:03 <ihope_> Ooh!
06:36:06 <audreyt> it's just like C!
06:36:13 <ihope_> Coerce True into ().
06:36:15 <audreyt> Haskell: the finest weakly typed language
06:36:17 <Cale> only much much easier to segfault
06:36:36 <Cale> *Main> coerce 'a'
06:36:36 <Cale> <interactive>: internal error: stg_ap_v_ret
06:36:36 <Cale>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
06:36:36 <Cale>     or http://www.sourceforge.net/projects/ghc/
06:36:44 <ihope_> Heh.
06:36:46 <Cale> *Main> coerce 5
06:36:46 <Cale> Segmentation fault
06:36:59 <audreyt> g'nite :) &
06:37:02 <ihope_> What's the default for Show?
06:37:12 <ihope_> Integer? ;-)
06:37:13 <Cale> there is no default
06:37:27 <Cale> there's a default for Num and it's Integer
06:37:29 <ihope_> Then how does stuff like "show undefined" work?
06:38:13 <Igloo> The compilers default more liberally on the ghci prompt
06:38:17 <Cale> it shouldn't. GHCi might default the type to () though
06:38:17 <int-e> @type show undefined
06:38:18 <lambdabot> String
06:38:39 <Igloo> s/compiler/interpreters/ I guess  :-)
06:38:44 <Cale> coerce.hs:8:4:
06:38:44 <Cale>     Ambiguous type variable `a' in the constraint:
06:38:44 <Cale>       `Show a' arising from use of `show' at coerce.hs:8:4-7
06:38:44 <Cale>     Probable fix: add a type signature that fixes these type variable(s)
06:38:56 <Cale> x = show undefined -- this is line 8 :)
06:38:57 <ihope_> @index unsafePerformIO
06:38:57 <lambdabot> System.IO.Unsafe, Foreign
06:39:11 <ihope_> @index newIORef
06:39:11 <lambdabot> Data.IORef
06:39:53 <Cale> unsafePerformIO is basically really really unsafe :)
06:40:52 <ihope_> :-)
06:41:14 <int-e> grmbl. I don't understand coerce - how does it end up sharing the two (differently typed?) r?
06:41:27 <Cale> the IORef is polymorphic
06:41:32 <Cale> r :: IORef a
06:41:48 <int-e> icky.
06:42:00 <ihope_> Something must be borked. This says that coerce :: a -> a
06:42:09 <Cale> you didn't give it a type signature
06:42:34 <Cale> my later version is potentially more polymorphic than will be inferred
06:42:44 <ihope_> Ah.
06:43:24 <ihope_> GHCi has encountered a problem and needs to close...
06:43:31 <Cale> hehe
06:43:43 <Cale> *Main> coerce coerce :: Integer
06:43:43 <Cale> -1217236040
06:43:52 <ihope_> :-)
06:44:01 <ihope_> Hmm...
06:44:14 <int-e> Cale: I expected the MR to give r a monomorphic type ... hmm. I guess it can't really do that.
06:44:33 <Cale> int-e: not if you include a type sig
06:44:35 <ihope_> I'd like a function that takes an integer and tells you what's so special about it.
06:44:57 <int-e> Cale: there isn't a type signature for r - that's what confuses me.
06:44:58 <gour> d'night
06:46:40 <Cale> int-e: well, in the absence of a type signature for coerce, r :: IORef a, where the 'a' is the same as in x :: a
06:47:00 <Cale> that is, it's not  forall a. IORef a
06:47:56 <ihope_> (x :: a) => IORef a
06:48:06 <Cale> sure, that works :)
06:50:05 <Cale> *Main> (coerce show) :: Integer
06:50:05 <Cale> 0
06:54:10 <roconnor> instance (Num a) => Group a where ... why doesn't this work?
06:55:32 <ihope_> What's the definition of Group?
06:55:51 <roconnor> <+>, opp, zero, and <->
06:56:28 <roconnor> There must be at least one non-type-variable in the instance head
06:58:01 <int-e> hmm. because it can lead to undecidable instances: instance Num a => Group a, instance Group a => Num a.
06:58:17 <roconnor> hmm
06:58:22 <int-e> -fallow-undecidable-instances -fglasgow-exts together allow that.
06:58:35 <roconnor> the 2nd will never happen
06:58:48 <roconnor> should I allow-undecidable-instances?
06:58:48 <int-e> you can't control your user's code :)
06:59:10 <int-e> I'm not sure why, but it wants -fglasgow-exts, too.
07:01:18 <roconnor> Well, I really only need Group Double
07:01:25 <roconnor> so I'll just do that
07:02:30 * roconnor wants tab completion in ghci
07:02:57 <dcoutts> roconnor, Lemmih added it recently
07:03:05 <roconnor> awsome
07:03:52 <roconnor> yay, my code builds
07:04:11 <roconnor> now I need to learn template haskell to remove all my code duplicatoin
07:08:24 <roconnor> @where paste thingy
07:08:25 <lambdabot> http://paste.lisp.org/new/haskell
07:08:34 <roconnor> @where list paste thingy
07:08:34 <lambdabot> I know nothing about list.
07:09:37 <lisppaste2> roconnor pasted "what I want to templatetize" at http://paste.lisp.org/display/17294
07:09:53 <roconnor> Anyone know template haskell?
07:12:31 <jethr0_> roconnor: i think for your problem "drift" is more appropriate
07:12:41 <jethr0_> although i haven't used it yet, i must admit
07:14:19 <roconnor> doesn't temlate haskell superceed drift?
07:17:06 <jethr0_> roconnor: they serve very different purposes
07:17:29 <jethr0_> drift is suited especially for automatically deriving type class instances
07:17:33 <roconnor> oh?
07:17:50 <roconnor> even multi-parameter typeclasses?
07:17:51 <jethr0_> for doing the same thing with TH, it would get rather detailed
07:18:13 <jethr0_> roconnor: i haven't used it. but i don't think it's been superseeded by anything
07:18:20 <roconnor> ok
07:19:18 <jyp> Drift is extensively used by John Meacham in jhc.
07:19:30 <ihope_> What's jhc?
07:19:49 <jyp> John's haskell compiler
07:19:56 <ihope_> Ah. :-)
07:20:20 <jyp> compile all the program at once.
07:20:26 <jyp> to iso C
07:20:30 <jyp> quite cool :)
07:20:47 <jyp> Still very experimental though.
07:20:49 <ihope_> I'd like a function called compile: String -> IO ()
07:21:09 <ihope_> Takes a Haskell source code thingy and turns it into an IO action ;-)
07:21:28 <jyp> You can do almost that with haskell plugins.
07:21:55 <roconnor> @hoogle eval
07:21:55 <lambdabot> Control.Exception.evaluate :: a -> IO a
07:21:55 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
07:21:55 <lambdabot> Control.Monad.RWS.evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a,
07:21:55 <lambdabot> w)
07:22:13 <ihope_> Control.Exception.evaluate? What's that do?
07:22:20 <jyp> hs-plugins is not indexed by hoogle.
07:22:28 <roconnor> oh
07:22:37 <TuringTest> @google hs-plugins
07:22:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:22:49 <jyp> @where hs-plugins
07:22:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:22:54 <jyp> good :)
07:23:33 <jyp> ihope_: It must restrict the scope of "imprecise" exception
07:26:01 <roconnor> I don't think drift will work for multiparameter typeclasses.
07:26:11 <roconnor> from my cursary reading
07:26:16 <ihope_> jyp: I don't get it.
07:27:11 <jyp> ihope_: let's suppose 'a' throws an exception.
07:27:39 <jyp> since haskell is lazy, the place where it can be caught is "imprecise"
07:28:02 <ihope_> So what's evaluate do?
07:28:23 <jyp> evaluate guarantees that you can catch it in "right after" the call to 'evaluate a'
07:29:17 <ihope_> Just how does this catching stuff work?
07:29:36 <jyp> I'm afraid this is beyond my knowledge
07:30:00 <jyp> there must be a paper explaining it however...
07:30:04 <jyp> let me check.
07:30:49 <jyp> it must be this: http://research.microsoft.com/Users/simonpj/Papers/imprecise-exn.htm
07:38:26 <Cale> @type Control.Monad.Exception.evaluate
07:38:26 <lambdabot> Couldn't find qualified module.
07:38:26 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
07:38:26 <lambdabot> \\)?
07:38:31 <Cale> @type Control.Exception.evaluate
07:38:32 <lambdabot> forall a. a -> IO a
07:38:53 <Cale> It produces an IO action which when run, evaluates the given value
07:40:25 <Cale> The most common use is to force the evaluation of values so as to ensure that any exceptions thrown as a result of evaluating calls to 'error' occur in the context of a particular catch
07:41:25 <oberon> a bear, a lion and a chicken meet somewhere - the bear says: "When I roar - the whole damn wood trembles" - the lion tells them: "thats nothing, when i roar, the wohle savanna trembels" - thereon the chicken retorts "hey guys - in case I cough the whole world trembles!"
07:45:25 <ihope_> :-)
07:51:52 <ihope_> So how does networking with Haskell work?
07:52:25 <olleolleolle> ihope_: Hey, I'd like to know that, too. What is the "world indata object" there?
07:53:44 <oberon> Is tremble the right word? Would shudder or shake fit better?
07:54:08 <ihope_> I think it works fine.
07:54:20 <SyntaxNinja> ihope_: what do you mean networking?
07:54:40 <mauke> haskell is cool: ppIdentifier = M.liftM PPIdentifier (prepend idstart (manyS idend)) <?> "identifier"
07:54:42 <ihope_> Connecting to other computers, sending stuff, recieving stuff.
07:55:07 <SyntaxNinja> ihope_: http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
07:55:20 <olleolleolle> SyntaxNinja: Thanks.
07:56:02 <SyntaxNinja> ihope_: there's an xmlrpc library if you want something higher level, among other things: http://hackage.haskell.org/ModHackage/Hackage.hs?action=info&pkg=XmlRpc&pkgVersion=2005%2e5%2e5
07:56:27 <olleolleolle> SyntaxNinja: Now you got me really interested.
07:57:08 <olleolleolle> (Oh, it was written by Mr Bringert, the first guy I ever saw typing "web app" and "Haskell" in the same sentence. That was today.)
07:57:14 <SyntaxNinja> browse the libraries here: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
07:57:38 <Beelsebob> o/~ Te ergo quasumuss tuis famulis subveni quos pretio so sanguine redemisti tuis famulis subveni
07:58:00 <ihope_> What language was that? Latin?
07:58:12 <Beelsebob> yeh
07:58:18 <mauke> yes, but "quasumuss" and "so" look wrong
07:58:39 <Beelsebob> it's taken from Salieri Coronation Te Deum
07:58:50 <Beelsebob> may well be pretioso
07:58:57 <olleolleolle> Again, SyntaxNinja, this is a tremendous help - getting my feet wet with "where to go". 
07:58:58 <mauke> ah
07:59:20 <Beelsebob> and quaesumus - becaus I can't spell
07:59:25 <ihope_> Attempt at translation: you must sell us pretzels or else we will redeem the in-store credit.
07:59:29 <Beelsebob> ... as I just beautifully demonstarted
07:59:46 <ihope_> Oh, wait. Your family must sell us pretzels.
08:00:09 <Beelsebob> lol
08:00:20 <ihope_> So what's it mean?
08:00:59 <Beelsebob> We therefore pray thee, help Thy servants whom thou hast redeemed with Thy precious blood.
08:01:31 <ihope_> Ah.
08:01:33 <SyntaxNinja> olleolleolle: glad to be of help. 
08:01:35 <SyntaxNinja> @learn
08:01:35 <lambdabot> http://www.haskell.org/learning.html
08:01:38 <ihope_> I was close enough.
08:04:20 <olleolleolle> SyntaxNinja: Grand. I was complaining to a friend today about the high-and-mighty attitude of some "func-proggers", "funcsters" or whatever they style themselves as. Glad to see it turn to an erroneous preconception.
08:06:41 <SyntaxNinja> olleolleolle: definitely :) Yet Another Haskell Tutorial seems to be the popular one lately, fwiw. hopefully you should find that folks here are pretty helpful. if not, let me know... and name names ;)
08:07:10 <olleolleolle> I am in the process of reading it, got it referred by a buddy.
08:07:55 <olleolleolle> And "The Tutorial" prompted me to get tools installed on all my machines. Very friendly tutorial. Makes you feel inquisitive.
08:08:51 <charles> newbie question re: ghci?
08:09:07 <[nom]> Should you decide to get a book, I think "The Haskell School of Expression: Learning Functional Programming by Multimedia" by Paul Hudak is pretty damn awesome.
08:09:43 <[nom]> My uni made me get "Haskell: The Craft of Functional Programming", which I don't like quite as much.
08:10:30 <olleolleolle> [nom]: RIght on! That one seemed like Grail-talk/mystic mumbo-jumbo half a year ago, and now it seems like a viable way of learning Real Stuff. I've come to know the functional programming "communities" a bit more now, and they are friendlier than their reputation.
08:11:41 <charles> If Main.hs contains a simple definition of fac (factorial fn), then when I load the uncompiled file into ghci (prompt is now "*Main>") I can do "fac 5" and everything works. If I compile Main.hs to Main.o and load it in ghci (prompt is now "Prelude Main>"), "fac 5" results in "<interactive>:1:0: Not in scope: `fac'". What am I doing wrong?
08:11:42 <Philippa> I suspect in our case any reputation for unfriendliness'll be based on language flame wars anyway
08:12:27 <araujo> Hi haskellers!
08:12:40 * araujo throws lambdas at everyone
08:13:14 <olleolleolle> Philippa: Could be. People can get snotty when language bashing.
08:13:25 * olleolleolle dodges those dangerous shapes.
08:13:35 * ihope_ tries to turn a lambda into a fixpoint combinator
08:13:37 * ihope_ fails
08:13:47 <SyntaxNinja> olleolleolle: any insight about where that reputation comes from? who told you we were unfriendly?
08:14:32 <SyntaxNinja> charles: you load Main.o into ghci?
08:14:41 <SyntaxNinja> charles: or just Main.hs? are you sure it loaded?
08:14:59 <olleolleolle> SyntaxNinja: Unfriendly... hm, perhaps that was the wrong turn of phrase. Uphill to get documentation, hard to grasp concepts, does not work on [aherrrm]Windows, all those concerns. (All now void, since I have a net-connected Powerbook these days.)
08:15:03 <charles> Prelude Main> :load Main
08:15:03 <charles> Skipping  Main             ( Main.hs, Main.o )
08:15:03 <charles> Ok, modules loaded: Main.
08:15:03 <charles> Prelude Main> 
08:15:17 <Beelsebob> :/
08:15:25 <[nom]> Does not work on Windows? :o
08:16:12 <SyntaxNinja> charles: hm. is there some sanity check you cna do to make sure it's loading the right file? are you in the right directory or something? that should work, so it sounds like something small.
08:17:23 <olleolleolle> nom: I was trying to enumerate what can be abrasive to a beginner in functional programming. Most nice tools are on Unix-like systems.
08:17:41 <charles> if I delete the Main.o, it works great (uncompiled):
08:17:43 <charles> Prelude Main> :! rm Main.o
08:17:43 <charles> Prelude Main> :load Main
08:17:43 <charles> Compiling Main             ( Main.hs, interpreted )
08:17:43 <charles> Ok, modules loaded: Main.
08:17:45 <charles> *Main> fac 5
08:17:48 <charles> 120
08:19:22 <SyntaxNinja> charles: very strange
08:19:36 <SyntaxNinja> no clue. maybe multiple versions of ghc installed?
08:19:55 <charles> ok thanks for the check that everything should be ok
08:20:11 <Philippa> GHC works fine under windows IME, though there can be issues with third party libraries that expect a *nix-like build environment
08:20:57 <Philippa> I've not had a problem getting what documentation is available - a lot of the hierarchical libraries were badly documented last I checked though, I should see how much the wiki's improving things now
08:21:01 <olleolleolle> Philippa: Yes, and there sits the "problem" I had. 
08:21:49 <olleolleolle> I was amazed at how much rock'n roll I could get out of my Windows box using Hugs and GHCi. (They started, they answered to my simple arithmetic.)
08:22:00 <olleolleolle> (No irony here. please note that.)
08:22:42 <olleolleolle> Has anyone here played with/used Bringert's XML-RPC lib?
08:23:18 <SyntaxNinja> Philippa: please! document them!
08:23:25 <SyntaxNinja> Philippa: it's seriously easy to do!
08:23:29 <SyntaxNinja> olleolleolle: a bit.
08:24:03 <olleolleolle> Is it hard stuff, or can I mince away at it? I understand XML-RPC well (have fiddled with it in procedural and OO languages).
08:24:16 <SyntaxNinja> oh, pretty easy, then.
08:24:50 <Philippa> SyntaxNinja: I've spent the last few hours failing to drag myself next door. Sometime I'll probably pitch a few bits and pieces in though
08:25:44 <olleolleolle> (I reacted to the great news of a Haskell XML-RPC lib, by clicking the download link, delicious-bookmarking it, and then promptly forgetting about it.)
08:26:00 <SyntaxNinja> Philippa: drag yourself next door!
08:47:22 <ihope> So how do I use the encodeMessage function in lambdabot's IRC.hs?
08:49:31 <olleolleolle> When I took a look at the Html combinator here http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html#t%3AHtml I was struck by the relative lack of docs text. Is that a correct observation, or am I simply missing the point of that page?
08:50:49 <olleolleolle> It was part of the Network.CGI library. Are these pages meant to keep docs, or just signatures for the available methods?
08:50:55 <olleolleolle> (Sorry, functions.)
08:53:06 <ihope> And where can I grab Util?
08:53:53 <mauke> heh, that's the file I've just written :-)
08:54:56 <olleolleolle> Is it possible to "import Network.CGI" in an interactive session with GHCi?
08:55:19 <olleolleolle> (Or, am I getting errors because I misunderstand how to use the hier-libs?)
08:55:39 <dons> I think it should be possible
08:55:39 <ihope> Something like :l + Network.CGI
08:55:51 <dons> :m + Network.CGI
08:56:05 <dons> :l is for :loading src files
08:56:14 <dons> :m is for packages in the system
08:56:31 <ihope> Ah.
08:56:47 <olleolleolle> Gave me a Cool prompt: Prelude Network.CGI> 
08:56:58 <ihope> :-)
08:57:00 <olleolleolle> dons: You are educatering us. Thanksy.
08:57:51 <ihope> Thatt's bade spelings!
08:58:47 <dons> olleolleolle, no worries. feel free to ask any haskelly questions you like
08:59:41 <olleolleolle> dons: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html#t%3AHtml is kicking me. What do I need to know to run one of those functions? 
08:59:57 <olleolleolle> [a] means an array of stuff, right, such as 200:200:200:[]
09:00:10 <dons> a list.
09:00:14 <olleolleolle> and a simple a means a string, right?
09:00:22 <ihope> A linked list. Not quite the same as an array.
09:00:23 <olleolleolle> or does it stand for "anything"?
09:00:35 <dons> > 1:2:3:[]
09:00:36 <lambdabot> [1,2,3]
09:00:41 <olleolleolle> dons, ihope : Thanks, list is a great word for it.
09:00:57 <ihope> And
09:01:18 <ihope> > 'a':'b':'c':[]
09:01:18 <lambdabot> "abc"
09:01:48 <olleolleolle> Yeah, the YATonHaskell taught me that, I feel "edercated".
09:01:51 <ihope> String = [Char]
09:02:01 <dons> an 'a' is a type variable. it stands for any type. so [a] is a "list of any type"
09:02:05 <olleolleolle> (Feels like C++)
09:02:15 <olleolleolle> dons: Great, thanks. Got it.
09:02:26 <ihope> All a's in a type have to be the same, though.
09:02:38 <olleolleolle> dons: So I'll read "a" as "any" when I "read it aloud"?
09:02:59 <ihope> Well, no. It's not always "anything".
09:03:03 <dons> I just say: "A list of 'a'"
09:03:16 <dons> or "A list of some type 'a'"
09:03:18 <olleolleolle> This is the "type rules", where things can get hairy, or so I heard.
09:03:25 <olleolleolle> dons: Good rules.
09:03:41 <ihope> Well, some types can be confusing.
09:03:43 <dons> sometimes the 'a' will not be just any type, it can be a constrained set of types, as ihope hints.
09:03:58 <dons> for example: Show a => [a]
09:04:06 <olleolleolle> (Yes, I got that, via some loose papers on Haskell I read.)
09:04:09 <dons> is a list of some type 'a', where 'a' is also a member of the Show class
09:04:20 <dons> so that's a smaller set of  types 'a', and not just any 'a'
09:04:43 <olleolleolle> Constraints can be useful later on, I take it.
09:04:51 <ihope> Yep.
09:04:54 <JohnMeacham> jyp: A lot of people also use it in 'offline' mode. where they will generate a Binary instance once say and just include it in their codebase rather than rely on DrIFT regenerating it each time.
09:05:18 <dons> so for example, when you see: (+++) :: (HTML a, HTML b) => a -> b -> Html
09:05:25 <dons> you know that only works on types that are also in the HTML class
09:05:42 <dons> that is, types that have an "instance HTML" written for them.
09:05:50 <olleolleolle> dons: That's great, good symbols there.
09:06:05 <dons> functions that are constrained this way are "ad hoc polymorphic". they're polymorphic in an ad hoc way.
09:06:22 <dons> functions like :a -> a, are fully polymorphic. they work on _any_ type.
09:06:49 <dons> the latter kind is known as "parametric polymorphism"
09:07:40 <ihope> What
09:07:41 <TuringTest> hi dons
09:08:06 <JohnMeacham> Anyone have a simple interpreter implemented in mostly pure haskell for a language suitable for embedding in an application as an extension language?
09:08:40 <dons> as an extensionn language?
09:08:59 <dons> use plugins or ghc-api, and then just use haskell ;)
09:09:39 <olleolleolle> Prelude Network.CGI> :m + Text.Html    ---> the even cooler prompt: Prelude Network.CGI Text.Html> (I am beginning to grok stuff)
09:09:41 <JohnMeacham> like, to add scripting to ginsu/jhc. no, plugins and ghc-api are much too heavyweight. something non platform specific would be ideal
09:09:54 <TuringTest> ginsu?
09:10:00 <JohnMeacham> My chat client.
09:10:07 <dons> an irc client./or gale?
09:10:09 <JohnMeacham> gale.
09:10:35 <ihope> gcc: installation problem, cannot exec `ld': No such file or directory
09:10:35 <dons> John, don't know of a good option here. Ideally you'd want an fp lang?
09:10:50 <dons> so a scheme-written-in-haskell, perhaps
09:10:51 <ihope> What's up with that?
09:11:03 <JohnMeacham> Yeah, 
09:11:04 <olleolleolle> (Just saying I am fiddling with Haskell, and it feels good.) Yay! It worked. I am Htmling along: stringToHtml("<p>Olle</p>") => &lt;p&gt;Olle&lt;/p&gt;
09:11:51 <dons> I'd say, byte the bullet. make it plugin-isable. it works for lambdabot and yi. but if there's a 30 minute scheme impl you could install, that might be fun too.
09:11:56 <JohnMeacham> I would like to write 'Noel' (normal-order-extension-language). it has been on the backburner for a while, but could be pretty darn cool.
09:12:29 <TuringTest> JohnMeacham:  I hear there is an almost pure haskell scripting language that is almost finished : perl6
09:12:29 <dons> olleolleolle, you don't need the parenthesis around your string, btw.
09:12:38 <dons> yeah, that's one option
09:12:59 <dons> you can just link against libpugs
09:13:03 <JohnMeacham> performance isn't an issue with extension languages in general, and the clarity of expression that normal-order evaluation allows would be a great boon. not to mention it could be used as a data-flow language, which would be a very nice thing for something like an editor say.
09:13:09 <olleolleolle> dons: yeah, I know (but I'll keep the support-wheels on for a while, til I get the hang of things). In Ruby, I can let go. I can see them there.
09:13:16 <dons> and then write a paper on using perl as an extensionn languaage for haskell.
09:13:57 <dons> TuringTest, hey. got you mail. will benchmark soon.
09:13:59 <dons> looks good!
09:14:03 <jethr0_> dons: how much easier would dropping type inference make the construction of a haskell compiler?
09:14:15 <TuringTest> dons: :)
09:14:19 <jethr0_> if everything were annotated, that should fascilitate most things, no?
09:14:29 <JohnMeacham> jethro0_: not a whole lot easier.
09:15:22 <jethr0_> TuringTest: i wanted to apologize for my errneous template haskell responses yesterday... sometimes i talk nonsense without realizing it.
09:15:28 <dons> our beginner compilers (i.e. week 2 of a course I tutor) require full type annotations, but constructing Haskell type checkers is pretty routine, so not a whole lot easier.
09:15:36 <TuringTest> jethr0_: It is okay -- I got it working.
09:15:40 <jethr0_> :)
09:16:11 <jethr0_> TuringTest: i've been thinking about my proposed speedup idea. and i'm not so sure anymore that it'll make the kind of difference i'd hoped for.
09:16:33 <TuringTest> jethr0_: I modified the CTK parser today and it beats Parsec by a long shot
09:16:37 <jethr0_> there must be a smarter way of string search with an acceptor than char by char. but maybe it wouldn't be "regexp based" anymore
09:16:45 <JohnMeacham> jethr0_: it would make the front end easier. but that is not a whole lot of the compiler. plus there are several drop-in typecheckers you can use, the THIH one, hatchet, jhc's new rank-n one. jhc's typechecker is ~2000 lines of code and handles several non-trivial extensions. rank-n, impdeicativity, first class existentials..
09:17:07 <TuringTest> jethr0_: Well, you could do memcmp if you were just comparing ascii strings....
09:18:12 <jethr0_> JohnMeacham: in answer/response to your earlier question. are there any lazy curried languages out there for which an interpreter is similarly easy to write as for scheme/lisp?
09:18:26 <olleolleolle> dons: That was it for today, with fiddling in GHCi, and I extend my humble thanks for all the pointers.
09:18:28 <dons> JohnMeacham, I seem to recall Conal Elliot embedding a small core-ish language in one of this graphics thingies using GADTs to write the interpreter.
09:18:34 <jethr0_> like a standard language one would be implementing?
09:18:48 <JohnMeacham> jethr0_: it would be straightforward to write one.
09:19:14 <JohnMeacham> jethr0_: I think haskell is the only standard lazy language. maybe clean or LML count...
09:19:21 <jethr0_> TuringTest: there's also the string search algo the name of which i forget which also works by analyzing prefix relations.
09:19:38 <jethr0_> JohnMeacham: is miranda lazy? or is miranda superseded by haskell?
09:19:39 <JohnMeacham> A standardized 'scheme with haskell syntax' would be a very nice language.
09:19:42 <dons> jethr0_, we write a  haskell interpreter, for most of haskell, in 2 three-week assignments. so as long as it is interpreted, then its not too hard -- al the techniques are standard.
09:19:54 <jethr0_> JohnMeacham: you mean a lazy one?
09:20:28 <JohnMeacham> jethr0_: no, I mean completly compatable with scheme, a one-to-one mapping but with haskells syntatic sugar.
09:20:39 <jethr0_> dons: yes, i'm pretty confident i could do it with a little fiddling. but writing a skelettal scheme interpreter is _so_ easy with eval-apply that it's hard to beat :)
09:20:42 <JohnMeacham> but that is different than my small lazy language I want.
09:21:07 <JohnMeacham> jethr0_: well, that is sort of cheating. the interpreter is already written in that case.
09:21:24 <dons> yeah. it's cheating.
09:21:31 <JohnMeacham> needing an 'eval' is a sign of weakness in a language.
09:21:36 <dons> it's like saying that lambdabot has a haskell implementation:
09:21:38 <dons> > 1 + 2
09:21:39 <lambdabot> 3
09:21:43 <ihope> So what's with this error message: gcc: installation problem, cannot exec `ld': No such file or directory
09:21:45 <jethr0_> JohnMeacham: might be worthwhile to set a standard and create sth like a scaled-down guile. optimally even upwards compatible with haskell or equipped with some kind of FFI.
09:21:49 <dons> just cause it has eval :)
09:22:16 <dons> ihope, have you added -v4 flags to ghc to see the exact command line generated?
09:22:19 <TuringTest> speaking of standards, is Haskell' making headway?
09:22:35 <ihope_> No...
09:22:38 <dons> jethr0_, I think a standard embedded haskell would be better
09:23:05 <jethr0_> haskell is IMO one of the few languages that turned out great through design by comittee. let's hope haskell' will do likewise
09:23:58 <JohnMeacham> TuringTest: A lot.
09:24:05 <ihope_> dons: just what should I do? I got "unrecognized option `-v4'", if that was what you meant...
09:24:07 <jethr0_> dons: i agree. but before there's a _really_ easy way to integrate it, it seems like a lot of hassle. nothing against hs-plugins, but i'm not sure they can compare to guile, lua, python, ruby when it comes to practical scripting issues
09:24:14 <jethr0_> although i might be wrong...
09:24:18 <dons> ihope_ is this a ghc or gcc error?
09:24:35 <ihope_> gcc.
09:25:03 <JohnMeacham> jethr0_: designed by comittee is not really what happens though. all the design is open on haskell-prime@haskell.org, there just needs to be _someone_ to make the final decisions and declare the language done, but the actual work is done by the community at large.
09:25:28 <dons> hs-plugins is really for plugins, not for scripting. so it doesn't easily let you manipulated internal data structures of your app dynamically. it does let you write photoshop-style load-at-startup extensions quite well though
09:25:32 <dons> i.e. see lambdabot
09:25:34 <jethr0_> ya, i thought as much. although it sounded less community driven in some description of the process of getting to haskell98
09:25:41 <JohnMeacham> jethr0_: yeah, that is what I want 'Noel' to be.
09:25:43 <dons> but that's different to a lua situtation
09:25:52 <jethr0_> but look at what community-driven (although company-driven might be more correct) has done to lisp *brr*
09:26:18 <JohnMeacham> jethr0_: the haskell 98 process was more closed as far as I know. but I wasn't involved in that so it is hard to say.
09:27:04 <jethr0_> JohnMeacham: yes, and i think it would be nice if there would be some kind of transition between "Noel" and haskell, so that you could use most of haskell's functions in "Noel" (probably as libraries and with bad performance, but nonetheless)
09:27:24 <jethr0_> *functionality
09:27:45 <dons> really, I don't see why someone couldn't take, say, hugs, and stick it in a libhugs
09:27:56 <jethr0_> otherwise i see the danger of creating just another language with all its dangers
09:28:01 <dons> then you'd have a very portable embeddable haskell.
09:28:42 <JohnMeacham> jethr0_: well, you are part of the community, so make sure that doesn't happen :) I think the restriction that we are looking at tried-and-true (for the most part) extensions keeps things from getting out of control. however, a lot of people seem to have much more experience with implementation driven languages which is something of a culture-clash.
09:28:45 <jethr0_> i don't mean to be bashing languages at random. but few are as elegant and thought-through as haskell. and creating a new similar one seems like a dangerous move
09:29:55 <JohnMeacham> jethr0_: thats the thing. people don't write haskell 98 in practice, they write GHC-haskell or haskell + various ill-defined non-standard extensions. we aim to standardize existing practice and clean up obvious deficiencies, not start over.
09:30:33 <jethr0_> JohnMeacham: i like implementation-driven. it just shouldn't stand in the way of radical changes or produce gold-plated language standards. i think ghc is a nice testbed for many "new" haskell ideas
09:30:56 <jethr0_> JohnMeacham: i didn't mean to critize at all :)
09:32:18 <jethr0_> what i kinda miss (admittedly coming from an OO "background") is the possibility to have parametrized module "instances". so that you can set some "global" parameters on module import. but i guess that's not very compatible with functional programming :)
09:32:56 <Excedrin> do you mean C++ templates?
09:33:14 <jethr0_> not exactly
09:33:18 <ihope_> So how do I get rid of this "cannot exec ld" error from gcc?
09:33:39 <dons> sounds  like your system is busted in some way?
09:33:59 <dons> have you found `ld' is it executable?
09:34:14 <jethr0_> JohnMeacham: btw, what's the "roadmap" for jhc? because i'm really interested in whole-program compilation a la mlton...
09:34:28 <ihope_> Don't know where ld is, or what...
09:34:50 <int-e> it's the linker and it should be in your path.
09:35:03 <dons> $ ld --version
09:35:04 <dons> GNU ld version 2.15
09:35:19 <ihope_> Will I need it if I want to generate .hi files?
09:35:20 <dons> linkers are fun!
09:35:28 <dons> if you want to generate executables
09:35:40 <ihope_> So I won't need it for the .hi?
09:36:04 <Excedrin> usually ld is part of the binutils package if that helps
09:36:05 <dons> if you just use ghci, or only want to typecheck, then ghc doesn't call the linker, no.
09:36:24 <dons> you won't invoke it if you use: gcc -c
09:36:26 <dons> or ghc -c
09:36:37 <dons> but then you won't create executables either, only objects
09:36:38 <ihope_> Hmm, I somehow managed to toss my Haskell source file right into gcc. Oops.
09:36:47 <dons> gcc mightn't like that
09:36:53 <dons> ghc doesn't mind .c files though
09:37:02 <int-e> or .o files
09:37:06 <dons> (though it tends to link them against the haskell rts..)
09:37:17 <ihope_> It does what now?
09:37:49 <int-e> anyway I'd consider a system without ld to be crippled.
09:37:50 <dons> if you throw a .c files at ghc, it will compile it with gcc
09:38:02 <ihope_> Well, thanks. It's working now.
09:38:05 <dons> it is. maybe you just messed up your $PATH ?/
09:38:22 <ihope_> I dunno.
09:38:49 <ihope_> But I do know that "gcc C:\ghc\ghc-6.4.1\imports\Util\Buf.hs" won't do anything useful ;-)
09:40:39 <dons> ah, now it is all clear. the machine was broken, it's running windows ;)
09:40:52 <ihope_> :-)
09:42:23 <ihope_> Okay. Now that about half those modules compiled right, let's try to load this thing again..
09:42:42 <ihope_> Ooh.
09:43:46 <ihope_> Am I supposed to have a C:\ghc\ghc-6.4.1\imports\Util.hi?
09:44:20 <int-e> no.
09:44:56 <ihope_> Then what should I have for "import Util (split, breakOnGlue, clean)" to work?
09:45:18 <dons> Util? is that a lambdabot module?
09:45:24 <int-e> the Util module which is probably package-local
09:45:41 <dons> ihope, are you writing a lambdabot plugin?
09:45:46 * dons has fingers crossed
09:45:56 <ihope_> No, I'm trying to load IRC.hs.
09:46:11 <dons> load?
09:46:11 <dons> in ghci?
09:46:31 <ihope_> Yes.
09:46:46 <dons> $ ghci -fglasgow-exts -cpp IRC.hs
09:46:47 <dons> Prelude IRC>
09:46:49 <dons> should do it
09:47:21 <dons> I've aliased ghci to ghci -v0, so no silly banners each time. I think everyone should do it :)
09:47:43 <dons> and you need ghc 6.4.somethiing
09:47:51 <ihope_> I have 6.4.1.
09:47:52 <dons> ghci 6.4.something, I mean
09:48:03 <dons> ok so what happens when you run the above line?
09:49:12 <ihope_> Same error.
09:49:19 <charles> question: does STM work on 6.4.1?
09:49:26 <TuringTest> answer: yes
09:49:40 <TuringTest> charles: What twisted thing do you wish it to do for you?
09:49:51 <dons> ihope, same error? what error? 
09:50:18 <ihope_> Could not find module `Util':
09:50:19 <jethr0_> @hoogle interleaveST
09:50:20 <ihope_>   use -v to see a list of the files searched for
09:50:20 <lambdabot> Control.Monad.ST.Lazy.unsafeInterleaveST :: ST s a -> ST s a
09:50:20 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
09:50:21 <ihope_>   (imported from C:/Documents and Settings/Tanner/Desktop/IRC.hs)
09:50:32 <araujo> Hello around 
09:51:07 <dons> are you in the same directory as IRC.hs?
09:51:23 <ihope_> No.
09:51:29 <dons> is Util.hs in the same directory as IRC.hs
09:51:32 <dons> ah, thats your problem
09:51:34 <ihope_> No.
09:51:47 <ihope_> So what do I do?
09:51:55 <dons> what are you trying to do?
09:52:02 <dons> why isn't Util.hs next to IRC.hs?
09:52:35 <dons> every module that IRC.hs uses needs to be visible to the compiler. so it should either be in the local directory, or in a remote directory specfiied with a -i/some/path flag
09:52:57 <ihope_> Okay.
09:52:58 <dons> what are you doing to poor lambdabot, dare i ask?
09:52:58 <dons>  ;)
09:53:13 <ihope_> I'm trying to make a new IRC bot.
09:53:49 <dons> ok cool. probably best to start directly with the module hierarchy that lambdabot uses. and then remove things that you don't want.
09:53:59 <ihope_> Um...
09:54:01 <dons> or, I guess, you can start with IRC.hs, and bring in things when you discover you need them.
09:54:24 <dons> (which is what this Util.hs business is -- IRC.hs needs it, but you've lost it somehow?)
09:54:26 <ihope_> Yeah, I wanted to start pretty much from scratch.
09:54:51 <dons> have a look at the import list of IRC.hs -- you'll need all those modules.
09:55:13 <dons> then (recursively) look at the modules you've brought in, and bring in all their dependencies
09:56:05 <jethr0_> how do default implementations for numerical operators or operators of "Ord" work? is this an implementation thing or can it be done for arbitrary type classes?
09:56:05 <TuringTest> hmmm....I just saw that sourceforge has added subversion support.   I wonder what version control system might be next? ...
09:56:34 <dons> probably you'll just need IRC.hs, Config.hs, DeepSeq.hs ,Error*, LBState, Map, Shared. oh and Util
09:56:43 <TuringTest> jethr0_: default (Integer,Double) only works on Prelude types, I think.
09:56:56 <dons> jethr0_, you can write default methods when you declare a type class
09:57:07 <TuringTest> (oops)
09:57:14 <dons> or do you mean, how does defaulting work, the kind that TuringTest means.?
09:57:17 <dons> (I think not)
09:57:18 <jethr0_> ahh, gotta look in the report again, then
09:57:53 <ihope_> Hmm. Didn't find a Util.hs or a Util.hi.
09:57:58 <dons> example: 
09:57:59 <dons> class  (Eq a, Show a) => Num a  where
09:58:04 <dons>     (+), (-), (*)   :: a -> a -> a
09:58:04 <dons>     -- | Unary negation.
09:58:04 <dons>     negate      :: a -> a
09:58:07 <dons>     x - y		= x + negate y
09:58:08 <dons>     negate x		= 0 - x
09:58:15 <jethr0_> dons: when you implement "compare" in "Ord" the comparison operators reflect that implementation. and i was wondering how to do that myself
09:58:30 <TuringTest> jethr0_: http://www.haskell.org/onlinereport/decls.html#class-decls
09:58:35 <jethr0_> cool, thx
09:58:48 <jethr0_> didn't now it was so "standardly" possible
09:59:00 <dons> ihope, what did you do to Util.hs? it should be in the lambdabot top level?
09:59:26 <dons> isthat where you are borrowing the code from?
09:59:50 <ihope_> Heh. I just downloaded IRC.hs.
10:00:12 <dons> oh. grab the whol darcs repo for lambdabot
10:00:15 <dons> you'll need to start with something..
10:00:20 <dons> @versoin
10:00:20 <lambdabot> lambdabot 3p303, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
10:00:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:00:43 <dons> (this explains why you're missing like, 10 modules, and not making any progress ;)
10:00:48 <ihope_> :-)
10:00:56 <dons> less: import Foo only works if you have Foo :)
10:01:02 <dons> lessson.
10:01:55 <palomer> ok guys
10:02:11 <jethr0_> @vresoni
10:02:12 <lambdabot> Unknown command, try @listcommands.
10:02:32 <palomer> my prof doesn't think that things like data Foo:: (*->*)->* where Bar :: Foo Maybe is useful
10:02:36 <palomer> s/is/are
10:02:48 <palomer> can someone please prove her wrong
10:02:58 <ihope_> Um...
10:03:06 <jethr0_> beta3 of MS monad shell is out :)
10:03:19 <dons> damn them and there monads.
10:03:32 <ihope_> Just where is the use in it?
10:03:37 <Cale> here's betting that it has nothing to do with category-theoretic monads :)
10:03:38 <dons> but it's not reall monadic or anything, is it?
10:03:45 <Cale> I think it's OO.
10:03:52 <dons> maybe more like gonads?
10:03:55 <Cale> heh
10:04:21 <jethr0_> i thought they were applying the idea of monads to shell sequencing and value passing. but as i haven't read up on it, that might just be plain wrong
10:04:47 <palomer> someone give me a data constructor which takes an arrow kind as one of its arguments and that's useful
10:04:53 <palomer> err, type constructor
10:05:13 <dons> something in the monad transformer library?
10:05:29 <palomer> wait, that's true
10:05:46 <ihope_> data Foo :: (* -> * -> *) -> * where Bar :: something -> Foo
10:05:49 <dons> @kind Control.Monad.RWS.RWST
10:05:49 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
10:05:57 <dons> holy cow, batman!
10:05:57 <ihope_> There, I did the hard work :-P
10:05:59 <jethr0_> ah
10:06:17 * ihope_ does a greater lesser oh noes
10:06:18 <jethr0_> that sure is hard to read
10:06:22 <palomer> @kind StateT
10:06:23 <lambdabot> Not in scope: type constructor or class `StateT'
10:06:26 <palomer> @hoogle statet
10:06:26 <lambdabot> Control.Monad.State.StateT :: StateT s m a
10:06:26 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
10:06:26 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
10:06:33 <palomer> @kind Control.Monad.State.StateT
10:06:34 <lambdabot> * -> (* -> *) -> * -> *
10:06:48 <TuringTest> @kind Control.Monad.Cont.ContT
10:06:48 <lambdabot> * -> (* -> *) -> * -> *
10:07:22 * TuringTest thinks it is too bad there is no ParsecT
10:07:24 <ihope_> @kind Control.Monad.List.ListT
10:07:25 <lambdabot> (* -> *) -> * -> *
10:07:29 <jethr0_> *pah*, those MS guys and their .NET. i already fear the day when i'll have to work with it...
10:08:01 <TuringTest> jethr0_: http://research.microsoft.com/fsharp/fsharp.aspx
10:08:12 * jethr0_ agrees that parsec should be a transformer.
10:08:24 <jethr0_> but then again, it would be nice if most/all monads were transformers :)
10:08:35 <dons> @kind Data.Generics.Aliases.GenericM
10:08:35 <lambdabot> (* -> *) -> *
10:08:49 <jethr0_> TuringTest: i know. but i still don't like .Net (just as a cultivated prejudice)
10:09:00 * TuringTest has never used .NET
10:09:32 <dons> palomer, so you have enough ammo now for arguing for higher-kinded type constructors?
10:09:36 <palomer> ok, my supervisor in an idiot
10:09:45 <palomer> s/in/is
10:09:48 <palomer> well, my co-supervisor
10:09:50 <palomer> dons: yeah
10:09:57 <palomer> I can't believe I didn't think of StateT
10:10:06 <palomer> in fact, all monad transformers have these types of kinds
10:10:08 <palomer> right?
10:10:10 <jethr0_> i think it's time linux/unix got a new shell too. the old "everything is a file, every file is a collection of chars" paradigm has its uses, but at some point, it just doesn't fit the problem anymore </RANT>
10:10:18 <dons> monad transformers, generics
10:10:24 <dons> yeah.
10:10:47 <dons> @kind Control.Monad.Cont.ContT
10:10:48 <lambdabot> * -> (* -> *) -> * -> *
10:10:56 <dons> @kind Control.Monad.Error.ErrorT
10:10:57 <lambdabot> * -> (* -> *) -> * -> *
10:11:06 <dons> @kind Control.Monad.List.ListT
10:11:06 <lambdabot> (* -> *) -> * -> *
10:11:17 <dons> @kind Control.Monad.Reader.ReaderT
10:11:18 <lambdabot> * -> (* -> *) -> * -> *
10:11:26 <dons> @kind Control.Monad.Writer.WriterT
10:11:26 <lambdabot> * -> (* -> *) -> * -> *
10:11:37 <dons> @kind Control.Monad.RWS.RWST
10:11:38 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
10:11:52 <dons> @kind Control.Monad.Identity.Identity
10:11:53 <lambdabot> * -> *
10:11:58 <dons> so, yeah.
10:11:58 <palomer> @hoogle RWS
10:11:59 <lambdabot> Control.Monad.RWS.RWS :: RWS r w s a
10:11:59 <lambdabot> Control.Monad.RWS.RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
10:11:59 <lambdabot> Control.Monad.RWS.RWST :: RWST r w s m a
10:12:04 <palomer> what's RWS?
10:12:18 <dons> reader + writer + state :)
10:12:24 <palomer> @hoogle MaybeT
10:12:24 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
10:12:30 <TuringTest> palomer: and a pony
10:12:53 <palomer> pfft
10:13:15 <dons> @kind Control.Monad.ExceptT.ExceptT -- maybe it's in there
10:13:16 <lambdabot> Couldn't find qualified module.
10:13:16 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
10:13:16 <lambdabot> \\)?
10:13:19 <dons> nah.
10:13:41 <palomer> ok, now I have a dilemna
10:13:45 <palomer> either email her a snappy response
10:13:51 <palomer> or wait until the next confrontation
10:14:10 <palomer> which could be brutal
10:14:26 <dons> a polite email?
10:14:37 <dons> is thiis person a haskell programmer?
10:14:41 <palomer> polite? I want to smash her to bits!
10:14:46 <palomer> dons: no, and she swears by sml
10:15:04 <TuringTest> As in right hand on the SML ?
10:15:22 <palomer> if sml was a book, sure
10:15:52 <olleolleolle> Or a laser-disk from the early 90s. Big enough.
10:15:52 <TuringTest> She sounds strict
10:15:59 <palomer> oh, and she actually thinks in logical programming and refuses to understand anything else
10:16:13 <palomer> she's a fool
10:16:40 <dons> "strict" dear oh dear TuringTest ;)
10:16:57 * TuringTest is a fool as well...
10:16:59 <dons> well, they don't have monad transformers anywhere else, so maybe she wouldn't know about them.
10:17:30 <palomer> there isn't any excuse to being a type theorist and not knowing haskell
10:17:35 <palomer> who's with me?
10:17:53 <TuringTest> "Burn the witch!"
10:17:56 <dons> well, if you want to mess with fancy kinded things, fair enough.
10:18:22 <dons> there's no use for them in SML (hmm, maybe functors?) but certainly they're common in haskell
10:18:26 <palomer> well, erm, she didn't know what a kind was
10:19:06 <dons> oh, hmm. well, um. maybe you need a new supervisor ;)
10:19:10 <TuringTest> "Well, the birds and the bees help pollinate the ..."
10:19:18 <palomer> or, rather, kind in the haskell sense
10:19:42 <dons> what's a kind in the non-haskell sense?
10:20:06 <dons> kinds are kinds, like types are types. or did she not know haskell had kind annotations and so on?
10:21:04 <palomer> well, you can abstract over kinds
10:21:21 <palomer> and you do in dependently typed systems, methinks
10:21:33 <dons> sure. and in theorem provers
10:21:41 <dons> you 'sort' your 'kinds'.
10:22:01 <palomer> so she knew about these more abstract kinds
10:22:23 <palomer> but, seriously, she knows only one thing
10:22:31 <palomer> then again, maybe I shouldn't be complaining about my supervisor
10:22:33 * palomer shuts up
10:22:55 <TuringTest> I get it. palomer is the fox in this metaphor.
10:23:07 <palomer> which metaphor?
10:23:17 <TuringTest> "The fox knows many things, but the hedgehog knows one big thing."
10:23:27 <dons> hehe
10:24:04 <GeniXPro> @p (\x y -> [[x]] ++ [y] : [] )
10:24:04 <lambdabot> Maybe you meant: part paste pl pl-resume pointless poll-add poll-close
10:24:04 <lambdabot> poll-list poll-remove poll-result poll-show pretty .
10:24:11 <GeniXPro> @pl (\x y -> [[x]] ++ [y] : [] )
10:24:12 <lambdabot> (. (return . return)) . (++) . return . return
10:24:45 <dons> that's what you wanted, yeah? ;)
10:24:51 <TuringTest> dons: Should I just submit the new CTK entry, or do you want a crack at it ?
10:24:54 <GeniXPro> yep
10:24:59 <GeniXPro> had to show this guy up in ##c++
10:25:06 <dons> TuringTest, well, it works?
10:25:10 <dons> it works on 5M input?
10:25:14 <TuringTest> yup
10:25:20 <dons> I say, go ahead.
10:25:25 <dons> we can always improve it later
10:25:46 <palomer> well, all that she knows can be summarized by one word: twelf
10:25:54 * dons notes that with the same number of programs implemented, we're only 4pts behind C
10:26:19 <dons> ah, twelf! twelf is my favourite.
10:26:25 <palomer> have you used it?
10:26:30 <dons> but then maybe she wouldn't know of practical programming using fancy kinds
10:26:37 <jethr0_> dons: what was the problem with FFI'ing the regexp library the C entry is using?
10:26:45 <dons> yeah, I wrote a compiler for a dependently typed language which used twelf as the type checker
10:26:55 <palomer> is it really a nice system?
10:27:03 <dons> jethr0, that's what Text.Regex does.
10:27:07 <dons> and it sucks
10:27:18 <dons> twelf is nice. but Isabelle is nicer
10:27:43 <dons> twelf is good for specifying type systems though
10:27:45 <palomer> isabelle uses logical programming?
10:27:46 <Phyx-> hello, evening everyone. question again? is there an easy way to cast from an n-tuple to a list? i'm currently using patter recognition
10:27:49 <dons> it's really designed mainly for that.
10:27:53 <palomer> dons: isabelle isn't?
10:27:54 <jethr0_> weird, it should be possible to call it with similar speed as C does. or is lazyness the limiting factor?
10:27:58 <dons> nah, isabelle is more general
10:28:26 <palomer> well, erm, my work is in specifying a type system
10:28:31 <dons> and isabelle has more libraries, a nicer interfaces, more cool solving algoritms.
10:28:31 <palomer> and proving things about that type system
10:28:47 <dons> so for proving things in general, isabelle is good. for type systems, twelf is good.
10:28:58 <dons> and for things like operational semantics too.
10:29:16 <palomer> twelf is good for operational semantics?
10:29:32 <Phyx-> are there date comparing functions in haskell?
10:29:47 <palomer> (or is isabelle good for operational semantics)
10:29:55 <dons> yeah, palomer, check the mini-ml static and dynamic semantics in twelf.
10:30:04 <dons> isabelle is good for proving things about things
10:30:16 <dons> but twelf is good specifically for programming language problems
10:30:29 <Phyx-> hello? this thing on?
10:30:31 <palomer> are there alternatives?
10:30:34 <dons> @hoogle date
10:30:35 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
10:30:35 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
10:30:35 <lambdabot> Data.HashTable.update :: HashTable key val -> key -> val -> IO Bool
10:30:42 <dons> @hoogle time
10:30:42 <lambdabot> Graphics.HGL.Units.Time :: Integer
10:30:42 <lambdabot> System.Locale.TimeLocale :: TimeLocale
10:30:42 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [
10:30:42 <lambdabot> (String, String)] -> String, String -> String -> String -> String ->
10:30:42 <lambdabot> String -> TimeLocale)
10:31:01 <dons> @hoogle Time
10:31:01 <lambdabot> Graphics.HGL.Units.Time :: Integer
10:31:01 <lambdabot> System.Locale.TimeLocale :: TimeLocale
10:31:01 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [
10:31:01 <lambdabot> (String, String)] -> String, String -> String -> String -> String ->
10:31:01 <lambdabot> String -> TimeLocale)
10:31:21 <dons> @hoogle Clocktime
10:31:21 <lambdabot> System.Time.ClockTime :: ClockTime
10:31:21 <lambdabot> System.Time.getClockTime :: IO ClockTime
10:31:21 <lambdabot> System.Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
10:31:36 <dons> Phyx- check the docs for System.Time, iirc
10:31:39 <dons> @docs System.Time
10:31:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.
10:31:39 <lambdabot> html
10:31:49 <Phyx-> k
10:31:51 <Phyx-> thanx
10:31:58 <dons> alternatives to twelf? well, Isabelle. Coq.
10:32:10 <palomer> yeah, but I hear that Coq isn't so hot for programming languages either
10:32:19 <palomer> so twelf it is
10:32:25 <dons> I think if you know it, Coq can be used effectively
10:32:32 <dons> it's just twelf has this really hardcore interface
10:32:39 <palomer> hardcore?
10:32:41 <dons> whereas Coq and Isabelle give you proof general
10:32:48 <dons> twelf is all texty and hard on your eyes
10:33:11 <palomer> I thought proof general could work with twelf
10:33:46 <dons> here, a guy i work with wrote an implementatoin of ghc core in twelf: http://www.cse.unsw.edu.au/~sjw/non-cvs/code/coreLF.tar.gz
10:33:57 <dons> maybe the proof general interface has improved.
10:34:06 <dons> oh, that's right. I forgot. there's a reasonable emacs interface.
10:34:31 <dons> if you follow Appel's twelf tutorial, he walks through the emacs interface, which is much more usable than running 'twelf' by hand.
10:34:53 <Phyx-> dons: also, another question is there a build in function 2 do this? lta (a,b,c,d,e) = [a,b,c,d,e]
10:35:12 <dons> well, you just wrote the function :)
10:35:23 <dons> no, there's no buillt in function
10:35:33 <Phyx-> heheh, well wanted it to be all one liner :P ohh well
10:35:59 <dons> maybe keep everything as lists in the first place?
10:36:06 <Phyx-> i need the to be able o use zipWith on it.
10:36:09 <dons> 5-tuples are unusual.
10:36:15 <dons> zipWith5?
10:36:19 <Phyx-> nah, we're working with data submitted by the teacher
10:36:26 <dons> ah. ok.
10:36:52 <Phyx-> it's a tuple containing day,month,year,hour,minute
10:37:06 <dons> @hoogle (a,b,c,d,e)
10:37:07 <lambdabot> Prelude.undefined :: a
10:37:07 <lambdabot> Test.QuickCheck.Batch.bottom :: a
10:37:12 <dons> hehe
10:37:22 <dons> ah, a ClockTime almost.
10:37:59 <Phyx-> my problem is, finding if a time is between a time interval or not
10:38:05 <Phyx-> so, i
10:38:37 <Phyx-> so, i'm first making them from a tuple to a list, then using zipWith (-) on the 2 dates i'm comparing
10:38:47 <Phyx-> to get a difference list
10:38:57 <Phyx-> and working on that now. 
10:39:06 <int-e> > [2,3] < [3,1]
10:39:07 <lambdabot> True
10:39:12 <int-e> > [2,3] < [1,4]
10:39:13 <lambdabot> False
10:39:33 <Frederick> I got a naive question, besides a gentle introduction to haskell what else should I read?
10:40:00 <SyntaxNinja> Frederick: Yet Another Haskell Tutorial.
10:40:09 <Phyx-> > [2,3] < [2,4]
10:40:10 <SyntaxNinja> Frederick: The Haskell School of Expression (book)
10:40:10 <lambdabot> True
10:40:20 <Phyx-> > [3,3] < [2,4]
10:40:20 <lambdabot> False
10:40:32 <dons> Frederick, have you read http://haskell.org/learning.html
10:40:35 <int-e> Phyx-: if you reorder the tuple in a more sensible order, you can use that comparison. (it exists for tuples, too)
10:40:43 <dons> and there's a list here http://haskell.org/haskellwiki/Books_and_tutorials
10:40:59 <dons> @wiki Books_and_tutorials
10:40:59 <lambdabot> http://www.haskell.org/haskellwiki/Books_and_tutorials
10:41:02 <Frederick> dons, just the tutorials
10:41:53 <Phyx-> int-e: ok, i'll try that
10:44:35 <Frederick> Is Haskell Road to logic a good book?
10:45:22 <dons> yeah, it's quite interesting. you can read the intro chapter for free online, I think
10:46:35 <Frederick> can I actually learn haskell reading it?
10:47:19 <dons> yes, definitely
10:47:28 * Frederick opens the book
10:47:33 <dons> writiing some project as you work helps though
10:47:48 <dons> fire up ghci or hugs while you read and try things out
10:48:00 <dons> also, you can talk to lambdabot. it's answers a lot of haskell questions
10:48:05 <dons> > map (+1) [1..10]
10:48:06 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
10:48:08 <dons> @type map
10:48:09 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
10:48:14 <dons> @hoogle map
10:48:14 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
10:48:14 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
10:48:14 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
10:48:22 <dons> @docs Data.List
10:48:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
10:48:33 <dons> @fptools Data.List
10:48:33 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
10:48:37 <jethr0_> dons: you think trying to FFI the tcl regexp library makes sense. i'm tempted to try that...
10:48:50 <Frederick> dons, sure I got ghci here
10:48:55 <dons> well, we wouldn't be able to use it in the shootout.
10:48:57 <jethr0_> it's got a C header
10:48:58 <TuringTest> dons: The CTK entry has been submitted.  And  I see there is a submission for gcc pidigits entry that binds GMP
10:49:02 <dons> jethr0, but in general, maybe.
10:49:09 <dons> hehe. GMP eh?
10:49:12 <jethr0_> dons: why couldn't we use it? tcl should be installed, no?
10:49:25 * TuringTest nods
10:49:34 <TuringTest> dons:  https://alioth.debian.org/tracker/index.php?group_id=30402&atid=411646
10:49:35 <dons> jethr0, it's a bit 'iffy'. not sure if it 's really Haskell 
10:49:45 <dons> good stuff TuringTest
10:49:47 <jethr0_> it's just using an externally available library
10:50:08 <dons> well, if using ctk is questionable, expect tcl to be even more controversial
10:50:14 <jethr0_> hmm
10:50:20 <dons> i general, ffi bindings are frowned upon
10:50:32 <jethr0_> then GMP should be controversial too. or C using any non-standard libraries
10:50:43 <dons> yes yes. I know.
10:50:59 <dons> as Isaac says, it's an ad hoc way of comparing oranges and apples
10:51:05 <jethr0_> i won't argue. if i'll go through with it, i'll post results on the wiki
10:52:01 <dons> it would be an innteresting library for the haskell community, if you do a good job..
10:52:32 <TuringTest> The vastly different coverage of "core libraries" for the language implementations makes it apples and bowling balls
10:53:03 <dons> I can't really tell if that implements the lazy spigot algorithm: https://alioth.debian.org/tracker/download.php/30402/411646/303144/1278/pidigits.c
10:53:15 <TuringTest> jethr0_: If you can make a "mutable list" library that way, that would be fantastic.
10:53:38 <jethr0_> TuringTest: huh?
10:54:04 <TuringTest> You'd need mutable strings at least
10:54:09 <TuringTest> to bind TCL
10:54:18 <jethr0_> i'll see what problem i'll run into :)
10:54:33 <dons> maybe the C entry is ok. I guess it is.
10:54:37 <jethr0_> ah, you mean for the replace-part. i was thinking more about the matching part
10:54:48 <jethr0_> ya, but it's damn slow
10:55:21 <TuringTest> dons: gcc is always a special case.  No worries.
10:55:36 <dons> yeah.
10:55:37 <jethr0_> TuringTest: we can always call upon our gcc "heritage" :)
10:56:06 <TuringTest> Haskell is beating D on pidigits...
10:56:20 <dons> yeah, they increased the workload, and we win
10:57:24 <dons> interesting, SML is trying to catch up
10:57:42 <dons> they improved into 4th in pidigits.
10:58:38 <dons> oh, but SML is also like an evil ugly Haskell, every time I look at it.
10:59:19 <dons> with all the extraneous 'fun's and weird interleaving of pure and side effecting code
10:59:23 <dons> nasty.
10:59:49 <dons> nicer than ocaml though ;)
11:00:24 <TuringTest> careful.. palomer might hear you say good things about SML ...
11:02:08 <jethr0_> dons: i was considering writing a few lines of FFI myself, but what would i use to auto-generate FFI binding?
11:02:11 <jethr0_> s
11:02:41 <dons> that's another nasty thing. in general you need a preprocessor. to check for different locations of headers and the like. differrrent word sizes
11:02:51 <dons> but you don't have  access to that on the shootout box.
11:03:42 <jethr0_> k, but in general?
11:03:57 <jethr0_> i don't know which of the many alternatives is the canonical one :)
11:04:12 <dons> in general, hsc2hs is good. then there's also c2hs.
11:04:20 <jethr0_> k
11:04:33 <dons> less often I see greencard. (maybe that's more hugs-ish?)
11:04:56 <jethr0_> greencard hasn't been updated for years if i remember correctly
11:08:01 <palomer> ack! there's a calculus I can't seem to remember. something about head. head and S, but I forgot what S stands for
11:08:37 <palomer> every term is represented as h . s
11:08:47 <Excedrin> dons: there's really no community effort around the SML shootout, I just added a few programs for the missing ones based on the ocaml entries
11:09:33 <dons> yeah. though I think a while ago there was some effort?
11:09:44 <dons> from "the brotherhoood of SML"
11:09:48 <Excedrin> there was a little traffic on the mlton mailing list about it
11:10:02 <jethr0_> would be interesting to compare languages by how much solutions converged into clusters overall. that way one would be able to make some inferences (for example whether lisp/scheme is used more functionally or imperative)
11:10:05 <dons> and some on the ocaml lists too
11:10:26 <palomer> there isn't much of an sml community, from what I gather
11:10:31 <TuringTest> Haskell has a sufficient community behind the shootout -- the mailing list haskell-cafe mentioned it and then I made a couple of wiki pages and it snowballed from there.
11:11:01 <TuringTest> Making a cvs / svn / darcs repository is overkill, the wiki was just right.
11:11:04 <dons> palomer, well, maybe the haskell is more open-sourcey. and less academically bound?
11:11:17 <dons> TuringTest, yeah, I was thinking about that. I tend to agree
11:11:25 <dons> a wiki has the least barrier to entry
11:11:37 <TuringTest> dons: more academic than Haskell?  that's saying a lot.
11:11:45 <dons> just that it's not all papers.
11:11:56 <dons> we have a community of people who write free code for free
11:12:18 <TuringTest> Ah
11:12:18 <dons> whereas I don't think any of the SML compilers are large open source projects? are they tied more to university projcets? (maybe I'm wrong)
11:14:25 <TuringTest> dons: Speaking of papers -- I left all the bibliographic references in you comments in the CTK submission
11:14:39 <TuringTest> s/you/your/
11:15:11 <palomer> dons: I don't think sml is much of anything:o
11:16:20 <TuringTest> fight fight fight !
11:16:24 <dons> palomer, it's a breakthrough language. the definitionn of standard ML is a high water mark in language design.
11:16:37 <int-e> dons: the c pidigits code looks fine, if you accept that one multiplication by 0 is optimized away.
11:16:51 * TuringTest expects people will have the same argument about Haskell eventually
11:17:01 <int-e> dons: for some reason the other multiplication by 0 is still there.
11:17:02 <dons> it's embarrassing that we don't have a similarly rigorous definition for Haskell, as SML has.
11:17:16 <dons> int-e, yeah, I guess it is ok. 
11:17:21 <TuringTest> dons: Is something in Haskell 98 less well defined?
11:17:23 <int-e> dons: (in compose_r and compose_l, bs is always 0)
11:18:53 <palomer> dons: high water mark in language design or language verification?
11:19:03 <dons> the SML defn provides formal static and dynamic semantics. H98 has informal semantics. though people have since written papers on this .
11:19:09 <palomer> I don't find sml to be designed to be very usable
11:19:11 <dons> langauge definition and design.
11:19:33 <dons> also, things like functors/modules are stunning, and we're only just getting there in Haskell
11:19:35 <Excedrin> what's "usable" ?
11:19:41 <jethr0_> yeah, i just did my first match with tcl :)
11:19:49 <palomer> functors/modules are stunning, but that's its only selling point
11:20:11 <dons> ah well. you can write  Isabelle in it, so it can't be so easily dismissed, palomer ;)
11:20:34 <palomer> and they are quite clunky most of the time
11:20:39 <jethr0_> dons: can haskell do memory mapping and shared memory?
11:20:48 <dons> you can use mmap, yep.
11:21:05 <jethr0_> dons: hmm, i meant like mapping files into memory
11:21:26 <jethr0_> ah, mmap is enough, i guess
11:22:02 <dons> yes. look at Datta.FastPackedString.mmapFile
11:22:07 <dons> (in package fps)
11:23:35 <jethr0_> thx
11:24:24 <dons> Excedrin, you a ML refugee? :)
11:24:38 <Excedrin> I suppose so
11:24:42 <dons> I should run a poll on how many people are switching from OCaml, Lisp, ML, Clean..
11:24:52 <dons> @help poll
11:24:52 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
11:24:52 <lambdabot> poll-close poll-remove
11:25:17 <Excedrin> I'm not really switching, just trying to pick up enough Haskell to add another tool to the belt
11:25:22 <jethr0_> dons: don't forget scheme...
11:25:24 <int-e> dons: using that trick in the haskell program speeds it up (n=4000) from 2.524s to 2.356s here.
11:25:42 <olleolleolle> dons: Another poll: "Are you a dynamic-language tourist, coming to the really exotic places?"
11:25:58 <dons> int-e, which trick?
11:26:13 <dons> ah.
11:26:15 <dons> the 0 trick.
11:26:38 <olliej> anyone know a tostring function (eg. show) that doesn't put quotes around things?
11:27:09 <lisppaste2> int-e pasted "a trick for pidigits" at http://paste.lisp.org/display/17302
11:27:20 <dons> int-e, do you want to post your improved entry on the ShootoutEntry page of the wiki?
11:27:26 <dons> @oldwiki ShootoutEntry
11:27:26 <lambdabot> http://www.haskell.org/hawiki/ShootoutEntry
11:27:31 <dons> there's a page for pidigits.
11:27:40 <TuringTest> olliej:  showString "hello" ""
11:27:48 <TuringTest> >  showString "hello" ""
11:27:49 <lambdabot> "hello"
11:27:53 <TuringTest> > show "hello"
11:27:54 <lambdabot> "\"hello\""
11:28:05 <dons> add your faster entry at the top. it's a good idea :)
11:28:08 <ihope> What's showString?
11:28:33 <TuringTest> showString :: String -> ShowS   -- Imported from GHC.Show
11:28:44 <olliej> ah ha
11:28:56 <olliej> i was calling show twice
11:28:56 <dons> int-e, and add yourself to the credits. once it's up, I'll benchmark it on the machine I've been using, and submit it.
11:28:56 <TuringTest> > showString "hello" "world"
11:28:57 <lambdabot> "helloworld"
11:28:58 <olliej> i think
11:28:59 <ihope> But
11:29:00 <olliej> hmmm
11:29:16 <TuringTest> > show (show "hello")
11:29:17 <lambdabot> "\"\\\"hello\\\"\""
11:29:58 <TuringTest> dons: (While you are benchmarking, there is the CTK entry for regex-dna to run)
11:30:12 <mauke> @hoogle [a -> a] -> a -> a
11:30:13 <lambdabot> No matches, try a more general search
11:30:51 <dons> > > foldl1 (.) (replicate 100 show) $ "hello" -- sorry ;)
11:30:51 <lambdabot>  parse error on input `>'
11:30:56 <TuringTest> @type foldl1 (.)
11:30:57 <lambdabot> forall c. [c -> c] -> c -> c
11:31:02 <dons> > foldl1 (.) (replicate 100 show) $ "hello" -- sorry ;)
11:31:03 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\
11:31:03 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\
11:31:03 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:31:03 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:31:03 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:31:05 <lambdabot> [23 @more lines]
11:31:06 <palomer> omg, I'm actually going to use the  case () of () | construct
11:31:08 <dons> hehe
11:31:15 <olliej> oh goody, lab time...
11:31:19 * olliej dematerialises
11:31:20 <mauke> @type  foldr (.) id
11:31:21 <lambdabot> forall a. [a -> a] -> a -> a
11:31:36 <dons> yep, I'll do that too. but a bit later. I have to get into uni now.
11:31:39 <TuringTest> palomer: to do what?
11:31:52 <TuringTest> dons: Have fun...
11:32:06 <palomer> as a cond
11:32:35 <TuringTest> Ah, I see, the guard is the thing...
11:33:46 * TuringTest drops a smoke pellet and slips out the side door
11:33:56 <dons> @pl \s -> Just (s,s)
11:33:57 <lambdabot> Just . join (,)
11:34:30 <int-e> dons: ok, it's on the wiki
11:34:33 <dons> > foldl1 (.) (take 1000 $ unfoldr (\s -> Just (s,s)) show) "hello" -- TMTOWTDI
11:34:34 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\
11:34:34 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\
11:34:34 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:34:34 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:34:34 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:34:36 <lambdabot> [23 @more lines]
11:34:40 <dons> int-e, cool! thanks 
11:34:51 <dons> @karma+ unfoldr
11:34:51 <lambdabot> unfoldr's karma raised to 3.
11:38:34 <palomer> haskell seriously needs a generalized cond
11:39:34 <Lemmih> cond?
11:40:17 <jethr0_> dons: i'm a bit confused. how do you handle structs in FFI? if a function takes/returns a struct (not a pointer), how would i reflect that? using c2hs i can get the size of the struct, but then...?
11:41:28 <jethr0_> palomer: i haven't missed it yet, i think.
11:42:24 <palomer> cond{(a && b) -> foo; d||e -> bar; f -> baz}
11:42:38 <jethr0_> Lemmih: "cond {isTheSkyBlue -> 2; 2 > 4 -> 5; complicatedFunction a b -> 7}"
11:42:39 <palomer> jethr0_: you've never had nested if statements?
11:43:07 <jethr0_> palomer: not that much. in most cases a "case" sufficed
11:43:17 <Lemmih> case () of () | isTheSkyBlue -> 3 | 2 > 4 -> 5 | complicatedFunction a b -> 7?
11:43:26 <jethr0_> Lemmih: :)
11:43:45 <palomer> Lemmih: but that's cond! (in disguise)
11:43:52 <jethr0_> never used that idiom. partly because i don't particularly like deeply nested guards
11:44:05 <jethr0_> actually i don't like them at all
11:44:39 <Cale> those aren't nested guards
11:44:52 <Cale> that looks bad in-line
11:45:01 <jethr0_> Cale: no, i mean guards anywhere deeper than directly after the parameters
11:45:08 <Cale> oh
11:45:14 <int-e> jethr0_: see get and set hooks (c2hs)
11:45:27 <Cale> I think they're okay if you have some case expression
11:45:39 <Cale> palomer: what's wrong with my implementation of cond?
11:46:01 <jethr0_> int-e: thx, but i don't want to get/set them. just know how to type the struct in the "import". but maybe there are some hints there i have overlooked yet
11:46:04 <int-e> cond = lookup True
11:46:06 <palomer> http://cale.yi.org/autoshare/folds.png <--is it just me or is there a typo here?
11:46:10 <palomer> Cale: your list based implementation?
11:46:25 <palomer> the z on the right hand side
11:46:26 <Cale> typo?
11:46:31 <palomer> oh, nevermind
11:46:53 <Cale> z occurs in the function :)
11:47:13 <Cale> yeah, my list-based implementation
11:48:09 <Cale> I can't exactly claim that it's 'mine', as lots of other people have come up with it before, but I typed it out the other night :)
11:48:35 <Cale> (for others interested, it's just:
11:48:38 <Cale> infix 0 :->
11:48:38 <Cale> data Cond a = Bool :-> a
11:48:38 <Cale> cond :: [Cond a] -> a
11:48:38 <Cale> cond [] = error "cond failed to match"
11:48:38 <Cale> cond ((b :-> x) : xs) = if b then x else cond xs
11:48:40 <Cale> )
11:48:42 <Cale> :)
11:49:01 <int-e> > let cond = lookup True; test n = [(n `mod` 2 == 0, 2), (n `mod` 3 == 0, 3), (True, 42)] in map test [1..5]
11:49:02 <lambdabot> [[(False,2),(False,3),(True,42)],[(True,2),(False,3),(True,42)],[(False,2)
11:49:02 <lambdabot> ,(True,3),(True,42)],[(True,2),(False,3),(True,42)],[(False,2),(False,3),(
11:49:02 <lambdabot> True,42)]]
11:49:15 <int-e> > let cond = lookup True; test n = cond [(n `mod` 2 == 0, 2), (n `mod` 3 == 0, 3), (True, 42)] in map test [1..5]
11:49:16 <lambdabot> [Just 42,Just 2,Just 3,Just 2,Just 42]
11:49:16 <Lemmih> Pattern guard are more powerful.
11:49:53 <palomer> Cale: yeah, that's not bad
11:50:01 <int-e> oh hmm. the Just is ugly :)
11:50:22 <Lemmih> eg. | Just n <- ..., n > 10, Just b <- fn n -> ...
11:50:38 <int-e> > let cond = maybe (error "cond failed") id $ lookup True; test n = cond [(n `mod` 2 == 0, 2), (n `mod` 3 == 0, 3), (True, 42)] in map test [2..6]
11:50:39 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
11:50:58 <int-e> > let cond = maybe (error "cond failed") id . lookup True; test n = cond [(n `mod` 2 == 0, 2), (n `mod` 3 == 0, 3), (True, 42)] in map test [2..6]
11:50:59 <lambdabot> [2,3,2,42,2]
11:51:09 <palomer> oh my god. I just wrote a 20 line function that worked without any type errors
11:51:16 <Cale> :)
11:51:23 <palomer> ok, 11 lines
11:51:49 <jethr0_> int-e: catMaybes
11:51:49 <palomer> phew, false alarm, I compiled the wrong file
11:52:29 <int-e> jethr0_: doesn't do what I wanted.
11:52:29 <jethr0_> > let cond = lookup True; test n = cond [(n `mod` 2 == 0, 2), (n `mod` 3 == 0,3), (True, 42)] in catMaybes $ map test [1..5]
11:52:30 <lambdabot> [42,2,3,2,42]
11:52:40 <jethr0_> ah, sry
11:53:27 <int-e> jethr0_: (I wanted something functionally equivalent to Cale's code, but with the builtin pairs)
11:53:38 <palomer> Cale: but we'll be missing out on the compiler guard optimizations
11:56:37 <Cale> which ones?
11:56:58 <palomer> the ones you'd get with case () of () | ...
11:57:10 <palomer> (compilers do optimize guard, right?)
11:57:22 <palomer> s/guard/guards
11:57:32 <Cale> hmm, how would they be optimised?
11:58:33 <palomer> case () of () | a && b -> boo | a && c -> bar | a || d -> baz
11:58:33 <Cale> as far as I know, they're just desugared into if expressions
11:58:57 <palomer> you only need to calculate a once in those 3 expressions
11:59:22 <Cale> oh, no, it'll recompute it unless it gets caught by CSE
11:59:44 <palomer> CSE?
11:59:53 <Cale> common subexpression elimination
12:00:20 <Cale> of course, if 'a' is bound at a higher level, for example if it's a parameter, it will get computed only once
12:00:21 <dons> desugared into case True -> ; case False  ->. 
12:00:41 <Cale> right
12:00:54 <dons> case () of _ |  .... is probably more idiomatic
12:01:12 <palomer> yeah, and CSE won't catch your cond subexpressions
12:01:16 <Cale> after enough desugaring, the only thing which ever causes evaluation to occur in Haskell is case :)
12:01:17 <palomer> since they're wrapped in a Cond
12:01:26 <Cale> hm? why is that?
12:01:38 <Cale> in fact, I can ensure that they're commoned up using let
12:01:48 <_llll_> dumb question: how do i get a "not equals" (eg let f x = x*x in [ f x | x<-[-1..1], f(x)!=x])
12:01:50 <Cale> but CSE could surely catch something like that
12:01:57 <palomer> hrmph, I'll have to think about it
12:02:00 <Cale> not-equals is /=
12:02:01 <Igloo> _llll_: /=
12:02:17 <Cale> as is xor :)
12:02:17 <_llll_> ah.. thankyou
12:02:43 <palomer> welp, bbl
12:02:44 <_llll_> is there a decent online refernence?
12:03:02 <Cale> there are a few -- you'll want to actually read the prelude at some point
12:03:02 <dons> anyway, is compiled quite well. f a b c d = case () of _ | a && b -> putStrLn "1" | a && c -> putStrLn "2" | a || d -> putStrLn "3"
12:03:08 <dons> becomes: case (# GHC.Prim.State# GHC.Prim.RealWorld, () #) a_a17P of wild_a264 {
12:03:12 <dons>           GHC.Base.False ->
12:03:14 <dons>             case (# GHC.Prim.State# GHC.Prim.RealWorld, () #) d_a17S of wild1_Xd {
12:03:18 <dons>               GHC.Base.False -> __coerce (# GHC.Prim.State# GHC.Prim.RealWorld, () #) M.lvl9;
12:03:20 <dons>               GHC.Base.True -> M.lvl8 eta_s26V
12:03:23 <dons>             };
12:03:24 <Cale> http://haskell.org/onlinereport/standard-prelude.html
12:03:26 <dons>           GHC.Base.True ->
12:03:28 <dons>             case (# GHC.Prim.State# GHC.Prim.RealWorld, () #) b_a17Q of wild1_XB {
12:03:31 <dons>               GHC.Base.False ->
12:03:34 <dons>                 case (# GHC.Prim.State# GHC.Prim.RealWorld, () #) c_a17R of wild2_XN {
12:03:35 <Cale> ack!
12:03:37 <dons>                   GHC.Base.False -> M.lvl8 eta_s26V; GHC.Base.True -> M.lvl5 eta_s26V
12:03:40 <dons>                 };
12:03:42 <dons>               GHC.Base.True -> M.lvl2 eta_s26V
12:03:45 <dons> (no more Core postings for today :)
12:03:48 <dons> so it caseified everything
12:04:08 <Cale> you'd kind of expect it to :)
12:04:20 <dons> yep :)
12:04:31 <Cale> _llll_: yeah, look up for that prelude link
12:04:41 <Cale> and there are a number of "tours of the prelude"
12:05:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- this is the set of libraries which come with GHC
12:06:12 <Cale> http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html -- here's a brief tour of the syntax, if you don't want to read the whole report :)
12:06:21 <Cale> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
12:06:33 <dons> I think there should be a haskell t-shirt that says something like: "What's wrong with a little hard Core?"
12:06:37 <Cale> heh
12:06:42 <dons> and some Core on the back.
12:07:08 <Saulzar> You'd be lucky to find anyone who understood the joke at all :)
12:07:09 <dons> or "Haskellers are hard Core". something like that.
12:07:21 <dons> well, 10 people on the ghc users list might :)
12:08:15 <_llll_> thanks Cale
12:08:26 <Cale> no problem
12:10:27 <Cale> http://zvon.org/other/haskell/Outputglobal/index.html -- here's yet another :)
12:10:50 <Cale> which also appears to include the Haskell 98 standard libraries
12:11:49 <Cale> and, almost forgot, you can look things up by approximate type using  http://haskell.org/hoogle/
12:12:10 <_llll_> is there a better way to get the second element in a list than head $ tail $ list ?
12:12:21 <Cale> xs !! 1
12:12:23 <Beelsebob> _llll_: xs !! 1
12:12:43 <Saulzar> I think there is only one person in the world who reads Core better than Haskell, olliej who is writing a compiler for Core.
12:13:11 <Beelsebob> _llll_: if you're doing that, think about your algorithm, and whether you need to or not - it's a linear time index operation
12:13:23 <Beelsebob> so in general you shouldn't search your lists for items
12:13:42 <Cale> well, you shouldn't search with !!
12:14:19 <_llll_> i need to invert a list, where invert means "swap the first two elements"
12:14:41 <Saulzar> Often pattern matching can be easier
12:15:00 <Cale> \(x:y:xs) -> y:x:xs
12:15:13 <_llll_> hmm, the double colon thing didnt work before
12:15:26 <Cale> those parens aren't optional
12:15:50 <Cale> since it needs to know that : isn't a formal parameter
12:16:27 <_llll_> maybe that was it.  thanks
12:41:14 <Excedrin> why is the '-' in f -1 interpreted as (-)? is there a unary (-)?
12:44:17 <int-e> Excedrin: use f (-1)
12:46:15 <Excedrin> I understand that parens fix that, but I don't understand why it's parsed that way or what the rule is
12:46:55 <Excedrin> > - 3
12:46:56 <lambdabot> -3
12:46:59 <Excedrin> > + 3
12:46:59 <lambdabot>  parse error on input `+'
12:47:32 <int-e> Excedrin: unary minus is one of the dark points in Haskell's design
12:48:24 <Excedrin> ok, it's a special case, that's fine
12:49:40 <int-e> Excedrin: to quote from the Haskell report: "The special form -e denotes prefix negation, the only prefix operator in Haskell , and is syntax for negate (e)."
12:51:53 <JoshTriplett> How can I make a list of SomeType an instance of a type class?  If I use: instance TypeClass [SomeType] where ..., I get: Illegal instance declaration for `Executable [StackInst]' The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables)
12:52:36 <JoshTriplett> And if I make a synonym using: type OtherType = [SomeType], and then attempt to make OtherType an instance, I get "Cannot use type synonym in instance head".
12:52:56 <mauke> JoshTriplett: you can't
12:53:04 <JoshTriplett> mauke: Why not?
12:53:21 <mauke> dunno
12:54:37 <JoshTriplett> mauke: Is it just the special syntax of the list type or can you not make any specialization an instance?  (instance SomeClass (YAType a b c) where...)
12:54:59 <JoshTriplett> I should say, YAType A B C.
12:55:15 <Excedrin> int-e: cool, I read 3.4 and now it all seems clear
12:55:29 <mauke> I simply assumed you couldn't do that because of the error message: "... a,b,c are distinct type variables"
12:55:41 <mauke> specializations aren't variables
12:56:13 <JoshTriplett> Hmmm.
12:57:03 <JoshTriplett> This is just some sample code, but I'm trying to do something like: data Inst = ...; instance Executable [Inst].
12:57:10 <int-e> Excedrin: the real uglyness isn't mentioned - (-a) isn't a slice (flip (-) a); one has to resort to expanded versions, or, as a trick, to something like (-a+) to get a function that subtracts a.
12:57:12 <JoshTriplett> How could I accomplish that otherwise?
12:57:41 <JoshTriplett> int-e: Or "subtract a"
12:57:49 <JoshTriplett> int-e: Which is why that function exists. :)
12:58:25 <int-e> JoshTriplett: 'expanded versions' - well, not exactly. But I meant to include that in this term.
12:58:34 <JoshTriplett> int-e: Ah.
13:01:31 <joelk> having a bit of trouble with hopengl. I have the following two ways of loading image data into a texture:
13:01:36 <joelk> build2DMipmaps Texture2D Alpha16 8 8 pixelData
13:01:43 <joelk> texImage2D Nothing NoProxy 0 Alpha16 size 0 pixelData
13:02:24 <joelk> the first works, the second doesn't, though I thought it should. Anyone who can spot my mistake? And explain my misunderstanding..
13:05:05 <Saulzar> joelk, How is the texture filter set (when you go to use the texture) ?
13:05:21 <Saulzar> I've noticed that it always gets reset to use mipmaps (and I think it shouldn't)
13:05:41 <joelk> hmmm....
13:11:19 <joelk> get (textureFilter Texture2D) >>= print -----> ((Nearest,Just Linear'),Linear')
13:12:11 <Saulzar> Yep, that's using mipmaps..
13:13:24 <joelk> How do I turn that off? ((foo,Nothing),bar) for some foo, bar?
13:13:32 <Saulzar> Right
13:14:53 <joelk> hmm. I'll give that a shot.
13:18:44 <joelk> I still get solid white. However, textureLevelRange Texture2D $= (0,0) fixed 'er right up! Thanks Saulzar!
13:20:34 <Cale> there is, however, a function 'subtract' for use where you'd otherwise want a section
13:20:55 <Saulzar> textureLevelRange ??
13:20:57 <Cale> > map (subtract 2) [10..20]
13:20:57 <lambdabot> [8,9,10,11,12,13,14,15,16,17,18]
13:24:49 * int-e wonders if writing Haskell programs that generate C code is crazy.
13:25:19 <Saulzar> Hmm
13:25:26 <sjanssen> int-e: can't be too crazy -- GHC does it
13:25:37 <Saulzar> I guess that would do it, more or less the same as forcing no mipmap...
13:26:15 <Saulzar> joelk, Where did you set the filter params? I found that it was getting reset at each frame
13:26:45 <joelk> What is the *real* way of turning of mipmap? there's a generateMipmap :: TextureTarget -> StateVar Capability, but that doesn't look right.
13:27:31 <Saulzar> joelk, Well that just auto-generates your mipmaps using something similar to build2DMipmaps
13:27:38 <joelk> Ah, I was setting at texture specification only. Resetting every frame? That's not a nice "feature"
13:27:45 <joelk> that's what I thought
13:28:05 <Saulzar> Texture filter is independant of how the texture is specified (ie. it only applies when the texture is used)
13:28:54 <Saulzar> joelk, Yeah, I'm pretty sure it is a bug - should dig around and have a look.
13:30:53 <_llll_> can i improve on "map (const x) [0..k]" as a way to get a list [x,x,..,x] of length k+1 ?
13:31:30 <Saulzar> @type replicate
13:31:31 <lambdabot> forall a. Int -> a -> [a]
13:32:44 <joelk> Oh! it's working! Saulzar thanks! What I'm really diong is volume rendering with 3d textures. neat-o!
13:33:55 <_llll_> Saulzar: cheers
13:34:48 <Saulzar> Great - sounds fun. :)
13:46:08 <_llll_> am i not allowed a function beginning with a capital letter?
13:46:18 <dons> nope
13:46:32 <dons> types, modules and constructors are capitalised.
13:46:35 <dons> variables are lower case
13:46:39 <dons> and functionas are variables
13:57:54 <Cale> Constructors are a special kind of function :)
13:58:12 <Cale> (which is why you're not allowed to have just any function starting with a capital letter)
14:00:49 <_llll_> i guess the awesomeness of the [ ...| ...] syntax means i can live with that
14:01:37 <Cale> :)
15:02:42 <dons> @yow
15:02:43 <lambdabot> Awright, which one of you hid my PENIS ENVY?
15:02:47 <dons> @uptime
15:02:47 <lambdabot> uptime: 3 days, 39 minutes and 28 seconds
15:03:00 <araujo> dons, hiya!
15:03:15 <dons> gday araujo :)
15:03:24 <araujo> :-]
15:03:43 <dons> how's the code? anything cool for me to put into HWN?
15:08:55 <pundai> hey, http://rafb.net/paste/results/2XvBne49.html
15:09:33 <Cale> pundai: certainly
15:09:42 <Cale> mapM is just an ordinary function anyway :)
15:09:57 <pundai> Cale, whats mapM anyway
15:10:35 <Cale> mapM f [] = return []
15:10:58 <Cale> mapM f (x:xs) = do v <- f x; vs <- mapM f xs; return (v:vs)
15:11:11 <pundai> ah
15:11:29 <pundai> that was what i was missing
15:12:02 <Cale> it's defined in Control.Monad
15:12:21 <Cale> you can just put   import Control.Monad  at the top of your module there, and it'll start working :)
15:12:54 <ncalexan> @yow
15:12:54 <lambdabot> TAPPING?  You POLITICIANS!  Don't you realize that the END of the "
15:12:54 <lambdabot> Wash
15:12:54 <lambdabot> Cycle" is a TREASURED MOMENT for most people?!
15:12:59 <ncalexan> @keal
15:12:59 <lambdabot> love a black and white lower 128 from 32 up of ascii glyphs?
15:13:06 <ncalexan> @keal
15:13:07 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty
15:13:07 <lambdabot> right. and then they call fads
15:14:01 <araujo> dons, haha, right now hacking a bit in this portage gui 
15:14:21 <araujo> dons, not yet, but i might probably have something for you in a couple of weeks :-]
15:14:50 <araujo> dons, how abut you', how hmp3 goes?
15:15:11 * araujo has not listened too much mp3 in this last month
15:15:39 <Cale> hey, good idea
15:15:49 * Cale puts on some Steely Dan
15:17:33 <araujo> :-]
15:18:47 <dons> I've done some code to make it possible to change the curses colors dynamically, so I think I might just tag it as 1.0 this week
15:19:26 <ncalexan> @keal
15:19:26 <lambdabot> are you saying i am MegaMonad?
15:20:04 <dons> i couldn't believe he said that.
15:21:54 <araujo> cool
15:22:02 <araujo> haha
15:22:58 * araujo has no caffeine, only juice
15:24:27 <pundai> so Double is like c double?
15:26:16 <dons> yeah, sort of. it behaves like one.
15:26:22 <eivuokko> It typically is implemented using same underlying hardware type, but I don't think h98 guarantees that.
15:26:24 <dons> > 1.7132332113  :: Double
15:26:24 <lambdabot> 1.7132332113
15:26:45 <dons> it's not guaranteed, but the C backend to ghc uses C doubles
15:27:05 <dons> and the asm backend almost always gives the same result as the C backend too
15:27:12 <eivuokko> Which is prety much as usefull guarantee as h98 ;)
15:27:52 <pundai> gotcha, thanks
15:29:00 <dons> it says that a Double is "Real floating-point, double-precision"
15:30:01 <jethr0> dons: can you tell me where i can get the fullsize data set for the regex benchmark?
15:30:19 <jethr0> i've semi-completed the tcl bindings and would like to benchmark them.
15:30:23 <dons> download the C version of the 'fasta' benchmark
15:30:33 <dons> compile it, and pass it arguments to generate various different sizes
15:30:36 <jethr0> dons: k, i'd hoped there'd be a file somewhere :)
15:31:05 <dons> it's easier to generate it, than download huge chunks of data, I reckon.
15:31:11 <dons> but I can post one if you really want?
15:31:37 <dons> www.cse.unsw.edu.au/~dons/tmp/5M
15:32:57 <jethr0> thx, i've already done the fasta thingey
15:33:35 <jethr0> naive version takes 12.8s where ruby takes 8s.
15:33:42 <jethr0> but lot's left to optimize
15:35:16 <dons> huh. pretty good
15:35:29 <dons> using an ffi binding to tcl?
15:35:40 <dons> the problem is going to be the marshalling i guess
15:35:45 <jethr0> yup, but it's all pretty naively implemented. 25 lines or so.
15:35:46 <dons> a packed string version would be very good
15:35:59 <jethr0> and i've considered nothing wrt to substituting
15:36:05 <dons> not sure it's legal, mind you. but that's just my view.
15:36:14 <jethr0> dons: i'm posting on the wiki as we speak. it's just a proof of concept really :)
15:36:26 <dons> it would be a good lib to mention on the haskell-cafe, I reckon
15:36:31 <jethr0> dons: i accept that. was just a fun exercise
15:36:40 <dons> just post the code, and i'll mention it in the HWN next Monday
15:37:01 <jethr0> do you know if pattern matches are allowed to overlap?
15:37:23 <dons> not sure of the details, i suspect  they don't(?)
15:37:29 <araujo> is there any point onj it?
15:37:35 <jethr0> it's just a tiny change anyways
15:37:41 <dons> araujo?
15:38:08 <araujo> dons, pattern matches overlapping
15:40:15 <jethr0> araujo: for the regexp benchmark in the shootout
15:44:23 <pundai> does haskell have operator overloading
15:44:39 <araujo> jethr0, oh ok
15:44:46 <jethr0> pundai: yes
15:45:11 <jethr0> pundai, but likely in a different manner than you'd expect :)
15:48:03 <pundai> jethr0, type classes?
15:48:10 <jethr0> pundai: yes
15:49:09 <pundai> ok
15:52:08 <jethr0> dons: it's on the wiki
15:54:11 <palomer> okay
15:58:26 <danols> Hey all
15:58:41 <dons> jethr0, cool, i'll have a peep at it.
15:58:50 <danols> i have a question; i need to process an html file to grab some information from it ?
15:58:59 <danols> what is my best choice of action ?
15:59:06 <danols> regural expression prehaps ?
15:59:18 <dons> ah, hehe danols.
15:59:25 <dons> I think pattern matching is easiest
15:59:34 <danols> dons you mean regex ?
15:59:39 <dons> using normal haskell patterns.
15:59:49 <dons> f ('>':'x':'y':xs) = ...
15:59:53 <danols> hmmm 
15:59:54 <dons> that kind of pattern matching
15:59:56 <danols> ohhh yeah
16:07:13 <Cale> danols: or if what you're doing is a little more sophisticated, there's Parsec for easily writing parsers
16:07:28 <Cale> danols: and some libraries which specifically parse XML and HTML
16:07:49 <danols> Cale i see well it is a rather dirty webpage
16:08:43 <Cale> danols: hehe, another option is to get the xml2/html2 tool (html2 is more resistent to errors), which flattens an html file into easily parseable lines which give a path to each element and its content :)
16:08:51 <Cale> (that's not Haskell though)
16:09:15 <danols> Cale i see
16:09:24 <danols> Cale i'll try it with haskell pattern matching first
16:09:28 <Cale> yeah :)
16:11:18 <jethr0> k, gotta sleep. good night
16:12:39 <dons> Cale, xml2 eh? good trick
16:12:45 <Cale> yeah
16:13:01 <Cale> it makes it easy enough to parse xml/html from a shell script
16:13:12 <Cale> (and trivial in something like Haskell :)
16:14:16 <dons> yeah , that's what I was thinking
16:16:04 <jethr0> night
16:16:11 <araujo> Cale, that's not written in haskell?
16:16:20 <Cale> right
16:16:51 <Cale> In fact, I'm not even sure what it's written in, but it's a handy program to have on your system
16:20:21 <pundai> so lambda functions arent polymorphic?
16:20:38 <Cale> they can be
16:20:46 <pundai> but by default they dont seem to be
16:20:49 <Cale> (\x -> x) is polymorphic
16:21:05 <Cale> the problem is that pattern bindings are treated specially
16:21:21 <Cale> with something called the monomorphism restriction
16:21:59 <palomer> strictly speaking, (\x -> x) is monomorphic
16:22:00 <Cale> Pattern bindings are like when you either pattern match as in (x:xs) = ..., or just bind a single value like x = ...
16:22:11 <palomer> but you can think of it as being polymorphic
16:22:13 <Cale> palomer: hm?
16:22:22 <palomer> it only becomes polymorphic when bound
16:22:25 <Cale> @type \x -> x
16:22:26 <lambdabot> forall t. t -> t
16:22:41 <Cale> oh
16:22:48 <Cale> I suppose that technically, that's true
16:23:12 <palomer> @type automatically generalizes
16:23:14 <lambdabot> Not in scope: `automatically'
16:23:14 <lambdabot>  
16:23:14 <lambdabot> <interactive>:1:14: Not in scope: `generalizes'
16:23:20 <Cale> hehe
16:24:43 <Cale> http://mathworld.wolfram.com/TuppersSelf-ReferentialFormula.html
16:25:06 <Cale> hehe
16:25:21 <palomer> oh my god
16:25:32 <Cale> of course, it's not that amazing, given the size of n.
16:25:42 <Cale> but still cute :)
16:26:22 <Cale> Mathworld's typography sucks ever since they stopped using LaTeX.
16:26:25 <palomer> wait, it's graphic 1/2 = ... ?
16:26:32 <Cale> yeah
16:26:52 <Cale> that pixellated image at the top is the plot they're referring to
16:26:56 <Cale> 1/2 < ...
16:27:08 <palomer> yeah
16:27:45 <palomer> hrm
16:27:53 <palomer> the first argument of the mod doesn't seem integral
16:28:07 <Cale> that's a floor function
16:28:14 <Cale> so it must be
16:29:21 <Cale> obviously, the formula encodes every bitmap of that size somewhere, and you just set the bounds right to make the image of the formula appear
16:29:49 <palomer> there's no floor inside the topmost mod
16:29:58 <Cale> yes there is
16:30:10 <palomer> no, there isn't!
16:30:11 <Cale> mod(floor(y), 17)
16:30:24 <palomer> mod(floor(y)*2^-17....
16:30:34 <danols> f ('>':'x':'y':xs) = ... can someone explain this to me ?
16:30:52 <palomer> danols: same as f(">xy"++xs)
16:31:07 <danols> ohhh thanks
16:31:08 <Cale> oh, I see what you mean
16:31:31 <Cale> danols: except that you can't pattern match using that notation
16:31:37 <Cale> you can only use constructors
16:31:41 <danols> I see 
16:31:46 <danols> makes sense
16:31:53 <palomer> has anyone every looked into higher order patterns?
16:31:53 <danols> it be nice if you could :)
16:32:16 <palomer> I'm sure I'm not the first to think about it
16:32:18 <Cale> danols: there's HaRP, which lets you use regular expressions in patterns
16:32:29 <palomer> ahhhh!
16:32:43 <danols> what's HARP another haskell implementation ?
16:32:49 <Cale> no, just a preprocessor
16:32:55 <danols> Cale ?
16:33:09 <Cale> i.e. it translates from an extension of Haskell to plain Haskell.
16:33:22 <gour> Cale: something for you (if you're not already aware of it) http://www.vedicmaths.org/
16:33:26 <danols> i see i'll stick to normal haskell still since i'm learning it
16:33:30 <palomer> does harp work with arbitrary datatypes?
16:34:23 <Cale> palomer: iirc, it works with lists, maybe, and either
16:34:37 <palomer> oh, that sucks
16:34:41 <palomer> it should be generalized to any datatype
16:34:43 <Cale> it makes sense
16:35:37 <palomer> what makes sense?
16:35:49 <Cale> in some sense, those are exactly the types associated to *, ?, and | in regexps
16:36:14 <Cale> http://www.cs.chalmers.se/~d00nibro/harp/tutorial.html
16:36:54 <palomer> yeah, I saw it
16:37:06 <palomer> which are the types?
16:37:13 <danols> "*** Exception: C:/Haskel_Progs/mls_processor.hs:34:0-41: Non-exhaustive pattern
16:37:13 <danols> s in function findPrize
16:37:18 <danols> anyone know what that means ?
16:37:41 <araujo> danols, check for a missing pattern matching 
16:37:50 <Cale> danols: it means that you failed to handle a base case or recursive case which is needed
16:38:30 <palomer> I still think harp could take it one step further
16:39:13 <Cale> gour: that seems to be an awkward encoding of very basic theorems about the naturals
16:39:45 <Cale> oh, and some stuff about rationals too
16:39:57 <gour> Cale: you talk about sutras?
16:40:15 <Cale> well, the stuff on that site
16:40:23 <Cale> I'm not sure if there's more to it
16:41:25 <gour> Cale: onece i had a chance to skim through a book, it had stuff about differential & integr.
16:42:40 <gour> Cale: however, i did not delve into it. atm i'm more interested for vedic astrology and some quick algorithms for e.g. date arithmetic
16:43:00 <gour> Cale: it's interesting 'cause they had different time scale
16:44:12 <Cale> oh, it was apparently used from 1500 BC to 500 BC, which makes it noteworthy.
16:44:51 <gour> Cale: Bhagavata Purana is written down 5000 years ago ;)
16:44:55 <Cale> they didn't really have differential or integral calculus in full generality, but they were able to compute pi
16:45:19 <Cale> which is something like integral calculus
16:46:21 <gour> have yu heard about Surya SIddhanta scripture dealing with planetary orbits?
16:46:56 <Cale> nope
16:47:02 <Cale> I don't really know too much history
16:47:37 <gour> they were able to precisely calculate ephemeris for the main planets, were aware about precession of equinoxes etc.
16:47:48 <Cale> It's interesting that this stuff was known so long ago, but I wouldn't make any claims about it competing with the modern abstractions which mathematicians are using.
16:48:41 <gour> well, it's question what modern abstractions brings to us?
16:48:46 <eivuokko> Vedic maths?  Aren't they pretty convient for doing maths in your head?
16:48:49 <danols> is this allowed ?
16:48:50 <danols> findPrize a:b:c:xs | a:b:c:xs == (' ':' ':'$') = "found it"
16:48:50 <danols>                    | otherwise == findPrize xs 
16:49:22 <Cale> danols: perhaps you want...
16:49:22 <gour> eivuokko: yep, people in that age didn't require calcs & PCs
16:49:33 <danols> cale ?
16:49:39 <danols> cale: i'm all ears :)
16:49:54 <Cale> findPrize (a:b:c:xs) | [a,b,c] = "  $" = "found it"
16:50:14 <Cale> sorry, ==
16:50:19 <Cale> findPrize (a:b:c:xs) | [a,b,c] == "  $" = "found it"
16:50:55 <Cale>                      | otherwise        = findPrize (b:c:xs)
16:51:08 <danols> thanks
16:51:12 <Cale> actually, there's not much need to do that even :)
16:51:33 <Cale> findPrize (x:xs) | take 3 (x:xs) == "  $" = "found it"
16:51:39 <eivuokko> Isn't that find isPrefixOf in Data.List
16:51:53 <danols> take 3 ?
16:52:07 <Cale> > take 3 "Hello, World!"
16:52:08 <lambdabot> "Hel"
16:52:22 <Cale> and yeah, you could use isPrefixOf
16:52:30 <danols> what isPrefixOf ?
16:52:48 <Cale> > isPrefixOf "  $" "Hello"
16:52:48 <lambdabot> False
16:52:55 <Cale> > isPrefixOf "  $" "  $2000"
16:52:56 <lambdabot> True
16:53:23 <danols> hmmm
16:53:23 <Cale> that's in Data.List
16:53:32 <Cale> you might try writing it yourself :)
16:54:02 <Cale> your function as a whole can be written as
16:54:17 <eivuokko> > find (isPrefixOf "  $") ["asd","  $as"]
16:54:18 <lambdabot> Just "  $as"
16:54:36 <eivuokko> But certanly, it's good excercise if you are learning to write that on your own
16:54:44 <Cale> findPrize xs = if any (isPrefixOf "  $") (tails xs) then "found it" else ...
16:54:59 <Cale> where ... is taken care of by whatever base cases you didn't show me :)
16:55:03 <danols> damn i hate when haskell tells me incorrect indentation
16:55:23 <danols> Cale those are great tips however i need to stick to baby steps
16:55:38 <Cale> the basic rule of indentation is that things which are inside other things have to be indented more
16:55:49 <Cale> otherwise, you stay at the same level
16:56:06 <eivuokko> And don't use tabs.. :)  Or is you do, they must be 8-wide.
16:56:12 <danols> no spaces here
16:56:20 <danols> vim on auto-expand tabs
16:56:33 <Cale> okay, so it's expanding them to spaces :)
16:56:44 <danols> findPrize (x:xs) | take 3 (x:xs) == "  $" = "found it"
16:56:44 <danols>                  | otherwise == findPrize xs 
16:56:52 <danols> what's wrong with the indentetion here ?
16:56:58 <Cale> otherwise = ...
16:57:04 <danols> ohhh shit yes
16:57:06 <danols> thank you Cale
16:57:09 <Cale> np
16:59:51 <Cale> I suppose you have to write things recursively a bunch of times before you can really fully appreciate the higher-order functions which do it all for you :)
17:01:01 <Cale> There's a neat function called 'all' -- all p xs applies p to every element of the list xs, and checks to see if p returns True for all of them. Of course, it stops at the first False.
17:01:38 <Cale> tails is a function (in Data.List) which takes a list and returns the list of all tails of it:
17:01:41 <Cale> > tails [1,2,3]
17:01:42 <lambdabot> [[1,2,3],[2,3],[3],[]]
17:02:30 <danols> ok so the string i'm interested is from "   $" to " "
17:02:34 <danols> this is what i have so far
17:02:35 <danols> findPrize (x:xs) | take 3 (x:xs) == "  $" = helper xs ' '
17:02:35 <danols>                      where helper x:xs res | x /= ' ' = helper xs x
17:02:35 <danols>                                            | otherwise = res 
17:02:35 <danols>                  | otherwise = findPrize xs 
17:03:02 <danols> i believe my syntax is incorrect
17:03:09 <Cale> you might be forced to move the where clause below the second guard
17:03:15 <danols> i see
17:03:28 <Cale> where is part of the function binding as a whole, and scopes over all the guards
17:03:57 <Cale> also, you need parens around x:xs
17:04:07 <Cale> since that's parsed as 3 parameters
17:05:45 <danols> thank you it's loading now but working yet :)
17:07:31 <Cale> Perhaps   helper (x:xs) res | x /= res = x : helper xs res
17:07:48 <Cale> and otherwise return the empty string?
17:08:27 <Cale> this, by the way, is called takeWhile
17:08:44 <Cale> > takeWhile (/= ' ') "Hello, World!"
17:08:45 <lambdabot> "Hello,"
17:13:11 <danols> Cale may you take a look at this ?
17:13:25 <danols> findPrize (x:xs) | take 3 (x:xs) == "  $" = helper xs []
17:13:25 <danols>                  | otherwise = findPrize xs 
17:13:25 <danols>                      where helper (x:xs) res | x /= ' ' = helper xs (res++[x])
17:13:25 <danols>                                              | x == ',' = helper xs res
17:13:25 <danols>                                              | otherwise = res 
17:13:40 <danols> findPrice "    $324,324" returns nothing
17:13:46 <danols> an empty set
17:14:34 <Cale> yep
17:14:42 <Cale> look at what helper does
17:15:04 <Cale> it always returns res unchanged
17:15:06 <danols> Cale i know i can't seem to see my error though
17:15:20 <Cale> oh, wait
17:16:13 <Cale> er, okay
17:16:24 <Cale> oh
17:16:27 <Cale> I see
17:16:34 <danols> Cale ? :)
17:16:35 <Cale> suppose that  take 3 (x:xs) == "  $"
17:16:54 <Cale> that means that the first 2 characters of (x:xs) are ' ' and '$'
17:17:11 <danols> k
17:17:24 <Cale> you probably want to call helper starting with drop 2 xs or drop 3 (x:xs)
17:17:30 <danols> OHHH YEAH
17:17:32 <Cale> (which are the same)
17:17:40 <danols> ofcourse
17:17:56 <Cale> also, the extra parameter is awkward
17:18:15 <Cale> you can just return some of the string before recursing
17:18:34 <Cale> helper (x:xs) | x /= ' ' = x : helper xs
17:19:12 <danols> ohhh yeah
17:19:16 <danols> that's smart
17:20:39 <ProfTeggy> Morning all.
17:21:03 <danols> argh
17:21:07 <danols> morning ProfTeggy
17:22:41 <danols> ohhh man i feel like such a noob
17:22:45 <danols> i'm getting :  Couldn't match `[Char]' against `Char'
17:22:45 <danols>    Expected type: [Char]
17:22:45 <danols>    Inferred type: Char
17:23:30 <Cale> you're using a string like a character or vice versa
17:24:35 <danols> Cale: can i paste it here again ?
17:24:51 <Cale> yeah
17:24:56 <Cale> or you can use
17:24:59 <Cale> lisppaste2: url
17:24:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:25:08 <danols> findPrize (x:xs) | take 3 (x:xs) == "  $" = helper (drop 3 (x:xs))
17:25:08 <danols>                  | otherwise = findPrize xs 
17:25:08 <danols>                      where helper :: String -> String
17:25:08 <danols>                            helper (x:xs) | x /= ' ' = x : helper xs
17:25:08 <danols>                                          | x == ',' = helper xs
17:25:08 <danols>                                          | otherwise = x 
17:25:31 <Cale> otherwise = []
17:25:34 <ncalexan> @type isPrefixOf
17:25:35 <lambdabot> Not in scope: `isPrefixOf'
17:25:37 <danols> helper takes a String and returns a String
17:25:42 <danols> ohhh
17:25:43 <ncalexan> @hoogle isPrefixOf
17:25:43 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
17:25:57 <ncalexan> That'll do part of your 'drop 3...'
17:25:58 <ProfTeggy> danols, yes, but x is a Char bot a String
17:26:04 <ProfTeggy> s/bit/not/
17:26:11 <ProfTeggy> s/bot/not
17:26:49 <danols> i see so my prog was this String -> String -> Char ?
17:27:09 <ProfTeggy> danols, no
17:27:22 <danols> ok ?
17:27:36 <ProfTeggy> danols, the two cases (x == ','  and otherwise) return values of different type
17:27:51 <danols> yes 
17:27:56 <ProfTeggy> They can't
17:27:58 <danols> i understand
17:28:13 <danols> i'm getting non exaustive search pattern error
17:28:16 <danols> what does that mean ?
17:28:48 <ProfTeggy> danols, no case of helper is prepared to handle the empty string "" (or [])
17:29:05 <danols> hmmm
17:30:11 <danols> you always must include an empty list case ?
17:30:25 <ProfTeggy> danols, you don't have to in the strict sense
17:30:40 <ProfTeggy> but helper will fail (at runtime) whenever an empty list is encountered as its argument
17:30:58 <ProfTeggy> That's why you get a warning here (not an error)
17:31:13 <danols> it's an exception
17:31:24 <danols> must be a GHCI thing
17:31:29 <danols> that it won't allow it
17:31:31 <danols> ?
17:31:48 <eivuokko> It causes an exception, yes.
17:31:56 <ProfTeggy> danol,s an exception at runtime
17:31:56 <danols> it makes sense now
17:32:01 <ProfTeggy> and a compile time warning
17:32:11 <danols> thank you guys i feel like i'm recalling most of what i knew about haskell again
17:32:18 <danols> function is working now :)
17:38:58 <gour> Cale: this one is written by mathematician - http://www.amazon.com/gp/product/0892131489/002-7377001-6412850?v=glance&n=283155
18:02:21 <araujo> @index zipWithM_
18:02:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
18:02:22 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
18:02:22 <lambdabot> Control.Monad.Error, Control.Monad.List
18:03:14 <ski> @type Control.Monad.zipWithM_
18:03:14 <lambdabot> forall (m :: * -> *) b a c.
18:03:14 <lambdabot>          (Monad m) =>
18:03:14 <lambdabot>          (a -> b -> m c) -> [a] -> [b] -> m ()
18:34:41 <danols> anyone alive ?
18:37:30 <danols> anyone alive ?
18:37:50 <eivuokko> Yeah.
18:38:25 <danols> hmm ok 
18:38:38 <danols> simpleHTTP :: Request -> IO (Result Response)
18:39:12 <danols> Result is of type : type Result a = Either ConnError   {- error  -}
18:39:12 <danols>                        a           {- result -}
18:39:23 <eivuokko> Yeah.  Looks like the http package.
18:39:27 <danols> i'm trying to get the Result
18:39:36 <danols> Right (response) dosen't work
18:40:19 <danols> eivuokko how would I go about getting the Result section ?
18:40:31 <eivuokko> do x <- simpleHTTP ...; case x of (Right result) -> putStrLn "Yay"; (Left _) -> putStrLn "Failed."
18:40:40 <danols> without case :)
18:41:04 <eivuokko> let (Right result) = x (instead of case in my example)
18:41:37 <danols> i have response <- Right (simpleHTTP ...) but that gives me an IO type error
18:41:46 <eivuokko> You need patterns anywya.  Data.Either might have some getter-method .. but I dunno.
18:41:59 <eivuokko> Nah.  do (Right result) <- simpleHTTP ..
18:42:19 <danols> i'm not sure i understand that one
18:42:21 <eivuokko> You might want to practice more: What is the diffrence between expression and pattern
18:42:32 <danols> could you explain that more ?
18:42:55 <eivuokko> Sorry, got to get some lunch.
18:43:04 <danols> k thanks
18:43:07 <danols> :)
18:44:22 <eivuokko> Anyway..expression creates soemthing, pattern takes something apart (a bit naive description maybe)...let x = y ... x is pattern and y is expression.  case x of ..   x is expression, case x of .. is expression, but the parts case x of y -> z ... y is pattern and z is expression
18:44:26 <eivuokko> And now off.
19:28:12 <neologism> whats the name of the haskell-implemented perl6 compiler?
19:28:18 <neologism> pugs!
19:29:02 <ProfTeggy> neo, are you an expert in rhetorical questions? ;-)
19:30:31 <neologism> no.. I just remembered that 2 seconds after I asked the question :)
19:30:38 <ProfTeggy> :-)
19:30:52 <neologism> it happens to me quite often
19:30:57 <neologism> mostly during exams... ;)
19:31:12 <xah> can anyone recommend a haskell tutorial?
19:31:13 <neologism> (you know the answer 30 seconds after you leave the exam)
19:31:23 <ProfTeggy> neo, that's inefficient
19:32:05 <neologism> inefficient?
19:32:16 <ProfTeggy> In terms of achieved marks, I mean
19:32:24 <neologism> sure ;)
19:32:33 <neologism> but what can I do?: )
19:33:23 <ProfTeggy> Seems time travel is the only wait out here
19:33:23 <neologism> xah: there's a lot on haskell.org
19:34:17 <xah> neologism: i'm familiar with them, have checked out a few, but wanted a best recommendation
19:34:25 <xah> didn't like what i checked out
19:34:56 <neologism> xah: the art of functional programming
19:34:58 <neologism> thats a great book
19:35:04 <neologism> (I hope I remember that name correctly-
19:35:26 <xah> any online ones?
19:35:36 <gour> xah: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
19:35:45 <gour> xah: but not online
19:36:35 <xah> i'm familiar with haskell books out there... i just wanted a online one for now
19:36:59 <neologism> well... the best way to learn haskell is to rpogram in it
19:38:03 <xah> has anyone learned haskell without a printed book, and can recommend a tutorial he liked best?
19:38:57 <tromp_> "a gentle introduction" is great
19:39:15 <xah> tromp_: i started with that, i think it's the worse. :)
19:39:21 <xah> worst.
19:39:43 <tromp_> i read that together with the Haskell Report
19:39:54 <olleolleolle> xah: I am very happy with Yet Another Haskell Tutorial.
19:40:39 <olleolleolle> (I am also trudging along, into functional land.)
19:40:39 * jbc recommends Haskell for C programmers
19:41:11 <tromp_> you'll enjoy reading why FP matters
19:41:21 <jbc> http://www.haskell.org/~pairwise/intro/intro.html
19:46:03 <tibbe> @quote
19:46:04 <lambdabot> oleg says: The implementation of RSA on type level is left for future
19:46:04 <lambdabot> work.
19:46:10 <tibbe> @quote
19:46:11 <lambdabot> oleg says: The implementation of RSA on type level is left for future
19:46:11 <lambdabot> work.
19:55:44 <xah> olleolleolle: thanks for that recommendation... i'll try that one.
19:55:46 <olleolleolle> Oh, the pattern matching concept is so elegant. Makes subclassing seem like spaghetti-coding.
19:56:38 <olleolleolle> xah: I'd like to thank you for the Gentle Introduction, as well. I have fooled around with some texts, never finishing any, but Gentle Introduction tells me things on a quite formal level, which at this juncture is great for me.
19:57:32 <xah> olleolleolle: ha ha... but i don't like the Gentle Intro at all
19:58:05 <xah> it's not Gentle, nor is it mathematically formal. It looks like math geeking to me.
19:58:09 <olleolleolle> Very computer sciencey.
19:58:20 <olleolleolle> For beginners like me.
19:58:45 <olleolleolle> I feel right at home..
19:58:45 <xah> what i'm trying to say is that that book is garbagish.
19:58:52 <olleolleolle> xah: I get that. 
19:59:34 <xah> i suppose the text books that costs money will be much, much better, if you want computer science oriented books.
19:59:48 <xah> books. -> materials.
19:59:50 <olleolleolle> But, with me reading "the delta" of many texts, and fiddling with the GHCi, at some point, I will be doing something that works. My immediate aim is to do some Html/XML-RPC things.
20:00:28 <olleolleolle> I have time on my side. This is hobby-horse computing for me. But fine stuff.
20:00:45 <olleolleolle> I meant to say: this is leisure for me, not work.
20:02:57 <araujo> xah, no need to understimate free material 
20:03:10 <araujo> there are pretty good free stuff out there
20:03:17 <integral> I mean, the haskell report is free!
20:03:53 <araujo> nevertheless, if you want to go serious with something, you wil need a book for it sooner or later, in the case of Haskell, i recommend the Bird book.
20:07:09 <olleolleolle> araujo: Bird == the multimedia one?
20:07:52 <araujo> ?
20:08:17 <araujo> Richard Bird's book, Introduction to Functional Programming using Haskell 2end.
20:08:29 <olleolleolle> araujo: the Bird book, is that the book that teaches Haskell via multimedia. OK, not that one, well good.
20:09:33 <ProfTeggy> olle^3: you are referring to the Haskell School of Expression by Paul Hudak
20:09:48 <olleolleolle> Yes, professor.
20:10:18 <olleolleolle> Oh, and Hudak also was a co-author of the Gentle Intro, right? He is a video game guy?
20:10:27 <ProfTeggy> No :-)
20:10:34 <dons> hehe. no.
20:10:45 <olleolleolle> Mixing it *all* up.
20:10:46 <ProfTeggy> http://www.cs.yale.edu/homes/hudak-paul/
20:11:04 <dons> I like "olle^3" much easier to type.
20:11:05 <olleolleolle> Is he the HOOD guy?
20:11:17 <ProfTeggy> No
20:11:34 <olleolleolle> (haha, running through my very short list of Haskell celebrities now.)
20:12:51 <olleolleolle> I got one of those right, though, mr Hudak was part of the Gentle Intro author team. The "video game guy" I referred to was the author(s) of "Haskell for C Programmers".
20:13:12 <araujo> The GI tutorial mist not be _so_ Gentle for learning Haskell, but i think its main goal is to *show* you what Haskell is all about.
20:13:22 <araujo> might*
20:14:00 <dons> @seen shapr
20:14:00 <lambdabot> shapr is in #scannedinavian. I don't know when shapr last spoke.
20:14:57 <olleolleolle> araujo: Good description of the text's intention. Thanks. I want just that, right now, need an overview of what is cool about Haskell, and see some of it in action.
20:15:30 <dons> perhaps, the Why Haskell Matters article on the wiki?
20:15:55 <dons> its's an overview of what is cool, at least.
20:16:05 <dons> @wiki Why_Haskell_matters
20:16:06 <lambdabot> http://www.haskell.org/haskellwiki/Why_Haskell_matters
20:16:51 <olleolleolle> http://haskell.org/tutorial/stdclasses.html has a section 8.4, which talks about derived types; it seems like it is used a bit like Ruby's Mixins.
20:17:20 <olleolleolle> "If your class implements <=> and each(), it'll be ready to be an Enumeration."
20:18:56 <olleolleolle> So, I could then mix in Enumerable, and I could use everything from Enumerable on my class.
20:19:49 <olleolleolle> This was practical, I think:  [Wednesday .. Friday]	=>	[Wednesday, Thursday, Friday]
20:20:44 <vincenz> except that haskell's types are compiletime not runtime making it more robust ;)
20:21:02 <dons> and faster :)
20:21:07 <vincenz> and better :)
20:21:17 <vincenz> (not to mention just plain sexier)
20:22:37 <olleolleolle> Good, then it means I understood what they were going on about in the text.
21:03:05 <xah> darn, all these tutorials are damn verbose
21:03:17 <xah> is there a tutorial for say, expert lisper?
21:04:13 <araujo> xah, we only do real functional programming here
21:04:15 * araujo giggles
21:05:37 <sieni_> xah: Which tutorials have you looked at?
21:06:09 <Lemmih> xah: There's the haskell98 report. Or the Gentle Introduction.
21:06:18 <xah> one by Graham Hutton, one by Damir Medak, one by Hal Daume
21:06:45 <xah> there are lots of problems with people in the programing industry
21:06:47 <integral> such an expert shouldn't need a tutorial.  the report explains the syntax
21:06:56 <xah> lol
21:09:12 <tromp_> then there's the GHC source, which also serves as a specification of Haskell:)
21:17:24 <sieni_> xah: well, I've liked Hal Daume's yet another haskell tutorial and also Thompson's book "Haskell: the Craft of Functional Programming", but both are a bit too elementary
21:18:07 <xah> i wished there's a elaborate version of this page: http://www.haskell.org/hawiki/HaskellDemo
21:18:17 <sieni_> xah: I guess you could take a look at "Purely Functional Data Structures" by Okasaki
21:19:11 <xah> where, the texts simply get on with haskell code, instead of pages upon pages of talks about concepts and warnings and why's this or that's.
21:20:10 <xah> the academic types will insert pages upon pages of inane academic useless confusing jargons, like ref transp, "destruction update", and so on pure garbage.
21:20:27 <eivuokko> Hehe
21:20:29 <sieni_> "ML for the working programmer" is nice, but it's not about Haskell :-/
21:21:00 <eivuokko> Learning haskell if you are not comfortable in skimming over academic stuff...heh might not be viable just yet.
21:22:01 <xah> seriously, isn't there some sites about Haskell for Lisp programers?
21:22:36 <sieni_> xah: Tell me when you find one.
21:22:44 <tuomov> hathkell?
21:22:44 <Lemmih> What's wrong with http://www.haskell.org/tutorial/?
21:23:12 <xah> that one is the worst i think
21:23:38 <xah> that one the authors don't even know how to write, or the basic concepts of writing a tutorial
21:24:06 <xah> that one is like, a bunch of computer geekers got together, who knew haskell well, and said "let's write a tutorial",
21:24:14 <jbc> heh
21:24:22 <eivuokko> I'd go for your fav haskell program or lib and tour of haskell syntax or so
21:24:32 <Lemmih> xah: It's not a tutorial. (The URL is a bit misleading)
21:24:43 <xah> and the result is one confused ball, mixed with half-assed math formalism, half-assed trying to be practical, and half-reference half-tutorial and half everything.
21:24:57 <jbc> good coding and good pedagogical style do not often go hand in hand
21:25:05 <xah> and among about the 5 or 6 tutorials of which i've read a chapter, that one is the LEAST gentle.
21:25:13 * jbc applauds
21:25:43 <Lemmih> xah: It's an introduction to Haskell. It will go through /every/ aspect in Haskell.
21:26:04 <xah> i rather like the Haskell Report (i.e. the lang spec) than that "gentle intro".
21:26:06 <Lemmih> xah: But you don't want it gentle. You're an expert lisper.
21:28:06 <jbc> a much more useful question: what range of %hh%hh numbers, when un-url-decoded, generate valid kanji?
21:28:49 <xah> jbc: you mean the unicode range for chinese chars?
21:28:55 <eivuokko> Might we interest you in content of unicode.org?
21:30:32 <xah> please some haskell experts: elaborate this page and it can grow into a book: http://www.haskell.org/hawiki/HaskellDemo
21:30:43 <xah> and it'll kick ass of them all.
21:31:15 <xah> i'm not a lisper, but even in lisp i think it is only until recent years a "practical" book became available
21:31:50 <jbc> xah: no, japanese
21:31:52 <integral> then maybe what you need isn't a haskell tutorial, but a tutorial in the terminology, and theory that haskell uses?
21:31:56 <eivuokko> xah, Have you read http://www.cs.uu.nl/~afie/haskell/tourofprelude.html and http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html?  Maybe they are nice if you are looking for that kind of thing
21:32:32 <jbc> eivuokko: yes, but this is a silly one-liner and my brain hurts
21:32:38 <xah> jbc: hanji is the Japanese's term for Chinese charaters.
21:32:46 <xah> hanji->kanji
21:32:48 <Lemmih> xah: I don't see the problem in writing a warning about Haskell's immutable nature when most newbies will hit that wall hard.
21:34:10 <xah> Lemmih: for instance there, don't âimmutableâ this or that. Just say that variable can't be changed once assigned.
21:34:16 <jbc> ah, okay. What do you call the character set that the average japanese website would be likely to use? 
21:34:43 <xah> jbc: simply Japanese character sets.
21:34:50 <integral> xah: that's what immutable means though...   and I wouldn't have said it was particulary obscure techspeak...
21:34:53 * jbc writes a google-seppuku generator
21:35:00 <integral> (ie, you'd find it in a normal dictionary)
21:35:07 <mauke> I remember seeing something like shift-jis in w3m
21:35:11 <Lemmih> xah: Ah, so you're against the academic jargon?
21:35:11 * jbc wouldn't call 'immutable' obscure in the least
21:35:33 <integral> now, endomorphisms, endofunctors, automorphisms etc definately *are* jargon ;-)
21:38:40 <xah> anyhow... i short i find haskell docs verbose, and ridden with academic jargons... however, it is far better than most docs in the industry (e.g. perl, python, unix, apache)...
21:40:14 <eivuokko> There isn't much sense to learn haskell if you can't live with academic jargon, imo.  The haskell community just simply uses the jargon, so getting in to the language and using avaialble libraries and compielrs just requires knowing the slang.
21:40:15 <mauke> xah: are you xah lee?
21:40:16 <ayrnieu> no, xah, it is not better than Perl's documentation.  But, with white papers, it is good.
21:42:59 <xah> some examples of quality documentation: http://xahlee.org/perl-python/quality_docs.html
21:43:11 <mauke> I think that means yes
21:43:30 <xah> mauke: may i kiss your hand?
21:44:01 <mauke> xah: you may stop spamming my newsgroups
21:44:54 <xah> as to the jargons, please read: http://xahlee.org/UnixResource_dir/writ/jargons.html
21:45:05 <ayrnieu> he's not spamming, he's just trolling^Uhe's not spamming *or* trolling, he's just stating ridiculous half-opinions in a very assertive manner^Uhe's not spamming, *or* trolling, *or* stating ridiculous half-opinions, he is being a fixture of usenet.
21:45:36 <ayrnieu> but now he is here! :D
21:45:45 <xah> and âthe naming of thingsâ at http://xahlee.org/Periodic_dosage_dir/t2/math_namings.html
21:46:53 <mauke> xah: croak and bless aren't jargon, they're function names
21:47:27 <xah> mauke: are you talking about perl?
21:47:51 <mauke> yes
21:48:30 <xah> ayrnieu: when you become serious, you'll see most if not all my opinions, are considerable or correct.
21:49:11 <mauke> xah: I don't care about your opinions. stop cross-posting them to my newsgroups.
21:49:36 * xah going back to reading about haskell...
21:49:43 <ayrnieu> xah - "Haskell's documentation is far better than Perl's" does not approximate a correct opinion.
21:50:07 * xah the time has arrived 
21:50:16 <eivuokko> Hmh
21:50:45 <mauke> while I agree that certain parts of perl's documentation suck, they're pretty good in general, especially compared to other languages
21:51:38 <mauke> "abelian, communicative (better: multiplicative-orderless)"? that's just wrong.
21:53:23 <mauke> "translation by sound" is a stupid name
22:19:14 <xah> mauke: traditionally, the stupid term for that is âtransliterationâ
22:35:34 <xah> why's the result of: show "2"++ "7"
22:35:38 <xah> not the same as "27"?
22:36:26 <aleator> Because show quotes strings.
22:36:35 <earthy> because show . read should be id
22:36:48 <earthy> and read . show  should be  id
22:36:50 <xah> aleator: ok, thanks.
22:37:10 <xah> earthy: sorry i don't understand advanced explanations yet
22:38:04 <xah> ah right, i shouldn't have the quote around 2 anyway.
22:41:02 <ayrnieu> xah - in Haskell, function application binds very tightly.
22:41:36 <xah> ayrnieu: no unstand, but i think i grok
22:41:40 * ayrnieu was amused by the contrast with Rebol, where function application binds very loosely.  Both are expressive, but things get written differently.
22:42:29 <earthy> xah: id = \x -> x
22:42:36 <earthy> . = function composition
22:42:52 <xah> ayrnieu: what you were trying to say, was that in haskell, the precedence of syntax for function application is greater than most other operators
22:42:56 <ayrnieu> show $ "2" ++ "7"
22:43:07 <earthy> > show $ "2" ++ "7"
22:43:08 <lambdabot> "\"27\""
22:43:12 <earthy> ;)
22:43:24 <ayrnieu> xah - greater than any operator, I think.
22:43:45 <xah> ok
22:43:56 <ayrnieu> which is convenient for "2" ++ show foo ++ "7", if not for your example.
22:45:53 <integral> xah: you shouldn't use precdence of synax
22:45:55 <integral> xah: you shouldn't use precdence of syntax
22:46:00 <integral> that's too jargony
22:46:15 <xah> earthy: ah ok, id is the identity function. i see.
22:46:45 <xah> integral: your nick name is too jargony
22:47:09 <integral> nope, it's main meaning is the one in the dictionary.
22:47:28 <xah> integral: maybe you should change your name to Infinite Sum
22:47:30 <mauke> s/it's/its/ while we're at it
22:47:44 <ayrnieu> what are we at? :-)
22:47:46 <integral> xah: but I'm not an infinite sum.  I'm not even a noun.
22:52:12 <Phyx-> omfg... this assignment took 3 days for me to make, and it all came down to 2 lines of haskell code :|
22:53:34 <mauke> ... each 200 characters long!
22:53:41 <Phyx-> no
22:53:46 <Phyx-> not even 100 together :P
22:53:54 <Phyx-> i'm a damn noob...
22:54:04 <Phyx-> didn't know you could compare tuples :P
22:54:15 <tromp_> r u sure it's not a one liner?
22:54:56 <Phyx-> nah, guards make it 2 ::
22:54:56 <ayrnieu> phyx - you should've -- or you should've assumed so, been ready to say "what?  This is *ridiculous!*" and then write your own tuple-comparison functions.
22:54:57 <Phyx-> :P
22:55:37 <xah> what's the fun for square?
22:55:43 <tromp_> (^2)
22:56:04 <ayrnieu> (\x->x*x)
22:57:07 <xah> odd name (^2)
22:57:16 <xah> how that works?
22:57:20 <ayrnieu> xah - it curries the ^ operator.
22:57:40 <tromp_> @pl \x->x*x
22:57:41 <lambdabot> join (*)
22:58:04 <integral> @type ((^),(**))
22:58:05 <lambdabot> forall a b a1.
22:58:05 <lambdabot>      (Integral b, Num a, Floating a1) =>
22:58:05 <lambdabot>      (a -> b -> a, a1 -> a1 -> a1)
22:58:36 <integral> xah: that particular form is called an "operator section"
22:58:57 <xah> integral: too much info. :)
22:59:04 <ayrnieu> powers of two: (2^)
22:59:16 <integral> *shrug* no wonder you never learn any jargon.
23:03:03 <ayrnieu> > map (2^) [1..10]
23:03:04 <lambdabot> [2,4,8,16,32,64,128,256,512,1024]
23:03:20 <sieni_> xah: it lets you apply the rest of the arguments later (i.e. generates a closure, i.e. (^2) is approximately (lambda (x) (* x x)))
23:03:22 <integral> > take 10 $ map (2^) [1..]
23:03:23 <lambdabot> [2,4,8,16,32,64,128,256,512,1024]
23:04:10 <ayrnieu> in Real Haskell, integral's is probably more useful and common.
23:04:20 <sieni_> or rather (lambda (x) (expt x 2))
23:04:28 <integral> and normally I'm zipping infinite lists :)
23:04:48 <integral> like, zip [1..] my_real_list_which_doesnt_have_indices_but_will_now
23:05:14 * ayrnieu hearts zip.
23:07:29 <Phyx-> what does the $ do?
23:07:42 <mauke> f $ x = f x
23:07:57 <integral> Phyx-: function application, but because normal juxtaposition application is very high precedence, $ is a version with very low precedence
23:08:39 <Phyx-> hmmm k
23:08:45 <integral> Phyx-: if I said, take 10 map (2^) [1..], each of "10", "map", "(2^)" and "[1..]" end up as arguments to the take, but the $ makes it parse as: take 10 (map (2^) [1..])
23:08:50 <ayrnieu> (phyx - incidentally, Perl has something similar: 'or' and 'and', low-precedence operator forms of || and &&, which also save parentheses and add a bit to readability)
23:09:55 <Phyx-> integral: ahh, okie
23:10:13 <xah> wow, the Hal Daume's tutorial is far better than others
23:10:20 <Phyx-> ayrnieu: cool, ok
23:10:24 <xah> (yet another)
23:11:05 <ayrnieu> xah - you can also find very good tutorials disguised as academic papers -- for instance, I didn't understand Haskell IO until I read concurrent-haskell.ps
23:11:39 <ayrnieu> or at least, didn't understand how to make use of it.
23:12:01 <integral> compsci papers are very readable as papers go,  or at least the good ones :-P
23:13:08 <ayrnieu> *nod*, although I objected to "Haskell has far better documentation than Perl" above, I really cherish Haskell papers like concurrent-haskell.ps
23:13:08 <JohnMeacham> I feel foolish for avoiding monads in my early code.
23:14:26 <integral> a lot of haskell stuff seems to overrely on haddock, compared to perl where there's an overreliance on good prose
23:15:56 <JohnMeacham> integral: well, a lot of that is that perl has no interface to extract.
23:16:31 <integral> and no one wants to fix that :-(
23:17:08 <mauke> @pl foo >>= \f -> bar >>= \x -> return (f x)
23:17:09 <lambdabot> (bar >>=) . (return .) =<< foo
23:17:54 <integral> @type Control.Monad.app
23:17:55 <lambdabot> Not in scope: `Control.Monad.app'
23:18:01 <integral> @index app
23:18:01 <lambdabot> Control.Arrow
23:18:12 <integral> @type Control.Monad.ap
23:18:13 <lambdabot> forall b (m :: * -> *) a.
23:18:13 <lambdabot>        (Monad m) =>
23:18:13 <lambdabot>        m (a -> b) -> m a -> m b
23:18:26 <xerox> xah: yes, yaht is pretty nice.
23:18:39 <mauke> integral: thanks
23:18:41 <integral> mauke: foo `ap` bar, no?
23:18:53 <xerox> xah: take it easy on the CPS chapter :)
23:19:38 <xah> xerox: CPS?
23:19:49 <xerox> xah: continuation passing style.
23:20:09 <vincenz> xah: it's the opposite o CSS 
23:20:14 <vincenz> continuation stopping style
23:20:16 <integral> xah: you've never used CPS in lisp?   I wonder if SICP covers that :-/
23:20:36 <mauke> I remember reading about it in "On Lisp"
23:26:59 <xah> i never actually understand what is âcontinuationâ, in fact i think i is stupid nonsense
23:27:10 <integral> it's the future.
23:27:37 <integral> although you can apparantly model them as negations in some logics,  but I haven't grokked any papers on that yet
23:27:42 <xah> one question: is this âcontinuationâ concept a pure math concept, or it has to do with hardware?
23:28:02 <integral> hmm, I think there's a lisp machine design that had hardware continuations
23:28:15 <xah> in other words, would one find âcontinuationâ in say, a treatise of lambda calculus?
23:28:26 <ayrnieu> xah - read "Teach Yourself Scheme in Fixnum Days", an online Scheme tutorial which IIRC does a very good job of teaching continuations.
23:28:54 <integral> ayrnieu: does scheme have way more continuation support than CL then?
23:29:05 <mauke> "I can't understand it, it must be stupid"
23:29:35 <ayrnieu> xah - one would probably not find 'memoization' in a treatise of lambda calculus, nor think of it as having to do with hardware, but it should interest you anyway.
23:29:58 <mauke> AFAIK scheme has built-in support for call/cc
23:30:08 <xah> ayrnieu: i so much know what it is. Don't think i'll be interested.
23:30:51 <xah> it's like a fad, any computer-sciency stud's first thing coming out of their mouth after they read a book is âcontinuationsâ.
23:30:53 <integral> mauke: it's basically specced so that the VM needs continuation support
23:31:02 <integral> mauke: there's also other continuation friendly facilities like (dynamic-wind)
23:31:35 <integral> xah: then you'll think that "delimited subcontinuations" and serialisable continuations are more so?
23:32:20 <xah> what i'm really interested, is first of all, if any real expert can tell me: how to define the concept of âcontinuationâ in pure math. (if it is part of pure math at all)
23:32:27 <sieni_> call/cc <3<3<3
23:33:06 <xah> or, put more directly: please define for me, the concept of âcontinuationâ, in operating an abacus.
23:33:29 <ayrnieu> xah - and if we can't?
23:34:00 <xah> ayrnieu: if it can't be done, then i pretty much know what it is, and am not interested in it.
23:34:16 <earthy> continuations are nothing but a tool
23:34:18 <ayrnieu> xah - why aren't you?
23:34:21 <xah> and regard any talk about it is pretty much stupid nonsense.
23:35:04 <ayrnieu> xah - what else in the class of 'things that cannot be expressed in the operation of an abacus' do you regard as pretty much stupid nonsense?
23:35:50 <xah> much of functional programing, in in a sense getting rid of the massive stupid nonsense that exists in imperative languages.
23:36:26 <xah> not that imperative languages are inherently embedded with such nonsenses, but rather, because how they are developed, their people, community. In short, the unix and C fuckheads.
23:36:44 * ayrnieu . o O ( callbacks?  dispatch tables?  caching and memoization?  iterators?  infinite streams?  higher-order-functions and currying?  parsing?  backtracking?  declarative programming?)
23:37:39 <sieni_> unix <3
23:38:28 <xah> a extreme example of this nonsense is for example, in Java and these days spreading to many so-called OOP langs, is the ânumeratorâ shit.
23:38:40 <earthy> unix fuckheads?
23:38:47 <earthy> if you think so. :)
23:39:06 <ayrnieu> earthy - best to leave it as an undefined term.
23:39:15 <mauke> what does an abacus have to do with maths?
23:39:25 * Saulzar is beginning to suspect xah lives under a bridge and turns to stone during the day.
23:39:30 <xah> that is to say, to loop thru a list, in functional lang usually they use a map, and in common imperative lang is just a for loop, but because the OOP fuckheads, now there's this extra step of a thing/concept called enumerator.
23:40:00 <mauke> don't you mean iterator?
23:40:06 <xah> the enumerator thing, is a complexity out of nothingness. It does nothingness. It's just there.
23:40:09 <xah> yeah, iterator.
23:40:13 <mauke> hahaha
23:40:30 <integral> you can have a monad that looks like an iterator
23:40:43 <integral> (and arrows too)
23:40:55 <earthy> um. iterators are one way of doing coroutines
23:41:02 <earthy> coroutines do have their place
23:41:12 <integral> and iterators can be very easy to write when you have continuations available
23:41:31 <ayrnieu> xah - reading from a filehandle is a common iterator in most any language.
23:41:40 <earthy> or from a database
23:42:09 <xerox> ayrnieu: fortunately Haskell doesn't have stream-based I/O anymore!
23:42:43 <earthy> xerox: wasn't there a lib by Bulat Zigansin to re-introduce stream-based I/O? :)
23:42:47 <ayrnieu> *nod*, but Haskell still reads from sockets.
23:43:02 <xah> in java, you can't go thru a list without elaborately create an "iterator" object. Quite amazing.
23:43:04 * xerox stabs earthy 
23:43:24 <integral> xah: umm, are you sure you're not confusing the visitor and iterator patterns?
23:43:39 <ayrnieu> xah - iterators are useful and common, and incidentally useful for languages bereft of proper functional programming techniques.
23:43:44 <integral> (of course, the 1st arg of map, *is* just a visitor...)
23:43:53 <tromp_> the problem is the lack of higher order functions
23:43:54 <xah> ayrnieu: ok, there you said it.
23:44:09 <xah> tromp_: there you said it!
23:44:22 <integral> but closures and objects are isomorphic...
23:44:35 <tromp_> so that can't define any sort of iterating functions
23:44:47 <ayrnieu> (Higher Order Perl has two chapters relating to iterators)
23:44:51 <tromp_> but have to combine loops with state
23:45:53 <integral> class visitor { has $.counter; method visit($x) { say $x; $.counter += $x } }   my $v = Visitor.new; $some_container.foreach($v); say $v.counter;
23:45:54 <ayrnieu> closures and objects are isomorphic in the presence of variable mutability.
23:46:31 <integral> oh, yes.  Sorry, I just assume that closures == normal variable immutability, and objects == normal variable mutability
23:49:53 <vincenz> > [list_people_in_channel] >>= return (x++" have a cookie") 
23:49:54 <lambdabot>  Not in scope: `x'
23:49:59 <vincenz> > [list_people_in_channel] >>= \x -> return (x++" have a cookie") 
23:50:00 <lambdabot>  Not in scope: `list_people_in_channel'
23:50:24 <integral> (the one flaw in the above, is that without an escape continuation, you can't do the last/next/redo operations of a loop+iterator)
23:50:39 <xerox> vincenz: fmap (++" have a cookie")
23:50:43 <xah> ayrnieu: thanks for the CC reference in Teach Yourself Scheme though, going to read it now
23:50:58 <xerox> @pl \f xs -> xs >>= return . f
23:50:58 <lambdabot> fmap
23:51:05 <vincenz> xerox: right but the main trouble is "list people in channel"
23:51:06 <mathrick> hi, I'm trying to use hugs, but fail miserably
23:51:09 <mathrick> Prelude> iter :: [Integer] -> Integer
23:51:09 <mathrick> ERROR - Undefined variable "iter"
23:51:37 <xerox> mathrick: you're supposed to write definition in a file and :load /path/to/it.hs.
23:52:02 <mathrick> aha
23:52:14 <mathrick> so it can't be done interactively?
23:52:22 <vincenz> mathrick: yes .. .with a better editor
23:52:29 <integral> (ghci can make bindings interactively)
23:52:30 <vincenz> that uses ghci as middleend
23:52:52 <mathrick> vincenz: hmm, I don't have ghc installed here, hugs is as good as it gets
23:53:05 <vincenz> oh
23:53:07 <vincenz> well hugs then
23:53:11 <vincenz> have hugs attached to vim or emacs
23:53:15 <mathrick> I tried
23:53:15 <ayrnieu> mathrick - are you on *BSD/notx86 ?
23:53:19 <vincenz> preferably with bubblegum
23:53:21 <mathrick> and it outputs nothing
23:53:24 <xerox> mathrick: then you can edit the file more and :reload, and it's "quite" interacive.
23:53:32 <mathrick> ayrnieu: nope, linux.x86, buy Uni install
23:53:39 <vincenz> xerox: for some defintion of "quite"?
23:53:51 <mathrick> s/buy/but/
23:53:54 <ayrnieu> mathrick - you might locally install ghc, if you've quota.
23:54:05 <vincenz> yeah it only takes 100MB :P
23:54:08 <ayrnieu> also, harass sysadmins.  They live for it!
23:54:19 <mathrick> not sure about that, last time I tried to compile anything it defeated all my attempts
23:54:33 <mathrick> it's an EVIL setup
23:54:35 <vincenz> ayrnieu; it's like people in highschool with a "kickme" signe
23:54:36 <vincenz> ?
23:54:51 <vincenz> mathrick: you mean windows?
23:54:55 <ayrnieu> well, you might also have harsh processor/memory/&c limits.
23:54:57 <mathrick> vincenz: nope, linux
23:55:02 <vincenz> you said "EVIL"
23:55:28 * ayrnieu notes *BSD/notx86 as GHC bereft.
23:55:31 <mathrick> vincenz: it's setup in a way which manages to break execv() in many apps (!)
23:55:37 <ayrnieu> also, of.
23:55:46 <vincenz> oy
23:55:58 <mathrick> I have NFC how they did it
23:56:01 <mathrick> but they did
23:56:20 <vincenz> mathrick: I bet they recompiled the kernel with something like "execv()....{ print "HAHA LOSER, SYSADMINHAS YOUR REAR!")}
23:56:39 <mathrick> heh
23:57:21 <ayrnieu> mathrick - I could break user execv with systrace under OpenBSD.
23:58:18 <mathrick> oookay
23:58:26 <mathrick> so I've got this in test.hs:
23:58:28 <mathrick> iter :: [Int] -> Int
23:58:28 <mathrick> iter [] = 0
23:58:28 <mathrick> iter (x:xs) = x + iter xs
23:58:28 <mathrick> print iter [10, 20, 30, 40]
23:58:35 <vincenz> o.O
23:58:39 <vincenz> mathrick: how about
23:58:40 <mathrick> ERROR "/mnt/amd/bach/export/students/makat05/test.hs":6 - Syntax error in declaration (unexpected `}', possibly due to bad layout)
23:58:42 <xerox> iter = sum
23:58:45 <vincenz> iter = foldr (+) 0
23:58:48 <xerox> > sum [1..10]
23:58:48 <mauke_> print (iter [10,20,30,40])
23:58:49 <lambdabot> 55
23:58:54 <mathrick> ever heard of "tests"?
23:58:57 <vincenz> xerox: gotta teach people foldr... it's more generic than sum
23:59:09 <xerox> mauke_ 1 - rest of the world 0
23:59:09 <vincenz> > foldr (+) 0 [1..10]
23:59:10 <lambdabot> 55
23:59:20 <vincenz> mathrick: whenever you have code like that
23:59:22 <vincenz> somefunc [] = b
23:59:34 <vincenz> somefunc x:l = x `op` somefunc l
23:59:35 <mathrick> yes?
23:59:36 <vincenz> then you can write
23:59:43 <vincenz> foldr (op) b l
23:59:45 <mathrick> vincenz: I KNOW
23:59:48 <vincenz> ph
23:59:50 <vincenz> oh
23:59:51 <vincenz> sorry
23:59:51 <mathrick> this is a test
