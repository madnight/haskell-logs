00:00:06 <xerox> <http://haskell.org/hide/> ?
00:01:09 <xerox> @where hide
00:01:10 <lambdabot> http://haskell.org/haskellwiki/HIDE
00:04:41 <roconnor> No instance for (Arbitrary (Map (Set Nat) Double))
00:05:04 <xerox> Map (Set Nat)?  Woo.
00:05:18 <roconnor> type Clifford = Map (Set Nat) Double
00:05:58 <roconnor> working with Map and Set at the same time requires a lot of qualified names
00:08:37 <roconnor> type Nat = Integer
00:08:49 <roconnor> actually, I don't really need Nat
00:08:56 <roconnor> or even Integer
00:09:08 <roconnor> It can be any ordered type
00:09:42 <roconnor> I'll keep it as Integer for sake of concreteness for now
00:10:42 * roconnor wishes Map and Set were memebers of Arbitrary
00:10:56 * roconnor writes his own instances
00:11:25 <xerox> :D
00:12:24 <roconnor> instance (Ord a, Arbitrary a, Arbitrary b) => Arbitrary (Map a b) where
00:12:24 <roconnor>  arbitrary = fmap Map.fromList arbitrary
00:12:24 <roconnor>  coarbitrary = coarbitrary . Map.toList
00:12:41 <roconnor> seems decent
00:14:58 <xerox> Hmm.  Wasn't Yi an executable while ago?
00:15:47 <xerox> /usr/bin/ar: creating dist/build/libHSyi-0.2.a
00:16:40 <Phyx-> hmm, will inserting ram myself in the laptop void my warranty? in laptop
00:16:59 <Lemmih> xerox: It can be either.
00:17:32 <xerox> Lemmih: how do I create the binary?
00:18:59 <Lemmih> xerox: Use the normal repo. But why do you want a yi binary?
00:19:35 <xerox> It has no Gtk gui anymore?
00:20:55 <xerox> (Also, my Cabal-1.0 doesn't understand hs-source-dirs, but hs-source-dir.)
00:21:36 <Lemmih> ghc.hide comes with Cabal-1.1.4 so that's not a problem.
00:21:53 <xerox> Okay.
00:22:13 <xerox> There was some problem darcsgetting ghc.hide, I'm trying again.
00:23:11 <roconnor> hmm, my resulting maps were a little too aribitrary.  Hard to multiply them.
00:25:38 <Jarod> hello
00:26:57 <roconnor> scalar x = Map.singleton (Set.empty) x
00:26:59 <Jarod> I want to learn Haskell, I have WinHugs but when I write: map Char.isLower "aBCde", it tells me "ERROR - Undefined qualified variable "Char.isLower""
00:27:16 <xerox> Jarod: try Data.Char.isLower?
00:27:24 <xerox> Or maybe import Data.Char and live happy?
00:27:39 <Jarod> ERROR - Undefined qualified variable "Data.Char.isLower"
00:27:52 <Jarod> ERROR - Syntax error in expression (unexpected keyword "import")
00:27:56 <mauke> you need to import qualified Char
00:27:56 <jethr0> Jarod: have you tried simply "isLower"?
00:28:06 <mauke> yeah, you can't do that in the interpreter
00:28:16 <mauke> write a file
00:28:18 <Jarod> Hugs> map isLower "aBCde"
00:28:18 <Jarod> ERROR - Undefined variable "isLower"
00:28:37 <jethr0> > map isLower "aBCde"
00:28:38 <lambdabot> [True,False,False,True,True]
00:28:39 <jethr0> :)
00:28:55 <Jarod> have you WinHugs ?
00:29:22 <jethr0> no, i'm using ghci under linux. and that was just lambdabot...
00:30:02 <xerox> Hugs.Base> :also Char
00:30:02 <xerox> Char> map toUpper "this way?"
00:30:02 <xerox> "THIS WAY?"
00:30:34 <roconnor> haskell is faster than C++?
00:30:43 <xerox> Without "?"
00:30:47 <Jarod> aaah ok, need an "also" command
00:30:47 <jethr0> roconnor: of course it is :)
00:30:51 <xerox> Aha, let me restate it
00:30:59 <xerox> "It is called 'C++', not 'C++?'"
00:31:37 * jethr0 thought it was C++0x
00:31:46 <Jarod> thanks xerox 
00:32:00 <roconnor> so I guess my potential graphics students won't mind working in Haskell
00:32:01 <xerox> You're welcome.  (Hint: use GHC, use GHC)
00:32:17 <Jarod> is possible to keep the Char.isLower version instead of just isLower
00:32:36 <Jarod> ?
00:32:49 <xerox> roconnor: you should talk to dcoutts.  He had a course with SOE, and a presentation with Cairo (http://haskell.galois.com/~paolo/nymphaea-new/ showing this)
00:33:10 <xerox> ...and a course where students should have implemented nymphaea :-)
00:33:27 <jethr0> roconnor: it's shades of gray really. depending on what your student should be doing haskell might not be the only/ideal choice
00:33:58 <roconnor> I was going to justify Haskell with its type system.
00:34:14 <roconnor> They can do graphics without a safety net after the course if they wish
00:34:30 <xerox> :-)
00:34:55 <jethr0> roconnor: what kind of graphics?
00:36:10 <roconnor> ray tracer and I was thinking of using the OpenGL bindings
00:37:10 <jethr0> for raytracing haskell is pretty much ideal
00:37:23 <xerox> Check boegel's code :-)
00:37:42 <jethr0> i implemented a ray tracer as my first real haskell project and it took me only two days and less than 270 lines to get all kinds of advanced features. and all without any hassle at all
00:38:13 <Jarod> sounds cool :)
00:38:38 <roconnor> I've spend 2 days and all I have to show for it is my Clifford algebra :(
00:38:41 <jethr0> roconnor: and i'm using the opengl bindings right now and they are extremely neat. i think working with them is nicer than in most other languages, but then opengl is pretty much the same everywhere, i guess
00:39:19 <roconnor> okay, I'll defintely use Haskell if I make my course.
00:40:28 <jethr0> :)
00:42:01 <roconnor> much of my 2 days were spent figuring out how multiplcation is supposed to work
00:42:19 <roconnor> 1 hour to implement it
00:45:01 <roconnor> although I still ought to implement the inner and outer products.
00:46:15 <jethr0> you should seriously try writing a raytracer. it was one of the most gratifying programming projects i ever did :)
00:46:45 <roconnor> Whats the best way to get from rasterization function to PNG file?
00:47:25 <jethr0> i wrote my files as pnm which is a very easy format to write
00:47:31 <roconnor> ok
00:47:46 <roconnor> there is no PNG encoder in Haskell?
00:47:51 <jethr0> just "type\nwidth height maxval\n<width*height bytes>"
00:47:56 <ndm> is hackage in a useable state in any way?
00:47:59 <mauke> that's PNM
00:48:15 <roconnor> ... I suppose Haskell doesn't really do binary IO.
00:48:19 <roconnor> :(
00:48:45 <roconnor> hence the text file output
00:48:56 <roconnor> then pnm2png
00:49:14 <roconnor> pnmtopng
00:49:25 <jethr0> roconnor: you can do binary IO alright in haskell. and there's binary versions of the pnm format (with a slight different postfix)
00:50:53 <roconnor> is the zip compression function available?
00:50:56 <jethr0> i think PGM is the binary version. not sure though
00:51:06 <jethr0> there's a binding to zlib
00:51:14 <mauke> pgm = portable greymap
00:51:15 <roconnor> excellent
00:51:34 <mauke> pbm = portable bitmap, ppm = portable pixmap, pnm = portable anymap
00:52:27 <jethr0> mauke: good to know
00:53:19 <tuomov> libpnm should be quite easy to interface with
00:54:03 <jethr0> tuomov: shouldn't other libraries be rather easy too (png, gif, jpeg) or am i being naive?
00:54:13 * integral just likes to output raw data and use ImageMagick's convert to encode it
00:54:16 <tuomov> dunno, I've only used libpnm
00:54:27 <integral> (ffmpeg can do the same for video!)
00:54:59 <ndm> ping dcoutts
00:55:25 <ndm> @seen dcoutts
00:55:25 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. Last spoke 1 hour, 49 minutes
00:55:25 <lambdabot> and 9 seconds ago.
00:59:54 <Pupeno> Any ideas about a font that has a nicely drawn lambda ? Or a vectorized (svg) lambda ?
01:00:43 <tuomov> computer modern
01:02:35 <Pupeno> thanks.
01:02:48 * Pupeno installs it.
01:05:56 <Jarod> just wondering, don't think you that "squeak syntax" is more logical that haskell syntax, i mean, in Haskell you read fst( head( tail [(5,'b'), (1,'c'), (6,'a')] )), in squeak you read [(5,'b'), (1,'c'), (6,'a')] tail head fst
01:06:26 <Jarod> in squeak you can read left to right
01:06:35 <roconnor> yes
01:07:25 <roconnor> did someone make a stack calculator syntax in haskell?
01:07:44 <Jarod> it will be very cool ^^
01:07:56 <roconnor> I remember seeing it on the wiki
01:08:00 <roconnor> maybe Cale made it
01:08:00 <Jarod> really ?
01:09:17 * Philippa finds the haskell syntax logical still, though she uses $ et al often enough too
01:13:36 <Jarod> does the term is "stack calculator syntax" ?
01:13:42 <Jarod> can't find on google
01:14:09 <jethr0_> Jarod: why "syntax"?
01:14:13 <jethr0_> don't you mean semantics?
01:14:44 <Jarod> maybe, i'm french ;)
01:15:17 <jethr0_> the idea behind stack based calculators is that you push values on a stack, and let them be consumed by the operators
01:15:30 <jethr0_> for single-digit number this would be:
01:16:00 <jethr0_> 234+* = (4+3)*2
01:16:11 <Pupeno> tuomov: do you know the filename of that font ?
01:16:38 <Jarod> yes, but in squeak you can do this: object function arguments
01:16:45 <Jarod> 2 + 3
01:17:05 <Jarod> ('a', 'b') fst for example
01:17:32 * roconnor can't find it
01:17:45 <jethr0_> roconnor: can't find what?
01:18:16 <Jarod> so you can read left to right instead of reading all the line, and evaluate the functions right to left
01:19:05 <Jarod> it is easier to understand what a program does
01:19:18 <tuomov> Pupeno: it's the standard TeX font..
01:19:41 <Igloo> Aha, "Slow synchro" looks like what I want, thanks!
01:19:44 <Igloo> Ooops
01:20:07 <roconnor> 07:38:39 <Cale> *Main> start push 1 push 2 add push "Hello" len add end
01:20:07 <roconnor> 07:38:39 <Cale> 8
01:20:12 <roconnor> http://tunes.org/~nef/logs/haskell/05.12.23
01:20:39 <tuomov> $ apt-cache search 'computer modern'
01:20:39 <tuomov> cm-super - TeX font package with CM (EC) in Type1 in T1, T2*, TS1, X2 enc
01:20:58 <tuomov> maybe that has cm in other formats
01:21:16 <tuomov> or perhaps its just something for tex itself
01:21:22 <tuomov> the dependencies would imply that
01:21:30 <tuomov> I've seen cm converted to X, though
01:23:22 <Jarod> roconnor, not sure that it is what i am talking about
01:24:05 <roconnor> yea, it's not quite the same
01:46:23 <Pupeno> tuomov: yet, I don't know where to find it exactly.
01:59:21 <pierre-> hello. 
01:59:41 <pierre-> @where HASP
01:59:41 <lambdabot> http://scannedinavian.com/~lemmih/hasp
02:01:31 <Lemmih> @where+ HASP http://darcs.haskell.org/~lemmih/hasp/
02:01:31 <lambdabot> Done.
02:02:16 <pierre-> Lemmih: is hasp practically usable now?
02:03:11 <Lemmih> No, it depends on ghc-cvs and has therefore bitrotted.
02:04:22 <Lemmih> It wont be stable until GHC-6.6 is out.
02:05:04 <jethr0_> "bitrot" carries with it a sense of inevitability :)
02:08:11 <neologism> what is hasp?
02:08:21 <jethr0_> stupid haddock fails on the new arrow notation *grr*
02:08:41 <jethr0_> i wish there was a pragma to let haddock ignore parts of the code
02:10:23 <seth_> hey, all, I want to try hGetBuf, to see if I get a performance improvement.  I'm not sure how to do that, though, since it uses a Ptr a, and all the docs I see are talking about using Ptr a with the FFI (which is what it is for, of course, but there is no FFI in my code at the moment)
02:11:08 <Jarod> neologism, http://article.gmane.org/gmane.comp.lang.haskell.general/12617
02:11:41 <andrew_p> hello
02:12:19 <andrew_p> i was thinking how one could implement his own 'map' function .. any ideas?
02:12:39 <jethr0_> andrew_p: sure, where do you want to start?
02:13:07 <seth_> andrew_p, there are examples of that in both of the haskell books.  Do you have one of them?
02:13:33 <andrew_p> seth_: no, i didn't see them yet, just interesting :)
02:13:43 <jethr0_> andrew_p: have you programmed recursive functions before?
02:14:07 <andrew_p> jethr0_: i have written some code once, but it didn't work .. i wish i did not delete it, but it seems i did :/
02:14:10 <seth_> andrew_p, I'm sure someone will know of an on-line example.  if you had the book I could have given you a page number which would be easy.  :)
02:14:30 <andrew_p> seth_: what book do you mean?
02:14:30 <jethr0_> andrew_p: k. let's write a function to determine a list's lenght first
02:14:41 <jethr0_> andrew_p: any ideas how you would start that?
02:14:41 <andrew_p> there was such exercise in yaht, afair
02:14:48 <seth_> andrew_p, there are two popular ones, one by Simon Thompson and the other by ... let me look
02:15:08 <seth_> andrew_p, hudak
02:15:10 <andrew_p> jethr0_: one minute, i will launch my ghc L)
02:15:13 <jethr0_> k
02:15:18 <seth_> andrew_p, both excellent books.  hudak is a bit newer
02:15:37 <jethr0_> andrew_p: but even without ghc, what would your first steps be
02:16:27 <andrew_p> mylength [] = 0
02:16:27 <andrew_p> mylength x = 1
02:16:27 <andrew_p> mylength (x:xs) = 1 + mylength xs
02:16:27 <andrew_p>  
02:16:39 <davidhouse> andrew_p: did you write that?
02:16:42 <Jarod> decrease the list and increase a counter ?
02:16:54 <andrew_p> davidhouse: yeah, i did
02:16:56 <jethr0_> andrew_p: i think you mean "[x]" instead of "x"
02:16:56 <neologism>  will this work?
02:17:01 <davidhouse> andrew_p: oh, it's slightly wrong. you mean [x].
02:17:03 <andrew_p> thanks, jethr0_
02:17:05 <davidhouse> but then that's not necessary
02:17:11 <Beelsebob> andrew_p: you don't even need that line
02:17:18 <jethr0_> true
02:17:18 <davidhouse> just the first and third lines are needed
02:17:19 <Beelsebob> because [x] = (x:[])
02:17:39 <andrew_p> aha, i see, thanks
02:17:55 <jethr0_> andrew_p: k. i see you've got a good idea of recursive functions.
02:18:06 <jethr0_> andrew_p: can you explain to me in plain english what "map" does...
02:18:18 <andrew_p> afair, when i was trying to implement map i couldn't find a way to apply function argument
02:18:25 <andrew_p> @type map
02:18:26 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
02:18:28 <andrew_p> :-D
02:18:30 <davidhouse> andrew_p: what have you got so far?
02:18:47 <jethr0_> andrew_p: that's hardly plain english :)
02:18:52 <andrew_p> davidhouse: i deleted what i had, a few minutes please :)
02:19:21 <andrew_p> jethr0_: it takes a function and a list as arguments and applies function to each element of the list
02:19:35 <jethr0_> exactly. so what would it do on an empty list?
02:19:44 <pierre-> seth_: "there are two popular ones" -- i know only one. what's the second?
02:19:48 <andrew_p> simply return
02:20:05 <jethr0_> yes, and on a list (x:xs)?
02:20:42 <jethr0_> hmm, maybe that's too big a step :)
02:20:48 <andrew_p> jethr0_: that's what i'm writing at the moment .. wait please :)
02:20:53 <neologism> andrew_p: there is no return (in the classic sense) in functional languages
02:21:08 <jethr0_> could you write down what "map f (1:(2:(3:[])))" expands to?
02:21:10 <davidhouse> it would just do nothing given []
02:21:14 <andrew_p> neologism: i know, only inside monadic blocks, right?
02:21:18 <neologism> functions are applied, ie. expressions are rewritten
02:21:32 <neologism> andrew_p: do you know lambda calculus?
02:21:32 <seth_> pierre-, depends on which is the first.  :)  One by Simon Thompson, and the other by Paul Hudak.
02:22:13 <Beelsebob> seth_: heh, I'm not sure I would recommend the hudak one to anyone - it teaches procedural coding in a functional language
02:22:17 <andrew_p> neologism: i've read a lot of theory on that and played with Common Lisp and Haskell a bit
02:22:19 <Beelsebob> which is fairly pointless
02:22:23 <pierre-> seth_: and what's the difference?
02:22:42 <neologism> andrew_p: beta reduction
02:22:47 <davidhouse> lambda calculus has a big scary name for something extremely easy
02:22:55 <Beelsebob> heh
02:23:14 <andrew_p> i just can't understand how should i do two actions in sequence, i mean mymap f (x:xs) = (f x) : (mymap f xs) or something like that
02:23:25 <seth_> pierre-, two different books, and as Beelsebob noted, a somewhat different approach.  I'm not sure I'd agree with his characterization of Hudak, however ... :)
02:23:29 <davidhouse> andrew_p: correct
02:23:39 <jethr0_> andrew_p: that's completely correct
02:23:49 <neologism> andrew_p: its nowhere stated that its executed sequentially
02:23:50 <andrew_p> great, thanks :)
02:24:00 <andrew_p> > mymap f [] = []
02:24:01 <lambdabot>  parse error on input `='
02:24:13 <andrew_p> hm, lambdabot complains on that
02:24:23 <davidhouse> > let mymap f [] = []
02:24:24 <lambdabot>  parse error on input `}'
02:24:30 <Phyx-> huh?
02:24:35 <Beelsebob> > let mymap f [] = []; mymap f (x:xs) = (f x) : (mymap f xs) in myMap (+1) [1,2,3]
02:24:36 <lambdabot>  Not in scope: `myMap'
02:24:38 <pierre-> lambdabot calculates expressions, not definitions
02:24:43 <jethr0_> > let mymap f [] = []; mymap f (x:xs) = (f x) : (mymap f xs) in mymap (+1) [1,2,3]
02:24:44 <lambdabot> [2,3,4]
02:24:45 <Beelsebob> > let mymap f [] = []; mymap f (x:xs) = (f x) : (mymap f xs) in mymap (+1) [1,2,3]
02:24:46 <lambdabot> [2,3,4]
02:24:47 <seth_> andrew_p, to do that you use the "do" expression syntax, or the >> and >>= combinators
02:24:52 <jethr0_> :))
02:24:58 <seth_> andrew_p, but, often, you don't really need to constrain the sequence
02:25:05 <Beelsebob> seth_: ... or the seq function
02:25:20 <Beelsebob> ... or the (.) function
02:25:20 <jethr0_> Beelsebob: stop typing what i'm thinking
02:25:25 <Beelsebob> lol
02:25:40 <Phyx-> (.) function?
02:25:44 <Beelsebob> jethr0_: head, mine, out of, sentence, rearange, this
02:25:50 <davidhouse> @type (.)
02:25:51 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
02:26:10 <seth_> Beelsebob, composition and >>/>>= have rather different semantics
02:26:11 <pierre-> @type [map, foldr, scanr]
02:26:11 <lambdabot>   Couldn't match `[[a] -> [a]]' against `t -> t1'
02:26:11 <lambdabot>   Expected type: [[a] -> [a]]
02:26:20 <roconnor> The instance type must be of form (T a b c)
02:26:20 <jethr0_> Beelsebob: exactly. those were my chaotic, primordial thoughts
02:26:20 <andrew_p> seth_: heh, yasterday i came here with application 3.10 from yaht - it was much more complicated than implementing map and somebody explained sequence and mapM here to me :)
02:26:22 <roconnor> boooo
02:26:31 <pierre-> @type [foldr, scanl]
02:26:32 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
02:26:32 <lambdabot>   Expected type: (b -> b -> b) -> b -> [b] -> b
02:26:35 <Beelsebob> seth_: indeed - but (.) and seq both do sequencing of functions
02:26:46 <seth_> Beelsebob, yes, that's true.
02:26:58 <pierre-> @type [foldr, foldl]
02:26:58 <davidhouse> what does seq do?
02:26:59 <lambdabot> forall b. [(b -> b -> b) -> b -> [b] -> b]
02:27:07 <neologism> f . g - its not defined that g is evaluated first
02:27:09 <neologism> or it is?
02:27:16 <Beelsebob> seq runs two functions, discards the result of the first and returns the second
02:27:18 <seth_> Beelsebob, I didn't want to leave the person just learning the language with the impression that they are identicalll.
02:27:22 <Beelsebob> it runs the first strictly
02:27:35 <davidhouse> neologism: (f . g) x = f(g(x))
02:27:39 <neologism> davidhouse: yes
02:27:44 <jethr0_> rather, it evaluates two expressions
02:27:47 <pierre-> @type (.)
02:27:47 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
02:27:48 <Beelsebob> seth_: oh, okay - I was just trying to not give them the impression tha you should always use monads for sequencing
02:27:50 <neologism> but I dont see why should g be evaluetd first
02:27:53 <neologism> or at all
02:27:59 <pierre-> @type ($)
02:28:00 <lambdabot> forall b a. (a -> b) -> a -> b
02:28:07 <Beelsebob> neologism: because the result of g is passed to f
02:28:11 <andrew_p> sorry, will be away for 10 minutes or so .. thanks for help
02:28:20 <davidhouse> Beelsebob: seq does that monadically?
02:28:29 <neologism> Beelsebob: f _ = 1
02:28:33 <neologism> f . g
02:29:00 <seth_> Beelsebob, agreed
02:29:04 <neologism> f x = x
02:29:06 <Beelsebob> davidhouse: no
02:29:15 <neologism> f . g = g is not evaluated at all
02:29:18 <neologism> right?
02:29:30 <Beelsebob> f . g of what?
02:29:36 <neologism> it doesnt matter
02:29:39 <Beelsebob> f . g is a function - f after g
02:29:45 <neologism> because the f jsut returns its parametrr
02:29:47 <Beelsebob> it does g first
02:29:53 <Beelsebob> then it runs f on the result of g
02:29:56 <davidhouse> Beelsebob: then what's the point of running the first function?
02:30:01 <neologism> Beelsebob: shouldnt that be lazy?
02:30:05 <Beelsebob> davidhouse: it's run strictly
02:30:10 <neologism> ie. g not evaluated at all as its not requiored
02:30:21 <davidhouse> Beelsebob: what does that mean?
02:30:25 <Beelsebob> neologism: it is lazy - that doesn't stop f demanding it's argument (g x)
02:30:37 <Beelsebob> davidhouse: it forces the evaluation of the first function
02:30:57 <jethr0_> Beelsebob: seq works on expressions, not functions
02:30:59 <davidhouse> Beelsebob: but unless the first function was monadic that'd be pointless, right?
02:31:07 <Beelsebob> e.g. seq (unsafePerformIO $ putStrLn "I'm doing something") $ g x
02:31:19 <jethr0_> davidhouse: it can also sometimes solve problems with space leaks
02:31:52 <pierre-> @hoogle seq
02:31:53 <lambdabot> Control.Parallel.seq :: a -> b -> b
02:31:53 <lambdabot> Prelude.seq :: a -> b -> b
02:31:53 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
02:31:59 <jethr0_> davidhouse: by evaluating an expression, the next function using part of it can keep only the part it needs instead of carrying the thunk plus a lazy operation around with it
02:33:46 <pierre-> > seq (unsafePerformIO $ putStrLn "I'm doing something") $ map (+1) [1,2,3] 
02:33:47 <lambdabot>  Not in scope: `unsafePerformIO'
02:34:18 <pierre-> seq (System.IO.Unsafe.unsafePerformIO $ putStrLn "I'm doing something") $ g x
02:34:31 <jethr0_> pierre-: you can't do IO in lambdabot
02:34:32 <pierre-> > seq (System.IO.Unsafe.unsafePerformIO $ putStrLn "I'm doing something") $ g x
02:34:33 <lambdabot>  Not in scope: `x'
02:34:54 <pierre-> > putStrLn "a"
02:34:55 <lambdabot> No IO allowed
02:35:01 <pierre-> yeah... i see
02:36:26 <Jarod> > x = 5
02:36:27 <lambdabot>  parse error on input `='
02:36:32 <Jarod> huh ?
02:36:35 <Jarod> why ?
02:36:43 <jethr0_> > let x = 5 in x
02:36:44 <lambdabot> 5
02:36:59 <jethr0_> Jarod: "x=5" is not an expression
02:37:22 <neologism> cannot it be nullary function definition?
02:37:22 <Jarod> but in "Yet Another Haskell Tutorial" it says "x = 5"
02:37:48 <jethr0_> yes, but declarations/definitions aren't expressions either
02:38:12 <Jarod> module Test
02:38:12 <Jarod> where
02:38:12 <Jarod> x = 5
02:38:12 <Jarod> y = (6, "Hello")
02:38:12 <Jarod> z = x * fst y
02:38:39 <jethr0_> it's a special case and as you can see the declarations are within a "where"
02:38:43 <jethr0_> > x where x = 5
02:38:44 <lambdabot> 5
02:38:54 <pierre-> let x=(x==False) in x
02:39:05 <Jarod> yes but when i load test.hs i have an error
02:39:05 <pierre-> > let x=(x==False) in x
02:39:06 <lambdabot> Terminated
02:39:12 <jethr0_> pierre-: that's unbounded recursion
02:39:16 <pierre-> > let x=(x==True) in x
02:39:17 <lambdabot> Terminated
02:39:41 <jethr0_> > let ones = 1 : ones in take 10 ones
02:39:42 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
02:40:14 <Jarod> ghci Test.hs
02:40:26 <Jarod> Test.hs:1:1: lexiacl error
02:40:32 <pierre-> let x=((x==True) + (x==False)) in x
02:40:41 <pierre-> > let x=((x==True) + (x==False)) in x
02:40:42 <lambdabot>  add an instance declaration for (Num Bool)
02:40:42 <lambdabot>   In the definition of `x': x = ((x == True) + (x == False))
02:40:42 <lambdabot>   In the definition of `add': add = let x = ((x == True) + (x == False))
02:40:42 <lambdabot> in x
02:40:43 <jethr0_> pierre-: what exactly are you trying to do?
02:40:50 <seth_> Jarod, indentation
02:40:51 <davidhouse> err, (+) isn't defined on bools
02:41:04 <pierre-> jethr0_: nothing useful
02:41:12 <davidhouse> you probably mean (||), or possibly (&&)
02:41:16 <pierre->  let x=((x==True) || (x==False)) in x
02:41:22 <pierre-> > let x=((x==True) || (x==False)) in x
02:41:23 <lambdabot> Terminated
02:41:46 <pierre-> but it's true logically ... :-) 
02:41:49 <ihope> > let x=((True==x) || (False==x)) in x
02:41:50 <lambdabot> Terminated
02:42:07 <ihope> > let x=((False==x) || (True==x)) in x
02:42:07 <lambdabot> Terminated
02:42:08 <jethr0_> well, haskell isn't _that_ lazy :)
02:42:12 <ihope> :-)
02:42:16 <pierre-> :-)
02:42:20 <ihope> > let x=((False==x) && (True==x)) in x
02:42:21 <lambdabot> Terminated
02:42:33 <ihope> > let x=((True==x) && (False==x)) in x
02:42:34 <lambdabot> Terminated
02:42:47 <Lemmih> > let x = True || x==False in x
02:42:48 <lambdabot> True
02:43:02 <jethr0_> pierre-: it's only true if "tertium non datur", i.e. there is no value beyond True and False. but in haskell's type system "undefined" exists
02:43:10 <ihope> > let x = x == False || True in x
02:43:11 <lambdabot> Terminated
02:43:16 <jethr0_> > (True == undefined) || (False == undefined)
02:43:17 <lambdabot> Undefined
02:43:33 <pierre-> wow. i didn't knew this
02:43:41 <tromp_> > undefined || True
02:43:42 <lambdabot> Undefined
02:43:51 <ihope> > undefined == undefined
02:43:52 <lambdabot> Add a type signature
02:43:54 <pierre-> > undefined
02:43:55 <lambdabot> Add a type signature
02:43:58 <ihope> > undefined == undefined :: Bool
02:43:59 <lambdabot> Add a type signature
02:44:01 <jethr0_> > undefined :: Int
02:44:02 <lambdabot> Undefined
02:44:07 <neologism> @type id
02:44:08 <lambdabot> forall a. a -> a
02:44:19 <ihope> > (undefined :: ()) == (undefined :: ())
02:44:19 <palomer> > (undefined::Bool) == Undefined
02:44:19 <lambdabot> Undefined
02:44:20 <jethr0_> every type in haskell contains undefined
02:44:20 <lambdabot>  Not in scope: data constructor `Undefined'
02:44:21 <pierre-> @type undefined::Int
02:44:21 <lambdabot> Int
02:44:29 <pierre-> @type undefined
02:44:29 <palomer> > (undefined::Bool) == undefined
02:44:29 <lambdabot> forall a. a
02:44:30 <lambdabot> Undefined
02:44:43 <neologism> what exaclty means "forall a. " ?
02:44:46 <neologism> thats from system F?
02:44:53 <davidhouse> jethr0_: is undefined _|_ or is that something else?
02:44:57 <roconnor> @hoogle [Maybe a] -> [a]
02:44:58 <ihope> It means that any a will work.
02:44:58 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
02:45:01 <jethr0_> davidhouse: i think so
02:45:08 <davidhouse> jethr0_: and where is it useful?
02:45:11 <jethr0_> davidhouse: but for a better answer you should ask our type experts
02:45:13 <ihope> forall a. a -> a means that it will take a and return a for any a.
02:45:34 <neologism> is there any correspondence with system F?
02:45:35 <pierre-> let x = Undefined + x in x 
02:45:38 <ndm> davidhouse: there are two types of _|_ - non terminatino and a pattern match error
02:45:38 <jethr0_> davidhouse: i think error propagation is done using undefined (i could be wrong here).
02:45:48 <ndm> undefined is a pattern match error
02:45:50 <pierre-> > let x = Undefined::Int + x in x
02:45:51 <lambdabot>  Not in scope: data constructor `Undefined'
02:46:04 <davidhouse> > _|_
02:46:04 <lambdabot>  parse error on input `|'
02:46:17 <jethr0_> and undefined values can be useful with lazy evaluation. so if a function doesn't terminate it's == undefined, but if we never evaluate it, that's just as well
02:46:23 <jethr0_> > fst (1,undefined)
02:46:24 <lambdabot> 1
02:46:27 <ihope> @type \x -> seq x undefined
02:46:28 <lambdabot> forall a a1. a -> a1
02:46:37 <jethr0_> > head $ map (+1) [1,2,3,undefined]
02:46:38 <lambdabot> 2
02:46:46 <davidhouse> jethr0_, ndm: makes sense
02:46:58 <davidhouse> > map (+1) [1,2,3,undefined]
02:46:59 <lambdabot> Undefined
02:47:10 <davidhouse> @index Undefined
02:47:10 <lambdabot> bzzt
02:47:14 <davidhouse> @index undefined
02:47:14 <lambdabot> Prelude
02:47:16 <ihope> > take 3 (map (+1) [1,2,3,undefined])
02:47:17 <lambdabot> [2,3,4]
02:47:44 <davidhouse> > [1..] : undefined
02:47:45 <lambdabot> [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
02:47:45 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
02:47:45 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
02:47:45 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
02:47:45 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
02:47:47 <lambdabot> [24 @more lines]
02:48:04 <davidhouse> > undefined : [1..] --meant this :)
02:48:05 <lambdabot> Undefined
02:48:19 <davidhouse> > [1..] ++ [undefined]
02:48:20 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
02:48:20 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
02:48:20 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
02:48:20 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
02:48:20 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
02:48:22 <lambdabot> [24 @more lines]
02:48:23 <jethr0_> > drop 1 $ undefined : [1..5]
02:48:24 <lambdabot> [1,2,3,4,5]
02:48:29 <ihope> > undefined : undefined
02:48:30 <lambdabot> Add a type signature
02:48:38 <ihope> > undefined : undefined :: [()]
02:48:38 <lambdabot> Undefined
02:48:49 <ihope> > (\x -> x : x) undefined
02:48:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
02:48:50 <lambdabot>   Expected type: [a]
02:48:50 <lambdabot>   Inferred type: a
02:49:25 <palomer> quick, someone write a function that checks if all the elements of a list are actually the same
02:49:51 <ihope> foldr (==) True?
02:49:57 <ihope> @type foldr (==) True
02:49:58 <lambdabot> [Bool] -> Bool
02:50:01 <ihope> Oh./
02:50:06 <davidhouse> \l -> foldr (==) (tail l) l
02:50:14 <davidhouse> err
02:50:17 <davidhouse> \l -> foldr (==) (last l) l
02:50:24 <ihope> @type \l -> foldr (==) (last l) l
02:50:25 <lambdabot> [Bool] -> Bool
02:50:38 <Jarod> i need a good editor under windows to write Haskell code
02:50:44 <davidhouse> \l -> foldl (==) (ha l) l
02:50:47 <Lemmih> @type (\l -> all (== head l) l) 
02:50:48 <lambdabot> forall a. (Eq a) => [a] -> Bool
02:50:49 <pierre-> Jarod: take cream
02:50:51 <davidhouse> @type \l -> foldl (==) (heah l) l
02:50:52 <lambdabot> Not in scope: `heah'
02:50:56 <Jarod> ok thanks
02:51:04 <davidhouse> @type \l -> foldl (==) (head l) l
02:51:05 <lambdabot> [Bool] -> Bool
02:51:05 <palomer> and that returns True on []
02:51:16 <davidhouse> > head []
02:51:17 <lambdabot> Add a type signature
02:51:36 <davidhouse> Lemmih: why didn't my fold work?
02:51:40 <seth_> palomer, well, all the elements of [] are the same
02:51:46 <davidhouse> wait, i know.
02:51:47 <Lemmih> @type let allEq [] = True; allEq (x:xs) = all (== x) xs in allEq
02:51:48 <lambdabot> forall a.
02:51:48 <lambdabot>                      (Eq a) =>
02:51:48 <lambdabot>                      [a] -> Bool
02:51:52 <davidhouse> duh.
02:52:06 <ihope> > head [] :: (0
02:52:07 <lambdabot>  parse error on input `}'
02:52:08 <ihope> > head [] :: ()
02:52:09 <lambdabot> Exception: Prelude.head: empty list
02:52:12 <palomer> let f = (\l -> all (== head l) l)  in f []
02:52:15 <ihope> > head [] :: 3
02:52:16 <lambdabot>  Only unit numeric type pattern is valid
02:52:29 <palomer> > let f = (\l -> all (== head l) l)  in f []
02:52:30 <lambdabot> Add a type signature
02:52:33 <Lemmih> > let allEq [] = True; allEq (x:xs) = all (== x) xs in allEq [1,2,3]
02:52:34 <palomer> hmm?
02:52:34 <lambdabot> False
02:52:37 <Lemmih> > let allEq [] = True; allEq (x:xs) = all (== x) xs in allEq [1,1,1]
02:52:38 <lambdabot> True
02:52:52 <Lemmih> > let allEq [] = True; allEq (x:xs) = all (== x) xs in allEq ([]::[Int])
02:52:52 <lambdabot> True
02:53:25 <davidhouse> > let allEq [] = True; allEq (x:xs) = all (== x) xs in allEq [1,1..]
02:53:28 <lambdabot> Terminated
02:53:36 <davidhouse> human > computer
02:54:28 <ihope> human /= computer
02:54:29 <palomer> > let f = (\l -> all (== head l) l)  in f [1,2]
02:54:30 <lambdabot> False
02:54:49 <palomer> why didn't my previous code work?
02:55:09 <jethr0_> > foldl (&&) True [True,True,False]
02:55:10 <lambdabot> False
02:55:12 <ihope> @type let f = (\l -> all (== head l) l) in f []
02:55:13 <lambdabot> Bool
02:55:21 <ihope> > let f = (\l -> all (== head l) l) in f []
02:55:21 <lambdabot> Add a type signature
02:55:26 <davidhouse> palomer: where?
02:55:31 <ihope> > let f = (\l -> all (== head l) l) in f ([] :: [()])
02:55:32 <lambdabot> True
02:55:34 <palomer> what ihope just pasted
02:55:39 <palomer> > True
02:55:40 <lambdabot> True
02:56:06 <davidhouse> @type []
02:56:07 <lambdabot> forall a. [a]
02:56:12 <davidhouse> @type head []
02:56:13 <lambdabot> forall a. a
02:56:24 <ihope> :-)
02:56:34 <davidhouse> @type (==head [])
02:56:35 <lambdabot> forall a. (Eq a) => a -> Bool
02:56:35 <jethr0_> spam, spam, spam
02:56:56 <ihope> Wonderful spam!
02:56:58 <jethr0_> davidhouse: head fails on empty list
02:57:04 <ihope> > tail []
02:57:05 <lambdabot> Add a type signature
02:57:09 <davidhouse> > head []
02:57:10 <ihope> > tail [] :: [()]
02:57:10 <lambdabot> Add a type signature
02:57:10 <lambdabot> Exception: Prelude.tail: empty list
02:57:18 <ihope> > head [] :: ()\
02:57:18 <lambdabot>  parse error on input `\'
02:57:18 <davidhouse> jethr0_: so it does.
02:57:20 <ihope> > head [] :: ()
02:57:20 <pierre-> > []==[]
02:57:21 <lambdabot> Exception: Prelude.head: empty list
02:57:21 <lambdabot> Add a type signature
02:57:28 <ihope> > [] == []
02:57:28 <lambdabot> Add a type signature
02:57:33 <palomer> righto
02:57:34 <pierre-> ? 
02:57:35 <jethr0_> ihope: you can use "drop 1" instead of tail
02:57:37 <palomer> man, I need to get some more sleep
02:57:43 <ihope> > drop 1 []
02:57:43 <lambdabot> Add a type signature
02:57:50 <ihope> > drop 1 [] :: [()]
02:57:51 <lambdabot> []
02:57:54 <ihope> > []
02:57:55 <lambdabot> Add a type signature
02:58:00 <pierre-> @type ()
02:58:00 <lambdabot> ()
02:58:10 <pierre-> > () == ()
02:58:11 <lambdabot> True
02:58:18 <jethr0_> pierre-: () is not an empty tuple, but it's own data type :)
02:58:47 <pierre-> :-) does empty tuple exists?
02:58:51 <ihope> ()
02:58:56 <jethr0_> no
02:59:02 <ihope> What's the difference?
02:59:06 <jethr0_> @type ()
02:59:07 <lambdabot> ()
02:59:10 <jethr0_> @type (1)
02:59:10 <lambdabot> forall t. (Num t) => t
02:59:20 <jethr0_> @type (1,2)
02:59:21 <lambdabot> forall a b. (Num a, Num b) => (a, b)
02:59:41 <Lemmih> () is just as much a tuple as (a,b).
02:59:45 <jethr0_> ihope: but i agree, in practice the difference is minor
02:59:47 <pierre-> @type []
02:59:48 <lambdabot> forall a. [a]
02:59:56 <jethr0_> Lemmih: k, i didn't know better
03:00:13 <pierre-> why there's no monads in []'s type?
03:00:26 <ihope> [] doesn't work in every monad.
03:00:34 <jethr0_> huh?
03:00:38 <davidhouse> pierre-: why should there be?
03:00:54 <pierre-> isn't [] a monad?
03:00:57 <davidhouse> yes.
03:01:08 <davidhouse> but it doesn't require its argument to be monadic.
03:01:09 <jethr0_> @kind []
03:01:09 <lambdabot> * -> *
03:01:13 <davidhouse> [a] is a monad.
03:01:18 <davidhouse> well, it's a in the monad [].
03:01:45 <ihope> pierre-: what should its type be, then?
03:01:46 <davidhouse> so if you had some function that looked like Monad m => m a -> Whatever, you could give it [a] for the first arg
03:02:00 <pierre->  @type [] is type of an empty list, yes?
03:02:14 <davidhouse> @type []
03:02:14 <lambdabot> forall a. [a]
03:02:17 <jethr0_> pierre-: empty or not doesn't reflect into the type
03:02:26 <davidhouse> pierre-: yes
03:02:40 <ihope> forall a. [a] is the type of an empty list...
03:02:43 <davidhouse> but [] is a list of integers.
03:02:47 <davidhouse> it's also a list of strings
03:02:51 <davidhouse> and a list of bools...
03:03:02 <davidhouse> in fact, for all a, [] is a list of a.
03:03:03 <ihope> It's a list of ((a -> b) -> a) -> a as well.
03:03:13 <pierre-> yes, i'm missing types with values...
03:03:19 <pierre-> *messing
03:04:09 <ihope> @type (|)
03:04:10 <lambdabot> parse error on input `|'
03:04:13 <jethr0_> forget what i said. of course the emptyness reflects into the type. i was thinking of ([]::Type).
03:04:45 <ihope> jethr0: it doesn't have to. [] can have type [Bool] or something.
03:04:52 <palomer> > let f = (\l -> all (== head l) l)  in f [] <---shouldn't f not even calculate the head of l?
03:04:52 <lambdabot>  parse error on input `of'
03:04:54 <davidhouse> ihope, that's what he meant
03:04:59 <davidhouse> []::[Bool]
03:05:16 <palomer> > all id undefined
03:05:17 <jethr0_> ihope: i know. i just phrased my sentence badly
03:05:17 <lambdabot> Undefined
03:05:26 <ihope> Okay.
03:05:27 <palomer> > all undefined []
03:05:28 <lambdabot> True
03:05:47 * palomer is confused
03:05:53 <dcoutts> ndm, pong
03:06:00 <davidhouse> palomer: what would you use as an initial value then?
03:06:16 <ihope> If it's acting on the empty list...
03:06:31 <palomer> davidhouse: I'm saying that (== head l) should never be evaluated
03:06:32 <Lemmih> > (\l -> all (== head l) l) ([]::[Int])
03:06:33 <lambdabot> True
03:06:35 <ndm> hi dcoutts, i now have modified haddock to generate hoogle output
03:06:45 <palomer> > (\l -> all (== head l) l) []
03:06:45 <lambdabot> Add a type signature
03:06:52 * palomer is confused
03:06:53 <ndm> and i'm not trying to run "some libraries" through this, so I can add them to the hoogle website
03:06:59 <ndm> and gtk2hs would be a good one for this
03:07:02 <palomer> is this because of MR?
03:07:11 <Lemmih> palomer: No.
03:07:12 <davidhouse> @type (l\ -> all (==head l) l) []
03:07:13 <lambdabot> parse error on input `\'
03:07:17 <ihope> palomer: it doesn't know what type [] should be to use in (==)
03:07:18 <davidhouse> @type (\l -> all (==head l) l) []
03:07:19 <pierre-> > all undefined [] -- is undefined here (a -> Bool)?
03:07:19 <lambdabot> Bool
03:07:20 <lambdabot> True
03:07:22 <ndm> unfortunately, i couldn't really figure out how to get .hs files, since they are all chs and other suffixes
03:07:34 <palomer> it works in ghci, btw
03:07:50 <dcoutts> ndm, use ./configure --enable-docs
03:07:54 <seth_> ndm, you can always do mv xyz.chs xyz.hs  :)
03:07:59 <dcoutts> ndm, then do a full make
03:08:04 <palomer> why the blazes would it work in ghci but not lambdabot
03:08:05 <ndm> dcoutts, and on windows?
03:08:09 <dcoutts> ndm, same on windows
03:08:13 <davidhouse> @type (\a -> all a [])
03:08:14 <lambdabot> forall a. (a -> Bool) -> Bool
03:08:25 <jethr0_> does anyone know if there's a way to get haddock to work with the new arrow notation of "-farrows"?
03:08:26 <ihope> palomer: I guess lambdabot /= GHCi
03:08:26 <davidhouse> @type undefined
03:08:27 <lambdabot> forall a. a
03:08:35 <jethr0_> maybe a pragma to let haddock ignore a portion of code?
03:08:36 <ndm> i take it by windows, you mean cygwin or msys, and not real windows?
03:08:49 <dcoutts> ndm, yes, msys
03:08:59 <ndm> seth_, won't haddock choke on {# stuff #}?
03:09:10 <seth_> ndm, it might, I wasn't really being serious.
03:09:31 <ndm> seth_ - its a perfectly reasonable solution, i only want documentation - not to build it
03:09:37 <ihope> > {-} 3
03:09:37 <lambdabot>  unterminated `{-'
03:09:38 <jethr0_> ndm: haddock chokes on practially anything
03:09:43 <ihope> > {--} 3
03:09:43 <lambdabot> 3
03:09:47 <ihope> @type {--}
03:09:48 <lambdabot> not an expression: `'
03:09:51 <ihope> @type 
03:09:52 <lambdabot> not an expression: `'
03:09:54 <davidhouse> what on earth is that?
03:09:57 <ihope> > 
03:09:57 <lambdabot> <stdin>: hGetLine: end of file
03:09:59 <davidhouse> the braces thing
03:10:04 <ihope> Comment.
03:10:06 <ihope> Empty comment.
03:10:11 <ndm> jethr0_: including GHC source code, especially the type checker
03:10:14 <ihope> > {--}
03:10:14 <davidhouse> oh, i thought it was some weird operator. of course :)
03:10:15 <lambdabot>  parse error on input `}'
03:10:32 <ihope> > [1,2,3,4,5] -- [3,4,5]
03:10:33 <lambdabot> [1,2,3,4,5]
03:10:40 <jethr0_> ndm: i know. it's choking on special chars (like slashes) and on the arrow notation :((
03:10:44 <pierre-> > {- {- -- -} -} 4
03:10:45 <lambdabot> 4
03:10:52 <ihope> > -} 4
03:10:53 <lambdabot>  parse error on input `}'
03:10:57 <ihope> Whoo.
03:11:06 <ihope> > {- {- 3 -} -} 4
03:11:07 <lambdabot> 4
03:11:09 <ndm> jethr0_: half the type checker has comments like this *really* should be the case, and haddock dies there
03:11:10 <palomer> whoa, haskell uses nested comments?
03:11:11 <palomer> that's nuts!
03:11:18 <jethr0_> > let a -} b = a + b in 4 -} 5
03:11:19 <lambdabot>  parse error on input `}'
03:11:21 <pierre-> hah 
03:11:26 <ihope> :-)
03:11:28 <jethr0_> > let a --} b = a + b in 4 --} 5
03:11:28 <lambdabot>  parse error (possibly incorrect indentation)
03:11:42 <pierre-> > \n
03:11:42 <lambdabot>  parse error on input `}'
03:11:56 <ihope> > \n -> n
03:11:56 <lambdabot>  add an instance declaration for (Show (t -> t))
03:11:57 <pierre-> > \n
03:11:57 <lambdabot>  parse error on input `}'
03:11:58 <Lemmih> Not having nested comments is a major PITA.
03:11:59 <ihope> ;-)
03:12:13 <davidhouse> Lemmih: it is? where?
03:12:27 <ihope> Commenting out commented code...
03:12:32 <jethr0_> Lemmih: look at C(++). using #if 0 is definitely no good alternative for real nested comments
03:12:35 <pierre-> > àáâãä
03:12:36 <lambdabot>  Not in scope: `àáâãä'
03:12:51 <pierre-> > let Ï = 1 in Ï
03:12:52 <lambdabot>  Not in scope: data constructor `Ï'
03:12:54 <Lemmih> davidhouse: If you comment out a large code block with {- -} comments inside.
03:12:57 <jethr0_> davidhouse: in C++ for example
03:12:58 <ihope> :-D
03:13:07 <davidhouse> > let á = (+) in á 1 2
03:13:08 <lambdabot> 3
03:13:12 <mauke> #if 0 is superior to nested comments
03:13:15 <ihope> > \â”¤ -> â”¤ + 3
03:13:15 <lambdabot>  lexical error
03:13:22 <mauke> comments are for comments, not code
03:13:24 <pierre-> > let Ï = 1 in Ï
03:13:24 <lambdabot>  Not in scope: data constructor `Ï'
03:13:32 <jethr0_> mauke: with the "0" it's not superior, IMO
03:13:32 <pierre-> ? why?
03:13:44 <davidhouse> > let á = 1 in á
03:13:45 <lambdabot> 1
03:13:45 <mauke> pierre-: Ï is uppercase
03:13:55 <jethr0_> pierre-: because symbols starting in uppercase are reserved for data constructors
03:13:59 <ihope> mauke: then how are we supposed to remove code that we might want later?
03:14:03 <davidhouse> > let Á = 1 in Á
03:14:04 <lambdabot>  Not in scope: data constructor `Á'
03:14:11 <pierre-> wow. even cyrillic uppercase
03:14:12 <mauke> ihope: use something like #if 0 :-)
03:14:26 * Lemmih thinks CPP is a dirty hack.
03:14:33 <davidhouse> (i <3 AltGr+symbols :))
03:14:42 <jethr0_> Lemmih: stroustrup even admits it on occasion :)
03:14:42 <ihope> data Spanish = Ã‘ String
03:14:47 <tromp_> > let æœˆäº®ä»£è¡¨æˆ‘çš„å¿ƒ = 0 in æœˆäº®ä»£è¡¨æˆ‘çš„å¿ƒ
03:14:48 <lambdabot>  lexical error
03:14:58 <ihope> > let ? = 0 in ?
03:14:59 <lambdabot>  parse error on input `?'
03:15:04 <ihope> > let 5 = 6 in 5
03:15:05 <lambdabot> 5
03:15:08 <tromp_> i pasted some chinese:)
03:15:11 <ihope> > let Nothing = () in Nothing
03:15:12 <lambdabot> Couldn't match `Maybe a' against `()'
03:15:18 <ihope> Aww.
03:15:28 <davidhouse> > let id = 4 in id
03:15:29 <lambdabot> 4
03:15:40 <tromp_> > let 0=0 in 0
03:15:41 <lambdabot> 0
03:15:51 <jethr0_> Lemmih: what does "let 5 = 6 in 5" do? why isn't that an error?
03:16:13 <davidhouse> let 5 = map in 5 (+1) [1..10]
03:16:18 <Lemmih> jethr0_: It's like 'let Just 5 = Just 20 in ()'
03:16:19 <davidhouse> > let 5 = map in 5 (+1) [1..10]
03:16:19 <lambdabot>  add an instance declaration for (Num ((a -> a) -> [a1] -> a2))
03:16:19 <lambdabot>   In the definition of `ruj': ruj = let 5 = map in 5 ((+ 1)) ([1 .. 10])
03:16:19 <lambdabot>   In the definition of `v': v = let ruj = let ... in ... in take 2048 (
03:16:19 <lambdabot> show ruj)
03:16:21 <ihope> Well, (x:y:z) = [1,2,3]. isn't an error.
03:16:22 <tromp_> > (\0 -> 1) 0
03:16:23 <lambdabot> 1
03:16:36 <ihope> Nor is (x:y) = [1,2,3], or x = [1,2,3]...
03:16:43 <tromp_> > (\0 -> 0) 1
03:16:44 <lambdabot>  Non-exhaustive patterns in lambda
03:16:47 <Lemmih> jethr0_: Or 'let Just 10 = Nothing in ()'. It's a pattern match failure but it isn't evaluated.
03:16:48 <davidhouse> jethr0_: i don't think you can have funcs which have a purely numeric name
03:16:59 <jethr0_> k
03:17:05 <tromp_> > (\0 -> 0) 0
03:17:06 <lambdabot> 0
03:17:12 <pierre-> @type Just 1
03:17:12 <lambdabot> forall a. (Num a) => Maybe a
03:17:23 <pierre-> @kind Maybe
03:17:24 <lambdabot> * -> *
03:17:36 <davidhouse> kinds seem fairly pointless.
03:17:41 <davidhouse> nearly everything has kind * -> *
03:17:48 <davidhouse> @kind State
03:17:49 <lambdabot> Not in scope: type constructor or class `State'
03:17:49 <jethr0_> @kind Int
03:17:50 <lambdabot> *
03:17:53 <ihope> :-)
03:18:00 <jethr0_> @kind Either
03:18:00 <lambdabot> * -> * -> *
03:18:11 <Lemmih> @kind (->)
03:18:11 <lambdabot> ?? -> ? -> *
03:18:15 <davidhouse> @kind Control.Monad.State
03:18:15 <lambdabot> Not in scope: type constructor or class `Control.Monad.State'
03:18:23 <ihope> @kind (->) :: * -> * -> *
03:18:24 <lambdabot> parse error on input `::'
03:18:31 <ihope> Aww.
03:18:37 <ihope> @index ST
03:18:38 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
03:18:46 <ihope> @kind Control.Monad.ST.ST
03:18:47 <lambdabot> * -> * -> *
03:18:49 <davidhouse> @kind Control.Monad.State.State
03:18:50 <lambdabot> * -> * -> *
03:19:01 <davidhouse> i remembered the name :)
03:20:16 <TuringTest> Hmmm...I wanted to see I could use Template Haskell to evaluate something at compile time.
03:20:27 <TuringTest> Anyone know the where the idiom for this is documented?
03:20:53 <jethr0_> TuringTest: http://haskell.org/hawiki/TemplateHaskellTutorial#head-33c4174493de650592977a4e50901cf60c1d303a
03:20:55 <Lemmih> TuringTest: x = $( expr )?
03:21:28 <TuringTest> Lemmih: Well expr has to be the right type
03:21:56 <TuringTest> Lets's say I have a "parse :: String -> Foo" and the Strings are known at compile time
03:22:07 <Lemmih> TuringTest: x = [| expr |] ?
03:22:24 <Lemmih> Bah, ignore me.
03:22:41 <TuringTest> q = $( [| parse Foo |] ) is the same as q = parse Foo
03:22:51 <TuringTest> so it takes a bigger trick
03:23:01 <TuringTest> Probably using unsafePerformIO or some such
03:23:13 <roconnor> @docs case
03:23:14 <lambdabot> case not available
03:23:18 <jethr0_> TuringTest: i haven't quite understood what you want to do
03:23:35 <jethr0_> TuringTest: and maybe it's in the tutorial link i posted
03:23:37 <Lemmih> TuringTest: There's a 'lift' function somewhere in the TH lib.
03:23:45 <TuringTest> jethr0_: I want to have (parse "abc") evaluated at compile time
03:24:02 <jethr0_> TuringTest: where do you get the "abc" from?
03:24:04 <TuringTest> Lemmih: But my Foo is not an instance of Lift
03:24:05 <ihope> Eureka!
03:24:13 <jethr0_> TuringTest: look at the link!
03:24:17 <TuringTest> jethr0_: It is a string known at compile time: a regular expression
03:24:26 <TuringTest> jethr0_: I have been looking at it
03:24:27 <ihope> @djinn (a -> Either a b) -> (b -> Either b c) -> a -> Either b c
03:24:27 <lambdabot> -- f cannot be realized.
03:24:38 <ihope> We need to generalize arrows.
03:25:13 <TuringTest> More detail: "parseRegexp :: String -> GenParser Char Int ()"
03:25:22 <jethr0_> TuringTest: why won't "let x = parse "abc" in x `seq` x" work?
03:25:23 <TuringTest> And GenParser is not an instance of Lift
03:25:43 <TuringTest> jethr0_: x `seq` x is meaningless
03:25:53 <ihope> It's equivalent to x.
03:25:57 <ihope> Not quite meaningless.
03:26:11 <TuringTest> (modulo bottom)
03:26:12 <jethr0_> ihope: i thought it would force normal form of x
03:26:42 <TuringTest> jethr0_: It only is "run" if x is demanded in which case the seq is redundant
03:26:45 <ihope> deepSeq x x?
03:26:58 <TuringTest> ihope: That is different
03:27:04 <TuringTest> But I don't want any of that.
03:27:13 <ihope> What *is* deepSeq?
03:27:21 * jethr0_ turns to his more productive coding
03:27:24 <TuringTest> I want to know if Template Haskell is powerful enough to run code at compile time and splice the result into my program.
03:27:31 <jethr0_> TuringTest: yes
03:27:36 <TuringTest> Or if that power is limited to instances of Lift
03:27:46 <jethr0_> TuringTest: i don't understand the question
03:28:07 <TuringTest> jethr0_: The example on the wiki uses "lift =<< runIO askForStr"
03:28:15 <Igloo> If you could write it with Haskell, then you could write a program to write it with TH
03:28:20 <TuringTest> jethr0_: lift is part of the type class Lift
03:28:40 <jethr0_> TuringTest: btw, "f x" is not equivalent to "$([|f x|])" when you look at the AST. it's just equivalent in its effect
03:28:45 <TuringTest> Igloo: The value to splice is a Parsec parser.  Would I need to re-implement Parsec?
03:28:52 <jethr0_> TuringTest: you don't need lift. it's just a convenience
03:29:00 <ihope> @index lift
03:29:01 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
03:29:01 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
03:29:01 <lambdabot> Control.Monad.List, Language.Haskell.TH.Syntax, Text.ParserCombinators.
03:29:01 <lambdabot> ReadPrec, Text.Read
03:29:09 <ihope> @type Control.Monad.Trans.lift
03:29:10 <lambdabot> forall (t :: (* -> *) -> * -> *)
03:29:10 <lambdabot>             a
03:29:10 <lambdabot>             (m :: * -> *).
03:29:10 <lambdabot>           (Control.Monad.Trans.MonadTrans t, Monad m) =>
03:29:10 <lambdabot>           m a -> t m a
03:29:24 <pierre-> @docs unsafePerformIO
03:29:25 <TuringTest> @type Language.Haskell.TH.Syntax.lift
03:29:25 <lambdabot> unsafePerformIO not available
03:29:25 <lambdabot> forall t.
03:29:25 <lambdabot>             (Language.Haskell.TH.Syntax.Lift t) =>
03:29:25 <lambdabot>             t -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.
03:29:25 <lambdabot> Exp
03:29:33 <ihope> @type Control.Monad.Trans.lift `asTypeOf` liftM
03:29:34 <lambdabot> Not in scope: `liftM'
03:29:39 <jethr0_> TuringTest: lift get's values into the Q monad and can therefore be "emulated" with "return"
03:29:41 <ihope> @type Control.Monad.Trans.lift `asTypeOf` Control.Monad.liftM
03:29:42 <lambdabot>   Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
03:29:42 <lambdabot>   When matching the kinds of `t :: (* -> *) -> * -> *' and `(->) :: ?? ->
03:29:42 <lambdabot> ? -> *'
03:29:45 <Igloo> Does evaluating a parsec parser actually do anything non-trivial, then?
03:29:52 <ihope> OW.
03:29:55 <TuringTest> jethr0_: Hmm....
03:30:14 <TuringTest> Igloo: It just moves the parsing from runtime to compile time.
03:30:22 <jethr0_> TuringTest: lift just does it recursively on the whole AST.
03:30:48 <jethr0_> to map a tree of type Exp to a tree of type ExpQ or "Q Exp"
03:30:50 <Igloo> If you want to do the parsing at compile time then the value you want to splice isn't a parsec parser, it's whatever type is being parsed
03:31:13 * jethr0_ takes a break
03:31:15 <TuringTest> Igloo: Actaully, the value of my parsec parser is another parsec parser.  
03:31:24 <Igloo> Ah, OK
03:31:44 <TuringTest> Igloo: I am parsing a string regexp into a Parsec parser that accepts that regexp
03:31:48 <Igloo> I think you'll need alift instance then
03:32:13 <TuringTest> Igloo: But there is no documentation I can find yet about creating a lift instance
03:32:20 <TuringTest> s/lift/List/
03:32:25 <TuringTest> s/lift/Lift/
03:32:39 <jethr0_> you don't need lift. as long as you stay in the quasi-quotes, you're already in the Q monad
03:33:42 <Lemmih> jethr0_: 'TH.Syntax.lift' lifts an expression to an Expr.
03:33:44 <TuringTest> jethr0_: [| parseRegexp "abc" |] does not evaluate parseRegexp so I need a trick
03:33:56 <TuringTest> Lemmih: Right.
03:34:02 <Lemmih> jethr0_: "lift 'c'" => LitE (CharL 'c')
03:34:08 <jethr0_> TuringTest: $([| parseRegexp "abc" |]) _does_ evaluate it
03:34:27 <TuringTest> Hmm....I'll test that again, but I don't think so...
03:34:35 <jethr0_> [| 'c' |] => litE (charL 'c')
03:35:18 <jethr0_> Lemmih: sry, i might have been wrong there...
03:35:21 <palomer> the Q monad?
03:35:28 <jethr0_> i'll just shut up.
03:36:49 <TuringTest> jethr0_: I checked again...it doesn't
03:37:26 <Lemmih> $([| parseRegexp "abc" |]) will lift the entire expression (to an AppE). You need to lift the result of the function.
03:37:35 <TuringTest> Right
03:37:43 <Lemmih> TuringTest: Know how to translate a Foo to an Exp?
03:38:02 <TuringTest> Not offhand...it is a Parsec type "GenParser Char Int ()"
03:39:22 <TuringTest> Lemmih: I had hoped TH would be have a tricky solution to this.  John Meacham used some unsafePerformIO trick I can't duplicate to make hsregex use TH
03:39:28 <Lemmih> Uh, then 'parseRegexp "abc"' doesn't really calculate anything.
03:39:54 <TuringTest> parseRegexp "abc" returns a GenParser Char Int ()
03:40:17 <TuringTest> It is Parsec returning Parsec which is a bit unusual
03:40:17 <Lemmih> TuringTest: Indeed.
03:40:56 <Lemmih> Ah.
03:41:12 <TuringTest> And a generic "evaluate this expression at compile time" feature would be nifty....I may need hsplugins' "eval" for this.
03:41:42 <TuringTest> But that is also not an obvious answer
03:43:35 <TuringTest> The mailing list had a similar request to evaluate an array initializer at compile time, but there was no solution for that, either.
03:43:50 <Lemmih> TuringTest: "eval" from hs-plugins doesn't do what you want.
03:43:59 <ihope> @type (Control.Monad.Arrow.&&&)
03:43:59 <lambdabot> Couldn't find qualified module.
03:43:59 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
03:43:59 <lambdabot> \\)?
03:44:08 <ihope> @type (Control.Arrow.&&&)
03:44:09 <lambdabot> forall (a :: * -> * -> *) c' c b.
03:44:09 <lambdabot>         (Control.Arrow.Arrow a) =>
03:44:09 <lambdabot>         a b c -> a b c' -> a b (c, c')
03:44:53 <TuringTest> Lemmih: It would if I created source code for a Parsec Parser and passed to eval.  But I would need to change parseRegexp to do that.
03:44:59 <Lemmih> TuringTest: I think you have to change the type of 'parseRegexp' to 'String -> (Q?) Exp'.
03:45:26 <TuringTest> Lemmih: Hmmm...That could be a solution....
03:45:39 <Lemmih> TuringTest: No, it wouldn't. "eval" just turns a string into an expression. But you already have the expression.
03:45:40 <jethr0_> TuringTest: sry, that i talked nonsense just now. happens to the best of us. as a workaround i would think that executing your function inside IO as in the tutorial should work...
03:45:58 <jethr0_> ah, but then you need a "lift" again. nm
03:46:56 <TuringTest> Lemmih: I think that may work!
03:47:32 <palomer> what's that combinator that mimicks an if statement without any else branch?
03:47:40 <palomer> @hoogle when
03:47:40 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
03:48:44 * TuringTest goes off to convert parseRegexp to return Q Exp
03:49:08 <ihope> How about Bool -> m a -> a -> ma?
03:49:11 <ihope> s/ma/m a/
03:49:57 <tromp_> in addition to when, we should have what and why combinators
03:50:18 <tromp_> oh wait we alrd have a Y combinator:)
03:50:39 <ihope> :-)
03:50:45 <ihope> How combinator?
03:50:55 <tromp_> that too:)
03:51:02 <ihope> how = >> return ()
03:51:07 <ihope> Erm.
03:51:11 <ihope> how = (>> return ())
03:51:45 <ihope> what = unsafePerformIO -- eep
03:51:50 <tromp_> that looks more like a whatever instead of how
03:52:11 <ihope> But it gives you how the value was calculated, but not the value itself.
03:52:11 <palomer> ihope: what about Bool -> m a -> a -> m a ?
03:52:33 <ihope> when :: Bool -> m a -> a -> m a
03:52:50 <ihope> when True a b = a
03:52:59 <ihope> when False a b = return b
03:53:00 <palomer> when is Bool -> m () -> m ()
03:53:07 <ihope> I know.
03:53:11 <palomer> oh, this is a when'
03:53:16 <ihope> Yeah.
03:53:40 <palomer> how would this be useful?
03:53:57 <tromp_> you mean when wld it be useful:-?
03:54:06 <palomer> har har
03:54:40 <ihope> When you don't want an m ()
03:57:04 <palomer> got an example where it's useful?
03:58:07 <ihope> No.
03:58:44 <Lemmih> Maybe it'll help us avoid success?
03:59:10 <ihope> when x y = when' x () y
04:00:10 <tibbe> could anyone give me a link to either big step operational semantics or denotational semantics for lambda calculus?
04:01:30 <tibbe> @where semantics
04:01:30 <lambdabot> I know nothing about semantics.
04:02:08 <palomer> ok,\s -> all (== (head s)) s bothers me
04:02:12 <palomer> it's giving me a head error
04:02:24 <palomer> (and a head ache)
04:03:11 <Lemmih> > let lst :: [Int]; lst = [] in (\s -> all (== head s) s) lst
04:03:12 <lambdabot> True
04:03:25 <Lemmih> > let lst :: [Int]; lst = [1,2] in (\s -> all (== head s) s) lst
04:03:26 <lambdabot> False
04:03:27 <palomer> oh, wait ,nevermind
04:03:31 <palomer> the head is never computed
04:03:55 <Lemmih> > let lst :: [Int]; lst = [undefined,2] in (\s -> all (== head s) s) lst -- Sure, it is.
04:03:56 <lambdabot> Undefined
04:04:25 <ihope> tibbe: you mean "how lambda calculus works", or something else?
04:06:43 <tibbe> ihope, I'm curious about the notatation, i.e. how do you write the semantics of LC
04:07:02 <ihope> \vars.body
04:07:10 <ihope> (Erm.)
04:07:24 <palomer> the head is never computed if the list is empty
04:08:08 <davidhouse> @type minimumBy
04:08:09 <lambdabot> Not in scope: `minimumBy'
04:08:17 <davidhouse> @type Data.Lits.minimumBy
04:08:17 <lambdabot> Couldn't find qualified module.
04:08:17 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
04:08:17 <lambdabot> \\)?
04:08:25 <davidhouse> @type Data.List.minimumBy
04:08:26 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
04:08:34 <davidhouse> @type Ordering
04:08:34 <lambdabot> Not in scope: data constructor `Ordering'
04:08:40 <davidhouse> @kind Ordering
04:08:41 <lambdabot> *
04:08:48 <davidhouse> what is it?
04:09:17 <davidhouse> @index Ordering
04:09:17 <lambdabot> Prelude
04:10:59 <tibbe> ihope, I mean, a rule for variables would be:  <x, env> => env(x)   where env is the environment and contains the variable bindings (in big step op semantics)
04:11:05 <ihope> data Ordering = LT | EQ | GT
04:11:20 <davidhouse> thanks ihope.
04:12:00 <davidhouse> @hoogle a -> a -> Ordering
04:12:01 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
04:12:01 <lambdabot> Prelude.LT :: Ordering
04:12:01 <lambdabot> Prelude.EQ :: Ordering
04:14:47 <TuringTest> Lemmih: The parsing to ExpQ worked.  Thanks for the hint
04:17:21 <Lemmih> TuringTest: Great.
04:26:14 <davidhouse> in general, do people find it takes longer to write a functional or imperative algorithm?
04:27:16 <GeniXPro> most algorithms can be done as either functional or imperitive
04:27:28 <davidhouse> perhaps it's just inexperience, but i find it seems to hours to write a functional algorithm for something that i could knock up in an imperative language within 20 minutes or so
04:27:30 <GeniXPro> they are all based on result computation
04:27:41 <davidhouse> GeniXPro: yes, i'm talking about how long it takes to write them
04:27:47 <jethr0_> davidhouse: that's just a transitional period :)
04:27:58 <GeniXPro> davidhouse, thats also dependant on the algorithm
04:28:06 <neologism> thinking functional is easier Id say
04:28:36 <GeniXPro> thinking functional takes experience, since we are all men who can't multitask
04:28:43 <TuringTest> Lemmih: This was the solution:
04:28:43 <TuringTest> vals = $(let re = ["!abc","!def"] in liftM ListE ( sequence [ [| ( $(parseRegexp s), s ) |] | s <- re ] ) )
04:28:52 <neologism> GeniXPro: I can multitask :)
04:28:55 <davidhouse> jethr0_: how long does the transitional period last?
04:29:05 <TuringTest> Which begins to be hard for humans to read...
04:29:05 <GeniXPro> i can too, but i was making fun of you
04:29:15 <xerox> davidhouse: :info Ordering
04:29:36 <davidhouse> :info Ordering
04:29:39 <jethr0_> depends how actively you write functional programs and how much effort you put into learning new ways of approaching problems. but a few weeks at least
04:29:46 <davidhouse> oh, in ghci. hehe
04:29:56 <davidhouse> xerox: nice, thanks
04:29:59 <neologism> most programmers do code functionally even in imperative langauges
04:30:31 <jethr0_> neologism: i wouldn't be sure about the "most" part
04:30:54 <neologism> most functional programmers I ment
04:31:00 <jethr0_> true
04:31:04 <GeniXPro> most modern languages are multi-parigram
04:31:10 <jethr0_> davidhouse: what have you been working on?
04:31:18 <GeniXPro> With a some bias towoards one parigram or the other
04:31:28 <neologism> GeniXPro: like asm? :)
04:32:07 <GeniXPro> neologism, asm isn't a language, its a hell
04:32:24 * neologism imagines functional asm ;)
04:32:50 <mauke> .oO( ploki )
04:32:52 <GeniXPro> PUSH FUNCTION PUSH PUSH MULT POP
04:32:54 <jethr0_> GeniXPro: although i understand what you're referring to, lisp is one of the first languages and is one of the most multi-paradigm, while C++ for example isn't very friendly for functional programmers...
04:32:59 <davidhouse> jethr0_: my question was just born out of some frustration really. i can solve problems in haskell, it just takes longer than i would like. to give some examples of what i've been trying: (nothing particularily interesting) solving connect 4 and converting decimal to roman numerals
04:33:10 <Lemmih> TuringTest: Really?
04:33:16 <TuringTest> :)
04:33:31 <TuringTest> parseRegexp:: String -> ExpQ
04:33:42 <GeniXPro> jethr0_, an experienced c++ programmer can program functionally without much effort, but because of its c background, it is biased towoards imperitvness
04:33:57 <neologism> davidhouse: what is connect 4 ?
04:33:58 <TuringTest> vals :: [ ( GenParser Char Int () , String ) ]
04:34:19 <GeniXPro> connect 4 is 6x7 mnk-drop
04:34:30 <neologism> uh?
04:34:32 <TuringTest> Lemmih: Mixing list comprehension with [| |] brackets was the best touch
04:34:40 <jethr0_> GeniXPro: again i see what you're referring to and i've done it myself, but lacking _real_ anonymous functions or higher-order functions (not considering Boost here), it's more of a pain than a solution
04:34:49 <GeniXPro> mnk-drop, a variation of tic tac toe where you can only play at the bottom of a column
04:34:53 <jethr0_> and manual memory management isn't a good start for functional programming anyways
04:34:59 <davidhouse> neologism: it may go by alternative names. a 7 cols, 6 rows grid. you take turn to drop counters in one col, which goes to the lowest empty space in that col.
04:35:08 <neologism> ok... a game
04:35:11 <TuringTest> Lemmih: And the result works with parseTest -- I love refactoring in Haskell...
04:35:16 <davidhouse> you win by getting 4 counters in a row either vertically, diagonally or horizontally.
04:35:19 <neologism> davidhouse: go read "why functional programming matters"
04:35:31 <Lemmih> TuringTest: liftM ListE x => lift x => [| x |], right?
04:35:32 <TuringTest> (This was my first TH usage)
04:35:33 <davidhouse> neologism: yeah, i meant "playing connect 4" as opposed to "solving..."
04:35:35 <neologism> theres' a nice text about exactly this
04:35:40 <GeniXPro> davidhouse, heh heh yesterday i whipped up my tic tac toe game
04:35:50 <GeniXPro> the compiler errors are very consistant
04:36:01 <neologism> davidhouse: hysteria.sk/~neologism/whyfp.ps
04:36:32 <TuringTest> If x:: ExpQ then LiftM ListE x  :: ExpQ
04:36:42 <davidhouse> neologism: the gist?
04:36:43 <davidhouse> :)
04:37:00 <TuringTest> It turns a list of ExpQ into a an ExpQ of the list of ExpQ
04:37:28 <Lemmih> TuringTest: Oh, right.
04:37:35 <TuringTest> (using sequence in there)
04:37:38 <GeniXPro> i wrote my first haskell program yesturday. I find i worried too much on memory constraints or speed
04:38:14 <TuringTest> sequence [ ExpQ ]  become [Exp] then ListE [Exp] is an Exp which liftM returns as Q Exp
04:38:17 <GeniXPro> when in reality haskell runtime only proccesses things one at a time, unlike in my imperitive language where you would get all possible elements upfront and thn begin proccessing
04:38:22 <TuringTest> I think I understand my code...
04:49:16 <davidhouse> @pl \a b -> compare (length a) (length b)
04:49:16 <lambdabot> (. length) . compare . length
04:52:05 <ihope> davidhouse: that can't compare infinite lists with finite ones
04:52:11 <ihope> ...I think.
04:52:31 <GeniXPro> @x*x
04:52:31 <lambdabot> Unknown command, try @listcommands.
04:52:32 <davidhouse> ihope, i'm comparing finite strings, i'll get over it :)
04:52:39 <GeniXPro> @pl x*x
04:52:40 <lambdabot> x * x
04:52:42 <ihope> :-)
04:52:43 <GeniXPro> wow!
04:52:53 <ihope> @pl \x -> x*x
04:52:53 <lambdabot> join (*)
04:52:55 <davidhouse> @pl \x -> x*x
04:52:55 <lambdabot> join (*)
04:53:30 <GeniXPro> @pl \x y z -> (x+z)/y*z
04:53:31 <lambdabot> flip flip id . (liftM2 (*) .) . flip . ((/) .) . (+)
04:53:44 <ihope> compareLengths [] [] = EQ
04:53:58 <ihope> compareLength (_:_) [] = GT
04:54:06 <GeniXPro> @help pl
04:54:06 <lambdabot>  @pointless <expr> - play with pointfree code
04:54:14 <ihope> compareLengths [] (_:_) = LT
04:54:19 <GeniXPro> @help
04:54:19 <lambdabot>  @help <command> - ask for help for <command>
04:54:24 <GeniXPro> helpfull...
04:54:36 <ihope> compareLengths (_:xs) (_:ys) = compareLengths xs ys
04:54:50 <ihope> GeniXPro: looking for @listcommands?
05:03:52 <davidhouse> is there a shortcut function for \a b -> take a $ repeat b
05:03:59 <davidhouse> i find myself using it so stupidly much
05:05:19 <ndm> davidhouse, replicate
05:05:34 <integral> @pl \a b -> take a $ repeat b
05:05:35 <lambdabot> (. repeat) . take
05:05:42 <davidhouse> ndm, brilliant
05:05:44 <ndm> > replicate 5 'a'
05:05:45 <lambdabot> "aaaaa"
05:05:57 <davidhouse> @type \a b -> take a $ repeat b
05:05:58 <lambdabot> forall a. Int -> a -> [a]
05:06:03 <davidhouse> @hoogle Int -> a -> [a]
05:06:03 <lambdabot> Data.List.replicate :: Int -> a -> [a]
05:06:03 <lambdabot> Prelude.replicate :: Int -> a -> [a]
05:06:03 <lambdabot> Data.List.repeat :: a -> [a]
05:16:56 <ihope> @pl (\cycle x -> x ++ cycle x)
05:16:57 <lambdabot> ap (++)
05:17:00 <ihope> !
05:17:09 <ihope> So cycle = fix (ap (++))
05:17:14 <xerox> Is that really what you want?
05:17:27 <xerox> @type cycle
05:17:27 <lambdabot> forall a. [a] -> [a]
05:17:45 <xerox> @pl cycle xs = xs ++ cycle xs
05:17:45 <lambdabot> cycle = fix (ap (++))
05:17:48 <xerox> Right.
05:18:47 <palomer> cycle sounds evil
05:20:32 <ihope> > cycle "uni"
05:20:33 <lambdabot> "uniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
05:20:33 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
05:20:33 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
05:20:33 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
05:20:33 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
05:20:33 <xerox> > take (4*10) $ cycle "no, "
05:20:35 <lambdabot> [23 @more lines]
05:20:37 <lambdabot> "no, no, no, no, no, no, no, no, no, no, "
05:21:08 <ihope> > take (4*10) (cycle "no, ") ++ "no!"
05:21:09 <lambdabot> "no, no, no, no, no, no, no, no, no, no, no!"
05:22:03 <tibbe> :t replace
05:22:04 <palomer> how would cycle be useful?
05:22:08 <tibbe> @type replace
05:22:08 <lambdabot> Not in scope: `replace'
05:22:15 <tibbe> @index replace
05:22:16 <lambdabot> bzzt
05:22:34 <tibbe> @hoogle replace
05:22:35 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments.Replace :: TextureFunct
05:22:35 <lambdabot> ion
05:22:35 <lambdabot> Data.Array.Diff.replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray
05:22:35 <lambdabot> a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
05:22:35 <lambdabot> Graphics.UI.ObjectIO.CommonDef.replaceOrAppend :: Cond x -> x -> [x] -> [
05:22:37 <lambdabot> x]
05:23:09 <tibbe> I want to replace every occurence of a substring with another string. Where can I find a replace function or some regexps
05:23:14 <tibbe> @index regexp
05:23:14 <lambdabot> bzzt
05:23:21 <sili-w-birdflu> haha
05:23:33 <sili-w-birdflu> funny bot.
05:23:56 <ihope> palomer: (sequence_ . cycle) [putStrLn "To see how an idiot spends his time, press enter.", getLine]
05:24:17 <Korollary> @doc Text.Regex
05:24:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.
05:24:17 <lambdabot> html
05:24:49 <xerox> @type (Control.Monad.sequence_ . cycle)
05:24:50 <lambdabot> forall (m :: * -> *) a.
05:24:50 <lambdabot>              (Monad m) =>
05:24:50 <lambdabot>              [m a] -> m ()
05:28:13 <palomer> the only IO I've ever done is with GTK
05:28:16 <palomer> quite odd:o
05:28:23 <xerox> :D
05:36:25 * tibbe gets really nervous when when he types something like foldl (\op str -> subRegex (mkRegex ("\\" ++ op)) str (paren op)) cs infixOps and the type checker doesn't complain.
05:36:46 <xerox> Enjoy the feeling.
05:38:22 <tibbe> infinite loop, great
05:38:51 <tibbe> @where fold
05:38:51 <lambdabot> I know nothing about fold.
05:39:32 <tibbe> how can I take a string with operators (+, -, *, /, == etc) and put parens around all the ops?
05:40:11 <xerox> Maybe I could give it a try.
05:40:13 <ndm> tibbe: parse it, then write it out with ops
05:40:46 <tibbe> yeah
05:42:15 <tibbe> I was too lazy to write another set of show functions only to get that slight variation for my AST
05:42:29 <tibbe> i.e. I have a show that prints without the ()
05:42:59 * xerox stops the try
05:46:26 <sili-w-birdflu> this tutorial asks how to extract 'a' from ((1,'a'),"foo") using fst and snd, but doesn't give an answer -- how do you do it?
05:46:54 <mauke> > snd (fst ((1,'a'),"foo"))
05:46:55 <lambdabot> 'a'
05:47:55 <tibbe> gahd, it shouldn't be that hard to replace every occurence of a with (a) in a string!
05:48:21 <sili-w-birdflu> mmm i see.
05:48:27 <sili-w-birdflu> mauke: freak.
05:48:29 <xerox> Only one-letter identifiers, tibbe?
05:48:39 <mauke> > let f 'a' = "(a)"; f x = [x] in concatMap f "harbl"
05:48:40 <lambdabot> "h(a)rbl"
05:48:51 <xerox> I was about ;-)
05:50:21 <tibbe> xerox, no, substrings
05:50:40 <Korollary> Try MissingH.Str
05:50:51 <tibbe> @type MissingH.Str
05:50:52 <lambdabot> Couldn't find qualified module.
05:50:52 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
05:50:52 <lambdabot> \\)?
05:50:59 <Korollary> it's not standard
05:57:18 <sili-w-birdflu> so in   read "Hello" + 3    read "Hello" is evaluated, then that value is added to 3?
05:57:34 <mauke> > read "Hello" + 3
05:57:35 <lambdabot> Exception: Prelude.read: no parse
05:57:54 <sili-w-birdflu> fine, read "5" + 3
05:58:32 <mauke> yeah, that's 8
05:59:00 <sili-w-birdflu> and read "5" happens first, right?
05:59:08 <mauke> maybe
05:59:13 <sili-w-birdflu> :(
05:59:17 <mauke> why?
05:59:29 <sili-w-birdflu> i dunno. how does it happen?
05:59:53 <mauke> I'd guess the evaluation order is undefined, as in C
06:00:07 <mauke> except Haskell doesn't evaluate anything until it needs the value
06:00:15 <sili-w-birdflu> eh
06:00:21 <sili-w-birdflu> i was thrown off by some stuff. nevermind
06:00:34 <ibid> acctually, in c it's unspecified, not undefined
06:00:50 <mauke> heh, ok
06:01:10 <ibid> and certainly in read "Hello" + 3, read "Hello" happens before the addition, as there's a data dependency there
06:02:17 <xerox> Hmm.
06:02:59 <ihope> > read "5" + 3
06:03:00 <lambdabot> 8
06:03:25 <ibid> also with read "5" :)
06:03:31 <ihope> > read "5"
06:03:31 <lambdabot> Add a type signature
06:03:37 <ihope> > read "5" :: Num a => a
06:03:37 <lambdabot>  add (Read a) to the expected type of an expression
06:03:37 <lambdabot>   In the expression: read "5" :: (Num a) => a
06:03:37 <lambdabot>   In the definition of `gmv': gmv = read "5" :: (Num a) => a
06:03:48 <ihope> > read "5" :: Num a, Read => a
06:03:49 <lambdabot>  parse error on input `,'
06:03:53 <ibid> read "5":: Int
06:03:58 <ibid> > read "5":: Int
06:03:59 <lambdabot> 5
06:04:04 <ihope> Well, that's no fun!
06:04:06 <ihope> > read "5" :: (Num a, Read a) => a
06:04:07 <lambdabot> 5
06:10:11 <ihope> There's nothing like a good game of Progress Quest while playing Idle RPG.
06:22:24 <ihope> Somebody give me three prime numbers, none of which end in 1, 3, 7 or 9.
06:23:09 <palomer> @hoogle mapM_
06:23:10 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
06:23:10 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
06:23:10 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
06:23:17 <sili-w-birdflu> 400200041      400200061      400200067 
06:25:01 <Lemmih> ihope: 0xe5
06:25:19 <ihope> Heh.
06:25:36 <xerox> The olympic closing event is going on right now, there is a stream if you want to see it ;-)
06:26:01 <xerox> It popped up a nude guy before when someone was talking, haha.  They pulled him offstage instantaneously.
06:26:10 <ihope> Okay. If you're going to use hexadecimal, then it's two primes not ending in 1, 3, 5, 7, 9, B, D, or F.
06:27:05 <jethr0_> how can i export everything defined in a module plus some imported modules?
06:27:28 <jethr0_> "module X (.., Control.Monad(..)) where" didn't work
06:29:42 <Cale> list everything explicitly?
06:29:56 <jethr0_> hmm, how would i export _everything_?
06:30:11 <xerox> Without writing a clause of what is exported.
06:30:24 <ndm> jethr0_: module X (module Control.Monad, ...) where
06:30:37 <jethr0_> ah, 3 points, hmm
06:30:37 <jethr0_> thx
06:30:48 <xerox> Uh, I didn't knew you could, cool.
06:31:33 <ndm> jethr0_: the tree points is just a typo :)
06:31:52 <xerox> ...
06:32:14 <jethr0_> so for exporting everything declared/defined, i use "(module Control.Monad, ..)"?
06:32:25 <ndm> yes, i think so
06:37:03 <ihope> @botsnack
06:37:03 <lambdabot> :)
06:37:12 <ihope> Hmm. Who needs a botsnack when...
06:37:17 <ihope> @karma+ lambdabot
06:37:17 <lambdabot> lambdabot's karma raised to 11.
06:37:43 <palomer> $ is the best thing to happen to haskell
06:37:58 <nom> $?
06:38:03 <xerox> Dollars.
06:38:09 <sili-w-birdflu> what's $
06:38:12 <ihope> I like some uses of it and despise others.
06:38:20 <ihope> a $ b = a b
06:38:25 <nom> It's not 98, is it?
06:38:35 <ihope> infixr 0 $
06:38:49 <Lemmih> nom: It is.
06:39:45 <ihope> I like things like zipWith ($). I don't like things like foo . bar $ baz.
06:39:58 <nom> What's it do?
06:40:13 <ihope> It's the apply operator.
06:40:26 <ihope> > not $ True
06:40:27 <lambdabot> False
06:40:44 <nom> hm
06:40:52 <ihope> Due to its low fixity, it's often used rather like parentheses:
06:40:59 <ihope> > (not . not) True
06:41:00 <lambdabot> True
06:41:06 <ihope> > not . not $ True
06:41:07 <lambdabot> True
06:41:15 <nom> Ah
06:41:40 <nom> I'm guessing it's not that commonplace? Or have I just missed it? 
06:41:44 <nom> I'm fairly new :o
06:41:58 <ihope> Yeah, you just missed it, I guess.
06:42:07 <ihope> It's "sort of" common.
06:42:11 <ihope> Some use it, some don't.
06:42:53 <palomer> ihope: why don't you like a . b $ c ?
06:43:11 <ihope> Well...
06:43:16 <xerox> I'ts cool when you have many combinators.
06:43:34 <xerox> . is more light-view than $
06:43:50 <ihope> I guess it's because of it has a low precedence level, or whatever.
06:45:10 <palomer> but?
06:45:54 <sili-w-birdflu> length (filter Char.isUpper "aBCdR") # simple, but i think i'm starting to like haskell
06:46:52 <palomer> > length (filter Char.isUpper "aBCdR")
06:46:53 <lambdabot> 3
06:48:32 <GeniXPro> All haskell code is clever
06:49:32 <ihope> What about gold-plating?
06:58:16 <jyp> ihope: gold-plating?
06:59:10 <ihope> Implementing language A in language B in order to reach a feature from A in B.
06:59:39 <ihope> http://c2.com/cgi/wiki?GoldPlating
07:17:06 <imix> does anyone have a little time to help me with a problem concerning sockets and TChan?
07:23:27 <Lemmih> imix: Pose your question and we'll see.
07:25:07 <imix> i have a small program that reads from a socket and passes the data on a TChan. When I use hReady, it only reads/writes (not sure which) on the TChan when I send ETX on the socket.
07:25:16 <lisppaste2> imix pasted "socket TChan problem" at http://paste.lisp.org/display/17252
07:26:26 <palomer> http://www.rafb.net/paste/results/dBMZoW83.html
07:26:59 <palomer> http://www.rafb.net/paste/results/Qb388D35.html
07:27:22 <palomer> oh, wait, I understand
07:27:29 <palomer> I have to reverse the order
07:28:01 <Lemmih> imix: Have you asked that question before? I'm having a funny deja vu feeling.
07:29:01 <imix> i discussed the problem with Cale some days ago, but then I had no clue where it was from
07:29:23 <imix> now i know that it has to be related with the hReady. When I remove it, it works as expected
07:30:14 <imix> the program i pasted is the smallest subset of what i do in my program that shows the same behaviour
07:31:05 <astrolabe> Is the haddock generated documentation the best place to find out about StateT?
07:31:43 <Lemmih> @docs Control.Monad.State
07:31:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.
07:31:44 <lambdabot> html
07:32:09 <Lemmih> Looks kinda dull.
07:32:37 <Lemmih> Don't know any better place, though.
07:34:10 <xerox> @google all about moands
07:34:11 <lambdabot> http://www.geocities.com/TimesSquare/Portal/8632/inanimae.html
07:34:12 <xerox> @google all about monads
07:34:14 <lambdabot> http://www.nomaware.com/monads/
07:34:15 <xerox> Sorry :-)
07:34:21 <xerox> It has nifty specific tutorials.
07:35:51 <dan> ok i have downloaded the Network.HTTP where do I put in GHC directory structure ?
07:36:29 <dan> if i put in under NETWORK it dosen't seem to find it when I import it
07:36:31 <Lemmih> dan: You don't.
07:36:41 <dan> Lemmih ok ?
07:36:45 <dan> Lemmih please go on
07:36:57 <Lemmih> Did you build it with Cabal?
07:37:10 <dan> I didn't build it Lemmih i'm on a windows machine
07:37:22 <dan> however if i just place it with my program and use import it works
07:37:44 <astrolabe> Thanks Lemmih, xerox.
07:38:47 <Lemmih> dan: You can do two things: Install it or just use it as any other module you have.
07:39:01 <dan> Lemmih what's the difference ?
07:39:57 <dan> one is for dynamic linking ?
07:40:52 <Lemmih> If you install it then you can use it from other Haskell programs.
07:41:22 <dan> Lemmih and to install it i need to build it with cabal ?
07:41:24 <Lemmih> (and people with it install can't use your code if just copy it)
07:41:41 <Lemmih> dan: Yep. Cabal is distributed with GHC, btw.
07:41:52 <dan> i see k
07:41:55 <dan> thanks lemmih
07:42:10 <icbt> howdy, Lemm
07:42:32 <Lemmih> Hiya, ic (:
07:43:14 <sethk> hey, all.  I want to use hGet/PutBuf for possible performance improvement.  The docs describe how to use its type, Ptr a, with the FFI.  But there is no FFI in use in this code.  I'm not sure how to define a buffer for hSetBuf/hPutBuf
07:43:17 <sethk> any ideas?
07:44:15 <icbt> sethK, checkout Peter Simon's "fast i/o in haskell" paper
07:44:38 <sethk> icbt, should I google for the URL?
07:44:57 <icbt> lem, do you use HXT?
07:45:14 * xerox is becoming tired of using 'google' as a synonym for 'search', I mean, there OUGHT to be at last ONE ANOTHER good search engine.
07:45:17 <Lemmih> sethk: Do you need to use the result of hGetBuf or just pass it to hPutBuf?
07:45:26 <icbt> cryp.to/blockio/
07:45:30 <Lemmih> ic, nope.
07:45:53 <icbt> so haxml is still the standard then
07:45:58 <xerox> (For example, clusty.com seem to do quite a nice job.  Especially wikipedia-wise.)
07:46:06 <stesch> Peter Simon? The Amiga guy?
07:46:08 <sethk> Lemmih, if I can use hGetBuf with a socket then I can pass the data to hPutBuf
07:46:21 <stesch> Of PGP fame?
07:46:53 <sethk> hmm, google showed me another interesting library.  But for later ... I don't want to change everything at once.
07:47:00 <Lemmih> sethk: You can allocate a buffer with alloca or malloc.
07:47:09 * xerox feels lonely
07:47:26 <sethk> Lemmih, you mean I have to use ffi and make a call to a C library function?
07:47:44 <Maddas> xerox: I've learned to not hug you lightheartedly...
07:48:02 * Maddas waves to xerox from a distance
07:48:03 <Lemmih> sethk: Well, yes. hGetBuf and hPutBuf are pretty much just C calls.
07:48:23 * xerox looks innocently and waves back to Maddas 
07:48:25 <stesch> stesch: Google says yes. It's the Amiga guy.
07:48:27 <sethk> Lemmih, I was hoping to be able to use it without having to figure out how ffi works, but maybe that doesn't make sense
07:49:33 <Lemmih> sethk: You don't need to grasp how the entire FFI works. Figuring out how to allocate a buffer should do.
07:50:01 <sethk> Lemmih, I'm not worried about grasping it, really.  I was trying to avoid figuring out the mechanics
07:50:13 <sethk> Lemmih, but if it can't be done, then it can't be done
07:50:24 <sethk> Lemmih, I'm just being lazy, basically
07:50:32 <sethk> but, after all, it _is_ a lazy language
07:51:08 <Lemmih> It's OK to be lazy. The word 'FFI' covers a lot and you only want a small part of it.
07:51:25 <sethk> Lemmih, yes, k
07:52:37 <Lemmih> You just have to use a function from Foreign which is just like any other Haskell library.
08:25:20 <dan> does anyone here have experience with Network.HTTP ?
08:25:27 <dan> i am really stuck and google isn't helping
08:28:53 <xerox> What about it?
08:31:13 <xerox> dan: any luck?
08:40:08 <dan> xerox i think i just forgat to much haskell for it to be of any use to me argh
08:40:18 <dan> xerox getting really frustrated here
08:40:24 <xerox> :-\
08:40:33 <dan> xerox i know cause i've made a few programs befre
08:40:35 <dan> xerox brb 
08:40:41 <dan> xerox need to clear my head
08:40:51 <xerox> Have fun.
08:41:24 <ihope> Does the FFI give IO values?
08:42:16 <xerox> Yep.
08:45:28 <dan> xerox may i msg you in private ?
08:46:22 <xerox> You can ask you here too, you have more chances to get a good answers.
08:46:24 <xerox> But as you please.
08:46:59 <dan> i see ok
08:47:06 <dan> it's more of syntax thing
08:47:19 <dan> i'm trying to use simpleHTTP fuction from this module http://www.haskell.org/http/api/Network.HTTP.html
08:47:22 <xerox> Right.
08:47:37 <dan> it requires simpleHTTP :: Request -> IO (Result Response)
08:47:59 <dan> request is http://www.haskell.org/http/api/Network.HTTP.html#t%3ARequest
08:48:09 <xerox> Yes.
08:48:15 <dan> how do i make a properly structured request ?
08:48:17 <dan> type
08:48:57 <xerox> It's rather simple.
08:49:12 <dan> i'm sure it will be once i understand it :)
08:49:27 <xerox> http://haskell.galois.com/~paolo/darcs/woopee/Woopee.hs
08:49:32 <xerox> See "request"
08:49:32 <dan> it's been about 2 years since i used haskell
08:49:37 <dan> xerox ok brb
08:50:27 <xerox> The idea is |value = Request { field = .., field = .., .. }|.
08:51:14 <dan> xerox i will be asking rather newbie haskell questions...
08:51:15 <dan>  rqURI = fromJust . parseURI $ "http://images.google.com/images?q=" ++ w ++
08:51:15 <dan>                                   "&svnum=10&hl=en&lr=&sa=N&imgsz=xxlarge",
08:51:23 <dan> what is fromJust ?
08:51:32 <xerox> fromJust :: Maybe a -> a
08:51:38 <xerox> fromJust (Just x) = x
08:51:48 <xerox> fromJust Nothing = error "Nothing"
08:52:05 <dan> i've seen fromMaybe what's that for ?
08:52:15 <xerox> @hoogle fromMaybe
08:52:15 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
08:52:20 <xerox> It has a defalut value
08:52:31 <xerox> > Data.Maybe.fromMaybe 0 (Nothing)
08:52:32 <lambdabot> 0
08:52:36 <xerox> > Data.Maybe.fromJust (Nothing)
08:52:37 <lambdabot> Add a type signature
08:52:40 <xerox> > Data.Maybe.fromJust (Nothing) :: ()
08:52:41 <lambdabot> Exception: Maybe.fromJust: Nothing
08:52:54 <dan> parseURI :: String -> Maybe URI
08:52:58 <xerox> In fact it's safer, if you have time to write a patch for woopee, I'll surely accept it.
08:53:02 * esap thinks fromJust is evil. I'd like all functions to be total.
08:53:22 <astrolabe> it is total
08:53:39 <astrolabe> You mean, you don't want run time errors?
08:53:42 <dan> xerox so parseURI takes a string and return Maybe URI
08:53:48 <dan> ?
08:53:53 <esap> I mean, I don't want run-time errors that can't be caught.
08:54:32 <dan> @hoogle parseURI
08:54:32 <lambdabot> Network.URI.parseURI :: String -> Maybe URI
08:54:32 <lambdabot> Network.URI.parseURIReference :: String -> Maybe URI
08:54:34 <xerox> dan: yes.
08:54:40 <astrolabe> But it is wrong to catch an error due to a coding mistake.
08:54:49 <dan> @hoogle Maybe
08:54:49 <lambdabot> Data.Maybe.Maybe :: Maybe a
08:54:49 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
08:54:49 <lambdabot> Prelude.Maybe :: Maybe a
08:55:19 <esap> astrolabe: true. But why provide a library function that allows you to make that mistake?
08:55:22 * jethr0_ is making SLOOOOOOW progress with yampa
08:55:47 <xerox> data Maybe a = Just a | Nothing
08:55:49 <dan> xerox so could you explain in plain english what this does ?  rqURI = fromJust . parseURI $ "http
08:56:30 <xerox> dan: yes.  rqURI is filled with the URI returne from parseURI on that string.
08:56:38 <astrolabe> @eval 1/0
08:56:39 <lambdabot> Infinity
08:56:46 <xerox> It's just like fromJust (parseURI "http://..").
08:56:46 <astrolabe> hmm
08:57:19 * xerox foresees another night of Infinity talkings :-)
08:57:22 <astrolabe> esap: so how would you define head [] ?
08:57:26 <dan> xerox i see so . is a short form for brackets ?
08:57:38 <esap> astrolabe: As a compile-time error.
08:57:48 <xerox> dan: in a certain sense.  It is function composition.  (f . g) x = f (g x)
08:57:48 <jethr0_> xerox: count me in on the infinite chaos
08:57:55 <Maddas> :-)
08:58:00 <xerox> Or if you prefer, f . g = \x -> f (g x)
08:58:22 <esap> astrolabe: I mean, head has the same problem.
08:58:22 <astrolabe> esap, I mean if you don't know that the list is [] at compile time.
08:58:32 <danols> xerox woahhh i remember vagualy all you are telling me; man i used to comperhend all the notations better
08:58:45 <ndm> sounds like you are asking for catch, that detects if head is safe at compile time
08:58:49 <esap> astrolabe: Then the programmer should be required to check for the empty case.
08:59:00 <xerox> danols: wordy explanation: it composes two unary functions feeding one with the result of the other, in a left-to-right order.
08:59:01 <palomer> safe head can be easily done with dependent types
08:59:11 <palomer> a little protection goes a long way
08:59:25 <ndm> CATCH = http://www-users.cs.york.ac.uk/~ndm/projects/catch.php
08:59:28 <palomer> err, I meant generalised algebraic datatypes
08:59:30 <ndm> @where+ catch http://www-users.cs.york.ac.uk/~ndm/projects/catch.php
08:59:30 <lambdabot> Done.
08:59:33 <xerox> danols: if you get overwhelmed by the others talking there is #haskell-overflow where can we overflow safely :-)
09:00:02 <astrolabe> esap: but if he 'knows' that it isn't empty, that's a waste of effort.
09:00:25 <astrolabe> Sorry xerox, danols
09:00:34 <xerox> astrolabe: no problem at all.
09:00:43 <esap> astrolabe: If he knows it, then why doesn't he write it in the program. If it's not possible to express that in the program, then the language is broken.
09:00:43 <xerox> astrolabe: I made #haskell-overflow for a reason :-)
09:01:08 <ndm> esap, if you can express non-terminating programs, does that make your language broken?
09:01:14 <astrolabe> Yeah.  You should use it.  It's getting cobweby.
09:01:21 <esap> ndm: no.
09:01:35 <ndm> esap, so why is non-termination ok, but pattern match failure not?
09:01:40 <ndm> they are both semantically bottom
09:02:02 <GeniXPro> will ['a'..] give me a list with all the charecters including and procedding a?
09:02:07 <danols> k xerox i'm going to haskel-overflow
09:02:15 <xerox> danols: great.
09:02:22 <esap> ndm: because pattern match failures are not undecidable for a type system.
09:02:31 <ndm> esap, in general, they are
09:02:32 <astrolabe> esap: The reason that the list is not empty might be the result of a complicated mathematical theorem.  It is impossible for the compiler to verify such a thing.
09:03:07 <ndm> head (if terminates x then [1] else []) -- woohoo, solving the halting problem :)
09:03:21 <astrolabe> @eval ['a'..]
09:03:22 <lambdabot> "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\
09:03:22 <lambdabot> 137\138\139\140\141\142\143\144\145\146\147\148\149\150\151\152\153\154\
09:03:22 <lambdabot> 155\156\157\158\159\160\161\162\163\164\165\166\167\168\169\170\171\172\
09:03:22 <lambdabot> 173\174\175\176\177\178\179\180\181\182\183\184\185\186\187\188\189\190\
09:03:22 <lambdabot> 191\192\193\194\195\196\197\198\199\200\201\202\203\204\205\206\207\208\
09:03:24 <lambdabot> [24 @more lines]
09:03:27 <esap> ndm: I'm not against run-time boolean checks, which contain complex conditions.
09:03:48 <ndm> esap, but if you aren't against that, how can you be for complete cases?
09:04:35 <astrolabe> GeniXPro: It won't give the ones preceding 'a'.
09:04:37 <esap> ndm: I'm suggesting the problem with undecidability should be confined to the really undecidable parts of the language.
09:04:46 <GeniXPro> astrolabe, not important :)
09:05:04 <esap> ndm: Completeness of patterns that do not use complex boolean conditions are not undecidable.
09:05:29 <ndm> esap, yes, but general pattern completeness is undecidable - its equivalent to the halting problem
09:06:48 <esap> ndm: making fromJust safe is not equivalent to the halting problem, I believe.
09:07:17 <ndm> you can always demand all patterns are complete (Turner does so in Total Functinoal Programming)
09:07:31 * astrolabe is undecided
09:07:32 <jethr0_> ndm, you can react to a failed pattern match, but you can't react to non-termination!
09:07:44 <ndm> but determining which patterns can raise errors precisely is impossible
09:07:59 <ndm> jethr0_: CATCH is the project i'm working on - case and termination checker for haskell
09:08:06 <ndm> it does both :)
09:08:24 <esap> The thing is, you don't want to determine which patterns can raise errors. You want to enforce that the programmer checks all cases that can possibly raise.
09:08:31 <jethr0_> ndm: but termination is definitely undecidable. maybe i'll drop by your project page sometime
09:08:45 <ndm> jethr0_: they are both definately undecidable :)
09:08:52 <ndm> esap, yes - and thats what my thing does
09:09:06 <esap> ndm: "your thing"?
09:09:11 <ndm> esap: CATCH
09:09:25 <ndm> it detects which patterns are definately safe, for example uses of head where the expression is a :
09:09:34 <ndm> and only flags those which can't be proved
09:09:34 <esap> ndm: ah ok, almost missed that.
09:10:03 <ndm> but i think if you put it in the language then you limit yourself to dependant types, and thats not required for htis problem
09:12:27 <sili-w-birdflu> i'm reading a tutorial and it has an example of "exponent a 1 = a" but I get an error saying "<interactive>:1:13: parse error on input `='" using GHC. can anyone help me figure out what the problem is?
09:12:55 <ihope> Type it into a file and load that into GHCi.
09:13:04 <esap> what's the part of patterns that cause the undecidability trouble? I'd expect it's the ability to compute things like sums that take two inputs and combine them in complex ways.
09:13:37 <ndm> case terminating x of {True -> True}
09:13:46 <ndm> if x is terminating, then you don't get a case error
09:13:57 <ndm> if its not, you do
09:14:05 <esap> ndm: I'd always flag that as an error.
09:14:07 <ndm> hence for the compiler to detect, it must solve the halting problem
09:14:12 <sili-w-birdflu> ihope: does ghci  not support function definitions?
09:14:16 <ndm> esap, yes, but then you are not accurately detecting it
09:14:24 <ndm> sili-w-birdflu: let def = value
09:14:26 <ihope> Oh, right.
09:14:41 <esap> ndm: that's true. You shouldn't try to solve the halting problem. Approximation is required there.
09:15:10 <ndm> esap, but that means you have no exact idea where to draw the line
09:15:11 <astrolabe> sili-w-birdflu: try using let before the expression
09:15:25 <ndm> i.e. if its in the language standard, then exactly what do you allow
09:15:35 <sili-w-birdflu> astrolabe: i will, but what is the problem?
09:16:06 <esap> ndm: My idea is that undecidability should be triggered by primitive computations that take two inputs and produce one output.
09:16:18 <esap> ndm: Like sum and product of two integers.
09:16:27 <ihope> Whoa!
09:16:30 <astrolabe> sili-w-birdflu: I think ghci doesn't accept definitions except from files ( or maybe if precided by let).
09:16:43 * ihope solves the halting problem
09:16:52 <ndm> esap, please explain more about primitives?
09:16:52 <esap> ndm: when you then use it as a condition for the pattern match.
09:17:08 <esap> ndm: s/then/them/
09:17:08 <ndm> so give an example of what would be accepted, and what would not (the boundary cases)
09:17:31 <astrolabe> ihope: congrats
09:18:28 <ndm> ihope, please send the solution to the mailing list :)
09:18:33 <ihope> :-)
09:18:41 <ndm> esap, any idea of what the boundary of what is accepted and what would not be in your system?
09:18:48 <ihope> Let's see here..
09:19:04 <esap> ndm: f x y | True <- is_inside_mandelbrot_set x y = ...  this would clearly be beyond capabilities of most compilers.
09:19:09 <ihope> type NT a b = a -> Either a b
09:19:31 <ihope> @djinn-add type NT a b = a -> Either a b
09:19:40 <ihope> @djinn NT a b -> NT b c -> NT a c
09:19:41 <lambdabot> f a b c =
09:19:41 <lambdabot>   case a c of
09:19:41 <lambdabot>   Left d -> Left d
09:19:41 <lambdabot>   Right e -> case b e of
09:19:41 <lambdabot>      Left _ -> Left c
09:19:43 <lambdabot>      Right f -> Right f
09:20:03 <ndm> esap, what about f x y | True <- null (x ++ y), and it turns out that in all situations either x or y is not null in teh callee
09:20:15 <ndm> or they both are null
09:20:26 <danols> lisppaste: url
09:20:26 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:20:29 <ihope> @djinn (a -> b) -> NT a b
09:20:29 <lambdabot> f a b = Right (a b)
09:20:40 <ihope> @djinn NT a b -> NT (a,c) (b,c)
09:20:40 <lambdabot> f a (b, c) =
09:20:40 <lambdabot>   case a b of
09:20:40 <lambdabot>   Left d -> Left (d, c)
09:20:40 <lambdabot>   Right e -> Right (e, c)
09:21:02 <lisppaste2> danols pasted "http module testing" at http://paste.lisp.org/display/17256
09:21:24 <lennart> ihope: nice to see the djinn spitting out code :)
09:21:25 <danols> cool
09:21:53 <ihope> Let's see here...
09:22:06 <esap> ndm: Null checks may be one of the more difficult cases [I think Rice's theorem goes into effect there]
09:22:24 <ndm> esap, well my system already solves those cases easily
09:23:43 <ihope> (a -> Either a b) -> (b -> Either b c) -> a -> Either a c
09:23:46 <esap> ndm: checking for emptiness is a difficult problem, because once the expression that produces the expression that is checked for emptiness becomes expressive enough, emptiness check is undecidable.
09:24:03 <ihope> If the first function returns a Right but the second returns a Left...
09:24:09 <ndm> esap, indeed - it doesn't check in all circumstnaces, but it often does
09:24:54 <lennart> ihope: you can always ignore the first two functions
09:25:24 <ihope> !djinn-del NT
09:25:38 <ihope> lennart: but I don't want to...
09:27:47 <lennart> no, but djinn can't read your mind :)
09:28:46 <esap> ndm: The trick is to find the cause of the undecidability. Of course, this requires detailed analysis of the type system
09:29:01 <ndm> esap: my checker is typeless :)
09:29:32 <esap> ndm: heh. does it do the check at run-time? :-)
09:29:49 <ndm> esap, no, its a static analysis
09:30:04 <GeniXPro> http://www.rafb.net/paste/results/fGuo4X45.html - - This is odd. Although i'm labelling "play_moves" as returning an [(Int, Int, Int)], it seems to be interprestting it differently
09:30:28 <GeniXPro> oop i just figured it out
09:31:11 <esap> ndm: Maybe it's just me, but I'd expect that a static analysis would need to manipulate type information.
09:31:32 <ndm> esap, so does everyone else, but indeed i've done it without types
09:31:47 <esap> ndm: Since types would encode the constraints that are visible when the static check is done.
09:32:17 <ndm> esap, i have an alternative case constraint representation
09:32:35 * ihope joins the "generalize arrows" movement
09:33:20 <esap> ndm: Do you have some details I could look at?
09:33:28 <ndm> @where catch
09:33:28 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/catch.php
09:33:37 <ndm> there is a paper there
09:33:52 <ndm> and i will have another paper in a few weeks, and an implementation in about a month
09:34:05 <esap> ndm: thanks for the link.
09:35:00 <ihope> Aha!
09:35:47 <ihope> Um...
09:35:54 <ihope> Yeah!
09:37:41 <danols> @type Result
09:37:42 <lambdabot> Not in scope: data constructor `Result'
09:39:53 <esap> ndm: the paper looks cool.
09:41:49 <GeniXPro> how would i get show 'a' not to show 'a' with quotes? I just want a
09:42:17 <Lemmih> You don't.
09:43:22 <wilx> > show 'a'
09:43:23 <lambdabot> "'a'"
09:43:26 <GeniXPro> There is no way
09:43:26 <wilx> :)
09:43:27 <wilx> Hm.
09:43:36 <lennart> > 'a'
09:43:37 <lambdabot> 'a'
09:44:02 <lennart> GeniXPro: No, there's no way.
09:44:11 <Lemmih> It's kinda like asking how to get (-) to multiply instead of subtract.
09:44:28 <lennart> But why would you want to change show for 'a'
09:45:11 <GeniXPro> because i'm using ['a'..] to get a continuous list of characters that i can print to the screen
09:45:22 <GeniXPro> I don't think ["a" ..
09:45:24 <Lemmih> > let showChar = (:[]) in showChar 'a'
09:45:25 <lambdabot> "a"
09:45:38 <lennart> Ah, you want to print it!
09:45:47 <lennart> > putStr ['a'..]
09:45:48 <lambdabot> No IO allowed
09:46:14 <GeniXPro> well i'm trying to keep the io out of this portion of the code
09:46:39 <lennart> So just return the list of characters, and do a putStr when you want to
09:51:01 <tennin> showy_id_char :: Char -> Char
09:51:08 <tennin> showy_id_char = (!! 1) . show
09:51:19 <ihope> Lemmih: return
09:51:28 <ihope> That is, showChar = return
09:51:31 <Lemmih> ihope: (:[]) is prettier.
09:51:59 <Lemmih> Now, if you could write return with smiley in it... (:
09:53:10 <ihope> Well, there's {-: blah blah :-}
09:55:01 <Lemmih> Wow, that's great. Haven't thought about that before. I'll definitely wrote some of those from now on. (:
09:56:12 <ihope> > (: [] :)
09:56:13 <lambdabot>  parse error on input `)'
09:56:16 <ihope> Aww.
09:56:42 <ihope> @index (>:)
09:56:43 <lambdabot> bzzt
09:56:48 <ihope> @index (:>)
09:56:49 <lambdabot> bzzt
09:56:52 <ihope> @index (:<)
09:56:52 <lambdabot> bzzt
09:56:58 <ihope> @index (<:)
09:56:59 <lambdabot> bzzt
09:58:13 * Lemmih feels like doing a smiley IOHCC entry.
09:58:33 <dons> @type ((((((((((((((((([] :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :)
09:59:22 <dons> a language of these things would be a good S S Z'th IOHCC entry.
09:59:34 <dons> hmm, looks like thee type checker is having trouble..
09:59:47 <ihope> http://www.teuton.org/~stranger/code/emoticon/emoticon.html
09:59:50 <ihope> You mean that?
10:01:06 <lambdabot> forall a.
10:01:06 <lambdabot>                          [[[[[[[[[[[[[[[[[[a]]
10:01:06 <lambdabot>                               -> [[a]]]
10:01:06 <lambdabot>                               -> [[[a]]
10:01:06 <lambdabot>                                -> [[a]]]]
10:01:08 <lambdabot> [131068 @more lines]
10:01:19 <dons> good bot!
10:01:33 <dons> only took 3 minutes :)
10:02:02 <ihope> 131068?
10:02:25 <ihope> Obsessive-compulsive line-breaking, I think.
10:02:25 <dons> 131068!
10:02:47 <dons> the ghc pretty printer likes to be pretty.
10:02:48 <ihope> @more
10:02:49 <lambdabot>                               -> [[[[a]]
10:02:49 <lambdabot>                                -> [[a]]]
10:02:49 <lambdabot>                                -> [[[a]]
10:02:49 <lambdabot>                                 -> [[a]]]]]
10:02:49 <lambdabot>                              -> [[[[[a]]
10:02:51 <lambdabot> [131063 @more lines]
10:02:52 <ihope> @more
10:02:53 <lambdabot>                                -> [[a]]]
10:02:55 <lambdabot>                                -> [[[a]]
10:02:55 <tennin> happiness is much more difficult than it looks
10:02:57 <lambdabot>                                 -> [[a]]]]
10:02:59 <lambdabot>                                -> [[[[a]]
10:03:00 * ihope cries
10:03:01 <lambdabot>                                 -> [[a]]]
10:03:03 <lambdabot> [131058 @more lines]
10:03:30 <Lemmih> @bot
10:03:31 <lambdabot> :)
10:04:31 <ihope> I find it annoying that error and fix error have different types.
10:04:51 <ihope> Erm...
10:05:11 <ihope> I find it weird that fix error and error (fix error) have different type.
10:05:26 <ihope> @type \x -> (fix x, x (fix x))
10:05:27 <lambdabot> Not in scope: `fix'
10:05:27 <lambdabot>  
10:05:27 <lambdabot> <interactive>:1:17: Not in scope: `fix'
10:05:38 <ihope> @type let fix x = x (fix x) in \x -> (fix x, x (fix x))
10:05:39 <lambdabot> forall a.
10:05:39 <lambdabot>                   (a -> a) -> (a, a)
10:05:52 <Lemmih> ihope: 'error' /= 'error' (:
10:06:03 <ihope> > 'error
10:06:04 <lambdabot>  lexical error in string/character literal
10:06:05 <ihope> > 'error'
10:06:06 <lambdabot>  lexical error in string/character literal
10:06:08 <Lemmih> It's polymorphic.
10:06:11 <ihope> ;-)
10:06:14 <Lemmih> (or something like that)
10:06:19 <ihope> > error == error
10:06:20 <lambdabot>  add an instance declaration for (Eq ([Char] -> a))
10:06:20 <lambdabot>   In the definition of `vjz': vjz = error == error
10:06:20 <lambdabot>   In the definition of `v': v = let vjz = error == error in take 2048 (
10:06:20 <lambdabot> show vjz)
10:07:47 <sili-w-birdflu> is there a function that'll display a list in a meaningful way on screen?
10:07:47 <Lemmih> > let x = error "" :: (); y = error "" :: Int in x == y
10:07:48 <lambdabot> Couldn't match `()' against `Int'
10:08:01 <ihope> sili-w-birdflu: show
10:08:03 <Lemmih> sili-w-birdflu: print?
10:08:17 <sili-w-birdflu> ihope: ah, i didn't know show worked on lists
10:08:31 <_ion> @type Î»x â†’ x
10:08:32 <lambdabot> lexical error
10:08:36 <ihope> !
10:08:52 <ihope> @type liftM2
10:08:52 <lambdabot> Not in scope: `liftM2'
10:08:58 <_ion> No unicode support. :-)
10:09:06 <ihope> @type Control.Monad.Reader.liftM2 (==) error error
10:09:06 <dons> _ion, no unicode (is that unicode?) in ghc 6.4.1
10:09:06 <lambdabot> [Char] -> Bool
10:09:10 <dons> you need ghc cvs 
10:09:27 <ihope> > liftM2 (==) error error "Hello, world!"
10:09:27 <TuringTest> hi dons
10:09:27 <lambdabot> Add a type signature
10:09:31 <_ion> dons: So i can type actual lambda, the "arrow right" char etc.?
10:09:39 <_ion> dons: And yeah, in UTF-8 encoding.
10:09:50 <Lemmih> _ion: http://haskell.org/haskellwiki/Image:HideUnicodePretty.png
10:10:18 <_ion> lemmih: Nice.
10:12:26 <dons> hey TuringTest -- good news about CTK :)
10:12:32 <TuringTest> dons: do tell!
10:12:51 <TuringTest> dons: Do you have an old one-at-a-time version lying around?
10:16:15 <TuringTest> I want to share some code that I do not even know how I managed to write correctly.
10:16:15 <TuringTest> It takes a list of string regular expressions and uses Template Haskell to turn them
10:16:15 <TuringTest> to Parsec parsers at compile time.
10:16:15 <TuringTest> vals :: [(GenParser Char state (),String)]
10:16:15 <TuringTest> vals = $(let re = ["ab*c|d()ef?","[def]|[^gh]+i\n"] in liftM ListE ( sequence [ [| ( $(parseRegexp s), s ) |] | s <- re ] ) )
10:16:34 <dons> hehe. fun!1
10:16:48 <TuringTest> demented fun.
10:16:57 <dons> oh, i was referring to Isaac's response that ctk was valid.
10:17:02 <TuringTest> Right...
10:17:54 <TuringTest> Do you want to update the CTK for the new specs?  Or should I work on that?  (No need to duplicate effort in making the first proposed version)
10:18:49 <dons> ah, ok. well if you have the time, go for it.
10:18:57 <dons> i need to prepare this weeks HWN issue.
10:19:23 <TuringTest> Ok...you write HWN, I'll make a proposed CTK based entry
10:19:50 <TuringTest> And _ion will go shopping for a Unicode keyboard.
10:19:56 <dons> ok. good. use the fastest ctk you've got :) 
10:21:04 <TuringTest> dons: I just got you e-mail.  Redundant now.  I'll mutate Lexer 6 into the new standard.
10:21:09 <TuringTest> But not tonight.
10:22:16 <_ion> turingtest: Well, it would be really easy to make vim output â†’ when you write -> in haskell mode etc. :-)
10:22:48 <TuringTest> _ion: I think emacs haskell-mode should get similar tricks.  But I don't write elisp.
10:23:54 <dons> TuringTest, did they revise the shootout FAQ: 
10:23:55 <dons> We are not trying to
10:23:55 <dons>   * compare different algorithms
10:23:55 <dons>   * showcase the capabilities of different languages
10:23:58 <dons>   * compare programming language productivity
10:23:59 <dons>   * contest programmer effort and sneaky tricks
10:25:28 <TuringTest> Interesting.
10:26:36 <dons> I'm not sure all those points were there a week ago.
10:27:52 <sili-w-birdflu> (map Char.isLower "aBCd")     works in ghci, but when i compile it i get Test.hs:4:27: Not in scope: `Char.isLower' -- any ideas?
10:28:13 <ncalexan> import Data.Char.
10:29:12 <sili-w-birdflu> i see. where do i stick that? top of my file, first thing in the module?
10:29:28 <TuringTest> top of the file, right after a module declaration
10:29:28 <ncalexan> after the module Blah where ...
10:30:48 <TuringTest> sili-w-birdflu: http://www.haskell.org/onlinereport/modules.html#import is the spec
10:32:15 <sili-w-birdflu> thanks
10:32:43 <TuringTest> Good night all
10:38:52 <GeniXPro> My tic tac toe program
10:38:54 <GeniXPro> so pretty
10:38:55 <GeniXPro> sigh
10:39:33 <GeniXPro> 234 lines of my first haskell program
10:39:47 <lennart> :)
10:40:14 <lennart> congratulations
10:40:21 <GeniXPro> thankyou
10:41:00 <GeniXPro> O almost always pwns X
10:41:03 <GeniXPro> I don't know why
10:42:50 <GeniXPro> lol probably every haskell pro will tell me my code looks n00b http://www.rafb.net/paste/results/dFOSOJ56.html
10:48:44 <dons> GeniXPro, I might rewrite your get_all_lines as :
10:48:45 <dons> get_all_lines x y l (Board a w h) = concat [a,b,c,d]
10:48:45 <dons>     where a = maybeNull (x <= w-l) [get_row x y l (Board a w h)]  
10:48:45 <dons>           b = maybeNull (y <= h-l) [get_col x y l (Board a w h)]              
10:48:45 <dons>           c = maybeNull (x <= w-l && y <= h-l) [get_diagnol x y 1    1 l (Board a w h)]
10:48:49 <dons>           d = maybeNull (x >= l   && y <= h-l) [get_diagnol x y (-1) 1 l (Board a w h)] 
10:48:52 <dons>           maybeNull cond v = if cond then v else [] 
10:48:56 <sili-w-birdflu> flodd
10:49:08 <dons> but I suspect there's probably a cleaner way.
10:50:05 <dons> otherwise, your code looks pretty good! 
10:50:36 <dons> in some cases, GeniXPro, you place 'let's on a single line of their own. That's a bit unusual.
10:50:54 <dons> Try using 'where'?
10:51:11 <dons> the 'possible_moves' functoin would be cleaner with 'where'
10:51:28 <dons> and no need to indent the body on a new line for functions like play_move
10:52:16 <araujo> dons, hiya!
10:52:28 <palomer> let a = [get_row x y l (Board a w h),get_col x y l (Board a w h),get_diagnol x y 1 1 l (Board a w h),get_diagnol x y (-1) 1 l (Board a w h)]; b = [x <= w-l, y <= h-l,x<=(w-l) && y<=(h-l),x>=l && y<=h-l]; c=zip a b ; d = map(\(e,f) -> if f then [e] else []) c in concat d
10:52:33 <dons> finally, the foo_style_names are a bit unhaskelly.
10:52:45 <dons> hey araujo.
10:53:00 <palomer> the trick is to find a pattern and then abstract over it
10:53:23 <dons> @pl \f xs -> filter (move_score_equal (maximumBy f xs) xs
10:53:24 <lambdabot> (line 1, column 54):
10:53:24 <lambdabot> unexpected end of input
10:53:24 <lambdabot> expecting variable, "(", operator or ")"
10:53:44 <palomer> oh, sure, filter is even better
10:54:00 <dons> (no, that's from further down in the program).
10:54:20 <palomer> let a = [get_row x y l (Board a w h),get_col x y l (Board a w h),get_diagnol x y 1 1 l (Board a w h),get_diagnol x y (-1) 1 l (Board a w h)]; b = [x <= w-l, y <= h-l,x<=(w-l) && y<=(h-l),x>=l && y<=h-l]; c=zip a b ; d = filter snd c in concat (map fst d)
10:55:00 <palomer> or, you can pair them up right away (and avoid zip), it's probably cleaner too
10:55:54 <palomer> and then you can write a condConcat combinator, which might come in useful later
10:56:43 <palomer> btw, does anyone here know how to use lhs2tex?
10:58:55 <araujo> dons, check my last baby! http://dev.gentoo.org/~araujo/screens/himerginggame.jpeg
10:59:52 <jethr0_> araujo: looks nice. what is it written it/with?
11:00:02 <lennart> GeniXPro: not bad for your first Haskell program.  But since everyone seems to have a complaint, I'll have one too: 'is_valid b (x,y) = get_pos x y b) == 0'
11:00:35 <araujo> jethr0_, gtk2hs
11:00:36 <audreyt> One of nothingmuch's slides about compiling Perl 6, to be presented today in OSDC.il:
11:00:49 <audreyt> * Lambda ninjas flip out and writer compilers
11:00:56 <audreyt> * ...all the time
11:01:01 <jethr0_> araujo: i'm writing pong using yampa and opengl right now. and it's _killing_ me :)
11:01:06 <audreyt> s/writer/write/
11:01:24 <dcoutts> araujo, that's a crazy black theme you've got there :-)
11:01:46 <araujo> dcoutts, :-]
11:01:55 <ihope> Eep, deja vu.
11:01:55 <araujo> jethr0_, haha, cool
11:01:59 <araujo> jethr0_, got screens?
11:02:12 <dons> hmm, cool araujo!
11:02:20 <araujo> dons, :-]
11:02:26 <ihope> Unmatched parentheses AND X's and O's.
11:02:31 <jethr0_> araujo: screens of pong :). no, i'm not that far yet. i got a moving ball and a mouse controlled paddle. but yampa is quite different than i expected.
11:03:07 <jethr0_> every motion is in closed form as a continuous integral over the game time, so getting the ball to move was hard enough, getting it to bounce off the edges was nerve-wrecking
11:03:22 <araujo> jethr0_, sounds interesting indeed
11:03:33 * araujo doesn't know too much about opengl though
11:03:59 <jethr0_> the beauty is that my pong game is 10 lines of game-specific stuff. the rest is just setting up opengl, .... could be interesting for more complex games!
11:04:28 <jethr0_> araujo: the hopengl bindings are absolutely fabulous. you should try, it's _so_ easy to get pretty impressive interactive stuff to work
11:05:29 <araujo> Cool.
11:05:59 <jethr0_> ya, well, getting the ball to bounce of the paddles and keeping the game score is gonna cost me another few hours :')
11:06:07 <araujo> haha
11:06:10 <lennart> jethr0_: my favorite pong game was written in Bluespec.  Compiled straight to an FPGA and no stupid computer needed to run it. :)
11:06:33 <jethr0_> also nice. i guess the original pong was also quite close to the machine...
11:07:09 <lennart> well, it was done even closer to the hw.  wiring up some ttl chips
11:41:32 <Pseudonym> Selamat jalan.
11:41:49 <jethr0_> salam aleikum
11:41:49 <Pseudonym> (That's the right one, isn't it?
11:41:59 <Pseudonym> Selamat tinggal is the other one.)
11:43:00 <Pseudonym> Cool.  A potential Aqsis convert in Indonesia.
12:00:45 <sethk> we ought to change the extension of .hi to something else.
12:02:39 <jethr0_> sethk: why's that?
12:02:48 <jethr0_> you mean sth not starting in "h"?
12:02:53 <ncalexan> Yeah :)
12:02:55 <sethk> jethr0_, so that filename completion would work for .hs
12:03:00 <jethr0_> ya
12:03:03 <sethk> jethr0_, right, not starting with h
12:03:22 <ncalexan> Of course, with Cabal/build systems no pollution occurs.
12:03:54 <sethk> ncalexan, for simple things, though, I like to do a simple ghc --make -o whatever
12:07:46 <ncalexan> sethk: oh, of course, me too.
12:13:06 <sethk> easy way to display one character of a string in hex?  I know how to make it a number, but how to get hex output?
12:14:46 <jethr0_> sethk: you mean hex as string?
12:14:52 <dons> Prelude> "0x" ++ Numeric.showHex 255 []
12:14:57 <sethk> jethr0_, right, I'm printing out the value
12:14:58 <dons> "0xff"  
12:15:11 <sethk> dons, thanks, showHex, that shouldn't be so hard to remember  :)
12:15:21 <sethk> dons, deployed another haskell app this weekend.
12:15:32 <dons> remember to import Numeric to get it.
12:15:32 <dons> cool!
12:15:51 <dons> keep it going. you'll create jobs for us all ! :)
12:16:26 <sethk> dons, well, maybe keep myself working for another month or two.  :)
12:16:42 <dons> ok, maybe that too.
12:20:41 <sethk> dons, what's the second argument for in showHex
12:21:05 <sethk> a string that is being built?
12:22:18 <dons> yeah, a la showsPrec. So usually you just want []
12:22:37 <dons> (unless you're appending to something).
12:24:59 <lambdabot> Issue 26 of the Haskell Weekly News is out: http://sequence.complete.org/
12:27:19 <danols> @type liftIO
12:27:20 <lambdabot> Not in scope: `liftIO'
12:27:50 <danols> anyone know what's liftIO for ?
12:27:53 <dons> @hoogle liftIO
12:27:54 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
12:27:54 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.liftIO :: IOMonad m => IO a -> m a
12:28:23 <danols> thanks dons
12:28:29 <danols> @hoggle Result
12:28:29 <lambdabot> Test.QuickCheck.Result :: Result
12:28:29 <lambdabot> Test.QuickCheck.Result :: Maybe Bool -> [String] -> [String] -> Result
12:28:29 <lambdabot> GHC.Dotnet.checkResult :: (State# RealWorld -> (#State# RealWorld, a,
12:28:29 <lambdabot> Addr##)) -> IO a
12:29:32 <danols> dons what does the IO (Result Respone) in simpleHTTP :: Request -> IO (Result Response) mean ?
12:31:49 <dons> it means that a 'Result Response' value is retuurned in the IO monad.
12:32:19 <danols> now where could I read up on Result ?
12:32:25 <dons> so, simpleHTTP takes a request, and returns a result, doing some IO on the way.
12:32:36 <dons> Result would be defined in the HTTP module somewheere.
12:32:49 <danols> hmmm dons that's what i thought but i can't seem to find it
12:32:55 <danols> http://www.haskell.org/http/api/Network.HTTP.html#t%3AResult
12:32:57 <danols> is the www
12:33:25 <danols> may you take a look ?
12:34:20 <dons> yep, looking...
12:34:46 <dons> ah, it musnn't have any haddoc documentation
12:35:02 <dons> you'll have to read the source.
12:35:19 <danols> hmmm wouldn't typing :t Result in GHCI reveal it ?
12:36:16 <danols> i found it in the source code but it's not in the scope when in GHCI
12:36:22 <danols> and i know the module is lodaded
12:36:53 <dons> hmm. Result is a type, so :t Result don't work.
12:37:43 <danols> @hoggle either
12:37:43 <lambdabot> Data.Either.Either :: Either a b
12:37:43 <lambdabot> Data.Either.either :: (a -> c) -> (b -> c) -> Either a b -> c
12:37:43 <lambdabot> Prelude.Either :: Either a b
12:38:20 <danols> dons i see
12:38:23 <dons> -- | This is the type returned by many exported network functions.
12:38:23 <dons> type Result a = Either ConnError   {- error  -}
12:38:23 <dons>                        a           {- result -}
12:38:36 <danols> @hoggle Either
12:38:37 <lambdabot> Data.Either.Either :: Either a b
12:38:37 <lambdabot> Data.Either.either :: (a -> c) -> (b -> c) -> Either a b -> c
12:38:37 <lambdabot> Prelude.Either :: Either a b
12:38:50 <danols> @type Either
12:38:51 <lambdabot> Not in scope: data constructor `Either'
12:38:58 <danols> @type Prelude.Either
12:38:59 <lambdabot> Not in scope: data constructor `Prelude.Either'
12:39:01 <dons> so Result is just a synonym for Either. you get back either an error value, or some value of type 'a'
12:39:07 <dons> for simpleHTTP, that 'a' is a Response.
12:39:16 <danols> i see
12:39:19 <dons> @kind Either
12:39:19 <lambdabot> * -> * -> *
12:39:22 <dons> Either is a type.
12:39:32 <dons> @type Left ()
12:39:33 <lambdabot> forall b. Either () b
12:39:54 <danols> so either returns an error or a
12:40:07 <dons> @type Right Bool  :: Either Int Bool
12:40:08 <lambdabot> Not in scope: data constructor `Bool'
12:40:24 <dons> @type Right True :: Either Int Bool
12:40:24 <lambdabot> Either Int Bool :: Either Int Bool
12:40:47 <dons> you can tell which value you get back by using 'case'
12:40:50 <dons> or pattern matching.
12:41:02 <danols> can you say that again in plain english ?
12:41:06 <danols> consider me a newb
12:41:38 <dons> > let x = Right 7 in case x of Left _ -> error "some error"  ; Right y -> y
12:41:39 <lambdabot> 7
12:42:21 <danols> Left 3
12:43:22 <dons> so 'x' is a value of type 'Either b Int', say. and then we can pattern match on 'x' to work out whether it is a 'Left' or a 'Right'. 'Left' indicates an error.
12:43:43 <danols> hmmm ok
12:44:01 <danols> -- | This is the type returned by many exported network functions.
12:44:01 <danols> type Result a = Either ConnError   {- error  -}
12:44:01 <danols>                        a           {- result -}
12:44:19 <danols> so Right result :: Result would return a ?
12:44:30 <dons> simpleHTTP returns either a Left containing a ConnError, or a Right containing an 'a'
12:44:40 <danols> i see
12:44:44 <dons> for the type of simpleHTTP, you see that the 'a' is bound to a 'Responose'
12:44:55 <dons> (Result Response)
12:45:57 <danols> so let's say i have result <- simpleHTTP
12:46:08 <danols> to read the response i would :
12:46:16 <danols> Right result  ?
12:47:01 <dons> do v <- simpleHTTP something
12:47:01 <dons>    case v of
12:47:01 <dons>         Left x  -> error "something bad"
12:47:03 <dons>         Right r -> return r
12:47:23 <dons> like that. using a 'case' statement to pattern match on the Left and Right options
12:48:03 <danols> what are x r ?
12:48:13 <dons> if you get back a 'Left' then there was an error, if you get back a Right r, unwrap the Right and return only the 'r'
12:48:27 <danols> makes sense
12:48:29 <dons> the 'x' and the 'r' are possible error message (I guess) or the actual response
12:48:45 <danols> is case the preffered way of handling either types ?
12:49:17 <dons> use 'case' or the 'either' function.
12:49:25 <dons> 'either' is just a wrapper over 'case'
12:49:34 <jethr0_> :e :w
12:49:40 <jethr0_> *arg*
12:49:42 <dons> either                  :: (a -> c) -> (b -> c) -> Either a b -> c
12:49:42 <dons> either f _ (Left x)     =  f x
12:49:42 <dons> either _ g (Right y)    =  g y
12:50:27 <dons> which is the same as: 
12:50:29 <dons> either f g v = case v of
12:50:31 <dons>     Left  x -> f x
12:50:34 <dons>     Right y -> g y
12:51:06 <danols> @type Print
12:51:07 <lambdabot> Not in scope: data constructor `Print'
12:51:08 <dons> it all depends on the context which one to use. I think 'case' is clearer, usually.
12:51:15 <danols> dons so it seems
12:51:19 <danols> @type show
12:51:20 <lambdabot> forall a. (Show a) => a -> String
12:51:28 <danols> @type print
12:51:28 <lambdabot> forall a. (Show a) => a -> IO ()
12:52:24 <dons> I wonder if djinn can derive 'either', i bet it can:
12:52:25 <dons> @djinn (a -> c) -> (b -> c) -> Either a b -> c
12:52:25 <lambdabot> f a b c =
12:52:25 <lambdabot>   case c of
12:52:25 <lambdabot>   Left d -> a d
12:52:25 <lambdabot>   Right e -> b e
12:52:28 <dons> hehe
12:52:45 <dons> even djinn says to use 'case' :)
12:53:12 <dons> @djinn-add either :: (a -> c) -> (b -> c) -> Either a b -> c
12:53:25 <dons> @djinn (a -> c) -> (b -> c) -> Either a b -> c
12:53:25 <lambdabot> f = either
12:54:01 <danols> dons take a look at this
12:54:02 <danols> main = withSocketsDo $ do
12:54:02 <danols>    response <- simpleHTTP (request "4194187")
12:54:02 <danols>       case response of 
12:54:02 <danols>       Left x = show("http error")
12:54:02 <danols>       Right y = show y
12:54:04 <danols>    return ()
12:54:20 <danols> it says last statement in do must be an expression
12:54:20 <dons> do you mean 'print' instead of 'show'??
12:54:22 <danols> what does that mean ?
12:54:34 <danols> what is the difference ?
12:54:38 <dons> and the 'case' shouldd have '->' not '='
12:54:47 <dons> @type print
12:54:47 <lambdabot> forall a. (Show a) => a -> IO ()
12:54:49 <dons> @type show
12:54:50 <lambdabot> forall a. (Show a) => a -> String
12:55:06 <danols> ok what is the -> meaning ?
12:55:14 <dons> one actually prints to stdout. the other just constructs a string.
12:55:24 <dons> Left x -> print "http error".
12:55:29 <dons> it's just the syntax of 'case'
12:56:03 <danols> i see
12:56:27 <danols> ok hmmm
12:56:28 <danols> main = withSocketsDo $ do
12:56:28 <danols>    response <- simpleHTTP (request "4194187")
12:56:28 <danols>       case response of 
12:56:28 <danols>       Left x -> print "http error"
12:56:28 <danols>       Right y -> print y
12:56:30 <danols>    return ()
12:56:37 <danols> i get last statement in do must be an expression ???
12:56:46 <dons> main = withSocketsDo $ do
12:56:46 <dons>     response <- simpleHTTP (request "4194187")
12:56:46 <dons>     case response of                   
12:56:46 <dons>         Left x  -> print "http error"
12:56:50 <dons>         Right y -> print y
12:57:01 <dons> your indenting, I think.
12:57:16 <danols> hmmm that's what i'm thinking too damn vim
12:58:58 <danols> dons you RULE :)
12:59:42 <danols> dons is there a string search / regexp for haskell ?
13:02:40 <dons> string search, well, there's the list library. it has lots of useful things.
13:02:42 <dons> like filter
13:02:45 <dons> elems
13:03:19 <dons> for regexes, there''s Text.Regex, but it's often not as nice as writing list functions
13:03:23 <dons> @docs Data.List
13:03:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
13:03:28 <dons> @docs Text.Regex
13:03:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.
13:03:28 <lambdabot> html
13:03:57 <dons> actually, Text.Regex can be kind of good: 
13:03:59 <dons> clean s | Just _         <- no_io      `matchRegex`    s = "No IO allowed\n"
13:03:59 <dons>         | Just _         <- terminated `matchRegex`    s = "Terminated\n"
13:04:03 <dons>     where
13:04:04 <dons>         -- s/<[^>]*>:[^:]: //
13:04:04 <dons>         type_sig   = mkRegex "add a type signature that fixes these type"
13:04:04 <dons>         no_io      = mkRegex "No instance for \\(Show \\(IO"
13:04:06 <dons>         terminated = mkRegex "waitForProc"
13:04:17 <dons> so with pattern guards (the <- arrows) the syntax is fairly ok.
13:04:53 <dons> though I think 'mkRegex should be called 'regex'. and 'matchRegex' should be called 'match'
13:05:59 <orbitz> hrm
13:06:04 <orbitz> i totally need a good haskell project
13:06:38 <audreyt> dons: this is your irregularily schedule... (you know the rest)
13:07:03 <dons> orbitz, maybe browse the recent project announcemnts and find something to hack on: http://www.cse.unsw.edu.au/~dons/code/hwn/announce.html
13:07:23 <dons> audreyt, thanks. what can i say? I'm a lazy functional programmer
13:08:05 <dons> orbitz, writing a lambdabot plugin is another good way to start.
13:08:12 <audreyt> my keynote on Pugs in OSDC.il will be on air in 3.5 hours, and I still can't say "use haskell:System.Eval.Haskell;" in Pugs
13:08:22 <dons> argh.
13:08:24 <audreyt> ;)
13:08:48 <orbitz> dons: is there a list of plugin needs out there?
13:08:50 <dons> 1.0 _is_ tagged. it's just sitting in the darcs repo
13:08:56 <audreyt> how about just sdist it :)
13:09:01 <audreyt> so I can refer it to the audience :)
13:09:22 <audreyt> you can mark it as (experimental) on your website or some such
13:09:42 <dons> ok. /me hacks.
13:09:52 <dons> I'll call it rc1 ;)
13:09:52 <audreyt> (cf: the comic strip linked on pugs.blogs.com)
13:09:54 <audreyt> dons++
13:09:58 <audreyt> yeah, sure, even rc0 would work
13:10:26 <orbitz> hrm
13:10:47 <orbitz> why is pugs being created anyways?  Honestly, I'd think haskell developers would find perl6 to mostly be a waste...
13:11:12 <audreyt> orbitz: er, I think Haskell only works if you know what you're doing :)
13:11:17 <Korollary> it's not for haskell deves
13:11:29 <audreyt> for people who don't know what they are doing, optionally-dynamic languages are needed
13:11:42 <audreyt> (cf. Eric Meijer's LtU column)
13:12:07 <orbitz> i'm not saying that, i'm saying perl6 seems like this giant mess form wha ti've read.  why not develope a decent impl of python or  somethign?
13:12:27 <audreyt> orbitz: PyPy is on the next alley, room 2, to your left
13:13:04 <orbitz> heh
13:13:12 <orbitz> i can't see PyPy going anywhere other htan beign SLOOOOOOW
13:13:21 <orbitz> i wonder how IronPython is coming along
13:13:23 <audreyt> they are actually JITting and going to self host
13:13:28 <audreyt> just as we are
13:13:28 <orbitz> interesting
13:13:35 <orbitz> 'we' as in pugs?
13:13:37 <audreyt> yeah
13:14:03 <orbitz> hrm, what other languages are out ther ethat could use a decent implementation
13:14:36 <audreyt> RDF (ducks)
13:14:47 <_ion> MicrosoftÂ® VisualÂ® BasicÂ®
13:14:49 <orbitz> we could use a godo Rexx implementation
13:14:56 <orbitz> :)
13:15:05 <audreyt> orbitz: JS2
13:15:11 <orbitz> javascript?
13:15:13 <audreyt> honestly, if I'm to start another compiler project, I'll choose JS2
13:15:19 <audreyt> I think it's the next Ruby :)
13:15:24 <audreyt> yeah
13:15:41 <_ion> Wow. I love Ruby. Gotta check out JS2. :-)
13:15:46 <orbitz> i have not used js, but i hear it's go ta really neat object model
13:15:57 <dons> now i'm scared.
13:16:00 <audreyt> it does... which Perl6 shamelessly plag^Wadapts
13:16:05 <orbitz> hah
13:16:40 <orbitz> i'm afraid this iwll start soem sort of falme war, but i can't say OOP really tickles me
13:16:43 <audreyt> first-class continuations and all that.
13:17:01 <audreyt> ... but JS is a functional programming language! brendan keynotes in ICFP! ;)
13:17:11 <dons> yup.
13:17:56 <dons> audreyt, 1.0-rc0 is up. http://www.cse.unsw.edu.au/~dons/hs-plugins/
13:18:28 <dons> @karma+ audreyt -- for nagging
13:18:28 <lambdabot> audreyt's karma raised to 1.
13:18:44 <audreyt> @karma+ dons -- for conagging
13:18:44 <lambdabot> dons's karma raised to 22.
13:19:11 <dons> hehe
13:19:33 <audreyt> nit, but can you put rc0 above 09?
13:19:37 <audreyt> and say (please test) or something
13:19:42 <dons> ok ok :)
13:19:52 <dons> I was trying to hide it ;)
13:20:02 <audreyt> that never works ;)
13:21:06 <orbitz> hrm, dones't lambdabot need some modifcation so it doesn't split url's
13:23:21 <dons> ok audreyt. tweakified
13:23:34 <audreyt> woot
13:23:39 <dons> orbitz, it could do with a different ouput filter , yep.
13:23:49 <orbitz> maybe i'll look at that
13:24:03 <orbitz> should the section of code i need to look at be fairly obvious?
13:24:10 <dons> sorry for the delay audreyt.
13:25:08 <audreyt> dons: np... the next release can finally do "use haskell:" then
13:25:14 * araujo has suddenly found a way to return a type variable similar to 'error'
13:25:20 <audreyt> I'd had used libGHC if it doesn't always fail build here
13:25:31 <audreyt> araujo: typeOf?
13:25:44 <dons> yeah libGHC is still a bit iffy. give it a year or so
13:26:02 <audreyt> a year, is like, forever :)
13:26:11 * audreyt notes pugs just turned 1yr old
13:26:28 <araujo> audreyt, probably an ugly way of doing... with an infinite loop :-]
13:26:31 <dons> woohoo!
13:26:36 <dons> happy birthday pugs :)
13:26:43 <audreyt> thanks :)
13:26:47 <araujo> hah, happy birthday!
13:27:01 <dons> how many patches did you get in the first year?
13:27:02 <dons>  do you know?
13:27:03 <audreyt> I feel old :/
13:27:13 <audreyt> we work in commits, not patches
13:27:22 <audreyt> ~10000 I think... some gets aggregated
13:27:25 <audreyt> 9188 outstanding commits
13:27:31 <dons> ah, commits. 10k whoa! exceelent stuuff.
13:27:53 <dons> there's about 20k in all of ghc, iirc.
13:27:58 <audreyt> nod
13:28:51 <audreyt> parrot though still beats us... 11745 to date
13:29:02 <audreyt> 6000 or so in the past year
13:29:23 <orbitz> you should stop writing pugs, and work on a parrot haskell impl:)
13:29:29 <orbitz> one VM to rule them all!
13:29:50 <audreyt> orbitz: parrot is, like, faster than C/Fortran recently, in Alioth benchmarks where Leo started worked on
13:30:00 <audreyt> I very much doubt I can top that with GHC
13:30:04 <audreyt> and it's not my forte anyway
13:30:12 <orbitz> no i mean
13:30:21 <orbitz> write a haskell atrget for parrot
13:30:27 <audreyt> ooh, yeah. Grin->PIR
13:30:36 <orbitz> if parrot is so nice
13:30:37 <audreyt> I should visit a certain JohnMeacham some time
13:30:43 <audreyt> to work on that
13:30:46 <orbitz> i woudl reallly love ot see all my fav langes have targets fo rit
13:30:59 <audreyt> especially now that the not-not-ML paper tells me precisely how to target a register VM
13:31:08 <audreyt> and mix nonstrict with strict types
13:31:30 <audreyt> SPJ++ # source of endless wisdom
13:32:10 <orbitz> how is haskell relate dot ML?
13:32:15 <audreyt> haskell is not not ML.
13:32:23 <orbitz> hrm
13:32:27 <orbitz> sot hat means it is ML?
13:32:29 <audreyt> # http://research.microsoft.com/%7Esimonpj/papers/not-not-ml/index.htm
13:32:37 <audreyt> no, it is ML only if you force it.
13:32:59 <orbitz> would i be slapped for saying it is similar to ML
13:33:11 <orbitz> does a lot of haskell reserach go on at MS? or is it that simon
13:33:18 <JohnMeacham> audreyt: sure. are you by Pasadena,CA?
13:33:34 <audreyt> JohnMeacham: I'll visit redmond and chicago and maybe portland this June
13:34:03 <audreyt> how's your timeslices around June/July?
13:34:51 <JohnMeacham> not terribly close. portland is the closest at 950 miles away.
13:35:16 <audreyt> that's okay, airplanes are safe
13:35:20 <audreyt> (or so I hope)
13:35:28 <audreyt> unsafeCrashLanding#
13:36:09 <dons> hehe
13:36:32 <JohnMeacham> ah. I should be around. I really need to go to one of these FP conferences sometime. but my work wouldn't sponsor it. hmm..
13:36:49 <ramza3> hello
13:37:12 <audreyt> ok, Pasadena is going into my slides :)
13:37:26 <audreyt> I'd love to chat more, but I really should get this thing written -- onstage in <3hr
13:37:32 <audreyt> bbiab :) &
13:38:01 <JohnMeacham> sure thing.
13:51:01 <sili-w-birdflu> (a -> b -> a) -> a -> [b] -> a  -- confuses me :(
13:52:45 <GeniXPro>  its leety
13:53:23 <GeniXPro> a function that takes a function that takes an a and a b and returns an a, an a, and a list of b's, and turns it into an a
13:54:46 <sethk> is the mod function in haskell mod, so you do     n `mod` m   ?
13:54:50 <sili-w-birdflu> that confuses me also
13:58:52 <orbitz> sili-w-birdflu: the first parameter to yoru functino is a funciton
13:59:07 <sili-w-birdflu> aye.
13:59:09 <orbitz> the second apraeter is somethign of type 'a', and the third of type list of b's
13:59:15 <orbitz> and it returns oemthign of type a
13:59:43 <sili-w-birdflu> that makes sense, the syntax confuses me
13:59:50 <orbitz> you get used to it
14:02:08 <GeniXPro> when you learn about partial application, the syntax will make sense
14:03:22 <dons> > 7 `mod` 4 -- sethk
14:03:23 <lambdabot> 3
14:03:39 <orbitz> i like how / gives you a float
14:05:15 <sethk> dons, thanks.  what's the flag to get ghc to tell you about nonexhaustive patterns?
14:07:44 <GeniXPro> sili-w-birdflu, we could confuse you some more, if you want. What your actually seeing is a function that takes a function as its first argument, and returns a function that takes an a. That function, when given an a, returns a function thats takes a [b]. This function, when given a [b], won't arrive at another function (becuase there aren'y any more -> ), it will actually arrive at a result
14:08:09 <orbitz> GeniXPro: oh my that wasn't necesary
14:08:13 <orbitz> an dcould have been explaien da lot better
14:08:23 <orbitz> GeniXPro: don't try to show off, it doesn't suit you
14:08:25 <sili-w-birdflu> ya that fucks me up
14:08:34 <sethk> -fwarn-incomplete-patterns?
14:08:51 <GeniXPro> wow my irc is lagging
14:09:02 <GeniXPro> sili-w-birdflu, thats functional programming for you
14:09:10 <orbitz> that's haskell for you
14:09:21 <GeniXPro> thats pure functional programming for you
14:09:38 <GeniXPro> with a bit of haskell thrown in on the side
14:10:10 <orbitz> GeniXPro: are you coming to my barmitzvah/
14:10:17 <sili-w-birdflu> i'm still trying to make sense of the syntax
14:10:29 <GeniXPro> orbitz, i don't know, i haven't recieved any invitation
14:10:31 <orbitz> sili-w-birdflu: foo -> bar -> baz
14:10:39 <sili-w-birdflu> orbitz: oh that explains everything :(
14:10:40 <orbitz> sili-w-birdflu: everything bu teh first thing is paraemters
14:10:45 <GeniXPro> foo -> (bar -> baz)
14:10:46 <orbitz> sili-w-birdflu: the last is return type
14:10:56 <orbitz> sili-w-birdflu: if they have a (), they are functions
14:11:21 <orbitz> so GeniXPro's pro takes one object of tyep foo and returns a function, the returend function takes an object of type bar and returns one of type baz
14:12:03 <GeniXPro> sili-w-birdflu, i'm still getting used to the syntax myself, having completed my first haskell program the other day
14:12:38 <sili-w-birdflu> orbitz: wait, all but the first thing are parameters, the last is the return type?
14:12:46 <GeniXPro> sili-w-birdflu, the best thing to do, i find, is to ignore it, and just write code, rather than trying to make sense of it all. It will hit you about two hours in
14:12:46 <orbitz> sili-w-birdflu: yes
14:12:52 <GeniXPro> sili-w-birdflu, yeah
14:12:54 <sili-w-birdflu> so what's the first thing?
14:12:58 <orbitz> sili-w-birdflu: err no
14:12:59 <GeniXPro> a parameter
14:13:02 <orbitz> sili-w-birdflu: all of the first stuff is parameters
14:13:10 <orbitz> sili-w-birdflu: all but the last are parameters, the last isreturn
14:13:18 <sili-w-birdflu> ok
14:13:32 <orbitz> sili-w-birdflu: so what would a function that takes 2 a's ans returns a b look like?
14:13:51 <sili-w-birdflu> a -> a -> b
14:13:58 <GeniXPro> yes
14:14:07 <orbitz> sili-w-birdflu: things in [] are lists too btw
14:14:18 <GeniXPro> I find implicit polymorphism rather confusing
14:14:19 <orbitz> sili-w-birdflu: so explain: [a] -> b -> [b]
14:14:26 <orbitz> GeniXPro: how so?
14:14:44 <GeniXPro> orbitz, i just do.. although i've gotten over it
14:14:55 <sili-w-birdflu> orbitz: the function takes a list of a and a b, returns a list of b
14:15:00 <orbitz> sili-w-birdflu: swell
14:15:18 <sili-w-birdflu> ya, this tutorial just kinda throws the syntax at you without too much explanation
14:15:24 <orbitz> sili-w-birdflu: no ([a] -> b -> c) -> d -> ([c] -> b)
14:15:31 <orbitz> which tut are you reading?
14:15:39 <sili-w-birdflu> yet another haskell tutorial
14:15:47 <orbitz> hrm, i found YAHT to be quite nice
14:15:50 <orbitz> explaining thigns well
14:16:00 <sili-w-birdflu> most things ya. :t map is what screwed me up
14:16:08 <orbitz> how so?
14:16:23 <sili-w-birdflu> the parens
14:16:23 <orbitz> :type map
14:16:27 <orbitz> @type map
14:16:28 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
14:16:31 <orbitz> do you understand it now
14:16:35 <sili-w-birdflu> i think so
14:16:38 <orbitz> lay it on me
14:17:20 <sili-w-birdflu> ([a] -> b -> c) -> d -> ([c] -> b) ?
14:17:28 <orbitz> sili-w-birdflu: map
14:17:31 <orbitz> well, youc an do both
14:17:38 <orbitz> sili-w-birdflu: err th e'no' in that was meant to be 'so'
14:17:44 <orbitz> err  i mean 'now'
14:18:28 <GeniXPro> sili-w-birdflu, close
14:19:57 <sili-w-birdflu> i'll what you gave me then map. 1st param: a function that takes a list of a, a b, and returns a c. 2nd param, a d. it returns a function that takes a list of c and returns a b
14:20:14 <GeniXPro> I would have thought map would be (a -> b) -> [a] -> [b]
14:20:29 <orbitz> sili-w-birdflu: sweet
14:20:40 <orbitz> GeniXPro: it is, notice what lambdabot said
14:21:03 <GeniXPro> lambdabot adds in forall for added complexity
14:21:37 <sili-w-birdflu> and for map: 1st arg is a function that takes an a and returns a b, 2nd arg is a list of a. it returns a list of b
14:22:07 <orbitz> sili-w-birdflu: shwing
14:22:12 <sili-w-birdflu> sweet thanks
14:22:54 <GeniXPro> Its too bad i couldn't get haskell to do my math homework for me
14:23:11 <orbitz> i generally use it fo rmy math home
14:23:24 <orbitz> nothing more broing than computing euclidean gcd by hand
14:24:16 <GeniXPro> My teacher requires us write the solution as well ...
14:24:35 <GeniXPro> Haskell has too much overhead on io for me to want to do it in it
14:24:41 <sethk> GeniXPro, so?  get haskell to do that too.  what kind of programmer are you, anyway?  :)
14:24:53 <orbitz> too much overhead?
14:25:22 <GeniXPro> too different i mean
14:25:41 <orbitz> hrm can't you trace a function like i lisp?
14:25:55 <GeniXPro> I still like the world where i can input a number from the console and calculate its square using the same symbol
14:26:07 <GeniXPro> yeah
14:26:31 <GeniXPro> Trace might work
14:26:43 <orbitz> symbol names are irelevant
14:26:53 <orbitz> and why can't you do sqrt with it?
14:27:09 <GeniXPro> Anyone, i have an hour to compute a 5 year budget for a theorieticall character named john
14:27:36 <GeniXPro> In a variety of situations, such as "he gets fired on the third year" or " he recieves a pay raise two months in"
14:29:36 <GeniXPro> The best homework doing robots are implemented in either lisp or python
14:31:02 <sili-w-birdflu> ?
14:31:48 <palomer> so when exactly shouldn't you put a "try" in parsec?
14:41:23 <Excedrin> is Maybe equivalent to SML's Option?
14:41:29 <palomer> yes
14:41:54 <palomer> (though option isn't capitalized)
14:42:14 <palomer> I also think option is more aptly name
14:42:48 <palomer> (then again, haskell isn't known for intuitive naming)
14:47:40 <pundai> why doesnt this work in ghci makeList = 1  : makeList
14:47:52 <pundai> orbitz you tell me
14:48:52 <sili-w-birdflu> haskell is too clever
14:49:19 <sili-w-birdflu> surprisingly clever, at least
14:49:53 <araujo> > let makeList = 1 : makeList in take 9 makeList
14:49:54 <lambdabot> [1,1,1,1,1,1,1,1,1]
14:50:20 <pundai> araujo, wth
14:50:20 <pundai> ok
14:50:25 <pundai> i guess it was pseudocode
14:50:51 <araujo> You need, let for binding with ghci
14:51:12 <pundai> 5ux
14:51:20 <araujo> ?
14:51:24 <pundai> sucks
14:51:44 <pundai> whats this in take 9 stuff
14:52:40 <araujo> @index take
14:52:40 <lambdabot> Data.List, Prelude
14:52:47 <araujo> @hoogle take
14:52:47 <lambdabot> Data.List.take :: Int -> [a] -> [a]
14:52:47 <lambdabot> Prelude.take :: Int -> [a] -> [a]
14:52:47 <lambdabot> Control.Concurrent.MVar.takeMVar :: MVar a -> IO a
14:53:03 <GeniXPro> is everyone convertying to haskell these days?
14:53:08 <pundai> ah ok so explain a chinese word in chinese!
14:53:14 <pundai> neer mind, i'll get it sopon
14:53:31 <palomer> man my grammar sucks
14:53:46 <Excedrin> > take 2 [1,2,3]
14:53:47 <lambdabot> [1,2]
14:53:58 <Excedrin> > take 3 [1..]
14:53:59 <lambdabot> [1,2,3]
14:54:01 <GeniXPro> > [1..]
14:54:02 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
14:54:02 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
14:54:02 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
14:54:02 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
14:54:02 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
14:54:04 <lambdabot> [24 @more lines]
14:54:14 <GeniXPro> that should be infinity more lines!
14:54:19 <GeniXPro> hax!
14:55:58 <GeniXPro> > ['a' .. 'c']
14:55:59 <lambdabot> "abc"
14:56:09 <GeniXPro> > ['a' .. 'Z]
14:56:10 <lambdabot>  lexical error in string/character literal
14:56:12 <GeniXPro> > ['a' .. 'Z']
14:56:13 <lambdabot> ""
14:56:18 <Cale> ghci and hugs aren't meant to accept declarations
14:56:26 <Cale> you put declarations in a file
14:56:37 <Cale> and they load those files and let you test them
14:56:55 <palomer> Cale: why won't this work:
14:57:16 <palomer> > let a = \l -> (all (== (head l)) l) in a []
14:57:17 <lambdabot> Add a type signature
14:57:23 <Cale> pundai: it wasn't pseudocode, just not an expression, but a declaration which must go in a file
14:58:12 <pundai> Cale, oh i see
14:58:21 <Cale> palomer: that works in ghci
14:58:34 <palomer> yeah, but not with lambdabot
14:58:37 <palomer> why is this?
14:58:56 <Cale> palomer: maybe the monomorphism restriction applies somehow
14:59:06 <palomer> that's what I was thinking
14:59:07 <Cale> I wish we could ask for the full error
14:59:19 <Cale> > let a l = (all (== (head l)) l) in a []
14:59:20 <lambdabot> Add a type signature
14:59:25 <Cale> no, that's not it
15:00:40 <Cale> > let a :: (Eq a) => [a] -> Bool; a l = all (== (head l)) l in a []
15:00:42 <lambdabot> Add a type signature
15:00:46 <araujo> > let a (l :: [Int]) = (all (== (head l)) l) in a []
15:00:47 <lambdabot>   Illegal signature in pattern: [Int]
15:00:47 <lambdabot>    Use -fglasgow-exts to permit it
15:00:49 <Cale> oh
15:01:01 <Cale> > let a l = (all (== (head l)) l) in a ([] :: [Int])
15:01:01 <lambdabot> True
15:01:04 <Cale> aha
15:01:07 <araujo> :-]
15:01:10 <Cale> defaulting rules don't apply
15:01:15 <Cale> that's what it is :)
15:01:30 <palomer> eh?
15:01:44 <Cale> unresolved overloading of the type of [] together with a need to know the type in order to decide on an instance of Eq to pass to a
15:02:05 <Cale> (despite the fact that it's not used :)
15:02:22 <palomer> english?
15:02:26 <Cale> Okay
15:02:29 <Cale> @type []
15:02:31 <lambdabot> forall a. [a]
15:02:34 <palomer> sure
15:02:37 <Cale> completely polymorphic
15:02:47 <Cale> @type let a l = (all (== (head l)) l) in a
15:02:48 <lambdabot> forall a.
15:02:48 <lambdabot>               (Eq a) =>
15:02:48 <lambdabot>               [a] -> Bool
15:03:11 <Cale> okay, so in order to apply this function, we need to know that a is in Eq
15:03:32 <palomer> > let a l = (all (== (head l)) l) in a ([] :: [Maybe Int])
15:03:34 <lambdabot> True
15:04:26 <palomer> someone give me a type which isn't in Eq !
15:04:38 <Cale> > let a l = (all (== (head l)) l) in a ([] :: [a -> a])
15:04:39 <lambdabot>  add an instance declaration for (Eq (a -> a))
15:04:39 <lambdabot>   In the definition of `gjb':
15:04:39 <lambdabot>    gjb = let a l = (all ((== (head l))) l) in a ([] :: [a -> a])
15:04:46 <palomer> oh, righto
15:04:53 <palomer> so why does ghci accept it?
15:05:07 <Cale> it defaults the type of [] to [()]
15:05:53 <palomer> how does it do that?
15:06:27 <palomer> this is an extension, right?
15:06:33 <Cale> hmm
15:07:03 <palomer> hugs has it too
15:07:06 <Cale> how do we see this? :)
15:07:30 <pundai> why do i have to do snd (fst ((1,'a'),"hello")) but cant do snd fst ((1,'a'),"hello")
15:07:55 <palomer> pundai: why can't you?
15:08:04 <palomer> oh, righto
15:08:05 <pundai> says cant match
15:08:14 <pundai> so im assuming it things there are two parameters
15:08:15 <palomer> application is left associative
15:08:18 <pundai> damn
15:08:18 <palomer> in english:
15:08:21 <pundai> no i get it
15:08:28 <pundai> i was about to say application is not right associative
15:08:51 <Cale> snd fst x is the same as (snd fst) x which is a type error :)
15:09:28 <pundai> uh what
15:10:09 <palomer> hmm
15:10:19 <palomer> the parsec grammar for my language is 500 lines long
15:10:48 <palomer> this is excessive, since my language consists of lambdas, application and case statements
15:10:56 <Cale> pundai: since (snd fst) is a type error
15:11:00 <palomer> oh, and types and kinds
15:11:03 <palomer> and let statements
15:11:14 <palomer> and, furthermore, my grammar is broken
15:11:17 <palomer> what to do:(
15:12:19 <Cale> palomer: Are you putting too much computation into the parser perhaps?
15:12:24 <fluxx> pundai, but that's why $ was invented
15:12:38 <Cale> and . too :)
15:12:59 <Cale> > (snd . fst) ((1,2),3)
15:13:00 <lambdabot> 2
15:13:14 <Cale> that's function composition
15:13:19 <Cale> > snd . fst $ ((1,2),3)
15:13:19 <lambdabot> 2
15:13:24 <pundai> Cale, you're saying that snd fst x gets applied like (snd fst) x right? (snd fst) is not some funky syntax, just parentheses?
15:13:36 <Cale> pundai: right
15:13:59 <pundai> ok
15:14:02 <Cale> pundai: every function in Haskell takes one parameter
15:14:09 <pundai> ah
15:14:15 <Cale> it's just that sometimes, they return functions :)
15:14:19 <pundai> this is what does currying?
15:14:21 <Cale> yeah
15:15:11 <Cale> When passing multiple parameters, you're really passing a single parameter, getting back a function, which eats the next parameter and so on
15:15:35 <Cale> which is why it's important that  f a b c  is read as  ((f a) b) c
15:15:36 <pundai> so how could you fix y for f(x,y)
15:16:38 <Cale> well, you could use a lambda
15:16:45 <Cale> (if I know what you mean :)
15:16:57 <pundai> im sure you do
15:16:58 <Cale> or if it's really f x y, then you can use flip
15:17:15 <Cale> @type flip
15:17:16 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
15:17:20 <pundai> well im still only on page 27 of yaht
15:17:22 <Cale> :)
15:17:40 <Cale> flip is defined like
15:17:45 <Cale> flip f x y = f y x
15:17:51 <palomer> Cale: my parser does no computation whatsoever
15:17:56 <Cale> palomer: hmm
15:18:08 <Cale> palomer: what type does it produce?
15:18:28 <Cale> (presumably an AST :)
15:19:29 <palomer> Cale: a Term
15:20:04 <palomer> http://www.rafb.net/paste/results/ufmx2E93.html
15:20:14 <palomer> or a [DataDeclaration]
15:20:20 <Cale> hmm, that doesn't seem too bad
15:20:32 <Cale> so what gets it up to 500 lines?
15:20:46 <palomer> http://www.rafb.net/paste/results/PJQHfz69.html
15:21:16 <palomer> Cale: im ineptitude:o/
15:22:18 <palomer> s/im/my
15:23:46 <Cale> hmm... maybe look through the combinators which are available in Parsec to see if you're repeating work anywhere? I'm not sure
15:23:47 <palomer> http://www.rafb.net/paste/results/UtXlxp82.html <--here's the grammar
15:23:51 <palomer> it's actually 300 line-
15:25:04 <palomer> s/line-/lines
15:27:13 <Cale> I suppose it's not too bad, since the lines are mostly short
15:27:23 <palomer> any suggestions?
15:27:28 <Cale> there are some places with obvious repetition
15:27:34 <Cale> which could be factored
15:27:52 <palomer> for example?
15:28:11 <Cale> identifierChar = letter <|> digit <|> oneOf ['_','\'']
15:28:27 <Cale> upperIdentifier = liftM2 (:) upper (many identifierChar)
15:28:36 <Cale> er
15:28:48 <Cale> upperIdentifier = tokerPos (liftM2 (:) upper (many identifierChar))
15:29:26 <Cale> etc.
15:30:04 <Cale> if elem i keywords then pzero else return (i,pos)  shows up 3 times
15:31:01 <Cale> (and btw, the usual indenting for 'then' and 'else' is to align them on lines following the if)
15:32:30 <Cale> you should make sure that  application  can't be written in terms of chainl
15:32:48 <palomer> how would that work?
15:32:54 <palomer> (it probably can be written in terms of chainl)
15:33:09 <Cale> chainl1  :: GenParser tok st a -> GenParser tok st (a->a->a) -> GenParser tok st a
15:33:22 <Cale> (chainl1 p op x) parses one or more occurrences of p, separated by op Returns a value obtained by a left associative application of all functions returned by op to the values returned by p.
15:33:23 <palomer> so I unfactor the expression?
15:33:51 <Cale> perhaps it's just
15:34:36 <Cale> chainl1 term App
15:34:37 <Cale> ?
15:34:37 <palomer> expression = try letP <|> try caseP <|> chainl1 expression space App would not work
15:35:26 <palomer> they should have a chainl2 :P
15:35:31 <Cale> or possibly
15:35:36 <palomer> oh, but that still wouldn't work
15:35:47 <Cale> chainl1 term combiner
15:36:32 <Cale> (where combiner is how you wrote it)
15:37:25 <palomer> what about the seperator?
15:37:50 <Cale> what about it?
15:38:02 <Cale> you're not currently parsing separators explicitly there
15:38:23 <palomer> so what exactly is combiner?
15:38:45 <Cale> look in your code :)
15:39:16 <palomer> oh, right
15:39:35 <palomer> chainl1 still needs a seperator though
15:39:43 <palomer> it takes 3 arguments
15:40:12 <Cale> actually it doesn't
15:40:31 <palomer> (chainl1 p op x)
15:40:45 <Cale> yeah, that's a typo
15:40:50 <Cale> phone
15:41:06 <palomer> at 1am?
15:41:48 <Frederick> @localtime cajole 
15:41:48 <lambdabot> Local time for cajole is Mon Feb 27 05:59:32 2006
15:41:54 <Frederick> @localtime cale
15:41:58 <Frederick> @localtime Cale
15:42:00 <lambdabot> Local time for Cale is Mon Feb 27 00:59:43
15:42:02 <Frederick> dammit
15:45:08 <pundai> @localtime pundai 
15:45:09 <lambdabot> Local time for pundai is Sun Feb 26 22:02:56
15:45:39 <pundai> omg its right!
15:46:09 <palomer> it is
15:46:14 <palomer> cale doesn't live too far from me
15:46:20 <palomer> about a 4 hour drive
15:46:39 <pundai> i wish i lived that far from certain people
15:50:45 * palomer ponders studying the haskell parsec grammar
15:51:45 <pundai> how the hell is this working: foldr (max) 0 [1,2,3,4,5]
15:52:08 <pundai> i though tit expands to 1 max 2 max 3 max.. or osmething
15:52:36 <pundai> or is (+) really plus a b
15:52:38 <palomer> the grammar for types, patterns and terms is very, very similar
15:53:41 <pundai> can i trace into foldr somehow
15:54:07 <palomer> http://www.rafb.net/paste/results/jxsULz66.html
15:54:27 <palomer> pundai: you can do C-style (printf) tracing with Debug.Trace.trace
15:55:08 <sethk> palomer, there is also a trace in ghci, or maybe ghc that ghci can use, for run time?  I think?
15:55:12 <pundai> palomer, but how do i see the application of foldr
15:55:25 <palomer> pundai: you can also try hat
15:55:47 <palomer> sethk: trace is for run time
15:55:56 <palomer> oh, I see why my grammar doesn't work
15:55:57 <palomer> hmm
15:56:17 <sethk> palomer, I know, I meant that there is an alternative that shows you the internal state and the applications.
15:59:57 <palomer> whoa
16:00:00 <palomer> that would rock
16:00:03 <palomer> but that's exactly what hat does
16:00:08 <palomer> (I think)
16:00:51 <pundai> whats hat
16:04:57 <palomer> pundai: a program for tracing
16:05:07 <palomer> though sethk claims there's a tracing mechanism inside ghci
16:05:10 <palomer> which is really cool (if true)
16:05:23 <palomer> let a ((Just) 4) = 5 in a
16:05:27 <palomer> > let a ((Just) 4) = 5 in a
16:05:28 <lambdabot>  Parse error in pattern
16:05:34 <palomer> ok, see, that pattern is so valid
16:10:29 <pundai> can someone explain why unary minus does not apply before function  argument evaluation
16:10:38 <pundai> like square -10 is a type error of some sort
16:11:54 <sethk> can you continue a string onto another line?  something like "whatever"    (newline)    "some more"?
16:12:13 <ncalexan> pundai: http://hackage.haskell.org/trac/haskell-prime/ticket/50
16:14:46 <pundai> haha
16:14:53 <pundai> replace (-x) with negate x
16:14:55 <pundai> thats great
16:15:52 <pundai> i still dont understand *why* that decision was taken though
16:16:04 <pundai> to have this weird operator
16:16:33 <sethk> pundai, you mean to interpret -1 that way?  The haskell report explains it.
16:16:49 <sethk> pundai, I'm not being difficult, I'd tell you but i don't remember  :)
16:17:19 <pundai> ;)
16:17:35 <pundai> so haskell doesnt seem to ignore whitespace does it
16:17:46 <ncalexan> Is there a reason that import A, B, C is not supported?
16:17:48 <pundai> ah next paragraph: "Because haskell does not ignore whitespace..."
16:17:56 <sethk> pundai, there are two modes
16:18:05 <sethk> pundai, in one, white space is significant
16:18:16 <sethk> pundai, but you can also use {} and ; and make it insignificant
16:20:55 <pundai> hey.... function composition. coolio
16:57:35 <Excedrin> > runQ [| 3 |] >>= print
16:57:35 <lambdabot>  parse error on input `|'
16:57:45 <pundai> how do you get an int from the user
16:58:17 <ncalexan> pundai: maybe try one of the haskell IO tutorials?
16:58:26 <pundai> im reading one right now
16:58:39 <pundai> must be sleeping time
16:58:48 <ncalexan> @type getLine
16:58:49 <lambdabot> IO String
16:58:52 <ncalexan> In short: do { s <- getLine ; return $ (read s) :: IO Int }
16:59:04 <pundai> ah i forgot to do read
17:10:56 <Cale> @type readLn
17:10:57 <lambdabot> forall a. (Read a) => IO a
17:20:46 <pundai> whats this type: askForNums :: IO [Integer]
17:23:43 <pundai> ok maybe someone can answer http://rafb.net/paste/results/UR3gT835.html
17:26:36 <Cale> if you want to sum it inside askForNums you can just  return (num + rest)
17:27:16 <pundai> Cale, i want to do more than just sub too
17:27:23 <pundai> i want to do product and mean (for example)
17:27:24 <Cale> and the type will change from  IO [Integer]  (an IO action returning a list of integers) to  IO Integer  (an IO action returning an integer)
17:27:35 <Cale> okay, then returning the list is good
17:27:45 <pundai> ok so how do i maniupate it in main
17:27:49 <Cale> main = do xs <- askForNums
17:27:59 <Cale>           ...
17:28:16 <Cale> xs is then a list of integers
17:28:20 <Cale> which you can use normally
17:28:28 <Cale> (apply sum, product, etc.)
17:28:49 <pundai> why couldnt i use a let statement or something
17:29:00 <Cale> because you have to run the action
17:30:14 <Cale> let is for defining things which are essentially constants -- you're trying to define xs as the result of some interaction with the user, which is different
17:31:27 <Cale> the bindings in a 'let' aren't ordered in any particular way
17:31:36 <pundai> damn im still missing something
17:31:41 <Cale> can I see?
17:31:51 <Cale> well, you need to use xs somehow there
17:32:03 <Cale> like, the least you could do is to just
17:32:05 <pundai> main = do xs <- askForNums\n\tputStrLn "Hello" ++ show(head xs)
17:32:05 <Cale> print xs
17:32:23 <Cale> okay
17:32:32 <Cale> does it complain about syntax?
17:32:34 <pundai> "the last statement in a do construct must be an expression"
17:32:35 <pundai> yeah
17:32:51 <pundai> ok do\n
17:32:58 <pundai> damn whitespace happiness
17:33:04 <Cale> okay, the problem is that the putStrLn isn't indented to the same level as the xs <- askForNums
17:33:18 <Cale> you should definitely have your editor convert tabs to spaces
17:33:23 <pundai> i should
17:33:36 <pundai> except i just kicked years of spaces habits for favour of tabs
17:33:44 <Cale> tabs are treated as 8 spaces
17:34:08 <Cale> (otherwise)
17:34:17 <Cale> you can write
17:34:22 <Cale> main = do
17:34:32 <Cale>    xs <- askForNums
17:34:39 <Cale>    print x
17:34:41 <Cale> s
17:34:47 <Cale> (sorry, typo))
17:34:55 <Cale> (I'm a little sleepy :)
17:35:03 <pundai> ditto
17:35:14 <pundai> i just want to finish this example and go to bed
17:35:45 * ProfTeggy just entered the office :-)
17:36:12 <ProfTeggy> If this isn't globalization, then what is it?
17:36:16 <MarcWeber> Good morning. How can I check wether two values are exactly of the same type? I want to implement the Eq class for an existancial type which implements a Class Dep
17:36:17 <Cale> If you put the first line of the do right after the 'do' on the same line, then you're forced to line the rest of the block up with it (at least to that level, or less)
17:36:18 <pundai> this is the interweb
17:36:34 <Cale> MarcWeber: I don't think you can.
17:36:42 <Cale> (in general)
17:36:56 <Cale> Once you put something inside an existential, you lose its type.
17:37:24 <Cale> you could use the Typeable class
17:37:57 <Cale> @type Data.Typeable.typeOf
17:37:58 <lambdabot> forall a.
17:37:58 <lambdabot>         (Data.Typeable.Typeable a) =>
17:37:58 <lambdabot>         a -> Data.Typeable.TypeRep
17:38:41 <Cale> which will give you a representation of the type of the thing, which can be stored alongside it. Use a smart constructor to build the values along with their types.
17:39:07 <Cale> however, this still doesn't quite solve your problem
17:39:40 <Cale> since even if you know that their TypeReps matching means that they're the same type, the compiler certainly doesn't.
17:40:00 <Cale> You could use Data.Dynamic
17:41:06 <Cale> hmm
17:41:33 <Cale> but it's hard to keep the guarantee that the types are in Eq at all
17:41:57 <ncalexan> what is \p xs -> (takeWhile p xs, dropWhile p xs) called?
17:42:16 <Cale> > span (< 5) [1..10]
17:42:16 <lambdabot> ([1,2,3,4],[5,6,7,8,9,10])
17:42:21 <Cale> span :)
17:42:27 <ncalexan> Cheers.
17:42:56 <MarcWeber> Cale: This is exactly my problem. I want to be able to compare instances of the dep class. http://www.rafb.net/paste/results/nwlpTe39.html
17:42:56 <Cale> MarcWeber: basically, what you're asking for is hard -- you're telling the compiler to forget about something at compile time, and then wanting it back at runtime. Types are essentially a compile-time construct.
17:44:52 <Saulzar> You could use something like Typeable
17:44:53 <Cale> see, the existential is constructed by only storing the dictionaries for those classes you asked for. The type itself is gone at runtime
17:45:46 <Cale> So there's no way to tell if two values actually came from the same type and were thus comparable for equality.
17:45:51 <MarcWeber> Can you recommend some stuff to read about Data.Dynamic?
17:46:08 <Cale> The GHC documentation -- it's really fairly simple
17:46:26 <Cale> you have toDyn
17:46:40 <MarcWeber> Thanks.. Be back in some minutes (after having read that stuff)
17:46:45 <Cale> that turns a value of any Typeable type a into a value of type Dynamic
17:46:58 <Cale> actually, I'm unsure if Dynamic will help
17:47:27 <Cale> there's no instance of Eq for Dynamic
17:47:47 <Saulzar> Typeable by itself would give you Eq for types though
17:47:58 <Cale> it gives you type equality
17:48:02 <audreyt> overtime by 20min, but yay I survived.
17:48:05 <audreyt> slides: http://xrl.us/j72t
17:48:22 <MarcWeber> "Only storing the dictionary by those classes" .. Do you mean a data structure containing function references?
17:48:28 <Cale> but having that type equality in a Bool at runtime is not the same as having it as a compile-time piece of knowledge
17:48:34 <Cale> MarcWeber: exactly
17:48:38 <shapr> shazam!
17:48:47 * shapr has switched back to xemacs, yay!
17:49:02 <Cale> Basically, if you have data Showable = forall t. Show t => Showable t
17:49:16 <pundai> ok what am i doing wrong again http://rafb.net/paste/results/Vv4WTv76.html
17:49:27 <Cale> then what it stores is a pair of each value with an implementation of show
17:49:30 <pundai> i know it has something to do with the type of xs, but ...
17:49:55 <shapr> hellish: hey echo, ltns
17:49:55 <Cale> pundai: map factorial xs is a list
17:50:05 <Cale> perhaps you want to apply print to that list
17:50:11 <hellish> shapr: hey!
17:50:12 <Cale> (you need to put an action there)
17:50:17 <shapr> hellish: How's code?
17:50:39 <pundai> so it is
17:50:57 <hellish> shapr: I've been busy getting confused about STM today.
17:51:15 <shapr> How do you like it so far?
17:51:19 <pundai> ok so how can i apply a function that doesnt return anything to a list
17:51:30 <Cale> hm?
17:51:39 <Cale> you want
17:51:43 <pundai> like apply myprintfunction mylist
17:51:44 <Cale> print (map factorial xs)
17:51:49 <Cale> or
17:52:03 <MarcWeber> Cale: what does ghc store exactly? only the function references? or for each function some "have result computed yet?" + result + function reference if not because of lazy evaluation?
17:52:11 <Cale> mapM (print . factorial) xs
17:52:19 <pundai> whats mapM
17:52:28 <shapr> I wish I could use STM everywhere. It's a great way to beat deadlock. I'm still not sure if it'll work as well in a distributed situation though.
17:52:37 <Cale> @type Control.Monad.mapM
17:52:37 <lambdabot> forall b (m :: * -> *) a.
17:52:37 <lambdabot>         (Monad m) =>
17:52:37 <lambdabot>         (a -> m b) -> [a] -> m [b]
17:52:46 <Cale> okay
17:52:55 <Cale> so it takes an (a -> IO b) function
17:52:58 <Cale> and a list of a's
17:53:08 <hellish> shapr: As I understand it, it's magic for transactional interactions between threads, which I would probably be more excited about if I had gone through being frustrated by having to manual locks before reading about it.
17:53:13 <Cale> and it applies the function to each value of the list, getting an action
17:53:19 <Cale> then it runs those actions in sequence
17:53:37 <pundai> \o/
17:54:08 <pundai> and now i can go to sleep
17:54:16 <Cale> MarcWeber: It stores a dictionary of the methods for each of the classes together with a lazy value like it normally would.
17:54:17 <pundai> thank you very much for your help Cale 
17:54:22 <Cale> pundai: no problem :)
17:54:26 <shapr> hellish: You could always try implementing the same functionality in Java first =)
17:54:36 <ncalexan> shapr: hehe... that's fun stuff.
17:55:33 <shapr> I learned about multithreading from VB magazines.. anyone remember the apartment threading model?
17:55:34 <pundai> if only i didnt ever have to see a for loop again
17:55:51 <pundai> shapr, you sure you want to admit to that :D
17:56:13 <shapr> Hey, I'm old.. and my reputation is already stained beyond repair ;-)
17:56:24 <pundai> eheh
17:56:31 <MarcWeber> Cale: I need something like this: uptoDate? if not update? upToDate? Can you give me a keyword to force reevaluation of the lazy update value? Of cause everything is of type IO ()
17:56:46 <pundai> anyway map goodnightkiss #haskell
17:56:59 <shapr> And remember, lambdabot loves you!
17:57:07 <Cale> MarcWeber: everything in Haskell is a constant
17:57:42 <Cale> either it's been evaluated or it hasn't
17:57:54 <Cale> A lazy value is really a pointer to some code
17:58:02 <shapr> After VB, I did multithreading in Java, Python, and Haskell. imho, STM is at least a bronze bullet...
17:58:25 <Cale> the first time that it's forced, this code is run and updates the pointer with a pointer to a trivial piece of code that returns the computed value
17:59:13 * Saulzar has a multi-threaded program with too many bugs to count
17:59:25 <Cale> (an alternate mechanism sets a flag, and sets the pointer directly to the computed value)
17:59:29 <Saulzar> Pthreads and C, oh dear :)
17:59:33 <shapr> Saulzar: Tried STM?
18:00:17 <Saulzar> Nope, but I haven't done anything with threads in Haskell much.
18:00:54 <MarcWeber> Cale: in which way did you learn that stuff? Reading books about the topic: How to implement lazy languages?
18:01:09 <Cale> the STG machine paper
18:01:30 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
18:02:58 <ProfTeggy> I also recommend http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
18:03:13 <ProfTeggy> It's the free source for a complete book on implenting lazy FP
18:03:55 <ProfTeggy> (by SPJ and David Lester)
18:04:16 <MarcWeber> Will be a lot of pages to read..
18:06:04 <ProfTeggy> It's worth it, I guess.
18:06:09 <shapr> Alternatively, implement your own three instruction machine and G-machine.
18:06:29 <shapr> Alternately? hmmm
18:06:46 * shapr figures Haskell is alternative anyway... but probably not emo
18:07:43 <Cale> It's funktional
18:07:46 * shapr grins
18:07:51 <MarcWeber> emo?
18:09:01 <Cale> MarcWeber: it's a strange music-oriented subculture
18:10:04 <Cale> http://en.wikipedia.org/wiki/Emo_%28music%29  http://en.wikipedia.org/wiki/Emo_%28slang%29  those should give some idea.
18:10:30 <Maddas> Hey there, shapr!
18:10:46 <shapr> hiya Maddas, what's up?
18:11:03 <Maddas> A preposit.. never mind ;-)
18:11:20 <Maddas> shapr: Looks like I'll be in Chalmers for a semester!
18:11:21 <MarcWeber> I see: There is toDyn and fromDyn(amic)... I could hardcode Eq type for my instances eq dyn1 dyn2= isNotNothingAndEqual ( (fromDynamic dyn1) :: ( MayBe class1)  (fromDynamic dyn2) or isNot[..] ::(MayBe class2) ...
18:12:03 <Cale> MarcWeber: yeah, if you know the type you want beforehand
18:12:13 <Cale> then you'll be able to extract them and compare them
18:12:25 * Maddas hopes he'll get to take cool courses :-)
18:12:35 <shapr> Maddas: nifty!
18:12:38 <Maddas> Indeed
18:12:41 <shapr> When will you be there?
18:12:59 <Maddas> Next year from January to ~May, Quarters 3-4.
18:13:04 <MarcWeber> There are only two.. (by now) . Lets check Typeable
18:13:14 <shapr> I'm moving to Stockholm this summer, maybe we can organize a #haskell meeting in Gothenburg.
18:13:43 <Maddas> shapr: Woot, neat!
18:13:58 <Maddas> shapr: I could also go to KTH in Stockholm, but Chalmers sounds so tempting :-)
18:14:03 <shapr> Try to get into one of John Hughes' advanced functional programming courses, if you can.
18:14:22 <Maddas> Indeed. I'll have to get my hands on someone to bug about schedules, though.
18:14:23 <shapr> Depends on your interests I think. Chalmers has a much more functional flavor.
18:14:25 <MarcWeber> Would it be possible to implement EQ for dynamic types ?
18:14:26 <Cale> MarcWeber: If there's only two, why not just make a custom datatype?
18:14:31 <Maddas> shapr: Yeah, that's why :-)
18:14:45 * Maddas already looked at John Hughes' personal page to see all courses he gives
18:15:30 <shapr> I'm looking forward to living in the south close to all the funktional and type theory folks. It'll be great!
18:15:37 <Maddas> :-D
18:15:46 * Maddas is also looking forward to visiting Sweden
18:15:52 <MarcWeber> Cale because I wouldn't have learned about Dynamic.. ;-)
18:15:57 <Maddas> Though the rooms offered by Chalmers seem to be very expensive.
18:15:58 <Cale> hehe
18:16:13 <Cale> okay, I think I'm going back to bed
18:16:19 <ncalexan> bed time for Nick.  Ciao everyone.
18:16:23 <shapr> polyphasic sleeping?
18:16:32 <Maddas> Heh.
18:16:33 <vincenz> hi
18:16:44 <Cale> yeah, this is Phase III
18:16:48 <shapr> salut christophe
18:17:08 <shapr> Maddas: Can you get a cheaper room off campus?
18:17:09 <Cale> and Civilization Phaze III is a good album :)
18:17:11 <vincenz> shapr: salut
18:17:20 <Maddas> shapr: The campus one *is* the very expensive one...
18:17:26 <vincenz> Anyone know the forall symbol in latex?
18:17:36 * Maddas will look around (which means bothering people from Gotheburg), though.
18:17:37 <Cale> \forall \fa ?
18:17:38 <MarcWeber> Cale: Thanks! Have nice dreams
18:17:42 <vincenz> Cale: ah thx :D
18:17:53 <Cale> vincenz: it's one of those two
18:18:40 * vincenz mutters
18:19:01 <shapr> If you use emacs, preview-latex is really useful.
18:19:06 <vincenz> Don't you just hate people
18:19:12 <vincenz> STL has Set and MultiSet
18:19:14 <vincenz> Set : Unique Values
18:19:18 <vincenz> so what does that make multiset?
18:19:22 <vincenz> Multiple Unique Values?
18:19:24 <vincenz> seems contradictory
18:19:40 <Cale> vincenz: multisets are a standard mathematical object
18:19:46 <vincenz> yeah but how do you explain that
18:19:49 <shapr> I rather like people.
18:19:55 <vincenz> "Multiple Unique Values"?
18:20:02 * Maddas tries his best to like people :-)
18:20:06 <MarcWeber> Cale. You are right.. I could also implement show and compare the results.. *g* would be the fastest way
18:20:16 * vincenz is peoplofoid
18:20:17 <Cale> "Unique Values" is a poor explanation of sets to begin with
18:20:19 <Maddas> Anyway, now to take care of more pressing university matters (upcoming exams). Later!
18:20:27 * shapr waves
18:20:29 * shapr goes back to work.
18:20:37 <vincenz> Cale: how's that?
18:21:07 <Cale> Well, if it was all you had to go on, you'd be pretty lost :)
18:21:19 <Cale> It doesn't even use the word "collection"
18:21:26 <vincenz> well obviously
18:21:29 <vincenz> collection of unique values
18:21:42 <Cale> A multiset then is just a collection of values
18:21:52 <Cale> unordered, if you want to be specific
18:22:05 <vincenz> yeah I guess
18:22:11 <vincenz> but unordered is not a specificity
18:22:22 <vincenz> ordered should be the specificity of multisorted set
18:22:33 <Cale> hm?
18:22:36 <Cale> that's a list
18:22:46 <vincenz> o.O
18:22:49 <vincenz> no it's not
18:22:54 <vincenz> it can be implemented as a list
18:23:07 <Cale> same thing :)
18:23:11 <vincenz> not quite
18:23:17 <Cale> (up to isomorphism)
18:24:07 <Cale> or perhaps I should say, up to natural transformation
18:24:15 <Cale> natural isomorphism?
18:24:26 <Cale> whatever :)
18:24:38 <vincenz> :)
18:25:17 <Cale> If you're recording the order of the values, you're allowed to repeat them as many times as you like, or not include them at all, then you have a list :)
18:25:42 <vincenz> you have a list of values
18:25:47 <vincenz> but not every list is a multisorted set
18:25:56 <vincenz> a list in it's more general case is a sequence
18:26:03 <vincenz> just like an array or a vector (in STL parlance)
18:26:04 <Cale> perhaps I don't know what you mean by multisorted set then
18:26:41 <vincenz> lists are positional
18:26:44 <vincenz> multisortedsets are not
18:26:54 <Cale> A list is a function from an ordinal to a given set.
18:26:57 <Cale> :)
18:26:58 <vincenz> right
18:27:03 <vincenz> notice the point of "oridinal"
18:27:08 <vincenz> aka it's an associative collection
18:27:15 <vincenz> multisorted sets are not associative collections
18:27:33 <Cale> Okay, give me an example of a multisorted set?
18:28:00 <vincenz> Cale: I know what you're gonna say
18:28:05 <vincenz> "you can number them'
18:28:08 <vincenz> the point is
18:28:14 <vincenz> that multisorted set implementations do not require this
18:28:18 <Cale> sorry
18:28:22 <vincenz> while positional associative containers do
18:28:32 <Cale> Perhaps I don't know what a multisorted set is
18:29:08 <Cale> I figured that what you mean is a multiset with an ordering on the elements.
18:29:15 <vincenz> correct
18:29:24 <vincenz> however
18:29:33 <vincenz> elements don't have a position
18:29:39 <vincenz> they do once you implement it
18:29:39 <Cale> Now, do all equal elements have to occur together?
18:29:44 <vincenz> but this is a concrete thing
18:29:46 <vincenz> not part of the abstract spec
18:29:54 <vincenz> Cale: that's undefined
18:29:58 <Cale> hm?
18:30:08 <vincenz> Cale: that's implementation details
18:30:11 <vincenz> from the interface point of view
18:30:12 <Cale> no it's not
18:30:33 <Cale> It's the difference between having something like (a,b,a) and not having it.
18:30:57 <vincenz> Cale: that's cause you keep thinking of it as a list
18:31:12 <Cale> Well, I'm trying to see if it's actually the same as a list or not
18:31:17 <vincenz> the elements are ordered
18:31:19 <vincenz> but not their positiion
18:31:30 <vincenz> it would be {a,a,b}
18:31:33 <vincenz> which == {a,b,a}
18:31:43 <vincenz> err wait
18:31:44 <vincenz> sorted
18:31:48 <vincenz> so {a,a,b}
18:31:48 <Cale> hm?
18:31:49 * vincenz ocughs
18:31:50 <vincenz> nm
18:31:52 <vincenz> anyways
18:31:57 <vincenz> let me finish my drawing and text
18:32:04 <Cale> I'm going to sleep :)
18:32:08 <vincenz> okies
18:32:10 <vincenz> sleep well
18:32:18 <vincenz> I'll get back to you :)
18:32:20 <Cale> I haven't been talking about implementation at all
18:32:38 <ski> (Cale : natural isomorphism, yes)
18:32:43 <Cale> yeah
18:32:54 <Cale> up to natural isomorphism :)
19:38:02 <MarcWeber> What is wrong here?
19:38:02 <MarcWeber> newtype VirtualTarget=VirtualTarget{ targetName::String; dependencies::[DepObj]}
19:38:09 <MarcWeber> Parse error on input ";"
19:39:01 <eivuokko> Change newtype to data, and ; to ,?
19:41:16 <MarcWeber> eivuokko Each data declaration is new type by default?
19:41:31 <eivuokko> Yeah..
19:41:39 <eivuokko> newtype is optimisation
19:41:57 <MarcWeber> I did use newtype here because I got another problem when using circlic data definitions like this data A = (String,[A]) .. Here newtype did work..
19:42:15 <eivuokko> Huh.
19:42:35 <MarcWeber> Perhaps I should look it up again..
19:42:44 <eivuokko> That has bad syntax, no data ctor name, but otherwise it should work.
19:43:03 <Saulzar> That's because (String, [A]) is one type
19:46:50 * shapr boings
19:46:54 <shapr> wassup?
19:47:13 <shapr> eivuokko: Hey, do you actually use darcs-cgi-push?
19:47:24 <eivuokko> Yes
19:47:33 <shapr> Neat, how do you like it?
19:47:49 <eivuokko> Much better than ssh-pipe :)
19:48:04 <shapr> heh
19:48:32 <MarcWeber> Oh.. I can't reproduce that cyclic error.. mmhmm.
19:49:00 <eivuokko> MarcWeber, I bet it was a typo or something.  Cyclic datas are common idiom.
19:52:18 <ski> (possibly it was with 'type')
19:53:15 <MarcWeber> ski You are right.. Possibly I should have slept more than 5h tonight?
19:53:35 <ski> maybe
19:54:03 * ski slept ca 14.5 hours
19:54:08 <shapr> wow
19:54:20 <ski> (but i was awake 30 hours before that)
20:04:28 <shapr> So, anything exciting going on today?
20:20:53 <shapr> I guess not.
20:21:01 <shapr> @quote Oleg
20:21:01 <lambdabot> Oleg hasn't said anything memorable
20:21:04 <shapr> @quote oleg
20:21:04 <lambdabot> oleg hasn't said anything memorable
20:21:10 <shapr> @remember oleg The implementation of RSA on type level is left for future work.
20:21:15 <shapr> @quote oleg
20:21:15 <lambdabot>  The implementation of RSA on type level is left for future work.
20:21:35 <fluxx> "is left as a reader excercise"
20:21:44 <shapr> yeah.
20:21:58 <shapr> Oleg is a source of good quotes.
20:22:23 <MarcWeber> I encountered this task some times now. apply one function f1 to a::A b::A and call another function f2 with the result. Does a function applyapply f2 f1 a b exist doing this? I've been thinking about using a combination of uncurry and some kind of map for tuples.. but that doesn't seem to exist..
20:22:55 <shapr> hiya roconnor 
20:23:07 <earthy> marcweber:  so,   f1 has type A -> A -> B, and f2 has type B -> C ?
20:23:08 <Saulzar> MarcWeber, Take a look at function composition (.)
20:23:17 <shapr> Yeah, I was going to ask if you've tried (.)
20:23:21 <earthy> then you want   f2 . f1
20:23:38 <roconnor> shapr: Hey.  Where do I go to learn what the big deal about GADTs is?
20:23:48 <MarcWeber> I want f2 (f1 a) (f2 a) 
20:23:57 <MarcWeber> oh a lot easier that way.. ;-)
20:23:59 <earthy> :type (f2 :: b -> c) . (f1 :: a -> a -> b)
20:24:06 <earthy> hm...
20:24:08 <shapr> roconnor: There's some recent discussion on LtU that covers exactly that.
20:24:13 <earthy> @type (f2 :: b -> c) . (f1 :: a -> a -> b)
20:24:14 <lambdabot> Not in scope: `f2'
20:24:14 <lambdabot>  
20:24:14 <lambdabot> <interactive>:1:18: Not in scope: `f1'
20:24:17 <earthy> hm. right. :)
20:24:38 <shapr> roconnor: But type niftiness aside, they're really great for newbies, because type constructors have explicit types now.
20:24:43 <earthy> MarcWeber: huh?   f2 (f1 a) (f2 a) ?
20:24:56 <earthy> what would the type for f2 be?
20:25:11 <MarcWeber> No, typo of cause f2 (f1 a) (f1 b)
20:25:18 <shapr> roconnor: The first example you'll see is the AST with and without GADTs...
20:25:20 <earthy> ah. right.
20:25:20 * shapr gets example
20:25:28 <earthy> so f1 :: a -> b   f2 :: b -> b -> c
20:25:32 <roconnor> shapr: The specification is like (co-)inductive types in coq, but I want to know what the extra expressiveness gives?
20:25:54 <shapr> roconnor: http://www.scannedinavian.com/~shae/gadt/
20:26:37 * roconnor wonders if he can convince mozilla to open text/x-haskell in the browser
20:27:12 <MarcWeber> earthy exactly.. So I need a function f :: f1 -> f2   where f f2 f1 a b=f2 (f1 a) (f2 b). Does this already exist?
20:27:27 <shapr> roconnor: http://lambda-the-ultimate.org/node/1293
20:27:28 <earthy> (you're making typos again)
20:27:45 <shapr> roconnor: That's a mimetype problem on my server, but I'm shutting down that server in three days, so no point in fixing it now.
20:27:56 <MarcWeber> yes I am .. 
20:28:17 <MarcWeber> My brian likes counting a lot .. ;-(
20:28:33 <roconnor> shapr: the mime type is reasonable, maybe mozilla ought to open text/* in the browser if it can't reconginise the type
20:29:04 <roconnor> The darcs slides say that GADTs can be used to enforce properties
20:29:43 <ski> @type \f2 f2 a b -> f2 (f1 a) (f2 b)
20:29:44 <lambdabot>   Conflicting definitions for `f2'
20:29:44 <lambdabot>   In a lambda abstraction
20:29:55 <shapr> From what I've read, GADT-power goes beyond what HM can infer. Haskell and all post-Haskell languages are trying to figure out how to mix type inference and heavy duty expressiveness.
20:29:59 <ski> @type \f2 f1 a b -> f2 (f1 a) (f2 b)
20:29:59 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:29:59 <lambdabot>   Expected type: t -> t1
20:30:08 <MarcWeber> ski Typo. The last should be f1, too
20:30:16 <ski> ah
20:30:20 <shapr> roconnor: Well yeah, look at the those two AST demo files.
20:30:40 <MarcWeber> s/Typo/my typo/
20:30:50 <shapr> But GADTs for enforcing props is sort of like monads for IO. It's just one thing you can do with 'em.
20:32:35 <earthy> MarcWeber: no, there's nothing in the prelude that will directly do what you want.
20:32:48 <shapr> Philippa's comment on that LtU GADTs thread is something I'd like to know more about...
20:33:15 <ski> > let f2 = uncurry (++); f1 = reverse in   f2 . join (&&&) f1  $ "foo"
20:33:16 <lambdabot> "oofoof"
20:34:46 <shapr> roconnor: Hey, did we finish that discussion about operating on obfuscated data?
20:35:29 <shapr> roconnor: I think you should teach a CG course using hscairo :-)
20:36:01 <roconnor> shapr: In other news, this weekend I have had fun making all sorts of multiplication operators for my Clifford algebra implementation.  I'm having way too much fun with it.
20:36:32 <roconnor> I thought about cairo, and may use it to some extend.
20:36:42 <roconnor> but typically CG is a raster graphics course
20:37:02 <shapr> Doesn't cairo do raster?
20:37:09 * shapr is nearly clueless about cairo
20:37:09 <roconnor> does it?
20:37:20 <shapr> xerox: ping? Does cairo do raster?
20:37:27 <dcoutts> cairo does compositing
20:37:30 <roconnor> I'm also clueless.  I understood it was a vector graphics library.
20:37:36 <dcoutts> what do you mean by raster exactly?
20:37:42 <shapr> bitmap, yeah?
20:37:43 <roconnor> pixels!
20:37:44 <josator> hi
20:37:47 <josator> @
20:37:47 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
20:37:47 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
20:37:47 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
20:37:47 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
20:37:47 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
20:37:49 <lambdabot> [8 @more lines]
20:37:52 <shapr> hola josator 
20:37:56 <josator> como
20:38:00 <shapr> muy bien..
20:38:03 <shapr> as always!
20:38:04 <josator> le meto funciones al lambda bot?
20:38:08 <josator> hi
20:38:08 <dcoutts> roconnor, cairo doesn't do individual pixel poking
20:38:10 <josator> sorry
20:38:30 <josator> @last "asdfasdfad"
20:38:31 <lambdabot> Maybe you meant: fact lam part paste
20:38:33 <shapr> @babel es en le meto funciones al lambda bot?
20:38:34 <lambdabot>  I put functions to him to lambda bot?
20:38:34 <josator> mmm
20:38:43 <josator> @last "asdfasdfad"
20:38:44 <lambdabot> Maybe you meant: fact lam part paste
20:38:50 <shapr> What are you trying to do?
20:38:54 <josator> last "asdfasdfad"
20:38:56 <earthy> >last "asdfasdfasd"
20:39:01 <earthy> > last "asdfasdfasd"
20:39:02 <lambdabot> 'd'
20:39:09 <shapr> ah, you want the interactive Haskell?
20:39:11 <josator> > last "asdfasdf"
20:39:11 <lambdabot> 'f'
20:39:11 * earthy still hasn't gotten the hang of that. ;)
20:39:15 <josator> yes
20:39:27 <josator> no but
20:39:35 <josator> i have made a function
20:39:41 <dcoutts> roconnor, gtk2hs supports using a Pixbuf as a Haskell mutable array. One can use that for pixel poking and then display it on screen or use it further, eg with cairo.
20:39:44 * roconnor likes fundeps
20:39:47 <josator> how can i pass it to lambdabot
20:39:53 <josator> with the arguments
20:40:12 <josator> ok
20:40:17 <sieni_> > (\x y -> x + y) 5 13
20:40:18 <lambdabot> 18
20:40:20 <josator> @help
20:40:21 <lambdabot>  @help <command> - ask for help for <command>
20:40:37 <sieni_> > let foo x y = x + y in foo 5 13
20:40:39 <lambdabot> 18
20:41:14 <josator> > (\x y -> x + y) in (\x y -> x + y) 2 3
20:41:15 <lambdabot>  parse error on input `in'
20:41:29 <josator> > (\x y -> x + y) in \x 2 3
20:41:29 <lambdabot>  parse error on input `in'
20:41:32 <josator> > (\x y -> x + y) in x 2 3
20:41:32 <lambdabot>  parse error on input `in'
20:41:37 <josator> > (\x y -> x + y) 2 3
20:41:37 <lambdabot> 5
20:41:46 <josator> prefi
20:41:48 <josator> x
20:41:48 <josator> xx
20:42:12 <josator> i am in a haskell practice
20:42:22 <josator> at university
20:42:27 <josator> ~~~~
20:43:07 <ski> nice
20:43:22 <earthy> josator:
20:43:34 <ski> josator : do you have any specifc question, right now ?
20:43:43 <josator> no
20:43:45 <josator> XD
20:43:48 <josator> well
20:43:58 <earthy> just try installing Helium
20:44:00 <ski> > let f = (\x y -> x + y) in f 2 3
20:44:01 <earthy> or ghci
20:44:01 <lambdabot> 5
20:44:08 <josator> hellium
20:44:09 <ski> > let f x y = x + y in f 2 3
20:44:10 <lambdabot> 5
20:44:13 <josator> but i use ghci
20:44:16 <josator> and linux
20:44:17 <josator> XD
20:44:20 <earthy> ah, you use ghci
20:44:25 <josator> yes
20:44:30 <earthy> in that case. :)  the >  is just a call to ghci
20:44:31 <josator> is better isn't it?
20:44:45 <earthy> nope
20:44:48 <josator> but i can not load my modules
20:44:52 <earthy> ah
20:44:59 <josator> is better hellium?
20:45:09 <ski> better for whom ?
20:45:19 <earthy> helium is easier to learn haskell with
20:45:26 <earthy> as it provides clearer error messages
20:45:31 <earthy> but it does not implement all of haskell
20:45:39 <earthy> ('98)
20:45:43 <ski> helium also doesn't have all features of full haskell
20:45:45 <ski> ya
20:46:03 <ski> josator : have you tried ":load MyFile.hs" ?
20:46:12 <josator> with lambdabot?
20:46:16 <ski> with ghci
20:46:16 <josator> no
20:46:19 <josator> yes
20:46:22 <josator> it works
20:46:30 <ski> <josator> but i can not load my modules
20:46:33 <ski> type error ?
20:46:34 <josator> i can't with lambadabot
20:46:40 <ski> (right)
20:46:46 <josator> sumatorio :: Int -> Int -> Int
20:46:46 <josator> sumatorio a a = a
20:46:46 <josator> sumatorio a b
20:46:46 <josator> 	| a > b     = 0
20:46:46 <josator> 	| a < b     = a + sumatorio (a+1) b
20:46:47 <josator> 	| otherwise = a
20:46:50 <josator> this is ok?
20:47:19 <ski> think so
20:47:23 <earthy> looks fine
20:47:32 <Lemmih> It's not.
20:47:52 <earthy> there's superfluous code
20:47:54 <josator> sumatorio :: Int -> Int -> Int
20:47:54 <josator> sumatorio a b
20:47:54 <josator> 	| a > b     = 0
20:47:54 <josator> 	| a < b     = a + sumatorio (a+1) b
20:47:54 <josator> 	| otherwise = a
20:48:01 <ski> Lemmih : when does it not work ?
20:48:20 <Lemmih> ski: 'let f a a' is invalid haskell code.
20:48:23 <ski> yes
20:48:24 <josator> i have to make the sumatory from an integer value to another
20:48:36 * ski 's been thinking in prolog, today ..
20:49:09 <oberon> bah i hate carnival:)
20:49:55 <josator> ey
20:50:03 <josator> what superflous code
20:50:04 <josator> !
20:50:06 <josator> XD
20:50:48 <Lemmih> It's more than superfluous, it's erroneous.
20:50:56 <earthy> josator: the  sumatoria a a = 0     was even erroneous
20:50:57 <josator> it works
20:51:07 <josator> 	| a >  b    = 0
20:51:07 <josator> 	| a == b    = a
20:51:07 <josator> 	| otherwise = a + sumatorio (a+1) b
20:51:10 <earthy> that works
20:51:13 <josator> sumatorio :: Int -> Int -> Int
20:51:14 <josator> sumatorio a b
20:51:14 <josator> 	| a >  b    = 0
20:51:14 <josator> 	| a == b    = a
20:51:14 <josator> 	| otherwise = a + sumatorio (a+1) b
20:51:17 <josator> yes
20:51:26 <josator> sumatoria 3 6
20:51:35 <josator> 18
20:51:43 <ski> maybe earthy refers to that it checks 'a > b' every time, but it's not needed
20:52:15 <josator> i should put it the last?
20:52:26 <earthy> oh, I didn't even look at the logic
20:52:32 <ski> no
20:52:34 <earthy> and assumed that    sumatorio a a = a    was valid
20:52:37 <josator> no but ski is right
20:52:44 <josator> i always check that
20:52:49 <josator> and is not necesary
20:52:54 <ski> to avoid that, you can use a helper function that recurses
20:52:59 <josator> wait
20:53:15 <ski> and only check 'a > b' in the wrapper function, not in the wroker (= helper)
20:53:52 <ski> (i assume that ghc has no magic optimisation to do this ..)
20:53:59 <josator> sumatorio :: Int -> Int -> Int
20:53:59 <josator> sumatorio a b
20:53:59 <josator> 	| a == b    = a
20:53:59 <josator> 	| a < b = a + sumatorio (a+1) b
20:53:59 <josator> 	| otherwise = 0
20:54:21 <josator> sumatorio :: Int -> Int -> Int
20:54:21 <josator> sumatorio a b
20:54:21 <josator> 	| a == b    = a
20:54:21 <josator> 	| a < b     = a + sumatorio (a+1) b
20:54:21 <josator> 	| otherwise = 0
20:54:27 <ski> that's not really better
20:54:46 <josator> it checks the thing the last time
20:55:05 <ski> if you initially check for 'a > b', then if that's not the case you only needs to check one of 'a == b' and 'a < b' each time later
20:55:37 <ski> so, you should just need one comparision for each round (and one initial comparision before the loop)
20:55:45 <ski> do you know about 'where' ?
20:55:51 <josator> yes
20:56:04 <josator> bbut now
20:56:13 <ski> you can make a helper/worker function, that you put in 'where', that recurses
20:56:21 <josator> the a > b is the last
20:56:25 <josator> is in the otherwise
20:56:26 <ski> no
20:56:35 <ski> 'otherwise' is no comparision
20:56:35 <josator> that is not ok?
20:56:39 <ski> it's just a catch-all case
20:56:44 <earthy> sumatorio a b = case (compare a b) of { LT -> a + sumatorio (a+1) b; EQ -> a ; GT -> 0 }
20:56:54 <ski> sure you don't call 'a > b' anywhere
20:57:00 <josator> no
20:57:05 <josator> but can happen
20:57:29 <ski> but now you call both 'a == b' and 'a < b' for all rounds, but final round
20:58:04 <josator> final round is a==b
20:58:05 <ski> (earthy : parens around scrutinized expression in 'case' is not needed)
20:58:18 <ski> yes, but it checks that all previous rounds, too
20:58:30 <ski> so, still 2 comparision at (almost) all rounds
20:58:48 <ski> (this is of course nit-picking, btw)
20:58:51 <earthy> :)
20:59:07 <ski> i'm sure your two last versions would do fine
20:59:25 <josator> yes
20:59:26 <josator> but
20:59:27 <ski> if you want to avoid comparing twice each round, though ..
20:59:32 <josator> yess
20:59:59 <ski> shall i say it ?
21:00:03 <josator> ok
21:00:05 <ski> .. you can check 'a < b' first
21:00:16 <josator> sumatorio :: Int -> Int -> Int
21:00:16 <josator> sumatorio a b
21:00:16 <josator> 	| a < b     = a + sumatorio (a+1) b
21:00:16 <josator> 	| a == b    = a
21:00:16 <josator> 	| otherwise = 0
21:00:19 <josator> yes
21:00:20 <josator> XD
21:00:32 <josator> XDDD
21:00:36 <ski> see how this does one check on recursive rounds ?
21:00:42 <josator> sure
21:00:49 <josator> nice
21:00:50 <ski> another way would have been to do
21:01:00 <ski> sumatorio :: Int -> Int -> Int
21:01:06 <ski> sumatorio a b
21:01:25 <ski>   | a > b     = 0
21:01:31 <ski>   | otherwise = loop a b
21:01:34 <ski>   where
21:01:37 <ski>   loop a b
21:02:01 <ski>     | a == b    = a
21:02:10 <ski>     | otherwise = a + loop (a+1) b
21:02:35 <josator> i think 
21:02:40 <josator> sumatorio :: Int -> Int -> Int
21:02:41 <josator> sumatorio a b
21:02:41 <josator> 	| a < b     = a + sumatorio (a+1) b
21:02:41 <josator> 	| a == b    = a
21:02:41 <josator> 	| otherwise = 0
21:02:46 <josator> makes less comparisons
21:02:54 <ski> (you can of course change order of last two lines in 
21:02:54 <josator> at all
21:02:59 <ski> 'loop' if you want)
21:03:16 <josator> ahh ok
21:03:22 <ski> no, same number
21:03:36 <josator> well is better when
21:03:44 <ski> (so in this case, i think that is nicer, yes)
21:03:47 <josator> you acomplish a> b
21:04:09 <ski> earthy's version is also good
21:04:28 <josator> i have not studied case
21:04:35 <ski> hm .. not sure how many comparisions 'compare' usually takes on e.g. 'Int's
21:04:35 <josator> is in hellium?
21:04:41 <josator> the case 
21:04:42 <ski> i would think so
21:04:43 <josator> ?
21:04:46 <ski> it's in haskell98
21:05:13 <ski> sumatorio a b = foo (compare a b)
21:05:15 <ski>   where
21:05:26 <ski>   foo LT = a + sumatorio (a+1) b
21:05:30 <ski>   foo EQ = a
21:05:33 <ski>   foo GT = 0
21:05:42 <ski> that's without using 'case'
21:06:42 <josator> what is foo
21:06:43 <josator> ?
21:06:54 <josator> hellium sucks
21:07:01 <josator> no operator overload ...
21:07:20 <josator> + for real numbers
21:07:20 <ski> 'foo' was just a helper function i just defined
21:07:24 <josator> +. for real numbers
21:07:33 <josator> +for integer
21:07:35 <ski> (for doing the pattern-matching without using 'case')
21:07:39 <josator> ok
21:08:29 <MarcWeber> When doing something like this: do { f1<- read "a.txt"; write "a.txt" "somethingelse but f1"; f2 <- read "a.txt"}. Will f1 and f2 be equal?
21:08:47 <josator> thanks guys
21:08:53 <ski> np
21:09:24 <MarcWeber> read write should read write files in this example
21:09:42 <dblhelix> josator: actually, helium does have operator overloading!
21:09:46 <MarcWeber> I'll try
21:09:49 <ski> (s/read/readFile/ s/write/writeFile/)
21:11:27 <josator> dbhelix: yes?
21:12:26 <josator> maybe version on lab pc don't has
21:12:43 <josator> maybe version on lab pc has not
21:12:53 <earthy> that may well be the case
21:13:04 <josator> it is don't have or has not ?
21:13:10 <earthy> don't have
21:13:14 <josator> ok
21:13:18 <josator> ~
21:13:27 <josator> ~_~
21:13:30 <earthy> but I'd say it would have to be  'doesn't have' in this case
21:13:31 <dblhelix> josator: overloading is available as of version 1.6
21:13:43 <josator> ok
21:13:59 <josator> i will say
21:14:08 <josator> XD
21:14:23 <earthy> (what's that XD?)
21:14:35 <josator> laughing
21:14:46 <josator> with eyes closed
21:14:52 <josator> X-D
21:15:00 <josator> XP
21:15:12 <josator> is dead with the tonge out
21:15:42 <ski> > reverse ":("
21:15:43 <lambdabot> "(:"
21:18:02 <josator> but
21:18:06 <josator> tou can do
21:18:13 <josator> in helium
21:18:21 <josator> 2.4 + 2.3
21:18:22 <josator> ?
21:18:41 <josator> or you must do+(2.4,2.3)
21:18:46 <josator> +(2.4,2.3)
21:18:47 <josator> ?
21:19:02 <dblhelix> josator: 2.4 + 2.3
21:19:12 <josator> works?
21:20:10 <josator> i says it do not support n+k
21:21:16 <dblhelix> josator:  it does not support n + k *patterns*
21:24:36 <ski> that means you can't write
21:24:58 <ski> factorial  0    = 1
21:25:12 <ski> factorial (n+1) = (n+1) * factorial n
21:25:27 <ski>            ^^^
21:25:34 <ski> that's an "n+k" pattern
21:25:49 <sieni_> > map(\x->case x of{'('->')'; _->x})":("
21:25:50 <lambdabot> ":)"
21:25:57 <ski> ("patterns" since it's to the left of the '=')
21:42:00 <araujo> Morning.
21:42:40 <ski> after noon
22:09:27 <shapr> jiihaa
22:09:29 * shapr boings
22:09:32 <dons> @y0w!
22:09:33 <lambdabot> My boxer shorts just went on a rampage through a Long Island bowling
22:09:33 <lambdabot> alley.
22:09:39 <dons> hey shapr, long time, no boings
22:09:47 <dons> well, a few days at least
22:10:25 <shapr> G'day dons. Yeah, life is distracting me...
22:14:47 <Itkovian> anybody submitting something to OSCON Europe 2006?
22:25:24 <ProfTeggy> Seems they are all busy writing, Itkovian
22:52:11 <roconnor> I'd like to propose a new law
22:52:45 <roconnor> As an online discussion of static types vs dynamic types grows longer, the probability of mentioning hetrogenous lists approaches 1.
22:52:51 <lennart> Law&Order!
22:53:06 <roconnor> Godwin's law for language design
22:57:27 <tibbe> is it more effective to use showsPrec rather than show if I use show without using any string concatentation?
23:01:39 <dons> @remember roconnor I'd like to propose a new law. As an online discussion of static types vs dynamic types grows longer, the probability of mentioning hetrogenous lists approaches 1. Godwin's law for language design.
23:02:25 <dons> roconnor, can i quote that in next weeks HWN?
23:02:30 <dons> I quite like it :)
23:06:08 <roconnor> some of the arguements from the dynamic type land are terrible.
23:06:28 <roconnor> ``[...]you can often run a program successfully before a roughly equivalent typed program would even be compilable by a static-checking compiler.''
23:06:53 <roconnor> I use error "Not implemented" to get my unfinished code to run
23:07:00 <roconnor> > error "Not Implemented"
23:07:01 <lambdabot> Add a type signature
23:07:13 <roconnor> > (error "Not Implemented")::Stirng
23:07:14 <lambdabot>  Not in scope: type constructor or class `Stirng'
23:07:19 <roconnor> > (error "Not Implemented")::String
23:07:20 <lambdabot> Exception: Not Implemented
23:07:31 <dons> hehe, I like the "successfully" -- for some definition of success.
23:07:32 <roconnor> no problem
23:07:48 <roconnor> > (error "Not Implemented")::IO ()
23:07:49 <lambdabot> No IO allowed
23:07:52 <roconnor> ;)
23:08:17 <dons> people sometimes get offended by the compiler suggesting that they don't know what they're doing :)
23:08:21 <roconnor> dons: you may quote me I suppose
23:08:33 <dons> cheers
23:10:22 * roconnor grumbles hetrogenous lists...
23:10:59 <dons> roconnor, have you seen the nice OO/dynamic/hlist example by sseefried on the new wiki?
23:11:16 <roconnor> @where
23:11:17 <lambdabot>  @where <key>, return element associated with key
23:12:21 <dons> here, http://haskell.org/haskellwiki/Existential_type
23:13:40 <dons> it's a bit heterogenousy. anyway, who needs hlists when we have sums types?
23:14:18 <dons> night all!
23:25:06 <ski> "Smart constructors" ?
23:26:05 <audreyt> hm, I've been using that in Pugs for a long time now, and I didn't know it was known as sum types :)
23:28:53 <roconnor> existenential types are not sum types
23:29:34 <roconnor> data Foo=A String|B Integer|C[B]|D(Map String B)
23:29:40 <roconnor> Foo is a sum type
23:29:54 <audreyt> that's what I recalled, yeah.
23:29:59 <roconnor> data Shape = forall a. Shape_ a => Shape a
23:30:07 <roconnor> Shape is an existential type
23:30:27 <roconnor> An existenitial type can in some ways been seen as a potentially infinite sum type
23:52:06 <tibbe> roconnor, why is the explicit forall needed?
23:52:45 <tibbe> so what's the difference between what you wrote and: data Shape = Shape_ a => Shape a ?
23:58:38 <roconnor> I don't think data Shape = Shape_ a => Shape a isn't valid because a isn't scoped
23:58:50 <roconnor> data Shape a = Shape_ a => Shape a  would be closer to valid haskell
23:59:01 <roconnor> but now a is a parameter of Shape
23:59:16 <roconnor> the forall gets rid of a being a parameter to Shape
23:59:39 <integral> there's also the fact that the forall stuff is bodged onto haskell98's original typesystem...
