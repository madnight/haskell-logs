01:36:35 --- topic: '["Submit a paper to the Haskell Workshop:","http://haskell.org/haskell-workshop/2006","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]'
01:36:35 --- topic: set by kosmikus on [Thu Feb 16 05:43:08 2006]
01:51:51 <TeR-> hi there
01:52:01 <Cale> hi
01:52:35 <TeR-> if i declare data type with fixed arguments, how should i declare it ? f.e. Quadruple a a b b  [i want to have two of them same type] doesn't works
01:52:36 <vincenz> aloha
01:52:51 <TeR-> i have line : Quadruple a a b b = Q a a b b
01:53:02 <Cale> data Quadruple a b = Q a a b b
01:53:19 <TeR-> but i want them to have the same types, not the exactly same value
01:53:28 <Cale> the a and b on the left are type parameters
01:53:46 <TeR-> so the left side just says which types i will use ?
01:53:48 <Cale> on the right, they're being used to describe how the data constructors are made up
01:53:52 <Cale> yeah
01:53:55 <TeR-> i see
01:53:59 <TeR-> i
01:54:20 <TeR-> i'm afraid i'll never get rid of this imperative thinking, if i can call it like that :P
01:54:33 <TeR-> no, i'll better call it C-thinking :P
01:55:06 <Cale> well, C doesn't have type parameters... I suppose the closest thing would be in C++ templates
01:55:23 <Cale> Where you have template parameters which are types.
01:55:57 <TeR-> but i still think of it as funnction arguments
01:57:05 <Cale> Well, in some sense, you have a function which creates a type here, but what you're writing on the right isn't a type directly, it's a template for the data in that type.
01:57:16 <TeR-> and what in this line is my new data type name? Q is a constructor, so in functions signatures i should use 'Quadruple' ?
01:57:29 <Cale> Quadruple is a type constructor
01:57:42 <Cale> Quadruple a b is a type
01:57:49 <Cale> Q is a data constructor
01:58:00 <TeR-> Cale : but the function arguments are types, not datas, that is unnatural for me now ;]
01:58:07 <Cale> right
01:58:34 <Cale> So for instance, you can plug in Integer and String
01:58:44 <TeR-> so if i have Quadruple a a b b, i shall say the type of it is Quadruple a b ?
01:59:11 <Cale> If x :: a, and y :: b, then (Q x x y y) :: Quadruple a b
01:59:13 <ProfTeggy> TeR, you're confused
01:59:30 <TeR-> ProfTeggy : ?
01:59:52 <ProfTeggy> TeR, you seem confused about values and types at the moment, that's what i deduce from your statements.
02:00:12 <TeR-> ProfTeggy: in fact i'm confused about Haskell :}
02:00:16 <Cale> :)
02:00:28 <ProfTeggy> TeR, this will improve, no worries
02:00:45 <TeR-> sometimes i doubt it, but let the time do his job
02:00:46 <Cale> yeah, it doesn't take too long before it starts making sense
02:01:02 <TeR-> i'm in it for about  a week
02:01:09 <TeR-> so i'm full of hope right now L]
02:01:13 <ProfTeggy> Hehe
02:01:59 <Cale> Let's actually look at another notation for this type. I should warn you that this notation only works in GHC with extensions turned on (because it's new) but perhaps it will make it clearer what is being defined
02:02:09 <Cale> data Quadruple a b where
02:02:21 <Cale>    Q :: a -> a -> b -> b -> Quadruple a b
02:02:28 <TeR-> it seems that hugs dont' accept "quadruple a b" notation
02:02:41 <ProfTeggy> TeR, mind case
02:02:48 <gour> Cale: is it going to become a part of haskell' ?
02:03:18 <Cale> gour: That's to be decided. Probably not Haskell', I wouldn't think, but the next one after.
02:03:26 <vincenz> Cale: how does that work with matching?
02:03:34 <Cale> vincenz: same way
02:03:41 <vincenz> Cale: so you can patternmatch functions?
02:03:49 <Cale> vincenz: constructors
02:03:56 <vincenz> erm, but now Q is just a function
02:04:03 <Cale> constructors always have been functions
02:04:04 <gour> Cale: what will be after Haskell', Haskell'' or Haskell-2.x ?
02:04:16 <vincenz> Cale: right but more specific than just "any functioin"
02:04:22 <vincenz> gour: haskell-95
02:04:24 <Cale> vincenz: yeah
02:04:32 <gour> vincenz: :-)
02:04:33 <ProfTeggy> vincenz, constructors may not be applied partically, for example
02:04:38 <ProfTeggy> partially, rather
02:04:38 <Cale> gour: Haskell' is a provisional name anyway
02:04:42 <vincenz> ProfTeggy: sure they may
02:04:49 <Cale> ProfTeggy: yes they can
02:04:50 <vincenz> > Left
02:04:50 <lambdabot>  add an instance declaration for (Show (a -> Either a b))
02:04:57 <vincenz> ProfTeggy: they can't be in ocaml
02:04:59 <vincenz> which leads to crap like
02:05:03 <vincenz> left x = Left x
02:05:06 <Cale> @type (,) 5
02:05:06 <vincenz> riht x = Right x
02:05:07 <lambdabot> forall a b. (Num a) => b -> (a, b)
02:05:20 <ProfTeggy> Doh
02:05:22 <vincenz> constructors are not first class in ocaml
02:05:23 <vincenz> :/
02:05:36 <gour> Cale: that i know, but i wonder whether we'll get haskell-2 after prime?
02:05:52 <Cale> gour: that's for everyone to decide together
02:05:55 <vincenz> gour: nah, they'll change the name compltely in a commercial move
02:06:04 <vincenz> something like "flashboing"
02:06:14 <TeR-> sorry guys, i didn't mean to start the fire of discussion ;)
02:06:20 <Cale> hehe
02:06:23 <vincenz> TeR-: discussions are fun
02:06:25 <gour> vincenz: ahh..that's great
02:06:40 <TeR-> so i'll quietly ask about my silly problems, ok? ;)
02:06:41 <vincenz> gour: well it's not decided yet between "flashboing" or "beephype"
02:06:43 <flux__> ecom-flashBOING3000
02:06:54 <Cale> TeR-: anyway, does the other notation make any more sense? You're defining a constructor, which takes 4 parameters
02:07:02 <TeR-> cose i still donno how to use my type in functions signatues
02:07:06 <Cale> and a type which takes 2
02:07:09 <Cale> oh
02:07:12 <Cale> that's easy :)
02:07:12 * gour considers that haskell has momentum (atm) and would be nice to start working on 'flashboing' or so, asap
02:07:15 <vincenz> TeR-: Quadruple a b= Quadruple is a type constructor (aka given two types it makes a specific type)
02:07:18 <Cale> f (Q x y z w) = ...
02:07:22 <TeR-> Cale : if left side describes the type: it's obvious
02:07:32 <vincenz> TeR-: Q a a b b = is a data constructor, given four values of type a and b, it will make a type Quadruple a b
02:07:51 <flux__> maybe ghc could be called 'flash' and ghci 'boing'
02:07:53 <Cale> f x = Q x (x+1) (x+2) (x+4) 
02:08:04 <Cale> Q is also a function
02:08:05 * ProfTeggy wonders about his above statement when he writes (x :) all day...
02:08:12 <Cale> which makes values of your new type
02:08:14 <TeR-> yes, but i try to write a function returning a list: myfunc :: Quadruple a b => ... , it's invalid
02:08:14 <flux__> although 'fbi' has an interesting ring to it too
02:08:18 <vincenz> ProfTeggy: coffee ;)
02:08:22 <ProfTeggy> yes
02:08:32 <Cale> TeR-: Quadruple isn't a class
02:08:34 <TeR-> hugs says he forbids multiple parameter classes
02:08:38 <vincenz> TeR-: you mean
02:08:44 <vincenz> myfunc :: Quadruple a b -> ...
02:08:47 <Cale> myfunc :: Quadruple a b -> ...
02:08:48 <Cale> yeah
02:09:04 <Cale> => is used to apply typeclass constraints
02:09:04 <vincenz> any good way of building graphs?
02:09:11 <Cale> you'll learn about those soon :)
02:09:15 * vincenz is considering using control.monad.st
02:09:19 <vincenz> and refs
02:09:36 <kosmikus> vincenz: you can try Data.Graph.Inductive
02:09:37 <TeR-> so the class operator => is used ONLY when something is in class ?
02:09:47 <vincenz> kosmikus: but I need the graph embedded in my type
02:09:55 <TeR-> is it called 'class operator'? :]
02:09:59 <Cale> TeR-: it's used to restrict type parameters so that they must belong to some class
02:10:01 <kosmikus> vincenz: yes, and?
02:10:06 <TeR-> it should, i think ;]
02:10:13 <Cale> TeR-: I'm not sure if it has a name :)
02:10:33 <TeR-> :)
02:10:34 <vincenz> kosmikus: it's a CFG... so I have expressions and stms... meaning I want somthing lie Exp ... = Exp {...., nextPoint :: Point}
02:10:48 <kosmikus> TeR-: I read it "implies" most of the time
02:10:51 <gour> dcoutts: ping
02:11:09 <ski> @type elem
02:11:10 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:11:36 <kosmikus> vincenz: I see
02:11:41 <vincenz> kosmikus: using an inductive graph would mean annotating my exps and stms with their node id and a lookup for each traversal
02:11:50 <vincenz> err, each traversal step
02:12:19 <TeR-> kosmikus : you read it 'impliens' in function signatures as well ?
02:12:32 <kosmikus> TeR-: yes
02:12:42 <Cale> I suppose that I do too :)
02:12:46 <vincenz> likewise
02:12:56 <Cale> Implies or "if-then" even
02:12:58 <vincenz> anyways... use ST monad with refs or anyone have an alternative solutioin?
02:13:53 <swiert> kosmikus: I have an lhs2TeX feature request...
02:14:01 <kosmikus> swiert: go ahead
02:14:02 <vincenz> oh, kosmikus I -have- used Data.Graph.Inductive in other projects ;)
02:14:06 <TeR-> kosmikus : it don't think it fits to signature logically
02:14:14 <kosmikus> TeR-: it does
02:14:19 <TeR-> but ofcourse i'm not sure about it
02:14:38 <swiert> kosmikus: I'd like to be able to \include files that are the result of running lhs2TeX into a plain .tex document.
02:14:50 <TeR-> kosmikus : so how would you read it? 'class a implies function which ..." ?
02:15:07 <vincenz> TeR-: ifi type a is in the class SomeClass, then you can apply this function
02:15:07 <Cale> If Eq a then ...
02:15:19 <kosmikus> swiert: you can do that already
02:15:43 <swiert> kosmikus: how would I do that?
02:15:52 <kosmikus> swiert: which version are you using?
02:16:10 <swiert> 1.10pre
02:16:22 <swiert> should I upgrade?
02:16:27 <kosmikus> not necessarily
02:16:42 <kosmikus> I have put a 1.11 rc online a few days ago, and I'd appreciate feedback
02:16:51 <kosmikus> and this particular issue has changed a bit
02:16:58 <kosmikus> anyway, for 1.10pre
02:17:06 <Cale> elem :: forall a. (Eq a) => a -> [a] -> Bool -- for all types 'a', if 'a' is comparable for equality, then elem is a function from values of type 'a' to lists of values of type 'a' to booleans.
02:17:16 <Cale> That's the verbose reading anyway :)
02:18:10 <kosmikus> swiert: you just make sure that lhs2TeX.sty is included once per TeX run, and lhs2TeX.fmt is included once per lhs2TeX run
02:18:26 <TeR-> so i can read it "the fact that a is in class X, implies the function implementativeness ?
02:18:34 <Cale> TeR-: yeah
02:18:36 * ProfTeggy experiences a lhs2TeX advice dejavu 
02:18:42 <TeR-> i'm not sure if there's a word 'implementativeness' :]
02:18:45 <TeR-> but it sounds ok
02:18:48 <kosmikus> ProfTeggy: :)
02:18:56 <Cale> hehe :)
02:19:06 <kosmikus> that's an FAQ by now
02:19:11 <kosmikus> anyway, Section 6.1 of the manual
02:19:14 <ProfTeggy> Works fine for me, btw, Andres
02:19:21 <TeR-> thanks guys
02:19:25 <Cale> no problem
02:20:35 <Cale> seems that everyone is confused by that Quadruple problem when learning Haskell... perhaps we should tell the author about that :)
02:20:39 <TeR-> i think #haskell is one of the most friendly place to get help :}
02:20:53 <kosmikus> swiert: in version 1.11, it should even "just work". there's no distinction between lhs2TeX.{fmt,sty} anymore, you can just include lhs2TeX.fmt everywhere and let TeX figure out the rest ...
02:20:56 <ProfTeggy> kosmikus, what is the most significant change from 1.10 to 1.11?
02:21:01 <Cale> we try to keep it friendly :)
02:21:13 <TeR-> you get any benefits ? :]
02:21:14 <ProfTeggy> Is this it?
02:21:22 <Cale> TeR-: more Haskell programmers :)
02:21:41 <Cale> which means more cool Haskell code :)
02:21:43 <TeR-> are there any 'developers' in haskell? maybe you belong to them ? :]
02:21:52 <Cale> I've done work in Haskell
02:21:54 <kosmikus> ProfTeggy: difficult to say; several smaller changes
02:21:58 <vincenz> anyways
02:22:00 <TeR-> so it's nothing but pure passion :] ?
02:22:07 <vincenz> kosmikus: still suggest Data.Graph.Inductive?
02:22:09 <Cale> paid work, even :)
02:22:09 <TeR-> you've done work? what work if i may ask ?
02:22:13 <swiert> kosmikus: give me a minute, I'm having a quick look.
02:22:27 <kosmikus> ProfTeggy: calling "ghci" or "hugs" from within an lhs2TeX document is slightly less broken than before
02:22:30 <TeR-> say it simple and short, i want to understand it ;]
02:22:37 <Cale> I worked for a university on a new compiler for a language for signal processing applications.
02:22:48 <ProfTeggy> kosmikus, I see.  Thank you.
02:23:12 <kosmikus> ProfTeggy: it's based on a more recent version of polytable.sty that should be a bit more robust
02:23:26 <kosmikus> ProfTeggy: it has a few library files with frequently used formatting statements
02:23:29 <TeR-> wow
02:23:39 * ProfTeggy nods
02:23:56 <vincenz> kosmikus: still suggest using Data.Graph.Inductive/
02:24:10 <ProfTeggy> komsikus, I've found typos here and there in the documentation.  
02:24:40 <Cale> I wrote what's called a pipeline scheduler and a register allocator -- the first being part of the optimisation process, determining the best way to issue instructions to the processor, and the second basically making sure that the finite resources that you have to store things on the chip get used efficiently.
02:24:56 <kosmikus> vincenz: I don't know. I can see your point. I think I wouldn't want to work in an ST monad with all my code, but having a separate graph is also inconvenient. You really have to decide yourself.
02:25:11 <vincenz> kosmikus: touche
02:25:22 <vincenz> well... I can always add operations
02:25:26 <vincenz> if it's slow...that's less of an issue
02:25:37 <vincenz> (it's a prototype tool to experiment)
02:25:46 <kosmikus> ProfTeggy: do you want to send a patch?
02:25:50 <vincenz> so I guess I can take the log N hit, thx for reminding me of Data.Graph.Inductive
02:26:11 <ProfTeggy> kosmikus, if this is what you prefer...
02:26:37 <kosmikus> ProfTeggy: you can also just write a mail. that's fine, too.
02:27:10 <TeR-> Cale: it's wroten in C, yes ?
02:27:21 <xerox_> Howdy!
02:27:23 * ProfTeggy downloads 1.11pre4
02:27:36 <Cale> TeR-: This compiler was being written in Haskell
02:27:43 <Cale> There's no C involved
02:28:03 <Cale> but my program was manipulating assembly instructions
02:28:23 <TeR-> haskell compiler written in  haskell? :}
02:28:23 <swiert> kosmikus: so I've got one .lhs file that %include lhs2TeX.fmt and a .tex file that \usepackages{lhs2TeX} and \includes the .lhs file.
02:28:32 <Cale> TeR-: yeah, GHC is written in Haskell
02:28:45 <TeR-> how is it possible ?
02:28:55 <xerox_> GCC is written in C :-)
02:29:01 <kosmikus> swiert: lhs2TeX.sty shouldn't ever be \usepackage'd, it should be %include'd ...
02:29:10 <ProfTeggy> TeR, search the web for 'bootstrapping'
02:29:14 <vincenz> English is written in English
02:29:17 <gour> Lemmih: ping
02:29:20 <Cale> TeR-: you compile it with an older GHC
02:29:25 <xerox_> vincenz: so true
02:29:31 <vincenz> :)
02:29:45 <Lemmih> gour: pong
02:29:46 <kosmikus> swiert: that's the reason of much confusion, I know, which is why it's only retained for backwards-compatibility in 1.11
02:29:57 <Cale> The OED is written in English too :)
02:30:03 <Cale> hehe
02:30:03 <gour> Lemmih: i get: Chasing modules from: Hide.CommonSense.Haskell,Hide.CommonSense.Haskell.Scanner
02:30:03 <gour> stack overflow: use +RTS -K<size> to increase it
02:30:13 <gour> Lemmih: is it know issue?
02:30:42 <gour> Lemmih: s/know/known
02:31:22 <TeR-> right away:]
02:31:27 <ProfTeggy> kosmikus, I still need to specify -fasm in config.mk.in to avoid a linker error on Mac OS X
02:31:27 <Lemmih> gour: Compiling that plugin makes GHC blow the stack?
02:31:48 * vincenz is considering buying an IPod
02:32:16 * shapr boings cheerfully.
02:32:21 <shapr> Haskell kicks butt! w00!
02:32:29 <swiert> kosmikus: but then I can't \include the result of running lhs2TeX in the .tex file can I?
02:33:00 <kosmikus> ProfTeggy: I doubt that this is related to lhs2TeX in any way. lhs2TeX doesn't rely on any foreign code or exotic Haskell libs.
02:33:23 <musasabi> shapr: any new fun things recently?
02:33:28 <gour> Lemmih: i just executed build.sh script
02:33:32 <kosmikus> swiert: just turn both files into .lhs files
02:33:41 <kosmikus> swiert: and run lhs2TeX on both
02:33:43 <TeR-> even the name 'bootstraping' tells something about unnatural situation [ such as lifting yourself out of the swamp, as it is written in wikipedia\
02:33:53 <kosmikus> swiert: then run latex on the master file
02:34:14 <gour> Lemmih: let me try to clean everything in hiDE
02:34:31 <Lemmih> gour: Did you modify the build script to use ghc.hide?
02:34:46 <kosmikus> TeR-: bootstrapping is a very common term in compiler construction
02:34:46 <Cale> TeR-: the nice thing is that Haskell is a pretty close to ideal language in which to write a compiler
02:34:48 <gour> Lemmih: yep, to point at new ghc
02:34:50 <TeR-> vincenz : it's not so obvious , that english is written in english, as it's not so simple to lift yourself by pull your head up
02:35:05 <TeR-> kosmikus : i guess so, but it's not in real life :]
02:35:10 <kosmikus> TeR-: gcc is written in C
02:35:13 <swiert> kosmikus: but I'd like to just include the result of an .lhs in a .tex. That way I would only have to run the preprocessor on the files that actually have code in them.
02:35:20 <ProfTeggy> lhs2TeX 1.11pre4, Copyright (C) 1997-2006 Ralf Hinze, Andres Loeh
02:35:45 <ProfTeggy> This started in '97 already?  
02:35:52 <vincenz> TeR-: eh?
02:36:02 <kosmikus> swiert: what's the problem with running lhs2TeX on the master file?
02:36:05 <TeR-> vincenz : nevermind :]
02:36:14 <swiert> kosmikus: of course I would be willing to add extra stuff to the .tex preamble.
02:36:19 <Cale> vincenz: ever pulled yourself up by your own bootstraps?
02:36:19 <kosmikus> ProfTeggy: yes, but I wasn't involved at the time.
02:36:27 <swiert> kosmikus: it changes line numbers, for one.
02:36:31 <vincenz> Cale: I don't have bootstraps
02:36:32 <TeR-> however, there have to be a tiny start _not_ in language being defined
02:36:36 <Cale> vincenz: hehe
02:36:44 <Cale> TeR-: right
02:36:55 <swiert> kosmikus: I can't just C-c C-c in Emacs is another (albeit more minor) point.
02:37:11 <Cale> TeR-: I think it was originally written in C for a short time.
02:37:16 <kosmikus> ProfTeggy: I've written polytable.sty in 2003.
02:37:22 <Cale> TeR-: Hugs is still in C.
02:38:02 <kosmikus> swiert: line numbers: have a look at "adjust": http://www.informatik.uni-freiburg.de/~wehr/
02:38:34 <kosmikus> swiert: I'm unconvinced. But the fact is that you only need to process the master file and all code-containing files with lhs2TeX.
02:38:40 <TeR-> is it good ffor hugs ?
02:38:52 <kosmikus> swiert: You can still include other pure LaTeX files using \include ...
02:38:52 <Cale> TeR-: hm?
02:38:56 <TeR-> i assume that the answer isn't one-lined :]
02:39:44 <TeR-> what does it means practicly ,what's the difference between hugs and haskell-based ghc when it comes to efectiveness?
02:39:46 <Cale> C isn't a wonderful language to write something like that in, but it at least means that Hugs is quite easily portable, as it's easy to find a C compiler on most platforms.
02:39:54 <Cale> Hugs is an interpreter
02:40:01 <Cale> GHC is a compiler
02:40:15 <TeR-> i see
02:40:22 <Cale> (though GHC comes with GHCi which is an interactive tool for compiled/interpreted code)
02:40:42 <TeR-> it sounds like hugs is quite shiity ;]
02:41:09 <Cale> It's not so bad, but I prefer GHC myself.
02:41:43 <swiert> kosmikus: sure, but this way I can separate files that actually need to be run through lhs2TeX and files that don't. Atm, once you use lhs2TeX, you need to change all your documents into .lhs files.
02:42:00 <Cale> there are yet other Haskell implementations at various levels of completion
02:42:07 <Cale> JHC is pretty cool.
02:42:37 <swiert> kosmikus: bbl.
02:42:40 <Cale> It's got some pretty neat features for optimising Haskell code.
02:43:02 <kosmikus> swiert: I don't see your point. As I just explained, you can have pure LaTeX files. It just can't be the master file.
02:43:24 <Cale> Yhc is supposed to compile to bytecode, and then the programs will be portable and can run wherever the small bytecode interpreter does.
02:43:39 <TeR-> Yale ?
02:43:53 <Cale> York, iirc.
02:44:17 <musasabi> JHC is mostly lacking some FFI support and MPTC+FD
02:47:14 <Cale> how do things end up on the haskell mailing list which are not addressed to the list?
02:47:59 <int-e> due to Cc, for example
02:48:15 <ski> TeR- : actually, there doesn't have to be a start that is not in the language that is implemented
02:49:29 <ski> (s/is/is being/)
02:49:45 <TeR-> ski: f.e. OS booting, but i can't imagine how it's done
02:50:13 <ski> Mercury was first implemented in itself, e.g.
02:50:30 <ski> more specifically, it was initially implemented in the intersection of Mercury and Prolog
02:51:08 <ski> (so they used Prolog implementations until it could compile itself)
02:51:18 <Cale> this message has equal From and To lines, and a blank Cc, but there are a bunch of List-* lines specifying the Haskell mailing list.
02:51:33 <resiak> …bcc?
02:51:36 <int-e> Bcc then
02:51:42 <Cale> must have been
02:53:47 <vincenz> DAMN
02:53:59 <vincenz> gmail-chat is impressive
02:54:14 <vincenz> I wonder how it does that
02:54:22 <vincenz> active thread that keeps polling the server with async?
02:54:23 <xerox_> What is it?
02:54:27 <vincenz> basically
02:54:29 <vincenz> if you open gmail
02:54:38 <vincenz> you can do chatting with your gtalk-buddies
02:54:42 <vincenz> in the browser
02:55:11 <vincenz> basically it must make a <div>
02:55:20 <vincenz> tho it's quite iimpressive
02:55:20 <gour> Lemmih: i pulled again hIDE and i get the same thing as before
02:55:40 <Lemmih> gour: That's very weird. Try building haskellSense manually.
02:56:07 <gour> Lemmih: ok
02:57:08 <gour> Lemmih: same
03:30:50 <shapr> vincenz: What's your gmail username?
03:31:32 <dcoutts_> gour, pong
03:34:12 <gour> dcoutts:_i had some issues in building hiDE, but it ended up much worse - Lemmih is trying to debug it. can you help us
03:34:13 <xerox_> dcoutts_: howdy!
03:36:36 <gour> dcoutts_: i had some issues in building hiDE, but it ended up much worse - Lemmih is trying to debug it. can you help us
03:42:10 <dcoutts_> gour, hmm, perhaps
03:42:13 <dcoutts_> xerox, morning!
03:50:58 <gour> Lemmih: can you give some more info to dcoutts regarding hIDE problem
03:52:13 <Lemmih> Not really.
03:52:44 <gour> so, he can only try to build hIDE on amd64?
03:54:15 <dcoutts_> Lemmih, does hs-plugins work at all on amd64 do you know?
03:54:33 <Lemmih> This isn't about hs-plugins.
03:55:13 <Lemmih> GHC blows the stack when it tries to compile haskellSense.
04:00:03 <MarcWeber> Is there a list contains :: [a] -> a -> Bool function? something like 1 == length ( filter (=element) list) ?
04:00:17 <Lemmih> > 10 `elem` [1..100]
04:00:18 <lambdabot> True
04:00:19 <tromp_> @index elem
04:00:20 <lambdabot> Data.List, Prelude
04:01:22 <tromp_> btw, the test shld be length >= 1 :P
04:01:43 <MarcWeber> ;-)
04:01:43 <tromp_> and wld be very inefficient;(
04:01:56 <tromp_> prolly process the whole list?
04:02:01 <MarcWeber> The list will be typically of length < 10 
04:02:42 <tromp_> > length [0..9999999] > 0
04:02:44 <lambdabot> True
04:02:49 <tromp_> > length [0..99999999] > 0
04:02:53 <lambdabot> Terminated
04:03:04 <tromp_> i thought as much:(
04:03:29 <Cale> > (not . null) [0..99999999]
04:03:30 <lambdabot> True
04:04:00 <MarcWeber> I want to write some kind of haskell make.. because I'm personally suck with make files ;-)
04:04:17 <tromp_> try ghc --make?
04:04:18 <Lemmih> Can't you use hmake or Cabal?
04:04:41 <kosmikus> MarcWeber: have a look at "maak": http://www.cs.uu.nl/people/eelco/maak/
04:04:58 <kosmikus> MarcWeber: it's a bit unfinished, but still contains lots of good ideas
04:05:30 <dcoutts_> MarcWeber, Cabal is really in need of a 'make' like feature so it can support arbitrary pre-processors, like hsc2hs, c2hs, happy, alex etc
04:06:16 <dcoutts_> so if someone writes a make-like thing in Haskell it'd be great if they could contribute it to cabal
04:08:22 <MarcWeber> dcoutts I thought of that, too.. If it works as I would expect it it should be even possible to replace configure like things.  ;-)
04:08:43 <dcoutts_> cool
04:08:50 * dcoutts_ though configure was a bit different
04:09:17 <MarcWeber> But the only reason configure exists is fullfilling some kind of dependencies.. ;-)
04:09:31 <MarcWeber> And I don't want to learn m4 preprocessors and stuff like that
04:09:55 <MarcWeber> Though it would be cool to get the "working knowledge" from the autoconf system...
04:10:05 <sieni_> autotools suck more than 10000 industrial grade vacuum cleaners
04:10:33 <MarcWeber> *lol*
04:10:52 <MarcWeber> sieni Have you read their point of view? ;-)
04:11:16 <sieni_> no, we actually use them at work
04:12:26 <MarcWeber> sieni Is there an alternative?
04:12:48 <MarcWeber> I want to share my ideas.. because I still don't know what might be the best way to implement it...
04:14:08 <MarcWeber> kosmikus wget fails on cygwin, svn on my colinux gentoo fails getting internet access at the moment. Will try it later
04:14:27 <dcoutts_> MarcWeber, in practise these days I think autoconf is less used because there are fewer broken unix versions out there than there used to be and autotools never really tackeled win32 well
04:15:37 <kosmikus> MarcWeber: try "https://svn.cs.uu.nl:12443/repoman/info/maak" with your web browser and try to download from there
04:15:38 <dcoutts_> I mean I build gtk2hs on win32 using autoconf & auomake and it works pretty well but it does need a mingw shell to support unix sh and common shell commands
04:15:54 <kosmikus> MarcWeber: not that "maak" is a make-like tool written in Haskell, but not a Haskell library
04:16:06 * kosmikus is away for a while
04:16:30 <vincenz> re
04:18:49 <MarcWeber> kosmikus Couldn't find the sources of hat file.. but there are some examples ;-) ... away ok.. 
04:40:23 <xerox_> dcoutts_: libnotify has a notify-send, I think I'll give up with libnotify bindings
04:40:56 <dcoutts_> xerox_, fair enough
04:41:27 <xerox_> That thing is pretty cool.
04:47:08 <roconnor> hey xerox!
04:47:42 <roconnor> hey xerox_!
04:48:19 <xerox_> Howdy roconnor!
05:06:13 <xerox_> dcoutts_: http://img48.imageshack.us/img48/1072/1401210206trashcan5hp.png
05:06:47 <dcoutts_> xerox_, heh, nice
05:06:57 <xerox_> Random (notified) wallpapers, woo :-D
05:07:15 <dcoutts_> scripted in Haskell? :-)
05:07:37 <xerox_> Not yet, I had some problems with HaXml.
05:08:07 <xerox_> (It doesn't recognise Google's html as proper one.. gah :-))
05:08:55 <Igloo> Last I looked it wasn't proper HTML, so that figures
05:09:26 <xerox_> Indeed, it's just painful, tho.
05:09:53 <MarcWeber> Sh.. I pressed Ctrl-w accidently in firefox.. My 2. attempt: http://www.rafb.net/paste/results/b65T1412.html . This tries to describe my vision of a haskell make system
05:10:15 <shapr> Have you seen maak?
05:10:23 <shapr> iirc, it's based on DAGs
05:10:39 <MarcWeber> shapr kosmikus pointed me to that one but I wasn't able to retrieve it by now
05:11:23 <shapr> MarcWeber: http://www.scannedinavian.com/~shae/ maak*
05:11:48 <MarcWeber> shapr Would you mind glancing at my idea and tell me how you like it, wether it's easier to understand than makefiles?
05:12:11 * shapr looks
05:12:48 <shapr> I swapped some emails with the author of maak and with Oleg about functional make systems.. dunno if I can still find them though.
05:12:59 <musasabi> MarcWeber: for replacing autoconf one needs at least 1) OS detection, 2) check whether a C {header,function,structure,cpp define} exists, 3) endianess check, 4) check the value of some CPP defines
05:14:08 <MarcWeber> haskell can detect OS, can't it? checking for defines shouldn't be that hard, too.   endianess check?? Never heard
05:14:20 <MarcWeber> check value of CPP defines: should be possible..
05:14:40 <shapr> Some architectures are least significant byte first, and some are the other way around.
05:14:41 <musasabi> AC_C_BIGENDIAN (this is easy to do in Haskell)
05:14:57 <MarcWeber> ah thanks
05:16:12 <shapr> MarcWeber: It's always seemed to me that make is just a directed acyclic(?) dependency graph. I've always thought that a really smooth depgraph implementation would be all you'd need for a powerful make system.
05:17:32 <musasabi> killing autoconf seems like the most important bit to me
05:17:38 <musasabi> but that is just a personal preference
05:17:44 <shapr> Inductive graphs as in Data.Graph seem like a good way to do that.
05:18:01 <shapr> But I've never actually tried to do anything about it, so I have the confidence of the completely clueless ;-)
05:18:14 <MarcWeber> hgl?
05:18:22 <shapr> Yeah, Data.Graph == hgl
05:18:26 <MarcWeber> shapr Thats my problem, too
05:18:37 * ski seems to recall a paper "Recursive Make considered harmful" or somesuch
05:18:45 <MarcWeber> I've downloaded the pdf and started reading..
05:18:50 <shapr> Maak is based on a directed graph, though it's been years since I read the papers.
05:19:31 <MarcWeber> shapr can you point me to source clarifying the expressions directed graph, acyclic graph?
05:19:59 <vincenz> is there any algos in Data.Graph.Inductive to do bipartite matching
05:20:13 <shapr> Well, acyclic means no circles, and directed means edges that have a definite direction.
05:20:37 <MarcWeber> acyclic graph=tree?
05:20:47 <vincenz> MarcWeber: no
05:20:58 <shapr> A tree is a special case of a graph.
05:20:58 <vincenz> A->B, A->C, B->D, C->D
05:21:00 <vincenz> that
05:21:16 <vincenz> that's a DAG but not a tree
05:21:23 <shapr> And trees are almost always acyclic :-)
05:21:37 <vincenz> trees are DAGs are DGs
05:21:41 <MarcWeber> in which case they are not?
05:21:54 <vincenz> trees are always acyclic
05:22:05 <MarcWeber> I would need DAG, then
05:22:14 <vincenz> trees subsetof DAGs subsetof DGs
05:22:19 <shapr> Having read large amounts of academic literature, I've discovered there's always a case where something isn't something. But I can't think of any case where trees are cyclic off the top of my head.
05:22:42 <MarcWeber> DGs?
05:22:46 <shapr> directed graph
05:22:47 <vincenz> directed graphs
05:22:56 <vincenz> trees subsetof DAGs subsetof DGs subset of Graphs
05:23:02 <vincenz> :)
05:23:12 <MarcWeber> list subset of tree ;)
05:23:16 <sieni_> the usual definitions for non-directed graphs are: an acyclic graph is called a forest and a connected forest is called a tree
05:23:16 <shapr> MarcWeber: http://en.wikipedia.org/wiki/Graph_theory
05:23:36 <vincenz> sieni_: erm, no
05:23:38 <sieni_> (for some reason many people find those definitions amusing :-)
05:23:57 * shapr could never see the forest for the trees...
05:24:07 <musasabi> hmm, seems like haskell.org has lost the link to the standard :-(
05:24:07 <MarcWeber> what is a DG now?
05:24:11 <vincenz> directed graph
05:24:20 <MarcWeber> ah. obvious
05:24:26 <shapr> MarcWeber: Look at that wikipedia page. It'll get you started.
05:24:31 <vincenz> anyone know an algo to do graph matching?
05:24:41 <vincenz> I forgot the name, it's apparently not bipartite matching
05:24:57 <MarcWeber> shapr I can imagine what they are but I don't know the names.. I've used kinds of trees a lot of time..
05:25:02 <sieni_> vincenz: erm, yes
05:25:11 <vincenz> sieni_: take a diamond
05:25:20 <vincenz> it's a DAG, it's connected, it's not a tree
05:26:22 <sieni_> vincenz: I was still talking about non-directed graphs (or would undirected be better)
05:26:49 <MarcWeber> I'm now interested in: do you think this might be useful? (I'll try it anyway).. DAG =directed acyclic graph (?) and how to implement it in haskell.
05:27:07 <vincenz> sieni_: nondirected graphs is even worse
05:27:14 <sieni_> http://en.wikipedia.org/wiki/Tree_%28graph_theory%29
05:27:25 <shapr> MarcWeber: I think a Haskell-based make would be nifty. Data.Graph is a good way to do most graph stuff.
05:27:38 <vincenz> sieni_: note the imoprtant distinction
05:27:41 <vincenz> "AT MONST ONE PATH"
05:27:50 <vincenz> s/MONST/MOST
05:27:57 <shapr> vincenz: 'worse' is a matter of perspective, and nothing we can unit test :-)
05:28:00 <vincenz> MarcWeber: Data.Graph.Inductive
05:28:32 <vincenz> sieni_: as for dgs, you're right, there'd be more constraints
05:28:54 <vincenz> |inb| = 1
05:29:02 <MarcWeber> So if you have a DAG like this A->(B and C) -> D and you want to make A you will check B and C which in turn will both try to check D.
05:29:18 <MarcWeber> How to prevent double check of D?
05:29:23 <vincenz> MarcWeber: typically you cache it
05:29:24 <MarcWeber> while traversing?
05:30:01 <MarcWeber> vincenz While traversing add another parameter (visitedNodes)  and skip them?
05:30:04 <vincenz> if hasVisited(node) then cacheValue(node)
05:30:15 <vincenz> if you have visited the node, you don't need to recheck it's children
05:30:24 <vincenz> MarcWeber: use a monad
05:30:29 <vincenz> statemonad
05:30:37 <vincenz> :)
05:30:41 <MarcWeber> =me leaves (joke)
05:30:51 <shapr> Or you could make them thunks, and just eval them when you need them.
05:30:55 <vincenz> hy, I'm a haskell newb
05:31:18 <shapr> Laziness lets you memoize for free if you do it right.
05:32:43 <MarcWeber> I want to kill my neigbour.. Hes looping some seconds of music arbitrarily..
05:33:28 * vincenz suggests a directed graph from the end of your rifle to the start of his head
05:33:34 <vincenz> preferably acylic
05:35:05 <shapr> Man, all these people wanting to mutate their neighbors in-place...
05:35:06 * shapr sighs
05:35:26 <MarcWeber> ;-)
05:35:28 <vincenz> shapr: I'm using an IO monad which is basically State (RealWorld)
05:36:01 <MarcWeber> It's some kind of flushing feeling 
05:44:29 <SimonRC> hi
06:03:33 <shapr> hiya SimonRC 
06:25:06 <xerox_> dcoutts_: you fooled me!  :-)
07:26:33 <moonlite> fail :: String -> m a
07:26:34 <moonlite> Fail with a message. This operation is not part of the mathematical definition of a monad, but is invoked on pattern-match failure in a do expression.
07:26:52 <moonlite> ok. but how do i actually patternmatch agains the failure?
07:27:39 <Lemmih> That depends on the monad.
07:27:54 <Lemmih> > fail "urk!" :: Maybe ()
07:27:57 <lambdabot> Nothing
07:28:53 <ski> > fail "urk!" :: [()]
07:28:54 <lambdabot> []
07:29:17 <moonlite> hm ok. google tells me that the fail function might be invoked whenever there is a patternmatch error
07:29:23 <moonlite> it is the State-monad
07:31:26 <ski> > do Just x <- [Just 2,Just 3]; return (x*x)
07:31:27 <lambdabot> [4,9]
07:31:32 <ski> > do Just x <- [Just 2,Nothing,Just 3]; return (x*x)
07:31:33 <lambdabot> [4,9]
07:31:52 * vincenz peers at ski
07:32:41 * ski peers back
07:42:09 <kowey> question about @: are these two definitions exactly the same thing?
07:42:15 <kowey> fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
07:42:26 <kowey> fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
07:42:28 <kowey> oops
07:42:32 <xerox_> :D
07:42:33 <mauke> yes :-)
07:42:34 <kowey> fib = let (1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip (1:tfib) tfib ] in (1:tfib)
07:42:36 <Lemmih> Yes, they are the same. (:
07:42:39 <kowey> :-)
07:42:55 <vincenz> > reverse ":("
07:42:56 <lambdabot> "(:"
07:43:05 <kowey> in other words, is @ just sugar, or is there something deeper and more mystical going on?
07:43:18 <vincenz> kowey: it's useful for matching
07:43:22 <xerox_> kowey: the former.
07:43:28 <kowey> thanks!
07:43:31 <vincenz> xerox_: even in the case  of patternmatching?
07:43:41 * kowey is learning about the difference between lazy and strict matching
07:43:41 <xerox_> vincenz: especially in this case.
07:44:01 <vincenz> xerox_: what if you have some @'s somewhere in the middle
07:44:28 <xerox_> vincenz: that's slightly different, but I think it's still ok to think of them as let bindings.
07:44:49 <vincenz> A(B, C, D (E f) x@(G g))
07:45:04 <vincenz> I would not want to do that with let's
07:45:09 <xerox_> dcoutts_: wher art thou?
07:46:09 <Lemmih> vincenz: A(B, C, D (E f) x) = let (G g) = x in .. ?
07:46:20 <vincenz> hmm
07:46:22 <vincenz> what about
07:46:36 <xerox_> f .. xs@(y:ys) .. = ..    =~=   f .. xs .. = let (y:ys) = xs in ..   =~=   f .. (y:ys) .. = let xs = (y:ys) in ..
07:46:46 <xerox_> modulo compiler optimization
07:46:47 <vincenz> it can get ugly quick
07:47:32 <xerox_> In fact the second one is slightly wrong, 'xs' can match everything.
07:47:59 <xerox_> And from the backstage I hear: s/=~=/<=>/g  :-)
07:48:03 <xerox_> (Thanks ski)
07:48:34 <lispy> heh, that meaning of modulo is in the Jargon file
07:48:58 <xerox_> lispy: yay :-)
07:51:32 <vincenz> s/xerox_ (.*)/fail "\1"
07:57:34 <moonlite> i have a type error that says: "Couldn't match the rigid variable `a' against `Prog'" although i know it to be Prog [something]. How do i seek out the bug? I always get into these problems and always have to ask someone.
08:00:05 <Lemmih> Did you mean 'Prog a'?
08:00:34 <moonlite> m, i guess so
08:00:49 <moonlite> i'n a bit lost unfortunately
08:07:20 <lispy> moonlite: one thing that helps avoid crazy type errors is to prototype your functions (one line at a time) in ghci and then when you get the right types add it to your source file and try to compile
08:07:52 <lispy> if you work that way, in theory you always have less code to work with when finding the source of the type error
08:09:08 <lispy> moonlite: from the sounds of it you have a function with an explicit type signature like, "foo :: a -> b" and you're doing something that forces the type checker to think you want "foo :: Prob -> b"
08:10:00 <moonlite> hm ok. i actually made it compile by commenting out the type prototypes. I'll just try adding them afterwards.
08:10:06 <moonlite> they are nice to have
08:10:34 <dcoutts_> xerox_, yarr!
08:10:57 <dcoutts_> xerox_, fooled you? how?
08:11:00 <xerox_> dcoutts_: hehe
08:11:07 <xerox_> libsvg-cairo is old!
08:11:12 <xerox_> librsvg kills it.
08:11:38 <dcoutts_> has librsvg actually released a version that works with cairo yet?
08:11:45 <xerox_> Yes
08:11:45 <dcoutts_> it hadn't last time I checked
08:11:50 <xerox_> That's what the GNOME guys use
08:12:02 <dcoutts_> yeah, the unreleased version of GNOME!
08:12:24 <xerox_> ii  librsvg2-2     2.13.93-0ubunt SAX-based renderer library for SVG files. (f
08:12:28 <xerox_> I have this installed...
08:12:32 <dcoutts_> I'm happy to switch the svg binding to it when it's actually released
08:12:42 <dcoutts_> 2.13.x is an unreleased version
08:12:48 <lispy> moonlite: do you use hugs or ghci? in ghci you can load your file and say, :t foo and it will tell you what type foo really is.  That would be handy right now
08:12:50 <xerox_> uhm.
08:12:59 <xerox_> Eveerybody is fooling me then :-P
08:13:07 <lispy> moonlite: then work backwards and try to understand why the type is different than you thought it would be
08:13:13 <dcoutts_> xerox_, check the librsvg site, it says so
08:13:47 <lispy> moonlite: i remember doing that sort of detective work when i was first learning the haskell type system
08:13:48 <moonlite> lispy: i'll try that approach later. though now i have to go. thanks for your help!
08:14:05 <xerox_> dcoutts_: 'released' ?
08:14:14 <moonlite> hm yeah, i's a bit cumbersome before you get to learn it it seems
08:17:38 <lispy> moonlite: np
08:27:27 <MarcWeber> Can't I do something like this: type DepTree=[(Target, Rule, DepTree)] ? error: cyclic type definition
08:28:40 <Lemmih> MarcWeber: You can do: newtype DepTree = DepTree [(Target, Rule, DepTree)]
08:30:09 <dcoutts_> xerox_, the librsvg website says that 2.13 is their development branch
08:31:27 <xerox_> dcoutts_: well, okay.
08:34:09 <nooga> how to read a file in a such format into a list of pairs? http://rafb.net/paste/results/Qqyxs630.html
08:35:11 <roconnor> n <- getline
08:35:17 <roconnor> n' = read n
08:35:29 <roconnor> um
08:35:49 <nooga> ?
08:36:44 <roconnor> let readpair = do p <- getline; return (read p)
08:36:48 <roconnor> um
08:37:19 <roconnor> sequenceM (replicate n' repair)
08:37:32 <roconnor> @type replicate
08:37:33 <lambdabot> forall a. Int -> a -> [a]
08:37:39 <roconnor> sequenceM (replicate n' readpair)
08:38:04 <roconnor> something like that
08:38:17 <roconnor> probablby could use some types sprinkled in
08:38:39 <roconnor> let readpair = (do p <- getline; return (read p))::(IO (Int, Int))
08:39:56 <tromp_> i just wrote a fast ackerman function:)
08:40:58 <tromp_> using only succ
08:41:47 <tromp_> it really succs :-)
08:42:17 <tromp_> inc [] = [(0,succ 0)]
08:42:17 <tromp_> inc ((i,a):l) = carry (succ i) (succ a) l
08:42:17 <tromp_> carry i a []          = (i,a): if i==1 then [(0,a)]            else []
08:42:17 <tromp_> carry i a l@((j,b):r) = (i,a): if i==b then carry (succ j) a r else l
08:42:17 <tromp_> ack = mapM print $ iterate inc []
08:46:09 <xerox_> tromp_++ :-)
08:46:14 <nooga> isSub.hs:3:2: parse error on input `<-'
08:46:16 <nooga> 17:35] <roconnor> n <- getline
08:46:16 <nooga> [17:35] <roconnor> n' = read n
08:46:30 <xerox_> nooga: have you ever done I/O in Haskell?
08:46:36 <nooga> umm... no :D
08:46:50 <dcoutts_> cparrott, so do you use gentoo on ppc64 ?
08:46:54 <xerox_> What does the paste really mean, nooga?  :-)
08:47:27 <nooga> it's a tree written as a list of pairs
08:48:00 <nooga> i want to read 2 trees from 2 files and check if the second is a subtree of the first
08:48:10 <xerox_> nooga: what's the Tree datatype definition?
08:48:23 <cparrott> dcoutts_: yes -- also amd64, x86, and sparc
08:48:47 <nooga> oh, it's a binary tree
08:48:49 <nooga> "a data structure in which each record may have two successors"
08:49:04 <dcoutts_> cparrott, ooh, excelent, would you help us test stuff on ppc64?
08:49:10 <xerox_> nooga: are you forced to use that representation in the files?
08:49:17 <nooga> yes
08:49:21 <xerox_> Aww.  :-)
08:49:33 <dcoutts_> cparrott, I've got access to x86, amd64 & sparc but no direct access to ppc64 hardware
08:49:35 <nooga> i already know how to convert tgis list of pairs into a tree
08:49:44 <cparrott> dcoutts_: sure, no problem, I am reinstalling gentoo on my dual G5 at the moment, so it will be a day or two before I will be up and running again
08:49:44 <nooga> but i need to read huge trees from files
08:49:51 <dcoutts_> cparrott, we're tring to get ghc working properly
08:50:02 <cparrott> dcoutts_: I will join #gentoo-haskell, one sec
08:50:03 <xerox_> nooga: each line is a pair of numbers?
08:50:25 <nooga> yes
08:50:45 <xerox_> nooga: if you could add '(', ',', and ')' it would simplify the job.  But it's doable either ways.
08:51:08 <xerox_> First, read the contents of the file with 'getContents', which will give you back a String of the whole file.
08:51:17 <xerox_> Then, split it with unlines.
08:51:22 <xerox_> @type unlines
08:51:22 <lambdabot> [String] -> String
08:51:29 <xerox_> Hmm.  lines.
08:51:32 <xerox_> @type lines
08:51:33 <lambdabot> String -> [String]
08:51:38 <xerox_> Better :-)
08:51:54 <ValarQ> oh, i got a similar problem
08:51:58 <xerox_> Each element of the list returned is in the form "n m", n and m being numbers.
08:52:03 <MarcWeber> When using something like newtype A=A [a] then I can't use the list monad, can I?
08:52:06 <xerox_> nooga: OK so far?
08:52:11 <nooga> yup
08:52:31 <xerox_> nooga: ok.  Now we just need a function from "n m" to (n,m).
08:52:40 <nooga> right
08:52:44 <xerox_> @type words
08:52:45 <lambdabot> String -> [String]
08:52:46 <ValarQ> it's taking a lot of memory because my treebuilding is nonstrict
08:52:50 <MarcWeber> , Lemmih?
08:52:58 <xerox_> nooga: words will split "n m" to ["n","m"].
08:53:09 <Lemmih> , MarcWeber?
08:53:11 <xerox_> I think, at least.
08:53:15 <xerox_> > words "n m"
08:53:16 <lambdabot> ["n","m"]
08:53:30 <xerox_> Can you carry out the rest by yourself?
08:53:34 <MarcWeber> Lemmih scroll 8 lines up
08:53:45 <gour> dcoutts_: can you build hIDE on amd64?
08:54:05 <nooga> i think yes
08:54:09 <xerox_> nooga: cool.
08:54:17 <dcoutts_> gour, not tried yet
08:54:31 <Lemmih> MarcWeber: Perhaps you can derive Monad for A with -fglasgow-exts.
08:55:04 <gour> dcoutts_: ok. i'm curios ;)
08:55:20 <dcoutts_> gour, I bet you are :-)
08:55:53 <gour> dcoutts_: i know you're low-level guy deep inside :-)
08:56:09 <xerox_> dcoutts_ is higher level!
08:56:15 <dcoutts_> both!
08:56:53 * dcoutts_ watches as his machine struggles to compile Wash's HTMLMonad98 module
08:57:05 <xerox_> Wait, the mouse is ringing...
08:57:07 <xerox_> http://www.yappernut.com/def/en/yapperMouse.htm
08:57:07 <MarcWeber> Lemmih I don't really need an new type. Alll I want is a abbreviation.
08:57:26 <gour> xerox_: haskell, i.e. higher-level, is just covering for his lower-level passion to trick the innocent :-)
08:58:23 <gour> xerox_: i.e. dcoutts talks haskell, but C is in his blood ;)
08:58:33 <Lemmih> MarcWeber: But type synonyms may not refer to them self.
08:58:56 <dcoutts_> gour, hmm, no it's the other way around
08:59:12 <dcoutts_> gour, I can do C but Haskell is in my blood
08:59:53 <tromp_> hmm, there's no from Maybe equivalent for lists?
08:59:54 <MarcWeber> dcoutts Can you give me some of your blood? (just kidding)
09:00:01 <dcoutts_> heh :-)
09:00:01 <tromp_> frommaybe
09:00:10 <gour> dcoutts_: it is just temptation if you can resist :-)
09:00:11 <nooga> exactly opposite here
09:02:19 <nooga> xerox:
09:02:25 <dcoutts_> gour, only C when you have to, eg when interfacing with C
09:02:34 <nooga> http://rafb.net/paste/results/894IM661.html
09:02:41 <vincenz> @hoogle writert
09:02:42 <lambdabot> Control.Monad.Writer.WriterT :: WriterT w m a
09:02:42 <lambdabot> Control.Monad.Writer.WriterT :: m (a, w) -> WriterT w m a
09:02:42 <lambdabot> Control.Monad.Writer.runWriterT :: WriterT w m a -> m (a, w)
09:03:26 <gour> dcoutts_: i'll try to minimize those usage as well, considering haskell is still #1 (on the shootout)
09:03:28 <vincenz> anyone care to explain how to ue a WriterT?
09:03:53 * gour hopes that people will start writing more general haskell-libs :-)
09:05:00 <xerox_> vincenz: it's quite simple, did you see the Nomaware's examples?
09:05:15 <tromp_> inc [] = [(0,1)]
09:05:15 <tromp_> inc ((i,a):l) = carry (succ i) (succ a) l
09:05:15 <tromp_> carry i a l = (i,a): case if null l then [(-1,1)] else l of
09:05:15 <tromp_>               (j,b):r -> if i==b then carry (succ j) a r else l
09:05:15 <tromp_> ack = mapM print $ iterate inc []
09:05:26 <tromp_> my first program using case if :)
09:05:27 <vincenz> xerox_: the nomaware examples are all too big and verbos
09:05:45 <xerox_> @google all about monads
09:05:46 <lambdabot> http://www.nomaware.com/monads/
09:05:51 <vincenz> imho nomaware's examples are really hard to understand
09:06:09 <vincenz> they contain a lot of needless crud
09:07:54 <vincenz> why the monoid restriction
09:08:06 <vincenz> basically
09:08:12 <vincenz> I ahve to transform an AST to a simpler one
09:08:17 <vincenz> where during the generation of an expression
09:08:25 <vincenz> I might have to pregenerate some extra statements
09:08:37 <vincenz> hence the writer mnad
09:08:41 <vincenz> so once he expression is done
09:08:42 <vincenz> I write it
09:10:16 <vincenz> is it suggested to do
09:10:21 <vincenz> ErrorT (WriterT
09:10:27 <vincenz> or WriterT(ErrorT
09:13:43 <vincenz> is it possible to .... call ErrorT(WriterT(State X)) from a ErrorT(State X)...and make sure the state threads into it?
09:18:26 <tromp_> is there any better way to express  if null list then list2 else list  ?
09:20:19 <mauke> class Boolean a where toBool :: a -> Bool; instance Boolean Bool where toBool = id; instance Boolean [a] where toBool = not . null;  if' c x y = if toBool c then x else y;  a || b = if' a a b
09:20:22 <mauke> list || list2
09:20:48 <tromp_> cute:)
09:21:04 <mauke> perl style, baby!
09:21:29 <palomer> silly: Maybe.fromJust: Nothing <--is it possible to get a trace from this error?
09:22:50 <Lemmih> palomer: Not really.
09:23:21 <palomer> because I use fromJust all over my code
09:23:30 <palomer> and hunting this down could be a pain:O!
09:24:12 <Lemmih> Prepare to suffer, then. (:
09:24:16 <Beelsebob> palomer: enable profiling mode
09:24:23 <Beelsebob> and then +RTS -hx
09:24:25 <Beelsebob> IIRC
09:24:29 * Beelsebob checks that
09:25:31 <Beelsebob> +RTS -xc -RTS
09:25:37 <Beelsebob> gives you stack trace on error
09:26:59 <xerox_> Fawk.
09:27:04 * Beelsebob prods palomer that useful?
09:27:04 <xerox_> I got disconnected.
09:27:09 <Beelsebob> indeed you did
09:27:37 <xerox_> What did I miss? :-(
09:28:02 <Beelsebob> me saying to enable profiling and then use +RTS -xc
09:28:13 <Beelsebob> and lemmih asking for the pain to begin
09:28:39 <palomer> oh, I didn't know
09:28:40 <palomer> thx
09:29:20 <xerox_> Danke.
09:30:02 <araujo> @yaw!
09:30:02 <lambdabot> quote module failed: getRandItem: empty list
09:30:13 <palomer> <Main.CAF> eh forall  . a
09:30:13 <palomer> <Data.Maybe.CAF>silly: Maybe.fromJust: Nothing
09:30:27 <palomer> what's CAF?
09:30:36 <Lemmih> heh
09:30:38 <palomer> and I'm pretty sure the stacktrace should be longer than this:O!
09:31:00 <palomer> since I don't call fromJust from Main
09:31:16 <Beelsebob> a constant application form
09:31:23 <palomer> hmm?
09:31:26 <Beelsebob> a function with no arguments
09:31:46 <Beelsebob> a constant essentially
09:31:49 <palomer> ahh
09:31:58 <Lemmih> palomer: Welcome to the corner of Hell called 'debugging lazy programs'!
09:32:07 <palomer> oh no
09:32:13 <palomer> so how do I get a real stack trace?
09:32:13 <Beelsebob> Lemmih: OI! That's my chosen hell to work in!
09:32:27 <Beelsebob> palomer: what did the stack trace look like?
09:32:49 <palomer> Beelsebob: that was it
09:33:14 <Beelsebob> in that case it's called directly from main
09:33:20 <Beelsebob> (the main constant)
09:33:38 <palomer> but, erm, it isn't
09:33:45 <palomer> my main is 4 lines
09:33:50 <palomer> none of them contain "fromJust"
09:33:51 <Beelsebob> that's the whole output of the program is it?
09:33:55 <palomer> yup
09:34:16 <Beelsebob> hang on... while I check the format of the stack traces
09:34:59 <Maddas> Out of curiosity, are (many) people here at chalmers?
09:35:25 <Lemmih> I've seen a few from Chalmers.
09:37:34 <Beelsebob> palomer: try hat-trail on it I think is your best aproach
09:39:33 <palomer> hat won't install on my computer:(
09:40:28 <Beelsebob> palomer: why not?
09:40:35 <Beelsebob> what does it bitch about?
09:41:18 <palomer> /home/palomer/src/hat-2.04/lib/ix86-Linux/config:11: *** missing separator.  Stop.
09:41:27 <Beelsebob> palomer: you're running OS X right?
09:41:31 <Beelsebob> oh no
09:41:36 <Beelsebob> odd never seen that one on non-OS X
09:41:42 <Beelsebob> but anyway... easy to fix...
09:41:44 <palomer> debian
09:41:58 <Beelsebob> vi lib/ix86-Linux/config
09:42:06 <Beelsebob> remove the two blank lines before the ghc version number
09:42:19 <Beelsebob> then similarly in targets/ix86-Linux/ghcsym
09:42:20 <MarcWeber> Can you tell me what's wrong here? http://www.rafb.net/paste/results/7IT0oO42.html 
09:42:45 <palomer> there's only one blank line
09:42:58 <Beelsebob> palomer: it should read VALUE = 604
09:43:06 <Beelsebob> not VALUE = 
09:43:06 <Beelsebob> 604
09:43:21 <Beelsebob> and the ghcsym file should only contain one line with 604 on it
09:43:39 <palomer> whoa
09:43:42 <palomer> that's a cooky bug
09:44:00 <Beelsebob> yeh, ghc 6.4 reports it's version oddly on some platforms
09:44:14 <palomer> 6.04 = 6.4 ?
09:44:22 <Beelsebob> 604 == 6.4
09:44:26 <Lemmih> MarcWeber: DepTree isn't a list.
09:45:08 <Beelsebob> palomer: building now?
09:45:15 <palomer> MkProg: hmake: the compiler 'ghc' is not known.
09:45:27 <Beelsebob> what does which ghc say?
09:45:44 <palomer> hmake says this
09:46:03 <palomer> ghc is not known, so it stays mum
09:46:10 <Beelsebob> yeh... what does `which ghc` say
09:46:57 <palomer> /usr/bin/ghc
09:47:06 <Beelsebob> ls /usr/bin/ghc
09:48:15 <palomer> /usr/bin/ghc
09:48:24 <Beelsebob> :o
09:48:30 <Beelsebob> not a symlink to a specific version?
09:48:55 <Beelsebob> MarcWeber: it says that the result of that function should be a DepTree (as you specify in the type signature), but you're trying to return a list
09:49:00 <palomer> lrwxrwxrwx  1 root root 21 Jan 26 21:31 /usr/bin/ghc -> /etc/alternatives/ghc
09:49:14 <Beelsebob> okay... interesting
09:49:29 <Beelsebob> what do you get from hmake --version
09:49:55 <palomer> /usr/bin/hmake: 3.10 (2005-03-11)
09:50:09 <palomer> I just installed it
09:50:33 <Beelsebob> echo "main = print 5" > Jam.hs & hmake Jam
09:50:52 <palomer> [1]   Done                    echo "main = print 5" >Jam.hs
09:50:56 <Igloo> You might need to tell hat to use ghc6 as the compiler
09:51:07 <Igloo> hmake-config list   will show you what compilers hmake knows about
09:51:13 <Igloo> Or you could add hc with hmake-config
09:51:35 <Igloo> s/hc/ghc/
09:51:49 <Beelsebob> that makes sense
09:51:50 <palomer> http://www.rafb.net/paste/results/AgE4p349.html
09:52:07 <Beelsebob> ah, you need to tell it about ghc
09:52:29 <palomer> it seems to know about ghc, no?
09:52:38 <palomer> Jam compiled, btw
09:52:44 <Beelsebob> no, it knows about ghc6, not ghc
09:52:50 <Beelsebob> hat specifically asks to be compiled with ghc
09:54:22 <MarcWeber> Beelsebob Why does ghc assume its a list? (see definitin of DepTree. It should be a list, too)
09:54:38 <palomer> so how do I fix this?
09:54:55 <Beelsebob> MarcWeber: no, it's a list tagged with the DepTree constructor
09:55:01 <Beelsebob> you used newtype not type
09:55:08 <Beelsebob> palomer: run hmake-config
09:55:25 <Beelsebob> I'm trying to remembxer how, but my hmake is currently a little broken
09:55:50 <Lemmih> MarcWeber: It's not a list. It's a new type.
09:56:00 * Beelsebob waits for it to compile
09:56:24 <Beelsebob> MarcWeber: if target `elem`  targets then DepTree [] -- cycle (catch dep tree a-b-a-b ...
09:56:27 <Beelsebob>       else DepTree $ foldr1 testRule []
09:56:31 <palomer> hmake-config add ghc ?
09:56:38 <Beelsebob> palomer: sounds about right
09:56:46 <Beelsebob> add /usr/bin/ghc for good measure :)
09:56:56 <palomer> MkConfig: Config file /root/.hmakerc/debian does not exist.
09:56:56 <palomer>   Try running 'hmake-config new' first
09:57:09 <Beelsebob> on you go then
09:58:35 <palomer> I have to create a new config?
09:58:40 <palomer> won't that mess up my old config?
09:58:41 <Beelsebob> yes
09:58:54 <Lemmih> Morning, SyntaxNinja.
09:58:59 <Beelsebob> you only have a stupid one atm by the looks of it
09:59:30 <SyntaxNinja> hiya Lemmih
09:59:56 <palomer> ok, starting to compile
10:02:54 <palomer> Beelsebob: how do I use this thing once it's compiled?
10:03:05 <Beelsebob> palomer: has it built, yeh?
10:03:19 <MarcWeber> Lemmih, Beelsebob How can I fix that?
10:03:29 <Beelsebob> MarcWeber: I just gave you source to fix it
10:03:50 <MarcWeber> Beelsebob Thanks
10:06:24 <palomer> nope
10:06:26 <palomer> yes
10:06:27 <palomer> built
10:06:36 <Beelsebob> cool, installed too?
10:07:00 <palomer> yup
10:07:09 <Beelsebob> okay, how would you normally build your source?
10:07:21 <palomer> make
10:07:30 <Beelsebob> how complex is the make file?
10:07:58 <palomer> 2 lines
10:08:03 <Beelsebob> what does it do?
10:08:04 <palomer> one for building and one for running
10:08:14 <Beelsebob> what's the build line?
10:08:56 <MarcWeber> Beelsebob Is this the point: create list first, then use DepTree constructor?
10:09:33 <Beelsebob> MarcWeber: the point is that when you do a newtype, you actually create a new type that must be tagged with it's constructor - [] is not a DepTree, DepTree [] is though
10:09:39 <palomer> ghc -o silly --make thefiles
10:09:53 <Beelsebob> okay, so is silly your main file?
10:10:11 <Beelsebob> oh no... that's the output
10:10:14 <Beelsebob> what's your main file called?
10:10:48 <palomer> silly
10:10:52 <palomer> err
10:10:53 <palomer> main.hs
10:11:02 <Beelsebob> okay, in your source directory, do `hmake main`
10:11:10 <Beelsebob> and check that it builds okay
10:11:19 <Beelsebob> (you should get an output called main)
10:12:24 <palomer> err
10:12:30 <palomer> don't I need to do hmake --make main?
10:12:35 <Beelsebob> no
10:12:37 <Beelsebob> hmake main
10:12:40 <palomer> palomer@palomerites:~/school/minhaskell$ hmake main
10:12:40 <palomer> MkProg: Can't find module SType in user directories
10:12:57 <Beelsebob> @index SType
10:12:58 <lambdabot> bzzt
10:13:02 <Beelsebob> @hoogle SType
10:13:03 <lambdabot> Language.Haskell.Syntax.HsType :: HsType
10:13:03 <lambdabot> Prelude.asTypeOf :: a -> a -> a
10:13:03 <lambdabot> Language.Haskell.Syntax.HsTypeDecl :: SrcLoc -> HsName -> [HsName] ->
10:13:03 <lambdabot> HsType -> HsDecl
10:13:17 <palomer> SType is something I compiled
10:13:22 <Beelsebob> ah... okay
10:13:34 <Beelsebob> is SType.hs in your src directory?
10:13:52 <palomer> yeah
10:13:58 <palomer> main depends on a whole bunch of stuff
10:14:07 <palomer> which is why I have a makefile
10:14:18 <Beelsebob> yeh, sure... does SType.hs start with "module SType where"?
10:14:22 <palomer> yup
10:14:26 <palomer> SType(..) where
10:15:00 <Beelsebob> hmake chases dependancies automatically so you don't need the make... hmm, I'm not sure why it's doing that... can you email me the source per chance, and I'll have a gawp
10:17:00 <MarcWeber> Beelsebob Am I able to do this: DepTree []  + DepTree [] ?
10:17:09 <palomer> www.magnesium.net/~palomer/minhaskell.zip
10:17:21 <Beelsebob> MarcWeber: depends... did you define an instance of Num DepTree?
10:17:39 <Beelsebob> :o 2.2MB of source!
10:17:40 <MarcWeber> I didn't define any instance..
10:17:53 <Beelsebob> MarcWeber: then no... + doesn't magically get defined for all types
10:18:06 <palomer> yeah, I have no idea why it's so big
10:18:08 <palomer> maybe the .hi files?
10:18:18 <Beelsebob> MarcWeber: why do you use newtype not type?
10:18:25 <palomer> oh, it's the prof file
10:18:35 <Beelsebob> ah, that makes sense
10:18:41 * palomer had a 13 gig prof file yesterday
10:18:44 <Beelsebob> lol
10:18:45 <palomer> it's actually only 8k
10:18:58 <MarcWeber> Beelsebob cyclic reference. Lemmih told me to do that.. ;-(
10:19:07 <Beelsebob> MarcWeber: ah, fair enough
10:19:09 <MarcWeber> Then it that line compiled
10:19:26 <MarcWeber> So I'll define ++ and I am happy
10:19:36 <Beelsebob> ah, you want to use ++, not +
10:19:57 <MarcWeber> typo. Shit
10:20:02 <MarcWeber> sorry
10:20:07 <Beelsebob> (-|-) (DepTree x) (DepTree y) = DepTree (x ++ y)
10:20:19 <MarcWeber> I would have don it that way, too
10:21:06 <MarcWeber> What does -|- mean? So I shouldn't use ++..
10:21:27 <Beelsebob> MarcWeber: yeh, it just defines a similar op over deptrees
10:21:39 <Beelsebob> palomer: it's case sensitive... hmake Main
10:21:54 <Beelsebob> which gives a parse error on line 21 unsurprisingly
10:22:01 <Beelsebob> (do needs something in it)
10:22:40 <palomer> hmm?
10:22:54 <palomer> make compiles it fine
10:23:03 <Beelsebob> well, the copy of Main.hs you gave me has this in...
10:23:07 <Beelsebob> processExpression y = 
10:23:08 <Beelsebob>     do
10:23:17 <Beelsebob> which unsurprisingly my ghc rejects
10:23:39 <palomer> which file is this?
10:23:44 <palomer> oh, I'm compiling main.hs
10:23:46 <palomer> not Main.hs
10:24:09 <palomer> Main.hs is garbage
10:24:19 <Beelsebob> there's no such file here
10:24:28 <palomer> that's odd
10:24:32 <Beelsebob> oh... which is because I don't have a case sensitive file system
10:24:37 <palomer> ahhh yes
10:24:39 <Beelsebob> so it got eaten by Main.hs when I unzipped
10:24:44 <palomer> I've encountered this before
10:24:52 <Beelsebob> can you do me a zip that doesn't have Main.hs in?
10:25:19 <Beelsebob> and I believe your problem is that hmake is case sensitive SType.hs must be SType.hs, not stype.hs
10:25:59 <palomer> oh, the module name and the filename have to be the same?
10:26:16 <palomer> yes! now I don't have to figure out how to name my files!
10:26:37 <palomer> I uploaded the file again, same url
10:26:37 <Beelsebob> hehe
10:27:58 <Beelsebob> btw... can I yoink this source for experimenting with hat... I need relatively complex examples to work on?
10:28:03 <Beelsebob> ... still d/ling btw
10:29:27 <palomer> sure
10:29:33 <palomer> do whatever you want with it
10:29:49 <Beelsebob> palomer: I still get the same Main.hs file
10:30:01 <palomer> are you using windows?
10:30:12 <Beelsebob> nope, OS X
10:30:29 <palomer> hrm
10:30:32 <Beelsebob> can you rezip with only the hs files and the mhs file?
10:30:39 <palomer> mhs?
10:30:41 <palomer> what are mhs files?
10:30:43 <Beelsebob> test.mhs
10:30:50 <Beelsebob> looks like a minhaskell file
10:31:16 <palomer> oh, righto
10:32:19 <palomer> cleaning up my sources
10:32:36 <MarcWeber> Oh  no.. I've forgotten that my function should rather return IO (MayBe DepTree) instead of DepTree. It's getting really complicated now..
10:34:13 <Beelsebob> heh
10:34:36 <palomer> Parse.o: In function `sfIR_info': undefined reference to `era' <-- I get a gizillion of these when I try to compile with hmake
10:35:02 <Beelsebob> can you lob me the source again now it's tidied up?
10:35:45 <palomer> yeah
10:35:47 <palomer> same url
10:36:01 <Beelsebob> yay for 500k now :)
10:36:29 <palomer> it was the executables
10:36:40 <palomer> 450k of  that is the silly executable
10:36:48 <palomer> btw, what's the best way to not have the .hi files pollute my sources?
10:37:14 <Beelsebob> use darcs and only check in the hs files
10:37:19 <palomer> and the .o files
10:37:23 <Beelsebob> no
10:37:26 <Beelsebob> no .o files
10:37:28 <ValarQ> anyone here who uses haskell-mode and knows how to tweak the indentation at do-notation?
10:37:43 <Beelsebob> palomer: I don't get the error you're getting, I get a type error in Utilities.hs
10:37:50 <Beelsebob> @paste
10:37:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:37:54 <palomer> ValarQ: yeah, it's a _huge_ pain int he ass
10:38:13 <palomer> Beelsebob: did you try make?
10:38:23 <Beelsebob> palomer: no, hmake
10:38:30 <ValarQ> palomer: yeah, i just want something to make it hurt less...
10:38:51 <Beelsebob> okay, type error shown there now
10:39:04 <palomer> oh, righto, forgot to delete utilities.hs
10:39:09 <palomer> actually, I did
10:39:10 <palomer> hrmmm
10:39:11 <Beelsebob> ah, okay
10:39:15 <Beelsebob> oh... oddness
10:39:35 <palomer> hmmmm
10:39:41 <palomer> what's the type error?
10:39:46 <Beelsebob> @paste
10:39:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:39:47 <Beelsebob> top paste
10:40:01 <palomer> whoa, we can paste there!
10:40:13 <Beelsebob> if you have access to the hawiki
10:40:16 <palomer> the makefile should take care of that
10:40:25 <palomer> -fno-monomorphism-restriction
10:40:26 <Beelsebob> palomer: how does the makefile take care of it?
10:40:29 <Beelsebob> ah, okay
10:41:04 <Beelsebob> cool... *waits for hmake to finish*
10:41:27 <palomer> what command did you use exactly?
10:41:38 <Beelsebob> okay... I get linke errors because my ghc install is screwed up... but...
10:41:44 <palomer> I get link errors too
10:41:46 <Beelsebob> hmake -fno-monomorphism-restriction Main
10:41:47 <palomer> tons
10:41:55 <Beelsebob> all undifined symbols?
10:42:04 <Beelsebob> like _ControlziMonadziReader_ZCDMonadReader_con_info
10:42:10 <palomer> undefined references
10:42:21 <Beelsebob> hmm, interesting one
10:42:27 <palomer> Main.o: In function `Main_inferType_srt': undefined reference to `ControlziMonadziReader_zdfMonadReaderr2_closure'
10:42:42 <Beelsebob> hmm, that's an odd one on a stick
10:42:47 * Beelsebob wonders why
10:42:53 <Beelsebob> oh... it'll be a missing package
10:43:05 <palomer> oh, you need to add --make
10:43:11 <Beelsebob> why?
10:43:18 <palomer> hmake --make -fno-monomorphism-restriction Main
10:43:33 <palomer> I don't know, it just works:O)
10:43:33 <Beelsebob> no... --make chases dependancies
10:43:36 <Beelsebob> hmake does that
10:43:45 <Beelsebob> there's a package you use that isn't included
10:43:49 <Beelsebob> need to know what it is
10:44:14 <palomer> package==module?
10:44:44 <Beelsebob> indeed
10:45:00 * Beelsebob wonders how to find out what package it is
10:45:20 <palomer> make compiles it fine though
10:45:28 <Beelsebob> yeh, but it won't when you start using hat
10:46:04 <palomer> if there was a package missing, make wouldn't compile, no?
10:47:01 <Igloo> mtl
10:47:39 <Beelsebob> ah, that got some of them
10:47:44 <Beelsebob> parsec
10:48:14 <MarcWeber> Yeah.. GHC did like it . Thanks Beelsebob, Lemmih!
10:48:24 <Beelsebob> np MarcWeber 
10:49:07 * Beelsebob checks that this compile works now
10:49:16 <Beelsebob> palomer: hmake -fno-monomorphism-restriction -package parsec -package mtl -package QuickCheck Main
10:49:22 <palomer> what's mtl?
10:49:26 <palomer> I don't use QuickCheck
10:49:37 <Beelsebob> mtl is monad readers
10:49:46 <Beelsebob> and you *do* use quickcheck somewhere
10:49:53 <palomer> whoa, where?
10:50:01 <Beelsebob> dunno...
10:50:02 <Beelsebob> ___stginit_TestziQuickCheck_
10:50:11 <palomer> that's really, really strange
10:50:36 <Beelsebob> you also use a lot of odd things so it'll be fun getting this to compile with hat enabled
10:50:40 <palomer> I also use State extensively
10:50:44 <Beelsebob> Data.Map is a pain in the arse
10:50:57 <palomer> and ST
10:51:12 <palomer> I use Data.Map everywhere:o)
10:51:17 <Beelsebob> indeed
10:51:21 <Beelsebob> um, this could be fun
10:51:34 <palomer> I like the fact that it writes over previous entries
10:51:36 <palomer> great for contexts
10:51:40 <Beelsebob> oh bugger *fixes his hat install*
10:52:52 <palomer> be back in 5 minutes
10:57:38 * beelsebob_ wonders where to get the Data.Map source code
10:58:31 * beelsebob_ grabs yhc's implementation
11:01:59 <jethr0> @source Data.Map
11:01:59 <lambdabot> lambdabot 3p290, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
11:01:59 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
11:02:02 <jethr0> hmm
11:02:09 <xerox_> @libsrc Data.Map
11:02:10 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Map.hs
11:02:13 <beelsebob_> ... apparently not
11:02:29 <beelsebob_> ah, useful... I have yhc's version now anyway :)
11:05:57 <beelsebob_> argh... I can't be arsed with sorting Data.Map jsut now
11:06:02 <beelsebob_> hat isn't gonna work on it for the mo
11:06:06 <beelsebob_> because Map is a pita
11:06:51 <palomer> :o?
11:07:02 <palomer> so i have to sort out my trace C-Style?
11:07:24 <beelsebob_> you may well have to... because Data.Map is an absolute pain
11:07:45 <beelsebob_> it uses non-standard haskell that trip up hat-trans
11:07:57 <palomer> can't hat simply ignore Data.Map ?
11:08:22 <beelsebob_> it still needs to put it through hat-trans
11:08:34 <beelsebob_> because it needs all the renamed functions
11:09:04 <Lemmih> beelsebob_: What non-standard haskell does it use?
11:09:08 * palomer wonders why Data.Map uses non-standard haskell
11:09:20 <Lemmih> (it's marked as portable)
11:09:21 <palomer> and Data.Map isn't especially fast, from what I hear
11:09:24 <beelsebob_> Lemmih: I seem to remember it's the fact that it imports Data.Typable
11:09:34 <palomer> can't you use jhc's Data.Map?
11:09:43 <beelsebob_> I'm not sure
11:10:38 <Lemmih> palomer: It should be quite fast.
11:11:07 <palomer> well, erm, sucks that hat can't work with something as simple as Data.Map. Thanks for the help though
11:11:31 <palomer> henceforth I'll use fromJustError
11:12:04 <beelsebob_> palomer: I'm fairly sure it's Data.Typable that gets it
11:12:16 <palomer> is it possible to errorify a function so that if it returns an error I can name that error?
11:12:21 <beelsebob_> I've had it working before, but only on a limited scale and it needs a whole lot of hacknig
11:12:42 <palomer> errorify "in function foo" fromJust bar
11:14:32 <beelsebob_> it should get sorted when tom shackell get's yhc building self-tracing binaries
11:15:08 <palomer> errorify str x = case x of _|_ -> error str | a -> a
11:15:14 <palomer> that would _rock_
11:15:37 <palomer> s/|/;
11:16:02 <Lemmih> It's possible with a little magic.
11:16:06 <palomer> oooh
11:16:09 * palomer likes magic
11:16:44 <xerox_> Are you sure? ;-)
11:16:45 <Lemmih> @type Test.QuickCheck.Batch.isBottom
11:16:46 <lambdabot> forall a. a -> Bool
11:16:55 <palomer> whoa
11:17:04 <palomer> that's pretty magical
11:17:14 <palomer> that's the greatest combinator I've ever seen
11:18:04 <palomer> bbl
11:29:48 <vincenz> how does that work?
11:32:34 <Lemmih> Something like this: \x -> unsafePerformIO (catch (evaluate x>>return False) (\_ -> return True))
11:33:19 <vincenz> btw
11:33:24 <vincenz> sony or ipod?
11:34:07 <Lemmih> @vixen sony or ipod?
11:34:07 <lambdabot> vixen module failed: getRandItem: empty list
11:34:40 <vincenz> @vixen [sony, ipod]
11:34:40 <lambdabot> vixen module failed: getRandItem: empty list
11:34:44 <vincenz> @vixen sony, ipod
11:34:44 <lambdabot> vixen module failed: getRandItem: empty list
11:34:47 <vincenz> @vixen sony, ipod or lala
11:34:48 <lambdabot> vixen module failed: getRandItem: empty list
11:34:51 <vincenz> @vixen 1 2 or 3
11:34:52 <lambdabot> vixen module failed: getRandItem: empty list
11:34:56 * vincenz smacks lambdabot 
11:36:00 <jethr0> @vixen what's the matter with you?
11:36:01 <lambdabot> vixen module failed: getRandItem: empty list
11:36:05 <jethr0> hmm
11:52:41 <sieni_> hmm... would a silc plugin for yi be insane enough as an educational project?
11:53:50 <musasabi> sieni_: maybe using Ginsu would be easier (http://repetae.net/john/computer/ginsu/)
12:49:05 <MarcWeber> Is (MyClass c) => [c]  the type of a list containing instances of class MyClass? If so can I add different instances implementing MyClass to this list?
12:54:59 <Saulzar> MarcWeber, Have a look at existential types
12:56:51 <mwc> MarcWeber, you might be able to do something like data MyClassers = IntanceA instA | InstanceB instB etc.
12:56:57 <Saulzar> On a function foo :: (MyClass c) => [c] then c will be fixed to one type at each use of foo
12:57:02 <MarcWeber> Then my guess was right..
12:57:06 <mwc> er, no, sorry, I wrote that wrong
12:57:24 <mwc> I was thinkiing = InstA MyClassInstance1 | InstB MyClassInstance2
12:57:24 <Saulzar> But you can achieve what you were looking for with existentials
12:57:25 <mwc> etc
12:58:04 <MarcWeber> It's the way you do it in classical OOP. (C++, Pascal, Java .. ) I still can't "think in Haskell"
12:58:41 <mwc> Yeah, Existential types are exactly what you want:
12:58:47 <mwc> http://www.haskell.org/hawiki/ExistentialTypes
12:59:00 <mwc> There's some sample code on there too
13:01:29 <MarcWeber> Exactly. Thanks!
14:05:42 <Beelsebob> @hoogle IO (a -> b) -> a -> IO b
14:05:43 <lambdabot> No matches, try a more general search
14:05:58 <Beelsebob> @hoogle IO (a -> b) -> IO a -> IO b
14:05:59 <lambdabot> No matches, try a more general search
14:06:12 <Beelsebob> bah... how the hell do I run this function
14:06:19 <Beelsebob> I guess I need to bind it
14:06:21 <Beelsebob> sillyness
14:06:45 <Saulzar> @hoogle ap
14:06:45 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
14:06:45 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
14:06:45 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
14:06:59 <Beelsebob> ah... useful
14:09:07 <Beelsebob> hmm... how do I make lambdabot perform an action
14:09:38 <Lemmih> An action?
14:09:53 * Beelsebob performs an action
14:10:06 <Beelsebob> Beelsebob|Home: @slap things
14:10:07 <Beelsebob> lambdabot: /me smacks things about with a large trout
14:10:11 <Beelsebob> ... not right
14:10:16 <Lemmih> Oh, you don't.
14:10:21 <Beelsebob> why not?
14:10:54 <Lemmih> Noone has written such a plugin yet.
14:11:00 <Beelsebob> oh, okay
14:11:09 <Beelsebob> where's the function in it that runs a command?
14:11:25 <Beelsebob> i.e. where does it pass off strings to the modules?
14:11:58 <Lemmih> I don't know. I haven't hacked lambdabot.
14:12:02 <Lemmih> @where lambdabot
14:12:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:14:28 <MarcWeber>   dynamicDependencies :: t -> IO [TargetObj]
14:14:28 <MarcWeber>   dynamicDependencies = return []
14:14:28 <MarcWeber> What is wrong here?
14:14:57 <MarcWeber> t is missing thanks
14:24:49 * Beelsebob tries to figure out IRC protocol for actions
14:31:39 <MarcWeber> Is there a function to test wether a file exists? get its time stamp? I've tried hoogle and tags and I've looked into the System directory.. Did I miss it?
14:33:49 <shapr> There is a file exists function.
14:34:06 <shapr> And you get can timestamp from the stat command maybe?
14:34:20 <Beelsebob> shapr: how do I link another library into lambdabot?
14:34:31 <Beelsebob> tatd2@jet ~/lambdabot-test $ ./lambdabot 
14:34:31 <Beelsebob> lambdabot: ./IRC.o: unknown symbol `__stginit_Char_'
14:34:31 <Beelsebob> lambdabot: user error (resolvedObjs failed.)
14:34:31 <Beelsebob> when I used Char (chr)
14:34:58 <Lemmih> Beelsebob: Try Data.Char
14:35:29 <Beelsebob> yep, that's working
14:35:47 <Beelsebob> bugger... that didn't work
14:36:09 * Beelsebob tries to figure out how to make it do an action
14:36:37 <shapr> Maybe it's a ctcp action?
14:36:45 <Beelsebob> hmm?
14:36:53 * Beelsebob confused by that
14:36:59 <MarcWeber> I've found it now doesFile/DirectoryExist
14:37:22 <Beelsebob> I've been told it should be PRIVMSG [target] :\u0001ACTION [action]\u0001
14:37:28 <shapr> Beelsebob: try verbose = True in lambdabot, and then look at the output.
14:37:34 <shapr> @echo fooby
14:37:34 <lambdabot> echo; msg:Message {msgPrefix = "shapr!n=user@2002:51e0:9345:0:0:0:0:2",
14:37:34 <lambdabot> msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo fooby"]} rest:"
14:37:34 <lambdabot> fooby"
14:38:50 <Beelsebob> [10:37pm] Beelsebob|Home: @slap somithng
14:38:51 <Beelsebob> [10:37pm] *** lambdabot slaps somithng
14:38:55 <Beelsebob> YAY!
14:39:02 <shapr> w00
14:39:13 <Beelsebob> it's a dirty dirty hack, but hey
14:39:39 <Beelsebob> @hoogle isWhitespace
14:39:39 <lambdabot> No matches found
14:39:44 <Beelsebob> @hoogle isSpace
14:39:45 <lambdabot> Data.Char.isSpace :: Char -> Bool
14:39:45 <lambdabot> GHC.Unicode.isSpace :: Char -> Bool
14:41:34 <shapr> MarcWeber: I think posix has a stat command that returns a big tuple, and the various timestamps are in there, maybe?
14:47:00 <palomer> isBottom is the best thing in the world
14:47:06 <palomer> how the blazes can it work?
14:47:21 <MarcWeber> shapr: don't ask me why I haven't seen those function at the first time. There is: getModificationTime. Me fool has searched for time instead of Time ;-)
14:50:32 <Cale> isBottom a returns False if a is distinct from bottom. If a equals bottom and results in an exception which is caught by isBottom, and this exception is of a certain kind (see below), then isBottom a = True. Other caught exceptions are re-thrown. If a never reaches a weak head normal form and never throws an exception, then isBottom a never terminates.
14:51:29 <Beelsebob> how do I grab a darcs patch to send it manually?
14:51:56 <palomer> > [1,2] /= [2,3]
14:51:57 <lambdabot> True
14:53:14 <palomer> Cale: oh, so it only catches exceptions
14:53:17 * Beelsebob prods people
14:53:45 <Cale> palomer: of course. It doesn't solve any undecidable problems :)
14:54:22 <palomer> that would rock
14:54:28 <Beelsebob> shapr: any idea how to bundle up the patch without letting darcs send it?
14:54:29 <palomer> so _|_ isn't always the same
14:54:34 <palomer> since it can be caugth by isBottom
14:54:37 <edwinb> solving undecidable problems wouldn't rock. We'd be out of work ;)
14:54:37 <Cale> right
14:54:38 <Beelsebob> darcs failed:  failed to send mail to: Don Stewart <dons@cse.unsw.edu.au
14:54:47 <Cale> or by Control.Exception.catch
14:55:18 <edwinb> Beelsebob: isn't darcs send -o foo what you want?
14:59:55 <Beelsebob> @karma me
14:59:55 <lambdabot> me has a karma of 1
15:00:00 <Beelsebob> bah
15:00:14 <Beelsebob> @karma
15:00:14 <lambdabot> You have a karma of 2
15:00:56 <palomer> @karma palomer
15:00:56 <lambdabot> You have a karma of 2
15:00:58 <palomer> woot
15:02:15 <Cale> @karma
15:02:16 <lambdabot> You have a karma of 5
15:02:24 <Cale> @dogma
15:02:24 <lambdabot> Unknown command, try @listcommands.
15:02:57 <Lemmih> @karma You
15:02:57 <lambdabot> You has a karma of 0
15:03:10 <palomer> oh my, I'm almost half way to beating Cale
15:03:14 <palomer> let the games begin!
15:03:18 <palomer> @karma ski
15:03:18 <lambdabot> ski has a karma of 3
15:03:52 <palomer> do you guys realize that I to frequent this channel for 2 years before I decided to try out haskell?
15:05:17 <Excedrin> missing "started" maybe?
15:05:21 <Cale> yeah
15:05:27 <Cale> :)
15:05:42 <Cale> @karma dons
15:05:43 <lambdabot> dons has a karma of 22
15:05:59 <TuringTest> @karma lambdabot
15:05:59 <lambdabot> lambdabot has a karma of 10
15:07:38 <Saulzar> @karma @karma
15:07:38 <lambdabot>  @karma has a karma of 0
15:08:24 <Cale> @karma has a karma of 0
15:08:24 <lambdabot> has has a karma of 0
15:08:30 <Saulzar> palomer, Well you're a slacker then :)
15:08:32 <Cale> @karma "has a karma of 0"
15:08:33 <lambdabot> "has has a karma of 0
15:08:37 <Cale> bah :)
15:08:44 <Cale> @karma has_a_karma_of_0
15:08:44 <lambdabot> has_a_karma_of_0 has a karma of 0
15:08:59 <Saulzar> Hehe.
15:09:07 <palomer> 2 years!
15:09:32 <palomer> and, if I hadn't had questions about lambda calculus, I might never had started using haskell
15:09:40 <shapr> Beelsebob: You can send patches to a file.
15:09:49 <Beelsebob> shapr: yeh, sorted
15:09:52 <Beelsebob> they're off to dons
15:09:52 <shapr> k
15:10:02 <Cale> @karms shapr
15:10:02 <lambdabot> shapr has a karma of 16
15:10:05 <shapr> w00
15:10:13 <Pseudonym> @karma dons
15:10:14 <lambdabot> dons has a karma of 22
15:10:17 <Pseudonym> ha!
15:10:24 <shapr> @karma Pseudonym 
15:10:24 <lambdabot> Pseudonym has a karma of 2
15:10:28 <Pseudonym> :-)
15:10:30 <Saulzar> lambdabot dons has a karma of 22
15:10:30 <Saulzar> * Pseudonym (n=ajb@lindor.alicorna.net) has joined #haskell
15:10:52 * Pseudonym must be psychic
15:10:53 <shapr> Pseudonym: dons truly deserves all his good karma :-)
15:10:59 <Pseudonym> Absolutely.
15:13:56 <araujo> http://dev.gentoo.org/~araujo/screens/himerginglog3.jpeg
15:14:03 <palomer> a let in a do block is always lazy, right?
15:14:09 <Cale> yeah
15:16:56 <tromp> any let is lazy
15:20:36 <palomer> @karma samB
15:20:36 <lambdabot> samB has a karma of 0
15:20:40 <palomer> @karma SamB
15:20:41 <lambdabot> SamB has a karma of 9
15:22:12 <shapr> I wish it weren't case sensitive.
15:23:29 <astrolabe> Sometimes peoples names only differ in capitalisation though.
15:23:50 <Cale> not on IRC
15:24:14 <palomer> shapr: I'm still on the hunt for more drone rock
15:24:18 <palomer> shapr: I foudn one other song
15:25:19 <astrolabe> Wasn't there a frederik and a Frederik at the same time?
15:26:09 <vincenz> aloha
15:26:53 <vincenz> astrolabe: just do a whois on an alternate casing of your name
15:27:08 <vincenz> fuck I'm tired, 13 hours at the office
15:27:23 <MarcWeber> I don't understand this error: http://www.rafb.net/paste/results/VBrZOd88.html
15:27:42 * MarcWeber throws a cup of coffee at vincenz ;-)
15:28:20 <Cale> MarcWeber: What is the type TargetList?
15:28:39 * vincenz smiles at MarcWeber 
15:28:40 <TuringTest> MarcWeber: List is a monad
15:28:50 <MarcWeber> data TargetObj = forall t. (Target t) => TargetObj t
15:28:50 <MarcWeber> type TargetList=[TargetObj] -- see Existantial Types
15:29:10 <Cale> MarcWeber: note that allDependencies t should be a list
15:29:24 <MarcWeber> TuringTest Why is List monad used? I want IO monad
15:29:27 <Cale> you can use do notation to build a list (using the fact that list is a monad)
15:29:41 <Cale> but if you want the IO monad, you need to return an IO computation, not a list
15:30:00 <Cale> so the type sig should be allDependencies :: t -> IO TargetList
15:30:07 <TuringTest> MarcWeber: Could you show the type of "TargetList" and "TargetObj" ?
15:30:21 <TuringTest> Ah..Cale spotted it.
15:30:24 <MarcWeber> Cale I want IO list 
15:30:38 <Cale> allDependencies :: t -> TargetList -- you have this
15:30:46 <Cale> allDependencies :: t -> IO TargetList -- you probably want this
15:31:11 <MarcWeber> Cale: You are a walking compiler ! ;-)
15:31:27 <Cale> hehe
15:31:50 <vincenz> MarcWeber: cale has a builtin alex,happy and monadic typer
15:32:23 <vincenz> out of curiousity
15:32:29 <MarcWeber> This term is said to be used for people having passed Java certifications ..
15:32:37 <Cale> also, --<<<< won't be treated as the start of a comment
15:32:48 <vincenz> can I call a ErrorT(WriterT(State Env)) from a ErrorT(State Env) and keep the state threaded?
15:33:17 <MarcWeber> Cale That was only meant for you to find line 29
15:33:22 <Cale> right :)
15:33:35 * MarcWeber has to read that line again
15:33:40 <Cale> just a warning, in case that's actually in your code anywhere :)
15:33:45 <vincenz> Cale: can i?
15:33:50 <Cale> vincenz: hmm
15:34:03 <vincenz> can I call a ErrorT(WriterT(State Env)) from a ErrorT(State Env) and keep the state threaded?
15:34:16 <MarcWeber> *lol* I thought right was Cales answer to vincenz question
15:34:34 <Cale> yeah, I saw the question, just thinking about it. It might be possible, but there's no easy way.
15:34:56 <vincenz> hmm
15:34:56 <vincenz> damn
15:35:19 <Cale> like, certainly, you can capture the state and run it and put the new state back into the other monad
15:35:30 <vincenz> yeah
15:35:33 <vincenz> not exactly nice tho
15:35:37 <Cale> and propagate any errors
15:35:46 <Cale> you could even write a separate combinator for that
15:36:02 <vincenz> I take it that calling WriterT(ErrorT(Env State)) should be easier?
15:36:16 <Cale> yeah
15:36:19 <TuringTest> Maybe
15:36:23 <Cale> you just runWriterT
15:36:25 <vincenz> yep
15:36:39 <vincenz> but then I have to encode explicitly what to do on failure
15:36:49 <vincenz> instead of just letting the whoel thing fai
15:37:29 <TuringTest> @type Control.Monad.Writer.runWriterT
15:37:30 <lambdabot> forall w a (m :: * -> *).
15:37:30 <lambdabot>             Control.Monad.Writer.WriterT w m a -> m (a, w)
15:38:04 <Cale> well, the ErrorT will still be there
15:38:22 <Cale> even after running the outer transformer
15:38:25 <TuringTest> Yes, The m (a, w) will have the error value or success stored in 'a'
15:38:42 <TuringTest> @type Control.Monad.Error.runErrorT
15:38:43 <lambdabot> forall a e (m :: * -> *).
15:38:43 <lambdabot>            Control.Monad.Error.ErrorT e m a -> m (Either e a)
15:39:17 <TuringTest> runWriterT will return "m (Either e a, w)"
15:39:25 <vincenz> let me run to the nightshop for cigarettes and coke
15:39:28 <vincenz> and explain the problem
15:39:32 <vincenz> maybe there's a cleaner solution
15:39:38 * TuringTest signs off
15:44:36 <xerox_> @type (Control.Monad.Error.runErrorT (undefined :: Control.Monad.Error.ErrorT e (Control.Monad.Writer.Writer w) a))
15:44:37 <lambdabot> forall e
15:44:37 <lambdabot>                                         a.
15:44:37 <lambdabot>                                       Control.Monad.Writer.Writer
15:44:37 <lambdabot> w
15:44:37 <lambdabot>                                                (Either e
15:44:39 <lambdabot>                                                   a)
15:44:53 <Cale> ew, stupid type formatter :)
15:44:56 <xerox_> :-\
15:45:05 <xerox_> I see what that mean, tho, cool.
15:46:32 <vincenz> so
15:46:36 <vincenz> mind if I lay it on you?
15:46:57 <Cale> go for it
15:47:00 <vincenz> ok
15:47:01 <vincenz> so far
15:47:06 <vincenz> all my analysis has done AST -> AST
15:47:15 <vincenz> with different instances of Ast (using decorations)
15:47:42 <vincenz> they typically were in ErrorT (State Env) monads for some Env
15:48:11 <vincenz> now I want to go to an IR (which sadly shares a lot of constructor names with my AST cause it's just a simplified version of it)
15:48:19 <vincenz> an example
15:48:22 <vincenz> somelineofcode;
15:48:34 <vincenz> a = b+f(c&&d++)
15:48:47 <vincenz> now
15:48:54 <vincenz> after the termination of someline of code
15:49:11 <vincenz> ( I will have the AST stms transform to () and have all the code generation as side effect with WriterT)
15:49:14 * shapr throws a lambda at vincenz 
15:49:15 <vincenz> I start on the line with obvious code
15:49:43 <vincenz> I enter... I see an assignment... so far so good... I see an addition ,left side has no side-effects, ok keep transform right side (we're in exp now btw)
15:49:58 <vincenz> then I see f(c&&d++)
15:50:05 <vincenz> I don't allow function calls in expresions
15:50:09 <vincenz> so I generate a piece of code
15:50:22 <vincenz> temp = f(c&&d++)... and keep processing the subexpression
15:50:31 <vincenz> as I see that c&&d++ is actually an if statement
15:50:40 <vincenz> before I tell the full statement I just generated in the subeval
15:50:50 <vincenz> I start generating the ifblock for that c&&d++
15:50:54 <vincenz> with another temporary
15:51:00 <vincenz> once I finish... I come back to the function call
15:51:04 <vincenz> so it's temp f(temp2)
15:51:06 <vincenz> this is fine
15:51:10 <vincenz> statement get's telled
15:51:15 <vincenz> I pop back to my original context
15:51:20 <vincenz> and generate at last a = b+temp
15:51:34 <vincenz> so as I enter expressions I might have to generate code
15:51:37 <vincenz> hence my reasoning for WriterT
15:51:56 <MarcWeber> Can you help me again? Scroll down till "in short"  http://www.rafb.net/paste/results/lHT5k471.html
15:52:46 <MarcWeber> How to tell ghc which monad to use? I've never met this syntax.
15:52:58 <xerox_> What a mess! :-D
15:53:22 <Cale> vincenz: okay
15:53:26 <Cale> vincenz: seems sensible
15:53:32 <vincenz> Cale: cool
15:53:39 <vincenz> MarcWeber: why are you using IO for everything
15:54:02 <MarcWeber> Because I the final implementation will access the filesystem
15:54:11 <MarcWeber> And that all are IO operations
15:54:57 <MarcWeber> xerox_ Was this related to my rafb.net text? If so why?
15:55:08 <vincenz> MarcWeber: line 32
15:55:23 <vincenz> MarcWeber: isOneFalse needs an extra param
15:55:36 <vincenz> o.O
15:55:45 <Cale> isOneResult takes 4 parameters
15:55:54 <vincenz> ye
15:55:57 <vincenz> ..p
15:56:09 <vincenz> but this seems like a lot of list mapping and filtering
15:56:27 <MarcWeber> oh no.. I didn't use it for the other ones.. I should go to bed
15:56:29 <palomer> what's a shorter way of writing do {(x,_) <- foo; return x}
15:56:45 <vincenz> palomer: foo >>= (x,_) -> return x
15:56:48 <Cale> fmap fst foo
15:56:53 <vincenz> palomer: foo >>= \(x,_) -> return x
15:56:58 <vincenz> or what cale said
15:56:59 <vincenz> he's good
15:57:16 <Cale> > fmap fst [(1,2),(3,4),(5,6)]
15:57:16 <lambdabot> [1,3,5]
15:57:29 <vincenz> > fmap fst J(ust (1,2))
15:57:30 <lambdabot>  Not in scope: `ust'
15:57:32 <vincenz> > fmap fst (Just (1,2))
15:57:33 <lambdabot> Just 1
15:57:43 <Cale> > do (x,_) <- [(1,2),(3,4),(5,6)]; return x
15:57:45 <lambdabot> [1,3,5]
15:57:45 <palomer> fmap? I would have thought lift would be more appropriate, no?
15:57:54 <vincenz> @type fmap
15:57:55 <xerox_> palomer: fmap == liftM.
15:57:55 <lambdabot> forall (f :: * -> *) b a.
15:57:55 <lambdabot>    (Functor f) =>
15:57:55 <lambdabot>    (a -> b) -> f a -> f b
15:57:56 <Cale> liftM and fmap are the same thing
15:57:58 <vincenz> palomer: monads are fucntors
15:58:05 <vincenz> Cale: they are?
15:58:05 <palomer> oh, it's liftM
15:58:05 <Cale> only liftM has a more restrictive type
15:58:09 <palomer> @hoogle liftM
15:58:09 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
15:58:09 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
15:58:09 <lambdabot> r
15:58:09 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -
15:58:09 <lambdabot> > m a3 -> m r
15:58:11 <palomer> @hoogle lift
15:58:12 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
15:58:13 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
15:58:16 <lambdabot> a
15:58:17 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
15:58:17 <vincenz> @hoogle elevator
15:58:19 <lambdabot> No matches found
15:58:22 <vincenz> darn americans
15:58:23 <palomer> gah, liftM and lift confuse me
15:58:24 <Cale> (conceptually the same thing)
15:58:38 <Cale> lift is for monad transformers
15:58:46 <vincenz> elevator is for monad buildings
15:58:54 <Cale> hehe
15:58:56 <xerox_> haha
15:59:22 <vincenz>  
15:59:31 <vincenz> time to try this WriterT thingy
15:59:43 <vincenz> I guess I'll just do a runWriterT for each procedure
15:59:59 <vincenz> (reason I need state is for my fresh uniqueid's for new variables)
16:00:08 <sieni_> it is strange how the most important principle of software engineering is claimed to be only specific to object oriented programming: http://en.wikipedia.org/wiki/Dependency_inversion_principle
16:00:12 * palomer has just found a nasty bug
16:00:36 <vincenz> que es depencency inversion principle?
16:00:45 <sieni_> I would think that functional (or even C) programmers would have something to say about that
16:00:56 <Pseudonym> I'm not certain that I'd call that the most important principle.
16:01:06 <sieni_> http://www.objectmentor.com/publications/dip.pdf
16:01:15 <vincenz> Cale: on another note, any fix to the fact that my IR and my AST share a lot of data and type constructor names?
16:01:29 <sieni_> Pseudonym: depends how much legacy code you have written or maintained :-)
16:01:50 * vincenz blinks at the document sieni_ gave him
16:01:52 <vincenz> DAMN
16:01:54 <palomer> does lift have anything to do with liftM?
16:02:05 <vincenz> next time I see a girl I'll ask her if she's been "had by reference" 
16:02:27 <Pseudonym> I've maintained plenty of legacy code, but most of it wasn't purely OO.
16:02:45 <dons> ah well, it had to happen. the C guys implemented 3 programs, and are noow back in 1st, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:02:54 <sieni_> vincenz: it's not related in any way to C++ or even OO.
16:02:56 <xerox_> vincenz: you should see the other Writer functions, like censor and... I don't remember the others' names.  They could avoid getting into multiple runWriters.
16:03:11 <dons> though not by much. enough that packed strings would beat them, I reckon.
16:03:54 <vincenz> xerox_: I know they'll be run one after the other
16:04:03 * vincenz has only been "had by value" never by refernece
16:04:27 * Pseudonym has been had by name
16:04:51 <vincenz> Pseudonym: lazy evaluation, hmm?
16:05:12 <Pseudonym> Yup.  Thankfully it was never evaluated.
16:05:43 <vincenz> poor girl
16:06:13 <Pseudonym> Well, it turns out it wasn't needed to produce output.
16:06:37 <palomer> gosh that was an annoying bug
16:06:49 <palomer> oh my, time to implement patterns
16:06:51 * palomer shivers
16:06:54 * vincenz goes to boot ihs laptop
16:08:46 <Pseudonym> Seems to me that this "dependency inversion principle" is a corollary from the principle of separating mechanism from policy.
16:09:15 <mwc> Why am I getting a warning about overlapping patterns here:
16:09:16 <mwc> pointOnBoundary (x,y) = case (x,y) of
16:09:17 <mwc>         (0,_) -> True -- Along the left edge
16:09:17 <mwc>         (_,0) -> True -- Along the bottom edge
16:09:17 <mwc>         (spanX,_) -> True -- Along the right edge
16:09:17 <mwc>         (_,spanY) -> True -- Along the upper edge
16:09:17 <mwc>         otherwise -> False -- We're in the interior
16:09:38 <vincenz> mwc: emm
16:09:41 <mauke> spanX,_ matches, always.
16:09:45 <vincenz> (spanX, _) Ã¹atches anything
16:10:02 <mwc> oh, right, sorry, I meant guards, thanks a lot
16:11:39 <vincenz> re on lappy
16:11:56 <vincenz> don't you hate it when you go talk to your advisor and you come out more confused than when you wnet int
16:14:16 <vincenz> sideline question
16:14:19 <vincenz> any way of doing
16:14:27 <vincenz> type Monad a = (ErrorT String (State Env))
16:14:33 <vincenz> so I can use it in typeclasses
16:14:41 <vincenz> instance TransformT MyMonad
16:14:44 <vincenz> instance TransformT MyMonad ...
16:17:12 <MarcWeber> Where is ClockTime defined in GHC?
16:17:30 <dons> @hoogle ClockTime
16:17:31 <lambdabot> System.Time.ClockTime :: ClockTime
16:17:31 <lambdabot> System.Time.getClockTime :: IO ClockTime
16:17:31 <lambdabot> System.Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
16:18:58 <MarcWeber> dons: then import System.Time should suffice? Unfortunately that doesn't. I've asked hoogle before, too
16:20:33 <MarcWeber> dons Directory.hs is using              import System.Time ( ClockTime(..) ) 
16:20:38 <dons> import System.Time
16:20:38 <dons> main = do c <- getClockTime
16:20:38 <dons>           print c
16:20:51 <dons> works for me.
16:21:14 * palomer is scared of pattern matching
16:22:10 <MarcWeber> dons I want to compare ClockTimes : I've tried this: maximumBy (\ (ClockTime a) (ClockTime b) -> compareInt a b) times
16:24:17 <MarcWeber> There is diffClockTimes..
16:24:38 <MarcWeber> I have to recreate my tags not omitting hsc files
16:25:36 <joelk> MarcWeber, according to the docs, Clocktime is an instance of Ord, so shouldn't max work?
16:27:11 <vincenz> > Control.Monad.Writer listen (do {tell "a"; tell "b"})
16:27:12 <lambdabot>  Not in scope: `tell'
16:27:23 <vincenz> > Control.Monad.Writer listen (do {Control.Monad.Writer.tell "a"; Control.Monad.Writer.tell "b"})
16:27:24 <lambdabot>  Not in scope: `Control.Monad.Writer.tell'
16:27:36 <vincenz> > Control.Monad.Writer.listen (do {Control.Monad.Writer.tell "a"; Control.Monad.Writer.tell "b"})
16:27:37 <lambdabot>  Not in scope: `Control.Monad.Writer.tell'
16:27:58 <vincenz> so I do listen instead of runWriter?
16:28:07 <MarcWeber> joelk Thanks. not max max is of type a -> a-> a but maximum 
16:28:37 <Pseudonym> BRB.  Rebooting.
16:28:41 <vincenz>     decls' <- execWriterT $ sequence $ map transform decls
16:28:41 <dons> MarcWeber, CockTime has two fields, and yeah, you can use Ord stuff.
16:28:44 <vincenz> this correct?
16:29:22 <dons> data ClockTime = TOD Integer Integer
16:29:40 <dons> so your pattern bind would fail, in any case.
18:44:00 --- topic: '["Submit a paper to the Haskell Workshop:","http://haskell.org/haskell-workshop/2006","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]'
18:44:00 --- topic: set by kosmikus on [Thu Feb 16 05:43:08 2006]
19:08:33 <palomer> Cale: what's the context?
19:08:44 <palomer> in sml it would say "domain of function is blah, but you passed foo"
19:08:46 <palomer> which is very clear
19:09:21 <davidmccabe> "foo was a complete suprise to me, given that the domain of function is blah."
19:10:03 <palomer> yeah, that would be great too
19:11:15 <palomer>             subpatsTypes <- lift $ mapM (\x -> processPat_ assoc x) subpats <--- how would one do what I want to do (which might be clear from the context?)
19:12:58 <palomer> oh, righto, nevermind
19:14:11 <davidmccabe> yay! I'm finally starting to expect what things do.
19:14:22 <palomer> hmm?
19:14:36 <davidmccabe> <- newbie, just wrote two functions in a row that worked the first time.
19:15:26 <palomer> wait, I've seen you around a million times
19:15:34 <davidmccabe> not here.
19:15:55 <davidmccabe> on #emacs? #freematrix?
19:16:25 <davidmccabe> seen my evil twin?
19:16:31 <palomer> emacs probably
19:16:33 <palomer> yeah, emacs
19:16:39 <palomer> and you probably helped me a gizzilion times
19:16:51 <davidmccabe> probably not. though your nick seems vaguely familiar.
19:26:06 <palomer> yes! We have patterns!
19:26:15 <palomer> I can't believe that worked
19:28:11 <palomer> man that _rocks_
19:29:36 <palomer> let a = \x -> case x of True -> False in a True <--it parses and types this correctly
19:29:37 <palomer> weeeeee
19:31:33 <palomer> -> is a really, really special type variable
19:31:41 <palomer> I wonder if everything we do with it can be generalized
19:49:36 <palomer> OMG IT WORKS
19:49:46 * palomer hugs Cale
19:49:49 <palomer> who needs a hug?
19:50:53 <Cale> hehe
19:51:41 <palomer> this is, I assure you, totally unexpected
19:51:47 <palomer> I'm used to it not working
19:52:11 <palomer> now all I need to do is figure out how to get lhs2tex working
19:55:04 <palomer> it seems lhs2tex is to convert tex files
19:55:06 <palomer> I'm confused
19:55:52 <ForgeAus> tex as in latex?
19:56:04 <noclaf> hi, i hope someone can guide me (VERY new to haskell & FP), my end goal is to write a database the way Torsten Grust described it in his "Comprehending Queries" papers...I was trying to define some data types to model SQL, I can't even get that far (I was trying to by pass having to parse an sql query)...the haskell tutorials seem to make sense, but when i sit down to code, I'm lost!  What's a good way to approach this proj? (I'm hoping 
19:56:08 <ForgeAus> (not the fabric the language/proggy)
19:56:10 <palomer> http://tunes.org/~nef/logs/haskell/05.12.13 <--this seems to explain it
19:56:14 <palomer> but I'm being a little thick
19:56:24 <noclaf> yikes, should've broekn it up in to several lines
19:57:37 <ForgeAus> got cut off at I'm hoping here
19:58:44 <noclaf> (I'm hoping haskell isn't beyond my IQ level)
20:01:01 <ForgeAus> hehe its not at least I don't think so.. just prolly different form what u used to, so kinda look at it as an adjustment
20:02:42 <noclaf> actually for a while i tried to find someone i could pay to work on this project, but it seems most haskell programmers are university profs. :)
20:03:07 <ForgeAus> lol really?
20:04:26 <noclaf> yup, after all else fails, try to do it yourself :)
20:05:38 <noclaf> unfortunately, even though I started learning haskell for a specific project, now that I have the most basic idea of what it is, I hate java, can't stand my daily routine of coding jdbc et al. :)
20:05:56 <dons> noclaf, well, maybe this is a common experience :)
20:06:10 <noclaf> so I've heard.
20:06:12 <dons> I haven't touched a line of java since starting haskell full-time about 5 years ago.
20:06:57 <ForgeAus> hehe I didn't like Java so much either
20:06:59 <noclaf> my biggest excuse was that since I am a visual learner, I can't learn a language by reading a book, but i recently found online lectures...
20:07:17 <ForgeAus> hehe
20:07:26 <noclaf> as i watch the lectures, i understand what the prof. is saying, i even anticipate his points...i guess i just need practice
20:39:26 <Revision17> <3 haskell's list comprehension syntax
20:40:39 <dons> <3 is good or bad?
20:40:44 * dons can't tell
20:41:02 <Korollary> what's not to love
20:41:42 <dons> ah, I see.
20:41:43 <fatbrain> dons: <3 <- it's a freaking heart, ascii ftw
20:41:58 <dons> thanks.
20:43:29 <dons> so why not just say "I love haskell's <insert feature here>" ;)
20:47:33 <Korollary> smiley using hypocrite
20:48:18 <dons> there are limits.
20:48:52 <Korollary> @elite I love haskell's <insert feature here>
20:48:52 <lambdabot> elite module failed: getRandItem: empty list
20:49:13 <Korollary> we're out of random numbers.
20:49:28 <dons> yeah, it is such a weird bug
20:49:38 <dons> maybe I look at it now
20:49:50 <dons> at least it's fairly specific 
20:52:40 <musasabi> Is there a good way to parse with HaXML if the shape of the data is known? (basically "given this Haskell datatype definition parse it from the element")
20:56:59 <dons> @quit debugging ..
20:57:09 <dons> @yow
20:57:27 <lambdabot> Barbie says, Take quaaludes in gin and go to a disco right away!
20:57:29 <lambdabot> But Ken says, WOO-WOO!!  No credit at "Mr. Liquor"!!
20:58:59 <dons> well, it doesn't seem to "run out" of random numbers.
20:59:06 <dons> the numbers just stop working at some point.
20:59:19 <dons> i'm logging things, so lets just wait and see if it happens again
20:59:24 <dons> @elite I love haskell's <insert feature here>
20:59:24 <lambdabot> I 1o\/3 h4ske|l's <inzErT ph3atURe h3rE>
21:01:55 <dons> @yow
21:01:56 <lambdabot> FROZEN ENTREES may be flung by members of opposing SWANSON SECTS ...
21:06:02 <palomer> nice
21:27:52 <dons> it amazes me that from Oct 2004 to Feb 2006, there's been 800 patches submitted to lambdabot
21:32:42 <palomer> hmmm
21:32:46 <palomer> it seems my typesystem is unsafe
21:33:00 <palomer> that sucks
