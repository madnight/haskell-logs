00:00:01 <Saulzar> Right, since haskell threads are all the same OS thread... 
00:00:22 <dons> well, you could use forkOS.
00:00:39 <Saulzar> Yeah, that's what I was thinking. Just seems that it might be per-process though
00:01:29 <dons> yeah, I reckon. the man page only talks about per-process resources, of course.
00:01:44 <neologism> isnt there parallel haskell?
00:01:45 <Saulzar> Hmm.
00:03:01 <Saulzar> I want to run 10 or 20 bots with rlimit, I guess it is possible to use seperate processes...
00:03:32 <dons> each with their own rlimit. hmm.
00:08:32 <Saulzar> Fun with serialisation and multi-process communication :)
00:09:43 <dons> hmm. I'm sure someone has pondered this before. perhaps try google, or haskell-cafe@ ?
00:10:55 <Saulzar> There's a fair amount on time limiting
00:11:53 <Saulzar> Was thinking that memory could be problematic
00:13:30 <Saulzar> -Ksize
00:13:30 <Saulzar> [Default: 1M] Set the maximum stack size for an individual thread to size bytes.
00:13:39 <Saulzar> Ah, stack.
00:17:11 <Saulzar> Hmm, something to think about - don't think I'll get too paranoid just yet :)
00:55:52 <lome> why haskell has `if` statement instead of `if` function? it seems to be more logic to have a function not a built-in construction. what's the reason?
00:59:19 <musasabi> lome: an if function would need more parenthesis most of the time.
00:59:45 <musasabi> Defining "if' c a b = if c then a else b" works fine.
01:00:27 <musasabi> Basically "if foo bar then baz bbb else baz ccc" -> "if' (foo bar) (baz bbb) (baz ccc)"
01:06:00 <lome> musasabi: was it the reason to choose built-in if?
01:08:59 <musasabi> lome: yes, I don't think there are many more reasons.
01:09:44 <lome> musasabi: thank you
01:10:28 <musasabi> much of haskell is just making the syntax prettier.
01:10:52 <musasabi> e.g. there is really no need to allow for multiple function bodies, but that makes code more pretty.
01:11:50 <musasabi> like "fac 0 = 1; fac k = k * fac (k-1)" => "fac k = if k==0 then 1 else k*fac (k-1)"
01:16:35 <lome> yes
01:27:23 <cpatrick> lome: 'if' is very ugly in haskell anyway. generally guards are a nicer way of expressing things
01:27:49 <dons> very ugly? I'd say they become less ugly the more Haskell you write :)
01:28:12 <cpatrick> heh, maybe
01:28:54 <dons> (I write a lot more if/then/else than I used to)
01:29:17 <dons> also, when you start throwing do-notation around, if-then-else is good
01:29:31 <dons> (you have to play big tricks to use guards (i.e. emulate them with mzero))
01:29:39 <dons> (use guards in a monadic setting)
01:29:51 <lome> cpatrick: maybe... but i'm intresting in the reason of built-in construction choosing during haskell was designed.
01:29:52 <cpatrick> yeah, that's true
01:30:08 <dons> lome, if-then-else is just syntax for case anyway
01:30:16 <dons> case x of True -> ... ; False -> ... ;
01:30:47 <lome> dons: yes, i understand implementation. but this is not a question :-) anyway thank you
01:31:10 <dons> ok :)
01:31:22 <lome> not the question, sorry my english
01:31:45 <lome> at the moment i have one reason - less parenthesis
01:32:42 <lome> sorry again :) parenthesEs
01:32:51 <dons> it's a good reason :) `when' is annoying for this reason.
01:33:42 <lome> dons: oh, it's true! why i didn't think about `when`? :-(
01:33:50 <Cale> dons: hm?
01:34:20 <cpatrick> @hoogle when
01:34:21 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
01:34:31 <Lemmih> An 'if' function would be a lot worse than 'when'.
01:34:53 <dons> Cale, oh, I was wondering earlier if we're able to use syntax highlighting for code on the new wiki? do you know?
01:34:54 <Cale> yeah
01:35:21 <Cale> dons: I don't actually know. I'm currently under the impression that it's not available
01:35:46 <dons> and is the general idea that new content should go on the new wiki?
01:36:02 <dons> (i still see new things appearing on the old wiki, whats up with that?)
01:36:22 <Cale> Um, I'm not sure. I still contribute to the old wiki.
01:36:34 <Cale> I should probably move a bunch of the stuff
01:36:41 <Cale> at least, what's mine
01:36:48 <Cale> there are licensing issues with moving it all
01:37:32 <Cale> the old wiki doesn't have a specific license, and it's not always obvious who owns content
01:37:37 <dons> yep. i'm not concerned about that. just wondering if we're doing the wrong thing by adding any new stuff to the old wiki?
01:38:00 <dons> transferring things is a separate issue.
01:38:29 <Cale> Well, the old wiki is still running :)
01:38:46 <dons> maybe it should be made read-only. that'd get things moving ;)
01:38:57 <Cale> I don't think anyone plans on killing it any time soon
01:39:03 <Cale> hehe
01:39:16 <Cale> but without syntax colouring on the new wiki, it's a little annoying to lose that
01:39:33 <dons> yep.
01:39:39 <dons> it's not a killer though
01:39:51 <dons> the new wiki is nice I think.
01:40:08 <dons> a lot more organanized.
01:40:35 <Cale> hehe, not for long if people start contributing :)
01:40:58 <Lemmih> dcoutts: ping.
01:41:21 <Cale> anyway, I should sleep
01:41:44 <dons> ah, maybe the new one should be read-only too then! that'll keep everything clean and nice.
01:41:57 <Cale> hehehe
01:43:44 <Cale> have a zen wiki which is completely empty and immutable
01:57:12 <tromp_> morning
02:01:55 <shapr> hoi
02:02:18 <shapr> dons: I'm going to make the old wiki read-only soon.
02:16:53 * tibbe is implementing type inference, his head hurts.
02:23:21 * shapr is implementation a webmonkey banana!
02:23:26 <shapr> er implementing
02:23:38 <shapr> hippie-expand got confused...
02:32:22 <shapr> What's going on in the world of Haskell?
02:32:29 * shapr is bored with Python, as usual...
02:33:28 <Lemmih> I'm trying to hack lexer-based indentation in hIDE.
02:34:00 <shapr> oh nifty
02:37:03 <Lemmih> No more regex'es! Hurrah.
02:59:39 <dcoutts> Lemmih, cool!
03:12:00 * shapr throws lambdas
03:13:52 <cathper> ouch, you got me ... (\x -> 0)
03:17:56 <Lemmih> dcoutts: Any eta on the new TreeModel stuff?
03:18:35 <dcoutts> Lemmih, well we're still discussion some finer points of the high level API (how much type info to include)
03:18:50 <dcoutts> but we could get on with the bits we've agreed on lower down
03:19:13 <dcoutts> Lemmih, probably at least a week or two
03:23:32 <tromp_> there appear to be 5478 tictactoe positions
03:23:57 <shapr> Lemmih: Is an arrival request..  eta expansion ?
03:23:59 * shapr snickers
03:24:39 <tromp_> if you believe this program:
03:24:41 <tromp_> tri = [-1..1]
03:24:41 <tromp_> ttt = [pos|a<-tri,b<-tri,c<-tri,d<-tri,e<-tri,f<-tri,g<-tri,h<-tri,i<-tri,
03:24:41 <tromp_>       let pos = [a,b,c,d,e,f,g,h,i], let balance = sum pos,
03:24:41 <tromp_>       let combos = [a+b+c,d+e+f,g+h+i,a+d+g,b+e+h,c+f+i,a+e+i,c+e+g],
03:24:41 <tromp_>       let wins = filter (== 3) combos, let loss = filter (== -3) combos,
03:24:42 <tromp_>       balance == 1 && null loss || balance == 0 && null wins]
03:25:22 <shapr> tromp_: Have you considered following in the footsteps of Richard Garfield and coming up with the successor to Magic : The Gathering ?
03:25:47 <tromp_> can't say that i have:(
03:25:51 <shapr> Speaking of which, I think I have a coupla guardian beasts and forty multilands around here somewhere.
03:26:02 <shapr> I wonder what they're worth these days.
03:26:09 <tromp_> i was never into magic
03:26:20 <shapr> I was thoroughly addicted.
03:26:27 <tromp_> but always saw it being played in the University of Waterloo coffee lounge
03:26:43 <shapr> I think you of all people should stay away from it.
03:27:13 <tromp_> don't worry, it has too much arbitrariness to it for my taste
03:27:20 <tromp_> that's why i love go:)
03:33:30 <davidhouse_> tromp_, that doesn't consider rotations, reflections and so on
03:37:37 <davidhouse_> tromp_: nice program, by the way :)
03:38:53 <dcoutts> gour, thanks for notifying us about our ebuild cockup earlier, does it build for you now?
03:39:18 <gour> dcoutts: yep, everything is fine
03:39:24 <dcoutts> gour, ok great
03:40:04 <gour> dcoutts: i encounter similar situations when eg. upgrading packages in my overlay and 'forget' to update patches :-)
03:40:51 <gour> dcoutts: do you use any of hp calcs?
03:41:07 <dcoutts> gour, nope
03:41:42 <gour> dcoutt: ahh...i could imagine. no haskell programming with them :-)
03:41:55 <dcoutts> heh
03:43:04 <shapr> actually...
03:43:04 * gour is practicing chart calculation by hand ;)
03:43:17 <shapr> Have you seen the concatenative language implementations in Haskell?
03:43:37 <valez> hello, im tryin to write a function which replace one element of a list with another but the second one should be placed at the same position as the one that was removed, cant work out the last part any ideas thanx
03:43:46 <edwinb> Do hs-plugins have to be compiled with the same version of ghc as the program that loads them?
03:44:25 <shapr> valez: You could find some way to look up the index of the first item and then insert the second item at that same index.
03:45:12 <valez> yes is there a function that can add elements at a specific position
03:45:14 <valez> ?
03:45:15 <genneth> valez: replacing the head of a list is straightforward, and replacing further down just recurses
03:45:32 <shapr> valez: Check out the docs for Data.List
03:46:34 <valez> yeh i did ill have another look thanx
04:02:44 <genneth> shapr: wonder what it looks like in epigram?
04:03:07 <gour> anyone can comment on this one: http://www.pcmag.com/article2/0,1895,1925239,00.asp
04:04:06 <shapr> genneth: List insert? I dunno, would be fun though.
04:04:16 <genneth> list replacement
04:04:37 <genneth>      ( n : Nat ;  xs : List A ;  y : A !                               
04:04:37 <genneth> let  !---------------------------------!                               
04:04:37 <genneth>      !    replaceAt n xs y : List A    )                               
04:04:37 <genneth>                                                                        
04:04:37 <genneth>      replaceAt n xs y <= rec n                                         
04:04:37 <genneth>      { replaceAt n xs y <= case n                                      
04:04:39 <genneth>        { replaceAt zero xs y <= case xs                                
04:04:41 <genneth>          { replaceAt zero nil y => nil                                 
04:04:43 <genneth>            replaceAt zero (cons x xs) y => cons y xs                   
04:04:45 <genneth>          }                                                             
04:04:47 <genneth>          replaceAt (suc n) xs y <= case xs                             
04:04:49 <genneth>          { replaceAt (suc n) nil y => nil                              
04:04:51 <genneth>            replaceAt (suc n) (cons x xs) y => cons x (replaceAt n xs y)
04:04:53 <genneth>          }                                                             
04:04:55 <shapr> yikes
04:04:57 <genneth>        }                                                               
04:04:59 <genneth>      }                                                                 
04:05:03 <genneth> maybe i shouldn't have done that
04:05:05 <genneth> :-$
04:05:08 <jethr0> genneth: use lisppaste
04:05:14 <shapr> Probably would have better to use a paste, it's true.
04:05:25 <shapr> gour: I seriously doubt Apple would switch to Windows.
04:06:09 <gour> shapr: but switch to intel is suspicious
04:06:36 <jethr0> genneth: replaceAt n y xs = let (a,b) = splitAt (n-1) xs in a ++ [y] ++ (drop 1 b)
04:06:44 <shapr> I think intel cpus allow for cheaper hardware.
04:07:13 <jethr0> > let replaceAt n y xs = let (a,b) = splitAt (n-1) xs in a ++ [y] ++ (drop 1 b) in replaceAt 3 5 [1,2,3,4,5]
04:07:14 <lambdabot> [1,2,5,4,5]
04:07:23 <shapr> jethr0: Now can you do that in Epigram? :-)
04:07:28 <pejo> shapr, and faster hardware.
04:07:33 <jethr0> epigram?
04:07:40 <shapr> @google epigram conor
04:07:41 <lambdabot> http://www.cs.nott.ac.uk/~ctm/
04:08:02 <shapr> @where epigram
04:08:02 <lambdabot> http://sneezy.cs.nott.ac.uk/epigram/
04:08:10 <shapr> @where+ epigram http://www.e-pig.org/
04:08:10 <lambdabot> Done.
04:08:14 <shapr> @where epigram
04:08:14 <lambdabot> http://www.e-pig.org/
04:08:41 <jethr0> just wanted to try my rusty haskell skills :). my solution isn't even correct for empty list...
04:08:53 <shapr> gour: I don't see how a switch to windows would benefit Apple.
04:09:31 <shapr> NeXTStep is/was beautiful code, and has created a rabid following because of that. Windows just isn't.
04:09:32 <ozone> gour: ignore dvorak, he's an idiot
04:10:04 <pejo> ozone, don't forget he is convinced that the professor *might* be right!
04:10:13 <ozone> pejo: that professor's also an idiot :)
04:10:33 <shapr> I mean, if Windows were beautiful and elegant, Microsoft wouldn't need monopolistic practices to stay on top.
04:10:40 <gour> ozone: ahh...didn't see that dvorak is the author :-(
04:11:21 <shapr> If Microsoft enforced a fair and equal market, they'd have split the company long ago into OS and app portions, and the OS part would have had to adapt or die.
04:11:41 <genneth> jethr0: epigram actually forced me to think about the nil cases -- i'd have completely forgotten about them otherwise
04:11:56 <jethr0> "enforced an equal market"? are they supposed to cripple themselves?
04:12:01 <gour> sure, but deal with apple would make one competitor less in the battle with linux
04:12:26 <shapr> No, but the spirit that created capitalism is that merit decides the winner.
04:12:41 <shapr> A monopoly is a pathological case of capitalism, in my view.
04:13:48 <jethr0> ok, but microsoft can hardly react to that from inside... that's the job of governments to remove hurtful monopolies
04:14:40 <shapr> I dunno... I wish I could think up a structure or system that would encourage operational units to deliver the most value to their customers instead of delivering the most value to their owners.
04:14:53 <shapr> hm.. maybe that's the solution...
04:15:11 <shapr> Don't sell a product, sell shares and a service?
04:15:13 <jethr0> marxism
04:15:34 <tuomov> monopolisation is the natural course of capitalism
04:15:45 * Beelsebob licks shapr's nose
04:15:45 <shapr> tuomov: I disagree, I think it's a pathological case.
04:16:03 <shapr> Beelsebob: You couldn't possibly do it better than this cute Australian sheperd who's visiting me.
04:16:05 <tuomov> capitalism defined as a system with extensive permanent property rights, not merely as a market economy
04:16:16 <Beelsebob> I see!
04:16:19 <shapr> shepard?
04:16:26 <Beelsebob> don't you mean sheep?
04:16:27 <Beelsebob> :P
04:16:30 * shapr grins
04:16:51 * Beelsebob considers writing a file system for OS X in Haskell
04:17:14 <shapr> Speaking of which, aren't there some Haskell filesystems out there?
04:17:28 <shapr> jethr0: What's the basic idea of marxism again?
04:17:40 <shapr> tuomov: I think you and I have different definitions of capitalism.
04:17:57 <tuomov> capitalism doesn't have monopoly on markets
04:18:00 <shapr> tuomov: Let's make a combinator based economic description calculus, and *then* we can discuss effectively!
04:18:11 <jethr0> shapr: hmm, i'm no expert. but of the basic ideas is to let the people own the production facilities.
04:18:20 <jethr0> s/of/one of/
04:18:28 <tuomov> capitalism is distinguished from other possible market economies by its concept of property. it's capitalism after all. 
04:18:44 <shapr> tuomov: I'm mostly serious about that, I'd like to discuss economic systems where I can look at real details.
04:18:58 <tuomov> markets could exist in a system based on use-based (worked-owned co-ops) property rights, for example
04:19:14 <shapr> I think that's sort of what I was describing.
04:19:22 <shapr> But in any case, how would you describe all this in code?
04:19:49 <shapr> The way to keep this discussion on-topic is to say how we could use Haskell to describe and maybe simulate economic systems.
04:20:08 <shapr> Even something as simple as an economic simulation at the level of Conway's Life would be nifty and illustrative.
04:20:34 <shapr> jethr0: That specific idea makes sense to me.
04:21:07 <tuomov> there are as many definitions of marxism as there are marxists..
04:21:14 <jethr0> shapr: it does to almost everybody. the problem is how to keep people motivated when their labour is rewarded with riches
04:21:28 <jethr0> s/is/isn't/
04:21:30 <shapr> Yeah, but an executable description in Haskell is a definition we can all see.
04:22:14 <pejo> shapr, I just glanced through the house source, but couldn't find a filesystem in there. I might have missed it though.
04:22:17 <shapr> jethr0: Um, why wouldn't work turn into reward? You'd get payout on the shares?
04:22:24 <tuomov> the problem I have with marxists is that most of them tend to favour authoritarian ways to get rid of capitalism and the state
04:22:26 <jethr0> pejo: i haven't found one either
04:22:34 <jethr0> pejo: they've got some ftp stuff or so
04:22:58 <tuomov> and in the end just form their own states..
04:23:04 <jethr0> shapr: no, the idea is to have the production means spread evenly within the people
04:23:16 <shapr> tuomov: Yeah, but how could we simulate all this in Haskell? :-)
04:23:20 <jethr0> otherwise at some point single people would again gain majority of companies
04:23:56 <jethr0> shapr: emerging behaviour with agents driven by needs. and the market with constrained resources
04:24:03 <shapr> Yampa?
04:24:04 <aleator> jethr0: Wasn't A.Smiths original idea to limit big companies so that little people could get capita as well? 
04:24:24 <jethr0> aleator: i've never read smith's work directly
04:25:04 <jethr0> but it's generally agreed upon that monopolies can evolve in pure capitalism and that this leads to a pathologic case if not handled
04:25:14 <tuomov> anyway, marxism doesn't have monopoly on the abolition of state and capital.
04:25:31 <jethr0> true
04:25:36 <aleator> jethr0: Neither have I and its long time since I studied philosophy. But in the essence the original idea was not in any way pure capitalism.
04:25:37 <tuomov> anarchists want that too, in a non-authoritarian way
04:25:41 * shapr still wants to see some code...
04:25:57 * jethr0 didn't know marxism was about abolition of state
04:26:11 <tuomov> jethr0: "the state will wither away"
04:26:16 <tuomov> yeah, right..
04:26:20 <jethr0> k
04:26:24 <shapr> I wonder if we could steal SPJ's financial contracts to make social contracts?
04:26:52 <shapr> Political systems are really a derivative of social contracts like laws...
04:27:56 <shapr> Just like executable security descriptions could come from formal descriptions of personal ethics.
04:28:15 <aleator> Humm. Would be interesting idea. Formulate program about how, for example, taxation works.. Let people fiddle around with them..
04:28:21 <shapr> yeah
04:28:24 <shapr> Politics by spec
04:28:42 <aleator> Not everything, but those things that "go by the book"..
04:28:57 <shapr> Yeah, you'd even be able to describe optimizations in executable terms.
04:29:15 <shapr> I'd like to vote for political candidates with the same process.
04:29:47 <tuomov> I don't vote for people.
04:29:53 <shapr> If they made executable versions of their proposed economic policy changes available for an open source simulator, each voter could download and experiment.
04:30:38 <shapr> Futarchy still looks like the best political process to me. Too bad no one's really tried it.
04:31:00 <tuomov> it's just formalisation of corruption..
04:31:09 <shapr> tuomov: Hm, so you're proposing we vote for rulesets directly? That would make a lot of sense...
04:31:28 <aleator> Voting wouldn't work. But say taxes, student benefits?
04:31:29 <tuomov> direct democracy, of course. in a decentralised manner
04:31:52 <tuomov> if there are representatives, they must have no political power and be instantly recallable and their decision changeable
04:32:10 <shapr> tuomov: That's a neat idea.. gov't directly executes the will of the people rather than following the personal leadership of the gov't officials.
04:32:17 <shapr> Yeah, I see what you mean.
04:32:30 <aleator> Somehow that system would need some measure that keeps ignorant people from voting..
04:32:47 <tuomov> ignorance stems to a great degree from not being able to properly participate
04:32:49 <shapr> I don't think you get that choice in a pure democracy, that's why republics were created.
04:33:03 <aleator> See how songs get popular.. Would you like laws that get popular in same way?:)
04:33:34 <shapr> Lobbying groups do work like the advertising and packaging industry that's wrapped around popular media.
04:33:46 <tuomov> you're assuming that direct democracy were even possible in the current economic system and culture dominated by big business
04:34:38 <tuomov> for such to become practical, other changes are needed as well
04:35:15 <shapr> A reactive economic simulator would be a persuasive tool I think.
04:35:30 <shapr> At least, it would be persuasive to the people who are listening...
04:35:54 <shapr> I've met a surprisingly large number of peoplo who vote purely democrat or republican in the USA.
04:36:35 <shapr> tuomov: Ever looked at Yampa?
04:37:11 <tuomov> yeah
04:37:50 <musasabi> How do I go from the Name of a type to the Type in template haskell?
04:38:24 <shapr> Doesn't Typeable do that?
04:38:29 <shapr> oh wait, TH..
04:38:40 <shapr> tuomov: You think an economic simulator could be written with Yampa?
04:39:08 <musasabi> I reify and get a Dec, but I want a Type not a Dec.
04:39:42 <musasabi> My current plan is to write a "reifyType :: Name -> Q Type" which reassembles type definitions from data definitions.
04:46:42 <musasabi> seems to work :-)
04:46:46 <shapr> yay!
04:49:48 <araujo> Good morning!
04:49:52 <shapr> Does that mean you can migrate typedefs via TH?
04:58:02 <musasabi> I am using it autogenerate code and types, and needed to get the Type.
04:58:57 <musasabi> Like this: http://youzen.b2.fi/~musasabi/a.hs
05:00:03 <musasabi> Basically the code works by passing a list of Handlers to the TH function which then looks at their types and builds suitable types and code to call them all in correct order when the events they are interested in arrive.
05:04:39 * JKnecht thanks #haskell for 'futarchy', off-topic but valuable.
05:25:06 <shapr> JKnecht: Yeah, futarchy roxx.
05:26:10 <shapr> musasabi: Sounds nifty, what are you doing with it?
05:32:13 <jips> hello
05:33:48 <musasabi> shapr: eventhandler stuff, basically avoiding lots of manual boxing/unboxing.
05:34:56 <jips> where can i find more info about new features of ghc 6.5, especially the ghc api?
05:36:34 <Lemmih> jips: The GHC source code.
05:38:43 <jips> hm... can i read the code online somewhere?
05:39:56 <davidhouse> jips, http://darcs.haskell.org/ghc
05:40:10 <jips> cool thanks
05:40:24 <edwinb> http://darcs.haskell.org/ghc/ghc/compiler/main/GHC.hs, more specifically
05:43:29 --- topic: set to '["Submit a paper to the Haskell Workshop:","http://haskell.org/haskell-workshop/2006","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by kosmikus
05:44:01 <JKnecht> shae: however 2 out of 3 of futarchy assumptions are I believe clearly false: neither are the wealthy nations the happy ones, nor does it make sense to have markets determine policy.
05:51:23 <JKnecht> since relative average material prosperity has been conflated with happiness in the 1st, and policy ratification and determination in the second.
05:52:45 <Philippa_> I do think I'm considerably more happy here than I would be in a poorer nation - on the other hand, I'm dependant on the welfare system here anyway, including healthcare stuff that'd seem stupidly expensive in a poorer country
05:54:29 <shapr> JKnecht: I think market predictions make lots of sense actually.
05:54:53 <shapr> kosmikus: Yay! Haskell Workshop! w00!
05:55:22 <JKnecht> well ... I wonder if there is anything like Coq in Haskell?
05:56:10 <shapr> JKnecht: I know that market predictions can only leverage distributed knowledge that exists, there's no silver bullet... but I still think it would be superior to existing solutions.
05:56:29 <liyang> When did this become #politics? o.O
05:56:38 <shapr> In any case, I'd rather have an economic simulator in Haskell that we can use to demonstrate our ideas!
05:56:50 <liyang> That's more like it. ;)
05:57:03 <JKnecht> darcs points the way.
05:57:09 <shapr> Hm, does Liwen Huang ever show up here?
05:57:14 <shapr> JKnecht: hm?
05:58:56 <edwinb> JKnecht: you mean something which can prove properties of Haskell programs?
05:59:03 <JKnecht> shapr: to e.g. token economies (partially) implemented in Haskell (my interest), re econ simulator, political aside above.
05:59:41 <JKnecht> i.e. as an example of a production killer app in haskell (darcs).
06:05:59 <shapr> JKnecht: Yeah, I'd love to have lots of different economy simulators implemented in Haskell.
06:13:41 <tuomov> are there (easy) haskell bindings to sqlite?
06:13:52 <tuomov> or some other standalone database?
06:14:05 <musasabi> haskelldb
06:15:04 <tuomov> it supports sqlite?
06:15:22 <JKnecht> edwinb: yes, that would be good though not I guess what I meant(Coq actually should 'port' to Haskel). But yeah anything like that or say a haskell fuzzy logic pkg/fuzzification of haskell (whatever that would be, maybe allowing different kinds of type inference, dunno). 
06:15:23 <shapr> CosmicRay has a standalone sqlite binding.
06:15:29 <JKnecht> bbl
06:16:25 <edwinb> JKnecht: I was just thinking that there are gadgets for converting Haskell programs to Agda
06:16:33 <edwinb> But I'm still not quite sure what you mean.
06:17:52 <musasabi> tuomov: yes, although if you don't want it, CosmicRays code is probably the best alternative.
06:17:56 <tuomov> hmm.. debian has hsql packages that mention sqlite
06:18:00 <tuomov> how does it relate to haskelldb?
06:18:02 <musasabi> it has a more SQL-like interface.
06:19:13 <Lemmih> Haskelldb is a DSL for generating SQL. It doesn't care what DB you use.
06:19:25 <tuomov> I just want something easy..
06:19:43 <tuomov> I don't know any sql...
06:20:03 <tuomov> I'm just thinking of making riot use a proper database
06:20:16 <tuomov> and I'd also like a MUA that uses a proper database, and riot is half of a mua
06:20:22 <tuomov> not that I have the time to write any of that..
06:20:49 <shapr> tuomov: Considered extending postmaster?
06:20:50 <tuomov> but I want not database servers and such complicatd things
06:20:55 <tuomov> s/not/no/
06:21:08 <shapr> doh, I read MTA
06:21:25 <tuomov> well, it would be nice if the mta would just dumb everything in the database as well..
06:21:57 <shapr> Yeah, true.
06:23:35 <xerox_> shapr: we should start haskell-sanduhr as soon as possible!
06:23:44 <shapr> yeah!
06:23:57 <shapr> It should be simple enough to implement with cairo.
06:24:07 <shapr> Oh, I bought a real physical timer to use as well.
06:24:20 <xerox_> That's a workaround! :-)
06:24:25 <shapr> I like mechanical timers.... tick, tick, tick, bzzz!
06:24:52 <xerox_> Hmmm...
06:25:07 * jethr0 wonders what his firefox is doing with its 99mb of resident mem usage
06:25:20 <xerox_> I wonder if there is a date(1)-like parser in Haskell.
06:25:31 <tuomov> there's strftime binding somewhere
06:25:32 <xerox_> jethr0: ah-ha, let me find that thing...
06:25:40 <Lemmih> jewel: It's not a bug. It's a feature!
06:25:51 <tuomov> hmm.. not strftime but the opposite..
06:26:01 <xerox_> jethr0: http://developers.slashdot.org/developers/06/02/14/2154224.shtml
06:26:08 <jethr0> cool
06:26:15 <tuomov> strptime
06:26:18 <xerox_> jethr0: wait, and read :-)
06:26:25 <yaarg> i've used hsql for connecting to sqllite before
06:26:25 <Lemmih> Tsk tsk. Stupid tab completion.
06:26:25 <xerox_> tuomov: oh-uhm.
06:27:42 <tuomov> or is there..
06:28:16 <jethr0> has anyone used "/usr/bin/time"? for me it has never properly reported on mem usage...
06:28:17 <JKnecht> edwinb: thx loads, downloaded Abel, Benke, Hughs and Norrel from ACM portal. Exactly what I meant/was looking for.
06:28:41 <edwinb> JKnecht: the gadget is at http://www.coverproject.org/CoverTranslator/, although I have never tried it.
06:28:42 <Igloo> Linux doesn't support the mem usage stuff AIUI
06:29:06 <jethr0> *great*. igloo, any alternatives to find out how much max/mean/min memory usage a process got?
06:30:13 <Igloo> I wrote http://urchin.earth.li/darcs/ian/memory/ which may not be perfect but was good enough for my uses
06:30:38 <Igloo> You'd have to do the max/mean calc yourself on the data file it produces, but that's simple enough
06:30:52 <Igloo> min = 0 when t = 0, trivially  :-)
06:31:20 <jethr0> thx
06:31:23 <Igloo> Was it you who filed the memory usage bug on ghc in the last day or so?
06:31:32 <jethr0> nope
06:32:55 <shapr> Lunar^: Hey, where's your corewars and visualizer?
06:33:50 <JKnecht> edwinb: hmmm doesn't look like a vital project (CoverTranslator) uses ghc 6.2.
06:34:33 <JKnecht> also let
06:34:45 <JKnecht> s's not leave out Bove on agda ref :)
06:36:42 <musasabi> Why are instance declarations with forall not permitted?
06:38:32 <Lunar^> shapr: mhh lemme check
06:38:47 <kosmikus> musasabi: I can't really say why. But there are papers about this: "Derivable Type Classes" by Hinze and SPJ, and "Simulating quantified class constraints in Haskell" by Trifonov.
06:39:43 <shapr> Lunar^: ok, I can't find my local copy.
06:39:49 <musasabi> I got around it, by not using type synonyms, but it does not seem like something really needed.
06:40:07 <musasabi> (because free variables have an implicit forall in the instance declaration)
06:42:23 <musasabi> This demonstrates it and shows how it seems like an artificial limitation at least in that case: http://youzen.b2.fi/~musasabi/a.hs
06:42:49 <musasabi> with -fglasgow-exts etc
07:05:48 <shapr> Is there some simple way to control the mouse from the keyboard in X?
07:06:42 <Lemmih> Take the keyboard and poke the mouse?
07:06:51 <Philippa_> there's probably some driver you can use
07:07:09 <shapr> Lemmih: ooh 
07:07:59 <araujo> haha
07:16:50 <musasabi> shapr: http://www.tuxfiles.org/linuxhelp/movecursor.html
07:40:47 <xerox_> tuomov: do you know how to transform a struct tm to something usable? :-)
07:41:10 <shapr> musasabi: oh spiffy!
07:41:27 <xerox_> ...like an Int.
07:43:17 <shapr> musasabi: That's way cool, now if only I could use shift, control, hyper, etc to speed up or slow down the movement.
07:44:13 <tuomov> xerox_: gmtime/localtime. those at least should have haskell bindings
07:45:01 <musasabi> shapr: when holding the movement button (e.g. '4') the mouse accelerates.
07:45:01 <tuomov> but obviously are somewhere deep in the hierarchies with an unrelated name
07:45:30 <musasabi> shapr: I think one can further configure that, but don't remember the details.
07:46:16 <tuomov> a quadrant-based mouse emulation thing might be useful sometimes
07:48:22 <tuomov> I once saw such a thing for emacs, but I can't recall what it was called
08:15:26 <xerox_> > strptime' "17h13m36s" "%Hh%Mm%ss" >>= print
08:15:26 <xerox_> 36
08:15:27 <lambdabot>  Not in scope: `strptime''
08:15:28 <xerox_> Hmmm.
08:15:47 <Beelsebo1> @index strptime
08:15:47 <lambdabot> bzzt
08:15:52 <Beelsebo1> @hoogle strptime
08:15:52 <lambdabot> No matches found
08:21:19 <shapr> @hoogle peyton
08:21:20 <lambdabot> No matches found
08:24:34 <lispy> heh
08:24:42 <lispy> @index peyton
08:24:42 <lambdabot> bzzt
08:25:02 <Trevion> @index simon
08:25:02 <lambdabot> bzzt
08:25:07 <Trevion> Now that's just _wrong_
08:25:07 <xerox_> tromp_: I think strptime is not exactly what I need...
08:25:31 * Beelsebo1 wonders what the Simon function would do
08:25:34 <Beelsebo1> everything?
08:25:43 <lispy> oh, i read taht as strprime and i wondered what it did
08:25:59 <Trevion> Return a paper about "<adjective> types"?
08:26:16 <xerox_> tromp_: sanduhr works more like "+2h" with the meaning of "in two hours", and such
08:26:22 <Beelsebob> lol
08:29:19 <davidhouse> @index (+)
08:29:19 <lambdabot> Prelude
08:29:29 <davidhouse> oh, that's what @index does.
08:29:48 <davidhouse> @index listToMaybe
08:29:49 <lambdabot> Data.Maybe
08:30:45 <shapr> Trevion: hah
08:30:59 <musasabi> Is this definition for Monoid Monads good:
08:31:00 <musasabi> instance (Monad m,Monoid a) => Monoid (m a) where
08:31:00 <musasabi>   mempty  = return mempty
08:31:00 <musasabi>   mappend a b = do x <- a; y <- b; return $ mappend x y 
08:31:34 <nooga> i'm looking for a solution for the post stamp problem (http://mathworld.wolfram.com/PostageStampProblem.html) for n=3 and h=infinity
08:31:56 <xerox_> tromp_: indeed, sanduhr uses a bison parser, gawk.
08:32:00 <nooga> i can't figure it out by myself
08:32:41 <nooga> any ideas? =.=
08:33:12 * xerox_ goes for a parsec parser
08:33:22 <davidhouse> nooga, what does n represent?
08:34:29 <nooga> n - number of stamp nominals
08:35:27 <davidhouse> ah, okay.
08:36:06 <nooga> i've got 3 nominals
08:36:13 <davidhouse> so you have a_1, a_2 and a_3, and want to know what numbers can be represented in terms of linear combinations of those?
08:36:28 <davidhouse> or are you aiming for a specific number
08:36:53 <nooga> i need to know the highest number which cannot be represented
08:37:02 <nooga> for 5 and 8 it is 27
08:37:17 <davidhouse> do you know your a_1, a_2 and a_3?
08:37:29 <nooga> yes
08:37:55 <davidhouse> and you're doing this algorithmically?
08:37:57 <xerox_> Do you know how to parse thing with backtracking in Parsec?
08:38:14 <xerox_> ... <|> discard the unmatched things right?
08:38:34 <xerox_> I'm asking because the .nl Parsec site appears to be down :-\
08:38:42 <nooga> davidhouse: i can do it even bruteforce
08:38:54 <nooga> speed isn't necessary 
08:39:26 <davidhouse> i can't see an easy way to reliably do this
08:40:15 <edwinb> "try" is the function that does backtracking
08:40:24 <jethr0> nooga, you mean the first number after the highest that can be represented?
08:40:30 <mauke> xerox_: IIRC p <|> q attempts to match p, and only if p fails without consuming any input it tries q
08:40:38 <nooga> no
08:40:39 <edwinb> try foo <|> bar
08:40:53 <edwinb> if foo might consume then fail
08:40:59 <nooga> for nominals: 5 and 8 the number is 27
08:41:00 <eivuokko> Try is backtrakin, <|> is only continue after first fails
08:41:00 <nooga>  5+5+5+5+8 > 27, 5+5+5+8 < 27 
08:41:06 <nooga> see?
08:41:16 <eivuokko> *continue with second one
08:41:23 <jethr0> ah
08:41:54 <eivuokko> Oops, I think I lag...like edwinb said.
08:42:34 <xerox_> mauke: what if p fails WITH consuming input?
08:43:06 <Cale> xerox_: the parse fails
08:43:17 <xerox_> That's what I want to avoid :-\
08:43:17 <mauke> xerox_: then it fails
08:43:23 <mauke> then use try p
08:44:02 <lispy> parsec documentation says to avoid 'try' but i found it unavoidable
08:44:10 <nooga> :/
08:44:16 <Cale> If p is a parser, then try p is a parser which is the same as p, but if it fails, it doesn't consume any input
08:44:35 <Cale> Avoiding try is only necessary if you really care about performance a whole lot
08:44:38 <mauke> http://www.cs.uu.nl/~daan/download/parsec/parsec.html isn't down for me
08:45:22 <jethr0> nooga, your problem might be better solved algebraically
08:45:33 <lispy> Cale: and yet i've never seen numbers that illustrate the slowness.  So it's hard to believe that.
08:45:48 <lispy> i just assume there is no penalty for now :)
08:45:57 <jethr0> nooga: because there is really no bound how many linear combinations to test
08:46:04 <Cale> lispy: well, it introduces backtracking
08:46:16 <jethr0> if i'm not wrong, this is a very potentially infinite search
08:46:17 <Cale> lispy: without try, parsec parsers are LL(1)
08:46:58 <xerox_> Hmm.
08:47:05 <xerox_> How does one bind the result of a try?
08:47:08 <xerox_> 'when' ?
08:47:25 <Cale> just like you bind the result of the parser that it modifies
08:47:42 <nooga> jethr0: i think yes
08:47:48 <jethr0> yes what?
08:47:54 <nooga> [17:45] <jethr0> nooga, your problem might be better solved algebraically
08:48:01 <jethr0> ah
08:48:28 <nooga> solution for 2 nominals is: g = a*b-a-b
08:48:29 <jethr0> there are some pretty neat approaches out there. like for example finding a orto-normal basis
08:48:42 <xerox_> Cale: but then it becomes irrefutable, it seems
08:48:51 <xerox_> Ah, idea.
08:48:55 <nooga> but i have no idea what can it be for 3 nominals
08:50:09 <xerox_> I declare default values as 'try parser <|> return default'.
08:50:15 <nooga> http://mathworld.wolfram.com/PostageStampProblem.html << how can this be coded in haskell?
08:50:46 <jethr0> nooga: unless i'm wrong, you can't solve this via brute force
08:50:54 <Cale> xerox: that's called option
08:51:08 <Igloo> jethr0: Why not?
08:51:27 <jethr0> because the sequence of linear combinations can be arbitrarily long?
08:51:27 <xerox_> Cale: do you mean there exist an 'option' function, or it's the english term to call the 'default value' ?
08:51:31 <Igloo> You have a finite number of spaces, each of which can hold any of a finite number of things (or nothing)
08:52:00 <Igloo> "room for no more than h stamps"
08:52:06 <jethr0> ah
08:52:20 <Cale> @type Text.ParserCombinators.Parsec.Combinator.option
08:52:21 <lambdabot> forall a st tok.
08:52:21 <lambdabot>                  a
08:52:21 <lambdabot>                  -> Text.ParserCombinators.Parsec.Prim.GenParser tok
08:52:21 <lambdabot>                                  st
08:52:21 <lambdabot>                                  a
08:52:23 <lambdabot> [3 @more lines]
08:52:30 <Cale> @more
08:52:31 <lambdabot>                  -> Text.ParserCombinators.Parsec.Prim.GenParser tok
08:52:31 <lambdabot>                                  st
08:52:31 <lambdabot>                                  a
08:52:50 <Cale> heh, I wish it wouldn't use qualified names there
08:53:08 <lispy> i wish it wouldn't break lines
08:53:11 <xerox_> :-)
08:53:25 <lispy>                              a
08:53:30 <lispy>                             ->
08:53:34 <lispy> that's just annoying :)
08:53:59 <jethr0> sequence (replicate h [a1,a2,a3,a4])
08:54:05 <xerox_> It would be cool to have a 'choice' which collects the scans
08:54:31 <lispy> xerox_: hmm...seems like that exists
08:54:47 <lispy> but i don't remember the details on what i'm thinking about
08:55:01 <jethr0> map sum $ sequence (replicate h [a1,a2,a3,a4])
08:55:44 <jethr0> ah, "< h"
08:56:20 <lispy> @pl \a1 a2 a3 a3 h -> map sum $ sequence (replicate h [a1,a2,a3,a3])
08:56:21 <lambdabot> ((const . const . ((map sum . sequence) .) . ap replicate) .) . (. ((. ap
08:56:21 <lambdabot> (:) return) . (:))) . (.) . (:)
08:56:27 <jethr0> map sum $ concatMap (sequence $ replicate n [a1,a2,a3]) [1..h]
08:56:48 <jethr0> > map sum $ concatMap (sequence $ replicate n [1,2,3]) [1..3]
08:56:49 <lambdabot>  Not in scope: `n'
08:56:56 <jethr0> > map sum $ concatMap (\n -> sequence $ replicate n [1,2,3]) [1..3]
08:56:57 <lambdabot> [1,2,3,2,3,4,3,4,5,4,5,6,3,4,5,4,5,6,5,6,7,4,5,6,5,6,7,6,7,8,5,6,7,6,7,8,
08:56:57 <lambdabot> 7,8,9]
08:57:26 <jethr0> nooga: those should be the linear combinations (i think, but usually i'm wrong ;)
08:57:31 <lispy> so then foldl max on that right?
08:57:39 <nooga> yes
08:57:45 <nooga> but how to code it --.'
08:57:52 <jethr0> ?
08:58:01 <lispy> that is the code
08:58:17 <nooga> where?
08:58:22 <xerox_> heh
08:58:24 <jethr0> ^_^
08:58:35 <lispy> > foldl1 max (map sum $ concatMap (\n -> sequence $ replicate n [1,2,3]) [1..3]
08:58:35 <lambdabot>  parse error on input `}'
08:58:45 <xerox_> mismatched parens
08:58:53 <lispy> oh right
08:58:56 <lispy> > foldl1 max (map sum $ concatMap (\n -> sequence $ replicate n [1,2,3]) [1..3])
08:58:57 <lambdabot> 9
08:59:11 <jethr0> so for elements [1,2,3] and h=3 the maximum is 9
08:59:31 <nooga> how about h = infinity? p
08:59:33 <xerox_> > foldl1 max ([1..3] >>= sum . sequence . flip replicate [1,2,3])
08:59:34 <lambdabot>  add an instance declaration for (Num [a])
08:59:39 <xerox_> Ouch.
08:59:46 <xerox_> > foldl1 max ([1..3] >>= return . sum . sequence . flip replicate [1,2,3])
08:59:46 <lambdabot>  add an instance declaration for (Num [a])
08:59:52 <xerox_> Okay, nm.
08:59:59 <Cale> hm?
09:00:05 <lispy> > foldl1 max (map sum $ concatMap (\n -> sequence $ replicate n [1,2,3]) [1..])
09:00:09 <lambdabot> Terminated
09:00:14 <jethr0> :)
09:00:22 <Cale> foldl1 max = maximum
09:01:00 <jethr0> nooga, building the maximum over infinitely many elements can take a while (or do i have it wrong again?)
09:01:09 <xerox_> @type \n -> sequence $ replicate n [1,2,3]
09:01:10 <lambdabot> forall a.
09:01:10 <lambdabot>               (Num a) =>
09:01:10 <lambdabot>               Int -> [[a]]
09:01:12 <Cale> sure can :)
09:01:39 <xerox_> Hm.
09:01:50 <Cale> > maximum (map sum $ concatMap (\n -> sequence $ replicate n [1,2,3]) [1..10])
09:01:51 <lispy> but with a sorted set and binary search you can take time log(inf) ;)
09:01:51 <lambdabot> 30
09:01:54 <jethr0> xerox_: sequence on list monad will produce all combinations
09:02:14 <jethr0> > sequence [[1,2],[5,6]]
09:02:14 <lambdabot> [[1,5],[1,6],[2,5],[2,6]]
09:02:15 <xerox_> I wonder about the 'map sum'.
09:02:24 <jethr0> > map sum $ sequence [[1,2],[5,6]]
09:02:24 <lambdabot> [6,7,7,8]
09:02:39 <xerox_> > foldl1 max ([1..3] >>= map sum . sequence . flip replicate [1,2,3])
09:02:40 <lambdabot> 9
09:02:45 <xerox_> ah.
09:02:58 <jethr0> *yuch*
09:03:02 <lispy> xerox_: Cale pointed out foldl1 max = maximum
09:03:33 <xerox_> > map pred "J!lopx"
09:03:34 <lambdabot> "I know"
09:03:37 <jethr0> nooga: did that help?
09:03:41 <lispy> > maximum ([1..3] >>= map sum . sequence . flip replicate [1..3])
09:03:42 <lambdabot> 9
09:04:16 <nooga> check it for 5 and 8
09:04:20 <nooga> should give 27
09:04:34 <lispy> > maximum ([5,8] >>= map sum . sequence . flip replicate [1..100])
09:04:38 <lambdabot> Terminated
09:04:42 <lispy> > maximum ([5,8] >>= map sum . sequence . flip replicate [1..10])
09:04:45 <lambdabot> Terminated
09:04:51 <lispy> > maximum ([5,8] >>= map sum . sequence . flip replicate [1..5])
09:04:52 <lambdabot> Exception: stack overflow
09:04:56 <nooga> aha
09:05:01 <lispy> > maximum ([5,8] >>= map sum . sequence . flip replicate [1..3])
09:05:02 <lambdabot> 24
09:05:04 <jethr0> > foldl1 max (map sum $ concatMap (\n -> sequence $ replicate n [5,8]) [1..27])
09:05:06 <nooga> http://www.math.tamu.edu/~lenny/wcnt05.pdf
09:05:08 <lambdabot> Terminated
09:05:11 <lispy> > maximum ([5,8] >>= map sum . sequence . flip replicate [1..4])
09:05:12 <lambdabot> 32
09:05:16 <jethr0> hmm
09:05:20 <lispy> heh, oops
09:05:26 <xerox_> Maybe with some... strictness.
09:05:39 <jethr0> maybe the approach to generate all combinations was rather lambda-bot-unfriendly
09:06:14 <jethr0> > foldl1 max (map sum $ nub $ concatMap (\n -> sequence $ replicate n [5,8]) [1..27])
09:06:18 <lambdabot> Terminated
09:06:53 <lispy> nub should makes things worse
09:06:59 <xerox_> > foldl1 max ([5,8] >>= join (seq) . map sum . sequence . flip replicate [1..27])
09:07:02 <lambdabot> Terminated
09:07:29 <jethr0> on my own ghci it's at least running :)
09:09:57 <jethr0> nooga: with what 'h'?
09:10:16 <nooga> infinity
09:11:50 <jethr0> i should read the problem descriptions better #@#$%#
09:13:34 <jethr0> i don't understand the problem description in combination with (5,8,27,infinity), sorry
09:14:10 <Cale> On the Mathworld page, is x_i in Z?
09:14:29 <Cale> (It would seem to make sense, given the analogy
09:14:30 <Cale> )
09:14:34 <jethr0> good question. but my guess is that postage stamps are discreet
09:14:46 <Cale> discrete, yeah
09:15:01 <nooga> i need solution for 3 numbers
09:15:09 <nooga> every solution i find is for 2 or 4
09:15:20 <Cale> actually, that's a silly question, since the problem is trivial if the x_i range over R
09:15:37 <jethr0> exactly
09:15:43 * nooga still dosen't know how to solve the problem :/
09:15:48 * nooga is drunken -.-
09:16:18 <Cale> well, can't you use the gcd here?
09:16:21 <jethr0> h can be bounded by "target / max_element"
09:16:30 <nooga> gcd?
09:16:35 <nooga> in which way?
09:16:36 * xerox_ yummies some cookies
09:16:41 <Cale> er, oh, only positive linear combs are allowed
09:16:47 <Cale> so that doesn't quite work
09:17:06 <jethr0> > foldl1 max (map sum $ nub $ concatMap (\n -> sequence $ replicate n [5,8]) [1..(27`div`8)])
09:17:07 <lambdabot> 24
09:17:24 <jethr0> hmm, stupid me
09:17:31 <nooga> should be 27
09:17:41 <jethr0> i know. i'm just procrastinating
09:17:56 <nooga> > foldl1 max (map sum $ nub $ concatMap (\n -> sequence $ replicate n [5,8]) [1..(5*8-5-8)])
09:17:57 <Cale> If you're allowed arbitrarily many stamps, isn't it just one less than the amount of your smallest stamp?
09:18:00 <lambdabot> Terminated
09:18:29 <nooga> hm
09:19:03 <Cale> er no
09:19:05 <jethr0> check n = let o = [x-a | a <-[5,8]] in if o < 0 then False else check o
09:19:06 <Cale> it's either 1
09:19:20 <Cale> or you can construct every nonnegative integer
09:19:44 <nooga> but
09:19:53 <Cale> Since if you have a stamp with value 1, then you can construct every nonnegative integer value
09:19:57 <nooga> the example says the number is 27 for 5 and 8
09:20:02 <Cale> and if you don't, then you can't construct 1
09:20:17 <jethr0> check n = let o = filter (>0) [x-a | a <-[5,8]] in or . map check $ o
09:20:19 <Cale> With h = infinity or h bounded?
09:20:48 <Cale> oh, the stamps have to be distinct
09:20:50 <Cale> sorry
09:20:52 <boegel> > reverse ")-:"
09:20:53 <lambdabot> ":-)"
09:21:06 <boegel> hehe :) something I just saw on the Haskell mailing list
09:21:10 <nooga> :/
09:21:10 <davidhouse> boegel: :P
09:21:11 <Cale> I misread that then
09:21:15 <jethr0> check n = let o = filter (>=0) [x-a | a <-[5,8]] in if n==0 then True else or . map check $ o
09:21:22 <davidhouse> > "/quit" -- this almost works
09:21:23 <lambdabot> "/quit"
09:21:30 <Cale> oh, no
09:21:32 <Cale> never mind
09:21:39 <nooga> :{
09:21:40 <Cale> the denominations have to be distinct
09:21:45 <Cale> and a_1 = 1
09:21:51 <Cale> so there's always a stamp with value 1
09:22:16 <Cale> so you can just take x_1 = k
09:22:20 <Cale> to get any k
09:22:35 <Cale> It's the h that makes the problem interesting
09:22:37 <nooga> thanks anyway
09:22:37 <nooga> g2g
09:23:37 <jethr0> nooga: how are 0 and 1 linear combiations of 5 and 8?
09:24:02 <Cale> jethr0: you always have a stamp with value 1, according to mathworld
09:24:09 <Cale> and 0 is always a linear combination
09:24:37 <jethr0> let check n = let o = filter (>=0) [n-a | a <-[5,8]] in if n==0 then True else or . map check $ o in head . filter (not . snd) $ zip [1..] (map check [1..])
09:24:40 <jethr0> > let check n = let o = filter (>=0) [n-a | a <-[5,8]] in if n==0 then True else or . map check $ o in head . filter (not . snd) $ zip [1..] (map check [1..])
09:24:41 <lambdabot> (1,False)
09:24:49 <jethr0> > let check n = let o = filter (>=0) [n-a | a <-[1,5,8]] in if n==0 then True else or . map check $ o in head . filter (not . snd) $ zip [1..] (map check [1..])
09:24:53 <lambdabot> Terminated
09:25:08 <jethr0> hmm, pretty much everything linear-combines with 1 :)
09:25:26 <Cale> The solution is always greater than h
09:26:05 <Cale> greater or equal to
09:26:06 <jethr0> *pah*, stupid problem :)
09:26:07 <Cale> because you can just take  x_i = k for all k < h.
09:26:16 <Cale> so h = infinity ruins the problem
09:26:31 <Cale> er
09:26:32 <Cale> x_1 = k
09:26:35 <Cale> a_1 = 1
09:26:48 <jethr0> yup
09:27:07 <jethr0> in the end it's similar to gcd
09:27:37 <Cale> yeah, gcd tells you the smallest Z-linear combination possible with a set of integers
09:28:05 <Cale> This is talking about the smallest N-linear combination possible, with bounded sum-of-coefficients.
09:28:28 <Cale> er
09:28:30 <Cale> not possible
09:28:32 <Cale> sorry :)
09:28:39 <beelsebo1_> @where gtk2hs
09:28:40 <lambdabot> http://haskell.org/gtk2hs/
09:29:35 <xerox_> Cale: it seems that option and try p <|> return q behave differently when sequenced.
09:35:16 <chrisbrown> hi all
09:37:03 <davidhouse> hmm
09:37:11 <davidhouse> i'm not sure how much i like gtk2hs.
09:37:28 <davidhouse> all the programs i've seen with it have been one big do {} statement
09:37:34 <davidhouse> it seems to make things quite imperative.
09:37:49 <araujo> uh?
09:38:46 <araujo> I don't think that a big do { } is enough to say that :-]
09:38:54 <davidhouse> well, true.
09:39:08 <davidhouse> but i'd still prefer it if i could avoid the big do {}
09:40:03 <Cale> Well, how would you design it?
09:40:16 <Cale> It's a pretty tricky problem
09:40:28 <jips> hello Cale
09:40:31 <Cale> hello
09:40:48 <jips> i think it's good that gtk2hs is a fairly straight mapping to the gtk c api
09:41:28 <davidhouse> Cale, that's true. it would be hard to build a very functional GUI lib.
09:41:39 <jips> davidhouse: fruit is cool
09:41:52 <davidhouse> it just seems gtk2hs is stuck painfully between OO imperative code and nice functional code.
09:41:57 <davidhouse> it's neither one nor the other.
09:42:00 <davidhouse> jips, huh?
09:42:11 <Cale> I haven't found it too painful to actually use
09:42:16 <jips> i've been thinking a bit about how one could program gtk2hs guis using fruit concepts
09:42:56 <davidhouse> oh, is fruit software?
09:43:08 <dcoutts> davidhouse, it's be great for someone to build a higher level functional API on top of gtk2hs
09:43:12 <jips> instead of directly mapping events/actions that deal with the application logic to the individual gtk widgets...
09:43:36 <jips> you map those events/actions to a proxy object that integrates with the yampa system
09:43:50 <dcoutts> davidhouse, Axel and I have got enough work on our hands with the improving low level stuff
09:43:58 <chrisbrown> dcoutts: could i ask you about hIDE?
09:44:00 <dcoutts> davidhouse, sure
09:44:02 <jips> dcoutts: that's sort of what i'm talking about, but i'm not really thinking about another api layer, more like a style of programming
09:44:51 <chrisbrown> dcoutts: I tried to install it the other night but had no luck! 
09:45:22 <prionic> looks like cabal-install has problems with windows paths
09:45:28 <dcoutts> chrisbrown, it's a pita to build/install at the moment
09:45:50 <chrisbrown> dcoutts: do you think it would be better for me to wait until a prototype is released?
09:46:01 <dcoutts> chrisbrown, probably
09:46:06 <chrisbrown> ok
09:46:18 <davidhouse> dcoutts, yeah. i'm not sure a haskell library on top of another haskelll library on top of a C library would be the best, performance wise.
09:46:21 <dcoutts> it depends on very particular development versions of several packages
09:46:40 <dcoutts> davidhouse, I don't see why
09:46:55 <dcoutts> davidhouse, if it were in gtk2hs it'd still have the same layers
09:47:23 <dcoutts> the problem is we don't have enought time and there is no concensus on what the api should look like
09:47:36 <dcoutts> so yes, at the moment gtk2hs is all in IO ()
09:47:50 <davidhouse> i guess so.
09:48:02 <dcoutts> we're leaving the high level functional bit to others
09:48:34 <dcoutts> there have been several Haskell GUIs but they all disspeared because they were not supported and/or were not broad enough
09:48:51 <beelsebo1_> bah... what the fuck is pkg-config and how does it work?
09:49:13 <dcoutts> beelsebo1_, it's a C system to make building C libs easier
09:49:30 <dcoutts> it tells you what C flags are necessary to build against a C lib
09:49:42 <beelsebo1_> hmmm, so how does it relate to managing to get gtk2hs working?
09:50:03 <beelsebo1_> and why is it not telling the configure script that glib2 is there
09:50:21 <dcoutts> beelsebo1_, we ask pkg-config to tell us what C flags are needed to link to gtk
09:50:24 <dcoutts> eg: pkg-config --cflags gtk+-2.0
09:50:38 <dcoutts> or: pkg-config --libs glib-2.0
09:50:45 <dcoutts> that should tell us stuff
09:51:02 <dcoutts> if it doesn't then you probably don't have glib-devel installed
09:51:10 <beelsebo1_> ah, okay
09:51:27 <dcoutts> (if you're on a platform where "dev" packages are seperate from "runtime" packages)
09:51:34 * beelsebo1_ calls in the wonder of fink
09:51:47 <dcoutts> beelsebo1_, doesn't the error message say something along those lines?
09:52:16 <beelsebo1_> it was complaining that glib2 didn't exist, but it probably means glib2-dev doesn't
09:52:55 <dcoutts> oh, actually it only gives a sensible error message for the optional packages :-(
09:52:56 <beelsebo1_> cool, that's squashed that error...
09:53:02 <dcoutts> I should go fix that
09:53:30 <dcoutts> beelsebo1_, use --enable-glade and you'll see what it should say
09:53:41 <beelsebo1_> ah, cool :)
09:53:44 * dcoutts suspects that beelsebo1_ will not have glade-devel installed
09:53:51 <dcoutts> but he really ought to!
09:54:01 <dbrock> here's a stupid question by a confused newbie:  I'm implementing a binary search tree, called BST, and a bunch of balanced binary search trees based on the BST implementation.  Since all the trees have the same datastructure, I could have just one type and a flat set of functions (insertBST, insertAVL, insertRB, etc.), where the BST ones accept all BSTs, the AVS ones accept only AVLs, etc.  But then I'd have to put asserti
09:54:01 <dbrock> ll over the place.
09:54:14 <dbrock> did that get cut off?
09:54:19 <basti_> "asserti..."
09:54:30 <basti_> i think the idea came through
09:54:31 <dbrock> assertions all over the place.
09:55:11 <basti_> did you think about using a class and instances?
09:56:12 * beelsebo1_ wonders where to get gdk
09:56:25 <dcoutts> beelsebo1_, it's part of gtk
09:56:36 <musasabi> phantom types could work.
09:56:54 * beelsebo1_ wonders why it's not installed then...
09:57:21 <davidhouse> dcoutts, do you need to pass --enable-glade to configure to get glade support in gtk2hs? or will configure pick up that you've got it installed and enable it itself
09:57:39 <dcoutts> davidhouse, it'll pick it up automatically,
09:57:41 <musasabi> data BST phantom element = Nil | Branch element (BST phantom element) (BST phantom element)
09:57:47 <beelsebo1_> apparently... No package 'gdk-2.0' found, any idea where to go with that?
09:57:51 <musasabi> data AVL = AVL
09:57:59 <dcoutts> beelsebo1_, install gtk-devel
09:58:00 <musasabi> type AVLTree = BST AVL
09:58:36 <basti_> yes, or something like that
09:58:42 <beelsebo1_> gyah... stupid fink... so many versions of the same thing to install
09:59:49 <dbrock> musasabi: oh... interesting
10:00:31 <basti_> my train of thoughts would be "class SearchTree" which gives the types of functions that are common (insert, remove etc.), and then "instance SearchTree AVL" etc. with specialized functions
10:01:21 <basti_> this way you would be able to use benchmark functions (or something) independant of the implementation you're using
10:01:28 <basti_> and you'd separate tree types, too.
10:01:38 <basti_> (that kinda rhymes in a funny way)
10:02:16 <dbrock> yeah, and then have data BST a => AVL a = AVL a?
10:02:40 <basti_> no, rather have instance BST AVL
10:02:52 <dbrock> but what is AVL?
10:02:56 <basti_> (i substituted SearchTree because of not thinking enough)
10:02:59 <basti_> a "data" type
10:03:19 <dbrock> can you define it, please? :-)
10:03:57 <basti_> uhm, like   data AVL a = AVLNode Int a (AVL a) (AVL a) | Tip
10:04:25 <dbrock> oh, so a parallel data structure for each type of tree?
10:04:45 <basti_> yes.
10:04:53 <dbrock> but then I have to put ALL the tree operations in the type class
10:05:26 <beelsebo1_> yay, workyness!
10:05:44 * beelsebo1_ sits and waits 10 days for build
10:05:51 <basti_> hmm you could generalize on the concept of search tree first, and then the insertion etc. mechanisms in a second class.
10:06:08 <basti_> hmmm :/
10:06:48 <dcoutts> beelsebo1_, thanks for pointing out the rubbish error message. I've improved it in the current darcs version.
10:06:48 <basti_> i mean like, giving primitives like "goLeft" "goRight" etc., you could implement "search" independent of the tree type
10:06:53 <basti_> thats what you want isn't it?
10:07:40 <dbrock> yeah... good point
10:08:01 <basti_> it's a little ugly
10:09:34 <Beelsebob|Lappy> dcoutts: :)
10:09:46 <dbrock> basically I could have a function in the type class called `bst' which simply converts the tree into a BST
10:09:57 <Beelsebob|Lappy> thanks for working through my stupidity dcoutts 
10:10:02 <basti_> hmmmmm.
10:10:07 <Beelsebob|Lappy> this was much easier to make work under gentoo
10:10:08 <dcoutts> Beelsebob|Lappy, np
10:10:12 <basti_> yes, and because it's lazy it wouldnt waste time, too
10:10:23 <basti_> the overhead would be a constant factor
10:11:03 <dbrock> but then it makes sense to have data BST a => AVL a = AVL a, right?
10:11:10 <xerox_> $ wc -l sanduhr-1.0/src/argparse.y Sanduhr.hs
10:11:11 <xerox_>  125 sanduhr-1.0/src/argparse.y
10:11:11 <xerox_>   17 Sanduhr.hs
10:11:11 <xerox_> heh.
10:11:30 <basti_> dbrock: i don't understand what that ought to mean
10:11:55 <xerox_> What is a 'BST' ?
10:12:04 <Cale> Binary search tree, probably
10:13:37 <Cale> It's a tree with labelled internal nodes such that the largest label on the left subtree is less than the element of the root, and the smallest label on the right subtree is greater than the label on the root
10:14:03 <Cale> and such that that property holds for all subtrees
10:14:08 <dbrock> I mean data AVL a = AVL (BST a)
10:14:36 <basti_> dbrock: that doesnt make much sense too
10:14:50 <Cale> don't AVL trees require extra labels to help balance them?
10:15:19 <basti_> yes
10:15:26 <basti_> usually called "weights"
10:15:26 <dcoutts> Beelsebob|Lappy, on gentoo you just emerge gtk2hs :-)
10:15:33 <Beelsebob|Lappy> indeed
10:15:42 <Beelsebob|Lappy> ... somewhat more complex on OS X
10:16:00 <basti_> dbrock: the class and derivation system in haskell is different to the one in java etc.
10:16:28 <dcoutts> Beelsebob|Lappy, does fink have any other Haskell stuff in it?
10:16:35 <Cale> yeah, classes in Haskell don't mean the same thing as classes in OO languages
10:16:36 <basti_> (i always assume it's the co-system, but i don't have a clue if it really is)
10:16:50 <Beelsebob|Lappy> dcoutts: ports has ghc in it, but it's easier to get the package offline
10:16:54 <dbrock> basti_: yes, I am probably still thinking in terms of Java interfaces
10:17:06 <basti_> it's the other way round in haskell
10:17:16 <dcoutts> Beelsebob|Lappy, so you don't think there's much point in trying to get gtk2hs into fink?
10:17:16 <basti_> in java, everything derives from "Object"
10:17:45 <basti_> in haskell, if you want, you can make everything derive a general class, but that doesnt make sense.
10:17:47 <Beelsebob|Lappy> dcoutts: it would take a *lot* of work... like working out how to get ghc to bootstrap on OS X
10:17:51 <basti_> (and you'd start at the bottom)
10:18:08 <dcoutts> Beelsebob|Lappy, ah ok
10:18:12 <davidhouse> anyone know where the glade documentation is?
10:18:20 <davidhouse> they don't seem to have any on their website
10:18:29 <dcoutts> davidhouse, the C api or the Haskell API ?
10:18:57 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Glade.html
10:19:06 <dbrock> why doesn't it make sense to make everything derive a general class?
10:19:22 <davidhouse> dcoutts: i want to know what XML i have to write
10:19:24 <dbrock> and what does "start at the bottom" mean?
10:19:41 <dcoutts> davidhouse, you dont. You use "glade" the visual GUI builder.
10:19:53 <davidhouse> ah. that makes life easier.
10:19:58 <dcoutts> http://glade.gnome.org/
10:19:59 <Cale> dbrock: if you had a class C a with an instance C a, that is, an instance at every type, then you could simply remove the class altogether, as you'd be writing completely polymorphic functions
10:20:09 <davidhouse> dcoutts: yay :) thanks
10:20:11 <basti_> dbrock: at the leaves of the derivation tree
10:20:25 <basti_> dbrock: because in haskell, everything can be treated generally already.
10:20:45 <jips> [a] vs [Object] same thing :D
10:20:54 <dcoutts> davidhouse, glade is definatly the way to go for building attractive GUIs. Doing it all in code is a pita.
10:21:06 <Cale> jips: only problem in Java is that it's not quite the same :)
10:21:06 <davidhouse> dcoutts: as i've found.
10:21:36 <Cale> (there are types which aren't subclasses of Object)
10:21:41 <dcoutts> davidhouse, if you're interested in nice looking GUIs you should take a look at the Gnome HIG
10:21:44 <jips> Cale: well, i think java 1.5 or 2.0 has generics which sort of is similar
10:21:56 <dcoutts> davidhouse, http://developer.gnome.org/projects/gup/hig/
10:22:09 <Cale> yeah, I think they might have some parametric polymorphism now
10:23:42 <dbrock> Cale: what if there were functions in that type class (is that how you say it --- functions "in" the type class?), though?
10:24:12 <Cale> dbrock: since they're polymorphic, you can pull them out to the top level and do away with the typeclass machinery
10:24:38 <liyang> dcoutts: *ping*
10:24:47 <Cale> In Haskell98, you can't even define an instance on a type with no type constructors though
10:24:48 <dcoutts> liyang, pong
10:24:59 <Cale> (it would be sort of pointless)
10:25:00 <liyang> is there an up to date Debian package for gtk2hs et associated libraries?
10:25:16 <dcoutts> liyang, sadly not, I wish there were.
10:25:17 <liyang> Just want to make sure I'm not duplicating work.
10:25:28 <Cale> like, let's say I have a class Auto a where auto :: a -> a
10:25:39 <waltz> so make some libraries instead of bitching about it
10:25:53 <Cale> If I write: instance Auto a where auto x = x
10:26:11 <Cale> then 1) I can't write another instance of the class without overlapping this one
10:26:14 <dcoutts> liyang, mmm, someone else asked me about that the other day and was thinking about doing a package. And then there was marcot who did do gtk2hs 0.9.9 and 0.9.10 packages but then he dissapeared.
10:26:42 <dcoutts> liyang, let me check the #haskell logs...
10:26:51 <Cale> and 2) I might as well just delete the class and the instance, and write auto :: a -> a; auto x = x
10:27:13 <Cale> (classes which hold for every type are not interesting)
10:27:40 <Cale> One nice way of thinking about classes is that they are predicates with which you can restrict polymorphism.
10:27:45 <xerox_> Cale, Italy just beat Canada at some olympic event, hehe!  But I still like you.
10:27:51 <Cale> hehe
10:28:02 <dcoutts> liyang, ah yes, resiak was pondering doing debian packages. He's not a DD but you might want to talk to him and marcot if you can find him.
10:28:12 <dcoutts> resiak, ping
10:28:49 <dcoutts> resiak, you might want to talk to liyang about doing a gtk2hs debian package
10:28:58 <xerox_> Cale: would you like to bring your inkscape-fu to a new level drawing a sanduhr?  :-)
10:29:06 <Cale> sanduhr?
10:29:15 <liyang> dcoutts: ah, thanks.
10:29:24 <xerox_> http://images.google.com/images?q=sanduhr&sa=N&tab=wi <-
10:29:30 <dcoutts> liyang, resiak, if you have any issues in actually doign the packaging then I'm happy to help. I do the package for gentoo. 
10:29:44 <Cale> xerox: ah
10:29:52 <xerox_> Well, drawing it programmatically would probably help more, since I do not have libsvg-cairo... but anyway.
10:31:05 <davidhouse> xerox, that's an hourglass in english, btw
10:31:20 <xerox_> Uh.
10:31:44 <dbrock> Cale: okay, that all makes sense to me
10:31:49 <dcoutts> xerox_, yeah I'd been wondering what you've been going on about for the last few days :-)
10:32:22 <dbrock> but I don't see how it makes data AVL a = AVL (BST a) nonsensical
10:32:38 <xerox_> dcoutts: hehe!
10:33:08 <xerox_> dcoutts: the next week I'll be on vacation.  I'm looking forward to gobby out with you the so often mentioned slick new api.
10:33:19 <dcoutts> xerox, cool
10:33:53 <dbrock> unless you mean because AVL trees are not just BST trees with some structural assumptions (that's what I thought they were, but I haven't gotten to reading about them and implementing them yet, so I may be off)
10:34:09 <xerox_> @index sleep
10:34:09 <lambdabot> System.Posix.Unistd, System.Posix
10:35:50 <prionic> does anybody have an idea what i can do about this?:
10:35:52 <prionic> Could not find module `Network.Socket': it is a member of package network-1.0, which is hidden (imported from ./Network/XmlRpc/Client.hs)
10:37:54 <xerox_> prionic: unhide it with ghc-pkg
10:38:13 <xerox_> err 'expose' is the right term.
10:38:16 <prionic> what, network or socket?
10:38:35 <dbrock> okay, a more direct question:  I have a bunch of functions foo that all look like this:  foo tree = case bst tree of Null -> ... ; Fork x a b -> ...  --- is there a way to abstract that?
10:38:59 <xerox_> prionic: network, it seems.
10:39:08 <prionic> xerox: i did, but no effect
10:39:32 <prionic> ive got an idea
10:40:09 <prionic> its probable a cabal problem, i think network isnt listed in the .cabal file as dependency
10:40:39 <resiak> liyang: I haven't actually done any work on packaging gtk2hs. I'm happy to do so, but it wouldn't be for a few days, and you wouldn't be duplicating work if you were to do anything.
10:41:38 <prionic> yupp thats it, tahnks anyway
10:42:04 <liyang> resiak: I've just been trying to update Martin Sjogren's packages to 0.9.10 and GHC 6.4.x -- turns out to be a bit more work than I'd anticipated.
10:42:31 <resiak> liyang: What are you running up against?
10:44:00 <dcoutts> liyang, marcot's package tried to split things so that each of the gtk2hs packages went into a seperate debian binary package. That meant he had to move where things are installed compared to what the gtk2hs build system does by default.
10:45:08 <liyang> Originally there were separate packages for gtk2, mogul and glade. Now we've also cairo, gconf, ...
10:45:21 <dcoutts> liyang, eg he wanted the glib package to install to ${prefix}/lib/ghc6-glib-devel-0.9.10 where as normally it'd install to ${prefix}/lib/gtk2hs/glib/
10:45:22 <liyang> dcoutts: ah. That's what I'm trying to do at the minute. :)
10:45:53 <dcoutts> liyang, marcot did it by patching the package.conf files and something else in the Makefile.am I recall
10:45:55 <xerox_> $ wc -l Sanduhr.hs
10:45:56 <xerox_> 27 Sanduhr.hs
10:45:59 * xerox_ whoohoos
10:46:13 <xerox_> (It's finished, still no Gtk in, tho ;-))
10:46:26 <dcoutts> liyang, let me see if I I've still got any of the patches he sent me
10:46:31 <dcoutts> xerox, ?
10:47:01 <xerox_> dcoutts: it parses "+2h10m50s" and runs some command
10:47:08 <xerox_> (or even just "+2m" or something)
10:47:29 <xerox_> Now is the time to draw some shiny cairo graphic :-)
10:47:56 <liyang> dcoutts: any idea why the -devel-0.9.10 ?
10:48:41 <xerox_> Is it possible to specify the "-package foo" options in some {-# pragma #-} ?
10:48:54 <dcoutts> liyang, I may be mis-remembering, but I think it was a "-dev" package and included the version number somewhere
10:49:17 <liyang> ... to allow multiple versions to be installed?
10:49:57 <dcoutts> liyang, I guess so
10:50:08 <dcoutts> liyang, that should be possible
10:50:09 <resiak> liyang: You seem on top of things. Let me know if you need a hand, but I strongly suspect you know more about debs and about gtk2hs than do I
10:51:01 <prionic> did somebody  manage to install cabal-get?
10:51:21 <dcoutts> liyang, ah here's a patch he sent me where he's patching things to use "${libdir}/libghc6-glib-dev"
10:52:08 <liyang> I know very little about gtk2hs; I know enough about .debs to get by... I just wanted to install a copy to have a play around, and look where it's landed me... >.<;;
10:52:23 <dcoutts> liyang, heh :-)
10:52:48 <dcoutts> liyang, well you see we're all desperate to get a proper debian package
10:55:18 <jonkri> how do i turn my Maybe Int to a Int?
10:56:08 <xerox_> @hoogle fromJust
10:56:10 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
10:56:16 <xerox_> But beware!
10:56:25 <xerox_> > fromJust Nothing
10:56:26 <lambdabot> Add a type signature
10:56:29 <xerox_> > fromJust Nothing :: ()
10:56:30 <lambdabot> Exception: Maybe.fromJust: Nothing
10:56:56 <araujo> > case Just 1 of Nothing -> 0 ; Just n -> n
10:56:57 <lambdabot> 1
10:56:57 <jonkri> ah, thanks! :)
10:57:04 <mwc> Is there hidden nastiness in using randoms :: (RandomGen g) => g -> [a]
10:57:12 <xerox_> > maybe 1 Nothing
10:57:13 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
10:57:21 <mwc> I've got a 1 line function using 95% of the CPU time
10:57:24 <xerox_> @hoogle Maybe
10:57:27 <lambdabot> Data.Maybe.Maybe :: Maybe a
10:57:27 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
10:57:27 <lambdabot> Prelude.Maybe :: Maybe a
10:57:39 <xerox_> > maybe 1 id Nothing
10:57:40 <lambdabot> 1
10:57:49 <xerox_> This way you can specify a default value.
10:57:51 <jonkri> should i take data.maybe or prelude.maybe?
10:57:57 <xerox_> > maybe 1 id (Just 2)
10:57:58 <jonkri> oh, ok
10:57:58 <lambdabot> 2
10:58:05 <JKnecht> @version
10:58:06 <lambdabot> lambdabot 3p290, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
10:58:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
10:58:54 <jonkri> what's the freenode policy with bots?
10:59:06 <jonkri> ah, nevermind, that's just off-topic
10:59:48 <xerox_> ...they have to be called ##name :-P
10:59:49 <mwc> jonkri, #freenode?
11:00:37 <jonkri> thanks
11:00:45 <jonkri> and sorry
11:01:15 <xerox_> It's ok.
11:04:16 <Cale> xerox: http://cale.yi.org/autoshare/Hourglass.svg
11:04:47 <Cale> not perfect
11:04:51 <Cale> but it's a start :)
11:05:02 <Cale> oh, there ought to be a shadow under the glass
11:06:38 <xerox_> YAY!
11:07:05 <Cale> there
11:07:23 <Cale> (added a shadow)
11:07:26 <xerox_> Pretty nice.
11:07:50 <xerox_> So, to draw it programmatically, we probably need to layer-ize it?
11:08:06 <xerox_> Background, sand, & foreground.
11:08:46 * xerox_ tries to get libsvg-cairo working in the meanwhile
11:09:00 <wolverian> Cale, the sticks should have shadows on the bottom too
11:17:51 <wilx> Yo.
11:18:05 <wilx> I have a bit OT question about image processing.
11:18:10 <jethr0> how can i convert a decimal number into binary?
11:18:31 <jethr0> i.e. as a string?
11:18:55 <wilx> Is there some well known heuristics or statistics that could compare two images for equality where the two images can be of different size and quality?
11:19:13 <wilx> > (read "1") :: Int
11:19:14 <lambdabot> 1
11:19:20 <wilx> Like this?
11:19:22 <xerox_> > take (log 10 / log 2) $ iterate (`mod` 2) 10
11:19:22 <lambdabot>  add an instance declaration for (Floating Int)
11:19:34 <beelsebob_> dcoutts: is there any good sample code to check that gtk2hs is working?
11:19:38 <xerox_> > take (round (log 10 / log 2)) $ iterate (`mod` 2) 10
11:19:39 <lambdabot> [10,0,0]
11:19:42 <xerox_> Err.
11:19:54 <dcoutts> beelsebob_, all the demos, after you've got it installed, do make installcheck
11:19:55 <jethr0> wilx: fourier transform?
11:20:17 <jethr0> xerox_: i rather meant a built-in method...
11:20:39 <wilx> Hmm, interesting, what would be the signal?
11:20:59 <jethr0> wilx: 2-d fourier transform on images is pretty standard
11:22:51 <wilx> Googling...
11:23:24 <jethr0> comparing the transformed functions should then be well possible. for example via cross-correlation (probably after some low-pass filtering, or so)
11:24:41 <beelsebob_> dcoutts: where are the demos put?
11:24:50 <beelsebob_> oh... demo
11:24:56 <beelsebob_> just missed it in the ls
11:25:40 <dcoutts> beelsebob_, make installcheck will build all the demos
11:25:55 <dcoutts> (at least all the ones appropriate to your configuration)
11:27:31 <xerox_> > snd $ last $ take (round (log 15 / log 2)) $ iterate (\(n,r) -> (n `div` 2,(n `mod` 2):r)) (15,[])
11:27:32 <lambdabot> [1,1,1]
11:27:37 <xerox_> ^_^
11:30:29 <jethr0> wilx: found anything suitable?
11:30:45 <wilx> http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/DRAPER2/L08.pdf
11:30:51 <wilx> Some slides that describe the basics.
11:30:55 <wilx> I will google more though.
11:31:21 <jethr0> comparing images should work pretty well
11:51:05 <tic_> tja wilx
11:51:06 <tic_> waern
11:51:10 <waern> hej
11:52:58 <ValarQ> goddag
11:54:43 <waern> hm.. ValarQ, jag knner igen ditt nick.. vet dock inte frn var
11:57:35 <Cale> wolverian: good idea, done :)
11:58:04 <wolverian> Cale, could also add a bit of shadow to the top of the sticks, from the top thing.. 
11:58:11 <wolverian> looking really good :)
12:02:51 <Cale> and again :)
12:05:40 <jethr0> i don't want to be the unproductive nitpicker, but i would make the upper wood plate a bit more elliptical/less angled
12:05:53 <jethr0> visible at a lesser angle
12:08:59 <Cale> there you go :)
12:13:42 <shapr> xerox_: Where's the sanduhr repo?
12:18:31 <xerox_> shapr: no repo atm
12:18:41 <xerox_> shapr: I'll make one this night.
12:19:07 <shapr> ok
12:19:10 <xerox_> I have to fetch the ssh key from some hard drive
12:19:21 <xerox_> I'll be back later, too, wave~~
12:19:30 <shapr> Yeah, time for some relaxing...
12:26:59 <elux> hi
12:27:22 <elux> can someone recommend a discrete mathematics text that explains concepts well and has good examples?
12:33:42 <SyntaxNinja> shapr: no relaxing!
12:35:43 <elux> has anyone looked at Discrete Mathematics and Its Applications 5th ed by Rosen?
12:41:42 <astrolabe> Not me
12:45:17 <elux> can someone explain this whole "Haskell is still the language of choice for discriminating hackers" thing
12:45:19 <elux> i see it everywhere
12:45:42 <Cale> It's the ICFP proclamation
12:45:50 <Cale> Haskell programmers won the ICFP again
12:46:00 <elux> is that the cops adn robbers thing?
12:46:14 <Cale> yeah, I think that's what it was last time
12:46:17 <elux> yea
12:46:20 <elux> i go to class with those guys
12:46:23 <elux> lol
12:46:31 <elux> brilliant guys
12:48:03 <Cale> Kieberer and Xiao Tou?
12:49:21 <elux> http://dailynews.mcmaster.ca/story.cfm?id=3255
12:49:47 <elux> well class with one of them .. another is my TA
12:50:54 <Cale> Ah, of course :)
12:51:05 <elux> are those the same people?
12:51:09 <Cale> yeah
12:51:11 <Cale> I know Wolfgang from when I was working there
12:51:19 <elux> you went to mcmaster?
12:51:22 <Cale> yeah
12:51:29 <elux> cool.. software engineering?
12:51:29 <Cale> I was working on coconut
12:51:41 <elux> ahh yea that project
12:52:15 <Spark> small world
12:52:23 <elux> quite
12:52:28 <Spark> ... if you're a functional programmer :)
12:52:34 <elux> lol.  tru
12:52:41 <elux> my professors here at McMaster love haskell
12:52:47 <elux> and i gotta say, its a pretty impressive language
13:05:18 <shapr> hey SyntaxNinja!
13:05:32 <ValarQ> 'lo formarn
13:05:36 <shapr> hey ValarQ
13:05:40 <shapr> wassup?
13:06:06 <ValarQ> compiling ghc on my new machine
13:06:24 <ValarQ> it seems to only be using one cpu :(
13:06:58 <shapr> Even with -smp and telling the ghc 6.5 RTS to use two cpus?
13:07:32 <ValarQ> havent checked the settings in the ebuild...
13:07:42 <shapr> You have 6.5 ebuild?
13:08:10 <ValarQ> nope, 6.4.1
13:08:24 <shapr> You'll need ghc-cvs, aka 6.5 to get SMP.
13:08:48 <ValarQ> for the build system?
13:09:43 <shapr> The unreleased ghc in the darcs repo has SMP support.
13:09:50 <ValarQ> ok
13:10:02 <ValarQ> sounds interesting
13:10:32 <ValarQ> is there an ebuild for the cvs?
13:10:34 <shapr> Yeah, Simon Marlow said the unoptimized first implementation of the SMP runtime got about 150% performance.
13:10:37 <ValarQ> er, darcs version
13:10:51 * shapr dunno
13:10:58 <shapr> Do you have two cores or more?
13:11:07 <ValarQ> 2 cores
13:11:10 <shapr> nice
13:11:13 <ValarQ> yeah :)
13:11:47 <shapr> I have a 2 cpu Athlon MP 1.5GHz, it'll be interesting to compare on-die and on-motherboard latencies for the same programs.
13:12:57 <ValarQ> how does the new smp support work?
13:13:40 <shapr> In short, it exploits the fact that the result of a call can be directly substituted for a call, and uses that for thunks.
13:13:47 <shapr> But that was probably obvious :-)
13:14:11 <ValarQ> yeah
13:14:17 <shapr> For details, see http://research.microsoft.com/~simonpj/papers/parallel/multiproc.pdf
13:15:10 <ValarQ> quite a chance for haskell now when multiple cores are getting popular
13:15:22 <shapr> Yeah, I've been pushing the idea for years.
13:15:26 * ValarQ feels optimistic
13:15:35 * shapr too
13:16:07 <shapr> I've made some interesting hypothetical extrapolations based on multicore setups...
13:16:48 <shapr> For example, the STI Cell cpu has nine cores for its 'single core' design. The Cell roadmap currently has a long term goal of 64 cores on a single die.
13:18:04 <dcoutts> I suggested Yhc as a platform to test a proof-of-cocept of Haskell on a cell CPU
13:18:06 <shapr> The average gaming enthusiast can easily afford a dual-socket motherboard, so let's say that ten years from now the Cell has reached 32 'single cores'
13:18:15 <dcoutts> it's described on the Yhc wiki page
13:18:37 <shapr> > (32 * 9) * 2
13:18:37 <lambdabot> 576
13:18:45 <dcoutts> > 64 * 32
13:18:46 <lambdabot> 2048
13:19:22 <shapr> At the moment, most programmers I've spoken to say that explicit thread creation will scale just fine. I disagree strongly...
13:19:35 <dcoutts> 32 is probably ok
13:19:49 <Beelsebob> shapr: google disagree don't they?
13:19:58 <shapr> Beelsebob: yup :-)
13:19:59 <dcoutts> people already have 32-way smp machines
13:20:05 <dcoutts> but not much more
13:20:28 <dcoutts> they start getting exotic arches after that
13:21:11 <lispy> shapr: there are graphs on how the performance typically grows with number of CPUs have you incorporated those into your estimates?
13:21:11 <shapr> So my question to the C programmers who advocate explicit threading is, how to deal with (64 * 9) * 2 separate cores that the average gamer will have in less than fifteen years?
13:21:54 <Beelsebob> especially when each of those cores will be slightly different
13:21:59 <dcoutts> shapr, especially if those cores do not have a simple shared memory space
13:22:02 <shapr> Are there any of those graphs that take nested data parallelism into account?
13:22:09 <shapr> lispy: Tell me more about these graphs :-)
13:22:18 <Taral> @seen JohnMeacham
13:22:19 <lambdabot> I saw JohnMeacham leaving #haskell and #haskell-blah 5 hours, 45 minutes
13:22:19 <lambdabot> and 31 seconds ago.
13:22:21 <lispy> shapr: iirc i saw them in a linux howto
13:22:22 <Taral> :(
13:22:29 <lispy> shapr: they were for C threading
13:22:48 <shapr> dcoutts: Right, that'll be challenging. Jan Willem-Maessan mentioned that distributed GC is a PITA right now.
13:23:05 <shapr> But distributed explicit locking would be so much more painful.
13:24:43 <shapr> I think that region allocation can probably be exploited to calculate data locality. That is, on NUMA, keep the data next to the code that uses that data.
13:25:08 * cathper can't think how hard a dead lock might be to trace if you have ~32 threads.
13:25:19 <lispy> there are some newer data sharing techniques (one implemented in the linux kernel by IBM, copy on read I think?) that help with lock contentions by getting rid locks
13:25:46 <dcoutts> lispy, it's RCU, Read Copy Update
13:25:52 <lispy> ah, that was it
13:25:59 <shapr> Sounds like memory journaling.
13:26:08 <dcoutts> it's patented and can only be used in GPL software
13:26:18 <dcoutts> shapr, no it's a clever scheduling thing
13:26:20 <shapr> Huh, nifty.
13:26:24 <lispy> the guy that came up with it gave a talk at my school, but i don't remember much other than lock contention is a way higher pentalty as proc speed increases
13:26:38 * SyntaxNinja pokes shapr w/ msgs
13:26:41 <dcoutts> shapr, there's a good article on it in LWN from a few years ago
13:27:00 <shapr> Yeah, memory bandwidth is not increasing as much as CPU speed.
13:27:45 <shapr> eivuokko: Hey, has anything happened with darcs-cgi-push since your last release?
13:27:50 <dcoutts> what's really interesting is that now you can do lots of processing if it saves doing some cache line fills
13:28:20 <dcoutts> something like 200 CPU instructions are equivalent to waiting for one cach line fill
13:28:29 <shapr> dcoutts: I think that explains Boquist's un-named benefits of SSA machine code.
13:28:33 <shapr> Maybe...
13:29:28 <shapr> Also, I'd like to print a die that's tiled with a square and hexagon pattern where the squares are CPUs and the hexes are local ram, and every edge is a link to the next section. Then you could price it according to how much of it actually works :-)
13:30:19 <dcoutts> mm, that's another benefit of multi-core, you get higher yeild
13:30:21 <eivuokko> shapr, nah, it works for me..  Well, ok, darcs unstable (and maybe stable now) has got patch that supports --sign options on push, which makes client even simpler..
13:30:31 <dcoutts> by turning off the cores that don't work
13:30:51 <dcoutts> so chip prices come down
13:32:12 <shapr> eivuokko: I wonder if it can do --encrypt as well?
13:33:17 <eivuokko> shapr, Huh?  That isn't available for any darcs command, right?
13:33:49 <eivuokko> Anyway...it'd probably be really trivial to add
13:33:52 <shapr> Yeah
13:46:08 <jethr0> i'm impressed how easy perceptron neural nets are
13:46:29 <jethr0> i just just trained mine to recognize digital clock digits :)
13:48:43 <basti_> does it work with a different font?
13:48:47 <basti_> or with photographed digits?
13:50:11 <jethr0> nah, just synthetic, data. but i'm just starting
13:50:30 <jethr0> gotta start small :)
13:51:02 <basti_> you don't know that "AI" techniques never solves any real problems, do you?
13:51:19 <jethr0> huh?
13:51:55 <jethr0> how are speech/face/text recognition not real problems?
13:52:30 <basti_> they do work?
13:53:26 <jethr0> basti_: i don't know what you're on about. AI has had bad publicity and many of the high aims failed. but the whole of robotics and image analysis is full of "AI" techniques
13:54:42 <jethr0> did prolog, symbolic differentiation and the "general problem solver" fail technically? no, they just didn't deliver the kind of "intelligence" everyone was hoping for
13:54:45 <basti_> I'm just ranting tbh. I can not see any working "robotics" or "image analysis" things that go beyond things that a human paid obscenely little amounts of money could or would do, and cost less in the long run.
13:55:21 <jethr0> i think neural nets are used in in practice more than you'd think
13:55:38 <davidhouse> i guess this is kind of off-topic here but it's a good source of people that have written stuff in gtk2hs, so i'll ask anyway.
13:55:49 <basti_> like, where?
13:56:15 <davidhouse> i want to change what font a textview displays its text in. can this be done in glade, or do i have to set it at runtime?
13:56:15 * dcoutts thinks gtk2hs is on topic ;-)
13:56:28 <dcoutts> davidhouse, runtime
13:56:43 <davidhouse> dcoutts: care to point me toward an attribute?
13:57:31 <jethr0> sales forecasting, industrial process control, customer research, data validation, risk management, target marketing
13:57:51 <davidhouse> i can't anything to do with fonts on the docs for TextBuffer or TextView.
13:58:05 <dcoutts> davidhouse, there ought to be an attribute, but in the mean time you can use widgetModifyFont
13:58:06 <basti_> ah. you mean areas where humans already fail to give reliable results?
13:58:07 <jethr0> basti_: classification of unstructured data is a hot topic :)
13:58:13 <basti_> then the aim is not too high.
13:58:19 <davidhouse> dcoutts: ah. okay, thanks
13:58:23 <jethr0> you're pretty cynical, aren't you?
13:58:26 <basti_> yes, hot for buzzers.
13:58:28 <basti_> yes I am
13:58:42 <basti_> especially about neural networks
13:58:48 <dcoutts> davidhouse, that modifes the font for the whole text view. There is also a way to set fonts (and all kinds of other attributes) on specific ranges in a text buffer.
13:59:10 <davidhouse> dcoutts: i don't think i need that, but thanks.
13:59:23 <basti_> lets put it that way:
13:59:28 <jethr0> basti_: and there's reason to be sceptical. but they're amazing at what they're doing. even if the applications have major problems
13:59:58 <basti_> of the few things the i found impressive in "AI" topics, none were done with classical "AI techniques"
14:00:12 <basti_> which would be: verbmobil and bayesian spam filters.
14:00:14 <basti_> period.
14:00:15 <basti_> ^^
14:00:29 <jethr0> hmm
14:01:08 <jethr0> i was impressed by the article about td-gammon. a neural backgammon program that started with zero knowledge, played only against itself and became the best player in the world
14:01:28 <jethr0> no need to exaggerate, but this example shows there's some potential for these kinds of techniques
14:01:55 <basti_> "TD-Gammon, developed by Gerald Tesauro of IBM, was the first of these computer programs to play at or near the expert level."
14:02:33 <jethr0> basti_: btw, handwriting recognition works impressively on many MS devices. it even has nearly 100% recognition when even i can't read my handwriting any more
14:02:43 <jethr0> yes, that one
14:02:54 <basti_> how much of that is neural?
14:03:36 <jethr0> don't know. i'm not neural network's knight in shining armor. just rebuttling your saying that recognition techniques don't work
14:03:39 <basti_> I don't doubt that NN's can do anything. I just think, they will never do what they're intended for, and the other uses (like, playing Backgammon) are very restricted
14:04:51 <jethr0> basically ANNs for classification do a similar thing as bayesian classification.
14:05:09 <basti_> except for that nobody is sure that they do anything that makes sense.
14:05:54 <basti_> imo the first step would be proving that a NN can't explode any time.
14:06:23 <jethr0> that depends on the dimensionality. for things that a simple bayes classifier does, a 1-layer-ANN might work and in that the weights are little less than the bayes parameters
14:06:30 <basti_> anyway, i was just ranting... don't take that stuff too serious...
14:07:08 <basti_> the problem is that a 1-layer network can't do anything meaningful either.
14:07:18 <shapr> jethr0: Is your perceptron written in Haskell?
14:07:32 <jethr0> i share you scepticism of the stability/reliability of ANNs. but when the alternatives are unrealisticly complex or just infeasible, it's at least an alternative
14:07:43 <basti_> and that bayes classification does something very meaningful
14:07:50 <jethr0> shapr, it's just a function as of now. when i've got a grasp of it, i'll try to do sth arrow-driven
14:08:04 <shapr> In any case, sounds nifty!
14:08:14 <basti_> i didnt want to hurt your feelings or anything
14:08:17 <jethr0> basti_: that's not true. 1-layer NN can do meaningful tasks
14:08:25 <jethr0> don't worry
14:08:41 <basti_> its just... kind of a reflex
14:08:55 <shapr> In essence, neural networks are just statistical classifiers like bayes.
14:09:03 <basti_> "we don't really know how to do it? oh, a NN might work."
14:09:03 <jethr0> converge f x = snd . head . dropWhile (uncurry (/=)) $ zip n (tail n) where n = iterate f x
14:09:24 <jethr0> shapr: i'm converging my neurons with the generic converge function :)
14:09:30 <basti_> shapr: no, bayes reasoning has a framework of statistics behind it and is not "lets twist a bunch of factors"
14:09:47 <basti_> which, to me, seems to be the usual NN-approach
14:10:01 <jethr0> basti_: NN put a hyperplane into the domain space. very much like bayes classifiers
14:10:01 <shapr> Mikhail Zak did some fascinating work on neural networks that exploit chaotic attractors.
14:10:08 <jethr0> heck, like any kind of classifier
14:10:28 <basti_> yes, it is in the same class of things
14:10:40 <shapr> basti_: 'backprop' means the errors flow back through the net to change the weights. In my viewpoint, it's just a statistical classifier.
14:10:43 <basti_> but bayes factors are adjusted with some reason, and because of a very meaningful theory
14:11:25 <basti_> i think we should debate that in #ai if at all.
14:11:28 <jethr0> all you do in NNs is adjust the hyper plane using the learning factor as multiplier.
14:11:32 <jethr0> :)
14:11:44 <basti_> cos it'll get on people's nerves
14:11:48 <jethr0> i've got a NN framework for haskell to write
14:11:53 <basti_> k
14:12:25 * shapr retrains basti_'s nerves...
14:12:34 <shapr> And I have to continue with my Evil Project.
14:12:39 <basti_> hF
14:12:43 <basti_> dint want to bother
14:12:55 <basti_> its just a knee jerk that happens to me now and then
14:12:59 <jethr0> shapr: what is your evil project?
14:13:05 <shapr> basti_: You've been overtrained ;-)
14:13:09 <jethr0> :)
14:13:27 <basti_> no i've seen what NN's do, opposed to what people claim they do.
14:13:34 <basti_> but apparently, everybody has to learn for himself.
14:13:42 <shapr> jethr0: It's a secret, but whether or not it succeeds, you'll hear about it at some point.
14:13:46 <jethr0> don't be a know-it-all
14:13:55 <basti_> I don't know it all.
14:13:58 <jethr0> shapr: can you give hints?
14:14:04 <shapr> I've tried to teach people autodidactism, but it seems they always have to learn it for themselves. -- Shae Erisson
14:14:15 <basti_> prolly its naughty.
14:14:36 <shapr> jethr0: Nah, if it works out I might end up making money with it, so no hints, sorry.
14:14:40 <jethr0> "always remember: you're unique. just like everyone else"
14:14:45 <jethr0> k
14:15:14 <jethr0> shapr: btw, i got my lazy tree alpha-beta-search working
14:15:19 <shapr> cool
14:15:31 <shapr> Sounds like TMR material.
14:15:32 <jethr0> perfect example of separating policy and mechanism using lazyness
14:15:40 <shapr> Speaking of which... I should kick out that last issue....
14:15:55 <jethr0> you just have to give it a lazy tree with all possible moves. and it'll go through it using iterative deepening
14:15:59 <shapr> That *really* sounds like TMR material now.
14:16:08 <jethr0> "saving" already done work for later
14:16:24 <shapr> I like positive use of laziness.
14:16:34 <jethr0> and it works really well and fast
14:17:07 <jethr0> it did a tic-tac-toe-5x5 lookup of 16*15*14*13*12 games in 50 secs
14:17:19 <jethr0> i.e. 5 ply.
14:17:27 <shapr> nice
14:17:31 <davidhouse> anyone familiar with the HTTP lib? i want a way of getting the response code description given a response code.
14:17:38 <jethr0> and then i found out that my alpha-beta-cutoff has broken and that i'd done a full minimax search
14:17:44 <davidhouse> i.e. 200 -> Successful, 404 -> File Not Found
14:17:59 <shapr> davidhouse: The HTTP lib Bjrn Bringert is maintaining?
14:18:06 <jethr0> shapr: looking forward to that TMR issue
14:18:10 <davidhouse> shapr, http://haskell.org/http
14:18:15 <shapr> me too..
14:18:28 <davidhouse> so yes.
14:18:36 <shapr> All I need to do is track down a few people who have partial articles, recheck the existing articles, and release it.
14:18:57 * basti_ gotta write something for TMR again, too, some day.
14:19:10 <shapr> basti_: Last chance...
14:19:18 <shapr> I'm shutting it down after this issue.
14:19:21 <basti_> oh
14:19:25 <basti_> too much hassle?
14:19:48 <shapr> Not really that, just that I'm switching my focus from community organization to code production.
14:20:02 <basti_> oh
14:20:17 <basti_> maybe I'll do something for the Haskell Wiki then
14:20:26 <davidhouse> shapr, so any ideas?
14:20:34 <shapr> davidhouse: Looking...
14:20:39 <lispy> oh, transfer or responsibility would be better than losing TMR
14:20:44 <shapr> lispy: You want it?
14:20:52 <lispy> shapr: nope :)
14:20:59 <shapr> I haven't found anyone who does...
14:21:05 <lispy> shapr: but maybe basti does :)
14:21:12 <basti_> >_<
14:21:15 <basti_> HEY.
14:21:16 <basti_> ;)
14:21:40 <astrolabe> Put a note in the editorial that it will disapear if no one takes it over.
14:22:19 <shapr> davidhouse: There doesn't seem to be a code -> response lookup table anywhere in Network.Browser or Network.HTTP
14:22:23 <shapr> You could write one :-)
14:23:13 <astrolabe> I no nutting
14:23:42 <astrolabe> jethr0_: still there?
14:23:47 <shapr> davidhouse: RFC2616 maybe?
14:23:51 <jethr0> yup
14:23:59 <davidhouse> shapr, yeah, i guess i'll just write one
14:24:20 <astrolabe> Isn't alpha-beta a fundamentally lazy algorithm in a way?
14:24:40 <jethr0> it's extremely well suited for a lazy tree, yes
14:24:45 <astrolabe> In that it doesn't generate a lot of nodes of the tree?
14:24:46 <shapr> davidhouse: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
14:25:02 <shapr> davidhouse: I dunno if that's the correct RFC though, just one of the first hits in my google search.
14:25:02 <jethr0> astrolabe: yes, but alternatively i can _not_ evaluate them :)
14:25:19 <davidhouse> shapr, actually, it's already in there
14:25:21 <jethr0> and by using a lazy tree you completely separate application and search mechanism
14:25:25 <davidhouse> shapr, well, kinda.
14:25:34 <tromp> hi astrolabe
14:25:42 <shapr> davidhouse: Oh I see
14:25:44 <davidhouse> shapr: if you have a Response then the rspReason contains what I want.
14:25:45 <astrolabe> I can see it would generate nicer code in a lazy language
14:25:51 <astrolabe> Hia tromp.
14:26:01 <davidhouse> so that's good enough for me. a lookup table would still be nice, but... yeah.
14:26:26 <jethr0> astrolabe: so your application generates a complicated tree with all kinds of lazy stuff in it. and the search algo would just "consume" that tree, without knowing what's in it
14:26:36 <shapr> davidhouse: Look at line 752 of Browser.hs
14:27:44 <davidhouse> shapr, that's not a lookup table
14:27:52 <davidhouse> that's just switching on certain resp codes
14:27:56 <jethr0> i wonder if you could train a sufficiently complex NN to spot digital watermarks even if it didn't know the domain (i.e. fourier) in which they were embedded :)
14:27:59 <davidhouse> i.e. the 3xx for redirection
14:28:23 <astrolabe> jethr0:  So it's going to have the same complexity as standard alpha-beta?   But be a cleaner way to code it?
14:28:33 <shapr> Yeah, but it seems like it could use a lookup table :-)
14:28:33 <tromp> did you see my fix to the tictactoe program?
14:28:49 <astrolabe> tromp: no.  Where should I look?
14:29:03 <davidhouse> shapr, well, you don't need to know the response reason there. only that it's, say, a 3xx code
14:29:23 <tromp> i simply took out the wins test:)
14:29:32 <shapr> davidhouse: As in, if you write one, send a patch to Bjrn. He's a cool guy and will probably a) welcome your patch and b) rewrite it into prettier code. Or maybe that's only what he does to my ugly patches ;-)
14:29:55 <jethr0> astrolabe: well, lazyness isn't for free. but while others write horrible code to implement iterative deepening that keeps information between iterations, the lazy tree does this from the very start
14:30:01 <astrolabe> tromp:  b b but wasn't it doing sompething useful?
14:30:04 <davidhouse> shapr, hehe. thanks
14:30:23 <jethr0> and as i said, i was quite impressed by the speed. although i have to think about relazifying some of the evaluated information again to save some space
14:30:52 <tromp> no, it was testing if there's only one win
14:31:09 <tromp> but it doesn't matter how many wins, 0, 1 or 2, there are
14:31:12 <Cale> laziness is beautiful for search problems
14:31:17 <astrolabe> jethr0:  sounds cool.
14:31:20 <jethr0> :)
14:31:22 <tromp> they always intersect
14:31:28 <shapr> Cale: Think you can finish your Scratchpad in the next few days? :-)
14:31:37 <Cale> shapr: yeah, possibly :)
14:31:42 <tromp> the final test is now simply       balance == 1 && null loss || balance == 0 && null wins]
14:31:53 <jips> anyone seen dons?
14:31:55 <jips> @seen dons
14:31:56 <lambdabot> dons is in #haskell. Last spoke 12 hours, 50 minutes and 6 seconds ago.
14:32:09 <shapr> He'll probably wake up in a coupla hours.
14:32:10 <jethr0> Cale: is there a way to relazify some evaluated data when you probably won't need it again, but might?
14:32:20 <astrolabe> tromp: Ah clever.  But what if they are wins for different sides?
14:32:26 <Cale> hmm, relazify? :)
14:32:28 <shapr> dons tends to show up around midnight Swedish time.
14:32:34 <shapr> @timein jips 
14:32:34 <lambdabot> Unknown command, try @listcommands.
14:32:38 <shapr> @time jips 
14:32:38 <lambdabot> Maybe you meant: dice type uptime
14:32:39 <jethr0> Cale: unevaluate
14:32:41 <shapr> feh
14:32:51 <Cale> jethr0: make it go out of scope
14:33:15 <jethr0> no, as i said, i might need it later again, but am willing to evaluate it again
14:33:15 <tromp> the test makes sure the player to move has no wins
14:33:22 <Cale> hmm
14:33:31 <jethr0> Cale: when searching too deep in my tree i get 700+mb mem usage
14:33:33 <astrolabe> jethr0: you should write it up.
14:33:48 <jethr0> astrolabe: you mean as a tmr article?
14:34:07 <astrolabe> ideally
14:34:26 <jethr0> astrolabe: not right away. before writing it up, i'd have to let some haskell gurus clean up the code for me :)
14:34:27 <Cale> jethr0: well, I suppose the only way is to just make sure that those computations aren't shared
14:34:36 <jethr0> hmm
14:34:36 <Saulzar> You found a use for the great big search tree method?
14:34:41 <jethr0> how would one ensure that?
14:34:48 <jethr0> Saulzar: yes :)
14:35:54 <astrolabe> tromp: I can't believe it's so simple, but it makes sense.
14:36:57 <jethr0> tromp: what game?
14:37:17 <tromp> tictactoe
14:37:19 <jethr0> ah, tic-tac-toe
14:37:30 <Cale> jethr0: call the function multiple times rather than binding its result with let or case -- CSE still might get you though
14:37:33 <jethr0> tromp: my alpha-beta-guy beats me hands down on a 5x5 board :)
14:37:58 <tromp> what guy?
14:38:07 <astrolabe> jethr0: a line of three on a 5x5?
14:38:12 <jethr0> algorithm-guy
14:38:16 <jethr0> now, line of 5
14:38:21 <jethr0> s/now/no
14:38:33 <jethr0> you think 3 would be harder?
14:38:55 <tromp> line of 5 is very drawish
14:38:56 <astrolabe> line of 5 should be easy to block
14:39:06 <Cale> hehe, make it line of 5 on a 19x19 board, and you basically have gomoku
14:39:07 <astrolabe> line of 3 should be easy to make I guess
14:39:17 <jethr0> hm, right, for line of 3 i'd have to change some of my heuristics/rules
14:39:23 <astrolabe> tromp: wasn't you're thesis on connect 4?
14:39:35 <astrolabe> *your
14:39:42 <tromp> nope. that was victor allis' thesis
14:39:57 <tromp> which stopped me from working on connect4
14:40:01 <Cale> http://en.wikipedia.org/wiki/Gomoku
14:40:02 <jethr0> 5x5 tic-tac-toe has a branching of 24 initially
14:40:09 <tromp> well, i worked on it recreationally
14:40:11 <astrolabe> Hmmm.  No, I wasn't confusing it with his.
14:42:09 <astrolabe> When I was still a PhD student, under the supervision of "Paul Vitnyi, I thought of doing a thesis on the game of connect-4."
14:42:21 <astrolabe> That must have thrown me.
14:42:33 <tromp> ah right
14:42:45 <jethr0> Cale: it would be cool if one could mark data types as "transient" to tell the garbage collect to reap them eventually, but reevaluate by need
14:43:03 <Cale> jethr0: yeah, that might be nice
14:43:10 <jethr0> Cale: can't you tell ghc how much memory to use as maximum?
14:43:20 <astrolabe> Hey tromp has an erdos number of 2!
14:43:26 <jethr0> it would allow some nice space-time tradeoffs
14:43:27 <shapr> Yeah, impressive, ain't it?
14:43:38 <jethr0> 2! == 2
14:43:39 <jethr0> :)
14:43:39 <tromp> nah, 1 is impressive
14:44:07 <astrolabe> 2 is impressive if you've yours is about 10
14:44:10 <shapr> I've never authored a research paper, I'm impressed.
14:44:21 <shapr> I'd like to though...
14:45:09 <tromp> you can publish papers on almost anything.
14:45:37 <tromp> i hear some guy even tried to publish a paper that just counted game positions:)
14:45:50 <shapr> Yeah, but will they show up in CiteSeer?
14:45:52 <jethr0> i was working in VR/augmented reality. and some of the papers were pure fun.
14:46:26 <shapr> I have some neat augmented reality ideas...
14:46:42 * shapr jerks his focus back to the Evil Project.
14:46:57 <astrolabe> shapr: should we be afraid?
14:47:40 <shapr> astrolabe: If it works, the world should be afraid.
14:47:51 <jethr0> shapr: stop advertising it so blatantly if it's all secret ^_^
14:47:58 <shapr> If it doesn't, I had fun hacking Haskell code.
14:48:02 <shapr> jethr0: Yeah, true :-)
14:48:02 * astrolabe hides under the bed
14:49:21 <shapr> Hey, anyone have any HUnit hacks or extensions?
14:49:38 * shapr is collecting useful bits.
14:49:54 <shapr> I have a QuickCheckExts.hs from TheHunter.
14:59:13 <astrolabe> jethr0:  connect 4 is a good game to try tree searches on because the number of leaves doesn't grow too explosively.
14:59:38 <jethr0> i want to make 2d fourier transforms under linux interactively. the gimp plugins are all bad and i've found no suitable gui solution. any hints?
14:59:56 <davidhouse> hi guys.
15:00:02 <jethr0> astrolabe: i might try that next. but i really want to try othello, which unfortunately also has a big branching factor
15:00:16 <basti_> interactively?
15:00:24 <jethr0> on the other hand, alpha-beta performs relatively best on high branching trees
15:00:32 <astrolabe> jethr0: othello is much harder I think.
15:00:50 <jethr0> basti_: like with a gui window. but i would also go with a suitable console solution...
15:01:10 <astrolabe> Even with optimal ordering, alpha-beta only square-roots the complexity IIRC
15:01:12 <basti_> how large do you want the area to transform to be?
15:01:19 <davidhouse> i need some advice: i've currently got an abstracted display code system in my program. it looks something like Display { output :: String -> IO (), input :: IO String, err :: String -> IO (), displayPage :: Response -> IO () }.
15:01:59 <davidhouse> one of the possible displayers i'm building is one build on gtk2hs. i want to allow my gtk2hs module to create a window when the program starts.
15:02:07 <astrolabe> jethr0: which is really useful of course, but it can be helped by a game that doesn't blow up.
15:03:02 <dcoutts> davidhouse, right
15:03:02 <davidhouse> so i add in a setUp :: IO () function to my Display declaration. only problem is, my setup function for my gtk2hs display module creates a couple of objects (relating to the window it just created) which i need access to later on.
15:03:03 <jethr0_> sry, split
15:03:21 <davidhouse> where can i store them?
15:03:21 <Saulzar> Games with big branching are great, since it is still a challenge to beat humans..
15:03:25 <dcoutts> davidhouse, how about this instead:
15:03:35 <jips> jethr0: have you considered gtk2hs?
15:03:43 <dcoutts> davidhouse, mkGtkDisplay :: IO Display
15:04:07 <jethr0_> jips: i don't want to write it myself. just do some horsing around with FFT, changes and inverse transform
15:04:10 <dcoutts> davidhouse, that way you can do some IO when you make the Display (ie you'd create a window etc)
15:04:30 <jethr0_> but if there's absolutely nothing there i might even consider writing it in haskell and gtk2hs :)
15:04:38 <dcoutts> davidhouse, and then the closures you stick into the Display can keep refs to the widgets you've created
15:04:56 <jips> jethr0: i think it could be done in only a few hours :)
15:05:26 <davidhouse> dcoutts: would i need to add a couple of generic stores in my Display type?
15:05:26 <jethr0_> yes, but for "interaction" a gimp plugin would be better. i even started writing one once, but somehow lost motivation finally :)
15:05:27 <dcoutts> davidhouse, eg: mkGtkDisplay = do { win <- newWindow; ...; return Display {  output = do ... win ... } }
15:05:42 <dcoutts> davidhouse, no, there's no need
15:05:52 <davidhouse> oh, right!
15:05:53 <davidhouse> nice.
15:05:56 <davidhouse> i'll try that
15:06:16 <davidhouse> if i didn't have a do statement but instead a function, would it still work?
15:06:22 <davidhouse> (i.e. how long is win accessible for)
15:06:37 <dcoutts> davidhouse, that's the nice thing about records of functions, they can hold extra private data that is not visible in the record or it's type
15:07:37 <dcoutts> davidhouse, the point is that if the thing building the Display has access to the 'win' then you're fine. So if you allow the Display constructor to do IO then you can arrange that.
15:07:57 <dcoutts> davidhouse, the win will stay as long as the Display does
15:08:09 <davidhouse> okay.
15:08:33 <dcoutts> davidhouse, (actually a top level Window is somewhat of a special case, it will stay on screen even if you drop all references to it)
15:20:10 <dons> yow
15:20:16 <jips> dons: hey
15:20:26 <dons> hi
15:20:26 <jethr0_> @yow
15:20:27 <lambdabot> PIZZA!!
15:20:37 <dons> ah, you were looking for me jips?
15:20:46 <dons> is it midnight Swedish time yet?
15:20:48 <jips> dons: affirmative
15:20:54 <jips> dons: apparently, since you are here :)
15:20:59 <dons> ah, it must be so
15:21:29 <dcoutts> @localtime dons 
15:21:30 <lambdabot> Local time for dons is Fri Feb 17 10:21:08 2006
15:21:37 <dcoutts> morning dons! :-)
15:21:53 <davidhouse> dcoutts: has dialogNewWithButtons not been implemented or something?
15:22:12 <dons> mornign dcoutts!
15:22:19 <dons> ah, ^^^ need my coffee
15:22:24 <jips> dons: remember that hs-plugins bug report about the file not being closed properly?
15:22:29 <dcoutts> davidhouse, no, because it's a varargs function in C, but you can do the equivalent in Haskell with a series of calls
15:22:35 <dons> jips, yes. you were going to send an example ... ?
15:22:43 <dons> which I never got?
15:22:53 <dcoutts> dons, mm, not yet, it's morning in 40min
15:22:58 <davidhouse> dcoutts,yeah. just that the api docs recommends it.
15:23:08 <jips> dons: hm.... i sent you that webpage with a detailed description and you said that it was sufficient
15:23:20 <dons> ah, sorry!
15:23:22 <dons> let me see.
15:23:24 <dcoutts> dons, any progres on de-bloating cabal-get ?
15:23:39 <dons> no, was going to start over the weekend (i.e. tomorrow, maybe later today)
15:23:40 <dcoutts> davidhouse, it does? oh I should change that.
15:23:47 <dcoutts> dons, cool
15:24:08 <davidhouse> dcoutts, http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/Graphics-UI-Gtk-Windows-Dialog.html
15:25:04 <dons> jips, hmm, do you have the  link?
15:25:29 <dons> I can't seem to find it :/
15:25:30 <dcoutts> davidhouse, yep, you see we generate most of the docs from the C docs and don't always catch when the C docs are not appropriate.
15:25:41 <dcoutts> davidhouse, I'll fix that though.
15:29:12 <jips> dons: hm.... the webhost seems to have kicked the bucket :/ but the jist of it was that everything works except the situtaion where there is a "merge error" during compilation in which case the plugin source file isn't closed properly(as can be witnessed with lsof)
15:34:06 <SyntaxNinja> dons: :)
15:34:36 <dons> jips, ah ,right. i remember. and this is causing some problems for you?
15:36:23 <jips> dons: yes because it prevents you from being able to edit the file
15:38:01 <musasabi> Does Haskell98 FFI addemdum define the INCLUDE pragma or is that a GHC extension?
15:39:07 <dcoutts> I think it's an extension
15:39:27 <musasabi> ok
15:40:06 <dcoutts> I think the only blesed method is the: foreign import "foo.h foo_frobnicate"
15:40:41 <davidhouse> okay, i need more gtk2hs help:
15:40:48 <dcoutts> ok :-)
15:41:40 <davidhouse> in my abstracted Display datatype, there's a section for 'input' which gets input from the user. i'd like to build a function which waits on the user pressing a given button then return the contents of an entry (i don't want to use a dialog).
15:41:46 <davidhouse> how can i wait for a signal like that?
15:43:18 <dcoutts> davidhouse, mm, so you're sort of converting from an async to a sync model
15:43:44 <davidhouse> i think it'll work though.
15:44:02 <dcoutts> you'll probably need to use an IORef
15:44:13 <davidhouse> basically what i'm building is a web browser (it won't be anything special, it's just to allow me to learn haskell/gtk2hs)
15:44:31 <davidhouse> when it was terminal-based, input was getLine, which again waits for the user.
15:44:34 <dcoutts> and have that get modified by a signal handler that you attach to the edit widget
15:45:02 <davidhouse> so my input will form the main loop of my program, where i wait for the user to type something then we go.
15:45:24 <davidhouse> dcoutts, could you expand a little? i'm still very new to gtk2hs.
15:45:34 <dcoutts> then you can implement the waiting by a loop that checks the IORef to see if the event has happened and runs the GUI loop for one cycle
15:48:02 <dcoutts> davidhouse, so you'd want a loop that checks the IORef and if the event hasn't happened yet, calls mainIteration
15:48:15 <dcoutts> oh, he dissapeared
15:48:20 <dcoutts> davidhouse, so you'd want a loop that checks the IORef and if the event hasn't happened yet, calls mainIteration
15:48:35 <davidhouse> dcoutts, sorry, my IRC client froze up. could you repeat?
15:48:45 <dcoutts> I did, that's all I said
15:48:54 <davidhouse> ah, okay.
15:49:29 <dcoutts> let waitForEvent = do { val <- readIORef; if hasHappened val then return () else mainIteration >> waitForEvent }
15:49:32 <jips> so much for kde's rumored stability :P
15:50:15 <davidhouse> jips, quite.
15:50:20 <dcoutts> davidhouse, so you attach a signal hander to the entry box that sets the IORef to a suitable value when the event happens
15:50:31 <davidhouse> jips, it happens a lot. it's probably more to do with my generally screwed system though
15:50:50 <davidhouse> dcoutts, i'll look into it. thanks.
15:50:52 <dcoutts> davidhouse, the alternative to this IORef stuff is to use threads and channels
15:51:13 <dcoutts> davidhouse, then you run the GUI in on thread and your sequential IO code in another
15:51:14 <davidhouse> pros? cons?
15:51:25 <davidhouse> ah, that sounds tricky.
15:51:28 <dcoutts> the sequential code just reads commands/events posted to a Chan
15:51:43 <davidhouse> i'll stick with IORefs, i think
15:51:45 <dcoutts> the GUI just posts events to the Chan whenever they happen
15:51:57 <dcoutts> it's quite an elegant solution, but it does involve using threads
15:53:12 <dcoutts> personally I quite like the threaded GUI designs
15:53:20 <dcoutts> I use that pattern quite a bit in hIDE
15:53:55 <dcoutts> the thread can maintain state quite easily too since it's just in a recursive function reading from a channel
15:54:09 * Beelsebob wonders why @where's stopped working
15:54:19 <dcoutts> @where Beelsebob
15:54:19 <lambdabot> I know nothing about beelsebob.
15:54:28 <dcoutts> @where gtk2hs
15:54:29 <lambdabot> http://haskell.org/gtk2hs/
15:54:40 <dcoutts> has it stopped working?
15:54:45 <Beelsebob> Beelsebob|Home: @where+ Twig http://www.uploadthis.co.uk/uploads/Twigathy/timetable.html
15:54:48 <Beelsebob> logicbot: Unknown command, try @listcommands.
15:54:50 <Beelsebob> ... yes
15:55:32 <dcoutts> @listcommands where
15:55:32 <lambdabot> where provides: where what where+
15:55:38 <dcoutts> @where+ Twig http://www.uploadthis.co.uk/uploads/Twigathy/timetable.html
15:55:38 <lambdabot> Done.
15:55:50 <dcoutts> @where Twig
15:55:51 <lambdabot> http://www.uploadthis.co.uk/uploads/Twigathy/timetable.html
15:56:02 * dcoutts just has the knack :-)
15:56:11 <Beelsebob> Beelsebob|Home: @listcommands where
15:56:11 <Beelsebob> logicbot: No module "where" loaded
15:56:14 <Beelsebob> :/
15:56:20 <dcoutts> logicbot: ?
15:56:23 <Beelsebob> it was loaded last time...
15:56:34 <Beelsebob> lambdabot for people who don't know about lambdas ;)
15:56:39 <dcoutts> hah
15:56:41 <Beelsebob> in a different channel
15:56:50 <dcoutts> clearly inferiour
15:57:00 <Beelsebob> ahhh - but logicbot has @truth
15:57:09 <Beelsebob> ... but not @where for some reason
15:57:12 <dons> logicbot: @version
15:57:22 <dons> Beelsebob|Home: @version
15:57:31 <dons> it's not a lambdabot?
15:57:48 <Beelsebob> logicbot: lambdabot 3p286, GHC 6.4 (Linux i686)
15:57:48 <Beelsebob> logicbot: darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
15:57:55 <dcoutts> @truth the way and the light
15:57:56 <lambdabot> Unknown command, try @listcommands.
15:58:04 <davidhouse> anyone recommend a tutorial that covers the more advanced features of haskell?
15:58:33 <dons> dvaidhouse, hmm, what are you interested in?
15:58:59 <dons> we're starting to add advanced things to the wikis (well, I am, and I think there's other advanced stuff there already)
15:59:16 <dons> so perhaps check the haskellwiki and hawiki
15:59:19 <dons> @hawiki
15:59:20 <lambdabot> http://www.haskell.org/hawiki/
15:59:23 <davidhouse> well i've covered most of YAHT, but there's still lots of stuff i need to read about, i gather.
15:59:55 <dons> also,  http://www.haskell.org/haskellwiki
16:00:07 <Beelsebob> dons: any idea why where wouldn't be loaded?
16:00:35 <davidhouse> dons, what's the difference?
16:00:53 <dons> davidhouse, one is the old wiki, the other is new. we're moving everything to the new wiki, slowerly
16:01:01 <Beelsebob> ah....
16:01:03 <Beelsebob> Couldn't load where, ignoring
16:01:04 <Beelsebob> ......... done.
16:01:10 <dons> davidhouse, depending on what you want to learn, reading the ghc user's guide is a good idea
16:01:13 * Beelsebob wonders why
16:01:23 <dons> particularly "Type system extensions"
16:01:27 <davidhouse> dons, haskellwiki is the new one?
16:01:30 <dons> yep
16:01:46 <dons> also, check the various documents on haskell.org/ghc
16:02:14 <dons> http://haskell.org/haskellwiki/GHC:Documentation
16:02:25 <dons> (oh, /ghc is part of haskellwiki now :)
16:19:53 <dons> davidhouse, another idea is to check course notes from the various university courses called "Advanced Functional Programming".
16:20:06 <davidhouse> dons, thanks.
16:20:13 <dons> Chalmers and UNSW both teach such courses in Haskell. I'll find you a link.
16:20:21 <davidhouse> i'm finding http://en.wikibooks.org/wiki/Programming:Haskell to be really good.
16:20:25 * tic_ attended the Chalmers one this winte.
16:20:25 <tic_> winter.
16:20:56 <dons> here's the UNSW one (which I've done a few years ago): http://www.cse.unsw.edu.au/~cs4132/
16:21:10 <dons> (hmm. a lot of this should go on the haskellwiki :)
16:21:31 <dons> the guy who teaches this is 'Chilli' here in #haskell
16:22:43 <dons> tic_, got a link to the Chalmers course?
16:22:48 <tic_> sec.
16:23:06 <tic_> http://www.firebox.com/index.html?dir=firebox&action=product&pid=1258
16:23:09 <tic_> bah.
16:23:17 <tic_> I said Cmd-C damnit. http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/
16:23:31 <tic_> Lennart A. is a semi-god.
16:23:40 <tic_> along with Simon P. Jones and Hughes.
16:24:26 <davidhouse> brilliant. cheers dons, tic_.
16:24:31 * davidhouse del.icio.us-ises
16:26:23 * wli discovers his Imap.hs in haskell-libs
16:26:36 * wli is stunned
16:27:28 <dons> looks like the Chalmers one concentrates on current advanced stuff, and the unsw one focuses on more edgy research issues? like Assoc. types. so you get a good spread from monads through  to not-yet-implemented type system extensions. 
16:27:41 <dons> if you do both courses :)
16:30:53 <wli> really cool that it got somewhere (even if not far)
16:32:05 <xerox_> Anybody has clues about debian packages' crafting perchance?
16:34:25 * wli does not
16:47:53 <jethr0_> i just read a paper of a guy who wrote a halflife bot using neural nets. only to find out that he had done this while still being at school *sob*
16:48:07 <jethr0_> s/being at/going to/
16:50:01 <musasabi> ok
16:51:05 <jethr0_> some people are just cooler than me :)
16:52:03 <xerox_> G'night.
16:55:26 <Saulzar> jethr0_, Yeah, too many smart people in the world. :)
16:56:25 <jethr0_> Saulzar: exactly. even when you're trying to do sth cool; almost always somebody has trumped you before you even started *g*
16:57:14 <jethr0_> and in addition there's so much to learn out there. this combination leaves little time to get anything productive done...
16:59:47 <Saulzar> Hmm, only thing to do is specialise. There are a lot of niches :)
17:02:22 <jethr0_> yes, but a firm grip of the "basics" often helps in approaching new problems
17:04:00 <Pseudonym> As they say, you have to know what the rules are before you break them.
17:04:04 <Saulzar> Yes, I think knowing limits also helps - doing something cool is often quite hard
17:05:52 <jethr0_> i think it's important to have heard of as many approaches/solutions/ideas as possible. so that when sth comes up you can say "hmm, we might tackle this with this and that algo"
17:08:02 <Saulzar> Yep, definately.
17:10:42 <Saulzar> Not easy to say "Well I did this and it was truly original", at least I don't think I can say that of anything I've ever done. Doesn't mean it's not worthwhile though :)
17:10:59 <jethr0_> i wish i had "known" about neural nets when i was doing a robot challenge. although acquiring lots of data would have been hard, devising algos for noisy data wasn't so nice either
17:11:44 <jethr0_> hmm, original is overrated. i'd rather go for "blowing people's minds" ^_^
17:12:07 <Saulzar> Hmm, neural nets seem hard to put to good use though, right?
17:13:21 <jethr0_> maybe, i couldn't say. but the idea is definitely intriguing. and from what i'm reading people are pretty happily using them
17:15:31 <jethr0_> stupid new sourceforge layout. i'm having a hard time navigating all that multimedia... well, everything is relative :)
17:16:51 <Saulzar> Focus on "cool" is dangerous too, easy to pick something too ambitious
17:18:58 <jethr0_> yup
17:19:19 * Saulzar likes to do that.
17:21:03 * jethr0_ too. there's nothing like realizing the futility of trying something outrageously complex
17:22:26 <jethr0_> maybe i'll try doing some spam filtering using NNetworks. seems like worth a try
17:23:27 <Saulzar> Or putting a lot of work into something promising, to realise it should take another re-write and considerably more work
17:23:46 <jethr0_> the problem is to get the mails into a network-readable format
17:24:32 <jethr0_> every single one of my projects "needs" major rewrites. i guess i'm just too self-critical and too easily succumb to quickly hacking in new features
17:25:34 <Saulzar> Hehe, very true - but if it was a little smaller, maybe it would be more managable and finishable
17:26:14 <jethr0_> i really wonder how well a sufficiently complex NNetwork can abstract. can it find the faintest regularities in data, like high frequency anomalies of steganograms?
17:27:49 <Saulzar> Hmm, could operate on word level and sentence level for some fixed size
17:28:42 <Saulzar> Must be some "good" way of doing it - as it would apply to all problems with undefined length
17:28:52 <jethr0_> ya, but i'd really have to convert the mail into chunks of "bits" \in [-1,1]. that would need some thought
17:29:25 <jethr0_> i'll google and look how others have done it *G*
17:30:35 <jethr0_> http://www.interstice.com/drewes/cs676/spam-nn/spam-nn.html
17:32:51 <Saulzar> Hmm, based on the n most frequent words..
17:33:12 <jethr0_> yup, just read it as well. pretty much how bayesian filters do it too
17:33:36 <Saulzar> Spam these days tends to have virtually no words at all
17:33:38 <jethr0_> in graham's articles he even uses only the 15 most significant words
17:33:56 <Saulzar> Either that or they put the spam at the top and give an essay down the bottom to sidetrack spam filters
17:33:59 <jethr0_> to prevent spammers from lowering their score by adding tons of "normal" text
17:34:25 <Saulzar> Surely tons of normal text will make up the most 15 significant words?
17:35:05 <jethr0_> it's really weird how small well-performing networks are. nobody uses 3 layers, and the second layer is always below 20 neurons.
17:35:12 <jethr0_> mind-boggling
17:35:27 <pesco> evening post
17:40:52 <Saulzar> Would seem ideal if somehow all the content could be included
17:41:39 <jethr0_> ?
17:42:16 <Saulzar> 15 most significant words is easily defeated if you know that is the scheme..
17:43:31 <jethr0_> not necessarily. graham makes the point that with individually adapted bayesian filters, spammers can impossibly _know_ significant "ham" words. and if they did, these would be added and others would emerge. unique to the filter's owner
17:44:04 <jethr0_> but fighting spam is always as arms race
17:44:26 <Saulzar> Well, these days they all use nonsese words..
17:45:50 <jethr0_> although i don't understand how words like "v4l1um" are hard to filter. but then again bayesian word based filters are too dumb to see this kind of pattern. with a suitable input transformations, NNets might do it...
17:45:58 <Saulzar> m4sters and p hd aat low l ow pric3s
17:46:45 <jethr0_> years ago i got "get a diploma for your lifetime experience". i really loved that, especially given the fact that i had no lifetime experience back then!
17:47:16 <Saulzar> Hehe. Recently I received a Nigerian scam mail, haven't recieved any of those for ages :)
17:48:35 <jethr0_> putting whole text (up to length n) into a network might yield results... who knows
17:52:29 <jethr0_> or, coming back to my question what kind of regularities NNs might pick up, even a hash of the mail. given a sufficiently complex network that should work :)
17:52:46 <Saulzar> Hehe, trouble is the more complicated the network the more training you need
17:53:52 <jethr0_> true
17:53:56 <Saulzar> No network will be good enough to identify spam if you've passed it through md5sum! :)
17:54:04 <jethr0_> you never know
17:54:18 <jethr0_> but i guess it would have to be _pretty_ complex
17:55:07 <jethr0_> although humans can show remarkable feats of pattern recognition
17:55:36 <jethr0_> but a hash is probably the hardest you could throw at a pattern recognizer
17:56:06 <Saulzar> I would guess it is impossible :)
17:56:18 <jethr0_> but, you can even do compression with NNets. train it with original/compressed data and it will learn that too
17:56:51 <Saulzar> Hmm... what kind of compression? Would need to maintain a lot of the original structure right?
17:56:54 <jethr0_> same should go for encryption and decryption (i'm getting naive now).
17:57:25 <Saulzar> Also, the output of md5sum might not be good enough to recognise spam at all anyway
17:57:42 <jethr0_> @google neural networks image compression
17:57:43 <lambdabot> http://www.comp.glam.ac.uk/digimaging/neural.htm
17:57:59 <jethr0_> Saulzar: i was more joking that anything else
17:58:57 <jethr0_> hmm, that google link didn't have enough pretty pictures
17:59:50 <Saulzar> Hmm. 
18:00:09 <jethr0_> you do compression by creating a bottleneck in the network and training it to the identity function.
18:00:34 <jethr0_> by taking the data at the bottleneck, transporting and reinserting it, you have compression :)
18:00:55 <jethr0_> http://www.ee.duke.edu/~cec/research/neuralcompression/JPL/node4.html
18:01:04 <Saulzar> Neat
18:01:09 <jethr0_> impressive. 16:1
18:02:16 <Saulzar> Not quite lossless though :)
18:03:26 <jethr0_> well...
18:03:39 <jethr0_> neither is jpg
18:05:41 <Saulzar> I'm sure jpg does much better in terms of subjective quality to humans though
18:06:05 <jethr0_> *lalala*
18:06:29 <wli> Is there a Haskell JPEG codec yet?
18:06:35 <jethr0_> NNs don't have nobs to tune
18:07:25 <Saulzar> Maybe you could tune it to jpeg rather thanid :)
18:08:05 <Saulzar> wli, No - but there are bindings to libraries with image loading/saving etc.
18:08:42 <jethr0_> that's how i thought it worked... but it's indeed the case that NNs can learn any function which they are big/complex enough to represent. so training a jpeg network is (at least in theory) possible
18:10:18 <wli> I mostly wanted to cook up my own custom smoothing kernels.
18:12:09 <jethr0_> Saulzar: supposedly NN based compression exceeds jpeg for high-compression cases.
18:12:31 <wli> jethr0: I'd be more interested in higher quality given equal compression.
18:12:38 <jethr0_> but it might just as well be a case of paper-lies again
18:12:56 <jethr0_> wli: sry, that's what it meant
18:13:20 <wli> jethr0: not equivalent...
18:13:48 <jethr0_> i know, but quarter-correlated :)
18:14:38 <wli> for instance I saw on the page you showed me 2 images side by side
18:14:53 <wli> I can see pixellation in the compressed image
18:15:41 <jethr0_> there's different approaches. but i'm sure that if NN-based compression were so great, it would be used somewhere..
18:15:41 <wli> It'd be good to see equivalent compression ratios with different algorithms for a quality comparison
18:15:47 <jethr0_> yup
18:15:53 <wli> jethr0: also
18:16:01 <wli> jethr0: speed is a big factor in the success of image compression algos
18:17:17 <jethr0_> http://www.dice.ucl.ac.be/~verleyse/papers/sams03ca.pdf
18:30:05 <Saulzar> Hmm, the image they show of jpeg at 1:38 is solid blocks of colour
18:33:48 <jethr0_> ya well. hopefully it's not the typical paper bias
18:44:17 <jethr0_> good night
18:45:13 <Saulzar> later jethr0_ 
19:30:40 * dons likes the new wiki
21:33:29 <gour> anyone familiar with lyx?
21:34:26 <gour> (ahh...forgot o greet with 'morning')
21:35:05 * gour considers his fingers still not fully alive
21:51:53 <dons> @quit some new code
21:52:14 <Lemmih> lambdabot: @whatsnew
21:52:25 <lambdabot> Unknown command, try @listcommands.
21:52:57 <dons> @time Lemmih
21:52:59 <lambdabot> Local time for Lemmih is Fri Feb 17 06:53:51 2006
21:53:02 <dons> is a synonym for @localtime
21:53:08 <dons> (after shapr kept typing @time )
21:53:19 <dons> @oldwiki Lambdabot
21:53:19 <lambdabot> http://www.haskell.org/hawiki/Lambdabot
21:53:26 <dons> @wiki Obfuscation
21:53:26 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
21:53:53 <sieni> ahh
21:54:18 <dons> @fptools Data.Map
21:54:18 <lambdabot> http://darcs.haskell.org/packages/base/base/Data/Map.hs
21:54:22 <dons> should be the new location.
21:54:22 <dons> almost.
21:55:38 <Lemmih> @fptools GHC
21:55:39 <lambdabot> GHC not available
21:55:54 <dons> @fptools GHC.Base
21:55:55 <lambdabot> GHC.Base not available
21:59:46 <dons> @dynamic-reload dummy
21:59:46 <lambdabot> module reloaded
21:59:54 <dons> @dynamic-reload version
21:59:55 <lambdabot> module reloaded
22:00:12 <dons> @fptools Data.Map
22:00:13 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
22:00:42 <dons> @version
22:00:43 <lambdabot> lambdabot 3p290, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
22:00:43 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:07:04 <cathper> > mod (-3) 2
22:07:16 <lambdabot> 1
22:33:48 <dons> shapr, will scannedinavian.org disappear? will things like the iohcc/succzeroth-2004/ be wiped?
22:52:45 <shapr> dons: Don't know, want to host a mirror just in case?
22:54:45 <rasfar> > mod (-4) 3
22:54:46 <lambdabot> 2
22:56:28 <dons> is that easy to do, shapr?
22:57:52 <shapr> Yeah, it's just a few files.
22:58:48 <dons> ok, I'll do that then.
23:14:46 <shapr> dons: It's a 68k file - http://www.scannedinavian.org/iohcc/iohcc.tgz
23:16:31 <dons> 68k, my favourite number of k. got it.
23:18:05 <shapr> Is that because of the motorola 68k?
23:20:11 <dons> yeah :) my first machine.
23:21:10 <shapr> Is it still popular? I know the Palm used the 68HC11 for awhile.
23:21:34 <dons> not sure if it still is. maybe in some mobile phones?
23:21:50 <shapr> That would make sense.
23:25:31 <Lokadin> say how would i read the text off a web page
23:25:55 <Lokadin> i mean say if i wanted the source for google.ca
23:26:26 <Lokadin> like the html
23:26:33 <Lokadin>  i mean i was thinking of using curl
23:26:46 <Lokadin> but i can't get it's output for some reason
23:26:53 <Lokadin> i can't figure out how mainly
23:26:56 <Cale> wget -q -O-
23:27:10 <Lokadin> ?
23:27:19 <Cale> wget -q -O- www.google.com
23:27:21 <Cale> for example
23:27:33 <Cale> will write the source for www.google.com to stdout
23:27:47 <dons> and then use something like  'w3m -dump' to render the src
23:27:52 <dons> to ascii
23:28:08 <Lokadin> well i just want it to feed into the program
23:28:25 <Cale> xml2 and html2 are really convenient
23:28:40 <Cale> they flatten the html into something that's more trivial to parse
23:28:44 <Lokadin> so i was doing: page <- system "curl www.google.ca"
23:28:55 <Lokadin> well i don't need to parse it
23:29:17 <shapr> You could use the HTTP lib.
23:29:42 <Lokadin> yea?
23:29:46 <dons> @where http
23:29:47 <lambdabot> http://www.haskell.org/http/
23:29:48 <shapr> Or look at lambdabot's @google command.
23:30:00 <dons> or even http://www.cse.unsw.edu.au/~dons/code/lambdabot/MiniHTTP.hs
23:30:14 <Lokadin> thanks
23:30:17 <Lokadin> :D
23:31:09 <Lokadin> wow seems so complex :|
23:31:40 <Lokadin> maybe i could just use the system command to write to a file and i'll just read it off the file
23:31:56 <Lokadin> i was just wondering if i could do that without necessarily making a file
23:32:07 <dons> pepole do this sometimes. but just grabbing a file is pretty easy with MiniHTTP.
23:32:21 <Cale> you could also just use runInteractiveCommand
23:32:50 <Cale> @type System.Process.runInteractiveCommand
23:32:50 <lambdabot> String
23:32:50 <lambdabot>               -> IO (GHC.IOBase.Handle,
23:32:50 <lambdabot>                 GHC.IOBase.Handle,
23:32:50 <lambdabot>                 GHC.IOBase.Handle,
23:32:50 <lambdabot>                 System.Process.Internals.ProcessHandle)
23:33:11 <Cale> it gives you the stdin, stdout, and stderr along with the process handle
23:33:20 <Lokadin> o wow
23:33:43 <Lokadin> so could you give me an example of how to use it?
23:34:07 <Lokadin> i mean runInteractiveCommand "curl www,google.ca"
23:34:08 <Lokadin> ?
23:34:23 <Lokadin> if i had say page <- in front
23:34:31 <Lokadin> to put it in variable page
23:34:31 <Cale> do (inp,out,err,hdl) <- runInteractiveCommand "curl www,google.ca"
23:34:41 <Cale>   hGetContents out
23:34:43 <Cale> er
23:34:48 <Cale>    page <- hGetContents out
23:34:50 <dons> maybe we need a howto on the wiki. people often ask aout this problem.
23:35:12 <Lokadin> wow thanks
23:35:59 <Cale> www.google.ca
23:36:02 <Cale> of course :)
23:36:38 <ulfdoz> What's .ca?
23:36:42 <Lokadin> say what would i import?
23:36:43 <Cale> Canada
23:36:44 <mauke> canadia
23:36:47 <Lokadin> as in system?
23:36:56 <Lokadin> import System
23:36:59 <Cale> System.Process and System.IO
23:37:08 <Lokadin> kk thanks :D
23:37:19 <ulfdoz> Ah
23:39:15 <Lokadin> a.out: fd:5: hGetContents: illegal operation (handle is closed)
23:39:17 <Lokadin> :(
23:39:36 <Cale> maybe the command failed?
23:39:41 <Lokadin> hmmm
23:39:44 <Cale> It works for me in ghci
23:39:56 <Cale> Prelude> :m System.Process System.IO
23:39:56 <Cale> Prelude System.IO System.Process> (inp,out,err,hdl) <- runInteractiveCommand "curl www.google.ca"
23:39:56 <Cale> Prelude System.IO System.Process> page <- hGetContents out
23:39:56 <Cale> Prelude System.IO System.Process> page
23:39:56 <Cale> "<html><head><meta http-equiv=\"content-type\" content=\"text/html;...
23:40:33 <Lokadin> kk let me try again
23:41:29 <Lokadin> say where can i paste my program?
23:41:40 <Lokadin> cause i can't see what's different
23:41:46 <Cale> lisppaste2: url
23:42:01 <Lokadin> er
23:42:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:42:35 * shapr imports canada!
23:42:49 <Cale> it also works for me compiled
23:42:53 <lisppaste2> Lokadin pasted "TypingGame" at http://paste.lisp.org/display/16891
23:43:26 <Lokadin> compiled for me to
23:43:31 <Lokadin> just didn't run
23:43:33 <Cale> oh, remove that extraneous hGetContents
23:43:39 <Lokadin> o
23:43:48 <Cale> that was a typo on my part
23:44:09 <Lokadin> you mean the second one?
23:44:19 <Cale> the first one, which doesn't bind a result
23:44:31 <Cale> (it's reading the contents and throwing them away)
23:45:44 <Lokadin> Yay
23:45:45 <Lokadin> :D
23:45:53 <Lokadin> it worked
23:46:42 <Cale> great
23:56:20 <Lokadin> say how do i make comment blocks?
23:57:07 <mauke> {- how do I made comment? -}
23:57:19 <Lokadin> lol :D thanks
