00:12:08 <Lokadin> say, could i take page, which is basicall like a file, take off the first 80 characters, then have page be without those 80 characters. Or perhaps instead to maybe have a marker for placement in the string?, but so later i can come back to it and move marker farther..
00:12:43 <Cale> > splitAt 5 "Hello World!"
00:12:44 <lambdabot> ("Hello"," World!")
00:12:53 <Lokadin> o wow
00:12:54 <Lokadin> thanks
00:13:05 <Lokadin> :D
00:13:52 <Cale> or if you don't care about the start, you can just use drop
00:13:56 <Lokadin> how would i then print say that first part
00:14:15 <Lokadin> well yea i need the front part
00:14:16 <Cale> do let (x,y) = splitAt 80 xs
00:14:26 <Cale>    putStrLn x
00:14:38 <Lokadin> kk thanks 
00:14:40 <Lokadin> :D
00:15:14 <Cale> (presumably you'll have more than just that in the do-block of course :)
00:15:48 <Lokadin> well yes
00:17:00 <Lokadin>  page <- hGetContents out
00:17:00 <Lokadin>     let (x,y) =  splitAt 80 page
00:17:02 <Lokadin>     putStrLn 
00:17:03 <Lokadin> x
00:17:15 <Lokadin> can i do that?
00:17:51 <Lokadin> yes
00:17:52 <Lokadin> oi
00:18:01 <Lokadin> why did i ask, lol i could have just compiled
00:18:01 <Lokadin> oi
00:18:13 <Lokadin> *runs and hides in shame*
00:22:31 <Lokadin> say is there an easy way to filter say all string matter found between < and >, as well as removing the < and >
00:23:35 <Lokadin> i mean maybe make < and > as delimiters
00:23:57 <Lokadin> or move along a line
00:25:46 <Lokadin> checking characters see if it's a <, if not then add to string output, if so then go to other function. The other function checks for a >, and doesn't add to output till it sees a > at which point the first would be called
00:26:13 <Lokadin> hmmm
00:26:20 <Lokadin> seems like imperative thinking
00:26:23 <Lokadin> *sighs*
00:26:34 <Lokadin> i feel so disabled :(
00:27:29 <Lokadin> anyways it's 7:33 in the morning
00:27:33 <Lokadin> i'm going to slee
00:27:35 <Lokadin> p
00:27:41 <Lokadin> thanks for all the help!! :D
00:35:33 <Cale> oops
00:35:36 <Cale> sorry :)
01:07:05 <musasabi> Is there a reason that there is no strict hGetContents ?
01:14:52 <Cale> musasabi: not really, except that it's rare that you want to read a whole file into memory all at once, since it doesn't scale well to large files
01:15:41 <musasabi> Cale: well it is a temporary file and I would like to delete it...
01:16:09 <musasabi> I just used a readFileStrict that seqs things.
01:16:11 <flux__> you can, except that of course is not portable to non-unix?
01:16:23 <musasabi> exactly.
01:16:46 <musasabi> Things worked fine for me, but windows users were getting errors.
01:17:52 <Cale> there's a nice low-level implementation of a strict hGetContents which reads the file into a buffer all at once, but lazily converts that buffer to a string
01:18:29 <musasabi> getting that into a library would be nice.
01:25:18 <Cale> oh, it was readFile
01:25:23 <Cale> lisppaste2: url
01:25:23 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:25:53 <lisppaste2> Cale pasted "Simon Marlow's readFile'" at http://paste.lisp.org/display/16894
01:28:30 <joelk> I have a program that reads in a file, extracts 3 doubles from each line with words and read, filters out certain entries, and prints the length. It runs in constant space, but is CPU bound! Half of an Athlon X2 takes 5 minutes to process 1.8 million lines! I'll paste it in lisppaste and appreciate any comments.
01:29:10 <lisppaste2> joelk pasted "slow reader" at http://paste.lisp.org/display/16895
01:29:20 <musasabi> Cale: thanks
01:32:58 <gour> i just looked at the hardware/software specs for openrpn project (e.g. http://doc.openrpn.org/wakka/HardwareSpecifications)
01:33:23 <gour> and wonder whether some haskell compiler could be used as development platform?
01:34:57 <musasabi> gour: 1mb of RAM, would probably want to use something that conserves memory
01:36:13 <gour> musasabi: true. i was not thinking about ghc, but yhc, jhc...some are striving for a portable bytecode
01:36:44 <musasabi> yes, but at least one needs more efficient Strings.
01:37:04 <gour> isn't fps good enough?
01:37:30 <musasabi> fps is quite nice.
01:37:55 <gour> and waht about nhc98/jhc?
01:38:31 <musasabi> well nhc98 generates bytecode and jhc very small and clean C.
01:38:41 <gour> openrpn folks are thinking t owrite 1st in java then c++ :-(
01:38:48 <gour> waste of time & effort
01:40:21 <musasabi> the local rpn enthuastics have mostly talked about forth or C.
01:42:00 <gour> yep. but further development for e.g. graphic calculator could benefit even more from haskell
01:42:59 * gour would like to have replacement for his hp 15c
01:47:06 <cpatrick> @where jhc
01:47:07 <lambdabot> http://repetae.net/john/computer/jhc/
01:48:32 <cptchaos> @listcommand
01:48:32 <lambdabot> use listcommands [module|command]. Modules are:
01:48:32 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
01:48:32 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
01:48:32 <lambdabot> seen spell state system todo topic type version vixen where
01:50:30 <cptchaos> is there a function to convert an Int to its hexadecimal string representation (e.g. 255 -> "FF") ? 
01:51:11 <cptchaos> beside from Text.Printf which does not work for me, for some not understood reason
01:54:08 <Cale> @type Numeric.showHex
01:54:09 <lambdabot> forall a. (Integral a) => a -> ShowS
01:54:22 <Cale> > showHex 255 ""
01:54:23 <lambdabot> "ff"
01:54:27 <cptchaos> arg
01:54:32 <cptchaos> Cale: thanks
01:58:47 <davidhouse> is Floating a subclass of RealFrac?
02:00:31 <Lemmih> davidhouse: No.
02:00:49 <davidhouse> haskell seems to have about a thousand and one different type classes for numbers.
02:00:59 <Si\Uni> Are seperately compiled modules containing TypeReps of the same type guaranteed to have same keys in GHC?
02:01:13 <davidhouse> surely all you need is Integral, its parent RealFrac and then a generic Num? (maybe complex numbers and stuff as well)
02:01:44 <davidhouse> is there a type tree somewhere? how does stuff like Fractional fit in?
02:02:15 <int-e> davidhouse: http://haskell.org/onlinereport/basic.html#sect6.3
02:03:08 <Si\Uni> i.e. if I have a TypeRep of an Int in the main program and a dynamically link in another module via hs-plugins which also has a TypeRep of an Int, will the two test True for equality?
02:14:15 <UncleD> > let uncleRound x = 10^(floor(log(x)/log(10)))*ceiling(x/(10^(floor(log(x)/log(10))))) in take 20 [ (a,b) | a <- [1..1000], b <- [1..1000], a*b + b*b == (uncleRound $ fromIntegral $ a*b) ]
02:14:16 <lambdabot> [(7,3),(8,2),(13,2),(17,3),(17,8),(18,2),(19,1),(23,2),(27,3),(28,2),(29,
02:14:16 <lambdabot> 1),(33,2),(35,5),(38,2),(39,1),(42,8),(43,2),(44,6),(46,4),(48,2)]
02:14:27 <davidhouse> oi.
02:14:30 <davidhouse> that's my function.
02:27:29 <davidhouse> @hoogle round
02:27:30 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
02:27:30 <lambdabot> Text.Html.background :: String -> HtmlAttr
02:28:46 <davidhouse> is there a way of doing log base 10 easily?
02:28:57 <davidhouse> other than \x -> log x / log 10
02:29:01 <davidhouse> that's not accurate enough
02:29:21 <davidhouse> > floor $ log 1000/log 10
02:29:21 <lambdabot> 2
02:30:38 <davidhouse> @hoogle log
02:30:38 <lambdabot> Prelude.log :: Floating a => a -> a
02:30:38 <lambdabot> GHC.ConsoleHandler.Logoff :: ConsoleEvent
02:30:38 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
02:30:48 <davidhouse> logBase 10 1000
02:30:54 <davidhouse> > logBase 10 1000
02:30:55 <lambdabot> 2.9999999999999996
02:31:11 <davidhouse> that's obviously defined as exactly what i just did
02:38:09 <int-e> > let v=[1..9]:map(10*)v;u n=head$dropWhile(<n)v in map u [1,10,11,20,21]
02:38:09 <lambdabot>  add an instance declaration for (Num [a])
02:38:09 <lambdabot>   In the list element: 21
02:38:38 <int-e> > let v=[1..9]++map(10*)v;u n=head$dropWhile(<n)v in map u [1,10,11,20,21]
02:38:38 <lambdabot> Couldn't match `[b]' against `t -> t1'
02:39:52 <int-e> > let v=[1..9]++map(10*)v;u n=head$dropWhile(<n)v in map u [1,10,11,20,21]
02:39:53 <lambdabot> [1,10,20,20,30]
03:14:20 <shapr> dons: Ever considered SILCnet support for lambdabot?
03:20:52 <Lemmih> Wow. jhc went out of memory on my box with 1.5gigs of RAM /-:
03:22:15 <davidhouse> @index mplus
03:22:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
03:22:16 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
03:22:16 <lambdabot> Control.Monad.Error, Control.Monad.List
03:54:46 <araujo> Good morning!
03:58:06 <tromp_> good afternoon!
03:59:20 <jips> morning
04:05:45 <rep> hi
04:12:02 <davidhouse> you know what
04:12:12 <davidhouse> i think i've finally fully understood monads.
04:12:39 <shapr> yay!
04:12:53 <davidhouse> :) it is a good day.
04:18:39 <dbrock> just so I know, how do you know you've fully understood them?
04:18:42 <dons> joelk, so maybe you should use packed strings and scanf , perhaps?
04:18:54 <dons> knowing how big your data files are, i'd have started with that
04:19:23 <dons> (i.e. an ffi binding to scanf typed to read 3 ints, and then pass it your files in packed strings)
04:19:41 <davidhouse> dbrock: well, i understand what a monad is in terms of being a container, what >>= and return do, i understand the monads as computations analogy, and i completed all the exercises on http://www.nomaware.com/monads/html/exercises.html :)
04:21:20 <davidhouse> dbrock: are you asking because you don't yet understand them? because i can recommend some excellent tutorials
04:21:58 <dbrock> haha okay :-)
04:22:28 <davidhouse> in order of usefulness:
04:23:13 <davidhouse> http://en.wikibooks.org/wiki/Programming:Haskell_monads then http://www.nomaware.com/monads/html/ then the monad chapter from http://www.isi.edu/~hdaume/htut/
04:23:15 <dbrock> well, I haven't done those exercises and I'm not sure I know what the monads as computations analogy is, but I'm clear on the other two
04:23:36 <dbrock> wow, a wikibook is the most useful?
04:23:40 * dbrock is impressed
04:23:59 <davidhouse> i tried to learn from yet another haskell tutorial first time through, but it just explained everything formally and abstractly, so i didn't get most of it.
04:24:30 <davidhouse> however it does go into detail about more complicated monad stuff, so it's probably worth a read
04:26:48 <dbrock> thanks
05:31:29 <azuroth> say I've got "list :: Parse a b -> Parse a [b]" as like, zero-or-more in a regex 
05:33:10 <azuroth> ahh, it doesn't matter
05:33:27 <ski> @hoogle many
05:33:28 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
05:33:28 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser
05:33:28 <lambdabot> tok st [a]
05:33:28 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
05:37:20 <azuroth> oh, actually. basically my question is, implementing one-or-more, it seems like copy-and-pasting some of the code from list is the cleanest way. (I've implemented it neList p = (p >*> list p) `build` uncurry (:) ). does anyone have a nicer way?
05:38:02 <davidhouse> argh. every time someone says (:), it comes up as a ( then a smiley face in my irc client.
05:38:15 <azuroth> it looks like a ninja for me. weird.
05:39:07 <pharm> (:)
05:39:36 <pharm> the ninja operator. Like it.
05:40:46 <astrolabe> I don't like the sound of copy-paste.  Can't you abstract out the copied stuff?
05:40:57 <davidhouse> it sneaks betewen lists and ties them together without them realising
05:41:24 <davidhouse> *between elements of lists.
05:41:39 <davidhouse> wow, this could be made into a Poignant Guide for Haskell :)
05:43:34 <azuroth> astrolabe: thanks!
05:44:28 <astrolabe> Coo. Glad I didn't need to actually understand anything :)
05:46:11 <azuroth> is there a spaceship operator in haskell? <=> ?
05:46:49 <davidhouse> you could easily define one.
05:47:05 <Lemmih> > let (<=>) = (+) in 10 <=> 20
05:47:06 <lambdabot> 30
05:47:25 <davidhouse> well, you could do that.
05:48:55 <azuroth> I'm just wondering what other crazily named operators there are
05:49:45 <azuroth> > let (<=>) = sign.(-) in 10 <=> 20
05:49:45 <lambdabot>  Not in scope: `sign'
05:50:11 <davidhouse> signum?
05:50:13 <davidhouse> @type signm
05:50:14 <lambdabot> Not in scope: `signm'
05:50:16 <davidhouse> @type signum
05:50:17 <lambdabot> forall a. (Num a) => a -> a
05:50:56 <azuroth> > let (<=>) = signum.(-) in 10 <=> 20
05:50:56 <lambdabot>  add an instance declaration for (Num (a -> a))
05:51:10 <davidhouse> no, sorry, i got that wrong.
05:51:15 <davidhouse> signum throws away the sign
05:51:18 <azuroth> ahh
05:52:22 <davidhouse> > let sign x = if x<0 -1 else if x==0 then 0 else 1, let (<=>) = sign.(-) in 10 <=> 20
05:52:23 <lambdabot>  parse error on input `else'
05:53:09 <azuroth> well. we'll pretend for now that we have the spaceship operator _and_ the ninja operator. woo
05:54:02 <Lemmih> > let a <=> b = signum (a - b) in 10 <=> 20
05:54:03 <lambdabot> -1
05:54:31 <davidhouse> let (<=>) x y | x < y = -1 | x > y = 1 | x == y = 0 in 10 <=> 20
05:54:35 <davidhouse> > let (<=>) x y | x < y = -1 | x > y = 1 | x == y = 0 in 10 <=> 20
05:54:36 <lambdabot> -1
05:55:01 <azuroth> hmm, okay
05:55:06 <davidhouse> oh, signum does get the sign. i was wrong.
05:55:44 <davidhouse> Lemmih: then why didn't azuroth's original work?
05:55:53 <dbrock> what's the ninja operator?
05:56:02 <ski> azuroth : you should be able to define them in terms of another (mutual recursion), i think
05:56:20 <davidhouse> dbrock: (:). just because it rendered as a ninja smiley on azuroth's computer
05:56:21 <pharm> dbrock: apparently (:) is turned into a ninja in some IRC clients...
05:56:22 <ski> (azuroth : them = 'list','one_or_more')
05:56:36 <azuroth> is there a difference between signum . (-) and \a b -> signum(a - b)    ?
05:56:42 <int-e> @pl \f g a b = f (g a b)
05:56:43 <lambdabot> (line 1, column 10):
05:56:43 <lambdabot> unexpected "="
05:56:43 <lambdabot> expecting pattern or "->"
05:56:44 <dbrock> I see... :-)
05:56:51 <int-e> @pl \f g a b -> f (g a b)
05:56:51 <lambdabot> (.) . (.)
05:57:14 <azuroth> ski: yeah, I just figured that out! I was only thinking about making one-or-more from list, but didn't even think of changing list
05:57:16 <davidhouse> @pl signum $ a - b
05:57:17 <lambdabot> signum (a - b)
05:57:23 <davidhouse> hmm
05:57:24 <int-e> > let (<=>) = (.) . (.) signum (-) in 10 <=> 20
05:57:25 <lambdabot>  add an instance declaration for (Num (a -> b))
05:57:31 <Lemmih> davidhouse: "let (<=>) = signum . (-)" => "let (<=>) = \x -> signum ((-) x)"
05:57:38 <int-e> > let (<=>) = ((.) . (.)) signum (-) in 10 <=> 20
05:57:38 <lambdabot> -1
05:57:52 <davidhouse> Lemmih: oh.
05:58:22 <davidhouse> int-e: yeah, that's nice and readable ;)
05:58:33 <azuroth> ahh, so it's using it as unary minus, not binary?
05:58:52 <int-e> davidhouse: I think it's pretty, but unreadable.
05:59:13 <davidhouse> > let (<=>) x y = signum.(-) x y in 10 <=> 20
05:59:14 <lambdabot>  add an instance declaration for (Num (a -> b))
05:59:14 <lambdabot>   In the definition of `fob': fob = let <=> x y = signum . ((-) x y) in
05:59:14 <lambdabot> 10 <=> 20
05:59:14 <lambdabot>   In the definition of `v': v = let fob = let ... in ... in take 2048 (
05:59:14 <lambdabot> show fob)
05:59:24 <davidhouse> > let (<=>) x y = (signum.(-)) x y in 10 <=> 20
05:59:24 <lambdabot>  add an instance declaration for (Num (a -> a))
05:59:24 <lambdabot>   In the definition of `svh': svh = let <=> x y = (signum . (-)) x y in
05:59:24 <lambdabot> 10 <=> 20
05:59:24 <lambdabot>   In the definition of `v': v = let svh = let ... in ... in take 2048 (
05:59:24 <lambdabot> show svh)
05:59:37 <davidhouse> unary minus again?
05:59:52 <int-e> @pl \x y -> signum (x-y)
05:59:53 <lambdabot> (signum .) . (-)
06:00:22 <davidhouse> my favourite is still Lemmih's.
06:00:27 <int-e> no, still the same problem: f.g only passes one argument to g before applying f.
06:00:27 <davidhouse> or mine for absolute clarity :)
06:01:02 <int-e> > let (<=>) = ((signum .) . (-)) in 10 <=> 20
06:01:03 <lambdabot> -1
06:01:10 <azuroth> > let (<=>) = signum . subtract in 10 <=> 20
06:01:10 <lambdabot>  add an instance declaration for (Num (a -> a))
06:01:30 <davidhouse> azuroth: same problem
06:01:48 <davidhouse> it sticks the x into signum.subtract, then gets confused about the y.
06:02:02 <int-e> > let (<=>) x = signum . subtract x in 10 <=> 20
06:02:03 <lambdabot> 1
06:02:06 <davidhouse> you need to do sections with composition like int-e did you get anywhere.
06:02:36 <davidhouse> int-e, that's backwards
06:02:36 <azuroth> wahh. I'm incredibly confused.
06:02:39 <int-e> > let (<=>) x = signum . (-) x in 10 <=> 20
06:02:40 <lambdabot> -1
06:02:59 <davidhouse> > let (<=>) x = signum.(`subract`x) in 10 <=> 20
06:03:00 <lambdabot>  Not in scope: `subract'
06:03:01 <int-e> davidhouse: I noticed. I forgot what exactly subtract is doing :)
06:03:05 <davidhouse> > let (<=>) x = signum.(`subtract`x) in 10 <=> 20
06:03:06 <lambdabot> -1
06:03:29 <int-e> signum.(x-) works as well.
06:03:38 <davidhouse> yep.
06:03:50 <davidhouse> just that it could be done with subtract if you wanted :)
06:04:03 <davidhouse> int-e, you mean (-x)
06:04:12 <davidhouse> subtract infix is just the same as (-)
06:04:20 <int-e> davidhouse: no I don't. (-x) is an unary minus.
06:04:40 <azuroth> > (-)5
06:04:40 <lambdabot>  add an instance declaration for (Show (a -> a))
06:04:47 <azuroth> > -5
06:04:48 <lambdabot> -5
06:04:54 <azuroth> > subtract 5
06:04:55 <lambdabot>  add an instance declaration for (Show (a -> a))
06:04:59 <azuroth> > (subtract) 5
06:04:59 <lambdabot>  add an instance declaration for (Show (a -> a))
06:05:03 <int-e> > subtract 5 2
06:05:04 <lambdabot> -3
06:05:06 <davidhouse> azuroth: subtract takes two parameters
06:05:08 <int-e> > (-) 5 2
06:05:09 <lambdabot> 3
06:05:14 <int-e> > (-5) 2
06:05:15 <lambdabot>  add an instance declaration for (Num (t -> a))
06:05:20 <int-e> > (5-) 2
06:05:21 <lambdabot> 3
06:05:22 <davidhouse> ooh.
06:05:31 <davidhouse> > 5 `subtract` 2 == 5 - 2
06:05:32 <lambdabot> False
06:05:40 <dbrock> > zipWith (++) [[1], [2]] [[9], [8], [7]]
06:05:41 <lambdabot> [[1,9],[2,8]]
06:05:47 <davidhouse> lets just forget about subtract :)
06:06:02 <azuroth> ...:x
06:06:17 <dbrock> what can I use instead of zipWith (++) to get [[1,9],[2,8],[7]] there?
06:07:14 <davidhouse> dbrock: what would it do if there were, say, 3 more elements in the second list than in the first?
06:07:19 <davidhouse> just append them onto the end?
06:07:32 <dbrock> pretend as if the missing elements were []
06:07:46 <davidhouse> hmm
06:09:21 <davidhouse> > let zipWithNew l1 l2 = zipWith (++) (l1 : take (length l2 - l1) $ repeat []) l2 in [[1], [2]] [[9], [8], [7]]
06:09:22 <lambdabot> Couldn't match `[[a]]' against `t -> t1'
06:09:41 <davidhouse> > let zipWithNew l1 l2 = zipWith (++) (l1 ++ take (length l2 - l1) $ repeat []) l2 in [[1], [2]] [[9], [8], [7]]
06:09:42 <lambdabot> Couldn't match `[[a]]' against `t -> t1'
06:09:57 <davidhouse> > let zipWithNew l1 l2 = zipWith (++) (l1 ++ (take (length l2 - l1) $ repeat [])) l2 in [[1], [2]] [[9], [8], [7]]
06:09:58 <lambdabot> Couldn't match `[[a]]' against `t -> t1'
06:10:20 <davidhouse> > let zipWithNew l1 l2 = zipWith (++) (l1 ++ (take ((length l2) - (length l1)) $ repeat [])) l2 in [[1], [2]] [[9], [8], [7]]
06:10:20 <lambdabot> Couldn't match `[[a]]' against `t -> t1'
06:11:39 <davidhouse> duh.
06:11:44 <davidhouse> > let zipWithNew l1 l2 = zipWith (++) (l1 ++ (take ((length l2) - (length l1)) $ repeat [])) l2 in zipWithNew [[1], [2]] [[9], [8], [7]]
06:11:45 <lambdabot> [[1,9],[2,8],[7]]
06:12:04 <davidhouse> > let zipWithNew l1 l2 = zipWith (++) (l1 ++ (take ((length l2) - (length l1)) $ repeat [])) l2 in zipWithNew [[1], [2]] [[9], [8], [7], [6], [5]]
06:12:05 <lambdabot> [[1,9],[2,8],[7],[6],[5]]
06:12:08 <davidhouse> :)
06:12:19 <dbrock> haha
06:12:31 <dbrock> well okay, thanks :-)
06:13:57 <davidhouse> really that'll only work if length l1 > length l2
06:14:20 <davidhouse> but you could add guards in for the other cases
06:14:35 <davidhouse> *length l1 <= length l2
06:14:56 <tromp_> > let zipWithNew l1 l2 = zipWith (++) (l1 ++ repeat []) l2 in zipWithNew [[1], [2]] [[9], [8], [7], [6], [5]]
06:14:57 <lambdabot> [[1,9],[2,8],[7],[6],[5]]
06:15:36 <davidhouse> tromp_: nice :)
06:15:46 <davidhouse> i keep forgetting how useful infinite lists are
06:18:11 <int-e> > let zipWithDef la lb d f = map (\(a, b) -> f (maybe d id a) (maybe d id b)) $ takeWhile (\(a, b) -> isJust a || isJust b) $ zip (map Just la ++ repeat Nothing) (map Just lb ++ repeat Nothing) in zipWithDef [1,2,3] [3,4,5,6] 0 (+)
06:18:12 <lambdabot> [4,6,8,6]
06:19:43 <davidhouse> what does the maybe function do/
06:19:45 <davidhouse> *?
06:20:11 <ski> @type maybe
06:20:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:20:30 <lennart> @djinn b -> (a -> b) -> Maybe a -> b
06:20:30 <lambdabot> f a b c =
06:20:30 <lambdabot>   case c of
06:20:30 <lambdabot>   Nothing -> a
06:20:30 <lambdabot>   Just d -> b d
06:20:33 <azuroth> @hoogle a -> [a]
06:20:38 <lambdabot> Data.List.repeat :: a -> [a]
06:20:40 <lambdabot> Prelude.repeat :: a -> [a]
06:20:42 <lambdabot> Data.List.replicate :: Int -> a -> [a]
06:20:46 <tromp_> applies a function or substitutes a default result
06:20:55 <davidhouse> right.
06:20:59 * ski was just about to invoke the djinn
06:29:53 <azuroth> night, all!
06:44:44 <davidhouse> hey guys
06:44:51 <davidhouse> is it possible to string monads together?
06:45:12 <ski> see monad transformers
06:45:40 <davidhouse> i.e. i'm writing a connection function, makeRequest. I'd like to have type of URI -> Maybe (IO Response) or something
06:46:14 <ski> itym 'IO (Maybe Response)'
06:46:35 <davidhouse> oh, that could work.
07:24:58 <araujo> Hello!
07:55:19 <roconnor> @hoogle Bool -> IO ()
07:55:20 <lambdabot> System.Console.Readline.setDone :: Bool -> IO ()
07:55:20 <lambdabot> System.Console.Readline.functionDumper :: Bool -> IO ()
07:55:20 <lambdabot> System.Console.Readline.setIgnoreCompletionDuplicates :: Bool -> IO ()
07:55:38 <roconnor> @hoogle Bool -> String -> IO ()
07:55:39 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
07:55:39 <lambdabot> Prelude.putStr :: String -> IO ()
07:55:39 <lambdabot> Prelude.putStrLn :: String -> IO ()
07:55:52 <roconnor> @hoogle Bool -> IOError -> IO ()
07:55:53 <lambdabot> System.Console.Readline.setDone :: Bool -> IO ()
07:55:53 <lambdabot> System.Console.Readline.functionDumper :: Bool -> IO ()
07:55:53 <lambdabot> System.Console.Readline.setIgnoreCompletionDuplicates :: Bool -> IO ()
07:56:51 <roconnor> is there an nicer way to write: if (not $ all verifyDistrict $ concat database) then ioError (userError "Bad Database") else return ()
07:57:27 <Lokadin> lol @ hoogle
07:58:20 <Lokadin> hmmm
07:58:21 <roconnor> Sorry
07:58:24 <roconnor> @hoggle
07:58:25 <lambdabot> HOOGLE - Haskell API Search
07:58:25 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
07:58:25 <lambdabot>  
07:58:28 <vincenz> Hello evryone
07:58:32 <roconnor> I always spell it wrong
07:58:43 <roconnor> on wait
07:58:49 <roconnor> no wait, I got it write
07:58:53 <roconnor> right
07:58:58 <Lokadin> yep
07:58:59 <Lokadin> :D
07:59:10 <roconnor> My brain is dead today.
07:59:15 <Lokadin> it's all good
07:59:47 <sjanssen> @type Control.Monad.when
07:59:48 <lambdabot> forall (m :: * -> *).
07:59:48 <lambdabot>         (Monad m) =>
07:59:48 <lambdabot>         Bool -> m () -> m ()
07:59:59 <sjanssen> roconnor: that should do what you want
08:00:10 <roconnor> Yes, I knew there was something better
08:00:36 <roconnor> @hoogle Bool -> m () -> m ()
08:00:37 <lambdabot> Control.Exception.assert :: Bool -> a -> a
08:00:46 <roconnor> @hoogle Bool -> a -> a
08:00:47 <lambdabot> Control.Exception.assert :: Bool -> a -> a
08:00:47 <lambdabot> Prelude.id :: a -> a
08:00:47 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
08:01:12 <sjanssen> can you give class contexts to Hoogle?
08:01:21 <roconnor> @hoogle (Monad m) =>Bool -> m () -> m ()
08:01:22 <lambdabot> No matches, try a more general search
08:01:27 <sjanssen> @hoogle (Monad m) => a -> m a
08:01:28 <lambdabot> No matches, try a more general search
08:01:37 <roconnor> There is an opposite to when?
08:02:19 <sjanssen> roconnor: unless ?
08:02:23 <roconnor> @type Control.Monad.unless
08:02:23 <lambdabot> forall (m :: * -> *).
08:02:23 <lambdabot>         (Monad m) =>
08:02:23 <lambdabot>         Bool -> m () -> m ()
08:03:09 <sjanssen> > unless True Nothing >> return 'a'
08:03:09 <lambdabot> Just 'a'
08:03:28 <roconnor> unless (all verifyDistrict $ concat database) (ioError (userError "Bad Database"))
08:03:28 <sjanssen> > when True Nothing >> return 'a'
08:03:29 <lambdabot> Nothing
08:03:47 <roconnor> hmmm, better, but still seems a bit akward.
08:04:07 <roconnor> maybe I should use when not
08:04:35 <roconnor> when (not $ all verifyDistrict $ concat database) (ioError (userError "Bad Database"))
08:04:48 <roconnor> that reads a little nicer.
08:05:15 <sjanssen> roconnor: I think it'd be easier to read if it were split into two lines
08:05:28 <roconnor> ok
08:36:08 <ndm> just for note, hoogle is broken when searching for monads...
08:36:13 <ndm> thats on my to fix list...
08:42:28 <Lokadin> say
08:42:35 <Lokadin> if i have two related functions
08:43:04 <Lokadin> as in say i use two functions that actually require each other to execute their purpose
08:43:10 <Lokadin> how should i name them?
08:43:48 <Lokadin> cause the first calls the second, and the second calls the first
08:43:49 <Lokadin> ..
08:43:58 <Lokadin> till the end of the list
08:44:14 <Lokadin> jethr0: are you here?
08:44:27 <Lokadin> *sigh*
08:44:32 <Lokadin> i'll go make some tea
08:45:12 <Lemmih> Why would you name them something special just because they call each other?
08:46:26 <araujo> mutually recursive functions or what?
08:46:46 <jethr0> mount moin
08:46:55 <jethr0> Lokadin: ?
08:47:29 <Lokadin> well i mean cause now they are called removeTags and tagHolder
08:48:02 <Lokadin> i was just thinking if i can make them more similar, so as not to confuse them
08:48:18 <Lokadin> oi, i guess it doesn't matter
08:48:20 <jethr0> Lokadin: you called :)
08:48:24 <Lokadin> yep
08:48:24 <Lokadin> :P
08:48:30 <jethr0> what can i do for you
08:48:31 <Lokadin> was wondering if someone was awake
08:48:36 <jethr0> k
08:48:44 <Lokadin> :)
08:48:51 <jethr0> @localtime lokadin
08:48:59 <jethr0> @version
08:49:00 <lambdabot> lambdabot 3p290, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
08:49:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
08:51:06 <dbrock> type BinarySearchTree a = Ord a => BinaryTree a -- that's not permitted?
08:51:35 <jethr0> wouldn't you have to restrict it right behind "type"?
08:52:04 <dbrock> oh
08:52:25 <jethr0> i'm not sure. not even if it's possible at all :(
08:52:37 <Jammni|bounc0rn> hi, i have a smal problem with a generic list [Int|Bool...] - anybody here, who could help me?
08:52:48 <jethr0> Jammni: i can sure try
08:52:52 <Jammni> k, thx
08:52:56 <dbrock> nope, it doesn't like that either
08:52:58 <Jammni> data HetList= Nil | Cons _ (HetList)
08:52:58 <Jammni> data Zeuch =String|Int|Bool|Char|Num	
08:53:01 <davidhouse> @google String -> Char -> Maybe Int
08:53:02 <Jammni> hetlength :: HetList-> Int
08:53:02 <Jammni> hetlength Nil =0
08:53:02 <Jammni> hetlength (Cons _ x)=1+ hetlength x
08:53:02 <lambdabot> http://www.reed.edu/~carlislp/ghc6-doc/libraries/base/Prelude.html
08:53:05 <Jammni> heterogeneous :: HetList
08:53:05 <Jammni> heterogeneous = Cons 1(Cons True (Cons 'X' Nil))
08:53:06 <davidhouse> @hoogle String -> Char -> Maybe Int
08:53:07 <lambdabot> No matches, try a more general search
08:53:10 <Jammni> and that doesnt work
08:53:21 <davidhouse> @hoogle Char -> String -> Maybe Int
08:53:22 <lambdabot> No matches, try a more general search
08:53:53 <jethr0> Jammni: the "_" looks fishy to me. what's the error message?
08:54:07 <Jammni> theres an error in the first line
08:54:15 <jethr0> i think you want; "data HetList a = Nil | Cons a (HetList a)"
08:54:20 <Jammni> the error message is: \hetlist.hs":12 - Insta
08:54:20 <Jammni> nce of Num Zeuch required for definition of heterogeneous
08:54:22 <davidhouse> anyone know of a function which takes a String and a Char and returns the first occurance of that char within that string?
08:54:25 <dbrock> wouldn't you have to say  data HetList a = Nil | Cons a (HetList a)?
08:54:39 <jethr0> find
08:54:44 <Jammni> but it must be possible to use more than one type
08:54:50 <davidhouse> @type find
08:54:51 <lambdabot> Not in scope: `find'
08:54:53 <Jammni> and this works just with one datatype
08:55:13 <sjanssen> Jammni: if you want to do heterogenous lists, you can't do it like that
08:55:27 <Jammni> and how must i do it?
08:55:34 <Jammni> i have no more ideas
08:55:47 <sjanssen> Jammni: "data HCons a b = Cons a b; data Nil = Nil"
08:55:50 <jethr0> > find ('l'==) "hello world"
08:55:51 <lambdabot> Just 'l'
08:55:58 <sjanssen> @google HList
08:55:59 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
08:56:12 <ski> data HetList= Nil | Cons Zeuch HetList
08:56:22 <sjanssen> Jammni: there is a whole paper on things like this, follow the link
08:56:38 <Lemmih> Jammni: Why do you want such a list?
08:56:39 <Jammni> k, thx - first i try the new code from jethr0 and sjanssen
08:56:42 <ski> data Zeuch = S String | I Int | B Bool | C Char
08:57:01 <jethr0> Jammni: but as they say: most often when you think you need heterogenous lists, there's either a common base type or you don't really want them :)
08:57:11 <Jammni> hmm, k
08:57:30 <Jammni> can u give me the link sjanssen?
08:57:42 <Jammni> or is it the link from lambdabot?
08:57:55 <sjanssen> Jammni: from lambdabot
08:57:57 <Jammni> thx
08:58:15 <Jammni> ok, i have some tries...
08:58:33 <Jammni> and perhaps i ask u all later again - thx for your help :-)
08:58:40 <jethr0> davidhouse: or if you want the string from the letter on, try
08:58:55 <jethr0> > dropWhile ('l'/=) "hello world"
08:58:56 <lambdabot> "llo world"
08:59:01 <Lokadin> is there any set way of removing newlines?
08:59:09 <Lokadin> from a string
08:59:12 <davidhouse> > :t find
08:59:13 <lambdabot>  parse error on input `:'
08:59:14 <jethr0> @hoogle lines
08:59:14 <lambdabot> Data.List.lines :: String -> [String]
08:59:14 <lambdabot> Prelude.lines :: String -> [String]
08:59:14 <lambdabot> Graphics.Rendering.OpenGL.GL.BeginEnd.Lines :: PrimitiveMode
08:59:17 <Lokadin> filter something string
08:59:34 <jethr0> > lines "hello\nworld"
08:59:35 <lambdabot> ["hello","world"]
08:59:52 <Jammni> im trying it now with this bit of code:
08:59:52 <Jammni> data HetList= Nil | Cons Zeuch HetList
08:59:52 <Jammni> data Zeuch = S String | I Int | B Bool | C Char
09:00:08 <Jammni> but the error is still the same:
09:00:08 <Jammni> hetlist.hs":11 - Type
09:00:08 <Jammni> error in application
09:00:08 <Jammni> *** Expression     : Cons 'X' Nil
09:00:08 <Jammni> *** Term           : 'X'
09:00:08 <Jammni> *** Type           : Char
09:00:10 <Jammni> *** Does not match : Zeuch   
09:00:17 <jethr0> lisppaste2
09:00:24 <jethr0> lisppaste
09:00:26 <sjanssen> Jammni:how long have you been learning Haskell?
09:00:39 <Jammni> two years in university ;-)
09:00:40 <davidhouse> > find 'l' "Hello World"
09:00:41 <lambdabot> Couldn't match `a -> Bool' against `Char'
09:00:48 <Lemmih> Jammni: You need to write 'Cons (C 'X') Nil'
09:00:48 <davidhouse> > find "Hello World" 'l'
09:00:49 <Jammni> but i guess not eough ;-)
09:00:49 <lambdabot> Couldn't match `a -> Bool' against `[Char]'
09:00:50 <jethr0> > find ('l'==) "hello world"
09:00:51 <lambdabot> Just 'l'
09:00:56 <davidhouse> ah. right.
09:01:16 <jethr0> > let ffind c = find (c==) in ffind 'l' "hello world"
09:01:17 <lambdabot> Just 'l'
09:01:18 <davidhouse> so find :: (a -> Bool) -> [a] -> Maybe a?
09:01:28 <Jammni> @Lemmih: this i have a few lines down
09:01:28 <lambdabot> Unknown command, try @listcommands.
09:01:29 <jethr0> yup, in case it's not found
09:01:32 <araujo> Jammni, Cons 'X' ?!?
09:01:39 <SimonRC> @type find
09:01:40 <lambdabot> Not in scope: `find'
09:01:40 <sjanssen> Jammni: now, do you want to do het. lists just because you can, or because you want to use them for some other purpose?
09:01:50 <araujo> Jammni, That value should be a type of Zeuch
09:01:53 <Jammni> because i have to use
09:01:56 <araujo> Not X
09:01:59 <Lemmih> Jammni: The error message said you wrote 'Cons 'X' Nil'.
09:02:02 <SimonRC> @type ffind
09:02:02 <lambdabot> Not in scope: `ffind'
09:02:53 <Jammni> hmm, the problem is, i have to use the following code fragement (thats what my prof gave to me):
09:02:57 <Jammni> hetlength Nil =0
09:02:57 <Jammni> hetlength (Cons _ x)=1+ hetlength x
09:02:57 <Jammni> heterogeneous = Cons 1(Cons True (Cons 'X' Nil))
09:03:02 <roconnor> just use [Zeuch ]
09:03:12 <Lokadin> can i feed output back into the input variable? cause i really don't want to make a new variable every time i do an operation on it
09:03:36 <Lemmih> Jammni: That code is not valid Haskell98.
09:03:42 <roconnor> @type until
09:03:43 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
09:03:53 <Jammni> yes - and i should make this code work
09:03:57 <araujo> data Zeuch = S String | I Int | B Bool | Char
09:04:02 <araujo> Do that
09:04:12 <Jammni> k, i try it
09:04:12 <jethr0> Lokadin: what are you trying to do?
09:04:14 <araujo> data Zeuch = S String | I Int | B Bool | Char | C Char
09:04:18 <araujo> Or that last one
09:04:19 <roconnor> hetrogenous = [I 1, B True, C 'X']
09:04:20 <vincenz> jethr0: how'sit going with the AB?
09:04:34 <araujo> If you need the C data constructor
09:04:35 <Lemmih> Lokadin: Variables are immutable in Haskell.
09:04:35 <jethr0> quite well. got everything working.
09:04:38 <vincenz> :)
09:04:45 <jethr0> vincenz: i'm starting to come to grips with haskell, finally
09:04:46 <Jammni> @araujo: that doesnt work
09:04:46 <lambdabot> Unknown command, try @listcommands.
09:05:09 <Jammni> @roconnor: i have to use Cons
09:05:09 <lambdabot> Unknown command, try @listcommands.
09:05:21 <roconnor> Jammni: Why?
09:05:21 <Jammni> and thats the problem
09:05:24 <sjanssen> jammni: if you want to do hetlength, you'll need to make a class
09:05:32 <Jammni> because thats what i have to do
09:05:38 <roconnor> Jammni: says who?
09:05:44 <Jammni> my prof from university
09:05:47 <araujo> Jammni, what do you get?
09:05:49 <Jammni> just a little homework
09:06:01 <Jammni> [17:59] <Jammni> error in application
09:06:01 <Jammni> [17:59] <Jammni> *** Expression     : Cons 'X' Nil
09:06:01 <Jammni> [17:59] <Jammni> *** Term           : 'X'
09:06:01 <Jammni> [17:59] <Jammni> *** Type           : Char
09:06:01 <Jammni> [17:59] <Jammni> *** Does not match : Zeuch 
09:06:02 <Jammni> [17:59] <Jammni> error in application
09:06:04 <Jammni> [17:59] <Jammni> *** Expression     : Cons 'X' Nil
09:06:06 <Jammni> [17:59] <Jammni> *** Term           : 'X'
09:06:08 <Jammni> [17:59] <Jammni> *** Type           : Char
09:06:10 <Jammni> [17:59] <Jammni> *** Does not match : Zeuch 
09:06:10 <micty> Does haskell has function overloading?
09:06:18 <Lemmih> micty: Yes.
09:06:22 <roconnor> hetrogenous = Cons (I 1) (Cons (B True) (Cons  (C 'X') Nil))
09:06:23 <jethr0> Jammni: please use lisppaste http://paste.lisp.org/new/haskell
09:06:32 <Jammni> k - i have a look
09:06:41 <jethr0> Jammni: you want "Cons (C 'X') Nil" or sth like it
09:06:49 <vincenz> jethr0: perfect :)
09:06:56 <jethr0> and yourself?
09:06:56 <Jammni> yes jethr0
09:07:10 <vincenz> jethr0: working on my phd ... trying to orthogonalize my searchspace :
09:07:10 <Jammni> but i must not use it
09:07:54 <jethr0> vincenz: what does that involve? what search space, or is that classified?
09:08:22 <micty> Where can I find implementation of Haskell?
09:08:33 <Lemmih> @where ghc
09:08:33 <lambdabot> http://haskell.org/ghc
09:08:54 <vincenz> jethr0: popssible input programs that I need to transform
09:08:59 <Lemmih> micty: GHC == Glasgow Haskell Compiler.
09:09:04 <Lokadin> say is there an hdoc tutorial of some sort?
09:09:13 <Lokadin> as in how to use it
09:09:38 <Jammni> ok, thx to all - the program works :-)
09:10:38 <Lokadin> @hdoc
09:10:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:14:00 <Lokadin> say how do i return true?
09:14:17 <jethr0> Lokadin: in what context?
09:14:22 <Lokadin> er one sec
09:14:26 <jethr0> > True
09:14:27 <lambdabot> True
09:14:33 <Lokadin> noNewLines x =
09:14:33 <Lokadin>     if x == '\n'
09:14:33 <Lokadin>        then false
09:14:33 <Lokadin>        else true
09:14:44 <tromp_> x /= '\n'
09:14:46 <jethr0> > (False, True)
09:14:46 <lambdabot> (False,True)
09:15:19 <davidhouse> @where hid
09:15:19 <lambdabot> I know nothing about hid.
09:15:20 <davidhouse> @where hide
09:15:21 <lambdabot> http://haskell.org/haskellwiki/HIDE
09:15:32 <Lokadin> tromp_: ?
09:16:15 <tromp_> noNewLines x = (/= '\n')
09:16:21 <Lemmih> @wiki Screenshots_of_HIDE
09:16:22 <lambdabot> http://www.haskell.org/haskellwiki/Screenshots_of_HIDE
09:16:24 <tromp_> i mean  noNewLines = (/= '\n')
09:16:41 <pesco> Lokadin: The == operator is a function like any other. It returns a Bool. Thus you don't need if-then-else at all.
09:17:02 <jethr0> noNewLines = ('\n' /=)
09:17:40 <Lokadin> o
09:17:50 <Lokadin> thanks :)
09:17:59 <Lokadin> but i don't really understand how it works :(
09:18:06 <davidhouse> tromp_: surely that would have to be noNewLines = (/=) '\n', no?
09:18:12 <pesco> Lokadin: BTW, of course that's not what makes your program incorrect. The reason is that false and true are undefined. What you meant were False and True. The names are capitalized because those are constructors.
09:18:32 <jethr0> > filter (' '/=) "this is a string with whitespace"
09:18:33 <lambdabot> "thisisastringwithwhitespace"
09:18:43 <davidhouse> Lokadin: if we were to write noNewLines x = x /= '\n', would you understand?
09:18:51 <tromp_> > (/= 0) 1
09:18:52 <lambdabot> True
09:18:57 <tromp_> > (/= 0) 0
09:18:58 <lambdabot> False
09:19:29 <Lokadin> well what does /= do?
09:19:41 <jethr0> Lokadin: in C for example you can also write "noNL(char c) {return c != '\n';}"
09:19:42 <tromp_> inequality
09:19:56 <Lokadin> as in !=?
09:20:00 <tromp_> yep
09:20:04 <Lokadin> oo
09:21:30 <Lokadin> kk i get that
09:23:09 <Lokadin> say i can't seem to get it to work as my filter function
09:23:23 <Lokadin> or would i need to make the operation on the whole list then?
09:23:48 <Lokadin> cause i thought it was char by char 
09:24:31 <jethr0> Lokadin: what is it you're trying to do?
09:25:33 <Lokadin> filter noNewLines info
09:25:48 <Lokadin> well info being a string
09:26:28 <micty> What does that mean? "Haskell does not support the C++ overloading style in which functions with different types share a common name."
09:26:38 <jethr0> > filter ('\n'/=) "the\ninfo\nstring"
09:26:39 <lambdabot> "theinfostring"
09:26:54 <Lokadin> o wow thanks :)
09:27:03 <Lemmih> micty: Familiar with C++ style overloading?
09:27:05 <davidhouse> Lokadin: it's more important you know why that works though
09:27:25 <Lokadin> hmmm
09:27:36 <davidhouse> > let noNewLines x = x /= '\n' in filter noNewLines "the\ninfo\nstring"
09:27:37 <lambdabot> "theinfostring"
09:27:47 <davidhouse> do you understand that?
09:28:38 <micty> Lemmih - yes f(int i); and f(int i, int i) and f(MyType x) can coexist
09:28:50 <Lokadin> yea
09:29:01 <Lokadin> it just doesn't seem to work in my program :(
09:29:16 <Lokadin> if x != n
09:29:26 <Lokadin> \n
09:29:29 <Lokadin> otherwise true
09:29:31 <Lokadin> i get that
09:29:57 <davidhouse> do you understand what i wrote?
09:30:09 <Lokadin> yea
09:30:11 <Lokadin> i do
09:30:17 <davidhouse> okay.
09:30:26 <davidhouse> do you know about infix operators?
09:30:36 <davidhouse> i.e. doing something like (/=) x '\n'
09:30:38 <Lemmih> micty: In Haskell we achieve overloading via type-classes.
09:31:44 <Lokadin> davidhouse: yep
09:31:53 <micty> Lemmih - I have just read about type classes and the quoted sentence is from there.
09:32:11 <davidhouse> Lokadin, right, so we can write noNewLines as noNewLines = (/=) '\n' x
09:32:24 <Lokadin> yep
09:32:29 <davidhouse> which we can also write as noNewLines x = (/='\n') x
09:32:42 <Lokadin> ummm
09:32:46 <micty> but if you can't f(int x) and f(myType x) then how can you define the functions that are in the class for different types?
09:32:50 <davidhouse> that's called a section.
09:33:13 <astrolabe> I want to write a program that uses pseudo-random numbers.  At the moment, I want to use a fixed initial seed to aid with development, but later I might want to use the system RNG to get my seed, and that lives in IO.  How should I do it?
09:33:18 <davidhouse> Lokadin: say you wanted to write a function to double numbers. you could just write timesTwo = (*2).
09:33:37 <Lokadin> o oka
09:33:38 <Lokadin> y
09:33:41 <Lokadin> i get it now :)
09:33:43 <Lemmih> micty: Right. Let's look at, say, the Eq type-class (it provides the (==) function): class Eq a where (==) :: a -> a -> Bool
09:33:46 <Lokadin> thanks
09:34:09 <Lokadin> , bah time flies, i have to go
09:34:15 <ski> > 'a' == 'b'
09:34:16 <lambdabot> False
09:34:21 <Lokadin> thanks a lot for all the help you guys :D
09:34:24 <ski> > 12 == 3*4
09:34:25 <lambdabot> True
09:34:30 <ski> > 12 == 'x'
09:34:30 <lambdabot>  add an instance declaration for (Num Char)
09:34:34 <ski> er
09:34:37 <davidhouse> Lokadin: so then we can do something called eta-reduction and get noNewLines = (/='\n'), and then there's little point actually having a seperate function
09:34:44 <ski> > False == 'x'
09:34:45 <lambdabot> Couldn't match `Bool' against `Char'
09:34:57 <Lemmih> micty: Now we can declare types to be instances of that type-class: instance Eq Bool where True == True = True; False == False == True; _ == _ = False
09:35:06 <jethr0> astrolabe: have you worked with IO before?
09:35:20 <ski> micty : overloaded function have to be defined in a type class
09:35:45 <ski> (micty : of course one can also define functions with same name in different scopes, like in different modules .. but that's another thing)
09:35:56 <Lokadin> davidhouse: kk' that's pretyy cool
09:36:15 <davidhouse> Lokadin: you'll probably come across it soon if you're using a textbook
09:37:25 <Lokadin> well i'm using YAHT
09:37:43 <Lokadin> kk well i'm gone' already late
09:40:54 <micty> Well, I have got to go. Thanks for the help, and don't forget to feed the fish while I am gone ;)
09:42:59 <astrolabe> Is there a standard monadic wrapper for random number generators?
09:43:10 <astrolabe> or for a rng?
09:44:54 <jethr0> @hoogle randomR
09:44:54 <lambdabot> System.Random.randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:44:54 <lambdabot> System.Random.randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
09:44:54 <lambdabot> System.Random.randomRIO :: Random a => (a, a) -> IO a
09:45:30 <jethr0> astrolabe: you only have to pass the rng along. maybe in a state monad?
09:45:50 <astrolabe> Yeah.
09:45:59 <jethr0> but maybe there's a nicer way
09:48:02 <Lemmih> Greetings SyntaxNinja.
09:50:17 <SyntaxNinja> hiyea Lemmih
10:30:13 * joelr1 waves
10:30:21 <joelr1> does anyone have a ACM subscription?
10:54:31 <ndm> joelr1: most people who do have one through their university
10:54:41 <tibbe> if I define a class like so:
10:54:43 <tibbe> class Typeable a where
10:54:43 <tibbe>     infer :: a -> Infer Type
10:54:48 <joelr1> ndm: hmm, ok
10:54:58 <tibbe> can I then make Show work on the type a?
10:59:38 <tibbe> anyone?
10:59:46 <tibbe> I wanna say something like: if Show a => instance Show (Typeable a)
11:02:19 <xerox_> tibbe: class (Show a) => Typeable a where
11:02:39 <xerox_> It constraints the possible 'a's to Show-able ones.
11:03:05 <tibbe> ah, thanks
11:03:16 <tibbe> I couldn't figure out the correct syntax
11:04:04 <xerox_> You could search in the Haskell report for things like this.
11:04:06 <xerox_> @where report
11:04:07 <lambdabot> I know nothing about report.
11:04:14 <xerox_> @google Haskell report
11:04:15 <lambdabot> http://www.haskell.org/onlinereport/
11:04:43 <tibbe> thanks
11:04:56 <tibbe> I'm having some problems with monads + type classes
11:05:06 <xerox_> What problems?
11:05:41 <tibbe> i have a function, infer :: Exp -> m Type and one, infer :: Def -> m Type and I thought I use a type class for infer
11:05:50 <tibbe> but show stops working
11:06:10 <tibbe> it worked when I ran the monad previously but not when I typeclass the code
11:06:49 <tibbe> what's the name of the online code paste thingy?
11:06:56 <tibbe> @google code paste thingy
11:06:58 <lambdabot> http://selectsmart.com/FREE/resultsgraphics.php?poll=thingy
11:09:39 <xerox_> @paste
11:09:39 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:09:44 <xerox_> lisppaste2: url
11:09:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:10:38 <lisppaste2> tibbe pasted "Type Inference Monad" at http://paste.lisp.org/display/16904
11:11:29 <xerox_> How is "Infer Type" define?
11:11:33 <xerox_> defined, even
11:11:50 <tibbe> type Infer = RWST Context [Const] [Id] Maybe
11:12:00 <xerox_> Oh, sorry I gotta run, be back later.
11:12:04 <tibbe> okay
11:21:12 <lisppaste2> tibbe annotated #16904 with "Type Inference Monad" at http://paste.lisp.org/display/16904#1
11:29:12 <ezraburgh> does anyone here understand Oleg's "dependent types" thing?
11:29:43 <ezraburgh> http://okmij.org/ftp/Haskell/eliminating-array-bound-check.lhs
11:37:32 <icbt> is ghc-6-4-branch available from darcs too?
11:38:01 <Igloo> No
11:38:22 <icbt> i am getting that pam error when i tries to cvs login
11:38:36 <Igloo> "that pam error"?
11:40:13 <icbt> cvs [login aborted]: unrecognized auth response from cvs.haskell.org: pam failed to release authenticator
11:41:13 <Igloo> Works for me
11:42:14 <icbt> did you try wiping the entry in .cvspass and cvs -d :pserver:anoncvs@cvs.haskell.org:/cvs login ?
11:42:46 <Igloo> I followed the instructions in the docs
11:42:51 <Igloo> In a new directory
11:43:26 <icbt> you have write access?
11:43:49 <Igloo> to what?
11:44:02 <icbt> cvs repo
11:44:07 <Igloo> anoncvs doesn't have write access to it
11:45:07 <icbt> you are right, that's the only thing running on pserver
11:46:20 <icbt> ahh, the password is "cvs"!
11:50:17 <musasabi> Where is the streams io library by Bulat available for download?
12:08:59 <lispy> musasabi: searching my email archive now
12:10:51 <lispy> musasabi: http://freearc.narod.ru/Streams.tar.gz
12:11:03 <lispy> musasabi: http://haskell.org/haskellwiki/Library/Streams
12:12:11 <musasabi> thanks
12:12:19 <lispy> np
12:32:58 <tibbe> if I have a monad with plus and zero (like Maybe) and I want to get back zero if one of [m] is zero, what do I do?
12:38:19 <Taral> tibbe: Define a different operation.
12:38:27 <Taral> 0+x = x
12:38:37 <Taral> you want an operation *, where 0*m = 0
12:39:52 <xerox_> > sequence [Just 1, Nothing, Just 2]
12:39:52 <lambdabot> Nothing
12:40:30 <xerox_> > sequence [return 1, mzero, return 2] :: [Int]
12:40:31 <lambdabot> Couldn't match `Int' against `[a]'
12:40:37 <xerox_> > sequence [return 1, mzero, return 2] :: [a]
12:40:38 <lambdabot>  [a]
12:40:38 <lambdabot>   Inferred type: [[a1]]
12:40:38 <lambdabot>   In the application `sequence [return 1, mzero, return 2]'
12:40:41 <xerox_> Whatever.
12:41:09 <Taral> xerox: The operation * is >>= in the Maybe monad, but not generally.
12:41:20 <Taral> er >>
12:52:06 <Saulzar> It's taking your values to be of the list monad
12:52:37 <Taral> @type sequence [return 1, mzero, return 2]
12:52:38 <lambdabot> Not in scope: `mzero'
12:52:43 <Taral> @type sequence [return 1, Data.Monad.mzero, return 2]
12:52:44 <lambdabot> Couldn't find qualified module.
12:52:44 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
12:52:44 <lambdabot> \\)?
12:52:51 <Taral> @type sequence [return 1, Control.Monad.mzero, return 2]
12:52:52 <lambdabot> forall (m :: *
12:52:52 <lambdabot>                        -> *)
12:52:52 <lambdabot>                      a.
12:52:52 <lambdabot>                   (Control.Monad.MonadPlus m, Num a) =>
12:52:52 <lambdabot>                   m [a]
12:53:02 <Taral> wow, there's a big
12:53:04 <Taral> *bug
12:53:42 <Taral> @type sequence
12:53:43 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:53:43 <xerox_> ??
12:53:48 <Taral> oh, that's why
12:53:58 <Taral> sequence returns a list
12:54:15 <Taral> > sequence [Just 1, Just 2]
12:54:16 <lambdabot> Just [1,2]
12:55:46 <Saulzar> Ah
12:57:30 <ezraburgh> > sequence [Just 1, Nothing]
12:57:31 <lambdabot> Nothing
12:57:41 <ezraburgh> > sequence [Nothing, Just 1]
12:57:44 <lambdabot> Nothing
12:59:10 <ihope> I was going to make a programming language. Then I realized that there's nothing wrong with Haskell.
12:59:28 <zamez> Nothing
12:59:31 <sieni_> well, there is, but not that much
12:59:58 <ihope> @djinn DisadvantageToUsingHaskell
12:59:59 <lambdabot> -- f cannot be realized.
13:00:46 <sieni_> standard ml is nice for practical projects, because of strict evaluation
13:01:45 <ihope> I guess I can admit that Haskell is very good at the "non-practical" stuff.
13:02:51 <Philippa> Haskell could seriously use structural subtyping on records
13:03:11 <Philippa> (and perhaps the equivalent trick on sums, too)
13:04:26 <sieni_> ihope: I mean stuff like: try to figure out why something is not as efficient as it should and the reason turns out to be lots of thunkety thunk in the background
13:04:50 <ihope> Ah... I see.
13:05:15 <xerox_> G'night.
13:10:11 <musasabi> I think error handling is one of the weak sides of Haskell.
13:10:40 <musasabi> exceptions lurking deep inside lazy structures etc
13:13:16 <ihope> Just don't make errors.
13:13:28 <ihope> Erm... you were talking about something else.
13:13:57 <musasabi> ihope: things like pattern match failures produce errors.
13:14:14 <ihope> Error monad?
13:14:19 <musasabi> and "write perfect code" is not really useful
13:14:34 <musasabi> ihope: does not help.
13:15:20 <jethr0> musasabi: the compiler knows about partial pattern matches. so it could easily display/warn about them
13:15:37 <jethr0> but that obviously doesn't solve the general problem
13:15:45 <musasabi> jethr0: pattern guards
13:16:11 <jethr0> i guess using functions like "head" and "isJust" carelessly is a major factor
13:16:30 <musasabi> ihope: the basic thing goes like this 1) there is pure code that is evaluated lazily, 2) the pure code will have a pattern match or some other error, 3) on a higher level we have Control.Exception.catch, 4) that does not handle the error because it is in the not-yet evaluated thunk, 5) the error is fired somewhere where it should not occur.
13:16:54 <ihope> Ah.
13:17:00 <ihope> And why couldn't you seq it?
13:17:10 <ihope> Or... something?
13:17:32 <musasabi> ihope: well one would need DeepSeq for arbitary datatypes.
13:17:34 <Saulzar> Are we talking about "expected errors"? Seems to me there's a clear difference... catching unexpected errors seems fairly unimportant, after all it's a bug
13:18:03 <musasabi> ihope: except that DeepSeq does not work with cyclic structures.
13:18:41 <ihope> Saulzar: I don't think it's so much expected as simply deemed possible.
13:18:53 <ihope> musasabi: cyclic?
13:19:03 <Saulzar> Haskell does well in cutting down on those unexpected errors, though clearly it's hard to eliminate them all without hurting some convenience
13:19:37 <ndm> jethr0: to solve the problem of head and fromJust, you can use http://www-users.cs.york.ac.uk/~ndm/projects/catch.php
13:19:58 * wli offers code to those hunting for stuff to dump into libraries.
13:20:40 <ihope> Is there a function like either and maybe that works on lists?
13:20:45 <Philippa> ihope: if you deepSeq an infinite structure, its evaluation will never terminate
13:20:55 <Saulzar> ihope, well there are expected errors - eg. IO errors and exceptions which you throw on purpose, and there's unexpected errors/bugs
13:21:08 <musasabi> Saulzar: and catching all those in one place "was this pure computation successfulland produced a value" is not really possible to check.
13:21:11 <ihope> Philippa: Ah. I see.
13:22:01 <ihope> list :: [a] -> b -> (a -> [a] -> b) -> b
13:25:02 <jyp> ndm: your paper looks like really cool stuff
13:25:32 <ndm> jyp: i have a new version of the paper, and a tool based on it which is heading towards general release
13:25:54 * jyp can't wait to see it working :)
13:26:12 <ndm> although, to be fair and offer appropriate disclaimers, its "sweet spot" seems about 2 A4 pages of code at the moment - more than that and it can start to have difficulties in some situations
13:26:38 <Saulzar> musasabi, Hm, I see what you mean with reguards to infinite structures. What can be done though? Seems the only real solution is to use structures with a notion of failure ...
13:27:58 <musasabi> Saulzar: a compiler could provide a deepSeq that would work on arbitary structures.
13:28:09 <Saulzar> That would be nice :)
13:28:12 <musasabi> *arbitrary
13:29:20 <wli> doh
13:29:34 <wli> looks like Mechveliani beat me to the punch on Groebner bases.
13:30:39 <jethr0> btw, how is lazy evaluation implemented in ghc? is it done using coroutines or completely optimized away?
13:31:57 <wli> jethr0: It uses an execution model called the Spineless Tagless G-Machine, a.k.a. STG Machine. It is essentially a calling convention.
13:32:37 <jethr0> i'm just wondering how much of the "call-tree" is available at runtime for debug purposes on fail.
13:33:22 <jethr0> but i guess native compiled languages don't have the luxury of dealing with call-trees at runtime anyways
13:33:23 <wli> jethr0: it's a full-fledged graph as implemented... there are analogues of a stack (2-3 of them depending on if you go by contiguity or break it up by purpose)
13:33:45 <wli> jethr0: oh, you can traverse it
13:34:13 <sieni_> damn, I need a printer
13:34:15 <wli> anyway
13:34:49 <jethr0> i mean "pattern-match failure of head at: head [] <= someFunc a b <= otherFunc <= root"
13:35:30 <davidhouse> @type (<=)
13:35:31 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:35:38 <Taral> jethr0: None of the "call stack" is really available.
13:35:40 <edwinb> you can persuade the run time system to give you a stack trace but it's not always that useful
13:35:42 <jethr0> davidhouse: that was pseudocode :)
13:35:43 <wli> you'd have to write architecture-dependent graph mapping code
13:35:47 <davidhouse> jethr0: ;)
13:36:08 <jethr0> hmm
13:36:08 <Taral> jethr0: You can set up SCC's with profiling, or use a source-to-source transformer (hat?)
13:36:27 <wli> "the spine" is probably the closest you'll get to a backtrace but it's probably too counterintuitive to be useful
13:36:32 <jethr0> yup. but hat won't install on my debian system and i'm too lazy to compile it from source
13:36:51 <jethr0> is it worthwhile or does it rather add more obscurity?
13:37:02 <Taral> It might be worthwhile if you have a very subtle error
13:38:10 <jethr0> what i absolutely hate is tracking down space leaks using manual SCCs in "where" clauses. that's definitely sth i'd hope for "hat" to alleviate
13:38:27 <Taral> hat doesn't help with heap problems
13:38:39 <wli> You'd have to understand more about how lazy evaluation is done than is likely required to fix your problem.
13:38:40 <jethr0> some of the name demangling in profiling mode is horrible
13:39:20 <jethr0> all those more-or-less-anonymous thunks *brr*
13:39:40 <Taral> The price you pay for laziness.
13:40:11 <ndm> Taral, there was some work done to make Hat work with space problems
13:40:21 <ndm> not sure it ever got finished, but a design was done on how to use it
13:40:32 <jethr0> why can't those damn spam filters figure out that mails from last year are pretty likely spam *grr*
13:41:29 <jethr0> i had 10 mails from 1970 in my inbox when i perchance happened to look at its bottom :)
13:43:26 <ihope> 1970?
13:43:41 <jethr0> stupid forged sent date
13:43:43 <ihope> Was there even electricity back then?
13:44:00 <ihope> Ah.
13:44:03 <jethr0> ihope: i take it you're younger than 36
13:44:09 <ihope> Correct.
13:44:57 <jethr0> yup, must have been some pretty avantguardistic spammer to pitch v14gr4 over some weird pre-darpa network
13:50:36 <icbt> is there a document that describes the evolution of ghc?
13:58:08 <davidhouse> in ghci, is there a way to string let statements together?
13:58:17 <davidhouse> assuming i want it all in one command
13:58:30 <davidhouse> so let x = a, y = b in c x y or something
13:58:37 <ihope> Braces.
13:58:46 <ihope> let {foo = bar, baz = qux} in quux
13:58:49 <davidhouse> thanks
13:59:06 <flux__> not ;?
13:59:19 <ihope> Oh, right...
14:00:17 <ihope> > let foo = bar; baz = qux in quux
14:00:18 <lambdabot>  Not in scope: `quux'
14:01:15 <davidhouse> do you not need the braces?
14:01:26 <ihope> Try it...
14:01:30 <davidhouse> > let a = 5; b = 6 in a + b
14:01:31 <jethr0> > let a = 1; b = 2 in a + b
14:01:31 <lambdabot> 11
14:01:32 <lambdabot> 3
14:01:39 <jethr0> ^_^
14:01:51 <jethr0> independent emerging behavious
14:01:52 <jethr0> r
14:02:06 <ihope> > let 6 * 9 = 42 in (6*9, 9*6)
14:02:07 <lambdabot>  Non-exhaustive patterns in function *
14:02:11 <jethr0> although my choice of integer is easier to justify :)
14:02:16 <ihope> Aww.
14:02:23 <jethr0> > let n-1 = 2 in n
14:02:23 <lambdabot>  Not in scope: `n'
14:02:28 <jethr0> > let n - 1 = 2 in n
14:02:29 <lambdabot>  Not in scope: `n'
14:02:35 <ihope> :-)
14:02:50 <ihope> You're defining the (-) function.
14:03:07 <jethr0> let f (n+1) = n in f 2
14:03:10 <jethr0> > let f (n+1) = n in f 2
14:03:11 <lambdabot> 1
14:04:44 <ihope> > let n - 1 = 2 in n - 1
14:04:44 <lambdabot>  Not in scope: `n'
14:04:48 <ihope> > let n - 1 = 2 in 3 - 1
14:04:49 <lambdabot> 2
14:04:51 <ihope> Erm.
14:04:54 <ihope> > let n - 1 = 2 in 5 - 1
14:04:55 <lambdabot> 2
14:05:02 <ihope> > let n - 1 = 2 in 4 - 0
14:05:03 <jethr0> erm
14:05:03 <lambdabot>  Non-exhaustive patterns in function -
14:05:08 <ihope> ;-)
14:05:45 <jethr0> huh, ghci parses that differently than i do, it seems
14:06:04 <jethr0> how is 5-1 == 2?
14:06:14 <ihope> You're redefining the (-) function, so that anything - 1 is 2.
14:06:21 <jethr0> ah, stupid me
14:07:54 <davidhouse> > let a = 1; b = 2; c = 3 in a + b + c
14:07:55 <lambdabot> 6
14:07:57 <davidhouse> hmm
14:13:08 <ihope> Time for a whatchamacallit.
14:13:17 <ihope> An... well...
14:13:20 <ihope> One of these:
14:14:41 <davidhouse> @type rand
14:14:42 <lambdabot> Not in scope: `rand'
14:15:29 <Taral> let n+(-1) = 2 in n
14:15:32 <Taral> > let n+(-1) = 2 in n
14:15:32 <lambdabot>  Not in scope: `n'
14:15:40 <davidhouse> > random
14:15:40 <Taral> heh, they only work for function args?
14:15:41 <lambdabot>  add an instance declaration for (Show (g -> (a, g)))
14:15:52 <Taral> no random for you!
14:15:59 <davidhouse> > newStdGen >>= random
14:16:00 <lambdabot> Couldn't match `IO' against `(,) a'
14:16:01 <Taral> @type random
14:16:02 <lambdabot> Not in scope: `random'
14:17:03 <davidhouse> > random $ mkStdGen 10
14:17:03 <lambdabot> Add a type signature
14:17:22 <davidhouse> > fst $ random $ mkStdGen 10
14:17:23 <lambdabot> Add a type signature
14:17:55 <davidhouse> i don't think it's got Random loaded
14:17:57 <davidhouse> works on my ghci
14:18:08 <Taral> > mkStdGen
14:18:08 <lambdabot>  add an instance declaration for (Show (Int -> StdGen))
14:18:10 <Taral> > mkStdGen 10
14:18:11 <lambdabot> 11 1
14:18:22 <Taral> > (random $ mkStdGen 10) :: Integer
14:18:23 <lambdabot> Couldn't match `Integer' against `(a, StdGen)'
14:18:28 <Taral> > (random $ mkStdGen 10) :: (Int, StdGen)
14:18:29 <lambdabot> (-1258130923,432453652 1655838864)
14:18:38 <davidhouse> ah.
14:18:41 <Taral> > (fst . random . mkStdGen $ 10) :: Int
14:18:42 <lambdabot> -1258130923
14:18:45 <Taral> > (fst . random . mkStdGen $ 42) :: Int
14:18:46 <lambdabot> -1673289139
14:18:49 <davidhouse> how do i create a random number in a given range?
14:18:55 <Taral> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
14:19:11 <Taral> > fst . randomR (1,8) . mkStdGen $ 42
14:19:12 <lambdabot> 8
14:19:15 <Taral> > fst . randomR (1,8) . mkStdGen $ 8
14:19:16 <lambdabot> 4
14:19:20 <Taral> > fst . randomR (1,8) . mkStdGen $ 223489274
14:19:21 <lambdabot> 4
14:19:23 <Taral> > fst . randomR (1,8) . mkStdGen $ 223489273
14:19:24 <lambdabot> 6
14:19:25 <sieni_> > let 2 * 2 = 5 in 2 * 2 + 5
14:19:26 <lambdabot> 10
14:19:29 <sieni_> hih
14:20:27 <davidhouse> > do { gen <- newStdGen; printStrLn $ randomR (1,8) gen }
14:20:28 <lambdabot>  Not in scope: `printStrLn'
14:21:08 <davidhouse> oops :)
14:23:20 <Taral> no IO
14:23:53 <davidhouse> no, it's putStrLn ;)
14:24:46 <davidhouse> > newStdGen >>= (putStrLn.show.fst.randomR (-1,1)) -- does what i want
14:24:47 <lambdabot> No IO allowed
14:24:57 <Taral> I have got to get off the haskell-cafe list
14:25:00 <davidhouse> ah. well it works on my system, i guess.
14:28:36 <Cale> If you're in the IO monad, you can just use randomRIO
15:19:25 <ihope> One of those.
15:20:55 * Beelsebob eats some more amoxicillin
15:28:36 <ihope> @index (<|>)
15:28:37 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
15:28:47 <ihope> Hmm.
15:28:51 <ihope> What's it do?
15:28:56 <davidhouse> ihope, one of what?
15:29:45 <ihope> <ihope> Time for a whatchamacallit.
15:29:50 <ihope> <ihope> An... well...
15:29:56 <ihope> <ihope> One of these:
15:30:09 <ihope> (log off, one hour gap, log on)
15:30:46 <davidhouse> yeah, i saw that
15:30:53 <davidhouse> i was wondering what you had one of.
15:32:00 <ihope> A log off, one hour gap, log on.
15:32:12 <wilx> Ha!
15:32:22 <wilx> It looks like mIRC has finally gotten UTF-8!
15:32:31 <Cale> wilx: wow :)
15:32:38 <wilx> Yeah.
15:32:55 <wilx> Installing...
15:34:56 <Cale> I wonder what's next? Maybe a non-brain-damaged scripting system. Eventually, it may even be as usable as X-Chat!
15:35:32 <Cale> :)
15:35:52 <resiak> Will it ever stop being used by script kiddies?
15:35:58 <wilx> Heh.
15:35:59 <wilx> Man.
15:36:02 <wilx> You are so wrong.
15:36:12 <wilx> mIRC is the only usable IRC client of all.
15:36:25 <gzl> ew.
15:36:30 <Cale> why?
15:36:35 <lennart> mIRC?  new-fangled nonsense!  what's wrong with ircII? :)
15:36:41 <edwinb> irssi is lovely :)
15:36:46 <ihope> What's wrong with...
15:36:47 <wilx> Because it is the only client that really works for me :)
15:36:47 <gzl> yeah, irssi.
15:36:57 <resiak> ircII? Bah, in my day we used telnet, etc
15:36:57 <wilx> Let me see...
15:37:04 <edwinb> if I could persuade xchat to work in a screen session, maybe...
15:37:11 <wilx> ???
15:37:13 <wilx> Bah.
15:37:19 <Cale> edwinb: well, you can use the text-mode version of x-chat
15:37:21 <wilx> It doesn't seem to work well.
15:37:24 <edwinb> there is one?
15:37:25 <ihope> What's wrong with copy/cat/whatever?
15:37:26 <Cale> yeah
15:37:35 <edwinb> I bet it's no better than irssi ;)
15:37:42 <Cale> edwinb: you're right
15:37:55 <Cale> It's actually perhaps a little worse, since I don't think many people use it
15:37:56 <edwinb> but it's interesting to know it exists
15:37:57 <davidhouse> so IORef is a state monad for IO?
15:38:00 <lennart> well, go ahead and laugh, but i use ircII :)
15:38:18 <edwinb> If it works for you ;)
15:38:25 * ihope goes ahead and laughs
15:38:27 <lennart> well, it's not great
15:38:47 <Cale> davidhouse: an (IORef a) is a mutable cell which carries a value of type a and can be created, read, and modified, in the IO monad.
15:39:11 <Cale> It's not too much like the State monad, in that you still have to pass the references around.
15:39:19 <davidhouse> okay.
15:39:37 <Cale> (So (StateT s IO) is still a useful monad sometimes)
15:40:30 <Cale> In fact, (ReaderT (IORef a) IO) can be quite handy too.
15:40:30 <wilx> 
15:40:41 <wilx> What do you see?
15:40:44 <jips> should i install gtk2hs 0.9.10 or darcs?
15:40:44 <lennart> a?Ya?-ea? ?
15:40:53 <Cale> 
15:41:14 <ihope> @type [True]
15:41:14 <lambdabot> [Bool]
15:41:25 <edwinb> W\^
15:41:33 <ihope> Oh noes!
15:41:41 <davidhouse> 
15:41:50 <lennart> #%@*&#%#*@%#*@
15:42:01 <Saulzar> jips, Newer stuff, eg. GL is only in darcs
15:42:30 <Cale> lennart: It's UTF-8 encoding. You can probably get it to work by using a terminal capable of UTF-8 (unless irssi just mangles it, I'm not sure)
15:43:15 <jips> Saulzar: GL sounds cool, i'll get darcs then. thanks
15:43:15 <ihope> > ['\128'..'\143']
15:43:16 <lambdabot> "\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143"
15:43:47 <jips> what does ./configure --with-hcflags=-O0 mean?
15:43:51 <lennart> well, if i used irssi i might get it :)  (And yes, I know it's UTF-8)
15:44:06 <Cale> oh, what are you using?
15:44:10 <davidhouse> @type if
15:44:11 <lambdabot> parse error (possibly incorrect indentation)
15:44:13 <edwinb> I use irssi and it doesn't work...
15:44:14 <lennart> ircII
15:44:17 <davidhouse> @type (if)
15:44:18 <lambdabot> parse error on input `)'
15:44:22 <Cale> oh, right, you mentioned
15:44:23 <davidhouse> maybe not then.
15:44:28 <edwinb> I've never really been enthusiastic enough to see weird characters to bother fixing it though
15:44:31 <Cale> well, it should still work :)
15:44:38 <lennart> i've considered upgrading to something
15:44:42 <ihope> @pl \x y z -> if x then y else z
15:44:42 <lambdabot> if'
15:44:44 <edwinb> I suspect it's the terminal rather than irssi in my case
15:44:47 <Cale> If you have a terminal which is capable
15:44:48 <ihope> @index if'
15:44:48 <lambdabot> bzzt
15:44:56 <Cale> gnome's terminal is good for that
15:45:12 <lennart> bah, gnome
15:45:37 <Cale> (you just set the character encoding to UTF-8 via the menu)
15:45:42 <edwinb> I couldn't get gnome-terminal to work, but I am using a Mac.
15:46:04 <Cale> Oh, I'd expect it to work in the OS X terminal.
15:46:21 <edwinb> yeah, but I'm using xterm, rather than the OS X terminal
15:46:24 <Cale> ah
15:46:27 <Cale> okay :)
15:46:38 <edwinb> (why? I can't remember, but I'm used to it now...)
15:46:46 <Cale> I also used iTerm a whole lot on OS X
15:47:02 <Saulzar> Wow, it does some fun things if you set encoding to utf16 when it isn't
15:47:08 <Cale> heh
15:47:23 <Cale> yeah, UTF-16 is incompatible with basically everything else
15:52:43 <jips> checking for happy... no
15:52:45 <jips> configure: error: Could not find happy which is needed to build c2hs.
15:53:00 <jips> must i install happy before compiling darcs gtk2hs?
15:53:31 <Saulzar> happy and alex, must be for the c2hs stuff.
15:53:46 <vincenz> nyone know an easy way to do
15:53:57 <vincenz> file1 -> filen+1, file2->filen+2...
15:54:07 <jips> how come happy doesn't come together with ghc?
15:54:34 <Cale> vincenz: in which language?
15:54:36 <vincenz> jips: or alex for that matter
15:54:39 <vincenz> Cale: err...files
15:54:43 <vincenz> Cale: I want to copy some files
15:54:54 <vincenz> Cale: they're called example1.cpp... example.6cpp
15:55:02 <vincenz> I want copies so I get 7-12
15:56:24 <Cale> for i in `seq 1 6`; do cp file$i file$((i + 6)); done
15:56:34 <vincenz> ah
15:56:34 <vincenz> thx
15:57:13 <jethr0_> gotta love bash :)
15:58:30 <vincenz> we need a hash
15:58:33 <vincenz> hashell shell
15:58:43 <jethr0_> already exists
15:58:46 <vincenz> o.O
15:58:56 <vincenz> oh right, ghci
15:59:04 <jethr0_> http://nellardo.com/lang/haskell/hash/
15:59:54 <jethr0_> you even got the name right
16:00:08 <jips> yonks! you are right vincenz alex is also needed!
16:01:14 <jethr0_> vincenz: sry, wrong page. but a haskell shell _does_ exist
16:01:24 <araujo> @where hashell
16:01:25 <lambdabot> haskell.org/hashell
16:01:33 <araujo> suggestions, comments welcome :-)
16:01:52 * araujo shuold probably commit those new changes
16:04:24 <JKnecht> @verson
16:04:25 <lambdabot> lambdabot 3p290, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
16:04:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
16:05:20 <Saulzar> Heh, that one is 1999
16:06:59 <ihope> Hmm? When's Haskell from?
16:07:34 <ihope> aroujo: what, no cryptographic hash library?
16:07:35 <ihope> Aww.
16:07:59 <Cale> ihope: the first version of Haskell was defined in 1990
16:08:20 <araujo> ihope, ?
16:08:20 <Cale> But Haskell is quite similar to Miranda
16:08:33 <ihope> Hmm... I suppose it's reasonable to assume that Haskell 98 was defined in 1998.
16:08:42 <Cale> Which is from 1985-86
16:09:04 <Cale> well, more like 1999, iirc.
16:09:43 <Cale> The current report is dated 2002 :)
16:10:12 <Cale> Haskell 98 was published January 1999
16:10:31 <Cale> oh, and then revised Jan 2003
16:13:37 <Cale> http://www.haskell.org/haskell-history.html
16:13:52 <Saulzar> araujo, The ability to use let x ... in ghci is really nice, maybe could use it for parts of the environment - I guess that's somewhat hard with plugins
16:14:26 <araujo> Saulzar, why?
16:14:56 <palomer> hrm
16:15:04 <palomer> every paper should have an irc channel
16:15:59 <ihope> > map fromEnum "You have no chance to survive make your time."
16:16:00 <lambdabot> [89,111,117,32,104,97,118,101,32,110,111,32,99,104,97,110,99,101,32,116,
16:16:00 <lambdabot> 111,32,115,117,114,118,105,118,101,32,109,97,107,101,32,121,111,117,114,
16:16:00 <lambdabot> 32,116,105,109,101,46]
16:16:01 <Saulzar> araujo, Well, how would you implement that? Given expressions can have any type...
16:16:55 * palomer just figured out how to do type inference with GADTs
16:17:01 <palomer> the implementation is going to be pretty hard though:/
16:17:29 <lennart> palomer: i doubt you can do GADT type inference in general
16:17:39 <palomer> lennart: you can, but it's intractable
16:17:46 <palomer> according to the stratified types paper
16:17:59 <palomer> in fact, I've developed an algorithm to do it in general
16:18:22 <palomer> unfortunetly it's slow and can't be changed to give  good error messages
16:18:23 <lennart> I need to read more than the abstract of that paper
16:19:07 <palomer> lennart: I, unfortunetly, don't understand the meat of the paper
16:19:13 <palomer> which is how they use "shape inference"
16:19:33 <palomer> because they don't seem to be using shapes, or they don't seem to define shapes correctly
16:20:29 <lennart> so are there principal types for GADTs?
16:20:38 <palomer> nope
16:20:48 <palomer> consider this function:
16:21:11 <lennart> then i'm not sure i'd like type inference.
16:21:40 <palomer> data Term::*->* = IntLit:: :int -> Term int ; BoolLit :: bool -> Term bool
16:22:20 <palomer> (\x y -> case x of IntLit x -> x+y | _ -> True)
16:22:29 <palomer> that function could have type:
16:22:46 <palomer> Term alpha -> int -> alpha
16:22:56 <palomer> or Term alpha -> alpha -> alpha
16:23:07 <palomer> oh, wait ,the second one would be the principle type
16:23:22 <lennart> but the former is an instance of the latter
16:23:30 <lennart> ah, int
16:23:32 <lennart> ok
16:23:37 <palomer> one sec
16:23:59 <palomer> f x y = case x of
16:23:59 <palomer> Lit i -> i + y
16:23:59 <palomer> other -> 0
16:24:14 <lennart> i have some very vague recollections of this from 15 years ago when i tried doing type inference for GADTs
16:24:31 <araujo> Saulzar, well, i use some kind of type constraint for shell expressions
16:25:05 <araujo> Saulzar, strings, strings+newline, non-strings and non-strings+newline
16:25:07 <palomer> f::term a -> a -> int 
16:25:27 <araujo> Saulzar, that's actually a concer for showing data to the user
16:25:34 <araujo> concern*
16:25:38 <ihope_> Um.
16:25:39 <palomer> and f::Term a -> int -> int
16:25:42 <araujo> nothing more
16:25:47 <palomer> lennart: what were your conclusions?
16:26:14 <lennart> inconclusive.  that if it were possible it was more trouble than it was worth
16:26:26 <araujo> Saulzar, so, for example, i can type things like:
16:26:29 <araujo> \ hashell
16:26:29 <araujo> > :p let f = 2 * 2 in let x = 9 in read (-date +%Y-) * x * f
16:26:29 <araujo> 72216
16:26:30 <lambdabot>  parse error on input `:'
16:26:43 <palomer> lennart: but several papers have been recently released which show the use of GADTs
16:26:52 <palomer> s/use/usefulness
16:26:56 <lennart> oh, I had no doubt of the use
16:27:03 <araujo> Saulzar, And :p just resolve the type problem and data representation for the user at once
16:27:03 <lennart> just that type inference was too hard
16:27:21 <lennart> I had some of the same examples :)
16:27:30 <ihope_> Hmm...
16:27:53 <ihope_> Now that could get interesting.
16:28:13 <palomer> lennart: why not just do type inference one branch at a time, ignoring branches which are impossible?
16:28:18 <palomer> lennart: seems simple enough
16:28:33 <araujo> Ive got some ideas that might problem get it working smoother, but so far it works that way for now
16:28:49 <lennart> well, why not just do type checking?  that's not too hard
16:29:37 <palomer> lennart: what do you mean?
16:29:46 <lennart> but in the early 90s it was not yet socially acceptable to require type signatures for some functions
16:30:16 <palomer> oh, mandatory function annotations
16:30:34 <palomer> but really, ignoring branches shouldn't be that much of a problem
16:30:41 <ihope_> >:-)
16:30:42 <Saulzar> araujo, Ahh, I think maybe we're not on the same wavelength. I was talking about setting haskell environment variables, eg. let foo = 3  and use it later in the same session       
16:31:04 <araujo> Saulzar, aaah, yeah, that's on my TODO :-)
16:31:35 <araujo> It wouldn't be difficult to get some scripting support either
16:31:42 <palomer> but, but then you get some pretty weird types
16:31:59 <lennart> palomer: how could you ignore some branches?  that sounds wrong
16:32:19 <palomer> lennart: consider this:
16:32:49 <palomer> Pair:: Term a -> Term b -> Term (a,b)
16:33:10 <palomer> fromLit x = (case x of IntLit y -> y)
16:33:14 <ihope_> > '\0xF0'
16:33:14 <lambdabot>  lexical error in string/character literal
16:33:49 <palomer> \x -> let a = fromLit x in case x of Pair c d -> True
16:34:10 <palomer> the let forces a to be of type Term Int
16:34:19 <palomer> so the first case branch is ignored
16:34:23 <palomer> and you get type:
16:34:30 <palomer> Term int -> alpha
16:34:45 <lennart> palomer: looks like a has type Int
16:34:58 <palomer> err, forces x to be of type Term int
16:35:30 <palomer> if you want that function to actually do something useful you would do: \x -> let a = fromLit x in case x of Pair c d -> error "foo"; IntLit _ => a
16:35:40 <vincenz> who uses vim, who uses emacs?
16:35:49 <palomer> which would have type Term int -> int
16:36:37 <Cale> vincenz: I use both of them
16:36:40 <lennart> palomer: yeah, i agree that there can be unreachable branches.  but in general you can't ignore branches just because they are "too difficult"
16:36:51 <palomer> lennart: nono, you ignore impossible branches
16:36:56 <palomer> and you do type inference as usual
16:37:00 <palomer> making sure to normalize your types
16:37:02 <vincenz> Cale: what do you prefer?
16:37:26 <lennart> palomer: but anyway, without principal types I don't want type inference
16:38:08 <Cale> vincenz: Usually vim for small things, since it's faster to load. For larger things, I might use emacs.
16:38:30 <vincenz> I see
16:38:45 <palomer> lennart: yeah, you get weirdness like: the inferable type of f is forall a.b, but f::(b[t/a]) can't be infered
16:38:46 * araujo agree with Cale 
16:38:50 <Cale> The Haskell mode in emacs is a little nicer (though I have to use simple indenting, or I'd go insane :)
16:39:36 <araujo> I also use vim for quickly glancing over files.....
16:39:41 <jips> i use only vim
16:39:55 <palomer> rather, it can't be checked
16:40:23 <palomer> lennart: I've developed a way to get all possible easily expressible types and present them to the user for him to choose
16:40:24 <araujo> But though sometimes emacs indenting gets annoying, i feel it more confortable for editing big files
16:40:31 <ihope_> @pl (\x -> (.x.))
16:40:32 <lambdabot> (line 1, column 9):
16:40:32 <lambdabot> unexpected "."
16:40:32 <lambdabot> expecting lambda abstraction or expression
16:40:44 <lennart> palomer: and if there are no principal types it might infer a type i did not intend at which is not compatible with a later use
16:40:46 * araujo wants hIDE though
16:41:51 <palomer> lennart: right, you'd force the user to pick one of the possible inferable types
16:43:01 <lennart> but in general I'm a great GADT fan :)
16:43:38 <palomer> not?
16:44:09 <lennart> "not?" ?
16:44:27 <palomer> you're a great fan?
16:45:07 <lennart> yes, I'm a great GADT fan.  just not of type inference for GADTs
16:45:57 <palomer> oh, righto
16:46:02 <palomer> so how do you think it should be done?
16:46:35 <palomer> require type annotations to all functions which do not have a principle type?
16:46:56 <palomer> err, to all bindings, rather
16:47:19 <lennart> yes
16:47:50 <palomer> any other caveats?
16:49:02 <lennart> well, i think the criterion for requiring a type annotation must be more syntactix than "not having a principal type".  that's too hard to know.
16:50:00 <palomer> for example?
16:50:31 <lennart> like saying "if you pattern match on a GADT you need a type signature"
16:50:57 <palomer> yeah, that's fair
16:51:12 <lennart> you need simple rules for people to follow :)
16:51:38 <palomer> but then the type checking is still going to be quite hard
16:52:08 <lennart> yeah, i guess it can be
16:52:50 <palomer> lennart: would you force the user to completely specify the type?
16:52:56 <lennart> i like GADTs; it's the road to depedent types ;)
16:53:44 <lennart> palomer: oh, i have no strong opinions if the type should be completly specified or not
16:54:22 <palomer> do you think we should allow impossible branches?
16:54:39 <palomer> actually, we have no choice
16:55:50 <palomer> actually, no, we have a choice
16:56:07 <palomer> I've been debating this question all day
16:56:22 <lennart> i see no reason to deviate from Haskell.  we can allow impossible branches and warn if we detect them
16:56:41 <palomer> you can have impossible branches in haskell?
16:56:46 <vincenz> man
16:56:47 <palomer> oh, in the current GADT implementation
16:56:51 <vincenz> unix tools are so weak
16:57:15 <lennart> let f 1 = 5; f 1 = error "we can never get here"
16:57:16 <dons> that's their strength
16:57:17 <palomer> 6.4 or 6.5?
16:57:44 <palomer> lennart: yeah, but that's not about static analysis!
16:58:01 <lennart> sure it is
16:58:10 <lennart> just not type checking
16:58:19 <palomer> oh, too true
17:03:33 <palomer> if we let the type only be partially specified, then users will start getting lazy and writing f::(exists x.x) everywhere
17:03:38 <palomer> s/writing/write
17:04:55 <palomer> and then you're stuck with the same problem you started out with
17:06:07 <ihope_> > (: (:))
17:06:08 <lambdabot> Couldn't match `[a]' against `t -> t1'
17:12:39 <araujo> I AM TUROOOK
17:12:42 <araujo> :-]
17:13:14 <Philippa> palomer: not really. You insist types be "sufficiently" specified
17:13:22 <Philippa> that is, you know how the GADT type constructor's applied
17:13:38 <palomer> Philippa: what do you mean?
17:13:49 <Philippa> also, specifying exists x.x means you get an utterly useless type you can't do anything with
17:14:07 <Philippa> (except feed it into id or a few semantically "interesting" functions)
17:14:16 <palomer> how can the user determine how much he needs to annotate his type by?
17:14:26 <Philippa> palomer: foo :: (GADT var -> _), for example
17:14:32 <Philippa> we know how the GADT's applied...
17:14:50 <palomer> oh, so he must specify all GADT variables
17:14:58 <Philippa> (GADT being some type constructor of kind * -> * with constructors that make non-trivial use of GADTs)
17:15:12 <palomer> could he write (exists a. Term a -> a) ?
17:15:14 <Philippa> the fact it's a variable and not a type constructor, yeah
17:15:42 <Philippa> good question. Ask it to someone who's thought through GADTs in the presence of existential quantifiers :-)
17:15:56 <Philippa> (my gut instinct is 'no')
17:15:57 <palomer> how else would you specify the GADT variables?
17:16:20 <Philippa> (either it's a universally quantified variable or it's a type constructor)
17:17:07 <palomer> a type constructor? got an example?
17:17:11 <Philippa> Term Int
17:17:35 <Philippa> really I mean "fully applied type constructor". Something of kind * that isn't a type variable.
17:17:40 <palomer> ahh, gotcha
17:18:13 <palomer> so this means you can't instantiate any of the gadted variables
17:18:36 <palomer> yeah, this seems like a good solution, why hasn't anyone proposed it?
17:18:49 <Philippa> it seems implicit in the original paper to me
17:18:55 <palomer> the wobbly paper?
17:18:57 <Philippa> (although not the re-release)
17:19:38 <palomer> wobbly types seems to be a method of normalizing the types according to the context
17:20:47 <palomer> Philippa: have you read the re-release?
17:21:07 <Philippa> yes
17:21:20 <Philippa> the re-release has far more restrictive rules for what counts as rigid
17:21:56 <Philippa> and I'd want to do some thinking about rigidity and partial type annotations, but my gut instinct is they mean you can't use the re-release's rules
17:22:38 <Philippa> (the whole point with partial type annotations being that you 'get' the inferred type, hence them not just being an existential)
17:23:30 <palomer> so rigid types are types are gadt tyvars which are in the binding types, right?
17:23:47 <Philippa> rigid types are "types that came from annotations"
17:24:23 <Philippa> the point being that we tell the refinement system what type it's refining /from/
17:24:33 <Philippa> so we're not left trying to unify them
17:24:55 <palomer> hrm, I'd better study this paper meticulously before we start talking about it
17:25:03 * palomer sacrifies his friday night to peyton-jones
17:25:25 <Philippa> study both papers
17:25:36 <palomer> which one is more insightful?
17:25:53 <Philippa> IMO the re-release is more insightful because it manages to use a simpler structure for the same ends
17:26:06 <palomer> so the re-release first and the wobbly second
17:26:11 <palomer> did you also read the stratified paper?
17:26:21 <Philippa> "simple unification-based..."
17:26:32 <Philippa> don't think so - title/URL?
17:27:03 <palomer> http://cristal.inria.fr/~fpottier/publis/pottier-regis-gianas-05.pdf
17:28:48 <Philippa> mmm, must read that sometime
17:28:52 <Philippa> 'sgetting late here though
17:29:02 <palomer> they claim to simplify the re-release
17:29:52 <Philippa> from the abstract I can believe that
17:30:02 <Philippa> do they cover at least the same source language as the re-release?
17:31:31 <palomer> nope
17:31:43 <palomer> I think they have more types
17:31:48 <palomer> (existentials)
17:32:05 <Philippa> to rephrase: do they cover all the cases that the re-release does?
17:33:10 <palomer> ahhh, I'll have to study the re-release better
17:33:35 <Philippa> I asked at least, not at most ;-)
17:34:06 <palomer> http://cristal.inria.fr/~regisgia/talks/popl06/popl06-stratified-inference.pdf <---a slideshow summarizing their work
17:34:32 <Philippa> thanks
17:34:37 <palomer> I wish I understood shapes and how they use them, but the literature is scarce and they're not consistent with their definitions
17:34:42 <Philippa> in the re-release, rigid types may not contain wobbly types
17:35:02 <Philippa> I guess that'd rule out GADT _ as a useful annotation
17:35:08 <Philippa> but probably not too much else
17:35:24 <Philippa> (but that depends what other type variables GADT has, I guess)
17:35:44 <Philippa> *ick*
17:35:48 <Philippa> just thought of a case where that matters
17:36:00 <Philippa> StateMonad _ result
17:36:37 <palomer> I'm off to study the re-release (and then the wobbly)
17:36:39 <palomer> bbl
17:37:52 <Philippa> 'k
17:38:11 <Philippa> (from part way through the slides, it looks like the stratified paper does something I've been wanting for a while)
18:12:22 <jips> what is GHC.Exception and is it different from Control.Exception?
18:14:32 <dons> it's the GHC foundatoin for Control.Exception. you should use Control.Exception as it is a portable interface.
18:17:11 <jips> hm... how can i stop it from being imported?
18:17:36 <dons> stop GHC.Exception being imported?
18:17:37 <jethr0_> yeah, 2-layer neural networks with 4 one-line functions :)
18:17:48 <ihope_> jethr0_: ?
18:18:13 <jethr0_> just finished writing it
18:18:16 <vincenz> hmm
18:18:18 <vincenz> category theory is hard
18:18:27 <jethr0_> vincenz: can be
18:18:35 <vincenz> I always get stuck on excercises
18:18:55 <araujo> Anybody would know why getProcessExitCode aborts when used with the ProcessHandle returned by runIteractiveCommand?
18:19:09 <araujo> It works fine with the one returned by runCommand.... so i don't get it.
18:19:16 <jips> dons: when i don't import Control.Exception then i get "Not in scope: `throwIO'", but if i import it then i get ambiguous between Control.Exception and GHC.Exception
18:19:29 <jethr0_> vincenz: this is so cool. i just trained my neural net to recognize (synthetic) LCD digits
18:20:17 <jethr0_> jips: weird, quick fix it with "hiding" or "qualified" :)
18:21:13 <vincenz> :)
18:21:17 <jips> jethr0_: you mean import GHC.Exception with hiding?
18:22:09 <Cale> araujo: aborts in what way?
18:22:09 <dons> why is GHC.Exceptionn imported? do you import yourself?
18:22:40 <jips> dons: no
18:23:25 <dons> import qualified Control.Exception as C, and then use C.throwIO
18:24:01 <araujo> Cale, getProcessExitCode: interrupted (Interrupted system call)
18:24:07 <araujo> Not a funny error
18:24:16 <jips> i guess that works. ideal would be to use straight throwIO though :\
18:24:23 <vincenz> here is the question i'm stuck with
18:24:30 <vincenz> assume two domains: C = circle, D=disk
18:24:32 <Cale> araujo: odd
18:24:37 <vincenz> assume inclusion map j : C -> D
18:24:44 <Cale> araujo: that's possibly a bug
18:24:52 <vincenz> and two continuous endomaps f,g : D -> D where g.j=j
18:25:06 <vincenz> prove: thereexists x s.t. f(x) = g(x)
18:25:13 <araujo> Cale, i think i should write a small code snippet and send it to the GHC ml
18:25:36 * araujo will do that
18:25:47 <Cale> vincenz: that's a topology question, really :)
18:26:35 <Cale> f and g both fix the circle?
18:26:39 <Cale> or just g?
18:27:05 <palomer> http://www.rafb.net/paste/results/so0p9898.html
18:27:16 <palomer> why won't that compile?
18:27:54 <ihope_> Type variable scope...
18:27:55 <ihope_> Weird.
18:28:05 <vincenz> Cale: they're both continuous on the disc
18:28:21 <vincenz> and only g.j=j
18:28:38 <vincenz> use brouwer's retraction theorem to prove the provable
18:28:49 <ihope_> Would removing the type declaration fix the problem?
18:28:51 <vincenz> exists x. s.t. f(x)=g(x)
18:29:26 <vincenz> oh, so the entire circle is a fixed point for g... right :)
18:29:42 <Cale> yeah, that's what g . j = j says :)
18:29:54 <vincenz> but f(x) could have a completely different fixedppoint!
18:30:11 <Cale> sure, but neither function needs to have a fixed point
18:30:17 <vincenz> they're continuous
18:30:21 <vincenz> that implies a fixedpoint
18:30:28 <vincenz> afaik
18:30:39 <Cale> right, but the property we're looking at is something else
18:30:50 <palomer> ihope_: yup
18:31:05 <Cale> f(x) = g(x) doesn't imply that x is a fixed point of either.
18:31:05 <palomer> ihope_: but I'm trying to understand why the type annotations screw everything up
18:31:11 <vincenz> hmm
18:31:17 <vincenz> so why use the retraction theorem of brouwer
18:31:45 <ihope_> palomer: type scoping, I think. The type of xcons changes.
18:32:56 <palomer> how would I scope?
18:33:44 <Cale> well, let's assume for a moment that g is invertible. Then we'd be looking for fixed points of g^(-1) . f
18:34:16 <vincenz> right
18:34:18 <ihope_> palomer: you don't?
18:34:23 <vincenz> wait.... 
18:34:25 <vincenz> g.j = j
18:34:26 <palomer> ihope_: what exactly should I do?
18:34:34 <vincenz> and j is just id but then onto a different domain
18:34:40 <vincenz> doesn't this mean that g = retraction for j
18:34:41 <ihope_> I'd suggest just commenting out the type annotation.
18:34:52 <ihope_> It'll still be there, but it won't mess anything up.
18:35:47 <Cale> one minute, brb
18:35:52 <vincenz> Cale: right, I see where you're going
18:35:55 <palomer> ihope_: yeah, but I'm trying to understand how the haskell type system works, ie why it's rejected
18:36:04 <palomer> ihope_: the program itself is uninteresting
18:36:53 <ihope_> Well, it looks to me that xcons doesn't have type [a] -> [a] because it won't work for all a, just the ones that are passed into the function.
18:37:33 <ihope_> I have no idea what this _7 stuff is.
18:38:45 <ihope_> Maybe it's compiler-specific...
18:39:16 <palomer> but...
18:39:25 <palomer> it shouldn't want to generalize variables which are still in the context
18:39:38 <palomer> in this case, x is still in the context
18:40:14 <ihope_> But the are still in different scopes.
18:41:02 <ihope_> s/the/the types/
18:41:36 <palomer> the type of xcons is valid only inside a context which has the type of x
18:41:51 <palomer> so I don't quite understand what you're saying
18:42:26 <ihope_> Well, is there a way to put the type annotation of xcons in that context?
18:43:50 <palomer> in the context of x?
18:44:12 <ihope_> As you said, inside a context which has the type of x.
18:44:22 <palomer> well, I mean, if you're not going to generalize the a, then it's going to be x: a |- xcons: a -> a
18:44:33 <palomer> which is fine
18:45:46 <ihope_> Is that Haskell syntax?
18:46:22 <palomer> er no, that's a typing judgement
18:46:44 <palomer> (it's the best way to express ideas about contexts, imho)
18:49:23 <ihope_> Well, I'm not familiar with it.
18:49:24 <palomer> maybe if I understood exactly what haskell does, I could understand why it doesn't compile
18:49:38 <palomer> ihope_: xcons has type a->a given x has type a
18:49:46 <ihope_> Ah, I see.
18:50:09 <ihope_> I guess somebody could stick that into Haskell...
18:50:31 <palomer> actually, that's not a bad idea
18:51:03 <ihope_> Could we stick that in the same place as classes?
18:51:16 <palomer> I don't see why not
18:51:19 <ihope_> E.g. (Num a, x: a) => a
18:51:24 <palomer> oh, erm
18:51:41 <palomer> well, type classes really do resemble typing judgements
18:51:43 <palomer> in many ways
18:52:40 <jethr0_>  anyone have an idea why apache won't show my README files in directory showing mode?
18:52:58 <mwc> is it on some exclusion list?
18:53:16 <vincenz> Cale: ok so far I got
18:53:37 <vincenz> g^-1*f has fixed point if g^-1 exists, and g^-1*f is continuous
18:53:55 <vincenz> I fail to see the use of g*j=j
18:54:10 <jethr0_> mwc: not that i know of
18:54:12 <Cale> vincenz: basically, if we knew that g was a homeomorphism, we could do it
18:54:23 <vincenz> not there yet
18:54:26 <Cale> perhaps that's too strong
18:54:28 <vincenz> it's just maps, and brouwer's theory
18:54:44 <palomer> Cale: any idea why my code doesn't compile?
18:54:50 <Cale> a homeomorphism is a continuously invertible continuous map
18:54:59 <vincenz> ah
18:55:01 <Cale> palomer: which code?
18:55:03 <palomer> ahh, go on with your explanation
18:55:07 <palomer> ill ask later
18:55:09 <jethr0_> mwc: yes it is. weird, i was sure i had looked in the apache config. sry
18:55:29 <Cale> (well, I'm working this out as I go... I'm not completely sure of how to do this yet :)
18:55:51 <vincenz> the second question completely stuns me because it seem to go against the just explained theorem
18:56:20 <Cale> what version of Brouwer's theorem do you have? I'm not sure I've seen a categorical generalisation before
18:56:56 <vincenz> Let D be a closed Disk, , and f a continouus endomap for D
18:57:00 <vincenz> then D has a fixed point
18:57:23 <Cale> oh, okay
18:57:28 <Cale> that's just the usual one then
18:57:38 <vincenz> err...f has a fixed point
18:57:44 <Cale> f, right
18:57:47 <mwc> What's in endomap? injective map onto a subset of the domain?
18:57:54 <Cale> a map from D -> D
18:57:55 <mwc> *what is an
18:57:56 <mwc> ah
18:57:59 <vincenz> so
18:58:01 <vincenz> f,g continous
18:58:02 <Cale> endomorphism is the usual term
18:58:03 <mwc> so an automorphism?
18:58:05 <vincenz> g.j=j
18:58:07 <mwc> or less strict
18:58:08 <mwc> I see now
18:58:13 <vincenz> so we know that they both have a fixed point
18:58:16 <vincenz> f and g that is
18:58:20 <vincenz> at least one that is
18:58:24 <Cale> it doesn't have to be an isomorphism
18:58:26 <vincenz> for g it's obvious, it's the circle, at least
18:58:55 <Cale> well, g has lots of fixed points, it might have more
18:58:59 <vincenz> right
18:59:02 <vincenz> at least the circle
18:59:59 <vincenz> f.g.j=f.j
19:00:19 <jethr0_> vincenz: i've added all kinds of stuff to my http repo directory. in case you're interested
19:00:22 <Cale> hmm
19:00:24 <vincenz> jethr0_: cool
19:00:49 <vincenz> that we get from g rule
19:01:38 <Cale> right
19:01:48 <vincenz> jethr0_: no remote changes to pull in, different repo?
19:01:55 <vincenz> so I take it I should go from there
19:02:01 <jethr0_> totally different repos
19:02:23 <jethr0_> it's all work in progress. just telling you coz' you asked earlier :)
19:02:30 <vincenz> jethr0_: what repo is it?
19:02:48 <jethr0_> same url
19:02:54 <vincenz> Cale: well we can do the simple way
19:03:01 <vincenz> assume f has fixed point on circle
19:03:06 <vincenz> assume f has no fixed point on circle
19:03:08 <vincenz> case 1 is trivial
19:03:31 <Cale> sure, so we can assume that f's only fixed points occur in the interior of the disc
19:03:58 <vincenz> case 1, there is some x such that f.x=x....in circle and we know that g.j=j for the circle
19:04:03 <vincenz> on circle even
19:04:13 <vincenz> so we take that x, and voila
19:04:48 <vincenz> case2...
19:05:03 <vincenz> then the rule g.j=j seems to be useless
19:05:40 <vincenz> it says to use the fixed point rule
19:05:44 <vincenz> without specialcasing g=1D
19:05:45 <vincenz> so I take it
19:05:48 <vincenz> g.f
19:06:07 <vincenz> err
19:06:08 <vincenz> nm
19:07:19 <palomer> http://www.rafb.net/paste/results/so0p9898.html <--this is the code that I'm wondering doesn't compile, if anyone is interested
19:08:01 <vincenz> palomer: remove the assertion for xcons
19:08:05 <Cale> palomer: xcons isn't that polymorphic
19:08:16 <vincenz> what Cale said
19:08:22 <Cale> you gave it the type forall a. [a] -> [a], but it's not
19:08:29 <jethr0_> palomer: that's one nasty problem
19:08:48 <jethr0_> palomer: what happens without type annotations?
19:09:12 <palomer> Cale: haskell automatically universally quantifies all annotations?
19:09:17 <Cale> palomer: yep
19:09:19 <palomer> jethr0_: it works
19:09:26 <jethr0_> Cale: why not?
19:09:26 <palomer> Cale: except ghc, right?
19:09:41 <palomer> Cale: which universally quantifies only the syntactically topmost occurrence
19:09:47 <Cale> palomer: if you want scoped type variables in GHC, you have to annotate the parameters of your function
19:10:02 <palomer> or, rather, doesn't quantify anything at all
19:10:15 <palomer> this is hugs
19:10:19 <palomer> this should compile with ghc
19:10:19 <Cale> GHC universally quantifies everything too
19:10:45 <palomer> even with the extentions?
19:10:49 <palomer> extensions
19:10:55 <Cale> ghc gives
19:11:29 <Cale> Inferred type is less polymorphic than expected:  Quantified type variable `a' is mentioned in the environment
19:11:37 <palomer> so what exactly are lexically scoped variables?
19:11:38 <Cale> blah, blah
19:11:42 <palomer> variables which cannot be refined?
19:12:11 <palomer> and are only generalized at the topmost occurrence?
19:12:45 <Cale> Well, there are lots of type variables which you don't (normally) have access to in type signatures
19:13:21 <Cale> scoped type variables let you name some of them
19:13:34 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
19:14:43 <Cale> GHC automatically universally quantifies any type variables that aren't in scope
19:14:56 <Cale> and bringing type variables into scope is an extension
19:15:05 <Cale> (H98 has no such notion)
19:15:26 <palomer> can you give me an example of bringing type variables into scope? (I don't exactly know what that means)
19:15:49 <Cale> there are lots on that link
19:16:01 <palomer> #
19:16:01 <palomer> The pattern (x::a) brings the type variable a into scope, as well as the term variable x. The pattern (y::(a,b)) contains an occurrence of the already-in-scope type variable a, and brings into scope the type variable b.
19:16:12 <palomer> variable a into what scope?
19:16:19 <palomer> the scope of the body?
19:16:23 <Cale> the scope of the function definition yeah
19:16:50 <palomer> so a won't be universally quantified?
19:17:30 <Cale> It could still be
19:17:35 <Cale> in the end
19:17:51 <Cale> let's use your example
19:18:42 <palomer> http://www.rafb.net/paste/results/8uYnn270.html <--btw, this compiles (oddly enough)
19:18:55 <Cale> http://www.rafb.net/paste/results/fHWMy350.html
19:19:56 <Cale> yeah, explicit quantification does that
19:20:03 <palomer> yeah, you changed the a to b in the second annotation
19:20:10 <Cale> just to make it clear
19:20:14 <palomer> that still doesn't compile
19:20:18 <Cale> hm?
19:20:22 <Cale> does for me
19:20:31 <Cale> you need -fglasgow-exts of course
19:21:12 <palomer> oh, you changed something else also
19:21:21 <palomer> so you bring the b into scope, in your terminology
19:21:36 <palomer> and since it's in scope, it won't be generalized
19:21:38 <Cale> right
19:21:44 <Cale> er
19:21:47 <Cale> yeah
19:22:00 <Cale> it's not forall'd in the xcons type declaration
19:22:15 <palomer> so that's what lexical scoping does
19:22:20 <palomer> it brings type variables into scope
19:22:24 <palomer> (informally)
19:22:53 <Cale> yeah
19:22:58 <palomer> but, get this, in the original code the a was in scope, no?
19:23:19 <Cale> not in the sense used here
19:23:30 <Cale> it would be possible to make that happen
19:23:43 <Cale> perhaps even desirable, but that's not what H98 does.
19:23:54 <palomer> so there are two ways to annotate something, either lexically or universally
19:24:07 <Cale> yeah
19:24:11 <Cale> well
19:24:14 <palomer> why not just make everything lexical?
19:24:34 <Cale> you can also just add a  forall a.  to the front of your type signature too.
19:24:51 <Cale> They decided that explicitly quantified type variables are brought into scope
19:25:16 <palomer> intuitively I would expect the forall to NOT lexically scope and all non quantified variables to be lexically scoped
19:25:17 <palomer> don't you agree?
19:26:02 <palomer> (it seems they did the opposite of what one would expect)
19:26:04 <Cale> Well, I'd like it if they'd just stick to one way or the other
19:26:28 <palomer> ie f::forall a. a -> b is the same as f::forall c. c -> b
19:26:33 <palomer> currently, this isn't the case
19:26:38 <Cale> I wouldn't mind it if all type variables were brought into scope in the function body.
19:26:52 <palomer> Cale: you'd lose alpha-equality between type annotations
19:27:05 <Cale> to some extent, yeah
19:27:13 * SamB is trying to "T" everything now instead of "X"-ing it
19:27:17 <Cale> not if you make the replacement in the body as well
19:27:36 <Cale> SamB: what?
19:27:54 <SamB> I just stopped playing The Gostak
19:28:01 <Cale> ah
19:28:04 <Cale> :)
19:28:23 <Cale> that's an awesome game
19:28:30 <SamB> it is
19:28:33 <palomer> besides, using lexical scoping only on unquantified variables makes the implementation very simple
19:28:54 <SamB> though I might like one of that type with easier puzzles...
19:29:16 <Cale> palomer: if you're going to use lexical scoping at all you'll lose alpha-equivalence, won't you?
19:29:27 <SamB> maybe its just a little too intense for me, I dunno.
19:29:31 <palomer> Cale: how so?
19:29:46 <palomer> Cale: you wouldn't bring universally quantified variables into scope, of course
19:30:00 <Cale> palomer: well, that's what you're doing here anyway
19:30:12 <palomer> it doesn't make sense to bring them into scope, really
19:30:17 <Cale> in every case, the scoped variables are universally quantified
19:31:35 <palomer> f (a::b) = a <--b is certainly not universally scoped in this expression
19:31:41 <Cale> You only lose alpha-equivalence locally. If you globally replace the type variable throughout the function declaration, it's fine.
19:31:43 <palomer> err, universally quantified
19:31:53 <Cale> yes it is.
19:32:06 <palomer>  oh, wait, you're right, one sec
19:32:18 <palomer> f (a::b) = a + 2
19:32:25 <palomer> either way, a is not of type forall b .b
19:32:53 <palomer> the way I see it is that if a term has variables which are not in the context, haskell will universally quantify them at the binding sites
19:34:54 <Cale> Well, okay, b will equal a's type, whatever that is.
19:35:07 <palomer> yeah
19:35:14 <Cale> so that annotation doesn't provide any universal quantification
19:35:26 <palomer> you could write f (a :: b) = a + 2
19:35:27 <Cale> but if it remains a variable, it'll still get forall'd
19:35:29 <palomer> you could write f (a :: forall b.b) = a + 2
19:36:13 <palomer> f (a::b) = a <--f will be polymorphic iff b is not present in f's context
19:36:24 <palomer> else it will be of type b -> b
19:38:17 <Cale> sure
19:39:46 <palomer> f:: b-> b ; f a = a is the same as (f::b->b) a = a to me
19:40:04 <palomer> again, the same thing can be said about f
19:40:22 <palomer> however, (f::forall b. b->b) a = a will always have type forall b. b->b
19:40:50 <palomer> anyways, you keep alpha conversion and lexically scoped variables with my method
19:41:02 <palomer> with a very clear linguistic interpretation of type annotations
19:42:03 <palomer> anyways, have you read the simple unification-based type inference for GADTs paper?
19:42:23 <vincenz> blegh
19:42:27 <vincenz> time to go play a bit of america's army
19:42:29 <vincenz> jethr0_: ping
19:42:36 <jethr0_> pong
19:42:44 <vincenz> jethr0_: which repo is it? genetic or neural?
19:43:06 <jethr0_> for what?
19:43:15 <vincenz> what you're working on
19:43:28 <jethr0_> i'm working on alphabeta, genetic AND neural :)))
19:43:36 <vincenz> both??
19:43:57 <vincenz> I'll take a look sometime
19:44:02 <vincenz> but now I'm gonna chill and play some shooting
19:44:03 <vincenz> :)
19:44:04 <vincenz> bbye!
19:44:10 * vincenz reboots to windows
19:44:11 <jethr0_> there's nothing like some good old multitasking. but right now i'm concentrating on "neural".
19:44:14 <jethr0_> by
19:44:18 <vincenz> :)
19:46:06 <jips> i want to do something but it's a bit over my head
19:46:08 <jips> what should i do?
19:46:18 <palomer> do it
19:46:20 <palomer> best way to learn
19:46:23 <palomer> but don't give up
19:46:42 <jips> problem is that i sort of know what i need to do, but i have no idea where to even start
19:47:36 <palomer> got a short description?
19:47:55 <jips> are you familiar with yampa?
19:48:59 <palomer> no, sounds hard:o
20:10:00 <jethr0_> good night
23:53:26 <Lokadin_> hey
23:53:30 <Lokadin_> anyone here?
23:53:54 <Adamant> no
23:53:59 <Lokadin_> kk
23:54:22 <Lokadin_> i have a bug i can't fix :(
23:54:26 <Lokadin_> here one sec
23:54:59 <Lokadin_> what happens is i'm processing an html file
23:55:17 <Lokadin_> now the complex bit that is taking out all the tags and everything in between them
23:55:20 <Lokadin_> i do fine
23:55:37 <Lokadin_> but when i try removing the new lines as well then i lose lots of information :(
23:55:55 <Cale> Lokadin_: hmm
23:56:10 <Lokadin_> you know, actually
23:56:27 <Lokadin_> i think it might not be recognising \n as a newline
23:56:32 <Lokadin_> but instead as just n
23:56:36 <Lokadin_> let me check
23:57:15 <Cale> (concat . lines) "Hello\nWorld"
23:57:18 <Cale> > (concat . lines) "Hello\nWorld"
23:57:19 <lambdabot> "HelloWorld"
23:57:36 <Cale> > (concat . intersperse " " . lines) "Hello\nWorld"
23:57:37 <lambdabot> "Hello World"
23:57:45 <Cale> or just
23:58:01 <Cale> > map (\x -> if x == '\n' then ' ' else x) "Hello\nWorld"
23:58:02 <lambdabot> "Hello World"
23:59:22 <Lokadin_> hmmm' well what i was doing is moving along list have case, so when x is '\n' -> process xs
23:59:48 <Lokadin_> er case x of '\n' -> process xs
