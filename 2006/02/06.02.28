00:00:02 <vincenz> ah, I thought you were testing iter
00:00:05 <mathrick> I'd like you guys to help me with the error message :)
00:00:06 * vincenz coughs and shuts up
00:00:21 <mathrick> vincenz: more like "making the POS do something"
00:00:26 <mathrick> which it refuses
00:00:36 <mauke_> mathrick: you can't have bare expressions in files
00:00:47 <mathrick> O_o
00:00:57 <mathrick> okay, that confuses me
00:01:03 <ayrnieu> vincenz - that works for me with hugs, sans the last line.
00:01:14 <ayrnieu> mathrick -
00:01:22 <mathrick> so I can't have defs in interactive sessions, and can't have expressions in files?
00:01:27 <ayrnieu> mathrick - why does it?  You can't have bare expressions in C files, either.
00:01:30 <mathrick> that's, hmm, unexpected
00:01:42 <mathrick> ayrnieu: so how do I run something?
00:01:42 <mathrick> ah
00:01:46 <mathrick> main where main = ?
00:01:55 <mathrick> s/main/module/
00:02:11 <tromp_> you edit and load definitions
00:02:50 <xerox> mauke_: hehe right.
00:02:54 <xerox> Ops, mathrick I mean.
00:03:07 <xerox> mathrick: you've to use them the oher way around :-)
00:03:08 <mathrick> xerox: /set completion_amount 0?
00:03:11 <ayrnieu> mathrick - er, it's easier for me to answer that question in terms of GHC.
00:03:51 <xerox> mathrick: also, print (iter list), as mauke_ pointed out.
00:04:05 <ayrnieu> print $ iter list
00:04:35 <vincenz> > sum $ map sum [[] ..[1..5]]
00:04:36 <lambdabot>  add an instance declaration for (Enum [a])
00:04:36 <lambdabot>   In an arithmetic sequence: [[] .. [1 .. 5]]
00:04:47 <vincenz> there should be an instance Enum a => Enum [a]
00:04:58 <vincenz> using lexicographic
00:05:39 <vincenz> > sum $ map sum $ map (\x -> [1..x]) $ [1..5]
00:05:40 <lambdabot> 35
00:05:55 <vincenz> > sum $ map sum $ map (1..) $ [1..5]
00:05:55 <lambdabot>  parse error on input `..'
00:06:00 * vincenz snaps
00:06:05 <vincenz> @pl \x -> [1..x]
00:06:06 <lambdabot> enumFromTo 1
00:06:59 <xerox> What's the point?
00:07:16 <vincenz> xerox: to enumerate lists
00:07:24 <xerox> > length [1..5]
00:07:24 <lambdabot> 5
00:07:25 <ayrnieu> there is no point!  (ha ha ha ha ha)
00:07:45 <vincenz> > 1
00:07:46 <lambdabot> 1
00:19:35 <mathrick> hmm, what is the class of comparables called?
00:19:38 <mathrick> Eq?
00:19:53 <Lemmih> Ord?
00:19:54 <dcoutts_> Ord?
00:20:46 <xerox> Ord!
00:20:50 <mathrick> heh
00:23:21 <dcoutts_> @seen malcolm
00:23:22 <lambdabot> I haven't seen malcolm.
00:25:12 <olleolleolle> @seen olleolleolle 
00:25:13 <lambdabot> You are in #haskell. Last spoke just now.
00:25:25 <olleolleolle> (Teehee.)
00:29:39 <ihope> I'm writing a simple thingy for IRC bots in Haskell.
00:30:06 <ihope> I'm wondering how to turn something like "foo\n\rbar\n\rbaz" into ["foo","bar","baz"].
00:30:12 <mathrick> greater :: t -> t -> t
00:30:12 <mathrick> greater a b
00:30:12 <mathrick>     | a < b = b
00:30:12 <mathrick>     | otherwise = a
00:30:13 <mathrick> ERROR "/mnt/amd/bach/export/students/makat05/test.hs":12 - Cannot justify constraints in explicitly typed binding
00:30:13 <mathrick> *** Expression    : greater
00:30:15 <mathrick> *** Type          : a -> a -> a
00:30:17 <mathrick> *** Given context : ()
00:30:19 <mathrick> *** Constraints   : Ord a
00:30:21 <mathrick> sorry for the paste
00:30:24 <mathrick> but I still don't get it
00:30:41 <xerox> ihope: tokens are single chars?
00:30:49 <xerox> ihope: well, there is that one:
00:31:04 <xerox> > words "one\ntwo\three"
00:31:05 <lambdabot> ["one","two","hree"]
00:31:20 <ihope> > words "foo\n\rbar\n\rbaz"
00:31:20 <xerox> > unwords ["uno","due","tre"]
00:31:21 <lambdabot> ["foo","bar","baz"]
00:31:21 <lambdabot> "uno due tre"
00:31:37 <Lemmih> mathrick: greater :: Ord t => t -> t -> t
00:31:42 <ihope> Well, I don't want to parse each word as a different message.
00:31:57 <mathrick> Lemmih: ah, =>
00:32:00 <ayrnieu> > words "one two\nthree four\nfive six"
00:32:00 <lambdabot> ["one","two","three","four","five","six"]
00:32:10 <mauke> @hoogle [a] -> [a] -> [[a]]
00:32:11 <lambdabot> Data.List.inits :: [a] -> [[a]]
00:32:11 <lambdabot> Data.List.tails :: [a] -> [[a]]
00:32:12 <xerox> Ah ops!
00:32:23 <xerox> > lines "one two\n\rthree four"
00:32:24 <lambdabot> ["one two","\rthree four"]
00:32:30 <ihope> > Hmm...
00:32:30 <lambdabot>  parse error on input `Hmm...'
00:32:32 <mauke> why doesn't haskell have a split function?
00:32:33 <ihope> Erm.
00:32:38 <ihope> @hoogle split
00:32:38 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
00:32:38 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
00:32:38 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
00:32:40 <mathrick> Lemmih: now, will it require both params to be exactly the same type, or just both to be in class Ord?
00:32:42 <xerox> I have one!
00:32:47 <xerox> And it's pretty nice.
00:33:01 <mauke> split :: (Eq a) => [a] -> [a] -> [[a]]?
00:33:11 <Lemmih> mathrick: The two args are both of type 't'.
00:33:26 <vincenz> > split [1,2,1,3]
00:33:27 <lambdabot>  add an instance declaration for (RandomGen [a])
00:33:27 <lambdabot>   In the definition of `izv': izv = split [1, 2, 1, 3]
00:33:27 <lambdabot>   In the definition of `v':
00:33:29 <Lemmih> mathrick: ie. they are of the same type.
00:33:38 <ihope> Is \n allowed inside an IRC messagE?
00:33:47 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:) in splitBy '\n' "We are\ntwo lines\n"
00:33:47 <lambdabot> ["We are","two lines",""]
00:33:51 <mathrick> Lemmih: yeah, but does that mean "greater 1 2.0" will be illegal?
00:33:51 <ayrnieu> ihope - no.
00:33:53 <xerox> :-D
00:34:05 <ihope> Okay. Thanks.
00:34:21 <mathrick> ERROR "/mnt/amd/bach/export/students/makat05/test.hs":10 - Haskell 98 does not support tag classes
00:34:21 <Lemmih> mathrick: No, '1' and '2.0' can easily be of the same type (:
00:34:23 <mathrick> whut?
00:34:43 <mathrick> Lemmih: okay, but if I defined something else in Ord, which cannot be easily made float
00:34:44 <ayrnieu> mathrick - 1 :: Float
00:34:44 <Lemmih> > (1::Float,2.0::Float)
00:34:45 <lambdabot> (1.0,2.0)
00:35:14 <Lemmih> mathrick: 'greater () False' wouldn't be valid.
00:35:31 <mathrick> I mean, I'm unclear on how exactly the type signature works in this case
00:35:49 <mathrick> Lemmih: aha, so you need them to really be of the same type?
00:35:57 <mathrick> not just both in the same class?
00:36:15 <Lemmih> mathrick: Yes, they are both of type 't'.
00:36:16 <mauke> right
00:37:25 <mathrick> also, how do I check the type signature of function?
00:37:39 <mathrick> I have removed the type signature from greater's def
00:37:49 <mathrick> and I want to see what haskell thinks about its type
00:38:07 <Lemmih> mathrick: :t greater
00:38:33 <mathrick> thanks
00:39:11 <mathrick> I see, so that unjustified error thing occurs when type constraints inferred are stronger than explicit ones?
00:41:56 <Lemmih> When the inferred type is less general, yes.
00:49:41 <pierre-> hello
00:50:26 <shapr> privet
01:13:02 <JohnMeacham> note to self: if there is ever even a mild inkling you might want to put something in a monad, put it in a monad right away.
01:17:11 <ayrnieu> does anyone have a recommendation for some sshable host machine with GHC?  I'd like to work with pugs, and only have OpenBSD/macppc handy.
01:22:49 <ihope_> Should I use let and where "a lot"?
01:24:18 <xerox> ihope_: I think they reflect the way one thinks about code.
01:25:26 <xerox> 'let' bindings introduce parts first, and the computation later, then, I think 'where' ones pose the accent on the computation, leaving the details for later.
01:26:44 <xerox> ayrnieu: doesn't GHC run on PPC?
01:27:31 <xerox> Also, green tea rocks.
01:30:00 <xerox> @version
01:30:01 <lambdabot> lambdabot 3p303, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
01:30:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:30:52 <ayrnieu> xerox - GHC does not run on *BSD/notx86
01:31:12 <ayrnieu> well, I asked Juerd for a feather account.  That should work.
01:31:17 <ihope_> Now, if I'm going to plop my IO stuff along with my pure stuff in one module, would {-End I/O capable code-} be a good way to seperate them?
01:32:49 <Lemmih> I don't see a need to separate them.
01:33:40 <ihope_> What would people think of me if I put {----------------------}{------------------------------------------------------} at the beginning of each module? ;-)
01:35:01 * vincenz smacks ihope_ 
01:35:19 <vincenz> i hope that answers :)
01:35:36 <ihope_> Um...
01:35:42 <vincenz> (jk)
01:35:48 <ihope_> :-)
01:36:16 <vincenz> I typically have -*80 lines to separete different portions of code
01:36:21 <vincenz> including one right after my imports
01:36:26 <palomer> whoa
01:36:28 <palomer> why?
01:36:38 <vincenz> to make my code more overseeable
01:39:56 <ihope_> Okay. Now all I need to write here is the runBot function.
01:40:06 <vincenz> ihope_: whatcha working on?
01:40:17 <ihope_> An IRC bot framework thingy.
01:40:20 <ihope_> type IRCBot a = IRCMessage -> State a [IRCMessage]
01:40:30 <vincenz> aha
01:40:37 <vincenz> lambdaboy?
01:40:44 <vincenz> to date lambdabot?
01:40:44 <ihope_> Um.
01:41:02 <xerox> Why don't you steal lambdabot's IRC Monad?
01:41:13 <vincenz> xerox: sounds like the garden of even in reverse
01:41:17 <vincenz> "take a bone from the woman to make a man"
01:41:22 <xerox> Hah.
01:41:23 <ihope_> I couldn't figure that out ;-)
01:41:24 <vincenz> garden of eve even
01:41:35 <vincenz> ...damn, you can tell I'm tired "eden"
01:41:41 <xerox> ihope_: Yeah, I think it has some spurious details now, like State support.
01:41:57 <ihope_> runBot :: IRCBot a -> [IRCMessage] -> State a [IRCMessage]
01:42:01 * vincenz wonders whether to take that last sentence out of context as well
01:42:25 <ihope_> Is there any good and easy way to write that?
01:42:33 <vincenz> ihope_: yeah
01:42:34 <xerox> A Monad?
01:42:39 <vincenz> but erm
01:42:44 <vincenz> why [IRCMessage]?
01:43:22 <ihope_> Well, my stuff parses into an [IRCMessage].
01:43:28 <vincenz> but why as input
01:43:46 <ihope_> It parses into an [IRCMessage], which is stuck into the bot.
01:43:54 <vincenz> for each line?
01:44:00 <ihope_> Um...
01:44:07 <ihope_> IRCMessage = one line of IRC junk.
01:44:11 <vincenz> riight
01:44:19 <vincenz> so how can you pass the entire future into a staemonad as input
01:44:26 <vincenz> that seems conceptually wrong
01:44:30 <ihope_> Um...
01:44:44 <vincenz> you're preprocessing all the input from irc until it shuts down before you generate ouput?
01:44:59 <ihope_> Wait a minute...
01:45:32 <ihope_> I don't think so. I wrote a loop that grabs what's there "so far", and pops it into runBot.
01:45:44 <ihope_> That's what hGetContents does, right?
01:45:47 <vincenz> ... so you're gonna call runBot over and over
01:45:50 <ihope_> Yes.
01:45:54 <vincenz> for each line
01:46:06 <vincenz> so why have [IRCMessage] as input and not IRCMessage
01:46:19 <ihope_> For each time I ran hGetContents.
01:46:30 <vincenz> it's not making sense to me
01:46:42 <ihope_> I cannot parse the output from hGetContents into a single IRCMessage, so I have to use a list;.
01:47:03 <vincenz> what's in hGetContents?
01:47:09 <vincenz> all future text?
01:47:19 <ihope_> I think it's just what's currently there.
01:47:22 <jethr0> hey vincenz 
01:47:25 <ihope_> I hope. (Eeph.)
01:47:28 <vincenz> jethr0: hi
01:47:39 <jethr0> vincenz: still fixing your oasisbot?
01:47:42 <vincenz> ihope_: wait let me look how I did this for a bot that stateful stdin-stdout communication with another process
01:47:46 <vincenz> jethr0: erm no?
01:48:00 <jethr0> nm, what're you up to?
01:48:42 <vincenz> ihope_: nope
01:48:44 <vincenz> ihope_: not gonna work
01:49:01 <vincenz> ihope_: what you want is a [IRCMessage] -> StateT a (IO ())
01:49:13 <ihope_> An IO ()?
01:49:17 <vincenz> so that inside your statemachine you output back to irc
01:49:23 <ihope_> Um.
01:49:41 <vincenz> jethr0: writing a report about my research :/
01:50:00 <vincenz> ihope_: hGetContents gets an infinte lazy list of incoming data...
01:50:09 <ihope_> Oh.
01:50:11 <ProfTeggy> vincenz, what's research without writing?  Nothing, almost.
01:50:17 <vincenz> ProfTeggy: true
01:50:21 <vincenz> ProfTeggy: but i hate writing
01:50:23 <jethr0> vincenz: doesn't sound like fun... i'll either finish up on my pong, or go right on to tetris or even straight to a jump'n'run...
01:50:26 <ProfTeggy> That's sad.
01:50:36 * ihope_ rewrites
01:50:37 <vincenz> ProfTeggy: yeah
01:50:47 <ProfTeggy> vincenz, I love it (when I'm allowed to to other stuff in between)
01:50:53 <jethr0> ProfTeggy: don't you hate writing up on stuff you've already solve? :)
01:50:54 <ProfTeggy> s/to to/to do/
01:50:56 <jethr0> solved
01:51:02 <ProfTeggy> jethr0, no!
01:51:03 * vincenz likes coding
01:51:07 * jethr0 too
01:51:31 <ProfTeggy> Quite often I found interesting twists of the matter only when I while I was writing
01:51:34 * jethr0 finds it the worst to write about solving sth when in reality it's still bug-ridden..
01:51:43 <ProfTeggy> s/when//
01:51:57 <vincenz> ProfTeggy: well that's true and it's helping me solidify my ideas, but when I write I have a short attention span and it takes forevever
01:52:29 <vincenz> not like coding, where I'll code undistractably
01:52:30 <ProfTeggy> Hmm...
01:52:51 <vincenz> I guess it's the rush of the "zone"
01:52:52 <ProfTeggy> My writing sometimes feels like coding because I strive for beautiful typesetting
01:53:04 <ProfTeggy> So, whenever I get tired of content, i switch to typeset mode
01:53:18 <ihope_> Maybe this is easier than I thought...
01:53:31 <vincenz> ProfTeggy: it might have to do with field of research... 
01:53:36 <vincenz> ProfTeggy: you're doing very theoretical reserach?
01:53:38 <jethr0> vincenz: it's the exact same thing with me. i can code for 12 hours at a time, but after 1 hour of research writing i'm totally exhausted.
01:53:41 <ProfTeggy> vincenz, which is your field?
01:53:53 <vincenz> ProfTeggy: optimizing transformations for multimedia applications
01:53:59 <ProfTeggy> vincenz, no -- I am a database guy, mostly into compilation of query languages
01:54:23 <ihope_> Maybe I need monad transformers.
01:54:34 <ihope_> @index ListT
01:54:35 <lambdabot> Control.Monad.List, Control.Monad.List, Language.Haskell.TH.Syntax,
01:54:35 <lambdabot> Language.Haskell.TH
01:54:37 <vincenz> anyways... the writing is typically not as highly formalized as such papers like you'd find in type theory papers or such
01:54:49 <vincenz> jethr0: yeah especially after 10 games of freecell
01:55:16 <ihope_> Wait... would State a [IRCMessage] be StateT [] a IRCMessage or ListT (State a) IRCMessage?
01:55:40 <vincenz> ihope_: you don't want a List monad
01:55:47 <jethr0> i was in real pain when i had to write up my thesis. much of it may have been selffulfilling prophecy, but i sure don't like it
01:55:56 * ihope_ goes bang bang bang
01:55:59 <ihope_> Yes I do.
01:56:02 <vincenz> ihope_: think about it... you're asking your runBot to return all the data that should go back to irc... before you get all the input
01:56:05 <vincenz> ihope_: that's like a singleshot bot
01:56:13 <vincenz> I'd think you want one that's interactiv
01:56:21 <vincenz> some input, some output, some input, some output
01:56:23 <vincenz> in a tight loop
01:56:36 <vincenz> so StateT a (IO ())
01:56:37 <ihope_> That's what I had...
01:56:44 <vincenz> one call to runBot
01:56:47 <vincenz> not one per input line
01:56:58 <ihope_> If this doesn't work, I'll try again.
01:57:00 <vincenz> meaning you don't have to rn your statemonad each time, get back the state and feed it int a new stateeval
01:57:32 <vincenz> anyways
01:57:34 <vincenz> back to this diagram
01:57:37 * vincenz mutters
01:57:44 <vincenz> "text is code"..."text is code"
01:57:56 <ihope_> Um...
01:58:04 <vincenz> I'm psyching myself to write
01:58:08 <jethr0> nice mantra
01:58:15 <jethr0> let's hope it'll work
01:58:18 <vincenz> yah
01:58:18 <ihope_> Okay, okay. I'll try the interactive thingy.
01:59:25 <vincenz> ProfTeggy: my problem with text is that it's too linear.... see code you can code on one bit, stick it into afunction then another bit, text you kinda have to go vertical, so if you get stuck somewhere, you get stuck, and that happens often
01:59:41 <vincenz> aka there's less random-writing with text w.r.t. code
01:59:47 <vincenz> random-placement writing even
01:59:53 * ihope_ attempts to think
02:00:23 <lispy> code also lets you be precise without fluffing things up
02:00:31 <lispy> you don't have to sell your code to the compiler
02:00:36 <vincenz> yeah
02:00:59 <vincenz> and there's a direct feedback loop "correct" 
02:01:35 <lispy> yeah
02:01:38 <vincenz> and type systems lets you know exactly what the missing piece should look like
02:02:04 <lispy> plus, with coding you've actually constructed something cool when you're done
02:02:10 <vincenz> yep
02:02:12 <vincenz> the gadget factor :)
02:02:14 <lispy> with writing you just endup with a pile of words
02:02:16 <vincenz> damn ADD when writing
02:02:22 * vincenz turns back to his diagram
02:02:45 <vincenz> ah, I'm getting somewhere
02:03:19 <ihope_> Hmm, /me forgot what he forgot
02:03:36 <ihope_> Aha! I forgot what ircLoop was supposed to return!
02:03:45 <vincenz> nothing
02:03:50 <ihope_> Indeed.
02:07:10 <lispy> Nothing or ()
02:07:17 <lispy> that is the question
02:07:22 <ihope_> ()
02:07:23 <vincenz> ()
02:07:43 <lispy> > ()
02:07:43 <lambdabot> ()
02:07:51 <ihope_> :-()
02:08:07 <ihope_> > (:-)
02:08:08 <lambdabot>  Not in scope: data constructor `:-'
02:08:09 <lispy> > ():[]
02:08:10 <lambdabot> [()]
02:08:31 <lispy> > repeat ()
02:08:32 <lambdabot> [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(
02:08:32 <lambdabot> ),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),
02:08:32 <lambdabot> (),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()
02:08:32 <lambdabot> ,(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(
02:08:32 <lambdabot> ),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),
02:08:34 <lambdabot> [23 @more lines]
02:08:45 <ihope_> > (concat . repeat) ()
02:08:45 <lambdabot> Couldn't match `[a]' against `()'
02:09:05 <ihope_> type () = forall a. [a]
02:09:09 <tromp_> > repeat "spam"
02:09:10 <lambdabot> ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","
02:09:10 <lambdabot> spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","
02:09:10 <lambdabot> spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","
02:09:10 <lambdabot> spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","
02:09:10 <lambdabot> spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","
02:09:12 <lambdabot> [25 @more lines]
02:09:23 <ihope_> > (concat . repeat) []
02:09:23 <lambdabot> Add a type signature
02:09:32 <ihope_> > (concat . repeat) [] :: [()]
02:09:36 <lambdabot> Terminated
02:09:42 <lispy> heh, nice
02:09:59 <ihope_> > 0 * (1/0)
02:10:00 <lambdabot> NaN
02:10:29 <vincenz> > reverse "_pmort kcams
02:10:29 <lambdabot>  lexical error in string/character literal
02:10:31 <vincenz> > reverse "_pmort kcams"
02:10:32 <lambdabot> "smack tromp_"
02:10:47 <lispy> > (0 * (1/0)):[]
02:10:48 <lambdabot> [NaN]
02:10:51 <ihope_> "I think all gun owners should be SHOT!"
02:11:28 <lispy> @. > keal
02:11:28 <lambdabot> compose module failed: Parse error: ">"
02:11:32 <tromp_> do policemen own guns?
02:11:35 <lispy> @. plugs keal
02:11:36 <lambdabot> compose module failed: Parse error: "plugs"
02:11:41 <lispy> @. eval keal
02:11:42 <lambdabot>  parse error on input `}'
02:11:48 * vincenz is going to holland this weekend
02:11:54 <lispy> vincenz: fun
02:11:58 <tromp_> me too
02:12:02 <vincenz> tromp_: you live there
02:12:05 <tromp_> wait, i'm there alrd
02:12:30 <ihope_> @keal
02:12:30 <lambdabot> i just got banned from math because i not have good ability to convey
02:12:30 <lambdabot> thoughts
02:12:42 <ihope_> > i just got banned from math because i not have good ability to convey thoughts
02:12:42 <vincenz> tromp_: jij bent zeker de plezante thuis :P
02:12:43 <lambdabot>  Not in scope: `thoughts'
02:12:46 <ihope_> @. eval keal
02:12:47 <lambdabot>  Not in scope: `b'
02:12:50 <ihope_> @. eval keal
02:12:50 <lambdabot>  parse error on input `in'
02:12:53 <ihope_> @. eval keal
02:12:54 <lambdabot>  parse error on input `in'
02:12:56 <ihope_> @. eval keal
02:12:56 <lambdabot>  Not in scope: `now'
02:12:58 <ihope_> :-)
02:13:27 <tromp_> ben de enige thuis:(
02:13:36 <vincenz> das minder
02:14:47 <lispy> @pl (\x -> (,) x (1/0):[]) 
02:14:47 <lambdabot> return . flip (,) (1 / 0)
02:15:18 <vincenz> who here works with music on?
02:15:27 <lispy> vincenz: once i while i do
02:15:35 <lispy> vincenz: but it's hit and miss
02:16:39 <lispy> hmm...might unsubscribe from haskell-cafe 1) lots of email i don't read 2) I rarely if ever reply to anything or send anything in
02:16:39 <tromp_> i have my headphones on
02:16:52 <vincenz> que es haskell-cafe?
02:17:09 <lispy> it's a haskell mailing list
02:17:29 <lispy> er sorry, soy es ...ah forget it
02:17:38 <vincenz> I don't speak spanish
02:17:46 <lispy> er not soy
02:17:54 <lispy> geez, i don't speak it either
02:17:56 <vincenz> why not? it's healthy
02:18:34 <lispy> tengo una cita con trabajar
02:18:51 <lispy> i think that's gramatically incorrect but it's close!
02:19:59 <vincenz> ah, I'm getting into a flow now with my diagram :)
02:21:37 <vincenz> anyways, cigarette break
02:22:31 <shapr> ayrnieu: w00
02:22:37 <roconnor> @yow
02:22:38 <lambdabot> I haven't been married in over six years, but we had sexual counseling
02:22:38 <lambdabot> every day from Oral Roberts!!
02:22:42 <ayrnieu> shapr - howdy!
02:22:47 <shapr> ayrnieu: You still doing the armed forces thing?
02:22:56 <vincenz> armed forces?
02:22:56 <ayrnieu> shapr - yes.  Why?
02:23:07 <vincenz> american army?
02:23:20 <shapr> Just curious, I try to stay current on the status of interesting people.
02:23:55 <ayrnieu> American something.  shapr has just shattered my policy of "don't talk about anything there here; don't talk about anything here there".  It saves me from feeling the need to rant :-)
02:24:01 <shapr> ah, I see
02:24:09 <shapr> How about I never really asked that? =)
02:24:18 <ayrnieu> :-)  How are you doing?
02:24:27 <shapr> Life is exciting...
02:24:35 <shapr> I live in interesting times.
02:24:48 <lispy> shapr: lies! ;)
02:24:55 <shapr> Research-wise it's never been better. Monetarily, it's not so good.
02:25:01 <lispy> hm...
02:25:06 <ayrnieu> The world is full of wonderful things.
02:25:09 <shapr> Truly
02:25:09 <lispy> shapr: are you back in school?
02:25:48 <shapr> lispy: Nah, just sick to death of my clients/jobs, and haven't gotten off my butt to find something better.
02:26:04 <ayrnieu> shapr - still working mostly with Python?
02:26:17 <shapr> Yup, Zope/Plone, and very very tired of it.
02:26:22 * lispy started learning python at work yestarday, it's a nice language
02:26:36 <shapr> lispy: Watch out, I'll tell you all the weak points ;-)
02:26:42 <lispy> it's no haskell, but it's much better than the fortran i was writing
02:26:44 <shapr> I went from Python to Haskell as my favorite language.
02:26:49 <shapr> True that.
02:27:08 <shapr> That's part of my problem, I used to do J2EE and other Java, and I'd rather do Python. I really don't want to do C or C++ either.
02:27:14 <lispy> IMO, there is no perfect language.  We just have "not as crappy as that one" languages
02:27:19 <shapr> My ex calls me a prima donna... I wonder if she's right.
02:27:27 <lispy> heeh
02:27:48 <lispy> i'm going to try working in the game industry, which means i have to polish up my C++
02:28:02 <lispy> i'm also looking for someone to talk me out of it  :)
02:28:06 <shapr> I'm just tired of implementing crappy solutions that are the answers to the wrong question in the first place.
02:28:21 <lispy> shapr: ah, consulting work?
02:28:47 <lispy> i mean, it sounds more general than language when you say it that way
02:28:51 <shapr> Yup, I get the requirements without much influence in molding them.
02:29:16 <shapr> True, the times I've worked for an enthusiastic client who's willing to hold a real conversation with me, I'm perfectly happy.
02:29:26 <shapr> I would even write FORTRAN for that sort of client.
02:29:28 <lispy> but how many jobs offer you the ability to shape them?  I can only think of one and that's doing "freelance" research
02:30:09 <shapr> I think any job should let the techie get the human requirements and then implement them to the best of hir ability.
02:30:10 <lispy> i say freelance to differentiate that sort of research from the kind where you're given a problem to solve by someone like the military
02:30:20 <shapr> Getting tech requirements to implement just sucks.
02:30:34 <lispy> yeah, takes the human aspects out
02:30:37 <shapr> ayrnieu: What're your language interests nowadays?
02:31:02 <lispy> well, i need to run to work, ttyl
02:31:05 <shapr> have fun
02:31:14 <lispy> i will, learning python again today
02:31:24 <lispy> building a gui for a client
02:31:36 <Philippa> I don't mind getting sensible tech requirements. Getting tech requirements from people who don't know what they're doing and should be letting the tech find them out, OTOH...
02:32:14 <ayrnieu> shapr - I've actually returned a bit to perl5, but am interested in perl6.  Other than that, only Erlang and Common Lisp have been on much of a practical radar.
02:33:23 <shapr> perl6 is quite nifty.
02:34:20 <ayrnieu> *nod*, and its development interests.
02:35:46 <ayrnieu> Right now I'm focused more on a set of libraries that I'd like than on any particular language.
02:36:29 <gour> dcoutts_: any progress on hIDE and/or amd64 status?
02:37:11 <ayrnieu> (which have taken a course of Rebol->Erlang->Perl, incidentally.  As I hit a shocking complexity wall in REBOL, and as I determined that I couldn't trust a server's flat-file interface and needed XML-RPC)
02:37:53 <ayrnieu> shapr - have you learned any new languages?
02:37:55 <dcoutts_> gour, well the static build works fine, I've not tried it yet on amd64 but I'd expect it'd work - since it doesn't use hs-plugins
02:38:25 <shapr> Hm, nothing really interesting... unless you count Epigram?
02:38:42 <gour> dcoutts_: are you still able to achieve the same (hIDE) objectives without hs-plugins?
02:39:24 <dcoutts_> gour, sort-of. I think we might be able to get it to work later with ghc-api's support for hs-plugins-like functionality
02:39:36 * ayrnieu doesn't see an immediate reason to discount it.
02:40:21 <gour> dcoutts_: iirc, there was talk that hs-plugins will become part of ghc?
02:40:44 <dcoutts_> gour, or some miniminal hs-plugins-like feature
02:40:46 <gour> dcoutts_: btw, did you have your gtk2hs demo already?
02:41:48 <dcoutts_> gour, it's in progress
02:42:24 <gour> dcoutts_: all the best in 'selling' the goods :-)
02:42:32 <dcoutts_> ta
02:42:51 <Philippa> oh crap, knew there was something else happening this friday :-)
02:43:07 <shapr> ayrnieu: I'm pursuing the whole proof programming idea.
02:48:25 <neologism> Hugs.Base> let r x = rev' x [] where rev' [] ys = ys; rev' (y:ys) z = rev' ys ([y] ++ z) in r [1,2,3]
02:48:28 <neologism> [3,2,1]
02:48:31 <neologism> sorry
02:48:37 <neologism> let r x = rev [] = []; rev' (x:xs) = rev' xs ++ [x] in r [1,2,3]
02:48:41 <neologism> whats wrong with this code?
02:49:20 <NoobLuck> > "hello" ++ " people"
02:49:21 <lambdabot> "hello people"
02:49:39 <Igloo> It's not syntactically correct for one thing
02:49:56 <Igloo> What do you mean by   let r x = rev [] = []   ?
02:50:29 <neologism> Igloo: I want to define that function
02:50:35 <neologism> r [] = []
02:50:52 <neologism> r (x:xs) = r' xs ++ [x]
02:50:59 <neologism> using let
02:51:12 <Igloo> let r [] = []; r (x:xs) = r' xs ++ [x] in ...
02:51:36 <Igloo> (do you really want r' rather than r there?)
02:51:41 <neologism> thnx
02:53:30 <neologism> Igloo: all I wanted to know was the let syntax
03:44:49 <Cale> "Isn't it great that we can add a new dimension to Wadler's law
03:44:49 <Cale>  by discussing character encodings?  ;-)" -- Wolfram Kahl
04:02:28 <sili_> i wonder how practical it'd be to write a job scheduler in haskell if i started learning it two nights ago
04:05:05 <shapr> sili_: If you know how to write job schedulers, look at the prolog-esque stuff implemented in Haskell.
04:05:51 <sili_> hmm
04:06:40 <shapr> Maybe an A* lazy search?
04:07:23 <sili_> nope. i've got specific instructions on how it's supposed to be generated
04:07:44 <shapr> Like what?
04:10:07 <sili_> well, the user wants it to do very little and let the process be very interactive. basically all i need to do is generate potential schedules using minor optimizations, then the user says yes/no
04:10:40 <sili_> they want the generation process to be simple and very ... i dunno ... structured. no magic
04:10:59 <sili_> i dunno.
04:11:57 <jonkri> how do i create a list with n elements, with the value [1, 1, 1, ..., 1]
04:12:05 <dcoutts_> @seen JaffaCake
04:12:05 <lambdabot> I haven't seen JaffaCake.
04:12:08 <mauke> > replicate 10 1
04:12:09 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
04:12:13 <jonkri> ah, perfect. thanks
04:13:01 <mauke> > take 10 [1,1..]
04:13:02 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
04:13:29 <sili_> mauke: just curious, how would you do it with map
04:13:40 <sili_> like map something [1..10]
04:14:16 <mauke> > map (const 1) [1..10]
04:14:16 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
04:14:22 <sili_> ah, const
04:14:24 <mauke> where const x = \_ -> x
04:14:47 <sili_> cute.
04:15:51 <xerox> There is replicate!
04:16:01 <xerox> Ah, woops.
04:16:14 <sili_> nah, sg-1 killed all the replicators
04:16:23 <mauke> but I need my food!
04:17:22 <shapr> hey SyntaxNinja!
04:17:23 <roconnor> @type \n f -> foldr (.) id $ replicate n f
04:17:24 <lambdabot> forall a.
04:17:24 <lambdabot>               Int -> (a -> a) -> a -> a
04:18:33 <roconnor> @pf \n f -> foldr (.) id $ replicate n f
04:18:34 <lambdabot> (foldr (.) id .) . replicate
04:19:20 <SyntaxNinja> heya shapr
04:19:35 <xerox> roconnor: nice one.
04:19:47 <xerox> roconnor: Think of WriterT (a -> a) a, too :-)
04:28:12 <xerox> ma tutti leccano :P
04:28:21 <xerox> I think I missed the window, sorry :-)
04:28:53 <rep> cazzo leccano?
04:29:09 <xerox> ...
04:30:55 <jonkri> the gentoo ghc package is one nasty package
04:31:14 <Cale> jonkri: get the binary version
04:31:29 <Cale> jonkri: I specifically requested that it be added for this reason :)
04:31:37 <jonkri> Cale: perhaps i will, i've been compiling it for hours (in my ram) and it sometimes slows down the system like crazy
04:31:42 <Cale> yeah
04:32:07 <jonkri> Cale: at one time my computer crashes, and i have a hard time imagining emerge crashing it, but i have an even harder time imagine that something else did it
04:32:23 <jonkri> Cale: how long is it supposed to take?
04:32:30 <Cale> Hours or days
04:32:35 <jonkri> no way?
04:32:41 <Cale> depending on the speed of your machine
04:32:42 <jonkri> ... why?
04:32:47 <jonkri> 1,3ghz
04:32:52 <Cale> it's huge, and it has to bootstrap
04:33:02 <jonkri> 1024 ram, with /usr/tmp/portage on shfs
04:33:05 <Cale> I think it took me almost all day on my 2.4GHz machine
04:33:11 <jonkri> jesus
04:33:18 <jonkri> why does it have to "bootstrap"?
04:33:26 <Cale> well, it's written in Haskell
04:33:31 <Cale> of course :)
04:33:37 <jonkri> Cale: so?
04:33:48 <Cale> do you have an older GHC already?
04:33:51 <shapr> Sort of like... how do you build a C compiler written in C for a computer that has no C compiler?
04:33:54 <jonkri> yes
04:33:59 <Cale> oh, okay
04:34:16 <Lemmih> Cale: Bootstrapping doesn't happen automatically.
04:34:16 <liyang> shapr: you cross-compile!
04:34:24 <jonkri> i hope this ghc will be newer since the old one still wants "Debug.QuickCheck" instead of "Test.QuickCheck".
04:34:34 <jonkri> ok
04:34:43 <Cale> Lemmih: Doesn't it get off the ground with .hc files?
04:34:46 <shapr> jonkri: What never wersion are you using?
04:34:52 <jonkri> butit still shouldn't take this long
04:34:55 <shapr> liyang: Yeah, would be nice...
04:34:58 <jonkri> how can it take more time than gcc?!
04:34:59 <liyang> ;)
04:35:06 <Cale> (I don't mean the full human-assisted bootstrapping process)
04:35:14 <jonkri> is it because of haskell?
04:35:17 <Lemmih> jonkri: It'll build all the standard Haskell libraries with optimizations, and it'll do it twice.
04:35:50 <jonkri> shapr: "The Glorious Glasgow Haskell Compilation System, version 6.2.2"
04:36:06 <Lemmih> Just building GHC without libraries shouldn't take more than an hour on a slow computer.
04:36:28 <Lemmih> Cale: I doubt it.
04:36:35 <jonkri> ok, i'm downloading the bin version now
04:36:36 <Cale> Lemmih: hmm
04:37:08 <Cale> Okay, perhaps it doesn't :) I've never built the gentoo package myself, I'm not sure how it manages.
04:38:10 <Cale> of course, given that his system has a previous GHC, it wouldn't need any of that
04:38:39 <Lemmih> Gentoo even have a ghc-bin ebuild.
04:38:47 <shapr> Is it possible that GHC can bootstrap with a minimal GHC, but requires its own version for an optimized GHC?
04:38:52 <Cale> yeah, I told him to get that
04:46:05 <pierre-> > let ack 0 x y = x+y; ack n x y = (x:(iterate (ack (n-1) x) x))!!y in ack 2 3 2  
04:46:06 <lambdabot> 9
04:46:22 <pierre-> > let ack 0 x y = x+y; ack n x y = (x:(iterate (ack (n-1) x) x))!!y in ack 1 3 2
04:46:23 <lambdabot> 6
04:46:39 <pierre-> > let ack 0 x y = x+y; ack n x y = (x:(iterate (ack (n-1) x) x))!!y in ack 2 9 9
04:46:41 <lambdabot> Exception: stack overflow
04:46:53 <pierre-> > let ack 0 x y = x+y; ack n x y = (x:(iterate (ack (n-1) x) x))!!y in ack 2 3 3
04:46:54 <lambdabot> 27
04:47:06 <pierre-> > let ack 0 x y = x+y; ack n x y = (x:(iterate (ack (n-1) x) x))!!y in ack 2 4 4
04:47:07 <lambdabot> 256
04:48:06 <pierre-> wow. seems to be working
04:49:57 <pierre-> > intersect [1..] [2..]
04:50:01 <lambdabot> Terminated
04:50:16 <pierre-> > union [1..] [2..]
04:50:17 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
04:50:17 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
04:50:17 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
04:50:17 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
04:50:17 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
04:50:19 <Beelsebob> ... it can't check that 1 isn't in the second set
04:50:19 <lambdabot> [24 @more lines]
04:50:49 <pierre-> > [1..] \\ 1
04:50:50 <lambdabot>  add an instance declaration for (Num [a])
04:50:58 <Cale> > intersect [2..] [1..]
04:50:59 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,
04:50:59 <lambdabot> 29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
04:50:59 <lambdabot> 53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
04:50:59 <lambdabot> 77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
04:50:59 <lambdabot> 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
04:51:01 <lambdabot> [24 @more lines]
04:51:27 <pierre-> > [1..] \\ [1]
04:51:28 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,
04:51:28 <lambdabot> 29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
04:51:28 <lambdabot> 53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
04:51:28 <lambdabot> 77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
04:51:28 <lambdabot> 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
04:51:29 <lambdabot> [24 @more lines]
04:51:52 <pierre-> [1..] ++ [..2]\\ [1]
04:51:57 <Cale> > [1..] \\ [2..]
04:52:00 <pierre-> > [1..] ++ [..2]\\ [1]
04:52:01 <lambdabot> Terminated
04:52:01 <lambdabot>  parse error on input `..'
04:52:11 <Cale> > head ([1..] \\ [2..])
04:52:15 <lambdabot> Terminated
04:52:31 <xerox> Aww.
04:52:35 <shapr> Too bad it doesn't exploit laziness.
04:52:37 <pierre-> nub [1..]
04:52:43 <pierre-> > nub [1..]
04:52:43 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
04:52:43 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
04:52:43 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
04:52:43 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
04:52:43 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
04:52:46 <lambdabot> [24 @more lines]
04:52:59 <pierre-> > nub [1..] ++ [2..]
04:53:00 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
04:53:00 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
04:53:00 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
04:53:00 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
04:53:00 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
04:53:02 <lambdabot> [24 @more lines]
04:53:22 <Cale> heh
04:53:33 <fluxx> we'll never know if it's going to filter that second 2 or not
04:53:50 <fluxx> > sort [1..]
04:53:53 <fluxx> ;(
04:53:53 <lambdabot> Terminated
04:54:13 <Cale> > nub [1..10] ++ [2..]
04:54:14 <lambdabot> [1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,
04:54:14 <lambdabot> 22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,
04:54:14 <lambdabot> 46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,
04:54:14 <lambdabot> 70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,
04:54:14 <lambdabot> 94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,
04:54:16 <lambdabot> [24 @more lines]
04:54:16 <fluxx> but, atleast that answers to the question if nub works by sorting
04:54:39 <fluxx> oh, nub was the function that _expects_ sorted input
04:54:47 <Cale> no
04:54:53 <xerox> no it's just
04:54:58 <Cale> nub ([1..10] ++ [2..])
04:54:58 <Cale> > nub ([1..10] ++ [2..])
04:54:59 <xerox> (nub [1..]) ++ [2..]
04:55:00 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
04:55:00 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
04:55:00 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
04:55:00 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
04:55:00 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
04:55:02 <lambdabot> [24 @more lines]
04:55:03 <xerox> right.
04:55:06 <fluxx> well, ok, it just filters adjacent equals elements?
04:55:11 <Cale> no
04:55:19 <fluxx> oh, right
04:55:29 <fluxx> you simply concatenated the list after nub
04:55:31 <Cale> nub wasn't applied to the second list there
04:55:34 <Cale> yeah
04:57:31 <pierre-> > group cycle [1,1,2,2]
04:57:31 <lambdabot> Couldn't match `[[a]]' against `t -> t1'
04:58:00 <xerox> > group $ cycle [1,1] [2,2]
04:58:00 <lambdabot> Couldn't match `[a]' against `t -> t1'
04:58:03 <pierre->  > group (cycle [1,1,2,2])
04:58:07 <xerox> Uh.
04:58:32 <pierre-> > group (cycle [1,1,2,2])
04:58:33 <lambdabot> [[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[
04:58:33 <lambdabot> 1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,
04:58:33 <lambdabot> 1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1]
04:58:33 <lambdabot> ,[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[
04:58:33 <lambdabot> 2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,2],[1,1],[2,
04:58:35 <lambdabot> [23 @more lines]
04:58:54 <pierre-> > group [1..]
04:58:54 <lambdabot> [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[
04:58:54 <lambdabot> 17],[18],[19],[20],[21],[22],[23],[24],[25],[26],[27],[28],[29],[30],[31],
04:58:54 <lambdabot> [32],[33],[34],[35],[36],[37],[38],[39],[40],[41],[42],[43],[44],[45],[46]
04:58:54 <lambdabot> ,[47],[48],[49],[50],[51],[52],[53],[54],[55],[56],[57],[58],[59],[60],[
04:58:54 <lambdabot> 61],[62],[63],[64],[65],[66],[67],[68],[69],[70],[71],[72],[73],[74],[75],
04:58:56 <lambdabot> [24 @more lines]
04:59:05 <Phyx-> hm
04:59:14 <pierre-> > group (cycle [1..])
04:59:15 <Phyx-> trying to overflow it or something?
04:59:15 <lambdabot> [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[
04:59:15 <lambdabot> 17],[18],[19],[20],[21],[22],[23],[24],[25],[26],[27],[28],[29],[30],[31],
04:59:15 <lambdabot> [32],[33],[34],[35],[36],[37],[38],[39],[40],[41],[42],[43],[44],[45],[46]
04:59:15 <lambdabot> ,[47],[48],[49],[50],[51],[52],[53],[54],[55],[56],[57],[58],[59],[60],[
04:59:15 <lambdabot> 61],[62],[63],[64],[65],[66],[67],[68],[69],[70],[71],[72],[73],[74],[75],
04:59:17 <lambdabot> [24 @more lines]
04:59:31 <pierre-> > group (cycle [1])
04:59:31 <lambdabot> [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:59:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:59:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:59:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:59:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
04:59:33 <lambdabot> [23 @more lines]
04:59:49 <pierre-> just exploring lazyness :-)
05:00:11 <xerox> No harsh implied: lambdabot works by privmsgs too(
05:22:47 <jonkri> why do i get parse error on this: [[(row + column | column <- [1..x]] | row <- [1..y]]? thanks
05:23:48 <mauke> @type \x y -> [[(row + column | column <- [1..x]] | row <- [1..y]]
05:23:49 <lambdabot> parse error on input `|'
05:24:15 <jonkri> yeah, but i don't get it
05:24:34 <Lemmih> @type \x y -> [[row + column | column <- [1..x]] | row <- [1..y]]
05:24:34 <lambdabot> forall a.
05:24:34 <lambdabot>                      (Enum a, Num a) =>
05:24:34 <lambdabot>                      a -> a -> [[a]]
05:24:45 <mauke> yeah, (
05:26:53 <jonkri> how could i miss that? thanks
05:28:13 * shapr tries to map his Haskell thinking into SQL.
05:31:38 <vincenz> aloha
05:41:05 <shapr> shazam!
05:42:35 <irc> shazam indeed
05:42:41 <irc> why is my name irc?
05:55:18 <sili_> is there a hash type
06:02:01 <Lemmih> There are many types of hash.
06:07:24 <dfhaii> what's the easiest way to read a csv file into a list/
06:11:12 <eurleif> Can I export a data constructor from a module and allow it to be pattern-matched, but not directly constructed?
06:13:23 <Cale> eurleif: nope, though that's a feature which people have talked about
06:14:05 <Cale> dfhaii: a list of lists?
06:15:35 <dfhaii> what do you mean, i wish to put the csv file which is like a,b,c,d,e into a list which would look like [a,b,c,d,e]
06:15:42 <Cale> hmm, probably a proper parser would be in order
06:16:05 <Cale> if you want to handle things like quotes and quotes in quotes
06:16:19 <Cale> otherwise, you could just break the lines up at the commas
06:16:28 <dfhaii> it's just a list of ints, no fancy formatting or anything to deal with
06:16:44 <Cale> oh, okay
06:18:28 <roconnor> @docs newtype
06:18:28 <lambdabot> newtype not available
06:18:54 <Cale> newtype is a keyword
06:19:01 <roconnor> when using newtype, boxing and unboxing is optimised away?
06:21:07 <Cale> yeah
06:21:26 <roconnor> okay, so suppose I have a type Clifford.
06:21:35 <roconnor> and then I do newtype Point = Point Clifford
06:21:47 <roconnor> and newtype Line = Line Clifford
06:21:53 <roconnor> and newtype Plane = Plane Clifford
06:22:29 <roconnor> and I lift my operations on Clifford to operations on Points and Lines
06:22:54 <roconnor> The lifted operations will run as fast as they would have if I had used Clifford directly.
06:23:02 <Cale> yep
06:23:07 <roconnor> but I still get all the advantages of type checking.
06:23:10 <Cale> yeah
06:23:24 <roconnor> making sure that two points form a line, and not a plane
06:23:39 <roconnor> nice
06:23:46 <Cale> dfhaii: btw, you might want to look at the 'words' function in the prelude
06:23:59 <roconnor> I have to do a lot of coding to lift function box and unbox stuff.
06:24:03 <Cale> It could easily be generalised/modified to deal with what you have
06:24:07 <dfhaii> ok,. thanks for the help Cale 
06:24:11 <roconnor> but I'm glad the complied code wont suffer.
06:24:15 <dfhaii> i'm still pretty green with haskell
06:24:40 <Cale> words            :: String -> [String]
06:24:40 <Cale> words s          =  case dropWhile Char.isSpace s of
06:24:40 <Cale>                       "" -> []
06:24:40 <Cale>                       s' -> w : words s''
06:24:40 <Cale>                             where (w, s'') = break Char.isSpace s'
06:25:18 <Cale> if you replace  Char.isSpace  with  (== ',')  it'll break at the commas.
06:26:11 <Cale> roconnor: this is especially nice when you have an interface to Clifford via a class
06:26:47 <Cale> you can use an easy extension called newtype deriving to derive any class on a newtype which the original type supported
06:27:07 <Cale> newtype Point = Point Clifford deriving Algebra
06:27:09 <roconnor> oh
06:27:26 <roconnor> nice
06:27:56 <roconnor> Although I don't think there are any classes that I want to derive in my case.
06:28:05 <roconnor> maybe Group.
06:28:20 <roconnor> ...
06:28:24 <roconnor> probably not actually.
06:28:32 <roconnor> still, nice to have the option.
06:32:24 <roconnor> oh there is a class I want to derive
06:32:27 <roconnor> AlmostEq
06:32:29 <roconnor> sweet
06:35:33 <tibbe> >􀀀  
06:35:33 <tibbe> 􀀀  􀀀        	 
06:35:33 <tibbe> 
06:35:33 <tibbe> 􀀀    	 	  	
06:35:33 <tibbe> 
06:35:34 <tibbe> 􀀀 
06:35:38 <tibbe> ooops
06:35:52 <integral> fascinating, but this isn't #perl :-P
06:35:55 * tibbe concludes that copying code from a pdf doesn't work
06:36:03 <tibbe> integral, haha
06:41:46 <Excedrin> talking about perl, how close can Haskell come to something like: $h{"foo"} = {"bar" => "baz"};
06:41:54 <jonkri> how do i turn [1, 2, 3, 4, 5, 6, 7, 8, 9] into [[1, 2, 3], [4, 5, 6], [7, 8, 9]]??
06:41:59 <jonkri> s/??/? :-)
06:43:10 <Lemmih> jonkri: See Data.List.splitAt
06:43:42 <jonkri> Lemmih: ah. will i have to do this recursively?
06:44:22 <_roconnor> @type unfoldr
06:44:23 <lambdabot> Not in scope: `unfoldr'
06:44:25 <_roconnor> @type unfold
06:44:26 <lambdabot> Not in scope: `unfold'
06:44:32 <_roconnor> @type List.unfoldr
06:44:33 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
06:45:49 <_roconnor> > unfoldr (\x -> if null x then Nothing else Just $ splitAt 3 x) [1..9]
06:45:50 <lambdabot> [[1,2,3],[4,5,6],[7,8,9]]
06:45:55 <_roconnor> oh yes
06:45:57 <_roconnor> first try
06:46:28 <jonkri> thanks
06:46:30 <jonkri> :-)
06:46:41 <_roconnor> Er, I hope that wasn't an homework exercise
06:47:22 <jonkri> _roconnor: don't worry, it wasn't. allthough it's a very small part of an assignment from school
06:47:34 <jonkri> _roconnor: very, very small part :-)
06:48:14 <Excedrin> by "very, very small part" you mean, exercise 6 out of 20
06:48:31 <tibbe> Why is Int -> (forall a. a -> a) of rank one but (forall a. a -> a) -> Int of rank two?
06:49:04 <_roconnor> because Int -> (forall a. a -> a) is isomorphic to forall a. Int -> a -> a
06:49:07 <jonkri> no, i mean that the only guideline for the assignment is that i should create an application that simulates game of life. i can construct it how i want
06:50:36 <_roconnor> sort of like how (a -> b) -> c is a higher order function, while c -> (a -> b) is just a boring function.
06:51:37 <jonkri> @docs foldr
06:51:37 <lambdabot> foldr not available
06:51:51 <MarcWeber> Why does hGetContents stdin doesn't return "" if there is none?
06:52:23 <tibbe> _roconnor, ah, I get it, thanks
06:53:32 <sethk> MarcWeber, because that would be wrong
06:53:53 <sethk> MarcWeber, "" would be a file with only a newline in it
06:54:23 <ihope> I'm guessing it's the same reason the Monad class doesn't extend Functor and provide return, join and fail.
06:54:46 <MarcWeber> sethk: Ah.. cat ignores stdin when adding files.. That's the way to do it.
06:56:01 <sethk> MarcWeber, I'm not quite sure how that relates, but maybe I missed part of the conversation
06:56:26 <MarcWeber> sethk: You didn't. I knew echo "abc" | cat outputs abc
06:56:38 <MarcWeber> I also knew echo "abc" > file; cat file outputs abc
06:56:48 <MarcWeber> So I thought invoking my own haskell programm this way
06:57:15 <MarcWeber> echo "some text" | myprog file1  should make my program read from stdin as well as opening those files..
06:57:42 <MarcWeber> but first reading from stdin and then getting args caused trouble.. it waited till interruption for stdin input
06:57:48 <ihope> Um...
06:59:56 <tibbe> is there any big difference between implementing strict and non-strict functional languages?
07:00:07 <ncalexan> Yes.
07:00:29 <ncalexan> You might be interested in SPJ's book; it's available online.
07:00:48 <ncalexan> @where Implementing Lazy Functional Languages
07:00:49 <lambdabot> I know nothing about implementing.
07:01:12 <ncalexan> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
07:04:28 <imix> do (socket-)handles support concurrent reading and writing?
07:05:52 <tibbe> ncalexan, I've read parts of it, I can't remember that he brought up the topic at all. perhaps you could highlight the differences?
07:06:07 <ncalexan> Uh... seriously?
07:06:15 <ncalexan> Consider f x y = y.
07:06:27 <ncalexan> If you evaluate x in a strict language, and x diverges, then f diverges.
07:06:39 <ncalexan> In a lazy language, x is never evaluated, and f does not diverge.
07:06:53 <ncalexan> Read diverge however you think of bottom/does not return.
07:07:23 <ncalexan> Maybe that's not a strict/non-strict but a lazy issue?
07:10:08 <tibbe> ncalexan, well I was more thinking about how the functional language was represented on the machine, i.e. in both cases you could use a graph and change the order of evaluation
07:10:27 <ncalexan> You didn't say that :)
07:10:32 <ihope> Well, the evaluation order for Haskell is pretty much undefined.
07:10:37 <tibbe> ncalexan, so to clarify me question, is the representation the same but the semantics differ?
07:10:46 <ihope> In other lanugages, it may have a definition of some sort.
07:10:53 <tibbe> ncalexan, I blame my English ;)
07:11:01 <ncalexan> I don't know of any strict languages that represent the program with a call graph and then reduce.
07:11:08 <ncalexan> If everything is ordered, why would you do that?
07:11:14 <tibbe> ncalexan, good, then how is it represented
07:11:23 <tibbe> ncalexan, partial evaluation?
07:11:25 <ncalexan> Sequentially?
07:12:09 <ncalexan> Partial evaluation is usually handled by building closures with lexical scoping/frames.
07:12:20 <ncalexan> Sequentially.
07:12:59 <ncalexan> Have you written a compiler for a lazy language but not for a strict one?  That's unusual :)
07:13:09 <tibbe> so, if I have a function: f x y = x + y and call f 1, would I store something on the heap that represents the arguments applied this far?
07:13:40 <tibbe> ncalexan, I've written an interpreter for a strict one, read about lazy ones and thinking about a strict compiler!
07:14:19 <ncalexan> tibbe: I think that's one way of doing it.
07:15:49 <ncalexan> tibbe: I think any book about compilation will convince you that the techniques are different.
07:16:11 <tibbe> ncalexan, the problem I was thinking of was that in C you could represent a 3 arg function with one block of code that gets called since you know you'll have 3 arguments always, not so with partial application
07:16:40 <ncalexan> Oh, so you're really asking, how do I implement closures in my strict language?
07:16:43 <tibbe> ncalexan, I've actually not found anything on compilation of strict functional languages
07:16:53 <tibbe> ncalexan, I dunno, am I?
07:17:04 <ncalexan> Uh... you might want to try all those books on compiling LISP or Scheme.
07:17:16 <ncalexan> Or ML.
07:17:21 <ncalexan> Appel's book, for instance.
07:17:26 <tibbe> does lisp do partial application?
07:17:29 <ncalexan> @google Appel compiling ML
07:17:30 <lambdabot> http://citeseer.ist.psu.edu/shao94compiling.html
07:18:17 <ncalexan> http://www.cs.princeton.edu/~appel/modern/toc.html
07:18:22 <ncalexan> Chapter 15 will get you started.
07:18:28 <ihope> Wikipedia seems to be down. It probably isn't.
07:18:45 <ncalexan> There are versions that do everything in C and Java, too, if you don't like ML.
07:19:27 <tibbe> ncalexan, if I would like to use C as an intermediate language I need to do what the Evil Mangler does right?
07:19:37 <tibbe> to get tail call optimizations
07:19:45 <ncalexan> That I can't say.  I really know very little about GHC details.
07:19:45 <bd_> you could do what chicken scheme does
07:20:07 <bd_> put your first generation on the stack, when it gets full do a copy collector pass, then longjmp back to a trampoline
07:21:02 <tibbe> bd_, I really didn't understand what you just said
07:21:03 <bd_> http://home.pipeline.com/~hbaker1/CheneyMTA.html
07:21:05 <bd_> XD
07:21:14 <bd_> see link, it explains better :P
07:21:47 <ihope> *All* functions tail-recursive?
07:21:54 <ihope> Eep.
07:22:31 <tibbe> bd_, I'll read it
07:22:49 <tibbe> ihope, something I said?
07:23:04 <jonkri> what should i do in order to get a working wxhaskell on my gentoo installation? (is it possible?)
07:23:21 <ihope> From that link up there: "IEEE Scheme [IEEE90] requires that all functions be properly tail-recursive".
07:23:41 <Lemmih> jonkri: Have you tried installing wxhaskell?
07:23:53 <ncalexan> tibbe: it really seems like you're conflating different issues.  Lazy vs strict vs non-strict, tail recursion, linking with C code... these are all separate!
07:25:31 <tibbe> jonkri, I have it working on mine, I don't remember doing much more than emerge
07:25:51 <ibid> ihope: it means that any calls made in tail position must be treated as parameter-passing gotos, not that all calls must be in tail position :)
07:26:07 <tibbe> ncalexan, they are and therefore the initial vague question
07:26:10 <ihope> Ah.
07:26:29 <MarcWeber> http://www.rafb.net/paste/results/YoTQIo70.html Why doesn't this compile? Where is the difference?
07:26:32 <tibbe> ncalexan, all have to do with implementing a strict functional language though
07:26:41 <ibid> ihope: R5RS has a whole section explaining it
07:26:43 <ihope> What if the only recursion we were allowed was tail recursion?
07:26:56 <ibid> that'd be a cps language
07:26:59 <ibid> annoying to use
07:27:09 <ibid> but some compilers use that as an intermediate form
07:27:30 <tibbe> well, I really have to go to bed, g'night all
07:27:37 <ncalexan> g'night.
07:27:48 <ibid> i should too, but i'm too energetic now
07:28:34 <MarcWeber> Do you know of a working brainfuck implementation in haskell?
07:29:51 <ihope> You could write one.
07:29:56 <ihope> It's not a complex language.
07:30:24 <bd_> MarcWeber: http://esoteric.sange.fi/brainfuck/impl/compilers/bf2c.hs
07:30:36 <MarcWeber> ihope: I'm trying to do that.. but I get this annoying compiler error
07:30:46 <ihope> What is it?
07:31:40 <MarcWeber> ihope: See above. (link)
07:32:32 <ihope> Try adding type annotations.
07:32:59 <ihope> That should better pin down the error, at least.
07:34:11 <MarcWeber> ihope: Why do I get it at all?
07:34:30 <MarcWeber> the liftM line does work in a IO monad .. but not after the then
07:34:31 <bd_> you may have done return (IO monad action) somewhere
07:34:45 <bd_> wait
07:34:56 <bd_> liftM (interpretBrainFuckStd interpreter1) (hGetContents stdin)
07:35:08 <bd_> if interpretBrainFuckStd is (something -> IO ())
07:35:10 <bd_> then you want
07:35:18 <bd_> (interpretBrainFuckStd interpreter1) =<< (hGetContents stdin)
07:35:29 <bd_> liftM is to lift non-monadic functions into the monad
07:36:41 <MarcWeber> bd_: I can delete everything after the first liftM line. Why does this compile then? I'll try your correction
07:37:32 <bd_> MarcWeber: I think it just throws away the return value of liftM then
07:37:34 <MarcWeber> Its working..
07:37:38 <bd_> might have to do with the second use of liftM later on
07:39:01 <_roconnor> @hoogle [a] -> Maybe a
07:39:01 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
07:39:01 <lambdabot> Data.Maybe.Nothing :: Maybe a
07:39:01 <lambdabot> Prelude.Nothing :: Maybe a
07:46:06 <ihope> @fixity
07:46:07 <lambdabot> Unknown command, try @listcommands.
07:50:55 <ihope> @index sort
07:50:56 <lambdabot> Data.List
07:52:20 <ihope> So "The quick brown fox jumps over the lazy dog." contains "e " twice and "he" twice.
07:52:43 <ihope> Indeed, it contains "he " twice.
07:59:31 <ihope> Now, is there any IO action for accessing the clipboard?
08:00:08 <ihope> Eh, never mind.
08:00:27 <bd_> Not a standard one, but possibly in some extension library. Not every system has a clipboard after all.
08:02:12 <ihope> Oh noes. I'm getting alternating GHCi and Windows command prompts, and having to type files into the GHCi ones and Haskell expressions into the Windows ones.
08:05:26 <xerox> <http://people.csail.mit.edu/jrb/goo/> Foo!..err..Goo!
08:05:41 <ihope> Okay. Lorem ipsum contains five " do".
08:20:39 <dcoutts> liyang, pong
08:22:44 <Phyx-> tired... geek's going to the gym... what next? dare i say it? a girlfriend??
08:27:02 * arguile watches the ice encroach upon hell's borders
08:34:11 <ihope> Whee.
08:34:39 <ihope> So everybody uses irssi?
08:35:58 <ihope> Apparently GNU netcat 0.7.1 is CTCP-compatible.
08:37:59 <dons> @seen ayrnieu
08:38:00 <lambdabot> ayrnieu is in #haskell. Last spoke 5 hours, 58 minutes and 7 seconds ago.
08:38:58 <dons> ayrnieu, GHC does run on BSD/notx86, for examle: sparc/ mips64/ sparc64/ alpha/ m68k
08:42:02 <oberon> > (\x -> x 2) (\x -> x * 3)
08:42:03 <lambdabot> 6
08:42:05 <dcoutts> dons, do you know anything about ghc on ppc64 ?
08:42:11 <oberon> > \x -> x 2
08:42:12 <lambdabot>  add an instance declaration for (Show ((t -> t1) -> t1))
08:42:17 <dcoutts> we're having problems with it in gentoo
08:42:38 <oberon> why oes that work?
08:42:50 <oberon> i dont get the \x -> x 2
08:42:54 <dons> oh, yeah, and on powerpc.
08:42:59 <dons> I don't know much  about it.
08:43:07 <ihope> \x -> x 2 applies its argument to 2.
08:43:35 <norpan> it takes a function and applies 2 as an argument to it
08:43:36 <dcoutts> ghc is supposed to build registered on ppc64, but non-trivial programs overfow the "TOC" and using -optc-minimal-toc makes the mangler barf
08:44:01 <ihope> (\x -> x 2) (\x -> x * 3) = (\x -> x * 3) 2 = 2 * 3 = 6
08:44:08 <dcoutts> so we can only get it to be usable when it's built unregisterised
08:44:13 <dons> hmm. i think the ppc _64_ might have rotted a bit. it's been a while since i've seen a build
08:44:21 <oberon> > (\x -> x) $ 2
08:44:22 <lambdabot> 2
08:44:52 <oberon> > \x -> x 2
08:44:52 <dons> and it only barely got there originally, iirc.
08:44:53 <lambdabot>  add an instance declaration for (Show ((t -> t1) -> t1))
08:44:58 <oberon> > \x -> x $ 2
08:44:58 <lambdabot>  add an instance declaration for (Show ((a -> b) -> b))
08:45:15 <dcoutts> dons, 6.4.1 does build unregisterised and even registerised. It's just not usable registerised :-). Eg building cabal overflows this TOC thing.
08:45:16 <oberon> > (\x -> x  2)
08:45:17 <ihope> @pl \x -> x y
08:45:17 <lambdabot>  add an instance declaration for (Show ((t -> t1) -> t1))
08:45:17 <lambdabot> ($ y)
08:45:30 <ihope> (\x -> 2 x)
08:45:34 <ihope> > (\x -> 2 x)
08:45:34 <lambdabot>  add an instance declaration for (Num (t -> t1))
08:45:34 <lambdabot>   In a lambda abstraction: \ x -> 2 x
08:45:34 <lambdabot>   In the definition of `zsj': zsj = (\ x -> 2 x)
08:45:36 <dons> right. sounds like a problem for someone with a ppc 64 to solve :)
08:45:42 <ihope> ;-)
08:45:46 <dcoutts> dons, indeed, do you know any?
08:45:55 <dcoutts> any such people I mean
08:45:59 <ihope> @type \x -> 2 x
08:46:00 <lambdabot> forall t t1. (Num (t -> t1)) => t -> t1
08:46:02 <dons> nope.
08:46:07 <dcoutts> oh well :-)
08:46:21 <dons> ah, does debian now call amd64 "amd64", not x86-64 :)
08:46:32 <dcoutts> I believe so
08:46:34 <dons> they came around to the openbsd way of doing things :)
08:47:42 <dcoutts> ppc64 ABI has this funny TOC thing which stores pointers to global vars but it's only bit enough for 8k entries so if you have more than 8k global vars in one ELF binary/sharedlib then it needs special handling
08:47:49 <dcoutts> bit/big
08:48:28 <dcoutts> and the special handling is slow and involves changes to the function call preulde & epilog
08:48:35 <dons> yikes.
08:48:39 <dcoutts> which is what makes the mangler barf
08:48:48 <sethk> question to make sure I understand something correctly.
08:48:58 <sethk> I have this function:    errorCounter = newMVar 0
08:49:00 <dons> yep, I see. ah, but that's just a matter of tweaking the mangler a bit
08:49:03 <Phyx-> @type foldr
08:49:03 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
08:49:20 <sethk> references other than the first to errorCounter will return the existing MVar, not create a new one?  correct?
08:49:21 * dons get some breakfast.
08:50:32 <dcoutts> dons, I had someone who knows perl look into it and it doesn't seem that trivial. The TOC is loaded into a special register and so the mangler has to preserve that setup when it strips off the rest of the prelude & epilog (I think).
08:50:56 <dcoutts> we really need a ppc64 + ghc expert
08:50:59 <ihope> I'd love to gets some breakfast...
08:51:09 <dcoutts> I don't think there are many such people about :-)
08:53:05 <ihope> How about a "forsome" operator thingy?
08:53:25 <sethk> another question.  actually the same question in another form.  In the haddock for Control.Concurrent, they show an example of a global array of MVar (specifically MVar thread id).  Why is unsafePerformIO needed?  It's the second line after "a better method is to keep a global list of all child threads..."
08:53:38 <ihope> something :: forsome a. a
08:54:08 <Pseudonym> Do you mean "exists"?
08:54:56 <ihope> ...What is it?
08:55:02 <Pseudonym> Well, we used to have it.
08:55:12 <ihope> It no longer exists? ;-)
08:55:16 <Pseudonym> GHC has alternately had it and not had it for a while now.
08:56:22 <ihope> @type concatMap
08:56:23 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
08:56:32 <ihope> concatMap == (=<<)?
08:57:46 <Pseudonym> http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
08:58:22 <Pseudonym> Unfortunately, existential types here are spelled as "forall".
08:58:26 <Pseudonym> Which is a bit confusing.
08:58:41 <dons> sethk, you need unsafeePerformIO so that the commpiler thinks it's a pure computation, and shares the result. so you get the same one back each time. otherwise, your errorCounter is like putStrLn, you'll get a new one each time
08:58:56 <Pseudonym> It makes sense because it's the correct type of the data constructor.
08:59:00 <dons> (you're doing the evil global variables hack?)
08:59:06 <sethk> dons, that's what I needed to know, thanks.
08:59:10 <Pseudonym> However, when UNpacked, the data has an existential type.
08:59:20 <sethk> dons, I'm doing it with a slightly different context but that's the behavior I need.
08:59:43 <dons> sethk, in fact, you have to go one step further, and prevent the compiler from inlining (and duplicating your mvar):
08:59:46 <dons> state = unsafePerformIO $ newMVar emptyEditor
08:59:48 <dons> {-# NOINLINE state #-}
09:00:01 <dons> well, that's from Yi, but you get the picture. 
09:00:14 <sethk> dons, why isn't that necessary in the example in control.concurrent?
09:01:22 <dons> hmm. maybe they know that ghc won't inline such an expensive computatoin? and avoid it for clarity?
09:01:33 <ihope> @type runState
09:01:33 <lambdabot> Not in scope: `runState'
09:01:39 <ihope> @type Control.Monad.State.runState
09:01:40 <lambdabot> forall s a.
09:01:40 <lambdabot>            Control.Monad.State.State s a -> s -> (a, s)
09:02:04 <sethk> dons, oh, so in fact I do need it, or at least I might
09:02:11 <dons> yes. it won't hurt.
09:02:13 <sethk> dons, I used not that code but the same idea in another spot
09:03:20 <sethk> dons, the pragma isn't location sensitive?  It can go before the definition, or after?
09:04:31 <ihope> The IRC module, she is not yet done.
09:06:51 <ihope> I'm going to add a data thingy containing all possible IRC commands as its values.
09:07:11 <ihope> ...Then again, I really don't need to.
09:08:34 <dons> sethk, yeah. either place.
09:11:38 <dons> ihope, it's a good idea.
09:11:48 <ihope> Maybe later...
09:11:49 <dons> it means you can't construct a bogus irc command.
09:12:00 <ihope> Hmm, good point.
09:14:25 <xerox> ihope: yes, |concatMap = (=<<)|, because |instance Monad [a] where return x = [x]; xs >>= f = concatMap f xs|.
09:14:38 <ihope> Okay. Thanks.
09:15:04 <ihope> Is there any syntactic sugar for wrapping a string over multiple lines?
09:15:19 <xerox> \
09:15:26 <ihope> Um...
09:15:29 <ihope> "foo\
09:15:33 <ihope> bar" -- that?
09:15:39 <xerox> Something like that IIRC.
09:18:33 <dons> what are your goals with your new irc bot, ihope/ as an exercise? or is there soemthing you disklike abut lambdabot that it needs rewriting?
09:19:07 <ihope> Well, I wanted to start from scratch, so I knew just what was "inside" my bot.
09:19:30 <ihope> And I've never written a "real" Haskell program before :-)
09:20:02 <ihope> @type (id :: String -> Char) :: a -> a
09:20:03 <lambdabot>   Couldn't match `Char' against `String'
09:20:03 <lambdabot>   Expected type: String -> Char
09:20:07 <dons> cool.
09:20:13 <ihope> @type (id :: String -> String) :: a -> a
09:20:14 <lambdabot>   Couldn't match the rigid variable `a' against `String'
09:20:14 <lambdabot>   `a' is bound by the polymorphic type `forall a. a -> a' at <interactive>
09:20:14 <lambdabot> :1:0-33
09:20:23 <ihope> @type (id :: String -> String) :: Char -> Char
09:20:24 <lambdabot>   Couldn't match `String' against `Char'
09:20:24 <lambdabot>   Expected type: Char -> Char
09:20:43 <xerox> @type (id :: String -> String)
09:20:44 <lambdabot> String -> String
09:21:28 <dons> @type (id :: a -> a) :: () -> ()
09:21:29 <lambdabot> () -> () :: () -> ()
09:23:32 <ihope> @index hIsEOF
09:23:33 <lambdabot> System.IO
09:23:50 <ihope> @index withSocketsDo
09:23:51 <lambdabot> Network.Socket, Network
09:24:48 <xerox> @type let a@b = a b in a
09:24:48 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
09:24:48 <lambdabot>   Expected type: t1 -> t
09:25:36 <ihope> a@b = a b?
09:25:49 <ihope> That's...
09:25:53 <ihope> a = a b; b = a b
09:29:02 <xerox> @type let f x = x f in f
09:29:02 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t1) ->
09:29:02 <lambdabot> t1
09:29:02 <lambdabot>   Expected type: t
09:29:14 <ihope> Ow ow ow ow ow.
09:29:32 <ihope> @pl f x = x f
09:29:33 <lambdabot> f = fix (flip id)
09:29:49 <ihope> @type fix
09:29:50 <lambdabot> Not in scope: `fix'
09:30:01 <ihope> @type Control.Monad.Fix.fix -- Grr.
09:30:02 <lambdabot> forall a. (a -> a) -> a
09:30:08 <ihope> @type flip id
09:30:08 <lambdabot> forall b c. b -> (b -> c) -> c
09:30:11 <xerox> Ah, the infamous flip id.
09:30:30 <ihope> flip id param func = func param
09:30:48 <dons> it's a bit annoying that you have to import Monad to get the pure: 
09:30:48 <dons> fix :: (a -> a) -> a
09:30:51 <dons> fix f = let x = f x in x  
09:31:00 <ihope> Yep.
09:31:03 <dons> should be in the prelude
09:31:03 <xerox> > let ($<) = flip id in 1 $< (+1)
09:31:04 <lambdabot> 2
09:31:18 <ihope> It's your, bot, dons, correct?
09:31:21 <ihope> Put it there >:-)
09:31:31 <dons> mostly, yes.
09:31:53 <dons> oh, for @type.
09:32:53 <ihope> @type \a b c -> a ++ b : c
09:32:54 <lambdabot> forall a. [a] -> a -> [a] -> [a]
09:33:06 <designdream> what projects are haskell primarily used in?
09:33:06 <ihope> @type \a b c -> a ++ (b : c)
09:33:06 <lambdabot> forall a. [a] -> a -> [a] -> [a]
09:33:15 <ihope> @type \a b c -> (a ++ b) : c
09:33:16 <lambdabot> forall a. [a] -> [a] -> [[a]] -> [[a]]
09:33:40 <xerox> @type let a x = x y; y x = x a in a
09:33:41 <lambdabot>   Occurs check: cannot construct the infinite type:
09:33:41 <lambdabot>   t = (((t -> t2) -> t2) -> t1) -> t1
09:35:15 <ihope> So, if f x = x f, then f = ($ f).
09:35:36 <ihope> In that up there, a = ($ y) and y = ($ a).
09:37:59 <ihope> y = ($ ($ y))
09:38:15 <ihope> @pl y = ($ ($ y))
09:38:16 <lambdabot> y = fix (flip id . flip id)
09:43:38 <ihope> Does doing a :reload in GHCi reload everything the current module depends on?
09:44:57 <ihope> Aha...
09:45:27 <ihope> I somehow managed to miss some error that happened to occur in the bit of my code that happened to be unreadable.
09:46:03 <ihope> Luckily that was easy to fix.
10:00:27 <ihope> Urmp.
10:00:39 <ihope> No instance for (Num PortID)...
10:01:16 <ihope> Aha!
10:01:34 <jethr0> good evening dons
10:02:54 <ihope> @index State
10:02:55 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.
10:02:55 <lambdabot> Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.
10:02:55 <lambdabot> ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec, Text.
10:02:55 <lambdabot> ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
10:03:11 <ihope> > Control.Monad.State.State
10:03:11 <lambdabot>  Not in scope: data constructor `Control.Monad.State.State'
10:03:16 <ihope> ?
10:03:22 <ihope> @hoogle State
10:03:23 <lambdabot> Test.HUnit.Base.State :: State
10:03:23 <lambdabot> Test.HUnit.Base.State :: Path -> Counts -> State
10:03:23 <lambdabot> Control.Monad.State.State :: State s a
10:03:38 <jethr0> ihope: what're you looking for?
10:03:47 <ihope> I'm looking for the State constructor.
10:04:01 <ihope> Would it be possible to have my IRC module export that along with everything else
10:05:03 <jethr0> ihope: you don't mean StateT, no? i must admit i'm not very proficient with state monads yet...
10:05:12 <jethr0> ihope: you working on lambdabot?
10:05:16 <ihope> Nope.
10:05:24 <ihope> Isn't StateT a monad transformer?
10:05:32 <jethr0> can i help with your irc module?
10:06:07 <jethr0> @type Control.Monad.State.State
10:06:08 <lambdabot> forall a s.
10:06:08 <lambdabot>           (s -> (a, s)) -> Control.Monad.State.State s a
10:06:31 <jethr0> ihope: yes
10:09:26 <ihope> Okay, my program is currently running...
10:09:44 <ihope> ...and not doing anything...
10:09:52 <ihope> ...and quitting.
10:11:48 <ihope> Aha!
10:12:40 <ihope> PortNumber 6667 does actually represent port number 6667, correct?
10:17:27 <ihope> @type System.IO.waitForInput
10:17:28 <lambdabot> Not in scope: `System.IO.waitForInput'
10:17:34 <ihope> @index waitForInput
10:17:34 <lambdabot> bzzt
10:19:02 <ihope> @type System.IO.hWaitForInput
10:19:03 <lambdabot> GHC.IOBase.Handle -> Int -> IO Bool
10:25:27 <ihope> Well, jethr0, I suppose you can help me.
10:25:38 * ihope mailing-list-ificates
10:27:35 <ihope> @where mailing list
10:27:35 <lambdabot> I know nothing about mailing.
10:27:43 <ihope> @where cafe
10:27:44 <lambdabot> I know nothing about cafe.
10:27:48 <ihope> Mmh.
10:27:53 <jethr0> ihope: sry, was shortly away
10:28:02 <jethr0> ihope: what does your code do?
10:28:37 <ihope> It connects to an IRC server and handles the I/O aspect of things.
10:28:38 <dons> ihope, check haskell.org
10:28:47 <dons> there's a link to "Mailing list" from there
10:29:18 <dons> ihope, have you improved the lambdabot code, or rewritten it? is there any chance your improvements could go back in to lamdabot?
10:29:28 <ihope> I've rewritten it.
10:29:49 <ihope> I'm not sure if these could be considered "improvements", other than the fact that it's all one module ;-)
10:29:58 <ihope> So to mail the list, I just fire one off to So to post stuff, would I just email haskell@haskell.org??
10:30:09 <ihope> Whoopsie, clipboard boochery...
10:30:09 <dons> haskell-cafe@haskell.org probably
10:30:21 <dons> unless you ae annoucing something
10:30:21 <jethr0> ihope: have you addressed the problem of losing connection and not being aware of it?
10:30:34 <dons> yeah, that'd be a good one to fix.
10:30:39 <ihope> :-)
10:30:45 <ihope> Hmm... well, the program doesn't actually ao anything yet.
10:30:50 <jethr0> i'm not sure if it's a generic IRC protocol problem, but it would sure be nice to fix that; and if it was only some quick heuristic hack...
10:31:09 <ihope> What sort of IRC protocol problem?
10:33:16 <jethr0> ihope: when connection to the server is lost (split, disconnect, ??) the current lambdabot implementation doesn't realize this and will never reconnect
10:33:33 <ihope> Hmm, makes sense.
10:33:52 <ihope> But I don't see why it would just disconnect like that. I stayed connected with this client ;-)
10:33:58 <jethr0> hmm, actually the protocol should be able to handle this (although i don't know if it does). but it sure can be annoying
10:34:18 <jethr0> irssi solves this by pinging once every N time units to see if it's still connected
10:34:38 <ihope> Hmm...
10:34:48 * ihope modifies
10:35:04 <ihope> Oops...
10:35:15 <ihope> How'd that happen?
10:35:23 <ihope> Oh...
10:36:01 <ihope> Maybe the problem is that it's not getting the NICK command in before it connects.
10:38:35 <ihope> Ah well.
10:38:36 * ihope posts
10:40:37 <jethr0> dons: ping
10:40:40 <dons> yo
10:41:18 <jethr0> i'm looking for stuff to do. as it's only 2am :). any wiki stuff or (even better) anything to code for me?
10:42:10 <dons> hmm. thinking..
10:42:29 <ihope> I'm gonna post this IRC thing really soon now...
10:42:38 <ihope> Any day now!
10:42:42 <jethr0> ihope: post where?
10:42:50 <ihope> haskell-cafe
10:43:27 <dons> musasabi, int-e suggested a faster tweak to pidigits shootout entry, can you submit it: http://haskell.org/hawiki/PidigitsEntry
10:43:39 <dons> jethr0, what do you want to work on? lambdabot?
10:43:50 <ihope> Lambdabot already works!
10:44:02 <dons> well, it has bugs
10:44:04 <dons> a couple
10:44:08 <dons> and it has a todo list
10:44:32 <jethr0> dons: sth small, lambdabot is still a little scary to me. like a shootout entry or some cool (easy) project you've been wanting to do for a long time, but never got around to :)
10:44:58 <musasabi> dons: I'll look at it in the morning.
10:45:03 <dons> hmm. ok, let me see. I'd like an introduction to existentials written for the new wiki?
10:45:13 <dons> musasabi, cheers.
10:45:29 <dons> an os x version of hmp3 to be built?
10:45:43 <dons> do you use os x?
10:45:47 <dons>  (jethr0)
10:45:58 <jethr0> nope
10:46:18 <dons> ok, hmm. shootout hack eh?
10:46:19 <jethr0> but maybe i'll have a look at existentials and write something as i go.
10:46:29 <jethr0> any good examples in mind for existentials?
10:47:08 <dons> we have a good example written, but no intor as to what they are. but it might require some type system knowledge.
10:47:44 <jethr0> hmm, i've been wanting to look into existentials anyways. let me see if i *get* them...
10:47:52 <dons> however, there's a lot of stuff on the old wiki that needs to be rewritten for the new wiki
10:47:56 <dons> a lot of idioms.
10:48:23 <dons> do you have some favourite haskell coding trick youu'd like to write a few paragraphs about?
10:48:49 <dons> heres the old wiki page for idioms: http://haskell.org/hawiki/CommonHaskellIdioms
10:48:54 <dons> and the new wiki page:
10:48:56 <dons> @wiki Idioms
10:48:56 <lambdabot> http://www.haskell.org/haskellwiki/Idioms
10:49:18 <dons> now, there's a lot on the old list that need to be _rewritten_ to appear on the new wiki.
10:49:40 <jethr0> dons: i've quite often would have like a more extensive collection of "idioms". like for fold and unfold, sequence, etc.
10:49:55 <jethr0> all the cool tricks appearing here in the channel from time to time, but never really kept.
10:49:58 <jethr0> like:
10:50:31 <dons> hmm. interesting. maybe you could write up a list of tricks and suggestions found on the #haskell channel?
10:50:44 <dons> you could go back through the logs, picking out cool suggestions
10:51:03 <dons> (ie. grep for '?' questions, and see if they're goood code answers)
10:51:13 <jethr0> > foldr (\a (x,y) -> (a:y,x)) ("","") "abcdefg"
10:51:14 <lambdabot> ("aceg","bdf")
10:51:19 <dons> and then log them to a Idiom page
10:51:22 <jethr0> i really like that one :)
10:51:49 <ihope> :-)
10:51:53 <dons> so, more of a cook book then?
10:51:56 <ihope> > foldr (\a (x,y) -> (a:y,x)) ("","") "abcdefgh"
10:51:57 <lambdabot> ("aceg","bdfh")
10:52:12 <jethr0> dons: that's like millions of lines, and 99% of the code lines are crap. maybe i'll start sth like the monad reader with requests to people to add their favorite (smart) idiom
10:52:34 <jethr0> dons: well, not so much a cookbook in being problem-driven, but rather a collection of how to solve recurring problems.
10:52:56 <dons> well, I do like the idea of a QandA or FAQ page for common tricks and solns
10:53:14 <dons> like "Q. How to split a string"  and so on.
10:53:20 <jethr0> > map snd . sort . map (length &&& id) $ ["a", "bc", "def"]
10:53:21 <lambdabot> ["a","bc","def"]
10:53:30 <jethr0> grmpf
10:54:16 <jethr0> dons: maybe i'll start sth like that. but as my attention span, motivation time span is _severely_ limited, i might not come so far :)
10:55:06 <dons> ok. but you could start a page? that's what wikis are for.
10:55:07 <jethr0> dons:  a faq might also make sense for the most commonly asked channel questions ("how do i get the string out of IO String"), but i think you've got a wiki page for that already, no?
10:55:10 <ihope> > (&&&)
10:55:11 <lambdabot>   add an instance declaration for (Show (a b c -> a b c' -> a b (c, c')))
10:55:36 <jethr0> dons: i will. and i'll try to populate it with some good examples
10:55:38 <dons> well, I like the idea of just posting cool one liners, and a sentence saying what they solve or do.
10:56:02 <dons> what would we call such a page? it's important to give it a reasonable name.
10:56:16 <jethr0> i just love showing off things like sequence on list monad :)
10:56:35 <jethr0> dons: i think those are idioms, but that's already taken
10:56:45 <jethr0> calling them "pearls" is going a bit too far
10:57:07 <dons> "Tips and tricks" "One liners"? It should be a page _under_ the Idioms category, see here http://haskell.org/haskellwiki/Category:Idioms
10:57:13 <jethr0> IdiomaticSolutions?
10:57:34 <dons> nah, to general, if you look at the wiki it wouldn't fit with the current hierarchy
10:57:49 <dons> since these are short examples, right?
10:58:15 <jethr0> hmm, but nobody's ever going to look under "OneLiners" when looking for a solution to a problem...
10:58:28 <jethr0> i guess i'll start collecting examples and worry about the name later :)
10:58:35 <dons> well, you can just hope newbies will read the wiki.
10:59:02 <dons> yeah. true. maybe once you've got a good list, you can stick it on the public wiki.
11:00:52 <sili_> Write a datatype Tuple which can hold one, two, three or four elements,
11:00:52 <sili_> depending on the constructor (that is, there should be four constructors, one for each
11:00:55 <sili_> number of arguments). Also provide functions tuple1 through tuple4 which take a
11:00:58 <sili_> tuple and return Just the value in that position, or Nothing if the number is invalid
11:01:01 <sili_> (i.e., you ask for the tuple4 on a tuple holding only two elements).
11:01:02 <sili_> sorry, i thought that'd paste as 1 line. anyone wanna help me with that?
11:02:17 <dons> ah, sounds like a homework question :)
11:02:23 <sili_> dons: no, i'm reading a tutorial
11:02:26 <jethr0> sili_: that's a question from yaht, right?
11:02:29 <sili_> jethr0: yes.
11:02:44 <jethr0> yup, there was someone asking the exact same question some time ago
11:02:48 <dons> do you know how to declare a new data type?
11:03:02 <jethr0> sili_: wasn't there a restriction on having to use "Either"?
11:03:04 <dons> and what they mean by a "constructor" ?
11:03:09 <sili_> data Tuple a b c d = Tuple4 a b c d | Tuple3 a b c | Tuple2 a b | Tuple1 a -- or something
11:03:15 <dons> right.
11:03:16 <sili_> jethr0: that's the second question
11:03:53 <jethr0> ah
11:04:51 <dons> ok, so what part of the problem is causing you trouble, sili_?
11:05:46 <jethr0> dons: what's the shortest way of writing "sequence ["12", "34"]" with "bind"?
11:05:55 <sili_> dons: the tuple1 .. tuple4 functions. I don't know how to access the stuff in the object
11:06:04 <dons> jethr0, with >>= ?
11:06:08 <jethr0> yup
11:07:26 <ihope> I'm guessing "12" >> "34" >> [()]
11:07:39 <sili_> dons: i also don't know how to check whether what type of Tuple I have -- is it a Tuple4 or Tuple2?
11:07:49 <sili_> s/whether//
11:07:54 <ihope> sili: tuple1 (Tuple1 a) = a
11:08:02 <ihope> tuple1 (Tuple2 a b) = a
11:08:04 <ihope> etc.
11:08:08 <dons> ihope, wouldn't that be fore sequence_ ?
11:08:15 <ihope> Oh yeah.
11:08:49 <ihope> Drop the >> [()] at the end, I guess.
11:08:50 <dons> > "a" >>= \a -> "b" >>= \b -> return [a,b]
11:08:51 <jethr0> i though it would be sth easy like ""12" >>= "34" >>= join", but it  seems i'll have to use ugly lambdas
11:08:51 <lambdabot> ["ab"]
11:09:13 <dons> you need to name the components, look at the defin of sequence.
11:09:15 <ihope> Oh.
11:09:16 <sili_> ihope: it wants me to do some logic. if tuple4 is called with a Typle3, return something different
11:09:19 <jethr0> k
11:09:31 <dons> @pl "a" >>= \a -> "b" >>= \b -> return [a,b]
11:09:31 <lambdabot> ['a' : return 'b']
11:09:32 <ihope> tuple4 (Tuple3 a b c) = Nothing
11:09:49 <ihope> s/= a/= Just a/ in my examples above
11:10:23 <sili_> ihope: isn't there a catchall? like I write a tuple4 (Tuple4 a b c d) = a; then tuple4 (everything that doesn't match) = Something
11:10:29 <dons> tuple4  (Tuple4 ...) = the right answer ; tuple4 _ = Nothing
11:10:36 <sili_> aha.
11:10:43 <dons> yep, a wild card pattern
11:10:45 <sili_> that's right, _ is the magic...
11:11:30 <dons> well, it's just like saying: tuple4 x = Nothing -- it matches everything too
11:11:43 <dons> but _ is easier on the eye.
11:12:09 <sili_> dons: would that match if I called tuple4 with no arguments?
11:12:20 <ihope> Nope.
11:12:22 <jethr0> or "tuple4 x | (Tuple4 a b c d) == x = Just d | otherwise = Nothing"
11:12:31 <ihope> Calling tuple4 with no arguments gives tuple4.
11:13:02 <dons> exactly, hooray for partial application :)
11:13:11 <dons> sili_, try it in ghci (or hugs)
11:13:34 <dons> (what Haskell implementation are you using, btw?)
11:13:34 <ihope> It's impossible to make a function that when applied to nothing returns something other than itself...
11:13:57 <sili_> hmm. no get_time function?
11:14:01 <jethr0> ihope: due to referential transparency that's a paradox
11:14:21 <jethr0> ihope: if it returned sth else than itself, it would be /= itself
11:14:51 <jethr0> sry, read that as a question...
11:18:37 <dons> @vote Which_Haskell_implementation_do_you_use? NHC
11:18:38 <lambdabot> voted on "NHC"
11:18:43 <dons> a poll! 
11:18:58 <dons> use @vote to vote on which Haskell implementationn you use.
11:19:15 <dons> @poll-show Which_Haskell_implementation_do_you_use?
11:19:15 <lambdabot> ["UHC","JHC","HBC","NHC","YHC","Hugs","GHC/GHCi"]
11:19:37 <dons> @poll-result Which_Haskell_implementation_do_you_use?
11:19:38 <lambdabot> Poll results for Which_Haskell_implementation_do_you_use? (Open): UHC=0,
11:19:38 <lambdabot> JHC=0, HBC=0, NHC=1, YHC=0, Hugs=0, GHC/GHCi=1
11:20:04 <dons> polls close 00.00 GMT (i.e. 23 hours)
11:20:43 <jethr0> @poll-show
11:20:44 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
11:20:55 <dons> @poll-show Which_Haskell_implementation_do_you_use?
11:20:56 <lambdabot> ["UHC","JHC","HBC","NHC","YHC","Hugs","GHC/GHCi"]
11:21:07 <jethr0> dons: are there other open polls?
11:21:16 <dons> @poll-list all
11:21:16 <lambdabot> ["Which_Haskell_implementation_do_you_use?"]
11:21:19 <jethr0> @vote Which_Haskell_implementation_do_you_use? GHC
11:21:20 <lambdabot> "GHC" is not currently a candidate in this poll
11:21:27 <jethr0> @vote Which_Haskell_implementation_do_you_use? GHC/GHCi
11:21:27 <lambdabot> voted on "GHC/GHCi"
11:21:30 <dons> GHC/GHCi is the candidate
11:22:45 <sili_> how would i write a show for my Tuple type? I was thinking show (Tuple a b c d) = Prelude.show (a,b,c,d)  -- but that results in Not in scope: data constructor `Tuple'. any suggestions?
11:23:04 <dons> why not write: deriving Show   :)
11:23:09 <dons> and get your code for free.
11:23:30 <sili_> ?
11:23:40 <dons> data Tuple .... = .... deriving Show
11:23:58 <dons> and the compiler generate a 'show'instance for you.
11:24:31 <dons> it's a cool feature.
11:24:41 <dons> yay, darcs 1.0.6 is out.
11:24:46 <sili_> maybe for you. i just get crashes 
11:24:57 <sili_> :p
11:25:10 <dons> what  compiler or interpreter are you using?
11:25:19 <sili_> ghc
11:25:21 <sili_> ghci
11:25:42 <jethr0> what was that function that did "(takeWhile p &&& dropWhile p)"?
11:25:44 <dons> crashes?
11:25:51 <sili_> data Tuple a b c d = Tuple4 a b c d | Tuple3 a b c | Tuple2 a b | Tuple1 a deriving Show -- i'm probably doing something stupid
11:26:07 <dons> data Tuple a b = T1 a
11:26:08 <dons>                | T2 a b deriving Show
11:26:10 <dons> works for me
11:26:16 <dons> *Main> show (T1 7)
11:26:18 <sili_> oh wait. i see what i did wrong
11:26:20 <dons> "T1 7"  
11:26:25 <sili_> ya, forget my parens for the show
11:26:37 <dons> ah, so not a crash. a type error?
11:26:39 <jethr0> should work w/o parens, no?
11:26:43 <sili_> dons: pebkac
11:26:51 <dons> show $ T1 7 would.
11:27:16 <sili_> so that's what $ does? or is there more to it than that?
11:27:51 <ihope> Well...
11:28:01 <dons> nope, it's just a low-precedence application, so it saves some parens.
11:28:06 <ihope> Yep.
11:28:07 <dons> @type ($)
11:28:08 <lambdabot> forall b a. (a -> b) -> a -> b
11:28:26 <dons> > negate $ 8
11:28:27 <lambdabot> -8
11:28:30 <dons> > negate 8
11:28:30 <lambdabot> -8
11:28:32 <sili_> that's what i said.
11:28:34 <dons> > negate (8)
11:28:35 <lambdabot> -8
11:28:46 <ihope> I never use $ for the fact that it's low-precedence.
11:29:04 <dons> i always use it for the fact it saves parens
11:29:05 <ihope> Wherever I use it, I think `id` would do just as well.
11:29:14 <dons> > negate `id` 8
11:29:15 <lambdabot> -8
11:29:18 <dons> quite so.
11:29:24 <ihope> dons: ever do stuff like \x -> ($ x)?
11:29:34 <dons> ah, only if @pl suggests it :)
11:29:39 <ihope> Or maybe map ($)?
11:29:42 <sili_> what does that do
11:29:51 <sili_> ($) or ($ x)
11:30:01 <ihope> ($) is pretty much the same as id.
11:30:15 <ihope> ($ x) is a function which applies its argument to x.
11:30:19 <dons> I often use it for: someIOthing takes_a_thing $ \the_thing -> do chomp it up some how
11:30:28 <ihope> ($ x) = \y -> y x
11:30:30 <ihope> @vote Which_Haskell_implementation_do_you_use? GHC/GHCi
11:30:30 <lambdabot> voted on "GHC/GHCi"
11:31:28 <sili_> confusing. i guess i'll get to that stuff later
11:32:35 <ihope> Well, are you familiar with `foo` operators?
11:33:02 <sili_> no, but i heard you could do 8 `mod` 4
11:33:44 <dons> right. you can take any function, wrap it in `` and it becomes infix.
11:33:45 <ihope> Yep.
11:33:59 <dons> > map (+1) [1..10]
11:34:00 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
11:34:13 <ihope> It's sort of the reverse of enclosing one in parentheses.
11:34:22 <ihope> An infix operator, that is.
11:34:22 <dons> > (+1) `map` [1..10]
11:34:23 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
11:34:41 <ihope> > 1 `enumFromTo` 10
11:34:42 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
11:35:24 <jethr0> 3 `elem` [1,2,3]
11:35:28 <jethr0> > 3 `elem` [1,2,3]
11:35:29 <lambdabot> True
11:35:44 <sili_> how does    x `mod` y `mod` z  work
11:35:47 <bd_> > 1 `elem` [undefined, 1]
11:35:48 <lambdabot> Undefined
11:35:54 <bd_> > 1 `elem` [1, undefined]
11:35:55 <lambdabot> True
11:35:58 <ihope> I think that's (x `mod` y) `mod` z.
11:36:09 <ihope> Are you familiar with fixity declarations?
11:36:14 <dons> hehe. bd_ :) now we gets tricksy.
11:36:17 <sili_> are you trying to make my brain exploder?
11:36:19 <sili_> -r
11:36:20 <jethr0> isn't mod commutative in this case?
11:36:23 <bd_> :P
11:36:34 <ihope> Commutative? You mean associative?
11:36:42 <jethr0> i always get them mixed up
11:36:50 <bd_> hmm, is there a way to catch the bottom? Something like a -> Either String a ...
11:37:00 <jethr0> bottom?
11:37:12 <ihope> Nontermination, divergence...
11:37:12 <sili_> catchall?
11:37:16 <dons> you can catch the exception that's thrown, yep.
11:37:18 <dons> but do you want to?
11:37:21 <bd_> jethr0: undefined, error "any string", exceptions
11:37:24 <dons> or are you thinking of something else?
11:37:28 <bd_> dons: Just curious really.
11:37:46 * ihope looks at the Report
11:38:06 <bd_> @hoogle catch
11:38:06 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
11:38:06 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
11:38:06 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
11:38:56 <dons> Control.Exception.catch (return $ 1 `elem` [undefined, 1]) $ \e -> return False
11:39:16 <bd_> > Control.Exception.catch (return $ 1 `elem` [undefined, 1]) $ \e -> return False
11:39:16 <lambdabot>  Not in scope: `Control.Exception.catch'
11:39:22 <bd_> blah
11:39:25 <dons> nah. we frown on IO in irc :)
11:39:27 * bd_ goes to open ghci
11:40:20 <bd_> Prelude Control.Exception> print =<< (Control.Exception.catch (return $ 1 `elem` [error "foo", 1]) $ \e -> return False)
11:40:24 <bd_> *** Exception: foo
11:40:26 <bd_> :|
11:40:29 <ihope> There used to be a bug in lambdabot where applying error to an error would result in the "inner" error being printed out "raw".
11:40:36 <dons> hmm. weird.
11:40:53 <bd_> well, the problem's probably that the bottom's getting passed right through
11:40:58 <bd_> needs to be more strict
11:41:04 <bd_> Prelude Control.Exception> print =<< (Control.Exception.catch (return $! 1 `elem` [error "foo", 1]) $ \e -> return False)
11:41:07 <bd_> False
11:41:09 <bd_> :)
11:41:15 <dons> Prelude> Control.Exception.catch (error "foo") $ \e -> putStr "got it\n"
11:41:16 <dons> got it
11:41:16 <ihope> I suppose stuff like error (error "Muahaha\r\nPART #haskell") would actually part from the channel and stuff.
11:41:24 <dons> yeah.
11:41:55 <ihope> All I could do was CTCP :-P
11:42:02 <dons> ihope, wasn't it you who worked this out? and forced me to turn it off?
11:42:07 <dons> right.
11:42:15 <ihope> Well... I guess.
11:42:17 <dons> it was a lambdabot exploit of sorts
11:45:53 <ihope> And you disabled it before I figured out that client-to-client protocol wasn't dealt with server-side ;-)
11:48:23 <dons> hehe
11:48:32 <araujo> Hello!
11:48:55 <CosmicRay> hi araujo
11:49:10 <araujo> hiya CosmicRay !
11:52:20 <jethr0> dons: is there no color markup for haskell code in the new wiki? :'(
12:10:16 <dons> no, but the old wiki had broken markup anyway.
12:10:42 <dons> at least, it broke on a lot of the code I posted
12:12:50 <jethr0> hmm, but i rather like it for it's better readability...
12:13:09 <jethr0> at least differently colored comments and code would be nice
12:13:57 <dons> yes, we should have some highlighting. would you like to investigate how to get haskell code highlighiting in MediaWiki?
12:14:44 <jethr0> :))
12:14:53 <jethr0> i can have a short look
12:15:02 <ihope> Say... does anybody else here actually give the RHS's of their equations 24 columns of space, whether they need it or not?
12:15:25 <dons> 24 columns?
12:15:37 <ihope> Yes.
12:15:39 <dons> f x = rhs. 7 columns :)
12:15:55 <ihope> Looks like 4 to me.
12:16:08 <dons> I count 6 before the letter 'r'
12:16:30 <ihope> I count the = sign and everything after it as being on the RHS.
12:16:34 <ihope> Erm, whoops.
12:16:39 <ihope> s/RHS/LHS/
12:16:53 <dons> ?
12:16:53 <jethr0> http://meta.wikimedia.org/wiki/User:Coffman/Syntax_Highlight
12:17:03 <dons> no i'm confused. ihope.
12:17:32 <ihope> 1 + 2                   = 3
12:17:41 <ihope> 24 columns for the LHS.
12:17:43 <jethr0> ihope: 24 colums seems like too much. i guess it can be hard to associate LHSs with RHSs at that much space
12:17:51 <dons> why would you want to indent 3 times just to get to the rhs? or did you mean lhs all along?
12:17:52 <jethr0> *yuch*
12:17:57 <dons> that's crazy stuff.
12:18:03 <ihope> Yes, I meant LHS.
12:18:11 * ihope abruptly disappears
12:18:18 <dons> where'd this 24 column movement emerge from? :)
12:18:44 <jethr0> ihope: i think i've _never_ used a 24 letter variable. and functions definitions sometimes get longer. it seems like an arbitrary number
12:19:00 <dons> jethr0, so then we need a haskell thingy for this extension?
12:19:12 <jethr0> hmm, seems like it. what did the old wiki use?
12:19:27 <jethr0> dons: maybe i can whip sth up, let me investigate...
12:19:29 <dons> or does enscript support haskell already? maybe it does.
12:19:45 <dons> "/usr/bin/enscript" I bet it already handles haskell
12:19:51 <cpatrick> a2ps certainly does
12:20:32 <cpatrick> though it doesn't output html. hrm.
12:20:52 <dons> if so, then can you post to haskell-cafe@ asking about syntax highlighting on the new wiki? and mention this link?
12:21:04 <dons> and then one of the maintainers of the wiki should install this tihngy.
12:24:05 <jethr0> dons: i'm looking further into it... give me a sec :)
12:24:44 <jethr0> they've got about every imaginable language supported _except_ haskell
12:24:57 <jethr0> http://qbnz.com/highlighter/index.php
12:25:08 <dons> hmm
12:25:16 <dons> how do you add support?
12:25:21 <dons> what's it need to be written in?
12:25:43 <dons> "GeSHi supports PHP5 and Windows" -- what the?
12:25:48 <musasabi> using vim to get syntax highlighting to a postscript file is easy
12:26:18 <musasabi> don't remember whether it supports html
12:26:37 <dons> it does, yep. but we're trying to wokr out how to add syntax highlighting support to the haskell.org wiki, musasabi?
12:26:38 <jethr0> dons: hmm, didn't see that "supports" clause :(
12:26:43 <musasabi> at least there was an elisp thing for syntax highlighting -> html, but that was quite slow.
12:27:25 <jethr0> musasabi: slow might not be the problem. you could convert it only after editing... and it's not likely to be applied to more than a few lines at a time
12:28:46 <jethr0> yup, enscript supports haskell
12:28:48 <dons> jethr0, ah I see. but does this actually integrate with MediaWiki?
12:29:22 <musasabi> I seem to have used the following for syntax highlighting Haskell->Html:
12:29:24 <musasabi> vim -u NONE -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" "$f"
12:30:18 <jethr0> dons: another link, pretty much the same as the first i posted. i guess going with enscript seems the easiest: http://www.wickle.com/wiki/index.php/Syntax_Highlight_extension
12:30:21 <dons> musasabi, I see what you're saying I think. that those who post can colorise their code themselves. but it's not quite the same as wiki support for colors.
12:30:44 <jethr0> http://www.milab.is.tsukuba.ac.jp/~bushuhui/index.php?title=Enhanced_syntax_highlight_extension_for_MediaWiki
12:30:47 <jethr0> spam, spam, spam
12:30:47 <cakoose> Is there a special term for types with kind '*'?
12:31:02 <dons> nice types ? :)
12:31:12 <musasabi> dons: that was a hacky alternative for doing it from inside the wiki, I am using that one in cron-scripts.
12:31:37 <cakoose> Trying to come up with a good name for a method.  Have considered, concrete, base, unit...
12:32:38 <musasabi> then again jethr0 link solves that more elegantly probably.
12:34:36 <dons> yeah, if there's a well-known mediawiki extension, we should probably just use that.
12:34:56 <jethr0> dons: i'm just writing up a post to haskell-cafe about it...
12:36:56 <dons> excellent.
12:43:42 <jethr0> done. although i don't know if the mailing list accepts non-registered users' messages
12:46:43 <sethk> dons, are the pragmas listed in the users guide?
12:48:08 <sethk> dons, nm, I found them.  acroread has search  :)
12:50:52 <sethk> dons, also, it was a while ago, I think we said there is no way to generate the current filename, line number, or function (as with __FILE__, __LINE__, __FUNCTION__ In C) without using a preprocessor.
12:51:59 <dons>  or cpp or m4, yeah.
12:52:24 <sethk> dons, that would be a nice thing to get into the compiler without having to jump those hoops.
12:52:27 <dons> but you can just pass -cpp to ghc. if this is for error messages, you can use 'assert'
12:53:35 <sethk> let me look at assert
12:54:56 <dons> GHC.Base.assert generates line/col numbers
12:54:57 <dons> :m + GHC.BasePrelude> :m + GHC.Base
12:54:58 <dons> Prelude GHC.Base> assert False $ putStrLn "something"
12:54:59 <dons> *** Exception: <interactive>:1:0-5: Assertion failed
12:55:01 <sethk> ok, but there is no way to make that into a trace statement, at least no obvious way
12:55:13 <dons> hmm...
12:55:29 <sethk> doesn't it always result in the exception occuring?
12:55:57 <sethk> if I use -fignore-asserts?
12:56:21 <sethk> I'll have to play with it when I get a chance
12:57:17 <dons> let trace f = System.IO.Unsafe.unsafePerformIO (Control.Exception.catch (assert False $ return ()) (\e -> print e >> return ())) `seq` f
12:57:22 <jethr0> sethk: you want trace with line/col number?
12:57:25 <dons> Prelude GHC.Base> trace (1 + 2)                                                                       <interactive>:1:73-78: Assertion failed
12:57:29 <dons> 3
12:57:37 <dons> Prelude GHC.Base> trace (1 + 2)                                                                       <interactive>:1:73-78: Assertion failed
12:57:38 <jethr0> hehe
12:57:40 <dons> 3
12:57:42 <dons> oh, sorry. double paste.
12:57:47 <sethk> jethr0, yes, without having to use a macro processor, at least explicitly
12:57:56 <jethr0> well, dons just did :)
12:57:59 <dons> that's a trace that gives  you line numbers.
12:58:09 <jethr0> dons: i might take that into my collection of cool solutions :)
12:58:20 <sethk> dons, doesn't exactly make the code look wonderful, though  :)
12:58:33 <dons> well, stick it in a library somewhere.
12:58:57 <dons> did you want a 'trace' that had line numbers? I think that's a fairly reasonable solution.
12:59:08 <sethk> dons, yes, it is.
12:59:47 <sethk> dons, and it wouldn't be too hard to have one version that is really an exception and another that's just a trace
12:59:52 <sethk> dons, using that basic idea
13:00:11 <jethr0> dons: couldn't you put the above inside a "real" trace instead of explicitely calling "unsafePerformIO"?
13:00:34 <jethr0> ah, problems with not being inside IO i guess
13:00:46 <sethk> dons, you are correct, the trace itself is odd, but the calls to it wouldn't look odd.
13:01:00 <sethk> jethr0, that's ok, I seem to always be in IO these days.  :)
13:01:32 <jethr0> dons: btw, when profiling the  regexp entry with chris, we found a weird profiling anomality. sometimes the profiler goes off tangents, doesn't it?
13:01:47 <jethr0> bad sethk :)
13:02:40 <dons> ah, but the 'assert' will always be the position of the 'traace' decl, i think. you'd have to actually pass the assert in to trace as well. hmmm. 
13:02:53 <dons> even better:
13:02:55 <dons> Prelude> let trace assrt f = System.IO.Unsafe.unsafePerformIO (Control.Exception.catch (assrt False $ return ()) (\e -> print e >> return ())) `seq` f
13:02:58 <dons> Prelude> let location = GHC.Base.assert                                                               Prelude> trace location (1+2)                                                                         <interactive>:1:15-29: Assertion failed
13:03:02 <dons> 3
13:03:53 <jethr0> hehe, nice one
13:04:12 <jethr0> that does _two_ unsafePerformIOs, right?
13:04:42 <sethk> I won't remember that, let me paste it.
13:05:02 <sethk> got it
13:05:27 <sethk> indentation question
13:05:36 <sethk> lately I've found that I've been doing this frequently:
13:05:37 <sethk> let
13:05:43 <sethk>         whatever = whatever
13:05:45 <sethk> in do
13:05:48 <sethk>       whatever
13:05:53 <jethr0> > trace assert 2
13:05:54 <lambdabot>  Not in scope: `assert'
13:06:05 <sethk> does the indentation after "in do" have to be to the right of the "do"?
13:07:44 <jethr0> no, but to the right of the in, i think
13:08:05 <sethk> jethr0, yes, that's what I was asking, whether I need to be to the right of in, or both 
13:08:06 <jethr0> doing things _under_ the keyword is mostly ok
13:08:20 <sethk> jethr0, I don't do that because I find it less clear
13:08:30 <jethr0> sethk: i didn't say you had to
13:08:32 <sethk> I would indent most of this even if I didn't have to
13:08:41 <sethk> jethr0, I know
13:08:52 <jethr0> i usually use:
13:09:01 <jethr0> whatever1
13:09:09 <jethr0>   where whatever1 = whatever2
13:09:26 <jethr0> or:
13:09:29 <jethr0> do
13:09:38 <jethr0>   let whatever1 = whatever2
13:09:42 <jethr0>   whatever1
13:09:56 <jethr0> which, in this constructed example is stupid :)
13:20:12 <dons> I've posted the location/assert code here: http://www.cse.unsw.edu.au/~dons/tmp/Location.hs 
13:20:15 <dons> with improvements and examples.
13:25:48 <sethk> dons, thanks, I'll bookmark it
13:28:06 <dons> just improved it a bit. it now dumps to stderr. feel free to steal it.
13:28:13 <sethk> dons thanks
13:28:21 <sethk> if I have code like this:
13:28:24 <sethk> xyz =
13:28:31 <sethk>    | (a==b) = whatever
13:28:37 <sethk>    | otherwise = whatever2
13:28:42 <sethk> can I put at the end:
13:28:44 <sethk> where
13:28:53 <sethk>     something
13:29:03 <sethk> and have that where apply to all the | cases?  I doubt it.
13:32:49 <jethr0> yes
13:33:09 <sethk> I can?  amazing
13:33:30 <jethr0> i'm not sure whether this explanation is valid, but i look at pattern guards as syntactic sugar for a "case" statement
13:34:38 <dons> you can if you use guards. not if you use separate decls. try it.
13:34:58 <sethk> dons, I am about to try it, thanks.
13:35:49 <dons> > let f | 1 == 2 = x + 3 | otherwise = x + 4 where x = 0 in f
13:35:50 <lambdabot> 4
13:51:58 <sethk> dons, that's very convenient
14:03:43 <palomer> ok, how can temp have type ((->) t) in  temp <- seq temp' ?
14:04:13 <jethr0> palomer: seq is a binary function
14:04:22 <sethk> a list comprehension to create a list of length n, filled with anything, say spaces ?
14:04:33 <palomer> @hoogle seq
14:04:34 <lambdabot> Control.Parallel.seq :: a -> b -> b
14:04:34 <lambdabot> Prelude.seq :: a -> b -> b
14:04:34 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
14:04:41 <jethr0> sethk: was that a question?
14:04:48 <palomer> ah, righto, I wanted to use sequence
14:04:50 <palomer> what does seq do?
14:05:05 <jethr0> > replicate 10 ' '
14:05:06 <lambdabot> "          "
14:05:14 <jethr0> > [x | x <- replicate 10 ' ']
14:05:15 <lambdabot> "          "
14:05:23 <sethk> jethr0, replicate, thanks
14:05:38 <jethr0> palomer: seq evaluates its first argument to normal form and returns the value of its second
14:06:00 <jethr0> palomer: what would you like to do?
14:06:05 <pundai> >@type \x -> x*x 
14:06:12 <pundai> > @type \x -> x*x 
14:06:12 <lambdabot>  parse error on input `@'
14:06:21 <pundai> how do you make it tell you the type
14:06:34 <pundai> > type \x -> x*x
14:06:34 <lambdabot>  parse error on input `type'
14:06:50 <palomer> but, erm, seq seems pretty useless
14:06:57 <palomer> seems like const to me
14:06:58 <jethr0> @type \x -> x*x
14:06:59 <lambdabot> forall a. (Num a) => a -> a
14:07:02 <pundai> ok
14:07:14 <pundai> so why is the typ eo fthat Num a but let f = \x -> x*x becomes Int
14:07:18 <jethr0> palomer: it makes its first argument strict
14:07:29 <jethr0> > undefined `seq` 5
14:07:30 <lambdabot> Undefined
14:07:34 <jethr0> > 5
14:07:35 <lambdabot> 5
14:07:36 <pundai> @let f = \x -> x*x; @type f
14:07:37 <lambdabot> lShell module failed: Prelude.init: empty list
14:07:39 <palomer> > const undefined 5
14:07:40 <lambdabot> Add a type signature
14:07:40 <pundai> damnit
14:07:44 <palomer> > const undefined 5::Int
14:07:45 <lambdabot> Undefined
14:07:47 <pundai> > let f = \x -> x*x; @type f
14:07:47 <lambdabot>  parse error on input `@'
14:07:50 <pundai> i suck
14:08:03 <jethr0> @type let f = \x -> x * x
14:08:04 <palomer> > flip . const $ undefined 5
14:08:05 <lambdabot> not an expression: `let f = \x -> x * x'
14:08:05 <lambdabot>  add an instance declaration for (Show (b -> a -> c))
14:08:10 <jethr0> @type f = \x -> x * x
14:08:11 <lambdabot> parse error on input `='
14:08:15 <jethr0> ah
14:08:40 <jethr0> palomer: if you want to make sure that a value is evaluated, use "seq".
14:08:56 <jethr0> > let f x y = y in f undefined 5
14:08:57 <lambdabot> 5
14:09:02 <jethr0> > let f x y = x `seq` y in f undefined 5
14:09:03 <lambdabot> Undefined
14:09:09 <jethr0> > let f x y = x `seq` y in f 4 5
14:09:09 <pundai> jethr0, so any idea?
14:09:10 <lambdabot> 5
14:09:22 <jethr0> @type f x = x * x
14:09:23 <lambdabot> parse error on input `='
14:09:34 <jethr0> pundai: type only takes expressions, i think
14:09:55 <jethr0> but "\x -> x*x" is the same as "f x = x*x" in regards to the type anyways
14:10:06 <pundai> but isnt Num more general
14:10:28 <jethr0> huh?
14:10:54 <pundai> like you can't evaluate f 10.0 in the above
14:10:59 <pundai> but there should be no reason you can't
14:11:12 <jethr0> @type \x -> x*x
14:11:13 <lambdabot> forall a. (Num a) => a -> a
14:11:26 <jethr0> 10.0 is a Num
14:11:28 <pundai> yes
14:11:32 <jethr0> so?
14:11:35 <pundai> @type let f = \x -> x*x
14:11:36 <lambdabot> not an expression: `let f = \x -> x*x'
14:11:39 <pundai> damnit
14:11:44 <pundai> anyway the type of that is Int -> Int
14:11:45 <pundai> why
14:11:51 <palomer> hrm
14:11:52 <jethr0> who says so?
14:11:55 <palomer> it seems that my type system is crap
14:11:59 <palomer> this sucks
14:12:08 <pundai> jethr0, ghci
14:12:30 <pundai> @let f = \x -> x*x
14:12:31 <jethr0> pundai: yes, sometimes it defaults to less general than possible types... unfortunately
14:12:31 <lambdabot> lShell module failed: Prelude.init: empty list
14:12:36 <pundai> jethr0, why!
14:12:39 <jethr0> but you can always "fix" this by givin annotations
14:12:52 <jethr0> pundai: i really don't know. ghci seems to suffer more badly from it than ghc
14:13:04 <pundai> oh ok
14:13:09 <pundai> but in haskell it should be Num
14:13:33 <palomer> almost makes me want to give up
14:13:36 <jethr0> the most general type is Num, unless a "parent" of Num also defined (*)
14:13:50 <jethr0> palomer: can i help?
14:14:06 <palomer> jethr0: I wish you could
14:14:14 <palomer> I'll have to tweak it until it works
14:15:04 <jethr0> with type systems, tweaking doesn't always terminate
14:15:49 <palomer> anyone have ghc 6.5 installed?
14:16:48 <palomer> if so, I'd really like to know if http://www.rafb.net/paste/results/LwYKwU24.html compiles
14:27:43 <Cale> palomer: doesn't that have an obvious indentation problem?
14:32:15 <Cale> palomer: It's easy to see that test, supposing that it type checked, would never return Nothing, since the only cases in which it returns Nothing are when another case of it returns Nothing.
14:33:41 <Cale> oh, I see, there's probably supposed to be some extra cases
14:36:34 <Cale> oh, it's just missing a Just
14:37:22 <lisppaste2> Cale pasted "GADT type equality" at http://paste.lisp.org/display/17358
14:37:31 <Cale> palomer: you there?
14:38:52 <palomer> yeah
14:39:07 <palomer> sorry
14:39:09 <palomer> went to eat
14:39:12 <Cale> ah
14:39:38 <palomer> where's the indentation problem?
14:39:53 <Cale> look at my paste
14:40:10 <Cale> (the constructor declarations ought to be inside the data declarations)
14:40:41 <palomer> so I hate to indent the datacontructors?
14:40:53 <palomer> s/hate/had
14:40:57 <palomer> what a freudian slip
14:41:00 <jethr0> @version
14:41:06 <jethr0> grmpf
14:41:52 <lambdabot> lambdabot 3p303, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
14:41:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:42:48 <Cale> palomer: and add a Just
14:42:55 <Cale> You had
14:43:02 <Cale> case test t1 t2 of
14:43:06 <Cale>    Nothing -> Nothing
14:43:11 <Cale>    Just Eq -> Eq
14:43:23 <Cale> the types of the right sides there obviously don't match
14:43:29 <palomer> yeah, that's fine
14:43:56 <palomer> I think
14:44:04 <palomer> I took this from peyton jones' paper
14:44:06 <Cale> hm?
14:44:15 <palomer> http://research.microsoft.com/Users/simonpj/papers/gadt/gadt-pldi.pdf
14:44:16 <Cale> nah, it really has to be
14:44:19 <palomer> page 5
14:44:21 <Cale>    Just Eq -> Just Eq
14:44:43 <Cale> You can't just return something which isn't a Maybe
14:44:49 <palomer> so peyton has a typo?
14:45:05 <jethr0> oh, no, the world is coming to an end :)
14:45:07 <Cale> yeah, looks like it
14:45:17 <palomer> I'll email him
14:49:31 <palomer> yes, my type system works!
14:49:37 <jethr0> congrats
14:50:27 <palomer> peyton jones eat your heart out
14:51:59 <sieni_> Ooh: <3 that must be good: http://research.microsoft.com/Users/simonpj/win32-cheat.html
14:54:49 <palomer> actually, it still doesn't work
14:55:48 <jethr0> :(
14:57:30 <palomer> omg, it works!
14:57:37 <palomer> with a little hacking
14:58:12 <palomer> I can type that function
14:58:46 <dons> @karma+ palomer -- finding a bug in a paper 
14:58:46 <lambdabot> palomer's karma raised to 3.
14:58:59 <palomer> yes!
14:59:02 <palomer> woohoo
14:59:15 <palomer> anyways, if anyone has ghc5 I'd really like to see it type that function properly
14:59:18 <palomer> it's a beast
14:59:30 <Cale> ghc6.5 you mean
14:59:38 <Cale> ghc5 wouldn't accept the GADT
15:00:08 <palomer> yeah, 6.5
15:00:20 <palomer> who's the one who had 6.5 installed last time?
15:00:31 <Cale> maybe Lemmih?
15:00:37 * palomer pokes lemmih
15:05:44 <palomer> ugh, there's a bug in my code
15:05:45 <palomer> oh well
15:06:08 <palomer> Cale: I'm going to upgrade ST so that the strefs are printable and comparable
15:06:17 <palomer> Cale: any suggestions?
15:06:49 <palomer> should I simply do: newtype superSTyref a= (STref a,Int) ?
15:08:00 <palomer> and newtype SuperST s k= StateT (ST s) (Int) k ?
15:08:41 <Cale> palomer: hey, I already did that mostly :)
15:08:58 <palomer> Cale: hmm?
15:09:11 <palomer> you've already implemented this?
15:09:23 <Cale> yes, for you
15:09:36 <palomer> whoa, where is it?
15:10:28 <Cale> I'd originally pasted it somewhere, let me just put it somewhere more stable
15:11:05 <palomer> the wiki!
15:13:17 <pundai> @let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 1
15:13:18 <lambdabot> lShell module failed: Prelude.init: empty list
15:13:21 <pundai> damnit
15:13:24 <pundai> > let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 1
15:13:25 <lambdabot>  parse error on input `}'
15:13:30 <pundai> i broke the interne
15:13:34 <pundai> tt
15:13:55 <Cale> I beat the internet
15:14:03 <Cale> the end guy was hard
15:14:05 <pundai> ok why didnt that parse
15:14:09 <pundai> @ let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 1
15:14:09 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
15:14:09 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
15:14:09 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
15:14:09 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
15:14:09 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
15:14:11 <lambdabot> [8 @more lines]
15:14:20 <pundai> > count2 p l = foldr (\x c -> if p x then c+1 else c) 0 1
15:14:20 <lambdabot>  parse error on input `='
15:14:24 <palomer> that's pretty broken
15:14:27 <palomer> > 2 + 4
15:14:28 <lambdabot> 6
15:14:30 <pundai> ghc accepts it
15:14:38 <Cale> you need a proper expression
15:14:48 <Cale> the bot doesn't maintain state in that way
15:14:48 <palomer> > let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 1 in count2
15:14:48 <pundai> is this a lambda bot thing
15:14:49 <lambdabot>  add an instance declaration for (Show ((a -> Bool) -> t -> b))
15:14:54 <pundai> oh
15:14:56 <Cale> http://www.haskell.org/hawiki/STOMonad
15:15:09 <jethr0> > let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 in foldr even [1]
15:15:10 <lambdabot> Couldn't match `Bool' against `t -> t1'
15:15:18 <palomer> what does STO stand for?
15:15:20 <jethr0> > let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 in ocunt2 even [1]
15:15:21 <lambdabot>  Not in scope: `ocunt2'
15:15:25 <jethr0> > let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 in count2 even [1]
15:15:26 <lambdabot>  add an instance declaration for (Show ([a] -> b))
15:15:27 <Cale> ST Ordered :)
15:15:32 <palomer> ah, nice
15:15:47 <palomer> yeah, you did actually what I was planning to do
15:15:50 <palomer> but much nicer, of course
15:16:00 <jethr0> > let count2 p = foldr (\x c -> if p x then c+1 else c) 0 in count2 even [1]
15:16:01 <lambdabot> 0
15:17:28 <palomer> I would change show ref = "<STORef: " ++ (show (idx ref)) ++ ">" with ref = show $ infseq !! (idx ref)  where infSeq = [replicate k letters | k <- [1..]] >>= sequence   
15:17:29 <palomer>     where
15:17:29 <palomer>       letters = ['a'..'z']
15:19:04 <palomer> modifySTref = a combination of read and write?
15:20:09 <palomer> modifySTRef f s = liftM2 writeSTRef $ liftM f $ readSTRef s  ?
15:22:56 <palomer> @type liftM2
15:22:56 <lambdabot> Not in scope: `liftM2'
15:23:02 <palomer> @hoogle liftM2
15:23:02 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
15:23:02 <lambdabot> r
15:27:47 <pundai> let count2 p l = foldr (\x c -> if p x then c+1 else c) 0 1
15:27:56 <pundai> count2 even [1,2,3,4,5,6] barfs
15:28:11 <pundai>    No instance for (Num [a])
15:28:11 <pundai>       arising from use of `count2' at <interactive>:1:0-5
15:28:11 <pundai>     Probable fix: add an instance d
15:28:44 <palomer> Cale: do you always wrap your monad transformers in this manner?
15:28:53 <Cale> palomer: pretty much, yeah
15:29:11 <Cale> palomer: basically, I force myself to write everything that I'll need right in the one module
15:29:22 <palomer> very smart
15:29:50 <palomer> in the one module?
15:29:54 <Cale> pundai: hmm... count2 doesn't use l
15:30:06 <Cale> palomer: well, all the primitives
15:30:22 <pundai> Cale, doh
15:30:31 <pundai> shouldve been 0 l
15:30:31 <palomer> the one module is the only module using state transformers?
15:30:43 <Cale> pundai: right
15:30:59 * palomer petitions STO be renamed to STI
15:31:01 <pundai> damn monospace 1 and l looking the smae
15:31:08 * pundai petitions using symbols for language
15:31:08 <Cale> palomer: right -- it's the only one with permission to have the type constructor
15:31:24 <palomer> which type constructor?
15:31:26 <Cale> pundai: get a nicer font :)
15:31:31 <pundai> Cale, damn pdf
15:31:31 <Cale> er
15:31:36 <Cale> data constructor I mean
15:31:42 <Cale> STO
15:31:48 <Cale> in this case
15:32:09 <pundai> @type \x -> [x]
15:32:09 <lambdabot> forall a. a -> [a]
15:32:10 <palomer> isn't Monad a subclass of Functor?
15:32:11 <Cale> note that the type STO is exported, but not its constructor
15:32:20 <Cale> palomer: no, not in Haskell 98.
15:32:30 <Cale> (or in GHC either)
15:32:39 <Cale> theoretically, it is
15:32:42 <palomer> is there a reason for this?
15:33:09 <pundai> i wish ghci would report :type using forall
15:33:12 <Cale> Only that there's no way to automatically derive instances of superclasses from base classes
15:34:02 <Cale> pundai: turn on -fglasgow-exts
15:34:11 <Cale> If Functor was a superclass of Monad, you'd be forced to write an instance of Functor before you could start writing your instance of Monad
15:34:13 <pundai> Cale, why is that an extension
15:34:29 <Cale> pundai: because explicit type quantification is new
15:34:36 <Cale> Haskell 98 didn't have it
15:35:05 <jethr0> Cale: care to take a look at my new wiki project? i'm trying to collect a list of helpful/informative/cool haskell idioms: http://haskell.org/haskellwiki/User:JohannesAhlmann
15:35:30 <ayrnieu> dons - ah, sorry, I didn't remember it running on BSD/sparc64.
15:35:39 <pundai> Cale, odd
15:35:43 <palomer> to write an instance of a class, you need to first write all the instances of the superclass?
15:35:43 <Cale> jethr0: cool
15:35:44 <jethr0> it's pretty chaotic still...
15:35:44 <pundai> wouldnt \x -> x imply forall x?
15:36:01 <Cale> pundai: well, normally when you write something like:
15:36:04 <Cale> f :: a -> a
15:36:12 <Cale> It's implied that you mean
15:36:16 <Cale> f :: forall a. a -> a
15:36:20 <pundai> yes
15:36:25 <pundai> wait
15:36:32 <pundai> how do i declare f :: a -> a
15:36:42 <Cale> by writing that line in your file
15:38:48 <jethr0> Cale: any more ideas of cool one-liner kinda solutions? or questions that come up regularly (like "how do i split a list into lists of length N?")
15:38:52 * ayrnieu will settle with putting a BSD/x86 system on the network for haskell development.
15:39:01 <Cale> hmm
15:39:23 <jethr0> or some nice and short haskell magic (like liftM, sequence, ...)
15:40:23 * palomer is considering stacking another ErrorT onto STI
15:40:34 <palomer> that would be evil
15:40:37 <palomer> I have to say, though
15:40:49 <palomer> once you get used to monads, you can never go back to computations with mutability
15:41:16 <jethr0> hehe
15:41:43 <jethr0> palomer: i'm not there yet. although i can't imagine the horrible type uncertainty of "normal" side-effecting programming
15:41:53 <jethr0> any more
15:42:15 <Cale> jethr0: yeah, but hang on a minute :)
15:42:44 <jethr0> Cale: that wasn't directed at you. my last line just didn't make sense without it :))
15:42:46 <palomer> what does the error monad do?
15:43:29 <jethr0> palomer: propagating errors?
15:44:05 <palomer> oh, righto
15:44:11 <palomer> I'll stack that on my STI
15:44:13 <palomer> STIE baby
15:44:20 <palomer> err, on Cale's STI
15:44:28 <palomer> this is too much fun
15:44:36 <ncalexan> sexually transmitted infection?  Charming.
15:44:57 <palomer> sexually transmitted infection with error
15:45:09 <ncalexan> I think any STI is an error condition.
15:47:06 <palomer> so it's a convention that if you want to represent errorful computation you'd use Left for error and Right for success, right?
15:47:45 <ncalexan> Yep.
15:49:02 <Cale> palomer: this is due to the fact that Either e is a monad for any e
15:50:26 <palomer> I don't see the relation
15:50:27 <palomer> ship
15:51:55 <ncalexan> Neither do I.  The convention was in place long before this stuff was thought of in terms of monads.
15:53:57 <jethr0> Cale: i'm off to bed. feel free to edit that wiki page if you feel the urge :)
15:54:21 <Cale> jethr0: I'll see about adding some things soon :)
15:54:30 <jethr0> good night
15:55:17 <Cale> hmm, perhaps it was, but try and define an instance of Monad using the opposite convention, and you'll see why it has to be that way
15:55:34 <Cale> (or even just Functor)
15:56:32 <lispy> @index Prelude
15:56:32 <lambdabot> bzzt
15:56:36 <lispy> @doc Prelude
15:56:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
15:57:57 <ncalexan> Cale: that seems like an artifact of the Haskell type system.  Surely Either a b is isomorphic to Either b a, and if you had a big-lambda you would have /\ a -> Either a e is a Monad just the same as Either e is.
15:58:07 <Cale> ncalexan: sure
15:58:11 <Cale> ncalexan: but we don't :)
15:58:56 <ncalexan> That's true, but there's a name for that incorrect argument.  Something about how the circumstance justifies the circumstance...
15:59:13 <ncalexan> Anyway, I officially withdraw my position :)
15:59:18 <Cale> well, there's a good unrelated reason why we don't have type lambda
15:59:26 <ncalexan> Several!
16:02:59 <palomer> ok, where do things break down?
16:04:32 <palomer> then again, I've never ever implemented a monad in my life
16:04:48 <palomer> I mean, will I ever have to write one?
16:04:50 <bd_> @oracle Either a b -> Either b a
16:04:51 <lambdabot> Unknown command, try @listcommands.
16:04:54 <bd_> hmm
16:04:59 <bd_> @genie Either a b -> Either b a
16:04:59 <lambdabot> Unknown command, try @listcommands.
16:05:10 <bd_> @listcommands
16:05:10 <lambdabot> use listcommands [module|command]. Modules are:
16:05:10 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
16:05:10 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
16:05:10 <lambdabot> seen spell state system todo topic type version vixen where
16:05:13 <palomer> I'll get acquainted with that black art when I need it
16:05:21 <bd_> djinn XD
16:05:26 <bd_> @djinn Either a b -> Either b a
16:05:26 <lambdabot> f a =
16:05:26 <lambdabot>   case a of
16:05:26 <lambdabot>   Left b -> Right b
16:05:26 <lambdabot>   Right c -> Left c
16:08:07 <Cale> palomer: Well, the computation-like monads seem to mostly be constructible via the MTL
16:08:30 <Cale> and those are the ones you're most likely to use
16:09:00 <palomer> MTL?
16:09:02 <ncalexan> Cale: have you seen any efficiency wisdom/benchmarking of mtl?
16:09:07 <Cale> monad template library
16:09:07 <ncalexan> Monad Transformer Library.
16:09:12 <ncalexan> -package mtl.
16:09:12 <ncalexan> Template?
16:09:15 <ncalexan> Didn't know that.
16:09:15 <Cale> transformer
16:09:16 <palomer> make up your minds!
16:09:25 <Cale> I think..
16:09:26 <Cale> hmm :)
16:09:31 <palomer> Cale: have you ever had to write your own?
16:09:44 <ncalexan> See the wiki!  Cale's written several useful monads.
16:10:08 <ncalexan> MonadSupply, MonadRandom.
16:10:08 <Cale> yeah, but I used monad transformers, so that's cheating :)
16:10:22 <ncalexan> Hehe... I suppose.
16:10:25 <palomer> those are done with the MTL!
16:10:36 <Cale> I have written implementations of a couple of tree monads
16:10:49 <Cale> I was going to do a graph monad, but graphs are a pain to work with.
16:11:19 <ncalexan> What's a tree monad?  Is it computation as a tree, or allows you to build a tree in the monad.
16:11:22 <ncalexan> ?
16:11:33 <Cale> Here's a basic one:
16:11:44 <Cale> data Tree a = Leaf a | Branch [Tree a]
16:11:50 <Cale> Tree is a monad
16:11:56 <palomer> and a container!
16:12:14 <Cale> (exercise: write the only nonidiotic instance of monad possible for that :)
16:12:28 <palomer> that's a yaht exercise, methinks
16:12:44 <palomer> and why would anyone ever use TreeT?
16:12:51 <palomer> or ListT for that matter?
16:13:36 <ncalexan> With that definition, isn't Tree a 'essentially' isomorphic to List a?
16:14:15 <ncalexan> I suppose there's structural information that might be useful, though I can't think of any non-trivial uses right now.
16:14:21 <ncalexan> Maybe numbering problems?  Shortest paths?
16:14:59 <palomer> newtype K = K; newtype S = S ; type KS = Tree (Either K S)
16:15:25 <palomer> you get a stack based representation in this way
16:16:04 <palomer> which is good for finding most specific generalizations, for example
16:16:17 <ncalexan> Neat, I think I see that.
16:16:38 <ncalexan> (That's generalizing a type most specific, right?)
16:16:55 <palomer> in this case it's generalizing a program in the most specific manner
16:16:57 <Saulzar> map = map each leaf to a new Tree, join = expand the tree to include the new tree at each leaf?
16:17:15 <palomer> @hoogle join
16:17:15 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
16:17:15 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
16:17:15 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
16:17:23 <palomer> join would turn a tree of trees into a single tree
16:17:28 <Saulzar> Right
16:17:31 <palomer> yeah, whatever you said
16:17:42 <Saulzar> Hmm
16:17:50 <Saulzar> Wonder what you'd use it for
16:18:00 <palomer> use what for?
16:18:12 <Saulzar> Tree monad
16:18:42 <palomer> good question
16:18:43 <Saulzar> Game search? :)
16:18:49 <palomer> the Tree Monad would do the same thing as List, no?
16:19:12 <ncalexan> That's what I was saying, but you showed that it's not quite the same.
16:19:13 <palomer> only using the monadic operations of List, can you still get non deterministic computation?
16:19:19 <Saulzar> Could use it for a form of bredth first search
16:19:26 <ncalexan> Point
16:19:30 <palomer> ncalexan: I mean "only using the monad operations"
16:20:06 <ncalexan> Ah... I guess inspecting the result always breaks that rule, though.
16:20:18 <palomer> yeah
16:20:38 <palomer> so, erm, how would one use ListT?
16:21:21 <Saulzar> There is no usefulness in "only using the monad operations" though, since that gives you nothing concrete
16:21:35 <araujo> Hello!
16:21:39 <palomer> hullo!
16:21:47 <ncalexan> Holla!
16:23:46 <palomer> hmm, ListT is a weird transformer
16:23:53 <palomer> it doesn't return an element of the underlying monad
16:23:58 <Saulzar> This has to be the most useless feature ever - scroll the scrollwheel over the clock and it changes your timezone
16:24:19 <palomer> whoa, that's awesome
16:24:26 <palomer> are there any other monad transformers like this?
16:24:48 <ncalexan> Sure, ErrorT returns Either e a.
16:24:56 <palomer> oh, I'm being an idiot
16:25:03 <palomer> they all do something of the sort
16:25:27 <palomer> except with evalStateT, which is all I've been using up to now
16:26:26 <palomer> is there a combination of evalState and execState, that return the return value and the final state?
16:27:19 <ncalexan> runState/runStateT?
16:27:23 <ncalexan> @hoogle runState
16:27:24 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
16:27:24 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
16:27:50 <ncalexan> That'll do it... I think that's actually implemented as the record label, which is why you might not have seen it in the docs.
16:28:57 <palomer> I can't believe I didn't see it
16:29:02 <palomer> oh, righto
16:31:32 <dons> Saulzar, yeah, that's got to get a prize for worse devel cost to value of code ratio
16:31:47 <dons> sounds like the kind of thing someone hacked up when they're bored :)
16:52:19 <Saulzar> I have always wondered why my timzone kept on ending up as Russia or London
16:54:12 <Cale> palomer: The ListT in the GHC libraries kind of sucks, since it's not actually a real monad transformer (sometimes you don't get a monad). There's a better version on the wiki though.
17:10:48 * araujo loves pattern matching
17:19:23 <oberon> > (\x -> x  2) (\x -> 3* x)
17:19:24 <lambdabot> 6
17:21:52 <ncalexan> Can anyone tell me why Either a is not a monad in the Prelude?
17:22:10 <oberon> ((\ x -> x) $ 2) . (\x -> 3* x)
17:22:14 <oberon> > ((\ x -> x) $ 2) . (\x -> 3* x)
17:22:15 <lambdabot>  add an instance declaration for (Num (a -> c))
17:22:21 <oberon> > ((\ x -> x) $ 2)  (\x -> 3* x)
17:22:21 <lambdabot>  add an instance declaration for (Num ((a -> a) -> a1))
17:22:37 <oberon> > ((\ x -> x)  2)  (\x -> 3* x)
17:22:38 <lambdabot>  add an instance declaration for (Num ((a -> a) -> a1))
17:23:00 <ncalexan> The $ is giving you more applications, and you're not applying anything to that last lambda.
17:25:30 <oberon> > (\ x -> x $ 2)  (\x -> 3* x)
17:25:31 <lambdabot> 6
17:39:09 <astrolabe> @type Either
17:39:10 <lambdabot> Not in scope: data constructor `Either'
17:39:16 <astrolabe> @hoogle Either
17:39:17 <lambdabot> Data.Either.Either :: Either a b
17:39:17 <lambdabot> Data.Either.either :: (a -> c) -> (b -> c) -> Either a b -> c
17:39:17 <lambdabot> Prelude.Either :: Either a b
18:03:35 * lispy does his good haskell deed for the day by creating a GeSHi highlight file for haskell
18:04:31 <lispy> http://codersbase.com/index.php/Geshi_haskell
18:36:21 <lispy> oh, i just thought of a game that could be setup to help defeat spammers
18:37:12 <lispy> you create a website where people make an account, doing so creates an email address they can't check.  Any email sent to it is automatically filtered for spam.  Spam is then reported and the person is given 1 point per spam.  Valid email counts against them.
18:37:21 <lispy> the goal is to be the high scorer collecting spam
19:13:47 <Itkovian> lispy: any work has been done on the Quake3 stuff on codersbase?
19:14:12 <Saulzar> lispy, What is the purpose? If it's automatically filtered, then new spam won't be found... 
19:16:22 <fluxx> I guess it assumes spam filters are good enough
19:16:36 <fluxx> lispy, who is prepared to waste that kind of bandwidth?-)
19:17:00 <Saulzar> Suppose it can classify spam - still don't see the purpose :)
19:40:07 <shapr> Hey, I like Oleg's Haskell as a markup language article.
19:41:25 <fluxx> url?
19:44:09 <shapr> http://permalink.gmane.org/gmane.comp.lang.haskell.general/13363
19:47:22 <musasabi> it looked quite pretty, and no overlapping instances :-)
19:49:27 <Cale> That should replace Text.Html in GHC :)
19:50:37 <Cale> rev'apppend -- odd spelling
19:52:42 <shapr> What does rev'append do?
19:54:00 <shapr> -- snipped from the HList library \n l3 = reverse l1 ++ l2
19:54:37 <musasabi> Are there many uses for overlapping instances that a type inequality predicate for instance definitions wouldn't solve?
19:55:40 <musasabi> I think most of my overlapping instances could be solved with that, and they seem to cause most of the problems in the discussions.
19:56:51 <Cale> Well, I guess that if a library author gives a generic instance with some type inequality predicates on it, and you determine that you want to override that class on a type in your own code, you're stuck.
19:57:14 <Cale> (since the library author can't know about future modules)
19:57:32 <Cale> then again, perhaps that's a good thing
19:57:41 <musasabi> Cale: but the library author can use a trick to overcome that.
19:57:51 <musasabi> newtype W t = W t
19:58:10 <Cale> ah, I get it
19:58:24 <musasabi> instance Foo generic ... | generic /= W a
19:58:44 <Cale> hmm
19:59:01 <Cale> okay, that seems reasonably sensible
19:59:12 <Cale> might end up being a little ugly, but it would work
20:01:12 <musasabi> and closed scenarios are quite common - and in those there are no hacks needed.
20:01:39 <Cale> right
20:02:31 <Cale> of course, lots of time will have to be spent arguing about the syntax of such a predicate :)
20:29:12 <jethr0> @seen ndm
20:29:12 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 9 hours,
20:29:12 <lambdabot> 52 minutes and 30 seconds ago.
20:40:18 <mauke> what's a good name for a parser combinator of this type: Int -> Int -> Parser a -> Parser [a]?
20:40:29 <mauke> it's the equivalent of {n,m} in regexes
20:41:01 <ibid> thisMany? :)
20:41:14 <ibid> not quite but close
20:41:45 <mauke> I already have exactly, upto :: Int -> Parser a -> Parser [a]
20:42:54 <jethr0> manyRange
20:43:08 <jethr0> manyFromTo
20:43:24 <mauke> ah, range sounds good
20:43:57 <jethr0> i would consider prefixing them with "many" though
20:45:13 <jethr0> or sth of similar meaning
20:45:45 <mauke> heh, type Eject (x a) = a doesn't work
20:54:20 <shapr> mauke: I wrote Parsec code to do fromMtoN
20:54:38 <shapr> Peter Simons cleaned it up and put it into HsEmail.
20:55:15 <shapr> Check out http://cryp.to/hsemail/docs/Text.ParserCombinators.Parsec.Rfc2234.html
20:56:14 <shapr> I wish we had an RFC section in the libs.
20:56:42 <mauke> my version also takes a Combine (Parser tok st [a]) argument
20:57:21 <shapr> Combine?
20:57:40 <shapr> I have a head full of html and python, can you explain that in small words while I switch mental gears? :-)
20:57:43 <mauke> type Combine a = a -> a -> a
20:58:17 <mauke> there are predefined basic combinators, <|>, <||> and <|||>
20:58:24 <mauke> s/are /are three /
20:58:34 <shapr> ok, what do they do?
20:58:54 <mauke> p <|> q runs p and q
20:59:06 <mauke> p <||> q runs p and if it fails q
20:59:23 <mauke> p <|||> q runs p, and if it fails without consuming input, q
21:00:41 <shapr> Hm, I think <|> is used as 'or' in Parsec.
21:00:52 <shapr> That is, <||> in your notation.
21:02:38 <mauke> I thought you needed (try p <|> q) in Parsec
21:02:55 <eivuokko> Yeah.
21:03:30 <eivuokko> p <|> q, runs p, and it it fails, runs q.  Whetever p consumed input doesn't matter.
21:05:17 <mauke>  The parser is called predictive since q is only tried when parser p didn't consume any input (i.e.. the look ahead is 1). 
21:08:11 <shapr> Why is it interesting if the first parser consumed input?
21:08:45 <eivuokko> Otherwise backtracking information will consume too much memory, I guess.
21:08:47 <jethr0> shapr: because that input is not accessible for the second one
21:09:10 <mauke> because Parsec is weird
21:09:25 <mauke>  This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.
21:09:35 <jethr0> shapr: do you have any suggestions/additions for my idioms project? http://haskell.org/haskellwiki/User:JohannesAhlmann
21:09:40 <eivuokko> I wonder if one could do with cut and or, instead of try and choice.
21:09:43 <integral> often you don't actually need to backtrack, especially if you've already left factored
21:10:09 <eivuokko> I guess cut would require adding scoping.
21:10:10 <jethr0> you don't need to backtrack if your grammar is LL(1)
21:10:30 <mauke> eh, <||> doesn't backtrack either, really
21:10:32 <jethr0> s/if/iff/ (?)
21:10:51 <eivuokko> A lot of grammars aren't, in practice.  (Or inconvient to write)
21:11:08 <integral> eivuokko: a lot of grammars have *parts* that are LL(1) :-)
21:11:16 <jethr0> i know. i just wanted to bring up some more compiler theory :)
21:11:18 <eivuokko> Naturally..
21:11:53 <eivuokko> jethr0, sure.  I was hoping to stay practical small-time grammar writer. ;)
21:12:24 <tibbe> I've implemented a type inferense algorithm for let-polymorphism, is it hard to extend it to recursive functions (e.g. map)?
21:12:58 <jethr0> left-factoring a grammar manually can be a pain, and often it makes grammars much less readable. "happy" in connection with the bnf converter can handle almost anything you throw at it and is (for more complex) languages definitely preferrable over a try-ridden parsec solution
21:14:27 <shapr> jethr0: Seen LicensedPreludeExts?
21:15:02 <shapr> What about John Hughes' use of lazy pattern matches?
21:15:04 <MarcWeber> Are there some String manipulating functions in the Prelude such as substitute? Or should I use functions such as dropWhile takeWhile ?
21:15:06 <shapr> I guess that could be its own article.
21:15:27 <shapr> Hughes also does this crazy pattern match unpack thing in the original QuickCheck that took me hours to figure out.
21:15:45 <shapr> It does save 3 to 5 lines of code though.
21:15:52 <shapr> Which is impressive for Haskell...
21:16:11 <jethr0> shapr: yes, i might link there. but i'm less interested in solution and more so in mind-enlarging _short_ examples
21:16:15 <fluxx> is it good to write crazy patterns that take hours to figure out?-)
21:16:25 <shapr> fluxx: Obviously they seem natural to John.
21:16:41 <eivuokko> Marcweber, yeah..usually those...or writing a Parserc parser that handles string manipulation in it.
21:16:47 <shapr> I've been there myself. For example, I cannot understand why anyone would consider SQL difficult.
21:17:02 <shapr> I taught SQL to my girlfriend last night in about half an hour.
21:17:17 <MarcWeber> fluxx Of course because you can remember them.. So you will invest those hours one time.. when typing those 3 to 5 additional lines over and over again you can loose days ;-)))
21:17:19 <shapr> Including inner/outer left/right joins...
21:17:33 <shapr> MarcWeber: Yeah, true that.
21:17:51 <shapr> jethr0: Doesn't Parsec do auto left factoring or something?
21:18:01 <jethr0> shapr: no!?
21:18:04 <eivuokko> Uhhuh.
21:18:05 <shapr> hmm
21:18:30 <jethr0> > parseTest (string "abc") "abc"
21:18:31 <lambdabot>  Not in scope: `string'
21:18:34 <fluxx> shapr, what's her education?
21:18:36 <MarcWeber> eivuokko All I want to do is some kind of pattern matching as make does it. eg %.o : %.c   So I want to know wether %o matches and how the c filename willl be called
21:18:49 <shapr> fluxx: She plays saxophone.
21:19:21 <jethr0> shapr: when you do "string "ab" <|> string "abc"" it'll fail on input "abc" because it's consumed "ab" for the first try and then fails the second with 'c'/='a'
21:19:27 <fluxx> so, she's smart or something?-)
21:19:35 <shapr> jethr0: Ah, ok.
21:19:35 <MarcWeber> >:t parseTest
21:19:57 <shapr> fluxx: Yeah, she is... but c'mon, how hard is SQL?
21:20:20 <earthy> quite hard
21:20:27 <earthy> if you've never seen anything like it before
21:20:29 <shapr> jethr0: Have you seen Conor McBride's Idiom Lite?
21:20:31 <fluxx> shapr, maybe you're just an excellent teacher
21:20:42 <shapr> I doubt it :-)
21:20:47 <jethr0> nope
21:20:55 <jethr0> shapr: where can i find it?
21:20:58 <shapr> She was unhappy with my attempt to teach her about type theory and lambda calculus.
21:21:08 <fluxx> its difficult to judge the difficulty of something one already knows..
21:21:16 <shapr> She was interested, but felt that I need to learn to be a better teacher.
21:21:38 <shapr> Maybe I shouldn't start with Russel & Whitehead, but I like the stories behind the theory as much as the theory itself.
21:21:39 <earthy> you have a girlfriend that actually wants to understand cs stuff
21:21:44 <ProfTeggy> shapr, I should have been there last night ;-)
21:21:47 <jethr0> select sql from is where reall = easy :)
21:22:02 <fluxx> yeah. sql is just simply writing plain english!
21:22:12 <shapr> ProfTeggy: Yeah, but you're a world-renown query expert :-)
21:22:14 <earthy> until you start adding joins
21:22:31 <shapr> earthy: Joins are really simple, have you seen the two overlapping circles explanation?
21:22:33 <ProfTeggy> shapr, you're too kind ;-P
21:22:38 <jethr0> i mean, complicated joins and stuff can get quite tricky, but the basics aren't that bad
21:23:02 <earthy> shapr: I have.
21:23:07 <jethr0> shapr: it _is_ possible to describe some mean relations with combinations of outer and inner joins
21:23:39 <earthy> but that is not to say that everyone can connect that with the sql syntax
21:23:41 <shapr> ProfTeggy: When people on LtU start giving the url to someone's thesis as part of an explanation of deep database stuff... ;-)
21:24:42 <shapr> I teach people how I learned it.. A plastic surgeon friend of mine wanted a database of patients and their operations. Some of his patients would have one operation to have a mole removed, some movie stars would have fifty operations.
21:25:12 <shapr> Then I explained foreign keys, then I said "How do you find all patients that have no operations, or all operations that have no patients?"
21:25:29 <shapr> That's after explaining how to display patients and their operations, of course.
21:25:33 <ProfTeggy> That involves difference (or outer join)
21:25:57 <jethr0> shapr: where can i find conor's idioms?
21:26:14 <jethr0> bbl, gotta eat :)
21:26:47 <shapr> looking...
21:27:26 <shapr> ProfTeggy: Ok, maybe I'm confused.. Matching patients to their operations is inner join, yes? And Patients without operations is left outer join, and operations without patients is right outer join, yes?
21:28:04 <Phyx-> hmmm is lambdabot opensource?
21:28:09 <shapr> yup
21:28:10 <shapr> @version
21:28:10 <lambdabot> lambdabot 3p303, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
21:28:10 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:28:22 * shapr reads http://en.wikipedia.org/wiki/Join_%28SQL%29
21:29:22 <shapr> earthy: Does that sound right to you?
21:29:25 <Phyx-> :O
21:29:27 <Phyx-> ok, thanx
21:29:41 * Phyx- wgets
21:29:51 <shapr> You should try darcs, it roxx.
21:30:53 <earthy> shapr: checking
21:31:22 * Phyx- wishes that had an installer
21:31:30 <shapr> jethr0: http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf from the bottom of http://www.cs.nott.ac.uk/~ctm/
21:31:45 <shapr> Phyx-: I don't think anyone has considered that non-Haskellers would use lambdabot.
21:32:06 <ProfTeggy> shapr, that makes sense, yes
21:32:23 <Phyx-> shapr: do i have to get everything in that dir?
21:32:33 <ProfTeggy> shapr, the outer joins retain all tuples, though, not those without matches
21:32:34 <shapr> Ok, whew.. would be embarassing (but informative) to be wrong for more than a decade.
21:33:11 <ProfTeggy> A except (A join B) is the set of tuples in A without a join partner in B
21:33:21 <ProfTeggy> This is the anti-semijoin of A and B
21:33:42 <shapr> Phyx-: darcs can get it all for you, and update the repository whenever changes are made. Can you install darcs?
21:33:43 <ProfTeggy> A except project[A](A join B) of course
21:34:26 <shapr> Hm, right.
21:34:28 <ProfTeggy> In SQL, you need to use EXCEPT or NOT EXISTS
21:34:40 * earthy shivers
21:34:45 <earthy> relational algebra
21:34:48 <ProfTeggy> It's a non-monotonic query: adding tuples to the database might make your result smaller
21:34:57 <earthy> I thought I'd succesfully blocked that from my mind
21:35:04 <ProfTeggy> earthy...!
21:35:13 <shapr> I wish I could program the relations directly.. especially higher order relations.
21:35:37 <shapr> I had a job working on a trust management system, and some of the queries were two and a half pages of zero whitespace printout.
21:36:07 <shapr> Higher order queries as available in HaskellDB would have cut down on the amount of SQL used by eighty percent or more.
21:36:52 <ProfTeggy> shapr, the question is if such higher-order concept receive adequate support from the database kernel and its bulk-oriented operations
21:37:08 <shapr> After using HaskellDB, I get irritated everytime I make a spelling error or typo in my hand built SQL strings in other languages.
21:37:47 <shapr> Even if the queries have to be built on the client side, it'll still cut down on programmer errors.
21:38:31 <shapr> But I'd much rather be able to send queries directly in relational algebra or whatever.
21:39:40 <shapr> One lovely thing about HaskellDB is that it's totally backend agnostic, my queries and inserts work just fine across five or six backend systems. When I had this job in the mid nineties, tools like that were twenty thousand dollars a copy.
21:40:10 <shapr> Of course, I guess every language has a DBAPI these days :-)
21:40:54 <shapr> ProfTeggy: It seems to me that databases and filesystems will merge in the next few years, thus turning the database kernel into a kernel module. I think that would allow for adequate support for nifty features like higher order queries.
21:41:29 <ProfTeggy> It could make (shell) progamming much more fun
21:41:38 <ProfTeggy> Relational algebra in the shell level can turn out useful
21:42:04 <ProfTeggy> Well, in UNIX you have grep (which is select), cut (which is project), join (which is join) already
21:42:11 <earthy> that's what Hans Reiser is working towards, right?
21:42:25 <earthy> profteggy: but fs's are purely hierarchical
21:42:26 <shapr> Yup, reiser4 is the first half database half filesystem sort of thing.
21:42:26 <ProfTeggy> It's what MS is working on.
21:42:36 <earthy> it's what Be already had. :P
21:42:45 <shapr> Well, first one I've been able to use =)
21:42:58 * shapr goes off to unicycle for lunch.
21:43:16 <musasabi> ZFS also has parts into that direction if you look past the posix layer.
21:43:26 <earthy> no, that would be BeOS DR8. it *is* very powerful, having all your data in a db rather than an fs
21:43:34 <shapr> musasabi: Oleg's ZFS?
21:43:40 <earthy> sun's ZFS
21:43:45 <musasabi> Sun's
21:43:49 <sieni_> shapr: Probably in 20 years it still seems that databases and filesystems will merge in a few years
21:44:07 <earthy> sieni: there will always be special-purpose databases
21:44:24 <earthy> but filesystems *will* become more database-like
21:44:40 <tuomov> metacrap
21:46:48 <tuomov> I'm for making the filesystem non-hierarchical, but I don't think arbitrary searches are the way to go
21:46:56 <ValarQ> or more filesystemlike databases...
21:47:02 <tuomov> rather, I'd have files assigned to multiple user-definable categories
21:47:11 <tuomov> and the categories themselves could contain categories
21:47:14 <MarcWeber> Why doesn't hoogle find (==) when quering "a->a->Bool" ?
21:47:17 <tuomov> more flexible symlinking..
21:48:06 <earthy> tuomov: the filing system the OS provides *should* provide the ability for arbitrary searches
21:48:10 <tuomov> two files with the same name couldn't belong to the same set of categories
21:48:19 <earthy> however, the UI need not require you to do arbitrary searches
21:48:44 <mauke> @hoogle a -> a -> Bool
21:48:45 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
21:48:45 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
21:48:45 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
21:49:07 <earthy> in fact, BeOS DR8 did provide for arbitrary searches, but showed a hierarchical fs on top of that
21:49:31 <MarcWeber> mauke Ah. I do have to use spaces
21:49:49 <tuomov> e.g. One could have 'foobarrc' in the categories 'cfg' and 'system', and another in 'cfg' and 'tuomov'
21:50:20 <tuomov> and /cfg/foobarrc/tuomov or /cfg/tuomov/foobarrc or just /foobarrc/tuomov should work
21:50:43 <tuomov> the latter assuming there's no foobarrc not in the category cfg
21:52:12 <mauke> > readOct "123"
21:52:13 <lambdabot> [(83,"")]
22:13:48 <mathrick> hi
22:13:54 <musasabi> hello
22:14:48 <mathrick> I have that:
22:14:48 <mathrick> f :: Integer -> Integer
22:14:48 <mathrick> g :: Integer -> Integer -> Integer
22:14:48 <mathrick> h1 = f . g
22:14:57 <mathrick> and when I try to load it into hugs
22:15:01 <mathrick> I get error:
22:15:03 <mathrick> ERROR "/mnt/amd/bach/export/students/makat05/test.hs":27 - Type error in application
22:15:03 <mathrick> *** Expression     : f . g
22:15:03 <mathrick> *** Term           : f
22:15:03 <mathrick> *** Type           : Integer -> Integer
22:15:03 <mathrick> *** Does not match : (Integer -> Integer) -> Integer
22:16:45 <musasabi> mathrick: what type do you want h1 to have?
22:16:58 <mathrick> musasabi: "the resulting type" :)
22:17:11 <mathrick> I wanted to do that to see what will be the output type
22:17:22 <mathrick> to see if I get currying and composition correctly
22:20:46 <tromp_> you can only compose functions b->c and a->b
22:22:54 <mathrick> tromp_: hmm?
22:22:58 <mathrick> not sure I get it
22:23:03 <mathrick> ah
22:23:35 <mathrick> wait
22:23:41 <mathrick> (Integer -> Integer) -> Integer ?
22:23:50 <mathrick> isn't -> supposed to be right-associative?
22:23:52 <tromp_> that would work for g
22:24:06 <dcoutts> shapr, so haskelldb works with hsql. Any others? hdbc?
22:24:15 <tromp_> but your g is Integer -> (Integer -> Integer
22:25:10 <mathrick> tromp_: oh
22:25:13 <dcoutts> I guess I should get haskelldb into gentoo
22:25:43 <mathrick> tromp_: I expected to get an equivalent of 
22:25:50 <mathrick> h x y = f (g x y)
22:26:47 <mathrick> I'm still not sure where does (Integer -> Integer) -> Integer come from
22:27:08 <musasabi> dcoutts: who maintains the jhc ebuild? (it could use the new build-system with package support)
22:27:11 <mathrick> also, my grammar is off today
22:28:09 <dcoutts> musasabi, there is no jhc ebuild yet, JohnMeacham is going to tell me when he thinls it's ready for packaging for distros.
22:31:37 <shapr> dcoutts: HaskellDB also works with a SQLite backend written by stepcut, aka Jeremy Shaw. I don't know if it works with CosmicRay's backend.
22:31:38 <JohnMeacham> I'd like to write a spec file to get some rpms going at some point. I still need to look at the install stuff musasabi has been working on but it seems great.
22:33:06 <shapr> As for the database/filesystem discussion... Both ram and hard drives are just a bunch of bits, should memory be hierarchically addressed? I'd rather go for something more efficient.
22:33:20 <dcoutts> musasabi, well we can start looking at doing an ebuild. They're not all that hard. Tell me more about this install stuff.
22:33:27 <JohnMeacham> of course, then I will get emails quite regularly to the effect of "I compiled my thing with jhc and it took 2 hours and ended up slower than ghc!" but at least I can counter with inviting them to join the development effort :) I do really hope to get the LVM backend working soon, so people can start using it as a main compiler even if the crazy optimizations arn't there.
22:33:47 <musasabi> there is http://www.haskell.org/~gentoo/gentoo-haskell/portage/dev-lang/jhc-darcs/jhc-darcs-0.ebuild but that is very old.
22:34:05 <dcoutts> musasabi, oh, I'd forgotten about that
22:34:39 <dcoutts> musasabi, if you'd like to help we can make a new one and put it in that repo
22:34:49 <JohnMeacham> musasbi: feel free to check in any spec/ebuild/debian something or other files into the repo if it seems that is the best place to store them. good packaging is key for getting people to use something.
22:34:52 <musasabi> JohnMeacham: I'll push a patch dropping the dependency on the darcs version of Cabal and a .deb package.
22:34:53 <dcoutts> musasabi, you can darcs send to that repo and I can apply
22:35:23 <musasabi> dcoutts: ok, I'll try to see something in a few days.
22:35:54 <dcoutts> musasabi, what sort of build system is it? autotools? configure + custom makefiles + cabal?
22:35:59 <JohnMeacham> musasabi: kay. though, don't feel obligated, I know I have unconventional views on cabal but I totally think what you are doing with jhc is great.
22:38:02 <Igloo> Can I reply to a trac bug report by e-mail?
22:38:03 <JohnMeacham> dcoutts: was it you I was talking about the problems with MArray with?
22:38:13 <dcoutts> JohnMeacham, yes it was me
22:38:56 <JohnMeacham> dcoutts: I don't know if you noticed, but the bounds problem was brougt up and got a ticket for ghc 6.6, the other issues with the indexes probably should be mentioned soon if we want it in the next version of ghc.
22:39:13 <JohnMeacham> (I think it was discussed in a haskell-prime thread somewhere)
22:39:18 <dcoutts> JohnMeacham, right, should I add it to the same ticket or elsewhere?
22:40:20 <JohnMeacham> dcoutts: I'd bring it up on the list first and perhaps reference the ticket saying you will add it as a new request unless there is a strong objection.
22:40:31 <dcoutts> JohnMeacham, ok
22:41:19 <JohnMeacham> I am not sure, but somethinh like MArray will probably end up in haskell' and I'd like our ideal interface to already be in ghc and tested going into the libraries standardization process  (which will be brutal!)
22:59:59 <musasabi> dcoutts: Makefile with very simple ${PREFIX} and ${DESTDIR} handling.
23:00:20 <dcoutts> sounds ok
23:01:36 <musasabi> Currently it is using bleeding edge Cabal to build the base library, but that can be dropped easily (and probably should so build depends are easier)
23:09:45 <dcoutts> musasabi, at the moment we're using Cabal-1.1.3 in gentoo
23:13:16 <EtnaRosso> morning all
23:14:01 <EtnaRosso> i would like to define a new type using the data keyworg
23:14:05 <EtnaRosso> keyword
23:14:44 <EtnaRosso> with a constructor Cons t1 t2 t
23:14:52 <EtnaRosso> where t is generic
23:14:57 <EtnaRosso> it is possible?
23:15:01 <mathrick> does curry always work on two-parameter functions?
23:15:41 <resiak> @t curry
23:15:42 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init
23:15:42 <lambdabot> topic-null topic-snoc topic-tail topic-tell type .
23:15:46 <resiak> Grrr
23:15:49 <resiak> @type curry
23:15:50 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
23:15:53 <resiak> so, yes
23:16:20 <EtnaRosso> so i define newType = Cons t1 t2 ?
23:16:49 <mathrick> resiak: what if I wanted to curry a function of 3 params?
23:17:17 <resiak> f a b c = ... stuff with a b and c
23:17:37 <mathrick> resiak: yeah, but I mean, there's no bultin for that?
23:17:46 <resiak> I don't think so
23:19:09 <ProfTeggy> EtnaRosso, data T t = Cons t1 t2 t
23:20:26 <ProfTeggy> A newtype defined type cannot have multiple fields
23:21:20 <ProfTeggy> (in the above, t1 and t2 have to be concrete types)
23:22:28 <EtnaRosso> thank you
23:25:24 <EtnaRosso> do you know ghc?
23:26:47 <ProfTeggy> data T t = Cons Integer Bool t
23:26:47 <ProfTeggy> Or, data T t1 t2 t = Const t1 t2 t
23:26:47 <ProfTeggy> EtanRosso, are you from Italy?
23:26:47 <ProfTeggy> If so, good luck for the soccer match againt Germany tonight -- you'll need it ;-)
23:27:34 <EtnaRosso> yes Teggy and you?
23:28:00 <EtnaRosso> tonight? i think i'm employed in haskell questions tonight
23:28:06 <ProfTeggy> Germany (Munich)
23:29:00 <EtnaRosso> i have a little problem defining a function
23:30:27 <ProfTeggy> Ask away (as long as this isn't homework)
23:30:42 <EtnaRosso> I have set the type definition as "funct :: t1 -> t2 -> tr"
23:30:51 <EtnaRosso> and then the function
23:31:08 <EtnaRosso> as "funct a1 a2 = something"
23:31:17 <EtnaRosso> but it doesn't work in ghc
23:31:45 <EtnaRosso> It tells me "Data constructor a1 not in scope"
23:31:47 <ProfTeggy> "doesn't work" is kinda vague.  What kind of error message do you get?
23:32:55 <EtnaRosso> read below
23:33:35 * jethr0 is looking at the "OLEG type theory with holes"
23:33:52 <jethr0> somebody seems to have fun at what they're doing :) (http://www.cs.nott.ac.uk/~ctm/oleg/quiet/)
23:34:31 <ProfTeggy> @find paste
23:34:32 <lambdabot> Not in scope: type variable `paste'
23:34:50 <mauke> lisppaste2: help
23:34:50 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:34:58 <ProfTeggy> Thanks, mauke
23:35:08 <ProfTeggy> EtnaRosso, use the above URL to paste your code
23:35:18 <EtnaRosso> ok
23:36:35 <jethr0> anyone using "epigram" around?
23:36:41 <lisppaste2> EtnaRosso pasted "Data constructor not in scope" at http://paste.lisp.org/display/17369
23:37:23 <carp> hi jethr0, how come you're looking at that stuff?
23:37:55 <jethr0> carp: what stuff? epigram or the holes? i'm just wondering around, really. always looking for new things to learn
23:38:24 <ProfTeggy> EtnaRosso, send a b c t = []
23:38:36 <jethr0> and dependent typed languages seem like even better than haskell, at least in theory, and from what little (i.e. nothing) i know about them
23:38:37 <ProfTeggy> EtanRosso, variables are always written in lowercase
23:38:43 <EtnaRosso> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
23:38:45 <ProfTeggy> EtnaRosso, types are written in uppercase
23:38:46 <carp> oleg
23:38:47 <EtnaRosso> thank you!
23:39:24 <jethr0> carp: have you used/studied it?
23:40:18 <carp> oleg is the precursor to epigram, i've attempted to use it, it's very difficult to use without Conor looking over your shoulder
23:41:08 <jethr0> carp: is it practically usable (in theory) or mainly of research interest, yet?
23:41:19 <carp> the current development of epigram two is at the stage of adding oleg like stuff to our implementation
23:42:16 <jethr0> hmm, i heard shapr had startet with epigram.. would you encourage me to look at epigram out of pure interest or is it going to drive me nuts? :)
23:42:45 <carp> oleg is primarily of interest if you're interested in implementing something like it :)
23:43:11 <mathrick> Main> fib 1000000
23:43:11 <mathrick> ERROR - Garbage collection fails to reclaim sufficient space
23:43:12 <mathrick> heh
23:43:39 <jethr0> carp: k, i didn't know oleg was partially superseded by epigram. but i meant epigram...
23:43:39 <mathrick> does hugs have some kind of fixed stack size?
23:43:51 <mathrick> or will it allocate mem as it goes?
23:44:29 <jethr0> mathrick: it's also a question of how you wrote your fibonacci series. there are stack-friendly and not-so-friendly approaches
23:44:36 <carp> by all means... i would suggest that you get epigram 1 and conor's afp notes and try some exercises. Using Epigram 1's interface drives most people nuts, but a new version is in progress
23:44:51 <jethr0> k, thx
23:45:37 <mathrick> jethr0: that was an excersise to see if I can still remember how to write more complex tail recursion cases
23:45:42 <mathrick> and seems I can
23:45:43 <mathrick> but
23:45:53 <mathrick> Main> fib 60000
23:45:53 <mathrick> ERROR - Control stack overflow
23:46:03 <jethr0> mathrick: what does your fib function look like?
23:46:09 <mathrick> fib calls fib2, defined as:
23:46:10 <mathrick> fib2 n1 n2 guard
23:46:10 <mathrick>     | guard <= 0 = n1
23:46:10 <mathrick>     | otherwise = fib2 (n1 + n2) n1 (guard - 1)
23:46:13 <carp> jethr0: http://sneezy.cs.nott.ac.uk/epigram
23:47:04 <mathrick> jethr0: naive recursive version didn't even terminate for fib 100, I interrupted it earlier
23:47:19 <jethr0> > let fib2 n1 n2 guard | guard <= 0 = n1 | otherwise = n1 `seq` n2 `seq` (n1+n2) n1 (guard-1) in fib2 60000
23:47:20 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 ->
23:47:20 <lambdabot> b
23:47:20 <lambdabot>   Expected type: t
23:47:20 <lambdabot>   Inferred type: t -> t1 -> b
23:47:20 <mathrick> although interestingly enough, it never overflowed the stack
23:47:33 <jethr0> > let fib2 n1 n2 guard | guard <= 0 = n1 | otherwise = n1 `seq` n2 `seq` (n1+n2) n1 (guard-1) in fib2 0 1 60000
23:47:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 ->
23:47:33 <lambdabot> b
23:47:33 <lambdabot>   Expected type: t
23:47:33 <lambdabot>   Inferred type: t -> t1 -> b
23:47:55 <jethr0> > let fib2 n1 n2 guard | guard <= 0 = n1 | otherwise = n1 `seq` n2 `seq` fib2 (n1+n2) n1 (guard-1) in fib2 0 1 60000
23:47:56 <lambdabot> 810830350478441542097818716616713593353911261117210765681209059477758165021
23:47:56 <lambdabot> 931933413395740856518007485664840719365404850185815117497578470536532685951
23:47:56 <lambdabot> 317844778012783580391127574728233614072117875503043024032723173820964507389
23:47:56 <lambdabot> 666924467202082604620680503162937477904084871366199958539697260372454900808
23:47:56 <lambdabot> 903932137648928889370648847060110152303081453094593307415018230625478108808
23:47:58 <lambdabot> [23 @more lines]
23:48:14 <jethr0> spam,spam,spam
23:49:19 <vincenz> jethr0: lambdabot is more efficient
23:49:30 <jethr0> mathrick: try it with the "seq"s. otherwise, you might be building up _huge_ thunks, which will then eat up mem. but i'm not sure that's your problem on hugs
23:49:30 <vincenz> > (take 10) $ repeat "spam"
23:49:31 <lambdabot> ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam"]
23:49:40 <jethr0> > replicate 10 "spam"
23:49:40 <lambdabot> ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam"]
23:49:52 <jethr0> vincenz: that sure is one big number
23:50:05 <mathrick> jethr0: what does seq do?
23:50:08 <vincenz> jethr0: yeah but the idea was that the "take 10" was hidden between parentheses so it could've been infinite spam
23:50:14 <vincenz> mathrick: seq : a -> b -> b
23:50:22 <vincenz> mathrick: forces evaluation of a before returning b
23:50:27 <mathrick> ah
23:50:35 <jethr0> mathrick: it makes the calculation strict. otherwise it's is postponed until you ask for the value, which is at the _very_ end of your computation
23:50:41 <jethr0> at the "show" even
23:50:54 <mathrick> I see
23:50:55 <vincenz> jethr0: there's an easier way
23:51:03 <xerox> woopee
23:51:08 <jethr0> yup, forcing it in the (+)
23:51:21 <vincenz> > let fib = 1:1:(zipWith (+) fib (tail fib)) in drop 10000 fib
23:51:22 <lambdabot> [54438373113565281338734260993750380135389184554695967026247715841208582865
23:51:22 <lambdabot> 622349017083051547938960541173822675978026317384359584751116241439174702642
23:51:22 <lambdabot> 959169925586334117906063048089793531476108466259072759367899150677960088306
23:51:22 <lambdabot> 597966641965824937721800381441158841042480997984696487375337180028163763317
23:51:22 <lambdabot> 781927941101369262750979509800713596718023814710669912644214775254478587674
23:51:23 <jethr0> ((+) n1 $ n2)
23:51:24 <lambdabot> [23 @more lines]
23:51:30 <jethr0> vincenz: i know that
23:51:33 <vincenz> :D
23:51:53 <vincenz> I wish there was something liike
23:51:53 <mathrick> and tail is what?
23:51:55 <jethr0> let fib = 0:scanl (+) 1 fib in take 10 fib
23:51:59 <mathrick> (cdr list)?
23:51:59 <jethr0> > let fib = 0:scanl (+) 1 fib in take 10 fib
23:52:00 <lambdabot> [0,1,1,2,3,5,8,13,21,34]
23:52:05 <vincenz> let prime = 2:3:(calculate prime) in take 100 prime
23:52:27 <xerox> mathrick: head = car, tail = cdr
23:52:36 <jethr0> let primes = sieve [2..] where sieve (p:x) = p : sieve [ n | n <- x, n `mod` p > 0 ] in take 20 primes
23:52:40 <jethr0> > let primes = sieve [2..] where sieve (p:x) = p : sieve [ n | n <- x, n `mod` p > 0 ] in take 20 primes
23:52:40 <vincenz> > let fib = 1:scanl (+) 1 fib in take 10 fib
23:52:41 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
23:52:41 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
23:53:13 <mathrick> how does (+) force the actual computation?
23:53:15 <vincenz> jethr0: that must build up an amazing amount of memory
23:53:53 <jethr0> mathrick: it doesn't. it builds a so-called "thunk" describing how the operation is to be performed when actually demanded
23:53:53 <vincenz> let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 1000 primes
23:53:56 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 1000 primes
23:53:57 <lambdabot> [7927]
23:54:05 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 1000000 primes
23:54:08 <lambdabot> Terminated
23:54:12 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 10000 primes
23:54:15 <lambdabot> Terminated
23:54:20 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 5000 primes
23:54:21 <earthy> ;)
23:54:24 <lambdabot> Terminated
23:54:26 <vincenz> grr
23:54:29 <mathrick> jethr0: <jethr0> yup, forcing it in the (+)
23:54:29 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 2500 primes
23:54:31 <lambdabot> [22343]
23:54:32 <vincenz> binary searching
23:54:35 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 3700 primes
23:54:36 <jethr0> vincenz: try it at home. lambdabot has a timeout feature
23:54:38 <lambdabot> [34651]
23:54:47 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4500 primes
23:54:51 <lambdabot> [43063]
23:54:53 <earthy> vincenz is trying to find out where lambdabot breaks
23:54:56 <xerox> mathrick: what about 'forcing' ?
23:55:03 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4750 primes
23:55:06 <lambdabot> Terminated
23:55:12 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4620 primes
23:55:15 <lambdabot> Terminated
23:55:22 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4560 primes
23:55:26 <lambdabot> Terminated
23:55:29 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4530 primes
23:55:33 <lambdabot> Terminated
23:55:36 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4515 primes
23:55:39 <mathrick> vincenz: I'm trying to see how your version works, and failing somewhat
23:55:40 <lambdabot> [43271]
23:55:42 <jethr0> mathrick: yes, but it's not as nice as i had hoped for: "((+) n1 $ n2)"
23:55:47 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4522 primes
23:55:51 <lambdabot> [43391]
23:55:57 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4526 primes
23:56:01 <lambdabot> [43411]
23:56:04 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4528 primes
23:56:08 <lambdabot> [43441]
23:56:12 <ihope> You can use (!!).
23:56:12 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in take 1 $ drop 4529 primes
23:56:16 <lambdabot> Terminated
23:56:18 <vincenz> woo!
23:56:22 <vincenz> it terminates at 4528
23:56:27 <ihope> 4529 !! primes
23:56:33 <ihope> Or something.
23:56:33 <jethr0> mathrick: it says the first fibonaccis are 1 and 1. and then it adds the each fibonacci with its successor
23:56:36 <vincenz> no, 4528
23:57:03 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in 4529 !! primes
23:57:03 <lambdabot> Couldn't match `Int' against `[a]'
23:57:10 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in primes !! 4529
23:57:14 <lambdabot> 43451
23:57:15 <vincenz> \o/
23:57:17 <vincenz> another prime
23:57:20 <jethr0> mathrick: it's positive thinking. assuming you already know fibs up to N how do you calculate the rest
23:57:22 <mathrick> jethr0: but won't that create a non-tail recursion?
23:57:27 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in primes !! 4530
23:57:31 <lambdabot> 43457
23:57:34 <jethr0> vincenz: could you please talk to lambdabot in private msg?
23:57:36 <vincenz> heh, this one is more efficient
23:57:41 <vincenz> jethr0: yeah, sorry :/
23:57:57 <mathrick> also, why does drop 1000 not make it display elems 1001 ... +inf?
23:57:59 <jethr0> mathrick: it's lazy
23:58:32 <jethr0> that was the answer to your question before :)
23:58:32 <mathrick> jethr0: oh, so it will notice that fib is being computed up to n-1 elem?
23:58:46 * mathrick tries to wrap his head around that
23:58:46 <xerox> ihope: (xs :: [a]) !! (n :: Int) :: a
23:59:01 <jethr0> mathrick: and also, zipWith is tail recursive, working on a lazy list
23:59:06 <vincenz> heh... 4587  instead of 4528 when using !! instead of the take 1 drop method
23:59:40 <jethr0> > let fibs = [1,1,2,3,5,8,13,21,34] in zipWith (+) fibs (tail fibs)
23:59:41 <lambdabot> [2,3,5,8,13,21,34,55]
23:59:46 <mathrick> jethr0: the lazy lists are a bit new concept to me, I need time to settle down :)
