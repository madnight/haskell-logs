00:07:32 <davidmccabe> I can beat that.
00:07:35 <davidmccabe> I believe in god!!!
00:10:37 <davidmccabe> (well ok not really)
00:10:40 <davidmccabe> gnight.
00:25:02 <k1ngz0r> hi!
00:25:33 <k1ngz0r> I have a question, I want to add a Int to a IO string. 
00:25:45 <k1ngz0r> And I cant get it right, help
00:29:32 <eivuokko> @type \x -> Control.Monad.liftM (++show x)
00:29:33 <lambdabot> forall a (m :: * -> *).
00:29:33 <lambdabot>               (Monad m, Show a) =>
00:29:33 <lambdabot>               a -> m [Char] -> m [Char]
00:29:54 <eivuokko> But probably you want to use IO monad "correctly" and just use ++ and show
00:30:42 <ProfTeggy> Moin Moin, you lambda junkies
00:32:21 <k1ngz0r> ok it was show that i wanted. Thanks
01:13:53 <tibbe> @quote
01:13:53 <lambdabot> ncalexan says: Singleton lists contain traps of great variety and danger.
01:14:01 <tibbe> @quote
01:14:01 <lambdabot> ncalexan says: Singleton lists contain traps of great variety and danger.
01:14:04 <tibbe> @quote
01:14:04 <lambdabot> ncalexan says: Singleton lists contain traps of great variety and danger.
01:14:06 <tibbe> @quote
01:14:06 <lambdabot> ncalexan says: Singleton lists contain traps of great variety and danger.
01:14:23 <tibbe> lambdabot, are you having some problems?
01:14:34 <pierre-> > 2+2
01:14:34 <lambdabot> 4
01:14:38 <pierre-> >  2*2
01:14:39 <lambdabot> 4
01:14:46 <tibbe> > 1 * 42
01:14:48 <lambdabot> 42
01:14:58 <pierre-> (2+2)=(2*2)
01:15:09 <pierre-> > (2+2)=(2*2)
01:15:10 <lambdabot>  parse error on input `='
01:15:16 <pierre-> > (2+2)==(2*2)
01:15:17 <lambdabot> True
01:17:08 <tibbe> > msum [Nothing, Just 5, Nothing, Just 9]
01:17:34 <tibbe> hmm
01:17:47 <lambdabot> Just 5
01:22:39 <dcoutts> juhp, oh, that's where the missing gtk2hs deb is!
01:27:13 <tibbe> > fromJust $ msum [Nothing, Just 5, Nothing, Just 9]
01:27:14 <lambdabot> 5
01:27:22 <dcoutts> @seen liyang
01:27:23 <lambdabot> I saw liyang leaving #haskell 8 hours, 36 minutes and 47 seconds ago.
01:27:25 <tibbe> > fromJust $ msum [Nothing]
01:27:26 <lambdabot> Add a type signature
01:27:32 <tibbe> > fromJust $ msum [Nothing] :: a
01:27:32 <lambdabot> Add a type signature
01:27:37 <tibbe> > fromJust $ msum [Nothing] :: Int
01:27:39 <lambdabot> Exception: Maybe.fromJust: Nothing
01:28:53 <dcoutts> resiak, juhp found marcot's gtk2hs deb if you're interested
01:29:03 <dcoutts> http://mentors.debian.net/debian/pool/main/g/gtk2hs/
01:34:39 <dcoutts> @seen CosmicRay
01:34:40 <lambdabot> I saw CosmicRay leaving #haskell 1 day, 5 hours, 34 minutes and 15
01:34:40 <lambdabot> seconds ago, and I have missed 1 second since then.
01:39:34 <resiak> dcoutts: Awesome, thanks for the heads-up
01:53:00 <xerox_> mornin' !
01:55:21 * beelsebob_ pords xerox with a stick
01:57:19 * xerox_ utters words indistinctly
01:57:31 <beelsebob_> how's the world?
01:58:06 * xerox_ looks around...
01:58:22 <Saulzar> hi xerox 
02:00:30 <xerox_> Saulzar: do you use GNOME?
02:01:02 <Saulzar> Not usually
02:01:37 * Saulzar finds it puzzling that gtkComboBox is marked "depreciated" in glade, but gtkComboBoxEntry is not - when one is a subclass of the other
02:01:50 <gour> xerox_: you're on GNOME?
02:01:56 <xerox_> Yup.
02:02:15 <gour> xerox_: what do you think about haskell bindings for dbus?
02:02:18 <xerox_> I want to get people trying woopee!  The random wallpaper changer :-D
02:02:30 <xerox_> darcs get http://haskell.galois.com/~paolo/darcs/woopee
02:03:34 <xerox_> Hmm... what exactly is dbus?
02:04:24 <gour> IPC protocol
02:04:34 <gour> http://dbus.freedesktop.org/
02:04:35 <xerox_> Right.
02:05:10 <dcoutts> Saulzar, GtkComboBox isn't deprecated, you're thinking of GtkOptionMenu
02:05:11 <gour> scribes dev told me that e.g. scribes could be used in hIDE if hIDE would speak dbus
02:05:50 <xerox_> What is scribes?
02:06:22 <gour> xerox_: http://scribes.sf.net/ editor
02:07:12 <kosmikus> ProfTeggy: sorry, I didn't see your answer yesterday. so why don't identifier names with underscores just work?
02:07:59 <Saulzar> dcoutts, In the glade I'm looking at gtkComboBox is listed under the "depreciated tab"
02:08:07 <Saulzar> Rather "depreciated" tab :)
02:08:12 <kosmikus> xerox_: < xerox_> kosmikus: i succeeded to talk with one of this people and hunt down the bug, it is a switchable option or something, hehe.
02:08:17 <kosmikus> xerox_: what was that about?
02:08:25 <xerox_> kosmikus: startkeylogger
02:08:46 <xerox_> kosmikus: there is some "intrusion detection system" which has a lot of options, one being about keyloggers or something...
02:09:03 <dcoutts> Saulzar, on my glade the GtkOptionMenu is in the depreciated tab and GtkComboBox is in the normal one. If you check the gtk api docs it's the same.
02:09:23 <kosmikus> xerox_: why were you telling me?
02:09:25 <Saulzar> Here, they're both under depreciated - and the only one which isn't is GtkComboBoxEntry
02:09:50 <xerox_> kosmikus: hmm... I thought you where the guy playing with it!
02:10:07 <dcoutts> Saulzar, you've got a confused version of galde :-)
02:10:27 <kosmikus> xerox_: ah, ok. never mind, then :) glad you solved it ...
02:10:43 <xerox_> kosmikus: heh, sorry.  It was another 'k' guy ;-)
02:11:00 <ProfTeggyko> kosmikus, they do, they do (translated to \char95) -- all fine now
02:11:13 <Saulzar> I think so. It seemed very strange to me :)
02:11:54 <ProfTeggy> Strange client.
02:12:09 <kosmikus> ProfTeggy: ok then
02:59:09 <Saulzar> dcoutts, Hmm, (Just looking at your post for new TreeView API stuff) - what happens with widgets created by gtk - eg. glade?  You could set the model fine, but what exists by "default"?
02:59:43 <Saulzar> Even in proposal 1, the model would be undefined?
03:01:23 <Saulzar> (Hmm, I guess it is undefined as it is already, or at least not defined in any useful way)
03:30:47 <gour> what's the difference in writing haskell package to be used with e.g. ghc or writing general lib in haskell which can be used fron e.g. C?
03:34:12 <Lemmih> Using Haskell from C is implementation specific.
03:35:27 <gour> so one has to provide different libs for different OS-es/compilers?
03:36:44 <gour> e.g. win32 specifics vs. linux?
03:36:44 <Lemmih> How to call Haskell from C depends on the Haskell compiler/environment.
03:37:08 <gour> i think about using ghc for writing lib...
03:37:36 <gour> and then using the same lib from e.g. C on win32/mac/linux
03:37:37 <Lemmih> Ah, there's no differnce on the Haskell side then.
03:37:57 <Lemmih> Except you need some foreign exports.
03:38:21 <gour> yep, i'm aware of it, but C-users can use 'straight' C-api ?
03:38:50 <gour> is there some (extra) penalty involved if i want to call the same lib from Haskell?
03:40:02 <Lemmih> Well, if you export a function of type 'CInt -> CInt' then C will see it as a 'int fn(int);'
03:40:58 <Lemmih> The C side just have to call 'startupHaskell' first.
03:41:05 <gour> and for specific data types (in haskell), one needs some C-structs?
03:41:58 <Lemmih> Marshalling is provided by Foreign.Storable.
03:42:17 <gour> why is startupHaskell required?
03:42:54 <Lemmih> Because the RTS needs to be started.
03:43:01 <Lemmih> s/started/initialized/
03:43:51 <gour> ahh...i see
03:43:59 <Lemmih> What are you hacking?
03:44:21 <gour> i'm just thinking about hacking (astrology program)
03:44:44 <ProfTeggy> Astrology?
03:45:10 <gour> so, if someone does not like to use haskell, then i'm thinking whether it is feasible to provide engine written in haskell which can be used as general C-lib
03:45:32 <gour> ProfTeggy: yep, i'm studing vedic astrology (jyotish)
03:45:33 <ProfTeggy> Or astronomy?
03:45:40 <ProfTeggy> Aha
03:45:48 * ProfTeggy goes googling
03:45:49 <Lemmih> Jumping between Haskell and C is pretty slow.
03:45:50 <gour> ProfTeggy: well, astronomy was in ancient times natural part of it
03:46:37 <gour> Lemmih: then, it's better to just write straight haskell as package
03:46:48 <gour> Lemmih: and forget about C-users :-)
03:47:31 <Lemmih> gour: I don't know. Just be careful not to call Haskell functions from inner loops in C.
03:47:51 <gour> ProfTeggy: http://shyamasundaradasa.com/jyotish/what_is_jyotish/what_is_vedic_astrology/what_is_vedic_astrology_1.html
03:48:38 <gour> Lemmih: i plan to write Haskell application in gtk2hs and write engine for all kinds of calculation as a lib with clean API
03:48:51 <gour> Lemmih: i do not intend writing anything in C
03:49:24 <gour> Lemmih: but i'm thinking whether it is useful lib which can be used by (potential) C-users
03:50:47 <gour> Lemmih: e.g. i have to write bindings for some C-lib used for calculating ephemeris, so I thought about the other way - writing C-lib (in Haskell) which can be used from C
03:54:30 <ProfTeggy> Thanks, gour
03:54:51 <gour> ProfTeggy: there is PDF also for (offline reading)
04:14:25 <sieni> cool, there's an actual silc toolkit. suddenly writing a silc plugin into yi is much easier :-)
04:14:45 <sieni> maybe I'll write an mua as well ;-)
04:20:10 <kowey> sieni: all you need is a clever name based on mutt
04:20:27 <sieni> ley?
04:20:42 <tuomov> a clever slogan. "now this one sucks the least."
04:21:00 <tuomov> (but I've reserved that for the riot mua... :)
04:21:07 <kowey> i wonder if a slow haskell infection of mutt would be possible
04:21:22 <kowey> start rewriting mutt one component at a time, for example, parse the muttrc format with parsec
04:21:57 <tuomov> riot is quite close to a mua. it even uses mbox format for .riot
04:22:15 <tuomov> it's just missing sending stuff..
04:22:31 <tuomov> and more interaction
04:23:04 <kowey> hey, tuomov, i'll send my blind friend that link... maybe he wants it for his braille board
04:52:24 <beelsebob_> anyone know where I can get a vector art version of the darcs icon?
04:52:53 <dfhaii> hai
04:52:57 <ValarQ> hoi
04:57:07 <dfhaii> quick question, i've written a quick factorial function., but when giving it a type with > fact :: a -> a hugs complains
04:57:19 <dfhaii> however if i take this line out the function works fine
04:57:34 <chrisbrown> its probably because you need Num a => a -> a
04:57:44 <chrisbrown> fact :: Num a => a -> a
04:57:58 <xerox> dfhaii: try ":t fact"
04:58:13 <xerox> dfhaii: it will tell you what type hugs thinks your function has.
04:58:51 <dfhaii> It's Num a => a ->
04:58:56 <dfhaii> thanks
04:59:06 <dfhaii> why is that though, i thought it would be int -> int
04:59:19 <chrisbrown> because hugs is inferring the most general type
04:59:28 <chrisbrown> it could be Int, Integer, Float...
04:59:54 <chrisbrown> the most general type is any type within the class Num
05:00:40 <dfhaii> So i could make it Integer a=>a->a , or any appropriate type within the class Num
05:01:02 <chrisbrown> erm...not sure try it. I think so.
05:01:36 <dfhaii> Nope, it's not keen
05:01:46 <chrisbrown> interesting
05:01:56 <ValarQ> dfhaii: how did you write?
05:02:04 <chrisbrown> you would have to be more specfic then... like Int -> Int 
05:02:09 <chrisbrown> or Integer -> Integer
05:02:24 <dfhaii> ah, i tried Int a => a -> a
05:02:32 <ValarQ> oh, that wont work
05:02:37 <chrisbrown> that wont work
05:02:46 <chrisbrown> Num is a class which take a parameter
05:02:49 <chrisbrown> Int is a type
05:02:57 <chrisbrown> Num Int => Int -> INt
05:03:01 <ValarQ> Integral a => a -> a  -- is probably what you want then
05:03:12 <chrisbrown> thats the one
05:03:24 <dfhaii> i'll leave it as it is, just messing around atm anyway
05:03:29 <dfhaii> would like to learn though
05:03:47 <kowey> dfhaii: do you know any java?
05:03:58 <dfhaii> yeah, a fair amount why?
05:04:14 <kowey> dfhaii: because what haskell calls 'classes' is a bit like what java calls 'interfaces'
05:04:21 <dfhaii> ah
05:04:26 <kowey> (at least, that's how i come to understand things when i emigrated)
05:04:37 <dfhaii> haskell is very different to any of the langs i know
05:04:50 <ValarQ> it usually is :)
05:05:35 <xerox> dfhaii: if you do :info Num, you'll see all the Num instances currenly loaded.
05:06:11 <xerox> dfhaii: along with the class' functions.
05:06:59 <xerox> dfhaii: as a general definition, classes are *set* of types, instances are 'putting the type into the set defining those given functions'.
05:07:58 <dfhaii> ah right
05:08:07 <dfhaii> i have a book, will have a good read
05:08:23 <dfhaii> thanks for help so far, must dash to a lecture now
05:09:24 <MarcWeber> Is haskell.org down?
05:10:36 <ValarQ> looks like it :(
05:50:00 <jbc> heyas :)
05:50:13 <jbc> is it me, or is haskell.org down?
05:50:14 <JohnMeacham> Is there a mailing list for the lvm or helium?
05:50:40 * jbc starts a haskell-based course in 2 days.
05:51:01 * jbc stares at said 'gentle introduction'
05:51:31 <jbc> *crosses legs*
05:51:36 <kowey> jbc: maybe you could help out in the haskell wikibook?
05:52:17 <jbc> there's a handy 'haskell for C programmers' tutorial that sounds good, but I can only see it via google's cache
05:52:22 <jbc> anyone know of a mirror?
05:54:14 <TuringTest> I can't reach haskell.org either
06:04:55 <shapr> blackdog: you called?
06:06:21 * jbc pokes blackdog also
06:06:23 <jbc> mark!!!
06:06:32 <shapr> Mistah Wotton!
06:11:43 <jbc> Most vexing. 
06:16:06 <shapr> @seen lambdabot
06:17:18 <Lemmih> I saw lambdabot getting killed by SIGHUB two hours ago.
06:23:47 * ProfTeggy nods
06:23:56 <ProfTeggy> lambdabot has quit the server saying: "killed by SIGHUP"
06:26:59 <MarcWeber> What is wrong here? Exposed-modules of a cabal file..
06:29:15 <MarcWeber> http://www.rafb.net/paste/results/vMU4wL16.html
06:38:12 <Lemmih> MarcWeber: hcamake.DepRules isn't a valid module name.
06:38:33 <ihope> What's the function to take the fractional part of a number?
06:40:29 <MarcWeber> Is Hcamake.DepRules then?
06:40:50 <tromp_> properFraction
06:41:08 <MarcWeber> It is
06:41:24 <tromp_> snd . properFraction   to be precise
06:43:26 <TuringTest> ihope: " x - fromIntegral (truncate x) " works
06:44:28 <TuringTest> Oh...so that's what properFraction does.
06:45:13 <ihope> Whoo. This ambiguous type variable errors are annoying.
06:45:26 <ihope> s/This/These/
06:46:19 <ihope> 'Ere we go.
06:46:21 <ihope> Thanks.
07:01:51 <shapr> CosmicRay: awesome!!!
07:02:32 <shapr> CosmicRay: xscreensaver puts debian planet blog posts on my screen, I just discovered that you're going to be a FATHER!
07:02:59 * shapr hasn't been reading blogs for awhile...
07:08:30 <xerox> Does it? :-)
07:14:58 <shapr> @yo
07:20:37 <ValarQ> hi formarn
07:23:14 <musasabi> Itkovian: splitEither, I think at least Cabal has it.
07:23:40 <musasabi> I think it should be added to Data.Either
07:23:56 <xerox> @hoogle splitEither
07:26:06 <Itkovian> ok
07:26:20 <Itkovian> I can of course write it myself ...
07:26:27 <Itkovian> but that would add to the code length
07:26:31 <shapr> hey ValarQ 
07:30:32 <ValarQ> shapr: had any use of my markov programs?
07:38:53 <CosmicRay> hey shapr!
07:39:00 <CosmicRay> shapr: yup!
07:39:02 <CosmicRay> thanks
07:39:23 <CosmicRay> shapr: Igloo told me "you're supposed to be working on the next generation of Haskell, not the next generation of Haskellers" <grin>
07:40:02 <CosmicRay> shapr: ltns, btw.  how ya been?
07:40:29 <xerox> CosmicRay: hah, woopee!
07:41:52 <CosmicRay> thanks xerox
07:49:44 <palomer> is there a reason we can't have wildcards for constructors?
07:55:37 <Philippa> that's what _ is, no?
07:56:43 <musasabi> more like (_ a) "match any unary constructor binding a to the value" I think.
08:35:52 <jethr0> i've just installed afrp. and it installed fine into ghc/imports/afrp
08:36:20 <jethr0> but including modules like "AFRP" still doesn't work. is there a way to tell ghc about these new modules?
08:36:35 <xerox> Investigate ghc-pkg.
08:37:10 <jethr0> xerox: i know (minimally) about ghc-pkg. but at first glance it didn't seem to help me, at least not if afrp doesn't have a package description, right?
08:37:54 <xerox> I don't know about afrp, but yes, you need a package description file to feed ghc-pkg to get it registered.
08:41:32 <jethr0> shapr: ?
08:41:41 <jethr0> shapr: i mean ping
08:49:31 <ihope> > let Nothing = 3
08:49:59 <jethr0> ihope: names starting in captilals are reserved for constructors
08:50:02 <ihope> I know.
08:50:18 <jethr0> k
08:50:25 <ihope> But... I didn't get any message...
08:50:33 <ihope> > let Nothing = 3 in Nothing
08:50:36 <jethr0> lambdabot might be offline once again
08:50:46 <ihope> Oh...
08:51:01 * ihope pops into GHCi
08:51:45 <ihope> Hmm. Blah blah blah "In a pattern binding: Nothing = 3"
08:52:04 <jethr0> ihope: what are you trying?
08:53:06 <ihope> Well, I'm trying to figure out whether numeric literal thingies are considered constructors.
08:53:23 <jethr0> i don't think you can assign constructors
08:53:31 <jethr0> let X = Just in X 4
08:53:39 <ihope> Well, apparently they are.
08:53:44 <Igloo> That's not assigning a constructor
08:54:10 <jethr0> exactly
08:54:11 <Igloo> It's binding the pattern on the left, which in this case has no variables so looks a bit odd (and I thought was illegal)
08:54:16 <jethr0> ihope: why do you say "apperently"?
08:54:31 <Igloo> let Just x = whatever in x   probably makes more sense to you
08:55:01 <jethr0> Igloo: no, i was trying this illegal thingey, to make sure it's illegal
08:55:15 <ihope> jethr0: based on what I've been doing in GHCi, those literals are treated as constructors.
08:55:28 <jethr0> ihope: i think you can only introduce constructors with "data" and "newtype". but i could be wrong. maybe the standard helps
08:56:04 <ihope> I know.
08:56:18 * pierre-- loves haskell...
08:56:38 <Lemmih> And Haskell loves you.
08:56:47 <pierre--> great
08:56:48 <palomer> probably not in the same way, though
08:56:53 <ihope> It's a mutual... language relationship thingy!
08:56:56 <palomer> ugh
08:57:00 * palomer has to rewrite his type system
08:57:37 <ihope> Well, I think it's time to tree.
08:57:39 * ihope trees
08:57:48 <palomer> eh?
08:58:13 <palomer> is that a "back to the future" quote?
08:58:16 <ihope> Binary search tree.
08:58:41 <ihope> Back to the future would be (I think) "Trees? Where we're going, we don't need trees."
08:58:52 <ski> (palomer : wanted something ?)
08:58:55 <palomer> it's time for you to make like a tree and leaf
08:59:15 <palomer> ski: yeah, my supervisor wants me to formalize what I'm doing in LF (twelf), but I'm considering using Coq
08:59:30 <palomer> since you're the export on this matter, what do you suggest I do?
08:59:35 <palomer> s/export/expert
08:59:36 <ski> palomer : ok (haven't used either)
08:59:44 <palomer> LF is logic programming
08:59:53 <ski> yes
09:00:03 <palomer> while coq is...functional?
09:00:08 <ski> formalize your type system, you mean ?
09:00:11 <palomer> yeah
09:00:13 <ski> yes, i believe so
09:00:28 <palomer> I'll be using them to formally prove my theorems
09:00:58 <palomer> there are, basically two theorems to prove:
09:01:02 <palomer> progress and preservation
09:02:20 <ski> i believe twelf can find (at least some) proofs for you
09:02:23 <ski> though, hm
09:02:29 <ski> possibly not induction proofs
09:02:40 <palomer> so can Coq, no?
09:02:46 <ski> i dunno :)
09:03:22 <palomer> do you think I'll learn more if I use LF (with logic programming) ?
09:03:29 <ski> (proving in twelf as in running a logic program query, i.e.)
09:03:37 <ski> learn more what ?
09:04:00 <palomer> about programming
09:04:10 <xerox> palomer: ask roconnor when he comes about!
09:04:12 <palomer> since I've never done any logic programming
09:04:16 <palomer> xerox: he's used both?
09:04:34 <xerox> He wrote Coq.
09:05:00 <palomer> xerox: he's the main author?
09:05:13 <palomer> well, erm, he'll of course tell me to use Coq
09:05:36 <palomer> ski: what could you see yourself doing more: proving theorems by logic programming or by functional programming?
09:05:58 <xerox> palomer: he could tell you what's the purpose of Coq, and if it matches your needs I think.
09:06:05 <ski> i think it would possibly be fun to try proving from the POV of LP
09:06:17 <ski> (never done that, yet :)
09:06:48 <palomer> LP?
09:06:55 <ski> logic programming
09:07:09 <CosmicRay> ugh.
09:07:37 <ski> (also, i dunno how hard it would be to get into the paradigm, and learn twelf, if one has never tried e.g. prolog)
09:07:48 <dcoutts> Saulzar, yes when you get a TreeView from a glade file it starts with no model, that would work fine under both proposals.
09:08:37 <palomer> ski: do you think twelf is simply a typed prolog?
09:09:01 <ski> palomer : not simply :)
09:09:11 <palomer> ski: hmm?
09:09:17 <palomer> like cayenne is to sml what twelf is to prolog
09:09:19 <ski> dependently typed
09:09:29 <palomer> or, rather, cayenne is to sheme what twelf is to prolog
09:09:33 <ski> sml is typed, prolog is not
09:09:40 <palomer> s/sheme/scheme
09:09:45 <ski> more or less, i think
09:10:12 <palomer> ski: and what do you think is more popular?
09:10:52 <ski> dunno ?  maybe coq (at least i think i've heard about that more) ?
09:11:38 <palomer> so mercury is midway between twelf and prolog
09:11:53 <ski> sortof
09:12:02 <ski> mercury has a static mode system
09:12:07 <palomer> static mode?
09:12:13 <ski> twelf has some simple support for modes, but not much
09:13:05 <ski> ('static mode system' as similar to 'static type system')
09:13:27 <palomer> twelf has no static typing?
09:13:35 <palomer> I thought that was the whole point of twelf!
09:13:54 <ski> twelf has static type system
09:14:01 <ski> but not much of static mode system
09:14:05 <palomer> what's a mode?
09:14:13 <ski> modes describe in which ways/directions/modes a predicate may be run (and optionally the determinism, in that case)
09:14:27 <ski> want an example ?
09:14:30 <palomer> sure
09:15:06 <ski> ?- append([0,1],[2,3],Xs).
09:15:15 <ski> Xs = [0,1,2,3]
09:15:26 <ski> that is a call to append/3 in one mode
09:15:39 <ski> :- mode append(in,in,out) is det.
09:15:49 <ski> is how that mode is declared in mercury
09:16:10 <ski> ?- append(Front,Back,[0,1,2,3]).
09:16:19 <ski> Front = [],Back = [0,1,2,3] ;
09:16:24 <ski> Front = [0],Back = [1,2,3] ;
09:16:30 <ski> Front = [0,1],Back = [2,3] ;
09:16:36 <ski> Front = [0,1,2],Back = [3] ;
09:16:42 <ski> Front = [0,1,2,3],Back = []
09:16:56 <ski> is a call (with four solutions, this time) in another mode
09:17:01 <palomer> ah, I think I get a vague idea
09:17:06 <ski> :- mode append(out,out,in) is multi.
09:17:22 <ski> an 'in' argument is given when the predicate is called
09:17:23 <palomer> this seems tremendously useful
09:17:38 <ski> an 'out' argument is computed by the predicate (so is a result)
09:18:12 <ski> 'det' is short for "deterministic" and means that this a call in this mode has exactly one solution
09:18:28 <ski> 'multi' is short for "multi-deterministic" and means that this a call in this mode has at least one solution
09:19:14 <ski> so, modes are used to keep track of in which "direction" a predicate is called .. what is input and what is output
09:19:16 <palomer> so this is good for proof search
09:19:26 <ski> yes
09:19:48 <ski> one can have mode complicated things than 'in','out', too
09:19:51 <Cale> shouldn't it be impossible to verify that the call has at least one solution?
09:20:05 <ski> Cale : approximations :)
09:20:06 <Cale> (at least, in general)
09:20:25 <ski> in this case it's no problem
09:20:46 <ski> sometimes the system can't determine as accurate determinism as one'd like
09:20:57 <palomer> hmm?
09:21:02 <ski> (so one can use promise_X pragmas, then)
09:21:19 <ski> e.g.
09:21:21 <Cale> ah, okay
09:21:32 <ski> :- mode append(out,in,in) is semidet.
09:21:48 <ski> the current system can't check this mode
09:22:09 <roconnor> > let (_|) = (*) in 4 _| 5
09:22:15 <Cale> what is semidet?
09:22:16 <roconnor>  > let (_|) = (*) in 4 _| 5
09:22:23 <palomer> roconnor: hello!
09:22:28 <roconnor> hi
09:22:28 <palomer> just the person I wanted to talk to
09:22:36 <ski> 'semidet' is short for "semi-deterministic" and means that a call in this mode has at most one solution
09:22:38 <roconnor> I have a few minutes
09:22:45 <roconnor> > 4 + 5
09:22:45 <palomer> roconnor: My supervisor wants me to formalize my type system in LF, but I've been considering Coq
09:22:50 <palomer> roconnor: what are your thoughts on this?
09:23:00 <ski> the system only succeeds in checking this mode has determinism 'nondet'
09:23:25 <ski> 'nondet' is short for "non-deterministic" and means that a call in this mode has at least zero solutions (i.e. no restriction at all)
09:23:26 <roconnor> LF seems like a better choice for formalizing type systems.  Thats what LF's are designed to do, right?
09:23:46 <roconnor> @seen lambdabot
09:23:50 <roconnor> :(
09:24:23 <palomer> err, make that twelf
09:24:33 <palomer> ahh shucks, and I was looking forward to playing with Coq
09:24:35 <roconnor> I assumed
09:24:43 <Cale> > 4 + 5
09:24:49 <mbot> 9
09:25:02 <roconnor> 9
09:25:10 <Cale> (unfortunately, I'm lagged at the moment, so it will be slow :)
09:25:36 <Lemmih> @version
09:25:39 <mbot> lambdabot 3p287, GHC 6.4.1 (Linux i686)
09:25:39 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:25:53 <jethr0> > let (_|) = (*) in 4 _| 5
09:25:55 <ski> (palomer : of course, you don't *need* a static mode system to be able to use predicates in different modes)
09:25:56 <mbot>  parse error on input `|'
09:26:04 <roconnor> roconnor 1.0
09:26:14 <palomer> ski: but you do if you want to combine modes, right?
09:26:28 <ski> palomer : 'combine' ?
09:26:29 <roconnor> jethr0: crap.  what's a good symbol for a contraction product?
09:26:34 <jethr0> roconner: > 32 * 32 / 12
09:26:37 <palomer> ski: what is the mode system for?
09:26:45 <jethr0> > let |
09:26:45 <ski> similar as type system
09:26:49 <mbot>  parse error on input `|'
09:27:01 <jethr0> > let >*< = (*) in 4 >*< 5
09:27:03 <mbot>  parse error on input `>*<'
09:27:09 <jethr0> *grmpf*
09:27:14 <roconnor> more brackets
09:27:21 <ski> palomer : checking, debugging, documentation, guidance
09:27:23 <roconnor> > let (>*<) = (*) in 4 >*< 5
09:27:23 <jethr0> > let >>*<< = (*) in 4 >*< 5
09:27:25 <mauke> > let (>*<) = (*) in 4 >*< 5
09:27:27 <mbot> 20
09:27:27 <mbot>  parse error on input `>>*<<'
09:27:30 <mbot> 20
09:27:30 <jethr0> ah, right
09:27:37 <ski> (palomer : and allowing more efficient implementation)
09:27:49 <roconnor> and <*> for outer product I suppose.
09:27:56 <jethr0> hehe
09:27:58 <roconnor> and * for geometric product maybe
09:28:11 <jethr0> roconnor: what is a contraction product?
09:28:17 <roconnor> a * b = a >*< b + a <*> b
09:28:32 <roconnor> jethr0: it is the generalization of inner products
09:28:59 <ski> :- mode length(list_skel(A),out) is det.
09:29:15 <ski> palomer : that is an example of a more advanced mode than 'in' or 'out'
09:29:38 <palomer> what does it do?
09:29:38 <roconnor> I'm toying with the idea of creating a computer graphics / geometric algebra course with Haskell.
09:29:52 <roconnor> it is the symetric part of the geometric product
09:30:13 <palomer> a university course?
09:30:21 <palomer> your students may hate it
09:30:28 <ski> palomer : the skeleton of the list should be fully known, and all the elements should have instantiation A (which is a variable that is universally quantified)
09:30:42 <roconnor> yep
09:30:46 <roconnor> gotta go now
09:30:55 <jethr0> bye
09:31:03 <ski> ?- length([0,1,2],N).
09:31:03 <ski> N = 3
09:31:16 <ski> ?- length([A,B,C],N).
09:31:18 <ski> N = 3
09:31:32 <ski> ?- length([left(1),right(X),left(2)],N).
09:31:33 <palomer> ?- length ([A,True,0],N)
09:31:34 <ski> N = 3
09:31:47 <ski> that is not possible with the static mode system (error)
09:31:53 <palomer> gotcha
09:31:54 <ski> (it is possible in prolog, though)
09:32:16 <ski> well
09:32:27 <ski> one could define another inst and mode so it works
09:32:40 <ski> for that specific case
09:33:42 <palomer> oh, I have an unrelated question
09:33:43 <ski> but it is hard to do in general
09:33:59 <ski> (possibly with existentially quantified insts (not supported))
09:34:17 <palomer> data (Foo:: (*->*)->*) where Bar::Int -> Foo Maybe <---is there any reason why this is currently disallowed in haskell?
09:34:34 <palomer> I'm thinking of making it legal
09:34:52 <ski> is it illegal ?
09:35:13 * ski doesn't know, and wonders why, too
09:35:13 <xerox> I.e. you need to use complete types?
09:35:46 <palomer> well, haskell currently doesn't even allow kind annotations
09:36:03 <ski> but current GADT implementation ?
09:36:13 <palomer> I'm talking about 6.4
09:36:19 <palomer> ski: hmm?
09:36:46 <Cale> Did 6.4 have GADTs?
09:36:51 <palomer> yup
09:36:56 * palomer should really get 6.5
09:37:00 <palomer> anyone here have 6.5?
09:37:01 <Cale> Have you tried 6.4.1?
09:37:07 <Cale> 6.5 is cvs
09:37:12 <ski> is the first paren pair legal, there ?
09:37:19 <palomer> data Eh a where   Baz ::  Int -> (Eh Maybe) <--if anyone has 6.5, try this
09:37:25 <palomer> Cale: using 6.4.1
09:37:31 <Cale> ah, okay
09:37:43 <Cale> heh
09:38:39 <palomer> noone has ghc-cvs :O?
09:38:45 <palomer> I'm scared to install it (might bugger up my system)
09:39:01 <Cale> the trouble is that you have to compile it
09:39:07 <Cale> which takes quite a while
09:39:29 <xerox> There seems to exist a Debian ghc-cvs package.  But last time I asked, ghc6 was the adviced one to use.
09:40:01 <palomer> yeah, ghc-cvs is scary enough
09:40:10 <palomer> combine it with debian and strange things start to happen
09:40:22 <Cale> heh
09:40:52 <Cale> I've found debian (even the unstable branch) to be pretty stable actually
09:41:06 <palomer> I've had my share of issues
09:41:18 <palomer> hmmm, adding kinds to a type system complicates things
09:41:28 <palomer> what would you guys use as your type datatype?
09:41:34 <Cale> yeah, but any more than you'd expect from a computer running any current OS? :)
09:41:45 * Lemmih is using ghc-6.5.
09:41:47 <palomer> data Monotype = Tylit String | Tyvar String | TApp Monotype Monotype <--this is what I have, and it gives me the heeby jeebies
09:41:53 <palomer> Lemmih: yes! now try that code
09:42:01 <palomer> Lemmih: data Eh a where   Baz ::  Int -> (Eh Maybe)
09:44:39 <Lemmih> That's not valid.
09:44:55 <Lemmih> Kinda like: data Eh (a :: * -> *) = Eh a
09:45:46 <ski> why isn't it valid ?
09:45:55 <ski> is 'a' assumed to have kind '*' ?
09:46:54 <Lemmih> Oh wait. It /is/ valid.
09:47:52 <palomer> ok, what's valid?
09:48:40 <Cale> It's conceptually valid, but not accepted by GHC.
09:48:56 <Lemmih> palomer: The GADT is valid.
09:49:13 <Lemmih> *Main> :i Eh
09:49:13 <Lemmih> data Eh a where
09:49:13 <Lemmih>   Baz :: Int -> Eh Maybe
09:49:13 <Lemmih>   Foo :: Char -> Eh (Either Char)
09:49:13 <Lemmih>         -- Defined at Test.hs:2:5
09:49:26 <Lemmih> Kinda funny.
09:49:44 <Cale> oh, so they must have fixed that in 6.5
09:49:45 <palomer> ahh, gotcha
09:49:46 <xerox> What's the purpose?
09:50:22 <palomer> xerox: now you can have functions of the type: forall (a::*->*) b. Eh a -> a b
09:50:54 <palomer> ugh, this rewrite is going to be a pita
09:50:58 <xerox> UH.
09:52:23 <palomer> GADTs really are quite wonderful
09:55:39 <ski> palomer : cool
09:57:22 <MarcWeber> Is anyone using pescos commandline library?
09:58:02 <jethr0> there isn't by any chance any (haddock) documentation for afrp / yampa around?
09:58:12 <MarcWeber> I have got problems understanding this expression: data Args = Args (forall a. (Typeable a) => String -> a) [String]
09:58:24 <MarcWeber> in combination with this usage: 
09:58:24 <MarcWeber> Args parm args <- get_args optspecs 
09:59:24 <MarcWeber> Got it.. 
09:59:37 <MarcWeber> pattern matching, expanding do expressions...
10:08:38 <tibbe> @quote
10:08:40 <mbot> SamB says: Boy, point-free Arrows are worse than Forth...
10:09:05 <Cale> heh, it must have some of the quote db :)
10:17:59 <kaydara> hi all
10:18:10 <Cale> hello
10:19:49 <ski> palomer : the body of 'forall' has kind '*'
10:20:21 <kaydara> im pretty new at haskell and im having troubles trying to make a functions that makes this. i have a list like [1,2,3,4,5,6,7,8] and want to create all sublist of 5 elements possible? Can someone help me with the idea of the implementation ?
10:20:32 <Cale> sure
10:20:37 <palomer> ski: what are you referring to?
10:20:55 <Cale> Probably the simplest thing to begin with is to write it recursively
10:21:01 <ski> palomer : 'forall a :: * -> *. a'
10:21:11 <Cale> so figuring out the base cases...
10:21:18 <ski> kaydara : do you have any code at all, so far ?
10:22:29 <palomer> ski: ah, you're referring to yesterday's conversation, yes?
10:22:37 <kaydara> well i have a function that create the list like i give x and it creates the [1..x] , only this
10:22:44 <kaydara> dont have ideas where to start
10:22:58 <Cale> sublists 0 xs = ...
10:22:59 <kaydara> i came from C and miss my loops
10:23:05 <Cale> there's a good thing to define first :)
10:23:15 <Cale> what are the sublists of length 0? :)
10:23:40 <kaydara> 0
10:23:44 <ski> palomer : dunno time :)
10:23:54 <Cale> just [], right?
10:24:01 <kaydara> yeah
10:24:11 <Cale> so sublists 0 xs = [[]]
10:24:25 <kaydara> well the length will be higher than 5 at least
10:24:25 <palomer> ski: and is it possible to interpret formulaes where the body of the forall does not have kind *?
10:24:48 <Cale> kaydara: right, but we'll take care of the base cases, and plug in whatever number later
10:24:58 <kaydara> ok ic
10:25:11 <Cale> well, the recursive step is important too, hehe :)
10:25:16 <kaydara> :))
10:25:33 <ski> (12 hours and 38 minutes ago) <palomer> what about forall (a :: *->*) a ?
10:25:58 <Cale> so then you have the nonzero sublists, and we'll break them into two cases:  sublists k [], and sublists k (x:xs)
10:26:04 <ski> palomer : that would be like saying 'forall a. sin' in logic ('sin' being trig. function)
10:26:07 <palomer> yeah, that was about 1am
10:26:22 <tibbe> could anyone point me to a high quality implementation of a lambda calculator in haskell (that is: easy to read, compact, etc.)
10:26:26 <palomer> ski: is forall a. (sin a) any better?
10:26:26 <ski> palomer : body of 'forall' should be a proposition/type, not an arbitrary term
10:26:29 <Cale> (at this point we know that k is not 0)
10:26:36 <kaydara> yeap
10:26:55 <ski> palomer : no, but 'forall a. sin a = 0' is
10:26:57 <Cale> so  sublists k [] is easy, there are no such sublists
10:27:05 <Cale> so we'll return the empty list there
10:28:03 <Cale> the other case is trickier though
10:28:19 <palomer> ski: right, but but we should stick to nullary predicates
10:28:27 <kaydara> that os the part i cant imagine atm
10:28:32 <kaydara> is*
10:28:48 <ski> palomer : what do you mean ?
10:29:14 <palomer> ski: = is a binary predicate
10:29:37 <Cale> you can imagine that we already have the solution to sublists (k-1) xs and sublists k xs, and from those, and knowing x, we'd like to build sublists k (x:xs)
10:30:13 <ski> palomer : yes, but why should you stick to nullary predicates ?
10:30:38 <palomer> because haskell doesn't have anything else?
10:31:01 <Cale> kaydara: do you know about 'map'?
10:31:12 <Cale> or list comprehensions?
10:31:19 <kaydara> yeahhave read most part of the functions this morning
10:31:26 <kaydara> apply a function to a list
10:31:28 <ski> palomer : with this translation, n-ary predicates becomes n-ary type constructors, and haskell has the latter, for all n (not just n = 0)
10:31:44 <kaydara> map odd [1,2,3,4] = [2,4]
10:31:55 <ski> no
10:32:04 <Lemmih> > map odd [1,2,3,4]
10:32:09 <Lemmih> > filter odd [1,2,3,4]
10:32:09 <mbot> [True,False,True,False]
10:32:13 <mbot> [1,3]
10:32:24 <palomer> ski: does that translation make sense?
10:32:27 <kaydara> ermm :)=
10:32:37 <ski> palomer : this is curry-howard
10:32:37 <Cale> > filter (not . odd) [1,2,3,4]
10:32:39 <mbot> [2,4]
10:32:49 <ski> > filter even [1,2,3,4]
10:32:50 <mbot> [2,4]
10:33:07 <kaydara> humm nice :D
10:33:09 <Cale> > map (+1) [1,2,3,4]
10:33:11 <mbot> [2,3,4,5]
10:33:35 <palomer> which curry-howard?
10:33:44 <kaydara> got it :)
10:35:25 <Cale> okay, so let's say we're trying to find the sublists of [1,2,3,4] of length 3. We know that sublists 2 [2,3,4] = [[2,3],[2,4],[3,4]] and we know that sublists 3 [2,3,4] = [[2,3,4]] -- is there a way to build sublists 3 [1,2,3,4] from these?
10:36:37 <kaydara> give me a sec :P
10:37:41 <Cale> (just in English even :)
10:38:27 <Cale> the neat thing about recursion is that you can assume that all the smaller cases are already taken care of
10:39:03 <kaydara> well we just need to add the element 1 to the head and we have like [[1,2,3],[1,2,4],[1,3,4]]
10:39:08 <Cale> right
10:39:12 <kaydara> to the head of heach
10:39:19 <kaydara> each*
10:39:42 <Cale> the function which adds an element to the start of a list is called (:), and you can partially apply it like (1:)
10:39:47 <Cale> > (1:) [2,3,4]
10:39:49 <mbot> [1,2,3,4]
10:40:08 <ski> palomer : curry-howard correspondance .. i.e. propositions and proofs and correspond to types and programs
10:40:14 <kaydara> yeah i know have make some tests this morning
10:40:26 <kaydara> i need to create the sublist
10:40:27 <Cale> of course, we'd like to apply it to that whole list, so how do we write that?
10:40:37 <palomer> ski: yes, but which curry-howard
10:40:40 <ski> (kaydara : do you only want contiguous sublists ?)
10:40:55 <palomer> I've never seen curry howard applied to n-ary predicates
10:40:58 <palomer> except with AF_2
10:41:06 <kaydara> ski well i dont
10:41:08 <palomer> and the translation was different than what you speak of
10:41:31 <kaydara> map (1:) [[2,3],[2,4],[3,4]]
10:41:38 <Cale> right :)
10:42:03 <ski> palomer : if 'a :: * -> *' then that corresponds to a second-order-predicate, taking a proposition as argument (e.g. negation is such a one)
10:42:10 <Cale> I should also mention that the way to concatenate two lists is using the operator ++
10:42:28 <Cale> and then we should be able to write the recursive step for sublists
10:42:36 <Cale> sublists k (x:xs) = ...
10:43:32 <kaydara> map (x:) ( let me think of this part )
10:43:36 <kaydara> :P
10:44:03 <Cale> and then there's the ones which don't include x
10:44:23 <palomer> ski: wrong channel
10:44:26 <ski> > map (1:) [[2,3],[2,4],[3,4]]
10:44:28 <mbot> [[1,2,3],[1,2,4],[1,3,4]]
10:44:30 <palomer> oh, maybe not
10:44:56 <Cale> [[2,3],[2,4],[3,4]] = sublists 2 [2,3,4]
10:47:50 <kaydara> in my function when i have a length 3 list should i reaturn the 3 cases possibels ?
10:47:58 <kaydara> possibles*
10:51:06 <palomer> ski: anything to suggest to my implementation?
10:58:19 <conal> does anyone there have java 1.4 installed but not java 1.5?  i'd like to get a test drive of my new Pan implementation.
10:59:30 <conal> The Java 1.4 examples are at http://conal.net/Pajama/1.4/examples
11:00:46 <conal> and the Java 1.5 version is at http://conal.net/Pajama
11:01:29 <conal> nothing to install.  just open the 1.4 page and click on a .html file.  
11:04:09 <kosmikus> I just see a small empty window ...
11:05:01 <conal> kosmikus: with an X in the upper left?
11:05:44 <conal> kosmikus: 1.4/examples page or the other one?
11:05:57 <kosmikus> 1.4/examples
11:06:04 <kosmikus> cornucopia 12
11:06:11 <kosmikus> it say so in the title bar of the window
11:06:24 <kosmikus> if I left-click nothing happens
11:06:25 <conal> thanks.  and do you know what version of java you have?
11:06:31 <kosmikus> if I right click, I get a menu
11:06:40 <conal> what's on the menu?
11:07:05 <kosmikus> well, yeah, blackdown-jdk-1.4.2.03
11:08:05 <kosmikus> the menu has three sections, "design tools", "mouse modes", "generic". the first is empty, the second has radio buttons "whole" and "cornucopia". The "generic" has a couple of entries.
11:08:12 <conal> ok.  
11:08:17 <kosmikus> nothing seems to really do anything, however.
11:08:57 <int-e> kosmikus: does your mouse cursor change if you left-click? (it does that here, sun jdkl 1.4.2_05-b05 (Linux))
11:09:14 <mwc> When they mention AccumulatorRecursion on the wiki (article not written), is that the same as "tail recursion modulo cons"
11:09:23 <kosmikus> int-e: yes, it does
11:09:36 <kosmikus> conal: I get red x'es for the http://conal.net/Pajama page
11:09:52 <kaydara> Cale: thkx a lot for your time, i need to go but i keep trying tomorow
11:09:59 <kaydara> again thanks a lot
11:10:08 <Cale> kaydara: oh, sorry
11:10:28 <kaydara> i come here tomorow and you give me another hand :P
11:10:30 <mwc> that is, tail recursion module cons is when the penultimate operation is a recursion, the last operation is to cons it with the parent calculation and the recursive result before returning
11:10:32 <kaydara> i really need to go
11:10:33 <Cale> kaydara: sure
11:10:34 <kaydara> :P
11:10:38 <kaydara> thkx
11:11:17 <mwc> anybody?
11:13:58 <conal> kosmikus: the red x's are expected, since that page relies on java 1.5.  i'm surprised about the blank window for 1.4.  that's what i wanted to find out.
11:14:03 <conal> would you mind trying another?
11:14:35 <kosmikus> same effect for xorgon_rings_2, only the menu contents are a bit different
11:14:42 <kosmikus> I have two entries in "design tools" there.
11:14:52 <conal> yep.  that's what i'd expect.
11:15:01 <kosmikus> still, the window seems to remain empty at all time, regardless of what I do
11:15:34 <ski> mwc : no
11:15:38 <conal> well, that's what i wanted to find out.  i used a tool to convert my 1.5 class files to 1.4.  i guess it didn't work perfectly.  thanks much for trying it out.
11:17:13 <kosmikus> ok
11:18:05 <ski> mwc : i assume Pseudonym just meant a function using an accumulator (probably tail-recursive) by AccumulatorRecursion
11:32:18 <Lokadin> say anyone here try using mediawiki?
11:34:00 <gr00ber> could someone please explain what a closure is... to a scrappy C programmer :-)
11:36:16 <neologism> piece of code
11:37:09 <gr00ber> huh?
11:37:16 <xerox> gr00ber: a piece of code enclosing part of its environment
11:37:32 <gr00ber> meaning?
11:37:36 <xerox> It's difficult to see it, from a C point of view.
11:38:30 <Cale> Well, imagine if C had a way to compile functions at runtime
11:38:32 <astrolabe> I think if you make a function that added water depth to an aeroplane altitude.
11:38:32 <gr00ber> seems so
11:38:37 <Cale> and we wrote something like
11:38:51 <Cale> k = 5;
11:39:06 <astrolabe> and the water depth was chosen at a different time to the function call.
11:39:27 <Cale> f (int x) { return (k + x); }
11:39:43 <Cale> defining f as a new function based on the value of k
11:39:58 <Cale> f captures the value of k at the time it is constructed
11:40:13 <gr00ber> which requires f to be a runtime construct
11:40:16 <Cale> right
11:40:19 <gr00ber> not in C, which is a compile-time construct
11:40:21 <gr00ber> oh, ok
11:40:38 <gr00ber> so can struct instances and function be somehow combined to accomodate this idiom in C?
11:40:44 <gr00ber> functions...
11:40:46 <astrolabe> Could you not get that functionality in C?
11:41:06 <Cale> astrolabe: well, you can get various approximations to it :)
11:41:09 <gr00ber> so it's kinda function instances?
11:41:21 <gr00ber> like functors in C++ ?
11:41:37 <Cale> You could keep a more general function, together with a struct which stores any parameters which are already filled in
11:42:29 <astrolabe> I've never seen a proper continuation in haskell
11:42:49 <Cale> astrolabe: that's because first-class continuations are evil
11:43:22 <Cale> (they break referential transparency)
11:43:37 <Cale> you can do ordinary CPS
11:43:41 <astrolabe> Ah good.  I think I must have a nose for evil.
11:44:04 <ski> gr00ber : typedef struct {void *data; Foo (*fun)(void *data,Bar bar,Baz baz)}; Foo_BarBaz_Closure' this can simulate it
11:44:18 * gr00ber reads that ugly piece of code
11:44:36 <gr00ber> Cale, first-class cont's ?
11:44:55 <astrolabe> He asks for C and then grumbles that it's ugly!
11:45:08 <gr00ber> foo bar baz....
11:45:15 <Cale> gr00ber: as in, at any point, you can capture the future of the current computation as a function, and pass it into another function
11:45:24 * ski is not convinced linear first-class continuations are evil
11:45:29 <palomer> @hoogle (\\)
11:45:30 <mbot> No Result Found.
11:45:34 <palomer> @hoogle \\
11:45:35 <Cale> ski: how could you not?
11:45:35 <mbot> No Result Found.
11:45:43 <astrolabe> @hoogle (//)
11:45:44 <mbot> No Result Found.
11:45:52 <Cale> @type Control.Monad.Cont.callCC
11:45:53 <mbot> forall (m :: * -> *) a b.
11:45:53 <mbot>           (Control.Monad.Cont.MonadCont m) =>
11:45:53 <mbot>           ((a -> m b) -> m a) -> m a
11:45:59 <gr00ber> ski, and how would this struct be used?
11:46:01 <astrolabe> @hoogle //
11:46:03 <mbot> No Result Found.
11:46:03 <ski> Cale : "... *linear* ..."
11:46:05 <Cale> we can do it in a monad though -- I think that's fine
11:46:07 <Cale> ski: oh
11:46:16 <ski> Cale : a first-class version of that is *not* linear
11:46:25 <gr00ber> what's a monad? Kinda closure?
11:46:36 * gr00ber 's a functional n00b
11:46:39 <palomer> gr00ber: careful what you say around these parts, partner
11:46:40 <Cale> gr00ber: that's a question with a long answer
11:46:49 <gr00ber> palomer, what?
11:47:04 <palomer> gr00ber: I was doing my best chuck norris impression
11:47:09 <Cale> A monad is a generalisation of container types or of types of computations, depending on the way you look at it.
11:47:24 <Cale> @oldwiki MonadsAsContainers
11:47:24 <mbot> Unknown command, try @listcommands.
11:47:29 <Cale> oh right
11:47:30 <ski> gr00ber : you'd store closure-local data in the 'data' field, and the closure would access it, when used (you should only pass a 'data' to the corresponding 'fun', never to another one)
11:47:31 <Cale> @wiki MonadsAsContainers
11:47:35 <mbot> No Result Found.
11:47:42 <palomer> @hoogle [a] -> [a] -> [a]
11:47:42 <gr00ber> this mbot is pretty dumb
11:47:43 <mbot> http://www.apple.com/
11:47:46 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
11:47:54 <gr00ber> hm, ok
11:48:00 <Cale> mbot doesn't have the same plugins as lambdabot
11:48:07 <astrolabe> monads let you abstract out the kind of imperitive processing you are doing.
11:48:12 <Cale> I moved it in here for the time being since lambdabot seems down
11:48:27 <gr00ber> ski, that looks more like a "this" pointer than anything else
11:48:47 <gr00ber> in c++ parlace
11:48:49 <Cale> Well, looked at one way, it's imperative
11:48:59 <ski> gr00ber : maybe that's because (according to some) "objects are a poor-man's closures"
11:49:11 <gr00ber> really...?
11:49:21 <ski> (gr00ber : also some say "closures are a poor-man's objects" ;)
11:49:33 <gr00ber> well, hell, now I'm confused
11:49:48 <ski> gr00ber : you can, more or less, simulate one with the other
11:50:02 <gr00ber> ok, so let's simulate closures with objects :-)
11:50:07 <gr00ber> come on, tell me !
11:50:25 <ski> it's usually painful
11:51:11 <Excedrin> just think of it as a function that carries around some state, it's kinda like a some data that has some member functions
11:51:12 <Cale> well, you'd have some evaluate method, and your constructor would plug values into a bunch of private variables.
11:51:14 <ski> i believe the 'functors' you mentioned before is something like that .. in Java you can use inner classes (but have to copy stuff explicitely with constructor, bleh !)
11:51:37 <Cale> and that would be about it
11:52:27 <Cale> so you'd need a new class for every kind of closure.
11:52:34 <gr00ber> hm
11:52:40 <astrolabe> So, why don't we say that almost all classes are closures?
11:53:09 <Philippa> because many of them aren't as such. Records-of-closures, maybe
11:53:10 <astrolabe> Is it just a matter of perspective?
11:53:10 <Cale> astrolabe: only one method, which evaluates the closure as a function, given any extra parameters
11:53:19 <gr00ber> Excedrin, well, that explanation makes sense. Just as objects carries data, functions carries data...
11:53:30 <gr00ber> wonder when it's useful...
11:53:41 <Cale> well, you use them in Haskell without thinking about it
11:53:50 <gr00ber> I think I miss the basic principle
11:53:53 <astrolabe> Cale: example?
11:54:00 <Cale> > filter (< 5) [3,10,2,9,7,8]
11:54:01 <mbot> [3,2]
11:54:03 <Philippa> they're useful *all the time* :-)
11:54:10 <gr00ber> appears functions are something you instantiate
11:54:26 <Cale> (< 5) is a sort of closure
11:54:40 <Cale> I've packaged up the function (<) with one of its parameters
11:55:01 <astrolabe> I think the concept of closure is a point of view about something rather than an objective definition.
11:55:04 <Cale> giving another function
11:55:16 <astrolabe> Cale: right. thanks.
11:55:29 <gr00ber> so, in C parlace, less(5) (int[] { your numbers} ) ?
11:55:42 <gr00ber> would return int[] { 3,2 } ?
11:56:02 <Cale> well, that's higher order
11:56:08 <gr00ber> the difference beeing that less(5) is a different function than less(4)
11:56:19 <Cale> so  filter (less (5), int [] {...})
11:56:25 <gr00ber> while in C, it's just the same function with different args
11:56:40 <Cale> well, if less returns another function
11:56:49 <gr00ber> Cale, right... you apply the function to another function (filter)
11:56:54 <gr00ber> ?
11:56:55 <Cale> but the problem is that it can't really do that, so it would have to return a struct
11:57:01 <Philippa> actually you apply filter to that function. But same difference
11:57:08 <Cale> I apply filter to less (5)
11:57:21 <Cale> which actually gives me another function
11:57:21 <gr00ber> I can accept both
11:57:27 <Cale> which I apply to the list
11:57:40 <Cale> > filter (< 5) [1,2,3,4,5,6,7,8,9,10]
11:57:41 <mbot> [1,2,3,4]
11:57:49 <Cale> > (filter (< 5)) [1..10]
11:57:50 <mbot> [1,2,3,4]
11:57:53 <astrolabe> Or you could say that filter (< 5) was your closure.
11:57:56 <Cale> right
11:58:14 <Cale> I can write in the extra parens there to emphasise that
11:58:21 <Philippa> all haskell functions have exactly one parameter. They might return a function to take the next one though
11:58:34 <gr00ber> how is this implemented? Is it like... for each number in the set of "< 5", the less function yields values to filter?
11:58:34 <astrolabe> So you can get the same functionality in C, but not with the normal function application notation.
11:58:49 <Cale> filter p [] = []
11:59:01 <Philippa> gr00ber: implementations vary. It's roughly like that in Haskell because Haskell is a lazy language
11:59:19 <Cale> filter p (x:xs) = if p x then x : filter p xs else filter p xs
11:59:30 <Philippa> filter passes values into its first parm and gets a boolean out
11:59:52 <Cale> which it uses to decide whether to add that element to the new list
11:59:54 <astrolabe> but filter is a red herring if you are trying to understand closures.
12:00:20 <Cale> Well, almost any Haskell function could be viewed as a closure.
12:00:29 <Cale> (unless it's primitive)
12:00:34 <astrolabe> > (< 5) 6
12:00:35 <mbot> False
12:01:31 <Cale> gr00ber: the neat thing about lazy evaluation is that lists become basically the same thing as loops
12:01:49 <gr00ber> sounds like the only practical implementation
12:01:56 <Cale> only they're a little more concrete than loops :)
12:02:04 <gr00ber> it's not like computing the set upfront is always feasible
12:02:30 <gr00ber> so, is that peyton lad around here anytime?
12:02:55 <Cale> Simon P-J, I don't think so, but Simon Marlow is sometimes.
12:03:53 <gr00ber> ok
12:03:55 <Cale> If you really want to know how this is evaluated, you'll want to read the STG machine paper
12:04:09 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:04:18 <Cale> (links on the right)
12:04:25 <gr00ber> i'll bookmark it and read when my head hurts less
12:04:33 <gr00ber> (pun intended)
12:04:43 <Cale> hehe
12:04:52 <astrolabe> I think it would sensible to play with haskell a lot first.
12:04:56 <Cale> yeah
12:05:15 <gr00ber> is LOGO considered a functional language?
12:05:44 <Philippa> good question, and one with potential for heated debate. I wouldn't myself, but I'd say it's closely related
12:05:44 <Cale> I think it's considered imperative
12:06:37 <Philippa> I would. It's certainly related to the lisp family, but hey
12:07:20 <Cale> can one write, say, foldr in logo?
12:08:06 <Philippa> I think so
12:08:13 <astrolabe> FORWARD 100 
12:08:13 <astrolabe> LEFT 90 
12:08:13 <astrolabe> FORWARD 100 
12:08:13 <astrolabe> LEFT 90 
12:08:13 <astrolabe> FORWARD 100
12:08:14 <astrolabe> LEFT 90
12:08:16 <astrolabe> FORWARD 100
12:08:18 <astrolabe> LEFT 90
12:08:21 <Cale> hehe
12:08:22 <Philippa> certainly you can pass around blocks of instructions
12:08:24 <astrolabe> looks pretty stateful
12:08:39 <Philippa> looks like do notation, too ;-)
12:08:43 <gr00ber> the state of the turtle is passed around for sure
12:08:44 <Cale> well, it is stateful, nobody is going to argue that
12:09:05 <gr00ber> Well, gotta go. Thanks for helping. Always nice to hit a friendly and helpful IRC channel (doesn't happend to often)
12:09:09 <Cale> there's an easy monad translation there :)
12:09:10 * gr00ber away
12:09:15 <Cale> later
12:09:21 <kosmikus> so, does logo have first-class functions?
12:09:53 <TuringTest> Where is a LOGO spec?
12:10:03 <TuringTest> (I can't ask lambdabot...)
12:10:50 <TuringTest> Speaking of which: is dons around?
12:11:07 <Cale> I don't know if logo is even standardised
12:12:10 <TuringTest> There could be a LOGO-06 standard then...with arrows!
12:12:45 <Cale> and monadic recursion!
12:12:49 <astrolabe> @localtime dons
12:12:52 <mbot> Local time for dons is Fri Feb 24 07:12:37 2006
12:13:10 <astrolabe> out of bed lazy bones!
12:13:18 <Cale> heheh
12:13:37 <TuringTest> Good point. ( 8:13 PM here)
12:14:24 <astrolabe> Me too.
12:14:28 <astrolabe> @map
12:14:28 <mbot> Maybe you meant: math msg
12:14:38 <astrolabe> maybe I didn't
12:15:45 <TuringTest> Okay...what is mbot?
12:16:28 <astrolabe> I don't know.  Is it related to mathematica?
12:16:43 <astrolabe> @Integrate
12:16:44 <mbot> Unknown command, try @listcommands.
12:16:51 <astrolabe> @listcommands
12:16:51 <mbot> use listcommands [module|command]. Modules are:
12:16:51 <mbot> babel base dict dynamic haddock help karma localtime math more pl plugs search seen system type vers
12:16:53 <int-e> It's Cale's lambdabot. It has an Mathematica interface.
12:16:56 <int-e> % help
12:16:57 <mbot> int-e: "See http://documents.wolfram.com/v5/ for detailed Mathematica help."
12:17:03 <dcoutts_> CosmicRay, I've added hdbc packages to gentoo
12:17:50 <dcoutts_> CosmicRay, it went quite smothly, you did a better packaging than hsql :-)
12:18:11 <dcoutts_> now the only thing missing vs. hsql is a mysql backend :-)
12:19:44 <TuringTest> % Simplify[ x*x - x]
12:19:46 <mbot> TuringTest: (-1 + x)*x
12:19:55 * TuringTest nods
12:20:27 <Cale> % Integrate[ Sqrt[Cos[x]], x]
12:20:30 <mbot> Cale: 2*EllipticE[x/2, 2]
12:20:37 <TuringTest> % %
12:20:39 <mbot> TuringTest: "See http://documents.wolfram.com/v5/ for detailed Mathematica help."
12:20:52 <TuringTest> Ah, it does not keep the last expression in %
12:21:10 <TuringTest> % x = 5; x*x
12:21:13 <Cale> Well, it does, but that's the last thing it does when initialising mathematica :)
12:21:13 <mbot> TuringTest: 25
12:21:22 <TuringTest> % x + 5
12:21:24 <mbot> TuringTest: 5 + x
12:21:29 <Cale> % x = 5; x * x; %^2
12:21:31 <mbot> Cale: "See http://documents.wolfram.com/v5/ for detailed Mathematica help."^2
12:21:35 <Cale> hehe
12:21:43 <Cale> nope
12:22:00 <Cale> I suppose you just can't use % usefully at all.
12:22:26 <TuringTest> I have 5.2.0.0 (student version) here
12:22:29 <heatsink> How do I pass a Handle to foreign C code?  handleToFd has the side effect of closing the handle, which is not what I want...
12:25:13 <Cale> does the C code need to use the Handle in any way?
12:25:45 <heatsink> Yes
12:25:51 <Cale> hmm
12:26:28 <heatsink> I'm basically using C functions to write Floats to a file as 32-bit numbers
12:26:40 <musasabi> heatsink: you use a dirty unsafeHandleToFd
12:26:54 * heatsink looks for it
12:28:04 <musasabi> it does not exist, but is quite easy to define. (I am grepping my sources, but it was ~5 lines)
12:28:30 <heatsink> oh, nice.
12:29:46 <Cale> couldn't you have the C function pass you back the Fd, which you then convert back into a handle?
12:30:02 <Cale> (or possibly keep the Fd around)
12:30:12 <heatsink> I could probably write my code to use Fds...
12:30:26 <heatsink> yea, that would work.
12:30:26 <Cale> well, you can just apply fdToHandle
12:31:55 <Cale> which will have the side effect of making the Fd go into non-blocking mode, but that's not likely to be a problem
12:32:24 <Cale> especially if you're already done with the Fd at that point.
12:33:14 <musasabi> import GHC.IOBase
12:33:14 <musasabi> import GHC.Handle
12:33:14 <musasabi> unsafeHandleToFD :: Handle -> IO FD
12:33:14 <musasabi> unsafeHandleToFD h = withHandle_ "unsafeHandleToFd" h (return . haFD)
12:33:54 <heatsink> musasabi: Have to turn off buffering first?
12:34:07 <Cale> withHandleAsFd hdl x = do fd <- handleToFd hdl; v <- x fd; hdl' <- fdToHandle fd; return (v,hdl')
12:35:18 <Cale> might need to State transform IO if you have a lot of those though :)
12:36:23 <heatsink> musasabi: I think I'll switch to using Fd, but thanks.  I found the Handle__ definition in the source in case I ever need to refer back to it.
12:37:33 <heatsink> Cale: Oh, I see what you're saying.  The Handle is closed, but not the file descriptor...
12:37:39 <Cale> right
12:37:43 <Cale> you can convert it back
12:46:45 <SimonRC> I have a function I think should be possible to write as a fold, but I cannot see a sensible way to do it (i.e. without lots of lambdas):
12:47:01 <SimonRC> it is called extracts, and here is an example:
12:47:10 <SimonRC> > let extracts = extracts' id; extracts' f (x:xs) = (x, f xs) : extracts' (f . (x:)) xs ; extracts' _ [] = []in extracts [1, 2, 3, 4, 5]
12:47:14 <mbot> [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
12:47:44 <SimonRC> and clues on a better way to write this (with a combinator rather than explicit recursion)
12:47:50 <SimonRC> * any
12:48:33 <heatsink> Is it only for length-five lists?
12:48:41 <SimonRC> any length of list
12:48:55 <SimonRC> > let extracts = extracts' id; extracts' f (x:xs) = (x, f xs) : extracts' (f . (x:)) xs ; extracts' _ [] = []in extracts ['a'..'g']
12:48:57 <mbot> [('a',"bcdefg"),('b',"acdefg"),('c',"abdefg"),('d',"abcefg"),('e',"abcdfg"),('f',"abcdeg"),('g',"abc
12:49:17 <heatsink> oh -- I didn't notice where the definition ended, nevermind me
12:49:45 <SimonRC> let ... in can be confusing like that.
12:51:38 <TuringTest> It does not look like a simple fold to me
12:51:43 <TuringTest> unfoldr, however
12:54:24 <SimonRC> my function runs in O(n^2), doesn;t it?
12:54:54 <int-e> yes. but you can't help that without changing the list representation.
12:55:24 <TuringTest> > let foo (pre,[]) = Nothing; foo (pre,x:xs) = Just ( (x,pre xs) , (pre . (x:), xs)); in unfoldr foo (id,[1,2,3,4,5])
12:55:26 <mbot> [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
12:55:29 <TuringTest> There
12:56:17 <TuringTest> SimonRC: I thought it was unfoldr
12:59:56 <int-e> @type (\x y z -> y z x) (\a b c ->  c a b) (\a b -> b a)
12:59:57 <mbot> forall t
12:59:57 <mbot>                      t1
12:59:57 <mbot>                      t2.
12:59:57 <mbot>                   t -> t1 -> (t -> t1 -> t2) -> t2
13:00:36 <SimonRC> TuringTest: interesting
13:00:58 <TuringTest> SimonRC: But not really better than the original
13:01:18 <SimonRC> no, alas
13:01:41 <SimonRC> I believe J has an operator to do it, though :-)
13:01:59 <TuringTest> If you use a different data structure it would not be so bad
13:02:39 <TuringTest> What is done with the result of extract ??
13:04:50 <SimonRC> TuringTest: I am using it for the travelling salesman problem...
13:05:16 <int-e> > let extract l = foldr (\(a,b) l -> (a,b):map (second (a:)) l) [] $ (map (\(a:b) -> (a,b)) $ init $ tails l) in extract "abcd"
13:05:17 <mbot> [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
13:05:25 <SimonRC> It takes a list of unvisited cities and returns all possible (next city, remaining unvisited cities) pairs
13:05:50 <TuringTest> You should use Data.Set instead of Data.List 
13:06:03 <int-e> SimonRC: it's O(n^2) because it has to create O(n^2) new list conses - the initial segments of the result lists can not be shared.
13:06:04 <SimonRC> would that be any better?
13:06:10 <SimonRC> int-e: I know
13:06:34 <TuringTest> int-e: Would Data.Set be more efficient?
13:06:38 <int-e> Data.Set has O(log n) deletion - asymptotically that's definitely better.
13:07:31 <SimonRC> ah, so I'd have O(n*log n)
13:07:33 <SimonRC> ok
13:07:48 <int-e> but, you can do better by using two lists to represent the set
13:08:05 <TuringTest> Exactly...
13:08:12 <SimonRC> The constants are larger for Set, though, and I don;t know how many cities will be in the problem
13:08:16 <SimonRC> int-e: how?
13:08:28 <TuringTest> I'll paste an example
13:10:21 <int-e> SimonRC: basically you have two stacks and always shuffle items from one stack to the other.
13:10:32 * SimonRC thinks about this
13:10:42 <SimonRC> yeah, makes sense
13:10:57 <SimonRC> Maybe I'll leave that optmisation to later, though.
13:13:11 <TuringTest> ok
13:13:48 <ValarQ> what happened to lambdabot?
13:14:23 <TuringTest> ValarQ: Talk to mbot
13:14:35 <ValarQ> mbot: what happened to lambdabot?
13:15:10 <palomer> watch out, or it might happen to you too
13:15:14 <SimonRC> :-)
13:15:22 <ValarQ> ?
13:16:38 <int-e> > let perm t [x] [] tl = (x:t):tl; perm _ [] _ tl = tl; perm t (a:as) bs tl = perm (a:t) as bs $ perm (a:t) bs as $ perm t as (a:bs) tl in perm [] [1,2,3] [] []
13:16:40 <mbot> [[3,2,1],[2,3,1],[1,3,2],[3,1,2],[1,2,3],[2,1,3]]
13:17:31 <int-e> SimonRC: this piece of code uses that idea - the second and the third argument to perm are the two stacks. the first is the tail of the permutations to generate; the last is the list of permutations to append to the result.
13:20:04 <lisppaste2> TuringTest pasted "for SimonRC" at http://paste.lisp.org/display/17147
13:21:00 <TuringTest> That was my approach to a Set as two stacks
13:21:59 <TuringTest> int-e: Is the pasted code what you meant?
13:22:42 <int-e> TuringTest: yes, although I'd put the burden of swapping the right and left stacks to the caller
13:23:03 <TuringTest> Feel free to annotate
13:23:16 <int-e> TuringTest: or at least I did that in the permutation generator above
13:24:27 <int-e> TuringTest: Actually I wouldn't do that if extract is the desired interface.
13:26:15 <TuringTest> I think my pasted code is O(4*N) , counting tuple and list constructors
13:27:20 <lisppaste2> int-e annotated #17147 with "just slightly shorter" at http://paste.lisp.org/display/17147#1
13:28:25 <TuringTest> int-e: excellent
13:29:07 <TuringTest> I should use that trick more often
13:39:12 <SimonRC> hmm
13:40:44 <SimonRC> thanks, guys
13:42:48 <SimonRC> I'd never have thought of that kind of algorithm.
13:42:49 <SimonRC> hmm
13:44:07 <TuringTest> The idea is to exploit that fact you do not care about the order of the set of untraversed points
13:45:24 <SimonRC> yeah
13:45:29 <TuringTest> The Data.Queue structure likely uses a similar pair of Data.List 
13:45:45 * SimonRC knows the trick behind Queue
13:45:54 <TuringTest> Same trick here
13:46:26 <SimonRC> Trouble is, I will have to declare that you helped me if I use this function in the assignment.
13:46:29 <int-e> there's a similar concept in text editors, where data is organized in a block of memory such that the text before the cursor is at the beginning of the buffer and the text after the cursor at the end, with a gap in the middle. If the cursor moves slowly through the file that's quite efficient.
13:47:10 <SimonRC> Some kind of ballanced tree would be good in other cases.
13:47:14 <int-e> you can think of these both ends as stacks, too - and the data structure supports navigation, deletion and insertion.
13:47:28 <SimonRC> yes
13:50:35 <int-e> heh.  perm' x = extracts x >>= \(a, y) -> map (a:) $ perm' y  is an almost complete permutation generator using extracts; the only thing that's missing is the base case.
14:20:26 <s> hi
14:20:33 <s> smile with this: http://www.collegehumor.com/movies/67664/
14:26:37 <xerox> What's funny about that?
14:34:20 <jethr0> can anyone help me with yampa / opengl?
14:34:51 <jethr0> or rather concretely with opengl under haskell?
14:36:54 <xerox> Boegel did something with OpenGL.
14:37:09 <xerox> It was quite a bit of understandable code IIRC.  L-systems.
14:38:29 <jethr0> xerox: hmm, i've got an 8-line example from a tutorial and it compiles just fine. but there never opens a window :(
14:38:52 <xerox> Try Kenneth's code.
14:40:00 <Lemmih> Sigh. GHC contains 632 'returnM's, 182 'mappM's and 935 'thenM'+'thenM_'s.
14:40:00 <jethr0> xerox: where do i find that? for example the space invaders code from yampa works just fine...
14:40:31 <jethr0> Lemmih: why is that bad?
14:40:35 <xerox> There is something on the wiki, jethr0.
14:41:00 <jethr0> k
14:41:34 <Lemmih> jethr0: Because using 'return', 'mapM' and the do-notation would be much prettier.
14:44:08 <dons> Lemmih, yeah, a lot of it was written in the early 90s
14:44:08 <jethr0> xerox: which wiki page do you mean? i'm having problems with the examples on the hopengl wiki page also :(
14:44:19 <xerox> Let me find it for you.
14:45:15 <lisppaste2> jethr0 pasted "opengl try" at http://paste.lisp.org/display/17154
14:45:31 <Lemmih> dons: Hiya!
14:45:37 <Lemmih> dons: lambdabot is gone.
14:45:54 <jethr0> this is an example straight from google(hopengl filetype:pdf). it compiles, but doesn't open a window...
14:47:29 <xerox> If only the wiki worked for me... grmbl.
14:47:48 <xerox> http://haskell.org/hawiki/KennethHoste
14:47:49 <xerox> IIRC.
14:47:54 <jethr0> thx
14:48:17 <xerox> It should have a link to his site, where his code is located.
14:48:37 <xerox> Right!
14:48:45 <xerox> http://www.elis.ugent.be/~kehoste/Haskell/HaskLS/
14:50:15 <int-e> @index fromJust
14:50:15 <mbot> Data.Maybe
14:51:34 <xerox> With maybe you can specify a default value, "Exception: fromJust: Nothing" sucks.
14:54:00 <int-e> xerox: I know
14:54:10 <int-e> xerox: but thanks anyway :)
14:55:49 <int-e> xerox: I'm just trying to avoid a pattern guard. The code is: f x | isJust foo = ... fromJust foo ... where foo = <something>
14:57:27 <xerox> int-e: What about "... where (Just foo) = <something>"
14:57:56 <int-e> xerox: hmm. I don't know what happens if that pattern match fails?
14:57:57 <jethr0> xerox: that isn't equivalent with the guard...
14:58:08 <xerox> The same thing, but looks better <grin>
14:58:31 <int-e> xerox: I'd expect an error.
14:59:03 <xerox> Why are you avoiding it anyway?
14:59:39 <int-e> "Irrefutable pattern failed for pattern Data.Maybe.Just n"
14:59:56 <xerox> ~(Just n) ?
15:00:11 <int-e> no, just that where clause you suggested
15:00:20 <xerox> Okay.
15:01:55 <dons> ah, no lambdabot. hmm.
15:02:23 <int-e> xerox: The program is finished and there's just that one line that uses a non-Haskell-98 extension (if I can trust ghc). It's a purely cosmetic reason.
15:02:48 <xerox> int-e: right.  As you please.
15:03:47 <Lemmih> lambdabot: @vixen You're back!
15:03:47 <lambdabot> I will NOT be ignored...
15:04:44 <int-e> now someone needs to tell Cale that mbot can leave again.
15:05:08 <jethr0> @version
15:05:08 <mbot> lambdabot 3p287, GHC 6.4.1 (Linux i686)
15:05:08 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:05:09 <lambdabot> lambdabot 3p290, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
15:05:09 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
15:06:00 <dons> mbot: @quit
15:07:20 <xerox> Poor mbot.
15:07:36 <xerox> dons: it serves other channels as well :-D
15:07:38 <int-e> poor #math
15:07:40 <dons> she does her job well, but she's just a temp ;)
15:07:47 <dons> oh. oops...
15:07:52 <dons> @karma- dons
15:07:52 <lambdabot> You can't change your own karma, silly.
15:08:00 <xerox> NP.
15:08:03 <int-e> @karma- dons
15:08:04 <lambdabot> dons's karma lowered to 21.
15:08:07 <vincenz> @karma 
15:08:08 <lambdabot> You have a karma of 2
15:08:10 <vincenz> :/
15:08:13 <xerox> FOO, you have lots of karma.
15:08:19 <xerox> I'm 1/dons.
15:08:21 <int-e> @karma
15:08:21 <lambdabot> You have a karma of 4
15:08:30 <xerox> Err... dons/2.
15:10:39 <lispy> @karma lispy
15:10:39 <lambdabot> You have a karma of 3
15:10:52 <lispy> so 'm dons/7
15:11:20 <lispy> heh, karam needs a plugin to represent a given karma as a function of dons's karam :)
15:11:27 * xerox laughs
15:11:33 <int-e> @karma lambdabot 
15:11:33 <lambdabot> lambdabot has a karma of 10
15:13:43 <dons> hehe
15:14:02 <dons> lispy, I'll hack this up. sounds like fun :)
15:14:11 <xerox> I was about too, heh.
15:14:17 <dons> ok, go for it.
15:14:26 <dons> I've got  to fix why the @seen module isn't loading anymore
15:14:30 <dons> @seen
15:14:30 <lambdabot> Unknown command, try @listcommands.
15:14:31 <xerox> dons: no problem, I have other things to do too.
15:14:44 <xerox> Also, I'd love to add a @>.>
15:15:21 * int-e wonders how many people will try to cause a division by zero by lowering dons' karma to 0 then
15:15:30 <dons> bad int-e
15:15:46 <int-e> It's not me, it's the voices in my head ;)
15:15:59 <dcoutts> poor int-3
15:16:06 <xerox> Oh, a Duncan!
15:16:12 <dcoutts> 3/e
15:16:17 <dcoutts> xerox!
15:16:46 <dcoutts> it's ME! Hurrah!
15:17:09 <TuringTest> dons: Hi.  I saw your regex-dna forum thread
15:19:57 <xerox> How did the effort in conjure finished?
15:22:33 <dons> TuringTest,  yeah, I'd kind of depressing. 
15:23:09 <TuringTest> The bibliography is impressively long
15:23:28 <Lemmih> xerox: 'conjure' the bittorrent client?
15:23:30 <TuringTest> I may try to compress the parsing stage for the string regex (I just started poking at that)
15:24:28 <xerox> Lemmih: yess.
15:25:00 <jethr0> dons, i had problems representing an eager regex parser with parsec. is your eager?
15:25:42 <TuringTest> jethr0: It is eager
15:25:54 <Lemmih> xerox: It's almost done except I'm not sure how to write the unchoking/choking algorithm without resorting to dirty hacks.
15:25:55 <TuringTest> Rather--- It is longest total match
15:26:13 <dons> did you look at the entry I posted on the wiki?
15:26:21 <dons> I combines your string frontend with the existing entry
15:26:30 <TuringTest> dons: I copied that entry, I am compressing it now
15:26:40 <dons> at least at the moment Isaac hasn't ruled strongly against us
15:26:43 <jethr0> TuringTest: k, i'll have a look at the code. or could you explain in two sentences how you managed to make it eager?
15:26:53 <xerox> Lemmih: ah cool.  I didn't read carefully the conjure list.  What's the problem?
15:26:53 <dons> so maybe nothing will happen, or maybe we just need a string regex frontend
15:27:19 <TuringTest> jethr0: What do you mean?  The CTK engine is "longest match"
15:27:50 <jethr0> ctk?
15:28:20 <TuringTest> jethr0: I misunderstood.  What are you looking at again?
15:28:41 <TuringTest> I wrote the string regex parser that dons program is using
15:28:58 <TuringTest> It uses Parsec
15:29:39 <jethr0> TuringTest: in one version dons is using a regex compiler that compiles "normal" regular expressions into parsec combinators. i tried the same thing, but only achieved lazy matching (i.e. shortest match)
15:30:10 <TuringTest> Could you point to the version you are talking about?
15:32:27 <jethr0> TuringTest: either some entry has changed or i've dreamt the whole thing. i'll just look at the latest entry again (which is horribly long)
15:33:04 <TuringTest> The Wiki page was edited and old ones deleted, you can access the history here : http://haskell.org/hawiki/RegexDna?action=info
15:33:35 <dons> jethr0, I only ever wrote _lexer_ combinators, from the CTK lib
15:33:44 <dons> we did write a few ones with parsec though
15:33:51 <TuringTest> jethr0: Is this what you saw : http://tinyurl.com/mynb7
15:33:53 <dons> which may be a backup if the ctk entry gets disqualified
15:34:03 <dons> since we can import it as a standard library
15:34:35 <dons> TuringTest, how do you think the thread is going? are they going to rule against us? or will they just ban the entries that don't use regexes for all parts of the problem?
15:34:42 <jethr0> maybe, nm
15:34:56 <TuringTest> dons: I think we just need the regex string parser.
15:35:13 <dons> it really makes me think that there should be some benchmarks that test things like higher-order functionnn performance
15:35:41 <dons> you tthink that Josh is just thrown by the syntaxX?
15:35:45 <TuringTest> dons: It would be a moot point if GHC had okay Regex support
15:36:14 <jethr0> dons: just in theory, are eager "regular expressions" in LL? because i had real trouble trying to make my parsec solution eager...
15:36:17 <dons> yeah, I think it is two things: 1) syntax of combinators versus regex strings. 2) ctk isn't in the base lib, and isn't imported
15:36:35 <TuringTest> dons: beats me.  Josh seems like a very conservative rule reader, which works poorly in the shootout.
15:36:41 <Lemmih> xerox: Well, it's impossible to tell whether the remote peer will unchoke and request a data block if we unchoke our end. That means we need the choking logic in both the STM code (which will unchoke depending on the number of unchoked peers and the configuration) and in the network code (which will make sure that we don't accidently start uploading to peers who change their interest state). And doing the previous can result in cases wher
15:37:05 <dons> yeah. lots of entries use a) hand-coded data structures, b) external libs c) work arounds
15:37:40 <dons> it's Isaac's show though, and he's only hinted that strings would be better. nothing more
15:38:04 <dons> jethr0, hmm. better read parsec's lib I reckon.
15:38:26 <dons> I'm almost certain parsec can implement greedy regular expressions though.
15:38:27 <xerox> Lemmih: the message was cut at "... the previous can result in cases wher"
15:38:42 <Lemmih> xerox: Those two hacks (logic code in two places, and time delay to fix loop) are so dirty that I won't implement them. Hopefully I'll find a neater solution.
15:38:55 <TuringTest> jethr0: This is a better version: http://tinyurl.com/lvw2a (the last one was truncated)
15:39:04 <jethr0> :)
15:39:12 <xerox> Lemmih: well-agreed.
15:39:52 <TuringTest> I claim http://tinyurl.com/lvw2a makes a string regex into a greedy parsec version of the regex
15:40:18 <dons> that's the kind of claim I like to hear :)
15:41:01 <jethr0> k, thx
15:42:50 <TuringTest> jethr0: The Alson Kemp regex engine in http://haskell.org/hawiki/RegexDna?action=recall&date=1139259959#head-eb9c8aaeedcae637b9788383595793a0922aa550 
15:42:58 <TuringTest> It can be lazy or greedy or both
15:43:06 <TuringTest> But avoids parsec
15:43:50 <dons> hmm, darcs pusll isn't a command ;)
15:44:02 <dons> my brain is funny sometimes.
15:45:48 <xerox> Hi Cale!
15:45:58 <xerox> Cale: blame dons, he killed our beloved mbot!
15:46:04 * xerox runs in circle screaming
15:46:44 <dons> I'm really sorry -- i thought the whole world was #haskell :/
15:46:51 <dons> "there are no other irc channels"
15:46:53 <xerox> I'm kidding :-)
15:47:13 <xerox> Is just that he runs mbot.
15:47:56 <dons> yep,  i know
15:48:01 <dons> myy bad.
15:48:07 * xerox hugs dons
15:48:11 <int-e> @quote-add dons I'm really sorry -- i thought the whole world was #haskell :/
15:56:59 <dons> something's werid. @quote is truncating files, and @seeen isn't loading.
15:57:02 <dons> @quote
15:57:05 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
15:57:07 <dons> ok. good.
15:58:20 <lispy> @quote
15:58:20 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks*
15:58:20 <lambdabot> I'll give you a cookie if you tell me how many letters that file has! -Oh,
15:58:20 <lambdabot> ok!
15:58:34 <lispy> hah
15:58:36 <lispy> @keal
15:58:37 <lambdabot> what is the max amount of operands haskell can handle in a single
15:58:37 <lambdabot> expression?
15:58:45 <int-e> hmm. full file system?
16:01:52 <ihope> Well, I think I know why declarations of the form Foo = bar are legal.
16:02:26 <ihope> Something like Just foo = bar is legal, as is (foo,bar) = baz. So why not Foo = bar?
16:02:46 <ihope> It doesn't actually do anything, but it's still legal.
16:03:32 <ihope> Of course, one might argue that it shouldn't be legal, as there's no reason to do it.
16:03:48 <ihope> > let Foo = bar
16:03:49 <lambdabot>  parse error on input `}'
16:03:51 <int-e> > 42 where Nothing = Just 1
16:03:52 <lambdabot> 42
16:04:00 <dons> patterns are fun :)
16:04:04 <ihope> :-)
16:04:09 <dons> > 42 where 0 = 1
16:04:10 <lambdabot> 42
16:04:14 <ihope> Now that was an odd error I got.
16:04:19 <xerox> o_O
16:04:21 <ihope> > 42 where 42 = 54
16:04:22 <lambdabot> 42
16:04:48 * ihope fastens Psuedonym in one place
16:04:56 <Cale> > let 0 = 1 in 0
16:04:57 <lambdabot> 0
16:04:58 <dons> > let 1 = 2 in 1+2
16:04:59 <lambdabot> 3
16:05:12 <dons> ah, Cale reads my mind
16:05:12 <ihope> > let 2+2 = 5 in 2+2
16:05:13 <lambdabot> 5
16:05:17 <dons> it's a great way to mess with people's head
16:05:19 <ihope> > let 2+2 = 5 in 4
16:05:20 <lambdabot> 4
16:05:25 <ihope> > let 2+2 = 5 in 2+3
16:05:26 <lambdabot>  Non-exhaustive patterns in function +
16:05:35 <xerox> > let 0 + x = x; n + x = pred n + succ x in 2 + 2
16:05:36 <lambdabot> 4
16:05:46 <ihope> Whoo.
16:05:53 * Pseudonym is done now
16:06:06 <dons> lets go crazy n+k style!
16:06:08 <ihope> > let 0 + x = x; n + x = pred n + succ x in (-2) + 6
16:06:12 <lambdabot> Terminated
16:06:25 * dons still wish for n*m patterns from Gofer
16:06:34 <ihope> Hmm.
16:06:39 <ihope> n/k
16:07:09 <dons> n^k ;)
16:07:14 <ihope> :-)
16:07:15 <dons> n! patterns
16:07:19 <dons> it'll be great!
16:07:25 <int-e> hmm. isPrime n | n = (2+k)*(2+l) = False | otherwise = True ?!
16:07:27 * int-e chuckles
16:07:41 <ihope> md5 n patterns!
16:07:50 <dons> oh yes. that's it!
16:07:54 <mauke> I want p ++ l patterns
16:07:57 <xerox> sqrt (n^3) = n
16:07:58 <int-e> err. (2+k)*(2+l) <- n  of course.
16:08:04 <ihope> > let foo (n*3) = n in foo 9
16:08:04 <lambdabot>  Parse error in pattern
16:08:04 <Cale> mauke: hehe
16:08:19 <Cale> mauke: would it choose the partition randomly?
16:08:20 <ihope> I tried to use one of those once.
16:08:35 <mauke> Cale: no, p must be a literal list
16:08:36 <tennin> (fib n) patterns
16:08:37 <xerox> guessTheConstructor (_ n) = n
16:08:39 <Cale> oh, okay
16:09:02 <int-e> xerox: guessTheConstructor (x _) = x :)
16:09:07 <ihope> xerox: guessTheContructor (1,2)
16:09:11 <dons> yeah, isprime patterns are the way to go.
16:09:12 <ihope> int-e: :-)
16:09:35 <Cale> heh, reserve p as a pattern matching variable and have it only match primes
16:09:41 <xerox> exchangeTheValueOfRandomConstructor (x _) k = x k
16:09:45 <Cale> and q should only match prime powers
16:10:18 <ihope> xerox: what's the type of that one? ;-)
16:11:00 <int-e> a -> b -> a ... now add some quantifiers.
16:11:31 <mauke> p a (_*) -> b -> p b $1
16:11:34 <ihope> exchangeTheValueOfRandomConstructor :: forsome a b. a -> b -> a
16:11:35 <xerox> forall (x :: * -> *) a k. (SomeClass x a k) => x a -> x k
16:12:08 <xerox> Right, it's a data constructors.
16:12:12 <xerox> -s
16:12:12 <ihope> mauke: just what's that do?
16:12:32 <mauke> that's the type of exchangeTheValueOfRandomConstructor!
16:12:58 <ihope> Oh.
16:13:03 <mauke> sadly, most haskell implementations don't support regexes in types
16:13:10 <ihope> Heh.
16:13:12 <xerox> Don't listen to mauke!  He talks perl!  <grin>
16:13:28 <ihope> > let exchangeTheValueOfRandomConstructor (x _) k = x k in exchangeTheValueOfRandomConstructor (Just 3) 4
16:13:29 <lambdabot>  Parse error in pattern
16:13:32 <ihope> Ow!
16:14:33 <ihope> Hmm...
16:15:19 <ihope> break (_ a) = a; break (_ a b) = (a,b); break (_ a b c) = (a,b,c)...
16:15:28 <ihope> We need typeclasses for that one, of course.
16:16:45 <xerox> Cool function.
16:16:59 <xerox> I wonder if there exist a language that supports it.
16:17:18 <mauke> @type flip (.) const . flip fmap w
16:17:19 <lambdabot> Not in scope: `w'
16:17:21 <mauke> @type flip (.) const . flip fmap
16:17:21 <lambdabot> forall a (f :: * -> *) a1.
16:17:21 <lambdabot>           (Functor f) =>
16:17:21 <lambdabot>           f a1 -> a -> f a
16:18:03 <xerox> That's cheating!
16:18:07 <Cale> Data.Generics can sort of approximate that sort of thing.
16:18:30 <xerox> Interesting.
16:19:22 <jethr0> TemplateHaskell can do that too...
16:26:07 <dons> mauke, oh, very nice. "flip (.) const . flip fmap" is pointfree heaven
16:28:48 <mwc> Suppose I have a class Vector, and I have an instance type data Vect = V2 Int Int | V3 Int Int Int. When I implement the functions in the Vector class, and I don't want "crossing" between types, how should I do it? Say I have (+) in the class, should I define (V2 x y) + (V2 u v); and similary for V3, and create a (_) + (_) = error "..." for the last case
16:29:12 <mwc> or is there a better way to handle this? that puts the error at runtime which I don't like
16:29:17 <mauke> why do you have a single Vect type?
16:29:23 <mwc> I've thought of separate 3Vector and 2Vector types
16:29:45 <mwc> this is somewhat of a pedantic example, the implementation is somewhat different
16:29:53 <mwc> but I think that phrasing it in this way actually just helped me resolve that
16:30:24 <mwc> The actual problem is ways of indexing a lattice
16:30:44 <TuringTest> dons: still there?
16:31:01 <dons> what the? -> seq: invalid floating point argument: 1q
16:31:06 <dons> ah, I get it.
16:31:10 <dons> TuringTest, yes?
16:31:25 <TuringTest> I have a smaller regex-dna parser--I'll put it on the wiki
16:31:41 <dons> go for it.
16:31:53 <dons> you want me to add it to the ctk entry?
16:31:55 <nothingmuch> what was the name of that article
16:31:59 <nothingmuch> ;-)
16:32:12 <nothingmuch> j/k
16:32:38 <nothingmuch> i can't remember the name of the article that shows that fold is a generalization of map, filter, etc
16:32:39 <TuringTest> maybe...(posting)
16:33:05 <dons> nothingmuch, sure it is.
16:34:48 <jethr0> @hoogle matrixexcursion
16:34:49 <lambdabot> No matches found
16:35:18 <Cale> excursion?
16:35:26 <jethr0> it's in hopengl somewhere...
16:35:46 <jethr0> like doing an excursion while not disturbing the currently active transformation matrix
16:36:51 <TuringTest> dons: I removed silly steps since the CTK has no string primitive.  PDot PString PAnyNot have all been removed.  The "simplify/merge" routine has been removed.  Quite a bit shorter.
16:39:35 <jethr0> does it really make sense to inline the CTK library into the entry? wouldn't "import ...CTK..." achieve a similar thing. i understand why it's in there (number of lines), but it makes the entry really much less readable (subjectively, first-glance-wise)
16:39:48 <nothingmuch> ahh! i found it
16:40:10 <nothingmuch> a tutorial on the universality and effectiveness of fold
16:41:06 <nothingmuch> @pl \delim strings ->  foldl1 ((++) . (++ delim)) strings
16:41:07 <lambdabot> foldl1 . ((++) .) . flip (++)
16:41:11 <Cale> foldr replaces (:) and nil with an arbitrary function and value
16:41:36 <TuringTest> dons: The wiki now has the shorter version, performance should not have detectably changed.
16:41:44 <Cale> nothingmuch: have you seen my nice diagrams?
16:42:03 <Cale> http://cale.yi.org/autoshare/folds.png
16:42:14 <nothingmuch> @pl \left right -> left ++ delim ++ right
16:42:14 <lambdabot> (. (delim ++)) . (++)
16:42:16 <nothingmuch> Cale: no, thank you =)
16:43:04 <robdockins> robdockins
16:43:13 <Cale> Cale
16:43:32 <robdockins> er.. sorry; client problems
16:46:25 <dons> jethr0, it would be better to iimport it, yes
16:46:33 <dons> but we'd have to install it onto the shootout box
16:46:50 <dons> cale.yi.org eh?
16:47:01 <dons> I want dons.yi.org :)
16:47:04 <jethr0> ah, i thought you'd send binaries there. nm then
16:47:19 <dons> nah, you post src. they compile it.
16:47:33 <jethr0> so other entries using some c libraries install them there?
16:47:51 <dons> yes, they've installed some C libs on the system
16:48:00 <dons> it's a bit "iffy", as we say.
16:48:06 <Cale> dons: you can have it
16:48:21 * jethr0 wants jethr0.yi.org
16:48:28 <jethr0> but i guess i should contribute first :)
16:48:28 <Cale> you don't ask me
16:48:33 <Cale> you set up an account :)
16:48:45 <Cale> it gives them away for free
16:48:56 <jethr0> hehe, i though it was related to the editor
16:49:13 <dons> I guessed as much :)
16:49:30 <Saulzar> Can you use template haskell to do some IO, download the source from Haskell.org and compile it? :)
16:51:25 * Igloo wonders why they chose yi
16:54:20 <dons> maybe I should sue
16:54:37 <Cale> probably most of the 2-letter domains are taken
16:55:01 <Saulzar> qz.org isn't
16:55:30 <jethr0> Saulzar: yes
16:55:51 <ihope> Hmm...
16:56:11 <jethr0> @oldwiki TemplateHaskellTutorial
16:56:11 <lambdabot> http://www.haskell.org/hawiki/TemplateHaskellTutorial
16:56:17 <jethr0> under "compile-time io"
16:56:29 <ihope> @type foldr
16:56:29 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
16:56:36 <Saulzar> I think they'd have some issues with such a solution...
16:56:45 <ihope> @type foldr (:) []
16:56:46 <lambdabot> forall a. [a] -> [a]
16:56:57 <ihope> > foldr (:) [] "Hello, world1"
16:56:58 <lambdabot> "Hello, world1"
16:57:03 <ihope> @type foldl
16:57:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:57:13 <jethr0> Saulzar: it's kinda evil. but there's a nice paper out there about compiling your binary to match some compile-time environment
16:57:16 <ihope> > foldr (flip (
16:57:17 <lambdabot>  parse error on input `}'
16:57:27 <ihope> > foldr (flip (:)) [] "Hello, world1"
16:57:28 <lambdabot>   Occurs check: cannot construct the infinite type: c = [c]
16:57:28 <lambdabot>   Expected type: c -> [c] -> c
16:57:28 <lambdabot>   Inferred type: c -> [c] -> [c]
16:57:54 <ihope> @type foldr (flip (:)) []
16:57:55 <lambdabot>   Occurs check: cannot construct the infinite type: c = [c]
16:57:55 <lambdabot>   Expected type: c -> [c] -> c
16:58:07 <ihope> > foldl (flip (:)) [] "Hello, world1"
16:58:08 <lambdabot> "1dlrow ,olleH"
17:16:40 <TuringTest> dons: Check out the string regex parser in http://haskell.org/hawiki/RegexDna#head-6da70f1f858433fb0d3b0c8411bf5622054f08a5
17:16:47 <TuringTest> I optimized it further
17:17:31 <TuringTest> dons: I goes straight from the string form to the CTK combinator form
17:17:40 <TuringTest> s/I goes/It goes/
17:22:00 <ihope> scramble [] = [] -- How boring.
17:25:13 <dons>  TuringTtest, ah, cool.  I thought we could do that.
17:26:01 <jethr0> TuringTest: "not an untyped string". well, as other languages will parse this string also, calling it "untyped" might be exaggerating a bit.
17:26:18 <dons> very nice TuringTest.
17:26:28 <dons> jethr0, they do it at runtime.
17:26:33 <dons> that was my comment)
17:26:59 <dons> whereas with combinators you can't construct, say, ** (an error)
17:27:34 <dons> (hopefully, I haven't actually it's well established that embedding a language is nicer than passing around strings representing that language
17:27:36 <jethr0> hmm, ok
17:27:43 <dons> this is why TH uses an AST
17:27:47 <ihope> Bad way to sort a list: scramble it according to some arcane algorithm, stick it into a binary search tree, then take it out again.
17:28:38 <jethr0> ihope: well, it's bound to be at LEAST O(n log n), i guess
17:28:49 * TuringTest returns
17:29:18 * jethr0 just got his first colored opengl triangle to turn soothingly
17:29:19 <TuringTest> dons: I had fun compressing that
17:29:24 * jethr0 b0ings
17:29:36 <TuringTest> @karma jethr0
17:29:36 <lambdabot> jethr0 has a karma of 0
17:29:41 <TuringTest> @karma jethr0 +1
17:29:42 <lambdabot> jethr0 has a karma of 0
17:29:50 <jethr0> *oh*
17:30:01 <TuringTest> crap...how does that work again
17:30:11 <TuringTest> @karma jethr0 (+1)
17:30:11 <lambdabot> jethr0 has a karma of 0
17:30:12 <jethr0> i think @karma+
17:30:20 <TuringTest> @karma+ jethr0 1
17:30:20 <lambdabot> jethr0's karma raised to 1.
17:30:23 <TuringTest> :)
17:30:24 <jethr0> *yeah*
17:30:43 <jethr0> now, on to yampa and a really nice game...
17:31:25 <ihope> @karma lambdabot
17:31:25 <lambdabot> lambdabot has a karma of 10
17:31:39 <ihope> @karma+ lambdabot 10
17:31:39 <lambdabot> lambdabot's karma raised to 11.
17:31:44 <ihope> ;-)
17:31:51 <dons> TuringTest, fun that you thought @karma :: String -> (Int -> Int) -> Int
17:32:12 <TuringTest> I forgot the karma+
17:32:21 <dons> irc is an untyped medium as well :)
17:32:32 <juhp> dcoutts: thanks for updating the debian download link
17:32:38 <jethr0> karma as a HOF would be much more idiomatic :)
17:32:49 <TuringTest> dons: The additional string parsing code is now very short -- it hurts less to submit it.
17:32:54 <dcoutts> juhp, thank's for pointing it out! :-)
17:32:56 <ihope> dons: that'd be IO Int, of course.
17:33:02 <ihope> Or IRC Int, maybe.
17:33:16 <dcoutts> juhp, we'd all been looking for that .deb
17:33:30 <juhp> dcoutts: a friend asked me - so I snooped around a bit on google :)
17:33:33 <juhp> lol
17:33:39 <dcoutts> heh
17:33:42 <Igloo> Where is it?
17:33:46 <TuringTest> dons: Getting "p_branch" correct was annoying, but once it compiled...it worked
17:33:59 <juhp> Igloo: http://haskell.org/gtk2hs/download/
17:34:04 <dcoutts> http://mentors.debian.net/debian/pool/main/g/gtk2hs/
17:34:21 <dons> TturintTest, yeah. it hardly hurts at all now. I say we do it if any action is taken on the complain raised on the forum
17:34:24 <jethr0> TuringTest: it's an evil liftM :)
17:34:34 <TuringTest> jethr0: liftM rocks
17:34:49 <TuringTest> @type Control.Monad.liftM
17:34:50 <lambdabot> forall r (m :: * -> *) a1.
17:34:50 <lambdabot>         (Monad m) =>
17:34:50 <lambdabot>         (a1 -> r) -> m a1 -> m r
17:34:56 <TuringTest> @type fmap
17:34:57 <lambdabot> forall (f :: * -> *) b a.
17:34:57 <lambdabot>    (Functor f) =>
17:34:57 <lambdabot>    (a -> b) -> f a -> f b
17:35:13 <jethr0> > 4 (.) 5 $ (+)
17:35:14 <lambdabot>   add an instance declaration for (Num (((b1 -> c) -> (a -> b1) -> a -> c)
17:35:14 <lambdabot>                -> t
17:35:14 <lambdabot>                -> (a1 -> a1 -> a1)
17:35:26 <jethr0> > (+) (.) 5 $ 4
17:35:27 <lambdabot>  add an instance declaration for (Show ((a -> b) -> a -> c))
17:35:50 <jethr0> @type (+) (.) 5
17:35:50 <lambdabot> forall b c a.
17:35:50 <lambdabot>      (Num ((b -> c) -> (a -> b) -> a -> c)) =>
17:35:50 <lambdabot>      (b -> c) -> (a -> b) -> a -> c
17:36:05 <TuringTest> dons: Can you fix the advance-by-too-many characters bug?
17:36:22 <TuringTest> (that requires the work-around)
17:36:42 <ihope> TuringTest: I prefer flip (>>=) . (return .)
17:36:56 * TuringTest vomits on ihope
17:36:56 <dons> I tried to, but couldn't work it out. very strange. it's in the original CTK library too.
17:37:09 <TuringTest> dons: I failed when I tried to fix it
17:37:49 <ihope> I want @state to have multiple states at once!
17:38:45 <jethr0> ihope: you mean @quantum-state
17:39:25 * mwc shakes head: http://www.nomorepasting.com/paste.php?pasteID=58181
17:39:38 <ihope> Oops!
17:40:07 <ski> (xerox,int-e : using a variable (or wildcard) instead of constructor in patterns is higher-order patterns, i think (and that is non-deterministic))
17:40:36 <ihope> http://pastebin.ca/42962
17:40:38 <mwc> anybody have any idea why it refuses to see the names of those functions in GridIndex? They're the required implements for Random
17:41:35 <ski> (mwc : i assume Pseudonym just meant a function using an accumulator (probably tail-recursive) by AccumulatorRecursion)
17:42:06 <ihope> I hate XiRCON. Whenever I click a link, it opens up to 6 copies of it...
17:42:22 <dons> ok. so we both failed, TuringTest. Do you think we should submit it with the references to parser combinators (maybe I was in a grumpy mood when I added those).
17:43:07 <TuringTest> dons: I say...submit it
17:43:20 <TuringTest> pre-emtive submission before you are forced to submit it will look good.
17:43:36 <TuringTest> Hopefully we can fix the advance-by-one error
17:44:27 <mwc> ski, thanks, by accumulator you mean someway of recombining the recursive value with one generated in the current call? eg: tail recursive: fib 0 = 1; fib 1 = 1; fib n = (fib $ n - 1) + (fib $ n - 2); but accumulator recursive would be something like: map _ [] = []; map f (x:xs) = f x : map f xs
17:44:53 <dons> ok. fair enough. I'll benchmakr, and ask musasab to commit it.
17:45:05 <mwc> since theoretically, we have to evaluate map f xs before consing it using (:). I know that's not really true because of laziness, but it'd be more work to come up with a real example
17:45:21 <ihope> mwc: fib (n - 1) + fib (n - 2)?
17:45:22 <int-e> mwc: that tail-recursive fib isn't tail-recursive.
17:45:23 <mwc> er, I guess my fib example wouldn't be tail reqw
17:45:25 <mwc> yeah
17:45:33 <jethr0> k, good night
17:45:46 <mwc> that was my accumulator recursive example
17:45:59 <ihope> If it were tail recursive, that would be fib n = fib somethingelse
17:46:08 <mwc> and it's not a good night for me carrying on a conversation without getting confused
17:46:08 <int-e> fib n = fib' n 0 1; fib' 0 a b = a; fib' n a b = fib' (n-1) b (a+b)  <-- this is tail recursive
17:46:18 <ihope> Yep.
17:46:20 <mwc> yeah, I know
17:46:40 <ihope> It took me a while to figure out that my "compose" function could be made tail recursive.
17:46:44 <ihope> compose 0 f p = p
17:46:54 <ihope> compose n f p = f (compose (n-1) f p)
17:47:10 <ihope> Tail recursive: compose n f p = compose (n-1) f (f p)
17:47:11 <mwc> so accumuator recursive is tail recursive with a step at the end that combines the recursive value with something before returning?
17:51:06 <int-e> mwc: http://www.cs.uiuc.edu/class/sp06/cs125/cs125/_notes/_lecture/3-recursion/lecture29.pdf agrees with that. the distinguishing point is that the function gets an additional argument whose sole purpose it is to collect the result.
17:51:37 <monochrom> Yuck, "ghc -cpp" doesn't mix well with string literals of the form:
17:51:41 <int-e> other than that, it's just tail recursion
17:51:43 <monochrom> "something \
17:51:51 <monochrom>    \more"
17:52:27 <mwc> just to clarify the most basic thing possible: class (A b) => B b where ... means that B has all of A's methods
17:52:28 <mwc> int-e, thank you
17:52:31 <ski> compose 0 f = id
17:52:38 <mwc> I've been looking for that definition all afternoon
17:52:42 <ski> compose n f = f . compose (n-1) f
17:52:43 <ski> or
17:52:49 <ski> compose n f = compose (n-1) f . f
17:53:08 <mwc> so why does this fail?! http://www.nomorepasting.com/paste.php?pasteID=58181 with random and randomR not being found in the subclass of Random?
17:53:44 <ihope> ski: but those aren't tail recursive.
17:54:15 <ski> right .. but it clearer shows the change
17:54:35 <mwc> cool use of pointfree anyways
17:54:38 <ski> mwc : to be tail-recursive, the result of the recursive call should be the result of the current call, no extra thing to do after recursive call is allowed
17:54:40 <mwc> thank's int-e 
17:54:45 <mwc> yes, I know ski 
17:55:10 <mwc> despite the fact that I can't give a sentence without contradicting myself tonight
17:55:19 <int-e> mwc: because you're defining a GridIndex instance instead of a Random instance
17:55:34 <mwc> int-e, oh, I need to make a separate instance Random GP2D ?
17:55:42 <int-e> mwc: right.
17:55:52 <mwc> ahhhh
17:55:53 <mwc> thanks
17:55:54 * ski sometimes thinks of a function as using accumulator, even if not all recursive calls are tail-recursive
17:56:02 <mwc> Yeah
17:56:15 <mwc> I tended to that alot before I got into State monad
17:56:26 <mwc> thanks for the blatantly obvious, int-e 
17:56:38 <mwc> I'm gonna go beat myself with the Haskell 98 report now
17:57:23 <ski> monochrom : what if you add a space after the first '\\
17:57:25 <ski> ' ?
17:58:22 <monochrom> Same thing.
17:58:59 <monochrom> "ghc -cpp" calls whichever cpp I have installed as part of my gcc installation, right?
18:00:40 <monochrom> After a while I think it is equally possible that my Ubuntu stock gcc/cpp is the problem. :)
18:01:08 <monochrom> It is: gcc (GCC) 4.0.2 20050808 (prerelease) (Ubuntu 4.0.1-4ubuntu9)
18:01:32 <monochrom> I now think it is a good idea to drop back to 3.x.x :)
18:02:10 <ski> more severe problem than it munging your string gaps ?
18:02:54 <monochrom> Naw, no other misbehaviour detected yet.  But compilation has been slow for the HTTP package.
18:03:07 <ski> mhm
18:04:10 <monochrom> When building HTTP the computer spends forever in gcc.  Maybe it's normal, but the code size and code nature of HTTP isn't unusual.
18:05:10 <monochrom> OTOH I'm probably too lazy to switch.  It's far easier to avoid \ <newline> \  :)
18:05:55 <monochrom> In any case, if the \ <newline> \ with -cpp issue is reproducible on your installation, it's ghc; otherwise it's my version of gcc.
18:06:40 <dons> monochrom, try -fasm -- it's within 1-2% of gcc anyway.
18:07:28 <monochrom> Ha, ok, but do I want to fiddle with the build script of HTTP?
18:08:05 <monochrom> Yes I do.  Just modify one token in http.cabal :)
18:09:17 <mwc> It amazes me that as scatterbrained as I am tonight, I'm still allowed to operate a motor vehicle
18:09:44 * mwc tries to remember what a flashing yellow light and a big white sign with an X on it denote
18:18:46 <TuringTest> dons: I have ... a fix for the bug
18:18:50 <TuringTest> :)
18:23:05 <TuringTest> dons: But it is almost 2:30 AM so I can't properly clean up the code.  I have put the working code on the end of the wiki page
18:23:21 <dons> wow, great :)
18:23:26 <dons> what was the issue?
18:24:25 <dons> @karma+ TuringTest <-- uber-hacker
18:24:25 <lambdabot> TuringTest's karma raised to 5.
18:24:43 <TuringTest> dons: Look at the doaction routine at the end of the wiki page now
18:25:02 <TuringTest> (Of course, I am a physicist, not a hacker)
18:25:35 <TuringTest> The "next" function is the key change
18:25:45 <TuringTest> But it breaks the regex that cleans the input
18:26:13 <TuringTest> So I had to duplicate the run routine to a fixed run' version
18:26:52 <TuringTest> I must cut tonight short -- it is 2:30 AM here shortly -- I must sleep
18:28:08 <TuringTest> The "next" function takes the input position passed to the previous "run'" call and the new state and advances the old position by one character and combines it with the new state
18:28:19 <TuringTest> good night all
18:28:32 <dons> so wass there a bug? 
18:30:51 <dons> ah, good night TuringTest!
19:09:04 <ptolomy> Is there a clean way to do many-to-1 mappings over a type like Char? in OCaml I'd do "match x with 'a'.. 'z' -> 1 | 'A' .. 'Z' -> 2 " or something like that.. should I use 'elem'? or maybe 'foo 'A' = 1 \n foo 'B' = 1' and so on?
19:15:13 <dons> case () of
19:15:13 <dons>     _ | x `elem` ['a'..'z'] -> 1
19:15:15 <dons>       | x `elem` ['A'..'Z'] -> 2
19:15:16 <dons> perhaps?
19:16:00 <dons> if it is a function bind, you can do without the 'case' stuff. i.e.
19:16:02 <dons> f x | x `elem` ['a'..'z'] -> 1
19:16:02 <dons>   x | x `elem` ['A'..'Z'] -> 2
19:16:25 <dons> sorry, no need for  '  x ' on the last line.
19:17:20 <palomer> don't you guys think a cond construct would be so much cleaner than guards?
19:17:39 <ptolomy> Yeah, that probably is the best way. For some reason, using `elem` seemed somehow less clean or efficient to me earlier, but on second examination, it's really just slightly less sugared..
19:18:04 <Cale> dons: and = instead of ->
19:18:23 <Cale> palomer: well, you don't really need one, you can create one :)
19:18:37 <Cale> from lists :)
19:19:15 <palomer> hmm?
19:21:10 <Cale> data Cond a = Bool :-> a
19:21:10 <Cale> cond :: [Cond a] -> a
19:21:10 <Cale> cond [] = error "cond failed to match"
19:21:10 <Cale> cond ((b :-> x) : xs) if b then x else cond xs
19:21:26 <Cale> oops, missed an =
19:21:42 <Cale> cond ((b :-> x) : xs) = if b then x else cond xs
19:21:44 <Cale> of course :)
19:23:43 <Cale> infix 0 :->
19:23:46 <Cale> that also helps
19:24:22 <Cale> *Main> map (\x -> cond [x > 1 :-> 5, x < -1 :-> x^2, otherwise :-> x - 2]) [-10..10]
19:24:22 <Cale> [100,81,64,49,36,25,16,9,4,-3,-2,-1,5,5,5,5,5,5,5,5,5]
19:30:01 <foxy_> are there any people with experience compiling GHC 6.5 about?
19:37:05 <foxy_> error:
19:37:12 <foxy_> parser/Lexer.x:593:10:
19:37:13 <foxy_>     lexical error in string/character literal at character '\8759'
19:37:15 <foxy_> source:
19:37:17 <foxy_>        ,("",	ITlam,          bit glaExtsBit)
19:41:09 <toruhikaru> can someone help me with c++??
19:42:00 <toruhikaru> anyone?? pascal triangle.. :(
19:43:01 <palomer> Cale: that's evil
19:49:14 <Cale> palomer: how?
19:50:16 <Cale> why wouldn't he ask in #c++ ?
19:50:51 <palomer> eh?
19:52:05 <Cale> <toruhikaru> can someone help me with c++??
19:54:42 <monochrom> perhaps #c++ doesn't do other people's homework :)
19:58:27 <araujo> And we do!
19:58:39 * araujo jumps and throws killer lambdas at everyone
20:03:02 <taw> hello
20:03:14 <taw> how do people typically debug haskell programs ?
20:03:23 <Pseudonym> We prove them correct.
20:03:31 <Pseudonym> :-)
20:03:40 <taw> i mean, the best i've found was putting unsafePerformIO ( do { print x; return x }) all over the place
20:03:59 <Pseudonym> Ah.  For that we use Debug.Trace
20:04:30 <Pseudonym> Damn, I missed the C++ questioner,.
20:04:50 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2003-August/004978.html <- My version of Pascal's Triangle in Haskell.
20:05:42 * Pseudonym grins evilly
20:06:26 <Pseudonym> taw: In addition, we tend to do a lot of unit testing.
20:08:01 <taw> nice pascal's triangle ;-)
20:08:40 <Pseudonym> I was once of the school of thought that if someone asked a homework question in an inappropriate forum, I should be helpful.
20:08:52 <Pseudonym> By giving them an answer which is accurate but useless.
20:09:40 <Pseudonym> I particularly like "swing".  Believe it or not, that is factorial.
20:11:54 <taw> poor students, forced to learn stuff like haskell, schere, sml or even prolog ;-)
20:13:47 <Cale> haha
20:14:20 <Cale> Pseudonym: that's got to be the least readable version of that program I've seen :)
20:14:35 <Pseudonym> It's seriously efficient, though.
20:14:59 <Pseudonym> It uses a fast factorial algorithm and memoing.
20:18:28 <lennart_> fast factorial?
20:18:46 <Pseudonym> Well, faster than product [1..n]
20:19:19 <lennart_> but not asymtotically faster?
20:19:21 <taw> Pseudonym: how can one do that ?
20:19:32 <Pseudonym> There are a few ways to do it.
20:19:44 <Pseudonym> Most of them are based on the observation that multiplication is not O(1).
20:20:08 <lennart_> true
20:20:23 <Pseudonym> To use fast multiplication (say, Katsuba or FFT-based algorithms), you ideally want the two numbers that you're multiplying to be roughly the same size.
20:20:45 <Pseudonym> A reasonable heuristic (used in recProd) is to divide and conquer.
20:21:10 <Pseudonym> product [1..n] = product [1..n/2] * product [n/2+1..n]
20:21:50 <Pseudonym> The LHS and RHS are often close to the same order of magnitude for commonly used n.
20:22:18 <lennart_> for commonly used n multiplication is O(1) :)
20:22:24 <Pseudonym> :-)
20:22:34 <lennart_> homewore commonly
20:22:41 <lennart_> homework, even
20:22:57 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/
20:23:01 <Pseudonym> Check out and enjoy.
20:23:20 <Pseudonym> Math.Combinatorial is a fairly fast factorial.
20:23:27 <Pseudonym> But it's based on a different algorithm.
20:23:42 <Pseudonym> It actually computes the prime expansion of n!
20:24:07 <lennart_> so at what size n does it start beating the naive factorial?
20:24:15 <Pseudonym> Not sure.
20:24:24 <Pseudonym> I guessed about 13!
20:24:39 <Pseudonym> Certainly for 100! and higher it seriously beats the naive version.
20:25:20 <Pseudonym> I have an even faster one that I didn't put in this version.
20:25:24 * Pseudonym needs to work it in.
20:26:05 <Pseudonym> If you import GHC.Integer, you can tell whether an Integer fits into a machine word or not.
20:26:10 <lennart_> cool, i'll try and remember it if i ever need factorial :)
20:26:20 <Pseudonym> So you multiply numbers together until you find a number which is bigger than a machine word.
20:26:26 <lennart_> right
20:26:35 <Pseudonym> Then you hang onto that and keep multiplying more numbers until it's bigger than a machine word.
20:26:48 <Pseudonym> You end up with a list of numbers which are large, and all roughly the same size.
20:26:55 <lennart_> yep
20:26:56 <Pseudonym> So you do a divide-and-conquer multiply of them.
20:27:11 <lennart_> i was gonna suggest something along those lines
20:27:25 <Pseudonym> Not only does it work with only machine words if it can (so small factorials are fast), when it does the divide-and-conquer multiply, the numbers are all roughly the same size.
20:27:31 <taw> actually a naive c++ factorial will beat most of the smart algorithms until really huge n ;-)
20:27:41 <lennart_> so, i legitimatly used factorial in a program a while ago.  i just cannot remember what it was.  lol
20:27:57 <Pseudonym> I used this to compute some probability distributions once.
20:28:00 <taw> allocating memory takes way more time than multiplying very big numbers :-)
20:28:05 <Pseudonym> I had to design a Huffman code.
20:28:25 <Pseudonym> True, but this one works for large n.
20:28:37 <lennart_> taw: are you speculating or do you have evidence?
20:29:12 <Pseudonym> The naive C++ version will stop working for large n.
20:29:34 <taw> lennart_: we can try a benchmark if you'd like :-)
20:29:41 <lennart_> obviously we have to have results that don't fit in 64 bits, otherwise multiplication is O(1)
20:31:09 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r } in s 2 100
20:31:10 <lambdabot> 3
20:31:22 <taw> sure, sure
20:31:35 <Pseudonym> Actually, 64! > 2^64
20:31:40 <Pseudonym> So that'd work.
20:32:24 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r } in 100 - s 2 100
20:32:25 <lambdabot> 97
20:32:45 <Pseudonym> 100! = 2^97 * odd number
20:34:31 <lennart_> 100^100*exp(-100)*sqrt(2*pi*100)
20:34:38 <lennart_> > 100^100*exp(-100)*sqrt(2*pi*100)
20:34:39 <lambdabot> 9.324847625269348e157
20:36:08 <lennart_> looks bigger than 2^97 :)
20:36:32 <lennart_> it's a large odd number
20:37:02 <Pseudonym> Yes.
20:37:20 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r } in (100 - s 3 100) `div` 2
20:37:21 <lambdabot> 48
20:37:32 <Pseudonym> 2^97 * 3^48 * ...
20:38:07 <lennart_> > 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 / (2^97 * 3^48)
20:38:08 <lambdabot> 7.383696698122597e105
20:39:22 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r } in (100 - s 5 100) `div` 4
20:39:23 <lambdabot> 24
20:39:26 <Pseudonym> 5^24
20:39:47 <lennart_> taw: if you're gonna do factorial in c++ what bignum package would you use?
20:39:47 <Pseudonym> > 5^24
20:39:48 <lambdabot> 59604644775390625
20:40:09 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r } in (100 - s 7 100) `div` 6
20:40:10 <lambdabot> 16
20:40:15 <taw> lennart_: probably gmp and just multiply in a loop
20:40:46 <Pseudonym> > 7^16
20:40:47 <lambdabot> 33232930569601
20:41:08 <lennart_> taw: I'm not convinced you'd see any difference between haskell and c++
20:42:28 <taw> lennart_: how does one benchmark haskell programs anyway ?
20:42:45 <taw> i mean, executing f () in a loop probably won't do if it's lazy
20:43:08 <Cale> taw: profiling
20:43:08 <taw> wow, Debug.Trace.trace is nice 
20:43:11 <lennart_> write a factorial, run it N times for some large input.  adjust N so the time gets sensible
20:43:31 <Cale> taw: or just overall timing them
20:43:41 <taw> lennart_: yeah but then we get time(factorial) + time(startup), the second is often quite big
20:43:55 <lennart_> that's why you need a large N
20:44:24 <lennart_> if it doesn't take around at least 10s i'd not trust it
20:47:42 <Cale> you can ask ghci for the time taken in evaluation
20:47:52 <Cale> :set +s
20:47:53 <Cale> iirc
20:48:59 <lennart_> ok, computing 1000! 1000 times takes about 3s on my laptop
20:49:17 <palomer> I have like 10 functions written in this very fashion:
20:49:37 <Pseudonym> BRB.  Got to speak to a reporter.
20:50:00 <palomer> http://www.rafb.net/paste/results/zRQl7z37.html 
20:50:15 <palomer> for some reason, there's something iffy about that
20:51:16 <lennart_> huh?
20:51:53 <palomer> who's that huh directed to?
20:51:58 <lennart_> perhaps you need to abstract the pattern then?
20:52:04 <lennart_> it was to you
20:52:23 <palomer> well, I can't, since the functions take arguments in different oders
20:52:31 <palomer> orders
20:52:42 <dons> lennart_, 1000! 1000 times in 3s .. that's lambdabot's time limit. I one if it would scrape in under the timeout?
20:53:14 <dons> s/one/wonder/
20:53:22 <lennart_> actually, 1000! 1000 times was without -O2.  Now I have 1000! 10000 times in 17s
20:53:35 <palomer> runNormalized f = \y -> do {y' <- normalize y ; f y'} would be the best option, really
20:53:56 <mgoetze> lennart_: actually in many cases it's more interested how long you need the first time around, before any caching takes place
20:54:06 <mgoetze> s/interested/interesting/
20:54:22 <lennart_> but much harder to measure
20:54:43 <lennart_> palomer: that's what I said, abstract out the pattern :)
20:57:03 <palomer> hmm, there's still something that bothers me
20:57:15 <palomer> it's one of those things that will bother me for months until I find a suitable fix
20:57:22 <lennart_> also runNormalized f = f =<< normalize
20:58:06 <lennart_> @pl \y -> do {y' <- normalize y ; f y'}
20:58:07 <lambdabot> (line 1, column 10):
20:58:07 <lambdabot> unexpected "{"
20:58:07 <lambdabot> expecting variable, "(", operator or end of input
20:59:03 <lennart_> @pl \ f y -> normalize y >>= \ y' -> f y'
20:59:03 <lambdabot> flip ((>>=) . normalize)
20:59:26 <lennart_> @pl \ f -> f =<< normalize
20:59:26 <lambdabot> (normalize >>=)
20:59:41 <lennart_> hmmmm
21:14:18 <Pseudonym> Back.
21:18:01 <lennart_> naive 1000! takes 1.7ms on my laptop.  i don't think i need faster :)
21:23:05 <araujo> hah
21:23:11 * araujo just searched 'failure' on google
21:28:35 <taw> damn, i've finally found a program that seemed to have an interesting use of monads (Lava) and they switched to unsafePerformIO ;-)
21:28:45 <palomer> 1000 bignum multiplications in 1.7ms? not bad
22:48:07 <ptolomy> Is FPS going to be in the standard GHC library?
22:49:22 <sieni> first person shooter?
22:50:20 <ptolomy> Fast Packed String. :)
22:51:43 <sieni> oh, that one
22:51:44 <sieni> :-)
22:52:04 * ptolomy is now inspired to download and try to run that haskell first person shooter he saw..
23:00:52 <sieni> yeah, just use darwinports for all things haskell... this fucker failed to compile darcs
23:01:23 <sieni> (naturally, because it wants to process a latex file and fails with that)
23:03:45 <sieni> so the dependencies Just Don't Work
23:12:24 <dons> ptolomy, yep. in 6.6
23:13:30 <sieni> hmm... maybe this thingie gets confused because of my fink installation
23:13:57 <sieni> although I can't accept that darcs fails to install because of fubar'd latex installation
23:15:00 <dons> you could just build darcs by hand. it's pretty easy as long (as you have curl installed)
23:16:09 <sieni> well... i'll look at it later... fortunately I have a functional darcs installed from fink
23:18:26 <Maddas> sieni: my Fink installation failed to install ghc :-/
23:18:53 <Maddas> (luckily the .dmg for GHC and Darcs both installed flawlessly)
23:19:03 <sieni> Maddas: at least for 10.3, ghc is ancient in fink
23:19:16 <Maddas> I'm on 10.4, but that's possible indeed.
23:19:36 <sieni> but ghc compiled just fine in darwinports
23:19:41 <Maddas> I had it installed anyway, I just thought it'd be easier to get darcs too that way. Of course dependency hell tried to install it again :-)
23:19:55 <sieni> soon I'll have Yi installed ^_^
23:20:11 <Maddas> Ooh :-)
23:25:52 <xerox> http://ezine.daemonnews.org/200602/apple.html
23:26:25 <tennin> darcs doesn't approve of my squalid network lifestyle
23:28:56 <sieni> damn, this powerbook is _slow_
23:32:50 <dons> @remember tennin darcs doesn't approve of my squalid network lifestyle
23:35:40 <sieni> hmm... first-person-shooter is missing
23:35:55 <ncalexan> @where frag
23:35:55 <lambdabot> http://www.cse.unsw.edu.au/~pls/repos/frag
23:36:55 <sieni> (well actually fast packed strings)
23:39:19 <sieni> hmm... which darwinports package provides fps
23:39:51 <sieni> maybe I just install it via darcs
23:47:35 <sieni> hmm... dist/build/./yi-tmp/cbits/YiUtils.o: No such file or directory
23:47:50 <sieni> or should I say: wtf?
23:47:55 <ProfTeggy> Hi
23:49:34 <sieni> dons: awake?
23:50:08 <dons> a little bit. looks like a Cabal issue.
23:50:18 <sieni> dons: for some reason YiUtils.o ended up in dist/build/yi-tmp/cbits/cbits instead of dist/build/yi-tmp/cbits
23:50:26 <dons> perhaps ln -s the .o files into the right place then?
23:50:51 <sieni> dons: actually I was planning to try that next
23:51:50 <dons> it's just cabal being silly.
23:52:10 <sieni> hmmmmmm.... ld: archive: /usr/local/lib/fps-0.1/libHSfps-0.1.a has no table of contents, add one with ranlib(1) (can't load from it)
23:52:30 <dons> yeah. that's a mac-ism. do as it says :)
23:53:31 <xerox> Is Yi usable these days?
23:54:08 <sieni> cool, it works
23:54:20 <sieni> next: lambadabot
23:54:30 <xerox> sieni: did you compile Gtk under osx?
23:54:48 <sieni> xerox: well under fink, yes
23:59:22 <tibbe> is someone willing to critique half-a-page of code? i would appreciate it
