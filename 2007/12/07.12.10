00:01:41 <nolrai> at glguy but is the list is infinite then it works.
00:02:14 <glguy> nolrai: right, I'm only referring to the code you tried using fix
00:02:27 <glguy> and: 0 : map ...
00:02:34 <glguy> err
00:02:36 <glguy> 0 : sums
00:08:39 <nolrai> right it has to be 1 : 1 : sums.
00:09:58 <dmwit> miclorb: First off, you need GHC 6.6 (I think 6.8 is not okay).
00:10:22 <dmwit> miclorb: Have you tried "runhaskell Setup.hs configure"?
00:10:29 <dmwit> miclorb: It should report missing dependencies to you.
00:10:33 <miclorb> dmwit: I have 6.8.1 - so I need older ?
00:10:38 <dmwit> miclorb: yes =/
00:10:51 <dmwit> ?version
00:10:51 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
00:10:51 <lambdabot> darcs get http://code.haskell.org/lambdabot
00:10:55 <miclorb> dmwit: yeah its saying I need arrows, zlib etc etc - I gather they are all haskell deps I need to get?
00:11:07 <dmwit> They are.  You can find them on hackage.
00:11:10 <dmwit> ?where hackage
00:11:11 <lambdabot> http://hackage.haskell.org/
00:11:15 <miclorb> (I gt ghc from yum in fedora)
00:11:28 <dmwit> You may be able to get some of the dependencies from yum, too.
00:11:28 <miclorb> ok - is there a command line tool to grab a version of them?
00:11:45 <dmwit> If you have a new enough version of cabal, I guess cabal-install works.
00:11:48 <miclorb> yeah, yum has some, but not everything, wasn't sure if there is a haskell dependency "thing"
00:11:53 <miclorb> ok
00:11:57 <miclorb> may be worth a try
00:12:06 <dmwit> I've never used it though, so you're on your own there. =)
00:12:06 <miclorb> bummer its not 6.8
00:12:31 <dmwit> miclorb: I'm sure patches to get it compiling under 6.8 would be accepted. ;-)
00:12:35 <dmwit> heh
00:12:38 <miclorb> heh yeh
00:12:48 <miclorb> yeah just fumbling around, learning what the tools are
00:13:15 <dmwit> Yeah, it's hard to get a start if you don't know what names to Google for.
00:13:34 <dmwit> darcs, cabal, and hackage are the three big things to know for building Haskell projects, I think.
00:13:45 <miclorb> yes, cabal is new
00:14:25 * glguy wonders if the process of moving ghc off darcs as progressed
00:14:46 <dmwit> glguy: What are they moving to?
00:14:47 <scook0> what are/were they moving to?
00:14:59 <glguy> Don't know if anything was decided
00:15:03 <glguy> it just came up on the mailing list
00:15:16 <glguy> simon marlow sent out a question about it a week or two ago
00:16:12 <dmwit> why?
00:16:27 <dmwit> (pointing me to a thread is a perfect valid answer for me)
00:16:34 <glguy> yeah, still looking for it
00:16:44 <dmwit> That's fine, I can look for it myself. ;-)
00:16:53 <glguy> first one to find it shares ;)
00:17:05 <dmwit> =)
00:17:11 <glguy> the ghc repo is too big for darcs was the one I remembered
00:17:22 <glguy> darcs annotate  inspires coffee breaks
00:17:28 <dmwit> hahaha
00:19:05 <sjanssen> glguy: the conclusion was to wait a while
00:19:15 <sjanssen> since droundy is actively working on the conflict bug
00:19:23 <glguy> don't happen to have a link to the discussion, do you?
00:19:39 <dmwit> Ha, got it!
00:19:46 <dmwit> This isn't the root, but:
00:19:47 <glguy> sjanssen: will that resolve the repository breaking merges and exponential slow-downs in common operations?
00:19:51 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/25000/match=darcs+ghc
00:19:52 <mattam> sjanssen: good news :)
00:19:52 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/ysg8ow
00:20:28 <sjanssen> glguy: it will solve the merge and exponential slow-downs
00:20:38 <sjanssen> glguy: it won't help 'darcs annotate', AFAIK
00:20:44 <Plareplane> try this: http://www.haskell.org/pipermail/cvs-ghc/2007-November/039824.html
00:20:45 <lambdabot> Title: Darcs, http://tinyurl.com/2lbnwk
00:20:57 <glguy> Plareplane: that was it exactly, thanks
00:21:12 <Plareplane> i've never really understood how gmane's interface worked
00:22:18 <sjanssen> I hope GHC can stick with darcs -- dogfooding is important, and we need applications in Haskell
00:24:02 * quicksilver suggests someone rewrite bzr in haskell
00:24:04 * quicksilver ducks
00:24:25 <Zao> quicksilver: I sense a volunteer!
00:29:20 <qweqwe> can you help me with the type
00:29:21 <qweqwe> delete ::Ord key =>  key -> RedBlackTree value key -> (Maybe value key)
00:29:46 <glguy> Maybe (value,key) ?
00:30:37 <qweqwe> it returns so maybe element of value key pair
00:33:27 <scook0> qweqwe: I'm not sure what your question is ...
00:34:28 <quicksilver> qweqwe: I think glguy has it
00:34:41 <quicksilver> qweqwe: maybe only takes "one" parameter, but you can pair them up
00:36:01 <qweqwe> yes yes it worked thanks
00:37:54 <qweqwe> can you also check this error plz http://pastebin.com/m64372734
00:38:34 <dmwit> Maybe (value, key), not Maybe (value key)
00:39:43 <dmwit> Also, check that you've copied exactly what you have in your file; that error sounds like you just made a spelling error or something. ;-)
00:40:12 <scook0> (incidentally, indexed data structures in Haskell usually specify the key first and the value second)
00:40:27 <scook0> (but that probably isn't relevant at this point)
00:47:26 <qweqwe> still ihave some error with my maybe type
00:47:27 <qweqwe> http://pastebin.com/m21834d34
00:47:47 <Sizur> does anybody here have any positive experience with Yampa?
00:48:14 <bos> @seen dons
00:48:14 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 50m 58s ago.
00:48:37 <sieni> 50 metres 58 seconds ago?
00:48:49 <sieni> whoa :-)
00:49:16 <basti_> Sizur: a "Maybe" value can only be constructed by using one of the constructors "None" or "Just x"
00:49:20 <dmwit> ?go speed of light in meters per second
00:49:25 <lambdabot> the speed of light = 299,792,458 meters per second
00:49:28 <roconnor> @go 50 light-meters in minutes
00:49:29 <lambdabot> http://www.photoethnography.com/ClassicCameras/lightmeters-classic.html
00:49:29 <lambdabot> Title: Light meters
00:49:31 <Sizur> sieni: context exception
00:49:45 <dmwit> > 50 / 299792458 + 58 -- the 58s dominates hard
00:49:47 <basti_> oops i'm sorry..
00:49:48 <lambdabot>  58.000000166782044
00:49:49 <sjanssen> qweqwe: you need to write 'Just (k, v)'
00:49:57 <basti_> qweqwe: a "Maybe" value can only be constructed by using one of the constructors "None" or "Just x"
00:49:57 <sjanssen> or (v, k)
00:50:15 <Sizur> basti_: Nothing you mean?
00:50:22 <basti_> yup
00:50:29 <basti_> None is coq :|
00:50:29 <qweqwe> perfect
00:51:32 <Sizur> @go 50 meters in light-years
00:51:32 <lambdabot> 50 meters = 5.28511705 x 10^-15 light-years
00:52:14 <sieni> @go 1 cubic lightyear in litres
00:52:14 <lambdabot> 1 (cubic lightyear) = 8.46732407 x 10^50 litres
00:52:23 <Sizur> rofl
00:52:33 <sieni> that's a practical unit
00:53:34 <basti_> which is? cubic light year or litre? ;)
00:54:03 <dmwit> ?go 50 meters in seconds
00:54:03 <lambdabot> http://usctrojans.cstv.com/sports/w-swim/spec-rel/071606aaa.html
00:54:04 <lambdabot> Title: Lezak Wins Rematch of 50-Meter Freestyle Olympians :: Coughlin posts top America ...
00:54:08 <dmwit> bummer =P
00:54:13 <mikael> @go 1 cubic litre in meta-hyper-lightyears
00:54:14 <lambdabot> No Result Found.
00:55:09 <sieni> for practical measurement of the fuel usage of american cars:
00:55:15 <sieni> @go 1 yoctometer / (cubic parsec) in miles / gallon
00:55:16 <lambdabot> (1 yoctometer) / (cubic Parsec) = 8.0059244 x 10^-80 miles / US gallon
00:55:33 <scook0> @hoogle guard
00:55:35 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
00:55:35 <lambdabot> Language.Haskell.TH.Guard :: data Guard
00:55:35 <lambdabot> Language.Haskell.TH.Syntax.Guard :: data Guard
00:55:59 <dmwit> sieni: That's a tiny, tiny amount of gas per gallon; are you sure that was the effect you were going for? =P
00:56:07 <dmwit> ...oh
00:56:11 <dmwit> miles/gallon
00:56:14 <dmwit> O_o
00:56:25 <sieni> @go 1 yoctometer / (cubic yottaparsec) in miles / gallon
00:56:26 <lambdabot> (1 yoctometer) / (cubic yottaParsec) = 8.0059244 x 10^-152 miles / US gallon
00:57:13 <Sizur> that's irrelevant since at these levels quantum foam will fuel your car
00:57:26 <dmwit> ?go 10^-848 yoctometer / (cubic yottaparsec) in miles / gallon
00:57:26 <lambdabot> No Result Found.
00:57:49 <dmwit> Shucks, I wanted to see if it could handle 10^-1000. ;-)
00:59:34 <sieni> dmwit: nope :-)
00:59:45 <sieni> @go 10^(-223) yoctometers / (cubic yottaparsec) in miles / gallon
00:59:46 <lambdabot> ((10^(-223)) * yoctometers) / (cubic yottaParsec) = 0 miles / US gallon
01:01:08 <dmwit> That's not many miles per gallon.
01:01:19 <Sizur> what's up with that! google cannot handle basic arithmetics!
01:01:43 <Lycurgus> not at that precision
01:01:52 <Lycurgus> sheesh it's just google after all
01:03:11 <dmwit> Well, I guess I better go to bed.
01:03:13 <Sizur> but any time anybody wants to get a very useful conversion from yoctometers per yottaparsec, google will fail! scary to think how many ppl will be left in the rain alone...
01:03:16 <dmwit> I have a final in 7 hours. =P
01:03:20 <Sizur> dmwit: g'night
01:04:07 <balodja> Would you kill the librarian in case he can't handle with 10^-200? :)
01:05:10 <mauke> > 10e-200
01:05:13 <lambdabot>  1.0e-199
01:06:02 <Sizur> balodja: if it's a she, then no
01:06:33 <Sizur> otherwise slaughter
01:16:36 <qweqwe> http://pastebin.com/m5db031c6 how i can deal with Illegal `_' in expression
01:17:05 <mikael> keke `_'
01:17:31 <mauke> qweqwe: what is the _ supposed to do there?
01:17:41 <mikael> you know _ in a pattern means "I won't use this part, throw it away"
01:18:15 <qweqwe> _ can be R or B
01:18:23 <opqdonut> just change both _s into a variable
01:18:24 <qweqwe> so now i have to write two cases ?
01:18:33 <mauke> qweqwe: no, just use a variable
01:18:35 <opqdonut> no no
01:18:39 <opqdonut> you can match a variable
01:18:50 <opqdonut> just like a v k b there
01:24:03 <glguy> Node c *(* delete (key a ....
01:24:18 <glguy> you need to surround the call to delete with parentheses probably
01:24:41 <glguy> otherwise "delete' is just an argument passed to Node
01:25:16 <qweqwe> still it has some error there
01:26:31 <qweqwe> http://pastebin.com/medd74a
01:26:55 <glguy> delete takes two arguments
01:27:26 <qweqwe> and i gave it twwo
01:27:34 <glguy> no, you gave it one
01:27:38 <glguy> (delete (key a))
01:28:31 <qweqwe> yes you right
01:29:11 <Taejo> when you "emerge ghc" in gentoo, does it download a binary and source and then use the binary to compile the source?
01:29:27 <Zao> Most probably.
01:29:35 <Zao> The FreeBSD ports does it that way at least.
01:30:07 <sjanssen> Taejo: yes
01:30:09 <Taejo> ok... I'm an Ubuntu man myself... don't have much experience with emerge
01:30:14 <sjanssen> even if you've already got GHC installed
01:30:27 <sjanssen> you can USE=binary to skip the compilation step
01:30:38 <qweqwe> what it want from me now ? http://pastebin.com/m7b4fa84c
01:31:16 <mauke> qweqwe: Node c (delete key a) v k b is not a Maybe x
01:31:23 <glguy> qweqwe: delete returns a Maybe (something) and you are trying to put that into your Node
01:31:33 <mauke> oh
01:31:34 <mauke> that too
01:31:53 <glguy> do thing <- delete key a
01:31:59 <glguy> return (Node c thing ...
01:32:17 <mauke> fmap!
01:32:33 <glguy> yeah... because that would lend itself to clarity ;)
01:32:53 <mauke> wait, wouldn't work anyway
01:33:00 <qweqwe> so i have make there a new function that will do the recoursion
01:33:03 <mauke> delete doesn't make sense
01:33:41 <mauke> it's sort of between lookup and delete with no part working
01:33:55 <glguy> qweqwe: the type of the two branches "key < k" and "otherwise" must match
01:34:10 <glguy> Right now you have a Maybe (value,key) and a Node
01:35:21 <mauke> how about delete :: (Ord key) => key -> RedBlackTree key value -> (Maybe value, RedBlackTree key value)
01:35:59 <faxathisia> hi
01:36:43 <qweqwe> no my main fuction has to return maybe pair of value key
01:36:52 <qweqwe> ok i will do it another way
01:37:20 <mauke> qweqwe: er, so?
01:37:30 <mauke> delete still has to return the modified tree to be useful
01:37:47 <Sizur> Yampa anybody?
01:38:16 <faxathisia> @pl \x y -> map (!!x) y
01:38:17 <lambdabot> map . flip (!!)
01:38:37 <faxathisia> @pl \x y -> sum (zipWith (*) x y)
01:38:38 <lambdabot> (sum .) . zipWith (*)
01:39:55 <Sizur> ok, another question. example of a state machine?
01:40:58 <faxathisia> @pl \x y -> map (!!y) x
01:40:58 <lambdabot> flip (map . flip (!!))
01:43:03 <faxathisia> @pl \a b = map (\row_ -> map (\col_ -> sum $ zipWith (*) (a!!row_) (map(!!col_)b)) [0..length (b!!0)-1]) [0..length a-1]
01:43:04 <lambdabot> (line 1, column 6):
01:43:04 <lambdabot> unexpected "="
01:43:04 <lambdabot> expecting pattern or "->"
01:43:07 <faxathisia> @pl \a b -> map (\row_ -> map (\col_ -> sum $ zipWith (*) (a!!row_) (map(!!col_)b)) [0..length (b!!0)-1]) [0..length a-1]
01:43:09 <lambdabot> ap (flip . (map .) . (`ap` (enumFromTo 0 . subtract 1 . length . (!! 0))) . ((flip . ((map . (sum .)) .)) .) . (. flip (map . flip (!!))) . flip . (((.) . zipWith (*)) .) . (!!)) (enumFromTo 0 .
01:43:09 <lambdabot> subtract 1 . length)
01:43:44 <faxathisia> @src ap
01:43:44 <lambdabot> ap = liftM2 id
01:46:41 <nolrai> @pl s x y z = (x z) (y z)
01:46:41 <lambdabot> s = ap
01:48:37 <nolrai> @ty ap
01:48:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:49:27 <faxathisia> @src transpose
01:49:27 <lambdabot> transpose []             = []
01:49:27 <lambdabot> transpose ([]   : xss)   = transpose xss
01:49:27 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
01:53:56 <qweqwe> http://pastebin.com/m3dfd0fed
01:54:02 <qweqwe> what is wrong there now ?
01:54:19 <glguy> @paste
01:54:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:54:29 <glguy> better highlighting and no ads
01:54:33 <qweqwe> i now
01:54:40 <qweqwe> forget about it
01:54:50 <qweqwe> know
01:56:07 <qweqwe> yes it really better paste site
01:56:22 <mauke> qweqwe: key < v
01:56:32 <glguy> you are crossing your key and value types someone
01:56:33 <mauke> don't you mean key < k?
01:56:37 <glguy> causing them to be the same
01:56:46 <glguy> ah, what mauke is pointing out
01:56:59 <Sizur> guys, anybody? an example of a state machine implementation with maybe like 3 states or so? where you can define clear state transition predicates
01:57:49 <glguy> Sizur: would look like a recursive function
01:58:00 <glguy> where the "state" is passed around as a parameter
01:58:27 <wli> You can have 3 mutually recursive functions.
01:58:35 <Sizur> aha, corecursive function
01:58:40 <Sizur> functions*
01:58:58 <Sizur> thanks let me try that out right now
01:59:13 <Sizur> i was thinking of some monadic implementation
02:00:12 <mwc> Sizur, you could also accomplish in the State monad
02:00:27 <mwc> but State is just a vehicle for threading a state parameter
02:00:45 <faxathisia> @pl \a b -> map (\row -> (map (\col -> sum $ zipWith (*) row col) (transpose b))) a
02:00:45 <lambdabot> flip (map . flip (map . (sum .) . zipWith (*)) . transpose)
02:01:23 <faxathisia> can anyone
02:01:24 <faxathisia> matrixMultiply a b = map (\row -> (map (\col -> sum $ zipWith (*) row col) (transpose b))) a
02:01:30 <faxathisia> give me any advice on this?
02:01:39 <faxathisia> because it's really bad .. basically
02:01:40 <mux> I can show you what I use for that
02:01:52 <faxathisia> That would be kind
02:02:01 <glguy> * ?
02:02:45 <Lycurgus> isn't there a SCALAPACK or LAPACK haskell/ghc binding?
02:03:13 <mux> mul :: Integral a => [[a]] -> [[a]] -> [[a]]
02:03:13 <mux> mul xs ys = mul' xs (transpose ys)
02:03:13 <mux>   where mul' xxs ys = foldr (\xs -> (mul1 xs ys :)) [] xxs
02:03:13 <mux>         mul1 xs     = foldr (\ys -> (sum (zipWith (*) xs ys) :)) []
02:03:16 <mux> faxathisia: here
02:03:22 <faxathisia> cool
02:03:24 <mux> don't know if that's very good or whatever
02:04:05 <faxathisia> no I like the method
02:04:18 <jedbrown> Lycurgus: hmatrix (hackage) interfaces to a subset of Lapack and GSL.
02:05:14 <faxathisia> Now I have 4 version
02:06:34 <Lycurgus> jedBrown: Acknowledged. Looks very nice.
02:07:33 <Lycurgus> but http://www.cs.utah.edu/~hal/HBlas/index.html is what I was thinking of.
02:07:34 <lambdabot> Title: HBlas - Linear Algebra for Haskell
02:08:21 <faxathisia> Documentation is 403 Forbidden lol
02:08:23 <mux> faxathisia: which one is nicest? :)
02:08:53 <hpaste>  faxathisia pasted "matrix mult" at http://hpaste.org/4361
02:09:03 <faxathisia> It's tough
02:09:27 <mux> mmult I quite like
02:09:33 <opqdonut> ssfffffffffffffff
02:09:36 <opqdonut> woops
02:11:28 <jedbrown> faxathisia: an interesting discussion: "An approach to fast arrays in Haskell" http://www.cse.unsw.edu.au/~chak/papers/CK03.html
02:11:29 <lambdabot> Title: Research Papers of Manuel Chakravarty
02:11:32 <mux> cat walking on keyboard?
02:12:43 <quicksilver> faxathisia: I'm a bit slow this morning, but I think that mux's version is just the same as your original one, unrolled.
02:12:58 <opqdonut> mux: nah, tapping keyboard to music
02:13:13 <mux> :-)
02:13:22 <opqdonut> (scenemusic.eu stream)
02:14:18 <Taejo> what GHC flags should we use for the South African Computer Olympiad? We're currently using -Wall -O2 (like for GCC) and --make
02:14:33 <fasta> Can I get a vector version of the Haskell logo anywhere?
02:16:34 <jedbrown> Lycurgus: From what I can tell, that lib is just a direct translation of the C interface.  Good to know about, but hmatrix is actively developed and offers a much nicer interface.
02:18:12 <opqdonut> Taejo: glasgow exts?
02:18:44 <opqdonut> (might not be desired, tho)
02:20:08 <Lycurgus> jedBrown: oh yeah, that's why I said hmatrix looked very nice. It's functionally rich; the other is just a basis for rolling your own haskell to LAPACK interfaces.
02:21:18 <Lycurgus> Fortran or C would be the common interligua base to Scalapack/Lapack though so the other isn't without value
02:23:42 <jedbrown> Lycurgus: Certainly.  When I get the MPI library I'm working on up to speed and we get bindings to FFTW, Haskell will be ready for full-fledged HPC.
02:26:38 * Lycurgus goes to check if GPH supports both PVM and MPI or what
02:26:43 <fasta> Is interfacing to C libraries as automated as possible?
02:27:04 <Lycurgus> as I thought
02:27:34 <quicksilver> fasta: no. it is not particularly automated at all.
02:27:45 <fasta> quicksilver: that's what I thought.
02:27:53 <jedbrown> Lycurgus: GPH (and GDH) are just PVM, although some recent research papers use GRID-GUM which is based on MPI.
02:28:00 <fasta> Chicken has automated it quite far, IIRC.
02:28:09 <quicksilver> chicken?
02:28:17 <jedbrown> Lycurgus: However, I don't think that emulating shared memory is necessarily a good idea.
02:28:17 <fasta> quicksilver: A Scheme implementation
02:28:21 <quicksilver> ah.
02:28:51 <hpaste>  mmorrow pasted "More Instances: String (to/from)/(from/to) {Lazy,Strict}ByteStrings" at http://hpaste.org/4362
02:28:55 <Lycurgus> there must be some significant reason for no apparent activity on GPH in nearly 3 years
02:29:37 <fasta> Lycurgus: Look for references to GPH articles.
02:29:51 <hpaste>  mmorrow annotated "Adjoint funct(ors/ions) and some instances." with "oops, meant to put this here" at http://hpaste.org/4345#a4
02:30:48 <hpaste>  mmorrow annotated "More Instances: String (to/from)/(from/to) {Lazy,Strict}ByteStrings" with "oops" at http://hpaste.org/4362#a1
02:31:00 <qweqwe> i have minTree Node c a v k b how i can check if the a argument is a Leaf a==Leaf don"t work
02:31:20 <opqdonut> pattern match
02:31:32 <quicksilver> mmorrow: I may be mistaken, but those aren't really interesting adjunctions, aren't they?
02:31:35 <opqdonut> case a of Leaf x -> foo ...
02:31:37 <quicksilver> mmorrow: they're isomorphisms...
02:31:41 <qweqwe> you mean like minTree Node c Leaf v k b
02:32:42 <opqdonut> yeah you could do that too
02:32:44 <Lycurgus> well googling "GPH haskell" in the last year certainly didn't tell me anything
02:33:20 <opqdonut> except you need parenthesis, something like: minTree (Node x) c (Leaf v) k b
02:33:35 <opqdonut> here x and v capture the contents of the constructors
02:33:36 <Lycurgus> .oO(I wonder if they are supposed to have a semantic search beta/prototype someplace)
02:34:24 <hpaste>  mmorrow annotated "Adjoint funct(ors/ions) and some instances." with "duals of some existing instances for completeness" at http://hpaste.org/4345#a5
02:34:28 <jedbrown> Lycurgus: presumably fasta meant http://scholar.google.com/scholar?hl=en&lr=&safe=active&scoring=r&q=GPH+haskell&as_ylo=2006
02:34:28 <lambdabot> Title: GPH haskell - Google Scholar, http://tinyurl.com/2b7jt9
02:36:38 <Lycurgus> yes EDI is teh neu
02:37:43 <mmorrow> quicksilver: the nice thing is that you can compose them like functions
02:37:58 <quicksilver> mmorrow: right, but you could make a class called 'Isomorphism' for that
02:38:07 <quicksilver> mmorrow: all I'm saying is that , as adjunctions, those are trivial :)
02:38:23 <mmorrow> but (to . from) gives a nice interface
02:38:24 <quicksilver> mmorrow: as isomorphism, they are certainly useful.
02:38:40 <quicksilver> mmorrow: I also don't understand your point about being unable to give a default for unit and counit?
02:39:10 <mmorrow> i'm not sure if i do either
02:39:12 <quicksilver> mmorrow: what's wrong with unit = from.to?
02:39:15 <quicksilver> or unit = adj id?
02:39:24 <mmorrow> the type checker doesn't let me do it
02:39:32 <quicksilver> show me the error...
02:39:36 <fasta> Lycurgus: I meant that you find some website that has a graph of articles and you find the in-edges of GPH.
02:39:45 <mmorrow> it'll take a min
02:39:49 <quicksilver> :)
02:39:51 <fasta> Lycurgus: citeseer has that feature, IIRC.
02:40:23 <nolrai> @hoogle ap
02:40:23 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
02:40:23 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
02:40:23 <lambdabot> System.IO.appendFile :: FilePath -> String -> IO ()
02:40:36 <Baughn> Say, is there a version of ghc 6.8.1 for freebsd/x86?
02:43:04 <nolrai> :type (ap (const (s id)) (ap (const const) i))
02:43:19 <nolrai> @ty (ap (const (s id)) (ap (const const) i))
02:43:20 <lambdabot> Not in scope: `s'
02:43:20 <lambdabot> Not in scope: `i'
02:43:33 <nolrai> @ty (ap (const (ap id)) (ap (const const) id))
02:43:34 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
02:44:19 <nolrai> so yeah compileing SKI to haskell whould be realy easy.
02:44:37 <qweqwe> if i have a tupple (value,key) how i can take from it the first argument and  the secound ?
02:44:47 <quicksilver> qweqwe: normally with a let binding
02:44:59 <quicksilver> let (v,k) = tup in .... use k and v in here ....
02:45:12 <quicksilver> although you can also use 'snd' and 'fst' but I don't recommend that for readability.
02:45:35 <qweqwe> what you mean by snd ?
02:45:42 <qweqwe> how i use it ?
02:45:44 <quicksilver> snd is a function, so's first
02:45:50 <quicksilver> but like I say, I don't recommend it
02:45:56 <quicksilver> I recommend using a let or case to bind.
02:45:58 <Taejo> :t (***)
02:45:59 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:46:05 <nolrai> > snd (1,2)
02:46:06 <lambdabot>  2
02:46:23 <Lycurgus> fasta: thx will give it greater scrutiny next time I'm at library
02:46:33 <qweqwe> fst(1,2,3,4)
02:46:43 <qweqwe> > fst(1,2,3,4)
02:46:44 <lambdabot>  Couldn't match expected type `(a, b)'
02:46:44 <quicksilver> fasta: is there a (free) website which draws graphs of papers connected by citation like that?
02:46:49 <quicksilver> fasta: that might be interesting...
02:47:10 <quicksilver> qweqwe: there are only predefined functions for 2-tuples.
02:47:16 <quicksilver> qweqwe: another reason to use let/case :)
02:47:23 <fasta> quicksilver: I don't think it draws it, but you can get the information you want, IIRC.
02:47:38 <fasta> quicksilver: it simply gives a list of everyone who cites article Foo.
02:47:55 <fasta> quicksilver: which is what most end-users would want.
02:48:11 <qweqwe> can you give me example for let case how to use it
02:48:14 <fasta> quicksilver: what's the point of a graph with 100's of edges filling your screen?
02:48:31 <fasta> quicksilver: or is that 100s?
02:49:02 <fasta> Right, 100s.
02:49:22 <Taejo> should I enable -fglasgow-exts for the SACO?
02:49:23 <hpaste>  mmorrow annotated "Adjoint funct(ors/ions) and some instances." with "errors if try to define defaults for unit/counit" at http://hpaste.org/4345#a6
02:49:38 <fasta> Taejo: what is this SACO you speak of?
02:49:50 <Taejo> sorry, South African Computer Olympiad
02:50:16 <fasta> Taejo: you should read the rules of the competition
02:50:28 <Taejo> fasta: what do you mean?
02:50:52 <mmorrow> quicksilver: the same errors occur if i try to use unit = from . id . to in the instances also
02:52:40 <quicksilver> qweqwe: I did.
02:52:48 <quicksilver> qweqwe: let (k,v) = tuple in blah blah
02:53:06 <quicksilver> > let (k,v) = (1,2) in "k is " ++ show k ++ " and v is " ++ show v
02:53:06 <lambdabot>  "k is 1 and v is 2"
02:53:43 <qweqwe> ah got you now
02:53:47 <qweqwe> thanks
02:53:57 <qweqwe> it really simple
02:54:06 <quicksilver> mmorrow: ah, it just needs a type annotation to know which from + to to use
02:54:10 <mmorrow> quicksilver: also, those instances are trivial in the sense that they are isomorphism (structurally/whatever), but not necessarily in terms of complexity of functions on the 'isomorphic' pairs
02:54:37 <quicksilver> mmorrow: well, they're trivial in the sense that unit and counit are both 'id'
02:54:44 <quicksilver> mmorrow: that's what trivial means, for adjunctions, isn't it?
02:55:57 <mmorrow> the id in there is supposed to emphasize the fact that the unit is isomorphic to id
02:56:11 <mmorrow> assuming from . to is an isomorphism
02:56:59 <mmorrow> how do you suggest adding the type annotation?
02:57:11 <mmorrow> i tried every way i could think of
02:57:48 <quicksilver> one sec, I'll try
02:58:58 <qweqwe> can you look on th error http://hpaste.org/4363
03:00:27 <hpaste>  quicksilver annotated "Adjoint funct(ors/ions) and some instances." with "defaults for unit/counit" at http://hpaste.org/4345#a7
03:00:33 <Taejo> fasta: I'm *writing* the rules of the competition, but seek advice on the (new) Haskell section
03:00:37 <quicksilver> mmorrow: there you go.
03:00:55 <quicksilver> mmorrow: basically without the annotation, it doesn't know which "to" you mean
03:01:00 <fasta> Taejo: oh, how interesting.
03:01:09 <quicksilver> mmorrow: for all it knows, you mean to :: a -> c for some other c != b
03:01:47 <fasta> Taejo: I would say that the contestants can use every option to ghc that they wish for.
03:02:06 <fasta> Taejo: Haskell 98 is rather limiting.
03:02:29 <Taejo> fasta: we compile and run programs on the server, so we need to decide on a good set of options
03:02:44 <mmorrow> quicksilver: sweet!
03:03:00 <fasta> Taejo: it depends on whether you can punish "evil" participants.
03:03:24 <fasta> Taejo: or you should put a bound on compilation time.
03:03:43 <SamB_XP_> what options don't work in OPTIONS_GHC pragmas that would be important?
03:04:00 <Taejo> fasta: we can... our restricted environment has been working for several years... we have time and RAM limits at execution time, and higher compilation time limits
03:04:03 <fasta> SamB_XP_: none, I can.
03:04:10 <fasta> SamB_XP_: er I think
03:04:28 <sjanssen> -package and -threaded come to mind
03:04:30 <Taejo> I didn't know about OPTIONS_GHC
03:04:39 <sjanssen> neither very important in this case, I think
03:04:48 <fasta> sjanssen: with --make that's not required, right?
03:04:53 <sjanssen> fasta: right
03:05:10 <sjanssen> and -threaded won't be very helpful in this sort of thing
03:05:29 <Taejo> yeah, I can't imagine concurrency would be anything but a hindrance
03:05:37 <qweqwe> can you look on th error http://hpaste.org/4363
03:05:47 <fasta> Taejo: just start ghc as ghc --make Main.hs and it should be ok.
03:06:00 <Taejo> (well, assuming my colleagues have disallowed use of multiple cores on the marker)
03:06:10 <quicksilver> qweqwe: you don't need a let inside a where
03:06:17 <Taejo> fasta: not even -O2?
03:06:20 <quicksilver> qweqwe: where is an alternative binding form
03:06:28 <Taejo> we use -Wall -O2 on gcc
03:06:29 <qweqwe> ahh
03:06:36 <qweqwe> ok thanks
03:06:42 <SamB_XP_> Taejo: the users can put that in their OPTIONS_GHC pragmas
03:06:48 <quicksilver> qweqwe: just where \n (x,y) = minTree b \n z = delete b y
03:07:12 <ski> mmorrow : what are the intended functors in the adjunctions ?
03:07:18 <fasta> Taejo: if you don't put -02 there it would be nice if you would tell that to the contestants, though.
03:07:29 <SamB_XP_> true
03:07:49 <qweqwe> i got there now Syntax error in input (unexpected `=')
03:08:09 <qweqwe> on the same line
03:08:26 <mmorrow> ski : i'm not sure if i understand your question, but 'to' if the left adjoint and 'from' is right
03:08:32 <mmorrow> if -> is
03:08:48 <Taejo> fasta: I think I'll keep -O2 for uniformity with the other compilers
03:09:25 <fasta> qweqwe: it's let foo in bar
03:09:45 <qweqwe> no
03:09:47 <qweqwe> http://hpaste.org/4364
03:10:10 <fasta> qweqwe: delete one space before z
03:10:49 <qweqwe> thanks
03:11:59 <qweqwe> one more strange error for me
03:12:12 <qweqwe> Constructor "Node" must have exactly 5 arguments in pattern
03:12:40 <qweqwe> isn"t it 5 arguments there
03:12:40 <ski> mmorrow : one formulation of an adjunction situation is that given categories `C',`D', and functors `F : C -> D',`G : D -> C', then `F',`G' form an adjunction situation iff there is an isomorphism bwtween `Hom_D (F A,B)' and `Hom_C (A,G B)', natural in objects `A' from `C' and `B' from `D'  (iirc)
03:13:08 <ski> mmorrow : i was trying to fit this with the class you pasted ..
03:14:03 <quicksilver> qweqwe: it's the minTree definition I expect
03:14:12 <quicksilver> qweqwe: you want minTree (Node c a v k b)
03:14:16 <quicksilver> qweqwe: (etc)
03:14:26 <fasta> qweqwe: you don't show all the relevant code, so I can only guess, which I won't.
03:14:27 <quicksilver> qweqwe: what you ahve writting is 'mintree' taking 6 arguments.
03:16:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4365
03:16:59 <qweqwe> http://hpaste.org/4365
03:17:11 <qweqwe> it with the constructors now
03:18:32 <qweqwe> ok found the problem
03:18:46 <qweqwe> it should be minTree (Node c Leaf v k b)
03:19:49 <quicksilver> that's what I just said :P
03:19:55 <Taejo> in "(f *** g) ~(x,y) = (f x, g y)", what does "~" mean?
03:20:05 <quicksilver> Taejo: irrefutable pattern match
03:20:18 <Taejo> quicksilver: what does that mean/do?
03:20:19 <quicksilver> which allows it to be lazy
03:20:26 <Taejo> oh, ok
03:21:07 <quicksilver> > ((+1) *** (+2)) undefined `seq` 5
03:21:08 <lambdabot>  5
03:21:16 <quicksilver> Taejo: without that, that would be undefined
03:21:40 <Taejo> ok
03:21:40 <njbartlett> @seen matthew-_
03:21:40 <lambdabot> matthew-_ is in #haskell. I don't know when matthew-_ last spoke.
03:21:47 <quicksilver> > let (f *** g) (x,y) = (f x,g y) in ((+1) *** (+2)) undefined `seq` 5
03:21:48 <lambdabot>  Undefined
03:21:48 <njbartlett> @seen matthew_-
03:21:48 <lambdabot> matthew_- is in #haskell. I don't know when matthew_- last spoke.
03:21:52 <hpaste>  mmorrow annotated "Adjoint funct(ors/ions) and some instances." with "cleaner instances using type annotations" at http://hpaste.org/4345#a8
03:21:54 <quicksilver> as demonstrated there! :)
03:23:18 <quicksilver> Taejo: I'm not entirely sure why they think that is important, myself :)
03:24:31 <mmorrow> ski : if you take C to be "the category with objects values of type a with morphisms f : a -> a" and D "the cat of .. of type b ...", and F := to, G := from
03:24:34 <matthew_-> njbartlett: boo
03:24:51 <mmorrow> that was my train of thought
03:24:55 <njbartlett> matthew_-: Hello! I have a new video for you...
03:25:09 <matthew_-> okay. Have you pushed it up?
03:25:17 <SamB_XP_> hmm, I guess -Wall does no harm if you don't also enable -Werror...
03:25:49 <SamB_XP_> Taejo: why did you need to know about irrefutable pattern matches?
03:26:08 <Taejo> I didn't. I saw a ~ and wondered what it meant
03:26:16 <SamB_XP_> fair enough
03:26:18 <mmorrow> quicksilver : unfortunately it seems i have to give the unit and counit in each instance despite the defaults (although with your method the instances are cleaner)
03:26:20 <axm> is there something like "unless pred a1 a2 = if (pred a1) then a1 else a2" or "when" predefined somewhere?
03:26:43 <quicksilver> mmorrow: why? what happens if you leave them out?
03:26:48 <SamB_XP_> axm: not really
03:26:55 <axm> :(
03:26:56 <mmorrow> it gives the same errors
03:27:02 <SamB_XP_> we would call it if', though
03:27:08 <axm> ah
03:27:17 <SamB_XP_> well, I mean, that's what @pl calls it
03:27:23 <axm> i was wondering what that meant a couple of times now
03:27:26 <SamB_XP_> but it isn't actually predefined
03:27:45 <SamB_XP_> no wait
03:27:46 <axm> that helped a lot actually, thanks
03:28:04 <idnar> @src if'
03:28:04 <lambdabot> Source not found. Wrong!  You cheating scum!
03:28:07 <idnar> pfft
03:28:07 <SamB_XP_> if' cond a1 a2 = if cond then a1 else a2
03:28:11 <SamB_XP_> sorry :-(
03:28:12 <fasta> axm: the problem with when is that it only makes sense for monads.
03:28:13 <SamB_XP_> that's not quite the same
03:28:26 <SamB_XP_> why "pred a1"?
03:28:31 <axm> fasta, you mean a1 would be evaluated twice anyway?
03:28:48 <axm> pred :: (a->Bool)
03:28:59 <fasta> axm: when False 5 => evaluates to?
03:29:02 <SamB_XP_> hmm, okay, I've not heard of a name for that...
03:29:07 <fasta> axm: the only sensible value is undefined
03:29:34 <baboa> hi, a question about hackage and cabal...
03:29:35 <axm> my when would take a bool fn, a value and a default
03:29:46 <fasta> axm: ok, that would be ok.
03:29:57 <baboa> how do I make my hackage package contain Haddock documentation?
03:30:21 <SamB_XP_> @hoogle a -> Maybe a -> a
03:30:21 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
03:30:21 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
03:30:21 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
03:30:43 <idnar> @src fromMaybe
03:30:44 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
03:31:04 <SamB_XP_> axm: those are the only things that come to my mind ...
03:31:05 <njbartlett> matthew_-: Not yet.. will do shortly
03:31:21 <njbartlett> matthew_-: Switch to private?
03:32:21 <axm> baboa, isnt there a cabal haddock target?
03:33:20 <baboa> axm: hmm, will see
03:33:33 <baboa> axm, I'm on Windows, so there could be a problem also
03:33:48 <baboa> but how to package this together?
03:34:23 <axm> no idea, never built one, was just suggesting that there would be no need to include extra docs
03:34:35 <axm> if using cabal anyway
03:34:54 <baboa> I built something, uploaded to hackage, so far so good
03:35:10 <baboa> except that my module hs no haddock info for modules
03:35:28 <baboa> at first I thought it is autogenerated at hackage site
03:35:32 <baboa> but isn't
03:35:52 <axm> ok, thats would i have thought as well
03:36:38 <mmorrow> ski : re: "...there is an isomorphism bwtween `Hom_D (F A,B)' and `Hom_C (A,G B)...". One interesting thing is that these may be isomorphism in terms of structure, but not necessarily in terms of complexity.
03:39:50 <axm> there might be a problem at the moment, if i understand that correctly http://groups.google.com/group/fa.haskell/browse_thread/thread/4eb0ff3123c8974a/9a77689195aa4744?fwc=1
03:39:51 <lambdabot> Title: Why doesn&#39;t Hackage link to Haddock documentation anymore? - fa.haskell | Go ..., http://tinyurl.com/2atah9
03:41:06 <axm> baboa, i mean. i should be more the highlighting kind.
03:41:39 <mmorrow> ski : maybe this could be exploited with rewrite rules or ???
03:42:08 <quicksilver> mmorrow, ski : I understand the adjunction thing to be only intuitive.
03:42:35 <quicksilver> mmorrow, ski : after all adjunctions are between *categories* and mmorrow's Adjunction is between *types*
03:43:04 <mmorrow> my 'categories' are types (and vice-versa)
03:43:19 <baboa> axm: so... do I have to do something special to have my lib documented
03:43:24 <baboa> axm: or just wait?
03:43:28 <quicksilver> how do you intend a type to be thought of as a category?
03:43:37 <quicksilver> what are the objects, and what are the morphisms?
03:44:25 <mmorrow> Map k a is the category with objects (Map k a)'s and morphisms f :: Map k a -> Map k a
03:45:22 <quicksilver> mmorrow: so objects are values?
03:45:35 <quicksilver> mmorrow: but then every morphism is between *every* pair of objects?
03:45:47 <mux> yeah, doesn't make much sense to me
03:48:19 <axm> baboa, i really do not know, i was more hoping someone else here would jump on that train.
03:48:28 <mmorrow> think of f as a collection of morphism parameterised my pairs (m,n) of (Map k a)'s s.t. f m === n
03:49:12 <quicksilver> but then you basically have a countable infinity of morphisms between every pair of objects
03:49:20 <quicksilver> and you have no structure, at all
03:49:28 <quicksilver> as a category it's degenerate
03:49:28 <baboa> axm: my old module, over some months on hackage still does not have documentation
03:49:32 <quicksilver> it's just got morphisms everywhere
03:49:37 <baboa> so there must be something wrong...
03:49:38 <mmorrow> yeah
03:49:47 <quicksilver> since its degenerate, its functors aren't interesting, and neither are its adjunctions.
03:49:55 <quicksilver> because there is no structure
03:50:01 <quicksilver> so 'structure-preserving' is meaningless
03:50:30 <quicksilver> which I think is why your adjunctions turn out to be simply set-isomorphisms
03:50:35 <quicksilver> that is, bijections.
03:50:37 <mmorrow> thus, interestingness must be found in functors between 'my' categories
03:50:45 <mmorrow> and nattrans between those functors
03:52:47 <baboa> axm:  I think I know... the haddock on hackage did not parse my comments correctly :)
03:53:13 <axm> baboa, it seems the documentation process is decoupled from the package upload, http://hackage.haskell.org/trac/summer-of-code/wiki/SoC2007Hackage, i cannot find anything about some special markup for doing the generation (I would not see a sense in that anyway)
03:53:25 <lambdabot> Title: SoC2007Hackage - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/yolmg2
03:53:29 <axm> so you have a clue it tried?
03:53:37 <mmorrow> ok, let me redo my phrasing of the categories i'm consider... Map k a is a category with a single object with only identity morphisms f : Map k a -> Map k a
03:54:23 <mmorrow> etc for every/any type
03:54:54 <mmorrow> => monoids
03:55:20 <mmorrow> under (.)
04:08:45 <quicksilver> mmorrow: *nod*. Well if it's the endormorphism monoid
04:09:04 <quicksilver> mmorrow: then your functors are monoid-preserving homomorphisms
04:09:36 <quicksilver> mmorrow: then your adjoints are pairs of homomorphisms and the unit and co unit are the kernels of the two homs
04:09:50 <quicksilver> mmorrow: the examples you gave all have trivial kernels and so are isomorphisms.
04:09:53 <quicksilver> I think.
04:10:13 <mmorrow> yeah
04:10:27 <mmorrow> i've been trying to think of some notrivial instances
04:51:31 <ADEpt> (stupid) question: i have day, month and year as strings. What's the quickest way to find out what weekday it is? I was looking in System.Time, but it seems to me that there is no easy method for that. Do i have to get current ClockTime and construct artificial TimeDiff to get what i need?
04:52:34 <faxathisia> @google dooms day algorithm
04:52:35 <lambdabot> http://rudy.ca/doomsday.html
04:52:35 <lambdabot> Title: Doomsday Algorithm &#8212; rudy.ca
04:53:29 <faxathisia> ADEpt: It's not a stupid question
04:53:47 <doserj> Data.Time.Calender.fromWeekDate?
04:53:52 <r3m0t> ?
04:53:52 <oerjan> ADEpt: Data.Time.Calendar may be a better bet
04:54:03 <doserj> Data.Time.Calender.WeekDate.fromWeekDate, sorry
04:54:31 * ADEpt looks through Hackage for D.T.Calendar
04:54:32 <doserj> resp. toWeekDate
04:55:17 <oerjan> hm, no.  those functions are based on week _number_
04:55:51 <doserj> toWeekDate :: Day -> (Integer, Int, Int)
04:56:04 <doserj> the third part in the tuple is the day of week
04:56:12 <ADEpt> doserj, oerjan: where is Date.Time.Calendar? It's not in 6.6.1, not in hackage, and it's hard to google for obvious reasons :)
04:56:21 <oerjan> oh like that.
04:56:24 <doserj> package time
04:57:56 <doserj> ADEpt: and it is "Data.Time....", not "Date.Time..." :)
04:58:48 <ADEpt> ah
04:58:52 <ADEpt> indeed
04:59:12 <oerjan> Data.Time.Calendar.fromGregorian also needed
04:59:31 <oerjan> ADEpt: note that afaik the Data.Time types are not compatible with the System.Time ones
05:00:33 <quicksilver> ADEpt: but, Data.Time is quite a bit better
05:00:39 <quicksilver> System.Time has a broken interface in several ways
05:00:48 <quicksilver> Data.Time is, at least, much less broken, even if not perfect :)
05:06:50 <ADEpt> quicksilver: well, the easies way seems to be (formatTime defaultTimeLocale "%a" (fromGregorian 2007 12 10)) and then analyze the string
05:13:41 <oerjan> ADEpt: toWeekDate (fromGregorian 2007 12 10) should be easier?
05:14:49 <oerjan> :t Data.Time.Calender.WeekDate.toWeekDate
05:14:51 <lambdabot> Couldn't find qualified module.
05:14:54 <oerjan> bah
05:15:01 <oerjan> :t Data.Time.Calendar.WeekDate.toWeekDate
05:15:02 <lambdabot> Couldn't find qualified module.
05:16:17 <Sizur> who's using or used Yampa? i think my compilation step halts at deriving instances
05:16:22 <ADEpt> oerjan: indeed :( I'm being dense today, it seems
05:25:28 <michaelkohwj> hello
05:26:35 <michaelkohwj> is the leap from C-style languages (perl, ruby), to functional languages (haskell, erlang) require a total change of perspective towards programming?
05:26:42 <michaelkohwj> s/is/does
05:27:01 <r3m0t> not really
05:27:09 <r3m0t> more like a new perspective to add to the old one
05:27:42 <r3m0t> and by the way, non-functional languages are called "imperative", not "C-style"
05:27:58 <michaelkohwj> r3m0t: ah icic
05:28:43 <michaelkohwj> r3m0t: oh wait i just found http://www.haskell.org/~pairwise/intro/intro.html
05:28:44 <shag> is there a way to make haddock handle utf8 characters in the .hs files correctly?
05:28:44 <lambdabot> Title: Haskell for C Programmers
05:28:50 <michaelkohwj> "Haskell Tutorial for C Programmers"
05:29:00 <michaelkohwj> thank you haskell.org
05:29:51 <sieni> well, I wouldn't call e.g. prolog either a functional or an imperative language
05:29:56 <sioraiocht> r3m0t: well, there do exist other paradigms than funtional or imperative, hehe
05:30:08 <sioraiocht> I would call prolog a headache
05:30:14 <r3m0t> ok ok, stop shooting me now :-)
05:30:30 <sioraiocht> hahahahah
05:30:39 <r3m0t> but prolog is closer to haskell than to perl
05:30:51 <r3m0t> because you know even less about the order of the computations
05:30:54 <earthy> um. um. :)
05:30:59 <sioraiocht> also, I would call lisp multi-paradigm
05:31:02 <r3m0t> I mean, you *specify* even less.
05:31:09 <opqdonut> well not really
05:31:16 <opqdonut> i'd say you specify more than in haskell
05:31:24 <opqdonut> e.g ! and so on
05:31:50 <sioraiocht> michaelkohwj: if you're familiar with functions as first class values, you're on yoru way to understand the basics of haskell
05:32:10 <earthy> http://citeseer.ist.psu.edu/cache/papers/cs/14072/http:zSzzSzwww.comlab.ox.ac.ukzSzouclzSzuserszSzsilvija.sereszSzPaperszSzehp.pdf/spivey99embedding.pdf
05:32:12 <lambdabot> http://tinyurl.com/2a6d2b
05:32:18 <earthy> for the 'prolog is close to haskell'
05:32:59 <sioraiocht> haha mike spivey
05:33:02 * sioraiocht is terrified of him.
05:33:09 <michaelkohwj> sioraiocht: first class values? thank you for new stuff to google.. hmm
05:33:24 <r3m0t> haskell for C programmers seems too much effort
05:33:37 <r3m0t> better to just ignore everything you've learned and start an ordinary haskell tute
05:33:53 <michaelkohwj> sioraiocht: oh, something that can be used in any way one wants...
05:33:56 <r3m0t> tinyurl is on 6 chars now? ouch
05:34:01 <sioraiocht> yes
05:34:12 <sioraiocht> specifically they can be passed to and returned from functions
05:34:18 <r3m0t> why are you terrified of mike spivey?
05:34:57 <michaelkohwj> sioraiocht: oh wait, like passing blocks in ruby or subroutine references in perl?
05:35:00 <sieni> well, C is a bit annoying for doing functional programming, since you don't have garbage collection, but in perl you can do functional programming
05:35:14 <earthy> michaelkohwj: indeed
05:35:16 <sieni> think about horrors of that: http://www.amazon.com/Higher-Order-Perl-Transforming-Programs/dp/1558607013
05:35:16 <sioraiocht> r3m0t: the first time I met him he started speaking german to me, and was somewhat shocked I didn't know what he was saying.  also, i'm currently trying to get into his college
05:35:30 <r3m0t> which college is he at?
05:35:33 <sioraiocht> Oriel
05:35:35 <michaelkohwj> sieni: what's wrong with HOP?
05:35:43 <r3m0t> cool. I'm at merton
05:36:04 <r3m0t> are you planning to do the MSc or what?
05:36:10 <sioraiocht> I'm at St anne's right now, i sort of hate it, and am trying to transfer before I to my dphil
05:36:12 <sioraiocht> no i'm doing the msc right now
05:36:15 <sieni> michaelkohwj: Higher Order Programming or doing it in Perl? :-)
05:36:33 <michaelkohwj> sieni: the book Higher Order Perl
05:36:41 <r3m0t> well that was unlikely. have you ever visited irc://irc.ox.ac.uk/#compsci ?
05:36:52 * EvilTerran sniggers
05:36:55 <sioraiocht> hahah
05:36:59 <sioraiocht> yes
05:37:02 <sioraiocht> i'm in rtharper ;)
05:37:04 <r3m0t> my sister was at st anne's, didn't seem *that* ugly :P
05:37:06 <EvilTerran> r3m0t, look at his whois :P
05:37:12 <michaelkohwj> damn im stuck in a stupid diploma vocational course where they teach java and asp.net in vb
05:37:22 <r3m0t> ach, damn this client of not-very-whois proportions
05:37:28 <michaelkohwj> ashamed to say that im in www.np.edu.sg
05:37:31 <quicksilver> I think that being able to pass functions around is possible in all currently popular languages. Personally I find that immutable values and referential transparency (which go together) is more the flavour of haskell.
05:37:33 <sieni> michaelkohwj: I haven't read it so I couldn't know.
05:37:33 <sioraiocht> michaelkohwj: java is a valuable languae to know.
05:37:45 <r3m0t> asp.net in vb?
05:37:56 <michaelkohwj> not that it's not a poor school, but i don't forsee myself being a java code monkey
05:38:07 <michaelkohwj> sioraiocht: yes, for the money
05:38:16 <r3m0t> btw sioraiocht , since you're in the UK, can you check if Pandora is still open in the UK?
05:38:26 <michaelkohwj> sioraiocht: but life is more than just money- why else are you in #haskell? *ducks
05:38:35 <sioraiocht> hahahah
05:38:42 <r3m0t> quicksilver: `possible, but not really utilised
05:38:47 <sioraiocht> r3m0t: pandora, the music genome project?
05:38:53 <r3m0t> yes, that one
05:38:57 <sioraiocht> yes it is
05:39:03 <sioraiocht> though i prefer last.fm, personally
05:39:16 <EvilTerran> doesn't pandora demand a US zipcode after three songs or sth?
05:39:28 <r3m0t> they've blocked israel for a start
05:39:53 <r3m0t> they could probably block the UK if they didn't have the license. => the zipcode requirement was porbably removed
05:40:00 <sioraiocht> r3m0t: use the oxford VPN
05:40:17 <sioraiocht> you guys can use my zip code if you want
05:40:18 <sioraiocht> 92629
05:40:25 <r3m0t> sioraiocht: I dunno, this connection is pretty slow as it is
05:40:28 <EvilTerran> hehe <.< >.>
05:40:49 <r3m0t> most 5-digit numbers work
05:40:58 <sioraiocht> indeed, we have a lot of zip codes
05:41:20 <sioraiocht> michaelkohwj: i'm in academia, of course I don't carea bout money ;)  but java is also useful as a language of discourse
05:41:32 <sioraiocht> as is C and Pascal
05:41:35 <sioraiocht> *as are
05:42:08 <faxathisia> What is Pascal useful for?
05:42:23 <sioraiocht> faxathisia: describing algorithsm
05:42:36 <r3m0t> a language of discourse: something you can write for everybody to understand
05:42:44 <r3m0t> except me of course
05:42:59 <sioraiocht> most algorithms books use some derivative of Pascal for their code
05:43:14 <michaelkohwj> r3m0t: and to bash it too...
05:43:26 <sioraiocht> I had an entire scientific computing class taught in SuperPascal
05:43:27 <r3m0t> something you can bash for everybody to agree?
05:43:52 <michaelkohwj> r3m0t: well, in some places, most people hate java
05:43:54 <r3m0t> I think that role is mostly taken by BASIC and derivatives
05:44:15 <sioraiocht> I hate on the java, but I hate faaaar more on the C++
05:44:42 <michaelkohwj> my lecturer once told me that while java is the most-used language in the industry, lots of java programmers hate it
05:45:03 <michaelkohwj> C++?
05:45:31 <michaelkohwj> i have quite a bit of ignorant respect for that language...
05:45:42 <ricky_clarkson> michaelkohwj: It's only IDEs holding us (yes, me included) back to Java.
05:45:48 <faxathisia> "ignorant respect"?
05:45:55 <njbartlett> michaelkohwj: Most Java programmers only know Java. So it's difficult to tell whether they hate Java, or just hate being programmers.
05:46:02 <michaelkohwj> ignorant because i've not used it a lot
05:46:22 <quicksilver> r3m0t: I dunno. It's very heavily utilised in javascript and C, to pass callbacks.
05:46:44 <quicksilver> r3m0t: in java you mainly pass objects but sometimes these objects are thinly disguised closures, so that's much the same really.
05:46:44 <michaelkohwj> njbartlett: they probably hate programming, poor code monkeys
05:46:50 <r3m0t> yes but they don't return functions very often, only pass them
05:46:59 <quicksilver> that's true, yes.
05:47:27 <michaelkohwj> faxathisia:  ignorant because i've not used it a lot, so i have never experienced its disadvantages. but i know that its very powerful
05:47:37 <r3m0t> actually, apart from currying and applying (.), I don't return functions very often either
05:47:51 <faxathisia> michaelkohwj: I don't know if you'll beleive me or not... but C++ is -not- very powerful
05:47:53 <r3m0t> what is this "powerful" people always talk about. :-)
05:48:05 <faxathisia> michaelkohwj: It's just another programming language, in particular it's a very badly designed one
05:48:20 <ricky_clarkson> r3m0t: Being able to express what you want to, in terms you want to.
05:48:31 <opqdonut> faxathisia: well depends on what sort of c++ you are talking about
05:48:32 <faxathisia> I would say haskell is far more powerful
05:48:38 <faxathisia> you write a little bit of haskell and it does a lot
05:48:45 <opqdonut> template-boost-stl c++ is very powerfull
05:48:47 <faxathisia> you write a lot of C++ and it.. crashes
05:49:00 <michaelkohwj> faxathisia: come to think of it, much of my arguments against java are valid against c++... hmm
05:49:07 <michaelkohwj> s/much/many/
05:49:08 <r3m0t> crashes powerfully?
05:49:17 <michaelkohwj> oh yeah, blows your whole leg oof
05:49:22 <faxathisia> crashes pointlessly
05:49:23 <michaelkohwj> s/oof/off/
05:49:27 <faxathisia> type system but not type safety
05:49:28 <ricky_clarkson> I liked oof.
05:49:43 <ricky_clarkson> > head []
05:49:45 <lambdabot>  Exception: Prelude.head: empty list
05:49:55 <ricky_clarkson> Like Haskell then? ;)
05:50:10 <opqdonut> ^_^
05:50:26 * michaelkohwj folds arms
05:50:31 <mux> > listToMaybe []
05:50:33 <lambdabot>  Nothing
05:50:36 <michaelkohwj> is that some haskell inside joke?
05:50:39 <mux> > listToMaybe [1..10]
05:50:39 <lambdabot>  Just 1
05:50:47 <mux> only fools would use head! ;-)
05:50:55 <opqdonut> :)
05:51:02 <ricky_clarkson> @src listToMaybe
05:51:02 <lambdabot> listToMaybe []        =  Nothing
05:51:02 <lambdabot> listToMaybe (a:_)     =  Just a
05:51:05 <faxathisia> was that use of head directed at me?
05:51:12 <ricky_clarkson> faxathisia: Yes.
05:51:14 <mux> plus most of the time you recurse on a list with pattern matching, so it makes you think of the [] case
05:51:17 <faxathisia> um..... why
05:51:27 <sioraiocht> that's a poory named function
05:51:38 <opqdonut> yeh it should be unsafeHead
05:51:41 <r3m0t> it should be headtoMaybe maybe
05:51:53 <ricky_clarkson> faxathisia: You said "type system without type safety", which I agree with, but at some level every language I've used has unsafe parts.
05:51:53 <r3m0t> headToMaybe of course. not my keyboard.
05:52:04 <faxathisia> ricky_clarkson: That's absolute nonsense
05:52:10 <ricky_clarkson> With perhaps the exception of Coq, which my head did not wrap itself around.
05:52:17 <ricky_clarkson> faxathisia: Can you explain?
05:52:32 <faxathisia> ricky: Read TAPL.. It will explain better than me
05:52:41 <mux> even better, using folds, you don't even need to care about the [] case
05:52:54 <faxathisia> anyway, head not being total has nothing to do with type safety..
05:53:23 <opqdonut> well in a way it does
05:53:25 <quicksilver> C++ has a (large) type-safe fragment.
05:53:28 <ricky_clarkson> faxathisia: dibblego once said that all errors are type errors.  I don't know whether he was correct, but he's read TAPL and I haven't.
05:53:29 <faxathisia> exceptions are not unsafe type coercions/violations..
05:53:42 <quicksilver> it's just that in practice people work outside that fragment.
05:53:50 <Sizur> headToMaybe sounds too much like a curse statement "you will go to nirvana tomorrow at night!"
05:54:09 <Sizur> the MaybeLand
05:54:25 <quicksilver> I think the likes of boost and so on substantially increase C++ type-safety in practise
05:54:25 <opqdonut> faxathisia: well, even tapl says that the point of type safety is to remove runtime errors
05:54:46 <quicksilver> by giving type-safe ways to do various complex tasks.
05:54:58 <opqdonut> yeah, as i said earlier, boost-stl-template c++ is very elegant, powerful and safe
05:55:02 <mux> yeah but TAPL never claims that all programming errors can be caught with the type system
05:55:33 <ricky_clarkson> "can be caught" is different to saying that all programming errors are type errors, though.
05:55:41 <faxathisia> basically I would suggest ricky_clarkson do some reading, since anything I say will be put forth with less rigour and less eloquently
05:55:43 <opqdonut> mux: of course
05:55:47 <ricky_clarkson> Thanks to Alan and his halting problem.
05:55:58 <faxathisia> oh please.. don't bring this into the discussion
05:55:59 <ricky_clarkson> faxathisia: Sure.  I think I have the PDF of that waiting for me.
05:56:15 <mux> I'm referring to dibblego's statement that all errors are type errors
05:56:38 <ricky_clarkson> mux: Is he wrong?
05:56:38 <Sizur> why not? with sufficiently complete type system?
05:57:03 <mux> ricky_clarkson: I'd say so; to me this means the same as saying that the all programming errors can be caught by the type system
05:57:13 <mux> s/the//
05:57:16 <faxathisia> "is he wrong?" -- Do you fully understand what he's actually saying?
05:57:25 <faxathisia> otherwise it's a pointless question to address
05:57:26 <mux> mere logic errors can not be caught by the type system, however powerful it is
05:57:33 <ricky_clarkson> faxathisia: I cannot judge whether I fully understand something, clearly.
05:57:40 <mux> even dependent typing won't catch logic errors that type-check
05:57:43 <mux> :-)
05:58:01 <Sizur> mux how do you recognize logic errors?
05:58:20 <ricky_clarkson> mux: Let's restrict the discourse to errors that would be runtime errors if not caught.
05:58:25 <Sizur> if you can do it, you can write code to do it for ya, correct? if you can write code, it can run at compile time
05:58:28 <mux> ricky_clarkson: okay
05:58:31 <ricky_clarkson> e.g., segfaults, exceptions.
05:58:31 <dcoutts> mux: dependent type people might say that your types should express the properties and so also catch logic errors
05:58:33 <mux> Sizur: no
05:58:41 <faxathisia>  in any case "head []" is absolutely not what I was talking about when I said type safety
05:58:49 <Sizur> mux i'm not saying you can do that in haskell
05:58:58 <mux> Sizur: a logic error can stem from the fact that you didn't read some piece of paper describing the specifications correctly, for instance
05:59:05 <Sizur> or in any current language for that matter
05:59:08 <faxathisia> consider things like accidentally chopping off the '\0' at the end of an ASCIIIZ string
05:59:10 <dcoutts> mux: eg that example where you can specify a type for the sort function such that any impl really is a correct sort
05:59:12 <mux> how will some code read and understand specifications for you? :)
05:59:28 <mux> dcoutts: dependent typing can't catch logic errors I'm talking about right now, though
05:59:47 <Sizur> mux, oh you mean solving a different problem from what you've been asked. well yes, type system cannot help there
05:59:51 <ricky_clarkson> faxathisia: Fair enough.  My thoughts are that as some level, that \0 problem and head [] are isomorphic.
05:59:57 <mux> Sizur: yeah
06:00:03 <mux> ie, + instead of *
06:00:05 <Sizur> but that' snot a logic error
06:00:10 <Sizur> it's understanding error
06:00:11 <ricky_clarkson> ..I will go and read, to see whether I'm right there.
06:00:13 <faxathisia> ricky_clarkson: Sorry but again.. That is total nonsense and a misuse of the word "isomorphic"
06:00:15 <mux> you'd have a hard time catching such an error
06:00:22 <ricky_clarkson> Ok, equivalent.
06:00:46 <mux> Sizur: *shrug* my admittedly limited english skills may have lead me to using the wrong term here, I don't know
06:01:10 <Sizur> mux no worries, i had the misunderstanding error here
06:02:17 <mux> dcoutts: playing with dependent typing to express complex properties about your code can indeed help preventing a very large class of errors, but it requires you to have thought about the likeliness of the said errors before hand, right?
06:02:34 <mux> it's still very nice
06:02:45 <dcoutts> mux: well, it makes you think very hard about what the specification is, and that's typically quite hard
06:03:15 <dcoutts> mux: you don't have to think about it as catching errors, rather of defining total correctness
06:04:38 <mux> dcoutts: are you using any specific dependent typing language?
06:05:10 <dcoutts> mux: I was thinking about epigram but I expect it's similar for any dependent typed programming language or proof system
06:05:27 <mux> I wish I could compile code with Agda
06:05:35 <sioraiocht> dcoutts: have you heard of Sage?
06:05:49 <dcoutts> sioraiocht: the maths package?
06:05:59 <sioraiocht> dcoutts: no, the programming language ;)
06:06:02 <ricky_clarkson> I read that the more you define total correctness the harder your life becomes.
06:06:10 <dcoutts> ricky_clarkson: yep
06:06:25 <dcoutts> sioraiocht: then I probably havn't
06:06:43 <sioraiocht> it handles dependent types and refinement types
06:06:44 <dcoutts> http://sage.soe.ucsc.edu/
06:06:47 <lambdabot> Title: Sage: A Programming Language with Hybrid Type-Checking
06:06:52 <sioraiocht> that one
06:07:28 <sioraiocht> the only down side: the type system is generally undeciable ;)
06:07:39 <dcoutts> right
06:07:50 <dcoutts> sounds a bit like ESC Java or ESC Haskell
06:07:50 <sioraiocht> it's still pretty neat
06:08:06 <sioraiocht> yes, but also does more
06:08:12 <dcoutts> where you use the term language to write predicates on values, or invariants on types
06:08:20 <sioraiocht> because it can handle dependent types
06:08:47 <dcoutts> yes that is more general
06:09:07 <dcoutts> I wonder to what extent it can check that statically and how much it has to leave to runtime
06:09:16 <sioraiocht> the paper has some figures on that
06:09:23 <sioraiocht> it could check a fair amount statically, it seems
06:10:27 <osfameron> gah reddit... how do I go from this link to the original article? http://programming.reddit.com/info/62kbq/comments/
06:10:43 <ricky_clarkson> There doesn't seem to be a fundamental unit for type systems like you have lambda for describing how values interact.
06:10:49 <sioraiocht> haha monads are a fraud, eh?
06:10:50 <osfameron> (the provocative "Monads are a fraud" title)
06:11:01 <ricky_clarkson> osfameron: That is the article.
06:11:16 <osfameron> the article is that one line title?
06:11:17 <ricky_clarkson> The comment by osipov.
06:11:36 <osfameron> ah, ok
06:11:46 <osfameron> I thought reddit posts were all linked to an original article
06:12:03 <ricky_clarkson> Have you seen any Ask Reddit posts?
06:12:10 <sioraiocht> btw, his argument = SUPER simplistic
06:12:15 <ricky_clarkson> They aren't linked to anything, that I've seen.
06:12:16 <michaelkohwj> ricky_clarkson: ?
06:12:32 <michaelkohwj> ricky_clarkson: yup, what about them
06:12:45 <ricky_clarkson> "They aren't linked to anything, that I've seen."
06:16:29 <scook0> (i.e. some reddit posts link to their own comment thread, instead of an external article)
06:17:18 <osfameron> ah!  that's what these posts do when you click on the title
06:17:26 <osfameron> it's very confusing when that doesn't take you anywhere
06:17:30 <osfameron> just looks broken
06:19:25 <michaelkohwj> osfameron: "It's a feature, not a bug" (TM)
06:19:55 <osfameron> http://files.myopera.com/freejerk/files/bug-feature.jpg
06:20:42 <faxathisia> hehe
06:21:36 <dcoutts> Lemmih, Igloo: did you notice the reddit blog post on web server framwork http performance? HAppS comes out pretty well.
06:22:46 <michaelkohwj> dcoutts, is that becuse haskell has better performance?
06:23:08 <dcoutts> michaelkohwj: that and the HAppS hackers are pretty clever :-)
06:23:11 <michaelkohwj> ah
06:24:10 <dcoutts> in that particular test HAppS wipes the floor with RoR, esp for dynamically generated content.
06:25:50 <michaelkohwj> dcoutts, too bad few web hosts offer it
06:26:14 <dcoutts> it's a little early for that I think
06:26:34 <dcoutts> of course if you use a web host that lets you run your own code you're ok
06:26:50 <dcoutts> ie not limiting you to uploading php scripts
06:27:21 <dylan> or if you have a proper (virtual) server
06:28:04 <faxathisia> HAppS wipes the floor in what respect?
06:28:52 <faxathisia> oh just performance wise
06:30:31 <michaelkohwj> faxathisia: well, ruby 1.9 has lots of performance improvements, but even so, i doubt that it will beat happs
06:30:33 <sclv> everything wipes the floor with RoR.
06:30:57 <michaelkohwj> has anyone heard about BSSP? =P
06:31:14 <michaelkohwj> actually, SHSP: http://hyperrealm.com/wtfd00d/shsp/
06:31:15 <lambdabot> Title: Bourne Shell Server Pages
06:32:15 <michaelkohwj> lambdabot: spoilerbot!
06:33:57 <quicksilver> michaelkohwj: haskell is several orders of magnitude faster than ruby, without doubt
06:34:08 <quicksilver> michaelkohwj: ruby is an interpreted language well known for being slow :)
06:34:19 <quicksilver> michaelkohwj: haskell is compiled and its compiler does a pretty good job.
06:34:52 <quicksilver> of course, many web applications are not CPU-bound
06:35:02 <michaelkohwj> quicksilver: once my exams are over, i'm learning haskell..
06:35:05 <quicksilver> (not CPU-bound in the app process, at least: CPU-bound in the DB process some times)
06:36:10 <sclv> measuring HAppS' MACID against a LAMP or Tomcat/MySQL stack might be more interesting for that reason.
06:37:16 <Sizur> i dont think we are ready yet for headon vs jvm
06:37:39 <Sizur> soon hopefully
06:38:24 <quicksilver> sclv: it would be massively dependent on the kind of data processing task you were doing
06:38:49 <quicksilver> sclv: factors like how often transactions collide and so on
06:39:01 <quicksilver> sclv: possibly hard to craft a good benchmark.
06:39:04 <quicksilver> interesting, though
06:39:32 <sclv> databases will tend to handle collisions better?
06:39:40 <quicksilver> not necessarily
06:39:51 <quicksilver> I just mean that would be a key part of the question :)
06:39:58 <quicksilver> no database is actualy acid...
06:40:17 <quicksilver> so in principle you could craft a benchmark in which the DB gave wrong results and only happs got it right :)
06:40:36 <sclv> I haven't quite wrapped my head about how MACID interacts with optimistic transactions in terms of the granularity it provides.
06:41:03 <quicksilver> I thought it was, essentially, optimistic concurrency with auto-retry.
06:41:05 <sclv> quicksilver: not if you used transactions in the db properly, no?
06:41:10 <quicksilver> but, I haven't studied it deeply.
06:41:27 <quicksilver> sclv: SQL's isolation level "SERIALIZABLE" is, in fact, not serializable.
06:41:29 <freepenguin> hello
06:41:32 <quicksilver> sclv: ironic though this sounds :)
06:41:41 <quicksilver> sclv: it permits certain kinds of anomalies.
06:43:20 <sclv> right -- but then it seems to store everything in a structure. so if i perform to simultaneous inserts to a "table", SQL should be able to perform them sequentially in the worst case whereas MACID might end up having to perform an auto-retry and so end up with far worse performance in the degenerate case of massive load. but I haven't explored enough.
06:43:59 <quicksilver> sclv: yup, that sounds plausible.
06:44:23 <quicksilver> sclv: but then again SQL might do two things simultaneously which could never occur sequentially :)
06:44:44 <HeartOfDarkness> it absolutely can
06:45:19 <HeartOfDarkness> (in the right implementation, ie any "full enterprise engine")
06:46:07 <sclv> the worst case scenario is i have complex transaction A (say, updating a massive amount of records that match a certain query) and simple transaction B (an insert) and get hammered with a constant rate of B. In theory, A might never manage to execute. :-(.
06:46:44 <quicksilver> Lycurgus: dososs 
06:46:44 <quicksilver> `.
06:47:10 <opqdonut> :D
06:47:10 <Syzygy-> quicksilver: o.O
06:47:16 <opqdonut> his ssh is lagging
06:47:27 <quicksilver> ;)
06:47:28 <quicksilver> nice
06:47:31 <opqdonut> and he's trying to kill it, but mistyped ~ as '
06:47:37 <quicksilver> Lycurgus: sorry, which were you agreeing with?
06:47:51 <quicksilver> Lycurgus: "it absolutely can" ?
06:48:05 <opqdonut> and his backspaces got interpreted as literals because they all came in a burst
06:48:12 <opqdonut> due to the connection hiccupping
06:48:21 <quicksilver> sclv: I'm familiar with that example yes.
06:48:30 <quicksilver> sclv: I suspect you're right but I don't know enough about happs to be sure.
06:48:36 <Lycurgus> that SQL can do things (to data) simultaneously which a (non-parellized) programming language normally couldn't
06:48:51 <Lycurgus> under the given conditions on the implemntation
06:49:04 <quicksilver> Lycurgus: yeah. Although kind of the point I was making is that even in isolation level SERIALIZABLE, it actually isn't.
06:49:24 <quicksilver> one of the SQL standard teams many mistakes, but arguably one of the worst.
06:52:10 <michaelkohwj> cya tomorrow guys, i have a networking fundamentals test and am sleeping early
06:53:32 <michaelkohwj> Captian Obvious' fact of the day: switches have a higher bandwidth because they allow each node to have its own dedicated connection!
06:53:33 <michaelkohwj> cya
06:54:03 <r3m0t> are you captain obviuos?
06:58:52 <pjd> quicksilver: SERIALIZABLE actually isn't?
07:00:59 <pjd> quicksilver: what anomalies do you mean?
07:02:59 <dancor> why does array-0.1 expect GHC.Arr.numElements to exist
07:03:32 <dancor> which does not, in ghc 6.6.1 anyway..
07:04:08 <dcoutts> dancor: it changed from 6.6 to 6.8
07:04:23 <dcoutts> the numElements is new, there's something similar in MArray
07:04:55 <dcoutts> it's an extra bounds check so that even if your Ix instance is buggy then there cannot be unsafe indexing
07:11:12 <psi> I can't build cabal 1.2.2: at least the following dependencies are missing: filepath-any. I have FilePath-0.11 in my ghc-pkg list.
07:11:34 <psi> (ghc-6.6)
07:11:47 <dcoutts> psi: upgrade to filepath-1.0 or 1.1
07:11:59 <psi> ugh. ok.
07:14:16 <dancor> so there is a bug in cabal's dependency specification?  meta++
07:14:26 <dcoutts> is there?
07:14:34 <dancor> he has filepath-any?
07:14:52 <dcoutts> no, he has an old version of FilePath, not filepath
07:14:55 <quicksilver> pjd: http://www.postgresql.org/docs/8.2/interactive/transaction-iso.html
07:14:56 <lambdabot> Title: PostgreSQL: Documentation: Manuals: PostgreSQL 8.2: Transaction Isolation, http://tinyurl.com/36djnh
07:14:58 <dancor> ah.
07:15:06 <quicksilver> pjd: "12.2.2.1. Serializable Isolation versus True Serializability"
07:15:33 <dcoutts> dancor: currently ghc treats package names case sensitively, though there are moves to change that in 6.10
07:15:40 <quicksilver> @quote python
07:15:40 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
07:15:41 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
07:15:44 <quicksilver> @quote guild
07:15:45 <lambdabot> No quotes match.
07:15:47 <quicksilver> bah
07:15:57 <quicksilver> @quote Guild
07:15:58 <lambdabot> No quotes match. :(
07:16:11 <dancor> dcoutts: sounds like changing that could exacerbate further (if possible)
07:16:49 <dcoutts> dancor: well in this case FilePath and filepath are really the 'same' package
07:16:52 <pjd> quicksilver: ah, right
07:17:13 <dcoutts> dancor: there are no other cases I know of where we have name clashes
07:17:39 <dcoutts> dancor: so in 6.8.2 it'll tell you sternly if you try to register two packages with names that differ only in cases
07:18:04 <dcoutts> and in 6.10 it may just treat them case insensitively
07:18:15 <dancor> cool
07:18:38 <dcoutts> it helps because most package systems use files and systems like macosx and windows use case insensitive file systems
07:18:52 <dcoutts> and even the unix package managers often just lower case all package names
07:19:00 <quicksilver> @remember wli If you can fly with Python, then you can fold space like a Guild Navigator with Haskell?
07:19:00 <lambdabot> Nice!
07:19:08 <quicksilver> dons: it makes me sad when lambabot forgets quotes
07:19:11 <dcoutts> so clashes would be really annoying, so it's better to ban them now
07:19:14 <quicksilver> dons: especially when they're good ones like that!
07:21:40 <dancor> hm type inferrence error building hslogger-1.0.2 with ghc-6.8.1, that's odd
07:22:54 <dancor> ha! http://hackage.haskell.org/packages/archive/hslogger/1.0.2/log
07:23:16 <dancor> i don't understand why you would post a package knowing it doesn't compile?
07:24:04 <Saizan> it compiled with a previous cabal
07:24:09 <ricky_clarkson> Fixing it is left as an exercise.
07:24:14 <dancor> heh
07:24:26 <Saizan> dancor: the darcs version compiles fine
07:24:28 <dancor> it's to protect it from being abused by noobs
07:25:38 <dancor> is it considered bad form to not use the latest darcs of everything
07:26:05 <himmel> Hi ... I am a beginner to Haskell .. I've defined my main thus ... main = do putStr "prompt1:" a <- getLine putStrln (show a)
07:26:07 <dancor> i'm not sure what strategy is likely to lead to the least build woes
07:26:18 <himmel> Assuming that the indentation is as reqd.
07:26:29 <himmel> But however, it asks for input before actually printing the prompt.
07:26:32 <himmel> Any ideas why?
07:26:41 <mauke> himmel: buffering
07:26:55 <mauke> add hFlush stdout after the first putStr
07:27:15 <himmel> Okay thanks. I couldn't find it in any tutorials online.
07:27:39 <mauke> this problem is actually language independent :-)
07:28:14 <dancor> buffering is in tricksly in general
07:29:08 <himmel> Tried that, (using ghc 6.6.1) .. says hFlush and stdout not in scope ...
07:29:20 <mauke> import System.IO
07:29:53 <quicksilver> himmel: alternatively, before the putstr, do hSetBuffering stdout NoBuffering
07:30:00 <quicksilver> himmel: this will, also, require System.IO though.
07:30:20 <mauke> won't that call write(2) for every single character?
07:31:32 <mux> mauke: it sure shouldn't
07:32:16 <mux> it's not because buffering is disabled that, for instance, hPutStrLn "Hello world!" shouldn't result in a single write() call
07:32:19 <EvilTerran> every call to an atomic output function, perhaps
07:32:24 <quicksilver> mauke: no, just once for each putStr, etc.
07:32:37 <EvilTerran> (being one that *can* be represented as a single write())
07:34:30 <mauke> quicksilver: it does
07:34:43 <mauke> call write for each char, I mean
07:34:56 <mux> well that's a bug
07:35:00 <dcoutts> that's expected for no buffering since hPutStr is not atomic
07:35:07 <dcoutts> since it lazily evaluates the string
07:35:13 <mux> ew
07:35:22 <dcoutts> so you get each char as and when it's evaluated
07:35:42 <dcoutts> think about what ghci does when you evaluate primes or something
07:35:42 <mux> I guess hPutStr could at least try coalesce writes
07:35:54 <mux> mmh not
07:35:54 <dcoutts> how? by time?
07:35:57 <dcoutts> using threads?
07:36:10 <dancor> hm.  so is this not valid in ghc 6.8.1:    data Proxy (a :: * -> *)
07:36:52 <dancor> i guess i have to know more haskell to get things to compile.  this is like needing to know go well before you can tell who has won finished games
07:37:29 <dcoutts> mux: it could do it in a fairly complex way by only printing ever few millisec or whenever the buffer fills, whichever is the sooner. It'd definitely require threads since you cannot introspect a lazy list to see if things are arriving in batches.
07:37:44 <EvilTerran> dancor, there should be a -X flag to allow that
07:38:21 <dcoutts> mux: for example lazy bytestrings can work effectively with no buffering because lazy bytestrings are already buffers :-)
07:38:38 <dcoutts> and we can see the chunk structure and do one write() for each chunk
07:38:41 <dancor> EvilTerran: do you know what like that feature is called so i can find the flag
07:38:53 <mauke> -fglasgow-exts?
07:39:37 <EvilTerran> http://haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#kinding
07:39:38 <lambdabot> http://tinyurl.com/2nsm7r
07:39:45 <EvilTerran> -XKindSignatures
07:39:58 <EvilTerran> or {-# LANGUAGE KindSignatures #-} at the top of the file
07:40:44 <dancor> thanks!
07:40:46 <conal> what would dancor's type decl mean?  what would the data value hold?
07:41:25 <EvilTerran> mauke, while that's often handy in practice, i like to know exactly which extensions i'm using. matter of personal preference, i guess.
07:41:51 <EvilTerran> conal, it means that the parameter to the Proxy type constructor itself takes a parameter
07:43:00 <EvilTerran> as it stands, it'd be a phantom type, and would only hold bottom, but there might be data constructors he hasn't mentioned
07:43:32 <mux> dcoutts: yeah, gotcha
07:43:42 <conal> dancor: what do you want your Proxy decl to mean?
07:44:09 <dancor> conal: i was just getting syb-with-class 3.0 to build with ghc 6.8.1
07:44:24 <dancor> the .cabal didn't specify some -X's
07:44:28 <conal> oh, never mind.  i  get it.
07:45:07 <conal> it's a a data type with no fields.
07:46:55 <EvilTerran> no constructors, you mean?
07:46:57 <conal> EvilTerran: that's probably it.
07:53:58 <nomeata> Igloo: Hi Ian.
07:58:05 <dons> awesome work happs hackers! http://blog.davber.com/2007/12/10/web-server-performance-shoot-out-simple-pages/
07:58:06 <lambdabot> Title: davber does IT  Web server performance shoot out - simple pages, http://tinyurl.com/3do7dh
07:58:38 <Saizan> dancor: btw, if you're installing syb-with-class for HAppS you want the darcs version of that too :)
07:59:18 <dancor> Saizan: yeah figured that out eventually heh
08:00:04 <dancor> i thought cabal would save me from myself earlier but no
08:12:43 <psi> did anyone try to port roguelulz to haskell? :)
08:13:45 <glen_quagmire> do you prefix everythign with module?
08:14:02 <glen_quagmire> > Prelude.product [1,2,3]
08:14:04 <lambdabot>  6
08:14:16 <psi> no, you don't have to
08:14:35 <glen_quagmire> but isn't this a good practice for real life large software?
08:14:39 <psi> you can import things "qualified" which means you have to prefix
08:14:49 <glen_quagmire> oh i see
08:14:51 <dancor> glen_quagmire: yeah but i woudn't do it for preldue
08:16:07 <byorgey> > (1 Prelude.+ 2) Prelude.* 4  -- yeesh
08:16:09 <lambdabot>  12
08:16:16 <glen_quagmire> Prelude. is composition?
08:16:20 <glen_quagmire> :t Prelude.
08:16:21 <lambdabot> parse error (possibly incorrect indentation)
08:16:44 <matthew-_> @type Prelude.(.)
08:16:45 <lambdabot> Not in scope: data constructor `Prelude'
08:16:53 <matthew-_> @type (.)
08:16:54 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:16:57 <mauke> > Prelude.show Prelude.. Prelude.length Prelude.$ "zomg"
08:16:57 <lambdabot>  "4"
08:17:18 <psi> hehe
08:17:48 <EvilTerran> ?type (Prelude..)
08:17:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:18:37 <EvilTerran> (yeah, those parentheses are in a weird place)
08:18:44 <matthew-_> yep.
08:19:48 <dancor> heh ppl are so unused to qualified that we don't know how to do the parens around it
08:20:08 <dancor> so much for real life good practice
08:21:04 <glen_quagmire> > (Prelude.product.(\x -> x))$(\x -> [1..3])1
08:21:06 <lambdabot>  6
08:23:11 <matthew-_> > (Prelude.product.Prelude.id)Prelude.$(\_->[1..3])1
08:23:12 <lambdabot>  6
08:23:42 <glen_quagmire> java!
08:24:37 <glen_quagmire> maybe composition should be \o  or o or <-> or @
08:25:05 <EvilTerran> but i don't like any of those...
08:25:19 <EvilTerran> qualification could use a different notation
08:25:21 <matthew-_> \cdot
08:25:41 <glen_quagmire> Prelude:product
08:25:48 <dancor> you can do o = (.)
08:26:04 <matthew-_> but not o = Prelude
08:26:20 <EvilTerran> import qualified Prelude as O --?
08:26:29 <matthew-_> no, first class modules
08:26:32 <dancor> O.o
08:26:37 <byorgey> haha
08:26:48 <EvilTerran> infix module names!
08:26:58 <EvilTerran> import qualified Foo as (:)
08:27:04 <glen_quagmire> > let o = (Prelude..) in (Prelude.product o Prelude.id) Prelude.$ (\_->[1..3])1
08:27:06 <lambdabot>  Couldn't match expected type `[a]'
08:27:10 <matthew-_> quite.
08:27:12 <EvilTerran> `o`
08:27:47 <dancor> alias o=ghc
08:27:59 <tester> can the fold function be used like a map? i want to do this using fold
08:28:19 <matthew-_> yep.
08:28:20 <tester> > map (+7) (map (^2) [1,2,3])
08:28:23 <lambdabot>  [8,11,16]
08:28:24 <mux> you can reconstruct a list in a fold
08:28:34 <mux> > foldl (flip (:)) [] "hello world"
08:28:36 <lambdabot>  "dlrow olleh"
08:28:54 <tester> i want to do this  map (+7) (map (^2) [1,2,3])
08:29:03 <tester> using fold
08:29:13 <EvilTerran> why?
08:29:15 <dancor> tester: what do you mean by that
08:29:32 <matthew-_> > foldr (\v acc -> (7 + v^2):acc) [] [1,2,3]
08:29:32 <lambdabot>  [8,11,16]
08:29:44 <EvilTerran> "do <blah> using fold" sounds like a homework question to me
08:30:01 <Toxaris> > foldr (:) [] [1, 2, 3] -- start with this, tester, and extend it
08:30:04 <dancor> sounds like a good way to subvert what was once easily parallelizable
08:30:05 <lambdabot>  [1,2,3]
08:30:46 <tcr> How are multiple guards called again? | foo <- bar, quux <- baz -> ...
08:31:04 <tester> nah, it was a mock test
08:31:36 <tester> i used the map verison, but i just wanted to know hoe to do it using fold
08:31:52 <doserj> well, map f = foldr (\x y -> f x : y) []
08:32:12 <tester> ok
08:32:23 <EvilTerran> tcr, you mean pattern guards?
08:32:25 <pjd> @pl \x y -> f x : y
08:32:25 <lambdabot> (:) . f
08:33:11 <EvilTerran> @pl \f ->  foldr (\x y -> f x : y) []
08:33:11 <lambdabot> flip foldr [] . ((:) .)
08:33:13 <tester> i want to create a function that removes duplicates from a list
08:33:25 <mauke> nub
08:33:26 <dancor> now it sounds like an interview question
08:33:34 <nomeata> Igloo: Im trying to build your ghc6.8 package from unsafe-haskell for i386 now. Do you want to put the then there as well?
08:33:43 <Toxaris> > nub [1, 3, 2, 1, 5, 4, 2, 1] -- like this one, tester?
08:33:47 <lambdabot>  [1,3,2,5,4]
08:34:07 <tester> what is nub?
08:34:28 <Toxaris> tester: a function that removes duplicates from a list
08:34:48 <EvilTerran> @type nub
08:34:49 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:34:51 <EvilTerran> @src nub
08:34:52 <lambdabot> nub = nubBy (==)
08:35:03 <EvilTerran> @src nubBy
08:35:03 <lambdabot> nubBy eq []             =  []
08:35:03 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
08:35:38 <tester> i just google it thanks, any simpler way?
08:35:49 <Toxaris> > Data.Set.toList . Data.Set.fromList $ [1, 3, 2, 1, 5, 4, 2, 1] -- a faster variant, but needs Ord
08:35:50 <lambdabot>  [1,2,3,4,5]
08:35:51 <tcr> EvilTerran: Right, thanks!
08:35:57 <EvilTerran> :)
08:36:06 <dancor> nub = "essence"
08:36:12 <EvilTerran> tester, i know a good way:
08:36:20 <Toxaris> tester: do you know http://haskell.org/hoogle/ ?
08:36:26 <EvilTerran> first, switch your brain on. then, think about how to solve the problem. then, solve it!
08:36:28 <EvilTerran> :)
08:36:39 <DRMacIver> Hm. Does anyone actually use Yi? :)
08:36:39 <pjd> the Feynmann algorithm
08:36:45 <dancor> DRMacIver: i tried once
08:36:48 <tester> nice
08:36:55 <tester> thanks
08:36:57 <dancor> i couldn't get syntax highlighting in the console version
08:37:01 <DRMacIver> Ah
08:37:03 <dancor> then i gave up
08:37:06 <DRMacIver> Heh
08:37:07 <pjd> Feynman, even
08:37:33 <EvilTerran> Toxaris, cunning; i prefer (map head.group.sort) for O(nlogn)
08:37:51 <dancor> then i found out there is python for vim, and i've been too lazy to go back
08:38:08 <DRMacIver> Ha ha. Ok. :)
08:38:37 <mcp_> Hi. Ive got this glorious type: data State s a = St (s -> (a,s))
08:38:47 <mcp_> i try to use it in: extract (St s_to_as) = fst.s_to_as
08:39:10 <mcp_> now the compiler says, the type of my expr is: State a b -> a -> b
08:39:23 <mcp_> where does the last 'a' come from?
08:39:46 <EvilTerran> pjd, heh, i guess so
08:40:10 <desegnis> mcp_: Read that as  State s a -> s -> a
08:40:19 <liyang> the `a' is the `s' in your data line.
08:41:10 <mcp_> but i think it should read: State a b -> b
08:41:24 <Toxaris> mcp_: that's not how (.) work
08:41:31 <liyang> mcp_: Control.Monad.State has the exact same types, and your extract is pretty much evalState. But I'm guessing that's not what you're trying to do here. :)
08:41:58 <mcp_> uh, so its the ".". ok, i assumed it just hands things through from right to left. I go reading on that
08:42:12 <Toxaris> mcp_: (fst . s_to_as) means: take an a, apply s_to_as to it to receive an (b, a), and extract the b by using fst
08:42:12 <EvilTerran> mcp_, why? extract takes one parameter, and returns the parameter of an St constructor; the parameter of the St constructor takes a parameter
08:42:26 <liyang> mcp_: if you have a function s_to_as :: s -> (a, s) -- and you want the a back out, you'd better give it an `s'. The function can't make one up out of thin air. :3
08:43:09 <liyang> @t (.)
08:43:12 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:43:14 <Toxaris> mcp_: the (.) just hands things through from right to left, but there have to be any things in the first place
08:43:19 <liyang> :t (.)
08:43:20 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:43:22 <mcp_> liyang, i thought i can pass that parameter when using my function. its called unbound or something
08:43:33 <quicksilver> mcp_: yes, exactly
08:43:42 <quicksilver> mcp_: and that's exactly what the type meant
08:43:47 <quicksilver> State s a -> (s -> a)
08:43:55 <quicksilver> mcp_: it returns a function (s -> a)
08:44:05 <quicksilver> which has one parameter "left" for you to provide.
08:44:06 <liyang> well, your extract in that case will need to invent a state (your `s') out of thin air then, and give it to s_to_as.
08:44:11 <liyang> (which it can't do.)
08:44:16 <quicksilver> mcp_: that's your "pass that parametere when using"
08:44:23 <quicksilver> mcp_: the "s" is left over to "pass when using"
08:44:28 <mcp_> thanks, understood
08:44:31 <quicksilver> mcp_: so what you first thought, was the right though :)
08:44:37 <quicksilver> it's just hte notation of the type which is confusing.
08:44:41 <liyang> (what quicksilver said.)
08:44:57 <liyang> Brackets to the right.
08:45:01 * liyang loves Indian food.
08:45:14 <Sizur> does it take time for newtype A = A String; A "a"? i mean the construction itself, does it need time?
08:45:23 <quicksilver> Sizur: no
08:45:29 <quicksilver> Sizur: newtypes are defined to have zero runtime cost
08:45:36 <quicksilver> Sizur: they are all compiled away.
08:45:45 <quicksilver> they're just a convenient fiction for the type checker :)
08:45:47 <Sizur> quicksilver: then my Homomorphism that you saw earlier take no time?
08:45:57 <quicksilver> should do, yes
08:46:00 <quicksilver> it should inline away
08:46:05 <quicksilver> with appropriate optimsation options.
08:46:18 <liyang> They do prevent some compiler optimisations though, from what I have experienced second-hand. :-/
08:46:30 <EvilTerran> running time is implemation-dependent, of course ;)
08:46:35 <liyang> (I might have gotten this totally wrong.)
08:46:48 * desegnis has forgotten again what's the difference between  newtype A = A String  and  data A = A !String.
08:46:50 <quicksilver> liyang: depends on inlining. there are circumstances where they might, yes.
08:46:58 <quicksilver> desegnis: mainly this point being discussed.
08:47:09 <quicksilver> desegnis: newtype is guaranteed to have the same runtime repr.
08:47:23 <quicksilver> desegnis: data might not do. Although you could argue it ought to, if it's strict.
08:47:30 <liyang> quicksilver: yup. My usual approach is ``Bugger this, I'll newtype it anyway. Just wait until the next ICFP and the performance issues will be sorted.''
08:47:31 <EvilTerran> desegnis, for the first one, (case undefined of A _ -> "ok") works
08:47:45 <EvilTerran> desegnis, and, for the second one, it breaks
08:47:58 <Sizur> but newtypes are limited to only one type argument, right?
08:48:03 <desegnis> hmmm
08:48:06 <Toxaris> EvilTerran: you missed the "!"?
08:48:06 <EvilTerran> only one value argument
08:48:11 <quicksilver> Sizur: I think they can have any number of type arguments
08:48:11 <Sizur> no i'm wrong they are not
08:48:16 <EvilTerran> Sizur, they can have many type arguments
08:48:18 <quicksilver> Sizur: only one constructor argument though, yes
08:48:19 <EvilTerran> @src State
08:48:19 <lambdabot> Source not found. Take a stress pill and think things over.
08:48:31 <Toxaris> EvilTerran: Or I missed the meaning of the "!"
08:48:32 <EvilTerran> @src runState
08:48:32 <lambdabot> Source not found.
08:48:32 <liyang> Sizur: yup. At runtime they are indistinguishable from the underlying type.
08:48:58 <EvilTerran> Toxaris, the ! goes in datatype declerations
08:49:04 <liyang> (which is just another way of saying they are compiled away.)
08:49:05 <Toxaris> EvilTerran: Or I missed your point (wich seems most likely)
08:49:29 <EvilTerran> ! in patterns is an extension, and completely irrelevant to the distinction between a datatype with a strict parameter and a same-shaped newtype
08:50:11 <roconnor> @bab nl en vergelijkingen
08:50:12 <lambdabot>   comparisons
08:50:22 <Toxaris> EvilTerran: sorry, I see now what you're talking about. your code is equivalent to case undefined of _ -> "ok" because A is not part of pattern matching
08:50:33 <EvilTerran> in the newtype case, yes
08:51:24 <dozer> > [a | Just a <- [Just "pig", Nothing, Just "dog"]]
08:51:25 <lambdabot>  ["pig","dog"]
08:51:33 <desegnis> quicksilver, your point seems to refer to an implementation detail (which is of not too much interest to the programmer). EvilTerran, so lazy data constructors, strict data constructors and newtype constructors all have different semantics wrt strictness, and I shall remember them all! ;-/
08:51:46 <dozer> ah sweet - so list comprehension 'silently' ignores patterns that don't match?
08:51:48 <EvilTerran> http://haskell.org/haskellwiki/Newtype
08:52:11 <mux> dozer: it calls "fail" as usual, but since fail = [] in the list monad...
08:52:15 <mux> you get the picture
08:52:21 <desegnis> EvilTerran, you're right, I may look them up instead
08:52:23 <mux> btw, this function you wrote was catMaybes
08:52:30 <mux> > catMaybes [Just "pig", Nothing, Just "dog"]
08:52:31 <Cale> desegnis: The semantics of newtype are easiest to remember using that implementation detail as a guide, I find.
08:52:34 <liyang> dozer: not quite. The fail method returns []. And pattern non-matches in monads call fail.
08:52:41 <lambdabot>  ["pig","dog"]
08:53:05 <Syzygy-> mux: Dang you for being quicker than me!
08:53:05 <desegnis> Cale, I see. I just pretend the newtype constructor not to be there
08:53:13 <dozer> sweet - I can replace a load of realy truly ugly code with nested cases, concatMap and nested folds/maps with readable comprehensions then
08:53:30 <mux> Syzygy-: :)
08:53:34 <Cale> desegnis: Well, yeah, that's essentially the same as what quicksilver said :)
08:53:46 <liyang> (This trick can be successfully used to write some totally incomprehensible programs, when cooking up your own custom monad.)
08:54:04 <mux> don't tempt me!
08:54:06 <desegnis> Cale, right
08:54:15 * EvilTerran really likes the failed pattern matches bit of list comprehensions
08:54:31 <dozer> is there any plan to extend the list comprehension syntax over any monad that is mappable, foldable, or whatever is needed to simulate binding and filtering?
08:54:31 <EvilTerran> (altho isn't so font of them in do{} notation, the requirement for fail in Monad, etc)
08:54:51 <Cale> dozer: That was in Haskell 1.4, but they removed it :(
08:55:01 <dozer> Cale: ouch!
08:55:03 * mux wants monad comprehensions, with orderby and groupby :)
08:55:16 <Saizan> dozer: you only need MonadPlus
08:55:17 <dozer> apparently, mux wants sql in haskell
08:55:23 <Syzygy-> Just emailed the journal referee who got my papers in August and asked him what was going on.
08:55:32 <Syzygy-> Turns out he cannot find a referee for my Haskell paper.
08:55:34 <desegnis> dozer, speaking of which, there should be a plan to draw  fail  out of the Monad class into a MonadFail class.
08:55:39 <mux> dozer: I've been reading that spj's paper where he implements them for ghc =)
08:55:47 <dozer> desegnis: that would make me happy
08:56:19 <liyang> mux: has he actually implemented it? I thought that was Wadler's pet project.
08:56:24 <byorgey> Syzygy-: =(
08:56:26 <liyang> (and not in GHC.)
08:56:55 <Syzygy-> byorgey: It's on Haskell for the working operadic homological algebraist interested in associahedral representations and diagonals.
08:57:11 <Syzygy-> So it seems the complete set of people who really grok what I'm doing has cardinality 1.
08:57:17 <byorgey> Syzygy-: heh... apparently you're the only one so far?
08:57:20 <byorgey> right. =)
08:57:37 <mux> liyang: mmm, maybe not really implemented, but at least he gave solid clues on how to implement it; I can't really remember
08:57:38 <Syzygy-> If you drop Haskell, there's a significant community around it.
08:57:42 <Syzygy-> The same if you drop the algebra.
08:57:43 <Syzygy-> But ...
08:57:48 <matthew-_> in general, you can't tell when two functions are equivalent can you? - it reduces to halting problem really doesn't it?
08:57:57 <matthew-_> (statically)
08:58:13 <dbueno> matthew-_: Even dynamically, it reduces to the halting problem.
08:58:16 <dozer> matthew-_ yeah - for arbitray functions, you are screwed
08:58:19 <mux> you can't prove it in general, but you can prove it for specific cases
08:58:32 <liyang> mux: I think it hints at a translation from orderby and groupby to Ordinary Haskell. I'm still convinced it's a bad idea.
08:58:32 <DRMacIver> matthew-_: I've seen a funny esolang based on providing an equality primitive for functions though... :)
08:58:33 <mux> alpha-equivalence, eta-equivalence
08:58:44 <matthew-_> yep. ok.
08:58:48 <Syzygy-> I'd be much more interested in "When are two functions homotopic" for a reasonable interpretation of homotopy.
08:59:02 <DRMacIver> f == g until you find a counterexample, at which point you backtrack to the first point you compared them for equality and rerun the program from there.
08:59:06 * dozer wonders what homotopy is
08:59:23 <DRMacIver> dozer: Syzygy- is just being a crazy algebraist. ;)
08:59:25 <Syzygy-> dozer: Do you -really- want me to answer that question? Please set a verbosity flag. ;)
08:59:34 <Syzygy-> DRMacIver: HOMOLOGICAL algebraist, if you please.
08:59:41 * dozer does a lot of idle wondering
08:59:44 <DRMacIver> Oh, I beg your pardon.
08:59:51 * EvilTerran wonders if homological means crazy
08:59:55 <DRMacIver> dozer: Syzygy- is just being a flat out insane algebraist.
08:59:57 <Syzygy-> EvilTerran: It's not that -far- from it.
08:59:58 <liyang> Syzygy-: is this related at all to what Martin Escardo does?
09:00:13 <Syzygy-> liyang: YEah.
09:00:16 <roconnor> dozer: two curves are homotopic if they can be continuously deformed from one to the other.
09:00:26 <Syzygy-> It's basically exactly what he does - from what a 10 second scan of his website says.
09:01:09 <dozer> ok, so how does this relate to discrete functions? there is an isomorphic mapping between their input/output pairs?
09:01:16 <Syzygy-> There was a bizarre paper a while back by Voevodsky about homotopy in lambda calculus
09:01:17 * liyang went to his Operational domain theory and topology course a year ago. Not that he learnt anything applicable, but at least he's figured out what he doesn't know.
09:01:33 <Syzygy-> liyang: You want -applicable-? Yeeesh!
09:01:55 <liyang> heh. Maybe that's too much to ask.
09:02:12 <liyang> (I usually apply things to dead, pulped trees.)
09:02:35 <liyang> (which is what I meant with `apply' there.)
09:02:37 * roconnor tries to read back for the context of dozer's question
09:05:08 <Syzygy-> roconnor: Halting problem ~=~ recognition of identity of two functions.
09:05:16 <Syzygy-> Followed by me asking for homotopy instead of functional equatliy.
09:05:19 <Syzygy-> *equatlity
09:14:49 <nailz> malcolmw: is it easy to get garbage collection time of nhc98 programs?
09:16:09 <haskellmasala> hello
09:18:34 <haskellmasala> grahamhutton, are you the guy who wrote the book?
09:18:48 <grahamhutton> yes, that's me.
09:19:19 <haskellmasala> grahamhutton. oh this is cool. I saw your slides. You explain haskell very well.
09:19:58 <grahamhutton> many thanks --- it's a great language to do teaching and research with
09:20:34 <grahamhutton> if you like the slides, i hope you bought the book too :-)
09:21:37 <grahamhutton> a great Xmas present for programmers everywhere! ;-)
09:21:38 <haskellmasala> grahamhutton: I'm kind of getting sick of my Java job that uninspire me. so I thought I could study algorithms and do my own scientific research in Haskell in order to keep my "scientific" spirit alive...
09:22:13 <haskellmasala> grahamhutton: I was going to buy your book on Amazon for christmas, if you have a link with your referral id, you'll get more out of it.
09:24:03 <grahamhutton> i don't have any referral programs, so just go for wherever you can get it cheapest
09:24:26 <haskellmasala> I actually have a question. The slides are great, but will the book just be a slight expansion of the slides or will there be more "meat" to it?
09:25:37 <grahamhutton> the slides were made to support the book in teaching; the book itself gives the full details.
09:25:49 <haskellmasala> oh that's great
09:26:05 <haskellmasala> would you recommend any other book on top of it to dig deeper?
09:26:40 <ricky_clarkson> @google graham hutton haskell amazon
09:26:43 <lambdabot> http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695
09:27:43 <tttz> I wonder how much it costs to make a hardcover text.
09:27:44 <grahamhutton> it depends what you want to do - if you want to learn about writing real-world programs in Haskell, there are a number of books in the pipeline that address this; if you want to learn about more theoretical topics, there are books that do this too.
09:27:57 <ricky_clarkson> So what does yours do? ;)
09:28:40 <ricky_clarkson> So far I'd recommend SICP to anyone interested in [functional] programming, except that it doesn't cover monads, for obvious reasons.
09:28:47 <grahamhutton> it's about teaching the basic principles of programming in Haskell, in a way that is as easy and accessible as possible.
09:29:29 <grahamhutton> it's primarily aimed at 1st year University students, but I also have a hidden agenda that it can be used for school kids :-)
09:29:40 <loupgaroublond> you could always do the scheme intepreter in 48 hours, in haskell, and then use that to practice whatis in SICP
09:31:34 <ricky_clarkson> And from there implement a Haskell to Parrot compiler which uses C for I/O, of course.
09:32:08 <loupgaroublond> of course
09:32:49 <earthy> graham's book is actually at a 10% discount at the store next door, currently
09:32:57 <earthy> not that that means I know the price... ;)
09:33:29 <ricky_clarkson> grahamhutton: I admire anyone who tries to make what people think of as hard not.
09:34:23 <grahamhutton> ricky_clarkson: that was my primary aim when writing the book!
09:43:19 <andy_> Has anyone thought about phantom-typing Template Haskell (well you know, the metaocaml idea, just single-staged)? I recently started sketching out an implementation.
09:45:17 <dcoutts> andy_: yes and things more sophisticated, see Igloo's PhD thesis
09:45:53 <andy_> dcoutts: yes i know about it, but i wanted to get some typing soon. ^^
09:46:46 <dcoutts> andy_: the downside of that kind of typing is that you loose some of the power of TH
09:47:07 <andy_> dcoutts: yeah, but you stay within the power of metaocaml, thats enough for me.
09:47:15 <dcoutts> andy_: you could probably replace the constructor wrappers with phantom typed versions
09:47:21 <andy_> im just about porting the state-of-the-art-Oleg-hackery. ^^
09:47:23 <dcoutts> and keep basically the same api
09:47:56 <andy_> Well im orienting towards metaocaml as you might have guessed by now. :>
09:48:08 <andy_> So the API is essentially Olegs.
09:48:30 <andy_> You know the MetaMonad Paper.
09:48:45 <edwinb> what's the MetaMonad paper?
09:49:25 <andy_> http://www.cas.mcmaster.ca/~carette/metamonads/index.html
09:49:25 <lambdabot> Title: Multi-stage programming with functors and monads: eliminating abstraction overhe ...
09:49:27 <edwinb> surely I haven't missed some crazy Olegery ;)
09:49:39 <andy_> Hehe.
09:51:43 <andy_> I think there are some benefits in Olegs metaocaml-based-approach, at least compared to the current TH-situation, thats why i oriented in that direction.
09:52:14 <andy_> And not much power to be lost, just needs more CPS-wizardry. ^^
09:52:32 <edwinb> well, they're differently powerful
09:53:03 <andy_> edwinb: yes, you cant inspect code for one.
09:53:16 <andy_> But why inspect code when you can generate it just right? ;>
09:54:34 <haskellmasala> do you know where can I buy Hutton's book or any other Haskell book in PDF format?
09:54:59 <opqdonut> ?djinn-env
09:54:59 <lambdabot> data () = ()
09:54:59 <lambdabot> data Either a b = Left a | Right b
09:55:00 <lambdabot> data Maybe a = Nothing | Just a
09:55:00 <lambdabot> data Bool = False | True
09:55:00 <lambdabot> data Void
09:55:01 <lambdabot> type Not x = x -> Void
09:55:04 <andy_> From my standpoint it looks like theres something to be learned from the metaocaml-approaches so i just want a testbed if you will.
09:55:04 <lambdabot> class Eq a where (==) :: a -> a -> Bool
09:58:33 <liyang> haskellmasala: I'm pretty sure you can't. :-/
09:58:45 <osfameron> > printf "%04d" (23::Int)
09:59:01 <lambdabot>  thread killed
09:59:09 <osfameron> eeek!
09:59:22 <oerjan> that's weird
09:59:23 <osfameron> I get it as type: printf "%04d" (23::Int) :: (PrintfType (Int -> t)) => t
09:59:35 <oerjan> > printf "%04d" (23::Int)
09:59:37 <lambdabot>  Add a type signature
09:59:43 <osfameron> so I can't print it for example
09:59:45 <oerjan> > printf "%04d" (23::Int) :: String
09:59:46 <lambdabot>  "0023"
09:59:49 <osfameron> ah
10:00:12 <osfameron> so String is a PrintfType ?
10:00:12 <oerjan> osfameron: that type class includes String and IO () as instances
10:00:23 <osfameron> ah!
10:00:40 <mauke> > printf "%04d" 23
10:00:40 <lambdabot>  Add a type signature
10:00:45 <osfameron> this is one of those odd things that is actually harder in ghci than you'd imagine
10:00:49 <mauke> > ""++ printf "%04d" 23
10:00:51 <lambdabot>  "0023"
10:00:53 <oerjan> @instances-importing Text.Printf PrintfType
10:00:53 <lambdabot> (a -> r), IO a, [c]
10:01:13 <osfameron> oh!  You idn't have to do (23::Int) there?
10:01:31 <mauke> no
10:01:44 <oerjan> it defaults to Integer
10:01:52 <oerjan> at least with extended defaulting
10:02:08 <mauke> > ""++ printf "%04c" 23
10:02:09 <lambdabot>  "000\ETB"
10:02:10 <osfameron> ok.  I may be confusing myself
10:02:17 <mauke> > ""++ printf "%04c" 0x23
10:02:18 <lambdabot>  "000#"
10:02:23 <osfameron> I'm sure I've seen some situation where I had to be explicit with Int type
10:02:57 <oerjan> lambdabot has extended defaults turned on, it's just about the only extension allowed in >
10:03:13 <oerjan> without those, only a few classes can be defaulted
10:03:31 <oerjan> PrintfType is not one of them
10:03:53 <oerjan> er, that would be PrintfArg for that 23
10:04:59 <oerjan> and anyway, the default default is (Integer,Double) so you still won't get Int
10:06:04 <oerjan> (see default declarations in the report)
10:10:22 <osfameron> PrintfType is a very odd one
10:10:48 <oerjan> yep, it includes the hackery to support variable argument number
10:11:27 <oerjan> (with that (a -> r) instance)
10:11:34 <osfameron> is that something anyone can do?  or baked into ghci?
10:11:47 <oerjan> as well as for being able to output both into String or to stdout
10:12:00 <oerjan> it's very portable i believe
10:12:04 <Saizan> Test.Printf is pure haskell98
10:12:09 <Saizan> *Text
10:12:39 <osfameron> ok, I was wondering what "hackery" meant in this case
10:12:52 <oerjan> just cleverness :)
10:13:17 <oerjan> type hackery is a technical term around these parts :)
10:13:48 <oerjan> (with its own unit of measure)
10:14:04 <oerjan> @quote milli-oleg
10:14:04 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
10:14:42 <jimstutt> oerjan: how many milli-olegs in a parsec?
10:15:09 <oal`> meh. uncompatibe physical units?
10:15:24 <oal`> * uncompatible
10:15:31 <oerjan> i don't think Parsec is that advanced, just a monad?
10:15:42 <oerjan> of course that is still more than in most languages
10:15:46 <oal`> eh.
10:16:11 <jimstutt> oerjan: so I can even learn something from then quips :)
10:16:12 <oal`> i though about parsec as in one light year
10:16:14 * osfameron is wondering if his little problem will require type hackery.
10:16:29 <osfameron> probably not, though I think I'd like first class labels for record types
10:16:57 <Saizan> those require HList :)
10:17:22 <osfameron> oh, that does it?
10:17:22 <oerjan> oal`: i know, i just ran with it
10:18:13 <oerjan> i guess HList's are like the uncurrying of Printf ... tuples vs. arguments
10:19:01 <Saizan> first class labels? yeah, but things like FRef could also work for you?
10:19:21 <Saizan> HList labels are more interesting if you need extensible records
10:19:35 <tindrum> so, I hear you're not rude to noobs here
10:20:05 <oerjan> hm, actually i haven't looked much at HList's, i didn't know it had labels
10:20:16 <tindrum> what's a good haskell website? general, basic stuff
10:20:22 <oerjan> tindrum: haskell.org
10:20:35 <Saizan> ?google haskell wikibook
10:20:36 <lambdabot> http://en.wikibooks.org/wiki/Programming:Haskell
10:20:36 <lambdabot> Title: Programming:Haskell - Wikibooks, collection of open-content textbooks
10:22:18 <Saizan> oerjan: labels are implemented as names for an index
10:22:48 <mrd> tindrum: sorry. we can emulate rudeness to noobs if you like.
10:23:15 <oerjan> tindrum: i believe being rude to noobs is actually a bannable offense here.
10:24:19 <oerjan> *offence?
10:24:29 <mrd> depends if you're English
10:24:53 <ricky_clarkson> oerjan: Excellent.
10:25:06 <oerjan> oh, it's a US/UK thing.
10:26:32 <loupgaroublond> canadian? :P
10:27:07 <oerjan> US/rest of English speaking world?
10:27:58 <oerjan> actually i am not sure what Canadians do.  or Australians etc.
10:28:02 <loupgaroublond> canadians have their own rules too
10:28:30 <loupgaroublond> not sure about australians
10:29:30 <trontonic> two kinds of english should be enough: simplified and complete :)
10:29:53 <oerjan> completificated
10:29:53 <loupgaroublond> good luck getting everyone to compromise on the spelling
10:29:54 <mrd> crazy vs insane
10:30:59 <dylan> .. are synonyms.
10:31:01 <byorgey> loupgaroublond: I think you meant 'compromize'.
10:31:04 <dylan> (here, anyway)
10:31:25 <loupgaroublond> compromise :P, unless you mean finalize
10:31:32 <trontonic> if both compromize and compromise was allowed in the "complete" version of english, there shouldn't be a problem? :)
10:31:36 <byorgey> it was a joke =)
10:31:42 * loupgaroublond had to check a spell checker on that one actually
10:31:56 <trontonic> byorgey: I found it funny :)
10:32:04 <byorgey> trontonic: thanks =)
10:32:16 <oerjan> always cheque your spelling
10:32:17 <mrd> dylan: don't tell that to the lunatics!
10:32:31 <byorgey> 'compromise' is one of the few words that actually is spelled -ise in US english, I think...
10:32:34 <dylan> mad vs. angry is fun.
10:32:52 <ricky_clarkson> @bab es en compromiso
10:32:52 <lambdabot>   commitment
10:33:05 <dylan> yay false friends.
10:33:18 <loupgaroublond> afrikaans and dutch are pretty much as far apart as english and american anyways, and since they are on other sides of the world, they don't seem to have too many problems with it either
10:33:54 <dylan> I wonder, how do you express compromise in spanish?
10:34:19 <ricky_clarkson> You do not compromise. ;)
10:35:07 <andy_> Is someone doing cache-oblivious algorithms (or the like) in Haskell? I started to wonder wether its actually possible to get good results in the presence of GC. Perhaps a region-based strategy would win here?
10:35:55 <oerjan> @bab en es compromise
10:35:55 <lambdabot>   compromiso
10:36:09 <dylan> that's not right.
10:36:36 <ricky_clarkson> @bab en es let's reach a compromise on this
10:36:36 <lambdabot>   alcancemos un compromiso sobre esto
10:37:14 <ricky_clarkson> It might be right for es_ES, because Google uses docs from the EU for its translation.
10:37:26 <mrd> @bab es en alcancer
10:37:26 <lambdabot>   to alcancer
10:37:45 <ricky_clarkson> @bab es en alcancemos
10:37:54 <lambdabot>   let us reach
10:38:12 <loupgaroublond> @bab en es to compromise
10:38:12 <lambdabot>   al compromiso
10:38:16 <mrd> @bab es en alcancir
10:38:17 <lambdabot>   to alcancir
10:38:29 <ricky_clarkson> The 'to' form of verbs doesn't appear very often in random text.
10:38:40 <ricky_clarkson> ..that's probably why babelfish is useless for them.
10:38:45 <mrd> quiero alcancer
10:39:04 <loupgaroublond> ah, used to doing that for other languages
10:39:19 <mrd> infinitivos!
10:39:42 <loupgaroublond> das Infinitiv ;)
10:55:48 <cippo> hey guys, i'm kinda new to haskell and have a little problem. http://nopaste.com/p/aIkfGSkA <-- code + compiler error
10:55:57 <cippo> guess i'm not getting something about IO :)
10:56:31 <oerjan> needs to be gimmeline :: IO String
10:56:40 <oerjan> well, actually
10:56:52 <oerjan> gimmeline = getLine the way you have defined it
10:57:01 <oerjan> except it has the wrong type
10:57:35 <oerjan> the fundamental thing about IO is that you _cannot_ make a function that uses IO internally without it showing up in its result type
10:57:36 <cippo> if i just use getLine directly i get     Couldn't match expected type `String'
10:57:36 <cippo>            against inferred type `IO String'
10:57:59 <monochrom> And if you force gimmeline to String you get an equivalent error.
10:58:15 <Cale> cippo: I have a short article on how you should think about IO
10:58:28 <Cale> cippo: http://haskell.org/haskellwiki/Introduction_to_IO
10:58:29 <monochrom> So the only logical exit is to agree with IO String.
10:58:36 <oerjan> yep, readLines assumes your impossible gimmeline function
10:58:39 <cippo> oh, nice Cale.
10:59:01 <cippo> oerjan, but reads seem to be expecting a String?
10:59:08 <Cale> cippo: Note that you've claimed in your program that gimmeline is a String, but then, what string is it?
10:59:39 <oerjan> cippo: yep, you need to rewrite readLines
10:59:39 <Cale> cippo: If it was really a String, you'd be able to tell at compile time which string it actually was.
10:59:46 <monochrom> do { a <- getLine; ... reads a ... }
11:00:03 <cippo> hmm, okay, i'll try that
11:00:24 <monochrom> 'a' is String. getLine is not String.
11:00:42 <Cale> But yeah, read my intro, since it's short and perhaps will help to give you the right idea :)
11:01:02 <cippo> okay, i will cale =)
11:01:22 <Cale> cippo: The main point about IO in Haskell is that we manage it by constructing values which describe things to be done -- IO actions
11:01:39 <monochrom> Wouldn't it be nice if tangible values were the standard of Haskell interaction? :)
11:02:43 <Cale> A value of type (IO String) is like a description of a program which when eventually run, will produce a String, but normal Haskell evaluation won't run it.
11:03:48 <cippo> hmm, right
11:04:45 <Cale> But you have various ways to combine these actions into larger ones -- including ways to include pure computations in them.
11:05:11 <Cale> and eventually, the 'main' of your program is such an action, which the RTS evaluates and then executes
11:05:20 <Botje> Syzygy-: I read your post about rails pluralization, turns out it pluralizes to "indices". you can test it yourself with irb-rubygems -ractive_record, just type in "index".pluralize
11:05:30 <Botje> *irb -rubygems
11:06:03 <quest> can the pred and succ function be used to create a multiplication & div function without using - + / *
11:06:06 <quest> ???
11:06:51 <Botje> quest: yes.
11:06:58 <quest> how?
11:07:04 <Botje> quest: first you define + in terms of pred and succ
11:07:11 <Botje> then you do the same thing for * in terms of +
11:07:13 <quest> ???
11:07:39 <roconnor> a + 0 = a
11:07:44 <quest> succ (pred x)
11:07:50 <roconnor> a + b = (succ a) + (pred b)
11:07:57 <quest> > succ (pred 1)
11:08:00 <lambdabot>  1
11:08:29 <monochrom> use recursion
11:08:35 <quest> i cannot use the + - / or * signs
11:08:44 <cippo>  17 readLines a = do {
11:08:44 <cippo>  18                    b <- getLine
11:08:44 <cippo>  19                    listToTuple (parseLine (reads b)) : readLines (a - 1)
11:08:44 <cippo>  20                  }
11:08:49 <cippo> (Sorry for pasting)
11:08:54 <cippo> i tried that instead
11:09:00 <cippo> but got set.hs:18:19:
11:09:01 <cippo>     The last statement in a 'do' construct must be an expression
11:09:01 <monochrom> then don't use the + sign. use the word "add". your definition.
11:09:44 <Saizan> cippo: if you don't use layout you need to end every line in a do with ;
11:09:46 <monochrom> add a 0 = a, add a b = succ a `add` pred b
11:09:56 <cippo> Saizan, oh :)
11:10:14 <cippo> ah, now i got an even longer error =)
11:10:23 <Saizan> cippo: and you'd get others type error on the second line
11:10:25 <Saizan> heh
11:10:53 <monochrom> return (listToTuple (parseLine (reads b)) : readLines (a - 1)) ?
11:11:01 <Saizan> readLines returns an IO [Something]
11:11:15 <Saizan> so you need to use it with <- like getLines
11:11:24 <Saizan> "getLine"
11:11:26 <monochrom> Oh I see.
11:11:42 <quest> @?
11:11:52 <quest> @help
11:11:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:12:11 <monochrom> do { b <- getLine; more <- readLines (a-1); return (listToTuple (parseLine (reads b)) : more) }
11:13:42 <cippo> do i need to add IO somewhere in the definition of readLines ?
11:14:09 <monochrom> Yes. What Saizan says.
11:15:05 <oossoo> What does '@' mean in Haskell?
11:15:42 <bos> oossoo: bind the contents of the pattern on the right under the name on the left
11:15:55 <luqui> let foo all@(x:xs) = (all,x,xs) = [1,2,3,4,5]
11:15:57 <monochrom> case Just 0 of x@(Just y) -> y is now 0, x is now Just 0.
11:16:01 <luqui> > let foo all@(x:xs) = (all,x,xs) = [1,2,3,4,5]
11:16:01 <lambdabot>  Parse error at "=" (column 33)
11:16:08 <luqui> > let foo all@(x:xs) = (all,x,xs) in [1,2,3,4,5]
11:16:10 <lambdabot>  [1,2,3,4,5]
11:16:17 <luqui> uh i'm being dumb
11:16:20 <luqui> > let foo all@(x:xs) = (all,x,xs) in foo [1,2,3,4,5]
11:16:20 <lambdabot>  ([1,2,3,4,5],1,[2,3,4,5])
11:16:24 <luqui> there we go
11:16:29 <cippo> nice, thanks guys! :)
11:16:32 <cippo> that made it work
11:16:36 <cippo> and made my a tiny bit smarter
11:16:39 <cippo> *me
11:17:50 <quest> can i use the wxwidgets manual to help learn wxhaskell?
11:18:00 <quest> can't find enough doc on it
11:18:20 <monochrom> @quote answered
11:18:21 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
11:18:24 <monochrom> @quote answered
11:18:24 <lambdabot> dmwit says: Welcome to #haskell, where we answered your question yesterday.
11:18:35 <therp> nice quotes
11:18:56 <monochrom> They lost my fugues quote?!
11:19:16 <oerjan> @quote fugue
11:19:17 <lambdabot> No quotes match. The more you drive -- the dumber you get.
11:19:24 <monochrom> Welcome to #haskell, where your questions are answered in contrapuntual fugues.
11:19:33 <ricky_clarkson> @quote oleg
11:19:33 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
11:19:36 <oerjan> lambdabot loses everything recently.
11:19:38 <ricky_clarkson> @quote oleg
11:19:38 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
11:19:39 <monochrom> (Last time I spelt "counterpunctual")
11:20:34 <mikael> are there monopuntal fugues?  also is "monopuntal" a word?
11:20:41 <monochrom> But I like yesterday :)
11:21:08 <ski> copunctual fugues
11:22:00 <luqui> of course, all the great composers knew how to write perfect copoint
11:22:31 <oerjan> luqui: don't you mean the great decomposers?
11:22:37 <luqui> ugh
11:22:53 <monochrom> I can't spell contrapuntal.
11:23:25 <oerjan> @spell contrapuntal
11:23:33 <oerjan> @bot
11:23:34 <lambdabot> :)
11:23:43 <oerjan> neither can lambdabot
11:23:45 <monochrom> I kept spelling it as contrapuntual. :)
11:23:53 <luqui> I always thought it was contrapunctal
11:23:59 <monochrom> me too.
11:24:08 <oerjan> er you mean it actually _is_ contrapuntal?
11:24:13 <monochrom> co-composers write co-points.
11:24:15 <luqui> without the u toward the end, mind you...
11:24:27 <monochrom> Yes! contrapuntal! totally ridiculous!
11:24:29 <luqui> but a cocomposer is just an mposer, right?
11:24:32 <oerjan> mposers too
11:25:04 <monochrom> Makes me think of contra-nuptal. or something.
11:25:43 <luqui> hmm... that makes me thing
11:25:46 <luqui> *think
11:25:51 <luqui> I'm going to write Haskell using cocomonads
11:25:57 <luqui> they are tastier than regular monads
11:26:07 <monochrom> We're going coconuts.
11:26:16 <SamB_XP_> so composers write ntrapuntal stuff?
11:26:38 <luqui> wow.
11:26:50 <oerjan> ah, via italian contrappunto
11:27:10 <monochrom> counterpoint. contrapuntal.
11:27:27 <oerjan> italian does such things.
11:28:05 <luqui> not like english!
11:28:24 <monochrom> Ordinary mathematicians go nuts. Categorical mathematicians go coconuts.
11:28:28 <SamB_XP_> luqui: smartass!
11:28:53 <SamB_XP_> monochrom: I think going nuts is tastier, personally
11:29:10 <ricky_clarkson> What's the 'oneness' in monad?
11:29:15 <ricky_clarkson> mon suggests oneness.
11:29:25 <oerjan> from monoid
11:29:32 <oerjan> monoid + triad, i hear
11:29:58 <ricky_clarkson> @go monoid wikipedia
11:29:59 <lambdabot> http://en.wikipedia.org/wiki/Monoid
11:29:59 <lambdabot> Title: Monoid - Wikipedia, the free encyclopedia
11:30:06 <oerjan> a monoid can be considered a category with just one object
11:30:11 <SamB_XP_> wow category theorists are bad at namings
11:30:42 <oerjan> may be a backformation
11:31:42 * SamB_XP_ loves to play backronyms
11:32:01 <monochrom> Yeah. objects, arrows, natural, ... only the OOP people beat them.
11:32:04 * SamB_XP does not love underscores
11:32:22 <SamB_XP> monochrom: "arrows" are well named
11:32:48 <SamB_XP> if you mean those things that have heads
11:32:57 <SamB_XP> otherwise ... no.
11:33:07 * SamB_XP remembers about Arrow :-(
11:33:20 <luqui> I still don't know what a natural transformation is, which indicates its name is not so accurate.
11:33:21 <monochrom> their arrow = morphism. no head.
11:33:24 <luqui> (or I'm just dense)
11:33:27 <luqui> (with limits)
11:33:54 * SamB_XP wonders if you can integrate dense things with limits
11:33:56 <monochrom> Are you also with co-limits?
11:45:11 <Taejo> do I remember lambdabot having a multilingual dictionary feature?
11:45:55 <byorgey> Taejo: it has an interface to babelfish.
11:46:11 <byorgey> @babel en es dictionary
11:46:13 <Taejo> how does one access it?
11:46:18 <Taejo> thx
11:46:21 <lambdabot>   diccionario
11:46:27 <Taejo> @babel es en mentida
11:46:28 <lambdabot>   lain
11:46:40 <Taejo> @babel po en mentida
11:46:40 <lambdabot> Plugin `babel' failed with: Error: Language po not supported
11:46:43 <ricky_clarkson> @bab es en mentira
11:46:44 <lambdabot>   lie
11:46:57 <ricky_clarkson> @bab es en mentirOSa
11:46:58 <lambdabot>   mentirOSa
11:47:20 <nolrai> @ty ap const
11:47:22 <lambdabot> forall a b. (a -> b) -> a -> a
11:47:29 <ricky_clarkson> @bab haskell en * -> *
11:47:29 <lambdabot> Plugin `babel' failed with: Error: Language haskell not supported
11:47:42 <Taejo> ricky_clarkson: thanks, that's the word I'm looking for
11:48:00 <ricky_clarkson> de nada
11:48:00 <Taejo> though I'm struggling to understand "todo es mentira en este mondo"
11:48:12 <ricky_clarkson> It's all a lie in this world.
11:48:22 <ricky_clarkson> mondo=mundo=world
11:48:25 <Taejo> thanks
11:50:38 <Taejo> the "lain" put me on the wrong track - I was thinking "lie" as in "lie down"
11:50:38 <ricky_clarkson> Do not lie down on the wrong track.
11:50:38 <Taejo> :)
11:52:09 <ricky_clarkson> > fix \x -> if (x<2) then (const 1) else (x*)
11:52:09 <lambdabot>  Parse error at "\x" (column 5)
11:52:21 <ricky_clarkson> > fix (\x -> if (x<2) then (const 1) else (x*))
11:52:23 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> t
11:52:23 <lambdabot>     Probabl...
11:52:41 <ricky_clarkson> Remind me, how do you get fix to do factorials?
11:52:58 <dylan> infinite list?
11:53:19 <ricky_clarkson> No, one will do.
11:53:46 <dylan> I mean, that's how, I think
11:54:01 <ricky_clarkson> hmm
11:54:03 <luqui> > fix \fact x -> if x < 2 then 1 else x*fact x
11:54:03 <lambdabot>  Parse error at "\fact" (column 5)
11:54:07 <luqui> > fix $ \fact x -> if x < 2 then 1 else x*fact x
11:54:09 <lambdabot>  <Integer -> Integer>
11:54:17 <luqui> > fix (\fact x -> if x < 2 then 1 else x*fact x) 10
11:54:18 <lambdabot>  Exception: stack overflow
11:54:20 <oerjan> > fix (\f x -> if (x<2) then 1 else x*f (x-1)) 5
11:54:20 <lambdabot>  120
11:54:23 <luqui> duh
11:54:52 <luqui> the > at the beginning of the line leaks brainpower into the aether...
11:55:28 <oerjan> @remember luqui the > at the beginning of the line leaks brainpower into the aether...
11:55:28 <lambdabot> It is stored.
11:55:32 <int-e> > scanl (*) 1 [1..] -- don't fix what ain't broken
11:55:32 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
11:55:40 <oerjan> soon forgotten, i guess
11:55:51 <ricky_clarkson> :t scanl
11:55:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
11:55:57 <ricky_clarkson> @src scanl
11:55:57 <lambdabot> scanl f q ls = q : case ls of
11:55:58 <lambdabot>     []   -> []
11:55:58 <lambdabot>     x:xs -> scanl f (f q x) xs
11:56:09 <andy__> @pl (\f x -> if (x<2) then 1 else x*f (x-1))
11:56:10 <lambdabot> ap (flip if' 1 . (< 2)) . ap (*) . (. subtract 1)
11:56:20 <andy__> hrhr
11:56:58 <andy__> @src if
11:56:58 <lambdabot> Source not found. Maybe you made a typo?
11:57:01 <andy__> @src if'
11:57:01 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:57:15 <dmwit> if' p x y = if p then x else y
11:57:24 <andy__> Ok, thought so.
11:57:37 <luqui> @index if'
11:57:37 <lambdabot> bzzt
11:57:42 <ricky_clarkson> I sometimes wish then wasn't a keyword.
11:57:47 <dylan> @src when
11:57:47 <lambdabot> when p s = if p then s else return ()
11:58:00 <oerjan> it's just @pl's way of getting around the lack of a function
11:58:10 <Taejo> dylan: that's handy
11:58:13 <oerjan> by inventing it
11:58:14 <ricky_clarkson> > let then=flip (.) in fst `then` snd ((1,2),(3,4))
11:58:14 <Taejo> @src unless
11:58:14 <lambdabot> unless p s = if p then return () else s
11:58:14 <lambdabot>  Parse error at "then=..." (column 5)
11:58:25 <ricky_clarkson> > let then'=flip (.) in fst `then'` snd ((1,2),(3,4))
11:58:25 <lambdabot>  Couldn't match expected type `a -> c'
11:58:31 <ricky_clarkson> > let then'=flip (.) in fst `then'` snd $ ((1,2),(3,4))
11:58:32 <lambdabot>  2
11:59:15 <luqui> hmmm
11:59:32 <luqui> > let f `then` g = g . f in fst `then` snd $ ((1,2),(3,4))
11:59:32 <lambdabot>  Parse error at "then`" (column 8)
11:59:40 <luqui> aww
11:59:45 <oerjan> > fst >>> snd $ ((1,2),(3,4))
11:59:46 <lambdabot>  2
12:02:01 <mauke> @hoogle [a] -> ([a], a)
12:02:02 <lambdabot> No matches, try a more general search
12:02:22 <oerjan> @hoogle [a] -> (a, [a])
12:02:23 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:02:23 <lambdabot> Data.List.mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:02:30 <ricky_clarkson> @src (>>)
12:02:30 <lambdabot> m >> k      = m >>= \_ -> k
12:02:32 <ricky_clarkson> @src (>>>)
12:02:32 <lambdabot> Source not found. It can only be attributed to human error.
12:02:39 <oerjan> @src Arrow
12:02:40 <lambdabot> class Arrow a where
12:02:40 <lambdabot>     arr, pure   :: (b -> c) -> a b c
12:02:40 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
12:02:40 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
12:02:40 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
12:02:42 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
12:02:43 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
12:03:49 <ricky_clarkson> :t \f g -> f >>> g
12:03:50 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
12:03:54 <oerjan> @src . >>>
12:03:55 <lambdabot> Source not found. Where did you learn to type?
12:04:02 <oerjan> @src (.) (>>>)
12:04:02 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:04:05 <oerjan> @src (.) >>>
12:04:05 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:04:11 <oerjan> @src . (>>>)
12:04:11 <lambdabot> Source not found. It can only be attributed to human error.
12:04:23 <BMeph> @remember monochron "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
12:04:23 <lambdabot> Good to know.
12:04:32 <BMeph> @bs
12:04:32 <lambdabot> Done.
12:04:37 <ricky_clarkson> The line in Arrow: arr, pure   :: (b -> c) -> a b c
12:04:42 <BMeph> @bot
12:04:42 <lambdabot> :)
12:04:47 <ricky_clarkson> looks odd, like piratespeak mixed with Haskell.
12:05:33 * oerjan hits head
12:05:43 <oerjan> @src (->) (>>>)
12:05:43 <lambdabot> f >>> g = g . f
12:08:04 <luqui> I don't know what type (.) is...
12:08:30 <oerjan> indeed.  i think it is at best a type variable.
12:08:44 <luqui> nope, just a syntax error :-/
12:08:50 <luqui> :q
12:08:58 <oerjan> not with suitable ghc extension
12:09:03 <SamB_XP> oerjan: eh?
12:09:14 <SamB_XP> a GHC extension makes it a syntax error!
12:09:26 <roconnor> fugues: A pathological amnesiac condition during which one is apparently conscious of one's actions but has no recollection of them after returning to a normal state. This condition, usually resulting from severe mental stress, may persist for as long as several months.
12:09:35 <luqui> conflicts with forall x. ... I think
12:09:36 <SamB_XP> forall a. a -- look familiar?
12:09:38 <oerjan> oh the forall maybe?
12:10:49 <oerjan> so . is essentially a keyword in type syntax, but not in expressions...
12:11:51 <oerjan> otoh it wouldn't _need_ to be illegal in other positions than after forall
12:12:33 <oerjan> although allowing forall (.). a . b may not be considered a virtue :D
12:12:55 <SamB_XP> oerjan: it isn't exactly missed, since you aren't allowed to compose types anyway...
12:13:28 <oerjan> technically it's lower case
12:13:38 <SamB_XP> that's another reason
12:14:16 <nolrai> @pl a b = (a . b) `liftM`
12:14:16 <lambdabot> (line 1, column 5):
12:14:17 <lambdabot> unexpected "="
12:14:17 <lambdabot> expecting variable, "(", operator or end of input
12:14:24 <nolrai> @pl f a b = (a . b) `liftM`
12:14:24 <lambdabot> (line 1, column 7):
12:14:25 <lambdabot> unexpected "="
12:14:25 <lambdabot> expecting variable, "(", operator or end of input
12:14:38 <nolrai> @pl (a . b) `liftM`
12:14:39 <lambdabot> (line 1, column 16):
12:14:39 <lambdabot> unexpected end of input
12:14:39 <lambdabot> expecting white space or simple term
12:14:51 <nolrai> @pl f a b = a b
12:14:52 <lambdabot> f = id
12:15:00 <roconnor> @pl f a b c = (a . b) `liftM` c
12:15:01 <lambdabot> f = (fmap .) . (.)
12:15:15 <nolrai> thanks!
12:15:18 <roconnor> @pl f a b = liftM (a . b)
12:15:18 <lambdabot> f = (fmap .) . (.)
12:15:22 <oerjan> that's weird
12:15:31 <nolrai> why
12:15:36 <oerjan> it complains about = when the actual error is later
12:15:59 <nolrai> Yeah, that is weird.
12:16:17 <oerjan> @pl a b = (a . b) test
12:16:17 <lambdabot> a = fix (flip flip test . (.))
12:16:32 <oerjan> @pl a b = (a . b) `
12:16:32 <lambdabot> (line 1, column 15):
12:16:33 <lambdabot> unexpected "`"
12:16:33 <lambdabot> expecting variable, "(", operator or end of input
12:16:35 <oerjan> @pl a b = (a . b) `test`
12:16:35 <lambdabot> (line 1, column 5):
12:16:36 <lambdabot> unexpected "="
12:16:36 <lambdabot> expecting variable, "(", operator or end of input
12:17:30 <oerjan> well @pl supposedly as an insane parser anyhow
12:17:37 <oerjan> *has
12:18:30 <Saizan> is foo = a `bar` legal syntax?
12:18:31 <oerjan> maybe it's a case of try (parse_as_equation) <|> parse_as_expression
12:18:52 <oerjan> no
12:19:12 <Saizan> ah, you're questioning the reported error
12:19:16 <oerjan> @pl a b = of
12:19:16 <lambdabot> a = const of
12:19:23 <oerjan> @pl a b = then
12:19:23 <lambdabot> (line 1, column 5):
12:19:23 <lambdabot> unexpected "="
12:19:23 <lambdabot> expecting variable, "(", operator or end of input
12:19:41 <oerjan> @pl \a b -> then
12:19:42 <lambdabot> (line 1, column 9):
12:19:42 <lambdabot> unexpected reserved word "then"
12:19:42 <lambdabot> expecting lambda abstraction or expression
12:20:06 <dons> ?users
12:20:06 <lambdabot> Maximum users seen in #haskell: 417, currently: 408 (97.8%), active: 22 (5.4%)
12:21:29 <Nafai> Hey byorgey
12:21:45 <ricky_clarkson> @pl \a b c d e -> a b c d e
12:21:45 <lambdabot> id
12:21:47 <byorgey> hey Nafai, how's it going?
12:22:20 <Nafai> Okay, just doing some boring XML stuff
12:22:58 <byorgey> ricky_clarkson: how about ($) . ($) . ($) . ($)?  =)
12:24:03 <Nafai> byorgey: How are you?
12:24:39 <byorgey> Nafai: pretty good, working on grad school applications
12:25:38 <Nafai> Where are you applying?
12:27:09 <byorgey> Nafai: Portland State, McGill, Princeton, Penn, CMU, Yale, Rutgers
12:28:40 <Nafai> Cool, what's your focus going to be?
12:29:47 <byorgey> hopefully, something along the lines of FP/logic programming/type systems/proof-carrying code/proof assistants.
12:30:37 <byorgey> that sounds really broad, but there are surprisingly few places in the US where that sort of thing is going on at all...
12:30:45 <Nafai> Yeah
12:31:31 <pejo> byorgey, plenty in UK though.
12:31:45 <byorgey> pejo: indeed!
12:32:26 <byorgey> I thought about applying to places in the UK, but what with planning to start a family soon and other things, going to school in the UK would be difficult.
12:32:51 <Nafai> Heck, I'm just looking for a job in FP.
12:33:00 <Nafai> Though I don't have enough experience just yet
12:34:58 <yrlnry> @src join
12:34:58 <lambdabot> join x =  x >>= id
12:35:07 <yrlnry> meh.
12:35:31 <byorgey> yrlnry: the type is more instructive
12:35:34 <byorgey> @type join
12:35:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:35:50 <byorgey> of course, the actual implementation is different for each specific Monad.
12:36:00 <yrlnry> Yes, when I saw the >>= I realized it was only going to make sense over the monad of arrows; hence "meh".
12:36:10 <yrlnry> Thanks though.
12:36:26 <byorgey> ah, ok
12:36:54 <yrlnry> Hey, maybe you have something useful to say on this topic:  since every type in Haskell is inhabited by the bottom value, is there a method for determining when a type is inhabited by a non-bottom value?
12:37:10 <Saizan> ?src Monad
12:37:11 <lambdabot> class  Monad m  where
12:37:11 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:37:11 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:37:11 <lambdabot>     return      :: a -> m a
12:37:11 <lambdabot>     fail        :: String -> m a
12:37:28 <mrd> yrlnry: isn't that equivalent to theorem proving?
12:37:36 <yrlnry> yes.
12:37:38 <yrlnry> For example, say I am considering forall a. (a->a)->a.  Is there a way to see that there is a partial function whose principal type is that?
12:37:40 <oerjan> well, every data definition that has at least one constructor has a non-bottom
12:37:47 <yrlnry> oerjan: see example.
12:37:55 <oerjan> er, with a non-strict field i guess
12:38:07 <oerjan> oh like that
12:38:15 <mrd> @type fix
12:38:15 <lambdabot> forall a. (a -> a) -> a
12:38:31 <yrlnry> Yes, I know fix has that type.  But (a->a)->a is not a theorem in any logic with which I am familiar.
12:38:32 <mrd> so the answer depends on which system you are working in =)
12:38:34 <oerjan> the system F inhabitation problem is undecidable, i believe
12:38:36 <mrd> right
12:38:49 <mrd> System F + fix would have it... artificially, but also not be terribly useful as a logic
12:38:53 <mauke> @djinn (a -> b) -> Either a c -> Either b c
12:38:54 <lambdabot> f a b =
12:38:54 <lambdabot>     case b of
12:38:54 <lambdabot>     Left c -> Left (a c)
12:38:54 <lambdabot>     Right d -> Right d
12:38:55 <yrlnry> So if it reduces to "just theorem proving", I want to know what the lofical systems are.
12:39:01 <SamB_XP> @free fix
12:39:02 <lambdabot> f . g = h . f => f (fix g) = fix h
12:39:11 <ricky_clarkson> head asplode
12:39:32 <SamB_XP> yeah, I can't understand that theorem either
12:39:40 <yrlnry>  system F inhabitation problem is indeed undeciable.
12:39:56 <yrlnry> I was reading about that in Srensen and Urzyczyn just last night.
12:40:03 <mauke> djinn is a theorem prover, right?
12:40:04 <yrlnry> But there might be some useful partial result; I don't know.
12:40:07 <yrlnry> mauke: no.
12:40:12 <oerjan> SamB_XP: i think it requires some laziness conditions
12:40:25 <SamB_XP> yrlnry: isn't it?
12:40:26 <yrlnry> @djinn (a -> a) -> a
12:40:28 <lambdabot> -- f cannot be realized.
12:40:31 <yrlnry> See?
12:40:35 <mrd> ?
12:40:38 <mrd> that's not provable
12:40:41 <yrlnry> Oh, right.
12:40:46 <SamB_XP> that just means it can't prove everything, duh
12:41:03 <yrlnry> Don't you "duh" me, you whippersnapper.
12:41:08 <ricky_clarkson> :t const 5
12:41:09 <lambdabot> forall t b. (Num t) => b -> t
12:41:14 <SamB_XP> @djinn a
12:41:15 <lambdabot> -- f cannot be realized.
12:41:16 <oerjan> SamB_XP: actually that fix theorem is quite intuitive
12:41:19 <oerjan> @free fix
12:41:19 <lambdabot> f . g = h . f => f (fix g) = fix h
12:41:21 <yrlnry> It's bad enough when my three-year-old daughter says that.
12:41:25 <ricky_clarkson> :t const 5 : Integer -> Integer
12:41:26 <lambdabot> <command line>:
12:41:26 <lambdabot>     Could not find module `L':
12:41:26 <lambdabot>       Use -v to see a list of the files searched for.
12:41:32 <ricky_clarkson> :t const 5 : Integer -> Integer -v
12:41:33 <lambdabot> Parse error in pattern
12:41:36 <mrd> ricky_clarkson: :
12:41:40 <SamB_XP> oerjan: quite intuitive is exactly the word that comes to mind, yes...
12:41:56 <oerjan> er, i mean i understood it the other day...
12:41:59 <oerjan> :D
12:42:03 <SamB_XP> yrlnry: so it's worse when a 21-year-old says it?
12:42:05 <yrlnry> Oh, that reminds me, there was a thingy on Planet Haskell a while back about how the S combinator was invertible, and part of the proof involved taking f, and then concluding that there is some g such that f = Kg.
12:42:34 <yrlnry> Now that does not seem true to me, but it was presented with no further explanantion.
12:42:40 <yrlnry> Does this ring any bells for anyone?
12:43:18 <byorgey> yrlnry: yes, I remember that... I thought it strange as well
12:43:37 <oerjan> ah yes. f (fix g) = f (g (fix g)) = (f . g) (fix g) = (h . f) (fix g) = h (f (fix g))
12:44:00 <oerjan> so f (fix g) is a fixpoint of h, which is fix h if h is lazy enough
12:44:27 <yrlnry> Here it is: http://www.iis.sinica.edu.tw/~scm/2007/s-combinator-is-injective-with-proofs/
12:44:38 <lambdabot> Title: S Combinator is Injective, with Proofs | Shin-Cheng Mu, http://tinyurl.com/2op8yh
12:44:48 <yrlnry>     ( a, y : x a (y a) = x' a (y a))
12:44:48 <yrlnry>        { choose y = K b for some b }
12:44:48 <yrlnry>     ( a, b : x a (K b a) = x' a (K b a))
12:45:04 <yrlnry> So what the heck happened there?
12:45:31 <mrd> hmm, this ghci debugger thing would be nice, but, it's taking about a year to get to the point of the stack overflow
12:45:42 <yrlnry> Surely that can only happen when y is a constant function, and so not for all y?
12:45:55 <yrlnry> Because y = K b means that y q = K b q = b for all q.
12:46:39 <andy__> yrlnry: Hmm? Didnt he simply choose a special y?
12:47:12 <yrlnry> Oh!
12:47:22 <byorgey> but he's trying to prove something quantified over all functions y.
12:47:45 <yrlnry> Yes, I understand now.  Thanks.
12:47:50 <andy__> Really? He says he needs only b.
12:48:32 <andy__> Note that in this step theres no equivalence.
12:48:35 <yrlnry> He's just trying to prove that if S x = S x'  then x = x'.
12:48:36 <pythonist> is it possible to define a type whose values are both functions (i.e. can be applied to arguments) and plain types (i.e. can be operated on)? Sort of () overloading of C++....
12:49:03 <mauke> you can operate on functions
12:49:03 <yrlnry> pythonist: I suspect that the answer is going to be "yes, but not in the way that you mean".
12:49:06 <andy__> He only shows the "forward"-direction.
12:49:23 <SamB_XP> pythonist: single type?
12:49:33 <pythonist> yrlnry: of course. Haskell is not C++ :D
12:49:41 <pythonist> SamB_XP: yes.
12:49:51 <byorgey> ohh, I see =)
12:50:08 <SamB_XP> doesn't seem too likely
12:50:09 <nolrai> sort of im doing that only using a +> for my aplication. I dont think you can just make ($) work.
12:50:12 <SamB_XP> but why would you want too?
12:50:16 <SamB_XP> er. to.
12:50:44 <pythonist> Just curious...
12:51:08 <pythonist> operator() seems to be nice in certain situations when using C++...
12:51:13 <yrlnry> pythonist: what you can't do is have the function have different behavior for different argument types.
12:51:19 <pythonist> wondering whether H has got something similar...
12:51:21 <oerjan> pythonist: in haskell if a function is to be overloaded it must be declared that way from the outset, and application clearly isn't.
12:51:32 <nolrai> well you could define say show f as f 0 or somthing. but that would be not very useful.
12:52:07 <SamB_XP> pythonist: you could just have a function to turn your things into functions...
12:52:10 <byorgey> @djinn ((a->b) -> (a->c)) -> a -> b -> c
12:52:11 <lambdabot> f a b c = a (\ _ -> c) b
12:52:33 <oerjan> but you could of course define a new overloaded function whose value applied to a function was ($)
12:52:37 <pythonist> oerjan: I imagine that... I hoped there could be some trick... may be like one of Oleg's magic...
12:53:09 <yrlnry> It's too bad that djinn doesn't match up the letters.
12:53:12 <pythonist> SamB_XP: yep... that's the obvious way I was thinking of...
12:53:27 <yrlnry> its solution has b::a and c::b, which is confusing.
12:54:48 <byorgey> yrlnry: true.  looks like it just generates fresh names as needed without regard to the given type names.
12:55:51 <andy__> I dont know too much C++, what is pythonist trying to do?
12:56:06 <mauke> overload function application
12:56:20 <pythonist> andy__: build a type which can be operated on and applied to arguments as well..
12:56:35 <mrd> a function
12:56:59 <mauke> define "operated on"
12:57:06 <pythonist> mauke: ok
12:57:10 <nolrai> you can operate on funtions.
12:57:22 <pythonist> take the function \x -> x + 5
12:57:24 <SamB_XP> I don't know why he is bothering to talk about C++, I'd think Python would be a more convenient point of reference for someone named pythonist...
12:57:46 <pythonist> SamB_XP: Eh eh.. legacy nickname...
12:57:55 <mrd> he could just be a snake-o-phile
12:58:14 <nolrai> pythonist: and do what with it?
12:58:19 <SamB_XP> pythonist: ... you don't seriously like C++ more than Python?
12:58:39 <sannysanoff> hello gentlemen! I am trying to develop DSL for my needs, which has following construct (see
12:58:39 <sannysanoff> http://hpaste.org/4371 ) but fall into the problem descibed there. If someone could suggest a reading for me, that is possibly related to my problem..
12:59:04 <pythonist> now, suppose that I just want to be able to define a function inc() taking the function I defined above and return the function \x -> x + 6
12:59:10 <pythonist> Got the point?
12:59:52 <SamB_XP> inc f = (1+) . f
13:00:01 <pythonist> SamB_XP: BTW, I never learned C++ :D
13:00:26 <pythonist> SamB_XP: mmmhh... too easy... that was just an example :D
13:00:44 <mauke> inc = (succ .)
13:01:18 <byorgey> pythonist: that may have been an easy example, but in general I think the sort of thing you are talking about can be accomplished in exactly the way SamB_XP showed.
13:01:37 <pythonist> SamB_XP: consider the where inc() depends on knowing 5....
13:01:38 <mrd> :t ((/) .)
13:01:39 <lambdabot> forall b a. (Fractional b) => (a -> b) -> a -> b -> b
13:01:45 <byorgey> pythonist: in Haskell (as in other functional languages), functions are first-class values, so it is very easy to "operate" on them in various ways
13:01:49 <SamB_XP> mauke: but that doesn't work right for one value!
13:02:13 <yrlnry> :t map (1/) [1..]
13:02:14 <lambdabot> forall t. (Fractional t, Enum t) => [t]
13:02:24 <pythonist> I should've come up with a better example...
13:02:47 <byorgey> pythonist: or maybe what you really want is Applicative.
13:02:58 <pythonist> byorgey: mmhh... intriguing...
13:03:03 <pythonist> byorgey: what's that?
13:03:24 <Plareplane> how do i get the vim literate haskell highlighting to work with > style lhs?
13:03:38 <byorgey> pythonist: http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Applicative.html
13:03:39 <lambdabot> http://tinyurl.com/2yero9
13:04:05 <byorgey> pythonist: the documentation is pretty theoretical, but essentially it allows you to define data types which can be "applied" in a function-like way
13:04:33 <pythonist> byorgey: curious... I was just reading "Applicative Programming with Effects" when I decided to come here :D
13:04:33 <byorgey> but since they can be arbitrary data types, you have a lot more control over the way in which that happens.
13:04:38 <Philippa_> pythonist: it sounds like you want to introspect functions?
13:04:44 <byorgey> pythonist: =)
13:04:45 <SamB_XP> Plareplane: upgrade to viper?
13:04:50 * SamB_XP teases
13:04:52 <Plareplane> ha ha
13:05:07 <pythonist> Philippa_: sort of...
13:05:24 <Plareplane> when emacs gets proper unicode/fonts support i might!
13:05:47 <mikael> what's wrong with it?
13:06:21 <SamB_XP> Plareplane: I hope that happens soon :-(
13:07:36 <Plareplane> if mikael was talking to me: currently it doesn't use xft, so it doesn't do antialiasing, and the default fonts (that come with ubuntu at least) are very ugly, and you have to manually set each character set's font if you want to change it
13:07:45 <pythonist> Too bad, I'm reading of jobs-in-fp only now... sounds interesting...
13:08:32 <pythonist> Quite a few companies from the banking industry are partecipating...
13:11:11 <oerjan> sannysanoff: would it be acceptable to have one big context variable that contained the others as fields?
13:11:19 <oerjan> then you could pass just that
13:11:47 <oerjan> or wait...
13:11:59 <oerjan> you could pass the # function :)
13:13:02 <oerjan> field # subField = subField (field allContext)
13:14:56 <nolrai> about Aplicative is does pure c = const c in (->)?
13:15:09 <oerjan> @src (->) pure
13:15:09 <lambdabot> pure = const
13:15:42 <nolrai> cool
13:15:50 <oerjan> @src (->) return
13:15:51 <lambdabot> return = const
13:16:11 <oerjan> anything which is both Monad and Applicative, should have pure = return
13:16:39 <nolrai> ok just trying to get my head around it.
13:16:41 <oerjan> (anything which is Monad should be Applicative, btw, but there are holes)
13:17:34 <nolrai> so to be in aplicative it has to be able to handle any data, right?
13:17:48 <oerjan> yep
13:18:10 <oerjan> iiu your question
13:18:26 <nolrai> so like puting the functions of an intepreter in Applicative requires handiling all the data types that haskell has?
13:18:44 <mauke> no
13:18:47 <oerjan> hm...
13:18:56 <mauke> it requires handling all data types that haskell could possibly have
13:19:07 <oerjan> usually you do it by being polymorphic
13:19:30 <oerjan> i.e. the basic methods don't look at the contents just pass them around
13:19:38 <Saizan> oerjan: is there another way?
13:20:04 <pythonist> thnak you folks... sleeping time now here in Italy...
13:20:06 <pythonist> bye
13:20:12 <oerjan> if your interpreter functions _don't_ have all possible types, then GADTs are a possible way to get around it
13:20:20 <nolrai> Ok so you basicly get stuck with static typing then.
13:20:25 <Taejo> @pl distance neighbours start end = lookup (distances neighbours start) end
13:20:26 <lambdabot> distance = (lookup .) . distances
13:20:27 <nolrai> what are GADT?
13:21:12 <oerjan> they are data types where the individual constructors don't need to give all possible typings
13:21:43 <monochrom> Instead of "data Whee a = X a | Y a", you can have "data Whee a where X :: a -> Whee a; Y :: a -> Whee a".
13:22:02 <oerjan> i.e. data Test a where Pure :: Test a; JustInts :: Int -> Test Int
13:22:05 <monochrom> But there is more! You can also have "Z :: Int -> Whee Int".
13:22:05 <oerjan> for example
13:22:17 <nolrai> that sounds intresting where can i read about GADTs?
13:22:35 <nolrai> and what do the G and the A stand for?
13:22:45 <mauke> data M :: * -> * where R :: a -> M a; B :: M a -> (a -> M b) -> M b
13:22:46 <oerjan> generalized algebraic
13:22:48 <monochrom> generalized algebraic
13:22:57 * oerjan should shut up :D
13:23:07 <monochrom> (And now, the obligatory fugues quote...)
13:23:28 <oerjan> yes?
13:23:37 <oerjan> @quote fugue
13:23:37 <lambdabot> monochron says: "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
13:23:54 <monochrom> sweet
13:24:29 <doserj> @quote stereo?
13:24:30 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:24:40 <monochrom> I think fugue is more accurate and general than stereo anyway.
13:24:53 <SamB_XP> @quote stereo!
13:24:53 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
13:25:14 <doserj> @quote metastereo
13:25:14 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
13:25:38 <byorgey> wow, nice =)
13:26:00 <dmhouse> Nice, metametastereo quotes. I wonder how far it'll go.
13:26:15 <oerjan> @remember dmhouse Nice, metametastereo quotes. I wonder how far it'll go.
13:26:15 <lambdabot> I will never forget.
13:26:22 <monochrom> It goes up to the first transfinite ordinal.
13:26:26 <oerjan> a sucker i am
13:26:46 <SamB_XP> monochrom: only as t approaches infinity
13:27:14 <monochrom> Yes yes.
13:28:05 <Taejo> which was the ICFP paper about automatic parallelisation?
13:28:44 <swiert> Taejo: Satnam Singh and Tim Harris?
13:29:41 <Taejo> swiert: thanks
13:31:40 <Philippa_> monochrom: you're suggesting we need to fix all these stereo metaquotes?
13:33:05 <oerjan> hm, technically dmhouse's quote has self-contradictory rank...
13:33:06 <SamB_XP> Philippa_: what?
13:33:22 <SamB_XP> oerjan: eh?
13:33:25 <SamB_XP> how so ?
13:33:32 <oerjan> SamB_XP: it's self-referential
13:33:38 <SamB_XP> oerjan: so?
13:33:53 <oerjan> so you cannot define an ordinal meta^w rank for it
13:34:15 <SamB_XP> eh?
13:34:21 <oerjan> hm, does that mean it is _not_ self-referential? or... oh my
13:34:27 <byorgey> why do you assume it's self-referential?
13:34:55 <SamB_XP> it refers to some metastereo quotes
13:35:02 <SamB_XP> it asks how far the trend will go...
13:35:04 <oerjan> 1) it's a meta^w stereo quote
13:35:11 <oerjan> it's part of the trend
13:35:40 <SamB_XP> so you are saying that it does not have finite rank?
13:35:51 <oerjan> it does not even have transfinite rank
13:36:05 <byorgey> but he didn't say 'meta^w-stereo quotes', he said 'metametastereo quotes'.
13:36:13 <byorgey> so it is a metametametastereo quote.
13:36:13 <hpaste>  ferret_0567 pasted "Screen login scrit" at http://hpaste.org/4372
13:36:17 <byorgey> or am I missing something?
13:36:26 <oerjan> but the "trend" referred to is obviously the meta^w trend
13:36:27 * SamB_XP retracts his statement about t approaching infinity
13:37:13 <glen_quagmire> that's not retractable
13:37:29 <SamB_XP> byorgey: I'm not sure what you mean about "beyond transfinite"
13:37:52 <byorgey> SamB_XP: I didn't say anything about "beyond transfinite"...
13:37:59 <SamB_XP> er.
13:38:01 <SamB_XP> oerjan:
13:38:17 <oerjan> otoh it is possible that the quote has a rank if and only if it doesn't
13:38:32 <SamB_XP> oerjan: don't go all barber on me
13:38:32 <byorgey> hehe
13:38:47 <oerjan> too late :)
13:39:01 <SamB_XP> that ain't possible!
13:39:35 <byorgey> therefore, the statement does not exist! QED.
13:40:08 <SamB_XP> the statement may be insensible
13:40:33 <SamB_XP> wait... it was a question, not a statement...
13:40:47 <byorgey> only if you assume that it must be sensible in order to be sensible.
13:42:07 * dmhouse wonders if he should take it back
13:42:43 <dmhouse> (For reference it was meant to be a (meta)^3stereo quote, although I didn't consider the implications of the second part of the quote.)
13:44:54 <byorgey> dmhouse: what, and ruin all the fun? =)
13:45:24 * SamB_XP looks for the full text search on his copy of GEB
13:45:28 * SamB_XP can't find it
13:45:49 <dmhouse> SamB_XP: it's got a good index.
13:46:04 <oerjan> full text search on GEB is obviously a logical impossibility.  somehow.
13:46:48 <SamB_XP> "we shall need them all" is not listed afaict
13:47:13 <SamB_XP> oerjan: what? I have the entire book on my knee.
13:47:25 <SamB_XP> it is printed in finite resolution
13:47:35 <SamB_XP> surely a finite amount of text is actually present!
13:47:42 <oerjan> ah, but _somehow_ it will be impossible to search it.
13:47:58 <SamB_XP> will it make the search engine self destruct?
13:48:05 <oerjan> quite likely.
13:48:19 <nolrai> a book in infine resolution, I have one of those.
13:49:22 * BMeph warns SamB_XP to back away from the infinities, so no one gets hurt
13:49:25 <dcoutts> @seen dons
13:49:25 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 10m 36s ago.
13:50:09 <dcoutts> dons: I'd like an opinion on whether we should continue packaging hs-plugins on gentoo, as far as I know there is no release that works with 6.6 or 6.8
13:50:15 <SamB_XP> couldn't I use a search engine with a different goedel number?
13:50:29 <dcoutts> dons: is there any chance it might work or should we just remove it from portage?
13:50:34 <BMeph> I have GEB in infinitesimal resolution, but I can never seem to find it...
13:50:46 <SamB_XP> BMeph: lol
13:50:57 <oerjan> lol
13:51:35 <oerjan> @version
13:51:35 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
13:51:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:51:40 <olsner> what's GEB and why would it be impossible to index?
13:51:53 <SamB_XP> olsner: well, it talks about recursion a lot
13:52:02 <mrd> does that mean GEB is incomplete?
13:52:03 <shachaf> SamB_XP: What are you looking for?
13:52:08 <SamB_XP> if it were published electronically, it might well be of infinite size!
13:52:08 <oerjan> Gdel Escher Bach: An Eternal Golden Braid
13:52:08 <dcoutts> does anyone have or know of patches to get wxHaskell to work with ghc-6.6 or 6.8? Otherwise we may have to drop that in gentoo as well. It's pretty much useless having packages that only work with ghc-6.4.x these days.
13:52:12 <stick_figure> How does one write efficient graph algorithms in Haskell?  ie MST and shortest path?  They seem to require mutation, so would you have to write them in the IO monad?
13:52:40 <mrd> pick a better representation
13:52:54 <sieni> stick_figure: There's also the State monad
13:53:57 <mrd> here's bellman-ford in data parallel haskell using an edge-list graph
13:53:59 <mrd> http://sequence.complete.org/node/371
13:53:59 <shachaf> SamB_XP: "We shall need them all" was in the beginning, I think? The bit by Lewis Carroll?
13:53:59 <lambdabot> Title: Data Parallel Bellman-Ford | The Haskell Sequence
13:54:14 <nolrai> > '\255'
13:54:15 <lambdabot>  '\255'
13:54:15 <stick_figure> mrd, cool
13:54:30 <nolrai> > chr 256
13:54:31 <lambdabot>  '\256'
13:54:42 <oerjan> @go we-shall-need-them-all
13:54:43 <lambdabot> http://www.ditext.com/carroll/tortoise.html
13:54:43 <lambdabot> Title: What the Tortoise Said to Achilles
13:55:08 <stick_figure> But in the sequential case, it's basically a mutative algorithm, and if I wanted to do that, I'd need either State or IO or something?
13:55:16 <oerjan> > maxBound :: Char
13:55:17 <lambdabot>  '\1114111'
13:56:13 <mrd> why is it a mutative algorithm?
13:56:18 <Plareplane> stick_figure, i don't know if this is relevant: http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
13:56:19 <lambdabot> Title: Functional Graph Library/Haskell
13:56:22 <SamB_XP> byorgey: please don't go all tortoise on me, anyway...
13:56:40 <mrd> FGL is interesting, and has a nice paper with neat examples
13:56:48 <fasta> FGL is also slow.
13:56:59 <fasta> FGL is for toy problems.
13:57:52 <fasta> FGL is not designed for general use.
13:58:12 <mrd> yea i use edge arrays, or adjacency lists/matrices generally
13:58:24 <stick_figure> mrd, if you're using a heap to get that log v factor, you have to track the vertices in the heap with a map, which if you're using path copy to update the heap, means they will need to be updated after every update of the heap.  If you use Map, the tree, you're getting log V * log V and it's also really awkward.
13:58:25 <byorgey> SamB_XP: I wasn't planning on it
13:58:46 * SamB_XP wonders why achilles is wearing a skirt
13:58:50 <fasta> stick_figure: what algorithm?
13:59:08 <stick_figure> Either Prim's or Dijkstra's.
13:59:15 <stick_figure> For MST or shortest path.
13:59:42 <mrd> that's bellman-ford which is simpler
14:00:01 <mrd> you just do n - 1 iterations
14:00:30 <byorgey> SamB_XP: all those Greek warriors wore skirts.  it was all the rage.
14:00:36 <mrd> it's n*m work, n depth
14:00:54 <SamB_XP> were they trying to look like japanese schoolgirls?
14:01:01 <stick_figure> mrd, I suppose, but E log V is a lot better...
14:01:50 <fasta> stick_figure: if you need an efficient implementation, build one, otherwise hack up something with FGL.
14:02:01 <byorgey> SamB_XP: yes.
14:02:27 <nolrai> "were they trying to look like japanese schoolgirls?" wha?
14:02:28 <SamB_XP> just like tortoise admired euclid?
14:02:40 <fasta> stick_figure: doing so would for mutation mean the use of the IO/ST monad; you can write efficient algorithms in Haskell.
14:02:43 <stick_figure> mrd, oh well, that's probably fine.  I'm just coding up algorithms from class for fun.
14:03:16 <mrd> stick_figure: yes yes, BMF is for when you deal with negative edge weights, which I am doing
14:03:50 <stick_figure> fasta, Bellman-Ford sounds easier to implement, so maybe I'll hit that up first, and then figure out how to work with the IO and State monads later.
14:03:54 <mrd> Dijkstra's makes the critical assumption that paths monotonically increase as they get longer
14:03:58 <mrd> in weight
14:04:02 <fasta> stick_figure: not State, ST.
14:04:08 <stick_figure> fasta, oh, thanks
14:04:18 <mrd> I've written similar algorithms using ST Arrays, too
14:04:31 <fasta> You are the second person confusing ST and State.
14:04:38 <fasta> (that I know of)
14:04:48 <fasta> Maybe the name should be changed.
14:05:06 <mrd> doesn't help that ST stands for "State Thread" or something
14:05:52 <nolrai> what is ST?
14:06:43 <mrd> a type constructor
14:06:45 <sorear> nolrai: a really evil hack
14:07:03 <fasta> @go lazy state threads simon
14:07:06 <lambdabot> http://portal.acm.org/citation.cfm?id=773473.178246
14:07:06 <lambdabot> Title: Lazy functional state threads
14:07:09 <mrd> is it really that evil
14:07:19 * SamB_XP wonders how large superman's planet's orbit is supposed to have been
14:07:26 <fasta> sorear: well, it's a pretty nice idea, isn't it?
14:07:45 <SamB_XP> mrd: I say it has gremlins for types
14:07:51 <sorear> fasta: Clever, yes.  Nice - not so sure.
14:08:12 <fasta> It would have been better if this kind of mutability would have been taken into account from the start.
14:08:28 <mrd> existential types == gremlins?
14:08:51 <oerjan> SamB_XP: my problem with Krypton orbiting a red giant is that stars spend a relatively short time in their red giant stage
14:09:14 <mrd> oerjan: wasn't it dying?
14:09:23 <oerjan> so just a few million years before, Krypton would have been _very_ cold, wouldn't it
14:09:35 <oerjan> i.e. life could not have evolved there
14:09:37 <nolrai> so maybe it was a colony.
14:10:19 <Philippa_> sorear: it's as nice as you're going to get, really
14:10:44 <nolrai> @ty (ap id id(ap id id(ap (ap (const ap) const) id)))
14:10:44 <Philippa_> which reminds me, I really ought to verify that it can be implemented (with crap performance) in System Fc with no primitives helping out
14:10:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
14:10:45 <lambdabot>     Probable cause: `id' is applied to too few arguments
14:10:45 <lambdabot>     In the second argument of `ap', namely `id'
14:10:54 <mrd> anyone notice any kind of stack overflow problem using randomRs?
14:11:22 <sorear> mrd: it would not suprise me one bit
14:11:26 <nolrai> the typed and untyped SKI are rather different.
14:11:33 <sorear> > randoms (mkStdGen 42)
14:11:34 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
14:11:35 <mrd> actually this also happened when i used randomR directly
14:11:45 <sorear> > randoms (mkStdGen 42) !! 10001000
14:11:49 <lambdabot> Terminated
14:11:54 <sorear> > randoms (mkStdGen 42) !! 1000100
14:11:56 <lambdabot>  Exception: stack overflow
14:12:02 <pheaver> heh
14:12:02 <mrd> sigh
14:12:09 <mrd> @src randoms
14:12:10 <lambdabot> Source not found. It can only be attributed to human error.
14:12:21 <EvilTerran> nolrai, yeah, you can't express a non-terminating computation in the simply typed, IIRC
14:12:25 <sorear> mrd: it's the standard lazy unfold gotcha
14:12:46 <mrd> perhaps its not evaluating the split generator expression?
14:13:16 <mrd> :t randomR
14:13:16 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:13:33 <mrd> if I force the g, perhaps?
14:13:34 <EvilTerran> that's how it works for lambda calculus, anyway. it's a pretty useful property for theoretical guff
14:13:38 <oerjan> mrd: perhaps each element depends on the previous
14:13:46 <sorear> mrd: that's what I said, lazy unfold gotcha
14:13:51 <mrd> yea
14:13:58 <sorear> > [0..] ! 100100
14:13:58 <lambdabot>  Couldn't match expected type `Array i e'
14:14:01 <sorear> > [0..] !! 1000100
14:14:02 <lambdabot>  Exception: stack overflow
14:14:43 <mrd> @hoogle unfold
14:14:43 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
14:14:43 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
14:14:43 <lambdabot> Data.ByteString.unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
14:15:41 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4373
14:15:50 <oerjan> > foldl' (flip const) undefined . take 1000100 $ [1..]
14:15:51 <lambdabot>  1000100
14:16:00 <oerjan> mrd: ^^
14:16:31 <oerjan> could call that last' ...
14:16:45 <sorear> oerjan: no.
14:16:52 <sorear> oerjan: the bug is in enumFrom
14:17:26 <sorear> oerjan: a stricter !! is a negative bug, which cancels out the unfold gotcha but is itself just as dangerous
14:17:46 <oerjan> sorear: i just meant [1..] as a test
14:18:20 <oerjan> it's a general last' to use for lists where each element depends on the previous
14:18:39 <stick_figure> mrd, I think you can do a nice little optimization on Bellman-Ford where after each cycle over the edges you check if you updated your graph, and if not you can stop.
14:18:42 <oerjan> > foldl' (flip const) undefined . take 1000100 $ randoms (mkStdGen 42)
14:18:43 <sorear> oerjan: it's a bad idea.
14:18:45 <lambdabot>  1001915027
14:19:00 <mrd> stick_figure: possible
14:19:13 <sorear> oerjan: it's far far better to just add the correct strictness to enumFrom
14:19:29 <oerjan> sorear: what about randoms?
14:19:36 <sorear> oerjan: that too.
14:19:49 <oerjan> what about iterate in general?
14:20:14 <oerjan> @src iterate
14:20:14 <lambdabot> iterate f x =  x : iterate f (f x)
14:20:22 <sorear> yes, iterate' needs to exist
14:20:27 <oerjan> perhaps iterate' would be a good place to put it
14:20:39 <oerjan> er, spoke to slowly
14:20:43 <sorear> just because you can paper over the standard demo, doesn't mean you've fixed it
14:22:06 <sorear> oerjan: http://hackage.haskell.org/trac/ghc/ticket/1097
14:22:08 <lambdabot> Title: #1097 (enumFrom on basic numeric types should be strict) - GHC - Trac
14:22:37 <gbacon> @src repeat
14:22:37 <lambdabot> repeat x = xs where xs = x : xs
14:22:42 <gbacon> @src map
14:22:42 <lambdabot> map _ []     = []
14:22:43 <lambdabot> map f (x:xs) = f x : map f xs
14:22:53 <kalven> @src const
14:22:53 <lambdabot> const x _ = x
14:23:03 <nburlett> hello!
14:23:07 <gbacon> @src flip
14:23:07 <lambdabot> flip f x y = f y x
14:23:08 <nburlett> anyone know of a good URL library?
14:23:26 <nburlett> (or even a poor one)
14:24:31 <oerjan> sorear: that's not really the same, it only speaks about the initial values
14:25:02 <SamB_XP> oerjan: maybe they moved the planet or something?
14:25:40 <oerjan> SamB_XP: well i am not quite up to the current continuity...
14:25:57 <SamB_XP> I am not up to ANY continuity
14:27:12 <oerjan> and i really just assume DC didn't consult astrophysical expertise
14:27:28 <SamB_XP> yeah, that's probably where that started ;-)
14:27:29 <njbartlett> @seen Heffalump
14:27:29 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 1d 6h 33m 44s ago.
14:30:03 <Heffalump> njbartlett: hi
14:30:12 <oerjan> otoh the Puppeteers in Niven's novels did do just that
14:30:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4374
14:32:12 <hpaste>  mrd pasted "strict tail-recursive randomRs?" at http://hpaste.org/4375
14:32:59 <mrd> it's not enough, and it's funny because using "repeat 0" instead works just fine
14:33:30 <oerjan> mrd: er, that seems excessive
14:33:42 <mrd> well it's not the first thing i tried :/
14:34:07 <BMeph> Talk to y'all later - time for me to go home. :)
14:35:23 <hpaste>  oerjan annotated "strict tail-recursive randomRs?" with "Doesn't this work?" at http://hpaste.org/4375#a1
14:36:45 <oerjan> hm... does that need a ! on the tuple itself?
14:36:55 <mrd> no that doesn't work
14:37:05 <mrd> no, pattern matching is already strict
14:37:16 <oerjan> not with let generally
14:37:20 <Syzygy-> Botje: See my update to the post.
14:37:31 <oerjan> is it enough to have an internal ! ?
14:37:40 <mrd> oerjan: it has to be, in order to figure out that it's a tuple
14:37:50 <oerjan> no!
14:37:53 <mrd> lazy patterns just fail horribly if it turns out not to be what's expected
14:38:22 <oerjan> mrd: try putting a ! on that tuple, just in case
14:39:16 <mrd> nope.  gotta run though, tnx for looking
14:41:03 <Botje> Syzygy-: oh, I only saw it by RSS. sorry if I was late :)
14:41:17 <Botje> so I was, doh :)
14:41:40 <oerjan> > let randomRs' r g = let (a, g') = randomR r g in a `seq` randomRs' r g' in randomRs' (1,6) (mkStdGen 42) !! 1000100
14:41:47 <lambdabot> Terminated
14:41:55 <oerjan> > let randomRs' r g = let (a, g') = randomR r g in a `seq` randomRs' r g' in randomRs' (1,6) (mkStdGen 42) !! 100010
14:42:03 <lambdabot> Terminated
14:42:09 <oerjan> oh wait
14:42:32 <oerjan> > let randomRs' r g = let (a, g') = randomR r g in a : a `seq` randomRs' r g' in randomRs' (1,6) (mkStdGen 42) !! 1000100
14:42:32 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
14:42:33 <lambdabot>       Expected...
14:42:53 <oerjan> > let randomRs' r g = let (a, g') = randomR r g in a `seq` a : randomRs' r g' in randomRs' (1,6) (mkStdGen 42) !! 1000100
14:42:54 <lambdabot>  6
14:42:58 <oerjan> yay
14:44:29 <Syzygy-> Botje: I did the update just now.
14:44:33 <Syzygy-> So you weren't late.
14:44:35 <hpaste>  oerjan annotated "strict tail-recursive randomRs?" with "This works" at http://hpaste.org/4375#a2
14:44:44 <Syzygy-> But the discussion had taken quite a bit od speed during the day...
14:45:14 <oerjan> > (0$0 `seq`)
14:45:14 <lambdabot>      The operator `seq' [infixr 0] of a section
14:45:14 <lambdabot>         must have lower prece...
14:50:00 <sfultong> is there a name for the datastructure that I'd naively call a two way hash?
14:50:50 <monochrom> In communities that are obsessed with hashing, you can call them two-way hash.
14:51:31 <opqdonut> so you want a one-to-one mapping with fast lookup in both directions
14:51:36 <sfultong> yes
14:51:55 <monochrom> In enlightened communities, where we know that hashing is just one implementation technique (out of many) for associative memory (e.g., set, bag, map), we say two-way associative memory.
14:52:32 <ddarius> monochrom: Don't communities that are obsessed with hashing usually call such things associative arrays/dictionaries?
14:53:03 <sfultong> what sort of communities are obsessed with hashing?
14:53:22 <monochrom> My experience with typical Perlers is they always say "hash" and never say "associative", "dictionary", "map".
14:53:28 <ddarius> Lua, Python, Smalltalk, Javascript...
14:53:29 <oerjan> the hashishim
14:53:30 <sfultong> ah
14:53:58 <integral> perl tells you that you're getting a hash, and not, say, a btree, or just a list [(a,b)]
14:54:00 <sfultong> oerjan: hehe
14:54:33 <monochrom> It is like some people say "xerox it" instead of "photocopy it", "hand me a Kleenex" instead of "hand me a tissue".
14:54:49 <ddarius> ChapStick, BandAid, etc.
14:55:05 <oerjan> my mistake, apparently it's Hashshashin
14:55:20 <sfultong> well, I don't even know Perl, so I'm not biased towards the hash label for that reason
14:55:20 <monochrom> It does not matter that the photocopier is actually Canon not Xerox made, and the tissue actually Royale something.
14:55:25 <ddarius> monochrom: Google...
14:56:30 <dibblego> I should google hashes ;)
14:56:55 <monochrom> Perl tells you it is a hash. That's fine. I'm talking about programmer attitudes and habits, however.
14:56:56 <sfultong> so... does ghc have a "two-way associative memory" data structure in its standard libraries?
14:57:35 <monochrom> IMO programmers should recognize the difference between "I just need any map" and "I really need hashing this time". This is independent of what the programming language tells you.
14:57:50 <ddarius> monochrom is trying to save us from our concrete selves
14:58:12 <SamB_XP> why would you really need hashing without needing some particular type of hashing?
14:58:17 <sfultong> it sounds like I've hit a pet peeve
14:58:23 <Saizan> sfultong: i've usually seen a pair of Maps used for that
14:58:24 <SamB_XP> i.e. for a DHT or something...
14:58:29 <ddarius> sfultong: Not really.
14:58:59 <SamB_XP> the Python programmers are okay, because "dictionary" doesn't imply anything about the implementation
14:59:04 <SamB_XP> only that you can look things up
14:59:21 <integral> but then you can't easily talk about the time complexity of your algorithms
14:59:27 <sfultong> saizan: I've done that before, but it seems like a common need...
15:00:57 <sfultong> implementation of a dictionary would only change the time complexity in terms of what base log the log complexity was, am I right?
15:01:12 <monochrom> Well, also IMO programmers should recognize when they need to talk about very precise time complexity and when they can leave a large margin.
15:01:36 <pjd> SamB_XP: indeed, Python's implementation special-cases small dictionaries (< 8 items)
15:01:41 <Saizan> sfultong: i suppose a clever implementation could find space in the standard library
15:01:45 <monochrom> I said nothing implying "you never need to know it's hashing", right?
15:02:18 <monochrom> I only said, sometimes you should know, sometimes you needn't over-specify, and you should be sensitive about when to do which.
15:02:33 <monochrom> It would help if you really read what I said first.
15:02:57 <ddarius> monochrom: But enterprise programmers should be insensitive to changes in implementation.
15:03:22 <ddarius> TechSchool.createProgrammer()
15:03:58 <SamB_XP> ugh
15:04:03 <sfultong> can't you just underspecify, and then specify more in a later optimization phase?  Is there any reason you'd want to think about the specifics beforehand?
15:04:18 <monochrom> Some later optimizations are hard.
15:04:41 <monochrom> We all say, bugs are more expensive to fix later. Well, under-performance is also a bug.
15:04:42 <sfultong> but in this case, it seems that switching one dictionary to another shouldn't be so bad...
15:04:45 <sfultong> maybe I'm wronig
15:05:24 <monochrom> Right.
15:06:35 <monochrom> I prefer to underspecify, too. I know the risk entailed.
15:06:50 <sfultong> I feel like sniffing glue.  Anyone want to join me?
15:07:01 <smack_> sfultong: depending on the context, it might make more sense to load both pairings into the same map?
15:07:15 * monochrom hands sfultong a capsule of Crazy Glue.
15:07:26 <sfultong> ooo! crazy! my favorite kind
15:08:07 <monochrom> cyanoacrylate glues FTW!
15:10:43 <stick_figure> Does anyone in here run ghc on Gentoo?  It seems to me that the version of darcs in Portage isn't compatible with GHC 6.6.  I'm trying to resolve some of those dependencies now...
15:11:00 <smack_> stick_figure: i do, but from the haskell overlay
15:11:12 <sfultong> yeah, I use the haskell overlay as well
15:11:57 <stick_figure> Guess I have to hit that up.
15:12:41 <stick_figure> smack_, is it stable/well-supported?  I've added compiz in the past and I'm still hemorraging broken dependencies.
15:13:20 <sfultong> I've found it stable... and as far as well-supported, well... you've got #gentoo-haskell (:
15:14:14 <stick_figure> sfultong, thanks
15:14:15 <smack_> stick_figure: it's working well on my server, but my desktop still has a mishmash of darcs built, overlay, and portage haskell packages...  seems alright if a bit bleeding edge, though
15:14:20 <sfultong> stick_figure: i'm generally averse to messing with my portage tree as well (the haskell overlay is the first I've used) but so far I've had no problems
15:15:43 <chessguy_> @bot
15:15:43 <lambdabot> :)
15:17:56 <stick_figure> smack_, see, the instability can be justified if the packages are actually bleeding edge, but it's obnoxious when the tree gets stale, and you can't update world because you unmasked some package to install another, and then a cycle arises...
15:18:23 <smack_> stick_figure: yep.  i'm in that state from an old gnome upgrade.
15:18:42 <smack_> stick_figure: haskell overlay seems ok to me currently though.
15:23:21 <augustss> @seen dons
15:23:21 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 2h 44m 32s ago.
15:49:34 <tinnus> anyone ever linked up haskell code with mac cocoa libraries?
15:49:39 <dmwit> Ah, darcs 2 is out.
15:50:24 <ChilliX> tinnus: http://hoc.sourceforge.net/
15:50:24 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
15:50:56 <tinnus> have you done it?
15:51:07 * mokus has fiddled with HOC, but has not yet ever actually seen it work
15:51:19 <tinnus> well, that's a stunning endorsement
15:51:26 * dmwit waits for the inevitable "ad hoc" joke
15:51:37 <tinnus> nah
15:51:41 <tinnus> i'm too tired for that
15:51:50 <tinnus> i prefer to make fun of people's nicks anyway
15:51:50 <ChilliX> I have *seen* it work, but never used it myself :)
15:52:17 <tinnus> any open source examples to look at, chillix?
15:52:27 <tinnus> preferably a game :)
15:52:29 <mokus> I have no particular doubt that it works, once built, but the header parser chockes hard on recent XCode sdk headers
15:52:46 <mokus> and I haven't takn the time yet to try to fix it
15:54:50 <tinnus> well, you should.. for the benefit of everyone ;)
15:54:50 <tinnus> i'm still trying to figure out the lambdabot dice program
15:54:50 <tinnus> so it's probably an academic question for me anyway
15:54:50 <chessguy> tinnus, what are you trying to figure out about it?
15:54:50 <tinnus> just curious
15:54:50 <tinnus> i like the mac
15:54:50 <tinnus> it's my home-room, so to speak
15:55:04 <ChilliX> tinnus: I haven't got any code, but are there no examples in the distribution?
15:55:14 <tinnus> there are a couple
15:55:16 <oerjan> @dice 3d6+2d12+5
15:55:16 <lambdabot> 3d6+2d12+5 => 38
15:55:26 <tinnus> just wanted to talk to someone with experience
15:55:36 <tinnus> see how their mileage varied
15:55:59 <tinnus> dice needs to handle a single die, without a d
15:56:03 <tinnus> @dice 6
15:56:03 <lambdabot> 6 => 6
15:56:10 <tinnus> six one-sided dice
15:56:10 <oerjan> @dice 1d6
15:56:11 <lambdabot> 1d6 => 6
15:56:15 <tinnus> yeah
15:56:20 <tinnus> seems kinda verbose
15:56:26 <dmwit> no
15:56:26 <tinnus> better parser is needed
15:56:35 <tinnus> yes
15:56:36 <dmwit> ?dice 6
15:56:37 <lambdabot> 6 => 6
15:56:40 <dmwit> oh
15:56:44 <oerjan> it permits adding constants
15:56:47 <dmwit> 6 translates to 6d1?
15:56:47 <chessguy_> @help dice
15:56:47 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
15:56:58 <tinnus> i think it does
15:57:01 <tinnus> or I'm very lucky
15:57:04 <tinnus> @dice 6
15:57:05 <lambdabot> 6 => 6
15:57:08 <tinnus> @dice 6
15:57:08 <lambdabot> 6 => 6
15:57:16 <dmwit> That's the problem with randomness... you can never tell. =P
15:57:20 <tinnus> i should help explore the ringworld, if that's my luck
15:57:25 <dmwit> indeed
15:57:27 <tinnus> @dice 6
15:57:27 <lambdabot> 6 => 6
15:57:39 <smack_> just 0+6
15:57:43 <tinnus> it's giving me results for 6 1 sided dice
15:57:43 <dmwit> You'll learn a few hard lessons about danger, first, though.
15:57:57 <oerjan> @dice 1d6*1d6
15:57:57 <lambdabot> unexpected "*": expecting digit, "+" or end
15:57:59 <chessguy> ringworld?
15:58:08 <tinnus> yeah, it's a book
15:58:10 <dmwit> chessguy: It's a book by Larry Niven.
15:58:23 <tinnus> it's a book by larry niven about a Halo-type world
15:58:23 <dmwit> (recommended as a diversion)
15:58:59 <oerjan> @dice d6
15:59:00 <lambdabot> unexpected "d": expecting number
15:59:15 <oerjan> it could have supported that at least
15:59:36 <oerjan> @list dice
15:59:37 <lambdabot> dice provides: dice
15:59:48 <dmwit> I don't think ?dice gets a lot of use.
15:59:58 <oerjan> ooh, i just realized something
16:00:09 <tinnus> yeah, that too
16:00:18 <tinnus> ?dice
16:00:18 <lambdabot> unexpected end of input: expecting number
16:00:23 <tinnus> ?dice 3
16:00:23 <lambdabot> 3 => 3
16:00:40 <tinnus> what does that mean?
16:00:55 <mokus> "?dice" == "@dice"
16:01:08 <tinnus> ?dice 3
16:01:08 <lambdabot> 3 => 3
16:01:16 <dmwit> tinnus: What does what mean?
16:01:16 <tinnus> what am I asking?
16:01:17 <oerjan> @@ @run randomRs (1,6) (mkStdGen (@dice 1d100)) :: [Int]
16:01:17 <lambdabot>  Parse error at "=>" (column 32)
16:01:18 <smack_> tinnus: it's just +3
16:01:35 <tinnus> waht does ? ask the parser?
16:01:38 <oerjan> @bot
16:01:38 <lambdabot> :)
16:01:42 <smack_> ?bot
16:01:42 <lambdabot> :)
16:01:47 <dmwit> tinnus: ? is just the same as @.
16:01:51 <TomMD> @botsnacks
16:01:51 <tinnus> oh
16:01:52 <lambdabot> :)
16:02:03 <tinnus> :t dice
16:02:04 <lambdabot> Not in scope: `dice'
16:02:10 <oerjan> > randomRs (1,6) (mkStdGen (100)) :: [Int]
16:02:11 <lambdabot>  [6,3,3,1,1,2,2,5,3,2,3,3,4,6,1,1,5,5,2,4,5,4,3,1,3,4,4,5,5,4,4,6,4,4,2,4,4,5...
16:02:15 <TomMD> @where lambdabot
16:02:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:02:38 <oerjan> @dice 1d6
16:02:39 <lambdabot> 1d6 => 5
16:02:42 <dmwit> oerjan: It's the (1d100 =>) bit that confuses it.
16:02:44 <oerjan> ah of course
16:03:21 <dmwit> oerjan: But surely a well-placed replicateM would get the same effect in pure Haskell?
16:03:32 <Botje> @quote finest
16:03:32 <lambdabot> No quotes match. Just what do you think you're doing Dave?
16:03:34 <Botje> argh!
16:03:47 <oerjan> dmwit: er, the point is to get _actual_ random input
16:03:48 <Botje> anyone know who made the quote "haskell: the finest imperative language" ?
16:03:56 <dmwit> oerjan: Oh, I see what you're trying to do.
16:03:59 <Botje> I'm making a presentation and want to properly attribute it :)
16:04:02 <smack_> Botje: SPJ i think?
16:04:12 <TomMD> @quote imperative
16:04:13 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
16:04:18 <TomMD> @quote imperative
16:04:18 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
16:04:20 <TomMD> damn
16:04:40 <Botje> heh. Erik meijer has meijcrosoft.com :)
16:04:45 <dibblego> is there a standard function (Int -> [Int]) to take 1234 to [1,2,3,4]
16:04:52 <smack_> Botje: http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/mark.pdf
16:04:53 <lambdabot> http://tinyurl.com/yc5nfg
16:04:55 <Botje> looks like it's SPJ alright.
16:05:00 <oerjan> @@ @run randomRs (1,6) (mkStdGen. drop 2 .words $ @show @dice 1d100)) :: [Int]
16:05:00 <lambdabot>  Unbalanced parentheses
16:05:12 <oerjan> @@ @run randomRs (1,6) (mkStdGen. drop 2 .words $ (@show @dice 1d100)) :: [Int]
16:05:12 <lambdabot>  Couldn't match expected type `Int' against inferred type `[String]'
16:05:25 <oerjan> @@ @run randomRs (1,6) (mkStdGen.read.drop 2 .words $ (@show @dice 1d100)) :: [Int]
16:05:26 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
16:05:50 <smack_> oerjan: drop 2 still gives you a list
16:06:00 <oerjan> @@ @run randomRs (1,6) (mkStdGen.read.(!!2) .words $ (@show @dice 1d100)) :: [Int]
16:06:01 <lambdabot>  [6,4,3,5,6,2,2,4,2,1,5,1,5,5,4,6,6,3,3,5,5,6,3,2,5,4,5,6,5,5,2,6,2,3,3,5,3,6...
16:06:09 <oerjan> @@ @run randomRs (1,6) (mkStdGen.read.(!!2) .words $ (@show @dice 1d100)) :: [Int]
16:06:10 <lambdabot>  [6,4,5,4,5,2,5,2,4,4,2,5,3,5,4,2,5,1,5,1,2,5,1,4,3,3,1,5,6,5,6,2,3,2,1,5,3,2...
16:06:50 <MyCatVerbs> > map sin [1.0,1.1...]
16:06:50 <lambdabot>  Parse error at "]" (column 20)
16:06:53 <MyCatVerbs> > map sin [1.0,1.1..]
16:06:54 <lambdabot>  [0.8414709848078965,0.8912073600614354,0.9320390859672264,0.9635581854171931...
16:11:08 <Pseudonym> MyCatVerbs: If you really need that, you might be better off with a CORDIC algorithm.
16:20:11 <MyCatVerbs> Pseudonym: I'm not after anything, I'm just bored and felt like staring at floating point numbers.
16:36:40 <RyanT5000> is there a library that does tab completion? e.g.: getLnTC :: (CurrentLine -> [Completion]) -> IO String
16:37:21 <RyanT5000> oh, maybe the argument should be a function in IO, but the idea is the same
16:37:49 <RyanT5000> that you should be able to supply a list of tab completions, and it should just make it work
16:38:10 <dmwit> Doesn't GNU Readline have that capability?
16:38:49 <RyanT5000> dmwit: i wouldn't know, but i wasn't sure how to search for it; i'll look up readline
16:39:07 <oerjan> there seems to be a frightening number of relevant options/functions
16:39:39 <dmwit> http://tiswww.case.edu/php/chet/readline/readline.html#SEC44
16:39:40 <lambdabot> Title: GNU Readline Library:
16:39:54 <RyanT5000> dmwit: ah, cool, thanks
16:41:45 <shapr> @yow !
16:41:46 <lambdabot> I was born in a Hostess Cupcake factory before the sexual revolution!
16:44:39 <shapr> Excitement?
16:46:59 <dmwit> Excitement!
16:46:59 <oerjan> > 'W':'H':repeat 'E'
16:47:00 <lambdabot>  "WHEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE...
16:48:31 <dmwit> > concat $ "WH" : cycle ["EEEEE", "ee", "ooo", "OOOOO"]
16:48:32 <lambdabot>  "WHEEEEEeeoooOOOOOEEEEEeeoooOOOOOEEEEEeeoooOOOOOEEEEEeeoooOOOOOEEEEEeeoooOOO...
16:50:28 <EvilTerran> @@ @run let q = (@show @yow) in (q, (@show @vixen q))
16:50:29 <lambdabot>  ("So this is what it feels like to be potato salad\n","uhuh")
16:51:24 <EvilTerran> @@ @run let q = (@show @yarr) in (q, (@show @vixen q))
16:51:25 <lambdabot>  ("Yarrr!","I like to pick everything up and smell it... Its a fetish of mine...
16:51:38 <dmwit> reeeally
16:51:41 <lucca> o.o
16:51:50 <dmwit> @vixen Yarrr!
16:51:50 <lambdabot> i drive a pickup truck
16:51:52 <dmwit> @vixen Yarrr!
16:51:52 <lambdabot> tell me more about yourself.
16:51:58 <EvilTerran> @@ @run let q = (@show @vixen) in (q, (@show @vixen q))
16:51:59 <lambdabot>  ("tell me a joke.. I like men that makes me laugh","ain't it just like a man?")
16:52:26 <dmwit> @vixen How come you flirt with @yow so much?
16:52:26 <lambdabot> let me answer that later, okay?
16:54:35 <nburlett> hey.. does this function exist somewhere in the standard library already:
16:54:37 <nburlett> when2 b a = if b then a else fail "when2 predicate false"
16:55:14 <EvilTerran> looks like flip when in the Identity monad
16:55:32 <sorear> @hoogle assert
16:55:33 <lambdabot> Control.Exception.assert :: Bool -> a -> a
16:55:33 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
16:55:33 <lambdabot> Control.Exception.AssertionFailed :: String -> Exception
16:55:38 <sorear> yep
16:55:50 <oerjan> er, that's monadic
16:55:58 <oerjan> but with fail, not return
16:56:18 <dmwit> ?type fail -- m a, or m ()?
16:56:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
16:56:28 <oerjan> guard b >> a  is close
16:56:30 <dmwit> ...interesting
16:56:31 <EvilTerran> @src assert
16:56:31 <lambdabot> Source not found. :(
16:56:38 <sorear> Just use assert
16:56:42 <EvilTerran> flip.assert looks close
16:56:46 <monochrom> guard b wants MonadPlus.
16:56:48 <EvilTerran> er, flip assert
16:56:52 <sorear> EvilTerran: it's an ultra-magic compiler primitive
16:56:56 <sorear> EvilTerran: no, assert
16:57:02 <dmwit> monochrom: In the ideal world, fail wants MonadPlus, too.
16:57:03 <sorear> EvilTerran: not flip assert
16:57:03 <monochrom> assert uses some kind of error, not fail.
16:57:04 <EvilTerran> er
16:57:19 <EvilTerran> the b and the a are the wrong way 'round in the parameter list \(O.o)/
16:57:24 <monochrom> Then again, the customer is always wrong.
16:57:51 <nburlett> :t assert
16:57:51 <lambdabot> Not in scope: `assert'
16:58:06 <nburlett> wait, that's not right though...
16:58:10 <nburlett> assert isn't identical
16:58:16 <nburlett> I want fail, not exception
16:58:31 <oerjan> nburlett: guard b >> a, i said
16:58:45 <nburlett> :t guard
16:58:45 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:59:02 <oerjan> ok, so it's mzero not fail
16:59:19 <nburlett> :t f a b = guard b >> a
16:59:20 <lambdabot> parse error on input `='
16:59:41 <oerjan> but that should be close enough
17:00:53 <nburlett> mzero is good enough
17:01:41 <EvilTerran> {-# LANGUAGE OverlappingInstances #-} instance Monad m => MonadPlus m where mzero = fail "mzero" -- ;)
17:02:20 <dmwit> Excellent, let's use MonadPlus to generate run-time errors. ;-)
17:02:41 <EvilTerran> yaaay!
17:02:50 <nburlett> well, my Monad is Maybe here, so I'm fine
17:03:32 <dmwit> Oh, yeah, then fail = const mzero anyway.
17:05:44 <oerjan> @instances-importing Data.Foldable Foldable
17:05:45 <lambdabot> Maybe, []
17:06:42 <EvilTerran> thrilling
17:07:43 <oerjan> :t \a b -> Data.Foldable.find (const b) a
17:07:44 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Bool -> Maybe a
17:09:50 <dmwit> > (find (const True) [3,4,5], find (const False) [3,4,5], find (const True) [])
17:09:51 <lambdabot>  (Just 3,Nothing,Nothing)
17:12:18 <oerjan> _given_ that fail was put in Monad, it seems rather weird that guard uses mzero rather than it...
17:12:51 <dmwit> Maybe they had thought better of it by the time guard came about.
17:13:34 <nburlett> yeah, I don't quite understand
17:13:51 <nburlett> my other extra function is mHead
17:13:52 <nburlett> mHead :: Monad m => [a] -> m a
17:13:52 <nburlett> mHead []    = fail "empty list"
17:13:53 <nburlett> mHead (e:_) = return e
17:14:19 <dmwit> :t listToMaybe
17:14:19 <lambdabot> forall a. [a] -> Maybe a
17:14:35 <nburlett> wow, how did I not find that :->
17:14:41 <dmwit> Also:
17:14:46 <dmwit> :t sequence . map return
17:14:46 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m [a]
17:14:53 <dmwit> Oh, well, that's not it. =P
17:14:55 <oerjan> nburlett: note that you can often achieve the same with (e:_) <- l in a do expression
17:15:35 <nburlett> oerjan: ooh, I like that
17:15:56 <oerjan> oh wait
17:16:05 <oerjan> should be (e:_) <- return l
17:16:15 <dmwit> right
17:16:16 <nburlett> currently, I'm doing mapMaybe mHead
17:16:27 <oerjan> :t mapMaybe
17:16:28 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
17:17:36 <oerjan> :t concatMap (take 1)
17:17:37 <lambdabot> forall a. [[a]] -> [a]
17:17:42 <nburlett> > let mHead l = case l of { [] -> fail "blah"; (e:_) -> return e } in mapMaybe mHead [[1,2,3],[1,2],[]]
17:17:43 <lambdabot>  [1,1]
17:17:44 <dmwit> I have complained before about this: there's lots of great functions for consuming Maybes, but very few for creating Maybes in a nice way.
17:17:48 <oerjan> is one alternative
17:18:01 <nburlett> oerjan: good call
17:18:10 <Saizan> [x| (x:_) <- xs]
17:18:12 <oerjan> or take 1 =<<
17:18:47 <nburlett> oerjan: I'm not as much a fan of that, as I haven't quite gotten used to =<< being concatMap yet :-<
17:19:02 <dmwit> heh
17:19:21 <oerjan> :t head . transpose
17:19:21 <lambdabot> forall a. [[a]] -> [a]
17:19:34 <dmwit> ooo, sneaky
17:19:44 <dmwit> > head . transpose $ [[], []]
17:19:44 <lambdabot>  Exception: Prelude.head: empty list
17:19:56 <oerjan> the last one probably requires one to be non-empty, yeah
17:20:54 <nburlett> well, yeah, the whole point of my mHead was to make head's failure case not bomb out of my program
17:21:53 * EvilTerran likes the list comprehension for this
17:22:49 <dmwit> I like the mapMaybe listToMaybe approach, with the only drawback being that it would probably send most readers to look up each of those functions.
17:22:51 <nburlett> failed pattern matches in a monad results in fail, yes?
17:23:25 <oerjan> yep
17:23:52 <mokus> > do (e:_) <- return []; return 5 :: Maybe Int
17:23:53 <lambdabot>  Nothing
17:24:12 <davidL> @type mapMaybe
17:24:12 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
17:24:26 <davidL> @type catMaybes
17:24:26 <lambdabot> forall a. [Maybe a] -> [a]
17:24:43 <dmwit> I guess mapMaybe is a specialization of (>>=), though.
17:24:58 <davidL> mapMaybe and catMaybes are inverse functions?
17:24:59 <EvilTerran> @index mapMaybe
17:24:59 <lambdabot> Data.Maybe
17:25:04 <dmwit> davidL: No
17:25:15 <dmwit> mapMaybe f = catMaybes . map f
17:25:22 <EvilTerran> mapMaybe f = ... yeah.
17:25:48 <davidL> > catMaybes [Just 1, Just 2, Just 3]
17:25:48 <lambdabot>  [1,2,3]
17:26:28 <davidL> ohhh ok
17:26:51 <davidL> I read the type for mapMaybe wrong
17:28:53 <davidL> > mapMaybe (splitAt 2) (replicate 3 [1..5])
17:28:53 <lambdabot>  Couldn't match expected type `Maybe b'
17:29:24 <davidL> @type splitAt
17:29:24 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:29:49 <davidL> > mapMaybe (\x -> splitAt 2 x) (replicate 3 [1..5])
17:29:49 <lambdabot>  Couldn't match expected type `Maybe b'
17:30:12 <dmwit> davidL: splitAt doesn't return a Maybe...
17:30:29 <davidL> hmm what function am I thinking of
17:30:32 <nburlett> > mapMaybe (\x -> Just $ splitAt 2 x) (replicate 3 [1..5])
17:30:33 <lambdabot>  [([1,2],[3,4,5]),([1,2],[3,4,5]),([1,2],[3,4,5])]
17:30:52 <desp> Has anyone thought about making a strict subset of Haskell?
17:30:52 <dmwit> davidL: Not sure, what should the output be?
17:30:53 <olsner> perhaps you're thinking of maybeSplitAt n l = if length l >= n then Just (splitAt n l) else Nothing
17:31:03 <nburlett> desp: you mean ML ?
17:31:07 <dmwit> desp: Take a look at Eager Haskell.
17:31:11 <dmwit> ?go eager haskell
17:31:12 <lambdabot> http://lambda-the-ultimate.org/node/485
17:31:12 <lambdabot> Title: Dynamic Eager Haskell | Lambda the Ultimate
17:31:19 <dmwit> hmm...
17:31:19 <desp> nburlett: SML and OCaml have inferior syntax.
17:31:22 <desp> dmwit: hmm!
17:31:25 <EvilTerran> nburlett, that's far too kind on ML
17:31:39 <nburlett> desp, EvilTerran :->
17:31:48 <EvilTerran> particularly that hateful syntax, yes
17:32:19 <hpaste>  dbueno pasted "Instance constraint" at http://hpaste.org/4376
17:32:21 <davidL> err I was thinking of lookup, I am tired :-(
17:32:23 <dmwit> desp: http://csg.csail.mit.edu/pubs/haskell.html
17:32:23 <lambdabot> Title: Computation Structures Group
17:32:32 <dbueno> Ugh, sorry about the long-line comment.
17:32:38 <desp> dmwit: Thanks, looking into it.
17:33:07 <dbueno> If someone is willing to look at the bit of code I pasted, I have a question about creating instance for a simple typeclass.
17:33:50 <dmwit> dbueno: If you want to stay H98, you nave to newtype it.
17:34:04 <dbueno> dmwit: newtype the array?
17:34:05 <dmwit> newtype IntArray a = Array Int a -- or so
17:34:11 <dmwit> yes
17:34:25 <dbueno> But the instance stiil needs to know that the *values* are Ints, not just the indices. Right?
17:35:02 <dbueno> dmwit: I don't mind exceeding H98, at this point.
17:35:05 <oerjan> i think that calls for a multiparameter type class
17:35:14 <davidL> > mapMaybe (elemIndex 3) (replicate 4 [1..5])
17:35:15 <lambdabot>  [2,2,2,2]
17:35:19 <oerjan> class SetLike t a where ...
17:35:35 <dbueno> oerjan: Right, but how can I write a function sig that makes the "a" in the signature and the typeclass parameter be the same?
17:35:41 <oerjan> and change t a to t inside
17:35:44 <dmwit> dbueno: err... either the values are Ints, or the indices are Ints, or else you can only have sets of Ints.  Is that what you want?
17:35:51 <dbueno> oerjan: Ahh... okay.
17:36:07 <dbueno> dmwit: I want Int indices and value,s yes.
17:36:28 <dmwit> ok
17:36:36 <dbueno> I want a set where each member can only be one of 1..n
17:36:41 <oerjan> oh, and a functional dependency seems useful:
17:36:46 <dbueno> And each Int is either present or not.
17:36:51 <oerjan> class SetLike t a | t -> a where ...
17:37:06 <nburlett> > mapMaybe (elemIndex 3) [[1..n] | n <- [1..10]]
17:37:06 <lambdabot>  [2,2,2,2,2,2,2,2]
17:37:14 <desp> dmwit: Looks like there's no code, though.
17:37:25 <dbueno> oerjan: Where would I put the Ord constraint?  As a dependency in the instance head, right?
17:37:32 <desp> dmwit: Promised since 2002. :)
17:37:52 <dmwit> desp: Mmm, bummer. =P
17:39:00 <oerjan> dbueno: i guess
17:41:48 <dbueno> dmwit, oerjan; Thanks, it worked.
17:41:55 <davidL> Where can I find the instance for Monad []?
17:42:06 <dmwit> ?src (>>=) []
17:42:06 <lambdabot> Source not found. Wrong!  You cheating scum!
17:42:10 <oerjan> davidL: Prelude
17:42:22 <dmwit> ?src [] (>>=)
17:42:22 <lambdabot> m >>= k     = foldr ((++) . k) [] m
17:42:24 <dbueno> dmwit: the way you asked about "Is that what you want?"  Was there something else that came to mind that would be easier, or already implemented, that would acheive what I want?
17:42:49 <dmwit> dbueno: I was thinking that maybe you want want Array a Int, so that you could have sets of any Ix'able.
17:43:03 <dmwit> (They would be bags, really, unless you did Array a Bool.)
17:43:06 <davidL> thanks oerjan and dmwit
17:43:46 <dbueno> dmwit: Well, my values are in 1-1 correspondence with Ints, so I can store one value at its location, if the indices are known to be Ints
17:44:17 <dmwit> values...
17:44:20 <dbueno> I wanted to store and have a "contains" function both in O(1)
17:44:23 <dbueno> values = elements
17:44:54 <oerjan> dbueno: note that if you want O(1) update of an array you need to use Diff arrays, or go monadic
17:45:24 <oerjan> other pure arrays copy the whole array
17:45:28 <dbueno> oerjan: Oh, right, because it copies the array.
17:45:55 <dmwit> dbueno: This sounds vaguely like a key-value kind of thing, which isn't totally set-like...
17:46:06 <nburlett> allright, thanks all
17:46:07 <nburlett> cya
17:47:24 <dbueno> oerjan: Do you know how much slower diff arrays become over time?
17:48:17 <oerjan> i don't think they slow down, they fake update by using mutation
17:48:38 <SamB_XP> they just start out really slow in the first place ;-P
17:48:45 <EvilTerran> what about STArrays?
17:49:10 <oerjan> well yeah, they have some basic overhead, apparently locking most of it i hear
17:49:21 <SamB_XP> EvilTerran: STArrays don't make any pretense about being purely-functional
17:49:24 <dbueno> The documentation says older elements (that haven't been updated in a while) become slower.
17:49:48 <oerjan> oh... lessee
17:49:53 <EvilTerran> SamB, well, they do provide a pure interface. that's good enough for me.
17:49:56 <EvilTerran> ;)
17:50:12 <SamB_XP> dbueno: sounds like you misread it
17:50:18 <EvilTerran> i distrust the subtlty of DiffArrays
17:50:44 <oerjan> dbueno: it's not old elements of the array, but old versions of the entire array
17:50:48 <SamB_XP> EvilTerran: so subtle they hit you over the head with a bajillion MVars
17:50:55 <EvilTerran> quite
17:51:02 <scook0> though DiffArrays are inherently pretty slow anyway
17:51:06 <SamB_XP> i.e. how is that subtle
17:51:21 <EvilTerran> i mean, order of evaluation in haskell can be pretty difficult to reason about
17:51:21 <scook0> so much so that in many cases, the copying overhead of a normal array is actually less
17:51:44 <EvilTerran> so it can be hard to know when an "older version" of a DiffArray might pop up unexpectedly in a thunk
17:51:51 <oerjan> scook0: eek.  what about compared to Map?
17:52:06 <dbueno> SamB_XP: You're right, it's older arrays, but I think it turns out to be the same thing?
17:52:12 <scook0> oerjan: no idea
17:52:12 <EvilTerran> while, with explicitly threaded state, there's no risk of that
17:52:18 <dbueno> I.e. if you update an element recently, accessing it faster, because you're accessing a more recent array.
17:52:26 <scook0> all I know is that I had an app that used DiffArrays, and changing to Arrays made it faster
17:52:58 <scook0> because its access pattern was "lots of reads, punctuated by relatively large update batches"
17:53:14 <dcoutts> scook0: doesn't surprise me at all, DiffArrays have terrible constant factors
17:53:19 <SamB_XP> dbueno: well, no, and anyway the constant factors are what kill you so it doesn't really matter
17:53:25 <EvilTerran> at the expense of having to think harder about your algorithm design, vanilla Arrays or STArrays strike me as far easier to reason about in terms of complexities and whatnot
17:53:41 <scook0> dcoutts: yes, that's pretty much what I was trying to say
17:53:50 <oerjan> dbueno: all of the elements of the newest array should be equally, er, maybe not fast is the word with what people are saying
17:53:51 <dbueno> EvilTerran: Sounds like it.
17:53:56 <dcoutts> I've never seen a real problem where DiffArrays were the answer
17:54:04 <SamB_XP> dbueno: the whole "most-recent" version of the array is "fast"
17:54:09 <SamB_XP> except it's slow
17:54:22 <dbueno> SamB_XP: Oh, I think I see.
17:54:50 <EvilTerran> it has O(1) everywhere as long as you use it single-threadedly, but it's a very big value of 1
17:54:55 <EvilTerran> ;)
17:55:13 <SamB_XP> EvilTerran: um
17:55:19 <dcoutts> there probably is a small niche in the lookups/updates ratio where it's faster than immutable arrays but it's not one that turns up much
17:55:36 <scook0> I had some code that used DiffArrays for random-selection-without-replacement
17:55:37 <EvilTerran> ?
17:55:41 <SamB_XP> EvilTerran: it's not the 1 that's big ;-P
17:55:53 <scook0> it *might* be faster than using normal Arrays, though I never checked
17:56:07 <SamB_XP> it's a constant implied by the O(f(n)) construct
17:56:15 <EvilTerran> you know that, i know that
17:56:32 <dcoutts> scook0: but then there's also mutable arrays, so DiffArray is only right if you want to keep multiple versions of the arrays
17:56:32 <EvilTerran> anyone paying the least bit of attention knows that, seeing as 1 doesn't change particularly often
17:56:41 <EvilTerran> i was trying to make a joke, dagnabbit
17:56:47 <scook0> dcoutts: it was more that I wanted a pure interface
17:56:52 <dcoutts> scook0: and at that point, IntMap starts to look promising
17:56:58 <SamB_XP> well, I personally would just say O(2) or something
17:57:04 <byorgey> @remember EvilTerran (on DiffArray): it has O(1) everywhere as long as you use it single-threadedly, but it's a very big value of 1
17:57:04 <lambdabot> Okay.
17:57:19 <byorgey> well, I laughed =)
17:57:20 <dcoutts> scook0: since IntMap is pure, so persistent, and it's pretty fast
17:57:29 <EvilTerran> good to see *someone* appreciates my sense of humour :)
17:57:52 <scook0> dcoutts: I'm not sure if it supports efficient removal of a single random element, though
17:58:08 <scook0> (which was the problem I had)
17:58:11 <dcoutts> scook0: ok, Data.Sequence does
17:58:16 <SamB_XP> sorry, for the, uh, "grandma Bronson" response as we call it around my home...
17:59:04 <dcoutts> scook0: Data.Sequence is log n time for most operations and faster when you want to do lots of inserts in roughly the same place
18:00:32 <scook0> I wrote some non-uniform selection-without-replacement code using FingerTree, too
18:00:40 <scook0> I should get around to posting it somewhere
18:00:55 <dcoutts> ah ok, yes, Data.Sequence is just a FingerTree specialised to Int indexes
18:05:47 <davidL> does lambdabot have something equivalent to :info in ghci?
18:06:08 <oerjan> no
18:06:10 <EvilTerran> no; people were over-using it, iirc
18:06:26 <EvilTerran> but a mixture of @index, @type, @src, etc goes a long way
18:06:30 <Pseudonym> And hoogle.
18:06:37 <davidL> over-using it? you mean it was flooding the channel?
18:06:45 <EvilTerran> i believe so
18:06:48 <Pseudonym> Brings a new meaning to "TMI".
18:06:57 <davidL> ah, ok
18:07:15 <EvilTerran> Pseudonym, hehe
18:11:16 <thetallguy> Anyone know how to coerce runhaskell to accept a file without a .hs extension?
18:12:12 <sorear> thetallguy: I think there's a trac feature request
18:12:20 <thetallguy> bummer
18:14:47 <dmwit> What, GHC doesn't take - as a filename for stdin? ;-)
18:14:58 <shapr> So, what's going on?
18:15:09 <shapr> d00d, w4ssup?
18:15:10 <dmwit> Darcs 2 is out!
18:15:15 <shapr> yay!
18:15:25 <Saizan> ?index sequenceA
18:15:26 <lambdabot> bzzt
18:15:40 <oerjan> Data.Traversable
18:15:41 <Saizan> ?docs Data.Traversable
18:15:41 <lambdabot> Data.Traversable not available
18:15:44 <dmwit> Saizan: foldr (>>>) -- something like that?
18:16:04 <Saizan> dmwit: A stands for Applicative there
18:16:08 <dmwit> ah
18:16:12 <oerjan> :t Data.Traversable.sequenceA
18:16:13 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
18:17:29 <dmwit> You know what would be kind of neat, but a little scary?
18:17:48 <shapr> What?
18:17:51 <dmwit> It would be kind of neat if GHC tried to resolve name conflicts by type-checking the possible names.
18:18:11 <Saizan> it's funny how lot of Control.Monad could be written for Applicative
18:18:36 <dmwit> Yeah, Applicative is sort of "in between" Functor and Monad.
18:18:43 <oerjan> Saizan: all except a handful of functions, last we discussed it
18:18:45 <shapr> I think Cale has been wishing for Monoid -> Monad for years, why not Monoid -> Applicative -> Monad ?
18:18:49 <shapr> Er, Functor
18:18:52 <shapr> I didn't get enough sleep.
18:19:09 <gwern> 'I find its lack of control structures disturbing' http://www.crsr.net/Programming_Languages/SoftwareTools/ch1.html <-- heh
18:19:10 <lambdabot> Title: CHAPTER ONE
18:19:10 <oerjan> Saizan: if you include Alternative
18:19:35 <dibblego> gwern, that's quite amusing
18:20:01 <gwern> well, yes... er, that's why I posted it here
18:20:15 <dibblego> gwern, that's why I was approving ;)
18:20:33 <gwern> ok then. we are in agreement
18:20:40 <Cale> shapr: Functor => Monad
18:20:46 <Cale> yeah
18:20:49 <gwern> wow, some of his little programs could badly use 'interact'
18:20:50 <shapr> Right, that's what I meant.
18:21:12 <Cale> shapr: We could do the latter as well.
18:21:27 <shapr> Eh?
18:21:37 <Cale> Functor => Applicative => Monad
18:21:49 <shapr> Right, that's what I'd like.
18:21:50 <dmwit> gwern: Yeah, he's stuck thinking low-level for now.
18:21:52 <Cale> shapr: The main problem is that as you make the hierarchy finer, defining instances becomes more of a pain, since we don't have class aliases.
18:22:19 * sjanssen thinks that argument is very weak
18:22:29 <Cale> Which argument?
18:22:40 <sjanssen> that defining instances becomes more of a pain
18:22:45 <oerjan> and Alternative => MonadPlus
18:22:51 <Cale> Oh, it does. I think we should have class aliases as well.
18:22:59 * shapr rereads http://repetae.net/recent/out/classalias.html
18:22:59 <lambdabot> Title: Class Alias Proposal for Haskell
18:23:16 <Cale> (or something similar)
18:23:17 <sjanssen> you have to write just a little bit of extra code
18:23:27 * gwern looks at his 'charcount'. AUUGH MY EYES
18:23:46 <sjanssen> class aliases would be great, but we should fix the Monad hierarchy regardless of that extension
18:23:46 <OceanSpray> The Cont monad tutorial on HaskellWiki is somewhat confusing
18:23:47 <OceanSpray> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
18:24:05 <OceanSpray> it says that runCont :: (a -> r) -> r
18:24:11 <OceanSpray> but below that,
18:24:15 <gwern> > :t main =  length (getContents) >>= print
18:24:15 <lambdabot>  Parse error at "=" (column 9)
18:24:17 <oerjan> sjanssen: for Functor => Applicative => Monad, you would need 3 extra functions
18:24:19 <OceanSpray> main = runCont (square 4) print
18:24:19 <gwern> > :t let main =  length (getContents) >>= print
18:24:20 <lambdabot>  Parse error at "let" (column 4)
18:24:29 <oerjan> fmap, pure and <*>
18:24:38 <OceanSpray> in main, runCont is taking two parameters,
18:24:45 <Cale> Of course, you'd always define them in an obvious way
18:24:51 <sjanssen> oerjan: well, if Applicative => Monad, we'd get rid of return
18:24:52 <OceanSpray> while in the type declaration, it only takes one, a function
18:24:58 <sjanssen> or make it an alias for 'pure'
18:25:02 <oerjan> sjanssen: well that's true
18:25:05 <OceanSpray> am I missing something?
18:25:10 <Cale> If you had a monad, you'd just define  fmap = liftM, pure = return, (<*>) = ap
18:25:13 <sjanssen> oerjan: so two extra functions
18:25:32 <sjanssen> and, as Cale says, we can provide the defaults as library functions
18:26:03 <sjanssen> this is an acceptable cost, IMO.  Especially considering that you rarely need to define new Monads
18:26:08 <Cale> But it's still kind of irritating that you have to do that (and needlessly provide yourself a chance to screw it up)
18:26:10 <shapr> btw, what's up with haskell' ?
18:26:12 <oerjan> sure, that's the approach Traversable takes now
18:26:12 <shapr> Is it dead?
18:26:57 <dcoutts> shapr: at the Haskell Workshop they claimed it was not dead
18:27:09 <OceanSpray> no, just not released yet.
18:27:10 <shapr> What's the status/plan for haskell' ?
18:27:12 <dcoutts> shapr: So said John Launchbury
18:27:37 <sjanssen> Cale: my concern about class aliases is that it always derails discussion about Functor => Monad.  I think we need to separate the two issues
18:27:38 <gwern> shapr: when DukeNukem Forever comes out, I've heard
18:27:43 <shapr> gwern: ah
18:27:53 <oerjan> :t runCont
18:27:53 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
18:27:54 <OceanSpray> could it be a typo, and the author meant 'main = runCont ((square 4) print)'?
18:28:02 <gwern> (the committee is waiting for feedback from practical application in the DNF game engine)
18:28:07 <oerjan> OceanSpray: ^^
18:28:08 <shapr> Cale: Are there any disadvantages to Functor => Monad other than breakage of existing code?
18:28:14 <byorgey> have class aliases actually been implemented anywhere?
18:28:26 <OceanSpray> oh
18:28:30 <sjanssen> byorgey: I don't think so
18:28:33 <byorgey> and if not, how hard would it be?
18:28:39 <Cale> shapr: Nope. Monads are formally required to be functors anyway.
18:28:41 <OceanSpray> then the wiki is kind of misleading.
18:28:52 <shapr> So... who has commit access?
18:28:55 <sjanssen> byorgey: it's pretty straightforward, it can be achieved by desugaring IIRC
18:28:57 * byorgey thinks that sounds like a fun way to learn ghc-hacking... unless it would be a lot harder than it seems
18:28:57 <dcoutts> shapr: there was another presentation at HW set in the year 2042 taking a 50 look at the history of Haskell. I think on that timeline, Haskell' came out in 2020 or there abouts. augustss can correct me.
18:29:05 <shapr> dcoutts: ouch
18:29:13 <byorgey> sjanssen: ok, I thought so
18:29:23 <sjanssen> the future presentation was quite humorous
18:29:31 <Cale> I kind of stopped caring about Haskell' when it was determined that it would only be standardising what's already implemented, rather than talking about sweeping changes which need to be made to basic stuff.
18:29:45 <shapr> I wonder what changes would best expand the goodness of Haskell?
18:29:45 <dcoutts> shapr: it was a very funny presentation, if you find the video watch it. :-)
18:29:53 <shapr> Haskell' strike force?
18:30:05 <dcoutts> shapr: more cabal hackers :-)
18:30:09 <Cale> We need a Haskell 2 strike force :)
18:30:10 <shapr> Yeah, that would help.
18:30:21 <shapr> What are the biggest 'problems' with Haskell right now?
18:30:34 * shapr has meds without sleep, therefore unlimited optimism.
18:30:38 <byorgey> Lambda Company, move out!  Go! Go! Go!
18:30:54 <dcoutts> shapr: send aspiring hackers my way, I've got an endless list of things to do in Cabal/Hackage that'll really help the whole community.
18:31:05 <shapr> I sometimes think a somewhat comprehensive laziness tutorial would help newbies.
18:31:22 <Cale> My shortlist of easily fixed things includes the do-syntax translation, the fact that map isn't as polymorphic as it ought to be, the associativity of ($) being wrong.
18:31:26 <shapr> Is there a planet.bugtracker.haskell.org ?
18:31:29 <gwern> @pl showln a = show a ++  "\n"
18:31:29 <lambdabot> showln = (++ "\n") . show
18:31:54 <OceanSpray> add macros?
18:32:05 <gwern> Cale: what's wrong with $? is it how it interacts with the monad stuff like >>?
18:32:07 <dcoutts> shapr: honestly I think one of the major impediments to growth is QA in libraries. We have loads of libs but it's hard for newbies to quickly get a set of working ones.
18:32:10 <shapr> Cale: Is that all Haskell' changes? Or would ghc take those changes for 6.8++ ?
18:32:17 <OceanSpray> man, that would be crazy.
18:32:19 <shapr> dcoutts: That's an excellent point.
18:32:20 <gwern> OceanSpray: I've heard Liskell has macros
18:32:25 <Cale> gwern: No, just the associativity.
18:32:32 <dcoutts> shapr: which is why we need more people working on hackage
18:32:32 <shapr> dcoutts: What about a hackage buildbot?
18:32:39 <dcoutts> shapr: well quite
18:32:46 <Cale> Currently, if you write something like f $ g $ h $ x, that means f (g (h x))
18:32:55 <Cale> which is also covered by f . g . h $ x
18:32:55 <shapr> dcoutts: And some people allowed to do hackage NMUs.
18:33:22 <Cale> However, if you have an expression like f (g x) (h y) (k z), it's basically impossible to remove the parens.
18:33:25 <dcoutts> shapr: we can do that already, anyone can upload anything, there's no restriction. Only social convention.
18:33:25 <gwern> Cale: what's bad about that? admitedly, the 'h $ x' isn't too hot, since it makes x look like a function and not an arg
18:33:36 <shapr> 6.8.1 broke lots of libs in hackage. I locally fixed the libs HAppS uses, but I didn't send the changes to anyone.
18:33:50 <Cale> If ($) were left associative, like function application normally is, we could write that as f $ g x $ h y $ k z
18:33:57 <dcoutts> shapr: we've got plenty of ideas about what to do in that area, testing etc, we just don't have the developer resources to make it happen quickly.
18:34:15 <gwern> Cale: I... I don't really think that'd be a good idea. it looks pretty confusing to me
18:34:24 <OceanSpray> Cale, but that would break return $ whatever x
18:34:31 <Cale> no it wouldn't.
18:34:32 <dcoutts> shapr: right, that transition was handled badly, even now half the packages do not work with 6.8
18:34:34 <OceanSpray> oh wait
18:34:36 <OceanSpray> you're right.
18:34:38 <OceanSpray> nvm
18:35:00 <Cale> Wherever you currently have f $ g $ h $ x, you could replace that with f . g . h $ x
18:35:01 <dcoutts> shapr: but since we've got no automatic testing it's not something easily measurable
18:35:02 <OceanSpray> normal application is still precedent
18:35:11 <dcoutts> shapr: measurable public problems get solved quickly
18:35:23 <Cale> and if there's only one $, well, associativity isn't an issue
18:35:35 <shapr> dcoutts: So that's what we really need...
18:35:46 <dcoutts> shapr: so if hackage could show us quickly and easily what packages work with ghc-6.6/6.8 then maintainers would fix their packages quickly
18:35:47 <shapr> things to measure, and actual measurements.
18:35:57 <Cale> Also, forcing people to replace f $ g $ h $ x with f . g . h $ x has other nice benefits.
18:35:59 <dcoutts> shapr: and if they do not we can see which packages we don't need anymore
18:36:16 <Cale> The latter code is easier to refactor, since it has more well-typed substrings.
18:36:21 <shapr> Does hackage keep a count of requested packages?
18:36:32 <shapr> Would be nice to see 'number of hits' for a lib.
18:36:36 <dcoutts> shapr: as I keep saying, we have discussed this stuff a lot, we know what to do, we just don't have enough people time to do them all quickly
18:36:49 <SamB_XP> shapr: how reliable would that be?
18:36:56 <Cale> g . h is effectively a subexpression of f . g . h $ x, whereas g $ h is not a subexpression of f $ g $ h $ x, nor is it likely to be well-typed.
18:36:56 <shapr> Sounds like we need a #haskell TODO
18:37:13 <dcoutts> shapr: it's the hackage trac! :-)
18:37:15 <SamB_XP> shapr: you can make the todo plugin usable ;-)
18:37:22 <shapr> SamB_XP: Good question, I expect you to have the answer and a fix by tomorrow.
18:37:39 <dcoutts> shapr: yep, people have suggested download stats, darcs repo stats, number of packages using a package are all good stats
18:37:47 <SamB_XP> shapr: things that were expected last week take precedence!
18:37:51 <Cale> Also, writing things in that way is the first step to becoming comfortable with points-free code.
18:37:53 <shapr> dcoutts: But lacks developer resources?
18:38:14 <Cale> If you have something like bar x = f . g . h $ x, then you can instead write bar = f . g . h
18:38:18 <shapr> SamB_XP: Ok, you have until next week then.
18:38:29 <dcoutts> shapr: right, we need to advertise what are the easy tasks, or what are the interesting projects and direct devs to them
18:38:30 <shapr> Report back by December 17th.
18:38:37 <SamB_XP> shapr: over things expected tomorrow, I mean
18:38:50 <dcoutts> shapr: infrastructure should be fun because you're making something that everyone will use
18:39:03 <shapr> Yeah, true.
18:39:05 <dcoutts> shapr: and the code does not need to be ugly, there's some nice stuff
18:39:31 <dcoutts> eg, how can you make Cabal pure, rather than all IO ?
18:39:41 <dcoutts> that's a very interesting problem
18:39:55 <shapr> I saw some opportunities for prettiness when investigating a local darcs repo source, but I didn't fix them.
18:40:10 <shapr> Well, I'm not doing anything now.. How does ghc's buildbot work?
18:40:31 <dcoutts> shapr: I was thinking of something with more coverage than a build bot
18:40:38 <dcoutts> shapr: think bigger! :-)
18:40:53 <dcoutts> shapr: what's the best way of getting testing on all the platforms that people use?
18:41:06 <shapr> I was thinking of something I could have working in 1.5 hours :-)
18:41:12 <SamB_XP> SPYWAREZ, duh
18:41:28 <dcoutts> SamB_XP: yeah, something like that :-)
18:41:33 <sjanssen> yes, a botnet!
18:41:39 <shapr> dcoutts: hackagetest hackage package that builds all packages and POSTs results to haskell.org
18:41:40 <dcoutts> shapr: well we already do have hackage do builds of each package that's uploaded
18:42:00 <TomMD> We could call it "LambdaNet"
18:42:11 <shapr> dcoutts: Er, you said you don't know which packages were broken by 6.8.1 ?
18:42:12 <sjanssen> we've always said that Haskell has weak Windows support -- just give each Haskell hacker a few trojaned Windows boxes
18:42:12 <dcoutts> shapr: but the results are not very helpful because they are not emailed anywhere and if the build machine does not have some C lib installed then the build fails
18:42:40 <gwern> if a build fails, but no one is notified, do end-users still suffer? :)
18:43:01 <shapr> gwern: I think so.
18:43:14 <SamB_XP> gwern: well, it depends on if an end user did the build or not
18:43:29 <dcoutts> shapr: so I was thinking, just get cabal-install to report build success/failure back to hackage which can collect the stats
18:43:38 <SamB_XP> if it was just done by an uncommunicative buildbot, it won't make anyone suffer
18:44:07 <dcoutts> shapr: with enough information to identify trends and pick out platform combinations that work or don't work.
18:44:45 <shapr> SamB_XP: Are you working on your #haskell homework? ;-)
18:44:59 * shapr throws sugar lambdas at SamB_XP
18:45:02 <SamB_XP> shapr: how many credits is #haskell again?
18:45:12 <shapr> I dunno, the number of hours seems infinite.
18:45:30 <SamB_XP> yeah, but where I go the credits and hours seem to be related in a strange way
18:45:45 <SamB_XP> since the lecture courses have more credits but take less time
18:45:59 <shapr> On the other hand, I've gotten a surprising amount of paying work out of #haskell social connections.
18:46:27 <SamB_XP> as it happens, in slightly over a week I'll be done with finals...
18:46:32 <SamB_XP> i.e. my last one is on tuesday...
18:47:09 <gwern> shapr: someone has actually made money off haskell? I'm impressed
18:47:23 <shapr> gwern: It's easier than you might think.
18:47:24 <SamB_XP> gwern: no, but they decided to pay him anyway
18:47:45 <shapr> Actually, there's a new Haskell company...
18:47:56 * SamB_XP is kidding, in case you can't tell
18:48:00 <shapr> But I don't know if I should disseminate that sort of info...
18:48:39 <shapr> dcoutts: Does hackage have some sort of admin page that would show that sort of posted info?
18:48:41 <gwern> shapr: it wouldn't happen to be called Galois, would it? :)
18:48:42 * shapr digs around...
18:48:51 <dcoutts> shapr: hmm?
18:49:08 <Cale> gwern: No, that'd be one everyone already knows about :)
18:49:08 <shapr> gwern: Nope, this is one I hadn't heard of two weeks ago.
18:49:32 <dcoutts> shapr: I'd put that sort of testing info on each package's page, perhaps with some summary pages for comparing different packages.
18:49:44 <shapr> ok
18:49:52 <dcoutts> shapr: hackage should be running on happs really :-)
18:50:00 <shapr> Yeah well...
18:50:03 <thetallguy> shapr: you talking about SeeReason?
18:50:04 <Cale> gwern: Actually, there are a number of financial companies using Haskell.
18:50:22 <shapr> thetallguy: Nope, hadn't heard of them.
18:50:30 <dcoutts> shapr: it's a big db managing users, various kinds of requests and possibly email too in future
18:50:58 <thetallguy> shapr: okay, well I just sent in the new blurb to HC&A about us, replacing the Linspire blurb
18:51:12 <dcoutts> shapr: and it needs fast serving of static files (the .tar.gx packages)
18:51:14 <shapr> thetallguy: spiffy
18:51:22 <shapr> dcoutts: Yeah, HAppS could do that.
18:51:34 <thetallguy> shapr: so you're talking about someone else?  Excellent, if so.
18:51:45 <shapr> thetallguy: Yep, someone else.
18:52:07 <shapr> Anyway... code!
18:52:35 <thetallguy> shapr: why do you kep changing colors?
18:53:26 <shapr> thetallguy: Maybe it's when I address you with your nickname?
18:53:30 <shapr> and then when I don't?
18:53:49 <tttz> Exposure to illicit substances.
18:54:03 <shapr> Hiya tttz, did I see you yesterday?
18:54:38 <shapr> Weren't you in Medford?
18:58:11 <thetallguy> shapr: nice guess.  Sure wish this IM client had a manual
19:00:46 <njbartlett> Cale: Well, 1 is "a number" I suppose ;-)
19:01:17 <Cale> njbartlett: I thought it was at least two? Maybe I'm mistaken :)
19:01:40 <njbartlett> Cale: I only know about Credit Suisse...
19:01:49 <SamB_XP> how about Jane Street?
19:02:00 <SamB_XP> or do they just use Haskell in ads?
19:02:27 <njbartlett> SamB_XP: They use OCaml. But they will hire somebody with Haskell knowledge
19:05:19 <hpaste>  (anonymous) annotated "Removing the 'x' point from ltSqrt significantly increases performance?" with "(no title)" at http://hpaste.org/4354#a1
19:05:23 <Cale> http://www.hrg.net/index.php/job_post/view/123 -- I wonder if this is a posting for Credit Suisse.
19:07:04 <njbartlett> Cale: I think so. The job description looks identical to this one: https://creditsuisse.taleo.net/servlets/CareerSection?art_ip_action=FlowDispatcher&flowTypeNo=13&pageSeq=2&reqNo=53820&art_servlet_language=en&selected_language=en&csNo=10020#topOfCsPage
19:07:05 <lambdabot> http://tinyurl.com/2h2vh7
19:07:10 <njbartlett> Ooh nice URL
19:07:22 <Cale> ah, okay
19:07:44 <Cale> Heh, I wonder if any other language parameters work.
19:08:45 <Cale> Changing the selected_language to es gives "This opportunity is no longer available" :)
19:08:55 <njbartlett> Discrimination!!
19:08:57 <SamB_XP> heh
19:09:14 <SamB_XP> njbartlett: I'm pretty sure it's more like "silly programming"
19:15:43 <ddarius> SamB_XP: Institutionalized discrimination
19:15:45 <shapr> @where seereason
19:15:46 <lambdabot> I know nothing about seereason.
19:15:59 <shapr> thetallguy: Where's SeeReason? Do you have anything mentioning Haskell on your site?
19:21:55 <gwern> 250k to 350k? I guess the financial types really value their programmers then
19:26:27 <SamB_XP> gwern: they probably saw jurassic park or something
19:26:47 <ddarius> Worried about raptors?
19:26:48 <dfranke_> WEEEE!
19:26:48 <dfranke_> Mon Dec 10 09:22:12 EST 2007  Ian Lynagh <igloo@earth.li> * Bump version number to 6.8.2 and set RELEASE=YES
19:27:23 <SamB_XP> ddarius: worried about disgruntled programmers making being bought out somehow or other
19:27:36 <SamB_XP> s/making //
19:27:50 <gwern> ddarius: I cringe before raptors. They run 10 meters a second and do not fear death
19:28:10 <gwern> SamB_XP: pretty reasonable, I guess. a little downtime could be a lot of money I suppose
19:28:42 <gwern> of course, you'd need 250k just to live in NYC! *ba dum shing*
19:29:07 <SamB_XP> I meant in the sabatoge/spying sense
19:29:09 <byorgey> dfranke_: hooray!
19:29:11 <nolrai> is there a wait command in haskell?
19:29:23 <ddarius> fix id
19:29:24 <gwern> 'sleep' maybe?
19:29:57 <ddarius> @hoogle threadDelay
19:29:58 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
19:29:58 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
19:30:14 <gwern> @hoogle sleep
19:30:14 <lambdabot> No matches found
19:30:23 <gwern> (phooey)
19:30:54 <ddarius> @where phooey
19:30:54 <lambdabot> http://conal.net/phooey/
19:33:55 <nolrai> thanks ddarous.
19:35:59 <xelxebar> Using Haskell, how could one go about writing an arbitrary set of bits to a file?
19:37:17 <SamB_XP> xelxebar: there are only ... um ...
19:37:20 <SamB_XP> 4 sets of bits...
19:37:20 <TSC`> I guess you could put them into Word8 values and then write those to the file
19:37:57 <monochrom> Data.Binary ?
19:40:15 <scook0> SamB_XP: I see what you did there
19:40:28 <OceanSpray> What do Reader and Writer do?
19:40:31 <nolrai> convert them to a string.
19:40:41 <thoughtpolice> xelxebar: data.binary if you mean as in seralization of haskell values.
19:40:57 <ddarius> OceanSpray: Rephrase your question.
19:41:15 <OceanSpray> :t Reader
19:41:16 <lambdabot> forall r a. (r -> a) -> Reader r a
19:41:21 <ddarius> @src Reader
19:41:22 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:41:28 <ddarius> @src Writer
19:41:28 <lambdabot> Source not found. You type like i drive.
19:41:31 <ddarius> @src ReaderT
19:41:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:41:34 <OceanSpray> I don't get what they're for.
19:41:37 <nolrai> Reader reads from an evironment.
19:41:49 <ddarius> They are (trivial) data constructors.
19:41:53 <SamB_XP> Writer writes to a Monoid
19:42:09 <OceanSpray> now back up a minnit here
19:42:12 <scook0> e.g. if you have a lot of computations that require a context
19:42:22 <scook0> you might express them in the Reader monad
19:42:37 <SamB_XP> OceanSpray: what?
19:42:39 <nolrai> I've used it quite a lot.
19:42:44 <OceanSpray> say I was writing an interpreter...
19:42:55 <SamB_XP> OceanSpray: are you telling me you don't know what a Monoid is?
19:42:56 <OceanSpray> the Reader would handle environments?
19:43:01 <OceanSpray> SamB, yes.
19:43:09 <OceanSpray> I don't know what a Monoid is.
19:43:55 <xelxebar> okay, it doesn't seem that Data.Binary is capable of writing some arbitrary stream of bits to a file, is that correct?
19:44:05 <ddarius> xelxebar: Sure it is.
19:44:12 <ddarius> (capabable)
19:44:28 <ddarius> OceanSpray: Know what a list is?
19:44:32 <OceanSpray> yeah
19:44:34 <SamB_XP> OceanSpray: hehe. usually with Writer it is something that you can concatenate together...
19:44:42 <ddarius> OceanSpray: Know what a fold is?
19:44:46 <OceanSpray> ddarius, I'm not THAT nubbish.
19:44:49 <OceanSpray> yes.
19:44:59 <ddarius> OceanSpray: Then you know what a monoid is.
19:45:06 <SamB_XP> ddarius: oh?
19:45:07 <OceanSpray> a folded list?
19:45:14 <nolrai> realy?
19:45:18 <xelxebar> ddarius, would you mind giving an example where you write, say 10111 out to a file?  Please forgive my ignorance
19:45:47 <SamB_XP> OceanSpray: if you have a monoid, you can use it to do a right or left fold
19:46:08 <OceanSpray> oookay.
19:46:09 <ddarius> Data.Binary does two things.  It has a convenient interface for serializing values but you have no control over the format, and it has operations for reading and writing words.
19:46:20 <OceanSpray> what's wrong with foldr or foldl?
19:46:22 <nolrai> so how is it diferent from a Foldable?
19:46:33 <scook0> mathematically, a monoid is a set, an associative binary operation on that set, and an identity element for that operation
19:46:37 <ddarius> @src Monoid
19:46:38 <lambdabot> class Monoid a where
19:46:38 <lambdabot>     mempty  :: a
19:46:38 <lambdabot>     mappend :: a -> a -> a
19:46:38 <lambdabot>     mconcat :: [a] -> a
19:46:53 <scook0> for lists, the operation is (++) and the identity element is []
19:46:55 <SamB_XP> @src mconcat
19:46:55 <lambdabot> Source not found. stty: unknown mode: doofus
19:46:58 <ddarius> mempty `mappend` x = x = x `mappend` mempty
19:47:02 <SamB_XP> and mconcat is that fold
19:47:02 <pa-ching> How do I convert Int32 to Int?
19:47:10 <scook0> pa-ching: fromIntegral
19:47:16 <ddarius> (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
19:47:28 <pa-ching> scook0: Thanks!
19:48:06 <SamB_XP> > do write 1; write 2 :: Writer Int a
19:48:07 <lambdabot>   Not in scope: `write'
19:48:19 * SamB_XP forgot the method name
19:48:23 <nolrai> isn't tell?
19:48:34 <SamB_XP> > do tell 1; tell 2 :: Writer Int a
19:48:34 <lambdabot>   Writer Int a
19:48:34 <lambdabot>       Inferred type: Writer Int ()
19:48:34 <lambdabot>     In the expression: tell...
19:48:45 <SamB_XP> > do tell 1; tell 2 :: Writer Int ()
19:48:45 <lambdabot>        add an instance declaration for (Show (Writer Int ()))
19:48:56 <ddarius> Lists are the free monoid.  Every other monoid can be "reached" by mapping then folding a list.  Usually you'd want a more specific fold :: (a -> a -> a) -> a -> [a] -> a where the first argument is required to be associative.
19:49:00 <SamB_XP> > runWriter (do tell 1; tell 2 :: Writer Int ())
19:49:01 <lambdabot>   add an instance declaration for (Monoid Int)
19:49:01 <lambdabot>     In the expression: tell 1
19:49:01 <lambdabot> ...
19:49:06 <SamB_XP> aww.
19:49:25 <scook0> > runWriter (do tell [1]; tell [2] :: Writer [Int] ())
19:49:26 <lambdabot>  ((),[1,2])
19:50:21 <clanehin> I would like to hear any criticism regarding my ideas about a replacement numeric prelude: http://hpaste.org/4377
19:50:25 <scook0> > runWriter (do tell (Sum 1); tell (Sum 2) :: Writer (Sum Int) ())
19:50:26 <lambdabot>  ((),Sum {getSum = 3})
19:50:49 <nolrai> @ty runReader
19:50:50 <lambdabot> forall r a. Reader r a -> r -> a
19:51:31 <SamB_XP> clanehin: isn't that awfully short?
19:51:49 <clanehin> yeah it's just a rough start right now
19:52:14 <SamB_XP> strange way of doing modulo...
19:52:17 <scook0> clanehin: I'm concerned about the semantics of NumberDivide
19:52:40 <SamB_XP> oh, ick, ys
19:52:40 <ddarius> Scathing commentary on the current numeric prelude: "I propose to improve the current situation with module NumericPrelude where {}"
19:52:42 <SamB_XP> yes
19:52:56 <clanehin> scook0: how so?
19:53:09 <scook0> well, you've given an instance for Int in terms of div
19:53:13 <SamB_XP> clanehin: you are defining it for Int!
19:53:18 <SamB_XP> that's flat-out WRONG
19:53:27 <scook0> what's the implementation for Float/Double going to do?
19:54:02 <scook0> if your answer isn't "truncating division", then there's an inconsistency already
19:54:43 <SamB_XP> ddarius: I don't think that is an improvement
19:54:54 <scook0> basically, integers shouldn't expose an operation that doubles would implement as true division
19:54:55 <nolrai> isnt div truncateing divison?
19:54:57 <smack_> clanehin: have you seen http://hackage.haskell.org/trac/haskell-prime/wiki/NumericClasses
19:54:57 <SamB_XP> see... it doesn't let you do anything, and that's kind of a problem
19:54:58 <lambdabot> Title: NumericClasses - Haskell Prime - Trac
19:55:28 <clanehin> Actually, I agree.  I should take that out.  If that's the worst complaint, I'm not too worried.
19:55:31 <ddarius> SamB_XP: It would make it easier to build your own.  That may be an improvement itself.
19:55:32 <clanehin> smack_: yes
19:55:49 <SamB_XP> ddarius: isn't that what NumericPrelude should be?
19:56:07 <OceanSpray> Once again, I have some questions, which may annoy the heck out of you by now.
19:56:27 <ddarius> OceanSpray: Many have tried to try #haskell's patience.  Few have succeeded.
19:56:38 <OceanSpray> You've seen my apply Add function
19:56:46 <OceanSpray> it's atrocious.
19:56:46 <SamB_XP> clanehin: so... why isn't there a divmod?
19:57:12 <OceanSpray> and you've suggested that I put all that environment and continuation passing into a monad, LispM
19:57:15 <SamB_XP> quotrem?
19:57:24 <OceanSpray> for simpler code and the ability to use do notation, of course.
19:57:34 <clanehin> SamB_XP: same reason there aren't instances for Float, Rational, etc, I wanted an opinion before I went through and definted everything and found out something was horribly wrong with the whole idea
19:57:58 <SamB_XP> also, you should call mod mod
19:58:04 <SamB_XP> not /%
19:58:10 <OceanSpray> But, is that still possible if I have to have _access_ to the environment and the continuation, to bind them in a new environment to be passed into a user-created procedure?
19:58:31 <ddarius> OceanSpray: Sure.
19:58:32 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/4378
19:58:44 <OceanSpray> that function is what I'm talking about.
19:58:44 <clanehin> \me will remember not to fix things that aren't broken
19:59:03 <OceanSpray> the code in that case of apply is very different from the others.
19:59:20 <ddarius> OceanSpray: That's no problem.
19:59:48 <SamB_XP> clanehin: yes, it is mostly a matter of arranging things in classes and possibly adding a few new things...
19:59:51 <OceanSpray> Oh?
20:00:34 <ddarius> Using monads doesn't remove functionality, it just exposes it in a different way.
20:01:10 <clanehin> I'll keep working then, thanks all for comments
20:01:39 <OceanSpray> Hmm
20:02:11 <btsdev> i'm sorry if this is a retarded question, but i'm typing exactly what a few haskell tutorials online are telling me to, at gchi, but i keep getting :1:4: Not in scope: `functionName' while trying to define functions.   what am i supposed to type before something like  functionName :: [a] -> a   ?
20:02:28 <loupgaroublond> btsdev: in ghci use let
20:02:29 <OceanSpray> use 'let'
20:03:10 <monochrom> Most tutorials tell you to put things in files, not type at ghci, I believe.
20:03:10 <allbery_b> you can't define functions at the ghci prompt, except by using let (which is temporary).  generally you put the definitions in files and load those into ghci
20:03:12 <btsdev> loupgaroublond: i tried that.  but then i get the same error
20:03:37 <btsdev> allbery_b: yeah i am just trying to make lots of temporary functions to learn though
20:03:38 <loupgaroublond> you have to do it all at once, it interprets a newline as an excuse to start processing what you said
20:03:42 <allbery_b> at the prompt you would have to say:  let function :: [a] -> a; function foo = ...
20:03:45 <allbery_b> all on one line
20:03:48 <btsdev> ohhh
20:03:54 <btsdev> touche
20:03:55 <btsdev> thanks
20:04:06 <nolrai> but it should work in the file.
20:04:17 <btsdev> got it.  thank you everyone
20:04:30 <nolrai> yeah that cought me the first time too.
20:09:42 <nolrai> @ty foldMap
20:09:43 <lambdabot> Not in scope: `foldMap'
20:10:04 <TSC`> fold map ?
20:10:12 <nolrai> @ty Data.Foldable.foldMap
20:10:13 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
20:10:19 <TSC`> Ah
20:10:24 <nolrai> @ty Data.Foldable.fold
20:10:25 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
20:11:41 <nolrai> @ty Data.Traversible.traverse
20:11:42 <lambdabot> Couldn't find qualified module.
20:11:46 <nolrai> @ty Data.Traversable.traverse
20:11:47 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:14:08 <shapr> hiya tttq
20:15:54 <Nafai> shapr!
20:17:11 <tttq> sharp harps
20:18:06 <nolrai> mappend needs to be associative, right?
20:18:12 <shapr> Nafai!
20:18:24 <monochrom> yes
20:18:33 <shapr> tttq: Learning Haskell?
20:18:53 <Nafai> shapr: How's it going?  You've been absent lately...
20:19:10 <shapr> Nafai: Yeah, I'll tell you about it later.
20:19:23 <Nafai> shapr: Okay.
20:19:32 <Pseudonym> Sounds ominous.
20:19:46 <Nafai> shapr: I've made some progress in my Haskell learnin'!
20:19:54 <shapr> Cool! Whatcha been doin?
20:20:23 <Nafai> More Project Euler stuff
20:20:32 <shapr> Spiffy, what's the url to your profile?
20:21:51 <Nafai> http://pastebin.com/m184bcc90 <- My latest
20:22:38 <nolrai> how is traverse diffrent then fmap, again?
20:23:14 <Nafai> shapr: http://projecteuler.net/index.php?section=profile&profile=19494
20:23:15 <lambdabot> Title: Project Euler
20:23:36 <nolrai> never mind.
20:23:46 <shapr> Nafai: ooh, I have to catch up!
20:43:08 <OceanSpray> does passing around environments warrant a monad?
20:45:26 <dmwit> The Reader monad is nice for that.
20:46:03 <ddarius> OceanSpray: It's up to you.  Usually if you already have one, you might as well.  It does make your code more change resistant.
20:47:45 <ddarius> Good ole Frakn.
20:47:47 <ddarius> er Frank
20:48:31 <OceanSpray> ha ha oh wow
20:48:58 <OceanSpray> the LispEnvM monad I was drafting looks just like the Reader monad
20:49:15 <OceanSpray> man, that's weird.
20:49:22 <ddarius> Not really
20:49:26 <SamB_XP> OceanSpray: that does not surprise me in the slightest
20:49:33 <ddarius> There aren't too many obvious ways of implementing that.
20:49:39 <btsdev> i realize this function i'm writing probably already exists, but can someone comment quickly as to how I can tell Haskell that this shouldn't run infinitely?   dupe 1 = \a -> a; dupe n = \a -> dupe (n-1) (a:[a])
20:49:47 <SamB_XP> that kind of thing happens a lot to people new to the MTL...
20:50:00 <ddarius> s/MTL/Haskell libraries
20:50:16 <SamB_XP> ddarius: I meant a more specific kind of thing ;-)
20:50:18 <nornagon> @pl \x -> x == ((intSqrt x)^2)
20:50:18 <lambdabot> ap (==) ((^ 2) . intSqrt)
20:50:19 <nolrai> Monad Type Librarie?
20:50:30 <allbery_b> monad transformer library
20:50:31 <ddarius> Monad Template Libraries
20:50:41 <allbery_b> or template, depending on who you talk to
20:50:47 <dmwit> btsdev: That doesn't really type-check, perhaps you want replicate?
20:50:51 <nolrai> even though there not templates>
20:50:53 <dmwit> > replicate 5 "foo"
20:50:54 <lambdabot>  ["foo","foo","foo","foo","foo"]
20:51:00 <ddarius> The name is from a bygone era.
20:51:16 <btsdev> hm i guess that's the function i was trying to write myself :)
20:51:18 <SamB_XP> nolrai: but it rhymes with STL that way ;-)
20:51:26 <nornagon> @instances Monad
20:51:28 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:51:33 <dmwit> btsdev: The compiler isn't complaining that the function runs forever; it was complaining that the *type* for the function is infinite.
20:51:46 <dmwit> (because you've written it slightly incorrectly)
20:51:51 <btsdev> hm okay
20:51:59 <nornagon> :t ap (==) -- is this using the ((->) r) monad?
20:51:59 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
20:52:06 <dmwit> btsdev: When you write (a:[a]) -- this bit is bad, here's why.
20:52:17 <btsdev> dmwit: okay
20:52:27 <dmwit> btsdev: Let's say that "a :: Int".  Then "[a] :: [Int]".  Right?
20:52:34 <btsdev> dmwit: yeap
20:52:44 <btsdev> dmwit: i see where you're going
20:52:46 <dmwit> ok
20:52:56 <dmwit> [[[[....Int]]]]....
20:52:58 <dmwit> =)
20:53:10 <btsdev> dmwit: yea :)  so what should I be saying?
20:53:11 <nolrai> > 1 : [1]
20:53:12 <lambdabot>  [1,1]
20:53:33 <nolrai> let f = a : [a] in f 2
20:53:39 <nolrai> > let f = a : [a] in f 2
20:53:39 <lambdabot>   Not in scope: `a'
20:53:45 <nolrai> > let f a = a : [a] in f 2
20:53:45 <lambdabot>  [2,2]
20:53:49 <dmwit> > let dupe 0 a = []; dupe n a = a : dupe (n - 1) a in dupe 5 "foo"
20:53:50 <lambdabot>  ["foo","foo","foo","foo","foo"]
20:54:06 <btsdev> dmwit: awesome.  thank you.  i will look at that
20:54:23 <btsdev> dmwit: appreciate your help
20:54:30 <dmwit> btsdev: good luck =)
20:54:33 <btsdev> ty
20:56:24 <shapr> @seen bringert
20:56:24 <lambdabot> I saw bringert leaving #haskell 3h 32m 28s ago, and .
20:56:27 <shapr> foo
20:56:47 <shapr> Whoa, I haven't seen flippo here in a very long time.
20:58:24 <lament> he's here all the time
20:58:30 <lament> well, except now :)
20:59:06 <lament> just never says anything
20:59:44 <shapr> I'll poke him next time I see him.
21:01:16 <dmwit> *poke*
21:01:19 <dmwit> *puke*
21:04:55 <shachaf> nornagon: Yes.
21:05:13 <shachaf> nornagon: (And in (r ->), ap is S.)
21:08:02 <ddarius> and return is K
21:08:39 <bos> @seen dons
21:08:40 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 3h 47m 49s ago.
21:39:05 <OceanSpray> My environment is made up of an IORef (Map String LispVal)
21:39:22 <ari> :t many
21:39:30 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
21:39:31 <dmwit> I'm willing to bet the Map is your environment, and the IORef is just incidental. ;-)
21:39:35 <OceanSpray> but the Reader monad's 'asks' function isn't IO something,
21:39:49 <OceanSpray> so how do I put that in?
21:40:21 <OceanSpray> well, the environment has to be mutable, hence the IORef
21:41:51 <dmwit> Well there's two real options.
21:42:08 <dmwit> One is to use a ReaderT, but often what is better
21:42:20 <dmwit> is to read the IORef, then enter the Reader monad.
21:42:30 <OceanSpray> hmm
21:42:44 <OceanSpray> lookin at this site: http://ogi.altocumulus.org/~hallgren/Programatica/tools/pfe.cgi?Control.Monad.Reader
21:42:46 <lambdabot> Title: 15 Control.Monad.Reader 8, http://tinyurl.com/22d3lg
21:42:55 <OceanSpray> I get the sense that MonadReader would fix that
21:43:08 <OceanSpray> Is that a red herring?
21:43:36 <OceanSpray> I mean, its 'asks' is of type :: m r, which I can make into IO LispVal, right?
21:43:48 <dmwit> ...
21:44:00 <dmwit> Only if you have IO is an instance of MonadReader.
21:44:04 <dmwit> (which it's not)
21:44:30 <OceanSpray> I'm ookay.
21:44:45 <OceanSpray> disregard that.
21:44:56 <allbery_b> ReaderT IO would be an instance of MonadReader though.  (but do you really need to be in IO there?)
21:45:47 <OceanSpray> My mind feels like it's being bent, and on the verge of tearing.
21:46:25 <OceanSpray> what you're saying is,
21:46:31 <OceanSpray> have IO be an 'outside' monad,
21:46:47 <OceanSpray> wait, what?
21:47:24 <allbery_b> ReaderT is a version of Reader which can "wrap" another monad
21:47:54 <allbery_b> when in ReaderT you can use lift to run something in the wrapped monad
21:48:26 <OceanSpray> I know that.
21:49:11 <OceanSpray> so using ReaderT (Some IO-related monad) would let me pass a function :: a -> IO b into asks?
21:49:48 <allbery_b> I don't think you'd evr want to do that
21:50:22 <allbery_b> the "s" stands for "selector"; usually a field selector for a record which is the state of the Reader(T)
21:51:09 <OceanSpray> my state is an IORef Map
21:51:11 <allbery_b> "ask" returns the entire state; "asks" lets you select a part of the state instead of the whole thing
21:51:26 <OceanSpray> oh, I see what you mean now
21:51:47 <OceanSpray> use 'ask' to get the IORef Map, and then do the IO action to read from it and extract the value?
21:52:02 <allbery_b> yes
21:53:29 <allbery_b> (I have something similar with a bunch of IORefs (laong with static state) in a record and have a wrapper which does \s -> asks s >>= lift . readIORef)
21:55:21 <allbery_b> bleh.  hpaste needs search capabil;ity :)
21:55:32 <allbery_b> @go site:hpaste.org askr
21:55:33 <dmwit> google site:hpaste.org
21:55:33 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:55:44 <allbery_b> ...or not
21:56:14 <dmwit> http://hpaste.org/3137
21:56:16 <OceanSpray> google site:http://hpaste.org "askr"
21:56:29 <dmwit> site:hpaste.org also works
21:57:48 <unmarshal> ls
21:58:47 <dmwit> classes applications Desktop Maildir programming sources rcc
21:58:51 <dmwit> ~]
22:00:00 <allbery_b> pity it doesn't play nice with LB though
22:02:44 <OceanSpray> :t ReaderT
22:02:45 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
22:03:29 <ddarius> :k ReaderT
22:03:31 <lambdabot> * -> (* -> *) -> * -> *
22:03:57 <allbery_b> @unmtl ReaderT
22:03:57 <lambdabot> err: No applications
22:04:02 <allbery_b> oh well
22:04:32 <ddarius> As the error says, you have to apply it to a type (actually two types and a type constructor)
22:04:36 <allbery_b> yeh
22:04:50 <allbery_b> @unmtl ReaderT s IO a
22:04:51 <lambdabot> s -> IO a
22:05:18 <dmwit> Gotta know the answer to ask that question. =P
22:05:26 <OceanSpray> huh
22:05:35 <allbery_b> I was hoping it would unroll a generic one with type vars
22:05:43 <allbery_b> like s -> m a
22:06:20 <ddarius> @unmtl ReaderT s m a
22:06:20 <lambdabot> s -> m a
22:06:46 <allbery_b> right, just thinking it might know to use s m a as "defaults"
22:08:11 <ddarius> :t runReaderT
22:08:17 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
22:15:33 <OceanSpray> do they have an IO monad transformer?
22:15:44 <dmwit> no
22:15:48 <dmwit> Such a thing is not possible.
22:23:57 <nolrai> > (return () >>= putString "1")
22:24:05 <lambdabot>   Not in scope: `putString'
22:24:12 <nolrai> > (return () >>= putStrLn "1")
22:24:13 <lambdabot>  Couldn't match expected type `() -> m b'
22:24:45 <nolrai> ok
22:25:08 <dmwit> > return () >>= const (putStrLn "1")
22:25:10 <lambdabot>  <IO ()>
22:25:18 <dmwit> > return () >> putStrLn "1" -- equivalent
22:25:19 <lambdabot>  <IO ()>
22:25:56 <nolrai> yeah just wanted to test if the wraping const was needed.
22:35:44 <nolrai> hey is there a way to use ghc to get at somthings type if ghci doesn't work?
22:35:55 <nolrai> (i.e. crashes)
22:36:03 <smack_> nolrai: what sort of crash?
22:36:05 <Heffalump> write x = expr :: Int in a program
22:36:07 <Heffalump> and then read the type error
22:36:13 <nolrai> on start up.
22:36:35 <nolrai> thats smart.
22:36:59 <Plareplane> if you said what the crash message was it might help in figuring out why
22:37:44 <nolrai> <interactive>:1:84: Not in scope: `IO.stderr'
22:37:45 <nolrai> ghc-6.6: panic! (the 'impossible' happened)
22:37:47 <nolrai>   (GHC version 6.6 for x86_64-unknown-linux):
22:37:48 <nolrai>         interactiveUI:flush
22:38:23 <OceanSpray> well, damn.
22:40:01 <nolrai> i should report it but ..
22:40:11 <OceanSpray> this is what I got right now:
22:40:12 <OceanSpray> * Yuno has quit (Read error: Connection reset by peer)
22:40:12 <OceanSpray> <InfinityB> either
22:40:12 <OceanSpray> <Plareplane> what does the extension do anyway
22:40:12 <OceanSpray> <InfinityB> no idea
22:40:12 <OceanSpray> <InfinityB> i just installed it
22:40:13 <OceanSpray> <InfinityB> lets see what happens
22:40:15 <OceanSpray> <InfinityB> it does a bunch of gay shit
22:40:27 <Plareplane> wrong channel oceanspray :(
22:40:56 <OceanSpray> I'm really sorry
22:41:24 <OceanSpray> xchat automatically copies whatever I select
22:41:46 <OceanSpray> type LispRet = ErrorT LispErr (ReaderT LispEnv (ContT LispVal (IO . Maybe) LispVal) LispVal) LispVal
22:42:26 <OceanSpray> that... can't be right, can it?
22:43:12 <nolrai> wow
22:43:29 <OceanSpray> I know.
22:45:01 <nolrai> ok ErrorT is * -> * -> * right?
22:45:23 <OceanSpray> takes three, yes
22:45:29 <nolrai> or is it * -> * -> * -> *?
22:45:33 <nolrai> ok
22:46:07 <nolrai> I think you want to drop the two iner LispVals
22:46:12 <nolrai> Inner
22:46:31 <OceanSpray> oh, right
22:46:34 <rumbleca> anyone build ghc 6.8.1 lately on freebsd amd64? ghci is core dumping on me
22:46:58 <roger`> i have a ghci coredump on i386 linux sometimes
22:46:58 <Zao> rumbleca: Unfortunately not, since the port doesn't support 7.0 yet.
22:47:28 <nolrai> and my ghci also crashes.
22:48:34 <rumbleca> hmm, I didn't try any ports, I was just building from source.... I don't think the port supports amd64 either
22:48:47 <dfranke_> rumbleca: 6.8.2 is actually out, it just hasn't been announced yet.  Try that.
22:48:55 <OceanSpray> how about 'type LispRet a = ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a'
22:49:11 <OceanSpray> where I'm going to pass (Maybe LispVal) into LispRet as a
22:50:00 <nolrai> thats easer to read any way
22:50:12 <rumbleca> I will dfranke_, thanks
22:50:52 <Shimei> So I was teaching some people about OOP and had a thought. Is it possible to statically check if a method will cause mutation in some kind of OOP system without introducing ideas like monads and such?
22:51:28 <Zao> In other news, the cross compiling guide on the wiki seems somewhat inaccurate.
22:51:35 <loupgaroublond> Shimei: append a ! to the end of the method name
22:51:45 <Shimei> loupgaroublond: But can you statically enforce that?
22:51:54 <Shimei> (that's what I was thinking about actually)
22:51:57 <loupgaroublond> of course not
22:52:10 * loupgaroublond is probably wrong
22:54:11 <Plareplane> nolrai, i wonder if it's related to this: http://hackage.haskell.org/trac/ghc/ticket/1001
22:54:14 <lambdabot> Title: #1001 (&#34;ghc-6.6: panic! (the 'impossible' happened) interactiveUI:flush&#34; ...
22:55:08 <fatman999> hello, i am fat man and i weigh 400 pounds!  you can see video of my supreme fatness at fat-man.bravehost.com
22:55:20 <OceanSpray> apparently, I can't use (.) to compose type constructors.
22:55:22 <nolrai> I know my instilation is screwd up but dont understand this OS.
22:55:27 <OceanSpray> well, dang.
22:55:57 <nolrai> you can but not in pattern maches
22:56:11 <nolrai> wait _type_ constructors
22:56:32 <OceanSpray> whatever, it compiled now
22:56:34 <faxathisia> OceanSpray: How did you solve the problem without .?
22:56:51 <OceanSpray> type LispRet = ErrorT LispErr (ReaderT LispEnv (ContT (Maybe LispVal) IO)) (Maybe LispVal)
22:57:12 <faxathisia> ah.. you wanted to use (.) in a type definition
22:57:13 <OceanSpray> I used to have (IO . Maybe) in the middle there.
22:57:19 <faxathisia> I don't think that makes any sense
22:57:35 <faxathisia> for example, what would ++ mean in there?
22:57:42 <faxathisia> (since . is just a function like any other)
22:57:49 <OceanSpray> well, I have no idea.
22:58:00 <thoughtpolice> Maybe's a type, Just and Nothing are the constructors.
22:58:03 <smack_> OceanSpray: . composes functions, not types
22:58:04 <faxathisia> basicallyy.. That's not haskell
22:58:08 <faxathisia> that's Haskell Type System
22:58:16 <thoughtpolice> are you look for say '(return . Just)' ?
22:58:26 <OceanSpray> no, forget it.
22:59:15 <faxathisia> I think it helps a bit to say,
22:59:21 <nolrai> you Could define type IOMaybe a = IO (Maybe a)
22:59:22 <faxathisia> You're writing code in two programming languages
22:59:25 <kfish> OceanSpray, you'd need to define an infix type constructor to do the type-system thing you want
23:00:01 <nolrai> Plareplane: I dont think so
23:00:19 <nolrai> need to up grade my system
23:06:35 <dfranke_> meh... GHC's build parallelization needs work.
23:06:46 <dfranke_> on an 8-core system with -j10 I'm only getting a load average of about 2.
23:33:44 <Taejo> modules that use both Data.Set and Data.Map are annoying
23:36:51 <TSC`> Taejo: How's that?
23:42:59 <Taejo> TSC`: all the conflicting names
