00:00:13 <ivanm> ahhh
00:00:21 * ivanm promptly forgets it then
00:00:26 <jsnx> sorry
00:00:33 <Korollary> you hate america. Get him.
00:00:39 <jsnx> Korollary: lolz
00:00:56 <ivanm> Korollary: more "don't care about" than "hate"
00:01:02 <Korollary> yeah yeah
00:01:07 <jsnx> ivanm: it's okay
00:01:20 * Korollary uses enhanced interrogation techniques on ivanm 
00:01:36 <jsnx> like water boarding, &c.?
00:01:43 <ivanm> what, the good cop/bad cop approach?
00:01:48 <Korollary> just bad cop
00:01:49 <ivanm> that's not very advanced...
00:01:49 <ivanm> :p
00:01:51 <ivanm> heh
00:02:32 <jsnx> ivanm: well, we use advanced polymer boards and triple distilled water...
00:02:45 <ivanm> .... right then...
00:03:02 <jsnx> at least, that's how it is in the *good* prisons
00:04:25 <ivanm> jsnx: you know from experience, do you? ;-)
00:04:41 <jsnx> ivanm: that's how i came to this country
00:04:49 <jsnx> i am so glad to be free
00:05:06 <ivanm> what, you magically appeared in a prison? :s
00:05:35 <mdmkolbe|work> sjanssen, oerjan: thx.  it looks like lists work if I use [(a, Bool)].  (I needed a delete operator and ((x,False):xs) works better than Data.List.delete)
00:13:47 <jsnx> anybody else reading the notes at the bottom of this? http://www.math.uchicago.edu/~eugenia/winter06/
00:13:48 <lambdabot> Title: winter06
00:14:12 <jsnx> i'm on the first few pages
00:14:21 <jsnx> the notation is a little confusing some times
00:14:53 <faxathisia> jsnx: Why learn about catagory theory?
00:15:01 <faxathisia> (I kind I read some stuff before and it's hard :p)
00:15:10 <jsnx> faxathisia: i don't know
00:15:16 <faxathisia> ack
00:15:18 <jsnx> i am drawn to it irresistably
00:15:19 * faxathisia skips this then
00:16:04 <jsnx> faxathisia: most of the material serves to clarify terminology, which i appreciate
00:17:53 <ivanm> I started reading "category theory for computer scientists"... then gave up when I got to arrows :s
00:19:13 <jsnx> ivanm: haven't got to those yet
00:19:33 <jsnx> well, arrows are all over the place, actually -- but i think they must have a different meaning
00:19:49 <jsnx> in haskell, they are a control flow mechanism
00:20:30 <jsnx> but in the category theory stuff i read, arrow are "morphisms"
00:20:46 <jsnx> introduced right away and not (so far) especially interesting
00:21:14 <jsnx> "arrow" and "morphism" seem to be synonomous
00:21:32 <faxathisia> Arrow.hs is neat
00:21:44 <jsnx> faxathisia: why is it cool?
00:22:11 <faxathisia> just this whole implementation fits together so well
00:22:19 <jsnx> oic
00:22:27 <faxathisia> I suppsoe that's because it's a coding of this concept from math
00:22:29 <faxathisia> s
00:22:42 <faxathisia> but I think I learned some haskell fromit
00:24:23 <mdmkolbe|work> Arrow.hs != category theory morphisms
00:24:49 <jsnx> yeah, Haskell arrows are something else
00:25:02 <jsnx> though, i don't know what
00:25:18 <mdmkolbe|work> class Morphism m where id :: m a b, comp :: m a b -> m b c -> m a c
00:26:01 <wy> Is there a lib function to merge two ordered lists?
00:26:34 <wy> I wonder if this can done with list comprehension
00:26:39 <jsnx> mdmkolbe|work: yeah, that jibes with the paper
00:27:36 <mdmkolbe|work> g'night all
00:29:59 <jsnx> so, say i have an app with a 'verbose' command line option
00:30:11 <bos> o beautiful type-level programming, how i love thee.
00:30:12 <jsnx> i'd like to write an app as a few different actions
00:30:28 <jsnx> and just change the verbosity once
00:30:30 <faxathisia> bos: like what?
00:30:39 <jsnx> is this a monad thing?
00:30:59 <faxathisia> jsnx: I used System.Console.GetOpt for that kind of thing
00:31:13 <jsnx> faxathisia: yeah, to get the option
00:31:15 <faxathisia> (in the IO monad..)
00:31:24 <jsnx> faxathisia: but i'm wondering about how to structure the program
00:31:29 <bos> faxathisia: i've got types like this in my llvm bindings: (undefined :: T.Pointer T.Int8 :-> T.Int32)
00:31:51 <bos> which constructs at runtime the type of a function that takes an int8 and returns an int32
00:32:06 <bos> all just by specifying the desired type signature
00:33:39 <Zao> wy: Non-elegantly and probably horribly slow :)  Data.Set.toAscList $ Data.Set.union (Data.Set.fromAscList x) (Data.Set.fromAscList y)
00:35:07 <Zao> Or just  sort $ union x y
00:36:47 <davidL> wy: do you want the length of the new list = length listA + length listB?
00:37:07 <wy> what?
00:37:08 <jsnx> :src union
00:37:16 <jsnx> @src union
00:37:16 <lambdabot> union = unionBy (==)
00:37:22 <wy> Ah...
00:37:23 <jsnx> @src unionBy
00:37:23 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
00:37:31 <wy> I see what you are talking ;-)
00:37:41 <jsnx> it's a Set union
00:37:56 <jsnx> not the same as simple (++) -- i was wondering about that
00:37:57 <wy> davidL: They might be infinite
00:38:34 <jsnx> wy: you can sort the union of them, in general
00:39:09 <jsnx> wy: you have set some kind of bound on how far up the list to search
00:39:54 <wy> @src union
00:39:54 <lambdabot> union = unionBy (==)
00:40:00 <wy> @src unionBy
00:40:00 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
00:40:30 <wy> @src nubBy
00:40:30 <lambdabot> nubBy eq []             =  []
00:40:30 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:41:28 <wy> take 5 (sort (union [1..] (map (2^) [1..])))
00:41:33 <wy> > take 5 (sort (union [1..] (map (2^) [1..])))
00:41:38 <lambdabot> Terminated
00:42:00 <wy> It doesn't work. I must write it myself...
00:42:06 <jsnx> yeah
00:42:15 <jsnx> would be cool to see what you do
00:42:36 <davidL> there's probably a neat way to do it with takeWhile
00:49:30 <jsnx> @let { a = [1,3..]; b = map (2^) [1..] }
00:49:31 <lambdabot> <local>:7:0: parse error on input `{'
00:49:58 <jsnx> @let a = [1,3..]
00:50:00 <lambdabot> Defined.
00:50:07 <jsnx> @let b = map (2^) [1..]
00:50:08 <lambdabot> Defined.
00:50:14 <jsnx> @let sorted = concat [ takeWhile (<= n) a | n <- b ]
00:50:15 <lambdabot> Defined.
00:50:22 <jsnx> this is wrong, actually
00:50:31 <jsnx> > take 10 sorted
00:50:32 <lambdabot>  [1,1,3,1,3,5,7,1,3,5]
00:50:57 <jsnx> @let sorted = concat [ (takeWhile (<= n) a) ++ [n] | n <- b ]
00:50:58 <lambdabot> <local>:10:0:     Multiple declarations of `L.sorted'     Declared at: <local...
00:51:12 <jsnx> @help
00:51:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:51:16 <jsnx> @help list
00:51:17 <lambdabot> list [module|command]
00:51:17 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:52:11 <jsnx> > take 10 sorted
00:52:12 <lambdabot>  [1,1,3,1,3,5,7,1,3,5]
00:52:22 <jsnx> @let sortaSorted = concat [ (takeWhile (<= n) a) ++ [n] | n <- b ]
00:52:23 <lambdabot> Defined.
00:52:25 <jsnx> > take 10 sorted
00:52:25 <lambdabot>  [1,1,3,1,3,5,7,1,3,5]
00:52:31 <jsnx> oops
00:52:42 <jsnx> @del sorted
00:52:42 <lambdabot> Maybe you meant: help keal let pl tell url
00:52:49 <jsnx> @delelte sorted
00:52:49 <lambdabot> Unknown command, try @list
00:52:52 <jsnx> @delete sorted
00:52:52 <lambdabot> SoR7Ed
00:53:01 <jsnx> @delete sortaSorted
00:53:02 <lambdabot> zOrT4sOr7eD
00:53:10 <Pseudonym> Oh, man.
00:53:11 <jsnx> @let sorted = concat [ (takeWhile (<= n) a) ++ [n] | n <- b ]
00:53:12 <lambdabot> <local>:11:0:     Multiple declarations of `L.sorted'     Declared at: <local...
00:53:16 <Pseudonym> That's a cool disambig.
00:53:19 <Pseudonym> @undef
00:53:20 <lambdabot> Undefined.
00:53:27 <Pseudonym> Now try again.
00:53:47 <jsnx> @let a = [1,3..]
00:53:48 <lambdabot> Defined.
00:53:56 <jsnx> @let b = map (2^) [1..]
00:53:57 <lambdabot> Defined.
00:54:04 <jsnx> @let sorted = concat [ (takeWhile (<= n) a) ++ [n] | n <- b ]
00:54:04 <lambdabot> Defined.
00:54:11 <jsnx> > take 10 sorted
00:54:12 <lambdabot>  [1,2,1,3,4,1,3,5,7,8]
00:54:19 <jsnx> it's wrong  still
00:54:32 <jsnx> don't know how to go down a and b at the same time
00:55:00 <jsnx> Pseudonym: thanks for your help
00:56:15 <Pseudonym> np
01:06:17 <oerjan> simple recursion seems best
01:08:11 <oerjan> > let merge a [] = a; merge [] b = b; merge ass@(a:as) bss@(b:bs) | a <= b = a:merge as bss | otherwise = b:merge ass bs in merge [1,3..10] [1,4..10]
01:08:14 <lambdabot>  [1,1,3,4,5,7,7,9,10]
01:09:43 <jsnx> @let foo (x:xs) (y:ys) = if y < x then y:x:(foo xs ys) else x:(foo xs (y:ys)
01:09:44 <lambdabot>  Parse error
01:09:51 <jsnx> eh?
01:10:05 <jsnx> @let foo (x:xs) (y:ys) = if y < x then y:x:(foo xs ys) else x:(foo xs (y:ys))
01:10:06 <lambdabot> Defined.
01:10:07 <jsnx> oh
01:10:24 <jsnx> > take 20 $ foo a b
01:10:25 <lambdabot>  [1,2,3,4,5,7,8,9,11,13,15,16,17,19,21,23,25,27,29,31]
01:10:39 <jsnx> > take 40 $ foo a b
01:10:40 <lambdabot>  [1,2,3,4,5,7,8,9,11,13,15,16,17,19,21,23,25,27,29,31,32,33,35,37,39,41,43,45...
01:11:20 <jsnx> i win!
01:11:57 <jsnx> and we can generalize to Comparable things, by changin the if
01:12:16 <jsnx> changin  ->  changin'
01:13:18 <oerjan> in base, used to define sort but not exported:
01:13:22 <oerjan> merge cmp xs [] = xs
01:13:22 <oerjan> merge cmp [] ys = ys
01:13:22 <oerjan> merge cmp (x:xs) (y:ys)
01:13:22 <oerjan>  = case x `cmp` y of
01:13:22 <oerjan>         GT -> y : merge cmp (x:xs)   ys
01:13:24 <oerjan>         _  -> x : merge cmp    xs (y:ys)
01:14:50 <jsnx> it will be so fun much fun if i can use this language for production code...
01:30:46 <wy> jsnx: good job :-)
01:31:11 <wy> I wonder if there is some database with lots of programming exercises
01:31:45 <allbery_b> project euler?
01:32:17 <ikegami--> or SPOJ
01:33:08 <ikegami--> http://www.spoj.pl/
01:33:13 <lambdabot> Title: Sphere Online Judge (SPOJ)
01:33:49 <ikegami--> There are over 1800 problems
01:34:24 <ikegami--> Haskell is available :D
01:35:25 <shachaf> @karma ikegami
01:35:25 <lambdabot> ikegami has a karma of -1
01:36:56 <shachaf> ikegami--: Is that on purpose?
01:36:58 <shachaf> ikegami--
01:37:04 <shachaf> @karma ikegami
01:37:04 <lambdabot> ikegami has a karma of -2
01:37:08 <shachaf> ikegami++
01:37:27 <ikegami--> thanks
01:38:08 <shachaf> ikegami--: It's still at -1.
01:38:25 <shachaf> ikegami--: Why do you use that nick?
01:38:38 <Korollary> why not. who cares about karma
01:38:39 <wy> haha
01:38:46 <wy> @karma wy
01:38:46 <lambdabot> You have a karma of 0
01:39:19 <shachaf> Korollary: Perhaps ikegami (without --) does.
01:40:36 <wy> @karma ikegami
01:40:36 <lambdabot> ikegami has a karma of -1
01:40:38 <Korollary> I've never liked that C'ist shortcut anyway
01:41:16 <wy> haskell also has ikegami--
01:41:33 <ikegami--> Another interesting database of problems are called Code Golf
01:41:41 <ikegami--> http://codegolf.com/
01:41:42 <lambdabot> Title: Code Golf | Home
01:42:00 <ikegami--> and another one http://golf.shinh.org/
01:42:00 <lambdabot> Title: anarchy golf
01:42:09 * shachaf just came across a language called GolfScript recently, speaking of golf.
01:42:27 <wy> ikegami--: thanks
01:51:38 <wy> I'm wondering if parser combinators can do everything parser generators can do
01:52:41 <visof> is monads in category theory like monads in haskell?
01:52:55 <visof> or
01:53:18 <visof> are monads in category theory and monads in haskell  same?
01:54:24 <jsnx> visof: well, everybody says they are closely related
01:54:36 <jsnx> visof: i am doing a lot of reading in order to find out ;)
01:55:07 <allbery_b> category theory is much more general than haskell.  haskell's monads can be seen as a specialization of the category-theoretical monad to a specific category (often referred to as Hask) which describes Haskell's type system
01:55:12 <allbery_b> or so I understand
01:55:18 * allbery_b is rather weak on CT
01:56:41 <wy> allbery_b: I haven't seen any connection yet. Monads are much like CPS
01:56:58 <wy> partly because I don't know any category theory ;-)
01:58:56 <Pseudonym> wy: The short answer to your question is "kinda".
01:58:57 <shachaf> wy: Like CPS? What do you mean?
01:59:01 <Pseudonym> On parser combinators.
01:59:24 <Pseudonym> With monads, no.
01:59:31 <Pseudonym> Because the second argument to bind is a function.
01:59:35 <Pseudonym> With arrows, I think so.
02:03:36 <wy> shachaf: because the RHS to bind is a continuation, but monads are more general
02:05:05 <wy> maybe I should read moggi's paper to find out the connection
02:05:39 <Pseudonym> If you can read Moggi's papers, you already understand it.
02:05:47 <Pseudonym> Moggi's papers are not known for readability.
02:05:55 <Pseudonym> Wadler papers are better reads, usually.
02:09:24 <wy> I've read two of Wadler's papers :-)
02:09:57 <Pseudonym> Have you read "Comprehending Monads"?
02:10:23 <wy> No..  I just read "the essence of ..." and "monads for ..."
02:13:18 <wy> "comprehending..." should be my next to read
02:13:39 <wy> any good papers for monad transformers?
02:14:11 <Pseudonym> Yes, the Mark Hopkins paper.
02:14:28 <Pseudonym> Just a moment.
02:14:47 <Pseudonym> Not Mark Hopkins, Mark Jones.
02:14:52 <Pseudonym> Mark Hopkisns is someone else.
02:15:17 <Pseudonym> http://web.cecs.pdx.edu/~mpj/pubs.html
02:15:17 <lambdabot> Title: Mark P Jones: Publications
02:15:26 <Pseudonym> "Monad Transformers and Modular Interpreters"
02:18:53 <faxathisia> oh yes
02:19:00 <wy> Got it. seems to be the original one. Thanks!
02:19:12 <faxathisia> I liked this
02:19:12 <faxathisia> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
02:19:13 <lambdabot> Title: Monad Transformers Step by Step
02:23:50 <wy> faxathisia: thanks
02:24:38 <wy> faxathisia: yeah. I also got code for it
02:25:48 <wy> I found these two lines in his code: %include polycode.fmt
02:25:48 <wy> %format alpha = "\alpha"
02:26:14 <wy> Is it for some processing tool?
02:27:14 <wy> Nice. Now I know how is a haskell paper made :-)
02:40:15 <ertai> @list Data.IORef
02:40:15 <lambdabot> No module "Data.IORef" loaded
02:58:12 * faxathisia mumbles about type theory being really hard
02:58:18 <faxathisia> >:|
03:06:41 <mxc> @hoogle runX
03:06:41 <lambdabot> No matches found
03:09:18 <faxathisia> isn't that in XMonad?
03:09:46 <faxathisia> http://hackage.haskell.org/packages/archive/xmonad/0.5/doc/html/XMonad-Core.html#v%3ArunX
03:09:47 <lambdabot> http://tinyurl.com/2pwdun
03:10:27 <dibblego> what does a tilde do in pattern matching?
03:10:46 <faxathisia> umn irrefutable constructor
03:10:54 <faxathisia> so it's staying lazy, when you know the patterns going to match
03:11:18 <dibblego> ah ok cheers
03:25:04 <mxc> HXT
03:26:15 <mxc> trying to do a sort of learning project with hxt
03:29:02 <hpaste>  aragaer pasted "(no title)" at http://hpaste.org/4694
03:29:02 <lambdabot> hpaste: You have 1 new message. '/msg lambdabot @messages' to read it.
03:37:17 <Japsu> @src foldr'
03:37:17 <lambdabot> Source not found. :(
03:41:30 <Japsu> @src foldr
03:41:30 <lambdabot> foldr k z xs = go xs
03:41:30 <lambdabot>     where go []     = z
03:41:30 <lambdabot>           go (y:ys) = y `k` go ys
03:41:38 <Japsu> @src foldl
03:41:38 <lambdabot> foldl f z xs = lgo z xs
03:41:39 <lambdabot>     where lgo z []     =  z
03:41:39 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
03:42:07 <Japsu> opqdonut:
03:42:15 <Japsu> @type (foldl, foldr)
03:42:17 <lambdabot> forall a b a1 b1. ((a -> b -> a) -> a -> [b] -> a, (a1 -> b1 -> b1) -> b1 -> [a1] -> b1)
03:42:42 <ertai> @pl w (\x -> f1 >> g x f2)
03:42:42 <lambdabot> w ((f1 >>) . flip g f2)
04:07:25 <hpaste>  Japsu annotated "reimplementation of random c++ stuff in haxell" with "even more betterer version" at http://hpaste.org/4693#a2
04:23:44 <Japsu> @type inlinePerformIO
04:23:45 <lambdabot> Not in scope: `inlinePerformIO'
04:24:18 <Japsu> "Very unsafe."
04:24:19 <Japsu> <3
04:29:26 <mxc> not to start a war or anything, but what is the haskell community's view of ocaml?
04:30:05 <Japsu> err, "not pure => cheating => uninteresting"? ;)
04:33:08 <qebab> Japsu: -- tail recursive state machine clusterfuck
04:33:11 <qebab> that is an awesome comment
04:33:19 <Japsu> qebab: ;)
04:33:37 <Japsu> qebab: if you look at the original, it was a lot more fuglier then ;)
04:33:54 <qebab> :D
04:34:09 <qebab> well if it's "random c++ stuff" that's what you would expect
04:34:23 <Japsu> yeah well that's a pretty generic problem it's trying to address
04:34:26 <Japsu> or at least in part
04:34:37 <qebab> my family is out
04:34:45 <qebab> I'm going to install linux on all the computers in the house
04:34:47 <qebab> wish me luck!
04:34:49 <Japsu> that is, I have "2007-13-32 25:61:61 <nick> message" and want to extract the nick
04:34:52 <Japsu> haha lol
04:34:57 <Japsu> this plan good, proceed
04:35:01 <qebab> :)
04:35:39 <ricky_clarkson> > words "2007-13-32 25:61:61 <nick> message" ! 3
04:35:40 <lambdabot>  Couldn't match expected type `Array i e'
04:35:53 <ricky_clarkson> > words "2007-13-32 25:61:61 <nick> message" $ !! 3
04:35:54 <lambdabot>  Parse error at "!!" (column 46)
04:35:56 <Japsu> ricky_clarkson: lol
04:36:06 <Japsu> stupid me
04:36:08 <ricky_clarkson> > words "2007-13-32 25:61:61 <nick> message" !! 3
04:36:09 <lambdabot>  "message"
04:36:16 <ricky_clarkson> > words "2007-13-32 25:61:61 <nick> message" !! 2
04:36:16 <lambdabot>  "<nick>"
04:36:18 <Japsu> I just stuck to getting the text between < and >
04:36:25 <qebab> well you could just dropWhile (/= '<') and and suck
04:36:34 <qebab> there's an and too much there
04:36:37 <Japsu> qebab: yeah well, that's how I had it first implemented
04:36:47 <Japsu> but then I wanted to add the stripping of the umode char
04:36:49 <qebab> I imagine that's the simplest way
04:36:58 <qebab> ah
04:37:01 <Japsu> anyway, all lines are in the same format
04:37:03 <ricky_clarkson> > drop 1 $ words "2007-13-32 25:61:61 <nick> message" !! 2
04:37:03 <lambdabot>  "nick>"
04:37:23 <ricky_clarkson> > take 1 . drop 1 . words "2007-13-32 25:61:61 <nick> message" !! 2
04:37:23 <lambdabot>      precedence parsing error
04:37:24 <lambdabot>         cannot mix `(.)' [infixr 9] and `(!!)' ...
04:37:39 <ricky_clarkson> > take 1 . drop 1 $ words "2007-13-32 25:61:61 <nick> message" !! 2
04:37:39 <lambdabot>  "n"
04:37:50 <Japsu> except for the lines that are status messages or such
04:37:51 <ricky_clarkson> :t butLast
04:37:52 <lambdabot> Not in scope: `butLast'
04:37:52 <qebab> > takeWhile (/= '>') $ drop 1 $ words "2007-13-32 25:61:61 <nick> message" !! 2
04:37:52 <lambdabot>  "nick"
04:38:06 <Japsu> :t init
04:38:06 <lambdabot> forall a. [a] -> [a]
04:38:12 <Japsu> > init [1,2,3]
04:38:12 <lambdabot>  [1,2]
04:38:19 <Japsu> there's your butLast
04:38:32 <qebab> ricky_clarkson: lisper?
04:38:40 <ricky_clarkson> qebab: Somewhat.
04:39:50 <ricky_clarkson> @pl \s -> init 1 . drop 1 $ words s !! 2
04:39:50 <lambdabot> init 1 . drop 1 . (!! 2) . words
04:40:46 <ricky_clarkson> > words >>> (!! 2) >>> drop 1 >>> init 1 "date time <nicholas> message"
04:40:47 <lambdabot>  Couldn't match expected type `[Char] -> [Char] -> d'
04:41:12 <ricky_clarkson> > words >>> (!! 2) >>> drop 1 >>> init 1 $ "date time <nicholas> message"
04:41:12 <lambdabot>  Couldn't match expected type `[Char] -> b'
04:41:37 <ricky_clarkson> > (words >>> (!! 2) >>> drop 1 >>> init 1) "date time <nicholas> message"
04:41:38 <lambdabot>  Couldn't match expected type `(->) [Char]'
04:42:01 <ricky_clarkson> What's my misunderstanding?
04:42:07 <desegnis> The type of init.
04:42:22 <ricky_clarkson> :t init
04:42:22 <lambdabot> forall a. [a] -> [a]
04:42:35 <desegnis> No 1 there.
04:42:43 <ricky_clarkson> > (words >>> (!! 2) >>> drop 1 >>> init) "date time <nicholas> message"
04:42:43 <lambdabot>  "nicholas"
04:42:50 <ricky_clarkson> Thanks. ;)
04:43:12 <ricky_clarkson> I like >>> because the resulting code looks like bash pipelines.
04:43:52 <desegnis> Yea, it frees you from reading function compositions backwards.
04:44:27 <desegnis> It's typographically too heavy for my taste, though.
04:44:41 <ricky_clarkson> Scala's pretty nifty in that respect.
04:45:15 <ricky_clarkson> 1 to 10 map (_*2) filter (_>9)
04:46:10 <desegnis> In Ruby it would be [1..10].map { |x| x*2 }.filter { |x| x > 9 }
04:46:18 <desegnis> Now, if Ruby was functional...
04:46:31 <ricky_clarkson> It appears to be both.
04:47:14 <Japsu> [2 * i for i in xrange(1,11) if 2 * i > 9]
04:47:16 <Japsu> in python
04:47:35 <Japsu> hmm
04:47:42 <Japsu> that ruby version looks quite nice
04:47:48 <ricky_clarkson> Japsu: Surely there's a way without duplicating 2 * i.
04:48:02 <Japsu> ricky_clarkson: in python? sure
04:48:15 <idnar> [n for n in (2 * i for i in xrange(1, 11)) if n > 9]
04:48:28 <idnar> that starts getting awkward, though
04:48:37 <Japsu> yeah
04:48:58 <RayNbow> oh great, compiling wxHaskell failed...
04:49:06 <desegnis> Well, regarding Ruby, it's what I wrote modulo the facts that it's (1..10) instead of [1..10] and  select  instead of  filter .
04:51:18 <alar> greetins!
04:52:37 <ricky_clarkson> range(1,10).map({int x => x*2}).filter({int x => x>9}) in the proposed Java 7.
04:52:49 <ricky_clarkson> As opposed to the 10 or so lines it is in Java now.
04:53:25 <alar> what data structure is the most appropriate to use as a "sorting" heap: that sorts inserted entries according to some order and has not too slow operations of adding an entry, removal of entry and selecting entry with lowest order?
04:53:42 <scook0> ricky_clarkson: AbstractSequenceMapperIteratorFactoryFactoryFactory? ;)
04:54:14 <ricky_clarkson> scook0: I think you and I need to communicate via a Delegate.  Here's a DelegateFactory.
04:54:55 <Japsu> BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(filename))); // and this is a REAL LIFE example
04:55:11 <scook0> alar: are you talking about library data structures, or ones you'd build yourself?
04:55:20 <desegnis> alar: I'm not sure whether you can have both an efficient add and an efficient lookup...
04:55:23 <ricky_clarkson> Japsu: And exaggerated, that code can be half as long.
04:55:45 <Japsu> hm?
04:55:47 <ricky_clarkson> I'm not defending Java, there's no point, but you can't blame Java for that code specifically.
04:56:08 <ricky_clarkson> BufferedReader reader=new BufferedReader(new FileReader(filename))
04:56:14 <EvilTerran> alar, i think, in haskell, a Data.Set has pretty good complexities for that sort of thing
04:56:36 <Japsu> oh, nice
04:56:37 <EvilTerran> (log time insertion, finding minimum, deletion)
04:56:50 <scook0> ricky_clarkson: it's a bad java-bashing example, because it's the kind of pattern that you actually *can* abstract in java
04:56:57 <desegnis> EvilTerran, or a multiset, depending on alar's requirements
04:56:58 <scook0> it's more of a dig at the standard lib
04:57:01 <ricky_clarkson> scook0: True.
04:57:07 <EvilTerran> indeed, which'd be a Data.Map [a], i guess
04:57:18 <EvilTerran> er, or something
04:57:44 <scook0> I'm sure there's a multiset in one of the datastructure libs on hackage
04:57:49 <idnar> the main reason that Java is so much more painful than, say, C#, is the standard library
04:57:51 <scook0> assuming there isn't one in base
04:57:52 <desegnis> you'd want to guarantee that the list can't be empty... but isn't there a multiset somewhere ready?
04:57:54 <EvilTerran> Data.Map a Int, if your elements are genuinely equal
04:58:13 <EvilTerran> Data.Map <hash, as it were> [a], otherwise
04:59:27 <Taejo> @oeis 1 1 3 5 11 21
04:59:28 <lambdabot> Jacobsthal sequence: a(n) = a(n-1) + 2a(n-2).
04:59:28 <lambdabot> [0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,174...
04:59:52 <ricky_clarkson> @help oeis
04:59:52 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
05:00:26 <ricky_clarkson> @oeis 1 -1 1 -1
05:00:26 <lambdabot> Numerators of Bernoulli numbers B_2n.
05:00:26 <lambdabot> [1,1,1,1,1,5,691,7,3617,43867,174611,854513,236364091,8553103,23749461029,861...
05:01:04 <Botje_> @oeis 1 11 21 1211 111221
05:01:04 <lambdabot> Look and Say sequence: describe the previous term! (method A - initial term i...
05:01:04 <lambdabot> [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113...
05:01:37 <ricky_clarkson> hah, amazing.
05:01:57 <idnar> @oeis 0 1 2 5 20 25
05:01:58 <lambdabot> a(1) = 1, then if n is even multiply it by the previous term else add to get ...
05:01:58 <lambdabot> [0,1,2,5,20,25,150,157,1256,1265,12650,12661,151932,151945,2127230,2127245,34...
05:02:46 <czShadoW> @oeis 1 2 6 24 120
05:02:46 <lambdabot> Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number o...
05:02:46 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
05:02:53 <mxc> @hoogle iter
05:02:54 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
05:02:54 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
05:02:54 <lambdabot> Data.ByteString.Lazy.iterate :: (Word8 -> Word8) -> Word8 -> ByteString
05:02:55 <alar> scook0: library is preferrable, but if there is noone, I'll try to make it myself
05:03:04 <czShadoW> Cool
05:03:08 <alar> EvilTerran: thank you! I'll try it
05:03:09 <ricky_clarkson> @oeis 2 4 16 256 65536
05:03:09 <lambdabot> 2^(2^n) (or: write in base 2, read in base 4).
05:03:09 <lambdabot> [2,4,16,256,65536,4294967296,18446744073709551616,340282366920938463463374607...
05:03:11 <mxc> @hoogle Data.List
05:03:11 <lambdabot> No matches, try a more general search
05:03:23 <EvilTerran> :)
05:04:24 <alar> I want one to write "best-first search": a "priority queue" to hold graph nodes
05:04:32 <scook0> alar: if you don't need to store duplicates, you could probably use Data.Set
05:04:43 <alar> yes, no duplicates
05:05:05 <alar> duplicates would crash search algorithm I think
05:05:21 <scook0> @hoogle minView
05:05:22 <lambdabot> Data.Set.minView :: Monad m => Set a -> m (a, Set a)
05:05:22 <lambdabot> Data.Map.minView :: Monad m => Map k a -> m (a, Map k a)
05:05:22 <lambdabot> Data.IntSet.minView :: Monad m => IntSet -> m (Int, IntSet)
05:05:40 <czShadoW> @oeis 1 4 27 256 3125
05:05:41 <lambdabot> Number of labeled mappings from n points to themselves (endofunctions): n^n.
05:05:41 <lambdabot> [1,1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611,8...
05:06:28 <scook0> alar: deleteFindMin or minView on a Set will extract the least element in O(log n)
05:06:51 <scook0> and insert is O(log n)
05:09:43 <byorgey> yes, the only operation on Data.Set that is slower than a true heap is minView (O(lg n) vs. O(1)).  But that doesn't really matter, most of the time you'd be using deleteMin anyway, which is O(lg n) for both.
05:25:36 <qebab> @oeis 1 3 27 81
05:25:37 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
05:25:43 <qebab> ):
05:25:58 <byorgey> qebab: what happened to 9?
05:26:04 <qebab> indeed
05:26:08 <qebab> I think I had a brainfart
05:26:10 <byorgey> hehe
05:26:11 <qebab> @oeis 1 3 9 27 81
05:26:11 <lambdabot> Powers of 3.
05:26:11 <lambdabot> [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,1434...
05:26:17 <qebab> amazing
05:26:25 <qebab> lambdabot: source?
05:26:29 <qebab> !source
05:26:37 <qebab> I'll try google!
05:26:52 <qebab> there it is
05:26:55 <wolverian> @source
05:26:55 <lambdabot>  not available
05:27:00 <wolverian> oh, wait. yeah.
05:27:03 <wolverian> @lambdabot
05:27:03 <lambdabot> Unknown command, try @list
05:27:08 * wolverian sighs
05:27:20 <ivanm> which source? lambdabot's?
05:27:24 <byorgey> @version
05:27:25 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
05:27:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
05:27:25 <ivanm> @whereis lambdabot
05:27:25 <lambdabot> Maybe you meant: where where+
05:27:32 <ivanm> @where lambdabot
05:27:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:27:32 <qebab> ah
05:27:39 <qebab> it just contacts a website
05:27:47 <qebab> I thought it figured out of it itself :P
05:27:50 <byorgey> qebab: yes, the OEIS =)
05:27:57 <byorgey> oh, haha
05:28:06 <qebab> see now why I wanted the source? :P
05:28:15 <byorgey> that would be... rather amazing
05:28:20 <qebab> yeah, it would
05:28:45 <opqdonut> @oeis 1 0 1 1 0 1 1 1 0
05:28:45 <lambdabot> a(n) = 0 if n of form m(m+3)/2, otherwise 1.
05:28:46 <lambdabot> [0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,...
05:28:58 <opqdonut> heh
05:29:26 <qebab> @oeis 1 3 6 10 15
05:29:26 <lambdabot> Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
05:29:27 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
05:30:05 <ivanm> let's try something silly...
05:30:07 <ivanm> @oeis 1 2 3 4 5
05:30:07 <lambdabot> The natural numbers. Also called the whole numbers, the counting numbers or t...
05:30:07 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
05:30:12 <ivanm> heh
05:30:13 <ricky_clarkson> @oeis 1 1 8 1 1 8
05:30:13 <lambdabot> Triangle whose rows are sequences of increasing and decreasing cubes:1; 1,8,1...
05:30:13 <lambdabot> [1,1,8,1,1,8,27,8,1,1,8,27,64,27,8,1,1,8,27,64,125,64,27,8,1,1,8,27,64,125,21...
05:30:20 <b_jonas> hmm
05:30:37 <b_jonas> mine is better, it gives the link
05:30:53 <b_jonas> and also the number of matching sequences
05:31:29 <b_jonas> try /msg buubot oeis: 1 0 1 1 0 1 1 1 0
05:32:00 <b_jonas> or actually, try it with commans for sequential matches
05:32:07 <b_jonas> try /msg buubot oeis: 1,0,1,1,0,1,1,1,0
05:33:29 <mxc>  @hoogle (>>>)
05:33:48 <mxc> @src (>>>)
05:33:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:33:55 <mxc> @hoogle (>>>)
05:33:55 <lambdabot> Did you mean: (>>>)
05:33:56 <lambdabot> Prelude.undefined :: a
05:33:56 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
05:34:09 <mxc> @hoogle >>>
05:34:12 <lambdabot> Control.Category.(>>>) :: Category cat => cat a b -> cat b c -> cat a c
05:34:38 <roconnor> Control Category!?
05:35:07 <roconnor> what is a Category?
05:36:19 <wolverian> I don't see that on hoogle
05:36:36 <resiak> http://www.haskell.org/ghc/dist/current/docs/libraries/base-3.0/Control-Category.html
05:36:37 <lambdabot> http://tinyurl.com/2hzn5s
05:37:16 <roconnor> A new superclass of arrow?
05:37:38 <roconnor> ah
05:37:45 <wolverian> weird, what does @hoogle use as source? web hoogle isn't as up to date :)
05:38:45 <roconnor> what else has been redesigned?
05:40:41 <byorgey> @unmtl ListT (StateT s m) a
05:40:41 <lambdabot> s -> m ([a], s)
05:41:11 <byorgey> @unmtl StateT s (ListT m) a
05:41:12 <lambdabot> s -> m [(a, s)]
05:41:18 <wolverian> see the 6.8 release notes, I suppose
05:41:30 <roconnor> strict and lazy mtl classes
05:41:46 <wolverian> also, if I wanted to make ap rocmail replacement in haskell, how should I approach it? making rules IO actions seems ugly.
05:41:57 <wolverian> s/ap /a p/
05:42:39 <mxc> @src isText
05:42:39 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:42:42 <roconnor> ooh System.Timeout.timeout
05:43:05 <wolverian> make my own monad with the allowed actions?
05:46:08 <byorgey> wolverian: that sounds like a good idea.  It will probably have to involve IO 'under the hood', but you can choose to export an interface that only allows certain things.
05:48:19 <b_jonas> let me have some stupid questions about haskell.
05:48:31 <wolverian> how would I implement this under-the-hoodiness? can't the action always lift up to the IO monad, then?
05:48:34 <b_jonas> modules cannot depend on each other cyclically, right?
05:48:50 <wolverian> b_jonas, ghc lets you do that, see the user's manual
05:49:25 <idnar> wolverian: once you've built up your set of rules or whatever, "running" the rules might involve IO
05:49:40 <wolverian> ah.. I need a runAction then?
05:49:46 * wolverian is new to this building monads stuff
05:50:07 <wolverian> any sample monad I should look at?
05:50:41 <b_jonas> hmm
05:50:44 <idnar> you might have something like: applyRules :: RuleSet -> Message -> IO Result
05:51:27 <idnar> where Message and Result are something appropriate to e-mail processing, maybe just String and ()
05:51:30 <b_jonas> ah, found it, thanks
05:51:32 <b_jonas> will read it
05:52:40 <wolverian> hmm. I'm still unclear how to build the monad. can you point me at an example you think might be useful?
05:53:12 <EvilTerran> ?src ST
05:53:12 <lambdabot> newtype ST s a = ST (STRep s a)
05:53:23 <qebab> @oies 2 3 5 7 11
05:53:23 <lambdabot> The prime numbers.
05:53:23 <EvilTerran> hm. never mind.
05:53:23 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
05:53:43 <roconnor> newtype ProcMailMonad a = IO a (derving Monad)
05:53:46 <roconnor> :)
05:53:53 <opqdonut> :D
05:53:58 <EvilTerran> (you need a constructor)
05:54:02 <roconnor> crap
05:54:13 <opqdonut> and then export only smart constructors for the things you allow
05:54:16 <EvilTerran> and your brackets on the deriving clause are in the wrong place :P
05:54:16 <roconnor> newtype ProcMailMonad a = runProcMailMonad IO a (derving Monad)
05:54:25 <roconnor> maybe more parenthesis
05:54:36 <wolverian> roconnor, yeah, I wanted to avoid letting the actions use IO
05:54:36 <roconnor> damn it
05:54:37 <EvilTerran> and deriving has stereo vision in most cases (two "i"s)
05:54:49 <roconnor> wolverian: oh
05:55:07 <EvilTerran> newtype ProcMailMonad a = ProcMailMonad { runProcMailMonad :: IO a } derving (Applicative, Functor, Monad)
05:55:12 <roconnor> wolverian: what sort of actions do you want?
05:55:18 <wolverian> roconnor, it is _important_ on large mail servers that the admin can restrict what the rules do :)
05:55:37 <EvilTerran> the point is, if you don't export the constructor, you *can* restrict what the rules do
05:55:38 <wolverian> roconnor, piping the mail to other programs, storing in folders, inspecting headers, things like that.
05:55:52 <roconnor> roconnor: only actions that you wrap and export from the module will be allowed with EvilTerran's definition
05:56:04 <roconnor> er
05:56:08 <roconnor> I'm talking to myself
05:56:12 <EvilTerran> because only your library can define new flavours of action
05:56:20 <opqdonut> modet valvoo
05:56:20 * EvilTerran pokes roconnor with a sharp stick
05:56:24 <opqdonut> whoops
05:56:26 <opqdonut> wrong channel ^_^
05:56:29 <wolverian> ah, I see.
05:56:32 <EvilTerran> go get some coffee or something ;)
05:56:44 * roconnor goes grab another cup of tea
05:56:52 <EvilTerran> mmm, tea
05:57:02 * idnar gets coffee
05:57:06 * opqdonut gets shower
05:57:13 * EvilTerran has tea (^.^)-c\_/
05:57:32 * ricky_clarkson bacon!
05:58:07 <wolverian> EvilTerran, can you show me the type of an example action?
05:58:19 <ricky_clarkson> :t return 5
05:58:20 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
05:58:29 <roconnor> wolverian: the important bit is to not export ProcMailMonad's constructor; that way no one can make their own ProcMailMonad commands.
05:58:31 <ricky_clarkson> :t return "hi"
05:58:32 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
05:58:49 <wolverian> roconnor, right.
05:58:54 <ricky_clarkson> :t return "hi" :: IO String
05:58:55 <lambdabot> IO String
05:59:11 <EvilTerran> procMailReadFile :: FilePath -> ProcMailMonad String; procMailReadFile = ProcMailMonad . readFile
05:59:29 <opqdonut> wolverian: for example putItIntoFile file = writeFile file
05:59:34 <roconnor> > return "hi" :: IO String
05:59:35 <lambdabot>  <IO [Char]>
05:59:50 <opqdonut> yeah, wrapped in the ProcMailMonad constructor like EvilTerran's
05:59:57 * wolverian is enlightened 
06:00:24 <wolverian> thanks, all. I'll ask more stupid questions at some point, probably. :)
06:00:40 <roconnor> of course I don't recommend wrapping read file and write file :)
06:01:02 <roconnor> better to make your own token system to replace the arbitray FilePath
06:01:18 <roconnor> that way users won't end up writing things all over the place.
06:01:20 <mxc> anyone familiar with HXT?
06:01:38 <mxc> and willing to answer stupid questions?
06:01:40 <b_jonas> that doesn't seem general enough...
06:02:09 <b_jonas> I mean, I can't see why you could break all cycles that way
06:02:13 <alar> I am
06:02:20 <b_jonas> wouldn't you need multiple levels of -boot files?
06:02:47 <roconnor> capability-based security is way better than access-control-based security.
06:10:00 <mxc> so just for example, i have the following code:
06:10:02 <mxc> --readKDicFile :: Attributes ->  String -> IOSArrow b Int
06:10:02 <mxc> readKDicFile attrs src =
06:10:02 <mxc>   readDocument attrs src >>>
06:10:03 <mxc>   deep (hasName "nanori")  >>>
06:10:03 <mxc>   writeDocument [] "-" >>>
06:10:03 <mxc>   --writeDocument [(a_show_haskell, "True")] "-" >>>
06:10:04 <mxc>   getErrStatus
06:10:36 <mxc> i'm trying to get at least one node <nanori>...</nanori> that is somewhere in the xml file
06:10:48 <mxc> but writeDocument doesn't print anything
06:11:30 <mxc> when i take out the deep arrow, i get the entire file, which contains some <nanori> nodes
06:12:14 <b_jonas> other questoion: are there such things as "singleton" classes
06:12:26 <opqdonut> hmm?
06:12:35 <opqdonut> you mean like Unique?
06:12:37 <b_jonas> which would be (multi-parameter) classes without parameters or classes with all parameters fundepping on nothing
06:12:38 <opqdonut> (probably not)
06:14:00 <mxc> oops, ignore that commented type declaration
06:15:04 <mxc> the readKDic function is called in:   runX (readKDicFile [] fName)
06:15:04 <mxc>  
06:15:13 <EvilTerran> b_jonas, you can say class Foo a | -> a where ...
06:15:37 <EvilTerran> I don't think you can have a class with no parameters, tho
06:15:48 <int-e> mxc: hmm. in my hxt experiment I used (isA (\n -> localpart n == "nanori")) and not hasName ... I don't remember why. (does hasName expect a fully qualified name? I forgot)
06:17:18 <int-e> hmm
06:17:37 <alar> I suppose
06:18:10 <int-e> mxc: that should be (getAttrName >>> isA (\n -> localPart n == "nanori"))
06:18:13 <alar> you should replace deep (hasName "nanori") with replaceChildren (deep (hasName "nanori"))
06:18:23 <b_jonas> yep, ghci says "No parameters for class `Foo'" even with -fglasgow-exts
06:19:01 <alar> because writeDocument expects root node that has document as a child
06:20:09 <mxc> ah
06:20:25 <desegnis> @pl \x y  ->  x >>= \a -> y >> return a
06:20:25 <lambdabot> (. ((. return) . (>>))) . (>>=)
06:20:28 <desegnis> bah.
06:22:43 * alar wonders what is "nanori"
06:23:40 <desegnis> I hoped there was a nice operator for that, thinking of parser combinators:  inParens t  =  char '(' >> t >>* char ')'  where (>>*) = see above
06:25:20 <b_jonas> and indeed
06:25:37 <b_jonas> a class with only one parameter bound as a fundep of nothing does work
06:25:43 <b_jonas> (with ghc)
06:25:59 <b_jonas> I wonder why the former isn't allowed then
06:28:18 <mxc> alar - i'm doing somethings with a japanese character dictionary
06:28:30 <mxc> nanori is just one of the fields for each character
06:28:49 <b_jonas> hmm
06:29:19 <desegnis> Ah, so I've found what I looked for in Control.Applicative
06:31:05 <hpaste>  b_jonas pasted "fundeps problem" at http://hpaste.org/4695
06:31:25 <b_jonas> I'm getting a fundep type error there
06:31:32 <b_jonas> could you tell me what's the problem?
06:45:08 <desegnis> b_jonas: I think you need to annotate  print (bar :: Int)
06:45:25 <desegnis> which may be a bug
06:45:53 <b_jonas> desegnis: that doesn't seem to help, same error
06:47:44 <desegnis> b_jonas: It works in ghc 6.8.1, but not in 6.6
06:48:02 <b_jonas> ah, I see
06:48:18 <b_jonas> I'll consider upgrading then
06:48:32 <desegnis> still, only with mentioned annotation
06:51:50 <desegnis> Do people actually use fundeps of that style (that is, class C a | -> a)?
06:52:14 <b_jonas> desegnis: I don't know
06:56:43 <Saizan> b_jonas: that fundep doesn't make much sense, i'm surprised it is even legal, i suppose the meaning is that you can have only one instance?
06:57:58 <b_jonas> Saizan: that's why I said "singleton" above
06:58:12 <b_jonas> I think it could make sense to break a circular dependency among modues
06:58:23 <b_jonas> that is, when the instance is in one module, and the class is in the other
06:59:55 <Saizan> oh, sorry didn't read the context
07:07:29 <mxc> anyone familiar with unicode problems in ghc?
07:07:32 <mxc> can'
07:08:01 <mxc> i can't get haskell to output acutal double-byte characters, it outputs the escape code instead of the character
07:11:22 <Saizan> mxc: how are you outputting them? print?
07:11:35 <mxc> putStr[ln]
07:12:00 <Saizan> that should output the least 8 bits for each Char
07:12:47 <Saizan> in which encoding would you get your output?
07:12:59 <mxc> ideally UTF-8
07:13:26 <int-e> mxc, you could try http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.2
07:13:27 <lambdabot> http://tinyurl.com/2e6gmt
07:13:32 <Saizan> yeah
07:14:20 <alar> can someone point me to an informal tutorial on xpath?
07:14:42 <alar> greetings to adept
07:15:37 <ari> @oeis 6 20 70
07:15:38 <lambdabot> Central binomial coefficients: C(2n,n) = (2n)!/(n!)^2.
07:15:38 <lambdabot> [1,2,6,20,70,252,924,3432,12870,48620,184756,705432,2704156,10400600,40116600...
07:15:52 * ari cheats on Project Euler
07:17:00 <ADEpt> alar:
07:17:32 <olsner> what's a good name for the function (\m x -> m x >> return x)?
07:18:19 <idnar> @pl \m x -> m x >> return x
07:18:19 <lambdabot> (`ap` return) . ((>>) .)
07:19:07 <idnar> probably not that
07:19:07 <olsner> yes, that's *much* simpler :P
07:19:29 <resiak> @pl \m n x -> m x >> n x
07:19:29 <lambdabot> liftM2 (>>)
07:19:49 <olsner> oh, liftM2 (>>) m return then
07:20:00 <resiak> hrm, there's a =<< but no <<
07:20:02 <resiak> how disappointing
07:20:14 <olsner> could do flip (liftM2 (>>)) return
07:20:17 <idnar> @pl \m -> (liftM2 (>>)) m return
07:20:17 <lambdabot> flip (liftM2 (>>)) return
07:20:35 <olsner> @ty let (<<) = flip (>>) in liftM2 (<<) return
07:20:35 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> a1 -> m a1
07:21:30 <idnar> is flip (liftM2 (>>)) the same as liftM2 (flip (>>)) ?
07:22:05 <int-e> idnar, no. the order in which the two arguments are sequenced in the monad is different
07:22:21 <idnar> ah, good point
07:22:27 <gbacon> I'm getting No instance for (MonadError String m), but don't both IOError and Either provide such implementations?
07:22:29 <olsner> but isn't liftM2 (>>) already bound to the (a ->) monad?
07:22:34 <olsner> @ty liftM2 (>>)
07:22:34 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
07:23:27 <int-e> > flip (liftM2 (>>)) [[1],[2]] [[1],[2]]
07:23:28 <lambdabot>  [[1],[2],[1],[2]]
07:23:41 <int-e> > liftM2 (flip (>>)) [[1],[2]] [[1],[2]]
07:23:42 <lambdabot>  [[1],[1],[2],[2]]
07:23:50 <gbacon> foo :: MonadError String m => String -> m String; foo x = return "foo"
07:24:59 <desegnis> gbacon: (Either String) is not (String m).
07:27:59 <mxc> int-e, saizan, still just spitting out escape sequences, any ideas?
07:28:07 <mxc> even using the utf8 package
07:28:15 <gbacon> then how does readM in dons' cpuperf typecheck?
07:28:20 <olsner> @ty let andReturn = liftM2 (>>) m return in print `andReturn` "123"
07:28:20 <lambdabot> Not in scope: `m'
07:28:30 <olsner> @ty let andReturn m = liftM2 (>>) m return in print `andReturn` "123"
07:28:31 <lambdabot> IO [Char]
07:28:40 <gbacon> http://www.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
07:28:42 <lambdabot> Title: Haskell hacking, http://tinyurl.com/2qxb8e
07:28:42 <resiak> olsner: nice name!
07:28:48 <mxc> hm, just a sec
07:29:21 <olsner> I like using `` to produce readable code ;-)
07:29:56 <int-e> mxc: where does the string originally come from?
07:30:16 <gbacon> desegnis: my example typechecks, but when I try to call it from ghci, I get the aforementioned error
07:30:23 <Saizan> ?type let  foo :: MonadError String m => String -> m String; foo x = return "foo" in foo
07:30:24 <lambdabot> forall (m :: * -> *). (MonadError String m) => String -> m String
07:31:16 <gbacon> ?type let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar"
07:31:17 <lambdabot> forall (m :: * -> *). (MonadError String m) => m String
07:31:53 <desegnis> Ah sorry, I had flipped the parameters of MonadError in my mind
07:32:01 <Saizan> gbacon: ghci doesn't know which instance to pick, you've to force it somehow, maybe with a type annotation
07:32:29 <gbacon> ?type let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: Maybe
07:32:29 <lambdabot>     `Maybe' is not applied to enough type arguments
07:32:29 <lambdabot>     Expected kind `?', but `Maybe' has kind `* -> *'
07:32:29 <lambdabot>     In an expression type signature:
07:32:53 <Saizan> > let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: Maybe String
07:32:54 <lambdabot>      Non type-variable argument in the constraint: MonadError String m
07:32:54 <lambdabot>     (U...
07:32:57 <mxc> hard code in the .hs file and an xml file
07:33:06 <mxc> for example: main = do
07:33:06 <mxc>   hSetBuffering stdin LineBuffering
07:33:06 <mxc>   putStrLn "enter filename:"
07:33:06 <mxc>   --fName <- getLine
07:33:06 <mxc>   rc <- runX (readKDicFile [] "kdic-shrt.xml")
07:33:07 <mxc>   --rc <- runX (readKDicFile [] fName)
07:33:08 <mxc>   U8.print  $ U8Codec.encodeString "文字の数: "
07:33:12 <mxc> ugh , sorry
07:33:20 <mxc> main = do
07:33:20 <mxc>   hSetBuffering stdin LineBuffering
07:33:21 <mxc>   U8.print  $ U8Codec.encodeString "文字の数: "
07:33:41 <Saizan> ?type let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: Maybe String -- > doesn't have extensions
07:33:42 <lambdabot>     No instance for (MonadError String Maybe)
07:33:42 <lambdabot>       arising from use of `foo' at <interactive>:1:78-86
07:33:42 <lambdabot>     Possible fix:
07:33:43 <mxc> U8 and U8Codec are the imported modules from the ut8-string package
07:35:11 <gbacon> to my mind it looks like a super-simple cousin to dons's readM, but I must be missing some essential difference
07:35:12 <int-e> mxc: you're encoding the string twice I believe.
07:36:15 <int-e> mxc: uh. try U8.putStrLn "<your string>"
07:37:33 <gbacon> ?type let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: IO String
07:37:33 <lambdabot>     Couldn't match expected type `String'
07:37:33 <lambdabot>            against inferred type `IOError'
07:37:33 <lambdabot>       Expected type: String
07:37:57 <gbacon> ?type let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: Either String
07:37:58 <lambdabot>     `Either String' is not applied to enough type arguments
07:37:58 <lambdabot>     Expected kind `?', but `Either String' has kind `* -> *'
07:37:58 <lambdabot>     In an expression type signature:
07:38:08 <gbacon> ?type let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: Either String String
07:38:08 <lambdabot> Either String String
07:38:20 <gbacon> > let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: Either String String
07:38:20 <lambdabot>      Non type-variable argument in the constraint: MonadError String m
07:38:20 <lambdabot>     (U...
07:38:42 <gbacon> lambdabot: enable glasgow-exts, wouldya?
07:38:43 <praetorian42> so, i'm trying to install cabal-install, and it gives me this error: "dyld: Library not loaded: /opt/local/lib/libreadline.5.2.dylib"... how do i install libreadline?  i don't see it referenced anywhere...
07:38:53 <int-e> mxc: U8.print still uses the normal Show instance for String, which generates ASCII characters only (quoting everything else).
07:39:43 <mxc> got it
07:39:45 <mxc> thanks
07:39:53 <mxc> the problem was was show
07:40:26 <gbacon> hmm.. so it's happy in the Either monad
07:40:58 <gbacon> but why not Maybe?
07:41:27 <Saizan> gbacon: because there's no MonadError instance for Maybe in the standard libs
07:41:46 <Saizan> ?instance-importing Control.Monad.Error MonadError
07:41:47 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
07:42:15 <gbacon> ?instances MonadError
07:42:15 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
07:42:44 <olsner> ooh, being able to cherry-pick changes in darcs record was neat!
07:43:13 <gbacon> > let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: IOError IO
07:43:13 <lambdabot>      Non type-variable argument in the constraint: MonadError String m
07:43:13 <lambdabot>     (U...
07:44:09 <Saizan> gbacon: IOError and IO are the two parameters of the class, they don't correspond to a valid type
07:45:08 <Saizan> s/class/instance/
07:46:32 <gbacon> so why won't it run in the IO monad?
07:47:22 <Saizan> it would, but you've to use IO String as the type in that case
07:47:31 <oerjan> lambdabot's > only accepts H98 syntax, i think
07:47:37 <gbacon> > let foo :: MonadError String m => String -> m String; foo x = return "foo" in foo "bar" :: IO
07:47:37 <lambdabot>      Non type-variable argument in the constraint: MonadError String m
07:47:37 <lambdabot>     (U...
07:47:41 <gbacon> phbbt
07:47:42 <oerjan> so no MPTC's
07:47:45 <gbacon> doesn't typecheck in ghci
07:47:58 <gbacon> couldn't match String against IOError
07:48:14 <oerjan> oh right
07:48:16 <Saizan> uh, yeah
07:48:30 <gbacon> because I constrained it in the type?
07:48:36 <Saizan> exaclty
07:48:42 <oerjan> the instance for IO is MonadError IOError IO
07:48:59 <oerjan> and the class has a functional dependency
07:51:06 <oerjan> > let foo :: MonadError e m => String -> m String; foo x = return "foo" in foo "bar" :: IO String
07:51:06 <lambdabot>  <IO [Char]>
07:51:40 <oerjan> hm, MPTC's are allowed anyhow
07:53:25 <gbacon> oerjan: spiffy.. but ghci doesn't like it
07:53:51 <gbacon> has -fglasgow-exts changed the semantics?
07:54:08 <gbacon> couldn't match m against []
07:55:28 <oerjan> er, are you sure you used my line literally?
07:55:36 <gbacon> I have to double wrap it in ghci (return . return)
07:56:18 <oerjan> exactly what line are you using?
07:56:23 <gbacon> oh, I dropped the parameter... sorry
07:56:33 <gbacon> s/foo =/foo x =/
07:56:51 <oerjan> ic
07:57:23 <gbacon> but inside the IO monad, I'd need to throw IOErrors, correct?
07:57:36 <gbacon> but throwError ought to take care of that, shouldn't it?
07:57:42 <Saizan> it does
07:57:49 <oerjan> :t throwError
07:57:49 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
07:57:57 * gbacon nods
07:58:02 <gbacon> such a cool language
07:58:08 <Saizan> well you've to give it an IOError
07:59:48 <swiert> @seen mattam
07:59:48 <lambdabot> mattam is in #haskell and ##logic. I last heard mattam speak 1d 19h 23m 45s ago.
08:00:02 <gbacon> @ty throwError "help!" :: IO String
08:00:02 <lambdabot> <command line>:
08:00:03 <lambdabot>     Could not find module `L':
08:00:03 <lambdabot>       Use -v to see a list of the files searched for.
08:00:21 <gbacon> @type throwError "help!" :: IO String
08:00:21 <lambdabot> <command line>:
08:00:21 <lambdabot>     Could not find module `L':
08:00:21 <lambdabot>       Use -v to see a list of the files searched for.
08:00:51 <Saizan> ?src Error
08:00:51 <lambdabot> class Error a where
08:00:51 <lambdabot>     noMsg  :: a
08:00:51 <lambdabot>     strMsg :: String -> a
08:00:57 <oerjan> that's a weird error message
08:01:21 <oerjan> although the _real_ culprit is that you are trying to pass a String to throwError's IO instance, i think
08:01:51 <Saizan> throwError . strMsg :: MonadError e m, Error e => String -> m a, you might want this?
08:02:07 <oerjan> aka fail </ducks>
08:02:18 <Saizan> heh, yeah :)
08:02:22 * gbacon grins
08:03:03 <Saizan> ?type catchError
08:03:04 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
08:03:10 <oerjan> @src ErrorT fail
08:03:10 <lambdabot> fail msg = ErrorT $ return (Left (strMsg msg))
08:03:14 <Saizan> no way back though
08:03:28 <gbacon> but is fail the method some say was a mistake?
08:03:36 <oerjan> yep
08:03:49 <gbacon> what's the better alternative?
08:03:54 <oerjan> @src ErrorT throwError
08:03:55 <lambdabot> Source not found. My pet ferret can type better than you!
08:04:05 <oerjan> there isn't any
08:04:12 <Saizan> it's a mistake to have it in Monad, not per se
08:04:24 <gbacon> where should it be?
08:04:26 <b_jonas> ErrorT is the class, isn't it?
08:04:34 <oerjan> @src throwError
08:04:34 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:04:38 <b_jonas> no wait, it isn't
08:06:21 <gbacon> oerjan, Saizan: thank you for your help and for your patience
08:06:32 <Saizan> gbacon: there's not a large consensus for that, but in a class of monads that have a notion of failure, like MonadError or MonadPlus
08:08:31 <mattam> hi swiert
08:08:40 <swiert> mattam: hiya.
08:08:40 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
08:09:19 <swiert> mattam: I was stuck with a bit of Program madness, but I think I just realized how to fix it.
08:09:47 <mattam> Some Qed with structurally recursive defs problem ?
08:12:00 <swiert> mattam: no. oddly enough there was something along the lines of "obligation1" appearing in the goal of "obligation2"
08:12:54 <mattam> ah, then it's me being too liberal about what sort an obligation can have :)
08:12:57 <shapr> Yay Haskell!
08:13:06 <mattam> hi shapr
08:13:18 <shapr> Salut mattam!
08:16:39 <swiert> hi shapr.
08:17:57 <swiert> mattam: actually, it was a bit weirder - the "obligation1" was in one function, that popped up in the goal of an obligation of another function. I can send you the file if you're interested.
08:19:14 <shapr> hoi swiert!
08:20:13 <mattam> swiert: you mean mutually recursive functions i guess ?
08:20:27 <swiert> mattam: no. one function calling another.
08:20:39 <mattam> Yeah I'd like to see it
08:20:45 <mattam> Someday #haskell will be some kind of subchannel of #typetheory, i hope :)
08:22:52 <ricky_clarkson> There's a #typetheory?
08:22:56 <ricky_clarkson> Prove it!
08:23:12 <mattam> /join #typetheory
08:23:17 <mattam> Qed.
08:23:37 <swiert> mattam: another unrelated bugreport: pattern matching on a Prop in a Program gave me an "anomaly" error that I should report.
08:23:45 <swiert> mattam: but there it was my fault, not yours.
08:24:05 <mattam> great, noted.
08:24:07 <ricky_clarkson> That does not prove the absence of #typetheory. In fact it proves the presence of it, if only for a moment.
08:24:37 <mattam> I wanted to prove the existence of it.
08:24:57 * RayNbow looks at the time
08:27:15 <RayNbow> so... it took me like 5 hours to finally find the right version of wxWidgets + wxHaskell that I could compile...? :p
08:27:44 <Saizan> write it somewhere!
08:28:16 <RayNbow> write what to where? :p
08:28:50 <b_jonas> haskell wiki?
08:30:35 <swiert> mattam: just sent you the obligation I couldn't prove.
08:32:55 <RayNbow> if anyone with Windows is interested...
08:32:59 <RayNbow> http://elektron.its.tudelft.nl/~vliege60/binaries/wxhaskell-bin-msw2.6.4-ghc6.8.2-0.10.1-0.zip
08:33:00 <lambdabot> http://tinyurl.com/33j2w2
08:33:19 <RayNbow> wxHaskell for wxWidgets 2.6.4 and GHC 6.8.2
08:34:55 <Zao> Hmm, might be worth a try.
08:58:13 <roconnor> RayNbow: I went through that a few months ago
08:58:37 <roconnor> RayNbow: but now you get to play with GuiTV
08:59:11 <RayNbow> GuiTV?
08:59:24 <roconnor> @wiki GuiTV
08:59:24 <lambdabot> http://www.haskell.org/haskellwiki/GuiTV
09:00:17 <RayNbow> interesting
09:01:18 <roconnor> I found it a bit confusing at first, because Conal has abstracted his project into lots of distinct (and independent) modules
09:01:38 <roconnor> but with his help I was able to understand his framework
09:01:59 <roconnor> It is very nice for making very quick UIs
09:02:14 <roconnor> quick GUIs rather
09:07:27 <ertai> @pl \_-> f
09:07:27 <lambdabot> const f
09:09:02 <ertai> @pl \x -> f1 x >> f2 x
09:09:02 <lambdabot> liftM2 (>>) f1 f2
09:09:38 <olsner> is lines smart, or is it safe to do unlines . lines on binary data?
09:09:56 <oerjan> olsner: it will add a final \n if there is none
09:10:15 <oerjan> > lines . unlines $ "testing\nho"
09:10:17 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
09:10:26 <oerjan> huh?
09:10:38 <oerjan> > unlines . lines $ "testing\nho"
09:10:38 <olsner> oerjan: unlines . lines?
09:10:39 <lambdabot>  "testing\nho\n"
09:10:55 <roconnor> @check lines . unlines === id
09:10:55 <lambdabot>   Not in scope: `==='
09:11:11 <spurion> that was a staggeringly unhelpful error message, wasn't it :)
09:11:17 <omnId> @let (f === g) x = f x == g x
09:11:18 <roconnor> @check \x -> (lines . unlines) x == x
09:11:19 <lambdabot> Defined.
09:11:20 <lambdabot>  Falsifiable, after 412 tests: ["\704883\886136\856814\820631\343474\1066684\...
09:11:24 <oerjan> spurion: which one?
09:11:28 <ertai> @pl \x -> f1 x >> f2
09:11:28 <lambdabot> (>> f2) . f1
09:11:35 <spurion> from getting  unlines and lines back to front.
09:11:44 <roconnor> @check \x -> (unlines . lines) x == x
09:11:44 <lambdabot>  Falsifiable, after 0 tests: "\155360\929957\378020"
09:11:53 <roconnor> there are your counter examples :P
09:12:34 <oerjan> @scheck \x -> (unlines . lines) x == x
09:12:35 <lambdabot>   Failed test no. 2. Test values follow.: "a"
09:13:17 <int-e> @check \x -> (unlines . lines) (x ++ "\n") == (x ++ "\n")
09:13:17 <lambdabot>  OK, passed 500 tests.
09:13:29 <oerjan> spurion: the error message is cut off
09:13:50 <oerjan> the full message will give which expressions are the problem
09:13:56 <spurion> Well, I know
09:13:57 <LoganCapaldo> @check let f `isInverseOf` g = \x -> (f . g) x == x in unlines `isInverseOf` lines
09:13:57 <lambdabot>  Falsifiable, after 1 tests: "\746484\458567"
09:14:48 <spurion> I just find it very common that the error message makes perfect sense, but only once you've worked out for yourself what the problem is.
09:15:01 <b_jonas> spurion: yeah
09:15:06 <b_jonas> the computer is always right
09:15:11 <LoganCapaldo> I loves having functions as my unit of combiningness
09:15:24 <b_jonas> LoganCapaldo: ?
09:15:27 <spurion> It's a natural consequence of type inference, sadly.
09:15:36 <b_jonas> what does "unit of combiningness" means
09:15:42 <LoganCapaldo> jheh
09:15:50 <LoganCapaldo> well as opposed to classes for instance
09:16:00 <LoganCapaldo> if that makes any sense
09:16:02 <spurion> "unit of composition"
09:16:28 <b_jonas> you mean, you measure complexity of a code in the number of functions?
09:16:45 <oerjan> @check \x -> (unlines . lines) x == x ++ "\n"
09:16:45 <lambdabot>  Falsifiable, after 1 tests: ""
09:16:59 <oerjan> @check \x -> not (null x) ==> (unlines . lines) x == x ++ "\n"
09:17:00 <lambdabot>  OK, passed 500 tests.
09:17:06 * oerjan grins evilly
09:17:32 <b_jonas> @check \x -> x != 42
09:17:33 <lambdabot>   Not in scope: `!='
09:17:36 <b_jonas> @check \x -> x <> 42
09:17:37 <lambdabot>   Not in scope: `<>'
09:17:42 <b_jonas> @check \x -> x /= 42
09:17:43 <oerjan>  /=
09:17:43 <lambdabot>  Add a type signature
09:17:57 <b_jonas> @check \(x :: Int) -> x /= 42
09:17:57 <lambdabot>  Parse error in pattern at "->" (column 13)
09:17:58 <LoganCapaldo> I  mean tht the function is the smallest abstraction, as opposed to something like java where the class is the smallest abstraction
09:18:06 <omnId> @check \x -> x /= (42::Int)
09:18:07 <lambdabot>  Falsifiable, after 220 tests: 42
09:18:15 <b_jonas> oh
09:18:17 <olsner> meh, I think I'll just stick to plain-text and encode this data in hex... even though unlines . lines is almost entirely safe
09:18:40 <b_jonas> @check \(x :: Int) -> x /= 137
09:18:40 <lambdabot>  Parse error in pattern at "->" (column 13)
09:18:54 <b_jonas> @check \x -> (x :: Int) /= 137
09:18:55 <lambdabot>  OK, passed 500 tests.
09:19:11 <Syzygy-> b_jonas, LoganCapaldo: I wanna say something erudite and sensible to the whole complexity-of-code issue. But it will end up being horribly algebraic and I'm not convinced my way of thinking about it is conveyed that clearly.
09:19:50 <oerjan> olsner: if you do a variant of lines that keeps the newlines, you should be safe
09:19:54 <byorgey> @check \x -> (x :: Int) /= 137
09:19:55 <lambdabot>  OK, passed 500 tests.
09:19:56 <byorgey> @check \x -> (x :: Int) /= 137
09:19:57 <lambdabot>  OK, passed 500 tests.
09:20:43 <oerjan> > groupBy (const (/= '\n')) "testing\nho\nagain"
09:20:43 <lambdabot>  ["testing","\nho","\nagain"]
09:21:13 <Syzygy-> It boils down to "Functions are corollas in a specific PROP internal to the Haskell category, and we can grade these things by the number of internal vertices. Hence, one possibly good complexity-of-code would be the grading in this way of the functions as morphisms in Hask"
09:21:19 <olsner> @ty groupBy
09:21:20 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
09:21:38 <Syzygy-> But I'm not even certain -I- know what I'm trying to say.
09:21:41 <Syzygy-> So I won't.
09:21:51 <Saizan> you just did!
09:21:54 <olsner> > groupBy (const . (/= '\n')) "testing\nho\nagain"
09:21:55 <lambdabot>  ["testing\nho\nagain"]
09:22:10 <Syzygy-> > groupBy (>) [1,3,5,2,4,6,9,8]
09:22:11 <lambdabot>  [[1],[3],[5,2,4],[6],[9,8]]
09:22:25 <Syzygy-> o.O
09:22:31 <olsner> oh, it keeps the first item of the group around
09:22:36 <omnId> 5 > 2, 5 > 4
09:22:43 <omnId> 5 < 6
09:22:44 <Saizan> it compares everythin with the first
09:22:58 <Syzygy-> Right.
09:23:29 <oerjan> olsner: alas, i realized it would have been more useful if it always compared adjacent elements
09:23:44 <omnId> @src groupBy
09:23:44 <lambdabot> groupBy _  []       =  []
09:23:45 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:23:45 <lambdabot>     where (ys,zs) = span (eq x) xs
09:23:49 <Saizan> so uhm, the heads are a "local maximum" ?
09:24:25 <Syzygy-> One of the functions I'm using in San Diego to introduce Haskell for mathematicians boils down, with a groupBy that compares adjacent elements, to > groupBy (<) lst
09:24:45 <Syzygy-> But with this groupBy it's not even expressible.
09:25:28 <Saizan> that gives crescent sublists?
09:25:42 <Syzygy-> Saizan: I want monotonic sublists.
09:26:01 <Syzygy-> So I want [1,3,5,2,4,6,9,8] to decompose into [[1,3,5],[2,4,6],[9],[8]]
09:26:07 <Syzygy-> > groupBy (<) [1,3,5,2,4,6,9,8]
09:26:08 <lambdabot>  [[1,3,5,2,4,6,9,8]]
09:27:41 <gbacon> > groupBy (>) [1,3,5,2,4,6,9,8]
09:27:42 <lambdabot>  [[1],[3],[5,2,4],[6],[9,8]]
09:28:07 <b_jonas> > groupBy (<=) [1,3,5,2,4,6,9,8]
09:28:07 <lambdabot>  [[1,3,5,2,4,6,9,8]]
09:29:29 <oerjan> hm...
09:30:56 <gbacon> @src groupBy
09:30:56 <lambdabot> groupBy _  []       =  []
09:30:57 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:30:57 <lambdabot>     where (ys,zs) = span (eq x) xs
09:32:30 <gbacon> > span (<1) [3,5,2,4,6]
09:32:31 <lambdabot>  ([],[3,5,2,4,6])
09:32:51 <oerjan> > map snd . groupBy (const (uncurry (<))) . join (zip.(undefined:).tail) $ [1,3,5,2,4,6,9,8]
09:32:51 <lambdabot>  Couldn't match expected type `(a, b)'
09:33:22 <oerjan> > map (map snd) . groupBy (const (uncurry (<))) . join (zip.(undefined:).tail) $ [1,3,5,2,4,6,9,8]
09:33:22 <lambdabot>  [[1],[3],[5],[2],[4],[6],[9],[8]]
09:33:56 <wy> http://syntaxfree.wordpress.com/2007/02/22/bycicling-for-collatz
09:33:57 <lambdabot> Title: Bicycling for Collatz  Data.Syntaxfree
09:34:14 <oerjan> > join (zip.(undefined:).tail) $ [1,3,5,2,4,6,9,8]
09:34:14 <lambdabot>  Undefined
09:34:23 <oerjan> > tail . join (zip.(undefined:).tail) $ [1,3,5,2,4,6,9,8]
09:34:24 <lambdabot>  [(3,3),(5,5),(2,2),(4,4),(6,6),(9,9),(8,8)]
09:34:32 <oerjan> bah
09:34:57 <oerjan> > join (zip.(undefined:)) $ [1,3,5,2,4,6,9,8]
09:34:58 <lambdabot>  Undefined
09:35:14 <oerjan> > map (map snd) . groupBy (const (uncurry (<))) . join (zip.(undefined:)) $ [1,3,5,2,4,6,9,8]
09:35:14 <lambdabot>  [[1,3,5],[2,4,6,9],[8]]
09:35:23 <oerjan> whee
09:35:28 <wy> Interesting. I hope we can visualize lots of computations like that
09:36:04 <oerjan> Syzygy-: not expressible you said? ;)
09:37:16 <b_jonas> lol
09:38:44 <gbacon> @unpl map (map snd) . groupBy (const (uncurry (<))) . join (zip.(undefined:))
09:38:44 <lambdabot> (\ e -> map (map snd) (groupBy (\ _ -> uncurry (<)) (((\ m -> zip (undefined : m)) >>= \ i -> i) e)))
09:39:15 <Syzygy-> oerjan: Oooookay. It is expressible, but I don't view that as particularly readable...
09:42:17 <oerjan> never said it was.  but it may still be the clearest pointfree way...
09:44:09 <oerjan> @pl \cmp -> map (map snd) . groupBy (const (uncurry cmp)) . join (zip.(undefined:))
09:44:10 <lambdabot> (map (map snd) .) . (. (zip =<< (undefined :))) . groupBy . const . uncurry
09:44:46 <Saizan> not bad :)
09:45:08 <oerjan> it even simplified the join bit
09:46:17 <Saizan> yeah, best written as |ap zip (undefined:)| though
09:46:50 <oerjan> um no
09:47:06 <oerjan> that would zip in the wrong order
09:47:17 <oerjan> although you could modify the rest for it
09:47:39 <Syzygy-> oerjan: Check out http://mpc723.mati.uni-jena.de/~mik/sandiego_saneblidzeumblehaskell.pdf for my solution
09:47:40 <lambdabot> http://tinyurl.com/3c7e63
09:49:31 <Saizan> > join (zip.(0:)) $ [1,3,5,2,4,6,9,8]
09:49:31 <lambdabot>  [(0,1),(1,3),(3,5),(5,2),(2,4),(4,6),(6,9),(9,8)]
09:49:41 <Saizan> > ap zip (0:) $ [1,3,5,2,4,6,9,8]
09:49:42 <lambdabot>  [(1,0),(3,1),(5,3),(2,5),(4,2),(6,4),(9,6),(8,9)]
09:50:28 <oerjan> > zip =<< (0:) $ [1,3,5,2,4,6,9,8]
09:50:28 <lambdabot>  [(0,1),(1,3),(3,5),(5,2),(2,4),(4,6),(6,9),(9,8)]
09:58:37 <Spark> what does haskell have in the way of custom binary operators?
09:58:41 <Spark> i know you can do `my_function`
09:58:59 <Spark> but can you make your own + and call it <+> or something
09:59:23 <RayNbow> yes
09:59:42 <Saizan> > let a <+> b = a - b in 5 <+> 2
09:59:43 <lambdabot>  3
09:59:58 <Spark> how does this work, as it must mean adding new productions to the parser
09:59:59 <oerjan> > ((map (map fst) .) . (. (ap zip (undefined :))) . groupBy . (const .) . uncurry . flip) (<) [1,3,5,2,4,6,9,8]
10:00:00 <lambdabot>  Undefined
10:00:12 <Spark> and there are presumably restrictions to avoid introducing ambiguities in the syntax
10:00:19 <Spark> how do you specify precedence
10:00:33 <allbery_b> infixr/infixl declarations
10:00:33 <oerjan> oh right
10:00:46 <oerjan> > ((map (map fst) .) . (. (ap zip (undefined :))) . groupBy . const . uncurry . flip) (<) [1,3,5,2,4,6,9,8]
10:00:46 <lambdabot>  [[1,3,5],[2,4,6,9],[8]]
10:00:50 <desegnis> Spark: Identifiers that begin with a letter are prefix functions, non-letter strings are binary operators.
10:01:23 <allbery_b> as for new productions, not so much.  <+> is an identifier, just like foo is an identifier
10:01:52 <desegnis> Spark: And there's another rules for infix constructors (mind, constructors are differentiated from plain functions by case)
10:01:58 <oerjan> Spark: actually the haskell 98 report is horribly messy on this, all the compilers just do precedence postprocessing
10:02:00 <desegnis> s/rules/rule
10:02:12 <Saizan> the only tricky part is to apply the associativity rules when you find them
10:03:08 <gigamonkey> Is this: data Board = Board (Array (Int, Int) Color) a sensical data type definition (given that Color has already been defined)?
10:03:20 <b_jonas> oerjan: what?
10:03:31 <gigamonkey> I'm trying to define a data type representing a Go board that contains an array
10:03:32 <Spark> ok i can see how seperating identifiers like that works quite well
10:03:37 <b_jonas> but it's not that complicated to parse infixes with precedences
10:03:39 <Spark> and you can use `` and () when you want to switch
10:03:42 <oerjan> gigamonkey: except that you probably want newtype
10:03:56 <Spark> what is precedence postprocessing
10:04:07 <gigamonkey> oerjan: but this should work too.
10:04:10 <gigamonkey> ?
10:04:22 <oerjan> gigamonkey: newtype is just usually more efficient when it applies
10:04:45 <gigamonkey> If so, how do I construct an instance of this data type?
10:04:49 <oerjan> since it removes one indirection
10:04:58 <gigamonkey> Everything I've tried gives me some kind of type mismatch error.
10:05:15 <Saizan> having x :: Array (Int,Int) Color, Board x :: Board
10:06:19 <Spark> nothing on google about precedence postprocessing
10:06:28 <gigamonkey> Saizan: what's that?
10:06:45 <oerjan> b_jonas: the report interpreted literally intertwines precedence with deciding where expressions end, and layout, in a way that probably is not even well-defined
10:06:46 <gigamonkey> I was trying something like: board = Board array ((0,0),(5,5)) [ (i,EMPTY) | i <- range ((0,0),(5,5)) ]
10:07:03 <b_jonas> oerjan: oh, layout
10:07:07 <b_jonas> I forgot about that, yes
10:07:13 <b_jonas> that probably complicates it
10:07:33 <Saizan> gigamonkey: that's a precedence problem,  board = Board (array ((0,0),(5,5)) [ (i,EMPTY) | i <- range ((0,0),(5,5)) ]) should work
10:07:59 <oerjan> b_jonas: someone claimed someone had created a paradoxical example, where an operator with local fixity declaration was in a given scope iff it wasn't...
10:08:09 <gigamonkey> Saizan: ah, there it is. Thanks.
10:08:18 <Saizan> function application is left-associative and binds tighter than anything else
10:08:22 <b_jonas> oerjan: lol
10:08:25 <b_jonas> that's nice
10:08:27 <desegnis> gigamonkey: Naming Color something else would prevent confusion (how will he represent an empty field? - Oh, there's Empty :: Color ...)
10:08:48 <oerjan> may have been quicksilver who told me...
10:09:57 <roconnor> that array initialization code looks very imperative style.
10:10:14 <roconnor> normally we initialize our arrays with their final values.
10:10:41 <oerjan> Spark: by postprocessing i mean that the actual parsing just parses as alternating simple expressions with operators, leaving to a later pass to group them properly
10:11:04 <Spark> right
10:11:13 <b_jonas> and there's also unary minus
10:11:39 <b_jonas> which has a similar definition in Haskell 98 than layout: fall back to unary minus if binary doesn't work
10:11:57 <Spark> it's easy to see why people have just used ~ in the past
10:12:11 <b_jonas> yeah
10:12:34 <desegnis> It's difficult to see why people don't just use ~ in the present
10:13:02 <desegnis> or neg or negate or whatever
10:13:08 <Spark> i was just thinking htat
10:13:12 <b_jonas> though I also like the choice that unary minus is only allowed in numeric constants
10:13:12 <roconnor> > (-6) 7
10:13:13 <lambdabot>   add an instance declaration for (Num (t -> a))
10:13:13 <lambdabot>     In the expression: (- 6)...
10:13:22 <roconnor> > (subtract 6) 7
10:13:23 <lambdabot>  1
10:14:02 <desegnis> roconnor, right, that's unary-minus confusion as we all love it
10:14:19 <b_jonas> > (+ -6) 7
10:14:19 <lambdabot>      The operator `+' [infixl 6] of a section
10:14:19 <lambdabot>         must have lower precede...
10:14:24 <b_jonas> > (+(-6)) 7
10:14:24 <lambdabot>  1
10:14:41 <Yokisho> >-(6-7)
10:14:50 <Yokisho> :
10:14:53 <roconnor> > -(6 - 7)
10:14:53 <lambdabot>  1
10:15:33 <b_jonas> > -(6-7)
10:15:34 <lambdabot>  1
10:15:44 <Spark> > -1 - -1
10:15:45 <lambdabot>      precedence parsing error
10:15:45 <lambdabot>         cannot mix `(-)' [infixl 6] and prefix ...
10:16:01 <Yokisho> > even 2
10:16:02 <lambdabot>  True
10:16:26 <Yokisho> xD
10:17:52 <oerjan> > nubBy (((>1).).gcd) [2..] -- obligatory demonstration
10:17:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:17:55 <gigamonkey> How do I express a newline in a string literal?
10:18:03 <Syzygy-> \n
10:18:23 <Syzygy-> oerjan: How does that compare speedwise?
10:18:35 <oerjan> probably not very well
10:18:45 <gigamonkey> Duh. I got faked out because ghci printed "abc\ndef" in the same literal form.
10:18:48 <Yokisho> > iterate (+1) 10 -- O_O
10:18:49 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
10:19:06 <Yokisho> oh, good! xD
10:19:08 <Tac-Tics> :t ((>1).)
10:19:09 <lambdabot> forall b a. (Num b, Ord b) => (a -> b) -> a -> Bool
10:19:42 <oerjan> even with mod instead of gcd it's still checking every prime against every number remaining
10:20:11 <Tac-Tics> One liners generally aren't efficient solutions
10:20:28 <roconnor> but they are quick :)
10:20:31 <b_jonas> meh, you call that inefficent?
10:20:33 <Tac-Tics> efficient solutions usually abuse obscurities in mathematics
10:20:45 <b_jonas> I've seen much more inefficent prime generators
10:21:19 <Tac-Tics> @let divisors n = [x | x <- [1..n], n `mod` x == 0]
10:21:21 <lambdabot> Defined.
10:21:22 <b_jonas> like that wierd regex one in perl
10:21:27 <Tac-Tics> @let prime n = length (divisors n) == 2
10:21:28 <lambdabot> Defined.
10:21:31 <b_jonas> where was that...
10:21:36 <Tac-Tics> > prime 13
10:21:36 <lambdabot>  True
10:21:43 <oerjan> > filter prime [2..]
10:21:44 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:22:06 <Tac-Tics> That's the definition I usually use when I'm screwing around with primes
10:22:14 <int-e> > prime (-1)
10:22:14 <lambdabot>  False
10:22:20 <Syzygy-> > prime (-3)
10:22:20 <lambdabot>  False
10:22:26 <Tac-Tics> because it's so easy to remember and close to the math definition of primes
10:22:39 <Tac-Tics> > filter prime [0, -1,..]
10:22:39 <lambdabot>  Parse error at "..]" (column 21)
10:22:39 <Yokisho> @unlet prime
10:22:40 <lambdabot>  Parse error
10:22:57 <gigamonkey> Is there some simple way to iterate over a two-dimensional array?
10:23:00 <Yokisho> :S
10:23:11 <Tac-Tics> > filter prime [0, -1..]
10:23:17 <lambdabot> Terminated
10:23:28 <Tac-Tics> > map prime [0, -1..]
10:23:29 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
10:23:36 <oerjan> Yokisho: there is @undefine which removes all temporary definitions (no way to remove just a single one)
10:23:42 <Syzygy-> > -3 `mod` 3
10:23:43 <lambdabot>  0
10:23:50 <Syzygy-> Ah.
10:23:55 <Syzygy-> The problem is in the 1..n
10:23:57 <Yokisho> ok, oerjan :)
10:24:26 <Syzygy-> @let divisors n = [x | x <- [1..(sqrt.abs)n], n `mod` x == 0]
10:24:26 <lambdabot> <local>:10:0:     Multiple declarations of `L.divisors'     Declared at: <loc...
10:24:33 <Syzygy-> Doh.
10:24:34 <Tac-Tics> gigamonkey: what kind of iteration are you looking for on a 2d array?
10:24:38 <roconnor> gigamonkey: what do you want to use the array data for?
10:24:46 <oerjan> :t assocs
10:24:46 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
10:24:51 <oerjan> gigamonkey: ^^
10:25:42 <gigamonkey> At the moment I'm trying to turn a 2d array into an string representing a Go board.
10:25:55 <b_jonas> ah, here it is: http://www.perlmonks.com/?node_id=510912
10:26:01 <oerjan> gigamonkey: there is also a Data.Foldable instance for Array
10:26:03 <b_jonas> no wait, that doesn't use regexen
10:26:36 <Tac-Tics> If you know the bounds, then: [array ! (x, y) | x <- [1..xBound], y <- [1..yBound]]
10:26:39 <Tac-Tics> Or something like that
10:26:59 <roconnor> :t elems
10:27:00 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
10:27:18 <roconnor> but as oerjan says, assoc is probably what you want
10:28:01 <roconnor> wow, a go board seems like a pretty good use for an array.
10:28:55 <Syzygy-> roconnor: Using Ix (Int,Int) ?
10:29:01 <oerjan> there is also indices if you want a key list
10:29:03 <cjb> Normally people use a 1d array with three different values for empty/white/black.
10:29:10 <gigamonkey> roconnor: are you teasing me or are you actually surprised to find a good use for arrays?
10:29:32 <roconnor> gigamonkey: I'm suprised. Arrays are not as common in Haskell as they are for other languages.
10:29:36 <Tac-Tics> Arrays are harder to use in Haskell and generally aren't as useful unless you need to optimise
10:30:05 <gigamonkey> roconnor: but you think this is actually a good use?
10:30:10 <Tac-Tics> Since everything is immutable, array updates either create new copies of the array or you have to use a stateful monad
10:30:21 <roconnor> Syzygy-: I might be inclined to perhaps newType the Int.
10:30:22 <gigamonkey> Tac-Tics: yeah, I'm just playing around for the moment.
10:30:31 <roconnor> gigamonkey: seems pretty reasonable
10:30:35 <Tac-Tics> Go boards can get really big, and they are probably an ideal use for arrays in Haskell
10:30:36 <gigamonkey> I'll probably switch to a MutableArray one of these days.
10:31:00 <roconnor> gigamonkey: DiffArrays may suit you well
10:31:03 <gigamonkey> so, I'm an idiot. How do I concatenate a list of strings into one big string?
10:31:08 <therp> tac-tic: big? I think 19x19 is pretty much the limit
10:31:09 <gigamonkey> My attempts to foldl aren't working.
10:31:13 <roconnor> @type concat
10:31:13 <lambdabot> forall a. [[a]] -> [a]
10:31:14 <allbery_b> :t concat
10:31:15 <lambdabot> forall a. [[a]] -> [a]
10:31:16 <allbery_b> heh
10:31:19 <gigamonkey> doh.
10:31:27 <roconnor> 19*19
10:31:29 <roconnor> 19*19
10:31:31 <roconnor> > 19*19
10:31:31 <lambdabot>  361
10:32:11 <therp> gigamonkey: you could also ask hoogle when you have an idea of the type signature .. http://www.haskell.org/hoogle/?q=%5B%5Ba%5D%5D+-%3E+%5Ba%5D
10:32:16 <lambdabot> Title: [[a]] -> [a] - Hoogle
10:32:24 <roconnor> @hoogle [[a]] -> [a]
10:32:25 <lambdabot> Prelude.concat :: [[a]] -> [a]
10:32:25 <lambdabot> Data.List.concat :: [[a]] -> [a]
10:32:25 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
10:32:38 <gigamonkey> So just for grins, shouldn't I be able to role my own with foldl?
10:32:51 <Tac-Tics> foldl (++) [] I think
10:33:01 <roconnor> @check \x -> foldr (++) [] x == concat x
10:33:02 <lambdabot>  Add a type signature
10:33:07 <Tac-Tics> or foldr or whatever
10:33:10 <roconnor> @check \x -> foldr (++) [] x == concat (x::[Int])
10:33:11 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
10:33:15 <roconnor> @check \x -> foldr (++) [] x == concat (x::[[Int]])
10:33:17 <lambdabot>  OK, passed 500 tests.
10:33:17 <olsner> should foldr be better for laziness?
10:33:18 <gigamonkey> Ah, I needed the inital value.
10:33:22 <hpaste>  gbacon pasted "monotonically increasing sublists" at http://hpaste.org/4696
10:33:29 <Tac-Tics> > foldr (++) [] [[1,2,3], [4,5,6], [7,8,9]]
10:33:30 <lambdabot>  [1,2,3,4,5,6,7,8,9]
10:33:49 <gbacon> how can I improve that code? (I used foldr rather than groupBy)
10:33:54 <Tac-Tics> > foldr (++) [] ["abc", "def", "ghijklmn", "p"]
10:33:55 <lambdabot>  "abcdefghijklmnp"
10:33:57 <roconnor> @src concat
10:33:57 <lambdabot> concat = foldr (++) []
10:34:02 * Tac-Tics forgot 'o'
10:34:36 <LoganCapaldo> > foldr (foldr (:) []) [] [[1], [2,3], [4]]
10:34:36 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `[a]'
10:34:48 <LoganCapaldo> @src (++)
10:34:48 <lambdabot> (++) []     ys = ys
10:34:48 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
10:34:59 <LoganCapaldo> mm
10:35:14 <LoganCapaldo> > foldr (foldr (:) ) [] [[1], [2,3], [4]]
10:35:14 <lambdabot>  [4,2,3,1]
10:35:21 <LoganCapaldo> doh
10:35:27 <LoganCapaldo> > foldr (foldl (:) ) [] [[1], [2,3], [4]]
10:35:27 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
10:35:27 <lambdabot>       Expected...
10:35:38 <LoganCapaldo> > foldr (foldl (flip (:)) ) [] [[1], [2,3], [4]]
10:35:38 <lambdabot>  [3,2,4,1]
10:35:44 <LoganCapaldo> gah
10:36:09 <LoganCapaldo> > foldr (flip $ foldr (:) ) [] [[1], [2,3], [4]]
10:36:10 <lambdabot>  [1,2,3,4]
10:36:18 <roconnor> ah right
10:36:19 <LoganCapaldo> victory!
10:37:47 <gbacon> @pl \ m x -> m ++ [x]
10:37:48 <lambdabot> (. return) . (++)
10:38:57 <Tac-Tics> @pl foldr (flip $ foldr (:) ) [] [[1], [2,3], [4]]
10:38:57 <lambdabot> [1, 2, 3, 4]
10:39:05 <oerjan> gbacon: reverse, last and ++[x] ? something is not right...
10:39:07 <Tac-Tics> smug bastard lambdabot....
10:39:18 <olsner> > (\x -> reverse . (x:) . reverse) 7 [1,2,3,4]
10:39:19 <lambdabot>  [1,2,3,4,7]
10:39:23 <ertai> @pl \x -> f y x >> g
10:39:23 <lambdabot> (>> g) . f y
10:39:29 <gbacon> oerjan: my impression also :-/
10:39:30 <oerjan> those are all too expensive
10:39:54 <Tac-Tics> @src last
10:39:55 <lambdabot> last [x]    = x
10:39:55 <lambdabot> last (_:xs) = last xs
10:39:55 <lambdabot> last []     = undefined
10:40:00 <ertai> @pl \x -> g >> f y x
10:40:01 <lambdabot> (g >>) . f y
10:40:18 <Tac-Tics> :t (>>)
10:40:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:40:28 <gbacon> the last is because foldr accumulates the sublist, and I need to look at the last element of the most recent sublist
10:40:35 <Tac-Tics> @src (>>)
10:40:35 <lambdabot> m >> k      = m >>= \_ -> k
10:40:58 <Tac-Tics> ack
10:41:01 <oerjan> gbacon: er, i think you can remove all those in one swoop
10:41:06 <Tac-Tics> my brain, I haven't done haskell in a while >___>
10:41:40 <b_jonas> this is the regex one: http://www.perlmonks.com/?node_id=146608
10:41:41 <lambdabot> Title: Re: Re: Prime Number Finder
10:41:56 <gbacon> oerjan: how?
10:42:05 <olsner> start with writing the right groupBy, and then just let mono l = groupBy (<) l
10:42:25 <Syzygy-> k,s
10:42:27 <hpaste>  oerjan annotated "monotonically increasing sublists" with "something like this" at http://hpaste.org/4696#a1
10:42:30 <Syzygy-> olsner: Is that for me?
10:42:43 <b_jonas> ah, it's also in here: http://www.perlmonks.com/?node_id=510925
10:42:44 <lambdabot> Title: Re: Simple primality testing
10:43:03 <olsner> Syzygy-: rather for gbacon I think
10:43:12 <Syzygy-> olsner: He's solving the same thing?
10:43:57 <olsner> Syzygy-: look at the recently annotated hpaste, http://hpaste.org/4696#a1
10:44:03 <Syzygy-> I am looking at it.
10:44:12 <Syzygy-> It even has the example I wrote in the channel a little while ago.
10:44:13 <Tac-Tics> @let mono = groupBy (<)
10:44:13 <lambdabot> <local>:10:15:     Ambiguous type variable `a' in the constraint:       `Ord ...
10:44:49 <Tac-Tics> why is that an error?
10:44:56 <Tac-Tics> it works fine on ghci
10:44:57 <oerjan> monomorphism restriction
10:44:59 <LoganCapaldo> @type groupBy (<)
10:45:00 <lambdabot> forall a. (Ord a) => [a] -> [[a]]
10:45:23 <Tac-Tics> @let mono = groupBy (<) :: [Int] -> [[Int]]
10:45:24 <lambdabot> Defined.
10:45:25 <LoganCapaldo> @let mono xs = groupBy (<) xs
10:45:25 <lambdabot> <local>:11:0:     Multiple declarations of `L.mono'     Declared at: <local>:...
10:45:29 <LoganCapaldo> doh
10:45:31 <Tac-Tics> oops
10:45:46 <gigamonkey> [1,2,3] is a list, right?
10:45:52 <LoganCapaldo> yes
10:45:57 <idnar> @type mono
10:45:58 <lambdabot> Not in scope: `mono'
10:46:07 <Saizan> :t [1,2,3]
10:46:07 <lambdabot> forall t. (Num t) => [t]
10:46:10 <LoganCapaldo> > mono :: Int
10:46:10 <lambdabot>  Couldn't match expected type `Int'
10:46:10 <Tac-Tics> > 1 : 2 : 3 : []
10:46:11 <lambdabot>  [1,2,3]
10:46:15 <LoganCapaldo> arg
10:46:24 <idnar> @let mono = groupBy (<) :: [Int] -> [[Int]]
10:46:24 <lambdabot> <local>:11:0:     Multiple declarations of `L.mono'     Declared at: <local>:...
10:46:27 <idnar> heh
10:46:32 <gigamonkey> Right, and what's (1,2,3)
10:46:35 <Tac-Tics> a tuple
10:46:36 <LoganCapaldo> tuple
10:46:38 <idnar> @undefine
10:46:38 <Tac-Tics> :t (1,2,3
10:46:39 <lambdabot> Undefined.
10:46:39 <lambdabot> parse error (possibly incorrect indentation)
10:46:42 <Tac-Tics> :t (1,2,3)
10:46:43 <idnar> @let mono = groupBy (<) :: [Int] -> [[Int]]
10:46:43 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1, t2)
10:46:43 <lambdabot> Defined.
10:46:45 <idnar> @type mono
10:46:46 <lambdabot> Not in scope: `mono'
10:46:57 <LoganCapaldo> @ype doesn't know about @let
10:46:58 <desegnis> ghci-6.8.1 shows strange defaulting behaviour on groupBy (<)
10:46:58 <lambdabot> parse error on input `let'
10:47:00 <Tac-Tics> Tuples can be heterogeneous but have a fixed size
10:47:02 <idnar> LoganCapaldo: oh, duh
10:47:12 <Tac-Tics> Rather, you can't cons onto tuples
10:47:15 <gigamonkey> Right.
10:47:20 <Saizan> desegnis: ghci has extended defaulting
10:47:23 <Tac-Tics> :t ('a', "b", (1, 2, ()))
10:47:23 <LoganCapaldo> hence my attempt to use the type error to get the type
10:47:24 <lambdabot> forall t t1. (Num t, Num t1) => (Char, [Char], (t, t1, ()))
10:47:33 <gigamonkey> Got to rewire my brain so ()'s don't mean list.
10:47:38 <Tac-Tics> heh
10:47:42 <gigamonkey> And CAR is spelled head.
10:47:51 <desegnis> Saizan: However, 6.6 and 6.8.1 tend to differ on this case
10:47:57 <Tac-Tics> usually, haskell doesn't need to use car/head ever
10:48:02 <desegnis> Saizan: namely, Integer vs. ()
10:48:08 <Tac-Tics> you use pattern matching for most everything
10:48:37 <LoganCapaldo> or folds and such
10:48:51 <gbacon> oh, duh, it's a fold*R*
10:49:05 <gigamonkey> Sure.
10:49:21 <gbacon> gigamonkey: or maybe fst :-)
10:49:32 <Tac-Tics> @src fst
10:49:32 <lambdabot> fst (x,_) =  x
10:49:37 <Tac-Tics> > fst (1, "a")
10:49:38 <lambdabot>  1
10:49:42 <gigamonkey> gbacon: that was my problem. I was trying to fst a [t]
10:49:42 <Tac-Tics> > snd (1, "a")
10:49:43 <lambdabot>  "a"
10:50:05 <oerjan> > [(),mono]
10:50:05 <lambdabot>  Couldn't match expected type `()'
10:50:11 <oerjan> > [mono,()]
10:50:11 <lambdabot>  Couldn't match expected type `[Int] -> [[Int]]'
10:50:24 <Tac-Tics> > [mono, undefined]
10:50:25 <lambdabot>  [<[Int] -> [[Int]]>,<[Int] -> [[Int]]>]
10:50:45 <oerjan> LoganCapaldo: ^^
10:50:48 <Tac-Tics> undefined is like an evil master of disguise
10:51:12 <oerjan> the idea was _not_ to match
10:51:20 <oerjan> > [map,()]
10:51:20 <lambdabot>  Couldn't match expected type `(a -> b) -> [a] -> [b]'
10:51:24 <oerjan> > [map]
10:51:24 <lambdabot>  Add a type signature
10:51:25 <LoganCapaldo> oerjan: that's using Dynamic right though? It won't work for polymorphic functions?
10:51:35 <LoganCapaldo> ahh
10:51:39 <LoganCapaldo> nvm
10:51:47 <oerjan> LoganCapaldo: it's a type error message
10:51:47 <LoganCapaldo> didn't see the map, () example
10:52:37 <LoganCapaldo> I was referring to this: <lambdabot> [<[Int] -> [[Int]]>,<[Int] -> [[Int]]>]
10:52:57 <oerjan> yep, that's what i was trying to demonstrate with the [map]
10:55:54 <opqdonut> anyone here know of a powerful factorization/primality test algorithm that's easy to grasp and implement?
10:56:25 <cjb> other than the sieve?  :)
10:56:57 <oerjan> the sieve is not very good for testing numbers...
10:57:49 <b_jonas> opqdonut: look at the top of one of the threads I've linked to...
10:57:58 <oerjan> i think randomized primality testing is reasonably simple, though i don't remember how it went
10:58:01 <b_jonas> http://www.perlmonks.com/?node_id=510901
10:58:02 <b_jonas> this one
10:58:03 <lambdabot> Title: Simple primality testing
10:58:07 <opqdonut> thanks
10:58:16 <Tac-Tics> Is there a common name in haskell for the function search p = head . (filter p) ?
10:58:20 <hpaste>  mdmkolbe|work pasted "Lazy Sets Revisited" at http://hpaste.org/4697
10:58:24 <oerjan> Tac-Tics: find
10:58:25 <mdmkolbe|work> So after a good nights rest, I'm revisiting my Lazy Set question.  I've got something that works (yea!), but the computational complexity is a bit high.  Does anyone know of a more efficient way to implement lazy sets? http://hpaste.org/4697
10:58:26 <b_jonas> but it's easier to implement if you read the algorithm from the Cormen book or the Knuth book, not from that code
10:58:27 <oerjan> @src find
10:58:28 <lambdabot> find p          = listToMaybe . filter p
10:58:29 <Tac-Tics> ah thanks
10:58:43 <b_jonas> provided you want to write it yourself, not just reuse code
10:58:49 <oerjan> except it uses a Maybe just in case it finds nothing...
10:59:04 <Tac-Tics> ok, thanks
10:59:29 <Tac-Tics> @hoogle Maybe a -> a
10:59:30 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
10:59:30 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
10:59:30 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
10:59:48 <Tac-Tics> so it would be fromJust . find... cool
11:00:23 <Tac-Tics> bah. I don't see why :m + isn't the default for importing modules in ghci
11:00:31 <Tac-Tics> :m replacing the current module gets annoying
11:00:37 <oerjan> although that's fairly equivalent to head . filter...
11:00:58 <gigamonkey> What's the naming convention for manifest constants?
11:01:12 <Tac-Tics> manifest constants?
11:01:21 <gigamonkey> e.g. #defines in C
11:01:26 <gigamonkey> final static variables in Java
11:01:32 <gigamonkey> defconstants in Common Lisp
11:01:37 <oerjan> gigamonkey: well they have to start with lower-case at least
11:01:39 <Tac-Tics> heh, everything in Haskell is that way
11:01:45 <Tac-Tics> every expression is a constant
11:01:46 <gigamonkey> Tac-Tics: good point.
11:01:48 <gigamonkey> duh.
11:01:54 <opqdonut> yes, i think i'll go with miller-rabin
11:02:06 <Tac-Tics> the standard haskell naming convention applies. camelCase just like Java does
11:02:48 <Tac-Tics> And modules, types and classes have to begin with upper case letters, of course
11:04:23 <oerjan> > maxBound :: Int
11:04:24 <lambdabot>  2147483647
11:04:28 <oerjan> > pi :: Double
11:04:29 <lambdabot>  3.141592653589793
11:04:56 <oerjan> for some manifest builtin examples :)
11:05:23 <Tac-Tics> :t maxBound
11:05:24 <lambdabot> forall a. (Bounded a) => a
11:05:39 <Tac-Tics> :info Bounded
11:05:48 <oerjan> no info in lambdabot
11:05:48 <Tac-Tics> Curse you lambdabot!
11:05:56 <Saizan> ?src Bounded
11:05:56 <lambdabot> class  Bounded a  where
11:05:56 <lambdabot>     minBound, maxBound :: a
11:05:56 <oerjan> @src Bounded
11:05:57 <lambdabot> class  Bounded a  where
11:05:57 <lambdabot>     minBound, maxBound :: a
11:06:22 <omnId> @instances Bounded
11:06:23 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
11:06:48 <oerjan> :t All
11:06:48 <lambdabot> Bool -> All
11:07:01 <omnId> > minBound :: All
11:07:02 <lambdabot>  All {getAll = False}
11:07:25 <oerjan> one of the Monoid constructors
11:09:36 <omnId> @brain Are you pondering what I'm pondering?
11:09:36 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
11:18:58 <mdmkolbe|work> So after a good nights rest, I'm revisiting my Lazy Set question.  I've got something that works (yea!), but the computational complexity is a bit high.  Does anyone know of a more efficient way to implement lazy sets? http://hpaste.org/4697
11:19:57 * oerjan actually pondered it earlier today but couldn't see a good solution
11:20:23 <Tac-Tics> mdmkolbe: how is a lazy set different from a lazy list besides how it prints out?
11:20:38 <Tac-Tics> or is it hash-based or something for faster searching?
11:21:57 <oerjan> i understand mdmkolbe|work's question as asking whether there _is_ a lazy set implementation that is more efficient than a lazy list
11:22:34 <mdmkolbe|work> oerjan: actually it's using the (X -> Bool) monoid.  lazy lists end up not working when you have both member and delete
11:23:15 <oerjan> it's still essentially the same asymptotically, i think
11:23:37 <oerjan> (as the previous [(X, Bool)]
11:25:11 <mdmkolbe|work> Tac-Tics: the problem with lazy lists (i.e. [X]) is that an "elem 2" after a "delete 2" will end up scanning and thus forcing the entire list, even though it is "obviously" impossible to find that element.  (This should be fixed a bit by [(X, Bool)] (but you can't use the list monoid to implement it and I haven't tested [(X, Bool)].  I've only tested (X -> Bool))
11:25:53 <Tac-Tics> mdmkolbe: ah neat
11:27:04 <mdmkolbe|work> Tac-Tics: yeah, it took me a while to realize (elem . delete) was the main problem instead of (elem . insert)
11:27:58 <Tac-Tics> but how can you test for equality at all without first normalizing your elements?
11:28:32 <mdmkolbe|work> Tac-Tics: normalizing elements = forcing the thunks?
11:29:02 <Tac-Tics> yes
11:29:38 <oerjan> equality of two sets would probably force everything if they are actually equal
11:29:39 <Sizur> is anybody writing I18N lib?
11:29:59 <mdmkolbe|work> well, you can't.  But what this does is make the elem not depend on anything that happened "before" the delete
11:30:01 <Sizur> just asking not to reinvent the weel
11:30:23 <Tac-Tics> I18N isn't a very haskellish thing to do =-P
11:30:47 <mdmkolbe|work> Since IntSet uses some form of ballanced tree, the shape of the tree after delete depends on the shape of the tree before delete, thus making the elem depend on the stuff before the delete
11:31:02 <oerjan> what i pondered earlier today:  ideally you would want an implementation that collected items in a trie or something
11:31:13 <Sizur> Tac-Tics: why so? you can wrap around IO
11:31:34 <Sizur> I see no reason why it's not haskellish
11:31:41 <Saizan> IntSet is a trie, iirc
11:31:54 <oerjan> not a finite trie
11:32:04 <abz> If you had to give an informal talk on any Haskell, which one would it be?
11:32:11 <abz> haskell paper
11:32:12 <abz> sorry
11:32:13 <oerjan> a trie with a fixed structure, so you never have to force anything other than what you look at
11:32:53 <oerjan> "The implementation is based on big-endian patricia trees."
11:33:06 <nolrai> what would items of type "StateT s IO r" be again?
11:33:13 <nolrai> what would items of type "StateT s IO r" be again?
11:33:39 <omnId> @unmtl StateT s IO r
11:33:39 <lambdabot> s -> IO (r, s)
11:33:40 <Tac-Tics> So a Lazy set would really be useful for elements which you can order by evaluating only part of the expression?
11:33:53 <Tac-Tics> > [1,2,3] < [2,3]
11:33:54 <lambdabot>  True
11:33:56 <mdmkolbe|work> oerjan: but it attempts to use old tree fragments doesn't it?  If the constructors aren't created fresh for each insert/delete operation, there is a "structure" dependancy on the memory addresses instead of the shape
11:34:16 <idnar> > [1,2,3] < [1,2]
11:34:17 <lambdabot>  False
11:34:19 <idnar> > [1,2,3] < [1,2,4]
11:34:19 <lambdabot>  True
11:34:21 <mdmkolbe|work> abz: composable interpreters
11:34:23 <Tac-Tics> > [1,2,3] < [2, undefined]
11:34:23 <lambdabot>  True
11:34:32 <Alleria_> does GoA compile cleanly under 6.8.1/2 on OS X 10.5?
11:34:35 <Tac-Tics> > [undefined, 1] < [2,3]
11:34:35 <lambdabot>  Undefined
11:34:50 <Sizur> generic alphanumeric ordering
11:35:17 <abz> mdmkolbe|work: got a link?
11:35:26 <Sizur> > "abc" > "acb"
11:35:27 <lambdabot>  False
11:35:50 <mdmkolbe|work> Tac-Tics: in my case, it's this complex self-dependant transformation (i.e. some parts of the transformation depends on whether other parts happen which in turn depend on whether this part happens, etc.)
11:36:15 <oerjan> mdmkolbe|work: hm right, using old tree fragments cannot be allowed
11:36:56 <oerjan> (in the final tree. they can of course be passed as intermediate structures if done lazily)
11:37:50 <mdmkolbe|work> abz: anything on http://www.ittc.ku.edu/Projects/SLDG/filing-cabinet.htm is good, the paper I mentioned is http://haskell.org/papers/modular-interpreters.ps
11:37:50 <lambdabot> Title: SLDG Filing Cabinet
11:38:12 <abz> mdmkolbe|work: Thanks.
11:38:42 <oerjan> (although i think the space leaks for this might be horrendous)
11:39:08 <mdmkolbe|work> oerjan: yep, which means a naive lazy trie would cost O(u*e) where u is the number modifying of operations (e.g. union) and e is the number of elements ever read or member'ed
11:39:22 <FunctorSalad> where can I find a list of haskell projects seeking developers? (not saying that I could probably help)
11:40:09 <FunctorSalad> (I mean free software projects)
11:41:10 <oerjan> hm, IntSet is in fact completely strict, ! on all fields
11:41:14 <Korollary> @where hackage
11:41:14 <lambdabot> http://hackage.haskell.org/
11:42:36 <Sizur> :t (>>)
11:42:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:42:58 <Sizur> > "abc" >> "def"
11:42:58 <lambdabot>  "defdefdef"
11:44:35 <mdmkolbe|work> > "a" >> "def"
11:44:35 <lambdabot>  "def"
11:44:41 <mdmkolbe|work> > "ab" >> "def"
11:44:42 <lambdabot>  "defdef"
11:44:48 <mdmkolbe|work> > "abc" >> "def"
11:44:48 <lambdabot>  "defdefdef"
11:45:07 <Tac-Tics> > [0..] >> "def"
11:45:08 <lambdabot>  "defdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdefdef...
11:45:20 <FunctorSalad> Korollary: was that in reply to me?
11:45:33 <yav> hi, do we have any cabal experts here?
11:45:35 <Korollary> FunctorSalad: Yes
11:45:44 <lakupuu> > [0..] >> "desu"
11:45:44 <lambdabot>  "desudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudes...
11:45:54 <Tac-Tics> lakupuu: hah
11:46:00 <FunctorSalad> Korollary: I can't seem to find the search tag for "developers wanted"?
11:46:28 <Tac-Tics> > cycle "desu"
11:46:28 <lambdabot>  "desudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudes...
11:46:46 <Cin> heh
11:47:22 <Korollary> FunctorSalad: Right. hackage is the closest there is to what you asked.
11:47:53 <Korollary> I think some projects are on sf.net as well
11:48:38 <yav> dons?
11:51:50 <Sizur> FunctorSalad: maybe this one?: http://haskell.org/haskellwiki/Applications_and_libraries#Guidelines_for_developers
11:51:51 <lambdabot> http://tinyurl.com/2rnhtk
11:54:47 <FunctorSalad> Sizur: thanks
11:59:02 <Sizur> > Nothing >> Just 'a'
11:59:03 <lambdabot>  Nothing
11:59:50 <Sizur> :t (<$>)
11:59:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:00:06 <oerjan> @src <$>
12:00:06 <FunctorSalad> this >> thingy is the analogue to an unused value in the do notation, isn't it?
12:00:06 <lambdabot> f <$> a = fmap f a
12:00:15 <oerjan> yes
12:00:31 <oerjan> @undo do {a ; b}
12:00:31 <lambdabot> a >> b
12:00:35 <FunctorSalad> :)
12:00:56 <FunctorSalad> cool, have to remember that command (undo)
12:01:07 <FunctorSalad> ghci should have these things
12:01:16 <oerjan> @where goa
12:01:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
12:01:31 <Sizur> @src <+>
12:01:31 <lambdabot> Source not found. I am sorry.
12:01:33 <oerjan> although it is probably not updated for 6.8 yet
12:01:40 <oerjan> :t (<+>)
12:01:41 <lambdabot>     Ambiguous occurrence `<+>'
12:01:41 <lambdabot>     It could refer to either `<+>', imported from Control.Arrow
12:01:41 <lambdabot>                           or `<+>', imported from Text.PrettyPrint.HughesPJ
12:01:44 <FunctorSalad> ah, nice
12:02:08 <oerjan> and has a reputation of being a pain to install, i think
12:02:21 <oerjan> :t (Control.Arrow.<+>)
12:02:22 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
12:02:34 <oerjan> @src ArrowPlus
12:02:34 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:02:54 <gigamonkey> Give this: data Point = Point Int Int deriving (Eq, Ord, Read, Show)
12:03:01 <Sizur> what's the analog for mappend?
12:03:06 <FunctorSalad> ok will just use lambdabot then
12:03:11 <oerjan> it's the one method of ArrowPlus
12:03:15 <gigamonkey> shouldn't this work: (read . show) (Point 0 0)
12:03:16 <gigamonkey> ?
12:03:22 <oerjan> Sizur: analog in what?
12:03:35 <Tac-Tics> :t read
12:03:36 <lambdabot> forall a. (Read a) => String -> a
12:03:44 <FunctorSalad> oerjan: one could just write a function to msg lambdabot from ghci ;)
12:03:50 <Sizur> oerjan: the second function in conjunction with <$>
12:03:52 <oerjan> gigamonkey: yes, provided the result type is determined
12:04:03 <gigamonkey> ah.
12:04:15 <omnId> (read . show) (Point 0 0) :: Point
12:04:17 <Tac-Tics> Functions with a type variable as the result are weird like that
12:04:35 <gigamonkey> Thanks.
12:04:44 <Sizur> :t (<->)
12:04:44 <lambdabot> Not in scope: `<->'
12:04:59 <Saizan> using it in some Point specific way will suffice
12:05:01 <oerjan> Sizur: thinking of <*> =
12:05:03 <oerjan> ?
12:05:19 <Sizur> :t (<*>) -- ah, yeah
12:05:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:05:24 <Sizur> applicative
12:05:44 <FunctorSalad> maybe it would be more newbie-friendly if it said "forall a. (a implements Read) => String -> a" - to distinguish class implementation from type construction
12:05:52 <FunctorSalad> quite confusing in the beginning.
12:06:18 <Sizur> FunctorSalad: but later it'll get very irritating to write/read that
12:06:30 <Tac-Tics> Haskell really favors the brevity of its syntax
12:06:49 <FunctorSalad> hmm ok
12:06:59 <Tac-Tics> it is confusing, I agree though
12:07:05 <FunctorSalad> how about (a is-a Read)? ;)
12:07:12 <Tac-Tics> heh
12:07:22 <ricky_clarkson> "implements" is only better once, when you learn it for the first time.
12:07:51 <ricky_clarkson> Assuming you use Haskell after learning the syntax, use is more important than initial learning.
12:08:32 <Tac-Tics> It is confusing too, because A x means "any type x which implements class A" but "b x" means a "b of type x"
12:08:35 <oerjan> @version
12:08:36 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
12:08:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:08:45 <FunctorSalad> Tac-Tics: yeah, that's what I meant
12:08:49 <Sizur> FunctorSalad: well, the syntax is a parallel to quantifications from logic notation
12:09:15 <FunctorSalad> Sizur: you mean as in (a \in Read)?
12:09:38 <FunctorSalad> or I think you consider Read a predicate
12:09:48 <Sizur> yeah, A from a set of Read
12:09:50 <Tac-Tics> stupid pidgin
12:12:02 <Sizur> class is basically a set of types
12:12:12 <Sizur> and kind is a set of classes, and it goes on and on
12:12:42 <Sizur> seems to be simply a hack. if you ask me, we still don't have a good set theory
12:12:44 <gigamonkey> Okay how do I use read to read "1" as 1? I tried read "1" :: (Num t) => t
12:12:50 <FunctorSalad> hmm isn't a kind a type of types, rather?
12:12:52 <Tac-Tics> What is a set of kinds called?
12:12:59 <Tac-Tics> =-)
12:13:03 <FunctorSalad> I don't see the relation from kinds to classes
12:13:05 <Sizur> superkind set :P
12:13:21 <Tac-Tics> > read "1" :: Integer
12:13:22 <lambdabot>  1
12:13:33 <Tac-Tics> > read "1" :: Int
12:13:33 <lambdabot>  1
12:13:42 <Sizur> FunctorSalad: you can think of a type as a set
12:13:47 <Sizur> a set of values
12:13:54 <FunctorSalad> yeah
12:14:03 <Tac-Tics> really, just about everything can be thought of as a set, and that's why we love them so very dearly
12:14:05 <omnId> gigamonkey: it needs to be just one type in order to actually choose an implementation for read.  (Num t) => t could be any type in Num.
12:14:07 <glguy> ?users
12:14:07 <lambdabot> Maximum users seen in #haskell: 434, currently: 371 (85.5%), active: 17 (4.6%)
12:14:16 <FunctorSalad> and Int and String are of kind *, Monad is of kind * -> * and so on, no?
12:14:21 <FunctorSalad> so kinds would be sets of types?
12:14:25 <Tac-Tics> Or, as in CS, everything's just a list
12:14:28 <glguy> hpaste, url
12:14:29 <hpaste> Haskell paste bin: http://hpaste.org/
12:14:30 <gigamonkey> So how do I know the right type to use when :type 1 returns (Num t) => t
12:14:36 <oerjan> gigamonkey: and that doesn't work since Num doesn't necessarily implement Read
12:14:37 <Tac-Tics> functorSalad: yeah
12:14:38 <omnId> @instances Num
12:14:39 <lambdabot> Double, Float, Int, Integer
12:14:41 <omnId> any of those
12:15:05 <Tac-Tics> gigamonkey: it depends what you want to use. Int is a word-sized integer, Integer is a bignum
12:15:05 <FunctorSalad> Tac-Tics: actually one of the major nice things about category theory is to avoid encoding everything as a set. just because you can do it doesn't mean it's a good idea
12:15:14 <Sizur> FunctorSalad: well, there are many classes of one kind, so kind is a superset of classes
12:15:49 <FunctorSalad> Sizur: seems to me that every kind is a class
12:15:50 <gigamonkey> So what's the nomenclature for what Int and Integer are vs what Num is?
12:16:03 <Tac-Tics> gigamonkey: Many kinds of number objects in Haskell implement the Num type class. A typeclass is essentially an interface or an abstract superclass
12:16:04 <omnId> Int and Integer are types, Num is a class.
12:16:11 <gigamonkey> omnId: thanks.
12:16:21 <Tac-Tics> @src Num
12:16:21 <lambdabot> class  (Eq a, Show a) => Num a  where
12:16:21 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:16:21 <lambdabot>     negate, abs, signum     :: a -> a
12:16:21 <lambdabot>     fromInteger             :: Integer -> a
12:16:33 <Tac-Tics> A type can be a Num if it provides these 5 functions
12:16:37 <Tac-Tics> err
12:16:39 <Tac-Tics> 7*
12:16:43 <Sizur> FunctorSalad: you can write your own class that has the same kind as another class
12:16:51 <gbacon> @hoogle Data.Map -> [a] -> [a]
12:16:51 <lambdabot> No matches, try a more general search
12:17:01 <Sizur> FunctorSalad: the classes are still different
12:17:11 <ricky_clarkson> gigamonkey: In CL terms, a typeclass would be a guarantee that a set of generic methods are implemented, and can provide default implementations of them.
12:17:27 <FunctorSalad> Sizur: classes don't "have" kinds though, have they? a class can be thought of as a set of types, and a kind can be thought of as a set of types. in that view, Num is a subset of *
12:17:29 <ricky_clarkson> s/methods/functions/
12:17:32 <FunctorSalad> (not an element)
12:17:48 <gigamonkey> ricky_clarkson: right. I actually new that once but it was a while ago that I read YAHT and now I'm at my folks place with none of my books.
12:17:48 <oerjan> gbacon: what do you want that function to do?
12:18:05 <Sizur> FunctorSalad: I see kind as a set of classes, and as such it is a set of types as well (on a second level)
12:18:35 <gbacon> oerjan: I have a list of desired keys that I want from a map.. really I want Data.Map -> [String] -> Either String [String]
12:18:39 <ricky_clarkson> gigamonkey: Which type is actually used in each case is decided at compile time, so there is no lookup at runtime (well, the implementation uses dictionary-passing, but that's a detail).
12:18:40 <Sizur> personally I don't like this particular set theory
12:18:48 <gbacon> where the Left-tagged value would be the missing keys
12:19:00 <oerjan> note that the type is actually Data.Map.Map t
12:19:08 <gbacon> oops, thanks
12:19:10 <oerjan> er, Data.Map.Map a b
12:19:20 <FunctorSalad> Sizur: I guess they had some good reason for using these layers rather than just making the whole thing self-referential?
12:19:24 <Sizur> but it's very practical and the most solid so far. and most of all, it gave us haskell :D
12:19:33 <gbacon> @hoogle Data.Map.Map a b -> [a] -> [b]
12:19:33 <lambdabot> No matches, try a more general search
12:19:46 <gbacon> @hoogle Data.Map.Map a b -> [a] -> Either c [b]
12:19:46 <lambdabot> No matches, try a more general search
12:20:27 <gigamonkey> :t reads
12:20:28 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:20:29 * Cin throws a pie at ricky_clarkson
12:20:45 <gbacon> oerjan: to be concrete, I need the values of several environment variables (some of which are required)
12:20:46 <gigamonkey> I'm missing why that returns a list containing a tuple rather than just a tuple
12:20:48 * ricky_clarkson converts it to a pastie and eats it.
12:21:02 <gbacon> @ty read
12:21:03 <lambdabot> forall a. (Read a) => String -> a
12:21:05 <Tac-Tics> gigamonkey: the reads family of functions is kinda dumb (imo at least)
12:21:15 <omnId> gigamonkey: I think if there are multiple valid parses, or no valid parses.
12:21:20 <Tac-Tics> from what I can tell, they are carryovers from very early versions of haskell
12:21:34 <gigamonkey> Tac-Tics: so is there a better alternative?
12:21:37 <Tac-Tics> really, what they *should* return is Maybe x
12:21:45 <omnId> > (reads::ReadS Int) "burble" -- for no valid ones.
12:21:46 <lambdabot>  []
12:22:04 <Tac-Tics> gigamonkey: you can roll your own with Parsec, which is perhaps the world's most lovely parser generator
12:22:22 <ricky_clarkson> > (reads::ReadS Int) "3 4 5"
12:22:23 <lambdabot>  [(3," 4 5")]
12:22:29 <gbacon> oerjan: but I don't want to bail immediately on the first undefined but required variable; I'd like to say "required envariables a, b, and c are undefined"
12:22:34 <Tac-Tics> but Haskell isn't so great with builtin support for strings
12:22:54 <Tac-Tics> (although writing your own functions for the usual string operations is ridiculously easy in most cases)
12:23:15 <FunctorSalad> gbacon: couldn't you accumulate these errors through a monad?
12:23:24 <ricky_clarkson> > read "3"
12:23:26 <lambdabot>  3
12:23:29 <gbacon> FunctorSalad: Writer?
12:23:40 <gbacon> FunctorSalad: or State?
12:23:47 <ricky_clarkson> > (words >>> read) "3 4 5"
12:23:47 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
12:24:08 <ricky_clarkson> > (words >>> (map read)) "3 4 5"
12:24:08 <lambdabot>  [3,4,5]
12:24:16 <FunctorSalad> gbacon: sorry, not familiar with the library yet :) just thought about writing a monad that keeps track of a list of variables that failed so far
12:24:41 <Sizur> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
12:24:58 <FunctorSalad> gbacon: I don't know the context of the question so maybe that's nonsense
12:25:17 <Sizur> FunctorSalad: that link was for ya
12:25:25 <FunctorSalad> ok
12:25:28 <gbacon> FunctorSalad: well, I'm trying to rewire my brain :-)
12:25:58 <Sizur> WriterT is perfect for accumulation
12:26:00 <FunctorSalad> and your brain probe runs Haskell? ;)
12:26:04 <ricky_clarkson> gigamonkey: Btw, I probably still don't understand typeclasses properly, but a bunch of stuff clicked when I used Scala's implicits and someone told me they were equivalent to typeclasses.  C++ templates are comparable too (but Haskell's generates dictionaries, not code).
12:26:56 <oerjan> gbacon: Data.Map.lookup is nicely monadic
12:27:16 <gbacon> oerjan: but I don't want to bail on the first error
12:27:48 <oerjan> use a monad which can catch errors
12:27:59 <oerjan> alternatively, findWithDefault could be used
12:28:20 <gbacon> something like WriterT ( ErrorT (IO) )?
12:28:52 <mux> > maybe "not found" (const "found) (Data.Map.lookup (singleton 1) 2)
12:28:54 <lambdabot> Unbalanced parentheses
12:29:03 <mux> > maybe "not found" (const "found") (Data.Map.lookup (singleton 1) 2)
12:29:03 <lambdabot>   Not in scope: `singleton'
12:29:05 <oerjan> why IO? i thought you were looking in a pure Map
12:29:16 <mux> :t Data.Map.singleton
12:29:16 <lambdabot> forall k a. k -> a -> Data.Map.Map k a
12:29:26 <gigamonkey> Is it common to write one's own Monads?
12:29:28 <mux> > maybe "not found" (const "found") (Data.Map.lookup (Data.Map.singleton 1) 2)
12:29:28 <lambdabot>   Not in scope: `Data.Map.singleton'
12:29:32 <mux> blah
12:29:35 <oerjan> but in fact Maybe should be enough
12:29:44 <Sizur> WriterT [String] (ErrorT String Identity)?
12:29:46 <gbacon> oerjan: yes.. either the output of getEnvironment or piecemeal with getEnv
12:30:26 <gbacon> gigamonkey: see http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
12:30:27 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
12:30:49 <oerjan> note that this thing for lookup is just a helper monad - nothing to do with the monads used in the larger program
12:30:50 <earthy> damn how do I hate shell quoting issues
12:31:01 <oerjan> unless you want it to be
12:31:13 <oerjan> :t maybe
12:31:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:32:39 <Sizur> :t lookup 1 $ lookup 1 (undefined :: Map Int Int)
12:32:39 <lambdabot> Not in scope: type constructor or class `Map'
12:32:50 <oerjan> :t \m -> map $ \key -> maybe (Left key) Right $ Data.Map.lookup key m
12:32:51 <lambdabot> forall a a1. (Ord a) => Data.Map.Map a a1 -> [a] -> [Either a a1]
12:33:32 <oerjan> gbacon: this gives you everything matched in Right, every key not matched in Left
12:33:42 <oerjan> hm wait you probably want the key too
12:34:19 <oerjan> :t \m -> map $ \key -> maybe (Left key) (Right . (,) key) $ Data.Map.lookup key m
12:34:20 <lambdabot> forall a a1. (Ord a) => Data.Map.Map a a1 -> [a] -> [Either a (a, a1)]
12:39:17 <Sizur> @instances Data.Map
12:39:17 <lambdabot> Couldn't find class `Data.Map'. Try @instances-importing
12:39:40 <Sizur> @instances Data.Map.Map
12:39:41 <lambdabot> Couldn't find class `Data.Map.Map'. Try @instances-importing
12:39:50 <omnId> it's a datatype
12:40:01 <Sizur> is Map a monoid?
12:40:17 <omnId> @instances Monoid
12:40:18 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
12:40:24 <omnId> @instances-importing Data.Map Monoid
12:40:25 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Map k v, Ordering, Product a, Sum a, [a]
12:41:10 <QuietPurple> evil terran?
12:41:22 <Sizur> I think it should be a monoid with mappend merging maps
12:41:28 <QuietPurple> EvilTerran?
12:41:56 <oerjan> instance (Ord k) => Monoid (Map k v) where mempty  = empty mappend = union mconcat = unions
12:42:05 <oerjan> (lines joined again)
12:42:21 <Sizur> yeah
12:43:37 <sutats> Say I have an integer 123456, but I wanted to add each digit of it (ie. 1 + 2 + ... + 6). What function do I want to use (I'm assuming something to do with mapping)?
12:44:05 <olsner> I think my linker is ready to have relocations implemented! now, I just need stuff to link with it
12:44:29 <oerjan> > sum . map digitToInt . read $ "123456"
12:44:30 <lambdabot>  Exception: Prelude.read: no parse
12:44:40 <oerjan> oops
12:45:03 <oerjan> > sum . map digitToInt . show $ "123456"
12:45:03 <lambdabot>  Exception: Char.digitToInt: not a digit '"'
12:45:11 <omnId> s/"//g
12:45:13 <oerjan> > sum . map digitToInt . show $ 123456
12:45:13 <lambdabot>  21
12:45:20 <oerjan> finally
12:45:43 <Sizur> > let f = sum . map (\x->read [x]::Int) in f "12345"
12:45:44 <lambdabot>  15
12:46:39 <sutats> Ah, thanks.
12:47:45 <oerjan> gbacon: did you see my suggestions?
12:48:14 <gbacon> oerjan: I did, thanks! (sorry, client trouble)
12:53:08 <gbacon> :t \m -> map $ \key -> maybe (Left key) (Right . (,) key) $ Data.Map.lookup key m
12:53:09 <lambdabot> forall a a1. (Ord a) => Data.Map.Map a a1 -> [a] -> [Either a (a, a1)]
12:53:29 <gbacon> @unpl \m -> map $ \key -> maybe (Left key) (Right . (,) key) $ Data.Map.lookup key m
12:53:29 <lambdabot> \ m -> map (\ key -> maybe (Left key) (\ g -> (Right) ((,) key g)) (Data.Map.lookup key m))
12:55:14 <FunctorSalad> http://www.cs.washington.edu/orgs/student-affairs/cseband/studio/Theory%20Girl.mp3
12:55:15 <lambdabot> http://tinyurl.com/3j4cj
12:55:16 <oerjan> :t Either a b -> Bool
12:55:16 <lambdabot> <command line>:
12:55:17 <lambdabot>     Could not find module `L':
12:55:17 <lambdabot>       Use -v to see a list of the files searched for.
12:55:22 <oerjan> @hoogle Either a b -> Bool
12:55:23 <lambdabot> No matches, try a more general search
12:57:23 <oerjan> could use a Writer to split the lists directly...
12:57:36 <gbacon> oerjan: so do you tend to write code inside, say, ErrorT directly or get all your thoughts down and then make the code more elegant?
12:58:26 <praetorian42> i'm trying to install some dependencies, and every module's install function fails with something like: "setup: Error: Could not find module: Text.ParserCombinators.Parsec.Error with any suffix: ["hi"]"
12:58:54 <oerjan> :t \m -> runWriter . sequence . map $ \key -> maybe (tell [key]) (\v -> return (key,val)) $ Data.Map.lookup key m
12:58:56 <lambdabot> Not in scope: `val'
12:59:05 <oerjan> :t \m -> runWriter . sequence . map $ \key -> maybe (tell [key]) (\val -> return (key,val)) $ Data.Map.lookup key m
12:59:05 <lambdabot>     Couldn't match expected type `[m a]'
12:59:05 <lambdabot>            against inferred type `[a1] -> [b]'
12:59:05 <lambdabot>     In the second argument of `(.)', namely `map'
12:59:56 <praetorian42> man, haskell might be a great language, but the community sure fucking sucks
13:00:00 <oerjan> :t \m keys -> runWriter . sequence $ map (\key -> maybe (tell [key]) (\val -> return (key,val)) $ Data.Map.lookup key m) keys
13:00:01 <lambdabot>     Couldn't match expected type `()' against inferred type `(a, a1)'
13:00:01 <lambdabot>       Expected type: m ()
13:00:01 <lambdabot>       Inferred type: m (a, a1)
13:00:02 <praetorian42> i've been trying all day to get this shit working
13:00:05 <praetorian42> fuck this
13:00:42 <Tac-Tics> =-/
13:00:44 <EvilTerran> charmed, i'm sure
13:00:54 <Tac-Tics> We're not as bad as #lisp and that's all that counts
13:01:08 <EvilTerran> "the community sucks"? i take it he's never had to deal with the community for any other language, then
13:01:56 <stevan>  och ngra kanske ska ut ikvll
13:01:56 <stevan> 21:12 <bullen> jag jjobbar
13:02:05 <Syzygy-> stevan: Wrong channel.
13:02:15 <gbacon> @hoogle [Either a b] -> [a]
13:02:15 <lambdabot> No matches, try a more general search
13:02:17 <Syzygy-> EvilTerran: And he based this on not getting help within 1 minute.
13:02:25 <gbacon> @hoogle [Either a b] -> [b]
13:02:26 <lambdabot> No matches, try a more general search
13:02:31 <oerjan> gbacon: list comprehension
13:02:41 <gbacon> oerjan: word
13:02:51 <oerjan> [x | Left x <- l] etc.
13:03:21 <oerjan> although i am still trying to use Writer to split directly :(
13:03:29 <gbacon> @karma+ oerjan
13:03:30 <lambdabot> oerjan's karma raised to 15.
13:04:34 <omnId> I think there's a [Either a b] -> ([a], [b]) somewheres
13:04:34 <oerjan> oh wait it's the tell that forces ()
13:04:36 <gbacon> Map isn't strictly necessary.. getEnvironment yields a plist
13:04:47 <oerjan> @hoogle [Either a b] -> ([a], [b])
13:04:48 <lambdabot> No matches, try a more general search
13:07:10 <oerjan> @instances Monoid
13:07:11 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
13:07:14 <oerjan> hm...
13:07:59 <mux> @hoogle splitEither
13:08:00 <lambdabot> No matches found
13:08:11 <mux> mm, I'm not sure, but I think this was in a recent proposal
13:08:21 <oerjan> :t \m keys -> mconcat $ map (\key -> ([key],[]) (\val -> ([],(key,val))) $ Data.Map.lookup key m) keys
13:08:22 <lambdabot>     Couldn't match expected type `t -> a -> b'
13:08:22 <lambdabot>            against inferred type `(a1, b1)'
13:08:22 <lambdabot>     In the first argument of `($)', namely
13:08:57 <oerjan> :t \m keys -> mconcat $ map (\key -> ([key],[]) (\val -> ([],[(key,val)])) $ Data.Map.lookup key m) keys
13:08:57 <lambdabot>     Couldn't match expected type `t -> a -> b'
13:08:57 <lambdabot>            against inferred type `(a1, b1)'
13:08:57 <lambdabot>     In the first argument of `($)', namely
13:09:36 <FunctorSalad> I don't understand praetorian42. so far you guys have been *very* helpful :)
13:09:56 <Tac-Tics> Haskell is the ultimate nerd-out channel
13:10:05 <oerjan> wait where did the maybe go
13:10:14 <Sizur> oerjan: Map is already an instance of Monoid
13:10:15 <EvilTerran> it's behind you ;)
13:10:31 <ricky_clarkson> EvilTerran: No, there's Nothing there.
13:10:36 <ricky_clarkson> Oh, I see.
13:10:40 <EvilTerran> ha. hahaha. ha.
13:10:40 <oerjan> Sizur: not the instance i'm looking for
13:10:44 <FunctorSalad> I'm a bit unconcentrated so I learn much quicker by discussing things here than trying to read something ;)
13:10:54 <oerjan> :t \m keys -> mconcat $ map (\key -> maybe ([key],[]) (\val -> ([],[(key,val)])) $ Data.Map.lookup key m) keys
13:10:55 <lambdabot> forall a a1. (Monoid ([a], [(a, a1)]), Ord a) => Data.Map.Map a a1 -> [a] -> ([a], [(a, a1)])
13:11:29 <Sizur> oerjan: referring to your implementation that you gave me earlier, it's defined the same in the standard lib
13:11:45 <oerjan> Sizur: er i pasted it from there
13:11:56 <oerjan> thought that was obvious :)
13:11:57 <Sizur> I see
13:12:27 <Sizur> obviously it wasn't :P
13:12:53 <oerjan> gbacon: ok i think that should work
13:13:13 <gbacon> thanks :-)
13:15:13 <hpaste>  gbacon pasted "getvars" at http://hpaste.org/4698
13:16:22 <gbacon> oops, shoulda used null
13:16:56 <oerjan> hah, just beat me to it :)
13:17:44 <hpaste>  gbacon annotated "getvars" with "getvars" at http://hpaste.org/4698#a1
13:18:21 <gbacon> oh, it looked like I was editing, not adding an annotation
13:19:10 <oerjan> no destructive editing in hpaste i think, unless you're an admin
13:19:39 <gbacon> wouldn't be very fitting for a Haskell context, now, would it? :-)
13:24:00 <gbacon> so now I should be able to wrap that in ErrorT for nice-looking code with minimal boilerplate?
13:24:24 <gbacon> but I guess I need a custom throwError
13:25:46 <oerjan> just a custom Error instance
13:25:52 <oerjan> for [String]
13:26:28 <oerjan> or whatever you want as your general error type
13:31:28 <Sizur> @hoogle liftIO
13:31:29 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
13:33:15 <Sizur> it is an inconvenience to always lift an IO computation even though IO is there
13:33:33 <Sizur> talking about transformers from IO
13:51:29 <Sizur> looks like my I18N monad is ready
13:51:41 <Sizur> now to have a PO Parser
13:55:24 <hpaste>  sizur pasted "I18N" at http://hpaste.org/4699
13:55:56 <Saizan> anyone know if john goerzen happends to frequent this channel?
13:56:08 <Korollary> yes
13:56:22 <Korollary> @seen CosmicRay
13:56:22 <lambdabot> I saw CosmicRay leaving #haskell 8d 23h 22s ago, and .
13:56:32 <gbacon> I'm shooting for main = do { env <- getEnvironment; [a,b] <- getvars ["A","B"]; generateOutput a b }
13:57:10 <Saizan> oh
13:58:36 <Saizan> is it considered bad manners to upload an fixed package on hackage for a lib that you don't maintain?
13:59:57 <Sizur> yep, I'd think so
13:59:58 <Korollary> He'd probably be back soon. It looks like he's on xmas vacation or something
14:00:18 <gbacon> I have getvars inside MonadError, but do I need ErrorT b IO a?
14:00:21 <Sizur> would anybody critique my paste?
14:01:57 <oerjan> gbacon: with your main setup i think ErrorT might be overkill
14:02:24 <oerjan> you could just have getvars return Either and use a case expression
14:02:57 <oerjan> it doesn't even need to be monadic at all
14:03:09 <gbacon> but the monadic code looks so nice
14:04:27 <gbacon> I'm okay with overkill because I'm trying to make this into a learning exercise
14:05:39 <oerjan> well monadic code can return Either if you just define the Error instance
14:06:57 <oerjan> @src ErrorT
14:06:57 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
14:07:12 <gbacon> how will that give me the programmable semicolon effect?
14:07:33 <oerjan> well it allows you to expand the monad later
14:08:18 <oerjan> anyway main needs to contain the code (runErrorT or case match) to start up the monad you use
14:08:42 <gbacon> does that leave me with calls to liftIO all over?
14:08:54 <ramza3> anyone know if there is a haskell library for communicating with rabbitmq
14:09:19 <oerjan> depends
14:09:41 <dmhouse> ?ask Cale where mbot is these days
14:09:41 <lambdabot> Consider it noted.
14:10:26 <oerjan> if the IO code ends up inside some other monad, yes
14:10:59 <oerjan> although you can liftIO large blocks of IO code
14:14:12 <Sizur> @users
14:14:12 <lambdabot> Maximum users seen in #haskell: 434, currently: 367 (84.6%), active: 12 (3.3%)
14:18:54 <gbacon> oerjan: ok, I bailed and used a case
14:19:57 <gbacon> oerjan: thanks very much for all your help and suggestions
14:20:02 <gbacon> @karma+ oerjan
14:20:02 <lambdabot> oerjan's karma raised to 16.
14:20:09 <oerjan> :)
14:22:56 <mux> sigh, bulat
14:25:10 <mdmkolbe|work> @help karma
14:25:10 <lambdabot> karma <polynick>. Return a person's karma value
14:25:19 <mdmkolbe|work> @help karma+
14:25:19 <lambdabot> karma+ <nick>. Increment someone's karma
14:25:25 <mdmkolbe|work> @help karma++
14:25:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:25:52 <FunctorSalad> hmm good idea gbacon. but I don't remember everyone who helped me today :)
14:33:00 <ballzack3> hello
14:33:34 <Korollary> > "Hello"
14:33:35 <lambdabot>  "Hello"
14:33:41 <ballzack3> I;m getting type problems i think
14:33:42 <ballzack3> http://rafb.net/p/hntK9Z26.html
14:33:43 <lambdabot> Title: Nopaste - haskell
14:34:05 <ballzack3> should i use hpaste?
14:34:20 <oerjan> we usually prefer that
14:34:25 <ballzack3> it's my first program
14:34:28 <oerjan> for one thing you need an IO type
14:34:45 <oerjan> every function that does IO must return an IO type
14:34:57 <hpaste>  ballzack3 pasted "(no title)" at http://hpaste.org/4700
14:35:04 <oerjan> so, doGuessing :: IO [Int]
14:35:08 <ballzack3> http://hpaste.org/4700
14:35:12 <glen_quagmire> ballzack3: i think doGuessing type is wrong
14:35:43 <ballzack3> so i should make a separate function to do the io, then put the results into a list in a function that calls that function?
14:35:45 <glen_quagmire> doGuessing probably have to beo IO () too because main is IO ()
14:35:55 <ballzack3> i wanted a function that returned a list
14:36:06 <ballzack3> giggety giggety!
14:36:07 <oerjan> main doesn't have to be IO (), actually
14:36:27 <glen_quagmire> oerjan: wouldn't putStrLn "blah"  make it IO () ?
14:36:28 <ballzack3> can hSetBuffering stdin LineBuffering be in the main?
14:36:30 <glen_quagmire> >t putStrLn
14:36:51 <oerjan> glen_quagmire: no, only the monad needs to be common for the lines
14:37:09 <oerjan> not the result type
14:37:17 <glen_quagmire> oh i see. So, in a do block, IO (), IO [Int] can reside
14:37:37 <oerjan> ballzack3: sure
14:39:05 <oerjan> ballzack3: but try changing the type to doGuessing :: IO [Int]
14:39:15 <oerjan> that may be the only error
14:39:21 <ballzack3> but i want to use foldr on that list, oerjab
14:39:23 <ballzack3> n
14:39:34 <ballzack3> to get the product of those nums etc
14:39:50 <oerjan> that's fine, you can extract the list later
14:40:15 <oerjan> by using l <- doGuessing or similar
14:40:54 <ballzack3> that will convert it to [Int] ?
14:41:13 <oerjan> l will be an [Int] then yes
14:41:47 <ballzack3> i thought it would need to convert each list element individually
14:42:53 <ballzack3> now it's complaining in main that l isn't IO t
14:43:32 <oerjan> well l <- doGuessing cannot be the last statement
14:43:44 <ballzack3> i put putStrLn "Done" after it
14:44:09 <oerjan> er, did you change the type declaration for doGuessing?
14:44:22 <ballzack3> it's doGuessing :: IO[Int]
14:44:42 <oerjan> can you paste what you have now?
14:44:46 <ballzack3> ok
14:44:55 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4701
14:45:01 <ballzack3> http://hpaste.org/4701
14:45:17 <ballzack3> oops, it's the same thing if you take out the last return
14:45:21 <oerjan> (btw you can annotate pastes to keep things together)
14:45:22 <ballzack3> same error
14:45:27 <ballzack3> ok
14:45:52 <oerjan> well the l by itself is not allowed
14:46:19 <oerjan> and yes the last return shouldn't be there
14:46:22 <ballzack3> thanks it's working sort of
14:47:42 <ballzack3> is there a function to print a list or tuple?
14:47:56 <oerjan> print can print nearly anything
14:48:33 <oerjan> it has an overloaded type
14:48:36 <oerjan> :t print
14:48:36 <lambdabot> forall a. (Show a) => a -> IO ()
14:49:04 <ballzack3> what's putStrLn for then? strings only?
14:49:25 <oerjan> yep
14:49:37 <oerjan> (and putStr if you don't want a newline)
14:49:53 <oerjan> if you print a string you get it in quotes
14:52:20 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4702
14:53:57 <ballzack3> Stop spying on me!
14:54:16 <oerjan> heh
14:54:45 <oerjan> there's a box you can uncheck if you don't want it announced
14:55:07 <ballzack3> oh cool, i see
14:56:23 <dcoutts_> anyone been following that lengthy discussion on haskell-cafe "Wikipedia on first-class object"?
14:56:27 <dcoutts_> is it as bizarre as it looks to the casual observer?
14:56:43 <Korollary> dcoutts_: I marked it read without reading
14:57:09 <dcoutts_> Korollary: me too mostly, it's size and posting frequency is still quite surprising
14:59:00 <Cale> its ;)
14:59:00 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:59:41 <Cale> dmhouse: I just restarted mbot. I'd had a problem with my machine last night and rebooted it, but forgot to restart mbot.
14:59:55 <dmhouse> Cale: thanks.
15:29:04 <dibblego> ?src span
15:29:04 <lambdabot> Source not found. It can only be attributed to human error.
15:29:08 <dibblego> ?src break
15:29:08 <lambdabot> break p =  span (not . p)
15:33:34 <Tac-Tics> @src span
15:33:34 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:39:46 <opqdonut> does ghci use the compiled file.o module when i run "ghci file.hs"?
15:40:12 <mauke> if it's new enough, yes
15:40:18 <LoganCapaldo> yeeeez
15:45:08 <nolrai> @hoogle uncurry
15:45:08 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
15:45:08 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
15:46:26 <nolrai> @hoogle (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
15:46:26 <lambdabot> No matches, try a more general search
15:46:52 <mauke> @djinn (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
15:46:52 <lambdabot> f a (b, _) (c, _) = (a b c, a b c)
15:47:35 <nolrai> @pl x f (a, b) (c, d) = (f a c, f b d)
15:47:37 <lambdabot> x = (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
15:48:01 <osfameron> eeek!
15:48:15 <nolrai> eeek is right.
15:48:44 <nolrai> @ty (((.) . (,)) .)) .)
15:48:46 <lambdabot> parse error on input `)'
15:48:56 <nolrai> @ty (((.) . (,)) .)) .))
15:48:56 <lambdabot> parse error on input `)'
15:48:59 <opqdonut> can i profile inside ghci?
15:49:03 <nolrai> @ty (((.) . (,)) .)) .)))
15:49:04 <lambdabot> parse error on input `)'
15:49:09 <nolrai> @ty (((.) . (,)) .)) .
15:49:09 <lambdabot> parse error on input `)'
15:49:37 <opqdonut> ...
15:49:50 <dibblego> @hoogle (a, b) -> (b -> c) -> (a, c)
15:49:50 <lambdabot> No matches, try a more general search
15:49:58 <dibblego> @djinn (a, b) -> (b -> c) -> (a, c)
15:49:58 <lambdabot> f (a, b) c = (a, c b)
15:50:16 <nolrai> @src second
15:50:16 <lambdabot> Source not found. I am sorry.
15:50:23 <nolrai> @hoogle second
15:50:23 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
15:50:24 <lambdabot> Data.Time.Clock.secondsToDiffTime :: Integer -> DiffTime
15:50:24 <lambdabot> Distribution.Configuration.parseCondition :: ReadP r (Condition ConfVar)
15:50:31 <dibblego> ah thanks
15:51:41 <dibblego> @djinn (a, b) -> (a -> c) -> (c, b)
15:51:42 <lambdabot> f (a, b) c = (c a, b)
15:58:16 <dibblego> ?check \z ts -> let y (a, b) c = (c a, b); para _ e [] = e; para f e (x:xs) = f x xs (para f e xs); span' p xs = para (\x xs t -> if p x then span p xs `y` (x:) else ([], xs)) ([], []) xs in span' z ts == span z (ts :: [Int]) -- can span be written as a paramorphism?
15:58:16 <lambdabot>  Falsifiable, after 1 tests: <Int -> Bool>, [1,-2]
16:07:39 <dibblego> ?check \z ts -> let y (a, b) c = (c a, b); para _ e [] = e; para f e (x:xs) = f x xs (para f e xs); span' p xs = para (\x xs t -> if p x then t `y` (x:) else ([], xs)) ([], []) xs in span' z ts == span z (ts :: [Int]) -- can span be written as a paramorphism?
16:07:40 <lambdabot>  Falsifiable, after 3 tests: <Int -> Bool>, [-1,0]
16:11:21 <sjanssen> dibblego: yes, but not very nicely
16:11:37 <dibblego> am I not on the right track there?
16:11:46 <sjanssen> dibblego: see a back issue in TMR about defining takeWhile with foldr
16:12:07 <dibblego> what is TMR?
16:12:53 <sjanssen> The Monad.Reader
16:14:04 <dibblego> takeWhile with foldr seems easy
16:19:18 <dibblego> ?check \z ts -> let takeWhile' p xs = foldr (\a as -> if p a then return a `mplus` as else mzero) mzero xs in takeWhile' z ts == takeWhile z (ts :: [Int])
16:19:18 <lambdabot>  OK, passed 500 tests.
16:19:31 --- mode: ChanServ set +o Cale
16:19:40 --- mode: Cale set -oo Cale Igloo
16:20:22 <sjanssen> ah, sorry
16:20:28 <sjanssen> I was confusing para with cata for a moment
16:20:29 <dibblego> do you mean dropWhile?
16:20:38 <dibblego> I found a thread about that
16:21:42 <dibblego> it seems you can get a paramorphism from a catamorphism and an anmorphism
16:22:03 <dibblego> *anamorphism
16:23:22 <hpaste>  sjanssen pasted "span via para" at http://hpaste.org/4703
16:28:29 <sw17ch> i always find the succinctness of haskell statements amazing
16:36:17 <glen_quagmire> how can I generate [1^1, 2^2, ..., n^2] ?
16:36:41 <glen_quagmire> ?hoogle Integer -> Integer -> [Integer]
16:36:41 <lambdabot> No matches, try a more general search
16:37:07 <jmbr> glen_quagmire: try unfold
16:37:11 <dcoutts_> > map (^2) [1..10]
16:37:12 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
16:37:34 <glen_quagmire> nice!
16:37:41 <LoganCapaldo> > [ x^2 | x <- [1..10] ]
16:37:42 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
16:37:54 * LoganCapaldo offers wordier alternative
16:38:34 <glen_quagmire> LoganCapaldo: what is that construct called?
16:38:43 <glen_quagmire> pattern matching?
16:38:46 <LoganCapaldo> that is a monad comprehension
16:38:50 <dcoutts_> glen_quagmire: it's a list comprehension
16:38:53 <LoganCapaldo> err I mean list comprehension of course
16:39:03 <dcoutts_> glen_quagmire: it's like a set comprehension from mathematics
16:39:23 * LoganCapaldo is trying to corrupt the ignorant
16:39:50 <glen_quagmire> which of the two are more efficient?
16:39:56 <glen_quagmire> they both read well
16:40:24 <dcoutts_> glen_quagmire: you'd recognise mathematical notation like:  { x^2 | x ∈ {1..10} }
16:40:25 <LoganCapaldo> I wouldn't worry about it
16:40:37 * glen_quagmire thinks it's impossible to do complexity analysis for  haskell
16:40:43 <dcoutts_> glen_quagmire: they're exactly the same efficiency
16:41:10 <LoganCapaldo> [ x ^ 2 | x <- [1..10] ] gets turned into concatMap (\x -> [x ^ 2]) [1..10]
16:41:14 <dcoutts_> glen_quagmire: it's a little harder in lazy languages by not impossible
16:41:43 <dcoutts_> LoganCapaldo: that's only the H98 specification desugaring, ghc doesn't use that
16:42:07 <LoganCapaldo> eh I wasn't going for accuracy :)
16:42:25 <LoganCapaldo> I was leading up to pointing out that ultimately it was almost exactly the same
16:43:00 <dcoutts_> ok, my point was that ghc really does generate the same core for the two (I think)
16:43:52 <LoganCapaldo> well I'd be a little surprised if it didnt
16:44:45 <LoganCapaldo> not like shocked, but you'd expect it to
16:44:47 <dcoutts_> glen_quagmire: if you're interested in complexity analysis for lazy languages like haskell, see the book on purely functional data structures, it's a great book and describes two techniques for analysing complexity of data structures that rely on laziness
16:44:54 <dcoutts_> LoganCapaldo: aye
16:46:00 <glen_quagmire> dcoutts_: thanks. i'll save the book title for the future when I get familiar with haskell
16:46:34 <runar> I'm not having any luck installing the plugins package with ghc 6.8.2.
16:46:50 * LoganCapaldo is waiting for real world haskell
16:46:55 * runar too!
16:47:01 <LoganCapaldo> patiently ;)
16:47:11 <runar> gently, softly
16:48:16 <runar> src/System/Plugins/PackageAPI.hs:64:20:
16:48:17 <runar>     Not in scope: data constructor `InstalledPackageInfo'
16:48:50 <runar> Where is InstalledPackageInfo supposed to come from?
16:48:57 <glen_quagmire> arg I can't do for loops
16:52:04 <LoganCapaldo> @type forM
16:52:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
16:52:36 <LoganCapaldo> you probably want map or fold(r|l)
16:52:57 <LoganCapaldo> or forM if it' your tradional loop and do some sieeffect kind of for loop
16:53:10 <hpaste>  glen_quagmire pasted "Consul the monkey " at http://hpaste.org/4704
16:53:14 <runar> #if CABAL == 1 || __GLASGOW_HASKELL__ >= 604
16:53:37 <runar> that's going wrong somehow
16:54:39 <LoganCapaldo> i'm sure thees a clever list comprehension to do that, but I'm not good at coming up with them <g>
16:54:53 <dibblego> ?typ nub
16:54:54 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:56:11 <glen_quagmire> is there something like zip function but takes a lambda and does the operation?
16:56:19 <dibblego> ?type zipWith
16:56:20 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:56:20 <LoganCapaldo> @type zipWith
16:56:21 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:56:26 <LoganCapaldo> yes!
16:56:26 <glen_quagmire> oh thanks
16:56:52 <LoganCapaldo> and I personally think that was an awesome question, and one I never would have thought of asking
16:57:21 <idnar> @src zipWith
16:57:21 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:57:21 <lambdabot> zipWith _ _      _      = []
16:57:26 <idnar> hmm
16:58:02 <idnar> @ty curry
16:58:03 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:58:06 <idnar> @ty uncurry
16:58:07 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:58:19 <idnar> @pl uncurry (\x y -> f x y)
16:58:19 <lambdabot> uncurry f
16:58:44 <idnar> @pl \f xs ys -> map (uncurry f) (zip xs ys)
16:58:44 <lambdabot> (. zip) . (.) . map . uncurry
16:59:21 <LoganCapaldo> likewise, zipWith (,)
16:59:51 <idnar> yeah, the opposite direction is a lot nicer
17:03:19 <glen_quagmire>  zipWith (*) (repeat 2) [1..12]   -- yay! now I need to change it to (repeat n)
17:03:37 <glen_quagmire> zipWith (*) (repeat i) [1..j]
17:04:07 <glen_quagmire> does it matter where infinite list comes for arguments of zipWith?
17:04:13 <mauke> no
17:04:25 <glen_quagmire> great!
17:04:39 <mauke> > iterate (* 2) 1
17:04:39 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
17:05:14 <mauke> :t \i j -> take j (iterate (* i) 1)
17:05:15 <lambdabot> forall a. (Num a) => a -> Int -> [a]
17:07:38 <runar> @seen dons
17:07:38 <lambdabot> dons is in #xmonad, #haskell and #ghc. I don't know when dons last spoke.
17:09:55 <glen_quagmire> > [zipWith (*) (repeat i) [1..i-1] | i <- [2..12]]   -- yay Consul the educated monkey almost done
17:09:55 <lambdabot>  [[2],[3,6],[4,8,12],[5,10,15,20],[6,12,18,24,30],[7,14,21,28,35,42],[8,16,24...
17:10:29 <glen_quagmire> i need to print them nicely
17:13:24 <LoganCapaldo> mapM_ print ? :)
17:13:33 <glen_quagmire> let consul n = [zipWith (*) (repeat x) [1..x-1] | x <- [2..n]] ++ [map (^2) [1..n]]  in consul 12
17:14:02 <glen_quagmire> that's the whole thing except I have to print it after rotating the triangle
17:15:10 <glen_quagmire> LoganCapaldo: nicely formatted
17:15:29 <LoganCapaldo> i make small joke
17:20:33 <hpaste>  glen_quagmire annotated "Consul the monkey " with "Consul the monkey " at http://hpaste.org/4704#a1
17:30:32 <mmmdonuts> @ty transpose
17:30:34 <lambdabot> forall a. [[a]] -> [[a]]
17:31:50 <_phobes> Monads are dumb!
17:32:15 <LoganCapaldo> don't anthromorphize monads, they don't like it.
17:32:25 <glen_quagmire> @index transpose
17:32:26 <lambdabot> Data.List
17:36:09 <hpaste>  Cale annotated "Consul the monkey " with "consul" at http://hpaste.org/4704#a2
17:36:48 <glen_quagmire> Cale, mmmdonuts thanks
17:37:38 <Cale> Of course, you could also try playing around with your list comprehension to put the elements in a different order.
17:38:46 <Cin> giggidy goo
17:38:53 <glen_quagmire> yup i was changing [1..n]  to [n, n-1 ..1]
17:39:13 <glen_quagmire> but I was worried about lower bound of n
17:41:31 <mdmkolbe|work> Is there a prepackaged version of the gensym that GHC uses? (i.e. one that isn't the cause of strict dependancies (the usual one that thread state through cases such dependancies)) (This probably requires use of unsafe operations.)
17:41:56 <mdmkolbe|work> (I could build my own, but wheels and all that.)
17:41:56 <Cale> _phobes: dumb in what way?
17:44:18 <mdmkolbe|work> @index unsafePerformIO
17:44:19 <lambdabot> System.IO.Unsafe, Foreign
17:47:36 <_phobes> Cale:  1) One could argue that it's really the presentation of Monads in Haskell that I don't like, but basically I think the Monad structure isn't really that interesting for programming
17:48:04 <_phobes> For example, I don't see any reason to try to find >>= and return that satisfy the Monad laws
17:48:28 <_phobes> When it's easy enough to arrange for those laws to be true by construction in the cases that I think we usually care about
17:48:59 <Cale> _phobes: The laws are the obvious thing you'd want in order to reasonably be able to refactor code.
17:49:39 <_phobes> Yes, but the laws should obviously hold, but there is an obvious way to make the law hold:  do the things you're shifting in in the right order !
17:49:53 <Cale> The associative law, for example, essentially says that you can chop some lines out of the middle of any do-block, define that as a new term and call it from the original do-block, without changing the meaning of the code.
17:50:00 <_phobes> Then you can write down any rule and associativity holds
17:50:16 <Cale> In what right order?
17:50:28 <_phobes> As an example, consider a Monad like MonadPlus that has another operation besides choose - setPriority
17:50:30 <Cale> I'm not sure I understand that remark.
17:50:35 <_phobes> First to last
17:50:53 <Cale> Well, the monad itself governs what "doing" something means.
17:51:23 <Cale> Have you seen examples like the backwards-in-time state monad?
17:51:30 <Cale> and the list monad, of course
17:51:33 <_phobes> I can imagine it
17:51:56 <thermoplyae> i haven't
17:51:57 <_phobes> Do an example of extending the list monad with a concept of priority
17:52:08 <Cale> In the backwards-in-time state monad, the computations are carried out in the order you wrote them as usual, but the state flows in the reverse direction.
17:52:09 <thermoplyae> sounds like cps though
17:52:27 <_phobes> so that instead of just working through all of the possibilities, it returns a list that lazily works through the possibile choices in order of priority
17:52:30 <mdmkolbe|work> _phobes: by that do you mean something like the probabalistic non-det monaid?
17:52:41 <_phobes> probably
17:52:56 <_phobes> if probabilistic takes into account a priority that can be set using an operation in the Monad
17:53:26 <_phobes> It seems quite not-straightforward to write down definitions of >>= and return that satisfy the Monad laws
17:53:31 <Cale> Well, ordinarily, priority is accounted for according to the order in which the elements occur.
17:53:32 <_phobes> unless you cheat
17:53:39 <mdmkolbe|work> _phobes: oh, but there are.
17:53:54 <mdmkolbe|work> in such a system you don't hard-set the probabilities, you have to divide up the probabilities among alternatives and then take the products as you sequence
17:54:06 <Cale> _phobes: If that's the case, then perhaps you don't *want* a monad.
17:54:15 <Cale> There are other sorts of combinator library of course.
17:54:29 <_phobes> Well, there *is* an easy way to write down any Monad like that
17:54:42 <_phobes> Namely, you build up data representing the operations you want
17:54:49 <Cale> The point of monads is to have a collection of devices (like the contents of Control.Monad) which work in any monad for free, once you've determined that what you're dealing with really is a monad.
17:54:51 <_phobes> and then inside "runMonad" do them in the right order
17:55:24 <mdmkolbe|work> _phobes: some things *can't* be monads.  e.g. a monad that counts the number of bind operators used
17:55:54 <_phobes> Yes, that's right ... but counting the number of bind operations isn't interesting really
17:56:18 <_phobes> And you *can* count the number of bind operations if you restrict the use of return
17:56:33 <mdmkolbe|work> _phobes: counting binds violates the monad laws
17:56:47 <_phobes> Well, you can count the number of operations called obviously
17:56:57 <_phobes> which is essentially the same thing
17:57:00 <Cale> Which operations?
17:57:27 <_phobes> I suppose I should clarify my point of view:  I'm imaging that we're accessing the Monad through some interface
17:57:31 <_phobes> typeclass
17:57:36 <_phobes> like MonadPlus, etc
17:57:43 <_phobes> and it supports some finite number of monadic operations
17:57:57 <_phobes> In that case you can count how many operations have been executed
17:58:11 <_phobes> You can't count binds, but it isn't interesting to count 'returns'
17:58:20 <_phobes> which are really just plumbing
17:58:27 <Cale> Depends on what operations those are and what laws you'd like them to satisfy.
17:58:35 <mdmkolbe|work> _phobes: many fall into the trap of effectively counting binds.  e.g. a monad that does breadth-first, limited-depth, non-det that is based on the number of binds.  (the way around this is to add an operation that explicitly increments the counter)
17:59:05 <pergesu> can I install ghc via macports on os x?  Every time I do, it tells me that it needs GHC.  That's what I'm trying to install!
17:59:18 <Cale> pergesu: You need a GHC binary in order to compile GHC.
17:59:45 <Cale> pergesu: Hence, just download the binary release, it's easier.
18:00:39 <Cale> pergesu: There is a way to bootstrap, but it's best performed by someone who knows the compiler well.
18:00:41 <_phobes> mdmkolbe|work:  I'm not sure I follow
18:00:45 <mdmkolbe|work> _phobes: of course, you can always add monad operators that are not subject to the monad laws, but the point of monads is that they present a common interface so some library function (e.g. "when") doesn't have to worry about whether it is implemented as foo or foo >>= return because those are guerented equivalent by the laws
18:01:30 <_phobes> mdmkolbe|work:  My point is that satisfying the Monad laws isn't really something we should have to worry about
18:01:41 <Cale> Yeah, the point isn't that all combinator libraries should be monads, but that a good chunk of them are, and that we can save effort when that happens to be the case.
18:01:47 <pergesu> Cale: okay, thanks
18:02:01 <mdmkolbe|work> _phobes: imagine a non-det monad, for which any non-det path becomes mzero if it uses too many >>=.  that would violate the monad laws.
18:02:44 <Cale> _phobes: Most of the time, the laws are easy to get, but when you call something a monad when it isn't, things can be very confusing.
18:03:26 <mdmkolbe|work> _phobes: well, it would be nice if GHC included an automated prover to check whether our implementation satisfied the monad laws.  but in most cases when I wrote a "monad" that violated the laws, this was an indication that something was semantically wrong with the monad.
18:03:32 <Cale> Loss of associativity breaks the most fundamental means of refactoring monadic code.
18:03:33 <_phobes> mdmkolbe|work:  I agree that counting >>= isn't going to work... you can effectively do it though if you're really interested in counting operations
18:03:46 <_phobes> mdmkolbe|work:  I don't think an automatic theorem prover is necessary
18:04:18 <_phobes> Ok let me give my example
18:04:23 <_phobes> Rather finish it
18:04:26 <mdmkolbe|work> _phobes: no you never count >>=, instead you add an operator (e.g. inc_counter)
18:04:47 <_phobes> mdmkolbe|work:  Or you can count the number of "real operations"
18:04:58 <_phobes> >>= and return are not real operations - they're plumbing
18:05:42 <_phobes> Anyway, here's a simple way to get a Monad with operations 'choose' and 'setPriority' which satisfies the Monad laws
18:05:48 <mdmkolbe|work> _phobes: the monad laws are sufficent and nessisary to enforce  that >>= and return are not real operations and are just plumbing.
18:06:29 <_phobes> mdmkolbe|work:  Yes, allowing arbitrary >>= and return and then imposing some "laws" is one way to do that... the other way would be to have the laws hold by construction
18:07:00 <mdmkolbe|work> by construction of what?  the monad? the program using the monad?
18:07:10 <_phobes> Construction of the Monad
18:07:13 <Cale> _phobes: You can do things with free monads, but not every monad is free.
18:07:36 <mdmkolbe|work> Cale: free =?= by construction
18:08:04 <Cale> mdmkolbe|work: well, sure, it's just the only case I'm aware of where you get the monad laws for free by construction.
18:08:23 <mdmkolbe|work> Cale: "=?=" = question
18:08:37 <_phobes> Cale:  Hmm ok, well let me recheck my train of thought
18:08:39 <Cale> oh, they're not the same thing
18:08:50 <mdmkolbe|work> Cale: I don't know
18:08:51 <Cale> (but almost?)
18:08:58 <mdmkolbe|work> I was asking you
18:09:24 <Cale> Free monad is a technical term, "monad by construction" is a little fuzzier.
18:09:39 <_phobes> Free monad sounds very similar to what I have in mind
18:09:42 <mauke> free the monads!
18:09:48 <_phobes> What's an example of a not-free Monad?
18:10:11 <_phobes> Actually, I think I know the relationship
18:10:29 <_phobes> I think a free Monad is basically one where you do what I'm thinking and what you get doesn't depend on bind order
18:10:34 <mdmkolbe|work> _phobes: so if I understand you correctly, you don't object to the monad laws as much as having to prove the monad laws.  you want them to be satisfied automatically?
18:10:55 <Cale> I'm fairly sure that, for instance, Cont is not free.
18:11:40 <Cale> !paste
18:11:40 <hpaste> Haskell paste bin: http://hpaste.org/
18:11:52 <dibblego> I just spent 10 minutes at ghci wondering why it complained about my Scala function def
18:12:27 <hpaste>  Cale  pasted "examples of free monads care of Derek Elkins" at http://hpaste.org/4705
18:12:28 <Saizan> hah! you traitor!
18:12:30 <_phobes> mdmkolbe|work:   Basically my reasoning is 1) Hey, we can get rid of the need to prove the Monad laws, 2) Actually there isn't much point in considering this Monadic structure at all
18:12:48 <mdmkolbe|work> _phobes: the problem is that whatever system of "by construction" you use, you will always exclude some monad implementations (as a consequence of Rice's Theorem).  thus it is better to leave it up to the programmer rather than restrict what can be programmed.
18:13:08 <mdmkolbe|work> s/monad implementations/otherwise valid monad implementations/
18:13:27 <_phobes> mdmkolbe|work:  hrmm.... Rice's theorem implies that?  Basically I have a construction that I thought should include every Monad
18:13:51 <Cale> _phobes: does that paste look like what you were thinking of?
18:14:55 <_phobes> sort of...
18:15:01 <_phobes> sec, lemme try to understand the differences
18:15:48 <mdmkolbe|work> _phobes: Rice's Theorem says that any non-trival property of a function implemented by a program can't be automatically proven in general (i.e. have a complete proof system). the monad laws are non-trival properties. "by construction" is an "automated" proof system.  thus it can never be complete (i.e. there are always cases the proof system won't handle)
18:16:44 <glen_quagmire> how can I teset pattern matching in ghci?  like, I want to test if [[]] matches [[]:rest]
18:16:50 <_phobes> mdmkolbe|work:  Ah, that argument has a flaw.  I don't *need* to answer the question of whether a given structure is a Monad
18:17:07 <Cale> glen_quagmire: case [[]]] of [[]:rest] -> True; _ -> False
18:17:08 <_phobes> mdmkolbe|work:  I just need to write down a structure that is equivalent IF it happens to be monad
18:17:10 <mdmkolbe|work> glen_quagmire: case [[]] of [[]: rest] -> foo
18:17:25 <mdmkolbe|work> _phobes: the argument still holds
18:17:25 <EvilTerran> (\[[] : rest] -> ()) [[]]
18:17:50 <_phobes> mdmkolbe|work:  Are you sure?
18:17:52 <glen_quagmire> ah thanks
18:17:56 <mdmkolbe|work> _phobes: in that case, parsing is the "proof" checker
18:18:05 <_phobes> mdmkolbe|work:  eh?
18:18:50 <_phobes> Cale:  I'm pretty sure that is more complicated than what I had in mind... because of the use of 'sig'
18:19:14 <_phobes> or maybe not... does 'sig' mean bind?
18:19:30 <Cale> sig is a data type you plug in which provides the "operations"
18:19:46 <_phobes> ah ha, ok sorry let me look again
18:19:51 <mdmkolbe|work> _phobes: if you limit your system to those monads that can be proven by construction, then your system nessisarily excludes some valid implementations.  In this case, you've limited your input to inputs that satify a certain syntactic constraint.  Rices Theorem basically says in general you can't derive semantics from syntax
18:20:53 <_phobes> mdmkolbe|work:   I'm not deriving semantics
18:21:00 <mdmkolbe|work> _phobes: limiting to by construction, is a syntactic constraint, but monad laws are a semantic constraint.
18:21:05 <_phobes> mdmkolbe|work:  My construction proves nothing
18:21:19 <mdmkolbe|work> _phobes: it proves that >>= and return are "just plumbing"
18:21:44 <_phobes> mdmkolbe|work:  No, my construction does not prove that
18:22:13 <_phobes> If you give me a particular >>= and return, I will not be able to tell you using my construction whether you have a Monad
18:23:03 <glen_quagmire> is there a way to match (rest:last_element) ?
18:23:09 <_phobes> However, I can use the construction to build another structure that is always a Monad, and which will coincide with your original structure if it was a Monad
18:23:18 <LoganCapaldo> glen_quagmire: not really
18:23:23 <_phobes> The question of whether that structure coincdes remains open
18:23:27 <LoganCapaldo> xs | last xs == last_element
18:23:33 <glen_quagmire> i mean,  some_list ++ [last element]
18:23:39 <LoganCapaldo> no
18:23:51 <LoganCapaldo> you can only match against constructors
18:24:04 <glen_quagmire> LoganCapaldo: what is |  in xs | last xs ?
18:24:08 <LoganCapaldo> otherwise you have to do something like what I did with a guard
18:24:12 <LoganCapaldo> a guard
18:24:19 <glen_quagmire> oh i see
18:24:30 <LoganCapaldo> if the thing on the rhs of the | is true then it matches
18:24:43 <_phobes> Cale:  No, this is not what I'm doing
18:24:56 <mdmkolbe|work> _phobes: it is not enough to prove that your construction always produces a monad, you need to prove your construction can produce any monad
18:24:57 <glen_quagmire> so you're comparing value of (last xs) with some known value
18:25:01 <LoganCapaldo> it can be read as such that
18:25:04 <LoganCapaldo> yeah
18:25:05 <_phobes> It's as I thought - he's buliding up the free structure formally, but then expecting it to reduce independent of order
18:25:15 <LoganCapaldo> xs such that last of xs is equal to something
18:25:22 <glen_quagmire> maybe lisp's dottest list or something is made for this purpose..
18:25:50 <glen_quagmire> dotted list
18:26:18 <hpaste>  Cale pasted "perhaps it's something like this?" at http://hpaste.org/4706
18:26:27 <mdmkolbe|work> glen_quagmire: lisp's dotted list is equiv to (a : b : c : d) == (a b c . d)
18:26:43 <_phobes> mdmkolbe|work:  I think I do have that - in a certain sense - since I can take any real Monad and convert it into a construction which yields an equivalent result
18:27:13 <dibblego> you could do it in Scala
18:27:18 <mdmkolbe|work> _phobes: have you tried Cont?
18:27:47 <_phobes> I've thought about it... but haven't worked through it rigorously
18:28:13 <_phobes> I'll think about this some more... I'm sure I have a big gaff somewhere
18:28:17 <glen_quagmire> is `reverse` costly?
18:28:27 <Cale> Of course, that doesn't exactly satisfy the monad laws, but it might, up to some equivalence on your terms.
18:28:35 <hpaste>  dibblego pasted "Extractor Methods" at http://hpaste.org/4707
18:28:46 <mdmkolbe|work> _phobes: if you wish to build a construction that give you monads "for free" that is fine, but you are just providing *one* avenue to proving the monad laws.  the laws are still fundamental.
18:28:47 <_phobes> Cale:  What are you referring to with 'that'?
18:28:50 <glen_quagmire> if list is doubly linked, `reverse` would just change direction
18:28:51 <dibblego> glen_quagmire, O(n) time, constant space
18:28:54 <Cale> http://hpaste.org/4706
18:29:07 <glen_quagmire> oh i see
18:29:08 <mdmkolbe|work> _phobes: ok, now the hard one.  do the IO monad ;-)
18:29:12 <dibblego> glen_quagmire, if list is doubly linked, we'd have lots of problems
18:29:26 <LoganCapaldo> indeed we do
18:29:30 <_phobes> mdmkolbe|work:  IO (being state) was my first example of course :)
18:29:54 <Cale> Of course, IO isn't formally a state monad.
18:29:56 <mdmkolbe|work> IO is more than just state, it's machine state, it can't be expressed in haskell
18:30:03 <_phobes> I just leave implementation of putString :: World -> World as an exercise for the reader
18:30:18 <Cale> _phobes: and how do you do forkIO ?
18:30:19 <Cale> :)
18:30:25 <_phobes> :)
18:30:31 <mdmkolbe|work> @index forkIO
18:30:31 <lambdabot> Control.Concurrent
18:30:41 <Cale> (I really hate the RealWorld model of IO)
18:30:42 <Saizan> dibblego: constant space? you've to force the list and build n new conses
18:30:59 <dibblego> Saizan, yes, my bad
18:31:04 <_phobes> Cale:  really, why?
18:31:05 <Cale> Something more like the GADT I just presented, under an appropriate equivalence, is more like it.
18:31:29 <_phobes> Cale:  I think it should be compartmentalized into smaller "worlds", for sure
18:32:09 <_phobes> I guess that's what you're talking about... the fact that IO has all kinds of unrelated junk dumped into it
18:32:15 <_phobes> and I agree, that's bad
18:32:21 <Cale> There's no actual way to model the "RealWorld" values. They have to include everything, including, for instance, other machines over the network, the positions of the user's fingers, and so on.
18:32:51 <_phobes> Ya, but I still think the state metaphor is useful
18:32:53 * Saizan wonders if CPS transforming the backwards state monad would work
18:33:12 <mdmkolbe|work> Saizan: CPS transforming is always valid
18:33:26 <Saizan> mdmkolbe|work: it changes strictness
18:33:37 <Cale> There's a much simpler view of IO computations as simply being syntax for side-effecting programs, modulo some program equivalence.
18:33:43 <mdmkolbe|work> Saizan: true
18:34:08 <nolrai> cale: i like that model.
18:34:24 <nolrai> just off the top of my head.
18:34:49 <_phobes> Cale:  I think it's useful to simultaneously view every Monad as abstract instructions for some machine, as well as a as inducing a function taking machine state to machine state
18:34:58 <hpaste>  Cale annotated "perhaps it's something like this?" with "IO" at http://hpaste.org/4706#a1
18:35:19 <_phobes> The "syntax for side effecting programs" falls into the former view... the world state transformer falls into the second
18:35:31 <EvilTerran> o/` IO, IO, it's off to (State# RealWorld) we go...
18:35:57 <_phobes> Cale:  RE annotation, yes
18:35:58 <Cale> If the RealWorld model worked better, GHC wouldn't have to cheat :)
18:36:20 <LoganCapaldo> there's no truth in advertising
18:36:35 <mdmkolbe|work> LoganCapaldo: is that an advertisement?
18:37:04 <LoganCapaldo> i hope so
18:37:42 <_phobes> The other problem I have is with Monad transformers
18:37:55 <_phobes> which I've concluded are broken and backwards
18:38:43 <Saizan> broken?
18:39:02 <Cale> Perhaps you'd prefer distributive laws?
18:39:12 <_phobes> Saizan:  Don't compose correctly
18:39:18 <_phobes> Cale:  distributive laws?
18:39:54 <Saizan> well you're not guaranteed that you'll get a monad unless you prove it
18:39:55 <Cale> Yeah. If you have monads N and M together with a map:  M (N a) -> N (M a), then N M becomes a monad.
18:40:03 <mdmkolbe|work> _phobes: are you refering to the need to "lift"?
18:40:26 <_phobes> mdmkolbe|work:  No, I'm talking about what happens if you work in ListT IO
18:40:37 <Cale> The crucial piece being of course, how join works: join :: N (M (N (M a))) -> N (M a)
18:40:41 <Saizan> ah well, ListT *is* broken
18:40:43 <_phobes> (even if you use the "right" listT
18:41:05 <Cale> you apply the distributive law to the inner M N to swap them, and then use the join in M and N
18:41:11 <Cale> (lifted appropriately of course)
18:41:21 <_phobes> I shouldn't say they're broken... they do what they're supposed to - it's just not what programmers should be using to compose monads
18:41:41 <_phobes> Cale:  (still thinking about assoc)
18:41:42 <Cale> ListT is specifically broken.
18:41:51 <Cale> (and should be removed from the libraries)
18:42:08 <_phobes> Right, but there's that ListT alternative that isn't broken, right?  And it still doesn't work the way I want
18:42:09 <Cale> It is *not* a monad transformer.
18:42:52 <Cale> I see a lot of people thinking about monad transformers in the wrong way. A good hint is that if you're using lift all over your code, then you're doing it wrong.
18:43:17 <_phobes> can you elaborate on that?
18:43:21 <Cale> sure ;)
18:43:32 <_phobes> (Clearly I'm doing it wrong :)
18:43:35 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
18:43:36 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
18:43:43 <mdmkolbe|work> Is there an implementation of something like UniqSupply (i.e. a gensym that doesn't add any strictness), that is suitable for user code?
18:43:44 <_phobes> hehe thanks
18:45:00 <_phobes> Cale:  ah, thanks... that's a neat trick (I'd seen omething like that but more verbose using a ton of type classes), but it doesn't address my problem
18:45:32 <_phobes> My problem is more semantic than syntactic (which lifts everywhere can be lumped in with syntax basically)
18:46:17 <Cale> _phobes: note that with the end result of my construction, at least outside of the module it's carried out in, you can't actually tell that monad transformers were used.
18:47:13 <Cale> Monad transformers don't solve all the problems of constructing monads, but I'm fairly certain that no general construction ever will.
18:47:43 <Cale> (and they should be thought of as a way to construct monads, and not to combine them)
18:48:43 <mdmkolbe|work> @index unsafeDupableInterleaveIO
18:48:43 <lambdabot> bzzt
18:49:09 <mdmkolbe|work> @index unsafeInterleaveIO
18:49:09 <lambdabot> System.IO.Unsafe
18:50:12 <Saizan> one big limitation is that transforming a monad which has an interface that takes parameters in that monad it's hard to lift those functions
18:50:36 <Cale> Maybe even impossible.
18:50:40 <Saizan> i.e, transforming parsec and using many/etc..
18:50:45 <_phobes> Cale:  I'm quite sure that what I have in mind won't clear up all of the issues with Monads... I'm just thinking that the Monad structure isn't often what's interesting to programmers
18:52:24 <Cale> _phobes: If you write up an example of how you'd structure things, I'll have a look :)
18:52:50 <_phobes> hehe ok
18:53:01 <Cale> http://haskell.org/haskellwiki/Monads_as_computation  -- this article has a fairly comprehensive overview of exactly why I think we care about monads in programming.
18:53:23 <dibblego> let breaks f as = takeWhile f as : case dropWhile f as of [] -> []; d -> let (w, r) = break f d in w : breaks f r -- can that be written using a paramorphism?
18:53:51 <mauke> @source System.Posix.Process
18:53:51 <lambdabot> http://darcs.haskell.org/packages/unix/System/Posix/Process.hs
18:56:48 <_phobes> Here's what I think is a simple proof of my claim:
18:57:09 <_phobes> well nm I'll think about this morre
18:57:14 <mdmkolbe|work> @index Int#
18:57:15 <lambdabot> bzzt
18:57:17 <_phobes> before I go posting proofs :)
18:59:02 <mdmkolbe|work> _phobes: you only have to prove three things.  (1) all things from your construction are monads (should be easy). (2) all monads can be made from your construction (a bit harder). (3) all monad *implementations* from your construction are as efficient and lazy as any hand implementation (probably impossible)
19:00:04 <_phobes> mdmkolbe|work:  1 and 2 are easy.   3 isn't going to be true in general, but I suspect efficiency will frequently increase
19:00:50 <mdmkolbe|work> (don't forget lazyness)
19:01:01 <mdmkolbe|work> (or space leaks)
19:01:15 <_phobes> mdmkolbe|work:  I don't like pervasive laziness :)
19:01:35 <_phobes> pervasive laziness is a premature pessimisation :)
19:02:44 <mdmkolbe|work> _phobes: monads are libraries, thus nothing is premature if the users actually need it.  (e.g. I've got a program that uses the output of the writer monad as the input to the reader monad (i.e. it needs lazyness))
19:02:50 <Cale> Pervasive laziness is important.
19:03:16 <mdmkolbe|work> _phobes: when lazeness matters, it isn't about speed, it is about not going into an infinite loop
19:04:04 <Cale> Laziness is important because of the large amount of compositionality that it buys you. It allows you to decompose problems in ways that you just couldn't otherwise.
19:04:20 <_phobes> mdmkolbe|work - 'lazy' annotations are a good way to make it clear that you are *relying* on a particular evaluation strategy to make your program work
19:04:32 <Cale> It's important that it be the default option in order that all the library functions be as lazy as possible.
19:04:46 <Cale> Otherwise, you lose those options for decomposition.
19:04:59 <Cale> (practically)
19:05:54 <Cale> You might as well not have laziness, if your entire bag of components are strict.
19:06:01 <_phobes> Libraries should be carefully designed for laziness ... also it needs to be possible to write code that is generic with respect to evalutation strategy
19:06:32 <Cale> It is possible, interestingly enough :)
19:06:40 <_phobes> Cale:  In haskell currently?
19:06:43 <Cale> yes
19:06:49 <_phobes> do tell!
19:07:03 <Cale> http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
19:07:05 <lambdabot> Title: Algorithm + Strategy = Parallelism, http://tinyurl.com/22srxl
19:07:08 <_phobes> Have another canned link - awesome!
19:07:33 <mdmkolbe|work> _phobes: ... what you say effectively means, that the default is lazy (b/c the code must be written to handle lazy).  and you just add a flag that adds strictness analysis
19:08:01 <_phobes> mdmkolbe|work - I think default evaluation strategy should be strict
19:08:29 <_phobes> mdmkolbe|work - It's just easier to think about, and code written to be correct under strict evaluation can always be evaluated lazily - not vice versa
19:08:30 <Cale> _phobes: let me make a little argument in this regard
19:08:53 <EvilTerran> it's only easier to think about because it's what you're used to
19:09:03 <_phobes> I disagree
19:09:05 <Cale> _phobes: We'll divide up data into two classes: "large" and "small" according to whether that data has many separately evaluable components, or few
19:09:09 <EvilTerran> i've done so much haskell in the last year that i find it easier to think lazily than strictly
19:09:21 <Cale> (I have to say I agree with EvilTerran)
19:09:22 <EvilTerran> i keep wanting implicit thunking in perl, say
19:09:23 <mdmkolbe|work> _phobes: "and not vice versa" is exactly why the default should be non-strict.  you can write more programs.  I've found lazy programs easier to think about b/c they are closer to the math.
19:09:30 <_phobes> afk 2 min sorry
19:09:46 <Cale> _phobes: okay, let me know when you're back so I can tell you exactly why we all like laziness.
19:10:03 <dibblego> I have to say that I agree with EvilTerran/Cale, even though I still don't always find it easier, I recognise it is a self-limitation after some time (it is always a pretty safe assumption)
19:10:06 <mdmkolbe|work> _phobes: i.e. you never loose any semantics by being lazy.  strict limits your semantics as a small performance gain (premature optimization)
19:10:06 <EvilTerran> (obvious puns about it being less work aside)
19:10:38 <mdmkolbe|work> s/as a/at a/
19:10:42 <dibblego> I have to rewrite scala.collection.immutable.TreeMap because method arguments are strict by default; so annoying
19:11:08 <EvilTerran> same goes for immutability, actually; took a bit of getting used to, but it's *so* much easier to think about than mutable code is, now
19:11:42 <dibblego> I've never had a problem with that; always had a problem with the 'free variable' (or the imaginary one I like to call it sometimes)
19:12:00 <_phobes> back, do tell :)
19:12:12 <EvilTerran> "wait, does this method mutate the original when it returns its new value?"
19:12:21 <Cale> okay
19:12:27 <EvilTerran> "is it safe to clobber this array i got as a parameter?"
19:12:46 <scodil> EvilTerran: const usually helps answer those questions
19:12:48 <_phobes> Hey, you won't find any argument from me on purity
19:12:52 <Cale> So we divide up data into essentially two classes: "large" data are those pieces of data which have many separately evaluable components
19:13:06 <dibblego> isn't there an eager Haskell or something like that?
19:13:07 <Cale> (e.g. lists, etc.)
19:13:10 <Cale> and "small" data are those which have few
19:13:11 <EvilTerran> scodil, well, it helps, yes. immutability-by-default helps a lot more, though.
19:13:16 <Cale> (integers, floats)
19:13:18 <_phobes> Cale: opk
19:13:22 <scodil> EvilTerran: no argument here
19:13:40 <Cale> So if we have a function, there are initially four possible cases:
19:13:54 <_phobes> yup S->L, L->S, S->S, L->L
19:13:55 <Cale> Small -> Small: Lazy and strict are essentially the same thing
19:14:14 <Cale> Small -> Large: You certainly want laziness.
19:14:37 <Cale> Large -> Large: Laziness is again better, if you can do any sort of "streaming"
19:14:38 <_phobes> (Not necessarily)
19:15:00 <Cale> not necessarily?
19:15:40 <Cale> Large -> Small (searching): You want laziness, in order not to force the entire structure in case the thing is found early on.
19:15:46 <_phobes> First of all, note that my previous point applies:  Anything that is faster with laziness *can be done lazily* if the original programmer was assuming only strictness
19:15:53 <Cale> Large -> Small (collapsing): This is where you want strictness.
19:16:18 <_phobes> But regarding my comment, Small -> Large it depends on what you do with the large after that
19:16:22 <Cale> That is, in Large -> Small cases where you're using the entire large structure.
19:16:28 <_phobes> Small -> Large -> Small might well be better off with strict evaluation
19:17:01 <_phobes> I'd expect it would be better off in many cases
19:17:21 <Cale> It's really in the collapsing phase where you want the strictness.
19:17:41 <Cale> Now, if you have something like Small -> Large -> Small, you may want something like deforestation, but that's another matter.
19:17:46 <glen_quagmire> is there a way to append an element to a list?  or should I use (:) ?
19:17:53 <mdmkolbe|work> _phobes: lazeness is *not* about speed, it's about more expressive power
19:17:54 <Cale> glen_quagmire: to the end?
19:17:57 <_phobes> If using laziness means that you have a large array of boxed values instead of a large array of unboxed ones, then no... laziness can be a huge loss
19:18:00 <glen_quagmire> list ++ [x]
19:18:02 <mdmkolbe|work> glen_quagmire: a ++ [x]
19:18:02 <glen_quagmire> Cale: yes
19:18:24 <Cale> glen_quagmire: right, that's how you do it, but if you're doing it a lot, then something is wrong
19:18:26 <glen_quagmire> mdmkolbe|work: is it ok or ugly?
19:18:35 <glen_quagmire> Cale: oh i see
19:18:54 <mdmkolbe|work> glen_quagmire: if you need to deal with the end of lists, often you may want to work with a reversed list or look into representations that offer fast head and tail access (e.g. Deques)
19:18:55 <_phobes> mdmkolbe|work - I believe Cale is arguing about efficiency, but I think strictness is better on both fronts
19:18:57 <Cale> glen_quagmire: (note that (xs ++ ys) takes O(length xs) reductions to fully evaluate)
19:19:01 <_phobes> (as a default)
19:19:02 <glen_quagmire> Cale: i'm trying to modify your diagonals function and other code to eliminate call to reverse
19:19:04 <mdmkolbe|work> glen_quagmire: it's ok, but it is O(length x)
19:19:41 <Cale> _phobes: I'm talking about efficiency, primarily in terms of memory usage. The difference in CPU time between the two strategies is minimal.
19:19:51 <Cale> (except where it's infinite, of course ;)
19:20:05 <mdmkolbe|work> _phobes: the set of terminating strict programs is a strict subset of the set of terminating lazy programs so I don't see how you can say that strictness is better in terms of expressive power
19:20:20 <_phobes> Cale:  I really doubt that in the case where you're computing a giant array of thunks instead of a giant array of unboxed values
19:20:30 <Cale> _phobes: what if you don't use them all?
19:20:43 <Cale> _phobes: If it's a memo table, that's exactly what you want.
19:20:43 <dibblego> mdmkolbe|work, /end-of-proof? :)
19:21:01 <mdmkolbe|work> dibblego: ?
19:21:11 <Cale> An array of unboxed values doesn't have separately evaluable components though, and hence it's "small".
19:21:12 <dibblego> mdmkolbe|work, I was just agreeing is all
19:21:15 <_phobes> mdmkolbe|work - I didn't mean to imply that it was more expressive.  I just mean that I think it's the right default on semantic grounds
19:21:26 <_phobes> Cale:  Exactly, IF you don't use them all
19:21:47 <_phobes> Cale:  Very often you will use them all
19:21:49 <Cale> _phobes: If you know that you're going to use them all, you can use a small datastructure instead of the large one.
19:22:14 <mdmkolbe|work> _phobes: the *only* difference in semantics, is that strict programs diverge more often which I don't think is "better" in any way.
19:22:16 <_phobes> Cale:  You mean use a datastructure with a strict annotation?
19:22:21 <Cale> (for example an unboxed array)
19:23:34 <_phobes> mdmkolbe|work:  That's like saying a type system is terrible because it only rejects programs
19:24:22 <Cale> No, in this case, it really is worse. There are many extremely useful programs which diverge under strict evaluation.
19:24:28 <_phobes> mdmkolbe|work:  Only assuring the programmer strict evaluation outlaws complicated hard to reason about values
19:24:49 <scodil> those programs surely could be re-written
19:24:54 <_phobes> Cale:  And I'd wager a well placed "lazy" keyword would make everyone of them clearer and easier to understand
19:24:57 <Cale> I estimate from my own experience, and this argument, that 75%+ of the time, laziness is either equivalent or better than strictness. In that remaining 25% of the code, you just need to place a strictness annotation, or use a strict fold operation, since they're usually places where you're collapsing a large datastructure (or virtual datastructure, in the case of recursion), down to a small value.
19:24:57 <mdmkolbe|work> _phobes: it would be if it didn't gain you anything (e.g. static assurances).  but strictness doesn't gain you *any* semantic assurances.
19:24:58 <scodil> that's mostly an aesthetic issue
19:25:49 <Cale> _phobes: If you programmed optimally with regard to expressiveness using such a keyword, you'd have far more lazy annotations than you would have in a lazy language using strictness annotations.
19:25:54 <_phobes> mdmkolbe|work:  No, it definitely does make your program easier to reason about!
19:25:57 <_phobes> consider this:
19:26:25 <scodil> i'm with _phobes on that point: stack overflows are a bitch
19:26:28 <ac> I have some code that works fine in GHC, but produces a garbage collection error in hugs. I'm wondering if I'm doing something incorrectly, or if hugs is doing something incorrectly
19:26:37 <Cale> scodil: They're a bitch in strict languages too.\
19:27:17 <scodil> oh come on. why then is there a wiki page all about how to deal with them in a lazy language?
19:27:34 <Cale> scodil: Because sometimes beginners don't know how to do it.
19:27:35 <_phobes> If I have g :: Nat -> Nat, and I write a function f (n::Nat) = g (n-1), it's not clear whether that's type safe in a lazy language
19:28:02 <hpaste>  ac pasted "GHC fine, Hugs not fine" at http://hpaste.org/4708
19:28:10 <dibblego> because Haskell users are helpful (why isn't there a wiki page on how to do it StrictLanguageX?)
19:28:11 <_phobes> In a strict langauge, it's clear that it isn't type safe, because (n-1) will be evaluated, and therefore could be evaluated at 0
19:28:26 <Cale> _phobes: It clearly is type safe.
19:28:37 <Cale> In either language.
19:28:46 <mdmkolbe|work> _phobes: if Nat == >0, then it clearly isn't type safe in either language
19:28:48 <EvilTerran> blub is a strict langauge ;)
19:28:49 <_phobes> Cale:  Perhaps if Nat is closed under -
19:28:51 <Cale> Unless you're talking about some kind of dependently typed language.
19:28:59 <_phobes> Cale:  I am
19:29:04 <ac> any suggestions on how to improve that?
19:29:05 <Cale> (in which case, that's not an appropriate type for n)
19:29:06 <dibblego> @remember <EvilTerran> blub is a strict langauge ;)
19:29:06 <lambdabot> Done.
19:29:09 <mdmkolbe|work> _phobes: Haskell isn't dependantly typed
19:29:20 <_phobes> I understand
19:29:20 <Cale> Nor is O'Caml.
19:29:27 <EvilTerran> damnit, why can i never spell "language" right? i always get it wrong in the pragma, too :(
19:29:35 <dibblego> or dependently
19:29:45 <dibblego> er, not you
19:29:57 * EvilTerran pokes dibblego with a sharp stick
19:30:00 <_phobes> My point is that it aids in reasoning
19:30:18 <mdmkolbe|work> _phobes: reasoning about what?
19:30:20 <EvilTerran> _phobes, to you, maybe. not to me, or anyone else who's spent enough time working in non-strict languages
19:30:33 <EvilTerran> we find that non-strictness aids reasoning
19:30:35 <dibblego> _phobes, that's an ad hominem in disguise
19:31:22 <EvilTerran> "aids reasoning" is relative
19:31:49 <ballzack3> Why does ghci complain when I try to define functions in it, but not if it imports them when I double-click on .hs file?
19:31:49 <dibblego> there are people at my work who think 1000 lines of Java is "definitely easier to read" than my one line of Haskell, even though I know Java far better than they do and I dispute their claim
19:32:20 <Cale> _phobes: In strict languages, you have to care when certain operations will create data structures which are combinatorially large, even when you're only interested in a little bit of the structure. You end up turning programs inside out in order not to generate any more data than you'll need.
19:32:32 <mdmkolbe|work> _phobes: you can always reason about a lazy program correctly (modulo termination), using a strict model.  (In fact I suspect that is what most do and only think about lazyness when nessisary)
19:32:49 <ac> btw, hugs says "Garbage collection fails to reclaim sufficient space". What does that mean anyway? The program doesn't even take very much memory
19:33:08 <mdmkolbe|work> ac: what was the link again
19:33:09 <mdmkolbe|work> ?
19:33:30 <EvilTerran> I feel most at home amoung grand towers of logical axioms and greek symbols; for me, gratuitous rigour often "aids reasoning"
19:33:30 <Cale> Of course if you want to understand performance, you have to use your lazy model of reasoning, but it's really not much harder at all.
19:33:35 <ac> mdmkolbe|work: http://hpaste.org/4708
19:33:36 <ballzack3> dibblego, I'm curious what that one line is.
19:34:06 <dibblego> ballzack3, nothing difficult
19:34:11 <EvilTerran> contrariwise, my grandfather (who was a mathematician) had a reputation for his knack for using natural language in his proofs
19:34:13 <scodil> getContents
19:34:22 <EvilTerran> *that* aided *his* reasoning
19:34:43 <ballzack3> dibblego, I'm new to Haskell, just wanted to see, not doubting you
19:34:58 <Cale> There is just one more thing you have to remember about functions: you have to remember approximately how much of their input they'll consume in generating each part of their output. Usually this is something obvious, and sometimes it's slightly more complicated, but it's also what gives you the additional composability of programs.
19:35:13 <dibblego> ballzack3, I wasn't thinking of any line in particular; just the usual "here I'll write it in Java for you so you can see what I am doing; oh look, it's 1000 lines"
19:35:21 <ballzack3> haha ok
19:35:30 <JFT> ballzack3: ghci only let you enter "one liners"
19:35:32 <dibblego> ballzack3, then the response of "oh, that's much easier to read" is the one that bamboozles me
19:35:41 <ballzack3> haha bamboozles
19:35:42 <_phobes> Cale:  That's the thing I don't like - the hidden "how much does this consume" .   Understanding whether or not a given "tying the knot" trick works isn't trivial
19:35:53 <Cale> ballzack3: I've written 600 lines of Haskell code which would have been 15000 lines of C, according to an expert C programmer :)
19:35:54 <JFT> ballzack3: and to define function in ghci you need to start by "let f = ..."
19:36:03 <mdmkolbe|work> ac: (1) do you know which call triggers the heap overflow, (2) can you increase the heap size in Hugs?
19:36:07 <EvilTerran> > nubBy (((0==).).flip mod) [2..] -- how's this for one line of haskell?
19:36:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:36:14 <ballzack3> hugs lets you enter functions more freely?
19:36:25 <dibblego> ballzack3, I wrote a rant recently about repeating yourself in languages such as Java; I can send you a link
19:36:29 <ac> mdmkolbe|work: I have not used hugs until today basically. I'll look in to such experimentation
19:36:31 <Cale> _phobes: It's better than deciding that the answer is always "it's impossible".
19:36:32 <JFT> ballzack3: I never work with hugs so I wouldn't know :P
19:36:35 <EvilTerran> let's see you do that with an arbitrary-length integer library in Java :P
19:36:35 <ballzack3> dibble please
19:36:39 <ballzack3> jft ok thanks
19:36:49 <dibblego> ballzack3, http://blog.tmorris.net/whats-it-like-to-use-those-languages/
19:36:50 <lambdabot> Title: λ Tony&#8217;s blog λ  Blog Archive  What&#8217;s it like to use those langu ...
19:36:55 <mdmkolbe|work> _phobes: going strict certainly solves that problem.  in a strict language the answer to "can I tie this know" is "no". </sarcasm>
19:37:07 <_phobes> Cale:  Again, if it works, a "lazy" annotation can be added that makes it more explicit why
19:37:14 <ballzack3> dibble cool, i saw that from reddit or digg
19:37:26 <Cale> _phobes: So why not have strict annotations instead?
19:37:56 <Cale> _phobes: Then the assumption is that you'll be making use of laziness, unless the strictness annotation is there.
19:38:23 <_phobes> Cale:  Because evaluation order - one way or the other - should be implentation detail.  By assuring the programmer lazy semantics, you are limiting your implementation options
19:38:53 <_phobes> Cale:  And I believe that when the programmer is actually relying on lazy semantics for correctness, the code will be clearer with annotations
19:39:14 <Cale> Well, okay, non-strict semantics, lazy evaluation isn't what's necessarily important.
19:39:35 <_phobes> sure, that's what I meant by "lazy semantics" :)
19:39:35 <Cale> (Though it's certainly better than a lot of other techniques for implementing non-strict semantics.)
19:40:23 <Cale> Strict semantics are perversely restrictive though.
19:40:24 <_phobes> By semantics I meant "what laziness gaurantees for program results"... there are other implementations
19:40:28 <fnord123> is strictness often required when interfacing with ffi? I'm reading some code that uses OpenGL bindings and there are strict function args all over the place.
19:40:54 <mdmkolbe|work> _phobes: when tieing a complicated knot, I want everything lazy. I don't want to think about which are really needed.
19:40:58 <Cale> fnord123: Yes, because C functions generally want actual values.
19:41:05 <ac> mdmkolbe|work: I increased the heap to 10 megs. It crunched for a minute or two this time and then seg faulted
19:41:22 <Cale> fnord123: Or are you seeing strictness annotations?
19:41:30 <ac> mdmkolbe|work: GHC executes it with barely a pause
19:41:31 <_phobes> mdmkolbe|work:  I would argue that you are implicitly thinking about which are needed ... ie. why is this going to terminate
19:41:33 <Cale> fnord123: (that would be kind of strange)
19:41:34 <mdmkolbe|work> ac: do you have heap useage info from GHC
19:41:51 <mdmkolbe|work> ac: i think it's ":set +s"
19:41:52 <fnord123> doesn't the ffi have to put it through an io monad and hence the values will have to be evaluated.. I see strictness annotations.
19:42:04 <fnord123> fun !arg = ...
19:42:09 <_phobes> Cale:  Strict semantics are perversely restrictive?
19:42:15 <Cale> _phobes: yes.
19:42:16 <EvilTerran> _phobes, so? we're all implicitly thinking about things all the time
19:42:29 <mdmkolbe|work> _phobes: if I write it without thinking and it termiantes, then I'm generally happy, I don't have to think about why
19:42:40 <Cale> _phobes: They often force you to turn your whole program inside out.
19:42:52 <EvilTerran> in a pure functional context, every program that works under strict semantics also works under non-strict
19:43:00 <EvilTerran> not vice-versa
19:43:02 <scodil> fnord123: no you can declare foreign functions to be pure. The opengl strictness annotations are just optimization I think, because none of the actual C opengl functions are exported. there's a thin wrapper, and that wrapper is strict
19:43:06 <mdmkolbe|work> ac: you could try using GHC's memory use to guide how much Hugs may need (times a small constant)
19:43:08 <_phobes> mdmkolbe|work:  Like if you have an off by one error and so you add +1 to something and it goes away ; )
19:43:21 <_phobes> mdmkolbe|work (hey, that seemed to fix it - I'm happy!) ;)
19:43:24 <EvilTerran> .'. strict semantics are restrictive, \box
19:43:25 <EvilTerran> :P
19:43:38 <fnord123> scodil: that's what i thought. but i wasn't sure if there was a fun gotcha I was going to run into
19:43:56 <mdmkolbe|work> _phobes: that example is a semantic error, strictness errors are a different class
19:43:59 <_phobes> Cale:  Are you sure that's not just because you don't have the non-strict datatypes that you want to use?
19:44:11 <Cale> fnord123: It might be that some of the annotations are actually unnecessary.
19:44:17 <_phobes> Cale:  ie you want to pass streams around and use them as "abstract loops"
19:44:47 <EvilTerran> ooh, i can hear the scorn in your voice
19:44:55 <Cale> _phobes: In strict languages with lazy options, the library maintainers hardly ever maintain two copies of the libraries for strict and lazy computation, and guess which default they go with?
19:44:57 <ac> mdmkolbe|work: am I doing anything stupid building that tree?
19:45:02 <fnord123> thanks for the affirmation. :)
19:45:27 <_phobes> Cale:  exactly... which is why IMO the real problem is in generic strategies
19:45:28 <glen_quagmire> how can I print many spaces for nice formatting?
19:45:33 <Cale> _phobes: There's hardly any point in having the ability to do lazy computation if your libraries are strict.
19:45:36 <glen_quagmire> in python i can do " " * n
19:45:40 <_phobes> Cale:  Though lists should always be finite - streams infinite
19:45:41 <mdmkolbe|work> _phobes: e.g. I "know" that a knot-ed evaluator will be lazyness correct, but I don't want to write down why it is lazy each time I write an evaluator
19:45:50 <Cale> _phobes: that's not necessarily true.
19:45:58 <EvilTerran> _phobes, consider this: you're in a channel for a lazy language, arguing that laziness is the wrong default behaviour.
19:46:01 <Cale> _phobes: I've done a lot of work with finite, but combinatorially large lists.
19:46:03 <_phobes> Cale:  No argument on that... but I think the problem is in the inability to write nice generic libraries
19:46:05 <EvilTerran> glen_quagmire, replicate n " "?
19:46:16 <EvilTerran> glen_quagmire, also look at HughesPJ
19:46:29 <_phobes> Cale:  I said Lists should be finite - not strict :)
19:46:39 <ballzack3> phobes likes to paddle upstream
19:46:41 <mdmkolbe|work> ac: I don't see anything (but then again I probably woudn't unless you could focus where the error is)
19:46:44 <EvilTerran> ?go hughespj
19:46:45 <lambdabot> http://haskell.org/ghc/docs/6.2.2/html/libraries/base/Text.PrettyPrint.HughesPJ.html
19:47:06 <glen_quagmire> EvilTerran: thanks
19:47:10 <EvilTerran> :)
19:47:19 <EvilTerran> er, btw, that should be (replicate n ' ')
19:47:25 <Cale> _phobes: That's basically the same thing, is it not?
19:47:28 <ac> mdmkolbe|work: thanks for looking at it :)
19:47:31 <glen_quagmire> yup
19:47:47 <_phobes> Cale:  No, again laziness is an implementation issue (evaluation order) - finiteness is semantics
19:47:50 <Cale> _phobes: How else do you intend to force them to be finite? Prove it externally?
19:48:19 <_phobes> Cale:  How do you intend to prove the monad laws hold in haskell?
19:48:38 <Cale> There's a place here between implementation and semantics where because the list is so large, evaluating it strictly is stupid.
19:48:50 <_phobes> With finite lists you can at least verify that finiteness holds in many cases by using a simple induction structure
19:48:54 <Cale> Even though the computation will theoretically terminate.
19:49:27 <_phobes> Cale:  But again, with strict semantics, you could have a lazy implementation
19:49:33 <Cale> Well, sure, but you want to put that in the type system?
19:49:38 <_phobes> And if performance is a problem than you probably should
19:49:46 <EvilTerran> Events.sleepUntil(Events.Cosmic.HeatDeath)
19:49:55 <_phobes> Cale: Yes, I want that in the type system... I just want a weak type system :)
19:50:01 <Cale> I don't understand why you'd want strict semantics there though.
19:50:04 * EvilTerran does the funky premature optimisation dance
19:50:08 <dibblego> I ran a Scala training course for Red Hat/JBoss last year and I'm running it again in two weeks; yippee!!
19:50:17 <EvilTerran> constant! factors! whee!
19:50:19 <Cale> Why artificially restrict your lists to be finite if you're not going to evaluate them strictly?
19:50:22 <ballzack3> Scala looked cool
19:50:29 <_phobes> Cale:  Because lists are finite :)
19:50:31 <ballzack3> My dog loves baby carrots
19:50:36 <Cale> Not for me.
19:50:40 <EvilTerran> no true scotsman fallacy!
19:51:03 * Cale is a greatest fixed point sort of person.
19:51:23 <EvilTerran> (incidentally, i know plenty of true scotsmen who wear underwear with their kilts. it'd be mad to do otherwise with the sort of weather we get.)
19:51:31 <_phobes> Cale:  Well I'm not just arguing definitions... I'm saying there is a useful concept for a list datatype which has a length and for which induction holds
19:51:32 <hpaste>  mdmkolbe|work pasted "Does this gensym implementation look right?" at http://hpaste.org/4709
19:51:40 <_phobes> Cale:  and I propose it should be called List
19:51:49 <mdmkolbe|work> Does this gensym implementation look Ok?  (It passes my smoke tests.) http://hpaste.org/4709
19:51:50 <merus> That's not arguing definitions?
19:51:53 <_phobes> Cale:  and stream is codata
19:51:58 <Cale> _phobes: Of course, infinite lists have a length too ;)
19:52:21 <_phobes> Cale: And that length shall be a natural!
19:52:29 <Cale> It just sometimes happens to be _|_, depending on what type of numbers you're using.
19:52:39 <Cale> Or infinity = Succ infinity
19:52:41 <_phobes> Cale:!!! And _|_ shall NOT be a natural!
19:52:51 <Cale> It's a member of every type :)
19:53:10 <mdmkolbe|work> _phobes: _|_ is a member of every type
19:53:16 <mdmkolbe|work> _phobes: even in strict languages
19:53:17 <_phobes> In haskell it is :)
19:53:39 <EvilTerran> even in strict languages
19:53:40 <_phobes> True, in other strict languages it is
19:53:43 <Cale> If you want to avoid nontermination altogether, goodbye Turing completeness.
19:53:43 <scodil> in #haskell it is
19:53:44 <EvilTerran> a function may error out
19:54:00 <_phobes> Cale:  I said I wanted a weak type system already, right?
19:54:07 <mdmkolbe|work> "x () = 1::Int + x ()" has type "Int", but is _|_
19:54:11 <ballzack3> So use Lisp
19:54:21 <_phobes> I said weak, not non-existant
19:54:32 <mdmkolbe|work> _phobes: lisp has a type system
19:54:32 <dibblego> *non-existent
19:54:33 <Cale> Weak in which sense?
19:54:37 <_phobes> or semantically baseless
19:54:45 <mdmkolbe|work> _phobes: it has a semantics
19:55:00 <mdmkolbe|work> _phobes: it's just checked at runtime
19:55:01 <_phobes> ok I don't know much about it ... I should look it up
19:55:09 <_phobes> oh ok, well I don't want that either
19:55:29 <_phobes> I want types = compile-time assertions about my code that I may or may not be able to prove
19:55:35 <mdmkolbe|work> (car ()) is a "type error" in scheme (which I know better than lisp)
19:55:54 <Cale> _phobes: but surely you want the compiler to actually check them?
19:56:02 <mdmkolbe|work> _phobes: you want a *static* type system.
19:56:03 <_phobes> Ah well, runtime "types" aren't types anyway :)
19:56:04 <Cale> _phobes: otherwise, you might as well be using comments.
19:56:10 <mdmkolbe|work> _phobes: yes, they are types
19:56:13 <EvilTerran> Cale, it can make quickcheck properties automagically ;)
19:56:28 <_phobes> mdmkolbe|work:  Not according to many type theorists!
19:56:47 <Cale> mdmkolbe|work: I'll agree with him on that one :)
19:56:52 <mdmkolbe|work> _phobes: I reject that proof by unsourced authority
19:57:03 <_phobes> I cite Cale!
19:57:42 <Cale> Types are statements about the code which are proved by the compiler.
19:57:47 <_phobes> Cale: I want the compiler to check as many as it can, and let me know which it can't verify
19:58:03 <Cale> _phobes: How do you stand on type inference?
19:58:08 <mdmkolbe|work> Cale: if that were true then the term "dynamic type" would be meaning less
19:58:13 <EvilTerran> Cale, with both feet :D
19:58:15 <_phobes> I'm happy to have a core type system which forms an algebra, is used for representation selection, and is safe
19:58:21 <Cale> mdmkolbe|work: of course, it almost is ;)
19:58:44 <mdmkolbe|work> _phobes: types ensure that you can't do invalid operations on values ("programs don't go wrong").  dynamic types meet that definition. thus they are types.
19:58:47 <_phobes> Cale:  Type inference should be able to pick up the core algebraic types
19:58:51 <EvilTerran> oh, look. 4am.
19:59:08 <Cale> Dynamic types are only slightly better than no types at all. You still have all the possibilities for going wrong, you just don't screw up memory when you do it.
19:59:11 * EvilTerran goes to bed
19:59:35 <mdmkolbe|work> Cale: which is the sort of "go wrong" that is meant in that definition
19:59:44 <_phobes> mdmkolbe|work:  Now *this* is just definitions... I'm happy to go with "static types" and "dynamic types"
20:00:19 <Cale> mdmkolbe|work: They don't ensure that the programs can't go wrong though. You can perform operations which are type-incorrect, and the program dies.
20:00:44 <mdmkolbe|work> _phobes: I won't dissagree with the assersion that "static types are better than dynamic types" or "dynamic types aren't good for much".  I just dissagree with the assersion that "dynamic types aren't types"
20:00:52 <_phobes> Cale:  One thing I definitely do not want is two versions of Natural defined... once as values and then again as types just so that I can shoe-horn the type system version into a provably correct version the dumb compiler can verify
20:01:20 <Cale> I'm not sure I mind that so much.
20:01:22 <mdmkolbe|work> Cale: early program termination isn't "going wrong".  e.g. heap exhausion
20:01:42 <_phobes> mdmkolbe|work:  I never actually asserted that they weren't types.... it's obviously just a terminology issue and I was just stating that many type theorists only consider the static ones types
20:01:44 <Cale> I'm not talking about things like running out of memory
20:02:18 <Cale> I'm talking about writing things like 1 + "hello", and not having the compiler catch the mistake until the code is actually run.
20:02:21 <_phobes> Arithmetic in the compiler is terrible and wrong
20:02:28 <_phobes> err, in the type system
20:02:48 <bos> _phobes: not at all
20:02:57 <_phobes> The implementatoin of that probably being a urnary representation of your natural with something like 1K of data per tick
20:03:06 <Cale> Dynamic types just give you prettier error messages when the program fails. They don't help it not to fail.
20:03:18 <mdmkolbe|work> Cale: again it may not be as usefull, but if you allow the implementation the liberty of early program termination in your "type safe" program, then you have to allow early program terminateion to be "not going wrong".
20:03:43 <_phobes> Vec ONE_THOUSAND AND TWENTY   ... beautiful notation that takes the compiler 1Meg to store
20:04:26 <mauke> > 1 `div` 0
20:04:26 <lambdabot>  Exception: divide by zero
20:04:48 <mdmkolbe|work> mauke: heh, I like that example
20:05:01 <_phobes> As soon as you concede that compile type computation that affects types is interesting, you have to stop and realize that your type system is uglier than almost any other language
20:05:26 <Cale> mdmkolbe|work: Well, then it's like your language has just one type, and any operations which would otherwise be not-type-safe, just result in _|_
20:05:36 <Cale> That's not helpful.
20:06:06 <bos> _phobes: don't be so silly. computations on types have practical uses.
20:06:28 <mdmkolbe|work> Cale: again I'm not arguing whether it's helpful, just whether it is a type system
20:06:28 <_phobes> bos:  I know they do... which is why I want to do them in a real language
20:06:44 <Cale> _phobes: this is a problem which is being worked on. The prolog-esque type-level computation stuff is being replaced with a more functional-language like approach.
20:06:46 <bos> the real language being ... ?
20:07:07 <_phobes> bos:  The same one I use to compute with values!!
20:07:24 <bos> ah. come back in a few decades, then.
20:07:27 <Cale> mdmkolbe|work: The dynamic types basically aren't doing their job as types in the way that I've described it there.
20:07:50 <Cale> _phobes: Perhaps you'd like to update/maintain Cayenne.
20:07:51 <_phobes> bos:  It's not that hard of a problem unless you insist on trying to have the compiler prove everything
20:08:11 <mdmkolbe|work> Cale: but they are in terms of keeping the program from "going wrong"
20:08:36 <Cale> mdmkolbe|work: No they're not. It's as if they're all the same type.
20:09:30 <mdmkolbe|work> Cale: actually the scheme folks would say there are multiple types.  one for pair, one for null, one for char.
20:09:31 <_phobes> Cale:  The thing is... I care almost nothing about the quality of the proof the compiler can give.  I'm not looking for Coq
20:09:53 <Cale> mdmkolbe|work: Does the compiler check those?
20:09:58 <_phobes> mdmkolbe|work:  the point of all of this is that the scheme folks use "type" differently than the type theorist
20:09:58 <Cale> (at compile time)
20:09:59 <mdmkolbe|work> Cale: but those types are only checked by those operations that need to care about them
20:09:59 <bos> _phobes: so other people have different goals from you. nothing wrong with that.
20:10:26 <mdmkolbe|work> _phobes: if by "type" you mean "set of values", then schemers use type more like a type theorist actually
20:10:47 <_phobes> mdmkolbe|work:  lol, no, by type I mean "type"
20:10:58 <mdmkolbe|work> _phobes: Error: *loop*
20:11:27 <_phobes> mdmkolbe|work:  I know, but I mean "type, as defined by type theorists"
20:11:49 <Cale> By "type", I mean a statement about the code which is checked by the computer before the first line of code gets run. Of course, this completely ignores things like type-directed programming, but I think that's possible to ignore for now :)
20:11:52 <_phobes> A type being something like a proposition in a logic... not a set of values
20:12:14 <Cale> A proposition with a free variable is kind of like a set ;)
20:12:21 <mdmkolbe|work> Cale: that is the definition of "static type" not of "type"
20:12:29 <_phobes> Cale:  Yes :)
20:13:05 <Cale> mdmkolbe|work: If it's checked only after the program is running, then there's typically nothing which can be done to prevent the program from going wrong.
20:13:15 <mdmkolbe|work> _phobes: the types in scheme meet that definition if you move to higher order logics
20:13:49 <mdmkolbe|work> Cale: By that argument haskell doesn't have types because of "x `div` 0"
20:13:50 <Cale> mdmkolbe|work: Once the problem is detected, it's too late. The program is going to die, because the programmer is gone.
20:13:54 <_phobes> bos: I overstated my disinterest... I actually do think work on theorem proving is great  -  I just have a slightly different balance of trade-offs than what currently seems to be hot
20:14:00 <Cale> mdmkolbe|work: That's not what I'm saying.
20:14:15 <mdmkolbe|work> Cale: but it is, just alpha rename your argument
20:14:16 <Cale> mdmkolbe|work: I'm saying that dynamic types don't act like separate types.
20:14:37 <Cale> If I have dynamic types S and T, and an operation T -> T
20:14:42 <Cale> and I give it an S
20:14:49 <mdmkolbe|work> Cale: no one said, types have to be separate.  ever heard of the F-<= type system?
20:14:52 <Cale> then it will fail at runtime
20:15:09 <_phobes> You can have subtyping
20:15:22 <Cale> and there's nothing which can be done about it, because the programmer is missing by then.
20:15:22 <_phobes> If S<: T, that would work :)
20:15:23 <mdmkolbe|work> Cale: or type systems with subtyping
20:16:03 <Cale> mdmkolbe|work: I'm saying that in any dynamic type system, all the "types" act as the same type.
20:16:24 <mdmkolbe|work> Cale: no, they act as differnt types, with a "union" type capability
20:16:32 <Cale> sigh
20:16:43 <Cale> Things which should have been type incorrect, are instead permitted, and end up being defined as _|_
20:17:32 <Cale> So regardless of how many types your dynamic type system has, or their relationship to one another, programs are never prevented from going wrong.
20:17:56 <Cale> Because type incorrect programs only notice the problem too late for the programmer to do anything about it.
20:17:58 <mdmkolbe|work> Well then I'll just say that x `div` 0 should be type incorrect.  Instead it is permitted and is defined a _|_.  (Some dependant type people would actually argue that.)
20:18:05 <Cale> Well, sure.
20:18:11 <_phobes> You're right
20:18:19 <Cale> You can say that, but you can't make the argument which I'm making with regard to Haskell.
20:18:21 <mdmkolbe|work> Thus by your argument, Haskell doesn't have types.
20:18:27 <Cale> No.
20:18:33 <mdmkolbe|work> > 3 `div` 0
20:18:34 <lambdabot>  Exception: divide by zero
20:18:49 <mdmkolbe|work> Ah, the program "went wrong" there are no types
20:18:52 <Cale> In Haskell, you can have type incorrect programs *which are caught before they run*
20:19:17 <_phobes> Not "every incorrect program is caught before it's run"
20:19:25 <_phobes> Just some
20:19:31 <mauke> keys @foo  # doesn't compile
20:19:36 <Cale> If I have a function of type T -> T, and I pass it a value of type S, then that's not a runtime error.
20:19:42 <_phobes> be back in a bit
20:19:48 <Cale> It's not _|_
20:20:04 <Cale> The program simply doesn't compile.
20:21:05 <mdmkolbe|work> Cale: "(define-syntax foo (lambda x (syntax-case (/ 2 0)))" scheme will catch that type error at compile time ;-J
20:21:06 <Cale> In a dynamically typed system, it's as if those types were compatible, right up until the point where the application actually evaluates, and ends up evaluating to _|_.
20:21:46 <Cale> So they might as well have been the same type.
20:22:06 <Cale> (and the function simply defined to be an error for that value)
20:22:22 <Cale> Do you get what I'm saying?
20:22:48 <mdmkolbe|work> I think I do, but I think you are wrong.
20:24:05 <Cale> My definition of "not going wrong" is a little stronger than "doesn't corrupt memory"
20:24:25 <mdmkolbe|work> (I hope you are taking this in good humor.  I like to argue sometimes for the sake of arguing.  (Though I still think I'm right about this one.))
20:24:58 <mdmkolbe|work> Cale: how do you exclude x `div` 0 from "going wrong" but include (car '())?
20:25:20 <Cale> Those can both be type correct for all I care.
20:25:42 <mauke> the trick is (car 0) and x `div` []
20:25:43 <mdmkolbe|work> and (car 1)?
20:26:07 <Cale> Depends on the type system in question.
20:26:18 <mdmkolbe|work> remember that pairs and nulls are not considered the same type.  (In haskell they are, but you can't make that assumption in Scheme)
20:26:57 <mdmkolbe|work> the way a scheme program goes wrong in (/ 2 0) and (car '()) and (car 1) are exactly the same
20:27:09 <Cale> Consider a language which is rather like a stripped down Haskell, with a dynamic type system instead.
20:27:40 <Cale> and suppose, just for simplicity, that (+) :: Integer -> Integer -> Integer
20:27:50 <mdmkolbe|work> Cale: don't assume a constructor belongs to only one type
20:28:16 <Cale> mdmkolbe|work: Uh, I don't see how that assumption applies to anything which I've said.
20:29:00 <Cale> Look at the program  main = print (1 + "a"), which has a type error in it.
20:29:14 <mdmkolbe|work> Maybe I guessed where you were going wrong, but in such a language you would want "data * = []; data * = * : *' instead of 'data List = [] | * : *'
20:29:15 <Cale> In statically-typed Haskell, this is not a program.
20:29:29 <Cale> It can't be run.
20:29:37 <Cale> Hence, semantics are not even an issue.
20:29:58 <Cale> In dynamically typed Haskell, this is a program.
20:30:04 <mauke> :t 1 + "a"
20:30:05 <lambdabot>     No instance for (Num [Char])
20:30:05 <lambdabot>       arising from the literal `1' at <interactive>:1:0
20:30:05 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
20:30:07 <Cale> 1 + "a" evaluates to _|_
20:30:28 <Cale> and then print _|_ of course is _|_ as well
20:30:45 <Cale> perhaps it should have been putStrLn
20:30:50 <mdmkolbe|work> so?  "typed" just means it is cought.  if it is static then it will be at compile type, if dynamic at runtime.
20:31:32 <Cale> In dynamically typed Haskell, the program "goes wrong" in a way which shouldn't be allowed.
20:31:59 <mrd> when good programs "go wrong": tonite at 11!
20:32:02 <Cale> It's as if all the types were the same type, and whenever a type mismatch would have occurred, the value is defined to be _|_
20:32:16 <JFT> mdmkolbe|work: if what you are programming is for fun or is a prototype beeing caught at runtime may be acceptable, when it is a production system I'll take the compilation-time anyday...
20:32:43 <mdmkolbe|work> JFT: The users of Chez would dissagree.
20:32:49 <Cale> Catching problems at runtime essentially means the same thing as not catching them.
20:33:11 <JFT> Oh I do like Scheme and Common-Lisp but I wouldn't ever bring that at work, altough I managed to bring Haskell....
20:33:31 <mdmkolbe|work> Chez = big production scheme implemtnation used by companies as big as disny (official list isn't public)
20:33:34 <Cale> Because by that time, your program is very likely not in the hands of a programmer who can do something about it.
20:33:46 <JFT> mdmkolbe|work: I know Chez
20:34:04 <JFT> Cale: exactly
20:34:11 <Cale> also, the program may have been running a long time
20:34:30 <Cale> even if a programmer is around, you may have just wasted a month on some computation.
20:34:32 <mdmkolbe|work> Cale: that is an argument of usability which I have never dissagreed with.  the question is whether it is still a type system
20:34:38 <loupgaroublond> in the instance syntax, say i have a class QueryPredicate a b c, and i want an instance Query any Bool Bool, how would i declare 'any' ?
20:34:59 <Cale> I'm saying that if it's a type system, it effectively has only one type, regardless of how many types it purports to have.
20:35:01 <JFT> moreover the worst problem with Dynamic Typing is that it requires disciplines from all programmer touching the codebase, and that in any sizeable team is an issue...
20:35:06 <mdmkolbe|work> loupgaroublond: make "any" start with a lower case then it is a type var
20:35:26 <Cale> Because the program still crashes when types mismatch.
20:35:34 <loupgaroublond> mdmkolbe|work: thanks
20:35:54 <Cale> Which I suppose is slightly better than not crashing and just giving an erroneous result, but not by much.
20:35:54 <mdmkolbe|work> Cale: I disagree with that, but won't argue it if you condeed that dynamic types are a type system
20:36:24 <Cale> You disagree that the program crashes?
20:36:59 <mdmkolbe|work> that = "it effectively has only one type,..."
20:37:16 <mdmkolbe|work> (typeing lag)
20:37:41 <_phobes> mdmkolbe|work - Note that I tried to concede that I was fine defining "type system" such that "dynamic types" applied about 20 min ago :D
20:37:50 <Cale> mdmkolbe|work: Consider all the types to be the type T of all the values in the program. Functions which formerly were defined on a single type are defined for other values as _|_
20:37:59 <mdmkolbe|work> _phobes: heh
20:38:00 <JFT> mdmkolbe|work: how about it has one type "from the compiler standpoint"... :P
20:38:04 <Cale> mdmkolbe|work: How is that any different from dynamic typing?
20:38:10 <mdmkolbe|work> _phobes: this is #haskell, we love arguing about types
20:38:21 <_phobes> Yes, but only static types :)
20:38:24 <JFT> we are of the arguing type ;)
20:38:45 <Cale> mdmkolbe|work: btw, have you read TaPL?
20:38:47 <mdmkolbe|work> argument type?
20:38:50 <mdmkolbe|work> ;)
20:38:54 <mdmkolbe|work> Cale: yes
20:39:04 <mdmkolbe|work> fav. book
20:39:24 <Cale> I'm generally subscribing to its definition of types.
20:39:35 <shapr> @yarr!
20:39:35 <lambdabot> Har de har har!
20:40:17 <nolrai> is there a way to ask if read would produce a value with out just using read and geting a crash?
20:40:28 <Cale> nolrai: reads
20:40:32 <mdmkolbe|work> well, I'm strictly adhering to the definition "doesn't go wrong".  for any meaning of "doesn't" and "go wrong" that leaves Haskell typed, scheme also meets the definition
20:40:43 <mdmkolbe|work> @type reads
20:40:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:40:52 <Cale> nolrai: You'll get a list of parses which will be empty in the case that it doesn't parse.
20:41:55 <Cale> mdmkolbe|work: You seem to be focused on the fact that some well-typed Haskell programs can go wrong, and not on the fact that badly typed Haskell programs can't go wrong because they simply won't run.
20:42:00 <_phobes> TAPL, Page 2-  The word "static" is sometimes added explicitly - we speak of a "statically typed langauge" to distinguish the sorts of compile-time analyses we are considering here from the dynamic or latent typing found in languages such as Scheme... Terms like "dynamically typed" are arguably misnomers and should probably be replaced by "dyanmically checked," but the usage is standard
20:42:47 <mdmkolbe|work> Cale: "simply won't run" has nothing to do with types, only "static types"
20:43:12 <Cale> mdmkolbe|work: Whereas if Haskell were dynamically typed, these programs would run, but fail.
20:43:40 <Cale> and they would behave exactly as if Haskell had only one type.
20:43:42 <_phobes> "arguably misnomers" seams to be spot on!
20:43:47 <_phobes> seems*
20:44:00 <Cale> yes!
20:47:02 <_phobes> So anyway, Monads are dumb, laziness is a bad default, and I still think Haskell is a pretty great language :)
20:48:06 <shapr> Er, why is laziness a bad default?
20:48:15 <shapr> And what's dumb about monads?
20:48:25 <dibblego> don't ask
20:48:31 <shapr> In my opinion, the abstraction that is monads compares favorably to the abstraction that is objects.
20:48:47 <mauke> \ is the one true abstraction
20:48:51 <_phobes> dibblego: lol
20:49:07 <shapr> _phobes: Do you have a blog post somewhere supporting those statements with some sort of unit testable numbers?
20:49:18 <_phobes> no :)
20:49:22 <shapr> Well then...
20:49:37 <_phobes> I think I have a pretty strong case for both statements though
20:50:05 <_phobes> I don't see where you logged on... so you can maybe scroll up for the summary :)
20:50:06 <shapr> I'm moving to Boston in three days, so I don't have time to discuss with you on #haskell. But I would very much like to read a blog post or other essay that makes that case.
20:50:17 <shapr> _phobes: I logged on about 6.5 years ago...
20:50:20 <_phobes>  :)
20:50:27 <_phobes> haven't left yet?
20:50:32 <cjb> shapr: cool!
20:50:34 <shapr> Well, once or twice
20:50:35 <_phobes> That's pretty amazing
20:50:38 <cjb> shapr: wow, why are you moving here?
20:50:44 <shapr> cjb: Oh HEY! I'll get to meet you finally!
20:50:48 <cjb> yup!
20:50:56 <shapr> You're still doing the XO, yeah?
20:50:59 <cjb> tell me about where you're working and staying and stuff?
20:51:00 <Cale> shapr: We spent the last few hours arguing on those points (laziness/monads/etc.)
20:51:00 <cjb> yup yup
20:51:11 <shapr> Cale: oh, sorry I missed it. maybe :-)
20:51:24 <Cale> _phobes: basically, monads are not a big deal, and they're good in that they're something which can be abstracted out of many combinator libraries.
20:51:30 <shapr> cjb: 95% chance of living in Somerville, working 45 mins north of there.
20:51:53 <cjb> shapr: cool beans.  can you tell us the company, or is secret?  Haskell job?
20:52:00 <shapr> cjb: Nah, C# job :-(
20:52:05 <shapr> But with extremely smart people
20:52:14 <shapr> And doing useful to people stuff too
20:52:50 <shapr> But my final goal is to get sufficient education to become a paper publishing academic, so I'll be back into the Haskell world.
20:52:58 <_phobes> Cale:  Monads aren't a big deal, but they're presented in the wrong way.   There is very seldom a reason for a programmer to care about determining an interesting representation for a partial sequence of instructions.
20:53:16 <shapr> _phobes: write a blog post and send me the link in an email!
20:53:18 <Cale> _phobes: I don't understand at all what you mean by that.
20:53:19 <_phobes> hehe
20:53:27 <_phobes> I don't know how to blog!
20:53:30 <cjb> shapr: Ah, proprietary software stuff, or a web service or something?
20:53:32 <ballzack3> Education? What are you, a scientologist?
20:53:36 <shapr> cjb: Yeah, pretty much
20:54:05 <shapr> ballzack3: Nah, I'm a Baptist. But I feel that education will enhance my ability to be a useful-to-humans-in-general sort of academic.
20:54:30 <shapr> ballzack3: I haven't seen you here before, are you learning Haskell?
20:54:41 <ballzack3> To some degree lol
20:54:58 <shapr> ballzack3: That's cool, are you taking a class?
20:55:12 <ballzack3> I was trying to help someone from another programming chat room
20:55:20 <ballzack3> I had an SML class before
20:55:28 <cjb> shapr: Well, I'd love to learn more about Haskell with you :)
20:55:50 <mdmkolbe|work> shapr: my interpretation of _phobes arguments is that "monads are not dumb, but the proof that they follow the laws should be for free by construction"
20:55:54 <ballzack3> Maybe I'll start writing Haskell programs. I definitely like list comprehensions
20:55:57 <Cale> Sometimes I have a hard time believing that other people actually believe in various religions.
20:56:10 <shapr> mdmkolbe|work: oh!
20:56:32 <_phobes> mdmkolbe|work:  It's really that Monads as a mathematical structure are dumb
20:56:39 <ballzack3> shaor what about you?
20:56:45 <Cale> _phobes: the proof that the monad laws work is often nearly trivial.
20:56:48 <shapr> ballzack3: Yeah, there's lots of cool stuff in Haskell. Many languages have cool features that are rarely found in other languages (I like Joy, PostScript, and so many more!).
20:56:49 <_phobes> in that it isn't an interesting structure for programmers
20:57:00 <shapr> Er, how so?
20:57:00 <Cale> _phobes: so I wouldn't let it bother you so much
20:57:04 <shapr> It's really interesting to me.
20:57:07 <_phobes> Cale:  Only because people work with trivial Monads
20:57:24 <shapr> From my viewpoint, monads are a far more compositional abstraction than objects or prototypes.
20:57:25 <Cale> Well, they're nontrivial with regard to the work that they do for us.
20:57:30 <ballzack3> I wrote a java postscript converter.  I think my teacher had a hard on for eps.
20:57:31 <_phobes> shapr:  Agreed
20:57:43 <_phobes> shapr:  Anything with mutable state is a non-starter
20:58:03 <mdmkolbe|work> _phobes: err ... I thought your construction was about producing monads
20:58:03 <shapr> I like that viewpoint, but that sort of background info would be in a blog post :-)
20:58:16 <shapr> Anyway, I should get back to packing...
20:58:17 <cjb> shapr: Drop me a mail when you're settled in, btw?
20:58:24 <Cale> _phobes: The reason that they're interesting to us as programmers is that lots of combinator libraries actually happen to be monads. Once that's recognised, you get all the stuff in Control.Monad for free, rather than having to code it separately for each library.
20:58:45 <ballzack3> combinator libraries???
20:58:45 <Cale> That's the whole point. Sharing of control structured in embedded DSLs, essentially.
20:59:02 <_phobes> Cale:  I'm going to look at Control.Monad more carefully to make sure all that stuff goes through
20:59:06 <_phobes> I'm pretty sure I'd still get all of that
20:59:10 <_phobes> at least most of it
20:59:18 <shapr> ballzack3: Yeah, you'll love combinator libraries :-) Check out the parsec tutorial!
20:59:26 <Cale> ballzack3: Libraries whose API follows a pattern of giving you simple computations together with ways to compose those computations into larger ones.
20:59:53 <Cale> _phobes: There are lots of other abstractions which people are using, not just monads.
20:59:57 <ballzack3> whars teh parsec tutorial?
21:00:06 <Cale> _phobes: For example, have a look at applicative functors, and arrows.
21:00:11 <Cale> As well as comonads.
21:00:12 <_phobes> Cale:  I know
21:00:48 <JFT> ballzack3: Parsec is a PARSEr Combinator library, monad
21:00:49 <Cale> In each case, the point is the same, to be able to pull out the relevant control structures and syntax and share them between libraries.
21:01:04 <ballzack3> Like Lisp macros?
21:01:08 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
21:01:12 <JFT> ballzack3: Not really
21:01:26 <_phobes> Cale:  But I think the thing people use the Monad abstraction for they don't really need Monads
21:01:30 <_phobes> most of the time
21:01:31 <ballzack3> damn, why do the links in here not open in a new tab on my browser?
21:01:57 <JFT> ballzack3: basically you build larger parser by combining smaller parser
21:01:58 <_phobes> Namely, the typical pattern is that you want to do a bunch of operations in a sequence and get a result out
21:02:06 <Cale> _phobes: You never *need* the monad abstraction, you *want* it.
21:02:19 <ballzack3> like how people wanted to make programming a snap-the-pieces-together thing with OOP?
21:02:21 <_phobes> Why do you want it?
21:02:33 <Cale> Because you get things like mapM and sequence and filterM and stuff for free.
21:02:40 <JFT> ballzack3: in a way yes, Monad allows you to do it more simply.
21:02:55 <Cale> Rather than starting from scratch.
21:03:07 <JFT> ballzack3: you could say that the "lego" interface is a monad :P
21:03:14 <ballzack3> :)
21:03:32 <Cale> It's not *that* big of an inconvenience to ignore the possibility that your interface is a monad, but it's nice when you recognise it.
21:04:01 <mdmkolbe|work> JFT: well it's the lego interface that Haskell has chosen to focus on. Others are possible, but monads are a very good one to choose.
21:04:05 <conal> Monad is a pattern that comes up often, with a variety of types.  There are lots of other patterns.  Each is captured in a type class.  Formalizing those patterns allows definition of some pretty general building blocks.
21:04:16 <_phobes> Cale:  Any interface where you have a box, and you send in a bunch of commands to that box, and then get a result out corresponds to a monad
21:04:31 <ballzack3> that sounds like a class!
21:04:34 <ballzack3> er, object
21:04:35 <JFT> mdmkolbe|work: I'm always curious to know of other interface but so far the monad one is the cleanest I've seen
21:04:37 <Cale> _phobes: mmm... not quite the way I'd put it, but almost.
21:04:37 <_phobes> :)
21:04:51 <dibblego> ballzack3, an object doesn't always mandate that the result is within the same type of box
21:04:52 <JFT> mdmkolbe|work: for parser at least :P
21:04:58 <_phobes> Cale:  But the standard way to define that box is totally convoluted!
21:05:09 <Cale> _phobes: No it isn't.
21:05:11 <Cale> :)
21:05:18 <_phobes> I shouldn't have to come up with a representation for a partial sequence of instructions for my box
21:05:18 <conal> for parsing, Monad is usually overkill, and Applicative suffices.
21:05:26 <Cale> It's exactly what functional programmers have been doing for years.
21:05:46 <Cale> _phobes: I don't know what you mean by that.
21:05:55 <mdmkolbe|work> JFT: well, arrows are the obvious ones, but any time you have an operation that lazilly propagates down a tree, you have a comonad.  and of course there are functors
21:06:23 <JFT> mdmkolbe|work: true but I actually prefer Monad over arrows, easier to comprehend IMO
21:06:38 <Cale> JFT: Sometimes the arrow syntax is really natural.
21:06:41 <conal> JFT: and Applicative is easier still.
21:06:47 <mdmkolbe|work> JFT: arrows haven't "clicked" for me yet, so I don't know either way
21:06:49 <Cale> But yes.
21:06:52 <JFT> conal: Applicative?
21:07:08 <ballzack3> does conal rhyme with anal?
21:07:28 <conal> JFT: have you seen the Applicative class?
21:07:30 <JFT> mdmkolbe|work: I've used HXT, so I had to use some Arrow but has soon as I'm trying to do something with conditional arrow I get loss
21:07:33 <_phobes> arrows I actually imagine as objects with inputs and outputs
21:07:33 <JFT> conal: No
21:07:45 <ac> @hoogle [Maybe a] -> [a]
21:07:46 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
21:07:56 * mauke sets mode: +troll ballzack3 
21:07:58 <Cale> JFT: The funny thing about HXT is that it's actually a monad in disguise.
21:08:00 <conal> JFT: it's a simplification of Monad.  More general.
21:08:07 <ballzack3> what's +troll do?
21:08:24 <conal> JFT: it's basically "return" and "ap" (from Monad), but renamed "pure" and "<*>"
21:08:33 <Cale> ballzack3: Presumably it marks you as a troll ;)
21:08:34 <conal> @ty Control.Applicative.pure
21:08:35 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
21:08:36 <JFT> conal: I'll check it up in GHC doc thanks for the info :)
21:08:38 <conal> @ty (<*>)
21:08:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:09:09 <conal> JFT: if you find yourself using liftM, liftM2, ... a lot, you're essentially using Applicative.
21:09:18 <JFT> conal: oh!
21:09:21 <conal> JFT: and the code looks more "applicative" / less sequential.
21:09:32 <_phobes> Cale:  How would you make an instance of Monad that supported operations 'choose' and 'setPriority' and worked through the possible results and presented them as a lazy list of values, sorted by priority?
21:09:48 <nolrai> @ty on
21:09:48 <lambdabot> Not in scope: `on'
21:10:02 <Cale> _phobes: I wouldn't set out to do that. I'd design my library first, and then see if it was a monad.
21:10:11 <conal> JFT: Applicative (like Arrow) also allows for static analysis/optimization, which Monad prevents.
21:10:21 <mdmkolbe|work> What is HXT?
21:10:37 <_phobes> Cale:  What I'm saying is... it's obviously a Monad.  It's a box that takes a sequence of instructions and produces a result
21:10:37 <JFT> mdmkolbe|work: Html Xml Toolkit
21:10:49 <nolrai> Cale: how would you tell?
21:10:53 <Cale> _phobes: However, just for interest's sake, what does setPriority do, and what is its type?
21:11:02 <conal> _phobes: i don't relate to that description of Monad either.  maybe you can clarify.
21:11:07 <JFT> mdmkolbe|work: Haskell XML Toolkit
21:11:17 <JFT> http://www.haskell.org/haskellwiki/HXT
21:11:17 <lambdabot> Title: HXT - HaskellWiki
21:11:28 <_phobes> setPriority :: SomeMonad m => Real -> m ()
21:11:42 <Cale> nolrai: I'd look and see if there were appropriate operations which looked like return and join and fmap or return and bind, and if there were, I'd check to see if they satisfied the monad axioms.
21:11:42 <dibblego> broken kinds there
21:11:51 <dibblego> oh wait, nothing
21:12:14 <Cale> _phobes: I still have no idea what it does.
21:12:26 <_phobes> it sets the priority for the branch you're currently in
21:12:39 <Cale> hmm
21:12:47 <mdmkolbe|work> Cale: I think the results from "runPriority" are sorted by the last set priority on them
21:12:48 <_phobes> It can result in "a branch switch"
21:12:54 <_phobes> if the priority goes lower than another branch
21:13:12 <Cale> what happens when the priority is set multiple times? Are the priorities multiplied?
21:13:21 <_phobes> The last priority governs
21:13:28 <_phobes> Think of it as exploring chess moves
21:13:31 <Cale> hmm
21:13:34 <_phobes> you want to think about the most promising first
21:13:51 <_phobes> You have a static evaluation function that determines which paths you recurse down
21:14:02 <JFT> _phobes: it somehow makes me think of a zipper, you set the subtree to work on based on the priority...
21:14:07 <nolrai> wouldn't you want setPriority :: Real -> SomeMonad a ->  SomeMonad a, instead?
21:14:32 <_phobes> JFT:  But you don't want to recursively set the subtree to work and forget about it... you have to keep control over the subtree in case it becomes low priority
21:14:34 <mdmkolbe|work> nolrai: that would be the reader way, but _phobes way also works, it's just more like MonadState
21:14:35 <thermo_> he's thinking like putState
21:15:12 <mdmkolbe|work> _phobes: for the first time tonight, I understand what you monad is doing, but I don't see why that is a problem
21:15:13 <_phobes> nolrai: Yes, I'm thinking of it as hidden state
21:15:30 <_phobes> mdmkolbe|work:  What's the Monad?
21:15:52 <Cale> So this would be something like  newtype M a = M [(Double, a)]
21:16:08 <mdmkolbe|work> the monad that implements setPriority
21:16:14 <Cale> Where the Double marked the priority of the elements?
21:16:33 <_phobes> Cale:  I'm guessing you'll have a very rough time making that definition into a Monad
21:17:14 <mdmkolbe|work> Cale: you'll have to keep around the operations that were not evaluated b/c another higher priority thread ran
21:17:15 <Cale> It's almost a WriterT.
21:17:46 <Cale> Well, with some additional sorting.
21:19:16 <Cale> I personally think it would be more natural to have priorities be multiplicative, but we can go with the overwriting instead if you prefer.
21:19:44 <_phobes> Well, sure... that might be more natural... this is slightly contrived
21:19:54 <_phobes> Does it make it easier to get a Monad?
21:20:09 <Cale> Well it means that we can use WriterT with an existing monoid.
21:20:10 <_phobes> That wouldn't affect my implementation
21:20:34 <_phobes> Really?
21:20:38 <Cale> Yeah.
21:20:51 <Cale> Well, almost...
21:21:03 <Cale> The order of evaluation is wrong though.
21:21:06 <_phobes> WRiterT doesn't sort... ya
21:21:11 <Cale> So you might end up redoing it to sort.
21:21:15 <_phobes> That's a big part of this I think
21:21:17 <Cale> But the code is almost the same.
21:21:33 <fnord123> brain fart time: what's an elegant way of taking an angle in radians and converting to the Cartesian quadrant. I'm thinking case angle `mod` 2*pi of something something
21:22:01 <nolrai> fnord123: arctan
21:22:02 <_phobes> case angle / (2 *pi ) mod 4
21:22:11 <_phobes> err
21:22:16 <_phobes> angle / (pi/2)
21:22:21 <_phobes> mod 4
21:22:59 <nolrai>  fnord123: sorry din't see quadrant.
21:23:15 <_phobes> Cale:  I guess I don't see it
21:23:48 <fnord123> mod needs an integer
21:24:10 <mauke> :t fmod
21:24:11 <lambdabot> Not in scope: `fmod'
21:24:20 <_phobes> or, after you divide by (pi/2), cast to int
21:24:36 <_phobes> round down
21:24:48 <mdmkolbe|work> Cale: what _phobes is describing sounds like a coperative-threading monad.  easily done, but not possible are a composition of existing monads.
21:25:05 <Cale> mdmkolbe|work: It's just a certain kind of nondeterminism.
21:25:17 <Cale> mdmkolbe|work: With sorting in an appropriate place.
21:26:08 <mdmkolbe|work> Cale: the order of evaluation is important and not representable with most non-det monads (IIUC)
21:26:27 <mdmkolbe|work> /non-det monads/non-det monad implementations/
21:27:39 <nolrai> @hoogle on
21:27:39 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:27:39 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
21:27:39 <lambdabot> Data.Function :: module
21:30:40 <nolrai> Ok, ghc is saying Data.Function dosn't exist. Where is 'on' defined?
21:30:53 <Cale> nolrai: which GHC?
21:31:03 <Cale> Data.Function is new in 6.8.x, iirc.
21:32:04 <nolrai> how does one get GHC's version again?
21:32:21 <mauke> ghc --version
21:32:28 <mauke> or run ghci
21:32:29 <Cale> _phobes: err... yeah, I think you can't make it a monad unless you do something like multiply the priorities.
21:32:43 <nolrai> ok thats it i have 6.6.1.
21:32:46 <mdmkolbe|work> nolrai: ghc --version
21:33:33 <mdmkolbe|work> @hoogle Int -> Integer
21:33:33 <lambdabot> No matches, try a more general search
21:33:47 <mdmkolbe|work> @hoogle (Num a) => Int -> a
21:33:47 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
21:33:48 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
21:33:48 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
21:34:10 <mdmkolbe|work> @djinn (Num a) => Int -> a
21:34:22 <_phobes> Cale:   hmmm
21:34:26 <_phobes> You have a proof in mind?
21:34:27 <JFT> @hoogle fromInteger
21:34:27 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
21:34:48 <mauke> :t toInteger
21:34:48 <lambdabot> forall a. (Integral a) => a -> Integer
21:34:55 <mdmkolbe|work> :t fromInteger (toInteger (1 :: Int))
21:34:56 <lambdabot> forall a. (Num a) => a
21:35:08 <mdmkolbe|work> @pl fromInteger . toInteger
21:35:09 <lambdabot> fromInteger . toInteger
21:35:13 <mdmkolbe|work> d'oh
21:35:20 <Cale> _phobes: It'll essentially be the same proof as the one for WriterT (Product Rational) [], but with sorting involved.
21:35:53 <_phobes> WriterT (Product Rational) is a particular datatype though
21:36:06 <Cale> WriterT (Product Rational) []
21:36:24 <_phobes> also I don't know what you're talking about.. I'm assuming there is some proof that it isn't a Monad?
21:36:25 <Cale> yes, and it's a monad by virtue of the fact that it's WriterT applied to a monad.
21:36:56 <_phobes> oh, I meant, do you have a proof in mind that you need to multiply priorities to get a Monad
21:37:13 <_phobes> Because I think you can do it in a Monad, regardless
21:37:22 <Cale> Well, what's the priority of return x ?
21:37:39 <mdmkolbe|work> _phobes: I'm not convinced you *need* products
21:37:52 <mdmkolbe|work> Cale: have default priority as input to "run" just like state does
21:37:55 <Cale> I think you'll lose the identity law for return if you just overwrite.
21:38:23 <Cale> You could go with something like  Maybe Double, though.
21:38:32 <Cale> hmm...
21:38:53 <ballzack3> What does the const in this mean? foldr (const (+1)) 0
21:38:57 <Cale> Basically, the priorities need to form a monoid for the monad laws to work out.
21:38:59 <mauke> @src const
21:38:59 <lambdabot> const x _ = x
21:39:17 <dibblego> ballzack3, \_ -> foo is equivalent to const foo
21:39:48 <Cale> ballzack3: const (+1) is the function which gives the value (+1), regardless of what argument it's given.
21:39:58 <ballzack3> as in positive 1?
21:40:05 <dibblego> no, that's a function
21:40:07 <Cale> No, as in the function which adds 1 to its parameter
21:40:14 <Cale> > (+1) 5
21:40:15 <lambdabot>  6
21:40:16 <ballzack3> why use const there?
21:40:19 <_phobes> Cale:  You're making the assumption about Monads that I think is usually unwarranted - That the Monad type is itself the result
21:40:23 <Cale> > const (+1) 5 10
21:40:24 <lambdabot>  11
21:40:32 <Cale> _phobes: what?
21:40:40 <dibblego> ballzack3, there are two separate issues here; that of const and the fact that a function is returned
21:40:49 <_phobes> Cale:  You're starting from the assumption that the type you want to make a Monad is the result type
21:40:53 <Cale> _phobes: You're the one who asked for a monad specifically.
21:40:56 <dibblego> > let f = const 7 in f 42
21:40:57 <lambdabot>  7
21:41:00 <dibblego> > let f = const 7 in f 43
21:41:00 <lambdabot>  7
21:41:06 <dibblego> > let f = const 7 in f 44 -- always 7!
21:41:06 <lambdabot>  7
21:41:25 <_phobes> But I don't care about intermediate results... I only want some Monad that I can run these commands through, and then when I'm done get the result out
21:41:28 <dibblego> (+1) is just a function
21:41:31 <dibblego> ?type (+1)
21:41:32 <lambdabot> forall a. (Num a) => a -> a
21:41:33 <mdmkolbe|work> Cale: you assume we are dealing with a Writer style monad.  if it is a state style monad, it won't need to be a monoid
21:42:17 <Cale> mdmkolbe|work: No, just think about it like this...
21:42:26 <_phobes> The way you use this monad might be with runMonad :: SomeMonad a -> [(Double, a)]
21:42:46 <Cale> do { v <- x; return v } == do { x }
21:42:48 <Cale> right?
21:42:56 <_phobes> You talking to me?
21:43:02 <Cale> sure, and mdmkolbe|work
21:43:03 <mdmkolbe|work> Cale: yeah
21:43:28 <Cale> So in particular, the priority of picking v's has to be preserved through return.
21:44:07 <Cale> But return only gets a value.
21:44:13 <mdmkolbe|work> Cale: IIUYC, that can be avoided by an explicit "yield" operator instead of yilding at each bind
21:44:27 <Cale> sorry?
21:44:28 <ballzack3> could I just write foldr (+1) 0 for a length function?
21:44:34 <Cale> ballzack3: yep
21:44:40 <mdmkolbe|work> Cale: there are two things you could mean
21:44:42 <Cale> > foldr (+1) 0 "hello"
21:44:43 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `Char'
21:44:52 <dibblego> const (+1)
21:44:54 <Cale> er, oops :)
21:44:57 <Cale> const (+1)
21:44:58 <Cale> yes
21:45:03 <Cale> > foldr (const (+1)) 0 "hello"
21:45:04 <ballzack3> why does it need const ??
21:45:04 <lambdabot>  5
21:45:10 <dibblego> because of the type of dolr
21:45:13 <dibblego> *foldr
21:45:14 <Cale> because you need to ignore the elements of the list
21:45:15 <ballzack3> ok
21:45:18 <dibblego> ?type foldr
21:45:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:45:31 <mdmkolbe|work> Cale: (1) Q: "how doe return know what priority v had".  A: thread the "state" of the priority through.
21:45:31 <dibblego> in a -> b -> b, the a is ignored
21:45:34 <mauke> ignore the a's, add the b's
21:45:47 <Cale> mdmkolbe|work: but there's one of those for each v
21:46:00 <dibblego> > foldr (\_ -> b -> b + 1) 0 "hello"
21:46:00 <lambdabot>  Parse error at "->" (column 16)
21:46:07 <dibblego> > foldr (\_ b -> b + 1) 0 "hello"
21:46:07 <lambdabot>  5
21:46:17 <mdmkolbe|work> Cale: that the same as any other non-det state monad
21:46:19 <dibblego> @pl \_ b -> b + 1
21:46:19 <lambdabot> const (1 +)
21:46:28 <ballzack3> why does it care that the a's are type Char if you don't use const?
21:46:34 <Cale> mdmkolbe|work: oh, perhaps I see what you mean.
21:46:52 <dibblego> ballzack3, it should always care, regardless
21:46:56 <nolrai> > 'a' + 'b'
21:46:56 <lambdabot>   add an instance declaration for (Num Char)
21:46:57 <lambdabot>     In the expression: 'a' + 'b'...
21:47:24 <mdmkolbe|work> Cale: (2) "doesn't the extra >>= call mean the thread switch could happen that doesn't happen in do {x }?" A: either only switch at "yield" calls or make an argument based on obserable equality instead of structural equality
21:47:24 <Cale> okay, that actually works all right.
21:47:25 <dibblego> ballzack3, Couldn't match expected type `b -> b' against inferred type `Char` <- the problem here is more than just the type of a
21:47:30 <mauke> ballzack3: the function is called with two arguments
21:47:42 <ballzack3> oh i see
21:47:42 <Cale> mdmkolbe|work: I don't know what you mean by thread switch.
21:47:43 <dibblego> ballzack3, in any case, foldl' is better
21:47:56 <Cale> mdmkolbe|work: This isn't parallel or concurrent or anything.
21:48:04 <ballzack3> foldl goes from head to tail?
21:48:12 <dibblego> yes and in constant stack space
21:48:23 <Cale> foldr goes from head to tail
21:48:23 <dibblego> foldl' that is (not foldl necessarily)
21:48:24 <mdmkolbe|work> Cale: well everything "setPriority" is called, there is the potential that one of the other non-det paths (i.e. threads) became higher priority
21:48:28 <Cale> foldl goes from tail to head
21:48:41 <mdmkolbe|work> I guess yield == setPriority
21:48:44 <dibblego> sorry, what Cale said is right
21:48:51 <Cale> I suppose it depends on how you look at it :)
21:48:56 <Cale> http://cale.yi.org/index.php/Fold_Diagrams -- this might help
21:48:57 <lambdabot> Title: Fold Diagrams - CaleWiki
21:49:31 <mdmkolbe|work> foldl = (((((1 + 2) + 3) + 4) -- parens on Left
21:49:31 <mdmkolbe|work> foldr = (1 + (2 + (3 + 4))) -- parens on Right
21:51:01 <hpaste>  Cale pasted "Prio" at http://hpaste.org/4712
21:52:01 <nolrai> @ty flip
21:52:01 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:52:11 <Cale> Lazy evaluation is so ingrained in the way that I think about things, that the top of the tree is where things start for me ;)
21:52:12 <nolrai> @ty swap
21:52:12 <lambdabot> Not in scope: `swap'
21:52:28 <_phobes> Ah, so the type is one that evaluates all elements of a list above a given priority...
21:52:43 <_phobes> and gives you back their priorities
21:53:01 <_phobes> err it's more complicated than that ... I have to read/ think
21:53:02 <Cale> It evaluates them all, but laziness accounts for the rest.
21:53:17 <Cale> The sorting will destroy some of the laziness, but it's hard to avoid that.
21:53:30 <_phobes> That's what I was looking for
21:53:34 <Cale> It might be better to use a tree.
21:54:03 <Cale> That way the levels would be preserved, and you could easily ignore the low priority branches all the way down.
21:54:10 <Cale> (and wouldn't need to sort)
21:54:20 <Cale> You could just prune later.
21:56:11 <mdmkolbe|work> Cale: the litmus test would probably be (setPrio 10 >> return 1 `mplus` setPrio 1 >> undefined).  There is a way to do that, but it's not trivial and I don't think you implementation handles it.  (Maybe in a day or two I'll be able to write it but I have other "priorities" right now.)
21:56:51 <Cale> mdmkolbe|work: my implementation will handle that, you'll end up with [(10,1), (1,undefined)]
21:57:13 <Cale> The elements of the list aren't observed by the sorting.
21:57:27 <mdmkolbe|work> Cale: I said >>undefined, not >> return undefined
21:57:34 <Cale> oh
21:58:00 <Cale> Yes, that's probably undefined.
21:58:22 <mdmkolbe|work> Cale: that is needed to account for expensive, low-priority branches of the search tree that should really be skipped
21:58:43 <hpaste>  loupgaroublond pasted "weird class errors" at http://hpaste.org/4713
21:59:31 <loupgaroublond> can anyone help me with this? based on the known types, the operations should be pigeonholing the data into the already defined instance
22:00:09 <mdmkolbe|work> Cale: this really all amounts to a cooperative threading monad.  If one doesn't exist already, the Cont monad mixed with the Error monad is a good place to start
22:00:41 <_phobes> mdmkolbe|work:  That sounds reasonable
22:01:31 <_phobes> except I make the claims that 1) this is straightforward, even with maximal laziness, and shouldn't require a haskell guru/genius to implement, and 2) monads are dumb
22:01:34 <_phobes> :)
22:01:38 <mdmkolbe|work> Cale: setPrio x = do { callCC (\k -> throwError (k, x) }, runPrio would run the highest priorty one until it through, then check the resulting priorites and use those cont to continue
22:01:58 <Cale> _phobes: To be honest, I wouldn't do this using a monad.
22:02:03 <loupgaroublond> :t String
22:02:06 <lambdabot> Not in scope: data constructor `String'
22:02:11 <Cale> _phobes: Your insistence that it should be a monad is strange.
22:02:30 <Cale> I'd probably just use a tree.
22:02:30 <_phobes> Cale:  It's a box that responds to instructions - those instructions are a monad!
22:02:32 <mdmkolbe|work> _phobes: 2 has been debated for hours, 1 is only true if you consider continuations easy (most don't)
22:02:59 <Cale> _phobes: I don't see how it's a box that responds to instructions in any obvious way.
22:03:29 <Cale> It's much more naturally a problem to use a tree with.
22:03:41 <loupgaroublond> are lists instances of Eq?
22:03:45 <nolrai> Cale: how?
22:03:45 <mdmkolbe|work> _phobes: have you read the "deriving monads" paper?
22:03:48 <Cale> loupgaroublond: if their elements are
22:03:56 <_phobes> mdmkolbe|work - I believe that with proper language foundation, you wouldn't need to think heavily about continuations to do it (though really "suspended computation" = continuation, so the problem is really *about* continuations)
22:04:04 <Cale> nolrai: how what?
22:04:14 <ballzack3> arent continuations just saving return points?
22:04:16 <nolrai> would you use a tree.
22:04:36 <_phobes> mdmkolbe|work:  The title sounds familiar
22:04:44 <Cale> nolrai: have the internal nodes of the tree labelled with priorities and just build a tree of all the possibilities.
22:04:44 <mdmkolbe|work> _phobes: monads don't take instruction streams, they take abstract syntax trees and interpret them
22:04:47 <loupgaroublond> Cale: better yet, are [Char]s instances of Eq, and if so, why won't something working on [Char] use a class defined for something that is Eq'able
22:05:03 <mdmkolbe|work> _phobes: e.g. the reader monad needs "local"
22:05:04 <Cale> Then you can prune it by simply recursing over the tree, and dropping low priority branches.
22:05:13 <_phobes> mdmkolbe|work:  Instruction streams are a simple special case of trees :)
22:05:34 <Cale> loupgaroublond: Strings are in Eq
22:05:37 <nolrai> but how would you handle arbitrary computations.
22:05:46 <Cale> > "abcd" == "abce"
22:05:47 <lambdabot>  False
22:06:18 <Cale> nolrai: I don't know what you mean...
22:06:30 <_phobes> nolrai: I don't think I ever suggested using a stream of instructions?
22:07:02 <Cale> nolrai: This sort of search problem is usually one where you're searching through a tree of possibilities. I'm just saying construct that tree rather than trying to fit the problem into a monadic style.
22:07:08 <nolrai> but thats the whole point of making it a monad isnt it?
22:07:19 <Cale> Right, I'm saying don't do that.
22:07:31 <nolrai> ^^ _phobes
22:07:48 <Cale> Some things are naturally monadic, and others are not.
22:08:02 <Cale> This would be one of those cases where it's just not monadic.
22:08:09 <mdmkolbe|work> _phobes: yes, but in general monads are on trees, the instruction stream only works for some monads.
22:08:19 <_phobes> Cale:  The knee jerk implementation of this solution is:  keep a priority queue of suspended computations, and develop them in order.   That's what a good solution to this problem should look like, and it should result in a Monad
22:08:23 <Cale> Or if it is monadic, it's not obviously so.
22:08:27 <mdmkolbe|work> Cale: come back in two days and I'll have a monadic implementation for you
22:08:44 <Cale> mdmkolbe|work: Sure, but will it be nicer to use than just building a lazy tree?
22:08:55 <mdmkolbe|work> Cale: how _phobes described it is exactly right
22:09:29 <mdmkolbe|work> Cale: I don't know, but it should be quite easy
22:09:46 <Cale> Too bad we don't have a priority queue in the libraries.
22:09:47 <mdmkolbe|work> Cale: you write the tree implementation and I'll write a monad implementation and we can compare ;-)
22:09:56 <_phobes> Cale:  Damn pure languages :)
22:10:04 <Cale> _phobes: that's not the problem
22:10:16 <_phobes> Cale:  Well, it's why you don't have heaps
22:10:22 <mdmkolbe|work> _phobes: not so
22:10:23 <_phobes> The bestest kind of priority queue
22:10:32 <Cale> _phobes: In fact, we have most of a pure efficient priority queue in the libraries, it's just not exposed for some stupid reason.
22:10:39 <_phobes> ah
22:10:49 <mdmkolbe|work> _phobes: heaps and prio ques are easy to implement in pure langs
22:11:11 <_phobes> Well, to really consider it a heap, I think you'd have to put it in a Monad and use a mutable array?
22:11:35 <Cale> Data.Sequence (a fast catenable, splittable sequence structure) is internally based on a data structure called a finger tree
22:11:42 <nolrai> what do you mean by heap?
22:11:53 <Cale> Finger trees easily give efficient priority queues as well
22:11:54 <loupgaroublond> Warning: This binding for `pred' shadows an existing binding In the definition of `-->' << What does this warning mean?
22:12:08 <Cale> But for some reason the underlying finger tree implementation isn't exposed.
22:12:09 <mdmkolbe|work> _phobes: no monad, no mutable array.  insert :: a -> Heap -> Heap
22:12:10 <_phobes> nolrai:  It's the name of a very simple data structure
22:12:24 <mdmkolbe|work> _phobes: pop :: Heap -> (a, Heap)
22:12:41 <Cale> loupgaroublond: It's warning you because pred is a prelude function.
22:12:51 <nolrai> yeah but it is as defineible in a pure way as a stack is, right?
22:12:53 <Cale> loupgaroublond: and by defining it, you're shadowing that definition
22:12:54 <_phobes> mdmkolbe|work:  Ok, I suppose a heap just operates on a tree, but that's kind of like the haskell implementation of quicksort...
22:13:06 <mdmkolbe|work> nolrai: a heap is a tree where every element in the tree has higher priority than the lower elements
22:13:19 <nolrai> thats what i thought.
22:13:54 <loupgaroublond> Cale, thanks again
22:14:04 <Cale> loupgaroublond: no problem
22:14:28 <nolrai> now a pure heap will be copying way more than you want to, but its still a heap.
22:14:38 <_phobes> ya, that was my point
22:14:52 <Cale> _phobes: Of course, without mutable cells, the data structures you tend to use are different, but it's surprising how well you can do. Typically the worst that happens is an additional log factor.
22:15:00 <_phobes> it might not be copying _too_ much though
22:15:20 <Cale> (which might as well be part of the constant)
22:15:42 <_phobes> Cale:  The problem usually isn't the log factor - it's the big constant
22:16:02 <Cale> The fact that you don't have to copy things also helps :)
22:16:07 <_phobes> all of the indirection you need for fancy data structures is expensive
22:16:36 <Cale> You don't have to worry about aliasing, so if two things are the same, you share them.
22:16:44 <_phobes> ya
22:16:50 <nolrai> what big constant? it would just be a tree. not that much inderection there.
22:17:54 <_phobes> nolrai:  one level of indirection is often enough to hammer performance because of cache issues
22:18:27 <nolrai> so useing a tree instead of an array.
22:18:31 <mdmkolbe|work> _phobes: there is no big constant, it's only the allocation of a few cells (which is fast).  the only extra indirection is if you want a lazy heap and that can be optimized.
22:19:10 <_phobes> mdmkolbe|work:  it's the scattering of elements that's bad
22:19:38 <Cale> _phobes: that's the garbage collector's problem isn't it?
22:20:06 <_phobes> Cale:  Does the garbage collector solve that problem?
22:20:08 <mdmkolbe|work> _phobes: oh, are you thinking of a heap implementation based on an array?
22:20:17 <_phobes> yes
22:20:22 <LoganCapaldo> garbage collector solves all problems.
22:20:29 <bos> Cale: have you done much type hacking?
22:20:47 <_phobes> My experience here is comparing the performance of an array based implementation to a binary tree based (with pointers) implementation in C++
22:20:49 <mdmkolbe|work> LoganCapaldo: I don't think the GC does anythink to keep objects that point to each other together in memory
22:20:52 <_phobes> and there's a big difference
22:21:02 <LoganCapaldo> all hailthe garbage collector,  long may he reign, untroubled by the usurper that is region inference
22:21:05 <Cale> _phobes: I don't know. But it's certainly not something which you can worry about when programming at this level of abstraction. If you really need to worry about that, you'll have to go down a level or two.
22:21:29 <LoganCapaldo> mdmkolbe|work: a copying/compacting gc does
22:21:30 <mdmkolbe|work> _phobes: was the C++ implemenation allocating memory?  (C++ malloc/free is much slower than Haskell/Scheme malloc)
22:21:35 <sclv> ?ty fromEither
22:21:36 <lambdabot> Not in scope: `fromEither'
22:21:38 <sclv> ?hoogle fromEither
22:21:39 <lambdabot> No matches found
22:21:44 <mdmkolbe|work> @type maybe
22:21:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:21:47 <mdmkolbe|work> @type fromJust
22:21:47 <lambdabot> forall a. Maybe a -> a
22:21:56 <LoganCapaldo> or can at least
22:22:09 <nolrai> @hoogle <?>
22:22:09 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<?>) :: GenParser tok st a -> String -> GenParser tok st a
22:22:17 <_phobes> mdmkolbe|work - well it was, but we had a special pooled allocator, so it wasn't nearly as bad as malloc'
22:22:17 <nolrai> @hoogle <$>
22:22:17 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
22:22:34 <Cale> _phobes: It certainly seems plausible that a compacting collector will put elements of the same data structure close together in memory
22:22:54 <_phobes> Cale:  Ya, I agree...
22:23:24 <mdmkolbe|work> _phobes: a good GC's allocator is just a test and register increment (less in GHC b/c it collects the allocations for a function all together and getts multiple allocs for the price of one)
22:23:24 <Cale> bos: type hacking... I'm not Oleg, but I've played around a bit :)
22:23:49 <_phobes> The problem isn't the allocation cost - it's the fragmentation cost
22:23:50 <bos> Cale: ok, mind if i bounce something off you?
22:23:58 <Cale> not at all, go right ahead
22:24:26 <ballzack3> doesnt GC get rid of fragmentation?
22:24:37 * LoganCapaldo wonders if a GC is really gonna be more fragmented han not-a-gc, but isn't sure that's what you are talking about
22:24:39 <_phobes> Cale was just surmising that it does
22:24:40 <bos> ok. i'm writing bindings for LLVM, using its C bindings.
22:25:02 <_phobes> LoganCapaldo:  I can guarantee it to be at least as fragmented as an array based heap implementation :)
22:25:16 <bos> the C bindings throw away lots of type information, so i'm trying to reconstruct the types in haskell to avoid crashes.
22:25:27 <Cale> _phobes: at the very least it *can*, whether that's always the best idea, I'm not sure. :)
22:25:48 <Cale> bos: ah, okay
22:25:57 <Cale> bos: That's often quite possible.
22:25:59 <mdmkolbe|work> _phobes: are you sure it was due to cache effects (i.e. did you have cache miss numbers)?
22:26:14 <Cale> bos: Newtypes alone will help a great deal.
22:26:15 <_phobes> mdmkolbe|work:  no :/
22:26:17 <bos> LLVM has a notion of types and values, and even kinds for types.
22:26:42 <_phobes> mdmkolbe|work:  We had a crappy hand-rolled profiling system
22:26:45 * mdmkolbe|work does research on cache effects for numerical computation
22:26:49 <bos> i have all of the type domain stuff worked out.  so each LLVM type gets a newtype, and the type hierarchy is represented with classes.
22:27:17 <Cale> all right
22:27:24 <_phobes> mdmkolbe|work:   But doesn't that sound plausible?  What else could it have been?  Like I said, our allocator wasn't the bottleneck I'm almost positive
22:27:27 <Cale> bos: any polymorphism?
22:27:52 <bos> but what i'm trying to figure out is how to apply the same type discipline to LLVM's value domain, so that e.g. if i call the "create a value" function, with a particular type, i get back a value that has the correct static type.
22:28:09 <_phobes> Allocating from a pool is almost as trivial as what a GC does... you ask the link list for the next free cell, and you return it
22:28:09 <bos> and so far, this seems to require lots of fingertyping.
22:28:22 <mdmkolbe|work> _phobes: well, often spatial cache effects are a lot less than most people imagine.  It's temporal cache effects that we see as the biggest problems.  Though occationally spatial can make a big difference
22:28:23 <bos> Cale: in places, yes.
22:28:26 <_phobes> and that's a head, not a list walk
22:28:29 <Cale> bos: You're passing the type itself as a parameter?
22:29:00 <mdmkolbe|work> _phobes: plausible, yes. but remember the second rule of optimization.  "benchmark first" b/c propgrammers are *very* bad at figguring out where the bottleneck is
22:29:15 <bos> Cale: the current interface looks like this:
22:29:34 <LoganCapaldo> no we aren't. computers are just bd at meeting our exacting standards and expectations <g>
22:29:36 <bos> newtype Value a = Value {
22:29:36 <bos>       fromValue :: FFI.ValueRef
22:29:36 <bos>     }
22:29:44 <_phobes> mdmkolbe|work:   Well, in this case, benchmarking was alot harder than "look, we replaced it with a heap and it got alot faster!"
22:29:56 <bos> addGlobal :: (Type t) => Module -> t -> String -> IO Value
22:30:23 <Cale> _phobes: well, you run a profiler, and look at what's taking all the time and space :)
22:30:31 <bos> what i'd really like is for the Value to be marked with the same t as the t parameter
22:30:50 <_phobes> Cale:  We did that, discovered the priority queue to be a problem, and optimized it.... but our tools didn't give us a good explanation as to why
22:30:55 <mdmkolbe|work> _phobes: fyi, if on linux try to use PAPI for the benchmarking, it makes collecting cache miss counts much easier.  though I understand that sometimes a simple A/B test doesn't work
22:30:55 <bos> but the obvious approach of using a "newtype Value a" falls over almost immediately.
22:31:52 <Cale> bos: hmm
22:32:00 <bos> each concrete type in LLVM's type hierarchy has its own newtype, and i fear having to replicate that hierarchy with newtypes in the value domain
22:32:14 <_phobes> mdmkolbe|work:   Thanks for the tip - I am on linux atm
22:32:22 <_phobes> (though wasn't at the time)
22:32:25 <bos> even if i did, i then substitute one problem for another, without making obvious progress
22:32:42 <bos> Cale: if you want a more detailed picture of what's going on, darcs get http://darcs.serpentine.com/llvm
22:32:43 <lambdabot> Title: Index of /llvm
22:32:54 <Cale> addGlobal :: (Type t) => Module -> t -> String -> IO (Value t) ?
22:33:11 <bos> Cale: it's fine for simple cases like that, but ...
22:34:06 <bos> constWord :: (IntegerType t, Integral a) => t -> a -> Value
22:34:06 <bos> constWord typ val =
22:34:06 <bos>     Value $ FFI.constInt (fromType typ) (fromIntegral val) 0
22:34:27 <bos> if i replace Value with Value t, the typechecker falls over
22:35:07 <Cale> with what error?
22:35:22 <bos> let me undo my undo and tell you...
22:36:06 <Cale> This does sound like a simple application of phantom types.
22:36:19 <Cale> Well, for some value of simple... :)
22:38:21 <bos> class Const a where
22:38:21 <bos>     const :: a -> T.Value a
22:38:31 <bos> instance Const Float where
22:38:31 <bos>     const = constReal floatType . fromRational . toRational
22:38:43 <bos>     Couldn't match expected type `Float'
22:38:43 <bos>            against inferred type `T.Float'
22:38:43 <bos>       Expected type: Float -> T.Value Float
22:38:43 <bos>       Inferred type: Float -> T.Value T.Float
22:38:43 <bos>     In the expression: constReal floatType . fromRational . toRational
22:38:43 <bos>     In the definition of `const':
22:38:45 <bos>         const = constReal floatType . fromRational . toRational
22:39:00 <ballzack3> way to use the paste site
22:39:09 <dibblego> @hpaste
22:39:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:39:17 <bos> yeah, erm.
22:40:17 <ballzack3> thanks for the shipment of fail :))
22:40:25 <TheColonial> hello everyone
22:40:43 <TheColonial> i have a noob question which I can't seem to find a great deal of documentation on and would appreciate a bit of help
22:40:45 <bos> if i change const to a -> T.Value t it doesn't help
22:41:14 <TheColonial> can someone give me a quick summary as to what the $ symbol means? eg:  concat $ replicate 3 "foo"
22:41:24 <bos> TheColonial: it's just function application
22:41:29 <Cale> fromRational . toRational == realToFrac, btw
22:41:30 <dibblego> concat (replicate 3 "foo")
22:41:34 <bos> TheColonial: think of it as a way of avoiding parens
22:41:41 <TheColonial> fantastic, thanks very much :)
22:41:57 <ballzack3> the rhs of $ gets higher precedence?
22:41:58 <bos> Cale: yeah, i can never remember the witchy ways of the real types
22:42:13 <TheColonial> that was my next Q :P what's the go with precedence?
22:42:20 <Cale> bos: Yeah, I think you're confusing Haskell types and LLVM types there
22:42:28 <ballzack3> I'm in your head, TheColonial!
22:42:36 <hpaste>  sclv annotated "U.g.l.y. ain't got no alibi" with "Better yet" at http://hpaste.org/4678#a2
22:42:40 <TheColonial> ballzack3: ha! GET OUT! :P
22:43:34 <Cale> bos: The phantom type should always refer to one of your LLVM types, right?
22:43:37 <bos> Cale: yes, i know i'm confused :-)  i just haven't figured a way out of it yet.
22:43:41 <bos> Cale: yes.
22:43:52 <sclv> don't see how to get my paste much cleaner.
22:43:54 <TheColonial> thanks guys, i'm heading back to the haskell playground. later :)
22:43:58 <Cale> bos: So you'll have to use a multiparameter typeclass with a dependency, I think
22:43:59 <bos> i guess i could capture another parameter in the class definition
22:44:03 <bos> right
22:44:17 <ballzack3> man, i am so pooped
22:44:22 <Cale> bos: class Const a t | a -> t where const :: a -> T.Value t
22:44:56 <bos> Cale: that's exactly what i wrote.
22:45:14 <Cale> bos: I think that should work out better :)
22:45:18 <bos> yay, another language extension. i've already got a string of christmas tree lights turned on in the compiler.
22:46:46 <Cale> Well, perhaps you could even use associated types instead, and require 6.8 :)
22:46:53 <bos> Cale: thanks. i should have thought of that already.
22:47:00 <Cale> No problem
22:47:18 <bos> i'm fairly sure i'm already requiring 6.8 for other extensions
22:48:05 <_phobes> Aren't functional dependencies obsolete?
22:48:49 <bos> they're twitching, but they haven't been finished off yet.
22:49:04 <_phobes> k
22:49:17 <bos> i don't see any docs on ATs in the GHC manual. must poke at chillix's site.
22:49:48 <Cale> Yeah, I was just noticing that as well.
22:50:33 <Cale> http://www.haskell.org/haskellwiki/GHC/Indexed_types
22:50:36 <lambdabot> Title: GHC/Type families - HaskellWiki
22:50:46 <bos> cale++
22:50:55 * Cale fails to understand why that hasn't been incorporated into the user's guide.
22:51:22 <Cale> I think it would look like:
22:51:40 <bos> that page repeats "only in the HEAD" rather a lot
22:51:48 <bos> i wonder what the state of play in 6.8 is
22:52:01 <Cale> class Const a where data T :: *; const :: a -> T.Value T
22:52:16 <Cale> oh
22:52:17 <Cale> hmm
22:52:28 <Cale> I thought they were in 6.8, but maybe I'm actually wrong :)
22:53:10 <bos> i think an older version might be
22:53:26 <bos> but, hm, perhaps not.
22:53:43 <bos> well, for once, the fundep is actually easy to understand and use.
22:53:50 <Cale> yeah
22:54:08 <Cale> oh, or maybe this would be  'type' and not 'data'
22:54:23 <bos> that would seem to make sense.
22:54:26 <sclv> this idiom is pretty:
22:54:28 <sclv> @. pl undo  do{                    v <- spaced word;                char '=';                e <- spaced exprn;                return (v, e)}
22:54:28 <lambdabot> (`fmap` (char '=' >> spaced exprn)) . (,) =<< spaced word
22:55:20 <sclv> @pl \x y -> (`fmap` x) . (,) =<< y
22:55:20 <lambdabot> (=<<) . (. (,)) . flip fmap
22:55:29 <sclv> @pl \y x -> (`fmap` x) . (,) =<< y
22:55:29 <lambdabot> (. ((. (,)) . flip fmap)) . (>>=)
22:55:47 <Cale> !paste
22:55:47 <hpaste> Haskell paste bin: http://hpaste.org/
22:55:57 <bos> Cale: the fundep is working out nicely, all i have to do now is figure out the right type constraints where i've shoved in Value a as a placeholder
22:56:00 <bos> Cale: whee!
22:56:02 <hpaste>  Cale pasted "this works in 6.8.2" at http://hpaste.org/4714
22:56:32 <Cale> (of course, it's not quite the same as yours, but you see how it goes :)
22:56:50 <bos> Cale: interesting. it's more verbose than the MPTC with fundep. my poor fingers!
22:58:12 <bos> boy, the LLVM bindings have been worthwhile as a learning vehicle. i've powered up on my type-level computations here, too.
22:58:26 <Cale> It also appears to be moderately broken...
22:58:43 <Cale> *Main> con (6.4 :: Float) :: Integer
22:58:43 <Cale> 6
22:58:51 <Cale> *Main> con (6.4 :: Float)
22:58:51 <Cale> <interactive>:1:0:
22:58:51 <Cale>     No instance for (Show (T Float))
22:58:57 <bos> oog.
22:59:23 <Cale> It's not applying the type function.
23:00:21 <Cale> Probably fixed in HEAD. ;)
23:02:00 <bos> heh.
23:08:10 <thermoplyae> alright dudes, i'm ready to give haskell another shot, hopefully you guys (maybe coupled with google) can point me in the right direction
23:08:27 <sjanssen> bos, Cale: it probably isn't a good idea to use type families in production code yet
23:08:36 <bos> sjanssen: indeed
23:08:55 * sjanssen can't wait for GHC 6.10 :)
23:09:11 <thermoplyae> i'm a reasonably smart guy at a reasonably good CS school, i know a great deal of OCaml and an adequate amount of Lisp, and i'm a serious mathematician.  i've looked at haskell tutorials before, but they have a frustrating tendency to assume that you're a complete stranger to the topics and rely on fuzzy exposition and bad analogies to communicate seemingly critical concepts
23:09:39 <thermoplyae> if there were a sharp, pointed introduction, i'd really enjoy taking a swing at it
23:09:58 <thermoplyae> or an introduction that assumes an OCaml (or even ML in general) background
23:10:20 <sjanssen> thermoplyae: tried the 'Gentle Introduction'?
23:10:27 <thermoplyae> maybe "introduction" isn't even the right word
23:10:38 <sjanssen> it's called "gentle", but it's the least gentle of all of them :)
23:10:38 <thermoplyae> not sure, it's been a while.  let me open it up, see if it's familiar
23:11:29 <sjanssen> another option is to just read the Haskell '98 Report
23:12:06 <thermoplyae> hmm.  that never occurred to me
23:12:12 <_phobes> That's usually the way it goes... when I was in HS I bought two books on the same day "Basic Number Theory" and "Advanced Number Theory".   The "Advanced Number Theory" proved to be a good introduction... I still have no idea what "Basic Number Theory" is about.
23:12:48 <Spark> heh
23:13:10 <Spark> usually it is the quality of the explanation, not the prerequisites, that makes a passage hard to understand
23:13:58 <bos> crap. i need to do another dance with existentials for values.
23:13:59 <_phobes> "Let F be a finite field (commutative or not) with the unit-element 1.  Its characteristic must clearly be a prime p >1, and the prime ring in F is isomorphic to the prime field Fp = Z / pZ, with which we may identify it"
23:14:11 <mdmkolbe|work> Is the expression "u { foo = 1 }" lazy in u?  (i.e. does it model "case u of U { bar = z } -> U { bar = z, foo 1 }" or does it model "case u of ~U { bar = z } -> U { bar = z, foo 1 }"?)
23:14:16 <_phobes> That's an excerpt from "Basic Number Theory"
23:14:29 <_phobes> And while I understand that now.... IT'S THE FIRST TWO SENTENCES
23:15:28 <_phobes> ... that book makes me laugh
23:15:46 <thermoplyae> from the looks of it, no, i haven't looked at Gentle Introduction, and i know i haven't looked at the report proper
23:15:56 <thermoplyae> i'll give them a go, come back and whine again if it doesn't work out
23:18:11 <mdmkolbe|work> hmm, my tests indicate that x { ...} is stict on the constructor,  is there a lazy version?
23:19:25 <fnord123> regarding quadrant calculations: atan2 is your friend. :)
23:19:26 <sjanssen> a lazy version isn't possible, AFAIK
23:21:01 <mdmkolbe|work> @where report
23:21:01 <lambdabot> http://www.haskell.org/onlinereport/
