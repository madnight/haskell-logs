00:00:58 <jsnx> maybe HaXml?
00:02:18 <jsnx> > Text.XML.HaXml.Escape.xmlUnEscapeContent "&#x01ce;"
00:02:20 <lambdabot>   Not in scope: `Text.XML.HaXml.Escape.xmlUnEscapeContent'
00:02:39 <jsnx> oh, fudge
00:02:47 <jsnx> it's the wrong type, anyway
00:07:14 <jsnx> well, i give up
00:12:33 <roconnor> > "\x01ce"
00:12:35 <lambdabot>  "\462"
00:12:58 <dmwit> > readHex "01ce"
00:12:59 <lambdabot>  [(462,"")]
00:23:47 <Japsu> :o
00:23:49 <Japsu> @index readHex
00:23:50 <lambdabot> Numeric
00:23:54 <Japsu> @type readHex
00:23:56 <lambdabot> forall a. (Num a) => String -> [(a, String)]
00:44:43 <dmwit> > let newFunction# = id in newFunction# 3
00:44:43 <lambdabot>  Parse error at "=" (column 18)
00:45:18 <dmwit> Bah, how come GHC gets to do it? =o
00:50:20 <mux> dmwit: it's using an extension
00:50:38 <dmwit> ah
00:50:40 <dmwit> thanks
00:52:23 <mux> looking at the list of extensions, I suppose this one is MagicHash
01:03:59 <ttfh> how is "forever" in Control.Monad defined? I doesn't seem to be in ghc 6.6.1 :-(     (really should upgrade...)
01:04:31 <mux> forever a = a >> forever a
01:04:49 <dmwit> forever = fix (>>)
01:05:07 <dmwit> But it has a type annotation to restrict its type.
01:05:09 <dmwit> I think.
01:05:27 <mux> @let forever a = a >> forever a
01:05:30 <mux> :t forever
01:05:37 <dmwit> The full glory of the type would be something like (forever :: m a -> m b), but it's restricted to (forever :: m a -> m ()).
01:05:42 <lambdabot> thread killed
01:05:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
01:05:55 <ttfh> alright
01:06:25 <dmwit> This is to suggest that it doesn't really make sense to do something like "do { x <- forever y; return x }".
01:06:32 <ttfh> does anyone know if there's a gentoo package for ghc 6.8?
01:06:45 <dcoutts> ttfh: yep, in the haskell overlay
01:07:03 <dcoutts> ttfh: it'll make it's way into portage in due course
01:07:20 <ttfh> dcoutts: do you know if there are any amd64 problems as before with ghci?
01:07:22 <opqdonut> > forever (Nothing)
01:07:26 <lambdabot>   Not in scope: `forever'
01:07:46 <opqdonut> > let forever a = a >> forever a in forever (Nothing)
01:07:47 <lambdabot>  Nothing
01:08:23 <dmwit> opqdonut: Yes, and I think most such special cases have no problem with the (-> m ()) restriction.
01:08:44 <opqdonut> true i guess
01:08:52 <dcoutts> ttfh: what ghci problems were there before? I use amd64 and have not had any problems.
01:09:21 <ttfh> dcoutts: ghci didn't work on amd64 for a while, but maybe that was a long time ago
01:09:32 <dcoutts> ttfh: that's back in ghc-6.2.2 era
01:10:06 <ttfh> yes, I want forever for a server loop, and then it doesn't really make sense for it to return a value
01:10:32 <ttfh> dcoutts: a couple of years ago right?
01:10:47 <dcoutts> ttfh: yep
01:15:07 <dmwit> opqdonut: In fact, I'm pretty sure that if you get back a monad that actually has a payload of type b, you know it's _|_.
01:15:15 <dmwit> Since there isn't a function (cast :: a -> b).
01:16:19 <quicksilver> intuitively that's true
01:16:30 <quicksilver> of course it's not entirely clear how to make precise the notion of 'payload'
01:17:32 <Baughn> There is unsafeCast, but I assume that doesn't count
01:22:44 <wefdf> just to say hi
01:28:03 <opqdonut> yeah, per-monad we might have something like (m a -> m b) but not generically
02:28:58 <quicksilver> :t \f -> (f >>= return Nothing)
02:29:00 <lambdabot> forall a a1. Maybe a -> Maybe a1
02:29:25 <Deewiant> @pl \f -> (f >>= return Nothing)
02:29:26 <lambdabot> (return Nothing =<<)
02:29:55 <dmwit> *return* Nothing?
02:30:00 <dmwit> :t \f -> f >>= const Nothing
02:30:00 <lambdabot> forall a a1. Maybe a -> Maybe a1
02:30:21 <dmwit> quicksilver: That return is in the Reader monad! =O
02:30:22 <nornagon> dmwit: IO (Maybe Int) perhaps?
02:30:29 <quicksilver> dmwit: oops :)
02:30:41 <dmwit> nornagon: No such luck, that would have to be const (return Nothing).
02:30:46 <quicksilver> dmwit: it still had the type opqdonut wanted though :)
02:30:48 <nornagon> oh
02:31:03 <quicksilver> yeah, I meant const Nothing
02:31:43 <opqdonut> :)
02:33:11 <dmwit> It's okay, the reader monad has been my new favorite toy for the last few days.
02:33:13 <dmwit> =)
03:00:10 <hpaste>  Mitar pasted "precedence parsing error" at http://hpaste.org/4257
03:02:57 <roconnor> @type ((.) ((.) join (flip (.) (flip (.)))) (flip (.)))
03:02:59 <lambdabot> forall b c a. ((a -> b) -> b -> c) -> (a -> b) -> a -> c
03:03:26 <roconnor> @type ((.) ((.) ((.) join) (flip (.) (flip (.)))) (flip (.)))
03:03:26 <lambdabot> forall b c a. (a -> b -> c) -> (a -> b) -> a -> c
03:03:40 <nornagon> scary
03:03:55 <nornagon> @unpl ((.) ((.) ((.) join) (flip (.) (flip (.)))) (flip (.)))
03:03:55 <lambdabot> (\ c i -> (\ aa u -> c aa (i u)) >>= \ ab -> ab)
03:04:31 <nornagon> @. pl unpl ((.) ((.) ((.) join) (flip (.) (flip (.)))) (flip (.)))
03:04:31 <lambdabot> flip flip id . ((>>=) .) . flip . ((.) .)
03:05:10 <roconnor> @type ap
03:05:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:05:45 <Mitar> can somebody look at the code i pasted?
03:05:47 <quicksilver> Mitar: that's life with infix operators.
03:05:51 <Mitar> :-)
03:05:54 <quicksilver> Mitar: $ and <?> conflict
03:06:00 <nornagon> :t ap ap
03:06:00 <Mitar> yes ... i see the error
03:06:00 <quicksilver> you have to bracket something...
03:06:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m (a -> b) -> m a) -> m (a -> b) -> m b
03:06:10 <quicksilver> :t ap.ap
03:06:10 <lambdabot> forall a a1 b. (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
03:06:23 <Mitar> so brackets around the whole do block?
03:06:28 <Mitar> this is plain ugly
03:06:53 <hpaste>  Mitar annotated "precedence parsing error" with "ugly" at http://hpaste.org/4257#a1
03:07:28 <Mitar> it looks like lisp :-)
03:13:29 <quicksilver> is (3+4)*5 ugly?
03:13:35 <quicksilver> I don't find it so
03:13:42 <doserj> Mitar: you can define the do-block in a separate where declaration
03:13:45 <quicksilver> sometimes you need brackets, especially with infix operators
03:14:23 <Lemmih> '(*) ((+) 3 4) 5' is obviously prettier.
03:15:09 <opqdonut> 3 4 + 5 * is obviously superior
03:15:10 <Svrog> or '5 4 3 + *'
03:15:17 <opqdonut> ^_^
03:18:43 <luqui> definitely a where clause would be my choice
03:19:30 <hpaste>  Mitar annotated "precedence parsing error" with "like this?" at http://hpaste.org/4257#a2
03:19:43 <Mitar> and how would you do indentation?
03:20:39 <quicksilver> I'd probably write
03:20:48 <quicksilver> (node <?> "function declaration")
03:20:57 <doserj> me too
03:21:35 <doserj> parantheses are ok, as long as they are close together
03:22:36 <Mitar> thanks
04:11:14 <ricky_clarkson> > let fac 0 a=a; fac 1 a=a; fac n a=fac (n-1) (a*n) in fac 1000000 1
04:11:29 <lambdabot>  thread killed
04:11:49 <ricky_clarkson> I get a stack overflow in ghci, but I'm not sure why.
04:14:13 <nornagon> seems like it should be TCO'd fine
04:14:58 <EvilTerran> add strictness?
04:16:33 <quicksilver> ricky_clarkson: because you're using ghci
04:16:44 <quicksilver> compile it :)
04:17:05 <quicksilver> it's not the TCO anyway
04:17:12 <quicksilver> it's the huge * thunk I imagine
04:17:19 <quicksilver> well, the huge joint * - thunk?
04:18:05 <nornagon> strictness sure improves performance in ghci
04:22:51 <ricky_clarkson> quicksilver: Oh, you mean the multiplication fails because the numbers are huge?
04:25:41 <luqui> ricky_clarkson, no, because the function is not strict in a
04:26:29 <luqui> the (-) thunk won't get big, it's evaluated every iteration to see if it's 0
04:26:30 <opqdonut> it accumulates a huge expression 1*2*3*4*5*...*100000 before evaluating it
04:26:49 <luqui> ah yes, the jargon thing...
04:27:37 <mux> I'm often wondering if it would be possible to make intelligent guesses in the compiler, based on term sizes, to help strictness analysis
04:28:03 <luqui> > let fac 0 a = a; fac n a = seq a $ fac (n-1) (a*n) in fac 1000000 1
04:28:10 <pejo> mux, why would the term size affect strictness?
04:28:19 <lambdabot>  thread killed
04:28:19 <luqui> of course another reason is that 1000000! is huge
04:28:31 <luqui> > let fac 0 a = a; fac n a = fac (n-1) (a+n) in fac 1000000 1
04:28:35 <lambdabot>  500000500001
04:28:47 <luqui> ah, it wasn't the thunk, just the big number
04:29:09 <mux> I don't mean that it does, I mean that if you see you are having bigger terms after evaluation than before, it might be interesting to note it somehow so as to consider being stricter
04:29:22 <TSC> > foldl' (*) 1 [1..1000000]
04:29:28 <lambdabot> Terminated
04:29:28 <luqui> so use runtime analysis for the next compilation or something, mux?
04:29:34 <TSC> > foldl' (+) 1 [1..1000000]
04:29:35 <lambdabot>  500000500001
04:29:55 <mux> luqui: maybe runtime, maybe only static, I really don't know yet, this was something that crossed my mind
04:30:12 <luqui> mux, how would you determine it statically?
04:30:29 <mux> that's a question for simon or simon
04:31:11 <luqui> of course, ghc tries pretty hard to make everything it can strict
04:31:18 <luqui> if it can prove it won't change semantics
04:31:24 <sieni> argh, what do I need to omport to get foldl'
04:31:31 <luqui> so my guess is that it might be wrong some of the time
04:31:33 <mux> @index foldl'
04:31:34 <lambdabot> Data.List
04:31:36 <luqui> which is Not Okay
04:32:13 <sieni> ah @index
04:32:17 <sieni> mux: thanks
04:32:20 <mux> yw
04:34:09 <int-e> @let bfold f [x] = x; bfold f xs = bfold f (pairup f xs) where pairup f (x:y:xs) = f x y : pairup f xs; pairup f xs = xs
04:34:10 <lambdabot> <local>:9:0:     Warning: Pattern match(es) are overlapped              In th...
04:34:18 <int-e> hmm. oh.
04:34:28 <int-e> > bfold (*) [1..100000]
04:34:29 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
04:34:48 <int-e> (I had already defined it)
04:36:38 <luqui> > bfold (*) [1..1000000]
04:36:44 <lambdabot> Terminated
04:36:56 <luqui> no good, cool fold though
04:46:28 <int-e> > bfold (*) [1..500000]
04:46:31 <lambdabot>  1022801584651902365330917440571931337926286208272242484080831292070902404683...
04:47:18 <opqdonut> ah, nice
05:09:39 <nominolo> > do Left x <- return (Right 42); Just x
05:09:41 <lambdabot>  Nothing
05:10:15 <nominolo> > do Just x <- return (Nothing); Right x
05:10:16 <lambdabot>  Add a type signature
05:10:27 <nominolo> > do Just x <- return (Nothing); Right x :: Either String Int
05:10:27 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:3-8"
05:10:54 <nominolo> > do Just x <- return (Nothing); Right x :: Either () Int
05:10:55 <lambdabot>   add an instance declaration for (Error ())
05:10:55 <lambdabot>     In a 'do' expression: Just x...
05:16:35 <nominolo> > do 42
05:16:37 <lambdabot>   add an instance declaration for (Num (t t1))
05:16:37 <lambdabot>     In the expression: 42
05:16:37 <lambdabot>     ...
05:38:56 <iuri> hi everyone, does anyone have knowledges on LL parsers
05:39:21 <dmwit> Hi iuri!
05:39:24 <dmwit> What do you need to know?
05:39:57 <iuri> hi, i'm trying to develop a basic LL parser to recnize strings
05:40:24 <iuri> the inpout is a CFG and a few words
05:40:33 <iuri> then the output is yes or no
05:41:18 <iuri>  the thing is i have no idea how to implement the derivation tree
05:42:12 <dmwit> iuri: You've got a lot of choices, but probably the easiest one to get going with right away is Parsec.
05:42:20 <dmwit> Have you seen it or tried using it yet?
05:42:32 <iuri> nope
05:42:52 <iuri> dm wit: do you have the url
05:42:54 <dmwit> ?where parsec
05:42:54 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
05:42:58 <dmwit> enjoy
05:43:10 <dmwit> You shouldn't have to download anything, it comes with GHC now.
05:43:51 <iuri> dmwit, i'm sure my question is related more with concepts of building such a sintax analyzer
05:44:27 <iuri> dmwit: this stuff seems to be vert advanced
05:44:40 <iuri> dmwit: and i'm doing an academic project
05:45:08 <dmwit> iuri: It's not *that* bad. =P
05:45:27 <dmwit> iuri: And it's perfect for academic projects... it does LALR(k) languages, not just LL(1) ones. =)
05:46:13 <dmwit> iuri: But, do you have a question about writing your own LL(1) parser?
05:46:23 <iuri> dmwit: ys
05:46:28 <dmwit> ok, go ahead
05:46:48 <iuri> dmwit: so far i understand the process has to be top-down
05:47:10 <iuri> but i don't know how to compare the grammar rules with the word
05:47:50 <dmwit> ?
05:47:59 <dmwit> :t (==) -- you mean this kind of comparison?
05:48:01 <lambdabot> forall a. (Eq a) => a -> a -> Bool
05:48:28 <iuri> not sure
05:48:31 <iuri> something like
05:48:39 <iuri> so the sketch as said:
05:48:39 <iuri> pass in a string to verify word
05:48:39 <iuri> then check wether there is a rule that satisfies the last character
05:48:39 <iuri> if so, replace the character with the left side of the rule
05:48:39 <iuri> if not, take one more character and test the string against your rules
05:48:40 <iuri> if it matches replace again
05:48:42 <iuri> if not, go on until, either you find a rule
05:48:44 <iuri> or the word does not fit into your rules at all
05:48:46 <iuri> if you found a replacement
05:48:48 <iuri> call your verify word function recursively with the new string
05:49:18 <MyCatVerbs> data SpanishInquisitionWeaponList = NobodyExpectsThe String SpanishInquisitionWeaponList
05:51:01 <scook0> "Expected type: a"
05:51:08 <scook0> "Inferred type: SpanishInquisition"
05:51:19 <dmwit> Well, that was unexpected.
05:51:32 <idnar> heh
05:52:08 <roconnor> @pl (\x y -> f x y a)
05:52:08 <lambdabot> flip flip a . f
05:52:15 <iuri> dmwit: unexpected?
05:52:20 <roconnor> @pl (\x -> f x a)
05:52:20 <lambdabot> flip f a
05:52:33 <dmwit> iuri: Nobody expects the SpanishInquisition!
05:52:35 <roconnor> @pl (\x y z -> f x y z a)
05:52:36 <lambdabot> flip flip a . (flip .) . f
05:52:45 <roconnor> @pl (\x y z w -> f x y z w a)
05:52:45 <lambdabot> flip flip a . ((flip . (flip .)) .) . f
05:52:51 <iuri> what is SpanishInquisition?
05:53:16 <scook0> iuri: it's a Monty Python joke
05:53:41 <iuri> does it mean when we ask too much??
05:53:52 <dmwit> No, it's just a joke.
05:53:58 <idnar> iuri: http://people.csail.mit.edu/paulfitz/spanish/script.html
05:53:58 <lambdabot> Title: The Spanish Inquisition - Monty Python
05:54:05 <roconnor> @pl (\x y z w r -> f x y z w r a)
05:54:05 <lambdabot> flip flip a . ((flip . ((flip . (flip .)) .)) .) . f
05:54:21 <MyCatVerbs> iuri: http://youtube.com/results?search_query=Spanish+inquisition&search=Search
05:55:43 <iuri> lambdabot: i see you are pating the anwser here
05:55:47 <iuri> is that it?
05:57:00 <dmwit> iuri: As for your real question, I'm not totally sure what you're having trouble with yet.  (Your description of the algorithm looks reasonable.)
05:57:12 <MyCatVerbs> @src foldr
05:57:13 <lambdabot> foldr k z xs = go xs
05:57:13 <lambdabot>     where go []     = z
05:57:13 <lambdabot>           go (y:ys) = y `k` go ys
05:58:37 <iuri> dmwit: my question is more specific
06:00:43 <iuri> dmwit: it's related on how to do it
06:01:15 <roconnor> @pl \x -> flip (f x)
06:01:15 <lambdabot> flip . f
06:02:03 <dmwit> iuri: Ah, then, no problem.
06:02:11 <arke> aargh
06:02:16 <dmwit> iuri: All you have to do is stare at a blank text editor until your eyes bleed. =)
06:02:24 <arke> I need to get myself to stop playing X-Moto and finally reacquaint myself with Haskell >_<
06:02:28 <arke> I need motivation.
06:02:29 <dmwit> Hiya arke.
06:02:40 <arke> hi dmwit
06:03:51 * arke wonders how nice Haskell does DSP code :D
06:03:55 <joelr1> good day
06:04:05 <dmwit> DSP?
06:04:10 <arke> digital signal processing
06:04:30 <arke> much harder than it looks, I found out.
06:05:02 <dmwit> Looks like there's an entire library for it.
06:07:56 <shapr> http://haskelldsp.sourceforge.net/ ?
06:07:57 <lambdabot> Title: Matt's Haskell DSP Libraries
06:08:17 <arke> Well that just made my day. :]
06:18:47 <shapr> @yow !
06:18:47 <lambdabot> I am a traffic light, and Alan Ginzberg kidnapped my laundry in 1927!
06:18:50 <shapr> Excitement!
06:19:12 <quicksilver> Drama!
06:20:01 <int-e> Mystery!
06:22:42 <shapr> CODE!
06:22:55 <Taejo> shapr: CYPHER?
06:23:04 <shapr> Could be.
06:23:13 <shapr> Though I'm just writing examples at the moment.
06:23:17 <shapr> What are you coding?
06:23:39 <Taejo> I'm coding a facebook application
06:24:07 <shapr> Nifty, are you using HAppS for that?
06:24:38 <Taejo> no, python (it interfaces with FontForge, which has a python interface)
06:24:44 <shapr> oh
06:25:00 <Taejo> in Haskell, I'm doing Project Euler
06:25:13 <shapr> How's that going?
06:26:20 <Taejo> shapr, the dynamic programming and complex input problems are a bit tricky
06:26:32 <Taejo> but bignum support and list comprehensions are awesome
06:27:06 <shapr> Yeah
06:27:35 <dmwit> ?lolcattime dmwit
06:27:36 <lambdabot> Local time for dmwit is Tue Dec  4 06:27:23
06:27:42 <dmwit> tee-hee!
06:27:47 <mar77a> >
06:28:08 <shapr> ?localtime shapr
06:28:09 <lambdabot> Local time for shapr is Tue Dec  4 08:28:08 2007
06:28:17 <sieni> dmwit: in california?
06:28:20 <dmwit> I guess I ought to go to bed, huh?
06:28:20 <shapr> Hiya mar77a, how's code?
06:28:24 <dmwit> sieni: yep
06:28:27 <shapr> dmwit: Or just stay up
06:28:29 <mar77a> what code? :p
06:28:38 <shapr> mar77a: Are you writing some exciting Haskell code?
06:28:42 <mar77a> of course not
06:28:51 <mar77a> im still having problems understanding the most basic elements of it
06:28:51 <shapr> Um, why not?
06:28:59 <shapr> mar77a: Oh! What questions do you have?
06:29:30 <mar77a> well none
06:29:41 <shapr> What parts are you having difficulty with?
06:29:47 <mar77a> unless you have the amazing powers to make something enter my brain and sleep in the realms of my understandage
06:29:55 <mar77a> amazing as it may seem
06:29:57 <shapr> I do have amazing powers.
06:30:04 <mar77a> i still how no clue how to write a program that does something
06:30:12 <mar77a> instead of just functions or special features of the language
06:30:45 <shapr> Can you think of something simple that is 'something' ?
06:30:48 <shapr> Maybe I could help?
06:31:06 <mar77a> well i was thinking in writting a console app which scans through a set of files in a directory searching for a keyword
06:31:21 <shapr> Ok, that sounds simple enough.
06:31:22 <mar77a> and then returns a prettified output
06:31:32 <mar77a> but probably C++ is better for that task
06:31:46 <shapr> Language choice aside, you are here on #haskell :-)
06:31:59 <mar77a> :p
06:32:10 <mar77a> well speed is quite important in these sorts of apps, ja
06:32:23 <shapr> Maintenance is also important.
06:32:34 <mar77a> of course
06:32:46 <mar77a> but then again, it's not some mainteinance intensive app
06:32:48 <shapr> And I'd bet serious amounts of internet credits that I can write a smaller easier-to-modify program to do that thing in Haskell.
06:32:51 <mar77a> i'll go for it
06:32:53 <quicksilver> actualy, there is no task that C++ is better for than haskell
06:33:11 <mar77a> heh yeah quicksilver
06:33:28 <shapr> mar77a: So, how would you break down that app into pieces?
06:33:39 <mar77a> one function that gets a list of the files
06:33:39 <shapr> hiya pythonist, want to become haskellist? :-)
06:33:55 <mar77a> one that iterates through each file and reads each line
06:34:03 <shapr> mar77a: Sounds good so far.
06:34:04 <mar77a> and one that checks if the line has the search pattern
06:34:14 <pythonist> shapr: I already am.
06:34:16 <mar77a> but im still thinking
06:34:20 <shapr> pythonist: Good to hear!
06:34:22 <mar77a> er, in an impreative sort of way
06:34:26 <pythonist> shapr: :D
06:34:38 <shapr> pythonist: You could become Programmist?
06:34:44 <pythonist> Arrows question anyone?
06:34:51 <shapr> pythonist: What sort of arrows question?
06:35:09 <shapr> I might be able to answer basic arrows questions.
06:35:27 <pythonist> I have two tuples (a1,b1) and (a2,b2)
06:35:54 <pythonist> Now, I want to apply two binary operators one for each component,
06:36:02 <shapr> mar77a: The simplest piece of code you could start with would cut a file into words. Can you write that?
06:36:30 <mar77a> shapr: no, i'll read on that
06:36:32 <pythonist> i.e. f (a1,b1) (a2,b2) = (a1 `f` a2, b1 `g` b2)
06:36:55 <shapr> mar77a: Can you cut a line of text into separate words?
06:36:56 <pythonist> I know the (***) operator,
06:37:06 <Taejo> what module defines (%) ?
06:37:11 <shapr> Taejo: Data.Ratio
06:37:22 <Taejo> shapr, thanks
06:37:25 <pythonist> but it works only for functions taking a single argument.
06:37:28 <mar77a> no shapr
06:37:38 <pythonist> Does exist anything working with binary functions/oiperators?
06:37:45 <shapr> mar77a: Do you know that a String is a list of Char values?
06:37:46 <pythonist> The only solution I came up with is:
06:38:03 <pythonist> uncurry (***) . (f *** g)
06:38:19 <shapr> pythonist: That sounds right.
06:38:28 <pythonist> which is clean and polite, but maybe it has been defined elsewhere.
06:39:08 <shapr> mar77a: Do you know how to drop items from a list?
06:39:10 <pythonist> BTW, (a1 `f` a2, b1 `g` b2) is more readable, but not in poit free style... >D
06:39:11 <pythonist> :D
06:39:39 <shapr> Point free style gets more readable the more time I spend on #haskell seeing @pl commands go past.
06:39:46 <shapr> I think it's just whatever you're used to reading.
06:39:54 <mar77a> shapr: i know the first, not sure about how to drop
06:40:01 <pythonist> shapr: agreed.
06:40:02 <mar77a> drop as in erase, right?
06:40:09 <pythonist> One more thing,
06:40:25 <shapr> pythonist: If you like the infix f and g better, you should use it!
06:40:36 <pythonist> if I input this in ghci:
06:40:45 <shapr> mar77a: Sort of, yeah. Do you know how to filter items in a list?
06:40:50 <pythonist> uncurry (***) . ((+) *** (zipWith (+)))
06:40:52 <Sizur> is it possible in haskell to do this: (a,b) -> a|b?
06:40:59 <mar77a> shapr: list comprehensions, map?
06:41:03 <psi> (a1 `f` a2, b1 `g` b2) is a million times more readable to me :)
06:41:05 <Deewiant> @pl f (a1,b1) (a2,b2) = (a1 `f` a2, b1 `g` b2)
06:41:06 <lambdabot> f = fix ((`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip g . (((.) . flip . (((.) . (,)) .)) .))
06:41:11 <Deewiant> :-)
06:41:20 <pythonist> I get (Num b, Num a) => (b, [a]) -> (b, [a]) -> (b, [a])
06:41:24 <pythonist> which is correct.
06:41:39 <Sizur> @users
06:41:39 <lambdabot> Maximum users seen in #haskell: 420, currently: 386 (91.9%), active: 13 (3.4%)
06:41:48 <pythonist> If I define the very same expression as a function
06:41:59 <pythonist> and the import it in ghci asking for its type, I get:
06:42:04 <psi> 420, is that a sign?
06:42:18 <shapr> The answer!
06:42:37 <pythonist> prodOp :: (Integer, [Integer]) -> (Integer, [Integer]) -> (Integer, [Integer])
06:42:41 <pythonist> prodOp is the name of the function I defined.
06:42:51 <shapr> mar77a: Yeah, but there's specifically a filter function as well. I'd suggest you look through the Prelude and try out the functions there. Feel free to ask any questions.
06:43:08 <pythonist> Why does it narrow the type of a and b to Integer?
06:43:38 <shapr> mar77a: The Prelude functions are used really often, learning them and using them will likely communicate the Haskell functional viewpoint to you.
06:43:39 <Sizur> guys, is something like this possible in haskell? (a,b) -> (a | b)
06:43:50 <shapr> Sizur: What does the a | b mean in that case?
06:43:51 <quicksilver> Sizur: what do you mean? what does | mean?
06:44:06 <shapr> in stereo...
06:44:11 <pythonist> Sizur: list cons?
06:44:20 <Sizur> polymorphic projection
06:44:22 <shapr> Or alternate constructors like Either?
06:44:25 <Sizur> | = or
06:44:28 <ToRA> @type uncurry (||)
06:44:31 <yaxu> (a, b) -> Either a b
06:44:31 <lambdabot> (Bool, Bool) -> Bool
06:44:44 <Taejo> is (%) a constructor?
06:44:56 <quicksilver> Sizur: well Either is the or type, but I'm not really sure what you're after
06:45:17 <quicksilver> Sizur: certainly that type is realisable, but the polymorphic realisations aren't very interesting
06:45:25 <Sizur> i want to have a projection function for tuples based on the type needed
06:45:26 <quicksilver> :t \(a,b) -> Left a
06:45:34 <quicksilver> :t \(b,a) -> Right b
06:45:36 <shapr> Sizur: Are you familiar with the Either type?
06:45:40 <lambdabot> forall t t1 a. (t, t1) -> Either a t
06:45:40 <lambdabot> forall t t1 b. (t, t1) -> Either t b
06:45:41 <quicksilver> :t \(a,b) -> Right b
06:45:42 <lambdabot> forall t t1 a. (t, t1) -> Either a t1
06:45:57 <shapr> mar77a: Have you tried reading YAHT, Yet Another Haskell Tutorial? Or maybe tried the wikibook?
06:46:02 <quicksilver> Sizur: then it has to be a method
06:46:09 <quicksilver> Sizur: functions have a single type :)
06:46:20 <oerjan> > let pap p = uncurry (***) p in ((+),(-)) `pap` (1,2) `pap` (3,4)
06:46:23 <lambdabot>  (4,-2)
06:46:30 <mar77a> no shapr , i only read 'haskell for c programmers'
06:46:52 <Sizur> quicksilver: but it's not that hard for compiler to implement two, or three, or however dimentions a tuple has
06:47:00 <Taejo> > let denominator (a % b) = b
06:47:00 <lambdabot>  Parse error in pattern at end of input
06:47:01 <quicksilver> Sizur: what?
06:47:05 <Sizur> method
06:47:11 <quicksilver> Sizur: sorry, I'm not sure what you're saying...
06:47:12 <oerjan> pythonist: ^^ uncurry (***) is nearly Applicative <*> for pairs
06:47:14 <shapr> mar77a: I haven't read that, is it good?
06:47:16 <Taejo> what's wrong with that defn of denominator?
06:47:19 <quicksilver> Sizur: haskell functions have types.
06:47:24 <mar77a> shapr: well pretty short but yeah, interesting
06:47:38 <tehgeekmeister> ?src liftM
06:47:38 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:48:02 <Sizur> project1of3 :: (a,b,c,d) -> a|b|c|d (i know | is not valid)
06:48:04 <quicksilver> Sizur: you need to decide what type you want :)
06:48:23 <quicksilver> Sizur: well that's not a unique type.
06:48:29 <quicksilver> Sizur: you could use a typeclass
06:48:32 <Sizur> it's 4 functions
06:48:35 <quicksilver> right
06:48:38 <quicksilver> exactly.
06:48:43 <oerjan> Taejo: % is a wrapper around the hidded :%
06:48:50 <oerjan> it's just a function
06:48:54 <oerjan> *hidden
06:49:01 <Sizur> but i dont want to write a separate function for every tuple type
06:49:13 <oerjan> which takes care of removing common factors
06:49:14 <Taejo> so can I get the denominator of a Ratio?
06:49:15 <Sizur> separate functions*
06:49:20 <quicksilver> Sizur: you mean for different tuples?
06:49:24 <Sizur> quicksilver: right
06:49:27 <oerjan> :t denominator
06:49:28 <quicksilver> Sizur: you mean different lengths, that is?
06:49:33 <Sizur> quicksilver: exactly
06:49:42 <lambdabot> thread killed
06:49:44 <Taejo> oerjan, thanks
06:49:53 <quicksilver> haskell can't help you, because there is no real 'uniformity' between tuple types
06:49:55 <Sizur> projection is a pretty common task
06:49:57 <oerjan> Taejo: don't thank me yet
06:50:00 <oerjan> :t denominator
06:50:00 <lambdabot> forall a. (Integral a) => Ratio a -> a
06:50:03 <quicksilver> you could ask something like metaprogramming to help you
06:50:10 <oerjan> Taejo: now you may :)
06:50:13 <quicksilver> e.g. TH or Data.Derive
06:50:34 <quicksilver> Sizur: you seem to be conflating two issues here
06:50:38 <Taejo> oerjan, ghci is faster than lambdabot: I already saw that when I thanked you
06:50:56 <quicksilver> (a) (a,b,c,d) -> a|b|c|d is four functions
06:51:03 <quicksilver> (b) you want it for different length tuples too
06:51:08 <quicksilver> Sizur: you could solve (a) with a typeclass
06:51:17 <quicksilver> [although I'm not sure it's a particularly good idea]
06:51:23 <quicksilver> (b) you need metaprogramming for
06:51:44 <sioraiocht> is there anywhere I can read more about dependent types?
06:51:49 <tehgeekmeister> ?src ap
06:51:49 <lambdabot> ap = liftM2 id
06:51:57 <sioraiocht> and wth they are?
06:52:01 <oerjan> Taejo: lambdabot was hanging on my first attempt for some reason
06:52:02 <Sizur> quicksilver: ok, how do i solve it with typeclasses? you mean implement a, b, c, d from (a,b,c,d)?
06:52:02 <shapr> sioraiocht: Have you read Types and Programming Languages by BC Pierce?
06:52:28 <sioraiocht> shapr: parts of it, i own it...
06:52:48 <shapr> sioraiocht: Dependent types are covered in there, though I forget which chapte.
06:52:50 <shapr> chapter*
06:53:29 <sioraiocht> shapr: thanks, I can stop just nodding when my Dphil supervisor brings them up...
06:54:18 <sioraiocht> (does anyone else do this?)
06:54:34 <swiert> sioraiocht: what do you want to know?
06:54:43 <sioraiocht>  I can stop just nodding when my Dphil supervisor brings them up...
06:54:46 <sioraiocht> lol
06:54:48 <quicksilver> Sizur: typeclasses can solve the problem of "pick the right function by the type of the context"
06:55:05 <quicksilver> Sizur: so if you want to automatically pick first, second, third or fourth basesd on the type of the context, a typeclass can do that
06:55:06 <sioraiocht> swiert: oh, did you mean about dependent types? anything, i don't know how they work
06:55:19 <quicksilver> Sizur: the problem you will have is, what do you do with (a,a,a)
06:55:21 <swiert> sioraiocht: there's a paper I wrote with kosmikus and Conor McBride, called "Simply Easy"
06:55:29 <sioraiocht> swiert: thanks
06:56:05 <swiert> sioraiocht: I found it quite useful to learn Coq, for example. CoqArt is nice in its own way.
06:56:07 <mar77a> 'thank you , good evening, welcome' where are those words from?
06:56:38 <pejo> swiert, for us mere mortals - isn't Coq and dependent types horribly complicated?
06:56:39 <mar77a> also shapr , can't find YAHT in html
06:57:03 <Sizur> quicksilver: that is an error case
06:57:31 <Sizur> quicksilver: i will make sure not to do that
06:58:45 <quicksilver> Sizur: then I think it's OK, although I'm not quite familiar with how these overlapping instances get resolved
06:58:51 <quicksilver> I think they're reported 'lazily' and so you're OK
06:59:01 <Sizur> quicksilver: so the tuple needs to be a class then, right?
07:00:42 <Sizur> quicksilver: then i need to implement that class with every tuple member type
07:01:11 <quicksilver> no
07:01:13 <quicksilver> you don't
07:01:13 <pi3> Is the standard function maximum O(n^2)?
07:01:29 <quicksilver> pi3: can't see why it would be
07:01:33 <tehgeekmeister> if i want to perform io in a program written with the continuation monad, i'd use io as the inner monad in a monad transformer, right?  (want to at least start off in the right direction since it's my first time writing actual code using monad transformers.)
07:01:38 <quicksilver> pi3: the naive algorithm for maximum is O(n)
07:02:00 <pi3> quicksilver: oh, ok
07:02:15 <quicksilver> Sizur: you have instance Project (a,b,c,d) a where project (a,_,_,_) = a
07:02:55 <Toxaris> Prelude> maximum [1..1000000]
07:02:55 <Toxaris> *** Exception: stack overflow
07:03:02 <oerjan> tehgeekmeister: yep.  since there is no IO transformer, IO is _always_ innermost if present.
07:03:19 <quicksilver> Sizur: for example; similar instances for b,c, and d
07:03:54 <tehgeekmeister> oerjan: oh, there isn't an IO transformer?  i guess that makes sense, there's no good reason to put other monads inside of it.
07:03:58 <oerjan> the same goes for ST, i should think
07:04:12 <oerjan> tehgeekmeister: it's more that it's impossible to write i think
07:04:13 <Sizur> quicksilver: that should do. thank you a lot :) then i just need a class for every length
07:05:12 <Toxaris> Prelude Data.List> foldl1' max [1..1000000]
07:05:12 <Toxaris> 1000000
07:05:33 <joelr1> @seen bringert
07:05:33 <lambdabot> I saw bringert leaving #ghc and #haskell 33m 27s ago, and .
07:05:53 <mar77a> @seen mar77a
07:05:54 <lambdabot> You are in #haskell. I last heard you speak just now.
07:05:58 <tehgeekmeister> oerjan: to me any monads are impossible to write, so that's a nonissue -- i take them as written by benevolent beings of higher intelligence in order to simplify my life.
07:05:58 <mar77a> ok!
07:06:16 <Toxaris> for what Ord instance is a foldr-maximum the right thing?
07:06:28 <oerjan> heh :)
07:07:09 <oerjan> Toxaris: lazy Naturals perhaps
07:07:36 <oerjan> @src maximum
07:07:36 <lambdabot> maximum [] = undefined
07:07:36 <lambdabot> maximum xs = foldl1 max xs
07:08:03 <oerjan> Toxaris: but it's the non-strictness that is the problem i think
07:08:27 <Toxaris> oerjan: yes, I mean foldl1 vs. foldl1'
07:09:01 <oerjan> i guess that's harder to justify
07:09:41 <faxathisia> hello
07:09:44 <Taejo> :t (**)
07:09:46 <byorgey> hey faxathisia
07:09:46 <lambdabot> forall a. (Floating a) => a -> a -> a
07:09:51 <Taejo> :t ^
07:09:51 <lambdabot> parse error on input `^'
07:09:53 <oerjan> although people say there are strange cases where foldl is the right thing
07:09:55 <Taejo> :t (^)
07:09:56 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:10:05 <mar77a> can someone help me find yet another haskell tutorial online an d in html format?
07:10:15 <byorgey> oerjan: AFAICT those cases are extremely contrived.
07:11:06 <quicksilver> Sizur: it's still just one class, actually
07:11:11 <quicksilver> Sizur: just lots of instances
07:11:16 <byorgey> mar77a: try http://en.wikibooks.org/wiki/Haskell/YAHT
07:11:51 <Sizur> quicksilver: is that multiparamtypes?
07:11:55 <quicksilver> Sizur: yes
07:12:08 <quicksilver> Sizur: first param is the tuple, second is the projected type
07:12:17 <phao> is haskell (beyond functional) object oriented, like common lisp is.
07:12:29 <quicksilver> phao: not per se, no
07:12:46 <quicksilver> phao: there are no direct object oriented constructs in haskell
07:13:04 <phao> sure, quicksilver are you the guy who helped me with sed?
07:13:06 <Cale> The closest thing to OO-ness is probably existential types
07:13:08 <quicksilver> phao: however it can be used to formulate OO-style abstractions as well as much more sophisticated ones
07:13:23 <quicksilver> I don't remember helping you with sed but it's not impossible
07:13:43 <phao> hmm
07:13:48 <byorgey> heterogeneous existentially typed lists FTW!
07:13:50 <phao> about \1 thing.. etc.
07:13:52 <faxathisia> phao: Have you seen any common lisp code written in an object oriented way?
07:13:54 <mux> Cale: I'd say type classes are much OO-like to me; existential types are related in the way that you can implement objects with it
07:13:59 <phao> faxathisia: yes.
07:14:07 <phao> some exemples in a book only
07:14:17 <mux> if you also have polymorphic record updates :)
07:14:17 <byorgey> faxathisia: well, there's CLOS
07:14:36 <mux> or is that just me?
07:14:59 <phao> thank you guys
07:15:49 <Cale> Typeclasses have one really major difference from classes in the OO sense in that the methods are separate from the data, which lets you make them polymorphic on the type of their result, for instance.
07:15:54 <mar77a> ok thanks byorgey
07:16:21 <quicksilver> mux: I would turn what you said quite around
07:16:22 <Sizur> quicksilver: thanks! it works
07:16:26 <quicksilver> typeclasses themselves are nothing like OO
07:16:35 <quicksilver> but a particular restricted sort of typeclass
07:16:40 <quicksilver> together with existentials
07:16:41 <quicksilver> can model OO
07:16:54 <quicksilver> (and here by OO I rally mean 'calss-based java-style OO'
07:17:01 <Toxaris> mux: OO is about objects, not about classes
07:17:33 <quicksilver> in particular, java-based classes would always translate into methods with front parameter 'a'
07:17:39 <quicksilver> and single-parameter type classes, at that
07:18:01 <Sizur> objects are mutable values, what is a contradiction according to mainstream math
07:18:24 <quicksilver> and neither the result type nor the other parameters would mentiond a
07:18:30 <quicksilver> so, a very restricted kind of typeclass
07:18:45 <pjd> Cale: you could describe typeclasses as a collection of generic functions flying in formation
07:18:50 <swiert> pejo: sorry - got distracted for a moment.
07:18:59 <quicksilver> pjd: not really 'generic' though
07:19:06 <quicksilver> pjd: 'generic' is true polymorphism
07:19:11 <quicksilver> pjd: more like 'type-indexed'
07:19:25 <swiert> pejo: Coq is a stable system that's pretty well-documented.
07:19:52 <swiert> pejo: If you try to do certain kinds of dependently typed programming with it, things can get quite nasty.
07:20:07 <faxathisia> why is it nasty?
07:20:16 <swiert> pejo: but it helped me understand a lot about the underlying type theory - and why dependently typed programming languages are hard.
07:21:09 <swiert> faxathisia: the "programming language" fragment of Coq is very limited: you can only write functional programs that are total (i.e. structurally recursive, no missing pattern matches).
07:21:44 <swiert> faxathisia: but once you start writing, say the head function on non-empty vectors, there are certain branches that are impossible.
07:22:12 <faxathisia> maybe you can use strongly specified functions
07:22:18 <faxathisia> to avoid that
07:22:49 <swiert> but then you run into the same problem.
07:23:03 <swiert> it's a problem with Coq - not with dep types in general.
07:23:04 <faxathisia> oh I thought that was one of the problems they solved..
07:23:17 <quicksilver> it's an interesting problem to solve, though
07:23:32 <quicksilver> epigram solves it and it's almost eerie the way it can prune impossible branches back
07:23:56 <mux> Cale, quicksilver: I understand that; I was mostly talking about feelings, what looks, or feels most like OO - at least to me - is definitely type classes even though i know full well the differences between the two
07:24:12 <mux> anyways :-)
07:24:15 <swiert> the programming language fragment of Coq is very restricted - once you want to do dependently typed programming you tend to get stuck in the "theorem proving part of the language" - where you have no idea what the program is that you're writing.
07:24:18 <faxathisia> epigram looks cool!
07:24:35 <swiert> mattam has done some really good work in that direction in Coq though (see his Program tactic).
07:24:50 * mux really needs to get up to speed with dependent typing
07:24:55 <faxathisia> is epigram subturing  as well?
07:25:24 <quicksilver> yes
07:25:28 <pejo> swiert, oh, no doubt that Coq can help you (as  a researcher) explore stuff.
07:25:38 <faxathisia> SQL and regex are
07:25:44 <swiert> quicksilver: yes. I think that the nice thing about epigram is that although there's quite a lot of work going on behind the scenes, it still feels like programming Haskell, as opposed to trying to program with Coq's weird tactic language.
07:25:51 <faxathisia> and are there other good subturing languages to look at?
07:27:15 <mux> if only I could use epigram without having to use xemacs
07:27:16 <swiert> faxathisia: why are you interested in subturing languages?
07:27:20 <mux> this is seriously boring me
07:28:05 <faxathisia> mux: If only xemacs would run I could try epigram!
07:28:12 <faxathisia> what's boring you?
07:29:01 <dcoutts_> mux: at one point there was a plan to rewrite the ui properly using gtk2hs and cairo etc. Axel and I went and did a presentation and training session. Unfortunately the post-doc who was going to do it disappeared into a higher paying industry job.
07:29:02 <faxathisia> swiert: I'm not sure, there's usually some unusual interesting properties about them though
07:29:11 <swiert> mux: I think the current installment of Epigram is not worth getting to work.
07:29:31 <swiert> mux: I'd seriously recommmend looking at Agda 2.
07:29:35 <swiert> @go Ulf Norell
07:29:37 <lambdabot> http://www.cs.chalmers.se/~ulfn/
07:29:37 <lambdabot> Title: Ulf Norell
07:29:40 <pejo> swiert, that just begs the question - when is Epigram 2 out? :-)
07:30:11 <swiert> pejo: I hear that there should be something capable of, say Vector append, in a few weeks.
07:30:23 <swiert> pejo: but I've been hearing this rumour for a while now :)
07:30:27 <faxathisia> What's good about Agda 2?
07:30:35 <fasta> When I run a program in Emacs in ghci and press C-c a million times, the program doesn't terminate immediately. My program calls external programs. I just want to use some method that instructs my computer to immediately stop the execution of the Haskell expression and everything depending on it.
07:31:27 <swiert> faxathisia: it's a version of Epigram 1 that actually works :)
07:31:28 <mux> swiert: thanks for the advice, I'll have a look at it now (bored at work, I'd do anything to escape Perl)
07:32:13 <swiert> mux: np. good luck.
07:33:40 <Taejo> > fix ("Infinity is awesome. " ++)
07:33:42 <lambdabot>  "Infinity is awesome. Infinity is awesome. Infinity is awesome. Infinity is ...
07:34:12 <mercury^> :P
07:34:29 <oerjan> > fix ("Infinity is awesome. " ++) ++ "Help! I am trapped in an infinite value!"
07:34:30 <lambdabot>  "Infinity is awesome. Infinity is awesome. Infinity is awesome. Infinity is ...
07:34:49 <Taejo> :)
07:34:50 <mercury^> Why the parentheses?
07:35:12 <Taejo> mercury^, I was demonstrating infinite values to a non-Haskeller
07:35:20 <oerjan> mercury^: it's section notation.
07:35:28 <oerjan> > (2 +) 2
07:35:30 <lambdabot>  4
07:35:36 <faxathisia> > fix "Infinity is awesome. " ++
07:35:39 <lambdabot>   parse error on input `}'
07:35:40 <oerjan> > map (2 +) [1,2,3]
07:35:40 <faxathisia> that's why :p
07:35:41 <lambdabot>  [3,4,5]
07:35:45 <mercury^> ah, ok
07:35:46 <mercury^> :)
07:35:53 <Taejo> oh right, I wasn't thinking, they are needed
07:36:00 <mar77a> map (^2) [0,1,2]
07:36:07 <mar77a> > map (^2) [0,1,2]
07:36:08 <lambdabot>  [0,1,4]
07:36:18 <mar77a> > map (^0) [1]
07:36:19 <lambdabot>  [1]
07:36:21 <mar77a> > map (^0) [0]
07:36:22 <lambdabot>  [1]
07:36:24 <mar77a> NOOOOOOO
07:36:31 <mar77a> HOW COULD YOU!?!
07:36:50 <Taejo> mar77a, integers don't have NaN
07:37:00 <mar77a> > map (^0.0) [0.0]
07:37:01 <lambdabot>  Add a type signature
07:37:08 <Taejo> and 0^0 == 1 is often useful, in integral contexts
07:37:09 <faxathisia> > fix ((++")") . ("("++)) "I'm trapped!"
07:37:10 <lambdabot>  Couldn't match expected type `[Char] -> t'
07:37:12 <Toxaris> > 0 ^ 0 :: Float
07:37:12 <lambdabot>  1.0
07:37:13 <faxathisia> !aww
07:37:22 <mar77a> pain
07:37:23 <oerjan> mar77a: it's perfectly correct for ^
07:37:26 <mar77a> lotsof paint
07:37:35 <mar77a> > :t pow
07:37:35 <lambdabot>   parse error on input `:'
07:37:37 <oerjan> you could argue more about **
07:37:40 <mar77a> :t pow
07:37:41 <lambdabot> Not in scope: `pow'
07:37:46 <Toxaris> > 0 ** 0 :: Float
07:37:47 <lambdabot>  1.0
07:37:49 <faxathisia> > iterate ((++")") . ("("++)) "?"
07:37:50 <lambdabot>  ["?","(?)","((?))","(((?)))","((((?))))","(((((?)))))","((((((?))))))","((((...
07:37:55 <faxathisia> > fix ((++")") . ("("++)) "?"
07:37:56 <lambdabot>  Couldn't match expected type `[Char] -> t'
07:38:15 <faxathisia> :t iterate
07:38:16 <lambdabot> forall a. (a -> a) -> a -> [a]
07:38:16 <faxathisia> :t fix
07:38:17 <lambdabot> forall a. (a -> a) -> a
07:38:34 <faxathisia> oah :|
07:38:54 <faxathisia> > fix ((++")") . ("("++)) -- how do you put somehting in the middle?
07:38:55 <lambdabot>  "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
07:39:28 <oerjan> > iterate (printf "(%s)") "?"
07:39:28 <lambdabot>  ["?","(?)","((?))","(((?)))","((((?))))","(((((?)))))","((((((?))))))","((((...
07:40:21 <Taejo> oerjan, nice!
07:40:24 <byorgey> faxathisia: you don't.
07:40:31 <oerjan> faxathisia: you don't, fix doesn't get to the base case _ever_
07:40:32 <faxathisia> but.. the faq
07:40:34 <mercury^> Which module is that "fix" function in?
07:40:46 <mux> @index fix
07:40:46 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
07:40:53 <mux> well, take the first one :-)
07:42:01 <oerjan> Taejo: it was more i realized printf for once needed no type annotation :)
07:42:02 <psi> > fix show -- this one is cool
07:42:15 <psi> or not
07:42:17 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:42:19 * faxathisia doesn't know what to do with haskell
07:42:19 <faxathisia> :(
07:43:07 <oerjan> faxathisia: or did you mean something else by in the middle?
07:43:20 <faxathisia> no I don't think so
07:43:47 <mercury^> fix vs yes, who takes bets? :)
07:44:15 <hpaste>  tehgeekmeister pasted "Unsuccessful first attempt at using continuations/monad transformers." at http://hpaste.org/4258
07:45:07 <tehgeekmeister> i think my issue is here is that one branch of my case expression has type IO () and another IO String
07:45:34 <allbery_b> you need t lift the putStrLn
07:46:04 <tehgeekmeister> in the case or the definition of ask?
07:46:08 <allbery_b> as is, when ghc sees the unlifted one it infers the type of ask as IO (something), not ContT ...
07:46:16 <tehgeekmeister> okay
07:47:10 <byorgey> mercury^: fix can beat up yes any day =)
07:47:21 <faxathisia> @@ 1+1
07:47:21 <lambdabot>  1+1
07:47:43 <byorgey> > fix ((1:) . scanl (+) 1)  -- bet you can't do this with yes...
07:47:45 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:48:04 <mercury^> Didn't mean in terms of functionality, but performance in the cases where functionality overlaps.
07:48:10 <faxathisia> > fix ("yes\n"++)
07:48:10 <lambdabot>  "yes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nyes\n...
07:48:35 <faxathisia> oops
07:48:38 <faxathisia> > fix ("y\n"++)
07:48:38 <lambdabot>  "y\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\n...
07:49:22 <Toxaris> > fix ((('(' :) .) . (. (++ ")"))) "faxathisia in the middle"
07:49:23 <lambdabot>  "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
07:49:31 <faxathisia> !!:D
07:51:19 <faxathisia> @keal
07:51:20 <lambdabot> there is no way to prove the failsafe exists
07:51:23 <faxathisia> @keal
07:51:23 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
07:51:46 <shapr> @protontorpedo
07:51:46 <lambdabot> please expalin pure and lazy a little (im igonorant i know)?
07:52:05 <faxathisia> @keal
07:52:05 <lambdabot> how do i search for someone saying 'Keal' in mirc
07:52:17 <faxathisia> @keal
07:52:17 <lambdabot> i aint running that on my puter
07:52:26 <EvilTerran> @quote faxathisia
07:52:28 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
07:52:36 <faxathisia> my quote got removed!
07:52:44 <faxathisia> I think lambdabot died several times
07:53:24 <oerjan> a tragic case of alzheimer's
07:54:33 <faxathisia> :t ((($).($)).(($).($))).((($).($)).(($).($)))
07:54:35 <lambdabot> forall a b. (a -> b) -> a -> b
07:55:04 <shapr> hoi reinierrr
07:55:09 <shapr> @users
07:55:09 <lambdabot> Maximum users seen in #haskell: 420, currently: 403 (96.0%), active: 19 (4.7%)
07:55:16 <reinierrr> hoi
07:55:19 <shapr> How's code?
07:55:24 <reinierrr> fine
07:55:26 <byorgey> anyone have any nice examples of Template Haskell being used to force calculation of CAFs at compile time?  I know I've seen some but I can't remember where.
07:55:30 <reinierrr> but i was just coming for a quick question
07:55:42 <Taejo> faxathisia, ((($).($)).(($).($))).((($).($)).(($).($))) == flip apply?
07:55:53 <reinierrr> what's the name of the extension that turns on multi-line string literals with backslashes?
07:55:56 <faxathisia> I don't have a clue
07:55:58 <faxathisia> :[[
07:56:12 <reinierrr> as in "this is one \
07:56:16 <reinierrr> \ big string"
07:56:17 <byorgey> Taejo: no, it's just id
07:56:27 <Sizur> how can i define a unary operator?
07:56:28 <quicksilver> reinierrr: I don't think that's an extension
07:56:34 <quicksilver> reinierrr: I think that's haskell 98
07:56:41 <quicksilver> Sizur: f 5 = -5
07:56:41 <reinierrr> it works in GHC
07:56:46 <reinierrr> but fails when I build via Cabal
07:56:46 <allbery_b> it's haskell98
07:56:48 <quicksilver> Sizur: f is a unary operator :)
07:56:50 <shapr> reinierrr: Maybe -fglasgow-exts ?
07:57:03 <byorgey> > let (!) n = product [1..n] in (10!)
07:57:03 <lambdabot>  3628800
07:57:06 <reinierrr> indeed, -fglasgow-exts does the trick, but that's what I'm trying to avoid
07:57:07 <quicksilver> reinierrr: that's probably because something is running cpp over the code?
07:57:15 <faxathisia> :O
07:57:24 <byorgey> Sizur: that works too, although the parentheses around (10!) are required
07:57:27 <reinierrr> quicksilver: there you have a point
07:57:29 <Sizur> quicksilver: what if i want to use a symbol for aesthetic reason
07:57:31 <faxathisia> > let n ! = product [1..n] in (10!)
07:57:32 <lambdabot>  Parse error at "=" (column 9)
07:57:47 <faxathisia> hows that work
07:57:55 <byorgey> Sizur, faxathisia: ^^^ see my code above.
07:58:05 <faxathisia> but how does it work byorgey
07:58:09 <Syzygy-> Damn. Visiting other language channels just reinforces the vast greatness of #haskell.
07:58:18 <shapr> Syzygy-: What did you visit?
07:58:24 <Syzygy-> #rubyonrails
07:58:36 <shapr> It was good?
07:58:37 <byorgey> faxathisia: it defines ! as an infix function of one argument.  Then (10!) is an operator section.
07:58:38 <pharm> faxathisia: which bit?
07:58:43 <Syzygy-> shapr: Nope.
07:58:46 <shapr> oh
07:58:57 <Toxaris> > let (?) = "nullary operator" in (?)
07:58:58 <lambdabot>  "nullary operator"
07:59:10 <faxathisia> what!
07:59:17 <faxathisia> I thought operators had to be infix
07:59:21 <faxathisia> that's cool
07:59:25 <Syzygy-> shapr: I asked what I viewed as a basic question about how to prevent SQL injections. I took care to state all details, and generally behave like a Good IRC Citizen. I got answered by a ridicule of my particular choice of code formatting.
07:59:27 <byorgey> faxathisia: they do.
07:59:33 <faxathisia> It's not
07:59:35 <EvilTerran> it's because (`foo`) = foo
07:59:43 <EvilTerran> and (foo `bar`) = bar foo
07:59:58 <byorgey> Syzygy-: =P
08:00:00 <shapr> Syzygy-: That sucks.
08:00:28 <Toxaris> > let (?) c t e = if c then t else e in (False ? "") "more arguments possible"
08:00:34 <lambdabot>  "more arguments possible"
08:00:40 * faxathisia is disappointed that SQL has always got such bad interfaces
08:00:58 <faxathisia> why don't they use combinators or something like that to compose SQL queries
08:01:02 <esap> SQL is the interface :-)
08:01:05 <faxathisia> textual substitution was a awful idea
08:01:08 <faxathisia> esap: That's the problem!
08:01:30 <hpaste>  tehgeekmeister annotated "Unsuccessful first attempt at using continuations/monad transformers." with "New error -- how do I abort the loop?" at http://hpaste.org/4258#a1
08:01:33 <mar77a> Syzygy-: being db a Mysql connection pointer or whatever the name is, you use db.escape_string(string) which returns the escaped string
08:01:55 <Syzygy-> mar77a: Right. Thanks!
08:01:57 <reinierrr> so always ask your Ruby questions on #haskell
08:02:08 <Syzygy-> Ooookay. This is amazing. I'm getting better RoR answers in #haskell than in #rubyonrails.
08:02:08 <shapr> hah
08:02:14 * shapr grins
08:02:15 <Syzygy-> I don't know why I ever bothered even trying. ;)
08:02:25 <mar77a> well im just helping you out cause i know some ruby
08:02:37 <mar77a> maybe i should've used pm tsk tsk
08:02:43 <shapr> Here on #haskell we barter Haskell knowledge for just about anything else.
08:02:46 <Syzygy-> mar77a: While I have you around - why aren't my Model.new(:blah => value, :blah => value) actually updating the database?
08:03:04 <mar77a> i've no clue what that is Syzygy-
08:03:11 <Syzygy-> mar77a: Ah. Rails-isms.
08:03:11 <mar77a> i usually do something like
08:03:15 <mar77a> ohh
08:03:18 <mar77a> don't know RoR, jsut ruby
08:03:22 <mar77a> just*
08:03:22 <Syzygy-> Right. :P
08:03:33 <mux> Syzygy-: oh man, your formatting sucks!! ;-)
08:03:48 <Syzygy-> mux: Thanks. Very heartwarming.
08:03:52 <faxathisia> lol
08:03:53 <shapr> hah
08:03:57 <shapr> @slap mux
08:03:57 * lambdabot moulds mux into a delicous cookie, and places it in her oven
08:04:01 <Syzygy-> mux: At least you don't get offended when I ask whether the formatting change is in any way relevant...
08:04:05 * shapr grins
08:04:09 <mux> heh
08:04:14 <tehgeekmeister> i know i'm not using the right method to break out of the continuation monad, how do i do it?  all the examples i've seen using continuations do much simpler things than this, so i'm not sure, and this example goes right in the direction i need to eventually anyway.
08:04:15 <Syzygy-> (and if you do, I know you enough to ignore it)
08:04:33 <shapr> tehgeekmeister: Now there's something I bet they don't see much on #rubyonrails
08:05:04 <tehgeekmeister> shapr: monads?  i'd guess not...
08:05:11 <shapr> Or CPS
08:05:16 <tehgeekmeister> oh, that too.
08:05:17 <tehgeekmeister> =]
08:05:22 <mux> or intelligent discussion
08:05:39 <shapr> I've read some blog posts from really smart guys in the RoR community, so I hope they get some of that.
08:06:09 <mux> I have no hope for any programming language's IRC channel but #haskell
08:06:11 <EvilTerran> #perl has Randall Schwartz, which is quite cool
08:06:14 <esap> tehgeekmeister: what do you mean "break out"? does runCont do it?
08:06:45 <EvilTerran> @src runCont
08:06:45 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:07:06 <EvilTerran> @src Cont
08:07:07 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
08:07:39 <oerjan> @remember Syzygy- Ooookay. This is amazing. I'm getting better RoR answers in #haskell than in #rubyonrails.
08:07:39 <lambdabot> It is stored.
08:07:45 <tehgeekmeister> esap: if you look at my code http://hpaste.org/4258#a1, it should be very clear what i'm trying to do.  the end goal is a sort of loop that takes emulates a flowchart sort of a process, but this is a first iteration to get my types sane and such.
08:08:30 <mux> I think the worse is by far #C
08:08:54 * EvilTerran notes that there seems to be no #c#
08:08:55 <tehgeekmeister> esap: this version just loops once more if you say yes, aborts if you say no, and is undefined if you do anything else (for now).
08:09:11 <mux> #C is a contest in stupidity
08:09:14 <mar77a> EvilTerran: it's too easy :>
08:09:48 <EvilTerran> there's #csharp, but it's only got 7 people in it, apparently
08:10:42 * faxathisia can't come up with an idea for what to code :[
08:10:54 <mar77a> aaaaaa sockets
08:11:00 <Sizur> where can i find what character restrictions we have on operators?
08:11:10 <oerjan> faxathisia: tetris!
08:11:10 <mux> Sizur: in the haskell 98 report
08:11:16 <mux> @where report
08:11:16 <lambdabot> http://www.haskell.org/onlinereport/
08:11:20 <tehgeekmeister> faxathisia: you can always solve my problems for me, if you're that desperate for things to do
08:11:25 <faxathisia> I've written tetris enough times already!
08:11:38 <oerjan> oh
08:11:44 <mar77a> @quote ruby
08:11:44 <lambdabot> Syzygy- says: Ooookay. This is amazing. I'm getting better RoR answers in #haskell than in #rubyonrails.
08:11:53 <mar77a> heh
08:12:03 <pejo> faxathisia, I think there's lots of existing stuff around you could hack on if you wanted
08:12:10 <Toxaris> faxathisia: I would love to have an extensible Java compiler written in Haskell.
08:12:13 <mar77a> the guy who redirected me to this channel told me i'd find a nice bunch
08:12:13 <hpaste>  fxr pasted "compilation problem" at http://hpaste.org/4259
08:12:14 <Sizur> not  special   ->  ( | ) | , | ; | [ | ] | `| { | }. thanks
08:12:31 * mux wonders if his laptop will melt before Agda2 is fully built (128 of 154)
08:12:39 <faxathisia> tehgeekmeister: Well I don't know how to solve your problem (I did look), and maybe it's not directly relevant but this is really nice and might help
08:12:40 <faxathisia> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
08:12:43 <mux> both CPU cores are at 74C already :-)
08:12:58 <faxathisia> Toxaris: Why?
08:13:07 <Toxaris> faxathisia: to extend it
08:13:10 <faxathisia> pejo: Is there a list, just wondering?
08:13:34 <tehgeekmeister> faxathisia: oh, well any more information on monad transformers is useful, so thanks.  from what i've heard of CPS it should be trivial to do what i want, i'm just not quite sure how yet...
08:13:43 <pejo> faxathisia, ghc is the most obvious candidate - always something to improve there. :-)
08:14:59 <darrint> Is there an example online showing how to write a function of type ListT IO a ?
08:16:08 <esap> tehgeekmeister: I'm wondering why you think you can invoke callCC in the second argument of runContT? Wouldn't you need two nested continuation monads then?
08:16:25 <Toxaris> faxathisia: I'm atm working with http://jastadd.cs.lth.se/web/ wich feels a little bit like a serious language (attribute grammar based with lazy evaluation of circular attributes) but is implemented as a java preprocessor
08:16:26 <lambdabot> Title: JastAdd
08:16:55 <Sizur> byorgey: there is no way to have an unary operator without using sections?
08:17:08 <byorgey> Syzygy-: I think Model.new doesn't actually write to the database by design.  You have to call .save on it.
08:17:13 <byorgey> Sizur: no, I don't think so.
08:17:50 <fasta> tehgeekmeister: I am not sure whether your question has been answered yet, but you are not doing anything with the continuations.
08:17:53 <tehgeekmeister> esap: maybe i can't?  i don't know how the mechanics of this work very well yet, which is why i'm writing this trivial deal first.
08:18:22 <tehgeekmeister> fasta: i'm not?
08:18:35 <tehgeekmeister> *how this work
08:18:47 <esap> tehgeekmeister: the continuation monad code is the first argument to runContT.
08:19:16 <fasta> tehgeekmeister: and you seem to be using continuations for the wrong purpose.
08:19:25 <tehgeekmeister> esap: then the second argument should always be the last computation to be run?
08:19:50 <faxathisia> Toxaris: I wonder how much work it would be to generate .class files from a simple imperative language
08:19:59 <dons> ?/users
08:19:59 <lambdabot> Maximum users seen in #haskell: 420, currently: 407 (96.9%), active: 24 (5.9%)
08:20:03 <fasta> tehgeekmeister: I use cont only when I need to escape from a computation in practice, I know some other applications that make some code run faster, but otherwise they have little use.
08:20:23 <faxathisia> hi dons
08:20:36 <esap> tehgeekmeister: The second argument is the "rest of the program" but *in the embedded monad*. So it would be pure IO monad code in your case, if you embed IO monad in the transformer.
08:20:40 <tehgeekmeister> fasta: very possible, i'm already certain i could do the same thing with recursive do expressions, but for some reason it seemed like i should try to use continuations.  now that i realize i had no good reason, i'm wondering why i tried it at all...
08:20:42 <pejo> faxathisia, oh yeah - I bet dons has lots of suggestions of things to make or fix. Good idea!
08:20:50 <faxathisia> ehehe
08:21:52 <tehgeekmeister> esap: okay.
08:23:10 <esap> tehgeekmeister: if you don't want anything, just use "return" as the second argument.
08:23:39 <hpaste>  fxr pasted "happs hello test" at http://hpaste.org/4260
08:24:45 <byorgey> hey dons, do you have any examples of using Template Haskell to evaluate CAFs at compile time? ISTR seeing you do that at some point, but I can't seem to find any examples.
08:24:58 <Syzygy-> byorgey: Yeah, I figured out. After quite a bit of annoying searching.
08:24:58 <Toxaris> faxathisia: java bytecode is quite simple, not too much work I would say. the .class-file format contains some twists (e.g. it contains information about stack layout at various points of execution), but there are tools doing the needed analysis for you.
08:25:00 <Syzygy-> Thanks.
08:25:58 <byorgey> Syzygy-: heh, yeah.  It's actually nice since it gives you more control over validation and such.
08:26:48 <tehgeekmeister> esap: the idea is to be able to have a set of different questions which direct to other questions based on the response to the previous one, exactly like following a flowchart, i have no clue if continuations are really the best way to do that or not, but i think i could do it without them.
08:27:02 <faxathisia> tools in haskell?
08:27:02 <byorgey> Syzygy-: sure.  If you have more RoR questions I may be able to help -- it's been a while but I knew quite a bit at one point.
08:27:28 <Toxaris> faxathisia: on the other hand, if you're writing a whole compiler, you should have that information available anyway, since you planned stack layout :) why do you ask?
08:27:54 <faxathisia> was thinking about maybe doing it..
08:27:57 <faxathisia> I doubt it though
08:30:15 <esap> tehgeekmeister: Continuations are very powerful (and thus hard to use). It all depends on what you want to do. For "normal" control flow, you don't need continuations.
08:31:14 <bringert> does anyone know a reference for rank-2 polymorphism is haskell?
08:31:21 <bringert> I can't seem to find any papers about it
08:31:59 <hpaste>  shapr annotated "happs hello test" with "siege on my box" at http://hpaste.org/4260#a1
08:33:50 <shapr> bringert: Ask Oleg?
08:34:06 <pejo> shapr, is 'Oleg' here the Oleg?
08:34:06 <faxathisia> @quote Oleg
08:34:06 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
08:34:18 <shapr> pejo: I don't think so.
08:36:27 <oerjan> there's an Oleg in the channel?
08:36:49 <byorgey> don't think so.
08:37:11 <shapr> @seen oleg
08:37:11 <lambdabot> I haven't seen oleg.
08:37:21 <byorgey> the \bot 'Oleg' quotes are from THE Oleg, but not because he said them on IRC, I think.
08:37:34 <faxathisia> @oleg
08:37:37 <lambdabot> Defined.
08:37:41 <faxathisia> ...lol
08:37:42 <faxathisia> what
08:37:43 <byorgey> hehe
08:37:52 <matthew_-> I think it would slightly destroy the mighty myth of the ledgend of Oleg were he to actually appear here
08:37:54 <byorgey> 'oleg' has an edit distance of 2 to 'let'
08:38:01 <faxathisia> haha
08:38:17 <faxathisia> @quote Oleg
08:38:17 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
08:38:24 <faxathisia> is there only one >:|
08:38:33 <tehgeekmeister> okay, i can do it without continuations painlessly, no continuations then.
08:38:38 <matthew_-> that's /so/ doable
08:38:47 * matthew_- plans to knock that up over the wkend
08:39:16 <byorgey> faxathisia: I don't know.  if you keep calling '@quote Oleg' you could possibly disprove it, but not prove it...
08:39:30 <faxathisia> @@ @quote Oleg @quote Oleg
08:39:30 <lambdabot>  No quotes match. stty: unknown mode: doofus
08:40:53 <oerjan> @quote oleg
08:40:53 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
08:42:50 <hpaste>  shapr annotated "happs hello test" with "siege with -O2" at http://hpaste.org/4260#a2
08:44:32 <hpaste>  shapr annotated "happs hello test" with "./hello without +RTS -N 2" at http://hpaste.org/4260#a3
08:44:34 <hpaste>  tehgeekmeister annotated "Unsuccessful first attempt at using continuations/monad transformers." with "Two new noncontinuation based versions... (with insane recursive fun!)" at http://hpaste.org/4258#a2
08:45:02 <tehgeekmeister> it was easy for the trivial case, not so easy for the generalized case.  i made need continuations after all.
08:45:05 <fxr> I'm looking for a way to declare ghc-options for every packet that I build. any ideas? is there any global configuration for cabal
08:45:15 <faxathisia> tehgeekmeister: What's the point in this program?
08:45:24 <faxathisia> tehgeekmeister: It just loops until you tell it to qiut
08:47:01 <tehgeekmeister> faxathisia: for now, yes.  eventually it should take arbitrary string lambda pairs which will emulate the process of following a flowchart, that's why i generalized the second version to take a string and a lambda, but as you can see i found a problem in writing the lambda.
08:47:19 <faxathisia> cool!
08:47:56 <faxathisia> :t lookup
08:47:57 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:48:05 <tehgeekmeister> if only i can make that lambda of non-infinite size i'll be set.
08:48:16 <faxathisia> why would it be infinite size?
08:48:22 <faxathisia> YOu can index on the string alone surely?
08:49:07 <tehgeekmeister> well, as i have it written now, the lambda has to include itself, and that inner lambda would have to include itself, and so on...
08:49:19 <tehgeekmeister> but your suggestion of lookup might solve the problem
08:49:22 <faxathisia> :t let s = t ; t = s in [("s", s), ("t", t)]
08:49:25 <lambdabot> forall t. [([Char], t)]
08:49:26 <tehgeekmeister> i'll have to refamiliarize myself with it.
08:49:31 <faxathisia> hey you can do mutual recursion that way!
08:49:43 <faxathisia> s and t are "lambdas"
08:49:56 <faxathisia> yeah if you had like [([Char], t)] .. you  can use lookup on it
08:50:37 <tehgeekmeister> oh, lookup is just looking up a value in an association list, isn't it?
08:50:52 <faxathisia> > lookup "foo" [("foo", "bar")]
08:50:54 <lambdabot>  Just "bar"
08:50:58 <tehgeekmeister> this solves my problem!
08:51:00 <tehgeekmeister> w00t!
08:51:14 * tehgeekmeister starts hacking
08:51:58 <oerjan> :t Data.Map.lookup
08:51:58 <tehgeekmeister> i'm sure glad i didn't stick with continuations when there was an option this simple available...
08:51:59 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
08:53:32 <tehgeekmeister> hey, what's up with hoogle being broken?  it makes looking up documentation a lot harder.
08:54:03 <oerjan> not updated for 6.8.1 yet
08:54:21 <hpaste>  byorgey annotated "Unsuccessful first attempt at using continuations/monad transformers." with "How about this?" at http://hpaste.org/4258#a3
08:54:35 <byorgey> tehgeekmeister: there's no problem with the recursive 'ask s f' version.
08:54:37 <dons> continuations eh?
08:54:44 <byorgey> tehgeekmeister: you just have to name things.
08:55:30 <tehgeekmeister> byorgey: doesn't work very well with the end goal, but definitely a workable solution.
08:56:03 <byorgey> tehgeekmeister: what's the end goal?
08:56:22 <dcoutts_> dons: had you ever realised before this thing about doing layered monads in a cont style allows you to bypass the underlying monad's >>= much of the time and only use it when necessary rather than on every use of the overall >>=
08:56:34 <faxathisia> tehgeekmeister: I don't like "ask"
08:57:00 <tehgeekmeister> byorgey: it should take string lambda pairs and emulate the process of following a flowchart
08:57:02 <tehgeekmeister> faxathisia: oh?
08:57:24 <MyCatVerbs> @hoogle [a] -> [a] -> Bool
08:57:25 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
08:57:25 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
08:57:40 <byorgey> 'ask' is a method of the MonadReader type class
08:57:52 <tehgeekmeister> oh, right.  i'd forgotten.
08:58:09 <tehgeekmeister> name can be changed, that's a bad conflict.
08:58:37 <dcoutts_> dons: so I talked briefly with Oege and Richard Bird today. They suggested asking for between 3 and 6 months for the jfp paper.
08:59:10 <faxathisia> tehgeekmeister: Do you have an example flow chat? Why not show a haskell representation of it
09:00:36 <tehgeekmeister> faxathisia: no, i don't yet, the idea is that the flowchart should be able to be arbitrarily complex, including, at some stage, the lambda interacting with the outside world before determining what question to direct to next.
09:01:18 <faxathisia> sick why don't you reify one
09:01:37 <tehgeekmeister> i probably will in the coming days
09:01:50 <tehgeekmeister> i potentially have work in a few hours, however, so it's probably not going to happen today.
09:01:53 <faxathisia> well then I'll need to find something to do...
09:02:07 <dons> dcoutts_: re. Cont -- hadn't  thought of that!
09:02:11 <dons> dcoutts_: 3-6 months seems ok
09:02:43 <dcoutts_> dons: it wasn't my discovery, someone here on #haskell, I can't remember who exactly.
09:03:28 <byorgey> hi dons, did you see my question above about Template Haskell examples?
09:03:31 <tehgeekmeister> faxathisia: however, if i don't have work, which is a possibility (the mill i'm working at currently got flooded yesterday), then i'll be working on it soon, so don't get too downtrodden.
09:03:49 <tehgeekmeister> anyway, i'm off for now.
09:07:21 <quicksilver> dcoutts_: doesn't that just mean you're doing the layering the other way up? or is there more to it than that?
09:08:47 <dcoutts_> quicksilver: I don't think so. My intuition is that you're only connecting things together at the lower >>= layer occasionally, while connecting things at the top level >>= all the time. So only certain primitives in the top layer need to connect via >>= in the bottom layer.
09:10:45 <quicksilver> dcoutts_: interesting. Of course that's really true of ordinary layering...
09:10:54 <quicksilver> dcoutts_: lift (a >> b) == lift a >> lift b
09:11:19 <quicksilver> is an algebraic rule which lift ought to be expected to obey
09:16:24 * EvilTerran tries and fails to work out where the trys should go in his parsec parser
09:16:35 <faxathisia> everywhere!
09:16:41 <faxathisia> I put try on almost everything :P
09:16:45 <faxathisia> and it seems to work ok
09:16:55 <EvilTerran> can't be good for efficiency
09:16:58 <quicksilver> I use backtracking parsers by default
09:17:01 <quicksilver> always works fine for me
09:17:07 <faxathisia> It is the difference between 0.0002 and 0.00002 seconds :p
09:17:10 <quicksilver> I've prbably never had a complex parser in a tight loop :)
09:17:26 <dons> i'm so happy wadler's writing haskell code again :)
09:17:47 <esap> again? did he ever stop? :-)
09:17:52 * EvilTerran would be using ReadP, but i'm parsing from a stream of tokens...
09:17:58 <dons> > let m+0 = m ; m+(n+1) = (m+n)+1 in 7 + 9
09:17:58 <lambdabot>  Parse error in pattern at "in" (column 33)
09:18:07 <dons> ah, no n+k
09:21:31 <pejo> dons, talking about his blog, or something else?
09:22:23 <dons> yeah
09:31:34 <dons> http://programming.reddit.com/info/624f2/comments/
09:31:39 <dons> `A first encounter with Arrows in Haskell '
09:38:03 <xinming> (Reader r) >>= f = Reader $ \e -> f (r e) e     <-- In this example, Is the function f should accept 2 parameters?
09:38:50 <quicksilver> xinming: yes
09:39:03 <quicksilver> xinming: one parameter is passed to it by 'bind', i.e. >>=
09:39:15 <quicksilver> xinming: the second parameter is passed to it implicitly by the nature of the reader monad
09:39:33 <quicksilver> > ((+1) >>= (*)) 5
09:39:35 <lambdabot>  30
09:39:45 <quicksilver> ^^ observe: (+1) takes one parameter, (*) takes two
09:39:54 <Nafai> I wonder how jdh feels about Factor being more popular than OCaml on the TIOBE list :)
09:40:52 <xinming> quicksilver: How does your example return the result of 30?
09:41:39 <quicksilver> xinming: (5+1) * 5 = 30
09:41:40 <xinming> 5+1 * 5?
09:41:43 <xinming> Oh, thanks
09:41:43 <quicksilver> right
09:41:46 <xinming> (5+1)
09:41:59 <oerjan> :t uncurry (***)
09:42:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
09:42:07 <quicksilver> xinming: in thre reader monad, every action has one parameter left unfilled
09:42:16 <quicksilver> xinming: this parameter is supplied by the "environment"
09:42:23 <quicksilver> xinming: in my case, the environment was 5
09:42:42 * doserj is trying to wrap his head arounds the argument order in wadler's (^^^)
09:43:47 <gwern> I are has a question: I am reading a Clean research paper, which makes heavy use of 'dynamics', apparently they are functions which you can write out to a file and then read'em back in and use them later as normal
09:44:15 <quicksilver> gwern: we dont' have an implementation of transparent persistence for code thunks at the moment
09:44:20 <quicksilver> gwern: if that's your question
09:44:26 <quicksilver> gwern: people have talked about it, though
09:44:36 <gwern> quicksilver: it might be, although your terminology seems to be different
09:44:56 <xinming> quicksilver: BTW, for monad laws, The multiple parameters for an action isn't spcified. does it mean, If there is an action which will return the (m a), It's not monad?
09:45:17 <quicksilver> xinming: there aren't really any "not" rules
09:45:24 <quicksilver> xinming: a monad must have >>= and it must have return
09:45:28 <quicksilver> xinming: and they must obey the rules
09:45:36 <quicksilver> xinming: it's allowed to have more stuff if it wants too :)
09:45:45 <quicksilver> all real monads have other, specific, functions, too
09:45:50 <gwern> quicksilver: is there anything even similar to Clean's dynamics?
09:45:56 * doserj concludes that wadler means "[True,False]^^^names", not the other way round.
09:46:03 <quicksilver> gwern: no; we can't write out code
09:46:17 <quicksilver> gwern: although someone has mentioned that they think there is a neat way to do it
09:46:21 <quicksilver> I can't remember who it was :(
09:46:25 <quicksilver> sjanssen: you, perhaps?
09:46:26 <gwern> quicksilver: no links huh...
09:46:44 <gwern> do you remember the terminology they used? maybe some assiduous googling could turn it up
09:47:06 <quicksilver> code serialisation? code persistence?
09:47:08 <quicksilver> something like that
09:48:51 <lQg> what would be the best way of evaluating nested notation?
09:49:03 <lQg> involving parenthesis
09:50:13 <lQg> I've really been hitting a brick wall here
09:50:54 <Cale> lQg: I'm not sure what you mean by that?
09:51:00 <gwern> darn, all the hits seem to be for serializing *data*, and not *code*
09:51:04 <rue> lQg: Are you parsing something?
09:51:15 <Stinger_> code is data ;)
09:51:36 <lQg> well i have propositional form equations (2v(1>3))&(3&4)
09:51:39 <lQg> style stuff
09:51:46 <hpaste>  fxr annotated "happs hello test" with "profiler output for happs hello example" at http://hpaste.org/4260#a4
09:51:53 <lQg> and i'm trying to convert them to CNF
09:52:18 <Cale> lQg: construct a datatype for representing those expressions, and use functions which pattern match against it.
09:52:43 <lQg> a datatype?
09:52:47 <Cale> Or is the problem with the parsing of strings?
09:53:26 <Cale> perhaps something like:  data Expr = Var String | And [Expr] | Or [Expr]
09:53:34 <roconnor> > map2 (,) [1,2,3] [True,False]
09:53:35 <lQg> well i've managed to convert the previously mentioned statement to (,2, ,(,1, ,-3,),),0,(,3,0,4)
09:53:35 <lambdabot>   Not in scope: `map2'
09:53:43 <oerjan> @let xs ^^^ [] = [ [] ] ; xs ^^^ (y:ys) = [ (y,x):e | x <- xs, e <- xs^^^ys ]
09:53:44 <Cale> Or like:  data Expr = Var String | And Expr Expr | Or Expr Expr
09:53:45 <lambdabot> Defined.
09:53:58 <roconnor> > liftM2 (,) [1,2,3] [True,False]
09:53:59 <lambdabot>  [(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
09:54:11 <oerjan> > [1,2] ^^^ [4,5]
09:54:12 <lambdabot>  [[(4,1),(5,1)],[(4,1),(5,2)],[(4,2),(5,1)],[(4,2),(5,2)]]
09:54:13 <roconnor> > length $ liftM2 (,) [1,2,3] [True,False]
09:54:13 <lambdabot>  6
09:54:47 <Cale> Then you can write things like  And (Or (Var "2") (Or (Var "1") (Var "3"))) (And (Var "3") (Var "4"))
09:54:56 <Cale> and pattern match against that
09:55:12 <Cale> f (And l r) = ...
09:55:52 <lQg> hmmm
09:55:58 <byorgey> > [1,2] ^^^ [3,4,5]
09:55:59 <lambdabot>  [[(3,1),(4,1),(5,1)],[(3,1),(4,1),(5,2)],[(3,1),(4,2),(5,1)],[(3,1),(4,2),(5...
09:56:08 <oerjan> there's got to be a simpler way of writing ^^^
09:56:54 <byorgey> Oh, I see, x ^^^ y is the list of all functions from y to x.  kind of seems backwards though.
09:56:59 <byorgey> oerjan: what is this from?
09:57:06 <oerjan> byorgey: wadler's blog
09:57:16 <oerjan> http://wadler.blogspot.com/
09:57:28 <lambdabot> Title: Wadler's Blog
09:57:29 <byorgey> oh, ok, I see it now
09:57:39 <doserj> byorgey: it's not really backwards
09:57:45 <oerjan> something with mapM or sequence...
09:58:27 <oerjan> > mapM (liftM (,) [3,4,5]) [1,2]
09:58:28 <lambdabot>  Couldn't match expected type `a -> a1'
09:58:41 <oerjan> not quite
09:58:52 <byorgey> doserj: hmm... oh, because it corresponds with set exponentiation notation?
09:59:02 <doserj> yes
09:59:19 <byorgey> ok, fair enough.
10:01:35 <Cale> > length [1..5] ^^^ [1..3]
10:01:36 <lambdabot>  Couldn't match expected type `[t1]' against inferred type `Int'
10:01:39 <Cale> > length ([1..5] ^^^ [1..3])
10:01:39 <lambdabot>  125
10:01:43 <Cale> > 5^3
10:01:44 <lambdabot>  125
10:03:46 <oerjan> > mapM (liftM (flip (,)) [1,2]) [3,4,5]
10:03:46 <lambdabot>  Couldn't match expected type `a -> a1'
10:04:21 <byorgey> doserj: I think you're right, he does mean [True,False] ^^^ names.
10:05:41 <oerjan> > mapM (flip map [1,2] . (,)) [3,4,5]
10:05:41 <lambdabot>  [[(3,1),(4,1),(5,1)],[(3,1),(4,1),(5,2)],[(3,1),(4,2),(5,1)],[(3,1),(4,2),(5...
10:06:29 <oerjan> > [1,2] ^^^ [3,4,5]
10:06:29 <lambdabot>  [[(3,1),(4,1),(5,1)],[(3,1),(4,1),(5,2)],[(3,1),(4,2),(5,1)],[(3,1),(4,2),(5...
10:07:35 <oerjan> @pl \xs ys -> mapM (flip map xs . (,)) ys
10:07:36 <lambdabot> mapM . (. (,)) . flip map
10:08:35 <doserj> > (mapM . flip (zip . repeat)) [True,False] [1..3]
10:08:35 <lambdabot>  [[(1,True),(2,True),(3,True)],[(1,True),(2,True),(3,False)],[(1,True),(2,Fal...
10:08:57 <doserj> > length $ (mapM . flip (zip . repeat)) [True,False] [1..3]
10:08:57 <lambdabot>  8
10:09:49 <doserj> > (mapM . flip (zip . repeat)) [True,False] [1..3] == [True,False] ^^^ [1..3]
10:09:49 <lambdabot>  True
10:10:26 <oerjan> > (mapM . (. (,)) . flip map) [True,False] [1..3] == [True,False] ^^^ [1..3]
10:10:26 <lambdabot>  True
10:10:35 <byorgey> @check \x (y :: [Int]) -> (mapM . flip (zip . repeat)) x y == x ^^^ y
10:10:35 <lambdabot>  Parse error in pattern at "->" (column 17)
10:10:52 <byorgey> @check \x y -> (mapM . flip (zip . repeat)) x y == x ^^^ (y :: [Int])
10:10:53 <lambdabot>  Add a type signature
10:11:04 <oerjan> :t flip (zip . repeat)
10:11:05 <lambdabot> forall b a. [b] -> a -> [(a, b)]
10:11:12 <byorgey> @check \x y -> (mapM . flip (zip . repeat)) x y == (x :: [Int]) ^^^ (y :: [Int])
10:11:15 <oerjan> :t (. (,)) . flip map
10:11:16 <lambdabot> forall a a1. [a1] -> a -> [(a, a1)]
10:11:18 <lambdabot> Terminated
10:11:23 <alfons> :t
10:11:31 <byorgey> oops, exponential blow-up =)
10:12:49 <oerjan> @check \bs a -> flip (zip . repeat) bs a == ((. (,)) . flip map) (bs::[Bool]) (a::Bool)
10:12:54 <lambdabot>  OK, passed 500 tests.
10:13:16 <oerjan> heh those parts are also identical
10:13:32 <byorgey> of course.
10:13:56 <oerjan> hm i guess they would have to be
10:14:23 <byorgey> > (zip . repeat) 3 [1,2,3]
10:14:32 <lambdabot>  [(3,1),(3,2),(3,3)]
10:15:19 <oerjan> @unpl ((. (,)) . flip map) bs a
10:15:19 <lambdabot> (map (((,)) a) bs)
10:15:41 <oerjan> @@ @pl @unpl ((. (,)) . flip map) bs a
10:15:41 <lambdabot>  map ((,) a) bs
10:15:42 * shapr lambda lifts
10:16:07 <shapr> Forget code katas, we have lambda lifting!
10:16:36 <alfons> :t
10:16:39 <opqdonut> :)
10:16:42 <shapr> :t alfons
10:16:42 <lambdabot> Not in scope: `alfons'
10:16:52 <shapr> alfons: You are out of scope! Time to buy mouthwash!
10:17:03 <byorgey> hehe
10:17:15 <oerjan> hm...
10:18:14 <oerjan> > (mapM . flip (map (,))) [1,2] [3,4,5]
10:18:15 <lambdabot>  Couldn't match expected type `a -> c'
10:18:32 <oerjan> argh
10:19:12 <shapr> alfons: How's code?
10:19:15 <oerjan> ah yes
10:19:29 <oerjan> > (mapM . flip (map . (,))) [1,2] [3,4,5]
10:19:29 <lambdabot>  [[(3,1),(4,1),(5,1)],[(3,1),(4,1),(5,2)],[(3,1),(4,2),(5,1)],[(3,1),(4,2),(5...
10:20:55 <oerjan> zip . repeat  is essentially Applicative use of ziplist, reducing to fmap
10:21:46 <tehgeekmeister> faxathisia: okay, no work today, i'm going to start on a basic example workflow now.
10:21:54 <oerjan> @unpl (mapM . flip (map (,))) xs ys
10:21:54 <lambdabot> mapM (\ c -> map (,) c xs) ys
10:21:59 <faxathisia> I'm trying to sleep!
10:22:18 <faxathisia> tehgeekmeister: I'm failing though so I'll probably check back later :p
10:22:24 <oerjan> argh
10:22:27 <oerjan> @unpl (mapM . flip (map . (,))) xs ys
10:22:28 <lambdabot> mapM (\ c -> map (((,)) c) xs) ys
10:22:35 <tehgeekmeister> okay, good luck.
10:22:43 <oerjan> @@ @pl @unpl (mapM . flip (map . (,))) xs ys
10:22:44 <lambdabot>  mapM (flip map xs . (,)) ys
10:32:50 <Phillemann> Trying to install pandoc produces the error message: "ghc-6.6.1: unknown package: regex-base-0.91 (dependency of regex-compat-0.90)"
10:33:19 <Phillemann> I've got regex-base-0.92 installed. Shouldn't this be backwards-compatible?
10:33:35 <shapr> You could hack the cabal file?
10:33:55 <shapr> Wait, does the cabal file explicitly say regex-base-0.91 ?
10:33:59 * shapr looks at pandoc
10:35:40 <Phillemann> It's pandoc-0.44 btw.
10:36:05 <shapr> Phillemann: the cabal file only says it depends on regex-base, I think you can fix it by using cabal to clean and configure before building.
10:36:10 <shapr> Oh, I don't know what version I have..
10:36:41 <tehgeekmeister> can i use a pattern along the lines of "a"|"b" in a case expression instead of having two branches with the same result?
10:37:10 <Phillemann> shapr: Well, pandoc does configure before producing this error. It says: "Configuring pandoc-0.44..." ... "Building pandoc-0.44...ghc-6.6.1: unknown package: regex-base..."
10:37:19 <EvilTerran> | "a" -> aOrB | "b" | aOrB | ... where aOrB = ...
10:38:10 <EvilTerran> or case str of ... [ch] | ch `elem` "ab" -> ...
10:38:22 <shapr> Phillemann: Do you have access to ghc 6.8.1?
10:38:28 <EvilTerran> sorry, that first one should be "a" -> aOrB; b -> aOrB; ... where aOrB = ...
10:39:04 <Phillemann> shapr: I could install it, yes.
10:39:41 <shapr> Phillemann: It configures fine with 6.8.1
10:39:41 <Phillemann> The last time I tried, however, gave me a slight headache.
10:39:58 <shapr> heh
10:40:02 <EvilTerran> tehgeekmeister, the problem with "or patterns" in general would be knowing which variables are bound in "Left y <or> Right z -> ..."
10:40:05 <conal> EvilTerran: or more elegantly with "or patterns"
10:40:08 <shapr> I don't have 6.6.1, so I can't test that.
10:40:23 <conal> EvilTerran: (once haskell has them)
10:40:24 <Phillemann> shapr: I'll try my luck with 6.8.1 again.
10:40:38 <shapr> Cool, hopefully I can help if you have trouble with 6.8.1
10:40:45 <shapr> Phillemann: What distro or flavor of windows?
10:40:47 <harlekin> I've written a function which returns an Integer. I'd like to pass the functions return value to a variable in a do construct. How do I realize that? out <- function doesn't work as out expects IO t and functions returns Interger.
10:41:06 <EvilTerran> > do let x = 1+2; [x]
10:41:06 <lambdabot>  Parse error at end of input
10:41:13 <EvilTerran> > do let { x = 1+2 }; [x]
10:41:15 <lambdabot>  [3]
10:41:39 <harlekin> Thanks. (:
10:45:54 <gwern> hm. http://www.haskell.org/pipermail/haskell-cafe/2004-June/006207.html claims Data.Dynamic is enough to emulate Clean's dynamics... but nothing on the runtime system or linker support. frustrating
10:45:58 <lambdabot> Title: [Haskell-cafe] Re: Modelling Java Interfaces with Existential data types, http://tinyurl.com/35th8n
10:52:11 <tehgeekmeister> how does one pause execution in haskell?  like the unix sleep command, for example.
10:52:23 <roconnor> @hoogle sleep
10:52:23 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
10:52:27 <roconnor> :(
10:53:25 <oerjan> @hoogle threadDelay
10:53:26 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
10:53:58 <roconnor> @hoogle Int -> IO ()
10:53:59 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
10:53:59 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
10:53:59 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
10:54:50 <tehgeekmeister> oerjan: would that be useful for a single threaded program?
10:55:40 <oerjan> gwern: i think that refers to only dynamical typing, but i'm not sure
10:56:17 <oerjan> tehgeekmeister: i think lightweight threads are always available
10:57:36 <roconnor> wow System.Timeout.timeout
10:57:42 <roconnor> that looks pretty cool
10:57:49 * shapr takes a quick timeout
10:57:52 <gwern> oerjan: yes, I think that's all Data.Dynamic is good for after a bit of reading
10:59:40 <oerjan> Data.Binary is pickling but not for functions
10:59:40 <tehgeekmeister> roconnor: is that new in 6.8?
11:01:07 <gwern> oerjan: unfortunately. I keep hoping I'll come across an 'oh and this also works for functions', but no dice thus far
11:01:37 <loupgaroublond> hi
11:01:47 <Runaro> gwern: That would be so bad-ass.
11:02:29 <loupgaroublond> i have a function that returns Maybe t, how do i get what's in t into a variable with foo <- func in a do statement tahts in the IO monad
11:02:29 <gwern> Runaro: it would be, which is why I'm looking for't
11:02:44 <gwern> case epression; Just a -> stuff, etc
11:02:52 <roconnor> tehgeekmeister: I don't know.
11:03:10 <tehgeekmeister> okay.
11:03:11 <roconnor> It's in base-3.0.0.0.
11:03:49 <tehgeekmeister> ah, my ghc has base 2.1.1, okay.
11:04:26 <roconnor> tehgeekmeister: It's possible it is in an earlier version.  I'm just browsing the online docs
11:04:47 <tehgeekmeister> roconnor: i tried to import it and there was no System.Timeout module
11:07:28 <Phillemann> pandoc now says "Could not find module `Text.PrettyPrint':", which package does this module belong to?
11:08:57 <Syzygy-> byorgey: Are you possibly named Brent? And reading God Plays Dice?
11:09:16 <byorgey> Syzygy-: indeed.
11:10:17 <loupgaroublond> how do I pick out the t from a function that returns Maybe t, to get it into an IO monad?
11:10:49 <byorgey> loupgaroublond: there are lots of ways; the easiest is probably to do a case analysis:
11:11:07 <loupgaroublond> byorgey, in a do statement, how would i do that?
11:11:14 <loupgaroublond> foo <- case stuff?
11:11:15 <byorgey> case (funcReturningMaybe foo bar) of { Just x -> blah ; Nothing -> blah }
11:11:58 <ToRA> @type maybe (error "Nothing!") return :: Maybe a -> IO a
11:11:59 <lambdabot> forall a. Maybe a -> IO a
11:12:18 <Runaro> gwern: could you not use lambda-lifting to get Binary to do the thing you want?
11:12:40 <gwern> Runaro: I have no idea what lambda-lifting is and very little idea what Binary does
11:12:50 <Phillemann> shapr: pandoc does not seem to play very well with 6.8.1, too.
11:15:03 <Saizan> Phillemann: pretty
11:16:02 <Phillemann> Saizan: I don't find that package, and in an ebuild from "HaXml" I found the note "Text.PrettyPrint is already provided by ghc [...]"
11:17:14 <Saizan> name: pretty [..] exposed-modules: Text.PrettyPrint Text.PrettyPrint.HughesPJ
11:17:23 <Saizan> from ghc-pkg describe pretty
11:17:54 <Saizan> have you installed the extralibs?
11:18:10 <Phillemann> Which extralibs? :)
11:18:48 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pretty-1.0.0.0 <- here it is, however
11:18:50 <lambdabot> http://tinyurl.com/yre9nb
11:19:44 <Saizan> with 6.8.1 base has been reduced and code moved in other little packages like this
11:20:48 <Phillemann> Ah, ok.
11:23:35 <Saizan> Phillemann: btw, you've to add that package to build-depends and rerun configure
11:29:29 <roconnor> @pl (\x x -> (f (g (h x x))))
11:29:29 <lambdabot> const (f . g . join h)
11:29:33 <roconnor> @pl (\x -> (f (g (h x x))))
11:29:33 <lambdabot> f . g . join h
11:31:14 <roconnor> @pl (\x -> (f (g (h x x))) z)
11:31:14 <lambdabot> flip f z . g . join h
11:31:53 <roconnor> @pl (\x -> (f z (g (h x x))))
11:31:53 <lambdabot> f z . g . join h
11:37:38 <roconnor> @pl (\x y -> g (abs (minus x y)) (abs (minus y x)))
11:37:38 <lambdabot> ap (ap . ((g . abs) .) . minus) ((abs .) . flip minus)
11:41:22 <hpaste>  tehgeekmeister pasted "Not very useful example of my flowchart dealio." at http://hpaste.org/4261
11:41:46 <tehgeekmeister> (in case anyone from earlier is curious about it)
11:42:09 <byorgey> roconnor: isn't abs (minus x y) == abs (minus y x) ??
11:42:52 <mwc> hah
11:42:54 <mwc> Git and Perforce couldn't be more chalk and cheese about this. Perl's development model is one that a colleague dubbed the ghetto merge model, where you have some kind of "hood" where the "flyist features go to battle it out". The features left standing are subsequently moved into trailer parks (aka integration branches), where they can make a new life for themselves and prove their stability.
11:43:25 <dropdrive> Is there a way to interact with lambdadot without writing to #haskell?  Or is stuff like @pl available elsewhere?
11:43:37 <mwc> dropdrive, pm lambdabot
11:43:49 <mwc> pm = private message, aka /msg
11:44:06 <desegnis> dropdrive: The usual answer is that you could take the source code of lambdabot and pull out the non-IRC-related bits
11:44:11 <mwc> dropdrive, though there is also a downloadable lambdabot
11:44:35 <roconnor> byorgey: yep
11:44:52 <desegnis> There used to be ghci on acid, but not sure whether there's something compileable out there right now
11:44:52 <mwc> desegnis, or, I suppose, you could insteall a local ircd, a local lambdabot, and talk to it that way ;)
11:45:06 <desegnis> mwc: indeed.
11:45:14 <dropdrive> desegnis, mwc: Thank you both.
11:46:41 <roconnor> byorgey: I want to use that fact in a lemma I proving
11:47:02 <roconnor> byorgey: and I have a rewrite system for combinators
11:47:12 <roconnor> byorgey: so I need the theorem in combinator form.
11:47:56 <byorgey> roconnor: aha!  now it makes sense. =)
11:48:22 <byorgey> roconnor: is this using Coq?
11:48:33 <roconnor> byorgey: ... the theorem doesn't look quite as nice with combinators. :P
11:48:38 <roconnor> byorgey: yes
11:49:21 <byorgey> roconnor: cool.  I just read a Coq tutorial and was playing around with it a bit the other day... proved some very basic group theory stuff.
11:49:34 <roconnor> byorgey: see #coq
11:49:36 <byorgey> but I still feel like I'm just sort of flailing around wildly until I find a tactic that works =)
11:49:56 <roconnor> byorgey: coq isn't so great at abstract mathematics at the moment.
11:50:10 <byorgey> roconnor: why not?
11:50:13 <roconnor> byorgey: it is much better at concreate mathematics, such as number theory.
11:50:32 <roconnor> byorgey: because equality is a finicky subject in type theory.
11:50:46 <byorgey> roconnor: ah, I see.
11:51:08 <roconnor> byorgey: one needs to work with equivalence relations rather than equality in type theory because there are no quotient types
11:51:42 <roconnor> byorgey: but you lose the nice leibniz equality that is easy to rewrite with.
11:51:52 <roconnor> byorgey: so you can use the setoid mechanism in Coq
11:52:10 <roconnor> byorgey: then you have to declare all your functions as being well defined. (as you do in math)
11:52:38 <roconnor> byorgey: but the setoid rewrite system works on types rather than types upto convertability.
11:52:49 <roconnor> byorgey: so then things get difficult with rewriting.
11:53:09 <roconnor> byorgey: at least that is my understaning as to why Coq isn't so great at abstract mathematics.
11:53:41 <byorgey> roconnor: hm, ok, I think that makes sense.
11:53:45 <roconnor> This isn't all that Coq specific.  Perhaps it is more that (raw) type theory isn't so great at abastract mathematics.
11:54:24 <roconnor> I wonder if the Mizar people have any difficulties.  They use something like ZFC.
11:54:37 <mwc> anybody used Isabelle? I was going to look at it over christmas, wondering if it was any better at analysis than Coq
11:54:43 <mwc> (applied math grad student)
12:13:34 <xinming> sorry to ask the question about Reader Monad again. in {{{   (Reader r) >>= f = Reader $ \e -> f (r e) e   }}}, Why isn't there a runReader for extracting the env please?
12:13:58 <matthew-_> env is constant
12:16:15 <mauke> xinming: bug?
12:16:37 <xinming> I'm still confused about this, f (r e) will return something which is something like "Reader $ \e -> blabla"
12:16:47 <mauke> yeah, you need runReader
12:16:51 <xinming> mauke: Not bug, It's from all about monads.
12:16:59 <mauke> what
12:17:02 <xinming> http://www.haskell.org/all_about_monads/html/readermonad.html
12:17:02 <lambdabot> Title: The Reader monad
12:17:10 <xinming> mauke: check that please. ;-)
12:17:10 <mauke> IT MUST BE TRUE I READ IT ON THE INTERNETS
12:17:23 <mauke> it's a bug
12:17:27 <xinming> *_*
12:17:48 <xinming> Oh, Ok, thanks, I really really wasted a long time on thinking how it worked.
12:17:51 <dons> bringert: around?
12:18:13 <dons> bringert: how do I best get from a Data.Time.UTCTime  to a good old fashioned CalenderTime
12:18:23 <dons> btw, the rss package is sweet
12:19:03 <dons> or anyone else who's got a suggestion? :)
12:19:08 <xinming> matthew-_: thanks anyway. :-)
12:20:07 <bringert> dons: hi
12:20:23 <bringert> dons: I think the easiest is to go through ClockTime
12:20:29 <dons> ah
12:21:03 <dons> bringert: btw, 5 mins with RSS 3000, and we have, http://galois.com/~dons/xmonad.xml :)
12:21:51 <bringert> dons: nice
12:22:24 <bringert> the CalendarTime this is a nice illustration of why constructors shouldn't be exported when it can be avoided
12:22:30 <bringert> s/this/thing/
12:23:22 <dons> yeah
12:23:39 <fnord> hi all
12:24:01 <sjanssen_> alternatively, http://xmonad.org/xmonad.xml :)
12:24:45 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4262
12:24:48 <dons> ah great! http://xmonad.org/xmonad.xml
12:25:34 <fnord> I don't suppose someone could look at that function I just pasted (http://hpaste.org/4262#a0) and tell me why it's causing a stack overflow?
12:25:37 <dons> ibid: xmonad rss feed for planet haskell, http://xmonad.org/xmonad.xml
12:25:56 <dons> sjanssen: ok.busy atm. will talk later about what needs to be done.
12:26:19 <fnord> I'm thinking maybe I need to make it strict in places but I'm not sure how to do that
12:26:47 <Saizan> fnord: you need to be strict on h and s
12:27:31 <Saizan> fnord: the easiest way is to use BangPatterns, so it will look like combine (f,(!h,!s)) ... etc
12:27:34 <fnord> how exactly do I do that? I seem to remember some syntax involving the ! charcter to make a patter strict
12:27:41 <fnord> aha! that's the one, cheers
12:28:16 <fnord> I'm not sure I understand why that part needs to be strict though, how is that causing a stack overflow?
12:28:22 <Saizan> you need -fbang-patterns or {-# LANGUAGE BangPatterns #-}
12:28:48 <desegnis> Is the issue with fnord's code different from the usual foldl vs. foldl' thing?
12:29:20 <Saizan> fnord: because in the foldl you're building a huge thunk by adding values to those accumulator without ever inspecting them
12:29:46 <Saizan> desegnis: it can't be solved with foldl' because the accumulator are inside a tuple, but it's the same problem
12:30:07 <ibid> dons: no non-meta content there. anyway, please use email
12:30:29 <dons> ibid: btw, is it a valid feed, btw?
12:30:37 <desegnis> ah, because of the tuple being lazy in its fields (if I understood right, Saizan?)
12:30:37 <fnord> I'm still getting a stack overflow...
12:30:49 <dons> just a quick script to turn xmonad annoucements into feeds
12:30:57 <dons> ibid: this weeks release will be announced there.
12:31:33 <fnord> Have tried making x and xs strict as well, still no luck
12:31:52 <ibid> dons: i haven't pointed a validator at it
12:32:03 <ibid> dons: you might want to :)
12:32:24 <dons> i trust Bringert's code  :)
12:32:48 <ibid> dons: i'd prefer to have something else than just the meta post there before i add, but otherwise it qualifies
12:33:01 <dons> ok. that's fine. i'll update it with the 0.5 annoucnement
12:33:02 <Saizan> fnord: sorry, i didn't pay attention to that "flip", that means you've to make h' and s' strict instead, i think
12:33:07 <dons> feel free to add it later, once that is there.
12:33:11 <dons> i'll ping you.
12:33:14 <ibid> ok
12:33:33 <dons> it'll be somewhat like the gtk2hs feed in scope
12:34:08 <bringert> dons: stepcut wrote most of it actually
12:34:41 <fnord> Saizan: thanks, trying that now, the flip is because I was original using foldr and thought I'd tried foldl
12:34:51 <ibid> dons: http://feedvalidator.org/check.cgi?url=http%3A%2F%2Fxmonad.org%2Fxmonad.xml
12:34:53 <lambdabot> Title: Feed Validator Results: http://xmonad.org/xmonad.xml, http://tinyurl.com/2ljpqo
12:35:00 <Saizan> fnord: features is not infinite right?
12:35:15 <dons> ibid: cheers
12:37:24 <fnord> no, about 100k elements
12:37:54 <fnord> still getting a stack overflow
12:40:51 <Cale> fnord: are you using foldl' now?
12:40:57 <Cale> (rather than plain foldl)
12:41:40 <Cale> fnord: I'm willing to bet it's all the unevaluated additions building up
12:41:59 <fnord> no, where abouts is foldl' (not in the prelude, right?)
12:42:06 <Cale> Data.List
12:42:23 <Cale> You'll also need to force the evaluation of h and s as you go.
12:42:29 <Saizan> Cale: the accumulator is the list
12:42:39 <fnord> cool, trying foldl' now
12:42:52 <Cale> oh
12:42:52 <Saizan> so i thought forcing h' and s' should have worked
12:42:55 <Cale> heh, yeah
12:43:04 <Cale> the flip there threw me off as well :)
12:44:09 <fnord> how would I force h and s? don't the bang patterns do that?
12:44:18 <Cale> You'll need both foldl' and forcing of h' and s' to get the desired effect.
12:44:43 <Cale> You don't need to force h and s, I misread your code at first
12:45:07 <fnord> cool, ok
12:45:30 <fnord> aha, that did it
12:45:34 <fnord> cheers guys
12:46:12 <Cale> fnord: the trouble was that it was building up unevaluated additions which were so large by the time they finally got forced, that they overflowed the stack.
12:46:15 <Saizan> what does foldl' buys here? i'd think it will only force (:)
12:47:10 <Cale> Saizan: otherwise you'll just end up with a big stack of unevaluated calls to combine
12:47:46 <Cale> what's with applying id to features?
12:47:58 <Feuerbach> is there some standard function like foldl1, but which would return all the intermediate results? e.g. f (*) [1,2,3] -> [1,1*2,1*2*3]
12:48:05 <Cale> yes
12:48:08 <Cale> scanl1
12:48:17 <Cale> > scanl1 (*) [1,2,3]
12:48:18 <lambdabot>  [1,2,6]
12:48:23 <Feuerbach> Cale: thanks!
12:48:52 <fnord> id is just a placeholder, was applying sort but took it out for testing
12:49:00 <Saizan> Cale: hah, it seems i've overlooked the basics :)
12:49:16 <fnord> replacing with id helps me remember something should be there :p
12:50:39 <Cale> By the way, using large association lists like that is generally not a good idea for performance.
12:50:45 <Saizan> ?type map (id *** (sum *** sum)) . (groupBy ((==) `on` fst) . sort
12:50:47 <lambdabot> parse error (possibly incorrect indentation)
12:50:49 <Cale> Data.Map provides a much nicer alternative.
12:51:12 <mauke> Saizan: missing )
12:51:19 <Cale> (unless the ordering of the lists matters to you)
12:53:42 <fnord> I'll check that out
12:58:12 <hpaste>  pitecus pasted "Space leak" at http://hpaste.org/4263
12:58:28 <pitecus> Any idea why this simple program runs out of memory?
13:01:04 <db4n> If >>= is called "bind", what's >> called?
13:01:10 <dmwit> then
13:01:31 <db4n> dmwit thanks, is that universal?
13:01:49 <dmwit> It might make sense to call it "sequence", but that conflicts with another function called sequence that's basically a fold of (>>).
13:02:05 <mauke> and `seq`
13:02:11 <dmwit> db4n: No, I think in most cases, return and (>>=) are called unit and some Greek letter.
13:02:30 <dmwit> mu, maybe?
13:02:36 <quicksilver> I'm not aware of a greek letter for bind
13:02:45 <quicksilver> mu and eta are join and unit
13:02:46 <mauke> we could invent one
13:02:50 <quicksilver> (join and return)
13:03:05 <dmwit> Ah, sorry, the maths people like join better than bind. =)
13:03:07 <quicksilver> bind is closely related to kleisli composition
13:03:11 <quicksilver> but it isn't quite it
13:03:19 <quicksilver> you might say that kleisli composition is the essence of bind, though
13:04:31 <dons> mm, (toUTCTime . flip TOD 0 . truncate . realToFrac . utcTimeToPOSIXSeconds )
13:04:39 <pitecus> I suspect the problem is that List Zipper thing, but I'm not sure what to do about it: http://hpaste.org/4263
13:04:41 <dons> :: UTCTime -> CalenderTime
13:04:44 <dons> time is a puzzle
13:05:04 <db4n> All About Monads calls it bind.
13:05:24 <dmwit> Yes, bind is a common name for it in Haskell.
13:05:27 <dons> seems to work though
13:05:38 <dmwit> I'm not sure it really extends outside of Haskell, though.
13:05:38 <Cale> fnord: let fromListWith' f xs = foldl' (\m (k,v) -> insertWith' f k v m) empty xs in fromListWith' (\(a,b) (!c,!d) -> (a+c,b+d)) features -- this is probably the most efficient way to build a map from your association list, and do the summation at the same time. You can probably get away with just using plain fromListWith here though, unless you have many many occurrences of the same feature.
13:07:30 <stick_figure> I'm fooling around with Haskell by writing a AA Tree implementation, and I want to test it with QuickCheck, but I get this funny error in ghci if I call "quickCheck aa_test".
13:07:50 <stick_figure> It says: No instance for (Show (IO ()))
13:08:31 <db4n> from AAMs "... the bind functions >>= and >> ..."
13:08:42 <db4n> That doesn't make much sense, since >> doesn't bind anything.
13:10:00 <gwern> reading through the Data.Binary docs, I see: 'Binary serialisation of Haskell values to and from lazy ByteStrings.'. Are Haskell function definitions 'haskell values'?
13:10:14 <db4n> stick_figure that sounds reasonable
13:10:40 <quicksilver> gwern: no. functions are values. not function definitions.
13:11:03 <stick_figure> db4n, sure it does, but what I'd like to know is how to run tests
13:11:13 <quicksilver> gwern: Binary isn't magic. You'd have to write Binary instances for your function types.
13:11:17 <dons> gwern: no instance of Binary (a -> b)
13:11:26 <dons> by all means have a go :)
13:11:37 <quicksilver> you could write one in principle for finite 'a'...
13:11:50 <gwern> quicksilver: I don't follow the distinction - so 'f x = foo x' is not a value? but if '(f x)' is passed somewhere as a higer order thingy, it is a value?
13:11:59 <stick_figure> db4n, eventually I defined a function run_tests in the file and ran that from the REPL and it worked.
13:12:07 <quicksilver> gwern: a definition is a chunk of source code
13:12:08 <gwern> dons: I sense you are having fun at my expense...
13:12:13 <quicksilver> gwern: compilation destroys source code
13:12:22 <quicksilver> gwern: in a compiled program, source code no longer exists, in any sense.
13:12:30 <quicksilver> gwern: therefore, a function definition is not a value.
13:12:37 <quicksilver> gwern: but a function itself is a value, yes
13:12:39 <dons> gwern:  no, its just a hard problem :)
13:13:02 <dons> a function is a value, so if you can write an instance Binary for it, you can serialise functions
13:13:05 <dons> > ord
13:13:07 <lambdabot>  <Char -> Int>
13:13:08 <dons> for example.
13:13:18 <dons> but that doesn't hold to : read. show == id
13:13:45 <gwern> quicksilver: so if main tried to write through Data.Binary out a function in its scope, it could only do so as a binary blob and not as source?
13:13:50 <gwern> (because the source is gone)
13:14:05 <dons> well, even the binary blob would be hard.
13:14:12 <dons> you could look up the source somehow,
13:14:22 <quicksilver> gwern: Data.Binary does not contain an algorithm for writing functions
13:14:32 <quicksilver> gwern: typeclasses require being implemented at the types you want to use them on
13:14:42 <quicksilver> the Data.Binary code contains instances for various built-in types
13:14:49 <quicksilver> well, built-in/common library types
13:14:56 <quicksilver> but it doesn't contain an instance for a->b
13:14:59 <db4n> stick_figure that's good.  I don't know what your tests do, but you shouldn't need to test the output of functions that return (), and other functions should never return that value.
13:14:59 <quicksilver> because that's hard
13:15:27 <quicksilver> gwern: you could write an instance for a->b if you wanted. I mean, the language would permit you to try.
13:15:38 <quicksilver> it would be hard to write one in practice, except for the limited case of finite 'a'
13:15:44 <gwern> quicksilver: would String->String be hard? I'm not sure what in that is the hard part, the -> or the generality of a and b
13:15:49 <Cale> gwern: the trouble is that while Haskell functions are values, they are completely opaque values. You can't see what a given function is made of, you can only apply it to values (or pass it around, put it into data structures etc.), but you can't observe it.
13:16:23 <Cale> When the domain of a function is infinite, you'll generally have trouble recording that function completely.
13:16:39 <dons> you could use TH though
13:16:42 <Cale> (though there are some infinite domains where this is possible)
13:16:48 <dons> to have the instance construct the AST at compile time
13:17:09 <gwern> Cale: whoa. what infinite domains is that possible in?
13:17:09 <dons> lots of fun metaprogramming papers involved
13:17:35 <Cale> gwern: Infinite sequences of Booleans, for one.
13:17:50 <quicksilver> in practice what you might do is design an ADT which represented the particular class of functions you were trying to serialise.
13:18:00 <quicksilver> I have done this with procedural textures
13:18:12 <quicksilver> in principle, my textures are functions Double -> Double -> Color
13:18:21 <quicksilver> but that would not be easy to serialise
13:18:22 <Cale> That is, a function (Nat -> Bool) -> X, where X can be serialised, should be possible to serialise as well.
13:18:45 <quicksilver> so, instead, I build an ADT FunctionalTexture, which can be serialised
13:18:52 <gwern> quicksilver: interesting; so how did you serialize them?
13:18:58 <gwern> oh nm, go on
13:19:09 <quicksilver> then you write an evaluator function
13:19:18 <quicksilver> eval :: FunctionalTexture -> (Double -> Double -> Color)
13:19:34 <quicksilver> essentially you add some structure to your functions
13:19:40 <quicksilver> instead of trying to represent "all" functions
13:19:51 <quicksilver> you limit yourself to a class of functions which, by design, can be serialised.
13:19:53 <gwern> hm. so this evaluator associates each bit of the abstract type with some function and reconsitutes the original functions that way?
13:20:06 <hpaste>  pitecus pasted "Much simpler" at http://hpaste.org/4264
13:20:09 <Cale> gwern: It would be really really nice to have a platform-independent (or even a platform-dependent) way to serialise any Haskell value without doing any evaluation on it.
13:20:24 <pitecus> OK a much simpler program which leaks space
13:20:29 <pitecus> I dont understand why
13:20:54 <Cale> But it's somewhat tricky, since that involves reading machine code and deciding which bits are relevant.
13:21:12 <Cale> (and hopefully stopping when you get into a common library)
13:21:17 <gwern> quicksilver: so it'd look a little like this if I understood you: type = Add | Subtract | Multiply... eval f = case f of Add -> (+) ?
13:21:21 <quicksilver> gwern: yes
13:21:28 <quicksilver> gwern: very much like that
13:21:51 <gwern> and then you'd map over a list of adts, and at the end presumably you'd have a function
13:22:00 * quicksilver nods
13:22:18 <Cale> pitecus: dons is pretty good at that sort of thing, and I'm sure the rest of us can take a look as well -- have you got an hpaste?
13:22:33 <Cale> oh, up there, I missed it :)
13:22:35 <dmwit> Cale: Yes he does. ;-)
13:22:41 <gwern> *now* I understand why lambda lifting was mentioned to me, to convert functions into combinators where your small set of combinators can be included in the 'eval' matching
13:23:12 <Cale> okay, so that's complicated enough to use the profiler :)
13:23:19 <hpaste>  quicksilver pasted "functionaltexture" at http://hpaste.org/4265
13:23:30 <quicksilver> gwern: there is the code, if you're interested
13:23:33 <Runaro> gwern: Bingo
13:24:17 <pitecus> Cale should it run in constant space?
13:24:55 <gwern> Runaro: you could've said some more you know -_-
13:25:11 <pitecus> Its 10 lines!
13:25:11 <conal> quicksilver: nifty.   are you doign anything else with FunctionalTexture, besides ptEval?  If not, you could define FunctionalTexture = GLdouble -> GLdouble -> Color4 GLdouble.  Or parameterize by the "color" type, as in Pan.
13:25:19 <Cale> pitecus: oh, I just saw your shorter program :)
13:25:29 <pitecus> yep
13:25:37 <gwern> quicksilver: yes; I take it 'cmEval' and 'gradient' are the 'normal' functions which are used by the reconstituted functions?
13:25:43 <Runaro> gwern: I don't really know Haskell well enough to help much.
13:25:46 <conal> quicksilver: then you could do a whole lot more than those few kinds of textures/images.
13:25:51 <gwern> (multinoise too?)
13:25:52 <quicksilver> conal: yes, I'm serialising them
13:26:00 <quicksilver> conal: that was the context of my discussion with gwern :)
13:26:21 <quicksilver> gwern: actually colorMap is another similar structure
13:26:30 <conal> quicksilver: oops -- i'll read my scrollback.  "functionaltexture" caught my eye (naturally).
13:26:32 <quicksilver> gwern: ColorMap is 'logically' a 1D texture
13:26:43 <quicksilver> gwern: but it's an ADT representing them
13:26:52 <quicksilver> conal: I just load and save them, basically
13:27:08 <gwern> Runaro: eh? you are in in #haskell, you understand my problem well enough to make an obscure but very germane point, etc. and you don't know haskell well?
13:27:28 <Cale> pitecus: what does this program do? Is it removing blank lines?
13:27:45 <hpaste>  quicksilver annotated "functionaltexture" with "ColorMap similarly" at http://hpaste.org/4265#a1
13:27:48 <gwern> quicksilver: oh, so I guess cmEval is the ColorMap's eval then. that makes sense
13:27:53 <pitecus> Cale, its just a test program, but yeah thats what it does
13:27:56 <gwern> (too slow again :(
13:29:16 <conal> quicksilver: the interpreter approach does suffer in performance & extensibility.  an alternative is to carry around two representations, as i do in TV & Eros.
13:29:18 <quicksilver> gwern: yes, annotated the paste
13:29:40 <conal> quicksilver: and operate on them in tandem, via DeepArrow.
13:29:52 <gwern> conal: you have a different approach to serializing functions?
13:29:59 <gwern> (or am I misunderstanding?
13:30:01 <quicksilver> conal: I haven't found performance to be an issue, with some careful partial evaluation tricks.
13:30:13 <quicksilver> conal: the main bottleneck is constructing those expensive perlin noise tables...
13:30:36 <Runaro> gwern: Precisely.
13:30:46 <conal> quicksilver: i'd like to hear what partial evaluation tricks you've used.   i do that sort of thing with graphics also.
13:30:54 <conal> gwern: yes -- a different approach.
13:30:57 <quicksilver> conal: just the let statements you see there
13:31:03 <quicksilver> conal: and careful definition of multiNoise
13:31:14 <conal> quicksilver: sure.  i see.
13:31:19 <quicksilver> conal: to make sure it constructs its tbles after it gets its first 4 parameters
13:31:28 <quicksilver> conal: so giving it the last 2 at different values
13:31:32 <quicksilver> doesn't re-compute the tables
13:31:54 <quicksilver> it's still quite a lot slower than I'd like, but it's fast enough to be useful on this laptop at least :)
13:31:58 <gwern> conal: if you have a spare moment, I'd appreciate a link or quick summary or sumthin
13:32:04 <conal> quicksilver: and when ghc inlines ptEval & your texture together, the data rep can vanish.
13:32:05 <gwern> *when/if
13:32:27 <quicksilver> http://roobarb.jellybean.co.uk/~jules/Picture%2035.png
13:32:35 <quicksilver> is what it looks like
13:32:38 <quicksilver> if you're curious :)
13:32:42 <conal> quicksilver: i'd like to compare notes on our projects.  we might learn some things from each other.
13:32:48 <quicksilver> with a pretty-printed ADT top right, navigated by a zipper
13:33:01 <conal> quicksilver: pretty.
13:33:24 <Cale> pitecus: It appears to be running in constant space, at least.
13:33:49 <pitecus> No it doesn't
13:33:54 <pitecus> At least onb my machine
13:34:06 <Cale> pitecus: I ran it on a file of several hundred megs, and it never became any larger than the initial 5.5MB.
13:34:24 <pitecus> with ghc 6.6.1 ?
13:34:30 <Cale> pitecus: Are you compiling with optimisations?
13:34:33 <Cale> No, 6.8.1
13:34:45 <Cale> Make sure to compile with -O2
13:34:54 <pitecus> yeah I'm doing it
13:35:19 <quicksilver> conal: yes, I skimmed your TV/Eros paper recently (but after I wrote that code)
13:35:29 <quicksilver> conal: my objective was to be able to edit the textures interactively.
13:35:37 <quicksilver> conal: in that context, an ADT seems to make sense
13:35:43 <pitecus> Cale, I'm running it on 1G data
13:35:44 <quicksilver> anyhow, I wanted to try this zipper lark :)
13:35:56 <conal> quicksilver: different project, but will merge with Eros.  and i'm definitely interested in interactive synthesis.
13:36:01 <Cale> pitecus: okay, I'll try it on a DVD image then :)
13:36:02 <gwern> (when cabal install works, it's really nice)
13:36:27 <conal> gwern: as others have said, we can't serialize a function, so we have to back up and change the problem.  in TV & Eros, i use combinators that compose UIs in parallel with type-compatible pure values.  this pairing is not wired-in.  it happens via DeepArrow instances for transformers of (a) plain-old values, (b) UI-transformers, and (c) pairings of DeepArrow instances.
13:36:54 <quicksilver> conal: well the interactive part mostly works. It renders the textures in the background in a different thread and with the right RTS options it feels quite responsive.
13:37:02 <conal> gwern: serialization and other things (e.g., optimized code generation and syntax pretty-printing) could work similarly.
13:37:17 <musiKk> yay, i finally managed to read and write files... i am both confused and proud
13:37:31 <quicksilver> conal: in fact what let me back to reading your paper was a comment you made about arrows which weren't really arrows.
13:37:36 <conal> quicksilver: cool :)  you do know about Pan, right?
13:37:37 <quicksilver> conal: at least I think that was you :)
13:37:51 <conal> quicksilver: probably.
13:38:02 <quicksilver> conal: functionaltexture is not an arrow, on the contrary eval is the opposite of pure
13:38:03 <Cale> musiKk: Have you read my short intro on how to think about IO in Haskell?
13:38:05 <conal> quicksilver: the "arr" requirement gets in the way.
13:38:09 <quicksilver> right
13:38:16 <quicksilver> I want 'eval' which is quite the opposite
13:38:26 <pitecus> Cale I just tried with newer GHC and it's OK
13:38:31 <Cale> pitecus: It quickly reached 12.4 MB and hasn't asked for any more
13:38:32 <quicksilver> these are "less general" than functions; not "more general"
13:38:38 <quicksilver> but they are composable
13:38:39 <musiKk> no cale, sorry, but if you tell me where i can find it, i might read it :-)
13:38:49 <pitecus> I can't use new GHC though
13:38:51 <quicksilver> (you can compose a FT with a ColorMap, in principle, although that's not quite the code I have now)
13:38:59 <pitecus> Im stuck with 6.6.1
13:39:15 <conal> quicksilver: what are you saying about eval??
13:39:25 <pitecus> I guess they don't fix bugs on old versions of the compiler....
13:39:32 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO  and for later when you're learning about monads in general: http://haskell.org/haskellwiki/Monads_as_computation
13:39:35 <Sizur> do we have a O(log n) find on Ord t?
13:39:58 <Sizur> Ord t => [t] I mean
13:40:16 <musiKk> Cale: thanks, i'll have a look
13:40:25 <conal> quicksilver: btw, i don't use arrows for *values* or interfaces in eros & tv, but rather for transformers of values & interfaces (etc).
13:40:44 <Cale> musiKk: It's rather short, but might help cement the idea of how things work.
13:41:16 <quicksilver> conal: about eval, I'm saying I don't have pure :: (a->b) -> A a b; rather I have eval :: A a b -> (a->b)
13:41:26 <quicksilver> conal: so it's the opposite of pure
13:41:28 <quicksilver> co-pure!
13:41:46 <conal> quicksilver: thanks.  that's in DeepArrow as well.
13:41:51 <quicksilver> Sizur: no, you can't do anything O(log n) on [t]
13:41:51 <conal> quicksilver: though in a more general form.
13:42:37 <quicksilver> Sizur: what i just said is not literally true, but in spirit :)
13:42:41 <conal> quicksilver: it's how i turn function TVs into transformers of argument TVs.
13:42:58 <quicksilver> conal: To keep answering your questions in no particular order, yes I know of Pan, but I haven't played with it
13:43:31 <Cale> musiKk: Of course, let me know if you have any questions about it :)
13:43:32 <Sizur> so I'd need to simulate a [t] with a binary tree?
13:43:37 <quicksilver> conal: nor likely to since I dont have a win32 platform
13:43:56 <quicksilver> Sizur: sounds like you should just use Data.Set or Data.Map
13:44:03 <quicksilver> Sizur: but maybe you have your own constraints..
13:44:16 <conal> quicksilver: nor anyone, because it bit-rotted even there.  i have a more modern variant, Pajama, that generates JVM code and runs on the web.
13:44:28 <quicksilver> Sizur: you could use Data.Sequence and get O(log n * log n) binary chop but that seems perverse
13:44:44 <conal> quicksilver: and now I'm doing a new version with a *very* different representation of infinite continuous images.  hopefully much more efficient.  looking good so far.
13:44:50 <conal> quicksilver: and also via OpenGL.
13:44:51 <Sizur> quicksilver: just trying to implement a pure relational db as a way of learning haskell ;)
13:45:10 <quicksilver> conal: you tantalised me a few weeks ago with talk of a functional composition for openGL shaders
13:45:15 <Mitar> is there a standard function for mixing two lists together (all elements of one list should be on odd positions and all elements of other list should be on even positions)
13:45:20 <conal> quicksilver: good :)
13:45:37 <conal> quicksilver: i bet it'd be much easier to re-do Vertigo now than my original version.
13:45:37 <Cale> Mitar: unfortunately not, but it's not so hard to write of course
13:45:39 <quicksilver> Sizur: I'd probably use an array for that. If you're trying to be realistic, use a file and use hSeek
13:46:08 <musiKk> Cale: i'm still quite at the beginning of my journey, so it's not a matter of some simple question but more like a big blurry picture with a few clear spots. but i'll keep your offer in mind :-)
13:46:18 <quicksilver> :t \l m -> concatMap (\(x,y) -> [x,y]) . zip l m
13:46:20 <lambdabot>     Couldn't match expected type `a -> [(t, t)]'
13:46:20 <lambdabot>            against inferred type `[(a1, b)]'
13:46:20 <lambdabot>     In the second argument of `(.)', namely `zip l m'
13:46:23 <Mitar> or easier question: i would like to produce from two numbers one unique one, which would not be repeated for any other combination of those two numbers
13:46:29 <quicksilver> :t \l m -> concatMap (\(x,y) -> [x,y]) $ zip l m
13:46:30 <lambdabot> forall b. [b] -> [b] -> [b]
13:46:35 <Cale> (\xs ys -> concat (transpose [xs,ys]))
13:46:39 <quicksilver> Mitar: that is one answer to our first question.
13:46:49 <Sizur> quicksilver: that will work, but it's too close the the metal :) I want something pure to play around with. maybe hit a few walls with haskell
13:47:02 <Mitar> so i thought of making something like:
13:47:07 <Mitar> unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) firstNumber
13:47:12 <Mitar> unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) secondNumber
13:47:13 <quicksilver> Sizur: then use a Sequence and put up with O (log n * log n)
13:47:20 <Mitar> and then intersperse them and fold them
13:47:20 <quicksilver> Sizur: that's good enough for playing
13:47:26 <quicksilver> who cares about log factors anyway :)
13:47:29 <Sizur> quicksilver: thanks, taking a look at it
13:47:31 <fasta> quicksilver: I do :)
13:47:32 <quicksilver> Sizur: it gives you the 'right' interface
13:47:38 <quicksilver> fasta: you don't count :)
13:47:40 <Cale> musiKk: the opening segment of my http://haskell.org/haskellwiki/Monads_as_computation article might be of some help in figuring out why we use these funny monad things :)
13:48:56 <quicksilver> conal: ah well make sure you keep us posted, I'm sure you will.
13:49:03 <conal> quicksilver: btw, i highly recommend anti-aliasing your textures, if you're not already.  and doing so progressively, through multiple accumulating passes, each displayed.  since you're using a continuous representation, you're all set to do it.
13:49:13 <quicksilver> conal: your time zone and mine are a poor match but badger me for code some time
13:49:36 <conal> quicksilver: you bet.
13:49:42 <quicksilver> conal: since my textures are continuous, at most resolutions they don't need antialiasing :)
13:49:49 <quicksilver> but your point is well taken.
13:49:52 <conal> @localtime quicksilver
13:49:53 <lambdabot> Local time for quicksilver is Tue Dec  4 21:49:36 2007
13:49:56 <quicksilver> I do display progress passes
13:49:58 <mar77a> what's to 'eschew'
13:50:01 <quicksilver> progressive
13:50:09 <conal> quicksilver: you already do multi-pass?
13:50:23 <conal> quicksilver: with sub-pixel jitter?
13:50:42 <conal> quicksilver: that's what pan & pajama did/do.  simple & effective.
13:50:58 <conal> quicksilver: and much prettier at *any* resolution.
13:51:25 <gwern> heh. I feel silly now - I was tyring to put the evaluation into the 'get' binary instance. silly me
13:51:44 <musiKk> Cale: yes, i think i got some basics of the idea, right now i stick to yaht. lots of reading, lots of trying, you know ;-)
13:53:08 <Cale> musiKk: If you're having trouble getting something to typecheck or otherwise to work, feel free to stick it up on hpaste, and one of us can probably help. :)
13:53:40 <mar77a> > let f = f
13:53:40 <lambdabot>  Parse error at end of input
13:53:49 <mar77a> .o
13:54:01 <mauke> missing "in"
13:54:51 <quicksilver> conal: no, I dont' combine the passes
13:55:00 <quicksilver> conal: but I do display them progressively :)
13:55:12 <musiKk> Cale: yeah, i already noticed the exceptional helpfulness towards beginners here
13:55:18 <Cale> :)
13:55:33 <Cale> Heh, as I get closer and closer to completing this torrent I'm downloading, the number of people with the parts that I need keeps dropping along with the download speed, so that it's been 4 hours away from finishing for 4 hours now :)
13:56:35 <gwern> don't give up, Achilles!
13:58:34 <hpaste>  gwern pasted "I feel like I'm missing something silly here" at http://hpaste.org/4266
13:59:25 <gwern> it works, but only partially, which is unusual for haskell code - which tells me I am misunderstanding something about the functions I am using
13:59:26 <Cale> a :: [Math]
13:59:40 <Cale> You just assigned the wrong type to read from the file.
13:59:44 * gwern knew it was something silly. d'oh
14:00:08 <gwern> yes, that's the problem
14:00:25 <gwern> why, uh, does it not crash when it tries to read a file containing [Math] as a Math?
14:00:37 <Cale> I don't know.
14:00:41 <Cale> er
14:00:44 <Cale> not crash?
14:00:46 <stick_figure> I'm trying to define a type class for binary trees, and I can't seem to get it right.  I want to say something like this:
14:00:56 <stick_figure> class (Ord b) => BinaryTree (a b) where
14:00:57 <Cale> Because there is a valid value of type Math at the start
14:01:12 <ddarius> :t encodeFile
14:01:13 <lambdabot> Not in scope: `encodeFile'
14:01:20 <Cale> It probably serialises lists by just serialising each element
14:01:21 * ddarius can hope.
14:01:41 <stick_figure> but that complains: Type found where type variable expected
14:01:43 <ddarius> Cale: It serializes a size and then each element (or at least did)
14:01:51 <gwern> silly ddarius. does lambdabot even have extensions like Data.Binary installed?
14:01:56 <stick_figure> Any ideas on how to do this properly?
14:02:12 <Cale> ah, okay
14:02:13 <ddarius> gwern: Probably not, but one can hope.
14:02:20 <Cale> So the first Word8 of that size must be 0
14:02:51 <ddarius> I forget whether it stores words in big or little endian.
14:03:09 <Cale> stick_figure: So what is a supposed to be?
14:03:25 <SamB> if lambdabot doesn't have Data.Binary ... how does it save/load it's state?
14:03:30 <stick_figure> a is supposed to be the actual type of the tree, ie AATree or RedBlackTree
14:03:39 <ddarius> :t Data.Binary.encodeFile
14:03:41 <lambdabot> forall a. (Data.Binary.Binary a) => FilePath -> a -> IO ()
14:03:44 <ddarius> There we go.
14:03:52 <gwern> SamB: it passes an ioref to the recompiled lambdabot, or something
14:03:57 <stick_figure> Cale, or AVLTree, or SplayTree
14:03:59 <mar77a> is there something like exceptions and try/catching ?
14:04:13 <Cale> stick_figure: ah, okay
14:04:15 <byorgey> mar77a: yes, but you probably don't want to use it.
14:04:17 <SamB> gwern: what the heck
14:04:19 <ddarius> mar77a: There is about three or four mechanisms.
14:04:19 <byorgey> mar77a: why do you ask?
14:04:21 <SamB> it saves the state in files
14:04:25 <Cale> stick_figure: So perhaps you want a multiparameter typeclass?
14:04:34 <mar77a> byorgey: cause i like using exceptions
14:04:36 <SamB> lambdabot isn't that crazy yet
14:04:40 <byorgey> mar77a: I'm sorry.
14:04:51 <mar77a> about what? o_O
14:04:57 <Cale> stick_figure: or just put the Ord b constraint on the methods?
14:05:01 <stick_figure> Cale, so it would be more like BinaryTree a b?  Then I have to enable -fglasgowwhatever
14:05:03 <byorgey> that you like using exceptions. ;-)
14:05:07 <Cale> stick_figure: right
14:05:13 <gwern> @src reverse
14:05:13 <lambdabot> reverse = foldl (flip (:)) []
14:05:14 <Cale> stick_figure: or else just...
14:05:31 <Cale> class BinaryTree a where
14:05:31 <Cale>    foo :: (Ord b) => a b -> ...
14:05:31 <byorgey> mar77a: in Haskell, it's much more idiomatic to encode the possibility of failure in the data type that you use.
14:05:46 <stick_figure> Cale, right, I think I'll do that, even though that's a lot of duplication.
14:05:57 <mar77a> byorgey: why?
14:06:22 <ddarius> byorgey: Which can work out with things like the Error monad to being simultaneously both an error value and exceptions depending on how you use it.
14:06:38 <ddarius> (And you can use it both ways in the same code.)
14:07:15 <byorgey> mar77a: that way, the type system can help you guarantee various properties of your error handling -- e.g. that you don't have any "uncaught exceptions" and so on.
14:07:28 <mar77a> hmm
14:07:57 <byorgey> mar77a: the simplest example is the Maybe type.  for example, if you have a function that returns an Int but could possibly fail, you can make it return a value of type Maybe Int instead.
14:09:02 <gwern> @src ($)
14:09:02 <lambdabot> f $ x = f x
14:09:14 <byorgey> mar77a: and using the Maybe monad, you can put together a bunch of operations which might individually fail into one big operation which will fail if any of the individual ones do, neatly skipping any computation that would have happened after the point of failure.
14:09:34 <dibblego> I use the Maybe monad *all the time* (in Scala)
14:09:43 <mar77a> er byorgey , i'll understand that when i see monads probably
14:09:55 <mar77a> also, show and read are the IO converters?
14:09:59 <dibblego> mar77a, Java has the Maybe monad (it's a keyword called throws)
14:10:09 <Cale> mar77a: No, just strings to values and back
14:10:11 <mar77a> i don't know Java dibblego
14:10:16 <ddarius> mar77a: Indeed. Monads let you encode exceptions as a library (and Maybe and Either can be viewed that way)
14:10:24 <dibblego> mar77a, it's a bit a white lie anyway (more like the Either a monad)
14:11:04 <mar77a> > "num " ++ show 5
14:11:06 <lambdabot>  "num 5"
14:11:09 <dibblego> I really think the word monad has to be relabelled as a "design pattern" for the mainstream
14:11:12 <mar77a> > "num " ++ show read 5
14:11:13 <lambdabot>  Couldn't match expected type `t -> [Char]'
14:11:21 <dmwit> > shows 5 "num "
14:11:21 <lambdabot>  "5num "
14:11:31 <mar77a> > "num " ++ show read show 5
14:11:31 <lambdabot>  Couldn't match expected type `(a -> String) -> t -> [Char]'
14:11:38 <ddarius> dibblego: Monad doesn't fit the definition of "design pattern"
14:11:42 <Cale> dibblego: Too imprecise.
14:11:45 <dmwit> > "num " ++ (show . read . show $ 5)
14:11:46 <lambdabot>  "num 5"
14:11:52 <dibblego> ddarius, has accuracy ever bothered mainstream programmers?
14:11:54 <byorgey> > "num " ++ (show (read (show 5)))
14:11:54 <lambdabot>  "num 5"
14:11:56 <Apocalisp> Throw/catch in Java is goto/comefrom.
14:12:12 <Apocalisp> :-)
14:12:14 <hpaste>  Mitar pasted "nicer?" at http://hpaste.org/4267
14:12:30 <mar77a> 'mainstream programmers'?
14:12:41 <mar77a> haha, it's the first time i hear that word applied to programmers
14:12:52 <dibblego> mar77a, those who think design patterns are sensible
14:13:17 <Cale> Monads are just a particular kind of combinator library. I think explaining them like that is helpful.
14:13:33 <Cale> (or a particular kind of domain specific language, if you prefer)
14:13:47 <mar77a> i still think of monks when the workd comes up
14:13:48 <Apocalisp> dibblego: The status quo is not a stream, let alone a mainstream. It's a stagnant swamp.
14:13:54 <dibblego> I think "fluffy teddy bear design pattern called Monamed" is its new name
14:14:10 <dibblego> Apocalisp, I am very conservative in my description of the stupids ;)
14:14:25 <byorgey> mar77a: do you like monks?
14:14:38 <stick_figure> How do you enable -fglasgow-exts in the source file?
14:14:41 <mar77a> no, but it just appeals
14:14:57 <dibblego> stick_figure, as a pragma in a comment
14:15:03 <Cale> I'm surprised Colbert didn't take more flak from "Fudgie the Prophet" :)  http://cale.yi.org/autoshare/fudgie.png
14:15:04 * byorgey goes off to write a new tutorial, "Monads as Magical Monks"
14:15:16 <stick_figure> {-# -flasgow-exts #-}?
14:15:16 <mar77a> byorgey: medieval
14:15:44 <byorgey> oho!  "Monads as Magical, Medieval Mystery Monks"
14:15:54 <byorgey> MMMMM for short, of course
14:15:55 <Mitar> can be this combine i pasted be made from standard functions nicer?
14:16:27 <mar77a> hmm another thing that might be of interest is that when someone said 'lazy evaluation' the first time i couldn't take off the image of a program throwing a runtime error 'too lazy' and quitting
14:16:39 <Cale> Mitar: the 0 padding makes it tricky
14:16:52 <Mitar> yes ... i noticed
14:17:05 <Mitar> padding with infinite number of 0 does not help :-)
14:17:17 <Cale> Mitar: an ordinary interleave can be done using transpose and concat
14:17:23 <ddarius> Cale: I guess I'd needed to see the show?
14:17:57 <gwern> quicksilver: I think I've noticed a limitation to the adt technique - any eval can only decode a bunch of functions if they are of the same type?
14:18:05 <sorear> stick_figure: {-# is a generic pragma introducer, you need to specify that it's options for ghc: {-# OPTIONS_GHC -fglasgow-exts #-}
14:18:25 <byorgey> > let interleave as bs = concat $ transpose [as,bs] in interleave [1,2,3] [5,6,7]  -- hmm, I never thought of that!
14:18:28 <lambdabot>  [1,5,2,6,3,7]
14:18:31 <Cale> ddarius: It was a jab at the whole uproar regarding some depiction of the prophet Muhammad in a cartoon :)
14:18:48 <byorgey> > let interleave as bs = concat $ transpose [as,bs] in interleave [1,2,3] [5,6,7,8]
14:18:48 <lambdabot>  [1,5,2,6,3,7,8]
14:19:35 <opqdonut> nice
14:19:53 <mar77a> > foldr (+) (foldr (-) (0) [0,1,2,3]) [0,1,2,3]
14:19:54 <lambdabot>  4
14:20:06 <mar77a> shouldn't...that be 0
14:20:17 <dibblego> > foldr (-) (0) [0,1,2,3]
14:20:17 <lambdabot>  -2
14:20:24 <mar77a> hmm
14:20:27 <dibblego> foldr (+) (-2) [0,1,2,3]
14:20:30 <dibblego> > foldr (+) (-2) [0,1,2,3]
14:20:31 <lambdabot>  4
14:20:32 <opqdonut> youre reversing the signs
14:20:33 <byorgey> that's (0-(1-(2-3))
14:20:34 <dmwit> > 0 - 1 + 2 - 3
14:20:35 <lambdabot>  -2
14:20:37 <opqdonut> on each step
14:20:42 <opqdonut> yep
14:20:42 <mar77a> ohh
14:20:59 <mar77a> this is causing me problems more often than i thought
14:21:04 <dmwit> > foldl' (-) 0 [0..3]
14:21:05 <lambdabot>  -6
14:21:26 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
14:21:27 <lambdabot> Title: Fold Diagrams - CaleWiki
14:21:27 <byorgey> folds with non-associative operators are confusing =)
14:21:42 <Cale> that shows a nice way to picture the action of foldr/l etc.
14:21:52 <dmwit> Well (-) is left-associative, so you need a left fold. =)
14:22:04 <mar77a> aaa too much information
14:22:09 <mar77a> foldr foldl?
14:22:10 <dmwit> hehe
14:22:14 <mar77a> what's the difference?
14:22:28 <dmwit> mar77a: Have a look at Cale's link, it diagrams the difference nicely.
14:22:30 <dibblego> mar77a, there is a significant difference between the two; it's worth finding out
14:22:34 <dibblego> ?where folds
14:22:34 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
14:22:42 <dibblego> mar77a, ^^
14:22:55 <Cale> foldr f z xs will directly replace each (:) in xs with f and the [] at the end with z
14:23:23 <Cale> foldl f z xs does something a little bit more funky, but still pretty regular
14:23:41 <Cale> (it starts at the end of the list, basically)
14:23:45 <dmwit> :t mapAccumL
14:23:48 <Sizur> Data.Set is lazy, right?
14:23:57 <Mitar> > let interleave as bs = concat $ transpose [as,bs] in interleave [1,2,3] [5,6,7,8,9]
14:23:58 <RayNbow> Cale's fold diagrams once helped me to visualize folds in my mind :)
14:23:59 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:24:01 <lambdabot>  [1,5,2,6,3,7,8,9]
14:24:26 <fasta> Sizur: lazy in what way? :) (I don't know, since I haven't used it)
14:24:35 <Mitar> nop, not good, there should be 0 :-)
14:24:38 <mar77a> ok, i will never learn haskell
14:24:40 <fasta> (well, I did, but not enough to care)
14:24:44 <Mitar> i will just leave it as it is
14:24:48 <Cale> mar77a: hehe, what's wrong?
14:24:58 <Cale> mar77a: here's a small example of the difference:
14:24:59 <mar77a> well my brain doesn't work...that must mean im dumb
14:25:03 <dmwit> Sizur: I think Data.Set is based on Data.Map, which is spine-strict but value-lazy.  So Data.Set is probably the same.
14:25:05 <Cale> foldr (-) 0 [1,2,3]
14:25:06 <mar77a> no, i got the difference
14:25:12 <Cale> er, okay
14:25:14 <dibblego> mar77a, folds are not specific to Haskell and they are worth learning; a foldl (meaning fold left) is something many people write as a loop
14:25:15 <mar77a> fold* in fact, is quite easy
14:25:16 <Cale> So what's the problem?
14:25:25 <mar77a> but...i see what people write here
14:25:37 <Cale> mar77a: Learning Haskell slowly makes you smarter :)
14:25:50 <mar77a> unless it's your first language
14:25:53 <sorear> learning it quickly makes you dumb!?
14:25:54 <fasta> mar77a: most people write garbage in this channel.
14:25:58 <Sizur> dmwit: thanks. so map won't take O(n) if I only need 2 elements
14:26:00 <dmwit> No, hanging out in #haskell slowly makes you smarter.
14:26:06 <fasta> mar77a: just to show some trick.
14:26:07 <SamB> sorear: no, you can't learn it quickly
14:26:17 <dibblego> mar77a, don't be overwhelmed by what you see in this channel; a few "aha!" moments and you'll wonder why you even thought it was so difficult
14:26:31 <mar77a> that's why i hate chemistry
14:26:37 <byorgey> fasta: we love you too. ;-)
14:26:39 <fasta> mar77a: "Hey, look at me, I just did <X> in the most contrived way possible"
14:26:47 <dmwit> guilty
14:26:55 <Cale> mar77a: One of the reasons I think this channel is so beginner-friendly is that at some point we were all there.
14:26:58 <mar77a> 'ohhh so e- spins'?
14:26:59 <dmwit> byorgey: You know it's true. ;-)
14:27:15 <SamB> fasta: what's your point?
14:27:29 <fasta> SamB: that might be overwhelming.
14:27:31 <Stinger_> Cale isnt that true of almost anything?
14:27:34 <mar77a> well fasta , knowing how to do things in a strnage or complex way shows that you know something
14:27:40 <byorgey> dmwit: I plead the fifth. =)
14:28:01 <fasta> mar77a: nah, it only does when you manually did it without trial and error.
14:28:14 <dibblego> byorgey, I was in court a year or so ago and a defendant said that to a magistrate, who reminded him what country he was in (not USA) - it was pretty funny :)
14:28:16 <Cale> Stinger_: well, yes, to varying extents :) I suppose it's also that we were treated nicely as beginners and like to repay it by helping more people :)
14:28:17 <fasta> mar77a: and often the stuff you see is automatically generated.
14:28:27 <mar77a> like @src and that
14:28:28 <byorgey> dibblego: hehe, that's hilarious.
14:28:29 <davidL> Cale: Is the mbot source available somewhere, specifically the mathematica binding?
14:28:32 <Stinger_> fair enough
14:28:33 <mar77a> how is that even helpful? it's more confusing
14:28:39 <Cale> davidL: I can give you it if you'd like
14:28:43 <mar77a> you know, i don't like haskell cause i can't listen to music while learning it!
14:28:51 <davidL> Cale: sure :)
14:28:54 <mar77a> on the other hand i LOVE it's math-like approach
14:29:03 <mar77a> which is basically what's keeping me going
14:29:04 <Sizur> haskell is the only lang I know that let's me pass cli args without flags that specify what the arg means. by using Read
14:29:20 <byorgey> mar77a: well, that explains why you can't listen to music at the same time =)
14:29:24 <Sizur> easy that is
14:29:29 <byorgey> (I can't either)
14:29:39 <mar77a> it just requires...mucho mind power
14:29:46 <davidL> Cale: that is, if you don't mind
14:29:58 <gwern> 'Yer honor, I'd like to take the Fifth here.' '...You do realize that Australia does not have the Fifth Amendment, correct?'
14:30:12 <thoughtpolice> mar77a: most of what you think is complex is just simple. your brain will add complexity, the key to those 'aha' moments is just removing it.
14:30:24 <Cale> davidL: http://cale.yi.org/autoshare/mathmodule.tar.gz
14:30:28 <thoughtpolice> at least, that's how I took on learning haskell
14:30:34 <mar77a> how long does it take
14:30:38 <Cale> davidL: No guarantees of correctness or safety :)
14:30:41 <mar77a> shouldn't have asked probably hmm
14:30:48 <dmwit> mar77a: Ten years!
14:30:51 <dmwit> ;-)
14:30:53 <thoughtpolice> i couldn't tell you unless you gave me your brain ;)
14:30:58 <davidL> Cale: thanks! this will be interesting
14:31:01 <thoughtpolice> and i'm not too trustable with stuff like that.
14:31:02 <fasta> Haskell is basically a simple language, but you have to be a genius to understand the simplicity.
14:31:05 <Cale> davidL: I disavow myself of all security risks :)
14:31:07 <mar77a> thoughtpolice: lets pretend it's the size of a chimp
14:31:21 <mar77a> fasta: einstein said something like that
14:31:22 <davidL> Cale: no worries :)
14:31:33 <fasta> mar77a: no, Dennis Ritchie
14:31:36 <dmwit> mar77a: I managed to get to where I can hold my own in obfuscation contests in a little under a year. =P
14:31:40 <gwern> about unix originally
14:31:41 <Cale> davidL: (Mathematica is really really hard to secure, and I'm not actually sure that I've got everything locked down)
14:31:52 <fasta> mar77a: but with Haskell = Unix and language = operating system
14:32:09 <mar77a> no, i mean't another one fasta
14:32:23 <dmwit> Let's make things as simple as they can be, but no simpler?
14:32:24 <thoughtpolice> mar77a: that's just degrading. :) in any case, finding those aha moments can take no time or a lot of time. luckily, a lot of people here are good at removing complexity as much as possible. so, ask questions. :)
14:32:35 <mar77a> alright
14:32:56 <thoughtpolice> if somebody bites we'll just get a choke collar. promise.
14:33:10 <Sizur> on that note, again I commend the channel members for making this the most rewarding channel
14:33:15 <dmwit> if somebody... bites...
14:33:34 <davidL> Cale: I wonder if using FFI with MathLink is a better idea
14:33:44 <ddarius> thoughtpolice: What would a choke collar do?
14:33:45 <dmwit> If somebody bites via IRC, he gets an award, not a choke collar.  I've wanted to do that for years.
14:34:19 <mar77a> ok, i guess i learn faster through examples so i'll just play around with fold
14:34:45 <thoughtpolice> ddarius: make them stop biting? at least, that's what we had to use for our dog when she was little.
14:35:21 <mar77a> is there a way to void the 2nd argument of fold??
14:35:31 <davidL> foldl1
14:35:44 <bmeph_> or foldr1
14:36:03 <mar77a> i don't understand this then
14:36:10 <mar77a> why isn't the 'base' function foldr
14:36:18 <mar77a> why is the 2nd arg so important
14:36:35 <mar77a> or does haskell work the other way round? from bigger functions to smaller?
14:36:41 <mar77a> (currying that is)
14:37:31 <Cale> davidL: Probably
14:37:48 <Sizur> mar77a: foldr1?
14:38:22 <Cale> davidL: I used to have a bot written entirely in bash, and at some point I decided that was getting too annoying to maintain and replaced it with lambdabot, but I kept the kernel wrapper script.
14:38:28 <Sizur> mar77a: you need to start the fold from some value
14:38:31 <pheaver> yeah
14:38:37 <pheaver> oops, wrong window
14:38:46 <Cale> Er, you mean end it with some value?
14:38:57 <allbery_b> mar77a: fold[lr] are more general because they let you provide a base case, whereas fold[lr]1 require the list provide its own base case
14:39:00 <Cale> foldr f z [] = ...
14:39:05 <Cale> what should it return there?
14:39:23 <Cale> There's only one option -- you need that z
14:39:30 <Sizur> Cale: the sarting value ;)
14:39:34 <Sizur> starting*
14:39:42 <sjanssen> @where cabal-install
14:39:42 <lambdabot> http://darcs.haskell.org/cabal-install/
14:39:44 <Cale> Sizur: it's really at the end
14:39:55 <bmeph_> i.e., z ;)
14:40:30 <mar77a> ok, i'll just feel smart by doing the excercises from YAHT
14:40:32 <Cale> It's more the starting value in the case of foldl :)
14:40:35 <Sizur> Cale: oh yeah. oops... it's the right fold
14:40:43 <allbery_b> @src sum
14:40:43 <lambdabot> sum = foldl (+) 0
14:40:47 <allbery_b> @src product
14:40:47 <lambdabot> product = foldl (*) 1
14:41:01 <Cale> @src concat
14:41:01 <lambdabot> concat = foldr (++) []
14:42:00 <Sizur> mar77a: I know exactly how you feel m8... I'm wrestling with 'arrows'
14:42:02 <EvilTerran> @src map
14:42:02 <lambdabot> map _ []     = []
14:42:02 <lambdabot> map f (x:xs) = f x : map f xs
14:42:24 <Sizur> mar77a: it gets much better
14:42:35 <mar77a> Sizur: yeah i like it already
14:42:41 <mar77a> and the fact that it's actually challenging is good
14:43:01 <Cale> map f = foldr ((:) . f) []
14:43:09 <Sizur> that was my numero uno reason for haskell. because it was expanding my mind
14:43:18 <mar77a> it's like drugs omg
14:43:19 <Sizur> still is
14:43:22 <mightybyte> I'm trying to create a game with a randomized rectangular board.  I have "data Board = Board {width, height :: Int}" and this works great for constructing the dimensions, but how would I incorporate a random initialization into it?
14:44:21 <Cale> mightybyte: Like, maybe include an array of pieces, and then write a function which takes a StdGen and constructs a random one?
14:45:00 <mightybyte> Cale: Ok, so I'd have to make the array of pieces another argument to the type constructor?
14:45:05 <Cale> Haskell arrays store their bounds, so you won't even need the pair of Ints that way.
14:45:13 <mightybyte> Ahhh
14:45:23 <Sizur> mightybyte: make a initFunction
14:45:24 <Cale> board :: Array (Int,Int) Piece
14:45:51 <Cale> That's an array of values of type Piece which is indexed by (Int, Int) pairs.
14:45:59 <mightybyte> Or maybe even board :: Array (Int,Int) Maybe Piece ?
14:46:12 <davidL> Cale: what version of mathematica do you use the module with?
14:46:13 <Cale> sure, Array (Int, Int) (Maybe Piece)
14:46:27 <Cale> davidL: 6.0, formerly 5.2
14:46:37 <davidL> Cale: thanks
14:46:54 <nornagon> @src Array
14:46:54 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:47:00 <bmeph_> Cale: Aren't the (Int,Int) specifications of the bounds, not the index form?
14:47:01 <Cale> davidL: actually that reminds me that I should probably go through the list of forbidden things and see if there isn't anything extra which I should add
14:47:02 <mightybyte> Cale: Ok, that makes sense.  But it doesn't look like the bounds are implied by that.
14:47:10 <nornagon> @docs Array
14:47:10 <lambdabot> Array not available
14:47:14 <Cale> mightybyte: they're not
14:47:16 <nornagon> @docs Data.Array
14:47:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
14:47:27 <nornagon> 404'd!
14:47:41 <Cale> mightybyte: They'll be stored along with the array when the value of type Array (Int,Int) Piece is created though
14:48:14 <Cale> bmeph_: no, the bounds specification will be ((Int, Int), (Int, Int))
14:48:21 <mightybyte> But if I don't have a piece located on the right or bottom, will the bounds be correct?
14:48:41 <Cale> mightybyte: so long as you set the bounds correctly, then yes
14:48:46 <Cale> :t array
14:48:47 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
14:48:51 <nornagon> @instances Ix
14:48:52 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
14:49:02 <Cale> Here, i = (Int, Int)
14:49:03 <mightybyte> Ok
14:49:08 <Cale> So you'll call array like:
14:49:21 <davidL> Cale: can you run the kernel in such a way that it can't touch the filesystem?
14:49:25 <Cale> array ((0,0),(10,20)) [...]
14:49:38 <Cale> davidL: not that I can tell
14:50:53 <Cale> which means that the array indices start with (0,0) and end with (10,20)
14:51:01 <Cale> (and it's rectangular)
14:51:06 <mar77a> > (1 > 0) ? "true" : "false"
14:51:07 <lambdabot>   Not in scope: `?'
14:51:09 <mar77a> ouch
14:51:19 <Cale> > if 1 > 0 then "true" else "false"
14:51:19 <lambdabot>  "true"
14:51:26 <mightybyte> Ok, so instead of a two dimensional array, it's a one-dimensional array of tuples.
14:51:31 <bmeph_> So, how do you declare a hexagonal array? ;p
14:51:49 <Cale> mightybyte: well, indexed by tuples?
14:51:53 <Olathe> What's a hexagonal array ?
14:51:58 <Cale> mightybyte: I'd say it's two dimensional
14:51:59 <mightybyte> bmeph_: Probably use a rectangular representation? :)
14:52:08 <Cale> mightybyte: But it's not an array of arrays, if that's what you mean :)
14:52:11 <ddarius> > show (1 > 0)
14:52:12 <lambdabot>  "True"
14:52:17 <mightybyte> Cale: Yeah, probably
14:52:31 <Olathe> > error "Everything is fine."
14:52:31 <lambdabot>  Exception: Everything is fine.
14:52:37 <fasta> Cale: under the hood it could be implemented like that, right?
14:52:49 <Cale> fasta: It could be, but it's not.
14:52:52 <fasta> (modulo that it probably isn't)
14:53:06 <cpfr> hey what symbols can i use for making infix operators in haskell?
14:53:21 <gwern> a `foo` b
14:53:23 <davidL> > 15 `mod` 8
14:53:23 <gwern> ?
14:53:23 <lambdabot>  7
14:53:28 <bmeph_> > error "It proves the rule!"
14:53:30 <lambdabot>  Exception: It proves the rule!
14:53:37 <ddarius> It's actually implemented via a series of short order instructions to a collections of dwarves.
14:53:41 * gwern groans
14:53:41 <fasta> cpfr: operators are infix by definition
14:53:42 <opqdonut> ?quote
14:53:43 <lambdabot> bos says: imperative languages only go up to ten
14:53:45 <bmeph_> @botsnack
14:53:45 <lambdabot> :)
14:53:51 <mightybyte> Cale: Ok, thanks for the help.
14:53:53 <opqdonut> ?quote
14:53:53 <lambdabot> ghc says: Can't mix generic and non-generic equations for class method
14:53:59 <cpfr> i meant - + / etc
14:53:59 <mar77a> ?quote
14:53:59 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbs recruited in '07"
14:54:06 <opqdonut> ?quote
14:54:06 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
14:54:10 <opqdonut> >:)
14:54:11 <Olathe> > error "One that is excepted, especially a case that does not conform to a rule or generalization."
14:54:12 <opqdonut> ?quote
14:54:12 <lambdabot> musasabi says: reallyUnsafePointerEq# seems unsafe.
14:54:12 <lambdabot>  Exception: One that is excepted, especially a case that does not conform to ...
14:54:14 <fasta> cpfr: - is a special case
14:54:21 <EvilTerran> cpfr, anything that's not taken yet
14:54:25 <gwern> reallyUnsafeCat is being unsafe...
14:54:32 <fasta> cpfr: otherwise operators are infix
14:54:40 <cpfr> EvilTerran, where i get a list of what's taken
14:54:51 <EvilTerran> but not the [](),"'_` characters
14:54:58 <EvilTerran> @where report
14:54:58 <lambdabot> http://www.haskell.org/onlinereport/
14:55:00 <EvilTerran> @where prelude
14:55:01 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
14:55:18 <cpfr> and not alphanumerics?
14:55:30 <EvilTerran> indeed not
14:55:48 <cpfr> like a -8- b = a+b
14:56:00 <EvilTerran> in http://haskell.org/onlinereport/lexemes.html , you can use anything under "ascSymbol"
14:56:08 <cpfr> thanks!
14:56:11 <bmeph_> > let s = ">_^"; (/>/^/) ('>':xs) _ = '^':xs; g = g in s/>/^/g
14:56:12 <lambdabot>  "^_^"
14:56:12 <cpfr> that isnt taken
14:56:16 <Apocalisp> Clean's prelude uses o as the composition operator.
14:56:19 <EvilTerran> indeed
14:56:23 <bmeph_> My favorite quote... :)
14:56:32 <Cale> You can't use .. : :: = \ | <- -> @ ~ => as infix operators, but basically anything else composed of !#$%&*+./<=>?@\^|-~ is okay
14:56:33 <mar77a> ok, enough for the day
14:56:37 <ddarius> Haskell isn't Clean.
14:56:49 <Apocalisp> ddarius: No pun intended?
14:57:16 <gwern> sometimes I wish haskell was more clean-like though
14:57:19 * dmhouse wonders why \ is illegal
14:57:24 <ddarius> \x -> x
14:57:25 <Cale> Oh, and I suppose -- would be another thing that's not an infix operator, but --> is fine.
14:57:35 <opqdonut> --<>--
14:57:37 <ddarius> sometimes I wish clean was more haskell-like
14:57:54 <sjanssen> gwern: in what way?
14:57:54 <cpfr> thanks Cale Apocalisp EvilTerran and anyone else i didnt name
14:58:15 <gwern> sjanssen: did you see my long discussion in the scrollback about serializing functions?
14:58:43 <sjanssen> Clean can do that?
14:58:55 <gwern> sjanssen: apparently.
14:58:58 <Cale> You're also supposed to be able to use unicode symbol characters, but that doesn't work in any implementation that I'm aware of.
14:59:14 <Cale> Or does it work in newer GHCs now?
14:59:52 <fasta> Cale: only UTF-8, AFAIK.
15:01:34 <sjanssen> fasta: other encodings can be implemented using iconv as a pre-processor
15:01:57 <fasta> sjanssen: yes, nobody does that, I guess.
15:02:18 <sjanssen> no need, really, UTF-8 is ubiquitous
15:03:57 <fasta> The only thing I need from ghci (or ghc) is that it returns memory to the OS.
15:04:19 <sjanssen> yeah, that'd be nice
15:04:22 <fasta> My sessions always take up more and more memory until I decide to restart it.
15:04:45 <fasta> All the devs. of course have 4GB machines which means they don't notice it.
15:04:45 <Sizur> hmm, Data.Map seems to already have relational join through intersectionWith
15:04:50 <sjanssen> it should be easy, given that GHC uses a compacting collector
15:05:13 <sjanssen> fasta: I don't generally keep long-lived ghci sessions
15:05:39 <fasta> sjanssen: by long I mean about 8 hours.
15:05:57 <fasta> sjanssen: you used VIM?
15:06:04 <gwern> sjanssen: for more on what I mean by Clean, see http://www.haskell.org/pipermail/haskell-cafe/2007-December/035844.html
15:06:04 <sjanssen> fasta: yeah, I use vim
15:06:05 <lambdabot> Title: [Haskell-cafe] Clean Dynamics and serializing code to disk, http://tinyurl.com/3cumf3
15:06:17 <fasta> sjanssen: well, with Emacs I hold the same instance open.
15:06:59 <fasta> gwern: get a new mail client
15:07:29 <ddarius> fasta: Set a heap size?
15:07:30 <gwern> fasta: it's not my fault if mailman won't soft-wrap lines... and I think you mean editor
15:07:44 <fasta> ddarius: and then it crashes with "out of heap space"
15:08:07 <fasta> gwern: no, I didn't mean that.
15:08:08 <mauke> does ghci call malloc to request new memory?
15:08:23 <EvilTerran> i believe not...
15:08:24 <gwern> fasta: I think mutt is a fine mail client
15:08:32 <sorear> mauke: I beleive so
15:08:38 <fasta> gwern: anyway, everybody else's email arrives perfectly, yours doesn't.
15:08:40 <EvilTerran> code compiled with ghc doesn't, iirc
15:08:50 <EvilTerran> or only does so in big chunksa
15:08:51 <mauke> then it should be easy to convince it to return memory
15:09:23 <mauke> by setting M_MMAP_THRESHOLD to 1 or similar
15:09:42 <sorear> stop this idle speculation and check the tracker
15:09:54 <sorear> I assure you there is a bug listed for 'never returns memory'
15:10:15 <sjanssen> http://hackage.haskell.org/trac/ghc/ticket/698
15:10:17 <lambdabot> Title: #698 (GHC's internal memory allocator never releases memory back to the OS) - GH ...
15:11:17 <sjanssen> fasta: as a potential workaround, use a large swapfile
15:12:09 <fasta> sjanssen: the swap file is large enough. The problem is swapping.
15:12:44 <fasta> I wonder whether it will ever be fixed, as it's a long standing bug.
15:13:10 <mauke> dang, how do I check memory usage?
15:18:10 <sjanssen> fasta: yeah, the report has been around for three major versions
15:18:16 <sjanssen> (and has existed for longer, I'm sure)
15:18:53 <fasta> sjanssen: another problem is that GHC cannot be loaded in ghci, AFAIK.
15:19:09 <sjanssen> the GHC API, you mean?
15:19:23 <fasta> sjanssen: no, I mean when one wants to make modifications to GHC.
15:20:44 <sjanssen> fasta: that issue is significantly less troublesome, IMO
15:20:51 <sjanssen> especially considering how large GHC is
15:21:54 <fasta> sjanssen: are you suggesting it won't fit in memory?
15:22:04 <jtootf> hi everybody
15:22:14 <hpaste>  darrint pasted "Why isn't go type IO [FilePath]" at http://hpaste.org/4269
15:22:17 <fasta> sjanssen: it would boost the potential development pool significantly
15:22:29 <sjanssen> fasta: I just don't think I'd want to load GHC in GHCI since it would take 15 min.
15:22:40 <EvilTerran> even compiled?
15:23:00 <darrint> Could someone please take a look at my paste and tell my why I don't get IO [FilePath]? I'm getting IO [[FilePath]] instead.
15:23:09 <jtootf> I have one question regarding functors and list processing in haskell...may somebody help me ?
15:23:27 <clanehin_> I asked in #ghc but maybe I should just ask here.  I'm trying to figure out if this is a duplicate bug, I don't understand enough about full laziness to be sure:  http://hpaste.org/4268
15:23:40 <Cale> darrint: Well, that's what runListT is all about
15:23:58 <Cale> darrint: Though list transforming the IO monad is really evil. You don't have a real monad anymore.
15:24:12 <fasta> sjanssen: hmm, I had this idea of the interactivity of Squeak in my head.
15:24:18 <Cale> :t Control.Monad.List.runListT
15:24:19 <lambdabot> forall (m :: * -> *) a. ListT m a -> m [a]
15:24:35 <Cale> see? It adds a layer of lists to the result type
15:24:44 <sjanssen> fasta: I really doubt that a lack of interactivity is keeping developers away from GHC
15:24:55 <Cale> :t System.Directory.getDirectoryContents
15:24:56 <lambdabot> FilePath -> IO [FilePath]
15:25:39 <Cale> lift $ getDirectoryContents "/proc" :: ListT IO [FilePath]
15:25:51 <Cale> runListT (lift $ getDirectoryContents "/proc") :: IO [[FilePath]]
15:27:01 <Cale> I'd strongly advise against using the ListT that's in the libraries, since it's really broken.
15:27:12 <fasta> Cale: because?
15:27:25 <darrint> Cale: There's a better one?
15:27:30 <Cale> Because for any noncommutative monad (i.e. most of them), it doesn't produce a monad.
15:27:41 <Cale> Because associativity will fail.
15:28:11 <Cale> This will create very strange problems if you try to refactor code written in such a "monad"
15:28:38 <fasta> Cale: so, you argue against the existence of ListT in general?
15:28:38 <Cale> How you break things up into functions will affect the result!
15:28:55 <Cale> fasta: There are nondeterminism transformers which work better.
15:29:04 <EvilTerran> darrint, there's NondetT somewhere, iirc, which is correct
15:29:20 <Cale> http://www.haskell.org/haskellwiki/ListT_done_right -- this provides an example
15:29:20 <lambdabot> Title: ListT done right - HaskellWiki
15:29:30 <EvilTerran> or Oleg did a LogicT which does something simila (again IIRC)
15:30:02 <jtootf> huh. well, I'll just ask and wait for any response. I want to implement generalized map function. it should take function predicate as a first argument, list as a second one, and it should return list as well. if predicate takes one argument, it should work as ordinary map. if two - it should half list, returning [(f a1 a2), (f a3 a4), ..]; if three - [(f a1 a2 a3), (f a4, a5, a6), ..] and so on. I'm quite a newbie to functional programming
15:30:02 <jtootf>  at all, and to haskell in particular, so I just cannot see how to pattern number of arguments of predicate given. thank you for answers, if there will be any :)
15:30:28 <darrint> Cale: Ok. It says: ListT isn't really a monad transformer, which explains a lot.
15:30:37 <darrint> And kind of makes sense.
15:30:40 <EvilTerran> jtootf, to be blunt, that's not possible
15:30:47 <dmwit> jtootf: That's not very easy to do in Haskell. =P
15:30:48 <Cale> jtootf: well, you could use a typeclass
15:30:57 <EvilTerran> Cale, even with a typeclass, could that work?
15:31:01 <Cale> err...
15:31:11 <Cale> hmm
15:31:20 <EvilTerran> i strikes me as deeply unlikely
15:31:24 <Cale> There's probably some fancy way to make it work
15:31:41 <dmwit> It would require a non-trivial amount of type-hackery.
15:31:41 <EvilTerran> it'd involve at least overlapping, and probably incoherent instances
15:31:47 <Saizan> i suspect it's an half oleg
15:32:04 <Cale> yes
15:32:33 <EvilTerran> because that "function of two parameters" may return a function at runtime
15:32:35 <dmwit> jtootf: What's much easier is to define a map that lets you pass a function that works on tuples, and a list of tuples.  (ie the map already in the libraries ;-)
15:32:50 <EvilTerran> and so take three parameters
15:32:58 <dmwit> > map (uncurry (+)) [(0, 3), (5, 7), (16, -16)]
15:33:01 <lambdabot>  [3,12,0]
15:33:44 <Cale> > map (\(x,y,z) -> x^2 + y^2 == z^2) [(3,4,5), (2,16,20), (1,2,3)]
15:33:44 <lambdabot>  [True,False,False]
15:33:51 <Cale> > filter (\(x,y,z) -> x^2 + y^2 == z^2) [(3,4,5), (2,16,20), (1,2,3)]
15:33:52 <lambdabot>  [(3,4,5)]
15:34:42 <Cale> Then all you need is a function which builds tuples from your original list.
15:34:46 <dmwit> jtootf: In general, the function you're describing doesn't seem very useful, since we know at code-creation time how many arguments a function ought to take.  So we can get the uncurried version of it easily.
15:35:33 <EvilTerran> you could do something with a typeclass for the first N tuple types, and have your function take a tuple parameter
15:35:38 <Cale> (and there, you'll need to handle the corner case, for what to do when there aren't enough elements to make a tuple left over at the end)
15:35:50 <dmwit> (Incidentally, there's a "zippy" Applicative that lets you do something very close to what you want.)
15:35:56 <dmwit> You get code something like:
15:36:24 <dmwit> f `apply` listOfFirstArgs `apply` listOfSecondArgs `apply` listOfThirdArgs `apply`...
15:38:07 <jtootf> thank you all :) I see where to go and what to look for now. I'll try all the ways to find what fits better...
15:38:12 <dmwit> Here we go:
15:38:17 <dmwit> http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
15:38:28 <pheaver> jtootf: sounds like something you could do with template haskell, but I doubt you want to try that :p
15:39:16 <jtootf> pheaver : why not ? ;)
15:39:30 <esteban2> i wis the prolog channel were as active as this one :(
15:39:37 <esteban2> wish*
15:39:51 <dmwit> Sorry, but Haskell is sexier than Prolog. =P
15:39:58 <esteban2> Mmmm...
15:40:04 <esteban2> i like haskell better than prolog..
15:40:09 <esteban2> but i need to do shit on that language too
15:40:53 <jtootf> dmwit : thanx, I'll look through this doc now
15:41:05 <lament> isn't prolog basically a "homework language" by this point?
15:41:37 <pheaver> jtootf: Oh, because if you're new to functional programming, and Haskell, it wouldn't be very pleasant I think
15:43:12 <Liskni_si> what does homework language mean?
15:43:17 <tehgeekmeister> if i wanted to build up (and modify) an environment to run a chain of functions with, would i use the reader or the state monad or some combination of the two?
15:43:22 <tehgeekmeister> (and i need to do io, too...)
15:43:29 <dmwit> It means people only write things in it for a homework assignment that requires that particular language.
15:43:47 <jtootf> pheaver : if it makes language more flexible I think it could help me a lot. but I should look at it before making any conclusions of course
15:43:53 <dmwit> tehgeekmeister: Probably StateT, unless you can build the entire environment before you start running.
15:44:13 <tehgeekmeister> dmwit: the environment depends on the the io
15:44:33 <dmwit> Then StateT s IO is nice.
15:44:34 <mwc> tehgeekmeister, reader is for stuff that can be modified, (via local) for children, but that children can't propagate things back up to the "caller".
15:44:35 <tehgeekmeister> so no, then StateT with IO inside it?
15:44:44 <mwc> its sort of like environment variables
15:45:04 <mwc> State lets children propagate things out of their call
15:45:12 <tehgeekmeister> okay, thanks.
15:52:20 <jtootf> bye everybody
15:54:19 <sorear> lament: those who forget prolog are doomed to reinvent it
15:54:41 <lament> sorear: you don't have to forget it in order not to use it :)
15:59:29 <dmwit> :t liftM2 $ uncurry (***) . ((*) *** (zipWith (+)))
15:59:31 <lambdabot> forall (m :: * -> *) b a. (Monad m, Num b, Num a) => m (b, [a]) -> m (b, [a]) -> m (b, [a])
16:00:06 <dmwit> :t liftM2 $ \(k, ll) (h, rl) -> (k*h, zipWith (+) ll rl)
16:00:11 <lambdabot> forall (m :: * -> *) t a. (Monad m, Num t, Num a) => m (t, [a]) -> m (t, [a]) -> m (t, [a])
16:01:30 <tehgeekmeister> another monad issue, i need to bind functions (all of the same type) in a chain, but i don't know which function i need for the right hand side at any given point until part of the way thru the function, what do i do?
16:02:14 <dmwit> nondeterminism?
16:02:18 <dmwit> (Evaluate them all.)
16:02:33 <dmwit> Or, use guards, or ...
16:02:57 <dmwit> Could you be a bit more specific about which function you're part-way through when you decide things?
16:02:58 <EvilRanter> ... >>= \p -> x >>= (if p then f else g)
16:03:06 <EvilRanter> ?
16:05:19 <tehgeekmeister> in this http://hpaste.org/4261, the pattern of functions which are calling question, these are the ones i'm concerned with.  i want to build up state from the responses to the questions, which you do by binding two functions with in the state monad, (sorry if i'm not saying that right, i think it's understandable...), but i don't know which question will be next, as you can see, until the io is done
16:06:06 <dmwit> xchat-- for grabbing the ',' in that URL
16:06:36 <Toxaris> how should xchat decide if the , is part of it or not?
16:06:49 <dmwit> dunno
16:06:54 <dmwit> not my problem
16:07:07 <Toxaris> the standard says to quote urls like this in text: <http://hpaste.org/4261>, wich may or may not work with IRC clients
16:07:20 <SamB> it works with x-chat
16:07:23 <SamB> which standard says that?
16:07:47 <Toxaris> have read it in some RFC some years ago
16:08:11 <SamB> was it the RFC for URLs? for email? for what?
16:08:42 <Toxaris> i don't remember :(
16:09:38 <nornagon> @instances Random
16:09:45 <lambdabot> Couldn't find class `Random'. Try @instances-importing
16:09:53 <nornagon> @instances-importing Random
16:09:53 <lambdabot> Couldn't find class `Random'. Try @instances-importing
16:09:57 <nornagon> :(
16:10:05 <dmwit> tehgeekmeister: You're pushing more and more things onto the (hypothetical) call stack here.
16:10:41 <dmwit> tehgeekmeister: If all of your functions call loop (rather than returning to loop), you can't possibly hope to get past the first call of any function...
16:11:19 <dmwit> tehgeekmeister: You have a few options:
16:11:40 <dmwit> * don't call loop; this will let you pop things from the call stack and eventually go forward
16:12:11 <dmwit> * OR, encode the control flow into your functions by calling, eg, "nap" instead of "loop"
16:13:20 <dmwit> Let me annotate with an untested sample of the second possibility.
16:13:53 <rey_> SamB: that's the appendix of RFC 1738
16:14:13 <rey_> and the actual recommendation is <URL:http://...>
16:14:24 <SamB> rey_: that does NOT work
16:14:38 <rey_> (because in 1994, people needed to be told something was an url :)
16:14:52 <SamB> <URL:http://foo.com>
16:15:08 <SamB> that doesn't work either, but that's because x-chat thinks URL: is part of the URL
16:15:23 <Liskni_si> rxvt thinks the same
16:15:38 <idnar> works for me (in gnome-terminal)
16:15:53 <rey_> urxvt gets it right as well
16:16:58 <idnar> I don't think http://foo.com is a valid HTTP URL, it's missing the path
16:17:01 <idnar> ;)
16:17:06 <lambdabot> Title: yeah.com - Only the best links ...
16:17:16 <SamB> idnar: why does it need a path?
16:17:21 <SamB> isn't that part optional?
16:18:29 <hpaste>  dmwit annotated "Not very useful example of my flowchart dealio." with "embedding control flow =/" at http://hpaste.org/4261#a1
16:18:43 * rey_ thinks it's pretty sad that foo.com doesn't go to a geeky site
16:20:11 <tehgeekmeister> dmwit: why the uses of const?
16:20:18 <hpaste>  dmwit annotated "Not very useful example of my flowchart dealio." with "whoops, missed a few returns" at http://hpaste.org/4261#a2
16:20:32 <dmwit> tehgeekmeister: Style, it's not critical.
16:20:53 <davidL> Why doesn't Haskell have binary matching or binary comprehensions like Erlang?
16:21:39 <dmwit> > (length "const ", length "\_ -> ")
16:21:40 <lambdabot>  Illegal escape sequence at ""\_" (column 26)
16:21:45 <dmwit> > (length "const ", length "\\_ -> ")
16:21:47 <lambdabot>  (6,6)
16:22:04 <idnar> SamB: I don't believe so
16:22:12 <idnar> SamB: although browsers will insert / for you anyway
16:22:22 <SamB> h t t p : / / hostport [ / path ] [ ? search ]
16:22:32 <SamB> http://www.w3.org/Addressing/URL/5_BNF.html
16:22:38 * Japsu finds "const x" more readable than "\_ -> x"
16:23:37 <dmwit> :t fix (>>)
16:23:38 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
16:23:38 <lambdabot>     Probable cause: `>>' is applied to too few arguments
16:23:38 <lambdabot>     In the first argument of `fix', namely `(>>)'
16:23:47 <Japsu> then there's of course also the cases where you pass const around without applying it to an argument yourself
16:23:57 <mrd>  _. x
16:24:24 <hpaste>  dmwit annotated "Not very useful example of my flowchart dealio." with "This time, decoupling flow control by allowing to return to loop" at http://hpaste.org/4261#a3
16:25:15 <idnar> SamB: hmm
16:25:55 <idnar> SamB: ok, my bad
16:26:13 <idnar> SamB: the http scheme defines an empty path to mean "/"
16:26:28 <SamB> can't imagine what else it would mean
16:26:52 <idnar> SamB: well, I thought it was just invalid
16:27:10 <tehgeekmeister> dmwit: return?  what monad is this in?
16:27:28 <dmwit> tehgeekmeister: I assume IO, based on the fact that you're calling it from main.
16:27:38 <dmwit> tehgeekmeister: ...and calling things like putStrLn and so on.
16:27:40 <tehgeekmeister> oh!  that makes sense.
16:27:44 <idnar> SamB: rfc2396 doesn't allow an empty path, though, so that's probably what I'm thinking of
16:27:45 <tehgeekmeister> right, sorry.
16:27:52 <idnar> SamB: (but rfc3986 does)
16:27:55 <tehgeekmeister> just starting to get used to doing actual programming with monads.
16:28:05 <dmwit> (the "do" notation should tip you off to monadness, too)
16:28:11 <nornagon> grr
16:28:15 <nornagon> i hate fromIntegral :(
16:28:24 <dmwit> Yeah, the name is too long.
16:28:25 <dmwit> =/
16:28:43 <nornagon> it's especially annoying in ffi situations
16:28:43 <LoganCapaldo> > let fi = fromIntegral in fi 3
16:28:44 <lambdabot>  3
16:28:54 <LoganCapaldo> fffffffffi
16:29:04 <nornagon> LoganCapaldo: that works only with -fno-monomorphism-restriction, i think?
16:29:14 <idnar> SamB: even more fun is that rfc1738 says the slash has to be there, but that it's not part of the path (?!?)
16:29:17 <dmwit> Or with a type annotation.
16:29:29 <nornagon> dmwit: ah
16:29:48 <nornagon> the thing with ffi is that i have to go Int <-> Int16 <-> Word8 <-> etc etc
16:29:52 <nornagon> all the damn time
16:30:36 <byorgey> well, write some conversion functions with names like 'q'. =)
16:31:28 <SamB> idnar: well, I think it's pretty clear what the truth is in regard to whether it counts as part of the path...
16:31:49 <SamB> well, the truth is it depends on whether the path is supposed to start with /..
16:32:15 <nornagon> byorgey: but then i also have to add brackets and crap
16:32:38 <byorgey> nornagon: hm? why?
16:32:39 <nornagon> 4 vs (q 4)
16:32:52 <byorgey> nornagon: but I thought you already had to write fromIntegral 4.
16:33:06 <nornagon> it's still not a nice solution though :/
16:33:19 <Saizan> nornagon: c2hs?
16:33:40 <nornagon> Saizan: ?
16:33:55 <nornagon> i'm just doing stuff the normal foreign import ccall way
16:34:31 <pi3> @src maximum
16:34:31 <lambdabot> maximum [] = undefined
16:34:32 <lambdabot> maximum xs = foldl1 max xs
16:34:55 <nornagon> doesn't foldl1 already handle the [] case?
16:35:04 <nornagon> > foldl1 (+) []
16:35:09 <newsham> > [toEnum (0x12345678 `shiftL` n)| n <- [32,24..0]] :: [Word8]
16:35:15 <lambdabot>  Exception: Prelude.foldl1: empty list
16:35:15 <lambdabot>  Exception: Enum.toEnum{Word8}: tag (2013265920) is outside of bounds (0,255)
16:35:25 <nornagon> > maximum []
16:35:28 <lambdabot>  Exception: Prelude.maximum: empty list
16:35:32 <newsham> > [toEnum ((0x12345678 `shiftL` n) .&. 0xff)| n <- [32,24..0]] :: [Word8]
16:35:33 <lambdabot>  [0,0,0,0,120]
16:35:37 <dmwit> :t uncurry (***)
16:35:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
16:35:46 <newsham> > [toEnum ((0x12345678 `shiftL` n) .&. 0xff)| n <- [24,16..0]] :: [Word8]
16:35:46 <lambdabot>  [0,0,0,120]
16:35:52 <dmwit> :t (uncurry (***) .)
16:35:52 <lambdabot> forall (a :: * -> * -> *) b c b' c' a1. (Arrow a) => (a1 -> (a b c, a b' c')) -> a1 -> a (b, b') (c, c')
16:35:57 <pi3> @maximum [1,2,3]
16:35:58 <lambdabot> Unknown command, try @list
16:35:58 <newsham> > [toEnum ((0x12345678 `shiftR` n) .&. 0xff)| n <- [24,16..0]] :: [Word8]
16:35:59 <lambdabot>  [18,52,86,120]
16:36:02 <newsham> left/right, whatever :)
16:36:06 <pi3> > maximum [1,2,3]
16:36:06 <lambdabot>  3
16:36:08 <dmwit> :t (*) *** zipWith (+)
16:36:08 <lambdabot> forall a a1. (Num a, Num a1) => (a, [a1]) -> (a -> a, [a1] -> [a1])
16:36:29 <newsham> norn: only one "toEnum" going from Int -> [Word8]
16:36:52 <dmwit> :t zipWith (+)
16:36:54 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
16:37:03 <Toxaris> > maximum [1..1000000]
16:37:06 <lambdabot>  1000000
16:37:18 <LoganCapaldo> @type liftM2 (+)
16:37:18 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
16:38:03 <xpika> > maximum [1..100000000]
16:38:08 <lambdabot>  100000000
16:38:13 <LoganCapaldo> > (liftM2 (+) [1,2,3] [4,5,6], zipWith (+) [1,2,3] [4,5,6])
16:38:14 <lambdabot>  ([5,6,7,6,7,8,7,8,9],[5,7,9])
16:38:27 <Toxaris> why can lambdabot do what my ghci can't?
16:38:38 <LoganCapaldo> the first function is way cooler
16:38:47 <dmwit> :t pure
16:38:48 <lambdabot>     Ambiguous occurrence `pure'
16:38:48 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
16:38:48 <lambdabot>                           or `pure', imported from Control.Arrow
16:38:49 <LoganCapaldo> @index maximum
16:38:49 <lambdabot> Data.List, Prelude
16:38:57 <dmwit> :t Control.Arrow.pure
16:38:57 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
16:39:02 <idnar> > let (f, g) = t (*) *** zipWith (+) $ (5, [1..10]) in (f 5, g [1..5])
16:39:02 <lambdabot>   Not in scope: `t'
16:39:11 <idnar> > let (f, g) = (*) *** zipWith (+) $ (5, [1..10]) in (f 5, g [1..5])
16:39:11 <lambdabot>  (25,[2,4,6,8,10])
16:39:58 <dmwit> :t liftM2 $ uncurry (***) . ((*) *** (pure (zipWith (+))))
16:39:58 <lambdabot>     Ambiguous occurrence `pure'
16:39:58 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
16:39:58 <lambdabot>                           or `pure', imported from Control.Arrow
16:40:06 <dmwit> :t liftM2 $ uncurry (***) . ((*) *** (Control.Arrow.pure (zipWith (+))))
16:40:07 <lambdabot> forall (m :: * -> *) b a. (Monad m, Num b, Num a) => m (b, [a]) -> m (b, [a]) -> m (b, [a])
16:40:14 <Olathe> > pure insanity
16:40:15 <dmwit> Even that doesn't help. =P
16:40:22 <lambdabot>   Not in scope: `insanity'
16:40:31 <Olathe> > sanity
16:40:31 <lambdabot>   Not in scope: `sanity'
16:40:35 <Olathe> That's better.
16:40:43 <LoganCapaldo> > pure target
16:40:43 <lambdabot>   Not in scope: `target'
16:40:45 <dmwit> > pure alcohol
16:40:45 <lambdabot>   Not in scope: `alcohol'
16:40:56 <idnar> undecidable sanity
16:40:56 <dmwit> But I assure you, there *is* alcohol in Scope.
16:41:09 * LoganCapaldo groans
16:41:41 <Olathe> > error 1
16:41:42 <lambdabot>   add an instance declaration for (Num [Char])
16:42:03 <LoganCapaldo> > error [chr 1]
16:42:04 <lambdabot>  Exception: 
16:42:24 <Olathe> @where botdeath
16:42:24 * lambdabot dies.
16:42:44 <LoganCapaldo> @where ami
16:42:44 <lambdabot> I know nothing about ami.
16:42:49 <dmwit> :t liftM2 $ uncurry (***) . ((Control.Arrow.pure (*)) *** (Control.Arrow.pure (zipWith (+))))
16:42:49 <lambdabot> forall (m :: * -> *) b a. (Monad m, Num b, Num a) => m (b, [a]) -> m (b, [a]) -> m (b, [a])
16:42:59 <LoganCapaldo> @where+ ami #haskell
16:42:59 <lambdabot> I will remember.
16:43:02 <dmwit> hum
16:43:04 <LoganCapaldo> @where ami
16:43:04 <lambdabot> #haskell
16:43:15 <dmwit> What thing do I have to wrap in "pure" to get an arrow at the end?
16:43:50 <byorgey> dmwit: depends on the arrow.
16:43:54 <Olathe> lambdabot's in a lot of channels where that will appear strange.
16:43:59 <Toxaris> dmwit: a function
16:44:02 <LoganCapaldo> dmwit: liftM2 is never gonna spit out an arrow "at the end"
16:44:02 <dmwit> byorgey: I want any arrow.
16:44:06 <byorgey> dmwit: something of type (a -> b) will do.
16:44:18 <byorgey> dmwit: I mean, it depends on the arrow instance.
16:44:21 <dmwit> LoganCapaldo: ah... hm
16:44:32 <Toxaris> dmwit: pure :: (normal function) -> (effectless arrow)
16:44:34 <byorgey> if you're using the (->) instance of Arrow.
16:44:39 <LoganCapaldo> unless you throw some kind of Kleisi stuf in there
16:44:44 <LoganCapaldo> which i don't quite grok
16:44:49 <byorgey> oh, wait, never mind =)
16:44:55 <byorgey> @type Control.Arrow.pure
16:44:57 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
16:44:58 <dmwit> Toxaris, byorgey: Yes, I know, I'm talking specifically about that block of code above.
16:45:50 <byorgey> dmwit: aha, I didn't understand what you were asking =)
16:45:54 <byorgey> hmm...
16:45:56 <LoganCapaldo> :t pure $ liftM2 $ uncurry (***) . ((Control.Arrow.pure (*)) *** (Control.Arrow.pure (zipWith (+))))
16:45:56 <lambdabot>     Ambiguous occurrence `pure'
16:45:56 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
16:45:56 <lambdabot>                           or `pure', imported from Control.Arrow
16:46:06 <LoganCapaldo> :t arr $ liftM2 $ uncurry (***) . ((Control.Arrow.pure (*)) *** (Control.Arrow.pure (zipWith (+))))
16:46:06 <lambdabot> forall (a :: * -> * -> *) (m :: * -> *) b a1. (Arrow a, Monad m, Num b, Num a1) => a (m (b, [a1])) (m (b, [a1]) -> m (b, [a1]))
16:46:08 <tehgeekmeister> dmwit: using return in there is good, but i'm still not sure how to get build state from the answers to questions, which was my original goal -- admittedly unnecessary at this stage, but i want to build a more general mechanism for this, and at some point the answers will be important for the future of the control flow
16:46:38 <LoganCapaldo> I doubt that's what you are looking for <g>
16:46:50 <LoganCapaldo> but there you go, an arrow! :)
16:47:14 <Toxaris> dmwit: maybe you want something like (Control.Arrow.pure (uncurry (*))?
16:47:28 <tehgeekmeister> because, still, we don't know which function to bind to next in the state monad until after the io is done, which is part of the way thru the function call.
16:48:10 <dmwit> tehgeekmeister: I'm still not sure I understand what you're getting at.
16:49:07 <byorgey> :t (arr (*) *** arr (zipWith (+))) >>> arr (uncurry (***))
16:49:15 <lambdabot> forall (a :: * -> * -> *) a1 c. (Num c, Num a1, Arrow a) => a (c, [a1]) ((c, [a1]) -> (c, [a1]))
16:50:00 <Toxaris> dmwit: why are you using liftM2 with arrows? this will force your Arrow instance to be (->)
16:50:26 <dmwit> Toxaris: I'm looking at <http://programming.reddit.com/info/624f2/comments/>.
16:50:27 <tehgeekmeister> i want to remember the answers to questions, for more complicated flowcharts i'll need to use the state.
16:50:39 <tehgeekmeister> or the past state, even.
16:51:21 <tehgeekmeister> i'm looking at some sort of a hybrid of writer and state.
16:52:18 <dmwit> State subsumes Writer.
16:52:34 <Toxaris> tehgeekmeister: Control.Monad.RWS(T)?
16:53:27 <LoganCapaldo> RWS, the ultimate hodge podge monad!!!
16:53:45 <dmwit> RWS seems really unnecessary.
16:54:31 <dmwit> Does it even have convenient put/get/ask/tell commands?
16:54:32 <tehgeekmeister> i just need to remember the answers, probably in a map so i can access them later.
16:54:41 <LoganCapaldo> arguably beats having to do ReaderT r (writerT w (State ... or whatver
16:54:48 <LoganCapaldo> dmwit: of course
16:54:53 <LoganCapaldo> @type tell
16:54:54 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
16:55:01 <LoganCapaldo> @instances MonadWriter
16:55:01 <dmwit> LoganCapaldo: Just use State.  There's nothing RWS can do that State can't.
16:55:02 <byorgey> LoganCapaldo: no, the ultimate hodgepodge monad would be something like RWSSTCMLIO.
16:55:02 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
16:55:58 <LoganCapaldo> dmwit: Sure. or you could just use IO all the time. there's nothing State an do that IO can't.
16:56:12 <dmwit> Sure there is.
16:56:17 <dmwit> There's runState.
16:56:26 <dmwit> There's no equivalent for that in the IO monad.
16:56:56 <LoganCapaldo> well writer and reader have different semantics than state
16:56:58 <dmwit> (unsafePerformIO doesn't count)
16:57:10 <Toxaris> dmwit: most important sentence from that blog posting: "I'll abuse arrow combinators a bit."
16:57:28 <dmwit> Toxaris: yeah =/
16:58:02 <dmwit> I don't think the community benefits from showing this kind of post to people who don't know Haskell, really.
16:58:05 <Toxaris> dmwit: but I do it myself all the time, Control.Arrow should be aliased as Data.Pair
16:58:15 <LoganCapaldo> isn
16:58:28 <LoganCapaldo> *isn't Control.Applicative full stuff like the stuff in Arrow?
16:58:29 <dmwit> Toxaris: Sure, it often leads to shorter, more readable code.  Do you think this is so in this case?
16:59:13 <LoganCapaldo> @type(*>)
16:59:14 <lambdabot> Unknown command, try @list
16:59:17 <LoganCapaldo> @type (*>)
16:59:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:59:25 <LoganCapaldo> mm
16:59:46 <LoganCapaldo> @src Applicative
16:59:46 <lambdabot> class Functor f => Applicative f where
16:59:46 <lambdabot>     pure  :: a -> f a
16:59:46 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
17:00:28 <Toxaris> dmwit: "But I'll never use prod by itself, so ..." <-- this is nonsense. there's nothing wrong with giving names to expressions, even if they are used only once. there's where and let to avoid namespace polution
17:00:28 <dibblego> is liftM to fmap as ap is to <*> ?
17:00:59 <dmwit> Yes.
17:01:11 <LoganCapaldo> nope I'm imaginning it
17:01:21 <dmwit> Note that fmap has fewer restrictions than liftM for behavior, and <*> has fewer restrictions on its behavior than ap.
17:02:02 <tehgeekmeister> hmm, i'm not sure it's even possible to use any monad here, unless i entirely decouple the flow control, and i'm not sure how to do that, either.
17:02:26 <dmwit> StateT [Response] IO -- ?
17:02:49 <Brian`> @src splitAt
17:02:49 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
17:03:05 <Brian`> @src span
17:03:05 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:03:07 <Toxaris> LoganCapaldo: I would say that Control.Arrow and Control.Applicative are only very loosely related (they handle similar problems, but are working quite differently)
17:03:33 <dmwit> span p xs = (takeWhile p xs, dropWhile p xs)
17:04:12 <dmwit> > let span' p xs = (takeWhile p xs, dropWhile p xs) in span' id [True, True, False] = span id [True, True, False]
17:04:12 <lambdabot>  Parse error at "=" (column 83)
17:04:24 <dmwit> > let span' p xs = (takeWhile p xs, dropWhile p xs) in span' id [True, True, False] == span id [True, True, False] -- just to make sure
17:04:26 <lambdabot>  True
17:06:13 <dmwit> > let span' p = liftM2 (,) (takeWhile p) (dropWhile p) in span' id [True, True, False]
17:06:15 <lambdabot>  ([True,True],[False])
17:06:25 <dmwit> :t join
17:06:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:08:29 <dmwit> ?pl \p -> liftM2 (,) (takeWhile p) (dropWhile p)
17:08:29 <lambdabot> ap (liftM2 (,) . takeWhile) dropWhile
17:08:38 <dmwit> :t ap
17:08:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:09:56 * dmwit can't yet figure that one out in his head
17:11:44 <dmwit> ?pl \p -> liftM3 (,,) (f p) (g p) (h p)
17:11:44 <lambdabot> ap (ap (liftM3 (,,) . f) g) h
17:11:57 <mar77a> is there a glob function for haskell?
17:12:27 <LoganCapaldo> @type \f a  -> { do g <- f ; a' <- a ; return (g a') }
17:12:28 <lambdabot> parse error on input `{'
17:12:39 <LoganCapaldo> @type \f a  -> do { g <- f ; a' <- a ; return (g a') }
17:12:39 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (t1 -> t2) -> t t1 -> t t2
17:12:40 <dmwit> Oh!  That makes perfect sense now.
17:13:19 <Toxaris> > let span = curry $ uncurry takeWhile &&& uncurry dropWhile in span id [True, True, False]
17:13:20 <lambdabot>  ([True,True],[False])
17:13:43 <shachaf> dmwit: In (r ->), ap is S.
17:14:00 <dmwit> shachaf: Yes, I can parrot this fact back at any time, but I have not yet digested it. =P
17:14:27 <shachaf> dibblego: I'd say liftM:liftA as ap:(<*>), maybe.
17:14:46 <shachaf> dmwit: Well, substitute "r ->" for "m".
17:17:02 <dibblego> shachaf, thanks
17:17:12 <LoganCapaldo> @type \f a -> (return f) `ap` a
17:17:17 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
17:17:18 <dmwit> :t liftM2 (&&&) takeWhile dropWhile (uncurry . flip id)
17:17:18 <lambdabot>     Couldn't match expected type `(a -> b -> c, b) -> c'
17:17:18 <lambdabot>            against inferred type `Bool'
17:17:18 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
17:18:40 <DRMacIver> Hm. There's a program called "anna" which seems to be used in a bunch of benchmarks / tests. What is it? google is being uninformative.
17:19:22 <dmwit> ?pl \f -> f x + f y
17:19:22 <lambdabot> liftM2 (+) ($ x) ($ y)
17:19:38 <mar77a> what does getLine return when eol is reached?
17:19:56 <LoganCapaldo> mar77a: do you mean eof?
17:19:57 <dmwit> You mean eof?
17:20:18 <mar77a> no, end of line
17:20:37 <DRMacIver> Ah. Just something from nobench apparently
17:20:40 <dmwit> It does not include the eol.
17:20:44 <shachaf> mar77a: getLine doesn't include the newline, if that's what you mean.
17:20:47 <dmwit> It also eats up empty lines.
17:20:53 <mar77a> ok
17:21:13 <dons> DRMacIver: its a strictness analyser
17:21:13 <dmwit> Oops, no it does not eat up empty lines.
17:21:21 <DRMacIver> dons: Ah ha. Thanks.
17:23:56 <mar77a> how would i write a function that reads till eof, one line at a time
17:24:13 <jleedev> fmap lines getContents
17:24:40 <Toxaris> > let span = (&&&) <$> takeWhile <*> dropWhile in span id [True, True, False] -- what about this one?
17:24:42 <lambdabot>  ([True,True],[False])
17:24:44 <sethk> What happened to the Haskell IDE project that was ongoing a while ago?  Anyone know?
17:25:51 <dmwit> Toxaris: VERY pretty.
17:26:01 <dmwit> Toxaris++
17:27:09 <shachaf> > let span = liftA2 (&&&) takeWhile dropWhile in span id [True, True, False] -- ?
17:27:11 <lambdabot>  ([True,True],[False])
17:27:23 <BMeph> dons: Where can I pick up a 'lambda-warez.net' T-shirt? ;)
17:28:33 <mwc> signs I'm studying too much for this exam: upon reading http://broken-latex.jottit.com/ my first thought was what sort of convergence properties this implies
17:28:36 <lambdabot> Title: Broken LaTeX: Home
17:29:00 <mwc> second thought was how do I define a metric, and what set does some variant of tex map into itself?
17:29:20 <mwc> which clearly shows I still haven't studied this enough ;)
17:30:34 <Toxaris> dmwit: but i wonder, is it sensible to call both takeWhile and dropWhile? isn't the point of span to avoid over-application of the predicate?
17:31:41 <dmwit> At most, you'll call it one extra time for each element that passes the test.
17:31:52 <dmwit> Which kind of sucks, but probably isn't that bad in reality.
17:32:14 <dmwit> Anyway, we're just providing a specification, it can be implemented efficiently in the compiler. ;-)
17:32:25 <Toxaris> dmwit: depends on reality, wich is bad for a library function...
17:35:39 <LoganCapaldo> stupid reality
17:37:21 <LoganCapaldo> stupid non-sufficently smart compilers
17:38:03 <dmwit> We don't need a sufficiently smart compiler.
17:38:28 <dmwit> We need a sufficiently smart human who writes an efficient implementation whose behavior matches our specification in all but running time/space.
17:38:35 <mrd> sufficiently smart compilers are always countered by sufficiently stupid coders
17:38:39 <dmwit> Which, luckily, we have. =)
17:40:09 <LoganCapaldo> stupid sufficiently stupid coders
17:40:35 <Toxaris> > let {span' p (x:xs) | p x = (x :) `first` span' p xs; span' p xs = ([], xs)} in span' id [True, True, False]
17:40:37 <lambdabot>  ([True,True],[False])
17:40:44 <hpaste>  stick_figure pasted "What's wrong with this where clause?" at http://hpaste.org/4270
17:40:48 <BMeph> Which begs the question: what is an insufficiently stupid coder like? ;p
17:41:07 <sethk> BMeph, don't know, I'm sufficiently stupid myself.
17:41:16 <LoganCapaldo> BMeph: terrifying I imagine
17:41:20 <stick_figure> Can anyone say what's wrong with that where clause?
17:41:38 <Toxaris> stick_figure: try indenting it more then "AABranch"
17:41:47 <Toxaris> stick_figure (just a guess)
17:42:00 <conal> stick_figure: what's the error message?  and where is t defined?
17:42:02 <stick_figure> Toxaris, nope.
17:42:12 <LoganCapaldo> where's t?
17:42:16 <stick_figure> t is an error, my bad
17:42:26 <conal> stick_figure: and do you know that in Haskell "where" is attached to a definition, not an expression?
17:42:46 <stick_figure> I switched to pattern matching, t used to represent the whole second argument.
17:42:57 <BMeph> stick_figure: Have you considered using just one where, and defining both pred and succ there? :)
17:42:57 <stick_figure> conal, that's probably it.
17:43:11 <stick_figure> BMeph, then I would need another inline if with the same logic.
17:43:11 <mar77a> "In some sense, yes. The I/O monad constitutes a small imperative sub-language inside Haskell, and thus the I/O component of a program may appear similar to ordinary imperative code."
17:43:15 <mar77a> i give up
17:43:21 <stick_figure> I was just trying to make it 80 cols clean
17:43:26 <shachaf> stick_figure: where can only be used with =.
17:44:04 <sethk> hpaste, indentation
17:44:43 <stick_figure> shachaf, yeah, that seems to be it.
17:44:45 <stick_figure> thanks
17:45:07 <stick_figure> I figured where was like a postfix let, which is kind of neat.  Is there any reason it's not that way?
17:46:21 <mwc> stick_figure, just that it attaches to a definition, not an expression
17:47:11 <mwc> so f x = g x where g x = ... is equivalent to (in pseudo haskell) let g x = ... in f x = g x, and not f x = let g x = ... in g x
17:47:38 <hpaste>  LoganCapaldo annotated "What's wrong with this where clause?" with "alternative formatting" at http://hpaste.org/4270#a1
17:47:40 <BMeph> let is an expression; where is not.
17:48:00 <hpaste>  Toxaris annotated "What's wrong with this where clause?" with "I would do it like this" at http://hpaste.org/4270#a2
17:48:32 <Toxaris> hmm, LoganCapaldo was faster and his code is nicer
17:48:34 <shachaf> There's also a difference between "f x = \y -> let z = g x in z + y" and "f x = \y -> z + y where z = g x".
17:48:40 <LoganCapaldo> Toxaris: ge tout of my head! ;)
17:48:46 <stick_figure> ooh, I like the t@(...) notation, that's good to know.
17:49:21 <stick_figure> I just formatted the code with that indentation because it's the easiest to achieve without fighting vim too much.
17:49:39 <dataangel> In a do block, what difference is there between "x <- stuff" and "let x = stuff" ?
17:49:48 <mwc> dataangel, the world
17:49:52 <shachaf> dataangel: One translates to (>>=).
17:49:54 <BMeph> let is an expression; where is not.
17:49:54 <dibblego> dataangel, the type of x
17:49:54 <LoganCapaldo> <- explands to >>= \x ->
17:50:00 <mwc> x <- stuff performs the io action stuff, and binds the result to x
17:50:07 <LoganCapaldo> let just names the expression on the rhs
17:50:08 <mwc> the other is a straight binding of non-monadic action
17:50:18 <mwc> which is a value
17:50:19 <dataangel> what if stuff is pure?
17:50:29 <mwc> then <- is meaningless, outside of the identity monad
17:50:37 <LoganCapaldo> x <- pureStuff wouldn't type check
17:50:45 <dataangel> oh
17:50:50 * dataangel should have tried compiling ;p
17:51:13 <shachaf> LoganCapaldo: Sure it will: "do { x <- [1,2,3]; return (x+1) }". :-)
17:51:28 <LoganCapaldo> shachaf: shh
17:51:30 <mwc> dataangel, to see if you undestand it, is do { let x = f; y <- x } equivalent to do { y <- f} ?
17:51:52 <BMeph> shachaf: lists are instances of monads. :p
17:52:28 <shachaf> BMeph: Exactly. "pure" /= "non-monadic". :-)
17:52:30 <Saizan> mwc: in that they are both "syntax" errors?:)
17:52:32 <LoganCapaldo> BMeph: but [1,2,3] is pure
17:52:42 <Toxaris> LoganCapaldo: in what sense of pure?
17:52:48 <mwc> Saizan, indeed, there should be an action at the end
17:52:53 <mwc> at a ... at the end ;)
17:53:12 <dibblego> ?type mplus . return
17:53:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => a -> m a -> m a
17:53:18 <Toxaris> > do {x <- (+); x} $ 21
17:53:22 <lambdabot>  42
17:53:31 <LoganCapaldo> Toxaris: in the sense that it invalidate my "x <- pureStuff wouldn't compile" statement
17:53:58 <dibblego> ?check \x xs -> (mplus . return) x xs -> (x :: Int) :: xs
17:53:58 <lambdabot>  Parse error at "->" (column 32)
17:54:06 <dibblego> ?check \x xs -> (mplus . return) x xs == (x :: Int) :: xs
17:54:06 <lambdabot>  Couldn't match expected type `m Int' against inferred type `Int'
17:54:13 <shachaf> @ty (<|>) . Control.Applicative.pure
17:54:13 <lambdabot> forall (f :: * -> *) a. (Alternative f) => a -> f a -> f a
17:54:49 <atp> is there a difference between Control.Applicative.pure and Control.Arrow.pure (ie, arr) ?
17:55:06 <dataangel> mwc: Err, can let bind x to a monadic type?
17:55:08 <shachaf> atp: Is there much of a similarity, other than the name?
17:55:16 <shachaf> ?check \x xs -> (mplus . return) x xs == (x :: Int) : xs -- This?
17:55:16 <dons> :t Control.Applicative.pure
17:55:17 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
17:55:17 <lambdabot>  OK, passed 500 tests.
17:55:17 <Toxaris> atp: they are completely different
17:55:20 <dons> :t Control.Arrow.pure
17:55:21 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
17:55:43 <atp> shachaf: i don't actually know what Control.Applicative.pure does, which is why i'm asking... but Toxaris answered my question non-rhetorically, so you needn't bother
17:55:47 <mwc> dataangel, yep, but it's not "sequenced" until the y <- x is "evaluated"
17:55:49 <atp> thanks Toxaris
17:55:56 <shachaf> atp: It's like return.
17:55:57 <dons> pure == return in Applicative
17:56:13 <atp> shachaf: as is Control.Arrow.pure
17:56:25 <dataangel> mwc: Err, I guess in order for the first to compile, x would be assigned to the monadic action, then y <- x would actually execute it. So yes, they would be the same.
17:56:28 <atp> hm, i don't know much about Applicative.  better take a look
17:56:36 <mwc> dataangel, that's the point :)
17:56:36 <dons> its a Monad without >>=
17:56:43 <clanehin_> atp: Applicative is a typeclass that is weaker than monads but stronger than functors, and thus much weaker than Arrows, so it's not the same.
17:56:44 <dons> so not a monad :)
17:56:50 <shachaf> dataangel: do { let x = print 5; ... } -- Sure.
17:56:50 <atp> i see
17:56:54 <dons> yeah, Arrows are off in their own land
17:57:00 <shachaf> dons: But with ap and fmap.
17:57:12 <idnar> arrows are weaker than monads ;)
17:57:12 <dons> yep
17:57:13 <atp> if they're functors they get fmap, what's ap?
17:57:18 <dataangel> what's the 'proper' way to check if an element is in a list? find seems overly complex, I just want a true or false
17:57:19 <shachaf> @ty ap
17:57:21 <shachaf> @ty (<*>)
17:57:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:57:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:57:33 <shachaf> @ty elem
17:57:34 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:57:48 <atp> how is <*> different than fmap then?
17:57:56 <shachaf> @ty fmap
17:57:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:57:57 <atp> i should just read the source
17:58:05 <Saizan> or the type
17:58:06 <atp> instead of asking ill-informed questions
17:58:09 <dons> 'fmap' f x = 'pure' f '<*>' x
17:58:11 <atp> oh, right, missed the f
17:58:29 <shachaf> > fmap (+1) [1,2,3]
17:58:33 <lambdabot>  [2,3,4]
17:58:40 <dons> f <$> a = fmap f a -- however
17:58:52 <dons> :t toUpper <$> getChar
17:58:54 <clanehin_> As far as I can tell, Applicative is generic zipping.  If someone can illuminate another use, I'd be interested to know about it.
17:58:55 <lambdabot> IO Char
17:58:56 <BMeph> atp: No f-ing off in this channel... ;p
17:58:57 <shachaf> > [(+1),(*2)] <*> [1,2,3]
17:58:58 <lambdabot>  [2,3,4,2,4,6]
17:59:02 <dons> clanehin_: zipping?
17:59:24 <dons> Applicative is for monadic-ish stuff that never assigns intermediate variables (e.g. pretty printing, parsing)
17:59:30 <clanehin_> dons: f <$> a <*> b is zipWith f a b, generic
17:59:44 <shachaf> clanehin_: Only for ZipList.
17:59:45 <atp> shachaf: that's pretty neat
17:59:47 <dons> ah, quite so. i've never used it for zip like things though :)
17:59:58 <dons> just `zip' over functors
17:59:59 <Toxaris> clanehin_: I use Applicative as a better interface for many uses of Monads
18:00:04 <shachaf> dons: I think clanehin_ is asking about Applicatives that aren't Monads.
18:00:43 <atp> so we have functor < applicative < monad < arrow then, basically
18:00:46 <dons> yeah, i've not used any of those. a bit like the only Arrow I use being (-> a)
18:00:58 <Toxaris> would it be possible to translate some of the motivating examples of Arrows to Applicatives?
18:01:00 <shachaf> atp: No, arrows aren't monads.
18:01:07 <dons> atp, i wouldn't put arrows in there.
18:01:07 <atp> shachaf: yes, i know
18:01:22 <dons> its Functor + >> == Applicative, Applicative + >>= = Monad
18:01:24 <atp> shachaf: but all monads are arrows...
18:01:38 <atp> dons: i see
18:01:43 <shachaf> dons: ap, not (>>).
18:01:47 <dons> yeah, >> and return
18:02:01 <dons> Monad - >>= == Applicative
18:02:01 <mwc> dons, I thought that the Kleisli arrows were arrows generated by a given monad
18:02:04 <clanehin_> I was comming from the angle that an arrow can do anything a monad can do, just as a monad can do anything an applicable can do.
18:02:16 <Toxaris> atp: nope. all monads give raise to an arrow, but a monad can never *be* an arrow (look at types)
18:02:42 <mwc> dons, I think on reflection you meant that arrow isn't a subclass of monad in the haskell typeclass sense)
18:02:44 <Toxaris> but every monad *is* an applicative
18:02:45 <dons> instance Monad m => Arrow (Kleisli m) where arr f = Kleisli (return . f) first (Kleisli f) = Kleisli (\ ~(b,d) -> f b >>= \c -> return (c,d)) second (Kleisli f) = Kleisli (\ ~(d,b) -> f b >>= \c -> return (d,c))
18:02:54 <atp> Toxaris: i thought there was a relatively natural isomorphism between Kleisli arrows and monads?
18:03:10 <Cale> atp: There is.
18:03:12 <dons> there is.
18:03:19 <shachaf> dataangel: Look at http://haskell.org/haskellwiki/Monads_as_computation for an explanation of do-notation and monads in general.
18:03:22 <dons> natural, but cumbersome :)
18:03:32 <atp> ok, that's what i thought.  when i say "are" i mean "are isomorphic to"
18:03:37 <shachaf> dons: Monad - (>>=) + ap. :-)
18:03:50 <mwc> atp, he means that monad isn't an arrow in the sense of a type class
18:03:57 <Toxaris> atp: but there is no notation of isomorphy in Haskell :)
18:04:15 <shachaf> dons: You forgot (>>>), also. :-)
18:04:17 <mwc> ie, arrow doesn't have a >>=
18:04:21 <atp> mwc: right, sorry, i wasn't clear
18:04:30 <mwc> atp, neither was I at first
18:05:01 <idnar> clanehin_: the point of arrows is that they can do *less* than a monad
18:05:07 <Saizan> clanehin_: arrows are strictly less expressive than monads, but you can get a monad from every ArrowApply
18:05:14 <atp> right
18:05:24 <atp> i knew that, i should have been more clear.  sorry
18:05:41 <atp> Arrow + ArrowApply => isomorphic to monad (right?)
18:06:06 <hpaste>  dataangel pasted "newbie type error. Am I using 'if' inside a do block wrong?" at http://hpaste.org/4271
18:06:10 <conal> maybe already mentioned, but: Arrow & Applicative allow static analysis, while Monad doesn't.
18:06:35 <Saizan> atp: yes, there's an instance like that in Control.Arrow iirc
18:06:36 <atp> right, wasn't that the impetus for arrows in hughes' original paper?
18:06:43 <Cale> dataangel: you probably don't want fail
18:07:14 <conal> atp: yes (if that question was for me)
18:07:20 <atp> conal: it was, sorry :)
18:07:40 <Toxaris> dataangle: fail needs a string parameter
18:07:43 <conal> atp: np
18:07:46 <dataangel> Cale: why not? the idea is reserved words can't be variable names, so the parse shouldn't succeed. The call to parseVarName has a try() around it
18:08:20 <conal> a nice thing about Applicative is that the analyzability comes in a form that is simpler than both Monad and Arrow.
18:08:34 <clanehin_> Saizan, idnar: you're right, I was letting my own specific use cases distort my abstract reasoning.
18:08:40 <conal> and has a nice applicative feel, rather than Monad's sequential feel.
18:08:44 <atp> actually, while we're on the subject of functors, can anyone think of a use of comonads that can't also be done (even cumbersomely) with monads?  for example, i find the product comonad to be more intuitive than the exponent monad, but the two are isomorphic and the latter allows do notation...
18:08:50 <Cale> dataangel: If you're using parsec, you likely want something like  unexpected "reserved word"
18:09:12 <Cale> dataangel: the type error is because fail expects a parameter
18:09:35 <Cale> dataangel: but you should never call fail manually
18:09:39 <Toxaris> > elem "dataangel" ["dataangel:", "there", "is", "elem", "for", "searching", "in", "lists"]
18:09:41 <lambdabot>  False
18:09:53 <Toxaris> > elem "dataangel" ["dataangel", ":", "there", "is", "elem", "for", "searching", "in", "lists"]
18:09:54 <lambdabot>  True
18:10:25 <mwc> dataangel, the purpose of fail in the monad is for when you try to use <- to bind to a pattern that doesn't exist
18:10:41 <mwc> (x:y:_) <- return [x]
18:10:51 <Cale> It's a bad hack and never should have been included in the standard.
18:10:52 <mwc> at least, that's the purpose justifying fail in the report
18:11:02 <dataangel> Toxaris: thx :)
18:11:17 <atp> i think Parsec is a MonadZero though and fail just calls mzero
18:11:19 <mwc> Cale, yeah, I agree, that should have just been the same kind of failure as failed pattern match in pure code
18:11:35 <Cale> mwc: I think it should generate a MonadZero constraint actually
18:11:36 <atp> or pzero, as they call it...
18:11:41 <Cale> mzero
18:11:48 <atp> (Parsec provides pzero)
18:11:55 <atp> same thing, different spelling
18:11:58 <Cale> atp: ah, I missed your previous message
18:12:06 <atp> np
18:12:22 <dataangel> I don't really follow the whole fail is for binding nonexistant patterns thing
18:12:23 <Cale> There's also 'unexpected' if you want to put a message with the failure as well.
18:12:29 <SamB> Cale: I agree
18:12:34 <dataangel> why would you be binding nonexistant patterns anyway?
18:12:37 <atp> dataangel: as they said, it was sort of a silly thing
18:12:45 <Cale> dataangel: It's for pattern match failure, is a better way to say it
18:12:47 <SamB> not that you've likely forgotten
18:12:53 <atp> dataangel: like, if you're doing Just x <- someMaybeFunction
18:13:03 <Cale> dataangel: for example, if I write  do [x] <- getArgs
18:13:25 <Cale> and then getArgs returns a list which is not exactly length one, fail will be used
18:13:45 <atp> means you don't need to check all the time if all you'd do is fail anyway
18:14:19 <atp> it can be useful because fail needn't abort, like in the list monad it just [] iirc
18:14:31 <Cale> However, it gives people the wrong impression that monads need to support failure, when most monads actually don't support it.
18:14:55 <Cale> There used to be a class MonadZero for monads which had a nice failure mechanism.
18:15:02 <atp> isn't there still?
18:15:10 <Cale> no, it was merged into MonadPlus
18:15:15 <atp> oh.  that's lame.
18:15:16 <Cale> (stupidly)
18:15:41 <atp> probably trying to make it look more like a monoid
18:15:52 <atp> no good reason not to have them separated if you ask me
18:15:56 <Cale> MonadPlus was always a subclass of MonadZero anyway
18:16:37 <atp> yeah, it seems weird... the tendency in haskell has always been towards greater generality, not less
18:16:45 <atp> why would they merge the two?
18:16:49 <SamB> atp: except in Haskell 98
18:16:53 <Cale> Someone noticed that all the instances of MonadZero in the libaries were also instances of MonadPlus
18:17:03 <SamB> Haskell 98 is apparantly the Haskell version of Windows ME
18:17:24 <Cale> Totally.
18:17:30 <atp> SamB: but very few of us actually code in straight Haskell 98 anyway, and the recent developments have all been towards greater generality, not less
18:17:32 <Cale> 1.4 is so much better
18:17:45 <SamB> atp: yes
18:18:01 <Brian`> @src iterate
18:18:01 <lambdabot> iterate f x =  x : iterate f (f x)
18:18:36 <Cale> atp: We also used to have monad comprehensions, and map was a member of the class Functor
18:18:54 <SamB> I really think we should try to get fail moved into MonadZero in Haskell', since it's trivial to implement and a really really good idea...
18:18:56 <atp> yeah, getting rid of monad comprehensions is dumb
18:19:04 <atp> and map should be dumped in favor of fmap i think
18:19:11 <atp> or at least just be an alias
18:19:18 <SamB> the only argument against it is backwards compatability
18:19:25 <Cale> Getting rid of monad comprehensions got the ball rolling for basically all the other things that went wrong with Haskell 98.
18:19:33 <SamB> with the stupidest haskell standard ever
18:19:57 <Cale> This is Haskell we're talking about. Since when do we care about backwards compatibility?
18:20:10 <Cale> :)
18:20:14 <atp> of course, some ideas are pretty radical... someone was making (.) into fmap
18:20:21 <atp> was talking about*
18:20:22 <Toxaris> Cale: It's easier for newcomers if things are backwards-compatible :)
18:20:27 <Cale> atp: That was me :)
18:20:28 <SamB> well, since Haskell 98 we have been reluctant to make GHC incompatible with Haskell 98
18:20:39 <atp> Cale: it has a certain obfuscating appeal :)
18:21:04 <LoganCapaldo> renaming map to fmap and adding a new function named map wasn't exactly backwards compatible at the time either...
18:21:07 <Cale> atp: It's actually really quite nice. fmap is one of those things which you'd use more and more the shorter the name gets.
18:21:39 <SamB> Cale: personally, I'd be inclined to go back to "map" first
18:21:55 <atp> Cale: i think it's a pretty neat idea, and it doesn't bother me in the least, but is (a ->) already an instance of class functor?
18:21:56 <Cale> I also *really* like how the Functor laws are exactly what you'd already expect (.) to satisfy
18:22:12 <Cale> atp: no, except if you import Control.Monad.Reader
18:22:22 <Cale> (or Control.Monad.Instances)
18:22:36 <atp> Cale: it's neat how it all ends up being associative
18:22:40 <Cale> But that's an easy enough instance to move into the prelude :)
18:22:48 <Cale> atp: right :)
18:23:09 <Cale> The associativity of (.) is exactly the fusion law for map
18:23:14 <atp> i think it would be pretty cool.  the only downside is that it might be harder for newbies with no math background
18:23:34 <LoganCapaldo> since when has haskell cared about newbs? :p
18:23:36 <atp> anyway, i need to go.  but it was nice chatting with you guys :p
18:23:37 <Cale> Meh, you just tell them that (.) is function composition, or "apply to all"
18:23:44 <LoganCapaldo> oh sure #haskell cares about newbs
18:23:50 <atp> Cale: which they'll believe until they see some code you wrote
18:23:54 <LoganCapaldo> but haskell? :)
18:24:02 <Cale> (+1) . [1,2,3,4] = [2,3,4,5]
18:24:40 <atp> ok.  see you guys
18:24:50 <Cale> see you
18:25:19 <Cale> LoganCapaldo: right, we make the language as mind-expanding as possible, and then handle the rapid cranial expansion problems on IRC :)
18:26:58 <LoganCapaldo> Cale: brilliant :)
18:27:18 <faxathisia> haha
18:28:01 <tehgeekmeister> faxathisia: http://hpaste.org/4261#a3 if you want to take a look, i'm at a roadblock now and can't seem to make the program too much more elegant or powerful yet.
18:28:09 <Saizan> we should start distribuiting a new base with these changes and start usign -fno-implicit-prelude :)
18:28:22 <faxathisia> tehgeekmeister: Cool!
18:29:03 <Cale> tehgeekmeister: btw, there are functions for generating random numbers directly in IO
18:29:11 <Cale> :t randomRIO
18:29:12 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:30:00 <tehgeekmeister> Cale: yes, i noticed that in dmwit's annotations, thanks for mentioning it, tho.  the big problem is that, no matter how many times i tried, i never seemed to be able to get a random number less than 70.  that seems fishy to me.
18:30:34 <SamB> random = 4
18:30:37 <Cale> tehgeekmeister: huh
18:30:46 <SamB> -- chosen with die, can't be wrong!
18:31:41 <Cale> tehgeekmeister: try   fmap sort . replicateM 100 . randomRIO $ (0,100)
18:31:52 <tehgeekmeister> Cale: i kept rerunning the program, and it never chose a random number less than 70 given the range 0 to 100, which seems to me like either the random number generator isn't so random or i'm not doing things right.
18:33:10 <Toxaris> tehgeekmeister: I vaguely remember that random produces not-really-random things in the first call, but better stuff in later calls due to fishy implementation.
18:33:25 <Cale> randomRIO (0,100) should uniformly pick numbers in the range 0 to 100 inclusive
18:33:27 <Toxaris> tehgeekmeister: but i've never understand the details :(
18:33:47 <Cale> depends on how you construct the generator
18:34:19 <Cale> newStdGen should be all right
18:34:41 <daniel_larsson> Cale, tehgeekmeister: Looks good to me, 75, 70, 69 and 71 numbers below 70 for a few runs )
18:34:43 <tehgeekmeister> Cale: what should i get from this snippet you gave me?
18:35:05 <Cale> tehgeekmeister: a bunch of randomly selected numbers from 0 to 100
18:35:26 <tehgeekmeister> daniel_larsson: huh, i don't know why it never triggered that branch for me, then...
18:35:40 <tehgeekmeister> Cale: well, these are about as random as i could expect.
18:35:52 <faxathisia> if you want random numbers why are you using a computer!
18:36:16 <Cale> It would be really nice if motherboards came with a proper hardware RNG.
18:36:18 <Olathe> Because it does better than I do.
18:36:39 <faxathisia> I kept asking for one of these http://www.araneus.fi/products-alea-eng.html
18:36:40 <lambdabot> Title: Araneus
18:37:26 <tehgeekmeister> faxathisia: i don't really want random numbers, i just don't want to write an interface to an e-mail server, so i figured that'd be better than any other option.
18:37:57 <faxathisia> tehgeekmeister: Why don't you enumerate every possible type of interaction in your flow chart langauge
18:38:16 <faxathisia> like I guess you've got, cases on strings (from reading a line), cases on < <= > etc on numbers..
18:38:52 <faxathisia> because then you could basically have an entire flowchart represented as data and write an interpreter
18:38:56 <TSC> Wow, that USB RNG is pretty expensive
18:39:11 <faxathisia> (instead of it seems like you are manually unfolding a single instance of such an interpreter)
18:39:47 <tehgeekmeister> faxathisia: that's what i want to do, i just took this approach to get an idea of how it'd work before trying to write any parsers.
18:39:53 <sgillesp1e> hello
18:40:10 <faxathisia> oh ignore parser for now
18:40:12 <tehgeekmeister> the idea is definitely to have a sort of a flowchart language, however.
18:40:20 <sgillesp1e> I was wondering if it is possible to achieve erlang-style concurrency in haskell?
18:40:25 <faxathisia> you can represent everything in haskell
18:40:33 <Cale> sgillesp1e: basically, yes.
18:40:34 <faxathisia> lists.. tuples.. data types
18:40:52 <Toxaris> tehgeekmeister: you don't need parser for EDSLs in Haskell
18:41:01 <sgillesp1e> basically?...
18:41:06 <faxathisia> I would think the best way to generate the haskell data would be output from a GUI editor of flow charts
18:41:35 <Cale> sgillesp1e: Well, you have to write some stuff to manage the channels, but there's a Chan concurrent datastructure in the libraries
18:41:36 <faxathisia> (and if it was written in haskell you could run them directly)
18:41:53 <tehgeekmeister> it would be, but i don't want to mess with gui yet.  i'm keeping this entirely terminal based, being that it's my first application i've written on my own for any real use.
18:41:59 <Cale> sgillesp1e: and threads are lightweight enough
18:42:19 <tehgeekmeister> but i would like to make a gui for it eventually -- if i can just get past the roadblocks i'm having now.
18:42:39 <sgillesp1e> I see...
18:43:04 <Cale> sgillesp1e: STM is a really nice foundation for building any sort of concurrency abstraction you might like
18:43:18 <sgillesp1e> STM?
18:43:27 <ddarius> Cale: I'd like a concurrency abstraction that scales to a distributed setting.
18:43:31 <tehgeekmeister> faxathisia: oh!  unfolding!  i kept feeling like this was something along the lines of a fold, but i'd forgotten about unfold.
18:43:33 <Cale> Software Transactional Memory
18:43:36 <tehgeekmeister> unfold is exactly what i need, i think.
18:43:44 <sgillesp1e> oh
18:43:52 * tehgeekmeister searches to see if this is the case
18:44:38 <Cale> ddarius: maybe NDP, but that's not exactly concurrency so much as parallelism
18:46:02 <Cale> sgillesp1e: I'll get you the relevant paper :)
18:46:10 <sgillesp1e> excellent!
18:46:22 <faxathisia> tehgeekmeister: Write your flowchart out as just data and no code
18:46:30 <Cale> http://research.microsoft.com/~simonpj/papers/stm/index.htm
18:46:32 <lambdabot> Title: Papers on transactional memory
18:46:35 <Cale> in particular...
18:46:43 <Cale> http://research.microsoft.com/~simonpj/papers/stm/index.htm#composble
18:46:44 <lambdabot> http://tinyurl.com/ylls27
18:46:48 <Cale> http://research.microsoft.com/~simonpj/papers/stm/stm.pdf
18:46:53 <Cale> blah :)
18:47:42 <sgillesp1e> awesome, thanks a lot
18:48:18 <tehgeekmeister> faxathisia: okay, so your recommendation is to have the flowchart as a data structure and to write functions that abstract the most common sorts of input handling, then?
18:49:31 <faxathisia> all!
18:49:32 <stick_figure> Is there a slick way to make this into a list comprehension so it's more succinct?
18:49:47 <dataangel> Weird parsec problem: I have p <|> q <|> r testing a string Z. This causes stack overflow. If I just do p <|> q, then Z matches against p, and no stack overflow. Now if Z matches p, why does adding <|> r have any effect at all?
18:49:50 <stick_figure> trees = foldr (\elt (x:xs) -> (insert elt x):x:xs) [AANil] elements
18:52:18 <tehgeekmeister> no more case expressions?  sounds good to me, they seemed like an ugly hack.
18:52:18 <Toxaris> dataangel: parsec tests all alternatives in parallel in some way, not one after another
18:52:18 <faxathisia> really? I thought it did them one by one
18:52:44 <stick_figure> I'm trying to accumulate a list of trees built by successively inserting elements into the last tree.
18:52:56 <LoganCapaldo> if it did it in parallel that would make try sperflous wouldn't it?
18:54:05 <LoganCapaldo> dataangel: is r (indirectly) recursive?
18:54:40 <LoganCapaldo> maybe at some point p <|> q is failing it goes to r, which eentually recurses to the same production as p <|> q <|> r... ?
18:55:37 <apparition> hi pplz
18:57:25 <tehgeekmeister> so something along the lines of this for my data type: data Question = Question String (String -> Question)
18:57:47 <tehgeekmeister> that seems like it'll do what i need to me.
18:58:00 <tehgeekmeister> (oh, maybe it should be IO String -> Question?)
18:58:57 <LoganCapaldo> it'll be pretty hard to write a (useful) function with type IO String -> Question
18:58:57 <faxathisia> well I thought not
18:59:20 <faxathisia> more like Question String -> (InputType, Condition)
18:59:23 * Toxaris tried to understand parsec sources
18:59:26 <ddarius> LoganCapaldo: You'd end up with an infinite deal of nothing.
18:59:26 <faxathisia> or something -like- that
18:59:46 <Toxaris> looks like parsec doesnt parse alternatives in parallel
18:59:52 <ddarius> Toxaris: They are basically explained and discussed in the Parsec letter if I remember correctly or in some other paper on Parsec.
19:00:04 <ddarius> Toxaris: It doesn't.  Parsek does though.
19:00:05 <faxathisia> anyway I imagine you'd like IO and such to be just part of what drive it
19:00:11 <faxathisia> not the actual description itself
19:00:17 <Toxaris> ddarius: Parsek?
19:00:28 <ddarius> (Not "parallel" parallel but "breadth first" so to speak.)
19:00:36 <ddarius> @google Parsek
19:00:37 <lambdabot> http://www.cp2.parsek.com/
19:00:37 <lambdabot> Title: CP2 - Free to develop.
19:00:42 <ddarius> @google Parsek Koen Claessen
19:00:43 <lambdabot> http://ufal.mff.cuni.cz/~smrz/Encode/doc/html/Parsek.html
19:03:12 <tehgeekmeister> faxathisia: i can't see why i'd want that type, explain please?  i was thinking i'd have a general function that prints the question, takes input, feeds it to the function of type String -> Question, get the next question, and keep going like that...
19:03:39 <faxathisia> tehgeekmeister: not that exactly but something like it
19:04:26 <LoganCapaldo> tehgeekmeister: you may want to consider accounting for the last question, ie Maybe (String -> Question) or (String -> Maybe Question)
19:05:02 <tehgeekmeister> LoganCapaldo: i considered that, (String -> Maybe Question) seems a good option to me.
19:06:56 <faxathisia> Maybe I'm thinking about this the wrong way.. But I'd approach it as writing an interpreter
19:07:10 <faxathisia> because imo a flow chart is just a simple program
19:07:49 <tehgeekmeister> i agree with you on that, i'm just not quite sure why you'd want to use that approach -- keep in mind i want to run all of this in the state monad, as well.
19:08:08 <faxathisia> but that's irrelevant
19:08:31 <faxathisia> I mean the state monad would be part of the interpreter (the engine), not just the description of a program
19:08:46 <tehgeekmeister> brb
19:08:59 <faxathisia> well you seem to have a slightly different idea, so it might be best to go with that instead
19:09:09 <stick_figure> When Haskell has a runtime error, ie non-exhaustive pattern match, how do you trace it back to the original caller?  Or does that even make sense?  I just get a line number to where there isn't an exhaustive pattern match.
19:09:19 <stick_figure> s/Haskell/ghc/
19:09:21 <dons> stick_figure: in ghc 6.8, you use the debugger
19:09:26 <dons> in ghci. to get a stack trace
19:09:41 <dons> the line number should be accurate, though
19:09:45 <dons> do you have the code?
19:09:56 <SamB_XP> dons: I think he wants to know what called that code
19:10:04 <dons> ah ok. so he needs the debugger then
19:10:07 <stick_figure> SamB_XP, exactly
19:10:13 <SamB_XP> maybe he should try catch, too?
19:10:13 <dons> stick_figure: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
19:10:14 <lambdabot> Title: Haskell hacking
19:10:22 <dons> is a demo of how to use the debugger to catch a pattern error
19:10:28 <dons> stick_figure: also, compile with -Wall
19:10:35 <dons> to get a list from the compiler of all incomplete matches
19:10:47 <dons> if you use -Wall, and avoid: head, fromJust, tail
19:10:55 <Brian`> what's an elegant way to remove one column from a 2 dimentional table?
19:10:56 <dons> you'll tend not to get these failures
19:11:03 <chessguy> it's simple, you just go back in time. this is haskell, after all
19:11:23 <dons> stick_figure: do you have ghc 6.8?
19:11:30 <faxathisia> Brian`: What is a talbe?
19:11:32 <faxathisia> table*
19:11:39 <stick_figure> dons, I don't want a complete pattern match, because if you try to take the the right child a nil tree, you should get an error.
19:11:40 <Brian`> just n x n Int..
19:11:46 <faxathisia> how?
19:11:47 <Brian`> like [[1,2,3],[4,5,6,],[7,8,9]]
19:11:49 <faxathisia> [Int]
19:11:50 <faxathisia> ok
19:11:52 <dons> stick_figure: ah ok. so you actually call 'error' on it?
19:12:04 <dons> or you think that shouldn't have been called, given your input?
19:12:08 <faxathisia> just map something which turns: [a,b,c,d] -> [a,c,d]
19:12:16 <dons> stick_figure: also, if you've narrowed down where it is failing, you can use trace
19:12:18 <stick_figure> dons, it shouldn't have been called, which means I have a bug.
19:12:20 <dons> from Debug.Trace.trace
19:12:28 <faxathisia> > (\x -> drop 3 x ++ take 4 x) "foobar"
19:12:29 <lambdabot>  "barfoob"
19:12:37 <dons> i'd probably start with trace and reasoning, then try the debugger.
19:12:40 <faxathisia> er.. a bit like that :p
19:12:45 <dons> you might go the other way, depending on your whims
19:12:57 <faxathisia> > (\x -> take 3 x ++ drop 4 x) "foobar"
19:12:59 <lambdabot>  "fooar"
19:13:09 <faxathisia> Brian`: you can just make one of those
19:13:17 <LoganCapaldo> The fooar in your eyes?
19:13:19 <Brian`> faxathisia, k I'll try that
19:13:25 <chessguy> @pl \x -> take 3 x ++ drop 4 x
19:13:25 <lambdabot> ap ((++) . take 3) (drop 4)
19:13:27 <Olathe> @pl \x -> take a x ++ drop b x
19:13:27 <lambdabot> ap ((++) . take a) (drop b)
19:13:31 <SamB_XP> stick_figure: try tracing around the call that shouldn't happen?
19:13:35 <Olathe> @src ap
19:13:35 <lambdabot> ap = liftM2 id
19:13:40 <Olathe> @src liftM2
19:13:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:13:43 <Olathe> O-o
19:13:51 <Olathe> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:13:51 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
19:14:07 <darrint> map getDirectoryContents :: [FilePath] -> [IO [FilePath]] -- How can I do something like this but with type [FilePath] -> IO [FilePath] ?
19:14:10 <LoganCapaldo> Olathe: the monad is (-> r)
19:14:13 <ddarius> data F a x = F { ... };  data Nu f = Nu { unwrap :: f (Nu f) }; type CoAlgebra f a = a -> f a; instance Functor (F a) where { ... }; unfold :: CoAlgebra f a -> a -> Nu f; unfold coAlg = Nu . fmap (unwrap . unfold coAlg) . coAlg
19:14:32 <chessguy> gezundheit, ddarius
19:14:42 <apparition> may I ask  a quick question ?
19:14:52 <LoganCapaldo> s/(-> r)/((->) r)/
19:14:52 <chessguy> sure apparition, we love questions!
19:14:54 <darrint> apparition: Always
19:14:56 <apparition> thnx
19:15:12 <apparition> I'm trying to get the next perfect number
19:15:21 <apparition> but when i put in a six i get a 6
19:15:34 <apparition> when i put in  a 7 i get 28 - correct
19:15:40 <apparition> module Perfect where
19:15:40 <apparition> -- Lambda expression, m is the function "n `mod` m == 0"
19:15:40 <apparition> factorsNMinusOne1 :: Integral a => a -> [a]
19:15:40 <apparition> factorsNMinusOne1 n = filter (\m -> n `mod` m == 0) [1 .. n]
19:15:40 <apparition> factorsNMinusOne2 n = [m | m <- [1..n-1], n `mod` m == 0] -- List comprehension, boolean filter
19:15:41 <apparition> sumFactors n = foldr1 (+) (factorsNMinusOne2 n)
19:15:41 <stick_figure> dons, I have ghc 6.4, so I should try Debug.Trace.trace?
19:15:43 <apparition> sumFactors2 n = sum (factorsNMinusOne2 n)
19:15:45 <apparition> -- create a list of factors from n-1 to 1 then add together, foldr1?,
19:15:47 <apparition> -- if the sum == n, isperfect
19:15:49 <apparition> -- find factors of a number not including the number abd add them together
19:15:51 <apparition> -- if the number is the same as the original number, hten it is perfect
19:15:52 <ddarius> stick_figure: 6.4?!
19:15:53 <apparition> isPerfect :: Integral a => a -> Bool
19:15:55 <apparition> isPerfect n
19:15:56 <chessguy> whoah
19:15:57 <apparition> 	| (sum (factorsNMinusOne2 n)) == n = True
19:15:59 <apparition> 	| otherwise = False
19:16:01 <apparition>  
19:16:03 <apparition>  
19:16:03 <darrint> uh oh
19:16:05 <chessguy> apparition, paste your code at hpaste.orge
19:16:06 <stick_figure> ddarius, it's the latest stable in Gentoo apparently.
19:16:07 <apparition> isPerfect2 n
19:16:09 <apparition> 	| sumFactors2 n == n = True
19:16:10 <chessguy> !paste
19:16:10 <hpaste> Haskell paste bin: http://hpaste.org/
19:16:11 <apparition> 	| otherwise = False
19:16:13 <dons> stick_figure: 6.4? then yes, trace is probably the only option
19:16:13 <apparition> 	
19:16:15 <apparition> nextPerfect n
19:16:15 <LoganCapaldo> apparition: stop please
19:16:17 <apparition> 	| isPerfect2 n == False = nextPerfect (n + 1)
19:16:19 --- mode: ChanServ set +o dons
19:16:19 <apparition> 	| otherwise = n
19:16:21 <apparition> 	
19:16:23 <apparition> --nextPerfect
19:16:24 --- kick: apparition was kicked by dons (come back in a sec)
19:16:27 --- mode: ChanServ set -o dons
19:16:27 <stick_figure> yeah
19:16:30 <SamB_XP> dons: don't forget -xc
19:16:31 <Olathe> ...
19:16:32 <stick_figure> thanks
19:16:37 <hpaste>  apparition pasted "nextPerfect" at http://hpaste.org/4272
19:16:43 <chessguy> good grief, why would anyone think that was a good ide
19:16:43 <chessguy> a
19:16:45 <Olathe> Heh.
19:16:46 <dons> that's better
19:16:54 <Olathe> He knew about hpaste ?
19:17:00 <LoganCapaldo> we told him
19:17:02 <dons> maybe he pasted into the wrong window
19:17:02 <Olathe> Oh.
19:17:04 <LoganCapaldo> but too late apparently
19:17:08 <LoganCapaldo> or that
19:17:09 <faxathisia> or didnt' copy the url by accident
19:17:17 <faxathisia> so the code was still on clipboard
19:17:22 <dons> yeah
19:17:23 <Olathe> Or didn't kill his IRC client.
19:17:38 <davidL> irc clients should warn about long pastes
19:17:54 <Nafai> irssi does
19:17:57 <darrint> map getDirectoryContents :: [FilePath] -> [IO [FilePath]] -- How can I do something like this but with type [FilePath] -> IO [FilePath] ?
19:18:14 <SamB_XP> the terminal-based ones might have a hard time doing so...
19:18:16 <davidL> yeah, irssi for example
19:18:36 <LoganCapaldo> irc clients should just neuter newlines and "listen" for the key press to send a message
19:18:49 <darrint> Actually, looking at my own question, I really want [FilePath] -> IO [[FilePath]]
19:18:53 <sjanssen> darrint: use mapM instead
19:19:19 <darrint> sjanssen: Oh that's awful. :-)
19:19:30 <apparition> im really sorry guys :(
19:19:32 <davidL> "Pasting 6 lines to #haskell. Press Ctrl-K if you wish to do this or Ctrl-C to cancel."
19:19:39 <Olathe> The even perfect number identity is nice.
19:19:41 <apparition> ma bad
19:19:53 <apparition> :)
19:19:56 <LoganCapaldo> or sequence (map getDirectoryContents paht)
19:20:01 <Olathe> Or whatever it is.
19:20:03 <LoganCapaldo> if you like typing
19:20:20 <dons> apparition: its ok.
19:20:29 <apparition> :Sorry
19:20:37 <dons> what was your question again?
19:20:40 <dons> i think it got lost in the noise
19:20:52 <apparition> to input 6 and output 28, not 6
19:21:01 <apparition> 7 gets 28
19:21:25 <apparition> etc etc
19:21:44 <chessguy> you want f(n) = the nth perfect number?
19:21:59 <apparition> http://hpaste.org/4272
19:22:11 <chessguy> yes, i can see that
19:22:27 <davidL> hmm, I am confused about TH, I have a funtion that uses splice, $(foo [...]), which returns an 11-tuple...what am I supposed to do with that?
19:22:33 <apparition> yes, that sounds palpable
19:22:46 <chessguy> so, when you put in 6, 6 is perfect, so why shouldn't it stop?
19:23:07 <apparition> it needs to get the next perfect number
19:23:12 <faxathisia> > let even = ((== 0).(`mod` 2)) in filter even [1..]
19:23:13 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
19:23:15 <darrint> @src mapM
19:23:15 <lambdabot> mapM f as = sequence (map f as)
19:23:22 <chessguy> oh, then you can't use it recursively
19:23:35 <darrint> :t sequence
19:23:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:23:39 <faxathisia> filter isPerfect [1..]
19:23:44 <darrint> ahhhhhh
19:23:44 <apparition> so i think ther needs to be a coindition ewhere if the first number iput is a perfect, it needs to add 1 + n to start the find for the next
19:23:44 <davidL> @type even
19:23:45 <lambdabot> forall a. (Integral a) => a -> Bool
19:23:57 <ddarius> davidL: Whatever you want?
19:24:00 <darrint> @src sequence
19:24:00 <lambdabot> sequence ms = foldr k (return []) ms
19:24:00 <lambdabot>     where
19:24:00 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:24:01 <faxathisia> apparition: why not filter?
19:24:15 <chessguy> apparition, why not just do this: perfectNums = filter isPerfect [1..]
19:24:24 * darrint hurts his brane
19:24:43 <davidL> ddarius: but there's no functions for 11-tuples, do I have to continue using TH throughout?
19:24:49 <chessguy> then nextPerfect n = head . dropWhile (<=n) $ perfectNums
19:25:04 <apparition> hmmm. thats the power for haskell, thankyou chess' and fax'
19:25:15 <apparition> I weill implement your adsvice
19:25:18 <LoganCapaldo> darrint: sequence [a, b, c] is a bit like do { a ; b ; c } except it saves the results of a, b and c in a list
19:25:21 <LoganCapaldo> if that helps
19:25:27 <chessguy> laziness at your service :)
19:25:32 <darrint> That makes sense.
19:26:00 <davidL> chessguy: why not just do: let nextPerfect n = perfectNums !! n+1 ?
19:26:03 <apparition> higher oder goo oodness
19:26:12 <darrint> LoganCapaldo: I was under the impression that once something was in IO (thinghere) it couldn't get out, but I see it's more complex than that.
19:26:17 <apparition> rrrr
19:26:19 <chessguy> davidL, n isn't an index
19:26:24 <davidL> err, nvm
19:26:28 <LoganCapaldo> darrint: it doesn't get out
19:26:39 <darrint> LoganCapaldo: Right, but it still hurts the brane.
19:27:03 <chessguy> @type \n -> head . dropWhile (<= n) $ ?p
19:27:12 <LoganCapaldo> darrint: you can't get out but you can move stuff around :)
19:27:15 <lambdabot> forall a. (Ord a, ?p::[a]) => a -> a
19:27:24 <darrint> Indeed. :-)
19:27:49 <chessguy> @pl \n -> head . dropWhile (<= n) $ p
19:27:49 <lambdabot> flip (head .) p . dropWhile . flip (<=)
19:28:15 * chessguy scratches his head
19:28:38 <LoganCapaldo> (this is part of the reason I didn't get Monads until I stopped trying to think of them as containers.)
19:28:39 <chessguy> @type flip (<=) [1..]
19:28:41 <lambdabot> forall t. (Ord [t], Num t, Enum t) => [t] -> Bool
19:28:50 <ddarius> davidL: Use pattern matching or use TH to spit out accessors if you like.
19:29:01 <hpaste>  tehgeekmeister annotated "Not very useful example of my flowchart dealio." with "New implementation of Question as a data type has a monad type problem." at http://hpaste.org/4261#a4
19:29:16 <Olathe> > take 6 $ evenPerfects
19:29:22 <lambdabot>  [6,28,496,8128,33550336,8589869056]
19:30:45 <chessguy> Olathe, i missed the definition of evenPerfects
19:31:01 <tehgeekmeister> do i need to use MaybeT or something there?  the problem it's having is that runQuestion returns a Maybe Question even tho it's in the do monad.
19:31:04 <tehgeekmeister> err
19:31:05 <tehgeekmeister> IO
19:32:11 <davidL> ddarius: I keep trying to get around pattern matching but I suppose there isn't a way. Thanks.
19:32:14 <LoganCapaldo> tehgeekmeister: you have to return
19:32:21 <LoganCapaldo> or keep going :)
19:33:02 <LoganCapaldo> return (f x a)
19:33:27 <LoganCapaldo> runQuestion :: Question -> IO Question
19:34:25 <darrint> How do I convince ghc ghc that [[Char]] is equivalent to [[FilePath]] ?
19:34:26 <LoganCapaldo> (or IO (Maybe Question) rather)
19:34:42 <chessguy>  darrint, it's not
19:34:43 <tehgeekmeister> w00t!  it works, somewhat.
19:34:44 <tehgeekmeister> =]
19:34:50 <LoganCapaldo> darrint: [FilePath] is equiv to [[Char]]
19:34:51 <chessguy> [[[Char]]] is [[FilePath]]
19:35:00 <darrint> Ah. Missed that. Thanks
19:35:18 <chessguy> can't...resist
19:35:20 <chessguy> @stereo
19:35:20 <lambdabot> Unknown command, try @list
19:35:24 <chessguy> @quote stereo
19:35:24 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:35:27 <chessguy> noooooo
19:35:35 <LoganCapaldo> that wasn't so much stereo as it was harmony
19:35:54 <chessguy> well bah humbug to you too
19:36:04 <LoganCapaldo> :)
19:36:32 <ddarius> There was never a @stereo command
19:36:52 <SamB_XP> yeah, that would have just encouraged MORE overuse
19:36:55 <LoganCapaldo> There never was a stereo quote.
19:37:08 <ddarius> There is no HSU.
19:37:15 <SamB_XP> LoganCapaldo: I guess Cale was never annoyed at the frequency with which it was quoted
19:37:15 <monochrom> Let's add a harmony quote. Even a fugue quote.
19:37:20 * LoganCapaldo starts a revisionist history campaign
19:37:25 <SamB_XP> ddarius: but there really isn't a HSU
19:37:29 <chessguy> yeah, @stereo was a typo
19:37:42 <SamB_XP> it's the PSU that, um, might exist
19:37:48 <monochrom> Welcome to #haskell, where your questions are answered in counterpunctual fugues.
19:38:14 <ddarius> @remember monochrom Welcome to #haskell, where your questions are answered in counterpunctual fugues.
19:38:14 <lambdabot> I will remember.
19:38:33 <chessguy> is counterpunctual even a word?
19:38:40 <LoganCapaldo> I sure hope so
19:38:43 <monochrom> adjective for counterpoint
19:38:49 <monochrom> something about harmony.
19:39:31 <darrint> I think It's the idea of arranging more than one line of music such that none sounds dominant.
19:40:25 <chessguy> no such word on dictionary.com
19:40:42 <chessguy> ah, contrapuntal
19:40:49 <monochrom> oopsie!
19:41:04 * LoganCapaldo starts a revisionist dictionary campaign
19:41:14 <LoganCapaldo> There is no such word as contrapuntal.
19:41:29 <chessguy> and now your vocabulary malfunction is @remembered for all of posterity
19:41:48 <monochrom> Well it's attributed to me, so all blames are on me.
19:42:08 <LoganCapaldo> all our blames are belong to you
19:42:19 <Olathe> @quote stereo.
19:42:19 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
19:42:23 <Olathe> @quote stereo.
19:42:23 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
19:42:27 <Olathe> @quote .stereo
19:42:27 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
19:42:32 <Olathe> :|
19:43:00 <SamB_XP> @quote C-a-l-e
19:43:00 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
19:43:02 <Olathe> Oh.
19:43:05 <hpaste>  tehgeekmeister annotated "Not very useful example of my flowchart dealio." with "Finally, an interesting version." at http://hpaste.org/4261#a5
19:43:09 <Olathe> You have to exclaim it !
19:43:13 <Olathe> @quote stereo!
19:43:13 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
19:43:28 <Olathe> @quote omg!
19:43:28 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
19:43:39 <SamB_XP> @quote omg
19:43:39 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life; is much happier now
19:44:36 <chessguy> @quote c-a-l-e
19:44:36 <lambdabot> No quotes match. My mind is going. I can feel it.
19:44:41 <chessguy> @quote C-a-l-e
19:44:41 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
19:44:52 <chessguy> @quote majestic
19:44:52 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
19:45:00 <chessguy> probably easier to remember
19:45:00 <tehgeekmeister> faxathisia: i think that'll give you an idea what i was going for, sorta.  not sure how i'll wrap that in the state monad yet -- but it'll probably have to be good for a few weeks, got too much other work to continue playing with this after tonight.
19:45:02 <Olathe> @quote questions
19:45:02 <lambdabot> Korollary says: You know, dons actually knows your phone number. Hell be calling you soon to check whether you have any questions about monad transformers.
19:45:40 <LoganCapaldo> he does?
19:45:42 <LoganCapaldo> schweet
19:46:33 <chessguy> tehgeekmeister, runQuestion is String -> IO () ?
19:46:35 <monochrom> "I am dons from the Monad Foundation"
19:46:55 <monochrom> "For a donation of $100 or more, we will answer all your monad questions!"
19:47:01 <tehgeekmeister> chessguy: for now, yes.  in fact, it might stay that way for a while.
19:47:07 <tehgeekmeister> errr
19:47:09 <tehgeekmeister> waiiiit
19:47:09 <tehgeekmeister> no
19:47:10 <LoganCapaldo> err
19:47:17 <LoganCapaldo> Question -> IO ()
19:47:21 <Olathe> > ['.','.'..]
19:47:22 <tehgeekmeister> it's Question -> IO ()
19:47:38 <lambdabot>  "..............................................................................
19:47:39 <chessguy> ah, right
19:47:59 <Olathe> > error ['.','.'..]
19:48:00 <lambdabot>  Exception: ....................................................................
19:48:01 <faxathisia> Make the Question monad!
19:48:01 <chessguy> lambdabot wields her lambda-saber!
19:48:02 <monochrom> "And if you donate $1000 or more, we will send you a CD full of monad explanations sung in contrapunctual fugues! Great for Christmas!"
19:48:19 <chessguy> monochrom, "contrapuntal"
19:48:33 <ddarius> chessguy: Not on #haskell!
19:48:35 <Olathe> The fugues are out of date.
19:48:38 <tehgeekmeister> faxathisia: i was considering it, it seems like it could be a monad.
19:48:50 <faxathisia> lol
19:49:00 <ddarius> Olathe: You want monad explanations set to death metal?
19:49:08 <monochrom> I am very disappointed that "point" gets derived to "puntual" rather than "punctual". It's so wrong.
19:49:15 <LoganCapaldo> ddarius: that sounds awesome!
19:50:06 <chessguy> tehgeekmeister, i'm relatively certain there's some simplification to be done here
19:50:24 * chessguy fires up his trusty emacs/ghci
19:50:33 <LoganCapaldo> well he definitely likes parens too much
19:50:40 <tehgeekmeister> i'm sure there is
19:50:49 <LoganCapaldo> case ((f x) $ a) of ---> case f x a of
19:50:50 <tehgeekmeister> parens are a newbs best friend.
19:51:07 <ddarius> LoganCapaldo: Holy crap
19:51:10 <tehgeekmeister> haskell's syntax is still weird to me
19:51:18 <LoganCapaldo> ddarius: ?
19:51:20 <pi3> tehgeekmeister: true, true
19:51:30 <tehgeekmeister> i came from ruby/python.
19:51:38 <faxathisia> I think one of the things which helped me realize where to not put parathesis is this:
19:51:41 <ddarius> LoganCapaldo: That's just so wrong.
19:51:52 <faxathisia> (((((f x) y) z) w) u) v = f x y z w u v
19:51:54 <LoganCapaldo> death metal monads?
19:52:08 <ddarius> LoganCapaldo: ((f x) $ a)
19:52:23 <chessguy> ddarius, be nice
19:52:27 <monochrom> "We wish you a writer monad. We wish you a writer monad. We wish you a write monad, and a stateful functor."
19:52:35 <LoganCapaldo> ddarius: http://hpaste.org/4261#a5
19:52:52 <ddarius> chessguy: You are misinterpreting my tone (though I have to say that both intepretations are mixed)
19:52:53 <SamB_XP> monochrom: ill-wisher!
19:52:55 <ddarius> LoganCapaldo: I know.
19:53:16 <ddarius> chessguy: Anyway, someone needs to not be nice around here just for balance.
19:53:55 <dmwit> tehgeekmeister: let m = f x a in when (isJust j) (runQuestion y) -- replaces the "case" statement
19:54:22 <dmwit> err... (isJust m), even
19:54:44 <LoganCapaldo> and (runQuestion (fromJust m))
19:54:56 <dmwit> yeah
19:55:00 <dmwit> We can do better.
19:55:01 <dmwit> :t maybe
19:55:02 <LoganCapaldo> since if you kill the case statement there's no more y
19:55:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:55:05 <dmwit> :t fromMaybe
19:55:05 <lambdabot> forall a. a -> Maybe a -> a
19:55:49 <dmwit> maybe (return ()) runQuestion (f x a) -- =D
19:56:47 <dmwit> And now it becomes:
19:56:57 <dmwit> getLine >>= maybe (return ()) runQuestion . f x
19:57:16 <dataangel> Toxaris: Why does it test them in parallel if it's supposed to be predictive?
19:57:32 <dataangel> LoganCapaldo: r is, but I didn't think it would ever run under the circumstances
19:57:46 * dataangel had to help someone with matlab code and so gives very belated replies
19:57:49 <chessguy> @pl \x -> p (q x) >> getLine >>= maybe (return ()) runQuestion . f x
19:57:49 <lambdabot> ap ((>>=) . (>> getLine) . p . q) ((maybe return runQuestion .) . f)
19:57:58 <tehgeekmeister> to be fair, i realized the overkill of (f x) $ a when i wrote it, but i didn't take the time to correct it.
19:58:06 <chessguy> heh
19:58:13 <chessguy> @pl screwed that one up
19:58:13 <lambdabot> screwed that one up
19:58:16 <LoganCapaldo> dataangel: you missed the "it's not parallel part"
19:58:22 <Toxaris> dataangel: I was wrong about parsec testing in parallel
19:58:36 <dataangel> oh
19:58:42 <chessguy> tehgeekmeister, don't worry about it, i wasn't immediately sure how to fix it either
19:58:42 <dataangel> so it still doesn't make sense :P
19:58:44 <LoganCapaldo> the part in my last message should be outside the quotes
19:58:51 <dmwit> ?pl I'm such a clever repeater bot
19:58:51 <lambdabot> I'm such a clever repeater bot
19:58:56 <dons> Cale, you might like this, http://programming.reddit.com/info/625lw/comments/c02li03
19:59:07 <SamB_XP> ?pl ?x
19:59:08 <lambdabot> (line 1, column 1):
19:59:08 <lambdabot> unexpected "?"
19:59:08 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
19:59:19 <Cale> dons: haha
19:59:24 <dons> h98 only please, SamB_XP
19:59:47 <chessguy> dons, i love the tables :)
20:00:01 <dons> aren't they awesome!
20:00:07 * chessguy needs to print that out and put it on his cubicle wall
20:00:17 <dons> we have them on the wall at work, as light relief
20:00:23 <pi3> @src maximum
20:00:23 <lambdabot> maximum [] = undefined
20:00:23 <lambdabot> maximum xs = foldl1 max xs
20:00:35 <chessguy> heh. "php" == 0 is true?
20:00:38 <ddarius> Hmm, how -do- I rate myself as a PHP developer?
20:00:54 <SamB_XP> ddarius: rate yourself as low as possible
20:01:04 <Cale> chessguy: apparently, yes
20:01:07 <chessguy> this is a real treasure-trove
20:01:12 <dons> i'd not have guessed that
20:01:25 <Cale> chessguy: and 0 == "0" is true, but not "php" = "0"
20:01:29 <allbery_b> chessguy: in perl it is.  dunno about php, being blissfully unaware of it beyond "vaguly perl-like and a veritable fount of security holes"
20:01:33 <Cale> er, ==
20:01:42 <mauke> see also http://tnx.nl/php#args
20:01:42 <ddarius> SamB_XP: I've never written any PHP so...
20:01:43 <lambdabot> Title: PHP in contrast to Perl
20:01:53 <ddarius> Table P-2 should be color coded rather than "TRUE" "FALSE"
20:02:38 <faxathisia> eh
20:02:45 * chessguy emails himself the trophy for his wall
20:02:49 <faxathisia> It's like in APL or J or whatever you get implict maps alll over the place
20:02:58 <faxathisia> in PHP you get implicit read or whatever
20:03:18 <allbery_b> borrowed from perl
20:03:23 <faxathisia> dunno why people are always making a fuss about it
20:03:28 <ddarius> I love the picture: http://tnx.nl/php.jpg
20:03:34 <allbery_b> (mmm, NaNcy typing)
20:03:39 <hpaste>  dataangel pasted "Stack overflow trouble. Dumb n00b mistake?" at http://hpaste.org/4273
20:04:02 <LoganCapaldo> hehehhe
20:04:09 <LoganCapaldo> training wheels w/o the bike
20:04:12 <LoganCapaldo> that's terrible
20:04:23 <LoganCapaldo> I
20:04:44 <LoganCapaldo> 'm gonna stand in a train station and handout tracts with that picture on them
20:05:45 <ddarius> dataangel: Where's parseDecl?
20:05:51 <LoganCapaldo> and now I go to bed
20:05:57 <LoganCapaldo> good night strongly typed ones
20:06:09 <Cale> dataangel: um, if it reaches parseBinOpCall in parseExpr, then it immediately lands back in parseExpr without having consumed any more input
20:06:14 <dataangel> ddarius: err, I didn't include it because I didn't think it mattered. Without the line parseDecl succeeds, so I know it matches the string
20:06:31 <Cale> dataangel: which means that if you ever make it to parseBinOpCall at all, you're in an infinite loop
20:06:34 <Cale> (for sure)
20:06:55 <dataangel> Cale: That is a problem, but parseExprStmt should never run in the first place AFAIK
20:07:15 * dataangel is probably doing something incredibly idiotic
20:07:47 <Toxaris> dataangel: show parseDecl
20:07:57 <Cale> Well, it *must* be running that code if changing that line changes the behaviour.
20:07:59 <tehgeekmeister> dmwit: i absolutely do not get the changes you suggested -- would you mind explaining a little?
20:08:22 <Cale> dataangel: which means that parseDecl must not succeed
20:08:23 <dmwit> tehgeekmeister: "maybe" is a function used for destroying Maybe types.
20:08:34 <dmwit> tehgeekmeister: Check this out:
20:08:45 <dmwit> > maybe 3 (+1) (Just 5)
20:08:47 <lambdabot>  6
20:08:53 <dmwit> > maybe 3 (+1) (Nothing)
20:08:53 <lambdabot>  3
20:09:02 <SamB_XP> yay death and destruction
20:09:04 <dmwit> tehgeekmeister: Is that behavior clear?
20:09:15 <hpaste>  dataangel annotated "Stack overflow trouble. Dumb n00b mistake?" with "updated" at http://hpaste.org/4273#a1
20:09:27 <Cale> maybe is to foldr what Maybe is to []
20:09:35 <SamB_XP> @type maybe
20:09:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:09:46 <SamB_XP> @djinn b -> (a -> b) -> Maybe a -> b
20:09:46 <lambdabot> f a b c =
20:09:46 <lambdabot>     case c of
20:09:46 <lambdabot>     Nothing -> a
20:09:46 <lambdabot>     Just d -> b d
20:10:00 <tehgeekmeister> dmwit: yes
20:10:05 <dmwit> Cool.
20:10:06 <tehgeekmeister> very useful, too.
20:10:07 <SamB_XP> djinn is such a good guesser
20:10:20 <dataangel> now parseDecl is in ther
20:10:29 <Cale> what about parseType?
20:10:35 <dmwit> tehgeekmeister: So, I just replaced your "case" statement with a call to "maybe".
20:10:55 <dmwit> The function you run on Just values is "runQuestion", and the default value for Nothing values is "return ()".
20:11:03 <dmwit> So, if we stick that in the call to maybe, it looks like
20:11:32 <dmwit> maybe (return () {- default value -}) runQuestion {- function on Just values -} {- TODO: what goes in the last slot? -}
20:12:05 <dmwit> tehgeekmeister: Still good?
20:12:17 <dibblego> ?djinn [a] -> b -> (a -> [a] -> b) -> b
20:12:17 <lambdabot> f _ a _ = a
20:12:23 <tehgeekmeister> dmwit: yes, and i can guess the next step, it all makes sense now.
20:12:30 <dmwit> Great!
20:12:31 <hpaste>  dataangel annotated "Stack overflow trouble. Dumb n00b mistake?" with "full code :)" at http://hpaste.org/4273#a2
20:12:47 <chessguy> dmwit++ nice explanation
20:12:58 <dibblego> ?type \xs b f -> case of [] -> b; case of (x:xs) -> f x xs
20:12:58 <lambdabot> parse error on input `of'
20:13:03 <pi3> how do I check if a list is empty? a == []?
20:13:06 <dibblego> ?type \xs b f -> case of [] -> b; (x:xs) -> f x xs
20:13:06 <lambdabot> parse error on input `of'
20:13:13 <dmwit> pi3: null
20:13:15 <chessguy> > null [1..3]
20:13:15 <dibblego> ?type \xs b f -> xs case of [] -> b; (x:xs) -> f x xs
20:13:16 <lambdabot> parse error on input `case'
20:13:16 <lambdabot>  False
20:13:21 <chessguy> > null []
20:13:21 <lambdabot>  True
20:13:25 <faxathisia> :t ([]==)
20:13:26 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
20:13:28 <dibblego> ?type \xs b f -> case xs of [] -> b; (x:xs) -> f x xs
20:13:29 <lambdabot> forall t t1. [t1] -> t -> (t1 -> [t1] -> t) -> t
20:13:33 <faxathisia> :t null
20:13:34 <lambdabot> forall a. [a] -> Bool
20:13:36 <pi3> thanks
20:14:02 <chessguy> @type \xs -> [] == xs
20:14:03 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
20:14:11 <chessguy> huh.
20:14:21 <dmwit> ?type \[] -> True
20:14:21 <lambdabot> forall t. [t] -> Bool
20:14:21 <chessguy> where is that Eq requirement coming from?
20:14:28 <dmwit> chessguy: From using (==).
20:14:29 <dmwit> ;-)
20:14:45 <chessguy> but it's an empty list
20:14:50 <faxathisia> chessguy: So what?
20:15:12 <SamB_XP> @pl (==[])
20:15:13 <lambdabot> ([] ==)
20:15:22 * dataangel is consumed by parsec's deep mysteries
20:15:30 <dmwit> chessguy: It's the difference between pattern matching and guards.
20:15:49 <faxathisia> :t (\x -> case x of [] -> True ; _->False)
20:15:57 <lambdabot> forall t. [t] -> Bool
20:15:57 <chessguy> > (\xs -> xs == []) ([] :: [a -> Maybe a])
20:16:00 <lambdabot>   add an instance declaration for (Eq (a -> Maybe a))
20:16:01 <lambdabot>     In the expression: ...
20:16:02 <faxathisia> :o
20:16:03 <faxathisia> cool
20:16:09 <dmwit> Since you're actually making a call to (==), you have to know that such a call is available.
20:16:34 <ddarius> Anyway (==) doesn't have to have ([]==) == null
20:16:41 <chessguy> @src null
20:16:41 <lambdabot> null []     = True
20:16:41 <lambdabot> null (_:_)  = False
20:17:02 <SamB_XP> ddarius: eh?
20:17:05 <faxathisia> :t (_:_)
20:17:06 <lambdabot> Pattern syntax in expression context: _
20:17:06 <lambdabot> Pattern syntax in expression context: _
20:17:11 <faxathisia> :t (_:_:_:_:_:_:_:_:_:_:_:_:_:_)
20:17:12 <lambdabot> Pattern syntax in expression context: _
20:17:12 <lambdabot> Pattern syntax in expression context: _
20:17:12 <lambdabot> Pattern syntax in expression context: _
20:17:15 <faxathisia> hehe
20:17:29 <SamB_XP> faxathisia: what's yer point?
20:17:41 <dmwit> SamB_XP: You can define Eq instances for [a] independently of a.
20:17:41 <faxathisia> SamB_XP: Regarding what
20:18:00 <SamB_XP>  :t (_:_:_:_:_)
20:18:03 <ddarius> SamB_XP: In general (==) doesn't have to satisfy any sane laws, though of course the above will hold for the Prelude instance of Eq for []
20:18:18 <SamB_XP> dmwit: since when?
20:18:18 <dataangel> Cale: sorry about the code dump, but I figure its better than slowly posting it all in small increment
20:18:32 <dmwit> SamB_XP: Forever.  At least since H98.
20:18:34 <dons> Cale: http://galois.com/~dons/types.html :)
20:18:34 <lambdabot> Title: PHP is too hard
20:18:52 <SamB_XP> dmwit: H98 doesn't have special Eq methods for [a]
20:18:59 <SamB_XP> you may be confused with Show
20:19:17 <dmwit> SamB_XP: If you declare a new type Foo, you can declare an Eq instance for [Foo] without having one for Foo.
20:19:21 <Toxaris> dataangel: your code works fine for me. whats the problem again?
20:19:25 <dmwit> I am not confused with Show.
20:19:27 <faxathisia> very nice dons
20:19:28 <SamB_XP> dmwit: not in H98
20:19:28 <dmwit> This is true of all classes.
20:19:32 <dmwit> Yes, in H98.
20:19:38 <SamB_XP> no
20:19:45 <dataangel> Toxaris: stack overflow. It works fine for you? @_@
20:19:50 <Toxaris> *Main>  parseTest parseStmt "int x;" -- works fine
20:19:50 <Toxaris> Decl JayInt [VarName "x"]
20:19:51 <faxathisia> > "php"==[]
20:19:53 <lambdabot>  False
20:20:01 <faxathisia> dons: you should add that ?
20:20:07 <ddarius> dmwit: That overlaps with the Prelude instance.
20:20:11 <dataangel> !_!
20:20:11 <dons> > "php" == ([] :: [Int])
20:20:12 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
20:20:13 <SamB_XP> for H98 requires that all parameters to a type constructor be variables
20:20:21 <SamB_XP> in the instance head
20:20:28 <faxathisia> hmm
20:20:31 <dataangel> I've been running it on the file rather than using the REPL like that
20:20:48 <dons> faxathisia: there is an interesting issue here of type String = [Char]
20:20:58 <dataangel> but I don't see what would be different...
20:21:15 <Toxaris> dataangel: maybe some whitespace related issue?
20:21:30 <Cale> dons: :)
20:22:05 <Toxaris> *Main> parseTest parseStmt " int x;"
20:22:05 <Toxaris> *** Exception: stack overflow
20:22:16 <faxathisia> :t (""==[])
20:22:17 <lambdabot> Bool
20:22:59 <dataangel> hmm, I made a new file in emacs, extra care not to have any spaces before or after, and still have the issue
20:23:11 <Toxaris> dataangel: parseDecl doesn't parse " int x;"
20:24:07 <wellwisher> i have the following: data Output = Begin Int | Arrival Int | Departure Int
20:24:07 <chessguy> dons, i assume you saw this today: http://lambda-the-ultimate.org/node/2557
20:24:09 <lambdabot> Title: Concurrency: The Compiler Writer&#039;s Perspective | Lambda the Ultimate
20:24:10 <dataangel> Toxaris: well, except for the first statement the whitespace call in parseStmt would always take care of that
20:24:33 <dmwit> SamB_XP: ok, sorry
20:24:45 <Toxaris> dataangel: we are talking about the first statement, aren't we? but i don't see why this produces the error...
20:24:47 <wellwisher> what is a good way to covert [Int] to [Output]?
20:25:03 <dataangel> "case parse (many parseStmt) "jayinterp" input of" -> "case parse (whitespace >> many parseStmt) "jayinterp" input of"
20:25:07 <dons> chessguy: yeah
20:25:10 <chessguy> wellwisher, map (f::Int -> Output) ints
20:25:11 <faxathisia> wellwisher: Do you have a function Int -> Output?
20:25:43 <dmwit> map Begin -- or map Arrival, or map Departure
20:25:49 <wellwisher> k
20:26:37 <dataangel> Toxaris: putting the whitespace there causes parseDecl not to match, which means it reaches parseExprStmt which has the infinite loop problem Cale mentioned
20:27:02 <wellwisher> wasn't sure if you could map data types
20:27:02 <dataangel> Toxaris: But when the file is just "int x;" with no leading or following whitespace I don't see why the error still happens
20:27:27 <dataangel> you can map constructors, which are just functions
20:27:46 <dataangel> maybe emacs is lying about the whitespace
20:27:55 <chessguy> dataangel, s/just //
20:28:04 <Toxaris> dataangel: sure. but you said that everything is ok when you delete parseExprStmt
20:28:52 <dataangel> Toxaris: Yeah, but it shouldn't reach parseExprStmt when it's there, so I'm wondering what is it trying to parse that gets it there
20:28:56 <dataangel> maybe I need to parse EOF?
20:29:06 <faxathisia> dataangel: What exactly do you want to parse?
20:29:10 <faxathisia> What's the language look like
20:29:31 <dataangel> faxathisia: just a little toy C'ish thing
20:29:43 <faxathisia> so you can em
20:29:52 <faxathisia> take e.g.
20:29:53 <dons> ?users
20:29:53 <lambdabot> Maximum users seen in #haskell: 420, currently: 390 (92.9%), active: 20 (5.1%)
20:29:58 <ddarius> @flush
20:29:58 <lambdabot> Not enough privileges
20:30:04 <Toxaris> dataangel: try to parse eof, sounds like a good idea to me
20:31:02 <faxathisia> "int x = 3+7;" >-(tokenize)-> [IntType, Ident "x", Assign, Const 3, Op "+", Cons 7] >-(Parse)-> [Declaration IntType "x" (Plus (Const 3) (Const 7))]
20:31:21 <faxathisia> doing it in two stages, lexing them parsing (you can do both with parsec though) is actually I found a lot easier
20:31:25 <faxathisia> easier to code it.. and debug
20:31:29 <faxathisia> debug/test
20:32:29 * Toxaris goes to bed now. good luck with your parser, dataangel
20:32:34 <faxathisia> dataangel: it seems like you're trying to do it all in one step
20:32:38 <faxathisia> which might not be the best idea
20:33:05 <nolrai> Are writeFile and readFile unicode? 'cuse they seam to be droping the high byte.
20:33:16 <dons> they're dropping the high byte
20:33:17 <sorear> nolrai: in theory, yes
20:33:21 <dons> you'll need the utf8-string package
20:33:21 <TSC> Yeah, they'll do that
20:35:32 <dons> to write Char or String without loss
20:35:32 <dataangel> Toxaris: hmm, where can I put the eof though? I can't put it in parseStmt because eof is Parser ().
20:35:32 <faxathisia> dataangel: Does my suggestion make sense?
20:35:32 <dons> use System.IO.UTF8.writeFile
20:35:32 <sorear> nolrai: in practice, only Hugs implements them properly for your locale - GHC assumes latin1 for all IO
20:35:32 <dons> sorear: "in theory" isn't a great answer, btw.
20:35:32 <sorear> nolrai: or you can use a UTF8 replacement library
20:35:32 <hpaste>  faxathisia annotated "Stack overflow trouble. Dumb n00b mistake?" with "lexing example" at http://hpaste.org/4273#a3
20:35:32 <dons> oi! where's my hackage.haskell.org gone?
20:35:32 <hpaste>  faxathisia annotated "Stack overflow trouble. Dumb n00b mistake?" with "parsing example" at http://hpaste.org/4273#a4
20:35:32 <SamB_XP> dons: did you forget to pay the DNS bill?
20:35:32 <faxathisia> dataangel: Check my annotation also.. that's how it can look
20:35:32 <dons> anyone else connect to hackage?
20:35:32 <nolrai> whats a UTF8 replacement library?
20:35:32 <dataangel> faxathisia: I'll give it a look
20:35:32 <dons> nolrai: there's a library, utf8-string, which provides System.IO.UTF8.writeFile and readFile
20:35:32 <davidL> I can connect to hackage fine
20:35:32 <dons> oh hmm
20:35:32 <dons> i musta forgot to pay my DNS bills
20:35:40 <glguy> hackage works for me
20:35:49 <dons> yeah, my dns is going silly
20:35:55 <glguy> http://hackage.haskell.org/packages/archive/utf8-string/0.2/utf8-string-0.2.tar.gz
20:35:56 <lambdabot> http://tinyurl.com/29mf6v
20:36:10 <SamB_XP> dons: I meant on the domain name ;-)
20:36:34 <dataangel> faxathisia: interesting, I think my way is closer to how I think though
20:36:54 <SamB_XP> you referred to it as YOUR hackage.haskell.org
20:37:00 <faxathisia> dataangel: Does it make sense?
20:37:04 <faxathisia> You have two stages
20:37:13 <faxathisia> 1st is parsing a [Char] into a [Token],
20:37:21 <faxathisia> 2nd is parsing a [Token] into a [Expression]
20:37:48 <davidL> hackage.haskell.org -> haskell.galois.com
20:38:00 <nolrai> well i cant compile with modules deaper then one "." so umm.
20:38:30 <dons> nolrai: sure you can
20:38:33 <nolrai> btw anyone have any idea whats up with that? i had run into this before and fixed it somehow but cant rember.
20:38:36 <dons> Foo.Bar lives in Foo/Bar
20:38:37 <faxathisia> dataangel: How you think ... isn't really always the best way to program something
20:38:40 <dons> Foo.Bar lives in Foo/Bar.hs
20:38:50 <faxathisia> dataangel: Think about like multiplying two numbers -- a computer does this differently to you
20:39:02 <dons> nolrai: and you use --make to build them all in one go
20:40:04 <nolrai> Foo.Bar.x works but Foo.Bar.Baz.x dosnt.  I know it should work. Im on a ubuntu x64 for refrence.
20:41:43 <nolrai> maybe i should go back a version or two on GHC. you think that would fix it?
20:42:29 <dons> no no. what actual source files do you have?
20:42:34 <dons> Foo/Bar/Baz.hs ?
20:42:40 <dataangel> Is there a way in parsec to print the remaining input? That would be helpful for debugging
20:42:45 <dons> the module structure must map directly onto the directory structure, ulfdoz
20:42:49 <dons> nolrai: ^^
20:43:07 <ddarius> dataangel: You should be able to get into with getState or getInput or some such function.
20:44:51 <bos> is moggi the person responsible for bringing categorical thinking to programming languages, or did someone blaze a trail before him?  he seems to have been the main influence on wadler.
20:45:20 <ddarius> bos: He brought it to denotational semantics, but certainly category theory was used way before that.
20:45:40 <ddarius> bos: For example, denotational semantics itself.  E.g. Dana Scott.
20:46:24 <bos> ah yes.
20:46:59 <bos> so that would have been back around 1969 or so.
20:47:10 <faxathisia> dataangel: Why don't you write out a proper description of your language
20:47:19 <faxathisia> dataangel: just textually, not in haskell
20:47:21 <faxathisia> (Yet)
20:47:29 <nolrai> well i have what the install put there. I think. I'll try removing and reinstaling.
20:47:53 <ddarius> (To correct my earlier phrase, Moggi brought -monads- to structuring denotational semantics)
20:48:27 <dataangel> faxathisia: It's just really basic C syntax. Variable declarations, assignment, and arithmetic. I'm only doing this as an exercise in learning parsec/haskell
20:48:40 <faxathisia> dataangel: Write it out textually
20:48:45 <faxathisia> dataangel: like a proper description of it
20:50:07 <bos> @hoogle on
20:50:07 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
20:50:07 <lambdabot> System.Console.Readline.onNewLine :: IO ()
20:50:07 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
20:50:11 <bos> hmph
20:50:18 <dataangel> faxathisia: I could go so far as to write out the formal denotational semantics, but I don't think that'll help me figure out what mystery input parsec is looking at :P
20:50:24 <bos> i'd swear on is defined in some library somewhere in 6.8
20:50:34 <faxathisia> dataangel: ... ok... I don't think I am able to help you then
20:51:19 <ddarius> Data.Function
20:51:25 <dataangel> faxathisia: it's not that I don't appreciate the help, I'm just trying to figure out a technical detail ATM
20:51:35 * ddarius waits for Control.Function
20:51:42 <faxathisia> dataangel: ... I am aware of that but you are focusing on the wrong thing
20:51:46 <TSC> bos: Data.Function
20:51:58 <TSC> Bah, way too slow (:
20:52:09 <dataangel> faxathisia: how so?
20:52:32 <bos> thank y'all.
20:53:49 <dataangel> faxathisia: you're probably right about separate lexing and parsing steps being easier, but I don't want to just run away from an error and do things entirely differently without ever understanding why my way didn't work. it's likely I'm missing something about how haskell or parsec works that would be good to know
20:54:20 <faxathisia> dataangel: That's exactly what I mean by focusing on the wrong thing but I don't think I want to labour this point anymore
20:55:09 <dataangel> faxathisia: sorry I didn't get it :P
21:03:28 <nolrai> GHC still can't find  "Control/Monad/State.hs", but finds "Data/Array.hs" just fine.
21:07:44 <nolrai> wait. it finds "Data.Array.Diff"?! what is different?
21:08:39 <allbery_b> mtl package misregistered?
21:09:21 <allbery_b> (depending on ghc version, Data/Array is base or arrays package; in both 6.6 and 6.8 Control/Monad/State is mtl package)
21:10:41 <ddarius> Authors seem to be (joining LtU and) replying to discussions on their work on LtU moreso lately.
21:12:28 <glguy> dons: still there?
21:12:38 <dons> yo
21:12:57 <glguy> this template language is going to make your static brain asplod ;)
21:13:19 <dons> you'll pay for this, Mertens!
21:13:54 <dons> glguy: i was inspired, http://galois.com/~dons/types.html
21:13:54 <lambdabot> Title: PHP is too hard
21:14:20 <glguy> lol
21:15:25 <faxathisia> hmf
21:15:37 <faxathisia> It would be easier to see if it was symmetric or not if you colored the background of the table
21:15:38 <dmwit> haha, "The type checker enforces simplicity by declaring bad ideas illegal."
21:15:45 <dons> faxathisia: i was just thinking that
21:16:06 <ddarius> faxathisia: Yeah, I said something like that earlier.
21:16:06 <dons> there's the germ of a blog post in here, i'll polish it up later
21:16:14 <faxathisia> :D
21:16:22 <faxathisia> you can upset some folk on reddit too!
21:16:30 <dons> i want to get at what it means to have removed those options
21:16:50 <dons> its one of the nicer ways of presenting why we bother with this types stuff
21:16:52 <hoelzro> if you do post on reddit, don't start your post with "Holy Schmoly"...
21:16:53 <ddarius> dons' blog posts are peer-reviewed by a select panel.
21:16:58 <faxathisia> yeah, I agree
21:17:04 <hpaste>  wellwisher pasted "Compile Errors" at http://hpaste.org/4275
21:17:07 <glguy> dons: looks like Haskell == function kinda sucks , eh?
21:17:11 <glguy> dons: doesn't do much
21:17:15 <dons> glguy: yeah, what's the point?
21:17:19 <dons> i want *power*
21:17:27 <faxathisia> the benefits of types don't stop there though!
21:17:30 <wellwisher> any help?
21:17:33 <faxathisia> it would be a shame if people got that impression
21:17:36 <dons> the power of "php" = 0
21:17:46 <glguy> dons: well it does, doesn't it?
21:17:58 <dmwit> wellwisher: Needs parens.
21:18:14 <dmwit> wellwisher: show (Begin _) = ...; show (Arrival i) = ...; show (Departure i) = ...
21:18:29 <dons> i'd present transitivity of == too, i think
21:18:37 <dons> since you kinda expect that
21:18:39 <kfish> dons: that post will need a spoonful of sugar to stop the babies crying
21:18:49 <dons> kfish: i know. its not a post!
21:18:53 <dons> its an idea of a post
21:18:59 <kfish> yet :-)
21:19:42 <dons> maybe skull and cross bones in boxes where its just stupid to allow it
21:19:45 <dmwit> wellwisher: And merge (as you've written it) takes one argument, whereas you give it two arguments.
21:19:55 <skew> 22:18 < dons> Cale: http://galois.com/~dons/types.html :)
21:19:55 <lambdabot> Title: PHP is too hard
21:19:56 <kfish> but yeah, you already know what i mean -- why does "not allowed" make things simpler ...
21:20:13 <wellwisher> i see
21:20:17 <dons> right.
21:20:24 <ddarius> What is the logic for "php" = 0
21:20:25 <ddarius> ?
21:20:38 <dons> i blame "too many rules" for allowing that
21:20:52 <Cale> ddarius: it fails to parse as an integer
21:20:52 <dons> i.e. complexity got so great, it slipped through, then something fundamental depended on it
21:21:09 <Cale> ddarius: which for some reason means that it's equal to 0 :)
21:21:16 <ddarius> Cale so it ends up as a NULL and that equals 0?
21:21:31 <faxathisia> pugs> "Perl 6" == 0
21:21:31 <faxathisia> Bool::True
21:21:33 <Cale> no
21:21:45 <Cale> well, hmm
21:22:01 <faxathisia> "php"+1  = 1
21:22:07 <faxathisia> doesn't it?
21:22:10 <hpaste>  tehgeekmeister annotated "Not very useful example of my flowchart dealio." with "Final version for now." at http://hpaste.org/4261#a6
21:22:17 <Cale> I think it's just that a string in numeric context which doesn't otherwise parse as a number gets treated as 0
21:22:30 <tehgeekmeister> and with that, i leave you for a week or two.
21:22:32 * ddarius stares bemused.
21:22:44 <hpaste>  dmwit annotated "Compile Errors" with "possible fix" at http://hpaste.org/4275#a1
21:23:15 <skew> dons: shouldn't "php" == [] ==> False?
21:23:50 <Cale> also, 1 == TRUE && -1 == TRUE
21:23:51 <hpaste>  dmwit annotated "Compile Errors" with "blast! stop being clever" at http://hpaste.org/4275#a2
21:24:28 <dmwit> agh
21:24:30 <nicodaem`> it's the inconsistencies with the PHP that bug me.  0 == NULL, but 0 == "php" /= NULL ... huh?!?
21:24:32 <dmwit> I screwed up again.
21:25:03 <shapr> dons is my hero!
21:25:05 <Cale> nicodaem`: == in PHP just massively fails transitivity
21:25:22 <faxathisia> skew: No since String and [Char] are differen
21:25:34 <skew> since when?
21:25:40 <faxathisia> about 5 mins ago :p
21:25:46 <hoelzro> what?
21:25:50 <faxathisia> I think it help illustrate the point better...
21:26:00 <shapr> faxathisia: scuse m?
21:26:02 <faxathisia> (I asked the same question you did just a few mins ago)
21:26:09 <Cale> type String = [Char]
21:26:13 <shapr> ank616: Learning Haskell?
21:26:15 <Cale> (from the Prelude)
21:26:19 <skew> ah, they were going to make a class for that, weren't they?
21:26:24 <shapr> Stringable?
21:26:25 <dmwit> Cale: Yes, but it muddies the table.
21:26:28 * shapr grins
21:26:35 <ddarius> @src String
21:26:35 <lambdabot> type String = [Char]
21:26:39 <dmwit> class Stringy where ...
21:26:53 <Cale> dmwit: what does?
21:26:57 <faxathisia> String is different to [Char] -- For the purposes of dissing PHP
21:27:03 <faxathisia> I should have been more clear..
21:27:08 <dmwit> Cale: "php" == [] -- not a type error
21:27:17 <faxathisia> > "php" == ([] :: [Int])
21:27:18 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
21:27:40 <allbery_b> IsString?
21:28:07 <Cale> > "php" == []
21:28:08 <lambdabot>  False
21:28:44 <dons> yes, that could be explained, since its an obvious retort
21:28:48 <dons> "" == []
21:28:49 <mrd> > fix ("php":)
21:28:50 <lambdabot>  ["php","php","php","php","php","php","php","php","php","php","php","php","ph...
21:28:55 <Cale> though perhaps [] isn't really the best analogue to array()
21:28:59 <dons> oh, looks like you can fix it
21:29:02 <dons> but it would take forever
21:29:06 <faxathisia> lol
21:29:09 <shapr> bwahah
21:29:22 <dmwit> Ba-dum PSH!
21:29:22 <dons> :)
21:30:26 <stick_figure> How does one limit quickcheck to supplying a list of distinct integers?
21:30:37 <dmwit> :t (==>)
21:30:38 <lambdabot> Not in scope: `==>'
21:30:39 <mrd> you could nub it
21:30:50 <stick_figure> mrd, as in filter it to make it distinct?
21:30:52 <shapr> Yeah, try ==> as dmwit says.
21:31:07 <ddarius> > 'p':'h':'p':[]
21:31:08 <lambdabot>  "php"
21:31:08 <dmwit> I like the nub suggestion better.
21:31:09 <shapr> You could create your own Arbitrary instance.
21:31:11 <mrd> yea it might eliminate too manyof the ints in some cases though
21:31:12 <dmwit> > nub "php"
21:31:12 <lambdabot>  "ph"
21:31:56 <stick_figure> nub just deduplicates lists?
21:32:05 <mrd> > all ((==1) . length) . group . sort $ [1,2,3,4,1]
21:32:05 <lambdabot>  False
21:32:08 <Olathe> > nub "yes"
21:32:08 <mrd> > all ((==1) . length) . group . sort $ [1,2,3,4]
21:32:08 <lambdabot>  "yes"
21:32:08 <lambdabot>  True
21:32:36 <faxathisia> @src nub
21:32:36 <lambdabot> nub = nubBy (==)
21:32:39 <skew> dons: are you running some recent build with overloaded strings?
21:32:44 <faxathisia> @src nubBy
21:32:45 <lambdabot> nubBy eq []             =  []
21:32:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:32:46 <Olathe> > (++ "!!).(>> "AA") "yes"
21:32:46 <lambdabot> Unbalanced parentheses
21:32:53 <Olathe> > (++ "!!").(>> "AA") "yes"
21:32:54 <lambdabot>  Couldn't match expected type `a -> [Char]'
21:33:01 <Olathe> > ((++ "!!").(>> "AA")) "yes"
21:33:02 <lambdabot>  "AAAAAA!!"
21:33:21 <stick_figure> it's not in scope in ghci, is that new as of later than ghc 6.4.2?
21:33:23 <mrd> ?check \ l -> (all ((==1) . length) . group . sort $ l) ==> map head (group (sort l)) == l
21:33:23 <lambdabot>  Add a type signature
21:33:25 <dons> skew, no, i just choose arbitrarily to declare [] of a specific type
21:33:29 <mrd> ?check \ l -> (all ((==1) . length) . group . sort $ l) ==> map head (group (sort l)) == (l::[Int])
21:33:30 <lambdabot>  Falsifiable, after 7 tests: [5,-4]
21:33:34 <dons> where a /= Char
21:33:44 <mrd> ?check \ l -> (all ((==1) . length) . group . sort $ l) ==> map head (group (sort l)) == sort(l::[Int])
21:33:45 <lambdabot>  Arguments exhausted after 484 tests.
21:34:03 <ddarius> > let nub = foldr1 (filter . (/=)) in nub "abraocehusth"
21:34:03 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
21:34:03 <lambdabot>       Expected...
21:34:07 <mrd> ?check \ l -> (all ((==1) . length) . group . sort $ l) ==> map head (group (sort l)) == sort(l::[Int])
21:34:07 <shapr> stick_figure: I'd recommend ghc 6.8.1 and quickcheck 2.0
21:34:08 <lambdabot>  Arguments exhausted after 488 tests.
21:34:13 <mrd> arguments exhausted?
21:34:22 <shapr> mrd: That's happened with some of my exs.
21:34:25 <mrd> they need rest!
21:34:26 <faxathisia> parameters tired
21:34:37 <stick_figure> shapr, maybe, it's not in the repo though.
21:34:42 <mrd> shapr: not with my family
21:34:43 <ddarius> :t filter . (/=)
21:34:50 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
21:35:03 <patperry> I want a DiffUArray that I can marshall to C code as an array without copying all of the elements.  Is this possible?
21:35:13 <dons> i'm not sure DiffUArray is good then
21:35:22 <dons> how about Foreign.Ptr.Array or Array.Storable
21:35:30 <ddarius> > let nub = foldr (filter . (/=)) [] in nub "abraocehusth"
21:35:38 <lambdabot>  ""
21:35:40 <dons> since they're the only ones that can be passed without copying, basically
21:35:46 <patperry> theres no way of getting one out of Array.Storable?
21:35:46 <shapr> mrd: hah
21:35:49 <mrd> ddarius: well there's no duplicates!
21:35:54 * ddarius was hoping not to have to add the the x:
21:35:57 <dons> patperry: yeah, Array.Storable is fine
21:36:02 <dons> anything 'Storable'
21:36:13 <dons> patperry: but you'll likely be looking at arrays in IO
21:36:21 <shapr> stick_figure: darcs get http://www.cs.chalmers.se/~bringert/darcs/QuickCheck
21:36:23 <lambdabot> Title: Index of /QuickCheck
21:36:24 <dons> since you can't trust the C code, and you're calling C anyway (which will likely be in IO)
21:36:35 <dons> anyway, DiffArrays are super inefficient, in the current impl.
21:36:54 <ddarius> > let nub = scanr (filter . (/=)) [] in nub "abraocehusth"
21:36:56 <lambdabot>  ["","","","","","","","","","","","",""]
21:37:47 <patperry> ok, thanks for the advice.  I was hoping to stay away from IO by only using "pure" C code, but I guess I'm stuck with it
21:38:30 <dons> yeah, if performance matters, DiffArray isn't good enough, unfortunately
21:38:36 <dons> nor can it be marshalled easily
21:38:50 <Olathe> > 1:""
21:38:51 <lambdabot>   add an instance declaration for (Num Char)
21:39:14 <Olathe> Who told you it was [Char] ?
21:39:22 <ddarius> :t ""
21:39:23 <lambdabot> [Char]
21:39:44 <Olathe> > error "[Char]"
21:39:46 <lambdabot>  Exception: [Char]
21:40:07 <Olathe> > error $ cycle "Exception: "
21:40:08 <lambdabot>  Exception: Exception: Exception: Exception: Exception: Exception: Exception:...
21:40:09 <faxathisia> > error (reverse "Exception: ")
21:40:10 <lambdabot>  Exception:  :noitpecxE
21:40:30 <nornagon> hm... has anyone written a Bresenham line algorithm in haskell that i could steal?
21:41:01 <dfranke> > error (cycle . reverse "Exception: ")
21:41:01 <lambdabot>  Couldn't match expected type `a -> [a1]'
21:41:03 <shapr> Bah, where's Chris Ball when I need him?
21:41:06 * ddarius hasn't written a Bresenham line algorithm in like 9 years.
21:41:08 <dfranke> > error (cycle . reverse $ "Exception: ")
21:41:08 <lambdabot>  Exception:  :noitpecxE :noitpecxE :noitpecxE :noitpecxE :noitpecxE :noitpecx...
21:41:20 <dfranke> > error (reverse . cycle $ "Exception: ")
21:41:22 <shapr> ddarius: What about bloom filters?
21:41:23 <lambdabot> Terminated
21:41:42 <faxathisia> > error (concat $ iterate reverse $ "Exception: ")
21:41:51 <lambdabot>  Exception: Exception:  :noitpecxEException:  :noitpecxEException:  :noitpecx...
21:41:53 <ddarius> shapr: Never written a bloom filter.
21:42:14 <shapr> You take some roses, squish 'em into a ... oh never mind. Bloom filters are nifty.
21:42:19 <nornagon> > error (concat $ iterate reverse $ reverse " Exception: ")
21:42:19 <lambdabot>  Exception:  :noitpecxE  Exception:  :noitpecxE  Exception:  :noitpecxE  Exce...
21:42:32 * ddarius does other things with roses.
21:42:38 <shapr> Lightning bolts?
21:42:44 <shapr> It's clear that my meds have worn off.
21:42:52 <nornagon> heh, how scary
21:42:59 <nornagon> i'm writing a lightning generator in haskell :P
21:43:06 <shapr> nornagon: oooh!
21:43:07 <nornagon> http://ccdevnet.org/~nornagon/lightning.png
21:43:08 * shapr zaps nornagon 
21:43:15 <ddarius> shapr: Actually when I was in Alabama not too long ago, I brought a rose with me.
21:43:21 * nornagon `zap` shapr
21:43:28 <shapr> ddarius: Obviously not for visiting me.
21:43:37 <shapr> I may be cute, but I'm not that cute.
21:43:54 <ddarius> shapr: No, shapr.  No you're not.
21:43:59 * shapr `arrow` nornagon 
21:44:08 <nornagon> shapr >>= chair
21:44:09 <shapr> ddarius: But I keep trying to persuade hot chix that I am.
21:44:23 * shapr grins
21:44:25 <ddarius> shapr: I can't account for women's taste.
21:44:27 <dmwit> :t chair
21:44:30 <shapr> <- cannon -< nornagon
21:44:30 <lambdabot> Not in scope: `chair'
21:44:34 <Olathe> How do you go through all the permutations of a list ?
21:45:22 <nornagon> type Chair = Furniture a
21:45:44 <dmwit> syntax error
21:45:56 <dmwit> type variable not in scope: `a'
21:45:58 <nornagon> Chair a then <.<
21:46:04 <dmwit> heh
21:46:14 <shapr> > filterM (const [True,False]) [1,2,3]
21:46:16 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:46:40 <shapr> Olathe: Like that?
21:46:46 <dmwit> No, that's the power set.
21:46:49 <shapr> oh
21:48:39 <hpaste>  shapr pasted "permutations from PreludeExts" at http://hpaste.org/4276
21:49:57 <dmwit> Oh, that's more clever than the one I was working on.
21:50:19 <dmwit> I tried to insert an element at each position in a list, but extracting each element in turn is much nicer.
21:51:16 <hpaste>  wellwisher pasted "Whats the parse error?" at http://hpaste.org/4277
21:52:05 <clanehin_> > let constrain f g x = if f x then g x else x
21:52:05 <lambdabot>  Parse error at end of input
21:52:32 <clanehin_> I pasted from ghci . . .
21:53:22 <clanehin_> @let constrain f g x = if f x then g x else x
21:53:25 <lambdabot> Defined.
21:53:42 <clanehin_> map (constrain even (*2)) [0..10]
21:53:54 <Olathe> > (constrain (const True) id) 5
21:53:55 <lambdabot>  5
21:54:05 <clanehin_> > map (constrain even (*2)) [0..10]
21:54:06 <lambdabot>  [0,1,4,3,8,5,12,7,16,9,20]
21:54:29 <Olathe> > map (constrain (const True) id) [0..10]
21:54:31 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
21:54:34 <wellwisher> so what is my parse error?
21:55:33 <clanehin_> wellwisher: is this a quiz?
21:55:43 <clanehin_> Compiler output?
21:55:58 <wellwisher> Main.hs:16:1: parse error on input `instance'
21:56:33 <clanehin_> probably whatever is just above the instance, that you snipped out
21:57:11 * clanehin_ finds a function every day that he wishes were in the prelude, like constrain
21:57:35 <faxathisia> do you have your own prelude?
21:58:27 <hpaste>  wellwisher annotated "Whats the parse error?" with "Whats the parse error?" at http://hpaste.org/4277#a1
21:58:43 <davidL> @index writeMS
21:58:43 <lambdabot> bzzt
21:58:49 <sclv> Data.Function should end up being a natural repository for any number of the more popular of these "folk" functions, no?
21:58:57 <wellwisher> that has more of the file
21:59:06 <Olathe> > let selections :: [a] -> [(a,[a])]; selections [] = []; selections (x:xs) = (x,xs) : [ (y,x:ys) | (y,ys) <- selections xs ]; permutations :: [a] -> [[a]]; permutations [] = [[]]; permutations xs = [ y : zs | (y,ys) <- selections xs, zs <- permutations ys ] in error $ (drop 1 $ permutations "Exception:") >>= (++ " ")
21:59:15 <lambdabot>  Exception: Exceptio:n Exceptino: Exceptin:o Excepti:on Excepti:no Exceptoin:...
21:59:15 <allbery_b> wellwisher: indentation
21:59:16 <clanehin_> faxathisia: I guess I should
21:59:24 <faxathisia> I would like to see it!
21:59:39 <allbery_b> because the second "instance" is indented it's considered part of the previous instance declaration,w hich is an error
21:59:46 <faxathisia> usually I made Auxiliary.hs which has stuff like that in it
21:59:56 <faxathisia> but it's different for every program
22:00:49 <wellwisher> now it says: Main.hs:18:4: parse error (possibly incorrect indentation)  on 2nd to last line
22:01:18 <clanehin_> usually I'm really impressed with haskell but then I'm stuck with, they took until 6.6 to come up with comparing?!?
22:01:55 <ddarius> clanehin_: There is a horde of functions that could be added to the "standard" libraries.
22:01:57 <davidL> where is popen?
22:02:27 <allbery_b> wellwisher: I count one to many open parens (or a missing close paren)
22:02:37 <allbery_b> @where newpopen
22:02:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
22:03:00 <wellwisher> lol
22:03:31 <nornagon> @hoogle trace
22:03:32 <lambdabot> Debug.Trace.trace :: String -> a -> a
22:03:32 <lambdabot> Debug.Trace :: module
22:03:32 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
22:04:18 <dons> davidL: System.Process ?
22:05:22 <davidL> did it used to be in System.PosixCompat by any chance?
22:05:44 <dons> maybe. the name rings a bell
22:06:20 <dibblego> ?src if'
22:06:20 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
22:06:22 <allbery_b> wasn't the original popen in MissingH?
22:06:27 <dibblego> ?where if'
22:06:27 <lambdabot> I know nothing about if'.
22:06:33 <allbery_b> it doesn't exist
22:06:43 <hpaste>  nornagon pasted "Bresenham's line algorithm" at http://hpaste.org/4278
22:06:46 <allbery_b> if'' is @pl's way of saying "I can't @pl an if then else"
22:06:51 <dons> so, anyone coded up a bytestring based HAT-trie yet?
22:07:06 <dons> http://www.crpit.com/confpapers/CRPITV62Askitis.pdf
22:07:41 <nornagon> erk
22:07:45 <nornagon> that algo is broken :(
22:10:52 <nornagon> oh, cool, it's not my fault
22:16:21 <sclv> dons: yipe. it looks like given all the bit-level funniness involved in those tries that it would make more sense to do most of the work in C?
22:18:14 <smack_> any good papers on rank 2 (or rank N?) polymorphism?
22:19:20 <dibblego> ?where+ if' http://www.haskell.org/haskellwiki/If-then-else
22:19:20 <lambdabot> I will never forget.
22:19:24 <dibblego> ?where if'
22:19:24 <lambdabot> http://www.haskell.org/haskellwiki/If-then-else
22:19:53 <dons> sclv: the bit wise stuff, yeah
22:19:55 <dons> that'd make sense
22:20:07 <dons> use strict bytestrings so you can pass them to C, make ffi calls to any big chunks of bit hacking
22:20:13 <davidL> dons: why isn't `nick' exported in IRCBase.hs of lambdabot?
22:20:16 <dons> or very carefully write the unboxed code
22:20:19 <dons> davidL: no idea :)
22:20:31 <dons> lambdabot maintains herself, in a state of disrepair
22:20:44 <davidL> :-]
22:22:15 <davidL> ah nevermind, nick is in Message
22:26:01 <sorear> also, I'm responsible for the current sorry state of the IRC subsystem
22:27:39 <pejo> smack, in general?
22:27:58 <dons> sorear: for the url deadlock? or was that always there?
22:28:09 <hpaste>  nornagon annotated "Bresenham's line algorithm" with "fixed" at http://hpaste.org/4278#a1
22:28:11 <smack_> pejo: i suppose?  i'm reading a paper on ST
22:28:53 <sorear> dons: it *seems* pretty orthogonal - if an unsafe foreign call is locking up the runtime now, it would do that with the old IRC layer
22:29:23 <pejo> smack, Odersky and Lufer had "Putting type annotations to work" in 96 I think. Mark P Jones with "First class polymorphism" around the same time. There's a recent one in JFP by Simon Peyton Jones that I don't recall the name of aswell.
22:29:40 <dons> sorear: yeah, i think it was always there, but we only catch the thread timing out properly now.
22:29:45 <dons> so we actually see it happen, when it happens
22:29:54 <dons> rather than the bot just not responding -- which has always been there
22:30:12 <sorear> the netsplit bug *is* fixed though
22:30:18 <dons> yep
22:30:32 <dons> so something unsafe down in network, i guess
22:30:39 <dons> should be in a forkOS
22:30:53 <nornagon> :t when
22:30:54 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:33:12 <sorear> dons: I suspect that the url module uses a 'foreign import unsafe' erroneously
22:34:31 <dons> that would be further down in network, then.
22:34:44 <dons> $ pwd
22:34:44 <dons> /home/dons/lambdabot/Lib
22:34:45 <dons> $ grep foreign *
22:35:19 <sjanssen> IIRC, network jumps through some pretty major hoops to avoid blocking foreign calls
22:35:51 <dons> sorear: though i did try an experiment with linking against the non-threaded runtime
22:36:00 <dons> the bot is currently using that. i've not seen a lockup yet
22:36:01 <dons> ?uptime
22:36:01 <lambdabot> uptime: 1d 23h 43m 22s, longest uptime: 1m 10d 23h 44m 29s
22:36:06 <dons> we'll see how long it lasts
22:36:16 <sorear> dons: interesting
22:36:32 <sorear> dons: you'd think there would be *more* lockups with non-threaded
22:36:47 <dons> you'd think.
22:37:10 <sorear> dons: +RTS -N30 seemed more likely to me (would of course ruin performance, but not much grinding in LB proper)
22:37:38 <hpaste>  nornagon annotated "Bresenham's line algorithm" with "fixed again" at http://hpaste.org/4278#a2
22:37:45 <dons> so all we know is that there's a thread kill thrown at the url thread. it times out
22:38:01 <dons> and the foreign call probably doesn't return...
22:38:09 <dons> and the rts just stops, after the failure is reported
22:38:44 <dons> omg.
22:38:45 <dons> http://www.bluebytesoftware.com/blog/CommentView,guid,bae6ac13-2a95-4887-9ee3-3e64867c5650.aspx
22:38:47 <lambdabot> Title: Joe Duffy's Weblog, http://tinyurl.com/yryynx
22:38:55 <dons> RealWorld# for C# ?
22:39:36 <smack_> pejo++  thanks, i'll check those out!
22:40:21 <mwc> hahaha
22:40:39 <mwc> somebody post the link to Lazy State Threads on a comment to that blog post
22:40:55 <dons> how they can go a whole article about copying the world without mentioning that kind of thing is kind of stunning.
22:41:37 <mwc> so they've invented IO = ST RealWorld, made an allusion to transactional memory?>
22:42:16 <dons> seems likely
22:43:02 <glguy> dons: did you see http://www.xkcd.com/353/ ?
22:43:02 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
22:43:10 <dons> "Server Error in '/blog' Application.
22:43:11 <dons> A potentially dangerous Request.Form value was detected from the client (_ctl7:comment="...check out <a href="http://cite..."). "
22:43:18 <mwc> wee, maybe they'll invent syntax for making it easier to pass the world state
22:43:27 <dons> mwc, that's crazy talk!
22:43:48 <dons> Version Information: Microsoft .NET Framework Version:1.1.4322.2032; ASP.NET Version:1.1.4322.2032
22:44:02 <dons> i included an href in the comment, and the server flipped
22:44:32 <sorear> let's call this 'shotgun security'
22:44:53 <dons> :t RealWorld#
22:44:59 <lambdabot> Not in scope: data constructor `RealWorld#'
22:45:23 <mwc> oh, sorry, dons, I was mistaken
22:45:33 <mwc> it really appears they invented State, not ST RealWorld
22:45:49 <dons> yeah, "more fully" :)
22:45:58 <dons> i think they're at the omg, let w' = f w
22:46:01 <dons> phase.
22:47:13 <dons> if you need this for C#, when do they start teaching monads in school?
22:47:36 * dmwit teaches monads in school already
22:47:50 <dmwit> But only to non-CS people. =)
22:48:12 <dons> that's the spirit
22:48:25 <sjanssen> sorear, dons: perhaps lambdabot is blocked in gethostbyname()?
22:48:42 <sjanssen> ie. DNS is blocking for some reason
22:49:30 <sjanssen> that call is marked "safe", however
22:50:10 <quicksilver> sjanssen: was it you who was muttering about a possible way to get persistence/serialisation for thunks?
22:50:24 <sjanssen> quicksilver: I don't think so
22:50:35 <quicksilver> sjanssen: ah. hmm. Maybe it was augustss .
22:50:41 <sjanssen> at least I don't remember having any special insight into that issue :)
22:54:34 <quicksilver> somebody was suggesting that the structure of the STG actually gave rise to an obvious mechanism for it
22:54:40 <quicksilver> or, that's my memory of what they said
22:54:43 <quicksilver> I could be confused :)
22:55:41 <quicksilver> ah well, I see gwern asked the question on the -cafe
22:55:48 <quicksilver> perhaps whoever it was will speak up there :)
22:59:12 <sjanssen> dons, sorear: I propose modifying the timeout function to kill threads asynchronously
22:59:44 <sjanssen> this means that the computation may continue running even after 'timeout' has exited.  Do you think this will cause any issues?
23:00:12 <sorear> sjanssen: D'OH
23:00:28 <sorear> sjanssen: certainly, I thought that's how it worked
23:00:34 <sjanssen> it isn't
23:01:21 <glguy> When are you guys going to release xmonad 0.5? Now I know two people waiting for it before they can start using it (the 0.4.1 package on arch linux doesn't build since they moved to ghc 6.8.1)
23:01:50 <sjanssen> grep timeout **/*hs # doesn't come up with anything that immediately causes me concern, but I thought I should check with y'all
23:02:14 <sjanssen> glguy: we released an RC today
23:02:39 <sjanssen> glguy: or you can suggest they patch xmonad.cabal, the modifications are trivial
23:03:05 <glguy> 0.4.1 -> 0.5 is a pretty big shift, no?
23:03:10 <glguy> (if its coming out this week)
23:03:32 <sjanssen> yes, there are some big changes
23:04:20 <sjanssen> big changes wrt. configuration and packaging, the default user experience hasn't changed much
23:06:24 <sorear> glguy: when you upgrade past a libraries flag day, expect massive breakage.  I for one would not advise anyone to make that upgrade this year
23:06:46 <glguy> you mean to upgrade ghc?
23:07:12 <sjanssen> dons, sorear: (untested) patch pushed, hopefully it doesn't break anything
23:08:34 <sorear> glguy: yes
23:08:43 <dons> sjanssen: ok, i'm keen.
23:09:38 <dons> not sure what sorear is talking about. i don't think that is relevant to xmonad.
23:10:53 <sorear> dons: "23:01 < glguy> When are you guys going to release xmonad 0.5? Now I know two people waiting for it before they can start using it (the 0.4.1 package on arch linux doesn't build since they moved to ghc 6.8.1)" <- I'm saying it's their fault for upgrading before the libraries settle
23:11:24 <glguy> sorear: oh, I'm not interested in assigning fault at all, just curious when 0.5 was coming out
23:12:15 <dons> they upgraded, and broke their xmonad package, yep.
23:12:16 <sjanssen> sorear: well, I wouldn't exactly blame the users, the library hackers could have done a better job at this transition
23:12:33 <dons> we needed cabal configurations 1 year ago
23:12:34 <dons> :)
23:12:47 <dons> so when we had a use case for it, we'd have been ready
23:13:42 <sjanssen> though I do think there is some wisdom in waiting a while on 6.8 for casual GHC users
23:16:32 <sjanssen> dons, sorear: btw, I looked at the Network code that lambdabot uses, it all looks safe to me ironclad
23:16:45 <sjanssen> s/ironclad//
23:18:05 <nanothief> does the do expression make the >> operator right associative?
23:18:31 <oerjan> @src >>
23:18:31 <lambdabot> m >> k      = m >>= \_ -> k
23:18:34 <dmwit> No, (>>) is infixl 1.
23:19:17 <nanothief> dmwit, i know that it is normally, but when doing something like do x;y;z, does it change to infixr
23:19:29 <dmwit> aha
23:19:36 <dmwit> no
23:19:47 <nanothief> hmmm
23:19:49 <dmwit> do { x; y; z } = x >> y >> z = (x >> y) >> z
23:19:57 <oerjan> @undo do a; b; c
23:19:57 <lambdabot> a >> b >> c
23:19:58 <dmwit> But it doesn't matter; the monad laws say that
23:20:02 <faxathisia> @pl f x = \_ -> x
23:20:02 <lambdabot> f = const
23:20:14 <dmwit> (x >> y) >> c = x >> (y >> c)
23:20:32 <dmwit> Why do you ask?
23:20:32 <faxathisia> @pl (\__ -> \_ -> __)
23:20:32 <lambdabot> (line 1, column 15):
23:20:32 <lambdabot> unexpected "_"
23:20:32 <lambdabot> expecting lambda abstraction or expression
23:20:40 <oerjan> indeed the do translation does imply right associative
23:21:12 <dmwit> Really?
23:22:29 <sjanssen> http://haskell.org/onlinereport/exps.html#sect3.14
23:22:40 <nanothief> oerjan: that would explain a bug i am getting
23:22:42 <sjanssen> the report does imply right association
23:22:47 <oerjan> do {e;stmts}  = e >> do {stmts}
23:23:08 <dmwit> huh
23:23:15 <sjanssen> nanothief: the associativity of >> should never change the meaning of your program, if it does you've got a bug in your Monad instance
23:25:03 <faxathisia> :t (\__-> \_->__)
23:25:10 <lambdabot> forall t t1. t -> t1 -> t
23:25:17 <joelr1> morning
23:25:40 <glguy> anyone know if tetley's british blend tea has caffeine?
23:25:45 * glguy assumes so
23:25:48 <joelr1> does anyone know of an expert systems implementation in haskell?
23:25:55 <joelr1> dons: maybe you?
23:25:58 <oerjan> glguy: the package doesn't say?
23:26:10 <glguy> oerjan: it might, do you have one?
23:26:26 <davidL> haha
23:26:29 <oerjan> no
23:26:39 <glguy> hmm, me neither
23:27:01 <sorear> glguy: I beleive all tea has caffiene unless it is deliberately removed (whether ther is a significant quantity, I'm not sure of)
23:27:19 <glguy> sounds reasonable
23:27:24 <glguy> is that the case for green tea too?
23:27:46 <hpaste>  nanothief pasted "bad monad with do" at http://hpaste.org/4279
23:28:07 <nanothief> this is the code that caused the association problems
23:28:39 <allbery_b> green tea has caffeine, yes
23:28:43 <oerjan> hm the tetley website is annoying
23:29:35 <OceanSpray> :t liftIO
23:29:45 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:29:47 <oerjan> hm maybe "british blend" is not actually called that in britain...
23:29:58 <davidL> @source lambdabot
23:29:58 <lambdabot> lambdabot not available
23:30:23 <oerjan> @where lambdabot
23:30:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:30:24 <allbery_b> @where lambdabot
23:30:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:30:27 <allbery_b> heh
23:30:37 <davidL> thanks :)
23:30:51 <faxathisia> vixen: Are you available?
23:30:56 <faxathisia> @vixen Are you available?
23:30:58 <lambdabot> first you tell me.
23:31:00 <allbery_b> taken from one of my tea boxes:  avg milligrams caffeine per 8oz. cup:  coffee = 100, black tea = 50, green tea = 30, decaffeinated tea = 4
23:32:19 <davidL> I was hoping to find haddocks for lambdabot :-\
23:32:45 <allbery_b> lambdabot is affressively underdocumented :/
23:32:50 <allbery_b> aggressively even
23:33:21 <glguy> ?where Haddock
23:33:21 <lambdabot> http://www.haskell.org/haddock/
23:33:51 <sjanssen> nanothief: why don't you allow filter after filter?
23:34:07 <davidL> where is the Module class defined?
23:35:43 <glguy> and then compose the filters
23:35:46 <davidL> nvm, it's in Lambdabot.hs
23:35:58 <sjanssen> nanothief: also, this seems like a bit of an abuse of the Monad class
23:36:03 <oerjan> nanothief: that monad is not going to work
23:36:18 <glguy> doesn't*
23:37:29 <nanothief> sjanssen,oerjan: i was just experimenting with monads. It does work when not using do. But if the >> is not meant to be affected by associativity, then it isn't a true Monad i don't think
23:37:51 <sjanssen> nanothief: you should check out the Monad laws
23:37:55 <oerjan> wordlist >> filter removes the filter, which makes it impossible for it to make worldlist >> (wordlist >> filter) equal to (wordlist >> wordlist) >> filter
23:38:57 <nanothief> oejan: yep, the problem was with (wordlist >> filter) >> filter, which with do became wordlist >> (filter >> filter), which isn't meant to work
23:39:08 <dmwit> nanothief: Is there a reason you're not just using the list monad + guard?
23:39:54 <oerjan> nanothief: but my example shows that even with wordlist first, the monad laws are violated i think
23:40:44 <dons> davidL: lambdabot was saying "bzzt." when haddock wasn't even a twinkle in simon marlow's eye
23:41:36 <nanothief> sjanssen: ahh i see. I never reads the laws from the monads tutorial very closely :P it definitey failed the m >>= (\x -> k x >>= h)	=	(m >>= k) >>= h law
23:42:10 <dons> the long arm of the monad laws will get you in the end :)
23:42:54 <hpaste>  sjanssen annotated "bad monad with do" with "WordList is the Writer Monad with the Endo Monoid" at http://hpaste.org/4279#a1
23:42:56 <nanothief> dons: noone is above the Monad Laws
23:43:03 <dmwit> > do { s <- ["hello", "goodbye", "lol"]; guard ((>3) . length $ s); guard (=='h' . head $ s) }
23:43:04 <lambdabot>      The operator `==' [infix 4] of a section
23:43:04 <lambdabot>         must have lower precede...
23:43:12 <dmwit> > do { s <- ["hello", "goodbye", "lol"]; guard ((>3) . length $ s); guard ((=='h') . head $ s) }
23:43:13 <lambdabot>  [()]
23:43:22 <dmwit> ah yes
23:43:26 <dmwit> > do { s <- ["hello", "goodbye", "lol"]; guard ((>3) . length $ s); guard ((=='h') . head $ s); return s }
23:43:27 <lambdabot>  ["hello"]
23:45:11 <dmwit> ?hoogle (MonadPlus m) => (a -> Bool) -> a -> m a
23:45:12 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
23:45:42 <dmwit> :t \f a -> if f a then return a else mzero
23:45:53 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> a -> m a
23:46:19 <dmwit> :t \f a -> guard (f a) >> return a
23:46:20 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
23:47:05 <glguy> hmm, haddock-darcs .cabal file defines cabal-vesion twice
23:47:09 <glguy> seems like a bug
23:48:39 <OceanSpray> :t liftM
23:48:47 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:48:48 <OceanSpray> :t ErrorT
23:48:48 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
23:49:10 <glguy> mtl is the old news ;) MonadLib is the future
23:49:22 <dmwit> > ["hello", "goodbye", "lol"] >>= ensure ((>3) . length) >>= ensure ((=='h') . head) -- this is pretty, is there an equivalent of ensure in the libraries?
23:49:23 <lambdabot>  ["hello"]
23:49:39 <glguy> filter?
23:49:59 <dmwit> Close, but the type is just a bit off.
23:50:02 <Olathe> @src ensure
23:50:02 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:50:02 <dmwit> Oh.
23:50:05 <dmwit> I see what you mean.
23:50:07 <dmwit> But:
23:50:07 <TSC> :t ensure
23:50:14 <lambdabot> Not in scope: `ensure'
23:50:23 <Olathe> (:[]).filter
23:50:28 <dmwit> > (Just "hello") >>= ensure ((>3) . length) >>= ensure ((=='h') . head)
23:50:34 <lambdabot>  Just "hello"
23:51:02 <glguy> :t \ p x -> guard p >> return x
23:51:04 <Olathe> > let ens = return.filter in (Just "hello") >>= ens ((>3) . length) >>= ens ((=='h') . head)
23:51:05 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
23:51:05 <lambdabot>  Couldn't match expected type `Maybe'
23:51:07 <Olathe> :(
23:51:16 <glguy> err
23:51:21 <glguy> :t \ p x -> guard (p x) >> return x
23:51:22 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
23:51:22 <dmwit> ensure f x = guard (f x) >> return x
23:51:24 <Olathe> Not quite, I think.
23:51:39 <Olathe> > let ens = (map return).filter in (Just "hello") >>= ens ((>3) . length) >>= ens ((=='h') . head)
23:51:48 <lambdabot>  Couldn't match expected type `[a]'
23:51:52 <Olathe> Oh well.
23:52:06 <dmwit> :t msum
23:52:15 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
23:52:34 <dmwit> :t let ens = msum . map return . filter in ens
23:52:50 <lambdabot> thread killed
23:53:26 <dmwit> :t let ens f = msum . map return . filter f in ens
23:53:42 <lambdabot> thread killed
23:54:23 <dmwit> Anyway, I'll probably add it to my standard library. =)
23:56:47 <hpaste>  patperry pasted "Fundep trouble" at http://hpaste.org/4280
23:57:08 <patperry> can someone help me with a fundep problem?
23:57:38 <patperry> or otherwise advise me on another approach?
23:59:04 <davidL> what could be a reason that runInteractiveProcess says file not found when the file is obviously there?
23:59:27 <davidL> I've checked permissions, 755
23:59:32 <Lemmih> patperry: What does GHC say?
23:59:54 <patperry> Couldn't match expected type `ma' (a rigid variable)
23:59:54 <patperry> 	   against inferred type `a' (a rigid variable)
23:59:54 <patperry>       `ma' is bound by the instance declaration at /Users/patrick/Programming/Haskell/Copy.hs:47:0
23:59:54 <patperry>       `a' is bound by the instance declaration at /Users/patrick/Programming/Haskell/Copy.hs:47:0
23:59:54 <patperry>     When using functional dependencies to combine
23:59:55 <patperry>       Copyable ma ma,
23:59:57 <patperry> 	arising from the instance declaration at /Users/patrick/Programming/Haskell/Copy.hs:50:0
23:59:59 <patperry>       Copyable a ma,
