00:00:46 <Enzo> QUESTION about web programming http://hpaste.org/4588
00:01:38 <nanothief> wy: something similar to what you are doing is at http://www.haskell.org/tutorial/moretypes.html. It only reimplements the (-) operator, and just uses wrappers for the other types
00:01:38 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again
00:01:53 <nanothief> *other operators
00:02:28 <wy> I've read that part, that's why I have this question
00:02:40 <nanothief> oh
00:03:12 <wy> it seems we just need to define the wrappers, unwrappers, ... But maybe that's too much to get into some new pattern
00:03:26 <nanothief> Enzo: shouldn't image be Image (just a guess)? eg image1 :: Image
00:04:52 <Enzo> nanothief:  Not in scope: type constructor or class `Image'
00:06:45 <Enzo> nanothief: oh I'm looking online and it should be lower case
00:07:19 <nanothief> Enzo: fair enough. it was just something that popped out at me as being wrong
00:08:25 <nanothief> Enzo: although the function still has to be wrong, you've set image to a "string", so it cannot be an image (haskell doesn't do implicit conversions)
00:08:43 <nanothief> are you sure there isn't a MakeImage constructor or something similar
00:09:05 <nanothief> haskell doesn't do implicit conversions <-- I don't think :)
00:09:33 <psi> types start with an uppercase letter also, so image is wrong
00:10:32 <Enzo> psi: http://www.haskell.org/ghc/docs/latest/html/libraries/xhtml/Text-XHtml-Transitional.html#v%3Aimage
00:10:33 <lambdabot> http://tinyurl.com/yupucc
00:10:47 <nanothief> Enzo, try removing the type signature, and changing the function to image1 = image "http:...."
00:12:12 <psi> Enzo: what? i see no "image" type there
00:13:24 <psi> the type is Html
00:13:45 <nanothief> Enzo: image is just a constant of type Html
00:14:43 <Enzo> psi: wow I was way off on that one
00:16:30 <psi> I agree though that it wouldn't hurt with some examples
00:16:40 <psi> I know I've seen some somewhere
00:17:23 <Enzo> psi: omg send me a link PLEASE
00:21:02 <psi> http://search.cpan.org/src/AUTRIJUS/Language-Haskell-0.01/hugs98-Nov2003/fptools/hslibs/text/html/doc/doc.htm
00:21:04 <lambdabot> http://tinyurl.com/32dj26
00:21:08 <psi> it's not the same library but it could help
00:21:23 <psi> the one you tried to use it based on it
00:24:06 <psi> try this one also http://haskell.cs.yale.edu/haskellwiki/Practical_web_programming_in_Haskell
00:24:07 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2s6jj3
00:24:51 <psi> *coffee break*
00:32:17 <wy> I've got a strange example from haskell 98 report. What to have a look?
00:33:13 <wy> http://hpaste.org/4589?#a0
00:33:54 <wy> Why is the first three diverge while the last four result to 42 ?
00:38:09 <Enzo> Psi: wow Thank You VERY VERY MUCH that REALLY helps =]
00:43:30 <scook0> wy: you're wondering why matching on a _|_ newtype doesn't diverge?
00:43:58 <scook0> I believe it comes down to the fact that newtypes don't really "exist" at runtime
00:44:22 <scook0> so even though (N i) looks like a pattern
00:44:50 <scook0> the fact that N is a newtype means that there isn't actually a constructor at runtime
00:45:03 <scook0> so there's no point forcing the thunk to see the constructor
00:45:08 <wy> that makes sense
00:45:42 <scook0> do you get the same results if you use case instead of a function definition?
00:45:49 <scook0> (I presume so)
00:46:31 <scook0> I agree it's weird that something that looks like strict decomposition doesn't actually force its argument
00:47:28 <wy> Ah, the point I was stuck is that n i = 42 doesn't try to match anything, because i is "atomic"
00:49:01 <wy> So it's bound to (N _|_) directly without evaluating anything
00:49:29 <wy> No it's bound to _|_
00:51:02 <wy> Maybe this is the reality version of the question puzzled me when I was taking my PL class. Something called pointed CPOs ?
00:53:05 <scook0> remember that N doesn't actually exist
00:53:30 <scook0> the compiler just uses it to keep type N and type Int distinct
00:53:37 <scook0> (at compile-time)
00:55:17 <wy> So if I want to define a data structure for 3D points and vectors, is it best to use ewtype Vector3 = Vector3 (Double, Double, Double) ?
00:56:00 <doserj> data Vector3 = Vector3 !Double !Double !Double
00:56:33 <doserj> in your version, you have an indirection through the (,,) constructor, anyways
00:57:14 <wy> but you have an indirection through Vector3
00:57:28 <doserj> yep :)
00:57:45 <wy> Is it better to be strict?
00:57:55 <scook0> for something like a vector, yes
00:58:08 <scook0> since you'll (almost) never want laziness in the components
00:58:09 <doserj> as a rule of thumb, for primitive types it often is
00:58:11 <wy> Good. If not, will there be three thunks?
00:58:23 <scook0> and strictness allows more optimizations, and potential unboxing
00:58:37 <wy> aha
00:58:43 <scook0> wy: there'll be three thunks anyway
00:58:49 <scook0> *unless* the compiler unboxes them
00:58:55 <Cin> does ghc run well on wine? just curious
00:59:09 <wy> When does the compiler unbox them?
00:59:32 <scook0> iirc, there's a pragma/flag to unbox strict fields
00:59:39 <quicksilver> wy, scook0: GHC doesn't unbox data types unless you tell it to
00:59:42 <quicksilver> -funbox-strict-fields
00:59:44 <quicksilver> IIRC
00:59:50 <quicksilver> or, the equivalent pragma
00:59:52 <scook0> quicksilver: ta
00:59:57 <wy> What if I use arrays?
01:00:00 <quicksilver> {-# UNBOX #-} maybe? I'm not sure.
01:00:10 <quicksilver> wy: UArrays are unboxed, that's what the 'U' means.
01:00:23 <quicksilver> wy: but, don't :) The overhead of array isn't worth it for 3 elements.
01:00:48 <wy> So it's better to use newtype?
01:00:51 <wy> or data?
01:01:00 <scook0> data, I'd say
01:01:04 <quicksilver> btw, newtype Vector3 = Vector3 (Double,Double,Double) is basically
01:01:16 <quicksilver> the same as data Vector3 = Vector3 Double Double Double
01:01:31 <quicksilver> in both cases, you define a new constructor Vector3 which is isomorphic to (,,)
01:01:55 <wy> But I can't use strictness in newtype ?
01:02:07 <quicksilver> I would use the latter, because the former feels contrived and is slightly more typing
01:02:28 <quicksilver> No, you can't use strictness in newtypes AFAIK
01:02:41 <scook0> I'm not sure what advantage you're seeing in newtypes
01:02:43 <quicksilver> (!Double,!Double,!Double) isn't a type :)
01:03:05 <wy> So data Vector3 = Vector3 !Double !Double !Double
01:03:17 <scook0> or even:
01:03:30 <wy> I'm just trying. When is newtype often used?
01:03:41 <quicksilver> when you want a new type isomorphic to an old one.
01:03:46 <scook0> data Vector3 = Vector3 { vec3_x :: !Double, vec3_y :: !Double, vec3_z :: !Double }
01:03:48 <scook0> :)
01:04:08 <doserj> deriving (Eq, Show, Read, Ix, ...)
01:04:14 <quicksilver> newtype is sometimes use for complex monad transformer stacks, e.g.
01:04:43 <quicksilver> newtype MyMonad m conf st a = ReaderT conf (StateT st m) a
01:05:35 <wy> I'd use
01:05:38 <wy> vec :: Vector3 -> Int -> Double
01:05:38 <wy> vec (Vector3 a b c) 1 = a
01:05:38 <wy> vec (Vector3 a b c) 2 = b
01:05:38 <wy> vec (Vector3 a b c) 3 = c
01:06:17 <doserj> vec _ n | n>3 || n < 0 = *boom* ?
01:08:53 <scook0> instance Index Vector One where index (Vector3 a b c) _ = a
01:08:54 <scook0> :)
01:08:57 <wy> vec _ _ = *boom*
01:09:50 <wy> What does that mean?
01:10:36 <quicksilver> vec v n = [vec3_x,vec3_y,vec3_z] !! n $ v
01:10:54 <quicksilver> although I must admit I don't often want to index vectors by numbers like that.
01:11:24 <doserj> it only makes sense, if you want arithmetic on the indices, which is not vere frequent
01:11:39 <wy> It's better to use index I think, especially you want to write something like line-box intersection
01:12:30 <wy> and it can be easily generalized to higher dimensions
01:13:03 <quicksilver> yes, if you're trying to write code which is dimension independent then you do indeed need arithmetic on the dimensions, sometimes.
01:14:58 <wy> I really hope the compiler can optimize out the indices, since all iterations are bounded from 1 to 3
01:17:37 <wy> I found this way always much more elegant in geometric programs, where you have those intersections. Saves lots of trouble even we have only 3D
01:19:59 <wy> Do you think the compiler can unbox that data type and eliminate the loo... wait I don't have loops
01:24:37 <wy> If I want to use something like a loop, must I use map or something like that? That way I have to make a list for the Vector3, then there is no advantage of using such a data type...
01:26:27 <quicksilver> wy: sounds a bit like you're worrying too much :)
01:26:35 <quicksilver> Does "premature optimisation" mean anything to you?
01:26:57 <quicksilver> There is a sense in which haskell doesn't have loops, only recursion, but there is another sense in which recursion is a perfectly good way to loop.
01:27:17 <quicksilver> And the compiler is pretty clever about inlining simple functions like your 'vec' function above.
01:27:29 <quicksilver> On the other hand, the compiler doesn't unroll loops by default.
01:27:35 <quicksilver> But, like I say, I thnk you're worrying too much!
01:27:40 <quicksilver> try it, and see how it goes.
01:30:20 <mmmdonuts> wy: not sure exactly what you're asking for with map, but something like this might help: vecmap f (Vector3 x y z) = Vector3 (f x) (f y) (f z)
01:34:47 <scook0> I believe there are cases in which the compiler will eliminate intermediate lists entirely
01:34:51 <scook0> though i don't know the details
01:35:22 <scook0> or is that the stuff that got pulled due to weird interactions with seq?
01:50:21 <quicksilver> scook0: intermediate lists, yes
01:50:30 <quicksilver> and no, that didn't get pulled :)
01:52:28 <notsmack> so what's the fastest way to read bytes from a file into an array?
01:52:40 <notsmack> (size known beforehand)
01:53:52 <quicksilver> :t hGetBuf
01:53:55 <lambdabot> Not in scope: `hGetBuf'
01:53:59 <quicksilver> :t System.IO.hGetBuf
01:54:01 <lambdabot> forall a. GHC.IOBase.Handle -> GHC.Ptr.Ptr a -> Int -> IO Int
01:54:05 <quicksilver> probably
01:54:16 <quicksilver> although you would need a way to view your array as a Ptr
01:54:23 <quicksilver> what kind of array is it?
01:54:40 <notsmack> quicksilver: i've been playing around with different types
01:54:46 <notsmack> UArray currently
01:56:01 <notsmack> right now i'm using Data.Binary and listArray on the result of sequence $ replicate size getWord16le
01:56:39 <quicksilver> I think that's fine
01:56:51 <quicksilver> it should fuse nicely, I believe
01:58:08 <notsmack> i'm seeing about 0.7 seconds for 262144 elements
01:59:27 <quicksilver> notsmack: hmm. 0.7 seconds for 512k is slow isn't it.
01:59:49 <quicksilver> I suspect you could mess around with ForeignPtrs and get faster than that.
01:59:51 <notsmack> quicksilver: seems it to me, though i haven't tried a naive C yet
02:00:08 <quicksilver> 512k is a bit small, the constant overhead might dominate
02:00:18 <quicksilver> might be more interesting to see bigger sizes.
02:00:32 <quicksilver> dons has talked about Data.Binary throughput of around 20MB/sec
02:00:41 <notsmack> huh
02:00:57 * notsmack double checks that adding -O dropped it to 0.03
02:01:39 <notsmack> seems to be the case
02:01:44 <moobax> what's the best way to topologically sort a DAG in a pure language? pass around a Set of visited nodes?
02:02:08 <notsmack> must not have been fusing by default?
02:09:45 <quicksilver> notsmack: ah! -O2
02:09:48 <quicksilver> notsmack: always -O2
02:10:01 <quicksilver> notsmack: don't ever expect code to run fast without -O :)
02:10:13 <notsmack> quicksilver: noted.  thanks.
02:10:19 <bparkis> ok so i made query-pointer timeout after 1 second, result is that now that it has failed again, it is timing out _every_ 1 second and never getting the mouse position
02:10:29 <quicksilver> notsmack: in particular, fusion doesn't happen without -O
02:11:02 <bparkis> aside from that everything is normal, the ball is moving and all (slowly, 1 frame per second) but not responding to mouse
02:13:23 <bparkis> so at some point there is some change in state that makes query-pointer always fail
02:14:01 <bparkis> I have not been able to trigger this behavior deliberately, it happens after waiting a certain amount of time (5 or 10 mins)
02:20:54 <bparkis> http://pastebin.com/m21d0086d
02:25:42 <bparkis> oh, whoops
02:25:43 <bparkis> wrong channel
02:33:10 <quicksilver> bparkis: I did wonder what you were talking about :)
02:55:18 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/sandiego_saneblidzeumblehaskell.pdf
02:55:19 <lambdabot> http://tinyurl.com/3c7e63
02:55:25 <Syzygy-> My slides for the AMS meet. Comments appreciated.
03:11:52 <nnxx> How to disable the GHC scheduler?
03:11:57 <quicksilver> what do you mean?
03:12:16 <quicksilver> what is the scheduler doing that you want to disable?
03:12:22 <nnxx> I'm running a non-threaded program, and according to both the GCC profiler and google-perftools, the Haskell scheduler is taking 20% of cputime
03:12:40 <nnxx> I have a Haskell wrapper around tight C numerical code..
03:12:47 <nnxx> and I don't want the GHC runtime wasting time
03:12:55 <quicksilver> It might be accounting garbage collection time to the scheduler
03:12:58 <nnxx> I've tried signal() and setitimer(), but it doesn't seem to help
03:13:00 <quicksilver> I can't think what else that could be
03:13:24 <nnxx> almost 20% is accounted to handleTick
03:14:19 <nnxx> strings doesn't find timer_create, so I assume it's using SIGALRM
03:15:29 <quicksilver> nnxx: I think it must be GC time. The scheduler isn't doing anything else.
03:15:35 <nnxx> (one of the official precompiled tarballs)
03:15:41 <quicksilver> (in singlethreaded code tehre is nothing to schedule!)
03:16:01 <quicksilver> if JaffaCake wanders in, he may have better answers for you.
03:16:04 <nnxx> I don't care what it is doing, but for some reason the ghc runtime seems to be invoked constantly during my C code
03:16:10 * JaffaCake is here
03:16:24 <quicksilver> JaffaCake: read up 10 lines or so and see if you can help.
03:16:29 <puusorsa> should i update to 6.8 already?
03:16:37 <puusorsa> or does it still have a lot of problems
03:17:23 <nnxx> yeah, 6.8 btw here
03:18:08 <JaffaCake> nnxx: hmm, I'm not sure what the problem could be
03:18:32 <JaffaCake> there is a timer interrupt that fires every 1/50s, but it's tiny
03:18:39 <JaffaCake> you can turn it off with +RTS -V0
03:18:48 <nnxx> let's see..
03:18:50 <JaffaCake> (that might be 6.8 only, I can't remember)
03:19:52 <nnxx> I did try some values for -V I think, but it didn't help much then
03:20:26 <JaffaCake> is this with or without -threaded?
03:20:47 <nnxx> I've been testing both
03:21:03 <nnxx> But it seems gone now, with -V0 and non-threaded
03:21:23 <JaffaCake> with -threaded, GHC will do a background GC if it thinks the systme is idle
03:22:04 <JaffaCake> that might happen if you've been in C for a while, I guess
03:22:05 <nnxx> I would be nice if there was some way to tel it to disable the timer interrupt for particular C functions, or something
03:22:49 <JaffaCake> you can disable the idle GC with +RTS -I0
03:22:53 <nnxx> there is something to collect (I do generate a rather big matrix in Haskell that I pass to C, and there's garbage from that process)
03:22:58 <quicksilver> It sounds like a bug if the timer interrupt can ever use 20% CPU time
03:22:59 <nnxx> but it shouldn't consistently take 20% cputime
03:23:04 <nnxx> no matter how long I run
03:23:17 <quicksilver> that would mean it runs ever 1/50s and takes 1/250s = 4ms to run each time.
03:23:30 <JaffaCake> also try  +RTS -sstderr and if the figures match up
03:23:42 <JaffaCake> and *see* if the figures match up
03:24:12 <JaffaCake> quicksilver: I'm sure it doesn't take that long!
03:24:17 <quicksilver> well exactly
03:24:19 <quicksilver> I'm sure too :)
03:24:32 <quicksilver> which is why nnxx's report seems odd
03:25:08 <nnxx> I get nothing in stderr
03:25:08 <JaffaCake> I bet the profiler has mis-attributed it
03:25:27 <JaffaCake> profilers tend to get confused by GHC-compiled code
03:25:35 <nnxx> the thing is, both GCC -pg and google perftools say the same
03:25:46 <nnxx> the latter is based on sampling and could make mistakes, but..
03:26:05 <JaffaCake> it might be relying on symbol table information that isn't correct
03:26:18 <nnxx> could be
03:26:39 <nnxx> maybe I should try to test with -V0 and without, with deterministic data..
03:26:40 <JaffaCake> did you compile the runtime with -pg too?
03:26:49 <nnxx> not at the moment
03:27:10 <JaffaCake> I've done it before, but got dubious results
03:27:27 <JaffaCake> I'm currently using oprofile BTW
03:28:02 <JaffaCake> oprofile is hard to use, but the results look reasonable
03:29:38 <nnxx> is that a code profiler?
03:29:48 <nnxx> the examples seem to be about system commands
03:29:52 <quicksilver> nnxx: you should compare total runtime as well as the profile output
03:30:03 <quicksilver> to see if you're actually "saving" time
03:30:09 <quicksilver> rather than just moving it around the profile :)
03:30:10 <nnxx> quicksilver: yeah, that's what I said above..
03:30:16 * quicksilver nods
03:30:24 <quicksilver> wasn't sure what you meant, but yes :)
03:33:45 <Sizur> @hoogle lexeme
03:33:46 <lambdabot> Text.ParserCombinators.Parsec.Token.lexeme :: TokenParser st -> CharParser st a -> CharParser st a
03:33:46 <JaffaCake> nnxx: yes, oprofile can profile code too
03:33:46 <lambdabot> Text.Read.Lexeme :: data Lexeme
03:33:46 <lambdabot> Text.Read.Lex.Lexeme :: data Lexeme
03:34:14 <JaffaCake> nnxx: it gives you source code annotated with % time by line
03:34:27 <JaffaCake> amongst other things
03:35:51 <nnxx> that would be nice
03:37:45 <matveev> I wonder what would a haskellish implementation of fromInt :: Int -> Double look like? Surely not as simple as \ x -> x + 0.0
03:38:03 <b_jonas> matveev: fromIntegral
03:38:26 <b_jonas> > (fromIntegral (-3 :: Int)) :: Double
03:38:28 <lambdabot>  -3.0
03:39:00 <matveev> that is hardwired, I wonder how one could have implemented that
03:42:34 <b_jonas> @src fromIntegral
03:42:34 <lambdabot> fromIntegral = fromInteger . toInteger
03:42:42 <b_jonas> that way :)
03:42:53 <matveev> :-)
03:43:55 <matveev> @src fromInteger
03:43:56 <lambdabot> Source not found. It can only be attributed to human error.
03:44:45 <nnxx> Well, a few runtime tests show that the difference is closer to the 2% than 20%..
03:44:47 <Vq^> heh, thats those machines excuse for everything :o)
03:44:51 <nnxx> -the
03:45:15 <nnxx> So I suppose the profilers get confused with how the scheduler is very often in the stack
03:45:35 <nnxx> Well, at least -V0 helps focus it out..
03:57:09 <quicksilver> matveev: well you can't implement it without answering some questions aout how Int and Double are implemented.
03:57:28 <quicksilver> matveev: it turns out that 'fromInteger' is a fundamental method of the Num class in haskel
03:57:36 <quicksilver> matveev: so fromInteger is the basic thing that makes that work.
03:59:33 <Sizur> @hoogle whiteSpace
03:59:34 <lambdabot> Text.ParserCombinators.Parsec.Token.whiteSpace :: TokenParser st -> CharParser st ()
04:01:39 <Sizur> @hoogle many
04:01:40 <lambdabot> Control.Applicative.many :: Alternative f => f a -> f [a]
04:01:40 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
04:01:40 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
04:04:36 <matveev> quicksilver: seems so, though it *is* doable without touching the representation: consider a case list with recursion fromInt 0 = 0.0; fromInt n = 1.0 + fromInt (n-1)
04:05:25 <quicksilver> matveev: do you know how the "0" in fromInt 0 works?
04:05:46 <quicksilver> matveev: that compiles to: fromInt x | (x == fromInteger 0) = 0.0
04:06:06 <quicksilver> matveev: you need the fromInteger functionality to implement these strange typeclass patterns.
04:07:51 <wy> What can I do with those parameters such as epsilon for controlling the accuracy? They used to be class variables in Java but now it seems I have to pass them in as parameters. That's too many.
04:08:34 <byorgey> wy: what function are you talking about?
04:09:13 <quicksilver> Bundle them all up into some kind of Param or Config value
04:09:24 <quicksilver> either pass them explicitly as a parameter or implicitly via a reader monad.
04:11:38 <matveev> quicksilver: thanks, good to know
04:14:37 <eljose> jk
04:15:41 <Hadaka> hello! I'm a haskell newbie and I'd like a bit of guidance on how to implement this thing I wish to do - since you are probably such a helpful lot, I'll just start explaining my problem :)
04:16:00 <scook0> go for it!
04:16:39 <Hadaka> I wish to calculate die rolls in Haskell - rolling different sided dice and evaluating results - but there's a twist
04:17:36 <Hadaka> there are (atleast) two modes in which I want to evaluate different dice rolling functions - in the first mode, I just want to get a single result out of it, with the function using as many random numbers it needs
04:18:12 <Hadaka> in the second mode, I want a list of *all* the possible results, probably in a tree of some sort so I can calculate the exact percentage chance of a result occuring
04:19:05 <Hadaka> so, I'd like something like this: roll_3d6 = do { x <- roll_die 6; y <- roll_die 6; z <- roll_die 6; return (x+y+z) } to be able to function directly in both cases
04:19:21 <wy> Why does negative number use minus sign? So I can't use something like quadSolve 1 2 -1 1e-6
04:19:53 <scook0> Hadaka: I swear there's already a library out there that does that
04:20:02 <scook0> but I'm struggling to remember the name of it...
04:20:22 <Saizan_> > let roll_die n = [1..n] in do { x <- roll_die 6; y <- roll_die 6; z <- roll_die 6; return (x+y+z) } -- the second case is easy :)
04:20:23 <lambdabot>  [3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11,12,8,9,10,11...
04:20:49 <scook0> http://web.engr.oregonstate.edu/~erwig/pfp/
04:20:50 <lambdabot> Title: PFP - Probabilistic Functional Programming in Haskell
04:20:51 <noteventime> Why are you using do?
04:21:07 <scook0> noteventime: for the magic of the list monad!
04:21:24 <Hadaka> Saizan_: the problem with that is that it lumps all the choices together... so I can't calculate the chances of something happening if there are cases where the die roll depends on the result of the former
04:21:35 <scook0> Hadaka: have a look at PFP
04:21:39 <Hadaka> say, roll a 6-sided die, if you get a 6, roll again
04:21:41 <Hadaka> scook0: thanks!
04:22:13 <Hadaka> scook0: w00t, that's exactly what I need :)
04:22:22 <quicksilver> Hadaka: actually you can
04:22:35 <quicksilver> > let roll_die n = [1..n] in do { x <- roll_die 6; y <-
04:22:36 <lambdabot>  Parse error at end of input
04:22:37 <quicksilver> bah
04:22:39 <quicksilver> one sec :)
04:23:18 <quicksilver> > let roll_die n = [1..n] in do { x <- roll_die 6; if (x==6) then do { y <- roll_die 6; return (x+y) } else return x }
04:23:19 <lambdabot>  [1,2,3,4,5,7,8,9,10,11,12]
04:23:35 <quicksilver> Hadaka: that rolls a second dice only if the first one is 6, and shows you all possible answers :)
04:23:44 <quicksilver> Hadaka: the magic of monads lets you do precisely that.
04:23:50 <scook0> Hadaka: hmm, there's also ProbabilityMonads on hackage
04:23:58 <quicksilver> (however, as it stands it doesn't calculate relative probability)
04:24:10 <scook0> which claims to be similar to PFP
04:24:14 <Hadaka> quicksilver: the relative probability is what I exactly need
04:24:29 <quicksilver> Hadaka: yes, you need a slight enhancement to the list moand to get the probabilities as well.
04:24:34 <ivanm> quicksilver: now write the general case, so that _whenever_ you roll a 6 you get another go :p
04:24:39 <Hadaka> quicksilver: that's why I thought I needed nested lists or a tree or something so I can calculate the probabilities later
04:24:59 <Hadaka> scook0: thanks, I'll take a look at that as well
04:25:09 <quicksilver> > let roll_die n = [1..n]; let score = do { x <- roll_die 6; if (x==6) then do { y <- score; return (x+y) } else return x }
04:25:10 <lambdabot>  Parse error at "let" (column 26)
04:25:21 <quicksilver> > let roll_die n = [1..n]; score = do { x <- roll_die 6; if (x==6) then do { y <- score; return (x+y) } else return x } in score
04:25:22 <lambdabot>  [1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,31,32,33...
04:25:26 <quicksilver> ivanm: like that?
04:25:38 <ivanm> dammit, I forgot lambdabot truncated results :s
04:25:52 <ivanm> quicksilver: but yes, like that :p
04:25:57 <ivanm> or, the easier way:
04:26:02 <ivanm> > enumFrom 1
04:26:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:26:03 <ivanm> :p
04:26:05 <quicksilver> Hadaka: yes. A small modification to the list monad would store the probability of all the current possibilities.
04:26:10 <quicksilver> ivanm: no, because 6 is not possible.
04:26:12 <Hadaka> ivanm: not true
04:26:17 <ivanm> oh, yeah, whoops :s
04:26:25 <ivanm> need to filter it for multiples of 6
04:26:34 <quicksilver> Hadaka: and then subsequent events would "multiply" their probability by the "current" probability.\
04:26:46 <quicksilver> Hadaka: and you'd be able to use do syntax like I did, and get weighted answers.
04:26:57 <Hadaka> quicksilver: well, actually, I tried to do that once myself - but I couldn't get it right
04:26:58 <quicksilver> I suspect the web pages you were pointed to do exactly that kind of thing.
04:27:02 <quicksilver> but I haven't read them :)
04:27:03 <ivanm> > filter ((/=) 0 . flip mod 6) $ enumFrom 1
04:27:04 <lambdabot>  [1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,31,32,33...
04:27:14 <Hadaka> quicksilver: but I think the probabilitymonads things that got linked to me will be quite sufficient for me
04:27:19 * quicksilver nods
04:35:38 <noteventime> Is it possible to have multiple type classes in the type of a function. If yes, what's the syntax?
04:36:39 <noteventime> example :: Foo a, Bar b => a -> b <- something like that
04:37:11 <noteventime> or Foo a => Bar b ->
04:37:20 <scook0> example :: (Foo a, Bar b) => a -> b
04:37:27 <scook0> is what you're looking for
04:37:31 <noteventime> Ahh, thanks :-)
04:38:08 <b_jonas> :t Map.!
04:38:09 <lambdabot> parse error on input `Map.!'
04:38:13 <b_jonas> :t (Map.!)
04:38:14 <lambdabot> Couldn't find qualified module.
04:38:20 <b_jonas> :t (Data.Map.!)
04:38:20 <lambdabot> forall k a. (Ord k) => Data.Map.Map k a -> k -> a
04:39:16 <psi> kaka :) that means cookie in swedish.
04:39:59 <Syzygy-> KAKA!
04:40:42 <b_jonas> but type variables are greek letters really
04:40:55 * firefly prefers "kage"
04:41:16 <quicksilver> Hadaka: http://hpaste.org/4590
04:41:33 <quicksilver> Hadaka: there you go. It was quite simple to write.
04:41:51 <quicksilver> Hadaka: it might be more useful to "collect up" values with the same result, of course
04:42:33 <roconnor> Wow, proving correctness is great motivation to break up code into modular pieces.
04:44:17 <Hadaka> quicksilver: woo! great, thanks, very educational
04:44:54 <xsdnyd> hi
04:45:06 <Hadaka> quicksilver: I will do the "collecting up" in a later step, it's more logical there anyway
04:46:07 <roconnor> xsdnyd: hi
04:47:28 <byorgey> roconnor: heh, I'll bet =)
04:47:48 <xsdnyd> i want to implement a Trie for a dictionary. Now i don't have an idea how to store the character in an edge in haskell... if i store the character in the node itself it is redundant. also if how do i choose which node i should take? since if i don't have edges i would have to check each node... :-\
04:48:18 <quicksilver> Hadaka: http://hpaste.org/4590#a1
04:48:22 <quicksilver> Hadaka: there's a version of 'collect'
04:48:39 <quicksilver> Hadaka: not that collect doesn't work on all Prob a; it only works if Ord a, since it does it by sorting.
04:49:24 <quicksilver> Hadaka: actually this is a *really* good example of what monads are for
04:49:40 <quicksilver> Hadaka: your question "what if I want a later dice roll to depend on an earlier one?"
04:49:46 <quicksilver> Hadaka: that gets right to the heart of it
04:49:55 <quicksilver> Monads are all about computation where later steps can depend on earlier steps.
04:50:36 <b_jonas> xsdnyd: umm,
04:50:43 <b_jonas> why is storing in the node redundant?
04:50:49 <roconnor> byorgey: I started working on defining and proving correct my Riemann integral and the Riemann-Stieltjes integral just fell out.
04:51:24 <byorgey> roconnor: cool.  what's a Riemann-Stieltjes integral?  I've heard of it but never studied it.
04:51:33 <roconnor> http://en.wikipedia.org/wiki/Riemann-Stieltjes_integral
04:51:34 <lambdabot> Title: Riemann-Stieltjes integral - Wikipedia, the free encyclopedia
04:51:35 <b_jonas> thoguh I might have a different kind of trie in mind than you
04:51:53 <roconnor> byorgey: it allows me in integrate with respect to point masses
04:52:26 <xsdnyd> um. mhh ok perhabs not really redundant, but if i have "hello" then how do i know which node do i have to take? i have to check each node if the character if 'h' and then take this way? that seems inefficient
04:52:28 <roconnor> byorgey: acutally I only have Riemann-Stieltjes for monotonic functions g, but this is exactly what you get when g is a cumlative distribution function
04:53:03 <byorgey> roconnor: ok, neat.
04:53:05 <xsdnyd> sorry for my poor english
04:53:18 <scook0> quicksilver: the PFP paper has a nice example of solving the Monty Hall problem
04:53:30 <b_jonas> you have to check each children of the root, not all nodes in the whole tree
04:53:37 <scook0> you can type firstChoice and firstChoice >>= switch, and see what the winning probabilities are
04:53:53 <roconnor> byorgey: not to mention the zillions of monads I've created :D
04:54:25 <xsdnyd> b_jonas: mhh ok. is this the right way for a trie? or does there exists another faster way?
04:54:29 <Toxaris> xsdnyd: you begin at the root. the root has a child for every letter of the alphabet. you take the 'h' child. now you're again at the root of a tree and have to search the node for "ello". so you take the 'e' child. and so on.
04:54:38 <quicksilver> scook0: cool
04:54:55 <b_jonas> I don't know. I don't do tries.
04:55:50 <xsdnyd> Toxaris: mh ok. i will try that. thank you all :)
04:56:19 <Toxaris> xsdnyd: the speed / memory efficiency depends on how you implement "contains a child for every letter of the alphabet". you could use an Char-indexed array. (very good speed, huge memory usage. consider unicde...), or you could use some clever data structure (consider Data.Map).
04:57:03 <Hadaka> quicksilver: here's the code where I *tried* to do the same as you some months back - http://hpaste.org/4591 - it didn't quite turn out so well :)
04:57:13 <xsdnyd> Toxaris: cool. i will look at Data.Map
04:57:53 <byorgey> Hadaka, quicksilver: If you abstract away the 'Double' as another type parameter to Prob, you can get nice Rational probabilities: http://hpaste.org/4590#a2
04:59:57 <byorgey> roconnor: zillions, eh? ;-)
05:00:00 <Toxaris> byorgey: but with Rational, you're storing [(p1 % n, v1), (p2 % n, v2), ... (pk % n, v3)]. wouldn't it be better to store only one n?
05:01:20 <byorgey> Toxaris: 'better' in what sense?  I don't know, maybe.  IMO that seems a lot more complicated for no reason. =)
05:02:45 <Toxaris> byorgey: resource usage. maybe allows to add integers instead of multiply rationals
05:05:58 <Toxaris> byorgey: but that makes mostly sense with uniform distribution
05:08:08 <quicksilver> Hadaka: :)
05:08:12 <quicksilver> Hadaka: learning experience, I guess
05:08:38 <quicksilver> Hadaka: easier to re-use [] that reinvent it, I suppose
05:08:45 <quicksilver> Hadaka: I didn't have to re-write concat, map etc
05:08:54 <Hadaka> quicksilver: yeah, I just couldn't figure a way how to re-use it there :)
05:09:06 <quicksilver> byorgey: yes, of course
05:09:08 <quicksilver> byorgey: I was being lazy
05:09:22 <quicksilver> byorgey: actually, Rational would have been a more intelligent kind of lazy, really :)
05:09:45 <Hadaka> quicksilver: the Prob/unProb is obvious and I've seen it plenty of times before, I just didn't think of it :)
05:09:55 <quicksilver> Toxaris: if you've got lots of dependent bits, then definitely not
05:10:09 <quicksilver> Toxaris: most of them won't have the same denomiator, and it's costly to go back and remultiply everything
05:11:05 <quicksilver> byorgey: your version gives much more pleasant results, not to mention more accurate :)
05:11:09 <quicksilver> for the dice example, at least
05:13:10 <wy> any suggestions for a good name for a dot product operator?
05:15:08 <Vq^> how about 'dot'?
05:15:18 <quicksilver> wy: .*. ?
05:15:28 <pjd> (Â·)
05:15:33 <quicksilver> or just .*
05:15:40 <b_jonas> heh
05:15:47 <quicksilver> I would probably use .*. for vector . vector
05:15:53 <Vq^> dot is what GSLHaskell uses
05:15:54 <quicksilver> and *. for matrix *. vector
05:16:02 <b_jonas> what about `mp`
05:16:05 <quicksilver> then you can use .* for vector .* matrix
05:16:12 <wy> isn't (.) composition?
05:16:13 <quicksilver> if you ever want left-multiplication like that
05:16:24 <quicksilver> yes
05:16:32 <quicksilver> hence I suggest .* .*. and *.
05:16:55 <quicksilver> and perhaps *** for cross-product, if you want that. Arrows lib uses *** but it's not that common.
05:16:56 <wy> hmmm .* seems to be good
05:17:06 <quicksilver> I'd use .* for matrix .* vector
05:17:10 <quicksilver> because it's asymmetrical
05:17:16 <wy> read char by char: dot, product
05:17:16 <quicksilver> and matrix-vector is asymmetrical
05:17:19 <b_jonas> or (<>) for dot product and (><) for cross product
05:17:21 <quicksilver> well that's true
05:17:51 <wy> b_jonas:  ah that's nice looking :-)
05:18:21 <quicksilver> yeah, it is actually
05:18:32 <quicksilver> You could then use *> and <* for matrix/vector
05:18:55 <b_jonas> or what about some combination using +
05:19:04 <b_jonas> like +* +.* +/* +/.*
05:19:51 <b_jonas> and of course you can shadow (.) or (*) locally
05:23:15 <wy> hmmm sometimes really miss Matlab
05:25:39 <b_jonas> I use J which is good for matrix calculations so I only miss matlab for the obscure statistical library functions like
05:25:53 <b_jonas> but I've done all my statistics courses so I no longer need those
05:33:44 <wy> b_jonas:  There is certain advantages of overloading function names with different types. I feel hard to find names ;-)
05:34:38 <Toxaris> class OneOperatorToRuleThemAll a b c where $!Â§? :: a -> b -> c
05:34:48 <b_jonas> haskell overloads function names too, it just does it sneakily by finding some obscure category theory result that shows those types are fundamentally the same
05:35:12 <oerjan> @remember Toxaris class OneOperatorToRuleThemAll a b c where $!§? :: a -> b -> c
05:35:12 <lambdabot> Done.
05:37:16 <oerjan> i'm sure Toxaris's operator is known in category theory as an object in the magmaoid category over a,b,c, or something.
05:38:12 <b_jonas> I guess it already exists
05:38:18 <b_jonas> @hoogle a -> b -> c
05:38:19 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
05:38:19 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
05:38:19 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
05:38:32 <b_jonas> meh
05:39:17 <Toxaris> b_jonas: ad-hoc polymorphism != universal polymorphism
05:39:42 <Toxaris> b_jonas: my operator is ad-hoc polymorph, it means something else for every choice of types
05:40:00 * oerjan finds some pleasure in the fact that most people, even on this channel, would not know that he made up nonsense on the spot there.  Including himself.
05:40:32 <oerjan> ddarius possibly excepted :)
05:40:47 <jive> Oerjan's Maxim
05:41:01 <Toxaris> oerjan: isn't it clear from the context?
05:41:12 <oerjan> ok possibly.
05:41:20 <oklopol> very clear
05:41:24 <Toxaris> b_jonas: but you've searched for universal polymorph operators, wich mean the same thing for all choices of types
05:41:34 <quicksilver> oerjan: an object (or indeed arrow) in a suitably general category would end up being universally polymorphic
05:41:48 <quicksilver> oerjan: which woudl that have the same objection as b_jonas's hoogle search :)
05:41:54 <oerjan> ok quicksilver possibly excepted too :D
05:42:00 <quicksilver> parametricity =~= naturality
05:42:42 <Toxaris> what I like about this channel is that you talk some nonsense, and someone will give you sensible information back
05:42:59 <oerjan> i see.  so overloading is in a sense incompatible with naturality.  but still monads are categorical.
05:43:26 <Toxaris> (the same happens if you talk non-nonsense, of course)
05:43:40 <Toxaris> oerjan: they are because of the monad laws
05:43:52 <Toxaris> oerjan: not every instance Monad X is
05:44:06 <oerjan> Toxaris: i hear in some channels the _only_ way to get sensible information back is to start claiming nonsense.
05:44:09 <dcoutts> @Yarr!
05:44:09 <lambdabot> Maybe you meant: arr yarr
05:44:10 <dcoutts> gentoo now has ghc-6.8.2 and nearly 70 other haskell libraries and tools that work with it
05:44:20 <xsdnyd> Toxaris: do i store the Map in every Node? (i use an IntMap for use with ord)
05:44:27 <xsdnyd> Toxaris: i mean the trie...
05:44:44 <Toxaris> xsdnyd: you could just use a Data.Map instead of your trie :)
05:45:01 <xsdnyd> Toxaris: i have to implement the trie myself...
05:45:05 <Toxaris> xsdnyd: but if you want to code a trie, you have a Map in every trie node
05:45:16 <xsdnyd> Toxaris: ok thx
05:45:56 <Toxaris> xsdnyd: the idea of a trie is: we already know how to do finite maps (a ~> b), using a trie we can make finite maps ([a] ~> b) too
05:46:12 <quicksilver> oerjan: well, it's an interesting issue and it depends which category you're trying to live in
05:46:15 <quicksilver> :t (>>=)
05:46:16 <oerjan> and infinite ones!
05:46:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:46:19 <Toxaris> xsdnyd: by combining such a finite map for every element of the key list
05:46:27 <quicksilver> oerjan: notice that that is fully polymorphic in "a" and "b"
05:46:49 <quicksilver> oerjan: that's equivalent to the underlying morphism map being natural.
05:46:54 <quicksilver> which is what you want, of course.
05:47:15 <quicksilver> the definition of a monad in category theory involves "blah blah blah... such that they are natural in .."
05:47:28 <quicksilver> the ad-hoc part is only m.
05:47:29 <wy> b_jonas:  How can I overload ordinary functions?
05:47:48 <quicksilver> and, as Toxaris points out, the ad-hocness is somewhat limited by the monad laws
05:47:52 <quicksilver> (not that they are enforced)
05:47:59 <quicksilver> wy: only methods can be overloaded.
05:48:03 <xsdnyd> Toxaris: ok thank you! i seem to get an idea ;)
05:48:11 <quicksilver> wy: if you need it to function differently on different types, you have to make it a method.
05:48:16 <b_jonas> wy: well, I said shadow
05:48:18 <b_jonas> not overload
05:48:20 <Toxaris> xsdnyd: cool! good luck with implementing
05:48:23 <quicksilver> ah
05:48:26 <b_jonas> pick an operator you don't need
05:48:28 <quicksilver> misunderstanding on my part
05:48:28 <quicksilver>  :)
05:48:32 <b_jonas> and use its name
05:48:49 <wy> quicksilver:  But they are not methods by nature
05:49:37 <scook0> you can't overload an existing non-class function
05:49:56 <scook0> but you can create a new overloaded function with the same name, and use that
05:50:06 <quicksilver> wy: confusion of terminology
05:50:13 <Toxaris> oerjan: sure infinite ones, and not only lists ... but "Generalizing generalized tries" is not really the paper for someone who never implemented a trie before...
05:50:14 <quicksilver> wy: you're talking about shadowing, not overloading :)
05:50:37 <wy> quicksilver:  What's shadowing?
05:50:48 <agl> Writing a new Cabal package I get a warning: "Could not find module `Data.Binary.Put': it is a member of package binary-0.4.1, which is hidden". Which is fine - I add binary>=0.4 to the build-depends. Now I get: "Setup.lhs: At least the following dependencies are missing:  binary >=0.4.1"
05:50:52 <agl> any ideas?
05:50:52 <scook0> > let x = 3 in let x = 5 in x
05:50:54 <lambdabot>  5
05:51:03 <agl> (ghc-pkg list also shows binary-0.4.1)
05:51:05 <scook0> wy: there's a quick example of shadowing
05:51:05 <b_jonas> scook0++
05:51:08 <b_jonas> that's shadowing
05:51:12 <oerjan> scook0: you might even manage to use the old one as an instance
05:51:12 <scook0> the inner x shadows the outer x
05:51:19 <scook0> oerjan: indeed
05:51:29 <quicksilver> wy: shadowing is just when you use the same name again in an unrelated way
05:52:08 <xsdnyd> hi
05:52:13 <xsdnyd> oh
05:52:14 <scook0> in practice, shadowing a definition involves either (a) not importing it, or (b) re-binding its name to something else in a narrower scope
05:52:27 <Hadaka> quick question still - in the ProbabilityMonad package, I get a value with 'ddist my_fun' that is of type: DDist Int, where DDist is of type DDist = MVT Prob [] and MVT is newtype (Monoid w, Monad m) => MVT w m a = MVT { runMVT :: m (MV w a) }
05:52:31 <scook0> though case (a) is not really "shadowing"
05:53:15 <Hadaka> how do I get a bleeping [MV Prob Int] out of it? :-)
05:53:28 <Hadaka> eg. just a list of the results
05:54:38 <oerjan> Hadaka: apply runMVT?
05:54:40 <quicksilver> well runMVT should give you a Prob (MV [] a)
05:54:52 <quicksilver> which might or might not be isomorphic to what you want
05:55:04 <wy> scook0:  Oh no. That's not what I want
05:55:06 <quicksilver> Prob (MV [] Int)
05:55:10 <quicksilver> indeed
05:55:52 <Hadaka> oerjan: I tried that, but for some reason the grouping of the entries disappeared that way
05:56:07 <wy> scook0: I believe there is no way to do it whenever there is type inference
05:56:12 <Hadaka> I'll take a peek in the source again to see if for some reason "show" would magic the grouping or something...
05:56:49 <oerjan> wy: (1) import the old function _qualified_ (2) create your class with the new method (3) use the qualified version to define the instance of the class method for the original type
05:56:51 <Hadaka> ah!
05:57:00 <Hadaka>   show = show . simplify . runMVT
05:57:07 <Hadaka> that explains it, thanks all :)
05:57:31 <wy> oerjan:  so that's still another name
05:57:45 <oerjan> wy: no you can use the same name for the method
05:57:47 <agl> (for those looking at the logs - the answer was to add --user to the configure command line)
05:58:08 <wy> oerjan:  Your qualifier is counted here ;-)
05:58:24 <oerjan> wy: picky, picky
05:58:54 <wy> oerjan:  sure ;-)
05:59:07 <wy> oerjan:  My code is getting uglier
06:02:47 <Toxaris> wy: you can give a new name to the old function at toplevel.
06:02:47 <Toxaris> import qualified Prelude as P
06:02:47 <Toxaris> (<*>) = (Prelude.*)
06:02:47 <Toxaris> x * y  = 1 + x <*> y
06:03:29 <Hadaka> (okay, my final problem was that for some really strange reason, Control.Monad.Distribution.Base does not export 'simplify' - even though it seems like a wildly useful function)
06:06:53 <Cin> is there some standard or common way of creating a multidimensional array?
06:07:10 <Cin> (other than having arrays of arrays)
06:07:30 <oerjan> Cin: array indices can be tuples
06:07:43 <Cin> ahh! i hadn't realised
06:08:04 <quicksilver> e.g. UArray (Int,Int,Int) Int
06:08:07 <quicksilver> 3D array
06:08:15 <oerjan> there's a type class for it, Ix :)
06:08:29 <Cin> Ix?
06:08:34 <oerjan> @instances-importing Data.Ix Ix
06:08:36 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
06:08:57 <BMeph> Cin: for I(nde)x. ;)
06:09:01 <Cin> ah
06:09:26 <Cin> very cool
06:09:28 <BMeph> Well, either that, or the module writer was a HUGE Dune fan... ;)
06:09:51 * Cin chortles
06:12:49 * BMeph scans the Array module for signs of melange...
06:14:29 <augustss> Ix is the word!
06:14:44 <augustss> @src Ix
06:14:44 <lambdabot> class (Ord a) => Ix a where
06:14:44 <lambdabot>     range           :: (a,a) -> [a]
06:14:44 <lambdabot>     index           :: (a,a) -> a -> Int
06:14:44 <lambdabot>     inRange         :: (a,a) -> a -> Bool
06:14:44 <lambdabot>     rangeSize       :: (a,a) -> Int
06:15:08 <b_jonas> BMeph: actually HHGG has "Ix" too
06:15:48 <b_jonas> (Ford's nickname)
06:16:33 <augustss> Ix, the 14th day in the Tzolk'in calendar
06:16:43 <BMeph> b_jonas: Well, now, how improbable is that? ;)
06:17:23 <b_jonas> BMeph: http://en.wikipedia.org/wiki/Ix should tell about most other meanings
06:17:24 <lambdabot> Title: Ix - Wikipedia, the free encyclopedia
06:17:50 <augustss> > range ((1,1),(3,3))
06:17:51 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
06:32:31 <Toxaris> > filter (inRange ('a', 'z')) "4h5GeD6Â§l5!5l?o$w__o. rDl%%4d3$d"
06:32:32 <lambdabot>  "helloworldd"
06:32:47 <Toxaris> Ix is nice for various purposes, not just array indexing
06:33:32 <Jomyoot> I read that haskell has no for loop?
06:33:57 <Toxaris> Jomyoot: Haskell as no loops at all. there's only recursion.
06:33:58 <Cin> toxaris: that's cool
06:34:25 <Jomyoot> Toxaris: does that make things difficult? for some time you really need for and while loop
06:34:34 <Toxaris> Jomyoot: but there are many loop-like functions ready-made to hide recursion, and you can write your own
06:34:42 <oerjan> > execWriter $ forM_ [1..10] $ tell "Don't believe everything you read. "
06:34:43 <lambdabot>  Couldn't match expected type `m b' against inferred type `()'
06:34:45 <Toxaris> Jomyoot: it makes things easier, once you know how to use it :)
06:34:53 <oerjan> bah
06:35:01 <oerjan> > execWriter $ forM_ [1..10] $ \_ -> tell "Don't believe everything you read. "
06:35:02 <lambdabot>  "Don't believe everything you read. Don't believe everything you read. Don't...
06:35:13 <Cin> hehe, oerjan
06:35:16 <Toxaris> > map succ [1, 2, 3] -- compare with a for loop, Jomyoot
06:35:17 <lambdabot>  [2,3,4]
06:35:19 <Wild_Cat> depends. Some things are more difficult, some are easier.
06:36:06 <Jomyoot> is popularity of haskell because of its academic value, or can it be general purpose too?
06:36:48 <Wild_Cat> Jomyoot: it can be general-purpose too. Some applications have been written with it. darcs and xmonad come to mind.
06:37:17 <Wild_Cat> (and though I haven't used darcs yet, I'm told it's frighteningly smart)
06:37:28 <Jomyoot> why do people put up with fact that there are no loops? There must be something else that makes up for lacks of it
06:37:59 <Cin> iteration [loops] can be implemented with recursion
06:38:05 <wy> Will ghc make simple types strict automatically?
06:38:14 <pejo> Jomyoot, why are you so fond of your loops?
06:38:26 <Jomyoot> used to loops
06:38:58 <jaa> how is function calling itself not a loop?
06:39:02 <Toxaris> Jomyoot: it's so much easier to program without loops. assembler programmer are used to goto and wonder how anyone can program with while and if.
06:39:45 <Jomyoot> what does this pure funictional programming paradigm get you?
06:39:55 <Jomyoot> when you go really pure. like. people say it's pure so it's better
06:40:00 <Jomyoot> but i don't understand why
06:40:29 <jaa> referential transparency, lazy evaluation, runtime gaurantees, easier composability/reuse
06:40:58 <Wild_Cat> Jomyoot: it makes your code easier to debug, mostly.
06:41:26 <Wild_Cat> the lack of side effects guarantees that a function will always yield the same result for a given input, no matter what.
06:41:57 <jaa> Jomyoot: re: loops: http://thedailywtf.com/Articles/No-Loop-For-You!.aspx http://osfameron.vox.com/library/post/for-loops-in-haskell.html http://varsztat.com/news/#loopy-loop http://notes-on-haskell.blogspot.com/2007/02/whats-wrong-with-for-loop.html
06:41:59 <lambdabot> Title: No Loop For You! - The Daily WTF
06:41:59 <Wild_Cat> and the laziness allows you to use infinite data structures.
06:43:01 <Wild_Cat> I'll give you that it feels *extremely* alien at first (in my case, it still does :p ). But make no mistake, it's useful.
06:43:37 <Jomyoot> what if your code consists of all these do and monads. then you have lots of state changes. then you are back to the problem with unpure planguages?
06:44:31 <Toxaris> Jomyoot: yes you are :) but the pure part of your program, even if small, will still be pure
06:44:40 <Cin> except you know which functions have state just by looking at their types
06:45:14 <Jomyoot> but you can do this in non pure languages as well though
06:45:25 <Toxaris> Jomyoot: with do-notation & the IO monad, you're embedding a statefull sublanguage into a pure language
06:45:32 <Jomyoot> well .if my code is like 80% state changes.  will I still benefit from haskell?
06:45:34 <BMeph> Jomyoot: There are many looping functions in Haskell. We just like to call it "fmap" instead.
06:45:36 <blakkino> Jomyoot, with a inpure language u can't express the idea that "this is indipendent from this"
06:45:48 <osfameron> that's more to do with really useful strong typing than it is with purity though?
06:46:02 <Toxaris> Jomyoot: and you can always try to code as much as possible in a pure way
06:46:08 <blakkino> Jomyoot, does each line of your code depend on each previous lines?
06:46:20 <Jomyoot> not all
06:46:28 <Jomyoot> interesting
06:46:35 <Jomyoot> what is the inspiration of all of this though
06:46:38 <osfameron> as in, say if in Perl a function could be declared "pure" but actually be naughty, you'd be able to reason about it just like in haskell (up until the point that the naughtiness caused subtle, hard to locate bugs...)
06:46:43 <Jomyoot> it seems many pure language uses are inspired by this purity
06:46:47 <Jomyoot> how do i be inspired too?
06:47:13 <augustss> Jomyoot: I'd be surprised if your problem requires a solution with 80% state change
06:47:40 <Wild_Cat> Jomyoot: well, Haskell is pretty much useless as a bash replacement. But the idea is that even if your code is 80% state changes, you can make the remaining 20% error-free more easily.
06:47:55 <Jomyoot> is there a haskell promoter, like how paul graham is for lisp?
06:48:04 <Jomyoot> not promoter but role model, the person who speaks out in support for the language
06:48:04 * Cin chortles
06:48:09 <Wild_Cat> (and chances are you can factor out those state changes down to 50% or less, thus making half your code proven error-free :p )
06:48:18 <Cin> jomyoot: simon peyton-jones?
06:48:23 <augustss> Wild_Cat: actually, i think Haskell is a pretty good bash replacement (but not for interactive use)
06:48:43 <Cin> jomyoot: http://blip.tv/file/324976
06:48:44 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
06:49:09 <Wild_Cat> Jomyoot: also, have a look at xmonad. It's a X11 window manager -- all about state changes. Yet it's 500 lines of very robust Haskell.
06:49:16 <pejo> Wild_Cat, you can still write pure functions that have bugs.
06:49:20 <Jomyoot> and do I get automatic .C and .H file to be included by C program if I want to access the Haskell program from C?
06:49:33 <augustss> Simon is the rock star in the Haskell world. :)
06:50:01 <sjanssen_> Jomyoot: it doesn't work exactly like that, but yes Haskell can be called from C
06:50:27 <Wild_Cat> pejo: correct. But they're easier to isolate and therefore easier to debug.
06:53:31 <Jomyoot> à¸à¸£à¸à¸à¸· à¸£à¸« à¸ ?à¸£à¹à¸à¸à¸«à¸à¸à¸° à¹à¸µà¸±à¸¦
06:53:40 <Jomyoot> Simon is a Microsoft guy?
06:54:05 <augustss> Yeah, he works at MSR Cambridge now.
06:55:00 <augustss> And sorry, I don't know Thai. :)
06:56:48 <Jomyoot> hehe
06:57:10 <Jomyoot> is there a web framework like rails in Haskell?
06:57:10 <wy> What's the equivalence of a simple for loop like for (int i=0; i<3; i++) {a[i]++} ?
06:57:29 <wolverian> Jomyoot, happs, kind of.
06:57:46 <osfameron> wy: a = map (+1) b    ?
06:57:49 <wolverian> wy, you have a mutating operator there. generally you wouldn't write that in haskell.
06:58:25 <wy> sorry. wrong example.
06:58:26 <quicksilver> b = map (+1) a
06:58:28 <quicksilver> would be closer :)
06:58:44 <osfameron> rarr!
06:58:45 <wy> I don't need to mutate it, I just need to index it. It's not a list
06:58:46 <doserj> what if a has more than 3 elements? :)
06:59:22 <oerjan> wy: a[i]++ means mutation
06:59:35 <augustss> wy: if it's an array: fmap (+1)
06:59:39 <wy> oerjan: I know. My example is contrived
06:59:43 <wolverian> wy, arrays have the indices function
07:00:00 <quicksilver> perhaps:
07:00:11 <quicksilver> map (a!n) [0,1,2]
07:00:12 <wolverian> wy, (Data.Array)
07:00:23 <augustss> but indexing in an array is a bit of a failure.  you should always try to use bulk operations
07:00:25 <quicksilver> if you just want to extract 3 values from a larger array
07:00:38 <BMeph> ...unless it isn't an array, either. 8*O
07:00:40 <wy> a is some home made data type, and I'm not just doing operation on each entry
07:01:23 <Toxaris> wy: you can map over the indices, if you really want to
07:01:27 <oerjan> > M.unionWith (+) (M.fromList [(i,i*i)| i <- [0..10]]) (M.fromList [(i,1)| i <- [0..2]])
07:01:30 <lambdabot>  fromList [(0,1),(1,2),(2,5),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),...
07:01:36 <augustss> wy: well, we can't really answer how to do it for your home made data structures without knowing them
07:02:02 <Toxaris> > let data = "hello world" in map (data !!) [0 .. length data - 1]
07:02:03 <lambdabot>  Parse error at "data" (column 5)
07:02:03 <wy> augustss: It's just data Vec3 = Vec3 {vec3_x,vec3_y,vec3_z :: !Double}
07:02:13 <Toxaris> > let dat = "hello world" in map (dat !!) [0 .. length data - 1]
07:02:14 <lambdabot>  Parse error at "data" (column 54)
07:02:16 <Toxaris> > let dat = "hello world" in map (dat !!) [0 .. length dat - 1]
07:02:17 <lambdabot>  "hello world"
07:02:18 <wy> vecRef :: Int -> Vec3 -> Double
07:02:18 <wy> vecRef 0 = vec3_x
07:02:18 <wy> vecRef 1 = vec3_y
07:02:18 <wy> vecRef 2 = vec3_z
07:02:25 <wy> My homemade index functions
07:02:53 <augustss> wy: but when would you want that.  it looks like a dangerous function.  it can go wrong
07:03:18 <Toxaris> wy: vecToList vec = map (flip vecRef vec) [0, 1, 2]
07:03:32 <wiedenmann> I am very new to haskell and read haskell for C Programmers <http://www.haskell.org/~pairwise/intro/section1.html> I installed hugs and tried some examples, but the simplest things dont work because of my non knowledge, can you help me plase? "Hugs> int a" "ERROR - Undefined variable "a"" and "fib :: Int -> Int" "ERROR - Undefined variable "fib""
07:04:07 <wy> wiedenmann: Add "let" to the beginning of each definition
07:04:11 <quicksilver> wiedenmann: that first example in that document, with 'int a' is not haskell
07:04:21 <quicksilver> wiedenmann: that is given in the text as an example of what haskell is not :)
07:04:22 <oerjan> wiedenmann: you usually need to put the examples in a file and load them with :l
07:04:24 <wy> oh my...
07:04:25 <Toxaris> wiedenmann: fib :: Int -> Int is a declaration, you have to write it in a file and load it into hugs
07:04:31 <quicksilver> "I mean that the following does not happen in normal Haskell:"
07:04:51 <Toxaris> wiedenmann: hugs will only evaluate expression (like 4 + 5)
07:04:57 <quicksilver> wiedenmann: those functions are written in a way designed to go into a file.
07:05:05 <quicksilver> wiedenmann: for example, you would write the two "fib" lines into a file
07:05:08 <quicksilver> and load that into hugs
07:05:12 <quicksilver> then you could test them in hugs
07:05:19 <quicksilver> you can, also, put let in front
07:05:26 <Cin> http://hpaste.org/4592#a0 -- what's the best way to layout this function?
07:05:30 <oerjan> quicksilver: not in hugs
07:05:33 <wiedenmann> the script said taht they have an interactive prompt where you type in expressions, I thought this is the promt
07:05:43 <oerjan> unless you put .. in after
07:05:46 <wy> augustss: That's just a 3D vector and now I want to write a line-box intersection. I want to iterate over the dimensions to make it elegant.
07:06:13 <wiedenmann> should I use something else instead of hugs? I would like to have it interactive if possible.
07:06:25 <wy> Ah... I almost got it
07:06:31 <wiedenmann> wy: let int a didnt work either: "ERROR - Syntax error in declaration (unexpected `}', possibly due to bad layout)"
07:06:35 <Toxaris> wiedenmann: this is the prompt, but fib :: ... is not an expression
07:06:51 <wy> wiedenmann: Have you really read the manual?
07:06:52 <augustss> wy: hmmm, maybe.  but it looks very awkward to me
07:06:52 <wiedenmann> Toxaris: so I have to put it in a file?
07:07:19 <Toxaris> wiedenmann: basically, yes. you can also use ghci wich allows more things at the prompt, but not everything either. so you will end up writing stuff in files
07:07:32 <wy> augustss: first I'll make three lists containing the hit points for each dimension's slab... then... hehe
07:07:46 <wiedenmann> wy: maybe I missed some points in the manual
07:07:54 <wiedenmann> Toxaris: okay I will do so then
07:08:21 <Toxaris> wiedenmann: that "int a" bit is not Haskell. It looks much more like c to me.
07:08:23 <wy> wiedenmann: Try "1+2.4" first
07:10:09 <quicksilver> Cin: I don't think it matters much
07:10:13 <byorgey> Cin: I would use the second.
07:10:18 <augustss> wy: explicit indexing is evil.  :)  You should only use it at the lowest level and the use higher level operations
07:10:19 <quicksilver> Cin: I would do any of those, depending how long that line was getting
07:10:34 <quicksilver> Cin: I try to keep my lines under 80 chars, as a personal preference.
07:10:57 <byorgey> Cin: except I would move the comma after [0..xw-1] onto the next line, lined up under the |
07:11:05 <Toxaris> > accumArray undefined 0 (0, 3) []
07:11:06 <lambdabot>  array (0,3) [(0,0),(1,0),(2,0),(3,0)]
07:11:18 <byorgey> Cin: but yeah, in this case I think it's mostly personal preference.  Do what you think is the most readable.
07:11:32 <wy> augustss: Indexing is still nicer than using names "x" "y" and "z". I guess I know how to do it now. That's even nicer.
07:12:20 <mightybyte> What's the technical reason that ghci and hugs don't allow you to do everything at the interactive command line?
07:12:27 <augustss> wy: yes, but why not use things like dot products and vector products, etc etc
07:12:49 <osfameron> mightybyte: misplaced mathematical consistency?  Whatever the reason it's utterly annoying to the point of being broken.
07:12:59 <mightybyte> Is it because any interactive interperter is by default in the IO Monad?
07:13:05 <Cin> byorgey, quicksilver: yeah, the first was my original and it seems readable but it's quite long -- is moving the comma onto the next line a style i might apply to all my code?
07:13:17 <wy> augustss: box is quite discontinuous...
07:13:21 <Philippa_> mightybyte: that, plus mutual recursion's a PITA in that setting
07:13:35 <Toxaris> what would be the meaning of typing "foo : Int" at an interactive prompt?
07:13:37 <wy> augustss: I'm trying to write a full featured ray tracer
07:14:01 <blakkino> wy, u know someone with the nick falsifian?
07:14:02 <blakkino> :)
07:14:20 <wy> ?
07:14:21 <mightybyte> Being used to python-like interpreters, it was strange coming to haskell and not being able to do everything in the interpreter.
07:14:28 <byorgey> Cin: sure.  I find the comma-at-the-beginning style nice because it's harder to forget them that way, especially when adding new elements to a list.
07:14:30 <Cin> quicksilver: i think i have seen that style applied to module exports
07:14:37 <Cin> byorgey: ahh, good point!
07:14:44 <byorgey> Cin: yup, you can use it there too
07:14:54 <blakkino> wy, nothing.. sorry
07:14:57 <Cin> three times just before i've missed commas on my lists
07:15:01 <byorgey> hehe
07:15:10 <byorgey> plus, I just think it looks nicer for some reason. =)
07:15:14 <Cin> hehe
07:15:35 <quicksilver> osfameron: I don't htink it's mathematical consistency, no
07:15:42 <quicksilver> ease of implementation, I suspect :)
07:15:56 <quicksilver> the 'easiest' thing to do is make the top-level just an expression evaluator.
07:16:11 <quicksilver> ghci does something slightly more sophisticated, and makes the top-level an IO do block
07:16:13 <mightybyte> I'll just throw out the comment that I think it would have been helpful to me when I first started haskell if I had seen an explanation (or at least a notification) that code typed into an interpreter is fundamentally different from code in a file.
07:16:30 <quicksilver> mightybyte: "fundamentally different" sounds a bit strong?
07:16:48 <mightybyte> quicksilver: Well, that's how it came across to me as a newbie.
07:16:49 <quicksilver> the interpreter evaluates pure expressions and executes IO actions.
07:16:56 <quicksilver> maybe that could be spelled out better.
07:16:59 <mightybyte> ...the realization that some things couldn't be done in the interpreter.
07:17:07 <mightybyte> Yes
07:17:18 <BMeph> How does it work with code in Emacs' haskell-mode?
07:17:26 <quicksilver> osfameron: defining data type incrementally would be fairly tricky, for example.
07:17:31 <quicksilver> BMeph: they're loaded as files.
07:17:57 <mightybyte> I will grant that this might be hard to explain since at that point most newcomers don't know about Monads yet.
07:18:19 <quicksilver> I don't think you need to know about monads to understand that an IO action is something that does some IO :)
07:18:47 <mightybyte> True, but that in itself wouldn't be immediately significant to the reader.
07:18:51 <Toxaris> the point is not about pure expression vs. IO action, but about expression vs declaration
07:18:58 <Cin> hmm. shouldn't the 'raw' view on hpaste be 'text/plain' and not 'text/html'?
07:19:04 <wy> augustss: I see. To convert everything directly, I just need to make the original code a function Int->Result, and map that on the list [1,2,3] ;-)
07:19:08 <Toxaris> maybe for (some) newbies this distinction isn't clear?
07:19:19 <Toxaris> (for me it was from programming language theory background)
07:19:21 <mightybyte> Toxaris: Yes, I would agree.
07:19:32 <quicksilver> Toxaris: except it isn't
07:19:40 <quicksilver> Toxaris: ghci permits you to type "foo <- readFile "bar""
07:19:47 <quicksilver> that's not a well formed expression :)
07:19:50 <mightybyte> Toxaris: Well, I knew the distinction, I just didn't quite see the justification.
07:19:54 <doserj> that's a hack :)
07:20:01 <BMeph> Cin: I think your style issue would be a lot less of an issue if you use "listArray" instead of just "array".
07:20:02 <Toxaris> quicksilver: it's not an declaration either
07:20:17 <quicksilver> Toxaris: no, it's slightly obscure syntax unit
07:20:27 <quicksilver> I think it might be called 'statement' in the formal grammar
07:20:33 <Toxaris> BMeph, Cin: have you seen my accumArray idea?
07:20:34 <quicksilver> or 'stmt' perhaps
07:20:35 <augustss> The ghci top level is pretty crappy in my opinion.
07:20:52 <augustss> It should allow anything that can be in a source file.
07:21:04 <quicksilver> would definitely be nice
07:21:07 <quicksilver> I wasn't sugesting it wouldn't
07:21:12 <quicksilver> I was just guessing at the answer why
07:21:14 <osfameron> quicksilver: ah, ok.  That's a shame, as in the simple case it would be lovely to just define simple types in the REPL
07:21:21 <quicksilver> osfameron: yes, it definitely would.
07:21:25 <mightybyte> Ayway, if this issue was addressed better, I think it would increase the ease of entry to haskell.
07:21:31 <augustss> hbi had it 15 years ago
07:21:52 <oerjan> augustss: there would be an awful mess if you intermingle expression evaluation, redefinitions, and module contents
07:22:14 <Cin> BMeph: ah... i didn't think it would create it properly with the tuple
07:22:27 <augustss> Mess is in the eye of the beholder. :)
07:22:28 <quicksilver> :t listArray
07:22:30 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
07:22:40 <psi> hbi = old haskell interpreter?
07:22:47 <Toxaris> just as you can't write an expression into a source file, you can't write a declaration into a interpreter prompt. I don't see the problem (except for telling people)
07:22:47 <augustss> psi: yes
07:22:51 <quicksilver> Cin: first param of listArray tells it the range and hence the tuple type.
07:22:52 * Cin fumbles with his shoes
07:23:04 <quicksilver> :t array
07:23:06 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
07:23:06 <Cin> emptyGrid x y = listArray ((0,0),(x-1,y-1)) [0..(x*y)-1]  -- much better!
07:23:12 <augustss> And Yale Haskell had some even better interactive features
07:23:58 <Cin> toxaris: i haven't
07:24:40 <Toxaris> > accumArray undefined 0 (0, 3) []
07:24:41 <lambdabot>  array (0,3) [(0,0),(1,0),(2,0),(3,0)]
07:24:45 <mightybyte> You could even force the use of the brace notation in the interpreter if that would simplify things.
07:24:53 <oerjan> :t accumArray
07:24:54 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
07:24:58 <BMeph> Toxaris: I saw it, I just didn't think that was what Cin was trying to do, that's all. :)
07:25:24 <augustss> hbi made you use braces if you wanted to enter mutually recursive definitions at the top level.
07:25:41 <Toxaris> BMeph: but is is, isn't it?
07:26:05 <quicksilver> augustss: of course, if you can enter full definitions at the top level, especially types, you want a convenience feature to save them out to files
07:26:11 <Toxaris> Cin: do you want zeros in your emptyGrid?
07:26:14 <quicksilver> augustss: "I like what I've just done, I want to save it"
07:26:17 <Cin> toxaris: i do!
07:26:35 <mightybyte> augustss: Yeah, then in a tutorial, you could just delay the introduction of the whitespace formatting rules.
07:26:38 <Toxaris> so your listArray solution will not work
07:26:45 <augustss> quicksilver: yes, that would be a nice things to have as well.
07:26:46 <Cin> i just realised, heh
07:26:52 <BMeph> >listArray ((0,0),(5,5)) $repeat 0
07:27:12 <quicksilver> augustss: that is an "Advantage" of the current set up, that we are forced to save things in files :)
07:27:22 <quicksilver> augustss: but it's a pretty funny kind of "advantage".
07:27:38 <augustss> I think it's just poor design :)
07:27:43 <mightybyte> quicksilver: True, but it's not an "advantage" that the newcomer cares about as much.
07:27:48 <Cin> toxaris: what is the 'undefined' part all about in your example?
07:27:57 <quicksilver> Cin: since that function never gets used, he leaves it out
07:28:23 <quicksilver> Cin: because his array is zero-length, so it just uses the 'default' number for all
07:28:31 <BMeph> Toxaris: It works in GHCi.
07:28:39 <osfameron> quicksilver: that said, I'm not sure I understand why you have to define the whole of a module (or even of a function) all in one go.  The REPL could behind the scenes take care of evaling the right source and replacing the definition en masse, if required
07:29:24 <Toxaris> Cin, quicksilver: nope, my array has the correct length, but the list of differences to the default value is zero-length, so no combination is needed.
07:29:38 <quicksilver> osfameron: it could. And it should. I was only trying to point out it's not necessarily trivial to implement.
07:30:02 <vininim>  (\ m -> let {perm n xs = (head $ drop (n-1) xs):(take n xs ++ drop (n+1) xs); f 0 = perm 0; f n = (perm (div n m)) . (f (mod n m))} in sequence (f <$> [0..m^m]) [1..m]) 3 -- enumerate permutation of [1..m]
07:30:04 <quicksilver> Toxaris: I meand "because his list is zero-length", sorry :)
07:30:07 <vininim> > (\ m -> let {perm n xs = (head $ drop (n-1) xs):(take n xs ++ drop (n+1) xs); f 0 = perm 0; f n = (perm (div n m)) . (f (mod n m))} in sequence (f <$> [0..m^m]) [1..m]) 3 -- enumerate permutation of [1..m]
07:30:08 <osfameron> quicksilver: ok, fair enough.
07:30:10 <Cin> toxaris: ah, i see
07:30:11 <lambdabot> Terminated
07:30:28 <Toxaris> Cin: but BMephs idea is better anyway
07:31:15 <Cin> i don't understand it
07:31:17 <Cin> :t repeat
07:31:18 <lambdabot> forall a. a -> [a]
07:31:24 <vininim> there is no space for infinite in there
07:31:32 <vininim> *non-termination
07:31:32 <Toxaris> vinimim: you want my oneOf combinator expressed with my funcy ((<$>) . (<$>)) combinator
07:31:50 * Toxaris wonders why everyone wonders about permutations
07:32:16 <BMeph> vininim: Take him up on it - it's beautiful code. :)
07:32:18 <vininim> Toxaris:  the "mathematics" nature of haskell does that =p
07:32:46 <Jomyoot> does haskell have mysql binding?
07:33:20 <doserj> http://www.haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
07:33:23 <lambdabot> Title: Applications and libraries/Database interfaces - HaskellWiki, http://tinyurl.com/2kvjne
07:33:56 <BMeph> Jomyoot: Yes. It's http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskelldb-hsql-mysql-0.10
07:34:03 <lambdabot> http://tinyurl.com/38o9cl
07:34:51 <Jomyoot> do they work and work well?
07:35:05 <BMeph> Er, look for "Databases" on the Hackage page - http://hackage.haskell.org/
07:36:58 <Cin> ah, now i understand it
07:38:21 <quicksilver> > repeat 0
07:38:23 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:38:24 <quicksilver> It's a useful function :)
07:38:34 <quicksilver> surprising how often the stupid ones turn out to be useful
07:38:35 <Cin> hehe
07:39:10 <BMeph> quicksilver: Like my campaign to have "swap" in the Prelude? ;)
07:39:32 <SamB_XP> BMeph: where do I sign?
07:39:34 <wy> I think it would be helpful that ghc can print some information how it inferred the types. Sometimes error messages are quite remote from the error.
07:39:35 <quicksilver> you mean swap :: (a,b) -> (b,a) ?
07:39:56 <Cin> bmeph: is that likely to happen?
07:40:10 <quicksilver> It's easy enough to make a libraries request.
07:40:23 <BMeph> Exactly - or maybe make it strict, like it's used in the Arrow module.
07:40:23 <quicksilver> Just write it up, put it in a trac ticket, send write-up to libraries@haskell.org
07:40:31 <b_jonas> @src swap
07:40:31 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:40:40 <quicksilver> I've never wanted swap, I must admit
07:40:42 <psi> id is one function that i was perplexed by as a beginner
07:40:43 <BMeph> @src (***)
07:40:43 <lambdabot> f *** g = first f >>> second g
07:40:52 <psi> like, what the hell is the point?
07:40:55 <BMeph> @src second
07:40:56 <lambdabot> Source not found. I am sorry.
07:40:59 <quicksilver> but equally, I'm happy with it since it's obvious what "swap" must do
07:41:01 <Toxaris> :t uncurry . flip . curry $ id
07:41:02 <lambdabot> forall a b. (b, a) -> (a, b)
07:41:06 <quicksilver> it doesn't seem likely to do anything else.
07:41:07 <BMeph> @src Control.Arrow.second
07:41:07 <lambdabot> Source not found. Wrong!  You cheating scum!
07:41:10 <Cin> i've used id a few times >_>
07:41:35 <doserj> > uncurry (flip (,)) (3,5)
07:41:36 <lambdabot>  (5,3)
07:41:39 <oerjan> > (snd&&&fst) (1,2)
07:41:41 <lambdabot>  (2,1)
07:41:45 <BMeph> It's actually declared as: swap ~(a, b) = (b, a)
07:42:02 <quicksilver> BMeph: that doesn't make it stricter, it makes it lazier.
07:42:03 <psi> sure, it can be useful for higher order functions, but at first it looks pointless :)
07:42:27 <quicksilver> I prefer oerjan's version :)
07:42:29 <BMeph> It's in a where-clause in the definition of second. Ah, lazier, even better! :)
07:43:25 <Cin> quicksilver: so do things that people want get added to the prelude, or do people have to wait years like in other Languages That Shall Not Be Named?
07:43:40 <quicksilver> You don't often see things added to the prelude
07:43:45 <quicksilver> But things get added to the base libraries all the time
07:43:50 <quicksilver> Data.List, etc.
07:43:53 <Cin> cool
07:44:11 <oerjan> the Prelude is a bit special because it has no hierarchical name
07:44:34 <Toxaris> oerjan: and I thought it is special because it is imported by default.
07:44:38 <oerjan> i believe they are quite strict that the non-hierarchical names contain _only_ H98 functions
07:44:56 <oerjan> i.e. Data.List contains extra things, List doesn't
07:47:02 <oerjan> which may make it very hard to get things added to the two modules Prelude and Numeric which have no alternative names...
07:47:29 * oerjan is spouting his vague impression again
07:48:01 * byorgey makes tsk-tsk noises at oerjan
07:49:00 <b_jonas> oerjan: doesn't the Numeric have no hierarchical name only because no-one wanted to add a non-H98 export to it yet?
07:49:18 <oerjan> heh, that may be possible
07:51:56 <b_jonas> Data.Natural sounds like a natural alternative name to me
07:52:40 <oerjan> except that's not what Numeric is all about
07:52:49 <oerjan> it has floating point things too
07:52:57 <b_jonas> Data.Numeric I mean
07:53:07 <b_jonas> doesn't it only have formatting and reading functions for floats?
07:53:23 <b_jonas> maybe it should be Data.NumFormat
07:53:54 <oerjan> Text.Numeric :)
07:54:04 <quicksilver> Num.Eric
07:54:20 <b_jonas> ah yeah
07:54:45 <oerjan> hm actually fromRat doesn't quite fit that
07:55:26 <b_jonas> Data.Numeric.Misc
07:55:33 <b_jonas> or Data.Arithmetic
07:55:39 <Toxaris> > Numeric.floatToDigits (negate 3) 12.454
07:55:39 <b_jonas> no, that's no good either
07:55:41 <lambdabot>  ([-1,-2,-2,-3,-2,-2,-1,-3,-3,-3,-3,-1,-3,-3,-1,-1,-1,-2,-3,-1,-2,-3,-1,-3,-1...
07:58:37 <Toxaris> is there some design document explaining the top-level of the hierarchical module namespace? e.g. why is it Control.Applicative but Data.Foldable?
07:58:46 <Sizur> @hoogle (Integral a) => a -> b -> [b]
07:58:47 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
07:59:51 <quicksilver> Toxaris: as far as I know, no :)
08:01:58 <malcolmw> Toxaris: http://www.haskell.org/hierarchical-modules/libraries/libraries.html
08:02:03 <lambdabot> http://tinyurl.com/3dqccb
08:04:11 <Toxaris> malcolmw: thanks, interesting
08:05:28 <Toxaris> so Data.* is basically Misc.*
08:05:41 <Toxaris> "Libraries which provide data types, operations over data types, or type classes, except for libraries for which one of the other more specific categories is appropriate."
08:06:48 <Toxaris> what can a library provide except "data types, operations over data types, or type classes"? maybe type class instances and operations over (bounded) polymorph values, but I think they're included here, too
08:07:04 <quicksilver> Toxaris: it can provide something more specfic :)
08:07:12 <quicksilver> for example, it might provide a database link
08:07:23 <quicksilver> whilst, evidently, that will include data types and operations etc
08:07:33 <quicksilver> it is not primarily that. It is primarily a database link.
08:07:44 <quicksilver> that does leave Data as a catch-all, I totally agree.
08:07:57 <quicksilver> Intuitively I understand why Data.Foldable but Control.Applicative.
08:08:14 <quicksilver> Foldable is a property of conventional data strutures, like Tree and List, which aids data processing.
08:08:20 <quicksilver> Applicative is a discipline for ordering effects.
08:08:25 <quicksilver> Which is a control-flow kind of thing.
08:09:05 <Toxaris> but haskell expresses control flow through data dependencies, what's the point of seperating Control and Data then?
08:09:22 <quicksilver> I don't really think that
08:09:24 <quicksilver> 's true.
08:09:35 <quicksilver> It may be that evaluation order is controlle dby data dependencies.
08:09:43 <quicksilver> but control flow is not the same thing as evaluation order.
08:09:48 <quicksilver> Exceptions are control flow.
08:09:58 <quicksilver> They have little to do with data dependencies or evaluation order.
08:10:58 <Toxaris> quicksilver: ok I see what you mean
08:11:25 <Heffalump> I don't think it's worth worrying too much about the specific choice. One or the other had to be picked, where for many things either would have been logical.
08:11:39 <quicksilver> as another example, if I fire three packets at three different servers, I wish to control what order those events happen in.
08:11:46 <quicksilver> evidently they are IO events.
08:11:55 <quicksilver> Both the IO Monad and the IO Applicative would let me choose the order.
08:12:09 <quicksilver> In neither case would data dependencies be involved in any obvious way.
08:12:34 <Toxaris> but Control.Applicative let's me express actions as data, and Data.Foldable let's me use data structure as control structure
08:12:42 <quicksilver> that is absolutely true
08:12:47 <quicksilver> I don't deny there is overlap
08:13:01 <quicksilver> I'm just saying, I *do* have an understanding of why they are that way around :)
08:14:10 <Toxaris> yes ok I see. from an instance-writer pov, it's makes perfectly sense. my type is an Applicative if it's provide's special control flow features, and Foldable if it's provides data handling features
08:15:02 <Toxaris> (sorry for unneeded "'s"s)
08:15:51 <Toxaris> well, it doesn't matter, the names are short enough that i can simply remember them
08:16:25 <quicksilver> After all, lists are in Data.List, and yet lists are also a Monad :)
08:16:45 <quicksilver> in Data.List we focus on them as data structures, whilst their Monad instance shows how they can model choice
08:17:06 <Toxaris> and their Foldable instance show how they can model loops
08:17:14 <quicksilver> indeed
08:17:25 <quicksilver> although their foldable instance is rather trivial, in a sense
08:17:30 <SamB_XP> wait, Foldable can fold more than one way?
08:17:32 <quicksilver> since they are the very most natural model for loops :)
08:17:54 <quicksilver> in fact, "toList" is sufficient to define foldable
08:17:59 <quicksilver> that's not a very elegant way of looking at it
08:18:05 <quicksilver> but it's the only thing that is needed
08:18:22 <psi> I don't think I've programmed haskell for over a year now. I'm always too tired when I get home. Does anyone have have suggestions for a project?
08:18:49 <SamB_XP> psi: are you working or still in school?
08:18:54 <psi> working
08:19:25 <SamB_XP> I guess "do it over the summer" isn't a great suggestion, then...
08:19:47 <oerjan> quicksilver: actually it is quite elegant once you realize lists are the free monoid
08:20:38 <psi> well, I do have vacation, but that's half a year away
08:20:41 <quicksilver> oerjan: right.
08:20:57 <quicksilver> oerjan: lists are the free monoid, and foldable is about monoid homomorphisms
08:20:58 <psi> there are holidays coming up now, though :)
08:21:08 <quicksilver> oerjan: and all monoid homormorphism factor through the free monoid
08:21:21 <oerjan> Q.E.D.
08:21:44 <quicksilver> oerjan: I thought ot adding that observation to the wiki page but I thought it might put some people off
08:22:22 <quicksilver> psi: pick something you find fun!
08:22:29 <quicksilver> psi: 3D graphics?
08:22:35 <quicksilver> functional music?
08:22:39 <quicksilver> a game?
08:22:41 * quicksilver shrugs
08:23:14 <psi> functional music - what's that?
08:24:30 <dozer> hi
08:24:37 <quicksilver> combinators for producing harmonic music
08:24:37 <psi> I'd like to learn more about the theory of music... maybe there's something I could do.
08:24:48 <dozer> is ghci known to segfault while deguggign, or is it just me?
08:24:50 <quicksilver> see, e.g. http://www.linusakesson.net/music/functional/index.php
08:24:52 <lambdabot> Title: Functional music
08:24:56 <psi> thanks
08:25:44 <quicksilver> psi: the web page is broken bu tht elink to the lhs file works
08:26:29 <quicksilver> psi: also http://www.youtube.com/watch?v=eLS6GHXWMpA
08:26:30 <lambdabot> Title: YouTube - hacking haskell music
08:27:11 <psi> quicksilver: yeah, i saw. the lhs file looks excellent at a first glance. it's exactly the stuff i wanted to learn about music anyway.
08:28:31 <sjanssen_> dozer: are you doing anything that could make it your fault?  (bad FFI code, unsafe array read/writes, etc.)
08:29:23 <dozer> sjanssen_: this is vanilla haskell
08:29:48 <vininim> id is usefull for foldr (.) =P
08:30:10 <sjanssen> dozer: seems worthy of a bug report if you can narrow it down
08:30:18 <psi> quicksilver: wow, cool video. is it from the same guy that wrote that lhs file?
08:30:32 <dozer> sjanssen: it happens when I'm stepping through, but not when its running in ghci
08:30:52 <dozer> sjanssen: and it runs without crashing from the command-line, or in ghci if there are no break points
08:31:11 <dozer> or if I go to the break point and then just let it run to completion
08:31:13 <sjanssen> dozer: yep, sounds like information GHC HQ is interested in
08:31:46 <quicksilver> psi: I'm not sure, actually :) It is cool, isn't it?
08:31:54 <dozer> sjanssen: but short of making a tarball with all the source and input files etc. I don't know how to testcase it
08:36:45 <SamB_XP> dozer: well, even that *might* be helpful...
08:51:28 <Sizur> :t parse
08:51:30 <lambdabot> Not in scope: `parse'
08:51:52 <Sizur> :t Text.ParserCombinators.Parsec.parse
08:51:52 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
08:54:37 <Sizur> how can I get out from the parsec monad? my compiler complains "Couldn't match expected type `m a'"
08:55:04 <SamB> you have to run the parser
08:55:08 <Sizur> I did
08:55:16 <Sizur> and checked against Either
08:55:21 <SamB> eh?
08:55:38 <Sizur> oh wait, sorry, I call fail
08:55:49 <Sizur> ofcourse
08:56:17 <SamB> yeah, as soon as you said "and checked against Either", it sounded like it wasn't anything to do with parsec ;-)
08:56:25 <Sizur> I guess I cannot get out until I resolve errors
08:56:47 <Sizur> that's nice :P
08:57:06 <SamB> it's just that fail only works in monads
08:57:16 <Sizur> yeah, and it's wise to do so
08:57:41 <Sizur> heh, ghc has just debugged me
08:58:39 <dankna> I have the distressing feeling sometimes ghc is more Turing-complete than I am
08:59:44 <osfameron> ?
08:59:46 <SamB> turing complete?
09:00:32 <osfameron> What is home without Plumtree's potted meat? ;-)
09:01:26 <BMeph> osfameron: Er, fresher-smelling? ;)
09:01:28 <dankna> SamB, never mind, attempt at humor.
09:01:53 <dons> ?users
09:01:53 <lambdabot> Maximum users seen in #haskell: 434, currently: 393 (90.6%), active: 11 (2.8%)
09:02:04 <osfameron> BMeph ;-)
09:02:20 <SamB> well, it fell flat here because I don't like programming turing machines, I guess
09:02:38 <Heffalump> do you mean "more capable of passing a Turing test"?
09:08:57 <dons> whoa,
09:08:59 <dons> Thu Dec 20 03:13:00 PST 2007  simonpj@microsoft.com * Implement generalised list comprehensions
09:09:14 <monochrom> scary
09:09:17 <dons> i didn't think i'd see it.
09:09:21 <dons> and its not monad comprehensions :(
09:09:31 <quicksilver> ;)
09:09:44 <quicksilver> I'm surprised SPJ is so enthusiastic about those.
09:09:50 <quicksilver> but, whatever floats his boat!
09:09:51 <dons> however, i do have some uses for sql these days .. hmm.
09:10:04 <dons> custom syntax, not an edsl. wacky stuff :)
09:10:06 <glguy> link?
09:10:06 <ndm_> i think wadler was threatening to go down and watch him implement them
09:10:45 <monochrom> hahaha
09:10:57 <dons> he did! at the HW
09:11:11 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/25373
09:11:12 <ndm_> yep, did he actually have to go down though?
09:11:13 <lambdabot> Title: Gmane -- Mail To News And Back Again
09:11:24 <dons> so i'm not sure how much spj endorses this feature, actually
09:11:42 <ndm_> i'm 100% dubious about it
09:11:57 <dons> power/weight ratio is all wrong
09:12:02 <ndm_> agreed
09:12:09 <ndm_> and things like "the" just feel all wrong
09:12:11 <dons> i mean, we're considering not adding parallel zip comprehensions
09:12:17 <dons> much cleaner, simpler, yet still no-go.
09:12:31 <ndm_> with parallel comps the human desugaring is trivial
09:12:36 <dons> yep.
09:12:42 <ndm_> with these, a human would find it very difficult to replicate
09:12:59 <ndm_> the feature i hate most is that inserting a line changes the types of successive lines transparently
09:13:14 <dons> mm
09:13:52 <ndm_> anyway, thats not to say once they are in they won't turn out to be great, but i can imagine the commit message removing them already
09:13:58 <dons> heh
09:15:30 <dankna> Heffalump, no, I actually meant it the way I said it, but perhaps it only makes sense if you're me ....
09:16:42 <Nafai> Modius: Hello fellow Austinite!
09:18:14 <Gwern-away> @pl foo a b = io $ a b =<< getSelection
09:18:14 <lambdabot> foo = (io .) . flip flip getSelection . ((=<<) .)
09:18:24 <shag> is there a way to import something from a module which is not exported by that module but i know it is in there?
09:18:47 <monochrom> No. It is not in there.
09:19:07 <shag> (i know, that is evil, but i want to check some structure with unit tests)
09:19:14 <shag> hm
09:19:22 <quicksilver> this is a common annoyance
09:19:26 <quicksilver> (for testing)
09:19:36 <quicksilver> somebody maintain separate #ifdef'ed export lists
09:19:39 <quicksilver> for testing
09:19:47 <shag> and what's the common workaraound?
09:19:47 <quicksilver> some people put all their tests in the same module
09:19:48 <shag> ah
09:20:51 <shag> but then you have to export your tests to actually execute them which is generally not really good.
09:22:06 <quicksilver> I run tests from the ghci shell
09:22:15 <quicksilver> having loaded the module itself
09:22:23 <quicksilver> I grant you, this is not terribly scalable :(
09:22:43 <shag> but i need something like "make test" that gives me a test result
09:22:58 <quicksilver> you can run ghci from a make rule
09:23:04 <quicksilver> perhaps with a simple wrapper to parse the result
09:23:36 * ddarius starts a petition to remove the "generalized" list comprehensions.
09:23:53 <shag> i think i will try the ifdef thing. but i hoped to leave ifdef behind me in the c-world forever ... ;)
09:24:14 <quicksilver> shag: well, one not-stupid idea is to equip all your modules with "run_tests :: IO ()"
09:24:36 <quicksilver> shag: then you run that from a makefile as "ghc -e Foo.run_tests Foo.hs"
09:25:00 <monochrom> Here is how certain unexported things are completely unusable from the outside. Some compilers take the liberty to inline unexported functions and then the functions themselves are discarded - disappeared from the top level. So it doesn't exist, you can't test it.
09:25:11 <sjanssen_> quicksilver: cluttering the namespace isn't particularly nice
09:25:32 <quicksilver> sjanssen_: I'm not sure run_tests is very much namespace clutter, is it?
09:25:38 <quicksilver> call it _run_tests if you like
09:25:45 <shag> but that still means i have to define my tests inside the module itself, doesn't it?
09:25:52 <sjanssen_> shag: while ghc can't access unexported names, ghci can
09:25:52 <quicksilver> yes, that's true
09:26:04 <quicksilver> I quite like defining tests inside the module
09:26:12 <quicksilver> because I can put them near the functions they are testing
09:26:24 <doserj> even better to define your test in haddock comments :)
09:26:25 * ddarius isn't sure why you wouldn't want to do it the way quicksilver suggests.
09:27:06 <shag> quicksilver: yes, i know the pro's of putting them into the module itself and i've gone through that discussion already. we decided to have seperate test modules ... :)
09:27:56 <quicksilver> could you be persuaded to do an Internal split?
09:28:05 <quicksilver> have Foo, Foo.Internal, Foo.Tests
09:28:12 <quicksilver> Foo imports Foo.Internal but doesn't export it
09:28:17 <quicksilver> Foo exports the public interface
09:28:23 <quicksilver> Foo.Tests imports Foo.Internal
09:28:31 <quicksilver> and therefore has access to everything, for testing purposes.
09:28:46 <shag> hm. that sounds quite good
09:28:58 <quicksilver> that's quite "heavyweight". But then, tests is separate file is a "heavyweight" style solution :)
09:29:10 <shag> hehe
09:29:12 <nolrai> @ty either
09:29:14 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
09:29:24 <puusorsa> but that has no runtime cost, right?
09:29:46 <shag> despite putting the tests into the module itself, that sounds like the cleanest solution to me.
09:30:41 <desegnis> Sometimes I'm still annoyed by lambdabot's habit of putting quantified type variables into order of appearance in the type.
09:31:23 <shag> quicksilver, thanks for the tip, i think  i can figure something out now :)
09:31:27 <quicksilver> ;)
09:31:33 <shag> tips, even
09:31:42 <oerjan> i'm quite sure i was confused earlier today when lambdabot _didn't_ have a consistent order.
09:32:13 <oerjan> @pl a (b,c) = a b c
09:32:14 <lambdabot> a = fix ((`ap` snd) . (. fst))
09:32:23 <oerjan> oops
09:32:27 <oerjan> @pl f a (b,c) = a b c
09:32:28 <lambdabot> f = (`ap` snd) . (. fst)
09:32:35 <oerjan> :t (`ap` snd) . (. fst)
09:32:36 <lambdabot> forall b a b1. (a -> b1 -> b) -> (a, b1) -> b
09:32:41 <oerjan> :t uncurry
09:32:42 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:33:37 <oerjan> desegnis: the first one doesn't follow that order
09:34:18 <desegnis> yea I see, now trying to see the idea behind the bot's customs
09:35:21 <Gwern-away> @pl promptSearch searchEngine browser config = mkXPrompt Search config (getShellCompl []) $ io . (searchEngine browser)
09:35:22 <lambdabot> promptSearch = ((flip (flip (mkXPrompt Search) (getShellCompl [])) . (io .)) .)
09:35:34 <byorgey> desegnis: I don't think it's anything to do with lambdabot in and of itself, it's to do with ghci.
09:36:00 <desegnis> byorgey: It's that black box for me anyway
09:36:21 <quicksilver> does LB use ghci?
09:36:22 <byorgey> and IIRC the type that gets displayed tries to follow any names used in the type signature given when the function was defined.
09:36:52 <byorgey> well, maybe ghc instead of ghci, I don't know exactly
09:37:08 <byorgey> just that it's not like someone sat down and coded type inference in LB from scratch =)
09:38:01 <oerjan> @pl y f = (\x -> f(x x)) (\x -> f(x x))
09:38:02 <lambdabot> y = ap (. join id) (. join id)
09:38:27 * Toxaris always believed ghc is just a small wrapper calling lambdabot over the network
09:39:23 <osfameron> or a little mini lambdabot clone living somewhere in your cpu
09:39:27 <byorgey> Toxaris: that's right, and lambdabot calls ghc.  The complex behavior you see emerges as the least fixed point. =)
09:47:11 <dcoutts_> dons: pong
09:47:26 <dcoutts_> @seen dons
09:47:26 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 33m 28s ago.
09:59:33 <shag> i have several errors in my unit tests like "Ambiguous type variable `a' in the constraints: `Show a' arising from a use of `assertEqual' `Eq a' arising from a use of `assertEqual'" and GHC suggest to add a type signature but i have no clue where i should add a signature?
10:00:12 <shag> i am creating the tests with TestCase (assertEqual "foo" ...)
10:01:26 <Toxaris> assertEqual "foo" ([] :: [Int]) []
10:01:31 <Toxaris> maybe like this?
10:03:53 <malcolmw> dons: do you have any objections if I take on the nobench project and make some updates, publish a new repo, etc?
10:04:48 <shag> Toxaris: aah! thanks alot! i didnt know that i could add a signature there ...
10:05:23 <gabrielmc> Is there some standard way to dynamically load modules at runtime?  I have a directory 'C[3
10:05:26 <gabrielmc> oy
10:05:41 <Cale> gabrielmc: You can do it with hs-plugins.
10:06:27 <Cale> gabrielmc: ...but it's not exactly something to be taken lightly.
10:07:49 <puusorsa> am i imagining things or is 6.8.2 a lot faster than 6.6.1?
10:08:41 <desegnis> puusorsa: There's something in the release notes about faster compilation.
10:09:02 <puusorsa> hooray!
10:09:10 <gabrielmc> I have a series of sequentially numbered directories, each of which has a 'Core.hs' file inside, with a predefined set of functions/lists to be used.  In Java, I would have an interface and a simple dynamic loader to search the directories for the particular number and then load the code in that directory.  Is such a thing possible in Haskell?
10:09:47 <bos> gabrielmc: you need something like hs-plugins
10:09:55 <wolverian> or ghc-api
10:10:19 <byorgey> gabrielmc: is the amount of code/lists in each directory large enough that you wouldn't want to have it all in memory at once?
10:11:18 <gabrielmc> Well, that's my problem.
10:11:54 <byorgey> right.  ok, just checking. =)
10:12:13 <gabrielmc> I don't want to hand code/mess with cabal (if it's possible) to generate the file necessary to lookup the right module to load.
10:12:49 <byorgey> gabrielmc: what determines which module should be loaded?
10:12:57 <byorgey> (just OOC)
10:13:05 * bos builds a fedora package for haddock 0.9
10:13:26 <gabrielmc> Size may not be an issue, but irritation, laziness, and a want of elegance makes me think something better might be available.
10:13:42 <gabrielmc> The files are loaded according to a command line switch.
10:14:06 <gabrielmc> app -i <NUMBER>
10:15:08 <byorgey> I mean, if size isn't really an issue, then why not just import all the modules in the first place?  It shouldn't be all that hard to select among a bunch of *already loaded* modules at runtime, given a suitable framework.
10:15:29 <gabrielmc> Indeed, but laziness....
10:17:20 * desegnis is disappointed that he needed minutes to prove that (`ap` snd) . (. fst)  =  \f x -> f (fst x) (snd x)
10:19:01 <gabrielmc> I don't want to have to write [...(2, (C02.function, C02.list, C02.otherFuncton), ... (34, (C34. function, C34.list, C34.otherFunction)...] and keep that up to date every time I decide to add/remove a module.  Just seems very messy and unnecessary -- and I suppose I could PrettyPrint a solution using cabal, conceivably, but that seems like another maintenance/uggification/duplication.
10:19:06 <desegnis> (Well, including the time I needed to discover what to prove)
10:20:38 <gabrielmc> another -> more
10:22:17 <ddarius> desegnis: All you do is eta-expand and beta-reduce and repeat.
10:22:58 <Cale> gabrielmc: Why are you numbering modules?
10:23:32 <Cale> gabrielmc: Modules should probably be broken into logical units based on what they contain.
10:23:55 <gabrielmc> They are all essentially the same.
10:24:20 <desegnis> ddarius: Yea, the transition itself is easy. But I couldn't get my head around that expression without writing it down and practice that primitive Greek.
10:24:40 <Cale> gabrielmc: hmm
10:24:43 <gabrielmc> The only differ in the features that they offer -- it's very much an interactive, test-it-out kind of thing
10:26:03 <dcoutts_> dons: I'm off, email me with whatever it was
10:29:07 <desegnis> ddarius: Could I profit from explicitly learning things like  f . (.g)  =  \h -> f . h . g  (and other combinations of (.))?
10:31:54 <gabrielmc> Ok, since the dyn-load thing won't pan out, another question: can one have Cabal perform compilation in 2 steps?  (1) Compile and run a single file executable that generates another haskell file in the main source directory that cabal (2) then compiles along with the rest of the stuff?
10:35:10 <xEpicFailGuyx> Hi, can anyone tell me why foldr works with infinite lists?
10:36:28 <monochrom> It depends on which operator you give to foldr.
10:36:41 <monochrom> For example foldr (+) will still not work.
10:36:43 <ricky_clarkson> > foldr (||) [True,True..]
10:36:43 <lambdabot>  Parse error at "True...." (column 18)
10:36:57 <ricky_clarkson> > foldr (||) False [True,True..]
10:36:57 <lambdabot>  Parse error at "True...." (column 24)
10:36:59 <xEpicFailGuyx> hm
10:37:09 <desegnis> > foldr (||) False (repeat True)
10:37:10 <ricky_clarkson> > foldr (||) False $ repeat True
10:37:12 <lambdabot>  True
10:37:12 <lambdabot>  True
10:37:19 <desegnis> true.
10:37:21 <xEpicFailGuyx> Which kind would work?
10:37:46 <monochrom> non-strict in the second parameter.
10:37:59 <xEpicFailGuyx> ok
10:38:07 <xEpicFailGuyx> I'll take a look at it then
10:38:13 <BMeph> > foldr (||) [True,True,...]
10:38:14 <lambdabot>  Parse error at "...]" (column 23)
10:38:21 <monochrom> foldr (||) False (repeat False) will not work.
10:38:25 <BMeph> > foldr (||) [True,True,..]
10:38:26 <lambdabot>  Parse error at "..]" (column 23)
10:38:51 <xEpicFailGuyx> Very curious...
10:39:58 <dmwit> > foldr (||) [True,True..]
10:39:58 <desegnis> xEpic: The reason is that you get (False || (True || (True || (True ....)...)))
10:39:58 <lambdabot>  Parse error at "True...." (column 18)
10:40:00 <monochrom> foldr (:) is an example that works because (:) is non-strict in the second parameter.
10:40:22 <desegnis> xEpic: And that is True once you get to the first True in there
10:40:35 <monochrom> Yes, for (||), if you happen to give True to its first parameter, then suddenly it ignores the second parameter.
10:40:37 <ddarius> You need a space, it's parsing True as a module name
10:40:48 <dmwit> > foldr (||) False [True,True ..]
10:40:49 <lambdabot>  True
10:40:52 <dmwit> sneaky
10:41:11 <ricky_clarkson> Hmm, crappy parser alert?
10:41:13 <xEpicFailGuyx> I'm a n00b but I'm starting to like Haskell a lot
10:41:19 <ricky_clarkson> > [True,True..]
10:41:20 <lambdabot>  Parse error at "True...." (column 7)
10:41:21 <ricky_clarkson> > [True,True ..]
10:41:22 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
10:41:24 <dmwit> ricky_clarkson: Yes, your error-message parser is crappy. =)
10:41:30 <ricky_clarkson> Heh.
10:41:34 <xEpicFailGuyx> I can't imagine such a kind response from the Lisp community
10:41:44 <ricky_clarkson> I dislike unnecessary whitespace.
10:42:12 <monochrom> That's because Haskell defines both types and kinds. :)
10:42:31 <BMeph> ddarius: Good catch, thank you. :)
10:42:38 <monochrom> ddarius++
10:42:55 <SamB> xEpicFailGuyx: "community"?
10:43:12 <monochrom> Please don't be picky.
10:43:34 <ricky_clarkson> I've had pretty good results from #lisp, though they're a bit tetchy about some questions.
10:43:42 <xEpicFailGuyx> The only part I'm confused about now, now that I understand the non-strictness requirement, is where a Haskell interpreter or compiler starts evaluating the expression generated by foldr
10:43:56 <xEpicFailGuyx> I mean ... it can't start in the middle, can it?
10:44:00 <monochrom> Besides, if discrete partial orders are still partial orders, then discrete community is still community.
10:44:09 <SamB> xEpicFailGuyx: the same place it starts evaluating any expression, pinky!
10:44:24 <ricky_clarkson> @src foldr
10:44:25 <lambdabot> foldr k z xs = go xs
10:44:25 <lambdabot>     where go []     = z
10:44:25 <lambdabot>           go (y:ys) = y `k` go ys
10:44:55 <ricky_clarkson> foldr (||) False [True,True ..] is the same as:
10:45:07 <xEpicFailGuyx> ricky_clarkson: I got kick-banned from #lisp because I outdid the channel op at being anal retentive and he didn't like that
10:45:09 <SamB> xEpicFailGuyx: incidentally, it generates the expression on-demand...
10:45:11 <ricky_clarkson> False || (True || (True || (True || ...)))
10:45:31 <ricky_clarkson> False || the rest needs 'the rest' to be evaluated.
10:45:43 <ricky_clarkson> the rest is True || (True || ...
10:45:51 <xEpicFailGuyx> So, the evaluation of a right-associative expression mustn't always begin on the right
10:45:58 <ricky_clarkson> True || the rest doesn't need 'the rest' to be evaluated.
10:46:01 <xEpicFailGuyx> ok
10:46:15 <xEpicFailGuyx> And foldl has to generate the whole expression
10:46:19 <xEpicFailGuyx> Period
10:46:19 <monochrom> We say "from the outside in".
10:46:22 <ricky_clarkson> > foldr (||) False [True,error]
10:46:22 <lambdabot>  Couldn't match expected type `Bool'
10:46:26 <SamB> xEpicFailGuyx: nope!
10:46:27 <ricky_clarkson> > foldr (||) False [True,undefined]
10:46:28 <lambdabot>  True
10:46:28 <SamB> er. yes.
10:46:38 <xEpicFailGuyx> lol
10:46:47 * SamB missed the l at first
10:47:02 <ricky_clarkson> Whoever mentioned lisp, I'm blaming them for me typing 'error' above.
10:47:19 <xEpicFailGuyx> I did :)
10:48:14 <doserj> foldr (||) False [True, True ..] = go (True:True:..) = True || go (True:..) = True
10:48:27 <ricky_clarkson> > fix (True ||)
10:48:28 <lambdabot>  True
10:48:32 <ricky_clarkson> > fix (False ||)
10:48:32 <lambdabot>  Exception: <<loop>>
10:48:35 <dons> task-parallel F# http://mlg.eng.cam.ac.uk/jurgen/blog/?p=6
10:48:37 <lambdabot> Title: F# and the Task Parallel Library
10:48:37 <xEpicFailGuyx> Anyway, I like the idea of lazy evaluation more than macros vs. functions because then you don't have to discern as much
10:48:46 <dons> (i.e. flat data parallelism ?)
10:48:56 <ricky_clarkson> xEpicFailGuyx: Macros are not first class, which is a problem.
10:48:57 <monochrom> I like that too. Very unifying.
10:49:46 <xEpicFailGuyx> ricky_clarkson: Yes, so then you can't pass them as arguments or anything :)
10:49:47 <SamB> yes, those things that laziness can do are really annoying to write macros for
10:50:02 <desegnis> xEpic: Evaluation of any expression can be thought of as starting at the outermost expression. So in False || (True || True), it starts at the first (||). Without infix operators, the outermost expression is always written on the very left: let f = (||) in f False (f True True)
10:50:05 <ricky_clarkson> You can make lisp lazy, of course.
10:50:15 <xEpicFailGuyx> top down evaluation
10:51:01 <dmwit> Am I just confused, or would it actually be (True || (True || (True || ... || False))), i.e. not have the False at the beginning?
10:51:17 <xEpicFailGuyx> dmwit: For foldr?
10:51:21 <xEpicFailGuyx> It would be at the end
10:51:35 <SamB> eh?
10:51:40 <xEpicFailGuyx> foldr passes the initial value downwards, yes?
10:51:49 <dmwit> > foldr ("True ||"++) "False" ["True", "True"]
10:51:49 <lambdabot>  Couldn't match expected type `b -> b'
10:51:55 <ricky_clarkson> dmwit: I think you're right, I've made that mistake before.
10:52:08 <xEpicFailGuyx> > foldr (||) False $ repeat True
10:52:09 <dmwit> > foldr (\x y -> x ++ " || " ++ y) "False" ["True", "True"]
10:52:09 <desegnis> Ah, I got this one wrong above, too.
10:52:10 <lambdabot>  True
10:52:10 <lambdabot>  "True || True || False"
10:52:20 <xEpicFailGuyx> Yeah
10:52:28 <ricky_clarkson> > foldr (||) undefined [True,True ..]
10:52:28 <lambdabot>  True
10:52:40 <xEpicFailGuyx> That's what he meant
10:52:46 <xEpicFailGuyx> (I think)
10:52:52 <dmwit> cool
10:53:07 <xEpicFailGuyx> Wow, I actually answered a question :)
10:54:07 <SamB> foldr (||) False [False, True] = False || foldr (||) False [True]
10:54:22 <newsham> all I want for christmas is ghci for freebsd/amd64
10:55:34 <SamB> newsham: what's hard about freebsd/amd64?
10:56:03 <newsham> the runtime library's dynamic linker doesnt do 64-bit relocations
10:56:12 <newsham> there are hacks to make it work on some systems like linux
10:56:18 <xEpicFailGuyx> So I take it that the expression cfold' (\x t g -> g (x:t)) [] [1,2,3] from YAHT is like foldr, except that building the list commences 'at the end', as it were
10:56:19 <newsham> (not sure how it works on openbsd, but it works there too)
10:56:48 <dmwit> :t \x t g -> g (x:t) []
10:56:50 <lambdabot> forall a a1 t. a -> [a] -> ([a] -> [a1] -> t) -> t
10:57:23 <dmwit> Where'd that a1 come from?
10:57:37 <xEpicFailGuyx> newsham: Have you considered using something like an SSH shell service? I used my SSH account when I needed to do something on Windoze in high school.
10:57:53 <newsham> how is that a solution?
10:58:02 <xEpicFailGuyx> dmwit: I'm guessing a1 just distinguishes a different type.
10:58:22 <monochrom> ssh to a platform that has ghci :)
10:58:24 <dmwit> xEpicFailGuyx: Yes, obviously.  But what's going on with that type?  How are we generating values of type a1?
10:58:24 <SamB> newsham: so, how hard is it to implement 64-bit relocations?
10:58:27 <xEpicFailGuyx> newsham: Well, say, if you logged in on a Linux box or something that supported ghci, you could do work remotely
10:58:34 <newsham> i have ghci on my laptop, mono.
10:58:37 <dmwit> oh
10:58:39 <newsham> samb: i dont know
10:58:41 <dmwit> [] :: [a1]
10:58:51 <desegnis> dmwit: The empty list is a polymorphic value.
10:58:55 <dmwit> right
10:58:59 <wy> I found that I already have (^) after I defined (+) (*) and (-) for my type of class Num. Should I define (^) just for efficiency?
10:59:23 <dmwit> Ah, and I see that example doesn't pass [] to g anyway. =P
10:59:29 * dmwit needs more sleep
10:59:31 <opqdonut> ?src (^)
10:59:32 <lambdabot> Source not found. Wrong!  You cheating scum!
10:59:38 <sjanssen_> wy: you can't, it isn't a class method
10:59:45 <opqdonut> wy: if it can be done more efficiently than iterating *
10:59:51 <dmwit> ?src Num
10:59:51 <opqdonut> sjanssen_: oh, okay
10:59:51 <lambdabot> class  (Eq a, Show a) => Num a  where
10:59:52 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:59:52 <lambdabot>     negate, abs, signum     :: a -> a
10:59:52 <lambdabot>     fromInteger             :: Integer -> a
11:00:08 <monochrom> (^) does an efficient job.
11:00:27 <wy> So I don't need to write one. Good.
11:00:43 <monochrom> How about this. (^) uses repeated squaring. I think it's efficient enough for most Num's.
11:01:19 <wy> I guess using exp instruction for Double would be faster?
11:01:46 <monochrom> (**) uses exp and log.
11:02:41 <dmwit> Will getArgs ever return a list with "" as an element?
11:03:02 <dmwit> (More to the point: is "fmap (map head) getArgs" safe?)
11:03:16 <monochrom> No.
11:03:41 <monochrom> More precisely, "" is possible.
11:03:46 <dmwit> =/
11:03:46 <allbery_b> on unix I can explicitly pass an argument "" (or '')
11:03:47 <wy> monochrom: Strange ** is also power
11:04:10 <wy> :t (**)
11:04:11 <lambdabot> forall a. (Floating a) => a -> a -> a
11:04:17 <monochrom> In a good unix shell, invoke your program with: yourprogram "" ''
11:04:19 <allbery_b> shell parses empty quotes and passes an empty argument.
11:04:26 <wy> So this one seems to be better...
11:05:25 <monochrom> Embrace the empty cases. Empty string, empty set, sum and product of empty sequences, empty parameters, ...
11:06:55 <Toxaris> > map (drop 1) ["xmaybe", "xlike", "xthis", "", "ddmwit"]
11:06:56 <lambdabot>  ["maybe","like","this","","dmwit"]
11:07:26 * Toxaris talks nonsense and should read better
11:07:46 <dmwit> > filter ((=="-") . take 1) ["--long-arg", "-s", "command"] -- more like what I want in the end
11:07:47 <lambdabot>  ["--long-arg","-s"]
11:08:46 <Toxaris> > filter ((=="-") . take 1) ["--already", "", "--working"]
11:08:46 <lambdabot>  ["--already","--working"]
11:14:36 <ddarius> Neither lazy evaluation nor macros get even close to subsuming the other.
11:17:51 <ricky_clarkson> You can implement lazy evaluation using macros.
11:18:05 <xEpicFailGuyx> Hm, do tell
11:18:22 <xEpicFailGuyx> Could you do, e.g., infinite structures?
11:18:41 <xEpicFailGuyx> Now that I think about, I guess so ...
11:19:01 <Toxaris> xEpicFailGuyx: everything can be infinite
11:19:20 <Toxaris> dmwit: did you consider System.Console.GetOpt?
11:19:24 <xEpicFailGuyx> Assuming you could use a macro that would make e.g., [1,..] turn into a generating function of some kind
11:19:56 <dmwit> Toxaris: overkill
11:19:57 <xEpicFailGuyx> Hell, even my current favorite language Python can do something like that :)
11:20:10 <Toxaris> dmwit: I've never used it, but it looks easy
11:20:37 <xEpicFailGuyx> Thanks so much for your support and illumination, guys
11:23:07 <dmwit> Toxaris: To give you an idea just how simple I want my option parser to be: hpaste.org/4594
11:23:19 <Toxaris> xEpicFailGuyx: by wrapping your code into a macro call you can transform it to whatever you like, including a version with thunks instead of values. (defmacro eval-lazy (code) (<<embed lisp2haskell compiler here>))
11:23:48 <Toxaris> dmwit: xchat doesn't recognize your link as a link :(
11:24:02 <dmwit> Sorry, I didn't put the protocol in front. =/
11:24:07 <xEpicFailGuyx> Toxaris: I'm not the expert yet, only 19, but I'll think about such things :)
11:24:16 <xEpicFailGuyx> have it good...
11:26:49 <Toxaris> dmwit: ok I see
11:29:08 <ddarius> ricky_clarkson: No, you can't.  Not in any sane way.
11:32:34 <EvilTerran> who needs sanity, anyway?
11:32:53 <nolrai> @pl f c (ix, a) (iy, b) = (ix, c a b)
11:32:54 <lambdabot> f = (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . const) .)) .) . flip ((.) . (.) . (,))
11:33:02 <nolrai> wow
11:33:05 <Valodim> beautiful
11:34:30 <shivernz> not entirely readable though
11:34:35 <desegnis> Speaking of sanity...
11:34:36 <earthy> ghe. this reminds me of encoding adt's in the pure untyped lambdacalculus
11:34:54 <shivernz> :t many1 digit
11:34:56 <lambdabot> Not in scope: `many1'
11:34:56 <lambdabot> Not in scope: `digit'
11:35:31 <nolrai> @pl f (ix, a) (iy, b) = (ix, (a, b))
11:35:32 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (,)) . (.) . (,))
11:36:13 <desegnis> shivernz: Parser String?
11:37:03 <nolrai> i want to zip the inside of two assoc lists, should i just write it by hand or is there some libfunction that will get me close?
11:37:15 <EvilTerran> ?type uncurry (***) . (const *** (,))
11:37:15 <lambdabot> forall b b1 b' b2. (b, b') -> (b1, b2) -> (b, (b', b2))
11:37:29 <EvilTerran> ?type \(ix, a) (iy, b) -> (ix, (a, b))
11:37:30 <lambdabot> forall t t1 t2 t3. (t, t1) -> (t2, t3) -> (t, (t1, t3))
11:37:31 <shivernz> desegnis, GenParser Char st [Char]
11:37:37 <EvilTerran> i win :D
11:38:07 <nolrai> yes you do.
11:38:25 <shivernz> what i need to do to apply readHex to the result of (many1 digit)
11:38:42 <desegnis> shivernz, right, the state is actually not restricted to ()
11:38:54 <nolrai> dont you want many1 hexDigit, then?
11:39:30 <shivernz> nolrai, nah. following an exercise.
11:39:44 <shivernz> i still don't "get" the basics
11:39:52 <desegnis> shivernz,  GenParser tok st  is a Functor instance.
11:40:04 <dmwit> ?index exitWith
11:40:04 <lambdabot> System.Exit
11:40:11 <desegnis> as well as a monad
11:40:24 <nolrai> thats a wierd exercise then.
11:40:31 <desegnis> shivernz, so you can use (<$>), (>>=) etc.
11:41:20 <nolrai> what type is readHex?
11:41:28 <desegnis> :t Numeric.readHex
11:41:29 <lambdabot> forall a. (Num a) => String -> [(a, String)]
11:42:16 <shivernz> desegnis, so something like many1 digit >>= readHex ?
11:42:27 <nolrai> "readHex `liftM` many1 digits" is what you want
11:42:54 <desegnis> ... where liftM is about the same as (<$>), which is just fmap.
11:43:12 <desegnis> you'll get a list of possible parses then, however. Not really the Parsec way
11:43:13 <nolrai> liftM f m = do {x <- m; return f x;}
11:43:59 <dmwit> What's the simplest way to hand off control to an external program?
11:44:20 <dmwit> I'm using runCommand right now, but it closes stdin before passing it off... =/
11:44:34 <desegnis> shivernz: If you want it to work like hexDigit, you'll want to check whether the parse isn't ambiguous.
11:44:41 <dons> newpopen, if you just want to run a command and get its output
11:44:49 <dons> if you only want to run it for some side effect, system
11:45:40 <dmwit> Ah, system/rawSystem seems close to what I want.
11:46:02 <shivernz> desegnis, not overly concerned. just doing the exercises to try to understand how things work (slow going)
11:47:28 <ddarius> "Sounds good. Patches can be sent via darcs."
11:47:37 <shivernz> return (many1 digit) >>= liftM(readHex)
11:47:41 <shivernz> is the same as
11:47:48 <dons> ddarius: was that ok?
11:47:54 <shivernz> readHex `liftM` many1 digit
11:47:58 <desegnis> shivernz: I'm realizing that digit will only parse 0..9, so...
11:48:00 <ddarius> dons: It was mildly entertaining.
11:48:15 <dmwit> dons: It still seems like stdin is getting closed.  I really just want to write a shell script.
11:48:39 <shivernz> desegnis, true. ill probably just change it to many (digit <|> letter)
11:50:06 <desegnis> shivernz: If you use readHex, you can let readHex do the hard work
11:50:22 <nolrai> isn't hexDigit == digit <|> oneOf "ABCDEFabcdef"
11:50:36 <shivernz> desegnis, you mean hexDigit right?
11:50:41 <dons> ddarius: i guess since there's already a ray tracer in nobench
11:50:45 <dons> he couldn't recommend that
11:50:47 <desegnis> shivernz: no
11:51:07 <nolrai> readHex is also a parser.
11:51:46 <desegnis> shivernz: but actually, if you use Numeric.readHex, then you would have inspect the result list, and then tell Parsec whether the parse was successful, and how many characters were consumed. Too much to do this way :)
11:52:59 <desegnis> shivernz: nolrai's thingy may be cleaner
11:53:48 <dmwit> http://hpaste.org/4595 # an example of the problem I'm seeing: stdin is empty during this call
11:53:52 <shivernz> desegnis, yeah. ill probably go with that
11:53:54 <desegnis> (especially if you only want the string, not the number itself)
11:55:26 <shivernz> am i right in assuming that the call to many1 or any other similar function consumes what it matches
11:55:41 <shivernz> so another call wouldn't match the same things
11:55:48 <nolrai> yes
11:56:15 <shivernz> thanks :)
11:57:42 <nolrai> why is ghc giving me a parse error at the ']' in "zipAssoc :: [(ixType, a)] -> [(ixType, b)] -> [(ixType, (a, b)]"?
11:57:52 <nolrai> oh now i see it.
11:58:45 <nolrai> i hate how some parts of haskell use camell case and some dont.
11:58:52 <byorgey> nolrai: the 'Haskell.Language.DWIM' parser module won't be included until 6.10
11:59:22 <ddarius> nolrai: ?
11:59:40 <nolrai> oh wrong spelling.
11:59:55 <dons> why we like haskell syntax...
11:59:56 <dons> http://www.flickr.com/photos/carlzimmer/1072758937/in/set-72157601351535771/
11:59:57 <lambdabot> Title: Program on Flickr - Photo Sharing!, http://tinyurl.com/ytz38b
12:00:40 <nolrai> what i hate is how its "lookup" but "putStr"
12:00:58 <ricky_clarkson> lookup is one word in English.
12:01:12 <nolrai> It is?
12:01:46 <ricky_clarkson> @go lookup wikipedia
12:01:48 <lambdabot> http://en.wikipedia.org/wiki/Reverse_DNS_lookup
12:01:48 <lambdabot> Title: Reverse DNS lookup - Wikipedia, the free encyclopedia
12:01:48 <Cale> Well, in computer-science English, anyway. :)
12:01:51 <ricky_clarkson> Gah.
12:02:03 <allbery_b> strictly speaking it's a compound word "look-up"
12:02:22 <Cale> http://en.wikipedia.org/wiki/Lookup
12:02:24 <allbery_b> welcome to the evolution of language :)
12:02:43 <nolrai> yeah and i almos always break it up i.e. he looked it up.
12:03:09 <Cale> That's different :)
12:03:21 <byorgey> yeah, you wouldn't say 'he lookupped it' =)
12:03:38 <qmrw> camelcase sucks.
12:03:40 <monochrom> lookup table
12:04:34 <nolrai> ok but the command is the verb.
12:04:50 <monochrom> I think I can't argue.
12:04:51 <Cale> lookup is usually used as a noun
12:04:55 <nolrai> oh well jargon allway gets weird.
12:05:16 <Cale> It's a nouned verb.
12:05:38 <monochrom> Latin is better.
12:05:46 <ricky_clarkson> quidquid latine dictum..
12:05:47 <nolrai> yeah that part almost makes sense.
12:06:08 <nolrai> but latin has cases. I sujust japanese.
12:06:10 <puusorsa> stupid question and not exactly haskell, but: how do i get back to previous version in darcs? or a few versions? new bytestring broke hosc and i really really need to get vocable working to show it to a friend
12:06:31 <sjanssen> puusorsa: you can use 'darcs obliterate'
12:06:47 <puusorsa> thanks
12:07:07 <pejo> sjanssen, is that very different from unpull?
12:07:16 <ricky_clarkson> I'm not complaining that you're asking here, but there is a #darcs, iirc.
12:07:22 <sjanssen> pejo: they're synonyms
12:07:55 <shivernz> another stupid question. suppose I want to do a head on the result of the the readHex function in: readHex `liftM` many1 digit
12:09:44 <puusorsa> ricky_clarkson, feels stupid to join a channel, ask a simple question with one line answer, and then part. sorry :(
12:09:51 <monochrom> a head on a number?
12:10:17 <shivernz> :t Numeric.readHex
12:10:18 <lambdabot> forall a. (Num a) => String -> [(a, String)]
12:10:33 <ddarius> puusorsa: Then you need to adjust your perceptions.
12:11:05 <monochrom> (head . readHex) `liftM` many1 digit
12:11:07 <ricky_clarkson> puusorsa: Like I said, I ain't complaining. ;)
12:11:43 <shivernz> puusorsa, feels worse to continually ask stupid questions and hang around :)
12:11:52 <shivernz> monochrom, thanks
12:11:53 <monochrom> If you furthermore want the number part in the head, (fst . head . readHex) `liftM` many1 digit
12:12:28 * SamB wonders if an R6RS stdlib would work with an R5RS interpreter
12:16:36 <Saul_> Is there a functions like fmapM, so (Monad m, Functor f) => (a -> m b) -> m a -> m (f b)?
12:17:04 <mauke> what the
12:17:16 <mauke> how can you construct a functor out of thin air
12:17:24 <sjanssen> mauke: fail "" will work here
12:17:30 <sjanssen> of course that's useless :)
12:17:44 <sjanssen> @hoogle fmapM
12:17:45 <lambdabot> No matches found
12:18:19 <sjanssen> Saul_: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Traversable.html#v%3AmapM
12:18:20 <dmwit> Saul_: Maybe you want (Monad m, Functor m) => (a -> m b) -> m a -> m (m b)?
12:18:23 <lambdabot> http://tinyurl.com/ylnfaa
12:18:47 <dmwit> :t (return .) . (>>=)
12:18:48 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m, Monad m1) => m1 a -> (a -> m1 b) -> m (m1 b)
12:19:19 <BMeph> Saul_: Did you mean (Monad m, Functor f) => (a -> f b) -> m a -> m (f b)?
12:19:36 <dmwit> That would also be reasonable.
12:19:47 <BMeph> Otherwise, the functor not showing up until the end just looks out-of-place. :)
12:19:48 <Saul_> BMeph: Yeah I did
12:19:53 <dmwit> In which case it's just (=<<).
12:19:57 <dmwit> :t (=<<)
12:19:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:20:07 <Saul_> :t mapM
12:20:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:20:20 <Saul_> But then for functors instead of lists
12:20:28 <ddarius> dmwit: There is no reason to have (Monad m, Functor m) =>
12:20:30 <mauke> Saul_: that looks like liftM
12:20:43 <dmwit> ddarius: *I* know that.
12:20:46 <BMeph> Off to drive the wife around... chat at 'yall later...
12:21:51 <Saul_> mauke: liftM is (Monad m) => (a1 -> r) -> m a1 -> m r
12:22:02 <mauke> yes
12:22:08 <mauke> where r = f b
12:22:48 <dmwit> :t liftM :: (Functor f, Monad m) => (a -> f b) -> m a -> m (f b) -- yep, it should type check just fine
12:22:49 <lambdabot> forall a (f :: * -> *) b (m :: * -> *). (Monad m, Functor f) => (a -> f b) -> m a -> m (f b)
12:23:30 <dmwit> oh
12:23:38 <monochrom> Then you're likely looking for (a -> m b) -> f a -> m (f b)
12:23:53 <dmwit> yeah
12:24:06 <monochrom> err, even, (a -> m b) -> m (f a) -> m (f b)
12:24:31 <monochrom> "m a" is pretty useless, the main point is.
12:24:57 <Saul_> Something is wrong about the type I think
12:25:08 <Sizur> @hoogle Either
12:25:09 <lambdabot> Data.Either :: module
12:25:09 <lambdabot> Prelude.Either :: data Either a b
12:25:09 <lambdabot> Data.Either.Either :: data Either a b
12:26:04 <Saul_> (Monad m, Functor f) => (a -> m b) -> f a -> m (f b
12:26:07 <Saul_> )
12:26:36 <Saul_> Ok this is what I need, sorry for messing it up (twice)
12:26:50 <monochrom> Ha, I can get "f (m b)" but not "m (f b)".
12:26:54 <Sizur> @hoogle (Either a b) -> (a,b)
12:26:55 <lambdabot> No matches, try a more general search
12:27:19 <monochrom> There is no (Either a b) -> (a,b). There is a long proof.
12:27:37 <Sizur> @hoogle (Either a) => a -> (b,c)
12:27:38 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
12:27:38 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
12:27:38 <lambdabot> Control.Monad.RWS.Lazy.evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:28:10 <Sizur> long proof doesn't sound good
12:28:25 <Saul_> Basically a mapM for for fmap instead of map (so for functors instead of lists)
12:28:56 <monochrom> It may be impossible in general, i.e., some functors cannot support it.
12:29:33 <Sizur> @hoogle (Either [a] [b]) -> ([a],[b])
12:29:33 <lambdabot> No matches, try a more general search
12:29:50 <Sizur> ah
12:30:10 <Sizur> @hoogle [Either a b] -> ([a],[b])
12:30:10 <lambdabot> No matches, try a more general search
12:30:14 <Sizur> this hsould be possible
12:30:29 <monochrom> By far, Data.Traversable.mapM is closest and possible, as sjanssen said.
12:30:55 <puusorsa> ok another stupid question: binary: efficient, pure binary serialisation using lazy ByteStrings .. can i get that t work with ghv 6.8
12:30:55 <nomeata> Doesnt (Either a b) -> (a,b) mean in logic writing: (a or b) implies (a and b), which is obviously not a tautology
12:31:14 <monochrom> Right, that's one summary of a long proof.
12:31:16 <puusorsa> wants base >=2.0&&<2.2
12:31:28 <nomeata> ok
12:31:39 <Sizur> a lost of A or B cam be mapped to a list of A and B
12:31:44 <ddarius> monochrom: Why do you we need to use a long proof?
12:31:49 <Sizur> s/lost/list/
12:31:59 <Botje> Sizur: you can use partition to separate them at least
12:32:13 <Botje> but you'd still have to remove the constructors
12:32:18 <dmwit> :t either
12:32:19 <monochrom> @type Data.List.partition
12:32:20 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:32:20 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:32:25 <Saul_> @src mapM
12:32:26 <lambdabot> mapM f as = sequence (map f as)
12:32:32 <Saul_> @src sequence
12:32:33 <lambdabot> sequence ms = foldr k (return []) ms
12:32:33 <lambdabot>     where
12:32:33 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:32:36 <monochrom> The return type is ([a],[a]) not ([a],[b]).
12:32:42 <ddarius> Sizur: Not in general.  Perhaps you meant "a pair of a list of A and a list of B"?
12:32:43 <monochrom> But you can steal the code.
12:32:43 <Sizur> right, partition is not good
12:33:08 <Botje> monochrom: that's what I meant by "separate, but you still have to remove the constructors"
12:33:22 <Sizur> yes. a lost of (a or b) can be mapped to a (list of a) and (list of b)
12:33:26 <monochrom> But you can't black-box-use partition.
12:33:47 <monochrom> Oh I see what you mean. A post-processor.
12:34:15 <Botje> yes. something like catMaybes for Either, applied to the two parts of the pair
12:34:22 <ddarius> :t (map fromLeft *** fromRight) . partition isLeft
12:34:23 <Sizur> yeah
12:34:23 <lambdabot> Not in scope: `fromLeft'
12:34:23 <lambdabot> Not in scope: `fromRight'
12:34:23 <lambdabot> Not in scope: `isLeft'
12:34:41 <Botje> no such thing as fromLeft
12:34:51 <Botje> unfortunately :)
12:34:53 <ddarius> fromLeft ~(Left x) = x
12:34:56 <dmwit> :t let f (Left x : xs) = let (ls, rs) = f xs in (x:ls, rs); f (Right y : ys) = let (ls, rs) = f ys in (ls, y:rs); f [] = ([], []) in f
12:34:57 <lambdabot> forall t t1. [Either t t1] -> ([t], [t1])
12:35:07 <Sizur> dmwit: thanks!
12:35:16 <dmwit> Now to make it a fold....
12:35:19 <Botje> dmwit: the ~ there means "trust me, i know what i'm doing", right?
12:35:28 <dmwit> Yes.
12:35:34 <Botje> yay :)
12:35:38 <byorgey> Botje: irrefutable pattern-match, yes.
12:35:39 <dmwit> It's "irrefutable".
12:35:45 <byorgey> but if it turns out not to match later...
12:35:47 <byorgey> boom!
12:35:47 <monochrom> I don't think you know what you're doing.
12:35:49 <ddarius> That's not what it means.
12:36:28 <monochrom> ~ also postpones evaluation. It gives you a lazier function.
12:36:51 <dmwit> :t foldr (\e (ls, rs) -> case e of Left l -> (l:ls, rs); Right r -> (ls, r:rs)) ([], [])
12:36:52 <lambdabot> forall t t1. [Either t t1] -> ([t], [t1])
12:37:01 <monochrom> It probably doesn't matter in this context.
12:37:13 <byorgey> :t either
12:37:13 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:38:14 <dmwit> :t foldr (\e (ls, rs) -> either (\l -> (l:ls, rs)) (\r -> (ls, r:rs)) e) ([], [])
12:38:15 <lambdabot> forall a b. [Either a b] -> ([a], [b])
12:38:18 <dmwit> yay!
12:38:42 <Sizur> dmwit: thanks mucho
12:38:58 <Botje> @pl \l -> (l:ls, rs)
12:38:59 <lambdabot> flip (,) rs . (: ls)
12:39:19 <Botje> hmmm
12:39:21 <Sizur> how to call it? collapseEither?
12:39:28 <dmwit> ?pl \r -> (ls, r:rs) -- mildly nicer?
12:39:28 <lambdabot> (,) ls . (: rs)
12:39:36 <ddarius> @djinn Either a b -> (Maybe a, Maybe b)
12:39:37 <lambdabot> f a =
12:39:37 <lambdabot>     case a of
12:39:37 <lambdabot>     Left b -> (Just b, Nothing)
12:39:37 <lambdabot>     Right c -> (Nothing, Just c)
12:39:55 <nolrai> does ghc have a debuger now?
12:39:58 <Botje> i'd have thought there'd be some nicer combinators
12:39:59 <ddarius> Yes.
12:40:21 <dmwit> ?djinn [(a, b)] -> ([a], [b])
12:40:21 <lambdabot> -- f cannot be realized.
12:40:26 <dmwit> Oh yeah, no lists.
12:40:49 <dmhouse> ?type unzip
12:40:50 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
12:40:58 <dmwit> heh
12:41:26 <byorgey> :t foldr (\e -> either (first . (:)) (second . (:)) e) ([],[])
12:41:27 <lambdabot> forall a b. [Either a b] -> ([a], [b])
12:41:40 <byorgey> :t foldr (either (first . (:)) (second . (:))) ([],[])
12:41:41 <lambdabot> forall a b. [Either a b] -> ([a], [b])
12:41:45 <byorgey> woot! =)
12:41:49 <dmwit> O_o
12:41:52 <dmwit> That's very pretty.
12:42:06 <roconnor> oh this function again
12:42:13 <byorgey> Arrows ftw!
12:42:18 <roconnor> I tried to get it added to the standard library, but I gave up
12:42:21 <roconnor> too much red tape
12:42:35 <dmwit> You couldn't even get it added to Data.Either?
12:42:41 <nolrai> it would be very nice
12:42:56 <ddarius> byorgey: Very similar to what the categorical solution would look like.
12:43:22 <byorgey> ddarius: interesting!
12:43:27 <roconnor> http://hackage.haskell.org/trac/ghc/ticket/974
12:43:32 <lambdabot> Title: #974 (Add unzipEithers, lefts, rights to Data.Either) - GHC - Trac
12:43:41 <roconnor> dmwit: what to call it, SplitEithers, unzipEithers?
12:43:53 <Sizur> collapseEither I propose
12:43:55 <profmakx> Cale, did you fix hs-plugins for 6.8.2?
12:43:56 <Sizur> Eithers
12:44:01 <roconnor> no concensus, thus no standard library.
12:44:06 <Cale> profmakx: yes
12:44:06 <nolrai> whats the [Maybe a] -> [a] called
12:44:17 <Botje> catmaybes
12:44:18 <roconnor> partitionEithers
12:44:19 <ddarius> catMaybes
12:44:28 <Sizur> yeah partitionEithers is best
12:44:32 <nolrai> partitionEithers - that i like.
12:44:38 <dmwit> ugh
12:44:41 <roconnor>     * resolution set to wontfix.
12:44:50 <dmwit> Such a minor thing to stop it from going in.
12:45:00 <roconnor> So far the least objectionable name for [Eithers a b] -> ([a],[b]) is separateEithers
12:45:19 <nolrai> not partitionEithers?
12:45:39 <nolrai> both work.
12:45:43 <olsner> untangle?
12:45:52 <profmakx> Cale  do you have a patch/darcs repo somewhere?
12:46:11 <roconnor> nolrai: it's not really a parition in the sense of the existing partition function
12:46:12 <dmwit> catEithers
12:46:16 <Sizur> untangle is good, but it also applies to quantum stuff
12:46:20 <dmwit> But any name is fine with me, really.
12:46:31 <Sizur> partitionEithers gets my vote
12:46:42 <Japsu> :o
12:46:42 <nolrai> ah then separeteEithers is maybe better.
12:46:56 <nolrai> :t partition
12:46:56 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:47:07 * byorgey thinks we should call it 'monkeyshoes' and be done with it.
12:47:33 <ddarius> chimpanzeeboots is clearly a better name.
12:47:41 <nolrai> > partition (/=a) "abbbacaad"
12:47:42 <lambdabot>   Not in scope: `a'
12:47:42 <roconnor> @check \f l -> let (a,b) = parition l in a++b == (l::[Integer])
12:47:44 <lambdabot>   Not in scope: `parition'
12:47:49 <nolrai> > partition (/='a') "abbbacaad"
12:47:49 <Sizur> elephanthighheels
12:47:50 <lambdabot>  ("bbbcd","aaaa")
12:48:05 <byorgey> ddarius: well, but it isn't really a chimpanzee in the sense of Data.Mammals.Simian.
12:48:07 <roconnor> hmm
12:48:09 <nolrai> partition is close enough
12:48:19 <roconnor> maybe I forget why partition either was disliked
12:48:57 <olsner> catLefts &&& catRights
12:49:11 <Sizur> the predicate is implied
12:49:34 <puusorsa> any way to get data.binary working with ghc 6.8.2 ?
12:49:38 <ddarius> I think we should just write inverse so that lefts, for example, would be inverse fromRight.  That would be the fibrational way.
12:49:56 <nolrai>  ?!?
12:50:00 <puusorsa> oh. it should work. nice
12:52:11 <ddarius> Wow, I totally jacked that up.
12:52:30 <byorgey> fibrational?
12:52:49 <ddarius> @google fibrations category theory
12:52:51 <lambdabot> Plugin `search' failed with: No Location header found in 3xx response.
12:53:10 <byorgey> it's either some crazy category theory term, or ddarius is going crazy.
12:53:22 <Sizur> :t partition (\x->case x of Left _ -> True; Right _->False;)
12:53:23 <lambdabot> forall t t1. [Either t t1] -> ([Either t t1], [Either t t1])
12:53:23 <dmwit> :t \es -> ([l | Left l <- es], [r | Right r <- es])
12:53:24 <lambdabot> forall t t1. [Either t t1] -> ([t], [t1])
12:53:30 <Sizur> hah
12:53:41 <Botje> the line between madness and category theory is a fine one indeed.
12:53:51 <ddarius> byorgey: It's a little from column A and a little from column B.
12:54:17 <allbery_b> @remember Botje the line between madness and category theory is a fine one indeed.
12:54:18 <lambdabot> Good to know.
12:56:40 <olsner> @quote metametastereo
12:56:40 <lambdabot> dmhouse says: Nice, metametastereo quotes. I wonder how far it'll go.
12:56:43 <Sizur> byorgey: maybe partition was disliked because (a,b) is not (a,a)?
12:56:51 <olsner> did that quote just add a meta?
12:56:56 <byorgey> Sizur: no idea.
12:57:18 <byorgey> olsner: that was a subject of quite some debate.
12:59:27 <roconnor> byorgey: apparently I was the one who objected to partitionEithers
12:59:38 <roconnor> byorgey: I thought it was kinda long
12:59:47 <roconnor> byorgey: but screw that, it's a great name!
12:59:52 <byorgey> hehe
13:00:08 <roconnor> I've given it a lot of though over the last year :P
13:00:13 <byorgey> too late, by now whoever liked that name before has probably changed their mind
13:00:32 <roconnor> ``
13:00:32 <roconnor> It appears that 95% of identifiers are between 2 and 21 (inclusive)
13:00:32 <roconnor> characters long.  So partitionEithers is not unusually long according to
13:00:32 <roconnor> this metric.
13:00:55 <Sizur> @hoogle first
13:00:56 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
13:00:56 <lambdabot> Data.Monoid.First :: newtype First a
13:00:56 <lambdabot> Data.Monoid.First :: Maybe a -> First a
13:01:17 <byorgey> Data.Monoid.First?  is that new in 6.8?
13:01:59 <roconnor> byorgey: ah you are right, after I agreed to partitionEithers, Henning Thielemann changed his mind
13:02:28 <roconnor> He thought partitionEither :: (a -> Either b c) -> [a] -> ([b], [c])
13:02:36 <roconnor> and unzipEither :: [Either b c] -> ([b], [c])
13:03:07 <Japsu> roconnor: err, that metric sucks. I can also claim that 99 % of identifiers are between 2 and 1337 (inclusive) characters long
13:03:23 <Japsu> how would that justify using an identifier of 1337 charactes?
13:03:35 <ddarius> byorgey: Presumably Just x+y = x Nothing + y = y
13:03:41 <Japsu> (not that I thought "partitionEithers" were too long)
13:04:08 * ddarius thinks we should call it partWays.
13:04:13 <Japsu> not bad
13:04:17 <roconnor> Japsu: 95% is the typical cut off point of things like this
13:04:34 <Japsu> roconnor: still, it does not tell anything of the actual distribution
13:05:09 <roconnor> Japsu: but I'm just claiming that if something happens more than 5% of the time, then it isn't unusual.
13:05:12 <ddarius> @google Zipf
13:05:27 <desegnis> @type let f = either (first . (:)) (second . (:)) in foldr f ([],[])
13:05:31 <wy> Is there a prelude function to remove an element from list?
13:05:37 <lambdabot> forall a b. [Either a b] -> ([a], [b])
13:05:48 <ddarius> wy: tail
13:05:49 <nolrai> delete?
13:05:58 <roconnor> @hoogle [a] -> a -> [a]
13:05:59 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
13:05:59 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
13:05:59 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
13:06:02 <byorgey> > delete 3 [1,2,3,4,3,4]
13:06:04 <lambdabot>  [1,2,4,3,4]
13:06:04 <roconnor> :/
13:06:05 <wy> I haven't found delete
13:06:09 <byorgey> > [1,2,3,4,3,4] \\ [3]
13:06:10 <lambdabot>  [1,2,4,3,4]
13:06:11 <Japsu> roconnor: assume I have 19 identifiers of length 3 and 1 of length 42, this matches your criteria, even though "partitionEithers" would still be considered exceptionally long
13:06:15 <byorgey> wy: it's in Data.List
13:06:23 <wy> Thanks
13:07:08 <Japsu> anyway, this is irrelevant
13:07:48 <desegnis> D'oh, bad eyes of mine...
13:08:23 <Japsu> hmm, that foldr (either left right) based solution in the first patch seems pretty elegant to me
13:09:21 <roconnor> http://hpaste.org/4596
13:09:22 <sjanssen> Japsu: gotta love the catamorphism
13:10:12 <Japsu> ...err, what's a catamorphism
13:10:23 * Japsu is happily ignorant of category theory
13:10:54 <ddarius> catamorphism isn't a categorical term.
13:11:27 <sjanssen> Japsu: foldr and either are catamorphisms on [] and Either
13:11:49 <sjanssen> Japsu: roughly, they're folds or "constructor replacers"
13:11:52 <Japsu> catamorphism... destroying structure?
13:11:58 <Japsu> collapsing?
13:12:01 <ddarius> downward transformation
13:12:06 <Japsu> hmm, okay
13:12:24 <Japsu> like "m a -> a"?
13:13:19 <Sizur> looks right to me
13:13:35 <Heffalump> more general than that
13:13:44 <Heffalump> m a -> b, kind of.
13:14:02 <roconnor> @type foldr
13:14:04 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:14:12 <sjanssen> and it really doesn't have anything to do with kinds
13:14:15 <roconnor> 1 function per constructor
13:14:21 <dmhouse> Japsu: by the way, http://en.wikibooks.org/wiki/Haskell/Category_theory might be worth a read if you were interested in how CT is used in Haskell. It doesn't cover cata/anamorphisms, though.
13:14:26 <roconnor> plus the input list
13:14:30 <roconnor> yeilding the result
13:14:45 <Japsu> hmm
13:15:30 <yrlnry> The paper on lenses, bananas, and barbed wire was very readable.
13:15:39 <yrlnry> If you want to know about catamorphisms, that's the place to go, I think.
13:15:47 <Japsu> @go lenses bananas barbed wire
13:15:48 <roconnor> Japsu: maybe have a look at http://programming.reddit.com/info/2h0j2/comments/c2hv1w
13:15:49 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
13:15:49 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
13:15:52 <ddarius> yrlnry: It's a good place to start
13:15:54 <Japsu> That? ;)
13:16:02 <roconnor> Japsu: particularly pjdelport's response
13:16:04 <Sizur> yrlnry: wasn't readable to me
13:16:32 <yrlnry> oh, maybe I'm mistaken.
13:16:35 <Sizur> alien syntax
13:16:55 <Sizur> good as a brain-teaser
13:17:25 <roconnor> hylomorphism!
13:17:37 <yrlnry> globomorphism!
13:17:43 <yrlnry> I like papers with funny little symbols.
13:17:54 <Sizur> how about morphomorphism?
13:18:00 <Sizur> metamorphism
13:18:03 <byorgey> fibratoelfimorphism!
13:18:07 <Japsu> wtf :D
13:18:11 <yrlnry> One of my favorites was the Burrows-Abadi-Needham one on "Logic of Authentication"
13:18:16 <yrlnry> Scleromorphism!
13:18:19 <yrlnry> Xanthomorphism!
13:18:20 <Japsu> crazymorphisms
13:18:29 <qpu> dwarfomorphism
13:18:32 <mauke> kittymorphism
13:18:32 <yrlnry> Skeptromorphism!
13:18:35 <torr> hi
13:18:39 <Japsu> cthulhumorphism :â¬
13:18:43 <byorgey> lol
13:18:45 <byorgey> hi torr
13:18:46 <qpu> torr: we're busy here!
13:18:52 <torr> I see
13:18:56 <roconnor> :D
13:18:58 <Japsu> :D
13:19:02 <olsner> anthropomorphism!
13:19:08 <profmakx> olsner is out
13:19:08 <yrlnry> olsner++
13:19:18 <torr> may I join in?
13:19:20 <Japsu> proceed
13:19:27 <byorgey> torr: of course =)
13:19:32 <torr> zrinozoromorphism!
13:19:37 <roconnor> :D
13:19:39 <byorgey> ooh, good one =)
13:19:45 <torr> zrinozoromorphisorus!
13:19:46 <Sizur> torr you surely meant: pay I join inmorphism
13:19:54 <roconnor> torr: bzzzt
13:20:02 <roconnor> torr: must end in ``morphsim''
13:20:14 <torr> ah
13:20:23 <yrlnry> Not of it's actually the name of a dinosaur.
13:20:24 <olsner> sesquipedomorphism
13:20:32 <torr> zrinozoromorphisoruzarusomorphism!
13:20:36 <yrlnry> olsner: Latino-Greek.  Foul!
13:21:03 <Sizur> mmomormorpmorphmorphimorphrsmorphism
13:21:12 <yrlnry> mnemomorphism.
13:21:25 <yrlnry> psychomorphism
13:21:42 <yrlnry> leukomorphism
13:21:51 <roconnor> oooh Paramorphism! http://en.wikipedia.org/wiki/Paramorphism
13:21:52 <lambdabot> Title: Paramorphism - Wikipedia, the free encyclopedia
13:21:52 <olsner> yrlnrymorphism
13:21:53 <Sizur> lol, this is going on alrady for 5 minutes
13:22:15 <BMeph> Eh? What's the current topic? :)
13:22:21 <torr> may I ask a question?
13:22:23 <roconnor> Apomorphism http://en.wikipedia.org/wiki/Apomorphism
13:22:24 <yrlnry> A  number of years ago #perl went on for at least an hour suggesting names for Nathan Torkington's unborn son.
13:22:29 <byorgey> roconnor: yes, I think that's the "strings"... or is it barbed wire...
13:22:35 <byorgey> torr: sure
13:22:48 <yrlnry> I recall that "Tyrannosaurus Torkington" and "Notorious B.I.G. Torkington" were suggested.
13:22:59 <loupgaroublond> bos: around?
13:23:04 <mauke> "Dalek Torkington"?
13:23:10 <yrlnry> probably.
13:23:23 <blakkino> how much big is the ghc RTS on windows?
13:23:27 <blakkino> more or less..
13:23:40 <mauke> @vixen don't cross the memes!
13:23:41 <lambdabot> I dunno
13:23:54 <qpu> no bigger than a small rodent, surely
13:24:06 <blakkino> 10k, 100k 1000k :)
13:24:09 <blakkino> choose
13:24:09 <blakkino> heh
13:24:49 <bos> loupgaroublond: yep
13:24:49 <Sizur> depends on the size of the brush you'll use to pain g.h.c.
13:24:57 <byorgey> blakkino: I think it's 256MB
13:25:21 <torr> well, I need to find () simbols in HTML files that I have and add a zero-width-non-braking-space chars next to them, I read a bit tutorials about Haskell long time ago, but never wrote a prgram in it. Would it be a good idea to try to do it in haskell? It would involve reading and writing files, and I know haskell is a bit theoretical about it
13:25:53 <olsner> blakkino: some say it's about 2^31 bits
13:25:58 <blakkino> pls
13:25:59 <blakkino> seriusly
13:26:30 <mauke> you mean like s/([()])/$1\x{feff}/g ?
13:26:33 <Sizur> I compiled a few on windows, but I cannot answer this one
13:26:47 <blakkino> compile main = putStrLn "hello"
13:26:48 <blakkino> :)
13:26:51 <blakkino> and tell me size
13:27:10 <Cale> blakkino: I don't have a windows machine handy. You can get an idea of how much extra stuff there will be by compiling something like a hello world, as you just pointed out.
13:27:17 <torr> mauke: something like that but only between the tags
13:27:17 <ddarius> torr: What exactly is theoretical about readFile and writeFile?
13:27:25 <Sizur> blakkino: my windows machine is not on this table right now, too lazy to move
13:27:34 <blakkino> me too :Â°)
13:27:38 <torr> ddarius: I read about monads, didn't understand it totaly
13:27:56 <mauke> torr: you'd need a html parser
13:28:07 <mauke> this is more about available libraries than language details
13:28:16 <Cale> blakkino: Don't be surprised if it's anywhere from a few hundred k to a couple megs.
13:28:25 <loupgaroublond> bos: what's the deal with the naming scheme for haskell packages in fedora, especially executables
13:28:54 <bos> libraries get named stuff like ghc681-foobar. executables are just plain old executables.
13:28:57 <Sizur> torr: if that's all you need haskell for, perl will be easier. it has a good and easy html parser
13:29:29 <loupgaroublond> bos: cause cabal rpm, when doing libraries, comes into conflict the standard fedora scheme
13:30:00 <Sizur> torr: I'd say there is a lot of preliminary material to get started on this with haskell, but in the end, it's definitely worth it
13:30:40 <bos> loupgaroublond: how so?
13:30:44 <loupgaroublond> bos, and i'm thinking, i'm debating if it's just worth it to hack up cabal-rpm to tell the difference, and make good packages, or do something else
13:30:46 <torr> Sizur: How much time do you think that would take?
13:31:01 <Sizur> torr: only you can answer that
13:31:45 <loupgaroublond> bos, well take zlib for example, if i run cabal-rpm on that, i get a file called zlib.spec, and then an empty rpm 'zlib-version.rpm' and a library 'ghc681-zlib-version.rpm'
13:31:46 <Sizur> it depends on what you know already and how fast you get new material
13:32:14 <loupgaroublond> bos: that would be perfect for something like xmobar, but definitely not for zlib
13:32:15 <torr> Sizur: does haskell has an html parser?
13:32:33 <bos> loupgaroublond: two options.  use cabal-rpm --name, or just delete the empty library.
13:32:59 <loupgaroublond> i guess i didn't find that option :)
13:33:07 <bos> try --help some day :-)
13:33:18 <Sizur> torr: html is a broken xml. we have xml parsers and tagsoup. perl html parser will be better suited for your goal
13:33:46 <loupgaroublond> bos, the other thing i wanted to know if it would be feasible to create spec files that create rpms for any and all haskell implementations available
13:34:03 <loupgaroublond> bos, or if to the best of your knowledge would be too complicated for fedora to handle
13:34:06 <torr> OK
13:34:23 <bos> loupgaroublond: you mean one rpm that contains files for ghc, hugs, etc?
13:34:47 <torr> Sizur: OK , I will do my first haskell program an other time then. Thanks.
13:35:16 <Sizur> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tagsoup-0.1
13:35:30 <loupgaroublond> bos, no, one spec file, say haskell-zlib, that generates 'haskell-ghc661-zlib.rpm', 'haskell-ghc682-zlib', 'haskell-hugs-zlib', etc...
13:35:55 <bos> loupgaroublond: i don't think that makes any sense.
13:36:01 <loupgaroublond> bos, why not?
13:36:13 <nolrai> > zip [1..] "abcdefg"
13:36:15 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g')]
13:36:39 <bos> loupgaroublond: too complicated, no benefits.
13:37:25 <loupgaroublond> bos, what about just for ghc? are you planning on supporting more than one version simultaneously on a regular basis?
13:38:17 <bos> no.
13:38:31 <Sizur> torr: I think this one is the best html parser we have so far: http://www.cs.york.ac.uk/fp/darcs/tagsoup/tagsoup.htm
13:38:32 <lambdabot> Title: Drinking TagSoup by Example
13:38:36 <bos> i'll actively support the newest ghc.
13:38:51 <loupgaroublond> bos, so i should work against just ghc681/2 for the time being?
13:39:03 <Sizur> torr: problem is that html is very broken, there are thousands of special cases
13:39:06 <bos> loupgaroublond: yes, i think so.
13:39:29 <loupgaroublond> bos, that makes my life easier :) thanks for the help
13:39:51 <bos> np
13:39:58 <Sizur> torr: you can easely write your own parser if all you need is modify our own html (which hopefully you know well)
13:41:24 <Sizur> torr: http://citeseer.ist.psu.edu/leijen01parsec.html
13:41:25 <lambdabot> Title: Parsec, a Fast Combinator Parser (ResearchIndex)
13:46:00 * olsner is already missing the morphism game
13:46:57 <DRMacIver> Hm. I need an interesting (and relatively simple) example of a multiparameter type class. Anything spring to mind?
13:46:57 <Japsu> round 2!
13:46:58 <Sizur> msihpromorphism
13:47:25 <Sizur> DRMacIver: Projection a b
13:47:30 <mauke> DRMacIver: MonadReader?
13:48:00 <DRMacIver> mauke: I need it for an example. I'd rather not mention monads. :)
13:48:28 <DRMacIver> Sizur: Hm. Meaning what exactly?
13:49:15 <visof> > 7 'div' 2
13:49:15 <lambdabot>  Improperly terminated character constant at "'div'" (column 3)
13:49:16 <Sizur> DRMacIver: http://hpaste.org/4573  how about Either a b?
13:49:32 <visof> how can do this?
13:49:34 <DRMacIver> Either isn't a type class?
13:49:44 <Sizur> oh yeah
13:49:47 <visof> also i had error in ghci
13:50:21 <mauke> > 7 `div` 2
13:50:23 <lambdabot>  3
13:50:24 <DRMacIver> Hm. The projection example is interesting though.
13:50:24 <Sizur> DRMacIver: you don't need to mention stuff about TH abviously. just a few examples of the instances
13:50:39 <DRMacIver> Sizur: The example isn't actually in Haskell. :)
13:50:51 <DRMacIver> Although it relates back to Haskell at the end.
13:50:57 <ddarius> Scala traitor
13:51:01 <DRMacIver> Ha ha
13:51:04 <DRMacIver> Yes
13:51:44 <DRMacIver> But given that the post is me demonstrating a faithful mechanical encoding (with relatively little syntax increase - a few keywords per declaration) of Haskell type classes in Scala I don't feel too bad about that. :)
13:51:52 <visof> > 5 `div` 2
13:51:53 <lambdabot>  2
13:52:04 <visof> thanks
13:52:11 <ddarius> Don't worry, I don't feel bad about it at all.
13:52:38 <DRMacIver> About you writing Scala? Or about me writing Scala?
13:52:54 <ddarius> I've never written any Scala.
13:52:59 <DRMacIver> Ah
13:57:54 <Hadaka> argh, a *really* silly question - how do I make a Float from an Int (not Integer)?
13:58:17 <mauke> fromIntegral
13:58:39 <nolrai> @ty \n -> [1.n]
13:58:40 <lambdabot> forall b c a. (Num (b -> c)) => (a -> b) -> [a -> c]
13:58:46 <Hadaka> mauke: great, thanks, that was what I was missing
13:58:48 <Toxaris> > fromIntegral (3 :: Int) :: Float
13:58:49 <lambdabot>  3.0
13:59:36 <blakkino> hmm.. hello world is ~500k on windows with last ghc
13:59:40 <Sizur> Hadaka: polymorphism
13:59:43 <blakkino> ~330 compressed with upx
13:59:56 <blakkino> :)
14:00:01 <Sizur> blakkino: how on linux?
14:00:57 <blakkino> 470 (on windows it was more 600 than 500)
14:02:08 <sclv_> msg lambdabot @pl \opts -> prop opts . a opts
14:02:29 <nolrai> how would you guys go about writing a routine to shuffle a finite list (randomly)?
14:02:34 <mauke> liftM2 (.) prop a
14:02:49 <mauke> @where oleg
14:02:50 <lambdabot> http://okmij.org/ftp/
14:02:54 <mauke> nolrai: I'd look there
14:03:15 <sclv_> msg maukebot @vixen a/s/l
14:03:16 <blakkino> nolrai, maybe a random mergesort-like stuff?
14:03:17 <dons> > randomRs (minBound,maxBound) (mkStdGen 42) :: [Integer]
14:03:18 <lambdabot>   add an instance declaration for (Bounded Integer)
14:03:18 <lambdabot>     In the expression: ma...
14:03:23 <dons> > randomRs (minBound,maxBound) (mkStdGen 42) :: [Int]
14:03:24 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
14:03:34 <dons> > zip "haskell" $ randomRs (minBound,maxBound) (mkStdGen 42) :: [Int]
14:03:34 <lambdabot>  Couldn't match expected type `Int'
14:03:39 * sclv_ really needs to get a better command line irc client
14:03:42 <dons> > zip "haskell" $ ( randomRs (minBound,maxBound) (mkStdGen 42) :: [Int])
14:03:43 <lambdabot>  [('h',-1673289139),('a',1483475230),('s',-825569446),('k',1208552612),('e',1...
14:03:52 <dons> > sortBy (comparing snd) . zip "haskell" $ ( randomRs (minBound,maxBound) (mkStdGen 42) :: [Int])
14:03:53 <lambdabot>  [('h',-1673289139),('l',-1284852847),('s',-825569446),('l',84572631),('e',10...
14:04:00 <dons> > map fst . sortBy (comparing snd) . zip "haskell" $ ( randomRs (minBound,maxBound) (mkStdGen 42) :: [Int])
14:04:01 <lambdabot>  "hlsleka"
14:04:03 <wy> Doesn't Data.List.find return an index?
14:04:03 <dons> :)
14:04:23 <dons> like that, nolrai ?
14:04:58 <mauke> :t find
14:04:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:05:02 <blakkino> nice :)
14:05:20 <mauke> @hoogle (a -> Bool) -> [a] -> Maybe Int
14:05:22 <lambdabot> Data.List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
14:05:33 <wy> ha! good!
14:05:34 * SamB wonders why they stuck this scheme script stuff in a non-normative appendix of R6RS
14:05:55 <bringert> doess galois have bandwidth problems? I'm only getting 75 KB/s download from darcs.haskell.org
14:06:00 <nolrai> wow
14:06:19 <SamB> bringert: what did you say your problem was again?
14:06:33 <bringert> SamB: huh?
14:06:33 <dons> bringert: hmm
14:06:41 <bringert> SamB: limited bandwidth?
14:06:53 <dons> bringert: do you have a test i can run?
14:07:00 <dons> its possible our connection is loaded up for some reason
14:07:21 <bringert> dons: I'm downloading http://darcs.haskell.org/ghc-HEAD-2007-12-16-ghc-corelibs-testsuite.tar.gz
14:07:42 <dons> so i'm getting 2.5M/s on that
14:07:49 <vincenz> bringert: 15KB/s for me
14:07:53 <dons> i'll try from outside galois
14:07:59 <SamB> dons: ... um, yeah
14:08:10 <dons> SamB: so at least its not the machine
14:08:22 <SamB> I guess it's good to establish what the server is capable of, yes...
14:08:28 <nolrai> dons++
14:08:36 <dons> getting 90 k/s to sydney
14:08:51 <bringert> I got like 20 KB/s with wget, but 150 KB/s initially with Safari, slowly decreasing, now at 67
14:09:06 <dons> what do you normally get for galois ?
14:09:18 <bringert> I normally don't pull down things this big
14:09:25 <SamB> why are you expecting more ?
14:09:36 <bringert> but I seem to remember getting an earlier darcs tarball faster than this
14:10:38 <bringert> well, it's seems like it's a bit limited bandwidth for a company like galois, especially since they host darcs.haskell.org
14:11:27 <bringert> I'm guessing that galois isn't running off an asymmetric consumer "broadband" connection
14:11:34 <dons> yep. there's bandwidth issues in the current building.
14:11:37 <dons> its quite old.
14:11:49 <bringert> them tubes are to narrow?
14:11:49 <dons> the new building we're moving to should be *much* better in this regard
14:11:57 <dons> yeah
14:12:08 <bringert> oh, you're moving? is it far from the current one?
14:12:15 <dons> downtown
14:12:26 <bringert> Beaverton? or Portland?
14:12:26 <dons> in a few months
14:12:31 <dons> portland :)
14:12:35 <bringert> sweet
14:12:42 <dons> in the cbd. since we're getting a bit big for this space
14:12:56 <dons> and we need to put john's helipad somewhere
14:13:02 <ddarius> The lights are much brighter there
14:13:02 <bringert> there was lots of free space when I was there 1.5 mths somewhere
14:13:04 <bringert> haha
14:13:12 <bringert> eh
14:13:17 <bringert> what the hell did I write
14:13:24 <dons> yeah, there's hardly any room now.
14:13:29 <bringert> s/1.5 mths somewhere/1.5 yrs ago/
14:13:42 <vincenz> bringert: I was already thinking :D
14:13:47 <bringert> you guys must have hired a lot of people
14:13:55 <vincenz> "those portlanders breed like rabbits"
14:14:23 <dons> yeah, there's been a lot of growth this year
14:14:24 <nolrai> you guys are in portland?!
14:14:37 <nolrai> well dons any way
14:14:44 <dons> yep.
14:14:52 <nolrai> cool
14:14:58 <dons> we even had a pdxfunc meeting last week
14:15:56 <nolrai> awsome!
14:16:27 <jmob> Anyone have a recommendation for the best library to use for lexing C++ tokens?
14:17:35 <SamB> jmob: what do you mean?
14:18:21 <dons> jmob: there's no C++ lexing library. but you could use alex to maybe c2hs's C parser/lexer
14:18:22 <Associat0r> any #F# guys here?
14:18:28 <vincenz> lexing c++ is not that hard
14:18:32 <vincenz> the complexity is in parsing :)
14:18:52 <jmob> I know lexing isn't that hard, I don't need to parse to accomplish what I want
14:18:55 <SamB> indeed
14:19:01 <SamB> try lexing scheme ;-)
14:19:42 <vincenz> SamB: eh?
14:19:56 <Associat0r> I would suggest boost::spirit
14:19:59 <dons> jmob: then perhaps just grab one of the existing C lexers, (e.g. in c2hs) and tweak it?
14:20:02 <Associat0r> for parsing
14:20:10 <SamB> vincenz: just look at those numeric literals
14:20:27 <vincenz> oh
14:20:46 <Associat0r> jmob
14:20:55 <Associat0r> check boost::spirit
14:21:29 <dons> i guess since this is #haskell, jmob is looking to do lexing on the haskell side, rather than being tied to C++ for some reason?
14:21:29 <jmob> Associat0r: I've seen it, I don't really want to right this project in C++ :)
14:22:03 <SamB> dons: of course
14:22:13 <dons> there's a full gcc lexer and parser in c2hs, and alex could take a standard lex spec with some tweaks, if you have one
14:22:14 <SamB> who the heck wants to involve C++ ?
14:22:41 <SamB> dons: is it even that hard to write one?
14:22:52 <dons> shouldn't be
14:23:06 <vincenz> you can find std lex definitions for c++
14:23:12 <vincenz> they're easily ported to for instance alex
14:23:14 <bringert> hmm ghc-HEAD-2007-12-16-ghc-corelibs-testsuite.tar.gz is actually a bzip2 file
14:23:16 <Associat0r> ah ok I misread
14:23:19 <Associat0r> sorry my bad
14:23:50 <Associat0r> I am into multiple channels I forgot this was haskell
14:23:58 <Zao> C++ is rather painful to parse.
14:24:00 <Zao> http://www.nobugs.org/developer/parsingcpp/
14:24:01 <lambdabot> Title: Parsing C++ at nobugs.org
14:24:06 <vincenz> c+= parses ambgiuously
14:24:09 <vincenz> until lookup stage
14:24:19 <vincenz> namely template instantiation and namespace lookup
14:24:37 <vincenz> which is why most systems use ambiguous lexers (like GLR) to generate a parse-forest
14:24:41 <vincenz> and then disambiguate later
14:24:44 <vincenz> erm
14:24:48 <vincenz> ambiguous parsers
14:24:54 <vincenz> happy does do glr
14:27:07 <nolrai> @hoogle comparing
14:27:08 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:27:49 <vincenz> @let on f g x y = f (g x) (g y)
14:27:52 <lambdabot> Defined.
14:28:04 <vincenz> :t (`on` ord)
14:28:05 <lambdabot> Not in scope: `on'
14:28:07 <vincenz> :t (`on` compare)
14:28:08 <lambdabot> Not in scope: `on'
14:28:13 <vincenz> :t (`L.on` compare)
14:28:13 <Japsu> :o
14:28:14 <lambdabot> Couldn't find qualified module.
14:28:16 <vincenz> grr
14:28:27 <vincenz> > `on` compare
14:28:28 <lambdabot>   parse error on input ``'
14:28:33 <vincenz> > (`on` compare)
14:28:34 <lambdabot>  Add a type signature
14:28:37 * vincenz sighs
14:28:38 <vincenz> oh well
14:28:57 <vincenz> :t let on f g x y = f (g x) (g y) in (`on` compare)
14:28:58 <lambdabot> forall t t1. (Ord t1) => ((t1 -> Ordering) -> (t1 -> Ordering) -> t) -> t1 -> t1 -> t
14:29:18 <vincenz> oh
14:29:20 <vincenz> comparing = compare on
14:29:23 <vincenz> erm
14:29:24 <vincenz> on compare
14:29:34 * vincenz stops spamming
14:30:52 <jmob> vincenz: for ex. (a) & (b) is ambiguous
14:31:11 <jmob> until you can start resolving names
14:31:32 <jmob> is it a cast an address or is it a binary and
14:32:55 <wy> got a strange layout parse error
14:33:26 <vincenz> jmob: yes
14:34:10 <vincenz> jmob: I know c++ is inherently ambiguous :)
14:34:17 <vincenz> c is ambiguous too but can be resolved while compiling
14:34:18 <wy> Need some help about the layout: http://hpaste.org/4597
14:34:19 <vincenz> erm
14:34:20 <vincenz> while parsng
14:34:47 <ddarius> @users
14:34:47 <lambdabot> Maximum users seen in #haskell: 434, currently: 399 (91.9%), active: 16 (4.0%)
14:35:24 <mauke> wy: what's the "let idx = " doing there?
14:35:43 <Sizur> Parsec's Java lexeme is not handling comments correctly
14:36:02 <wy> mauke: oh...
14:37:07 <wy> mauke: They are not needed
14:37:22 <Toxaris> > findIndex (0 ==) [1, 2, 0, 3] -- wy
14:37:24 <lambdabot>  Just 2
14:39:58 <wy> Corrected. Perfect ;-)
14:40:16 <wy> Toxaris: Thanks! That's really good style
14:41:05 <Toxaris> > [(x, y, z) | x <- ["x1", "x2"], y <- ["y1", "y2"], z <- ["z1", "z"]] -- wy again
14:41:06 <lambdabot>  [("x1","y1","z1"),("x1","y1","z"),("x1","y2","z1"),("x1","y2","z"),("x2","y1...
14:42:00 <Toxaris> > (,,) <$> [1, 2] <*> [3, 4] <*> [5, 6] -- wy: even nicer in my eyes
14:42:01 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
14:42:44 <wy> Toxaris: Cool. I should paste my full code ;-)
14:42:55 <Syzygy-> > ((,,) <$> [1,2] <*> [3,4] <*> [5,6]) == [(x,y,z)|x <- [1,2], y <- [3,4], z <- [5,6]]
14:42:56 <lambdabot>  True
14:43:12 <wy> Toxaris: <*> is defined?
14:43:17 <Syzygy-> :T <*>
14:43:18 <wy> :t <*>
14:43:18 <Sizur> > (,) <$> "ab" <*> "cd"
14:43:19 <lambdabot> parse error on input `<*>'
14:43:19 <lambdabot>  [('a','c'),('a','d'),('b','c'),('b','d')]
14:43:26 <Toxaris> wy: import Control.Applicative
14:43:28 <mux> :t (<*>)
14:43:28 <wy> :t (<*>)
14:43:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:43:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:43:42 <Sizur> :t (<$>)
14:43:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:43:58 <Syzygy-> > [1,2] <*> [3,4]
14:43:58 <lambdabot>   add an instance declaration for (Num (a -> b))
14:43:58 <lambdabot>     In the expression: 2
14:44:06 <vincenz> a <$> b = (return a) `ap` b
14:44:14 <Syzygy-> ?src (<*>)
14:44:14 <lambdabot> Source not found. You type like i drive.
14:44:45 <Toxaris> > [succ, pred] <*> [0, 10] -- Syzygy-: you need functions somewhere
14:44:46 <lambdabot>  [1,11,-1,9]
14:45:27 <vincenz> <*> = ap
14:45:33 <vincenz> > [succ, pred] `ap` [0,10]
14:45:34 <lambdabot>  [1,11,-1,9]
14:45:42 <Sizur> :t ((,) <$>)
14:45:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> (a, b))
14:46:42 <Syzygy-> Toxaris: Aaaahhh.
14:46:49 <Sizur> I need to dig more into papers
14:47:04 <Syzygy-> And we have (,,) <$> [1,2] == [(1,,), (2,,)]
14:47:14 <mux> @src [] (<*>)
14:47:14 <lambdabot> (<|>) = (++)
14:47:20 <mux> uh?
14:47:33 <Toxaris> mux: :)
14:47:40 <mux> I think I got LB confused somehow
14:47:49 <Toxaris> lambdabot: that's the answer to a different question!
14:48:05 <Toxaris> @src [] (<|>)
14:48:05 <lambdabot> Source not found. That's something I cannot allow to happen.
14:48:46 <Toxaris> Syzygy-: exactly. nice, isn't it?
14:49:02 <Sizur> amazing
14:49:19 * Toxaris has a secret dual life as Control.Applicative promoter
14:49:43 <Syzygy-> Toxaris: I like!
14:49:46 <vincenz> Toxaris: that's conal (:
14:49:49 <wy> Full code pasted :D http://hpaste.org/4598
14:49:51 <Syzygy-> Btw, what except for functions implement Applicative?
14:49:52 <Sizur> :t (,,) <$>
14:49:53 <lambdabot> parse error (possibly incorrect indentation)
14:50:05 <Sizur> :t ((,,) <$>)
14:50:06 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f a -> f (b -> c -> (a, b, c))
14:50:44 <Toxaris> Syzygy-: every monad could in theory (and should in practice)
14:50:52 <Syzygy-> Toxaris: How?
14:51:01 <Toxaris> Syzygy-: pure = return and <*> = ap
14:51:04 <ddarius> :t (<*>)
14:51:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:51:05 <ddarius> :t ap
14:51:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:51:09 <delYsid> I have a question which is maybe trollish, but I swear I have no trolling intents.  I am programming since 10 years now in more languages than I've got fingers, I LOVE lisp and do things like python or perl as well.  I've once tried to learn haskell and sort of wrote a chess program in it, but I cant seem to get my head around monads.
14:51:10 <wy> Toxaris: interesting. It seems it's making the combinations for you
14:51:23 <Syzygy-> wy: EXACTLY! :)
14:51:37 <delYsid> Does one have to study some CS to actually be able to grasp Haskell?
14:51:44 <ddarius> delYsid: No.
14:51:57 <mauke> delYsid: don't try to get your head around monads. just use a few data types that happen to be instances of Monad
14:52:08 <wy> Syzygy-: And construct them into whatever types you like?
14:52:15 <mux> to be perfectly honest, I got much more comfortable with haskell after reading TAPL, but that may be just me
14:52:18 <ddarius> delYsid: There are children that program in Haskell.
14:52:20 <mauke> you'll notice the commonalities (and if you don't, it doesn't really matter)
14:53:32 <Syzygy-> delYsid: I never studied any CS.
14:53:40 <Toxaris> wy: the idea about <*> is that it somehow lifts function application. normally, function application has type ((a -> b) -> a -> b). do you see why this is the case?
14:53:44 <Syzygy-> OTOH - I'm finishing my PhD in algebra, so I might not count.
14:53:48 <delYsid> Well, when I was in my haskell-learn mode a few years back, I remember I really liked it at the beginning, doing simple things with data types and stuff.
14:54:01 <Philippa_> delYsid: I've run powerful subsets of Haskell past people who're more or less non-programmers in a couple of hours before, including examples
14:54:05 <delYsid> But as soon as I hit the IO thing, I was like completely without any energy left...
14:54:25 <MyCatVerbs> mux: TALP?
14:54:27 <wy> Toxaris: Yes. applications have this type
14:54:30 <MyCatVerbs> mux: er, TAPL?
14:54:36 <Philippa_> ah. Probably the easiest way to start with IO is "by recipe" - don't worry about monads, just pay attention to the existance of IO types and use do
14:54:43 <Toxaris> wy: now <*> lifts application to type [a -> b] -> [a] -> [b]
14:54:43 <mux> MyCatVerbs: yeah, types and programming languages, from pierce
14:54:51 <wy> Syzygy-: You are more than CS :D
14:54:55 <Toxaris> wy: and type Maybe (a -> b) -> Maybe a -> Maybe b
14:55:02 <Syzygy-> Toxaris: Or IO (a -> b) to IO a -> IO b
14:55:08 <Toxaris> wy: and type IO (a -> b) -> IO a -> IO b
14:55:10 <olsner> delYsid: try http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
14:55:11 <Toxaris> wy: and so on
14:55:17 <mauke> delYsid: http://mauke.ath.cx/stuff/haskell/how-to-io.html
14:55:29 <mauke> (it's still incomplete, though)
14:55:59 <Toxaris> wy: in a "sensible manner" :) for [], this means: apply every function in the list to every argument and concat the results
14:56:05 <delYsid> olsner: reading
14:56:21 <Toxaris> > [succ, pred] <*> [-10, 10] -- wy so we get 4 results here
14:56:22 <lambdabot>  [-9,11,-11,9]
14:56:23 <wy> Toxaris: Wait...
14:56:25 <mauke> olsner: I don't like that article :(
14:56:38 <wy> You have a list of functions and a list of arguments for them?
14:56:53 <olsner> mauke: oh? why?
14:57:00 <dobblego> ?type ap
14:57:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:57:20 <Toxaris> wy: yes. like in the succ, pred example
14:57:25 <mauke> olsner: because it lies in an evil way
14:57:27 <dobblego> ?type ap :: [(a -> b)] -> [a]
14:57:28 <lambdabot>     Couldn't match expected type `[a]'
14:57:28 <lambdabot>            against inferred type `[a] -> [b]'
14:57:28 <lambdabot>     In the expression: ap
14:57:40 <Toxaris> wy: but you can just use a singleton list if you happen to have only one function
14:57:42 <mauke> and it introduces "do" before >> and >>=
14:57:56 <wy> Toxaris: Like cross product, but they are applications
14:57:58 <ddarius> mauke only likes the lies in the Bible that are blessed by God.
14:58:06 <Toxaris> wy: yes
14:58:20 <wy> sorry, cartesian product?
14:58:25 <olsner> mauke: but >> and >>= are pretty irrelevant until you can actually get simpler things done, IMO
14:58:26 <Toxaris> wy: whatever...
14:58:39 <Toxaris> wy: yes cartesian sounds better.
14:58:59 <nolrai> > (Just (+1) `ap` Just 1
14:59:00 <lambdabot> Unbalanced parentheses
14:59:00 <mauke> olsner: I disagree
14:59:08 <nolrai> > Just (+1) `ap` Just 1
14:59:09 <lambdabot>  Just 2
14:59:10 <Toxaris> > Just succ <*> Just 4 -- it works with other types as well wy
14:59:11 <lambdabot>  Just 5
14:59:18 <Toxaris> > Nothing <*> Just 4 -- it works with other types as well wy
14:59:19 <lambdabot>  Nothing
14:59:22 <olsner> relevant to monads, irrelevant to I/O
14:59:26 <Toxaris> > Just succ <*> Nothing -- it works with other types as well wy
14:59:27 <lambdabot>  Nothing
14:59:34 <wy> So what does [1,2] <*> [3,4] mean?
14:59:36 <mauke> does http://mauke.ath.cx/stuff/haskell/how-to-io.html work for you (where you = the internet)?
14:59:42 <lambdabot> Title: Haskell: How To IO
14:59:50 <Syzygy-> wy: Nothing sensible since 1 and 2 aren't functions
14:59:51 <mauke> lambdabot: oh, right
14:59:56 <Toxaris> wy: do you know about currying?
15:00:00 <mauke> olsner: anyway, that's how I'd introduce IO in Haskell
15:00:01 <wy> yes
15:00:21 <mauke> you'll see that it starts with >>, >>=, followed by return
15:00:26 <Toxaris> :t [(+)] <*> [1, 2] -- wy
15:00:28 <lambdabot> forall a. (Num a) => [a -> a]
15:00:32 <mauke> it doesn't even mention monads
15:00:39 <Toxaris> :t [(+)] <*> [1, 2] <*> [5, 10] -- wy
15:00:40 <lambdabot> forall a. (Num a) => [a]
15:01:21 <Toxaris> > [(+)] <*> [1, 2] <*> [5, 10] -- we can use currying with <*> to combine more then one argument in "a sensible way"
15:01:21 <lambdabot>  [6,11,7,12]
15:01:39 <wy> Toxaris: Ha!
15:01:48 <mauke> olsner: >>= and return are sufficient to get anything done, and you can understand them without knowing anything about do-notation or monads or state passing
15:01:55 <Syzygy-> > [(+),(*),(/)] <*> [1,2] <*> [5,10]
15:01:56 <lambdabot>  [6.0,11.0,7.0,12.0,5.0,10.0,10.0,20.0,0.2,0.1,0.4,0.2]
15:02:06 <olsner> well, in any case, it's time for me to sleep well in preparation of tomorrow's speed-packing
15:02:27 <wy> So what does <$> mean?
15:02:47 <Syzygy-> Take a function and pack it into the right monad/functor
15:03:03 <Toxaris> wy: it's boring to write [(+)] all the time, so there's a name for it, too. it's called pure
15:03:05 <ddarius> @src (<$>)
15:03:05 <lambdabot> f <$> a = fmap f a
15:03:10 <Toxaris> wy: (I'll come to <$> in a second)
15:03:29 <Toxaris> > Control.Applicative.pure 4 :: [Int]
15:03:30 <lambdabot>  [4]
15:03:37 <Toxaris> > Control.Applicative.pure 4 :: Maybe Int
15:03:38 <lambdabot>  Just 4
15:03:46 <Sizur> :t Just <$> (+)
15:03:47 <lambdabot> forall a. (Num a) => a -> Maybe (a -> a)
15:03:50 <Toxaris> wy: do you know monads?
15:04:04 <wy> Toxaris: A little. I planned to read it today
15:04:04 <ddarius> We need colimits of type classes.
15:04:15 <Toxaris> wy: ok, pure is basically the same as return
15:04:23 <Sizur> :t [] <$> (+)
15:04:24 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
15:04:24 <lambdabot>     In the first argument of `(<$>)', namely `[]'
15:04:32 <Toxaris> wy: it takes a value and prepares it to be used with <*> without any funny stuff happening
15:04:40 <Toxaris> wy: for lists, that means: wrap it into a singleton list
15:05:04 <Toxaris> [succ] <*> [1, 2, 3] == pure succ <*> [1, 2, 3]
15:05:08 <mauke> > (+) <$> []
15:05:09 <lambdabot>  []
15:05:26 <Toxaris> wy: since this (pure f <*> ...) pattern is very common, it has a special name: <$>
15:05:38 <Toxaris> > succ <$> [1, 2, 3]
15:05:39 <lambdabot>  [2,3,4]
15:06:31 <Syzygy-> This starts feeling like . . . $ chains and contravariance.
15:06:37 <Sizur> > pure succ <*> [1]
15:06:38 <lambdabot> Terminated
15:06:59 <Toxaris> > Control.Applicative.pure succ <*> [1]
15:07:00 <lambdabot>  [2]
15:07:15 <sjanssen> Sizur: why not succ <$> [1]?
15:07:17 <sjanssen> Sizur: that's more general
15:07:27 <Sizur> sjanssen: learning purpose
15:07:42 <nolrai> > succ <$> [1]
15:07:43 <lambdabot>  [2]
15:07:51 <Toxaris> for very annoying reasons, we have to qualify the pure, empty and <|> functions from Control.Applicative
15:07:53 <wy> Toxaris: A little confused
15:07:55 <Philippa_> type theory question: is there a shorthand name for System F with types restricted to prenex form?
15:08:08 <Toxaris> wy: about what?
15:08:19 <nolrai> :t pure
15:08:20 <lambdabot>     Ambiguous occurrence `pure'
15:08:20 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
15:08:20 <lambdabot>                           or `pure', imported from Control.Arrow
15:08:21 <wy> (pure f <*>...)
15:08:41 <dmwit> ?instances Applicative
15:08:42 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
15:08:58 <Toxaris> wy: you understand that bit about <*> being defined for many types?
15:09:30 <wy> Toxaris: I see now. pure f is putting f into [f] ?
15:09:41 <Toxaris> wy: yes.
15:10:08 <wy> I'm lucky not having used this symbol in my program
15:10:18 <Sizur> :t succ <$> (return 1::IO Int)
15:10:19 <Toxaris> wy: or f into Just f. or f into an IO action returning f when run
15:10:19 <lambdabot> IO Int
15:10:20 <ddarius> > pure id <*> Just 3
15:10:20 <lambdabot> Terminated
15:10:27 <sjanssen> > [succ, pred] <*> [1]
15:10:28 <lambdabot>  [2,0]
15:10:36 <dons> cute
15:11:48 <Toxaris> vincenz: I'm conal's faithfull disciple in this question :)
15:12:05 <Toxaris> wy: ok with pure and <$>?
15:12:07 <wy> Toxaris: I have to read monads again first ;-)
15:12:14 <Sizur> Toxaris: I cannot apply across functors, right?
15:12:16 <wy> Toxaris: Almost
15:12:29 <wy> Can I used this as something like "generalized map"?
15:12:39 <Toxaris> wy: <$> IS generalized map
15:12:57 <Toxaris> wy: for lists, it IS map. and for other types, it is something sensible wich works like map works for lists
15:13:03 <Toxaris> map succ [1, 2, 3]
15:13:05 <Toxaris> > map succ [1, 2, 3]
15:13:06 <lambdabot>  [2,3,4]
15:13:11 <Toxaris> > succ <$> [1, 2, 3]
15:13:11 <lambdabot>  [2,3,4]
15:13:18 <dmwit> Syzygy-: It feels like a . . . $ chain because it *is* a . . . $ chain:
15:13:31 <Toxaris> wy: from where we are now, monads are easy to explain in my opinion
15:13:33 <dmwit> ?ty (<$>) :: (b -> c) -> (a -> b) -> (a -> c)
15:13:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:13:37 <Toxaris> wy: all the background is already there :)
15:14:13 <Sizur> :t (<$>)
15:14:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:14:17 <wy> Toxaris: How can I get something like: map (+) [1,2,3] [2,3,4]  => [3,5,7] ?
15:14:19 <Sizur> :t fmap
15:14:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:14:30 <Toxaris> wy: let's look at the types
15:14:36 <Toxaris> :t map (+) [1, 2, 3]
15:14:37 <lambdabot> forall a. (Num a) => [a -> a]
15:14:47 <Toxaris> :t [2, 3, 4]
15:14:48 <lambdabot> forall t. (Num t) => [t]
15:15:02 <ddarius> (+) <$> ZipList [1,2,3] <*> ZipList [2,3,4]
15:15:06 <ddarius> > (+) <$> ZipList [1,2,3] <*> ZipList [2,3,4]
15:15:06 <lambdabot>   add an instance declaration for (Show (ZipList a))
15:15:13 <ddarius> > unZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [2,3,4]
15:15:14 <lambdabot>   Not in scope: `unZipList'
15:15:24 <ddarius> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [2,3,4]
15:15:24 <lambdabot>  [3,5,7]
15:15:28 <Toxaris> wy: oups, haven't read correctly
15:16:03 <wy> ddarius: A little wordy
15:16:23 <Sizur> :t zipWith
15:16:23 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:16:38 <ddarius> wy: Which is why people end up using zipWithN instead.
15:16:40 <Toxaris> wy: but anyway, we want to apply a list of functions to a list of arguments again, but this time, we have a different idea of wich function applies to wich argument. since Haskell thinks type-wise, we need a different type then list.
15:17:21 <ddarius> (Incidentally, it seems neither specialization nor generalization necessarily make understanding something easy.)
15:17:30 <wy> @hoogle zipWithN
15:17:31 <lambdabot> No matches found
15:17:39 <ddarius> @hoogle zipWith
15:17:40 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
15:17:40 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
15:17:40 <lambdabot> Data.ByteString.zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
15:17:49 <Toxaris> wy: so we invent the type ZipList wich does exactly what you want, as ddarius has shown. unfortunately, we have to convert every list of such a ZipList and the result back to a normal list
15:17:51 <ddarius> @hoogle zipWith3
15:17:51 <lambdabot> Prelude.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
15:17:51 <lambdabot> Data.List.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
15:18:19 <ddarius> Toxaris: Only because the Applicative instance for [] is the monad based one
15:18:44 <Sizur> :t (+) <$> [1,2,3]
15:18:45 <lambdabot> forall a. (Num a) => [a -> a]
15:19:00 <wy> ddarius: Only up to 7, but that's enough
15:19:01 <ddarius> > (+) <$> [1,2,3] <*> [2,3,4]
15:19:01 <lambdabot>  [3,4,5,4,5,6,5,6,7]
15:19:05 <loupgaroublond> bos, still there?
15:19:06 <Toxaris> ddarius: it is the wrong one. if we had the ZipList instance, we would need newtype ProductList for the current behaviour.
15:19:06 <Sizur> > (+) <$> [1,2,3] <*> [2]
15:19:07 <lambdabot>  [3,4,5]
15:19:17 <Toxaris> ddarius: so one of them will always be the wrong one
15:19:24 <ddarius> Toxaris, I agree.
15:19:57 <sjanssen> it is important to have the Applicative and Monad instances match
15:20:00 <ddarius> Toxaris: Consistency argues for them to be the same, usefulness argues for them to be different since I can always use return/ap for the other.
15:20:15 <Toxaris> ddarius: consistency wins by far :)
15:20:36 <Sizur> :t (+) <$> Just
15:20:37 <lambdabot> forall a. (Num (Maybe a)) => a -> Maybe a -> Maybe a
15:20:42 <ddarius> Toxaris: I don't disagree with the decision, but needing to use ZipList isn't anything inherent.
15:20:49 <wy> Toxaris: Is the <..>'s left associative?
15:20:51 <sjanssen> ddarius: I'd hate that, imagine the bugs that pop up when you refactor your `ap` code to <*>
15:20:55 <Sizur> (+) <$> Just <$> [1,2]
15:21:09 <Sizur> :t (+) <$> Just <$> [1,2]
15:21:09 <lambdabot> forall a. (Num (Maybe a), Num a) => [Maybe a -> Maybe a]
15:21:20 <Toxaris> ddarius: but the underlying annoyance, needing newtype's for instance selection, is
15:21:38 <sjanssen> ddarius: or when a library author changes a type from Monad m => ... to Applicative m => ...
15:22:19 <wy> Toxaris: I remember there is something in Mathematica like that.
15:22:27 <Sizur> > (+) <$> Just <$> [1,2] <*> [Just 2,Nothing,Just3]
15:22:27 <lambdabot>   Not in scope: data constructor `Just3'
15:22:36 <Sizur> > (+) <$> Just <$> [1,2] <*> [Just 2,Nothing,Just 3]
15:22:37 <lambdabot>   add an instance declaration for (Num (Maybe a))
15:22:38 <Toxaris> wy: I always mix up left- and right-associativity.
15:22:47 <ddarius> sjanssen: That last wouldn't cause any problems.  Code that depended on it would simply fail to type check (this is true either way the instances are set up)
15:22:48 <wy> Toxaris: I remember it's called replace the Head of an expression
15:22:53 <Toxaris> wy: a <$> b <*> c == (a <$> b) <*> c as you want
15:23:10 <sjanssen> ddarius: that isn't strictly true, what if I'm calling it with the concrete type of []?
15:23:23 <bos> loupgaroublond: yep
15:23:36 <aFlag> I guess no "real world haskell" chapters before 2008 :(
15:23:55 <Sizur> > (+) <$> Just <*> [1,2] <*> [Just 2,Nothing,Just 3]
15:23:56 <lambdabot>  Couldn't match expected type `a -> b'
15:23:57 <Toxaris> wy: and a <$> b <$> c = (a <$> b) <$> c wich is wrong most of the time.
15:24:07 <Toxaris> wy: so you have to use (a . b) <$> c instead
15:24:11 <ddarius> sjanssen: If the implementation of the code changes, it is the authors job to make sure it still means the same thing (if that's the goal)
15:24:51 <loupgaroublond> bos: other than hacking it in myself, are there plans/already implemented, to pass through cabal-rpm while processing the cabal files?
15:24:57 <wy> Toxaris: Do you use only one <$> in an express?
15:25:02 <Toxaris> darius: is this some sort of theoretical discussion, or would you really like Applicative instances differ from Monad instances for the same type?
15:25:13 <Toxaris> wy: you can use more, but you have to make sure you know what happens :)
15:25:22 <ddarius> Toxaris: I already said that I don't disagree with the decision that was made.
15:25:30 <Toxaris> wy: most of the time, you use the   f <$> a <*> b <*> c   pattern
15:26:11 <Toxaris> ddarius: ok fine
15:26:36 <wy> @hoogle unZipList
15:26:37 <lambdabot> No matches found
15:26:41 <ddarius> getZipList
15:26:53 <nolrai> :t pure
15:26:54 <lambdabot>     Ambiguous occurrence `pure'
15:26:54 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
15:26:54 <lambdabot>                           or `pure', imported from Control.Arrow
15:27:58 <EvilTerran> seems to me importing Arrow hiding (pure) would be in order
15:28:06 <EvilTerran> you can use the arr alias if you want that one
15:28:09 <Toxaris> who can I ask to hide Control.Arrow.pure from lambdabots scope? There's Control.Arrow.arr as a synonym, and Control.Applicative.pure would be nice to have in a short form
15:28:20 <sjanssen> Toxaris: speak to dons
15:28:37 <Toxaris> EvilTerran: :)
15:28:43 <EvilTerran> ?let pure = Control.Applicative.pure
15:28:44 <lambdabot> <local>:8:7: Not in scope: `Control.Applicative.pure'
15:28:54 <EvilTerran> Toxaris, :D
15:29:00 <EvilTerran> hm.
15:29:01 <Toxaris> :t empty
15:29:02 <wy> Toxaris: Nice explanation. I have to read monads now. See you
15:29:02 <lambdabot>     Ambiguous occurrence `empty'
15:29:03 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
15:29:03 <lambdabot>                           or `empty', imported from Text.PrettyPrint.HughesPJ
15:29:20 <Toxaris> wy: ok do so. but don't forget what I'm told you. with monads, it's the same :)
15:29:32 <EvilTerran> ... why's HughesPJ imported? i doubt people're gonna do much prettyprinting with lambdabot...
15:29:35 <wy> Toxaris: Thanks
15:29:55 <ddarius> EvilTerran: What?!
15:30:03 <EvilTerran> what?
15:30:14 * ddarius loves him his pretty printing combinators.
15:30:18 <Toxaris> ddarius, EvilTerran: What?!
15:30:25 <EvilTerran> well, yes. but lambdabot's not exactly the best showcase for 'em.
15:30:38 <ddarius> lambdabot, don't listen to him
15:30:51 <EvilTerran> whaaa
15:30:55 <nolrai> what are the prettyprinting combinators any way?
15:30:59 <EvilTerran> ... I'm going. to bed.
15:31:07 <ddarius> @google pretty printing combinators
15:31:10 <ddarius> EvilTerran: Good idea.
15:31:14 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/pretty.html
15:31:14 <lambdabot> Title: The Design of a Pretty-printing Library
15:31:29 <sjanssen> Toxaris: I just pushed a patch to fix that, it should be included next time dons rebuilds lambdabot
15:31:47 <Toxaris> :t (<|>)
15:31:48 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
15:32:00 <Toxaris> sjanssen: cool thanks. for empty too?
15:32:11 <ddarius> @src (<\*>)
15:32:12 <lambdabot> Source not found. My mind is going. I can feel it.
15:32:19 <ddarius> @src [] (<\*>)
15:32:19 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:34:00 <sjanssen> hmm, is code.haskell.org down?
15:34:11 <dons> works for me
15:34:51 <sjanssen> http works, but ssh seems to be hanging
15:35:11 <sjanssen> ah, just really slow
15:54:38 <scodil> how does Lazy ST work? Does it just defer the whole statefull computation until needed? Or does it thread the state through the rest of the program? Like, can you use it to produce infinite stuff?
15:55:25 <ddarius> Sure you can use it to produce infinite stuff.
15:56:33 <titusg> how come my code that uses #ifdef WIN32 ... #else ... #endif falls through to the #else on windows?
15:57:20 <Lemmih> titusg: I'm not sure WIN32 is set on Windows.
15:57:59 <titusg> bummer! how else should I put it then?
15:59:47 <jmob> titusg: it's usually _WIN32 in C code
16:01:54 <titusg> jmob: I was looking at this sort of thing from darcs (for example): http://tinyurl.com/3yhon9
16:01:55 <lambdabot> Title: darcs-1.0.8/RawMode.hs - Google Code Search
16:02:34 <titusg> Maybe that depends on the user setting that up before building?
16:02:52 <jmob> titusg: yeah, certainlly possible
16:03:04 <jmob> since the build system might have to define that
16:03:10 <scodil> if you've got a loop that modifies a lot of different data structures, is it better to thread that through a big fold? do it in ST with a bunch of STRefs? Both seem really awkward. Are there any standard abstractions for this kind of thing?
16:03:13 <jmob> instead of ghc automatically adding it
16:03:38 <jmob> (or whatever you're building with)
16:04:13 <jmob> Isn't the preprocessor stuff specific to GHC?
16:04:48 <titusg> I dunno, but I'm using ghc
16:05:58 <yitz> scodil: you can combine state together  - into an ADT/record, or some other container. THen thread it through, or use ST or State.
16:06:55 <titusg> Is there a flag I can set for this perhaps? Where would I check that out?
16:07:33 <titusg> At the moment the only flag I use is -cpp
16:10:01 <sjanssen> titusg: are you using Cabal?
16:11:06 <titusg> sjanssen: not at the moment, just trying to get a simple example working
16:16:24 <titusg> Like so: http://hpaste.org/4600 (is hpaste not announcing?)
16:20:48 <Valodim> ok I got the hang of defining my functions recursively now, but I always got the feeling they are really slow the way I do it
16:20:56 <Valodim> http://hpaste.org/4601
16:21:18 <Valodim> permuteRoute 20 20
16:21:18 <Valodim> been loading for some minutes now at 100% cpu...
16:22:48 <mauke> oh yeah
16:23:00 <Plareplane> Valodim, what happens when x and y are -?
16:23:04 <Plareplane> negative
16:23:06 <mauke> it returns 0
16:23:07 <Valodim> would there be a better way of defining that function? it's just two simple ifs and recursion but still it seems really inefficient
16:23:19 <Valodim> "otherwise" it returns 0
16:23:22 <mauke> Valodim: some sort of cache
16:23:23 <Valodim> and that should never happen anyways
16:23:37 <mauke> it looks like it recomputes a lot of values
16:23:41 <mrd> memoization might help
16:23:47 <mrd> looks like a dynamic programming problem
16:23:49 <nolrai> can one set colors of widgets in Gtk2hs?
16:24:08 <dcoutts> nolrai: that's generally done by the theme, but yes it's possible
16:24:17 <Valodim> a "dynamic programming problem"? and that would be?
16:24:42 <Valodim> (...google'd, reading...)
16:25:06 <nolrai> Where in the documnetation i would find how to set colors?
16:26:10 <dcoutts> nolrai: hoogle for widgetModifyBg
16:26:24 <nolrai> @hoogle widgetModifyBg
16:26:25 <lambdabot> No matches found
16:26:28 <dcoutts> nolrai: using the hoogle search on http://haskell.org/gtk2hs/
16:26:43 <dcoutts> it's labeled "search api docs"
16:26:52 <nolrai> found it
16:27:00 <nolrai> dcoutts++
16:28:54 <Toxaris> valodim: (just an idea) you could try to come up with a closed solution for this problem
16:30:25 <Valodim> I'll do the dynamic thing, probably the better approach for improving my haskell skillz :)
16:31:43 <mrd> Valodim: the easy way is to take advantage of laziness
16:31:59 <mrd> Valodim: create an array in which the elements recursively reference the array
16:32:19 <Valodim> yeah that's what I was gong for :)
16:32:42 <mrd> you may be a natural
16:32:46 <mrd> ;)
16:34:11 <Valodim> you mean like this, right?
16:34:11 <Valodim> http://hpaste.org/4602
16:42:21 <unk_red> anyone reccomend a haskell book? i've got an amazon gift card i don't know what to do with..
16:44:39 <bos> loupgaroublond: what do you mean by pass through?
16:45:11 <titusg> unk_red: `Bird' is my favourite
16:46:55 <titusg> unk_red: if you're a practical type of person and want to, you know, make things, perhaps Hudak "school of expression" or wait for the O'Reilly book
16:54:44 <Valodim> what happens if I use !! on a nonexistent index?
16:54:48 <Enzo> Can someone tell me what's up with this: mainLinks = ulist << li << alink ! [href "http://www.google.com"] << "google"     ..I get an error:  Couldn't match expected type `Html' against inferred type `String', Expected type: Html -> b, Inferred type: String -> HtmlAttr.. I just want to turn a string, "google", into a link to google.com
16:54:53 <Valodim> does it rhwo an exception?
16:54:53 <bos> > [1,2] !! 10
16:54:56 <lambdabot>  Exception: Prelude.(!!): index too large
16:54:59 <Valodim> *throw
16:55:25 <yitz> Valodim: yes
16:55:33 <titusg> Enzo: use hpaste.org
16:55:43 <yitz> so we often avoid !!
16:56:22 <notsmack> Enzo: should it be:  toHtml "google"?
16:57:05 <yitz> instead, try to use things like zip and map that go across all elements without having to treat one in the middle as special.
16:58:14 <Enzo> notsmack: i get the same error message. I'll post it on hpaste
16:58:53 <yitz> in haskell you often can avoid treating particular list elements as special - even the last one, due to laziness.
17:01:12 <titusg> Valodim: you can often use pattern matching in some way instead. !! is (often) a code smell
17:01:52 <Valodim> yeah figuring it out, I was still caught in the imperative ways "if in cache get from cache", old habits >_>
17:02:20 <mauke> just put everything in the cache up front
17:02:53 <Enzo> titusg: http://hpaste.org/4603
17:03:05 <Enzo> notsmack: http://hpaste.org/4603
17:03:23 <Enzo> any help will be greatly appreciated
17:06:53 <notsmack> @where xhtml
17:06:53 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml
17:13:24 <titusg> Enzo: I don't know this lib...break it down into smaller expressions and see which ones are well typed?
17:13:57 <loupgaroublond> bos, cabal files have flags that change their behavior, is there a way to control which flags are set when evaluating the cabal file, to generate a spec file out of it?
17:14:51 <titusg> what's happening with alink ! [..] for instance? alink :: String -> HtmlAttr
17:15:39 <Enzo> titusg: do you know of any examples online that show how to make Haskell render a navigation bar in xhtml?
17:16:05 <bos> loupgaroublond: not a generalised way yet.  let me know which flags you want passed through.
17:16:30 <Valodim> wouldn't that work just like any other language outputting html?
17:18:24 <Valodim> do an example in plain xhtml how it should look like, reduce that to a simple template with placeholders, implement in haskell
17:18:38 <Enzo> Valodin: probably, but Haskell is the only language I know and I can't get this to work
17:19:12 <Valodim> but you do know html?
17:19:28 <mmmdonuts> Enzo: I might be using a different version of xhtml from you, but if I change "alink" to "anchor" that google link code works.
17:19:35 <mmmdonuts> I don't have "alink".
17:20:06 <loupgaroublond> bos, i think it shoud be done generalised, zlib for example has a flag 'bytestring-in-base', which really should be 'ghc66' or something to that effect
17:20:18 <Enzo> valodim: yeah
17:20:28 <dcoutts> loupgaroublond: no, it's not ghc specific
17:20:45 <Valodim> well that's all you need for that approach isn't it
17:21:03 * ndm emails off another mingw rant...
17:21:08 <dcoutts> loupgaroublond: we can already have conditionals on implementation versions, but in this case it is not the right thing. It's actually based on the version of the base library.
17:21:15 <dcoutts> ndm: oh what this time? :-)
17:22:47 <Enzo> mmmdonuts,  works for me too now. Thanks!
17:23:33 <ndm> dcoutts, on glasgow-haskell-users - just someone asking why #ifdef WIN32 doesn't work
17:24:04 <dcoutts> ndm: ah, and ghc defines something like os_mingwin32
17:24:10 <ndm> yep :)
17:24:24 <ndm> i've also just finished my thesis word counting script, in haskell of course: http://www-users.cs.york.ac.uk/~ndm/thesis_words.png
17:24:43 <dcoutts> ndm: which is fair enough, but it'd be helpful to also define something to tell you you're on windows, mingwin is true, but too specific
17:24:45 <ndm> which brings to the end my list of things to procrastinate on doing before actually writing the thing
17:24:50 <dcoutts> heh
17:25:07 <ndm> dcoutts, its also defined on Hugs with Cabal, which is entire untrue
17:25:20 <ndm> or potentially entirely untrue
17:25:22 <Nafai> ndm: So did you find something to use for your charts ?
17:25:39 <ndm> Nafai: i did these with Google Charts, its dead simple actually
17:25:48 <dcoutts> ndm: yeah, that's an example of just following what ghc does because people follow what ghc does
17:25:50 <ndm> Nafai: but for Hoogle i'll look into the Haskell one
17:25:58 <Nafai> Cool
17:26:10 <ndm> dcoutts: if GHC ran off a cliff...
17:26:22 <Valodim> totally
17:26:43 <dcoutts> ndm: people would still have to define host_os_mingw32 just to be able to build all the common software :-)
17:27:11 <ndm> dcoutts: i'm not saying we can remove it, i'm just saying we should gently be weaning people off it
17:27:13 <dcoutts> ndm: 90% of the uses of that define are wrong, but there is nothing else available to use
17:27:19 <dcoutts> ndm: I agree
17:27:39 <dons> ?yow
17:27:39 <lambdabot> When this load is DONE I think I'll wash it AGAIN ...
17:27:41 <ndm> i'm just worried when we have to keep os = "mingw32" on 64 bit Vista with WinHugs and no mingw installed
17:28:04 <ndm> which kind of makes at most one letter in the os string correct
17:28:17 <dcoutts> 'w' ?
17:28:25 <ndm> yeah
17:28:27 <yitz> 3, but permuted
17:28:32 <ndm> you can kind of argue that stands for windows
17:28:52 <ndm> we need to add an osUnpermute function
17:29:13 <ndm> and Oleg can do some type magic to ensure that it is a filtering permutation, and doesn't introduce any new letters not already in the os string
17:29:17 <perhaps404> hi is there an equivalent function to apply from scheme in haskell?
17:29:28 <ndm> perhaps404: ($)
17:29:32 <MyCatVerbs> $?
17:29:35 <ricky_clarkson> perhaps404: There's no need for one.
17:29:36 <dons> > toUpper $ 'x'
17:29:38 <yitz> The "g" stands for : g = (*2) . read . drop 1
17:29:38 <lambdabot>  'X'
17:29:39 <dons> > toUpper 'x'
17:29:40 <lambdabot>  'X'
17:29:46 <shachaf> I don't think ($) is it.
17:29:46 <perhaps404> uh
17:29:56 <shachaf> Isn't it (apply + '(1 2 3)) #=> 6?
17:30:06 <dons> oh, fold?
17:30:09 <perhaps404> i'm writing an evaultor but i need to compute functions with different arity
17:30:12 <mauke> > sum $ [1, 2, 3]
17:30:13 <perhaps404> i have the args in a list
17:30:14 <lambdabot>  6
17:30:18 <shachaf> perhaps404: Haskell functions (generally) have a fixed number of arguments.
17:30:28 <dons> yep, unless they take lists.
17:30:29 <ricky_clarkson> shachaf: Generally?  What exception exists?
17:30:32 <shachaf> perhaps404: The best you can easily get to is probably curry/uncurry-style.
17:30:39 <shachaf> > printf "%d%d" 1 2
17:30:39 <lambdabot>  Add a type signature
17:30:42 <shachaf> > printf "%d%d" 1 2 :: String
17:30:42 <lambdabot>  "12"
17:31:08 <shachaf> > printf "%d%d" 1 2 :: IO ()
17:31:09 <lambdabot>  <IO ()>
17:31:25 <perhaps404> yeah but that will give me a different type each time and the compiler complains...
17:31:36 <shachaf> @source Text.Printf
17:31:36 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
17:31:40 <yitz> :t printf
17:31:42 <lambdabot> forall r. (PrintfType r) => String -> r
17:31:51 <shachaf> perhaps404: What would the type of this "apply" function be?
17:32:23 <perhaps404> i figure it wouldn't be possible, it would be like...
17:32:32 <mmmdonuts> perhaps404: apply f l = foldl f (head l) (tail l)
17:32:34 <Valodim> I can use guards in "where" subfunctions, right?
17:32:48 <mmmdonuts> then: apply (+) [1,2,3]   => 6
17:32:48 <perhaps404> apply :: (a->b->c...) -> [a] -> d?
17:32:53 <yitz> Valodim: yes
17:33:03 <mauke> a->b->c... is not a valid type
17:33:12 <Valodim> so why does that give me a syntax error. dang
17:33:22 <mauke> I can give you apply :: ([a] -> b) -> [a] -> b, though
17:33:31 <yitz> > let f x = x + b where {b = 3}
17:33:31 <lambdabot>  Parse error at end of input
17:33:50 <perhaps404> mauke: whats the name of that function
17:33:54 <mauke> perhaps404: ($)
17:33:56 <yitz> well, it works in ghci
17:33:59 <shachaf> @check \f x -> (not (null x)) ==> (foldl1 f (x::[Int])) == (foldl f (head x) (tail x))
17:34:02 <lambdabot>  OK, passed 500 tests.
17:34:09 <mauke> perhaps404: also known as 'id'
17:34:41 <mmmdonuts> mauke, $ doesn't let you apply a function to a list of arguments unless the function already takes a list.
17:34:51 <Valodim> if I redeclare a variable in a where subfunction, does that override the variable of the superfunction?
17:34:53 <perhaps404> mauke: heh guess i gonna differentiate between arity then
17:35:09 <mauke> mmmdonuts: yes
17:35:15 <yitz> Valodim: yes. ("shadowing")
17:35:15 <shachaf> > let { f x = x + b where { b = 3 } } in f 5
17:35:16 <lambdabot>  8
17:35:26 <yitz> ah, tnx
17:35:42 <mauke> > let { f x = x where { x = 3 } } in f 5
17:35:43 <lambdabot>  3
17:35:54 <perhaps404> well actually i can change the function to take a list and decompose it inside the function
17:36:02 <perhaps404> that might work
17:37:06 <Valodim> so why doesn't this work .V.
17:37:09 <Valodim> http://hpaste.org/4605
17:37:17 <Valodim> gives a parse error on the first guard of subRoute
17:37:29 <loupgaroublond> i'm getting some errors with imports, when compiling packages from hackage.  what does this mean:
17:37:29 <loupgaroublond>     Could not find module `Data.Tree':
17:37:29 <loupgaroublond>       it is a member of package containers-0.1.0.0, which is hidden
17:37:50 <mauke> Valodim: remove the first =
17:37:52 <shachaf> Valodim: Extra =.
17:38:10 <Valodim> ...
17:38:13 <Valodim> >_<
17:38:15 <Valodim> thanks
17:38:17 <shachaf> loupgaroublond: It means the package is from before the base split.
17:38:38 <shachaf> loupgaroublond: Either use a newer version with a proper cabal file, or add containers to build-depends.
17:38:55 <Valodim> got it
17:39:31 <loupgaroublond> shachaf: bitrot?
17:39:49 <loupgaroublond> shachaf: is there a bug tracker for these packages in general? or do i have to contact each author?
17:39:52 <shachaf> loupgaroublond: Well, the base split is pretty recent.
17:40:07 <shachaf> loupgaroublond: Many packages haven't been updated yet.
17:40:13 <shachaf> loupgaroublond: Not that I know of, but maybe.
17:40:50 <loupgaroublond> ah, i can edit cabal files then
17:42:26 <Valodim> works blazing fast now
17:42:32 <Valodim> wrong result but... well, it works :P
17:42:40 <Valodim> sleepy time
17:42:41 <Valodim> later guys
17:43:06 <dcoutts> someone needs to do a survey of hackage packages to find the ones that still do not build with ghc-6.8 and start naming and shaming maintainers
17:44:43 <ndm> dcoutts, that needs to be 100% automated, and done every night
17:44:51 <dcoutts> yes, it does
17:45:11 <dcoutts> and the results need to be published on each page and a summary page
17:45:17 <dcoutts> and occasionally emailed to haskell-cafe
17:45:32 <loupgaroublond> dcoutts: meanwhile, i'm going to have to make patches, in order to package them for Fedora
17:45:35 <dcoutts> ndm: but someone needs to implement that infrastructure
17:45:55 <dcoutts> loupgaroublond: you might want to look at the patches gentoo apply
17:46:06 <dcoutts> loupgaroublond: we have all the standard packages working with 6.8
17:46:12 <dcoutts> 60+ of them
17:46:20 <loupgaroublond> dcoutts: thanks, :)
17:47:12 <dcoutts> darcs get --partial http://www.haskell.org/~gentoo/gentoo-haskell/
17:47:18 <lambdabot> Title: Index of /~gentoo/gentoo-haskell
17:49:16 <loupgaroublond> dcoutts: i don't see any patches stored there
17:49:32 <dcoutts> loupgaroublond: most are simple sed in the .ebuild files
17:49:45 <dcoutts> mostly just adding missing build-depends
17:50:03 <loupgaroublond> ah
17:50:04 <dcoutts> occasionally replacing the Setup.hs with the default
18:03:31 <luqui> does, say, fmap (const 4) need to be non-strict by the functor laws?
18:14:10 <Cale> luqui: In which sense?
18:14:21 <dobblego> what are some good function signatures to demonstrate djinn?
18:14:36 <Cale> @djinn-env
18:14:37 <lambdabot> data () = ()
18:14:37 <lambdabot> data Either a b = Left a | Right b
18:14:37 <lambdabot> data Maybe a = Nothing | Just a
18:14:37 <lambdabot> data Bool = False | True
18:14:37 <lambdabot> data Void
18:14:39 <lambdabot> type Not x = x -> Void
18:14:41 <lambdabot> class Eq a where (==) :: a -> a -> Bool
18:14:50 <dobblego> are they the types it recognises?
18:15:10 <Cale> yeah, I was just checking if Cont was already there :)
18:15:10 <Pseudonym> fmap (const 4) = fmap (const 4 . const undefined) = fmap (const 4) . fmap (const undefined)
18:15:18 <Pseudonym> Did you mean in that sense, luqui?
18:17:11 <Cale> @djinn-add type Cont r a = ((a -> r) -> r)
18:17:20 <Cale> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
18:17:21 <lambdabot> f a b c = a (\ d -> b d c)
18:18:01 <Cale> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
18:18:01 <lambdabot> f a b = a (\ c _ -> b c) b
18:20:25 <chessguy> i don't know if anyone remembers the idea i brought up last week of using haskell to represent a pattern for a chess position, but i have a good example of something that i'd like to be able to represent
18:21:36 <chessguy> there's a particular kind of checkmate where one king is on the edge of the board, then there's an empty rank or file, and then the other king, while the rook is giving check on the rank or file the lone king is on
18:21:57 <dcoutts> @seen Lemmih
18:21:58 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 2h 24m 37s ago.
18:22:35 <dcoutts> @tell Lemmih bencode-0.3 (and thus torrent which deps on it) fails to build for me, src/Data/BEncode.hs:69:18: No instance for (Binary ByteString)
18:22:35 <lambdabot> Consider it noted.
18:22:53 <chessguy> like this: http://hpaste.org/4606
18:24:13 <chessguy> so the pattern would have to capture several notions:
18:24:19 <chessguy> the lone king is on an edge square
18:24:45 <chessguy> the other king is in a position that keeps the lone king from coming off the edge
18:25:05 <chessguy> and the rook is safely giving check on the same rank/file that the lone king is on
18:26:01 <chessguy> am i even making sense?
18:27:30 <chessguy> @users
18:27:30 <lambdabot> Maximum users seen in #haskell: 434, currently: 364 (83.9%), active: 9 (2.5%)
18:28:30 <Cale> chessguy: uh, yeah, I can see how that's checkmate
18:31:46 <chessguy_> Toxaris, i think you were in on this discussion, weren't you?
18:31:53 <wy> Can I use guards in a branch of case express?
18:33:42 <Toxaris> hehe yes I were :)
18:34:26 <Saizan_> > case Just 3 of Just x | x < 2 -> "foo" | x > 2 -> "bar"
18:34:26 <Toxaris> > case 42 of x | False -> error "never called" | True -> show x
18:34:28 <lambdabot>  "bar"
18:34:28 <lambdabot>  "42"
18:34:32 <chessguy> i can represent things like 'king on the edge of the board' easily enough
18:34:50 <wy> Saizan_: Good! Thanks!
18:35:24 <chessguy> it's referring back to previously-referred-to places/pieces that's hard
18:35:52 <Toxaris> chessguy: one and the same rook has to atack the king and be safe?
18:36:01 <chessguy> yes
18:36:36 <Toxaris> what's your general aproach so far?
18:36:54 <Toxaris> how do you represent e.g. "king on the edge of the board"
18:37:02 <chessguy> i don't have one yet
18:37:18 <chessguy> but i can imagine several ways of doing it
18:37:23 <Toxaris> :)
18:37:48 <Toxaris> if you design a small language to represent such things
18:37:52 <Toxaris> you could add variables to the language
18:38:38 <chessguy> you mean a prolog-like language?
18:38:42 <Toxaris> to express stuff like (exists r . isRook r && r `atacks` king && forall p . not (p `atacks` r))
18:39:06 <Toxaris> chessguy: whatever language you want :)
18:39:28 <chessguy> this is what i'm trying to figure out though, what such a language should look like
18:40:11 <syntaxfree> ethical question on #haskell-blah.
18:40:22 <MyCatVerbs> syntaxfree: ...ethics? Here? o_O
18:40:51 <Toxaris> consider such an expression as above. it could be "compiled" to a loop over the list of pieces
18:41:05 <pjd> MyCatVerbs: fast and loose reasoning? :)
18:41:15 <syntaxfree> not here. #haskell-blah
18:42:03 <Toxaris> \board -> any (\r -> isRook r && atacks board r king && all (\p -> not (atacks board p r)) (pieces board)) (pieces board)
18:42:09 <Toxaris> or something like this
18:42:49 <Toxaris> since you have finite domains for your values, you can enumerate all choices instead of real theorem proving
18:43:43 <chessguy> hrmmmm
18:44:47 <chessguy> i'm just not even sure where to start
18:56:31 <dcoutts> @tell Lemmih figured it out, I was building bencode using bytestring-0.9.0.3 but binary had been built against bytestring-0.9.0.1.
18:56:31 <lambdabot> Consider it noted.
18:56:51 <dcoutts> dons: We're going to get these ^^^ issues more and more unless we figure out some solution
18:57:22 <dcoutts> it's not specific to bytestring of course, it just affects core libs more frequently
19:12:48 <dcoutts> @tell Lemmih but torrent really doesn't build, needs updating in several places for ghc-6.8
19:12:48 <lambdabot> Consider it noted.
19:20:56 <TomMD> @messages
19:20:57 <lambdabot> You don't have any new messages.
19:32:12 <aFlag> @messages
19:32:12 <lambdabot> You don't have any new messages.
19:32:26 <aFlag> @tell aflag asd
19:32:27 <lambdabot> You can tell yourself!
19:32:51 <dmwit> ?ask aflag Why do you want messages?
19:32:52 <lambdabot> Consider it noted.
19:33:02 <aFlag> @messages
19:33:03 <lambdabot> dmwit asked 10s ago: Why do you want messages?
19:33:23 <aFlag> dmwit, I was just playing to see how it works
19:33:35 <aFlag> so anyone can leave messages to anyone like that, cool
19:35:38 <dmwit> Yeah, it's a pretty reasonable system.
20:08:54 <sclv> I want to write this in a pointfree way that doesn't look awful
20:08:55 <sclv> concatSTMPs xs = \m -> ($m) =<< xs
20:09:04 <sclv> pl gives me: (. flip id) . (>>=)
20:09:11 <sclv> any better ideas?
20:12:38 <sclv> in my case, another way to look at it is: \xs y -> concatMap ($y) $ xs
20:12:56 <Toxaris> :t \m -> ($m) =<< xs
20:12:58 <lambdabot> Not in scope: `xs'
20:13:06 <Toxaris> :t \xs -> (\m -> ($m) =<< xs)
20:13:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m (a -> m b) -> a -> m b
20:13:08 <scook0> flip $ (>>=) . flip ($)
20:13:25 <sclv> :t flip $ (>>=) . flip ($)
20:13:27 <lambdabot> forall b a b1. (b1 -> (a -> b1) -> b) -> a -> (a -> b1) -> b
20:13:31 <scook0> sclv: it's easier if m is the first parameter
20:13:33 <OceanSpray> is there a function that determines whether a set of numbers in a list are in order/
20:13:34 <OceanSpray> ?
20:13:54 <scook0> hmm
20:13:59 <scook0> should be easy to whip one up
20:14:08 <sclv> m can't be because i'm feeding it into another function.
20:14:48 <sclv> this is the first time i've found something that pointfrees to something small, but still looks hideously obfuscated
20:15:13 <scook0> > and . map (uncurry (<=)) . (\xs -> zip xs (tail xs)) $ [1..3]
20:15:14 <lambdabot>  True
20:15:37 <scook0> sclv: you can pointfree it, pretending m is first
20:15:43 <sclv> the signature I really want, without all the monadstuff, is [a -> [b]] -> a -> [b]
20:15:44 <scook0> and then use flip to change the parameter order
20:16:20 <scook0> OceanSpray: zip a list with its tail
20:16:30 <scook0> map (uncurry (<=)) over the list
20:16:38 <scook0> and use and to check that all the comparisons are true
20:16:46 <Toxaris> sclv: it's almost ap
20:16:48 <Toxaris> :t ap
20:16:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:17:02 <Toxaris> :t (ap .) . return
20:17:03 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => m (a -> b) -> a1 -> m a -> m b
20:17:16 <Toxaris> :t (. ap) . return
20:17:16 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => a1 -> m (a -> b) -> a1
20:17:42 <OceanSpray> :t sip
20:17:42 <lambdabot> Not in scope: `sip'
20:17:45 <OceanSpray> :t zip
20:17:45 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
20:18:00 <scook0> > (\xs -> zip xs (tail xs)) [1..4]
20:18:00 <OceanSpray> with the tail?
20:18:02 <lambdabot>  [(1,2),(2,3),(3,4)]
20:18:05 <OceanSpray> oh
20:18:09 <scook0> that gets you adjacent pairs
20:18:23 <scook0> > map (uncurry (<=)) [(1,2),(2,3),(3,4)]
20:18:24 <lambdabot>  [True,True,True]
20:18:28 <scook0> that compares each pair
20:18:33 <scook0> >  [True,True,True]
20:18:33 <lambdabot>  [True,True,True]
20:18:36 <scook0> > and [True,True,True]
20:18:37 <lambdabot>  True
20:18:42 <OceanSpray> so that's what zip does.
20:18:48 <OceanSpray> ok, thanks
20:19:10 <scook0> OceanSpray: zip just twines two lists together
20:19:17 <scook0> > zip [1..5] "hello"
20:19:19 <lambdabot>  [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
20:19:57 <scook0> zip xs (tail xs) is just one of those cute tricks you pick up
20:20:11 <Toxaris> scook0: use zipWith f instead of map (uncurry f) . zip
20:20:20 <scook0> Toxaris: ah, of course
20:20:34 <sclv> sigh. I'm just going to go with: flip $ concatMap . flip id
20:20:50 * sclv hates the flip
20:20:52 <scook0> sclv: you might want to use flip ($) instead of flip id
20:21:14 <scook0> it's the same thing, but it's clearer
20:21:50 <Toxaris> :t \xs x -> join (xs `ap` return x)
20:21:51 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> a -> m a1
20:22:13 <Toxaris> :t \xs -> join . (xs `ap`) . return
20:22:14 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m (a1 -> m a) -> a1 -> m a
20:22:26 <scook0> sclv: oh, have you seen the "swing" combinator?
20:22:40 <Toxaris> :t \xs -> (join .) .  ap . (. return)
20:22:42 <lambdabot> forall t a a1 a2 (m :: * -> *). (Monad m) => t -> (m a2 -> a1 -> a2 -> a) -> (a2 -> a1) -> a2 -> a
20:22:50 <scook0> Prelude> :t swing concatMap
20:22:50 <scook0> swing concatMap :: a -> [a -> [b]] -> [b]
20:23:03 <Toxaris> hmm. whatever. have to go now.
20:23:09 <sclv> o_O
20:23:19 <scook0> :t concatMap
20:23:20 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
20:23:58 <scook0> :t let swing f c a = f ($ c) a in swing (=<<)
20:23:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => a -> m (a -> m b) -> m b
20:25:33 <sclv> awesome!
20:26:18 * monochrom has made some haddock docs for a few number-theory routines he wrote many years ago.
20:26:24 <OceanSpray> :t mapM
20:26:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:34:22 <sclv> (flip $ swing (=<<)) it is!
20:42:48 <OceanSpray> is Either a monad?
20:42:59 <wy> got another strange layout error from Daume's tutorial http://hpaste.org/4609
20:43:01 <scook0> OceanSpray: Either String is
20:43:14 <OceanSpray> oh boy.
20:44:22 <wy> I hate layout
20:45:32 <scook0> wy: then/else need more indentation than if
20:46:50 <wy> scook0: That's autoindented by haskell-mode
20:50:44 <OceanSpray> somehow, writing >, <, and = that take any number of arguments is harder than expected.
20:50:57 <wy> Yet another layout problem: http://hpaste.org/4610
20:52:19 <monochrom> Eh? Please align "let" with "if".
20:52:41 <monochrom> Anyway, auto-indentation for Haskell is undecidable.
20:53:12 <sclv> wy: you have a let but no in!
20:53:39 <notsmack> sclv: that's fine in do notation
20:53:39 <wy> monochrom: But isn't if in the scope of let ?
20:53:47 <monochrom> Supposed  to be no "in". Inside "do" we are.
20:54:15 <notsmack> wy: no, the let affects everything after it
20:54:24 <sclv> ah -- yes, it's the indentation that's the issue
20:54:32 <monochrom> do { x <- xxx; let y = sin x; print y }
20:54:44 <monochrom> This is a special "let" inside "do".
20:55:21 <wy> monochrom: Gosh. Now I know
20:55:37 <sclv> @undo do { x <- xxx; let y = sin x; print y }
20:55:38 <lambdabot>  Parse error at "}" (column 39)
20:55:56 <monochrom> If you really want to use "let in" inside "do", you can, but I claim you seldom should.
20:56:46 <wy> monochrom: I guess that's because it's scope is to the end
20:57:41 <wy> Layout is really trouble
20:57:59 <wy> Save the tab key!!
20:58:08 <monochrom> "do" is also full of magic.
20:58:40 <monochrom> The combination of the two is a very potent Turing Test.
20:59:08 <monochrom> If you understand the combination, you are not a human. :)
21:01:40 <wy> What's the benefits of monads, I haven't seen yet
21:02:55 <monochrom> Certain generalities. Like the benefits of Integral: can write one single gcd code that works for all.
21:03:16 <allbery_b> monads let you create libraries that implement functionality that otherwise would have to be designed into the language
21:03:21 <monochrom> One single sequence_, one single mapM_, ... works for all Monads.
21:03:43 <notsmack> one do-notation
21:03:52 <monochrom> ONE MONAD TO RULE THEM ALL. ONE MONAD TO BIND THEM. ONE MONAD TO RETURN THEM TO ... err I guess Monad again.
21:04:34 <monochrom> Someone should translate that to Mordor speak. :)
21:05:07 <shachaf> monochrom: "Join them"?
21:05:14 <luqui> monochrom, "auto-indentation for haskell is undecidable"
21:05:16 <luqui> what?
21:05:30 <monochrom> If you say "join" you will have to add "fmap" somewhere.
21:05:47 <shachaf> monochrom: Well, you can call it "map".
21:05:58 <monochrom> If you just use the bind-return pair you need not add too many sentences.
21:06:06 <luqui> "fmap" kinda sounds like someone getting whacked in the face
21:06:32 <wy> haha
21:06:54 <wy> It really needs more propaganda to convince people
21:07:59 <Cale> I really want to rename fmap to map and (.) (have both to allow for either syntax)
21:08:32 * shachaf is still undecided about (.).
21:08:38 <notsmack> Cale: (.)?
21:08:52 <shachaf> But possibly leaning towards it being fmap; it should at least be tried.
21:09:02 <Cale> Yes, fmap is the same as composition in one instance.
21:09:07 <shachaf> @ty fmap `asTypeOf` (.)
21:09:16 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> a1 -> b
21:09:32 <notsmack> @type fmap
21:09:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:09:37 <notsmack> @type (.)
21:09:38 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:09:40 <Cale> and the important property of composition, that f . (g . h) = (f . g) . h is preserved for any Functor when (.) means fmap.
21:09:50 <wy> Is there a factorial function in the library?
21:10:19 <twanvl> no
21:10:21 <notsmack> > let fac n = product [1..n] in fac 20
21:10:26 <lambdabot>  2432902008176640000
21:10:44 <Cale> > let fac = product . enumFromTo 1 in fac 20
21:10:46 <lambdabot>  2432902008176640000
21:10:52 <sclv> wy: we have a whole library just for factorial functions!
21:11:13 <monochrom> Suppose you have "f x = g x \n where g x = h x \n where h x = g x \n x = 0"  it is undecidable whether you should put x=0 under the first where or the second where.
21:11:17 <notsmack> @pl fac n = product [1..n]
21:11:18 <lambdabot> fac = product . enumFromTo 1
21:11:33 <sclv> its not as good as our fibs though
21:11:54 * sclv thinks there should be an allfibs benchmark suite
21:12:27 <luqui> monochrom, you mean ambiguous?  I'm not seeing how it's undecidable
21:12:52 <wy> monochrom: Layout is the only thing I dislike about haskell
21:13:18 <Cale> wy: why?
21:13:27 <notsmack> wy: what would you prefer?
21:13:29 <wy> tab stops to work. C-M-\ will never work...
21:13:29 <monochrom> Well, I like to think from the POV of the computer. I can't guess what the human wants. I call it undecidable. From human's POV you call it ambiguous.
21:13:33 <luqui> I dislike it in theory, but like it in practice :-)
21:13:36 <shachaf> Cale: Is it preserved across different Functors?
21:13:57 <wy> I'd like to force a ";" behind
21:14:07 <Cale> shachaf: Well, translate the fusion law :)
21:14:31 <Cale> wy: Just make your editor emit spaces instead of tabs.
21:14:32 <luqui> monochrom, I usually equate undecidable with the halting problem... (though it is yet unknown whether undecidable implies turing complete, only vice versa)
21:15:09 <monochrom> There is no terminating algorithm to guess what the human wants.
21:15:38 <luqui> that's only because the decision problem isn't well formed, but we're just being silly anyway, I get it :-)
21:15:51 <wy> Cale: My editor can do that, but I have to push lot more tab keys than before
21:16:09 <Cale> wy: Why>
21:16:10 <wy> And I can't use a stepper, ...
21:16:32 <wy> Because there is no way to indent to the right place with one press
21:16:35 <Cale> wy: Mostly you can configure editors to treat multiple spaces as tabs and only write spaces into the file.
21:17:03 <Cale> If you're using Emacs, there's a Haskell mode which knows how far to indent things, for the most part.
21:17:21 <wy> I'm using it now
21:17:30 <Cale> It has some strange behaviour though, which requires you to sometimes type the start of the line before hitting tab.
21:17:32 <wy> Got another problem...
21:18:06 <wy> Can I use multiple equations with the "let" of do?
21:18:11 <monochrom> Yes.
21:18:16 <Cale> yep
21:18:27 <wy> I got this error "The last statement in a 'do' construct must be an expression"
21:18:32 <luqui> wy, indent the latter equations to the same place the first equation started
21:18:36 <luqui> let foo = bar
21:18:42 <luqui>     baz = quux
21:18:53 <luqui> x <- y
21:18:56 <wy> That's right
21:19:06 <Cale> You can't end with a let.
21:19:32 <wy> Oh, I forgot again...
21:19:38 <wy> This let isn't the real let
21:19:53 <wy> should give it another name
21:20:04 <shachaf> wy: Why not?
21:20:15 <shachaf> wy: It has an implicit in.
21:20:16 <wy> I put "in" on a new line, so the next line got indented two chars...
21:20:26 <shachaf> wy: When it's at the end of a block, where do you put the in?
21:20:53 <wy> I thought the last putStrLn is in the scope of that let
21:21:34 <shachaf> wy: putStrLn?
21:22:02 <shachaf> If you're talking about paste 4610, move the if block to chars to the left.
21:22:09 <shachaf> Or add an "in".
21:22:16 <monochrom> We're past that.
21:23:17 <shachaf> Oh. Not a paste, then?
21:23:32 <wy> No... syntax had never been a problem
21:23:52 <wy> I tried to add all the ";"s back, but it doesn't work
21:24:17 <monochrom> Put in { } also.
21:24:40 <monochrom> This is because you have nested things, like "let" inside "do".
21:25:02 * shachaf again wishes for a real-time multi-user editor to go with #haskell.
21:25:09 <monochrom> do { x <- xxx; let { y = sin x; z = cos x }; print (y,z) }
21:25:20 <wy> monochrom: But you said that let is not the real let. What can I do?
21:25:24 <shachaf> (What is the problem here, if not syntax?)
21:25:40 <shachaf> wy: It is the real let.
21:25:54 <shachaf> wy: With an optional implicit Â«inÂ».
21:26:43 <monochrom> I have a better idea.
21:27:04 <monochrom> Askers should use Windows and turn on that "remote support" thingie.
21:27:15 <monochrom> Answerers should then use that. :)
21:27:41 <sclv> subethaedit ftw
21:28:03 <monochrom> Incidentally that will also trivialize all "I can't install ghc" problems!
21:29:48 <wy> do { x <- xxx; let { y = sin x; z = cos x }; print (y,z) } , so that let is different
21:29:53 <monochrom> I tried: "main = do\n  x <- readLn;\n  let y = sin x;\n      z = cos x;\n  print (y,z)\n"
21:29:54 * shachaf has used Gobby before.
21:29:59 <monochrom> It worked.
21:30:12 <wy> It's block ends before you print (y,z)
21:30:37 <shachaf> monochrom: Why require askers to use Windows? There are VNC/NX/etc.
21:31:03 <monochrom> Linux askers may give root access to answerers.
21:31:28 <monochrom> The point is answerers directly modify asker's computer.
21:31:53 <wy> I need to paste again
21:32:35 <wy> http://hpaste.org/4611
21:33:14 <wy> See if you can add semicolons to make it correct ;-0
21:34:21 <notsmack> wy: there's an extra semicolon
21:34:42 <syntaxfree> > "Alone at 4AM"
21:34:45 <lambdabot>  "Alone at 4AM"
21:35:18 <syntaxfree> > "Maybe I should just dial up someone's cell phone"
21:35:19 <lambdabot>  "Maybe I should just dial up someone's cell phone"
21:35:21 <wy> notsmack: Which line?
21:35:34 <notsmack> in the 'then', i think?
21:36:19 <wy> I doesn't work even if I remove that one
21:36:52 <skew> Is any code available for supero?
21:38:09 <Cale> wy: there's a semi missing after your let block
21:38:36 <monochrom> Yeah, I'm coming to the same conclusion as Cale's.
21:38:42 <wy> Which line?
21:38:50 <Cale> second last nonempty line
21:39:18 <Cale>       factorials = map (\x->fac x) numbers} -- right here
21:39:34 <wy> No. It doesn't work
21:40:06 <Cale> What's the error?
21:40:18 <monochrom> try http://hpaste.org/4611#a1
21:40:52 <monochrom> incidentally I removed some { }. You can put them back.
21:41:07 <monochrom> The point is ; and where to put them.
21:41:57 <monochrom> Techincally the full form should be, e.g., do { ... ; let { x = y; }; ... }
21:42:11 <wy> monochrom: You put two ";"'s after the first let!
21:42:19 <wy> monochrom: Why is that?
21:42:29 <monochrom> You see there are two semicolons after x=y, one is inside, one is outside.
21:42:34 <Cale> http://hpaste.org/4611#a2
21:42:43 <wy> If I remove one, it doesn't work
21:42:48 <monochrom> The inside one is optional. do { ... ; let { x=y}; ... }
21:43:00 <monochrom> The outside one is mandatory (clearly).
21:43:16 <monochrom> Now, suppose you remove { }.  do { ... ; let x=y; ... }
21:43:31 <monochrom> Then computer thinks your ; is the inside one, and ignores it.
21:43:32 <Cale> It's easier just to get the indentation right, perhaps :)
21:43:40 <monochrom> Then it can't find the mandatory outside one!
21:44:08 * ddarius has never ever gotten bitten by this if-in-do issue.
21:44:10 <wy> Cale: Right it's easier... although still confusing to me
21:45:20 <wy> monochrom: So the layout of the semicolon matters?
21:45:46 <monochrom> I wouldn't say that. Getting your intention across to the computer matters.
21:45:59 <wy> I've never seen a semicolon at the beginning of a line
21:46:12 <monochrom> If you write "let x=y" and ";" on the same line, there is no way the computer can deduce you mean ";" to be the outside one.
21:46:41 <wy> What does "outside" mean?
21:46:56 <wy> Can you add more { } 's to make it clear?
21:47:01 <monochrom> Yes.
21:47:13 <monochrom> I am sure I defined outside above.
21:47:28 <monochrom> <monochrom> Techincally the full form should be, e.g., do { ... ; let { x = y; }; ... }
21:47:33 <monochrom> <monochrom> You see there are two semicolons after x=y, one is inside, one is outside.
21:47:41 <ddarius> {}'s are what turn layout off.
21:47:52 * ptolomy wishes for views.
21:47:57 * ddarius doesn't.
21:48:21 <monochrom> If you put ";" on a separate line, then the computer finds it clearly outside. For example you can even put ";" at the beginning of a new line, no spacing.
21:48:44 <wy> I changed it to {..}, but it doesn't work
21:48:53 <monochrom> Put ; after {}.
21:49:04 <monochrom> It happens again in your main.
21:49:41 <monochrom> You have "let {fac 0 = ....}", no semicolon after "}".  It causes another parse error.
21:50:00 <monochrom> Remember Haskell is not C.
21:50:12 <monochrom> "}" does not imply "};".
21:50:35 <wy> SML hasn't such a complex syntax rule
21:50:54 <monochrom> SML doesn't have do-notation.
21:51:02 <ptolomy> I'm slightly amused and slightly distressed by how it would take me a matter of a couple hours to implement real closures and futures in my interpreter, but other dirtier imperative things are still escaping me.
21:51:45 <monochrom> SML makes you write "let ... in ... end", not just "let ... in ...".
21:51:47 <skew> wy: what is complicated? The rules for using completely explicit punctuation are quite simple
21:51:50 <notsmack> wy: layout is pretty simple
21:51:51 <wy> This is frustrating
21:51:58 <monochrom> If SML had a do-notation, it would be "do ... od", not "do ...".
21:52:08 <skew> wy: braces around, semicolons between each thing
21:52:14 <monochrom> Would you rather have that?  Perhaps you do.
21:52:25 <skew> do {let {x = blah; y = other}; action; action2}
21:52:48 <wy> Why not use a C syntax inside do ?
21:52:50 <wy> hehe
21:53:00 <monochrom> Why use a bloody C syntax inside do?
21:53:06 <wy> C doesn't need a ; after {...}
21:53:14 <monochrom> I actually think that's wrong.
21:53:23 <puusorsa> it does, sometimes
21:53:24 <skew> you don't need that in Haskell either
21:53:31 <monochrom> It's one of those "let's make a special case to save typing".
21:53:34 <skew> you need ; between items in a brace group
21:53:39 <wy> As long as the parser can know your indention, that's correct
21:53:44 <puusorsa> try struct foo = { int a; float b; }
21:54:00 <monochrom> And yeah, what puusorsa says.
21:54:04 <ptolomy> I haven't been paying attention; is there a Parsec for Bytestrings yet?
21:54:10 <monochrom> It's bloody incomplete and inconsistent. Both.
21:54:12 <skew> ptolomy: there is a ReadP
21:54:40 * ptolomy is confused and frightened by ReadP.
21:54:49 <ptolomy> .. and spoiled by buildExpressionParser and the like.
21:54:50 <wy> Doh. Let's go to Lisp parens
21:55:05 <puusorsa> haskell syntax is simplish, just think of ; as a newline
21:55:21 <puusorsa> and { .. } as indentation block
21:55:27 <skew> puusorsa: no! separator not terminator
21:55:33 * ptolomy writes complicated template-laden C++ all day.. haskell seems simple.
21:55:37 <wy> But sometimes aligned if ... else work, sometimes not
21:55:39 <ptolomy> (syntactically)
21:55:51 <ddarius> ptolomy: Kind of.
21:55:57 <puusorsa> skew, i don't know if what i said is right but it works for me
21:56:14 <skew> wy: if you want to know why, first learn very simple fully braced syntax
21:56:37 <skew> wy: then puzzle through the layout algorithm from the report about 3 times
21:56:37 <puusorsa> isn't do { something; somethingelse; }; legal?
21:56:39 <ddarius> wy: That's consistent.  People want to change stuff so that there is a special case to make it work.
21:56:43 <monochrom> "else" is not intended to be aligned with "if".
21:56:44 <ddarius> puusorsa: Yes.
21:58:11 <skew> so, is there released code for supero?
21:58:18 <a2dk> Hi. With a [(Int,Bool)] how do I filter on (_,True) ?
21:58:18 <ddarius> skew: I'm pretty sure no.
21:58:40 <ddarius> skew: I'm pretty sure you can get at it, though I may be wrong, but that it hasn't been "released."
21:59:04 <ddarius> > [x | (x,True) <- [(1,False),(2,True)]]
21:59:07 <lambdabot>  [2]
21:59:09 <wy> haskell-mode doesn't even give me the choice of putting else there. Aligning with if is the only choice
21:59:19 <notsmack> > filter snd [(1,False),(2,True)]
21:59:20 <lambdabot>  [(2,True)]
21:59:34 <wy> Maybe I should disable haskell-indent-mdoe
21:59:36 <a2dk> Thanks
21:59:42 <monochrom> Use a bit of manual spacing.
22:01:11 <clanehin> With the new System.Timeout, you can profile non-terminating programs.  Cool.
22:01:56 <monochrom> I mean as a workaround for the moment. The "if" alignment should be changed in haskell-indent-mode.
22:11:44 <wy> I should try liskell
22:13:48 <monochrom> hehe
22:15:39 <wy>   (defdata IList
22:15:39 <wy>   (INil)
22:15:39 <wy>   (ICons Integer IList))
22:15:46 <wy> Looks nice
22:16:49 <wy> No cluttering commas, square braces, can use names-with-much-more-symbols-you-like
22:16:52 <aFlag> if I used emacs I'd probably even learn some lisp
22:17:42 <wy> There is almost no syntax, because it's just a AST
22:18:17 <ddarius> data IList = INil | ICons Integer IList  there are only two punctuation symbols there and both of them laced with meaning.
22:23:42 <Korollary> I think in emacs, I am going to swap '_' and '-' as subtraction is rarer than _ in variable names and pattern matches.
22:25:07 <wy> "|" is indeed carrying some meaning
22:25:58 <wy> But I have no doubt of Lisp syntax, because there is no syntax
22:26:35 <ddarius> I can certainly have a Lisp implementation give me a syntax error.
22:27:20 <Korollary> I sometimes forget the parens around a single var in a lisp let block
22:29:47 <wy> Korollary: Then you must used some imperitive style
22:31:03 <Korollary> Eh?
22:33:58 <luqui> it's not so much about the lisp compiler giving me a syntax error, but lisp giving my brain syntax hemorrhages...
22:35:01 <OceanSpray> how do I pattern match against multiple data constructors?
22:35:26 <OceanSpray> data D = A | B | C
22:35:34 <luqui> Korollary, I've mapped the whole top row of my keyboard to their shifted equivalents.  Quite a headache when I use somebody else's machine :-)
22:35:43 <OceanSpray> case something of A | B -> ... ?
22:35:54 <luqui> OceanSpray, you kind of don't
22:36:19 <luqui> helper functions may be necessary:  isA A = True; isA _ = False; etc.
22:36:35 <OceanSpray> well, damn
22:36:43 <luqui> (the reason is that usually data constructors come with data, which doesn't generalize nicely to multiple matches in a single case)
22:37:06 <wy> OceanSpray: Can you show me the code?
22:37:30 <OceanSpray> it's ugly as hell, but ok
22:37:33 <OceanSpray> @hpaste
22:37:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:37:38 <Korollary> luqui: That's a good idea (top row)
22:38:03 <luqui> (except = actually :-)
22:39:26 <OceanSpray> http://hpaste.org/4612
22:39:33 <OceanSpray> I wonder why it doesn't announce anymore.
22:40:46 <OceanSpray> it works, but I'm looking for a way to shorten that big ol' block of repetition.
22:41:25 <ddarius> OceanSpray: The bot has to be in channel for that to work.
22:41:41 <skew> OceanSpray: are you expecting that to work like OCaml?
22:41:58 <OceanSpray> I have no idea how OCaml works.
22:42:03 <OceanSpray> looking at that,
22:42:11 <OceanSpray> do you have any idea how to shorten it?
22:42:16 <skew> luqui: the generalization to data is to require the same variable names in each patterns
22:42:41 <luqui> skew, with same types also...
22:42:45 <luqui> I rarely ever see that
22:42:55 <luqui> though that could be because I design my code so that I don't have to multiple match
22:42:59 <luqui> circular reasoning :-)
22:42:59 <Jomyoot> Is there a guide to building data files with Haskell?
22:43:28 <luqui> OceanSpray, ooh ooh pattern guards
22:43:31 <wy> OceanSpray: So you want to combine (Nothing, _) and (_,Nothing) ?
22:43:44 <Cale> Jomyoot: Like, files with a particular binary format?
22:44:00 <Jomyoot> for storing objects onto files
22:44:04 <Jomyoot> B-Tree stuff?
22:44:07 <OceanSpray> what's pattern guards?
22:44:17 <Jomyoot> random access file structure for storing data chunks
22:44:17 <luqui> oh wait, pattern guards only and together, don't they :-(
22:44:42 <Cale> Jomyoot: Um, I suppose you could use the binary package for that.
22:44:49 <luqui> OceanSpray, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
22:44:51 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
22:45:19 <luqui> OceanSpray, maybe that page will give you some ideas though
22:45:44 <ddarius> Cale: You ever read "Probability Theory: The Logic of Science"?
22:45:52 <Cale> ddarius: nope
22:46:10 <Jomyoot> This is this book "Purely Functional Data Structures" that makes me wonder if I should build datastructure/file structure differently in functional languages
22:46:12 <luqui> OceanSpray, also to combine the (Nothing,_) and (_,Nothing), you can just use (_,_), since you already matched against (Just _, Just_)
22:46:48 <Cale> Jomyoot: Usually it's in-memory datastructures which are different.
22:46:49 <luqui> OceanSpray, and for heaven's sake line up your equals signs! :-)
22:46:51 <OceanSpray> luqui, I'm trying to throw usable error messages here.
22:47:03 <Cale> Jomyoot: because of the immutability and laziness
22:47:07 <luqui> ahh, well what part of the code are you trying to refactor with multiple matches then?
22:47:15 <Jomyoot> I didn't buy that book and wonder if I should.
22:47:16 <Cale> Jomyoot: On disk, things pretty much look the same
22:47:45 <OceanSpray> luqui, everything below lispCmp
22:48:00 <ddarius> Disk formats tend to have totally different constraints and trade-offs.
22:48:07 <OceanSpray> the variants of eq that I use in defining my comparison operations.
22:48:15 <luqui> ahh I see
22:49:29 <luqui> yeah, the best I can see is to define isNumber, etc., which is not really a win (unless you have code like this in a lot of places)
22:49:57 <OceanSpray> this is the only place I have something like this.
22:50:11 <OceanSpray> Is there really no way to make things shorter?
22:50:49 <OceanSpray> I mean, you guys always make functions extremely succint with folds or something
22:51:14 <luqui> well you might, but I wouldn't say you would gain any readability :-p
22:51:32 <luqui> you'd have to define the fold over your data constructor
22:51:54 <luqui> data X = A | B | C  becomes a -> a -> a -> a
22:51:58 <wy> Can I fix unary (-)'s precedence?
22:52:19 <luqui> data X = A Int | B String | C becomes (Int -> a) -> (String -> a) -> a -> a
22:52:33 <luqui> but I find that totally messes up any readability your program had :-)
22:53:17 <ddarius> OceanSpray: Your code presumably could be shortened without doing anything particularly different.
22:53:46 <luqui> OceanSpray, wait a sec... something is fishy in that code
22:53:51 <luqui> eq val _ = Left val
22:53:55 <luqui> eq _ _ = Right False
22:53:59 <luqui> those are overlapped
22:54:09 <luqui> you'll never get to Right False...
22:57:30 <OceanSpray> hmm
22:58:23 <olsner> after the eq Null Null case, I think you can just replace all the other cases with eq _ val = Left val
22:59:47 <olsner> oh, wait, you have a few more constructors of lispvals, so I guess that would differ in behaviour
23:02:42 <quicksilver> OceanSpray: I would combine all the 'number-only' ones like this. numOp (~~) (Number n) (Number m) = Right (n ~~ m); numOp _ (Number_) val = Left val; numOp _ val _ = Left val;
23:03:02 <quicksilver> OceanSpray: then, greater = numOp (>), lesser = numOp (<) etc.
23:03:03 <OceanSpray> wha?
23:03:24 <OceanSpray> what's (~~) ?
23:03:26 <quicksilver> just abstracting out the common pattern between your last four definitions.
23:03:30 <quicksilver> it's a variable :)
23:03:39 <quicksilver> just like n and m
23:04:11 <OceanSpray> huh
23:04:50 <quicksilver> > let (+) = (*) in 5 + 6
23:04:53 <lambdabot>  30
23:05:02 <quicksilver> ^^ symbols are just as free to be variables as alphanumerics.
23:05:10 <quicksilver> > let (~~) = (*) in 5 ~~ 6
23:05:11 <lambdabot>  30
23:05:13 <ZsoL> @src filter
23:05:14 <lambdabot> filter _ []     = []
23:05:14 <lambdabot> filter p (x:xs)
23:05:14 <lambdabot>     | p x       = x : filter p xs
23:05:14 <lambdabot>     | otherwise = filter p xs
23:05:39 <ZsoL> is this the defininition in Prelude?
23:06:31 <quicksilver> probably. Is there something obviously wrong with it?
23:06:45 <ddarius> ZsoL: Which Prelude?  It's probably the definition given in the Report.
23:06:56 <ZsoL> I mean GHC's Prelude :-)
23:07:14 <ZsoL> Guess I could grep for it in the sources
23:07:16 <ddarius> I'd imagine GHC uses foldr there to get foldr/build fusion.
23:07:30 <olsner> the eq case for :/ seems like it would benefit from the monad instance for Either (to remove the nested "case of")
23:07:34 <bos> no, ghc uses exactly that.
23:07:47 <ZsoL> quicksilver, there's nothing wrong with it
23:07:50 <ZsoL> just asking
23:08:01 <quicksilver> olsner: except you'd need (Error LispVal) for that
23:08:05 <quicksilver> olsner: which is a bit odd :)
23:08:09 <ZsoL> ddarius, thanks, I'll dig into it
23:08:15 <OceanSpray> ok, it works now
23:08:20 <OceanSpray> one last question
23:08:31 <OceanSpray> is it really that important for a language to have IO ?
23:08:46 <ddarius> OceanSpray: It depends on what the language is for.
23:09:04 <OceanSpray> proof-of-concept project.
23:09:17 <ddarius> E.g. I don't think SQL has any inherent IO facilities.
23:09:52 <olsner> hmm, so you'd have to add an instance Monad (Either LispVal) to shave off two lines in one definition... worth it?
23:09:52 <ddarius> OceanSpray: If you can show values and have some kind of REPL, it should be fine enough.
23:10:00 <OceanSpray> ok then.
23:13:28 <glguy> ?seen dons
23:13:29 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 5h 43m ago.
23:16:49 <ddarius> Death is inconvenient.
23:16:55 <sjanssen> bos: it isn't quite so simple, there are rules that replace the normal defn. with a foldr and build version
23:17:53 <bos> sjanssen: yes, but that's the version in GHC.Base
23:18:04 <dons> yow
23:18:17 <Lemmih> dcoutts: There's a version of Binary that doesn't have an instance for ByteString?
23:18:17 <lambdabot> Lemmih: You have 3 new messages. '/msg lambdabot @messages' to read them.
23:18:53 <Lemmih> dcoutts: Oh, OK.
23:19:11 <nanothief> hey I'm having an ld error with the code at http://hpaste.org/4613. It was taken from the all about monads tutorial. I've never had a link error with haskell before, so I don't know what causes them
23:20:22 <Lemmih> nanothief: You probably want --make.
23:20:31 <ddarius> sjanssen, dons: Those little logos at the bottom of xmonad.org should be likns.
23:22:15 <nanothief> ddarius: thanks that worked
23:22:20 <nanothief> never thought of using make
23:22:54 <ddarius> nanothief: Well I didn't say anything, but always use --make unless you have a reason not to.
23:23:08 <nanothief> woops sorry Lemmih :P
23:23:34 <ddarius> dons: Besides fromIntegral, what was the other question/answer I thought lambdabot should automatically answer?
