00:02:03 <Sizur> @users
00:02:03 <lambdabot> Maximum users seen in #haskell: 434, currently: 369 (85.0%), active: 5 (1.4%)
00:05:14 <Plareplane> @type liftM
00:05:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:06:57 <Jomyoot> do I need to understand monad beyond just sequencing things under "do"?
00:07:51 <smack_> Jomyoot: depends what you want to do
00:07:55 <Plareplane> i think >>= can be more than just sequencing
00:08:12 <Jomyoot> for typical uses. is "do" good enough?
00:09:19 <Sizur> well, that depends on what your typical usage is
00:09:48 <Jomyoot> Typical IO and sequencing actions
00:09:49 <Philippa_> you can do everything with do except define your own monad
00:09:52 <Sizur> if it's just to code for the end-user, then yeah
00:09:58 <Jomyoot> similar to (progn ...)
00:10:22 <Jomyoot> and when I become more proficiant at Haskell then I can learn more special stuff
00:10:31 <Jomyoot> What's a good IDe for haskell
00:10:42 <Sizur> each monad defines what sequencing means
00:10:59 <roger`> Jomyoot: many people use Emacs or vim
00:11:48 * Sizur will learn emacs one day. even if it'll take him 200 man-years
00:12:31 * scook0 intends to migrate from gedit ... some day ...
00:12:35 <roger`> i think it takes 5 minutes to learn the basics
00:12:37 <Sizur> Jomyoot: i just use gedit (it has better haskell highlights than kate)
00:13:09 <shachaf> Jomyoot: You should learn about monads in terms of (>>=)/return.
00:13:32 <Jomyoot> what are great apps writen with haskell?
00:13:45 <shachaf> Jomyoot: GHC. :-)
00:13:53 <Jomyoot> well
00:13:55 <Jomyoot> any end-user app?
00:13:57 <shachaf> (Well, about 3/10 Haskell, it seems.)
00:13:58 <Sizur> Jomyoot: darcs
00:13:58 <Korollary> darcs
00:14:10 <Korollary> happs
00:14:17 <shachaf> Jomyoot: Xmonad.
00:14:27 <Jomyoot> any mathematical packages?
00:15:06 <Sizur> Jomyoot: haskell = Matlab^2
00:15:25 <Korollary> Not quite
00:15:32 <Korollary> libraries are important
00:15:34 <Sizur> 2^Matlab?
00:15:37 <Sizur> :P
00:15:42 <Jomyoot> matlab written with haskell?
00:15:52 <Jomyoot> is it suitable for AI as Lisp is?
00:15:59 <glguy> lol
00:16:18 <Sizur> sure it is, but nobody wrote a lib for neuralnets yet
00:17:37 <Jomyoot> is haskell naturally fast? or we must do hacks and hintings to make it fast?
00:18:21 <Korollary> It's pretty fast and gets quite fast with hints, yes.
00:18:26 <Sizur> Jomyoot: haskell is at a very high abstraction level. for that, ghc implements it very fast
00:18:34 <Korollary> +er
00:19:01 <Sizur> i'm very surprised at how fast ghc compiles all that
00:19:12 <Sizur> i mean how fast the compiled code runs
00:19:44 <Sizur> of course you can always write a faster code in C, but it'll take you much longer to do so
00:20:31 <Sizur> coding time and complexity grows exponentially with the complexity of your problem if you implement the solution in C
00:20:37 <Sizur> not so much in haskell
00:21:01 <scook0> Sizur: it's easy to be "faster than C" if you have to write the C program yourself :)
00:21:19 <Sizur> scook0: that's not fair
00:22:08 <Sizur> C is designed to please the cpu. haskell is designed to please the mathematician
00:22:24 <Korollary> Java beats C in some benchmarks due to hotspot optimizations using real data.
00:22:36 <scook0> what I mean is that if you can write a correct program in Haskell, but you can't write the same program in C without your brain exploding, then the Haskell version is "faster"
00:22:43 <Sizur> yeah, sun jvm is a beauty
00:23:55 <scook0> how does GHC compare to JVM/CLR these days, roughly speaking?
00:24:04 * scook0 goes to check the shootout...
00:24:56 <Sizur> ghc team should start real optimizing soon
00:25:25 <scook0> what do you mean by "real"?
00:26:34 <Sizur> i read on their site that they have not even started to do real optimizations yet
00:26:50 <Sizur> #1 priority is correctness
00:27:19 <Sizur> so potentially it can beat all compilers
00:28:05 * Sizur thinks ghc already beats others
00:29:38 <allbery_b> thought jhc beat ghc on some things because of wwhole-program optimization
00:34:07 <Jomyoot> why haskell over lisp though. that's another functioanl language
00:35:28 <Korollary> lispers typically call lisp a multiparadigm language. It's not heavy on functional by culture/libraries.
00:35:50 <Korollary> There are other functional languages like scheme, ocaml, etc.
00:36:02 <ehaas> c++ templates
00:36:08 <allbery_b> ((think (layout is bad?)) (try (keeping track) (of (all (those parens))))))
00:36:08 <Korollary> It more or less depends on what features you prefer.
00:36:12 <allbery_b> :p
00:36:39 <Jomyoot> haskell has the largest channel here though
00:37:00 <allbery_b> (p.s. may that be the last time I ever try diagramming a sentence via sexpr...)
00:37:04 <Korollary> We're just very cool and friendly people.
00:37:09 <Tela> I feel like Haskell promotes high abstraction through semantics, lisp through syntax.
00:37:41 <ehaas> allbery_b: now diagram a sentence using GADT's
00:37:48 <Tela> Though I think I tried to make that such a soundbite it came out funny
00:38:26 <Korollary> Tela: What you said is generally true about lisps. I don't know what you meant by semantics.
00:39:42 <Tela> I wanted to suggest that Haskell abstracts things through higher order functions and other fun aspects of currying and the like. It's a very different method of abstraction than macros
00:39:51 <shivernz> @hoogle munch
00:39:51 <lambdabot> Text.ParserCombinators.ReadP.munch :: (Char -> Bool) -> ReadP String
00:39:52 <lambdabot> Text.ParserCombinators.ReadP.munch1 :: (Char -> Bool) -> ReadP String
00:40:18 <Jiten> with Haskell, if you don't model your dataflow properly, the code gets really messy really fast.
00:40:18 <allbery_b> ehass: alas, that's one area where lisp wins:  it's largely typeless --- as are natural languages.  (that pair of sentences broke several formal rules, for instance)
00:40:40 <allbery_b> I can slap together a sexpr without worrying too much about missing components or incorrect types
00:40:44 <Korollary> Tela: and with types
00:41:32 <Tela> Yes, definitely â€” once again, those seem more "semantic" to me, concerned with the meaning of your code, than syntactic.
00:42:40 <Tela> That being said, there are interesting DSLs you can write in Haskell, too. I haven't played with TH at all, but I'm sure that widens the possibilities even more...
00:43:47 <scook0> TH can be a pain, though
00:44:14 <osfameron> has anyone tried the "fluent numbers" DSL that Ruby and Perl folks were blogging recently ?
00:44:32 <scook0> osfameron: got a good link?
00:44:37 <Sizur> i'm trying my hand at a relational model in haskell. problem with the mainstream type system is that you need to keep adding higher level types. type -> class -> kind -> ???
00:44:38 <Tela> Wasn't there some sort of sexpr Haskell people were writing about? I wonder how TH works in that...
00:45:19 <osfameron> scook0: http://beautifulcode.oreillynet.com/2007/12/the_cardinality_of_a_fluent_in.php  and then http://thegestalt.org/simon/perl/Numbers.pm
00:45:20 <lambdabot> Title: The Cardinality of a Fluent Interface - Beautiful Code, http://tinyurl.com/362mzq
00:45:35 <scook0> osfameron: heh, already found it :)
00:45:45 <scook0> looks pretty crazy
00:46:10 <scook0> actually, I have a feeling that Haskell can probably do that sort of thing at compile-time, using type hackery
00:46:15 <osfameron> Simon's thread on l.pm starts http://london.pm.org/pipermail/london.pm/Week-of-Mon-20071217/011834.html
00:46:16 <lambdabot> Title: Oh I am *bad* and *wrong*, http://tinyurl.com/2sng9v
00:46:26 <scook0> (though I won't be the one to implement it)
00:46:36 <osfameron> shiny :-)
00:46:39 <Tela> Just screams for method_missing when I look at it wih Ruby-tinted glasses...
00:46:50 <Sizur> rather it's s problem with the set theory, not with the type system implementing it
00:47:28 <Korollary> Was the term DSL so bad that they had to invent their own???
00:47:34 <Korollary> "fluent interface"
00:49:06 <Korollary> Is this a "toy problem" or a yardstick for fluent interfaces?
00:49:20 <Korollary> I mean, what if you can't implement it. What does it mean?
00:52:50 <ehaas> he calls it a 'code kata'...a way to practice doing this sort of thing...if you can't do it in ruby it means you need more practice
00:52:59 <ehaas> if you can't do it in haskell it doesn't really mean anything
00:53:18 <ehaas> because no haskeller would ever create such an ugly interface :)
00:54:00 <Sizur> simon's implementation simply returns undef when autoload cannot match a method call
00:54:33 <ehaas> i dont know about you guys but i read the jmock example and find it harder to understand than if they had just written it in normal code
00:54:36 <Sizur> and he exports all the number words
00:55:15 <Korollary> ehaas: the code doesn't do anything interesting anyway.
00:55:27 <Tela> I don't quite get the point of this fluent interface thing. It seems potentially easier to read, but much harder to write.
00:55:53 <osfameron> and harder to debug when it inevitably goes wrong
00:56:01 <osfameron> I think it's just a fun exercise
00:56:05 <Sizur> it was just done for fun (perl pawa demo)
00:56:09 <osfameron> which is very much the spirit Simon took it in
00:56:10 <Tela> Reminds me of the "3.times do this() end" idiom in Ruby. People like to show it off, but no one writes code like that.
00:56:23 <osfameron> gah, 3.times is horrible conceptually
00:56:31 <Sizur> yeah, there is a Ruby.pm
00:56:32 <osfameron> it has nothing to do with the number 3
00:57:03 <Korollary> I know no Ruby, so in 3.times, is the message "times" being passed to 3?
00:57:11 <ehaas> yes
00:57:13 <Sizur> osfameron: in OO spirit, i disagree. if you code in OO then everything should be an object, including the object 3
00:57:25 <Korollary> What else does 3 know?
00:57:42 <ehaas> you can make it know anything because ruby has open classes
00:57:48 <Sizur> Korollary: 3 in ruby is an object, and it has methods, and you can give it more methods
00:57:51 <scook0> osfameron: have you ever seen church-encoded numerals?
00:57:54 <ehaas> so you can add methods to Num at runtime
00:58:03 <osfameron> Sizur: yes.  That's a good fit for some methods, but I don't thinke "times" is really a property ofa number.  It seems like it would be the property of a codeblock
00:58:09 <Tela> Other than the times example, most of the methods on numbers are pretty standard, I'd think
00:58:10 <ehaas> one popular one is "upto"
00:58:10 <sjanssen> Tela: nobody writes that way?  "5.times { puts say }" is prominent on ruby-lang.org
00:58:13 <Korollary> Wow. 3 knows almost all of mathematics eh? Good one, 3.
00:58:22 <osfameron> 3++
00:58:29 <Korollary> @karma 3
00:58:30 <osfameron> eeek!  I just changed the value of 4!
00:58:30 <lambdabot> 3 has a karma of 1
00:58:30 <ehaas> 2.upto(5) {|n| print n}
00:59:06 <Tela> sjanssen It's definitely common for really quick code blocks like that, but in more involved code I've rarely ever seen 3.times used.
00:59:39 <Sizur> well, Ruby is trying to match user convenience to conceptual correctness, with convenience bias
00:59:40 <scook0> osfameron: in lambda-calculus circles, it's common to represent the number _n_ as a function that takes _s_ and _z_, and applies _s_ to _z_ _n_ times
00:59:46 <Korollary> 2.upto(5) just looks like syntactic sugar made to seem as if 2 had anything to do with the concept.
00:59:50 <scook0> but that's mathematics for you :)
01:00:02 <ehaas> what concept are you talking about
01:00:04 <ehaas> 2?
01:00:19 <ehaas> remember ruby has no mathematical basis...it's smalltalk + lisp
01:00:23 <Korollary> I suppose I am talking of mapM_
01:00:29 <osfameron> lisp has mathematical basis, no?
01:00:30 <Korollary> and a list
01:00:39 <ginkgo> language shootout
01:00:49 <ehaas> well yes but not in the sense i'm talkign about :)
01:01:14 <ehaas> that little pocket of algebra called type theory
01:01:14 <Tela> I see this fluent interface thing as abstracting the wrong direction. Natural language is a hierarchy based on, say, sentence structure instead of functionality. That seems counterintuitive for thinking about programming.
01:01:15 <ginkgo> ..oh sorry. That did not really belong here.
01:01:55 <Sizur> Tela: there is a functional natural language processor in haskell
01:02:37 <scook0> Tela: well, the point is to *abuse* the syntax you've got, presumably because it's easier than actually extending the syntax
01:02:49 <Korollary> Tela: DSLs don't need to be equivalent to programming languages.
01:03:45 <Tela> That's true. It doesn't keep me from twitching when I see stuff like that JMock example though.
01:04:02 <Korollary> Yeah that JMock example is blah.
01:04:27 <Sizur> re scook0: yeah, and why not if the language allows you to :P who needs all this "discipline" nonsense
01:04:28 <Korollary> Unit tests are programming after all.
01:04:48 <scook0> I mean, C++ has a whole I/O system built on the basis of syntax abuse
01:05:01 <Korollary> Unit tests are also very verbose, so I can see the value for something like atLeastOnce().
01:05:09 <scook0> not to mention some of the crazier boost stuff
01:05:27 <Tela> And the Ruby example. 3.times makes me think that I should be able to do 3.new Apple to create a list of three apple objects, or something similar.
01:06:11 <Korollary> Tela: Since 3 knows all, maybe you can.
01:06:23 <ehaas> all hail 3
01:06:46 <Tela> 3 /is/ the magic number
01:06:49 <Tela> Hmm
01:06:59 <Korollary> and 7 is holy
01:07:25 <Korollary> With all this power, we can write anything.
01:07:28 <Tela> Wow! I just wonder what 7 can do, now
01:08:02 <Korollary> 7.answerprayer ?
01:08:08 <Sizur> 7.main
01:08:08 <Tela> wine = 7.cupsOfWater
01:08:10 <Korollary> We can solve the halting problem
01:08:23 <ehaas> there is a library called activesupport
01:08:32 <ehaas> that adds methods which let you do things like 3.hours.from.now
01:08:36 <Sizur> Korollary: questionmark is part of the methodname
01:08:39 <Tela> Ooh. 7.ask("P=NP?")
01:09:40 <Korollary> I'd like now.if.not.then.in.fifteen.minutes.again.but.no.more.than.five.times.total.
01:09:42 <ZsoL> woo
01:09:56 <Tela> Units are an interesting "fluent interface" perhaps. Has anyone used that Haskell Dimensional Analysis libry?
01:11:42 <Tela> Actually, maybe I misread. /Is/ there a Haskell DA library?
01:12:07 <ehaas> i read a blog post where someone did that once...i dont know if it's a real library though
01:12:07 <Sizur> jhc has no GC :/
01:12:45 <ehaas> would have been useful if they had it for that mars orbiter
01:13:45 <Tela> I think I must have saw this: http://code.google.com/p/dimensional/
01:13:45 <lambdabot> Title: dimensional - Google Code
01:14:19 <allbery_b> dibs on "dimentor"!
01:18:14 <visof> happy "Eid Al-Adha"
01:18:57 <allbery_b> shouldn't that be "Eid al-Adha mubarak!"?
01:19:06 <Sizur> Al applied to the id of E and subtracted Adha?
01:19:47 <wy> Oh, dimensional ... Why is everything I though of is already done...
01:20:47 <Tela> wy those were exactly my thoughts back when I first found that.
01:22:01 <wy> Tela: I was thinking about designing something like that when I was writing my raytracer this semester, because I always forget to multiply something...
01:22:56 <Tela> wy: When I was learning to understand types I thought about doing that as a toy problem because it seemed like a good fit. I think I'll probably still try it someday
01:27:20 <wy> Is there a way to filter those messages in xchat?
01:28:54 <allbery_b> Settings > Advanced > Text Events is all I see (but I'm running an older version)
01:29:09 <allbery_b> (somewhat deliberately as I haven't liked what I've seen of newer ones)
01:29:30 <allbery_b> there are probably scripts which can track netsplits and hide just those
01:32:09 <wy> Can't find the setting in my dumb gnome version. I use this one just because I can click the links to open them in firefox
01:33:56 <quicksilver> irssi ftw!
01:34:02 <quicksilver> it tracks netsplits :)
01:34:28 <roger`> I never seem to notice them in erc, it must do so too.
01:36:13 <Tela> I get smacked with them on Colloquy, but that's because I guiltily chose candymac aesthetics over unix fundamentals. :)
01:36:22 <quicksilver> allbery_b: you could probalby hide all joins and parts? they're not that interesting in a busy channel like this
01:36:53 <allbery_b> yes, that's easy.  find the advanced > text events dialog and delete the contents of the join and part message strings
01:37:32 <allbery_b> or, /set irc_conf_mode 1
01:37:48 <allbery_b> (set it to 0 to re-enable)
01:40:44 <visof> happy feast
01:42:04 * allbery_b doesn't know why there doesn't seem to be a netsplit script in the archive, it's not *that* hard...
01:42:33 <wy__> hello!
01:42:45 <allbery_b> (I do see a message where someone whines that "they look just like oedinary joins/parts", but in fact the parts are easy to distinguish:  it's a pair of server names)
01:43:10 <wy__> This is wy in irssi
01:43:14 <allbery_b> queue those as they're seen, ignore the next join message for that user
01:43:48 <allbery_b> if you want to be pedantic, hook joining the server and grab the output of /links
01:44:44 <visof> hasn't anyone feast this day??
01:51:15 <roconnor> visof: I do
01:51:48 <visof> roconnor do what?
01:51:58 <roconnor> I have a feast this day.
01:52:06 <visof> really?
01:52:17 <visof> what is your feast?
01:52:26 <roconnor> my verjaardag
01:53:19 <visof> it 's Muslim's feast today
01:53:28 <roconnor> oh
01:53:29 <visof> and i'm muslim
01:53:32 <allbery_b> wouldn't that have started at sundown?
01:53:43 <roconnor> visof: different feast for me :)
01:54:09 <visof> :)
01:54:42 <visof> allbery_b ya
01:55:31 <visof> sorry it have started at sunrise this day allbery_b
02:00:02 <allbery_b> ah.
02:02:14 <visof> Allah Akbar Allah Akbar Allah Akbar , La Elah Ela Allah
02:02:35 <visof> Allah Akbar Allah Akbar, Wa LeLLah Alhamd
02:03:13 <trez> oh
02:03:26 <allbery_b> visof: I would kinda hope anyone who really cared would be *away from the computer* right now :)
02:03:52 <visof> why?
02:04:04 <allbery_b> surely they have better things to do?
02:04:17 <visof> may be
02:04:21 <visof> i don't know
02:05:24 * allbery_b doesn't either, but would imagine that a Muslim feast day is not best spent hovering over a computer keyboard
02:06:24 <visof> allbery_b i adore computer
02:06:39 <visof> it's my  only friend
02:09:06 <visof> allbery_b where are you from?
02:11:01 <dozer> allbery_b: any religion that can allow me to hover - on a feast day or otherwise, gets my vote
02:13:43 <allbery_b> visof: The US.  But I'm a Reform Jew
02:14:39 <visof> we are cousin
02:14:56 <Sizur> lol
02:15:14 <visof> hahaha
02:15:39 <visof> allbery_b do you know why?
02:15:54 <visof> have read in history?
02:15:59 <allbery_b> (so I have to work fronm analogy, since I don't trust the predominant US image of Muslims but also don't trust how far the similarities between Judaism and Islam hold, much less whether/how Islam is divided up as compared to how Judaism is)
02:16:00 <visof> have you
02:16:29 <Sizur> let's express our genealogy in haskell
02:16:39 <visof> hahaha
02:16:40 <allbery_b> Have learned some, am still learning, do not trust the current hot buttons.
02:17:45 <Sizur> allbery_b: that's the best position to take, unless of course the hot buttons begin to hurt you
02:18:03 <allbery_b> I did study the history of the Ottoman Empire a couple years ago, which included a minimal introduction to Islam (which I already knew was slanted; secular Turks have their own hot buttons)
02:20:14 <visof> allbery_b did you visit Israel??
02:21:36 <allbery_b> not yet.  not entirely sure if ever --- surely lots to see, but when the PTB seem to be trying to encourage a war to start...)
02:22:37 <visof> what is PTB?
02:24:05 <allbery_b> powers that be
02:24:06 <visof> allbery_b?
02:24:31 <visof> war between?
02:24:41 <allbery_b> the maniacs running the asylum
02:25:55 <allbery_b> who can say?  Israel and Hamas seem to be trying to push each other just shoprt of starting a war, Lebanon keeps threatening to fall into another civil war, yug.
02:27:49 <Plareplane> i thought i was in the wrong channel
02:28:01 <visof> hahahaha
02:28:10 <allbery_b> yeh, probably belongs in -blah
02:28:30 <allbery_b> I could say a lot more but it's hardly worth it
02:30:42 <wy> Is there a way to define types with symbols as constructors, such as data [a] = [] | a : [a] ?
02:31:11 <therp> wy: infix constructors are possible, but not that precise syntax
02:31:20 <sjanssen> wy: you can use infix operators that start with :
02:31:25 <allbery_b> [] is special syntax.  infix constructors are possible but must start with a colon
02:31:53 <therp> @quote stereo
02:31:53 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
02:32:24 <wy> But I can't use [a] on the LHS right?
02:32:33 <Toxaris> wy: no
02:33:50 <quicksilver> wy: [a] is special, and it 'chearts'. You can't do anythign exactly like it, sadly.
02:35:34 <wy> There are many things I can do with those symbols. It seems {} is already used for grouping. So not so much pitty ;-)
02:36:17 <wy> I could have something like [| 1, 2, 3 |] though
02:36:27 <allbery_b> in theory you can use any of the unicode brackets, in practice I don't think you can duplicate list syntax
02:36:53 <allbery_b> either cons-style or list style, because (a) list brackets are special cased (b) so is comma
02:38:09 <wy> > let pred2 (n+1) = n in pred2 4
02:38:09 <lambdabot>  Parse error in pattern at "in" (column 21)
02:39:06 <wy> What's wrong. It worked on my ghci
02:39:21 <Heffalump> does lambdabot have (n+k) patterns turned off?
02:39:30 <sjanssen> wy: lambdabot doesn't support n+k patterns
02:39:51 <piis3141> Does someone have a pointer to an algorithm or Haskell implementation to evaluate if two simple algebraic expressions (like data Expr = Var String | Lit Int | Expr :* Expr etc.) are semantically equivalent?
02:39:53 <dcoutts> is that because the Language.Haskell module doesn't support them?
02:39:55 <wy> sjanssen: That's bad style
02:40:01 <sjanssen> dcoutts: yes
02:40:17 <sjanssen> (we use Language.Haskell to guard against various code injection attacks)
02:41:03 <Heffalump> piis3141: that's not decidable, is it?
02:42:14 <quicksilver> piis3141: evaluate and compare values?
02:42:20 <quicksilver> not quite sure what you're after :)
02:42:24 <wy> Can I find some examples of pattern binding ?
02:42:38 <quicksilver> > let (a,b,c) = (1,2,3) in a+b
02:42:42 <lambdabot>  3
02:42:43 <quicksilver> wy: something like that?
02:42:47 <sime> piis3141: well it depends: first you have to define the semantics of your expressions, i.e., you have to provide a semantic interpretation function (e.g. a standard eval for algebraic expressions) and then you see in what class of problems deciding "eval x = eval y" lies
02:43:35 <roconnor> Heffalump: I think the theory of rings is decidable.
02:43:59 * roconnor ponders this
02:44:10 <piis3141> quicksilver: evaluating is not possible when having variables
02:44:16 <roconnor> or at least the universal fragment is.
02:44:36 <Toxaris> piis3141: bound variables should be no problem :)
02:44:37 <roconnor> The idea would be to put the expressions in normal from.
02:44:53 <piis3141> so for instance I want to check that a*(b+c) = a*c+a*b
02:45:10 <wy> Something like fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]. But that's the only example I found
02:45:20 <quicksilver> piis3141: that kind of problem is solved by defining a sensible normal form
02:45:29 <wy> > let fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] in fib 10
02:45:30 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[t2]'
02:45:31 <quicksilver> piis3141: how it works depends on the exact language
02:46:02 <piis3141> roconnor: do you know a normal form for algebraic expressions
02:46:14 <quicksilver> "algebraic expressions" is meaningless
02:46:23 <quicksilver> it could mean too many things :)
02:46:37 <quicksilver> in a languae with just binary operators, it's simple enough to think of one
02:46:48 <Toxaris> for data Term = Var String | Literal Int | Term :
02:46:53 <quicksilver> but the details depend on what distribution + commutation laws hold.
02:46:55 <piis3141> quicksilver: simple arithmetic
02:47:08 <quicksilver> for example, a*b == b*a but a/b !+ b/a
02:47:10 <quicksilver> for example, a*b == b*a but a/b != b/a
02:47:12 <quicksilver> I mean
02:47:20 <quicksilver> so, your normal form needs to understand this
02:47:39 <quicksilver> since a*b == b*a you might say "compound-* expressions are ordered alphabetically"
02:47:52 <quicksilver> so the normal form of a*c*d*a would be a*a*c*d
02:48:06 <quicksilver> you have a rule like that for every commutative operator
02:48:11 <quicksilver> then you need rules for distribution laws
02:48:21 <quicksilver> (like a*(b+c) = a*c + a*b)
02:48:22 <quicksilver> and so on.
02:48:29 <quicksilver> And you may possibly need to prove confluence.
02:48:34 <quicksilver> It's not *hard* mostly.
02:48:38 <wy> Strange. It doesn't work. It's on the gentle introduction.
02:48:38 <quicksilver> But it can be quite a lot of work.
02:48:42 <Toxaris> for data Term = Var String | Literal Int | Term :+: Term | Term :*: Term   with the usual interpretation of :*: and :+: as * and + on ints on could go for one of CNF / DNF equivalents
02:49:22 <Svrog> > let fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] in take 10 fib
02:49:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
02:49:29 <piis3141> Toxaris: ok, that might be an idea, I will look into that
02:49:32 <quicksilver> Toxaris: plus the understand that you interpret factors/summands as multisets not lists
02:49:40 <quicksilver> Toxaris: because of commutativity.
02:49:53 <quicksilver> Toxaris: which is where my commutation + distribution lawas get you to.
02:50:09 <ZsoL> > let fib@(1:tfib) = 1: 1: [ a+b | (a,b) <- zip fib tfib ] in fib
02:50:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:50:19 <ZsoL> i love that feature
02:50:19 <ZsoL> :-)
02:50:21 <Toxaris> piis3141: it's the same idea as quicksilverr
02:50:38 <dozer> is it possible to get a stack overflow by chosing the wrong one of a foldl/foldr?
02:50:44 <sime> piis: you can pose your problem as a problem in real arithmetic as "\forall FV(x) u FV(y). x = y" where x and y are expressions. Then you can use one of the general purpose thoerem provers like Z3, MathSAT, Yices, ... to solve the problem
02:50:52 <wy> > let fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] in take fib 5
02:50:53 <lambdabot>  Couldn't match expected type `Int' against inferred type `[t]'
02:50:55 <sjanssen> dozer: yes
02:51:15 <dozer> sjanssen: and also if I've effectively coded up the wrong fold manually?
02:51:23 <sjanssen> dozer: yes
02:51:24 <sime> piis: FV means free variables. see: www.smtcomp.org for more information on the current state of these theorem provers
02:51:29 <Svrog> wy: that should be take 5 fib, not take fib 5
02:51:48 <dozer> sjanssen: mm - at least now I have a candidate for my badness
02:51:59 <wy> > let fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] in take 5 fib
02:52:00 <lambdabot>  [1,1,2,3,5]
02:52:02 <dozer> so which one do I want, given that it's processing an arbitrarily long list?
02:52:15 <wy> Svrog: Thanks
02:52:17 <Toxaris> quicksilver: will this normal form stuff really work? it will only show some equalities, not all, will it?
02:52:28 <wy> sjanssen: That's what I mean "pattern binding"
02:52:34 <sjanssen> dozer: what function are you folding?  Is it strict or lazy?
02:52:54 <Svrog> dozer: for strict code foldl, for lazy code foldr
02:53:06 <piis3141> sime: thanks
02:53:08 <quicksilver> Toxaris: that depends if a normal form exists :)
02:53:10 <sime> Toxaris: This depends on the property if the rules ure using to rewrite are confluent, i.e., if there exists always a unique normal form
02:53:18 <quicksilver> Toxaris: if you can show that a normal form exists, and is unique, then it works.
02:53:34 <dozer> Svrog;sjansen: I'm assuming it is lazy - I've got no strictness annotations on it
02:53:43 <Toxaris> quicksilver: :) i show that it works, then it works.
02:53:49 <quicksilver> Toxaris: constructive logic is confluent and strongly normalising, and therefore certain versions of the lambda calculus are.
02:54:02 <quicksilver> but it's not that hard to break the property by adding stuff to the language.
02:54:06 <vincenz> Woo
02:54:09 <vincenz> http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html?
02:54:09 <lambdabot> Title: Research Highlights - More Haste Less Speed, http://tinyurl.com/3ao43y
02:54:18 <Toxaris> but even a simple case like   x + x == 2 * x   looks not too easy to me
02:56:12 <piis3141> it all depends on the normal form, I guess
02:56:41 <Svrog> dozer: if you're constructing something like a list go with foldr - if you're adding a bunch of numbers or doing something where the result will just be a single value use foldl
02:57:29 <dozer> Svrog: I'm eating a list of pairs and building a map of fst -> set snd
02:57:39 <Sizur> @hoogle first
02:57:40 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
02:57:40 <lambdabot> Data.Monoid.First :: newtype First a
02:57:40 <lambdabot> Data.Monoid.First :: Maybe a -> First a
02:58:34 <Sizur> :t fromJust . first
02:58:36 <lambdabot>     Couldn't match expected type `Maybe'
02:58:36 <lambdabot>            against inferred type `a (b, d)'
02:58:36 <lambdabot>       Expected type: a b c -> Maybe a1
02:58:39 <quicksilver> Toxaris: yup. Arithmetic isn't in the simple lambda calculus.
02:58:59 <quicksilver> Toxaris: I woudl imagine you could come up with a normal form for factors, but I'm not sure.
02:59:12 <quicksilver> Toxaris: what about x*x - y*y = (x+y)(x-y)
02:59:16 <quicksilver> Toxaris: which is normal ? :)
02:59:21 <Sizur> @hoogle a -> Maybe b
02:59:22 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:59:22 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:59:22 <lambdabot> Prelude.Just :: a -> Maybe a
02:59:24 <roconnor> piis3141: sorry, I was drawn away.
02:59:40 <sjanssen> dozer: use foldl' if you're building a Map
02:59:48 <scook0> dozer: have you seen insertWith?
02:59:59 <roconnor> @go ``Proving Equalities in a Commutative Ring Done Right in Coq''
03:00:01 <lambdabot> http://citeseer.ist.psu.edu/754279.html
03:00:01 <lambdabot> Title: Proving Equalities in a Commutative Ring Done Right in Coq (ResearchIndex)
03:00:13 <roconnor> piis3141: that paper may have some information for you.
03:00:19 <Toxaris> quicksilver: but piis3141 wants arithmetic (I assume from the given examples)
03:00:36 <Sizur> @hoogle a -> m b
03:00:37 <lambdabot> Prelude.id :: a -> a
03:00:37 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
03:00:37 <lambdabot> Data.Function.id :: a -> a
03:01:00 <roconnor> piis3141: hmm, now that I look at it, it is a bit beyond what you need.
03:01:09 <roconnor> piis3141: they spend a lot of time on efficency
03:01:19 <quicksilver> Toxaris: Yeah. I don't know. I'm sure there is an answer out in the literature :)
03:01:25 <dozer> my manual code is: http://hpaste.org/4570
03:01:28 <piis3141> i see
03:01:57 <Sizur> :t cast
03:01:58 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
03:02:14 <Sizur> :t fromJust . cast
03:02:15 <lambdabot> forall a a1. (Typeable a, Typeable a1) => a1 -> a
03:02:22 <roconnor> piis3141: so thinking off the top of my head...
03:02:47 <roconnor> piis3141: I suppose a normal form would be a sum of products, sorted in lexographical order
03:03:14 <Toxaris> :t Data.Map.fromListWith Data.Set.union
03:03:15 <lambdabot> forall a k. (Ord a, Ord k) => [(k, Data.Set.Set a)] -> Data.Map.Map k (Data.Set.Set a)
03:04:12 <roconnor> piis3141: with lots of subtle details about getting rid to terms that end up with a 0 coefficent.
03:04:57 <roconnor> quicksilver may have said all this already.
03:05:03 <roconnor> I'm just reading back now
03:05:04 <piis3141> roconnor: yes, first some sort of simplification and than transform to a normal form (sum of products)
03:05:14 <dozer> :t Data.Map.insertWith Data.Set.insert
03:05:15 <lambdabot>     Occurs check: cannot construct the infinite type:
03:05:15 <lambdabot>       a = Data.Set.Set a
03:05:15 <lambdabot>       Expected type: a -> a -> a
03:05:22 <Toxaris> :t Data.Map.fromListWith Data.Set.union . map Data.Set.singleton
03:05:23 <lambdabot>     Couldn't match expected type `(k, Data.Set.Set a)'
03:05:23 <lambdabot>            against inferred type `Data.Set.Set a1'
03:05:23 <lambdabot>       Expected type: [a1] -> [(k, Data.Set.Set a)]
03:05:48 <quicksilver> roconnor: I'm concerned about things like the difference of two squares
03:05:59 <roconnor> quicksilver: what's the problem?
03:06:00 <quicksilver> roconnor: I'm not sure which is normal out of x*x - y*y and (x+y)(x-y)
03:06:02 <Toxaris> :t Data.Map.fromListWith Data.Set.union . ((<$>) . (<$>)) Data.Set.singleton
03:06:03 <lambdabot> forall k a. (Ord a, Ord k) => [(k, a)] -> Data.Map.Map k (Data.Set.Set a)
03:06:11 <sime> piis3141: just had a closer look upon the SMT theorem provers: they should solve the problem you are posing, i.e., they implement the algorithms you are looking for, see the tutorial of Yices: http://yices.csl.sri.com/slides-afm-tutorial.pdf
03:06:26 <Toxaris> dozer: try this one
03:06:28 <roconnor> quicksilver: only 1*x*x + (-1)*y*y is the sum of produts
03:06:34 <quicksilver> roconnor: hm. Probably x*x - y*y is normal. Expand out as much as possible
03:06:36 <quicksilver> yeah
03:06:43 <quicksilver> expand all compound products
03:06:52 <quicksilver> make it a multi-variable polynomial
03:07:04 <quicksilver> and (obviously) collect coeefficients
03:07:05 * Toxaris finds at least one use of ((<$>) . (<$>)) each visit to #haskell
03:07:13 <quicksilver> so 2*x is the normal form of x+x
03:07:24 <Syzygy-> Toxaris: What does ((<$>) . (<$>)) do?
03:07:28 <quicksilver> intuitivey that sounds strongly normalising to me
03:07:34 <quicksilver> Syzygy-: two-deep functor
03:07:41 <quicksilver> :t fmap.fmap
03:07:41 <sime> piis3141: however they are not too simple to implement and even more difficult to get efficient. However these provers are free of charge and ready to be integrated. One could actually call this the standard way of solving problems like yours :-)
03:07:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:07:43 <dozer> :t <$>
03:07:44 <vincenz> quicksilver: x*x or x^3?
03:07:44 <lambdabot> parse error on input `<$>'
03:07:44 <roconnor> quicksilver: yes
03:07:45 <vincenz> quicksilver: x*x or x^2?
03:07:54 <Syzygy-> Ah.
03:07:59 <dozer> :t (<$>)
03:07:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:08:01 <quicksilver> vincenz: x*x
03:08:09 <Toxaris> Syzygy-: it's the same as ((<$>) <$> (<$>)), fmap fmap fmap   and   fmap `fmaÃp` fmap
03:08:13 <vincenz> seems counterintuitive
03:08:16 <quicksilver> vincenz: well, you could write x^2 as a convenient shorthand.
03:08:19 <quicksilver> but it would *be* x*x
03:08:21 <vincenz> 2*x vs x+x -but- x*x vs x^2
03:08:27 * Syzygy- almost read fmap fmap fmap as fap fap fap
03:08:28 <quicksilver> we're not doing full exponentiation
03:08:30 <Syzygy-> *hrm*
03:08:38 <vincenz> quicksilver: this for datatypes?
03:08:43 <vincenz> Syzygy-: lo
03:08:44 <vincenz> ..l
03:08:46 <roconnor> vincenz: either x*x or x^2 would make a fine normal form, so long as you chose one
03:08:58 <quicksilver> vincenz: erm it's for proving existence of a normal form for a fragment of arithmetic
03:09:02 <vincenz> roconnor: I do not agree
03:09:04 <Toxaris> Syzygy-: in this case, the second <$> maps over the list, and the first <$> maps into the second element of the tuples
03:09:12 <vincenz> x+y+x -> 2*x+y is preferred
03:09:14 <vincenz> similarly
03:09:20 <vincenz> x*y*x -> x^2*y is preferred
03:09:23 <vincenz> it's a clear analogy
03:09:29 <quicksilver> syntax is irrelevant, vincenz
03:09:33 <Syzygy-> Toxaris: Right. I think I might have done things that would benefit from that myself....
03:09:45 <quicksilver> the point is the definition of the term
03:09:49 <quicksilver> the term is a sum of products
03:10:02 <quicksilver> whether you choose to display the products of the same variable with itself using a convenient shorthand
03:10:07 <quicksilver> or interger exponentiation
03:10:08 <quicksilver> or not
03:10:12 <quicksilver> doesn't really change the normal form.
03:10:36 <Syzygy-> > (+1) `((<$>) . (<$>))` [[1,2,3],[4,5,6]]
03:10:37 <lambdabot>  Parse error at "((<$>..." (column 7)
03:10:45 <Syzygy-> > (+1) ((<$>) . (<$>)) [[1,2,3],[4,5,6]]
03:10:48 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
03:10:57 <Syzygy-> > ((<$>) . (<$>)) (+1) [[1,2,3],[4,5,6]]
03:10:58 <lambdabot>  [[2,3,4],[5,6,7]]
03:11:01 <Toxaris> Syzygy-: unfortunately, ` is only for identifiers :(
03:11:07 <Syzygy-> Wheee!
03:11:08 <roconnor> Lunch!
03:11:20 <Syzygy-> Toxaris: So I simply can't infix ((<$>) . (<$>)) ?
03:11:22 <piis3141> Yes, thanks guys!
03:11:32 <Toxaris> Syzygy-: so I have been told
03:12:11 <quicksilver> > let (<$$>) = fmap.fmap in (+1) <$$> [[1,2,3],[4,5,6]]
03:12:12 <lambdabot>  [[2,3,4],[5,6,7]]
03:12:42 <Syzygy-> Natch
03:14:40 <dozer> :t ((<$>) . (<$>)) Data.Set.singleton
03:14:42 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1) => f (f1 a) -> f (f1 (Data.Set.Set a))
03:14:45 <Sizur> > fmap (+1) [[[1,2],[3,4]],[[5,6],[7,8]]]
03:14:45 <lambdabot>   add an instance declaration for (Num [[t]])
03:15:32 <Sizur> > (fmap.fmap.fmap) (+1) [[[1,2],[3,4]],[[5,6],[7,8]]]
03:15:33 <lambdabot>  [[[2,3],[4,5]],[[6,7],[8,9]]]
03:16:31 <sime> piis3141, quicksilver: I guess this would be the paper corresponding to the rewritting system approach: http://www.cs.uu.nl/research/techreps/repo/CS-1994/1994-43.ps.gz
03:17:16 <Sizur> :t map (map (foldl1' (++)))
03:17:17 <lambdabot> forall a. [[[[a]]]] -> [[[a]]]
03:17:40 <Toxaris> let forceInfix x f = f x in forceInfix succ ((<$>) . (<$>)) [[1, 2], [3, 4]]
03:17:51 <Toxaris> > let forceInfix x f = f x in forceInfix succ ((<$>) . (<$>)) [[1, 2], [3, 4]]
03:17:52 <lambdabot>  [[2,3],[4,5]]
03:20:05 <Sizur> :t let f = map (foldl11 (++)) in f.f
03:20:09 <lambdabot> Not in scope: `foldl11'
03:20:23 <Sizur> :t let f = map (foldl1' (++)) in f.f
03:20:24 <lambdabot> forall a. [[[[a]]]] -> [[a]]
03:20:36 <Sizur> :t let f = map (foldl1' (++)) in f.f.f
03:20:37 <lambdabot> forall a. [[[[[a]]]]] -> [[a]]
03:24:10 <dozer> thanks Toxaris - I think that't got my app running!
03:28:13 <quicksilver> sime: sort of, but not quite.
03:28:43 <quicksilver> sime: they deal with actual numbers, not variables, I think?
03:29:07 <quicksilver> maybe I read it too fast
03:29:32 <quicksilver> no, I think that's right.
03:35:49 <sime> quicksilver: no, they don't: if there would only be actual numbers, then one could fully evaluate them :-)
03:40:28 <dozer> just found another use for extensible records :)
03:40:55 <dozer> datatype with 6 constructors, each wrap a record
03:41:32 <dozer> each of the 6 should have a field opa_annotations but in one it was misspelled opa_anntotions
03:41:44 <dozer> this wouldn't have happened with extensible records
03:46:02 <Sizur> > let c f s = [x|x<-s,f x]; sort xs = if null xs then [] else (\(x:xs)->sort (c (<=x) xs) ++[x]++ sort (c (>x) xs)) xs in sort [3,4,1,3,6,4]
03:46:05 <lambdabot>  [1,3,3,4,4,6]
03:52:32 <dcoutts> hmm, darcs.haskell.org is down :-(
03:52:38 <dcoutts> @seen dons
03:52:39 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 4h 54m 55s ago.
03:55:52 <Sizur> @hoogle [a]->(a->Bool)->([a],[a])
03:55:52 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
03:55:53 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
03:55:53 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
04:09:38 <Sizur> > let sort xs = if null xs then [] else (\(x:xs)-> (\(a,b)->sort a++[x]++sort b) (partition (<x) xs)) xs in [3,3,4,4,5,6,6,7,9]
04:09:42 <lambdabot>  [3,3,4,4,5,6,6,7,9]
04:10:00 <Sizur>  let sort xs = if null xs then [] else (\(x:xs)-> (\(a,b)->sort a++[x]++sort b) (partition (<x) xs)) xs in [9,8,7,2,3,4,7,6,5]
04:11:35 <wy> Any good reference for arrows?
04:11:53 <mux> @where arrows
04:11:54 <lambdabot> http://www.haskell.org/arrows/
04:13:06 <Sizur> :t (>>>)
04:13:08 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
04:13:45 <wy> I got that page, but too many papers there. Which one is the best introduction?
04:15:16 <byorgey> wy: the last one listed there, "Programming with Arrows" is good I think.
04:15:26 <wy> byorgey: Thanks!
04:15:47 <byorgey> wy: and ask in here if you have questions of course =)
04:25:34 <fadec> Are functions like fromJust considered to destroy the purity of a monad, specifically Maybe in this case.
04:26:07 <fadec> > fromJust $ Just 8
04:26:11 <lambdabot>  8
04:26:38 <scook0> I'm not sure I'd phrase it like that
04:26:49 <quicksilver> fadec: absolutely not.
04:26:49 <roconnor> same as scook0
04:26:54 <scook0> but partial functions like fromJust can be problematic
04:27:00 <quicksilver> fadec: the monad is just as pure with or without fromJust
04:27:09 <quicksilver> partiality is annoying, but that's different :)
04:27:20 <fadec> So from just is sort of external to the monad?
04:27:38 <Armored_Azrae1> Hey, anyone know why:
04:27:38 <Armored_Azrae1> do fd <- openFile "/proc/loadavg" ReadMode
04:27:38 <Armored_Azrae1>      c  <- hGetContents fd
04:27:38 <Armored_Azrae1>      hClose fd
04:27:38 <Armored_Azrae1>      return c
04:27:39 <Armored_Azrae1> Yields "" while doing the same thing without hClose gives expected output?
04:27:39 <quicksilver> well, it's a special property of this specific monad
04:27:51 <quicksilver> rather than being a general property of all monads
04:27:51 <fadec> ok
04:27:55 <scook0> I'm not sure that monadicity has anything to do with it
04:28:09 <quicksilver> Armored_Azrae1: yes
04:28:21 <quicksilver> Armored_Azrae1: becuse hGetContents is broken and no one should use it.
04:28:25 <scook0> lazy I/O goblins strike again!
04:28:35 <Armored_Azrae1> quicksilver: OK, thanks.
04:28:41 <roconnor> quicksilver: what do we use instead?
04:28:43 <scook0> or fail to adequately strike, as it were
04:28:50 <quicksilver> Armored_Azrae1: alternatively, because hGetContents uses unsafe lazy IO, and the data isn't actually read until you demand it
04:28:51 <roconnor> quicksilver: does readFile work?
04:28:54 <mux> lazy_io_frags++
04:28:54 <quicksilver> roconnor: nope.
04:29:02 <roconnor> :(
04:29:07 <quicksilver> strict IO
04:29:19 <quicksilver> I think dons uploaded a strict getContents or readFile to hackage the other day.
04:29:26 <mux> yeah
04:29:35 <quicksilver> I have no idea why there aren't strict IO primitives in the standard library. It sucks.
04:29:50 <scook0> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict-0.3
04:29:51 <lambdabot> http://tinyurl.com/22m4ey
04:30:30 <Armored_Azrae1> quicksilver: Is there any way of using "!" in order to make it be strict without getting this package?
04:31:02 <roconnor> what happens if you do evaluate c before the hClose?
04:31:08 <roconnor> @hoogle evaluate
04:31:09 <lambdabot> Control.Exception.evaluate :: a -> IO a
04:31:26 <roconnor> (after importing Control.Exception)
04:31:40 <roconnor> Hmm
04:31:47 <roconnor> evaluate c probably isn't good enough.
04:31:54 <roconnor> :(
04:32:08 <mux> evaluate (length xs)
04:32:17 <roconnor> mux: that hack may work
04:32:25 <mux> it should, it's often used
04:32:27 <roconnor> evaluate (length c)
04:32:38 <roconnor> mux: Ah, I didn't know that
04:32:41 <quicksilver> Armored_Azrae1: (length c) `seq` hClose fd
04:32:44 <quicksilver> should do the trick
04:32:52 <Armored_Azrae1> quicksilver: Thanks.
04:32:57 <quicksilver> that's roughly equivalent to the evaluate thing
04:32:57 <mux> yeah that's even nicer
04:33:03 <roconnor> quicksilver: we are in the IO monad, we should totally use evaluate here ;)
04:33:11 <quicksilver> I'm not 100% happy with evaluate
04:33:15 <quicksilver> I don't like its name
04:33:24 <quicksilver> :)
04:33:26 <roconnor> :)
04:33:32 <quicksilver> I find it hard to explain to other people exactly what it does
04:33:36 <quicksilver> compared to explaining seq
04:33:40 <roconnor> !
04:33:41 <roconnor> really
04:33:59 <Armored_Azrae1> The evaluate version also appears to work.
04:34:04 * quicksilver nods
04:34:07 <quicksilver> it should, yes :0
04:34:09 <roconnor> I thought explaining evaluate would be easier
04:34:12 <quicksilver> I just don't think it looks very nice
04:34:13 * quicksilver shrugs
04:34:49 <roconnor> Armored_Azrae1: both the seq and evaluate versions do about the same thing.  That is to compute the lenght of c before closing the file.
04:35:07 <roconnor> Armored_Azrae1: this forces haskell to read in the entire file into memory
04:35:08 <Armored_Azrae1> roconnor: No, I used evaluation on c to gain another string, then used that.
04:35:21 <Armored_Azrae1> Basically I forced that part of evaluation to go.
04:40:17 <quicksilver> Armored_Azrae1: that's actually not reliable
04:41:01 <quicksilver> Armored_Azrae1: it will work, but it's not doing the right thing
04:41:39 <quicksilver> Armored_Azrae1: all you're doing there is forcing it to check fi the string is empty or not ([] or x : xs).
04:41:47 <quicksilver> in practice, this involves reading the first character.
04:42:09 <quicksilver> in practice, because IO is buffered, reading the first character involves reading a whole chunk.
04:42:28 <quicksilver> since "/proc/loadavg" is a very small file, this will certainly be the entire file.
04:42:34 <quicksilver> but this is not a general approach :)
04:43:58 <scook0> and Haskell is all about the general approach!
04:45:30 <tobyS> hiya!
04:45:49 <tobyS> short question from a newbe: is there something similar than sprintf() in haskell?
04:46:14 <ari> :t printf
04:46:16 <lambdabot> forall r. (PrintfType r) => String -> r
04:47:09 <ari> @index printf
04:47:10 <lambdabot> Text.Printf
04:47:31 <ari> It's printf and sprintf in one function!
04:47:35 <Syzygy-> > printf "%.2f" (1/3) :: String
04:47:36 <lambdabot>  "0.33"
04:48:36 <tobyS> ah, cool :)
04:49:00 <tobyS> hmmm... but my hugs doesn't know it. do i need to import some module for it?
04:49:33 <psi> Text.Printf
04:49:46 <tobyS> thanks! :)
04:52:58 <Sizur> @go Kleisli
04:52:59 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/realworld/kleisli.html
04:52:59 <lambdabot> Title: Kleisli
05:18:26 <Sizur> > let f = arr (\_->"test") >>> arr show :: a -> String in f 1
05:18:28 <lambdabot>  "\"test\""
05:21:52 <quicksilver> Sizur: you know your type sig a-> String applies to the whole expresion?
05:22:07 <quicksilver> Sizur: and therefore forces your arrow instance to (->)
05:22:15 <quicksilver> (and makes arr into id)
05:22:26 <Sizur> quicksilver: I just found out ;)
05:23:36 <Sizur> I always feel like it's my birthday when I learn concepts
05:27:32 <scook0> well, that was fun: http://hpaste.org/4572
05:28:30 <scook0> Title: "fluent interface for numbers" :)
05:28:40 <mux> very nice :)
05:28:58 <scook0> I wanted to do a type-level one
05:29:15 <scook0> but actually I'm quite proud of how I perferted the (.) operator for this version
05:29:23 <scook0> (perverted)
05:29:57 <scook0> surprisingly short, now that I look at it
05:32:09 <Sizur> scook0: nice one
05:34:27 <quicksilver> scook0: that's very cool :)
05:34:53 <scook0> quicksilver: I decided that re-binding (.) would be cheating
05:35:33 <Sizur> there, in case anybody will need tuple projections: http://hpaste.org/4573
05:36:16 <scook0> @pl \f -> snd $ f (1, 0)
05:36:16 <lambdabot> snd . ($ (1, 0))
05:37:44 <scook0> Sizur: oh, that's nice
05:38:01 <scook0> what happens if you try to project a type that occurs twice?
05:39:57 <Sizur> scook0: it cannot find an instance then. overlapping
05:40:05 <scook0> ah
05:40:23 <Sizur> you can isomorph before projection if you need, but that's a different module for me
05:41:48 <scook0> I don't think the verb "isomorph" gets used often enough :)
05:42:03 <dozer> it sounds like something from red dwarf
05:43:41 <Sizur> I'd like to have projections shipped with ghc. anybody against that?
05:44:44 <scook0> I thought the trend was away from shipping extra stuff with GHC
05:45:01 <sjanssen> Sizur: I think it would make a nice micro-library
05:45:32 <benny99> there should be something like boost-haskell then :p
05:45:35 <scook0> it would be lovely to see it on hackage, though
05:46:35 <sjanssen> yep, packages in hackage are practically as good as bundled for users of cabal-install
05:47:05 <wy> How often is GADT used?
05:47:32 <Sizur> there are two drawbacks. 1) all types must be different; 2) cannot project in the other direction (yet). http://hpaste.org/4573#a2
05:47:33 <takamura> Hi, i have a question. I strange results using diffClockTimes ( see http://hpaste.org/4574 ) like 0:0:345. Is this the expected behaviour?
05:47:42 <takamura> I obtain strange*
05:50:27 <scook0> takamura: you're using System.Time?
05:50:34 <takamura> yes
05:51:00 <scook0> I hear Data.Time is preferred these days
05:51:07 <scook0> (though I've not used either myself)
05:51:17 <takamura> ah, ok, i will try it
05:51:23 <doserj> there is a comment in the source, saying, "use normalizeTimeDiff" on this function's result" :)
05:52:41 <takamura> there is nothing about that in the hadoc docs :S
05:52:50 <doserj> yep :(
05:52:52 <sjanssen> wy: not very ofen, I think.  They're quite new
05:52:56 <quicksilver> wy: not very often, yet. It is a relatively recent feature.
05:52:57 <takamura> i will try that also
05:53:10 * Heffalump uses them for various things
05:53:59 <wy> Thanks. I'm reading the wikibook. It's quite good a tutorial
05:55:48 <sjanssen> Sizur: I think you can drastically reduce the number of instances, from O(n^2) to O(n)
05:56:21 <benny99> wy: yep
05:56:21 <Sizur> sjanssen: it's not n^2 right now
05:56:41 <Sizur> no it is!
05:56:46 <wy> I'm wondering how they got type checked. It looks like runtime feature
05:56:52 <Sizur> 12^2 = 144
05:56:56 <Sizur> sjanssen: how?
05:57:13 <Sizur> sjanssen: I know you can use Generic, but it'll be folding at runtime
05:57:24 <Sizur> sjanssen: so this is much faster
05:57:28 <Heffalump> wy: no, it's compile-time, but it relies on you providing type annotations at appropriate points
05:57:37 <wy> Could you look at that SafeList example ? http://en.wikibooks.org/wiki/Haskell/GADT
05:58:40 <sjanssen> Sizur: start with a class, Normalize, which flattens any tuple into a nested tuple with a certain structure
05:58:51 <wy> I haven't figured out how can the compiler know the list is empty, because it doesn't knowhow many tails have you taken
05:58:53 <Heffalump> that's just tracking empty/non-emptiness in the type.
05:59:01 <sjanssen> eg. (a, b, c) -> (a, (b, (c, ())))
05:59:06 <Heffalump> it can't, it just will refuse to typecheck most programs. It's a rubbish example :-)
05:59:50 <Heffalump> safeHead (safeTail xs) will simply fail to typecheck no matter what xs is.
06:00:27 <wy> So GADT can do all the things existential types can do?
06:00:28 <sjanssen> Sizur: then you can write type relations that recognize permutations of this list
06:01:05 <Heffalump> yes, but they have nicer syntax and better type-checking algorithms (AIUI)
06:01:51 <wy> You mean the existential types  have nicer syntax and better type-checking algorithms?
06:02:04 <Heffalump> no, GADTs do.
06:02:44 <wy> I misunderstood because you used "but". So GADT is always better
06:02:46 <Heffalump> oh, and they are more powerful, as you can't define a constructor to produce a restricted set of result types with existentials.
06:03:52 <Sizur> sjanssen: but permutation count is exponential
06:03:56 <wy> It seems they are moving towards dependent types?
06:04:54 <quicksilver> I don't really think GADTs move you towards dependendent types
06:05:11 <quicksilver> at their heart, they are just more specific types for constructors
06:05:33 <Heffalump> they do let type-checking be guided by information about values
06:05:35 <quicksilver> with standard ADTS, if there is polymorphism in your type, all your constructors must be fully polymorphic.
06:05:38 <BMeph> quicksilver: But what of the converse? Do dependent types encourage one to use GADT's?
06:05:42 <Heffalump> but they don't let values *determine* types
06:05:55 <quicksilver> GADTs just allow you to have slightly less polymorphic constructors
06:05:57 <quicksilver> which is very useful
06:10:49 <Sizur> how can this piece work? how do I call the constructor? data GadtedFoo x where  MkGadtedFoo :: x -> GadtedFoo Int
06:11:24 <oerjan> the x'es are entirely unrelated iirc
06:12:24 <Sizur> pseudocode?
06:12:56 <Armored_Azrae1> Hey, if anyone's free, do you think you could reccomend any changes to the interface on this module I'm making: http://ugcs.caltech.edu/~maurer/Demon-0.1.tar.gz
06:12:56 <Armored_Azrae1> I know it's inefficient in several places, etc. and this will be fixed later, but at the moment I'm wondering if it should have any other features.
06:13:08 <b_jonas> Sizur: it's those GAT things I beleive
06:13:29 <Sizur> ok, but how can I call the constructor?
06:13:55 <b_jonas> I think you treat the constructor MkGadtedFoo like a x -> GadtedFoo functoin
06:14:00 <b_jonas> except that it's uppercased
06:14:04 <b_jonas> and that you can pattern match it
06:14:05 <oerjan> MkGadtedFoo justAboutAnything
06:14:40 <oerjan> hm wait
06:14:41 <b_jonas> it's amost like data GadtedFoo x = MkGadtedFoo x; except that the constructor only works if x is Int
06:14:44 <allbery_b> works the same as a normal constructor, I believe; it just has a more flexible definition
06:14:45 <b_jonas> but I'm not completely sure
06:15:03 <Sizur> MkGadtedFoo 'a' -- what kind of an GadtedFoo Int can it return?
06:15:19 <b_jonas> Sizur: hmm
06:15:24 <b_jonas> let's try it
06:16:15 <b_jonas> *Main> :t MkGadtedFoo
06:16:15 <b_jonas> MkGadtedFoo :: forall x. x -> GadtedFoo Int
06:16:20 <b_jonas> that's what ghci tells to me
06:16:32 <Sizur> call the constructor with a char
06:16:47 <b_jonas> *Main> :t MkGadtedFoo 'a'
06:16:47 <b_jonas> MkGadtedFoo 'a' :: GadtedFoo Int
06:16:56 <Sizur> lol
06:16:56 <allbery_b> you gots a problem there, I think that is inhabited only by _|_
06:17:11 <oerjan> i guess it is essentially existential - since the x has no typeclass you can get it out but do little with it
06:17:23 <b_jonas> maybe the two x aren't the same?
06:17:26 <b_jonas> I don't understand
06:17:59 <oerjan> i think the x before the where isn't used for anything other than possibly determining the kind
06:18:01 <allbery_b> I think they are separate unless unified by being part of the result type
06:18:10 <allbery_b> hm, maybe
06:18:45 * oerjan is vaguely recalling again
06:18:58 <Sizur> so I can pattern match any type that was constructed with only this constructor then
06:19:06 * allbery_b waits for $doctor to call back since he's now on 25 hours without sleep and still bronchospasming periodically :(
06:19:14 <b_jonas> *Main> let MkGadtedFoo u = MkGadtedFoo 'a'
06:19:14 <b_jonas> <interactive>:1:4:
06:19:14 <b_jonas>     My brain just exploded.
06:19:14 <b_jonas>     I can't handle pattern bindings for existentially-quantified constructors.
06:19:20 <b_jonas> I can't make sense of that error message
06:19:53 <allbery_b> the forall it inserted, because it couldn't do anything else with the 'x', is messing with ghc's pattern matcher
06:20:47 <oerjan> you may try case MkGadtedFoo 'a' of MkGadtedFoo u -> ...
06:20:57 <chr1s> hey all!
06:20:58 <allbery_b> (I think that may be inevitable, since (being existientially qualified) you can't actually extract or do anything with it anyway)
06:21:12 <chr1s> I'm going to create my first monad today!
06:21:14 <Sizur> very useful
06:21:38 <oerjan> you can extract existentially quantified things, but i think you cannot use let like that, but case should work
06:22:01 <chr1s> I want to have a wrapper around the IO-monad that also stores a variable (a connection to the database).
06:22:09 <oerjan> as well as pattern matching in function arguments, which desugar to case?
06:22:28 <oerjan> (not sure about that)
06:22:29 <b_jonas> oerjan: ah yes
06:22:31 <chr1s> does anybody have a good tutorial on creating monads?
06:22:51 <allbery_b> StateT IO
06:23:04 <doserj> b_jonas: what ghc version do you use?
06:23:06 <allbery_b> monad transformers are your friends
06:23:07 <b_jonas> so basically, the existentially qualified thingy is more useful if its type is bound by an interface
06:23:25 <b_jonas> so you can at least call the functions of the interface on it
06:23:36 <b_jonas> doserj: 6.6
06:23:46 <b_jonas> with -fglasgow-exts
06:24:04 <kpreid> chr1s: your monad is StateT DBConnection IO
06:24:11 <kpreid> or possibly ReaderT
06:24:40 <chr1s> kpreid: thanks. I'll go and read about monad transformers!
06:24:52 <kpreid> monad construction kit :)
06:25:27 <b_jonas> I don't really understand these existential types
06:25:33 <ari> @src []
06:25:34 <lambdabot> data [] a = [] | a : [a]
06:26:28 <wy> How can I show the value constructed by the GADT constructor? I don't know if I can deriving Show
06:26:58 <oerjan> b_jonas: i think the unwrapping of existential types needs to be in a clearly delineated sub-scope, which case gives, as well as pattern matching on function arguments, but not pattern bindings in lets
06:27:06 <allbery_b> wy: include a Show constraint on it
06:27:17 <allbery_b> Foo :: Show x => ...
06:27:23 <allbery_b> same as any function
06:27:23 <b_jonas> oerjan: yes
06:28:47 <wy> MkGadtedFoo :: (Show x) => x -> GadtedFoo Int ?
06:28:57 <allbery_b> yes
06:29:01 <quicksilver> oerjan, b_jonas: you can extract the existential with case, certainly, but there isn't much you can do with the thing you extract
06:29:08 <wy> I still get errors
06:29:21 <quicksilver> all you can do is stick it back into another
06:29:31 <quicksilver> wy: you won't be able to derive Show for existential constructors.
06:29:36 <allbery_b> however I still think that particular declaration is only inhabited by _|_
06:29:46 <quicksilver> allbery_b: nah, it's very well inhabited.
06:29:50 <allbery_b> I mean, what's it supposed to do with the x?
06:29:56 <b_jonas> quicksilver: can you call methods on the extracted value?
06:30:03 <quicksilver> MkGadtedFoo 42, MkGadtedFoo 'a', MkGadtedFood (id)
06:30:08 <quicksilver> are all perfectly happy inhabitants
06:30:13 <quicksilver> but you really can't do much with them.
06:30:26 <quicksilver> b_jonas: if it has a class context, of course
06:30:31 <quicksilver> b_jonas: but this one was unbounded existential.
06:30:41 <b_jonas> quicksilver: yep
06:30:45 <allbery_b> so it's secretly unsafeCast except that you can't get the value back out?
06:30:57 <quicksilver> I'm not sure that's very meaningful.
06:30:59 <b_jonas> also, could you have an existential like
06:31:10 <quicksilver> No more so than lists are secretly unsafeCast
06:31:17 <quicksilver> *everything* in GHC is secretely unsafeCast
06:31:27 <quicksilver> excepting unboxing, all types are represented uniformly
06:31:30 <allbery_b> isn't its (wrapped) type Int, though?
06:31:38 <oerjan> allbery_b: you can at least call seq on it, so it's not _quite_ indistinguishable from _|_
06:31:38 <b_jonas> data Foo where MkFoo :: x -> (Bar x)
06:31:48 <wy> MkGadtedFoo 'a' :: GadtedFoo Int. Then what's that Int there?
06:31:54 <quicksilver> wy: nothing much.
06:31:56 <allbery_b> ==wy.  exactly
06:31:58 <b_jonas> then you could use generic Bar operations on the argument
06:31:58 <quicksilver> you've just told it that's the type
06:32:02 <quicksilver> so it believes you
06:32:04 <quicksilver> compare this:
06:32:07 <quicksilver> Nothing :: Maybe Int
06:32:11 <quicksilver> ^^ what's that Int there?
06:32:24 <dcoutts_> quicksilver: surely if MkGadtedFoo is a constructor then you can take it apart and get the Show x => x thing and call show
06:32:35 <dcoutts_> doesn't matter a jot if the type parameter is Int
06:32:35 <allbery_b> hrm.  so another use for GADTs is to carry around extra hidden information, then?
06:32:43 <allbery_b> guess so, from the rest of the discussion.
06:32:49 <allbery_b> wild.
06:33:13 <wy> Hmmm... I guess I'd better stick with the basic stuff at this time
06:33:32 <quicksilver> dcoutts_: erm, that's not what I was saying.
06:33:41 <quicksilver> dcoutts_: I was saying "deriving Show" wouldn't work.
06:33:42 * allbery_b has heard other people claim to be afraid of GADTs, ut never saw why... until now
06:33:59 <quicksilver> dcoutts_: and at another point, I was sayng that unbounded existentials can't be shown
06:34:10 <quicksilver> I don't think this is a GADT point
06:34:10 <wy> I found that there had been work on intersection types, but I haven't found many implementations
06:34:13 <quicksilver> consider this:
06:34:20 <dcoutts_> show (MkGadtedFoo x) = "MkGadtedFoo " ++ show x
06:34:26 <quicksilver> data Foo a = One | Two | Three a
06:34:37 <quicksilver> dcoutts_: absolutely. It's just that built-in deriving can't do that.
06:34:45 <dcoutts_> quicksilver: I expect you're right, but in this case there's no reason we could not derive Show if x is in Show
06:34:55 <quicksilver> ^^ Foo is not a a GADT
06:35:03 <allbery_b> quicksilver: I see where you are going, but I wll point out that I would nto expect Two to carry an a.
06:35:08 <quicksilver> but Foo Int contains values like "Three 7" as well as "Two"
06:35:13 <quicksilver> "Two" doesn't contain an Int.
06:35:22 <quicksilver> this is no better or worse than the GADT we saw.
06:35:24 <allbery_b> yet the GADT is carrying an x not included in its result type!
06:35:37 <quicksilver> that's "just" because it was existential
06:35:45 <quicksilver> although:
06:35:55 <quicksilver> data Foo a = Two Int | Three a
06:36:04 <quicksilver> Two 42 :: Foo Char
06:36:12 <quicksilver> ^^ this carries an Int not mentioned in its result type
06:36:55 <allbery_b> that does not seem to be similar, since the point of a GADT is that the result types are independent per constructor
06:37:10 <allbery_b> (well, a point)
06:37:22 <wy> Is the whole point to make things like heterogeneous lists possible?
06:37:44 <quicksilver> wy: no, not really. They always were possible.
06:38:17 <quicksilver> allbery_b: well there are several conflated points here.
06:38:21 <wy> Because the constructors make values of the same type even they took different inputs... So they can be inserted into a list of type [GadtedFoo Int]
06:38:42 <quicksilver> allbery_b: (1) a single, unbounded, existential is not very useful
06:39:02 <quicksilver> allbery_b: (2) constructors don't have to mention the types in the type itself
06:39:08 <quicksilver> wy: no, again, normally ADTs are fine for that
06:39:21 <quicksilver> data AnyThing = I Int | C Char | S String
06:39:29 <quicksilver> [Anything] --- a list of ints or chars or strings
06:39:36 <wy> But you have too many
06:39:52 <quicksilver> that's what existentials are for, then
06:39:58 <wy> and you have to use different names for each type
06:40:03 <quicksilver> this is still not using the 'G' in GADT.
06:40:13 <Associat0r> any F# users here?
06:40:13 <quicksilver> data Anything = forall a . Thing a
06:40:27 <Sizur> Associat0r: basic f#
06:40:34 <wy> :type [MkGadtedFoo 2, MkGadtedFoo 'a']
06:40:35 <wy> [MkGadtedFoo 2, MkGadtedFoo 'a'] :: [GadtedFoo Int]
06:40:46 <quicksilver> wy: right. But you're not using GADTS.
06:40:56 <quicksilver> wy: your tag Int is meaningless, it might as well not be there.
06:41:06 <Associat0r> how did you like it? Sizur
06:41:06 <quicksilver> wy: at which point, your type becomes my AnyThing type
06:41:11 <quicksilver> the second one, I mean :)
06:41:14 <quicksilver> data Anything = forall a . Thing a
06:41:28 <Sizur> Associat0r: very convenient. but not pure
06:42:08 <Associat0r> I think it had some monadic stuff in it
06:42:10 <wy> It lies about its type...
06:42:19 <quicksilver> wy: no, it doesn't.
06:42:28 <Sizur> Associat0r: until haskell will not compile on CLI, F# is best
06:43:02 <wy> Is F# still in an experimental state?
06:43:16 <Associat0r> F# Computation Expressions
06:43:27 <Sizur> wy: I believe so, but it's very usable already
06:43:38 <Sizur> and on Mono too
06:43:43 <wy> I have to find another tutorial about GADT to make some sense
06:43:55 <fadec> > extendSequence [4, 8, 15, 16, 23, 42]
06:43:57 <lambdabot>   Not in scope: `extendSequence'
06:44:03 <allbery_b> I think I've heard it's going to be in the nextr major VS release
06:44:13 <Associat0r> yeah
06:44:18 <wy> Sizur: What's more in it than OCaml ?
06:44:26 <Associat0r> operator overloading
06:44:30 <Associat0r> from what I see
06:44:31 <allbery_b> I think I've also heard that Haskell is difficult to target to the CLR for some reason :(
06:44:40 <Associat0r> and haskell syntax
06:44:42 <quicksilver> wy: the effect you are describing is all about existential types.
06:44:46 <Associat0r> whitespace syntax I mean
06:44:48 <quicksilver> wy: and it has nothing to do with GADTs.
06:45:04 <Sizur> allbery_b: I heard the opposite
06:45:10 <quicksilver> GADTs happen to make the syntax for existentials simpler, but that's the only connection.
06:45:14 <allbery_b> of which?
06:45:33 <Sizur> allbery_b: that haskell is not hard to target CLR
06:45:46 <Sizur> just nobody is doing it
06:45:51 <b_jonas> fadec: try /msg buubot oeis: 4, 8, 15, 16, 23, 42
06:45:53 <Associat0r> why do you guys want the CLR so badly?
06:45:59 <Associat0r> because of the libs?
06:46:01 <allbery_b> (my terminology is somewhat imprecise with regard to targeting, being that <a> I am no Windoiws / CLR developer and <b> I've been awake for 25+ hours at this point)
06:46:11 <Sizur> Associat0r: a reason enough already :)
06:46:16 <oerjan> @oeis 4, 8, 15, 16, 23, 42
06:46:17 <lambdabot> The Lost Numbers.
06:46:17 <lambdabot> [4,8,15,16,23,42,108]
06:46:17 <quicksilver> Sizur: actually, that's not true.
06:46:20 <Associat0r> hmm
06:46:30 <quicksilver> Sizur: there are good reasons why it is hard to get a decent haskell implementation on the CLR
06:46:35 <quicksilver> I'm not sure I can remember them :)
06:46:46 <wy> quicksilver: How much bigger it is than existentials?
06:46:47 <quicksilver> but someone ( JaffaCake perhaps?) explained once
06:46:52 <allbery_b> libraries; development environment that's windows-friendly; generally, better windows support than exists for any current haskell implementation
06:46:58 <allbery_b> enough reasons?
06:47:28 <quicksilver> wy: bigger? I'm not sure. existentials are a simpler change, I guess.
06:47:34 <Associat0r> visual haskell is a windows friendly environmet but not CLR
06:47:38 <quicksilver> but really GADTs are not a very big change either.
06:48:08 <wy> quicksilver: I don't mean big change. I mean how much more powerful it is
06:49:24 <allbery_b> not more powerful.,  more expressive.
06:50:04 <allbery_b> it's easier to write some types with GADTs than with Haskell98 types; Oleg has repeatedly demonstrated how to write various claimed GADT-requiring types in H98
06:50:56 <Sizur> http://haskell.org/haskellwiki/GHC:FAQ#Why_isn.27t_GHC_available_for_.NET.3F
06:50:57 <lambdabot> http://tinyurl.com/27tp4v
06:51:00 <allbery_b> basically, any GADT can be represented as an H98 ADT, but you may have to be Oleg to do it :)
06:53:12 <wy> I saw he wrote HList
06:53:13 <quicksilver> wy, allbery_b : well the 'smart constructors' in a GADT can easily just be 'plain functions' in a normal ADT.
06:53:19 <quicksilver> so that's "half the work"
06:53:31 <quicksilver> then the only thing which GADTs give you is the ability to pattern-match on them
06:53:37 <quicksilver> which is really nice and convenient
06:53:40 <mux> I want an Oleg for christmas
06:53:40 <Sizur> @oeis 1,3,2,4,3,6,4
06:53:41 <lambdabot> Molien series for Weyl group E_6.
06:53:41 <lambdabot> [1,0,1,0,1,1,2,1,3,2,4,3,6,4,8,6,10,9,14,11,18,15,22,20,29,25,36,32,43,41,54,...
06:53:46 <quicksilver> but clearly not an expressivity issue
06:53:57 <quicksilver> you can do it by hand if you must.
06:54:10 <quicksilver> existentials, on the other hand *are* an expressivity thing, I believe.
06:54:28 <quicksilver> I don't think you can encode them just in rank-1 types.
06:54:32 <quicksilver> But, I'm not sure.
06:54:49 <quicksilver> In rank-2 types you can, certainly. But rank2types is strictly more powerful than existentials.
06:55:31 <mux> what I like about existentials is that they correspond fairly well to what's needed in the module language$
06:55:47 <mux> which could allow to merge the two if I'm not mistaken
06:55:47 <Associat0r> Sizur : #f#
06:55:49 <SamB_XP> what does this have to do with money
06:56:01 <Associat0r> need more people
06:56:09 <wy> James Cheney? First-Class Phantom Types?
06:56:22 <Cin> what is this syntax called? [1..10] -- i want to know what types it is able to take
06:56:26 <Sizur> Associat0r: pay me more than my current employer, and I'm there
06:56:49 <mauke> :t \x y -> [x .. y]
06:56:49 <Sizur> I'm coding perl here
06:56:51 <lambdabot> forall t. (Enum t) => t -> t -> [t]
06:57:01 <Associat0r> what lang do you use at your employer now?
06:57:02 <mauke> @pl \x y -> [x .. y]
06:57:02 <lambdabot> enumFromTo
06:57:03 <mux> importing a module is about the same thing as "opening" an existential
06:57:28 <Cin> mauke: what is `pl'?
06:57:33 <mauke> @help pl
06:57:34 <lambdabot> pointless <expr>. Play with pointfree code.
06:57:43 <Cin> ah
06:58:04 <Cin> ahh. i get it
06:58:11 <Cin> it works for any type that is an instance of Enum
06:59:07 <Sizur> Associat0r: perl extensively, some java, js, sql
06:59:19 <Associat0r> o
07:00:39 <mux> Cin: yes, using [x..y] is like enumFromTo x y
07:00:42 <mux> :t enumFromTo
07:00:43 <lambdabot> forall a. (Enum a) => a -> a -> [a]
07:02:56 <Cin> i've got some Int value n, and i want to do from 0.0 to n/10. so if i give it 100, it will produce 0.0 to 10.0
07:03:07 <Cin> but i get "No instance for (RealFrac Int)"; what is RealFrac?
07:03:33 <mauke> :t (/)
07:03:34 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:03:45 <SamB_XP> mux: "like"?
07:03:50 <SamB_XP> it *is* that
07:04:01 <doserj> @src RealFrac
07:04:01 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
07:04:01 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
07:04:01 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
07:04:51 <Cin> > let height = 100 :: Int
07:04:51 <lambdabot>  Parse error at end of input
07:04:55 <Cin> > [0.0..(floor (height/10))]
07:04:56 <lambdabot>   Not in scope: `height'
07:05:01 <Cin> that produces the error
07:05:15 <Cin> i guess Integral is not an Int
07:05:16 <Cin> erm
07:05:34 <Syzygy-> Cin: floor is in RealFrac, so it requires that what you feed it implements RealFrac.
07:05:42 <doserj> try (fromIntegral height) / 10
07:05:54 <mauke> try [0 .. height `div` 10]
07:06:00 <mauke> what's the point of 0.0?
07:06:30 <Cin> mauke: stupidity
07:06:30 <Syzygy-> > [0 .. (100 :: Int) `div` 10]
07:06:32 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
07:06:42 <Syzygy-> Cin: We like to say "inexperience" ;)
07:06:53 <Cin> okay :P
07:07:27 <Cin> :t (fromIntegral 10)
07:07:27 <lambdabot> forall b. (Num b) => b
07:07:37 <Cin> i see
07:07:45 <mauke> :t 10
07:07:45 <lambdabot> forall t. (Num t) => t
07:07:53 <Cin> :t fromIntegral
07:07:54 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:08:00 <mux> SamB_XP: yes, that's what I meant
07:08:43 <Cin> mauke: well, div seems to be correct
07:08:47 <SamB_XP> now, 1 is *like* fromInteger 1
07:09:38 <Cin> i should know better; i'm exploring some example code without actually knowing what i'm doing.
07:09:55 <Cin> samb: samb from ##c?
07:10:20 <SamB_XP> Cin: indeed
07:12:31 <quicksilver> but, in here, he's smarter
07:12:33 <quicksilver> and purer
07:12:46 * Cin chuckles
07:16:30 <SamB_XP> heh
07:17:03 <SamB_XP> well, I don't feed PoppaVic in here, anyway
07:18:45 <Sizur> @users
07:18:45 <lambdabot> Maximum users seen in #haskell: 434, currently: 399 (91.9%), active: 15 (3.8%)
07:20:13 <wy> I looked at David Roundy's talk slides about darcs' using of GADT. It seems that GADT is a general way to "compute" types. Is this a correct understanding?
07:22:43 <matveev> > -1 `mod` 2 == -1 `rem` 2
07:22:46 <lambdabot>  True
07:23:01 <matveev> ^^^ caused me a headache ...
07:23:22 <Lemmih> > (-1) `mod` 2 == (-1) `rem` 2
07:23:22 <lambdabot>  False
07:24:13 <matveev> right, but headache is not yet gone ...
07:24:44 <oerjan> > (+1) `mod` 2 == (+1) `rem` 2 -- ;)
07:24:45 <lambdabot>   add an instance declaration for (Integral (a -> a))
07:25:12 <byorgey> unary minus strikes again!
07:25:31 <byorgey> BIFF! POW!
07:25:46 <byorgey> uh... hi everyone =)
07:26:22 <SamB_XP> byorgey: hatezor it!
07:28:00 <Sizur> what's a good paper on monad transformers?
07:28:06 <int-e> @index time
07:28:07 <lambdabot> bzzt
07:28:29 <oerjan> @hoogle time
07:28:31 <lambdabot> System.Time :: module
07:28:31 <lambdabot> Data.Time :: module
07:28:31 <lambdabot> System.Timeout.timeout :: Int -> IO a -> IO (Maybe a)
07:28:46 <byorgey> @go Monad Transformers step-by-step
07:28:57 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
07:28:57 <lambdabot> Title: Monad Transformers Step by Step
07:29:22 <byorgey> Sizur: that's a great one.  or do you mean, a paper on the theory behind monad transformers?
07:30:15 <Sizur> hmm, maybe I will compile all papers to read for noobs ordered by prerequisites as this seems to be a common question
07:30:26 <byorgey> Sizur: hey, that's a great idea.
07:30:33 <byorgey> Sizur: put it on the wiki.
07:33:01 <mux> http://chronicle.com/blogs/footnoted/627/another-tat-y-combinator-why-not
07:33:03 <lambdabot> Title: Another Tattoo: Y Combinator? Why&#160;Not? - Chronicle.com, http://tinyurl.com/2c5gwa
07:34:09 <therp> I only thought about printing the Y combinator in exactly that notation on a t-shirt. now I feel a bit less geeky
07:35:10 <Sizur> :t Just undefined
07:35:12 <lambdabot> forall a. Maybe a
07:35:19 <mux> I wish I was crazy enough to get fixed point combinators tattoed on my arm
07:36:13 <therp> I'm glad I'm not. The number of girls I'd be able to date would decline seriously
07:36:56 <mux> my dating functions is o(x^2) so any linear decrease is irrelevant
07:44:06 <Sizur> byorgey: yeah that's a perfect paper.
07:44:31 <Sizur> strange, I was able to sent messages, but not receive... good that we have logs
07:45:55 <fadec> > catch (fmap read getLine :: Int) (\e -> putStr "no parse\n")
07:45:57 <lambdabot>  Couldn't match expected type `Int' against inferred type `IO a'
07:46:16 <fadec> > catch (fmap read getLine :: IO Int) (\e -> putStr "no parse\n")
07:46:16 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
07:51:22 <pwncity> I get this: http://kortlink.dk/4mdt
07:51:30 <lambdabot> Title: MyMiniCity
07:58:15 <dmead> weird, i was just looking at that
07:58:49 <benny99> dmead: at what?
07:59:00 <dmead> minicity
07:59:03 <dmead> goontower
07:59:04 <dmead> etc
07:59:14 <benny99> hmk
08:04:41 <Cin> is (a -> b -> c) -> ((a, b) -> c) precisely equivalent to (a -> b -> c) -> (a, b) -> c?
08:05:08 <Lemmih> Cin: Yes.
08:05:16 <Cin> ah, i thought so.
08:05:21 <taruti> Is it guaranteeded that "fail m >> anything" <=> "fail m" or is mzero required for those semantics?
08:05:45 <byorgey> Cin: the function arrow associates to the right, so you can always add and remove parentheses at the far right of a type signature.
08:06:00 <Cin> byorgey: ahh. thanks for clarifying
08:06:08 <sjanssen> taruti: fail doesn't really have any guarantees
08:06:45 <taruti> ok
08:06:50 <byorgey> Cin: in general it corresponds to two different ways of thinking about curried functions: a -> b -> c is "a function of two arguments", whereas a -> (b -> c) is a function of one argument which returns another function.
08:07:01 <byorgey> but they're actually the same thing.
08:07:30 <Nafai> byorgey: Morning!  Any fun projects now you are done with grad school apps?
08:07:44 <byorgey> morning Nafai!
08:07:47 <byorgey> of course =)
08:08:32 <byorgey> I'm going to write up some documentation related to xmonad, and I've also started working (just for fun) on a Haskell EDSL for creating text adventure games =)
08:08:43 <Nafai> byorgey: Cool
08:08:55 <benny99> byorgey: :)
08:09:08 <byorgey> benny99: were you the one working on a MUD server?
08:09:27 <benny99> the one who wanted to, yeah
08:09:32 <benny99> and still wants to
08:09:35 <byorgey> cool =)
08:09:59 * benny99 is ill currently and thous a bit "limited"
08:10:20 <Cin> byorgey: right. a -> b -> c, because -> is right-associative, is (explicitly) (a -> (b -> c)), right? (sorry about slow reply-time, was afk)
08:10:20 <benny99> I still need to learn more about haskell and it's library I guess :|
08:10:28 <byorgey> benny99: that's too bad, hope you feel better soon =(
08:10:28 <benny99> else my code might scare people to death
08:10:31 <benny99> or beyond :(
08:10:41 <benny99> byorgey: thanks ^^ -- got just a cold
08:10:59 <byorgey> benny99: that's ok, the only way to learn is by trying things -- and you can always start over of course once you've learned more
08:11:07 <byorgey> Cin: right.
08:11:10 <Cin> yay
08:11:29 <benny99> byorgey: well... I dunno really where to start either Y_Y
08:12:18 <byorgey> benny99: heh, yeah, I remember that feeling... just start somewhere and you'll eventually figure out where you should have started, then you can go back to it =)
08:13:19 <benny99> byorgey: ok, I might just start tomorrow, if you take the responsibility for some peoples head exploding :|
08:14:18 <byorgey> benny99: heh, ok =)
08:15:48 <wy> What's the orginal paper for GADTs?
08:16:25 <mattam> Xi's I think
08:16:30 <benny99> wy: :D still at the GADTs ?
08:17:08 <mattam> of course if you see GADTs as contrived inductive families then it's much earlier :)
08:17:37 <benny99> mattam: 10$ on "I would not even know what that is..."
08:18:32 <conal> wy: might be http://research.microsoft.com/~simonpj/papers/gadt/ .  if not, there will be refs from that url.
08:18:33 <lambdabot> Title: Simple unification-based type inference for GADTs
08:19:00 <mattam> benny99: Well, its complicated to put it in one phrase :)
08:20:59 <mattam> Inductive types indexed by something, as in vector : nat -> *, term : list type -> type -> *, less_than : nat -> nat -> Prop...
08:22:05 <benny99> hm :|, kinds ?
08:23:52 <Sizur> what's a good paper on monadic parsers?
08:25:31 <mrd> http://citeseer.ist.psu.edu/50754.html
08:25:32 <lambdabot> Title: Monadic Parser Combinators - Hutton, Meijer (ResearchIndex)
08:27:28 <benny99> *yeah*
08:33:56 <gbacon> @pl dropEven (x:xs) = x : dropOdd xs
08:33:56 <lambdabot> dropEven = ap ((. dropOdd) . (:) . head) tail
08:34:03 <gbacon> @botsnack
08:34:03 <lambdabot> :)
08:34:15 <dons> ?users
08:34:16 <lambdabot> Maximum users seen in #haskell: 434, currently: 411 (94.7%), active: 20 (4.9%)
08:35:28 <dozer> mm - now that I've heavily optimized my code, I'm left with hxt being the bottleneck
08:35:47 <dozer> it seems to be aprox 10x slow than java at processing a 20m xml file
08:35:57 <wy> What about this paper? http://citeseer.ist.psu.edu/meijer91functional.html
08:35:58 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
08:36:10 <gbacon> dozer: :-(
08:36:43 <dozer> yeah, but I don't fancy tring to re-write hxt
08:36:58 <Cin> 20MB :o
08:37:16 <gbacon> dozer: ghc 6.8?
08:37:24 <dozer> oh, xml files get arbitrarily large in bioinformatics - not unusual to have multi-gig xml files
08:37:26 <dozer> yeah gbacon
08:38:38 <dozer> I think the xpickle stuff is doing massive amounts of back-tracking
08:40:10 <gbacon> does anyone know of head-to-head tests of HXT vs. HaXmL?
08:40:23 <dcoutts_> gbacon: ask malcolmw if he knows of any
08:40:41 <malcolmw> I was just going to say that I'd be interested to see anything like that...
08:41:03 <dons> head to head compile times? ;)
08:41:16 <gbacon> dons: wocka-wocka-wocka
08:41:19 <dcoutts_> heh, HXT is >100 modules, takes forever
08:41:35 <dons> research project syndrome
08:42:07 <gbacon> HXT client code is so nice to look at
08:43:10 <gbacon> dozer: have you played around with different optimization levels?
08:43:18 <gbacon> perhaps some end up being pessimal
08:44:19 <dcoutts_> do any of our xml libs provide an equivalent of SAX, ie a pre-order fold over the xml tree?
08:44:29 <dcoutts_> so it can work in parse order
08:44:36 <malcolmw> Text.XML.HaXml.Sax
08:44:54 <dcoutts_> malcolmw: does that give a list or a fold?
08:45:08 <malcolmw> HaXml also has a lazy XML parser, so if your tree usage pattern is well-behaved, you get good performance
08:45:15 <dcoutts_> mm
08:45:26 <dcoutts_> I guess that's equivalent
08:45:38 <dcoutts_> though you have to know your traversal is well behaved
08:45:39 <malcolmw> the SAX module gives a list of things - I didn't write it, so am hazy on the details
08:46:03 * Cin read that as "ham azy"
08:47:54 <malcolmw> dons: I notice that "nobench" now records the executable sizes of programs - but is there a way to generate a results table that includes the size information?
08:49:13 <dons> malcolmw: haven't touched that code in 6 months. there's a way, but you'll need to add stuff to the results outputter
08:49:35 <malcolmw> dons: OK, I'll dig around in there
08:51:04 <dons> http://www.goesping.org/archives/2007/12/18/haskell-is-kind-of-cool/
08:51:07 <lambdabot> Title: Haskell is kind of cool., http://tinyurl.com/345l2a
08:52:04 <nolrai> im geting an error, which doesnt make much sense, from GHC when it trys to compile the Ciro libraries.
08:53:00 <nolrai> http://tinyurl.com/345l2a
08:53:00 <nolrai> gtk/Graphics/UI/Gtk/Cairo.chs.pp:103:35:
08:53:00 <nolrai>     Couldn't match expected type `ReaderT r IO a'
08:53:00 <nolrai>            against inferred type `Control.Monad.Reader.ReaderT Cairo IO a'
08:53:02 <lambdabot> Title: Haskell is kind of cool.
08:53:25 <dons> http://programming.reddit.com/info/63fl2/comments/
08:53:30 <dons> Catamorphisms - for people who don't know what catamorphisms are!
08:53:43 <dons> hey i wonder, is reddit blocking lambdabot's url requests?
08:54:01 <dcoutts_> nolrai: is that the 0.9.12.1 tarball? what version of ghc and mtl is that?
08:55:24 <nolrai> I think its the most resent GHC but how would i determan the version of the mtl?
08:57:09 <Igloo> It sounds like you have multiple mtl's
08:57:21 <Igloo> Try ghc-pkg -l
08:57:33 <ricky_clarkson> dons: I get lost here: "So typologically we have 1 + (a,List a)."
08:58:20 <quicksilver> ricky_clarkson: "+" in types is like Either
08:58:30 <nolrai> its mtl-1.0.1 is that old?
08:58:32 <quicksilver> ricky_clarkson: and "1" in types is a fragment with a single value
08:58:43 <quicksilver> ricky_clarkson: so (1 +) is just like Maybe
08:59:40 <ricky_clarkson> (1 + 1) is just like Either?
08:59:53 <doserj> 1+1 = Bool
09:00:11 <doserj> = Either True False :)
09:00:25 <doserj> or Either () () in Haskell
09:00:40 <ricky_clarkson> Where can I read about this?
09:03:29 <dons> ricky_clarkson: hmm. TAPL perhaps?
09:05:44 <quicksilver> ricky_clarkson: 1+a is Maybe a; a+b is Either a b. 1+1 is Bool.
09:06:13 <doserj> ricky_clarkson: you can try to read it as simplified haskell data type declarations, where the constructors just don't have names :)
09:06:20 <quicksilver> ricky_clarkson: then you need another operator for product types. The author you quoted was using comma for that, although you sometimes see /\ (logical and) or *
09:10:06 <ricky_clarkson> I seem to vaguely get what you guys said, but I can't extrapolate it to getting from Node :: (a,List a) -> List a to 1 + (a,List a)
09:10:40 <doserj> List a = Nil | Cons (a,List a)
09:11:00 <ricky_clarkson> That helps, thanks.
09:11:10 <doserj> now ignore the names Nil and Cons, and replace | with +
09:11:40 <ricky_clarkson> Is this basically topology for types?
09:12:59 <ricky_clarkson> dons: Anywhere I can read that doesn't require me to insert coins?  I've nothing against buying books, but I like to see them first.
09:14:00 <Cale> What's up?
09:15:58 <dons> ricky_clarkson: maybe bob harper's plbook. there's a link from haskell.org's book page
09:18:50 <ricky_clarkson> dons: Thanks..  I already had that and forgot.
09:32:44 <nomeata> now haddock seems to complain about something:
09:32:45 <nomeata> dist/build/tmp/Main.hs:"dist/build/tmp/Main.hs": 43:1: parse error in doc string: [TokSpecial '/',TokString ".xmonad",TokSpecial '/']
09:33:21 <doserj> "/" has to escaped in haddock comments
09:35:16 <chadz> Anyone know of a nitty-gritty haskell book along the lines of bjarne stroustrup's c++ book, or ritchie/kernighan's C book? (had a coworker ask, surprisingly)
09:36:50 <BMeph> @go haskell for C programmers
09:36:52 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
09:36:52 <lambdabot> Title: Haskell for C Programmers
09:37:08 <BMeph> Maybe: YMMV. ;)
09:37:15 <Lycurgus_> nothing can be as authoritative as that on the language level I think
09:37:35 <Lycurgus_> something from Glasgow re ghc perhaps
09:37:39 <BMeph> Lycurgus_: H98 can.
09:37:54 <Lycurgus_> and there are the specs such as that just mentioned
09:37:56 <BMeph> Lycurgus_: The report, that is.
09:38:19 <bench> any libraries out there for dealing with json rpc or soap for haskell? googling didn't find anything interesting
09:38:46 <chadz> but no books?
09:39:07 <BMeph> The GHC docs are mainly about how GHC compiles and interprets Haskell, but seems to assume you've already read the report.
09:39:26 <BMeph> chadz: The H98 Report is big enough to be a book.
09:39:35 <BMeph> @go Haskell report
09:39:36 <lambdabot> http://www.haskell.org/onlinereport/
09:39:36 <lambdabot> Title: The Haskell 98 Language Report
09:39:45 <chadz> k, thanks.
09:39:52 <Lycurgus_> but nothing corresponding to situation in C++ with the two by Stroustroup (the one him alone the other with Margret Ellis)
09:40:32 <BMeph> Lycurgus_: True, true.
09:41:21 <monochrom> what is nitty-gritty?
09:41:40 <Lycurgus_> american slang for basic
09:41:44 <Lycurgus_> fundamental
09:42:06 <ricky_clarkson> Not particularly American.
09:42:19 <Lycurgus_> well english anyway
09:42:20 <mauke> nub
09:42:36 <monochrom> Hudak's is pretty basic and direct.
09:43:56 <BMeph> North American, maybe.
09:44:01 <monochrom> Bird's and Hutton's are pretty basic and direct too. However, Hudak's gets to I/O early on, the others later.
09:44:14 <BMeph> @ty second reverse
09:44:17 <osfameron> "nitty gritty" is quite british too
09:44:18 <lambdabot> forall a d. (d, [a]) -> (d, [a])
09:44:32 <osfameron> hudak does waffle quite a lot about proofs and such
09:45:02 <monochrom> I think it is a necessity.
09:45:32 <BMeph> osfameron: Really? I thought it started getting used in the 1920's - I'll have to look it up. Thanks. :)
09:47:10 <osfameron> BMeph: well, British English has taken the odd thing from American language since the 1920s...
09:47:48 <BMeph> osfameron: Good point. Pity, though... ;)
09:48:34 <Lycurgus> yeah, it's an English idiom, no direct cognates apparently even in Nederlands or Hochdeutsch, spanish maybe ...
09:50:03 <osfameron> http://www.phrases.org.uk/meanings/nitty-gritty.html is interesting but doesn't suggest what the earliest use was
09:50:03 <lambdabot> Title: Nitty-gritty
09:50:11 <osfameron> I guess the OED or similar would be more useful
09:50:25 <Lycurgus> el quid
09:51:26 <Lycurgus> la parte mas substantial, real or verdadera (de una situacion, accion, etc.)
09:56:00 <mmmdonuts> Here's a teaser on the subject of nitty gritty: http://tinyurl.com/2m6v79
10:01:40 <mmmdonuts> And: http://en.wiktionary.org/wiki/Talk:nitty-gritty
10:01:40 <lambdabot> Title: Talk:nitty-gritty - Wiktionary
10:02:57 <bench> can someone help with my json/soap library question?
10:03:51 <malsyned> When I use Haskell, I occasionally wish I could use a
10:04:12 <osfameron> yeah it would be useful for writing functions like "map" and "append"
10:04:24 <malsyned> 'for' loop or store some global state.  But I can't go five minutes in another language without bashing my head against the wall for lack of lazy lists and the functions defined in the Prelude.
10:04:50 <malsyned> Combined with the fact that I don't use Haskell at work, and you've got one frustrated programmer.  Thanks, Haskell!
10:05:30 <Lycurgus> did everyone else see osfameron's last remark come between two of malysyned's?
10:05:46 <malsyned> malsyned: I did.
10:05:49 <ricky_clarkson> malsyned: I am here to promote Scala to you. ;)
10:06:45 <osfameron> Lycurgus: yes, that was just a stupid joke, sorry (luckily I got in between the remarks, or would have looked even stupider)
10:06:45 <malsyned> ricky_clarkson: Scala is a JVM language so far, right?
10:07:04 <Nafai> I think there is also a .NET backend, isn't there?
10:07:12 <ricky_clarkson> Yes, and somewhat a CLR language.
10:07:16 <osfameron> ricky_clarkson: was it you that blogged about Scalar recently on planet.haskell ?
10:07:18 <Lycurgus> oh, np, just wanted to make sure IRC was still sane
10:07:21 <ricky_clarkson> The .NET backend is behind.
10:07:25 <ricky_clarkson> osfameron: No.
10:08:05 <osfameron> ah no, was this one http://unenterprise.blogspot.com/2007/12/no-seriously-why-scala.html
10:08:06 <lambdabot> Title: Desperately UnEnterprise: No, seriously, why Scala?, http://tinyurl.com/2snmdl
10:08:13 <ricky_clarkson> That's DRMacIver.
10:08:52 <osfameron> yeah, sorry
10:09:25 * BMeph pauses for effect
10:09:31 <BMeph> ...MacIver!
10:11:05 --- mode: ChanServ set +b *!n=gschuett@*
10:11:49 <ZsoL> why is he banned?
10:13:23 <Saizan_> known troll, it seems
10:14:28 <Armored_Azrael> Saizan_: Odd, because /whois antipaladin reveals the same guy, only with username g, not banned
10:15:24 <Lycurgus> musta done something bad, this is a pretty tolerant channel, or maybe he was shitlisted by freenode
10:15:43 <ZsoL> probably the latter
10:17:26 <Lycurgus> sometimes a channel will be under attack and they start banning anybody online at the time and you have to let them know the made a mistake
10:17:32 <Lycurgus> y
10:18:42 <Lycurgus> the freenode admins don't know who is a regular in a given channel
10:20:30 <noteventime> Does someone have a good example where the use of closures is "better" than the use of objects
10:21:05 <malsyned> That's a good question.
10:21:08 <noteventime> I need it to convince a friend
10:21:24 <noteventime> And I'm not very good at making up concrete examples :-/
10:21:42 <loupgaroublond> when you don't want objects, when you just need functions to pass to higher order functions
10:22:01 <malsyned> Any class which has only a constructor and a single instance method is a great candidate for a closure that does the same thing in fewer lines of code and with less semantic overhead.
10:22:01 <sjanssen> @protontorpedo
10:22:01 <lambdabot> check otu squeak seems dope
10:22:07 <sjanssen> gschuett is that guy
10:23:03 <Saizan_> heh, in haskell you almost forget you're using closures in the presence of partial application
10:23:09 <Lycurgus> doesn't that question sort of apply to CL or ocaml better than haskell?
10:23:43 <malsyned> Lycurgus: I'd agree with that.  Closures can do a lot of interesting tricks in languages with assignment that they can't do in Haskell.  But they're still pretty handy in Haskell.
10:24:45 <malsyned> noteventime: closures and functions like map and filter interact very well together.  If you have closures, then replacing all your looping syntax with a function starts to look like a reasonable idea.  If you don't, and you have to declare a new class and instantiate it just to pass the instance to "map" to get idiomatic looping behavior, "map" and "filter" stop looking like good ideas.
10:24:49 <osfameron> yeah, closure iterators etc. are handy with assignment
10:25:36 <noteventime> Thanks for the suggestions :-)
10:26:51 * Saizan_ has lost the ability to exploit assignment
10:27:03 <Saizan_> osfameron: can you elaborate?
10:27:15 <malsyned> My line of thinking usually goes: I want to abstract out a common looping pattern or other data structure traversal pattern.  so I'm going to need first-class functions (at least a-la C function pointers).  Now it would be really great if I could define anonymous functions right there in the argument lists.  Well gosh, now I need closures or my scoping rules will be completely unintuitive.
10:27:58 <osfameron> Saizan_: sub it { my $x = 0; return sub { $x++ } }
10:28:27 <malsyned> I guess that basically boils down to: Closures let you implement the Visitor pattern in less than one line of (overhead) code.
10:28:42 <nolrai> what are closures in this context?
10:29:16 <osfameron> Saizan_: i.e., because you can assign to the closed over lexical scope, you can use it to yield iterated values
10:30:00 <malsyned> nolrai: Same as always.  A data structure representing an invokable chunk of code which has reference to some possibly non-global variables (usually called an "environment")
10:30:00 <noteventime> nolrai: Mostly high order functions, but if you have an example where the closure captures local state (in a language that's nore purely functional) it would be even better
10:30:24 <Saizan_> osfameron: ah, right, that's a common scheme example i think, thanks :)
10:30:46 <malsyned> noteventime: technically, I think you mean "first-class functions".  A "higher-order function" is a function to which you can pass a function as an argument.
10:31:04 <noteventime> malsyned: Ohh, right. Sorry :-)
10:31:21 <noteventime> I'm still a little new to the terminology
10:31:35 <osfameron> Saizan_: cool.  In many ways less convenient than lazy lists of course, but kinda handy)
10:31:42 <noteventime> I got to go, Thanks for the suggestions
10:32:02 <malsyned> noteventime: good luck with your evangelizing.
10:46:36 <ac> why is the source release for 6.8.2 only 6.7M, and the binary is 47M?
10:47:02 <ac> (for GHC I mean). If I was concerned about size, is there anything that could easily be chopped out of that?
10:48:50 <olsner> Haskell is actually just a good compression scheme for assembly code
10:49:40 <Cale> Not even assembly, but actual machine code :)
10:49:59 <ac> olsner: lol
10:50:12 <olsner> Cale: indeed
10:52:00 <Cale> It *might* have something to do with the lack of dynamic linking though.
10:52:28 <noteventime> Is there any progress being done on dynamic linking=
10:53:18 <Saizan_> there has been a SoC progect on it
10:54:03 <Saizan_> thos summer
10:54:17 <Cale> I think it either is or was working on OSX.
10:54:42 <Cale> There hasn't been a whole lot of demand for it.
10:55:59 <Cale> Generally static linking the RTS, etc. has made Haskell programs easier to distribute anyway, since there are only so many Haskell users.
10:58:13 <dcoutts_> ac: it has several binaries that are not actually installed and it has lots of profiling libs and libs you might not use (like the GHC lib)
10:59:06 <ac> dcoutts_: ok, and I can just remove them with ghc-pkg (or whatever that command is)
10:59:06 <jimstutt> ac: ghc-6.8.2 binary has all the libs. The src bundle doesn't even have a Makefile or config files which makes things a bit difficult?
11:00:01 <Cale> afaik, ghc-pkg doesn't actually remove any files when you unregister a package.
11:00:30 <noteventime> I just realised that the newest ghc in Gentoo is 6.6.1 O_o
11:00:41 <dcoutts_> noteventime: 6.8.2 is in the haskell overlay
11:00:42 <ac> Oh right. Well I can always "rm -rf lib/..."
11:01:06 <dcoutts_> noteventime: and works pretty well, we're just discussing the final testing to get it into portage
11:01:26 <noteventime> dcoutts_: Do you have a link for it?
11:02:03 <dcoutts_> noteventime: use layman to get the haskell overlay and see #gentoo-haskell
11:02:43 <noteventime> dcoutts_: I'm using paludis, I can't use layman :-/
11:02:50 <noteventime> As far as I know anyway
11:03:51 <dcoutts_> noteventime: I've no idea if the haskell packages work with paludis anyway, we have no way of testing them
11:04:03 <dcoutts_> noteventime: do the ones in portage work ok for you?
11:04:18 <Saizan_> is there a darcs command to see which patch has inserted/modified a line in a file? i remember something like this, but darcs changes file just lists the patches without telling their contribute to the file
11:04:25 <Heffalump> darcs annotate?
11:09:48 <Saizan_> Heffalump: yes, thanks
11:25:17 <gabrielmc> I am having a beginner's problem with understand how the IO monad works.
11:25:33 <gabrielmc> http://hpaste.org/4579
11:26:06 <gabrielmc> How can one do IO and return a different type?  Is this just a total misunderstanding on my part?
11:26:11 <allbery_b> you can't mix monads like that
11:26:16 <gabrielmc> Ah
11:26:17 <Zao> gabrielmc: You need to return IO (Maybe Term)
11:26:24 <gabrielmc> How do I fix that?
11:26:40 <gabrielmc> IO (Maybe Term) seems kind of, well, ugly.
11:26:43 <Zao> and use return to return your value.
11:26:48 <Saizan_> "once you're in IO you can never get out"
11:26:48 <Zao> gabrielmc: It's the way.
11:26:53 <loupgaroublond> gabrielmc: there's no escaping the IO monad, but other monads let you do that
11:27:23 <gabrielmc> Harumph
11:27:38 <allbery_b> see http://hpaste.org/4579#a1
11:27:38 <gabrielmc> Ok.  Thank you.
11:27:47 <Saizan_> gabrielmc: you may like this: http://haskell.org/haskellwiki/Introduction_to_IO
11:28:00 <allbery_b> whatever calls that needs to be in IO itself, though.
11:28:04 <desegnis> gabrielmc: If you think it is ugly, come to think of what you want to do. Why do you want to return the (Maybe Term) when you print it out?
11:28:43 <allbery_b> better would be to design it to return IO () and toss that value, sine there's no good reason to return what was passed in
11:29:00 <gabrielmc> It's being passed, stream like, from operation to operation, so packing and unpacking from IO uggifies the code a little.
11:29:47 <allbery_b> hm.  are you providing a trace log of operations?  you might ant to look at the Writer monad instead
11:29:51 <Saizan_> in fact haskell programs should be structured as a thin IO layer around the pure core
11:30:25 <noteventime> Hehe, you just answered something I've been wondering :-D
11:31:34 <SamB_XP> how do you make the IO layer thin for interactive programs?
11:31:49 <gabrielmc> Stole my question.
11:32:22 <allbery_b> check the haskell-cafe discussion of the Game monad
11:32:34 <desegnis> http://hpaste.org/4579#a2
11:32:44 <gabrielmc> What I'm writing is an expression evaluator which should retain some notion of the old value passed in while reporting errors and passing forward terms.
11:32:55 <allbery_b> basiclaly, abstract out as much of the IO as possible into one place and invoke pure stuff in response to events
11:33:09 <SamB_XP> of course, the REAL problem I'm stuck on in my Z-machine interpreter is actually "what in the world shall I use for the status area"
11:33:14 <allbery_b> not a whole lot different from event-loop-based processing in e.g. C
11:33:51 <noteventime> allbery_b: Do you have a link for that thread?
11:34:22 * SamB_XP actually has his whole interpreter running on top of the IO monad, but it communicates with the UI using a Chan and MVars...
11:34:31 <allbery_b> gabrielmc: sounds like Writer to me.  tell the initial value and all evaluation steps, get at the end the final value (or error, using Either) and he audit log
11:34:59 <gabrielmc> Thanks.  I'll look it up!
11:35:02 <allbery_b> noteventime: nit offhand, but a search of the archives for "Game monad" should find it readily
11:35:19 <noteventime> allbery_b: I did, is it the one called "Re: 'Proper' use of the State monad"
11:35:43 <SamB_XP> but GTK seems not to have any decent widgets for character-cell displays...
11:35:52 <allbery_b> I think it roamed around a bit, it was actually an expansion on an earlier disccusion of a Prompt monad whichj had its own subject
11:36:25 <noteventime> I got to go
11:36:39 <noteventime> I'll check the game monad later :-)
11:37:05 <allbery_b> look for the stuff weith the subject like of the Prompt monad, follow the threads
11:37:43 * SamB_XP is pretty sure his Z-machine interpreter only uses the IO part of the monad for communication with the UI...
11:40:51 <lament> you havea z-machine interpreter??
11:40:52 <lament> crazy.
11:41:53 <scodil> what are the reasons that a function (class method) might not be inlined despite an INLINE pragma? Besides obvious reasons like recursion.
11:43:38 <alexj> anyone know the real name of this function? mbSumIO f = foldl (\mbVal item->maybe (f item) (return . Just) =<< mbVal) (return Nothing)
11:44:00 <alexj> it basically runs through the list until it finds a an IO value.
11:44:34 <vincenz> Hey peeps
11:48:28 * shivernz waves
11:54:16 <shivernz> has anyone done the "Write Yourself a Scheme in 48 hours" tutorial?
11:54:38 <shivernz> was wondering if there were answers to the exercises so i can tell if I got things right
11:55:26 <loupgaroublond> shivernz: just try compiling some libs, if it's a full interpreter, it will work
11:55:58 <shivernz> unfortunately it's not full yet. only the beginning actually.
12:00:25 <SamB_XP> well, what have you tried so far?
12:01:58 <shivernz> i've just added something to parse literal quotes withing a string
12:02:02 <shivernz> instead of excluding them
12:03:01 <SamB_XP> and ... you don't know how to test that?
12:03:46 <shivernz> well, the tests i run look ok, at least most of them do. just want to know if i did it right and i don't have some flawed logic
12:05:10 <SamB_XP> I don't think there's much room for flaws in that ;-)
12:05:43 <olsner> nothing's too small to have bugs
12:05:56 <SamB_XP> olsner: write me a buggy id
12:06:23 <olsner> @type const undefined
12:06:24 <lambdabot> forall a b. b -> a
12:06:33 <SamB_XP> that doesn't look remotely similar
12:06:43 <olsner> heh, I noticed
12:06:51 <SamB_XP> well, I didn't even mean the type
12:06:56 <mauke> id tehValue = theValue
12:06:58 <ac> I decided to go with hugs instead of GHC, as it's MUCH smaller
12:07:02 <SamB_XP> the code looks completely different too
12:07:04 <ac> is hugs not a compiler?
12:07:10 <mauke> ac: no, it's just an interpreter
12:07:11 <allbery_b> nope
12:07:20 <olsner> SamB: mauke's candidate is pretty good though
12:07:21 <shivernz> the reason why i have my doubt to if it is right is because giving it a string like: "\"" fails
12:07:22 <ac> that would explain why it's so much smaller
12:07:33 <shivernz> but something like: "a\"a" passes
12:07:46 <SamB_XP> shivernz: why is there any doubt?
12:08:02 <SamB_XP> it's not right ;-)
12:09:04 <shivernz> yeah. i was trying to live in denial and hoping that if i saw the answer, it would somehow match mine :D
12:09:17 <SamB_XP> don't do that ;-)
12:09:37 <shivernz> ill try not to :)
12:09:52 <ac> m_stone: you around?
12:10:07 <SamB_XP> I mean, it's one thing to be worried that you just haven't tried the inputs that will break your parser...
12:11:11 <SamB_XP> but another to hope that the inputs that break your parser actually are supposed to work that way...
12:13:01 <shivernz> SamB_XP, its good to live in hope
12:13:20 <shivernz> you know, end to war and all that stuff...
12:13:47 <shivernz> "always look on the bright side of life..."
12:15:12 <nolrai> > zip [(0.0)..(3,3)] ['a'..]
12:15:13 <lambdabot>   add an instance declaration for (Fractional (t, t1))
12:15:13 <lambdabot>     In the expression:...
12:15:19 <nolrai> > zip [(0,0)..(3,3)] ['a'..]
12:15:20 <lambdabot>   add an instance declaration for (Enum (t, t1))
12:16:35 <nolrai> it seems odd that (a,b) has a ix instance and not a Enum instance. Is there a reason for that?
12:17:00 <mauke> define one
12:17:10 <nolrai> i guess.
12:19:34 <nolrai> I see you need the column/row(more changable) lenght.
12:23:59 <alexj> FYI just released the new version of SearchPath which supports darcs/svn repos and tgz archives.
12:24:22 <alexj> http://searchpath.org
12:24:23 <lambdabot> Title: SearchPath
12:27:36 <pchiusano> hello
12:27:40 <_XdarkiX__150526> hi
12:27:45 <_XdarkiX__150526> wer sucht gilde
12:29:09 <pchiusano> I have a question about haskell's type system
12:29:31 <pchiusano> why is f (f x) = f x not allowed?
12:29:59 <pchiusano> I mean, I know you can only have primitives or ctors on the lhs of an equation, but why is that?
12:30:17 <mauke> what type would you give to f?
12:30:21 <pchiusano> also, would it be possible to give the type for f?
12:30:36 <pchiusano> mauke: I don't know
12:30:55 <mauke> it would match any single-parameter constructor
12:30:55 <doserj> pchiusano: how would you, in general, know that a certains value matches the pattern f x?
12:31:06 * Lemmih can't even see what that code would do.
12:31:33 <pchiusano> I guess I am thinking of functions like reverse:
12:31:44 <mauke> oh, you want the f's to be the same?
12:31:47 <mauke> that's even more impossible
12:31:57 <pchiusano> reverse (reverse x) = x
12:32:26 <mauke> no, the second reverse would be an independent variable there
12:32:36 <byorgey> pchiusano: but that's not a definition of reverse, just a property that reverse should satisfy (for finite x)
12:32:39 <mauke> and bound by the pattern matching process
12:33:17 <tetha> well, f(f x)) = f(x) can be defined for some very special f(x)
12:33:36 <pchiusano> tetha: can you explain?
12:33:44 <tetha> pchiusano: think of f x = 5
12:34:19 <desegnis> pchiusano: That wouldn't even be a definition, because  r . r == id  holds for several (?) functions r.
12:34:50 <tetha> or something like f x = if(x > 0) then 1 else -1, something like that. but in general, this wont hold: g x = x+1 breaks already
12:34:58 <pchiusano> okay, what about this:
12:35:56 <pchiusano> suppose I have reverse defined by two equations:
12:36:21 <pchiusano> reverse l = foldl (flip (:)) [] l
12:36:32 <pchiusano> reverse (reverse l) = l
12:36:43 <mauke> what's the second equation for?
12:37:00 <pchiusano> it is an optimization of the function
12:37:02 <tetha> mauke: random proofs for students?
12:37:03 <nolrai> maby he wants a rule?
12:37:11 <mauke> pchiusano: no, it isn't
12:37:15 <mauke> it changes the semantics of reverse
12:37:34 <pchiusano> and it is consistent w/ the type of the first equation, or is it?
12:37:46 <pchiusano> you mean for infinite lists?
12:37:49 <mauke> yes
12:38:10 <byorgey> well, maybe reverse isn't the best example, but yes, I think maybe pchiusano wants RULEs?
12:38:28 <pchiusano> rules?
12:38:50 <byorgey> pchiusano: ghc has things called rules that allow you to provide various optimizations/code transformations for ghc to apply while compiling your code.
12:38:51 <desegnis> pchiusano: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
12:38:52 <lambdabot> Title: 8.13. Rewrite rules, http://tinyurl.com/y7rk9g
12:38:55 <tetha> hm. how do proofs for infinite lists work?
12:38:57 <mauke> rules rule
12:39:15 <Cale> tetha: induction
12:39:17 <byorgey> you could use a rule to do something like reverse (reverse l) = l (although as mentioned that's not a great example)
12:39:24 <byorgey> (since it's wrong =)
12:39:47 <desegnis> tetha: IIRC, the base case is undefined, the induction step is undefined -> (x:undefined)
12:39:53 <pchiusano> yes, I know ghc does that, but I was more curious why rules like that couldn't just be regular haskell
12:40:15 <tetha> Cale: afaik, structural induction only works if you assume a finite number of steps taken in order to reach your current step
12:40:45 <Heffalump> desegnis: the step is xs -> x:xs
12:41:00 <byorgey> pchiusano: well, that would basically require doing pattern-matching on the actual structure of the code, which would have to be carried around at runtime
12:41:02 <fadec> What's the best haskell mode for vim?
12:41:06 <byorgey> I'm not sure that would even be possible.
12:41:10 <Cale> tetha: Induction actually works on any well-ordered set.
12:41:10 <Heffalump> and your predicate needs to be chain-complete
12:41:24 <pchiusano> byorgey: that makes sense
12:41:24 <mrd> @go reinke vim haskell
12:41:26 <lambdabot> http://article.gmane.org/gmane.comp.lang.haskell.general/15180
12:41:26 <lambdabot> Title: Gmane -- Mail To News And Back Again
12:41:39 <fadec> mrd: thanks
12:41:48 <desegnis> Heffalump: You're obviously right.
12:42:00 <tetha> ah, I remember. instead of proving p([]) you prove p(undefined) and then stepping from xs to x:xs, and then, reverse(undefined) = undefined and things splode.
12:42:13 <byorgey> pchiusano: but you can easily do something like this if you reify expressions as an algebraic data structure, and then write code to optimize/evaluate expressions.
12:42:14 <Heffalump> tetha: right.
12:42:37 <Cale> You can use the usual form of mathematical induction for well-ordered sets to prove the validity of something called coinduction, which is convenient for infinite datastructures.
12:42:46 <byorgey> data Exp a = Reverse (Exp a) | ListL [a] ...
12:42:48 <pchiusano> byorgey: yes, I can see that
12:42:50 <nolrai> doent ghc have somthing to do that at compile time?
12:43:01 <tetha> whereas that "undefined" is not the most correct term, "takes infinite time to compute" is better :)
12:44:12 <nolrai> why isnt reverse (reverse I) == I?
12:44:13 <byorgey> nolrai: to reify Haskell expressions?  well, yes, and so does every compiler =)
12:44:25 <Cale> nolrai: consider [1..]
12:44:25 <byorgey> nolrai: that's only true for finite lists.
12:44:31 <njbartlett> Heffalump: How's the flu?
12:44:31 <Cale> > reverse [1..]
12:44:46 <lambdabot>  thread killed
12:45:06 <Cale> So reverse (reverse [1..]) isn't the same as [1..]
12:45:09 <Heffalump> still unpleasant. My temperature has been stuck at about 102F all week.
12:45:27 <tetha> Cale: you dont know, it is "some value that takes infinite time to calculate"
12:45:58 <Heffalump> tetha: otherwise known as bottom
12:46:02 <pchiusano> Cale: but that is more because Haskell's type system does not distringuish between data and codata
12:46:05 <tetha> Heffalump: indeed
12:46:36 <Heffalump> how would codata help? You still can't inspect anything about reverse [1..]
12:46:41 <nolrai> pchiusano: that would be nice
12:47:04 <sclv_> Heffalump: reverse [1..] would be a type error with codata!
12:47:07 <mrd> Heffalump: the theorem is true for data
12:47:09 <sclv_> er, I think.
12:47:09 <pchiusano> actually, you are right
12:47:17 <Heffalump> oh, I see.
12:47:25 <pchiusano> you would not be able to define reverse for infinite lists
12:47:29 <mrd> and for codata you would have to talk about bisimulation
12:47:38 <mrd> anyway
12:48:03 <sclv_> I was getting a handle on data/codata the other day and as far as I saw, there are reasonable codata implementations for Haskell.
12:48:21 <sclv_> the hard part was data.
12:49:01 <nolrai> yeah because in a lazy languege how do you describe a unspecified but finite length?
12:49:07 <sclv_> I could see a method to construct FiniteList by providing only safe combinators, but couldn't see any reasonable way to encode it in the type system.
12:49:42 <Cale> nolrai: by making the constructor strict
12:50:00 <mrd> data List a = Nil | Cons !a !(List a)
12:50:01 <sclv_> Cale: but that'll just give you a runtime error earlier on.
12:50:09 <nolrai> thats clever
12:50:26 <sclv_> it'll still compile.
12:50:33 <Cale> sclv_: Well, there are no infinite lists of that type.
12:50:36 <pchiusano> just do not expose the constructors
12:50:47 <mrd> sclv_: it'll give you the same behavior as a cbv language
12:50:49 <Cale> Of course, you can always fail to terminate.
12:50:55 <tetha> sclv_: you cannot decide if an arbitrary list is going to be finite
12:51:23 <sclv_> Right, so I was thinking hide the constructor and only let finitelists be declared using enumFromTo
12:51:29 <Cale> But any value which would have been an infinite list will instead be bottom with that type.
12:51:31 <sclv_> and then provide safe operations only.
12:51:32 <mrd> so, primitive recursion
12:51:57 <doserj> then code collatz, and let it type-check...
12:52:27 <Cale> Absolutely every type contains bottom, you can't avoid that.
12:52:50 <mrd> sure you can. work in a strongly normalizing language.
12:52:50 <sclv_> except, i suppose, even with that you could hide a recursion as long as snoc was allowed
12:52:57 <tetha> hm, is there an untyped bottom?
12:52:58 <Cale> But that's not the same as having infinite litst.
12:53:03 <Cale> lists*
12:53:19 <Cale> :t undefined
12:53:20 <lambdabot> forall a. a
12:53:24 <mrd> tetha: _|_ :: forall a. a
12:53:37 <mrd> and is the only thing of that type
12:53:42 <tetha> :)
12:53:48 <Cale> ...sort of.
12:54:02 <mrd> different varieties of "abort" notwithstanding =)
12:54:04 <quicksilver> sjanssen: well I finally found time to read that STM paper.
12:54:16 <quicksilver> sjanssen: Nice. nicely written, too. Makes a good case.
12:54:23 <nolrai> anyway, is it even bad to implement a rule whose only counter examples eval to _|_?
12:54:45 <sclv_> nolrai: if you can't guarantee it will always fire, yes?
12:55:18 <quicksilver> the problem with _|_ is that we do, in fact, care about values which are technically _|_
12:55:19 <sclv_> i.e. if reverse (reverse x) = x was done for ghc but not hugs, then programs which run on ghc will die on hugs.
12:55:40 <doserj> nolrai: sometimes no result is better than a wrong result...
12:55:41 <quicksilver> lots of programs rely on infinite lists or 'infinite' IO actions.
12:55:45 <mrd> well, ghc does have the moral equivalent included in some optimizations
12:56:38 <mrd> some transformations based on parametricity theorems that don't account for seq.
12:57:09 <nolrai> yeah i guess. still seems like there should be a way around. but thinking more looks like it would require solving the halting problem.
12:57:10 <quicksilver> ghc had some broken optimisations
12:57:16 <quicksilver> for this kind of reason
12:57:31 <quicksilver> didn't foldr/build have a broken case?
12:57:50 <nolrai> also seems like somthing you should be able to choose.
12:57:53 <mrd> @free foldr
12:57:54 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
13:02:28 <dcoutts_> quicksilver: it still does
13:03:12 <Saizan_> but stream fusion isn't?
13:03:27 <dcoutts_> not so far as we know
13:04:02 <doserj> how much would you bet? :)
13:04:24 <dcoutts_> depends exactly on the question
13:05:01 <Saizan_> we need a denotational semantic :\
13:05:32 <dcoutts_> I'm trying to formalise the stream fusion rule a bit for my PhD thesis
13:07:24 <doserj> I wouldn't want you to bet you PhD on it, though :)
13:10:41 <pejo> dcoutts, defending your thesis soon?
13:11:18 <dcoutts_> pejo: hope to submit it in a few months
13:11:51 <vincenz> dcoutts_: ibid
13:11:59 <vincenz> also on fusion :)
13:12:09 <pejo> dcoutts, oh, nice. :-)
13:12:18 <dcoutts_> vincenz: the more the merrier :-)
13:12:25 <vincenz> dcoutts_: albeit in the c++/embedded domain
13:12:39 <dcoutts_> yes, that's interesting work
13:12:52 <vincenz> I hope I get it in a decent shape (:
13:18:05 <vincenz> quicksilver:ping
13:24:59 <proqesi> :t (>>=)
13:25:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:25:22 <proqesi> :t ((<$>) . (<$>)) Data.Set.singleton
13:25:23 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1) => f (f1 a) -> f (f1 (Data.Set.Set a))
13:25:59 <Armored_Azrael> dcoutts_: I made the thread scheduler thing and will be using it for my other project. Were you interested in it?
13:27:58 <ndm> has anyone started on a google chart API wrapper in haskell?
13:28:07 <ndm> it seems the obvious thing to do for many things
13:28:31 <ndm> i was going to write a chart generator for Hoogle 4, but a wrapper round the google one would be much easier (and hopefully someone else might do it)
13:32:06 <Armored_Azrael> dcoutts_: Regardless, I'm heading out. If you were interested: http://ugcs.caltech.edu/~maurer/Demon-0.1.tar.gz. Comments very welcome.
13:32:24 <Nafai> ndm: What about this? http://dockerz.net/twd/HaskellCharts It's not a Google Chart API, but it is Haskell
13:32:25 <lambdabot> Title: HaskellCharts - twd
13:34:40 <ndm> Nafai: that is pretty cool, and might be better
13:34:50 <ndm> depends how hard it is to get Gtk2hs bits installed on haskell.org
13:35:05 <ndm> but gently prodding a maintainer has always worked in teh past
13:35:23 <Nafai> I forgot about that dependency
13:35:52 <ndm> still, more reliable if i can have the png generation on the haskell server
13:36:00 <ndm> although its possible i'll still go google
13:37:04 <DRMacIver> Have implicit parameters been removed now?
13:37:44 <ndm> linear implicit parameters have, not normal ones
13:38:04 <DRMacIver> What's the difference?
13:38:16 <Heffalump> linear ones have to be single-threaded, or explicitly "forked"
13:38:39 <ndm> you can use them for unique ID's, a bit like a monad
13:38:54 <Heffalump> or random numbers (?)
13:39:05 <DRMacIver> Hm. I'm sortof confused as to what that has to do with implicit parameters.
13:39:21 <Heffalump> they're still implicit when you don't use them
13:39:39 <DRMacIver> ok
13:40:09 <ndm> i think the concensus is they weren't as great aspeople thought they might be
13:40:40 <Heffalump> nobody really seems to use them
13:40:57 <Heffalump> s/seems/seemed/
13:41:00 <DRMacIver> What's the flag for enabling implicit parameters then? The docs seems to claim XImplicitParams, but ghci doesn't appear to like that.
13:41:08 <Heffalump> which version?
13:41:44 <DRMacIver> 6.6.1 apparently.
13:41:54 <DRMacIver> (Hm. I thought I was running a later version than that)
13:41:57 <Heffalump> and which docs are you reading? 6.8.1 is happy with that.
13:42:39 <DRMacIver> Hm. Lost the page I was looking at. It's probably that I was reading a later version, yes, as I thought I had a later version on this machine. :)
13:45:33 <DRMacIver> Ah, yes. It used to be -fimplicit-params
13:47:08 <roconnor> I was pondering if applicative functors would be better for random numbers.
13:47:37 <roconnor> f <*> x would give f and x access to random numbers without stating which one gets it first.
13:48:29 <roconnor> but I suppose you need a primitive to support it
13:50:59 <sjanssen> roconnor: I've considered this before
13:51:13 <sjanssen> roconnor: the problem is that you end up violating the applicative laws
13:51:30 <roconnor> sjanssen: oh
13:51:32 <roconnor> :(
13:51:44 <roconnor> well, it's nice that it has been thought through.
13:51:45 * sjanssen searches for the code
13:53:11 <sjanssen> roconnor: http://hpaste.org/3749
13:54:09 <roconnor> sjanssen: do you know which law breaks?
13:55:32 <roconnor> sjanssen: you need to make sure you use the right equivalence relation in your laws ;)
13:55:53 <sjanssen> roconnor: it breaks most of them, IIRC
13:57:00 <sjanssen> roconnor: identity, composition, and interchange are violated
13:59:10 <roconnor> sjanssen: I think you are being to harsh on the laws.  If I replaced x with (fst (split x)) everywhere in my program, would the program be the same?
13:59:34 * roconnor is not sure
13:59:45 <vincenz> > chr 201
13:59:47 <lambdabot>  '\201'
14:00:54 <roconnor> the trick would be to ensure that no independent random variables are transformed into the same random variable
14:03:13 <gbacon> @topic-tell
14:03:13 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
14:06:55 <sclv_> @quote
14:06:55 <lambdabot> JaffaCake says: Casting boxed types to unboxed types or vice versa is pretty much guaranteed to end in tears
14:08:15 <roconnor> @quote kind
14:08:16 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
14:10:23 <Syzygy-> o.O
14:11:24 <roconnor> @quote boring
14:11:25 <lambdabot> monochrom says: recursive directory search is an alpha-beta with boring values of alpha and beta.
14:41:04 <florenz> hi
14:41:10 <Valodim> 'sup
14:41:38 <florenz> does anyone know how to pass C structs between C and Haskell? without pointers.
14:41:52 <mauke> I don't think you can
14:41:59 <florenz> i. e. the C function is of type void f(struct_type a)
14:42:04 <mauke> I mean, even between C and C you can't really do it
14:42:16 <florenz> why does it work then, in C?
14:42:27 <mauke> the compiler silently converts it to a pointer
14:42:40 <mauke> or inlines it, if it's small enough
14:42:42 <sjanssen> really?
14:42:54 <florenz> ah, okay, that's a bit ugly. so i cannot rely on this conversion?
14:42:55 <sjanssen> huh, I always assumed they were passed on the stack
14:43:02 <mauke> at least for returning structs
14:43:05 <pejo> mauke, so why is struct return such a mess to implement?
14:43:09 <florenz> sjanssen: i also believed this.
14:43:23 <mauke> pejo: huh?
14:43:38 <pejo> mauke, when writing a c compiler.
14:43:58 <olsner> I always thought that just depended on the ABI
14:44:44 <florenz> ok, so  i have to wrap all MPI functions that have an MPI_Datatype or MPI_Comm in their argument list to a take MPI_Datatype *
14:45:02 <florenz> in order to call them from Haskell?
14:45:47 <florenz> the thing is that i don't know what they are, in general, they are just typedeffed somehow.
14:47:16 <olsner> Java is like a variant of the game of Tetris in which none of the pieces can fill gaps created by the other pieces, so all you can do is pile them up endlessly.
14:51:20 <pejo> florenz, gcc has the parameter -fpcc-struct-return which makes it behave like pcc does wrt. returning structs.
14:52:13 <pejo> florenz, and gcc defaults to different defaults depending on your platform apparently.
14:54:11 <florenz> pejo: so, if i want to have it reliably i should wrap the functions?
14:54:42 <florenz> pejo: btw., how does pcc return structs and what compiler is pcc?
14:55:52 <pejo> florenz, pcc is an old C-compiler by Johnson (sp?) from the 70's. I think the compiler in old SunOS versions were based on it for example.
14:56:40 <florenz> ok, i see, never heard of it.
14:57:01 <pejo> florenz, I'm not very familiar with the Haskell FFI though, so telling how things look from the C side will only bring you half-way unless you know the FFI stuff yourself.
14:57:47 <pejo> florenz, oh, it returns structs in memory instead of in registers. Code compiled assuming either is of course not binary compatible with the other one.
14:58:37 <allbery_b> pcc was the old AT&T Unix C compiler, yes.  and pcc-style struct returns were done by allocating memory just before the function to hold the return value, because the machines pcc was designed for had only 16-bit registers (so returning pointers was problematic).  which meant recursive functions couldn't return structs
14:58:51 <florenz> yes, i think, i understood the FFI reasonably. and now knowing the issues with struct passing and returning in C i understand why there are basically only pointers (and numbers) in the FFI.
14:59:21 <pejo> ChilliX, I must say that I strongly agree with your latest posts on ghc-users. Make it simple for the users to use GHC!
14:59:44 <ChilliX> pejo: thanks :)
14:59:56 <florenz> pejo, allbery_b: thanks for your explainations.
15:00:55 <ChilliX> pejo: I am working on an automated way to produce mac installer .pkg's for GHC
15:01:11 <ChilliX> with only one dependence, namely Xcode
15:01:24 <pejo> ChilliX, oh, will it be possible to have multiple versions of ghc installed with them?
15:01:59 <ChilliX> Yes, but only multiple version distinguished by major.minor version number
15:02:20 <ChilliX> The idea is to create a GHC.framework (much like Ruby.framework and Python.framework in Leopard)
15:02:26 <pejo> ChilliX, so 6.6.x, 6.8.x and 6.10.x will be usable at the same time?
15:02:37 <ChilliX> frameworks are versioned and you can have multiple versions simultaneously installed
15:02:41 <ChilliX> right
15:02:58 <ChilliX> This is just following recommended practice by Apple
15:03:02 <pejo> ChilliX, ahh. That's sweet. Makes it easier to track down gmp-problems too.
15:03:46 <ChilliX> I have been reading through some of Apple's dev docs on software delivery etc
15:04:00 <ChilliX> and the idea is to just do it in the "standard" way
15:09:57 <pejo> ChilliX, sounds great - things usually "just work" when done the standard way on Macs. :-)
15:14:42 <dcoutts> ChilliX: if you find out anything especially useful I'd like to know, for packaging gtk2hs and for cabal packages generally
15:15:46 <Valodim> how would I trace a stack overflow?
15:17:59 <dcoutts> ChilliX: it'd be nice to have a tool to generate mac binary packages like we have for various linux distros
15:18:47 <dcoutts> Valodim: use ghci to narrow it down by testing bits interactively
15:19:07 <Valodim> I'm doing this: http://projecteuler.net/index.php?section=problems&id=14
15:19:10 <lambdabot> Title: Problem 14 - Project Euler
15:19:20 <Valodim> and I have gone for the obvious approach
15:20:06 <Valodim> to calculate the maximum of a list, it shouldn't need to keep all those entries in memory, nuh?
15:20:08 <dcoutts> Valodim: make your solution tail recursive
15:20:30 <dcoutts> Valodim: no, maximum does not keep them all
15:20:39 <Valodim> sequences = [ x : collatz x | x  <- [1 .. 1000000] ]
15:21:18 <Valodim> that's the list of collatz sequences right now, thought mapping length to it and getting the maximum of the resulting list should work
15:21:57 <Valodim> I realize it's not very elegant but I'm only learning and taking one step at a time :)
15:22:33 <TSC> Valodim: Note that the problem says "under one million", so you want 1..999999 (:
15:22:53 <Valodim> I don't think that one matters ;)
15:22:59 <Valodim> and I have already confirmed it's not 1000000
15:23:14 <TSC> I don't think it matters for this one, but you have to be wary of the wily Euler
15:23:33 <Valodim> what
15:23:58 <Valodim> just thought of a better approach for the task, will try that one
15:26:38 <dcoutts> Valodim: you've not put sequences as a top level value have you?
15:26:51 <dcoutts> Valodim: if you do, I'm not sure it'll be collected
15:27:11 <Valodim> what is a top level value?
15:27:18 <dcoutts> sequences
15:28:02 <Valodim> no, I mean what is a top level value? never heard the term before
15:28:18 <Valodim> just "outside of other functions"?
15:28:32 <monochrom> Yes.
15:28:38 <Valodim> yeah I did
15:31:38 <dcoutts> Valodim: my version is running in constant space
15:32:02 <dcoutts> and take 4 sec for 100000
15:32:12 <Valodim> missing a zero there
15:32:17 <dcoutts> I know
15:33:23 <Valodim> the approach is pretty stupid anyways
15:34:19 <Cale> maximum is written to use foldl, iirc, rather than foldl' which it ought to.
15:34:45 <dcoutts> Cale: it's specialised for Int & Integer
15:34:59 <Cale> Oh, it is now? That's good :)
15:35:15 <dcoutts> well, I thought so. It works for me in constant space using maximum
15:35:21 <Cale> Perhaps he's not compiling with optimisations?
15:39:05 <Valodim> it's in interpreted mode
15:39:18 <dcoutts> that's going to be slow slow slow :-)
15:40:18 <dcoutts> actually this is a lovely example for fusion
15:40:33 <gchin> hi all, beginner question about foldl: in the yaht tutorial it says "before foldl does anything,it has to go to the end of the list". how is this true? doesn't foldl start computing from the head->tail?
15:40:34 <dcoutts> and especially for stream fusion since length and maximum are left folds
15:40:58 <sarehu> hmmm
15:41:03 <dcoutts> gchin: before it returns anything it has to have got to the end of the list
15:41:15 <sarehu> not true
15:41:23 <mauke> gchin: foldl doesn't start computing
15:41:25 <sarehu> > foldl (||) False [True, undefined]
15:41:27 <lambdabot>  True
15:41:39 <sarehu> or wait
15:41:40 <sarehu> never mind
15:41:45 <mauke> > foldl (||) False (True : undefined)
15:41:46 <lambdabot>  Undefined
15:41:55 <dcoutts> mauke beat me to it :-)
15:42:01 <sarehu> I am being a real moron...
15:42:17 <gchin> dcoutts: oh, that makes a lot more sense
15:42:39 <gchin> I was interpreting the wording of "does anything" to mean "any computation"
15:42:43 <gchin> thanks
15:42:54 <dcoutts> gchin: you're welcome
15:47:54 <glen_quagmire> I wrote a lambda fork bomb today: (Æ›x.xxxx)(Æ›x.xxxx)
15:48:16 <dons> looks untyped
15:48:28 <mauke> ooh, lambda with stroke
15:48:45 <ricky_clarkson> The first time I used threads in Scheme I forkbombed someone's IRC bot with them.
15:53:27 <Liskni_si> glen_quagmire: does that grow exponentially? i don't think so (but i may be missing it)
16:02:24 <shivernz> :t many
16:02:26 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
16:02:41 <shivernz> @hoogle many
16:02:41 <lambdabot> Control.Applicative.many :: Alternative f => f a -> f [a]
16:02:41 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
16:02:41 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
16:13:53 <Leimy> hi
16:14:16 <Leimy> I've seen stuff about a GHC port the JVM.  Is that readily available anywhere?
16:14:50 <dons> nope. it was a research project in the early decade
16:14:58 <Leimy> dons: yours right? :-)
16:15:20 <dons> well, there were several
16:16:35 <ricky_clarkson> Isn't there some Java bridge or other?
16:17:45 <conal> ricky_clarkson: antony courtney made one
16:27:50 <ndm> my tests suggest that with GHC 6.8.2 the __GLASGOW_HASKELL_COMPILER__ macro is not set
16:27:56 <ndm> @seen Igloo
16:27:56 <lambdabot> Igloo is in #ghc, #darcs and #haskell. I last heard Igloo speak 7h 30m 35s ago.
16:28:24 <ndm> does anyone know if i have do some some magic, or if this is a bug?
16:29:49 <ndm> apparently the manual says use __GLASGOW_HASKELL__
16:29:55 <ndm> did that change, or did i screw up originally?
16:30:04 <ndm> cause it certainly used to work!
16:33:28 <wellwisher> does anyone know how to convert a ProcessHandle to a ProcessID in windows?
16:37:07 <byorgey> dcoutts: around?
16:37:21 <dcoutts> byorgey: hia
16:37:42 <byorgey> dcoutts: I heard you mention before that cabal-install now incorporates functionality from cabal-setup?
16:37:52 <dcoutts> yes
16:38:12 <byorgey> how do I access that functionality?  I just installed from darcs.
16:38:29 <dcoutts> cabal --help
16:38:32 <dcoutts> lists all the commands
16:38:40 <byorgey> right, I tried that.
16:38:56 <dcoutts> and it includes all the ones that runghc Setup.hs or cabal-setup provide
16:39:15 <dcoutts> byorgey: what problem are you encountering?
16:39:27 <byorgey> hmm, ok... maybe I was confused about what cabal-setup did then
16:39:37 <byorgey> I just want to create a new cabalized project.
16:39:54 <dcoutts> ah, perhaps you were thinking of dons's mkcabal program
16:39:55 <byorgey> but I don't see a command that obviously does that... unless I'm missing something obvious (quite possible =)
16:40:03 <byorgey> dcoutts: oh, indeed =)
16:40:19 <dcoutts> byorgey: I'm trying to encourage dons to integrate mkcabal into cabal-install too
16:40:29 <dcoutts> something like cabal init
16:40:33 <byorgey> dcoutts: yeah, that would be nice
16:40:45 <byorgey> maybe I'll poke dons about it too =)
16:41:14 <dcoutts> byorgey: for reference, cabal-setup was basically a compiled version of Setup.hs
16:41:25 <byorgey> dcoutts: oh, ok, I see.
16:42:25 <dcoutts> the idea in future is that the cabal command will be the primary way of doing stuff, no need for runghc Setup.hs etc
16:43:16 <byorgey> dcoutts: cool
16:44:14 <byorgey> dcoutts: by the way, any small projects that need doing? I'm done with grad school apps now and interested in contributing to the cabal project
16:44:49 <dcoutts> byorgey: yes!
16:45:11 <dcoutts> byorgey: the comprehensive list is the hackage bug tracker
16:45:21 <dcoutts> and there are several on there that should be straightforward
16:45:24 * dcoutts looks
16:45:48 <dcoutts> byorgey: http://hackage.haskell.org/trac/hackage/report/9
16:45:51 <lambdabot> Title: {9} Active Tickets by Component - Hackage - Trac
16:46:15 <dcoutts> byorgey: in particular there are some easier ones filed against hackagedb
16:46:37 <dcoutts> and it's the component that gets least attention at the moment but is in greatest need of improvement
16:46:44 <shivernz> is this a good way to write a parsec function? http://hpaste.org/4582
16:46:47 <byorgey> dcoutts: ok, I'll take a look.
16:47:08 <byorgey> dcoutts: where's the repo for that code?
16:47:25 <dcoutts> byorgey: http://haskell.org/cabal/code.html
16:47:33 <byorgey> ok, cool
16:48:27 <dcoutts> byorgey: one more interesting project rather than just bug fixing is a new dependency resolver for cabal-install
16:48:48 <dcoutts> byorgey: it's not starting from scratch, kosmikus already wrote a prototype
16:48:56 <byorgey> dcoutts: ok, sounds interesting
16:49:07 <dcoutts> that is a nice well compartmentalised problem
16:49:12 <byorgey> dcoutts: what needs improving about the old one?
16:49:15 <dcoutts> and doesn't need any IO
16:49:27 <dcoutts> byorgey: it's very simplistic and doesn't take configuration flags into account
16:49:34 <byorgey> I see.
16:49:39 <dcoutts> it does no backtracking and it's not easily configurable with extra constraints
16:49:55 <byorgey> ok, that one sounds fun, I'll take a look at that too =)
16:50:20 <dcoutts> byorgey: see bugs #131 168 174 175
16:50:37 <dcoutts> byorgey: they're all things that could be fixed with an improved algorithm
16:51:19 <dcoutts> byorgey: in particular #175 has the link to kosmikus's code, which is fairly readable and well commented
16:51:20 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/175
16:51:21 <lambdabot> Title: #175 (cabal-install needs a new package dependency resolution algorithm) - Hacka ...
16:51:29 <byorgey> cool.
16:51:59 <dcoutts> it's written in a self-contained way, it needs mapping onto the types that cabal/cabal-install uses
16:52:45 <dcoutts> in some cases it could just use the cabal types directly, in others what it needs for dep resolution is much simpler than what cabal uses so we could map into those types
16:53:19 <dcoutts> especially the GuardedDeps, it's an abstraction of cabal's CondTree expressions
16:53:39 <dcoutts> we should be able to map CondTree -> GuardedDeps
16:53:47 <dcoutts> map/convert
16:54:17 <byorgey> ok, got it
16:54:31 <dcoutts> byorgey: the main complexity is that now with configurations we have conditional dependencies, eg if flag then build-depends: foo; else build-depends: bar
16:54:48 <dcoutts> so package dep resolution has to decide what flag assignment to use for each package
16:55:29 <byorgey> dcoutts, right.  I read nominolo's TMR article
16:55:47 <byorgey> makes sense.
17:06:00 <wellwisher> does anyone know how to extract a ProcessID from a ProcessHandle in windows?
17:17:39 <roger`> wellwisher: in C, you'd use GetProcessId, are you using System.Win32.Process?
17:23:29 <wellwisher> roger`: System.Win32.Process doesn't contain a way to get the ProcessID
17:24:11 <wellwisher> this is what I am currently doing: http://hpaste.org/4583
17:26:50 <wellwisher> I need to get the CPid to a Word32
17:27:17 <dons> fromIntegral, I think
17:27:26 <dons> ?hoogle CPid
17:27:27 <lambdabot> No matches found
17:27:32 <oerjan> fromIntegral . fromEnum
17:27:49 <dons> ?remember alpheccar I think that without blogs I would not have been able to understand Haskell.
17:27:50 <lambdabot> It is stored.
17:29:28 <shivernz> i second alpheccar's thoughts, though technically i still don't "understand" it
17:30:27 <Cale> IRC seems way more effective than blogs for me :)
17:31:20 <shivernz> true, though i feel like a bit of an idiot asking questions here. all the people here are way above my level.
17:31:42 <ricky_clarkson> I'm not.
17:32:17 <Cale> I think it's pretty safe to say that at some point everyone here was at your level though :)
17:32:20 <wellwisher> CPid is in System.Posix.Types
17:32:31 <Cale> (and most of us actually remember that time pretty well)
17:33:03 <ricky_clarkson> shivernz: From what I've seen, even my most idiotic questions were answered pretty politely and helpfully.
17:33:22 <ricky_clarkson> Let the idiocy flow.  Ahem.
17:33:35 <shivernz> ricky_clarkson, oh definitely. not faulting the helpfulness at all. doesn't stop me from feeling like an idiot though :)
17:34:13 * dcoutts adds new ghc-6.8 libs to gentoo
17:34:15 <ricky_clarkson> I think you should deliberately feel like an idiot.  That is, if you get to the top of a pile, find another that you're at the bottom of.
17:34:51 * shivernz applauds dcoutts 
17:35:09 <dcoutts> ghc-6.8 is in already, p.masked
17:35:14 <shivernz> ricky_clarkson, very true. i like being challenged. keeps me awake
17:35:14 <dcoutts> 6.8.2 that is
17:35:16 <wellwisher> I still always get the number 1904; I think CPid is a pointer
17:35:43 <Brian`> hey, can "data Obs a = Obs (Date -> (a, Obs a))" be a State Monad?
17:35:45 <shivernz> dcoutts, cool. since when was that? haven't done a sync in a few days now.
17:35:51 <dcoutts> shivernz: today
17:35:56 <Brian`> shouldn't this be data Obs a = Obs (Date -> (a, Date)) in order to be a State Monad?
17:36:14 <shivernz> dcoutts, sweet. ill probably do the update sometime this weekend
17:36:24 <Cale> Brian`: yeah, I think so
17:37:53 <monochrom> Obs a = Obs (Date -> (a, Obs a))  is some kind of continuation stream.
17:38:36 <byorgey> combined with a Reader monad...
17:40:39 <Brian`> I was reading http://contracts.scheming.org/#contract-eval and it said data Obs a = Obs (Date -> (a, Obs a)) matches the type signature of State Monad... I guess that is wrong then..?
17:40:39 <lambdabot> Title: Composing Contracts
17:42:08 <byorgey> Brian`: well, it does if a = Date...
17:42:59 <byorgey> Brian`: as it stands, since there is no state of type 'a' provided as input to the function, there is no way for the state to be 'transformed'.
17:43:30 <Cale> a wouldn't be the state type anyway
17:43:35 <Cale> it's the result type if anything
17:43:43 <byorgey> Cale: well, true.
17:44:50 <byorgey> Brian`: where on the page does it say this?
17:46:00 <byorgey> never mind, I found it
17:46:19 <Brian`> byorgey, :)
17:46:21 <vagif> Hello, anyone using fastcgi or cgi ?
17:46:48 <Cale> Well, it's sort of a state monad, since the returned Obs can modify its Date parameter arbitrarily.
17:46:49 <byorgey> Brian`: good old text search... =)
17:47:06 <Brian`> byorgey, yeah that always works hehe
17:47:30 <Cale>  newtype Obs a = Obs (Date -> (a, Date)) -- this is the actual code though
17:47:48 <Brian`> byorgey, since it says " return v = Obs $ \t -> (v, t)" (assuming t represent Date), would it be possible that the author made a mistake..?
17:47:49 <Cale> the latter recursive data is not intended as real code
17:48:10 <Brian`> Cale, oh.. i c
17:48:16 <Brian`> Cale, how did you know if that was a real code or not?
17:48:17 <Cale> The newtype is the thing with the box around it indicating that it's real code.
17:48:29 <byorgey> Brian`: yeah, I was just going to point out the same thing as Cale -- when it says "the above type signature matches that of monad", it's referring to the code Cale just pasted.
17:48:43 <Cale> and yes, that's actually a state monad
17:48:44 <byorgey> not the data Obs a = Obs (Date -> (a, Obs a))
17:48:54 <Brian`> Cale, byorgey, aha that sounds right :)
17:49:01 <Cale> though they do make a mistake later on, it's isomorphic to State Date a, not State a Date.
17:49:17 <byorgey> Cale: interesting observation about the returned Obs a being able to modify its Date parameter though.
17:49:25 <Brian`> Cale, yeah
17:50:19 <wy> Is hugs faster than ghc as an interpreter?
17:50:27 <Cale> wy: no
17:50:35 <Cale> wy: For initially loading code, yes.
17:50:39 <Cale> But otherwise, no.
17:50:55 <wy> So there is no advantage of using Hugs?
17:51:32 <Cale> Not really that I'm aware of.
17:52:28 <psnively> Anyone know anything more about when the Mac OS X Leopard ld bus error issue on PPC might be worked around?
17:52:30 <wy> So I'll keep using ghc in my emacs. Hugs can't even define functions on the top level
17:52:55 <Cale> You mean at the commandline.
17:53:14 <wy> Right. let f x = x+1 doesn't work
17:53:31 <Cale> You're not really expected to define functions at the commandline in GHCi either -- they're blown away by lots of things.
17:53:59 <Cale> Better to just create a file and load it, then reload with :re
17:54:02 <wy> I can at least try some small things there
17:54:13 <Brian`> also, another question I have is, in "data Contract = Until   (Obs Bool)   Contract"
17:54:20 <Brian`> Until is data constructor right?
17:54:24 <roger`> get used to switching between two buffers in emacs, one for ghci and the other your source file, reloading with :r
17:54:31 <Cale> Brian`: yep
17:55:20 <Brian`> Cale, then what are the other two called? (Obs Bool) and Contract?
17:55:32 <Cale> types?
17:55:32 <Brian`> just parameter?
17:55:46 <Cale> Those are the types of the parameters to Until
17:56:09 <Brian`> Cale, got it ;)
17:56:47 <wy> I found I like type classes even better. It seems to have made clear some confusions that were put into my mind by object oriented languages.
17:58:32 <wy> Obs is a unary polymorphic type constructor, and Bool and Contract are nullary type constructors.
17:59:50 <wy> Let me try to state my thinking to verify if the ideas are right...
17:59:57 <cdsmithus> I'm trying to build lambdabot for GHC 6.9.  Anyone had luck with that?
18:00:10 <wy> 6.9 ??
18:00:12 <chadz_> i couldn't even build it with 6.8.1
18:00:17 <cdsmithus> develpment.  Basically 6.8
18:00:38 <wy> I see
18:00:39 <dcoutts> cdsmithus: it needs hs-plugins and that does not work with 6.8 yet
18:00:49 <cdsmithus> Ah, thanks.
18:00:50 <chadz_> it doesn't need hs-plugins, does it?
18:00:59 <thoughtpolice> you need hs-plugins for certain things like eval
18:01:07 <thoughtpolice> and the @check etc.
18:01:09 <chadz_> yeah. that's what i figured.
18:01:18 <thoughtpolice> hs-plugins actually does work on ghc 6.8 as of now (I have it installed)
18:01:33 <chadz_> was there a recent patch within the past week?
18:01:37 <thoughtpolice> there's just no release for 1.1 because people are aiming to make it work on windows before a big new reannouncement
18:01:57 <cdsmithus> Funny, though, the lambdabot I built with 6.6 seems to work with GOA in GHC 6.8's ghci
18:02:04 <thoughtpolice> i think conal is trying to make some headway in that area though.
18:02:55 <thoughtpolice> i got all sorts of weird GOA errors just from upgrading bytestring, iirc.
18:03:06 <wy> There is what I'm thinking. Normal OOP languages are message passing systems. Classes have variables and methods, as if those methods all belong to the objects. But actually they are not. So the essence of type classes is to define those operations that are intrinsic to a type if it is of that class. But other functions can be defined outside of the classes.
18:03:06 <chadz_> @vixen does lambdabot rule?
18:03:07 <lambdabot> nevermind about that
18:03:13 <wwww> I need help to get the CPid to a Word32 in http://hpaste.org/4583   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
18:03:35 <cdsmithus> thoughtpolice: I get errors about Data.ByteString.index.  But if I ignore them, things still work
18:03:53 <thoughtpolice> Cale also got lambdabot to build with 6.8.2 i think.
18:04:09 <Cale> wwww: CPid is an instance of Integral.
18:04:15 <Cale> wwww: So use fromIntegral
18:04:27 <Cale> thoughtpolice: This is true.
18:04:40 <cdsmithus> Cale: Any tips, then?
18:04:45 <thoughtpolice> Cale: are there patches in the repo yet?
18:04:54 <Cale> thoughtpolice: yes
18:04:57 <thoughtpolice> sweet
18:05:00 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
18:05:04 <lambdabot> Title: Index of /~dons/code/hs-plugins
18:05:15 <thoughtpolice> Cale: oh no. i have hs-plugins for 6.8.2 working, i meant lambdabot
18:05:15 <cdsmithus> Cale: Awesome.  Thanks!
18:05:21 <thoughtpolice> wait
18:05:24 <Cale> thoughtpolice: oh, that's easy.
18:05:33 <Brian`> if something is of type Num, does it have to be of type Eq?
18:05:42 <byorgey> Brian`: unfortunately, yes
18:05:49 <byorgey> and Show
18:05:52 <Brian`> byorgey, haha why is it unfortunate?
18:05:53 <thoughtpolice> yes
18:05:54 <oerjan> @src Num
18:05:55 <lambdabot> class  (Eq a, Show a) => Num a  where
18:05:55 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:05:55 <lambdabot>     negate, abs, signum     :: a -> a
18:05:55 <lambdabot>     fromInteger             :: Integer -> a
18:06:03 <byorgey> Brian`: because it's too restrictive.
18:06:23 <Cale> If there aren't patches in the repo, it's pretty trivial to get it to compile. There's only one slightly tricky change to make. Apparently newtype deriving isn't as forgiving as it used to be, so you have to make something more polymorphic.
18:06:24 <byorgey> Brian`: it's easy to come up with things that are Nums but cannot (computably) be compared for equality.
18:06:29 <thoughtpolice> cdsmithus: i got similar errors but I always get the feeling it will bite me in the ass hard when I least expect it. shortly after I upgraded to 6.8 anyway
18:06:41 <Brian`> byorgey, for example.. imaginary number?
18:06:42 <Cale> (I forget what, but it was something like  MonadReader Foo -> MonadReader e
18:06:47 <Cale> )
18:07:00 <byorgey> Brian`: no, imaginary numbers can be compared for equality pretty easily.
18:07:16 <Brian`> byorgey, oops i was thinking about ord lol
18:07:16 <byorgey> Brian`: infinite-precision real numbers come to mind though.
18:07:34 <Cale> Or just functions with a Num codomain.
18:07:35 <Brian`> byorgey, ah.. yes
18:07:39 <Cale> (elementwise)
18:07:45 <byorgey> Cale: yup, that too
18:08:35 <byorgey> Brian`: actually, imaginary numbers can be ordered too... maybe you're thinking of complex numbers =)
18:08:36 <Cale> Or more generally, (Monad m, Num n) => Num (m n)
18:09:07 <thoughtpolice> wy: i think of typeclasses more of 'inversed' oop (depending on your definition.) with objects, you define classes of which the objects have certain properties/functions.
18:09:12 <Cale> mm, applicative will probably do, even.
18:09:16 <nolrai> is there a way to apply a funtion element wise to 2 arrays?
18:09:32 <Cale> nolrai: like zipWith for arrays?
18:09:37 <thoughtpolice> with type classes, you rather define general constraints/functions, and let the data types implement themselves.
18:09:38 <cdsmithus> Where would I look to fixSetup: At least the following dependencies are missing:
18:09:38 <cdsmithus>     Cabal ==1.2.3.0
18:09:44 <byorgey> Cale: interesting, I hadn't thought it out that far =)
18:09:55 <thoughtpolice> cdsmithus: ghc 6.8.2. it increased the cabal version number from 1.2.2 to 1.2.3
18:10:15 <Brian`> byorgey, how can imaginary numbers can be ordered..?
18:10:21 <nolrai> cale: yeah aculy come to think of it, i just want zip for arrays.
18:10:22 <thoughtpolice> cdsmithus: oh nevermind
18:10:32 <thoughtpolice> cdsmithus: just upgrade cabal using the 1.2.3 tarball from haskell.org/cabal
18:10:39 <cdsmithus> thoughtpolice: If I were to speculate that my 6.9 Cabal would work, can I fix the dependency?
18:11:11 <Cale> nolrai: I think the best you can do is simply to unpack to lists, and then repack as an array.
18:11:27 <oerjan> nolrai: it gets complicated if the arrays don't have the same bounds...
18:11:40 <nolrai> they do.
18:11:41 <cdsmithus> Funny, the cabal file just says >= 1.2.  I don't know where it's getting == 1.2.3 from.
18:11:42 <Cale> right, you'd need to do something interesting then :)
18:11:49 <thoughtpolice> cdsmithus: if you need 1.2.3 just upgrade from the tarballs. it should be on hackage too. the HEAD is probably using 1.2.3 as well but i don't trust compilers in that state :p
18:11:52 <oerjan> the Ix class isn't really designed for taking intersection of ranges.
18:12:11 <dcoutts> cdsmithus: what are you building that requires exactly that version of Cabal? usually the version deps are not so precise.
18:12:12 <oerjan> although you can probably do it
18:12:20 <Cale> cdsmithus: huh?
18:12:23 <wwww> I need help to get the CPid to a Word32 in http://hpaste.org/4583   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
18:12:23 <cdsmithus> dcoutts: the new hs-plugins.
18:12:25 <dcoutts> cdsmithus: it's probably in build-depends
18:12:33 <byorgey> Brian`: imaginary numbers are of the form a*i, where a is a real number
18:12:35 <nolrai> its simple for one dimintional ix's but examples like pairs and such are harder.
18:12:46 <Cale> wwww: I answered you already, say it again and I'll have to kick you.
18:12:47 <byorgey> Brian`: so (a*i) <= (b*i) iff a <= b
18:12:57 <cdsmithus> dcoutts: Ah yes, thanks!
18:13:01 <Cale> wwww: also, please stop with the repeated X's.
18:13:16 <cdsmithus> dcoutts: I was confused by the cabal-version earlier in the file
18:13:24 <dcoutts> dons: ping, you don't want to specify Cabal == 1.2.3.0, You might want Cabal >= 1.2.3 && < 1.3
18:13:40 <thoughtpolice> cdsmithus: the darcs repo has patches that tweak it for 6.8.2 building. i would bet that it'll work fine on 6.8.1 though
18:13:43 <Cale> The == 1.2.3.0 was intentional
18:13:50 <thoughtpolice> then again i'm not sure.
18:14:01 <Cale> We don't actually know that it works with any other Cabal, and it certainly doesn't work with 1.3
18:14:01 <dcoutts> dons: as it is it'll fail if I release a minor patch version that doesn't change the api at all. The first three version components are the api.
18:14:02 <Brian`> byorgey, is it the case? hm.. so you mean sqrt(-4) < sqrt(-16) ?
18:14:20 <byorgey> Brian`: sure, I mean, that's a possible ordering
18:14:25 <wy> thoughtpolice:  I guess that's what OOP really means, but misinterpreted by some languages where everything is an object
18:14:31 <cdsmithus> Crap.  Not in scope: data constructor `InstalledPackageInfo'
18:14:38 <cdsmithus> Maybe it's easy to fix, though
18:14:39 <dcoutts> dons: and increases in the third digit are api compatible changes (non-breaking extensions)
18:14:53 <wwww> Cale: your answer didn't work
18:14:55 <Cale> dcoutts: It's just in the darcs repo like that, there hasn't been a release.
18:15:08 <thoughtpolice> Cale: the patches were applied after 6.8.2's release then i assume?
18:15:09 <dcoutts> Cale: I know, I want it fixed before the release :-)
18:15:14 <Cale> wwww: fromIntegral will convert between CPid and and numeric type.
18:15:37 <Cale> dcoutts: Probably by the release there will also be support for Cabal 1.3 :)
18:15:38 <Brian`> byorgey, oh.. so we're just defining the ordering like that way, right? It's not that we can actually compare the two imaginary numbers since they don't exist..
18:15:44 <wwww> Cale: yes it does, but it is not the right value
18:15:51 <Cale> wwww: How so?
18:15:54 <thoughtpolice> wy: well i don't know. the true meaning may simply have been confused over time though
18:16:05 <Brian`> byorgey, I don't know if "don't exist" is appropriate but you know what i mean lol ?
18:16:06 <Cale> any* numeric type
18:16:07 <wwww> Cale: the value returned always 1904!!!!!
18:16:11 <thoughtpolice> i believe alan kay said something along the lines of "when I invented object-oriented programming, c++ was not what I had in mind."
18:16:19 <thoughtpolice> so that is probably indicative of something. :)
18:16:27 <wy> The only thing I found missing from type classes is that the class functions can't overload different types. But after some thinking I found that's not needed!
18:16:35 <Cale> wwww: Maybe the input is always something which reduces to 1904 modulo 2^32?
18:17:30 <wy> @src Integer
18:17:31 <lambdabot> data Integer = S# Int#
18:17:31 <lambdabot>              | J# Int# ByteArray#
18:17:37 <cdsmithus> So Cabal no longer imports constructors for InstalledPackageInfo?
18:17:42 <wy> @src Int
18:17:43 <lambdabot> data Int = I# Int#
18:17:43 <EvilTerran> zomg \(o.O)/
18:17:43 <cdsmithus> *exports
18:17:49 <Cale> Prelude System.Posix.Types Data.Word> fromIntegral (37281 :: CPid) :: Word32
18:17:49 <Cale> 37281
18:17:52 <Cale> see?
18:17:56 <Cale> It works just fine.
18:18:29 <wy> I wonder when and from whom fromIntegral is called?
18:18:31 <Cale> wy: Overload different types?
18:18:35 <moconnor> What does the # mean in the data constructors for Integer?
18:18:41 <Cale> wy: what?
18:18:55 <EvilTerran> it means "magic"
18:19:01 <wwww> Cale: well yes that does work, but it doesn't answer my question
18:19:02 <EvilTerran> @hoogle #
18:19:03 <lambdabot> Prelude.(>) :: Ord a => a -> a -> Bool
18:19:03 <lambdabot> Data.Ord.(>) :: Ord a => a -> a -> Bool
18:19:03 <lambdabot> Prelude.(>=) :: Ord a => a -> a -> Bool
18:19:04 <wy> Cale:  I mean add(Double, Integer), add(Integer, Integer), ...
18:19:06 <EvilTerran> er.
18:19:10 <Cale> moconnor: It's just a convention when working with unboxed things.
18:19:17 <moconnor> oh, ok
18:19:18 <oerjan> wwww: were you doing this on a Windows machine, btw?
18:19:29 <wwww> yes
18:19:43 <oerjan> i don't think the Posix libraries are completely supported there
18:20:14 <Cale> wy: You can do that with multiparameter type classes.
18:20:30 <Cale> wy: Or were you asking how to use fromIntegral with those?
18:20:45 <wy> That's two different questions
18:20:49 <Cale> wwww: Windows doesn't support Posix.
18:21:15 <Cale> wwww: You can use the Win32 library to get access to processes.
18:21:22 <wwww> I am using cygwin though, so it shouldn't matter
18:21:30 <wy> Cale:  I didn't know type classes can have parameters yet
18:21:38 <oerjan> moconnor: # is used for the names of internal ghc things (it's not a legal H98 character)
18:21:51 <Cale> wy: Well, in Haskell 98, they have one parameter
18:22:06 <Cale> wy: In GHC for quite some time, they've been allowed to have more than one.
18:22:12 <Cale> For example,
18:22:18 <Cale> class Foo a b where
18:22:26 <Cale>    foo :: a -> b -> a
18:22:44 <cdsmithus> Anyone know how to fix InstalledPackageInfo { importDirs = idirs } to work with Cabal that apparently no longer exports the data constructor for InstalledPackageInfo?
18:22:45 <Cale> instance Foo String Int where
18:22:53 <Cale>    foo xs n = take n xs
18:23:03 <Cale> Or whatever.
18:23:14 <Cale> (that's a pretty crappy example, but you get the idea)
18:23:43 <wy> Cale:  What kind of relationship is this capturing?
18:24:05 <Cale> wy: an arbitrary multiparameter relation on types
18:24:14 <oerjan> @src MonadReader
18:24:15 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:24:39 <wy> Cale:  But when can we need this?
18:24:41 <Cale> where if the relation is satisfied, you have some functionality which is present
18:25:01 <Cale> A good example of use is in Data.Array.IArray
18:25:05 <oerjan> @src MonadError
18:25:06 <lambdabot> class (Monad m) => MonadError e m | m -> e where
18:25:06 <lambdabot>     throwError :: e -> m a
18:25:06 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
18:25:11 <Cale> class IArray a e where
18:25:11 <Cale> bounds :: Ix i => a i e -> (i, i)
18:25:38 <Cale> Essentially, IArray a e means that a is an array type with element type e
18:26:04 <Cale> Then you have instances like:
18:26:08 <Cale> IArray Array e
18:26:10 <Cale> (for any e)
18:26:17 <Cale> IArray UArray Bool
18:26:39 <Cale> (which is for an unboxed array of Bools, which does bit packing)
18:28:08 <wy> What does the parameter of type e in bounds :: Ix i => a i e -> (i, i) mean?
18:28:22 <Cale> That's the type of element which the array carries.
18:28:26 <dons> ?uptime
18:28:27 <lambdabot> uptime: 2d 20h 42m 1s, longest uptime: 1m 10d 23h 44m 29s
18:28:31 <Cale> The i is the index type
18:28:36 <Cale> and a is the type of array
18:28:44 <Cale> (Array, UArray, etc)
18:28:45 <wy> How do you usually call bounds?
18:29:13 <Cale> actually, there are a bunch more functions in that class, but bounds is the only exported one
18:29:35 <Cale> You pass bounds an array, and it tells you the bounds of the array.
18:29:50 <mrd> ?lusers
18:29:51 <lambdabot> Maximum users seen in #haskell: 434, currently: 388 (89.4%), active: 18 (4.6%)
18:30:16 <wy> But why does it take three arguments?
18:30:26 <mrd> it takes 1
18:30:39 <Cale> Prelude Data.Array> bounds (array (0,10) [(n,n^2) | n <- [0..10]])
18:30:39 <Cale> (0,10)
18:30:41 <mrd> the first being of type "a i e"
18:30:42 <wy> oh. right
18:31:07 <Cale> So in that case, it was something like Array Integer Integer
18:31:12 <mrd> "a i e" also being the sound most people make went confronted with the array interface for the first time
18:31:25 <mrd> when*
18:31:52 <oerjan> @remember mrd "a i e" also being the sound most people make when confronted with the array interface for the first time
18:31:53 <lambdabot> Done.
18:32:05 <Cale> I actually really like the array interface. It's not perfect, but it's a lot better than what most other languages' libraries have.
18:32:25 <mrd> yea it's fine, just the amount of options can be bewildering
18:32:42 <Cale> Most languages can't even index arrays with anything but integers.
18:32:57 <dons> http://randomwalter.livejournal.com/34339.html
18:32:59 <dons> hahah
18:33:24 <dons> I have rejected a lot of them: Python, Ruby, LISP, Java, D, Haskell (trendy in nerd circles )
18:33:34 <dons> "  * Haskell, ML, and the other trendy (in nerd circles, at least) functional programming languages:
18:33:37 <dons>     maybe one day, but not now. Erlang is a possible exception; I like how multi-threading and fault
18:33:40 <dons>     recovery are built-in."
18:34:15 <dons> i'm not sure what's left from that list. C++?
18:34:30 <Cale> He apparently already knows C++, so that's out.
18:34:35 <mrd> clearly he wants to be programming in Intercal
18:34:41 <Cale> He should learn Icon.
18:34:45 <mrd> sorry, INTERCAL
18:35:31 <Cale> http://www.cs.arizona.edu/icon/
18:35:32 <lambdabot> Title: The Icon Programming Language
18:38:02 <Cale> It's an imperative language with backtracking built in.
18:38:38 <ricky_clarkson> dons: Such a positive blogger.
18:38:58 <wy> hehe. He likes perl
18:39:08 <ricky_clarkson> dons: "nerd circles" is a link to proggit.
18:39:08 <dons> ah perl.
18:39:12 <dons> ricky_clarkson: :D
18:39:19 * dons high fives ricky_clarkson 
18:39:44 * ricky_clarkson adjusts his spectacles.
18:40:04 <wy> I looked at Ruby yesterday and I didn't like it
18:40:24 <dcoutts> cdsmithus: JaffaCake renamed it to InstalledPackageInfo_
18:40:34 <dcoutts> with type InstalledPackageInfo = InstalledPackageInfo_ String
18:41:04 <dcoutts> cdsmithus: because it's now parametrised by the string type
18:41:54 <wy> IArray a e. Why is e in the class definition and not the type definition?
18:42:41 <dcoutts> dons: btw, why isn't hs-plugins at code.haskell.org/plugins ? is the main repo really the one in your code.haskell.org/~dons/code/hs-plugins ?
18:43:06 <dcoutts> dons: and I told you about the Cabal == 1.2.3.0 dep already
18:43:32 * dcoutts stops bugging dons about hs-plugins and goes pack to getting ghc-6.8.2 unmasked in gentoo
18:44:09 <Cale> Basically all that dons has been doing with hs-plugins is applying patches anyway.
18:44:44 <monochrom> Some array types are only good for selected few element types, e.g., UArray. If you just say "class IArray a where" you can't express such a constraint. If you say "class IArray a e where" then you can say "instance UArray Int where" meaning UArray is good for Int. UArray may be unavailable for unsaid element types.
18:44:47 <wy> Cale:  I see... multiparameters are useful
18:45:09 <dons> dcoutts: i couldn't be bothered making an account? :)
18:45:22 <Cale> wy: another good example if you know some linear algebra would be vector spaces over their respective fields
18:45:55 <wy> I just had a class on numerical analysis
18:46:01 <dcoutts> dons: if I make you a project now you can move it? want a new project space?
18:46:06 <monochrom> class VectorSpace v f where  scalar_product : v -> f -> v
18:46:37 <dons> dcoutts: eventually, no need now though
18:46:51 <Cale> Though usually you want a functional dependency there.
18:47:06 <monochrom> Again, if you just say "class VectorSpace v where" you don't know how to declare scalar_product.
18:47:13 <dcoutts> dons: well I can make it now anyway if you will want it in future
18:47:46 <byorgey> Brian`: imaginary numbers exist just as much as, say, real numbers =)
18:48:14 <monochrom> Real numbers are imagined, too.
18:48:47 <mrd> all numbers are imaginary
18:48:57 <ricky_clarkson> 3 isn't.
18:49:02 <mrd> imagined*
18:49:12 <mrd> you just did it!
18:49:26 <ricky_clarkson> D'oh!
18:49:32 <dcoutts> I'm sure there really is a real platonic 3 out there somewhere
18:50:01 <wy> v -> f -> v, or v f -> ... -> v f ?
18:50:19 <ricky_clarkson> dons: "I probably need not mention around here that I won't touch PHP code without a ten-foot pole. I'm not saying I never use it, that's what I keep the pole in the office for."
18:50:25 <ricky_clarkson> From that article earlier.
18:50:52 <dcoutts> ricky_clarkson: that's a nice quote :-)
18:50:56 <ricky_clarkson> That's the only bit worth reading.  I hope you didn't post this to proggit.
18:50:58 <dons> ricky_clarkson: so at least he's reasonable
18:51:13 <dcoutts> I'm sure using a 10 foot pole doesn't make programming PHP easier
18:51:32 <dcoutts> I'm sure you'd end up just mashing the keys
18:51:46 <mrd> prevents contamination though
18:52:19 <mrd> anyway, whatever you mash, it's going to run ... something
18:52:39 <dons> ?quote secur
18:52:39 <lambdabot> No quotes match. I feel much better now.
18:52:43 <dons> ?quote types
18:52:44 <lambdabot> types says: A good type system is like a set of tests, except they're actuallly proofs
18:52:47 <dons> hmm
18:53:07 <dons> ?quote checking
18:53:08 <lambdabot> praetorian42 says: I have yet to come across a scenario where compile-time type checking is a worthwhile substitute for reasonably thought-out dynamic code
18:53:10 <dons> ah yes :)
18:53:16 <dons> go php!
18:53:33 <EvilTerran> if he's got a ten-foot Pole, he should get in touch with the guiness book of records. the tallest recorded man *internationally* was only 8'11", let alone in Poland alone ;)
18:53:35 <ricky_clarkson> Type checking cannot yet replace thought?  Wow.
18:53:44 <wy> I still haven't verified why e is in IArray a e. It seems that there is no special operations depend on e
18:53:58 <dcoutts> I tried programming php in a functional style once, lazyness and closures. Turned out not so nice.
18:54:01 <dons> dcoutts: btw, looks like we're going to be open sourcing a whole bunch of web dev libs in the new year :)
18:54:10 <dcoutts> dons: excellent
18:54:32 <dons> just crossing t's and dotting i's now, in preparation.
18:54:48 <Cin> dons: in haskell?
18:54:50 <dons> so quite exciting. all together its pretty much a complete suite for basic web dev.
18:54:51 <wy> One of my friends tried to program postscript in a functional style ;-)
18:54:53 <dons> yeah.
18:54:56 <Cin> oooo
18:55:55 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hiccup-0.3 interesting
18:55:55 <BMeph> rick_clarkson,dons: "Besides, I like C++ just fine." That made me put down my drink, I laughed so much.
18:55:56 <lambdabot> http://tinyurl.com/3dc2ql
18:55:58 <oerjan> wy: array, listArray, accumArray all depend on e for a start
18:56:01 <dons> "A simplistic interpreter for a subset of tcl"
18:56:21 <wy> And made those map, fold, ... all in postscript
18:57:19 <dcoutts> dons: how do you see these libs fitting in? as replacements for some existing de-facto standard libs or complements or candiates for merging into new versions of standard libs?
18:57:57 <dcoutts> better api, more features or better impl?
18:58:04 <wy> oerjan:  I haven't type dependent operations on listArray. e is just boxed in an array
18:58:09 <dcoutts> or all of the above? :-)
18:58:19 <wy> sorry in a list
18:58:33 <monochrom> wy: Suppose you had "class IArray a where (!!) :: (Ix i) => a -> i -> e" instead. That is (!!) :: forall e i . (Ix i) => a -> i -> e.  Note the forall e.
18:58:34 <dons> complements for some (e.g. light weight xml, sqlite3, mime), extensions of others (e.g. rss), and entirely new stuff (e.g. json, json-rpc, xml-rpc, ...)
18:58:44 <oerjan> wy: there are unboxed arrays with IArray instances
18:58:52 <dons> so stuff bringert won't need to write :)
18:58:59 <dcoutts> :-)
18:59:01 <monochrom> forall e means that an array type must support any type as elements.
18:59:06 <dons> the xml one is nice. its not 500 modules big
18:59:07 <wy> Probably because of accumArray
18:59:18 <dcoutts> dons: heh heh, yeah
18:59:23 <dons> there's some others, like the curl binding
18:59:28 <monochrom> So now if you want to have UArray which only supports (say) Int, Bool, Char, and nothing else, you're stuck.
18:59:57 <dons> dcoutts: its quite fun, we have the ability to churn out infrastructure libs. quite satisfying.
19:00:12 <dons> and reassuring: for years to come there will be people paid to produce haskell libs
19:00:12 <OceanSpray> > (fib 1234567)
19:00:13 <OceanSpray> Stack space overflow: current size 8388608 bytes.
19:00:13 <OceanSpray> Use `+RTS -Ksize' to increase it.
19:00:14 <lambdabot>   Not in scope: `fib'
19:00:22 <OceanSpray> is that a Haskell error message?
19:00:24 <dcoutts> dons: yes
19:00:31 <dons> OceanSpray: stack overflow :)
19:00:36 <OceanSpray> well, damn
19:00:41 <dons> running in ghci?
19:00:47 <OceanSpray> no, binary
19:00:52 <dons> you could try compiling it, but if its a bad algo, then its a bad algo
19:01:10 <wy> monochrom:  That's the answer I was looking for. So the purpose to restrict the types that can be in that array
19:01:12 <OceanSpray> it's the naive algorithm
19:01:15 <OceanSpray> but then again,
19:01:27 <OceanSpray> my interpreter doesn't support tail-calls anyway
19:01:30 <OceanSpray> so it doesn't matter.
19:01:32 <dons> hmm, the naive one shouldn't overflow.
19:01:33 <dons> ah.
19:01:39 <dons> oh, is that your language
19:01:44 <dons> not haskell? but running on haskell?
19:01:52 <OceanSpray> the interpreter is written in haskell
19:02:02 <dons> ok. so your interpreter ran out of stack.
19:02:15 <dons> probably because of how you do recursion :)
19:02:19 <dons> as you say
19:02:44 <Cin> hi ocean :P
19:02:46 <OceanSpray> sup
19:02:52 <OceanSpray> it's a compiled binary
19:03:02 <OceanSpray> how do I increase the stack size on that?
19:03:05 <Cin> ocean: decided to learn haskell after reading your code, heh
19:03:11 <OceanSpray> lol
19:03:54 <oerjan> OceanSpray: +RTS -Ksize when running the program
19:04:05 <OceanSpray> wha?
19:04:15 <OceanSpray> you mean, even the compiled binary takes those arguments?
19:04:16 <oerjan> +RTS is for runtime system
19:04:33 <oerjan> especially the compiled binary
19:04:41 <OceanSpray> oh
19:04:53 <Cin> haskell has tail-cail recursion, right?
19:05:04 <EvilTerran> in a manner of speaking
19:05:10 <EvilTerran> laziness makes it a bit funny
19:05:17 <wy> monochrom:  But I still think that's not the purpose of the class to be multiparametric. GADT can do that for you to restrict the types that could be in the array.
19:05:23 <monochrom> Many recursive calls cost no stack space.
19:05:35 <EvilTerran> wy, GADTs are much newer than MPTCs
19:05:38 <Cin> :s
19:06:19 <wy> EvilTerran:  I'm just trying to find some orthogonal features that can't replace each other
19:06:46 <monochrom> I am not sure how to use GADT to write a uniform (and open-ended) interface over many array implementations.
19:06:50 <OceanSpray> It's impossible to have tail-call optimization in my language, since it's pass-by-expression and procedures acquire the caller's environment as a variable with each call.
19:07:12 <Cale> Cin: the usual problem with tail calls is that since evaluation is outermost-first, if you put some computation into the parameter, it won't be evaluated immediately. In this way you can build up huge expressions which will overflow the stack when they finally get evaluated.
19:07:16 <OceanSpray> Unless, of course, there's something I haven't figured out yet.
19:07:20 <wy> Surely unary type classes are indispensible for this.
19:07:35 <Cale> Cin: combined with strictness annotations though, tail calls are fine.
19:08:25 <Cale> > foldl (+) 0 [1..10000000]
19:08:27 <wy> But the purpose of type classes is for overloading. If the operation doesn't depend on the type, the type needn't be in the argument to the class
19:08:36 <lambdabot> Terminated
19:08:38 <Cale> > foldl (+) 0 [1..1000000]
19:08:39 <monochrom> Is there a tail recursion article on the wiki?
19:08:41 <lambdabot>  Exception: stack overflow
19:08:46 <Cale> > foldl' (+) 0 [1..1000000]
19:08:47 <lambdabot>  500000500000
19:08:59 <OceanSpray> well, damn
19:09:03 <dons> > foldl (+) 0 [1..1000000] :: Int
19:09:05 <lambdabot>  1784293664
19:09:08 <dons> > foldl (+) 0 [1..1000000] :: Integer
19:09:09 <wy> So I guess type classes only need one parameter, and let GADT to do the typing constraints
19:09:09 <lambdabot>  Exception: stack overflow
19:09:16 <dons> I# is just strict enough
19:09:17 <Cale> The difference is that while they're both tight loops, the first tight loop just builds a giant expression.
19:09:45 <Cin> cale: ah, true
19:10:11 <dons> so anyone have some thoughts on why Int terminates, but Integer is too lazy?
19:10:20 <dons> I# i doesn't look at lot stricter than,
19:10:22 <dons> data Integer = S# Int#                -- small integers | J# Int# ByteArray#
19:10:48 <monochrom> How optimizing is lambdabot?
19:10:51 <wy> What'd the command to load a module in ghci? I tried :load, but it doesn't work. :module will put me into the environment of that module
19:10:52 <dcoutts> dons: lambdabot compiles without -O right?
19:10:56 <dons> -O2 optimising , iirc
19:11:01 <dcoutts> hmm
19:11:08 <dons> -O -fasm
19:11:15 <dons> -fextended-default-rules
19:11:32 <monochrom> Probably recognizes I# and does special things not done to other types.
19:11:50 <dons> that's what I'm thinking.
19:11:50 <dcoutts> dons: or strictness anlysis
19:11:56 <dons> or the bounds checks in Integer confuse things
19:12:33 <monochrom> Yeah, if code concerning Integer is too complicated, strictness analyzer may give up.
19:12:41 <dons> Integer yields a lazy loop,
19:12:43 <sclv> is J# Int# ByteArray# fully unboxed?
19:12:46 <dons> Main.lgo =
19:12:46 <dons>   \ (z1_anM :: GHC.Num.Integer) (ds_anN :: [GHC.Num.Integer]) ->
19:12:46 <dons>     case ds_anN of wild_anO {
19:12:46 <dons>       [] -> z1_anM;
19:12:46 <dons>       : x_anS xs1_anT -> Main.lgo (GHC.Num.plusInteger z1_anM x_anS) xs1_anT
19:12:49 <sclv> or is ByteArray# a pointer?
19:12:56 <dons> a ptr.
19:13:06 <sclv> maybe that's why the difference?
19:13:14 <dons> Int is fully strictified,
19:13:16 <dons> Main.$wlgo =
19:13:16 <dons>   \ (ww_swP :: GHC.Prim.Int#) (w_swR :: [GHC.Base.Int]) ->
19:13:16 <dons>     case w_swR of wild_anP {
19:13:16 <dons>       [] -> ww_swP;
19:13:18 <dons>       : x_anT xs1_anU ->
19:13:21 <dons>         case x_anT of wild1_au1 { GHC.Base.I# y_au3 ->
19:13:23 <dons>         Main.$wlgo (GHC.Prim.+# ww_swP y_au3) xs1_anU
19:13:27 <EvilTerran> good heavens
19:13:38 <dons> a little bit of core doesn't hurt :)
19:13:45 <dons> its good for you in small doses.
19:14:16 <monochrom> Like zinc.
19:14:21 <dons> there are other special cases for Int in the list library
19:14:44 <sclv> what does the wild mean in the generated core names, by the way?
19:15:04 <dons> oh ..
19:15:05 <dons>     enumFrom (I# x) = eftInt x maxInt#
19:15:05 <dons>         where I# maxInt# = maxInt
19:15:06 <dons>     -- Blarg: technically I guess enumFrom isn't strict!
19:15:24 <dons> enumFromTo (I# x) (I# y) = eftInt x y
19:15:40 <dons> eeftInt :: Int# -> Int# -> [Int]
19:15:46 <dons> i think that's what's going on.
19:16:34 <dcoutts> dons: and there's no similar specialisation for Integer?
19:16:56 <dons> there's no specialisation for Integer. but also, I still get a strict loop avoiding the enumFromTo
19:17:20 <dons> so that's not it (or not the only src of strictness)
19:18:16 <dons> there's lots of little strict hints for Int,
19:18:17 <dons> quotRemInt a@(I# _) b@(I# _) = (a `quotInt` b, a `remInt` b) -- OK, so I made it a little stricter.  Shoot me.  (WDP 94/10)
19:18:39 <dons> (I# x) `plusInt`  (I# y) = I# (x +# y)
19:18:48 <dons> so plus also. along with enumFromTo
19:19:34 <monochrom> What does (+) for Integer say?
19:19:34 <dons> yep, those two together.
19:19:44 <dons> if i use, const (const 1) as the foldl, its lazy again,
19:19:45 <dons> Main.lgo =
19:19:45 <dons>   \ (z1_as3 :: GHC.Base.Int) (ds_as4 :: [GHC.Num.Integer]) ->
19:19:45 <dons>     case ds_as4 of wild_as5 {
19:19:45 <dons>       [] -> z1_as3; : x1_as9 xs1_asa -> Main.lgo x_rBs xs1_asa
19:20:01 <dons> but i can't use [1..n] :: Int, nor (+), since they're strict.
19:21:17 <twanvl> > foldl (+) 0 [1..1000000] :: Int64 -- the result doesn't actually fit in an Int
19:21:17 <lambdabot>  500000500000
19:21:23 <monochrom> Is x_rBs defined by another line of core as a thunk?
19:21:49 <dons> plusInteger is huge
19:22:15 <wy> class IArray a e where
19:22:15 <wy> bounds :: Ix i => a i e -> (i, i)
19:22:17 <monochrom> If it is huge, no strictness analyser or human will easily see through it as strict or non-strict. :)
19:22:35 <dons> x_rBs = GHC.Base.I# 1
19:22:47 <wy> Here bounds doesn't need the type of e in order to operate, so I think e doesn't need to be in the parameters
19:23:04 <monochrom> bounds is not the only IArray method.
19:23:16 <EvilTerran> ?src IArray
19:23:17 <lambdabot> Source not found.
19:23:31 <monochrom> In fact IArray methods are not really exported. The IArray class is highly abstract.
19:23:39 <twanvl> > let plus a b = a `seq` b `seq` a + b in foldl plus 0 [1..1000000] :: Integer
19:23:40 <lambdabot>  500000500000
19:23:56 <dons> very good :)
19:24:12 <dons> i wonder: maybe we should do an audit for Int-laziness (or Integer-strictness?)
19:24:13 <oerjan> wy: the large majority of the IArray methods start with "unsafe" :)
19:24:26 <dons> and just decide: Integers and Ints are atomically strict.
19:24:37 <dons> since there's some ad hoc stuff happening now
19:24:40 <monochrom> Many hidden methods of IArray depend fundamentally on e.
19:24:42 <dons> and h98 doesn't specify
19:25:02 <twanvl> they *are* already strict, but the compiler doesn't know
19:25:12 <dons> yeah, we want to state that.
19:25:34 <dons> > foldl (+) 0 [1..1000000] -- is really bad :(
19:25:35 <lambdabot>  Exception: stack overflow
19:26:10 <dons> i bet there are Integer-strict-explicit functions already.
19:26:11 <dons> let me see...
19:26:17 <twanvl> this sounds like a two character patch to Base
19:26:25 <dons>   "maximumInt"     maximum = (strictMaximum :: [Int]     -> Int);
19:26:26 <dons>   "maximumInteger" maximum = (strictMaximum :: [Integer] -> Integer)
19:26:27 <dons> haha
19:26:47 <dons> so who decides? why aren't we methodical about this? where's the policy: Integer, Int, Char, Word* are strict ?
19:28:17 <twanvl> (+) and (-) for these types must be strict, how can the compiler/program ever know "a + b" without evaluating both a and b?
19:28:19 <wy> oerjan:  Where can I find the definition of class IArray?
19:29:16 <dons> twanvl: so what about (*) and all the other Num things?
19:29:37 <twanvl> "0 * x" could be lazy in the second argument, but that is the only thing I can think of
19:29:59 <wy> unsafeAccum      :: Ix i => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e
19:30:30 <oerjan> @docs Data.Array.IArray
19:30:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
19:30:49 <oerjan> bah
19:31:20 <oerjan> actually http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html
19:31:21 <lambdabot> http://tinyurl.com/333ztl
19:31:31 <wy> I guess that's why e is need. We need to know e in order to do the accumulation
19:31:43 <oerjan> click on the source link
19:32:33 <oerjan> gets you to http://www.haskell.org/ghc/docs/latest/html/libraries/array/src/Data-Array-Base.html#IArray
19:32:34 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2ktkbr
19:34:27 <wy> oerjan:  Got it. Thanks
19:40:30 <wy> Still not justified. The first parameter (e -> e' -> e) is a function passed in
19:40:55 <oerjan> wy: take a look at the UArray Bool instance
19:44:24 <oerjan> if you don't see how that one depends specifically on Bool, i don't know how to demonstrate :D
19:44:49 <wy> ... too hard for me at this time
19:45:27 <oerjan> well, the answer is that it packs the bits.
19:45:33 <monochrom> I think wy is looking for two points, one he has found and the other he hasn't.
19:46:14 <monochrom> One point is UArray doesn't want to support all element types. That one he is convinced.
19:46:38 <wy> yes
19:46:43 <monochrom> The other point is IArray methods actually use the type e, and he hasn't found one.
19:46:52 <oerjan> :t Data.Array.IArray.accumArray
19:46:54 <lambdabot> forall e e' i (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
19:47:29 <monochrom> Well, if you want to know what I think, I wouldn't need to see such a method.  The very presence of (!!), method or not, implies that a method depending on e must exist.
19:47:51 <wy> ahh...
19:47:58 <monochrom> Proof. (!!) depends on e. If all methods of IArray are independent of e, (!!) would be unimplementable. Contradiction.
19:49:12 <wy> (!) ?
19:49:30 <monochrom> Yes (!), sorry.
19:49:52 <wy> unsafeAt (UArray _ _ _ arr#) (I# i#) =
19:49:52 <wy>         (indexWordArray# arr# (bOOL_INDEX i#) `and#` bOOL_BIT i#)
19:49:52 <wy>         `neWord#` int2Word# 0#
19:50:09 <wy> So I neglected the implementation. I see now.
19:50:44 <desp> ! (?)
19:50:46 <wy> It seems that lists doesn't depend on implementation.
19:50:50 <monochrom> UArray Bool actually uses a bit vector. It is implemented different from UArray OtherThings.
19:51:13 <monochrom> list is just generic linked list nodes.
19:51:20 <wy> Are other things the same?
19:52:00 <wy> Thanks a lot :-)
19:52:34 <monochrom> Actually the other things are slightly different from each other, but you could see they're more or less copy-paste-rename of each other. Whereas bit vector is significantly different.
19:55:05 <wy> indexWideCharArray#, indexWordArray#, indexAddrArray#, ... they are all different
19:56:10 <wy> Does that mean they are "unboxed" ?
19:56:27 <wy> I haven't really understood what "unboxed" means
19:56:50 <nolrai> @hoogle second
19:56:51 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
19:56:51 <lambdabot> Data.Time.Clock.secondsToDiffTime :: Integer -> DiffTime
19:56:51 <lambdabot> Distribution.Configuration.parseCondition :: ReadP r (Condition ConfVar)
19:58:26 <thoughtpolice> wy: i don't quite understand the semantics but an 'unboxed' integer for example, is an integer that is faster purely because you don't have to go through the box to get it; it's the direct value rather than a computation/etc..
19:58:57 <TSC> It's thunkless, isn't it?
19:59:28 <twanvl> From a programmer point of view, unboxed means that all operations are strict
19:59:43 <wy> I understand. So the indexing of it will depend on its type
20:00:11 <thoughtpolice> twanvl: ah, which is why by adding bang patterns/etc and looking at core you can see ghc replace values with unboxed ones, etc.
20:00:21 <thoughtpolice> well, types
20:00:30 <twanvl> yes
20:01:26 <wy> Nice!
20:02:03 <dons> twanvl: so did we decide that it was beneficial to make Integer stricter in some ops?
20:02:19 <wy> The lesson learned today is that an operation of a type in some class can depend on both its own type and the type which implements this type
20:03:14 <twanvl> dons: AFAIK Integer is already strict everywhere, the compiler just doesn't know that. So yes, add the bangs
20:04:36 <wy> Why not use this: class IArray (a e) where ... So I still need only one parameter
20:04:36 <dons> oh hmm. seems to work on with ghc 6.8.2 actually. hmm
20:04:52 <Jomyoot> Why everyone praises the syntax of Haskell? How does it compared to Ruby?
20:05:13 <wy> syntax is irrelavent
20:05:13 <dons> its a lot more concise, Jomyoot
20:05:34 <Jomyoot> syntax makes it easier to read through lines and lines of code
20:05:34 <dons> twanvl: 6.8.2 seems to do the right job. 6.6.1 fails
20:05:38 <wy> Actually I still don't like the layout based syntax
20:05:45 <chessguy> wy, then go write in assembler, it''s more efficient
20:05:53 <dons> Jomyoot: sure does.
20:06:14 <Jomyoot> i am tempted by ocaml until i saw the syntax
20:06:20 <Jomyoot> i like ruby now because of the syntax
20:06:23 <wy> I mean, Haskell could use a syntax like lisp, but it's still Haskell and lisp.
20:06:30 <wy> and not lisp
20:06:30 <dons> don't those 'end' blocks get annoying, Jomyoot ?
20:06:33 <thoughtpolice> wy: see liskell :)
20:06:54 <wy> thoughtpolice:  I found that :-) but haven't tried that
20:07:14 <wy> I think ((()))(()))) still have some shortcomings ;-)
20:07:21 <Jomyoot> whoever came up with liskell is crazy
20:07:36 <dons> therp did. you can talk to him.
20:07:52 <wy> But I really miss the semicolons
20:07:56 <chessguy> @GO LISKELL
20:07:57 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
20:08:01 <chessguy> bah
20:08:03 <chessguy> @go liskell
20:08:05 <lambdabot> http://clemens.endorphin.org/liskell
20:08:05 <lambdabot> Title: Liskell - clemens.endorphin.org
20:08:16 <thoughtpolice> Jomyoot: i prefer the syntax because it is succinct, very very expressive. just like any language it becomes considerably easier to scan through after time
20:08:28 <ricky_clarkson> wy: You had two unmatched right-parens above.  You're fired.
20:08:28 <wy> If we force the semicolons, one press of the tab key would have indented my code to the right place!
20:08:32 <Jomyoot> is Liskell complete?
20:08:57 <thoughtpolice> for certain values of 'complete' i would guess so...
20:08:58 <jcreigh> Jomyoot: Liskell is AFAIK just a proof-of-concept, and is not really used seriously or widely.
20:09:21 <wy> I don't like that layout. When I press tab, I just see my line jumping around ;-)
20:09:22 <chessguy> @seen therp
20:09:22 <lambdabot> I saw therp leaving #haskell, #haskell-soc, #ghc and #xmonad 5h 44m 57s ago, and .
20:10:36 <wy> In order to save a few semicolons, we have to type a lot more tab keys :-P
20:10:57 <mauke> tab is for variable completion
20:11:12 <scook0> wy: it's not just typing though -- layout code *looks* cleaner
20:11:16 <wy> How do you indent then?
20:11:41 <mauke> ^T and ^D of course!
20:11:45 <wy> scook0:  semicolons don't really clutter the code. Look at SML...
20:11:50 <mauke> (actually, I use tab to increase indentation)
20:13:26 <wy> mauke:  My ^T is still transpose-chars
20:13:44 <mauke> that's xp
20:13:49 <wy> mauke:  So you have to press double the number of keys than me ;-)
20:14:03 <mauke> how so?
20:14:13 <wy> ctrl and tab
20:14:19 <wy> ctrl and T
20:14:36 <mauke> oh, yeah. which is why I use tab in reality
20:14:59 <wy> How many times do you need to use tab to get to the right column?
20:15:26 <mauke> 1 or 0 times
20:16:19 <wy> Now I only want semicolons back. Not {}, begin, end ;-)
20:17:07 <mauke> just use them
20:17:25 <wy> But haskell-mode doesn't indent lines even if I use them
20:17:50 <mauke> I just use autoindent/copyindent
20:18:45 <wy> C-c C-. is pretty nice
20:18:55 <mauke> what does that do?
20:19:12 <wy> align the equal signs
20:19:28 <mauke> ah
20:19:37 <wy> better use that on the last equal sign of your function definition
20:21:56 <wy> Is there a package for semantic analysis of the language? There really should be an editor that really understand scopes and get the true locations of definitions and references
20:22:33 <bos> there's Language.Haskell
20:25:55 <nolrai> @pl f (a, (b, c)) = g a b c
20:25:55 <lambdabot> f = uncurry ((`ap` snd) . (. fst) . g)
20:26:16 <oerjan> gah
20:26:17 <nolrai> @pl f (a, b, c) = g a b c
20:26:17 <lambdabot> (line 1, column 13):
20:26:17 <lambdabot> unexpected "="
20:26:17 <lambdabot> expecting variable, "(", operator or end of input
20:26:32 <oerjan>  @pl doesn't understand triples
20:26:42 <nolrai> aparently not
20:27:06 <oerjan> they're impossible to turn pointless
20:27:11 <cdsmithus> Cale: Are you still here?
20:27:19 <Cale> yep
20:27:44 <cdsmithus> Cale: Do you remember more about fixing the newtype deriving in lambdabot that you mentioned earlier?  I'm running into it now, and it's not clear what to do.
20:27:45 <oerjan> @pl f ((a,b),c) = g a b c
20:27:46 <lambdabot> f = uncurry (uncurry g)
20:27:54 <byorgey> oerjan: well, you just have to implement some combinators like fst and snd but for triples.
20:28:12 <Cale> cdsmithus: It's something like MonadReader Foo, right?
20:28:31 <cdsmithus> Cale: It's MonadError
20:28:45 <Cale> ah, okay
20:29:00 <nolrai> is (a, b, c) sugar for ((a, b), c)?
20:29:02 <Cale> change  MonadError Something  to  MonadError e
20:29:09 <oerjan> nolrai: no
20:29:09 <Cale> nolrai: Nope
20:29:45 <cdsmithus> Cale: Okay, so the instance delcaration is newtype ModuleT s m a = ModuleT { moduleT :: ReaderT (MVar s, String) m a }
20:29:45 <cdsmithus>     deriving (Functor, Monad, MonadTrans, MonadIO, MonadError IRCError, MonadState t)
20:30:00 <cdsmithus> And the error is on MonadError IRCError
20:30:04 <Cale> Yeah, replace IRCError with e
20:30:06 <nolrai> huh must have falsely analogized from lists
20:30:15 <oerjan> @pl f a (b,c) = g a b c
20:30:16 <lambdabot> f = (`ap` snd) . (. fst) . g
20:30:40 <cdsmithus> Looks like that did it.  Thanks!
20:32:04 <oerjan> @pl f a (b,c) = a b c
20:32:05 <lambdabot> f = (`ap` snd) . (. fst)
20:32:45 <oerjan> isn't that just uncurry.
20:33:48 <oerjan> @unpl uncurry (uncurry . g)
20:33:49 <lambdabot> uncurry (\ c -> uncurry (g c))
20:34:27 <BMeph> @pl f (a,b) c = a b c
20:34:27 <lambdabot> f = ap fst snd
20:34:37 <oerjan> :t (`ap` snd) . (. fst)
20:34:38 <lambdabot> forall b a b1. (a -> b1 -> b) -> (a, b1) -> b
20:34:43 <oerjan> :t uncurry
20:34:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:34:59 <oerjan> oh wait
20:35:15 <toad3k> is there a more general version of the lines and words functions?
20:35:35 <oerjan> toad3k: no
20:35:39 <toad3k> bummer
20:35:51 <oerjan> frequently asked for though...
20:36:21 <toad3k> toss my request onto the pile.
20:37:28 <BMeph> To that end, wouldn't lines just be wordsBy '\n'?
20:37:54 <oerjan> there are subtleties.
20:38:04 <oerjan> > words "test  ho"
20:38:06 <lambdabot>  ["test","ho"]
20:38:15 <oerjan> > lines "test\n\nho"
20:38:16 <lambdabot>  ["test","","ho"]
20:38:48 <nolrai> > words "test   ho"
20:38:49 <lambdabot>  ["test","ho"]
20:39:08 <nolrai> huh
20:39:45 <nolrai> so you cant have empty words but can have empty lines
20:39:53 <oerjan> yep
20:41:03 <BMeph> Ah - multiple dividers, of arbitraty number, versus one divider type of count one. Interesting.
20:41:06 <oerjan> > words " test  ho "
20:41:07 <lambdabot>  ["test","ho"]
20:41:16 <oerjan> > lines "\ntest\n\nho\n"
20:41:17 <lambdabot>  ["","test","","ho"]
20:42:27 <nolrai> those are realy quite difrent ops, although having generic versions of both would be nice.
20:44:08 <BMeph> In fact, all four combinations could be useful in some way.
20:44:46 <nolrai> the word one is almost a lexer, just dosnt have non-white-space brakes.
20:44:52 <BMeph> > words " test \n ho"
20:44:52 <toad3k> > intercalate "," ["item1","item2","item3"]
20:44:54 <lambdabot>   Not in scope: `intercalate'
20:44:54 <lambdabot>  ["test","ho"]
20:45:10 <oerjan> toad3k: lambdabot is not up to 6.8.2 yet
20:45:16 <toad3k> double bummer :)
20:45:36 <oerjan> > concat $ intersperse "," ["item1","item2","item3"]
20:45:37 <lambdabot>  "item1,item2,item3"
20:45:37 <Pseudonym> @version
20:45:37 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
20:45:38 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:45:39 <toad3k> well a deintercalate would make my christmas
20:45:52 <ixvv> Hmm this reminds me of something i didnt solve before. Does anyone have a function like breaks, but it doesnt drop the 'break element'? I want something like [a,b,c,a,b,c] -> ["abc","abc","abc"] ?
20:46:22 <nolrai>  ?!?
20:46:24 <oerjan> ixvv: er what's that?
20:47:34 <oerjan> ixvv: did not understand your function
20:47:51 <nolrai> is that ment to be [a,b,c,a,b,c] -> ["abc","abc"]?
20:48:16 <oerjan> still quite a bit underspecified :)
20:48:18 <ixvv> Yes, [a] -> [[a]] , i didnt put quotes on the chars
20:48:43 <scook0> "abcabc" -> ["abc", "abc"]
20:48:58 <oerjan> um and what's the test?
20:49:30 <nolrai> (== 'c') maybe?
20:49:31 <ixvv> break the list when it encounters 'a'
20:50:50 <ixvv> =='a'
20:50:52 <BMeph> ixvv: Always a, always (something specified elsewhere), or always the first element of the list?
20:51:05 <BMeph> s/a,/'a',/
20:51:37 <oerjan> hm...
20:52:10 <ixvv> Its specified, sorry for typing a bit slow, im on an n800. Just lurking =)
20:52:22 <nolrai> (== 'c') maybe?
20:52:27 <nolrai> sorry
20:52:38 <oerjan> > groupBy (const (== 'a')) "abcabc"
20:52:40 <lambdabot>  ["a","b","ca","b","c"]
20:52:44 <oerjan> eek
20:52:53 <oerjan> > groupBy (const (/= 'a')) "abcabc"
20:52:54 <lambdabot>  ["abc","abc"]
20:53:04 <oerjan> yay :)
20:53:10 <BMeph> oerjan++
20:53:12 <ixvv> Cool
20:53:41 <ixvv> Thanks oerjan!
20:53:44 <oerjan> > groupBy (const (/= 'a')) "bcabcabca"
20:53:46 <lambdabot>  ["bc","abc","abc","a"]
20:56:29 <EvilTerran> that's quite clever
20:56:34 * oerjan wonders how portable uses of groupBy with things that aren't equivalent relations are
20:56:45 <oerjan> *equivalence
20:57:35 <EvilTerran> well, in theory, any implementation would have to follow the behaviour of the report implementation
20:57:45 <BMeph> ?ty groupBy
20:57:45 <Cin> http://rtfs.ath.cx/Desktop/fourinarow.png
20:57:46 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
20:57:59 <Cin> yaaaay i'm going to make a four-in-a-row game
20:58:19 <BMeph> ?ty const (/='a')
20:58:20 <lambdabot> forall b. b -> Char -> Bool
20:58:35 <byorgey> Cin: awesome =)
20:58:44 <Cin> :D
21:04:33 <BMeph> oerjan: The whole point of groupBy is to supply the (a -> a -> Bool) "comparator". If it's an equivalence operator, so much the better, but it's not needed.
21:05:16 <oerjan> BMeph: however you could imagine an alternative implementation that always compared consecutive terms
21:05:42 <oerjan> it would be the same for transitive operators, but would break the above trick
21:06:22 <oerjan> the current implementation keeps comparing with the same first element until it fails
21:06:37 <ixvv> Im still a haskell noob. I tried editing break,partition etc. But ghc errors scare me. =)
21:07:11 <BMeph> Technically, not until it fails, just until the function evals to False. ;)
21:07:26 <ixvv> Anyway thanks again =)
21:07:40 <oerjan> @slap BMeph
21:07:41 * lambdabot is overcome by a sudden desire to hurt BMeph
21:07:51 <BMeph> ?bs
21:07:52 <lambdabot> Done.
21:07:58 <BMeph> @bot
21:07:58 <lambdabot> :)
21:08:00 <EvilTerran> ... what?
21:08:04 <EvilTerran> ?help bs
21:08:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:08:07 <oerjan> oh no
21:08:12 <oerjan> @b
21:08:12 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . ? @ v
21:08:27 <BMeph> ?bo
21:08:27 <lambdabot> :)
21:08:28 <oerjan> ?bs +[.]
21:08:29 <lambdabot>  fd:21: hClose: resource vanished (Broken pipe)
21:09:23 <EvilTerran> ?bf +[.]
21:09:24 <lambdabot>  fd:21: hClose: resource vanished (Broken pipe)
21:09:47 <EvilTerran> that'll be the one, then
21:14:26 <BMeph> ((groupBy . (const . (/=)))=<<head) "abcabc"
21:14:30 <BMeph> > ((groupBy . (const . (/=)))=<<head) "abcabc"
21:14:32 <lambdabot>  ["abc","abc"]
21:14:46 <BMeph> > ((groupBy . (const . (/=)))=<<head) "abacab"
21:14:47 <lambdabot>  ["ab","ac","ab"]
21:14:52 <BMeph> ?bo
21:14:52 <lambdabot> :)
21:15:10 <nolrai> ?bo +
21:15:11 <lambdabot> :)
21:27:24 <wy> Interesting. It seems the diamond problem doesn't exist in type classes.
21:27:50 <chadz_> or interfaces.
21:28:49 <wy> I think that's because the methods are in one namespace
21:29:14 <clanehin> haskell doesn't support the kind of function overloading that leads to that problem
21:29:50 <wy> I just proved that we don't need that kind of overloading. I don't know if I'm correct
21:30:14 <oerjan> i'm afraid it _may_ happen if class aliases are implemented
21:30:47 <oerjan> specifically the part of allowing defaults for superclasses
21:30:47 <wy> What's class alias?
21:31:12 <wy> But you still can have only one function of that name
21:31:40 <oerjan> there may be conflicting choices for the implementation, though
21:32:54 <oerjan> @go class alias haskell
21:32:55 <lambdabot> http://repetae.net/recent/out/classalias.html
21:32:56 <lambdabot> Title: Class Alias Proposal for Haskell
21:33:02 <wy> There is how my argument goes. Theorem 1. We don't need non-method functions with the same name but different types.
21:34:03 <wy> Sorry, change. Theorem 1. We don't need non-method functions with the same name but different implementations.
21:34:25 <clanehin> wy: haskeller's don't normally talk about "methods", typeclasses provide type-indexed functions, not classes as generally undertood in the object oriented world
21:35:15 <wy> clanehin:  They'd better have a name, and the "Gentle Introduction" calls them methods
21:35:59 <EvilTerran> a lot of places do tend to talk about methods of typeclasses in haskell
21:36:19 <wy> Theorem 2. We don't need to overload methods with different types other than the type of the class.
21:36:38 <clanehin> I'll let it go then
21:36:47 <wy> EvilTerran:  What else can I call them?
21:37:17 <EvilTerran> call 'em methods, everyone else does
21:37:44 <clanehin> wy: I've seen it so rarely that it struck me as odd, but I guess it's more common than I thought
21:37:59 <wy> alright :-) Do you think my two claims to be true?
21:38:10 <oerjan> clanehin: it's used in the H98 report as well
21:38:32 <clanehin> I officially lose then.  :)
21:39:07 <nolrai> its a not so great borrowing of terms, the similarity to OO concepts hinders understanding i think.
21:40:12 <wy> Right. Let's think of some new name for it?
21:40:40 <clanehin> type indexed function?
21:40:57 <wy> characteristic function?
21:41:30 <nolrai> that works.
21:42:10 <nolrai> now how to get the rest of the world to agree..
21:42:55 <sclv> ok hi quick parsec question.
21:43:17 <sclv> anonTemplate = do {  char '{';  var <- many1 (noneOf "}");  char '}';  return (makeAnonTmpl var)}
21:43:24 <sclv> this is lovely but they don't nest.
21:43:32 <sclv> i suppose i need some sort of pushdown stack?
21:43:35 <dobblego> ?hoogle (Eq a) -> [a] -> a -> Bool
21:43:35 <lambdabot> No matches, try a more general search
21:43:44 <dobblego> ?hoogle (Eq a) -> a -> [a] -> Bool
21:43:44 <lambdabot> No matches, try a more general search
21:43:49 <sclv> I really don't want to have to go and use the parsec lexer too, if possible.
21:44:34 <sclv> what's the easiest way to get nested braces/parens then?
21:44:39 <Cale> sclv: How exactly should they nest?
21:44:45 <oerjan> sclv: recursion?
21:45:15 <nolrai> it can be done. mine wasnt very nice looking but it can be done.
21:45:20 <sclv> oerjan: thanks! it might be that simple.
21:45:24 <Cale> sclv: brackets = do { char '('; brackets; char ')'; return () } <|> return ()
21:45:28 <oerjan> many1 (anonTemplate <|> noneOf "}"), except that won't collect the result correctly
21:45:35 <dobblego> ?hoogle (Eq a) -> a -> [a] -> Bool
21:45:36 <lambdabot> No matches, try a more general search
21:45:38 <dobblego> oops
21:45:56 <sclv> Cale: didn't mean like that -- meant more generally.
21:46:20 <Cale> brackets = do { char '('; n <- brackets; char ')'; return (n+1) } <|> return 0 -- for an example where a value is returned
21:46:46 <nolrai> dobblego: what are you looking for?
21:46:49 <Cale> sclv: anyway, so long as you're consuming a character before recursing, recursion should work just fine
21:46:56 <dobblego> nolrai, contains?
21:47:07 <nolrai> elem
21:47:12 <dobblego> ah of course, cheers
21:47:26 <jaredj> :t elem
21:47:27 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:47:28 <sclv> right: the problem I ran into, I guess, is that I just realized I need to recurse directly into another parser instead of just grabbing some other stuff and then parsing it later.
21:47:34 <dobblego> why didn't lambdabot find it?
21:47:40 <dobblego> oh s/->/=>
21:47:41 <jaredj> dobblego: aha, => vs ->
21:47:42 <jaredj> yes
21:47:59 <dobblego> silly lunch beer did that
21:48:11 * jaredj wants lunch beer
21:48:13 <Cale> sclv: Then it's possible that you want a chainl, or something like it.
21:48:22 <wy> Any ideas where is fromInteger of the numbers called?
21:48:34 <oerjan> wy: no parse
21:48:38 <Cale> wy: What?
21:48:39 <dobblego> is there a elem for sorted lists?
21:48:47 <oerjan> @src Num
21:48:48 <lambdabot> class  (Eq a, Show a) => Num a  where
21:48:48 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:48:48 <lambdabot>     negate, abs, signum     :: a -> a
21:48:48 <lambdabot>     fromInteger             :: Integer -> a
21:48:52 <Cale> wy: *where* is it called?
21:48:58 <skew> dobblego: almost
21:49:04 <dobblego> :t almost
21:49:05 <lambdabot> Not in scope: `almost'
21:49:11 <jaredj> hehe
21:49:15 <dobblego> I'll write one with takeWhile and elem
21:49:15 <Cale> wy: Anywhere that a numeric conversion from an integral type is needed?
21:49:19 <EvilTerran> head .: dropWhile . (/=)
21:49:31 <skew> dobblego: listToMaybe . dropWhile (<x)
21:49:33 <dobblego> ?type (.:)
21:49:34 <lambdabot> Not in scope: `.:'
21:49:49 <EvilTerran> (f .: g) x y = f (g x y)
21:50:06 <jsnx> why doesn't `toInteger` work on Rationals? i mean, what's the philosophy there?
21:50:11 <nolrai> i think he ment "head . dropWhile (/=)
21:50:11 <jaredj> O_o
21:50:21 <jsnx> > (toInteger 1.2) :: Integer
21:50:21 <lambdabot>  Add a type signature
21:50:44 <skew> jsnx: sounds like you are looking for round
21:50:52 <nolrai> > (round 1.2)
21:50:54 <lambdabot>  1
21:51:00 <EvilTerran> nolrai, maybe head.dropWhile(/=x)
21:51:09 <EvilTerran> dropWhile (/=) is ill-typed
21:51:24 <nolrai> :t dropWhile
21:51:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:51:29 <jsnx> skew: no, i am looking for understanding
21:51:52 <jsnx> skew: (`trunc` fills my need)
21:51:56 <skew> jsnx: Integral is for types that actually represent the integers or a subset
21:52:03 <jsnx> skew: aye
21:52:14 <nolrai> 1.2 is not an integer
21:52:16 <skew> jsnx: and toIntegral is the embedding that witnesses that
21:52:28 <skew> jsnx: rational numbers are not a subset of the integers
21:52:31 <jsnx> yes, but why not make it handle rationals, too?
21:52:41 <jsnx> skew: i am trying to figure out why they did that
21:53:04 <jsnx> i guess, it is because there is more than one way to go `Rational -> Integer`
21:53:20 <skew> jsnx: more than that, toIntegral needs to be a homomorphism
21:53:37 <jsnx> skew: why?
21:54:41 <jsnx> that is an interesting criterion
21:54:51 <jsnx> i am so tired, i am going to bed
21:54:52 <skew> jsnx: like I said, it's supposed to be the witness that an Integral type actually corresponds to a subset of the integers in some reasonable way
21:55:13 <jsnx> well, i do not understand this 'witness' bit
21:55:19 <jsnx> but, i will come back
21:55:22 <jsnx> skew: thank you
21:56:07 <skew> dobblego: oh, I wrote something close to "lookup" rather than elem
21:56:51 <wy> Ah, I see how 1+2.4 works
21:56:56 <wy> > (1::Integer) + 2.4
21:56:57 <lambdabot>   add an instance declaration for (Fractional Integer)
21:57:44 <nolrai> > 1+2.4
21:57:45 <lambdabot>  3.4
21:58:40 <ricky_clarkson> :t 3.4
21:58:41 <lambdabot> forall t. (Fractional t) => t
21:58:42 <wy> I deliberately made that example
21:58:48 <wy> :t 1
21:58:50 <lambdabot> forall t. (Num t) => t
21:58:50 <Enzo> Anyone know of a tutorial on how to write a form in Haskell?
21:59:27 <ricky_clarkson> @instances Fractional
21:59:27 <lambdabot> Double, Float
22:00:11 <ricky_clarkson> Huh?  Double is a Fractional?
22:00:17 <ricky_clarkson> @instances Floating
22:00:17 <lambdabot> Double, Float
22:00:31 <wy> Do I have this command in ghci?
22:00:33 <chadz_> :t (/)
22:00:34 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:01:14 <wy> 1+2.4 works because 1 is Num and 2.4 is Fractional, and the principal type of 1 is Fractional here
22:01:30 <wy> ... no
22:01:46 <ricky_clarkson> :t 1+2.4
22:01:47 <lambdabot> forall t. (Fractional t) => t
22:02:07 <ricky_clarkson> Blimey, it really doesn't like to infer concrete types unless necessary.
22:02:13 <wy> Ah, The principal type is (Fractional t) => t
22:02:14 <chadz_> wy needs a girlfirned :)
22:02:24 <wy> Why?
22:02:57 <chadz_>  because that's what type Boy does.
22:03:01 <chadz_> usually
22:03:21 <skew> wy: it would be (Num t, Fractional t) => t, except Num is a superclass of Fractional so the constraint can be simplified
22:05:12 <wy> Is the class hierarchy a dag?
22:06:38 <wy> This type system is really wonderful
22:06:48 <dons> dcoutts: around?
22:09:11 <nolrai> are complex numbers defined someware in haskell?
22:09:33 <skew> Data.Complex
22:10:04 <nolrai> cool
22:10:28 <ddarius> @index Complex
22:10:28 <lambdabot> Data.Complex
22:10:53 <nolrai> thats the comand!
22:14:29 <ddarius> @hoogle Complex
22:14:30 <lambdabot> Data.Complex :: module
22:14:30 <lambdabot> Data.Complex.Complex :: data Complex a
22:23:15 <nolrai> @src show
22:23:15 <lambdabot> show x = shows x ""
22:26:21 <nolrai> sqrt (-1)
22:26:24 <nolrai> > sqrt (-1)
22:26:27 <lambdabot>  NaN
22:26:40 <nolrai> > sqrt (-1::Complex)
22:26:40 <lambdabot>      `Complex' is not applied to enough type arguments
22:26:40 <lambdabot>     Expected kind `?',...
22:26:53 <nolrai> > sqrt (-1::Complex Float)
22:26:53 <lambdabot>  -0.0 :+ 1.0
22:27:31 <nolrai> why is it -0.0?
22:28:20 <nolrai> :t pi
22:28:21 <lambdabot> forall a. (Floating a) => a
22:28:51 <nolrai> sin ((0.0 :+ 1.0) * pi)
22:28:56 <nolrai> > sin ((0.0 :+ 1.0) * pi)
22:28:57 <lambdabot>  0.0 :+ 11.548739357257746
22:29:20 <nolrai> > exp ((0.0 :+ 1.0) * pi)
22:29:21 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
22:30:08 <nolrai> > exp ((0%0 :+ 1%0) * pi)
22:30:09 <lambdabot>   add an instance declaration for (RealFloat (Ratio t))
22:30:09 <lambdabot>     In the expression...
22:30:53 <shachaf> > (0,-0,0.0,-0.0)
22:30:54 <lambdabot>  (0,0,0.0,-0.0)
22:31:24 <shachaf> > -(1 + 2)
22:31:25 <lambdabot>  -3
23:04:27 <Cin> if one has a program separated into two modules and files, like YAHT's example of Poker.hs and Cards.hs, and the Poker module imports Cards, how would that be compiled with GHC?
23:09:10 <Cin> disregard that
23:09:39 <OceanSpray> :t getArgs
23:09:39 <lambdabot> Not in scope: `getArgs'
23:09:51 <OceanSpray> :t IO.getArgs
23:09:52 <lambdabot> Not in scope: `IO.getArgs'
23:11:40 <shachaf> OceanSpray: IO [String]?
23:11:53 <OceanSpray> yes
23:12:45 <shachaf> OceanSpray: Do you have a question? :-)
23:12:55 <OceanSpray> no
23:17:09 <alkoma> :t System.getArgs
23:17:09 <lambdabot> IO [String]
23:22:38 <alkoma> Hi, I have access to a couple of FreeBSD 6.1 boxes, it has ghc-6.4.1 installed from ports.  Is it possible to build ghc-6.8.2 ?  (I understand that I have to build ghc-6.6.x first)
23:23:00 <OceanSpray> :t getContents
23:23:01 <lambdabot> IO String
23:23:16 <quicksilver> alkoma: I have a feeling 6.4.1 is capable of compiling 6.8.2 directly.
23:23:20 <quicksilver> alkoma: I'm not sure, though.
23:25:28 <alkoma> I will try without the 6.6x step ... but the 6.8.2 page says: The source distribution needs an installed GHC (version 6.0 at least).
23:25:49 <OceanSpray> hold on a minnit
23:26:05 <OceanSpray> why doesn't getContents take a handle as an argument?
23:26:29 <shachaf> alkoma: 6.4 > 6.0? :-)
23:27:11 <alkoma> :) what's wrong with me :)
23:27:17 <dons> OceanSpray: hGetContents
23:28:48 <alkoma> thanks quicksilver, shachaf.   Hopefully after a couple of hours I will have brand-new ghc-6.8.2! :)
23:31:17 <Flynsarmy> How do you create an infinate list of increasing integers? I tried typing in [1, 2, ...] but it didn't work
23:31:27 <Cin> [1..]
23:31:30 <Cin> iirc
23:31:51 <Flynsarmy> thanks
23:32:15 <wy> > floor(4/3) + 2.4
23:32:16 <lambdabot>  Add a type signature
23:32:55 <Cin> hm. just realised i have no idea how i'm going to store state in this gui program
23:33:36 <ddarius> > [1..]
23:33:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:33:40 <ddarius> > [1,2..]
23:33:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:33:57 <Donny_> [1,3..]
23:34:15 <Donny_> > [1,3..]
23:34:15 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
23:34:57 <wy> > 1+2
23:34:58 <lambdabot>  3
23:36:24 <wy> @kind (,,,,,,)
23:36:25 <lambdabot> * -> * -> * -> * -> * -> * -> * -> *
23:36:42 <wy> @kind (,,,,,,,,,,,,,,,,,,,,,,,,,)
23:36:43 <lambdabot> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> *
23:37:09 <wy> Is this infinite?
23:37:58 <wy> Oh it's 2:37 am. I thought it was 2:37 pm
23:39:01 <wy> @users
23:39:01 <lambdabot> Maximum users seen in #haskell: 434, currently: 374 (86.2%), active: 10 (2.7%)
23:39:18 <wy> Hmmm this is really low point
23:41:08 <psi> isn't kinds sort of types for types? what's ,,,,, supposed to mean?
23:43:00 <jurku> > [1,3,5,4,8,10,12..]
23:43:01 <lambdabot>  Parse error at "..]" (column 17)
23:43:14 <jurku> > [1,3,5..]
23:43:14 <lambdabot>  Parse error at "..]" (column 7)
23:43:33 <scook0> psi: (,) is the constructor for pairs
23:43:36 <scook0> (,,) for triples
23:43:37 <scook0> etc.
23:44:06 <scook0> @kind (,,)
23:44:07 <lambdabot> * -> * -> * -> *
23:45:53 <wy> Now I seem to have found the counterpart of class inheritance in Haskell.
23:45:57 <psi> @type (,,,)
23:45:58 <scook0> the @kind is a little misleading, because I don't believe you can actually write (,,) Int Int Int to mean the type of triples of ints
23:45:58 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
23:46:14 <scook0> you write (Int, Int, Int) instead
23:46:18 <wy> newtype is actually this thing, but I don't see how we can avoid copying code
23:46:21 <psi> Ah, I see
23:46:44 <wy> @type (,,,,,,,,,,,,)
23:46:45 <lambdabot> forall a b c d e f g h i j k l m. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a, b, c, d, e, f, g, h, i, j, k, l, m)
23:46:53 <scook0> wy: if it's instance declarations you want to copy, you can use what's called "newtype deriving"
23:46:55 <wy> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
23:46:56 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x
23:46:56 <lambdabot> -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33)
23:47:01 <wy> haha
23:47:47 <wy> where is t27?
23:47:50 <scook0> newtype Blah = MkBlah Integer deriving (Eq, Ord)
23:48:35 <wy> What if I only want to change one method, say (-), because I want to make a natual number
23:51:26 <wy> There is lots of boilerplate code if I want to make it Num. I have to code toNatual, fromNatual, I have to (almost) repeat the definition of  (+) and (*)
23:51:57 <wy> Maybe there is no better way to do this
