00:00:04 <jz87> basically how hot code replacement works in erlang is just with higher order functions
00:00:12 <jsnx> jz87: oh, i see
00:00:20 <jsnx> jz87: you are basically right
00:00:25 <jz87> fun (real_fun) -> real_fun(); fun(real_fun).
00:00:40 <jsnx> because the code does not get swapped until the function is called next
00:00:44 <jz87> yes
00:00:52 <jsnx> so, we figured that out
00:00:59 <jz87> so you would basically pass a message that makes the tail call be fun(new_fun)
00:00:59 <TSC> runar: Maybe you need to do the inductive step
00:01:07 <jz87> haskell can do that too
00:01:08 <Cale> runar: you'll probably need the property that  map f (xs ++ ys) = map f xs ++ map f ys
00:01:22 <jsnx> jz87: well, you never actually pass that message in erlang
00:01:32 <runar> Cale: Thanks, I was indeed looking for a more general property.
00:01:33 <jz87> what do you mean?
00:01:33 <Cale> Of course, along with [f x] = map f [x], which is trivial.
00:01:37 <jsnx> jz87: you just wait for the process to kick itself
00:01:45 <jsnx> jz87: or you kill it
00:01:58 <jz87> I don't really understand what yoiu're trying to say
00:02:09 <jz87> why do you need to wait for the process to kill itself to hot code swap?
00:02:24 <jsnx> jz87: because, a process is a function in erlang
00:02:28 <jz87> yes
00:02:32 <jz87> well no
00:02:33 <Cale> !paste
00:02:34 <hpaste> Haskell paste bin: http://hpaste.org/
00:02:37 <jz87> processes run functions
00:02:53 <jz87> functions correspond more to states of a process
00:03:05 <jz87> when a process is running a particular function it's in that state
00:03:14 <jz87> and the process can transition to a new state by calling another function
00:03:20 <jsnx> jz87: yes
00:03:33 <jz87> hot code swapping is essentially transitioning to a state not defined originally
00:03:39 <jsnx> jz87: well, no
00:03:56 <jz87> what do you mean
00:04:13 <jsnx> jz87: when it makes the usual state transition, the *name* to which it transitions is the same
00:04:22 <jz87> yes
00:04:24 <jsnx> jz87: it's just the code is different after the swap
00:04:26 <jz87> yes
00:04:45 <jsnx> jz87: so, erlang processes are written to *call the same funtion over and over again*
00:04:50 <hpaste>  Cale pasted "main part of proof" at http://hpaste.org/4728
00:04:52 <jz87> well the name bindings has to be the same
00:04:56 <jsnx> right
00:05:09 <jsnx> so, when it is done with this iteration, it starts up again with the new code
00:05:23 <jz87> yes
00:05:28 <jsnx> you usually can't send it a message to "reload" unless you built that into your protocol
00:05:31 <jz87> yes
00:05:50 <jz87> but shouldn't haskell be able to do the same thing
00:05:50 <jsnx> so in general, hot code swapping doesn't happen that way
00:06:02 <jz87> if you write a function that takes as one possible input
00:06:11 <jsnx> jz87: well, do we have a process abstraction?
00:06:12 <jz87> a Reload(closure) constructor
00:06:31 <jz87> well no, but we do have threads
00:06:44 <jz87> I don't see how haskell threads are different from erlang processes
00:06:51 <runar> Cale: That was it. Thanks a lot. I'm able to complete the induction step by proving that property.
00:07:03 <jsnx> jz87: the erlang process is something very specific
00:07:07 <jz87> you pass a closure to a forkIO/spawn function
00:07:16 <jz87> and it executes concurrently with your former process/thread
00:07:34 <jz87> oh? is there some subtlety I'm missing?
00:07:40 <jz87> it looks really similar to me
00:07:51 <jsnx> jz87: in erlang, processes have a global handle, and you send messages to it
00:08:05 <jz87> I thought you only get a global handle if you register it
00:08:11 <jsnx> jz87: no
00:08:21 <jsnx> jz87: it is there, it just can't be looked up
00:08:41 <jsnx> jz87: but, if one process sends another a message, the handle can be revealed
00:08:42 <jz87> well, why can't you build an abstraction based on TVar
00:08:59 <jsnx> well, it's a different abstraction, is my point
00:09:17 <jsnx> with TVar, you manage the *channels* of communication, explicitly
00:09:24 <jsnx> (right?)
00:09:27 <jz87> yes
00:09:47 <jz87> but can't you define an abstraction that basically associates a fokIOed thread with a TVar
00:09:51 <jz87> that is its handle?
00:10:00 <jsnx> sure, yes
00:10:07 <jsnx> that's the abstraction we'd need
00:10:25 <jsnx> though, i suppose we'd need *two* -- input and output
00:10:44 <jz87> I thought you can only pass messages one way in erlang
00:11:01 <jsnx> you can pass messages along one *channel*
00:11:03 <jz87> if you want someone to call you back to have to pass your own handle along with the message
00:11:13 <jsnx> yeah, exactly
00:11:20 <jsnx> oh, yeah you are totally right
00:11:24 <jsnx> sorry, i was wrong
00:11:31 <jsnx> you only need one TVar
00:11:41 <jsnx> thinking of sockets, for some reason
00:12:11 <jz87> it just seems like you can implement this stuff as a framework/library in haskell
00:12:29 <jz87> basically you define a main that starts up a socket server that listens for incoming messages
00:12:31 <jsnx> jz87: well, you still don't have the networking stuff worked out
00:12:38 <jz87> and the application developer define a AppMain
00:12:39 <jsnx> okay
00:12:44 <jz87> that gets called by your framework main
00:13:06 <jsnx> well, in erlang, you can send anything whatever through the wire
00:13:14 <jsnx> because it's all serializable
00:13:20 <jsnx> not so in haskell, though
00:13:23 <jz87> yeah, and that can get really ugly
00:13:28 <jz87> in terms of mental book-keeping
00:13:34 <jsnx> jz87: yes, ugly! i agree
00:13:34 <jz87> that's one of my least favorite parts of erlang
00:13:48 <jz87> wait, what is not serializable in haskell?
00:13:52 <jsnx> jz87: so, we need to have some rule
00:14:07 <jz87> can't you enforce a type rule like
00:14:08 <jsnx> jz87: like, only things of '*' kind could be sent
00:14:33 <jsnx> or, only serializable things?
00:14:43 <jz87> ! :: Pid a, Write b => a -> b -> STM ()
00:14:58 <jz87> so the type you specify as a message has to be of the type class Write
00:15:05 <jsnx> ah, i see
00:15:19 <jz87> most standard types are serializable
00:15:35 <jz87> and most types you define are also by structural induction
00:15:41 <jz87> maybe you'd have problems serializing functions
00:15:58 <jz87> but I guess you can define custom serializers for specific types
00:16:14 <jz87> although that's kind of clunky
00:16:54 <jsnx> aye
00:17:02 <jz87> sorry, not Write
00:17:03 <jz87> it's Show
00:17:06 <jz87> Show and Read
00:17:11 <Cale> It's ever so slightly annoying that there isn't a way to serialise things without evaluating them first :)
00:17:13 <jsnx> yeah, need both of them!
00:17:26 <jz87> that's true
00:17:32 <jz87> well usually Read and Show comes together
00:17:41 <jz87> I don't know what many types that is one but not the other
00:17:43 <jsnx> Cale: yeah, too bad -- because serializing [1..] should be easy...
00:17:59 <jz87> yeah, easy serialization is crucial in a distributed architecture
00:18:22 <jsnx> so, we are almost done, i think
00:18:36 <jz87> they need to stop adding more and more esoteric type hacks and start adding stuff like easy serialization
00:18:55 <jsnx> jz87: well, that's not what haskell is for, though...
00:19:04 <jsnx> but, here's the problem you can not solve
00:19:11 <jz87> it's so frustrating when I have to get real work done in crappy languages
00:19:20 <jsnx> how do we handle fatal exceptions?
00:19:24 <jz87> when there's this awesome language that is missing a few features
00:19:30 <jsnx> jz87: like erlang?
00:19:38 <jz87> yes
00:19:44 <jz87> erlang the language isn't anything great
00:19:48 <jz87> people use erlang for the runtime
00:19:57 <jsnx> jz87: you can't serialize most stuff in mathland -- why should you be able to serialize everything in haskell?
00:20:13 <jz87> well you don't have to serialize everything
00:20:14 <jsnx> jz87: anyways, though, in haskell, exceptions really mean death
00:20:20 <jz87> you should only need to serialized messages
00:20:36 <jsnx> floating point errors and what not take down the whole runtime
00:20:37 <jz87> which would be a type class with read/show prerequisites
00:20:43 <jsnx> jz87: aye, i see
00:20:52 <jz87> yeah, that's a runtime issue
00:20:57 <jz87> that really should be delt with
00:21:03 <jsnx> jz87: well, it's part of the language definition
00:21:14 <jsnx> runtime exceptions are failures
00:21:36 <jsnx> which is why we like static analysis and all that jazz
00:22:07 <jz87> but you still need to accomodate the possibility of runtime exceptions
00:22:17 <jz87> because static analysis can't get rid of all of them
00:22:32 <jsnx> jz87: not in haskell :)  it's handled in an interesting way
00:22:38 <jz87> isn't that why haskell has the whole catch, try, combinators?
00:22:41 <jsnx> jz87: are you familiar with Maybe?
00:22:44 <jz87> yes
00:22:50 <jz87> that's one thing
00:22:54 <jz87> but Haskell also has exceptions
00:23:08 <jz87> specifically, asychronous exceptions
00:23:10 <Cale> jz87: yeah, but it's tricky to get those to catch the sort of exceptions thrown by error
00:23:12 <jz87> well GHC does
00:23:24 <jz87> what do you mean?
00:23:46 <jz87> don't you just wrap your code in code `catch` handler?
00:23:48 <Cale> You have to ensure that the error is actually evaluated in the catch.
00:24:07 <jsnx> i've never seen that stuff -- reading...
00:24:13 <Cale> Which usually involves using Control.Exception.evaluate
00:24:34 <jz87> wait, maybe I don't understand this well enough
00:24:42 <jz87> but I thought
00:24:52 <jz87> that if a piece of code throws an exception
00:25:19 <jsnx> it must happen in the IO Monad, since it's called through Main.main ?
00:25:36 <jz87> well exceptions can only be handled in the IO monad I think
00:25:37 <Cale> :t error
00:25:39 <lambdabot> forall a. [Char] -> a
00:25:45 <jz87> :t catch
00:25:46 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
00:26:19 <jz87> I thought there was an alternate definition of catch
00:26:29 <jz87> that has Exception -> IO a as the second argument
00:26:30 <Cale> :t Control.Exception.catch
00:26:31 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
00:26:37 <jz87> aha
00:26:40 <jz87> that's the one I was thinking of
00:26:53 <jsnx> weird
00:27:06 <jsnx> i thought that was basically impossible in haskell
00:27:11 <jz87> but I still don't quite get what you meant by you have to make sure the error is actually evaluated in the catch
00:27:36 <Cale> Well, try something like   return (error "foo") `catch` (\e -> return "hello")
00:27:43 <jz87> can you give an example of where <code> `catch` <handler>, where <code> throws an exception and it's not passed to handler?
00:27:51 <jz87> ok
00:28:17 <Cale> oh, and bind that whole thing to print
00:28:28 <jz87> let me just bootup ghci
00:28:34 <Cale> return (error "foo") `catch` (\e -> return "hello") >>= print
00:28:36 <jz87> I wish lambdabot came with a ghci console also
00:28:39 <jsnx> Cale: but what if you wrapped main in a catch?
00:28:56 <Cale> jsnx: it doesn't help here
00:29:06 <Cale> er
00:29:15 <jz87> hmm, that's weird
00:29:20 <jz87> why is it returning foo
00:29:42 <Cale> The exception doesn't happen until the (error "foo") is evaluated.
00:29:46 <jz87> ok
00:29:59 <jz87> print should've forced it to execute
00:30:02 <jsnx> Cale: it won't help here
00:30:07 <Cale> it does force it to evaluate
00:30:14 <Cale> but the print is outside the catch
00:30:16 <jcrites> how come when one talks about kinds, one only describes the arity?  you might say a kind is * => * or *
00:30:29 <jcrites> how come you wouldn't say a kind is like A => B, or E => C[E] ?
00:30:36 <jsnx> Cale: oh, tricky
00:30:38 <jz87> but shouldn't the block (error "foo") `catch` (\e -> return "hello") evaluate to "hello"?
00:30:51 <Cale> jcrites: because we don't have that flowery of a type system yet.
00:31:03 <jcrites> oh, so that's a research topic?  :o
00:31:08 <Cale> jcrites: there are actually some other kinds
00:31:14 <Cale> :kind (->)
00:31:17 <jcrites> I'm surprised someone hasn't gotten a PhD on that yet then :o
00:31:18 <jz87> well why would you need that many sort of kinds?
00:31:26 <jz87> it just seems like gold plating
00:31:33 <Cale> jcrites: There are other programming languages with more interesting kinds.
00:31:36 <jcrites> for the same reason you want to distinguish a -> b from b -> a even though they are both * -> *
00:31:42 <Cale> @kind (->)
00:31:42 <lambdabot> ?? -> ? -> *
00:32:26 <Cale> @kind GHC.Prim.Char#
00:32:26 <lambdabot> #
00:32:32 <Cale> @kind Char
00:32:33 <lambdabot> *
00:32:36 <jz87> I think more effort should be put into making haskell more friendly for production work
00:32:48 <jz87> this way I don't have to fry my brain trying to wrestle with Java
00:32:49 <jsnx> jz87: so, it looks like lazy evaluation allows a "bottom" to move around
00:33:10 <jsnx> jz87: there is no way to completely wrap it up
00:33:14 <jz87> but I still don't understand why the expression Cale wrote does that
00:33:40 <jz87> print is being passed the whole expression return (error "foo") `catch` (\e -> return "hello")
00:33:41 <Cale> jz87: The catch only throws exceptions which are thrown *while the IO action passed on the left runs*
00:34:02 <Cale> jz87: Executing (return x) in the IO monad specifically does not evaluate x
00:34:16 <Cale> (why would it?)
00:34:24 <jcrites> well even writing "x" in Haskell doesn't evaluate "x" right?
00:34:27 <jz87> yes
00:34:29 <jz87> that part I understand
00:34:38 <Cale> jcrites: depends what you mean by that...
00:34:47 <Cale> jcrites: things are evaluated outermost-first
00:34:50 <jz87> but as I understood it, `catch` is just like any other combinator
00:35:02 <jz87> so you're really evaluating catch
00:35:06 <jz87> and when you evaluate catch
00:35:09 <jz87> you evaluate error
00:35:16 <Cale> No you don't.
00:35:22 <jcrites> why do you evaluate error?
00:35:34 <jcrites> Haskell is non-strict
00:35:36 <jz87> because print forces the evaluation of return catch
00:35:54 <Cale> You evaluate return (error "foo"), to the point where it can be executed, which doesn't involve evaluating (error "foo")
00:35:57 <jz87> and catch needs to evaluate error to get its value
00:36:16 <jz87> yes, you get a thunk
00:36:22 <jsnx> Cale: what is the *right* way to code the example?
00:36:40 <jz87> but don't you need to evaluate (error "foo") in order to print?
00:36:52 <jz87> this is so counter intuitive
00:36:53 <jsnx> jz87: yeah, but that comes later...
00:37:31 <jsnx> jz87: so, it looks like runtime errors can not be caught in a general fashion in haskell
00:37:47 <Cale> Prelude Control.Exception> evaluate (error "foo") `Control.Exception.catch` (\e -> return "hello") >>= print
00:37:47 <Cale> "hello"
00:38:36 <Cale> (the ugly qualification of catch is just because I can't import Prelude hiding catch from the GHCi prompt ;)
00:38:39 <jz87> so that forces strict evaluation?
00:38:55 <jz87> using evaluae?
00:39:16 <Cale> evaluate x will cause the evaluation of x to WHNF, in sequence with the rest of the IO monad computations.
00:39:24 <Cale> (and returns the result of that evaluation)
00:39:26 <jz87> WHNF?
00:39:33 <TSC> weak head normal form
00:39:39 <Cale> Weak head normal form, essentially to the top level constructor.
00:39:42 <jz87> ah
00:39:51 <jz87> so you can call evaluate on [1..]
00:39:55 <jz87> without infinite loop right?
00:40:04 <Cale> right
00:40:07 <jz87> since it's just List
00:40:21 <jsnx> oh, nifty
00:40:22 <Cale> It'll just evaluate to determining that the list is a cons cell.
00:40:24 <jz87> that is so non-obvious
00:40:27 <Cale> and then stop
00:40:37 <jz87> definitely one of the dark corners of haskell
00:40:38 <Cale> (which is what evaluation tends to mean)
00:40:49 <Cale> It's not that dark. It's totally in line with what seq does.
00:41:03 <jz87> but the catch behavior is really unexpected
00:41:26 <Cale> It's troubling, but you should see why it occurs.
00:41:27 <jz87> it's completely not in line with the substitution semantics I use to reason about haskell programs in general
00:41:35 <jz87> honestly I still don't see it
00:41:48 <jz87> what is the evaluation order
00:41:53 <jz87> in that expression?
00:42:02 <jz87> isn't it print -> catch -> error?
00:42:22 <jz87> my mental model is that we try to evaluate print, print needs to evaluate return (catch)
00:42:25 <Cale> Well, when you execute an IO action, it's only evaluated as little as necessary to do its work.
00:42:33 <Cale> Consider:
00:42:33 <jz87> but in sequence
00:42:35 <jz87> right?
00:42:46 <Korollary> catch ignores the arg.
00:42:51 <Korollary> err the catcher ignores
00:42:58 <Cale> do putStrLn "Hello"; return undefined; putStrLn "Goodbye"
00:43:13 <Cale> The return undefined is still a no-op.
00:43:34 <jz87> wait
00:43:36 <jz87> on my ghci
00:43:38 <jz87> that printed Hello
00:43:40 <jz87> and then Goodbye
00:43:43 <Cale> right
00:43:44 <jz87> which is what I expect
00:44:02 <Cale> And not Hello, followed by an error
00:44:07 <Cale> Instead, try:
00:44:12 <Cale> do putStrLn "Hello"; undefined; putStrLn "Goodbye"
00:44:29 <jz87> hmm
00:44:44 <jz87> :t undefined
00:44:46 <lambdabot> forall a. a
00:45:22 <jz87> :t do putStrLn "Hello"; undefined; putStrLn "Goodbye"
00:45:23 <lambdabot> IO ()
00:45:38 <Cale> So the important thing to notice here is that return isn't strict.
00:45:39 <jsnx> hey, it works different on my system if i use different catch
00:45:45 <jz87> I see
00:45:46 <Cale> jsnx: yeah.
00:45:58 <Cale> jsnx: The prelude catch can't catch all types of exceptions.
00:45:59 <jsnx> (error "foo") `Control.Exception.catch` (\ _ -> print "error")
00:46:00 <jz87> but putStrLn is?
00:46:09 <jsnx> returns "error"
00:46:20 <jz87> so return is undefined, but putStrLn is
00:46:24 <jsnx> (error "foo") `Prelude.catch` (\ _ -> print "error")
00:46:37 <jz87> so there is some sort of strict list for built in functions?
00:46:39 <Cale> jz87: well, putStrLn forces its argument when executed, so in that sense it's strict
00:46:43 <jsnx> gives me "*** Exception: foo"
00:46:49 <Cale> (but not just when evaluated)
00:47:14 <Cale> Prelude Control.Exception> putStrLn undefined `seq` ()
00:47:14 <Cale> ()
00:47:17 <jz87> ah I see
00:47:20 <jz87> return doesn't force
00:47:24 <jz87> because there is nothing using its value
00:47:27 <Cale> right
00:48:05 <Cale> If you were to return some lengthy expensive computation from an IO action, perhaps you wouldn't want it evaluated right away.
00:48:07 <jz87> so the semantics of catcy
00:48:13 <jz87> so here's my question then
00:48:26 <jz87> why isn't the semantics of catch defined so that the first argument is forced?
00:48:41 <jz87> I mean you need to evaluate something in order to determine whether or not it raises an exception
00:48:42 <Cale> It is forced, but it evaluates to an IO action.
00:48:56 <jz87> :t error
00:48:57 <lambdabot> forall a. [Char] -> a
00:49:06 <jz87> :t catch
00:49:07 <Cale> The evaluation of that IO action doesn't necessarily involve the evaluation of every term inside it.
00:49:07 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
00:49:15 <jz87> :t Control.Exception.catch
00:49:16 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
00:49:32 <jz87> ok
00:49:40 <Cale> You can think of an IO action as simply a piece of data describing what's to be done.
00:49:43 <jz87> so return (error "foo") is returned without evaluation to print
00:49:52 <Cale> It's the runtime system which actually carries out those instructions.
00:50:07 <dibblego> is dons going to do a Haskell version of Top 10 most popular Haskell programs as requested by Dr. Harrop?
00:50:14 <Cale> error "foo" is returned without evaluation to print
00:50:24 <Korollary> dibblego: jdh 'requested' ?
00:50:25 <Cale> and at that point, when the print is finally *executed*
00:50:32 <Cale> is when the error happens
00:50:33 <dibblego> Korollary, yes, on reddit
00:50:37 <jz87> ok I see it now
00:50:51 <Cale> Prelude> print (error "foo") `seq` ()
00:50:51 <Cale> ()
00:50:54 <jz87> that just seems so counterintuitive of how one would expect catch to work
00:50:55 <dibblego> Korollary, "I'd love to see DonS do a Haskell version of this... ;-)"
00:51:10 <jz87> I had totally expected catch to force evaluation of its IO action
00:51:17 <Cale> That shows that the evaluation alone of  print (error "foo")  doesn't cause the error. The IO action actually has to run.
00:51:19 <jz87> and then trgger the handler if an exception occurs
00:51:26 <Korollary> dibblego: why don't we just have a pissing contest like real boys?
00:51:41 <Cale> jz87: Execution of catch does force the evaluation of the IO action.
00:51:56 <Cale> jz87: It just doesn't force the evaluation of the *result* of that action.
00:52:16 <jz87> so wait
00:52:20 <jz87> what if I have something like
00:52:38 <jz87> [a, b, (error "foo")]
00:52:42 <Cale> (it forces the evaluation of the IO action because that action must run, so which instructions it consists of must be determined)
00:52:52 <Cale> Oh, then you're even more out of luck :)
00:53:11 <Cale> You need to apply more than just evaluate to cause that one to occur.
00:53:34 <jz87> return [(error "foo")] `catch` (\e -> return ["hello"]) >>= (map print)
00:53:53 <Cale> Something like  evaluate (foldl' seq () xs)
00:54:16 <jz87> so basically I need to determine if the type is a constructor
00:54:22 <jz87> and force evaluation of its arguments
00:54:22 <Cale> (or deepSeq, if you have that library, or you could use rnf, from Control.Parallel.Strategies)
00:54:50 <Cale> Basically, the lesson is that asynchronous exceptions are a bitch to catch, and you usually shouldn't bother trying.
00:55:27 <Cale> (Unless you *really* have no other way to detect the problem.)
00:55:33 <Cale> This is why people use Maybe instead.
00:55:52 <jz87> well if you don't want an errant thread to crash the whole program
00:55:52 <jsnx> jz87: so, after that long interlude, where are back where we started
00:56:15 <Cale> Hmm...
00:56:24 <jz87> you are telling me that I'm shit out of luck with haskell?
00:56:55 <jsnx> you mean, for writing multi-threaded programs?
00:57:00 <jz87> yes
00:57:04 <Cale> Uh, no, async exceptions should only kill the thread which evaluates them.
00:57:04 <jz87> erlang styled programs
00:57:07 <jz87> oh
00:57:10 <jz87> well in that case
00:57:22 <jz87> you can just do what erlang does
00:57:29 <jsnx> well, sort of
00:57:29 <jz87> well actually no
00:57:36 <jz87> you still need to catch the exception
00:57:43 <jsnx> well, no
00:57:47 <jz87> how can you tell if a thread has died?
00:57:58 <jsnx> that's the question we need to answer
00:58:08 <jsnx> because erlang does not catch exceptions, either
00:58:18 <jz87> if there is some way besides having the thread explicitly send a messge out
00:58:24 <jsnx> aye
00:58:29 <jsnx> i can't figure it out
00:58:31 <jz87> well when erlang processes die, they send out a message as their last act
00:58:37 <jz87> if you can do something similar in haskell
00:58:44 <jz87> that would solve the async exception problem
00:58:50 <jz87> just have a supervisor thread start another instance
00:58:53 <jz87> like erlang does
00:58:58 <jsnx> but it's good to know that multi-threaded haskell programs can survive the death of one of their threads
00:59:09 <jsnx> i always thought it would just kill the whole thing
00:59:23 <jz87> I should just try to write a library that does this in haskell and see how far I get
00:59:30 <jz87> I hate erlang syntax with passion
00:59:58 <jsnx> jz87: i like the idea, i really do
01:00:02 <jz87> I imagine gen_server would be so much sweeter in haskell
01:00:16 <jsnx> everything would be sweeter
01:00:31 <jz87> the protocols between the components would be documented by the type system
01:00:35 <flux> more sugar, or would it come with artificial sweetener?
01:00:46 <jz87> the erlang people have to write parse_transformers to tell them that they mistyped an atom
01:01:06 <jsnx> flux: agave nectar -- better for the glycemic index
01:01:15 <jsnx> jz87: lolz
01:01:25 <jsnx> that is why dynamic == bad
01:01:32 <jsnx> but, i digress...
01:01:33 <flux> don't they have some tool that reports some type errors
01:01:42 <flux> dializer orsomesuch?
01:01:49 <Cale> You can often approximate an Erlang style of concurrent programming without much of a framework, using Chans for communication.
01:02:11 <jz87> how lightweight are haskell threads?
01:02:13 <wy> haha. I found an interesting sentence in J Reynolds's paper: "Interference is not always undesirable; procedures that manipulate common global variables are widely used in programmingprogrammingand collections of such procedures are the essence
01:02:13 <wy> of "object-oriented" programming
01:02:25 <Cale> jz87: Very lightweight.
01:02:31 <jz87> ok, that's good
01:02:53 <jz87> it's not dynamic that is bad
01:02:58 <jz87> it's the lack of type inference that is
01:03:12 <jz87> I wouldn't mind dynamic if type inference were an option
01:03:22 <jz87> like HaXe
01:03:34 <dibblego> wy, it is interesting because it denotes an "essence of OOP"?
01:03:52 <wy> right
01:03:54 <jz87> lol
01:04:22 <jz87> well that's not how OOP was marketed
01:04:35 <jz87> OOP was supposed to improve data encapsulation and decrease coupling
01:05:03 <jz87> I increasingly find myself allergic to Java style state manipulation
01:05:08 <jz87> I've become paranoid about it
01:05:20 <jz87> I find it mentally taxing even to write code in scala
01:05:29 <jz87> I sprinkle my code with val
01:05:41 <jz87> and even hashtables I find is problematic
01:05:52 <jz87> btw, what is a good haskell alternative for hashtable
01:05:56 <Cale> Data.Map
01:06:05 <jz87> I need to dig up my functional data structures book
01:06:46 <jz87> you're just a treasuretrove of information cale
01:06:53 <jz87> they need to turn you into a lambda bot
01:06:58 <Cale> hehe :)
01:07:12 <jz87> this way I can query you for info even when you're not here
01:08:20 <Cale> Even if I'm not here, my machine is usually connected to IRC anyway. So you can send me a message, or use lambdabot to @tell me something.
01:11:58 <jz87> hmm, is there any constant time lookup hashmap?
01:12:43 <jz87> what about Data.HashTable
01:12:49 <Cale> There's Data.Hashtable, but don't use it. The performance is worse than Data.Map in all cases.
01:12:55 <jz87> oh
01:13:15 <Cale> Plus, it's restricted to IO
01:13:23 <johnnowak> Cale: why is the performance worse?
01:13:33 <Cale> johnnowak: I'm not completely sure.
01:13:47 <Cale> Probably bad choice of hash function.
01:13:55 <jz87> what does O(min(n,W))
01:13:57 <jz87> mean?
01:14:01 <jz87> what is W?
01:14:19 <Cale> in which document?
01:14:26 <jz87> Data.IntMap
01:14:42 <jz87> ah nvm
01:14:46 <jz87> it explains
01:14:49 <Cale> W is number of bits in an Int
01:15:09 <jz87> so essentially it's O(1)
01:15:13 <Cale> (The trees never get deeper than that)
01:15:15 <Cale> Right.
01:15:15 <jz87> for insertion
01:15:32 <jz87> hmm, so it seems that creating a custom hash function
01:15:38 <jz87> and using IntMa
01:15:39 <jz87> IntMap
01:15:49 <jz87> is the way to go for fast hashtables in haskell?
01:16:10 <Cale> I'd personally just use Data.Map until I ran into a problem.
01:16:14 <jz87> one of the applications I'm trying to write involve storing isbn numbers
01:16:21 <jz87> ok
01:16:31 <Cale> Data.Map has really very decent performance for most applications
01:16:41 <jz87> ok
01:16:53 <jz87> well an isbn is almost an integer
01:17:07 <jz87> the only exception is when it uses an x
01:17:10 <jz87> at the end
01:17:18 <Cale> Yeah, you might try IntMap. Eventually, that'll get merged into Data.Map as an automatic specialisation.
01:17:19 <jz87> basically the last digit of an isbn is in base 11
01:18:02 <Cale> You could delete it and just regenerate it later though ;)
01:18:10 <jz87> that's also true
01:18:17 <jz87> actually that's a really good idea
01:18:38 <oerjan> um Data.Map is parametrically polymorphic, can you specialize that?
01:18:52 <oerjan> er + Ord
01:19:16 <Cale> oerjan: Not with out using pragmas at the moment.
01:19:20 <Cale> without*
01:19:41 <oerjan> what i mean is, any code which expects a generic Map would break on an IntMap
01:20:03 <jz87> yeah
01:20:10 <Cale> I'm pretty sure you could play some tricks with RULES.
01:20:14 <jz87> RULES?
01:20:43 <Cale> GHC has a pragma which lets you specify rewrite rules to be used by the simplifier as part of a library.
01:20:55 <Cale> So you can essentially teach the optimiser new tricks.
01:21:37 <Cale> Data.ByteString uses this and it can beat (library-using) C code at some simple tasks.
01:22:00 <jz87> ah
01:22:08 <jz87> that's the thing that Andy Gills was talking about
01:22:25 <jz87> he has that library of rewrite rules
01:23:27 <oerjan> hm
01:24:02 <jz87> haskell could be a pretty fast language with a good library of these rules
01:25:35 <flux> it seems to me such a library would just be a big list of special cases, and if you don't know about them, you might accidentally walk outside the rules and get surprisingly bad performance
01:25:42 <Cale> Also, I'm not certain about this, but the new type families stuff might be able to handle specialising the structure for Integer maps as well.
01:25:53 <flux> of course there are good uses of such rules, such as the fusion techniques
01:26:07 <jz87> well I think the focus should be on correctness and clarity first
01:26:10 <jz87> and optimization last
01:26:22 <jz87> optimization should ideally be done by experienced programmers
01:26:52 <flux> no, optimization should ideally be done by the compiler :)
01:26:53 <jsnx> too bad i can not get these experienced programmers to come to my house
01:26:57 <Cale> If I recall correctly, they're also going to be used in the nested data parallelism stuff.
01:27:28 <jz87> well, having these rules is like having the expertise of experienced programmers in how to optimize code
01:27:36 <jz87> essentially, it's like a library of coding tricks
01:27:39 <jz87> refactorings
01:27:42 <jz87> in OOP speak
01:28:00 <jz87> that's what Jetbrains charge so much money for
01:28:05 <Cale> Yes, it's really fairly powerful. Of course, if you get one wrong, it results in horrible confusion :)
01:28:08 <flux> and there are infinite ways to express algorithms, yet such a library should be of limited size
01:28:21 <jz87> well, that's what idioms are for
01:28:23 <Cale> flux: usually APIs are finite though
01:28:30 <jz87> there are infinite ways, but in practice people use only a few patterns
01:28:39 <flux> cale, yes, but rewrite rules cannot see much through complexity, can they?
01:28:42 <jz87> if you look at real programs, people tend to stick to what they know
01:28:44 <Cale> So you can at least specify lots of simplifications for compositions of API calls.
01:28:50 <flux> how hard is it to break the list fusion rules?
01:29:00 <jz87> yeah, you can have api specific rewrite rules
01:29:16 <Cale> At present, it's not so hard, but there's a better library in the works.
01:29:19 <jz87> the point isn't to optimize everything
01:29:27 <Cale> (the stream fusion library)
01:29:31 <jz87> but to optimize commonly used patterns that lead to bad performance
01:29:45 <Cale> right
01:29:46 <jz87> that will get the language a long way toward being practical for real work
01:30:04 <Cale> It's already practical for a lot of real work.
01:30:08 <jsnx> if you can mark the patterns that won't work with the rules, you can make them fail at compile time
01:30:17 <jsnx> jz87: yeah, it seriously is
01:30:21 <Cale> The code generator has improved in leaps and bounds over the last few years.
01:30:30 <jz87> well, it doesn't help that a lot of haskell libraries break
01:30:32 <jz87> every other revision
01:30:41 <jz87> I've been trying to get HAppS to work forever
01:30:43 <jsnx> jz87: now if only i can convince my boss that an experience report would make us look cool to new hires...
01:30:49 <jz87> haha
01:30:53 <Cale> Well, yes, and some of us (e.g. me) would like to break even the Prelude ;)
01:31:18 <jsnx> jz87: well, HAppS is a special case
01:31:25 <jsnx> lots of other things do work well
01:31:28 <jz87> well if you write web applications
01:31:31 <Cale> But usually it's a pretty small part of maintenance cost.
01:31:46 <jz87> there aren't a huge number of options for haskell
01:31:52 <jsnx> jz87: that's true
01:32:03 <jsnx> jz87: there's always CGI :)
01:32:19 <jz87> and right now a lot of the really exciting stuff are happening on the web
01:32:25 <jsnx> jz87: i am concerned that HAppS is not going to deliver on its early promise
01:32:31 <jz87> web services are popping up left and right
01:32:41 <jsnx> the author basically told me that the scalability bit was out the window
01:32:44 <jz87> I really really like to run a EC2 cluster on haskell
01:32:45 <Cale> Interestingly, yhc seems to be working on the client side for Haskell.
01:32:53 <jz87> client side?
01:32:55 <jz87> you mean gui?
01:32:59 <Cale> They have a preliminary Haskell -> Javascript compiler.
01:33:00 <jz87> yeah, that's important too
01:33:03 <jz87> oh
01:33:04 <jsnx> jz87: that is totally out the window for HAppS!
01:33:11 <jz87> I was thinking more along the lines of HS -> Cocoa bindings
01:33:12 <jz87> lol
01:33:14 <jsnx> jz87: though the guy has not updated his site yet
01:33:27 <jz87> well HAppS is grea
01:33:29 <jz87> but it doesn't work
01:33:31 <Cale> Oh, those exist too.
01:33:35 <jz87> it's broken everytime I try to install it
01:33:39 <jsnx> he just puts it on a huge Sun box at Joyent
01:33:45 <Cale> http://hoc.sourceforge.net/
01:33:46 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
01:34:02 <jz87> that hasn't been maintained in forever
01:34:05 <jz87> has it?
01:34:12 <Cale> Oh, I'm not sure.
01:34:16 <jsnx> well, cocoa is for macs, anyways...
01:34:22 <jz87> heh, I run on a mac
01:34:27 <jsnx> lolz
01:34:31 <jz87> I've found programming on windows to be too hard
01:34:32 <Cale> I don't use a mac anymore, so I don't know.
01:34:40 <jz87> too many hassles
01:34:47 <Cale> Ubuntu is pretty nice :)
01:34:48 <jz87> everything run less well on windows
01:34:52 <jz87> well if you use linux yes
01:34:55 <jsnx> jz87: yes, i agree
01:34:56 <pejo> jsnx, sun machines aren't really that fast, so it must scale sideways in that case.
01:35:03 <Cale> jz87: Just uninstall windows, and put Ubuntu or something on there :)
01:35:06 <jsnx> pejo: no, they are *big* machines
01:35:14 <jz87> I thought HAppS had EC2 integration
01:35:16 <jsnx> pejo: it doesn't scale sideways
01:35:18 <jsnx> jz87: no
01:35:25 <jsnx> jz87: it says "coming soon"
01:35:29 <jz87> wasn't that an objective?
01:35:37 <jsnx> jz87: not anymore
01:35:38 <pejo> jsnx, so? 32 times a slow CPU is still .. lots of slow cpu's.
01:35:44 <jz87> lol
01:35:50 <jsnx> pejo: that is what he is doing
01:35:58 <jsnx> pejo: no horizontal scalability
01:36:12 <jz87> you mean HAppS?
01:36:12 <jsnx> pejo: just big machines with gigs and gigs of RAM
01:36:19 <jsnx> Alex Jacobson
01:36:24 <jz87> eh, we need horizontally scalable web framework
01:36:30 <jsnx> jz87: yes
01:36:32 <jz87> something you can put on a cheap EC2 instance for starters
01:36:36 <jz87> and then scale if it's a hit
01:36:57 <jsnx> jz87: what if we made some kind of, uhm, distributed RAM STM thing?
01:37:00 <jz87> what I like about the erlang programming workfow is that you write something that doesn't work
01:37:03 <jz87> but is testable
01:37:06 <jz87> and you put it up
01:37:08 <pejo> jsnx, it must parallelize fairly well over CPU's in that case though?
01:37:22 <jz87> and then you throw use cases at it
01:37:22 <jsnx> pejo: yeah, but that is Haskell's doing
01:37:27 <jz87> and fix the errors one by one
01:37:38 <jsnx> pejo: has nothing to do with HAppS qua HAppS
01:37:48 <jsnx> jz87: that sounds really dynamic to me
01:38:06 <jsnx> jz87: i've always preferred to start with a principled description of my program
01:38:10 <jsnx> and work from there
01:38:29 <jsnx> though, the designer idiot calls and changes things all the time
01:38:38 <jz87> well the problem with that is that sometimes you don't know what exactly is it you want
01:38:43 <jz87> you have a general idea
01:38:45 <jsnx> yeah, for real
01:38:51 <jz87> but you need to test it and see if it works the way you thought it would
01:38:57 <jz87> that's why you need fast iterations
01:39:01 <Cale> jz87: The classical static programming approach to that is just to design an EDSL for the problem domain.
01:39:03 <jz87> of test and change
01:39:18 <jz87> yeah, but that's a lot of up front work
01:39:22 <Cale> (usually in the form of a combinator library)
01:39:30 <jsnx> up front work == good
01:39:31 <jsnx> !
01:39:43 <jz87> low startup cost has been proven to be a key advantage
01:39:48 <jsnx> fast iterations are okay, too
01:39:57 <jsnx> jz87: and disadvantage
01:40:04 <jz87> you need the activation energy for new projects to be low
01:40:08 <jsnx> let us all remember twitter
01:40:11 <jz87> hehe
01:40:12 <jz87> well yes
01:40:16 <jsnx> and their scaling snafu
01:40:25 <jz87> but they're running ruby on rails
01:40:33 <jz87> not exactly known for performance
01:40:41 <jsnx> SQL was the problem, not rails
01:40:49 <jsnx> horizontal scaling of rails is easy
01:40:51 <jsnx> so they did that
01:40:54 <jz87> they should've just said screw the DB
01:40:58 <jz87> and use memcache
01:41:01 <jz87> and flat files
01:41:08 <jsnx> or LDAP
01:41:11 <jz87> for the kind of thing they're doing you totally don't need a relational DB
01:41:30 <Cale> Yeah, I don't really understand many web developers' insistence on sticking absolutely everything in a SQL database.
01:41:36 <jz87> twitter is basically a router
01:41:44 <jz87> they don't use SQL in routers
01:41:45 <jsnx> jz87: right -- and if they had done a little up front work, to bind to a new backing store or pick an appropriate one...
01:41:51 <Cale> It's not like most desktop applications use SQL databases.
01:41:55 <jz87> yeah
01:42:02 <jz87> in fact, for a lot of applications
01:42:07 <jsnx> Cale: yeah, but many do -- for example, SQLite
01:42:08 <jz87> a hashtable is far more appropriate
01:42:20 <jz87> well sqlite is basically a hashtable
01:43:03 <jsnx> jz87: right
01:43:17 <jz87> for websites like twitter you need a fast distributed hashtable
01:43:30 <jz87> which is basically what memcache is
01:44:53 <jz87> the workflow I'm envisioning
01:45:18 <jz87> I have a question Cale
01:45:27 <Cale> sure
01:45:36 <jz87> what is the current state of runtime loading/unloading in haskell
01:45:50 <jz87> I know dons had that hsplugins thing a while back
01:45:56 <Cale> It's not perfect, but it exists via hs-plugins.
01:46:10 <jz87> how hard would it be to write a function f::D -> E
01:46:12 <Cale> I recently updated hs-plugins to use the GHC API a bit.
01:46:13 <jz87> arrgh
01:46:20 <jz87> f :: D -> E
01:46:30 <jz87> where D is defined as data A = A
01:46:37 <jz87> and then hot swap it with
01:46:40 <jz87> data A = A | B
01:46:57 <jz87> and add an additional clause for f B = ...
01:47:04 <Cale> Impossible, I think.
01:47:17 <jsnx> well, you'd have to swap all the code that calls f, too
01:47:22 <Cale> If you're saying what I think it is that you're saying.
01:47:44 <Cale> Oh, if the data structure is local to the module that you're hot-swapping, then it would be possible.
01:48:02 <jz87> yes
01:48:10 <Cale> Basically, you have to maintain a consistent outward type interface though.
01:48:11 <jz87> the data structure would be local
01:48:16 <jz87> yes
01:48:30 <jz87> basically the idea is that you would design an outward interface
01:48:33 <jz87> that's fairly general
01:48:43 <jz87> and parse it into a specific internal interface
01:48:50 <jz87> and add bits of functionality at a time
01:48:58 <jz87> so externally you might take in a string
01:49:07 <jz87> but then you can parse it into specific type constructors
01:49:18 <jz87> and pass it to functions
01:49:25 <Cale> This is quite a bit like how lambdabot does it.
01:49:37 <jz87> but if you can hot swap modules
01:49:41 <jz87> (which is what erlang does)
01:49:46 <mux> 2008 will be the year of haskell!
01:49:49 <jz87> then you can add additional internal data type definitions
01:50:06 <jz87> and modified functions that can run correctly on more of the external input
01:50:15 <jz87> this gives you the same iterative development workflow of erlang
01:50:21 <jz87> but with the static typing of haskell
01:50:37 <jsnx> jz87: yeah, but the typing is not better than erlang's, in this case
01:50:40 <pejo> Cale, you going to keep on hacking hs-plugins?
01:50:43 <Cale> I really distrust the hot-swapping style of code development though.
01:50:58 <jsnx> jz87: since you are generifying the interface to String for intermodule communication
01:51:00 <jz87> well your external types can't be
01:51:07 <jz87> because you have to interface with external systems
01:51:16 <jz87> potentially non-haskell components
01:51:24 <jz87> you can't enforce haskell's types outside that
01:51:27 <pejo> jz87, as for the hot-swap of code - you need to disable cross module inlining and all that kind of stuff too for it. So performance might take a hit.
01:51:31 <Cale> pejo: I don't know. I actually feel somewhat unqualified for it. The recent hack that I did was entirely directed by the type system -- in fact, it possibly even deserves more of the credit than I do ;)
01:51:57 <jz87> Cale, why do you distrust hot swapping style of development?
01:52:05 <jz87> I think it's really great
01:52:11 <jz87> that's the way to live editing
01:52:18 <jz87> basically the smalltalk way
01:52:28 <jsnx> ph34r!
01:52:49 <jz87> small talk is great for experimenting and sketching ideas
01:52:51 <jsnx> the UNIX way: kick the process
01:53:03 <jz87> static types are great for managing large projects
01:53:05 <pejo> Cale, as for your concern about hot-swapping - "lots" of places would be happy to keep track of that stuff themselves through processes, like it's alread done today.
01:53:13 <Cale> Because you can end up with a program state in your debugger where things work, but which can't be reached from program startup.
01:53:30 <jsnx> jz87: yeah, but your method punts on static types in the large
01:54:03 <jz87> well for me, I mostly treat static typing as documentation
01:54:12 <jz87> not so much for enforcing code safety
01:54:36 <pejo> Oh, jz87 wants hot-swapping for "rapid" development, not uptime improvement for already deployed applications?
01:54:44 <jz87> yes
01:55:03 <jz87> basically I would like live editing capabilities
01:55:28 <Cale> jz87: Using hs-plugins for that is probably a really unweildy way to do things.
01:55:32 <jz87> essentially you are only ever swapping a small bit at a time
01:55:32 <pejo> Oh, disregard my comment about solving things through some manual process then, since the process overhead would slow it down compared to a non hotswap way.
01:56:09 <jsnx> jz87: a small bit?
01:56:18 <jz87> well a module
01:56:25 <pejo> Cale, shrug, one under qualified guy is lots better than no guy, especially if the guy is more qualified than he thinks. :-)
01:56:28 <jz87> a human being can usually only do one thing at a time
01:56:43 <Cale> pejo: this is true :)
01:57:01 <jsnx> jz87: if you are trying to take advantage of static typing while solving a tricky problem, you might end up with big modules
01:57:19 <Cale> pejo: Also, perhaps I can just let the type system do its work through me.
01:57:24 <jz87> Cale, why do you say that using hs-plugins for hot swapping would be unwieldy
01:57:40 <Cale> jz87: For hot swapping in development.
01:58:03 <Cale> For hot swapping where it's essential to keep your program running, it's okay.
01:58:25 <jz87> is hot swapping really slow or something?
01:59:25 <Cale> It's just a lot of extra work in designing interfaces, and loss of benefit in terms of the types you have to give things.
01:59:35 <jsnx> ultimately, i think of process control as an OS thing
01:59:44 <Cale> If you have a really strongly typed interface, then you lose flexibility.
01:59:50 <jsnx> there's all this talk of bringing concurrency into language design
02:00:03 <Cale> So you're making a trade-off there which is usually somewhat unhappy.
02:00:06 <jsnx> seems to prevent composition of parts made with different languages, though
02:00:22 <jz87> can't you have some sort of type directed serialization/derserializable library?
02:00:30 <jz87> that wraps your types in String
02:00:43 <jz87> to be transported across module boundaries?
02:00:49 <jz87> for development purposes?
02:01:07 <Cale> yeah, but by doing that, you're throwing away much of the usefulness of the type system.
02:01:07 <jsnx> this is sounding more and more like plain sockets and ASN.1
02:01:14 <jz87> the thing is you want to keep things flexible in development
02:01:27 <jz87> and gradually introduce constraints and strictness
02:01:34 <jz87> as you develop a better idea of what is it you're trying to build
02:02:00 <jz87> I guess what I want is to start with something like erlang, and gradually turn it into haskell
02:02:05 <jsnx> why isn't ASN.1 and a compiler for it good enough for what you want to do?
02:02:12 <jz87> what's ASN.1
02:02:16 <Cale> My approach to development is typically, "Sit and think about it for 3 weeks, then code for one week"
02:02:32 <jsnx> ASN.1 is the granddaddy of format defining languages
02:02:45 <jz87> the problem with that is some people like to solve problems interatively
02:02:48 <jz87> try this, doesn't work
02:02:51 <jz87> try that, doesn't work
02:02:56 <jz87> try X, ok, it works
02:03:11 <jz87> not, let's formulate a solution to the problem and then write it up
02:03:31 <jz87> ideas need to be tested
02:03:52 <jz87> making it cheaper and easier to test ideas increase the number of ideas that programmers are willing to test
02:03:56 <Cale> Well, you can still code up bits of things and test them.
02:04:02 <Cale> GHCi makes that easy enough.
02:04:39 <jsnx> ASN.1 allows you to say, "a person is made of a name, a birthday, an optional phone number..." and "a phone number is made of 10 chars" and "a char is a byte"
02:04:44 <jz87> well the problem wit hthat
02:04:46 <jz87> is program state
02:05:02 <jz87> usually you don't want to test the start state of the program
02:05:03 <Cale> This is Haskell :)
02:05:12 <jz87> but some state after some amount of user interaction
02:05:21 <jz87> if you have to restart the program you lose that program state
02:05:31 <jsnx> ANS.1 compilers and parsers are widely available, so you can specify a completely language independent interface, and then have tools to read and write it
02:05:33 <jz87> well even if it's haskell, you still need state in a lot of programs
02:05:40 <Cale> Usually you keep the state which is going into any part of the program to a minimum.
02:05:58 <Cale> also, usually you keep the UI separate from the model.
02:06:22 <Cale> (the UI is the part in IO)
02:06:44 <jsnx> erlang actually has rich support for ASN.1
02:06:50 <jz87> basically, for development purposes
02:07:03 <jz87> it would be great if components communicated in a generic format like string
02:07:22 <jz87> but have a tool remove the Bin->String and String->Bin conversions
02:07:26 <jz87> for deployment
02:07:33 <Cale> That's actually really annoying, because then you get a lot of things being accepted by the compiler which shouldn't be.
02:07:35 <jz87> and hookup strict type interfaces directly
02:07:42 <Cale> I like being told that I'm doing something dumb.
02:07:55 <jz87> well the thing is
02:08:03 <jz87> sometimes you know you're not implementing a correct program
02:08:11 <jz87> this is like the eventual consistency thing in databases
02:08:14 <Cale> It's *way* better to deal with compiler errors than to have a program which runs and does the wrong thing, and you have to figure out why.
02:08:26 <jz87> well no, let's say you have 5 uses cases
02:08:38 <jz87> 5 cases to implement for a function
02:08:48 <jz87> or an indetermininate number of cases
02:08:53 <jz87> you can only implement one at a time
02:08:57 <jz87> I like to implement one case
02:08:57 <jz87> test that
02:09:03 <jz87> and let it crash for the other cases
02:09:11 <Cale> You can do that :)
02:09:12 <jz87> then implement the second one, test that
02:09:21 <jz87> and so on
02:09:32 <jz87> but I would like to do this without having to restart the program all the time
02:09:44 <jz87> the compile/restart cycle is non-productive work
02:09:44 <Cale> meh, what's wrong with hitting :r ?
02:10:06 <jz87> well as I mentioned
02:10:08 <jz87> for pure functions
02:10:11 <jz87> this is fine
02:10:17 <jz87> but most programs aren't just pure functions
02:10:20 <jz87> you do need some state in there
02:10:32 <Cale> You should be passing the state in as a parameter.
02:10:40 <jz87> but even so
02:10:44 <jz87> it's lost when you crash
02:10:45 <Cale> Which means that you can simply plug in the same state over and over.
02:10:50 <Cale> No it's not.
02:10:54 <jsnx> Cale: yeah, but when you reload, GHCi nukes all those parameters
02:11:04 <Cale> jsnx: You're passing it explicitly.
02:11:13 <jz87> yes
02:11:17 <jz87> even if you pass state explicitly
02:11:22 <jz87> if the program crashes
02:11:26 <jz87> where does the state go?
02:11:31 <jz87> when you restart the program
02:11:33 <Cale> It hasn't gone anywhere?
02:11:38 <jsnx> Cale: all the let bindings are gone when you reload, is what i mean
02:11:56 <Cale> The state is a parameter to your function. Just plug it back in the same way you did.
02:11:57 <jz87> it's not that
02:12:02 <jz87> but you don't have that
02:12:10 <jsnx> jz87: well, you need to be putting it in your database or something
02:12:12 <jz87> it's not like I typed the state in through the console
02:12:23 <jz87> the state was built up through a sequence of user interactions
02:12:24 <Cale> You could even simply include the test state in your module.
02:12:31 <jz87> I don't want to have to repeat that sequence everytime
02:12:32 <Cale> So you call, like:
02:12:33 <jz87> I reload
02:12:36 <jsnx> jz87: i see what you are saying
02:12:44 <Cale> myFunction myTestState foo bar baz
02:12:50 <jz87> that's what's annoying about iterative development as it is right now
02:12:50 <Cale> and see what you get
02:13:31 <jsnx> jz87: you don't want to have state serializer/storage strategy worked out from the get-go
02:13:38 <jsnx> jz87: it's a lot of up front work
02:13:38 <Cale> jz87: If that's the case, you can usually simply apply Show to the state and write the result to a file.
02:14:16 <Cale> But it's not necessary to actually have the state passed around the program as strings.
02:14:35 <jz87> yes, but the program can crash at any point
02:14:58 <Cale> at any point?
02:14:58 <jz87> if you had to insert write . show everywhere
02:15:02 <jz87> that would be boiler plate
02:15:10 <jz87> well, asynchronous exceptions
02:15:11 <Cale> Not at any point.
02:15:54 <jz87> so for instance
02:16:00 <jz87> if I define a data type A = A | B
02:16:07 <jz87> and I write function f A = ...
02:16:19 <jz87> and I want to test that this works first before moving on to implement f B case
02:16:29 <jz87> how would I do this in haskell?
02:16:36 <Cale> Just write the f A = ...
02:16:39 <jz87> basically if B gets passed into f
02:16:48 <Cale> and ignore any compiler warnings you might get
02:16:49 <jz87> I want the program to just crash and print out an error message
02:16:58 <ZsoL> afaik that's what happens
02:17:01 <Cale> That's the default behaviour.
02:17:10 <ZsoL> you'll get a runtime exception
02:17:34 <jz87> does that crash the whole program?
02:17:37 <Cale> yep
02:17:39 <jz87> or just the thread it's executing in?
02:17:41 <Cale> Well, the thread.
02:18:00 <jz87> well why can't i just reload the module
02:18:09 <jz87> and run retry then?
02:18:14 <Cale> Why would you want to?
02:18:26 <jsnx> Cale: what would he do instead?
02:18:29 <Cale> It'll just crash again. Fix the problem.
02:18:37 <jz87> I mean fix the problem
02:18:43 <jz87> and hot code swap in the module
02:18:46 <jz87> and run retry
02:18:50 <Cale> Why not restart the program?
02:19:04 <jz87> well for one, the program might take a long time to get to that point
02:19:07 <Cale> Because of the bug, your program might be in an inaccessible state anyway.
02:19:12 <jz87> say he start of the program require a ton of initialization
02:19:38 <Cale> The function you're working on basically can't though.
02:19:45 <Cale> So pull that out and test it separately.
02:19:59 <jz87> the problem with that
02:20:04 <jz87> is in a lot of situations
02:20:09 <jz87> the test data you need to test the function
02:20:17 <jz87> is naturally generated by a lot of different processes
02:20:18 <Cale> You can't work out what parameters your function is called with?
02:20:23 <jz87> they could come from the network
02:20:27 <jz87> they could come from the user
02:20:28 <Cale> So?
02:20:38 <jz87> you want to test the function in the context of a live system
02:20:39 <jsnx> jz87: collect a few, and try them out
02:20:44 <Cale> That doesn't matter to the function
02:20:51 <jz87> not have to write a ton of code to mock up the rest of the system
02:20:55 <Cale> The function only cares about the values of its parameters. That's it.
02:20:58 <jsnx> jz87: unless you are coding with lots of side effects, it shouldn't matter
02:21:01 <jz87> it's a lot of work to have to mock up the rest of the system
02:21:12 <jz87> well, where would you get all those values from?
02:21:17 <jsnx> jz87: you don't need the rest of the system
02:21:20 <Cale> That's why we like referential transparency.
02:21:21 <jz87> you would have to mock them up in a test harness
02:21:27 <jz87> yes I understand what you're saying
02:21:30 <jz87> it's doable
02:21:35 <jz87> but it's a lot of work
02:21:39 <jsnx> yes and no
02:21:41 <Cale> Not usually.
02:21:47 <jsnx> it's different work
02:21:55 <jz87> let's say I want to test against amazon's web service
02:22:02 <Cale> Using a debugger is a lot of work.
02:22:04 <jz87> am I supposed to mock up amazon's web service?
02:22:07 <Cale> No.
02:22:25 <jsnx> jz87: just get some data from it in one run, and test a few times against that
02:22:31 <Cale> You're supposed to take the one output of that service which is causing trouble and plug it into the function you're working on.
02:23:52 <Cale> Depending on which function you're working on, it might not even be the entire output of the service, but just a small fragment of it.
02:24:19 <jz87> I like the idea of edit and continue
02:24:30 <Cale> You also usually don't have to be very imaginative to come up with reasonable test inputs for functions.
02:24:50 <jz87> basically, once it passes
02:25:01 <jz87> you don't have to do anything extra to continue running the system
02:25:32 <Cale> There's a problem with that though.
02:26:37 <Cale> If you run any code that ends up affecting the state of your program, and then remove that code from the system, replacing it with something else, you can end up with a state which is actually impossible to reach if the program were to be run from the beginning.
02:26:50 <jz87> yes
02:27:10 <jz87> I'm well aware of this, so this probably doesn't work in general
02:27:11 <Cale> Moreover, the program might only work by virtue of that inaccessible state.
02:27:31 <Cale> (and all your intermediate debugging)
02:27:58 <jz87> well one way is to just design your data structures so that invalid states are not representable
02:28:18 <lament> sounds difficult
02:28:33 <jsnx> jz87: why can't you have a bunch valid data combined in an invalid way?
02:28:58 <jz87> you could
02:29:05 <Philippa> either a) because the combinators threw up on the input or b) the type system stopped you
02:29:15 <jsnx> jz87: then it doesn't solve the problem
02:29:34 <jz87> but you can define your functions so that they throw an error on the invalid cases
02:29:50 <jz87> basically your functions are designed to work on specific cases of state
02:29:54 <Philippa> well yeah. So what you get is that it at least spews early
02:30:02 <Philippa> but it still vomits everywhere
02:30:30 <jsnx> the original problem was, how to prevent the program from getting into an invalid state, given that we are using code that doesn't work and not purging state each time
02:30:43 <jsnx> seems to me that you can not
02:30:56 <jz87> I think that this is something that seems like would be a problem in theory
02:31:02 <jz87> but won't come up much in practice
02:31:15 <jz87> like the worse case run time of ML type checking
02:31:17 <Philippa> but when it does come up in practice has the potential to completely shaft everything
02:31:18 <jsnx> famous last words
02:31:20 <jz87> in practice it's pretty fast
02:31:47 <jz87> well this isn't for building nuclear powerplant control software
02:32:07 <jz87> for building web applications, a 90% solution tomorrow is worth more than a 100% solution in a yera
02:32:15 <jsnx> yeah, they use BCPL and VAX for those!
02:32:38 <Philippa> for building web apps you still want to know that that 90% isn't going to back you into a corner
02:32:39 <jsnx> jz87: actually, that's true of everything
02:32:40 <Cale> jz87: The general mindset of Haskell programmers, you'll find to be the sort where we'd rather sit down and prove that our entire program is correct than to have to debug it interactively.
02:32:54 <jsnx> indeed
02:33:15 <jz87> this however is not a good way of dealing with uncertainty
02:33:18 <jsnx> and those of us that don't, are forced to learn more math
02:33:22 <jsnx>  :)
02:33:24 <Cale> Sure it is ;)
02:33:28 <jz87> interactive debugging is a learning process
02:33:38 <Philippa> so's proving
02:33:43 <Cale> If you can prove that your program does what it's supposed to, there's no uncertainty left.
02:33:56 <jz87> well usually the uncertainty doesn't come from program logic
02:33:59 <jz87> but external factors
02:34:00 <Cale> (unless there's a bug in your proof of course ;)
02:34:34 <Philippa> no, it comes from people hand-waving about what they can rely on in those external factors
02:34:56 <Philippa> and about what they're willing to engineer against and what's allowed to cause failure
02:35:46 <jz87> well, I find that it's more productive to get the most common cases working
02:35:57 <jz87> and not worry about what the program does on the other cases
02:35:59 <jz87> until they come up
02:36:16 <Philippa> yeah. Others find that a great way to get cracked
02:36:29 <Cale> jz87: That generally is a bad idea when writing Haskell programs. Write functions one at a time, and ensure that they're total.
02:36:32 <jz87> well it depends on the sort of applications you're building
02:36:46 <jsnx> jz87: that is basically the point of disagreement
02:36:55 <jz87> I find that static types are a good way of keep track of my ideas
02:37:06 <jz87> in terms of how data is floating around through the program
02:37:18 <jz87> but I don't find it particularly valuable for proving program correctness
02:37:29 <Cale> It saves lots of time with that actually.
02:37:31 <jz87> because for the sort of programs I write correctness is not very valuable
02:37:44 <Cale> That's a lie ;)
02:37:55 <jsnx> jz87: that is crazy
02:38:03 <Philippa> rather, because the sort of programs you write are poorly-specified?
02:38:09 <jz87> well yes
02:38:19 <jz87> they're poorly specified because I don't start with an idea of exactly what I want
02:38:22 <jz87> I start with a vague idea
02:38:29 <jz87> I tend to sketch
02:38:34 <jz87> that's why I started with lisp
02:38:44 <zx]treads> has this been implemented?
02:38:45 <zx]treads> http://citeseer.ist.psu.edu/198235.html
02:38:46 <lambdabot> Title: Lightweight Extensible Records for Haskell - Jones, Jones (ResearchIndex)
02:39:04 <jz87> but lisp is verbose
02:39:18 <jz87> and it's too easy to forget whether a function accepts a list or an atom
02:39:22 <jz87> or list of a specific format
02:39:25 <Philippa> there's more than one way to sketch
02:39:39 <Cale> zx]treads: I can't remember if that's the one which is/was in Hugs.
02:39:54 <jz87> well, how would you sketch if you had to write total functions?
02:40:08 <Philippa> by starting with skeletons rather than outlines
02:40:18 <jz87> what's a skeleton?
02:40:34 <jz87> like default implementation for functions?
02:40:45 <Philippa> solid bits of "core" functionality that everything else fleshes out around
02:40:52 <zx]treads> cale: i was playing yesterday with ML tuples and records, and found out that Haskell's records are a bit different that i had in mind
02:41:05 <zx]treads> than*
02:41:06 <Cale> zx]treads: Haskell's records are basically not records.
02:41:19 <Cale> zx]treads: They're algebraic datatypes with a little syntax sugar.
02:41:41 <jz87> I guess I don't like to keep an excessive amount of context in my mind
02:41:43 <zx]treads> cale: you're right, but why we call them records?
02:41:51 <jz87> I like having a program up and running quickly
02:41:54 <Cale> zx]treads: Well, it's called the record syntax.
02:41:56 <jz87> to test against
02:41:58 <Philippa> zx]treads: because they still have named fields
02:42:09 <jsnx> jz87: you could just forego context
02:42:15 <jsnx> jz87: that is kind of the point
02:42:23 <jz87> well
02:42:26 <jz87> here's the problem
02:42:36 <Philippa> yeah, it's amazing how long I go without writing a main sometimes
02:42:39 <jz87> I don't feel motivated to develop a particular function to perfection
02:42:48 <jz87> if I don't know that I actually need it
02:42:55 <jz87> I want to write 1 case of that function
02:43:02 <jz87> and test it for that one case in the context of the whole application
02:43:08 <Philippa> then you don't want to write that function in the first place
02:43:08 <jz87> it might turn out this function isn't what I need
02:43:12 <jsnx> jz87: well, different strokes for different folks
02:43:14 <Cale> zx]treads: http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf -- this is the proposal which I'd like to see implemented as far as semantics are concerned (but I don't like the syntax that the paper uses)
02:43:14 <lambdabot> http://tinyurl.com/392r4k
02:43:18 <Philippa> you want to write the thing it dispatches to in one case and assume that case holds
02:43:19 <jz87> but I don't know that until I've run it through the whole application
02:43:29 <jsnx> jz87: that's not true in general
02:43:39 <jsnx> jz87: usually, we have a big idea of parts of our app
02:43:46 <jsnx> we do a nice drawing or something
02:43:54 <jz87> yeah, I don't like doing that
02:43:58 <jz87> I prefer to specify my programs in code
02:44:04 <Philippa> the other thing with Haskell is that refactoring's so damn easy that it's not all that painful if you have to rearrange how the functionality's spread out
02:44:09 <jz87> it's executable specification
02:44:16 <jsnx> well, why use a statically typed, purely functional language then?
02:44:34 <Philippa> jsnx: because they actually make pretty neat compositional tools if you have the right approach
02:44:37 <jz87> it's not the static typing I want
02:44:40 <jz87> it's the type inference
02:44:55 <jz87> I like being able to ask the compiler about what types I'm using
02:45:03 <jz87> so I can remember to use the right types else where
02:45:16 <Philippa> you don't find being told when you've screwed up useful?
02:45:31 <jz87> I guess what I would find useful
02:45:42 <jz87> is being able to selectively told when I've screwed up
02:45:47 <jz87> because some screw ups are intentional
02:45:56 <jz87> so being told that I've screwed up in those cases is not useful
02:46:14 <Philippa> there really aren't that many of those in haskell
02:46:18 <jsnx> haskell really invites us to remember when we thought computing was a science -- or engineering discipline
02:46:23 <Philippa> there're cases where you want to fill in undefined as your value sometimes, sure
02:46:27 <jz87> sometimes I know a part of the program is wrong, but I might not care for that case
02:46:41 <Philippa> then you can comment the damn thing out, no?
02:46:41 <Cale> jz87: So comment it out?
02:46:42 <jsnx> jz87: and you don't fix it ever?
02:46:52 <jz87> I might fix it, if it becomes necessary
02:46:58 <jsnx> lolz
02:47:04 <jz87> I guess I take a lazy appraoch to programming
02:47:16 <jsnx> well, planning is even lazier
02:47:23 <jsnx> because you code less, and doodle more
02:47:24 <jz87> basically, if you try to execute theprogram
02:47:33 <jz87> basically here's how my idea of the ideal workflow would go
02:47:41 <jz87> haskell would interactively evaluate
02:47:50 <jz87> basically, consider the editor an extension of haskell
02:47:57 <jz87> and I would define a rough program outline
02:47:59 <Cale> Another thing about Haskell code is that the more you think about it beforehand, the less of it you end up having to write.
02:48:03 <jz87> and when haskell needs to evaluate an expression
02:48:06 <Philippa> jz87: I'm 99% sure you just want a chance to FITB if it ever evaluates an undefined...
02:48:16 <jz87> FITB?
02:48:20 <Philippa> Fill In The Blank
02:48:26 <jsnx> jz87: maybe you should ask what you can do for your haskell
02:48:30 <jz87> yeah
02:48:31 <jz87> exactly
02:48:35 <jz87> I would just say <blank>
02:48:38 <jz87> and when haskell gets there
02:48:43 <jz87> it prompts the programmer to writ that in
02:48:45 <zx]treads> cale: i'll look at it
02:48:51 <jz87> and then interactively compile and link that code in
02:48:53 <jz87> and keep going
02:49:11 <jsnx> do you use NetBeans or something like that?
02:49:13 <jz87> if there is some case you never get to in actual execution
02:49:21 <jz87> you just don't write those cases
02:49:23 <Philippa> so here's what's different: instead, you keep a trace of what data you fed it, do a recompile by hand and run back up to that point
02:49:47 <Philippa> some of us care about never vs rarely
02:50:11 <jz87> actually, I don't use netbeans
02:50:15 <jz87> I use eclipse for java
02:50:20 <jz87> although I'm not a huge fan of it
02:50:23 <jz87> and emacs for everything else
02:50:40 <jz87> basically, I would like an Amazon mechanical turk type of interface to programming
02:50:44 <Philippa> And there's rarely as in "can we just turn off the relevant bit of UI please?" and rarely as in "...but we can't stop it coming up when it does so we'd better not fail in too disgraceful a manner"
02:50:52 <jz87> the compiler calls the programmer as a subroutine
02:51:03 <Philippa> try Epigram
02:51:12 <Philippa> not for real work yet, but try it
02:51:22 <Philippa> it does exactly that, except it calls you at compile time
02:51:24 <jz87> what does it offer in addition to dependent types?
02:51:52 <Philippa> then again, so does an interactive theorem prover
02:52:01 <jz87> yes
02:52:03 <jz87> like coq
02:53:04 <Philippa> you can work with your main theorem being "it never fucks up really /badly/" and insist specific bits work right, too
02:53:57 <jz87> basically the plan first approach to programming is equivalent to strict evaluation
02:54:11 <Philippa> this isn't about plan first though
02:54:13 <jz87> you program all the potential execution paths first and then run it
02:54:16 <Philippa> jsnx seems to think it is, but it isn't
02:54:25 <jsnx> Philippa: well, no
02:54:36 <jsnx> Philippa: but you do think about your scope of work
02:55:02 <jsnx> Philippa: instead of just being like, well, i can has web server
02:55:15 <Cale> I suppose it's more about the fact that usually inside any large working program, there's a small working program.
02:55:21 <jz87> I like to strip things down to the bare minimum that will work
02:55:24 <jz87> for the cases I imagined
02:55:32 <jz87> and run it to see how it works
02:55:36 <jz87> and modify as necessary
02:55:36 <Cale> jz87: Try cutting things up in the other direction.
02:55:40 <jz87> basically evolve programs
02:55:42 <Philippa> and guess what? That still typechecks
02:55:54 <Cale> jz87: Don't handle a subset of the cases, but implement a subset of the functionality first.
02:56:07 <jsnx> jz87: that's really not the same thing as what you were describing before: a large system that doesn't work
02:56:11 <Philippa> or let that subset of cases correspond to a subtype
02:56:25 <Cale> sure :)
02:56:30 <jz87> well work in this case I should clarify
02:56:32 <jz87> by work, I mean it runs
02:56:39 <jz87> just not correctly on all cases
02:56:43 <Cale> That's not what we mean by work :)
02:56:44 <Cale> hehe
02:56:45 <jz87> it should work on the cases I care about
02:56:49 <jsnx> lolz
02:56:51 <jz87> or I've thought of
02:56:58 <jz87> it might not work on things I haven't thought of
02:57:05 <jz87> that's what I meant
02:57:06 <Cale> Why shouldn't it?
02:57:06 <jsnx> that approach is, i think, a basically bad one
02:57:14 <Philippa> whereas we'd say that there should be some defined set of inputs that you know it "works" on and you should know /how/ it fails on the rest
02:57:20 <jz87> why because otherwise I would have to think of all potential cases
02:57:23 <jz87> and that's too many things to think about
02:57:28 <jz87> the world is large and my brain is small
02:57:39 <Philippa> sounds like your brain's missing the tools to handle it
02:57:45 <jsnx> jz87: then partition the world into two parts
02:57:58 <jsnx> jz87: and simply fail gracefully on one of them
02:57:59 <Cale> jz87: When you pattern match a data structure in Haskell, there are only so many constructors to match against.
02:58:01 <jz87> well I like an open world assumption
02:58:09 <jz87> there are known knowns and unknown unknowns
02:58:12 <Cale> Data types are closed in Haskell.
02:58:25 <Cale> (Typeclasses are open)
02:58:44 <jz87> well by fail gracefully you mean throw an error?
02:58:47 <jsnx> jz87: i keep thinking, you want ruby
02:59:00 <jsnx> jz87: no, i mean return an error value
02:59:00 <Cale> So once you've defined a datatype, you don't have to worry about cases other than those which you've defined.
02:59:02 <jz87> well I've tried ruby, I dislike their lack of static typing
02:59:08 <Philippa> "fail gracefully" depends on the system in question
02:59:10 <jz87> actually, if I'm going to code in ruby, I might as well use lisp
02:59:19 <jsnx> jz87: or scheme
02:59:37 <jsnx> jz87: what do you actually like about haskell?
02:59:41 <jz87> the type inference
02:59:46 <jz87> the clean syntax
02:59:54 <jz87> and of course laziness
02:59:54 <jsnx> jz87: your approach doesn't seem to fit anything else
03:00:16 <jsnx> jz87: what you want has a price
03:00:25 <jsnx> jz87: get ready to pay!
03:00:34 <jz87> well type inferencing doesn't have to be bondage and discipline
03:00:50 <Philippa> well no, it can just be boring instead
03:00:51 <jz87> the compiler can simply compile code that doesn't type check and make a node of it
03:00:53 <jz87> note of it
03:01:06 <jsnx> jz87: that makes a lot of other things hard
03:01:08 <jz87> so if the program breaks the error messages can be meaningful
03:01:26 <jsnx> jz87: that sounds like c++ thought
03:01:32 <jsnx> s/thought/though/
03:01:38 <jz87> uh, C++ error messages are not meaningful
03:01:45 <jz87> they're like cryptic #$@$
03:01:46 <Philippa> meaningful like a type error that's even further from its origin than the worst H-M implementation'd give you?
03:01:55 <Cale> Basically, yes it does, because if the compiler can infer interesting types, then the usage of values of those types must be pretty strongly controlled.
03:02:19 <Philippa> yeah. Otherwise pretty quickly it just becomes x::"how the f**k should I know?"
03:02:33 <jz87> basically if you have strongly inferred type information
03:02:40 <Philippa> sorry, x::exists y.y
03:02:50 <jsnx> jz87: there must be some language out there that is close to what you want
03:02:54 <jz87> you can say, ok, so this runtime value has this value, which is outside the range of what it shuld've been
03:03:13 <jsnx> well, that would not happen with a type
03:03:24 <Cale> jz87: Types are compile time phenomena.
03:03:25 <jsnx> it could happen with a pattern match or guard
03:03:29 <jz87> well if you enforce types discipline at compile time yes
03:03:33 <oerjan> x::Maybe(exists y.y)
03:03:39 <jz87> but you have the option of just computing the types and not enforcing them
03:03:39 <Cale> jz87: Dynamic types aren't really types.
03:03:46 <jz87> basically, I treat types as documentation
03:03:47 <jz87> not laws
03:04:02 <Cale> Types are statements about the program which the compiler checks.
03:04:05 <jsnx> jz87: once again, i must ask -- what would you get out haskell, then?
03:04:06 <Philippa> this may be /why/ you can't figure out all your cases
03:04:29 <jsnx> the nice thing about haskell is it keeps track of all the laws, and all lawbreakers
03:04:38 <jsnx> and puts them in prison for you, even
03:04:42 <jz87> yes, but sometimes you need to break the laws temperarily
03:04:42 <Cale> That is, they are essentially theorems which the compiler proves.
03:04:49 <jsnx> jz87: no, no, no
03:04:57 <Philippa> (yeah, I know, IO's full of surprises - but that's another nice thing about having to keep it separate)
03:04:57 <jz87> it's like going into debt
03:05:02 <jsnx> jz87: you just need to write some new laws
03:05:09 <jsnx> jz87: credit is not illegal
03:05:13 <jz87> I know
03:05:15 <jsnx> jz87: there are laws for it
03:05:23 <jz87> but theoretically withdrawing more money than you have is
03:05:31 <jsnx> if your laws don't work, you need new ones
03:05:34 <jz87> but it's like a ATM that says I'll let you withdraw more than you have
03:05:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
03:05:41 <lambdabot> http://tinyurl.com/fmmvy
03:05:45 <jz87> I'll assume that you'll pay it back
03:05:56 <Cale> You can always just do that ^^
03:06:02 <jsnx> jz87: actually, that is covered by insurance
03:06:09 <Philippa> jz87: if you're getting into that situation you're probably making stupid assumptions about what laws you can rely on holding in the first place
03:06:26 <jsnx> jz87: it's well defined in your agreement with the bank
03:06:35 <jz87> I would like to make incremental assumptions
03:06:36 <jsnx> Philippa: i agree
03:06:38 <jz87> if that makes sense
03:06:48 <jz87> basically I would like to start with weak assumptions
03:06:49 <Philippa> right. Starting from "assume nothing"
03:06:53 <Sizur> jz87: i had an experience of haskell's type system debugging me. precisely because it was enforcing types
03:06:57 <jz87> and incrementally increase the constraints
03:07:21 <jsnx> jz87: that is different than just ignoring stuff
03:07:25 <Philippa> Right. So you start with a choice between id and undefined and then work out how to constrain your program's input enough that you can do anything with it at all...
03:07:31 <lament> haskell type system is, er, rather good at enforcing types, yeah.
03:07:53 <Philippa> take ruthless advantage of parametricity. Enforce it where possible
03:08:00 <Philippa> Feel free to say "I don't know and I don't want to!"
03:08:08 <jz87> hmm
03:08:15 <jz87> so how would you express a functon
03:08:16 <jsnx> lolz
03:08:24 <jz87> ok, here's a typical scenerio for me
03:08:28 <jz87> maybe you can shed some light
03:08:32 <jz87> say I want to define a function
03:08:41 <jz87> there are 2 possible cases
03:08:42 <jz87> A and B
03:08:59 <jz87> I know that A is more common so I only want to put in thetime to implement the A case
03:09:06 <jz87> say the program is a function chain
03:09:09 <jz87> f . g. h
03:09:13 <jz87> each of which has 2 cases
03:09:20 <jz87> I only want to write 1 case for each
03:09:24 <jz87> to start with
03:09:34 <jz87> and see if this is what I want
03:09:45 <jz87> and then implement the other cases as necessary later
03:09:49 <jsnx> jz87: then you will have runtime errors
03:09:51 <Philippa> I make sure that the type we're dealing with is equivalent to Either A B in some sense and build a chain on A for now
03:09:51 <notsmack> f A = ...;  f B = undefined
03:10:03 <Philippa> and shove a conversion in front of the chain that vomits on Bs
03:10:29 <Philippa> that way, when I later go back to add the other case I can also keep the old code and call it
03:10:41 <Sizur> i used f B = undefined approach plenty
03:10:49 <Sizur> while developing
03:11:38 <jz87> ok
03:11:42 <jsnx> i just use arrows like this: -> -> <- -> <- until it works somehow
03:11:52 <jz87> lol
03:12:03 <jsnx> then i make everything an Int
03:12:07 <jz87> well one of the other nice things about live editing systems is that you can examine intermediate data values
03:12:20 <jz87> sometimes it's just hard to think with too many abstractions
03:12:25 <jz87> that's why excel is popular
03:12:26 <jsnx> it is true that haskell debugging is somewhat rough
03:12:37 <jz87> you work through the problem with ok, here's how I would solve it on this case
03:12:47 <jz87> I write that up as a case implementation
03:12:58 <jz87> then you would run the program and hit a case that's not covered
03:13:20 <jz87> I wish it would just hit a breakpoint or something and prompt you for the solution while letting you inspect the data that's being passed in
03:13:28 <jz87> so you would work out how to solve it for that case and write it up
03:13:35 <jz87> instead of having to do this all on paper
03:13:38 <Philippa> GHCi can (almost) do that for you now
03:13:39 <jz87> ahead of time
03:13:40 <jsnx> jz87: that's asking a lot
03:13:58 <jsnx> GHCi unfortunately wipes all the lets when you reload, though
03:13:58 <jz87> oh?
03:14:05 <jz87> how would I do this with ghci?
03:14:10 <jz87> this I have to know
03:14:13 <Sizur> jz87: that sounds to me like OOP style
03:14:28 <Philippa> you'd get to the crash and inspect what's there using the debugger
03:14:30 <jz87> it's not OOP, this is how you program with excel
03:14:33 <jz87> and excel is a functional language
03:14:55 <jsnx> jz87: well, it is not a language
03:15:00 <Philippa> nah, the model it's closest to is dataflow
03:15:17 <jz87> well yes
03:15:29 <jz87> but oftentimes I think in dataflow mode when programming
03:15:30 <Philippa> "patch it while it's running" is definitely not FP
03:15:36 <jz87> it's easier to think about data sometimes
03:15:37 <Sizur> i like the fact that haskell let's you write concise functions that you can test by hand using ghci and can reuse them easily for any app
03:16:00 <Philippa> jz87: so let's talk dataflow. What did I make explicit about it in my approach to your hypothetical?
03:16:13 <jz87> well let me try it in ghci
03:16:28 <jsnx> jz87: you need   :e
03:16:34 <jz87> :e?
03:16:36 <jsnx> to edit stuff
03:16:40 <Philippa> you'll find you have to make the edit in the text editor and re-run. But if you're working on pure code that's not much loss
03:17:56 <jz87> what does :e add over not having it though?
03:18:11 <jsnx> jz87: nothing, never mind -- you are not ready yet
03:18:17 <Sizur> it comforts unix junkies
03:18:21 <jsnx> jz87: don't try it, it's not interesting
03:20:19 <Philippa> jz87: did you understand how my approach was to use the type system to push the uncertainty to the top of the program?
03:21:18 <jz87> you mean using undefiend?
03:21:39 <Philippa> <Philippa> I make sure that the type we're dealing with is equivalent to Either A B in some sense and build a chain on A for now
03:21:52 <Philippa> so yeah, I get one undefined branch, but it's in front of the call chain
03:22:06 <jz87> yes
03:22:13 <jz87> yeah that's what I'm doing
03:22:20 <jz87> right now
03:22:25 <jz87> I'm trying out the approach you suggested
03:22:35 <jz87> I like to try things before I buy them
03:22:45 <jz87> ok
03:22:50 <jz87> so say I now call the undefined branch
03:23:05 <jz87> how can I get the debugger to break
03:23:10 <jz87> and tell me what's being passed in
03:23:26 <Philippa> RTFM?
03:23:33 <jz87> huh?
03:23:36 <Philippa> :break <undefined-position> would be a starting point
03:23:57 <notsmack> @go haskell hacking debugger
03:23:58 <jz87> is there a way to do this in emacs?
03:23:59 <lambdabot> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14
03:23:59 <lambdabot> Title: Haskell hacking
03:24:19 <Philippa> except I'm fairly sure it does that by default
03:24:25 <Philippa> damned if I know, I don't use emacs
03:24:40 <jz87> oh
03:24:53 <jz87> what do you use to write haskell btw
03:25:08 <jsnx> ed is the standard text editor
03:25:09 <Sizur> > let f x = undefined in f 5
03:25:12 <lambdabot>  Undefined
03:25:19 <ivanm> jz87: what are you wanting to do in emacs? stop it?
03:25:22 <ivanm> C-c C-c
03:25:56 <jz87> well mark a line for breakpoint
03:26:02 <Philippa> I use whatever text editor comes to hand, but I'm mostly a windows user and I don't have the time to learn a completely different set of UI conventions
03:26:15 <ivanm> jz87: *shrug* don't know
03:26:42 <Philippa> give me syntax highlighting, some basic project management and a reasonable UI (by windows power user standards) under windows and I'm happy
03:26:52 <jz87> ah
03:26:54 * jsnx shudders
03:26:57 <jz87> I'm spoiled by lisp
03:27:04 <jsnx> eh?
03:27:11 <jz87> I measure all IDEs by lisp's standards
03:27:18 <Philippa> understandable
03:27:27 <Cale> All I care about is that the editor does syntax highlighting and can convert tabs to spaces.
03:27:29 <Philippa> there're tools I'd like to have, they just don't necessarily exist
03:27:37 <jsnx> i use VIM and GHCi
03:27:44 <jz87> lisp has some sweet tools
03:28:06 <jsnx> jz87: yeah
03:28:13 <Philippa> I don't know that what I want exists for lisp either
03:28:16 <jsnx> VMS was sweet, too
03:28:23 <jz87> I think I got the taste for interactive debugging while hacking lisp
03:29:12 <Philippa> what do the available refactoring tools give you in the way of history? Will they let you keep 'before' and 'after' versions of code and a pile of transformations going between the two?
03:29:35 <jz87> for lisp?
03:29:52 <Philippa> yeah. Or Smalltalk, for that matter
03:29:56 <jz87> I don't know
03:30:03 <jz87> I have never had to use refactoring tools for lisp
03:30:14 <jz87> refactoring lisp code is pretty easy
03:30:17 <Philippa> really what I have in mind's more useful in a purer language...
03:30:32 <jz87> since lisp style promotes very thin functoins much like haskell
03:30:38 <jz87> not a lot to refactor
03:30:49 <Philippa> sometimes you want to rearrange something from something readable into something fast instead though
03:31:00 <jz87> yes, that's what RULES is for
03:31:27 <jz87> they're basically user defined code transformations/refactorings
03:31:33 <jz87> that the compiler will automatically apply to your code
03:31:36 <jz87> when it matches
03:31:46 <Philippa> yeah. Which is great when you can trust something to be done automatically
03:32:10 <Philippa> only there's a difference between knowing the rewriting and knowing when to apply it
03:32:20 <jz87> well in the lisp case you would describe your problem and write macros
03:32:28 <jz87> to translate it into actual code
03:32:35 <jz87> and you rerewrite the macros for speed
03:32:57 <Philippa> yeah. What's macro debugging like in the systems you've used?
03:33:03 <jz87> not great
03:33:06 <jz87> not in CL
03:33:08 <jz87> which is what I mostly use
03:33:16 <Philippa> so not up to what I have in mind either
03:33:19 <jz87> PLT scheme have much nicer macro debuggin facilities
03:33:29 <jz87> you can step through macro expansions
03:33:40 <jz87> and they even color code different levels of name bindings
03:33:46 <jz87> so you don't confuse them
03:33:54 <jsnx> jz87: how much does it cost?
03:33:56 <jz87> but scheme lacks decent libraries
03:33:59 <jz87> PLT? it's free
03:34:04 <jsnx> oh, nifty
03:34:05 <Philippa> mmm. But what you /really/ want is help in seeing where things came from in the source...
03:34:19 <jz87> you mean the error
03:34:37 <jz87> the problem with macros is that there's no 1-1 correspondence between 1 line of macro and 1 line of actual executed code
03:34:47 <jz87> since the actual code that's executed is generated by the macro
03:35:03 <jz87> so it's hard to pinpoint where that line actually came from
03:35:07 <Philippa> don't make assumptions about what I'm looking for
03:35:17 <Philippa> I'm not necessarily /debugging/ here
03:35:21 <jz87> oh
03:35:25 <jz87> what are you looking for?
03:35:36 <Philippa> more than just correctness
03:36:26 <Sizur> i'm looking for a computer that can compute The Ultimate Question
03:36:33 <jsnx> 42
03:36:36 <Philippa> suppose I'm trying to transform a bunch of code into some particular form that's amenable to a nifty bunch of optimisations or is otherwise known to work well...
03:36:38 <jsnx> oh, wait
03:36:39 <Sizur> that's answer :P
03:36:56 <Philippa> Sizur: you're standing on it
03:37:10 <Sizur> what's the question?
03:37:15 <jsnx> love
03:37:25 <Philippa> ...suppose I'm finding knotty bits of code that don't want to behave as well as I want
03:37:26 <jz87> ok
03:37:32 <Sizur> :D
03:37:36 <jsnx> no, wait
03:37:39 <Sizur> love? 42!
03:37:40 <Philippa> this is exactly the sort of thing that happens if you're doing fusion work, btw
03:38:09 <jsnx> i know a food i can imagine but have never tasted...
03:38:15 <jsnx> ...what is it?
03:38:49 <jsnx> Sizur: earlier, we were talking about concurrency
03:39:09 <jsnx> Sizur: and i was saying, let's just forget about making it a language feature
03:39:16 <jsnx> use sockets and ASN.1
03:39:26 <jsnx> and live with it
03:39:35 <jz87> the problem with this is that it's too much work
03:39:40 <Sizur> jsnx: but i like erlang :P
03:39:59 <Sizur> by far not as much as i love haskell
03:39:59 <jsnx> jz87: you didn't even know what ASN.1 was until I told you
03:40:07 <jz87> we were actually discussing why we don't like erlang earlier
03:40:12 <jz87> yes I didn't know what it was
03:40:15 <jz87> but then I looked it up
03:40:18 <jz87> and it looks like a lot of work
03:40:25 <jsnx> jz87: yeah, it'a formal language
03:40:55 <jsnx> but it offers type safety between languages
03:41:14 <jz87> eh, supposedly SOAP does that too
03:41:16 <jsnx> and that's the particular problem i wanted to address
03:41:34 <jsnx> well, SOAP is unfortunately not a data format
03:41:45 <jsnx> it defines function calls and so forth
03:41:56 <jz87> that's essentially a data format
03:41:59 <jz87> it's a service contract
03:42:13 <jsnx> ASN.1 deliberately punts on functions -- it's more specific, and more compact
03:42:26 <jz87> wait, you can't pass functiosn with ASN?
03:42:31 <jsnx> right
03:42:35 <jz87> that would totally not work
03:42:40 <jsnx> don't pass functions between languages
03:42:43 <Philippa> jz87: that's not a data format, it's a codata format
03:42:45 <jz87> well ok
03:42:50 <Sizur> WSDL does define data being used by SOAP service
03:42:51 <jz87> yeah
03:43:03 <jsnx> however, XML == bad
03:43:06 <jz87> hehe
03:43:14 <jz87> XML = verbose S-expr
03:43:17 <jsnx> whereas ASN.1 is actually quite efficient
03:44:06 <jsnx> we see what the problem is with erlang
03:44:14 <Sizur> i agree about that. but i've used eXist's XQueries, they do give you power AND flexibility plus verbosity :P
03:44:19 <jsnx> they put all their effort into this great runtime
03:44:30 <Cin> are Handles threadsafe?
03:44:33 <jz87> but the language is ugly as hell
03:44:43 <jz87> maybe they should just implement a new language on top of the runtime
03:44:54 <jz87> and call it erlang 2 or something
03:45:03 <Sizur> twerlang
03:45:04 <jsnx> well, i think they should have just made it a system service
03:45:13 <jsnx> something other languages could use
03:45:27 <jsnx> because they obviously were not in it for making a cool language
03:45:44 <jz87> well, they could've just said, we're making this cool VM and runtime
03:45:49 <jz87> you guys write the languages
03:46:04 <jz87> like what the LLVM guys are doing
03:46:10 <jz87> or the Parrot guys
03:46:38 <Sizur> you can always define your own language and compile it to erlang using haskell
03:46:38 <jsnx> yeah, but the runtime likely does not support a lot of things
03:47:29 <jsnx> also, relatively few languages have targeted any of those VMs
03:47:53 <jsnx> whereas a service based on, say, pipes and big RAM caches, would be usable by even old languages
03:48:03 <jsnx> even bourne shell
03:48:28 <jsnx> anyways, i'm a bearded UNIX guy -- i think like that
03:48:35 <jsnx> time to go to bed in my land
03:49:08 <jz87> what would the service do though?
03:49:34 <Sizur> accept commands just like a VM does
03:49:58 <jz87> well, what you're saying is basically a repl interface
03:50:02 <jz87> to the VM
03:50:27 <jz87> allow other languages to talk to the VM and start processes and do stuff like that
03:53:58 <qebab> say I want to make a fraction datatype, so I write data Frac = Frac Integer Integer, I derive Show and Eq, but upon initialising a Frac, I want to divide both the numerator and denominator by their gcd, and I want to make sure that they get the right sign. Is there any way I can say data Frac = Frac Integer Integer --use this function to build it?
03:54:49 <qebab> as in, Frac 2 4 should be reduced automatically to Frac 1 2, Frac (-1) (-3) should be Frac 1 3 and so on
03:55:32 <Sizur> Data.Ratio
03:55:54 <qebab> Sizur: I'm writing it as an exercise to get a better understanding of the type system
03:56:15 <qebab> oh, did you mean to point me at the source for it?
03:56:53 <Sizur> no, i thought you needed to use fractions. what's the question?
03:57:29 <qebab> how I can do things with the input for a constructor, so to say
03:58:29 <Sizur> mkFrac :: Integer -> Integer -> Frac
03:58:49 <qebab> so I do have to write a function for it, I can't do it in the constructor?
03:59:14 <Sizur> constructor is only for constructing, nothing else, otherwise you'd not be able to pattern match against it
03:59:21 <qebab> okay, thanks
03:59:27 <qebab> yeah that makes sense
03:59:44 <Sizur> or you can perform the calculations later when some operator is used on Frac
04:00:18 <qebab> that's not a bad idea actually, why didn't I think about that /o\
04:07:25 <Sizur> @users
04:07:26 <lambdabot> Maximum users seen in #haskell: 434, currently: 351 (80.9%), active: 7 (2.0%)
04:08:49 <DuClare> how does it count the active users?
04:09:25 <DuClare> [/g 13
04:09:30 <qebab> it probably remembers how many people that said something the last n minutes
04:10:27 <ertai> @hoogle CChar
04:10:27 <lambdabot> Foreign.C.Types.CChar :: data CChar
04:10:28 <lambdabot> Foreign.C.String.castCharToCChar :: Char -> CChar
04:10:28 <lambdabot> Foreign.C.String.castCCharToChar :: CChar -> Char
04:11:09 <DuClare> is there a tutorial on the web you could suggest for a newcomer?
04:11:51 <Sizur> http://en.wikibooks.org/wiki/Haskell
04:11:51 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
04:12:55 <Sizur> keep an eye for http://www.realworldhaskell.org
04:12:56 <lambdabot> Title: Real World Haskell
04:13:48 <qebab> cool
04:14:08 <qebab> is that intended to be somewhat like Practical Common Lisp?
04:14:21 <Sizur> i'd guess so
04:14:46 <Sizur> their beta chapters looked real good
04:14:56 <qebab> cool
04:25:06 <RayNbow> hmm, anyone around by any chance whose combinatorial skills aren't rusty? :p
04:25:27 <qebab> mine are very, very rusty
04:25:39 <RayNbow> mine are too :)
04:27:47 <DuClare> mine aren't
04:29:15 * RayNbow is trying to figure out how many possible ways you can select 4 edges from a cycle of n vertices, in such a way that the 4 selected edges are not adjacent...
04:29:26 <DuClare> ... because I lack them altogether.
04:29:59 <RayNbow> lucky you... because discrete maths = scary, you don't want to know anything about it ;)
04:30:06 <DuClare> na
04:30:09 <DuClare> I want to learn all of it
04:32:02 <zx]treads> raynbow: adjacent edges is edges that share a common vertex?
04:32:18 <RayNbow> yeah
04:32:34 <bart416> I'd help but I seem to remember how I always failed on that so I doubt I'll be a lot of help
04:33:32 <Botje> RayNbow: for the first edge, you have a choice of N-1 edges. for the second, you can choose from N-3 edges, then N-5 and N-7
04:33:43 <opqdonut> RayNbow: just investigate the different distances between the chosen edges
04:33:59 <opqdonut> presuming the cycle is simple of course
04:34:33 <opqdonut> Botje: that doesn't quite work
04:34:48 <opqdonut> in the case that the edges "banned" by the choices overlap
04:35:08 <Botje> hmm
04:35:27 <Botje> I was thinking it was too easy
04:35:57 <RayNbow> the problem is that you quite easily overcount edges
04:36:39 <RayNbow> opqdonut: what exactly do you mean by investigating the different distances?
04:37:47 <RayNbow> the only available information is that there are n vertices in a cycle (no further information is given)
04:38:07 <b_jonas> argh
04:38:08 <opqdonut> RayNbow: well take for example choosing 2 edges from a cycle with 10 edges
04:38:13 <b_jonas> n vertices on a cycle
04:38:19 <b_jonas> I don't want to hear things like that
04:38:28 <opqdonut> you can have the distances (along the cycle) be (1,9), (2,8), and so on
04:38:35 <opqdonut> gah, not 1, that's banned
04:38:37 <b_jonas> reminds me to my thesis I have ot write
04:38:43 <opqdonut> (2,8), (3,7) and so on
04:39:09 <opqdonut> you can think of these numbers as the lengths of the "arcs" that the edges split the cycle into
04:50:22 --- mode: irc.freenode.net set +o ChanServ
05:06:27 <mxc> @hoogle Error
05:06:28 <lambdabot> System.IO.Error :: module
05:06:28 <lambdabot> Foreign.Marshal.Error :: module
05:06:28 <lambdabot> Foreign.C.Error :: module
05:12:15 <Pseudonym> @localtime Pseudonym
05:12:16 <lambdabot> Local time for Pseudonym is Tue Jan  1 00:12:16 2008
05:13:07 <Pseudonym> Happy new Gregorian year, for those for whom this event has happened.
05:23:45 <qebab> am I the only one who can 't access project euler for some reason?
05:24:51 <johnnowak> nope, it's hosed
05:25:55 <RayNbow> opqdonut, I didn't quite get your idea, but I think I have found an alternative solution
05:26:06 <opqdonut> pray tell?
05:26:39 <RayNbow> if you use S for selected and U for unselected, then you can encode possible selections as a string:
05:26:51 <RayNbow> SUUSUUSUUS... for example
05:27:41 <RayNbow> then you can rewrite the original problem as a distribution problem:
05:28:08 <RayNbow> SU_SU_SU_SU_
05:28:13 <RayNbow> and: U_SU_SU_SU_S
05:28:26 <RayNbow> where _ are bins in which 0 or more Us have to be placed
05:30:55 <RayNbow> opqdonut: do you think this approach will work or did I make a mistake?
05:33:03 <opqdonut> yeah, that should work
05:33:10 <zx]treads> is it true that haskell doesn't play well with graph theory?
05:33:49 <byorgey> opqdonut, RayNbow: what problem are you discussing, OOC?
05:33:55 <sieni> zx]treads: what is that supposed to mean?
05:34:16 <zx]treads> sieni: i mean that i find it hard to implement graph algorithms with haskell
05:34:17 <RayNbow> byorgey: selecting 4 non-adjacent edges from a cycle of n vertices
05:34:29 <RayNbow> (the number of possible ways to do so)
05:34:37 <zx]treads> sieni: cause all the graph algorithms are imperative styled
05:34:44 <byorgey> RayNbow: ah, I see
05:35:51 <opqdonut> zx]treads: they
05:36:02 <opqdonut> 're mostly folds over sets of vertices or edges
05:36:16 <opqdonut> or iterative refinements of such sets
05:36:20 <mattam> You should be able to rephrase them functionnaly... that's what people did for the ocamlgraph package for example.
05:36:22 <opqdonut> both of which are pretty easy to express in haskell
05:36:55 <zx]treads> maybe i didn't tried hard enough
05:37:11 <zx]treads> all my haskell graph impl were too imperative
05:37:12 <mattam> You have to go for the big folds though :)
05:37:19 <zx]treads> disgusting, so i deleted them
05:37:29 <zx]treads> :D
05:37:48 <mattam> With serious accumulators.
05:38:11 <RayNbow> byorgey: it isn't a simple problem (well, in hindsight it is :p)... I wasted like 3 sheets of paper trying to figure it out :p
05:38:13 <idnar> zippers!
05:38:58 <mattam> One thing I didn't manage to do while working on graphs in ocaml is to find a good set of composable combinators. I wonder how higher-order you have to get to find these.
05:41:58 <Andrew__> hey guys, I  need help with one function I'm working on
05:42:29 <andrikkos> can someone help me?:)
05:43:19 <andrikkos> I have to define a function stringToInt :: String -> Int
05:43:30 <andrikkos> for example stringToInt "0" would give 0
05:43:42 <andrikkos> and stringToInt "96118" would give 96118
05:43:50 <andrikkos> assuming that our strings are non negative integers
05:44:15 <andrikkos> I know that for a single digit character u can convert it with ord  'character' - ord '0'
05:44:22 <opqdonut> use digitToInt
05:44:30 <Botje> ?src transpose
05:44:30 <lambdabot> transpose []             = []
05:44:30 <lambdabot> transpose ([]   : xss)   = transpose xss
05:44:30 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:44:36 <opqdonut> > digitToInt '9'
05:44:38 <lambdabot>  9
05:44:39 <Botje> andrikkos: read ?
05:44:43 <opqdonut> :t digitToInt
05:44:44 <lambdabot> Char -> Int
05:44:47 <Botje> > read "96118"
05:44:48 <lambdabot>  96118
05:44:51 <opqdonut> Botje: nah, it's probably his homework or something
05:45:13 <b_jonas> wait
05:45:17 <b_jonas> that defaults why?
05:45:34 <Botje> magic? :)
05:45:37 <Botje> > read "a book"
05:45:38 <lambdabot>  Exception: Prelude.read: no parse
05:45:39 <opqdonut> b_jonas: lambdabot magic iirc
05:45:49 <b_jonas> or ghc magic
05:45:51 <b_jonas> anyway,
05:45:58 <opqdonut> well doesn't work in ghci
05:46:03 <b_jonas> > read "96118" :: Int
05:46:03 <lambdabot>  96118
05:46:13 <FunctorSalad> hmm, is this "minimal complete definition" automatically inferred?
05:46:32 <andrikkos> erm this isnt exactly what I'm looking for
05:46:54 <b_jonas> andrikkos: clarify then?
05:47:04 <andrikkos> if u do -> map (digitToInt) "96118" u will get [9,6,1,1,8]
05:47:11 <andrikkos> i wanna get   --- 96118
05:47:38 <andrikkos> stringToInt "96118" would give 96118
05:47:42 <opqdonut> andrikkos: well [9,6,1,1,8] is just one fold away from 96118
05:47:58 <desegnis> andrikkos: Consider to include the sequence [1, 10, 100, ... ]
05:48:23 <opqdonut> that's another way, a bit nonstandard tho
05:48:24 <andrikkos> fold away from? could u be more specific?
05:48:27 <desegnis> (which is informal notation, you can use  iterate  to define that sequence)
05:48:53 <desegnis> andrikkos: fold describes an algorithm technique.
05:49:40 <FunctorSalad> say in the definition of Eq, http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#Eq, does the compiler automatically figure out that implementing either of == or /= will define the other?
05:49:41 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/yqjxlq
05:49:50 <b_jonas> well,
05:50:20 <b_jonas> let { stringToInt :: String -> Int; stringToInt = read; } in stringToInt "96118"
05:50:28 <b_jonas> > let { stringToInt :: String -> Int; stringToInt = read; } in stringToInt "96118"
05:50:29 <lambdabot>  96118
05:50:44 <andrikkos> well I'm not only looking for that number.
05:50:46 <andrikkos> it could be any number
05:50:53 <andrikkos> that's why it should be  a function
05:50:55 <b_jonas> > let { stringToInt :: String -> Int; stringToInt = read; } in stringToInt "425"
05:50:56 <lambdabot>  425
05:51:03 <b_jonas> stringToInt is a function there
05:51:16 <b_jonas> it's a function of type String -> Int
05:51:17 <andrikkos> i know, but what if it's a list of characters?
05:51:24 <andrikkos> for example (x:xs)
05:51:33 <qebab> a String is a list of Char
05:51:34 <andrikkos> (assuming that our list is always digits)
05:51:44 <qebab> String = [Char]
05:52:01 <andrikkos> yes yes
05:52:31 <desegnis> FunctorSalad: It will use the default declarations iff there is no declaration in the instance. So if you implement either of (==), (/=), it will work, if you implement none of them, then both are practically undefined (but the compiler will not try and check)
05:52:41 <andrikkos> How would you generalise that function? for example given any string(which contains only integers)
05:52:57 <b_jonas> generalise in what way?
05:53:11 <andrikkos> as in accepting any string comprising of integers
05:53:11 <b_jonas> do you mean you want to read, like, "6 42 192 37" to a list of integers?
05:53:13 <b_jonas> or what?
05:53:20 <andrikkos> no
05:53:40 <andrikkos> stringToInt :: String -> Int
05:53:44 <andrikkos> the string here could be any number!
05:53:51 <andrikkos> so generalising it
05:54:00 <andrikkos> stringToInt (x:xs) = ....
05:54:06 <desegnis> andrikkos: You cannot generalise from "any".
05:54:27 <FunctorSalad> desegnis: is this done at compile-time or run-time? in the latter case, do you mean I can get a runtime error that I didn't implement enough things?
05:54:42 <b_jonas> I think the function as I defined it works for any integer that fits in an Int
05:54:56 <andrikkos> sobasically when you type stringToInt "any string comprising of numbers" should give <the number>
05:55:13 <qebab> andrikkos: the function b_jonas wrote 5 minutes ago does just that...
05:55:55 <desegnis> FunctorSalad: At compile time (if we think of the same this), and yea, in the case of (==) and (/=) for example, you will get an infinite loop at runtime due to one being defined through the other
05:56:16 <andrikkos> ah yea sorry id dint see that
05:56:31 <andrikkos> ermm....isn't read a I/O function though?
05:56:45 <desegnis> FunctorSalad: The author of a class should include documentation what is the minimum needed for an instance declaration
05:57:16 <andrikkos> is there any other way of doing it though? for example, if you consider that each element of the list of characetrs can be converted into an integer with <ord char - ord '0' >
05:57:35 <desegnis> andrikkos: Do you know how to use ghci?
05:57:47 <FunctorSalad> desegnis: hmm, ok. so I can only get away with instantiating Eq and defining neither because there is a default implementation, but that happens to be non-terminating.
05:57:57 <andrikkos> desegnis: : i'm not sure
05:58:03 <andrikkos> desegnis: i think so not
05:58:04 <desegnis> FunctorSalad, right
05:58:07 <FunctorSalad> (but the default implementation is complete type-wise)
05:58:47 <FunctorSalad> ok, termination cannot be checked at compile-time; these could be legitimate co-recursive functions...
05:59:32 <desegnis> andrikkos: You should use ghci (or hugs, for that matter), so you can try out things instead of asking any detail here. For example, in ghci, type ":type read" and you'll notice what type has read.
05:59:45 <desegnis> FunctorSalad, correct
06:00:05 <mattam> it could be checked.
06:00:46 <andrikkos> i have hugs
06:00:54 <FunctorSalad> @karma+ desegnis
06:00:54 <lambdabot> desegnis's karma raised to 2.
06:01:21 <FunctorSalad> mattam: well, in this simple case it could, but if one of them had a termination condition...
06:06:38 <b_jonas> > let { s2i :: String -> Int; s2i = (Data.List.foldl1' (\x y -> 10*x+y) . map (\x -> fromEnum x - fromEnum '0')); } in s2i "4205"
06:06:40 <lambdabot>  4205
06:07:18 <b_jonas> can someone tell what modules are imported unqualified in lambdabot's > prompt?
06:08:47 <desegnis> ohm btw, FunctorSalad, I don't think they would have to be co-recursive. I'm not sure what corecursive means, namely, but they could be plain mutually recursive functions with, of course, a termination condition
06:10:06 <mattam> FunctorSalad: yeah, sure, not in general.
06:11:13 <FunctorSalad> desegnis: I thought corecusive=mutually recursive, but I could be misremembering
06:11:25 <shachaf> @version -- b_jonas: That should have the list.
06:11:25 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
06:11:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:11:34 <shachaf> b_jonas: See L.hs or RunPlugs.hs, I think.
06:31:13 <FunctorSalad> could someone point me to some interesting haskell exercises?
06:33:20 <EvilTerran> project euler lends itself to haskell well
06:33:39 <therp> http://haskell.org/haskellwiki/99_Haskell_exercises
06:33:44 <earthy> that's hard. it strogly depends on what you consider interesting
06:33:53 <therp> not sure whether you consider that interesting, FunctorSalad
06:33:54 <earthy> +n
06:35:08 <FunctorSalad> therp: hmm, these seemed to generic and list-heavy to me (had enough of that with lisp ;)) I was thinking of something that uses the fun new haskell features (the type system, Monads, etc.)
06:35:56 <FunctorSalad> wouldn't mind some real-worldish thing as long as it uses these
06:36:32 <therp> functorsalad: yes, I can understand that.. maybe we need some kind of mini-ICFP programming challenge every month, one that's really interesting. "write your own 100 line mini-compiler", or "implement foo in the type system" :)
06:37:47 <FunctorSalad> EvilTerran: yeah that would be an option
06:39:52 <b_jonas> shachaf: thanks
06:39:56 <Saizan> "write a typechecker in the type system"
06:40:19 <opqdonut> :D
06:40:28 <olsner> cat :P
06:40:55 <olsner> if haskell output is acceptible
06:41:15 <b_jonas> therp: I liked the "perl quiz of the week" series while it lasted
06:41:22 <b_jonas> but then Dominus ceased to do it
06:41:36 <b_jonas> most of them were language-independent, not really perl specific
06:42:15 <b_jonas> FunctorSalad: if you want interesting exercises, you could solve some of them
06:43:01 <b_jonas> the address is http://perl.plover.com/qotw/#archives
06:43:02 <lambdabot> Title: Perl Quiz of the Week
06:44:29 <desegnis> I also recall a page on the wiki about Haskell solutions for Ruby Quiz programs
06:44:37 <desegnis> s/programs/problems/
06:45:48 <b_jonas> you mean the ruby quiz on the ruby-talk list?
06:46:19 <b_jonas> "write your own 100-line mini-compiler"
06:46:33 <b_jonas> what counts as a compiler? I might have already done taht
06:47:25 <Saizan> sources ---> executable
06:48:13 <desegnis> b_jonas, I guess so
06:49:05 <glen_quagmire> would docstring stuff be added to haskell in the future?  to see the documentation from interpreter
06:49:45 <glen_quagmire> like, how would I find what fromIntegral does? general coercion from integral types  doesn't ring a ell for me
06:50:05 <Saizan> :t fromIntegral
06:50:05 <glen_quagmire> Num is super class of Integral it seems
06:50:08 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:50:32 <Saizan> you can convert an arbitrary Integral to an arbitrary Num
06:50:49 <Saizan> > fromIntegral (1::Int) :: Double
06:50:50 <lambdabot>  1.0
06:51:06 <glen_quagmire> yah but what's Integral? integer-like type?
06:51:16 <FunctorSalad> @src fromIntegral
06:51:16 <lambdabot> fromIntegral = fromInteger . toInteger
06:51:16 <Saizan> ?instances Integral
06:51:17 <int-e> @instances Integral
06:51:17 <lambdabot> Int, Integer
06:51:17 <lambdabot> Int, Integer
06:51:41 <Saizan> ?src Integral
06:51:41 <lambdabot> class  (Real a, Enum a) => Integral a  where
06:51:41 <lambdabot>     quot, rem, div, mod :: a -> a -> a
06:51:41 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
06:51:41 <lambdabot>     toInteger           :: a -> Integer
06:51:42 * glen_quagmire should read up on `instances` keyword
06:51:57 <Saizan> instances is only a lambdabot command
06:51:57 * glen_quagmire and `class` keyword
06:51:58 <int-e> glen_quagmire: it's a lambdabot command
06:52:17 <Saizan> however yes, you should read something on typeclasses
06:52:48 <FunctorSalad> if only I could manage to build lambdabot ;)
06:53:08 <mux> it's quite easy to build lambdabot
06:53:09 <desegnis> glen_quagmire: For written-out documentation, the best we have is the Haddock docs that ship with ghc. (Hoogle for searching, lambdabot's @doc for a URL to a specific module's HTML)
06:53:13 <bart416> FunctorSalad irc is a really simple protocol
06:53:52 <bart416> only hard thing related to irc is communication between two irc servers and SSL (what isn't that hard with the correct libraries)
06:53:59 <FunctorSalad> mux: have been installing dependencies for hours (and figuring out how to do that), now there is another error. given up
06:54:27 <mux> FunctorSalad: if you're not too bored by it already, send this error to hpaste, I'm sure people would be able to help you
06:54:42 <Saizan> ?version
06:54:42 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
06:54:42 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:54:57 <b_jonas> bart416: agreed, it is simple, http://www.faqs.org/rfcs/rfc2810.html thru rfc2813 documents it mostly, and there are some extensions
06:54:58 <lambdabot> Title: RFC 2810 (rfc2810) - Internet Relay Chat: Architecture
06:55:47 <bart416> I slapped up a simple irc bot in php in a couple of minutes based on xchat's raw connection log a couple of years ago
06:55:51 <hpaste>  FunctorSalad pasted "lambdabot build error" at http://hpaste.org/4731
06:55:54 <bart416> well wasn't xchat actually
06:56:02 <bart416> forgot what client I used back then
06:56:25 <mux> FunctorSalad: did you run the 'build' shell script?
06:56:36 <FunctorSalad> mux: yes
06:57:39 <mux> well looks like you're somehow missing the LICENSE file
06:57:48 <mux> maybe you don't have a complete checkout?
06:58:32 <FunctorSalad> yes. I will checkout again... can I just overwrite the dir?
06:58:55 <mux> I suppose so, but it's probably even cleaner to start from scratch, just in case
06:59:21 <shachaf> Huh. Seeing type variables longer than 1 character is so odd... :-)
07:00:14 <FunctorSalad> hmm, darcs starts from scratch in a new dir on its own accord ;)
07:01:53 <glen_quagmire> what is @  ?
07:02:02 <glen_quagmire> resizeScene s@(Size width height) = do
07:02:23 <idnar> it's a pattern match
07:02:29 <glen_quagmire> thanks
07:02:34 <idnar> the value is bound to s, but there's also a pattern match against Size width height
07:02:59 <idnar> so s will be bound to the Size, and width and height will be bound to the "components" of the Size
07:03:00 <Sizur> does anybody here know anything about the plural forms of gettext?
07:09:55 <roconnor> gettexts?
07:10:23 <olsner> does cabal-install work nowadays?
07:11:13 <Sizur> http://en.wikipedia.org/wiki/Gettext
07:11:13 <lambdabot> Title: gettext - Wikipedia, the free encyclopedia
07:11:37 <olsner> Setup.lhs: cabal-install.cabal:24: Invalid syntax (no colon after field name)
07:12:06 <Saizan> olsner: you need a newer cabal
07:12:53 <olsner> found a very fitting quote from the readme here: "Kind of ironic we need cabal install to make it easier to build cabal install."
07:16:24 <olsner> I should upgrade to 6.8.2 sometime soon.. wonder when darwinports will catch up
07:16:42 <Saizan> you can update Cabal separately
07:17:32 <olsner> yeah, but I wouldn't have had to, had I already had ghc 6.8.2
07:19:50 <Saizan> you would :)
07:20:31 <Saizan> oh, maybe with 6.8.2 no
07:21:30 <FunctorSalad> olsner, re the readme: that's what I thought too (without reading the readme though) when cabal-install wanted me to install HTTP and a yet newer cabal
07:21:35 <FunctorSalad> :)
07:22:02 <FunctorSalad> maybe cabal-install should be more obviously advertised (if it is stable yet, haven't worked with it yet)
07:22:39 <olsner> two dependencies isn't too bad, but perhaps there should be a cabal-install-bootstrap shell script for wgetting, configuring, building and installing the latest cabal-install and its dependencies
07:23:32 <Saizan> i think a binary release should do
07:24:27 <olsner> cabal install lambdabot yields "cabal: user error (Unresolved dependencies: fps >=0.7)"
07:25:04 <Saizan> does lambdabot builds directly with cabal? i thought there were some shell scripts
07:26:38 <olsner> the original plan was to use cabal-install for lambdabot's dependencies and then build lambdabot from darcs, but I thought I'd try to see if it could install lambdabot for me now that I got cabal-install set up
07:27:11 <FunctorSalad> I think you need the newer lambdabot that doesn't ask for fps, since fps is now included in base, which yields a duplication error if you have fps installed (you see why I said hours :))
07:27:34 <olsner> lambdabot seems to be "just building" now
07:30:29 <Sizur> @hoogle try
07:30:30 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
07:30:30 <lambdabot> System.IO.Error.try :: IO a -> IO (Either IOError a)
07:30:30 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
07:30:38 <FunctorSalad> hmm, still crashes on "*** Exception: LICENSE: copyFile: does not exist (No such file or directory)"
07:30:52 <olsner> I'm now stuck in the same place
07:30:59 <FunctorSalad> :)
07:33:49 * FunctorSalad hopes the supermarkets don't close early today :o
07:33:50 <Sizur> what does parsec's try return when in fails?
07:34:47 <Saizan> Sizur: it fails, like pzero
07:34:50 <mux> try is not about exception handling
07:35:13 <Sizur> i know. i'm parsing an optional value
07:35:15 <Saizan> try is to not consume input in failure
07:35:22 <Saizan> *on
07:35:27 <Sizur> but i need it to be default on failure
07:35:50 <Saizan> try parseVale <|> return defaultValue
07:36:02 <Sizur> oh yeah, thanks
07:38:21 <mux> :t option
07:38:23 <lambdabot> Not in scope: `option'
07:38:38 <mux> option :: a -> GenParser tok st a -> GenParser tok st a
07:39:12 <mux> so try (option defaultValue parser)
07:39:41 <Sizur> thanks
07:43:23 <FunctorSalad> hmm, Either is exactly a coproduct disregarding _|_, isn't it?
07:43:45 <FunctorSalad> and either is the morphism part of the coproduct bifunctor
07:44:30 <roconnor> @seen conal
07:44:30 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
07:45:40 <Saizan> ?type either
07:45:41 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:46:12 <mercury^> !seen mercury^
07:46:15 <mercury^> err
07:46:18 <mercury^> @seen mercury^
07:46:18 <lambdabot> You are in #haskell-blah and #haskell. I last heard you speak just now.
07:46:24 <mercury^> :)
07:46:33 <Saizan> FunctorSalad: shouldn't the result be in Either as well?
07:46:39 <b_jonas> @type curry
07:46:40 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:46:43 <b_jonas> @type uncurry
07:46:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:47:46 <Saizan> ?type \f g -> either (Left . f) (Right . g) -- maybe this?
07:47:46 <lambdabot> forall a b a1 b1. (a -> a1) -> (b1 -> b) -> Either a b1 -> Either a1 b
07:49:47 <FunctorSalad> Saizan: oh, right. then it is something different... it is the natural isomorphism from Mor(a coproduct b, c) to Mor(a times b, c times c)
07:50:05 <FunctorSalad> (in other words, it implements the universal property of the coproduct)
07:50:15 * FunctorSalad needs to think more clearly :)
07:50:33 <Saizan> yup
07:50:37 <farabi> hello
07:50:39 <FunctorSalad> (in fact, it is the natural iso in the other direction)
07:51:02 <Saizan> ?type \f g -> (f . fst) *** (g . snd)
07:51:03 <lambdabot> forall c a b c1 a1 b1. (a -> c) -> (b1 -> c1) -> ((a, b), (a1, b1)) -> (c, c1)
07:51:32 <FunctorSalad> is that *** the target tupling?
07:51:35 <Sizur> isomorphism goes both ways, right? monomorphism maybe
07:51:47 <FunctorSalad> it should be an iso
07:51:49 <Saizan> ?type \f g -> (f . fst) &&& (g . snd) -- i always confuse them
07:51:50 <lambdabot> forall c c1 a b. (a -> c) -> (b -> c1) -> (a, b) -> (c, c1)
07:52:23 <Saizan> ?type (***)
07:52:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:52:32 <Saizan> ah this is already the map :)
07:52:50 <Sizur> is there an easy way to parse a quoted string, together with escapes? hope one can use 'read' in parsec
07:52:54 <FunctorSalad> ?type \f g -> ((f :: a->c) . fst) &&& ((g :: b->c) . snd)
07:52:54 <lambdabot>     Inferred type is less polymorphic than expected
07:52:55 <lambdabot>       Quantified type variable `c' is mentioned in the environment:
07:52:55 <lambdabot>         f :: a -> c (bound at <interactive>:1:1)
07:53:05 <FunctorSalad> the codomains must be equal
07:53:19 <FunctorSalad> Saizan: yeah but on another level *head explodes*
07:54:10 <Saizan> FunctorSalad: in the product the codomains can be different, the domains must be equal
07:54:31 <FunctorSalad> actually I'm not sure what we are trying to define right now ;)
07:54:37 <Saizan> yeah :D
07:54:46 <FunctorSalad> ?type ***
07:54:46 <lambdabot> parse error on input `***'
07:54:58 <Saizan> well after having defined the map of coproduct i was defining the one on product
07:55:07 <allbery_b> :t (***)
07:55:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:56:06 <FunctorSalad> Saizan: ah yes, what you defined after I said "an iso" is the morphism part of the product functor, I think
07:56:33 <FunctorSalad> :t (&&&) -- thanks allbery_b
07:56:34 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:56:47 <Saizan> FunctorSalad: yes, which is a specialization of (***) to the (->) arrow
07:57:39 <FunctorSalad> ah right, that &&& is the target tupling
07:57:59 <FunctorSalad> what is the source tupling operator?
07:58:05 <FunctorSalad> :t (|||)
07:58:06 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:58:15 <roconnor> :t (>>>)
07:58:16 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
07:58:18 <FunctorSalad> good naming :)
07:58:35 <FunctorSalad> roconnor: that seems to be composition
07:58:49 <roconnor> The types are out of date
07:59:04 <roconnor> @hoogle (>>>)
07:59:05 <lambdabot> Did you mean: (>>>)
07:59:05 <lambdabot> Prelude.undefined :: a
07:59:05 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
07:59:11 <roconnor> @hoogle >>>
07:59:12 <lambdabot> Control.Category.(>>>) :: Category cat => cat a b -> cat b c -> cat a c
08:08:07 <Sizur> :t liftM read
08:08:08 <lambdabot> forall a (m :: * -> *). (Read a, Monad m) => m String -> m a
08:14:07 <glen_quagmire> :t (_|_)
08:14:08 <lambdabot> parse error on input `|'
08:14:21 <glen_quagmire> Divergence occurs when a value needed by the pattern contains an error (_|_).
08:14:41 <glen_quagmire> is _|_ error symbol for haskell?
08:15:03 <bos> no.
08:15:22 <bos> it's the notation used for bottom, but it's not a haskell symbol.
08:15:32 <Saizan> where bottom = undefined
08:15:40 <Sizur> :t let bot = bot in bot
08:15:41 <lambdabot> forall t. t
08:15:45 <glen_quagmire> it's math stuff?
08:16:01 <Saizan> glen_quagmire: yes, the symbols comes from lattice theory
08:16:18 <bos> glen_quagmire: more or less.  it means "this program doesn't terminate usefully".  it eiter crashes or loops infinitely.
08:17:01 <glen_quagmire> oh . i only know up arrow means it goes infinite loop
08:17:06 <glen_quagmire> in turing machine
08:18:00 <Sizur> @hoogle parseFromFile
08:18:01 <lambdabot> Text.ParserCombinators.Parsec.Prim.parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)
08:18:10 <Sizur> does it read in utf8?
08:18:51 <bos> no.
08:19:05 <Sizur> just bytes
08:19:09 <bos> yes.
08:20:00 <Sizur> can read break if i feed it with a utf8 string?
08:20:26 <Sizur> utf8 string represented as a bytestring
08:21:12 <bos> afaik, it will just do something useless, like turn bytes > 127 into unicode code points > 127
08:25:50 <Sizur> ok, how do you parse a utf8 file then?
08:28:05 <olsner> FunctorSalad: did you get lambdabot installing? I found that commenting the license-file line out of lambdabot.cabal solved the copyFile exception thing
08:29:34 <FunctorSalad> olsner: sounds good, will try
08:30:02 <olsner> so I now have a working lambdabot and also got GHCi on Acid working (lambdabot-in-ghci)
08:31:19 <FunctorSalad> I'm sure the acronym goa is pure coincidence.
08:31:30 <bos> Sizur: there are a few libraries on hackage that will take byte input and treat it as utf-8. you can then feed the string to parsec.
08:32:12 <Sizur> bos: and then 'char' will work fine?
08:32:22 <bos> Sizur: yep.
08:32:26 <Sizur> yeah, because it simply uses a (==)
08:34:28 <glen_quagmire> :t threadDelay
08:34:30 <lambdabot> Not in scope: `threadDelay'
08:34:39 <ndm> @seen Igloo
08:34:40 <lambdabot> Igloo is in #ghc, #darcs and #haskell. I don't know when Igloo last spoke.
08:34:45 <oerjan> :t Control.Concurrent.threadDelay
08:34:46 <lambdabot> Int -> IO ()
08:35:21 <oerjan> FunctorSalad: goa?
08:42:28 <FunctorSalad> oerjan: http://en.wikipedia.org/wiki/Goa
08:42:28 <lambdabot> Title: Goa - Wikipedia, the free encyclopedia
08:43:06 <oerjan> um, and how is that a coincidence?
08:43:54 <oerjan> or rather, how is that coincidence of any interest?
08:44:39 <jfredett> its also an acronym for the "Gun owners of America"
08:44:48 <jfredett> and "Generic Open Architecture
08:44:49 <jfredett> "
08:45:00 <jfredett> its a kind of antelope
08:45:06 <ndm> GHC on acid
08:45:07 <jfredett> and surface to air missle system
08:45:35 <sieni> well, if goa is the name of one of the most known targets for hippie travellers seeking psychedelic experience and also an acronym for "ghc on acid", then I think it is almost as coincidential as lsd and unix both coming from berkeley
08:45:35 * Saizan always thought it referred to goa trance
08:45:41 <oerjan> ndm: um that was what this started with
08:45:54 <jfredett> sieni: that make sense
08:46:03 <oerjan> sieni: hm, ok that makes some sense
08:46:04 * ndm joins late
08:46:07 <jfredett> india => guru => hippie => LSD ~= Acid
08:46:17 <FunctorSalad> as per sieni
08:46:22 <jfredett> kindof obscure, though
08:47:22 <sieni> well, if the originators of goa trance have never taken acid, then I'm the prince of persia and also simultaneously the queen of the whole british commonwealth
08:47:28 <Saizan> goa trance -> goa party -> LSD ~= Acid, shorter!
08:47:35 <jfredett> true
08:48:30 <FunctorSalad> though "ghc on acid" is already clear, no need for an innuendo in the acronym
08:48:40 <jfredett> true that
08:48:49 <FunctorSalad> :)
08:49:54 <jfredett> though- I think being "on Acid" has traditionally implied a more negative effect, since you're stuck in some kind of dream world, compare with "on Steroids" which implies that something is stronger, as per the normal effects of steroids in humans..
08:50:06 <FunctorSalad> sieni: btw, what is this about lsd coming from berkeley. hoffmann wasn't in berkely, was it?
08:50:07 <jfredett> then again, maybe they wanted to get away from the image of ball shrinkage
08:50:13 <FunctorSalad> that period should be a ?
08:50:23 <sieni> FunctorSalad: there were big labs there in the 60's
08:50:24 <glen_quagmire> in ghci, :load OpenGLHelloWorld.hs     then invoking main  creates an opengl window but when I close it, the ghci quits too
08:50:38 <sieni> FunctorSalad: read Tom Wolfe's "Electric Kool-Aid Acid Test"
08:51:12 <glen_quagmire> how can I test gui applications from ghci?  when I close the gui window, i don't want ghci to quit
08:51:23 <sieni> FunctorSalad: you'll learn some interesting stuff about one great american author, Ken Kesey, better known as the author of "One Flew Over the Cuckoo's Nest"
08:51:24 <FunctorSalad> jfredett: "on steroids" would be physical strength. "on acid" implies consciousness "expansion", which is more close to what it does ;)
08:51:30 <jfredett> ahh
08:52:34 <FunctorSalad> jfredett: psychedelics may decrease performance on low-level task but I think it improves stuff like associative thinking
08:52:40 <FunctorSalad> *they
08:52:48 <Saizan> glen_quagmire: does it close with an error?
08:53:04 <FunctorSalad> *tasks
08:53:42 <glen_quagmire> Saizan: nope. after I close, no message printed and ghci is exited too.   echo $?  returns 0 from the shell
08:53:44 <jfredett> FunctorSalad: have there been studies to that effect?
08:54:07 <FunctorSalad> jfredett: http://www.maps.org/news-letters/v07n1/07110bag.html
08:54:07 <lambdabot> Title: MAPS - Volume 7 Number 1 Winter 1996-97 - Psilocybin's effects on cognition
08:54:36 <glen_quagmire> wanna see my code?
08:54:40 <jfredett> i love asking that question, and actually getting an answer
08:54:41 <jfredett> :)
08:55:57 <jfredett> rephrase, getting _satisfying_ answers
08:56:01 <Saizan> glen_quagmire: i've never used OpenGl but i've read that using graphics toolkits from ghci usually needs some special handling
08:56:19 <loupgaroublond> it certainly boosts the unquantifiable 'creativity' at the expense of quantifiable humant properties
08:56:40 <loupgaroublond> it's almost logically impossible to get a clear scientific answer when that's the premise you're going for
08:56:54 <hpaste>  glen_quagmire pasted "nehe tutorial lesson01  " at http://hpaste.org/4732
08:57:02 <FunctorSalad> jfredett: though to be honest, on psilocybin I'd probably be dazzled in amazement about the concept of a programming language rather than actually getting programming work done ;)
08:57:05 <sieni> FunctorSalad: I think that the differences in performance caused by various substances are mostly observable only if you do something you don't know how to do very well i.e. requiring ad-hoc thinking, random pondering, trial-and-error and such
08:57:16 <glen_quagmire> Saizan: oh i see
08:57:23 <jfredett> FunctorSalad: thats always been my impression to
08:57:45 <sieni> I can juggle 5 balls rather well after considerable amount of alcohol
08:57:49 <jfredett> it may superficially "feel" like you're more enlightened
08:58:13 <loupgaroublond> sieni: i speak perfect swedish after a considerable amount of alcohol ;)
08:58:27 <allbery_b> graphics toolkits tend to use ExitProcess from somewhere deep inside their event code instead of returning from whatever initiates the event loop
08:58:27 <FunctorSalad> jfredett: that was not really what I meant. I meant true amazement because you think about the all the implications you always took for granted (that were filtered out)
08:58:37 <sieni> loupgaroublond: that doesn't count!
08:58:38 <jfredett> but in general it's not that you are actually more creative or enlightened, but rather that you're more aware that you're capable of cool things
08:58:39 <allbery_b> er, exitProcess
08:58:43 <Saizan> glen_quagmire: try running 'forkOS main'
08:59:05 <sieni> FunctorSalad: when you've seen them once, they seize to amaze you again
08:59:08 <FunctorSalad> sieni: that's what I'd think too
08:59:14 <glen_quagmire> :i forkOS
08:59:21 <allbery_b> (arguably ghci should somehow hook that...)
08:59:26 <glen_quagmire> ?hoogle forkOS
08:59:27 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
09:00:02 <glen_quagmire> Saizan: still quits
09:00:06 <loupgaroublond> i've seen some  friends put out some very crazy work thouh, while on different substances
09:00:09 <jfredett> FunctorSalad: thats what I was (attempting) to get at
09:00:18 <jfredett> its an interesting effect, for certain
09:00:36 <loupgaroublond> but every account i've heard and read, everyone points out that for volume and quality, they need to be close to sober, or cafinated
09:00:53 <Saizan> glen_quagmire: are you using exitProcess or similar somewhere?
09:01:15 <koxinga> sieni : You really do juggle better while drunk ?
09:01:43 <glen_quagmire> Saizan: I was callling Sys.exitWith Sys.ExitSuccess   on some keypress but now commented it out. so, the only way to quit the app is by closing the window
09:01:43 <andrei> Is anyone interested in haskell bindings for llvm?
09:01:49 <FunctorSalad> sieni: do you mean they cease to amaze you or that they seize you as in get into a thought loop?
09:01:50 <sieni> koxinga: no, I didn't claim that :-)
09:01:52 <glen_quagmire> andrei: i'm interested in it
09:02:05 <andrei> glen_quagmire, Okies, I'll put them up somewhere then
09:02:18 <FunctorSalad> loupgaroublond: for actual implementation mere caffeine is surely better, agreed
09:03:01 <Saizan> glen_quagmire: seems like mainLoop is doing it then
09:03:02 <glen_quagmire> andrei: great. just for me yay!
09:03:07 <koxinga> sieni : It would have surprised me ;-) That's not my experience at all ...
09:03:13 <sieni> FunctorSalad: wtf, I did a homophone error :-)
09:03:20 <sieni> FunctorSalad: "cease" is what I meant :-)
09:03:33 <FunctorSalad> jfredett: I agree though that quite a few people falsely think they are "enlightened" now
09:03:36 <andrei> glen_quagmire, I've had them for a month or two but it just occured to me that maybe other people might be interested
09:03:43 <loupgaroublond> FunctorSalad: although i don't feel like i'm forcing myself sans caffiene, but i'm pretty dependant at this point
09:03:45 <glen_quagmire> Saizan: probably. my google skills aren't good enough to find a proper way around it
09:03:57 <jfredett> FunctorSalad: I have a friend who enjoys the cannabis, we talk about this effect alot
09:04:12 <FunctorSalad> sieni: both made sense, otherwise I wouldn't have said anything. homophone errors happen to me all the time on an exciting subject ;)
09:04:12 <glen_quagmire> I would also be interested in bindings for PortMidi library
09:04:41 <jfredett> fortunately, he more or less agrees with my point- that you're not really experiencing much, if anything, truly "new", just amazement at the old
09:04:44 <sieni> koxinga: but I've managed something like 250 catches while considerably drunk, when I've managed ~750 catches while sober
09:04:52 <sieni> koxinga: with 5 balls that is
09:04:55 <jfredett> which is a useful effect, certainly
09:05:22 <jfredett> sieni: I can barely juggle 3, I'm a bad clown... :/
09:05:42 <jfredett> my record is 20-25 catches
09:05:47 <jfredett> I was fairly proud of that
09:05:49 <FunctorSalad> jfredett: hehe, cannabis makes me too anxious, but psychedelics are often pure bliss (YMMV!)
09:05:50 <jfredett> now I'm not
09:05:50 <jfredett> :/
09:05:56 <sieni> jfredett: not being able to juggle is a good start in being a good clown
09:06:05 <jfredett> sieni: lol
09:06:24 <koxinga> sieni : I find it is a good way to know when to stop
09:06:27 <jfredett> FunctorSalad: I have never experienced (nor plan to experience) the effect, but I'm happy you enjoy it
09:06:31 <jfredett> Guitar is my drug
09:06:32 <jfredett> :)
09:06:45 <koxinga> sieni : When I can't juggle 5 balls, it is really time to go to bed :)
09:07:02 <jfredett> it grants the same effect, as far as I can tell
09:07:14 <jfredett> which is an interesting thing in it of it self
09:07:39 <Saizan> glen_quagmire: well i'd try 'Control.Exception.try main' but this is just guessing :)
09:07:53 <sieni> koxinga: well, that's true :-)
09:07:58 <FunctorSalad> jfredett: not at all similar IME. btw, I wasn't implying you were, just feel obliged to say that so that noone here runs out and drops some mushrooms now ;)
09:08:03 <saturday> HAPPY FUCKING NEW YEAR
09:08:53 <FunctorSalad> happy new year, saturday
09:08:53 <jfredett> lol, FunctorSalad
09:08:56 <sieni> yeah, this year pretty much started with fucking. I can't see how that could happen this time
09:09:54 <saturday> 2008 is going to be the year of the linux desktop!
09:10:00 <saturday> you heard it hear first!
09:10:01 <FunctorSalad> since you are likely to have a bad trip when not carefully considerring setting and stuff....
09:10:09 <jfredett> saturday: oy vay
09:10:19 <glen_quagmire> Saizan: that doesn't do still. I found something. I think it's limitation of GLUT or something. Probably I have to use Gtk2Hs . http://64.233.169.104/search?q=cache:6KTp7vP43AwJ:mlblog.osdir.com/lang.haskell.hopengl/2004-09/index.shtml+gui+ghci+exitWith&hl=en&ct=clnk&cd=1&gl=us&client=firefox-a
09:10:19 <lambdabot> http://tinyurl.com/38azbb
09:13:38 <FunctorSalad> btw, I still don't know what to do tonight...
09:13:54 <glen_quagmire> is there HASKELL_IMPORT_PATH or similar environment varialbe i can set so taht ghc(i) can find a module?
09:14:09 <glen_quagmire> I want it to search /usr/lib/gtk2hs
09:14:35 <glen_quagmire> we need a man page for ghc
09:16:47 <glen_quagmire> ghc -i yay
09:17:01 <Botje> @pl \x -> (x, f x)
09:17:01 <lambdabot> ap (,) f
09:17:41 <FunctorSalad> @type id &&& f
09:17:42 <lambdabot> Not in scope: `f'
09:17:46 <FunctorSalad> @type id &&& ?f
09:17:47 <lambdabot> forall a c'. (?f::a -> c') => a -> (a, c')
09:18:02 <FunctorSalad> (to Botje)
09:18:31 <Botje> heheh
09:18:32 <Botje> yeah
09:18:36 <Botje> but I don't want to import Arrow
09:18:48 <FunctorSalad> @src ap
09:18:48 <lambdabot> ap = liftM2 id
09:19:00 <FunctorSalad> @src liftM2
09:19:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:19:07 <glen_quagmire>  GHC_PACKAGE_PATH
09:19:37 <oerjan> Botje: but using ap requires importing Control.Monad.Reader/Instances
09:19:42 <oerjan> (for that monad)
09:20:05 <Botje> that's true :)
09:20:23 <FunctorSalad> @type liftM2
09:20:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:20:34 <andrei> bos, Helllo?
09:20:54 <FunctorSalad> @type liftM
09:20:54 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:21:21 <FunctorSalad> ah, so that's the morphism part of a monad?
09:21:46 <oerjan> liftM = fmap usually yeah
09:21:49 <FunctorSalad> (I mean in the equivalent definition of monads as endofunctors)
09:22:26 <oerjan> the morphism part of the functor yes
09:23:06 <gbacon> how can I avoid building snoc lists in a foldl?
09:23:28 <oerjan> use foldr instead?
09:24:06 <oerjan> (might work in some cases)
09:24:18 <gbacon> sometimes the right answer is to unask the question :-)
09:24:37 <gbacon> yeah, but what if I'm processing a stream
09:25:16 <oerjan> hard to say without actual example...
09:26:01 <SyntaxNinja> w00t
09:26:31 <gbacon> as an exercise, I'm converting the code in http://hpaste.org/4696#a1 to use foldl
09:26:50 <gbacon> I guess I could map reverse . foldl
09:27:20 <gbacon> what's the usual advice for avoiding snoc lists with foldl?
09:27:24 <oerjan> well the code given handles infinite lists
09:28:06 <oerjan> (mine that is)
09:28:52 <monochrom> foldl is inappropriate for this purpose. I suggest you don't pursue it. Yes, I know you do it for exercise. There are inappropriate exercises like this, and you should not do inappropriate exercises.
09:29:03 <gbacon> monochrom: roger
09:29:26 <monochrom> foldr is appropriate and may be possible.
09:29:53 <MyCatVerbs> monochrom: foldc? :)
09:29:53 <gbacon> why was I thinking foldr requires a finite list?
09:30:07 <oerjan> (well yours too except it cannot handle an infinitely growing sublist i think)
09:30:10 * MyCatVerbs thought YAHT's continuation-passing fold was cute. =)
09:30:17 <oerjan> gbacon: you got it backwards
09:30:20 <MyCatVerbs> gbacon: because it succeeds on infinite lists.
09:30:28 <MyCatVerbs> gbacon: foldl requires a strictly finite list.
09:33:10 <oerjan> hm... i just realized it could be made even lazier
09:33:55 <gbacon> oops.. I looked at (Cale's?) fold diagrams but conflated foldl's structure with foldl1
09:34:00 <gbacon> but they flipflop
09:42:20 <gbacon> oerjan: using foldr or something else?
09:42:24 <hpaste>  oerjan annotated "monotonically increasing sublists" with "lazier" at http://hpaste.org/4696#a2
09:42:52 <oerjan> just by being careful to put the x in place without looking at the rest
09:45:45 <andrei> glen_quagmire, Here you go: http://csclub.uwaterloo.ca/~abarbu/
09:45:46 <lambdabot> Title: Computer Science Club of the University of Waterloo: Home
09:46:37 <andrei> glen_quagmire, Excuse the build system
09:52:51 <glen_quagmire> andrei: thank you!
09:53:02 <FunctorSalad> is [] really implemented in the library and not hardcoded?
09:53:20 <glen_quagmire> :t ([])
09:53:23 <lambdabot> forall a. [a]
09:53:25 <oerjan> FunctorSalad: really hardcoded
09:53:29 <desegnis> Easy to mix up foldl and foldr in your (or at least my) mind... r like, it folds from the right, so it starts at the last element, so it's certainly the fold that works only for finite lists! Hah.
09:53:38 <FunctorSalad> :src []
09:53:39 <oerjan> at least the syntax
09:53:49 <FunctorSalad> @src []
09:53:49 <lambdabot> data [] a = [] | a : [a]
09:53:50 <oerjan> @src []
09:53:50 <lambdabot> data [] a = [] | a : [a]
09:53:50 <gbacon> desegnis: you diagnosed my problem exactly
09:53:56 <oerjan> ^^ not legal haskell
09:54:06 <andrei> glen_quagmire, I'll drop by in a day or two with a proper build system :)
09:54:08 <FunctorSalad> oerjan: yes, the "outfix" syntax probably is, but that src made me wonder.
09:54:33 <oerjan> FunctorSalad: however there is no problem defining another datatype exactly equivalent except for sugar
09:54:56 <gbacon> desegnis: and reinforced by looking at the structure of foldr1 in the diagram
09:55:14 <FunctorSalad> oerjan: [] is a wrapper for outfix lists?
09:55:34 <desegnis> gbacon: If in doubt, I look at the definition :)
09:55:40 <FunctorSalad> or wait, then the def above still wouldn't make sense
09:55:50 <glen_quagmire> andrei: i wish you a happy new year. and a chinese new year too
09:56:02 <oerjan> FunctorSalad: [] has a lot of meanings
09:56:15 <gbacon> desegnis: well, there is that
09:56:15 <oerjan> as an expression alone, it's the empty list
09:56:19 <andrei> glen_quagmire, Thanks :) you too. If I knew people cared I would have released it a month or so ago
09:56:30 <oerjan> as a type alone, it's the constructor of kind * -> *
09:57:05 <glen_quagmire> andrei: i think may people would appreciate any kind of contribution. a couple of weeks ago Ocaml people were very active on llvm mailing list
09:57:15 <FunctorSalad> oerjan: yes, I meant the type constructor
09:57:19 <oerjan> with things inside, it can be a lot of different things
09:57:40 <FunctorSalad> but anyway ;)
09:57:46 <andrei> glen_quagmire, Yeah, this uses their work on providing C bindings
09:58:05 <glen_quagmire> i see
09:58:42 <oerjan> :t [1] :: [] Int
09:58:43 <lambdabot> [Int]
09:59:05 <FunctorSalad> I just meant whether [] a and [a] are just different syntaxes (syntices?) for the same type or whether [a] is hardcoded and [] a is in the library
09:59:10 <FunctorSalad> but not so important :)
09:59:29 <FunctorSalad> that seems to anwer it
09:59:38 <oerjan> neither could be defined with that syntax
09:59:45 <FunctorSalad> yeah
10:00:02 <oerjan> :t (,) 1 2 :: (,) Int Double
10:00:18 <oerjan> @bot
10:00:18 <lambdabot> thread killed
10:00:18 <lambdabot> :)
10:00:21 <idnar> heh
10:00:23 <oerjan> :t (,) 1 2 :: (,) Int Double
10:00:24 <lambdabot> (Int, Double)
10:01:19 <FunctorSalad> @vixen happy new year lambdabot :)
10:01:19 <lambdabot> i could really use a backrub
10:01:30 <oerjan> alas [] 1 is not the same as [1] as an expression
10:01:32 <gbacon> oerjan: so if you were going to implement mono from scratch, would you use foldr?
10:02:03 <oerjan> probably
10:02:04 <gbacon> if my code has more than about two function applications, I worry that I'm being too verbose after having seen so much ber-elegant Haskell code
10:03:15 <oerjan> or actually... perhaps direct recursion would be easier
10:03:33 <oerjan> given that which' which split
10:04:19 <gbacon> in Haskell, shouldn't one always prefer laziness to using accumultors?
10:05:10 <FunctorSalad> <lambdabot> yeah, why not?<FunctorSalad> @vixen because I live in the real world and you are just a fantasy?<lambdabot> oh, okay
10:05:19 <gbacon> oh, or do you mean direct recursion on a zipped version of the input?
10:05:22 <oerjan> depends on strictness
10:05:47 <oerjan> no, just very directly
10:07:24 <Roberth> why is there a tarball for each os for ghc?
10:09:11 <hpaste>  oerjan annotated "monotonically increasing sublists" with "foldr may be overkill" at http://hpaste.org/4696#a3
10:12:05 <oerjan> except maybe foldr works better with those fusion things ghc does, i don't know
10:12:30 <gbacon> I was nipping at your heels.. didn't have the inner (mono l)
10:14:37 <hpaste>  gbacon annotated "monotonically increasing sublists" with "fix pattern failure" at http://hpaste.org/4696#a4
10:14:44 * SyntaxNinja hates X11's zap "feature"
10:14:57 <olsner> zap? ctrl-alt-backspace?
10:15:08 <SyntaxNinja> olsner: ja
10:15:35 <olsner> SyntaxNinja: shit, r alla svenskar hr inne!?
10:16:02 <oerjan> gbacon: er the last two are identical apart from names...
10:16:35 <olsner> OTOH, "ja" for "yes" does occur in a few other languages
10:16:35 <SyntaxNinja> olsner: er, no?
10:16:36 <sjanssen> foldr is never overkill!
10:17:13 <bparkis> is there a simplified framework (like combinatory logic) for dealing with algebraic data types and pattern matching?
10:17:17 <gbacon> oerjan: well it fixed a failure in my code :-(
10:17:41 <Choko> ja is also german and danish, maybe also norwegian ?
10:17:47 <gbacon> partial copy/paste
10:17:47 <oerjan> Choko: yep
10:18:01 <_rey_> Choko: also dutch
10:18:12 <Choko> and maybe finnish?
10:18:29 <gbacon> ja, ja, ja, ja, weiss nicht wie gutt ich dir bin
10:18:38 * oerjan recalls this dutch lecturer who ended all his sentences in "ja" - when speaking english
10:19:50 <koala_man> I've heard english speakers do than when speaking english. no'wa'mean, yah?
10:19:58 <oerjan> sjanssen: but the code got simpler without foldr
10:20:28 <idnar> I also use "ja" a lot, maybe because of Afrikaans influence
10:20:40 * SyntaxNinja has no excuse for using "Ja"
10:20:51 <idnar> (I'm a native English speaker)
10:20:52 <gbacon> @ho a -> [b] -> [[c]]
10:20:52 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
10:20:58 <gbacon> @hoogle a -> [b] -> [[c]]
10:20:59 <lambdabot> No matches, try a more general search
10:21:19 <shachaf> gbacon: const (const [])?
10:21:54 <shachaf> gbacon: What are you looking for, with separate a, b, c?
10:21:55 <olsner> koala_man: reminds me of Fargo (the movie), where almost everyone pronounces yeah as yah
10:21:56 <gbacon> koala_man: or JAck Sparrow's "Savvy?" :-)
10:22:08 <gbacon> @ho a -> [a] -> [[a]]
10:22:08 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
10:22:12 <gbacon> @hoogle a -> [a] -> [[a]]
10:22:12 <lambdabot> No matches, try a more general search
10:22:32 <idnar> @djinn a -> [a] -> [[a]]
10:22:32 <lambdabot> -- f cannot be realized.
10:22:46 <oerjan> gbacon: that type does not make much sense
10:23:00 <gbacon> that's which's type, isn't it?
10:23:03 <oerjan> djinn still does not know about lists
10:23:23 <idnar> @type which
10:23:24 <gbacon> @hoogle a -> [b] -> [b]
10:23:25 <lambdabot> Not in scope: `which'
10:23:25 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
10:23:25 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
10:23:25 <lambdabot> Data.List.scanl :: (a -> b -> a) -> a -> [b] -> [a]
10:23:44 <shachaf> Nor would it do any good if it did -- it knows Maybe.
10:23:55 <oerjan> idnar: in the paste
10:24:01 <idnar> oh
10:24:39 <oerjan> gbacon: well it was declared once as Ord a => a -> [[a]] -> [[a]]
10:25:10 <gbacon> right, realized that and switched to beta in the hoogle search
10:25:54 <gbacon> or is that an OCaml-ism to pronounce a in a type as alpha?
10:26:42 <|Jedai|> It looks like the type of a "split", doesn't it ?
10:26:54 <|Jedai|> What are you trying to do ?
10:27:28 <oerjan> jedai: http://hpaste.org/4696#a3
10:27:50 <oerjan> oh wait
10:27:58 <oerjan> m:ms = mm
10:29:42 <hpaste>  oerjan annotated "monotonically increasing sublists" with "simplified" at http://hpaste.org/4696#a5
10:31:35 <oerjan> hm now the first and last case are identical
10:32:13 <nolrai> is there a way to do what would be a function - static varible in C, in haskell (in the IO monad of corce)?
10:33:11 <hpaste>  oerjan annotated "monotonically increasing sublists" with "whittling down" at http://hpaste.org/4696#a6
10:33:34 <sjanssen> nolrai: are you sure you need such a thing?
10:35:17 <nolrai> wow, i dont need it actuly, just need to break up my actions.
10:35:45 <sjanssen> you mean local static variables in functions, right?
10:37:34 <nolrai> yeah
10:38:15 <sjanssen> yeah, those are evil :)
10:39:04 <nolrai> I mean you could use a file, but thats both fragel and inifecient.
10:39:30 <Sizur> :t readS
10:39:31 <lambdabot> Not in scope: `readS'
10:39:37 <idnar> why does it need to be static?
10:39:45 <Sizur> @hoogle String -> IO a
10:39:46 <lambdabot> Foreign.C.Error.throwErrno :: String -> IO a
10:39:46 <lambdabot> Distribution.Simple.Utils.die :: String -> IO a
10:39:46 <lambdabot> System.Environment.withProgName :: String -> IO a -> IO a
10:39:48 <nolrai> but haveing to pass around a IORef is annoying if its only used in one place.
10:39:59 <oerjan> :t readIO
10:40:00 <lambdabot> forall a. (Read a) => String -> IO a
10:40:03 <Sizur> thanks
10:41:36 <nolrai> well i would like to be able to init the dialog when it is first oppened, but if it is inited twice things get ugly.
10:42:16 <Sizur> nolrai: did you think about using a ReaderT?
10:42:42 <hpaste>  gbacon annotated "monotonically increasing sublists" with "quickcheck property!" at http://hpaste.org/4696#a7
10:42:57 <Sizur> then you have access to local values within your monad
10:42:58 <idnar> @src readIO
10:42:58 <lambdabot> Source not found. :(
10:43:17 <nolrai> Sizur: with an IORef?
10:43:42 <Sizur> nolrai: nope. in your monadic function you do: value <- ask
10:43:49 <Sizur> :t ask
10:43:50 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:44:10 <nolrai> yeah but then i cant change them.
10:44:22 <Sizur> :t local
10:44:22 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
10:44:36 <Sizur> use local to change. or StateT
10:46:36 <gbacon> @pl \l -> all (uncurry (<=)) $ zip l (tail l)
10:46:36 <lambdabot> all (uncurry (<=)) . ap zip tail
10:46:45 <oerjan> gbacon: < not <= i think
10:46:58 <nolrai> * thinks
10:47:15 <gbacon> is it strictly increasing or nondecreasing?
10:47:33 <oerjan> strictly i believe
10:47:41 <oerjan> i mean the definition contains <
10:47:56 <Sizur> nolrai: that way your function signature tells everybody that it has access to a specific local variable without you passing it all over the place
10:48:03 <gbacon> true
10:54:29 <nolrai> true witch is a good thing, but dosnt help me write  already :: IO Bool -- returns weather already has been run before this program.
10:57:03 <sjanssen> > (\x -> z where z = x+1) 1 -- can't remember if this is allowed
10:57:03 <lambdabot>  Parse error at "where" (column 10)
10:57:57 <lelf> use let
10:59:23 <nolrai> but i dont need that now. So meh.
11:02:55 <ehird> parsec question: if i have [..], and [... ofc being an error, how can i make parsec report the error in the line/col of the [ instead of end-of-input?
11:04:15 <oerjan> hm... if you wrap it in try it should go back to that step
11:04:41 <ehird> oh hello oerjan :)
11:05:25 <oerjan> changing to parsec eh? :)
11:05:33 <ehird> considering it
11:05:48 <ehird> unless i think of some super-duper thing :)
11:06:29 <oerjan> i thought of a simple way to fix that bug from yesterday btw:  just parse comment chars as a NOP command
11:06:58 <ehird> which bug was it again?
11:07:18 <oerjan> running off the end of file if it ends with a comment
11:07:26 * ehird is already retooling the current one to be parseOne, parseLoop and parse, so may not be able to put the changinto practice :-)
11:07:28 <ehird> and ah
11:07:48 <ehird> better way: String -> [(BF, String)]
11:07:50 <ehird> and "" = []
11:08:38 <idnar> > "" == []
11:08:40 <lambdabot>  True
11:08:44 <idnar> :t []
11:08:44 <lambdabot> forall a. [a]
11:08:55 <ehird> err, i meant
11:08:55 <idnar> :t ""
11:08:56 <lambdabot> [Char]
11:08:57 <ehird> func "" = []
11:08:58 <ehird> :-)
11:09:11 <idnar> heh
11:09:17 <idnar> I was just curious
11:09:57 <visof> can i get feeds for haskell?
11:11:02 <gbacon> visof: http://planet.haskell.org/rss20.xml
11:11:03 <FunctorSalad> why doesn't ghci see QuickCheck even though it is registered in ghc-pkg ?
11:11:12 <nolrai> @ty let f 1 'a' "a" = 2 in flip f
11:11:12 <lambdabot> forall a t. (Num a, Num t) => Char -> a -> [Char] -> t
11:12:02 <nolrai> @hoogle flip
11:12:02 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
11:12:02 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
11:12:14 <conal> any gtk2hs folks here?  i'm wondering what prereqs there are for ghc 6.8.2 on ubuntu.  i see gtk+, but i don't know what package to install.  (linux newbie.)
11:12:37 <visof> gbacon thanks
11:12:49 <gbacon> visof: there's also an atom feed
11:13:07 <oerjan> ehird: however i foresee a similar bug with an unmatched ] following a comment
11:13:26 <visof> what is atom feed?
11:13:33 <oerjan> and in that case you cannot just return [], because you want the line/col as well
11:13:45 <gbacon> @google atom feed
11:13:46 <lambdabot> http://en.wikipedia.org/wiki/Atom_(standard)
11:13:46 <lambdabot> Title: Atom (standard) - Wikipedia, the free encyclopedia
11:13:52 <nolrai> conal: I think it tells you what you need when you try to install it. I just installed it last week, but dont quite rember.
11:14:06 <oerjan> hm, actually any ] following a comment
11:14:27 <conal> nolrai: oh -- cool.  i'll give that a try.  thx.
11:15:07 <ehird> oerjan: who would know that haskelly brainfuck parsing would be hard :-)
11:15:56 <gbacon> visof: either way, they're both available from http://planet.haskell.org/
11:15:56 <lambdabot> Title: Planet Haskell
11:16:12 * EvilTerran would expect parsing BF to be pretty easy
11:18:22 <nolrai> is there like a flipN where say flip3 f a b c = f c a b?
11:19:30 <idnar> @pl flip3 f a b c = f c a b
11:19:30 <lambdabot> flip3 = (flip .) . flip
11:19:42 <idnar> that's more like "rotate"
11:20:40 <nolrai> true
11:21:31 <idnar> @pl flip3 f a b c = f b a c
11:21:31 <lambdabot> flip3 = flip
11:21:35 <idnar> er
11:21:43 <idnar> @pl flip3 f a b c = f c b a
11:21:43 <lambdabot> flip3 = flip . (flip .) . flip
11:21:47 <idnar> heh
11:23:01 <ehird> @pl flip flip
11:23:03 <lambdabot> flip flip
11:23:12 <ehird> @pl flip flip flip
11:23:12 <lambdabot> flip flip flip
11:23:15 <EvilTerran> @unpl @pl flip flip
11:23:15 <lambdabot>  Parse error at "@pl" (column 1)
11:23:18 <EvilTerran> @unpl flip flip
11:23:18 <lambdabot> (\ b c f -> c f b)
11:23:43 <nolrai> @ty (flip flip)
11:23:44 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
11:24:10 <Tac-Tics> :t flip . flip
11:24:11 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
11:24:40 <nolrai> (flip . flip) == id, right?
11:24:56 <Tac-Tics> > (flip . flip)
11:24:57 <lambdabot>  Add a type signature
11:24:58 <Tac-Tics> err
11:25:02 <Tac-Tics> > (flip . flip) 4
11:25:02 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
11:25:03 <glen_quagmire> @src id
11:25:03 <lambdabot> id x = x
11:25:12 <Tac-Tics> @pl flip . flip
11:25:13 <lambdabot> id
11:25:16 <Tac-Tics> yes ;-)
11:25:39 <Tac-Tics> that's kinda weird though
11:25:52 <EvilTerran> ?djinn (a -> b -> c) -> a -> b -> c
11:25:52 <lambdabot> f a = a
11:25:55 <Tac-Tics> (a -> b -> c) -> (a -> b ->c)  = x -> x
11:25:57 <EvilTerran> ?. pl djinn (a -> b -> c) -> a -> b -> c
11:25:57 <lambdabot> f = id
11:26:21 <glen_quagmire> :t djinn
11:26:21 <lambdabot> Not in scope: `djinn'
11:26:29 <EvilTerran> ?help djinn
11:26:30 <lambdabot> djinn <type>.
11:26:30 <lambdabot> Generates Haskell code from a type.
11:26:30 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
11:26:40 <Tac-Tics> Oh, I get it, It's a specification of 'id' for functions of 2 parameters
11:27:04 <idnar> :t (flip . flip) 4
11:27:04 <lambdabot> forall a b c. (Num (a -> b -> c)) => a -> b -> c
11:27:06 <nolrai> yeap
11:27:21 <Tac-Tics> > (flip . flip) (-) 4 1
11:27:22 <lambdabot>  3
11:27:25 <Tac-Tics> ^^
11:27:44 <idnar> :t id 4 :: forall a b c. (Num (a -> b -> c)) => a -> b -> c
11:27:44 <lambdabot> forall a b c. (Num (a -> b -> c)) => a -> b -> c
11:27:56 <Tac-Tics> :t flip
11:27:56 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:29:03 <glen_quagmire> ?djinn [[a]] -> [[a]]
11:29:03 <lambdabot> f a = a
11:29:16 <Tac-Tics> ?djinn Int -> a
11:29:16 <lambdabot> -- f cannot be realized.
11:29:21 <Tac-Tics> heh
11:33:41 <nolrai> would there be away to use template haskell to write RotateN f first second ... nMinusOneth nth = f nth first second .. nMinusOneth? (if that makes any sense)
11:34:13 <nolrai> so or rather rotateN?
11:34:35 <nolrai> (i.e. rotate2 would be flip?)
11:35:20 <resiak> @ty \f x y z -> f z x y
11:35:21 <lambdabot> forall t t1 t2 t3. (t2 -> t -> t1 -> t3) -> t -> t1 -> t2 -> t3
11:36:07 <EvilTerran> you could write $(rotate n) to do that
11:37:54 <nolrai> cool
11:38:20 <EvilTerran> or $(rotate n i) or what-have-you
11:43:20 <EvilTerran> roll n 0 = [| id |]
11:43:20 <EvilTerran> roll n i = [| ($(roll n (i-1)) .) . flip |]
11:43:49 <EvilTerran> er, drop the n parameter. dunno why i put that in.
11:45:07 <nolrai> very cool
11:46:38 <EvilTerran> ?unpl (((flip.).flip.).flip.).flip
11:46:38 <lambdabot> (\ r aa ad ag b c -> r c aa ad ag b)
11:46:49 <EvilTerran> ?type (((flip.).flip.).flip.).flip
11:46:51 <lambdabot>     The operator `.' [infixr 9] of a section
11:46:51 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
11:46:51 <lambdabot>         in the section: `(((((((flip .)) . flip) .)) . flip) .)'
11:47:02 <EvilTerran> what
11:47:19 <EvilTerran> ?. type unpl (((flip.).flip.).flip.).flip
11:47:19 <lambdabot> forall t t1 t2 t3 t4 t5. (t4 -> t -> t1 -> t2 -> t3 -> t5) -> t -> t1 -> t2 -> t3 -> t4 -> t5
11:48:51 <Tac-Tics> stop this typey madness!
11:49:01 <EvilTerran> yarr
11:49:42 <Tac-Tics> what kind of madness is this? (the answer is (* -> * -> * -> * -> * -> *) -> * -> * -> * -> * -> * -> *!)
11:49:45 <EvilTerran> @. elite yarr
11:49:45 <lambdabot> I'd |Ixe TO DrOp /\/\e 4NChOR in Her La90On
11:50:17 <Cale> @. elite keal
11:50:18 <lambdabot> I jUsT g0t B4nNED phROm maTh BeC4Use I noT haVe G00D ABi1I7Y TO coNvey +|-|0UGhTs
11:50:33 <Tac-Tics> @. elite whatdoeselitedo?
11:50:33 <lambdabot> Plugin `compose' failed with: Unknown command: "whatdoeselitedo?"
11:50:46 <Cale> @elite hello world
11:50:46 <lambdabot> HE1l0 WOrLD
11:51:02 <Tac-Tics> @elite 1337sp34|<
11:51:02 <lambdabot> 13375p34|<
11:51:08 <Tac-Tics> heh
11:53:38 <oerjan> @remember Tac-Tics what kind of madness is this? (the answer is (* -> * -> * -> * -> * -> *) -> * -> * -> * -> * -> * -> *!)
11:53:38 <lambdabot> Good to know.
11:54:58 <nolrai> @elite i cant read this
11:54:58 <lambdabot> I (4nt re4d tHIz
11:55:33 <Tac-Tics> @elite Moar monads or gtfo noob!
11:55:33 <lambdabot> moAR /\/\0Nad$ 0R g+fo n0O8!
11:57:13 <Tac-Tics> @elite > "I'm totally leet"
11:57:13 <lambdabot> > "i'/\/\ 7o74L|Y 1Eet"
11:57:32 <Tac-Tics> Aw, lambda bot doesn't invoke herself =-(
11:57:58 <Tac-Tics> @elite so much for my nubby hacker skillz
11:57:59 <lambdabot> sO Mu(|-| F0R /\/\y nu88y |-|AcKEr $xI1ls
11:59:17 <oerjan> @@ @elite @run "No, _I'm_ totally leet"
11:59:17 <lambdabot>  "NO, _I'm_ t0tAlLy lee7"
12:03:36 <FunctorSalad> ok, I got a bunch of number-theoretic function that need a list of primes. what is a nice way to avoid passing it around?
12:04:57 <Cale> FunctorSalad: Well, you could define it at the top level, but that would cause it to be memoised, which you might not want.
12:05:12 <nolrai> so is there away to implement "already :: String -> IO Bool --returns weather has already been called before", without using files??
12:05:28 <FunctorSalad> I had it that way, but now it's a library, so the caller should generate the prime list and pass it one time
12:05:29 <Cale> You could also define the list of primes as a function at the top level, just taking () as a parameter.
12:05:39 <FunctorSalad> (@Cale)
12:06:03 <nolrai> why would the memoisation be a bad thing?
12:06:09 <Cale> nolrai: memory
12:06:15 <Tac-Tics> it eats up memory permanently in your program
12:06:53 <FunctorSalad> abstractly, I have some functions f:: [Int] x A -> B, g:: [Int] x B -> C that call each other
12:06:54 <EvilTerran> nolrai, IORefs would work
12:06:58 <Tac-Tics> So by making the prime list a nullary function, that makes a function Superlazy or something? ;-)
12:07:26 <Cale> The results of functions aren't shared.
12:07:50 <EvilTerran> nolrai, do you mean (already "x" >> already "y") would return True, or just such things as (already "x" >> already "x")?
12:07:51 <Tac-Tics> shared in what sense?
12:08:03 <Cale> nolrai: A good hint is that you might be happier with something of type IO (String -> IO Bool)
12:08:07 <FunctorSalad> and I think i need a widget such that (g `widget` f) :: [Int] x A -> C in the obvious way
12:08:10 <FunctorSalad> (passing the list around)
12:08:24 <nolrai> evilTerran: the second
12:08:28 <EvilTerran> ok
12:08:31 <Cale> nolrai: (Which gives you the ability to initialise multiple such "already" functions)
12:08:43 <FunctorSalad> this looks like a comonad to me?
12:08:45 <nolrai> right
12:09:31 <Cale> FunctorSalad: it might be that you just want a reader monad.
12:09:33 <Tac-Tics> what is a comonad?
12:09:47 <FunctorSalad> oops, forgot to mention that the primelimit should be given by the caller of the library, yes, otherwise I would just do the list of primes on the toplevel
12:09:49 <Tac-Tics> (In dumb C.S. terms)
12:10:23 <idnar> @type bind
12:10:24 <lambdabot> Not in scope: `bind'
12:10:27 <Cale> FunctorSalad: or maybe a "supply" monad (which is effectively a state monad with restrictions on how the state is interacted with)
12:10:30 <idnar> ag
12:10:34 <FunctorSalad> Tac-Tics: monad with the arrows reversed. I'm not sure if this actually is a comonad so I better shut up now
12:10:34 <idnar> @type (>>=)
12:10:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:10:52 <nolrai> I want to hide the initizing of dialogs from the using of dialogs.
12:11:00 <FunctorSalad> Cale: I looked up Reader but didn't see how to use it here
12:11:19 <idnar> cobind :: (w a -> b) -> w a -> w b
12:11:46 <FunctorSalad> yes, that cobind is my "widget" I think.
12:11:50 <Cale> FunctorSalad: well, the purpose of reader is to get an environment (in this case the list of primes) passed down to all parts of a computation
12:11:53 <EvilTerran> nolrai, i'd suggest something with an IORef Set
12:12:14 <Tac-Tics> :t flip . (>>=)
12:12:14 <lambdabot> forall b a b1. (b -> a) -> b -> (a -> b -> b1) -> b1
12:12:25 <Tac-Tics> er
12:12:26 <FunctorSalad> Cale: yeah but can it bump (w a -> b) functions to (w a -> w a) functions?
12:12:28 <Tac-Tics> :t flip (>>=)
12:12:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
12:13:04 <FunctorSalad> (where here, w a is just (Int,a))
12:13:24 <oskarM> :t (=<<)
12:13:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:13:45 <EvilTerran> already = do ref <- newIORef empty; return $ \str -> do set <- readIORef ref; if str `member` set then return True else do modifyIORef ref (insert str); return False
12:14:08 <EvilTerran> nolrai, that kinda thing
12:14:30 <Tac-Tics> What is an example of a comonad?
12:14:50 <FunctorSalad> Tac-Tics: no idea really, I'm wondering whether this is one
12:14:57 <idnar> http://www.cs.helsinki.fi/u/ekarttun/comonad/
12:14:59 <lambdabot> Title: Comonads and Haskell
12:17:13 <FunctorSalad> I'd define WithPrimes a = (Int, a)
12:17:54 <FunctorSalad> cobind :: WithPrimes a -> (WithPrimes a -> b) -> WithPrimes b
12:18:46 <FunctorSalad> cobind (primes, x) f = (primes, (f primes x))
12:18:58 <FunctorSalad> coreturn (primes, x) = x
12:19:11 <idnar> that's not the right type for cobind
12:19:25 <idnar> @type (>>>)
12:19:26 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
12:19:26 <FunctorSalad> it's the type you just gave, no?
12:19:51 <idnar> oh, I guess it is, just flipped
12:20:17 <FunctorSalad> are comonads in the standard library?
12:20:22 <idnar> something is confusing me
12:20:33 <idnar> @src Reader (>>=)
12:20:33 <lambdabot> Source not found. It can only be attributed to human error.
12:20:39 <nolrai> EvilTerran: that will allways return true
12:20:49 <nolrai> EvilTerran: wont it?
12:20:53 <EvilTerran> no...
12:21:14 <EvilTerran> once set <- readIORef ref; has happened, any changes to ref won't affect set
12:21:39 <EvilTerran> hm... do we have ST in these parts?
12:22:30 <EvilTerran> > runST (return ())
12:22:30 <lambdabot>   Not in scope: `runST'
12:22:37 <EvilTerran> apparently not. i can't demonstrate, then.
12:22:52 <EvilTerran> > Control.Monad.ST.runST
12:22:53 <lambdabot>   Not in scope: `Control.Monad.ST.runST'
12:22:54 <nolrai> oh right, its type IO (String -> IO Bool) right, but then i have to pass around the returned function, right?
12:23:08 <EvilTerran> yeah
12:23:27 <EvilTerran> you have to do an IO action to create the IORef Set
12:23:27 <nolrai> I might just use a file then.
12:24:18 <EvilTerran> you can make a global set with unsafePerformIO, i believe.
12:24:43 <FunctorSalad> :o
12:24:44 <EvilTerran> which you could argue is nicer than using a file
12:25:05 <nolrai> yeah.
12:25:15 <nolrai> hummm.
12:25:16 <EvilTerran> FunctorSalad, it's not a problem in this case, as it'll get run as soon as you first dereference the IORef
12:25:51 <EvilTerran> it's just global mutable values don't really fit into the monadic IO model
12:26:13 <nolrai> thats strange.
12:26:16 <Sizu1> @hoogle liftIO
12:26:17 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
12:26:51 <FunctorSalad> I don't get the Reader docs at the moment :(
12:26:56 <EvilTerran> the problem is tying them into the "main" IO action
12:27:45 <EvilTerran> if you're sure you'll only ever want one of these sets, another possibility would be to state-transform the IO monad
12:27:55 <FunctorSalad> oh, is every one of my functions a different Reader?
12:28:01 <EvilTerran> and then use liftIO (as suggested by Sizu1 there)
12:28:07 <FunctorSalad> that's a different approach than my comonad thingy...
12:28:23 <FunctorSalad> EvilTerran: to nolrai or to me?
12:28:26 <EvilTerran> nolrai,
12:29:40 <nolrai> I cant because im using a call back library (gtk2hs) so i guess either the file or passing around somthing.
12:30:11 <EvilTerran> already :: StateT (Set String) IO Bool; already str = do set <- get; modify (insert str); return (str `elem` set)
12:30:51 <EvilTerran> having done that, you'd need to liftIO every monadic action that's :: IO a
12:31:19 <EvilTerran> s/elem/member/
12:31:54 <EvilTerran> nolrai, there's presumably only one section of the program that needs this set
12:32:11 <FunctorSalad> if f:: Int -> Int is my function that needs the prime list to work, I should do it as a Reader [Int] (Int->Int), right?
12:33:06 <EvilTerran> you could wrap that bit in (\action -> evalStateT action empty), and then you'd only have to liftIO the actions inside that section
12:33:20 <EvilTerran> ?unmtl  Reader [Int] (Int->Int)
12:33:20 <lambdabot> [Int] -> Int -> Int
12:33:41 <FunctorSalad> unmtl?
12:33:42 <EvilTerran> FunctorSalad, methinks it'd be cleaner in this case to just pass it as a parameter normally
12:34:01 <EvilTerran> "UNdo use of the Monad Transformer Library"
12:34:03 <FunctorSalad> EvilTerran: maybe, but now I will learn how Reader works :)
12:34:11 <FunctorSalad> hehe
12:34:19 <EvilTerran> ?unmtl StateT (Set String) IO a
12:34:19 <lambdabot> Set String -> IO (a, Set String)
12:34:28 <EvilTerran> ?unmtl State Int
12:34:29 <lambdabot> State Int
12:34:39 <EvilTerran> er
12:34:40 <EvilTerran> ?unmtl State Int a
12:34:40 <lambdabot> Int -> (a, Int)
12:35:05 <EvilTerran> (Reader r a) is equivalent to (r -> a)
12:35:42 <EvilTerran> this is why people speak of (e ->) as being the reader (as compared to Reader) monad
12:35:53 <EvilTerran> similarly, Writer = (,)
12:36:00 <FunctorSalad> yeah, we had that another day
12:36:10 <FunctorSalad> now I understand more
12:36:25 <EvilTerran> and State s a ~~ s -> (a, s)
12:36:42 <FunctorSalad> EvilTerran: it's not really equivalent, is it? the library defines how to make a Monad, Functor etc. of it
12:37:01 <EvilTerran> (every State action takes the initial state, and returns a new state alongside the value)
12:37:08 <FunctorSalad> wait, let me just type it up
12:37:12 <EvilTerran> not completely drop-in equivalent
12:37:33 <EvilTerran> but there's Monad instances for (r->) and (w,)
12:37:42 <glen_quagmire> is it possible to make a package that has external C library that'll compile automatically using gcc included in ghc?
12:39:03 <EvilTerran> nolrai, i guess the two ways of doing it would be to either pass around an IORef (or a closure hiding the IORef), or to wrap part of the program in a StateT. i prefer the latter, but either works.
12:40:01 <EvilTerran> the StateT version's more explicit
12:41:24 <nolrai> but i cant use it beacause i need to get at the state from within call backs.
12:41:50 <nolrai> So i think ill just use a temporary file.
12:42:00 <Sizu1> nolrai: you can wrap it around the IO, around the main loop
12:42:26 <nolrai> ?
12:42:35 <Sizu1> before you initialize gtk2hs
12:43:08 <nolrai> how would that let me pass in monad values to the callbacks?
12:43:14 <Sizu1> hmm, i see, the callbacks have a signature already
12:43:48 <nolrai> i might be able to write a genral wraper.
12:45:27 <nolrai> although thats about the same as passing a IORef around.
12:45:41 <Sizu1> nolrai: well, you can make your own version of a callback that wraps around the original, but if you really need to use the variable within the callback itself, you'll have to pass it
12:48:44 <oerjan> hm...
12:49:55 <nolrai> the wraper could pass it, but like i said befor thats realy the same thing as just passing it, just rearanged on the line.
12:50:07 <Sizu1> exactly
12:50:13 <Sizu1> passing is the best solution if you ask me
12:50:19 <Sizu1> the framework forces it
12:53:22 <nolrai> I think I would do that if performance was an issue, but as its not Ill just use a temporay file. or no i think ill pass it around i already am passing a lot of stuff to the callbacks anyway.
12:54:05 <Sizu1> what are you passing around again?
12:54:06 * FunctorSalad finally figured out that Reader is just a plain value constructor ;)
12:55:11 <Sizu1> i though i figured out that a monad is a shell, and reader is a monad :P
12:56:13 <nolrai> an IORef (Set String)
12:56:35 <Sizu1> nolrai: why would a file version be better?
12:56:43 <FunctorSalad> Sizu1: for any type R, (Reader R) is a monad, I think
12:56:58 <nolrai> because i wouldnt have to pass it around at all.
12:57:16 <FunctorSalad> this overloading of type names and value constructor names is hard :(
12:57:39 <Sizu1> nolrai: but you introduce parsing into the picture completely unnecessarily
12:57:49 <nolrai> true
12:58:40 <Sizu1> the whole point of FP is to be explicit about what code does
12:58:42 <conal> @seen vincenz
12:58:43 <lambdabot> I saw vincenz leaving #haskell 2d 23h 8m 33s ago, and .
12:58:45 <gigamonk`> Is it possible to define one's own type classes that can be derived with "deriving"?
12:59:04 <Sizu1> and how sould you get out of the IO within the callback after parsing?
12:59:15 <conal> @tell vincenz i'd like a chat about lossy events.
12:59:15 <lambdabot> Consider it noted.
12:59:57 <Sizu1> gigamonk`: i htink 6.10 should do it. right now you'd have to use Template Haskell
13:00:15 <gigamonkey> 6.10 of what?
13:00:18 <Sizu1> ghc
13:00:30 <gigamonkey> ah.
13:00:46 <nolrai> the call back is IO ().
13:00:47 <gigamonkey> Is ghc a leading indicator of what's coming in Haskell-prime?
13:01:30 <Sizu1> no idea about that
13:01:54 <oerjan> ghc is already _far_ ahead of haskell-prime i should think
13:02:03 <Sizu1> i'd guess haskell' takes ideas from ghc, but they are not connected much
13:03:18 <DuClare> hmm
13:04:05 <DuClare> are there any runtime deps for haskell or ghc related stuff for binaries built by ghc?
13:04:12 <DuClare> or are they all they way stand-alone?
13:04:50 <Sizu1> depends what you use in your code. for example gtk2hs needs gtk
13:04:59 <DuClare> ah
13:05:17 <DuClare> but no haskell specific deps?
13:05:17 <Sizu1> you should be able to link it in though
13:05:26 <Sizu1> nope
13:05:32 <DuClare> alright.
13:05:54 <monochrom> I see linux-gate.so.1, libm.so.6, libgmp.so.3, libdl.so.2, librt.so.1, libc.so.6, ld-linux.so.2, libpthread.so.0
13:06:37 <Sizu1> monochrom: what about windows? or mac?
13:06:41 <monochrom> IMO that means standalone, since all linuxes already have them. Maybe just lacking libgmp.
13:06:48 <monochrom> I don't know.
13:07:02 * SyntaxNinja cleans up cabal-install's multi-package error handling )
13:07:03 <SyntaxNinja> :)
13:15:12 <FunctorSalad> how do I define a type constructur synonym again?
13:15:26 <FunctorSalad> e.g. something like Stringreader a := Reader String a
13:16:29 <Sizu1> type A a = B C a
13:17:57 <Sizu1> note, there are no constructors here. just a type synonym
13:18:51 <FunctorSalad> yes, but I meant A is now a "type constructor synonym" for B C
13:20:03 <monochrom> I don't like the word "constructor" alone. It's ambiguous. data constructor /= type constructor. So "constructor" = ?  Better just avoid it.
13:20:33 <FunctorSalad> monochrom: agreed. unfortunately they often share the same identifies as well
13:20:36 <FunctorSalad> *identifier
13:21:34 <monochrom> Yeah, I avoid that when I show code to beginners too.
13:24:18 <monochrom> The impossible has happened! I have finished skimming haskell-cafe.
13:26:17 <Sizu1> i need to use read, but to catch if it doesn't parse. and if i use readIO, i cannot get out of the IO even though all options are covered... what alternatives do i have?
13:26:38 <sjanssen> Sizu1: use reads
13:26:59 <sjanssen> > reads "1" :: [(Int, String)]
13:27:02 <lambdabot>  [(1,"")]
13:27:10 <sjanssen> > reads "not a number" :: [(Int, String)]
13:27:11 <lambdabot>  []
13:27:22 <Sizu1> sjanssen: thanks!
13:30:06 <Sizu1> > reads "12 34" ::[(Int,String)]
13:30:06 <lambdabot>  [(12," 34")]
13:30:26 <Sizu1> > reads "12 34" ::(Int,String)
13:30:27 <lambdabot>  Couldn't match expected type `(Int, String)'
13:30:39 <Sizu1> why list?
13:31:31 <monochrom> multiple possible parses.
13:40:51 * SyntaxNinja implements cabal upgrade :)
13:41:41 <idnar>  > reads "12 34" ::[(Int, Int)]
13:41:49 <idnar> > reads "12 34" ::[(Int, Int)]
13:41:50 <lambdabot>  Couldn't match expected type `Int' against inferred type `String'
13:42:13 <idnar> hrm, nevermind me
13:42:15 <gbacon> > reads "12 34" :: [(Int,String)]
13:42:16 <lambdabot>  [(12," 34")]
13:42:25 <SyntaxNinja> @seen shapr
13:42:25 <lambdabot> I saw shapr leaving #haskell-blah, #scannedinavian and #haskell 20h 21m 7s ago, and .
13:42:31 <SyntaxNinja> @seen dcouttes
13:42:31 <lambdabot> I haven't seen dcouttes.
13:42:38 <hpaste>  FunctorSalad pasted "passing-primelist-around with Readers" at http://hpaste.org/4736
13:42:51 <SyntaxNinja> @seen dcoutts
13:42:51 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell, #ghc and #haskell-overflow 2d 1h 55m 15s ago, and .
13:43:26 <FunctorSalad> ok, got it to work with Readers. now the big question is, how do I write this more neatly? at the moment I obviously don't win anything over just passing the prime list around
13:44:13 <FunctorSalad> would be cool if I could write this in do notation or whatever. don't try to parse the number theory stuff there if you don't like :)
13:44:24 <sjanssen> FunctorSalad: use 'ask' and do notation
13:44:51 <FunctorSalad> 'ask' is for MonadReaders :( I think my thing is no MonadReader
13:45:41 <sjanssen> it is
13:46:02 <sjanssen> MonadReader is a general interface for both Reader and ReaderT
13:46:58 <ptolomy> Hm. I'd always assumed that 'tail' was teh equivalent of 'drop 1', but a runtime exception proves me wrong. Silly me.
13:46:59 <FunctorSalad> oh, read that the other way around
13:47:12 <idnar> > drop 1 []
13:47:12 <lambdabot>  []
13:47:15 <idnar> > tail []
13:47:15 <lambdabot>  Exception: Prelude.tail: empty list
13:51:33 <hpaste>  sjanssen annotated "passing-primelist-around with Readers" with "written in more typical style" at http://hpaste.org/4736#a1
13:52:42 <sylvan> What's the easiest Haskell web framework if I want to get a site up and running on a site hosted by nearlyfreespeech.net? It supports Haskell CGI (only) but has no web framework installed by default (well, except the standard cgi package). HApps? Hope? WASH? HSP? I'm confused! Which is easiest to install and get up and running with a database connection?
13:53:21 <sylvan> I actually don't care too much about features. I just want it to connect to a database, be easy to install, work with CGI, and let med program in Haskell.
13:56:09 <Lemmih> sylvan: I'd go with plain CGI.
13:56:45 <sylvan> Okay, so how do I connect to the MySQL database with a minimum of pain?
13:56:53 <Lemmih> sylvan: HDBC.
13:57:00 <sylvan> cool, I'll check it out
13:58:02 <Lemmih> sylvan: HAppS is awesomely cool. Unfortunally, it's under heavy development and the last stable release was before the awesomeness as introduced.
13:58:43 <sylvan> Does it work via CGI? I'm looking at a presentation about it and so far it seems like something that requires running a persistent process?
13:59:17 <Lemmih> It'll work with FastCGI.
13:59:57 <Tac-Tics> Seriously.... wtf D-=
13:59:58 <Tac-Tics>     My brain just exploded.
13:59:58 <Tac-Tics>     I can't handle pattern bindings for existentially-quantified constructors.
14:00:10 <sylvan> Ah they don't support that.. They claim its for some fundamental architectual reason, but I don't understand it
14:00:17 <Tac-Tics> Did I just hurt GHCi?
14:00:29 <jsnx> Tac-Tics: what does that look like?
14:01:00 <oerjan> Tac-Tics: existentially-quantified constructors need to matched in a case statement, or as function arguments
14:01:30 <Tac-Tics> oerjan: I sorta get that. I was just wowed by their choice of error message
14:06:01 <glguy> ?seen SyntaxNinja
14:06:01 <lambdabot> SyntaxNinja is in #haskell and #haskell-blah. I last heard SyntaxNinja speak 23m 10s ago.
14:16:44 <FunctorSalad> does anyone know what the "|" here means? "class Monad m => MonadReader r m | m -> r where"
14:17:02 <ibid> yes
14:17:08 <ibid> look up functional dependencies
14:17:10 <dibblego> functional dependency, reads "such that"
14:17:27 <stevie>       /msg nickserv link stevie stevie_
14:20:48 <gbacon> such that what in this case? that there's a function from m to r?
14:21:42 <Sizu1> that r depends on m
14:22:37 <Sizu1> functionally. meaning for one m there can be only one r
14:24:01 <FunctorSalad> Sizu1: hmm. only one r such that...?
14:24:29 <Sizu1> for each m type there can only be one r type
14:25:10 <Sizu1> just like the meaning of (a->b) in a function signature
14:25:29 <Sizu1> except now we have types instead of values
14:25:39 <Sizu1> or rather types are values in this case
14:25:44 <FunctorSalad> "forall m exists exactly one r such that P(m,r)"... what is the predicate P?
14:26:50 <monochrom> that m uses r as m's reader environment.
14:26:59 <ibid> FunctorSalad: at most one, actually
14:27:15 <ibid> FunctorSalad: P(m,r) is "there is an instance MonadReader r m"
14:27:28 <FunctorSalad> ibid: ah, thanks
14:27:40 <ibid> for this particular example, of course
14:28:12 <ibid> FunctorSalad: the point is that the monad determines the type of the state it holds
14:28:15 <FunctorSalad> so this is a constraint on how many implementing types I'm allowed to write.
14:28:45 <ibid> how many instances, yes
14:28:46 <Sizu1> exactly. and it helps the type inferrence
14:29:11 <ibid> multi-parameter classes are relations between types so it doesn't really make sense to say "how many implementing _types_"
14:29:44 <gbacon> FunctorSalad: http://research.microsoft.com/~simonpj/papers/fd-chr/jfp06.pdf
14:31:08 <FunctorSalad> ibid: true, should be "pairs of types"
14:31:45 <gbacon> Functional Dependencies are Tricky (quoth spj)
14:33:10 <FunctorSalad> this type stuff is hard but so far I feel that it's worth it. avoids all these errors of inattention that only show up upon runtime in dynamically typed langs
14:33:52 <Sizu1> category theory is harder for me
14:34:07 <FunctorSalad> I'm even thinking whether one should assign Synonyms just for sanity checks. like "type ListOfPrimes = [Int]"
14:34:14 <FunctorSalad> hmm I had CT at school, which helps
14:34:37 <Sizu1> actually you should do that whenever you can
14:34:40 <FunctorSalad> or newtype, even
14:35:10 <Sizu1> newtypes have restrictions
14:35:53 <FunctorSalad> Sizu1: I mean for the situation where ListOfPrimes should only come from designated prime-producing functions
14:36:10 <FunctorSalad> so you can't pass some other list out of inattention
14:36:12 <Sizu1> and you definitely debug your code before running with haskell :)
14:36:59 <Sizu1> it's better than other languages, but still misses bugs of course
14:37:11 <FunctorSalad> yes. actually I already grew fond of "theorems for free" in CT, before I looked at haskell
14:37:19 <FunctorSalad> so this is really cool for me ;)
14:37:22 <ibid> FunctorSalad: synonyms are invisible to the typechecker, so they help only as documentation. if you want to restrict the values of the type, use newtype (preferably making an abstract type through sepective export from a module)
14:37:47 <FunctorSalad> ibid: yes, I meant newtype but keep mixing them up
14:37:52 <Sizu1> selective*
14:38:02 <DuClare> is there a specific situation in which one should consider using haskell over any other language? what are the strenghts of haskell?
14:39:24 <monochrom> I think "embedded domain specific language" is one.
14:39:39 <smtms> DuClare, see http://www.haskell.org/ for answers of some questions
14:39:40 <lambdabot> Title: Haskell - HaskellWiki
14:41:52 <sylvan> DuClare: "Difficult programs". Really. Many apps are complex without being difficult, Haskell excells when you have to write something that is really tricky (advanced algorithms etc.).
14:41:56 <Sizu1> i like the blend between data and code of list, and wish that somehow for haskell...
14:42:03 <Sizu1> lisp*
14:42:30 <DuClare> actually I was just going to ask how does haskell compare to lisp
14:42:33 <Sizu1> or the purity, type-classes, and laziness for lisp
14:43:10 <DuClare> productivity is claimed high for both haskell and lisp
14:44:10 <sylvan> DuClare, Haskell is statically typed (with an advanced type system), and purely functional. That's probably the main thing. It's also has better performance typically.
14:45:47 <Sizu1> and it looks Beautiful
14:46:01 <Sizu1> but that's in the eye of the beholder
14:47:05 <Sizu1> i find that just by looking at haskell code layout, you can guess what it is about
14:47:09 <sylvan> Yeah, Lisp appeals to me for the simplicity, but I find Haskell's syntax to be really elegant and practical to write and read.
14:48:00 <bparkis> common lisp is actually kind of crufty
14:48:37 <FunctorSalad> That functional programming hasn't really caught on does make me somewhat wary. But maybe it is really better and most people just can't be bothered to learn new abstractions now for a large gain later. dunno
14:48:42 <DuClare> crufty?
14:49:00 <bparkis> yeah it has features left in for compatibility's sake or because of tradition
14:49:10 <bparkis> that reduce its simplicity
14:52:02 <Cale> FunctorSalad: I'm fairly convinced that's basically it.
14:52:23 <Cale> FunctorSalad: and on the other hand, there are upsides to not having too large a userbase :)
14:52:48 <Cale> (In particular, breaking changes to the language are not as large a problem :)
14:53:05 <FunctorSalad> hmm yes, that's a point I didn't consider so far
14:54:50 <markstos> I'm trying to learn some Haskell (from a Perl background). I'm reading through the "Gentle" introduction and related code samples. I'm trying to play with some of the examples in "ghc --interactive". However, I can't figure out how to input a 'data' line into the ghc shell, like: data Day = Sunday | Monday
14:55:21 <SyntaxNinja> @where yaht
14:55:21 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
14:55:42 <SyntaxNinja> markstos: Yet Another Haskell Tutorial is a bit gentler than the gentle introduction
14:55:49 <byorgey> markstos: you can't input data declarations at the ghci prompt.
14:56:00 <LoganCapaldo> markstos: you can't. you must put your data declarations into a file and :load it
14:57:25 <FunctorSalad> sjanssen: thanks a lot for your hpaste reply, didn't notice it. how come the last two functions don't take a primes list anymore? it is a library where the caller is supposed to specify the primelimit
14:57:58 <bart416> somebody join #freenode-newyears
15:00:33 <sjanssen> FunctorSalad: they take primes list implicitly via the Reader Monad
15:02:22 <sjanssen> FunctorSalad: but since the functions don't use the primes list directly (they merely pass it to a deeper invocation of 'splitOffPrimePower'), we don't have to mention it
15:02:35 <sjanssen> this is the point of using Reader :)
15:10:07 <markstos> LoganCapaldo: Ah: that explains it. Thank you!
15:10:38 <LoganCapaldo> markstos: you're welcome
15:11:46 <LoganCapaldo> that reminds me, is : no longer reload? either I'm doing something funky or : by itelf spews out a list of commands in 6.8 instead of reloading
15:13:00 <Korollary> 6.8.1 broke :, 6.8.2 fixed it
15:13:02 <oerjan> hm there was something in the 6.8.2 notes on that
15:13:50 <LoganCapaldo> gtk
15:14:01 <LoganCapaldo> gives me an excuse to upgrade <g>
15:15:13 <LoganCapaldo> thanks Korollary
15:17:54 <FunctorSalad> @karma+ sjanssen
15:17:54 <lambdabot> sjanssen's karma raised to 53.
15:18:05 <FunctorSalad> sjanssen: that's even neater than I thought it would become.
15:18:26 <FunctorSalad> no mention of the Reader at all in phi... wow
15:18:35 <surrounder> happy new year everyone!
15:18:40 <FunctorSalad> \o/
15:18:44 <FunctorSalad> surrounder
15:18:45 <surrounder> o//
15:18:50 <surrounder> FunctorSalad
15:18:51 <oerjan> happy new year!
15:18:56 <surrounder> \o/
15:18:58 <surrounder> oerjan: same to ya
15:19:02 <FunctorSalad> hny oerjan
15:19:38 <FunctorSalad> is there some way to inspect how haskell inferes the type for phi?
15:21:13 <oerjan> apart from :t ?
15:21:38 <FunctorSalad> hmm, don't know if I can :t the intermediaries. but lambdabot's ? notation would prolly help
15:21:59 <FunctorSalad> @vixen happy new year lambdabot
15:22:00 <lambdabot> where on a map is Panama?
15:22:17 <bparkis> so I've seen it claimed (on wikipedia) that the purpose of combinatory logic is to clarify the role of variables by eliminating them
15:22:39 <phobes> free variables?
15:22:47 <bparkis> if that's true, what insight does it provide about the role of variables?
15:22:49 <oerjan> @vixen hey, that's not a palindrome.  you cheated!
15:22:49 <lambdabot> hello
15:23:10 <phobes> it shows you can eliminate them :^)
15:23:42 <bparkis> is that it?
15:23:51 <cognominal_> test
15:24:33 <oerjan> > fail "test"
15:24:34 <lambdabot>   add an instance declaration for (Show (m a))
15:24:50 <FunctorSalad> hmm, a few hours ago she was much more convincing
15:24:53 <FunctorSalad> (lambdabot)
15:24:56 <monochrom> Yeah, combinatory logic is a Turing-complete programming language without any variables whatsoever.
15:25:16 <FunctorSalad> @vixen are you drunk?
15:25:16 <lambdabot> i have not yet begun to defile myself
15:25:19 <monochrom> Is that its only purpose? Gosh, nothing has a unique purpose, ever...
15:25:22 <phobes> You can develop something just like the lambda calculus by where variables are passed "by name" (not meaning not-strict, meaning variables are named).  The fact that this turns out to be pretty much exactly the lambda calculus is interesting
15:25:33 <bparkis> i know i'm saying, does combinatory logic allow us to make any specific statement about the role of variables
15:25:40 <bparkis> besides just "you can get rid of them"
15:25:49 <phobes> but I guess that's not really about combinators
15:26:06 <FunctorSalad> to be honest I don't like combinatory logic much ;)
15:26:16 <FunctorSalad> very obfuscatory
15:26:31 <monochrom> OK, I don't know any further.
15:27:00 <oerjan> well after programming in combinatory logic for a while you can make the specific statement "Variables are darn useful"
15:27:24 <monochrom> Hehe
15:27:35 <phobes> and then after programming in the lambda calculus for a while
15:27:42 <phobes> "Sugar is darn useful"
15:27:49 <FunctorSalad> I'm thinking more and more that clarity is more important than doing some "every x can be represented as an y where y is something with very few primitives but very long"
15:28:06 <monochrom> Absolutely.
15:28:37 <phobes> But those results are often interesting... usually not because "This means we can do away with everything but y!"
15:29:30 <FunctorSalad> yes, I found them fascinating for some time
15:29:32 <monochrom> Thus, for example, I use certain versions of formal logic, but they are much richer than the very primitive Gentzen's, Hilbert's, and EE's "turn everything into and, or, not".
15:29:43 <FunctorSalad> but know I'm into "literate math" ;)
15:29:45 <FunctorSalad> *now
15:30:29 <FunctorSalad> monochrom: yeah I always thought these other logics were pointless since everything can somehow be expressed in predicate calculus
15:30:35 <FunctorSalad> but not anymore...
15:30:43 <monochrom> And so, I use formal logic all the time, and can still be very practical and speedy. This is contrary to most people's conventional wisdom. This is because they have only seen very primitive formal logics, like if you have only seen assembly code, you think programming is undoable.
15:30:59 <FunctorSalad> interesting
15:31:10 <bparkis> what is a variable anyway?
15:31:23 <RayNbow> > reverse "sdnalrehteN eht morf raey wen yppah tub ,etal oot setunim 03"
15:31:25 <lambdabot>  "30 minutes too late, but happy new year from the Netherlands"
15:31:29 <bparkis> besides just a syntactic construct
15:31:36 <phobes> bparkis:  it depends! :P
15:31:42 <LoganCapaldo> mathematicians have real ultimate power. mathematicians flip out and use formal logic all the time!
15:31:55 <FunctorSalad> \o/
15:32:11 <oerjan> @remember monochrom And so, I use formal logic all the time, and can still be very practical and speedy. This is contrary to most people's conventional wisdom. This is because they have only seen very primitive formal logics, like if you have only seen assembly code, you think programming is undoable.
15:32:11 <lambdabot> I will never forget.
15:32:29 <phobes> (until next I'm restarted)
15:32:34 <FunctorSalad> one time this kid dropped a spoon, the mathematician dropped an inaccessible cardinal on the town
15:32:36 <sjanssen> @flush
15:33:36 <FunctorSalad> (that was continuing LoganCapaldo)
15:33:54 <monochrom> That are logicians and programming language theorists who study "what is a variable anyway". I have seen some mention on LtU. But I don't remember any pointer.
15:34:37 <FunctorSalad> hmm, a placeholder for something ;)
15:35:07 <FunctorSalad> (coming full circle naivity -> formal logic -> many formal logics -> colloquial language again...)
15:35:10 <phobes> ya, I remember seeing a paper posted to LtU about 6-9 mo ago I'd guess that claimed to have distilled parameter passing to more fundamental features
15:35:12 * oerjan vaguely recalls someone managing to split up lambda calculus into even more primitive concepts
15:35:21 <oerjan> of naming
15:35:25 <phobes> yes
15:35:38 <phobes> oerjan: I think I'm having vague memories of the same thing
15:35:42 <FunctorSalad> yeah and you can compress the group axioms into one (about division IIRC) ;)
15:35:50 <oerjan> and i think it was LtU too
15:36:43 <phobes> I can compress them all into one axiom ... it's a conjuction...
15:36:46 <oerjan> hm i think i've seen propositional calculus compressed to one axiom
15:36:55 <FunctorSalad> phobes: equational logic
15:37:01 <phobes> ah
15:40:34 <dufflebunk> I have a program that uses a lot of memory. I've no idea how to evaluate what is using it all. Does anyone have any suggestions in how to track it down?
15:40:47 <oerjan> profiling
15:41:24 <dufflebunk> oerjan: Yeah... but so far the output from +RTS hasn't meant a whole lot
15:42:22 <dufflebunk> I just don't know what option to pick or how to interpret the result
15:42:37 <cognominal_> happy new year from Paris
15:42:51 <dufflebunk> Happy new year cognominal_
15:43:20 <cognominal_> to bad there is not a supersonic concord anymore to feat the new year many times
15:43:41 <cognominal_> not that I could have afforded it. But the concept is cool
15:46:41 <lament> cognominal_: if we consider all the options you can't afford, concord wasn't the only one :)
15:47:20 <oerjan> http://haskell.org/haskellwiki/Performance/Space seems like a simple instruction
15:48:27 <oerjan> hm...
15:49:05 <oerjan> > 40000000/86400
15:49:08 <lambdabot>  462.962962962963
15:51:31 <dufflebunk> oerjan: The lines with the information I want has ... cutting off the end of the names
15:52:58 <dufflebunk> But the -auto_all was what I was missing from my previous attempts. Thanks
15:53:47 <oerjan> cannot help any more, alas, haven't used it myself
15:54:23 * oerjan picks up things by channel osmosis
15:54:56 <dufflebunk> hmm, seems to be in the [] type... now I jsut have to figure out what type is /in/ those lists
15:55:34 <FunctorSalad> can lambda list the methods of a class?
15:55:57 <oerjan> if it's in @src
15:56:08 <oerjan> @src Monad
15:56:08 <lambdabot> class  Monad m  where
15:56:08 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:56:08 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:56:08 <lambdabot>     return      :: a -> m a
15:56:08 <lambdabot>     fail        :: String -> m a
15:56:19 <LoganCapaldo> also :i in ghci will tell you the methods of a class
15:56:29 <FunctorSalad> yeah but Int is not in src (I wanted to round)
15:56:36 <oerjan> Int is not a class
15:56:50 <oerjan> @src RealFrac
15:56:50 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
15:56:50 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
15:56:50 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
15:57:14 <FunctorSalad> thanks
15:57:24 <LoganCapaldo> @hoogle round
15:57:24 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
15:57:38 <oerjan> i think :i Int would list the classes Int is in though?
15:59:11 <oerjan> oh, and Int isn't in that class
15:59:26 <oerjan> it's for fractional things
16:00:28 <FunctorSalad> hmm, what is your method for finding such things? (e.g., rounding)
16:00:36 <LoganCapaldo> hoogle!
16:00:52 <LoganCapaldo> this scenario kind of bites though
16:01:00 <oerjan> @hoogle (RealFrac a, Integral b) => a -> b
16:01:00 <LoganCapaldo> @hoogle Double -> Integer
16:01:01 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
16:01:01 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
16:01:01 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
16:01:01 <lambdabot> No matches, try a more general search
16:01:22 <LoganCapaldo> Oh I though hoogle didn't grok classes!
16:01:30 <oerjan> hm not very useful if you don't know the class name
16:01:33 <FunctorSalad> but hoogle needs some identifier that actually exists, doesn't it? I mean, if I search for concept foo but it's called bar in haskell
16:01:33 <LoganCapaldo> is this new?
16:01:43 <oerjan> it's higher-kind classes it doesn't grok
16:01:44 <LoganCapaldo> you can search with types
16:02:01 <LoganCapaldo> @hoogle a -> [a] -> Maybe Int
16:02:01 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
16:02:04 <FunctorSalad> (to myself) well then an automatic search prolly isn't useful in the first place ;)
16:02:21 <LoganCapaldo> which I think is just the coooles
16:02:24 <LoganCapaldo> *coolest
16:02:57 <LoganCapaldo> @hoogle [a] -> Maybe a
16:02:57 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
16:02:58 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
16:03:01 <FunctorSalad> I think an editor with good online library doc referencing would go a long way for newbies
16:03:14 <FunctorSalad> since it breaks the "flow" if you need to go to your browser
16:03:27 <LoganCapaldo> I'm pretty sure theres a hoogle emacs doohicky
16:03:58 <FunctorSalad> hmm, I meant more like a few paragraphs of text about it, hoogle doesn't do it apparently
16:04:29 <LoganCapaldo> if you click it it should take you to the docs
16:04:45 <LoganCapaldo> I presume haddock can spit out not-html
16:05:32 * LoganCapaldo never got into the looking up things in his editor, for whatever reason
16:06:05 <FunctorSalad> @hoogle log
16:06:05 <lambdabot> Prelude.log :: Floating a => a -> a
16:06:05 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
16:06:05 <lambdabot> GHC.Conc.Logoff :: ConsoleEvent
16:07:41 <FunctorSalad> can I be sure that floor (logBase 2 2^n) == n ?
16:07:58 <FunctorSalad> since if log is slightly off downwards, that will fail
16:08:09 <Pseudonym> FunctorSalad: YOu can prove it.
16:08:10 <nolrai> FuctorSalad: personaly I find useing a browser about the same to easer to useing a help doc.
16:08:23 <FunctorSalad> Pseudonym: I was not asking about the math ;)
16:08:32 <Pseudonym> Good luck proving anything about IEEE 754.
16:08:45 <FunctorSalad> yeah
16:09:04 <FunctorSalad> maybe I should add an epsilon.
16:09:43 <oerjan> > floor (1/0)
16:09:46 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
16:09:54 <nolrai> ?
16:09:59 <LoganCapaldo> hehe
16:09:59 <gbacon> @botsnack
16:10:00 <lambdabot> :)
16:10:18 <LoganCapaldo> so those are the first few digits of infinity, eh? :)
16:10:27 <nolrai> > 1/0
16:10:28 <lambdabot>  Infinity
16:10:32 <FunctorSalad> > logBase 2 2^10 -- odd precedence
16:10:32 <lambdabot>  1.0
16:10:42 <oerjan> > floatRange (undefined :: Double)
16:10:42 <lambdabot>  (-1021,1024)
16:10:50 <FunctorSalad> > logBase 2 (2^10)
16:10:50 <lambdabot>  10.0
16:11:01 <LoganCapaldo> FunctorSalad: function application always wins (barring parens)
16:11:23 <oerjan> > all . join ((==).logBase 2 . flip (^)) $ [0..1023]
16:11:24 <lambdabot>  Couldn't match expected type `a -> Bool'
16:11:32 <oerjan> gah
16:11:48 <oerjan> > all . join ((==).logBase 2 . (2^)) $ [0..1023]
16:11:48 <lambdabot>  Couldn't match expected type `a -> Bool'
16:11:53 <FunctorSalad> that's what I had in mind too oerjan
16:12:18 <oerjan> > all (join ((==).logBase 2 . (2^))) $ [0..1023]
16:12:18 <lambdabot>  Add a type signature
16:12:28 <FunctorSalad> > map (\n -> floor (logBase 2 (2^n))) [0..1023]
16:12:29 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:12:51 <oerjan> > all (join ((==).floor.logBase 2 . (2^))) $ [0..1023]
16:12:51 <FunctorSalad> > zipWith == map (\n -> floor (logBase 2 (2^n))) [0..1023] [0..1023]
16:12:52 <lambdabot>  True
16:12:52 <lambdabot>  Couldn't match expected type `[t]
16:12:55 <oerjan> finally
16:13:10 <FunctorSalad> > zipWith (==) map (\n -> floor (logBase 2 (2^n))) [0..1023] [0..1023]
16:13:11 <lambdabot>  Couldn't match expected type `[a]'
16:13:28 <FunctorSalad> > zipWith (==) (map (\n -> floor (logBase 2 (2^n))) [0..1023]) [0..1023]
16:13:29 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
16:13:48 <LoganCapaldo> @check (\xs -> map (\n -> floor (logBase 2 (2 ^ n)) xs == xs)
16:13:49 <lambdabot> Unbalanced parentheses
16:13:50 <oerjan> actually...
16:14:06 <FunctorSalad> > all $ zipWith (==) map (\n -> floor (logBase 3 (3^n))) [0..1023] [0..1023]
16:14:06 <lambdabot>  Couldn't match expected type `[a]'
16:14:11 <LoganCapaldo> @check (\xs -> map (\n -> floor (logBase 2 (2 ^ n))) xs == xs)
16:14:12 <lambdabot>  Add a type signature
16:14:15 <oerjan> > map (\n -> floor (logBase 2 (2^n))) [0..1023] ==  [0..1023]
16:14:16 <lambdabot>  True
16:14:16 <FunctorSalad> > all $ zipWith (==) (map (\n -> floor (logBase 3 (3^n)))) [0..1023] [0..1023]
16:14:16 <lambdabot>  Couldn't match expected type `[a]'
16:14:19 <nolrai> > and [n == (floor . (logBase 2) . (^2)) n | n <- [0..(2^20)]]
16:14:19 <lambdabot>  Add a type signature
16:14:25 <LoganCapaldo> @check (\xs -> map (\n -> floor (logBase 2 (2 ^ n))) xs == xs) :: [Int] -> Bool
16:14:26 <lambdabot>  Exception: Prelude.^: negative exponent
16:14:30 <FunctorSalad> sorry for the spam
16:14:32 <LoganCapaldo> gah
16:14:59 <LoganCapaldo> @check (\xs -> let xs' = map abs xs in map (\n -> floor (logBase 2 (2 ^ n))) xs' == xs') :: [Int] -> Bool
16:15:00 <lambdabot>  OK, passed 500 tests.
16:15:29 <nolrai> > all (\n -> n == (floor . (logBase 2) . (^2)) n) [0..(2^20)]]
16:15:29 <lambdabot>  Parse error at "]" (column 60)
16:15:36 <nolrai> > all (\n -> n == (floor . (logBase 2) . (^2)) n) [0..(2^20)]
16:15:37 <lambdabot>  Add a type signature
16:15:54 <nolrai> > all (\n -> n == (floor . (logBase 2) . (^2)) n) [0..(2^20) :: Int]
16:15:54 <lambdabot>   add an instance declaration for (Floating Int)
16:16:04 <oerjan> nolrai: (2^) not (^2)
16:16:19 <nolrai> > all (\n -> n == (floor . (logBase 2) . (2^)) n) [0..(2^20) :: Int]
16:16:20 <lambdabot>  False
16:16:41 <nolrai> > all (\n -> n == (floor . (logBase 2) . (2^)) n) [0..(2^10) :: Int]
16:16:41 <lambdabot>  False
16:16:49 <oerjan> Double doesn't go up to more than 2^1024
16:16:49 <nolrai> > all (\n -> n == (floor . (logBase 2) . (2^)) n) [0..100 :: Int]
16:16:49 <lambdabot>  True
16:17:07 <nolrai> > all (\n -> n == (floor . (logBase 2) . (2^)) n) [0..2^10 :: Int]
16:17:08 <lambdabot>  False
16:17:13 <oerjan> > 2^1024 == floor(1/0)
16:17:14 <lambdabot>  True
16:17:32 <LoganCapaldo> oh that's right
16:17:45 <LoganCapaldo> DOuble isn't liek Integer
16:17:55 <LoganCapaldo> der
16:18:04 <nolrai> > all (\n -> n == (floor . (logBase 2) . (2^)) n) [0..1024:: Int]
16:18:05 <lambdabot>  False
16:18:09 <nolrai> > all (\n -> n == (floor . (logBase 2) . (2^)) n) [0..10:: Int]
16:18:10 <lambdabot>  True
16:18:15 <nolrai> > all (\n -> n == (floor . (logBase 2) . (2^)) n) [0..1023:: Int]
16:18:15 <lambdabot>  True
16:18:23 <LoganCapaldo> and Rational isn't an instance of floating is it?
16:18:30 <oerjan> indeed not
16:19:05 <oerjan> infinite-precision reals have strange properties
16:19:17 <oerjan> equality is uncomputable for one thing
16:19:28 <nolrai> oh
16:19:30 <LoganCapaldo> point
16:19:35 <LoganCapaldo> good point
16:19:38 <jsnx> @help
16:19:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:19:43 <jsnx> @help tell
16:19:43 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
16:19:51 <FunctorSalad> oerjan: nevermind the problem of even describing them in the first place ;)
16:20:16 <oerjan> well computable reals
16:20:29 <jsnx> @tell Cale I think there is something mixed up in this part of Wikipedia:  http://en.wikipedia.org/wiki/Limit_superior_and_limit_inferior#Sequences_of_sets
16:20:30 <lambdabot> Consider it noted.
16:20:36 <FunctorSalad> hmm in a way they aren't really infinite-precision
16:21:47 <FunctorSalad> jsnx: no, it is correct
16:22:11 <jsnx> FunctorSalad: the infimums are non-decreasing?
16:22:22 <jsnx> FunctorSalad: how, when they are intersections of ever more sets?
16:22:34 <oerjan> lim inf = sup inf
16:22:39 <oerjan> iirc
16:22:51 <jsnx> oerjan: the equations are right
16:23:06 <jsnx> but the statements used to justify them are vague, and i think incorrect
16:23:18 <oerjan> oh right
16:23:28 <FunctorSalad> jsnx: I didn't read it, I meant the defs were right
16:24:15 <jsnx> FunctorSalad: so, check the part that says "The sequence { I_n : n = 1,2,3... } where I_n is the infimum of the nth set...
16:24:21 <jsnx> "
16:24:34 <FunctorSalad> jsnx: a nice intuitive picture is to think of X_m as "the event will happen on day m" and to think of the union as "will eventually happen" and intersection as "will happen every day"
16:24:46 <jsnx> okay, okay
16:24:56 <FunctorSalad> (these things come from probability theory)
16:24:56 <jsnx> but, i am trying to fix the article
16:25:07 <FunctorSalad> sorry :)
16:25:17 <jsnx> FunctorSalad: yes, but they are being presented to me in the context of set theory
16:25:23 <jsnx> that is why i am looking them up :)
16:25:38 <oerjan> jsnx: are you editing it now?
16:25:45 <jsnx> oerjan: not yet
16:25:53 <jsnx> oerjan: i cleaned up the formatting
16:25:54 * oerjan is
16:26:03 <jsnx> oerjan: oh, cool
16:26:30 <FunctorSalad> jsnx: looks correct. they are intersection of ever *less* sets, so it's getting more and mroe
16:26:57 <jsnx> FunctorSalad: well, this part i don't understand
16:27:33 <jsnx> what does "the infimum of the nth set" mean?
16:27:48 <jsnx> do they in fact mean, "the infimum of the first n sets"?
16:27:51 <oerjan> oh wait
16:27:55 <FunctorSalad> I_n = it will always happen starting from day n. if it will always happen starting from day 1, then so for day 2
16:28:12 <FunctorSalad> jsnx: the sets themselves don't have an order. the order is on the set of sets
16:28:17 <oerjan> the intersection is from m=n _upward_
16:28:37 <FunctorSalad> A intersection B is the infimum of {A,B} in the powerset lattice.
16:28:51 <ehird`> map (x . y) z == map x (map y z)
16:28:53 <ehird`> true/false
16:29:13 <jsnx> ehird`: true
16:29:25 <ehird`> then i have some other bug
16:29:52 <jsnx> i agree that the intersection from m=n upward is non-decreasing
16:30:04 <jsnx> but the verbiage before that is pretty vague
16:30:15 <FunctorSalad> jsnx: ah now I see it. yes it is bad
16:30:43 * oerjan cancels his edit
16:30:59 <FunctorSalad> maybe just write I_n := \bigcap_m=n^infty X_m there
16:31:07 <oerjan> i thought it was just a simple reversal, too late in the night for me to think clearly enough
16:31:21 <jsnx> oerjan: where are you?
16:31:28 <oerjan> norway
16:31:39 <oerjan> and happy new year :)
16:32:09 <jsnx> oerjan: you too!
16:32:15 <jsnx> oerjan: i'm in california
16:32:35 <jsnx> we celebrate new year with yoga trance dance
16:32:50 <FunctorSalad> btw, the lim sup is "the event happens infinitely often" and the lim inf is "the event always happens except finitely many times"
16:33:00 <FunctorSalad> gotta admit that is more intuitive than this thing ;)
16:34:09 <FunctorSalad> this is since "infinitely often" == "for every day, will happen again eventually"
16:36:17 * FunctorSalad shuts up now
16:47:27 <jsnx> FunctorSalad: fixed it, i think -- please have a look
16:47:43 <jsnx> oerjan: if you are still up, let me know if it's right
16:48:37 * oerjan is up but his brain isn't
16:49:58 <FunctorSalad> jsnx: maybe it would be more didactic if the cap from 1 to infty was replaced by a generic description of the infimum, since it doesn't have a obvious relation to the following sequence of infs and serves only to explain what an inf in P(X) is
16:50:33 <jsnx> FunctorSalad: hmmm
16:50:38 <jsnx> what should it say, then?
16:51:08 <jsnx> with my edit, i only hoped to clear up some vague material...you are suggesting a larger change, i take it
16:51:27 <FunctorSalad> jsnx: yes, your edit is good, it was an additional suggestion
16:51:42 <jsnx> FunctorSalad: okay, thanks
16:51:46 <FunctorSalad> something like "the infimum of a family of sets is the intersection of all these sets"
16:51:55 <jsnx> ah, yes
16:52:06 <jsnx> i think that whole article is a little notation heavy
16:52:39 <jsnx> the verbal explanations are lacking
16:54:03 <jsnx> as i get further into the book, i'll surely do more for math on wikipedia
17:17:23 <glen_quagmire> what's a better book for practical application development:  soe or programming in haskell?  something like blah cookbook series
17:18:22 <izuker> quick question:
17:18:28 <izuker> i have a type constructor Dist a
17:18:38 <izuker> can i not do:
17:18:58 <izuker> instance Show Dist Int where ...
17:18:58 <izuker> ?
17:19:06 <opqdonut> Show (Dist Int)
17:19:17 <glen_quagmire> i do data Dist a derives Show or something
17:19:25 <glen_quagmire> i'm a noob . i'm a trap
17:19:50 <opqdonut> well soe is like a case studt
17:19:54 <opqdonut> *study
17:20:01 <izuker> newtype Dist a = D { unD :: ( a -> Float ) -> Float }
17:20:07 <opqdonut> more than a reference or coursebook
17:20:25 <izuker> ok, next question:
17:21:33 <glen_quagmire> opqdonut: i think i'll order soe
17:21:42 <izuker> newtype Gift = Gift { value :: Float }
17:21:52 <izuker> with instance Show ( Dist Gift ) I get:
17:22:03 <glen_quagmire> but some said programming in haskell is KnR of haskell
17:22:06 <izuker> Illegal instance declaration for `Show (Dist Gift)'
17:22:15 <izuker> (The instance type must be of form (T a b c)
17:22:21 <izuker> where T is not a synonym, and a,b,c are distinct type variables)
17:22:31 <izuker> is the problem with Gift ?
17:22:35 <LoganCapaldo>  you need flexible insances
17:22:50 <LoganCapaldo> or
17:23:23 <LoganCapaldo> instance (Show a) => Show (Dist a) and define an instance of show for gift
17:24:14 <izuker> but "Dist a" only has a show for a few a
17:24:25 <izuker> i need to define a dummy class "ShowableInDist" ?
17:24:25 <LoganCapaldo> -XFlexibleInstances or {-# LANGUAGE FlexibleInstances #-} if you go that route
17:24:44 <LoganCapaldo> it's an extension
17:25:33 <LoganCapaldo> hmm a dummy class would be another possibility if you didn't want Gift to be an instance of Show and didn't want to use a language extension
17:25:43 <LoganCapaldo> or
17:25:49 <LoganCapaldo> you can use a newtype
17:26:10 <izuker> Gift *is* an instance of Show
17:26:15 <LoganCapaldo> newtype DistGift = DG (Dist Gift) instance Show DistGift ...
17:26:19 <LoganCapaldo> right
17:26:21 <LoganCapaldo> ok
17:26:24 <izuker> but Show a isn't enough to generate Show ( Dist a )
17:27:05 <izuker> DistGift seems a hack... but I'll use it if it works
17:27:06 <LoganCapaldo> If you want to "dispatch" on a, you need to use FlexibleInstances
17:27:43 <LoganCapaldo> (or one of those other options)
17:28:07 <izuker> excellent, thanks!
17:29:04 <monochrom> Haskell 98 does not allow "instance Show (Dist Gift)" or "instance Show [Gift]" or "instance Show (Maybe Gift)", etc. It is now allowed, period.
17:29:14 <monochrom> s/now/not/
17:29:31 <monochrom> (Gosh, I hate that kind of now<->not typo)
17:29:59 <jsnx> monochrom: but is allows with overlapping instances, right?
17:29:59 <LoganCapaldo> maybe I should have started with that sentence <g>
17:30:06 <FunctorSalad> is there Epsilon in haskell?
17:30:13 <FunctorSalad> (machine precision)
17:30:17 <LoganCapaldo> @hoogle epsilon
17:30:17 <lambdabot> No matches found
17:30:19 <FunctorSalad> for doubles
17:30:37 <monochrom> I don't know for sure what overlapping instances allows, but probably yes.
17:31:02 <monochrom> @info Floating
17:31:02 <lambdabot> Floating
17:31:13 <LoganCapaldo> @src Floating
17:31:13 <lambdabot> class  (Fractional a) => Floating a  where
17:31:13 <lambdabot>     pi                                                      :: a
17:31:13 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
17:31:13 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
17:31:13 <lambdabot>     (**), logBase                                           :: a -> a -> a
17:31:17 <nolrai> @src sequence
17:31:17 <lambdabot> sequence ms = foldr k (return []) ms
17:31:17 <lambdabot>     where
17:31:19 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
17:31:25 <monochrom> Oh, it's in RealFloat.
17:31:30 <monochrom> @src RealFloat
17:31:30 <lambdabot> Source not found. My pet ferret can type better than you!
17:31:34 <LoganCapaldo> blast
17:31:40 <LoganCapaldo> pet ferret strike again
17:32:29 <monochrom> Look into RealFloat. Some of its methods help you deduce machine epsilon.
17:33:26 <FunctorSalad> am I remembering epsilon correctly?
17:33:28 <FunctorSalad> >  head $ [n | n <- [1..], 1+(2**(-n))==1]
17:33:31 <lambdabot>  64.0
17:33:36 <FunctorSalad> this should be it, no?
17:33:58 <FunctorSalad> on my computer it's only 53 :'(
17:34:09 <FunctorSalad> where is lambdabot running?
17:34:31 <monochrom> > 2**(-64)
17:34:32 <lambdabot>  5.421010862427522e-20
17:34:35 <LoganCapaldo> @version
17:34:35 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
17:34:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:35:02 <aFlag> on my computer it's 53 as well
17:35:34 <FunctorSalad> I think I will use something slightly larger for safety though
17:36:03 <FunctorSalad> since I'm not a numerical analyst
17:37:09 <aFlag> > [n | n <- [1..], 1+(2**(-n))==1] !! 11
17:37:10 <lambdabot>  75.0
17:37:18 <aFlag> on my computer that's 64
17:37:51 <aFlag> so I guess I'm 11 behind.
17:37:51 <FunctorSalad> ?
17:38:04 <FunctorSalad> ah
17:38:22 <FunctorSalad> well, nothing exciting there after the head
17:38:27 <FunctorSalad> > [n | n <- [1..], 1+(2**(-n))==1]
17:38:28 <lambdabot>  [64.0,65.0,66.0,67.0,68.0,69.0,70.0,71.0,72.0,73.0,74.0,75.0,76.0,77.0,78.0,...
17:39:00 <monochrom> It is very likely up to how you built GHC.
17:39:43 <FunctorSalad> monochrom: furthermore, I tried it in ghci
17:39:46 <Cale> >  head $ [n | n <- [1..], 2+(2**(-n))==2]
17:39:46 <lambdabot>  63.0
17:39:47 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:39:55 <aFlag> here both 2**(-64) and 2**(-53) equals to one
17:40:10 <aFlag> I mean
17:40:15 <aFlag> 2**(-64)+1
17:40:21 <aFlag> and 2**(-53)+1
17:40:52 <monochrom> Right, ghci makes a difference. ghc -O2 gives 64.
17:40:55 <FunctorSalad> hny Cale :)
17:41:17 <Cale> hy FunctorSalad :)
17:41:29 <FunctorSalad> hehe
17:41:33 <aFlag> I guess the floating point precision is not good enough here?
17:41:38 <monochrom> Your use of eta is much appropriate :)
17:41:54 <FunctorSalad> nu would be more phonetic though
17:42:01 <FunctorSalad> (my scim is broken)
17:42:49 <Cale> I have not only scim, but set things up so that both alt keys will switch my keyboard between US and Greek layout.
17:43:14 <Cale> If you're running Gnome, that's pretty easy to do :)
17:43:25 <aFlag> in that case, is ghc using double or float?
17:44:36 <FunctorSalad> I don't know the hotkey in KDE for that, which doesn't mean that I never hit it -.-
17:44:42 <Cale> jsnx: The suprema are non-increasing, and the infima are non-decreasing.
17:44:59 <FunctorSalad> there it is: hy!
17:45:00 <Cale> Usually you have to set it up explicitly.
17:45:01 <monochrom> Float is out of the question.
17:45:15 <Cale> vv
17:45:22 <monochrom> > (head $ [n | n <- [1..], 2+(2**(-n))==2]) :: Float
17:45:24 <lambdabot>  63.0
17:45:48 <monochrom> > (head $ [n | n <- [1..], 2+(2**(-n))==2]) :: Double
17:45:49 <lambdabot>  63.0
17:45:55 <Cale> >  [head $ [n | n <- [1..], k+(2**(-n))==k] | k <- [0..10]]
17:45:56 <lambdabot>  [1075.0,64.0,63.0,63.0,62.0,62.0,62.0,62.0,61.0,61.0,61.0]
17:46:10 <FunctorSalad> hehe
17:46:30 <FunctorSalad> for 0 it can adjust the exponent
17:46:36 <Cale> right :)
17:47:12 <jaredj> FunctorSalad: i like it the  way better?
17:47:17 <Cale> [1075.0,53.0,52.0,52.0,51.0,51.0,51.0,51.0,50.0,50.0,50.0] -- on my machine
17:47:50 <Cale> -wave -sic
17:48:24 <jaredj> "Ni! -- ! -- No, it's 'ni.'"
17:48:32 <FunctorSalad> *g*
17:50:21 <FunctorSalad> maybe lambdabot has one of these 80bit-double things
17:50:35 <FunctorSalad> I guess 53 should be 64-bit doubles
17:51:05 <ac> @src replicateM
17:51:05 <lambdabot> replicateM n x = sequence (replicate n x)
17:51:16 <monochrom> ghc -O0 gives 53. -O2 gives 64.
17:51:37 <ac> > randomRIO ('a','z')
17:51:37 <lambdabot>  <IO Char>
17:52:24 <ac> > liftM putStr $ replicateM 4 $ randomRIO ('a','z')
17:52:25 <lambdabot>  <IO (IO ())>
17:52:27 <monochrom> Certain optimization eliminates intermediate redundant floating-point load-store.
17:52:56 <monochrom> That means you will be using the full 80-bit internal x86 registers.
17:53:41 <monochrom> Unfortunately, I am unable to control that with -fexcess-precision and -fno-excess-precision, which is supposed to be the flag controlling that.
17:53:47 <ac> why doesn't putStr work with liftM?
17:54:08 <monochrom> ghc -O0 -fexcess-precision still gives 53. ghc -O2 -fno-excess-precision still gives 64.
17:54:49 <FunctorSalad> monochrom: again, we see I have no idea what I'm talking about ;)
17:55:06 <bos> ac: what would you expect it to do?
17:55:10 <FunctorSalad> didn't know there were different float registers
17:55:11 <monochrom> Oh good, ghc -O2 -fvia-C -fno-excess-precision works as advertised, gives 53.
17:55:45 <monochrom> All 8 registers in x86's FPU are full 80-bit.
17:56:03 <ac> > putStr "foo"
17:56:04 <lambdabot>  <IO ()>
17:56:13 <FunctorSalad> monochrom: and the values are later loaded into a regular CPU register?
17:56:44 <monochrom> No. All computations are done in those 8 registers.
17:56:52 <monochrom> All floating point computations, of course.
17:56:54 <ac> bos: I would expect 'liftM putStrLn (return "foo")' to print "foo" but it does nothing
17:56:58 <FunctorSalad> hmm. and where is it reduced to 64bit?
17:58:06 <monochrom> Only way to get truncation: you send an instruction that says truncate, or you transfer a register to memory saying "the memory is a Double-type variable".
17:58:07 <LoganCapaldo> @type liftM putStrLn
17:58:07 <lambdabot> forall (m :: * -> *). (Monad m) => m String -> m (IO ())
17:58:27 <monochrom> Therefore all intermediate arithmetic steps are done in full 80bit.
17:58:31 <LoganCapaldo> ac: I think you are looking for >>=
17:58:41 <LoganCapaldo> return "foo" >>= putStrLn
17:58:45 <FunctorSalad> monochrom: silly me, forgot about RAM. there it is only given 64 bit, then
17:59:11 <FunctorSalad> (I think)
17:59:19 <monochrom> Yeah, all load/store instructions says "this is Double" or "this is Float" etc.
17:59:33 <FunctorSalad> ok and the optimization somehow makes sure the == is done before the value leaves the CPU
17:59:38 <ac> LoganCapaldo: I've used that before, just trying to understand liftM
17:59:59 <FunctorSalad> @karma+ monochrom
17:59:59 <lambdabot> monochrom's karma raised to 18.
18:00:56 <monochrom> Assembly code is strongly typed too!
18:01:07 <monochrom> (Only there is little checking :) )
18:01:24 <LoganCapaldo> ac: liftM is for pure functions, mostly, taking a function from a -> b to m a -> m b
18:01:32 <LoganCapaldo> putStrLn is a -> m b
18:01:43 <dibblego> ?type mapM_
18:01:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
18:01:46 <LoganCapaldo> so when you liftM it you get m a -> m (m b)
18:02:02 <ac> you get some sort of funky nested IO monad
18:02:02 <FunctorSalad> hmm, ghci apparently doesn't look for modules in the current dir
18:02:25 <ac> is it ever useful to have a type of IO (IO ...)?
18:02:36 <FunctorSalad> you can flatten it with join
18:02:41 * LoganCapaldo is glossing over some details, before anyone jumps down my throat
18:02:42 <dibblego> ac, just use join
18:03:02 <FunctorSalad> > join [[1]]
18:03:04 <lambdabot>  [1]
18:03:11 <conal> ac: sure.  e.g., reading an action-valued ref
18:03:11 <ac> nifty
18:03:15 <idnar> > join Just Just 5
18:03:16 <lambdabot>  Couldn't match expected type `a -> t1 -> t'
18:03:20 <idnar> > join (Just Just 5)
18:03:21 <lambdabot>  Couldn't match expected type `t -> m (m a)'
18:03:29 <idnar> > join Just (Just 5)
18:03:29 <lambdabot>  Couldn't match expected type `(->) a' against inferred type `Maybe'
18:03:30 <dibblego> > join (Just (Just 5))
18:03:30 <lambdabot>  Just 5
18:03:35 <idnar> argh!
18:03:37 <FunctorSalad> \o/
18:03:37 <ac> > join $ liftM putStr $ replicateM 4 $ randomRIO ('a','z')
18:03:38 <lambdabot>  <IO ()>
18:03:57 <ac> cool :-)
18:04:11 <FunctorSalad> ac: as was said, liftM is meant for pure functions. e.g. I think liftM f = map f for the list monad
18:04:34 <FunctorSalad> > (liftM (*2)) [1 .. 5]
18:04:34 <lambdabot>  [2,4,6,8,10]
18:04:43 <ac> but that line of code works
18:04:53 <FunctorSalad> > (liftM (*2)) (Just 5)
18:04:54 <lambdabot>  Just 10
18:05:10 <FunctorSalad> ac yes it works, I meant that's the reason why you have to go via join
18:05:12 <idnar> liftM is fmap
18:05:58 <FunctorSalad> almost
18:06:23 <ac> why doesn't lambdabot display stdout?
18:06:27 <FunctorSalad> fmap is for functors and liftM for monads, no?
18:06:39 <dibblego> FunctorSalad, all monads are also functors
18:06:43 <FunctorSalad> ac: I think it was missing the input
18:06:56 <FunctorSalad> dibblego: yes
18:07:22 <FunctorSalad> ac: or wait, that thing on the right doesn't take stdin, does it?
18:07:24 <dibblego> FunctorSalad, therefore, liftM is for all functors and is equivalent to fmap
18:07:24 <sjanssen> dibblego: except in Haskell :(
18:07:34 <ac> > putStrLn "hello..."
18:07:34 <lambdabot>  <IO ()>
18:07:37 <FunctorSalad> dibblego: not all functors are monads
18:08:07 <FunctorSalad> sjanssen: what's different in haskell?
18:08:13 <fxr> happy new year #haskell
18:08:27 <dibblego> ?type \m f -> join (fmap f m)
18:08:28 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a -> (a -> m a1) -> m a1
18:08:57 <sjanssen> FunctorSalad: Haskell doesn't force you to write a Functor instance for every Monad
18:09:06 <sjanssen> this is quite controversial
18:09:12 <FunctorSalad> dibblego: maybe you are right in that for Monads, liftM is defined as fmap
18:09:33 <FunctorSalad> sjanssen: why isn't Monad just a subclass of Functor?
18:09:36 <idnar> well, fmap should suffice, because every monad should also be a functor
18:09:43 <sjanssen> FunctorSalad: it is a mystery
18:09:44 <idnar> (except, as sjanssen mentions, it's not like that in Haskell)
18:09:57 <bos> every monad should be a functor, but happens not to be for historical reasons.
18:10:08 <FunctorSalad> btw, can I define Monads in the unit, join, fmap style?
18:10:13 <dibblego> ?check \f xs -> fmap f xs == (liftM f (xs :: [Int])) :: [Int]
18:10:14 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `Bool'
18:10:23 <bos> FunctorSalad: not usefully.
18:10:27 <dibblego> ?check \f xs -> fmap f xs == liftM f (xs :: [Int])
18:10:28 <lambdabot>  Add a type signature
18:10:35 <sjanssen> FunctorSalad: not directly (join isn't in the Monad class), but you can do it by hand
18:10:37 <FunctorSalad> bos: why?
18:10:45 <bos> the Monad typeclass really wants bind and unit
18:10:46 <dibblego> ?check \f xs -> fmap f xs == liftM (f :: Int -> [Int]) (xs :: [Int])
18:10:49 <lambdabot>  OK, passed 500 tests.
18:10:57 <LoganCapaldo> liftM isn't part f the class
18:11:21 <sjanssen> eg. myjoin = ...; instance Monad MyType where m >>= f = join $ fmap f m
18:11:27 <FunctorSalad> I guess I could define a UnitJoinFmapMonad which instantiates Monad?
18:11:31 <bos> so you can write map and join, but then you have to glue them together
18:11:34 <sjanssen> erm, myjoin $ fmap f m
18:12:07 <bos> FunctorSalad: yes, but you won't be able to use it with e.g. do notation
18:12:23 <FunctorSalad> bos: if it instantiates Monad, I should
18:12:24 <bos> well, if it's a subclass of monad you will
18:12:28 <bos> ha.
18:12:28 <FunctorSalad> :)
18:12:50 <FunctorSalad> bos: I thought maybe sometimes it could be clearer
18:12:57 <bos> oh sure.
18:13:12 <ac> so I read somewhere that in the latest version of GHC they reorganized the type classes for numbers a little bit
18:13:26 <sjanssen> ac: that hasn't happened AFAIK
18:13:36 <ac> sjanssen: is it planned?
18:13:43 <sjanssen> I doubt it
18:13:52 <bos> ac: the typeclasses are standardised
18:13:57 <ac> why isn't there a type class for groups and rings?
18:14:17 <sjanssen> ac: we're a bit locked in by the standard
18:14:18 <bos> ac: write one yourself?
18:14:22 <FunctorSalad> :)
18:14:26 <sjanssen> same story with Functor/Monad/Applicative
18:15:01 <bos> the numeric typeclass hierarchy is byzantine and confusing, but i doubt it will ever change.
18:15:01 * sjanssen wants Haskell' !
18:15:17 <dibblego> same
18:15:18 * LoganCapaldo wants Haskell 1.4
18:15:25 <sjanssen> bos: I think it's very practical
18:15:28 <LoganCapaldo> I keed Ikeed
18:16:09 <sjanssen> bos: I'd only change minor things (like the Show and Eq superclass on Num)
18:16:13 <bos> sjanssen: i don't use some aspects of it often enough to keep much of it in my head
18:16:37 <sjanssen> conversions are sometimes difficult to remember
18:16:47 <bos> sjanssen: for example, i can never remember what function i should call to turn a Float into a Double, or which member of the FP hierarchy i should be looking in.
18:16:51 <sjanssen> 15 seconds to answer: how do you convert a CFloat to a Float?
18:17:06 <bos> fromWibble . toNerfle
18:17:16 <markstos> newbie question: I'm having trouble finding the documentation for "Just". Any hints?
18:17:24 <bos> markstos: Data.Maybe
18:17:32 <sjanssen> @type fromRational . toRational
18:17:34 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
18:17:45 <sjanssen> that should be easier
18:17:45 <bos> markstos: it's just a value constructor, there's no documentation to speak of
18:18:02 <ac> markstos: data Maybe a = Just a | Nothing
18:18:12 <ac> (is that correct ppl?)
18:18:19 <bos> yes
18:18:37 <ac> (just making sure)
18:18:46 <FunctorSalad> wow, ".Hs" files majorly mess ghci up
18:18:49 <FunctorSalad> (big H)
18:19:03 <FunctorSalad> they even prevent the ".hs" file with the same name from working properly
18:19:05 <sjanssen> @src Maybe
18:19:06 <lambdabot> data Maybe a = Nothing | Just a
18:19:19 <sjanssen> ac: no, you're backwards!!!!!
18:19:21 <ac> nooooooo
18:20:51 <FunctorSalad> or wait, ghci still doesn't find a file that obviously exists
18:21:06 <markstos> bos: Thanks... I still don't understand what Just returns, but I probably need to keep reading beginner tutorials.
18:21:21 <bos> markstos: it returns a Maybe value.
18:21:28 <Sizu1> markstos: Just constructs a value of type Maybe
18:21:39 <bos> markstos: there are two kinds of constructor: type constructors and data constructors.
18:21:41 <markstos> Ah, Ok. I think I see.
18:21:50 <allbery_b> :t Just
18:21:52 <lambdabot> forall a. a -> Maybe a
18:22:01 <bos> markstos: so Just is a data constructor, and it wraps your type in a Maybe type constructor
18:22:13 <kpreid> ac: incidentally, the order matters, for the derived Ord instance
18:22:32 <markstos> bos: I believe I understand well enough to proceed now. Thanks!
18:22:34 <kpreid> ac: forall x. Nothing < Just x
18:22:49 <kpreid> (Ord and Enum, actually)
18:23:32 <gbacon> markstos: everything that's a Maybe is either Just <something> or Nothing
18:23:38 <ac> kpreid: interesting. I'm a ways away from generics
18:23:53 <markstos> everyone: Thanks. I'm working towards creating my first Haskell patch for darcs. :)
18:23:59 <kpreid> ac: generics are something else; this is all Haskell 98
18:24:11 <gbacon> markstos: strong start :-)
18:24:21 <ac> kpreid: isn't "deriving Foo" equivalent to generic programming?
18:24:41 <kpreid> maybe. I don't recall that term.
18:24:45 <bos> markstos: keep at it :-)  it will all click together pretty soon.
18:24:46 <ac> markstos: I started with "Hello World" I think
18:25:00 <ac> :P
18:25:10 <bos> automatic deriving isn't really equivalent to generic programming.
18:25:33 <ac> bos: is there a more general purpose form of that?
18:25:40 <ac> bos: that doesn't envolve built in types I mean
18:25:55 <bos> ac: yeah, see the "scrap your boilerplate" research papers
18:25:58 <ac> *involve
18:26:08 <bos> they talk about how to do generic programming in haskell.
18:26:22 <ac> bos: but you just said they weren't equivalent
18:26:57 <kpreid> ac: SYB is not deriving.
18:28:03 <ac> similar concept though, no? So far I haven't written any haskell code that involves complicated enough custom types to warrant such things, so I haven't looked in to it
18:30:12 <bos> kpreid: i know, but SYB requires the use of deriving Typeable
18:30:29 <bos> ac: they're related, but not the same thing
18:30:58 <jsnx> SYB gives me horrible memories alexandrescu's book
18:31:10 <jsnx> (the one on c++ templates)
18:31:31 <bos> SYB is ok. SYB With Class is nicer.
18:31:35 <idnar> that book was awesome
18:31:41 <jsnx> yes
18:32:14 <jsnx> but it was awesome because it was totally esoteric
18:33:28 <idnar> awesome in the "wow, this razor is awesome, I can't feel a thing when I use it to slit my wrists" sense ;)
18:34:08 <jsnx> idnar: i think that's pretty close :)
18:34:23 <jsnx> idnar: or like, wow, those explosions are big...better not go over there!
18:36:12 <dufflebunk> I don't suppose there's a functio nthat does the opposite of Monad.sequence: m [a] -> [m a] ?
18:36:32 <FunctorSalad> idnar: what kind of razor would have that property?
18:36:34 <jsnx> :t sequence
18:36:37 <Cale> dufflebunk: Such a function can exist, but is awkward at best.
18:36:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:36:54 <LoganCapaldo> @type (>>= . map return)
18:36:54 <lambdabot> parse error on input `.'
18:37:07 <LoganCapaldo> @type (>>=  map return)
18:37:07 <lambdabot> forall a (m :: * -> *). (Monad m) => [[a]] -> [m a]
18:37:11 <idnar> FunctorSalad: an extremely sharp one
18:37:12 <jsnx> FunctorSalad: laser razor
18:37:28 <LoganCapaldo> let m = [] :)
18:37:30 <Cale> dufflebunk: For example, antisequence x = [fmap (!!n) x | n <- [0..]]
18:38:04 <FunctorSalad> because not so many nerves are hit?
18:38:04 <Cale> That's about the best you can do. Note that if the list returned is actually finite, you'll end up with infinitely many undefined elements.
18:38:07 <idnar> @type antisequence x = [fmap (!!n) x | n <- [0..]]
18:38:07 <lambdabot> parse error on input `='
18:38:15 <idnar> @type [fmap (!!n) x | n <- [0..]]
18:38:16 <lambdabot> Not in scope: `x'
18:38:21 <idnar> @type [fmap (!!n) ?x | n <- [0..]]
18:38:22 <lambdabot> forall a (f :: * -> *). (?x::f [a], Functor f) => [f a]
18:38:33 <dufflebunk> Cale: No, it's an infinite list.
18:38:44 <jsnx> FunctorSalad: or they are cut while registering their message :)
18:39:06 <idnar> @type (>>= fmap return)
18:39:07 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f, Monad f) => f (f a) -> f (m a)
18:39:10 <FunctorSalad> jsnx: hmm I guess the impulse is way faster
18:39:18 <idnar> @type (>>= liftM return)
18:39:19 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (m1 a1) -> m1 (m a1)
18:39:22 <Cale> dufflebunk: The other thing to worry about is that each action in the list is actually going to carry out x when executed, so as you run each of them, the effects will be repeated.
18:39:47 <jsnx> FunctorSalad: it's slower than you think...but i can't remember how slow
18:39:53 <Cale> Also, xs !! n is O(n)
18:40:24 <FunctorSalad> jsnx: think this was related to this myelin sheath thingy (with myelin sheath it's faster)
18:40:27 <idnar> FunctorSalad: yeah, pretty much
18:41:15 <idnar> the less you mangle the tissue, the less pain is likely to be experienced
18:41:58 <idnar> eg. if you have an injection in your arm or whatever, you shouldn't even really feel the needle going in if they're doing it right
18:42:57 <dufflebunk> Cale: hmm, perhaps I've completely misunderstood the basic monad stuff then.
18:44:41 <dufflebunk> I picked a prime number generator to try to learn more about monads. The stuff hidden in the monad is a cache of previous primes found which are used to generate more. They aren't actions.
18:45:36 <dufflebunk> http://dufflebunk.homeip.net/~dufflebunk/poor.lhs is a (not quite up to date) version of what I'm trying to do
18:48:47 <faxathisia> Hi
18:49:05 <ac> @src Rational
18:49:05 <lambdabot> type Rational = Ratio Integer
18:49:13 <ac> @src Ratio
18:49:13 <lambdabot> data (Integral a) => Ratio a = !a :% !a
18:49:19 <faxathisia> anyone used Agda2s parser for some other language?
18:49:25 <faxathisia> just wondering
18:49:43 <ac> faxathisia: no, but mind if I ask you about agda?
18:49:54 <faxathisia> I don't know much but sure
18:50:09 <ac> faxathisia: I haven't bothered to download it and play with it. Just want to know what it's like
18:50:16 <faxathisia> I never tried Agda
18:50:39 <faxathisia> Agda2 is looking really cool though
18:50:39 <faxathisia> mm I think you should read some of,
18:50:41 <faxathisia> The proofs here http://www.iis.sinica.edu.tw/~scm/
18:50:42 <lambdabot> Title: Home | Shin-Cheng Mu
18:51:30 <ac> specifically I'm interested in Alfa
18:51:39 <faxathisia> Why?
18:51:53 <faxathisia> I mean I can see why someone might, but in particular?
18:54:02 <FunctorSalad> ghc on acid: "No lambdabot process" :(
18:54:35 <ac> faxathisia: the description just sounds intriguing
18:54:50 <ac> http://www.cs.chalmers.se/~hallgren/Alfa/features.html
18:54:51 <lambdabot> Title: Features of Alfa
18:56:42 <faxathisia> hey
18:56:57 <faxathisia> ac, do you know where I might learn enough about type theory to get why Type : Type leads to inconsistency?
18:57:07 <ac> hell no
19:01:13 <ac> faxathisia: I don't even know what dependent types are
19:03:34 <faxathisia> ac; I think that if you have like type a -> b, in dependant types you can have the type b depend on the value of whatever was passed in (of type a), so instead of arrow they use x:a. b, and b be some expression using x
19:04:07 <faxathisia> ac; But I keep seeing that * :: * is inconsistent and not understand why :/
19:04:33 <ac> @src mapM
19:04:34 <lambdabot> mapM f as = sequence (map f as)
19:04:50 <ac> thought so :-)
19:06:13 <ac> how do I find the associativity of operators?
19:06:23 <bos> :info (+) in ghci
19:06:28 <ac> thanks
19:06:53 <ac> is there a left associative version of (.)?
19:08:39 <bos> i don't know.
19:08:50 <ac> 'twould be handy at the moment
19:09:22 <FunctorSalad> huh? isn't (.) associative
19:09:35 <FunctorSalad> (in math it definately is)
19:09:51 <FunctorSalad> :t (.)
19:09:53 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:10:07 <ac> @hoogle (b -> c) -> (a -> b) -> a -> c
19:10:09 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
19:10:09 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
19:10:09 <lambdabot> Control.Parallel.Strategies.(.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
19:10:09 <FunctorSalad> no tricks there. this is surely associative
19:10:15 <clanehin> ac: the Arrow instance for (->)
19:10:53 <FunctorSalad> ok guys, think I will go to the city now that it's 4am ;)
19:10:53 <clanehin> erm, I think I misread the question
19:11:46 <clanehin> I'm a little confused about what you mean, a different associativity in this case would seem to mean the arguments are reversed also
19:12:08 <clanehin> do you want flip (.)  ?
19:12:24 * faxathisia starts to think it might be easier to write a parser from scratch :"\
19:12:49 <EuphoriaSalad> clanehin: different associativity is just (f . g) . h vs f . (g .h) I think, which are equal
19:13:31 <EuphoriaSalad> or am I totally missing the point?
19:13:47 <clanehin> EuphoriaSalad: yeah, but that seems so useless that my brain jumped to a conclusion
19:14:14 <ac> I like to ask stupid questions
19:14:26 <EuphoriaSalad> clanehin: hmm, not exactly useless, it's a basic axiom of CT, but I know what you mean ;)
19:15:52 <faxathisia> sorry what CT stand for?
19:16:09 <ac> category theory
19:16:14 <faxathisia> oh right
19:19:36 <EuphoriaSalad> afk now... happy new year to you guys across the ocean in advance :)
19:19:51 <ac> huh. when you run a haskell program it's the equivalent of "show main >>= putStrLn"
19:19:55 <jmorrison> Happy new year y'all
19:20:18 <jmorrison> Anyone here familiar with c2hs?
19:22:48 <kpreid> ac: only if main's type is not IO ()
19:23:09 <kpreid> ac: and you mean "main >>= print"
19:23:19 <kpreid> ac: and, iirc, this is a ghc thing
19:23:31 <ac> @src print
19:23:31 <lambdabot> print x = putStrLn (show x)
19:23:46 <ac> that's nice to know
19:24:01 <kpreid> ac: ("show main" doesn't mean what you want)
19:24:10 <ac> I want a haskell editor that automatically simplifies expressions like that
19:24:38 <faxathisia> Why?
19:25:03 <ac> because I haven't memorized all of these functions
19:27:22 <ac> (yes, it would be a not-very-useful gimmick)
19:29:02 <jmorrison> Anyone here familiar with c2hs?
19:29:17 <ac> jmorrison: apparently not. what is it?
19:30:01 <jmorrison> it's a C to Haskell binding generator used by the gtk binding amongst other things
19:30:35 <jmorrison> I'm trying to figure out how to get it to bind a C typedef of a function type
19:31:16 <pgavin> jmorrison: what's the problem?
19:31:18 <faxathisia> if you are on POSIX, you could maybe use void * instead of func trs
19:31:39 <jmorrison> like typedef int custard(char rhubarb)
19:31:41 <ac> what's the difference between List and Data.List?
19:32:15 <pgavin> jmorrison: you probably mean: typedef int (*custard) (char rhubarb)
19:32:33 <allbery_b> ac: Char is the Haskell98-compatible name
19:32:47 <allbery_b> (H98 doesn't have hierarchical libraries)
19:33:07 <jmorrison> pgavin: the exact call is: typedef int  nfq_callback(struct nfq_q_handle *gh, struct nfgenmsg *nfmsg, struct nfq_data *nfad, void *data);
19:33:30 <jz87_> hey I have a question about type class definition
19:34:01 <jz87_> I'm trying to define a shorthand for a type that is instance of both Read and Show
19:34:13 <jz87_> I want to define class (Read a, Show a) => Message a
19:34:19 <pgavin> ok, you'd probably want to use something like:
19:34:32 <jz87_> so I don't have to type (Read a, Show a) => everywhere
19:34:49 <dufflebunk> Could someone try to compile something ghc and tell me if it succeeds, I'm getting undefined references
19:35:03 <dufflebunk> http://dufflebunk.homeip.net/~dufflebunk/primes.lhs
19:35:13 <pgavin> type NFQCallback = FunPtr (Ptr NFQHandle -> Ptr NFGenMsg -> Ptr NFQData -> Ptr () -> IO CInt)
19:35:22 <pgavin> jmorrison: ^^^
19:35:40 <allbery_b> jz87_: that can't be done without extensions, because H98 is a bit stupid about "type" (the constraints get forall-ed)
19:35:49 <jz87_> ok, so what extensions do I need?
19:35:56 <jz87_> yeah, I was really puzzled
19:36:02 <jz87_> because this seems like something really simple
19:36:08 <ac> dufflebunk: primes.lhs:77:23: Not in scope: `IntSet.findMax'
19:36:13 <pgavin> jmorrison: but I think c2hs gets confused on those sometimes
19:36:21 <jmorrison> pgavin: thanks. I can remap the struct types easily enough, I just wasn't sure what the haskelly concept of a function typedef is
19:36:40 <pgavin> hmm
19:36:55 <jz87_> what extension would I need in order to be able to simply alias Read and Show
19:37:06 * allbery_b unfortunately does not remember how you do it, or even if you can do it with "type" (the different stupidity with "data" can be fixed in a couple of ways)
19:37:25 <jz87_> it just doesn't seem like the Haskell way to type it over and over again
19:37:26 <dufflebunk> ac: I don't get that... hmm, it is imported :/
19:37:32 <allbery_b> no, it doesn'
19:37:34 <allbery_b> t
19:37:39 <ac> dufflebunk: yeah neither do I. It's definitely in the docs
19:37:44 <allbery_b> you're far from the only one who's annoyed
19:39:46 <dufflebunk> ac: when I try, I get stuff like: primes.o: In function `roo_srt': (.data+0xb0): undefined reference to `containerszm0zi1zi0zi1_DataziIntSet_split_closure'
19:40:29 <jz87_> is there documentation somehwere
19:40:34 <jz87_> on all the compiler extensions in GHC
19:40:49 <ac> dufflebunk: so you're saying you get a link error instead of a compile error?
19:41:00 <faxathisia> dufflebunk: Works fine for me
19:41:06 <dufflebunk> ac: Yeah
19:41:07 <faxathisia> dufflebunk: Why do you write lhs instead of hs btw?
19:41:11 <allbery_b> works for mwe.. if I use --make
19:41:18 <dufflebunk> faxathisia: It's literate haskell
19:41:19 * faxathisia also used --make
19:41:22 <faxathisia> dufflebunk: Why
19:41:36 <allbery_b> try -package containers if you don't like --make
19:41:37 <faxathisia> doesn't it take longer to write all the > instead of -- for comments
19:41:41 <faxathisia> since there's more code than comments
19:41:59 <dufflebunk> faxathisia: there are at the moment, it a chunk from a larger file with other stuff in it
19:42:00 * faxathisia doesnt' understand how people have patience to write lhs
19:42:07 <bgeron> Happy new year!
19:42:17 <dufflebunk> faxathisia: in emacs, it's just a tab away
19:42:26 <dufflebunk> And it works for me if I use --make too.
19:42:41 <dufflebunk> Is it expected to get link errors when --make isn't used?
19:42:48 <allbery_b> as of 6.8 yes
19:42:56 <allbery_b> IntSet used to be in base bt is now in containers
19:44:54 <LunarCrisis> Does GHC provide a low-pause garbage collector?
19:45:58 <allbery_b> you can tweak things with +RTS options
19:46:17 <dufflebunk> allbery_b: Oh, so without the --make it was only putting in the base stuff and wasn't linking the containers .o file?
19:46:23 <allbery_b> exactly
19:46:24 <ac> faxathisia: in vim, if you :set formatoptions+=r then the leading '>' is inserted automatically
19:46:52 <allbery_b> --make causes it to chase dependencies, or -package can be used to force linking
19:47:52 <jmorrison> pgavin: after a few {#pointer#} lines, it accepted type Callback = FunPtr( QueueHandle -> Message -> Data -> Ptr () -> CInt )
19:47:53 <allbery_b> it seems a bit unfortunate to me that the .hi files are visible but the .o files aren't if you forget --make / -package
19:48:03 <allbery_b> because you only find out at link time that something is wrong
19:48:41 <jmorrison> pgavin: of course, that's no guarantee it ends up doing anything useful when it compiles...
20:00:34 <jz87_> :t read
20:00:36 <lambdabot> forall a. (Read a) => String -> a
20:09:30 <jz87_> how does GHC search for files?
20:09:34 <jz87_> I mean ghci
20:09:40 <jz87_> if I wrote a module
20:09:45 <jz87_> and I wrote another file in the same directory
20:09:53 <jz87_> and I want to reference the first file from the second
20:09:58 <jz87_> how would I do this in emacs?
20:13:03 <jmorrison> have you tried the obvious in Java style - name the files after their modules and just use "import Modulename"
20:13:20 <jz87_> yes
20:13:32 <jz87_> well maybe I'm doing something wrong
20:13:42 <jz87_> I named my module A.Base
20:13:49 <jz87_> and I'm currently writing A.Test
20:13:53 <jz87_> in the same directory
20:14:02 <jz87_> and I wrote import A.Base
20:14:04 <jz87_> and it can't find it
20:14:16 <jz87_> what should the name of A.Base be?
20:14:37 <ac> is there a shorter version of "takeWhile (not.null) $ iterate a b"?
20:14:58 <dolio> Is it in a directory called 'A'?
20:15:04 <dolio> Or, are they, rather?
20:15:08 <jz87_> no
20:15:27 <jz87_> so they both have to be in a directory called A
20:15:29 <dolio> That's probably the problem, then.
20:15:35 <jz87_> and then the first should be named base.hs?
20:15:37 <jz87_> or Base.hs?
20:15:42 <jz87_> does case matter?
20:15:44 <dolio> module Foo.Bar.Baz should be at Foo/Bar/Baz.hs
20:16:13 <dolio> It probably matters on Unix, if I had to guess.
20:16:39 <jz87_> so if they're in the same directory
20:16:41 <jz87_> ok
20:17:00 <jz87_> aha
20:17:01 <jz87_> ok, now it works
20:17:02 <jz87_> thanks
20:17:08 <dolio> No problem.
20:35:01 <jz87_> I'm puzzled by the following type inference problem
20:35:28 <jz87_> if I have a function receive :: a -> b -> IO ()
20:35:44 <jz87_> and I apply forever . receive
20:35:50 <jz87_> :t forever
20:35:51 <lambdabot> Not in scope: `forever'
20:36:03 <jz87_> :t Control.Monad.forever
20:36:04 <lambdabot> Not in scope: `Control.Monad.forever'
20:36:15 <kpreid> forever a = a >> forever a ?
20:36:20 <jz87_> yes
20:36:31 <kpreid> :t \a -> a >> forever a ?
20:36:31 <lambdabot> parse error (possibly incorrect indentation)
20:36:33 <kpreid> er
20:36:37 <jz87_> shouldn't I get a -> b -> IO()
20:36:38 <dolio> What about '(forever .) . receive'
20:36:41 <jz87_> for forever . receive
20:36:57 <jz87_> ok that type checks
20:37:02 <jz87_> why is that?
20:37:05 <jz87_> that's weird
20:37:05 <kpreid> jz87_: (.) is not general in the way you were thinking.
20:37:08 <kpreid> @type .
20:37:08 <lambdabot> parse error on input `.'
20:37:14 <kpreid> @type (.)
20:37:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:37:45 <jz87_> it's quantified over a, b and c
20:37:48 <jz87_> ah
20:37:49 <kpreid> what you were thinking of was (b -> c) -> (a -> z -> b) -> a -> z -> c
20:37:49 <jz87_> I see
20:37:53 <jz87_> ok
20:37:56 <jz87_> that's why
20:38:07 <kpreid> or in other words: . is for functions of one argument
20:38:24 <dolio> On the right, at least.
20:38:28 <jz87_> I see
20:38:44 <jz87_> so there is no easy way of just writing f . g
20:38:49 <jz87_> where g might take multiple arguments
20:39:09 <dolio> There's just the multiple dots like I posted above.
20:39:12 <dolio> One dot per argument.
20:39:15 <kpreid> as dolio said, (f .) . g is one way
20:39:23 <kpreid> however, nobody actually uses that :-)
20:39:32 * kpreid will now be contradicted
20:39:49 <jz87_> so what would you write?
20:40:01 <kpreid> the pointful version
20:40:02 <jz87_> if you need to hook up a function that takes 2 arguments
20:40:04 <dolio> I think Oleg has some way of making an operator that's polymorphic in the right way, but it's brain-melting.
20:40:16 <kpreid> probably using $
20:40:25 <jz87_> yeah that's what I did initally
20:40:28 <jmorrison> You gotta think of it as: ALL haskell functions take one argument
20:40:31 <jz87_> but I thought it would be more clear
20:40:37 <jz87_> to simply write forever . receive
20:40:40 <conal> using DeepArrow, you can say (result.result) f g
20:40:43 <jmorrison> they just return the next cut down piece of the function
20:40:43 <jz87_> since it claifies wha the function is doing
20:41:23 <kpreid> jz87_: forever . uncurry receive
20:41:29 <jmorrison> hence the double dots
20:41:36 <conal> if you just want functions (not more general arrows), you can define result = (.).  you can freely mix result, first, second, fmap.
20:42:05 <conal> the informal reading is to direct f at the result of the result of g.
20:42:07 <jz87_> conal, are you addressing my question?
20:42:16 <jz87_> I'm really not understanding what you're saying
20:42:28 <ramza3> year happy new haskell
20:42:58 <conal> jz87_: thanks.  i tuned in mid-discussion and was addressing "what you were thinking of was (b -> c) -> (a -> z -> b) -> a -> z -> c"
20:43:19 <conal> giving an alternative to (f .) . g
20:43:19 <jz87_> ok, yeah, I was trying to write forever . receive
20:43:26 <jz87_> where receive is a function a -> b -> IO ()
20:43:39 <jz87_> and I can't do it with .
20:44:08 <conal> jz87_: because you want to direct forever at the IO () part, right?
20:44:09 <dolio> There's always \x -> forever . receive x, as well.
20:44:10 <jz87_> ok, so this arrow thing
20:44:22 <dolio> If you like partial pointlessness.
20:44:25 <jz87_> well I want the mixure to be a functon a -> b -> IO ()
20:44:32 <jz87_> the same signature as receive, except it does it forever
20:44:38 <jz87_> receive is a one shot function
20:44:49 <conal> jz87_: try (result.result) forever receive
20:44:59 <jz87_> what is result?
20:45:13 <conal> specialized to functions, result = (.)
20:45:26 <jz87_> result is not in scope
20:45:30 <jz87_> is this defined in some package?
20:45:31 <conal> but writing "result" gives it clear reading
20:45:39 <conal> @wiki DeepArrow
20:45:39 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
20:46:10 <conal> jz87_: it's generalized in DeepArrow, but if you just want to use it for functions, define result = (.)
20:46:12 * BMeph watches conal proselytise for the Church of Eros
20:46:52 <conal> BMeph: not so much eros, as a particularly nice higher-order pattern.  but yeah, i came across it while thinking about eros.
20:47:30 <jz87_> result = .
20:47:32 <jz87_> ?
20:47:40 <jz87_> what is that black circle thing
20:47:41 <dolio> @type (.) . (.)
20:47:44 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:47:53 <conal> neat, eh?
20:47:56 <jz87_> how do you type that?
20:48:04 <jz87_> which key on your keyboard is that black circle thing?
20:48:20 <conal> jz87_: oh, you're seeing something different from what i'm typing.
20:48:28 <conal> jz87_: it's a dot with surrounding parens
20:48:41 <BMeph> conal: Yes, I've been poking at TypeCompose and DeepArrow lately, trying to get a grip on it.
20:48:47 <conal> in other words, function composition.
20:49:00 <jmorrison> Arrows are heap big medicine. People who think about arrows too much often go insane, or are heard to scream in the night and then never seen again.
20:49:09 <conal> BMeph: :)  i'd be glad to answer questions if & when you have them.
20:49:26 <conal> @type (.) . first . (.) . second
20:49:27 <lambdabot> forall a d a1 b c d1. (b -> c) -> (a -> (a1 -> (d1, b), d)) -> a -> (a1 -> (d1, c), d)
20:49:57 <kpreid> jz87_: is (.) the black circle thing? you have an overeager emoticonifier in your IRC cleient.
20:49:58 <jz87_> ah
20:50:21 <jz87_> yeah
20:50:22 <conal> in other words, direct a function (b->c) at the result part, then the first, then the result, then the second.
20:50:31 <BMeph> conal: Now, you're just trying to blow brain gaskets,a ren't you? ;)
20:50:33 <jz87_> I'm using trillian
20:50:35 <jz87_> on windows
20:50:40 <jz87_> I couldn't find any better irc clients
20:50:55 <jz87_> yeah, arrows are pretty complicated
20:51:15 <jz87_> I need a day when I'm really lucid
20:51:35 <jz87_> understanding monads was hard enough
20:51:36 <BMeph> Actually, I find arrows to be clearer than the whole Functor/Applicative/Monad divide.
20:52:02 <conal> jz87_: i wouldn't worry about the arrow aspect.  you can use this idiom (compositions of (.), first, and second) with plain old functions.  and the name "result" makes it clearer what's going on.  the composition chain spells out a path in a type, to the part to be transformed.
20:53:20 <jz87_> hmm
20:53:28 <jz87_> this reminds my of the car, cdr combos in lisp
20:53:30 <jz87_> caaadr
20:53:35 <jz87_> count the a's
20:53:37 <jz87_> lol
20:53:52 <conal> yep -- similar mnemonic
20:54:06 <conal> jz87_: have you played with the functions first and second?
20:54:17 <jz87_> :t first
20:54:18 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
20:54:21 <jz87_> no
20:54:35 <jz87_> I can usually tell if I've used something by their type sig
20:54:36 <jz87_> lol
20:54:37 <dolio> > first (+1) (1, 2)
20:54:39 <lambdabot>  (2,2)
20:54:50 <jz87_> hmm
20:54:59 <dolio> > second (+1) (1,2)
20:55:00 <lambdabot>  (1,3)
20:55:00 <jz87_> applies a function to the first part of a tuple
20:55:06 <conal> specialized to functions, first :: (b -> c) -> ((a,b) -> (a,c))
20:55:06 <jz87_> interesting
20:55:26 <jz87_> but that's some scary looking types
20:56:07 <conal> if you think of f :: b->c as an "editor", then first f :: (a,b) -> (a,c) is a pair editor
20:56:11 <jmorrison> The thing I've never got about the arrow first/second type signatures, is, where does the d come from?
20:57:00 <jz87_> well, from the looks of it
20:57:32 <jz87_> nvm
20:57:33 <dolio> If you're just modifying the first element of the pair, it doesn't matter what the second element is.
20:57:35 <jz87_> I don't understand either
20:57:39 <conal> jmorrison: d just goes along for the ride, untouched by the function/arrow given to first or second.
20:57:42 <dolio> So, it gets a universally quantified variable.
20:57:47 <jz87_> why is a of kind * -> * -> *?
20:57:58 <jmorrison> I suppose I was misreading it as a simple function, but it isn't, is it - it's a higher level function. So the d is in the type of the output function.
20:58:05 <conal> jz87_: because a is like (->)
20:58:07 <jz87_> from the way you're using it a is b -> c
20:58:17 <conal> jz87_: a is (->)
20:58:26 <conal> the prefix form "a b c" is really unfortunate
20:58:27 <jz87_> oh
20:58:37 <conal> i prefer "b ~> c"
20:58:40 <jz87_> so a applied to types b and c
20:58:45 <jmorrison> jz87_: it's like (+) is a->b->c
20:58:55 <conal> right.  in other words b `a` c
20:59:04 <jz87_> ah, I need to turn this emotifier off somehow
20:59:11 <jz87_> your expressions are turning into emoticons
20:59:15 <conal> jz87_: lol
20:59:24 <conal> (:[])
20:59:31 <conal> @ty (:[])
20:59:34 <lambdabot> forall a. a -> [a]
20:59:34 <jz87_> they need irc client for programming discussions
20:59:41 <jz87_> that formats the code
20:59:45 <jz87_> and color syntax
20:59:51 <conal> jz87_: that'd be awesome.
20:59:52 <jz87_> and built in evaluator like labmda bot
21:00:05 <jz87_> then we can all gather around and host hackathons on irc
21:00:17 <b7j0c> /bye
21:01:24 <loupgaroublond> happy new year everyone
21:01:41 <conal> loupgaroublond: thanks.  happy new year!
21:01:51 <conal> @localtime loupgaroublond
21:02:11 <jz87_> happy new year
21:02:13 <loupgaroublond> east coast
21:02:18 <jz87_> yeah I figured
21:02:22 <EuphoriaSalad> hi I'm back :)
21:02:33 <jmorrison> yeah, happy new year everyone :-)
21:02:34 <jz87_> the europeans are probably already asleep
21:02:38 <loupgaroublond> although pittsburgh isn't much of a coast
21:02:44 <EuphoriaSalad> jz87_: not me :p
21:02:46 <EuphoriaSalad> 6am
21:02:50 * jmorrison is up late in UK
21:02:53 <loupgaroublond> i asked them earlier, they said that there were no flying cars in 2008
21:02:58 <loupgaroublond> we've been ripped off again
21:03:03 * conal is in CA
21:03:18 <EuphoriaSalad> 2008 is already the year of linux on the desktop (ripped that joke of from someone today)
21:04:05 <jz87_> lol
21:04:14 <conal> loupgaroublond: cmu?
21:04:17 <jz87_> 2008 is also the year of armageddon
21:04:22 <EuphoriaSalad> rly?
21:04:22 <aFlag> happy toshiba tdk maxell pontiac kodak LG mcdonalds year!
21:04:24 <loupgaroublond> conal: close, upitt
21:04:34 <conal> loupgaroublond: real close.
21:04:37 <aFlag> the world ends in march
21:04:43 <jz87_> yes
21:04:45 <jmorrison> There are flying hovercrafts, which is almost as cool. http://www.youtube.com/watch?v=FViP5izaj8E
21:04:46 <lambdabot> Title: YouTube - Wing in ground effect Hovercraft uh 18spw
21:04:49 <jz87_> so linux better take over the desktop before then
21:04:53 <conal> when i was at cmu, lazy functional programming was hunky dory.  not so much anymore.
21:05:08 <jz87_> huh?
21:05:10 <jz87_> what happened?
21:05:42 <loupgaroublond> conal: bill gates is putting alot of money into CMU, i could see F# grabbing some attention there in the future
21:05:43 <conal> people left & arrived.  the PL folks became ML-focused.
21:06:01 <loupgaroublond> they are building a whole CS building with his name on it
21:06:07 <jmorrison> jz87_: Haskell started working. Ergo, it's no longer an academic language ;-P
21:06:12 <jz87_> ah
21:06:46 <jz87_> ML doesn't have as nice syntax
21:06:57 <jz87_> I definitely prefer Haskell's syntax to F#
21:07:04 <jz87_> it's just better looking
21:07:14 <jmorrison> OCaml is fast and would be nice, but I don't trust its license
21:07:28 <conal> jmorrison: what's in its license?
21:07:41 <jz87_> they also don't have polymorphic operators
21:07:44 <jmorrison> INRIA could just yank it, and the world would have to pay up or go without
21:07:48 <jz87_> having to remember which + to use is a pain
21:08:09 <jmorrison> conal: it's open source, but of the variety where you have to distribute as "original tarball plus patches"
21:08:11 <allbery_b> haskell use has actually been growing the past couple years, from what I've seen
21:08:25 <loupgaroublond> OCaml has some nasty static library problems in Fedora, i don't trust it for security at all
21:08:59 <jz87_> haskell's type system is just way better than ocaml's
21:09:00 <EuphoriaSalad> allbery_b: hmm why's that surprising?
21:09:18 <allbery_b> of course I'm not actually *in* SCS so I don't have direct information about what goes on over there, just talk with a fair number of grad students over zephyr (which admittedly is a small subset)
21:09:28 <allbery_b> EuphoriaSalad: I am at CMU
21:09:35 <jmorrison> if INRIA yanks the license for the next version, then OCaml is doomed to stagnate, because patching against an increasingly ancient codebase is painful
21:09:39 <jz87_> zephyr?
21:09:53 <allbery_b> ancient IM system which uses kerberos authentication
21:10:06 <EuphoriaSalad> allbery_b: so you meant it's been growing at CMU?
21:10:23 <allbery_b> yes
21:10:45 <loupgaroublond> allbery_b: is there any contact between CMU and Pitt's CS departments?
21:11:00 <ac> I know this has been brought up about 20 times here, but is there a shorter version of "takeWhile (not.null) $ map (take n) (iterate (drop n))"?
21:11:05 <allbery_b> it's still not a major undergrad focus but it's definitely getting attention
21:11:12 <allbery_b> loupgaroublond: no idea
21:11:31 <johnniac> allbery_b, sml still seems to be the major focus, though
21:11:40 <allbery_b> I think there is some contact but no major cooperation that I've heard of
21:11:47 <loupgaroublond> allbery_b: hmm... i'm not a CS student, but i was wondering what the community here is like
21:11:58 <ac> @hoogle [a] -> [[a]]
21:11:58 <lambdabot> Data.List.inits :: [a] -> [[a]]
21:11:58 <lambdabot> Data.List.tails :: [a] -> [[a]]
21:11:58 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
21:12:10 <ac> @src group
21:12:10 <lambdabot> group = groupBy (==)
21:12:14 <allbery_b> yes, SML is still the major focus.  Haskell is growing though
21:12:46 <EuphoriaSalad> guys, MonadReader is killing me :( anyone got some insights on that?
21:13:04 <allbery_b> what about it?
21:13:05 <EuphoriaSalad> :src MonadReader
21:13:13 <EuphoriaSalad> @src MonadReader
21:13:13 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:13:57 <EuphoriaSalad> allbery_b: I have a bunch of functions that all need some piece of data (a list of prime numbers, in this case) and the Monad should encapsulate the passing around of this data
21:15:15 <allbery_b> ok...
21:15:30 <EuphoriaSalad> oh, forgot to supply one of the parameters. lol
21:15:50 <EuphoriaSalad> now it works, but still I'd like to know how it works
21:16:05 <EuphoriaSalad> @src Control.Monad.Reader.MonadReader
21:16:05 <lambdabot> Source not found. :(
21:16:09 <EuphoriaSalad> @src Control.Monad.MonadReader
21:16:10 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:17:06 <jz87_> ok
21:17:13 <jz87_> this type constructor syntax question
21:17:16 <allbery_b> runReader (code that gets r/o state passed around with it) initialState
21:17:17 <jz87_> I'm trying to define
21:17:34 <EuphoriaSalad> @src Control.Monad.Reader.Class.MonadReader
21:17:34 <lambdabot> Source not found. My pet ferret can type better than you!
21:17:38 * allbery_b uses a ReaderT IO in a GUI program
21:17:38 <jz87_> data Process a = Process (chan :: TChan a, threadId :: ThreadId)
21:17:50 <allbery_b> @source Control.Monad.Reader
21:17:50 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
21:17:59 <jz87_> and it's giving my a parse error
21:18:00 <allbery_b> it's not in the @src database
21:18:02 <jz87_> on TChan
21:18:35 <EuphoriaSalad> allbery_b: the other guy somehow wrote it in do notation such that it works without explicitly calling runReader
21:18:35 <allbery_b> well, yes
21:18:49 <allbery_b> jz87_: tuples don't have names
21:18:54 <allbery_b> did you mean { } record syntax?
21:19:18 <allbery_b> data Process a = Process { chan :: TChan a, threadId :: ThreadId }
21:19:57 <allbery_b> if you use parens, it's a tuple:  data Process a = Process (TChan a,ThreadId)
21:20:18 <jz87_> yes
21:20:20 <jz87_> ah
21:21:19 <EuphoriaSalad> paging sjanssen... in the code you kindly wrote for me, where is MonadReader actually instantiated?
21:24:01 <EuphoriaSalad> and what is the Monad m that is an argument of MonadReader r m
21:25:32 <ac> is there a point free way to write "(\a b -> fst a == fst b)"?
21:25:55 <Jangler> @pl (\a b -> fst a == fst b)
21:25:55 <lambdabot> (. fst) . (==) . fst
21:26:08 <ac> ah, that's the command
21:26:21 <ac> ah right
21:26:22 <conal> how about "on"
21:26:29 <jmorrison> ac: the former is much less braintwisty, you know
21:26:41 <ac> jmorrison: the latter is so much cooler
21:26:50 <conal> (==) `on` fst, i think
21:26:51 <Jangler> (==) `on` fst
21:27:04 * conal high-fives Jangler 
21:27:05 <jmorrison> for values of cool where cool == braintwisty
21:27:10 <Jangler> hehe
21:27:48 <EuphoriaSalad> (==) . (fst *** fst)
21:27:54 <EuphoriaSalad> @type (==) . (fst *** fst)
21:27:57 <lambdabot> forall a b a1 b1. (Eq (a, a1)) => ((a, b), (a1, b1)) -> (a, a1) -> Bool
21:28:20 <EuphoriaSalad> @type (uncurry (==)) . (fst *** fst)
21:28:21 <lambdabot> forall b a b1. (Eq a) => ((a, b), (a, b1)) -> Bool
21:28:25 <EuphoriaSalad> :D
21:28:48 <ac> @hoogle on
21:28:48 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:28:48 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
21:28:48 <lambdabot> Data.Function :: module
21:29:01 <EuphoriaSalad> > ((uncurry (==)) . (fst *** fst)) ((1,1),(1,2))
21:29:04 <lambdabot>  True
21:29:36 <allbery_b> <EuphoriaSalad> and what is the Monad m that is an argument of MonadReader r m
21:29:38 <EuphoriaSalad> @type curry ((uncurry (==)) . (fst *** fst)) -- actually you want this
21:29:39 <lambdabot> forall b a b1. (Eq a) => (a, b) -> (a, b1) -> Bool
21:30:05 <allbery_b> hrm, and now I've lost what I was going to say.  ref
21:30:08 <allbery_b> feh even
21:30:50 <allbery_b> ah, right.  m is the actual implementation (usually Reader or ReaderT (mumble).  r is the state
21:31:14 <EuphoriaSalad> allbery_b: he doesn't use the "instance" keyword at all :( it's all magic
21:31:17 <shachaf> m is actually something like (Reader r), isn't it?
21:31:21 <shachaf> The r is used twice.
21:31:38 <allbery_b> something liek that, yes.  I was talking conceptually, not generating Haskell code :)
21:31:50 <jmorrison> bye all
21:32:01 <allbery_b> @instances MonadReader
21:32:03 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
21:32:26 <ac> > map (map snd) $ groupBy ((.fst).(==).fst) $ zip (concatMap (replicate 4) [0..]) "aoeublah"
21:32:27 <lambdabot>  ["aoeu","blah"]
21:32:28 <allbery_b> heh.  that first one is sneaky
21:32:36 <ac> think my first one was better
21:32:38 <shachaf> Ignore all the transformers (except for ReaderT and RWST).
21:32:41 <allbery_b> functions are instances of MonadReader
21:32:52 <allbery_b> no runReader foo needed
21:33:33 <hpaste>  FunctorSalad pasted "MonadReader ..." at http://hpaste.org/4740
21:34:48 <shachaf> EuphoriaSalad: What is the question, by the way?
21:34:49 <EuphoriaSalad> see there the "splitOffPrimePower" function
21:35:44 <EuphoriaSalad> shachaf: understanding where exactly MonadReader comes into play in that code (sjanssen wrote it in do notation for me)
21:35:54 <shachaf> @ty ask
21:35:56 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
21:36:19 <shachaf> EuphoriaSalad: But you can ignore MonadReader; do-notation works with just Reader.
21:36:22 <allbery_b> he didn't provide the cde that *invokes* the reader, just the code that runs in it
21:36:40 <allbery_b> if you want to call phi, for examp[el, you need to do so in a runReader
21:36:57 <shachaf> EuphoriaSalad: MonadReader is so your function will work in several different Monads.
21:37:17 <loupgaroublond> can i ask haddock questions here, or is there a specific channel for that?
21:37:54 <hpaste>  Pseudonym pasted "Bizarre" at http://hpaste.org/4741
21:38:29 <EuphoriaSalad> shachaf: only MonadReaders have "ask" though
21:38:35 <EuphoriaSalad> allbery_b: cde?
21:38:45 <ac> Is there a simple way to get @hoogle, @djin, and @pl commands at the ghci prompt?
21:38:56 <shachaf> EuphoriaSalad: And Reader is a MonadReader.
21:39:03 <shachaf> @where goa
21:39:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
21:39:11 <EuphoriaSalad> allbery_b: no, that's the magic part. you just call phi as "phi n someprimes"
21:39:27 <EuphoriaSalad> no mention of Monads anywhere, the someprimes is magically passed around
21:39:35 <EuphoriaSalad> :)
21:39:38 <shachaf> EuphoriaSalad: That's because it's using the (r ->) monad.
21:39:57 <shachaf> @src (->) return
21:39:57 <lambdabot> return = const
21:40:04 <shachaf> @src (->) (>>=)
21:40:04 <lambdabot> f >>= k = \ r -> k (f r) r
21:40:07 * allbery_b mentioned that one earlier
21:40:12 <ac> shachaf: thanks
21:40:21 <allbery_b> <allbery_b> functions are instances of MonadReader
21:40:21 <allbery_b> <allbery_b> no runReader foo needed
21:40:41 <shachaf> EuphoriaSalad: You could still have used do-notation before, when you used Reader, though.
21:40:47 <allbery_b> Pseudonym: what's bizarre?
21:40:51 <shachaf> Pseudonym: What is bizarre?
21:41:03 <Pseudonym> Not bizarre, exactly.
21:41:08 <shachaf> Pseudonym: Integer is Bounded and Integral.
21:41:11 <Pseudonym> But it's something that keeps biting me every so often.
21:41:14 <allbery_b> @instances Bounded
21:41:16 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
21:41:17 <EuphoriaSalad> allbery_b: sorry for missing those, it's 6:40am :)
21:41:18 <Pseudonym> > maxBound :: Integer
21:41:19 <lambdabot>   add an instance declaration for (Bounded Integer)
21:41:19 <lambdabot>     In the expression: ma...
21:41:21 <allbery_b> that;'s right
21:41:29 <allbery_b> Integer is *not* Bounded
21:41:30 <Pseudonym> Why would Integer be bounded?
21:41:33 <shachaf> Oh, wait.
21:41:34 <Pseudonym> That's the whole point.
21:41:34 <shachaf> Sorry.
21:42:07 <EuphoriaSalad> ok, maybe I should just draw an commutative diagram, right? :)
21:42:10 <Pseudonym> The problem is that GHC looks at the right-hand-side only when finding instances.
21:43:52 <Pseudonym> The thing is, it's the fact that maxIntDouble is _demanded_ that causes the error.
21:44:00 <Pseudonym> If it weren't demanded, there would be no error.
21:44:07 <Pseudonym> Because instance resolution is lazy.
21:44:14 <EuphoriaSalad> allbery_b: sorry for my denseness, but which part causes the MondadReader to be instantiated as a (r ->) monad?
21:44:59 <allbery_b> nothing, it's automatic
21:45:09 <shachaf> @source Control.Monad.Reader
21:45:09 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
21:45:24 <allbery_b> runReader is needed for the full Reader instantiation; (-> r) doesn't need it
21:45:32 <EuphoriaSalad> shachaf: the example there is not so helpful IMHO :(
21:45:36 <allbery_b> (think of (-> r) as reader-lite)
21:45:44 <shachaf> EuphoriaSalad: That's where the instance is defined.
21:45:53 <EuphoriaSalad> allbery_b: you mean (r ->), right?
21:46:00 <EuphoriaSalad> and here we have ([Int] ->)
21:46:02 <bos> @pl \f1 f2 (a,b) -> (f1 a, f2 b)
21:46:02 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
21:46:07 <allbery_b> actually I mean ((->) r)
21:46:08 <shachaf> EuphoriaSalad: Yes, or ((->) r), which is what GHC accepts.
21:46:16 <bos> crikey.  i thought that was something more like f1 *** f2
21:46:18 <allbery_b> that is, -> treated as a prefix operator
21:46:22 <shachaf> No (->) sections.
21:46:40 <shachaf> bos: @pl doesn't know (***) and friends.
21:46:50 <bos> yeah, i see that :-)
21:46:56 <allbery_b> -> is syntax, not an operator, so you can't make sections --- but you can fake it with the ((->) r) syntax
21:47:06 <EuphoriaSalad> actually I ought to know hom functors well, but I have trouble drawing the connection at this time of the day :)
21:48:21 <allbery_b> anyway, to attempt to answer your question: Reader carries around state, and requires runReader to intiialize it.
21:48:45 <EuphoriaSalad> splitOffPrimePowers \in Hom([Int], Int -> (Int,Int;Int))
21:48:49 <allbery_b> with the ((->) r) monad, (the argument of the function) is the state
21:48:59 <allbery_b> dropped something there
21:49:04 <jz87_> I have a question with using closures to store state without breaking external function interface
21:49:11 <jz87_> basically I'm writing something like this
21:49:25 <allbery_b> with the ((->) r) monad, r (the argument of the function) is the state
21:49:32 <allbery_b> and calling the function instantiates the state
21:49:34 <jz87_> f arg = f' arg 0
21:49:40 <jz87_> where f' arg n = do
21:49:49 <jz87_> line <- getLine
21:49:54 <jz87_> putStrLn $ show n
21:50:03 <jz87_> f' arg (n + 1)
21:50:09 <EuphoriaSalad> allbery_b: ok, I think I'm trying to figure out how splitOffPrimePowers and the other one are plugged together
21:50:29 <jz87_> so a call to f should instantiate the closure inside
21:50:31 <jz87_> and then after that
21:50:52 <jz87_> the closure should update itself with each input
21:50:57 <jz87_> but it's printing out all 0s
21:52:03 <EuphoriaSalad> ok guys, thanks for the help. I'll try again tomorrow or so
21:52:08 <EuphoriaSalad> @karma+ allbery_b
21:52:08 <lambdabot> allbery_b's karma raised to 8.
21:52:16 <EuphoriaSalad> @karma+ shachaf
21:52:17 <lambdabot> shachaf's karma raised to 1.
21:52:46 <shachaf> @localtime EuphoriaSalad
21:52:46 <lambdabot> Local time for EuphoriaSalad is Tue Jan  1 06:52:46
21:52:59 * shachaf just woke up a little while ago.
21:53:09 <EuphoriaSalad> @localtime shachaf
21:53:10 <bos> @pl \f (a, b) -> (f a, f b)
21:53:11 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
21:53:11 <lambdabot> Local time for shachaf is Tue Jan  1 00:53:09 2008
21:53:32 * shachaf doesn't run his IRC client locally. :-)
21:54:22 <EuphoriaSalad> haskell should allow drawing diagrams as code ;)
21:54:50 <EuphoriaSalad> really, half the problem with these things is keeping in mind which function goes from where to where
21:54:50 <jz87_> does ghci have a config file
21:54:58 <allbery_b> it's almost 8am in shachaf's area :)
21:54:58 <jz87_> so that it's launched by default with certain parameters?
21:55:03 <allbery_b> ~/.ghci
21:55:05 <shachaf> jz87_: There's ~/.ghci.
21:55:23 <EuphoriaSalad> makes me feel bummy that he just woke up and I'm still awake :)
21:55:40 <jz87_> that didn't work
21:55:51 <shachaf> allbery_b: Well, good guess, but you were lucky.
21:56:01 * shachaf was only in this time zone for about a week.
21:56:07 <allbery_b> heh
21:56:23 <jz87_> do I just type in the params into ~/.ghci?
21:56:28 <allbery_b> jz87_: how did you use it?  it has to be ghci commands, so you need to use :set to set command line options
21:56:33 <jz87_> ah
21:56:35 <jz87_> lol
21:56:41 <jz87_> Ithought you would set commandline params
21:56:43 <jz87_> in the .ghci file
21:57:05 <jz87_> no
21:57:07 <jz87_> still didn't work
21:57:10 <allbery_b> no, the idea is that you can also define new commands for ghci
21:57:20 <jz87_> I put :set -fno-monomorphism-restriction
21:57:39 <allbery_b> type :? in ghci to see what kind of stuff you can put in the ~/.ghci file
21:57:57 <jz87_> yeah
21:58:05 <jz87_> basically the stuff you can type in ghci console right?
21:58:06 <shachaf> Seems to work here.
21:58:16 <jz87_> I just want to save myself from having to type a ton of :set everytime
21:58:25 <allbery_b> is this on unix or windows?
21:58:30 <jz87_> windows
21:58:41 <allbery_b> ok, then it's not the e.g. cygwin $HOME
21:59:01 <allbery_b> it's C:\Documents & Settings\loginname\.ghci (or something like that)
21:59:15 <ac> is something like "snd2last (a1:a2:[]) = a1; snd2last (a:as) = snd2last as" predefined somewhere?
21:59:16 <allbery_b> this was discussed recently on haskell-cafe
21:59:44 <jz87_> aha
21:59:45 <jz87_> ok that worked
21:59:49 <jz87_> so the directory was wrong
21:59:58 <jz87_> arrgh, I hate windows
22:00:09 <jz87_> but apple is probably coming out with new Mac Pro soon
22:00:10 <conal> windows + haskell == sorrow
22:00:12 <jz87_> so i can't buy one yet
22:00:18 <jz87_> yes I'm well aware of that fact
22:00:25 <jz87_> I hate programming on windows
22:00:30 <jz87_> everything works differently from documented
22:00:41 <jz87_> but my mac is a mac mini
22:00:45 <jz87_> and has no dual monitor support
22:01:03 <conal> i'm finally shifting over to linux (from windows).  just getting things sorted out.
22:01:04 <allbery_b> haskell + osx has its own fun, especially on leopard...
22:01:18 <jz87_> I'd rather use mac
22:01:26 <jz87_> I like having a user friendly desktop gui
22:01:39 <conal> allbery_b: what kind of problems in haskell + osx?
22:01:46 <jz87_> although I know for pure development linux is probably best
22:01:54 <jz87_> well with emacs anyway
22:02:05 <jz87_> I do also use eclipse though for coding stuff like Flex
22:03:08 <BMeph> ac: It's simple enough not to need defining, so it's expected that you "roll you own" function for it.
22:03:50 <allbery_b> conal: problems with getting the right readline library (Apple ships one which isn't really readline, and in Leopard overriding it is a bit more difficult than it was in Tiger)
22:04:06 <conal> @ty (head.tail.reverse)  -- for ac
22:04:08 <lambdabot> forall a. [a] -> a
22:04:22 <conal> (head.tail.reverse) [1 .. 10]
22:04:27 <conal> > (head.tail.reverse) [1 .. 10]
22:04:28 <lambdabot>  9
22:04:30 <jz87_> emacs on OS X is the bet though
22:04:31 <jz87_> best though
22:04:37 <allbery_b> there have been other linker issues because Apple switched to a 64-bit-capable linker which is perhaps not quite ready for prime time
22:04:50 <ac> BMeph: and I imagine it's not commonly needed
22:05:32 <ac> conal: clever
22:06:17 <BMeph> > last.init [0..10]
22:06:18 <lambdabot>  Couldn't match expected type `a -> [a1]'
22:06:31 <BMeph> > (last.init) [0..10]
22:06:32 <lambdabot>  9
22:07:24 <ac> BMeph: ah. I found inits, but not init for some reason
22:07:36 <conal> BMeph: better still.
22:08:26 <jz87_> incReceive :: TChan a -> IO t
22:08:26 <jz87_> incReceive chan = incReceive' chan 0
22:08:26 <jz87_>     where incReceive' chan n = do
22:08:26 <jz87_>             msg <- atomically $ readTChan chan
22:08:26 <jz87_>             putStrLn $ show n
22:08:27 <jz87_>             incReceive' chan (n + 1)
22:08:29 <jz87_> ok
22:08:34 <jz87_> I'm puzzled
22:08:40 <jz87_> the following code doens't work right
22:08:50 <jz87_> I'm sending it a series of input messages
22:08:54 <jz87_> through the TChan
22:09:05 <jz87_> it basically discards the messages and then increment itself
22:09:09 <Sizu1> why is last.init better than head.tail.reverse? first takes 2n-1 and second takes n+2 steps?
22:09:10 <jz87_> and prints out the current value
22:09:21 <jz87_> if I replace atomically $ readTChan chan with readLine
22:09:24 <jz87_> it works fine
22:09:36 <jz87_> but with readTChan it doesn't
22:10:01 <allbery_b> usually in a case like that I first suspect that because you're not using it, it doesn't happen
22:10:07 <allbery_b> (laziness)
22:10:14 <jz87_> hmm
22:10:23 <jz87_> but I'm not using msg either way
22:10:44 <allbery_b> no, but I/O is special
22:10:45 <jz87_> the only difference is whether msg is coming from getLine or atomically $ readTChan chan
22:11:05 <jz87_> oh
22:11:21 <allbery_b> I/O has to be sequenced no matter what, so the fact that you're doing the putStrLn causes the readLine to happen
22:11:33 <allbery_b> the visible result is thrown away but the "world state" is updated
22:11:47 <allbery_b> and putStrLn depends on that "world state"
22:11:58 <allbery_b> there is no such dependency when you read the TChan though
22:12:23 <jz87_> ok
22:12:27 <jz87_> so I modified the code
22:12:29 <jz87_> I'm using msg
22:12:31 <jz87_> I inserted a line
22:12:34 <jz87_> putStrLn msg
22:12:39 <jz87_> right after the atomically readTChan
22:12:55 <jz87_> it still isn't updating the counter
22:12:55 <BMeph> Sizu1: It's likely less efficient, but more in line with the intended operation.
22:13:11 <jz87_> incReceive chan = incReceive' chan 0
22:13:11 <jz87_>     where incReceive' chan n = do
22:13:11 <jz87_>             msg <- atomically $ readTChan chan
22:13:11 <jz87_>             putStrLn msg
22:13:11 <jz87_>             putStrLn $ show n
22:13:12 <jz87_>             incReceive' chan (n + 1)
22:13:14 <allbery_b> I didn't promise thta would fix it, just that it would be the first thing I'd look at
22:13:23 <allbery_b> btw, please use hpaste instead of pasting into the channel
22:13:25 <allbery_b> @paste
22:13:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:13:30 <jz87_> ah ok
22:13:46 <hpaste>  jz87 pasted "(no title)" at http://hpaste.org/4742
22:14:27 <jz87_> that's a good idea
22:14:32 <allbery_b> unfortunately I',m pretty unfamiliar with STM, so don't think I can help much :(
22:14:45 <allbery_b> and the folks who can are probably asleep
22:14:54 <jz87_> I'm trying to write a haskell implementation of the sort of functionality that erlang has
22:14:59 <allbery_b> (I should be heading to bed myself, speaking of which...)
22:15:23 <Lemmih> What's the problem?
22:15:23 <jz87_> with regards to creating servers, supervisor chains, etc
22:15:32 <jz87_> http://hpaste.org/4742
22:15:39 <jz87_> basically this code isn't updating the coutner
22:15:48 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4743
22:16:21 <jz87_> incReceive runs in a separate thread
22:16:29 <jz87_> and it receives messages through a TChan
22:16:56 <jz87_> incReceive chan = incReceive' chan 0
22:17:06 <jz87_> and incReceive' basically runs in a loop
22:17:18 <jz87_> it reads a message from the TChan, and prints it out, and updates its own coutner
22:17:30 <jz87_> basically it calls itself with chan (n + 1)
22:17:42 <Lemmih> Works for me.
22:17:45 <jz87_> so the idea is that each time this function receives a message, it incremenets
22:18:08 <jz87_> that's not possible
22:18:31 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4744
22:18:41 <jz87_> this is the whole source file
22:18:47 <jz87_> you couldn't have executed that snippet
22:18:52 <jz87_> since ! wasn't defined in it
22:19:14 <hpaste>  Lemmih annotated "(no title)" with "My output." at http://hpaste.org/4742#a1
22:19:47 <mxc> strange, docs say that UTCTime is an isntance of Show, but this doesn't work:
22:19:48 <mxc> Prelude Data.Time.Clock> do {a <- getCurrentTime ; putStrLn $ show a; return a}
22:19:48 <mxc> <interactive>:1:37:
22:19:49 <mxc>     No instance for (Show UTCTime)
22:19:49 <mxc>       arising from use of `show' at <interactive>:1:37-42
22:19:53 <jz87_> what?
22:19:56 <jz87_> this is strange?
22:20:16 <mxc> let me rephrase: as a haskell newbie, i dont understand why that doesn't work
22:20:31 <mxc> when the docs say that UTCTime is an instance of Show
22:20:52 <EuphoriaSalad> @t ($)
22:20:52 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:20:56 <EuphoriaSalad> :t ($)
22:20:58 <lambdabot> forall a b. (a -> b) -> a -> b
22:21:17 <Lemmih> jz87_: have you forked more than one incReceive threads?
22:21:26 <EuphoriaSalad> this $ is an odd thing ;) used almost always for its grouping priority
22:21:37 <jz87_> hmm
22:21:45 <jz87_> let me print threadid
22:22:19 <EuphoriaSalad> :t \x -> ($x) -- canonical embedding into the bidual \o/
22:22:20 <lambdabot> forall a b. a -> (a -> b) -> b
22:22:38 <jz87_> yeah
22:22:40 <jz87_> that explains it
22:22:44 <jz87_> it's spawning new threads
22:22:47 <faxathisia> :t on
22:22:48 <lambdabot> Not in scope: `on'
22:22:53 <faxathisia> @src on
22:22:53 <lambdabot> (*) `on` f = \x y -> f x * f y
22:22:59 <faxathisia> :t (*) `on` f = \x y -> f x * f y
22:23:00 <lambdabot> parse error on input `='
22:23:04 <jz87_> aha
22:23:06 <jz87_> so this is why
22:23:08 <faxathisia> :t let (*) `on` f = \x y -> f x * f y in on
22:23:09 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
22:23:15 <faxathisia> ?djinn (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
22:23:16 <lambdabot> f a b c _ = a (b c) (b c)
22:23:25 <conal> mxc: which docs say that UTCTime is a Show instance?
22:23:56 <EuphoriaSalad> faxathisia: huh? how can (*) be an argument
22:23:57 <jz87_> YES!!!!
22:23:58 <jz87_> it works
22:23:58 <mxc> http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html#t%3AUTCTime
22:23:59 <lambdabot> http://tinyurl.com/2w6lgd
22:24:01 <EuphoriaSalad> err, paremeter
22:24:06 <jz87_> thanks lemmih
22:24:17 <jz87_> I mistakenly created a new thread every time
22:24:22 <mxc> i'm on ghc 6.61 and have the time library 1.1.1 instead of 1.1.2,  so that cld be it
22:24:29 <conal> mxc: maybe version skew.  my ghci doesn't know that instance.
22:24:43 <faxathisia> I don't know.. I thought it's just part of haskell syntax
22:24:45 <mxc> mine doesn't either
22:24:50 <conal> mxc: unless perhaps the instance is defined in another module.
22:24:57 <faxathisia> I only learned this is legal (assuming it is) from @src
22:25:06 <conal> mxc: i see only Eq and Ord
22:25:32 <Lemmih> On my box: fmap show Data.Time.getCurrentTime  -->  "2008-01-01 06:24:55.313567 UTC"
22:25:50 <EuphoriaSalad> :t (*) `on` sqrt
22:25:51 <shachaf> EuphoriaSalad: You're still here? :-)
22:25:52 <lambdabot> Not in scope: `on'
22:25:54 <Lemmih> (Using ghc-6.8.2)
22:26:00 <mxc> @hoogle fmap
22:26:00 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
22:26:00 <lambdabot> Control.Monad.fmap :: Functor f => (a -> b) -> f a -> f b
22:26:00 <lambdabot> Control.Monad.Instances.fmap :: Functor f => (a -> b) -> f a -> f b
22:26:01 <EuphoriaSalad> shachaf: yeah. sleep is the enemey
22:26:08 <conal> Lemmih: with which modules in scope?
22:26:16 <mxc> lemmih, i guess it could be a new thing in ghc 6.8.x
22:26:18 <mxc> i'm on 6.6
22:26:40 <Lemmih> conal: Prelude.
22:26:57 <faxathisia> > let (++) `then` ($$) = ($$) . (++) in (+1) `then` (*2) $ 5
22:26:57 <lambdabot>  Parse error at "then`" (column 11)
22:27:02 <shachaf> > fmap show System.Time.getClockTime
22:27:03 <lambdabot>   Not in scope: `System.Time.getClockTime'
22:27:04 <shachaf> "Mon Dec 31 22:26:47 PST 2007"
22:27:12 <shachaf> (In GHC 6.6.1.)
22:27:21 <faxathisia> let (++) `theng` ($$) = ($$) . (++) in (+1) `theng` (*2) $ 5
22:27:26 <faxathisia> > let (++) `theng` ($$) = ($$) . (++) in (+1) `theng` (*2) $ 5
22:27:27 <lambdabot>  12
22:27:51 <shachaf> > (+1) >>> (*2) $ 5
22:27:52 <lambdabot>  12
22:27:56 <EuphoriaSalad> prolly something to do with my nonstandard choice of celebration accessoirs for new years eve
22:29:01 <allbery_b> <EuphoriaSalad> faxathisia: huh? how can (*) be an argument
22:29:09 <faxathisia> ?
22:29:21 <johnniac> > let theng = flip (.) in (+1) `theng` (*2) $ 5
22:29:22 <lambdabot>  12
22:29:25 <allbery_b> haskell allows two kinds of identifiers:  function names which are word characters, and operators
22:29:35 <allbery_b> (*) is just as valid an operator as any other
22:29:53 <EuphoriaSalad> an operator parameter?
22:30:01 <faxathisia> ahh when you put it that way :)
22:30:05 <allbery_b> but since it's being used not as an operator there, it has to be specified with operator-to-function syntax (i.e. with parentheses around it)
22:30:10 <shachaf> EuphoriaSalad: (*) is just a variable name.
22:30:13 <allbery_b> EuphoriaSalad: why not?
22:30:15 <shachaf> EuphoriaSalad: It can be an argument.
22:30:27 <mxc> ah, clocktime is fine
22:30:27 <shachaf> Or redefined.
22:30:29 <EuphoriaSalad> sure operators can be arguments, but (*) is taken already
22:30:32 <allbery_b> haskell is functional, operators are functions, functions can be arguments :)
22:30:35 <mxc> hanks shachaf
22:30:38 <shachaf> EuphoriaSalad: It's shadowed.
22:30:44 <EuphoriaSalad> oh I see
22:30:46 <shachaf> > let undefined = 3 in undefined
22:30:46 <lambdabot>  3
22:30:49 <shachaf> > undefined
22:30:49 <lambdabot>  Undefined
22:30:54 <allbery_b> and it's a local lambda binding (shadowed, as they said(
22:30:59 <shachaf> > let 2 + 2 = 5 in 2 + 2
22:30:59 <lambdabot>  5
22:31:03 <faxathisia> lol
22:32:34 <allbery_b> haskell is fun!  :)
22:34:52 <EuphoriaSalad> yeah it's even better for coming down than random internet nonsense
22:35:01 * EuphoriaSalad shuts up now
22:35:24 <EuphoriaSalad> prolly since concentrating releases good neurotransmitters or something ;)
22:35:57 <faxathisia> The on definition totally baffled me when I first saw it, that's why I like one
22:36:36 <EuphoriaSalad> hmm that redefines (+), doesn't it?
22:37:10 <faxathisia> > let 2 + 2 = 5 in 1 + 1  --  I guess this is a pattern match failure then
22:37:10 <lambdabot>   Non-exhaustive patterns in function +
22:37:21 <jz87_> :i liftM
22:37:55 <faxathisia> Control.Monad.liftM
22:39:16 <EuphoriaSalad> on is just a preprocessor for the arguments of on's first arguments I suppose
22:39:25 <EuphoriaSalad> *first argument
22:40:36 <EuphoriaSalad> > (exp $ on log +) 2 2
22:40:36 <lambdabot>   Not in scope: `on'
22:40:40 <EuphoriaSalad> :(
22:41:07 <EuphoriaSalad> @hoogle on
22:41:07 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:41:07 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
22:41:07 <lambdabot> Data.Function :: module
22:41:19 <EuphoriaSalad> :import Data.Function
22:41:23 <EuphoriaSalad> @import Data.Function
22:41:23 <lambdabot> Unknown command, try @list
22:41:29 <EuphoriaSalad> :load Data.Function
22:41:34 <EuphoriaSalad> halp?
22:42:08 <shachaf> EuphoriaSalad: lambdabot isn't ghci.
22:42:17 <shachaf> (And is running 6.6 anyway.)
22:42:24 <EuphoriaSalad> oh, and it must be "(exp . (on log +)) 2 2"
22:42:30 <EuphoriaSalad> shachaf: yes, was just guessing :(
22:42:45 <allbery_b> > let 2 + 2 = 5; x + y = x Prelude.+ y in (2 + 2,2 + 3) -- think this works
22:42:46 <shachaf> "on log +"?
22:42:46 <lambdabot>  (5,5)
22:42:58 <allbery_b> > let 2 + 2 = 5; x + y = x Prelude.+ y in (2 + 2,3 + 3) -- think this works
22:42:59 <lambdabot>  (5,6)
22:43:02 <allbery_b> righjt
22:43:19 <BMeph> Don't forget the parens around the plus. :)
22:43:43 <Mitt08> GOVERNOR ROMNEY: "And further, if I were fortunate enough to be elected your President, I'd call for a National Summit of Nations to create a new partnership  a Partnership for [Progress] and Prosperity."
22:43:43 <Mitt08> "This Partnership would assemble the resources of all the nations of the world to work to assure that Islamic states that are threatened with violent Jihad have public schools that are not Wahhabi madrasas; that they have micro-credit and banking, the rule of law, human rights, basic health care, and competitive economic practices." (Governor Mitt Romney, Remarks At Yeshiva University, 4/26/07)
22:43:51 <allbery_b> meh
22:43:57 <faxathisia> and the order
22:43:59 <faxathisia> I think is wrong..
22:44:11 <EuphoriaSalad> > let on op f x y = op (f x) (f y) in (exp . on (+) log) 3 3
22:44:12 <lambdabot>   add an instance declaration for (Floating (a -> a))
22:44:20 <EuphoriaSalad> yes faxathisia
22:44:24 <EuphoriaSalad> fixed it now
22:44:27 * allbery_b doesn't have ops here, oh well
22:44:35 --- mode: ChanServ set +o Pseudonym
22:44:36 <EuphoriaSalad> > let on op f x y = op (f x) (f y) in (exp . on (+) log) 3.0 3.0
22:44:36 <lambdabot>   add an instance declaration for (Floating (a -> a))
22:44:45 <Pseudonym> Now, how do you do this again?
22:44:48 <jsnx> i am voting for Bush in the next election
22:45:02 <EuphoriaSalad>  /ban foo ?
22:45:15 <Pseudonym> Nope.
22:45:22 <jsnx> Pseudonym: /kick the_enemy
22:45:23 <faxathisia> /mode +b *!*@*
22:45:23 <allbery_b> /kickban nick!user@host (with wildcards)
22:45:30 <EuphoriaSalad> well it's a client shortcut in some clients
22:45:38 <jsnx> yeach, kickban is better
22:45:43 <allbery_b> if your client doesn't have that, /mode * +b ...
22:45:47 <shachaf> @let on f g x y = g x `f` g y
22:45:48 <lambdabot> Defined.
22:45:53 <faxathisia> shachaf bag
22:45:55 <faxathisia> bah*
22:45:56 <faxathisia> @src on
22:45:57 <lambdabot> (*) `on` f = \x y -> f x * f y
22:46:00 <allbery_b> (some clients don't need the *, some may require it to explicitly be #haskell)
22:46:01 <faxathisia> this def is nicer
22:46:08 <Pseudonym> NOne o that seems to work for me.
22:46:10 <Pseudonym> Oh well.
22:46:14 <Pseudonym> Too late now.
22:46:19 <EuphoriaSalad> faxathisia: I did the same except for the infix :)
22:46:28 <Pseudonym> Most of us aren't even in the US.
22:46:31 <faxathisia> what infix?
22:46:32 <EuphoriaSalad> oh, nvm
22:46:42 <shachaf> faxathisia: Yours is way more typing. :-)
22:46:43 <EuphoriaSalad> thought you were comparing shachaf's and mine
22:46:55 <EuphoriaSalad> > let on op f x y = op (f x) (f y) in (exp . on (+) log) 3.0 3.0 -- so what's still wrong with this?
22:46:55 <lambdabot>   add an instance declaration for (Floating (a -> a))
22:47:08 <wy> anyone using archlinux here? I'm considering abandon my ubuntu ;-)
22:47:26 <EuphoriaSalad> :t exp
22:47:27 <lambdabot> forall a. (Floating a) => a -> a
22:48:06 * Pseudonym should really learn this stuff
22:48:12 <shachaf> > let on f g x y = g x `f` g y in ((exp .) . on (+) log) 3 3
22:48:12 <lambdabot>  9.000000000000002
22:48:23 <shachaf> EuphoriaSalad: (.) is for single-argument functions.
22:48:38 <shachaf> @let dot = (.) . (.) -- For two arguments
22:48:39 <lambdabot> Defined.
22:48:51 <EuphoriaSalad> :t on (+) log
22:48:52 <lambdabot> Not in scope: `on'
22:48:54 <faxathisia> :t dot
22:48:55 <lambdabot> Not in scope: `dot'
22:49:02 <EuphoriaSalad> thought we defined on globally...
22:49:07 <shachaf> > (exp `dot` (+) `on` log) 3 3
22:49:08 <lambdabot>  9.000000000000002
22:49:09 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] ADD allbery_b!*@* 38
22:49:17 <Pseudonym> Consider yourself op'd.
22:49:30 -Axeman(n=esterase@c-71-227-16-131.hsd1.mi.comcast.net)- HAPPY NEW YEAR FROM AXEMAN! 2008! NEVAR FORGET!
22:49:47 <allbery_b>  @let isn't seen by @type, only by @run
22:49:49 <EuphoriaSalad> shachaf: hmm, but (+) `on` log 3 3 is just a single argument?
22:49:59 <EuphoriaSalad> err, returns just a single value
22:50:06 <EuphoriaSalad> sorry for sleepyness :(
22:50:13 <shachaf> EuphoriaSalad: That's not how you grouped it anyway.
22:50:29 <EuphoriaSalad> shachaf: but (f . g) x = f (g x)
22:50:31 <Axeman> :>
22:50:46 <shachaf> > ((+) `on` log) 3 3
22:50:47 <lambdabot>  2.1972245773362196
22:50:55 <shachaf> EuphoriaSalad: For one argument.
22:50:56 <Pseudonym> Dammit.
22:51:01 <Pseudonym> *** #haskell *!*@75.116.15.108 :Channel ban list is full
22:51:02 <shachaf> EuphoriaSalad: But (+) has two.
22:51:06 <EuphoriaSalad> > let on op f x y = op (f x) (f y) in exp (on (+) log 3.0 3.0)
22:51:07 <lambdabot>  9.000000000000002
22:51:12 <EuphoriaSalad> shachaf: hmm ok
22:51:26 <Axeman> Happy day.
22:51:29 <shachaf> @pl \f g x -> f (g x)
22:51:30 <lambdabot> (.)
22:51:30 <EuphoriaSalad> shachaf: I considered x a pair, didn't think in curry
22:51:31 <shachaf> @pl \f g x y -> f (g x y)
22:51:32 <lambdabot> (.) . (.)
22:51:36 --- mode: ChanServ set -o Pseudonym
22:51:36 <mxc> @hoogle ReaderT
22:51:37 <lambdabot> Control.Monad.Reader.ReaderT :: newtype ReaderT r m a
22:51:37 <lambdabot> Control.Monad.Reader.ReaderT :: (r -> m a) -> ReaderT r m a
22:51:37 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
22:51:39 <allbery_b> yeh, banlist fullness was noted last time the politibots invaded :(
22:51:56 <allbery_b> may be time to do some consolidation there
22:52:03 <Pseudonym> Well, feel free to clean it out.
22:52:08 * Pseudonym has no clue wtf he's doing
22:52:19 <allbery_b> I have no idea which  ones are needed and which are now obsolete
22:52:21 <Axeman> wtf r u doin
22:52:25 <EuphoriaSalad> > let on op f x y = op (f x) (f y) in (exp . (uncurry (on (+) log)) (3.0, 3.0)
22:52:26 <lambdabot> Unbalanced parentheses
22:52:45 <EuphoriaSalad> > let on op f x y = op (f x) (f y) in (exp . (uncurry (on (+) log))) (3.0, 3.0)
22:52:46 <lambdabot>  9.000000000000002
22:52:46 <allbery_b> would be bad form to let e.g. protontorpedo back in (yes, it's still around)
22:52:49 <EuphoriaSalad> \o/
22:53:06 <BMeph> @pl \f x g y -> f x (g y)
22:53:06 <lambdabot> ((.) .)
22:53:28 <allbery_b> (as is keal but I last saw that one terrorizing cognet)
22:53:31 <EuphoriaSalad> IMHO uncurrying is more obvious
22:53:41 <BMeph> @pl \f x g y -> (f x (g y))
22:53:41 <lambdabot> ((.) .)
22:53:50 <Pseudonym> Just a moment, allbery_b, I see I did that wrong.
22:54:04 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] DEL allbery_b!*@*
22:54:06 <EuphoriaSalad> currying can be confusing if the argument is intrinsically a pair
22:54:13 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] ADD allbery_b 38
22:54:15 <Pseudonym> Better.
22:54:34 <allbery_b> heh.  the first one did work (chanserv told me)
22:54:45 <Pseudonym> Sure, but I looked at the list.  It wasn't clean.
22:55:43 <EuphoriaSalad> @hoogle Invertible
22:55:43 <lambdabot> No matches found
22:55:46 <EuphoriaSalad> @hoogle Bijection
22:55:47 <lambdabot> No matches found
22:55:55 * Pseudonym briefly considers going on an op-privs-creating frenzy, then considers shapr's wrath
22:55:57 <Pseudonym> Better not.
22:56:00 <BMeph> @wiki Bijection
22:56:00 <lambdabot> http://www.haskell.org/haskellwiki/Bijection
22:56:17 <EuphoriaSalad> arcane lambdabot :)
22:56:24 <BMeph> ?bo
22:56:25 <lambdabot> :)
22:56:25 <allbery_b> @gwiki Bijection
22:56:26 <lambdabot> No Result Found.
22:56:35 * EuphoriaSalad uses book of lambdabot mastery
22:57:13 <EuphoriaSalad> BMeph: doesn't exist
22:57:18 * allbery_b prefers @gwiki since @wiki just gives you a page for whatever you named
22:57:29 <allbery_b> whether it exists or not
22:58:09 <EuphoriaSalad> is there something like "typelet" for ghci / lambdabot?
22:58:15 <EuphoriaSalad> or "classlet"
22:58:45 <allbery_b> if that's what I think it is (scoped types/classes), no
22:58:52 <EuphoriaSalad> yes
22:59:26 <allbery_b> problem is, ghc doesn't have scoped types or classes
23:00:01 <shachaf> allbery_b: I think EuphoriaSalad doesn't even want them scoped.
23:00:01 <darkness3477> Hey, I've been wanting to learn a new programming language, just for the challenge of it, and one completely different from the few I know (And some I know only enough to read), and I decided on a functional language.
23:00:02 <darkness3477> Basically, all I've done up to this moment is download GHC, a few other things related to it, and search around for a few tutorials. As of yet, I've not found a tutorial that I like. However, "Write yourself a Scheme in 48 hours" does look more promising than anything I've found yet. Could any of you recomend a tutorial? perhaps one that is quite fast paced?
23:00:03 <allbery_b> so neither ghci nor LB can have them (well, in theory something ugly and probably buggy could be done for LB...)
23:00:07 <shachaf> allbery_b: Just defined interactively.
23:00:11 <mxc> @hoogle liftIO
23:00:12 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
23:01:08 <darkness3477> Also, do you think Haskell is a good language for learning, or are there other ones more suited to a hobbyist?
23:01:15 <EuphoriaSalad> as shachaf hinted at, the point is not really scoped types, but being able to use types on the fly in lambdabot
23:01:32 <Pseudonym> OK, cleared out a bit of the ban lisdt.
23:01:33 <Pseudonym> list
23:02:10 <Pseudonym> And Mitt08 is in.
23:02:13 <allbery_b> yeh, but scoped types are the easiest implementation that would provide them in both ghci and LB
23:02:45 <allbery_b> and adding something like let data a = ... has been discussed for ghc
23:03:25 <Lemmih> darkness3477: Haskell is excellent for hobbyists. You can get a lot of stuff done in a short time.
23:04:00 <EuphoriaSalad> how would you encode an invertible function that knows its inverse?
23:04:07 <EuphoriaSalad> with data, I suppose
23:04:13 <conal> EuphoriaSalad: yep.
23:04:18 <Pseudonym> Or typeclasses.
23:04:26 <conal> EuphoriaSalad: See Data.Bijection in TypeCompose
23:04:29 <conal> @wiki TypeCompose
23:04:29 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
23:04:42 <darkness3477> Lemmih: Thanks, any suggestions on good tutorials and perhaps an IDE. I know Emacs has a Haskell mode, and gedit supports syntax highlighting. Are there any IDE's that offer code completion, and other things that help a lazy programmer :P
23:04:43 <EuphoriaSalad> conal: oh, I hoogled for Bijection but nothing showed up
23:04:53 <allbery_b> darkness3477: Haskell has something of a steep learning curve if you're not used to functional languages.  but it's worth it
23:05:24 <allbery_b> both in terms of sheer mind-expanding-ness and in what you can easily do once you understand what's going on even a little bit
23:05:24 <shachaf> darkness3477: I think most people here use vim/emacs.
23:05:33 <EuphoriaSalad> darkness3477: I'm a newb too and loving it :) don't get discouraged at first
23:05:34 <Lemmih> darkness3477: Not really. I use emacs.
23:05:53 <EuphoriaSalad> darkness3477: http://www.haskell.org/haskellwiki/Meta-tutorial
23:05:53 <lambdabot> Title: Meta-tutorial - HaskellWiki
23:06:23 <allbery_b> I use emacs as well.  others use nvi.  there's a pluging for eclipse but it's underfeatured at present.  there's also a thing that plugs into visual studio for windows users, but it's reportedly underfeatured and somewhat buggy
23:06:42 <allbery_b> er.  others use vim.  I htink I'm the only nvi user here :)
23:07:00 <EuphoriaSalad> I use emacs but would like a richer IDE too
23:07:01 * allbery_b is so used to replacing vim with nvi that he did it there... oops
23:07:07 <darkness3477> Emacs'll do then! I'll look through that page again, but I think I've seen it before. I'm about to have Dinner now, I'll come back if I have any questions! I
23:07:39 <EuphoriaSalad> darkness3477: there was some very fast-paced, practical tutorial if you like that
23:07:46 <conal> anyone know how extend the hoogle db?
23:08:05 <allbery_b> haddock can generate hoogle dbs
23:08:07 <EuphoriaSalad> darkness3477: didn't read it myself, but: http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell
23:08:08 <lambdabot> Title: Hitchhikers guide to Haskell - HaskellWiki
23:08:13 <conal> allbery_b: and then what?
23:08:17 <allbery_b> not sure
23:08:43 <allbery_b> I only know it has that ability, haven't tried to use either haddock or hoogle locally to any great extent
23:09:15 <allbery_b> (tried to use haddock once, but was using an old one on newer code and it was grumpy.  still waiting on haddock.ghc...)
23:09:38 <conal> allbery_b: haddock.ghc is working pretty well for me.
23:10:02 <conal> i'm still waiting for ghc lib docs and hackage to use haddock.ghc
23:10:07 <conal> inching there
23:10:21 <allbery_b> hm, maybe I need to add a build option
23:10:40 <conal> http://www.haskell.org/pipermail/haskell-cafe/2007-December/035954.html
23:10:41 <lambdabot> Title: [Haskell-cafe] Hoogle works once more, http://tinyurl.com/yoavvs
23:11:35 <ac> what's a good way to de-duplicate a list?
23:11:45 <Pseudonym> nub
23:11:51 <Pseudonym> In Data.LIst.
23:11:51 <allbery_b> nub... oh wait, you said a good way :)
23:11:55 <EuphoriaSalad> ac: hmm in python I converted to set and back ;)
23:12:00 <Pseudonym> :-)
23:12:14 <Pseudonym> A better way is sort followed by noDups, which is like the Unix uniq.
23:12:20 <Pseudonym> But I don't think noDups is standard.
23:12:29 <allbery_b> head . group . sort
23:12:36 <EuphoriaSalad> Pseudonym: hmm, the set thing should be efficient too since it uses hashing
23:12:39 <EuphoriaSalad> (I assume)
23:12:50 <EuphoriaSalad> @hoogle Set
23:12:50 <lambdabot> Data.Set :: module
23:12:50 <lambdabot> Data.Set.Set :: data Set a
23:12:50 <lambdabot> Distribution.Simple.Setup :: module
23:12:54 <Pseudonym> No doubt.
23:12:56 <allbery_b> but converting to set and back seems like it might work better
23:12:56 <EuphoriaSalad> @src Set
23:12:57 <lambdabot> Source not found. There are some things that I just don't know.
23:12:59 <ac> Pseudonym: what's wrong with nub?
23:13:01 <Pseudonym> Right, head.group works too.
23:13:05 <Pseudonym> ac: It's O(N^2).
23:13:09 <conal> EuphoriaSalad: probably balanced trees rather than hashing
23:13:13 <Pseudonym> head . group . sort is O(N log N)
23:13:35 <EuphoriaSalad> @src Data.Set.Set
23:13:35 <lambdabot> Source not found. My mind is going. I can feel it.
23:13:45 <allbery_b> @source Data.Set
23:13:45 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
23:13:48 <allbery_b> bah
23:13:51 <EuphoriaSalad> of course, you wouldn't need to actually convert back if a set is ok for your purposes.
23:13:52 <allbery_b> someone should update that
23:14:24 <EuphoriaSalad> since a set is more natural for duplicate-free things anyway
23:14:46 <ac> wouldn't you want "map head (group.sort list)"?
23:14:48 <allbery_b> http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html
23:14:49 <lambdabot> http://tinyurl.com/2h2prk
23:14:57 <allbery_b> yeh
23:15:04 <Pseudonym> A sorted list is pretty natural, too, depending on what you're doing.
23:15:06 <allbery_b> map head . group . sort, sorry
23:15:08 <EuphoriaSalad> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
23:15:09 <lambdabot> http://tinyurl.com/ynl5nk
23:15:20 <Pseudonym> THe omly thing that sorted lists don't do well is single-element membership tests.
23:15:35 <Axeman> PISSSSSSSSSSSSSSSSSSSSSSS
23:15:47 <ac> well, in this case, all I want is to print out the resulting set
23:16:11 <EuphoriaSalad> Pseudonym: hmm, binary search?
23:16:17 <Pseudonym> IN a linked list?
23:16:21 <Pseudonym> I don't think so.
23:16:44 <EuphoriaSalad> oops :)
23:16:52 <EuphoriaSalad> :t fromList
23:16:54 <lambdabot> Not in scope: `fromList'
23:17:00 <allbery_b> :t M.fromList
23:17:01 <lambdabot> Couldn't find qualified module.
23:17:02 <Axeman> I USE JENKEM
23:17:03 <allbery_b> bah
23:17:10 <Axeman> I USE JENKEM
23:17:13 <Axeman> BAH THAT
23:17:17 <Axeman> HAAAAHAHAH
23:17:18 <darkness3477> Just read the second or third paragraph of the Hitchhikers gui... and it's better than anything else. It's the first thing I've read that states it's whitepace sensitive.
23:17:24 --- mode: ChanServ set +o allbery_b
23:17:56 <EuphoriaSalad> > fromList [1,2,3,1,2]
23:17:57 <lambdabot>   Not in scope: `fromList'
23:18:02 <EuphoriaSalad> > Data.Set.fromList [1,2,3,1,2]
23:18:04 <lambdabot>  fromList [1,2,3]
23:18:10 <BMeph> :t Data.Set.toList
23:18:10 <lambdabot> forall a. Data.Set.Set a -> [a]
23:18:34 <mxc> @hoogle StateT
23:18:34 <lambdabot> Control.Monad.State.Lazy.StateT :: newtype StateT s m a
23:18:34 <lambdabot> Control.Monad.State.Lazy.StateT :: (s -> m (a, s)) -> StateT s m a
23:18:34 <lambdabot> Control.Monad.State.Strict.StateT :: newtype StateT s m a
23:18:52 <EuphoriaSalad> why doesn't it process my query?
23:19:25 <shachaf> EuphoriaSalad: Which?
23:19:32 <EuphoriaSalad> > Data.Set.fromList [1,2,3,1,2]
23:19:33 <lambdabot>  fromList [1,2,3]
23:19:47 <EuphoriaSalad> doh, it did
23:19:50 <BMeph> Data.Set> toList.fromList [1,4,2,1,4,6,1,2,4]
23:20:02 <allbery_b> it did.  but the Show instance for Data.Set uses fromList :)
23:20:11 <EuphoriaSalad> hehe
23:20:12 <jz87_> is there a way to automaticlaly derive show, read for records?
23:20:13 <lambdabot> jz87_: You have 1 new message. '/msg lambdabot @messages' to read it.
23:20:14 <ac> anybody around here ever play Boggle?
23:20:26 <allbery_b> jz87_: just do so
23:20:49 <allbery_b> data R = R {a :: Int, b :: String} deriving (Read, Show)
23:20:52 <BMeph> Data.Set>  toList.fromList [1,4,2,1,4,6,1,2,4]
23:21:02 <jz87_> ah I see what's the problem
23:21:04 <jz87_> can't serialize TChan
23:21:11 <allbery_b> yep
23:21:29 <EuphoriaSalad> hmm wouldn't it be better if lambdabot just ran with everything imported already?
23:21:40 <allbery_b> you could create your own custom instances that omit it or create dummy instances for TChan
23:22:01 <allbery_b> EuphoriaSalad: it does, you just have to fully qualify (like with ghci)
23:22:11 <allbery_b> problem with doing it unqualified are collisions
23:22:16 <EuphoriaSalad> I see.
23:22:19 <ac> ...or even know what Boggle is?
23:22:21 <allbery_b> for example, Data.Map also uses fromList
23:22:31 <allbery_b> ac: I used to but it's been years
23:22:48 <ac> hmm. well, just for general amusement...
23:22:51 <EuphoriaSalad> couldn't that be solved by type inferrence or explicit type annotations allbery_b?
23:22:52 <hpaste>  ac pasted "Boggle in Haskell" at http://hpaste.org/4745
23:23:13 <EuphoriaSalad> only if fromList belonged to a class, I suppose
23:23:37 <allbery_b> right, Haskell's way of handling that is typeclasses.
23:23:42 <allbery_b> or qualified modules
23:24:26 <allbery_b> not sure how automatically doing absent a typeclass so would interact with polymorphism
23:24:34 <EuphoriaSalad> btw, this channel rocks. so much more friendly and helpful than others
23:24:36 <allbery_b> or with type inference in general
23:24:41 <BMeph> Speaking of which, isn't fromList in Traversable?
23:24:42 <EuphoriaSalad> \o/
23:24:51 --- mode: allbery_b set -o allbery_b
23:25:39 <EuphoriaSalad> maybe there is some odd correlation between politeness and liking functional programming
23:25:43 <faxathisia> stop asking ##php to help with #haskell ?!
23:25:55 <EuphoriaSalad> hehe
23:26:03 <shachaf> @karma #haskell
23:26:03 <lambdabot> #haskell has a karma of 6
23:26:11 <EuphoriaSalad> :)
23:26:25 <allbery_b> well, except I've heard the ocaml channel is nowhere near as friendly
23:26:31 <ac> allbery_b: only problem is the damn "Qu" tile
23:26:31 <EuphoriaSalad> oh
23:26:34 <shachaf> EuphoriaSalad: Which channels are you comparing this with?
23:26:35 <allbery_b> mostly it's cu;ture
23:26:39 <allbery_b> culture
23:26:41 <EuphoriaSalad> shachaf: #not-math :/
23:27:06 <EuphoriaSalad> was somewhat of a regular there but left it for good because people hurt me all the time
23:27:25 <shachaf> EuphoriaSalad: I'd guess that many people there prefer functional programming too, no?
23:27:44 <EuphoriaSalad> shachaf: hmm yes. maybe my hypothesis is not so strong
23:28:16 <allbery_b> #haskell is the friendliest large channel I've seen
23:28:41 <allbery_b> it's the culture; we try to stay friendly instead of letting things degenerate as the channel grows
23:28:50 --- mode: ChanServ set +o Pseudonym
23:28:51 --- mode: ChanServ set -o Pseudonym
23:28:53 <Pseudonym> Cool.
23:28:58 <Pseudonym> Just testing my new macros.
23:29:37 --- mode: ChanServ set +o Pseudonym
23:29:40 <allbery_b> this requires some effort, as annoyance tends upward as the channel size does
23:29:44 --- mode: Pseudonym set -o SampleTroll
23:29:44 --- kick: SampleTroll was kicked by Pseudonym (game over, man.  game over.)
23:29:53 <Pseudonym> Excellent.
23:30:00 <faxathisia> SampleTroll lol
23:30:20 <EuphoriaSalad> no dark sarcasm in the chatroom...
23:30:40 <allbery_b> oper leave them bots alone?
23:30:47 <EuphoriaSalad> :)
23:30:51 <allbery_b> hm, actuallt
23:30:58 <allbery_b> oper, leave them n00bs alone
23:31:26 <Axeman> jenkem...
23:31:35 --- mode: Pseudonym set -o Axeman
23:31:35 --- kick: Axeman was kicked by Pseudonym (game over, man.  game over.)
23:31:43 <Pseudonym> Except that the ban list is still full.
23:31:57 <Pseudonym> Dammit.
23:32:00 <allbery_b> have to roust out dons and find out what's safely cleanable
23:32:08 <Pseudonym> It's obviously not the same as the autorem list.
23:32:10 <allbery_b> or maybe shapr knows
23:32:12 <Pseudonym> Which is what I've been cleaning out.
23:32:23 <Pseudonym> How do you even see the ban list?
23:32:37 <frivol> Most channels don't have to create synthetic trolls for practice
23:32:51 <dibblego> /banlist in xchat
23:32:53 <Pseudonym> I'm my own target practice.
23:33:03 <allbery_b> wow, that's a large list
23:33:06 * Pseudonym is using sirc
23:34:23 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] ADD dibblego 38
23:34:35 <Pseudonym> Go for it, dibblego. :-)
23:34:52 <dibblego> I did, it's pretty dang big :)
23:35:01 <Axeman> dude, wut?
23:35:22 <EuphoriaSalad> hmm, full ban list? isn't disk space cheap these days? ;)
23:35:32 <dibblego> why not just empty the banlist then add as required?
23:35:45 <Pseudonym> I wouldn't do that without asking shapr first.
23:35:51 <bd_> EuphoriaSalad: IRC servers typically keep all info in RAM though :)
23:35:51 <allbery_b> generically, it looks like "/mode #channel +b" might work (but it doesn't in xchat, at least)
23:35:54 <dibblego> good point
23:36:01 <EuphoriaSalad> bd_: ok, but still ;)
23:36:09 <allbery_b> we definitely want to keep at least some of those, I spotted protontorpedo in there
23:36:19 <Pseudonym> Ah.
23:36:21 <Pseudonym> Yes, there it is.
23:36:23 <Pseudonym> And damn it's bigg.
23:36:41 <EuphoriaSalad> I'd think most trolls wouldn't come back
23:36:42 <Pseudonym> I think we can remove Keal.
23:36:46 <Pseudonym> Unlikely to be back.
23:36:51 <EuphoriaSalad> so the as-required approach might work
23:36:57 <allbery_b> protontorpedo has been back recently
23:37:13 <Pseudonym> Anyway, time for me to make dinner.
23:37:17 <Pseudonym> SO fare well, and BBL.
23:38:14 <allbery_b> no, last I saw keal was working his magic on cognet instead of freenode
23:38:28 <allbery_b> hit #bcfg2 and #lopsa, at least
23:38:38 <mxc> @hoogle Ord
23:38:38 <lambdabot> Data.Ord :: module
23:38:38 <lambdabot> Prelude.Ord :: class Eq a => Ord a
23:38:38 <lambdabot> Data.Ord.Ord :: class Eq a => Ord a
23:40:26 <ac> @djin (a -> b -> c) -> (b -> a) -> (b -> c)
23:40:26 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
23:40:45 <jz87_> hey
23:40:45 <ac> @djinn (a -> b -> c) -> (b -> a) -> (b -> c)
23:40:45 <lambdabot> f a b c = a (b c) c
23:40:55 <jz87_> how would I express type class dependencies?
23:41:01 <jz87_> I want to define
23:41:07 <jz87_> class Serializable
23:41:12 <jz87_> and express that
23:41:19 <jz87_> anything that is a Read and Show
23:41:23 <jz87_> is also Serializable
23:41:33 <ac> @pl (\a b c = a (b c) c)
23:41:33 <lambdabot> (line 1, column 9):
23:41:34 <lambdabot> unexpected "="
23:41:34 <lambdabot> expecting pattern or "->"
23:41:40 <Lemmih> jz87_: You need GHC extensions to do that.
23:41:43 <ac> @pl (\a b c -> a (b c) c)
23:41:43 <lambdabot> flip flip id . liftM2
23:41:44 <jz87_> which one?
23:41:50 <jz87_> that's what I've been trying to find out
23:41:54 <ac> huh?
23:41:59 <jz87_> which extension do I need to be able to say that?
23:42:24 * ac scratches head
23:42:36 <Lemmih> jz87_: overlapping instances and undecidable instances, I'd guess.
23:44:04 <ac> the @pl tool is great
23:45:21 <faxathisia> @@ @pl @djinn a -> (a -> b) -> b
23:45:22 <lambdabot>  f = flip id
23:45:25 <faxathisia> :D
23:45:35 <jz87_> ok
23:45:47 <EuphoriaSalad> > logBase 2 (4 :: Int)
23:45:49 <lambdabot>   add an instance declaration for (Floating Int)
23:45:49 <lambdabot>     In the expression: logBa...
23:45:52 <jz87_> I need to enable -XFlexibleInstances and -fallow-undecidable-instances
23:45:55 <EuphoriaSalad> this is odd.
23:46:16 <ac> is @@ sort of like a unix pipe?
23:46:18 <EuphoriaSalad> do I really have to explicitly convert with fromInteger?
23:47:08 <faxathisia> @@ @pl @djinn (a -> x) -> (a -> y) -> (a -> z) -> a -> (x -> y -> z -> w) -> w
23:47:09 <lambdabot>  f = (liftM2 flip .) . liftM2 (flip . flip id)
23:47:17 <faxathisia> :t (liftM2 flip .) . liftM2 (flip . flip id)
23:47:19 <lambdabot> forall b c b1 a1 (m :: * -> *). (Monad m) => m a1 -> m b1 -> m b -> m ((a1 -> b1 -> b -> c) -> c)
23:48:20 <ac> could someone add some parenthesis to "flip flip id . liftM2"?
23:48:28 <faxathisia> (flip flip id . liftM2)
23:48:43 <faxathisia> ((flip flip id) . (liftM2))
23:48:50 <faxathisia> (((flip flip) id) . (liftM2))
23:49:02 <EuphoriaSalad> it seems that often there is a better pointless translation than all these pesky flip's
23:49:03 <faxathisia> :t (flip flip id . liftM2, (((flip flip) id) . (liftM2)))
23:49:04 <lambdabot> forall a1 a2 r a11 a21 r1. ((a1 -> a2 -> r) -> (a2 -> a1) -> a2 -> r, (a11 -> a21 -> r1) -> (a21 -> a11) -> a21 -> r1)
23:49:11 <ac> ah, I guess (flip . flip) is different from (flip flip)
23:49:22 <faxathisia> :t ((flip . flip), (flip flip))
23:49:23 <lambdabot> forall a b c a1 b1 c1. ((a -> b -> c) -> a -> b -> c, b1 -> (a1 -> b1 -> c1) -> a1 -> c1)
23:49:26 <ac> :t (flip . flip)
23:49:27 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
23:50:18 <faxathisia> @@ @type @pl @djinn (a -> a)
23:50:19 <lambdabot>  parse error on input `='
23:50:25 <ac> :t flip flip
23:50:26 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
23:50:43 <faxathisia> ac: flip . flip = id
23:50:46 <bd_> (flip . flip) x is equivalent to flip (flip x)
23:50:48 <bd_> :)
23:50:54 <bd_> making it an identify
23:50:56 <bd_> identity*
23:51:58 <ac> > id 1
23:52:00 <lambdabot>  1
23:52:05 <ac> > (flip.flip) 1
23:52:05 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
23:52:12 <ac> thought so. They're not the same
23:52:22 <faxathisia> ac: flip . flip = id
23:52:27 <ac> > (flip.flip) 1 1
23:52:28 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
23:52:38 <faxathisia> :t id
23:52:39 <dibblego> a bounded id that is
23:52:39 <lambdabot> forall a. a -> a
23:52:42 <faxathisia> :t flip . flip
23:52:43 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
23:52:49 <faxathisia> (a -> b -> c) -> a -> b -> c = u -> u
23:53:01 <dibblego> > (flip . flip) (-) 7 42
23:53:09 <dibblego> > (-) 7 42
23:53:11 <lambdabot>  -35
23:53:12 <lambdabot>  -35
23:53:12 <faxathisia> MGU: u = a -> b -> c
23:53:34 <ac> MGU?
23:53:39 <faxathisia> most general unifier
23:53:40 <dibblego> ?check \f a b -> (flip . flip) f a b == f (a :: Int) (b :: Int)
23:53:41 <lambdabot>  Add a type signature
23:53:57 <dibblego> ?check \f a b -> (flip . flip) f a b == (f :: Int -> Int -> Int) a b
23:53:57 <lambdabot>  OK, passed 500 tests.
23:54:11 <EuphoriaSalad> dibblego: lol, was just trying to do this too
23:54:20 <faxathisia> @unpl flip . flip
23:54:20 <lambdabot> (\ i b c -> i b c)
23:54:48 <ac> faxathisia: so what you were saying is (flip . flip) is the same as id for a subset of types
23:54:54 <faxathisia> no
23:55:26 <dibblego> lambdabot said it 500 times!
23:56:29 <EuphoriaSalad> @djinn (a->b->c) -> (b->a->c)
23:56:30 <lambdabot> f a b c = a c b
23:57:03 <mxc> @hoogle max
23:57:03 <lambdabot> Prelude.max :: Ord a => a -> a -> a
23:57:03 <lambdabot> Data.Ord.max :: Ord a => a -> a -> a
23:57:03 <lambdabot> Prelude.maxBound :: Bounded a => a
23:58:25 <EuphoriaSalad> @djinn ((a,b) -> c) -> (a -> b -> c)
23:58:25 <lambdabot> f a b c = a (b, c)
23:58:31 <EuphoriaSalad> heh
23:59:02 <faxathisia> @@ @type @pl @djinn (((a, b) -> c) -> (a -> b -> c), (a -> b -> c) -> ((a, b) -> c))
23:59:04 <lambdabot>  parse error on input `='
23:59:08 <faxathisia> @@ @pl @djinn (((a, b) -> c) -> (a -> b -> c), (a -> b -> c) -> ((a, b) -> c))
23:59:08 <lambdabot>  f = ((. (,)) . (.), (`ap` snd) . (. fst))
23:59:15 <faxathisia> yuck >:|
23:59:56 <EuphoriaSalad> yeah
