00:00:19 <oerjan> most things in Control.Monad can be generalized to Applicative/Alternative, but the bits are spread among Control.Applicative, Data.Foldable and Data.Traversable
00:16:53 <dmwit> http://mine.icanhascheezburger.com/completestore/pahrenthaseekat128413023897146250.jpg
00:16:54 <lambdabot> http://tinyurl.com/2t8vfx
00:20:22 <glguy> seems like lambdacats went steeply downhill and then stalled
00:20:48 <Zao> They ran out of joke thunks.
00:23:49 <dmwit> Don't worry, icanhascheezburger is still excellent.
00:29:06 <dmwit> http://tinyurl.com/2m7hwl # happy face
00:29:07 <lambdabot> Title: i try to put on a happy face « Lolcats &#8216;n&#8217; Funny Pictures - I Can Ha ...
00:29:30 <dmwit> Oops, sorry, that one was supposed to go to -blah
00:35:12 <ibid> dons: feed added
02:07:07 <mauke> @quote guild
02:07:08 <lambdabot> wli says: If you can fly with Python, then you can fold space like a Guild Navigator with Haskell?
02:16:33 <roconnor> abs (integral f) <= integral (abs f)  ?
02:17:05 <roconnor> I guess it is like the triangle inequality
02:18:32 <doserj> roconnor: seperate f in the positive and the negative part.
02:19:41 <araujo> morning
02:29:07 <martin> hello there?
02:29:13 <roconnor> hi
02:29:15 <martin> am I right here in the haskell room?
02:29:20 <roconnor> you are
02:29:34 <martin> ok, may I ask you a question about haskell?
02:29:46 <roconnor> yes
02:29:50 <martin> I'll get an error and haven't a solution yet
02:29:56 <roconnor> @paste
02:29:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:30:01 <martin> error is: ERROR parser.hs:110 - Equations give different arities for "parseKoords"
02:30:14 <roconnor> post your code on the hpaste.org page
02:30:16 <martin> code is: parseKoords :: [Koord]	->	[Symbol]	->	Result [Koord]
02:30:16 <martin> parseKoords tok (Lpar:syms)				=	case parseKoord syms of
02:30:16 <martin> 											{
02:30:16 <martin> 												Error str				->	Error str;
02:30:16 <martin> 												--Result kor (Lpar:syms)	->	parseKoords tok++[kor] syms;
02:30:17 <martin> 												Result kor _			->	Result tok++[kor];
02:30:19 <martin> 												_						->	Error "missing '('"
02:30:21 <martin> 											}
02:30:23 <martin> parseKoords _							= 	Error "missing '('"
02:30:41 <martin> I commented one line out but the error is still there
02:30:52 <martin> oh sorry
02:30:56 <martin> hpaste.org?
02:30:58 <doserj> try parseKoords _ _ = Error "missing '('"
02:31:09 <roconnor> what doserj said
02:31:38 <roconnor> martin: hpaste.org is where we put long things to look at rather than flooding the IRC channel with messages.
02:31:45 <roconnor> :)
02:31:51 <martin> ok, thanx, i think i'm blind
02:32:40 <roconnor> martin: what is the declaration for Result?
02:32:58 <quicksilver> martin: your first parseKoords takes two parameters
02:33:06 <quicksilver> martin: toks, and Lpar:syms
02:33:12 <quicksilver> martin: the second only takes one _
02:33:14 <martin> result is:data Result a  = Result a [Symbol] | Error String  deriving Show
02:33:21 <quicksilver> martin: you mean parseKoords _ _ = Error ...
02:33:22 <quicksilver> IMO
02:33:24 <martin> yeah, that was it
02:33:36 <martin> yeah, parseKoords __
02:33:42 <martin> _ _ = Error ... was right
02:34:24 <quicksilver> martin: also, your recurive calls to parseKoords only give it one parameter
02:35:00 <martin> quicksilver: how can I correct this?
02:35:12 <quicksilver> martin: by supplying two parameters?
02:35:19 <quicksilver> oh, hang on
02:35:23 <quicksilver> my mistake
02:35:32 <quicksilver> I am mistaking 'parseKoord' for 'parseKoords'
02:35:44 <martin> ok, it give's both
02:35:44 <quicksilver> didn't realise there were two different functions one without the s :)
02:35:56 <doserj> but the commented out line has a mistake still, I think :)
02:36:07 <martin> maybe
02:36:29 <martin> I have other mistakes and then I can test it
02:36:36 <doserj> you probably need some parantheses
02:36:44 <roconnor> martin: it is possible to use monads to simplify your code.
02:37:09 <roconnor> martin: although I don't know if you are ready for that level yet ;)
02:37:24 * doserj smiles at reading "use monads" and "simplify" in the same sentence
02:38:00 <roconnor> doserj: and I see a way of using monads to make your code more complicated :P
02:38:29 <martin> thx for the help, but first I'll try to find other mistakes an than, when time is left, I'll try to simplify my code ;-)
02:39:09 <roconnor> martin: that's perfectly fair.  Just keep it in the back of your mind.
02:40:28 <roconnor> martin: this | Error String idom is so common that we have an abstract way of handling it that is in the standard library :)
02:41:08 <martin> yeah, but at university they prefer to teach us haskell like this :-(
02:41:36 <roconnor> martin: the abstract way of handling it involves learning a new concept, so you may not want to take it on right away.
02:42:04 <quicksilver> I think handling it as an explicit | Error is a very useful thing to think about
02:42:19 <quicksilver> and, to be honest, I don't think ErrorT is a very big win in practice
02:42:58 <quicksilver> there are two reasons to use abstraction: (1) to improve expressiveness/simplify code and (2) to take advantage of generic combinators
02:43:14 <quicksilver> ErrorT doesn't make a really powerful case for either of those, in my personal opinion.
02:43:35 <roconnor> quicksilver: getting rid of the the case anaysis used to propogate errors is (1)
02:43:37 <martin> ErrorT? Never heared about
02:43:46 <quicksilver> roconnor: yes, it is. definitely.
02:44:03 <quicksilver> roconnor: but the price you pay is runErrorT and lift all over the place
02:44:26 <roconnor> quicksilver: I was going to suggest using the (Either String) monad.
02:44:40 <roconnor> it's very lightweight.
02:45:34 <visof> hello
02:45:41 <roconnor> visof: hi
02:45:56 <visof> how can i put lambdabot in my own irc channel?
02:46:10 <quicksilver> roconnor: the other price you pay is sequentialising your code
02:46:36 <roconnor> quicksilver: it was already sequenced by the chaning of the error propogation.
02:46:43 <roconnor> chaining
02:47:07 <roconnor> visof: I think only a lambdabot admin can do that.
02:47:23 <sjanssen> visof: what channel?
02:48:09 <visof> #more
02:48:34 <quicksilver> roconnor: yeah, I just mean visually
02:48:37 <roconnor> quicksilver: I only want to use the (Either String) monad to remove the case analysis that propagates the error.  Although martin hasn't posted that code, I'm sure it is lurking ;)
02:48:37 <quicksilver> roconnor: <- noise
02:49:36 <sjanssen> visof: what is #more?
02:50:43 <visof> sjanssen this my own channel "for general conversation"
02:50:50 <visof> this is*
02:51:18 <sjanssen> lambdabot: @join #more
02:51:58 <visof> sjanssen thanks very much
02:57:06 <sjanssen> @karma-all
02:57:11 <lambdabot>  "fglock"              442
02:57:11 <lambdabot>  "Aankhen"             219
02:57:11 <lambdabot>  "avar"                187
02:57:11 <lambdabot>  "moritz"              164
02:57:11 <lambdabot>  "dlo"                 157
02:57:13 <lambdabot> [950 @more lines]
02:57:27 <sjanssen> those #perl6 cheaters!
02:58:22 <roconnor> @karma
02:58:22 <lambdabot> You have a karma of 2
02:59:42 <mauke> @karumba
02:59:42 <lambdabot> You have a karma of 10
03:00:03 <doserj> @karma
03:00:03 <lambdabot> You have a karma of 1
03:00:09 <mux> @karma
03:00:10 <lambdabot> You have a karma of 3
03:00:49 <doserj> .oO(could be worse)
03:04:12 <roconnor> @karma lambdabot
03:04:12 <lambdabot> lambdabot has a karma of 51
03:04:35 <luqui> @tell lambdabot lambdabot++
03:04:36 <lambdabot> Nice try ;)
03:19:29 <lichtkind> audreyt: hello
03:29:06 <xf650> @karma
03:29:06 <lambdabot> You have a karma of 0
03:32:07 <michaelw> hi, is there some problem with compiling big constants?
03:32:20 <dwyatt> @karma
03:32:20 <lambdabot> You have a karma of 0
03:32:58 <swiert> michaelw: what type of constants? You may need to use Integer instead of Int - other than that it should work...
03:34:25 <mauke> michaelw: for doubles, yes
03:34:36 <mauke> or any fractional type, really
03:34:41 <michaelw> swiert: three lists of length 7500, small integers, and simple data constructors
03:35:18 <swiert> michaelw: ghc should be able to cope. I've never tried anything that size myself...
03:35:31 <michaelw> ghc compiles already 10mins on that
03:35:46 <sjanssen> michaelw: what version of ghc?
03:35:50 <michaelw> 6.6.1
03:36:59 <michaelw> hmm, I'm going for lunch, if it's not finished by then, I'll investigate...
03:38:15 <quicksilver> michaelw: I have heard someone else report thatn ghc is slow compiling rather long constant lists
03:38:23 <quicksilver> I don't know if there is an answer
03:38:28 <quicksilver> or if newer versions go faster
03:40:21 <sjanssen> 6.8 seems to work well here
03:42:39 <quicksilver> not sure if it's related to http://hackage.haskell.org/trac/ghc/ticket/1552
03:42:41 <lambdabot> Title: #1552 (GHCi thinks large list literals impossible?) - GHC - Trac
03:42:53 <quicksilver> slightly more ghc guts than I can digest
03:44:07 <sjanssen> quicksilver: I specifically remember a bug about large do blocks
03:45:28 <quicksilver> sjanssen: sounds like it could be using up ghc stack space building/traversing the ADT
03:45:34 <quicksilver> sjanssen: causing much slowness
03:45:37 <quicksilver> but that's guesswork.
03:46:31 <sjanssen> ghc --make foo  9.23s user 0.43s system 95% cpu 10.147 total
03:46:49 <sjanssen> where foo has three lists with about 7000 lines in each
03:46:55 <sjanssen> 6.8.1, by the way
03:54:37 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/4287#a1
03:57:40 <hashendgame> @pl \x -> [last x]
03:57:40 <lambdabot> return . last
03:57:57 <Botje> @quote SPJ
03:57:57 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
03:57:57 <lambdabot>  what you just said?"
03:58:02 <Botje> :)
03:59:28 <Sizu1> can somebody try to explain this line to me? data TypeRep = TypeRep !Key TyCon [TypeRep]
03:59:34 <Sizu1> what does the '!' do there?
03:59:54 <Plareplane> strictness
04:00:44 <Plareplane> http://users.aber.ac.uk/afc/stricthaskell.html#seq
04:00:45 <lambdabot> Title: Making Haskell programs faster and smaller
04:00:54 <Plareplane> (just random first link off google)
04:01:28 <Sizu1> Plareplane: thanks
04:04:48 <Sizu1> what is this Data.Typeable.Key, i cannot find it's definition?
04:05:04 <Sizu1> a better question, how can in instantiate a Typeable
04:05:23 <mauke> data Foo ... deriving (Typeable)
04:05:51 <Sizu1> from existing type like (a,b)
04:06:00 <Sizu1> or (,)
04:06:12 <mauke> those are already instances of Typeable
04:06:30 <Sizu1> doesnt seem like it... there is one for ()
04:07:08 <mauke> > typeOf ()
04:07:10 <lambdabot>  ()
04:07:19 <mauke> > typeOf (1,2)
04:07:20 <lambdabot>  (Integer,Integer)
04:08:01 <Syzygy-> !get_shapr
04:08:08 <Syzygy-> @get_shapr
04:08:09 <lambdabot> shapr!!
04:08:11 <Syzygy-> That's better
04:08:51 <nornagon> :t typeOf
04:08:52 <lambdabot> forall a. (Typeable a) => a -> TypeRep
04:09:11 <nornagon> @docs Typeable
04:09:11 <lambdabot> Typeable not available
04:10:37 <idnar_> > typeOf (1,2)
04:10:38 <lambdabot>  (Integer,Integer)
04:10:41 <quicksilver> Sizu1: you shouldn't need to derive typeable often; it should be automatically deriveable for most type
04:10:44 <idnar> oops
04:11:05 <Sizu1> quicksilver: it doesnt seem to work for tuples
04:11:07 <quicksilver> Sizu1: you'd need to derive it yourself if you were doing something like impredicative polymorphism I think
04:11:30 <quicksilver> Sizu1: it does, as mauke just demonstrated?
04:12:05 <Sizu1> http://hpaste.org/4288#a3
04:12:33 <Sizu1> select' [(0, False), (1, True)] :: [(Bool,Integer)] -- []
04:13:29 <Sizu1> ok Integer,Bool is working :P but not the other way arond what makes perfect sence
04:13:35 <Sizu1> i just made a fool out of myself
04:13:53 <quicksilver> :)
04:14:22 <quicksilver> incidentally, I would like to record that I do not think this is sane programming style :)
04:14:28 <quicksilver> but good luck with whatever you are trying to do
04:15:08 <Sizu1> define sane
04:15:48 <Sizu1> @google sane
04:15:49 <lambdabot> http://www.sane-project.org/
04:15:49 <lambdabot> Title: SANE - Scanner Access Now Easy
04:15:52 <Sizu1> lol
04:16:45 <bringert> has anyone had a go at Wide Finder in Haskell? see http://www.tbray.org/ongoing/When/200x/2007/10/30/WF-Results
04:16:46 <lambdabot> Title: ongoing &#xb7; WF XI: Results
04:18:49 <michaelw> quicksilver: oh, cute. I get the "linkBCO: >= 64k insns in BCO" thing with runhaskell, so this seems to be related
04:19:07 <michaelw> anyway, it compiled (15min), let's see whether it runs...
04:19:59 <Sizu1> quicksilver: just trying to model relational theory in haskell
04:20:13 <Sizu1> for the fun of it
04:20:20 <michaelw> ahum... "milestone changed from 6.8 branch to _|_"
04:20:44 <quicksilver> Sizu1: I know. I don't really think type-directed project is the right way to do it.
04:20:52 <quicksilver> unless you intend one unique type per column
04:20:57 <quicksilver> but then you have a problem with renaming
04:20:58 <Sizu1> that's how it should be
04:21:09 <quicksilver> since you need a way to generate fresh types
04:21:29 <quicksilver> and I don't believe there is a general way to generate fresh types like that
04:22:19 <quicksilver> michaelw: as a workaround, you could write the big list to a file and "read . unsafePerformIO readFile" it
04:22:44 <michaelw> yeah, there are any number of workarounds, but meh...
04:22:57 <quicksilver> Sizu1: for example, suppose a relation has columns A and B, and you do a full outer join a.k.a. cartesian product with itself.
04:23:07 <quicksilver> Sizu1: the new relation has columns A B A B
04:23:19 <quicksilver> Sizu1: if you want unique typing, you have to generate at least two fresh types for that
04:23:57 <Sizu1> permutation, hmmm
04:24:19 <Sizu1> true
04:24:57 <Sizu1> simple answer, dont do outer joins! hehe
04:25:14 <quicksilver> the problem is not only with outer joins
04:25:19 <quicksilver> that was just the simplest example
04:25:24 <quicksilver> take a natural join on B
04:25:29 <quicksilver> then the result relation has A B A
04:25:43 <quicksilver> this is a natural query (pairs of people with the same age)
04:26:15 <quicksilver> I say this partly to convince you that I have thought about this issue quite carefully :)
04:26:21 <quicksilver> it is something that interests me personally.
04:26:31 <Sizu1> how about this: ABA is not normalized and as such should not exist
04:27:33 <Sizu1> a pair is (A,A) and that's a new type
04:27:43 <quicksilver> normalisation is about storage
04:27:45 <quicksilver> not expressions
04:27:54 <quicksilver> it's stupid to store non-normalised data, you get anomalies
04:27:55 <Sizu1> normalization is part of the relational theory
04:28:04 <quicksilver> that doesn't mean it's stupid to calculate non-normalised expressions
04:28:12 <quicksilver> most useful queries produce non-normalised data :)
04:28:16 <Sizu1> have the pair as (A,A)
04:28:23 <quicksilver> don't forget relations are the model for the whole query language
04:28:30 <quicksilver> not just the base storage model
04:28:40 <quicksilver> that's non-compositional then
04:28:49 <dmwit> Hmmm, you must have a different definition of "normalized" to me.
04:28:50 <quicksilver> A B join B C has a 'different shape' to A B join B A
04:29:24 <quicksilver> dmwit: my natural join would result in something non-normalised: it would store each person's name many times.
04:29:40 <quicksilver> dmwit: but, it was a calculation, not a base relation to be stored.
04:30:03 <dmwit> Oh, never mind, I'm just not thinking straight.
04:30:28 <Sizu1> the theory states nothing abotu storage though. every relation produced from calculation is that -- a relation
04:30:45 <quicksilver> Sizu1: you misunderstand something important
04:30:50 <quicksilver> normalization is about anomalies
04:30:54 <quicksilver> it *is* about storage
04:31:05 <quicksilver> you shuoldn't store data in a way which permits anomalies, if possible.
04:31:28 <quicksilver> however, there is no rule in relational theory than all expressions of the calculus or algebra should result in normalised relations.
04:31:37 <quicksilver> that would make the language so weak as to be useless.
04:31:53 <quicksilver> non-normalised relations are the expected result of producing useful reports for human beings.
04:32:08 <Sizu1> ok, i agree
04:32:40 <Sizu1> we must have renaming
04:36:01 <Sizu1> quicksilver: thanks for the explanation
04:37:43 <quicksilver> not at all. It's a pet subject of mine.
04:37:52 <quicksilver> One day I will write a true relational database in haskell
04:38:01 <quicksilver> with replication and true transaction serialisation
04:38:04 <quicksilver> and change the world!
04:38:07 <quicksilver> not today, though.
04:38:24 <Sizu1> quicksilver: call me, i want to be a part of it!
04:54:10 <ArthurClemens_> quicksilver: do you know couchdb?
04:54:16 <ArthurClemens_> it is written in Erlang
04:57:43 <Sizu1> hmm, another new db paradigm
04:58:55 <Sizu1> i'd pick eXist over CouchDB though
04:59:13 <Sizu1> you get semistructured benefit of couchdb + XQuery
05:08:28 <dmwit> XML may be verbose, but XPath and XQuery sure are nice.
05:08:44 <Sizu1> quicksilver: what if to implement a function that polymorphously returns the largest "cycled" tuple to be used instead of "first" in that hpaste. wouldn't that take care of duplicate types? except it required overlapping of types...
05:09:07 <dmwit> Of course, they hardly stand up to what you can do with record types + Read, but hey...
05:13:03 <Sizu1> but yeh, we still need names for attributes to make sense of same types
05:14:31 <luqui> instances like:  instance Num a => Foo a   are illegal because the head is no larger than the context
05:14:39 <Sizu1> renaming can be done thought a cast
05:15:04 <luqui> but couldn't it be legal even if the head was exactly the same size
05:15:16 <luqui> finitely many terms of a given size, so you can memo them when you're searching
05:15:47 <Sizu1> luqui: -XFlexibleContexts?
05:16:21 <mauke> instance Foo a => Num a  -- loop
05:17:06 <luqui> mauke, but that's just the algoritm being silly
05:17:07 <Sizu1> bot = bot -- loop too. error of the programmer, not compiler
05:17:17 <mauke> yeah
05:17:28 <luqui> no, mauke's is a _compile time_ loop, which is rather different
05:17:33 <luqui> pretty hard to debug that
05:17:46 <luqui> but that needn't be a loop afaict
05:17:58 <luqui> the compiler can see that it already visited Foo a
05:18:12 <luqui> assuming a dijkstra-like solving algorithm
05:32:50 <Taejo> @let loop = loop
05:32:51 <lambdabot> <local>:17:7:     Ambiguous occurrence `loop'     It could refer to either `l...
05:33:05 <Taejo> @let loopzorz = loopzorz
05:33:08 <lambdabot> Defined.
05:33:13 <Taejo> > loopzorz
05:33:13 <lambdabot>  Exception: <<loop>>
05:33:14 <mux> <<loop>> :)
05:33:39 <Taejo> how is <<loop>> detected?
05:34:14 <luqui> Haskell has a halting problem solver
05:34:18 <luqui> ;-)
05:34:28 <Taejo> @let might_loop cond = if cond then might_loop cond else cond
05:34:30 <lambdabot> Defined.
05:34:40 <Taejo> > might_loop True
05:34:40 <lambdabot>  Exception: <<loop>>
05:34:48 <mux> Taejo: lookup GHC blackholes somewhere, this is the mechanism that allows detecting such simple loops
05:34:54 <luqui> (if it tires to evaluate a thunk as part of that same thunk, it dies with loop)
05:35:07 <luqui> as a part of /evaluating/ that same thunk...
05:35:19 <Taejo> @google ghc blackholes
05:35:31 <lambdabot> Plugin `search' failed with: getHostByName: does not exist (no such host entry)
05:35:42 <DRMacIver> People get too hung up on parser generators.
05:36:05 * araujo has been thinking to write a GO front-end on gtk2hs for gnu-go
05:36:28 <DRMacIver> I was having intense irritations with ANTLR and rewrote it with a simple handwritten parser. My coworker is now irritated with me for this despite the fact that the handwritten parser is *shorter* than the antlr file was. :)
05:37:32 <quicksilver> DRMacIver: ++ on that
05:37:44 <quicksilver> DRMacIver: parser generators are premature optimisation
05:38:03 <quicksilver> DRMacIver: unless you want to parse huge documents, naive recursive descent backtracking parsers are easy to write, clear to read, and work fine.
05:38:22 <quicksilver> of course, if you want to parse several multi-megabyte XML files
05:38:28 <quicksilver> then, sure, use your parser-generator :)
05:38:53 <joelr1> good day
05:57:22 <mdmkolbe|work> Is this a typo in the GHC manual? http://hpaste.org/4309
05:59:44 <quicksilver> hmm. Are javascript namespaces/scopes a slightly obscure form of dynamic scoping?
05:59:48 <quicksilver> seems like they are.
06:01:08 <Saizan> mdmkolbe|work: seems like a typo, the same you've done forgetting (p1,p2,...) etc on the LHS of zipN :)
06:01:34 <mdmkolbe|work> Saizan: heh, yes
06:09:30 <Laney> Don't suppose anyone here works on packaging for Debian/Ubuntu and/or knows if a 6.8 package is in the works?
06:10:07 <dylan> that'd be Igloo, I think.
06:13:37 <Laney> Hmm. Igloo, is there any news? I might just install it manually but that always gives me The Fear of breaking stuff... :(.
06:18:41 <Igloo> I'll probably upload to Debian shortly after 6.8.2 is released
06:21:11 <quicksilver> Laney: there are a couple of bugs in 6.8.1 and quite a few problems getting libraries to compile under it
06:21:24 <quicksilver> Laney: depending what your needs are you might want to wait for 6.8.2
06:23:31 <Laney> quicksilver: Right, well it's not urgent I guess. It's just that I'm working on a project using HAppS which now requires 6.8.1, but I can stick with HAppS 0.8.8 for now. Thanks
06:42:30 <joelr1> am i correct that the latest ghc head (to update with darcs patches) is 2007-08-29?
06:44:28 <quicksilver> doesn't sound very likely
06:44:42 <quicksilver> changes are committed to ghc every day, more or less
06:45:00 <Saizan> i think he's referring to the tarball on darcs.haskell.org
06:45:24 <Saizan> that you need to download because a bare darcs get on the repo will take ages
06:45:57 <Saizan> and yes, it seems that's the last
06:47:59 <quicksilver> oh, I understand
06:48:02 <quicksilver> didn't know about that.
06:48:11 <quicksilver> JaffaCake will know better :)
06:49:27 <mar77a> morning my dear haskellians from haskell
06:50:22 <mar77a> i was wondering if it's possible and how hard it is to program GUI apps in haskell (probably win32)
06:51:44 <Saizan> it's done via bindings to existing toolkits at the moment, one of the best maintained is gtk2hs
06:51:49 <bmeph_> mar77a: It depends on what you mean by "GUI" ;)
06:59:44 <quicksilver> mar77a: gtk2hs and wxHaskell enable you to program GUIs in a rather imperative style
06:59:55 <quicksilver> but still take advantage of haskell's higher-order expressivity
07:00:01 <quicksilver> so it's not as verbose as C++ or Java
07:00:40 <dcoutts_> and it's type safe and memory safe
07:00:46 <quicksilver> mar77a: there are experimental packagse which wrap GUIs into a more sophisticated functional framework
07:00:52 <quicksilver> right, what dcoutts_ said too, that's important.
07:01:15 <quicksilver> btu there is no clear consensus about what makes a good functional GUI api
07:01:44 <mar77a> mmm
07:05:55 <pejo> quicksilver, what are those experimental packages?
07:06:18 <joelr1> pejo: hola
07:07:03 <scodil> is there any way to profile code, even in a real handwavey sense, without -prof? If I compile with profiling it runs more than twice as slow than without
07:07:17 <joelr1> speed of downloading from haskell.org is 11kbps
07:08:17 <quicksilver> pejo: grapefruit springs to mind as a relatively recent one
07:08:24 <quicksilver> pejo: there is a wiki page about it
07:08:42 <quicksilver> pejo: http://www.haskell.org/haskellwiki/Libraries_and_tools/GUI_libraries
07:08:44 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/gn7tc
07:08:47 <quicksilver> pejo: first section 'high-level'
07:14:24 <pejo> joelr1, was that a hi, or an answer to my question?
07:14:48 <joelr1> pejo: that was a hi. what kind of question can you answer with "hola"? :D
07:15:48 <pejo> joelr1, hi! It could have been the name of a gui toolkit though. :-)
07:15:56 <joelr1> pejo: haha
07:16:14 <quicksilver> scodil: nothing immediate and easy, no
07:16:19 <wolverian> heh, the grapefruit "simple" example is quite, uh, interesting
07:16:33 <quicksilver> scodil: you should find that -prof does correctly identify your hotspots, even if it also slows everything down
07:18:55 <scodil> quicksilver: yeah i don't know. i'm skeptical. it seems to defeat a lot of inlining
07:19:19 <scodil> it doesn't slow everything down by a constant factor
07:19:21 <quicksilver> scodil: hmm. You could be right. I'm not sure.
07:19:28 <quicksilver> scodil: what about if you don't use -auto-all
07:19:34 <quicksilver> scodil: but rather place your SCCs carefully
07:19:35 <scodil> yeah i guess i'll try that
07:19:40 <scodil> oh i see
07:19:43 <quicksilver> I think if you don't put an SCC it won't break inlining
07:22:11 <Sizu1> hola = Higher Order Liquid Animation gui library toolkit framework thing emacs
07:31:03 <Sizu1> any indication on the leader of them? wxFuit maybe?
07:33:49 <quicksilver> Sizu1: my impression is that grapefruit is the most "recently active"
07:33:55 <quicksilver> but that impression may be incorrect
07:34:16 <quicksilver> significantly, I'm not aware of much activity in terms of writing real programs using this stuff
07:34:30 <quicksilver> and I don't think people have much confidence about what the right design for them is
07:37:33 <Saizan> when a licence says "you can't use the names Foo and Bar to endorse or promote derived products without prior written permissions" means that i can't say: "My library uses Blah to make x easier"?
07:38:46 <Sizu1> Saizan: just send an email to the makers and they will say Yes as you are effectively promoting theirs too
07:39:15 <quicksilver> Saizan: you can't say "my product is excellent because it uses Foo and Bar technology"
07:39:29 <quicksilver> because that reads like an endorsement by them, of your product
07:39:40 <quicksilver> they can't prevent you from stating the fact that you use it
07:39:46 <Sizu1> but the former is promotion
07:39:55 <quicksilver> (although, they may decide to write you a scary letter if they're nasty people)
07:40:39 <quicksilver> the line between 'endorsement/promotion' and 'simple mention of a fact' is not very clear to me, but hey, I'm not a lawyer :)
07:40:52 <Lemmih> Saizan: Blah /= Foo or Bar.
07:41:17 <Saizan> Lemmih: s/Blah/Foo/
07:41:19 <bmeph_> quicksilver: "I'm not a lawyer, but I play one on the Internet." ;)
07:41:41 <quicksilver> bmeph_: I used to say "I'm not a lawyer, but I play one on debian-legal"
07:41:45 <Sizu1> you can always have a small print to clear everything up (mention of names does not constitute endorsment or promotion, etc blablabla)
07:41:57 <quicksilver> bmeph_: however, I no longer say that because I became bored of the flamewars on debian-legal
07:43:04 <Sizu1> and by reading this you are agreeing to everything and are binded for life
07:43:27 <Saizan> Sizu1: it's a report for HCAR such disclaimers would seem rather weird
07:44:23 <Sizu1> Saizan: always best to inform the makers what you would like to do
07:44:32 <Sizu1> it's nice
07:51:15 <Pastorn> @query lambdabot
07:51:15 <lambdabot> Unknown command, try @list
08:28:07 <Sizu1> quicksilver: why cannot i project A B A into A B C where C is a synonym on A? that's renaming, is it not?
08:32:04 <quicksilver> Sizu1: yes, you can. But you need to generate new types (the new type C) at "runtime"
08:32:13 <quicksilver> Sizu1: I can't see an easy way to do that, maybe I miss something.
08:32:40 <quicksilver> I don't think you can write code at the type-level which checks if A and A are equal and if so produces a new type C isomorphic to A
08:32:57 <quicksilver> ...and still keep a useful result type for the 'join' function.
08:34:06 <Sizu1> quicksilver: if i have all relational statements at compile time, then it should be ok
08:35:00 <quicksilver> Sizu1: what type will join have then?
08:35:24 <Sizu1> A B C where C is a type synonym of A
08:35:54 <Sizu1> (Name1,Age,Name2)
08:36:08 <Sizu1> type Name1 = String
08:37:46 <Sizu1> ofcourse you'd have to cast it at the statement level
08:38:28 <Sizu1> but you'd do it in your relational statement anyway "select String as Name1 ..."
08:39:01 <Sizu1> you can do that with haskell because tuples are ordered
08:40:52 <Sizu1> what am i missing?
08:43:00 <quicksilver> Sizu1: type synonym isn't good enough
08:43:13 <quicksilver> Sizu1: a type synonym is not a fresh type
08:43:27 <quicksilver> but you're also not answering my question :)
08:43:33 <quicksilver> join is supposed to work on any two relations....
08:43:41 <quicksilver> so it must have a type which declares that
08:45:16 <Sizu1> wont a polymorphic join with overlapping types that requires you to specify the type if overlapping occurs solve that?
08:46:04 <quicksilver> it might do, perhaps
08:46:10 <Sizu1> i'm still on the compile-time page
08:46:11 <quicksilver> show me what polymorphism you expect to use :)
08:46:14 <quicksilver> ;)
08:48:05 <Saizan> the motivating case used for hlist in the papers are typeful sql queries
08:49:44 <Sizu1> a::[(String,Int)]; joinOn a a (on::Int) ::[(String,Int,String2)]
08:49:45 <quicksilver> Saizan: but, I don't think they generate fresh types in the way Sizur wants
08:50:09 <quicksilver> Sizu1: right. Show me the full, general type of joinOn.
08:50:16 <Sizu1> heh
08:50:22 <quicksilver> that's the part I don't think you can do.
08:50:26 <quicksilver> although I could be wrong.
08:50:50 <quicksilver> Saizan: Sizur is trying to ensure that there is never more than one column with the same type, requiring 'fresh type' renaming when you join.
08:51:44 <quicksilver> (Rel a, Rel b, RelContains a key, RelContains b key, Join a b key c) => joinOn :: a -> b -> key -> c
08:51:47 <quicksilver> perhaps
08:51:56 <quicksilver> but I'm not sure you can define the 'Join' class in a way which makes that work.
08:52:05 <Saizan> they can ensure there's only one column with the same type, but no renaming involved
08:53:10 <quicksilver> at least, I don't see a way to write out all the instances of Join polymorphically.
08:53:35 <Saizan> but the labelled records have a namespace, so you could differentiate on that?
08:54:02 <quicksilver> the problem is you want (for example)
08:54:13 <quicksilver> Join Int Int () Int
08:54:14 <quicksilver> and
08:54:24 <quicksilver> Join Int Int Int (Int,Fresh Int)
08:54:46 <quicksilver> and our typeclass system doesn't make it easy to capture type equality.
08:54:57 <quicksilver> although, I know that HList does do that, in some senses.
08:55:04 <quicksilver> I'm not sure if it's sufficient for this example or not.
08:55:28 <quicksilver> hmm
08:55:34 <quicksilver> those two examples where backwards!
08:55:40 <Saizan> ah :)
08:55:41 <quicksilver> Join Int Int () (Int,Fresh Int)
08:55:46 <quicksilver> Join Int Int Int Int
08:55:55 <Saizan> now they make sense
08:59:09 <Saizan> if you don't mind tagging the types with a table reference i think it can be done, but the only way is to implement it :)
08:59:53 <quicksilver> Saizan: table in the SQL sense of the word?
09:01:36 <Saizan> yes, circa
09:02:48 <Saizan> Join (Table1 Int) (Table2 Int) () (Table1 Int, Table2 Int), Join (Table1 Int) (Table2 Int) Int (Table1 Int)
09:02:53 <quicksilver> Saizan: *nod*
09:02:57 <Saizan> using hlist instead of tuples
09:03:03 <quicksilver> Saizan: but what if, in fact, I want to do a self-join?
09:03:15 <quicksilver> Saizan: (which was my original challenge to sizur)
09:03:29 <quicksilver> Saizan: then you need to somehow 'notice' self-joins and generate fresh types
09:03:47 <quicksilver> Saizan: which comes back to my point about detecting equality in the type class system.
09:04:19 <Saizan> well, hlist is based on TypeEq and TypeCast
09:06:18 <quicksilver> Saizan: right, but can you 'check' for TypeEq and if you find it automatically 'freshen' types?
09:06:54 <quicksilver> Saizan: and won't it be a pain for clients of the library which don't know how many times they have to 'unFresh' to get at the real value?
09:07:24 <quicksilver> (I myself certainly don't know the answers to these questions, they go deeper than I have looked into HList)
09:08:14 <Sizu1> need to run unfortunately... good discussion going on. ttyl guys
09:09:54 <Saizan> well i don't know either, but with a standard way to tag types you may have only to add a specific instance to Join for self-joins and a generic Untag
09:17:19 <Lemmih> Sonarman: Ron Paul is secretly a Haskeller, eh?
09:18:22 <swiert> the Texas Congressman?
09:33:46 <byorgey> ndm++   yay for Hoogle updates!
09:34:33 <quicksilver> hear hear! ndm++
10:11:09 <sioraiocht> @src zipwith7
10:11:09 <lambdabot> Source not found. My pet ferret can type better than you!
10:11:18 <sioraiocht> @src zipWith7
10:11:18 <lambdabot> Source not found. I feel much better now.
10:11:20 <sioraiocht> boo
10:17:48 <conal> dcoutts_: i ready to talk about Applicative & Monad (etc) w.r.t dependencies/make.
10:17:57 <dcoutts_> hia conal
10:18:01 <MyCatVerbs> @src zipWith3
10:18:02 <lambdabot> Source not found. I am sorry.
10:18:22 <conal> dcoutts_: howdy
10:19:33 <dcoutts_> conal: so with make, the primary input is the environment, we drop this generic 'keep things up to date' program into an environment and then ask it to go and keep things up to date
10:19:56 <dcoutts_> so the first task is to find out what there is and what it should do to keep things up to date
10:20:03 <conal> dcoutts_: "the environment"?
10:20:10 <dcoutts_> and then we go an change the environment by editing files etc
10:20:22 <conal> dcoutts_: do you not want to take a functional approach?
10:20:48 <dcoutts_> conal: well we do have to interface to the setup where users edit files in their favourite text editor
10:21:08 <conal> dcoutts_: yes, which we can wrap functionally.
10:21:14 <conal> dcoutts_: as a time-varying value
10:21:21 <conal> rather than a file
10:21:27 <dcoutts_> ok
10:22:15 <dcoutts_> so my point is, finding out what time varying values we have (files and derived stuff) is itself time varying as people create/delete/move files
10:22:20 <dcoutts_> it's not just the file content
10:22:27 <MeineKatzeRegelt> Hee, German people.
10:22:47 <conal> dcoutts_: in a sense, that's editing the program.
10:22:53 <dcoutts_> and editing content of some files also affects the dependency graph we get, like editing the .cabal file
10:23:09 <dcoutts_> conal: ok, so the whole build tree is one compound time varying value
10:23:30 <conal> dcoutts_: build tree, compilers, test data, results, ...
10:23:30 <dcoutts_> or at least, all the interesting source files
10:23:51 <conal> .hs, .o, .out ..
10:24:24 <dcoutts_> conal: so as far as I see, it's not all applicative, though it's got many bits which can be expressed in an applicative way
10:24:26 <conal> dcoutts_: it's a pretty radical direction.  that's where i'm taking it.  depends how far you want to go.
10:24:32 <dcoutts_> some bits look monadic
10:24:40 <dcoutts_> not monadic in an imperative sense
10:24:43 <conal> dcoutts_: perhaps.  which bits?
10:24:52 <conal> i understand (not imperative).
10:24:59 <dcoutts_> but in that the structure of one time varying value seems to depend on another
10:25:30 <dcoutts_> so if I write an applicative expression I seem to be describing a static dependence structure
10:25:31 <conal> dcoutts_: that's the interesting bit.  i don't know dynamic dependencies are necessary.  maybe.
10:25:55 <conal> dcoutts_: that's my understanding too, of the essential difference between Applicative and Monad.
10:26:19 <dcoutts_> conal: maybe they are not necessary in the way I've been conceiving them, but initially it looks that way
10:26:38 <dcoutts_> conal: the canonical example is .hs file dependencies
10:27:00 <conal> dcoutts_: when an import is added?
10:27:04 <dcoutts_> I can write an applicative expression which reflects the import structure of a collection of .hs modules
10:27:11 <dcoutts_> but yes, when I change the imports...
10:27:55 <dcoutts_> so it looks to me like we have the expression that reflects the imports being calculated using the 'current' value of some other time varying value
10:28:01 <dcoutts_> and that looks rather like a monad
10:28:25 <dcoutts_> ... >>= \imports -> ...
10:28:32 <conal> dcoutts_: yeah.  that's a nice example.  in a sense, that's changing the time-varying function itself.
10:28:38 <dcoutts_> right
10:28:44 <dcoutts_> @type >>=
10:28:46 <lambdabot> parse error on input `>>='
10:28:49 <dcoutts_> @type (>>=)
10:28:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:29:25 <andyjgill> How do we write a true unicode string to a file in Haskell?
10:29:47 <dcoutts_> andyjgill: writeFile file (toUTF8 string)
10:30:06 <andyjgill> toUTF8 does the unpacking?
10:30:25 <dcoutts_> andyjgill: using whatever toUTF8 or other encoding function you have to hand
10:30:45 <dcoutts_> it'd be String -> String where the result is pretending to be [Word8]
10:31:08 <Saizan> if you specifically need uft8 there's utf8-string on hackage
10:31:28 <andyjgill> I want 16 bit unicode
10:31:40 <dcoutts_> andyjgill: there's also iconv on hackage if you need other encodings
10:32:01 <dcoutts_> andyjgill: the iconv provides a lazy bytestring -> lazy bytestring api
10:32:11 <conal> dcoutts_: makes sense to me so far.  let's play with it.  I've been thinking of module import as Applicative-style application (liftAn) of a sources-to-source function to some time-varying sources.  i'm not seeing at the moment where to go next, with changing the imports.
10:32:25 <conal> dcoutts_: other than that >>= may help
10:32:54 <andyjgill> dcoutts_: you are the author, I see!
10:32:59 <conal> (correction: "... of a *time-varying* sources-to-source function ...)
10:32:59 <dcoutts_> @arr!
10:33:00 <lambdabot> Avast!
10:33:32 <dcoutts_> conal: >>= does reflect the fact that we really do not know the dependency structure 'til we've got the current value of the first bit
10:33:44 <andyjgill> So, what are Haskell strings? UTF-16?
10:33:56 <andyjgill> Latin1?
10:33:59 <dcoutts_> andyjgill: [Char] list of unicode code points
10:34:02 <monochrom> probably as 32-bit code points
10:34:05 <conal> dcoutts_: i don't even know what type to use for the importing module, if the number & types of imports are not fixed.
10:34:35 <dcoutts_> conal: where with <*> we can just look at the whole expression and extract the dep structure statically
10:34:53 <conal> dcoutts_: right.
10:35:26 <conal> dcoutts_: take an example: a module that imports two modules might have type Source (Module -> Module -> Module).
10:35:42 <conal> dcoutts_: then apply via  A <*> B <*> C
10:35:51 <conal> dcoutts_: where B & C are the imported modules
10:35:56 <dcoutts_> conal: can we not fold over a list of imports?
10:36:07 <conal> dcoutts_: hm.
10:36:31 <dcoutts_> conal: a [TV a], not a TV [a]
10:36:35 <conal> dcoutts_: we'd lose some static typing.
10:36:43 <conal> oh.
10:37:09 <conal> dcoutts_:  btw, i'm thinking Source where you're typing TV
10:37:16 <dcoutts_> conal: ok :-)
10:37:23 <conal> dcoutts_: maybe TV would have some cool application.  i hadn't thought of that.
10:37:41 <conal> dcoutts_: [Source a] is still static in the number of imports
10:37:42 <dcoutts_> conal: TV is tangible not time-varying, I forgot :-)
10:37:51 <dcoutts_> conal: yes.
10:38:02 <conal> dcoutts_: yes.  oops!  hadn't thought of that confusion
10:38:03 <dcoutts_> conal: that's important, and it's fine.
10:38:12 <conal> dcoutts_: what's fine?
10:38:25 <dcoutts_> conal: [S a] being static in the number of imports
10:38:41 <hpaste>  Paczesiowa pasted "unboxed fib" at http://hpaste.org/4311
10:38:43 <paczesiowa> can someone help me compile that (do I need some cli switch?)
10:38:46 <conal> dcoutts_: hm?? aren't you going for dynamic?  and hence monad?
10:38:48 <dcoutts_> conal: if we can then use >>= to connect them,
10:39:31 <luqui> what's the best way to "join" two Chan's; i.e. joinChan :: Chan a -> Chan b -> Chan (Either a b)
10:39:51 <luqui> block until something comes in on one or the other...
10:40:04 <dcoutts_> conal: so we want a [S Import] -> S b, then we connect it with >>= to a S [Import]
10:40:06 <conal> dcoutts_: i'm not seeing how
10:40:48 <conal> dcoutts_: oh.
10:40:53 <dcoutts_> then we don't know the dep structure of the overall thing 'til we know the current [Import]
10:40:57 <Saizan> luqui: it's very easy with STM Chans, and requires threads with MVar ones i think
10:41:11 <dcoutts_> and whenever that first value changes we recalculate the structure of the second
10:41:15 <luqui> Saizan, thanks; I was looking for an excuse to use STM anyway ;-)
10:41:43 <conal> dcoutts_: probably connect to a S [S Import]
10:41:44 <monochrom> paczesiowa: probably -fglasgow-exts ?
10:41:55 <dcoutts_> conal: erm, yes.
10:42:10 <dcoutts_> conal: but [Import] -> [S Import] is an easy map
10:42:13 <paczesiowa> monochrom: still no type constructor or class `Int#' and Not in scope: `+#'
10:42:18 <dcoutts_> conal: perhaps >>= isn't right, becuase I don't think it'd follow the monad laws, but the type is right I think.
10:42:19 <luqui> Saizan, okay, I don't see it.
10:42:30 <luqui> Saizan, (by which I mean an easy way to do it)
10:43:47 <Saizan> luqui: well you can't exactly build a Chan (Either a b), but waiting on both at the same time is easy, with orElse
10:44:23 <conal> dcoutts_: do you have a law in mind that might not hold?
10:44:44 * conal still noodles >>= for source code
10:45:03 <dcoutts_> conal: well, monads are not allowed to do too much introspection and this looks like it wants to do as much as possible
10:45:08 <luqui> Saizan, ohhh, TChan doesn't block if there's no value, it retries?
10:45:37 <Saizan> luqui: retry is how you block in STM
10:45:38 <luqui> (which amounts to a very clever block I presume)
10:45:40 <dcoutts_> conal: so it's my guess that the monad laws would not hold, but I don't know for sure.
10:45:53 <luqui> Saizan, okay.  still getting the hang of this stm stuff
10:46:20 <conal> dcoutts_: if we focus on getting a simple denotational semantics for what we're doing, then it'll be clear whether it's a monad or not.  and if not, it'll be something else nice.
10:46:38 <dcoutts_> conal: aye
10:46:48 <Saizan> luqui: you can look at the source of TChan for inspiration :)
10:47:29 <conal> dcoutts_: i like your idea of tracking dynamic dependencies via Monad (or whatever it turns out to be).  there may be a simpler way, with just applicative.  want to explore that?
10:48:01 <dcoutts_> conal: sure
10:48:29 <dcoutts_> conal: btw, we can move to #haskell-overflow if we think we're hogging this channel
10:48:58 <conal> dcoutts_: let's
10:49:04 <dcoutts_> and other interested people can follow us there
10:49:13 <conal> right
10:55:43 <scodil> in HOpenGL, does `preservingMatrix a` preserve the matrix that's active when action a is started, or when its finished?
10:55:55 <scodil> er, which does it pop
10:58:19 <monochrom> paczesiowa: import GHC.Prim.  Also need to change < and - to <# and -#. Also literals like 1, 2, 41 need change, and I don't know how.
10:58:37 <scodil> i forget, in formal language theory, is a language with multiple stacks more powerful that one with a singlel stack? single stack is a PDA but multiple stacks == a turing machine, right? or did i remember that incorrectly
10:59:20 <byorgey> scodil: that's right.
10:59:58 <monochrom> paczesiowa: Also cannot use polymorphic functions like $, print.
11:00:23 <monochrom> Polymorphism does not include # types.
11:01:22 <paczesiowa> monochrom: thanks!
11:01:39 <paczesiowa> it should be mentioned in ghc docs
11:03:10 <geezusfreeek> scodil: what does PDA stand for in that context?
11:04:48 <scodil> personal digintal... no wait  it's pushdown automaton
11:05:28 <byorgey> public display automaton?
11:05:49 <scodil> i'm a fan of pushdown affection
11:05:55 <byorgey> hehe
11:06:26 <byorgey> scodil: with two stacks, you can easily simulate a tape -- moving the read/write head corresponds to popping from one stack and pushing onto the other
11:07:11 <geezusfreeek> thanks
11:07:27 <lament> you do that for a while, and your brain is fucked.
11:07:29 <scodil> i was going to make a point about how the HOpenGL preservingMatrix function loses functionality with respect to good ol glPush and glPop, because it forces all the opengl stacks into the single haskell lexical call stack
11:07:41 <scodil> but i guess if you can change stack modes in the middle, then its equivalent
11:07:59 <scodil> all it does is pair push and pops which you have to do anyways to avoid overflow
11:08:03 <geezusfreeek> wait, isn't brainfuck turing complete?
11:08:12 <oerjan> YES!
11:08:19 <geezusfreeek> it's only unidirectional
11:08:44 <geezusfreeek> that is, it only models a tape that is infinite in one direction
11:08:54 <monochrom> paczesiowa: To get useful things done, also import GHC.Exts. Now suddenly you have "data Int = I# Int#" accessible. So you can now bridge between Int (which you can write literals and print) and Int#. I'll paste.
11:09:34 <hpaste>  monochrom annotated "unboxed fib" with "a complete example" at http://hpaste.org/4311#a1
11:09:37 <oerjan> turing machines don't need bidirectional tapes either
11:09:39 <scodil> you can model an infinite 2D tape using an infinite 1D tape, with some kind of space filing curve or something. a spiral. isn't there some Cantor argument based on that?
11:10:23 <oerjan> scodil: the bijection between rationals and naturals
11:10:31 <geezusfreeek> it seems to me that that is very very close to a single stack, with the one restriction that a stack loses data as the head moves left
11:11:02 <scodil> can it read and write to memory?
11:11:26 <geezusfreeek> what, brainfuck? no
11:11:54 <oerjan> only to the tape
11:12:17 <scodil> well you can turn a one-directional tape into a two-directional tape by just considering evens and odds
11:12:18 <geezusfreeek> pointer increment/decrement, value increment/decrement, loop until zero, and input/output
11:12:48 <geezusfreeek> ah, i guess that would make sense
11:14:09 <gio123> is here somebody mathematicca programer?
11:14:29 <oerjan> gio123: try in #math, they even have a mathematica bot
11:15:06 <oerjan> which is somewhat based on our lambdabot
11:15:15 <oerjan> (although not the mathematica part)
11:15:24 <gio123> there people only solve math homeworks
11:15:25 <gio123> :)
11:15:43 <proqesi> somewhat?
11:15:56 <oerjan> i mean it's lambdabot with extra plugins
11:16:25 <oerjan> afaik
11:17:03 <paczesiowa> monochrom: thanks! do you know why this isn't any faster than boxed version? ghc is smart enough to unbox it itself?
11:20:15 <monochrom> Yes. I tried the same example several weeks ago with Int and -O2. I briefly looked at the core. I was impressed. It seemed to unbox everyone for this example.
11:21:39 <paczesiowa> it's great that ghc is that smart, on the other hand I thought that with unboxed Ints we could beat java:P
11:22:08 <monochrom> I pitted it against a C version. I detected no difference in speed.
11:22:08 <dons> we don't?
11:22:13 <Taejo> :t uncurry (.) . (map . second . drop . length &&& (filter . (flip $ flip isPrefixOf . snd)))
11:22:14 <lambdabot> forall a a1. (Eq a) => [a] -> [(a1, [a])] -> [(a1, [a])]
11:24:14 <sclv_> I've only ever found corner cases where the compiler isn't smarter at unboxing than me.
11:25:51 <sclv_> Java pure numeric computations are also pretty close to C, recall -- its numerics are unboxed by default, and especially with a JIT JVM it'll be plenty zippy. Java mainly slows down when objects are introduced.
11:26:19 <paczesiowa> dons: with ghc-6.8.1 -O2 it's almost two times slower than java
11:26:50 <dons> paczesiowa: i think that's likely due to constructor specialisation failing
11:27:01 <dons> or, are you using the explicit unboxed version?
11:27:08 <dons> (i can check with 6.8.2 if you like)
11:27:36 <hpaste>  Paczesiowa annotated "unboxed fib" with "(no title)" at http://hpaste.org/4311#a2
11:27:47 <dons> why unboxed, btw?
11:28:10 <dons> ghc will unbox it fine
11:28:34 <dons> (check output with -ddump-simpl)
11:29:08 <paczesiowa> now I know that:P
11:30:45 <luqui> where can I find the laws for Arrows?
11:31:24 <Sizur> ask a marksman :P (sorry couldn't resist)
11:31:25 <hpaste>  Paczesiowa annotated "unboxed fib" with "(no title)" at http://hpaste.org/4311#a3
11:31:39 <dons> $ time ./A-boxed
11:31:39 <dons> 267914296
11:31:39 <dons> ./A-boxed  3.87s user 0.02s system 99% cpu 3.904 total
11:31:39 <dons> $ time ./A-unboxed-old
11:31:39 <dons> 267914296
11:31:42 <dons> ./A-unboxed-old  4.47s user 0.01s system 100% cpu 4.473 total
11:31:44 <dons> $ time ./A-unboxed
11:31:47 <dons> 267914296
11:31:49 <dons> ./A-unboxed  4.43s user 0.02s system 99% cpu 4.484 total
11:31:52 <dons> paczesiowa: the fastest one is the non-unboxed fib, compiled with ghc 6.8.2 (snapshot)
11:32:09 <luqui> Sizur, :-p
11:32:16 <dons> $ time ./A-boxed-old
11:32:16 <dons> 267914296
11:32:17 <dons> ./A-boxed-old  3.60s user 0.01s system 99% cpu 3.623 total
11:32:24 <dons> oh, i'm wrong. ghc 6.8.1 seems best.
11:32:48 <paczesiowa> java is still faster:/
11:32:58 <hpaste>  dons annotated "unboxed fib" with "boxed" at http://hpaste.org/4311#a4
11:33:09 <dons> paczesiowa: it will be sometimes.
11:33:14 <dons> they've thrown billions at it :)
11:33:55 <paczesiowa> so ghc could be faster with more code work?
11:34:08 <dons> you can always improve compilers
11:34:13 <Sizur> they might have an optimization for this case of recursion. why not try a better fib implementation?
11:34:33 <dons> right. they might be doing the tail call optimisatoin on the second call
11:34:46 <dons> paczesiowa: i'd check again my boxed versoin (with its flags)
11:34:56 <dons> > 3.623 / 4.473
11:34:58 <lambdabot>  0.8099709367315002
11:35:09 <dons> so there was a 20% difference versus your unboxed code.
11:35:30 <sclv_> The problem is that tco is optional on jvms -- so you have no guarantee it will occur in any given circumstance.
11:35:35 <paczesiowa> how can they tail call that? fib has to add those results in the end
11:35:54 <byorgey> luqui: http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf
11:36:22 <dons> paczesiowa: http://programming.reddit.com/info/61tc0/comments/c02kcpp
11:36:22 <byorgey> hm, strange that the arrow laws aren't specified in the haddock documentation for Control.Arrow.
11:36:24 <dons> (gcc does)
11:36:34 <sclv_> the jvm is also pretty good with register allocation too, for small programs at least.
11:36:44 <luqui> byorgey, thanks.... indeed it is strange
11:36:57 <dons> yeah, so i'm on amd64. on x86 yu might suffer
11:37:01 * byorgey just might submit a patch...
11:37:11 <paczesiowa> btw dons why do you use gcc flags for haskell code without -fvia-C ?
11:37:30 <dons> -O2 turns on -fvia-C last I checked. i might be wrong..
11:37:34 <Sizur> sun jvm has a hack of a lot oprimizations going on even dynamically
11:38:05 <dons> ah no. my fault :)
11:38:14 <dons> so that's the native backend (and on amd64, its rather good)
11:39:20 <dons> similar result via C, ./A  3.65s user 0.00s system 99% cpu 3.657 total
11:39:55 <paczesiowa> gcc is so smart to turn naive fib into linear tail-called version?
11:40:06 <monochrom> Compilers are on their ways to replace algorithms and self-awareness.
11:40:12 <oerjan> byorgey: hey, i was going to say the same about Applicative, but they're there!
11:40:22 <jonafan> i can honestly say i have no comprehension of that at all
11:40:25 <jonafan> way to go gcc
11:40:31 <oerjan> don't recall seeing them there before
11:40:44 <byorgey> oerjan: they've been there for a while in Applicative, I think.
11:40:48 <monochrom> Still not linear.
11:44:08 <oerjan> byorgey: hm indeed, don't know how i missed it
11:51:34 <mrd> well, i figured out part of the reason why i wasn't getting any parallelism out of NDP
11:51:43 <mrd> but it's still not quite there
11:54:00 <quicksilver> dons: I believe O2 doesn't necessary turn on via-C in 6.8.x
11:54:17 <quicksilver> dons: that's why we're seeing more native code gen bugs, because it's being exercised more
11:55:11 <dons> right, seems so.
12:06:28 <mrd> the other part of the puzzle is that i'm an idiot
12:06:52 <mauke> oh man, I hate those kinds of puzzle
12:07:12 <mrd> had a stray forkIO which was totally pointless and probably breaking stuff, from some past failed experiment
12:07:48 <mrd> now 172% CPU usage :-)
12:13:05 <mrd> ooh, 226%.  stupid wacky processors throwing things off.
12:16:50 <MyCatVerbs> Is isEmptyChan in Control.Concurrent.Chan always nonblocking? The documentation doesn't explicitly say, and I'm writing a program here that's guaranteed to go kaboom if it ever blocks. >>
12:17:10 <MyCatVerbs> Er, that question should've had a "please" in there somewhere. Please? :)
12:17:38 <dons> isEmptyChan (Chan read write) = do
12:17:38 <dons>    withMVar read $ \r -> do
12:17:38 <dons>      w <- readMVar write
12:17:38 <dons>      let eq = r == w
12:17:40 <dons>      eq `seq` return eq
12:18:14 <dons> the withMVar will block if something else is taking the channel
12:19:04 <MyCatVerbs> dons: I have the source code in hand, yes, but I don't understand it. ;)
12:19:35 <MyCatVerbs> dons: hrmn. I can guarantee that no other thread will ever read from the same channel... is that enough?
12:20:26 <dons> that should be ok.
12:20:33 <MyCatVerbs> Kewl, thank you very much.
12:45:40 <dons> @tell ndm tagsoup's haddocks fail, http://hackage.haskell.org/packages/archive/tagsoup/0.1/log
12:45:40 <lambdabot> Consider it noted.
13:33:55 <yallop> is there a restriction on pattern matching for methods of classes with associated type synonyms?
13:34:00 <yallop> or is the following a bug? http://hpaste.org/4312
13:34:23 <manu3000> hello, I have a Haskell script that writes to a sqlite3 database. so far so good. When it runs inside the CGI monad (like say, I am trying to write to the database from a website), I get a 500 Internal Server Error, exception :: Database.HDBC.SqlError ! Has anybody had this problem ? Is this because the process is owned by the web server ?
13:38:17 <dons> could be.
13:38:23 <dons> perhaps the database doesn't have permissions?
13:38:32 <dons> can you run it by hand successfully?
13:38:55 <profmakx> i wrote my first really productive haskell program. and i dont ever want to code in any other language.
13:38:55 <manu3000> dons : yes I can run the script in the IO monad, straight from main
13:38:59 <Olathe> 500 has to be the worst-informative error message in history.
13:39:15 <dons> manu3000: ok. so I'd suspect permissions or path issues then
13:39:22 <dons> (i use sqlite3 and CGI at work ok, btw)
13:39:26 <dons> profmakx: cool :)
13:39:33 <manu3000> dons : the database is a flat file, I've tried changing the permissions, to no avail
13:39:42 <byorgey> Olathe: how about "Error"?
13:39:45 <dons> manu3000: is it visible to the cgi process?
13:39:55 <dons> sometimes the web server prevents access to funny locations
13:39:56 <profmakx> Olathe  "General Error"
13:40:00 <Olathe> byorgey: I think they're equivalent.
13:40:17 <Olathe> 500 = Something went wrong to make this not work.
13:40:19 <manu3000> dons:  well, yeah, cause I can run a select query from the CGI
13:40:54 <manu3000> dons: but when I try to 'insert', I get the 500
13:41:22 <byorgey> yallop: you could try posting to haskell-cafe if no one here responds.
13:41:47 <dons> manu3000: hmm. write permissions?
13:41:55 <dons> manu3000: i'm not familiar with hdbc
13:42:08 <manu3000> dons: me neither :)
13:42:53 <manu3000> dons: I changed the db file to 0777, but no...
13:58:55 <quicksilver> manu3000: remember you need execute permissions to the entire path to the file
13:59:29 <manu3000> quicksilver: right, you mean the folder holding the db file needs to be executable ?
14:00:54 <quicksilver> manu3000: and its parent and its parent and its parent..
14:01:24 <manu3000> quicksilver: yep, ok, i try that...
14:11:05 <manu3000> quicksilver: all the parent directories have 'x' for u,g,o except the top one  /Users which has drwxrwxr-t
14:20:51 <gwern> is there any darcs repo for 'scrap your boilerplate with class'? the one on hackage seems to be broken with ghc 6.8 or whatever in more than just dependencies
14:24:02 <_ry> is the ghc parser using parsec?
14:24:18 <gwern> nm. change a few arguments, add an extension, remove some haddock stuff and it works now
14:25:10 <swiert> _ry: I think the ghc parser uses happy.
14:25:19 <ndm> it uses happy
14:25:20 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
14:27:39 <ndm> @tell dons I've fixed tagsoup HEAD, and i'm just tracking down one user bug, then I'll release a new version - thanks for the heads up
14:27:39 <lambdabot> Consider it noted.
14:27:59 <dons> ndm: ok. cool.
14:27:59 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
14:28:12 <dons> ndm, i've used it for a couple of things now
14:28:18 <dons> and likely lambdabot will use it more and more for scraping
14:28:19 <ndm> HEAD or darcs version?
14:28:30 <dons> hackage tagsoup
14:28:33 <ndm> they have different API's, quite different in some respects
14:28:34 <dons> e.g. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hackage2hwn-0.1
14:28:35 <lambdabot> http://tinyurl.com/yqp33r
14:29:21 <dons> ndm, also, i guess lambdabot should move to new hoogle?
14:29:36 <swiert> dons: I had a crack at formalizing parts of xmonad in Coq.
14:29:38 <ndm> dons: i updated the hoogle database, but not the binary
14:29:55 <swiert> dons: and came to the conclusion that it's pretty hard :(
14:29:59 <dons> swiert: awesome! Roman's also working on this (in type families)
14:30:06 <dons> swiert: the StackSet stuff specifically?
14:30:15 <ndm> dons: if you just update the hoogle.txt database with http://haskell.org/hoogle/res/hoogle.txt that should be enough
14:30:28 <swiert> dons: yes (well, just the Stack).
14:30:42 <swiert> dons: I managed to prove that up (down x) = x.
14:30:56 <dons> ndm, awesome
14:31:03 <dons> swiert: ah great.
14:31:16 <dons> swiert: i'm happy to take patches (or suggestoins of patches) that would make the code easier to formalise
14:31:27 <dons> also, if you want to blog about this, i'd love to see some examples
14:31:36 * ndm too
14:31:49 <swiert> dons: ok. I'll think about it.
14:32:04 <dons> even just a mail showing how far you got.
14:32:05 <Nafai> That would be an interesting thing to advertise on the xmonad home page
14:32:17 <dons> I'd like to ensure StackSet.hs can be used as sort of a 'nofib' for analysis of haskell code
14:32:17 <Nafai> "The only X Window Manager formally proven to be correct"
14:32:32 <Nafai> (Okay, so that's a stretch, since *all* of it might not be provable)
14:32:33 <swiert> After the category theory talks on youtube, I've been meaning to make a series of dependently typed programming talks/screencasts.
14:32:37 <ndm> that would be uber cool
14:32:49 <Nafai> dons: nofib?
14:32:51 <ndm> I should persuade Matt to run Reach over it
14:33:03 <roconnor> swiert: does epigram2 have a set/prop distinction?
14:33:06 <dons> swiert: yeah. that would really be good
14:33:15 <dozer> @src foldl
14:33:15 <lambdabot> foldl f z xs = lgo z xs
14:33:15 <lambdabot>     where lgo z []     =  z
14:33:15 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:33:16 <swiert> I was browsing through xmonad code looking for good examples.
14:33:28 <swiert> roconnor: good question. let me have a look.
14:34:30 <dons> swiert: so all the good stuff is in StackSet.hs, and you'll find some nice properties in tests/Properties.hs
14:34:40 <dons> trying to establish some of those properties statically would be useful
14:34:54 <Nafai> It would be sure nice to have lambdabot's capabilities integrated into my editor/ide
14:35:01 <swiert> roconnor: yes.
14:35:29 <Nafai> That's one nice thing about Eclipse / Java...I can look at source for things in the JDK easily, so I can understand what that does
14:35:49 <swiert> dons: yep. I'd found those. I need to clean up my proof, I'd be happy to blog/send you an e-mail/whatever once it's somewhat fit for human consumption.
14:36:27 <dons> excellent, i'd be keen to see it.
14:38:37 <dons> bringert: i remember you wrote some tool that could download 1G+ files via lazy bytestrings over http
14:38:49 <dons> what bytestring http support did you use for that?
14:38:58 <bringert> dons: I did?
14:39:16 <bringert> hmm, maybe
14:39:34 <dons> do you remember doing lazy bytestring downloading stuff?
14:39:42 <jvoorhis> if f :: (a -> a -> a -> a), what's the simplest way to apply it to a (,,) or a 3-element list?
14:39:50 <dons> possibly i'm confused. maybe it was Lemmih or jlouis working on conjure or downnova?
14:40:07 <bringert> dons: I remember working on large uploads for the cgi package
14:40:08 <dons> jvoorhis: pattern matching
14:40:13 <dons> bringert: ah yes, that's right.
14:40:23 <dons> so there must have been some bytestring http layer
14:40:31 <quicksilver> Nafai: you could just install the documentation locally...
14:40:35 <dons> or maybe you jsut wrote to handles, after setting up the connection?
14:40:39 <jvoorhis> i was hoping i could somehow do a fold with ($) or something :)
14:40:46 <quicksilver> Nafai: witht he new haddock and stuff it's all hyperlinked to the source
14:40:46 <dons> jvoorhis: well, over a list, yes.
14:40:52 <dcoutts> dons: isn't there bytestring http parsing in happs
14:41:02 <bringert> dons: I think I was only only working on the server side with accepting uploads, but I'm not sure
14:41:03 <dons> > foldl1 (\a b c -> a + b + c)  [1,2,3]
14:41:06 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
14:41:06 <lambdabot>     Probab...
14:41:19 <byorgey> > foldl (\a b c -> a + b + c) id [1,2,3]
14:41:19 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
14:41:19 <lambdabot>     Probab...
14:41:20 <bringert> dons: I don't know what I used in the client, possibly a web brower
14:41:30 <bringert> no, that doesn't seem right
14:41:37 <dons> mm
14:41:41 <Nafai> quicksilver: *nods*  That's a step in the right direction
14:41:45 <dons> dcoutts: hmm. maybe
14:41:50 <bringert> dons: anyway, if you want bytestring http, I would look at nominolo's fork of the http package
14:41:54 <byorgey> > foldl ($) (\a b c -> a + b + c) [1,2,3]
14:41:55 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
14:41:55 <lambdabot>     Probabl...
14:42:05 <dons> bringert: ah.
14:42:27 <byorgey> > demonstrate foldl
14:42:27 <lambdabot>  "fold (+) 0 [1..5] = (((((0 + 1) + 2) + 3) + 4) + 5)"
14:42:30 <dons> bringert: for soc?
14:42:37 <thoughtpolice> Nafai: lambdabot in ghci is pretty awesome.
14:42:39 <roconnor> swiert: oh wow
14:42:48 <dons> Cale, byorgey: this demonstrate stuff should go in a nice little package somewhere :)
14:42:52 <bringert> dons: no, he wrote it before soc, as a course project I think
14:43:06 <byorgey> dons, agreed!
14:43:09 <dons> @seen nominolo
14:43:09 <lambdabot> I saw nominolo leaving #haskell, #ghc and #haskell-soc 2d 5h 59m 19s ago, and .
14:43:13 <bringert> dons: http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html
14:43:14 <lambdabot> Title: nominolo's Blog: Network.HTTP + ByteStrings
14:43:15 <dons> ah
14:44:22 <bringert> dons: btw, we've started thinking about Hac 2008 at Chalmers
14:44:32 <jvoorhis> thanks guys
14:44:33 <bringert> dons: we have a candidate date, and a stub wiki page http://www.haskell.org/haskellwiki/Hac_2008
14:44:34 <byorgey> > let f = (\a b c -> a + b + c) in (((f $ 1) $ 2) $ 3)
14:44:34 <lambdabot>  6
14:44:36 <lambdabot> Title: Hac 2008 - HaskellWiki
14:44:51 <byorgey> hmm, so why doesn't foldl ($) (\a b c -> a + b + c) [1,2,3] work?
14:45:07 <dons> bringert: yep, been following it
14:45:14 <Nafai> thoughtpolice: I compiled lambdabot locally a while back, but I only ran it as a IRC bot.  It would be nice to have it run with my local ghci.  Is that something that is documented how to do?
14:45:17 <dons> byorgey: type of the accumulator
14:45:31 <bringert> dons: oh and another thing, will galois be represented in any way at http://www.jobs-in-fp.org/
14:45:32 <lambdabot> Title: Jobs in Functional Programming
14:45:33 <byorgey> @type foldl
14:45:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:45:44 <jvoorhis> byorgey: now i'm not sure you *can* foldl with ($)
14:45:47 <jvoorhis> but you can foldr
14:45:57 <dons> bringert: there's lots of interest, and we've got people on the case
14:45:58 <bringert> dons: what do you think of April 11-13 as hac dates?
14:45:58 <dons> so i hope so
14:46:13 <byorgey> oh, ok, I see
14:46:25 <bringert> @seen dcoutts_
14:46:25 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 37m 34s ago.
14:46:26 <dons> i don't want those other guys stealing our chalmers hackers :)
14:46:32 <bringert> :-)
14:46:44 <bringert> dons: get them to fly you over here
14:46:47 <dcoutts> hia bringert
14:46:52 <bringert> hi dcoutts
14:47:12 <bringert> dcoutts: what do you think of April 11-13 as Hac 2008 dates? http://www.haskell.org/haskellwiki/Hac_2008
14:47:20 <sclv_> > msg lambdabot demonstrate accumMap
14:47:25 <dons> bringert: i'm pretty sure we'll have someone there
14:47:32 <lambdabot>   Not in scope: `accumMap'
14:47:36 <dcoutts> bringert: lemme check Oxford term dates.
14:48:16 <Nafai> byorgey: Question for you (and anyone else)...What's the easiest way to get all 4 to 7 item sequences from a list?
14:48:27 <bringert> dons: you guys should be on the programme page then, having lots of companies there will attract students. and galois is the only haskell company most students have heard of
14:48:42 <byorgey> Nafai: do they have to be consecutive?
14:48:50 <dons> bringert: yes, i'm talking to our recruitment people
14:49:00 <mwc_> bringert, out of curiosity, are they familiar with Jane St?
14:49:18 <bringert> mwc_: possibly these days, not say a year ago
14:49:35 <dcoutts> bringert: ok for Oxford, we start back on April 20th.
14:49:41 <bringert> mwc_: them buying up haskell adwords probably helps
14:49:55 <bringert> dcoutts: so that's during your easter break?
14:50:01 <dcoutts> bringert: yep
14:50:09 <dcoutts> which is good
14:50:24 <Nafai> byorgey: Yes.  I'm basically wanting to get the set of possible "words" from a string.
14:50:34 <bringert> Chalmers has easter break 2008-03-17 - 2008-03-24
14:50:46 <dons> ?hoogle pseq
14:50:46 <lambdabot> GHC.Conc.pseq :: a -> b -> b
14:50:50 <dons> ?hoogle par
14:50:50 <lambdabot> Control.Parallel.par :: a -> b -> b
14:50:50 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
14:50:50 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
14:50:52 <bringert> weird that they're in such different times
14:50:57 <dons> ?hoogle forever
14:50:57 <lambdabot> No matches found
14:51:10 <Igloo> bringert: It's really only 1 week?
14:51:29 <dibblego> hpaste broked?
14:52:18 <bringert> Igloo: yes, plus one week of re-take exams for students who have failed some course
14:52:31 <bringert> Igloo: so if you don't fail your courses, you get two weeks
14:52:32 <mwc_> bringert, you let people do retakes?
14:52:44 <bringert> mwc_: any number of retakes even
14:52:45 <Igloo> bringert: OK, it's not that strange then - ours starts 9 March
14:52:49 <mwc_> bringert, wow
14:52:58 <dons> ?hoogle forever
14:52:58 <lambdabot> No matches found
14:53:15 <dons> ?hoogle forever
14:53:16 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
14:53:18 <dons> yay!
14:53:19 <mwc_> I'd love to retake my functional analysis exam. I made three stupid mistakes that I'd love to fix
14:53:23 <dons> ndm: hoogle updated
14:53:30 <dons> ?hoogle on
14:53:31 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:53:31 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
14:53:31 <lambdabot> Data.Function :: module
14:53:36 <bringert> mwc_: you can retake even if you passed, and your best grade will count.
14:54:08 <bringert> mwc_: this is only at technical universities, others only allow retakes if you failed, and you can only get a pass grade at the retake, not a higher grade
14:54:23 <mwc_> bringert, what about grad courses?
14:54:23 <lament> which is SO MEAN
14:54:47 <lament> i was screwed like this
14:55:02 <lament> got a grade above passing grade, but below minimal required grade for the program
14:55:05 <bringert> mwc_: masters-level courses have the same system, phd-level very rarely have written exams
14:55:09 <lament> can't retake the course
14:55:15 <lament> since i didn't fail
14:55:47 <mwc_> bringert, ah, we don't have that distinction here, between PHD and Masters courses
14:56:00 <dcoutts> ndm: well done on getting hoogle updated
14:56:20 <mwc_> Except that phd students generally are around longer, so they take some 8xx courses, rarely will a masters student have the time to take anything except 7xx
14:56:21 <dcoutts> ndm: we should discuss some time goals for hoogle 4 and hackage integration
14:56:40 <mwc_> hey, what's this I saw around here about haddock?
14:56:43 <mwc_> er, haddock 2?
14:57:15 <dons> ?uptime
14:57:15 <lambdabot> uptime: 3d 16h 4m 35s, longest uptime: 1m 10d 23h 44m 29s
14:57:23 <dons> i note no lockups since switching to the non-threaded rts
14:57:37 <ddarius> @users
14:57:37 <lambdabot> Maximum users seen in #haskell: 420, currently: 404 (96.2%), active: 19 (4.7%)
14:58:42 <bringert> dons: have you looked a Tim Bray's Wide Finder benchmark btw? http://www.tbray.org/ongoing/When/200x/2007/10/30/WF-Results
14:58:42 <lambdabot> Title: ongoing &#xb7; WF XI: Results
14:58:57 <bringert> dons: I have a quick hack implementation here: http://www.cs.chalmers.se/~bringert/darcs/wide-finder/wf.hs
14:59:16 <dons> i've only seen that he runs on solaris and didn't want to build ghc there
14:59:22 <dons> also, that its regex/io based?
14:59:26 <bringert> yeah
14:59:32 <dons> so it'll come down to who can call tre or pcre
14:59:43 <dons> i.e. not Text.Regex.Posix :)
15:00:01 <dons> looks good
15:00:09 <dons> have you seen bos' implementatoin?
15:00:57 <scodil> so, i'm using two threads (this is in IO) and I'm seeing my both my cores being used, but its running no faster
15:01:00 <mwc_> speaking of benchmarking
15:01:13 <mwc_> is there any progress on getting the shootout kids to upgrade to ghc 6.8?
15:01:15 <bringert> dons: had a look at it now
15:01:25 <ddarius> scodil: So?
15:01:36 <scodil> so. this is normal?
15:01:52 <dons> mwc_: we await ghc 6.8.2 in gentoo
15:02:00 <dons> since 6.8.1 has broken spec constr anyway, so that's no fun
15:02:07 <mwc_> scodil, if you're IO bound on the network or HD, then throwing cores at the problem won't help
15:02:27 <scodil> no this is for sure compute bound
15:02:38 <ddarius> scodil: Depends on the code.  Threading costs something so it's possible that the cost of threading is matching/overwhelming the gain from parallelisation.
15:02:39 <dons> scodil: yep, you'll just have to think about what is going on -- how much communication hs happening and so on
15:02:47 <scodil> no communication
15:02:57 <scodil> its like vanilla openMP loop parallelization
15:03:05 <dons> buggy code then?
15:03:10 <dons> is it short?
15:03:13 <dons> could you hpaste it?
15:03:15 <scodil> yeah
15:03:27 <mwc_> dons, what is the timeframe on 6.8.2?
15:03:32 <bringert> dcoutts: you meant April 21st as the first day of the term, right?
15:04:05 <dcoutts> bringert: Oxford weeks start on Sunday :-)
15:04:24 <dcoutts> bringert: it's not as weird as Cambridge though, their weeks start on Thursdays.
15:04:28 <hpaste>  scodil pasted "parallelized code" at http://hpaste.org/4314
15:04:37 <dcoutts> or was it Wednesdays, I forget
15:04:39 <mwc_> "The 6.8 branch is the current STABLE, and 6.8.2 is due very soon."
15:04:47 <mwc_> any knowledge of what very soon means?
15:04:59 <ndm> dcoutts, I think I know what's needed, i'm a few pieces of Hoogle infrastructure away from doing that yet
15:05:04 <bringert> dcoutts: but are there classes on the sunday?
15:05:11 <dcoutts> bringert: no
15:05:21 <Heffalump> bringert: no. And not on the Saturday either, unlike those silly tabs.
15:05:31 <bringert> so in what sense does the week start on sunday?
15:05:37 <Heffalump> counting-wise
15:05:45 <dcoutts> bringert: by decree :-)
15:05:50 <Heffalump> Sunday is the beginning of week n, and Saturday is the end.
15:06:03 <dons> that's some pretty wild code scodil
15:06:11 <bringert> ah, but that's just general anglo-saxon weirdness, isn't?
15:06:23 <dons> scodil: so compiled with -O2 -threaded , and run with +RTS -N2
15:06:27 <dons> ?
15:06:29 <scodil> yeah
15:06:33 <ndm> no, that's general oxcan weirdness
15:06:38 <dcoutts> bringert: no, the rest of the UK generally count from Monday -> Sunday
15:06:39 <ndm> York weeks start on Monda
15:06:49 <dons> scodil: is it contending for the same array in memory?
15:06:50 <bringert> US weeks start on Sunday, right?
15:06:51 <scodil> -N1 and -N2 make no difference. same wall time, but -N2 uses both cores for sure
15:07:00 <dons> same wall time exactly?
15:07:03 <ndm> but all York lectures start at 15 minutes past the hour - thats a bit weird :)
15:07:13 <dons> do you see more than 100% cpu utilisation when timing?
15:07:14 <scodil> dons: same wall time, give or take a few seconds
15:07:17 <scodil> yeah
15:07:20 <sjanssen> bringert: yes
15:07:25 <dons> not 200% cpu, then, scodil ?
15:07:30 <scodil> oh
15:07:32 <dons> you should see more than 100%
15:07:41 <dons> like 190% or so, if its doing a good job
15:07:42 <dcoutts> ndm: Oxford it's only 5 past, since Oxford solar time is ~5min later than GMT :-)
15:07:50 <sjanssen> bringert: though many businesses and the like label Monday as the first day of the week
15:08:00 <bringert> ndm: Chalmers is weirder, all lectures start on the hour before lunch, and 15 min after after lunch
15:08:02 <scodil> i'm using this here monitor thingy on the task bar. it's half-full w/ -N1, and totally full with -N2
15:08:02 <dozer> sjanssen: first day of the /working/ week
15:08:14 <sjanssen> dozer: right
15:08:18 <dons> scodil: is that code compilable, can you include the import statements, and a main necessary to run it?
15:08:24 <ndm> dcoutts: York's is because the first city bus in 1960 arrived at 9:12
15:08:31 <scodil> dons: no not really
15:08:39 <dcoutts> ndm: heh
15:08:43 <scodil> i mean, thats the meat of the program. you would need a lot
15:09:00 <bringert> ndm: but at gothenburg university everything starts 15 min past the hour. now our department is actually shared between Chalmers and GU
15:09:01 <dcoutts> ndm: so in hoogle atm, how do you manage the various kinds of names, like module, type, value etc?
15:09:15 <dcoutts> ndm: are they all tagged with their kind?
15:09:19 <ndm> dcoutts, yes
15:09:28 <bringert> ndm: and phd defences start at 15 past, even at chalmers
15:09:38 <ndm> but they share a common name lookup
15:09:52 <bringert> summary: it's hard to know if time T means T or T + 15
15:10:03 <dcoutts> ndm: so you'll be able to add fields from .cabal files like name, description, author etc as just new tags?
15:10:27 <dcoutts> ndm: and do text searches within those fields?
15:10:41 <dozer> 20 min to run something to realise that I've got a == and /= the wrong way about --in my debug printing code!
15:11:16 <ndm> dcoutts, yes, but i'd probably keep a metadata field separate, and possibly have the search work in different ways - not sure yet
15:11:26 <ndm> dcoutts, but i will do full text search of a large blob of metadata :)
15:11:26 <dcoutts> ndm: it'd be nice to replace the hackage package list page with hoogle and have hoogle as the interface to hackage
15:11:30 <ddarius> dozer: Unfortunately Haskell can't catch everything... unless you want to make your types a lot richer.
15:11:40 <ndm> dcoutts, sounds like a plan :)
15:12:02 <dcoutts> ndm: I'm not sure a full text search of the .cabal file is appropriate, some meta data is more significant than others
15:12:14 * ddarius would still want a browseable list.
15:12:27 <dcoutts> ndm: oh, and the other one was that hoogle should also do a text search of the haddock comments
15:12:52 <ndm> dcoutts, that can all be done
15:13:02 <dcoutts> ndm: think about googling for a package that does "blah", you'd find it by the package's description or documentation using those key words
15:13:05 <ndm> ddarius: hoogle can give you a browsable list
15:13:52 <dcoutts> ndm: then we should attach more weight to some things than others, like if I hoogle for bytestring then the package name match is more significant than a description about using bytestrings in some other package
15:14:15 <dcoutts> ndm: and finally, we should be able to make searching all of hackage not insane by ranking packages
15:14:19 <ndm> dcoutts, hoogle already has the idea that certain matches are more important than others, so that easy
15:14:22 <dcoutts> ndm: by popularity
15:14:25 <scodil> so, is it normal that 2x parallelization doesn't get you anything? do you need like 4x or more? is there contention for the allocator/garbage collector or something?
15:14:29 <ndm> again, easy to do :)
15:14:41 <dcoutts> ndm: sure, we just need to tune the ranking for these new kinds of metadata
15:14:44 <ndm> the hardest bit is making this fast enough
15:14:59 <dcoutts> ndm: aye
15:15:06 <bringert> scodil: in my experience no, 2x often gives you almost 2x wall clock speed-up
15:15:19 <scodil> ok cool
15:15:19 <bringert> scodil: if the task is heavily parallelizable
15:15:54 <dcoutts> ndm: someone suggested calculating the pigeon rank of hackage packages basically by looking at dependencies and download popularity
15:16:00 * Heffalump pokes Igloo about 6.9 binary snapshots
15:16:08 <dozer> scodil: my experience (in Java) is that if you are spinning 2 CPUs at 100% each, you will get nearly half the user time if there is lots of thread contention, the overall cpu drops to much closer to 100% of one CPU
15:16:56 <dons> scodil: you might want to consider the ndp parallel arrays package instead?
15:16:57 <ndm> dcoutts, thats not a very good plan - you end up with really low-level packages like bytestring beating even commonly used packages like parsec, which tend to be more used in applications and less in libraries
15:17:03 <dons> which abstracts over all the underlying forkIO business
15:17:08 <ndm> but downloads seems to be a good plan
15:17:14 <dcoutts> ndm: right, hence the combo of deps and downloads
15:17:19 <ndm> yeah
15:17:20 <dons> scodil: mrd has used them recently, successfully
15:17:22 <dcoutts> ndm: remember, core packages never get downloaded
15:17:28 <ndm> hehe, true :)
15:17:32 <dons> scodil: e.g. http://sequence.complete.org/node/371
15:17:33 <lambdabot> Title: Data Parallel Bellman-Ford | The Haskell Sequence
15:17:33 <ndm> but i think we can hardcode them :)
15:17:35 <dcoutts> ndm: but they probably account for most searches
15:17:45 <dcoutts> ndm: that's not very automatic :-)
15:17:58 <dozer> sounds like you want an 'information' metric for package use
15:18:07 <scodil> dons: but what's wrong with my forkIO business? I'm trying to understand
15:18:09 <dozer> if everything imports it, then it is not very informative
15:18:23 <dons> scodil: i can't tell -- the code is too hairy
15:18:34 <ndm> dcoutts: again, true - we can hack it eventually, its all just heuristics by that stage
15:18:44 <dcoutts> aye
15:19:15 <scodil> i've got a function f, i'm applying it to every element in an array, so I split the array range into two halves. make two threads, and apply f separately to those halves.
15:19:20 <scodil> i don't know how it could be any easier
15:19:48 <dcoutts> hey bringert, got spare hacking time this evening?
15:19:49 <dons> scodil: that should be easy to do then. i'm not sure why there's so much code?
15:19:56 <scodil> f is complicated
15:20:12 <dons> scodil: and also, its super easy with ndp arrays (just use Data.Parallel.Array.*.map
15:20:13 <scodil> i'll repaste with only the parallelizing business...
15:20:15 <dozer> scodil: have you benchmarked something similar where f is very simple?
15:20:25 <dons> try just you know, (+1) or somehting
15:20:46 <dons> this is begging for ndp arrays though
15:20:52 <dozer> and could you pate in the "time" stats when you run it?
15:22:04 <hpaste>  scodil annotated "parallelized code" with "(no title)" at http://hpaste.org/4314#a1
15:23:13 <bringert> dcoutts: I had some. but I spent it on getting a bunch of my packages to compile with 6.8.1
15:23:39 <dcoutts> bringert: oh yes I noticed the new entries on hackage, good job.
15:24:04 <dcoutts> bringert: I'm getting closer to a working cabal-install with new command line handling
15:24:10 <bringert> dcoutts: great
15:25:46 <bringert> dcoutts: I use the cabal command (how do we refer to it now that it's all one command?) to build every thing. it's so convenient
15:26:21 <dcoutts> bringert: you mean just 'cabal install' in the current dir?
15:26:33 <bringert> right
15:27:01 <noteventime> There isn't a way to link Haskell and OCaml apps without going through the C FFI, is there?
15:27:20 <noteventime> With that I mean, without writing a new compiler
15:27:44 <noteventime> I understand that it could be done by writing a frontend for LLVM, or something similar
15:28:10 <dmwit> I don't think GHC has an OCaml FFI.
15:28:22 <dmwit> I doubt OCaml has an Haskell FFI, either. =P
15:28:26 <noteventime> :-)
15:28:28 <noteventime> Actually
15:28:47 <noteventime> Are there any non C FFIs around?
15:28:51 <noteventime> For Haskell
15:30:12 <dmwit> There's a Win32 FFI, and I think that's it.
15:30:20 <noteventime> Ok :-)
15:30:32 <noteventime> I was just curious :-)
15:30:49 <dcoutts> bringert: aye, it's really convenient when it works :-). I'd also like it to have the other commands beyond just install.
15:31:00 <bringert> yes, me too
15:31:27 <bringert> I really miss clean and sdist, and to a lesser extent configure and build
15:31:35 <lament> ricky_clarkson: haskell doesn't have variables in the Java sense. I don't see what the objection is.
15:31:57 <ricky_clarkson> Haskell does have variables.  The Java 'sense' is warped.
15:32:14 <ricky_clarkson> Even in Java, final variables are still variables.
15:33:43 <mokus> haskell doesn't have variables, because haskell's "variables" don't vary
15:33:55 <mokus> the same identifier can repeatedly get redefined
15:34:01 <fozze> hi, I'm going through the yaht and I'm on section 4.5.3 on Recursive Datatypes, I understand the concept, but I'm not sure how to use the functions in GCHI interactively, could someone give me a clue on using the functions in the exexercise in that section?
15:34:03 <mokus> which seems like a variable to the unititiated
15:34:15 <lament> mokus: except they're called variables
15:34:21 <dmwit> fozze: You have to put data type declarations into files and load them from GHCi.
15:34:33 <lament> because that's the mathematical terminology
15:34:37 <fozze> dmwit: right, now how do I use them?
15:34:44 <ddarius> noteventime: Different implementations have different FFI bindings beyond C ones.
15:34:46 <mokus> they can be called variables by those that choose to do so
15:35:00 <mokus> I call them identifiers, parameters, and sometimes variables
15:35:04 <mokus> but, they don't vary
15:35:17 <lament> sure they do
15:35:17 <mokus> which is what peeople usually mean when they say haskell doesn't have variables
15:35:25 <lament> f x = x + 2
15:35:31 <lament> f 3  -- x is 3
15:35:35 <hpaste>  fozze pasted "Learning about Recursive Datatypes" at http://hpaste.org/4315
15:35:36 <lament> f 2  -- x is 2
15:35:40 <ricky_clarkson> mokus: They do vary, if you exit the scope and re-enter it, by calling the function again, it can have a different value.
15:35:45 <noteventime> ddarius: Any interesting ones? :-)
15:35:46 <mokus> those are different x'es ;-)
15:35:55 <ricky_clarkson> They are variables in the same sense mathematical variables are.
15:36:04 <lament> mokus: look the same to me!
15:36:12 <dmwit> fozze: "Nil" and "Cons 3 Nil", for example, are values of type "List Int".
15:36:14 <mokus> that's because they're in the same place :)
15:36:20 <fozze> dmwit: k
15:36:26 <dmwit> fozze: You can enter those values at the GHCi prompt.
15:36:44 <fozze> dmwit: if I type ":t List" I should get a definition right?
15:36:49 <dmwit> nope
15:36:56 <ddarius> noteventime: GHC used to be able to do some .NET stuff and I think it might have had one or two others.  yhc has a few if I'm not mistaken.
15:37:16 <lament> mokus: i agree that "parameters" is a better term, but they're called variables because that's what they're called in math. The usage of the word in other programming languages to mean a different kind of entity is unrelated.
15:37:25 <dmwit> fozze: List is a type constructor, not a value, so it doesn't have a "type", it has a "kind".
15:37:29 <mokus> I don't mind calling tem that
15:37:42 <fozze> dmwit: ah...
15:37:44 <dmwit> fozze: But ignore that for now; what you probably want is something like, ":t Nil" or ":t Cons 3 Nil".
15:37:45 <mokus> I'm just upholding the notion that there is a sense in which they aren't variables
15:38:04 <ricky_clarkson> lament: Why should we use variable to mean something other than it means in maths?
15:38:09 <lament> mokus: no, there is'nt
15:38:19 <dmwit> fozze: You can also get more information about an identifier with, for example, ":i List".
15:38:24 <lament> ricky_clarkson: because the word is confusing :)
15:38:26 <dons> yeah, mutable variables aren't variables.
15:38:42 <dons> they're strange low level stateful, side effecting weirdos
15:38:45 <lament> ricky_clarkson: the word is confusing because of its corruption by other programming languages
15:38:46 <fozze> dmwit: sweet, thanks
15:38:52 <dons> you have a side condition that no other part of your code needs the old value
15:38:56 <mokus> mutable variables aren't mathematical variables
15:38:59 <dons> as  soon as you do the assignment
15:39:10 <dons> so better be good with the threads
15:39:21 <mokus> but there certainly is precedent for letting the word "wariables" mean "mutable variables"
15:39:41 <ricky_clarkson> Ok, so Java variables are not even variables.  I like that. ;)
15:39:44 <mokus> and language is nothing but precedent, I argue (though I certainly don't want to get caught up in a debate about that)
15:39:44 <lament> mutable variables are variables in the CS sense, regular function parameters are variables in the math sense
15:39:47 <lament> witness the confusion
15:40:12 <lament> "mutable variables" vs. "parameters" makes the distinction more clear
15:40:31 <dons> we should deprecate mutable variables though. by ensuring they're harder to write
15:40:37 <dons> (in text)
15:40:39 <ricky_clarkson> lament: When you say CS, I think you mean CS degree, sadly.
15:40:59 <Japsu> When you say CS, they think Counter-Strike.
15:41:03 <Japsu> *boom* headshot!
15:41:04 <ricky_clarkson> Heh.
15:41:04 <dmwit> Dang, #haskell is approaching #lisp for snobbery these days. ;-)
15:41:05 <lament> http://en.wikipedia.org/wiki/Variable#In_computer_programming
15:41:10 <lament> "Variables in computer programming are very different from variables in mathematics and the apparent similarity is source of much confusion."
15:42:19 <lament> "n computer programming a variable is a special value (also often called a reference) that has the property of being able to be associated with another value (or not). What is variable across time is the association." -- in this sense, haskell variables aren't variables. So there you go. :)
15:42:37 <ricky_clarkson> wikipedia, the bazaar.  In a bazaar, the loudest, most repetitive and most numerous win.
15:42:42 <dons> dmwit: this "why doesn't haskell have variables" fud is an old brick we love to kick
15:42:48 <mokus> there ya go, and you can't argue with wikipedia! ;-)
15:43:05 <dmwit> dons: Heh, yeah. =)
15:43:10 <mokus> if it's on the internet, it must be true!
15:43:25 <dmwit> ?quote ooooh
15:43:25 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
15:43:25 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
15:43:26 <proqesi> haskell *does* have variables
15:43:46 <proqesi> I created my own implementation which has them
15:44:14 <proqesi> on a more serious note, uh..
15:48:06 <ricky_clarkson> @quote variable
15:48:06 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
15:48:06 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
15:48:23 <mokus> of course, "lacking variables" isn't really a justifiable basis for snobbery - it puts hasell squarely in the same class as brainfsck
15:48:46 <lament> (the discussion of variables was much less retarded than the parallel discussion of polymorphism in ##java that started it, but still pretty lame)
15:49:13 <lament> mokus: no, the basis for snobbery is "Haskell's variables are pure math! None of your stupid _programming_ crap"
15:49:14 <ricky_clarkson> lament: Let's not entertain the notion that programming isn't mathematical.
15:49:47 <ricky_clarkson> There lie dragons, side effects and mainstreamity.
15:50:09 <lament> Lie dragons?
15:50:25 <SamB_XP> lament: dragons are drawn in uncharted regions on maps
15:50:36 <SamB_XP> lament: this doesn't happen so much anymore
15:50:44 <Olathe> Uncharted ?
15:50:49 <ricky_clarkson> outside the Whitehouse, at least.
15:50:56 <Olathe> No, they went there and found a huge dragon.
15:50:59 <SamB_XP> perhaps I should have said "were"
15:51:04 <lament> SamB_XP: i was referring to Lie groups
15:51:15 <SamB_XP> lament: heh
15:51:18 <lament> since we're being so mathematical
15:51:48 <SamB_XP> hmm, is there a weak version of lie groups called "fib groups"?
15:52:12 <mokus> again, only in the whitehouse
15:52:36 * ddarius returns to his analytic number theory.
15:52:42 <lament> ddarius: ouch
15:53:24 <lament> every time i see a capital gamma, i want to scream
15:53:37 <SamB_XP> what does a capital gamma look like?
15:53:42 * ddarius loves the gamma function.
15:53:44 <nolrai> [ [n..] | n <- [0..]]
15:53:50 <nolrai> >[ [n..] | n <- [0..]]
15:53:54 <nolrai> > [ [n..] | n <- [0..]]
15:53:55 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:54:02 <TSC> SamB_XP: Î
15:54:13 <lament> AAAARGH
15:54:14 <SamB_XP> isn't that like !
15:54:15 <mokus> capital gamma looks like a hangman tree
15:54:24 <mokus> with no horizintal line at the base
15:54:25 <mauke> L
15:54:46 <dibblego> ?check \a b c -> c /= 0 ==> (a + b) `div` c == (a :: Int) `div` (c :: Int) + (b :: Int) `div` c -- is there a way of getting this to work (say, by not using div)?
15:54:46 <lambdabot>  Falsifiable, after 2 tests: -3, 3, 2
15:54:52 <dmwit> mauke: You must be in the Southern Hemisphere, you're gamma is upside down.
15:55:00 <Toxaris> capital gamma looks like the logical next glyph in this series: E F
15:55:07 <TSC> SamB_XP: Not Â¬, Î
15:55:14 <dmwit> Toxaris: Gamma looks like G?
15:55:19 <lament> AAARGH!
15:55:23 <idnar> hahahha
15:55:36 <Toxaris> dmwit: next *glyph*, not next character
15:55:38 <ddarius> M[e^(-t)]
15:55:43 <dmwit> =)
15:56:06 <ddarius> dmwit: There is no (single) "logical next glyph"
15:56:07 <SamB_XP> Knuth says:
15:56:08 <mauke> E F Î L Â¬
15:56:09 <ddarius> Er Tobsan
15:56:12 <ddarius> Crap
15:56:14 <ddarius> Toxaris:
15:56:19 <Toxaris> ddarius: you're talking with me
15:56:29 <dmwit> Typing is hard.
15:56:29 <SamB_XP> Î(x) = (x - 1)!
15:56:33 <Toxaris> ddarius: "logical next glyph" in the iq-test sense
15:56:40 <byorgey> SamB_XP: yes, you can think of Gamma as a generalization of factorial to the complex plane.
15:56:59 <byorgey> Nafai: around?
15:57:18 <SamB_XP> he had zeta or something there
15:57:32 <SamB_XP> but I don't have that on my keyboard or anything...
15:58:16 <Nafai> byorgey: Yeah.  I was wondering if I scared you off :)
15:58:38 <byorgey> Nafai: no, sorry about that, my work internet died =P
15:58:44 <byorgey> and then I came home
15:58:57 <Nafai> Lucky!  (The going home part)
15:59:28 <byorgey> Nafai: but while I was on the subway, I wrote this: http://hpaste.org/4316   =)
15:59:51 * Nafai reads
15:59:51 <Toxaris> SamB_XP: http://www.spinellis.gr/sw/greek/grconv/grconv.jpg
16:00:14 <byorgey> Nafai: oh, btw, I included two alternate implementations of subseqsFromTo
16:00:26 <dmwit> Hey!
16:00:43 <SamB_XP> actually, come to think of it, that was a lowercase gamma...
16:01:00 <ddarius> Î¶ Î³
16:01:10 <Nafai> byorgey: Okay, I already had a similar implementation of subseqs for an earlier problem
16:01:21 <Nafai> byorgey: I'm trying to understand your second implementation of subseqsFromTo
16:01:25 <osfameron> eeeek!  "\t" and "\n" don't seem to work in haskell strings
16:01:42 <ddarius> osfameron: Sure they do.
16:02:04 <dmwit> osfameron: What do you mean by "work"?
16:02:08 <dibblego> ?check \a b c -> (a + b) * c == (a :: Int) * (c :: Int) + (b :: Int) * c -- what's the name of this law?
16:02:08 <lambdabot>  OK, passed 500 tests.
16:02:09 <Nafai> byorgey: I see >>= so you must be using the List monad, but I'm not sure I understand it
16:02:13 <byorgey> Nafai: yup
16:02:18 <dmwit> dibblego: distributive
16:02:20 <byorgey> @src [] (>>=)
16:02:20 <lambdabot> m >>= k     = foldr ((++) . k) [] m
16:02:22 <dibblego> that's it, ta
16:02:27 <osfameron> ddarius, dmwit:  in ghci, I'm seeing the string "hello\nworld" come our as "hello\nworld"
16:02:29 <byorgey> oh, that's not a very instructive @src
16:02:30 <dibblego> "muiltiplication distributes"
16:02:35 <dibblego> oops
16:02:42 <Toxaris> osfameron: well, it's quoted
16:02:43 <dmwit> osfameron: Try putStrLn instead of print. ;-)
16:02:44 <ddarius> osfameron: That's because it's 'show'ing the string.
16:03:11 <Nafai> byorgey: brb
16:03:13 <byorgey> Nafai: for the list monad, x >>= f means, take each element of the list x and apply f to it.  Each application of f results in a new list; then gather up all the results into one big list.
16:03:13 <SamB_XP> osfameron: that happens in Python too...
16:03:14 <osfameron> ah, ok :-)
16:03:15 <osfameron> ta
16:03:19 <SamB_XP> also Lisp.
16:03:32 <SamB_XP> it doesn't happen in C though, because C doesn't have a REPL
16:03:47 <dibblego> in other words, >>= in the list monad means map then concat, or concatMap ;)
16:03:48 <osfameron> it also doesn't happen in Perl because Perl's REPL sucks
16:04:43 <byorgey> dibblego: flip concatMap actually, but yeah =)
16:05:11 <dibblego> oh yeah ;)
16:05:57 <byorgey> Nafai: I should go, but if you're still confused I'm sure there are plenty of others who can explain the list monad.  talk to you later!
16:07:19 <Nafai> byorgey: Later, thanks!
16:10:06 <Nafai> I think what byorgey makes sense.
16:10:57 * osfameron translates the first K&R example into Haskell, then cries when he thinks about trying to translate that version *back* into C...
16:12:02 <mauke> let ghc do it for you
16:12:21 <hpaste>  osfameron pasted "version of code from K&R section 1.2" at http://hpaste.org/4317
16:12:38 <osfameron> mauke: oh?  I can compile it to C code?
16:12:51 <mauke> sure
16:13:07 * osfameron mans ghc
16:13:34 <mauke> ghc -O2 -fvia-C -C
16:13:45 <mauke> well, -C
16:15:12 <osfameron> it has to be said that even the original example code is nicer than that output :-)
16:18:31 <dibblego> ?check \a b c -> (a - b) / c == (a :: Double) / (c :: Double) - (b :: Double) / c -- (a - b)/c == a/c - b/c ?
16:18:32 <lambdabot>  Falsifiable, after 1 tests: 0.0, 0.0, 0.0
16:20:48 <dibblego> how can I get lambdabot to work with the property, (a - b)/c == a/c - b/c ?
16:21:49 <mauke> @check \a b c -> c /= 0 ==> (a + b) / c == (a/c + b/c :: Rational)
16:21:49 <lambdabot>  OK, passed 500 tests.
16:22:14 <mokus> thing is, with floating point numbers, it really is false
16:22:20 <dibblego> yeah I know
16:22:46 <mauke> @check \a b c -> c /= 0 ==> (a + b) / c == (a/c + b/c :: Double)
16:22:47 <lambdabot>  Falsifiable, after 4 tests: 2.75, 8.0, -2.5
16:23:32 <dibblego> could you say, 'approximately equal to' for the case of Double?
16:24:29 <mokus> you could test abs (a - b) < epsilon
16:24:57 <mokus> although i gess that wouldn't always work either
16:25:43 <dibblego> ok, never mind, cheers
16:40:54 <EvilTerran> abs (a - b) / abs a `max` abs b
16:41:00 <EvilTerran> is a fairly common metric, iirc
16:41:11 <EvilTerran> (< epsilon, that is)
17:15:54 <dons> pdxfunc (portland haskell hackers) meeting, details on haskell.org
17:16:03 <dons> ocaml hackers welcome :)
17:24:26 <andyjgill> Where is the meeting, Don?
17:25:19 <LoganCapaldo> portland I would guess
17:25:55 <dons> andyjgill: cubespace on the SE?
17:26:02 <dons> just announced on -cafe@
17:26:22 <dons> should be beer involved, i hope
17:26:43 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/32985
17:26:43 <lambdabot> Title: Gmane -- Mail To News And Back Again
17:30:08 <LoganCapaldo> strange. an office building rented out on a per person basis. your coworkers aren't.
17:31:43 <hpaste>  Nafai pasted "Why is this not match " at http://hpaste.org/4318
17:32:43 <andyjgill> How many came to the last meeting, Don?
17:33:15 <monochrom> @type and
17:33:17 <lambdabot> [Bool] -> Bool
17:33:38 <dons> andyjgill: i missed that one. there were 10 or so
17:33:46 <andyjgill> ok.
17:33:48 <Nafai> Oh d'oh
17:33:57 <andyjgill> I'll try get a hall pass.
17:34:19 <nolrai> do {[1,2], [2,3]}
17:34:23 <nolrai> > do {[1,2], [2,3]}
17:34:23 <lambdabot>  Parse error at "," (column 10)
17:34:28 <nolrai> > do {[1,2]; [2,3]}
17:34:35 <lambdabot>  [2,3,2,3]
17:38:18 <davidL> does binary exponentiation always result in the fewest multiplications for x^n when n is even?
17:38:30 <Olathe> No.
17:38:40 <LoganCapaldo> davidL: count and find out :)
17:38:47 <Olathe> Check for addition chains.
17:41:15 <Olathe> http://en.wikipedia.org/wiki/Addition_chain_exponentiation
17:41:43 <davidL> yes, I know, I'm just having a hard time generating them efficiently
17:48:10 <ndm> why would the GHCi debugger fail to perform a ":back"
17:48:25 <ndm> i get an exception, in read, which is called from 100's of places
17:48:35 <ndm> :back says no more logged breakpoints
17:50:11 <ndm> The code is all interpetted and -fbreak-on-exception was passed when i started GHCI
17:51:11 <ndm> (at this point, my GHCi debugger experiences have actually been _worse_ than my Hat experiences!)
17:54:54 <dcoutts> ndm: I'm not sure it keeps previous context by default
17:55:09 <ndm> what gentle prodding could i give it?
17:55:17 <ndm> i roughly followed dons article, which didn't mention anything
17:55:18 <sorear> ndm: afair, back goes back to the previous stop point
17:55:30 <sorear> ndm: so set more breakpoints for :back to work
17:55:33 <ndm> i have no breakpoints explicitly set, just hte break on error
17:55:59 <dcoutts> I'm not sure, but I've heard that there's a mode where it keeps a buffer of the last N stack points or something similar, but that's not on by default as it's really slow
17:56:12 <ndm> i don't want to go back to the previous stop point, i want to know what the previous call was - if i knew which function was the problem, i'd have solved it by now :)
17:57:04 <dcoutts> but one can turn it on, or perhaps they were just talking about implementing that. If it doesn't say in the ghc manual ask pepe or Igloo or JaffaCake.
17:57:26 <ndm> so when dons gives his overview of the GHC debugger, is what he does actually possible?
17:57:33 <ndm> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14
17:57:34 <lambdabot> Title: Haskell hacking
17:57:42 <dcoutts> http://haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
17:57:43 <lambdabot> http://tinyurl.com/2zhb6v
17:58:40 <ndm> so in dons article he skipped the bit which required him to already know where the error was?
17:58:45 <dcoutts> ndm: it suggests to use :trace
17:59:02 <dcoutts> ndm: have you read the ghc manual section on the ghci debugger?
17:59:14 <ndm> so :trace main should be sufficient?
17:59:34 <chessguy> ndm, and then :hist
17:59:34 <dcoutts> possibly
18:00:09 <ndm> hmm, that works, but the information is totally useless
18:00:27 <chessguy> why?
18:00:35 <ndm> its manipulating data resulting from parsing a CSV file
18:00:46 <ndm> the crash is in the manipulation, the history is all about the parsing functions
18:01:58 <chessguy> hmm. you could debug the old fashioned way. only parse/manipulate the first half of the file, and see if you still get the error, etc.
18:02:15 <ndm> perhaps
18:02:26 <ndm> i can equally use the Safe library and annotate all calls to the function in question
18:02:43 <ndm> but thats not really using the shiny new debugger i've been waiting for for so long
18:02:54 <chessguy> agreed
18:03:19 <chessguy> it is a bit disappointing
18:04:12 <ndm> :-(
18:04:30 <ndm> especially as the problem is not that i want to debug, i just want a stack trace!
18:05:09 <ndm> its rather sad that GHC can't do that, but it took Tom 15 minutes to hack it into Yhc
18:05:47 <SamB_XP> 15 minutes? from idea to stack trace?
18:06:07 <ndm> pretty much
18:06:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4320
18:06:19 <ndm> if only Yhc wasn't a broken piece of crap, I'd be sorted!
18:06:58 <dons> dare I quote that?
18:08:21 <ndm> you can only quote it if you add a smilie somewhere in it
18:08:26 <chessguy> > fmap quicksort ndm
18:08:38 <lambdabot>   Not in scope: `ndm'
18:08:49 <SamB_XP> ndm: why is there a need for a smiley
18:09:24 <ndm> SamB_XP: if a piece of text transmitted electronically you can always weasel out of the point of view later with claims like "sarcasm", "irony" or "joke"
18:09:29 <chessguy> "if only Yh:)c wasn't a broken piece of crap, I'd be sorted!"
18:09:36 <ndm> provided you put a smilie somewhere!
18:09:55 <SamB_XP> ndm: this implies that the claim is not, in fact, true
18:10:03 <SamB_XP> are you sure you want to imply that?
18:10:21 <ndm> it gives me the freedom to flip either way as necessary
18:11:07 <sjanssen> > unwords . intersperse ":)" $ words "you can only quote it if you add a smilie somewhere in it"
18:11:10 <lambdabot>  "you :) can :) only :) quote :) it :) if :) you :) add :) a :) smilie :) som...
18:12:27 <SamB_XP> ndm: guess what
18:12:37 <SamB_XP> that quote is offered under a simple permissive license!
18:12:37 <ndm> SamB_XP: dons is a robot?
18:12:51 * ndm doesn't remember signing a EULA
18:13:11 <SamB_XP> http://www.haskell.org/haskellwiki/Haskell_Cafe_migration
18:13:12 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
18:13:16 <SamB_XP> does that ring a bell?
18:13:56 <dons> awesome
18:14:43 <ndm> indeed i did
18:14:45 <SamB_XP> don't you just love this existential licensing?
18:15:00 <ndm> i didn't remember it "any media that are part of the Haskell community"
18:15:07 <ndm> thats an incredibly broad license!!!!
18:15:22 <ndm> i guess that covers my haskell workshop talk and paper as well
18:15:48 <SamB_XP> ndm: I'm not sure about the paper
18:15:56 <SamB_XP> did you put a copyright statement on it?
18:16:27 <ndm> SamB_XP: i had to sign copyright over to the ACM
18:16:45 <ivanm> ndm: you could retroactively apply a different license to your statement! :p
18:16:46 <SamB_XP> oh, well, I'm pretty sure this doesn't cover that then
18:16:48 <ndm> twice (once without subtitle, once with)
18:16:55 <SamB_XP> the ACM is specifically nasty in licensing!
18:17:35 <ndm> they let you put a copy on your website, with the appropriate disclaimer
18:17:37 <ndm> its not too bad
18:17:59 <SamB_XP> oh, well, yeah. okay. so they just don't let you download stuff for free...
18:18:23 <SamB_XP> unless you are on a subscribing LAN, of course
18:19:16 <Toxaris> good old   vpn on - download paper - vpn off   workflow
18:19:20 <ndm> i think everyone should put up their papers, and a bibtex entry, for everything
18:19:27 <SamB_XP> huh
18:19:27 <ndm> on their website
18:19:31 <SamB_XP> I didn't know I spoke spanish
18:20:02 <SamB_XP> but I'm quoted speeking spanish here: http://www.haskell.org/haskellwiki/HWN/es/2006-10-19
18:20:03 <lambdabot> Title: HWN/es/2006-10-19 - HaskellWiki
18:20:46 <Nafai> Wow my brain is hurting
18:21:53 <lament>     * O(n^2) es mejor que O(sin-cabello)
18:22:09 <lament> what did you actually say?
18:22:24 <SamB_XP> @quote O(n^2)
18:22:24 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
18:22:29 <ricky_clarkson> @babelfish es en sin cabello
18:22:29 <lambdabot> Unknown command, try @list
18:22:31 <SamB_XP> @quote O(n\^2)
18:22:31 <lambdabot> No quotes match. Take a stress pill and think things over.
18:22:39 <lament> @quote SamB
18:22:39 <lambdabot> SamB says: Because sliced bread gives horribly uninformative error messages?
18:22:52 <ricky_clarkson> @babel es en sin cabello
18:22:52 <lambdabot>   without hair
18:22:54 <lament> i don't understand what the joke was
18:23:03 <Olathe> Sliced bread is horribly mutable.
18:23:05 <lament> sin cabello just means hairless
18:23:14 <mar77a> @quote perl
18:23:14 <lambdabot> emu says:  people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference
18:23:15 <Olathe> Monadic sliced bread is much better.
18:23:20 <lament> @quote hair
18:23:20 <lambdabot> SamB says: O(n^2) is better than O(hair-gone)
18:23:23 <lament> aha!
18:23:34 <mar77a> @quote zeppelin
18:23:34 <lambdabot> No quotes match. That's something I cannot allow to happen.
18:23:40 <mar77a> @quote floyd
18:23:40 <lambdabot> No quotes match. The more you drive -- the dumber you get.
18:23:41 <mar77a> :(
18:23:50 <SamB_XP> ah! now I get it
18:24:07 <ivanm> SamB_XP: why did you bring hair into it?
18:24:21 <SamB_XP> I must have been saying that using an O(n^2) algorithm is better than pulling out your hair trying to do better
18:24:56 <ricky_clarkson> It's a bit strange to quote a translated version without saying so.
18:24:59 <ivanm> ahhh
18:25:13 <ivanm> ricky_clarkson: from the looks of things, they translated the entire HWN
18:25:14 <ricky_clarkson> Ah, it does say so, last line.
18:25:53 <ricky_clarkson> "This is an article translated from its original English version."
18:26:25 <ivanm> so the HWN is once again becoming the Haskell "released whenever dons feels like it" News, is it? :p
18:26:28 <lament> @quote ricky
18:26:28 <lambdabot> No quotes match. stty: unknown mode: doofus
18:26:38 <thoughtpolice> dons: cool ehc post. i was wondering when ehc would post info over the structure :)
18:26:41 <ivanm> since I don't recall reading one in the past few weeks...
18:28:52 <SamB_XP> hmm. why am I being used as test data?
18:29:01 <SamB_XP> http://www.haskell.org/haskellwiki/Timing_computation_in_cycles
18:29:03 <lambdabot> Title: Timing computation in cycles - HaskellWiki
18:29:52 <dons> thoughtpolice: i'd like to see a release too :)
18:31:09 <thoughtpolice> dons: isn't one of the goals to be a more approachable compiler for those interested in the topic? (i remember reading something like that when I first saw it)
18:31:36 <dons> yes, iirc
18:33:18 <thoughtpolice> dons: from looking at Atze's thesis, it seems probable: http://www.cs.uu.nl/wiki/bin/view/Ehc/SteppingThroughHaskell
18:35:55 <RyanT5000> is there any description/report on the haskell memory model? i'm looking for something that describes the layout of the heap, etc., as comprehensively as possible
18:38:38 <LoganCapaldo> ghc source code? <g>
18:38:58 <RyanT5000> well, i realize *that*, lol
18:39:12 <RyanT5000> and i'm sure i'll look at it at some point
18:39:21 <RyanT5000> but i was hoping there was something that would be more of an... illustration
18:39:56 * ivanm pulls out pen and paper and draws a heap for RyanT5000 
18:40:12 <ivanm> here's your illustration ;-)
18:40:14 <SamB_XP> there is one or more outdated papers on the subject
18:40:32 <RyanT5000> hm... so i guess reverse engineering it is, then
18:40:46 <RyanT5000> i'm thinking of starting the "serialize arbitrary closures" project i've mentioned in here before
18:40:51 <RyanT5000> i'll have some time next semester
18:59:24 <Nafai> So close and my head hurts :/
19:09:08 <Brian`> hi, what's good parsec tutorials on the web?
19:09:11 <Brian`> any recommendations?
19:09:21 <Brian`> i'm a beginner by the way
19:09:36 <gwern> Brian`: I myself was looking earlier; I didn't find any
19:10:00 <gwern> I think our best bet is to find one of the 'monadic parsing' papers and understand it and then figure out how to work with parsec
19:12:38 <Saizan> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html <-- this documentation is a bit outdated but it's almost a tutorial
19:15:42 <chessguy_> any mac users in here?
19:19:27 <njbartlett> chessguy: I'm a mac user
19:19:49 <goalieca> moi too
19:20:04 <chessguy> i'm thinking about breaking down and picking up a mac with leopard
19:21:03 <goalieca> questions? I don't use leopard yet.
19:21:35 <chessguy> how hard is it to find mac apps?
19:22:03 <Zao> Were the leopard ghc build issues fixed yet?
19:23:00 <sorear> anyone know anything about a Mark Zander?
19:24:08 <davidL> chessguy: what kinds of mac apps?
19:24:21 <chessguy> in general.
19:25:21 <njbartlett> There are plenty of Mac apps. They do tend to be Mac-only though.
19:26:00 <chessguy> even open-source apps? do they usually have mac binaries?
19:26:01 <davidL> and some of them you have to pay for (textmate for example)
19:26:38 <mar77a> hey haskellians
19:26:42 <mar77a> bit off topic
19:27:01 <mar77a> http://img231.imageshack.us/img231/1263/rfc35kg6.jpg can someone refresh me on exponential properties
19:27:12 <goalieca> chessguy, some of the best apps are mac only
19:27:28 <goalieca> as far as open source goes.. it is pretty easy but not linux easy yet
19:27:33 <davidL> I used to have a list of amazing apps that were only available on mac, I seem to have misplaced it
19:27:40 <goalieca> kde4 libs are going to be built for mac. i am looking forward to that
19:27:45 <goalieca> but gtk2 isn't native yet
19:27:50 <chessguy> davidL, freeware apps?
19:27:53 <P_D> that's the 1/6th power of a matrix?
19:27:53 <goalieca> the x11 for mac os x is awful
19:28:00 <davidL> chessguy: some were, yes
19:29:02 <wli> P_D: Diagonalize and take 1/6 powers of eigenvalues. If it's not diagonalizable NFI.
19:29:28 <goalieca> chessguy, omnigraffle, keynote are two awesome mac only apps
19:29:34 <davidL> ahh yeah one of them was omni-something
19:29:36 <davidL> useful for outlining
19:29:49 <P_D> I was asking the guy who already left
19:30:03 <mokus> omnioutliner
19:30:11 <davidL> yes, that's the one
19:30:34 <mokus> very simple app, but very well-done
19:30:38 <chessguy> i'm watching http://www.apple.com/macosx/guidedtour/large.html and it's pretty interestin
19:30:38 <chessguy> g
19:30:54 <lambdabot> Title: Apple - Mac OS X Leopard - Guided Tour - Large
19:35:05 <chessguy> wheeee
19:35:13 <allbery_b> yowza
19:35:18 <monochrom> cheese
19:36:58 <chessguy> i'm getting an iphone for Christmas, so i'm thinking it'll be really nice to have a mac to go with it
19:37:08 <FMota> milk?
19:38:43 <byorgey> cookies
19:46:15 <chessguy> i must say, leopard looks impressive
20:02:37 --- mode: irc.freenode.net set +o ChanServ
20:10:13 <mwc> http://www.cs.uu.nl/wiki/bin/view/Ehc/TheStructureOfTheEssentialHaskellCompiler
20:10:13 <lambdabot> http://tinyurl.com/2vjhxg
20:10:14 <mwc> any relation to The Djikstra?
20:10:26 <bos> anyone coming to PADL/POPL in january?
20:10:47 <Nafai> Where is <$> defined?
20:10:47 <ddarius> @index (<$>)
20:10:47 <lambdabot> bzzt
20:10:47 <dons> ?hoogle <$>
20:10:47 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
20:10:48 <Nafai> dons: Trying to understand your example on reddit :)
20:10:48 <ddarius> hoogle is the next thing to go for if @index doesn't work (or just use hoogle in the first place)
20:10:49 <ricky_clarkson> I think when he mentioned <$>, he just meant $.
20:10:57 <ddarius> @src ($)
20:10:57 <lambdabot> f $ x = f x
20:11:01 <ddarius> @index ($)
20:11:01 <lambdabot> Prelude
20:11:09 * ricky_clarkson forgets where that comment was.
20:11:09 <Nafai> Right, I understand $
20:12:28 <dons> :t map toUpper <$> getContents
20:12:29 <lambdabot> IO [Char]
20:12:40 <dons> :t map toUpper <$> return "foo"
20:12:41 <lambdabot> forall (f :: * -> *). (Monad f, Functor f) => f [Char]
20:12:49 <dons> > map toUpper <$> return "foo" :: Maybe [Char]
20:12:50 <lambdabot>  Just "FOO"
20:13:01 <dons> > map toUpper <$> fail "oh noes" :: Either String [Char]
20:13:01 <lambdabot>  Left "oh noes"
20:13:20 <dons> > map toUpper <$> reture "quite so, old chap" :: Either String [Char]
20:13:20 <lambdabot>   Not in scope: `reture'
20:13:25 <dons> > map toUpper <$> return "quite so, old chap" :: Either String [Char]
20:13:25 <lambdabot>  Right "QUITE SO, OLD CHAP"
20:13:46 <yaru> am I offline or something?join #haskell
20:13:47 <ricky_clarkson> :t <$> return
20:13:48 <lambdabot> parse error on input `<$>'
20:14:19 <shachaf> ricky_clarkson: (<$>) is infix fmap.
20:14:29 <shachaf> @ty fmap return
20:14:29 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
20:14:57 <shachaf> @ty (<$> return) -- Or this.
20:14:58 <lambdabot> forall b a (m :: * -> *). (Monad m) => (m a -> b) -> a -> b
20:15:14 <ricky_clarkson> > toUpper <$> "hi"
20:17:29 <lambdabot>  "HI"
20:17:35 <ricky_clarkson> Nice.
20:17:37 <dons> i'm still impressed that (<$>) forever (!)  is type correct :)
20:18:34 <shachaf> > let (.) = fmap in toUpper . "hi"
20:18:34 <lambdabot>  "HI"
20:20:13 <shachaf> @ty let forever x = x >> forever x in (<$>) forever (!!)
20:20:13 <lambdabot> forall b a. [a] -> Int -> b
20:20:24 <ricky_clarkson> Can I make up operator names?
20:20:28 <Nafai> ricky_clarkson: Just enclose them in ( ), I think
20:20:33 <ricky_clarkson> > let (of)=(<$>) in toUpper of "wow"
20:20:33 <lambdabot>  Parse error at "of)=(..." (column 6)
20:20:34 <Nafai> I could be wrong :)
20:20:34 <shachaf> ricky_clarkson: No, they have to use the operator characters.
20:20:35 <shachaf> ricky_clarkson: Or used with ``.
20:20:35 <Nafai> Okay, I was wrong
20:20:35 <dons> > let forever x = x >> forever x in (<$>) forever (!!) [1..10] 2
20:20:36 <dons> hehe
20:20:36 <lambdabot> Terminated
20:20:37 <shachaf> > let of = fmap in toUpper `of` "wow"
20:20:37 <lambdabot>  Parse error at "of" (column 5)
20:20:37 <ricky_clarkson> > let ($$)=(<$>) in toUpper $$ "wow"
20:20:38 <shachaf> Oops.
20:20:38 <lambdabot>  "WOW"
20:20:56 <shachaf> > let off = fmap in toUpper `off` "wow"
20:20:56 <lambdabot>  "WOW"
20:20:58 <ricky_clarkson> I don't know why, but $$ seems nicer than <$>.  Is there some meaning behind <$>?
20:22:29 <dons> like $ but more >>-ish ?
20:22:49 <shachaf> ricky_clarkson: It's like $, only in a Functor. :-)
20:22:53 <shachaf> ricky_clarkson: It works with (<*>).
21:28:45 --- topic: '["The Haskell programming language","math + romance + language == haskell","http://haskell.org ","http://www.jobs-in-fp.org/","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]'
21:28:45 --- topic: set by dons on [Wed Dec 05 09:39:49 2007]
21:28:45 --- names: list (clog tessier nolrai Mr_Awesome monochrom Vulpyne TSC arossato Oatschool hellige ski__ mokus rumbleca codemac balodja jbalint markb_ netx scook0 markb FMota Beelsebob dje kscaldef cjs ChilliX seafood_ tga marceau jimstutt StaZ|home Caelum lispy jleedev audreyt largos mwc obk_ TSC` mlh dcoutts nanothief ricky_clarkson tennin felzix lambdabot nnunley Niat_ cods_ tarrybon1 wang_ raxas_ lament DRMacIve1 aleator Hirvinen_ dionoea_ Zzompp Syzygy-_)
21:28:45 --- names: list (ray mornfall stevan__ nostrademons xerox BMeph glguy pgavin Nafai thedward xsdg Pupeno blackdog bos authentic ivanm goalieca RyanT5000 JBGood25 bgola` kfish shteou P_D davidL oal` dfeuer atp noclouds clanehin_ joed sek Alleria_ boyscared Tobsan sorear phb2 ddarius Philippa araujo qz njbartlett sioraiocht yallop Modius qrck halassocracy jethrotcs boegel ArmchairDeity sad0ur sclv_ smtms edsu Jedai Sizur mrsolo matveev jonafan borism gbeshers)
21:28:45 --- names: list (conal Cale xinming andyjgill augustss_ thepointer levitation[A] Pastorn c9s binary42 mathrick kpreid whoppix talmuth Sgeo lekro MyCatVerbs mattrepl vininim Averell Tychom a2n sclv mm_freak idnar patc_ sciolizer Khisanth felipe explicitjelly Igloo geocalc vinse Xgc Kattana drbean dblog proqesi bdash Meldon IvdSange1 psykon Alleria Eelis Baughn cognominal_ bgeron ulfdoz kartoo __suri yahooooo rue ragzter dmwit pejo sjanssen sutats Korollary)
21:28:45 --- names: list (dfranke cmeme goban_ daugustine petekaz glith pragma_ tessier_ kaol Aviaattori huamn saturday Boney calvins smack_ jcreigh resiak EvilTerran rdd agemo Mitar stick_figure thou_ rey_ Apocalisp nothingmuch jedbrown moconnor shachaf ari opqdonut1 Dreamer` Altair^ laz0r liyang m90_ benny zamez spoop kosmikus eyck lQg lokik_ fdr- sarehu pheaver gwern seafood shapr pitecus Japsu jurku omg911 yosemite Saizan Laney Lunchy matthew_- dibblego kolmodin_)
21:28:45 --- names: list (bobwhoops mux ksandstr Olathe sili Jiten_ ttt- Tigge tmoertel_away sphynx quicksilver l_a_m jmob thetallguy Liskni_si masta reffie mercury^ darrint kawfee ski_ koeien_ dgriffi3 pa-ching Spark bran_ chr1s henrik Thas wolverian ascender jimki jql SimonRC mightybyte eno GNU\caust1c matthew-_ LoganCapaldo m4thrick osfameron hefner Betovsky encryptio orbitz jeremiah MrDomino go_ Skyp dvekravy arjanoosting mrd og klugez nelhage Lemmih nornagon)
21:28:45 --- names: list (mattam kalven dufflebunk SamB magagr edwinb hpaste flux trez profmakx nipuL acura Choko noj integral Daveman jyasskin Shurique arguile cameron viklund opqdonut Vq^ qwr Deewiant mattiast sieni ibid cjay fritte jvoorhis gds caust1c_ SamB_XP m_stone exDM69 Shoragan jah Shimei tphyahoo-haskell pjd dylan flori nasloc__ Eidolos puusorsa andun trurl dons _frederi1_ caust1c` TwigEther kpk tuukkah desp ZsoL Zao newsham tessier__ thorkilnaur earthy)
21:28:45 --- names: list (dcoutts_ ToRA twifkak ichor_ @ChanServ)
21:44:40 <dons> Igloo: aja's .NET binding for haskell probably should get a rush on account creation :) (on community.h.o)
21:49:34 <Nafai> Is there something to concatMap like mapM is to map?
21:49:54 <dons> :t concat <$> mapM
21:50:44 * wolverian looks at lambdabot 
21:51:37 <Nafai> dons: Thanks
21:52:43 <lambdabot> Maximum users seen in #haskell: 401, currently: 370 (92.3%), active: 8 (2.2%)
21:52:47 <lambdabot> :)
21:52:58 <dons> the netsplits are going wacky
21:53:07 <dons> wow, not a happy bot
21:53:11 <dons> Main: caught (and ignoring) thread killed
21:53:15 <dons> url module failed in contextual handler: thread killed
21:53:21 <dons> type module failed in contextual handler: thread killed
21:53:22 <dons> ?bot
21:53:22 <lambdabot> :)
21:53:27 <dons> :t concat <$> mapM
21:53:27 <lambdabot>     Couldn't match expected type `[[a]]'
21:53:27 <lambdabot>            against inferred type `[a1] -> m [b]'
21:53:27 <lambdabot>     Probable cause: `mapM' is applied to too few arguments
21:53:31 <dons> but it soldiers on!
21:53:37 <dons> :t concat <$> mapM ?f ?x
21:53:37 <lambdabot> forall a a1 (f :: * -> *). (?f::a1 -> f [a], ?x::[a1], Monad f, Functor f) => f [a]
21:54:17 <RyanT5000> ah geez, implicit parameters
21:54:23 <RyanT5000> who thought that was a good idea?
21:54:35 <RyanT5000> i kid
21:54:39 <RyanT5000> but how does the scoping work on that?
21:54:51 <dons> they're cool for querying the type checker :)
21:54:57 <RyanT5000> true
21:55:02 <dons> > map ?f [1..10] -- find the type of 'f' that would make this work
21:55:03 <lambdabot>   Not in scope: `f'
21:55:06 <dons> :t map ?f [1..10] -- find the type of 'f' that would make this work
21:55:07 <lambdabot> forall a b. (?f::a -> b, Num a, Enum a) => [b]
21:55:14 <dons> a -> b, Num a, Enum a
21:55:54 <RyanT5000> so if i have two functions that each have implicit type (?x :: a) => something
21:56:24 <RyanT5000> how do i know x means the same thing in both cases?
21:56:42 <dmwit> Wait, ?-notation can be used outside of type queries? O_o
21:56:55 <dons> heh
21:57:11 <jcreigh> would GHC build stuff faster if I had a multi-core machine?
21:57:12 <RyanT5000> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
21:57:13 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
21:57:16 <ddarius> RyanT5000: It doesn't.
21:57:36 <ddarius> jcreigh: I believe so.
21:57:42 <dons> jcreigh: much faster
21:58:01 <dmwit> RyanT5000: thanks
21:58:09 <sjanssen> jcreigh: not by default
21:59:09 <ddarius> > let ?f = id in map ?f [1..10]
21:59:09 <lambdabot>  Parse error at "?f" (column 5)
21:59:14 <sjanssen> jcreigh: ie. GHC is single threaded.  Of course, if you've got a makefile you can use -j
21:59:32 <jcreigh> sjanssen: what if you've got Cabal/
21:59:46 <sjanssen> jcreigh: Cabal doesn't support parallel building yet
22:00:41 <dmwit> Implicit parameters seem closely related to the Reader monad.
22:01:44 <dmwit> > let newMap :: (?f :: a -> b); newMap = map ?f in let ?f = id in newMap [1..10]
22:01:44 <lambdabot>  Parse error at "?f" (column 16)
22:02:00 <dons> h98 only -- the safe and true
22:02:25 <dmwit> > let newMap :: (?f :: a -> b) => [a] -> [b]; newMap = map ?f in let ?f = id in newMap [1..10]
22:02:25 <lambdabot>  Parse error at "?f" (column 16)
22:02:36 <dmwit> hum
22:02:52 <RyanT5000> ddarius: ok, so if i call both of those functions from the same place, which binds ?x, doesn't it pass that same value to both callees?
22:03:22 <hpaste>  Nafai annotated "#59, In Progress" with "What's wrong?" at http://hpaste.org/4308#a7
22:04:13 <dmwit> Nafai: The "then" and "else" clauses need extra indentation.
22:04:26 <dmwit> This is a very surprising behavior of do-blocks, and I don't recall the reason for it.
22:04:37 * Nafai wonders why Emacs isn't doing that
22:05:01 <ddarius> RyanT5000: Yes.
22:05:18 <ddarius> dmwit: The reason is consistency.
22:05:18 <RyanT5000> ddarius: so how is that not a problem?
22:05:36 <ddarius> RyanT5000: Who said it wasn't a problem?
22:05:53 <Nafai> dmwit: Thanks, now if I could just get this to do what I want
22:06:02 <RyanT5000> ddarius: oh; no one, i guess; why does it exist?
22:06:09 <goalieca> dmwit, heh. and i just thought they didn't work in a do block
22:06:12 <goalieca> for real
22:06:13 * goalieca n00b
22:06:42 <ddarius> RyanT5000: Because people are sometimes lazy.
22:06:47 <glguy> if _ then _ else _ is one expression, each line of a do-block is a new expression
22:06:50 <RyanT5000> ddarius: i hate people, lol
22:07:03 <ddarius> RyanT5000: Sounds like the appropriate attitude.
22:07:11 <RyanT5000> :P
22:07:39 <Nafai> I want to call that function like this:
22:07:41 <Nafai> getAllCounts dict allStrings = concat <$> mapM (getCount dict) allStrings
22:08:06 <Nafai> So basically I end up with an IO [(Int, String)] with only those items with the Int > 50
22:08:13 <ddarius> RyanT5000: Implicit parameters are not a particularly popular extension.
22:08:33 <Nafai> But I don't quite get how to do that
22:08:49 <glguy> Nafai: what about filterM?
22:09:05 <Nafai> @index filterM
22:09:05 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:09:20 <RyanT5000> ddarius: they seem like they'd be ok if they were just declared somewhere
22:09:46 <RyanT5000> ddarius: like a typeclass - even though the class and instance scoping rules are *also* retarded
22:09:47 <glguy> :t filterM
22:09:48 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:10:13 <Nafai> glguy: Yeah, I could do that, but I was wanting to do it before I even packed the tuple together
22:10:20 <Nafai> Trying to make this program a bit faster
22:10:31 <dmwit> glguy: Ah, very nice, thanks for explaining if/then/else.
22:11:28 <glguy> ?src filterM
22:11:28 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:12:01 <glguy> Nafai: OK, how about    liftM catMabies
22:12:33 <Nafai> I don't even know what that does. :)
22:12:37 <glguy> ?type catMaybes
22:12:38 <lambdabot> forall a. [Maybe a] -> [a]
22:12:54 <glguy> > catMaybes [Just 1, Nothing, Just 2]
22:12:59 <lambdabot>  [1,2]
22:13:17 <dmwit> :t maybeToList
22:13:18 <lambdabot> forall a. Maybe a -> [a]
22:13:25 <dmwit> :t (>>= maybeToList)
22:13:25 <lambdabot> forall a. [Maybe a] -> [a]
22:13:29 <dmwit> interesting
22:13:33 <Nafai> the problem I'm having right now is my getCount function is messed up
22:13:47 <Nafai> IO Maybe (Int, String) doesn't seem to be a valid type to return :)
22:14:00 <dmwit> IO (Maybe (Int, String))
22:14:06 <dmwit> But even better would be
22:14:14 <dmwit> MonadPlus m => IO (m (Int, String))
22:14:44 <glguy> msum?
22:14:46 <glguy> :t msum
22:14:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
22:14:56 <glguy> hmm
22:14:59 <Nafai> @index MonadPlus
22:14:59 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:15:09 <glguy> not quite
22:15:28 <dmwit> glguy: Yes, quite, just use m = [] instead of m = Maybe. ;-)
22:15:37 <Nafai> I'm so close :(
22:15:56 <dmwit> msum = concat -- =P
22:16:00 <glguy> dmwit: right, but I just mean it doesn't do specifically what we were doing here
22:16:03 <glguy> :)
22:16:09 <dmwit> Oh, yeah, okay.
22:17:24 <Nafai> I'm having a hard time staying awake
22:17:32 <Nafai> And I just want to get this optimized
22:17:59 <ddarius> Nafai: Just go to sleep.  There are always more days and if not then this hardly matters.
22:18:18 <Nafai> ddarius: True.
22:18:28 <Nafai> This has taken me all night as it was
22:19:22 <ddarius> Nafai: It'd be a better use of your time to sleep and tackled it afresh when you're rested than to plod on with lessening acuity.
22:19:38 * Nafai nods
22:19:41 <Nafai> Good advice.
22:19:49 <Nafai> On that note, I should be off to bed!
23:19:56 <moconnor> @src maximum
23:19:57 <lambdabot> maximum [] = undefined
23:19:57 <lambdabot> maximum xs = foldl1 max xs
23:20:37 * quicksilver wonders what the first clause is for
23:20:41 <quicksilver> just clarity, I suppose
23:20:57 <goalieca> > maximum []
23:20:59 <oerjan> an error clause would make more sense
23:20:59 <lambdabot>  Exception: Prelude.maximum: empty list
23:22:36 <quicksilver> well my point is that foldl1 max [] would already be undefined
23:22:47 <quicksilver> so maximum = foldl1 max would be a sufficient definition
23:23:17 <moconnor> @src foldl1
23:23:17 <lambdabot> foldl1 f (x:xs) = foldl f x xs
23:23:17 <lambdabot> foldl1 _ []     = undefined
23:23:39 <oerjan> the Prelude says:
23:23:40 <oerjan> -- It is expected that compilers will recognize this and insert error
23:23:40 <oerjan> -- messages that are more appropriate to the context in which undefined
23:23:51 <oerjan> -- appears.
23:23:59 <moconnor> why is maximum not defined using foldl1'?
23:24:19 <oerjan> i.e. it is meant to imply that the error message should be specific to maximum rather than foldl1
23:25:11 <nornagon> ghc is so slow :(
23:25:26 <oerjan> moconnor: because the ' foldls were not defined in H98
23:25:49 <nornagon> @src foldl1'
23:25:49 <lambdabot> Source not found. It can only be attributed to human error.
23:28:56 <OceanSpray> so here's the thing
23:29:04 <OceanSpray> I'm trying to use CPS
23:29:22 <OceanSpray> and I'm trying to pass (>>=) into a function as the continuation
23:29:43 <OceanSpray> but I ALSO want the syntactic sugar of do notation.
23:29:56 <OceanSpray> Is that even possible?
23:31:00 <oerjan> you mean syntax as within the Cont monad, but you want to pass an explicit continuation?
23:31:13 <OceanSpray> no, the Cont monad is way too confusing.
23:31:33 <OceanSpray> I'm just making my functions in the a -> (b -> r) -> r style
23:32:00 <glguy> getCC x0          = callCC (\k -> let f x = k (x, f) in return (x0, f))
23:32:03 <glguy> this kind of thing?
23:32:26 <OceanSpray> I can use callCC without the Cont monad?
23:32:28 <oerjan> well if you want it to use >>= from another monad, then r needs to be m r at least
23:32:38 <OceanSpray> yeah, it's m r
23:33:00 <OceanSpray> specifically, ErrorT
23:33:02 <oerjan> so you want b -> m r
23:33:36 <oerjan> (>>= \b -> do ...)
23:33:36 <OceanSpray> that too, yes.
23:33:48 <OceanSpray> hm
23:33:57 <oerjan> or flip (>>=) $ \b -> do ...
23:34:10 <OceanSpray> :t flip
23:34:12 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:34:23 <OceanSpray> huh, that's weird.
23:34:29 <oerjan> oh wait
23:35:04 <oerjan> that would be m b -> m r
23:35:17 <OceanSpray> that's ok.
23:35:44 <oerjan> for b -> m r, you actually want just the \b -> do ... part
23:36:15 <oerjan> i.e. the use of >>= is baked into the CPS
23:37:45 <OceanSpray> 'baked into'?
23:38:06 <dons> ?src callCC
23:38:06 <lambdabot> Source not found. That's something I cannot allow to happen.
23:38:08 <oerjan> maybe a norvagism there :)
23:38:25 <OceanSpray> lol
23:40:14 <OceanSpray> function calls...
23:40:49 <OceanSpray> With Haskell's layout thingamajig, can I do (f a <newline> b)?
23:41:08 <OceanSpray> or would that be interpreted as calling b?
23:41:08 <oerjan> you may have to indent the b sometimes
23:41:29 <oerjan> if the f is lined up in some block (do, of, where, let)
23:41:29 <OceanSpray> f a
23:41:30 <OceanSpray>   b
23:41:33 <OceanSpray> would be alright?
23:41:34 <dons> that's fine
23:41:36 <oerjan> yep
23:41:48 <dons> you see that used when f == .
23:42:45 <dons> main = print $
23:42:45 <dons>     reverse
23:42:45 <dons>   . map toUpper
23:42:46 <dons>   . filter (not.isSpace) =<< getContents
23:42:56 <oerjan> mostly it's only do blocks that trip you up, since the others don't start the lines with expressions
23:43:29 <tga> could anyone please explain what Maybe actually does?
23:43:40 <dons> tga, it signals compuations that fail
23:43:47 <dons> so instead of say, void *
23:43:49 <oerjan> @src Maybe
23:43:50 <lambdabot> data Maybe a = Nothing | Just a
23:43:52 <OceanSpray> what does $ do again?
23:43:54 <dons> or Null values in every type
23:43:58 <oerjan> @src $
23:43:59 <lambdabot> f $ x = f x
23:44:01 <sjanssen> OceanSpray: application
23:44:03 <dons> you return Nothing, and the code's type says it will return a failing value
23:44:15 <dons> its a ridiculously useful, simple idea.
23:44:24 <OceanSpray> also, who wrote the emacs Haskell module?
23:44:25 <tga> dons: so Nothing is part of Maybe?
23:44:38 <oerjan> tga: see the data above
23:44:38 <OceanSpray> its indentation scheme is freaking crazy.
23:44:41 <dons> tga, yes. the Maybe a type contains two possible values, Nothing, or Just a
23:44:56 <tga> @src Just
23:44:56 <lambdabot> Source not found. You speak an infinite deal of nothing
23:45:00 <dons> ?src Maybe
23:45:01 <lambdabot> data Maybe a = Nothing | Just a
23:45:07 <oerjan> OceanSpray: i hear one needs to toggle between possibilities
23:45:17 <dons> sum types like this are rare outside of type functional programming
23:45:19 <dons> for some odd reason
23:45:25 <dons> but they're ludicrously useful
23:45:26 <OceanSpray> it's wearing out my tab key.
23:45:38 * dons grumbles about JSON not supporting sum types
23:45:44 <kfish> hi OceanSpray
23:45:50 <dons> some "universal" data type .. hah!
23:45:50 <OceanSpray> yo
23:45:59 <tga> dons: so what's Just?
23:46:07 <OceanSpray> Just is a data contructor
23:46:08 <dons> tga, it is the 'tga' for a successful value
23:46:13 <OceanSpray> taking one argument, the data it contains.
23:46:25 <tga> I see
23:46:33 <dons> consider,
23:46:34 <dons> safeHead []     = Nothing
23:46:34 <dons> safeHead (x:xs) = Just x
23:46:41 <dons> a safe version of head that throws no exceptoins
23:46:43 <dons> versus
23:46:44 <dons> ?src head
23:46:44 <lambdabot> head (x:_) = x
23:46:44 <lambdabot> head []    = undefined
23:46:44 <OceanSpray> Nothing is also a data constructor, taking no arguments, constructing... big surprise... nothing.
23:46:47 <dons> which fails
23:46:55 <dons> here, safeHead :: [a] -> Maybe a
23:47:07 <dons> and now the caller is required to handle the failure case
23:47:30 <tga> alright, so Maybe just adds the possibility of returning Nothing to any return type
23:47:32 <dons> tga, its quite a useful tool to have in the kit
23:47:34 <dons> yep.
23:47:37 <tga> neat
23:47:45 <dons> a -> Maybe a, adds the possibility of Nothing
23:47:49 <dons> :t
23:47:51 <dons> :t Just
23:47:53 <lambdabot> forall a. a -> Maybe a
23:48:15 <dons> the fun can really start once you think of Maybe a as the monad for possibly failing computations
23:48:15 <glguy> ok, this time I'm staying!
23:48:33 <dons> > do return 1 ; return 2 ; fail [] ; return 4
23:48:34 <lambdabot>   add an instance declaration for (Show (t t1))
23:48:37 <glguy> yeah... or maybe just write them correctly the first time ...
23:48:37 <dons> > do return 1 ; return 2 ; fail [] ; return 4 :: Maybe Int
23:48:39 <lambdabot>  Nothing
23:48:42 <dons> > do return 1 ; return 2 ; return 4 :: Maybe Int
23:48:42 <tga> dons: I was looking at some functor stuff earlier.. how does fmap fit in with something like Maybe?
23:48:43 <lambdabot>  Just 4
23:48:47 <dons> it does
23:48:52 <dons> > fmap (+1) $ Just 2
23:48:53 <lambdabot>  Just 3
23:49:17 <dons> > fmap (+1) $ Nothing
23:49:18 <lambdabot>  Nothing
23:49:31 <dons> > map (fmap (+1)) [ Just 1, Just 3, Nothing, Just 4]
23:49:32 <lambdabot>  [Just 2,Just 4,Nothing,Just 5]
23:49:38 <glguy> > Just 1 <* Just 2
23:49:38 <lambdabot>  Just 1
23:49:39 <dons> > sequence $ map (fmap (+1)) [ Just 1, Just 3, Nothing, Just 4]
23:49:41 <lambdabot>  Nothing
23:49:44 <glguy> > Just 1 <* Nothing
23:49:45 <lambdabot>  Nothing
23:49:46 <dons> > sequence $ map (fmap (+1)) [ Just 1, Just 3, Just 4]
23:49:47 <lambdabot>  Just [2,4,5]
23:49:47 <tga> what's the difference between map and fmap here?
23:49:56 <dons> map here is fmap on the [a] type only, basically
23:50:03 <dons> so the inner fmap walks the Maybe a
23:50:05 <glguy> @quote fmap
23:50:06 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life; is much happier now
23:50:08 <dons> the outer map walks the [a]
23:50:15 <dons> glguy: heh
23:50:17 <dons> nice quote
23:50:28 <sioraiocht> hahaha
23:50:28 <oerjan> @quote polymorphic.scare
23:50:28 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
23:50:37 <dons> the Maybe a type should be taught in comp 1A, and be provided in every language
23:50:44 <dons> its so foundational -- the concept of failure.
23:50:47 <dons> yet supported so badly.
23:50:59 <tga> failure is not implemented, heh
23:51:05 <glguy> failure is not an option
23:51:06 <lament> null pointers do the same job
23:51:08 <dons> its implemented badly :)
23:51:10 <dons> glguy: hah
23:51:17 <OceanSpray> :t$
23:51:18 <glguy> lament: null pointer dereferencing?
23:51:22 <OceanSpray> :t $
23:51:22 <dons> lament: though its not in the type
23:51:22 <lambdabot> parse error on input `$'
23:51:30 <dons> and you're not forced to check
23:51:35 <OceanSpray> hm
23:51:42 <tga> euh.. why can't a regular map walk the Maybe a?
23:51:43 <glguy> :t ($)
23:51:43 <lambdabot> forall a b. (a -> b) -> a -> b
23:51:48 <dons> :t map
23:51:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:51:49 <glguy> :t map
23:51:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:51:50 <sioraiocht> dons: exception handling?
23:51:52 <lament> :t fromMaybe
23:51:53 <lambdabot> forall a. a -> Maybe a -> a
23:52:04 <OceanSpray> so let me get this straight:
23:52:08 <OceanSpray> f $ a b
23:52:11 <OceanSpray> is the same as
23:52:14 <dons> yep
23:52:15 <OceanSpray> f (a b) ?
23:52:17 <glguy> ?djinn (a -> b) -> a -> b
23:52:17 <dons> nope
23:52:17 <lambdabot> f a = a
23:52:22 <lament> > fromMaybe Nothing
23:52:22 <lambdabot>  Add a type signature
23:52:24 <OceanSpray> wha
23:52:24 <dons> yep.
23:52:43 <lament> > fromMaybe (Nothing :: Maybe String)
23:52:43 <dons> > (+1) $ (+2) 3
23:52:44 <lambdabot>  6
23:52:44 <lambdabot>  <Maybe (Maybe [Char]) -> Maybe [Char]>
23:52:46 <OceanSpray> dons, I'm getting confused over here
23:52:48 <dons> > (+1) ((+2) 3)
23:52:49 <lambdabot>  6
23:52:53 <TSC> OceanSpray: What you said was right
23:52:56 <dons> > (+1) (+2) $ 3 -- no oh
23:52:56 <lambdabot>   add an instance declaration for (Num (a -> a))
23:52:56 <OceanSpray> oh ok
23:53:01 <TSC> f $ a b c === f (a b c)
23:53:22 <lament> oh, that's the wrong fromMaybe
23:53:52 <lament> > fromJust (Nothing :: Maybe String)
23:53:55 <lambdabot>  Exception: Maybe.fromJust: Nothing
23:53:59 <glguy> > join (Just (Just 42))
23:54:00 <lambdabot>  Just 42
23:54:02 <lament> null pointer exception!
23:54:23 <glguy> fail
23:56:22 <oerjan> tga: in a previous version of haskell, fmap was called map, but they changed map to work only on lists
23:57:25 <tga> that's polymorphically confusing
23:57:46 <oerjan> sometimes it is useful to have a less ambiguous version of functions
23:58:29 <lament> listMap
23:59:13 <oerjan> fmap is a rather horrible case, there are at least a handful different names for it
23:59:36 <oerjan> map, (.), fmap, (<$>), liftA, liftM
23:59:52 <oerjan> most with slightly different types
