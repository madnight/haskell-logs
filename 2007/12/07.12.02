00:00:00 <dmwit> He leaves out unsafe*.
00:00:01 <conal> flux: that's what IO *used* to be, but not anymore.
00:00:03 <dmwit> Is that so bad?
00:00:09 <conal> now IO is way more than "I/O"
00:00:18 <flux> what is IO more?
00:00:32 <conal> arbitrary access to the physical universe
00:00:35 <dmwit> IORef, FFI, file system access...
00:00:51 <conal> exactly
00:00:51 <flux> even with mutable variables, I think the description still holds true - even the behavior under the hood is more optimized
00:00:54 <xpika> im trying to use this style http://www.xyz1024.com/xmonad.PNG
00:01:10 <flux> "even if the"
00:01:49 <conal> flux: how can any type whose meaning is arbitrary access to the universe have tractable semantics and so admit useful reasoning?
00:02:09 <conal> which is why i like functional programming.
00:02:28 <conal> xpika: cool.
00:02:49 <conal> xpika: still, it's a shame, because the IO type fails to capture the near-purity of the discipline.
00:03:00 <xpika> writing the IO shell is the hard part
00:03:12 <hpaste>  Porges pasted "Fun little snippets" at http://hpaste.org/4215
00:03:55 <xpika> > when (1==1) (return 2)
00:03:57 <lambdabot>   add an instance declaration for (Show (m ()))
00:04:11 <conal> we have this great purely functional core, which admits powerful reasoning and is guaranteed safe.  and then we say that to do anything useful we have to add in IO, which had neither property.  and we mix the two together in a way that is not separable after the fact.
00:04:36 <flux> conal, well, maybe such issues are shadowed by IO: but can't you write such messy code in a functional way, then?
00:04:42 <Porges> IO is guaranteed safe
00:04:50 <flux> conal, if you have one big module that has everything
00:05:00 <conal> flux: sure.  but it's safe and the types delimit the semantics.
00:05:34 <flux> infact, can you not write an IO simulator in 100% Haskell98?-o
00:05:35 <oerjan> Porges: actually unless is in Control.Monad, but with arguments flipped
00:06:01 <flux> (if not, then I believe the argument ;))
00:06:03 <conal> flux: do you mean I/O or IO
00:06:16 <xpika> conal: is there a difference?
00:06:31 <Porges> oerjan: why is everything invented already :'(
00:06:35 <flux> conal, whatever the IO monad can do (without unsafePerformIO)
00:06:48 <flux> hm, maybe forkIO will be tricky to simulate
00:06:48 <conal> flux: then, i'm pretty sure you cannot.
00:06:50 <ddarius> conal: What if your combinators are just a "prefolded" interpreter on some pure model?
00:07:07 <conal> ddarius: which combinators?
00:07:32 <ddarius> conal: Some arbitrary set of combinators for doing something.  E.g. making UIs.
00:07:33 <BMeph> Porges: not everything.... ;)
00:07:44 <flux> conal, what do you think would be the first problem?
00:07:45 <conal> flux: because i don't know how to simulate the physical universe in pure haskell98.
00:08:12 <conal> ddarius: then you have simple semantics, not IO
00:08:19 <flux> inputs from the user would be provided to the function as an infinite stream of bytes, and output from the program would produce such a list
00:08:27 <conal> ddarius: which is what i do.  i call it functional.
00:08:32 <flux> inputs could even be timed
00:08:35 <ddarius> conal: But the combinators would have IO types.
00:08:45 <conal> flux: yes.  that's simple semantics.  it's I/O, not IO
00:08:54 <conal> ddarius: why?
00:09:00 <flux> how the time of day and file system content change would be parametrized
00:09:09 <BMeph> Just curious: do many other folks here find themselves flipping the argument order of "lookup"?
00:09:25 <conal> ddarius: my UI  combinators do not have IO type
00:09:37 <conal> nor my imaging, 3D or animation combinators, etc.
00:09:50 <oerjan> :t lookup
00:09:51 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:10:06 <Porges> :t Data.Map.lookup
00:10:07 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
00:10:09 <conal> ddarius: i don't know how they could have IO type and still have simple & useful properties.
00:10:29 <Porges> BMeph: i think of it like the membership operator
00:10:35 <dmwit> Porges: You can take the "do"s out of your fun little snippets. =)
00:10:48 <Porges> x `lookup` dict = x `member-of` dict
00:10:51 <dmwit> BMeph: Yes, I flip it all the time.
00:10:51 <xpika> I think a haskell spin would be cool. it would be like a haskell distro http://fedoraproject.org/wiki/CustomSpins
00:10:52 <lambdabot> Title: CustomSpins - Fedora Project Wiki
00:10:53 <Porges> dmwit: D:
00:11:20 <ddarius> conal: I was talking about a situation where you have what you get at the end of 'data Model = ...; fiddleModel :: Param -> Model -> Model; renderModel :: Model -> IO Foo', so you have (just) fiddleModel :: Param -> IO Foo -> IO Foo or some such essentially
00:11:30 <oerjan> Porges: yes, do is redundant when there is just one statement in it
00:11:36 <hpaste>  (anonymous) annotated "Fun little snippets" with "argh!" at http://hpaste.org/4215#a1
00:12:00 * conal reads & rereads ddarius's last
00:13:04 <conal> can anyone help me understand what ddarius is saying?
00:13:13 <ddarius> conal: Essentially the Model has been "fused" out.
00:13:54 <conal> ddarius: after composing, right?
00:14:19 <conal> but what's the IO *argument*, and what's the Foo output?
00:14:42 <conal> i've done a lot of functional graphics libs, and nothing of that shape.
00:14:44 <ddarius> conal: In some situations, you should be able to "prefuse" them and have the combinators directly do what they do.
00:14:45 <oerjan> fused, or confused.  that's the question.
00:15:09 <BMeph> Porges: I flip elem's arguments, too. It is more convenient to me, especially for partial application.
00:15:32 <conal> ddarius: the question for me is what is the (denotational) semantics of Model, including of its constructors.
00:15:50 <conal> ddarius: if you want to do fusion as a provably correct optimization, go for it.
00:15:54 <conal> but semantics first, please.
00:16:06 <ddarius> conal: The same as the semantics of the rendered model.
00:16:11 <conal> btw, i've implemented a compiler that does exactly this kind of fusion.
00:16:21 <conal> ddarius: you mean the semantics of IO?
00:16:23 <conal> or what?
00:16:26 <ddarius> Particularly, if "renderModel = foldModel primA primB"
00:16:46 <conal> ddarius: i don't mean the semantics of rendering.  i mean of the model.
00:17:22 <conal> or, if rendering, then a denotational model of rendering, e.g., Model -> Image
00:17:27 <conal> but not IO
00:17:58 <conal> because Image a nice simple model with nice properties.
00:18:16 <conal> (... Image *has* a ...)
00:20:54 <conal> for instance, without a semantics for the model and a semantics for rendering, how can we claim that the render function is correct?
00:21:56 <conal> we're not just C hacking in Haskell, are we?
00:23:11 <ddarius> This line of discussion was mostly in response to the (out of context) statement: [01:53] <conal> and no for anything that exposes IO or depends on IO for its semantics.
00:24:47 <xpika> conal: I believe we are asm hacking in everyting.
00:26:12 <sclv> ?src Double
00:26:12 <lambdabot> data Double = D# Double#
00:26:28 <ddarius> Now close your eyes and walk away.
00:28:44 <conal> urg.  it's half past midnight here.  catch you later, #haskell-friends.
00:30:26 <BMeph> Yikes, so it is. Good night, all. :)
00:32:04 <omg911> weak... it's half pass 3 here :p
00:32:43 <Porges> agh
00:33:27 <oerjan> Porges: relax and take a deep breath :)
00:33:35 <Porges> I've got a function (MArray a t IO) => [t] -> IO [t]
00:33:54 <Porges> so 'a' needs to be IOArray or STArray
00:34:11 <oerjan> not showing up in the type?
00:34:21 <Porges> well, i'm not sure what I'm meant to add
00:34:24 <ddarius> I think your choices are IOArray and IOUArray.
00:35:03 <ddarius> Porges: In the body of the function you need to make sure there is an explicit array type being used.
00:35:36 <Porges> well I didn't want it at the call site
00:35:52 <Porges> since the callee will only have (listShuffle [0..100])
00:36:30 <Porges> if I enable FlexibleContexts I can put the type as (MArray IOArray t IO) => [t] -> IO [t]
00:36:39 <Porges> but then it says it cannot deduce (MArray a t IO)
00:36:45 <Porges> which makes sense...
00:37:11 <ddarius> Porges: In the body you need to make sure that everything (relevant) is explicitly using an IOArray.
00:37:36 <ddarius> Otherwise there are multiple array types that could be used and no way to determine which.
00:38:05 <ddarius> All you should need to do is add a well-placed type annotation.
00:38:22 <Porges> okay
00:38:30 <Porges> I was hoping that it would be usable from IO or ST
00:39:08 <ddarius> You want the type to be [t] -> m [t] with m constrained in some appropriate way?  Otherwise it doesn't matter which array type is used internally.
00:39:30 <oerjan> hm... you _might_ do that but you'll need a new class i think
00:39:37 <ddarius> @wiki Introduction/Direct Translation
00:39:37 <lambdabot> http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
00:40:09 <Porges> d'oh
00:40:14 <Porges> it might have been the IO [t]
00:41:01 <ddarius> Anyway, I too should head to bed.
00:41:03 <oerjan> Porges: actually you are going to have trouble even replacing IO by m
00:41:04 <ddarius> @time
00:41:05 <lambdabot> Local time for ddarius is Sun Dec  2 02:40:59
00:41:24 <oerjan> because you still cannot determine the array type from m
00:41:37 <Porges> well I can, but not the compiler
00:41:40 <Porges> :D
00:42:40 <Porges> there's no way to say (if MArray a t IO, a == IOArray ?)
00:43:10 <oerjan> er, IOArray cannot be used from ST can it?
00:43:16 <Porges> no
00:44:33 <oerjan> if you really want to use IO+IOArray and ST+STArray then you are going to need a new class i think
00:44:56 <oerjan> because MArray does not give enough restrictions to get the array from the monad
00:45:45 <Porges> :r
00:45:49 <Porges> oops
00:46:18 <oerjan> heh, i though that was a disgruntled smiley
00:46:50 <Porges> now that I'm trying to add an explicit annotation I can't figure it out either
00:47:10 <oerjan> paste?
00:47:11 <hpaste>  Porges pasted "Having type problems" at http://hpaste.org/4216
00:47:41 <Porges> I thought I could stick "IO (IOArray Int a)" on the end of the newListArray line
00:48:02 <Porges> but then I get "inferred type is less polymorphic than expected"
00:48:10 <oerjan> oh right
00:48:24 <oerjan> to use a you need the scoped type variable extension
00:48:32 <oerjan> and a declaration for the whole function
00:49:29 <Porges> maybe i'll just put the IOArray restriction on the inner function
00:49:49 <oerjan> what inner function?
00:49:54 <Porges> shuffle?
00:50:11 <oerjan> oh right, that should work
00:50:35 <Porges> ... and it compiles first try
00:51:38 <Porges> except for the bounds bug :P
00:51:58 <hpaste>  Porges annotated "Having type problems" with "fixed" at http://hpaste.org/4216#a1
00:53:28 <jsnx> i have a chinese character in a URI, and Network.URI.parseURI won't parse the URI with the character in it -- what should i do?
00:53:51 <jsnx> if i replace the character with random alphabet letters, the URI parses fine
00:59:43 <jsnx> okay, it looks like I have to escape the Chinese character, and pack it into the URI string
00:59:55 <jsnx> > :t escapeURIChar
00:59:56 <lambdabot>   parse error on input `:'
01:00:03 <jsnx> :t escapeURIChar
01:00:10 <jsnx> @t escapeURIChar
01:00:10 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:00:11 <lambdabot> Not in scope: `escapeURIChar'
01:00:25 <jsnx> no way to show you
01:00:26 <oerjan> :t Network.URI.escapeURIChar
01:00:27 <lambdabot> (Char -> Bool) -> Char -> String
01:05:19 <Porges> now to ensure it's linear
01:05:45 <oerjan> i guess isAllowedInURI is a suitable Char -> Bool for the use
01:06:22 <oerjan> er, i think i mean isUnescapedInURI
01:06:58 <jsnx> oerjan: if you know it's a chinese character, `(const False)` is okay, too :)
01:07:37 <oerjan> jsnx: yeah, but in general wouldn't you use escapeURIString on the entire string?
01:09:10 <jsnx> oerjan: or, i could just use Network.HTTP.urlEncode, which seems to be the right thing...
01:10:05 <oerjan> decisions, decisions
01:12:40 <Porges> does quickCheck do timing?
01:13:03 <sjanssen> no
01:13:20 <Porges> it would be cool if it could do a whole bunch of examples and then perform regression
01:13:39 <jsnx> well, turns out you are right.
01:13:50 <jsnx> urlEncode makes the string unparsable
01:13:53 <Porges> -- Caution! Algorithm is exponential.
01:13:58 <oerjan> impossible!
01:14:54 <oerjan> it would have been more impressive if i wasn't just guessing
01:15:28 <jsnx> oerjan: actually, it's even more impressive that you were guessing
01:18:01 <Porges> hrm
01:18:27 <oerjan> Porges: System.CPUTime
01:18:28 <xpika> ghci told me urk!
01:18:30 <oerjan> perhaps
01:18:56 <Porges> yeah I've done the data, i just thought it would be cool if QuickCheck did it also :)
01:20:42 <Porges> althought if I try to compile it, I get linker errors
01:21:01 <oerjan> first guess: add --make
01:21:16 <oerjan> (that's frequently it)
01:21:21 <Porges> hrm
01:21:26 <Porges> what difference does that make?
01:21:31 <Porges> (it worked)
01:21:46 <oerjan> it looks up dependencies and packages used
01:27:20 <Porges> doesn't look O(n) :|
01:30:07 <hpaste>  (anonymous) pasted "Horrendously inefficient primes definition" at http://hpaste.org/4217
01:31:58 <Porges> although it does shuffle 100,000 entries in < 0.2 seconds
01:32:42 <oerjan> there could be initial overhead, or garbage collection disturbances, all sorts of things?
01:33:38 <oerjan> oh and the dreaded cache
01:33:46 <wli> > let primes :: [Integer] ; primes = 2 : 3 : 5 : [p | p <- [7, 9 ..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q * q < p) primes)] in take 10 primes
01:33:50 <lambdabot>  [2,3,5,7,9,11,13,17,19,23]
01:34:28 * oerjan intuitively blames the cache
01:35:17 <oerjan> knuth shuffling pretty obviously will swap all over the place, which ruins it
01:36:02 <Porges> I guess so
01:36:31 <Porges> I just wanted a pretty graph
01:36:34 <Porges> maybe I'll zoom in
01:36:36 <Porges> >:D
01:37:36 <Porges> thx oerjan
01:37:39 <Porges> night time
01:40:10 <christine_c> does somebody here knows prolog?
01:40:38 <oerjan> just barely
01:41:13 <wli> Yes.
01:41:47 <christine_c> i thank you, i found you.....
01:42:25 <christine_c> im new to prolog and im soliciting ideas, i hope you people could help me, people in prolog were very busy
01:43:22 <christine_c> and i respect them for that
01:43:58 <dmwit> Hello, and welcome to Backhanded Compliments 101!  christine_c presiding
01:44:00 <dmwit> ;-)
01:44:14 <christine_c> hehehe
01:46:11 <christine_c> long live dmwit ;-)
01:51:17 <mgsloan> heh, I just implemented a quickie and wrong lambda calculus in 11 lines
01:51:24 <mgsloan> I know there's no alpha reduction
01:51:31 <mgsloan> and it might not work even beyond that
01:52:16 <mgsloan> but basic examples work so far
02:02:14 <dmwit> Well, hell, I can implement a wrong lambda calculus in less than 11 lines. ;-)
02:02:27 <dmwit> But no, seriously, nice work!  I bet it's fun.
02:03:51 <dmwit> eval x = print "Hello world!" -- aggressively optimize everybody's first example program
02:04:00 <ivanm> heh
02:04:20 <dons> ?users
02:04:20 <lambdabot> Maximum users seen in #haskell: 414, currently: 393 (94.9%), active: 7 (1.8%)
02:05:23 <Heffalump> oh, it lost the stats?
02:06:14 <dons> musta gone down for some reason, yeah.
02:07:26 <ari> Wate wut
02:07:40 <ari> I know what alpha equivalence and beta reduction are, but alpha reduction?
02:07:51 <Plareplane> * lambdabot has quit (Remote closed the connection)
02:07:55 <Plareplane> that was 10 hours ago
02:08:08 <dons> mm.
02:12:36 <Mitar> Environment.hs-boot:5:0:ghc-6.8.1: panic! (the 'impossible' happened)
02:12:36 <Mitar>   (GHC version 6.8.1 for i386-apple-darwin):
02:12:36 <Mitar> 	newTyConEtadRhs main:Environment.EnvItem{tc r0}
02:12:59 <Mitar> it is written that i should report this ... but is this maybe just because of mine bad -boot file?
02:17:49 <Heffalump> ari: alpha reduction doesn't really make sense but it might be used to refer to alpha renaming
02:18:02 <Heffalump> for consistency with beta and eta reduction
02:25:11 <mgsloan> dmwit - yeah, it was rather fun
02:25:32 <mgsloan> yeah, I may have gotten the name wrong
02:26:02 <mgsloan> I am rather proud of it, since I did it from memory, after just reading the chapter in TAPL which introduces lambda calc
02:26:24 <mgsloan> actually, I read the chap yesterday
02:28:22 <wli> I wish I knew more of the programming language theory of logic and imperative languages.
02:29:08 <wli> Then again, given how little progress I've made on the functional front vs. how well-developed that is, it probably just doesn't matter.
02:35:12 <hpaste>  Mitar pasted "mutually recursive modules" at http://hpaste.org/4218
02:35:29 <Mitar> can anybody show me how can i compile this with GHC?
02:38:54 <sjanssen> Mitar: did you read about hs-boot in GHC's manual?
02:39:15 <Mitar> yes ... but the problem is that i do not know what to puy there
02:39:58 <hpaste>  Mitar annotated "mutually recursive modules" with "boot" at http://hpaste.org/4218#a1
02:40:08 <Mitar> if i do this, it does not work
02:40:28 <sjanssen> Mitar: you should have the full defn. of the A data type there
02:40:35 <Mitar> but I cannot specify constructors for A because I have to import B then ...
02:40:39 <Mitar> and then I get a loop
02:40:50 <sjanssen> oh, right :)
02:41:39 <hpaste>  Mitar annotated "mutually recursive modules" with "does not work" at http://hpaste.org/4218#a2
02:42:20 <sjanssen> perhaps you need hs-boot files for both A and B?
02:42:29 <Mitar> but they are the same :-)
02:42:49 <Mitar> in both cases i need to import something in boot file, so that I can use Show
02:43:58 <Heffalump> mitar: I think the .hs-boot file should have data A and instance Show A
02:43:59 <sjanssen> these modules won't compile anyway, correct?
02:44:06 <Heffalump> and you should only need one
02:44:18 <sjanssen> because the names of the constructors overlap
02:44:28 <Heffalump> also, remember you need to import {-# SOURCE #-} A in module B
02:45:21 <Mitar> sjanssen: i was trying to make an example
02:46:32 <Mitar> yes!!!
02:46:34 <Mitar> thank you
02:47:11 <hpaste>  Mitar annotated "mutually recursive modules" with "works" at http://hpaste.org/4218#a3
02:47:39 <Heffalump> the basic principle is that the .hs-boot file should be absolutely minimal
02:47:55 <Heffalump> just say *what* will be declared by the real .hs file, not *how* it does it
02:49:09 <mgsloan> eval (Data.Map.insert "fls" (Lambda 't' (Lambda 'f' (Ref "f"))) $ Data.Map.insert "tru" (Lambda 't' (Lambda 'f' (Ref "t"))) $ Data.Map.empty) (App (App (Ref "fls") (Ref "fls")) (Ref "tru"))
02:49:09 <mgsloan> tru
02:49:18 * mgsloan laughs maniacally
02:49:51 <mgsloan> though I'm not sure why it didn't evaluate tru further.. hm
02:53:52 <Mitar> and also only that what will be needed by the module where I SOURCE import it
02:55:43 <dikini> has anyone done a study of combinators and categories? particularly Y?
02:57:24 <mgsloan> I certainly haven't - I just learned Y yesterday.  I found Omega rather humorous, though (\x. x x) (\x. x x)
02:57:56 <int-e> @pl ap id id (ap id id)
02:57:59 <lambdabot> ap id id (ap id id)
02:57:59 <lambdabot> optimization suspended, use @pl-resume to continue.
02:58:33 <int-e> @pl \x -> x x
02:58:33 <lambdabot> join id
02:59:28 <mgsloan> @pl let apself x = x x in ap apself apself
02:59:28 <lambdabot> join id `ap` join id
02:59:42 <Heffalump> oh, @pl doesn't typecheck?
02:59:56 <int-e> no, @pl is purely rewrite rule based.
03:01:50 <sjanssen> with some questionable rules.  My favorite:
03:01:53 <sjanssen> @pl liftM
03:01:53 <lambdabot> fmap
03:03:35 <Heffalump> :-)
03:03:44 <Heffalump> @pl (2*)
03:03:44 <lambdabot> (2 *)
03:03:52 <Heffalump> @pl join (+)
03:03:52 <lambdabot> join (+)
03:03:54 <sjanssen> dons and I had an fmap vs. liftM disagreement, @pl helped me win :P
03:04:39 <int-e> @pl concat
03:04:40 <lambdabot> join
03:04:47 * desegnis cries: <$>, <$>, <$>!
03:05:18 <int-e> @index (<$>!)
03:05:18 <lambdabot> bzzt
03:05:19 <int-e> ;)
03:05:43 <desegnis> ...
03:06:13 <sjanssen> desegnis: don't you have a Haskell lexer built into your brain? ;)
03:06:51 <desegnis> sjanssen: Did I not catch something?
03:07:19 <sjanssen> desegnis: there is no <$>! operator
03:07:31 <sjanssen> ! is an operator character
03:07:34 <int-e> I'm fairly sure desegnis understood what I did.
03:07:46 <int-e> hmm. or maybe I'm just assuming :)
03:07:58 <Heffalump> I don't think <$>, is an operator either.
03:08:03 <desegnis> sjanssen: ! is a punctuation sign in most western languages.
03:08:27 <sjanssen> desegnis: yes, in Haskell its part of an operator
03:08:35 <desegnis> > let a <$>! b = a + b in 1 <$>! 2
03:08:36 <lambdabot>  3
03:08:44 <desegnis> fine
03:08:47 <int-e> Heffalump: , is not allowed in infix operators though
03:08:56 <Heffalump> even in the middle?
03:09:07 <int-e> yes
03:09:11 <Heffalump> fair enough
03:09:33 <desegnis> right :)
03:17:03 <hpaste>  wli pasted "building matrices from variables" at http://hpaste.org/4219
03:17:21 <wli> Could I get a quick sanity check on that?
03:18:56 <wli> (Suggestions for improvements welcome as well.)
03:19:28 <wli> I've been having massive trouble getting certain matrices formed and I think this would help.
03:38:47 <luqui> I would think...
03:39:31 <luqui> > let a <$>! b = b `seq` a <$> b in Maybe (const 4) <$>! Maybe undefined
03:39:33 <lambdabot>   Not in scope: data constructor `Maybe'
03:39:39 <luqui> > let a <$>! b = b `seq` a <$> b in Just (const 4) <$>! Just undefined
03:39:39 <lambdabot>  Couldn't match expected type `a -> b'
03:40:31 <luqui> that's what I get for trying to use applicative without knowing it...
03:40:51 <luqui> > let a <$>! b = b `seq` a <$> b in const 4 <$>! Just undefined
03:40:52 <lambdabot>  Just 4
03:41:04 <luqui> oh right...
03:42:06 <EvilTerran> WHNF!
03:42:24 <luqui> that looks funny as an explitive...
03:42:58 <EvilTerran> hehe
03:43:46 <int-e> wli, looks sane to me. I'd probably use  (i, term) <- zip [1..] labeledTerms  and replace  labeledTerms !! (i - 1)  by term.
03:43:59 <int-e> but that's a rather minor detail
03:45:53 <luqui> let a <$>! b = (\x -> seq x $ a x) <$> b
03:46:04 <luqui> > let a <$>! b = (\x -> seq x $ a x) <$> b in const 4 <$>! Just undefined
03:46:07 <lambdabot>  Undefined
03:48:02 <wli> int-e: done
03:49:11 <wli> Now to see if I can't get the equations formed this way.
03:50:39 <desegnis> luqui: I'd prefer <$!> though.
03:53:06 <opqdonut> i'd prefer $!!!
03:53:35 <desegnis> $!!!? What the $!?
03:53:47 <desegnis> :)
04:00:57 <Taejo> I prefer `make$$$inYourSpareTime`
04:05:46 <opqdonut> Taejo: wouldn't that be "make$$$inYourSpareTime a b = b `pseq` a b"
04:07:11 <sjanssen> why pseq rather than seq?
04:13:34 <Heffalump> 'lo
04:18:06 <jimstutt> @users
04:18:06 <lambdabot> Maximum users seen in #haskell: 414, currently: 390 (94.2%), active: 9 (2.3%)
05:01:05 <Taejo> what are seq and pseq?
05:02:47 <sjanssen> Taejo: they're functions used to force evaluation of values
05:02:52 <sjanssen> @type seq
05:02:53 <jimstutt> Taejo: iiuc (newb) seq invokes strict evaluation and I guess might be related to class Ord. pseq is a parallel version.
05:02:54 <lambdabot> forall a t. a -> t -> t
05:03:16 <sjanssen> jimstutt: pseq isn't parallel
05:03:30 <jimstutt> sjanssen: sorry
05:03:49 <sjanssen> pseq is the same as seq, except for weird GHC strictness stuff that I barely understand :)
05:04:13 <jimstutt> sjanssen: o good that's an encouraging relief
05:04:19 <sjanssen> jimstutt: no problem, it seems to be a common misconception lately.  par is the parallel evaluation combinator
05:04:19 <Taejo> so seq evaluates both args and returns the second?
05:04:34 <Taejo> and so does par?
05:04:37 <sjanssen> evaluates the first argument, then returns the second
05:05:09 <Taejo> sjanssen, can you give me an example where that makes a difference?
05:05:37 <jimstutt> sjanssen: and i only read it a few days ago. But I'll persist with both boots.
05:05:41 <Taejo> surely if (a `seq` b) is evaluated, then b is also evaluated?
05:05:50 <sjanssen> (where evaluate means WHNF, enough evaluation to reveal the first constructor)
05:05:56 <sjanssen> Taejo: yes, there is no difference
05:06:11 <Taejo> ok
05:06:33 <sjanssen> it follows that (\x -> x `seq` x) is equivalent to id
05:06:57 <Taejo> so it is
05:07:07 <noob2007> sjanssen,hei can u help me
05:07:15 <sjanssen> noob2007: perhaps
05:07:26 <sioraiocht> doesn't a `seq` b also guarantee that a is evaluated before b?
05:07:41 <sjanssen> sioraiocht: no, there are no guarantees wrt. sequence
05:07:44 <jimstutt> ?seq
05:07:44 <lambdabot> Maybe you meant: faq let seen src
05:07:59 <sioraiocht> ?src seq
05:08:00 <lambdabot> Source not found. Sorry.
05:08:00 <noob2007> Itry to run some example from winhugs, but I can't
05:08:33 <sjanssen> jimstutt, sioraiocht: seq is a magic compiler primitive, so it has no source
05:09:59 <jimstutt> sjanssen: aha. where are the lambdabot commands @ listed - not on google and lambdabot page is u.s.
05:10:23 <sjanssen> @list
05:10:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:11:57 <jimstutt> @kind seq
05:12:01 <lambdabot> Not in scope: type variable `seq'
05:12:10 <sioraiocht> uhh
05:12:18 <sioraiocht> only constructors have kinds, jimstutt
05:12:44 * Heffalump is confused about pseq
05:12:48 <jimstutt> :t seq
05:12:50 <lambdabot> forall a t. a -> t -> t
05:12:57 <jimstutt> :t pseq
05:13:03 <EvilTerran> sioraiocht, what? don't you mean only types have kinds?
05:13:11 <lambdabot> Not in scope: `pseq'
05:13:16 <sioraiocht> EvilTerran: sorry, has
05:13:20 <sioraiocht> YES
05:13:26 <sioraiocht> <---- has read tooo many papers today
05:13:29 <EvilTerran> hehe, okay
05:13:30 <sjanssen> Heffalump: AFAIK, pseq seems lazy in the second argument
05:14:02 <sjanssen> Heffalump: I think this keeps the strictness analyzer from messing with par
05:14:22 <jimstutt> guess: pseq isn't in the db?
05:15:39 <jimstutt> @djinn forall a t. a -> t -> t
05:15:43 <lambdabot> f _ a = a
05:16:32 <jimstutt> @pl forall a t. a -> t ->t
05:16:32 <lambdabot> (line 1, column 15):
05:16:32 <lambdabot> unexpected ">" or "-"
05:16:32 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
05:16:54 <andrei> Hi, I'm using c2hs and have a bit of an issue. The code typedefs a void* to X then it typedefs X to Y1, Y2, Y3; c2hs complains that there is no marshaller between my haskell type Y1 and a function that takes a Y1 [though its error message complains about Y1 and Ptr ()]. If I make my haskell type Ptr () it still complains there's no in marshaller between Ptr () and Ptr(). I'm just wondering what's up?
05:21:14 <EvilTerran> specify an explicit marshaller of id (in the latter case)?
05:21:50 <andrei> I was trying to avoid that, there's no reason why it should get so confused here
05:22:23 <EvilTerran> it's what i ended up doing in a similar situation, iirc
05:23:50 <andrei> Ah joy, okies; thank you
05:25:01 <EvilTerran> i don't know if there's a better way, mind; I was pretty much learning as i went along
05:28:43 <Mitar> can anybody point me to some reference on how to build a semantic parser for a compiler, as I am trying to one for a subset of a Pascal but I have problems
05:28:45 <hpaste>  Mitar pasted "semantic analysis" at http://hpaste.org/4220
05:30:23 <Botje> Mitar: if I understand your question correctly, you need to modify that SynProgram as you go, right?
05:31:30 <Mitar> no, I would like to make a abstract tree where SynProgram is the main node, and to that node (and to all other nodes) I have added a SemTypeM value for a type-checked value of node's type
05:31:57 <Mitar> I do not want to make an abstract tree and then map it to another (new) tree with added semantic information
05:32:07 <Mitar> but I would like to leave to layiness to do that ...
05:33:00 <Mitar> so I define the function to check and return SemTypeM, but as it is lazy, it will not be evaluated until I read the value of type of SynProgram
05:33:28 <Mitar> which I do after I parse everything and build the abstract tree, and in this way I do a semantic check over it ...
05:33:54 <Mitar> the problem is, that I have to somehow specify current environment in lower nodes
05:34:20 <Botje> this screams "state monad" to me, but I don't know how you'd interface it with the parsing :/
05:34:48 <Mitar> in the topest node it is initenv which have for example system calls ...
05:34:54 <Mitar> but in the lower nodes ...
05:35:18 <Mitar> I could use state monad ... but in this case I will have to combine the parsing step with semantic analsis.
05:35:48 <Mitar> as the code for parsing will have to take care of changing the environment and use/store that in a state as I am build the abstract tree
05:36:07 <Mitar> (I could use Parsec state interface for this)
06:25:24 <luqui> the array interface seems to have changed
06:25:29 <luqui> how do I use them now?
06:25:44 <luqui> I just want my Array (Int,Int) (Maybe Int) back
06:27:47 <Saizan> chenged?
06:29:00 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/array-0.1.0.0/Data-Array-IArray.html <-- it seems the same to me
06:29:01 <lambdabot> http://tinyurl.com/yusu79
06:47:03 <LoganCapaldo> @type array (0 :: Int , 9) (map Just [1.. (10 :: Int )])
06:47:14 <lambdabot>     Couldn't match expected type `(Int, e)'
06:47:14 <lambdabot>            against inferred type `Maybe a'
06:47:14 <lambdabot>     In the first argument of `map', namely `Just'
06:48:13 <LoganCapaldo> @type array (0 :: Int , 9) [ (x - 1, Just x) | x <- [1.. (10 :: Int) ]
06:48:21 <lambdabot> parse error (possibly incorrect indentation)
06:48:52 <LoganCapaldo> @type array (0,9) [ (x, Just x) | x <- [1..10] ]
06:48:54 <lambdabot> forall t. (Num t, Enum t, Ix t) => Array t (Maybe t)
06:49:15 <LoganCapaldo> @type array (0,9) [ (x, Just x) | x <- [1..10] ] :: Array (Int, Int) (Maybe Int)
06:49:22 <lambdabot>     Couldn't match expected type `Int'
06:49:22 <lambdabot>            against inferred type `(Int, Int)'
06:49:22 <lambdabot>     In the first argument of `Just', namely `x'
06:49:49 <wli> I wish array comprehensions would get merged so we don't have to put up with list conversion crud.
06:50:06 <kuribas> Is the haskell version on debian testing recent enough?
06:50:08 <LoganCapaldo> I wish I wasn't going insane apparently
06:50:36 <chessguy> @type array (0,9) [ (x, Just x) | x <- [1..10] ] :: Array (Int, Maybe Int)
06:50:37 <lambdabot>     `Array (Int, Maybe Int)' is not applied to enough type arguments
06:50:37 <lambdabot>     Expected kind `?', but `Array (Int, Maybe Int)' has kind `* -> *'
06:50:37 <lambdabot>     In an expression type signature:
06:50:43 <LoganCapaldo> @type array (0,9) [ (x, Just x) | x <- [1..10] ] :: Array Int (Maybe Int)
06:50:43 <lambdabot> Array Int (Maybe Int)
06:50:52 <chessguy> yeah
06:50:57 <chessguy> i knew something was wrong there
06:52:15 <LoganCapaldo> @type array ((0,9), (0,9)  [ ((x,y), Just x) | x <- [0..9], y <- [0..9]  ] :: Array (Int, Int) (Maybe Int)
06:52:16 <lambdabot> parse error (possibly incorrect indentation)
06:52:29 <chessguy> LoganCapaldo, missed a closing paren
06:52:38 <chessguy> or two
06:52:41 <LoganCapaldo> @type array ((0,9), (0,9))  [ ((x,y), Just x) | x <- [0..9], y <- [0..9]  ] :: Array (Int, Int) (Maybe Int)
06:52:49 <lambdabot> Array (Int, Int) (Maybe Int)
06:53:53 <wli> @type array ((0,0), (9,9)) [((x, y), Just x) | x :: Int <- [0 .. 9], y :: Int <- [0 .. 9]]
06:53:55 <lambdabot> Array (Int, Int) (Maybe Int)
06:54:06 <wli> Try that instead.
06:54:48 <chessguy> wli, the extra type annotations are rather superfluous
06:54:52 * LoganCapaldo was thinking (x1, x2), (y1, y2)
06:55:00 <LoganCapaldo> silly me
06:55:09 <wli> chessguy: Are they?
06:55:28 <chessguy> oh, you took the one off the end, never mind
06:56:29 <wli> Yeah, it's a lot shorter sticking a couple of generators' types in vs. rattling off a huge built-up type at the end.
06:57:02 <hashendgame> @pl \x -> sequence . map x
06:57:02 <lambdabot> (sequence .) . map
06:57:14 <wli> The same sort of thing helps prevent weird Num instances from getting inferred BTW.
06:58:09 <wli> I've become anti-defaulting in my old age.
06:58:39 <MyCatVerbs> wli: define "old"?
06:58:53 <wli> 10 years of Haskell use.
06:59:51 <wli> I'm also liking the ML-style parameter/pattern type annotations.
07:00:10 <wli> f (x :: t) (y :: t') = z :: t'' where ...
07:01:20 <wli> I kind of wish scoped type variables behaved more as expected, though.
07:03:55 <LoganCapaldo> it's gonna be H98's 10th birthday soonish isn't it
07:04:06 <LoganCapaldo> are we gonna throw a party?
07:06:48 <wli> If it's in Portland, sure.
07:09:08 <Igloo> Can http://hpaste.org/4221 be made to work without changing the class declarations?
07:09:39 <jimstutt> @pl forall x. T -> forall y. (T y) => y -> x) ->x
07:09:39 <lambdabot> (line 1, column 13):
07:09:39 <lambdabot> unexpected ">" or "-"
07:09:39 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
07:10:04 <jimstutt> @pl forall x. T -> (forall y. (T y) => y -> x) ->x
07:10:05 <lambdabot> (line 1, column 13):
07:10:05 <lambdabot> unexpected ">" or "-"
07:10:05 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
07:10:10 <LoganCapaldo> Igloo: I'm scared and confused
07:10:20 <Igloo> jimstutt: @pl wants an expression, not a type
07:10:41 <LoganCapaldo> mmm pointfree types
07:11:02 <jimstutt> @pl \a -> forall x. T -> (forall y. (T y) => y -> x) ->x a
07:11:02 <lambdabot> (line 1, column 19):
07:11:02 <lambdabot> unexpected ">" or "-"
07:11:02 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
07:11:33 <jimstutt> :t forall x. T -> (forall y. (T y) => y -> x) ->x a
07:11:36 <lambdabot> parse error on input `=>'
07:11:48 <jimstutt> :t forall x. T -> (forall y. (T y) => y -> x) ->x
07:11:49 <lambdabot> parse error on input `=>'
07:12:16 <Saizan> jimstutt: :t wants an expression too
07:12:18 <igel> @pl \n xs -> if n <= 1 then [xs] else y : unshuffle (n-1) ys where (y, ys) = splitAt (length xs `div` n) xs
07:12:18 <lambdabot> (line 1, column 72):
07:12:18 <lambdabot> unexpected "="
07:12:18 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
07:12:20 <LoganCapaldo> that also wants an expression, not a type
07:12:29 <Saizan> what do you want to know from that type?
07:12:42 <igel> @pl \n xs -> let (y, ys) = splitAt (length xs `div` n) xs in if n <= 1 then [xs] else y : unshuffle (n-1) ys
07:12:42 <lambdabot> (line 1, column 14):
07:12:42 <lambdabot> unexpected "("
07:12:42 <lambdabot> expecting natural, identifier or "in"
07:12:51 <jimstutt> Saizan: just trying to use it as a type checker
07:13:11 <jimstutt> Saizan: I can't parse this type
07:13:35 <Saizan> jimstutt: a type checker checks if an expression matches a type, with only the type you won't get much
07:14:12 <EvilTerran> you could verify the type was valid with sth like :t undefined :: {your type here}
07:14:14 <jimstutt> Saizan: this so-called type of mine is not cos it's illegal but I don't know why?
07:14:18 <LoganCapaldo> I'm not entirely sure what the difference between Bar b => b -> a and (forall b. Bar b => b) -> a is
07:14:32 <jimstutt> EvilTerran: many thx
07:14:40 <Saizan> jimstutt: that type is wrong, maybe you meant forall x. T x => (forall y. T y => y -> x) -> x ?
07:15:05 <dmhouse> LoganCapaldo: have you read http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types ?
07:15:07 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
07:16:02 <dmhouse> LoganCapaldo: the difference is that in the second one, b can be assumed to have any type in Bar at all.
07:16:25 <dmhouse> LoganCapaldo: in other words, b is in the intersections of all types (representing types as sets of values with that type) that have the class Bar.
07:16:41 <LoganCapaldo> dmhouse: but in this specific type isn't that not all that useful?
07:16:50 <jimstutt> :t undefined :: forall b. T -> (forall a. (T a) => a -> b -> b
07:16:54 <lambdabot> parse error (possibly incorrect indentation)
07:17:03 <dmhouse> LoganCapaldo: yeah, intersections over lots of types are normally pretty useless.
07:17:04 <jimstutt> had this before
07:17:10 <desegnis> LoganCapaldo: In the second type, b must be entirely polymorphic over Bar, and must not be of any specific type.
07:17:15 <dmhouse> LoganCapaldo: normally the intersection ends up containing precisely undefined.
07:18:13 <dmhouse> LoganCapaldo: in other words, if you were writing the body of foo :: Bar b => b -> a, you can assume the parameter has _some_ type which instantiates Bar. If you're writing the body of foo' :: (forall b. Bar b => b) -> a, then you can assume the parameter has _any_ type which instantiates Bar.
07:18:37 <LoganCapaldo> sure
07:18:57 <LoganCapaldo> but it seems like a distinction w/o meaning for b -> a
07:19:12 <jimstutt> Saizan: Here's where I've got
07:19:43 <dmhouse> LoganCapaldo: well, the only function f :: b -> a is f = undefined (up to lambdas).
07:20:08 <LoganCapaldo> sorry
07:20:16 <LoganCapaldo> I mean with the Bar constraint
07:20:35 <LoganCapaldo> Seems like the foos you can write will be the same
07:21:09 <LoganCapaldo> whether it's type is Bar b => b -> a or (forall b. Bar b => b) -> a
07:21:29 <jimstutt> Saizan: from Types.hs in HDBC-1.1.3/Database/HDBC/Types.hs hpaste = 4199
07:22:45 <jimstutt> LoganCapaldi: In the problem code the first type is a type class and the second an instance of it iiuc?
07:23:15 <Saizan> jimstutt: ConnWrapper is a type, IConnection a typeclass
07:23:40 <sjanssen> Igloo: foo, bar = _|_ ?
07:24:23 <jimstutt> Saizan: I always seem to remember things backwardss. But now I've got something to read up on and find out what it should be
07:24:43 <Igloo> sjanssen: I need the instances to actually work (with overlapping instances avoiding infinite loops, although I'm not sure if that would work out either
07:24:46 <Igloo> )
07:25:28 <Igloo> sjanssen: I've come to the conclusion it's not possible though, I think
07:26:02 <Igloo> although I'm not sure why it isn't accepted by the typechecker
07:26:48 <Igloo> Aha, if I eta-expand then it is accepted
07:28:13 <LoganCapaldo> eta-expand is foo = bar ----> foo x = bar x right?
07:28:19 <Igloo> Yup
07:30:52 <Heffalump> that's odd, it doesn't look like something that should be subject to the monomorphism restriction
07:30:59 <Heffalump> what did you expand, foo and bar?
07:31:23 <jimstutt> undefined :: b -> T -> (a  ->( U a)->a->b) ->b
07:31:59 <Saizan> jimstutt: the foralls just put a type variable in scope, they are not another parameter.
07:32:10 <Saizan> ?type id
07:32:10 <LoganCapaldo> @src Kleisli
07:32:12 <lambdabot> forall a. a -> a
07:32:12 <lambdabot> Source not found. You type like i drive.
07:32:34 <Igloo> Heffalump: Yup
07:33:01 <Igloo> I think GHC needs help like that when things like higher rank types are involved
07:33:03 <jimstutt> undefined :: b -> t -> (a  ->(u a)->a->b) ->b
07:33:08 <Saizan> jimstutt: id :: forall a. a -> a means that id takes a parameter of type 'a' which is univerally quantified, i.e. it could be anything
07:33:56 <Heffalump> that's worrying
07:34:24 <jimstutt> Saizan: just playing with the wiki Existentially Qualified Types from a position of complete ignorance. It's great fun. Hope it doesnt disturb u helpful people
07:35:16 <jimstutt> :t undefined :: b -> t -> (a  ->(u a)->a->b) ->b
07:35:18 <Saizan> jimstutt: ah,ok i thought you were still trying to understand your previous type
07:35:23 <lambdabot> forall b t a (u :: * -> *). b -> t -> (a -> u a -> a -> b) -> b
07:35:57 <jimstutt> Saizan: I am. Missed the :t then got it is seen as a valid sig
07:37:30 <Saizan> jimstutt: yes, but you're changing the meaning of the simbols, e.g. u is no longer a typeclass if written that way
07:38:27 <jimstutt> Saizan: id :: a -> a == forall a. a -> a
07:39:45 <jimstutt> Saizen: what's the minimum syntax to indicate a typeclass?
07:40:44 <Saizan> jimstutt: well a typeclass name starts with a capitol letter, and it's used before the '=>'
07:42:32 <Saizan> jimstutt: http://en.wikibooks.org/wiki/Haskell/Classes_and_types
07:45:10 <jimstutt> Saizen: am in the wiki and yaht so back after a good read. thx
07:45:51 <Saizan> jimstutt: however :t checks that the typeclasses you're using exists, so you might want to experiment in ghci after loading a module that exports those classes
07:47:48 <mike_zzz> hello
07:49:29 <mike_komi> for all of you who've been using haskell for a long time, can you tell me what they've improved since the older versions of haskell?
07:50:41 <mike_komi> i.e. what sorts of shortcomings did the older versions have? i'm wondering b/c I'd really like to start learning functional languages
07:50:54 <mike_komi> not just how to use them, but how they've come along
07:51:39 <oerjan> well the first version of Haskell did not have monads, for one thing
07:51:48 <conal> @go history of haskell
07:51:49 <lambdabot> http://haskell.org/haskellwiki/History_of_Haskell
07:51:57 <mike_komi> is there a place i can find the old version reports?
07:52:03 <conal> mike_komi: that paper has a pretty extensive history
07:52:27 <conal> and it was written this year
07:52:45 <mike_komi> i read that, very well done
07:52:53 <shachaf> @go haskell 1.4 report
07:52:54 <lambdabot> http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/
07:52:54 <lambdabot> Title: The Haskell 1.4 Report
07:52:55 <mike_komi> a little biased hehe
07:53:23 <wli> The Haskell 1.4 Prelude was a beautiful thing.
07:54:17 <mike_komi> cool thanks
07:55:02 <noteventime> Has anyone done any experiments on nested data parallelism? I'm watching a presentation on it.
07:55:19 <noteventime> Sounds interesting :-)
07:58:13 <olsner> so what's the difference between the 1.4 prelude and the Haskell98 prelude?
07:58:49 <mike_komi> main difference i know is that haskell 98 is more like a stable version, leaving out some features that 1.4 has
07:59:05 <wli> olsner: Beauty. Godliness. Choirs of angels singing. World peace.
07:59:17 <shachaf> olsner: http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/standard-prelude.html
07:59:18 <lambdabot> Title: The Haskell 1.3 Report: Standard Prelude, http://tinyurl.com/299g2f
07:59:31 <Saizan> more polymorphism, no fail, monad comprehensions, rivers of milk and honey
07:59:32 <wli> olsner: More specifically 1.4 having numerous sorts of sanity and monad comprehensions.
07:59:34 <mike_komi> is lambdabot written in haskell?
07:59:38 <shachaf> mike_komi: Yes.
07:59:44 <mike_komi> lol
08:00:03 <shachaf> @vixen Are you written in Haskell?
08:00:04 <lambdabot> Ooh, functional programmers are so hot!
08:00:18 <olsner> yes, was just reading that page... I can't spot the differences :P
08:00:24 <shachaf> Monad comprehensions aren't part of the Prelude, are they?
08:00:35 <LoganCapaldo> they would be part of the language
08:00:39 <LoganCapaldo> (I hope...)
08:00:41 <wli> olsner: e.g. in 1.4 you have map :: Functor f => a -> b -> f a -> f b as the class method of Functor.
08:00:52 <shachaf> olsner: MonadZero is there.
08:01:02 <olsner> ah, yes, map instead of fmap
08:01:05 <shachaf> A lot of the functions are overloaded, like filter.
08:01:08 <wli> olsner: e.g. in 1.4 you have (++) as the class method of MonadPlus and MonadPlus is a distinct class from Monad0.
08:01:33 <wli> olsner: e.g. in 1.4 you have monad comprehensions which are brilliant beyond words
08:02:06 <shachaf> Will they be adding any of this back to Haskell'?
08:02:19 <wli> No.
08:02:38 <wli> It may be brought back, but Haskell' has a different purpose.
08:02:49 <wli> Haskell' is for what implementations are already all doing now.
08:02:59 <LoganCapaldo> sacrificed on the altar of backwards compatibility?
08:03:25 <wli> Haskell' as an opportunity to do anything could be described that way.
08:03:47 <Saizan> we could start cabalizing a new prelude/base with these things back, then hack monadcomprehension in ghc
08:03:50 <wli> It's a different project, for a different purpose.
08:04:17 <wli> I wanted to get around to working on ghc intrinsics.
08:04:21 <wli> I failed.
08:04:21 <kirkt> Hey all. finally, i understand the meaning of functional languages, and i think i'm getting that addiction. is there some kind of community for that?
08:04:26 <mike_komi> lot of people use 1.4 instead of 98 then?
08:04:33 <LoganCapaldo> > [ x | x <- Just 1 ] -- I bet this parses
08:04:35 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Maybe t1'
08:04:39 <wli> mike_komi: Most people just use ghc extensions.
08:04:41 <Saizan> mike_komi: no, we use 98 + extensions
08:04:41 <LoganCapaldo> yep
08:05:09 <shachaf> LoganCapaldo: Why wouldn't it?
08:05:09 <mike_komi> ahh ok, i'll bbiab going to look some of this up
08:05:25 <LoganCapaldo> shachaf: I dunno?
08:05:32 <shachaf> > [x | x <- anything parses]
08:05:34 <wli> Saizan: Most of the serious damage needs intrinsics hacking to get off the ground.
08:05:42 <lambdabot>   Not in scope: `parses'
08:05:50 <wli> Saizan: I'm not sure where a new base/etc. would get started without all that.
08:05:54 <LoganCapaldo> yes but I'm lame
08:06:10 <pejo> wli, why can't you work on ghc intrinsics?
08:06:20 <Saizan> wli: fail and monadcomprehensions need instrinsics.
08:06:56 <wli> pejo: Time, mental energy, limited ability to track the number of things I have concurrently in progress.
08:07:36 <wli> Saizan: Also naturals.
08:07:55 <wli> Saizan: (which I assume people want but were never part of 1.4)
08:08:51 <EvilTerran> does fail need intrinsics? i thought -fno-implicit-prelude would be enough
08:09:16 <wli> EvilTerran: Typing comprehensions involves fail.
08:09:41 <EvilTerran> ahh. k.
08:28:51 <gwern> :def c++ \str -> return $ ":! c++ \"" ++ str ++ "\""
08:29:01 <gwern> > c++ "foobar.c"
08:29:16 <lambdabot>  thread killed
08:30:24 <gwern> > c++ "foobar.c"
08:30:27 <lambdabot>   Not in scope: `c'
08:30:47 <gwern> hm. that's interesting. :def allows you to define stuff you can't use?
08:31:06 <wli> Saizan: Where would you start that you wouldn't need intrinsics?
08:31:18 <shachaf> gwern: lambdabot isn't ghci.
08:31:52 <gwern> same thing seems to happen when I try it locally in my ghci, fwiw
08:32:06 <shachaf> gwern: You want :c++.
08:32:34 <gwern> ah.
08:33:29 <Saizan> wli: reshaping MonadPlus/MonadZero/ using map for Functor, making Applicative a superclass of Monad, providing fail as a method of MonadZero so it at least works in do-notation..
08:33:43 <gwern> hm. now all I need is a way to have functions call a GHCi command...
08:34:08 <LoganCapaldo> gwern why?
08:34:18 <shachaf> Saizan: Why not use mzero instead of fail?
08:34:35 <oerjan> shachaf: error messages
08:34:38 <wli> shachaf: Because ghc has to be hacked to emit it.
08:34:47 <gwern> LoganCapaldo: because having to type ':' all the time sucks. it'd be better to be able to type 'cd' instead of ':cd'
08:35:08 <Saizan> shachaf: so IO or other error-like monads can give a better error message
08:35:17 <LoganCapaldo> so why don't you define cd as a function in the first place?
08:35:20 <Saizan> shachaf: and others can simply fail _ = mzero
08:35:22 <shachaf> I missed the earlier bits of the conversarion, probably; are you talking about an alternative Prelude?
08:35:42 <Saizan> shachaf: yes, to be used with -fno-implicit-prelude
08:36:04 <shachaf> Saizan: Oh, OK. And you can use MonadZero/your own fail with that?
08:36:39 <Saizan> shachaf: yes, ghc will use whichever fail is in scope
08:38:24 <Saizan> wli: ah, the numerical hierarchy too, but i've not a clear design for that.
08:38:29 <gwern> LoganCapaldo: also, you can't do things like ':cd ../; :top' as far as I can tell
08:39:55 <wli> Saizan: It needs intrinsics to get started, too, modulo my lack of half-stepping ability.
08:40:13 <gwern> it's kind of frustrating. it looks to me like ghci is *almost* at the point where you could add layers on top of it to get a Haskell shell, but it's not quite there
08:40:25 <LoganCapaldo>  gwern err, if you want to wite a shell, why don't you do just that?
08:40:44 <gwern> LoganCapaldo: "good artists borrow; great ones steal"
08:41:04 <LoganCapaldo> yeah but you're stealing from the wrong thing IMO
08:41:07 <mike_komi> this might be basic, but if I have a polymorphic type, which I define a monad for, then I can use the monad for types derived from the polymorphic type?
08:41:25 <LoganCapaldo> I'd try stealing from lambdabot, it's got way more support for custom command thingies
08:41:27 <conal> mike_komi: "types derived"??
08:41:53 <gwern> LoganCapaldo: what's wrong about it? It's already got most of the necessary facilities, like using the ghc api, readline support, interactive evaluation of Haskell expressions and even a bunch of shell builtins like :cd
08:42:05 <mike_komi> for 'things' ? derived from the polymorphic type?
08:42:12 <gwern> (lambdabot still uses plugins last I heard and isn't an option for me)
08:42:23 <conal> mike_komi: haskell does have derived types.
08:43:00 <desegnis> mike_komi: Perhaps you mean something like class Foo m => Monad m where ...; then you can use any Foo type as a monad.
08:43:25 <Heffalump> but you can't write that without redefining Monad..
08:43:31 <mike_komi> thanks, time to read more :)
08:43:33 <LoganCapaldo> gwern: I didn't say it was "wrong", I just think that you are gonna keep running into these issues
08:43:35 <desegnis> er
08:43:49 <desegnis> Heffalump: I think I meant instance instead of class.
08:44:00 <Heffalump> if you do that you'll get into all sorts of trouble with overlapping instances
08:44:11 <Heffalump> not recommended unless you really know what you're doing
08:44:31 <mike_komi> I guess I'm not seeing the difference between Monads and polymorphism
08:44:46 <desegnis> Heffalump: I think it depends on the specific design whether you'll get overlapping instances.
08:44:51 <shachaf> gwern: How could ghci be a shell, exactly?
08:45:00 <shachaf> gwern: Do you want to define an alias/function for every command?
08:45:07 <shachaf> mike_komi: What do they have in common?
08:45:22 <Heffalump> no, you'll definitely get overlapping instances if you write instance Foo m => Monad m where ...
08:45:33 <LoganCapaldo> gwern: or you could just accept the limitations or not having multiple commands on one line and needing to type : etc.
08:45:33 <Heffalump> you just need to decide whether it's worth the pain or not
08:45:36 <desegnis> mike_komi: Polymorphism just means that a function acts on different types at will.
08:45:46 <LoganCapaldo> s/or/of.
08:46:15 <shachaf> LoganCapaldo: "of you could just accept"?
08:46:24 <LoganCapaldo> the second or
08:46:24 <mike_komi> i need to beat this imperative logic outta my skull
08:46:51 <LoganCapaldo> limitations of
08:48:15 * LoganCapaldo has never quite gotten the appeal of "I want to live in programming language foo, but only if I can make foo look a lot like sh"
08:48:23 <gwern> LoganCapaldo: I'm sure I can figure out a way; I just need to spelunk through the ghci code. I*think* all that's really needed is to abolish the distinction between ghci commands and functions, and change the parsing somehow
08:48:55 <gwern> LoganCapaldo: well, 'I want to live in programming language Haskell, but only if I can put multiple commands on one line without needing a bazillion :s"
08:49:21 <shachaf> gwern: do { ...; ... } or ... >> ...?
08:50:03 <LoganCapaldo> I just wouldn't use commands. cd = Directory.setCurrentDirectory, top = system "top" ; cd "../" >> top
08:51:25 <gwern> > do { let foo = "bar"; take 100 [1..] } -- shachaf, like this?
08:51:25 <lambdabot>  Parse error at "}" (column 38)
08:51:32 <desegnis> Heffalump: Right, ghc agrees with you...
08:52:15 <shachaf> gwern: Oh, you want :def commands because you don't have to type the quotes?
08:52:43 <shachaf> gwern: But yes, otherwise.
08:53:03 <shachaf> gwern: (You need to say let {...};, though, if you're doing this on one line.)
08:53:17 <gwern> shachaf: yes, the difference between :cd ../ and cd "../" is small but significant for me
08:53:22 <Heffalump> desegnis: this is because I am wise in the ways of ghc ;-)
08:53:46 <shachaf> gwern: GHCi would make a terrible sh.
08:54:15 <gwern> shachaf: as it is right now, absolutely. hence all my questions, I'm trying to figure out the best way to go
08:55:06 <shachaf> gwern: If you want a Haskell shell, write one. :-)
08:55:13 <gwern> do I try to layer on stuff to ghci to make it a good sh? do I copy the source code to ghci and rip stuff out and mercilessly edit it? do I continue with my small interactive evaluator using the ghc api and try to reimplement a ton of ghci functionality on my way to sh-dom? there's a lot of alternatives here
08:55:24 <shachaf> gwern: Do you expect to :def or define every single command?
08:55:54 <gwern> shachaf: how do you mean? shell builtin commands or what?
08:55:54 <desegnis> Heffalump, right :)
08:56:48 <Heffalump> also, it stands to reason. A type variable m overlaps any other type.
08:57:10 <Heffalump> instance resolution is local, not global
08:57:31 <shachaf> gwern: Everything in $PATH.
08:58:22 <shachaf> gwern: If you actually want to use this, you'd probably pick the third option.
08:58:35 <shachaf> gwern: A usable shell is quite different from ghci.
08:58:51 <gwern> shachaf: oh. for that I was thinking something like 'programs <- (liftM rmUseless) $ (liftM concat) $ mapM getDirectoryContents path', and then ' rebind a = print a >> mustWork ("let " ++ a ++ " = run " ++  "\"" ++ a ++ "\"" ++ " []") session GHC.SingleStep' where run is doing much the same thing as :! dpes
08:59:18 <gwern> (or something like that anyway)
09:00:01 <shachaf> gwern: You could make every single : command parse its arguments.
09:00:14 <shachaf> gwern: Check for a ; or some character like that.
09:00:45 <shachaf> gwern: Check $PATH on every command to see if anything has changed, or something like that.
09:00:57 <shachaf> gwern: This just won't work... :-)
09:01:26 <gwern> shachaf: so recurse through the entered command, like 'eval = if head args = ';' then eval (tail args) else ghci-evaluate args'
09:03:40 <shachaf> gwern: You'd probably want real parsing.
09:04:10 <gwern> yeah; it'd get complicated once you throw in quoting and escaping of ;
09:04:23 <mike_komi> going to try my hand at some basic haskell functions, thanks for all the help everyone
09:06:33 <Nafai> Is there a Haskell library for parsing json?
09:06:57 <Nafai> I'm wanting to play around with the delicious json feeds
09:08:09 <shachaf> Nafai: There's HsSyck, I guess.
09:08:14 <shachaf> Nafai: Which parses YAML.
09:08:20 <gwern> @where posix
09:08:21 <lambdabot> I know nothing about posix.
09:08:55 <shachaf> (There's also YamlReference, but that's not really meant to be used for anything.)
09:09:35 <shachaf> Nafai: There also seems to be http://snippets.dzone.com/posts/show/3660
09:09:36 <lambdabot> Title: JSON Parser in Haskell [json] [haskell] [parsec]
09:10:23 <Nafai> Thanks!
09:10:26 <shachaf> Nafai: And http://notes-on-haskell.blogspot.com/2007/05/parsing-json.html
09:10:26 <lambdabot> Title: Notes on Haskell: Parsing JSON
09:13:12 <shachaf> Nafai: JSON looks pretty simple; you could probably write a parser yourself pretty easily.
09:14:18 <Nafai> Yeah
09:14:22 <shachaf> Nafai: Oh, http://json.org/ has two more links.
09:14:23 <lambdabot> Title: JSON
09:14:27 <shachaf> Nafai: Those may be helpful.
09:15:03 <Nafai> Yeah, I think so, thanks
09:19:00 <v3cw> Hello.
09:19:15 <v3cw> Is there a haskell equivalent to F#'s |> in the standard library?
09:19:41 <mauke> what does |> do?
09:19:42 <shachaf> v3cw: No (if (|>) is flip ($)).
09:19:50 <shachaf> v3cw: But it's easy to define.
09:19:50 <v3cw> Where x |> f = f x
09:19:56 <mauke> oh
09:20:00 <Heffalump> @type ap
09:20:02 <shachaf> v3cw: There is ($).
09:20:04 <v3cw> shachaf, I know, but I didn't want to redefine it every time I need it.
09:20:14 <v3cw> What's the definition of $?
09:20:15 <lambdabot> thread killed
09:20:20 <mauke> ($) = id
09:20:28 <shachaf> f $ x = f x
09:20:36 <v3cw> Oh.
09:20:48 <v3cw> Ok, thanks.
09:21:15 <shachaf> v3cw: There is (>>>), which is like flip (.).
09:27:10 <buffi_> could anyone explain to me the point of the Maybe datastructure. coming from other languages such as python I don't see the use of a wrapper for this instead of just returning None or something similar
09:28:28 <cjay> buffi_: Maybe is the type and gives you the chance to use None
09:30:05 <cjay> unlike in python, there is static typing, so a fuction with result type Foo can't "return" None, you have to use Maybe Foo
09:30:37 <cjay> most tutorials should make it clear
09:31:37 <mauke> buffi_: going the other way, a function that returns (say) a string can't also return None
09:31:48 <mauke> the types don't match
09:31:51 <buffi_> I guess. it just feels weird to have to wrap your values instead of simply returning None in non-static languages or throwing an exception in other languages
09:32:46 <buffi_> but I guess that using a Maybe structure could be more intuitive than throwing an exception
09:33:01 <Brian`> hey, when it pattern matches, if the matching type is Int and the type of argument is Row (which is Int type.. i.e. type Row = Int), does it match? or give an error?
09:33:02 <mauke> oh, Maybe can be used like an exception system
09:33:03 <njbartlett> buffi_: It's to do with type safety. If somebody tells you they're going to give you a String, they're damn well going to give you a String, and not a null pointer.
09:33:32 <mauke> Brian`: "type" just creates new names for existing types. the actual type is the same
09:33:39 <buffi_> njbartlett: yeah, but when it comes to static typing I guess I'm just used to exceptions :)
09:33:52 <Brian`> mauke, yeah so does that mean it will pattern match it then?
09:33:55 <mauke> Brian`: yes
09:34:00 <njbartlett> buffi_: Exceptions and static typing are orthogonal
09:34:05 <Brian`> mauke, ok thanks
09:35:32 <Nafai> Bleh
09:35:35 <buffi_> njbartlett: could you rephrase that, since I'm only aware of the geometric use of orthogonal
09:35:36 * Nafai gives up
09:35:39 <buffi_> :)
09:35:44 <mauke> buffi_: "independent"
09:35:48 <buffi_> thank you
09:36:02 <njbartlett> buffi_: Hehe. I mean, they don't really have anything to do with each other. You can have one without the other, or both, or neither.
09:36:26 <wli> IMHO things generating exceptions should live within some kind of monad.
09:36:28 <njbartlett> buffi_: Yeah, okay mauke defined it in one word where I used 21
09:36:30 <buffi_> yes, I simply meant that they are often used in static languages where Maybe is used in haskell :)
09:36:41 <mauke> buffi_: Maybe is an exception
09:37:03 <buffi_> well yes, but it forces you to unpack the value even if it isn't raised
09:37:10 <njbartlett> buffi_: Well. Exceptions should be used in true error conditions. Maybe should be used when it's not an error to return nothing. For example looking something up in a Map
09:37:18 <buffi_> or well, I gyess you could look at it like it's always raised
09:37:26 <Heffalump> buffi_: yes, so that you deal with the possibility of there being no value
09:37:50 <buffi_> I guess I'll get used to it
09:37:56 <mauke> > do { x <- lookup "bar" [("foo", 1), ("bar", 2)]; y <- lookup "bzzt" [("baz", 3)]; return (x + y) }
09:37:57 <Nafai> wli: Okay, why? :)
09:38:07 <lambdabot>  Nothing
09:38:11 <wli> Nafai: It's the sort of thing monads were made for.
09:38:24 <mauke> > do { x <- lookup "bar" [("foo", 1), ("bar", 2)]; y <- lookup "bzzt" [("baz", 3), ("bzzt", 40)]; return (x + y) }
09:38:33 <lambdabot>  Just 42
09:38:54 <mauke> EXCEPTION'D
09:38:55 <wli> Nafai: A parallel set of error reporting and handing primitives is a language design error.
09:39:51 * Nafai nods
09:40:03 <Nafai> Exceptions in Java are very frustrating to me
09:40:11 <Nafai> And just feel messy
09:40:19 <wli> Nafai: The implementation need not use data structures similar to Maybe or Either String or MonadError e m => m
09:40:23 <njbartlett> Heffalump: How's it going? I need to organise the mid-december pub meeting
09:40:36 <njbartlett> Oh and I still need to get Jeremy's video up onto the site!
09:40:44 <njbartlett> I'm falling behind again :-(
09:41:00 <wli> Nafai: You can do RTS magic behind the scenes of throwError and catchError, for instance.
09:42:20 <wli> A builtin error monad besides IO would help there.
09:43:15 <TomMD> @quote Nothing
09:43:27 <wli> That does not mean Maybe.
09:43:32 <wli> Nor Error String
09:43:39 <chessguy> #quote
09:43:42 <chessguy> @quote
09:43:46 <Heffalump> njbartlett: not bad. Let me know if I can be of any assistance..
09:43:47 <lambdabot> lambdabot says: I know nothing about love.
09:43:47 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
09:44:05 <wli> It means the sort of monad you can do division and catch divide by zero exceptions in.
09:44:09 <njbartlett> Heffalump: Should be fine. Bigger problem is finding a speaker for the January meet
09:44:47 <Heffalump> njbartlett: I could talk about darcs sometime, if that helps.
09:45:00 <njbartlett> Heffalump: Yeah that would be great!
09:45:05 <TomMD> Is this FUN?
09:45:17 <njbartlett> Heffalump: Don't suppose you can do Jan? How long, short talk or full talk?
09:45:17 <Heffalump> TomMD: no, London Haskell Users Group
09:45:40 <TomMD> Damn, I can't go to London just for an afternoon meeting.
09:45:54 <Heffalump> njbartlett: I can do any length really. There's various areas I can talk about - using it, patch theory, use of GADTs
09:46:04 <Heffalump> so full talk if that's what you want
09:46:36 <Heffalump> TomMD: it's (early) evening, not afternoon.
09:46:45 <Heffalump> but not very convenient if you're not in London or thereabouts already
09:47:10 <njbartlett> Heffalump: thanks, I'll follow up by email later
09:47:21 <njbartlett> Heffalump: BTW is CS hiring at the moment? Or just in NY?
09:47:39 <Heffalump> either location
09:48:14 <njbartlett> Heffalump: Ooh. Maybe I'll have a chat with Lennart later then :-) Got to go for know, cheers
09:48:15 <Heffalump> (London or NY)
09:48:21 <Heffalump> ok, bye :-)
09:59:56 <shachaf> Is anyone here using GHC with Slackware?
10:01:54 <TomMD> @where dph
10:01:54 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
10:02:43 <conal> augustss: ping
10:02:55 <augustss> conal: yes?
10:03:22 <conal> does the Haskell standard say that Float & Double have -Infinity & +Infinity?
10:03:27 <augustss> No
10:03:34 <conal> oh.  oops.
10:03:46 <wli> IEEE754 will
10:03:50 <augustss> There's a method to ask if it's IEEE
10:04:04 <sioraiocht> anyone here that follows research into contracts in haskell?
10:04:14 <augustss> IEEE can have +/- if it's in affine mode
10:04:57 <augustss> which seems to be the default
10:05:02 <augustss> on most systems
10:05:26 <conal> augustss: okay.  i'm working on a library for functional futures, and it'd be convenient to have Bounded.  i want something that will work uniformly.
10:05:46 <conal> so i'll just augment time types via Either () (Either t ())
10:06:34 <augustss> Well, Float and Double will always have a largest representable number
10:06:40 <conal> which extends the t ordering and adds min & max.
10:06:46 <conal> augustss: oh?  how might i get them?
10:07:09 <augustss> well, they must since there's only a finite number of them and they are ordered
10:07:12 <conal> i guess the couldn't be used for Bounded though.
10:07:34 <Heffalump> sioraiocht: theorem-proving type contracts as opposed to financial contracts?
10:07:46 <sioraiocht> Heffalump: yes
10:08:07 <sioraiocht> I found a few papers, want to make sure i'm not missing anything, i'm about to put forth a reserach proposal on this
10:08:31 <augustss> conal: you might be able to construct them with the methods that return the exponent range, mantissa digits, and radix
10:08:36 <Heffalump> whose work have you found?
10:08:55 <sioraiocht> Dana Xu
10:08:58 <conal> augustss: sure. and do it once for each, in a caf
10:09:00 <sioraiocht> Ralf Hinze (my supervisor)
10:09:06 <sioraiocht> Blume
10:09:13 <sioraiocht> and of course they all refer to eiffel
10:09:15 <Heffalump> what about Neil Mitchell's catch?
10:09:18 <conal> augustss: still, they wouldn't work for Bounded.
10:09:22 <sioraiocht> no i haven't
10:09:38 <conal> since they're not the minimal and maximal numbers, according to <
10:09:49 <conal> at least on my machine
10:09:53 <Heffalump> it's not exactly contracts, but it's related
10:09:57 <sioraiocht> right
10:10:04 <sioraiocht> it's theorem proving for pattern matches, i see
10:10:12 <sioraiocht> thanks
10:10:15 <Heffalump> and there's QuickCheck and (Lazy) SmallCheck which are also somewhat related
10:10:20 <sioraiocht> right
10:10:32 <sioraiocht> i'm looking for static checking work
10:10:57 <Heffalump> various ideas on embedding stuff in the type system, too
10:11:06 <Heffalump> can't think of any specific references
10:18:46 * wli always did like Eiffel's precondition/postcondition/invariant stuff.
10:19:00 <augustss> they are not maximal and minimal if you have +/- infinity
10:19:31 <conal> augustss: yep.  so neither my original suggestion or your trick would be portable.
10:20:45 <augustss> i don't how to make something portable
10:20:51 <Brian`> what's xor in haskell?
10:21:06 <augustss> Brian`:  /=
10:21:15 <conal> augustss: here comes one, via a wrapper.
10:21:17 <Brian`> isn't it not equal to?
10:21:20 <hpaste>  conal pasted "Extending an Ord type to Bounded" at http://hpaste.org/4222
10:21:24 <augustss> Brian`: yes
10:21:44 <LoganCapaldo> @type xor
10:21:45 <lambdabot> forall a. (Bits a) => a -> a -> a
10:21:56 <LoganCapaldo> @instances Bits
10:21:57 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
10:21:59 <conal> augustss: that (hpaste) version is a more general solution anyway.  it works for all underlying ordered types.
10:22:01 <mauke> > True `xor` False
10:22:02 <lambdabot>   add an instance declaration for (Bits Bool)
10:22:02 <lambdabot>     In the expression: True `xo...
10:22:07 <mauke> lame
10:22:09 <LoganCapaldo> @instances-importing Bits
10:22:09 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
10:22:16 <LoganCapaldo> @instances-importing Data.Bits
10:22:16 <lambdabot> Couldn't find class `Data.Bits'. Try @instances-importing
10:22:23 <LoganCapaldo> meh
10:22:25 <augustss> > True /= False
10:22:26 <lambdabot>  True
10:22:31 <Brian`> augustss, how can /= be xor?
10:22:31 <augustss> > True /= True
10:22:32 <lambdabot>  False
10:22:34 <LoganCapaldo> > 3 `xor` 2
10:22:34 <lambdabot>  Add a type signature
10:22:43 <augustss> Brian`: try it :)
10:22:44 <mauke> Brian`: what's the difference?
10:23:04 <LoganCapaldo> write out the truth tables for both and compare if you must
10:23:26 <augustss> Brian`: when does xor give you True?  when the operand are not equal
10:23:51 <mauke> in C you can use - to test for inequality
10:24:03 <Brian`> oh.. that's right
10:24:15 <Brian`> my lack of knowledge :(
10:24:40 <augustss> no problem
10:24:44 <Brian`> thanks
10:25:32 <shachaf> @instances-importing Data.Bits Bits
10:25:32 <lambdabot> Int, Integer
10:25:33 <augustss> There's implication too, but it looks very unnatural :)
10:26:10 <mauke> <=?
10:26:11 <machnt0sh> anybody known a hangman game in the haskell??
10:26:39 <augustss> mauke: yeah.  kinda the wrong way around
10:27:26 <mauke> max/min on Bools don't short circuit
10:27:30 <mauke> should I file a bug report?
10:27:57 <Heffalump> do you think they should short-circuit on maxInt / minInt?
10:28:45 <mauke> maybe. I don't really care for types with more than 3 constructors
10:28:50 <SamB> mauke: aren't they just derived?
10:29:04 <desegnis> Is max === (||), min === (&&)?
10:29:44 <mauke> yes
10:30:02 <LoganCapaldo> @scheck (\a b -> max a b == a || b) :: Bool -> Bool -> Bool
10:30:03 <lambdabot>   Completed 4 test(s) without failure.
10:30:19 <LoganCapaldo> @scheck (\a b -> min a b == a && b) :: Bool -> Bool -> Bool
10:30:20 <lambdabot>   Failed test no. 2. Test values follow.: True, False
10:30:54 <Olathe> Eww.
10:30:56 <LoganCapaldo> > min True False
10:30:56 <lambdabot>  False
10:31:03 <LoganCapaldo> > True && False
10:31:03 <lambdabot>  False
10:31:07 <Heffalump> huh?
10:31:08 <LoganCapaldo> err
10:31:12 <Ferron> do guys know where i can get some wxhaskell tutorial
10:31:14 <Ferron> ??
10:31:16 <LoganCapaldo> scheck going senile?
10:31:17 <integral> > undefined && True
10:31:18 <lambdabot>  Undefined
10:31:26 <Heffalump> @scheck (\a b -> min a b == (a && b)) :: Bool -> Bool -> Bool
10:31:26 <lambdabot>   Completed 4 test(s) without failure.
10:31:26 <Olathe> Test values follow ?
10:31:37 <LoganCapaldo> doh
10:31:44 <LoganCapaldo> I feel dumb
10:31:45 <Heffalump> normally that precedence is what you'd want :-)
10:31:47 <LoganCapaldo> also surprised
10:32:12 <Heffalump> mauke: I guess the bug is that the comparison operators don't short-circuit.
10:33:20 <integral> > undefined || True
10:33:21 <lambdabot>  Undefined
10:33:26 <sioraiocht> wli: i'm trying to take that to haskell
10:33:28 <sioraiocht> for certain cases
10:33:40 <sioraiocht> with static checking for some of it
10:33:57 <wli> sioraiocht: That would be awesome.
10:34:31 <sioraiocht> wli: glad to here it, hopefuly the committee and EPSRC agree with hyou
10:34:36 <hpaste>  conal pasted "Functional futures -- interface and semantic prototype" at http://hpaste.org/4223
10:34:46 <conal> i'd like comments on that paste.
10:35:03 <conal> e.g., related work
10:35:31 <conal> i'm thinking of STM for the actual implementation.  Note that the futures are pure.  No IO.
10:36:16 <conal> i.e., the imperative implementation would be hidden with a pure, referentially transparent layer of functional futures.
10:37:01 <Heffalump> conal: why do you compare the values as well as the times for mappend?
10:37:24 <conal> Heffalump: do i?
10:37:35 <conal> Heffalump: oops!
10:37:46 <conal> Heffalump: oh no.  it's doing what i want.
10:37:53 <Heffalump> no, I think I'm confused
10:38:01 <Heffalump> but why require an Ord t instance, then?
10:38:18 <conal> it's not comparing values.  just times.
10:38:25 <Heffalump> either for Ord (Future t a) or for Monoid (Future t a)
10:38:29 <Heffalump> right, I agree
10:38:30 <conal> see the Ord instance: fst
10:38:46 <conal> Heffalump: t is time, a is value
10:39:01 <Heffalump> oh, right, yeah.
10:39:06 <conal> Heffalump: i'll make that clear up front in the Future comment.  sorry.
10:39:17 <Heffalump> no, I think it's clear, I just wasn't reading properly.
10:40:15 <hpaste>  conal annotated "Functional futures -- interface and semantic prototype" with "clarify "t" in Future" at http://hpaste.org/4223#a1
10:40:20 <Heffalump> presumably you've considered the financial contracts work as related work?
10:41:02 <conal> Heffalump: no i hadn't.  obvious now that you mention it.  thanks.
10:41:23 <Heffalump> it almost seemed too obvious to mention :-)
10:41:48 <conal> Heffalump: yeah -- to me too, especially considering my comment about the value of Galois stock.
10:41:58 <mcp_> I want o add some trace statements. Is that possible without specifying Show for the type in the function declaration?
10:42:05 <conal> Heffalump: it must have been there subconsciously
10:42:27 <vali> things going well for Galois?
10:42:35 <mauke> mcp_: not if you want to show the value
10:42:47 <mcp_> :(
10:42:50 <Heffalump> vali: I believe so (from their hiring numbers), not that it's related to Conal's comment really.
10:43:04 <vali> i see. good to hear that
10:43:13 <Heffalump> does Galois stock even have a measurable value? I didn't think they're public or anything.
10:43:54 <conal> i'll change the example to LambdaPix
10:44:23 <Heffalump> also markets are generally not open at 6pm :-)
10:44:26 <conal> what i'm after is a new simple & efficient basis for FRP.  these "futures" are event occurrences in the future.
10:44:28 <Heffalump> while I'm being pedantic
10:44:44 <SamB> Heffalump: hmm?
10:44:45 <SamB> so?
10:45:05 <Heffalump> SamB: so it's hard to give an accurate price for something that isn't being actively traded
10:45:07 <conal> Heffalump: thanks.  new example comment: "the value of LambdaPix stock at noon next Monday"
10:45:22 * conal is amused
10:45:25 <Heffalump> conal: so how does this idea improve on the idea of time-varying functions?
10:46:41 <conal> Heffalump: i'm doing new refactoring.  this is one piece, which i think will be of value for other things.
10:46:51 <conal> it'll allow efficient data-driven evaluation.
10:46:54 <Heffalump> fair enough
10:47:07 <Heffalump> can you give examples of more complicated combinators on futures than just min and max?
10:47:14 <conal> which FRP implementations don't do.  i came up with DataDriven to do the same, but this is simple and more efficient.
10:47:17 <conal> @wiki DataDriven
10:47:18 <lambdabot> http://www.haskell.org/haskellwiki/DataDriven
10:47:33 <conal> Heffalump: fmap, <*>, join
10:47:50 <Heffalump> sorry, I meant things that are specific to futures
10:48:10 <conal> Heffalump: are you reading "futures" as financial futures?
10:48:21 <Heffalump> no, generally
10:48:29 <conal> i mean http://en.wikipedia.org/wiki/Futures_and_promises
10:48:29 <lambdabot> Title: Futures and promises - Wikipedia, the free encyclopedia
10:48:38 <conal> i'll add that reference as a comment
10:48:44 <noobi1> is there any admin in here?
10:48:52 <Heffalump> ah, I wasn't aware of that technical definition
10:48:55 <Heffalump> noobi1: why?
10:49:10 <conal> Heffalump: specific to futures: the UI & stock examples.
10:49:13 <noobi1> want to know if a banned cud be lifted
10:49:14 <noobi1> ?
10:49:35 <noobi1> it's been 4 months since my friend was banned
10:49:48 <mauke> who is your friend?
10:50:01 <Heffalump> and what was the reason for the ban, and who did it?
10:50:03 <noobi1> well he called himself n00b
10:50:29 <roderyk> All I can find for sql is HToolkit's HSQL (last release 2005). Is there something newer? Is this one standard and stable?
10:50:52 <noobi1> the point is the banned was a ip ban and hence it is not allowing no computer in the whole university to access #haskell
10:51:01 <Heffalump> roderyk: there's HDBC too
10:51:15 <noobi1> don't think one person should suffer for all
10:51:23 <Heffalump> and HaskellDB if you want a higher-level interface, though it's rather verbose to use IME
10:51:28 <Heffalump> noobi1: what IP?
10:53:14 <roderyk> I'm also interested if there is a lightweight disk-based dictionary I could use for string -> Data mappings. For testing out ideas, it's far easier than sql (I'm thinking along the lines of Python Shelve or one of many CL persist libraries)
10:53:23 <Heffalump> conal: I find that page rather hard to follow, but is the basic idea that futures are ways of combining computations whose inputs will only become available in the future?
10:54:20 <Heffalump> also, what's the time associated with the future "the value of the next key you press"? Do you have to have a separate underlying Time type based on the sequencing of keypresses rather than clock time?
10:54:44 <conal> Heffalump: thanks for that feedback, too.  i'll add an explanation at the top.  a "future" is a value that will become knowable only later.  the module gives a way to manipulate them functional.  E.g., a + b will become knowable when the later of a & b becomes knowable.
10:54:48 <roderyk> Heffalump: I though HaskellDB was pretty verbose too. I think, optimally, I would like a pythonisque shelve until I figure out my final schema.. and then move on to just proper sql
10:54:48 <wli> I think futures are trades involving future values.
10:55:05 <conal> wli: that's the financial meaning.  there's also a programming language meaning.
10:55:30 <Heffalump> roderyk: I don't like mentioning vaporware, but I'm in the middle of writing my own high-level SQL combinator library. Dunno when I'll have anything usable, though.
10:55:32 <conal> and they're relatd
10:55:50 <obk> Why is "t" important to a Future?
10:56:41 <roderyk> Heffalump: interesting, of course. But I need something for now :)
10:56:51 <Heffalump> roderyk: don't we all :-)
10:57:42 <Heffalump> just as a data point, how complicated and backend-specific would you expect your SQL to be?
10:57:45 * obk worked with futures in FCP (Flat Concurrent Prolog). Every variable was single-assignment and had two "endpoints", one write-only and one read-only. Using the value of the "reader" blocked until someone assigned to the "writer". This was used as the basic concurency mechanism.
10:58:03 <obk> There was no time concept involved however
10:58:27 <roderyk> when it comes down to it, I don't really need a high-level SQL combinator anyway. I'll be happy to write more verbose queries later. For now I'd like to store a bunch of data instances in a hash with string values. I just need something that's disk-based
10:58:34 <roderyk> and I can't really find anything :(
10:58:38 <obk> So you could write (paraphrased) foo :- producer(writer X), consumer(reader X). And they would run in parallel
10:58:57 <roderyk> string s/values/keys/
10:59:10 <Heffalump> ugh, flashing
10:59:19 <Heffalump> have you looked at Data.Binary?
10:59:19 <obk> Heffalump: Is your Futures idea trying to achive something similar?
10:59:30 <noobi1> here's the ip 205.214.198.201
10:59:30 <Heffalump> obk: I don't have a futures idea, conal does.
10:59:31 <conal> obk: definitely related. thanks.  there must have been some discipline about who gets to write?
10:59:38 <conal> obk: did writing do unification?
10:59:48 <obk> conal: Compile-time safety insured single-writer property
10:59:54 <Heffalump> noobi1: and what's the uni?
11:00:04 <obk> You could have multiple readers though, the type system got a bit hairy for that
11:00:30 <roderyk> Heffalump: I've heard of it yes. I'm very new to haskell, I'll go see if it will do. thanks
11:00:33 <obk> Since readers/writers were actual "types" (almost), you also needed "broadcaster" and "listener" types
11:00:51 <conal> obk: all packaged up declaratively?
11:01:06 <noobi1> unu?
11:01:11 <noobi1> or uwi?
11:01:11 <Heffalump> roderyk: it's not disk-based per se, it just might be a convenient way to persist your own structure
11:01:12 <obk> Well, of course, this was a Prolog variant after all :-)
11:01:22 <obk> The trick is that you could use these for 2-way communication.
11:01:23 <Heffalump> noobi1: what university
11:01:31 <conal> obk: well, it could have been assert/retract
11:01:42 <sclv> ?undo do x <- peek v1; x' <- peek v2; return (x-x');
11:01:42 <lambdabot> peek v1 >>= \ x -> peek v2 >>= \ x' -> return (x - x')
11:01:56 <obk> That's where the F (flat) comes in - no backtracking
11:02:02 <conal> obk: sounds lovely
11:02:22 <Heffalump> noobi1: I've looked through the banlist and I can't find that IP or the hostname corresponding to it.
11:02:40 <obk> You could do writer X <- Foo { writer Y }, and then reader X == Foo { writer Y } | writer Y <- ... for back-and-forth between the two pieces of code
11:02:54 <Heffalump> roderyk: you can also just use read/show if you don't care about space usage.
11:03:04 <conal> obk: what's "<-"?
11:03:06 <noobi1> University of the West Indies Mona
11:03:09 <Heffalump> You could do that with a Data.Map without much effort.
11:03:14 <obk> Of course, if you had _broadcaster_ X, you could not assign it a value containing writers because there might be multiple listeners and this would break the single-writer rule
11:03:14 <noobi1> Jamaica
11:03:28 <obk> <- Just a shorthand for assigning a value to a writer
11:03:33 <obk> You would actually use "="
11:03:40 <Heffalump> noobi1: can you identify the ban in the list of bans for the channel?
11:03:46 <Heffalump> since I can't spot it myself
11:03:49 <obk> But as always with Prolog based syntax it wasn't very pretty :-)
11:03:51 <conal> obk: equality (unification)?
11:04:12 <obk> Unification, in theory, but because of the single-writer rule it wasn't general unification, more like assignment
11:04:56 <obk> Unification was used for guards/patterns/etc. - as in (if) X = Foo { writer Y } (then) | (some stuff)
11:05:00 <conal> obk: hm.  why not add unification and drop single-writer?
11:05:10 <roderyk> Heffalump: thanks for that pointer. Doesn't look as scary as it first sounds, heh. Will be useful if I do just want to serialize arbitrary data.
11:05:11 <obk> X = Foo { writer Y } would be unification/pattern matching but it wouldn't change X
11:05:32 <obk> This is why it was "flat" prolog - no backtracking, no NP-complete unification (Ugh)
11:05:32 <jimstutt> Saizen: (if u r still about) my typeclasses exist and loaded dependent import modules into ghci ok. Same "Illegal polymorphic or qualified type". Now I've dive into this hole I'll keep digging :).
11:05:52 <obk> conal: Because this made the whole thing scale and work on multiple cores
11:05:58 <wli> I wonder how qualified types would mix with subtyping.
11:06:08 <conal> obk: oh.
11:06:16 <obk> conal: The Japanese tried distributed unification and multiple writers in their 5th generation project. Miserable failure
11:06:33 <noobi1> yeah i could
11:06:39 <conal> obk: yeah. bummer.
11:06:40 <obk> conal: Anyway, I always believed this is the best way to handle concurrency...
11:06:50 <conal> i suspect that i'm using "futures" differently from the PL literature.  mine are values that can't be known in the present, not just a concurrency mechanism.
11:06:51 <noobi1> how do i view the ban list?
11:07:08 <obk> conal: I thought Haskell's IVar's are similar, but they are in IO which defeats the whole purpose. Should have been in ST.
11:07:13 <Heffalump> noobi1: in my client, /bans lists them.
11:07:19 <Saizan> jimstutt: you may need to :set -fglasgow-exts to allow foralls in type signatures
11:07:44 <conal> obk: do you know of an IVar reference?
11:07:57 <obk> conal: Nope :-)
11:08:22 <conal> obk: i'll find one
11:09:04 <conal> awkward, as Ivar is a common name
11:09:06 <obk> conal: How do Futures work in context of multi-cores? I guess you still need explicit 'par' statements - but would it be possible to assign to one in one thread and block on it until assigned in another?
11:09:21 <noobi1> it's saying unknown command
11:09:25 <thetallguy> conal: what floating types don't have infinities?  Non-IEEE?
11:09:51 <conal> augustss: response for thetallguy ?
11:10:11 <Saizan> thetallguy: Rational, so yes, non-ieee
11:10:29 <mauke> noobi1: /mode +b
11:10:52 * obk doesn't see why the 't' value is important to the Future pattern - probably missing something about how it is to be used
11:10:58 <thetallguy> Saizan: the Rational's are implemented in Haskell, aren't they?
11:11:47 <conal> obk: i'm not sure how to understand your question about multi-cores.  Any haskell value is uniquely determined, however it is computed.  couldn't get different values in different threads.
11:11:48 <Saizan> thetallguy: yes, as continued fractions
11:12:07 <wli> No, as pairs of Integers.
11:12:25 <wli> Numerator and denominator.
11:12:33 <obk> conal: agreed; what I wondered was whether I could use these for synchronization (like IVars)
11:12:38 <Saizan> ah, ok :)
11:12:47 <conal> obk: about 't': yeah.  i didn't motivate it here.  it can be queried in 'force', but more usefully for things like snapshotting continuously changing quantities.
11:12:48 <noobi1> it is not returning anything
11:12:54 <noobi1> just blank
11:12:59 <conal> obk: i think so.  gotta learn about IVars.
11:13:18 <conal> augustss: do you know where i could learn about IVars?
11:13:19 <obk> conal: So it isn't single-assignment? I can enter two different values into a Future at different times?
11:13:22 <conal> anyone else?
11:13:25 <ddarius> @src Rational
11:13:26 <lambdabot> type Rational = Ratio Integer
11:13:32 <conal> obk: no way
11:13:41 <conal> a single value
11:13:46 <obk> So... continusly changing quantities...?
11:13:59 <conal> obk: oh.  i see.
11:14:06 <thetallguy> I don't understand why that invalidates Conal's proposal for Float and Double
11:14:20 <conal> there's a separate, related type of time-varying values.
11:14:23 <Heffalump> noobi1: do you have an email address I could send the list to?
11:14:39 <conal> and a use of futures that "unfolds" into an infinite stream of futures.
11:14:55 <conal> for punctuating continuous behaviors (functions of time)
11:14:59 <noobi1> ferronrsmith@gmail.com
11:15:02 <conal> as in Fran
11:17:07 <Heffalump> noobi1: sent
11:18:25 <thetallguy> Okay, I didn't ask the right question.  What Double and/or Float types don't have infinities?
11:18:51 <Heffalump> thetallguy: H98's
11:18:58 <Heffalump> it's not guaranteed, at any rate
11:19:04 <ddarius> :t isIEEE
11:19:05 <lambdabot> forall a. (RealFloat a) => a -> Bool
11:19:10 <Heffalump> I don't know of any implementation that doesn't use the IEEE machine representations
11:19:23 <conal> that's the rub
11:19:27 <thetallguy> Heffalump: okay, that's what I thought.
11:19:42 <thetallguy> Saizan's point about Rational is a different issue
11:20:00 <thetallguy> conal: Seems like a proposal for Haskell' then?
11:20:04 <conal> i guess i can only have actual portability but not theoretical portability.
11:20:17 <conal> thetallguy: i suppose so
11:20:30 <thetallguy> conal: you could if Double and IEEEDouble were separate
11:20:54 <conal> thetallguy: a new type (IEEEDouble)?
11:21:04 <thetallguy> or rather, you had IEEEDouble and OtherDouble, then machine dependent Double = IEEEDouble
11:21:17 <thetallguy> or Double = OtherDouble
11:21:45 <thetallguy> Not sure if that's the right answer, but it seems like the types of Doubles should be more specific to represent the implementation of the machine
11:25:44 <conal> thetallguy: i'm going to drop it for now, as i like the added generality i get from not assuming Bounded, and using an AddBounds wrapper (see http://hpaste.org/4223) instead.  then i can use *any* Ord type for "time" at this level.
11:26:40 <conal> though i would like to be able to rely on infinities for Float & Double, in general.
11:27:09 <conal> doesn't seem worth my effort to push the issue in a committee, though.
11:29:02 * obk still misses the point - why is it not enough to have a single bit (known/unknown) such that an unknown value can become known and that's it
11:29:41 <conal> obk: i'm defining *semantics* here
11:30:38 <obk> conal: What semantics can you define with 't' that you can't with 'is_known' and a single transition?
11:30:55 <conal> obk: specifically, a *denotational* semantics
11:31:07 <obk> As long as you are describing the system as an evolving state with transitions, that is
11:31:09 <conal> (i'm so biased, i forget to mention "denotational")
11:31:37 * obk scrambles for Wikipedia to get the point :-)
11:32:59 <obk> Hmmm.... Nope, sorry, still don't get it... denotational semantics is fine with an evolving state. State-before -> State-after
11:33:05 <obk> No 't' necessary
11:33:30 <obk> And, speaking from a practical implementation point of view, again I don't see why you need a time field instead of a bit
11:33:49 <conal> obk: my semantic domain for Future a is just (Time,a).  i don't know of a simpler model.
11:33:51 <Heffalump> conal: did you answer my question about the time associated with "the next key I press"?
11:34:02 <Heffalump> obk: ordering matters
11:34:19 <conal> Heffalump: oops.  missed it.  what was the question?
11:34:44 <obk> conal: (IsKnown,a)? (True,a) > (False,_)?
11:34:46 <Heffalump> what is the time associated with that future? Do we need a different underlying Time to the one for "the price of Lambdapix next Monday at noon"?
11:35:08 <Heffalump> obk: you can't decide which of two futures will happen earlier, then
11:35:26 <obk> You don't decide... one will be computed ahead of the other
11:35:34 <obk> Will be knowable ahead of the other
11:35:55 <Heffalump> obk: right, but conal's interface means you do know.
11:35:56 <conal> i always like to start with a clear (denotational) semantics.  if i can't get that simple & compelling, then there's no point in implementing anything, as it would be a mess to use.
11:36:15 <obk> Ah, I see... you are working around the fact there is no explicit IsKnown(x) in Haskell so you simulate it
11:36:34 <conal> Heffalump: your question is what type to use for time in those two examples?
11:36:50 <Heffalump> conal: specifically, do you have to use different types for the two examples?
11:37:04 <obk> But that doesn't make much sense either. If I have two Futures, the value for both is still unknown, I still can't compare them because the time at which they will be known is not yet known...
11:37:05 <conal> obk: because there's no IsKnown(x) in math.
11:37:09 <Heffalump> if you do, then choices of types are obvious (e.g. sequence number of the key press, and real time)
11:37:12 <conal> haskell happens to be like math.
11:37:18 <conal> which is why i like it
11:37:24 <obk> conal: Depends which math - there are such things as tempral logic systems
11:37:47 <obk> The trick is to make them behave "nicely" which is what DFCP did. Single assignment helped avoid most of the complexity
11:37:53 <conal> obk: ("But that doesn't ...")  i think you're talking about implementation, which i'm not addressing at all.
11:38:18 <obk> conal: I see, so this is just a theoretical concept? No an actual Haskell library? ;-)
11:38:45 <conal> obk: it's the semantic basis (specification) for what will be a library.
11:39:26 <conal> obk: (re: temporal logic comment) can you think of anything as fundamentally simple as (Time,a) as a semantic model?
11:39:51 * obk ponders. I suppose you could define semantics with a universal 't', and then avoid it in the implementation because by definition there is the "clock time" to use...
11:40:15 <ddarius> obk: The whole point is that there may be multiple ways of implementing the semantics.
11:40:27 <ddarius> You don't want to bake in one particular one at the get-go.
11:41:08 <ddarius> Instead, you want to work with whatever is most intuitive/mathematically nice.
11:41:26 <conal> ddarius: exactly.  thanks.
11:41:59 <obk> Hmmm. FWIW - in DFCP the idea was that the state of the system was the current active list of, let's say "uncomputed function calls", and the semantics was defined as doing one step at a time - replacing a cal;l with its body _and_ assigning values to some writers. So 't' was discrete (in theory) and wasn't part of the semantics model.
11:42:03 <conal> if the semantics as simple & powerful then it's worth implementing.  and it defines correctness of the implementation.
11:42:15 <Brian`> hi, I have a question, how can I apply a function to evert element in list of list? like the ones in [[1,2,3],[4,2,3],[7,3,2]]
11:42:23 <Heffalump> Brian`: map (map f)
11:42:25 <ddarius> map . map
11:42:45 <conal> obk: sounds like an operational semantics.  denotational is my personal preference.
11:42:48 <obk> In practice of course you could replace more than one function by its body (and assignments) at "the same time" which allowed for parallel/distributed implementation... but the semantics didn't require/forbid it.
11:42:58 <obk> conal: Gotcha.
11:43:17 <Brian`> Heffalump, ddarius: oki doki
11:43:21 <obk> Well, part of it was determinism. Do you expect your semantics to be deterministic?
11:43:27 <conal> i've got to start mentioning that up front and not assume that my bias is shared.
11:43:36 <obk> Same input, always same output?
11:43:41 <conal> obk: if it weren't deterministic, it couldn't have a simple semantics.
11:43:44 <thetallguy> conal: or join #haskell-british
11:43:51 <obk> If so I see your point, with 't' you have no indeterministic decision points
11:44:09 <conal> thetallguy: is that where my kindred spirits are hiding? :)
11:44:37 <obk> Well, in the real world, once you depend on 't' for something, it becomes indeterministic. A program waiting for the earlier of a disk event and a keyboard event will hardly ever run the same time twice...
11:44:45 <ihope> Is there a shorter way to express patterns like 'f':'o':'o':x?
11:44:46 <thetallguy> conal: http://cliffordbeshers.blogspot.com/2007/11/british-programming-style.html
11:44:50 <lambdabot> Title: RuMiNaTiOnS: British Programming Style, http://tinyurl.com/2uxkyx
11:45:12 <obk> Which I guess is why DFCP went with operational semantics. If you manage to define formal deterministic semantics for this, it would be interesting result.
11:45:44 <mauke> ihope: no
11:46:31 <conal> ihope: drop one of the "o"s ;)
11:47:00 <thetallguy> conal: nice ;-)
11:47:23 * ihope continues yelling at the GHC people :-P
11:47:24 <bringert> ihope: x | "foo" `isPrefixOf` x = ... (drop 3 x) ..., if the prefix is long
11:47:46 <ihope> I think I'll use regexes.
11:48:01 <thetallguy> ihope: you might want to look at Harp
11:48:05 <conal> thetallguy: thanks for the british reminder.  i'd read it and forgotten.  it's a *terribly* strong, gut-level bias.  operational semantics leave me stone cold, like imperative programming.
11:48:34 <thetallguy> conal: I know the feeling
11:48:37 <mauke> x' | Just x <- dropPrefix "foo" x' = ...
11:48:38 <bringert> ihope: or y | ("foo",x) <- splitAt 3 y = ... x ...
11:49:20 <thetallguy> conal: I had an aha! moment a couple of years ago.  I was reading some FP book or paper, that said 'a type is a set of values'
11:49:38 <conal> about ihope's question: i wonder why string literals were hacked into the language for expressions but not patterns.
11:50:06 <conal> thetallguy: yes!  and by looking at just the nature of the set and nothing else you can learn a lot about the language.
11:50:10 <dmwit> They *are* patterns!
11:50:23 <thetallguy> conal: and I realized that if I asked for a definition, my C reflexes would have kicked in and I would have talked aboutword length, memory layout, etc.
11:50:26 <bringert> just not terribly useful patterns
11:50:27 <Toxaris> > let f "foo" = 42 in f "foo"
11:50:29 <dmwit> > let f "hey" = "for real!"; f x = "not hey" in (f "hey", f "there")
11:50:32 <lambdabot>  42
11:50:32 <lambdabot>  ("for real!","not hey")
11:50:35 <conal> thetallguy: i guess that's why i have such a strong distaste for IO also.  i can't help thinking about the semantic domain for it.
11:50:48 <conal> which is the most complex thing possible.
11:51:01 <conal> hey, that insight explains a lot to me.
11:51:03 <dmwit> It's like asking why you can't do "f ([3,4,5]:xs)".
11:51:04 <thetallguy> conal: my brother was here recently, a biologist, and he asked what the fuss about FP was.
11:51:07 <dmwit> It's not fair.
11:51:14 <bringert> > let "foo" = "bar" in 3
11:51:15 <lambdabot>  3
11:51:19 <thetallguy> conal: and in fact, he asked what is FP?
11:51:36 <dmwit> > let "foo" = "bar" in "foo" -- the obvious next test
11:51:37 <lambdabot>  "foo"
11:51:57 <dmwit> huh
11:52:05 <conal> thetallguy: great question.
11:52:10 <thetallguy> conal: Nothing made any sense until I descriped static typing as:
11:52:13 <ihope> > let blah ("foo" ++ x) = x in blah "foobar"
11:52:13 <lambdabot>  Parse error in pattern at "in" (column 27)
11:52:22 <conal> funny juxtaposition.
11:52:28 <dmwit> (++) is a function...
11:52:33 <ihope> What a strange place for a parse error.
11:52:52 <ihope> Seems the code for this would be similar to that for n+k patterns.
11:52:53 <thetallguy> conal: ensuring that if two functions are composed. that the range of the second is identical to the domain of the first
11:52:54 <conal> oh -- i see that my comment about literal patterns was *way* out in left field.
11:53:20 <thetallguy> conal: and he said, why would anyone not want that?
11:54:42 <thetallguy> conal: a question related to the infinities
11:56:03 <LoganCapaldo> hmmm
11:56:05 <thetallguy> conal: if you were trying to show a lexicographic range, and you started with the full set of strings, what would you start with as the min and max?
11:56:41 <LoganCapaldo> Do n+k only work for built in types or any instance of Num?
11:57:01 <darrint> I have a question about this: last $ take 2 $ iterate (execState dealOneRound) g ; That has the effect of executing dealOneRound only 1 time. Why?
11:57:19 <conal> thetallguy: are you asking what would be the min and max strings made of a given alphabet?
11:57:42 <mauke> darrint: what did you expect?
11:57:51 <LoganCapaldo> @type execState
11:57:52 <thetallguy> no, I'm asking what you would show in a UI
11:57:53 <lambdabot> forall s a. State s a -> s -> s
11:58:00 <dmwit> darring: you probably want (execState (dealOneRound >> dealOneRound)) or so.
11:58:02 <darrint> That it would execute dealOneRound twice.
11:58:07 <mauke> darrint: why?
11:58:18 <thetallguy> instead of any string, assume english words
11:58:18 <darrint> My intention is to run it 7 times.
11:58:31 <dmwit> darrint: See replicateM.
11:58:36 <dmwit> :t replicateM
11:58:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:58:39 <darrint> When I change the count to 7 it runs it six times.
11:58:47 <darrint> :i replicateM
11:58:48 <thetallguy> conal
11:58:59 <sclv> @src replicateM
11:58:59 <lambdabot> replicateM n x = sequence (replicate n x)
11:59:08 <thetallguy> ; trick question. ;-)
11:59:44 <mauke> :t iterateM
11:59:44 <lambdabot> Not in scope: `iterateM'
11:59:58 <Brian`> what's the difference between kind and type?
12:00:00 <conal> thetallguy: do you mean how would i show an infinite string in a widget?
12:00:09 <sclv> :t replicate
12:00:09 <conal> Brian`: spelling.
12:00:10 <lambdabot> forall a. Int -> a -> [a]
12:00:19 <mauke> Brian`: kinds are type types
12:00:19 <byorgey> Brian`: kinds classify types, just as types classify values.
12:00:25 <LoganCapaldo> Brian`: kind is "just" the type of a type
12:00:26 <conal> Brian`: yeah, that.
12:00:39 <Brian`> so kind is type of types?
12:00:53 <conal> yep
12:00:59 <byorgey> for example, Int, Bool, Double :: *.  Maybe, [] :: * -> *.
12:01:01 <ddarius> Brian`: The kind system is a type system for the type system.
12:01:06 <thetallguy> conal: no, a range indicating all words in the dictionart, without using <=
12:01:09 <Toxaris> > take 10 $ iterate succ 0 -- begins with 0, not with 1. iterate f x = [x, f x, f (f x), ...], not [f x, f (f x), ...]
12:01:10 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
12:01:17 <thetallguy> just <
12:01:34 <thetallguy> conal
12:01:42 <thetallguy> conal
12:01:46 <thetallguy> doh
12:01:56 <ddarius> (type of types while catchy has the issue that most of the reason for the kind system is due to things that aren't types, namely type constructors)
12:02:17 <thetallguy> conal: no worries, the question wil lmake sense when I finish one of my current projects.
12:03:19 <byorgey> Brian`: Maybe :: * -> *, so Maybe Int :: *.  Just like negate :: Int -> Int, so negate 3 :: Int.
12:03:23 <Brian`> ah... so :kind is used to find out how many types are needed for multiparameter type constructor?
12:03:40 <ddarius> Brian`: The reason for the kind system is to disallow stuff like 'Int Bool' or 'Maybe [] Int'
12:03:47 <byorgey> Brian`: essentially, yes.
12:03:49 <ddarius> :t undefined :: Int Bool
12:03:49 <lambdabot>     Kind error: `Int' is applied to too many type arguments
12:03:49 <lambdabot>     In the type `Int Bool'
12:03:49 <lambdabot>     In an expression type signature:
12:03:52 <conal> thetallguy: okay.
12:04:06 <Brian`> that makes sense :) thanks guys
12:04:14 <LoganCapaldo> :t undefed :: Maybe
12:04:15 <lambdabot> Not in scope: `undefed'
12:04:20 <byorgey> Brian`: although it's also for finding out not just how *many* types are needed for a multiparameter type constructor, but what their kinds should be.
12:04:20 <LoganCapaldo> :t undefined :: Maybe
12:04:21 <lambdabot>     `Maybe' is not applied to enough type arguments
12:04:21 <lambdabot>     Expected kind `?', but `Maybe' has kind `* -> *'
12:04:21 <lambdabot>     In an expression type signature:
12:04:38 <ddarius> :k StateT
12:04:38 <lambdabot> * -> (* -> *) -> * -> *
12:04:59 <LoganCapaldo> :k Kleisli
12:04:59 <Brian`> :k stateT Int Maybe Int
12:04:59 <lambdabot> (* -> *) -> * -> * -> *
12:04:59 <lambdabot> Not in scope: type variable `stateT'
12:05:07 <Brian`> :k StateT Int Maybe Int
12:05:07 <lambdabot> *
12:05:11 <byorgey> Brian`: ^^^ StateT takes three type arguments, but the second one must itself be a type constructor of kind * -> *.
12:05:20 <byorgey> Brian`: right, you've got it =)
12:05:24 <Brian`> gotcha :)
12:05:25 <Brian`> hehe
12:05:31 <darrint> ok. replicateM does the same thing:
12:05:34 <Brian`> thank you so much everyone
12:05:38 <darrint> last $ replicateM 2 (execState dealOneRound) g
12:05:56 <darrint> ... gets me the state just before the one I'm interested in. :-P
12:06:14 <mauke> iterate (execState dealOneRound) g !! 2
12:06:51 <dmwit> :t execState
12:06:51 <lambdabot> forall s a. State s a -> s -> s
12:07:14 <Brian`> and is undefined special symbol?
12:07:19 <Brian`> :t a::Int doesn't work
12:07:24 <LoganCapaldo> @src undefined
12:07:24 <lambdabot> undefined =  error "Prelude.undefined"
12:07:25 <Brian`> where as :t undefined :: Int works..
12:07:25 <lambdabot> Not in scope: `a'
12:07:30 <mauke> Brian`: no, it's in the standard library
12:07:34 <dmwit> darrint: That doesn't even look like it type-checks.
12:07:37 <darrint> So if I think of this as a list of states, the one at index zero is the initial state, but I don't understand why that is.
12:07:43 <mauke> dmwit: yes, it does
12:07:49 <LoganCapaldo> :t error "exceptions can be any type" :: Maybe Float
12:07:50 <lambdabot> Maybe Float
12:07:52 <mauke> ok, that doesn't
12:08:02 <mauke> darrint: because that's how iterate works
12:08:02 <ddarius> :t error "foo"
12:08:03 <lambdabot> forall a. a
12:08:10 <ddarius> :t let undefined = undefined in undefined
12:08:11 <lambdabot> forall t. t
12:08:11 <darrint> dmwit: It does type check.
12:08:26 <ddarius> @src iterate
12:08:26 <lambdabot> iterate f x =  x : iterate f (f x)
12:08:36 <darrint> mauke: What is weirding me out is that replicateM is doing the same thing.
12:08:59 <mauke> huh?
12:09:04 <dmwit> :t replicateM
12:09:07 <LoganCapaldo> > [0,1,2] !! 2
12:09:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:09:08 <lambdabot>  2
12:09:11 <mauke> replicateM should give you the same result N times
12:09:15 <LoganCapaldo> > replicate 2 ()
12:09:16 <lambdabot>  [(),()]
12:09:32 <mauke> or am I doing it wrong?
12:10:01 <dmwit> Oh, the Reader instance.
12:10:06 <dmwit> =P
12:10:17 <mauke> > runState (replicateM 2 (modify succ)) 0
12:10:24 <lambdabot>  ([(),()],2)
12:10:41 <Taejo> :t runState
12:10:41 <mauke> > execState (replicateM 2 (modify succ)) 0
12:10:42 <lambdabot> forall s a. State s a -> s -> (a, s)
12:10:42 <lambdabot>  2
12:10:46 <dmwit> > replicateM 2 (runState (modify succ)) 0
12:10:47 <lambdabot>  [((),1),((),1)]
12:11:07 <dmwit> mauke: Look at his thing again, replicateM is *outside* of execState. =P
12:11:27 <Taejo> :t modify
12:11:28 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
12:12:26 <Toxaris> darrint: you normally don't call runState et. al. all the time, but instead combine the monadic actions to bigger monadic actions to be executed at once
12:13:13 <darrint> Ok. I'm trying to move the execState outside replicateM like was said but I can't quite get it to type check.
12:13:16 <mauke> Toxaris: execState gives you a pure function of type s -> s
12:13:27 <mauke> I don't see what's wrong with giving that to iterate
12:13:34 <Toxaris> mauke: nothing.
12:14:34 <Toxaris> mauke: but is it good design?
12:14:42 <mauke> sure
12:14:58 <Toxaris> darrint: is replicateM the right combinator?
12:15:07 <darrint> (execState $ replicateM_ 2 dealOneRound) g
12:15:10 <dmwit> ddarint: last . execState . replicateM 2 dealOneRound $ g
12:15:17 <darrint> That does what I want and I can almost imagine it being correct. :-)
12:15:24 <Toxaris> darrint: you want to execute the same action multiple time in sequence, and accessing the final result only? (correct?)
12:15:31 <darrint> Toxaris: yes.
12:15:36 <dmwit> ddarius: Yeah, that.
12:16:27 <Heffalump> noobi1: did you ever reply about the ban? If so I missed it.
12:17:17 <darrint> dmwit: I don't think your last . execState suggestion is right, btw. ghci won't run it and it might inherit that off by one error.
12:17:40 <dmwit> darrint: No, my last suggestion is definitely wrong.
12:17:44 <dmwit> (sorry)
12:18:08 <byorgey> darrint: what's the type of dealOneRound?
12:18:13 <darrint> not a problem. I did find a replicateM_ way that worked well and looks like the best way to express this.
12:18:26 <Toxaris> darrint: will dealOneRound return something usefull, or change the "internal state" of the monad in some usefull way?
12:18:26 <darrint> dealOneRound :: State GameState ()
12:18:35 <byorgey> darrint: yes, what you wrote above looks good to me.
12:18:44 <darrint> thanks for the help again all.
12:18:49 <Toxaris> darrint: so replicateM_ is the way to go
12:19:05 <darrint> Toxaris: it definitely feels like the right way to express this. deal 7 rounds.
12:19:38 <Cheery> I'd need to know a string searching algorithm that works neat with buffered input and multiple strings to search
12:21:35 <mauke> http://www.google.de/search?q=p333-aho-corasick.pdf
12:21:35 <lambdabot> Title: p333-aho-corasick.pdf - Google-Suche
12:25:05 <LoganCapaldo> @type replicateM_
12:25:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
12:25:35 <LoganCapaldo> let times = replicateM_ in 7 `times` dealOneRound
12:26:38 * dmwit tries to imagine what replicateM_ means in Reader.
12:26:47 <dmwit> replicateM_ x m = return () -- ?
12:27:14 <darrint> Now you're all just being silly. :-)
12:28:31 <byorgey> dmwit: yeah, Reader () isn't very useful =)
12:28:37 <ddarius> dmwit: Correct.
12:28:46 <njbartlett> 424 members!
12:29:05 <ddarius> njbartlett: We were up to 432?, 436? yesterday.
12:29:12 <ddarius> But lambdabot forgot again.
12:29:14 <ddarius> @users
12:29:14 <lambdabot> Maximum users seen in #haskell: 428, currently: 424 (99.1%), active: 20 (4.7%)
12:29:19 <Olathe> :t replicateM_
12:29:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
12:29:42 <njbartlett> ddarius: Not bad!
12:29:55 <joelr1> good evening
12:30:04 <dmwit> Hiya joelr1!
12:30:04 <njbartlett> Hi! How's the book going?
12:30:28 <Olathe> @djinn Int -> m a -> m ()
12:30:28 <lambdabot> -- f cannot be realized.
12:30:32 <joelr1> njbartlett: slowly :) just 1 chapter written of about 10. i did write it in just a few hours, though
12:30:37 <Olathe> As you can see, replicateM_ is unpossible.
12:30:52 <dmwit> ?djinn (Monad m) => Int -> m a -> m ()
12:31:04 <darrint> Which book is this?
12:31:11 <njbartlett> joelr1: Do you have a deadline? Or do the prags go easy on that sort of thing?
12:31:12 <joelr1> darrint: erlang
12:31:13 <Olathe> That's so unpossible, lambdabot can't even comment.
12:31:23 <joelr1> njbartlett: no deadline
12:31:27 <dmwit> lambdabot: *poke*
12:31:36 <LoganCapaldo> @type let replicateM_ 0 _ = return () ; replicateM_ n a = a >> replicateM_ (n - 1) a in replicateM_
12:31:37 <lambdabot> forall t (m :: * -> *) a. (Num t, Monad m) => t -> m a -> m ()
12:31:58 <darrint> Ah. Good luck on it. Should have an impact.
12:32:10 <dmwit> ?type let replicateM_ n m = sequence_ (replicate n m) in replicateM_
12:32:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
12:32:16 <njbartlett> darrint: *Hardcore* Erlang, even.
12:32:32 <joelr1> darrint: thank  you
12:32:41 <joelr1> bringert: thanks in advance :-)
12:32:45 <LoganCapaldo> dmwit: bah who needs a list?
12:32:50 <darrint> heh
12:32:58 <njbartlett> joelr1: I met Joe Armstrong recently, he seemed suitably amused ;-)
12:33:07 <dmwit> LoganCapaldo: Bah, who needs a call stack?
12:33:12 <joelr1> njbartlett: amused about?
12:33:37 <njbartlett> joelr1: The idea of building a stock exchange on EC2
12:34:00 <LoganCapaldo> @src sequence_
12:34:00 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:34:34 <joelr1> njbartlett: well, i don't think i'm gonna be able to build a stock exchange in the book. i couldn't figure out how to weave the book around it. it's gonna be more like a suitably complex project per chapter.
12:34:57 <joelr1> njbartlett: or just explanations of complex workings of erlang with some examples
12:35:01 <dmwit> LoganCapaldo: Rats, I was hoping you'd say something about tail-call optimization.  I actually had a retort for that. =P
12:35:24 <joelr1> njbartlett: i will have to leave stock exchanges for my blog
12:35:29 <njbartlett> joelr1: Ah, oh well. Sounds fair enough. I know how hard it is to weave narrative around a single meaty example
12:35:32 <LoganCapaldo> dmwit: I was just trying to figure out what your argument was <g>
12:35:46 <joelr1> njbartlett: how's your end of things?
12:35:47 <LoganCapaldo> I almost just said "both of us?"
12:36:37 <dmwit> Anyway, with list fusion, the recursive definition and the sequence_ definition should act pretty damn similarly.
12:36:54 <njbartlett> joelr1: My end is fine. Hey, if you're ever up near London do you have anything you could talk about at the HUG?
12:37:49 <joelr1> njbartlett: probably in the near future. i will have something to talk about. i don't think i'll be near london in the next few months, though.
12:38:10 <njbartlett> joelr1: Okay, well drop me a line if and when you think you can?
12:38:42 <joelr1> njbartlett: sure
12:42:46 <glguy> ?seen dons
12:42:46 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 11m 1s ago.
12:44:13 <nottha_k> http://hpaste.org/4224 is there any way to fix this with cabal-install? or do I have to manually download it and edit the cabal file and do the tedious Setup.lhs stuff?
12:45:24 <Saizan> nottha_k: the latter
12:46:38 <dons> glguy: ?
12:51:03 <Taejo> anybody got any tips on removing a mole from a room? my cat will kill it if I don't find it. :)
12:51:30 <asl> well ... you could confine the cat temporarily to buy time
12:51:40 <ptw> "Seems like spam could be used to actually get a message out in a very quick and widespread way about injustice, working for peace, and other political issues.  Why hasn't this happened yet? Spamming is so easy and inexpensive - seems like a perfect tool for subversion."
12:51:40 <ptw> WORLD PEACE THROUGH MARIJUANA   www.havethisbook.com   very interesting FREE non-fiction, enjoy, newly updated!
12:51:42 <ptw> :]
12:52:06 <mauke> someone kickban ptw
12:52:07 <asl> huh
12:53:05 <Taejo> asl, done, but I can't keep it out forever
12:53:26 <asl> Taejo, no, cats are strange and clever creatures
12:53:44 <Taejo> but moles are so cute and helpless
12:53:51 <olsner> so you have a pet cat and a pet mole?
12:53:54 <ptw> man, NOBODY wants world peace!
12:54:18 <Taejo> olsner, no, I have a pet cat and a wild mole strayed into my house
12:54:43 <dmwit> ptw: No, nobody wants spam.  Get off my internet!
12:54:51 <olsner> ah, I see
12:56:04 <dotsintacks> what's the best environment to poke about and play with haskell on my mac?
12:56:24 <dotsintacks> (by environment I think I mean compiler/editor/IDE combo)
12:56:42 <dmwit> I use GHC+Vim.
12:57:07 <dmwit> Pretty much everybody here uses GHC, I think.
12:57:19 <dmwit> Vim and emacs of course is a bit of a holy war.
12:57:33 <dmwit> (Though there's a higher ratio of vim users here than I see in the wild.)
12:57:49 <dotsintacks> I see mention of fink...do I need a unix packaging system on my fresh leopard install just to get going? :(
12:57:55 <njbartlett> TextMate would probably be the popular developer choice on Mac.
12:57:59 <dmwit> No!
12:58:01 <wli> I use nvi, though it's still a bit bloated for my tastes.
12:59:01 <dmwit> http://www.haskell.org/ghc/download_ghc_681.html -- aren't these binary distributions for MacOSX?
12:59:01 <lambdabot> Title: GHC: Download version 6.8.1
12:59:30 <dotsintacks> says I need GNU readline.
12:59:39 <ddarius> dmwit: There are a higher ratio of emacs users here than seen in the wild too.
12:59:43 <dmwit> Oh, yes, that's true.
12:59:45 <dotsintacks> "preferably through macports".
13:00:08 <dmwit> ddarius: Ah, interesting point.
13:00:10 <LoganCapaldo> I bet the ratio of Yi users in here is probably _huge_ compared to the wild ;)
13:00:21 <wli> A bunch of people have some bizarre notion of tabs vs. spaces, too.
13:00:24 <dmwit> How much would you bet?
13:00:53 <wli> Where I come from a tab is a tab is a tab.
13:00:54 <esteban2> paste?
13:01:14 <dmwit> ?hpaste
13:01:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:01:25 <esteban2> thanks
13:02:28 <hpaste>  esteban2 pasted "tuples" at http://hpaste.org/4225
13:02:41 <esteban2> can anyone have a look at that? i'm just getting a bit confused with tuples
13:03:14 <mauke> [(_,(d,e,f),_):xs] -> ((_,(d,e,f),_):xs)
13:03:49 <dmwit> Right.  Also, check your indentation.
13:04:05 <esteban2> ok
13:04:06 <dmwit> And you may be interested in type synonyms, or, even better, record syntax.  But one thing at a time, I guess. =)
13:04:22 <esteban2> yes, i know that.. but i was just not using them not to confuse me even more :)
13:04:51 <shachaf> LoganCapaldo: I think there are about as many Yi users here as anywhere else.
13:04:51 <hpaste>  mauke annotated "tuples" with "(no title)" at http://hpaste.org/4225#a1
13:05:31 <LoganCapaldo> shachaf: what, 0?
13:05:50 <shachaf> LoganCapaldo: Yes.
13:05:53 <dmwit> LoganCapaldo: Yeah, that's why I asked how much you wanted to bet. =)
13:05:57 <darrint> Is there a built in way to pretty print records?
13:06:08 <shachaf> LoganCapaldo: Yi isn't meant to be used as an editor. :-)
13:06:08 <wli> show
13:06:08 <hpaste>  mauke annotated "tuples" with "(no title)" at http://hpaste.org/4225#a2
13:07:26 * Taejo has rescued the mole
13:07:56 * dons thanks ndm for tagSoup
13:08:17 <dons> i get to use list comprehensions instead of regexes
13:09:04 <asl> if anyone wants to read about some fun I had with knot-tying, I recently wrote up the backwards state monad in a recent blog post: http://panicsonic.blogspot.com/2007/12/backwards-state-or-power-of-laziness.html .  Feedback is appreciated.
13:09:05 <lambdabot> Title: FS: Backwards State, or: The Power of Laziness, http://tinyurl.com/3acj9w
13:10:22 <hpaste>  LoganCapaldo annotated "tuples" with "(no title)" at http://hpaste.org/4225#a3
13:11:36 <v3cw> Quick question.
13:11:50 <v3cw> What's the easiest way to update an element from a 2 dimensional list?
13:12:02 <esteban2> thanks for all the ideas, but the 2nd one was more than just enough :)
13:12:08 <LoganCapaldo> esteban2: if you leave off the isJust you can actually get the value with that date
13:12:09 <dmwit> Consider using an Array for updates.
13:12:11 <v3cw> Right now I'm using 'take', 'drop', and ++, but it feels like a hack.
13:12:48 <dmwit> Also, consider carefully whether there is an algorithm that doesn't require such updates.
13:13:14 <dmwit> (There is not always a correspondingly update-less algorithm, but there often is.)
13:13:36 <v3cw> I mean "update" in the functional sort of way.
13:13:39 <v3cw> Not mutable updates.
13:14:12 <v3cw> I basically just want to replace the element (x, y) with 'val' and have a new list pop back to me.
13:14:17 <shachaf> v3cw: But still, linked lists aren't the best for that.
13:14:21 <dmwit> Yes, I understand.
13:15:31 <v3cw> Is there a library function that does what I want?
13:15:53 <v3cw> Maybe for 1 dimensional lists?
13:15:55 <shachaf> v3cw: You'd have to walk through the entire list to get to the element you want.
13:16:00 <nottha_k> http://hpaste.org/4226 problem building regix-posix. i'm trying to build yi. and so far it hasn't been very user friendly :)
13:16:06 <v3cw> shachaf, I'm not worried about performance.
13:16:22 <dmwit> v3cw: See splitAt if you are really stuck on [] rather than Array.
13:16:40 <shachaf> v3cw: You should still use an Array, probably.
13:17:18 <dmwit> nottha_k: What version of GHC?  (I don't know how to fix it, I'm just curious.)
13:17:19 <shachaf> I guess something based on splitAt would be best, otherwise.
13:17:37 <v3cw> How would using an Array simplify anything?
13:17:40 <LoganCapaldo> @let update i v xs = [ if i == i' then v else x | (i', x) <- zip [0..] xs ]
13:17:42 <lambdabot> Defined.
13:17:57 <LoganCapaldo> > update 2 7 [1..10]
13:17:57 <lambdabot>  [1,2,7,4,5,6,7,8,9,10]
13:18:59 <pi3> How can I get the nth value of a list?
13:19:09 <v3cw> !!
13:19:11 <dmwit> :t (//) -- for v3cw
13:19:12 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
13:19:12 <shachaf> pi3: (!!), but that's O(n).
13:19:41 <dmwit> :t accum -- also for v3cw
13:19:42 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
13:19:47 <v3cw> I'm not really sure how to read 'forall' types.
13:19:57 <shachaf> v3cw: You can ignore the forall.
13:20:02 <dmwit> For those two types, just drop the forall preamble.
13:20:07 <shachaf> v3cw: It means... For all. :-)
13:20:14 <LoganCapaldo> > (update 0 3) . (update 9 3) $ [1..10]
13:20:18 <lambdabot>  [3,2,3,4,5,6,7,8,9,3]
13:20:23 <shachaf> "id :: forall a. a -> a" -- for every type a, id is a function from a to a.
13:20:26 <v3cw> forall is for dependent types, isn't it?
13:20:33 <shachaf> v3cw: No.
13:20:49 <v3cw> Let me rephrase that: it can be used for dependent types, can't it?
13:20:51 <shachaf> v3cw: Haskell doesn't have dependent types.
13:20:54 <LoganCapaldo> > update 1000 5 [1,2,3]
13:20:54 <lambdabot>  [1,2,3]
13:21:03 <v3cw> I thought I read somewhere that it did...
13:21:04 <v3cw> Oh well.
13:21:34 <dmwit> Existential types, phantom types, abstract data types, and several other fancy types, yes, but dependent types, no.
13:21:44 <Heffalump> GADTs come quite close
13:22:06 <Heffalump> in that you can determine from a value (i.e. a GADT constructor) what a type is
13:22:09 <shachaf> dmwit: You don't need forall for all those.
13:22:10 <LoganCapaldo> > take 3 (update 7 2 [1..10])
13:22:11 <lambdabot>  [1,2,3]
13:22:22 <ddarius> asl: You may want to look at the relationship between attribute grammars and lazy evaluation.
13:22:24 <dmwit> shachaf: Yes, I know.
13:22:40 <Toxaris> isn't forall for higher-rank types?
13:22:44 <v3cw> LoganCapaldo, yes, I got it the first time.
13:22:57 <v3cw> I'll go ahead and use splitAt, then.
13:23:01 <LoganCapaldo> v3cw: I long ago stopped doing it for your benefit :)
13:23:03 <v3cw> I suppose that's not as bad as take and drop.
13:23:03 <Heffalump> Toxaris: mostly. And for specifying that you want to use scoped type variables.
13:23:05 <shachaf> It's for a lot of things.
13:23:19 <v3cw> LoganCapaldo, you're initial function is more complicated than it needs to be, btw.
13:23:21 <v3cw> your
13:23:21 <dmwit> ?src splitAt
13:23:21 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
13:23:32 <dmwit> v3cw: ;-)
13:23:37 <v3cw> dmwit, I'm aware of that.
13:23:48 <dmwit> ok
13:23:49 <v3cw> dmwit, but it's faster than having to reference 'list' twice.
13:23:53 <shachaf> (That's not the actual source, of course.)
13:23:57 <v3cw> And by "faster" I mean shorter.
13:24:03 <dmwit> ok
13:24:20 <shachaf> @pl \n xs -> (take n xs, drop n xs)
13:24:20 <lambdabot> ap (ap . ((,) .) . take) drop
13:25:05 <LoganCapaldo> v3cw: how dare you call me an initial function! I'm not a function I'm a human being!
13:25:11 <LoganCapaldo> :p
13:25:53 <Heffalump> LoganCapaldo: you're a function ThingsObservedByLoganCapaldo -> ActionsOfLoganCapaldo
13:26:47 <dmwit> LoganCapaldo :: t -> State [Observation] Action
13:27:02 <pi3> What is the average time it would take to be able to use Haskell correctly? I'm talking about the learning curve
13:27:09 <glguy> 7
13:27:15 <ddarius> Good answer glguy
13:27:31 <glguy> pi3: repeat your question for grahamhutton
13:27:36 <glguy> He might have first hand experience
13:27:36 <Taejo> @localtime Taejo
13:27:38 <lambdabot> Local time for Taejo is Sun Dec  2 23:27:39
13:27:44 <LoganCapaldo> Heffalump, dmwit you guys only wish I was a pure function ;). I give different outputs for the same observations all the time :)
13:27:53 <SamB> man... golly is fast... I just ran a space filler out to some generation near 1.63385e+21...
13:27:56 * ddarius suspects that the variation makes "average" meaningless.
13:28:07 <dotsintacks> Can GHC make tiny executables?
13:28:12 <bringert> pi3: depends on how much of it you want to be able to use
13:28:20 <dmwit> dotsintacks: ...not really
13:28:34 <pi3> bringert: think in Haskell
13:29:04 <reinierrr> pi3: a few months if you do it in your free time?
13:29:06 <bringert> pi3: you want to think in Haskell? all your thoughts, or just those about programming?
13:29:11 <dmwit> SamB: Have you seen the DDJ article "An Algorithm for Compressing Time and Space" or some such?
13:29:24 <Heffalump> LoganCapaldo: you are incapable of observing the present time?
13:29:52 <SamB> dmwit: no, but I have heard that DDJ had an article about the hashlife algorithm...
13:29:52 <dotsintacks> I'm looking for a functional programming language that compiles to small executables with an extremely usable foreign functional interface
13:29:58 <pi3> bringert: well, all of my thoughts would be way too radical, interesting though
13:30:00 <dotsintacks> function*
13:30:08 <wli> > let { splitAt' _ [] (ys, zs) = (ys, zs) ; splitAt' 0 xs@(_:_) (ys, zs) = (ys, zs ++ xs) ; splitAt' n (x:xs) (ys, zs) = let (ys', zs') = splitAt' (n-1) xs (ys, zs) in (x : ys', zs') ; splitAt n xs = splitAt' n xs ([], []) } in splitAt 3 [1..10]
13:30:13 <reinierrr> i've reached the point that all my thoughts are in Haskell and I dream in lambda abstractions, and I feel terrible when I wake up and realize that I live in a stateful world. It took me about 3.5 years
13:30:14 <LoganCapaldo> Heffalump: watch battery died :p
13:30:19 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
13:30:22 <dmwit> SamB: Okay, that's the algorithm I was thinking of.  Yes, it's impressive, isn't it? =)
13:30:23 <bringert> pi3: like ddarius said, it's very different for different people. but we have introductory courses for first-year students that take 8 weeks
13:30:31 <Heffalump> dotsintacks: Try O'Caml. I don't know if it produces small binaries, but the standard Haskell implementation, GHC, certainly doesn't.
13:30:51 <wli> Heffalump: nhc98
13:30:53 <Heffalump> There's nhc, which may do somewhat better; I think people have experimented with using it on embedded devices.
13:31:00 <pejo> bringert, the students presumably take other courses during those 8 weeks as well?
13:31:00 <bringert> pi3: they can write some interesting programas after that, but there's of course lots more to learn
13:31:02 <SamB> dmwit: on extremely regular patterns exhibiting quadratic growth, yes, very!
13:31:17 <thoughtpolice> nhc does indeed make smaller executables.
13:31:19 <dmwit> ?users
13:31:19 <lambdabot> Maximum users seen in #haskell: 429, currently: 428 (99.8%), active: 24 (5.6%)
13:31:22 <dons> reinierrr: interesting. have a RealWorld#
13:31:23 <bringert> ah, yes, that would be half-time during 8 weeks
13:31:37 <pi3> bringert: I started learning Haskell a couple of days ago (I have some experience with imperative languages) and I find functional languages very different
13:31:51 <wli> pi3: Try logic languages.
13:32:08 <bringert> pi3: I think you're right
13:32:22 <dotsintacks> NHC has a link to YHC
13:32:24 <dotsintacks> but it 404sa
13:32:26 <dotsintacks> 404s*
13:32:35 <bringert> pi3: but it's not really difficult, just different
13:32:37 <pi3> bringert: so I'm reading the tutorial for C programmers, is there anything you suggest me to read or do?
13:32:41 <dons> dotsintacks: how small do you require the programs to be?
13:32:49 <dons> and what kind of computing resources are available?
13:32:51 <Heffalump> dotsintacks: there was a recent release announcement, so there should be a webpage somewhere
13:33:02 <reinierrr> dotsintacks: http://www.haskell.org/haskellwiki/Yhc
13:33:03 <lambdabot> Title: Yhc - HaskellWiki
13:33:11 <dotsintacks> I'm just feeling around for something to do some GUI development in that's not C++ or D.
13:33:28 <dons> oh, gui eh? well, ghc + gtk2hs might be fine then.
13:34:05 <bringert> pi3: think of simple programs and write them. preferreably ones without I/O to start with.
13:34:06 * Heffalump wonders why the troll's reddit karma is increasing when all his recent posts have zero or negative scores.
13:34:06 <dons> nhc release, fwiw, http://article.gmane.org/gmane.comp.lang.haskell.general/15770
13:34:07 <lambdabot> Title: Gmane -- Mail To News And Back Again
13:34:14 <BMeph> Didn't we have 433 in here yesterday?
13:34:21 <bringert> pi3: you could look at exercises and lecture notes from university courses
13:34:31 <dons> bringert: 436
13:34:57 <BMeph> dons: ? :)
13:34:58 <dons> BMeph: ^
13:34:59 <thoughtpolice> pi3: i would suggest just finding some algorithms and implementing them purely using something like ghci
13:35:02 <dons> tab completion!
13:35:26 <dons> pi3: also, I guess people have recommended YAHT ?
13:35:32 <bringert> pi3: you could try teaching yourself something like this course http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/schedule.html
13:35:39 <lambdabot> Title: Introduction to Functional Programming -- Schedule
13:36:18 <pi3> dons: I was searching tutorials but really didn't know which one to chose, so I came here
13:36:30 <reinierrr> pi3: i think my lecture notes were great, too: http://people.cs.uu.nl/jeroen/courses/fp-eng.pdf
13:36:50 <reinierrr> they contain lots of little exercises with algorithms on lists and trees
13:37:03 <dmwit> Learning Haskell is the act of making the implicit explicit.
13:37:10 <dons> ?where yaht
13:37:11 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:37:12 <pi3> thank you, there's a nice community around Haskell I see :)
13:37:16 <dons> is the most recommended tut
13:37:24 <dons> oh, you're most welcome, pi3 !
13:37:28 <musiKk> i'm reading yaht right now
13:37:41 <Heffalump> pi3: we're aiming at world domination
13:37:43 <dons> what do you think of it, musiKk ?
13:38:05 <dons> pi3: what lead you to haskell, btw?
13:38:15 <musiKk> well, it's definitively not bad
13:38:25 <dons> gloomy winter weather seems to correlate with increased interest, i've noticed :)
13:38:50 <musiKk> but in the very beginning i liked "haskell for c/c++ programmers" better
13:39:31 <dmwit> I never thought that one explained anything. =/
13:39:52 <ddarius> dons: It's summer in Australia right now.  And currently it's sunny and my window is open where I am.
13:40:06 <dons> dmwit: you didn't like yaht?
13:40:09 <pi3> dons: basically my free time because I'm on holidays since last Friday, and that I have a project in mind that uses some kind of parsing and AI. By the way, is Haskell good at handling strings and parsing in general?
13:40:10 <ddarius> dmwit: Explanations are for the weak.
13:40:12 <dons> musiKk: oh, that's good to know.
13:40:23 <dmwit> dons: No, I didn't like "Haskell for C/C++ Programmers."
13:40:23 <reinierrr> ddarius: here it's autumn, raining, stormy and late at night
13:40:26 <dons> pi3: oh, yes. strings and parsing are probably one of the 4 pillars of strength
13:40:32 <dons> pi3: you get to use parsec :)
13:41:05 <ddarius> reinierrr: It's autumn/winter here too; I'm in the US.  However, many Haskellers and potential new Haskellers are in Australia.
13:41:11 <musiKk> dmwit: sadly it's very short
13:41:15 <dons> i'd be hard pressed to find a language with better support for parsing
13:41:16 * ddarius pokes Philippa_ 
13:41:34 <ddarius> dons: If things get going perhaps we'll have Parsec+bytestrings soon.
13:41:35 <pi3> dons: well, wonderful then; the other choice was to use Python which I have been using for some time but just wanted to try Haskell
13:41:50 <glguy> If it is summer in the southern hemisphere and winter in the northern... where is the dividing line? topic of cancer / capricorn?
13:42:03 <dons> pi3: people have written a lot about parsing in haskell , http://haskell.org/haskellwiki/Blog_articles/Parsing
13:42:03 <ddarius> glguy: The equator.
13:42:04 <dmwit> Parsing is so easy that there's like 80 different libraries to choose from. =)
13:42:25 <ddarius> glguy: It doesn't really matter too much in those middle latitudes.
13:42:25 <glguy> so when you cross the equator, that is where the season flops?
13:42:49 <glguy> ddarius: right, but I wondered if they even had a "winter" at all at the equator
13:42:58 <glguy> if they evere declared it "winter"
13:43:06 <ddarius> glguy: As far as the weather is concerned, no.
13:43:15 <Heffalump> I don't think anything inside the tropics has seasons, thanks to the earth's tilt.
13:43:15 <glguy> I just mean the label
13:43:15 <pi3> dons: I think I'll have to let parsec for the future
13:43:56 <reinierrr> pi3: yes, its interface is quite abstract
13:44:04 <reinierrr> pi3: you need some background to appreciate it
13:44:31 <glguy> "In other tropical areas a three-way division into hot, rainy and cool season is used."
13:44:42 <Heffalump> glguy: I don't think they talk about the four seasons in that sense, no. (My mother grew up in Sri Lanka, which is roughly on the equator)
13:45:27 <ddarius> reinierrr: Wouldn't the background you need be the same background you'd need to parse languages anyway?
13:46:13 <dmwit> Nah, you don't need a background in monads to parse languages.
13:46:33 <Toxaris> do you need a background in monads to use parsec?
13:46:37 <reinierrr> dmwit: you don't need monads to parse, but you do need monads to use parsec
13:47:09 <dons> there's only wet and dry seasons in northern australia
13:47:10 <ddarius> reinierrr: I think many people would be able to readily use parsec with or without background in monads.
13:47:25 <ddarius> dons: Dry season now?
13:47:28 <TSC> glguy: Some places just have wet/dry seasons (NT, like Don says, and Indonesia)
13:47:28 <njbartlett> glguy: Singapore is about 100km from the Equator and it has basically the same weather all year: hot and humid
13:47:34 <TSC> Wet season now
13:47:55 <dons> ddarius: wet.
13:47:58 <dmwit> Toxaris: No, but you need a background in monads to *appreciate* parsec.
13:48:06 <Heffalump> so what causes the division?
13:48:10 <dmwit> reinierrr: Right, exactly my point.
13:48:33 <ddarius> dmwit: Huh?  The monadic aspect is almost irrelevant to why I appreciate parsec.
13:48:44 * dmwit shrugs
13:49:02 <dmwit> Okay.  I appreciate it at least partially because I can use all the usual monad combinators with it.
13:49:56 <reinierrr> and you probably _will_ have to use to monad combinators to use it well
13:50:15 <reinierrr> of course you can learn them as you learn parsec, but then you're learning monads and parsec at the same time
13:50:32 <reinierrr> i don't know if there are any tutorials that take that approach
13:50:42 <ddarius> I appreciate 1) a close match with BNF 2) seamless addition of semantic actions and 3) the ability to use the language to abstract patterns.  2 & 3 come from parsec being embedded in Haskell but not from it being a monadic embedding.
13:51:02 <Toxaris> reinierr: even with nothing "monadic" but do-notation, Parsec (or other Haskell-based parser combinator libraries) are superior to other languages' aproaches to parsing, in my opinion
13:51:17 <BMeph> Heffalump: That's where the tropic lines come in.
13:51:24 <ddarius> reinierrr: Many people recommend the parser combinator papers to help understand monads.
13:53:02 <reinierrr> ddarius: okay, that's great then
13:54:24 <Heffalump> BMeph: the division between wet/dry seasons, I meant
13:54:39 <igel> can i find out which RTS options have been set?
13:54:55 <igel> i'm interested in the -N option^^
13:55:10 <njbartlett> The tropics are defined as the norternmost/southernmost places that receive vertical rays from the Sun at some point in the year. Just in case anybody was interested :-)
13:56:23 <igel> (concerning the GHC)
13:56:26 <musiKk> not me, but it's interesting nonetheless
13:57:48 <Toxaris> reinierrr: for many people, working with a concrete use of the "monad pattern" before learning about it's theoretical background and the related standard combinators is easier. e.g., after writing do {a' <- a; b' <- b; return f a' b'} often enough, they appreciate `ap` much more.
13:58:26 <nottha_k> dmwit: ghc 6.8.1 (in regards to my problems building yi via posix-regex). had to change data.bystring.base to data.bytestring.unsafe
13:58:44 <ddarius> Toxaris: That's liftM2
13:58:52 <BMeph> njbartlett, Heffalump: Exactly. The tropic of Capricorn it the circle of earth where the sun's overhead in December, and the respective relation goes for Cancer in June.
14:00:25 <Toxaris> ddarius: I used to use (return f `ap` a `ap` b), but recently switched to (f <$> a <*> b). I don't like the liftMn-family (or any other family where I have to count arguments by hand and insert numbers into function names).
14:00:31 <BMeph> I'm guessing it's wetter when the sun's higher, but that's a guess.
14:01:14 * Heffalump will ask his wife once she gets off the phone, since she's an atmospheric physicist :-)
14:01:32 <nottha_k> hmm. i'm seeing dependencies like regex-compat >=0.71,regex-compat <0.73, does that mean both versions are necessary?
14:01:44 <reinierrr> Toxaris: and I prefer the verbose do-notation for clarity :-)...
14:01:53 <Heffalump> nottha_k: no, it means you need 0.71 or 0.72
14:01:59 <Heffalump> or any minor revisions inbetween
14:03:00 <nottha_k> oh dur. i misread that. as greater than the higher and less than the lower. which seemed really odd
14:05:40 <MyCatVerbs> @hoogle [a] -> [a] -> (a,a)
14:05:40 <lambdabot> No matches, try a more general search
14:05:44 <MyCatVerbs> @hoogle [a] -> [a] -> [(a,a)]
14:05:44 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
14:06:05 <MyCatVerbs> @hoogle [a] -> [(a,a)]
14:06:05 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
14:06:18 <dmwit> :t partition
14:06:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:06:34 <mauke> :t map (join (,))
14:06:35 <lambdabot> forall a. [a] -> [(a, a)]
14:06:40 <shachaf> MyCatVerbs: What are you looking for?
14:07:00 <setuid_w00t> Where can I find functions in the standard library for doing things like string split and character replacement?
14:07:20 <MyCatVerbs> shachaf: [1...] -> [(1,2),(3,4),(5,6)...]
14:07:31 <MyCatVerbs> > (map (join (,))) [1..]
14:07:32 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
14:07:34 <ddarius> setuid_w00t: In the Prelude or Data.List primarily.
14:07:41 <dmwit> setuid_w00t: There's nothing really great in the standard libraries for that.
14:08:00 <dmwit> setuid_w00t: There's words and lines; for anything more complicated you have to graduate to regexes or Parsec or so.
14:08:31 <MyCatVerbs> shachaf: actually, wrong bracketing. What I'm really after is [1..8] -> ([1,3,5,7],[2,4,6,8])
14:08:41 <MyCatVerbs> @hoogle [a] -> ([a],[a])
14:08:42 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
14:08:42 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
14:08:42 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:08:48 <dmwit> > partition even [1..8]
14:08:49 <mauke> > groupBy (\x y -> even x == odd y) [1 ..]
14:08:50 <lambdabot>  ([2,4,6,8],[1,3,5,7])
14:08:50 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,...
14:09:35 <MyCatVerbs> Handy to know. But, forall a., rather than (Integral a) >_>
14:09:39 <MyCatVerbs> :t even
14:09:40 <lambdabot> forall a. (Integral a) => a -> Bool
14:10:47 <Toxaris> MyCatVerbs: you want "abcdefg" --> ("aceg", "bdf")?
14:10:48 <dmwit> ?src partition
14:10:48 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
14:10:48 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
14:10:48 <lambdabot>                               | otherwise = (ts, x:fs)
14:11:17 <dmwit> interesting
14:11:25 <dmwit> > take 10 . fst . partition even $ [1..]
14:11:27 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
14:11:45 <MyCatVerbs> Toxaris: precisely.
14:12:48 <Toxaris> MyCatVerbs: My guess: you have to write it yourself. there's not library support for eating more then one list element at once.
14:13:00 <diltsman> Ok, now that I *think* that I understand Monads, I have a question as to why something isn't working.
14:13:25 <MyCatVerbs> > let { lr (x:y:z) al ar = lr (x:al) (y:ar) z; lr (x:[]) al ar = ((x:al),ar); lr [] al ar = (al,ar); yar l = let (al,ar) = lr l in (reverse al,reverse ar) } in yar [1..]
14:13:26 <lambdabot>  Couldn't match expected type `(t, t1)'
14:13:33 <MyCatVerbs> ...balls.
14:15:07 <dmwit> :t foldr
14:15:14 <Taejo> diltsman, ask away
14:15:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:15:31 <dmwit> > let f (x:y:rest) (as, bs) = f rest (x:as, y:bs); f [x] (as, bs) = (x:as, bs); f [] (as, bs) = (as, bs) in foldr ([], []) [1..8]
14:15:32 <lambdabot>  Couldn't match expected type `a -> b -> b'
14:15:35 <MyCatVerbs> > let { lr (x:y:z) al ar = lr (x:al) (y:ar) z; lr (x:[]) al ar = ((x:al),ar); lr [] al ar = (al,ar); yar l = let (al,ar) = lr l [] [] in (reverse al,reverse ar) } in yar [1..]
14:15:38 <diltsman> I'm trying to use the State monad.  My function is parseConfig :: String -> State (HashTable String String) String          parseConfig = return "crap"
14:15:39 <lambdabot> Terminated
14:15:45 <MyCatVerbs> > let { lr (x:y:z) al ar = lr (x:al) (y:ar) z; lr (x:[]) al ar = ((x:al),ar); lr [] al ar = (al,ar); yar l = let (al,ar) = lr l [] [] in (reverse al,reverse ar) } in yar [1..40]
14:15:45 <lambdabot>  ([2,1],[40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18...
14:15:53 <diltsman> I have no idea why that won't work...
14:15:56 <MyCatVerbs> Aw, cachu ci.
14:15:58 <dmwit> > let f (x:y:rest) (as, bs) = f rest (x:as, y:bs); f [x] (as, bs) = (x:as, bs); f [] (as, bs) = (as, bs) in f [1..8] ([], [])
14:15:59 <lambdabot>  ([7,5,3,1],[8,6,4,2])
14:16:31 <dmwit> almost
14:16:35 <diltsman> Ok, now it works (forgot to name the parameter).
14:16:58 <Taejo> :t return "crap"
14:16:59 <MyCatVerbs> > let { lr (x:y:z) al ar = lr z (x:al) (y:ar); lr (x:[]) al ar = ((x:al),ar); lr [] al ar = (al,ar); yar l = let (al,ar) = lr l [] [] in (reverse al,reverse ar) } in yar [1..]
14:17:00 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
14:17:03 <lambdabot> Terminated
14:17:05 <MyCatVerbs> > let { lr (x:y:z) al ar = lr z (x:al) (y:ar); lr (x:[]) al ar = ((x:al),ar); lr [] al ar = (al,ar); yar l = let (al,ar) = lr l [] [] in (reverse al,reverse ar) } in yar [1..40]
14:17:07 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39],[2,4,6,8,10,12,14,...
14:17:16 <dmwit> Not lazy enough!
14:17:18 <MyCatVerbs> Crap, finite lists only. Ah well, that works.
14:17:18 <shachaf> diltsman: You probably shouldn't use HashTable.
14:17:22 <diltsman> Man, that makes me feel kind of stupid, but that is usually the thing I forget to do.
14:17:44 <MyCatVerbs> dmwit: what's the problem?
14:18:14 <diltsman> I'm wanting a set of name/value pairs that I can pull out whichever one I want.  HashTable or BST would probably be the correct data structure.
14:18:47 <shachaf> diltsman: What about Data.Map?
14:19:19 <dmwit> > let f (x:y:rest) = let (as, bs) = f rest in (x:as, y:bs); f xs = (xs, []) in f [1..8]
14:19:20 <lambdabot>  ([1,3,5,7],[2,4,6,8])
14:19:25 <diltsman> Um...Missed that one.
14:19:29 <shachaf> @yar
14:19:29 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
14:19:33 <dmwit> > let f (x:y:rest) = let (as, bs) = f rest in (x:as, y:bs); f xs = (xs, []) in take 10 . fst . f $ [1..]
14:19:34 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
14:19:48 <dmwit> MyCatVerbs: There, now we can handle infinite lists.
14:19:57 <MyCatVerbs> dmwit: ah, handy! Thank you.
14:20:21 <diltsman> shachaf: Thanks for pointing that one out.
14:20:34 <shachaf> diltsman: HashTable is both slow (I understand) and in IO.
14:21:48 <dmwit> MyCatVerbs: No, thank *you*.  Now I know how to write something I was thinking about earlier. =P
14:24:04 <dmwit> > let f (x:y:rest) = let (as, bs) = f rest in (x:as, y:bs); f xs = (xs, []) in take 10 . fst . f $ [1..7] -- just out of curiousity
14:24:04 <lambdabot>  [1,3,5,7]
14:25:31 <diltsman> shachaf: Shouldn't HashTables be O(1)?  Just a slow implementation?
14:26:29 <Taejo> diltsman, functional programmers don't like to spend too much time on hash tables, as you can imagine
14:26:34 <ddarius> diltsman: Yes they should be, but if the constant factor is high enough, that doesn't matter.
14:29:30 <dmwit> ?src catMaybes
14:29:30 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:29:42 <dmwit> haskell++
14:30:14 <dons> filtering via matching in list comprehensions is sometimes overlooked :)
14:31:15 <Toxaris> not after reading Neil's uniplate stuff
14:38:59 <diltsman> Is there any recomended way of trivial string tokenizing?  I'm splitting a string on '='.
14:39:11 <dmwit> :t break
14:39:12 <Olathe> @src words
14:39:12 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:39:12 <lambdabot> words s = case dropWhile isSpace s of
14:39:12 <lambdabot>     "" -> []
14:39:12 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:39:30 <dons> > break (=='=') "let x = e"
14:39:31 <Olathe> You can rewrite words.
14:39:31 <lambdabot>  ("let x ","= e")
14:39:33 <dmwit> > break (=='=') "this = that"
14:39:33 <lambdabot>  ("this ","= that")
14:41:56 <njbartlett> I'm trying to build a binary installation package for nhc98 on Mac OS X Leopard (Intel). Would anybody like to test it for me?
14:42:53 <diltsman> Thanks.  Still learning the basic libraries.
14:45:28 <MyCatVerbs> dmwit: heh. What were you thinking of, out of curiosity? Myself, it was the fast fourier transform.
14:47:42 <dmwit> I'm doing some hand-generated LL(1) parsing where the input may be incomplete, and I was trying to figure out how I could lazily return as much of the parse as possible plus a "completion" token.
14:48:23 <dmwit> Of course returning a tuple is the obvious choice, but I was having trouble figuring out how to make the parse part of the tuple be lazy, and now I think I've got it. =)
14:54:00 <filcab42> hi all
14:54:27 <filcab42> anyone knows if the ghc version that is in macports is working in leopard?
14:54:32 <filcab42> I can't get it to compile :s
14:54:53 <Botje> you need an existing ghc install to compile ghc
14:55:01 <filcab42> hmm
14:55:08 <filcab42> how can I bootstrap that?
14:55:18 <Botje> grab the binary off the site
14:55:18 <filcab42> should I install one version manually and then compile?
14:55:30 <lQg> if i have a list of strings, some of which are parseable integers and some are not, but I want to multiply all that are actually int's time -1  how would i do that?
14:55:35 <Botje> don't know if it works with leopard, though
14:56:01 <lQg> basically need a way to get it to not print error on no parse and simply skip to next token
14:56:01 <nebulous> learning haskell: how can i get an element d out of 4-tuple (a, b, c, d)?
14:56:14 <ddarius> lQg: reads
14:56:16 <ddarius> :t reads
14:56:17 <Botje> nebulous: pattern match.
14:56:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:56:36 <Botje> case blah of (_,_,_,d) -> ....
14:56:44 <nebulous> i try func (a, b, c, d) = d in hugs and get syntax error..
14:56:47 <Botje> of course you can write your own accessor, that's generally easier
14:56:56 <Botje> nebulous: you can't define new functions in hugs
14:57:00 <Botje> not like that, at least
14:57:09 <lQg> ddarius: so what exactly does that do?
14:57:17 <Toxaris> nebulous: write the definition in a file, load the file in hugs with :l filename
14:57:19 <Botje> > let func (a, b, c, d) = d in func (1,2,3,"foo")
14:57:21 <lambdabot>  "foo"
14:57:24 <pejo> filcab42, atleast earlier macports has downloaded a bootstrap compiler to build the right one. I can't help you with Leopard though.
14:57:26 <nebulous> ahh thank you
14:57:38 <thoughtpolice> filcab42: there should be a working binary for os x around somewhere. if you can find a stable 6.6/6.4 bin snapshot, you can just compile 6.8.1. try macports or fink?
14:57:47 <ddarius> > (reads "aoeu" :: [(Int,String)], reads "34 aoeu" :: [(Int,String)])
14:57:48 <lambdabot>  ([],[(34," aoeu")])
14:57:51 <thoughtpolice> er, well, fink in this case if you haven't :)
14:58:00 <filcab42> I+ll try that, thanks
14:58:31 <lQg> > reads ["(","1"]
14:58:32 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
14:58:45 <lQg> > map (\x -> reads x)  ["(","1"]
14:58:45 <lambdabot>  [[],[(1,"")]]
14:58:46 <thoughtpolice> filcab42: i don't have a mac but i've heard a bit more 'success' from using something like fink. as long as you can get one of those bins installed you should be good to go from there
14:59:41 <lQg> is there a map that works from right to left?
14:59:47 <ddarius> > map reads ["(","1"] -- incidentally.
14:59:47 <lambdabot>  [[],[(1,"")]]
15:00:07 <ddarius> lQg: That doesn't make any sense.  map doesn't have an order (at a high level).
15:00:09 <dmwit> lQg: map is not directional
15:00:13 <ddarius> Maybe you want to reverse the list?
15:00:19 <lQg> oh right nm
15:00:24 <Toxaris> lQg: map works from right to left :)
15:00:54 <Toxaris> (as much as it works from left to right...)
15:01:09 <shachaf> > join (***) (map snd) . partition (even . fst) . zip [0..] $ [1..]
15:01:11 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
15:02:15 <shachaf> LoganCapaldo: In a more @pl way.
15:02:17 <dmwit> shachaf: I would argue that that is not nicer than the simple recursive definition. =P
15:02:46 <LoganCapaldo> shachaf: ?
15:03:02 <dmwit> LoganCapaldo: He was probably aimed at MyCatVerbs, not you.
15:03:45 <Toxaris> shachaf: you test numbers for being even to seperate every other element of a list? ;) but join (***) is  cool!
15:03:54 <shachaf> Oops, sorry.
15:08:42 * locomalo is away: Ausente
15:13:34 <jdrake> Q: What facilities does haskell have for bitwise operations?
15:13:52 <dmwit> Data.Bits or something like that.
15:14:15 <Toxaris> A: These in Data.Bits.
15:14:18 <dmwit> > 3 .&. 8
15:14:21 <Zao> :t (.|.)
15:14:29 <lambdabot> forall a. (Bits a) => a -> a -> a
15:14:29 <lambdabot>  Add a type signature
15:14:29 <jdrake> merci
15:14:33 <ddarius> @src Bits
15:14:33 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:14:38 <dmwit> > 3 .&. 8 :: Int
15:14:38 <lambdabot>  0
15:14:39 <ddarius> @src Data.Bits.Bits
15:14:40 <lambdabot> Source not found. :(
15:14:44 <dmwit> ?source Data.Bits
15:14:44 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
15:15:36 <dons> ?docs Data.Bits
15:15:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
15:15:53 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Bits.html
15:15:53 <dons> this doc breakacage is getting annoying :)
15:15:53 <lambdabot> http://tinyurl.com/2yd4ej
15:15:58 <Toxaris> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Bits.html
15:15:58 <lambdabot> http://tinyurl.com/2yd4ej
15:16:09 <dons> what ever happened to persistant urls?
15:16:38 <nebulous> how can i import the function filter?
15:16:49 <ddarius> dons: They never existed in the first place?
15:16:53 <dmwit> nebulous: It's automatic unless you're doing something strange.
15:16:57 <ddarius> nebulous: By doing nothing at all.
15:16:57 <Toxaris> maybe this is the way to go: http://haskell.org/hoogle/hoodoc.cgi?module=Data.Bits&mode=module
15:17:13 <dmwit> nebulous: If you *are* doing something strange, then you can use "import Prelude (filter)".
15:17:14 <ddarius> @google site:haskell.org Data.Bits
15:17:15 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Bits.html
15:17:22 <ddarius> Hmm.  Not that.
15:17:38 <dmwit> Toxaris: Some of Hoogle's links are broken, too. =/
15:17:40 <dons> @google site:haskell.org/ghc Data.Bits
15:17:40 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Bits.html
15:17:51 <dons> bingo
15:19:14 <Toxaris> dmwit: but no need for duplicate link cleaning if lambdabot and hoogle use the same database
15:19:33 <dmwit> ah
15:20:07 <Toxaris> what's the meaning of .../latest/...-3.0.0.0, btw? is there more then one version 3.0.0.0, and this is the latest?
15:20:32 <monochrom> the version number is supposed to be redundant.
15:20:33 <dmwit> ugh
15:20:58 <monochrom> there is only one 3.0.0.0. it happens to be the latest for now.
15:21:03 <Toxaris> so it's just a non-standard (and non-sense?) use of "latest"
15:21:32 <dmwit> These are the latest docs.
15:21:37 <dmwit> (Not necessarily for the latest library.)
15:21:49 * dmwit starts making things up
15:22:11 <Toxaris> hehe, so documentation version can increase independently from library version
15:22:38 <Toxaris> ok, according to doc. 3.1.2.2 for lib. 3.0.2.1 we should use lib 3.3.1.0 instead
15:23:09 <dmhouse> What's a standard matrix datatype?
15:23:57 <dmhouse> Do most people just use [[Int]]? Ideally I'd like to enfore rectangularity, but I'm not in that much need of efficiency.
15:24:17 <dmwit> I don't think there's a standard one, but Array seems like a good fit.
15:24:25 <mrd> i used [UArr Double] once
15:24:44 <mrd> though my output was a 2-D array
15:25:47 * Toxaris wonders about how to enforce rectangularity using some crazy type
15:26:17 <dmwit> Toxaris: Why wouldn't an array do that?
15:26:27 <mrd> might be able to do it with the Peano numerals trick
15:26:41 <Toxaris> dmwit: ... statically ...
15:27:02 <ddarius> Toxaris: Easy.
15:27:10 <LoganCapaldo> nested tuples ftw :)
15:27:11 <dmwit> type Matrix = Array (Int, Int) Int -- is *statically* rectangular
15:28:21 * Toxaris hmm of course :) I mean quadratic ofc
15:28:53 <dmwit> > range ((3, 3), (5, 5)) -- just to make sure I'm not blowing smoke out my rear
15:28:55 <lambdabot>  [(3,3),(3,4),(3,5),(4,3),(4,4),(4,5),(5,3),(5,4),(5,5)]
15:28:56 * mrd chuckles.  I was thinking square too.
15:29:26 <dmwit> aha, square
15:29:52 <LoganCapaldo> > range ((0,3), (0,3))
15:29:53 <lambdabot>  [(0,3)]
15:29:59 <LoganCapaldo> hehe
15:30:07 <LoganCapaldo> > range ((0,0), (3,3))
15:30:07 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
15:30:43 <LoganCapaldo> You could write your own Ix instance to enforce squarness maybe
15:31:01 <dmwit> Mmmm, yes.
15:31:35 <dmwit> err... maybe not
15:31:37 <dmwit> :t range
15:31:38 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
15:31:50 <dmwit> You have to return something of the same type as your inputs. =/
15:31:52 <LoganCapaldo> newtype MyIx a = Square (x, x) ; makeMyIx n = Square (n,n) -- don't export the constructor
15:32:04 <dmwit> Oh, yeah, that would be fine.
15:32:31 <LoganCapaldo> not exactly staticlaly enforcing it I guess
15:32:35 <Toxaris> LoganCapaldo: and how could I create Square values for indexing into my matrix?
15:32:36 <LoganCapaldo> well it is
15:33:18 <LoganCapaldo> Toxaris: you don't, you'd have an index function that would make the square values for you from tuples and pull the stuff out of the array
15:33:24 <LoganCapaldo> pita
15:33:32 <dmwit> data IsSquare = IsSquare | IsNotSquare
15:33:44 <dmwit> data Square = Square Int Int IsSquare
15:33:53 <dmwit> makeMyIx a = Square a a IsSquare
15:34:13 <dmwit> makeMyRetriever a b = Square a b IsNotSquare
15:34:18 <dmwit> problem solved
15:35:02 <dmwit> Actually, I guess you really want "data IsSquare; data IsNotSquare" for the phantom types to work out.
15:35:05 <dmwit> But you get the idea.
15:35:20 <ddarius> http://citeseer.ist.psu.edu/hinze99manufacturing.html
15:35:20 <lambdabot> Title: Manufacturing Datatypes - Hinze (ResearchIndex)
15:35:26 <Toxaris> dmwit: no i don't
15:35:36 <dmwit> Okay, let's go to hpaste. =)
15:35:41 <ddarius> Nested data types can encode quite a few invariants.
15:35:55 <Toxaris> without the help of the existing Array interface?
15:37:33 <chessguy> > range (3,9)
15:37:35 <lambdabot>  [3,4,5,6,7,8,9]
15:37:41 <chessguy> > range (3,2)
15:37:42 <lambdabot>  []
15:37:44 <Toxaris> is ((0, 1), (3, 4)) to be considered square?
15:37:51 <chessguy> @src range
15:37:51 <lambdabot> Source not found. Maybe you made a typo?
15:38:17 <chessguy> > range ((0,0),(2,2))
15:38:18 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
15:38:21 <Toxaris> range (('a', 1), ('c', 2))
15:38:23 <chessguy> interesting
15:38:23 <Toxaris> > range (('a', 1), ('c', 2))
15:38:24 <lambdabot>  [('a',1),('a',2),('b',1),('b',2),('c',1),('c',2)]
15:38:33 <chessguy> @src Ix
15:38:33 <lambdabot> class (Ord a) => Ix a where
15:38:33 <lambdabot>     range           :: (a,a) -> [a]
15:38:33 <lambdabot>     index           :: (a,a) -> a -> Int
15:38:33 <lambdabot>     inRange         :: (a,a) -> a -> Bool
15:38:33 <lambdabot>     rangeSize       :: (a,a) -> Int
15:39:27 <dmwit> Ah, this is slightly more interesting than I thought.
15:40:31 <Toxaris> ddarius: thanks for the reference, that's the direction i was hoping for
15:48:03 <nottha_k> where/how does cabal keep track of installed packages?
15:48:39 <Zao> In the filenames mentioned when you do a ghc-pkg list
15:49:19 <ddarius> Working with nested data types typically involves using polymorphic recursion, my oft stated bitrev example also uses polymorphic recursion but it effectively implicitly makes a perfect tree type.
15:49:31 <dons> nottha_k: in the installed package.conf file
15:49:37 <dons> and in ~/.cabal/
15:49:37 <nottha_k> Zao: ah thanks. .ghc/i386-linux-6.6.1/package.conf
15:49:46 <nottha_k> couldn't find anytihng in .cabal
15:49:57 <BlackMeph> :r
15:50:05 <dons> yeah, only if you install with --user will it be there
15:50:10 <BlackMeph> Whoops, wrong window. ;p
15:50:20 <dons> or if you start using cabal-install
15:50:36 <dons> Prelude>
15:50:55 <monochrom> :load Shutdown.hs
15:51:09 <dons> <no location info>: can't find file: Shutdown.hs
15:51:15 <monochrom> :quit
15:51:22 <dons> $
15:51:37 <monochrom> perl Shutdown.hs
15:51:51 <dons> Can't open perl script "Shutdown.hs": No such file or directory
15:52:04 <monochrom> python
15:52:08 <LoganCapaldo> dons has been takenover
15:52:10 <dons> zsh: command not found: python
15:52:35 <monochrom> apt-get python
15:52:44 <dons> zsh: command not found: apt-get
15:52:46 <sethk> perl?  python?  how about cobol?
15:52:51 <ddarius> ghc -e '[1..]'
15:53:00 <monochrom> cobol has been superseded by cabal
15:53:06 <dons> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20, ..
15:53:24 <thoughtpolice> cat /dev/urandom > /dev/audio
15:53:26 <LoganCapaldo> install package parsec into ghc_root giving ghc
15:53:35 <monochrom> hahahahaha
15:53:42 <dmwit> Wait, you seriously don't have python and perl installed?
15:53:48 <dons> ^C
15:54:02 <dmwit> Half of the scripts that come with my distribution require one of perl or python.
15:54:10 <LoganCapaldo> well he has perl installed
15:54:12 <monochrom> dons seriously doesn't have python and perl installed (in his mind). :)
15:54:16 <LoganCapaldo> just not Shutdown.hs
15:54:26 <dons> $ which perl
15:54:26 <dons> /usr/bin/perl
15:54:26 <dons> $ which python
15:54:26 <dons> python not found
15:54:26 <dons> $ which python2.4
15:54:28 <dons> /usr/local/bin/python2.4
15:54:49 <LoganCapaldo> which ghc
15:54:54 <dons> /home/dons/bin/ghc
15:55:03 <LoganCapaldo> ghc --version
15:55:05 <dons> The Glorious Glasgow Haskell Compilation System, version 6.8.1.20071117
15:55:36 <MyCatVerbs> find /
15:55:42 <dons> hah.
15:55:52 <idnar> heehee
15:56:05 <dmwit> yes
15:56:14 * LoganCapaldo is tempted to set PS1 to <dons> now
15:56:18 * dmwit waits for dons to flood the channel with 'y'
15:56:18 <dons> heh
15:56:28 <dons> y
15:56:28 <dons> y
15:56:28 <dons> y
15:56:28 <dons> y
15:56:29 <dons> y
15:56:38 <Brian`> rm -rf /
15:56:48 <LoganCapaldo> ^Z
15:57:16 <MyCatVerbs> find / -type f -print0 | xargs file | sed "s/^[^:]+: //" | ghc -e "interact (unlines . Data.List.nub . lunes)"
15:57:29 <MyCatVerbs> Whoops, that should be xargs -0.
15:57:30 <dons> Permission denied
15:57:31 <monochrom> lunes?
15:57:34 <dmwit> rm: cannot remove `/': Permission denied
15:58:04 <dmwit> It turns all files into "Monday" first. =)
15:58:05 <idnar> dmwit: y\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny --More--
15:58:28 <dmwit> idnar: @more
15:58:43 <LoganCapaldo> dmwit: now you're just mixing metaphors
15:58:52 <idnar> dmwit: You have died!
15:58:58 <glguy> People in glass ships shouldn't throw stones
15:59:00 <dmwit> LoganCapaldo: idnar started it, he went to NetHack mode. =P
15:59:20 <idnar> People in glass ships shouldn't rock the boat
15:59:37 <dmwit> People who rock out shouldn't ship glass.
15:59:50 <LoganCapaldo> hehe
16:00:00 <monochrom> People who learn Haskell shouldn't ask for intuition.
16:00:37 <LoganCapaldo> i can haz intooishun?
16:00:44 <monochrom> hehehehe
16:02:08 <LoganCapaldo> People who go ice fishing shouldn't ask for Inuits.
16:02:30 <Brian`> People who ice fishes with Inuits should go
16:02:43 <dmwit> People who ice Inuits are named Ender.
16:03:29 <idnar> People in with are discohere named piazza
16:03:35 <MyCatVerbs> People who live in dinosaur houses shouldn't throw bones.
16:04:35 <dmwit> People who house dinosaurs get what they deserve.
16:04:42 <monochrom> hahaha
16:05:11 <gwern> I have a question: in matching in a case expression, why is
16:05:30 <gwern> "quit":_ apparently not equivalent to 'q':'u':...:_?
16:05:32 <dons> ?babel en fr People who house dinosaurs get what they deserve
16:05:33 <lambdabot>   Peuplez qui obtiennent les dinosaurs de maison ce qu'ils mritent
16:05:41 <dons> ?babel fr en Peuplez qui obtiennent les dinosaurs de maison ce qu'ils mritent
16:05:42 <lambdabot>   Populate which obtains the dinosaurs house what they mritent
16:05:44 <MyCatVerbs> gwern: because YOUR LAWNMOWER. (But there's probably a better reason.)
16:05:44 <dmwit> gwern: Because "quit" includes the final (:[]).
16:06:02 <LoganCapaldo> my hovercraft is full of eels
16:06:14 <dons> ?babel en de my hovercraft is full of eels
16:06:14 <lambdabot>   mein Luftkissenfahrzeug ist von den Aalen voll
16:06:19 <MyCatVerbs> gwern: "quit" is the whole list. "quit":_ has looks like it has type [String] instead of String, the latter being what you want.
16:06:20 * allbery_b is inclined to think that's unfortunate
16:06:23 <monochrom> "quit":_ is not equivalent to 'q':'u':'i':'t':_
16:06:31 <MyCatVerbs> Er, "quit" is *a* whole list, I mean.
16:06:41 <monochrom> This matches "quit":_ : ["quit", "hello", "whee"]
16:06:41 <dons> ?unpl "quit":_
16:06:41 <lambdabot>  Parse error in expression at end of input
16:06:44 <allbery_b> although it does raise the question of how to do a list of strings, so maybe not
16:06:47 <allbery_b> it's a pity
16:07:04 <gwern> interesting. so, "quit" ++ _ might then be equivalent?
16:07:07 <MyCatVerbs> gwern: so it looks to the compiler like you're asking for a list, the head element of which is exactly the string "quit".
16:07:09 <thoughtpolice> gwern: look at the type of :
16:07:13 <thoughtpolice> :t (:)
16:07:14 <lambdabot> forall a. a -> [a] -> [a]
16:07:17 <dmwit> gwern: If it were a valid pattern, then yes.
16:07:19 <monochrom> ++ is not a constructor. can't use it in pattern
16:07:22 <gwern> (I don't think it's allowed anyway, but I'm interested in understand)
16:07:26 <gwern> monochrom: right
16:07:31 <LoganCapaldo> gwern: it would except you can't pattern patch against not-a-constructor
16:07:33 <monochrom> Yes, the idea is right.
16:07:39 <gwern> :t (++)
16:07:39 <lambdabot> forall a. [a] -> [a] -> [a]
16:07:43 <lQg> is there a take till a certain token function?
16:07:51 <dmwit> :t takeWhile
16:07:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:07:53 <thoughtpolice> lQg: takeWhile
16:07:53 <LoganCapaldo> @type takeWhile
16:07:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:08:00 <thoughtpolice> well, there you go
16:08:07 <lQg> thanks
16:08:11 <monochrom> f xs | "quit" `isPrefixOf` xs = ...   may be a good solution.
16:08:15 <MyCatVerbs> :t \c -> takeWhile (/= c)
16:08:15 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
16:08:44 <MyCatVerbs> > ((\c -> takeWhile (/= c)) 'o') "Hello, world!"
16:08:45 <lambdabot>  "Hell"
16:08:50 <thoughtpolice> > takeWhile (/='-') "hi - i'm the thoughtpolice"
16:08:51 <lambdabot>  "hi "
16:08:51 <gwern> monochrom: yes, I've concluded I need to switch to guards instead of a case expression
16:09:01 <MyCatVerbs> Hrmn. Not quite the soft of world I want to say hello to. ;)
16:09:19 <MyCatVerbs> gwern: you *could* still use the case expression, it's just overly verbose. :)
16:09:50 <gwern> MyCatVerbs: no kidding
16:10:25 <gwern> also, it frustrates searches... I was very confused why grep wasn't producing hits for "quit" until I finally discovered it was being matched as 'q':'u'...
16:10:39 <monochrom> hehehehe
16:12:22 <dmwit> Can anybody think of an Eq instance that is not equivalent to pattern matching?
16:12:38 <LoganCapaldo> dmwit: I wrote one
16:12:41 <LoganCapaldo> today
16:13:07 <dmwit> Maybe sets stored as a newtype of lists or something, I guess.
16:13:17 <dmwit> LoganCapaldo: Oh? What?
16:13:20 * gwern gets on with improving hashell, now that that has been cleared up
16:13:33 <LoganCapaldo> hashell. Briliant! :)
16:13:58 <LoganCapaldo> dmwit: I went off the deepend with that "update a list" question
16:14:06 <gwern> LoganCapaldo: eh? I'm afraid I didn't think up that name - it's an existing haskell shell
16:14:09 <gwern> not very good though
16:14:17 <LoganCapaldo> ah
16:14:21 <dmwit> gwern: "improving" means you something working?  Where's the code?
16:14:22 <LoganCapaldo> well still a cool name
16:14:26 * gwern would really have preferred 'hsh', but that's taken
16:14:29 <gwern> dmwit: on my hard drive
16:14:38 <dmwit> heh
16:15:22 <hpaste>  LoganCapaldo pasted "not straight pattern matching instance of eq" at http://hpaste.org/4231
16:16:15 <dmwit> interesting...
16:17:28 <Saizan> ?type \f -> ContT $ \k -> liftM f (k ()) -- does this have a name?
16:17:29 <lambdabot> forall (m :: * -> *) r. (Monad m) => (r -> r) -> ContT r m ()
16:18:28 <TSC> LoganCapaldo: Could you define "at" in terms of runUpdateList and (!!) ?
16:18:40 <dons> ?users
16:18:40 <lambdabot> Maximum users seen in #haskell: 429, currently: 408 (95.1%), active: 19 (4.7%)
16:18:43 <LoganCapaldo> TSC: probably
16:18:46 <dmwit> LoganCapaldo: Ah, pretty neat.  It can get pretty bad if there's lots of updates, though, huh?
16:18:53 <LoganCapaldo> the original version of at was more clever
16:19:50 <dmwit> A lot of this could be done with standard functions if you used
16:19:54 <LoganCapaldo> dmwit: I would imagine so
16:20:13 <dmwit> data UpdateList a = UL ([(Int, a)], [a]) -- or so
16:20:25 <dmwit> Even so, it's a neat idea.
16:21:55 <LoganCapaldo> DLists /ShowS are cooler though :)
16:23:12 <gwern> @where isPrefixOf
16:23:13 <lambdabot> I know nothing about isprefixof.
16:23:24 <ddarius> @index isPrefixOf
16:23:25 <lambdabot> Data.List
16:23:32 <diltsman> How do you use things from another module you wrote?
16:23:41 <TSC> Import the other module
16:23:45 <dmwit> Just import the module first.
16:23:57 <diltsman> So, if they are in the same directory, just import *name*
16:24:02 <dmwit> diltsman: If you name the file the same as the module, GHC will find it automatically.
16:24:07 <TSC> That's right
16:24:15 <SamB> diltsman: well, you also need to have actually written modules ;-)
16:24:16 <dmwit> Otherwise, you have to tell it where to look.
16:24:31 <diltsman> Ok, I think I might have just named it with the same name as some standard library.
16:24:49 <dmwit> You can use :b to see if things look right.
16:25:02 <TSC> :browse, in 6.8
16:25:21 <dmwit> :bummer
16:25:51 <TSC> I suppose you could use :bro
16:26:01 <LoganCapaldo> dude, yer my :bro
16:26:05 <TSC> As in, "hey, bro, what's in my module?"
16:26:30 <dmwit> :bro SurferDude
16:26:33 <dmwit> module not found: SurferDude
16:26:36 <dmwit> :bummer :bro
16:26:49 <diltsman> lol
16:26:52 <idnar> what is the ST monad?
16:27:18 <LoganCapaldo> no one can be told what the ST monad is
16:27:26 <LoganCapaldo> er
16:27:39 <LoganCapaldo> actually I mean no one can be told what the RealWorld# is
16:27:55 <idnar> haha
16:28:11 <dmwit> Have you had a look at the docs for it?
16:28:26 <hpaste>  Toxaris pasted "square matrices" at http://hpaste.org/4232
16:28:39 <Mitar> i am trying to make a simple parser which would afterwards make a semantic analysis, but without reworking an abstract tree to a new tree as it would use laziness into an account and after the tree is build would check types, but i have problems passing environment around
16:28:41 <hpaste>  Mitar pasted "semantic analysis, how?" at http://hpaste.org/4233
16:28:52 <LoganCapaldo> seriously though, ST is sorta liek State only you have a whole heap to pla with instead of one value
16:29:04 <LoganCapaldo> and you can create / use StRefs which are liek IORefs
16:30:01 <SamB> so... ST is the Matrix?
16:30:10 <idnar> dmwit: well, I read http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Monad-ST.html; but I don't know what is meant by "strict state threads"
16:30:10 <lambdabot> http://tinyurl.com/24kksb
16:31:00 <idnar> LoganCapaldo: I don't know what an IORef is either :/
16:31:10 <idnar> LoganCapaldo: but the thing you said about State helps, I guess
16:31:12 <dmwit> It's a pointer.
16:31:15 <SamB> idnar: do you know what a pointer is?
16:31:19 <idnar> SamB: yes
16:31:40 <SamB> do you know what a mutable cell is?
16:32:16 <ddarius> LoganCapaldo: Is liek liek the new spelling of "like"?
16:32:26 <LoganCapaldo> ddarius: I hate my keyboard
16:32:29 <SamB> ddarius: you presuppose the answer
16:32:39 <SamB> by using liek liek that in your question
16:32:46 <idnar> SamB: not as such
16:32:49 <ddarius> SamB: Shhhh
16:33:08 <LoganCapaldo> leik never happens at work
16:33:14 <LoganCapaldo> err
16:33:17 <LoganCapaldo> liek I mean
16:33:31 <LoganCapaldo> I can't even do it wrong on purpose
16:33:42 <SamB> yes you can
16:33:50 <SamB> you got it wrong!
16:33:51 <dmwit> hueg liek xobx
16:34:33 <dons> the ST monad lets you create an object in a mutable way (i.e. fill up blocks in memory), but afterwards treat the values as a normal haskell value
16:34:47 <dons> idnar: does that make sense?
16:34:58 <idnar> dons: yes, I think so
16:35:08 <Mitar> anybody?
16:35:11 <ddarius> idnar: STRefs and IORefs are like normal variables in imperative languages.
16:35:19 <ddarius> That's all there is too it.
16:35:26 <dons> yep.
16:35:52 <LoganCapaldo> @type runST
16:35:53 <SamB> like pointers to normal variables...
16:35:54 <lambdabot> Not in scope: `runST'
16:35:58 <LoganCapaldo> gah
16:36:02 <LoganCapaldo> @hoogle runST
16:36:03 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
16:36:03 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
16:36:03 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
16:36:24 <Saizan> yeah, you can't pass a variable as an argument
16:36:27 <idnar> so, it's like a little sandbox of state for you to play in; but from outside the monad, it's a black box that has referential transparency etc.
16:36:34 <LoganCapaldo> see, you even get "unsafePerformIO" except it's safe
16:36:35 <dmwit> Mitar: Maybe build a Reader monad, where the value you're reading is built from the AST?
16:36:56 <ddarius> idnar: Yes.
16:36:57 <SamB> LoganCapaldo: if only it worked
16:36:59 <Toxaris> Mitar: hmm you want to know how to fill the undefined in the various (checkType tree undefined) calls?
16:37:08 <nottha_k> man. the contents of hackage and ghc 6.81 really don't get along much
16:37:12 <idnar> ok, cool
16:37:18 <LoganCapaldo> SamB: "it"?
16:37:25 <Mitar> the problem is that checkType should have different envirnoment at each call (different when there is a new variable declared)
16:37:27 <SamB> the unsafePerformIO
16:37:35 <LoganCapaldo> runST doesn't work?
16:37:53 <SamB> well, it, uh, interacts strangely with polymorphism
16:38:00 <LoganCapaldo> ah right
16:38:07 <LoganCapaldo> I vaguely recall seeing that
16:38:11 <Mitar> but the monad is only a nicer way to program this ..
16:38:22 * LoganCapaldo never actually used ST
16:38:26 <ddarius> SamB: ?
16:38:27 <Mitar> my question is about a "principle" i could use to make it work
16:38:32 <Saizan> basically 's' tends to infect all your types
16:38:39 <Toxaris> Mitar: you need some state, namely, a updatable mapping of names to types
16:38:53 <dons> nottha_k: hmm?
16:38:53 <SamB> well... the problem will probably only show up if you use STUArrays...
16:38:57 <dmwit> Mitar: You basically want a stack of environments, and each variable scope puts a new entry on the stack, right?
16:39:01 <dons> nottha_k: what's failing -- everything i've tried recently works.
16:39:04 <ddarius> Mitar: You probably need to use a State monad (or state passing) as opposed to the Reader monad
16:39:07 <dmwit> Mitar: If so, Haskell's lists are very stack-like.
16:39:08 <Mitar> yes, but this maping can be done when I am evaluating type
16:39:29 <Toxaris> Mitar: Parsec allows for user-defined state to be threaded along with the parsing state
16:39:33 <Mitar> dmwit, yes
16:39:37 <ddarius> dmwit: Indeed, Haskell's integers are very integer-like as well.
16:39:46 <Mitar> but i do not have a recursive function going over the abstract tree
16:39:59 <Mitar> i would like to lazily evaluate it ...
16:40:06 <SamB> ddarius: heh
16:40:11 <Toxaris> Mitar: that shouldn't be a problem
16:40:11 <Mitar> http://hpaste.org/4233
16:40:24 * dmwit doesn't mind saying obvious things from time to time
16:40:51 <Mitar> i would like to divide parsing phase (and code) from semantic analysis
16:41:06 <Mitar> so I would like to have all semantic analysis code in checkType functions
16:41:25 <SamB> Mitar: that is the usual way of things...
16:41:29 <Mitar> which would also have to change environemnt accordingly
16:42:19 <Mitar> but i would also like not to have a recursive function which would map an anbstract tree to a new tree but to do this in one step ...
16:42:29 <Philippa> what do you mean, "in one step"?
16:42:29 <Mitar> to use laziness :-)
16:42:43 <Mitar> like this: let tree = SynScope syns (checkType tree undefined)
16:43:11 <Toxaris> Mitar: you would use laziness even when you define multiple AST types for the results of the various processing phases
16:43:16 <Mitar> where the second element of SynScope is a semantic checked type of an abstract tree node SynScope
16:43:42 <Toxaris> Mitar: but you can leave your current design as it is, and use parsec to thread the state through wich is used by your checkType functions
16:45:01 <nottha_k> dons: lot's of things seem to have "hidden" dependencies. haddock is the most recent one i tried with that error
16:45:01 <Mitar> Toxaris: but how can I update the state? the "logic" behing this would need to be somewhere and I would not like that it would be in a parsing step
16:45:50 <Toxaris> Mitar: consider checkType :: State -> Syn -> (State, Type)
16:45:59 <dons> nottha_k: oh, possibly you're installing things as --user ?
16:46:06 <nottha_k> dons: yeah
16:46:06 <dons> so not using --user
16:46:18 <dons> right. if you install as --user, you need to configure with --user on
16:46:22 <dons> for those packages to be found
16:46:29 <Toxaris> Mitar: the caller of checkType, namely the parser code, would only be responsible of storing the State
16:46:37 <hpaste>  Mitar annotated "semantic analysis, how?" with "if I could do this ..." at http://hpaste.org/4233#a1
16:46:43 <nottha_k> dons: i'm using cabal-install actually
16:47:02 <nottha_k> dons: they fail on the configure step.
16:47:12 <nottha_k> dons: oh wait no.
16:47:17 <nottha_k> dons: the build step
16:47:20 <ddarius> Mitar: Why can't you do that?
16:47:28 <SamB> Mitar: how many haskell compiler have you hacked?
16:47:38 <dons> nottha_k: what tool fails?
16:47:53 <Mitar> because tree is not defined when i call buildEnv
16:48:01 <Mitar> SamB? none? why?
16:48:44 <ddarius> Mitar: Just remove that second let so they are in the same binding group.
16:49:00 <ddarius> > let { a = 1:b; b = 2:a } in a
16:49:06 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
16:49:11 <nottha_k> dons: tool?  haddock-0.8
16:49:14 <Mitar> this can be done in a do?
16:49:24 <Toxaris> Mitar: monads are lazy, too :)
16:49:39 <SamB> Toxaris: eh?
16:49:44 <ddarius> Mitar: 1) You can use normal lets in a do 2) the translation is trivial
16:50:00 <dons> nottha_k: ok, i'll see if i can build it with 6.8
16:50:00 <Saizan> :t \f = ContT $ \k -> (k ()) >>= f -- which name would you use for this?
16:50:01 <lambdabot> parse error on input `='
16:50:09 <ddarius> @undo do x <- m; let { y = x + 1 }; return y
16:50:10 <lambdabot> m >>= \ x -> let { y = x + 1} in return y
16:50:13 <dons> $ cabal install haddock-0.8
16:50:23 <dons> Downloading 'haddock-0.8'...
16:50:25 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4234
16:50:27 <dons> Configuring haddock-0.8..
16:50:32 <dons> src/Main.hs:49:7:
16:50:32 <dons>     Could not find module `System.Directory':
16:50:32 <dons>       it is a member of package directory-1.0.0.0, which is hidden
16:50:43 <dons> $ cabal install directory
16:50:43 <dons> All requested packages already installed. Nothing to do.
16:50:44 <dons> mm
16:50:44 <Toxaris> SamB: there is nothing strict with monadic code, it's execution is driven by data dependencies just like normal haskell code, this even includes IO and ST, the only difference is that that the data dependencies may be hidden by syntactic sugar like do notation
16:50:51 <Mitar> translation is trivial? to what? from do to without do syntax?
16:51:04 <ddarius> Mitar: Yes.
16:51:06 <nottha_k> dons: have to add directory to haddock.cabal to fix
16:51:08 <SamB> Toxaris: single lets aren't monadic anyway
16:51:18 <Mitar> ddarious: thanks, i will check this ...
16:51:35 <Mitar> obviously I will have to hack some haskell compilers more
16:51:37 <Mitar> :-)
16:51:37 <dons> nottha_k: ah yes. its just not been updated for 6.8 yet
16:51:44 <dons> probably the darcs haddock is
16:51:47 <dmwit> ?wiki monads as computation
16:51:47 <lambdabot> http://www.haskell.org/haskellwiki/monads_as_computation
16:52:02 <Mitar> so then i will not have to use the state monad?
16:52:07 <Mitar> if i redo it like this?
16:52:10 <dmwit> Mitar: http://www.haskell.org/haskellwiki/Monads_as_computation#Do_notation
16:52:11 <SamB> Mitar: well, really, if you hacked anything with a typechecker it would probably help...
16:52:11 <lambdabot> Title: Monads as computation - HaskellWiki, http://tinyurl.com/379e6v
16:52:30 <SamB> as long as it was written in Haskell, and not [ny]hc
16:52:35 <Mitar> i have done it .. but not in haskell :-)
16:52:57 <SamB> ([ny]hc have the hairiest typechecker ever!)
16:53:06 <ddarius> Assuming buildEnv does something reasonable, no you wouldn't, but then you would be doing two-passes over the syntax.
16:53:08 <dons> that's just a rumour, SamB
16:53:12 <Mitar> and i have done one type checker in haskell but it was a recursive function like in any other language traversing the tree
16:53:12 <dons> and you shouldn't repeat rumours
16:53:21 <SamB> oh, okay, maybe tcc has a worse typechecker
16:53:34 <ddarius> dons: I heard a rumor that that was just a rumor.
16:53:53 <SamB> dons: but the developers said it that it was really bad
16:54:15 <dmwit> They say that rumours can have a colonel of truth.
16:54:27 <idnar> I always thought they had a major of truth
16:54:34 <dons> a colonel of truth!
16:54:40 <Mitar> but i have to make dual two passed (not in this example but in the real program i am making) as I have also mutually recursive types ...
16:54:41 <Philippa> in the bedroom, with the rope
16:54:43 <mrd> or a private johnson
16:54:45 <dons> a field marshal of deception!
16:54:48 <Mitar> or will then be three passes?
16:54:49 <SamB> I'm not worried unless it's a minister of truth
16:55:28 <dons> the grand inquisitor of fibonacci
16:55:34 <nottha_k> regex-base is another one that was failing on 6.8 for more reasons
16:55:35 <ddarius> Mitar: There is a trick to do it in one pass with lazy languages.
16:55:48 <SamB> hint: have you heard of a ministry of truth?
16:55:54 <dons> what's a better, cuter sequence than fibonacci ?we need a new not-benchmark
16:55:55 <Mitar> ddarious: how?
16:56:01 <dons> Cale: suggestions?
16:56:10 <monochrom> tower of hanoi
16:56:29 <SamB> dons: number of still lives having a given number of cells
16:56:35 <mkehrt_office> look and say
16:56:36 <dons> not bad, monochrom
16:56:38 <mkehrt_office> sequence
16:56:55 <monochrom> lately I invented the Pisa Tower of Hanoi. :)
16:56:59 <dons> heh
16:57:12 <ddarius> Mitar: You build the environment as you parse and return it and pass in that environment as the initial one, kind of like what you suggest with buildEnv only building the environment is done as you parse (which is often necessary anyway for other things)
16:57:25 * dmwit starts at OEIS id A000001
16:57:29 <Cale> dons: How about the number of partitions of an integer?
16:57:41 <dons> @help oeis
16:57:41 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
16:58:04 <dons> was there a plan to have the Math.OEIS provide haskell versions of the seuquences?
16:58:12 <dmwit> dons: A000004
16:58:20 <dons> ?oeis A000004
16:58:20 <lambdabot> The zero sequence.
16:58:20 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:58:40 <dmwit> ;-)
16:58:48 <dons> anyone else thing the lib should print out the code to generate the sequence too, where known?
16:58:49 <Mitar> initial one: initial like after the first pass when i have to check the recursive types yet?
16:58:50 <mrd> ?oeis 1 4 9 16
16:58:50 <lambdabot> The squares: a(n) = n^2.
16:58:50 <lambdabot> [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:58:52 <ddarius> > (length "repeat 0", length "fix (0:)")
16:58:54 <lambdabot>  (8,8)
16:58:54 <SamB> dons: http://www.research.att.com/~njas/sequences/A019473
16:58:54 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
16:59:00 <ddarius> > fix(0:)
16:59:00 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:59:02 <dons> ?oeis A019473
16:59:03 <lambdabot> Number of stable n-celled patterns ("still lifes") in Conway's game of Life.
16:59:03 <lambdabot> [0,0,0,2,1,5,4,9,10,25,46,121,240,619,1353,3286,7773,19044,45759,112243,27318...
16:59:10 <mrd> ?oeis 1 5 14
16:59:10 <lambdabot> Square pyramidal numbers: 0^2+1^2+2^2+...+n^2 = n(n+1)(2n+1)/6.
16:59:10 <lambdabot> [0,1,5,14,30,55,91,140,204,285,385,506,650,819,1015,1240,1496,1785,2109,2470,...
16:59:14 <Mitar> but then parsing step is not seperated with semantic step ...
16:59:25 <dmwit> ?oeis 1 2 2 3 2 4 2 4 3 4 2 6
16:59:26 <lambdabot> d(n) (also called tau(n) or sigma_0(n)), the number of divisors of n.
16:59:26 <lambdabot> [1,2,2,3,2,4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,4,...
17:00:01 <dmwit> That could be a reasonable micro-benchmark.
17:00:15 <Cale> ?oeis Partitions of an integer
17:00:15 <lambdabot> Triangular array illustrating the application of cyclic partitions to the com...
17:00:15 <lambdabot> [1,0,1,1,0,1,1,2,0,1,2,2,3,0,1,2,5,3,4,0,1,4,6,9,4,5,0,1,4,13,12,14,5,6,0,1,7...
17:00:18 <dons> ah, Math.OEIS does do some of what I expected, actually,
17:00:22 <dons> Prelude Math.OEIS> extendSequence [5,7,11,13,17]
17:00:22 <Cale> oy
17:00:29 <mkehrt_office> ?oeis 1 11 21 1211
17:00:29 <lambdabot> Look and Say sequence: describe the previous term! (method A - initial term i...
17:00:29 <lambdabot> [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113...
17:00:48 <dmwit> Mmm, yes, run-length encoding.
17:01:58 <Mitar> ddarius: what a sec, why would this approach i suggested do two passes? buildEnv will not traverse a tree, it wil just use data from tree variable to build new env - I am only removing the code from parsing step to budilEnv step, I could do the same thing in a do block when parsing ...
17:02:31 <mrd> the cosmological theorem sequence
17:02:59 <mrd> ?oeis 1 1 2 5 14
17:02:59 <lambdabot> Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called ...
17:02:59 <lambdabot> [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35...
17:03:17 <mrd> another fun one too
17:03:28 <ddarius> Mitar: It won't reparse, but it will traverse the tree another time (possibly, depending on how you do it, retraversing subtrees a quadratic number of times)
17:03:34 <TSC> ?oeis 1 2 3 4 5
17:03:34 <lambdabot> The natural numbers. Also called the whole numbers, the counting numbers or t...
17:03:34 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:03:45 <TSC> Glad it got that (:
17:03:48 <Pseudonym> ?oeis 1 2 4 8 15
17:03:48 <lambdabot> Tetranacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) +a(n-4).
17:03:48 <lambdabot> [0,0,0,1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536,10671,20569,39648,76...
17:03:52 <phlpp> > let rle s = map (\x -> show $ length s ++ [head s]) (group s) in rle "WWWAAA"
17:03:53 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
17:04:01 <ddarius> (rather a linear number of times, recalculating a quadratic amount of data)
17:04:11 <phlpp> > let rle s = map (\x -> (show $ length s) ++ [head s]) (group s) in rle "WWWAAA"
17:04:12 <SamB> ?oeis 0, 0, 0, 2, 1, 5, 4, 9
17:04:12 <lambdabot>  ["6W","6W"]
17:04:12 <lambdabot> Number of stable n-celled patterns ("still lifes") in Conway's game of Life.
17:04:12 <lambdabot> [0,0,0,2,1,5,4,9,10,25,46,121,240,619,1353,3286,7773,19044,45759,112243,27318...
17:04:14 <dmwit> > map (length &&& head) . group $ "WWWAAA"
17:04:14 <lambdabot>  [(3,'W'),(3,'A')]
17:04:14 <mrd> an integer sequences bot in a channel full of geeks? recipe for spam
17:04:37 <ddarius> mrd: An being able to evaluate arbitrary expressions wasn't already?
17:05:01 <Mitar> hmm, i do not get it, if i in buildEnv do not call recursivelly no function on tree then it will not traverse it, or will it?
17:05:25 <ddarius> Mitar: How does buildEnv work?
17:05:30 <Mitar> s/no/any/
17:05:48 <phlpp> ?oesis 1283 292 83912 10
17:05:49 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:05:50 <dons> why does the wikipedia towers of hanoi page say "can be implmented elegantly in haskell", is categorised as a page with haskell code, yet doesn't have haskell code on the page?
17:06:04 <phlpp> ?oesis 123,123,451,2
17:06:04 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:06:15 <mrd> dons: because you haven't fixed it yet!
17:06:18 <dons> however, it does have some ocaml first up. i wonder if the haskell was removed at some piont?
17:06:20 <ddarius> dons: That was the code.  It was so short it wasn't even there.
17:06:46 <dons> something like,
17:06:46 <dons> moveTower 1 a b c = [(a,c)]
17:06:47 <dons> moveTower n a b c = (moveTower (n-1) a c b) ++ (moveTower 1 a b c) ++ (moveTower (n-1) b a c)
17:07:54 <Mitar> when called on a SynVar it will add a (identifier,getType(var)) to the environemtn
17:07:59 <dmwit> The comments on the sequence [1,1..] are ridiculous.
17:08:01 <monochrom> Only those who have finished the Original Tower of Hanoi can see the code. :)
17:08:17 <Mitar> when called on a scope it will add another level to the environemnt
17:08:50 <Mitar> (so that adding SynVar with the same name as before will not produce an error - otherwise this will be checked)
17:09:20 <Mitar> the point is that I will use getType to get types and will not recheck everyhing again
17:09:20 <ddarius> @oeis 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
17:09:21 <lambdabot> The simplest sequence of positive numbers: the all 1's sequence.
17:09:21 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:09:35 <ddarius> That wasn't what I was looking for.
17:09:52 * mrd looks for the integer sequence of infinite ones ended by 2
17:09:59 <Toxaris> @oeis 2 2 2 2 2 2
17:10:00 <lambdabot> Number of distinct primes dividing n (also called omega(n)).
17:10:00 <lambdabot> [0,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,2,1,2,...
17:10:06 <scook0> > fix (1:) ++ 2
17:10:14 <lambdabot>   add an instance declaration for (Num [t])
17:10:20 <scook0> > fix (1:) ++ [2]
17:10:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:10:53 <dmwit> Toxaris: Wait, what just happened?
17:11:14 <Toxaris> dmwit: I'm waiting. What for?
17:11:15 <dmwit> Oh, it must have 2 2 2 2 2 2 as a subsequence.
17:11:24 <Toxaris> dmwit: yes, think so, too
17:11:25 <dmwit> Never mind.
17:11:49 <Toxaris> dmwit: I hoped for something like "The simples sequence of numbers bigger then 1: the all 2's sequence"
17:11:59 <dmwit> yeah =)
17:12:07 <monochrom> me too
17:13:43 <Toxaris> @oeis 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
17:13:44 <lambdabot> The all 2's sequence.
17:13:44 <lambdabot> [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
17:13:48 <Toxaris> @oeis 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
17:13:49 <lambdabot> Number of digits in decimal expansion of n.
17:13:49 <lambdabot> [1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
17:13:56 <Mitar> ddarius: can you describe me (or point me to some text about making a semantic analysis step in a lazy language) more precisely how would you do this one step less analysis?
17:14:10 <dmwit> Weird.
17:14:19 <Pseudonym> @oeis 1 2 4 8 16 31
17:14:20 <lambdabot> Pentanacci numbers: a(n+1)=a(n)+...+a(n-4).
17:14:20 <lambdabot> [0,0,0,0,1,1,2,4,8,16,31,61,120,236,464,912,1793,3525,6930,13624,26784,52656,...
17:15:24 * mrd chuckles at how the name Fibonacci has been twisted.  It wasn't even the guy's name in life.
17:16:46 <LoganCapaldo> where are the fibonactorial numbers?
17:17:15 <mrd> how about the potato pasta numbers: fibognocchi
17:17:24 <Mitar> mrd: and what was his name?
17:17:46 <mrd> Leonardo of Pisa
17:18:19 <Mitar> and how does it come to fibonacci?
17:18:43 <mrd> a nickname shortened from filius Bonacci
17:19:47 <dmwit> ?oeis 1 3 5 9 13 17 25
17:19:47 <lambdabot> Reve's puzzle: Tower of Hanoi with 4 pegs.
17:19:47 <lambdabot> [1,3,5,9,13,17,25,33,41,49,65,81,97,113,129,161,193,225,257,289,321,385,449,5...
17:19:59 <dmwit> No proven optimal solution.
17:21:08 <ddarius> Mitar: It's a circular programming trick.  There are papers on circular programming but I don't know if they specifically mention this trick.  It's a folklore thing at this point.
17:21:21 <ddarius> I'm sure it's in something somewhere.
17:21:47 <SamB> oooh, that sounds actually interesting...
17:21:50 <SamB> 4 pegs!
17:21:52 <SamB> wow
17:22:00 <Mitar> folklore in a functional programming?
17:22:03 <dmwit> Yeah, it's not so obvious how to use that extra peg. =)
17:22:23 <LoganCapaldo> mmm folklorical programming
17:22:27 <ddarius> Mitar: There is folklore in every field of interest.
17:22:36 * Liskni_si had 4-peg hanoi as a bonus homework in a freshmen year at college
17:22:52 <LoganCapaldo> wouldn't 4 peg hanoi be easier?
17:22:54 <SamB> for some reason there is even folklore about 3-peg hanoi
17:23:05 <SamB> LoganCapaldo: no
17:23:30 <LoganCapaldo> but you have an extra peg to stick stuff
17:23:35 <LoganCapaldo> on
17:23:40 <dmwit> Liskni_si: I also saw it first in a Haskell programming course.  (Not one I'd taken.)
17:23:46 <SamB> yes, but now there is more than one possible solution
17:23:56 <dmwit> LoganCapaldo: The solutions are shorter, but it is not obvious how to do it optimally.
17:23:56 <Liskni_si> dmwit: Wasn't related to Haskell at all.
17:24:14 <LoganCapaldo> what's with this optimal nonsense? :)
17:24:17 <Liskni_si> dmwit: (and my solution wasn't using haskell either)
17:24:33 <ddarius> http://citeseer.ist.psu.edu/549784.html
17:24:34 <lambdabot> Title: On Folk Theorems - Harel (ResearchIndex)
17:24:36 <dmwit> LoganCapaldo: In fact, a good solution is much, much faster than a bad one. =)
17:25:08 <SamB> LoganCapaldo: with three pegs, there is ONE way that ALWAYS gets the shortest solution, no matter how many rings you have...
17:25:57 <LoganCapaldo> I'm clearly way too in "get it done, no one cares how" mode tonight :)
17:26:18 <monochrom> Not a bad thing sometimes.
17:28:10 * SamB wants to pummel people who discriminate against folk theorems
17:51:30 <dons> ?users
17:51:30 <lambdabot> Maximum users seen in #haskell: 429, currently: 402 (93.7%), active: 12 (3.0%)
17:58:02 <dmwit> > 18*18
17:58:17 <lambdabot>  thread killed
17:58:29 <dmwit> uh?
17:58:38 <dons> sometimes the virtual host takes a while to wake up
17:58:41 <esteban3> > 18*18
17:58:42 <dons> > 18*18
17:58:42 <lambdabot>  324
17:58:42 <lambdabot>  324
17:58:48 <dons> if there's been some idleness
17:58:52 <dons> i'll increase the timeout threshold
17:58:59 <dmwit> Oh, okay.
17:59:08 <dmwit> That's alright, now that I know. =)
17:59:22 <dons> its a little annoying :)
17:59:34 <dons> didn't happen when we had a dedicated machine
17:59:48 <Pseudonym> Curse you, new world order!
17:59:52 <Pseudonym> Go back to Sydney!
18:00:48 <dons> ok, should be fixed now.
18:01:08 * glguy needs to get a fibonacci number list for his os x "dashboard"
18:01:16 <glguy> these things come up way too often on euler :)
18:01:52 <dons> Pseudonym: Light Rain and 40 degrees F, The wind chill is 33 :)
18:02:01 <Pseudonym> What's a F?
18:02:10 <dons> Fucked up, that's what.
18:02:24 <Pseudonym> 40 degrees Fucked up
18:02:27 <Pseudonym> That makes sense.
18:02:41 <dons> ?google 33 F in C
18:02:41 <lambdabot> 33 degrees Fahrenheit = 0.555555556 degrees Celsius
18:02:52 <dons> glguy: heh.
18:02:55 <dons> that would be awesome
18:02:57 <Pseudonym> So, much like midnight in Canberra.
18:03:42 <dons> yeah, just wetter
18:04:38 <glguy> I've done the math in class, but the relationship between sqrt 5 and fibonacci numbers still amazes me :)
18:04:52 <gwern> I gotta say, yi has one interesting and intricate structure to its code
18:05:28 <Pseudonym> glguy: It makes more sense in continued fractions.
18:06:02 <dons> gwern: it's fractal
18:07:00 <dons> mmm
18:07:01 <dons> IronPython 1.1 (1.1) on .NET 2.0.50727.832
18:07:02 <dons> Copyright (c) Microsoft Corporation. All rights reserved.
18:07:02 <dons> >>> from System import IntPtr
18:07:02 <dons> >>> IntPtr.Zero == IntPtr.Zero
18:07:03 <dons> True
18:07:06 <dons> >>> [IntPtr.Zero] == [IntPtr.Zero]
18:07:09 <dons> False
18:07:11 <dons> http://blog.kamil.dworakowski.name/2007/12/ironpython-bug-that-costed-me-can-of.html
18:07:12 <lambdabot> Title: Programmer's Weblog: IronPython bug that cost me a can of Coke, http://tinyurl.com/27oaoz
18:07:16 <gwern> @index with
18:07:16 <lambdabot> Foreign.Marshal.Utils, Foreign.Marshal, Foreign
18:07:35 <davidL> dons: is this the correct darcs repo for hs-plugins? http://www.cse.unsw.edu.au/~dons/code/hs-plugins
18:07:36 <lambdabot> Title: Index of /~dons/code/hs-plugins
18:07:40 <dons> it is
18:07:44 <davidL> thanks
18:08:14 <dons> why does MS have a python interpreter?
18:08:23 <dons> oh, a .NET one. i c
18:08:26 <gwern> dons: extend, embrace...
18:08:32 <dons> like F#
18:08:37 <Mitar> i am using Error Monad, is it possible to "lift" lookup function to a Error monad (so that I do not have to check if it is Just or Nothing but that it will just throw an exception if it is Nothing)
18:08:39 <gwern> er, I mean, embrace, extend... :)
18:09:23 <davidL> uhh, dpkg wants to install exim4 to install darcs...wtf
18:09:30 <monochrom> Which lookup? Set.lookup? Map.lookup? (Yes to both.  Just write: do .... x <- Map.lookup x y; ... )
18:09:38 <dons> i wonder how hard it would be to spit F# out of GHC core, and get .NET support for free
18:09:41 <gwern> davidL: for 'darcs send'
18:09:45 <monochrom> @type Data.Map.lookup
18:09:46 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
18:10:02 <monochrom> See it is happy with any monad whatsoever :)
18:10:04 <davidL> gwern: but you can set it to use any mail client
18:10:19 <gwern> davidL: yes, I know... on gentoo, it insists on installing ssmtp. go figure
18:10:29 <dons> what's does lookup do in Cont and List ?
18:10:37 <davidL> silly package maintainers
18:11:09 <allbery_b> list presumably returns [] vs. [val]
18:11:21 <dons> and error for Cont
18:11:28 <monochrom> It calls your monad's "fail" method if the query turns up nothing. It calls your monad's "return" method if the query turns up an answer.
18:11:30 * allbery_b is amused by the thought of Cont 
18:11:44 <dons> Cont doesn't define fail, does it?
18:11:59 <Saizan> it doesn't
18:12:05 <monochrom> Then the default for fail is adopted.
18:12:11 <dons> instance Monad (Cont r) where return a = Cont ($ a) m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
18:12:12 <Mitar> List lookup
18:12:33 <monochrom> List lookup. Well then you have to write your own code. :)
18:12:46 <Mitar> why?
18:12:54 <Mitar> why it works for all others?
18:12:55 <monochrom> @type Data.List.lookup
18:12:58 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:13:08 <monochrom> The others were designed in the Space Age.
18:13:12 <Saizan> Mitar: in that case you've to write a maybeToM = maybe mzero return
18:13:22 <monochrom> List's was designed in the Industrial Age.
18:14:46 <dons> mm
18:14:52 <jimstutt> dons: hs-plugins-0.1-rc0.tar.gz => "missing text2page"
18:15:00 <dons> harmless, jimstutt
18:15:09 <dons> and you'll need the darcs repo for ghc 6.6.
18:15:10 <jimstutt> dons: tnx
18:17:13 <dons> #haskell needs more pomp and ceremony
18:17:22 <dons> why don't we have any pomp?
18:17:27 <dons> or circumstance, for that matter
18:17:29 <blackdog> hey, anyone had any luck installing ghc 6.8.1 for Leopard? I keep getting 'installPackage: Multiple files with extension buildinfo
18:17:33 <blackdog> '
18:17:33 <TSC> Who let the pomp out?
18:17:34 <blackdog> on readline...
18:17:42 <monochrom> because it is a text channel, not a multimedia channel.
18:17:48 <blackdog> ascii art, maybe?
18:17:54 <jimstutt> dons: newb sticking with learning 6.8.1 despite much build grief. Now 54 pks built. HDBC, HAppS, haskore, Takusen all failed for me.
18:17:56 <PauloZanoni> hello! I'm starting to learn haskell today, and I'm trying to make an algorithm that adds 2 matrix. If anyone could point what is wrong with my program, I would really thank you... (www.inf.ufpr.br/prz05/matrix.hs)
18:18:20 <dons> jimstutt, ok. those are the more esoteric/larger ones
18:18:36 <dons> i'd expect them to either be updated in their darcs repos, or not updated (for takusen and haskore)
18:19:20 <TSC> PauloZanoni: It would probably help if you put type declarations on the functions
18:19:29 <TSC> Then you (and we) can see what each one is supposed to do
18:20:25 <TSC> (I think you have a typo, too: "add_matrix x3 y4" should be "add_matrix x3 y3", in add_four)
18:20:25 <Saizan> jimstutt: so you're installing all of hackage just for the sake of it?
18:20:26 <monochrom> "The matrix is a list of four elements. Each one is another matrix" is an indication that you're over-complicating.
18:20:34 <PauloZanoni> TSC: I have unsucessfully tried...
18:20:50 <dons> jimstutt: perhaps keep track of which ones fail, and report them to libraries@haskell.org
18:20:56 <dons> or their maintainers directly
18:21:06 <jimstutt> dons: trbl is us newbs get the new thing with its new things. Misses out things soon to be deprecated. I wanted to see HS behaviour and they's the sort of pop apps aren't they that at least I've prematurely expected.
18:21:22 <monochrom> Why not the simpler and easier-to-see-why-it-works "The matrix is a list of four rows. Each one is a column."
18:21:37 <monochrom> err, "The matrix is a list of four rows. Each one is list of columns."
18:21:38 <PauloZanoni> monochrom: recursivelly adding square matrices is the smallest "example" of what I was trying to do
18:22:17 <dons> jimstutt: well, ghc 6.8 is very new, so not every large project has updated for it yet
18:22:49 <monochrom> There is no recursion in the definition of matrices. You have a list of rows. A row is a list of columns. A column is a number. Finish. You cannot have "a column is a matrix all over again".
18:23:12 <njbartlett> I've had an absolute bitch of a time getting wxHaskell working recently
18:23:28 <dons> yeah, esp. projects with no maintainers
18:23:35 <dons> such as haskore, or wxhaskell
18:23:48 <njbartlett> dons: wxhaskell is maintained
18:23:51 <dons> it is?
18:23:53 <dons> by whome?
18:23:57 <dons> with an e
18:24:01 <TSC> who me?
18:24:08 <dons> heh
18:24:11 <njbartlett> There's even a relatively active mailing list
18:24:19 <jimstutt> dons: yep, but driving from functional tests has always seemed a good idea. The apps code base isn't huge and Ros Paterson's upgrade  tests as a regular bulletin. U know, Continuous build.
18:24:27 <dons> yep.
18:24:32 <dons> that's needed infrastructure.
18:24:48 <dons> i hope to get some time to work on that next year actually, since it could be important for work
18:25:03 <dons> tests, code coverage reports, failures, for the entire haskell codebase
18:25:09 <dons> would be pretty special
18:25:19 <PauloZanoni> monochrom: but I'm using square matrices...
18:25:29 <monochrom> I'm talking about square matrices.
18:26:36 <jimstutt> dons: all haskell is brilliant. I've spent from Z to cats to haskell but thought I'd survey first and learn to build and configure. searchpath is my new maven?
18:26:39 <njbartlett> In fact, I've not just had a problem with wxhaskell... I can't seem to find any working GUI library for Haskell on Mac OS
18:27:13 <dons> njbartlett: oh hmm. now that's interesting. so gtk2hs isn't ok?
18:27:29 <dons> nor the revival of hoc recently?
18:27:42 <njbartlett> dons: Well it claims to work on Mac, through Mac ports. Doesn't work for me though
18:27:51 <jimstutt> njbartlett: yeh, I;m not looking at my 'scrupulous' notes so I'd forgotten wxhaskell fails.
18:28:04 <PauloZanoni> monochrom: so forget it is a matrix. just consider that there are lists with four elements, and each element may be a list with four elements or lists with a number =P
18:28:21 <njbartlett> wxhaskell I actually got to compile, although there was no documentation on which version of wxWidgets was required. Unforunately the apps built with wxhaskell don't run
18:28:42 <njbartlett> And HOC... well, I haven't tried that yet. To be honest I'd prefer something cross-platform though :-(
18:28:53 <dons> the larger, older libs can struggle a bit in the move to cabal and faster release cycles, esp. once they lose their initial maintainer
18:29:18 <dons> njbartlett: ok. i'd really think gtk2hs is the main option here -- wxhaskell is just too hard to build for now.
18:29:26 <dons> perhaps talk to the gtk2hs guys, if you attempts stall
18:29:37 <allbery_b> there are general problems with non-Aqua GUIs on OSX
18:29:55 <allbery_b> erm, correct that
18:29:57 <njbartlett> dons: Okay. Although even if it works, it only works through X11 which is a bit sucky on Mac.
18:30:02 <allbery_b> with Aqua-based GUIs really
18:30:06 <allbery_b> X11 stuff works as expected
18:30:07 <monochrom> Someone else will answer your question. It's too complicated for beginners IMO. I'm not going to do it.
18:30:20 <allbery_b> Aqua you need to package the program as an OSX app, or it won't be permitted to do GUI stuff
18:30:29 <jimstutt> dons: I;m just failing on gtk2hs - they're aint no configure as per destructions in the darcs download
18:30:29 <njbartlett> At least wx builds proper aqua apps, although they are Carbon rather than Cocoa
18:30:44 <dons> gwern: for shame "this shows that doing recursion in Ruby/Haskell/whatever is not so hot" -- the whole war was about the fact haskell was hot for doing recursion ;)
18:31:00 <allbery_b> somewhere or other is an app-maker script for wxwindows
18:31:47 <ZimeTime> So this program is suppose to evaluate some function "f" at point a    ..except it doesn't work.
18:32:03 <ZimeTime> evaluate :: String -> Double -> Double
18:32:03 <ZimeTime> evaluate f a = (\ x -> putStrLn f ) a
18:32:24 <Toxaris> PauloZanoni: that's not how Haskell works ;) you have to decide beforehand if a value should be a list or a number (or if it explicitly can be either a list or a number). are you writing some real app or just playing around
18:32:25 <monochrom> putStrLn doesn't evaluate a function.
18:32:27 <dons> what is that trying to do, ZimeTime ?
18:33:05 <chessguy> i think he's saying evaluate = flip putStrLn
18:33:09 <dons> ZimeTime: do you want to print a string, and return some Double ?
18:33:14 <dons> or is it 'trace'
18:33:15 <monochrom> Is this an attempt at randomized programming or what?
18:33:39 <blackdog> looks more like trying to evaluate a string and get a function back from it, like javascript...
18:33:46 <dons> ZimeTime: what are you trying to do? we're all very confused
18:33:50 <dons> blackdog: ah!
18:33:56 <dons> and apply that to 'a' ?
18:33:57 <gwern> dons: it was a general point - don't show me how your language is better than another, show me how you work aruond the language's bad points
18:34:06 <ZimeTime> dons: I want to take some function (ex: x^2 + 3) and evaluate it at a point
18:34:15 <njbartlett> dons: You mentioned a revival of HOC? It looks to me like development stopped in 2004
18:34:20 <dons> and you want the function to be represented as a String, ZimeTime ?
18:34:32 <gwern> if a language sucks at recursion, that's a fact you're going to have to live with for a long time; so the relevant question is, how well can you cope?
18:34:36 <monochrom> Ha, "function" means "expression".
18:34:44 <dons> > let apply f a = f a in apply (\x -> x^2 + 3) 7
18:34:46 <lambdabot>  52
18:34:55 <ZimeTime> dons: I actually don't quite know, I'm a beginner
18:34:56 <dons> > (\x -> x^2 + 3) 7
18:34:57 <lambdabot>  52
18:35:02 <dons> > map (\x -> x^2 + 3) [1..10]
18:35:03 <lambdabot>  [4,7,12,19,28,39,52,67,84,103]
18:35:07 <dons> something like that?
18:35:45 <PauloZanoni> Toxaris: the main objective was to implement the Strassen algorithm (a recursive algorithm for matrix multiplication)
18:35:55 <dons> njbartlett: i thought there was a recent announcmenet
18:36:01 <dons> along the lines of 'hoc is dead, long live hoc'
18:36:05 <ZimeTime> dons: yes but what if I want the function to be an argument
18:36:11 <dons> right
18:36:42 <PauloZanoni> Toxaris: the "add_matrix" should be a generic function that plays with "lists of lists" and "add_four" should play with lists of 4 elements and add_one should play with lists of one element
18:36:43 <monochrom> and the argument is a string like "x^2 +   3"
18:36:49 <dons> > map (\f -> map f [1..10]) [(\x -> x^2 + 3), (\x -> x^3 - 7)]
18:36:49 <lambdabot>  [[4,7,12,19,28,39,52,67,84,103],[-6,1,20,57,118,209,336,505,722,993]]
18:37:03 <njbartlett> dons: Aha, you're right. I found the announcement. Thanks
18:37:17 <dons> ZimeTime: one thing is that the function can't be a String
18:37:29 <Toxaris> PauloZanoni: ok, the idea of Strassen is to divide a 2n x 2n matrix into four n x n matrices, right?
18:37:53 <ZimeTime> dons: that is take any function and evaluate it at any point ( the function and point the arguments right?
18:38:00 <dons> yep
18:38:06 <PauloZanoni> Toxaris: divide a 2^n x 2^n into four n x n
18:38:10 <dons> this is just the apply operator, ($)
18:38:17 <dons> > let apply = ($)
18:38:17 <lambdabot>  Parse error at end of input
18:38:22 <dons> ?let apply = ($)
18:38:29 <dons> > apply (\x -> x^2 + 3) 9
18:38:32 <lambdabot>   Not in scope: `apply'
18:38:35 <lambdabot> Defined.
18:38:39 <dons> > apply (\x -> x^2 + 3) 9
18:38:40 <lambdabot>  84
18:38:42 <dons> > apply (\x -> x^2 + 3) 1
18:38:42 <PauloZanoni> Toxaris: but the function I was ttying to do was just a very small exemple
18:38:42 <lambdabot>  4
18:38:49 <dons> like that, ZimeTime ?
18:39:03 <Toxaris> PauloZanoni: hmm. consider n = 5. 2^n = 1024. 1024x1024 is a lot more then 4 * 5x5.
18:40:52 <Toxaris> PauloZanoni: well anyway, I suggest you to code this for a fixed size matrix first, adding recursion later. (actually, i think this is what you already tried, but i'm not sure)
18:41:02 <mar77a> how can (10 -) be a function >:/
18:41:09 <mar77a> (sorry i come from a C background)
18:41:23 <Toxaris> PauloZanoni: looks like i wanted to use n = 10, but you see what I mean?
18:41:38 <dons> ?unpl (10 -)
18:41:38 <lambdabot> (\ a -> 10 - a)
18:41:52 <dons> mar77a: its using 'section' syntax, which means you can leave off the argument position
18:41:54 <mar77a> sorry, don't know lambdas yet
18:42:09 <dons> so, its an anonymous function that subtracts its argument from 10, yeah?
18:42:13 <dons>   f x = 10 - x
18:42:18 <dons> which can be written as:
18:42:19 <mar77a> so
18:42:21 <PauloZanoni> Toxaris: for fixed size it worked. the recursion was the problem...
18:42:21 <dons>    \x -> 10 - x
18:42:25 <dons> and using section syntax,
18:42:28 <dons>    (10 - )
18:42:33 <mar77a> so
18:42:39 <mar77a> > (10 -) 2
18:42:42 <lambdabot>  8
18:42:42 <ZimeTime> dons: well yes and no, maybe haskell just isn't the right programming language for me, but I want to write a basic program that takes a function and evaluates it at a point.
18:42:45 <njbartlett> Ah. The "new" HOC is just a placeholder at Google Code. No releases, empty subversion repository.
18:42:46 <dons> mar77a: right
18:42:49 <gwern> (>.< wow I've totally confused myself messing around in Yi. my brain hurts)
18:42:52 <pi3> Why is modulus `mod` and not %?
18:42:53 <mar77a> > 10 - 2
18:42:53 <lambdabot>  8
18:43:02 <mar77a> ohh i get it
18:43:15 <dons> ZimeTime: can you explain what the proogram should do? I think we're confused about what your requirements are.
18:43:18 <Toxaris> PauloZanoni: can you paste your working code for fixed size? you can use http://hpaste.org/ if you want?
18:43:21 <davidL> :t (%)
18:43:24 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:43:34 <Pseudonym> pi3: Historical reasons, but yeah, we use % for something else.
18:43:36 <dons> ZimeTime: you don't just want a function,  apply :: (Double -> Double) -> Double -> Double ?
18:43:46 <Pseudonym> Partly because we want to distinguish between mod and rem.
18:43:52 <dons> that takes a function on Double, applies it, and returns the result?
18:43:55 <glguy> in J, % is division :)
18:44:08 <davidL> > 3%100
18:44:10 <lambdabot>  3%100
18:44:18 <PauloZanoni> Toxaris: well, ill have to rewrite... wait a minute
18:44:20 <dons> ZimeTime: oh, you want to enter the function argument on the command line, or standard input ?
18:44:31 <dons> ZimeTime: and read that string, converting it to a Haskell function?
18:44:36 <dons> as blackdog originally suggested
18:44:44 <TSC> glguy: It is in Haskell too, sort of
18:44:59 <ZimeTime> exactly
18:45:06 <glguy> "sort of" ;)
18:45:32 <ZimeTime> dons: as an input
18:45:36 <TSC> You have to use your imagination a bit, I admit
18:45:41 <dons> ZimeTime: right. so the problem is how to parse a string into a Haskell function.
18:45:47 <davidL> > let x % y = mod x y in 7 % 4
18:45:48 <lambdabot>  3
18:46:02 <dons> ZimeTime: perhaps just wrap ghci.
18:46:13 <PauloZanoni> Toxaris: but it was just something like "add [x1, x2, x3, x4] [y1, y2, y3, y4] = [x1 + y1, x2 + y2, x3 + y3, x4 + y4]"
18:46:46 <ZimeTime> dons: wrap ghci?
18:47:08 <Toxaris> PauloZanoni: yeah, that looks sensible :) let's try it out using our favorite evaluation bot:
18:47:12 <gwern> ghci -e "take 100 $ [1..]"?
18:47:14 <ZimeTime> dons: shouldn't this work? evaluate f a = (\ x -> putStrLn f ) a
18:47:32 <Toxaris> > let add [x1, x2, x3, x4] [y1, y2, y3, y4] = [x1 + y1, x2 + y2, x3 + y3, x4 + y4] in add [1, 2, 3, 4] [1, 2, 3, 4]
18:47:33 <lambdabot>  [2,4,6,8]
18:47:45 <ZimeTime> dons: i mean it doesn't but I wish it would
18:47:47 <gwern> huh. ghc -e works as well
18:48:19 <Toxaris> PauloZanoni: ok, works. do you know the type of the add function?
18:48:25 <dons> ZimeTime: like:
18:48:27 <dons> $ apply.hs  "\x -> x ^ 3 + 1" 7
18:48:32 <dons> 344
18:48:51 <PauloZanoni> Toxaris: something like "[a] -> [a] -> [a]" ?
18:49:00 <dons> ZimeTime: no, your putStrLn program wouldn't work. it would just print the string in f
18:49:26 <dons> import System.Cmd
18:49:26 <dons> import System.Environment
18:49:27 <dons> main = do [f,n] <- getArgs system $ "echo '(" ++ f ++ ") " ++ n ++ "' | ghci -v0"
18:49:38 <Toxaris> PauloZanoni: yes, something like this. We have to say that "a" should be a numeric type to allow for the addition, but that's not the point now.
18:49:47 <Toxaris> PauloZanoni: now the question is, how to do recursion... :)
18:50:03 <mar77a> "So when you start thinking things like "This is too weird, I'm going back to C++!", try to force yourself to continue learning Haskell - you'll be glad you did.
18:50:17 <mar77a> i like how all haskell tutorials seem to encourage the reader unconditionally
18:50:48 <hpaste>  dons pasted "ZimeTime" at http://hpaste.org/4235
18:50:50 <Toxaris> PauloZanoni: we have a working add for 4x1-matrices. let's try to extend it to work with 4x4-matrices.
18:50:57 <dons> ZimeTime: -> like this program, http://hpaste.org/4235 ?
18:51:09 <Toxaris> PauloZanoni: what would be the type of this add2D?
18:51:56 <mar77a> i really like how haskell 'thinks' in the same way math does
18:52:14 <mar77a> "When variables are thought of as short-hands for values (just like they are in mathematics), it makes perfect sense that variable updates are not allowed. You wouldn't expect "4 = 5" to be a valid assignment in any language, so it's really quite strange that "x = 4; x = 5" is." for instance
18:52:30 <dons> yeah, that's a good observation, mar77a :)
18:52:37 <mar77a> on the other hand, doesn't this mean haskell can be really slow?
18:52:41 <PauloZanoni> Toxaris: you're thinking in using the "add 4x1" four times to add 4x4? that is not exactly the way I was trying...
18:52:44 <mar77a> or at least, memory intensive?
18:52:49 <ZimeTime> dons: oh good thinking! I think I can work with that.
18:52:52 <gwern> mar77a: sure
18:53:05 <mar77a> :(
18:53:08 <dons> there's some problems that need updates
18:53:17 <dons> but generally haskell's about 5-500x faster than python
18:53:21 <dons> so should be ok
18:53:32 <gwern> laziness alone can be a double-edged sword, at times giving you great memory usage, and at other times causing major space leaks
18:53:33 <mar77a> oh great
18:53:49 <mar77a> dons: so it's definitely faster than python?
18:53:53 <gwern> mar77a: the question is, is it fast enough and can the speed be improved when necessary? we think so :)
18:53:54 <dons> definitely.
18:53:56 <Toxaris> PauloZanoni: ok, so what matrices do you want to add using your add4-function recursively? 8x1?
18:54:12 <mar77a> gwern: you can disable such features? o_O
18:54:39 <dons> mar77a: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=python
18:54:40 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2deng4
18:54:42 <gwern> laziness can be banished with enough strictness annotations, yes...
18:55:05 <dons> maybe mar77a hasn't seen laziness yet.
18:55:11 <mar77a> i've
18:55:16 <gwern> dons: that's a good point
18:55:20 <dons> as he was asking about purity.
18:55:22 <PauloZanoni> Toxaris: the idea was to have an "add 1x1" and recursively split every matrix into 4 matrices until we were able to use "add 1x1"
18:55:30 <dons> purity does mean you can do optimisations not possible without
18:55:39 <mar77a> it's not the first tutorial im reading though dons :)
18:55:42 <dons> cool
18:55:48 <dons> installed ghc ?
18:55:52 <dons> tried a few programs?
18:55:53 <Toxaris> PauloZanoni: fine, but you haven't written any code to split the matrices
18:56:05 <mar77a> yes dons
18:56:09 <mar77a> quite amazing
18:56:16 <mar77a> by far the best language to experiment
18:56:16 <glguy> @paste
18:56:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:56:17 <monochrom> impurity means you can do optimizations by hand :)
18:56:32 <PauloZanoni> Toxaris: it was supposed to the the file I first sent to this channel =P
18:56:34 <mar77a> and i really like the math-like approach...im a maths lover even though i kinda suck at them
18:56:35 <hpaste>  glguy pasted "laziness makes cps look boring :)" at http://hpaste.org/4236
18:56:50 <Toxaris> PauloZanoni: at witch point in that file do you do any splitting?
18:56:58 <monochrom> I like laziness alot.
18:57:20 <dons> i'm more comfortable with it, now i can control it a bit easier
18:57:43 <monochrom> It only complicates cost accounting. But I know how to do even that.
18:57:50 * mar77a compares g++ with ghc
18:57:53 <PauloZanoni> Toxaris: the add_four was supposed to do it
18:58:06 * mar77a cries
18:58:13 <dons> well, do you want to write in C++ ?
18:58:27 <mar77a> i already do that
18:58:44 <dons> so the answer is "no" ? :)
18:58:53 <mar77a> the answer is: i find haskell much more interesting now that i know enough c++
18:58:55 <davidL> can you use assembly on the shootout?
18:59:11 <monochrom> Knowing every language is good. :)
18:59:11 <dons> oh, its not so bad. we're less than 5x slower than C++ on all but 1 benchmark
18:59:12 <mar77a> and i was told knowing a functional programming language would improve my coding skills
18:59:22 <dons> and meteor is out of date
18:59:31 <Toxaris> PauloZanoni: but add_four accepts only lists of four elements as arguments, not lists of arbitrary length
18:59:33 <dons> the average looks abotu 2x slower than C++
18:59:41 <codemac> So after deciding that I don't understand Monads in the least, is there a tutorial/doc or something that shows a practical use of a monad?
18:59:52 <dons> considering the level of abstraction involved, 2x is reasonable
19:00:06 <dons> codemac: a practical use? for a custom monad?
19:00:08 <mauke> codemac: no, all practical uses are of specific types, not monads in general
19:00:26 <codemac> I understand that it's a language feature
19:00:32 <PauloZanoni> Toxaris: yes but this is what it should do.
19:00:36 <mauke> codemac: not really
19:00:41 <dons> codemac: some practical uses are documented here, for the general concept, http://haskell.org/haskellwiki/Monad#Interesting_monads
19:00:42 <mauke> do syntax is
19:00:59 <dons> threads, backtracking, continuations, undoable computations, non-determinism
19:01:06 <dons> lots of cool things
19:01:19 <mar77a> LUA faster than python...
19:01:21 <mauke> parsing!
19:01:33 <dons> parsing!
19:01:44 <Toxaris> PauloZanoni: so you need to code it :) you need a function wich takes a big matrix and returns four smaller matrices. what type has a matrix? what type would this function have?
19:01:45 <mar77a> still much slower than haskell
19:01:52 <codemac> ok fine, import Control.Monad, whatever, but I mean that when I first learned OOP style programming, you had all these "Let's make a XXX application with classes".. I don't see any tutorials like that for writing your own monads.
19:02:31 <mauke> I normally don't write my own monads
19:02:33 <SamB> codemac: well, writing your own monads is different
19:02:39 <nostrademon1> sometime I want to write a blog posting about useful monads, because (writing in Python but knowing Haskell) I keep coming across all the problems that would be better solved with a monad than traditional Python idioms
19:02:49 <nostrademon1> internationalization, indentation & gensyms for code generation...
19:02:54 <codemac> SamB: ... well that's what I want to learn?
19:02:56 <Toxaris> PauloZanoni: as you may guess by now, this is not really the easiest algorithm to learn Haskell with... much easier is "add two matrices", that's an oneliner, maybe you should start with this, before heading straight to Strassen
19:03:03 <SamB> codemac: you ... don't do it nearly so often
19:03:12 <mauke> codemac: do you know monad transformers?
19:03:42 <codemac> SamB: ok. great. that doesn't stop me from wanting to learn how
19:03:45 <codemac> mauke: nope
19:03:49 <dons> ZimeTime: cool. hope that works.
19:03:58 <mauke> hmm
19:04:00 <PauloZanoni> Toxaris: I think I didn't explain correctly... In my example, a matrix is a list of four elements. Each element can be another list of four elements (which is another matrix) or a list with only one element (a number).
19:04:14 <SamB> codemac: the best way is probably to learn the laws and read a lot of existing monads...
19:04:20 <PauloZanoni> Toxaris: something like this: [ [ [1],[2],[3],[4] ], [ [1],[2],[3],[4] ], [ [1],[2],[3],[4] ], [ [1],[2],[3],[4] ] ]
19:04:27 <mauke> codemac: well, the "how" consists of writing two functions, >>= and return :-)
19:04:30 <Toxaris> PauloZanoni: what type does such a matrix have?
19:04:49 <PauloZanoni> Toxaris: it's a list of lists
19:04:57 <SamB> codemac: the tricky part is figuring out what monad to write
19:05:10 <Toxaris> PauloZanoni: a list of lists of what? of numbers or of even more lists?
19:05:26 <mar77a> ah...so C isn't really strongly typed
19:05:34 <mar77a> according to this definition at least
19:05:53 <gwern> right; static but weakly typed, I believe the phrase is
19:06:07 <mar77a> since some conversions are done silently i guess that means it allows some weak typing
19:06:15 <PauloZanoni> Toxaris: in the end we have numbers, but we don't know how many "levels" of lists of lists we have
19:06:36 <gwern> technically, doesn't strongly typed also entail memory safety?
19:06:43 <SamB> gwern: yeah
19:07:06 <mauke> I think it's a different axis
19:08:10 <PauloZanoni> Toxaris: well... in prolog I could do it with 5 lines =/
19:08:14 <Toxaris> PauloZanoni: ok, as I tried to tell you somewhere above, that is just not possible with Haskell lists. you have to decide beforehand (while writing your program) wich types the expressions in your program have, e.g., how many levels of lists you want. (of course, you can express such a data structure in haskell, just not with lists...)
19:09:11 <Toxaris> PauloZanoni: that's because prolog is dynamically typed (it tries to work out what types your values have at runtime, and dies if it doesn't work) and Haskell is statically typed (it proves while compiling that everything will work, but sometimes is a bit strict about it)
19:09:29 <Toxaris> PauloZanoni: have you heard about data type definitions?
19:10:27 <PauloZanoni> Toxaris: I have read something in a pdf today, but I was thinking that just "list of lists of whathever" was possible
19:10:41 <PauloZanoni> Toxaris: so you always must know how "deep" is your pile of lists?
19:11:26 <Toxaris> PauloZanoni: basically, yes.
19:12:24 <PauloZanoni> Toxaris: so you think it is not possible to implement it the way I was planning? =/
19:12:30 <thetallguy> PauloZanoni: The standard lists are as you describe
19:12:51 <thetallguy> PauloZanoni: but you can define Lisp style lists if you choose
19:13:33 <thetallguy> PauloZanoni: you don't get the nice built-in syntax, but you can get the same semantics
19:13:42 <PauloZanoni> thetallguy: I gotta learn Lisp then =P
19:13:57 <thetallguy> D'oh!
19:14:17 <SamB_XP> it had to happen sooner or later anyway ;-P
19:14:27 <PauloZanoni> Toxaris: so you suggest me to use "list of rows" or something like that?
19:14:31 <Toxaris> well, if you define your own data type, you can just define the type of "square matrices of size 2^n x 2^n for some n"
19:15:18 <PauloZanoni> Toxaris: hmmmm, that would be interesting
19:15:48 <Toxaris> PauloZanoni: we have this description of your data type: a matrix is either a number or four matrices.
19:16:11 <Toxaris> PauloZanoni: we can say this in Haskell!
19:17:11 <hpaste>  Toxaris pasted "Matrix type for PauloZanoni" at http://hpaste.org/4237
19:17:20 <mar77a> for some reason, i have the idea that only intelligent people can use haskell
19:17:28 <Toxaris> PauloZanoni, I hope you are fine with Double entries.
19:17:29 <mar77a> even for the more or less simple programs
19:17:46 <mauke> that's a feature
19:18:01 <Pseudonym> mar77a: I don't think it's only intelligent people, I think it's only teachable people.
19:18:18 <Toxaris> tutorial reading people?
19:18:25 <PauloZanoni> Toxaris, thetallguy: thank you a lot!
19:18:50 <PauloZanoni> Toxaris: I'll take a look at the tutorials to find out how those types work =)
19:19:18 <Toxaris> PauloZanoni: hehe do that :)
19:21:12 <mar77a> "We aren't writing applications in assembler anymore for the same reason we shouldn't be writing applications in C anymore."
19:21:39 <mar77a> HS/C = C/ASM (speed-wise) ?
19:22:01 <mauke> languages don't have an associated speed
19:22:09 <mauke> ASM is not a language
19:22:17 <Olathe> Lies.
19:23:14 <SamB_XP> if you mean by that that Haskell programs are often faster than C programs... you'd be right!
19:23:46 <haedent_> is there a ghci :module line equivalent to "import qualified" or "import ... hiding" ?
19:24:32 <Olathe> bleh = Module.bleh
19:25:16 <Pseudonym> mar77: HS/C = C/ASM (maintainability-wise)
19:25:32 <mar77a> hmmm good point
19:25:43 <davidL> where in lambdabot would I import my own module containing functions that I want to be able to use in `> myfoo' evaluations?
19:25:48 <ninjaskeet> #is it alright
19:25:58 <ninjaskeet> to ask ridiculously stupid questions here?
19:26:12 <Olathe> @let myFoo a = a + 2
19:26:15 <lambdabot> Defined.
19:26:17 <Olathe> > myFoo 10
19:26:18 <lambdabot>  12
19:26:19 <mauke> yes, but you must be able to deal with stupid answers
19:26:26 <ninjaskeet> I can deal with that
19:26:42 <ninjaskeet> why can't I define things in interactive mode? (ghci specifically)
19:26:52 <Pseudonym> Assembly programmers can write faster programs than C programmers, but only because assembly programmers are allowed to use the C compiler to write most of the code (keeping assembler for the tight inner loops that profiling has found).
19:26:57 <mar77a> you can ninjaskeet
19:27:01 <Pseudonym> Haskell and C have a similar relationship.
19:27:03 <Olathe> ninjaskeet: Have you tried 'let f a = a + 2' ?
19:27:40 <LoganCapaldo> ninjaskeet: you "can't" because ghci is a bit like you're inside a do block
19:28:04 <ninjaskeet> oh that's interesting...
19:28:09 <clanehin> erm . . . that would be a rediculously stupid question because Olathe had just answered it, he's testing us (do I get a cookie?)
19:28:12 <LoganCapaldo> if you always pretend you're in a do block when you use ghci that'll geive you a pretty good idea for waht you can / can not do
19:28:22 <mar77a> "We don't have to define what type phrase is, as Haskell uses type inference to infer at compile time the types of all expressions in the program" this somewhat reminds me of PHP
19:28:40 <ninjaskeet> thanks :)
19:28:43 <Pseudonym> It reminds me of how different it is from PHP.
19:28:53 <dons> mar77a: except that the types are checked at compile time
19:29:04 <dons> mar77a: and then erased, so the runtime code executes without checking
19:29:18 <mar77a> erased?
19:29:19 <dons> inference makes types as cheap as dynamic checking though, syntax-wise
19:29:28 <dons> there's no type checking at runtime
19:29:35 <davidL> Olathe: I have an entire file I want to import into lambdabot
19:33:05 <davidL> I suppose I would import it in L.hs
19:38:55 <jimstutt> davidL: I wanted to know that as well. Did dons tell me to go get ghci'd? PS dig: can't build my own lambdabot. The 6,8,1-newb problem again...or p'raps it's just me :)
19:39:22 <allbery_b> it hasn't been ported to 6.8.1 yet
19:39:22 <dons> lambdabot is one of those big scary projects not updated yet
19:39:32 <dons> i'm considering a rewrite for the coming year
19:39:43 <dons> it really should use some more modern libraries, more thorougly
19:39:44 <davidL> dons: would I import my own module in L.hs?
19:39:53 <scook0> dons: is there any inherent reason why \b is scary?
19:39:57 <dons> things like xml, bytestring, tagsoup, from the ground up
19:40:01 <scook0> or is it just an artifact of the evolved implementation?
19:40:02 <dons> scook0: its just big.
19:40:15 <dons> scook0: yeah, it evolved in a very ad hoc manner over 7 years
19:40:35 <dons> often doing new things, for which libraries have since appeared
19:40:42 <dons> e.g. today i wrote an rss plugin
19:40:52 <dons> that was trivial with new libraries like xml and tagsoup
19:40:56 <scook0> because (as I'm sure you're aware), a more tractable local lambdabot could be very useful :)
19:41:10 <dons> yep. i'm not sure lambdabot's fit for that though
19:41:17 <dons> currently.
19:41:31 <thoughtpolice> a new lb would be nice
19:41:52 <dons> it can be considered a rathe successful prototype, i guess
19:42:05 <dons> many architectural issues have been clarified too
19:43:02 <dons> i'd need a couple of weekends, with nothing else on, to do the rewrite, and port the existing top plugins
19:43:06 <dons> so its doable
19:43:16 <dons> and i'm getting more interested in doing it , too
19:45:20 <thoughtpolice> dons: would it mainly just be cutting the cruft?
19:46:01 <dons> let me just sketch a plan...
19:47:47 <dons> * bytestring network layer
19:47:47 <dons> * bytestring irc parser
19:47:47 <dons> * associated types for plugin local state and isolation
19:47:47 <dons> * same forkIO dispatch module as current
19:47:47 <dons> * xml, rss, html support from the outset
19:48:33 <allbery_b> irc a plugin, with a protocol router so that e.g. jabber can be added?
19:49:30 <sjanssen> dons: I don't think ATs will be ready for use soon enough
19:49:58 <dons> for the use i want, i think so.
19:50:02 <dons> just class-associated types
19:50:07 <dons> not the full families stuff
19:50:21 <dons> i.e. class Plugin a where type T = MyState
19:50:22 <jimstutt> dons: ta for all the down and dirty stuff help. Great Hinze paper. Take a bedtime (03:50 GMT) Cat joke?
19:50:37 <sjanssen> dons: those just desugar to type families
19:50:45 <dons> right, and the desugaring is fine
19:50:53 <dons> its the funny hard stuff that's not :)
19:50:54 <sjanssen> dons: just in casual hacking I've hit tons of snags with ATs
19:51:04 <dons> ok, cool.
19:51:27 <dons> allbery_b: yeah, it should be easier to hook filters in between the bot and its output
19:51:55 <sjanssen> actually, why do plugins need to AT/MPTCs at all?
19:52:14 <dons> so the plugins are lifted into an existential, holding its interface
19:52:20 <dons> and then we have per-plugin private state
19:52:34 <dons> which is easy to hide inside the type class interface with either FDs or ATs
19:52:52 <dons> and this usage is the most primitive use of ATs, which I'm pretty sure works
19:53:28 <sjanssen> so, the current module class is parametric in plugin name and plugin state
19:53:31 <sjanssen> just combine those
19:54:16 <dons> i'm not sure if that'd be better or worse -- its not a key issue (though, i'd like to avoid FDs)
19:57:50 <dons> http://programming.reddit.com/info/61zbt/comments/
19:58:27 <dons> i note the url title lookup fails for reddit now.
19:58:34 <dons> i wonder if they've increased the page size over the limit
20:00:24 <sjanssen> dons: another feature I'd like to see is fair IO scheduling
20:01:08 <sjanssen> if somebody runs a command with lots of output, freenode's rate limiting causes lambdabot to hang in all other channels
20:02:55 <dons> yes, that would be key too
20:03:25 <clanehin> what is it with overcompexifying monads?  foo >> bar means "do foo, then do bar afterwards", foo >>= bar means "do foo, whatever thingie foo returns, do bar with that thingie", return means "don't do nothin'"
20:03:25 <scook0> dons: heh, I remember suggesting the schroedinger/monad metaphor once
20:03:34 <scook0> I think we decided it was a bad idea :)
20:04:37 <davidL> dons: is there something you need to do for @let to work with lambdabot? I'm getting "Plugin `eval' failed with: Data.ByteString.last: empty ByteString"
20:04:46 <clanehin> on monad analogies, If you give someone a kitten and say, it'll grow into a cat.  What's a cat?  Don't show them a picture of a lion.
20:05:06 <dons> davidL: you need a particular version of the regex-* libs
20:05:16 <dons> since its a bug in regex-*. you'll need the latest ones
20:05:27 <davidL> from darcs?
20:05:46 <Pseudonym> There's a lambdacat in that.
20:05:52 <scook0> clanehin: the problem is that understanding the monad abstraction is more like understanding the concept of *all* cats
20:05:55 <Pseudonym> "Oh, just get the latest version from darcs."
20:06:00 <dons> clanehin: except that >>  is really "do foo, then something wacky and monadic, then do bar"
20:06:12 <dons> there's the programmable semicolon in there
20:06:27 <dons> so people can be cautious about oversimplifying
20:07:33 <chessguy> myprogrammable semicolon? what are you talking about?
20:07:55 <clanehin> it doesn't matter . . . let the newbies have their training wheels and stop taking pot shots at them.
20:07:55 <nornagon> do { a ; b }
20:07:58 <davidL> also, do I have to add the name of my module somewhere so it doesn't get erased from L.hs every time?
20:08:06 <SamB_XP> clanehin: a lion is a cat, though
20:08:09 <chessguy> err. s/my// i don't know how that got in there
20:08:11 <nornagon> is the same as a >> b
20:08:14 <SamB_XP> hmm. do we have any lions in lambdacats?
20:08:19 <chessguy> nornagon, i'm well aware of that
20:08:45 <chessguy> i don't know why dons is calling the semicolon 'programmable' though
20:08:47 <nornagon> right, and since you define >>= in your monad, you can define the behaviour of ;
20:09:05 <chessguy> erm
20:09:20 <nornagon> @src (>>)
20:09:20 <lambdabot> m >> k      = m >>= \_ -> k
20:09:21 <chessguy> well, it's not the semi-colon, it's what the semi-colon desugars to
20:09:28 <nornagon> same thing really :)
20:09:43 <clanehin> I just really feel like there's a habbit of throwing newbies into the shark-infested end of the pool.  It really isn't necessary.
20:09:53 <monochrom> Our >> is some other language's ;
20:09:56 <nornagon> there are no sharks! :(
20:09:59 <SamB_XP> ooh, nobody told me there was a shark-infested end!
20:10:04 <SamB_XP> I want to swim there!@
20:10:05 <dmwit> clanehin: See "the IO monad for people who just don't care" or whatever. =)
20:10:14 <chessguy> do they have frickin' lasers on there heads?
20:10:15 <nornagon> SamB_XP: you can join oleg!
20:10:18 <chessguy> uh, their
20:10:25 <chessguy> apparently i can't type tonight
20:10:56 <monochrom> Oleg is the shark.
20:11:06 <nornagon> the type shark.
20:14:10 <lament> i'm with clanehin
20:14:31 <clanehin> I would just like a "IO, State, Maybe, and List monads in language that a third year computer science undergraduate can understand without resorting to quantum mechanics of all things, srsly" tutorial
20:14:41 <lament> it seems abstarct stuff is better appretiated _after_ a whole bunch of concrete examples
20:14:54 <lament> appreciated
20:14:59 <monochrom> Piaget's theory says that it's the only way.
20:15:04 <monochrom> I believe him.
20:15:20 <nornagon> i find that the best way to think of IO is to think in terms of actions
20:15:27 <wli> I'm coming in late on this one. What's the only way?
20:15:32 <monochrom> I certainly learned numbers by first counting apples and coins, not looking at the Num class.
20:15:34 <SamB_XP> lament: that's true...
20:15:35 <nornagon> 'IO Int' is an action that, when run, produces an int
20:15:46 <gwern> wli: specifics -> generalities
20:16:08 <dmwit> clanehin: Meet the Monads and You Could Have Invented Monads both helped me get there as a third year CS undergrad.
20:16:09 <monochrom> The only way to learn anything is to learn concrete examples before abstract laws.
20:16:13 <lament> Mathematicians like to start off with the abstract definition right away
20:16:16 <Korollary> monochrom: How have you learned complex numbers then?
20:16:17 <SamB_XP> okay, so we tell them "don't try to understand what a monad is. when the time comes, you will. instead, try to understand specific monads."
20:16:17 <wli> Sure. The organic learning process is inductive.
20:16:34 <monochrom> I learned R^2 vectors first.
20:16:45 <gwern> 'once you understand a bunch of specific monads, the beautiful commonalities will slowly emerge into your understanding'
20:17:02 <monochrom> And how did I learn R^2 vectors? By playing on grid papers first.
20:17:12 <lament> right
20:17:15 <SamB_XP> monochrom: most people at least learned R^2 cartesian coordinates first...
20:17:22 <lament> it's all about getting the itnuition
20:17:42 <monochrom> Yeah, I mean that. R^2 something. But definitely played alot on grid papers.
20:17:57 <dmwit> That said, no amount of examples are going to make you "get it" if you don't put in a little effort.
20:17:58 <SamB_XP> anyway... complex numbers are abstract since when?
20:18:00 <lament> and the only way to get the intuition is by playing with specific stuff like grid papers
20:18:08 <Korollary> Since day 1, I believe.
20:18:22 <monochrom> Right, I think part of Piaget's theory is "nevertheless, some people will never get it".
20:18:23 <SamB_XP> I always though they were pretty concrete
20:18:31 <SamB_XP> then again, I learned them from a fractal book...
20:18:37 <Korollary> It depends on what your definition of concrete is.
20:18:49 <lament> SamB_XP: _algebra_ is pretty abstract
20:18:53 <wli> By the time it came time for me to consider vector calculus, I was dealing in various other abstractions that had me practiced enough that it was a non-issue. Unless you count complex as R^2 in which case I followed that course.
20:18:56 <lament> i mean high school algebra, not galois theory
20:18:57 <SamB_XP> lament: not really
20:19:06 <lament> SamB_XP: no, really, it is
20:19:10 <monochrom> concrete-abstract is relative to what you have learned, of course.
20:19:11 <SamB_XP> galois theory is a little bit abstract
20:19:29 <lament> SamB_XP: you have already developed intuition for high school algebra, so you think it's pretty concrete
20:19:37 <monochrom> 1yo's probably find integers abstract. 30yo's probably find fractions concrete.
20:19:41 <lament> but six-graders are having having troubles with it for a reason
20:19:47 <wli> SamB_XP: esp. over p-adic fields?
20:19:47 <SamB_XP> abstract algebra is pretty darn abstract
20:20:00 <monochrom> I think monads are pretty concrete.
20:20:09 <SamB_XP> monads are pretty darn abstract
20:20:11 <gwern> if I have an infinite loop - foo = s <- readIn; parse s; foo; - does the nesting use up much memory or anything?
20:20:15 <SamB_XP> a monad is concrete, though
20:20:15 <monochrom> And I think 2-categories are pretty abstract.
20:20:28 <gwern> SamB_XP: arrows are probably worse then
20:20:31 <monochrom> These are only statements of my education level!
20:20:51 <wli> I don't really think of things in terms of ranking in terms of abstraction.
20:20:52 <monochrom> concrete = I've learned, or I've had experience.
20:20:59 <SamB_XP> I don't even know what 2-categories are
20:21:14 <monochrom> Right! I don't know it either. Therefore it's abstract.
20:21:24 <dmwit> gwern: No, that should be fine due to laziness.
20:21:45 <wli> The ranking is certainly there, and it has a definite sort of relevance, but it never concerns me.
20:21:47 <SamB_XP> I'm probably the only one in my chemistry class who thinks that thinking of hess's law as saying that chemical reactions form linear systems makes it *easier* to remember...
20:21:51 <gwern> dmwit: well, I mean if a user types in, say, a couple thousand times
20:22:32 <hpaste>  gwern pasted "dead-simple interpreter" at http://hpaste.org/4238
20:22:37 <dmwit> Well, if you're keeping the results around, then of course you have to have enough memory for all the results.
20:22:44 <gwern> dmwit: I'm interested in eval there
20:23:26 <lament> SamB_XP: are you bragging?
20:23:47 <dmwit> gwern: It doesn't save anything, so garbage collection should take care of you nicely.
20:23:52 <SamB_XP> lament: you could put it that way
20:24:14 <lament> i don't think anybody is very impressed here in #haskell :)
20:24:33 <SamB_XP> well, I didn't say it was a very good description of what I was doing...
20:24:43 <gwern> dmwit: ok. I was worried a couple thousand entries in one mgiht discover that all the memory is being used by the closures/stack-frames/whatever-the-hell-gobbledegook-is-appropriate constituting the deep nesting of evals
20:25:06 <monochrom> I'm impressed. Because it's an instance of "yay, great minds think alike!"
20:25:09 <SamB_XP> I guess I was conceding that I'm a lot happier with some abstract things than many other people
20:25:42 <SamB_XP> I have yet to decide on what the variables are ;-)
20:26:07 <lament> SamB_XP: sadly, a typical CS undergrad's abilities are far below your mighty intellect
20:26:30 <monochrom> I think it's very nice that this Internet has brought us abstract thinkers together. You have to admit, we are rare, and if not for this Internet we would be alone in our localities.
20:26:30 <SamB_XP> yeah, too bad the same can be said of EEs
20:27:32 <lament> well, if you want the math faculty you probably know where to find it :)
20:27:43 <SamB_XP> of course, I'm probably the only one in my chemistry 1 class to have taken Differential Equations before chemistry 1...
20:28:12 <dmwit> monochrom: I'm sure there would never be a formal institution set up that tried to recruit the most interesting minds into one place.  I mean, what would they be good for?  Teaching other people?  Researching even more esoteric things?  pshaw
20:28:34 <SamB_XP> entertainment!
20:28:39 <SamB_XP> duh!
20:30:14 * wli suspects this is not the crowd to try to compete with in terms of such things.
20:30:28 <monochrom> dmwit: I think you're sarcastic there, but don't laugh, many universities are now facing external pressure to refrain from doing that. They are pressed to do more "relevant" things, and less "irrelevant" things. Of course guess who defines relevance.
20:30:29 <lament> dmwit: actually it might happen.. for the purpose of making fun of their alarmingly high percentage of virgins!
20:31:02 <dmwit> lament: heh
20:31:03 <SamB_XP> monochrom: well I bet it isn't me
20:31:37 <lament> (if you're a muslim mathematician, you get 3^2*2^3 virgins when you die)
20:31:38 <gwern> tenure is increasingly uncommon.
20:31:47 * gwern read it in the NY Times, so it must be true!
20:32:37 <monochrom> Another point is that, yes you're right, university is a good place for abstract thinkers. But what about your first 17 years? You're an abstract thinker but you're still stuck at primary school, secondary school, ... You are lonely there.
20:32:56 <dmwit> monochrom: right, that's true
20:33:03 <SamB_XP> home schooling
20:33:32 <dmwit> monochrom: Of course, people find a way not to be lonely.
20:33:47 <dmwit> MathCounts, AMC/AIME spring to mind for me, but I'm sure everybody had something similar.
20:33:57 <monochrom> Yet another point is, even in universities, the undergrad level contains fewer and fewer abstract thinkers now.
20:34:04 <wli> dmwit: Not really.
20:34:09 <lament> monochrom: does it?
20:34:11 <wli> dmwit: It's pretty bad out there.
20:34:13 <jeffz> hi, the link to Network.CGI docs on http://haskell.org/haskellwiki/Applications_and_libraries/Web_programming#CGI points to http://www.haskell.org/ghc/docs/latest/html/libraries/cgi/Network-CGI.html , which 404s, should I update it to http://www.haskell.org/ghc/docs/latest/html/libraries/cgi-3001.1.5.1/Network-CGI or will this break in the next ghc release if cgi changes version numbers?
20:34:20 <lambdabot> http://tinyurl.com/253xhy
20:34:51 <monochrom> Well, "fewer" should be "less" and should refer to proportion, not absolute numbers.
20:35:03 <lament> how would you know this?
20:35:26 <lament> unless you're a prof or for some other reason have been hanging around a university for decades
20:37:50 <monochrom> I can draw on other profs' observation that, for example, the proportion of first year students who can learn calculus has dropped.
20:40:24 <lament> that can happen for many reasons
20:40:52 <SamB_XP> such as?
20:40:58 <lament> and i wouldn't equate "abstract thinker" with "can learn calculus"
20:41:11 <lament> such as declining quality of high school education in north america
20:41:29 <SamB_XP> ... you don't think that could be reducing the number of abstract thinkers?
20:41:36 <dmwit> You're going for causes, but the effect seems the same to me.
20:41:40 <lament> such as a larger percentage of non-mathy people going to university (presumably, they won't go into math)
20:41:44 <lament> SamB_XP: no
20:41:46 <SamB_XP> you underestimate the power of the education system, I Think
20:41:59 <lament> SamB_XP: consider yourself and your prodigious intellect
20:42:01 <SamB_XP> lament: that means less mathy people
20:42:08 <lament> SamB_XP: was high school ever anything other than a hindrance?
20:42:15 <dmwit> *ksh huuuuh* You underestimate the *power* of the dark side. *kssh huuuh*
20:42:25 <glguy> couldn't be that college is  becoming accessible to more people?
20:42:32 <monochrom> It can happen for many reasons. But the result is still that these people are not acquiring a certain ability by the age of 18. It is also unlikely that anything could be done to let them acquire it after.
20:42:47 <SamB_XP> lament: regardless of the answer to that question, I believe it to be more of a hindrance now then ever before
20:42:48 <glguy> so the average ability of college students is getting closer to the average ability of the general population?
20:43:13 <SamB_XP> glguy: I hear people have begin to notice this sad trend
20:43:26 <lament> not sure why is it sad
20:43:28 <Brian`> that's why I want to quit university hehe
20:43:44 <dibblego> school has never been about education; it has always been about the instillment of submissionto authority
20:43:53 <scook0> glguy: doesn't that suggest that college ends up being a four-year extension of high-school?
20:43:53 <monochrom> Yes, university students were a self-selecting bunch in the past. Now they are a random sample.
20:44:01 <SamB_XP> dibblego: they used to do a bit of each, I hear
20:44:22 <glguy> scook0: I wouldn't be shocked if that was the case
20:44:34 <lament> monochrom: well, if you want to find a bunch of abstract thinkers, you shouldn't look at "university students". Look at, for example, third and fourth year math students.
20:44:50 <SamB_XP> hmm. if that is the case, what are we home-schoolers to do?
20:44:53 <dibblego> SamB_XP, only the minimum required to maintain the education masquerading, hence, having dropped recently; you're all discussing the cause of an underlying principle
20:45:01 <scook0> i.e. previously, an "abstract thinker" might trudge through school, and then be rewarded by being able to go to university
20:45:18 <scook0> now, they have to trudge through undergrad as well
20:45:32 <lament> scook0: now, an abstract thinker will be erwarded by being able to finish a math degree with honours.
20:45:37 <SamB_XP> scook0: TELL ME ABOUT IT. but at least I didn't have to trudge through school.
20:46:06 <SamB_XP> of course, I suppose this will probably be good for my grades in the long run...
20:46:16 <jimstutt> MO is anglo-american empiricism done for abstraction in the west. Babies seems to me to have no problem.
20:46:44 <SamB_XP> what did you say?
20:47:13 <SamB_XP> anyway, I do believe that the school system HARMS many children...
20:47:42 <markb> all children are harmed by schools
20:47:45 <SamB_XP> you know how they tend to start out with endless streams of questions?
20:47:59 <dibblego> SamB_XP, that's its intention
20:48:01 <davidL> an article from the ny times regarding school and such: http://query.nytimes.com/gst/fullpage.html?res=9E07EFD61F30F933A05750C0A9629C8B63&sec=&spon=&pagewanted=print
20:48:42 <lament> dibblego: ever heard of hanlon's razor?
20:48:45 <Shimei> The best evidence I've seen of stupid people in my class is how most questions during a class is "will this be on the exam?" when confronted with genuinely interesting (but hard!) problems or proofs the prof is using as examples.
20:48:58 <markb> SamB_XP: http://feeds.feedburner.com/~r/TEDTalks_video/~3/76547149/ted_robinson_k_2006.mp4
20:48:58 <lambdabot> http://tinyurl.com/yv7v69
20:48:58 <Shimei> Can we get away from the goddamn exam and think about learning CS for a second?
20:49:15 <dibblego> lament, no
20:49:20 <SamB_XP> hmm, I should go to bed to increase the probability that I can slog through tomorrow...
20:49:25 <davidL> "Once you reach adulthood, the key to success will not be demonstrating teacher-pleasing competence across fields; it will be finding a few things you love, and then committing yourself passionately to them."
20:49:29 <SamB_XP> probably...
20:49:30 <lament> dibblego: "never attribute to malice what can be adequately explained by stupidity"
20:49:35 <SamB_XP> but I want more tea...
20:50:00 <monochrom> tea is an anti-thesis to sleep. weigh your options carefully!
20:50:07 <dibblego> lament, I don't mean to imply that the intention is one of conscious malice
20:50:09 <SamB_XP> monochrom: PEPPERMINT tea
20:50:19 <monochrom> Ohh! Go ahead!
20:50:34 <lament> tisane :)
20:50:54 <monochrom> Speaking of which, I promised myself a cup of Milo!
20:51:09 <lament> tea is camellia sinensis, anything else is the work of the devil
20:51:19 <Shimei> Herbal tea doesn't deserve to be called tea. Dammit lament you beat me to it.
20:51:55 <lament> when i asked for tea in mexico, they thought i meant chamomile... strange country
20:52:41 <wli> lament: Benefit of the doubt.
20:52:43 <SamB_XP> lament: I thought it was the work of the british
20:53:04 <Brian`> can I ask you for an advice? I'm in software engineering in a university and I feel like the mathematics they teach in class is absolutely horrible... it's fast paced and thereby don't give me time to think over the proof or its concept and make me memorize stuff in the end due to lack of time to study thoroughly... When I was in high school, I always tried to prove some interesting concept myself and that's how I became decent at 
20:53:04 <Brian`> and really liked it... but ever since I entered university, I feel like I'm losing ability + interest in mathematics... should I just quit school and study myself or switch out to different program or something?
20:53:29 <lament> Brian`: take a bunch of math electives
20:53:41 <SamB_XP> Brian`: maybe try community college?
20:54:20 <Shimei> Community college doesn't teach much "math" usually.
20:54:22 <qmrw> or you could just study outside of class
20:54:31 <dons> we're going through another monad run, eh?
20:54:34 <dons>  http://programming.reddit.com/info/61zg5/comments/
20:54:38 <dons> `Overloading Semicolon, or, monads from 10,000 Feet'
20:54:44 <wifs> Brian`: you probably have poor professors, I would seek (free) tutoring and/or see the TA's during their office hours to review material regularly
20:54:45 <dons> as new people have a go at haskell?
20:55:22 <dons> `In his spare time he teaches category theory to fourth graders.'
20:55:24 <dons> :)
20:55:36 <Brian`> seriously, i feel like those engineering curriculum is designed to impress those accreditation board... just have lots of courses and lots of workload to show "look our engineering students are doing this much". but really, even if ppl pass those classes, they rarely know anything about what they have learned... because they jammed stuff in!
20:55:49 <lament> Brian`: that's why it's called "engineering"
20:55:50 <Shimei> Brian`: Switch to CS. ;)
20:56:02 <SamB_XP> Brian`: well, I WILL know that stuff...
20:56:10 <lament> you could have at least gone to CS, then you would have less workload and could have taken more math courses
20:56:18 <Shimei> Though CS is often a joke.
20:56:23 <lament> CS is a joke, yeah
20:56:34 <Brian`> hm... I kinda regret choosing Software Engineering over CS, too
20:56:35 <Shimei> I'm just taking it so I can do graduate studies in it.
20:56:43 <SamB_XP> oh.
20:56:48 <SamB_XP> I'm learning REAL engineering
20:57:02 <Brian`> like?
20:57:13 * Shimei is in the science faculty, so...
20:57:23 <wli> I took CS basically as a sideline to math in case I needed to go to industry.
20:57:47 <SamB_XP> at my school they make all the the engineering students take Electric Circuits and Statics...
20:57:55 * SamB_XP is majoring in EE
20:58:04 <Brian`> same here too...
20:58:06 <lament> dons: looks confusing :)
20:58:24 <SamB_XP> Brian`: what school do you go to?
20:58:24 <dons> it does, i must admit
20:58:30 <Brian`> University of Waterloo
20:58:34 <SamB_XP> and they make software engineers take that?
20:58:36 <wli> As it turns out I had no chance of getting into a grad school above the level of non-accredited correspondence study and basically had to "drop out" by dropping all my minors to graduate so burnout didn't take my GPA below 3.0.
20:58:40 <Brian`> what about you Sam?
20:58:41 <Brian`> yeah
20:58:58 <SamB_XP> I'm going to Widener University
20:59:50 <lament> wli: couldn't you just graduate and then take one of those tests instead? GRE?
20:59:57 <wli> It probably didn't help that my finances were in such poor shape as to affect cognition via malnutrition.
21:00:34 <wli> lament: I did. My GRE scores were not in a high enough percentile to be meaningful beyond not being a red flag to deny me.
21:00:58 <monochrom> Monads are the work of the devil. Or the Italian.
21:01:48 <dmwit> Pretty much the same thing, really.
21:01:53 <monochrom> hehehe
21:01:53 <Shimei> Brian`: Oh hey, another Canadian uni guy. I'm at UBC. :)
21:02:00 <dmwit> I know, I saw it on GodTube.
21:02:24 <monochrom> I'm at U of Toronto.
21:02:48 <Brian`> Shimei, nice :)
21:02:49 <lament> Shimei: heh, did i know at some point that you're at ubc?
21:03:16 <Brian`> monochrom, what year are you in?
21:03:21 <Shimei> lament: Maybe from a nethack channel.
21:03:30 <lament> Shimei: your'e not in any of my courses, are you?
21:03:31 <monochrom> grad school, should be finishing my thesis.
21:03:43 <Shimei> lament: You're at UBC too?
21:03:51 <lament> yes, 4th year math undegrad
21:03:53 <Brian`> monochrom, nice~ that's cool. What program are you in ?
21:03:55 <lament> undergrad
21:04:29 <Shimei> lament: Whoa. Neato. Probably not in your courses though. Taking CS121 + 211, physics and chem (first-year).
21:04:31 <lament> well, not anymore as Friday was last day of classes, and except for the finals, i'm all done :)
21:04:35 <lament> ah
21:04:48 <monochrom> cs, I'm with formal methods people, a subgroup of software engineering people. A few of us know Haskell. One of us uses Haskell to write a theorem prover, takes advantage of type classes.
21:05:08 <Shimei> lament: How was math at UBC? I'm thinking of doing math + CS or physics + CS.
21:05:10 <lament> Shimei: enjoying 211? :)
21:05:31 <Shimei> 211 is well taught, but way too slow paced for me.
21:05:42 <lament> Shimei: i highly recommend you take math 320/321/420 with Feldman
21:05:50 <lament> if you're not particularly afraid about your average
21:05:50 <Brian`> monochrom, that's interesting :) man I wish there is Haskell User Group meeting in Toronto hehe
21:06:04 <Shimei> lament: Real analysis eh? Isn't that the weedout class?
21:06:07 <lament> it is
21:06:36 <monochrom> His idea is pretty cool. I think all of us should hear it. You know how "propositional logic" is defined by certain operators and certain inference rules, then "predicate logic" is by certain other operators and certain other inference rules, then "modal logic" is by yet other operators and yet other rules...
21:06:58 <SamB_XP> is he overloading operators?
21:07:04 <Shimei> monochrom: Like algebraic theory but for logic?
21:07:21 <monochrom> So, he use one type class for one set of operators and rules. There is a "propositional" type class. There is a "predicate logic" type class. There is a "modal" type class...
21:07:28 <lament> Shimei: also, anstee and adler are great profs
21:07:51 <lament> but don't take linear programming, even anstee can't make it fun
21:08:02 <Shimei> lament: I'm taking hon. linear algebra from Gupta and diff. eq. from Nagata. They any good?
21:08:08 <SamB_XP> what IS linear programming?
21:08:14 <lament> aww, i had anstee for hon. linear algebra
21:08:29 <Brian`> monochrom, is he planning to present his work to others sometime?
21:08:36 <lament> gupta's much less exciting
21:08:50 <lament> also, in CS, get wolfman
21:08:57 <monochrom> Now you can do two cool things. 1. inherit from several logics to obtain a combined logic, e.g., "modal logic with forall and exists" = inherits both "predicate" and "modal". 2. Write proof-search algorithms that work for, say, all instances of "propositional".
21:08:58 <lament> any course with wolfman is gonna kick ass
21:09:23 <Shimei> lament: Yeah, I've talked to him before. Seems pretty cool. I've had classes with Carter and Belleville.
21:09:31 <monochrom> Look for "prufrock". It is the beginning of his line of work.
21:10:26 <lament> don't like belleville
21:10:58 <lament> monochrom: let us go then, you and i?
21:11:13 <monochrom> go where?!
21:11:31 <dmwit> I think that's who the Alfred Prufrock poem goes.
21:11:47 <SamB_XP> http://www.ittc.ku.edu/Projects/SLDG/projects/project-prufrock.htm
21:11:48 <lambdabot> Title: Prufrock, http://tinyurl.com/285cag
21:11:49 <monochrom> Oh well, I know no English literature.
21:11:57 <dmwit> Sorry, I mean J Alfred Prufrock of course.
21:12:28 <lament> Surely that prufrock project is named after the poem?
21:12:39 <monochrom> Surely. But I know nothing.
21:12:56 <lament> read it, it's one of the better poems in the english language :)
21:13:18 <dmwit> Bah, l(a is far superior.
21:13:31 <monochrom> If you talk about poems by Li Po, ... I know a few of them. If you talk about non-Chinese poets and their work, sorry I learned nothing.
21:13:37 <dmwit> If only because a mere mortal like me can get his mind around it. =)
21:14:08 <SamB_XP> dmwit: I think you may have a hard time convincing me to read something with unbalanced parens in the name
21:14:17 <monochrom> Also, I don't get the more abstract poems. I don't get or like allegories.
21:14:31 <dmwit> SamB_XP: The right-paren comes near the end of the poem.
21:14:41 <dmwit> SamB_XP: If I balanced the parens in the title, you'd have the whole poem. =)
21:15:06 <SamB_XP> dmwit: but... that would put it in a DIFFERENT FONT!
21:15:29 <dmwit> The poem is actually untitled.
21:15:41 <SamB_XP> oh
21:15:55 <SamB_XP> how do you pronounce l
21:16:03 <dmwit> You don't.
21:16:13 <dmwit> If I said any more, it would be a spoiler.
21:17:18 <dmwit> http://www.poemhunter.com/poem/1-a-a-leaf-falls-on-loneliness/
21:17:19 <lambdabot> Title: 1(a... (a leaf falls on loneliness) by e.e. cummings
21:17:40 <dmwit> I couldn't find any site that had it without a spoiler. =/
21:17:44 <dmwit> So: spoiler alert.
21:30:57 <jdrake> If I wanted to parse command line arguments that are essentially going to be in the format of -hvg blah   where h, v and g are each individual parameters and blah is a directory name (relative or absolute) - what is the best way of parsing this?
21:32:18 <allbery_b> System.Console.Getopt ?
21:32:53 <allbery_b> whoops.
21:32:58 <allbery_b> System.Console.GetOpt
21:33:38 <jdrake> hmm, I look
21:34:48 <allbery_b> you could write your own option parser (for one unusual program I actually used Parsec) but in the general case it's nice to use existing stuff
21:36:25 <jdrake> OH, this looks pretty good. It is using a lot of features that I do not quite understand, but it looks usable.
21:37:01 <jdrake> In the example it has a data definition that derives Show. What exactly does that do?
21:37:02 <thoughtpolice> jdrake: it's simpler than you would think, check the example at the bottom of the getopt module
21:37:33 <thoughtpolice> jdrake: it automatically writes some code for you, so you can write 'show a' where show may be any value of that data type
21:37:52 <thoughtpolice> in other words, it automatically creates a version of show from YourDataType -> String
21:38:26 <jdrake> thoughtpolice: OTher than a print operation, is there anything that gives you?
21:38:43 <allbery_b> no, that's it
21:38:57 <allbery_b> but Show instances are therefore quite useful for debugging
21:39:34 <dmwit> jdrake: You can get the inverse operation by deriving Read.
21:39:45 <allbery_b> hm, ghood point
21:39:49 * allbery_b is tired
21:40:04 <allbery_b> Show + Read means you can serialize data (i.e. save to file and reread later)
21:40:06 <jdrake> Either way, it looks like it would double the size of the program :p
21:40:24 <allbery_b> if you don't need that then you can omit it
21:41:18 <jdrake> ok, now one thing I am missing here - I can see how to do -c style options, but what about options that are just there, like my directory name?
21:42:02 <jdrake> hmm, in the first example I notice a [] list item that might be it.
21:42:58 <thoughtpolice> jdrake: you mean options that can be in the form of '-c dir' or just '-c' where the directory is implied?
21:43:07 <thoughtpolice> or both?
21:43:24 <jdrake> The most basic:   myprog .   to list the current directory.
21:43:42 <allbery_b> "getOpt returns a triple consisting of the option arguments, a list of non-options, and a list of error messages"
21:44:00 <allbery_b> the second element of the tuple will have your directory
21:44:01 <qmrw> stupid camelcase. lowercase everything!
21:44:03 <jdrake> The most complicated it gets right now:  myprog -h .   to list the current directory, with sizes in human friendly output.
21:44:28 <jdrake> ah, I think I see what you mean.
21:44:40 <monochrom> Stupid lowerCase. CamelCase EveryThing!
21:45:20 <ddarius> thisIsCamelCase
21:45:32 <jdrake> Would it be wise to make a module for this?
21:46:09 <davidL> is camelCase used as much in FP?
21:46:31 <ddarius> davidL: It's de facto standard for Haskell for whatever that's worth.
21:46:34 <scook0> it's widely used in Haskell circles
21:46:39 <davidL> I see
21:47:00 <allbery_b> it's all much easier in languages that don't have case :)
21:47:19 <allbery_b> (of course that means you can't write types...)
21:48:41 <jdrake> If you look somewhere you can find hFileSize which my friend denounced as *hungarian notation* :P
21:49:35 <allbery_b> one could argue the Haskell Way would be a typeclass, actually :)
21:49:44 <scook0> one thing that bugs me about camelCase
21:49:56 <allbery_b> (such that fileSize's first argument could be either a String or a Handle)
21:50:01 <scook0> is that if you have identifier and prefixedIdentifier
21:50:08 <scook0> then the capitalization is inconsistent :/
21:50:39 <davidL> I like hyphens between identifiers, lisp style, end-of-file :)
21:50:45 <allbery_b> never mind that, take a look at any of the System.Win32 modules for real inconsistency :)
21:51:05 <atp> hey guys.
21:51:17 <atp> man, lots of stuff about haskell on reddit these days
21:51:23 <allbery_b> all those uppercase win32 constants which become cONSTANTs
21:53:18 <jdrake> atp, When microsoft hosts stuff on monads and develops F#, you know something funny is up.
21:53:33 <dmwit> allbery_b: Really?  They don't have some standard like winCONSTANT?
21:53:35 <dmwit> =/
21:54:16 <atp> what surprises me frankly is how many people on reddit are confused about what monads are and yet still feel qualified to write lengthy posts on the subject
21:54:32 <dons> anyone have a theory about why Map is spine-strict,
21:54:33 <dons> data Map k a  = Tip  | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
21:54:43 <dons> IntMap too, btw
21:54:43 <ddarius> dmwit: But that would be Hungarian notation ! ! !
21:55:05 <allbery_b> atp: I often see people writing long articles about things they know nothing about.
21:55:14 <atp> dons: the bangs mean the fields should be strictly evaluated?
21:55:20 <dons> atp, it does, yes.
21:55:34 <atp> dons: hm.  i've seen that around recently, is it an extension or is it part of haskell98?
21:55:39 <dons> its h98
21:55:46 <dons> but only in constructors
21:55:51 <atp> ah, i see
21:55:54 <dons> not on function arguments, i.e. f !x
21:56:16 <atp> but i can do f $! x for that... oh, i guess that's not the same thing, is it
21:56:31 <dons> you can use `seq`
21:56:34 <atp> right
21:56:38 <dons> f !x = y
21:56:44 <dons> f x = x `seq` y
21:56:55 <atp> f !x = y needs -fbang-patterns doesn't it?
21:56:57 <dons> ddarius: any thoughts on Map ?
21:57:00 <dons> yep
21:57:01 <atp> ok
21:57:04 <atp> thanks dons
21:57:05 <Plareplane> do there really need to be 3 articles on monad on proggit at the same time?
21:57:29 <monochrom> People rant all the time. On monads, on health care, on economic fairness, on celebrities. Do not try to understand why. Just take it as an axiom.
21:57:54 <atp> i just don't understand what people find so bewildering about monads
21:58:14 <dons> Plareplane: Sunday is Monaday
21:58:21 <dons> didn't yow know? :)
21:58:28 <allbery_b> @yow
21:58:29 <lambdabot> Here we are in America ... when do we collect unemployment?
21:58:32 <atp> haha
21:58:32 <dons> the day when no one is reading proggit at work, so haskell stuff bubbles up a bit
21:58:46 <monochrom> Part of the explanation is: they don't understand it, but they see here we have a sizable group that does, the disparity is unsettling.
21:59:18 <ddarius> dons: It might be spine strict for a reason, but then it might be just as a "hey, why not?"
21:59:27 <atp> i can see they don't understand it, i guess the question is, why don't they understand it?  i think it must be a self-fulfilling prophecy.  they're told it's hard, and psychologically can't get over that, or something
21:59:43 <dons> ddarius: ok, that worries me -- since I suspect its a pessimisation
22:00:08 <ddarius> dons: Does the documentation state where the algorithm came from?
22:00:10 <atp> dons: is this the map in Data.Map ?
22:00:10 <monochrom> If subject X is understood by no one, or is understood by everything, there is no surprise. The most interesting case is when it's 50/50, or even 99/1.
22:00:19 <monochrom> s/everything/everyone/
22:00:31 <dmwit> Is pessimal really an antonym to optimal?
22:00:48 <dons> works for me.
22:00:50 <ddarius> dmwit: In modern computer science usage, yes.
22:01:05 <dons> atp, yup
22:01:05 <monochrom> I actually think a significant mindset adjustment is needed before understanding abstractions.
22:01:54 <dons> ddarius: i worry about the lack of stress testing in base and containers, in particular
22:02:10 <dons> probably half of bytestrings dev time was to do with fixing results after stress testing
22:02:25 <ddarius> monochrom: Shouldn't programmers, at least, already have most of the mindset adjustment?
22:02:32 <dons> basically pushing the upper limit of how big and fast you can make things
22:02:42 <dons> I wonder if Map got  the treatment
22:02:46 <monochrom> I think they have always got by without.
22:02:50 <atp> dons: do you think the spine-strictness of Map is unnecessary?
22:03:08 <ddarius> dons: It certainly wouldn't hurt, but there are many uses of some of these libraries at least and I'm sure some of them are "stressful".
22:03:09 <dons> atp, I think it makes it worse, since you have to allocate the whole tree, even if you only traverse a part of it
22:03:29 <atp> that's a good point.
22:03:46 <dons> its suspicious when haskell data types don't use laziness
22:03:57 <dons> since that's where a lot of the big performance gains for data lie
22:04:03 <atp> there are some people who seem to be afraid of laziness
22:04:09 <atp> or at least suspicious of it
22:04:12 <monochrom> Take for example "queue". It's supposed to be an abstract utility. You're supposed to (eventually) just reason about your use of queues by algebraic axioms. Does anyone actually do it? Everyone seems to use a list-based model rather than algebraic axioms in their heads.
22:04:30 <dons> i raise this, as I'd assumed it would of course by spine-lazy
22:04:37 <atp> monochrom: personally, i think of 2-3 finger trees, hehe
22:05:07 <ddarius> dons: Well a lot of Okasaki's work on purely functional data structures is about getting the right balance between laziness and strictness.
22:05:08 <monochrom> So now, suddenly you face monads, with either too many models or no model at all, depending on which tutorial you read.
22:05:19 <dons> ddarius: exactly
22:05:22 <dons> its that careful balance
22:06:29 <monochrom> Everyone uses queues but few actually have even see its algebraic axioms. Now suddenly someone shows you monad laws.
22:07:23 <atp> dons: perhaps you should remove the strictness annotations and do some heap profiling and see if there's an unreasonable amount of accumulated laziness
22:07:30 <dons> i raise it here, http://article.gmane.org/gmane.comp.lang.haskell.cafe/32705
22:07:32 <lambdabot> Title: Gmane -- Mail To News And Back Again
22:07:56 <dons> atp, right, i intend to have a look at that if the authors don't remember why its strict
22:08:54 <monochrom> Here is an additional challenge. Queue has many models, but they look quite alike. Monad has many models, but they look quite different, they also support different extra operations.
22:09:11 <atp> it does seem weird that it would be globally spine strict though... in most of okasaki's papers he suggests more careful, localized applications of strictness (or laziness, if he's using ML)
22:09:42 <lament> well, queues are really simple and monads are actually pretty hard
22:09:46 <atp> but i don't really understand this stuff yet
22:09:47 <glguy> dons: "teh suckness"?
22:10:05 <dons> glguy: of course
22:10:34 <atp> lament: monads aren't the least bit difficult, and persistent queues that have reasonable access from both the left and right are actually not particularly trivial
22:10:58 <atp> lament: i really think that people are afraid of the word monad
22:11:04 <dons> glguy: we should try some benchmarks on spine-lazy Map with unboxed strict fields (and element-strict lists!)
22:11:06 <atp> lament: it sounds to mathematical
22:11:19 <sjanssen> spine strictness on Data.Map makes complete sense, IMO
22:11:21 <atp> lambdabot: too rather
22:11:27 <atp> sjanssen: why's that
22:11:28 <dons> sjanssen: due to the insertion pattern?
22:11:29 <lament> atp: sounds theological to me
22:11:39 <dons> i guess usually we don't traverse and discard
22:11:41 <sjanssen> it's a size balanced tree, you've got to evaluate the spine of a subtree to know the size
22:12:48 <dons> ah, now that's interesting. so there might be scope for a spine lazy tree that doesn't need to do the subtree work
22:13:02 <dons> insert kx x t
22:13:02 <dons>   = case t of
22:13:02 <dons>       Tip -> singleton kx x
22:13:02 <dons>       Bin sz ky y l r
22:13:02 <dons>           -> case compare kx ky of
22:13:05 <dons>                LT -> balance ky y (insert kx x l) r
22:13:07 <dons>                GT -> balance ky y l (insert kx x r)
22:13:10 <dons>                EQ -> Bin sz kx x l r
22:13:11 <sjanssen> I'm not sure how you can do that with a balanced tree
22:13:40 <dons> no, that's right, you may not be able to.
22:14:23 <nanothief> atp: I am finding monads very difficult to understand. I think the problem is that resources on the net are either too technical, try to teach monads and IO at the same time, or never really explain how they work
22:14:31 <dons> balanced t
22:14:31 <dons>   = case t of
22:14:31 <dons>       Tip              -> True
22:14:35 <dons>       Bin sz kx x l r  -> (size l + size r <= 1 || ...
22:14:52 <atp> nanothief: what don't you understand
22:14:57 <ddarius> nanothief: Define "resources on the net"?
22:15:06 <dons> i wish i could choose how i want my generic structure to be strict or lazy
22:15:21 <dons> since different applications have different tunings
22:15:44 <nanothief> ddarius: well the two i am looking atm are the wikibooks one and the haskell.org/tutorial/monads page
22:15:45 <monochrom> "really explain how they work" = model, for those who're interested in my theory above.
22:16:16 <nanothief> I was taught them a while ago with a uni resource, but they just explained how to do IO, not how to use monads generally
22:16:45 <nanothief> but probably, after a while it will 'click', and i will never understand how i didn't 'get' them before
22:17:17 <atp> nanothief: you probably think that there's more to a monad than there really is
22:17:38 <bos> how do i post an article to the LTU home page?
22:17:52 <monochrom> bribe an LTU editor
22:18:21 <monochrom> I'm kidding! Contact an LTU editor. Editors are the only ones who can do that.
22:18:30 <ddarius> nanothief: As I tell everybody, read Wadler.
22:19:09 <ddarius> bos: You can post a forum topic but not a story.
22:19:17 <bos> ddarius: ah, ok
22:20:24 <nanothief> atp: probably, there's really only three function to understand so it can't be too difficult...
22:20:33 <jdrake> LTU?
22:20:44 <Korollary> latvian thermal unit
22:21:10 <glguy> lambda the ultimate ;)
22:21:12 <Korollary> lambda-the-ultimate.org
22:21:18 <jdrake> oh the great one!
22:21:32 <ddarius> bos: That said, to become a contributing editor all you need to do is email Ehud or Anton (though usually you want to have been around for a while)
22:22:03 <bos> ddarius: yeah
22:22:11 <jdrake> Have you guys read the great work: Miranda Dyno mite!?
22:22:20 <atp> nanothief: it helps to understand what problem it solves.  if you have two functions f :: a -> m b and g :: b -> m c, how do you compose them?
22:22:23 <bos> here's what i was aiming at: http://lambda-the-ultimate.org/node/2553
22:22:23 * ddarius should become a contributing editor.
22:22:24 <lambdabot> Title: Parsimony Principles for Software Components and Metalanguages | Lambda the Ulti ...
22:22:40 <jdrake> http://lambda-the-ultimate.org/node/1562#comment-18623  :-) My favourite.
22:22:41 <lambdabot> Title: HLVM - High Level Virtual Machine toolkit for dynamic languages | Lambda the Ult ...
22:23:28 * jdrake sleeps
22:23:55 <bos> todd veldhuizen has interesting interests.
22:24:00 <atp> nanothief: the answer in general is, it depends on what the m is, right?  i mean, if it's Maybe you'd do it one way, if it's List you'd do it some other way, etc...
22:24:20 <atp> nanothief: the Monad class just defines an abstraction so that you can do it the same way for any m that's in the class
22:24:33 <atp> nanothief: that's all there is to it
22:24:57 * bos pokes oege de moor again about algebra of programming
22:25:04 <virgil> (beginner question warning) how do I write the type of a function in a class involving a possibly different instance of the class?
22:25:06 <nanothief> apt: so it is a bit like the (.) operator, but wraps around types?
22:25:16 <virgil> I can't get a type constraint to work anywhere
22:25:45 <Toxaris_> virgil: class X x where foo :: (X y) => x -> y
22:25:57 <atp> nanothief: yes
22:26:09 <atp> nanothief: so like, Maybe is a monad... you know Maybe, right?
22:26:12 <ddarius> :t fromIntegral
22:26:13 <lambdabot> forall a b. (Num b, Integral a) => a -> b
22:26:24 <atp> nanothief: data Maybe a = Nothing | Just a
22:27:41 <nanothief> apt: I know Maybe
22:28:09 <atp> nanothief: so as an instance of the monad class, it defines two functions, return and (>>=)
22:28:32 <atp> nanothief: return just turns something of type a into type Maybe a in the obvious way: return x = Just x
22:29:11 <atp> nanothief: and >>= is defined this way: if you have some function f :: a -> Maybe b, then Nothing >>= f = Nothing, and Just x >>= f x
22:29:30 <nanothief> apt: so Just 4 >>= (*2) would return Just 8?
22:29:31 <atp> nanothief: so that lets you compose a bunch of functions that return maybe values, without checking for Nothing each time
22:29:43 <atp> nanothief: no, because the type of (*2) isn't a -> Maybe b
22:30:18 <atp> nanothief: but for example, if you have say f x y = if x == 0 then Nothing else y / x
22:30:26 <atp> err Just $ y / x
22:30:29 <ddarius> better
22:31:04 <atp> then you could say something like return 4 >>= f 5 and you'd get Just (4 / 5)
22:31:18 <atp> but if you had f 0, you'd get Nothing
22:31:24 <atp> and if you started out with Nothing, you'd get Nothing
22:31:41 <atp> so essentially, any function in the pipe can return nothing, and if it does, the whole expression evaluates to nothing
22:31:45 <atp> so it's like throwing an exception
22:32:02 <nanothief> apt: thats making a lot more sense now
22:32:21 <atp> but see, the Monad part is just the abstraction... other monads work completely differently, they each define return and >>= in their own way
22:32:26 <dons> > do Just 1; Just 2; Just 3
22:32:29 <lambdabot>  Just 3
22:32:33 <dons> > do Just 1; Nothing; Just 3
22:32:33 <lambdabot>  Nothing
22:33:02 <nanothief> > Just 1 >> Just 2 >> Just 3
22:33:03 <lambdabot>  Just 3
22:33:18 <dons> > sequence [Just 1, Just 3, Just 3]
22:33:18 <lambdabot>  Just [1,3,3]
22:33:23 <dons> > sequence [Just 1, Nothing, Just 3]
22:33:24 <lambdabot>  Nothing
22:33:39 <dons> computations that can fail
22:33:58 <nanothief> > Just 1 >> Just 2 >>= (\(Just x) -> Just (x * 2))
22:33:58 <lambdabot>   add an instance declaration for (Num (Maybe t))
22:34:10 <atp> nanothief: remember the type!
22:34:15 <atp> nanothief: a -> Maybe b
22:34:19 <atp> nanothief: not Maybe a -> Maybe  b
22:34:27 <nanothief> woops!
22:34:36 <nanothief> > Just 1 >> Just 2 >>= (\x -> Just (x * 2))
22:34:36 <lambdabot>  Just 4
22:34:38 <dons> the >>= is doing the unwrapping
22:34:39 <dons> yeah
22:34:40 <nanothief> nice
22:34:46 <atp> :)
22:34:54 <dons> ?src (>>=) Maybe
22:34:54 <lambdabot> Source not found. There are some things that I just don't know.
22:35:00 <dons> ?src Maybe (>>=)
22:35:00 <lambdabot> (Just x) >>= k      = k x
22:35:00 <lambdabot> Nothing  >>= _      = Nothing
22:35:26 <dons> the scala for this is quite horrible, i note (but at least they can write it!)
22:35:39 <atp> you can extend this ... if you wanted to throw more than just one kind of exception, you could make Either into a monad, and have it work the same way
22:36:04 <nanothief> their a lot like unix pipes, with >>= being a | and >> being &&
22:36:13 <atp> yep
22:36:27 <atp> and Monads define fail, too, which in the case of Maybe is predictably Nothing
22:36:49 <virgil> toxaris: thanks ... when I try that I get "couldn't match expected type y (a rigid variable) against inferred type <whatever>
22:37:00 <dons> nanothief: yeah, in fact oleg wrote a small article on how shell pipes form a true monad
22:37:09 <dons> with cat and >
22:38:00 <Thomas2> cute
22:38:00 <dons> http://okmij.org/ftp/Computation/monadic-shell.html
22:38:01 <lambdabot> Title: UNIX pipes as IO monads
22:38:05 <Toxaris> virgil: it compiles fine for me
22:38:20 <Toxaris> virgil: is the error about the class definition or about some instance definition?
22:38:21 <atp> nanothief: instead of trying to understand what monads are in general, first just try to understand how different types are monads... like Maybe and List
22:38:39 <atp> nanothief: and writer, that's a good and fairly easy one to develop
22:38:54 <virgil> instance X X1 where foo (X1 x) = X2 x
22:38:56 <atp> nanothief: state isn't much harder, if you understand currying
22:39:13 <virgil> toxaris: is where it breaks
22:39:17 <Toxaris> virgil: well, that definition is not correct :)
22:39:48 <nanothief> apt: what do you mean by writer?
22:39:53 <dons> dfranke has written a small library that produces an Arrow for unix pipes
22:39:57 <dons> (with `tee`
22:40:18 <Toxaris> virgil: foo :: X y => x -> y   means that foo will produce whatever y the caller wants, as long as it is a member of X. but in your code, foo decides wich y to produce, and the caller has to accept it
22:40:19 <atp> nanothief: like, you know how if you're writing a C program or something and you're debugging it, it's pretty useful to stick print statements in various places to figure out what's going on?
22:40:36 <atp> nanothief: and how at first blush it seems like you can't do that in haskell?
22:40:47 <nanothief> apt: yeah its the biggest thing i have been missing in haskell
22:40:54 <evilsporkman> hi, I'm trying to write an IO action to read a list of lines, terminated by ".", and I can't quite get the IO monad business to work out
22:41:14 <atp> nanothief: so you think, well, since i can't print the string, maybe i'll return it
22:41:36 <atp> nanothief: so then instead of having f :: a -> b, I'd have f :: a -> (b, String)
22:41:49 <dons> evilsporkman: how about readFile and lines?
22:41:58 <atp> nanothief: like mysin x = (sin x, "Sin was called\n")
22:41:58 <hpaste>  EvilSporkMan pasted "simple IO action, doesn't build" at http://hpaste.org/4239
22:42:02 <virgil> toxaris: thanks. I think the second is what I want -- can that be expressed as a type?
22:42:15 <dons> main = do s <- readFile "x" ; let ls = lines s; print (head ls)
22:42:17 <virgil> toxaris: I don't want the caller to have to specify the types right?
22:42:23 <atp> nanothief: but again, composition rears its ugly head!  if you have two functions like that, how do you compose them?
22:42:42 <Toxaris> virgil: I don't know what you want :)
22:42:54 <evilsporkman> er, sorry, i'm reading from stdin until ".", but that should be massagable to use this newfangled "lines" thing. let me look it up
22:43:33 <atp> nanothief: well, you can make a datatype: data Debug a = Debug (a, String)
22:43:56 <atp> nanothief: and then you can make it into a monad in the following way: return x = Debug (x, "")
22:44:38 <atp> nanothief: (Debug (x, str1)) >>= f = let (fx, str2) = f x in (fx, str1 ++ str2)
22:44:48 <atp> err Debug (fx, str1 ++ str2)
22:44:52 <hpaste>  dons annotated "simple IO action, doesn't build" with "recurse" at http://hpaste.org/4239#a1
22:44:57 <dons> evilsporkman: ^
22:45:02 <nanothief> apt: ahh i see now
22:45:16 <atp> nanothief: then you can just have a bunch of functions that return debug strings and string them together with >>=
22:45:26 <atp> nanothief: and all the strings you return from each function will be concatenated together
22:45:26 <Toxaris> virgil: you can use an existential type to allow the function to return whatever y it likes, as long as it's in class X. that means that the caller can only use X methods to do something with the returned value (since the caller can't know what type it is)
22:45:57 <virgil> toxaris: that's what I want :) I'll look up existential types
22:45:58 <evilsporkman> dons: thanks, i swear I tried that permutation.
22:46:15 <atp> nanothief: basically, monads just abstract away the problem of doing composition on complicated types
22:46:32 <dons> evilsporkman: do you see why you have to do it this way?
22:46:34 <dons> :t (:)
22:46:53 <ddarius> atp: Composition's head is ugly?
22:47:11 <atp> ddarius: i don't know, i brown bag her with a monad
22:47:13 <nanothief> apt: well it is a lot simpler than i was making it out to be
22:47:47 <monochrom> Its head is ugly at first. Messy hair. Monad styles its hair, so now it looks cool. :)
22:48:24 <dons> ?bot
22:48:53 <dons> fixing this url lockup is one thing too. url module failed in contextual handler: thread killed
22:48:55 <glguy> hmm, someone should tell dons that lambdabot is down
22:49:02 <atp> nanothief: the key is realizing that a monad is not "one thing" anymore than instances of class Num are all the same.  Int, Float... they're different, but it would be annoying if we had to use a different symbol to multiply them
22:49:07 <monochrom> hahahaha
22:49:09 <dons> since it sucks.
22:49:20 <evilsporkman> dons: yeah, return goes into the monad, so we always have to use it for the result. the "ls <- doGetFileText" for the recursive call gets back out of the monad, otherwise we'd have inconsistent types in the generated list (nesting of IO monad)
22:49:22 <dons> its always to do with urls timing out
22:49:28 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
22:49:33 <dons> but in a forkIO thread. maybe the error handler is wrong. hmm
22:49:43 <dons> evilsporkman: right
22:50:12 <ddarius> @users
22:50:13 <lambdabot> Maximum users seen in #haskell: 401, currently: 386 (96.3%), active: 3 (0.8%)
22:51:03 <dons> the bug was introduced a few months ago, but is becoming more of a problem
22:51:32 <evilsporkman> i'm doing YAHT; if those one-liners are idiomatic, why are we going through all this tail-recursive business instead of telling me about lots and lots of useful higher-order functions?
22:51:39 <evilsporkman> s/tail-recursive/recursive/
22:52:39 <dons> @quit experiment
22:52:48 <dons> > 1+2
22:53:02 <lambdabot>  3
22:53:17 <atp> did you write lambdabot, dons?
22:53:46 <dons> a fair bit of it.
22:54:01 <dons> along with 1/5th of the people in here :)
22:54:21 <dons> she's got some arthritis though
22:54:22 <monochrom> It is thought that beginners need and want lots of examples and exercises in recursion before moving on.
22:55:14 <monochrom> Clearly, some beginners will never move on, and some beginners don't need too many elementary exercises.
22:55:16 <atp> speaking of recursion, why are so many functions in prelude defined specifically for list when any Foldable will do
22:55:29 <dons> list came first, by about 20 years
22:55:32 <glguy> because the Prelude predates Foldable
22:55:42 <atp> it's annoying :(
22:55:49 <monochrom> Foldable is invented in the Information Age. Prelude is invented in the Agricultural Age.
22:56:02 <glguy> evilsporkman: because as nice as it would be for *all* problems to fit nicely into existing function, you'll end up writing your own too
22:56:31 <quicksil1er> evilsporkman: if you didn't know how to write functions recursively, you'll be stuck when the higher order library functions don't match your particular need.
22:56:50 <atp> it's also annoying how the Enum class's instances are all Int instead of Integer, meaning that if i'm using some other instance i need to do fromInteger . toInteger bs
22:56:51 <evilsporkman> good points, everyone, i should be ashamed. ;)
22:57:02 <dons> atp, oh?
22:57:12 <quicksil1er> atp: fromIntegral == fromInteger . toInteger
22:57:13 <nanothief> atp: now  getChar :: IO Char, and the other IO functions makes perfect sense, as well as half of my IO programs I've written using guesswork :P
22:57:14 <dons> fromIntegral
22:57:18 <atp> quicksil1er: oh yeah?
22:57:22 <atp> hey, what do you know
22:57:27 <quicksil1er> @src fromIntegral
22:57:27 <lambdabot> fromIntegral = fromInteger . toInteger
22:57:38 <dons> at least you found the right glue :)
22:57:46 <atp> yeah, thanks guys!
22:57:58 <dons> if there are missing Foldable instances, that should get reported to Ross, I think
22:58:07 <nanothief> apt: thanks for all the help, you've explained in about 30 minutes what i have spent hours banging my head agains :)
22:58:18 <dons> or do you wish for all the listy functions defined in terms of foldr, specially, to be lifted to Foldable
22:58:26 <atp> that would be nice
22:58:29 <dons> i wonder if there are useful ones not defined in Folable
22:58:33 <dons> do you have an example?
22:58:39 <atp> no, i don't, i'm just griping.
22:58:48 <atp> if i come up with one i'll let you know though.
22:58:49 <dons> there's some other legacy of long term development
22:58:52 <dons> fmap/map/liftM
22:59:01 <dons> (.) too, as some would have it
22:59:12 <atp> ah?
22:59:14 <atp> how do you mean
22:59:31 <dons> they're synonyms at different types (a bit like Foldable / fold-specialised-to-lists)
22:59:41 <dons> > map (+1) [1..10]
22:59:43 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:59:44 <dons> > fmap (+1) [1..10]
22:59:44 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:59:44 <atp> yeah that one i know
22:59:47 <atp> but (.)?
23:00:01 <dons> there's a category faction that wants (.) = fmap
23:00:02 <atp> (i could see replacing pretty much everything with Functor types)
23:00:05 <dons> or something :)
23:00:06 <atp> ah
23:00:09 <atp> hm
23:00:23 <atp> > :t fmap
23:00:23 <lambdabot>   parse error on input `:'
23:00:25 <atp> :t fmap
23:00:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:00:27 <monochrom> @src fmap (->)
23:00:27 <lambdabot> Source not found. It can only be attributed to human error.
23:00:32 <dons> check Control.Category
23:00:33 <monochrom> or something
23:00:37 <quicksil1er> a categorical conspiracy, perhaps?
23:00:43 <atp> :t (.)
23:00:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:00:56 <atp> that doesn't seem to be the right kind of function
23:01:11 <atp> hm
23:01:14 <atp> i'll take a look
23:01:17 <dons> instance Functor ((->) r) where fmap = (.)
23:01:20 <monochrom> Let f = (a ->)
23:01:30 <atp> oh, i see
23:01:36 <atp> that's kind of neat :)
23:01:37 <monochrom> (b -> c) -> f b -> f b
23:01:50 * atp nods at monochrom.
23:01:51 <monochrom> err typo, but nevermind
23:01:54 <atp> functors are everywhere
23:02:19 <quicksil1er> the surprising thing is that this (.) turns out to be associative
23:02:25 <quicksil1er> even when applied at different types
23:03:00 <Taejo> @instances Monad
23:03:08 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:04:13 <atp> is there some s -> Either (err, s) (a, s) monad i'm not aware of?  that one is particularly useful but i've been defining it myself
23:04:55 <dons> StateT s (Error err) a -- ?
23:05:07 <dons> or ErrorT err (StateT s) a
23:05:12 <ddarius> I don't want fmap = (.)
23:05:14 <quicksil1er> @unmtl StateT s (Error err) a
23:05:14 <lambdabot> err: Unknown MTL(1)
23:05:28 <ddarius> And I think Control.Category is misnamed.
23:05:37 <quicksil1er> dons: neither of those give you the option of a different state, in the error case, directly
23:05:38 <dons> ?unmtl State String a
23:05:39 <lambdabot> String -> (a, String)
23:05:40 <atp> dons: neither of those interleaves the state with the error very well... you want the state to be propagated even if an error is throw
23:05:43 <atp> thrown
23:06:03 <quicksil1er> atp: you can, however, model it with ErrorT err (State s)
23:06:04 <sjanssen> @unmtl StateT s (Either e) a
23:06:05 <lambdabot> err: Unknown MTL(1)
23:06:16 <quicksil1er> atp: you just nee a more complex 'throw' primitive which also sets the state
23:06:24 <dons> ?unmtl ErrorT err (StateT s) a
23:06:24 <lambdabot> err: Unknown MTL(1)
23:06:33 <atp> quicksil1er: yeah, seems kludgy :)
23:06:35 <dons> ?unmtl Error err a
23:06:35 <lambdabot> err: Unknown MTL(1)
23:06:38 <dons> ah
23:06:39 <quicksil1er> atp: doesn't to me.
23:06:48 <atp> dons: Either
23:06:48 <quicksil1er> atp: seems like what you want.
23:07:03 <atp> quicksil1er: except you need a more complex throw primitive :(
23:07:04 <dons> ?unmtl Error a
23:07:04 <lambdabot> Either String a
23:07:14 <quicksil1er> atp: well, write it! It takes 10 seconds...
23:07:18 <dons> ?unmtl ErrorT (StateT s) a
23:07:18 <lambdabot> err: Unknown MTL(1)
23:07:23 <dons> ah well
23:07:23 <quicksil1er> throwWithState s e = put s >> throw e
23:07:23 <atp> quicksil1er: in that time i can just write the whole monad :)
23:07:39 <EvilTerran> ?unmtl ErrorT e (State s) a
23:07:39 <lambdabot> s -> (Either e a, s)
23:08:05 <quicksil1er> s -> Either (err,s) (a,s) is ismorphic to a -> (Either err a , s)
23:08:12 <atp> yeah, that's a good point
23:08:19 <atp> they are isomorphic aren't they
23:10:34 <Taejo> Is the state of the art in monad tutorials improving? Are the "overloaded semicolon" and "schroedingers cat" analogies better than the nuclear waste one?
23:11:05 <atp> there's altogether too much fuss about this imho
23:11:42 <Taejo> Personally, I didn't get the nuclear waste thing at all, but I didn't read anything else... I just started using them
23:12:08 <atp> they're fairly intuitive i think if no one scares you by claiming they're hard
23:12:18 <EvilTerran> i just did whatever 'til it made sense
23:12:38 <Taejo> once you actually *know* some Haskell -- know what typeclasses are, have done some IO -- they will soon come pretty naturally
23:12:45 <ddarius> Taejo: The state of the art hasn't improved in a decade.
23:12:57 <atp> i still don't do much IO
23:13:03 <EvilTerran> when you start actually *seeing* how the category theory has any bearing on programming...
23:13:15 <EvilTerran> ...*then* you know you've got it :D
23:13:37 <ddarius> A lot of category theory doesn't obviously have bearing on actual coding.
23:13:56 <Taejo> atp, I really meant "used some monad"... I really started grokking monads when I used parsec for the first time
23:14:02 <monochrom> This is a secret plan to avoid success.
23:14:21 <EvilTerran> well, not all of category theory, of course. i meant thinking about haskelly monads in terms of categorical monads or whatever.
23:14:39 <atp> haskelly monads are all defined on the category of haskell types...
23:15:30 <atp> i did quite a lot of category theory in the context of algebraic topology back in uni and i'm not sure it helped me much
23:15:36 <EvilTerran> yeah, yeah. it's all well-and-good knowing the definitions if it's just sa a load more rules you have to prove if you want to make a monad yourself
23:16:08 <ddarius> atp: The relevant category theory is more algebra and logic rather than topology.
23:16:41 <atp> ddarius: hm, must be.
23:16:51 <EvilTerran> i've had moments when the flash of insight and clarity that'll make everything monad-related clear seems almost within my grasp...
23:17:24 <ddarius> EvilTerran: Define "everything monad related".
23:17:29 <EvilTerran> ... but i imagine, if i wanted that, it'd help if i actually had a decent grasp of category theory. i'm pretty much learning as i go along, tbh...
23:17:34 <atp> proving the monad laws for things you know are monads is a very good exercise
23:18:25 <ddarius> atp: Yes... but I'm not sure it's a good exercise in learning how to use or create monads in actual practice.  It's good for other things though.
23:18:53 <Shimei> Speaking of category theory/algebra, did anyone else read that Utrecht paper about Algebraic Theory using FP and get a shock out of how they taught first-years about abstract algebra?
23:19:03 <atp> ddarius: i think it helps you develop an intuitive feel for what could be a monad and what couldn't
23:19:04 <ddarius> Shimei: link?
23:19:06 <Shimei> I also noticed they did category theory in semester 7 or so.
23:19:24 <Shimei> http://people.cs.uu.nl/jeroen/article/algebra/index.html
23:19:24 <lambdabot> Title: Explaining algebraic theory with functional programs
23:19:51 <Shimei> The bit about teaching is near the end.
23:20:05 <ddarius> atp: Maybe, I think if you understand the idea behind monads as applied to programming it should already be intuitively clear what sorts of things are and are not monads.
23:21:04 <xpika> its a shame you can't write a function > set c f v = c { f = v }
23:21:13 <atp> ddarius: maybe... i like proving things so perhaps i'm biased in this regard :)
23:21:41 <dons> xpika: yeah
23:21:47 <dons> no first class labels
23:22:02 <ddarius> Shimei: You may like Burstall's "Computational Category Theory"
23:22:17 <monochrom> Any understanding must eventually be founded on laws.
23:22:38 <EvilTerran> the laws, though, must eventually be founded on understanding
23:23:09 <EvilTerran> you can't build set theories on logics on substitution systems on set theories and not rely on intuition eventually
23:23:30 <atp> i just don't understand why someone who understands why class Num is useful can't understand why class Monad is useful
23:23:32 <Shimei> ddarius: All of this interesting math/CS hybrid stuff seems to come out of the UK or N. Europe. N. America feels behind.
23:23:54 <dons> atp, heh.
23:23:56 <Toxaris> atp: constructor classes are one step more abstract in my opinion
23:24:06 <dons> people have monomorphic ; burnt into their brains though
23:24:08 <Taejo> atp, well you can't understand why it's useful until you've *seen* why it's useful
23:24:29 <dons> its in deeper than the Float/Double/Int/Word overloading
23:24:45 <Taejo> If all you've seen is the word "monad" on reddit, you ain't gonna understand
23:24:48 <monochrom> Glad you bring up the set example. It is a great example of how intuition goes way wrong.
23:24:49 <Toxaris> atp: and the *problem* of having numerous numeric types is well-known to most programmers, while the problem of having various kinds of monadic action domains is not
23:25:02 <atp> maybe
23:25:12 <monochrom> Every user-friend course on sets begins with "a set is a collection of members". That's the intuition.
23:25:22 <ddarius> Shimei: North Americans (well at least US Americans) tend to be of the more applied/practical bent.
23:25:23 <atp> so by that analogy, they should have similar problems with class Functor and class Monoid then?
23:25:25 <atp> do they?
23:25:29 <monochrom> Great. Now don't you see everyone has a slightly different idea of what "collection" ought to be.
23:25:49 * EvilTerran listens to monochrom, enthralled
23:25:59 <monochrom> Some people's idea would be, {0, 0} ought to be different from {0}, as far as "collection" goes.
23:26:22 <ddarius> Monoid has a scary name too.
23:26:27 <monochrom> Some other people, me included, regarded {0, {1}} = {0, 1} as far as "collection" goes.
23:26:35 <atp> ddarius: it's a pretty familiar structure from algebra though
23:27:00 <ddarius> atp: What programmers know algebra?  (And actually, it's a -really- familiar structure from programming)
23:27:02 <Shimei> I found it amusing how Monoids sound scarier than, say, Groups or Rings.
23:27:16 <monochrom> I actually assumed {0, {1}} = {0, 1} for weeks. I needed someone to tell me no no no, that's not what we mean by "collection".
23:27:31 <atp> ddarius: isn't algebra required for a CS major?
23:27:35 <monochrom> So much for lawless education.
23:27:46 <Shimei> atp: Not in N. America...
23:27:47 <EvilTerran> Shimei, and what about "magmas"? they sound TERRIFYING! :D
23:28:04 <atp> Shimei: i went to uni in north america, but i was a math major...
23:28:12 <monochrom> Intuition? Feh. Everyone has different intuitions.
23:28:14 <ddarius> atp: For many colleges, I doubt it.  I doubt most programmers out there today have ever taken an abstract algebra class.
23:28:41 <Shimei> atp: Most CS students don't get past linear algebra and basic calculus.
23:28:47 <Taejo> EvilTerran, I was taught that magmas are so called because they *are* terrifying, in that you can prove almost nothing about them
23:29:00 <EvilTerran> monochrom, all very true, but, in the end, you've gotta leave *something* up to intuition
23:29:22 <EvilTerran> because there's only so far you can define stuff rigorously in terms of other stuff
23:29:26 <ddarius> Taejo: That's because they are almost nothing so that shouldn't be scary.
23:29:30 <EvilTerran> eventually it's just... word.s
23:29:45 <ddarius> That said, the -free- magma is extremely popular in the CS world.
23:29:58 <atp> as is free manga, haha
23:29:59 <Taejo> ddarius, I know... they just seem useless to me, not scary
23:30:01 <EvilTerran> Taejo, i figured it was more that they were very fluid
23:30:11 <atp> Taejo: not useless at all
23:30:13 <EvilTerran> but okay
23:30:22 <ddarius> Taejo: What?!  Free magmas are the most beloved structure of computer scientists.
23:30:24 * Toxaris just learned that his teacher is ill and he has another two hours to spend wondering what exactly "magmas" are
23:30:41 <monochrom> Eventually it is just symbols. Therefore, let the symbols do the work. Also, therefore, I do not believe in semantics other than semantics defined by more syntax.
23:30:43 <Taejo> atp, ddarius, I have only done "introductory algebra"
23:30:50 <ddarius> Toxaris: A magma is a set with a binary operation.
23:31:00 <Shimei> EvilTerran: I don't know, I'm reading a neat Calculus book that goes straight from "here are some axioms" to "let's prove everything else". None of this silly intuition stuff. ;)
23:31:12 <Shimei> ("Calculus" by Spivak. I haven't had time to get very far yet though)
23:31:15 <Taejo> and a sort of introduction to advanced algebra mini-seminar
23:31:16 <EvilTerran> "here"? what is "here"?!
23:31:22 <EvilTerran> define "axiom"!
23:31:23 <atp> Taejo: i have a book called introductory algebra that's about 50 pages long and is one of the densest books i've ever had to study in my life
23:31:30 <ddarius> Taejo: A free magma is just a (non-empty) binary tree.
23:31:30 <EvilTerran> (okok, i'm being difficult)
23:31:34 <atp> Shimei: baby rudin ftw
23:32:35 <ddarius> Taejo: For completeness, I should say the free monoid is just a list.
23:32:41 <EvilTerran> "are"? "some"? you dare come at me with something that isn't an incomprehensible symbol representing some egyptian god that took someone several hours to pick out in latex?
23:32:43 <monochrom> Semantics eventually traces down to the syntax that is the neuron activities and rules in your brain.
23:32:57 <EvilTerran> there, i found four problems with your first sentence alone. :P
23:33:21 <Toxaris> so data FreeMagma = FreeMagma FreeMagma FreeMagma? any base case?
23:33:56 <ddarius> Toxaris: No it's an operation -on- a set so data FreeMagma a = Leaf a | Branch (FreeMagma a) (FreeMagma a)
23:34:15 <ddarius> (or rather it's the "free magma generated from some set")
23:34:28 <Zao> "The name magma was introduced by Bourbaki to denote a set with a law of composition."
23:34:33 <Taejo> and a * b = Branch a b, right?
23:34:59 <ddarius> Zao: Because "Bourbaki" was (several) crack-heads.
23:35:03 <ddarius> Taejo: Yes.
23:36:18 * ddarius has no idea where most of the names in abstract algebra came from.
23:36:32 <atp> they get coined by mathematicians
23:36:38 <dmwit> Without knowing anything about magmas, it seems like it ought to be Branch a a, if the binary operation takes two elements of the set.
23:36:45 <dmwit> Why isn't it?
23:36:58 <Shimei> Magmas are also called groupoids? Groupoid is definitely a cooler name.
23:37:24 <Taejo> when I first heard the word ring, I thought it was a cyclic group (rings are cyclic, obviously :)
23:37:26 <atp> dmead: because each element of a free magma can be thought of as either a basic element or a product of two elements, possibly distinct
23:37:29 <ddarius> atp: Most of the names in mathematics make sense in one way or another, but the ones in abstract algebra seem to have no etymology.
23:37:30 <atp> dmwit: sorry
23:37:35 <atp> dmwit: that was for you
23:37:56 <dmwit> Aha, the binary operation is on the magma, not the set?
23:38:00 <ddarius> dmwit: The binary operation should be closed meaning it must have type AxA -> A
23:38:02 <dmwit> ok
23:38:18 <monochrom> The first ring examples happened to be cyclic groups, since they were Z_n.
23:38:21 <atp> dmwit: a magma is just a set S with a binary operation * : S x S -> S
23:38:31 <Taejo> monochrom, interesting
23:38:49 * ddarius suspects Z came first.
23:38:50 * dmwit dives into the rabbit hole
23:38:51 <atp> dmwit: so Set and Magma are linked by the forgetful functor, or something
23:38:58 <Toxaris> hmm, so haskell-speaking, we have class Magma a where op :: a -> a -> a
23:39:01 <dmwit> atp: Give me one second to digest.
23:39:03 <monochrom> Hilbert or someone was looking at Z_n and said, gee, what should I call them? Annulus! That's great.
23:39:29 <ddarius> atp: There is an adjoint situation F -| U where F is FreeMagma and U takes FreeMagma a -> a
23:39:39 <ddarius> Er sorry, U is Id on objects.
23:39:44 <ddarius> (Silly me)
23:39:50 <dmwit> atp: Okay, got it.  Cool!
23:39:50 <atp> indeed
23:39:53 * atp laughs.
23:39:54 <dmwit> (thanks)
23:39:59 <Toxaris> and data FreeMagma as given by ddarius and instance Magma (FreeMagma a) where op = FreeMagma
23:40:11 <ddarius> Toxaris: Yes.
23:40:27 <ddarius> The unit of the adjunction would be Leaf
23:40:49 <dmwit> So, for example, lists are magmas under (++).
23:40:52 <dmwit> ?
23:41:25 <ddarius> dmwit: Yes as are all monoids and groups (lists are the free monoid)
23:41:33 <atp> dmwit: sure.  they're more than magmas actually, they're free monoids, because ++ is associative and there is an identity element ""
23:41:47 <dmwit> right
23:42:20 <dmwit> Saying you have a magma doesn't say much. =P
23:42:35 <ddarius> dmwit: Nope.  All it says is that you have a closed binary operation.
23:42:44 <ddarius> It's pretty hard -not- to have such a thing.
23:42:47 <atp> dmwit: but ddarius' observation that binary trees are free magmas is interesting, and worth thinking about :)
23:46:36 <atp> but you know, ddarius...
23:47:13 <atp> oh, never mind
23:47:30 <atp> i got it :)
23:49:21 <Toxaris> a tuple of a set and some operations wich fulfill some laws is called... an algebra? an algebraic structure?
23:49:45 <atp> depends on the laws
23:49:59 <ddarius> It's one of the overloaded meanings of the term "algebra"
23:50:10 <ddarius> They don't have to satisfy any laws.
23:50:17 <ddarius> (Though they can)
23:50:39 <atp> generally there's the implicit closure associated with all binary operations though...
23:51:02 <ddarius> Toxaris: A nice way of encoding that notion is called an F-algebra (for some functor F) (and is yet another overloading of "algebra" but very similar to that one)
23:52:07 <ddarius> atp: When there isn't (as much) the result is usually called a multi-sorted algebra.
23:52:33 <atp> ddarius: ah, nice
23:52:52 <dmwit> ddarius: If I want to learn these things, and need to communicate to another professional what it is I want to learn, what do I say?  "I want to learn about ...."
23:53:09 <dmwit> Does category theory cover all of this stuff?
23:53:10 <ddarius> dmwit: universal algebra is one term
23:53:33 <ddarius> dmwit: Category theory has an excellent handling of universal algebra (and coalgebra and several other related things)
23:53:55 <Toxaris> dmwit: as i understand it, category theory is another level on top of this stuff, wich unifies even more concepts
23:54:35 * dmwit adds a few lines to his todo file
23:55:30 <Toxaris> now, "being a magma" is a possible property of such algebras, "begin a monoid" another, strictly more specific, and so on
23:55:57 <ddarius> dmwit: I'd recommend skimming a universal algebra text and then moving on to a categorical approach if that is what you ultimately aim at.
23:56:18 <dmwit> I just want to know things.
23:56:23 <dmwit> I don't really have a specific aim for now.
23:56:39 <ddarius> dmwit: Most of it should be actually very familiar as much of it has very direct encodings into programming.
23:57:37 <Toxaris> but in Haskell, we have class Monoid as a set of types, not a set of (type, operation)-pairs
23:57:40 <ddarius> E.g. The "term algebra" (initial F-algebra) is just an AST essentially (maybe with some laws) and a signature can also be readily encoded with an algebraic data type.
23:58:01 <dfranke> crap.  The kernel upgrade didn't solve the lockup problem in PipeArrow.
23:58:25 <ddarius> Toxaris: Monoid is a concept, there are specific monoids (just like there are specific instances of Monoid) and those (the instances) are exactly type,operation pairs.
23:58:54 <ddarius> Toxaris: However, the problem with the Monoid type class is that a type may be a monoid in more than one way but it can only be an instance of Monoid once.
23:59:28 <atp> that's what newtype is for
23:59:56 <ddarius> That's one way around it, but is not ideal.
