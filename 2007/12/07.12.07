00:00:59 <tga> now, lifting is just wrapping a type into something larger, like a list?
00:01:31 <oerjan> not that kind
00:01:58 <oerjan> although it's true for lift and liftIO, which is something different again
00:02:05 <oerjan> :t liftM
00:02:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:02:38 <oerjan> ok i guess fmap/liftM etc. lifts a _function_ into something larger
00:02:45 <tga> I need to find myself a nice intro to monads, I can't quite parse it
00:03:32 <tga> the way I have it figured atm, when lifting a to [a] you also have to lift f:a->a to f->[a]->[a]
00:03:54 <tga> to get a working category
00:04:04 <oerjan> you mean fmap f :: [a] -> [a]
00:04:08 <tga> yeah
00:04:11 <OceanSpray> :t >>=
00:04:13 <lambdabot> parse error on input `>>='
00:04:14 <oerjan> :t fmap
00:04:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:04:19 <OceanSpray> :t (>>=)
00:04:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:06:39 <oerjan> recently i have heard people here, after someone complains about all the confusing monad tutorials, tell them to look at Phil Wadler's original papers
00:06:58 * tga makes a note of the name
00:07:48 <tga> I'm surprised people get anything _done_ in Haskell
00:07:51 <OceanSpray> :t (>>= \a -> b)
00:07:57 <tga> there seems to be a lot of meta discussion about it
00:08:03 <lambdabot> Not in scope: `b'
00:08:07 <OceanSpray> argh.
00:08:13 <OceanSpray> :t (>>= \a -> a)
00:09:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
00:09:08 <oerjan> i never meta *hit by falling piano*
00:09:08 <bos> @pl \f a -> a f
00:09:08 <lambdabot> flip id
00:09:08 <bos> meh, flip id has some line noise alternative that i've forgotten
00:09:08 <OceanSpray> :t (>>= (\a -> a))
00:09:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
00:09:08 <OceanSpray> hrm
00:09:34 <TSC> @unpl (flip id)
00:09:35 <lambdabot> (\ b c -> c b)
00:09:51 <oerjan> @pl flip id x
00:09:51 <lambdabot> ($ x)
00:09:59 <TSC> @unpl (flip ($)
00:10:00 <lambdabot> Unbalanced parentheses
00:10:02 <TSC> @unpl (flip ($))
00:10:03 <lambdabot> (\ b c -> c b)
00:10:44 <oerjan> @pl (>>= id)
00:10:45 <lambdabot> join
00:11:38 <OceanSpray> oh fuck it
00:11:44 <OceanSpray> this is way too confusing
00:11:59 <OceanSpray> I'll just let the compiler tell me whether it's correct.
00:12:25 <oerjan> OceanSpray: in case it wasn't clear from what i say, you _shouldn't_ use (>>= ...) to make a continuation.
00:12:33 <atp> does something like the bytestring library exist for Word16 types?
00:12:34 <oerjan> *said
00:12:55 <OceanSpray> why not?
00:13:09 <oerjan> because that forces the argument to be m b
00:13:27 <oerjan> the continuation should take a pure value argument, essentially
00:13:37 <OceanSpray> and who says that?
00:13:41 <sjanssen> @where storablevector
00:13:42 <lambdabot> I know nothing about storablevector.
00:13:52 <oerjan> um...
00:13:59 <sjanssen> @where+ storablevector http://code.haskell.org/~sjanssen/storablevector
00:13:59 <lambdabot> Done.
00:14:05 <OceanSpray> Not trying to be difficult here.
00:14:10 <OceanSpray> Just asking what the harm is.
00:14:16 <sjanssen> atp: try http://code.haskell.org/~sjanssen/storablevector
00:14:17 <lambdabot> Title: Index of /~sjanssen/storablevector
00:14:28 <OceanSpray> what's so wrong about taking a monad as an argument?
00:14:35 <atp> sjanssen: thanks, i'll check it out
00:14:44 <OceanSpray> a... vector?
00:14:59 <atp> argh
00:15:07 <atp> goddamn mime types
00:15:19 <atp> haskell.org serves haskell code as text/x-haskell-code
00:15:27 <oerjan> well, it doesn't correspond to what ContT does
00:15:36 <atp> or something that's not text/plain and so firefox wants to download it instead of just displaying it
00:15:47 <atp> drives me nuts
00:16:04 <OceanSpray> :t ((>>+) \a -> b)
00:16:05 <oerjan> @src ContT
00:16:05 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
00:16:06 <lambdabot> parse error on input `\'
00:16:14 <OceanSpray> :t ((>>=) \a -> b)
00:16:15 <lambdabot> parse error on input `\'
00:16:22 <OceanSpray> :t ((>>=) (\a -> b))
00:16:23 <lambdabot> Not in scope: `b'
00:16:25 <OceanSpray> :t ((>>=) (\a -> a))
00:16:26 <lambdabot> forall a b. (a -> a -> b) -> a -> b
00:18:00 <OceanSpray> OH
00:18:05 <OceanSpray> yeah, got it now
00:19:15 <atp> sjanssen: so basically i'd create a vector of Word16 to correspond to a packed string of unsigned short?
00:19:34 <sjanssen> atp:
00:19:36 <sjanssen> atp: sure
00:19:46 <sjanssen> atp: or you can use CUShort from Foreign.C
00:20:16 <sjanssen> atp: you should probably use CUShort if you're interfacing with C
00:20:32 <atp> sjanssen: well, i will be doing some limited interfacing with a unicode library, probably
00:20:45 <atp> sjanssen: but most stuff will be done haskell side...
00:21:00 <atp> sjanssen: i haven't actually committed to anything yet, i'm just exploring my options
00:21:02 <sjanssen> Word16 is probably fine
00:21:12 <atp> sjanssen: i want to have utf16 strings...
00:23:09 <OceanSpray> oerjan, what does ContT do?
00:23:21 <OceanSpray> does it have anything to do with runErrorT?
00:23:36 <OceanSpray> because right now, that and IO are the only monads I'm using.
00:31:21 <atp> OceanSpray: ContT is just the monad transformer for the continuation monad, isn't it?
00:31:41 <OceanSpray> seems so
00:31:55 <OceanSpray> but I'm not using the Cont monad, so that's moot.
00:32:19 <atp> sjanssen: hey, is there any reason why Data.StorableVector isn't a standard lib? it seems pretty useful (unlike some of the other libraries that are a standard part of ghc)
00:33:18 <sjanssen> atp: I don't think it's quite as complete as ByteString
00:33:19 <atp> OceanSpray: ContT is a monad for continuations... it lets you write code transparently in continuation passing style, which allows you to write programs that have functionality similar to scheme's call/cc
00:33:57 <sjanssen> atp: and the current trend is towards a smaller standard library
00:34:17 <OceanSpray> oh hey, it's sjanssen
00:34:21 <atp> sjanssen: is there a particular reason that ByteString was written to be specific to 8-bit types?  one would think a more modular definition would be preferrable...
00:34:29 <OceanSpray> waddup
00:34:42 <sjanssen> atp: because that was the goal at the time
00:35:26 <sjanssen> atp: ByteString is also intended to be as fast as possible -- polymorphism can hurt that sometimes
00:35:41 <atp> sjanssen: ah, i see.  i was about to ask that.
00:35:44 <sjanssen> OceanSpray: yes, it is I, sjanssen!
00:36:05 <atp> sjanssen: btw, i just upgraded to xmonad 0.4, it's very nice, thank you
00:36:20 <tga> is bottom actually used in Haskell or is it just theoretical?
00:36:36 <atp> tga: you can't use it in your code if that's what you mean
00:36:40 <tga> right
00:36:41 <sjanssen> atp: just in time for 0.5 in a couple days :)
00:37:07 <atp> sjanssen: well, i had previously been running a xmonad-0.2 (which i built myself) but now debian has a package for it so i'll just track that (since i'm lazy)
00:37:39 <atp> tga: but bottom is important, because technically speaking, divergence is a side-effect that needs to be implicitly encapsulated
00:37:40 <ZsoL> sjanssen, really? new cool features?
00:38:26 <sjanssen> ZsoL: the new configuration system is the big thing
00:38:31 <tga> atp: I'm not sure I follow
00:38:47 <atp> tga: well, suppose you have a function f :: Int -> Int
00:38:47 <sjanssen> you keep you config in ~/.xmonad now, rather than compiling it in to the executable
00:39:08 <atp> tga: if f is a computation that never terminates, it doesn't actually return an int, right?
00:39:26 <tga> atp: guess it shouldn't return at all
00:39:36 <ZsoL> that's nice, no more "rm ~/.xmonad/xmonad && ghc --make" ?
00:39:37 <ZsoL> :-)
00:39:41 <sjanssen> tga: the _|_ symbol isn't used, but there are concrete and implicit representations used for it
00:40:12 <atp> tga: but haskell is strictly typed, so essentially bottom represents the possibility that any expression never halts (someone correct me if i'm wrong, i'm not a computer scientist)
00:40:21 <tga> I think I see what you mean
00:40:28 <atp> tga: this is important because haskell has lazy semantics,
00:40:43 <atp> tga: so if a function f isn't strict in its argument, f _|_ might not equal _|_
00:40:56 <glguy> strictly typed?
00:41:01 <OceanSpray> :t (>>=)
00:41:03 <tga> coming from the procedural world, what's wrong with f :: a -> a simply not returning?
00:41:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:41:03 <atp> oops, not
00:41:07 <atp> strongly typed i meant
00:41:09 <atp> sorry :(
00:41:34 <atp> tga: well, haskell is functional, functions always have a domain and a codomain
00:41:47 <glguy> tga: an   a->a that doesn't return does nothing at all but get warm
00:42:17 <atp> tga: i mean, what does a function do if it doesn't return something?
00:42:24 <tga> loop forever
00:42:36 <tga> the function may be defined on Int -> Int, but it never reaches a result
00:42:40 <atp> tga: exactly.  that's what bottom means.
00:42:49 <atp> tga: so when we say Int we really mean Int (or bottom)
00:43:16 <tga> when do I care about bottom being there?
00:43:18 <atp> tga: technically, that's true for all types.  and that's the difference between data Foo a = Foo a and newtype Foo a = Foo a, too, iirc
00:43:18 <mwc> tga, something like: f x = f $! x + 1 diverges
00:43:36 <tga> of course
00:43:40 <atp> tga: the former can be _|_, Foo a, or Foo _|_
00:43:48 <atp> tga: the latter can only be Foo a or Foo _|_
00:44:27 <atp> tga: so the former is not strictly an isomorphism of types because _|_ doesn't have a preimage in a
00:44:30 <mwc> glguy, it's evil to say a function that doesn't return gets warm
00:44:45 <mwc> glguy, afterall, that means its doing work, increasing entropy
00:44:51 <mwc> and entropy is a state variable! :)
00:44:59 <ZsoL> duh
00:45:00 <atp> mwc: how true :)
00:45:03 <tga> alright, thanks, I'll go read up some more good stuff
00:45:04 <glguy> not in Haskell98 :)
00:45:18 <atp> tga: but practically speaking, you don't care about bottom :)
00:45:37 <atp> tga: you can know nothing whatever about it and still write good haskell code
00:46:08 <glguy> you can know everything about it and write bad haskell code ! :)
00:46:14 <atp> yes, hehe
00:46:25 <tga> I'm speed-digesting Haskell for school so I guess I care more about knowing than writing code
00:46:28 <tga> sadly enough
00:46:33 <atp> hey sjanssen, i like that newtype deriving voodoo you do in XMonad.hs
00:46:46 <atp> didn't know you could do that :)
00:47:17 <atp> tga: don't worry about it.  if you enjoy haskell, you will invariably end up knowing more about this stuff than you ever cared to know, and if not, who cares?
00:47:55 <tga> functional programming has already warped the way I think about things, so I have no choice
00:48:05 <tga> the first thing I noticed was that now I just want to map stuff everywhere
00:48:17 <atp> yes
00:48:31 <atp> it's quite addictive
00:48:47 <atp> and as ddarius is fond of saying (and i agree with him), haskell is the gateway drug to programming language research
00:49:11 <atp> you find yourself reading academic papers really quickly (and enjoying them)
00:49:39 <goalieca> or haskell is just a gateway drug to avoiding loops while coding C++
00:50:05 <goalieca> i always hated oop
00:50:16 <goalieca> it took me a while to find haskell
00:50:41 <tga> haskell the antiloop
00:50:45 <jeffz> i'm a tad bit annoyed i didn't know about haskell sooner.
00:51:14 <ZsoL> Recently, i found myself implementing foldr and foldl in eiffel
00:51:33 <ZsoL> students around me looked somewhat puzzled :-)
00:51:42 <atp> you know you're in trouble when you start thinking about implementing monads in C
00:52:04 <atp> as i think dan piponi did i think
00:52:09 <tga> I was just thinking that folds would be quite easy to implement in C
00:52:31 <atp> they're really just for loops if you think about it...
00:52:34 <Taejo> tga: you'd have trouble with types, wouldn't you?
00:52:45 <atp> folds i mean
00:52:54 <tga> hmm, maybe specialized folds for starters
00:52:55 <Taejo> you could do templatised folds in C++
00:52:57 <ZsoL> tga, the fun is when you implement it using multiple inheritance
00:52:59 <atp> ick
00:53:01 <atp> C++ should die
00:53:02 <Sizur> still the best implementation of folds is done in
00:53:03 <Sizur> paper
00:53:05 <atp> use C if you must
00:53:10 <atp> but C++... noooooo
00:53:36 <Taejo> atp: I use C++ in programming competitions. STL saves lives.
00:54:19 <atp> Taejo: it is an evil, evil language, besot with horrible inconsistencies and warts, and nowhere near as readable, portable, or fast as C
00:54:30 <atp> but that's just my humble opinion :)
00:54:31 <Sizur> the paper theory states that any infinite list can have maximum 12 elements
00:55:00 <ZsoL> Sizur, doesn't sound very useful
00:55:42 <Sizur> a 12 dimensional list?
00:55:55 <Sizur> of one element in each dim lol
00:58:00 <Taejo> atp: I agree with you, but I'm not writing operating systems; I'm writing programming contests
00:58:25 <OceanSpray> :t throwError
00:58:26 <tga> just do Java then
00:58:27 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
00:59:23 <Sizur> c# is better for that. but why not haskell? it's the best lang for projecteuler.net atleast
01:15:08 <Sizur> @users
01:15:08 <lambdabot> Maximum users seen in #haskell: 401, currently: 366 (91.3%), active: 9 (2.5%)
01:15:59 <hpaste>  aaim annotated "Why is this not match " with "(no title)" at http://hpaste.org/4318#a1
01:19:24 <OceanSpray> oh wow, it actually compiled.
01:58:27 <cinimod> @pl \x -> (x <=3)
01:58:27 <lambdabot> (<= 3)
01:58:42 <cinimod> @pl \x -> (x <=3) && (x >= 3)
01:58:42 <lambdabot> liftM2 (&&) (<= 3) (>= 3)
01:59:06 <cinimod> :t liftM2 (&&)
01:59:08 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
01:59:43 <cinimod> :t liftM2 (&&) (<= 3)
01:59:44 <lambdabot> forall a. (Num a, Ord a) => (a -> Bool) -> a -> Bool
01:59:44 <Taejo> :t liftM2 (&&) (<= 3) (>= 3)
01:59:45 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
02:00:49 <cinimod> :t (<= 3)
02:00:49 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
02:01:08 <cinimod> presumably m is the identity monad?
02:01:44 <cinimod> no it can't be
02:02:20 <cinimod> must be (a ->)
02:03:00 <cinimod> :i (->)
02:03:33 <cinimod> instance Monad ((->) r) -- Defined in Control.Monad.Instances
02:04:11 <cinimod> \me lives and learns
02:05:25 <OceanSpray> This code I'm writing has the most atrocious indentation EVER.
02:06:37 <ray> M-x indent-region
02:07:00 <quicksilver> M-x indent-regions makes a royal mess of haskell code :)
02:07:23 <OceanSpray> No, not too little indentation,
02:07:27 <OceanSpray> too MUCH of it.
02:07:29 <ray> that just means your mode isn't good enough
02:07:35 <ray> (and i know some of it is ambiguous and all that)
02:07:42 <ray> (that's no excuse)
02:08:00 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/4322
02:08:17 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/4323
02:08:25 <OceanSpray> well, shit.
02:08:38 <ray> english is ambiguous but that doesn't stop copy editors from indenting it (bad analogy)
02:09:10 <OceanSpray> I thought it had gone over the size limit
02:09:20 <OceanSpray> see, how would I fix that?
02:09:34 <OceanSpray> I have to use the smallest font size just so that the line doesn't crop.
02:13:25 <mwc> fwiw, I've found that if you go more than three levels deep, it's time to start factoring your code because you're trying to do too much
02:14:45 <OceanSpray> It seems so.
02:14:47 <cinimod> :t liftM2 (&&) (<= 3) (>= 0)
02:14:53 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
02:15:01 <cinimod> > liftM2 (&&) (<= 3) (>= 0) 2
02:15:06 <lambdabot>  True
02:15:10 <cinimod> > liftM2 (&&) (<= 3) (>= 0) 4
02:15:11 <lambdabot>  False
02:15:16 <cinimod> > liftM2 (&&) (<= 3) (>= 0) (-1)
02:15:16 <OceanSpray> If I could just use do notation with what I'm doing...
02:15:17 <lambdabot>  False
02:16:22 <dmwit> OceanSpray: You might want to consider whether the data types you're using are really what you want.
02:16:57 <dmwit> Having a spaghetti value like (Pair prc (Pair args (Pair envt (Pair cnt NULL)))) suggests to me that you haven't really figured out what you want your values to be yet.
02:17:12 <dmwit> (Although this is just a guess based on a very small portion of your code.)
02:17:33 <OceanSpray> what I want my values to be
02:17:39 <OceanSpray> I don't understand.
02:17:59 <dmwit> Well, just as an example, it might make more sense to have two constructors:
02:18:00 <mwc> OceanSpray, trying to operate on deeply nested types as a whole like that is bad form
02:18:30 <OceanSpray> I see no alternative.
02:18:41 <dmwit> OceanSpray: Flatten the type.
02:18:44 <dmwit> Use something like
02:18:48 <mwc> as a general rule, I force myself to agonize over reaching more than one constructor deep into any given value
02:18:48 <RyanT5000> OceanSpray: sorry, i just started reading; what's your difficulty?
02:19:02 <OceanSpray> I'm a novice in all aspects.
02:19:03 <mwc> I think to myself, is there really no way I can factor this out?
02:19:19 <dmwit> data Foo a b c d = WithEnvironment a b c | WithPRC a b c d -- or something
02:19:39 <sjanssen> OceanSpray: I think you need to factor out the "Nothing -> throwError" part
02:19:54 <OceanSpray> how?
02:20:07 <RyanT5000> OceanSpray: what's the type of your function "apply"?
02:20:18 <RyanT5000> OceanSpray: explicit type annotations, at least at the top level, would be very helpful
02:20:23 <OceanSpray> apply :: LispProc -> LispVal -> LispEnv -> LispCont -> LispRet
02:20:30 <RyanT5000> OceanSpray: oh sorry, i didn't see the first file, nvm
02:21:17 <natv> If I'm trying to build a cabal package and get the error message " 'Executable' stanza starting with field 'cabal-version'" is that indicative of a malformed package, or some problem in my environment?
02:21:30 <OceanSpray> Note that sometimes, a procedure CAN return Nothing and not produce an error.
02:21:33 <RyanT5000> mwc: while i agree with your general principle, I've found that evaluating s-expression-like stuff generally requires two or so levels of constructors rather than one
02:21:33 <dmwit> Oh, wait, these binds are partially applied... and then passed to eval?  Interesting.
02:21:36 * dmwit looks more carefully
02:21:56 <RyanT5000> OceanSpray: using an infix constructor for Pair would make everything *look* a lot nicer
02:22:13 <OceanSpray> what is an infix constructor?
02:22:14 <dmwit> OceanSpray: Have you considered using a real Error monad?
02:22:24 <OceanSpray> I am using an Error monad
02:22:31 <RyanT5000> OceanSpray: like how (:) is the constructor for haskell's list conses
02:22:43 <dmwit> OceanSpray: I mean in place of Maybe.  That would help eliminate the cases, I think.
02:22:46 <OceanSpray> LispErrT a = ErrorT LispErr IO a
02:22:54 <OceanSpray> Maybe cannot be gotten rid of
02:23:04 <dmwit> Why not?
02:23:09 <mwc> OceanSpray, just like you can define your own operators, you can define operator constructors using the same characters. the only rule is that they must start with :
02:23:16 <OceanSpray> (define a b) would return a Nothing, for example,
02:23:26 <mwc> starting with : is sort of like capitalization for operators
02:23:45 <OceanSpray> so I can't really replace all Nothing -> throwError with just throwError
02:24:21 <OceanSpray> mwc, so I just make Pair use ':' in constructing pairs?
02:24:24 <mwc> Not :
02:24:27 <dmwit> OceanSpray: I mean, the functions you're calling should return something other than Maybe; you obviously need to be returning more information.
02:24:35 <dmwit> s/obviously/might/
02:24:38 <mwc> : is reserved for the lists
02:24:53 <OceanSpray> ok, :p or something?
02:24:57 <mwc> but something like a :: b might be easier to scan than Pair a b
02:24:59 <OceanSpray> or are letters not allowed?
02:25:13 <mwc> no, they have to be entirely "operator symbols"
02:25:14 <dmwit> Yeah, only symbols.
02:25:14 <OceanSpray> I thought :: was the has-type operator.
02:25:22 <dmwit> It is, you can't use that.
02:25:26 <mwc> might be
02:25:28 <mwc> I never actually checked
02:25:35 <OceanSpray> hm
02:25:36 <mwc> to see if its a reserved symbol everywhere
02:25:43 <mwc> I guess it'd have to be now that I think of it
02:25:47 <OceanSpray> :-) will be my constructor operator.
02:25:51 <RyanT5000> lol
02:25:58 <RyanT5000> how about
02:26:00 <RyanT5000> :.: or something
02:26:01 <mwc> certain things like "qualified" and "as" aren't keywords everywhere
02:26:04 <dmwit> (parens might be reserved too)
02:26:11 <dmwit> :->
02:26:19 <mwc> :-:?
02:26:22 <RyanT5000> reminiscent of not only the . operator from lisp but the general goal of making everything as blinding as possible
02:26:25 <OceanSpray> ;_;
02:26:43 <dmwit> :^_^
02:26:56 <mwc> I'm pretty sure _ isn't allowed
02:27:01 <wolverian> the :::::::::::::::: operator
02:27:07 <mwc> _foo is a valid identifier?
02:27:14 <OceanSpray> that'll shorten things up!
02:27:27 <OceanSpray> ok, :' should be alright, I think
02:27:33 <wolverian> of course, ::::::::::: and :::::::::::: have completely different meanings
02:27:47 <dmwit> > let _foo = 3 in _foo -- ?
02:27:49 <lambdabot>  3
02:27:53 <dmwit> seems fine
02:27:55 <OceanSpray> how do I declare those?
02:28:08 <dmwit> data Foo a = a :' a
02:28:18 <dmwit> data Pair a b = a :' b -- probably more useful ;-)
02:29:00 <OceanSpray> data LispVal = LispVal :' LispVal
02:29:06 <OceanSpray> how about labels?
02:29:13 <RyanT5000> labels?
02:29:17 <RyanT5000> symbols?
02:29:25 <OceanSpray> data LispVal = {car::LispVal :' cdr::LispVal} ?
02:29:35 <RyanT5000> OceanSpray: i don't think that works
02:29:38 <dmwit> Sorry, no.
02:29:40 <OceanSpray> damn.
02:29:40 <RyanT5000> OceanSpray: just write functions
02:29:46 <dmwit> But why not
02:30:00 <dmwit> data LispVal = LispVal { car :: LispVal, cdr :: LispVal } -- ?
02:30:12 <dmwit> Or is that what you wanted to get away from.
02:30:14 <RyanT5000> ok how about this
02:30:16 <mwc> dmwit, its arbitrary syntax that doesn't get you anywhere
02:30:18 <sjanssen> I bet you can write data LispVal = (:') { car, cdr :: LispVal }
02:30:21 <RyanT5000> just write the following functions
02:30:24 <mwc> because the point of records is to ease construction
02:30:28 <mwc> Foo { a = ... }
02:30:38 <mwc> accessing them can be done with fucntions
02:30:43 <mwc> also, they ease pattern matching too
02:30:44 <RyanT5000> cons, car, cdr
02:30:56 <mwc> but if you have an operator constructor, it's already dead simple
02:31:12 <RyanT5000> and, uncons :: Pair a b -> (a -> b -> c) -> c
02:31:23 <OceanSpray> It seems that the labelling is unnecessary
02:31:32 <RyanT5000> i.e.: just use cps to unpack your pairs
02:32:13 <OceanSpray> Can I have both a operator AND a normal data constructor for the same thing?
02:32:19 <RyanT5000> OceanSpray: afaik, no
02:32:26 <OceanSpray> dang.
02:32:48 <sjanssen> OceanSpray: you can have an operator for construction
02:32:48 <RyanT5000> yeah, haskell's namespace management is pretty lacklustre
02:33:24 <dmwit> You can have a normal (lower-case) function that constructs the value, though.  (Just no pattern matching.)
02:34:08 <RyanT5000> is there a reason we can't alias things for the purposes of matching?
02:34:50 <RyanT5000> i mean, certainly for simple aliasing it seems totally doable at compile-time
02:34:56 <OceanSpray> how do I set the associativity?
02:35:03 <dmwit> infix, infixl, infixr
02:35:15 <dmwit> infixr :' 9
02:35:15 <dmwit> for example
02:35:15 <OceanSpray> just put that anywhere?
02:35:35 <quicksilver> RyanT5000: no, there isn't a reason. It just hasn't been done.
02:35:53 <OceanSpray> what's :
02:35:54 <quicksilver> RyanT5000: in principle it could be easily enough implemented as a preprocessing pass
02:36:09 <OceanSpray> 's number?
02:36:13 <OceanSpray> is it 9, too?
02:36:59 <RyanT5000> quicksilver: well i wouldn't really advocate changing it anyway; i'm pretty sure all of haskell's scoping and namespacing should just be torn out and replaced at once
02:37:43 <quicksilver> @info (:)
02:37:44 <lambdabot> (:)
02:37:48 <quicksilver> @src (:)
02:37:49 <lambdabot> Source not found. My mind is going. I can feel it.
02:37:53 <dmwit> ?help info
02:37:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:37:57 <quicksilver> OceanSpray: :i (:) should tell you, in ghci
02:38:15 <quicksilver> data [] a = ... | a : [a] 	-- <wired into compiler>
02:38:15 <quicksilver> infixr 5 :
02:38:37 <OceanSpray> ah, 5
02:39:21 <dmwit> I wonder what ?info spell-corrects to.
02:39:37 <dmwit> ?echo (:)
02:39:37 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "dmwit!n=dmwit@buckwheat.Stanford.EDU", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo (:)"]} rest:"(:)"
02:39:54 <RyanT5000> quicksilver: the namespace and record systems are barely passable, the transitive scoping of instances is terrible, and the scoping of implicit variables is a downright travesty
02:40:03 <RyanT5000> sorry, implicit parameters, not implicit variables
02:40:54 <RyanT5000> so, i'm happy with most of the stuff haskell does with my objects, just not how i refer to them :P
02:41:17 <sjanssen> RyanT5000: to be fair, implicit parameters aren't a part of Haskell proper
02:41:37 <quicksilver> RyanT5000: "transitive scoping of instances?"
02:41:44 <RyanT5000> sjanssen: true, and they certainly shouldn't become so until they have some scoping rules
02:42:05 <quicksilver> RyanT5000: I sincerely they never do. They're horrible.
02:42:12 <quicksilver> insert 'hope' into that somewhere.
02:42:25 <sjanssen> RyanT5000: they're also a much-maligned extension, I don't think you'll have to worry about that
02:42:36 <RyanT5000> quicksilver: there's no way for me to import, for instance, Control.Monad.Error without also getting an (unwanted, possibly) instance MonadError Either (or whatever it is)
02:43:05 <quicksilver> RyanT5000: *nod* but the whole typeclass system is based on the assumption of (at most) one instance for a type of a class.
02:43:11 <quicksilver> so instances are essentially global.
02:43:21 <quicksilver> In many ways it would be nice if that wasn't true.
02:43:28 <RyanT5000> quicksilver: right; to me, that's the same as saying "the whole typeclass system is braindamaged"
02:43:30 <quicksilver> but removing that property is not without its problems.
02:43:47 <quicksilver> that's a very harsh judgement
02:43:52 <quicksilver> and in my view quite incorrect
02:43:56 <quicksilver> the typeclass system is very powerful
02:44:01 <quicksilver> maybe it's just not what you want it to be...
02:44:04 <RyanT5000> yeah, i know i'm going to bring down the wrath of this chatroom by saying such a thing :)
02:44:06 <quicksilver> but what it is, it does well.
02:44:19 <RyanT5000> quicksilver: no, i think it's a great idea, but i can't abide the scoping
02:44:26 <RyanT5000> nothing should ever force code upon me that i don't want
02:44:36 <RyanT5000> i can't envision a situation in which that's excusable
02:44:38 <quicksilver> the business about transitive scoping of instances is merely a rather minor side-effect of the general assumption that instances are global.
02:44:55 <RyanT5000> quicksilver: it's forced me to newtype a *lot*
02:44:58 <quicksilver> right.
02:44:59 <sjanssen> RyanT5000: the single instance property is somewhat important towards correctness
02:45:15 <quicksilver> probably you shouldn't be using typeclasses at all then, if that's what you're doing.
02:45:24 <quicksilver> just pass around higher-order functions
02:45:29 <quicksilver> (sometimes called dictionaries!)
02:45:39 <sjanssen> RyanT5000: eg. we need to know that a Map was constructed with the same Ord instance
02:46:04 <sjanssen> s/a Map was/two Maps were/
02:46:09 <RyanT5000> sjanssen: would it be any worse to just chuck the ordering function into the map itself?
02:46:29 <sjanssen> RyanT5000: that's quite bad for optimization
02:46:46 <RyanT5000> quicksilver: exactly! so why can't i just *usually* use the typeclass system, and then have a mechanism for overriding it when i feel like it?
02:47:19 <RyanT5000> sjanssen: yeah, i suppose you're right about that; i don't know how good the constant analysis stuff is, or how good it would have to be
02:47:27 <quicksilver> without understanding much more about the kind of code you write, I can't answer that
02:47:42 <sjanssen> RyanT5000: moreover, it's not particularly convenient for the author of Data.Map
02:47:42 <quicksilver> but in my experience many people use typeclasses when they aren't the right solution
02:47:52 <quicksilver> and then find they don't work the way they want :)
02:48:02 <quicksilver> because, they weren't the thing they wanted them to be...
02:48:10 <quicksilver> typeclasses are really a mechanism for overloading.
02:48:22 <quicksilver> not a general mechanism for chucking around higher-order functions with data
02:48:22 <RyanT5000> quicksilver: i practically never use typeclasses except when i want to use libraries that use them
02:48:59 <RyanT5000> sjanssen: yeah, you're right about all of these concerns; what we really need is dependent types, so we can just chuck the comparison function into the type
02:49:46 <RyanT5000> sjanssen: (yeah, i realize that's a difficult solution)
02:50:09 <RyanT5000> all i know is that i've never encountered a situation where, in the long run, i was happy that i had a global variable
02:50:21 <sjanssen> RyanT5000: we can represent the comparison function in Haskell's type system -- it just isn't particularly pretty
02:50:37 <sjanssen> RyanT5000: that isn't a fair comparison, IMO
02:50:54 <RyanT5000> sjanssen: really?
02:51:07 <sjanssen> RyanT5000: yes, for one thing instances aren't "variable"
02:51:17 <RyanT5000> sjanssen: ok, global *assumptions*
02:51:29 <RyanT5000> it's variable at design-time
02:51:29 <quicksilver> it's only an assumption for the purpose of overloading
02:51:33 <quicksilver> that's all it is
02:51:39 <quicksilver> it's only so you can use (+) or do {} notation
02:51:48 <quicksilver> it's not actually a restriction on expressivity in any way
02:52:11 <RyanT5000> quicksilver: if people actually restricted themselves to using it for those kinds of things, i wouldn't be nearly as upset
02:52:24 <RyanT5000> take, for instance, a serialization library using class Serializable
02:52:33 <RyanT5000> which, i believe, is the current Haskell canon
02:52:53 <RyanT5000> suppose i don't like the fact that it serializes integers in a really stupid way
02:53:00 <RyanT5000> (which it does)
02:53:22 <RyanT5000> (at least for my purposes, which was that i needed very tiny representations when possible)
02:53:31 <RyanT5000> the point is that not everyone needs the same serialization of integers
02:53:57 <quicksilver> that's certainly true; but auto-serialisation is not for people who care about the details of serialisation
02:54:06 <RyanT5000> why not?
02:54:06 <quicksilver> auto-serialisation is for those people who don't care
02:54:13 <quicksilver> if you do care, then you choose your details yourself
02:54:15 <dmwit> :t second
02:54:16 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
02:54:16 <RyanT5000> why does it have to be difficult just because you care?
02:54:21 <quicksilver> it isn't difficult
02:54:27 <quicksilver> you just use Put and Get directly
02:54:46 <quicksilver> Binary provides a two-level interface
02:55:00 <quicksilver> one level contains default serialisations for people who are happy not to know the exact format
02:55:00 <sjanssen> serialization is actually a perfect example of why global instances are good
02:55:01 <RyanT5000> yeah, well i don't think i should have to accept or reject levels wholesale
02:55:06 <quicksilver> you don't
02:55:12 <quicksilver> you can mix and match them very easily
02:55:40 <sjanssen> we need to be totally certain that the same instance is always used on a particular bit of data
02:56:28 <RyanT5000> sjanssen: not for serialization we don't; it already breaks out of the type system
02:56:40 <quicksilver> a more convincing example IMO is sortBy
02:56:49 <quicksilver> it is kind-of clumsy that we have sort and sortBy
02:57:02 <quicksilver> and msum is another example I find more convincing
02:57:22 <sjanssen> why msum?
02:57:27 <quicksilver> :t msum
02:57:28 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:57:30 <RyanT5000> quicksilver: well those are clumsy, but they don't prevent you from reusing other people's code
02:57:33 <quicksilver> I ddin't mean msum
02:57:37 <quicksilver> :t mconcat
02:57:38 <lambdabot> forall a. (Monoid a) => [a] -> a
02:57:38 <RyanT5000> if i like all the serialization code *except* integers
02:57:40 <quicksilver> that's the one
02:57:52 <RyanT5000> there's no reason i should have to rewrite all of it just to support my special integer serialization
02:58:05 <RyanT5000> also, i shouldn't have to make deep changes to my datastructure to add in newtypes to support int
02:58:50 <quicksilver> well, I think that's an unusual case myself
02:59:06 <quicksilver> I don't think it's common to have no interest in the details of serialisation for most of your types
02:59:10 <quicksilver> and suddenly care about Integer
02:59:16 <quicksilver> IME you either care, or you don't.
02:59:26 <quicksilver> if your intention is to produce a consistent, documentable file format
02:59:28 <quicksilver> then you have to care
02:59:42 <quicksilver> if you're just doing lazy serialisation to be read back in by the same version of ghc/Binary, then you don't.
02:59:43 <RyanT5000> quicksilver: that's like saying that you should either write your whole program in python because you don't care about performance or in assembly because you do
02:59:45 <sjanssen> RyanT5000: by the way, what's wrong with the current Integer serialization?
02:59:50 <quicksilver> RyanT5000: no, it isn't.
02:59:58 <quicksilver> RyanT5000: it's entirely different.
03:00:02 <RyanT5000> quicksilver: we profile because we don't want to waste effort on things that only matter a little
03:00:18 <quicksilver> serialisation is a very specific domain, and one which I have spent a long time thinking about
03:00:43 <quicksilver> and in my opinion the key distinction is (1) I care about the exact format because I need to document it and (2) I couldn't care less, I just want read/write to work.
03:00:49 <RyanT5000> quicksilver: if you care about serialization size but not serialization details, for instance, you might find that reducing the size of integers helps, whereas the existing array serialization routine is already fine
03:02:17 <RyanT5000> sjanssen: it wastes like 4 bytes
03:02:18 <quicksilver> sjanssen: takes up too much space on small numbers, I believe is RyanT5000's point.
03:02:37 <RyanT5000> sjanssen: it stores it as a 32-bit integer plus an array of 32-bit integers or something
03:02:47 <RyanT5000> sjanssen: which means you're spending 8 bytes representing 0
03:03:14 <sjanssen> yes, that isn't so nice
03:03:27 <RyanT5000> sjanssen: there are simple schemes that would use 1 byte on that
03:03:32 <RyanT5000> so
03:03:42 <RyanT5000> while i don't have a problem in general
03:03:49 <RyanT5000> i don't think it should be so hard to change
03:04:10 <sjanssen> it isn't so hard to change, 'darcs send' :P
03:04:23 <quicksilver> but that underlines a key flaw in Binary
03:04:26 <sjanssen> (yes, I know that isn't a real solution for a variety of reasons)
03:04:39 <RyanT5000> but what if someone else prefers, for example, 4-byte aligned values :)
03:04:40 <quicksilver> that it doesn't cope with version changes
03:04:51 <RyanT5000> that's my point: people have different needs
03:04:58 <quicksilver> which is one reason why I think Binary is primarily for network serialisation and throwaway data
03:05:07 <RyanT5000> and they shouldn't have to blast away a whole library just because their needs are slightly different
03:05:08 <quicksilver> persistent storage will always want a well designed file format
03:05:11 <quicksilver> with versioning and stuff
03:05:22 <RyanT5000> quicksilver: yeah, that's true
03:05:38 <quicksilver> I think typeclasses probably are entirely the wrong solution for a real file format library
03:05:47 <quicksilver> but they're a good solution for what Binary does
03:05:53 <quicksilver> which is fast network communication
03:06:04 <quicksilver> and between-request serialisation
03:06:15 <quicksilver> short-term stuff which is guaranteed to be running the same version of the libs
03:06:19 <sjanssen> to be fair, binary isn't just a type class for serialization
03:06:24 <RyanT5000> quicksilver: yeah, it's fine for a number of applications
03:06:31 <sjanssen> it's also a library for slurping and generating ByteStrings quite quickly
03:06:37 <sjanssen> you don't have to use the Binary class at all
03:06:46 <quicksilver> sjanssen: true enough, but we're talking about the Binary class here
03:06:56 <RyanT5000> quicksilver: my point is that small deviations from the assumptions of the library designers shouldn't require wholesale rejection of the library
03:07:01 <quicksilver> sjanssen: you could use Put and Get ven with a putative file format library.
03:07:07 <RyanT5000> (s/library/sublibrary/g if you wish)
03:07:30 <sjanssen> RyanT5000: I don't see why it does require wholesale rejection
03:07:52 <RyanT5000> sjanssen: the only other choice is to replumb my entire datastructure with MyInt newtypes or something equally retarded
03:08:27 <sjanssen> RyanT5000: when you're writing your instances, use 'superDuperIntegerPut' for Integer components rather than 'put'
03:08:29 <RyanT5000> assuming that i've already written my datastructure (and dons or whoever has already written Data.Binary), there's no real way to reconcile them
03:08:58 <RyanT5000> sjanssen: yeah, ok, but that only works for leaf types
03:09:16 <RyanT5000> sjanssen: if i instead had a complaint about array serialization or something, i'd be in the cold again
03:09:33 <quicksilver> sjanssen: what he's trying to do is 'mostly' reuse the class Binary
03:09:38 <quicksilver> sjanssen: but override some types
03:09:47 <quicksilver> sjanssen: (rather than just using Get and Put)
03:10:15 <sjanssen> quicksilver: right.  You can do that when writing your own instances
03:10:27 <quicksilver> sjanssen: but not if you have [Integer]
03:10:29 <quicksilver> of course
03:10:38 <sjanssen> true
03:10:41 <quicksilver> mind you, I don't really accept his comment as a common complaint :)
03:10:55 <sjanssen> yeah, parametricity is a problem
03:10:56 <quicksilver> I maintain that if you want that much control, you should be using Put and Get correctly.
03:11:24 <RyanT5000> quicksilver: alright quicksilver, then explain to me how to get a custom-sorted Map (Map a b) c
03:11:57 <quicksilver> with a newtype :)
03:12:02 <RyanT5000> yeah, that's fantastic
03:12:03 <RyanT5000> lol
03:12:11 <RyanT5000> that's my point
03:12:16 <RyanT5000> everything always comes down to a newtype
03:12:24 <RyanT5000> newtypes require a ton of code changes when you don't realize them upfront
03:12:47 <RyanT5000> and typeclasses are all about integrating things you didn't necessarily realize you would be integrating
03:12:50 <quicksilver> but if you care about the sorting, I'm not entirely sure Map is the right tool.
03:13:00 <quicksilver> in my view, Map is abstract.
03:13:11 <RyanT5000> quicksilver: what if i want a different equivalence relation?
03:13:14 <quicksilver> the fact that it happens to maintain an internal sort is not really part of its contract.
03:13:26 <RyanT5000> quicksilver: that'll affect keys
03:13:37 <RyanT5000> quicksilver: in an observable way
03:13:49 <quicksilver> yes, that's definitely a case for a newtype, I agree
03:14:11 <quicksilver> although you can do something a bit funky with a higher-kinded Map wrapper
03:14:18 <Baughn> quicksilver: I view Map as a sorted tree, which /does/ have that as part of the contract.
03:14:21 <RyanT5000> well now i have to go through and modify every function that has ever referred to that value
03:14:34 <RyanT5000> why should i have to do that?
03:14:39 <Baughn> ..actualy, I'm not sure what use an /unsorted/ tree could be
03:14:53 <quicksilver> type DifferentMap Box a b = Map (Box a) b
03:15:00 <quicksilver> you can use a generic boxer 'Box'
03:15:02 <quicksilver> data Box a = Box a
03:15:05 <RyanT5000> Baughn: if it sorted by something unsafe (StrongName, e.g.), then hiding that could be useful
03:15:09 <quicksilver> and write different ord instances for it
03:15:24 <quicksilver> Baughn: an unsorted tree is used in various heap algorithms
03:15:30 <quicksilver> Baughn: priority queues and stuff like that
03:15:31 <OceanSpray> it seems that :' cannot be used
03:15:49 <RyanT5000> quicksilver: i understand that your solutions are *correct*, but only in the same way that "write it all in machine code" is "correct"
03:15:50 <sjanssen> quicksilver: hmm, I think this approach could even be adapted for generic use with eg. Edison
03:16:01 <OceanSpray> what's the command in emacs to replace text?
03:16:08 <Baughn> quicksilver: You wouldn't say those are sorted by priority?
03:16:13 <quicksilver> RyanT5000: I agree there are shortcomings with using typeclasses to model stuff like collection
03:16:15 <RyanT5000> quicksilver: the purpose of programming in a high-level language is to be able to make sweeping changes concisely
03:16:22 <quicksilver> Baughn: they are not totally sorted in the way we are discussing
03:16:29 <quicksilver> Baughn: tehre is an invariant, but it's weaker than total order
03:16:41 <quicksilver> Baughn: that's the "clever" bit of the algorithm
03:16:57 <RyanT5000> quicksilver: (*a* purpose, rather)
03:17:07 <quicksilver> RyanT5000: yes, definitely not "the" purpose.
03:17:32 <quicksilver> anyhow, I agree there are shortcomings in using typeclasses with Map and similar
03:17:38 <RyanT5000> quicksilver: so i reject the notion that i should have to make O(f) changes to my code when i want to change the serialization routine or the map sorting or whatever
03:17:51 <RyanT5000> where f is the number of functions that refer to the value in question already
03:18:01 <RyanT5000> i mean, let's say i just write the following thing
03:18:32 <RyanT5000> data MyDatastructure = MyDatastructure ... Integer ...
03:18:37 <RyanT5000> where "..." is some other stuff
03:18:47 <RyanT5000> now i use MyDatastructure in like a billion places throughout my program
03:18:50 <OceanSpray> ghc gives me
03:18:52 <OceanSpray> LispData.hs:19:10: parse error on input `5'
03:19:14 <OceanSpray> which is the line where I wrote
03:19:15 <OceanSpray> infixr :\ 5
03:19:29 <RyanT5000> even if i should have designed it a little better than that, do i really deserve to need to make a billion changes when i want to play with the serialization?
03:19:42 <RyanT5000> (newtype method)
03:20:05 <RyanT5000> or do i really not deserve to use Data.Binary.Binary at all?
03:21:09 <RyanT5000> i don't really see how, e.g., the ability to either statically or dynamically scope instances would be worse than either of those options
03:21:21 <RyanT5000> in fact
03:21:39 <RyanT5000> i'd even settle for the ability to evict instances entirely from my program
03:21:43 <quicksilver> I personally like the notion of lexically scoping instances.
03:21:54 <quicksilver> but sjanssen has explained to me there are problems with that :)
03:22:00 <RyanT5000> ghc -exclude-instance Data.Binary.Binary
03:22:04 <RyanT5000> er
03:22:10 <RyanT5000> Data.Binary.Binary Integer
03:22:13 <Baughn> How would you implement that?
03:22:27 <quicksilver> my interpretation of the problem is that the type is Map k v and not (Ord k => Map k v)
03:22:43 <quicksilver> it would be ok if the ord instance was implicit in the type and always carried around
03:23:01 <quicksilver> but that's beyond my knowledge of System Fc to understand if that's feasible.
03:23:48 <RyanT5000> quicksilver: yeah, that's a really good point; the Ord instance should definitely be associated with the datastructure rather than the manipulation functions
03:23:56 <RyanT5000> which would solve sjanssen's safety concerns
03:24:11 <RyanT5000> (though perhaps would cause optimization issues)
03:24:15 * sjanssen is hacking up a proto type of that as we speak
03:24:26 <RyanT5000> sjanssen: cool :)
03:24:28 <quicksilver> it's a bit like existensials
03:26:00 <quicksilver> in the sense that it only matters if something "escapes"
03:26:08 <quicksilver> suppose you want to use mconcat at a different instance
03:26:18 <quicksilver> mconcat:: [Int] -> Int
03:26:26 <quicksilver> might be muliplication or addition
03:26:36 <quicksilver> selecting an instance lexically is fine for that
03:26:46 <quicksilver> since it only returns an Int
03:26:54 <quicksilver> which "can no longer remember" what kind of Monoid it is
03:27:09 <quicksilver> but with
03:27:10 <quicksilver> :t insert
03:27:12 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
03:27:18 <RyanT5000> about all of this, though, i must say i just prefer to chuck the ord function into the map type :P
03:27:34 <RyanT5000> Map compareInt Int Thing
03:27:47 <RyanT5000> someday...
03:30:01 <RyanT5000> i'm sure that ruins unification and stuff
03:30:14 <RyanT5000> but it looks really sexy :P
03:32:02 <RyanT5000> alright, well, back to law school work (*sigh*); i don't actually know what i was thinking going to law school
03:34:44 <OceanSpray> Ok, things seem to work right now.
03:34:49 <OceanSpray> Final problem of the night:
03:35:06 <OceanSpray> the cont $ throwErrors I have around,
03:35:20 <OceanSpray> do they need the cont $ ?
03:35:27 <RyanT5000> by the way, when i call a haskell feature "stupid" i'm always exaggerating; you guys should know how much i love haskell :)
03:35:35 <SamB_XP> OceanSpray: what is cont?
03:35:44 <dmwit> :t cont
03:35:45 <lambdabot> Not in scope: `cont'
03:35:46 <OceanSpray> cont, here is a LispCont
03:35:55 <OceanSpray> that is, LispRet -> LispRet
03:35:56 <SamB_XP> RyanT5000: why need you always be exhaggerating
03:36:12 <SamB_XP> OceanSpray: well... what's it for?
03:36:13 <RyanT5000> SamB_XP: i don't need to be, although it certainly gets discussion going quicker
03:36:17 <OceanSpray> that is, LispRet :: LispErrT (Maybe LispVal)
03:36:33 <SamB_XP> RyanT5000: I mean... can't Haskell have stupid features?
03:36:38 <OceanSpray> LispErrT a :: ErrorT LispErr IO a
03:36:40 <SamB_XP> like the MR, for instance
03:36:44 <OceanSpray> so... yeah.
03:36:46 <dmwit> OceanSpray: Well, I assume (cont /= id).  What does it do?
03:37:01 <OceanSpray> it's a continuation.
03:37:06 <SamB_XP> should suggest a PW instead or something
03:37:08 <RyanT5000> SamB_XP: stupid is pretty harsh; most of the features are the result of a lot of hard work by really smart individuals
03:37:19 <RyanT5000> even if misguided, there's usually a kernel of usefulness
03:37:21 <OceanSpray> every eval and apply has a continuation passed in, represented by this value.
03:37:41 <SamB_XP> well... I can see what they were getting at with the MR, but it was totally the WRONG way to go about it
03:38:07 <RyanT5000> SamB_XP: that's more than can be said of many things in the world
03:38:19 <Philippa> it's easy to say that ten years later though
03:38:21 <OceanSpray> Lemme think...
03:38:23 <RyanT5000> law school has really given me some perspective on how truly arbitrary and stupid humans can be
03:38:26 <SamB_XP> you mean like how americans are always trying to get rich?
03:38:45 <RyanT5000> i don't really see the connection there
03:38:46 <SamB_XP> oh, darwin award stupid?
03:39:15 * SamB_XP thinks getting rich is a stupid life goal
03:39:26 <RyanT5000> nah, not even that kind of stuff, just how so much of the law is a result of happenstance
03:39:34 <dmwit> Yeah, I think it would be hard to imagine the problematic cases of the MR without having encountered them a few times.
03:39:35 <RyanT5000> oh, i totally agree that it's a bad life goal
03:39:50 <RyanT5000> but being rich certainly helps one achieve some more worthwhile life goals
03:40:05 <RyanT5000> for example, if you can be your own venture capitalist, you'll have a much easier time in business
03:40:37 * SamB_XP wonders if the MR actually prevents any program from being written (even with asTypeOf)
03:41:08 <RyanT5000> i'd rather be successful and somehow magically poor than unsuccessful and somehow magically rich
03:41:45 <RyanT5000> (success = i've managed to establish one of the business ventures i'm planning to start)
03:41:47 * SamB_XP isn't sure hasTypeOf helps with any of the MR's annoyances
03:42:06 <Pastorn> how do i do caveman debugging? i wanna see what the evaluation is each step in my recursion
03:42:16 <SamB_XP> huh
03:42:17 <OceanSpray> I am intrigued by your ideas and would like to subscribe to your newsletter.
03:42:18 <RyanT5000> anyway, goodnight all
03:42:30 <dmwit> SamB_XP: Wait, you mean without type signatures or something?
03:42:59 * SamB_XP is probably confused
03:43:05 <dmwit> Pastorn: "Caveman debugging"?
03:43:23 <dmwit> SamB_XP: You can always give an explicitly polymorphic type signature to thwart the MR.
03:43:36 <Pastorn> print stuff again and again
03:43:45 <dmwit> :t Debug.trace -- =/
03:43:46 <lambdabot> Couldn't find qualified module.
03:43:51 <dmwit> :t trace
03:43:51 <lambdabot> Not in scope: `trace'
03:43:54 <dmwit> bwuh
03:43:57 <dmwit> ?index trace
03:43:57 <lambdabot> Debug.Trace
03:43:58 <Pastorn> @hugs trace
03:43:58 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:44:04 <dmwit> ?t Debug.Trace.trace
03:44:04 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:44:10 * dmwit goes to bed
03:44:15 <Baughn> Pastorn: See http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
03:44:16 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2orwlb
03:44:21 <SamB_XP> http://www.haskell.org/haskellwiki/Monomorphism_restriction says that sometimes you *can't* write a type signature
03:44:22 <lambdabot> Title: Monomorphism restriction - HaskellWiki
03:44:26 <Baughn> Pastorn: You want 6.8, of course. 6.6 didn't really /have/ a debugger.
03:44:53 <RyanT5000> there's a debugger now?
03:44:55 <RyanT5000> sweet
03:45:05 <RyanT5000> are we ever going to get backtraces on exceptions?
03:45:21 <Baughn> RyanT5000: We've had /that/ for a long time. It's buried in the profiling section.
03:45:22 <RyanT5000> are they in the debugger now?
03:45:33 <RyanT5000> Baughn: oh really? wow, i wish i had known
03:45:37 <Pastorn> fuck... don't have that here
03:45:41 * Pastorn is screwed
03:45:41 <Baughn> RyanT5000: Check http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
03:45:42 <lambdabot> Title: Haskell hacking
03:46:01 <dmwit> SamB_XP: Ah, yes, there are some tricks with where clauses, aren't there.
03:46:27 <dmwit> SamB_XP: Still, I'm pretty sure you could write a Turing machine simulator without running into that...
03:46:42 <SamB_XP> dmwit: eh?
03:46:44 <sjanssen> edison is somewhat strange
03:46:57 <sjanssen> why http://hackage.haskell.org/packages/archive/EdisonCore/1.2.1.1/doc/html/Data-Edison-Assoc-Defaults.html over normal default definitions?
03:46:58 <lambdabot> http://tinyurl.com/2j3gzr
03:47:03 <dmwit> SamB_XP: Weren't you asking whether there were any programs that were unwritable because of the MR?
03:47:09 <SamB_XP> I'm not talking about computations you can't do, I'm talking about otherwise well-typed Haskell programs you could write
03:47:26 <SamB_XP> er. can't write because of the MR.
03:47:27 <dmwit> oh
03:48:42 <RyanT5000> quicksilver: for truely arcane typeclass usage, see HAppS
03:49:21 * SamB_XP hopes they transferred GHC bug 1749 to the Haskell' trac...
03:52:24 <dmwit> ?pl \p x y -> if p then x else y
03:52:24 <lambdabot> if'
03:52:27 <dmwit> bah
03:53:14 <dmwit> :t guard
03:53:15 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
03:58:02 <dmwit> :t (<$)
03:58:03 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
03:59:34 <Baughn> @instances Functor
03:59:36 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:01:55 <Sizur> quicksilver: well, i have natural join with renaming alright
04:03:11 <Sizur> hpaste doesn't do unicode unfortunately
04:03:11 <Baughn> > (4 <$ Just 2)
04:03:11 <lambdabot>  Just 4
04:03:37 <Baughn> > (4 <$ printLn "foo")
04:03:37 <lambdabot>   Not in scope: `printLn'
04:04:02 <Baughn> @hoogle (<$)
04:04:02 <lambdabot> Did you mean: (<$)
04:04:02 <lambdabot> Prelude.undefined :: a
04:04:02 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
04:04:34 <Baughn> @hoogle <$
04:04:34 <lambdabot> Control.Applicative.(<$) :: Functor f => a -> f b -> f a
04:04:34 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
04:04:34 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b
04:05:46 <Baughn> @src (<$)
04:05:46 <lambdabot> (<$) = (<$>) . const
04:05:51 <Baughn> @src (<$>)
04:05:51 <lambdabot> f <$> a = fmap f a
04:06:41 <dmwit> > 4 <$ putStrLn "foo"
04:06:42 <lambdabot>  <IO Integer>
04:06:55 <dmwit> It prints "foo\n", then returns 4.
04:07:49 <Baughn> > 4 <$ (const 3)
04:07:49 <lambdabot>  Add a type signature
04:08:16 <Baughn> > 4 <$ (const 3 :: Int -> Int)
04:08:16 <lambdabot>  <Int -> Integer>
04:08:33 <Baughn> > (4 <$ (const 3 :: Int -> Int)) 42
04:08:34 <lambdabot>  4
04:08:55 <Baughn> So, sort of a higher-order const. Got it.
04:12:27 <Baughn> > (const 4) <$> 3
04:12:29 <lambdabot>   add an instance declaration for (Show (f t))
04:12:38 <Baughn> :t <$>
04:12:39 <lambdabot> parse error on input `<$>'
04:12:43 <Baughn> :t (<$>)
04:12:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:13:17 <Baughn> > (const 4) <$> (const 3)
04:13:18 <lambdabot>  Add a type signature
04:13:21 <Baughn> > ((const 4) <$> (const 3)) 42
04:13:22 <lambdabot>  4
04:18:06 <dmwit> :t \f x y -> (`f` x $ y)
04:18:08 <lambdabot>     The operator `f' [infixl 9] of a section
04:18:08 <lambdabot>         must have lower precedence than the operand `($)' [infixr 0]
04:18:08 <lambdabot>         in the section: `(`f` (x $ y))'
04:18:21 <quicksilver> Sizur: nice!
04:20:19 <ricky_clarkson> :t \f x y -> ((`f` x) $ y)
04:20:20 <lambdabot> forall t a b. (a -> t -> b) -> t -> a -> b
04:20:56 <ricky_clarkson> :t flip
04:20:57 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:21:44 <dmwit> I wanted:
04:22:03 <dmwit> ?pl \x -> cond x n p -- flip (flip cond n) p
04:22:03 <lambdabot> flip (flip cond n) p
04:28:07 <dmwit> ?hoogle (a -> b -> c -> d) -> (a,b,c) -> d
04:28:08 <lambdabot> No matches, try a more general search
04:28:16 <dmwit> What, no uncurry3?
04:30:29 <byorgey> dmwit: nope =(
04:39:25 <quicksilver> dmwit: I don't mind typing (\(a,b,c) -> f a b c) for uncurry3
04:39:31 <quicksilver> dmwit: it really doesn't take up that much space
04:39:51 <quicksilver> dmwit: and 87% of the time the parameters weren't in the right order anyway :)
04:39:52 <dmwit> quicksilver: I'm taking the "only point-free functions" FizzBuzz challenge.
04:39:57 <quicksilver> ah
04:40:14 <dmwit> I'm using list3 instead of uncurry3. =)
04:40:19 <quicksilver> :t list3
04:40:20 <lambdabot> Not in scope: `list3'
04:40:30 <dmwit> list3 x y z = [x, y, z]
04:43:00 <Sizur> quicksilver: gimmi some harder relation challenge
04:43:06 <Sizur> relational*
04:44:42 <araujo> morning
04:45:42 <alc> moin
04:45:46 <Sizur> class Joinable a b c where () :: a -> b -> c
04:46:02 <Sizur> instance (Eq a) => Joinable [(a,b)] [(c,a)] [(a,b,c)] where r1  r2 = [ (a1,b,c) | (a1,b)<-r1, (c,a2)<-r2, a1==a2 ]
04:46:33 <Sizur> renaming is done through a homomorphism
04:51:40 <quicksilver> show me a renaming example then
04:52:27 <Sizur> class Homomorphism a b where  :: a -> b
04:52:53 <Sizur> data Name  = Name String deriving (Show,Eq,Ord)
04:52:53 <Sizur> instance Homomorphism Parent Name where  (Parent s) = Name s
04:53:08 <Sizur> data Parent = Parent String deriving (Show,Eq,Ord)
04:53:08 <Sizur> instance Homomorphism Name Parent where  (Name s) = Parent s
04:54:07 <Sizur> instance Homomorphism a a where  = id
04:54:07 <Sizur> instance (Homomorphism a b) => Homomorphism [a] [b] where  r = map  r
04:54:19 <Sizur> etc for more dimentional relations
04:54:42 <Sizur>  (a::[Parent]) ::[Name]
04:55:36 <dmwit> http://programming.reddit.com/info/62bur/comments/c02m60b
04:56:47 <quicksilver> Sizur: what does the Joinable instance for [(a,b)] [(a,b)] look like then?
04:57:24 <Sizur> outer join?
04:57:38 <quicksilver> well that's part of the question, I guess
04:57:45 <quicksilver> how many instances does it have?
04:57:49 <Sizur> joinable a b c
04:58:08 <Sizur> you need to specify the resulting type
04:59:13 <Sizur> to do A B A, rename the second A into C and join both on B
04:59:25 <Sizur> you can always rename back into A if you need
05:00:17 <Sizur> the instance number is a problem
05:00:46 <Sizur> i'd write a script to writ ethem out for me
05:00:51 <quicksilver> ok, but it sounds like you have to write a lot of instances
05:00:58 <quicksilver> that is sort-of what I was getting at yesterday
05:01:04 <quicksilver> when I said "without metaprogramming"
05:01:09 <Sizur> yeah
05:01:16 <Sizur> definitely wont work without that
05:01:24 <quicksilver> I meant that I don't think you can generate all this instances from simple schemes
05:01:44 <Sizur> it's be a really long module
05:01:49 <Sizur> it'd*
05:02:22 <Sizur> plus i will have a ceiling on the relational dimentions
05:02:25 <Sizur> but that's ok in real life
05:05:49 <dmwit> ooooh, fromEnum
05:05:54 <dmwit> :t fromEnum :: Bool -> Int
05:05:55 <lambdabot> Bool -> Int
05:06:43 <dmwit> :t let if' p x y = [x, y] !! fromEnum p in if'
05:06:43 <lambdabot> forall a a1. (Enum a) => a -> a1 -> a1 -> a1
05:06:54 <dmwit> cute
05:07:58 <dmwit> rofl_waffler++
05:08:17 <adaszko> Hi, Haskellers
05:08:34 <adaszko> Could someone please help with this: http://hpaste.org/4324#a0 ?
05:08:41 <adaszko> help me*
05:09:26 <adaszko> I'am getting Not in scope: `mplus`, as I've written there
05:09:44 <dmwit> Wow, hpaste is very slow tonight.
05:10:04 <dmwit> adaszko: Hpaste isn't loading for me, but have you imported Control.Monad?
05:10:05 <quicksilver> yeah, it's not working for me at all
05:10:17 <quicksilver> adaszko: I imagine you just want import Control.Monad
05:10:25 <quicksilver> @index mplus
05:10:25 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:10:30 <adaszko> I'm checking it...
05:11:15 <adaszko> Yep, it works now :-)
05:11:24 <adaszko> thanks
05:12:11 <Sizur> peopleRel :: [ (Name, Gender) ]
05:12:11 <Sizur> parentsRel :: [ (Name, Parent) ]
05:12:11 <Sizur> parentOf :: Gender -> Name -> Parent
05:12:11 <Sizur> gender `parentOf` name = head ( parent)
05:12:11 <Sizur>     where parent = sex  parentsRel ::[(Parent,Gender,Name)]
05:12:12 <Sizur>             where sex =  (peopleRel  gender) ::[(Parent,Gender)]
05:13:05 <Sizur> doesnt look bad to me
05:13:57 <Sizur> data Gender = Male | Female
05:14:53 <Sizur> there we have selection, renaming, natural join, and a projection
05:15:06 <EvilTerran> unicode?
05:15:09 <Sizur> yeah
05:19:06 <Sizur> eh mistake, it should read: where parent = sex  parentsRel  name ::[(Parent,Gender,Name)]
05:20:59 <Sizur> Female `parentOf` (Name "Abel") == Name "Eve"
05:21:10 <Sizur> Parent "Eve" i mean
05:24:34 <quicksilver> Sizur: no, I think that's nice
05:25:14 <Sizur> it's not fast, but it sure looks good to me :)
05:25:35 <zeloran> hey
05:26:12 <zeloran> when i have an instance of this data structure data Plan = Plan [Train] deriving (Read,Show), how to access the Train array?
05:26:16 <Olathe> Eww.
05:26:47 <Olathe> zeloran: f (Plan xs) = head xs
05:26:51 <Sizur> access (Plan carts) =
05:27:06 <Olathe> Or whatever you want to do with xs.
05:27:29 <Sizur> zeloran: pattern match against the constructor
05:27:49 <Olathe> Since it's a train, maybe rxrs
05:27:58 <ibid> (there is no array in that type)
05:28:27 <Olathe> Yep, arrays are uglier than lists.
05:28:44 <Olathe> "Arrays ! Ewww !"
05:34:48 <mar77a> can i define a function like an infix operator?
05:35:30 <Saizan> > let x `add` y = x + y in add 2 4
05:35:31 <lambdabot>  6
05:35:39 <mar77a> o_O
05:35:50 <mar77a> so `add` works like a variable
05:35:57 <EvilTerran> > let x ?? y = (y,x) in "yes" ?? True
05:35:58 <lambdabot>  (True,"yes")
05:36:01 <Sizur> like an infix operator
05:36:15 <quicksilver> yes, but also like a variable, as mar77a says
05:36:16 <Saizan> > (+1) `map` [1..3]
05:36:17 <mar77a> i mean, in the declaration
05:36:17 <lambdabot>  [2,3,4]
05:36:21 <quicksilver> add was a variable bound by the let
05:36:24 <mar77a> it's a place holder for the function
05:36:26 <quicksilver> right
05:36:30 <mar77a> whoo whee
05:36:39 <EvilTerran> > let (~~) = (,) in "this works" ~~ "too"
05:36:40 <lambdabot>  ("this works","too")
05:36:47 <quicksilver> > let (+) = (*) in 5+5
05:36:48 <lambdabot>  25
05:37:55 <mar77a> anotehr thing
05:37:57 <mar77a> another*
05:38:00 <mar77a> the "<-" basically means
05:38:08 <mar77a> convert IO to String?
05:38:13 <quicksilver> no :)
05:38:24 <quicksilver> but it does, in some very loose sense, mean 'unwrap IO'
05:38:31 <quicksilver> it isn't related to String though
05:38:41 <mar77a> what does it do exactly?
05:39:05 <Sizur> x::String <- y::IO String
05:39:07 <quicksilver> do {a <- foo ; bar a }  translates to foo >>= bar
05:39:15 <quicksilver> is what it does 'exactly'
05:39:24 <mar77a> and what's... >>=
05:40:26 <quicksilver> it's the special thing which makes this all work :)
05:40:41 <quicksilver> it says "run the action foo, and then run the action bar, with the result of foo as its parameter"
05:40:59 <Sizur> a combinator of functions that (.) cannot combine. is that somewhat right?
05:41:24 <quicksilver> except it doesn't quite mean 'run', actually it means "create the larger action which, when run, runs foo and then bar, feeding the result of foo to bar"
05:47:04 <Sizur> i always thought why have (>>=) when (.) does the same. at least to me, explanations weren't stressing enough that you cannot simply feed the output into the input because they are different types
05:47:08 <Syzygy-> Sizur: >>= combines a function of type a -> M b with one of type b -> M c to give a function of type a -> M c
05:47:08 <Syzygy-> You can't use . because the types don't match.
05:47:08 <Sizur> exactly
05:47:08 <Syzygy-> The functions aren't composable as such.
05:47:15 <Syzygy-> Oh sorry.
05:47:17 <Syzygy-> I should probably read everything you say before replying. *oops*
05:47:18 <Sizur> heh, i know i dont make sense most of the time. no worries
05:47:18 * Syzygy- finds >>= easier to think about in terms of fmap and bind.
05:47:18 <Syzygy-> So you can take your b -> M c and pipe it through fmap to get M b -> M M c
05:47:18 <Sizur> it's very interesting how different ppl understand monads though different means
05:47:18 <Syzygy-> And then bind takes M M c to M c
05:47:19 <Syzygy-> Sizur: I'm a mathematician, working in homological algebra. What draws me to Haskell is precisely the prevalence of category theory.
05:47:34 <byteshack> is there a contains :: String -> String -> Bool type function somewhere?
05:47:52 <byteshack> ... if so, how can I find it (search for it?)
05:49:34 <Sizur> byteshack: find :: (a -> Bool) -> [a] -> Maybe a -- Data.List
05:50:42 <Lemmih> byteshack: That function isn't in the standard libraries.
05:51:05 <Sizur> contains = f.find where f (Just _) = True; f Nothing = False
05:52:53 <Lemmih> @type \x y -> any (x `isPrefixOf`) (tails y)
05:53:05 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
05:53:13 <Lemmih> Sizur: Not really.
05:54:16 <Sizur> woooopppssss...
05:56:36 <quicksilver> byteshack: isInfixOf
05:56:42 <quicksilver> @index isInfixOf
05:56:42 <lambdabot> bzzt
05:56:44 <quicksilver> hmm
05:56:50 <quicksilver> I'm sure I'm not hallucinating
05:57:12 <quicksilver> :t isInfixOf
05:57:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
05:57:18 <quicksilver> ah yes, there it is!
05:57:23 <ari> @src isInfixOf
05:57:24 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
05:57:34 <Lemmih> Oh my.
05:57:50 <byteshack> quicksilver: sweet
05:58:07 <quicksilver> Lemmih: went in in Aug 2006 according to the changelogs
05:58:15 <byteshack> I tried searching in hoogle for: [a] -> [a] -> Bool
05:58:28 <quicksilver> Lemmih: it's in my 6.6.1
05:58:37 <Lemmih> quicksilver: I'm such an oldie.
05:58:53 <quicksilver> ;)
06:04:07 <exDM69> 8
06:06:17 <Invisible> it would be really nice if hpaste was working... :(
06:07:28 <Invisible> !list
06:07:28 <hpaste>  gwern pasted "odd type error" at http://hpaste.org/4325
06:07:52 <Invisible> ...ok, so I guess it's only me who can't get to it then. :S
06:08:04 <gwern> I haven't quite figured out this error - I've never seen a monad mis-match which gives an error 'when generalising types'
06:08:07 <Invisible> @list
06:08:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
06:09:19 <Invisible> @seen dcoutts
06:09:20 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts last spoke.
06:10:27 <hpaste>  gwern annotated "odd type error" with "error" at http://hpaste.org/4325#a1
06:10:28 <Invisible> I'm having trouble installing HDBC; anybody here likely to be able to help?
06:10:58 <Lemmih> Invisible: Yeah.
06:11:14 <Invisible> Lemmih: ok. well here goes...
06:11:32 <Invisible> I tried to install HDBC from Hackage. Didn't work too well.
06:11:40 <Invisible> Tried getting it with Darcs, that installed fine.
06:11:46 <dcoutts_> Invisible: hello
06:12:01 <Invisible> Tried getting HDBC-ODBC with Darcs... it no likie me. :(
06:12:21 <Invisible> dcoutts_: hiya. onmipresent? ;)
06:12:28 <dcoutts_> @arr!
06:12:28 <lambdabot> Yeh scurvy dog...
06:12:38 <Invisible> lolz @ duncan
06:12:41 <dcoutts_> Invisible: something like that :-)
06:13:25 <Invisible> Cabal sez "Database\HDBC\ODBC\Utils.hsc:134:8: parse error on input `import'"
06:13:54 <Sizur> ok, now only to sell my relational module and retire with the ultra uber-megabucks
06:14:29 <Invisible> anybody have the slightest clue why it's complaining?
06:16:13 <Invisible> ...so, that's a 'no' then? :(
06:19:20 <Invisible> mmm, puzzling.
06:19:40 <Invisible> everyone says that #haskell is the most helpful place ever, yet all I find is people idling...
06:20:02 <gwern> bad time of day
06:20:13 <Invisible> what, *every* time of bad? ;)
06:20:18 <gwern> you usually do get more help in the evening
06:20:25 <Invisible> mmm, ok.
06:20:28 <quicksilver> Invisible: if you had a haskell problem, I'd be helping you
06:20:32 <Sizur> #haskell is da best!
06:20:33 <Invisible> hey, what timezone is everybody in?
06:20:40 <quicksilver> I know nothing about hackage, nothing about darcs, nothing about cabal and nothing about hdbc
06:20:42 <gwern> EST here, so it's morning
06:20:43 <Sizur> of da best!
06:20:49 <quicksilver> so I'm no use for you problem.
06:20:50 <gwern> quicksilver: I had a haskell problem :)
06:21:04 <dcoutts_> Invisible: are you trying to use HDBC with ghc-6.8.x or 6.6 ? It almost certainly does not work yet with 6.8.x.
06:21:12 <quicksilver> gwern: yes, but you didn't tell us what it was...
06:21:18 <quicksilver> gwern: oh, I missed the paste :)
06:21:20 <Invisible> dcoutts_: that'll be the problem then I guess.
06:21:22 <gwern> quicksilver: did too. I even linked to the paste
06:21:40 <Invisible> dcoutts_: OOC, what's changed that breaks it?
06:21:43 <quicksilver> hpaste doesn't seem to like me today much
06:21:53 <Invisible> quicksilver: likewise.
06:22:02 <quicksilver> Invisible: everything has changed.
06:22:03 <quicksilver> :)
06:22:07 <dcoutts_> Invisible: mostly packages being renamed, see http://haskell.org/haskellwiki/Upgrading_packages
06:22:14 <quicksilver> Invisible: in particular, cabal has changed, and so has the entire standard library :)
06:22:42 <Invisible> well, I tried getting HDBC from Hackage, and it wouldn't build
06:22:55 <Invisible> but then I fetched HDBC from Darcs, and it built just fine
06:23:12 <Invisible> now I'm trying to build HDBC-ODBC, and it doesn't like me much
06:23:41 <quicksilver> seems likely that hdbc has been updated but not odbc, then
06:23:50 <quicksilver> gwern: I can't access your hpaste.
06:24:03 <Invisible> so it would seem...
06:24:20 <Invisible> first I got an error about main is Setup.hs having the wrong inferred type (!!)
06:24:35 <gwern> quicksilver: http://hpaste.org/4325 isn't working?
06:24:47 <Invisible> and now I get a parse error on an apparently ordinary line in Utils.hsc
06:25:21 <Invisible> gwern: I don't know why, but I can't get at hpaste.org today...
06:25:34 <quicksilver> like Invisible, I haven't been able to access hpaste all day
06:25:51 <gwern> strange. it worked fine for me, I haven't noticed anything
06:26:02 <Invisible> it's weird tho - I can get some metadata about the page, just not the page contents.
06:26:17 <Invisible> like, it gets the page title, charset, MIME type, etc...
06:27:27 <Invisible> dcoutts_: assuming I ever get it to work, is HDBC actually the package to go for?
06:27:35 <dcoutts_> Invisible: yep
06:27:37 <Invisible> (rather than one of the three-dozen other DB packages...)
06:27:47 <Invisible> dcoutts_: ok, thought so.
06:28:23 <Invisible> I want to write your typical "I talk to a database and present an HTML frontend" type app in Haskell
06:28:52 <Sizur> Invisible: do you need an external db?
06:29:18 <Invisible> Sizur: quite likely, yes.
06:30:01 <Sizur> Invisible: I see you! (sorry couldn't resist)
06:30:20 <Invisible> Sizur: damn! don't tell anybody I'm here. (not supposed to be...)
06:31:03 <Invisible> I only came to see if I could get HDBC working...
06:31:35 <Invisible> does anybody know who maintains it?
06:31:42 * Invisible examines license file
06:32:49 <Sizur> the new ghc release broke a lot of things. but that's good: as soon as haskell will stop evolving, it will stop evolving. lol
06:33:00 <gwern> no pain, no gain...
06:33:14 <Sizur> hey, i think i need to tell that to my wife
06:33:23 <Invisible> ...?
06:33:56 <Sizur> just thinking out loud
06:34:01 <Invisible> oh, ok.
06:34:06 <manu3000> Invisible : maybe
06:34:21 <gwern> now hpaste is hanging on me
06:34:22 <manu3000> Invisible: what's yout platform ?
06:34:28 <Invisible> damn, I wish I had a wife...
06:34:48 <Invisible> manu3000: GHC 6.8.1, Windows XP
06:35:10 <manu3000> Invisible: ok, what's your problem ?
06:35:31 <Invisible> manu3000: I can't get HDBC-ODBC to work...
06:35:59 <gwern> excellent, it now compiles - well except for the all important definition I defined as undefined :(
06:36:00 <manu3000> Invisible: does it compile ?
06:36:20 <Invisible> manu3000: no. parser error in one of the source files. (!!)
06:36:43 <gwern> sounds like a CPP error
06:36:49 <Invisible> mayhap.
06:37:11 <gwern> I've had to open up files and manually execute the ifdefs and so on to get things to compile
06:37:24 <Invisible> heh. scary :S
06:37:33 <gwern> not really. pretty simple conditionals
06:37:49 <gwern> 'ifdef MINGW'? well, no, I'm not on Windoes *deletes*
06:38:03 <Invisible> menu3000: initially Setup.hs wouldn't run due to the wrong type being inferred for main (Cabal API changes?)
06:38:13 <Invisible> :| menu?
06:38:27 <gwern> manu
06:38:30 <manu3000> Invisible : I never installed the ODBC stuff. What is the parsing error ?
06:38:36 <gwern> (as in, the deity)
06:38:37 <Invisible> Database\HDBC\ODBC\Utils.hsc:134:8: parse error on input `import'
06:39:35 <Lemmih> Invisible: You probably need to add ForeignFunctionInterface to Extensions in the cabal file.
06:39:48 <manu3000> Invisible : is that ligne a foreign function import ?
06:39:57 <Invisible> manu3000: indeed yes.
06:40:23 <manu3000> Invisible :  in that case you need to add ForeignFunctionInterface to the extensions in the Cabal file
06:40:51 <manu3000> Invisible : and move on to the next error ;)
06:41:38 <Invisible> Database\HDBC\ODBC\Utils.hsc:56:18: Illegal signature in pattern: Ptr ()    Use -XPatternSignatures to permit it
06:42:13 <Invisible> good news: Lemmih was right.
06:42:16 <Lemmih> Invisible: Add PatternSignatures to the extensions.
06:42:19 <Invisible> bad news: manu was right too
06:42:39 <Lemmih> (or downgrade to ghc-6.6.1)
06:43:25 <ricky_clarkson> If you take part of a list and never use the rest again, can the rest be GC'd?
06:43:29 <ricky_clarkson> take or drop.
06:43:52 <Invisible> Lemmih: now Cabal is giving me a parse error for that field :S
06:43:58 <Saizan> ricky_clarkson: if you lose the reference to it
06:44:11 <Saizan> Invisible: try with ghc-options: -fglasgow-exts
06:44:12 <manu3000> Invisible : yeah
06:44:34 <manu3000> Invisible : add a lanuage pragma at the top of the file where the error happens
06:44:41 <ricky_clarkson> Saizan: So does the new part of the list not need a ref to the old?
06:44:55 <manu3000> Invisible: {-# LANGUAGE PatternSignatures #-}
06:45:33 <manu3000> PatternSignatures : for some reason, adding this one to the Cabal file causes a parse error
06:46:01 <Invisible> manu3000: known bug?
06:46:03 <Saizan> ricky_clarkson: well, when take is evaluated till it adds the new [] at the end of the elements taken
06:46:26 <manu3000> Invisible : yeah, there's a cabam patch by dcoutts
06:46:42 <Invisible> manu3000: kk
06:46:55 <ricky_clarkson> Saizan: While the new part is unevaluated, a ref to the old list is needed?
06:46:57 <dcoutts_> not all the language extensions were in the cabal that comes with 6.8.1, they're all in for 6.8.2
06:47:06 <Invisible> I just added -fglasgow-exts to GHC-Options...
06:47:15 <Invisible> OMG, IT COMPILES! o_O
06:47:17 * Invisible dies
06:47:38 <Sizur> ok, nothing happened, move on everybody
06:47:46 <manu3000> Invisible : you see, everything happens :)
06:47:47 <Saizan> ricky_clarkson: yes, how would you consume the elements you need otherwise?
06:47:50 * Invisible comes back to life
06:48:07 <ricky_clarkson> Saizan: Sure.  I was just checking my assumptions.
06:49:05 <Saizan> ricky_clarkson: but, the rest of the list might not even be there yet :)
06:49:06 <Invisible> OK, I now have HDBC and HDBC-ODBC installed. I wonder if they work...
06:49:25 <ricky_clarkson> Saizan: That's fine.
06:50:03 <Invisible> also, I wonder how you configure an ODBC data source? :|
06:50:39 <Sizur> Invisible: you do that in your control panel on windows maybe?
06:51:05 <Invisible> Sizur: yeah, I'm vaguely aware of it - it's just not something I've ever looked at in detail before.
06:51:10 <Invisible> oh well, time to start learning! :-}
06:51:41 <Sizur> i'd be using my megabucks pure relational module that i wrote today!!
06:52:02 <Invisible> Sizur: heh, nice. I bet that took a while?
06:52:19 <Sizur> i think thought of it two days ago
06:52:41 <gwern> dammit, I hate when things compile but don't work. anyone here familiar with Shellac?
06:52:45 <Invisible> yeah, I've been thinking about a toy db implementation in pure Haskell.
06:52:58 <Sizur> Invisible: it's just a proof of concept, nothing to be used in production, God forbid!
06:53:19 <Invisible> Sizur: indeed. for THIS project, I need a production-grade db.
06:53:27 <Invisible> I'll probably use Oracle.
06:53:46 <Sizur> if you have the bucks for it
06:53:57 <Invisible> it's for a work project. we already have Oracle.
06:54:48 <Invisible> hopefully Oracle will work with ODBC - but I can test it with good old M$ Access for now ;-)
06:55:06 <Invisible> anyway, I'd better go get on with it... :|
06:55:17 * Invisible leaves
06:57:01 * gwern sighs. I think I'll give this shellac thing another shot later, when hpaste is up and I've had breakfast
06:57:41 <Sizur> @users
06:57:42 <lambdabot> Maximum users seen in #haskell: 401, currently: 375 (93.5%), active: 10 (2.7%)
07:01:04 <manu3000> Invisible : Takusen work with Oracle I think, but dosn't compile with 6.8.1
07:22:58 <byorgey> greetings, #haskell!
07:23:05 <Nafai> Hi byorgey!
07:23:19 * byorgey distributes peppermint-flavored lambdas
07:23:22 <byorgey> hi Nafai!
07:24:05 <Nafai> Get my privmsg from last evening?
07:25:06 <byorgey> um, no, I don't think I did
07:29:16 <Nafai> hpaste seems down
07:29:29 <Nafai> Or I would show you what I have for #59
07:29:36 <Nafai> I got it working, but its too slow
07:30:13 <byorgey> hmm, indeed
07:31:15 <byorgey> you could use a different paste site?
07:31:22 <Nafai> Yeah
07:31:24 <Nafai> Just a second
07:31:25 <byorgey> e.g. paste.lisp.org or pastebin.com
07:32:59 <Nafai> http://pastebin.com/m184bcc90 <- So it gets the possible strings and their word counts quickly, but my means of determining which one is "right" is too slow
07:35:18 <Nafai> It took all night (well from the time I got home from work until I went to bed) to come up with that
07:35:22 <Nafai> But I feel it's rather ugly :/
07:35:55 <byorgey> heh
07:36:00 <byorgey> well, you have to start somewhere =)
07:36:22 <Nafai> Yes
07:39:46 <byorgey> Nafai: well, I don't see any obvious ways to speed it up
07:40:15 <byorgey> Nafai: it occurs to me that you could use a Data.Set instead of Data.Map to store the dictionary words
07:41:07 <byorgey> it wouldn't do anything to the speed, but since you're not actually storing any information associated with each word, only the fact that it exists
07:42:01 <byorgey> Nafai: you could also lowercase everything from the get-go, instead of lowercasing each word every time you look it up in the dictionary
07:42:14 <Nafai> byorgey: Well, the slowdown is in the sorting of the possible strings
07:42:31 <Nafai> byorgey: I added in a debug print in the process and it almost immediately returns the possible strings and their counts
07:42:41 <byorgey> oh, interesting
07:43:07 <Nafai> byorgey: So I was trying to add some filtering to not return anything if the count for that particular string was below some threshold
07:44:16 <byorgey> hm, I would have thought the call to maximumBy would be pretty fast
07:45:02 <Nafai> Yeah, interestingly, that's the slow part
07:46:11 * byorgey downloads the code to play with
07:47:56 <Nafai> If you want to run it, you'll also need this file: http://pastebin.com/d4834ff7c
07:48:05 <Nafai> I really need to get my hg repo on the web
07:49:09 <byorgey> Nafai: btw, instead of   x <- return $ foo, you can just say  let x = foo
07:50:29 <Nafai> Oh, nice
07:51:38 <byorgey> Nafai: hmm, I'm not convinced that the maximumBy is actually the slow part.
07:51:56 <byorgey> adding debugging print statements can be deceiving, because of laziness
07:52:21 <Nafai> Didn't think of that
07:52:28 <byorgey> i.e. just because it gets to a particular debugging print statement doesn't necessarily mean it's actually done all the computation preceding it.
07:52:36 <byorgey> it might have just been put off since it wasn't actually needed yet.
07:53:01 * EvilTerran is reminded of the suggestion of trying to control a robot arm through unsafePerformIO / trace / whatever to show the hazards of making assumptions about order of evaluation in haskell
07:54:29 <byorgey> Nafai: if you want to see what's taking the most time, you should do some profiling.
07:54:45 <Nafai> How do I do that?
07:55:18 <byorgey> first, compile with -prof -auto-all, then run it with... hang on, I need to go look it up
07:55:27 <Saizan> +RTS -p
07:56:06 <Nafai> Thanks
07:56:07 * Nafai tries
07:56:22 <quicksilver> EvilTerran: the danger is that an article about that would be misinterpreted into "Why haskell sucks!" :)
07:56:38 <EvilTerran> meh
07:57:23 <EvilTerran> more like "why haskell is incompatible with your attempts to micromanage the running of your program. this isn't C, ferchrissakes."
07:57:28 <byorgey> ah, thanks Saizan =)
07:58:16 <quicksilver> EvilTerran: right. I appreciate that.
07:58:26 <quicksilver> EvilTerran: just pointing out a danger of being misunderstood :)
07:58:45 <EvilTerran> yeah, people do tend to assume it's the tools that suck, not their attempts to use 'em
07:59:40 <ricky_clarkson> :t zipWith
07:59:41 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:59:55 <quicksilver> EvilTerran: which is (roughly) why I dislike the prevalence of unsafely lazy IO in the default haskell libraries.
08:00:07 <quicksilver> EvilTerran: I think it gives a poor impression to people trying to learn the language and undermines our message.
08:00:15 <EvilTerran> mmhmm
08:00:21 <quicksilver> people will blame haskell for the woes of readFile
08:00:27 <ricky_clarkson> > zipWith (+) [1..5] [10..14]
08:00:28 <quicksilver> quite understandably, since it's in the standard lib
08:00:28 <lambdabot>  [11,13,15,17,19]
08:00:44 <osfameron> the library *is* the language :-)
08:00:56 <ricky_clarkson> > let ones=1:ones in let integers=1:zipWith (+) integers ones in integers
08:00:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:02:00 <ricky_clarkson> Is that dreadfully inefficient?
08:02:06 <byorgey> Nafai: how long does your program take to run?
08:02:16 <byorgey> ricky_clarkson: not at all.
08:02:36 <Toxaris> Nafai: you could try a manual foldl' instead of maximumBy
08:04:24 <Nafai> byorgey: Well, it took 3 minutes on my dual core duo 2 laptop at home
08:04:44 <Nafai> byorgey: With profiling turned on, it takes much longer than that on my work machine (still running)
08:04:49 <byorgey> ok, it just finished... I was just wondering how long I should expect to wait for it
08:05:04 <ricky_clarkson> > let fibs=0:1:zipWith (+) fibs (tail fibs) in fibs
08:05:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:08:34 <byorgey> Nafai: it seems most of the time is taken in lookupWord.  So maybe using a real hash table instead of a Map or Set would actually be a big speedup.
08:08:58 <Nafai> http://pastebin.com/d1ab0effa <- interesting
08:09:26 <pitecus_> Map.fold (+) is too lazy right?
08:10:24 <Nafai> What does CAF in the profile report mean?
08:10:29 <byorgey> Nafai: yeah, that's a lot of calls to lookupWord!
08:11:49 <quicksilver> Nafai: how big is your dictionary, roughly?
08:12:02 <quicksilver> Nafai: how many words, what's the approx. average word length?
08:12:41 <byorgey> Nafai: CAF stands for Constant Applicative Form -- basically, something which isn't a lambda abstraction
08:12:52 <Nafai> quicksilver: I cut down my dictionary to about 28k words, IIRC, each word is 3-7 characters long
08:13:14 <quicksilver> Nafai: hmm. I suspect it might be String that's killing you.
08:13:47 <quicksilver> Nafai: a 7 character string takes up 7x16 = 112 bytes
08:14:05 <quicksilver> Nafai: you might try re-writing to Map Bytestring Bytestring
08:14:08 <byorgey> hmm, interesting, I hadn't thought of that
08:14:21 <quicksilver> Nafai: Bytestring's Ord instance is quite a lot faster than Strings
08:14:33 <byorgey> 16 bytes per character, really!?  wow.
08:14:34 <dcoutts_> though ByteString is not ideal for short strings
08:14:35 <quicksilver> it is, more or less, a C strcmp()
08:14:48 <dcoutts_> byorgey: no, only 12 on 32bit
08:14:56 <quicksilver> dcoutts_: but ByteString < should be faster than String < taking data locality into account, I think?
08:14:56 <kalven> wow, only 12
08:15:05 <byorgey> 12 is still a lot =)
08:15:11 <quicksilver> dcoutts_: and that might speed up the Map quite a lot.
08:15:26 <allbery_b> and a couple indirections for each character
08:15:46 <allbery_b> (one for the cons cell, one for the Char constructir, IIRC)
08:16:25 <quicksilver> one for the car and one for the cdr, indeed
08:16:41 <quicksilver> but String is special-cased, otherwise it would be three
08:16:42 <quicksilver> I think?
08:16:51 <dcoutts_> Char is special cased a bit
08:17:01 <dcoutts_> in that the first 255 Chars are statically allocated
08:17:19 <dcoutts_> so all 'a' Chars point to the same memory object
08:17:21 <quicksilver> dcoutts_: in fact, couldn't he read his entire dictionary into a huge great strict Bytestring
08:17:31 <quicksilver> dcoutts_: and then have a zero-copy Map Bytestring?
08:17:42 <Nafai> Nice, I have a whole channel optimizing my code! :)
08:17:45 <quicksilver> dcoutts_: where all the keys were actually just pointers into the single bytestring?
08:18:01 <dcoutts_> quicksilver: it's still 5*4 (or 8) bytes overhead per word
08:18:22 <quicksilver> dcoutts_: yes, but that's much better than (wordlen)*12
08:18:27 <dcoutts_> true
08:18:29 <quicksilver> dcoutts_: and we've also gained a lot of data locality
08:18:35 <dcoutts_> yep
08:18:37 <quicksilver> dcoutts_: the whole body of the dictionary is in one place
08:18:42 <ski> anyone mentioned <http://www.jobs-in-fp.org/> yet ?
08:19:26 <Nafai> byorgey: I'm glad you had me profile.  I was trying to optimize the wrong thing last night
08:19:26 <quicksilver> my /usr/share/dict/words on this machine is 2.4M which might just be cacheable on a high-end box
08:19:40 <quicksilver> dcoutts_: is "lines" zero-copy?
08:19:52 <dcoutts_> quicksilver: yep
08:19:56 <byorgey> Nafai: yeah, profiling is pretty crucial, otherwise it's very difficult to know what's really going on.
08:19:59 <quicksilver> Nafai: are you following me here?
08:20:08 <quicksilver> Nafai: if you read in /usr/share/dict/words as a strict bytestring
08:20:13 <dmead> ?seen dmead
08:20:13 <lambdabot> You are in #haskell. I last heard you speak just now.
08:20:18 <dmead> ?seen dbueno
08:20:18 <lambdabot> I haven't seen dbueno.
08:20:27 <quicksilver> Nafai: then it's only in memory once. All the references to the words are pointers into the copy of the file
08:20:40 <quicksilver> Nafai: so you waste less space with spreading the keys out all over the place
08:20:54 <quicksilver> Nafai: add that to Bytestring.< being faster than String.<
08:21:01 <matthew-_> dmead: you are in #haskell. In front of you is a keyboard and a screen. There are around 400 people in the room.
08:21:01 <quicksilver> and I think it could help you quite a bit
08:21:29 <dmead> :P
08:21:30 <Nafai> quicksilver: Sounds like it.  I'll have to give that a try.
08:21:35 <Nafai> When I'm not at work :(
08:21:39 <quicksilver> Nafai: :)
08:33:32 <ricky_clarkson> Before people knew about monads, did they think about just enforcing a 2-layer system, where the inner is pure and the outer, possibly considered a different language, allows assignments, etc., and isn't lazy?
08:34:02 <quicksilver> I'm sure lots of people thought about that
08:34:11 <quicksilver> certainly many people programmed like that
08:34:15 <quicksilver> that's how I used to program in ocaml
08:34:36 <ricky_clarkson> ..with lots of 'delay'?
08:35:04 <byorgey> @hoogle String -> ByteString
08:35:05 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
08:35:21 <engb> is hpaste down?
08:38:18 <byorgey> @hoogle Word8 -> Char
08:38:19 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
08:39:18 <dcoutts_> don't use that
08:39:45 <dcoutts_> @type fromEnum 45 :: Char
08:39:46 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
08:39:47 <lambdabot>     In the expression: fromEnum 45
08:39:56 <dcoutts_> > (fromEnum 45) :: Char
08:39:57 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
08:39:58 <desegnis> What's a good way to quick-and-dirtily time the computation of a long list in ghci? I'm currently doing foldr seq (), but this makes the whole list remain in memory.
08:40:08 <dcoutts_> > (toEnum 45) :: Char
08:40:10 <lambdabot>  '-'
08:40:31 <dcoutts_> desegnis: last?
08:40:45 <dcoutts_> perhaps length too
08:40:54 <dcoutts_> just don't hold onto the head of the list as well
08:41:16 <desegnis> D'oh. Thanks, dcoutts_, trying out.
08:41:35 <byorgey> dcoutts_: ok, good, that's what I had come up with too =)
08:41:44 <ToRA> length . show?
08:41:50 <byorgey> dcoutts_: hmm, is there a version of lines that works on ByteStrings?
08:42:16 <byorgey> @hoogle ByteString -> [ByteString]
08:42:17 <lambdabot> Data.ByteString.group :: ByteString -> [ByteString]
08:42:17 <lambdabot> Data.ByteString.inits :: ByteString -> [ByteString]
08:42:17 <lambdabot> Data.ByteString.tails :: ByteString -> [ByteString]
08:42:53 * osfameron is having trouble with Text.Printf - http://pastebin.com/d66798dfa
08:42:59 <Toxaris> @hoogle lines
08:42:59 <lambdabot> Prelude.lines :: String -> [String]
08:42:59 <lambdabot> Data.List.lines :: String -> [String]
08:42:59 <lambdabot> Data.ByteString.Char8.lines :: ByteString -> [ByteString]
08:42:59 <dcoutts_> byorgey: yes, Data.ByteString.Char8.lines surprisingly :-)
08:43:13 <byorgey> oh, I see, I wasn't looking in .Char8
08:43:15 <byorgey> thanks
08:43:43 <dcoutts_> byorgey: since lines is not a binary thing, it depends on the ascii encoding of '\n'
08:44:22 <byorgey> dcoutts_: ah, that makes sense.
08:44:25 <desegnis> dcoutts_: I realize now that  length  won't calculate the cells contents, while  last  will not garbage-collect in ghci.
08:44:41 <desegnis> At least that's what I suspect.
08:44:59 <dcoutts_> desegnis: right, though I'm not sure why last would not work in ghci
08:45:40 <quicksilver> desegnis: foldr seq will not make the whole list remain in memory
08:45:44 <dcoutts_> desegnis: you certainly cannot bind the list at the top level with let as that'll hold it 'til then end of the ghci session since it'll still be in scope
08:45:46 <quicksilver> desegnis: not by itself
08:45:57 <quicksilver> desegnis: if the list remains in memory you have some other reference to it :)
08:46:06 <quicksilver> foldr seq ought to be fine...
08:46:14 <osfameron> ah.  I need to declare the type of f2c as -> Float, otherwise it gets confused and doesn't know how to print a Fractional
08:46:18 <dons> ?users
08:46:18 <lambdabot> Maximum users seen in #haskell: 401, currently: 383 (95.5%), active: 17 (4.4%)
08:46:23 <quicksilver> assuming WHNF of each element is enough
08:46:26 <dcoutts_> d'morning dons
08:46:31 <dcoutts_> @localtime dons
08:46:32 <lambdabot> Local time for dons is Fri Dec  7 08:46:30 2007
08:46:44 <dcoutts_> ech, a bit early :-)
08:46:57 <dcoutts_> dons: btw, mid April sounds ok to me too
08:48:01 <desegnis> quicksilver: Is ghci's  it  a good candidate for some other reference?
08:48:23 <desegnis> Wait, it cannot be.
08:49:46 <ricky_clarkson> quicksilver: In ocaml, did you use 'delay' a lot, or whatever ocaml's equivalent is?
08:50:20 <quicksilver> ricky_clarkson: no, I didn't really do lazy stuff
08:50:31 <quicksilver> desegnis: I'm not sure...
08:50:43 <ricky_clarkson> quicksilver: Fair enough.
08:52:22 <quicksilver> desegnis: I wouldn't have thought ghci would retain references to old 'its'
08:52:31 <quicksilver> desegnis: I'm sure it retains references to things you let-bind though :)
08:52:34 <quicksilver> but, I'm not sure
08:53:18 <desegnis> quicksilver, dcoutts_: Now this is funny. The scenario is fibs :: [Integer], which will fill my memory if evaluated in ghci. However, fibs :: [Int] seems to fuse away. I would have thought that [Integer] means more used memory and more work than [Int], but not to this extent.
08:53:59 <dcoutts_> desegnis: this is all interpreted in ghci, no compiling?
08:54:21 <desegnis> dcoutts_: Right. If I compile, there's no difference: I get instant answers in both cases.
08:54:26 <Lemmih> desegnis: Int overruns. Integer keeps doing more and more complicated calculations.
08:54:56 <dcoutts_> desegnis: there is no fusion going on unless you compile with -O
08:55:21 <ricky_clarkson> I was searching reddit for one of dons' comments.. searching for dons matches anything with "don't" in it.
08:56:02 <desegnis> Lemmih: Right, but there is no problem with Integer in my case. If I compile, it's fine.
08:56:14 <desegnis> dcoutts_: Then there's something fooling me.
08:57:24 <Lemmih> desegnis: I'm not sure what's going on. I just saw 'fib' and 'last', and said the first thing that came to mind.
08:59:06 <desegnis> Lemmih: Right. I am only computing a rather small prefix of fibs, i.e. fibs !! (10^5). So there is no overflow involved, and  Integer  is efficient enough.
09:00:26 <desegnis> Er, there is indeed an overflow involved, I think, but it does not matter here for efficiency at least.
09:00:43 <desegnis> (please pardon confusing wording)
09:00:56 <dcoutts_> desegnis: when Integer overflows an Int it gets a lot slower
09:01:35 <dcoutts_> since it has to start using gmp bignum functions rather than primitive machine operations
09:01:59 <ricky_clarkson> Is Integer as fast as Int below that?
09:02:27 <ricky_clarkson> ..I suppose it can't be because you've got to watch for overflow.
09:03:28 <quicksilver> below that it's not too bad
09:03:33 <quicksilver> just takes up a bit more memory
09:03:42 <quicksilver> the actual arithmetic ops generated are not a disaster
09:03:59 <quicksilver> but there are a few more indirections hanging around
09:04:02 <dons> you still have to check the tag though
09:04:05 <quicksilver> (as is so often the case :)
09:04:59 <desegnis> (fibs !! (10^5)) :: Integer is around 3 seconds if compiled, no matter how I compile. So I'm not being bitten by big numbers arithmancy. Still, if interpreted, my memory gets eaten.
09:06:03 <dons> 3 seconds seems slow. hmm
09:07:02 <dons> just a linear, or a logarithmic immpl?
09:07:17 <desegnis> The usual zipWith thing.
09:07:19 <dons> > (fix ((0:) . scanl (+) 1)) !! (10^4)
09:07:22 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
09:07:24 <dons> > (fix ((0:) . scanl (+) 1)) !! (10^5)
09:07:26 <lambdabot> Terminated
09:07:34 <dons> ok.
09:07:57 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! (10^5)
09:07:59 <lambdabot> Terminated
09:08:10 <doserj> the usual zipWith takes 3 seconds interpreted here
09:08:20 <doserj> (maybe 4)
09:09:15 <Nafai> byorgey: So I kept getting tripped up last night because of that pesky IO.  "Wait, I just want a String, not an IO String!"
09:10:24 <desegnis> Alright, so I tried dons' last line - and it worked, just as doserj confirms. But if I define fibs at top-level, then it won't.
09:10:55 <desegnis> (top-level = in a file)
09:12:41 <doserj> desegnis: true, that uses much more memory here too (around 600MB)
09:13:04 <ricky_clarkson> :t (!!)
09:13:06 <lambdabot> forall a. [a] -> Int -> a
09:13:13 <ricky_clarkson> [1,2,3] !! 1
09:13:17 <ricky_clarkson> > [1,2,3] !! 1
09:13:19 <lambdabot>  2
09:13:33 <ricky_clarkson> Why !!?  Seems a strange name.  Anything from maths explain it?
09:13:44 <doserj> desegnis: but subsequent computations are faster :)
09:14:51 <desegnis> doserj: Since I don't have as many as 600 MB of memory, I cannot enjoy the effect.
09:14:53 <sioraiocht> ricky_clarkson: do you have a BETTER one? =p
09:15:33 <ricky_clarkson> Bah, just make [1,2,3] a function Int -> a ;)
09:15:44 <ricky_clarkson> [1,2,3] 2 gives 3
09:16:12 <sioraiocht> yes
09:16:19 <sioraiocht> > [1,2,3] !! 0
09:16:20 <lambdabot>  1
09:16:22 <byorgey> Nafai: yeah, I noticed that a few of your functions in particular really shouldn't involve IO.
09:16:49 <sioraiocht> @src (!!)
09:16:49 <lambdabot> xs     !! n | n < 0 = undefined
09:16:49 <lambdabot> []     !! _         = undefined
09:16:49 <lambdabot> (x:_)  !! 0         = x
09:16:49 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:17:05 <ricky_clarkson> (1 to 10)(2) gives 3 in Scala.
09:17:08 <byorgey> Nafai: a couple of your functions don't actually do any IO, you just use a do block with returns everywhere for no good reason =)
09:17:14 <desegnis> ricky_clarkson: They use (!) for arrays and probably wanted something different for lists.
09:17:25 <doserj> desegnis: but you understand what happens? when you declare a value top-level then ghc will not throw the computed result away after it has evaluated it once. it just replaces the (unevaluated) thunk with the value. In your case, the value is unfortunately a very large list...
09:17:30 <sioraiocht> ricky_clarkson: when have you run across scala?
09:17:30 <ricky_clarkson> desegnis: Fair enough.
09:17:44 <ricky_clarkson> sioraiocht: For about 2.5 months.
09:17:53 <ricky_clarkson> Why?
09:17:59 <sioraiocht> ricky_clarkson: was it for a class or something?
09:18:04 <ricky_clarkson> No.
09:18:20 <sioraiocht> hrm.  Distributed and Concurrent Programming is taught in scala here
09:18:23 <sioraiocht> looked kinda evil to me
09:18:23 <desegnis> doserj: Thanks, so this is by design really; that's fine with me.
09:18:50 <ricky_clarkson> sioraiocht: If you know Java and Haskell it's kinda a half-cousin of each.  It's ok.
09:18:56 <doserj> desegnis: you can work around it by declaring fibs as a function, of course
09:19:07 <sioraiocht> ricky_clarkson: sounds horrid, though.
09:19:43 <ricky_clarkson> *shrug*.  I'm not promoting it, I don't have responses to emotive criticism.
09:20:32 <sioraiocht> ricky_clarkson: i'm not criticising , just giving initial impressions, i haven't actually used it
09:20:34 <doserj> desegnis: more or less by design :) if you think about it, 600MB for an infinitely long list is still quite good:)
09:20:44 <sioraiocht> unlike OCaML, which I really DO hate
09:20:58 * dcoutts_ too
09:21:20 <ricky_clarkson> I don't hate any languages, I just pity their users.
09:21:31 <desegnis> doserj, true ;)
09:21:33 <pejo> sioraiocht, hate is a strong word.
09:21:56 <sioraiocht> dcoutts understands me...he was just a demonstrator for me
09:22:01 <dcoutts_> :-)
09:22:11 <dcoutts_> it's painful to use occasionally
09:22:22 <dcoutts_> it might be ok if it was what one was familiar with
09:22:36 <sioraiocht> in which case i would pity them..
09:22:44 <quicksilver> hate is a strong word, but there are programming situations I would apply it to
09:22:59 <osfameron> I hate some legacy perl that I had to maintain
09:23:01 <quicksilver> I hate "enterprise" java with it's incredibly verbose method and class names
09:23:17 <quicksilver> ReallyBigObjectWhichCanMakeObjectsOfSomeOtherTypeFactoryMaker()
09:23:30 <desegnis> doserj: Making it a function is a bit too painful a workaround, since I have to edit the source file. Then I could just as well compile a Main module.
09:23:33 <Nafai> byorgey: Any particular cases I used unncessarily?
09:23:42 <ricky_clarkson> quicksilver: So do its programmers.  There's a movement against that.
09:23:43 <dcoutts_> quicksilver: but that just shows you're a serious enterprise software engineer ;-)
09:23:49 <quicksilver> and XML configuration files which require about 1000 characters of typing per config setting.
09:24:26 <dons> i don't think you're supposed to write xml by hand, are you?
09:24:27 <dcoutts_> it's enterprise, it's supposed to be hard
09:24:29 <dons> ever.
09:24:44 <dcoutts_> how else do they keep people employed?
09:24:48 <Nafai> dons: I wish!  I've been writing XML by hand in Emacs just this morning!
09:24:53 <quicksilver> dons: maybe not. But personally I want config files which can be read + written by hand if necessary, even if that's not the usual case.
09:25:07 <ricky_clarkson> s-expressions!
09:25:12 <dcoutts_> dons: see docbook :-)
09:25:18 <sioraiocht> I know grad students that have been made to annotate computational linguistics corpora in XML by hand...
09:25:21 <quicksilver> dons: I also want config files which are manipulatable by small reusable tools like grep, awk, and ...
09:25:37 <dcoutts_> quicksilver: and ... xsltproc? :-)
09:25:49 <dylan>  ... is not a small tool
09:25:59 <osfameron> it should be possible to have handy toold to process xml streams
09:26:21 <dcoutts_> xml tends not to come in streams, more like blobs
09:26:29 <byorgey> Nafai: numberOfWords in particular doesn't involve any IO
09:27:07 <dons> dcoutts_: docbook boo
09:27:13 <quicksilver> dcoutts_: I have used xmlstarlet on occasion ofr this kind of thing
09:27:22 <quicksilver> dcoutts_: and throwaway tagsoup scripts
09:27:27 <quicksilver> ndm++ # tagsoup
09:27:31 <dons> yeah, tagsoup rocks
09:27:39 <dons> its sometimes exactly the amount of structure you need
09:27:49 <dons> we should really release the galois xml lib soon too.
09:27:55 <dons> its similarly small and useful
09:28:06 <dcoutts_> dons: what's good about that compared to the other N xml libs?
09:28:11 <quicksilver> xmlstarlet is pretty neat, as long as you're prepared to learn a bit of XPath
09:28:16 <byorgey> Nafai: most of the processing in getDictionary and getDictionaryWords doesn't really involve IO either.  If I were you I'd pull out all the processing into a pure function, and just have the actual reading of the file in a function with IO.
09:28:22 <dons> its tiny
09:28:39 <byorgey> Nafai: in general, it's really helpful to have as little as possible in IO, and then use pure functions to do the actual processing
09:28:46 <byorgey> helps with debugging, for one thing
09:28:46 * Nafai nods
09:28:54 <dons> dcoutts_: but what we need is a full bytestring network/http/xml stack
09:28:59 <dcoutts_> dons: I've used haxml in the past, but only ever for the xml parsing and adt, I could never understand the query/processing functions
09:29:05 <Nafai> Yeah, it was frustrating because I wouldn't actually use these functions from ghci
09:29:07 <dcoutts_> dons: yes, and unicode bytestrings
09:29:15 <dons> right
09:29:25 <byorgey> Nafai: exactly.
09:30:33 <Nafai> byorgey: allAlpha is another hairy function that I think could use some improvement
09:31:22 <byorgey> Nafai: you also sometimes tend to (IMO) do too much in a single function.  breaking things out into smaller pieces helps with testing & debugging too.
09:31:42 <byorgey> and sometimes it helps make it easier to see how to simplify/generalize your code.
09:31:56 <byorgey> allAlpha, from your previous approach?
09:32:06 <quicksilver> until eventually you discover the entire program is a one-liner using standard library higher-order functions.
09:32:09 <dylan> Nafai: where's this code again?
09:32:48 <Nafai> byorgey: Er, I meant getDictionaryWords...I was looking at the old code
09:33:16 <Nafai> dylan: http://pastebin.com/m184bcc90
09:33:41 <Nafai> byorgey: I think because Haskell code is so "dense" in comparison to Java and such, I don't have a good sense of "scale"
09:33:47 <Nafai> I don't know if that makes any sense
09:33:53 <byorgey> Nafai: yeah, that makes sense.
09:33:59 <quicksilver> it makes very good sense
09:34:11 <quicksilver> also the line between 'clear' and 'obfuscated' is not objective
09:34:13 <byorgey> in Java, a "small" method is like 5-10 lines or so
09:34:21 <byorgey> in Haskell, a "small" function is 1 or 2 lines
09:34:32 <quicksilver> one reader might think that a neat way of using 'ap' in the (->) monad is very clear and rather elegant
09:34:38 <quicksilver> a second reader might find it totally obfuscating
09:34:50 <dylan> Nafai: ah, so my comment about all isAlpha wouldn't have been valid.
09:36:43 <byorgey> Nafai: a cleaner version of getDictionaryWords might be something like do { contents <- readFile "..." ; return $ filter isWantedWord (lines contents) }
09:37:09 <byorgey> and then I would break out isWantedWord etc. as separate top-level functions, for easier testing
09:37:25 <quicksilver> otherwise written as filter isWantedWord . lines <$> readFile "..."
09:37:31 <quicksilver> if I'm not mistaken
09:37:36 <Toxaris> in a   readFile => process => printResult   kind of program, you shouldn't have any IO functions beside main IMO
09:38:01 <desegnis> quicksilver was faster than me on that comment.
09:38:17 <byorgey> quicksilver: true.
09:38:38 <byorgey> I think that's more a matter of taste/style though.
09:39:49 <desegnis> Nafai: As Toxaris suggests, you could have all readFiles within main. (Just as you already have all prints in main.)
09:41:03 <quicksilver> byorgey: it is. But there is a key tenet here:
09:41:12 <quicksilver> byorgey: Don't name something you only use once.
09:41:25 <quicksilver> byorgey: Unless you believe that, by naming it, you are providing valuable documentation.
09:41:44 <byorgey> quicksilver: indeed, that's an excellent point.
09:41:53 <quicksilver> the key purpose of naming is to allow a value to be used multiple times, in my personal belief.
09:42:43 <byorgey> I was just about to say something to Nafai about naming intermediate results vs. a "pipeline" sort of idiom where you just string together a lot of functions.
09:42:57 <byorgey> but that's a good explanation as to *why* that's a good idiom.
09:43:15 <dcoutts_> quicksilver: or to help explain the meaning of a program
09:43:37 <quicksilver> dcoutts_: that was my second point?
09:43:48 <quicksilver> dcoutts_: "Unless you believe that, by naming it, you are providing valuable documentation."
09:44:03 <dcoutts_> quicksilver: sorry, I wasn't paying attention :-)
09:44:05 <quicksilver> ;)
09:44:28 <quicksilver> ohnoes it's conal! quick, hide the functional graphics code...
09:45:16 <conal> :)
09:45:22 <Toxaris> I use names to avoid breaking expressions into multiple lines (wich I find hard to read)
09:46:02 <Toxaris> like f = x . y . z where \n x = ... \n y = ... \n z = ...
09:46:31 <Toxaris> with sensible choosen x, y and z, of course
09:51:20 <quicksilver> Toxaris: weird.
09:51:29 <quicksilver> Toxaris: your program is already on multiple lines.
09:51:42 <quicksilver> Toxaris: why is an expression on multiple lines worse than a program on multiple lines?
09:51:56 <quicksilver> presumably you allow your 'do' expressions to span multiple lines...
09:52:24 <Toxaris> quicksilver: I try hard to avoid do expressions, wich i don't like at all
09:52:40 <Toxaris> quicksilver: but if I use them, then on different lines
09:57:18 <Toxaris> quicksilver: I'm not sure. Maybe I like explicit structure? (with multiline expressions, I have to parse multiple lines to understand the top-level structure of the expression).
09:58:05 * Nafai loves all of the good suggestions
10:00:15 <Toxaris> with multiline programs, I don't have this problem, the structure is clear: one definition per line.
10:00:41 <Toxaris> i try to organise my programs so that exactly one name is bound per line
10:01:12 <Toxaris> data TypeName \n = ConsName { \n fieldName :: SomeType }
10:01:26 <quicksilver> Toxaris: that's fair. With multiline expressions I normally have an obvious top-level structure.
10:01:34 <quicksilver> Toxaris: like, they are all (.)-ed together.
10:01:43 <quicksilver> Toxaris: or they're elements in a [] list
10:05:37 <roconnor> @bab nl en zuurstof
10:06:19 <oerjan> oxygen
10:06:44 <oerjan> @bot
10:06:45 <lambdabot> :)
10:06:57 <ricky_clarkson> @check \x -> @bab nl en (@bab en nl (x :: String)
10:06:58 <lambdabot> Unbalanced parentheses
10:07:02 <ricky_clarkson> @check \x -> @bab nl en (@bab en nl (x :: String))
10:07:03 <lambdabot>  Parse error at "@bab" (column 7)
10:07:05 <ricky_clarkson> ;)
10:07:27 <ricky_clarkson> Garbage for more than one reason.
10:07:42 <byorgey> heh
10:07:47 <byorgey> I bet that isn't true anyway.
10:09:25 <oerjan> actually babelfish does turn them into each other
10:10:01 <byorgey> oerjan: for any input string?
10:10:19 <oerjan> no for oxygen <-> zuurstof
10:18:02 <ricky_clarkson> byorgey: http://pastebin.com/d7d893c2
10:18:28 <MyCatVerbs> :i forkIO
10:18:37 <MyCatVerbs> Wait, this isn't ghci.
10:18:39 <MyCatVerbs> :t forkIO
10:18:40 <lambdabot> Not in scope: `forkIO'
10:19:04 <oerjan> :t Control.Concurrent.forkIO
10:19:05 <lambdabot> IO () -> IO GHC.Conc.ThreadId
10:19:21 <MyCatVerbs> Danke.
10:19:26 <byorgey> ricky_clarkson: heh, nice.
10:22:38 <Nafai> byorgey: So, I just tried an experiment.
10:22:52 <byorgey> Nafai: what's that?
10:22:55 <Nafai> byorgey: I only cared about 5 letter words, not 3-7 or whatever I was doing
10:23:07 <byorgey> how'd it work?
10:23:14 <Nafai> byorgey: So the only change to the code was the length range of valid and possible words
10:23:25 <Nafai> 38 seconds vs 3 min 26 seconds on this machine
10:23:33 <byorgey> heh, nice
10:23:44 <Nafai> And still came up with the right answer
10:24:02 <byorgey> sweet!
10:24:35 * quicksilver growls at Peter Padawitz
10:24:54 <Nafai> Makes me curious if there is an "optimal" word length to search for
10:25:23 <byorgey> Nafai: try doing 3-letter words instead of 5
10:25:29 <byorgey> see if it still works
10:25:53 <byorgey> well, try 4-letter words too
10:27:36 <Nafai> Both 3 and 4 worked, taking 31s and 34s respectively
10:27:48 <byorgey> cool
10:28:12 <mcp_> Where can i find the definition of Maybe?
10:28:21 <allbery_b> @src Maybe
10:28:22 <lambdabot> data Maybe a = Nothing | Just a
10:28:30 <quicksilver> mcp_: in the haskell report
10:28:33 <allbery_b> @index Maybe
10:28:33 <lambdabot> Data.Maybe, Prelude
10:28:37 <quicksilver> @go haskell report online
10:28:39 <lambdabot> http://www.haskell.org/haskellwiki/Definition
10:28:39 <lambdabot> Title: Language and library specification - HaskellWiki
10:28:45 <allbery_b> @where report
10:28:45 <quicksilver> hmm that's not right!
10:28:45 <lambdabot> http://www.haskell.org/onlinereport/
10:28:48 <quicksilver> thanks :)
10:29:57 <mcp_> I thought Maybe is a monad. Shouldnt it implement Monad then?
10:30:13 <ricky_clarkson> @instances Maybe
10:30:15 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
10:30:21 <byteshack> can someone help me understand what is wrong with this?   let grepFile fname = do; f <- readFile fname; unlines (filter (\x -> isInfixOf "AssemblyName" x) (lines f));
10:30:21 <ricky_clarkson> @instances Monad
10:30:22 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:30:24 <quicksilver> mcp_: it does; that is also in the report
10:30:28 <ricky_clarkson> Maybe is in there.
10:30:55 <allbery_b> @instances Monad
10:30:55 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:31:29 <mcp_> http://www.haskell.org/onlinereport/maybe.html  There is no monad in the code. Can you point me to what actually makes it a monad?
10:31:29 <lambdabot> Title: The Haskell 98 Library Report: Maybe Utilities
10:31:45 <allbery_b> @src Maybe return
10:31:45 <lambdabot> return              = Just
10:31:52 <allbery_b> @src Maybe (>>=)
10:31:52 <lambdabot> (Just x) >>= k      = k x
10:31:52 <lambdabot> Nothing  >>= _      = Nothing
10:31:56 <byteshack> I'm thinking it is the fact that I'm not returning an IO, but not sure what to do
10:32:09 <Toxaris> byteshack: use return
10:32:19 <ricky_clarkson> mcp_: I think there'll be a line somewhere starting with 'instance' that declares it.
10:32:29 <ricky_clarkson> Someone'll likely correct me within the minute.
10:33:17 <Toxaris> byteshack: do f <- readFile fname; return (unlines (filter ... f)))
10:33:25 <quicksilver> mcp_: http://www.haskell.org/onlinereport/standard-prelude.html
10:33:25 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
10:33:35 <quicksilver> mcp_: search for "instance  Monad Maybe"
10:33:44 <quicksilver> mcp_: (two spaces between instance and Monad, annoyingly!)
10:33:59 <byteshack> Toxaris: thanks, ; at the end, I assume
10:34:10 <dons> ?users
10:34:10 <lambdabot> Maximum users seen in #haskell: 401, currently: 400 (99.8%), active: 15 (3.8%)
10:34:17 <mcp_> quicksilver, found it, thx
10:34:40 <Toxaris> byteshack: I would write it in multiple lines and use layout
10:34:55 <gwern> oy. one of the bad things about haskell is when stuff is under documented, it's hard to figure out what does what. I mean, what does 'runSh st info = (flip runReaderT) info . (flip execStateT) (st,Nothing) . unSh' mean?
10:35:18 <ricky_clarkson> In the prelude, instance Eq Int where ...
10:35:25 <ricky_clarkson> Does ... mean "compiler-internal"?
10:35:28 <allbery_b> @unpl runSh st info = (flip runReaderT) info . (flip execStateT) (st,Nothing) . unSh
10:35:28 <lambdabot> runSh st info i = runReaderT (execStateT (unSh i) (st, Nothing)) info
10:35:41 <Toxaris> like this, byteshack:
10:35:41 <Toxaris> do f <- readFile filename
10:35:41 <Toxaris>    return (unlines ... f)
10:35:55 <quicksilver> gwern: it's running with environment 'info'
10:35:56 <ricky_clarkson> :t (...)
10:35:59 <lambdabot> Not in scope: `...'
10:36:00 <quicksilver> gwern: (that's the ReaderT part)
10:36:03 <oerjan> byteshack: ; is a separator, no need at the end or beginning
10:36:10 <quicksilver> gwern: and state (st,Nothing)
10:36:21 <quicksilver> gwern: that's the StateT part
10:36:21 <allbery_b> ricky_clarkson: yes
10:36:26 <ricky_clarkson> Thanks.
10:36:36 <quicksilver> gwern: the parameters are not in the order the author wanted, hence hte use of flip
10:36:47 <quicksilver> gwern: normally you write "runReaderT action environment"
10:37:02 <quicksilver> gwern: they wanted to give the environment first so they could built up a pipeline
10:37:08 <gwern> hm. it's still a bit confusing, but the unpl makes it more sensible
10:37:08 <quicksilver> gwern: the issue with the state is exactly the same
10:37:19 <quicksilver> gwern: then the unSh bit is just unwrapping a newtype
10:38:04 <quicksilver> I bet data Sh st info m a = Sh { unSh :: ReaderT info (StateT (st,Maybe blah)) m a }
10:38:12 <quicksilver> gwern: give or take some typos on my part :)
10:38:44 <MyCatVerbs> > (read "    340")::Integer
10:38:46 <lambdabot>  340
10:38:50 <Toxaris> byteshack: (\x -> isInfixOf "AssemblyName" x) is equivalent to (isInfixOf "AssemblyName")
10:39:02 <gwern> actually, it's 'newtype Sh st a = Sh { unSh :: StateT (CommandResult st) (ReaderT OutputCommand IO) a }
10:39:07 * MyCatVerbs quietly deletes one instance of "dropWhile isSpace" from his code. >_>
10:39:34 <dons> "Last year it seemed you couldn?t turn around without reading another blog
10:40:18 <Toxaris> byteshack: and   do f <- action; return (foo f)   is equivalent to   fmap foo action
10:40:33 <dons> entry saying Ruby was going to kill Java, etc. Now the named languages are
10:40:33 <dons> Haskell or Erlang, but the story is the same."
10:40:56 <Toxaris> byteshack: I would therefore write something like
10:40:56 <Toxaris> grepFile = fmap (unlines . filter (isInfixOf "AssemblyName") . lines) readFile
10:40:58 <quicksilver> gwern: well, sort of kind of close :)
10:41:36 <quicksilver> Toxaris: which looks even nicer, IMO, with infix `fmap`
10:41:54 <quicksilver> Toxaris: unlines . filter (isInfixOf "AssemblyName") . lines `fmap` readFile "foo"
10:42:08 <gwern> shellac's author is way too fond of clever type stuff :(
10:43:47 <quicksilver> gwern: monad transformers are syntactically noisy, making them a bit unapproachable until you get used to them
10:43:59 <quicksilver> gwern: they are a sensible abstraction in theory but a bit noisy in practice.
10:44:12 <Toxaris> quicksilver: I would actually prefer <$> over `fmap`, and a seperate name for grep :: String -> [String] -> [String] without IO
10:44:25 <quicksilver> Toxaris: well yes :)
10:44:32 <gwern> quicksilver: is that what I've been dealing with? so that's what monad transformers look like...
10:44:34 <quicksilver> Toxaris: agreed on both counts
10:44:45 <mcp_> so is the sole point of >>= in monads, that this function knows how to combine 2 instances of the same monad?
10:44:47 <quicksilver> gwern: ReaderT and StateT are monad transformers, yes
10:44:53 <quicksilver> mcp_: yes
10:44:59 <quicksilver> mcp_: feeding a value through
10:45:06 <quicksilver> mcp_: "binding" a value, hence >>= is "bind"
10:47:31 <andy__> dons: Haskell killing Erlang or Ruby killing Haskell? I remember at least one blog author smoking interpreted languages away via Haskell. ;>
10:50:30 <Toxaris> quicksilver: I'm not sure about the `foo` notation. it's sometimes nice (consider x `sepBy` semi), but most of the time it leads to annoying parameter order (consider (sepBy semi) again, wich is not as usefull as (flip sepBy semi)).
10:51:07 <quicksilver> Toxaris: I also prefer <$> to `fmap`
10:51:12 <Toxaris> quicksilver: in the end, I opt for "real operators" when possible
10:51:19 <quicksilver> Toxaris: I was merely taking a step-by-step approach to changing the code
10:51:29 <quicksilver> Toxaris: for byteshack's benefit more than yours :)
10:51:58 <Toxaris> quicksilver: ohh, ahem, fine, so we just provided different steps :) fine.
10:52:40 * Toxaris considers #haskell the best refactoring tool ever
10:52:50 <andy__> Toxaris: what about (`sepBy` semi) ?
10:53:36 <dons> andy__: yeah, i love charging in with a flame thrower on the silly dynamic kids
10:53:47 <oerjan> @remember Toxaris * Toxaris considers #haskell the best refactoring tool ever
10:53:48 <lambdabot> I will never forget.
10:54:00 <andy__> hehe
10:54:08 <Toxaris> andy__: it's the obvious solution. But it means that the author of a function decides wether it's usable with backticks or it's usable without
10:54:25 <Toxaris> andy__: it's (most of the times) not the caller's decision
10:54:53 <quicksilver> Toxaris: but you do get to choose between (semi `sepBy`) and (`sepBy` semi)
10:54:57 <quicksilver> Toxaris: thus avoiding flip
10:55:21 <quicksilver> more useful example (`isInfixOf` "verylongword") vs ("short" `isInfixOf`)
10:58:46 <Toxaris> I would like  infixl sepBy  instead of forcing every user of sepBy to search for ` on his keyboard
10:59:39 <Toxaris> or maybe changing lexical rules to allow alphanumeric characters in operator names (as long as there is at least 1 operator char), and forcing tokens to be seperator by whitespace
11:00:25 <Toxaris> the point of the backticks rule seems to be that the same function name can be used as infix as well as prefix. but are there such functions wich are sensibly usable as both?
11:00:41 <allbery_b> yes
11:00:51 <Toxaris> at the other hand, backticks work only with names, not with arbitrary expressions. (why? parsing issues?)
11:01:01 <allbery_b> whether someone uses fmap as infix or prefix is a matter of individual style (if not religious war :)
11:01:51 <andy__> Ohh yeah and dont forget about Squigollishness. ^^
11:02:21 <quicksilver> Toxaris: parsing issues. they don't nest.
11:02:33 <quicksilver> Toxaris: `foo `ap` bar`
11:02:42 <quicksilver> Toxaris: has two possible parses :)
11:02:46 <quicksilver> at least two
11:04:27 <gwern> anyone familiar with shellac? http://hpaste.org/4326 <-- it compiles, but I can't figure out why the only recognized commands is 'quit'...
11:05:06 <Toxaris> allbery_b: ok. maybe my position is just `fmap` is devil's work, but other's positions are different
11:05:41 <Toxaris> if I were to use `fmap`, it would alias it as `inside`
11:05:50 <quicksilver> Toxaris: also, alphanumeric can be quite mnemonic
11:05:55 <glguy> quicksilver, what are the two possible parses?
11:05:55 <quicksilver> my favourite being `on`
11:06:10 <glguy> quicksilver, the ` always touches the word it applies to, doesn't it?
11:06:26 <quicksilver> glguy: if you're prepared to use whitespace to solve it, that does indeed solve it.
11:06:30 <glguy> > succ ` id ` 1
11:06:30 <allbery_b> `foo` ap `bar`, `foo (`ap`) bar`
11:06:33 <lambdabot>  2
11:06:37 <quicksilver> glguy: but then I can't write zip`ap`tail
11:06:42 <glguy> oh, I didn't know that `   id   ` was valid
11:06:46 <quicksilver> glguy: the well known aztec god of consecutive numbers.
11:07:05 <quicksilver> or his big brother, zipWith(*)`ap`tail
11:07:15 <dcoutts_> Is there any class, like Functor that provides an operation like fzipWith :: SomeClass f => (a -> b -> c) -> f a -> f b -> f c
11:07:22 <quicksilver> dcoutts_: yes
11:07:28 <dcoutts_> what is it?
11:07:35 <quicksilver> dcoutts_: you need Traversable on the left, but Foldable is sufficient on the right
11:07:47 <dcoutts_> hmm
11:07:50 <quicksilver> dcoutts_: I wrote this code a few weeks ago, congrats on being my first customer!
11:07:51 <MyCatVerbs> Huh. foldr works on infinite lists, foldl doesn't.
11:07:55 <conal> isn't it just Applicative?
11:08:01 <conal> @ty liftA2
11:08:05 <MyCatVerbs> However, mapAccumL does, mapAccumR doesn't. o_O
11:08:16 <dcoutts_> conal: no, it's not as strong as Applicative
11:08:16 <lambdabot> thread killed
11:08:19 <quicksilver> dcoutts_: http://www.haskell.org/haskellwiki/FoldableAndTraversable#Generalising_zipWith
11:08:21 <lambdabot> Title: FoldableAndTraversable - HaskellWiki, http://tinyurl.com/3xy5eu
11:08:24 <dcoutts_> (I think)
11:08:39 <conal> dcoutts_: (<*>) = liftA2 ($)
11:08:51 <quicksilver> conal: it is not quite the same in intent as Applicative. In my opinion.
11:09:03 <quicksilver> conal: Applicative can do arbitrary weird stuff, like the list monad, if it wants
11:09:11 <quicksilver> conal: cartesian product is not very 'zipWith-like'
11:09:24 <quicksilver> conal: the natural spec of zipWith is to recreate the structure on the left
11:09:29 <MyCatVerbs> :t (,)
11:09:30 <lambdabot> forall a b. a -> b -> (a, b)
11:09:37 <dcoutts_> conal: sure, applicative is probably enough to define it, but I think it's intermediate in generality between Functor and Applicative
11:09:44 <quicksilver> conal: zipWith tree list should be the same 'shape' as tree, but pair with the items in the list
11:09:48 <quicksilver> conal: (see my code which I just linked)
11:10:02 <quicksilver> zipWithTF :: (Traversable t,Foldable f) => (a -> b -> c) -> t a -> f b -> t c
11:10:13 <quicksilver> is, in my opinion, the correctly general type signature
11:10:18 <quicksilver> obviously t == f is a special case
11:10:24 <quicksilver> since all Traversables are Foldable.
11:10:29 <SyntaxNinja> does anyone know which file(s) I have to edit to update my blog url on planet.haskell.org?
11:10:37 <dcoutts_> quicksilver: hmm, I think that's too powerful again, I've got something like: data Record a = Record a a a a a
11:10:43 <SyntaxNinja> ompl.xml? foafroll.xml?
11:10:52 <dcoutts_> quicksilver: so it's obviously a Functor, but it's not list like at all
11:11:02 <quicksilver> dcoutts_: it's traversable though
11:11:12 <quicksilver> dcoutts_: finite tuples are traversable and foldable
11:11:46 <quicksilver> if you're prepared to write those instances, you'd find my zipWithTF did the thing you want.
11:12:14 <quicksilver> (you clearly could, also, write the applicative instance and do it conal's way)
11:12:31 <quicksilver> but I happen to think the Traversable and Foldable instances for that structure are more "natural" than the applicative one.
11:13:51 <andy__> Is there some multi-stage programming effort going on? I mean in the metaocaml-spirit.
11:14:13 <dcoutts_> andy__: see TemplateHaskell
11:14:16 <dcoutts_> quicksilver: I don't see any (,,,) instances for Traversable
11:14:21 <andy__> dcoutts_: Template Haskell is going in that direction?
11:14:39 <quicksilver> dcoutts_: no. Traversable isn't as widely used as it should be.
11:14:40 <dcoutts_> andy__: oh, multi stage as in more than 2? in that case no.
11:14:45 <quicksilver> dcoutts_: easy to write one though.
11:15:14 <andy__> dcoutts_: im not necessarily in need for >2 stages but for more typing.
11:15:41 <dcoutts_> andy__: Igloo wrote his thesis on typing Template Haskell
11:16:13 <andy__> Thats the softtypes paper?
11:16:29 <Toxaris> quicksilver: how would you express that ('a', 'b') is Traversable, but ('a', 3) not?
11:16:29 <dcoutts_> I think that's what it was called
11:16:43 <Toxaris> (or isn't that the case?)
11:16:44 <quicksilver> Toxaris: with a newtype; fortunately dcoutts_ already has one
11:17:00 <dmead> Toxaris, the first one is homogeneous and the second isnt?
11:17:19 <Toxaris> quicksilver: ok
11:17:22 <andy__> dcoutts_: and will it be implemented?
11:17:37 <dcoutts_> andy__: ask Igloo
11:17:38 <quicksilver> instance Traversable Record where traverse act (Record a b c d e) = Record <$> act a <*> act b <*> act c <*> act d <*> act e
11:17:42 <quicksilver> if I"m not mistaken
11:18:22 <quicksilver> and instance Foldable Record where foldMap x (Record a b c d e) = foldMap x [a,b,c,d,e]
11:18:45 <quicksilver> actually might as well delegate to lists in the Traverse case I suppose, it's slightly easier to write
11:18:58 <quicksilver> ah no, can't do that :)
11:19:07 <quicksilver> that's rather the point.
11:19:13 <quicksilver> dcoutts_: make sense?
11:19:16 * Toxaris realizes that instance Foldable (,) is not well-kinded anyway, so a newtype is needed
11:19:30 <quicksilver> dcoutts_: maybe that seems like a mess just to get zipWith, but it feels 'Right' to me.
11:19:46 <quicksilver> dcoutts_: since that data type is just as naturally Traversable as it is naturally Functorial.
11:19:59 <quicksilver> Toxaris: precisement.
11:21:09 <byteshack> I have: getAssemblyNames files = mapM (\x -> grepFile x "<AssemblyName") files -- which has type: [FilePath] -> IO [String], how can I get it to accept IO [FilePath]?
11:21:48 <quicksilver> byteshack: fmap
11:22:12 <quicksilver> getAssemblyNames `fmap` thingWhichReturnsIO[FilePath]
11:22:21 <quicksilver> byteshack: or, for extra points, use <$> instead of `fmap` :)
11:22:44 <quicksilver> ah, that would double up your IOs
11:22:46 <quicksilver> not quite what you want
11:22:51 <quicksilver> this is a case for >>=
11:23:09 <quicksilver> thingWhichReturnsIO[FilePath] >>= getAssemblyNames
11:23:24 <quicksilver> or, getAssemblyNames =<< thingWhichReturns
11:23:26 <quicksilver> according to taste
11:23:35 <oerjan> :t \f x1 x2 x3 x4 -> liftM3 ($) (liftM2 f x1 x2) x3 x4
11:23:43 <lambdabot> forall a a3 r a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> a -> a3 -> r) -> m a1 -> m a2 -> m a -> m a3 -> m r
11:23:55 <Toxaris> does this lead to a discussion of fmap, bind and join?
11:24:02 * byteshack needs to scratch his head with that for a while now
11:24:20 <quicksilver> Toxaris: deja vu?
11:24:35 <quicksilver> Toxaris: or do you have a slightly different discussion in mind
11:24:52 <quicksilver> byteshack: your example is *exactly* the example which motivates monads in the first place
11:24:59 <Toxaris> quicksilver: I'm just proud to understand something
11:25:03 <quicksilver> byteshack: and it is the motivating example for the existence of >>=
11:25:04 <quicksilver> Toxaris:  :)
11:25:30 <byteshack> ... now it's my turn to try to understand it
11:30:28 <byteshack> quicksilver: what can I read to help me understand what just happened?  It works, but I have no clue why
11:30:58 <pitecus_> how can i include some data files in a cabal package?
11:31:56 <quicksilver> byteshack: I'm not sure, really. Have you looked at cale's monad tutorials?
11:32:13 <quicksilver> byteshack: if you're not satisfied by the simple fact that >>= is designed to do exactly what you wanted.
11:32:19 <musiKk> i'm reading them too right now
11:34:29 <byteshack> this? http://www.haskell.org/haskellwiki/Monads_as_Containers
11:36:13 <quicksilver> byteshack: that's one, yes
11:37:02 <quicksilver> byteshack: then the more advanced one is http://www.haskell.org/haskellwiki/Monads_as_computation
11:38:10 <byteshack> thanks
11:41:02 <musiKk> i have one question concerning named fields
11:41:08 <musiKk> i read about them in yaht
11:41:17 <musiKk> here: http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced#Datatypes_Revisited
11:41:39 <musiKk> there exist "update methods"
11:42:33 <musiKk> do they really update? i read everywhere that haskell has no real update methods, because every function should always provide the same result given the same arguments no matter when it is executed
11:43:07 <mauke> they return a modified version
11:43:43 <quicksilver> musiKk: they're just convenient sugar for returning a fresh value with one field changed
11:43:55 <byorgey> pitecus_: the Extra-source-files field?
11:43:57 <quicksilver> musiKk: significantly for some use cases, the unchanged fields dont' occupy any more space
11:44:13 <quicksilver> musiKk: they're just pointers back to the same fields as the unchanged value had, which is quite nice.
11:44:27 <quicksilver> well "one field changed" -> "some fields changed"
11:44:40 <pitecus> byorgey, OK. How do I use them from the program though? That is what file path do I use?
11:44:50 <musiKk> okay thank you very much... this makes perfect sense but i wanted to be sure :-)
11:45:05 <byorgey> pitecus: hmm, I don't know
11:45:31 <pitecus> :-(
11:45:51 <mauke> > runReader ask{ runReader = succ } 42
11:45:53 <lambdabot>  43
11:46:40 <quicksilver> pitecus: there is an answer to this, I believe, but I don't know it. try dcoutts_ if he wakes up again :)
11:46:51 <pitecus> ok
11:47:00 <dcoutts_> @yarr!
11:47:00 <lambdabot> Gangway!
11:47:19 * dcoutts_ wanders off to get more tea
11:47:28 <oerjan> > runReader ask{ runReader = intToDigit } 5
11:47:30 <lambdabot>  '5'
11:47:37 <pitecus> dcoutts_, do you know the answer?
11:47:44 <oerjan> huh
11:48:13 <oerjan> i thought that would give a type error
11:49:13 <dcoutts_> pitecus: what is the question?
11:50:01 <pitecus> how can i include some data files in a cabal package? And what file path do I use from the program to refer to them, dcoutts_
11:51:13 <dcoutts_> pitecus: data-files:  and then you import the Paths_<pkgname> module to find out where the files are at runtime.
11:51:32 <oerjan> :t \x -> ask{ runReader = x }
11:51:33 <lambdabot> forall r a. (r -> a) -> Reader r a
11:51:38 <byorgey> hey, that's nifty =)
11:51:51 <pitecus> dcoutts_, what functions in that module?
11:51:54 <mauke> :t \x -> runReader ask{ runReader = x }
11:51:56 <lambdabot> forall r a. (r -> a) -> r -> a
11:52:20 <dcoutts_> pitecus: take a look, it's in dist/build/autogen/Paths_<pkgname>.hs
11:52:27 <oerjan> i would have thought the x would have to be the same type as the original
11:52:30 <pitecus> ok thanks
11:52:33 <oerjan> :t ask
11:52:33 <byorgey> dcoutts_: and when you install, Cabal automatically squirrels away the data files in /usr/local/lib/foo or something like that?
11:52:33 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
11:52:47 <oerjan> :t runReader ask
11:52:48 <lambdabot> forall r. r -> r
11:52:51 <dcoutts_> byorgey: right, in the $datadir/$datasubdir
11:52:59 <byorgey> dcoutts_: cool.
11:53:11 <mauke> oerjan: ask = id
11:53:15 <dcoutts_> pitecus: you probably want getDataFileName or getDataDir
11:53:23 <dcoutts_> byorgey: it tells the package it's version number too
11:53:29 <dcoutts_> it's/its
11:54:26 <gbacon> @pl \x -> (x*x) +1
11:54:26 <lambdabot> (1 +) . join (*)
11:54:36 <oerjan> mauke: Reader id.  but why can you do ask{ runReader = x } where x does _not_ have type a -> a ?
11:54:51 <mauke> oerjan: because record updates don't care about types
11:55:17 <oerjan> and Hugs seems to have a strange bug even when the type _is_ the same
11:55:46 <gbacon> :t join
11:55:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:56:50 <gbacon> :t join (*)
11:56:50 <lambdabot> forall a. (Num a) => a -> a
11:57:09 <gbacon> ah.. ->
11:58:16 <ricky_clarkson> @check \x -> join (*) (x :: Integer) == x*x
11:58:17 <lambdabot>  OK, passed 500 tests.
11:59:32 <gbacon> wheee!
12:00:37 <vininim> @check (+)
12:00:38 <lambdabot>  Add a type signature
12:00:43 <vininim> =p
12:01:19 <ricky_clarkson> @check (\x y -> x+y-y==x) :: Integer -> Integer -> Boolean
12:01:20 <lambdabot>   Not in scope: type constructor or class `Boolean'
12:01:25 <ricky_clarkson> @check (\x y -> x+y-y==x) :: Integer -> Integer -> Bool
12:01:26 <lambdabot>  OK, passed 500 tests.
12:01:51 <oerjan> @check (\x y -> x+y-y==x) :: Double -> Double -> Bool
12:01:52 <lambdabot>  Falsifiable, after 4 tests: -0.3333333333333333, -2.6666666666666665
12:02:08 <pitecus> When I use the package which uses that Paths_.. hack, I get linker errors like this:
12:02:09 <pitecus> /home/gchrupala/lib/morfette-0.1/ghc-6.8.1/libHSmorfette-0.1.a(Distr.o): In function `s4gt_info':
12:02:09 <pitecus> (.text+0x3e87): undefined reference to `morfettezm0zi1_Pathszumorfette_datadir_closure'
12:02:33 <pitecus> dcoutts_, Do i need to do anything special in the cabal file?
12:02:33 <mauke> > (-0.3333333333333333) + (-2.6666666666666665)
12:02:35 <lambdabot>  -3.0
12:02:37 <mauke> > (-0.3333333333333333) + (-2.6666666666666665) - (-2.6666666666666665)
12:02:37 <lambdabot>  -0.3333333333333333
12:03:47 <ricky_clarkson> > let x=-1/3 :: Double in let y=-8/3 :: Double in x+y-y-x
12:03:48 <lambdabot>  Parse error at "::" (column 12)
12:04:03 <ricky_clarkson> > let x=(-1/3 :: Double) in let y=(-8/3 :: Double) in x+y-y-x
12:04:04 <dcoutts_> pitecus: you need to list the data files in the "data-files:" field in the .cabal file.
12:04:08 <lambdabot>  -1.6653345369377348e-16
12:04:17 <pitecus> dcoutts_, I did that
12:04:36 <dcoutts_> pitecus: that's it then
12:04:48 <pitecus> I gte those linker errors
12:05:01 <dcoutts_> you'll have to be more specific
12:05:15 <dcoutts_> linker errors don't have anything to do with the data files being installed
12:05:20 <pitecus> I pasted them 1 minutes before
12:05:28 <ricky_clarkson> Why does QuickCheck not include things like the maximum value of an Int in its sample data?
12:05:46 <ricky_clarkson> e.g., \x -> x+1>x is falsifiable.
12:06:06 <pitecus> dcoutts, I tried to put Paths_morfette in the Other-modules field
12:06:21 <dcoutts_> pitecus: and did that not work?
12:06:25 <pitecus> dcoutts_, but it cant find the dir with the module
12:06:44 <pitecus> do i just specify dist/auotgen in Hs-Source-Dirs??
12:07:03 <desegnis> ricky_clarkson: There are algorithms that need a long time on large values, which may be a reason to prefer small values for quick checks.
12:07:21 <Toxaris> ricky_clarkson: it would be the wrong thing for some tests
12:07:31 <dcoutts_> pitecus: hmm, that's not terribly nice is it. I guess so. It's a bit of a hack though. I guess most users of the paths module are programs not libs, and for programs they can get away with not specifying all other-modules.
12:07:47 <Toxaris> ricky_clarkson: consider (length . flip replicate () == id)
12:08:04 <pitecus> dcoutts_, ok then
12:08:36 <dcoutts_> pitecus: it's a bug really I guess, I'm filing a cabal bug report...
12:08:49 <pitecus> cool thanks, dcoutts_
12:20:36 <newsham> ?src replicate
12:20:37 <lambdabot> replicate n x = take n (repeat x)
12:25:22 <esdrasbeleza> I'm trying to do this: "tamanho (Interval t1 t2) = abs (t2 - t1) + 1", but ghci says: "Couldn't match expected type `Int' against inferred type `t'"
12:25:26 <esdrasbeleza> any help? :(
12:26:25 <oerjan> what's the definition of Interval?
12:27:20 <vininim> ?src liftM_
12:27:20 <lambdabot> Source not found. stty: unknown mode: doofus
12:27:59 <vininim> ?src liftM2
12:27:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:28:12 <esdrasbeleza> oerjan, data (Enum t) => List t = ListaVazia | Cons t (List t) | Interval t t
12:29:05 <oerjan> do you have a type declaration for tamanho?
12:29:33 <esdrasbeleza> yes
12:29:37 <esdrasbeleza> tamanho		:: (Enum t) => List t -> Int			-- Retorna o tamanho da lista
12:29:54 <esdrasbeleza> (sorry for the comments in Portuguese)
12:30:22 <luqui> everyone knows all software is written in english
12:30:25 <oerjan> right that cannot work, because subtraction is not defined for all t that might be used
12:30:37 <oerjan> or number literals for that matter
12:30:40 <luqui> or ancient greek, in the case of haskell
12:30:46 <esdrasbeleza> hmm, fine. how can I define that?
12:30:53 <oerjan> perhaps you want Num t instead?
12:30:54 <conal> esdrasbeleza: and you gave Int as the result, which forces t == Int
12:31:07 <oerjan> oh wait
12:31:13 <oerjan> right
12:31:22 <conal> esdrasbeleza: because of the types of - & +
12:31:35 <oerjan> what does tamanho mean? length?
12:31:43 <conal> esdrasbeleza: maybe add Num t to the context and generalize the result type to t.
12:31:59 <lament> everybody knows haskell doesn't need comments :)
12:32:01 <oerjan> oh i see!
12:32:29 <esdrasbeleza> oerjan, yes :)
12:32:30 <oerjan> esdrasbeleza: i think you want abs(fromEnum t2 - fromEnum t1)
12:32:39 <oerjan> :t fromEnum
12:32:40 <lambdabot> forall a. (Enum a) => a -> Int
12:33:02 <conal> i bet that's it.
12:34:37 <esdrasbeleza> it worked :D
12:34:43 <oerjan> :)
12:34:47 <esdrasbeleza> :D
12:34:54 <lament> esdrasbeleza: are you from portugal?
12:35:06 <esdrasbeleza> lament, no, from Brazil
12:35:45 <lament> nice :)
12:35:53 <vininim> me2 =p
12:36:21 <esdrasbeleza> vininim, where are you from?
12:36:50 <esdrasbeleza> (two brazilians speaking in English, cool)
12:37:10 <vininim> MG
12:38:31 <lament> i'm from canada but i really like brazilian music and portuguese :)
12:38:52 <esdrasbeleza> lament, hmm. what kind of brazilian music? :)
12:39:40 <lament> pretty much anything i've heard that wasn't MPB :)
12:39:49 <lament> but mainly bossa nova and choro
12:40:07 <jedbrown> How can I tell if (fromIntegral :: Int -> CInt) is a no-op?
12:40:43 <mauke> @src CInt
12:40:43 <lambdabot> Source not found. My brain just exploded
12:41:40 <jedbrown> mauke: In a portable way.  I beleive it is with GHC and all current architectures.
12:41:56 <mauke> why do you need to know?
12:42:45 <jedbrown> I'm serializing StorableVectors with MPI which can do endian-conversion for the standard C types.
12:42:48 <oerjan> > bitSize (1::CInt)
12:42:50 <lambdabot>   Not in scope: type constructor or class `CInt'
12:42:50 <dcoutts_> jedbrown: I think it's not on 64bit systems since Int follows the system word size but C int is often 32bit even on 64bit machines.
12:43:30 <jedbrown> dcoutts_: Okay.  Good to know.
12:43:32 <oerjan> oh right, Foreign is excluded
12:43:33 <esdrasbeleza> lament, good :) sometimes people say to me "I like brazilian music!", and when I ask what do they listen from here they tell me the worst brazilian artists
12:43:36 <dcoutts_> jedbrown: with ghc, if they're the same size on your system then it's a no-op or a performance bug. If it's the latter, report it :-)
12:44:53 <jedbrown> dcoutts_: I'm just trying to write instances for my MPI_Datatype class.
12:45:22 <jedbrown> dcoutts_: If they map to a C type, then MPI can do the necessary conversion so that it works on a heterogeneous system.
12:45:53 <lament> esdrasbeleza: that's the beauty of brazilian music - there's so much variety, everybody will like _something_ :)
12:46:39 <jedbrown> dcoutts_: If not, then it needs to work like derived types where the conversion is done in the Haskell world and MPI doesn't touch the byte representation.
12:46:56 <dcoutts_> jedbrown: right
12:48:31 <jedbrown> dcoutts_: Is something defined which will tell me if a Haskell type is equivalent to the C type?  (Double -> CDouble, Long -> CLong, ...)
12:49:00 <oerjan> jedbrown: bitSize should give at least a hint
12:49:15 <jedbrown> dcoutts_: Right, I forgot.  Thanks.
12:50:20 <oerjan> @src RealFrac
12:50:21 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
12:50:21 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
12:50:21 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
12:50:27 <oerjan> er not that one
12:50:30 <oerjan> @src RealFloat
12:50:31 <lambdabot> Source not found. Sorry.
12:50:38 <dcoutts_> jedbrown: I don't see that it actually matters anyway, you have to do the conversion anyway and if they have the same machine representation then it'll be a no-op
12:53:33 <jedbrown> dcoutts_: Hmm.  Could that cause unnecessary truncation?  If the Haskell representation is the same between systems, but the C representation is different.  Maybe this never happens.
12:54:21 <dcoutts_> jedbrown: yes it's possible. Int is 64bit on 64bit boxes with ghc. CInt is usually 32bit even on 64bit boxes.
12:55:56 <jedbrown> dcoutts_: Also, doesn't (map id :: StorableVector a -> StorableVector a) perform a copy?
12:56:08 <dcoutts_> jedbrown: yup
12:56:38 <oerjan> maybe there's a rule to remove the copy?
12:57:27 <jedbrown> In this case, the rule has to fire when (fromIntegral :: Int -> CInt) is a no-op.
12:58:05 <jedbrown> Reading the source, there is no rule.
12:58:17 <oerjan> that _does_ seem trickier.
13:06:05 <newsham> who is the haskell programmer in portugal who frequents this channel?
13:06:15 <dons> who isn't!?
13:06:22 * gwern wonders.  now that I have a community.haskell.org, what do I do with it?
13:06:47 <oerjan> @brain
13:06:48 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
13:07:15 <jedbrown> In the interest of portability, I think I won't try to map Haskell types to C types.  We can usually do numerics with the C types anyway.  Interesting Haskell types will go through Data.Binary anyway.
13:07:16 <oerjan> @brain world
13:07:17 <lambdabot> Uh, I think so, Brain, but balancing a family and a career ... ooh, it's all too much for me.
13:07:31 <newsham> someone from portugal is linking an image from my website that I posted to this channel once as their webforum icon
13:07:44 <newsham> and I should probably talk to them about it sooner than later ;-)
13:08:27 <newsham> before it causes them too much personal embarassment
13:08:49 <dmwit> Oh, good, what have you changed it into?
13:08:57 <newsham> you dont want to know
13:10:14 <mauke> url?
13:10:27 <newsham> the original is http://www.thenewsh.com/%7Enewsham/consMonster2.jpg
13:10:38 <newsham> attempt to recover the new one at your own risk
13:11:02 <ricky_clarkson> Oh dear.
13:11:21 <mauke> pfft, harmless
13:12:15 <Betovsky> newsham thats probably me
13:12:24 <Betovsky> if you want i can change
13:12:26 <newsham> hi beto.  please copy the image to your own site
13:12:34 <newsham> you can use the image, just please dont link from my site
13:12:52 <Betovsky> oky doky
13:12:58 <dmwit> Just at a guess, you should have no trouble detecting whether it is, in fact, you.
13:16:59 <Altair^> where can I get haskell libraries?
13:17:04 <dmwit> ?where hackage
13:17:04 <lambdabot> http://hackage.haskell.org/
13:19:49 <Betovsky> it has been done
13:20:16 <Betovsky> dmwit actually in the forum it still was the old one, probably cache
13:20:30 <Betovsky> i only noticed it had changed when i saved the file
13:24:08 <dylan> newsham: that's not as bad as what I've done. Someone linked to a picture on my website, which was of the irish flag, with gentoo and debian's logos on opposing sides, and a penguin image in the center... because they liked penguins.
13:24:34 <dylan> newsham: I noticed this person lived in Ireland, so I replaced it with a very large, violently-worded IRA poster.
13:25:18 <dylan> (it was the background image of their blog...)
13:25:25 <mauke> hahaha
13:25:59 <mauke> http://adblockplus.org/blog/why-you-really-should-not-hotlink
13:25:59 <dylan> he somehow found the original image, again, right after posting a picture of himself...
13:26:40 <dylan> so, a friend made this: http://hardison.net/album/funny/tn/exposed-himself-on-the-internets.png.index.html
13:27:17 <dylan> which *still* didn't work. After this one, though, he closed is blog: http://hardison.net/album/funny/tn/exposed.png.index.html
13:27:27 <dylan> *his
13:27:38 <newsham> dylan: mean :)
13:27:55 <lament>  cute
13:28:09 <dylan> I tried talking to him first!
13:28:14 <dmwit> Bye bye, niven!
13:28:34 <lament> dylan: did he say anything?
13:28:44 <dylan> lament: he didn't seem to comprehend what I said.
13:29:31 <dylan> in that I got no response.
13:29:56 <dmwit> Maybe he doesn't speak your language. =)
13:29:57 <Heffalump> some people started discussing a photo of a friend of mine, not in a very nice way. So we changed the photo to a big, wide, red and green flashing block, just for their referrer.
13:30:47 <dmwit> whee...
13:33:51 <dylan> dmwit: he did not live in a Gaeltacht region, so chances are he speaks english as a first language. :P
13:35:36 <quicksilver> that was a messy unsplit. irssi didn't recognise it properly as an unsplit
13:35:38 <quicksilver> irssi--
13:35:54 <oerjan> irssi-- me too
13:36:15 <ricky_clarkson> Just to prove irssi isn't its own source of entropy, me too.
13:36:58 <ibid> i got lots of "netsplit over" notices. seems to me it recognised it just fine
13:37:33 <dmwit> Mmm, I wonder if xchat has a plugin for collapsing netsplits.
13:37:38 <dmwit> That sounds like a nice feature.
13:37:42 <oerjan> what's the point with notices if it cannot summarize...
13:37:46 <lament> dylan: just use irssi
13:38:14 <lament> oerjan: it cannot summarize, because people actually join at different times
13:39:10 <quicksilver> ibid: you're not supposed to get lots of
13:39:17 <quicksilver> ibid: you're supposed to only get one :)
13:39:39 <quicksilver> ibid: but sometimes they don't come back at close enough to the same time and its magic summarisation doesn't kick in
13:39:46 <lament> if people join at different times, irssi can't really do anything
13:39:54 <dmwit> lament: That seems like a poor excuse.  How hard can it be to lump together all the joins in a, say, 60-second interval or so?
13:39:54 <lament> it's not gonna lie that they joined at the same time
13:40:07 * dmwit shrugs
13:40:09 <dmwit> Why not?
13:40:12 <lament> dmwit: so for 60 seconds you're not gonna say that somebody rejoined, when in fact they have?
13:40:19 <dmwit> yep
13:40:21 <lament> that sounds like an awful bug to me
13:40:21 <ibid> quicksilver: exactly my point
13:40:52 <dmwit> lament: Show them in the user list and allow tab-completion of their name, but do you seriously care about join-time down to the second?
13:40:52 <oerjan> hm, it could at least join netjoins that are on consecutive lines
13:41:31 <dylan> lament: um, what?
13:41:31 <mauke> oerjan: what if they're hours apart?
13:41:36 <quicksilver> I belief it uses exactly this algorithm
13:41:40 <quicksilver> it's just the magic number isn't 60 seconds
13:41:41 <lament> dylan: yes?
13:41:41 <dylan> I'm using irssi. :P
13:41:45 <quicksilver> it's rather more like 0.5 seconds
13:41:48 <dmwit> dylan: He was talking to me, but mistyped.
13:41:50 <ibid> quicksilver: irssi would be buggy if it didn't show me them as they came in (i note that it did summarise some of them, the weren't all single notices)
13:41:51 <quicksilver> I'm not sure, though.
13:41:51 <oerjan> mauke: a second limit in addition would be fine
13:41:52 <dylan> ah.
13:41:54 <lament> dylan: oh :)
13:42:19 <quicksilver> ibid: but it doesn't show them as they come in. It aggregates some. All we're arguing about is the threshold :)
13:42:58 <lament> (why do people rejoin at different times? aren't they all on one server?)
13:43:06 <oerjan> if it can modify a previous line then it wouldn't have to have a threshold
13:43:26 <oerjan> at least not a low one
13:43:52 <ibid> quicksilver: "would you sleep with anyone if given a million dollars?" "sure." "what about for a hundred dollars?" "really, i'm not a whore!" "i'm sorry, we already established you are, we're now discussing your price" that about it? :)
13:44:04 <quicksilver> ibid: exactly :)
13:44:56 <ibid> what i wonder is how irssi knows it's a netjoin
13:45:05 <Heffalump> ibid: it guesses
13:45:10 <ibid> is there something in the protocol message?
13:45:19 <Heffalump> it can be confused by people simulating the same effect, I've seen it
13:45:24 <oerjan> and just now it seemed to guess wrong ...
13:46:52 <lament> it looks like it forgot about the netsplit
13:46:58 <lament> and marked all these joins as regular joins
13:47:58 <quicksilver> yeah, I strongly suspect it only marks netjoins if it's "Expecting"
13:48:03 <quicksilver> i.e. if there was a split recently
13:48:09 <quicksilver> but I'm only guessing based on what I've seen.
13:48:26 <ibid> if i really cared i'd go look at the source
13:48:31 <ibid> but EVVK :)
13:49:40 <quicksilver> ooh, finnish acronyms
13:49:47 <quicksilver> luckily google provides!
13:49:52 * quicksilver feels his horizons broaden
13:50:22 <ibid> there's an english wikipedia page on it
13:50:25 <ibid> weird
13:51:21 <andy__> matveev: Hi, i guess we're from the same university. Is there a larger haskell community at tum? :>
13:51:45 * ibid didn't know about the tv show
14:13:53 <nolrai> is there any way to get  some thing like:
14:13:55 <nolrai> toLazyKayList (x:xs) = (\ f -> (f x (toLazyKayList xs)))
14:13:56 <nolrai> to work?
14:14:42 <oerjan> :t let toLazyKayList (x:xs) = (\ f -> (f x (toLazyKayList xs))) in  toLazyKayList
14:14:45 <lambdabot>     Occurs check: cannot construct the infinite type:
14:14:45 <lambdabot>       t = t1 -> (t -> t2) -> t2
14:14:45 <lambdabot>     Probable cause: `f' is applied to too many arguments
14:14:56 <nolrai> Im trying to make a Lambda calculus interpreter.
14:14:57 <byorgey> nolrai: what exactly are you trying to do?
14:15:01 <r3m0t> what is it meant to be?
14:15:13 <oerjan> nolrai: you need a newtype wrapper
14:15:50 <nolrai> :oerjan how exactly
14:15:58 <Saizan> church encoding a list shouldn't give a foldr with rank2 types?
14:16:10 <mauke> newtype Fun = Fun { call :: Fun -> Fun }
14:16:55 <oerjan> mauke's suggestion should work for pure LC
14:17:08 <mauke> ocaml -rectypes
14:17:18 <nolrai> mauke++
14:17:48 <oerjan> otoh the result will be hard to observe...
14:19:00 <quicksilver> yes, it's a model, not a term algebra
14:19:10 <quicksilver> not inspectable...
14:19:24 <oerjan> if you make the result be in a monad then you can make some testable functions
14:19:52 <oerjan> newtype Fun = Fun { call :: Fun -> IO Fun } or similar
14:20:12 <quicksilver> or you can cheat a bit and stick a couple of atomics in
14:20:25 <quicksilver> data Fun = Atom | Fun { call :: Fun -> Fun }
14:20:34 <quicksilver> but you don't permit the "user" to use Atom
14:20:44 <quicksilver> however, you can use it to observe stuff, I think
14:21:13 <oerjan> Atom String perhaps
14:22:24 <oerjan> i guess the Atom method fits better with lazy evaluation
14:24:08 <oerjan> or even Atom String [Fun], then you could apply those by just appending the argument
14:25:10 <gabor_> fwiw, my blog entry today: http://heisenbug.blogspot.com/2007/12/only-one-of-each-please.html
14:25:29 <quicksilver> oerjan: or, you can pair terms and denotations
14:26:00 <quicksilver> oerjan: data Fun = Fun Term (Fun -> Fun)
14:26:14 <quicksilver> oerjan: at least I think that works out.
14:30:46 <Saizan> gabor_: can you give a short description of omega?
14:32:18 <gabor_> omega is not my invention, but Tim Sheard's, here is an intro: http://web.cecs.pdx.edu/~sheard/papers/SumSchNotes.ps
14:32:35 <gabor_> of course that has 50+ pages :-)
14:32:46 <Saizan> not exactly short :)
14:33:11 <byorgey> Saizan: it's descended from Haskell, but features an extensible kind system, among other things
14:33:29 <Saizan> dependently typed?
14:33:50 <gabor_> the short description is: haskell-like strict with optional non-trict semantics, integrated reasoning via Curry-Howard and GADTs
14:34:13 <byorgey> Saizan: I don't think so (but I'm not entirely sure)
14:34:22 <gabor_> not dependently typed, but emulates them well thru singleton types
14:34:28 <osfameron> bah.  getLine throws an exception on EOF
14:34:49 <osfameron> http://pastebin.com/d42376e7f
14:35:19 <osfameron> if I cat something | runghci words.hs, then it croaks at the end
14:35:26 <osfameron> *** Exception: <stdin>: hGetChar: end of file
14:35:30 <Toxaris> osfameron: what did you expect?
14:35:35 <osfameron> Toxaris: dunno really
14:35:59 <osfameron> but I need to be able to trap that
14:36:36 <sjanssen> not a problem, see Control.Exception
14:36:46 <quicksilver> osfameron: or check for EOF before reading...
14:36:53 <quicksilver> normally I frown on check-then-attempt
14:36:58 <quicksilver> it's a pooor paradigm
14:37:03 <quicksilver> but I dont think it's too bad in this cas
14:37:10 <osfameron> checking for EOF seems more elegant than having to trap an exception
14:37:21 <osfameron> really I'd want getLine to be a Maybe result
14:37:43 <osfameron> how do I check EOF?
14:37:51 <Toxaris> osfameron: what's wrong with interact (unlines . concatMap words . lines)?
14:38:25 <Toxaris> osfameron: in other words: do you really need line-wise reading, or just line-wise processing?
14:38:44 <quicksilver> :t (Just <$> getLine) `catch` (\_ -> return Nothing)
14:38:46 <lambdabot> IO (Maybe String)
14:38:56 <quicksilver> osfameron: that would appear to be what you asked for
14:39:18 <quicksilver> except I'm not distinguishing between different types of exception
14:39:33 <osfameron> Toxaris: I guess processing.  I'm trying to write K&R exercise 1-12 (Write a program that prints its input one word per line) in haskell
14:40:07 <osfameron> quicksilver: cute.  I guess `catch` is in Control.Exception?  What's <$> ?
14:40:26 <ricky_clarkson> fmap, infix.
14:40:30 <quicksilver> osfameron: that's the prelude catch actually
14:40:33 <quicksilver> since I didn't qualify it
14:40:40 <ricky_clarkson> > [1,2,3] <$> (*2)
14:40:41 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
14:41:01 <ricky_clarkson> > (*2) <$> [1,2,3]
14:41:02 <lambdabot>  [2,4,6]
14:41:04 <Toxaris> > succ <$> [1, 2, 3]
14:41:05 <lambdabot>  [2,3,4]
14:41:25 <Toxaris> ricky_clarkson: param order of <$> is like that of $
14:41:37 <byorgey> > (+) <+> [1,2,3] <*> [4,5,2]
14:41:38 <lambdabot> Terminated
14:41:51 <byorgey> =(
14:42:08 <quicksilver> @src interact
14:42:09 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:42:17 <byorgey> > (+) <$> [1,2,3] <*> [4,5,2]  -- duh
14:42:18 <lambdabot>  [5,6,3,6,7,4,7,8,5]
14:42:58 <osfameron> @index (<$>)
14:42:58 <lambdabot> bzzt
14:43:15 <byorgey> @index <$>
14:43:15 <lambdabot> bzzt
14:43:20 <byorgey> Control.Applicative
14:43:28 <byorgey> might be exported from other places as well, I'm not sure.
14:43:42 <osfameron> why do we need the fmap there?
14:43:48 <byorgey> osfameron: where?
14:44:03 <byorgey> Just <$> getLine?
14:44:18 <quicksilver> osfameron: I fear your exercise is interact (unlines . concatMap words . lines). You may not find that as instructive as writing it your way though :)
14:45:06 <Nafai> byorgey: So I wonder if I can rewrite my solution to #59 without looking at my current solution.  I don't think I remember enough of the Haskell "tricks" to do it though :)
14:45:09 <byorgey> because getLine :: IO String, so Just getLine :: Maybe (IO String), but Just <$> getLine :: IO (Maybe String).
14:45:10 <smack_> why lines?
14:45:27 <osfameron> byorgey: yeah, there.
14:45:35 <byorgey> Nafai: hmm, might be an interesting excercise =)
14:45:50 <quicksilver> byorgey: it moves the 'Just' "inside" the IO
14:45:56 <quicksilver> osfameron: that was for you, osrry :)
14:45:57 <osfameron> quicksilver: heh
14:46:02 <smack_> interact (unlines . words) -- ?
14:46:37 <quicksilver> smack_: depends how you interpret the question, but yes it could be that, too
14:46:42 <Toxaris> smack_: but osfameron wanted linewise processing for some reason
14:46:44 <EvilTerran> osfameron, in this context, <$> = liftM
14:46:47 <quicksilver> smack_: oh, I see. good point.
14:46:55 <Nafai> Can someone explain this line?
14:46:57 <Nafai> > [10,20,30] >>= \x -> [x, x+1] >>= \y -> if y > 20 then [] else [y,y]
14:46:58 <lambdabot>  [10,10,11,11,20,20]
14:47:05 <byorgey> @check \w -> concatMap words . lines $ w == words w
14:47:05 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
14:47:06 <Nafai> I don't get how that happens
14:47:38 <EvilTerran> > [z | x <- [10,20], y <- [x,x+1], z <- if y > 20 then [] else [y,y]]
14:47:43 <lambdabot>  [10,10,11,11,20,20]
14:47:46 <quicksilver> Nafai: well the key is to understand what >>= means in the list monad
14:48:05 <gabor_> Saizan: http://code.google.com/p/omega/
14:48:09 <quicksilver> Nafai: it means 'run this code "n" times, once for each item in the list, and accumulate the results"
14:48:15 <EvilTerran> @src [] (>>=)
14:48:15 <lambdabot> m >>= k     = foldr ((++) . k) [] m
14:48:40 <quicksilver> Nafai: so, "[4,5,6] >>= blah" means 'run blah three times, with values 4, 5 and 6 respectively, and collect the results"
14:48:43 <EvilTerran> clear as mud :)
14:48:51 <Nafai> Ahhhh
14:48:54 <quicksilver> Nafai: which you could also write as concat (map blah [4,5,6])
14:48:59 <quicksilver> Nafai: or, concatMap blah [4,5,6]
14:49:09 <quicksilver> Nafai: and, in fact, >>= is concatMap, in the list monad
14:49:16 <Nafai> I was getting lost on the second >>=, but of course that first lambda function returns a list
14:49:26 <ddarius> byorgey: That was concatMap words . lines (w == words w)
14:49:42 <Nafai> Much clearer now
14:49:44 <byorgey> ddarius: huh?
14:49:45 <osfameron> quicksilver, byorgey: ah ok.  That makes enough sense from experimentation...
14:49:47 <Nafai> Thanks you!
14:49:50 * osfameron looks at the interact stuff
14:49:54 <Nafai> Er, Thank
14:50:07 <ddarius> [16:47] <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
14:50:15 <ddarius> [16:47] <byorgey> @check \w -> concatMap words . lines $ w == words w
14:50:26 <byorgey> ddarius: oh, now I see what you're saying =)
14:50:34 <ddarius> (Except that I needed to parenthesize the composition as well.)
14:50:35 <byorgey> @check \w -> (concatMap words . lines $ w) == words w
14:50:36 <lambdabot>  OK, passed 500 tests.
14:50:39 <byorgey> =D
14:50:44 <Toxaris> > words "that's\nthe\nquestion"
14:50:45 <lambdabot>  ["that's","the","question"]
14:50:47 <quicksilver> osfameron: "interact" is just the cute observation that a simple stdin/stdout program is just a function String -> String
14:51:01 <quicksilver> byorgey: I wouldn't have much confidence that has tried the important test cases
14:51:05 <ddarius> quicksilver: Laziness is crucial here.
14:51:14 <Japsu> Hmm
14:51:27 <Japsu> does interact operate line-wise or on the whole contents of stdin?
14:51:27 <quicksilver> byorgey: the ones you might care about are about spaces next to newlines, and lines consisting of only spaces, etc
14:51:33 <ddarius> @scheck \w -> (concatMap words . lines $ w) == words w
14:51:33 <lambdabot>   Completed 1957 test(s) without failure.
14:51:36 <mrd> whole contents
14:51:37 <quicksilver> Japsu: the whole contents
14:51:41 <Japsu> hmm yay
14:51:42 <byorgey> quicksilver: ah, good point
14:51:44 <Japsu> makes it more useful
14:51:47 <mrd> interact (unlines . map f . lines)
14:51:56 <Japsu> though many cases are still interact $ unlines . f . lines
14:52:02 <quicksilver> exactly
14:52:03 <Japsu> *map f
14:52:04 <Japsu> yeah
14:52:48 <osfameron> quicksilver: your interact version works fine for piped input, but echoes each char immediately, which is suboptimal for interactive input
14:53:34 <osfameron> er, Toxaris's version even
14:54:50 <Toxaris> Prelude> interact $ unlines . words
14:54:50 <Toxaris> working fine
14:54:50 <Toxaris> working
14:54:50 <Toxaris> fine
14:55:20 <Toxaris> but i guess it depends on readline or whatever
14:55:46 <byorgey> it might act differently depending on whether it's compiled or not, output buffering mode, etc...
14:56:56 <osfameron> If I type "hello world" I get the result "hheelloo\nwwoorrlldd"
14:57:06 <osfameron> cute though
14:57:48 <osfameron> good value for 3 words and a smattering of punctuation
14:58:03 <quicksilver> osfameron: yes. interact, ironically, is not good for interactive use :)
14:58:26 <quicksilver> osfameron: for interactive use you are better taking some control of things yourself. normally you want to print prompts and do line-editing etc.
14:58:26 <osfameron> heh
14:58:50 <quicksilver> having said that, by explicitly setting buffering to line-by-line you ought to get something reasonably sensible.
14:59:16 <Toxaris> maybe that works better: linewiseInteract f = mapM_ putStrLn . f . line =<< getContents
14:59:34 <osfameron> how can you set buffering?
15:00:40 <Toxaris> or that: linewiseOutputInteract f = mapM_ putStrLn . lines . f =<< getContents
15:00:46 <quicksilver> osfameron: hSetBuffering stdin LineBuffering
15:02:12 <osfameron> quicksilver: how do I use that
15:02:21 <osfameron> Toxaris: interesting - I get the same result with that though
15:02:34 <quicksilver> osfameron: main = do hSetBuffering stdin LineBuffering
15:02:44 <quicksilver>       hSetBuffering stdout LineBuffering
15:02:49 <quicksilver>         interact (do your stuff)
15:02:55 <quicksilver> hmm, with correct indentation :)
15:03:17 <Toxaris> osfameron: so haskell is, as always, another step lazier then i thought
15:03:31 <osfameron> :-)
15:03:33 <quicksilver> Toxaris: don't feel bad. getContents is evil anyway :)
15:03:38 <osfameron> quicksilver: where does LineBuffering live?
15:03:45 <quicksilver> osfameron: System.IO I suspect
15:03:49 <quicksilver> @index LineBuffering
15:03:49 <lambdabot> System.IO
15:04:24 <Toxaris> quicksilver: but getContents seems to be the right tool for that task
15:04:44 <osfameron> yup.  That's the behaviour I was expecting (from the C exercise's version)
15:04:57 <quicksilver> Toxaris: I think we have just demonstrated it isn't :)
15:05:13 <quicksilver> Toxaris: I'd rather a version of interact which explicitly does the IO behind the scenes
15:05:19 <quicksilver> Toxaris: without lazyness
15:06:01 <ddarius> quicksilver: And takes a different type (of function)?
15:06:08 <Toxaris> quicksilver: the exercise makes no sense interactively, and for non-interactive usage, output as-soon-as-possible sounds sensible to me
15:06:40 <perspectivet> why do I need to make the following compile? map (\x -> printf "%02x" (x::Int)) [1,23]
15:06:59 <byorgey> perspectivet: good question =)
15:07:05 <Toxaris> perspectivet: maybe because you want to try it out?
15:07:20 <lament> what's the meaning of life?
15:07:46 <perspectivet> hehe
15:07:46 <byorgey> > map (\x -> printf "%02x" (x::Int)) [1,23]
15:07:47 <lambdabot>  Add a type signature
15:07:57 <quicksilver>  :t let {interact_by_lines f = do { eof <- isEOF ; if eof then return () else do {l <- getLine; putStrLn (f l); interact_by_lines f}}}  in interact_by_lines
15:08:05 <quicksilver> :t let {interact_by_lines f = do { eof <- isEOF ; if eof then return () else do {l <- getLine; putStrLn (f l); interact_by_lines f}}}  in interact_by_lines
15:08:06 <lambdabot> Not in scope: `isEOF'
15:08:07 <byorgey> > map (\x -> printf "%02x" (x::Int)) [1,23] :: [String]
15:08:09 <lambdabot>  ["01","17"]
15:08:35 <quicksilver> :t let {interact_by_lines f = do { eof <- System.IO.isEOF ; if eof then return () else do {l <- getLine; putStrLn (f l); interact_by_lines f}}}  in interact_by_lines
15:08:36 <lambdabot> (String -> String) -> IO ()
15:08:38 <perspectivet> byorgey: thanks.  type signatures still give me a few problems now and then
15:08:41 <quicksilver> Toxaris: something like that.
15:08:47 <byorgey> perspectivet: well, printf is an odd case.
15:08:50 <quicksilver> perspectivet: what's giving you trouble is the insane overloading of printf.
15:08:58 <quicksilver> perspectivet: don't feel bad about that :)
15:09:13 <perspectivet> quicksilver: thanks
15:09:15 <byorgey> printf "blah" x  -- this might be a String, or it might be a function!
15:09:24 <osfameron> I played with printf earlier.  It is rather odd
15:09:30 <quicksilver> Toxaris: that still has a convenient type at the front, but behind the scenes the lazy IO is explicit, not implicit.
15:09:38 <quicksilver> byorgey: or, indeed, an IO action
15:09:45 <Toxaris> quicksilver: but not less lazy
15:09:53 <byorgey> quicksilver: oh, right, that too!
15:09:59 <quicksilver> Toxaris: well you can lines are read as needed
15:10:04 <quicksilver> Toxaris: no more, no less.
15:10:19 <quicksilver> Toxaris: getContents will read when the data is demanded. This reads always once per line.
15:10:39 <quicksilver> Toxaris: "f" can never be called on a String containing an IO exception, in my version.
15:11:00 <Toxaris> quicksilver: hmm yes, because when something crashes, it's between calls to f
15:11:10 <quicksilver> Toxaris: exactly.
15:11:31 <quicksilver> Toxaris: the bad thing about lazy IO is crashes can occur asynchronously. explicit IO makes sure exceptions occur where you are expecting.
15:11:43 <quicksilver> Toxaris: but still, my interact_by_lines has a convenient type.
15:12:04 <Toxaris> quicksilver: but it is less general then interact
15:12:09 <quicksilver> of course
15:12:11 <quicksilver> it is by line
15:12:13 <quicksilver> ;)
15:12:27 <Toxaris> quicksilver: wich was explicitly requested
15:12:28 <quicksilver> if you want the full "interact" then you have to answer this question:
15:12:38 <quicksilver> "Am I happy to read the whole file into memory at once?"
15:12:47 <quicksilver> if the answer is yes, then use strict IO and be happy.
15:12:56 <quicksilver> if the answer is no, then (unsafely) lazy IO is the only choice.
15:13:03 <quicksilver> nothing else can have the right type signature.
15:13:57 <Toxaris> quicksilver: i see what you mean. since lines are normally short enough to read into memory at once, getContents is not the right tool for interactByLine
15:14:38 <quicksilver> Toxaris: if you want to read massive files without unsafe lazy IO, then you will need to do some kind of explicit chunking
15:14:48 <quicksilver> which, of course, is what you'd probably do in another language
15:15:04 <Toxaris> quicksilver: it's what I hope the lazy IO will do for me
15:15:05 <quicksilver> the tradeoff between explicit chunking and dangerous IO laziness is a fiddly one
15:15:08 <quicksilver> right
15:15:10 <quicksilver> and it will :)
15:15:16 <quicksilver> if you're prepared to live with its shortcomings
15:15:41 <Toxaris> the problem seems to be for me: it's hard to understand, but seems to be newbie-friendly and easy
15:15:51 <ddarius> For a throw-away script, lazy IO is okay, but for something more serious, it's usually a bad idea.
15:16:32 <osfameron> gah.  C really is very annoying when you're used to high level languages
15:16:42 * dcoutts loves lazy IO
15:16:54 <quicksilver> dcoutts, dons and I love to argue about lazy IO :)
15:16:57 * ddarius thinks we should do away with all lazy IO.
15:17:24 <quicksilver> Toxaris: yes; the thing I don't like is its deceptively simple but then leads to surprising problems
15:17:35 <quicksilver> Toxaris: which then belie our claims about haskell's high level expressivity
15:17:49 <quicksilver> Toxaris: to be fair, the not-closing-filehandles is the worst bit, certainly
15:17:57 <quicksilver> if that was fixed problems would be quite a lot raere
15:17:59 <quicksilver> rarer
15:18:27 <Toxaris> isn't that one believed to be fixable by better integration of io into the gc?
15:18:49 <quicksilver> Toxaris: yes, it is
15:18:54 <ddarius> GCed file handles is a bad idea
15:19:02 <quicksilver> ddarius: interesting. why's that?
15:19:20 <quicksilver> Toxaris: oleg explains this more coherently that me, at the following URL:
15:19:20 * osfameron *heart*'s Perl's garbage collected filehandles
15:19:28 <quicksilver> @go perils of getContents
15:19:35 <quicksilver> osfameron: they're refcounted, not garbage collected
15:19:47 <quicksilver> osfameron: refcounting is nice and easy to understand :)
15:19:54 <osfameron> quicksilver: refcounting is a form (even if a simpleminded stupid one) of garbage collection, isn't it?
15:19:59 <quicksilver> well, yes, it is
15:20:05 <dcoutts> quicksilver: "not-closing-filehandles" is that a specific bug or just the general problem of lazy io?
15:20:17 <quicksilver> dcoutts: it is a particular example of a general kind of problem
15:20:23 <quicksilver> dcoutts: which is that IO implies OS resources
15:20:34 <quicksilver> dcoutts: and lazy IO doesn't clean up those resources synchronously
15:20:47 <quicksilver> dcoutts: it happens to be the one which bites newbies most often
15:21:11 <dcoutts> esp on MacOS apparently which has a ridiculously low file handle count
15:21:16 <quicksilver> even worse is lazy DB access (*winks* at CosmicRay) since DB handles are generally more "precious" than file handles.
15:21:45 <dcoutts> file handles are not a limited resource on any sensible system, they're just a bit of memory, there's no need to make them artificially scarce
15:21:47 <ddarius> quicksilver: It has pretty much the same problem as lazy IO in that regard.
15:21:49 <quicksilver> where by DB handles I also include statement handles and cursors and stuff.
15:22:02 <quicksilver> tieing up those resources can tie up significant server-side resources
15:22:23 <quicksilver> ddarius: I'm interested in why you say so confidently that GCed file handles in bad
15:22:29 <quicksilver> ddarius: not that I disagree :)
15:22:34 <luqui> is there somewhere I could find a lambda calculus expression for which the halting problem is not known?
15:22:34 <quicksilver> ddarius: I just want to hear your argument.
15:22:42 <dcoutts> certainly some resources are so expensive that managing them with GC is not appropriate
15:23:01 <dcoutts> file handles are in a grey area and it depends on the use case
15:23:07 <quicksilver> luqui: I'm not sure there are simple ones.
15:23:18 <quicksilver> luqui: basically you build a LC term which is a turing machine and apply it to itself
15:23:27 <quicksilver> luqui: well it's a little more complex, but that's the general plan
15:23:31 <quicksilver> that is not a simple example :)
15:23:47 <ddarius> quicksilver: It's exactly the same problem as with lazy IO.  Even with GC you can lead to holding many file handles that should be released.
15:23:48 <dcoutts> luqui: I think there's that numeric algorithm which almost randomly makes a number very big then usually reduces it
15:23:49 <pmatos> Hello guys, shouldn't the following define a diff array: x = newDiffArray (1,100) [(i, i*i) | i <- [1..100]] ?
15:23:50 <luqui> yeah...  I was looking for the *analogue* of the 5 state turing machines
15:23:57 <luqui> not them literalle embedded in LC :-)
15:24:00 <pmatos> I'm getting an error in ghc :-(
15:24:14 <pmatos> I already imported: import Data.Array.Diff, do I need anything else?
15:24:25 <luqui> dcoutts, don't think I've heard of it
15:24:41 <quicksilver> Ah, what dcoutts said rings a bell...
15:24:47 <luqui> dcoutts, oh, 3n+1 ?
15:24:51 <dcoutts> luqui: it's something like when it's even you apply some increasing function, when it's odd you apply some reducing function. In every case tested it eventually terminates but nobody can prove that it really always terminates.
15:25:03 <luqui> div by 2 when even, 3n+1 when odd
15:25:09 <Toxaris> collatz?
15:25:09 <dcoutts> something like that
15:25:16 <quicksilver> I don't think that grows fast enough luqui
15:25:30 <quicksilver> you have to grow really fast to be non primitive-recursive
15:25:36 <ddarius> Collatz is correct, but the problem isn't undecideable (or at least that hasn't been proven yet)
15:25:44 <luqui> it doesn't have to be non-primitive-recursive
15:26:03 <quicksilver> luqui: all primitive-recursive functions are decidably terminating, aren't they?
15:26:14 <luqui> quicksilver, this is an iteration of a PR function
15:26:16 <quicksilver> or am I in a muddle? long day at work....
15:27:10 <luqui> you apply that function until you get to 1.
15:27:26 <luqui> of course dividing by 2 and multiplying by 3 and adding 1 are always terminating :-)
15:27:58 <ddarius> let infinity = Succ infinity in ...
15:28:08 <luqui> sigh
15:28:17 <Toxaris> quicksilver: what do you mean by "fast growing" in the context of primitive-recursive functions?
15:28:37 <luqui> Toxaris, I expect like Ackermann
15:28:41 <quicksilver> Toxaris: it can be shown that there is a bound on how fast a primitive recursive function grows
15:28:48 <quicksilver> Toxaris: e.g., they can't grow as fast as ackermann
15:29:30 <quicksilver> this gives an intuition that turing-complete languages can do "bigger stuff" than primitive-recursive languages
15:29:44 <Toxaris> quicksilver: oh ok. but slower-growing functions can be non primitive recursive as well?
15:29:51 <quicksilver> true
15:29:53 <ddarius> quicksilver: Or we can just pull out an interpreter for a Turing-complete language.
15:30:10 <quicksilver> ddarius: yes
15:30:28 <quicksilver> Toxaris: inverse ackermann grows very slowly :)
15:30:40 <Toxaris> :)
15:30:51 <luqui> oh, collatz isn't what I was looking for; I was looking for a term which was unknown
15:31:06 <quicksilver> indeed, there is a sense in which any primitive recursive function which grows more slowly than inverse ackermann must be eventually constant
15:31:15 <quicksilver> although I'm sure I can't remember how to prove that
15:31:40 <Toxaris> quicksilver: interesting
15:31:52 <luqui> quicksilver, if it didn't, take its inverse (a PR operation), and you have a function that grows faster than ackermann.  contradiction
15:32:17 <luqui> er
15:32:20 <luqui> i'm being dumb
15:32:25 <luqui> not _that_ kind of inverse
15:32:26 <luqui> :-p
15:34:05 <Toxaris> luqui: "a term wich was unknown"?
15:34:12 <skew> I just started reading Conor McBride's thesis, and it starts off great.
15:34:46 <skew> "Computer programs are not expected to make sense. In fact, they are seldom expected to work, which is as much as to say that computer programmers are not expected to make sense either."
15:35:18 <luqui> Toxaris, I wanted a lambda calculus term for which it was unknown whether it would terminate
15:35:41 <skew> luqui: something small and explicit?
15:35:48 <Toxaris> luqui: unknown (as in: nobody knows at the moment) or undecidable?
15:36:11 <luqui> Toxaris, it is my belief (unproven) that there are no undecid*able* terms
15:36:30 <luqui> kind of a platonic world view
15:36:36 <skew> luqui: it's straightforward if tedious to code up something that e.g. searches all strings for proofs of the Riemann hypothesis
15:36:58 <luqui> skew, yeah, looking for something more simple
15:37:07 <luqui> I coded up the 5-state unknown turing machine
15:37:14 <skew> oh, there's that 3n+1 thing
15:37:25 <luqui> and which number should I run it on
15:37:33 <luqui> it's true for numbers up to something gigantic
15:38:05 <skew> undecidable, I don't know
15:38:12 <Toxaris> luqui: take something gigantic + 1 :)
15:38:21 <luqui> fair enough ;-p
15:38:26 <skew> but goodstein's theorem suggests there probably are terms whose termination is undecidable
15:38:35 <luqui> skew, how so?
15:38:46 <luqui> goodstein's theorem is an omega rule
15:38:47 <skew> or, not implied by a given formal system
15:38:53 <quicksilver> skew: ah, that's the one I was thinking of
15:39:03 <luqui> skew, oh there definitely are
15:39:11 <luqui> but make a bigger formal system
15:39:29 <skew> that's all you ever get with undecidability
15:40:08 <quicksilver> luqui: you can always make a bigger formal system by adding your conjecture as an axiom :P
15:40:14 <quicksilver> luqui:  you're not going to make progress that way
15:40:16 <luqui> right.
15:40:24 <quicksilver> certainly nothing is undecidable if you're allowed to add more axioms :P
15:40:25 <Toxaris> luqui: what about the lambda term wich evaluates to the smallest number wich begins a circular collatz-chain?
15:41:07 <luqui> Toxaris, that could work
15:41:18 <quicksilver> although collatz is not known to be undecidable
15:41:21 <quicksilver> it is merely unknown
15:41:34 <Toxaris> quicksilver: that is what luqui want, isn't it?
15:41:42 <quicksilver> I'm not sure :)
15:41:48 <luqui> still kinda complex, but not too bad
15:41:58 <luqui> I'm having fun talking decidability theory at the moment ;-)
15:42:02 <skew> how about the goldbach conjecture?
15:42:16 <luqui> skew, how would that ever terminate?
15:43:03 <luqui> so LC is a term-rewriting system, something 'real" in a sense.  You can make axioms to talk about it, but when it comes down to it, you have an LC term, and you start rewriting it.  And either you'll get to a normal form, or you won't.
15:43:09 <luqui> that's what I mean "no undecidable LC terms'
15:43:22 <luqui> that's the platonic view.
15:43:45 <quicksilver> luqui: how will you know that you aren't going to get to a normal form, though?
15:43:54 <luqui> quicksilver, you won't.
15:43:57 <quicksilver> luqui: at any particular stage in the algorithm all you know is you haven't got there yet...
15:44:04 <luqui> so you may not be able to prove that it runs forever
15:44:11 <quicksilver> oh, I see what you mean
15:44:13 <quicksilver> platonically, yes
15:44:18 <skew> and any particular logic may be too weak to show that it will terminate
15:44:20 <quicksilver> either the sequence goes on forever, or it doesn't
15:44:24 <skew> or terminate for all input or something like that
15:44:33 <luqui> when I get high I can concieve of what it means to neither terminate nor run forever, but not when I'm sober :-)
15:44:48 <skew> so you're only a constructivist when you're high?
15:44:49 <luqui> skew, right, I'm talking about _single_ terms with no nput
15:44:57 <quicksilver> not that that makes any difference
15:45:09 <quicksilver> there is a bijection between single terms and terms with n parameters :)
15:45:11 <luqui> well it's rather different when you're talking about input
15:45:12 <quicksilver> erm
15:45:14 <quicksilver> injection
15:45:27 <luqui> because then you can start talking about an omega rule again
15:45:27 <quicksilver> any term with n parameters is also a single term...
15:45:33 <luqui> like goostein's theorem.
15:45:54 <luqui> in PA, you can run the goodstein sequence on any input
15:46:00 <skew> I wonder if there are explicit forms there?
15:46:01 <luqui> and it will always halt, (so you can decide it)
15:46:12 <luqui> but you can't prove that it will do that (within PA)
15:48:16 <skew> I saw something recently where an asymptotic bound on the size of circuits for a given problem was transformed with much trouble into an explicit bound for an explicit instance
15:48:51 <skew> I wonder if a similar thing applies for being able to prove termination of the goodstein sequence - or perhaps it's the size of the proof that gets big too quickly
15:49:14 <luqui> I'm not really sure what you mean
15:49:35 <skew> is it true that for any given n you can prove in PA that the goodstein sequence starting at n terminates?
15:49:42 <luqui> yep
15:49:49 <luqui> but you can't prove that you can prove that :-)
15:50:02 <skew> if so does the size of the proof grow very quickly with n?
15:50:12 <luqui> yeah, with the number of steps in the sequence
15:50:30 <skew> ah, ok
15:50:33 <quicksilver> skew: remarkable outstandingly bogglingly quickly, yes
15:50:50 <skew> so it's something like ackerman's not being primitive recursive then
15:50:53 <quicksilver> skew: the only proof, within PA itself, as far as I know, is actually to run it
15:51:17 <skew> anyway, what I really want to know is what goedel's theorem looks like for dependently typed languages
15:51:36 <quicksilver> http://en.wikipedia.org/wiki/Goodstein's_theorem has some examples of how fast it grows
15:51:41 <skew> typechecking, though decidable, requires normalizing terms
15:51:59 <skew> I suppose you could present terms with explicit convertability judgements
15:52:33 <luqui> skew, goedel's theorem for dependently typed languages is just 'they're undecidable', right/
15:52:36 <quicksilver> skew: I think reading Martin-Lof and some of McBride will probably give you answers
15:52:48 <skew> then I think eval is like the consistency statement
15:52:52 <luqui> I mean, that's all his theorem was, saying statements of arithmetic were necessarily undecidable
15:53:10 <quicksilver> skew: a lot of the hard part of formalising dependentl type programming is picking the underlying theory
15:53:41 <skew> luqui: the interesting bit is that e.g. ZF can't imply Con(ZF)
15:53:58 <luqui> ah, the *second* incompleteness theorem
15:54:03 <luqui> which he didn't even publish!
15:54:07 <skew> but on the other hand ZF + Con(ZF) is also a consistent system (as is ZF + ~Con(ZF))
15:54:36 <luqui> and so is ZF + Con(ZF) + Con(ZF + Con(ZF))
15:54:38 <luqui> :-
15:54:39 <luqui> )
15:55:02 <skew> as, similarly, I think a dependently typed language could have a standard type modeling it's own syntax, and a primitive eval
15:55:09 <quicksilver> skew: you mean, I think, that ZF + Con(ZF) is no less consistent than ZF ?
15:55:17 <skew> yeah, that's the one
15:55:20 <quicksilver> skew: ZF + Con(ZF) is 'relatively consistent'
15:57:29 <luqui> so.. skew, what is godel's theorem for untyped LC?
15:58:09 <skew> untyped LC doesn't really correspond to a logic
15:58:44 <quicksilver> well it's a term-rewriting system, so it sort of is
15:58:55 <quicksilver> but I'm not sure it's powerful enough to encode propositions about itself?
15:58:56 <SamB_XP> it can compute all computable integers, can't it?
15:59:03 <skew> at least the usual way, it's one with one statement corresponding to the "untype", and derivation rules from vars and labmdas
15:59:43 <skew> I'm thinking propositions-as-types here, as for dependently typed languages
15:59:50 <luqui> ah
16:00:10 <skew> under that, if you can give an infinite loop any type, then your logic is inconsistent
16:00:12 <luqui> so what is the function whose type is godel's theorem? :-)
16:00:50 <skew> I think it's the type of eval
16:01:01 <luqui> hm...
16:01:08 <skew> at least that's the statement that the system is consistent
16:01:55 <skew> like I said, it's a little wierd because you need normalization to typecheck arbitrary terms
16:02:24 <skew> but I guess it's the typechecking derivations that are really the "proofs", even if elaborating them is computable
16:04:23 <skew> but it definitely seems a bit odd that checking terms is probalby too hard to code up
16:17:22 <nolrai> where is the Monad instace for (->) defined?
16:17:48 <mauke> Control.Monad.Reader <- Control.Monad.Instances
16:18:11 <skew> :info Monad in ghci will show you where all the instances in scope came from
16:18:36 <skew> (but not that it came from Control.Monad.Instances by way of Control.Monad.Reader)
16:18:50 <luqui> there's a great undecidable term: print the least odd perfect number!
16:19:02 <nolrai> skew++
16:19:17 <luqui> s/undecidable/unknown/
16:19:22 <nolrai> thanks mucho
16:26:39 <nolrai> what is "f >>= k = \ r -> k (f r) r" doing?
16:27:07 <nolrai> it's not (.) is it?
16:27:15 <Toxaris> nolrai: no
16:27:21 <dons> ?users
16:27:21 <lambdabot> Maximum users seen in #haskell: 406, currently: 377 (92.9%), active: 12 (3.2%)
16:27:43 <skew> defining >>= ?
16:28:02 <skew> the (->) instance is like reader, it passes the argument everywhere
16:28:23 <Toxaris> nolrai: the r is distributed to both f and k
16:28:53 <skew> dons: I'm curious, how much trouble did you have getting rewrites to work out for stream fusion?
16:29:16 <skew> dons: did it take a lot of fiddling and adjusting stages to stop them from interfering with each other or other optimizations?
16:29:35 <ddarius> skew: Isn't there only one RULE?
16:29:37 <Toxaris> > fst >>= snd $ (1, succ)
16:29:38 <lambdabot>      Occurs check: cannot construct the infinite type:
16:29:38 <lambdabot>       b = ((a, b), b2)...
16:30:20 <quicksilver> > fst >>= (,) $ (1,succ)
16:30:21 <lambdabot>  Add a type signature
16:30:32 <quicksilver> Toxaris: you need the second thing to take two parameters...
16:30:47 <quicksilver> > fst >>= (,) $ (1,2)
16:30:48 <lambdabot>  (1,(1,2))
16:30:58 <Toxaris> quicksilver: yes, realized now
16:32:28 <dons> skew: not so much with fiddling steps, but initially working out the phasing
16:32:39 <nolrai> how is that useful?
16:32:39 <dons> there was a bit of fiddling -- and learning to recognise when things weren't working
16:33:13 <Toxaris> nolrai: it's basically the same as Reader, but without newtype
16:33:21 <quicksilver> nolrai: typically for passing around a global environment
16:33:27 <quicksilver> nolrai: like, Config read from a file, perhaps
16:33:39 <Toxaris> nolrai: and it seems to be mainly usefull to abuse monadic combinators
16:33:41 <quicksilver> nolrai: it's also used for cute hacks
16:33:45 <nolrai> ahh, thanks.
16:34:03 <quicksilver> > liftM2 (&&) (<= 3) (>=1) $ 2
16:34:04 <lambdabot>  True
16:34:09 <quicksilver> > liftM2 (&&) (<= 3) (>=1) $ 5
16:34:10 <lambdabot>  False
16:34:14 <Toxaris> > join (*) 2
16:34:14 <lambdabot>  4
16:35:29 <Toxaris> > (++) <$> fst <*> snd $ ("hello ", "world")
16:35:29 <lambdabot>  "hello world"
16:36:32 <Olathe> Eww.
16:36:39 <Toxaris> > fst <*> snd $ (succ, 1) -- that's what I meant
16:36:40 <lambdabot>  2
16:36:49 <nolrai> what are <$> and <*> ?
16:37:05 <Toxaris> nolrai: <$> is another name for fmap and liftM
16:37:14 <mauke> <*> is ap
16:37:26 <nolrai> ok
16:38:56 <Toxaris> nolrai: so (f <$> a <*> b <*> c) is an alternative for (a >>= \a' -> b >>= \b' -> c >>= c' -> f a b c)
16:39:14 <Olathe> @unpl f <$> a <*> b <*> c
16:39:14 <lambdabot> (((f <$> a) <*> b) <*> c)
16:39:18 <Olathe> :(
16:39:24 * Olathe sobs.
16:39:37 <Toxaris> Olathe: <*> is Applicative, but >>= would only work with Monad
16:39:39 <EvilTerran> @type \f a b c -> f <$> a <*> b <*> c
16:39:40 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
16:39:47 <luqui> also known as liftM3 f a b c  (except it works on things which have less structure than monads too)
16:39:54 <EvilTerran> @type \f a b c -> (a >>= \a' -> b >>= \b' -> c >>= c' -> f a b c)
16:39:54 <lambdabot> parse error on input `->'
16:39:57 <conal> @type liftA3
16:39:58 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
16:40:05 <EvilTerran> @type \f a b c -> (a >>= \a' -> b >>= \b' -> c >>= \c' -> f a b c)
16:40:06 <lambdabot> forall (m :: * -> *) a a1 a2 b. (Monad m) => (m a -> m a1 -> m a2 -> m b) -> m a -> m a1 -> m a2 -> m b
16:40:15 <EvilTerran> er. never mind.
16:40:18 <conal> the applicative generalization of liftA3 is liftA3
16:40:22 <conal> the applicative generalization of liftM3 is liftA3
16:40:29 <EvilTerran> @quote stereo
16:40:29 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:40:31 <EvilTerran> :P
16:40:46 <Toxaris> I like this error message
16:45:36 <pmatos> Are there any restrictions on the values inside an array?
16:45:55 <mrd> @type array
16:45:56 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
16:45:59 <mrd> nope
16:46:01 <benny> no shenanigans!
16:46:05 <mrd> forall e
16:46:20 <pmatos> mrd: ok, thanks...
16:46:42 <mrd> > array (1,10) [1..10]
16:46:43 <lambdabot>   add an instance declaration for (Num (t, e))
16:46:43 <lambdabot>     In the expression: 10
16:46:47 <mrd> > listArray (1,10) [1..10]
16:46:48 <lambdabot>  array (1,10) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
16:47:09 <mrd> > [(1,1)..]
16:47:09 <lambdabot>   add an instance declaration for (Enum (t, t1))
16:47:09 <lambdabot>     In the expression: [(1, ...
16:47:57 <pmatos> is hpaste.org down?
16:48:28 <TSC> There's no Enum for pairs, but you can still do:
16:48:29 <TSC> > listArray ((1,1), (3,3)) [1..]
16:48:30 <lambdabot>  array ((1,1),(3,3)) [((1,1),1),((1,2),2),((1,3),3),((2,1),4),((2,2),5),((2,3...
16:49:32 <pmatos> Yes, but it's wierd, I'm trying to track down a bug in a very simple function that handles arrays and it's driving me mad. Unfortunately hpaste is down.
16:50:19 <Toxaris> pmatos: http://pastebin.com/
16:50:23 <sorear> would people tell me when hpaste is down?  I can't fix it if I don't know
16:50:26 <sorear> @slap Toxaris
16:50:26 * lambdabot secretly deletes Toxaris' source code
16:51:17 <pmatos> sorear: ah, so you're the maintainer? great, it's working now! :-)
16:51:33 <sorear> pmatos: I'm still trying to log in.
16:51:36 <sorear> shapr!!
16:51:51 <sorear> (shapr owns the box)
16:52:54 <pmatos> http://hpaste.org/4327 | can someone please check this code? It's quite small but the error for me is quite incomprehensible.
16:53:14 <pmatos> If I change the a in makeMatrix by Int, it works!!!
16:53:45 <pmatos> How come? Any suggestions/explanation is very welcome. Bear in mind that it's the first time I'm fiddling with Arrays, so be patient. :-)
16:53:56 <sorear> pmatos: you're claiming it's polymorphic.  it's not.  delete one or both type signatures and things will work perfectly
16:54:05 <mrd> because of that type variable
16:54:19 <Toxaris> I can't because hpaste is still not loading. maybe sorear can fix that? ;-)
16:54:23 <mrd> if you had lexical type sigs on it would work i think
16:54:39 <sorear> Toxaris: give me hosting and I will
16:54:39 <mokus> hpaste loaded for me, but it took a long while
16:54:43 <mrd> you shouldn't need the type sig on the array statement
16:54:47 <pmatos> I'm claiming it's polymorphic and it's not? What do you mean?
16:54:59 <pmatos> Why is it not polymorphic?
16:55:14 <sorear> pmatos: because in any specific call, only one type is valid.
16:55:26 <Toxaris> mokus: oh there some title now, i'll join the discussion in twenty minutes, then
16:55:47 <mrd> i think this is easier understood by considering that the 'a' in the function typ signature is a different 'a' from the one on the array statement
16:55:51 <pmatos> ah, so basically the 'a' type declaration for arr is different to the 'a' in the function type declaration...
16:55:55 * mrd chuckles
16:56:01 <pmatos> mrd: now I got it... :-D
16:56:14 <mrd> it's because type variables aren't scoped in Haskell '98
16:56:18 <pmatos> ok, now, I understand.
16:56:23 <mrd> i mean
16:56:28 <sorear> Toxaris: if you'll give me an account on an Internet-visible computer, I'll fix hpaste
16:56:31 <mrd> in-so-far as you can reference them in other signatures
16:56:35 <pmatos> quite stupid then... in fact I never thought about removing it.
16:57:00 <pmatos> I added the type sig to the decl because in : http://www.haskell.org/haskellwiki/Modern_array_libraries
16:57:06 <lambdabot> Title: Arrays - HaskellWiki
16:57:10 <Toxaris> sorear: I havn't any, sorry.
16:57:13 <pmatos> you have: arr = listArray (1,1000) [1..1000] :: DiffArray Int Int
16:57:14 <sorear> pmatos: when you get an error involving rigid type variables, it usually means you have too many signatures and they conflict in some way
16:57:19 <pmatos> in 5. Data.Diff.Array
16:58:09 <pmatos> sorear: great! thanks for the tip.
16:58:39 <pmatos> By the way, another question, in the tutorial for DiffArray it says:
16:58:39 <mrd> pmatos: yea that doesn't use any type variables though
16:58:41 <pmatos> So if a diff array is used in a single-threaded style, that is, after '//' application the old version is no longer used, a!i takes O(1) time and a//d takes O(length d). Accessing elements of older versions gradually becomes slower.
16:58:56 <pmatos> does this mean I can access older versions? What does that mean anyway=
16:58:57 <pmatos> ?
16:59:05 <mrd> yes they're all there
16:59:17 <pmatos> if I can access older versions then probably diffarrays are not very space efficient... right?
16:59:19 <mrd> it preserves the illusion of persistency
16:59:29 <Toxaris> pmatos: yes, you can, but you probably shouldn't
16:59:33 <mrd> diffarrays aren't very efficient :/
17:00:07 <skew> pmatos: they take O(1) space for each operation, until you use the old version, or let it gc
17:00:13 <pmatos> mrd: yes, but it seems all the other more efficient arrays make you deal directly with monads, something I want to avoid for my current example.
17:00:44 <pmatos> skew: ok...
17:00:55 <skew> pmatos: what's the point? probalby might as well use plain Array on small examples if you are just learning the array interface
17:01:58 <pmatos> skew: yes, but since the tutorial said DiffArrays are like arrays but more efficient, that means that I can starting using DiffArrays right away winning in efficiency and staying with a monad-free example.
17:01:59 <pmatos> :-)
17:02:43 <skew> are they actually that efficient?
17:02:58 <sorear> no
17:03:14 <Toxaris> pmatos: yes, that should work. (it may be slower or faster then normal arrays depending on actual usage pattern). but it will not be efficient. if you want efficiency, you have to learn STArray
17:03:31 <sorear> or IOArray, or plain Array
17:03:34 <skew> I think all the mutation under the covers, and keeping the edit history is actually more trouble than using efficient pure data structures
17:03:53 <skew> pmatos: remember, that's one memory for every array operation performed to get from the oldest version you keep to the current version
17:04:00 <Toxaris> sorear: IOArray and STArray is the same, isn't it?
17:04:12 <skew> not #difference plus some log factor like a tree or something...
17:04:26 <sorear> Toxaris: Interanlly yes, externally IOArray is much easier to use
17:04:33 <mrd> technically IOArray is an STArray on RealWorld
17:04:33 <pmatos> skew: ok... you're probably right. I only used DiffArrays due to: DiffArray combines the best of both worlds - it supports the IArray interface and therefore can be used in a purely functional way, but internally it uses the efficient update of MArrays. (from tutorial)
17:04:46 <mrd> but for some reason I've gotten different performance characteristisc
17:04:50 <Toxaris> sorear: because you don't have thread the state around?
17:04:58 <skew> pmatos: which tutorial?
17:05:18 <pmatos> skew: http://www.haskell.org/haskellwiki/Modern_array_libraries
17:05:24 <lambdabot> Title: Arrays - HaskellWiki
17:05:32 <Toxaris> sorear: (in type signatures)
17:05:34 <pmatos> 5 DiffArray (module Data.Array.Diff), first paragraph
17:05:39 <skew> pmatos: I haven't seen recent benchmarks, but I don't remember them actually being worthwhile - Data.Sequence has nice performance guarantees
17:06:12 <davidL> does GHC install on the eeepc?
17:06:25 <SamB_XP> the WHAT?
17:06:32 <pmatos> skew: have to look at Data.Sequence then :-)
17:06:46 <sorear> davidL: why wouldn't it?  does it require signed binaries or something silly like that?
17:06:57 <davidL> SamB_XP: the asus eeepc, it's a cheap, light weight laptop
17:07:10 <skew> how about the XO? anybody got one of those?
17:07:14 <davidL> sorear: I don't know
17:07:38 <davidL> I think ghc works on the XO because there's a screenshot with xmonad on the XO
17:07:44 <skew> :)
17:07:47 <sorear> pmatos: if you are doing matrics, I *highly* recommend Array / UArray.  Mutability isn't even valuable for this.
17:08:03 <mrd> yea UArray is probably the biggest thing you can do
17:08:29 <mrd> i did a matrix multiplication which created a UArray from lists of UArrs (from NDP =)
17:08:51 <skew> pmatos: oh yeah, DiffArray adds overhead everywhere checking if it's an old version and needs to turn itself into a real array
17:09:01 <pmatos> Ok. :-) I'll try those out. I think  I'll do it simple and then I'll fiddle with the structures afterwards! :-)
17:10:18 <mrd> i ordered an XO
17:11:55 <davidL> have you recieved it yet?
17:12:33 <mrd> nolrai:(
17:12:36 <mrd> no :(
17:13:12 <nolrai> hu?
17:13:39 <davidL> I wonder if openbsd runs on the eeepc
17:14:28 <Japsu> openbsd runs on anything turing complete
17:14:29 <Japsu> :P
17:27:56 <nolrai> So what would 'RWST IO env state log' be?
17:28:28 <sjanssen> it would be a kind error
17:28:32 <EvilTerran> reader/writer/state transformed IO monad?
17:28:56 <sjanssen> RWST env log state IO -- is probably what you mean
17:29:32 <nolrai> yeah it is.
17:32:20 <nolrai> would that let me use the state and env while talking to the user? or should i use 'IORef's insted?
17:34:10 <sorear> nolrai: yes, and probably yes
17:34:55 <nolrai> when would you not use IORefs?
17:35:54 <skew> nolrai: when you want to be able to easily save and restore states and environments, for one
17:36:29 <nolrai> dont need that.
17:37:54 <Toxaris> when parts of my program need State and Reader, but not IO.
17:38:39 <newsham> [15:05] < davidL> I think ghc works on the XO because there's a screenshot with xmonad on the XO
17:38:45 <newsham> could be cross-built
17:39:00 <conal> Is {-# LANGUAGE GADTs #-} supposed to make GADTs parse in 6.8.1?  I'm still having to add {-# OPTIONS_GHC -fglasgow-exts #-}
17:39:32 <skew> newsham: I wouldn't want to try compiling GHC on an XO
17:40:28 <nolrai> Toxaris: ok but 'StateT IO ()' is silly, eh?
17:40:42 <newsham> i would use the XO vmware image and build it on that
17:40:52 <newsham> much easier to beef up the cpu and ram
17:41:24 <skew> conal: -XGADTs works for me
17:41:41 <skew> conal: seems to work either way
17:42:32 <Toxaris> nolrai: it would look more like   foo :: (MonadState m MyState) => m String   and then later   foo >>= liftIO . putStrLn
17:43:07 <Toxaris> nolrai: the bonus is: foo can use State, is in fact used inside IO, but doesn't know about.
17:43:31 <nolrai> the state or the IO?
17:43:33 <Toxaris> nolrai: so i can use foo outside of IO, too. (consider ghci, quickcheck, different part of the program, lambdabot)
17:43:38 <Toxaris> nolrai: IO
17:44:12 <nolrai> OK that makes sense.
17:44:24 <skew> Toxaris: are you using mapRWST to sometimes run without the IO?
17:45:42 <Toxaris> skew: i do not even know mapRWST
17:45:59 <jbalint> is there a function in gtk2hs to detect if pango markup is valid?
17:46:21 <skew> Toxaris: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
17:46:27 <dcoutts> jbalint: hmm, I don't know of one but that doesn't mean one doesn't exist
17:46:37 <pmatos> I'm starting to get into a programming pattern which I would like to know how this is usually solved in a Haskell.
17:46:40 <skew> you could turn RWST r w s Identity into RWST r w s IO with that
17:46:49 <jbalint> dcoutts: okie. i'll let it slide for now. Thanks
17:47:04 <pmatos> Guess that I define the matrix type as an array so the constructor is Matrix (Array ...)
17:47:07 <dcoutts> jbalint: check pango's C docs
17:47:15 <jbalint> dcoutts: ok
17:47:19 <newsham> skew: http://wiki.laptop.org/go/OS_images_for_emulation
17:47:23 <dcoutts> jbalint: if there is one it's probably fairly easy to bind
17:47:32 <pmatos> Then I use pattern matching in function that receives the matrix: function (Matrix arr) = ...
17:47:49 <skew> newsham: I'm not so motivated yet, but thanks
17:48:08 <pmatos> but then, inside function I want to have access to the argument itself and not to arr. A solution is to do (Matrix arr) but this will probably penalize me.
17:48:14 <jbalint> dcoutts: maybe i'll dig into this weekend, looks like pango_parse_markup() returns an error
17:48:18 <pmatos> Is there anyway to get the unpatterned argument?
17:48:26 <mauke> pmatos: x@(Matrix arr)
17:48:27 <pmatos> and still managing to do the pattern matching?
17:48:33 <jbalint> dcoutts: i dont know if its used under the hood, right now i'm only using labelSetMarkup
17:48:56 <pmatos> mauke: :-D I haven't tried yet but it smells like that's what I want! :-) thank you!
17:50:02 <skew> pmatos: maybe even x@(Matrix _)
17:50:07 <ddarius> pmatos: Incidentally, wrapping and unwrapping won't penalize you if you used newtype.
17:50:10 <Toxaris> skew: cool. And I provide a function like (return . runIdentity) to mapRWST?
17:50:20 <skew> something like that
17:50:50 <skew> maybe you even want to take apart a plain RWS and rewrap as an RWST on Identity
17:50:59 <skew> never used it myself, but it sounds like what you are describing
17:51:12 <skew> if you actually want to be sure the parts that don't need IO don't use it
17:52:23 <Toxaris> skew: parts that don't need IO are polymorphic in the used monad
17:52:46 <Toxaris> skew: no need for an explicit Identity
17:52:48 <conal> skew: thanks for checking on -XGADTs.  what ghc version do you have?
17:52:57 <skew> conal: 6.8.1
17:53:16 <pmatos> skew: ddarius: thanks! :-)
17:54:27 <dcoutts> jbalint: there is code in Graphics.UI.Gtk.Pango.Markup for generating correct markup
17:54:29 <skew> conal: doesn't it work for you? I thought all the options were supposed to be listed in Language.Haskell.Extension.Extension, but this one isn't
17:55:21 <jbalint> dcoutts: but i have an input string and won't use it unless its valid markup, so a simple isValidMarkup would work best
17:55:23 <conal> skew: it sure doesn't.  odd.  i'll hpaste my trivial example.
17:55:50 <skew> conal: I was sure to test an example where the type itself is H98 even if the syntax is not
17:56:21 <skew> conal: nah, seems to work even in the indexed case
17:56:35 <conal> skew: thanks.  would you look at http://hpaste.org/4328
17:56:56 <dcoutts> skew: several were missing from the Extension list in 6.8.1, they're there in 6.8.2
17:57:07 <skew> conal: ah, it's complaining about the kind signature
17:57:20 <conal> oh -- another extension needed?
17:58:06 <skew> conal: KindSignatures
17:58:50 <conal> that one did it.  thanks much, skew.
17:59:08 <skew> conal: I don't know why it didn't helpfully suggest -XKindSignatures, as it suggested -XGadts
18:00:27 <sorear> @botsnack
18:00:28 <lambdabot> :)
18:00:30 <conal> skew: hit & miss
18:00:51 <pkrumins> Can't I write function definitions directly in Hugs?
18:01:40 <mauke> pkrumins: no
18:01:55 <pkrumins> okay
18:02:51 <nolrai> > runReader (1,2) (asks snd)
18:02:52 <lambdabot>  Couldn't match expected type `Reader r a'
18:03:02 <skew> A unit test, how quaint: Lemma count_occ_test_1 : count_occ 1 (1::2::1::3::nil) = 2. reflexivity. Qed.
18:04:01 <nolrai> > runReader (1,2) (ask >> return . fst)
18:04:02 <lambdabot>  Couldn't match expected type `Reader r a'
18:04:14 <nolrai> > runReader (1,2) (ask >> return )
18:04:15 <lambdabot>  Couldn't match expected type `Reader r a'
18:04:18 <ddarius> :t runReader
18:04:19 <lambdabot> forall r a. Reader r a -> r -> a
18:04:33 <nolrai> > runReader (ask >> return ) (1,2)
18:04:34 <lambdabot>  Couldn't match expected type `Reader r a'
18:04:46 <nolrai> > runReader (ask >>= return ) (1,2)
18:04:52 <lambdabot>  (1,2)
18:05:06 <nolrai> > runReader (asks fst ) (1,2)
18:05:06 <lambdabot>  1
18:05:12 <nolrai> > runReader (asks snd ) (1,2)
18:05:13 <lambdabot>  2
18:05:30 <ddarius> > asks snd (1,2)
18:05:32 <lambdabot>  2
18:05:47 <nolrai> ?!
18:05:47 <lambdabot> Maybe you meant: . ? @ v
18:06:17 <nolrai> lambdabot: no
18:06:21 <Toxaris> skew, nolrai: http://hpaste.org/4329
18:07:13 <ddarius> > snd (1,2)
18:07:14 <lambdabot>  2
18:08:10 <ddarius> > {- or really sick -} ask snd (1,2)
18:08:11 <lambdabot>  2
18:08:46 <dmwit> :t ask
18:08:47 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
18:08:55 <Toxaris> > local (const 3) succ 0
18:08:56 <lambdabot>  4
18:08:57 <dmwit> Oh, come on.
18:08:58 <davidL> @src sick
18:08:59 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:09:11 <mauke> > ask snd (ask (2, 1))
18:09:12 <davidL> oh
18:09:12 <lambdabot>  1
18:09:13 <davidL> lol
18:09:26 <nolrai> Toxaris++
18:09:28 <davidL> > {- this is a comment -} 1+1
18:09:29 <lambdabot>  2
18:16:46 <Toxaris> nolrai: we don't need runReader, 'cause we can exploit that funny (->)-monad again: http://hpaste.org/4329#a1
18:17:21 <OceanSpray> aw dang it
18:17:34 <OceanSpray> runtime errors
18:17:39 <dmwit> !
18:18:10 <dmwit> Oh, not using total functions? =P
18:19:35 <OceanSpray> how do I exit ghci?
18:19:54 <sieni> ctrl-d?
18:19:56 <conal> OceanSpray: :q
18:19:59 <OceanSpray> oh
18:20:01 <OceanSpray> thanks
18:20:08 <dons> ?yow
18:20:09 <lambdabot> UH-OH!!  I put on "GREAT HEAD-ON TRAIN COLLISIONS of the 50's" by
18:20:09 <lambdabot> mistake!!!
18:20:56 * dmwit wonders . o O ( He's never left GHCi... hardcore! )
18:21:50 <Toxaris> dmwit: there's :! after all
18:21:52 <OceanSpray> wow, this is weird.
18:21:57 <dmwit> heh
18:22:06 <OceanSpray> backspace doesn't work when I'm using my interpreter inside ghci
18:22:17 <mauke> that's ghci's fault
18:22:58 <OceanSpray> how do I go through a computation step by step?
18:23:08 <mauke> pen & paper
18:23:17 <OceanSpray> orz
18:23:21 <mauke> do you have ghc 6.8.1?
18:23:21 <Olathe> That's pretty horrid.
18:23:25 <OceanSpray> yeah
18:23:32 <mauke> I hear it can set breakpoints
18:23:36 <dmwit> :b
18:23:47 <dmwit> But you'll have to read the docs to really know how to use it.
18:23:50 <OceanSpray> oh screw it.
18:23:57 <Olathe> It would be nice if it could show a function being followed strictly.
18:24:08 <OceanSpray> I'll just put some putStrFlush's in there and see what they output.
18:24:35 <dmwit> ...or you could (hSetBuffering NoBuffering stdout >> main)...
18:24:45 <dmwit> :t putStrFlush
18:24:49 <lambdabot> Not in scope: `putStrFlush'
18:24:52 <OceanSpray> doesn't matter.
18:25:47 <OceanSpray> anybody here willing to take a look at my code?
18:27:04 <dmwit> Just hpaste it, if we're not willing we won't look. ;-)
18:29:07 <OceanSpray> this is taking a while.
18:29:51 <dmwit> I blame you.
18:31:31 <OceanSpray> Hm
18:31:32 <OceanSpray> it's up
18:31:44 <OceanSpray> http://hpaste.org/4330
18:31:47 <dmwit> (part of it, at least)
18:32:00 <OceanSpray> oh boy.
18:32:14 * dmwit wanders off
18:32:54 <OceanSpray> http://pastebin.ca/808972
18:33:37 <Toxaris> OceanSpray: do you ask for general comments?
18:33:47 <OceanSpray> yeah
18:33:59 <Olathe> My eyes !
18:34:03 <OceanSpray> wow
18:34:09 <OceanSpray> It's that ugly?
18:34:19 <conal> OceanSpray: does it compile?
18:34:20 <Toxaris> OceanSpray: wait a moment, I have to enlarge the window containing hpaste-org to cover both screens
18:34:29 <OceanSpray> conal, it does.
18:34:43 <OceanSpray> but I'm running into runtime errors.
18:34:52 <mauke> there's no way to join an Applicative, right?
18:34:59 <mauke> because otherwise it would be a monad
18:35:01 <conal> mauke: right
18:35:05 <Toxaris> mauke: i think so, yes
18:35:23 <OceanSpray> See, every time I use 'flambda' to create a procedure, and then try to apply it, it fails.
18:35:23 <Toxaris> OceanSpray: you should consider using more newlines
18:35:26 <mauke> so much for lifting Applicative then
18:35:29 <conal> mauke: i assume you mean an arbitrary applicative.
18:35:49 <mauke> yeah, I was trying to write instance (Applicative m) => Applicative (ParserT s m)
18:35:49 <OceanSpray> Says that it's expecting a procedure, but instead gets the argument's type.
18:36:21 <conal> mauke: where does it break down?
18:36:44 <conal> i wonder where parsers use monadness rather than applicativeness
18:36:50 <Toxaris> mauke: do you have instance Monad (ParserT s m)?
18:37:14 <mauke> af <*> ax = ParserT $ \s -> unParserT af s `tfilA` \(e, r) -> r `tfilA` \(f, s') -> unParserT
18:37:18 <mauke> and then my brain got stuck
18:37:43 <mauke> Toxaris: yes
18:38:25 <Toxaris> mauke: so if you have monad, and want applicative, define (<*>) = ap. or did i miss the point?
18:38:36 <mauke> Toxaris: it's only a monad if m is a monad
18:38:59 <Toxaris> mauke: oh, you're applying a monad transformer on a mere Applicative and hope to get another Applicative out?
18:39:07 <mauke> right
18:39:14 <mauke> it works for Functor :-)
18:39:58 <dmwit> ?src Applicative
18:39:58 <lambdabot> class Functor f => Applicative f where
18:39:58 <lambdabot>     pure  :: a -> f a
18:39:58 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:39:59 <conal> mauke: i don't think you need transformers for Applicative.  Use type composition instead.
18:40:14 <mauke> what's that?
18:40:17 <pkrumins> ?src last
18:40:17 <lambdabot> last [x]    = x
18:40:17 <conal> @wiki TypeCompose
18:40:17 <lambdabot> last (_:xs) = last xs
18:40:17 <lambdabot> last []     = undefined
18:40:17 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
18:40:53 <conal> one of the many cool things about Applicative is that they compose.  so the whole Foo vs FooT thing goes away.
18:41:00 <conal> it's very fun.
18:41:35 <conal> much more elegant than Monad
18:43:12 <conal> mauke: for an example use of type composition, see http://www.haskell.org/haskellwiki/DataDriven#Composing_Sources
18:43:13 <lambdabot> Title: DataDriven - HaskellWiki
18:43:44 <Japsu> @src ap
18:43:44 <lambdabot> ap = liftM2 id
18:44:15 <conal> @ty (<*>)
18:44:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:44:23 <Japsu> hm
18:44:31 <Japsu> > ap [1,2]
18:44:32 <lambdabot>   add an instance declaration for (Num (a -> b))
18:44:32 <lambdabot>     In the expression: 2
18:44:33 <conal> Japsu: <*> generalizes ap
18:44:53 <Japsu> oh, M2
18:44:54 <Japsu> not M
18:45:43 <Toxaris> > ap [succ, pred] [10, 20]
18:45:44 <lambdabot>  [11,21,9,19]
18:46:37 <conal> > [succ, pred] <*> [10, 20]
18:46:38 <lambdabot>  [11,21,9,19]
18:46:44 <mauke> conal: but I still need an Applicative instance for my parser
18:47:02 <conal> mauke: is it a monad?
18:47:12 <mauke> if m is a monad, yes
18:47:21 <conal> then use the standard Applicative instance: pure = return; (<*>) = ap
18:47:35 <mauke> instance (Monad m) => Applicative (ParserT s m)
18:47:46 <Toxaris> mauke: what is ParserT?
18:47:47 <mauke> I just wanted to see if instance (Applicative m) => Applicative (ParserT s m) was possible
18:47:57 <mauke> data ParserT s m a = ParserT { unParserT :: Counted s -> m (IResult s a) }
18:48:27 <conal> mauke: what are Counted and IResult ?
18:49:03 <mauke> data Counted s = Counted !Int s; type IResult s a = (Error s, [(a, Counted s)])
18:49:57 <conal> mauke: how about simplifying to Parser s a, without the m.  then composing.
18:50:14 <mauke> I thought you can't compose monads
18:50:25 <conal> i mean for Applicative.
18:50:38 <conal> applicative composes.  monad doesn't
18:51:00 <mauke> I don't really need Applicative anyway
18:51:09 <Toxaris> mauke: you can compose monads. the result may not be monadic, though. (as i understand it)
18:51:11 <conal> then never mind.  my suggestion is probably not helpful if you want applicative and not monad.
18:51:21 <conal> yes -- what Toxaris said
18:51:30 <conal> monads compose, but not into monads.
18:52:25 <Toxaris> mauke: have you a specific applicative, but non-monadic m in mind?
18:52:33 <mauke> no
18:52:41 <mauke> I just like *> and <*
18:53:06 <Toxaris> mauke: then i would define instance Monad m => Applicative (ParserT s m)
18:53:08 <conal> does anyone know a reason to use the Monad interface to parsing instead of the simpler Applicative?  just a historical accident?
18:53:55 <pjd> when you do need bind/join
18:54:21 <mauke> I don't know how to parse with Applicative
18:54:27 <mauke> are there any docs?
18:54:45 <Toxaris> the very first thing I do when parsing is defining an Applicative instance for my parser monad
18:55:08 <conal> mauke: the question is whether you ever need to use >>=, or you can get away with fmap, liftM, liftM2, ... and ap.
18:55:30 <conal> mauke: if the latter, then your code will be more functional/applicative looking.
18:55:44 <conal> parsing seems not to need >>=, from what i've seen.
18:57:45 <mauke> bah, why is Functor not a superclass of Monad
18:58:00 <conal> mauke: an oops.
18:59:45 <Toxaris> conal: consider (between (string "let") (string "in") decls >>= expression)
19:00:25 <Toxaris> conal: wich combines name resolution with parsing (wich may be a bad idea in the first place)
19:00:38 <conal> Toxaris: what's between?
19:00:51 <conal> oh -- bracketing
19:01:07 <mauke> string "let" *> decls <* string "in"
19:01:30 <conal> Toxaris: and the type of expression?
19:01:44 <Toxaris> conal: [Decl] -> Parser Expression
19:01:54 <conal> Toxaris: i see.
19:02:22 <conal> Toxaris: the >>= use isn't really helping parsing, is it?
19:02:34 <conal> more like static analysis
19:02:39 <Toxaris> conal: define parsing
19:02:49 <OceanSpray> Oh I see what the problem is now.
19:03:38 <conal> with a liberal enough definition of "parsing", then sure -- bind would be plenty useful.
19:04:30 <mauke> hmm, the infrastructure compiles but I still don't have any parsing primitives :-)
19:05:33 <conal> i'm still curious whether Monad-minus-Applicative is useful for the classic notion of "parsing".  i guess the answer is no for context-free languages, and perhaps yes for context-sensitive.
19:05:37 <byorgey> mauke: if the infrastructure compiles, that's 80% of the work =)
19:05:54 <byorgey> mauke: now just write the type of your parsing primitives, and infer the code =)
19:06:17 <mauke> kind of hard to do. I plan on having three different versions of <|>
19:08:26 <Toxaris> conal: the "freedom" one feels when using monadic parser combinator aproaches comes from not being restricted to context-whatever grammars, but instead working in a very open framework. that freedom goes (partly) away when restricting to Applicative. what are the benefits?
19:09:03 <conal> Toxaris: makes sense to me.  thanks for the explanation.
19:09:47 <conal> Toxaris: benefits: simplicity, functional style, amenability to static analysis (lookahead set generation, etc)
19:13:32 <OceanSpray> what should I use, Happy or Parsec ?
19:14:06 <smack_>     Could not find module `System.Process':
19:14:06 <smack_>       it is a member of package process-1.0.0.0, which is hidden
19:14:18 <smack_> 'ghc-pkg list' shows it as unhidden...
19:14:30 <conal> smack_: using cabal?
19:14:39 <smack_> conal: gentoo haskell overlay
19:14:39 <Toxaris> OceanSpray: I recommend Parsec, it's a joy to work with. (don't forget to define and use instance Applicative (GenParser ...))
19:14:46 <smack_> conal: which is using cabal, i believe
19:14:57 <conal> smack_: how are you compiling?
19:15:18 <smack_> conal: just doing emerge hxt, 7.3
19:15:35 <OceanSpray> ok then.
19:15:41 <smack_> haskell-cabal_src_compile...
19:16:07 <conal> smack_: i don't know linux.  maybe someone else can help you.
19:16:07 <OceanSpray> but what's that Applicative (GenParser ...) thing?
19:16:14 <smack_> conal: thanks anyway
19:16:31 <OceanSpray> smack_, try '-package process'
19:16:45 <OceanSpray> actually, I don't know either.
19:17:10 <conal> cabal-based builds turn on -hide-all-packages, or some such.
19:17:18 <mokus> ghc 6.8.1 has many new packages broken out of base, which confuses the heck out of cabal
19:17:29 <mokus> add process to the Depends line in the .cabal file
19:17:31 <conal> so i though maybe "process" got omitted from the "dependencies" line in the .cabal file.
19:17:45 <OceanSpray> #ghc ?
19:17:50 <conal> yeah -- what mokus said
19:18:03 <smack_> gotcha, thanks
19:18:08 <Toxaris> conal: i can benefit from functional style without using a Applicative-only library. simplicity: would I understand what happening in an applicative-only parser? (I don't always do in Parsec, have to experiment) static analysis sounds very good, a theoretical link between parser combinator aproaches and grammar classes would be nice
19:18:22 <mokus> unfortunately, it only tells you the first dependency that fails
19:18:28 <mokus> and there are usually around 10
19:18:30 <mokus> :(
19:18:33 <OceanSpray> :t Applicaive
19:18:34 <lambdabot> Not in scope: data constructor `Applicaive'
19:18:37 <OceanSpray> :t Applicative
19:18:37 <lambdabot> Not in scope: data constructor `Applicative'
19:18:41 <mokus> so you have to rinse, lather, repeat
19:18:42 <byorgey> OceanSpray: Control.Applicative
19:18:49 <OceanSpray> what does it do?
19:19:05 <conal> OceanSpray: it's like Monad but simpler
19:19:06 <byorgey> provides niftiness
19:19:15 <conal> :o
19:19:22 <OceanSpray> I already wrote my parser, so does it matter now?
19:19:55 <byorgey> probably not, but you could learn about it for later.
19:20:07 <smack_> yeah, hxt.cabal is missing process, added in 7.4
19:21:29 <Toxaris> OceanSpray: You asked about using happy or parsec, how can you have already written your parser?
19:21:53 <OceanSpray> I already have a Parsec parser, but I wondered whether happy is 'better'?
19:22:04 <OceanSpray> The question was misleading. Sorry.
19:22:50 <Toxaris> OceanSpray: Applicative lies between Functor and Monad. you can gradually move from monadic to applicative style, wich is (in my eyes) more concise and easier to understand
19:23:55 <Toxaris> > [1, 2, 3] >>= \x -> "abc" >>= \y -> return (x, y) -- product set in monadic style
19:23:56 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
19:24:20 <Toxaris> > (,) <$> [1, 2, 3] <*> "abc" -- same in applicative style
19:24:20 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
19:24:23 <conal> OceanSpray: learning Applicative may influence your programming style when *using* your parser.  Applicative code is more functional-looking, less sequential.  and it's not an all-or-nothing thing.  start looking for ways to use fmap, liftM, liftM2, and maybe ap in place of do and >>=.  you'll probably like the results, if you like functional programming.  at some point, you could replace uses of fmap, liftM, liftM2, ap, with <$>,
19:24:23 <conal> liftA, liftA2, <*>.
19:29:48 <conal> yo andyjgill
19:30:00 <andyjgill> Hi conal
19:30:12 <conal> andyjgill: how go things?
19:30:43 <andyjgill> Tired tonight; been a long, long week
19:31:07 <conal> andyjgill: restful weekend ahead?
19:32:05 <andyjgill> Get a tree; visit powells is the plan, a bit of Galois work.
19:32:25 <conal> sounds pretty pleasant.
19:33:17 <andyjgill> Not too bad :-)
19:33:54 <andyjgill> Might to time to sorts out wxHaskell.
19:34:06 <conal> andyjgill: on Mac?
19:34:19 <conal> i.e., MacOS ?
19:34:22 <andyjgill> Yes. There are issues, I believe
19:34:31 <conal> i've heard there may be.
19:35:00 <conal> i hope it goes well.
19:35:12 <andyjgill> Thx
19:36:26 <conal> btw, Applicative + type composition is a winning combo.  i just made a simple type of reactive values (using a new STM-based IVar impl), plus a simple, slightly optimized type of functions, and then type-composed them in to reactive behaviors.  with an efficient data-driven implementation.
19:36:43 <conal> type ReactiveB = Reactive :. Fun Time
19:41:06 * Toxaris wants Maybe in Java instead of (name == null ? null : intern(name))
19:41:12 <newsham> for a Fun Time
19:41:38 * mokus wants a lot of things in java instead of a lot of things...
19:41:54 <mokus> but maybe would be a realy nice start
19:42:29 <lament> how would maybe work?
19:42:51 <mokus> I like the objective C model for method calls
19:42:52 <pkrumins> I have just begun learning Haskell. Does Int -> (Int -> Int) mean that a function takes an integer and returns a function taking and integer and returning an integer?
19:42:56 <mokus> [nil foo] is a no-op
19:43:04 <Zao> Yes, pkrumins.
19:43:26 <pkrumins> good
19:43:52 <pkrumins> If so, then I can always look at it in a way that the arguments is everything that comes before first left arrow and value is everything after?
19:44:17 <lament> note that Int -> Int -> Int means the same thing
19:44:27 <lament> as Int -> (Int -> Int)
19:44:35 <pkrumins> yup
19:44:40 <newsham> :type \a b -> a + (b :: Int)
19:44:52 <newsham> ?type \a b -> a + (b :: Int)
19:44:52 <pkrumins> what does the \a do?
19:44:53 <lambdabot> Int -> Int -> Int
19:45:01 <newsham> ?type (\a b -> a + (b :: Int)) 3
19:45:03 <lambdabot> Int -> Int
19:45:06 <newsham> ?type (\a b -> a + (b :: Int)) 3 5
19:45:07 <lambdabot> Int
19:45:12 <newsham> > (\a b -> a + (b :: Int)) 3 5
19:45:13 <lambdabot>  8
19:45:20 <Zao> pkrumins: lambda function with two arguments, a and b.
19:45:27 <newsham> \a -> a+3  is a function with one argument that returns that argument plus 3
19:45:28 <pkrumins> oic.
19:45:42 <Toxaris> lament: well, I want the equivalent of (fmap intern name), wich could look like fmap(intern, name), if their were first-class functions in java. in existing java, one could encode intern as an Function Object and do something like fmap.apply(intern, name)
19:46:27 <lament> pkrumins: it makes sense somehow to think of, say, (+) as a function that takes two integers and returns an integer
19:46:43 <newsham> > (+) 3 5
19:46:44 <lambdabot>  8
19:46:47 <lament> whereas in reality it takes one, and returns a function that takes the other
19:46:57 <newsham> > ((+) 3) 5
19:46:58 <lambdabot>  8
19:47:22 <lament> pkrumins: you could think of it both ways, but the latter is "what actually happens"
19:47:22 <conal> newsham is lament's lovely assistant
19:47:30 <andyjgill> (back from putting kids to bed) What do you mean by Applicative + type composition, conal?
19:47:55 <pkrumins> lament, kk
19:47:56 <Toxaris> lament: java's typesystem is not so bad IMO, but it's syntax destory any hope for sensible encoding of stuff - you have to go for short encoding to make it usable
19:48:18 <conal> andyjgill: applicative functors (AFs) compose into AFs.  so one can write nicely modular AFs and simply compose them.
19:48:19 <newsham> i'm a regular old vanna white
19:48:33 <flippo> Funny, you don't look much like her.
19:48:36 <Toxaris> (but how cares about java, if we have conal here speaking about type composition, wich is so much cooler)
19:48:46 <andyjgill> Ahh. neat.
19:48:47 <lament> true
19:49:09 <Toxaris> conal: is your "compose" like (.) but on Functors (that is, on type and function level at once)?
19:49:25 <conal> andyjgill: very.  see an example at http://www.haskell.org/haskellwiki/DataDriven#Composing_Sources
19:49:26 <lambdabot> Title: DataDriven - HaskellWiki
19:49:47 * mokus tries not to care about java, but it's hard when you have to use it at work
19:49:55 <conal> Toxaris: it composes type constructors.  e.g., "[] :. []" is a list of lists
19:50:05 <conal> but with an extra type constructor.
19:50:24 <pkrumins> Huggs or HGC?
19:50:48 <conal> the nice thing is that Functor and Applicative instance for :. do some of the work.
19:51:00 <pkrumins> I started learning Haskell from Graham Hutton's book, he uses Hugs
19:51:21 <Olathe> Hugs is the work of Satan ! ghc is the one true compiler !
19:51:50 <newsham> satan's been busy
19:51:54 <Olathe> Yes.
19:52:01 <Olathe> He has lots of minions, though.
19:52:13 <Toxaris> conal: oh, and these new types get their interface via approbiate instances (like: instance (Functor a, Functor b) => Functor (a .: b) where fmap f (Composed x) = fmap (fmap f) x
19:52:21 <Toxaris> aproximately
19:52:42 <newsham> i heard he started hiring developers in vancouver because of H1B problems.
19:52:58 <Toxaris> and in the end, you can compose types like ordinary fp programmers compose functions
19:53:28 * skew mubles about dependent types
19:53:44 <andyjgill> conal: Interesting stuff.
19:53:46 <skew> now composing functors easily, that's interesting
19:54:24 <skew> nice that the extra structure is carried along for you, that is
19:54:45 <andyjgill> How does it related to O'Haskell's reactive model of computation, which is also data-driven.
19:55:03 <conal> andyjgill: O'Haskell is imperative, isn't it?
19:55:17 <andyjgill> Sort of.
19:55:39 <conal> Toxaris: yes.  and similarly for Applicative.  see TypeCompose for these & more goodies.
19:55:46 <andyjgill> Its reactive. You pass events to objects, and can *not* wait for responses.
19:56:08 <andyjgill> You can send a callback, and ask it be called when something happens
19:56:31 <conal> andyjgill: and the callback is an action, right?  that's what i mean by imperative.
19:56:51 <andyjgill> Yes, it uses the O monad. No input, only output.
19:57:13 <conal> andyjgill: i'll check it out again.  it's been a long time.
19:57:33 <conal> generally i like functional programming, not so much imperative programming in a functional language (IO).
19:58:18 <conal> i like simple & powerful denotational semantics.  which then leads to tractable reasoning and powerful composition.
19:58:26 <andyjgill> That actually is why I like O'Haskell (and Timber), because it is *not* IO based.
19:58:31 <conal> that's why i'm sorry people are still programming with IO after all these years.
19:58:48 <conal> andyjgill: and yet -- do they have simple (denotational) semantics?
20:00:42 <conal> on o'haskell: "Actions, requests and templates are all examples of expressions that denote commands in the monad Cmd. Cmd is actually a type constructor, with Cmd a denoting the type of reactive commands that may perform side-effects before returning a value of type a."
20:00:46 <conal> http://www.cs.chalmers.se/~nordland/ohaskell/survey.html
20:00:47 <lambdabot> Title: A survey of O'Haskell
20:01:07 <andyjgill> I'm having dinner with Johan tomorrow; I'll ask him about it.
20:01:48 <conal> neat!  is Johan in portland??  not in northern sweden?
20:02:21 <andyjgill> Yes, for the next few days, but he is coming back in Feb~April for a longer visit.
20:02:45 <conal> fun.  enjoy. :)
20:02:54 <jelousbuddy> what does stupid paki mean? has any of you ever felt any great pain? how was it? !!! was it accident? how bad can it be if i am in a car accident for ex got hit by a train but still alive? or half burnt my entire skin including eyes? how about heart attack / failure?
20:03:06 <jelousbuddy> what does stupid paki mean? has any of you ever felt any great pain? how was it? !!! was it accident? how bad can it be if i am in a car accident for ex got hit by a train but still alive? or half burnt my entire skin including eyes? how about heart attack / failure?
20:04:05 <andyjgill> Could you arrange a visit to PDX, for some sort of brainstorming in Feb~April?
20:04:07 <conal> andyjgill: meanwhile, i'll read up on O'Haskell.  it may be relevant to some of my current ideas.  thanks.
20:04:41 <conal> andyjgill: sure, if sufficiently motivated.  or maybe you guys could have a retreat here in the woods.
20:05:16 <andyjgill> Nothing wrong with northern CA! Thanks for the offer
20:05:41 <conal> it's really lovely here.  i rarely want to leave.  even to go into town to get the mail.
20:06:02 <conal> oog.  i get so discouraged when i see imperative programming in haskell.
20:06:16 <Zao> do $ do $ do
20:06:29 <andyjgill> Portland got about 5 inches of rain last weekend - i did want to leave
20:08:13 <skew> conal: what languages have nice semantics for concurrency? FRP? datalog?
20:08:35 <skew> conal: and are you far enough north those woods see snow?
20:09:00 <conal> skew: FRP (at least Fran) has extremely simple semantics with deterministic concurrency.  i don't know datalog.
20:09:42 <conal> skew: i'm at 1200 feet.  we get occasional snow.  not much.  we're down a dirt road, and 4-wheel drive helps sometimes.
20:09:49 <skew> conal: the network datalog from the P2 group at berkeley seems nice
20:10:26 <conal> skew: deterministic?
20:10:31 <conal> skew: i'll look.  thanks.
20:10:51 <skew> datalog is basically prolog without much in the way of compound data
20:11:01 <skew> so predicates can be interpreted as tables as in a relational database
20:11:20 <skew> the semantics is just the least fixed-point of the rules and asserted facts
20:11:36 <conal> skew: with some form of concurrency?
20:12:11 <conal> oh, btw, another property i like a lot is *continuous* time.  natural for modeling and nicely composable.
20:12:14 <skew> that comes from rules for incrementally updating the derived facts as new things are asserted
20:12:53 <conal> skew: a concurrent implementation, more than some kind of visible concurrency.
20:12:55 <conal> ?
20:14:31 <skew> it's sort of visible
20:15:02 <skew> it's not so much a language you'd program something arbitrary and complicated in
20:15:02 <conal> concurrency in FRP is incredibly simple.  if f is a (continuously) time-varying function and x is a time-varying argument, then f <*> x is a time-varying result.
20:15:18 <conal> skew: i just checked out the wikipedia article.
20:15:59 <conal> (though i didn't know about Applicative when i did Fran.)
20:16:00 <skew> the unless that's specifically P2, network datalog or "declarative networking" there is still a bit missing
20:17:00 <skew> If anything the network datalog stuff is more basic
20:17:37 <skew> you have your set of rules, time-varying input, and time-varying output
20:18:09 <skew> the interesting thing is that they show how to make this all work even if they values are distributed all around a network, and you've got all the usual packet loss and whatever
20:18:23 <conal> skew: that's *very* nice.
20:19:17 <skew> oh, and incrementally joining against just the affected tuples in the relation as data comes or goes
20:20:22 <conal> skew: sounds wonderful.  would you please recommend a paper for me to read?
20:20:41 <skew> they just talk about overlay networks and network protocols, but datalog is a fine query language for relational databases
20:21:16 <skew> http://p2.cs.berkeley.edu/p2pubs.php the one at the top describes the execution
20:21:17 <lambdabot> Title: P2: Declarative Networking
20:21:48 <conal> skew: thanks!
20:22:36 <skew> conal: so I think you could use this to declaratively specify something like the complete database tier of some buisness application
20:23:40 <skew> (that's an interpretation you won't see in any of their papers - maybe those enterprise buisness rule engines already cover that?)
20:26:16 <conal> skew: what's an "overlay network"?
20:27:39 <skew> conal: building your own communication over the existing internet. Making and maintaining a multicast tree or something
20:27:54 <conal> got it
20:50:01 <dons> curious haskell tag cloud, http://wiki.chainofthoughts.com/dt/en/Haskell%20(programming%20language)
20:50:03 <lambdabot> http://tinyurl.com/387pfr
20:50:24 <mgsloan> hmm, haskell + sarcasm == XKCD?!?!
20:51:15 <dons> math + language + love == haskell
20:51:48 <mgsloan> well, the topic says math + romance + language == haskell
20:52:13 <mgsloan> and xkcd is a webcomic of romance, sarcasm, math, and language
20:52:31 <dons> so it does.
20:53:30 <lament> ddarius provides the sarcasm.
20:53:49 <lament> also, tag clouds are the worst way to represent anything ever.
20:53:50 <dons> oh, we've a bunch of them
20:53:55 <mgsloan> anyway, is there a chance that galois will participate in the Oregon State University "MECOP", Multiple Engineering Cooperative Program (internship program)
20:54:03 <dons> Korollary and monochrom too
20:55:56 <nanothief> i'm having a problem with an IO function I wrote at http://hpaste.org/4331
20:56:10 <nanothief> i can't figure out what is wrong with the types of the function (causing the errors)
20:57:14 <dons> let's have a look.
20:57:21 <Toxaris> nanothief: the a in the signature of cpsReadFile is *not* the same as the a in the signatures of normalFunc and errFunc
20:57:35 <nanothief> Toxaris: I know, but it shouldn't matter
20:57:41 <dons> right.
20:57:46 <Toxaris> nanothief: sure it does
20:57:46 <dons> you'll need to bind them with a forall
20:58:03 <Toxaris> normalFunc :: IO a means that normalFunc can return any a the *caller* wants
20:58:05 <dons> or leave the type sigs off
20:58:20 <nanothief> dons: forall?
20:58:25 <Toxaris> but return (suceedF text) means that succeedF decides wich a to return, not the caller of normalFunc
20:58:30 <dons> its a good example actually, of a few different idioms we can use instead
20:58:34 * dons refactors a bit
20:58:55 <nanothief> Toxaris: oh i see
20:59:12 <dons> so, you can leave off the type signatures, for example
20:59:35 <dons> or use a type signature like:
20:59:36 <dons>   cpsReadFile :: forall a . FilePath -> (String -> a) -> (String -> a) -> IO a
20:59:37 <nanothief> dons: ha i should have tried that earlier, it compiles like that
20:59:42 <dons> which explicitly binds 'a'
20:59:50 <dons> but that's an extension to h98
21:00:18 <nanothief> so forall a binds the previously defined 'a' for this functions type signature?
21:00:31 <allbery_b> it's a ghc extension, scoped type vars
21:00:39 <Toxaris> nanothief: no, you use forall a in the type signature of cpsReadFile
21:01:08 <Toxaris> nanothief: and then it is automatically bound for normalFunc and errFunc too
21:01:55 <nanothief> Toxaris: right
21:02:59 <Toxaris> nanothief: but what about that: a shorter way to write (do value <- action; return (f value)) is simply (fmap f action)
21:03:01 <dons> http://hpaste.org/4331#a1
21:04:07 <Toxaris> wich yields what dons has written (given that <$> is another name for fmap)
21:04:20 <dons> yeah
21:04:46 <nanothief> never seen the <$> operator before, looks very useful
21:05:10 <Toxaris> nanothief: yeah, it can do a lot of things
21:05:10 <nanothief> anyway, thanks
21:06:27 <Toxaris> in your case, it enables you to use cps-like functions even without explicit cps
21:07:36 <Toxaris> since you can use (succeedF <$> readFile f `catch` failF)
21:07:40 <Toxaris> or something similar
21:09:42 <nanothief> Toxaris: that looks very nice
21:12:23 <nolrai> > lines "a\nb\nabc\n"
21:12:25 <lambdabot>  ["a","b","abc"]
21:12:26 * Toxaris wonders how it would be to learn about Functor (and Applicative?) before Monad
21:13:37 <dons> mm.
21:13:58 <dons> conal would like that
21:14:20 <conal> indeed!
21:14:24 <dons> it could well be more natural, and encourage a better FP style once dealing with effectful things
21:14:51 <conal> monads tempt FP newbies to stay stuck in sequential thinking.
21:14:56 <dons> right.
21:15:14 <dons> we'll need to constructor "Introduction to monads ... without monads" tutorial :)
21:15:21 <dons> constructor ?
21:15:31 * dons gets lost in haskell sometimes
21:15:42 <conal> lol
21:15:42 <mgsloan> The Other Prelude ftw
21:15:45 <dons> s/constructor/write a/
21:16:21 <Toxaris> but it would be harder to motivate. can you keep the interested newbie away from IO long enough?
21:16:35 <dons> parsers ftw!
21:16:41 <Nafai> dons: Crap, if you get lost in Haskell, I've got problems :)
21:16:53 <dons> Nafai: i mean, lost deep inside it, that i forget normal words :)
21:17:03 <dons> i try to fmap over my breakfast
21:17:21 * dons $ dinner
21:17:36 <Nafai> Heh
21:17:37 <Toxaris> dons is out of sync
21:17:37 <conal> buys dinner?
21:17:48 <Toxaris> he tries to eat everything at once
21:23:44 <dmwit> Nah, he eats lazily, as he gets hungry. ;-)
21:24:00 <dmwit> "Wizard needs food, badly!"
21:29:43 <nolrai> > [a..] ! 3
21:29:45 <lambdabot>   Not in scope: `a'
21:29:48 <bos> dons: are you coming to PADL?
21:29:50 <nolrai> > ['a'..] ! 3
21:29:51 <lambdabot>  Couldn't match expected type `Array i e'
21:29:58 <nolrai> > ['a'..] !! 3
21:29:59 <lambdabot>  'd'
21:30:30 <bos> hm, missed him
21:30:47 <bos> i would have thought it would be dons `ap` dinner anyway
21:31:04 <mrd> takeWhile hot
21:31:24 <shachaf> bos: Not dons =<< dinner?
21:31:30 <nolrai> mrd: lol
21:32:43 <conal> bos: dons <*> dinner
21:32:44 <sclv> forall d. (Food d) => d -> Stomach d
21:33:02 <sclv> it puts it in the digestive monad.
21:33:23 <mrd> unsafePerformDigest
21:33:24 <bos> conal: quite, unless he's anorexic, in which case it would be dons *> dinner
21:33:29 <sclv> or, er, I  guess comonad? (comonads are consumers)
21:33:35 <bos> er, <*
21:34:11 <bos> Control.Applicative is the shiny new toy of this winter. get an applicative functor for your kids while they're still in stock!
21:35:31 <mrd> doesn't quite roll off the tongue like Monad
21:37:01 <bos> if monads are warm fuzzy things, then applicative functors, on account of being more generally usable, must be even warmer and fuzzier. we should refer to them as fennecs
21:49:11 <glguy> hmm, how do I write a regex for "longest string not containing a specific substring?
21:49:15 <glguy> "<%" in this case
21:49:39 <dmwit> grep -v
21:49:44 <dmwit> oh
21:49:47 <dmwit> not quite
21:50:32 <kamiphlauge> not containing either or that exact occurence
21:50:40 <dons> [^(<%)]* ?
21:50:54 <nolrai> @type ap
21:50:56 <dmwit> "[^<]*(<[^%][^<]*)*"
21:50:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:50:57 <bos> glguy: you can't write negative assertions like that without perl extensions
21:51:37 <dmwit> bos: All DFA's can be negated to create another DFA.
21:52:08 * bos is really tired of writing book examples that don't use monads
21:52:25 <mrd> sadly POSIX regex syntax doesn't include syntax for complement
21:52:25 <nolrai> @h
21:52:26 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
21:52:33 <nolrai> @help
21:52:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:52:40 <nolrai> @g
21:52:40 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . ? @ v
21:52:54 <glguy> I doing this in alex
21:53:09 <glguy> so anything that is available in alex to do this?
21:53:25 <nolrai> whats the comand that looks an item of the given type?
21:53:25 <glguy> I have a workaround if not
21:53:41 <dmwit> ?hoogle [a]
21:53:43 <lambdabot> Prelude.repeat :: a -> [a]
21:53:43 <lambdabot> Data.List.repeat :: a -> [a]
21:53:43 <lambdabot> Prelude.tail :: [a] -> [a]
21:53:53 <mrd> @djinn a -> [a]
21:53:53 <lambdabot> -- f cannot be realized.
21:54:08 <dmwit> ?djinn (Monad m) => a -> m a
21:54:27 <dmwit> ?bot
21:54:28 <lambdabot> :)
21:54:47 <nolrai> @djinn (a -> b) -> (m a) -> m b
21:54:49 <lambdabot> -- f cannot be realized.
21:54:56 <nolrai> @hoogle (a -> b) -> (m a) -> m b
21:54:57 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
21:54:57 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
21:54:57 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
21:55:07 <dmwit> ?type fmap
21:55:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:55:09 <mrd> @djinn a -> (a -> a) -> (a -> Int) -> Int
21:55:09 <lambdabot> f a b c = c (b a)
21:55:14 <dmwit> ?type liftM
21:55:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:55:34 <nolrai> liftM thats it.
21:55:35 <dmwit> ?type (<$>)
21:55:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:55:49 <dmwit> TMTOWTDI
21:55:59 <bos> please, enough lambdabot spam already
21:56:31 <dmwit> sorry
21:57:12 <nanothief> is there any place to try out the lambdabot without spamming the channel?
21:57:21 <glguy>  /msg
21:57:22 <mrd> msg
21:57:31 <mrd> get a room, you two!
21:57:43 <mrd> /query lambdabot
21:58:20 <nanothief> sweet... spam time :D
22:01:22 <Brian`> hi, i have a question
22:01:34 <Zao> Brian`: Ask away.
22:01:38 <Brian`> let's say I have "data Basket a = Basket a"
22:01:43 <Brian`> and
22:01:51 <mrd> hmm, a Basket case
22:01:52 <Brian`> instance Show (Basket a) where
22:02:03 <Brian`> show k = case k of
22:02:14 * Zao hides mrd in the BadJokes monad.
22:02:15 <Brian`> Basket APPLE -> "APPLE"
22:02:17 <Brian`> and so on..
22:02:26 <mrd> you don't know anything about a
22:02:34 <Brian`> it will be about..
22:02:42 <Brian`> data Fruit = APPLE | BANANA
22:02:44 <Brian`> and so on...
22:02:50 <mrd> right but in the instance, you don't know that
22:03:00 <mrd> it's "forall a"
22:03:13 <Brian`> so how do I write it ?
22:03:13 <mgsloan> you could have Basket Int
22:03:18 <Brian`> yeah
22:03:27 <Brian`> so if i want it to be of type Fruit?
22:03:37 <mrd> data Basket = Basket Fruit
22:03:55 <Brian`> i mean at instance Show part...
22:04:06 <mrd> well you need to be more specific about 'a'
22:04:11 <Brian`> data Basket a will still remain as Basket a...
22:04:13 <Brian`> hm..
22:04:39 <Brian`> so what I'm trying to do is Basket can contain any type say Fruit, String (-_-;), Int and so on
22:04:45 <Brian`> but for "instance Show"
22:04:50 <Brian`> I'd like to specify for Fruit only
22:05:04 <mgsloan> instance Show (Basket Fruit) where
22:05:12 <Brian`> hm.. ok hold on let me try
22:05:24 <mrd> mgsloan: i think thats illegal in H98
22:05:30 <mgsloan> is it?
22:05:38 <faxathisia> `Hello!
22:05:45 <mrd> however you could have instance (Basketable a) => Show (Basket a)
22:05:49 <Brian`> it still fails..
22:05:58 <mrd> and define a class Basketable
22:06:05 <Brian`> oh.. i c
22:06:15 <mrd> and then do Fruit specific stuff in there
22:06:19 <Brian`> yeah
22:06:32 <mrd> but actually
22:06:39 <mrd> you may just want (Show a) => Show (Basket a)
22:06:52 <mrd> then you can use show on the subterm
22:07:23 <Brian`> hm... okay. but in that case Fruit has to be an instance of Show then.. right?
22:07:24 <mrd> instance (Show a) => Show (Basket a) where show (Basket x) = show x
22:07:28 <mrd> right
22:07:43 <mrd> btw you can get this all by 'deriving Show'
22:07:54 <mgsloan> I guess I haven't done any haskell for too long, but I don't see any good reason for instance Show (Basket Fruit) not to work
22:07:55 <mrd> well then you'll get things like "Basket APPLE" to print out
22:08:22 <mrd> mgsloan: well h'98 instances need to be of the form (T a b c)
22:08:45 <mrd> avoids overlapping instances and stuff
22:08:56 <mgsloan> ah right
22:09:18 <faxathisia> What's wrong with overlapping insatnces?
22:09:20 <mrd> you can do it if you enable extensions
22:09:21 <Brian`> what do you mean by overlapping instances?
22:09:23 <faxathisia> Can't something have two ttypes
22:09:42 <mgsloan> there'd be two instances which could each validly be used for a particular type
22:09:46 <mrd> right
22:09:53 <mgsloan> so it's ambiguous as to which to use
22:10:10 <faxathisia> Does anyone have The Science of Programming?
22:10:24 <faxathisia> I want.. to ask something about it for a haskell code I was writing
22:11:03 <mgsloan> though I think some instance specialization could be useful.  For example, define instance (Show a) => Show (Basket a), then specialize the case of instance Show (Basket Fruit)
22:11:31 <Brian`> yeah that's kinda what I wanted
22:11:42 <mgsloan> you'd just need to make the specialization hierarchy explicit somehow
22:12:23 <mrd> adhoc :(
22:12:23 <mgsloan> I think you can do it with C++ templates ;P
22:12:30 <faxathisia> has anyone read this book?
22:14:39 <mgsloan> mrd - what's the problem with adhoc polymorphism?
22:14:47 <mgsloan> I mean sure, it's nice to avoid it
22:14:57 <mrd> its not parametric
22:15:13 <mgsloan> seems like my example mixes parametric and adhoc polymorphism
22:15:14 <mrd> don't you want Theorems for Free?
22:15:32 <mrd> yeah, type-classes are kinda sorta ad-hoc, sadly.
22:16:22 <mgsloan> well, Theorems for Free will still work in the cases where it's purely parametric
22:16:58 <mgsloan> there's the issue of ensuring that it remains purely parametric.  Eg, if you allow specializations in other modules
22:17:50 <mgsloan> Such specializations are kinda what rewrite rules give you..
22:18:42 <mgsloan> although I guess that's more pure, since the behavior should be exactly the same
22:23:18 <dfranke_> Are there any tools along the lines of DRiFT that can generate derivations for GADTs?
22:38:57 <mgsloan> I think the specialization should be done the same way function parameter pattern matching is done - the instances must be in series, in the same file, and be ordered in order of consideration
22:40:25 <mgsloan> then again, class instances aren't always as simple as this example
22:41:12 <pkrumins> Hugs does not allow me to write code directly in it. If I used GHC, would it allow me to do it?
22:41:32 <pkrumins> like fn def's etc.
22:41:53 <Zao> pkrumins: ghci lets you do things interactively.
22:42:07 <Zao> let f x = 2*x
22:42:08 <mgsloan> I'm afraid not.  I'm not sure why the interactive interpreters only do expressions not declarations
22:42:10 <Zao> f 42
22:42:22 <Zao> That'll work just dandy in ghci
22:42:28 <pkrumins> not in Hugs: > let f x = 2*x
22:42:28 <pkrumins> ERROR - Syntax error in expression (unexpected end of input)
22:42:34 <pkrumins> gonna get GHC
22:42:47 <mgsloan> can you define a datatype in ghci?
22:42:47 <pkrumins> so i could learn Haskell faster, without having to type it all in text file then reload it
22:44:43 <Zao> pkrumins: I bound a key in vim to save and compile my code.
22:44:55 <pkrumins> oh nice idea!
22:44:56 <Zao> Which gave rather instant feedback on what's wrong or not.
22:45:35 <pkrumins> yup
22:53:38 <LoganCapaldo> > "quine"
22:53:39 <lambdabot>  "quine"
23:03:22 <atp> fy
23:03:43 <atp> hey, has anyone read this haskell -O11 pdf linked by reddit?
23:06:42 <atp> http://www-users.cs.york.ac.uk/~ndm/downloads/paper-supero_making_haskell_faster-27_sep_2007.pdf
23:06:43 <lambdabot> http://tinyurl.com/2fwg3l
23:06:48 <atp> it's pretty interesting
23:11:26 <atp> pretty quiet tonight
23:13:55 <bogner> can anyone point me somewhere that will explain how to deal with Maybe types?
23:14:41 <dfranke_> what do you mean by "deal with" them?
23:15:03 <bogner> That is to say, if i want to do something with the return value if it's something, or do nothing if the value is nothing
23:15:20 <dfranke_> case foo of
23:15:28 <dfranke_> Just x -> doSomething x
23:15:32 <dfranke_> Nothing -> return ()
23:15:33 <nolrai> or the maybe monad.
23:15:49 <atp> bogner: you can use fromMaybe
23:16:01 <atp> @t fromMaybe
23:16:01 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:16:12 <dfranke_> ?t fromMaybe
23:16:12 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:16:18 <dfranke_> :t fromMaybe
23:16:20 <ivanm> fmap for maybe?
23:16:20 <lambdabot> forall a. a -> Maybe a -> a
23:16:34 <atp> dfranke_: there we go :)
23:16:43 <bogner> thank you all, i'll try a few of these
23:16:52 <kaol> > fmap (+1) (Just 4)
23:16:54 <lambdabot>  Just 5
23:17:04 <atp> > fromMaybe 4 (Just 3)
23:17:04 <ivanm> > fmap succ Nothing
23:17:05 <lambdabot>  3
23:17:05 <lambdabot>  Nothing
23:17:05 <kaol> > fmap (+1) Nothing
23:17:05 <lambdabot>  Nothing
23:17:16 <atp> > fromMaybe 4 (Nothing)
23:17:16 <lambdabot>  4
23:19:08 <sclv> bogner: or, depending on the circumstance you may find it easier to just pattern match.
23:19:49 <atp> bogner: it sounds like you reall want to handle it monadically... use >>=
23:20:51 <bogner> atp: i'm fairly new to haskell (and functional programming in general), so i don't really know what that means
23:22:01 <atp> bogner: it's like this: Nothing >>= f = Nothing for any f
23:22:17 <atp> bogner: Just x >>= f will evaluate to f x
23:22:28 <atp> and f itself returns a maybe value too
23:22:46 <bogner> ah, i like that, that's really clean
23:22:51 <atp> so you can string them together m >>= f >>= g >>= h
23:22:57 <atp> where m is some Maybe type
23:23:11 <atp> it's kind of like throwing an exception
23:24:57 <kaol> > Nothing `mplus` Just "hello"
23:24:58 <lambdabot>  Just "hello"
23:26:57 <kaol> > Just "goodbye" `mplus` Just "hello"
23:26:58 <lambdabot>  Just "goodbye"
23:30:08 <dons> cdsmithus: you talking to the happs guys about how best to document things?
23:30:26 <dons> cdsmithus: i'd imagine not doing it on the haskellwiki, but perhaps a happs wiki?
23:43:30 <skew> wow, I just wrote a function in Coq from k to the k+1-step recursion scheme on natural numbers
23:55:34 <nolrai> > let f n = trace "c" f (n+1) in f 0
23:55:36 <lambdabot>   Not in scope: `trace'
23:56:12 <ivanm> nolrai: won't that produce an infinite loop? or is that the point?
23:56:23 <nolrai> yes
23:56:38 <ivanm> ahhh
23:56:56 <nolrai> I'm geting an infinite loop but my trace is only showing up once
23:58:53 <ivanm> maybe brackets around "f (n+1)" ?
23:59:04 <ivanm> @type trace
23:59:08 <lambdabot> Not in scope: `trace'
23:59:19 <ivanm> @type System.debug.trace
23:59:19 <lambdabot> Not in scope: `System.debug'
23:59:19 <lambdabot> Not in scope: `trace'
23:59:25 <ivanm> @hoogle trace
23:59:26 <lambdabot> Debug.Trace.trace :: String -> a -> a
23:59:26 <lambdabot> Debug.Trace :: module
23:59:26 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
