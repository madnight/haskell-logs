00:05:13 <wy> http://hpaste.org/4628
00:05:45 <wy> need some help for understanding this code from Wadler's monad paper
00:09:14 <Cale> wy: what about it in particular?
00:09:47 <Cale> wy: btw, sequence_ . map f = mapM_ f
00:09:49 <wy> Cale: I don't understand how the position works
00:10:13 <wy> Cale: resetP and bindP is a little hard to understand
00:10:49 <wy> Why is P defined like that?
00:11:30 <wy> define-macro: Are you testing something?
00:11:47 <Cale> Well, I suppose P computations are just like E computations, but they additionally depend on a Position parameter.
00:12:24 <wy> Yes. That's the purpose of P. But why is it defined like a function, not just like E
00:12:41 <Cale> So what (m `bindP` k) does is to produce the computation which takes the initial position p and runs m with it
00:13:01 <Cale> binding the result of that to x (in the E monad)
00:13:17 <Cale> and then runs k with x and the position parameter p
00:13:33 <Cale> So p is just passed along to each part of the computation.
00:13:58 <Cale> It's like a (computation-) globally available environment.
00:14:44 <Cale> resetP takes a Position and a P computation, and produces the computation which ignores the position it's passed, using the given position instead.
00:14:49 <wy> Let me twist my head again...
00:15:19 <Cale> This is a somewhat antequated style for monads.
00:15:29 <ddarius> wy: Why is E not defined like a function, like P?
00:15:48 <ddarius> Indeed, it was pre-constructor classes, let alone monads in Haskell.
00:15:56 <Cale> ddarius: Um, because it's an error monad, and not a reader?
00:16:11 <ddarius> Cale: -I- know that and I know you do, I was asking wy.
00:16:15 <Cale> ah, okay
00:16:42 <Cale> brb
00:18:18 <wy> ddarius: That's the reverse of my question... I don't know
00:18:31 <ddarius> wy: Why do you think it should look like E?
00:19:09 <wy> Is it like a stack?
00:19:26 <ddarius> Is what like a stack?
00:19:37 <wy> I mean P
00:20:55 <ddarius> Like a stack in what way?
00:23:17 <wy> I still don't know why it is different. Maybe I should try to rewrite it like E
00:23:55 <ddarius> wy: Why do you think it should be like E?
00:24:12 <wy> no
00:24:35 <wy> The position only comes with an error
00:24:50 <wy> If there is no error, position will not be reported
00:25:10 <wy> but error will always be reported and stops computation
00:27:23 <wy> I see...
00:27:29 <wy> It's really like a stack
00:28:04 <ddarius> In what way?
00:29:02 <wy> The problem is that you see position before you see the error. So you must keep track of the position even if you don't have error so far
00:38:35 <wy> Did you already know the answer to your question?
00:42:13 <ddarius> The last one?  No, because I can't read your mind.  I still don't know the answer.
00:43:24 <wy> That the direction to think, but I have got it clear yet...
00:43:39 <wy> I must go to sleep. See you tomorrow!
01:29:20 <duki> hello everyone.
01:30:07 <duki> is there someone here who uses xmonad?
01:30:57 <Lycurgus__> you
01:31:47 <shachaf> duki: Yes, but try #xmonad.
01:32:16 <duki> Ah ok,  thanks shachaf
01:32:46 <pa-ching> Hmm, how do I do something like "instance (Integral a) => MyClass a where [...]"?
01:34:56 <quicksilver> pa-ching: well, exactly like that, but it probably doesn't mean *quite* what you think it does
01:35:09 <quicksilver> constraints are not taken into account when choosing instances
01:35:28 <pa-ching> Ok
01:35:35 <quicksilver> so that says "EVERY a is a member of MyClass, but using MyClass methods will give you an Integral constraint
01:35:43 <quicksilver> so it will overlap with over instances, if you have any others.
01:35:50 <pa-ching> Hmm alright
01:36:00 <quicksilver> That's fine if you only want Integral instances, and nothing else.
01:36:11 <pa-ching> Can I do anything similar?
01:36:13 <quicksilver> (although then you could also consider making Integral a superclass of MyClass)
01:36:28 <pa-ching> hmmm...
01:36:32 <quicksilver> well you can turn on overlapping instances and cope with the overlap.
01:36:45 <quicksilver> which I don't much like because I don't 100% understand the semantics of that case.
01:36:54 <quicksilver> Or you could use a newtype wrapper
01:38:20 * quicksilver reels under the blow of 17 emails from Peter Lund
02:06:48 <moconnor> Why is "let f :: Num b => a -> b; f _ = 1" legal, but "let f :: Ord b => a -> b; f _ = "x"" illegal (Couldn't match expected type `b' (a rigid variable) against inferred type `[Char]')
02:07:18 <moconnor> I would expect the 1st example to give the same error, just w/ inferred type Integer or whatever
02:08:24 <ddarius> :t 1
02:08:26 <lambdabot> forall t. (Num t) => t
02:08:30 <moconnor> oh
02:08:36 <moconnor> I didn't know that
02:10:03 <shachaf> moconnor: Number literals have an implicit fromInteger (or fromRational).
02:13:20 <moconnor> So I want to write a function but the only thing I care about is that its return values can be sorted.  I don't care about the values themselves.  So, strings or fractions or ints, or whatever are fine.  I thought "Ord b => a -> b" would do what I want.  However, it doesn't.
02:13:29 <moconnor> So, can I write such a function.  Is such a thing sensical?
02:14:13 <shachaf> moconnor: What does the function do with the a?
02:15:45 <moconnor> It's used to compute b.  This function is in a type class, so i was thinking there would be different implementations for concrete types a.  class Foo a where bar :: Ord b => a -> b;  (may have gotten syntax wrong there)
02:16:22 <shachaf> moconnor: OK, how do you make a b, then?
02:16:39 <shachaf> @src Ord
02:16:39 <lambdabot> class  (Eq a) => Ord a  where
02:16:39 <lambdabot>     compare      :: a -> a -> Ordering
02:16:39 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
02:16:39 <lambdabot>     max, min         :: a -> a -> a
02:17:21 <moconnor> Well, I figured that depends on the implementation.  I could have one like this:  instance Foo Blah where bar _ = 1;  instance Foo Baz where bar _ = "cows".  The details of how you go from a to b are specific to Blah and Baz.
02:18:44 <moconnor> I'm pretty sure I'm asking for something non-sensical, I'm just not sure why
02:18:51 <shachaf> moconnor: What would bar's type be? bar :: forall a b. (Foo a, Ord b) => a -> b
02:19:04 <shachaf> moconnor: It has to work for every Ord, not just one.
02:19:13 <moconnor> oh!
02:22:20 <moconnor> that makes sense.  I was thinking "oh, well the b is a type variable but then instance Foo Blah fixes b to be [Char]".  But it doesn't work that way and that's exactly what the error message was telling me.
02:27:02 <shachaf> moconnor: What are you trying to do?
02:45:14 <moconnor> shachaf: I wanted to have a ranking function for given types so I could sort those types and pick the best one.  For a little toy I'm writing.  I think, in hindsight, it makes more sense to make each type be an instance of my type class, and an instance of the Ord type class. That seems to was trying to do before.
02:45:49 <moconnor> s/was/be what I was/
02:50:35 <c9s> lambdabot: [ x | x <- [2,3,4,5,6,7] , x < 4 ]
02:50:58 <roconnor> > [ x | x <- [2,3,4,5,6,7] , x < 4 ]
02:51:02 <lambdabot>  [2,3]
02:51:23 <roconnor> > filter (< 4) [2,3,4,5,6,7]
02:51:24 <c9s> roconnor: thanks ;)
02:51:24 <lambdabot>  [2,3]
02:51:45 <roconnor> > filter (< 4) [2..7]
02:51:46 <lambdabot>  [2,3]
02:52:02 <notsmack> > takeWhile (<4) [2..7] -- If you know they're sorted.
02:52:03 <lambdabot>  [2,3]
02:52:13 <c9s> > filter ( < 8 ) [ 1,3 .. 11 ]
02:52:14 <lambdabot>  [1,3,5,7]
02:54:28 <cytzol> @pl \(dx,dy) -> (dy,-dx)
02:54:29 <lambdabot> (line 1, column 16):
02:54:29 <lambdabot> unexpected ","
02:54:29 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
02:56:14 <xerox> cytzol: (snd &&& negate . fst)
03:01:21 <cytzol> xerox: cool, thanks. why didn't pl like it?
03:01:56 <xerox> no support for pattern matching for tuple arguments
03:02:09 <cytzol> aw, oh well
03:08:16 <notsmack> @pl \(dx,dy) -> (dy,(-dx))
03:08:17 <lambdabot> uncurry (flip (,) . negate)
03:28:14 <eu-prleu-peupe1> hey there!
03:28:21 <eu-prleu-peupe1> is haskell the best language in the world ?
03:29:01 <jh__> Romansh edges it out by a hair :/
03:29:29 <roconnor> haskell has some issues
03:29:42 <roconnor> the prelude is broken in some places
03:29:42 <eu-prleu-peupe1> roconnor: such as ?
03:29:46 <eu-prleu-peupe1> oh yes :/
03:29:52 <roconnor> the type classes are global
03:29:53 <eu-prleu-peupe1> and the console sucks
03:30:31 <eu-prleu-peupe1> probably haskell is second best to C
03:30:59 <moconnor> Not an intrinsic problem w/ the language, but Haskell's libraries are horrible compared to a more main stream language.
03:31:24 <moconnor> Also, the laziness makes it hard (for me) to reason about space and time complexity.  I'll be amazed w/ a simple function blows the stack
03:32:05 <roconnor> yeah, whether the standard libraries are part of the language or not is debatable.
03:32:31 <eu-prleu-peupe1> i though haskell was the most advanced language of the moment
03:32:40 <eu-prleu-peupe1> at the moment i mean
03:32:44 <roconnor> perhaps
03:32:53 <roconnor> but there is certainly room for improvement
03:33:05 <roconnor> I'm looking forward to Epigram2
03:33:12 <eu-prleu-peupe1> what is epigram2 ?
03:33:17 <moconnor> I don't think it's really possible to say any given langauge is the most advanced.  There are certainly more esoteric languages, more brainy ones, more academic ones, etc
03:33:44 <eu-prleu-peupe1> heheh yes indeed :) i just like to troll a bit with huge generalizations
03:33:48 <moconnor> Haskell's got a big community though, lots of programmers, and momentum, and lots of people do amazing things w/ it all the time.
03:34:07 <roconnor> http://www.e-pig.org/epilogue/
03:34:09 <lambdabot> Title: Epilogue
03:34:25 <czShadoW> But lambdabot is best :)
03:34:36 <roconnor> @vixen you're the best
03:34:37 <lambdabot> I dunno
03:35:25 <eu-prleu-peupe1> epigram2 is epilogue version 2 ?
03:37:45 <swiert> eu-prleu-peupe1: epilogue is the developers blog about epigram.
03:40:49 <eu-prleu-peupe1> ah ok
03:41:36 <eu-prleu-peupe1> and epigram is a language
03:42:55 <eu-prleu-peupe1> how is it related to haskell ?!
03:43:14 <eu-prleu-peupe1> epigram is like haskell^2 ?
03:45:02 <desegnis> I don't know about epigram, but haskell^2 is called Haskell' (that is, Haskell prime).
03:45:13 <roconnor> eu-prleu-peupe1: epigram has dependent types
03:45:34 <roconnor> this drasticly increases the expresivity of the type system
03:45:40 <roconnor> allows generic programming
03:45:41 <roconnor> etc
03:46:30 <roconnor> swiert: I found out that types in Prop in OTT have at most 1 element, so you can always eliminate Prop over Set
03:47:00 <swiert> roconnor: yep. that sounds right.
03:47:33 <roconnor> OTT seems like such a nice type system.
03:47:58 <roconnor> It behaves exactly how I use Coq's type system.
03:48:14 <eu-prleu-peupe1> roconnor: but are dependent types efficient (as in: fast) ?
03:48:22 <roconnor> ie always making sure that all my Props that I use has at most 1 element (extensionaly)
03:48:55 <roconnor> eu-prleu-peupe1: I think I'd say that question is of active research.
03:49:06 <eu-prleu-peupe1> but how is epigram2 going to conquer the world ?
03:49:32 <roconnor> eu-prleu-peupe1: well, the first step it needs to do is exist.  Epigram 2 is still under development.
03:49:38 <eu-prleu-peupe1> ah ok
03:50:04 <eu-prleu-peupe1> if i was any good functional programmer coder, i would very much like to jump into the wagon...
03:50:14 <eu-prleu-peupe1> but im not :/
03:51:27 <kombinator> Hello, I'm writing a new version of "Functional programming" page on haskellwiki, please let me know if you have any comments. http://www.haskell.org/haskellwiki/Functional_programming/Alternative_1
03:51:29 <lambdabot> Title: Functional programming/Alternative 1 - HaskellWiki, http://tinyurl.com/2jhr7l
03:51:40 <kombinator> you may fix it on the spot as well
03:56:24 <desegnis> kombinator: Looks like a good approach to me. Under “lazy evaluation”, you may want to add that computations may not exactly be performed in /any/ order, with regard to some orders that will terminate while others won't.
03:57:08 <eu-prleu-peupe1> where can i learn more about dependent types ?
03:57:46 <mgsloan> I think it would be cool to have a language where if there is any evaluation order which terminates, the program will terminate
03:57:58 <roconnor> eu-prleu-peupe1: http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
03:57:59 <lambdabot> Title: Type Theory and Functional Programming
03:58:22 <roconnor> mgsloan: haskell has this property
03:58:29 <roconnor> (assuming no use of seq)
03:58:43 <sjanssen> mgsloan: I'm sure this can run afoul of the halting problem
03:59:05 <mgsloan> roconnor - it sort of does
03:59:51 <mgsloan> but what about (nonterminating || expr_evaluating_to_true)
04:00:11 <kombinator> desegnis: I'm not sure how I can formulate that, I just wanted to point out that since there are no side effects the order does not matter
04:00:19 <roconnor> ah, the parallel or problem
04:00:20 <mgsloan> I don't think it does run afoul of the halting problem..
04:00:37 <mgsloan> yeah, or anything else like it
04:00:44 <kombinator> desegnis: I'm not talking about reduction strategies, only about more intuitive concepts
04:01:26 <Cin> doesn't || support short-circuiting?
04:01:34 <mgsloan> it does, but the other way around
04:01:43 <Cin> i don't follow
04:01:47 <mgsloan> in other words, it's not commutative
04:01:58 <kombinator> desegnis: maybe "they can be performed in any order" -> "they can be performed at any time" would fix that?
04:02:27 <mgsloan> (expr_evaluating_to_true || nonterminating) will yield true
04:02:38 <Cin> ah, good
04:02:43 <mgsloan> but not the other way around
04:02:49 <Cin> yeah
04:03:09 <Cin> makes sense, has to evaluate each clause in order
04:03:12 <desegnis> kombinator: Maybe formulate it more technically, like: the compiler is free to perform them in any order that is considers appropriate.
04:03:14 <Cin> (right?)
04:03:26 <roconnor> Cin: it doesn't HAVE to evaluate in order.
04:03:31 <Cin> oh dear
04:03:43 <roconnor> @src (||)
04:03:43 <lambdabot> True  || _ =  True
04:03:43 <lambdabot> False || x =  x
04:04:04 <sjanssen> mgsloan: yeah, might be safe from the halting problem
04:04:11 <kombinator> desegnis: that changes that sentence a bit too much
04:04:25 <roconnor> It is the sequential nature of the lambda calculus that forces us to order the case statements in the definition of ||.
04:04:30 <Cin> roconnor: that looks ordered to me? tests one after the other
04:04:37 <mgsloan> yeah, I think it is.  It's like progressive-deepening evaluation
04:04:51 <sjanssen> mgsloan: though there are programs that will use exponentially more space with this evaluation order
04:04:51 <roconnor> Cin: It is ordered according to the definition
04:04:56 <sjanssen> space and time
04:05:04 <roconnor> Cin: but one could imagine a definition of || that was unordered.
04:05:13 <Cin> roconnor: oh, yes, i could
04:05:16 <mgsloan> which would be very impractical :)  slightly more practicla would be to explore a branch for a while, then switch to other branches, at places where this sort of thing might matter
04:05:34 <mgsloan> imho ordered pattern matching is rather impure
04:05:37 <Cin> roconnor: it's certainly nice to be able to avoid evaluating expressions unnecessarily
04:06:01 <kombinator> any other comments?
04:06:07 <roconnor> mgsloan: impure/pure has a techinical meaning.
04:06:19 <mgsloan> I know
04:06:20 <mgsloan> and that's not the one I mean :)
04:06:23 <roconnor> :)
04:07:13 <roconnor> Well, most of this becomes a non-issue when you avoid non-terminating programs :P
04:07:28 <qpu> why doesn't || recurse, even though @src (||) appears to indicate it calls itself?
04:07:45 <roconnor> qpu: it isn't recursing
04:07:48 <mgsloan> anyone here seen the subtext 2 tables? they offer some very interesting, unordered pattern matching
04:08:01 <qpu> roconnor: yes, i asked *why*
04:08:02 <sjanssen> mgsloan: consider f 0 = True; f (n+1) = f n || f n
04:08:17 <roconnor> qpu: it has two cases.  One returns True and the other returns x
04:08:21 <roconnor> @src (||)
04:08:22 <lambdabot> True  || _ =  True
04:08:22 <lambdabot> False || x =  x
04:08:32 <integral> the || are in the patterns
04:08:50 <roconnor> qpu: maybe it is a bit confusing because it is defined with infix notation
04:08:54 <sjanssen> mgsloan: that program will run in exponential space when only linear stack is necessary
04:08:58 <roconnor> (||) True _ = True
04:09:03 <roconnor> (||) False x = x
04:09:04 <Cin> qpu: that's the infix definition. you could define it as myOr True _ = True and myOr False x = x
04:09:06 <qpu> ohh
04:09:16 <qpu> thanks, makes sense now
04:10:19 <mgsloan> sjanssen - yes, it would be rather impractical, wouldn't it?  One method might be to evaluate along a certain evaluation order for a while, and at some point backtrack and pursue other evaluation paths
04:10:35 <mgsloan> the runtime overhead probably still wouldn't be worth it
04:10:40 <Cin> mgsloan: why are ordered patterns impure? because one has to conditionally evaluate?
04:10:54 <eu-prleu-peupe1> this book on type theory is a bit dense...
04:11:06 <mgsloan> well, as you're reading them you have to keep in mind that all the previous conditions are false
04:11:23 <roconnor> eu-prleu-peupe1: :)  Take a few weeks to read it
04:11:26 <mgsloan> it also brings up issues like this.  the || definition is quite necessarily ordered
04:12:24 * mgsloan = away
04:12:46 <roconnor> @hoogle por
04:12:47 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
04:12:47 <lambdabot> Distribution.InstalledPackageInfo.importDirs :: InstalledPackageInfo_ m -> [FilePath]
04:12:47 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
04:12:57 <Cin> i'll have to ponder on that one
04:55:19 <eu-prleu-peupe1> is there any C code generator writen in haskell ?
04:55:35 <Japsu> ghc? ;)
04:55:39 <eu-prleu-peupe1> lol
04:55:44 <eu-prleu-peupe1> yes, besides those...
04:56:25 <fasta> What XML library is currently "recommended"? I need UTF-8 support too.
05:05:22 <qeb`away> is there a de-facto introduction to Haskell book (ala Kernighan and Rithie for C) and if so, what is it called?
05:06:00 <qeb`away> the website (haskell.org) seems to have several books on it and I'm at loss which one I want
05:06:35 <jtra> how can I modify this code to be strict so it will not overflow stack limit? http://hpaste.org/4631#a0
05:07:22 <jtra> I tried puting $! at random places but it did not help :-)
05:08:05 <qeb`away> shotgun fixing! :)
05:11:15 <jtra> I written the code to measure performance of Set (versus performace of List) on small number of entries for to decide what to use for my bigger program
05:12:48 <pjd> qeb`away: what background are you coming from, and what about Haskell interests you?
05:14:07 <qeb`away> pjd: I want to pick up proper functional programming and grok it once and for all (Not to mention that lazy evaluation is awesome), and I "come from" Python/Scheme/C
05:14:45 <qeb`away> pjd: I guess I should add Matlab to that list but I can't stand it so :(
05:14:51 <pjd> qeb`away: yay for Python/Scheme/C :)
05:15:26 <qeb`away> pjd: don't ask me how I ended up with those 3 in the first place, but they let me do what I need mostly :)
05:15:58 <Baughn_> qeb`away: Listening to me? :P
05:16:04 <qeb`away> Baughn_: listening to both!
05:16:19 <qeb`away> Baughn_: where the other one is #python
05:16:34 <pjd> qeb`away: as far as books go, i've gotten a lot out of The Haskell School of Expression
05:16:39 <qeb`away> okay
05:16:40 <Baughn_> qeb`away: If you've already got scheme and continuations, then you might skip directly to the gentle haskell tutorial
05:16:48 <qeb`away> Baughn_: continuations, no
05:16:54 <Baughn_> qeb`away: Lazy evaluation maps nicely to continuations
05:16:58 <qeb`away> hm
05:17:11 <Baughn_> (It's a lot better behaved, though. Mostly due to the no-IO rule.)
05:17:12 <pjd> Baughn_: i'm not sure how you get that :)
05:17:38 <qeb`away> just out of curiosity, lazy evaluation coupled with functional programming should give a really nice combo for parallellisation?
05:17:51 <Baughn_> pjd: Perhaps I should say, continuations and lazy evaluation *both* map well to CPS
05:17:53 <qeb`away> as in, Haskell will do very well on multiple cores?
05:18:12 <Baughn_> qeb`away: Yep, that it does
05:19:09 <pjd> qeb`away: _automatic_ parallelization is a bit of an open research topic
05:19:24 <pjd> but Haskell is generally very friendly
05:19:37 <Baughn_> From par and up. :)
05:19:57 <pjd> you can get away with just adding a few parallelization hints, without changing the structure of your program
05:19:57 <qeb`away> pjd: as far as the community goes I have to say that I really admire the FP community in general
05:20:23 <Baughn_> qeb`away: ("par a b" - "When b is needed, start evaluating a in your spare time, assuming that it'll be needed later".)
05:20:48 <qeb`away> yeah that was something like what I thought it would be
05:20:56 <Baughn_> qeb`away: It automatically adapts to system load (par sparks run at low priority), number of cores, etc. etc. - and sparks are very, very cheap.
05:21:02 <qeb`away> SICP gave me something of a revelation when it comes to FP
05:21:25 <qeb`away> their chapter on state / mutability is really, really good
05:21:29 <pjd> SICP is great
05:21:43 <pjd> you're going to love Haskell :)
05:21:58 <qeb`away> I certainly hope so
05:22:21 <Baughn_> The fun thing is, 'a' can be part of the data needed to evaluate 'b' - thus using multiple cores for b. It all just works.
05:22:40 <qeb`away> magic
05:22:51 <Baughn_> Immutability.
05:22:57 <pjd> qeb`away: have you looked at the Haskell wikibook?
05:23:54 <pjd> qeb`away: you can probably zip through the "Basics" and "Elementary" chapters
05:23:54 <qeb`away> pjd: doing so now
05:24:38 <pjd> to get familiar with the Haskell versions of what you already know from other languages
05:24:38 <qeb`away> Baughn_: this is why I asked for TCO earlier, I really like the power of recursion that lets you do looping without programming imparatively
05:25:12 <Baughn_> qeb`away: As I said - it doesn't quite do TCO, but what it does is often better than TCO. Just.. harder to understand.
05:25:15 <pjd> then you'll have a solid foundation to tackle the more interesting stuff :)
05:25:15 <qeb`away> then again there's also list comprehensions here I see :o which is fairly awesome
05:25:45 <Baughn_> qeb`away: List comprehensions are a straightforward shorthand for using the list monad
05:26:01 <pjd> qeb`away: TCO isn't really that prominent in Haskell idiom
05:26:08 <pjd> combinators, on the other hand, are
05:26:11 <qeb`away> oh well, thanks for the help guys, I'll leat you know how it goes
05:26:24 <pjd> qeb`away: be sure to ask questions here
05:26:32 <qeb`away> I should get somewhere if I don't spend christmas reuniting with friends and beer that I didn't see the last 6 months :)
05:26:39 <qeb`away> pjd: thanks, I'll be sure to do :)
05:26:48 <qeb`away> dinner awaits now though, laters and thanks
05:26:54 <Baughn_> The only thing I"m really missing from haskell/ghc is the ability to serialize thunks. :P
05:28:12 <pejo> pjd, 'TCO'?
05:28:24 <pjd> pejo: tail call optimization
05:28:50 <pjd> it's a prominent feature of Scheme
05:29:23 <pjd> (does that help? :)
05:29:32 <pejo> I know what tail call optimization is, I just couldn't figure out what the  "total cost of ownership" had to do with Haskell.
05:29:44 <pjd> heh
05:29:44 <Baughn_> It decreases?
05:30:06 <earthy> baughn: thats an unknown
05:31:28 <earthy> it might, but haskell programmers are rarer, and therefore more expensive
05:35:57 <Lycurgus> the ghc path to the FC rpm seems to lead to a cul-de-sac at RH. Is there actually a 6.8.2 rpm someplace?
05:45:18 <fasta> jtra: I fixed your program.
05:45:46 <jtra> fasta: thank you
05:45:49 <fasta> jtra:
05:46:06 <fasta> jtra: I didn't minimize the amount of bang-patterns
05:47:08 <jtra> I see
05:47:29 <fasta> jtra: fnrepeat is basically take n $ iterate f v, btw
05:47:48 <fasta> jtra: although, I haven't tested that's where the problem is.
05:48:03 <jtra> I also tried: fnrepeat2 n f v = head (drop n (iterate f v))
05:48:18 <fasta> jtra: er with a last before it.
05:48:29 <jtra> but it did not help
05:49:45 <fasta> jtra: it's also a pretty bad performance test, I guess.
05:50:15 <fasta> jtra: the reason it spends O(number of "iterations") is because it's lazy.
05:50:42 <Saizan_> you need a strict iterate?
05:51:20 <fasta> It wasn't only the strict iterate. D[D[D[D[D[D[D[D[DOF
05:53:26 <fasta> Function f needs to be strict in all arguments.
06:21:15 <c9s> > "bar" =~ "(foo|bar)"
06:21:16 <lambdabot>   Not in scope: `=~'
06:21:41 <c9s> > "bar" =~ "(foo|bar)" :: Bool
06:21:42 <lambdabot>   Not in scope: `=~'
06:25:29 <desegnis> @hoogle =~
06:25:30 <lambdabot> No matches found
06:28:31 <Saizan_> ?index =~
06:28:32 <lambdabot> bzzt
06:29:06 <desegnis> It should be in Text.Regex, anyways?
06:29:27 <allbery_b> Text.Regex.Posix
06:30:03 <allbery_b> :t (Text.Regex.Posix.=~)
06:30:08 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.Wrap.Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.
06:30:08 <lambdabot> Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption source) => source1 -> source -> target
06:30:43 <desegnis> Qualified class names suck.
06:50:29 <qeb`away> hrm, does anyone know if there is a haskell-mode for emacs that integrates nicely with ghc and such?
06:51:18 <qpu> i keep reading that haskell is in the lisp family, is there any truth in that?
06:51:54 <qeb`away> in the sense that both promote (in the lisp case up to a point) functional programming I guess, but syntactically they seem to be widely different
06:52:04 <qeb`away> but lisp isn't similar to anything really so that shouldn't be much of a surprise
06:52:22 <sjanssen> qpu: barely.  It's more accurate to say that Haskell is in the ML family
06:52:48 <qpu> weird, so it's certainly not a *dialect* of lisp?
06:53:04 <sjanssen> qpu: definitely not
06:53:26 <qpu> hmm, guess i should be taking these amazon book reviews with a few more grains of salt :]
07:07:58 <pjd> qpu: ObCounterpoint: http://clemens.endorphin.org/liskell
07:07:59 <lambdabot> Title: Liskell - clemens.endorphin.org
07:08:47 <qpu> pjd: heh, interesting!
07:09:26 <pjd> qpu: note that it doesn't make Haskell any more of a Lisp than Lisp syntax for any other language :)
07:11:40 <fasta> Is there anything for "undoable side-effects" in Haskell?
07:12:31 <kombinator> fasta: what do you mean by that?
07:12:31 <Saizan_> what kind of side effect?
07:12:43 <fasta> I mean like Screamer offers.
07:13:29 <kosmikus> in case anyone is interested: the HCAR is out! http://haskell.org/communities
07:14:15 <fasta> In Screamer you can locally do some side-effects and when you decide that branch wasn't the one you wanted, you can roll back everything you did there.
07:14:36 <fasta> These side-effects are variable assignments; they don't undo nuclear launches.
07:15:09 <Saizan_> seems like "ListT done right" is almost there
07:15:33 <SamB> it doesn't have variables, does it?
07:15:43 * allbery_b wonders if it's worth posting a "do not feed the trolls" note to -cafe
07:15:54 <kombinator> fasta: STM provides similar functionality
07:16:05 <SamB> eh?
07:16:10 <Saizan_> well, you can have variables in the inner monad?
07:16:11 <fasta> kombinator: huh?
07:16:21 <SamB> oh, true, it does...
07:16:40 <SamB> at least superficially
07:16:40 <kombinator> fasta: all changes take place in a transaction and you can roll them back or decide to commit when you're done
07:17:04 --- mode: ChanServ set +o kosmikus
07:17:10 --- topic: set to '["The Haskell programming language","New Haskell Communities & Activies Report: http://haskell.org/communities","GHC 6.8.2 released!","http://haskell.org ","http://www.jobs-in-fp.org/","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by kosmikus
07:17:19 <kombinator> otherwise, you could make this by hand
07:17:21 <fasta> kombinator: can I also roll back ST-actions?
07:17:34 <kombinator> no, you have to use STM variables
07:17:34 <SamB> fasta: of course not
07:17:54 <fasta> Well, Screamer can do that.
07:18:05 <SamB> but runST doesn't have any side effects anyway
07:18:11 <kombinator> fasta: what's screamer?
07:18:25 <SamB> and that's the only legit way to run ST code from STM
07:19:02 <fasta> @go Screamer Common Lisp
07:19:04 <lambdabot> http://www.cis.upenn.edu/~screamer-tools/screamer-intro.html
07:19:04 <lambdabot> Title: Screamer General Info
07:19:06 <kombinator> fasta: another way is by doing everything by hand that it operating on persistent data
07:19:22 <kombinator> fasta: and going back to old versions if needed
07:19:28 <fasta> kombinator: you mean "isn't"?
07:19:43 <fasta> I thought of just reifying all the actions in a list.
07:20:16 <fasta> Which would qualify as "manually", I guess.
07:20:24 --- mode: ChanServ set -o kosmikus
07:20:45 <SamB> fasta: well, kombinator seems to be suggesting to not use mutation...
07:21:03 <kombinator> yes
07:21:04 <fasta> Right, but that's going to cost a log n factor.
07:21:18 <SamB> yeah, probably
07:21:25 <kombinator> fasta: what exactly do you want to do?
07:35:08 <kombinator> @tell fasta For the record, it shouldn't be too difficult to implement such imperative nondeterminism like in Screamer on top of ST, by writing a monad encapsulating it.
07:35:08 <lambdabot> Consider it noted.
07:35:11 <sioraiocht_> http://www.cs.caltech.edu/~mvanier/hacking/rants/cars.html
07:35:12 <lambdabot> Title: Mike Vanier: opinions
07:35:17 <sioraiocht_> see the part on haskell ;)
07:38:07 <sjanssen> kombinator: yes, I've done something similar to that
07:38:38 <sjanssen> I was writing a Sudoku solver based on the "dancing links" method
07:39:09 <sjanssen> part of that requires backtracking and repairing a linked list structure as you go
07:39:23 <sjanssen> so I wrote a backtracking ST Monad :)
07:40:14 <kombinator> sjanssen: it might be useful to other people, perhaps you could announce it on Haskell-Café
07:40:26 <sjanssen> kombinator: I've since lost the code
07:47:07 <Cin> right! here's hoping writing TCP applications in haskell will be easy, fun and rewarding!
07:47:09 * Cin hits google
07:49:52 <Saizan_> well it's not hard, but don't expect esoteric solutions :)
07:50:33 <Cin> esoteric solutions?
07:50:48 <pjd> Cin: http://www.seas.upenn.edu/~lipeng/homepage/unify.html
07:50:48 <lambdabot> Title: Unifying events and threads
07:50:52 <Cin> do you mean lots of solutions to random problems people have had?
07:51:09 <Cin> pjd: ahh, thanks. this will lead me on the right path?
07:51:22 <pjd> Cin: i don't know, but it's sure to be an interesting path
07:51:34 <wolverian> "So in typical GHC style, rather than patch the immediate problem, we’re redesigning the entire back end." heh
07:52:07 <Cin> haha
07:52:21 <SamB> wolverian: where did you see that?
07:52:49 <wolverian> SamB, http://haskell.org/communities/12-2007/html/report.html
07:52:52 <wolverian> (see topic for pdf)
07:53:25 <Cin> oo, interesting
07:53:35 <pjd> Cin: very :)
07:55:28 <pjd> Cin: they implement a high-performance application-level TCP stack as an addendum
08:52:02 <Cin> > let test = (+)
08:52:02 <lambdabot>  Parse error at end of input
08:52:10 <Cin> > test = (+)
08:52:10 <lambdabot>  Parse error at "=" (column 6)
08:52:20 <Cin> lambdabot: help
08:52:25 <Cin> bleh
08:52:49 <mauke> expressions only
08:53:28 <Cin> > let i a = a in i 10
08:53:30 <lambdabot>  10
08:55:19 <ndm> @let test = (+)
08:55:21 <lambdabot> Defined.
08:55:24 <ndm> > test 1 3
08:55:24 <lambdabot>  4
08:56:30 <oerjan> > test 1.0 3.0
08:56:32 <lambdabot>   add an instance declaration for (Fractional Integer)
08:56:39 * oerjan cackles evilly
08:57:02 <Cin> heh
08:58:20 <Jomyoot> How well does Haskell handle multi-threading?
08:58:22 <desegnis> @set -fno-monomorphism-restriction  -- lambdabot should have this :)
08:58:23 <lambdabot>  Parse error
08:58:41 <mauke> Jomyoot: awesomely
08:59:01 <Jomyoot> Does it have mutex, semaphore and other stuff?
08:59:32 <mauke> I have no idea
08:59:40 <desegnis> Jomyoot: Control.Concurrent should be of interest to you.
09:00:09 <Jomyoot> does it allow several threads to access same memory chunks with proper locking and stuff?
09:00:15 <clanehin> Jomyoot: MVar implement mutexes
09:00:31 <oerjan> QSem seems to be semaphores
09:00:33 <Jomyoot> is that part of the main Haskell?
09:00:38 <mauke> I access memory without locking
09:00:53 <desegnis> Jomyoot: It's in the base package anyway.
09:01:11 <desegnis> Jomyoot: See http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
09:01:12 <lambdabot> http://tinyurl.com/33wpmr
09:01:15 <Jomyoot> does this work on freebsd, mac and all platforms?
09:01:22 <Jomyoot> u know threading have some issues with some platforms
09:01:48 <oerjan> Jomyoot: ghc uses its own lightweight threads spread over the OS's ones
09:03:22 <desegnis> Jomyoot: The documentation suggests that it works on any Unix-thingy as well as on Windows
09:03:28 <sk> how about forkOS?
09:04:10 <oerjan> sk: forkOS is used to guarantee that a haskell thread always runs in the _same_ OS thread
09:04:12 <sjanssen> sk: what about it?
09:04:28 <oerjan> which is required for some frameworks
09:04:31 <Jomyoot> what's a good book/tutorial for haskell. if i am already a programming wanting to convert?
09:04:44 <mauke> @where yaht
09:04:45 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
09:04:58 <sk> ic... i did not really read much about concurrent haskell
09:05:33 <oerjan> oh well it is also a new OS thread apparently
09:05:55 <sk> not lightweight?
09:05:56 <oerjan> and technically only foreign calls are guaranteed for it
09:05:59 <sk> right?
09:06:05 <oerjan> right
09:06:25 <sk> icic... native os threads... thx lots.. brb for a dota game
09:09:46 <Cin> what's that theorem called where random occurrences converge over time?
09:10:51 <LoganCapaldo> murphy's law?
09:11:02 <Associat0r> guys when is it appropriate to use function pattern matching vs case expressions?
09:11:55 <Cin> i don't think so
09:12:02 <Cin> something distribution something
09:12:11 <oerjan> law of large numbers?
09:12:19 <Cin> ah, that'll be it
09:12:19 <Cin> thanks
09:13:24 <oerjan> Associat0r: well you can always use either i think
09:14:34 <LoganCapaldo> you can't have multiple alternatives for a lambda w/o using case, but there's always let and where, so pick whatever you think looks good
09:15:02 <oerjan> if what you are matching _is_ a function argument already, making it a pattern looks good
09:15:31 <roconnor> I almost never use case expressions
09:15:49 <oerjan> it's the old declaration vs. expression style thing - entirely matter of taste
09:16:51 <oerjan> well if you are constructing an expression only to match on the result, case seems nice
09:17:18 <roconnor> oerjan: I use where clauses for that :)
09:18:35 <sk> when was yaht last updated?
09:27:39 <Jomyoot> is there an ide for haskell?
09:31:54 <pejo> Jomyoot, lots of people use Emacs/vim. There's Visual Haskell which is a plugin for Visual Studio too.
09:33:57 <byorgey> Jomyoot: there's also a project going to create an environment for Haskell in Eclipse, but it's not really that usable yet, I don't think.
09:34:20 <byorgey> sk: not for quite a while, I think
09:34:21 <Jomyoot> ok
09:34:32 <byorgey> sk: are you having some sort of problem or confusion with it?
09:35:20 <desegnis> Speaking of IDEs... Did anyone ever implement a nicer visual presentation of type errors, say, highlighting an argument of the wrong type in red?
09:36:15 <desegnis> Because I guess that would make life easier than the ghc way (by the expression ... in the lambda abstraction ... in the definition of ... etc. etc.)
09:36:37 <pejo> desegnis, just pinpointing which argument is of wrong type is actually quite tricky.
09:36:59 <desegnis> Well right, you don't know whether the programmer erred in the function or in the argument.
09:37:13 <desegnis> Or in both, but then it's her problem entirely.
09:37:24 <pjd> GHC tells you what's invalid, not what's wrong
09:38:07 <pejo> desegnis, but there's a lot of room for improvement wrt type error reporting. The stuff you mention would be very useful.
09:38:49 <desegnis> Hm, I'm currently realizing something about ghc's error reports:
09:38:53 <desegnis> > 1 + 'a'
09:38:55 <lambdabot>   add an instance declaration for (Num Char)
09:38:55 <lambdabot>     In the expression: 1 + 'a'
09:38:55 <lambdabot>  ...
09:39:17 <desegnis> ghc does not pinpoint where's the Char
09:39:44 <pjd> 'a' lacks an instance declaration for (Num Char)
09:39:50 <oerjan> ghc doesn't show its reasoning...
09:39:50 <pjd> would be much more helpful
09:40:04 <desegnis> pjd, exactly
09:40:05 <pjd> the "add an" sounds like an imperative suggestion
09:40:39 <desegnis> yes, that's an issue, too. "There is no" would look better
09:41:03 <desegnis> Or just: No instance Num Char  -- nearly Haskell syntax
09:41:04 <pejo> pjd, didn't those type of explainations show up when they implemented one of those type error reproting things by Heeren?
09:41:26 <pjd> pejo: i have absolutely no idea :)
09:44:54 <desegnis> Err, Is the “add an” thing a specialty of lambdabot?
09:45:40 <desegnis> Ah, no, it's just that lambdabot strips some lines.
09:46:08 <pjd> ah, right
09:46:23 <oerjan> desegnis: private msg shows the rest
09:47:08 <desegnis> Hey, this is funny:
09:47:10 <pjd> which points out that the error actually refers to the 1, not the 'a'
09:47:25 <desegnis> (see above lines ;-)
09:47:30 <desegnis> s/lines/line
09:47:38 <oerjan> um actually the + is sufficient
09:48:03 <desegnis> But they improved this since 6.6 by removing the reference to the 1
09:49:17 <desegnis> oerjan: What do you mean exactly?
09:49:26 <oerjan> > 'a' + 'b'
09:49:29 <lambdabot>   add an instance declaration for (Num Char)
09:49:30 <lambdabot>     In the expression: 'a' + 'b'...
09:51:01 <desegnis> > (1::Integer) + (2::Int)
09:51:02 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
09:51:48 <desegnis> That's the point where I always guess. I usually don't try to figure out where expected and inferred type, respectively, come into play
09:54:25 <doserj> the function *expects* a certain type, but the argument is *inferred* to be of a different type
09:55:54 <omnId> (+) :: Num a => a -> a -> a,  (+) (1::Integer) fixes 'a' to 'Integer', (+) (1::Integer) :: Integer -> Integer, (2::Int) does not match expected Integer.
09:56:41 <desegnis> hmright. but then:
09:56:47 <desegnis> > False || 0
09:56:50 <lambdabot>   add an instance declaration for (Num Bool)
09:56:58 <desegnis> What's that?
09:57:11 <LoganCapaldo> @type fromInteger
09:57:13 <lambdabot> forall a. (Num a) => Integer -> a
09:57:22 <omnId> @type (||)
09:57:22 <lambdabot> Bool -> Bool -> Bool
09:57:39 <desegnis> Ah, thanks, LoganCapaldo
09:57:40 <BMeph> > ?ty 0
09:57:40 <lambdabot>   parse error on input `?'
09:57:48 <BMeph> @ty 0
09:57:49 <lambdabot> forall t. (Num t) => t
09:57:49 <omnId> (fromInteger 0 :: Bool) == False
09:58:13 <oerjan> um no
09:58:24 <oerjan> > fromInteger 0 :: Bool
09:58:26 <lambdabot>   add an instance declaration for (Num Bool)
09:58:26 <lambdabot>     In the expression: fromInteg...
09:58:39 <LoganCapaldo> (toEnum 0 :: Bool) == False
09:58:39 <desegnis> > toEnum 0 :: Bool
09:58:41 <lambdabot>  False
09:58:48 <omnId> oh, oops
09:58:58 <omnId> toEnum, rather
10:00:16 <desegnis> Still, for the (False || 0) case, I'd prefer to read that ghc couldn't match Bool against (Num a => a)
10:01:33 <oerjan> :t 0 :: Num Bool => Bool
10:01:35 <lambdabot>     No instance for (Num Bool)
10:01:35 <lambdabot>       arising from the literal `0' at <interactive>:1:0
10:01:35 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
10:01:39 <BMeph> @index Bool
10:01:39 <lambdabot> Data.Bool, Prelude
10:01:42 <omnId> :), but if you have an instance Num Bool, then False || 0 becomes valid.
10:01:45 <oerjan> hmph
10:01:52 <BMeph> @src Num
10:01:53 <lambdabot> class  (Eq a, Show a) => Num a  where
10:01:53 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:01:53 <lambdabot>     negate, abs, signum     :: a -> a
10:01:53 <lambdabot>     fromInteger             :: Integer -> a
10:02:03 <BMeph> @src Bool
10:02:04 <lambdabot> data Bool = False | True deriving (Eq, Ord)
10:02:27 <desegnis> omnId: Yes, but I would understand that even if ghc didn't tell me
10:03:00 <Jomyoot_> is our bot written in haskell
10:03:13 <oerjan> @vixen Are you written in haskell?
10:03:14 <lambdabot> Ooh, functional programmers are so hot!
10:03:44 <omnId> @version
10:03:44 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
10:03:44 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:03:58 <desegnis> I'd rather wish for something concise such as: (False ||) expects Bool, but 0 has type Num a => a.
10:04:33 <desegnis> (alright, it may mention that there is no (instance Num Bool) afterwards)
10:04:45 <jaredj> how easy is it to bind haskell to c? does the c-to-haskell binding get you both ways?
10:05:47 <jaredj> er... s/^/ [OT]/
10:06:22 * oerjan doesn't see how that's off topic
10:06:26 <jaredj> oh k
10:06:27 <oerjan> @where ffi
10:06:28 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:06:53 <jaredj> aha, "and vice versa." thanks
10:07:11 <BMeph> Maybe it "knows" that Num is a sub-class,so it's "being helpful" by saying that this other class you're trying to use hasn't been established as an instance of the Num class.
10:07:37 <LoganCapaldo> err
10:07:49 <oerjan> BMeph: Num is the only class in those examples.  The rest are types
10:08:01 <LoganCapaldo> Num isn't a subclass. And there are no other classes in that expression
10:08:22 <omnId> BMeph: new to Haskell? :)
10:08:27 <clanehin> it's trying to construct a Bool using fromInteger, so it tells you what /it/ wants: an instance Num Bool.  If it knew what you wanted, it wouldn't need to print error messages.
10:09:39 <BMeph> It's not trying to do squat with fromInteger, because it doesn't think 0 is an Integer.
10:09:41 <oerjan> "0 has type Num a => a but is used in a context that expects Bool"
10:09:45 <LoganCapaldo> Instead of saying this doesn't type check because 0 isn't a Bool, it says to make this type check make Bool an instance of Num :)
10:09:45 <wy> hello!
10:10:01 <oerjan> BMeph: you are still new to haskell...
10:10:05 <LoganCapaldo> BMeph: numeric literals get fromInteger called on them
10:10:05 <BMeph> It thinks 0 is a Num. That's as far as it can infer.
10:10:09 <clanehin> BMeph: it is trying to use fromInteger :: Integer -> Bool
10:10:23 <omnId> BMeph: the first weird thing going on in (False || 0) is that numeric literals are polymorphic.  This means literals like 10 or 42 are implicitly changed to (fromInteger (10:Integer)), etc.
10:10:26 <LoganCapaldo> *integral numeric liteerals
10:10:32 <oerjan> 0 "desugars" to fromInteger (0 :: Integer)
10:10:38 <BMeph> If it were calling fromInteger on 0, it would think it was an Integer, not a Num.
10:10:39 <omnId> @type fromInteger
10:10:41 <lambdabot> forall a. (Num a) => Integer -> a
10:11:01 <omnId> @instances Num
10:11:01 <lambdabot> Double, Float, Int, Integer
10:11:15 <BMeph> It doesn'twant to assume that 0 is an Integer, because it could be a Float, or Double.
10:11:50 <mokus> BMeph: the way it becomes polymorphic is through an implicit fromInteger
10:11:54 <BMeph> Num is the most general class that 0's type can be in, but it doesn't know how to make a Bool out of a Num.
10:12:06 <omnId> BMeph: if you add instance Num Bool, then fromInteger could take on the type Integer -> Bool, thus 0 would represent False.
10:12:24 <Saizan_> or True :)
10:12:28 <omnId> (presuming that's how you implement fromInteger in the Num instance, of course)
10:13:09 <omnId> Saizan_: or _|_ :D
10:13:32 <Valodim> I wonder how they got the idea to have _|_ as error symbol
10:13:33 <oerjan> instance Num Bool where fromInteger 42 = True; fromInteger _ = False; ...
10:13:38 <sk> byorgrey: about yaht, not confusion, but I happened to be reading the part about Finitemap, and noticed that it was replaced with Data.Map.. just wondering if i was reading the latest version of yaht
10:13:44 <Valodim> it looks like symbolically flipping the bird _|_
10:14:04 <oerjan> Valodim: it's Bottom from logic
10:14:06 <mokus> _|_ is the 'bottom type' in the heirarchy of types, because it has no values
10:14:08 <omnId> Valodim: it's an upside-down T, for 'top', thus 'bottom'
10:14:13 <Valodim> ah
10:14:13 <mokus> it's a subset of overy other type
10:14:15 <Valodim> k
10:14:44 <Valodim> not in all fonts, but in most the | ends one pixel lower than than _ which results in that flipping off image, at least I see that everytime I look at it
10:15:00 <Valodim> "does not compute, screw you!"
10:15:25 <BMeph> @src Complex
10:15:25 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
10:16:07 <byorgey> sk: yeah, it might be slightly out of date I suppose
10:16:40 <desegnis> oerjan, clanehin: Right, the bad thing about the error message is that it's trying to make it typecheck. Instead it should first state why it doesn't type check, so that /I/ can think of a fix.
10:17:17 <desegnis> Well, there's a specific meaning of “why” in my sentence.
10:19:30 <desegnis> s/oerjan, clanehin/oerjan, clanehin, LoganCapaldo, etc./
10:20:10 <LoganCapaldo> I imagine it would be difficult to get that "right"
10:21:12 <omnId> "No instance for (Num Bool)" is why, though that's because 0 :: Num a => a.  It'd be difficult to say "Didn't match expected type Bool" since we don't know 0's actual type yet.
10:21:54 <BMeph> desegnis: In other words, you would "like" to see the "expected: ..., inferred: ..." form, instead of it jumping straight to "You need to give me a way to convert from this type to that one"?
10:21:59 <mokus> in this case at least, I think the behavior he's describing would be obtainable by changing the typechecker to not unify 'a' with 'Bool' when a is constrained in a way that Bool cannot satisfy
10:22:55 <omnId> desegnis, BMeph: yeah, it's the polymorphic literal that makes the error message seem the wrong way 'round.
10:25:46 <wy> I'll ask my questions again because here is more people than last night :-)
10:26:32 <wy> I'm figuring out what the code in Walder's original monad paper is doing. http://hpaste.org/4628
10:28:03 <wy> And I haven't completely understood the nature of the monad P in this interpreter. I know it actually converted "let" into lambda, but I want to know if this technique is a widely used pattern in monadic programming
10:28:28 <oerjan> wy: are you turning off the MR restriction? otherwise (unitM, bindM, showM) = (unitP, bindP, showP) will give you trouble
10:28:44 <oerjan> er wait
10:29:01 <oerjan> no classes involved, scratch that
10:29:05 <doserj> wy: it is the reader monad, isn't it?
10:29:07 <Associat0r> am I correct to assume that type classes are like compile type polyphormism like C++ templates but with constraints?
10:29:31 <wy> oerjan: I didn't know. I've set the option -fglasgow-exts
10:29:51 <oerjan> wy: that wouldn't have helped i think
10:29:55 <wy> doserj: I haven't learn so many monads at the time. I'm trying to understand his paper first
10:30:21 <wy> oerjan: But it works. You can try to see if it give trouble in your setting
10:30:51 <oerjan> wy: i said, scratch that. :)
10:31:10 <doserj> wy: or rather, it is ErrorT (Reader ..)
10:31:28 <wy> reader...
10:31:34 <oerjan> i saw the pattern binding of polymorphic functions and as usual forgot the last requirement.
10:32:00 <wy> OK. Do you also think it's a reader. oerjan ?
10:32:06 <oerjan> sure
10:32:18 <wy> alright. I'll remember its name and go on
10:33:01 <doserj> erm... ReaderT (Error ..), this way round, I think now...
10:33:02 <oerjan> all the monads in the paper are in base/mtl except the weird backwards state monad
10:33:05 <wy> Any pointers where to continue after finish reading this paper?
10:33:32 <sk> wy: continue with what?
10:33:40 <wy> What does mtl stand for?
10:33:47 <wy> sk: continue learning monads
10:33:52 <oerjan> monad transformer library, i think
10:33:54 <desegnis> BMeph: Yes. (Right, there's a bit of a delay on my side today.)
10:34:31 <oerjan> one of the packages usually bundled with ghc
10:34:52 <wy> Thanks.
10:35:00 <oerjan> containing most of the Control.Monad.* hierarchy on the doc page
10:35:28 <wy> I noticed that there is no direct way to pass the error out. Is that true that it's the real constraint in any language and compiler?
10:36:42 <oerjan> wy: the Control.Monad.Error module contains a catch function
10:37:03 <oerjan> @src MonadError
10:37:04 <lambdabot> class (Monad m) => MonadError e m | m -> e where
10:37:04 <lambdabot>     throwError :: e -> m a
10:37:04 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
10:37:30 <wy> Another way might be to pass in a continuation into the closures, once an error is found, it's passed out immediately. But that requires you to pass something inside... It's the same cost
10:38:45 <wy> Maybe this is what I'm saying
10:39:39 <pejo> wy, there's a paper written by Mark P. Jones for a springschool, http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf. In general the spring/summer school papers on things are well written and a bit more verbose than the original papers.
10:42:36 <wy> pejo: Thanks for the reference :-)
10:50:36 <wy> oerjan: I think this is a way to construct "let". Do you think so?
10:51:18 <oerjan> i understand the reader monad is often used for nested scopes, such as with let
10:52:19 <Philippa> it's a natural fit for it, you get the same kind of scoping discipline
10:53:48 <LoganCapaldo> reader is fun!
10:54:53 <wy> still illusive to me...
10:55:06 <wy> How somebody could have thought about this?
10:56:17 <Philippa> wy: the 'essence' of lexical scoping is "do this block with this bunch of different info then come back to what I was using"
10:56:29 <Philippa> after a while, you notice you're writing code to do that in something like a state monad rather a lot
10:57:40 <wy> Is it because this is hard to understand?
10:58:52 <roconnor> @remember Dyson In the game of life and evolution there are three players at the table: human beings, nature, and machines. I am firmly on the side of nature. But nature, I suspect, is on the side of the machines.
10:58:53 <lambdabot> It is stored.
10:59:46 <r3m0t> hello there. how can I make a binary tree where the path from root to end node is the same for every node?
11:00:23 <roconnor> r3m0t: ?
11:00:34 <roconnor> r3m0t: that question didn't quite make sense to me.
11:00:34 <wy> r3m0t: singleton?
11:00:35 <r3m0t> don't you question mark me ;-)
11:00:36 <oerjan> r3m0t: you mean the length of the path?
11:00:42 <r3m0t> length of the path, yes
11:00:49 <roconnor> ah
11:00:54 <wy> ah2
11:01:12 <roconnor> ... Dependent types would do it.
11:01:16 <roconnor> any other way?
11:01:17 <Zao> So you want only the leaves to be nodes?
11:01:25 <Modius> In suitability for the learning and expression of certain higher concepts, where do you see Haskell wrt. APL family languages (like J)?
11:01:39 <oerjan> there's a cool type trick for it i vaguely recall
11:01:51 <wy> roconnor: He might not want a type for this?
11:01:52 <roconnor> r3m0t: so there will be exactly 2^n leaves?
11:01:56 <Modius> (I'm not trying to start a language pi**ing match - any links that would put this in perspective appreciated)
11:02:07 <r3m0t> roconnor: yes
11:02:24 <roconnor> wy: oh good point. Me, always thinking about types.
11:02:57 <wy> r3m0t: Do you want a type that can classify this type of tree, or do you just want a function that can construct such a tree?
11:03:37 <r3m0t> I want a datatype for it
11:03:55 <wy> roconnor: ... you are right
11:04:38 <wy> r3m0t: So trees not satisfying this will not be considered to be this type...
11:04:41 <roconnor> oh, maybe we can use nested data types somehow.
11:05:04 <wy> You can't count...
11:05:22 <wy> Oh, maybe GADT can do it
11:05:35 <byorgey> Modius: higher-order functions and such in J are sort of ad-hoc.
11:05:48 <roconnor> wy: right a GADT would manage nicely
11:05:50 <wy> We don't actually need the values, so computing in the type world would be enough
11:06:06 <oerjan> i think maybe there was one type for each size
11:06:14 <byorgey> Modius: I think learning Haskell would help immensely in learning J, but not vice versa.
11:06:39 <byorgey> Modius: I know that's not exactly what you asked, but hopefully it sort of answers your question indirectly =)
11:07:01 <wy> wait... Do we really don't need the values...
11:07:17 <oerjan> data Tree t a = Tree (t a) (t a)
11:07:33 <LoganCapaldo> | Empty ?
11:07:40 * ricky_clarkson spots 'oleg' in his Firefox search field and panics.
11:07:44 <oerjan> and then you can use Tree (Tree (Tree (Tree Id))) Int
11:07:57 <LoganCapaldo> oh
11:08:08 <oerjan> LoganCapaldo: no, no empty.  you want to enforce the same structure everywhere
11:08:23 <LoganCapaldo> yeah  just caught that
11:08:30 <oerjan> (newtype Id a = Id a)
11:10:10 <wy> oerjan: Can you count without GADT?
11:10:30 <roconnor> wy: you can count with type classes and fun deps.
11:11:02 <wy> roconnor: ... fun deps is something I haven't learned yet
11:11:03 <oerjan> wy: what if we put Id and Tree in a type class, wouldn't an existential be enough?
11:11:17 <roconnor> oerjan: I fear that your type is too flexible, because people may end up putting crazy stuff in for t.
11:11:30 <oerjan> roconnor: thus a type class
11:11:57 <oerjan> and you could always hide things by not exporting...
11:12:41 <r3m0t> I thought it could be something more like (Node (a::(Tree 2)) (b::(Tree 2))) :: Tree 3
11:12:43 <roconnor> data FullTree s a | Leaf :: a -> FullTree () a | Branch :: FullTree s a -> FullTree s a -> FullTree (Maybe ()) a
11:12:49 <roconnor> or whatever the GADT notation is
11:13:18 <sk> oerjan: what type class you think should t inherit?
11:13:35 <oerjan> r3m0t: well the nested Tree things can replace your numbers i think
11:13:39 <oerjan> sk: a new one
11:14:48 <wy> I haven't proved that we can know if a tree is a full tree before we have computed it...
11:15:51 <oerjan> wy: tie the knot! :)
11:16:40 <wy> oerjan: What if we have functions that do recursion on numbers, and construct unbalanced branches according to those numbers
11:18:00 <oerjan> wy: you can only combine two branches if they have the same type
11:18:11 <oerjan> which means the same size
11:19:03 <wy> My brain needs food...
11:19:54 <wy> No. I mean, I'll eat my breakfast. See you soon!
11:24:57 <sk> oerjan: the Tree constructor would take 2 arguments right?
11:25:03 <oerjan> sk: right
11:25:26 <wy> oh, right. Once your tree becomes non-full, you have no way to construct a full tree
11:26:29 <sk> in that case: Tree (Tree (Tree (Tree Id))) Int => this would refer to a type declaration?
11:26:59 <oerjan> that would be the type of a tree of 16 Ints
11:27:37 <sk> i get it now, damn my brain needs fuel
11:28:28 * roconnor thinks the GADT solution is simpler.
11:29:06 <Philippa> hmm, that reminds me of a problem I ought to ask what the current state of the art on solving is...
11:29:37 <Philippa> oh, wait, I think I know where to look already, nevermind
11:29:47 <Saizan_> roconnor: your choice of () and Maybe looks a bit random, but yeah :)
11:30:00 <oerjan> roconnor: i don't think that quite works
11:30:37 <oerjan> you can combine FullTree (Maybe ()) a  branches unbalancedly
11:31:06 <Saizan_> oerjan: it's just counting the depths in the phantom parameter, Maybe = Succ, () = Zero
11:31:11 <oerjan> um, maybe you mean Maybe s ?
11:31:40 <Saizan_> uh, i was reading it as (Maybe s)
11:32:05 <oerjan> ok just a simple typo
11:35:49 <roconnor> oerjan: oops, right I mean (Maybe s)
11:35:59 <moconnor> What's the syntax for including the -fglasgow-exts directive in a comment in Haskell source?
11:36:46 <roconnor> {-# GHC_OPTIONS -fglasgow-exts #-}
11:37:00 <moconnor> roconnor: thank you
11:37:13 <oerjan> o_O
11:37:50 * oerjan for a moment wondered if someone was talking to himself
11:38:10 <shachaf> Isn't that OPTIONS_GHC?
11:39:01 <roconnor> shachaf: I cut and paste from my source file ... I supose my source file could be wrong.
11:39:22 <shachaf> roconnor: Hmm, it seems that either is valid?
11:39:23 <skew> Isn't {-# LANGUAGE GADTs #-} the new thing?
11:40:17 <wy> O_o
11:40:22 <moconnor> OPTIONS_GHC worked for me (via runhaskell) GHC_OPTIONS didn't
11:40:48 <oerjan> users guide says OPTIONS_GHC
11:40:53 <roconnor> shachaf: yeah I appear to have GHC_OPTIONS only in one source file :(
11:41:10 <roconnor> the rest are OPTIONS_GHC
11:41:34 <oerjan> and by a freak accident that file is pure H98? :)
11:41:41 <roconnor> ... I guess I don't need -fno-monomorphismrestriction for that file after all
11:41:52 <moconnor> With GADTs is it possible to use "deriving"?
11:41:58 <oerjan> moconnor: no
11:42:07 <shachaf> roconnor: What about {-# LANGUAGE NoMonomorphismRestriction #-}?
11:42:24 <moconnor> ok.  Do GADTs just not make sense w/ what deriving is doing under the hood?  Or is it just not implemented?
11:42:38 <ndm> @seen kosmikus
11:42:39 <lambdabot> kosmikus is in #haskell, #darcs, #xmonad, #ghc and #gentoo-haskell. I last heard kosmikus speak 4h 27m 39s ago.
11:43:12 <oerjan> next up, {-# LANGUAGE NoInsanelyLongLanguageOptionsPleasePrettyPlease #-}
11:43:30 <ndm> anyone know how to set up lhs2tex to do [| foo |] as nice semantic brackets?
11:44:19 <ndm> oerjan: solution is to use Haskell 98 :)
11:46:11 <oerjan> moconnor: may be hard to get the necessary contexts when everything is implicitly existentially quantified?
11:46:44 <wy> still illusive after getting food
11:47:17 <SamB> moconnor: I guess it probably wasn't obvious how to do it...
11:47:26 <moconnor> ok, fair enough
11:47:50 <oerjan> like if you have a field MyField :: a -> Int -> MyGADT Int and try to derive Show, you won't have anywhere to get Show a from...
11:47:51 <skew> ndm: not exactly, but you need to set up a lhs2tex macro, so your source looks like Bracket(foo)
11:48:12 <ndm> any way that doesn't involve changing the source?
11:48:15 <skew> ndm: then you tell it Bracket(x) = [| x |] for copiling, and whatever TeX for printing
11:48:32 <ndm> i currently have it as \< foo \> then set up macros forthose two
11:48:59 <skew> can you set up a macro for [| then?
11:49:35 <ndm> no, since its not a variable in haskell
11:50:21 <ndm> %format \< = "[\![" -- works fine
11:50:39 <ndm> %format [| = "[\![" -- gives an error when preprocessing with lhs2tex
11:50:53 <skew> not a valid operator, right
11:51:05 <ndm> "syntax error in directive"
11:51:20 <ndm> but i guess it lexes [ and | separately, and then won't let you replace between them
11:51:44 <skew> I think I've always seen that sort of thing done with a macro that expands to brackets or to TeX
11:52:15 <ndm> :(
11:52:22 <skew> I wonder how it recognizes arrows
11:52:25 <ndm> its ugly when you are typsetting Template Haskell
11:52:30 <ndm> arrows are trivial - they are one lexeme
11:52:49 <skew> you could always filter through sed
11:52:56 <ndm> hmm, i guess
11:53:01 <ndm> but i'd rather not, if possible
11:53:27 <ndm> would probably be worth it though....
11:55:07 <skew> or maybe to patch lhs2TeX?
11:55:18 <ndm> can't even build it on GHC 6.8
11:55:22 <skew> what are you typesetting anyway?
11:55:27 <ndm> my thesis
11:55:31 <skew> oh, then it definitely needs some patching :)
11:55:47 <ndm> yeah, but its over SVN, which makes me a bit more reluctant
11:56:07 <ndm> plus hacking the Setup.hs script should be left to the professionals - its all cabal version skew, and i have no idea what it was meant to do originally
12:00:36 <skew> ndm: does supero depend on much besides YHC?
12:02:50 <ndm> skew, the concept or the code?
12:03:02 <skew> ndm: The code - I sent you some mail the other day, I have some notions about CPS and the termination condition I want to test
12:03:33 <ndm> skew: it takes me about an hour to get it building on a fresh machine, its not massively complex, but its not release easy
12:03:44 <skew> YHC is building now.
12:03:56 <wy> oerjan: Let me verify it... Is that P monad the only way to pass information into the scopes?
12:05:43 <ndm_> skew, my sister unpluged the router...
12:06:09 <ndm_> skew - install Yhc, you only need to do "scons build yhc" then "scons build libraries"
12:06:45 <oerjan> wy: not in principle, it's just nice for anything that's passed strictly inward...
12:06:47 <skew> "can't connect to http://svn.python.org"
12:07:19 <wy> oerjan: Are there any other ways very different from this?
12:07:57 <ndm_> wy: you can set it to not  both connecting and downloading libffi from there, but do it from a local tarball
12:08:08 <ndm_> skew: i meant (not wy)
12:08:43 <oerjan> the state monad is different, allowing to pass information both ways...
12:08:45 <ski> r3m0t : data BalancedTree a = Leaf a | Branch (BalancedTree (a,a))
12:09:00 <ndm_> skew: add ctypes=snapshot to the command line you are using
12:10:03 <skew> ah, thanks. it's compiling things now
12:11:10 <wy> oerjan: That's my next goal :-)
12:14:25 <wellwisher> Does anyone know what win32 header pid_t is defined?
12:16:18 <marshr> winnt.h ?
12:17:55 <oerjan> ski: ah, that was it, much simpler
12:18:21 <Zao> wellwisher: I can't seem to find it in my VS installation dir.
12:18:33 <Zao> wellwisher: Or at least, findstr can't find it.
12:18:38 <Zao> wellwisher: It smell awfully posixish.
12:18:41 <ski> oerjan : though one still needs to figure out how one recurses over the thing (.. which i'm thinking about now :)
12:21:44 <marshr> wellwisher: Process IDs are usually treated as DWORDs in win32 headers
12:22:27 <oerjan> traverse f (Leaf a) = Leaf <$> f a; traverse f (Branch t) = Branch <$> traverse (f *** f) t, i think
12:22:32 <oerjan> oh wait
12:22:43 <r3m0t> ski: I don't get it :-(
12:22:45 <ski> :t traverse
12:22:46 <lambdabot> Not in scope: `traverse'
12:22:55 <oerjan> :t Data.Traversable.traverse
12:22:56 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:22:59 <ski> r3m0t : what don't you get ?
12:23:12 <oerjan> that f *** f is not quite right
12:23:27 <wellwisher> thanks Zao
12:23:29 <ski> oerjan : could that handle the nestedness ?
12:23:43 <r3m0t> what is a tree with 3 on the left and 4 on the right?(e.g.)
12:24:00 <ski> Branch (Leaf (3,4))
12:24:19 <ski> Branch (Branch (Leaf ((0,1),(2,3))))
12:24:20 <ski> etc
12:24:29 <oerjan> ski: let's do a pure version first, just fmap
12:24:47 <r3m0t> oh, ok
12:24:51 <r3m0t> interesting
12:24:57 <dons> whoa. did peter lund send out benchmarks broken over 16 consecutive emails?
12:25:03 * ski had another idea in mind .. but possibly something simple can work :)
12:25:16 <oerjan> fmap f (Leaf a) = Leaf (f a); fmap f (Branch t) = Branch (fmap (f *** f) t)
12:25:40 <oerjan> i think that's right
12:25:44 <ski> *nod*
12:25:47 <ski> and folds ?
12:25:53 <r3m0t> originally I wanted a node-labelled rose tree, so just
12:26:04 <oerjan> folds can be defined once you have traverse
12:26:09 <ski> sumBTree :: Tree Integer -> Integer
12:26:11 <r3m0t> data BalancedRTree a = Leaf a | Branch (BalancedTree (a,[a]))
12:27:03 <ski> r3m0t : should the nodes really be labelled with subtrees ?
12:27:20 <r3m0t> what do you mean?
12:28:08 <ski>   Branch (Branch (Leaf ((0,[1,2]),[(3,[4,5,6]),(7,[8])])))
12:28:12 <ski> is a valid tree, there
12:28:37 <r3m0t> oh yeah. ugh. um.
12:28:42 <ski> mayhaps
12:29:10 <ski> type BalancedRTree a = LabelledBRTree a a
12:29:34 <r3m0t> data BalancedRTree a = Leaf a | Branch (a, BalancedTree ([a]))
12:29:39 <r3m0t> data BalancedRTree a = Leaf a | Branch (a, BalancedRTree ([a]))
12:29:54 <ski> data LabelledBRTree a t = Leaf t | Branch a (LabelledBRTree a [a])
12:29:59 <ski> maybe something like that .. hm
12:30:46 <oerjan> foldMap f (Leaf a) = f a; foldMap f (Branch t) = foldMap (uncurry mappend . (f *** f)) t
12:30:59 <ski> r3m0t : you want (in this example) only numbers as labels, but a nested list of numbers in the leaf, yes ?
12:31:05 <r3m0t> yes
12:31:24 <ski> (or maybe you want nothing of value in the leaf, at all ?)
12:31:59 <ski> oerjan : onoid', eh ?
12:32:07 <ski> s//`M/
12:32:10 <oerjan> :t Data.Foldable.fold
12:32:11 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
12:32:18 <ski> ah :)
12:32:22 <oerjan> :t Data.Foldable.foldMap -- er
12:32:23 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
12:33:05 <ski> then maybe you don't need my `foldBTree :: (forall a. a -> k a) -> (forall a. k (a,a) -> k a) -> BinaryTree a -> k a' ? :/
12:34:01 <oerjan> eek
12:34:05 <ski> (not sure if i need a constraint on `k', btw)
12:34:08 <ski> (:
12:36:23 <wy> oerjan: I rewrote bindP into this form, and it's easier to understand.
12:36:26 <wy> m `bindP` k = \p -> case (m p) of (Success a) -> k a p; (Error a)   -> Error a
12:37:48 <ski> hmm
12:38:35 <ski>   foldBTree leaf branch (Leaf a) = leaf a
12:38:37 <ski>   foldBTree leaf branch (Branch taa) = foldBTree leaf branch (branch taa)
12:38:53 <ski> should work, i think .. but it seems somehow needlessly inefficient
12:39:08 <ski> (unless some clever deforestation can spring into work)
12:39:16 <oerjan> wy: right.  the bindP given is a transformer, you can plug in any bind from another monad for bindE i think
12:39:45 <ski> oerjan : :t bindP
12:39:46 <oerjan> (see ReaderT)
12:40:27 <oerjan> well, not literally, i mean it comes from one
12:40:56 <ski> doing a parser monad transformer ?
12:41:45 <oerjan> ski: wy is reading one of SPJ's original papers
12:41:54 <ski> on .. ?
12:42:43 <oerjan> lots of example monads
12:42:53 <oerjan> without syntactic sugar
12:42:56 <ski> ok
12:43:05 <wy> without type classes...
12:44:02 <oerjan> he writes something like he wanted to show such fancy things weren't needed
12:44:19 <wy> actually someone recommended this paper to me a few days ago. I took some time review my haskell learned a year ago, then came back to this paper yesterday
12:45:13 <wy> the author is actually Wadler. I wonder if we have type classes back in 1992?
12:45:31 <oerjan> oh i misremembered
12:45:35 <oerjan> type classes, yes.
12:45:49 <oerjan> type _constructor_ classes were at least much newer
12:46:07 <oerjan> i.e. classes for things not of kind *
12:46:27 <Cale> I think constructor classes were introduced in 1.3
12:47:07 <ski> r3m0t : anyway, the tricky part about this nested datatype is figuring out how to recurse over it to compute what you want .. probably the solutions given here work, if one can figure out how to use them .. (i was wondering how to make it more efficient .. and maybe natural, FSVO)
12:47:48 * ski seems to remember a third solution from the paper .. something about using a nested stream of functions, or something like that
12:47:53 <Cale> and the 1.3 report was in May 1996, so it's some point between March 1992 and May 1996 that constructor classes happened.
12:47:58 <oerjan> hm... can you simply get out the two subbranches somehow?
12:48:28 <oerjan> Cale: i seem to recall Gofer being mentioned
12:48:40 <Cale> Yeah, Gofer was the first thing to implement them.
12:49:00 <ski> oerjan : i think my `foldBTree' can do it
12:49:19 <wy> I still think type classes only need one parameter
12:49:32 * Cale wonders if he can get all the old release notes for Gofer.
12:49:50 <oerjan> ski: but it should be possible to do efficiently
12:50:04 <skew> ndm_: I see contexts is commented out in the current uniplate, something to do with Str
12:50:04 <ski> oerjan : .. yes, it should
12:50:05 <Philippa> wy: do you have an alternative for typing various uses of MPTCs? I run into natural MPTCs fairly often
12:50:43 <Cale> Gofer 2.28 was the version which introduced them.
12:50:58 <Cale> That was in February 1993.
12:51:28 <wy> Philippa: I thought we could just put the other parameters in a paren with the type constructor.
12:51:36 <ndm_> skew: yes, i'm moving from old-uniplate to new-uniplate - you shouldjust use the old version
12:51:44 <wy> so it's like a pattern matching
12:51:54 <skew> ndm_: what's the point of using Str rather than a simple list?
12:52:04 <oerjan> split (Branch (Leaf (x,y))) = (Leaf x, Leaf y); split (Branch t) = (Branch x, Branch y) where (x,y) = split t
12:52:13 <ndm_> skew: higher performance, no need for continuations, better laziness, simpler to write definitions
12:52:17 <Philippa> wy: doesn't work, they won't unify appropriately with method types
12:52:46 <wy> Philippa: Are most of the other parameters just components of the type?
12:53:02 <ndm_> skew: if you install the version from hackage that should work fine
12:53:21 <Philippa> wy: components of which type?
12:54:02 <Philippa> but probably not, no
12:54:02 <wy> Philippa: Let's say... IArray...that's the only MPTC I've met (I'm too new ;-)
12:54:32 <Philippa> okay, suppose you've got a class that links references and the monads they can be accessed from - how would you implement that?
12:55:00 <ski> oerjan : of course :)
12:56:05 <wy> Philippa: That's out of my experience. Sorry ;-)
12:56:33 <Philippa> wy: basically it's a bad idea to assume that because you haven't seen a good use case for a feature nobody else has :-)
12:57:10 <wy> Philippa: right. I'm just trying to play devil's advocate. That's one way to prove something is cool :-)
12:58:24 <Cale> wy: Components?
12:58:46 <ski> (oerjan : a while ago, i played some with "CPSed" types, hence i'm trying to fit this problem into my thinking on that ;)
12:58:59 <oerjan> aha
12:59:09 <skew> with type functions you could make a new type constructor tuple all the parameters
12:59:34 <wy> Cale: I don't know the appropriet word for that
12:59:36 <ski> (but i think i'd need to sit down with pen and pencil to remember how it went ..)
12:59:51 <wy> Cale: or arguments?
13:00:04 <Cale> wy: perhaps, I'm a bit lost in this discussion :)
13:00:28 <wy> Cale: Let's see an example: class IArray a e where...
13:01:27 <wy> Cale: e is going to be used as in (a i e), so I say "e is a component of a"
13:01:36 <Cale> ah, okay
13:01:41 <Cale> No, that's not usually the case.
13:01:48 <ski> or `a i e' determines `e' ?
13:03:03 <wy> alright
13:03:03 <Cale> For another example, let's look at the class MonadState
13:03:13 <Cale> class Monad m => MonadState s m | m -> s where
13:03:13 <Cale>    get :: m s
13:03:13 <Cale>    put :: s -> m ()
13:03:34 <Cale> (well, okay, the type of get uses s as a parameter to m)
13:03:48 <Cale> but put doesn't
13:05:01 <wy> ... I haven't fully understood monads yet
13:05:22 <wy> Halfway through states currently
13:06:24 <Cale> Well, the meaning here is that you have some monad m and some type of state s
13:06:35 <dons> http://programming.reddit.com/info/63p12/comments/
13:06:40 <dons> `What's happening with Haskell? The 13th Haskell Community Report'
13:06:41 <wy> So the second m is not in any way associated with s?
13:06:43 <Cale> get is a computation in the monad m which gets the current state
13:07:00 <Cale> Oh, it's associated with s *somehow*
13:07:17 <Cale> (in particular, s is a type of state which is managed by computations of type m)
13:08:56 <ski> `| m -> s' mean that, if you know `m', there could be at most one `s' such that `MonadState s m'
13:09:02 <Philippa> but I might have a monad IntState where s would always be Int, and a parameterised State s where the class's s is the type constructor's parm
13:09:27 <ski> instance MonadState Int IntState
13:09:31 <ski> instance MonadState s (State s)
13:10:29 <ski> instance MonadState s m => MonadState s (SomeMonadTransformer s m)
13:11:07 <ski> (actually s/s m)/m)/)
13:13:02 <ski> the point being that, if you know `m', you "know" `s' .. in the sense that it is determined .. but to actually get what `s', you may have to trace through the relevant instance declarations regarding `m' and `s' .. just looking at `m' doesn't do it
13:13:46 * ski has no idea whether that's intelligble
13:19:51 <ndm_> offtopic, but anyone know how to do variables in latex? #latex is not much help :(
13:23:38 <allbery_b> "variable" is a bit too general for latex's worldview.  what are you actually trying to do?
13:24:51 <ndm_> allbery_b: \setvariable{foo}{bar}, \getvariable{foo} returns bar
13:25:04 <ndm_> i could do it if i wanted Int's using setcounter
13:26:55 <allbery_b> \newcommand{foo}{bar} \renewcommand{foo}{bar} \foo
13:27:29 <ndm_> alas, no use, since renewcommand won't propogate into already defined commands
13:27:36 <allbery_b> there are no generic "variables" as such, because "commands" are really macros and the others are special registers (counters, lengths, boxes, etc.)
13:28:21 <allbery_b> urgh.  depending on how it's used, your best bet is probably a box
13:30:54 <Liskni_si> hm, defs should propogate to already defined cmds
13:31:22 <ndm_> they don't seem to...
13:31:45 <ndm_> have managed to find a sub-optimal work around for my particular case, so we can get back to type level programming
13:31:55 <ndm_> (which is still substantially more logical than latex programming)
13:32:56 <dmwit> I'm pretty sure latex wasn't designed for "programming".
13:33:02 <Liskni_si> well, \setbeamertemplate uses \def and works
13:33:09 <allbery_b> assuming this is text to be typeset: \newsavebox{\mybox} \savebox{\mybox}{...} \usebox{\mybox}
13:33:20 <dmwit> If there is a proof that it is Turing complete, I'm sure everybody who sees it shudders.
13:33:47 <allbery_b> yeh, it's pretty horrific
13:33:53 <kosmikus> proving LaTeX Turing complete isn't difficult
13:34:00 <kosmikus> hi ndm
13:34:35 <kosmikus> have you solved your lhs2TeX problem from a while ago? [| can't be used directly, you can only use workarounds, either on the lhs2tex or on the LaTeX side
13:34:48 <ndm_> it isn't hard to prove it turning complete, but it is not turing friendly
13:35:10 <ndm_> kosmikus: i did solve it in the end, i found a 6.6 machine and compiled it there and grabbed the binary
13:35:22 <ski> aka turing tar pit
13:36:15 <ndm_> kosmikus: i used $| and |$ for [| and |] - but it would be nice if lhs2tex supported them natively
13:36:56 <kosmikus> I'm very reluctant to change the lexing behaviour of lhs2tex, because it might break a lot of old documents
13:37:13 <skew> kosmikus: old documents that use [| ?
13:37:19 <kosmikus> that being said, I recently had a plan for allowing the definition of new tokens flexibly
13:38:09 <kosmikus> skew: that was a general statement
13:38:16 <kosmikus> one can argue that this case is unlikely to cause trouble
13:38:38 <ndm_> you can still lex it as "[" and "|" - if you just extended the %format to allow multiple tokens on the LHS and do maximal munch when matching format directives
13:38:44 <kosmikus> but I've seen so many examples already of supposedly minor changes that had strange side effects that were difficult to debug
13:39:12 <ndm_> i can see your reluctance to screw up old documents, and support it heavily!
13:41:09 <kosmikus> ndm_: you suggestion is pretty close to what I had in mind
13:41:55 <kosmikus> let's see how much time I have during the next week
13:41:58 <ndm_> neat :)
13:43:11 <kosmikus> as to compilation with 6.8 ... I should release 1.13. pre2 is actually available from my webpage, just not linked.
13:43:39 <kosmikus> 1.13 also uses filepath.
13:44:26 <ndm_> neat :)
13:44:41 <ndm_> i was a little stuck last week, as i was at my g/f's who lives on a campus
13:44:52 <ndm_> with GHC 6.8, and no SVN access
13:45:17 <ndm_> and no SSH :(
13:45:55 <skew> ndm_: Calling "uniplate", is it assumed that the replacement Str of children has the same form as the returned one?
13:46:16 <ndm_> skew: yes
13:48:53 <ndm_> skew: what are you using the new uniplate for? you should just be able to use the one Yhc puts in depends/uniplate
13:49:55 <ndm_> the new one is very not finished:)
13:50:20 <kosmikus> ndm_: yes, I'm sorry that I got delayed with releasing lhs2TeX, but ironically, it's HCAR's fault
13:50:36 <ndm_> kosmikus: yeah, when i saw that come out today, i guessed
13:50:38 <skew> well, I think I fixed the commented-out functions
13:51:05 <ndm_> skew: i left them out because i think contexts can be defined in terms of holes, so wasgoing to think about that, but i'll happily accept a patch
13:51:17 <skew> yeah, that's exactly how I defined it
13:51:24 <skew> holes was commented out as well
13:51:25 <ndm_> neat :) - then send it over
13:51:28 <ndm_> yeah
13:51:40 <skew> also added holesOn, for defining contextsOn
13:51:54 <ndm_> @karma+ skew
13:51:54 <lambdabot> skew's karma raised to 2.
13:51:58 <skew> I suppose Data.Generics.Str needs to be a public module now, for anybody to write instances?
13:52:29 <ndm_> skew: yes, it does - but i'm still wondering exactly what operations to provide upon Str, before i make it too public
13:53:29 <ndm_> pam should definately be named something else :)
13:55:58 <Philippa> for purposes of an argument elsenet: what apps use gtk2hs at the moment?
13:59:23 <wy> Can () still be used as the type of values to be ignored?
13:59:40 <nornagon> no
13:59:42 <nornagon> :t ()
13:59:43 <lambdabot> ()
13:59:46 <ndm_> undefined
13:59:51 <ndm_> @type undefined
13:59:51 <lambdabot> forall a. a
14:00:12 <nornagon> > () :: Int
14:00:12 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
14:00:45 <wy> is it also a constructor?
14:00:59 <pastorn> :i ()
14:01:08 <wy> :i undefined
14:01:16 <pastorn> @info ()
14:01:17 <lambdabot> ()
14:01:18 <nornagon> > (\ () -> "hi!") ()
14:01:19 <lambdabot>  "hi!"
14:01:30 <nornagon> :k ()
14:01:31 <lambdabot> *
14:02:18 <wy> > (\undefined -> "hi") 10
14:02:18 <lambdabot>  "hi"
14:02:56 <wy> why not use _ ?
14:03:26 <ricky_clarkson> > (\undefined -> undefined) 10
14:03:27 <lambdabot>  10
14:03:46 <ricky_clarkson> Why not use const "hi"?
14:03:59 <nornagon> @pl \undefined -> undefined
14:04:00 <lambdabot> id
14:04:13 <wy> What's @pl?
14:04:23 <ricky_clarkson> Converts to point-free style.
14:04:48 <wy> Is it available in ghci?
14:05:01 <allbery_b> @where goa
14:05:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
14:05:03 <ricky_clarkson> Yes, but not as standard.
14:05:10 <allbery_b> ...but I don't think it builds currently :(
14:05:45 <ricky_clarkson> You can /msg lambdabot anytime. ;)
14:08:52 <wy> So my states monad finished with () changed to undefined: http://hpaste.org/4633
14:15:38 <Philippa> also, for debate purposes: I got the impression that if you use the FFI to write C-in-Haskell and use the non-threaded RTS then your code is likely to be fairly close to C in speed with much of the difference attributable to memory management and the like.
14:15:45 <Philippa> is this fairly accurate?
14:17:58 <Associat0r> anyone used clean?
14:20:40 <skew> Philippa: I think GHC is not quite as good with loops and arrays and so on
14:22:29 <skew> Philippa: there was a thread on cafe around when 6.8.1 came out
14:23:18 <Philippa> skew: fair enough. The overheap there's in the Haskell code rather than the FFI though
14:23:27 <Philippa> *overhead
14:24:17 <skew> Philippa: that was all calls like peek and put. I don't think those have any special overhead
14:24:33 <Philippa> I need to know about calls to C code
14:24:52 <ricky_clarkson> Philippa: See "back end stuff" in this doc: http://www.haskell.org/communities/12-2007/html/report.html
14:24:52 <lambdabot> Title: Haskell Communities and Activities Report
14:24:56 <dmwit> wy: Is there a particular reason you're not using the Monad class?
14:25:06 <ricky_clarkson> I'm not sure how applicable it is but it's the closest I've come across.
14:25:28 <skew> Philippa: Oh, I thought C-in-Haskell meant working with raw memory with the Foriegn libraries, but not actually calling out
14:25:32 <ricky_clarkson> dons: If you're involved in writing that doc, how about a ToC and relative links? ;)
14:25:43 <Philippa> skew: assume interaction with libraries :-)
14:25:55 <wy> dmwit: The reason is that I'm just copying and understanding the code in the paper ;-)
14:26:18 <dmwit> ah
14:26:30 <dmwit> So, what doesn't work as expected?
14:26:57 <skew> Philippa: I think an unsafe foreign call in the unthreaded runtime is quite cheap
14:27:32 <wy> The plan is that I first write it that way without any class, and then aha, I found a pattern in all the things and put them into a class.
14:27:46 <dmwit> ok
14:29:03 <lichtkind> audreyt: ping
14:30:43 <ndm_> skew: many thanks, patches received and pushed
14:31:49 <Associat0r> http://web.cecs.pdx.edu/~mpj/pubs/plos07.pdf
14:31:49 <Associat0r> http://plosworkshop.org/2007/presentations/diatchki.pdf
14:31:49 <Associat0r> Systems Haskell
14:32:31 <Associat0r> can anyone here tell me about their experiences with clean?
14:38:26 <skew> ndm_: why is pam not fmap?
14:40:13 <ndm_> skew: could you define Str as a Functor? if you could, that would be great :)
14:42:28 <ddarius> Where is this?
14:42:42 <dons> ricky_clarkson: its is kosmikus. perhaps you can suggest that?
14:43:36 <skew> ndm_: fmap = pam
14:43:39 <ndm_> ddarius: my new version of uniplate
14:43:51 <ndm_> skew: does pamM have an equivalent in fmap world?
14:45:40 <ddarius> You need folding abilities to write a monadic map.  However, there should be something in like Foldable or Traversable that does it.
14:46:13 <skew> yeah, looks like Traversable.mapM
14:47:02 <ricky_clarkson> @tell kosmikus Would you be able to add a ToC and relative links to http://www.haskell.org/communities/12-2007/html/report.html ?
14:47:03 <lambdabot> Consider it noted.
14:48:02 <dons> http://programming.reddit.com/info/63p89/comments/
14:48:05 <dons> Austin Functional Programmers Group in 2008
14:50:31 <newsham> cool, installing Hugs on an xo-olpc is super easy "yum install hugs"
14:50:40 <newsham> and doesnt eat up too much space
14:50:52 <ndm_> neato :)
14:51:00 <dons> newsham: can you write that up -- that's great news .
14:51:05 <dons> goes along with xmonad on olpc :)
14:51:24 <ricky_clarkson> newsham: Wow!
14:51:26 <newsham> not sure what to "write up" or where..
14:51:31 <newsham> its just one line at cmd prompt
14:51:43 <ricky_clarkson> Do a screenshot or something.
14:51:46 <ndm_> newsham: just a blog post on how cool it is
14:51:51 <ndm_> a photo would be best :)
14:52:32 <ricky_clarkson> <meta keywords="cool,cool,so f'in cool">
14:52:53 <ricky_clarkson> That might make grahamhutton happy.
14:55:22 <newsham> i cant reach the blogosphere
14:55:39 <newsham> i'm afraid of hypes
14:55:42 <Korollary> then just deface the fsecure website and put the screenshot there
14:55:48 <newsham> heh
14:56:37 <ndm_> newsham: if you write the post, and provide the screen shot, you are welcome to put it on my blog (just send the text and photo) - and i'm sure many other people would be happy to post it too
14:59:22 <newsham> screenshot and info: http://www.thenewsh.com/%7Enewsham/xo/
14:59:23 <lambdabot> Title: Directory /~newsham/xo/
15:00:23 <newsham> anyone have good photo editing skills to unblur that photo?
15:00:51 <ricky_clarkson> Why does it mention running yum install hugs, when you have done already?
15:01:14 <newsham> I wrote that line
15:01:26 <newsham> > "to install run 'yum install hugs' as root"
15:01:29 <lambdabot>  "to install run 'yum install hugs' as root"
15:01:33 <newsham> see
15:01:37 <ricky_clarkson> Ah.  The left side is too blurred.
15:02:30 <ricky_clarkson> The keys look bad and there appears to be no Del.
15:02:45 <newsham> what do you want delete for?
15:02:48 <ndm_> newsham: ifyou move further back from the screen the photo may be less blurred
15:03:02 <ndm_> (i discovered this when doing the reduceron photography)
15:06:10 <opqdonut> i learned that in art school
15:06:23 <ddarius> opqdonut: How to photograph monitors?
15:06:27 <opqdonut> (great method for looking at impressionistic paintings)
15:06:41 <opqdonut> naw, going further
15:07:59 <skew> ndm_: I've sent you more patches for the Functor and Traversable instance
15:11:47 <ndm_> skew: hmm, not yet received
15:12:13 <ndm_> oh, sent to ndm - those take a few minutes to come through sometimes
15:12:21 <skew> you might just want the functor one
15:12:37 <ndm> i'll take both, would be nice to have mapM for both
15:12:53 <newsham> better screenshot http://www.thenewsh.com/%7Enewsham/xo/hugs-xo.jpg
15:13:36 <newsham> blah i distorted it i think
15:13:42 <ricky_clarkson> I like how the XO seems the brightest thing in the room. ;)
15:13:43 <skew> I'm not sure what to do for zipWith
15:14:02 <mrd> how's the battery life
15:14:54 <ndm> you mean zipWith in traversible?
15:15:01 <ndm> @docs Traversable
15:15:02 <lambdabot> Traversable not available
15:15:26 <newsham> ok, fixed the pic
15:15:31 <skew> it is not in traversable, but converting the supero code would need it
15:15:45 <newsham> ricky: its actually cooler when its not.  the screen rules in full sunlight
15:15:46 <ndm> converting Supero to the new version of Uniplate?
15:15:56 <ndm> where would you need it - for which constructor?
15:16:06 <skew> the embedding test
15:16:09 <ricky_clarkson> newsham: Excellent.  *want*
15:16:28 <skew> might be better to make the new uniplate export the Str methods under a different name
15:16:43 <skew> should be easy to fit a list of subterms into a Str with a monadic traversal
15:17:58 <skew> str is enough different from list that you perhaps need some kind of generic programming tools to work with it
15:18:17 <ndm> skew: i did consider defining instance Uniplate for Str
15:18:56 <ndm> skew: you can map from Str to List, but not back again since you loose the structure
15:19:31 <skew> you can map back if you save the structure, and replace children with items from the list
15:19:34 <ndm> i'm not sure you can convert Supero to use the new uniplate framework, as Yhc.Core still depends on teh old one
15:19:50 <skew> actually, I never figured out how to install yhc and just copied that directory
15:20:06 <ndm> and i don't want to upgrade Yhc.Core to Uniplate2 just yet - i want to make sure I've got the interface for Uniplate fixed
15:20:15 <ndm> skew: youdon't install, just specify it with -i
15:20:21 <skew> the build process made an inst directory containing among other things Yhc/Core full of uncompiled .hs files
15:20:27 <ndm> did it?
15:20:30 <ndm> i didn't know it did that
15:20:35 <ndm> i always just -i into the src tree
15:20:43 <ndm> and the depends/uniplate as well
15:20:58 <skew> I've been installing uniplate
15:21:03 <skew> the changes to core were quite simple
15:21:14 <skew> an fmap for a map in a few places, and the instances
15:21:18 <ndm> yes, they should all make it easier
15:21:48 <ndm> some of the old instances were a real pain!
15:23:16 <skew> I'm seeing how well I like the new interface in supero
15:23:36 <skew> seems like it really needs a uniplate instance or something
15:23:42 <ndm> for Str?
15:23:56 <skew> yes
15:24:02 <ndm> it can't be added to Uniplate
15:24:17 <ndm> otherwise you'll get clashes in Data.Generics.PlateData
15:24:28 <ndm> it would have to go in something like Data.Generics.UniplateExtra or something
15:24:57 <skew> for e.g, any (x <<|) ys with ys a Str rather than a list
15:25:17 <ndm> but i did think when working with Uniplate, when defining children :: a, i noticed its actually universe :: Str a
15:25:27 <ndm> why would you make ys a Str rather than a list?
15:25:53 <ndm> oh, you mean in <<|
15:25:54 <skew> because these terms are opened with uniplate or something, and I think put back together again
15:26:08 <ndm> i actually don't use <<| anymore - its dead code
15:26:13 <ndm> i now use the stuff in Data.Homeomorphic
15:26:45 <skew> what conflicts would you see in PlateData?
15:27:07 <ndm> instance Uniplate Str where, plus instance (Data a, Typeable a) => Uniplate a where
15:27:15 <ndm> those two conflict
15:29:41 <Drehtabak_84953> gffhfhj
15:29:44 <Drehtabak_84953> u
15:30:06 <EvilTerran> gesundheit
15:31:41 <MyCatVerbs> Hrmn. In most programming languages, there are dire warnings against using exceptions for anything even resembling normal control flow, (in part) because they're stunningly, mind-bogglingly slow. Does this stricture apply to Haskell, too?
15:31:52 <MyCatVerbs> Or are Haskell's exceptions actually reasonably fast, please?
15:32:12 <EvilTerran> i think it's more that haskell as a whole's stunningly, mind-bogglingly slow
15:32:13 <EvilTerran> :P
15:32:24 <skew> GHC does the usually stack walking thing
15:32:37 <ndm> MyCatVerbs: they don't fit the natural flow of computation, so they are to be avoided for that reason - plus it puts you in IO
15:32:45 <EvilTerran> if you mean Control.Monad.Error, say, that's pretty zippy
15:32:52 <ndm> GHC's stack /= a normal stack though
15:33:03 <skew> if you really want weird control flow, use Control.Monad.Cont.ContT
15:33:08 <MyCatVerbs> :t catch
15:33:10 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:33:47 <skew> ndm: It's split into heap-allocated segments, but otherwise I think it's reasonably normal
15:34:16 <dons> MyCatVerbs: async exceptoins are fast, but since you can only catch them in impure code, they're *not* used for normal control flow
15:34:40 <MyCatVerbs> dons: ah, damn. Thanks.
15:34:52 <ndm> skew: its a lazy stack, so it won't follow the call chain in the same way - its a normal stack but won't neecessarily look like you might expect
15:34:54 <ddarius> MyCatVerbs: Using an appropriate monad would be fine.  Cont in particular does a good job of not having "error" connotations and should be pretty skippy.
15:34:56 <dons> use them for exceptional events, not normal events
15:35:33 <ddarius> EvilTerran: I shudder to know what you think of ruby's performance then.
15:36:24 <olsner> my irc client has gone crazy and has forgotten to display any text from #haskell... but it increments the unread-messages-counter for #haskell while I'm in some other tab
15:36:26 <EvilTerran> i was kidding anyway. but, now you mention it...
15:36:27 * MyCatVerbs is reading "Purely Functional Data Structures" at the moment, and they have an example of a binary-heap set (on Ord elements) which avoids unneccessary path-copying on insertion in the event that the element to be inserted is already in the set by leaping backwards and returning the original set in the case where it is.
15:36:46 <olsner> agh, I can't see my own messages either
15:36:56 <EvilTerran> MyCatVerbs, i think the standard way of doing that in haskell would be with a kind of CPS
15:37:32 <MyCatVerbs> EvilTerran: aye, that sounds sane.
15:37:52 <EvilTerran> it'd be pretty horrible in a non-lazy language, which might be why it isn't proposed
15:38:03 <skew> where "a kind of CPS" means writing in the Cont monad, so you don't have to do the CPS transform yourself
15:38:35 <MyCatVerbs> That or passing the original tree all the way down to the bottom... and returning that instead of a new tree in the case that the element you're after is already in the tree.
15:38:45 <skew> at least if it would be at all tricky
15:38:55 * MyCatVerbs fires up AAM again.
15:39:02 <MyCatVerbs> skew: Cont is easier to use?
15:39:17 <skew> when things get tricky
15:39:54 <ddarius> Cont (like State or Reader) just handles the "boilerplate" for you.
15:40:06 <skew> if you actually want to do a full CPS transform, rather than just explicitly carrying along a continuation argument or two
15:40:41 <EvilTerran> if your "continuation" doesn't actually have a parameter, and you're not faffing around with multiple continuations, Cont's probably excessive
15:41:15 <ddarius> Multiple continuations would be more awkward to deal with using Cont.
15:42:14 <pa-ching> Hmmm... how do I map over a list, taking two items at a time?
15:42:57 <EvilTerran> > zip `ap` tail $ "abcdef"
15:42:59 <lambdabot>  [('a','b'),('b','c'),('c','d'),('d','e'),('e','f')]
15:42:59 <ddarius> As in [x,y,z,w], [f x y, f z w] or [f x y, f y z, f z w]?
15:43:35 <pa-ching> [f x y, f z w]
15:44:04 <ddarius> pa-ching: No convenient way really.  The simplest thing is just to explicitly write the obvious recursive function.
15:44:13 * EvilTerran concurs
15:44:18 <pa-ching> Alright, thanks!
15:46:05 <MyCatVerbs> :t ap
15:46:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:46:26 <MyCatVerbs> :t zip `ap` tail
15:46:27 <lambdabot> forall a. [a] -> [(a, a)]
15:46:37 <Saizan_> > filter fst . zip (cycle [True,False]) . zip `ap` tail $ "abcdef"
15:46:38 <lambdabot>      precedence parsing error
15:46:38 <lambdabot>         cannot mix `(.)' [infixr 9] and `ap' [i...
15:46:52 <Saizan_> > filter fst . zip (cycle [True,False]) . zip <*> tail $ "abcdef"
15:46:53 <lambdabot>  Couldn't match expected type `[b]'
15:48:12 <MyCatVerbs> > [fst,snd] `ap` (zip [1..] [2..])
15:48:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:48:27 <MyCatVerbs> > [fst,(2*).snd] `ap` (zip [1..] [2..])
15:48:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:48:57 <MyCatVerbs> > [fst,snd] `ap` (zip [1..5] [2..6])
15:48:58 <lambdabot>  [1,2,3,4,5,2,3,4,5,6]
15:50:40 <ski> skew : `pam' ?
15:50:54 <ndm> ski: my new uniplate, like map, but for a different data type
15:51:06 <ski> "uniplate" meaning ?
15:51:25 <MyCatVerbs> Hrmn. I presume MonadError is reasonably skippy? Er, quick?
15:51:30 * ski 's only seen `pam = flip map' ..
15:52:07 <EvilTerran> > zip [1..5] [2..6] <**> [fst,snd]
15:52:07 <lambdabot>  [1,2,2,3,3,4,4,5,5,6]
15:52:32 <ski> MyCatVerbs : you can try `MonadError e m => .. ContT o m a', iirc
15:52:39 <shachaf> ski: What good would «flip map» do? I'd think at least «map . flip id» (which is «flip sequence»).
15:52:54 <shachaf> @where uniplate
15:52:54 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
15:53:21 <MyCatVerbs> ski: you lost me there.
15:53:26 <ddarius> @wiki Performance/Monads
15:53:26 <lambdabot> http://www.haskell.org/haskellwiki/Performance/Monads
15:53:37 <ski> > let pam = flip map in [0,1,2] `pam` \x -> [0,1,2,3] `pam` \y -> (x,y)
15:53:38 <lambdabot>  [[(0,0),(0,1),(0,2),(0,3)],[(1,0),(1,1),(1,2),(1,3)],[(2,0),(2,1),(2,2),(2,3)]]
15:54:16 <ski> MyCatVerbs : throwing in the continuation monad can make things more "skippy" (iiuc what you mean by "skippy")
15:54:29 <davidL> @where house
15:54:29 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
15:54:38 <shachaf> ski: You're sure you don't want a (>>=)/concatMap there somewhere?
15:54:40 <MyCatVerbs> ski: ahhhh, heheh, I see.
15:54:40 <EvilTerran> ski, he means "fast" :P
15:55:34 <ski> MyCatVerbs : the problem with `Either e' is that each `(>>=)' checks and reconstructs the exception/normal tag, even when exceptions are just propagated
15:56:21 <ski> MyCatVerbs : throwing in continuation monad makes a thrown exception to "just arrive at the handler" with no intervening extraneous reconstructions/interpretation
15:56:29 <MyCatVerbs> ski: so transforming to CPS makes things quicker by letting you skip out immediately?
15:56:43 <ddarius> MyCatVerbs: That's part of it, but not all of it.
15:56:57 <EvilTerran> nm, ignore me :P
15:57:31 <ski> the nice thing is that `(>>=)' for `Monad (ContT o m)' doesn't use `(>>=)' for `Monad m'
15:58:13 <ski> @src ContT (>>=)
15:58:14 <lambdabot> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
15:59:19 <wy> How can I get more information from exceptions?
15:59:48 <wy> currently I just got "*** Exception: Prelude.undefined" and I can't know what's happening
16:00:23 <notsmack> wy: did you try http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14 ?
16:00:23 <MyCatVerbs> ddarius: where should I be looking to READ UP ON THE REST
16:00:24 <lambdabot> Title: Haskell hacking
16:00:31 <MyCatVerbs> Oh, shit, sorry about the capslock.
16:00:41 <MyCatVerbs> ddarius: I mean, where should I be looking to read up on the rest, please?
16:01:32 <ddarius> MyCatVerbs: Read up on the rest of what?
16:01:35 <shachaf> wy: In GHC 6.8, you can probably use ghci's debugger.
16:01:45 <Saizan_> the CPS tranform can cause strictness issues, e.g. snd $ runState (fix (>> put 1)) undefined terminates, but not when transformed
16:01:55 <wy> notsmack: sounds cool! I'm reading it
16:02:00 <wy> shachaf: Thanks
16:02:25 <shachaf> wy: Oh, sorry, I missed notsmack's message.
16:02:30 <ddarius> Saizan_: Indeed, using Cont normally corresponds to the call-by-value CPS transform.
16:02:56 <MyCatVerbs> ddarius: the rest of what the Hell everyone here except me seems to know about. ;)
16:03:16 <ddarius> There was a wiki page I referenced above that explains this particular case
16:03:22 <MyCatVerbs> Danke.
16:06:12 <wy> unrecognised flags: -fbreak-on-exception ... mine is 6.8.1
16:07:08 <ddarius> MyCatVerbs: For continuations and CPS in general (and other stuff): http://library.readscheme.org/page6.html is good, as well as http://library.readscheme.org/page1.html  The whole site is good http://readscheme.org/ and it contains a Haskell section.
16:07:34 <wy> It seems I don't have the debugger!
16:07:54 <wy> unknown command ':break'
16:08:02 <notsmack> wy: you're sure that's 6.8.1?
16:08:22 <wy> I'm sure. It comes with Ubuntu 7.10
16:08:32 <shachaf> wy: No, 7.10 is 6.6.1.
16:08:35 <wy> No...
16:08:41 <wy> That's too old
16:08:43 <shachaf> wy: `ghc --version`?
16:08:48 <wy> Yes. It's 6.6.1
16:09:06 <shachaf> wy: You want >=6.8. :-)
16:09:17 <wy> Is there a package for Ubuntu?
16:10:49 <MyCatVerbs> ddarius: thank you. ^_^
16:10:57 <shachaf> wy: Possibly, I'm not sure. It might be easier to use the haskell.org/ghc binary.
16:11:07 <wy> I'm afraid all my ghc library packages will break if I install the new one
16:11:47 <shachaf> wy: It'll all go in /usr/local.
16:12:05 <shachaf> wy: (Or anywhere else.)
16:12:20 <shachaf> wy: But you can have multiple version of GHC installed at once.
16:12:22 <wy> ubuntu really should update it
16:12:31 <wy> I hope so
16:12:31 <davidL> A Bool takes up one bit of memory right?
16:12:55 <EvilTerran> hahaha. no.
16:12:59 <shachaf> wy: It might be in Hardy.
16:13:19 <EvilTerran> a Bool takes up, er, 6 bytes, is it? 12? i forget
16:13:35 <davidL> Why?
16:14:15 <EvilTerran> every normal haskell value has a certain amount of overhead
16:14:25 <wy> I remember it's 6.6.1 in 7.04
16:14:25 <ddarius> EvilTerran: It takes up 4 and that's pre-pointer tagging.  Now it should take up a bit.
16:14:33 <EvilTerran> wrt how evaluated it is, what type it is (?), etc
16:15:02 <shachaf> wy: No, 7.04 had 6.4.something, I think.
16:15:03 <EvilTerran> ddarius, the new ghc packs bools? impressive
16:15:19 <davidL> Does a Word8 have any overhead, for example?
16:15:34 <EvilTerran> presumably it only does so to ones it can successfully strictness-analyse to the point of unboxing
16:15:39 <EvilTerran> (unless i'm confused)
16:15:48 <ddarius> EvilTerran: True, a thunk will take up more space.
16:16:23 <EvilTerran> davidL, the report doesn't discuss memory usage or anything of that nature, by the way. we're only discussing the behaviour of GHC here.
16:16:46 <wy> So you compiled it?
16:16:56 <wy> and make install?
16:17:28 <EvilTerran> davidL, unless you're planning on doing something really quite data intensive (signal processing, say), the overhead that may or may not exist causes surprisingly little trouble
16:17:44 <EvilTerran> in the cases where you *are* doing something data-intensive, UArray is your friend :)
16:17:48 <ddarius> shachaf: How much space a Word8 takes depends.  A UArray of Word8 should only be using a byte for each, a random reference to one will probably use a pointer and if it is lazy it will be a pointer to a thunk.
16:18:00 <shachaf> ddarius: Was that for davidL?
16:18:08 <ddarius> shachaf: Uh, yeah.
16:18:32 <shachaf> davidL: A Bool in an unboxed array really does take up one bit, I think (right?).
16:18:33 <davidL> EvilTerran: I'm writing a TCP implementation, I guess that's data intensive
16:18:38 <ddarius> shachaf: Yes.
16:19:07 <ddarius> davidL: Write it as you like, worry about it later.
16:19:12 <EvilTerran> shachaf, modulo a certain amount of overhead, but yeah. that's the explicit point of UArrays, so it damn well better work like that ;)
16:19:50 <EvilTerran> UArray: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Unboxed.html
16:19:51 <lambdabot> http://tinyurl.com/2q5bxh
16:19:55 <davidL> I guess I'll worry about optimization later, thanks all
16:19:59 <sjanssen> davidL: how are you storing the Word8?  Passing lists of them? tuples? arrays?
16:20:16 <sjanssen> custom data types?
16:20:27 <davidL> creating new data types
16:21:16 <sjanssen> okay, the easiest thing you can do to reclaim space is using strict fields (!) and -funbox-strict-fields
16:21:58 <sjanssen> this will reduce the overhead of each Word8 to 4 bytes
16:22:26 <davidL> What would the overhead be of !Bool?
16:23:14 <ddarius> davidL: In almost all cases, everything is word-aligned (at least)
16:23:58 <davidL> alright
16:24:04 <sjanssen> hmm, I can't reember if Bool is a special case
16:24:22 <sjanssen> typically GHC can't unpack sum types
16:25:42 * ddarius sometimes wants ways to specify an explicit layout, alignment, memory location.
16:27:05 <LoganCapaldo> does C even (portably?) let you do that?
16:27:11 <ddarius> LoganCapaldo: No.
16:27:24 <LoganCapaldo> didn't think so . just checking
16:28:13 <wy> Yeah. problem solved before I compilation of 6.8.2 finish
16:28:44 <shachaf> wy: You should keep compiling it anyway. :-)
16:28:53 <shachaf> wy: (Or just use a binary.)
16:29:03 <wy> shachaf: I guess it would take an hour
16:29:23 <SyntaxNinja> dons: are reddit comments always so shrill?
16:30:17 <wy> What distro of linux do most of you use?
16:31:02 <shachaf> wy: Well, Arch seems to be popular in #xmonad. :-)
16:31:03 <psi> if i would have to guess, i'd say debian or ubuntu
16:31:28 <wy> shachaf: It seems to be new
16:31:47 <wy> It's using some primitive package system?
16:32:07 <psi> no
16:33:01 <psi> it does dependencies and upgrades and all that
16:33:23 * shachaf is planning to try NixOS sometime.
16:33:48 <davidL> is that the functional os?
16:33:49 <SyntaxNinja> ubuntu
16:34:19 <vincenz> screw ubuntu
16:34:30 <davidL> oh, functional package management
16:34:33 <pa-ching> Does there happen to be a convenient built-in way to convert a list of length n to an n-tuple?
16:34:40 <pa-ching> maybe for some small values of n? ;)
16:34:54 <shachaf> pa-ching: Do you know the size of the list in advance?
16:34:58 <pa-ching> Yeah.
16:35:14 <dons> SyntaxNinja: sometimes. when it disrupts people's comfort levels a little, especially
16:35:49 <shachaf> pa-ching: The answer is probably not, I think. :-)
16:35:54 <shachaf> pa-ching: How do you make the list?
16:36:03 <vincenz> dons: which comment?
16:36:05 <pa-ching> shachaf: lines
16:36:12 <mdmkolbe|work> @djinn (a -> m Bool) -> [a] -> m ([a], [a])
16:36:13 <lambdabot> -- f cannot be realized.
16:36:14 <pa-ching> Eh, just wondering.
16:36:27 <pa-ching> Easy enough to do it manually or write that as a helper
16:36:48 <vincenz> mdmkolbe|work: a monadic partition?
16:36:50 <pa-ching> I tend to come across the list unpack a lot though and was wondering if I'm reinventing
16:36:54 <shachaf> mdmkolbe|work: Djinn doesn't know about lists (or about m).
16:37:28 <ddarius> shachaf: There's nothing to know about m in that case.
16:37:35 <mdmkolbe|work> vincenz: yep
16:37:36 <wy> shachaf: Looks good. Do you know what language is the scripts in?
16:37:57 <vincenz> > partitionM f [] = return ([],[]); partitionM f (a:as) = do { (ys,ns) <- partitionM f as; b <- f a; if b then return (a:ys,ns) else return (ys,a:ns) }
16:37:57 <lambdabot>  Parse error at "=" (column 17)
16:38:01 <vincenz> mdmkolbe|work: try that
16:38:05 <SyntaxNinja> vincenz: some PHP folks feeling a little defensive when I suggest designing language features to improve security :)
16:38:12 <vincenz> SyntaxNinja: :D
16:38:35 <shachaf> ddarius: Which is why it doesn't know about it. :-)
16:38:41 <vincenz> mdmkolbe|work: there's other possibilities
16:38:43 <mdmkolbe|work> vincenz: yeah, I'll write my own if there isn't already a built in or one liner.
16:38:47 <shachaf> wy: Which scripts?
16:38:49 <SyntaxNinja> <--- even went so far as to explicitly NOT blame PHP and say that Haskell is susceptible to many of the same attacks (as are all languages)
16:38:52 <vincenz> mdmkolbe|work: like mapM'ing, doing a bind only wonce and then using a simple partition
16:38:56 <vincenz> @type partition
16:38:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:39:14 <mdmkolbe|work> @type mapM
16:39:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:39:16 <wy> shachaf: The web page of NixOS says that it's package management and scripts are all in functional lang?
16:39:26 <dons> yes, you see similar reponses from other groups (e.g. C++ guys) when confronted with the idea that their work might be possibly obsolete. It's scary, and leads to weird reactions like this.
16:39:26 <shachaf> wy: It's their own language.
16:39:31 <shachaf> wy: (Their channel is #trace.)
16:39:50 <vincenz> partitionM f = liftM (partition snd) . mapM (\x -> liftM ((,) x) $ f)
16:39:54 <vincenz> @type let partitionM f = liftM (partition snd) . mapM (\x -> liftM ((,) x) $ f)  in partitionM
16:39:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> [a] -> m ([(a, Bool)], [(a, Bool)])
16:40:08 <wy> shachaf: strange. another FP?
16:40:14 <SyntaxNinja> dons: yeah.
16:40:21 <ricky_clarkson> SyntaxNinja: I think the keyword "Haskell" can provoke people.
16:40:21 <shachaf> wy: Sort of.
16:40:25 <vincenz> @type let partitionM f = liftM (map fst *** map fst) . liftM (partition snd) . mapM (\x -> liftM ((,) x) $ f)  in partitionM
16:40:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> [a] -> m ([a], [a])
16:40:30 <dons> ?users
16:40:30 <lambdabot> Maximum users seen in #haskell: 434, currently: 366 (84.3%), active: 20 (5.5%)
16:40:32 <vincenz> there you go, mdmkolbe|work
16:40:32 <mdmkolbe|work> vincenz: that looks like a variation of the schwartzian transform
16:40:34 <ricky_clarkson> You should write it Ha****l
16:40:35 <SyntaxNinja> dons: I would be perfectly happy if there were 1000 insecure php programs and 100 secure Haskell programs :)
16:40:43 <dons> that'd be great!
16:40:44 <SyntaxNinja> ricky_clarkson: hah!
16:40:47 * shachaf doesn't know a lot about it -- you'd be better off sking in their channel.
16:40:56 <SyntaxNinja> dons: just different langugaes for different needs
16:41:17 <SyntaxNinja> but I have to agree that Haskell hasn't proven itself yet.  we're working on it.
16:41:30 <dons> we got similar reactions to some of the safety proofs and type system stuff done for xmonad. "well, sure, but you can't do that in the real world." etc etc.
16:41:57 <ricky_clarkson> The real world is somewhere between the water cooler and the printer.
16:42:01 <ricky_clarkson> I think it's the Gents.
16:42:09 <dons> you can never counter these assertions, as they're entirely unverifiable.
16:42:25 <SyntaxNinja> yeah.
16:42:30 <vincenz> mdmkolbe|work: afraid I haven't heard of that transform
16:42:38 <SyntaxNinja> after writing a few slashdot reviews, I got kinda used to the comments that follow :)
16:42:46 <dons> heh
16:43:01 <wy> shachaf: Found some code http://nix.cs.uu.nl/dist/nix/nix-0.10.1/manual/#chap-writing-nix-expressions
16:43:02 <lambdabot> Title: Nix User's Guide, http://tinyurl.com/yq7wk7
16:43:04 <SyntaxNinja> but it's still disappointing.
16:43:05 <vincenz> whoops, forgot to add the x
16:43:15 <vincenz> @type first
16:43:16 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:43:47 <dons> SyntaxNinja: malcontent is a bit of a reactionary though. i'd not worry :)
16:44:16 <shachaf> wy: If you get it working, tell me how it goes. :-)
16:44:27 <SyntaxNinja> dons: nah, doesn't bother me at all.  It's fun to get so many hits.
16:44:30 <vincenz> Anyone know how to burn a cd from the console
16:44:34 <wy> shachaf: I dare not try at this time
16:44:58 <dons> SyntaxNinja: yeah :) now, just to get glguy to start blogging ..
16:45:03 <wy> shachaf: I've broken too many times my package system
16:45:09 <shachaf> wy: OK -- I'll try it, then. :-)
16:45:09 <SyntaxNinja> the amazing thing is when you see the comments, like on slashdot, you're left with the overwhelming impression that everyone's stupid. but then you look more carefully, and there's almost always a really intelligent and experienced person who says something about an article.
16:45:11 <wy> So I got paranoid about it
16:45:16 * shachaf has a free 10GB partition.
16:45:21 <SyntaxNinja> dons: word.  that glguy hates writing, though.
16:45:35 <dons> ah, hmm. so need to make it fun somehow
16:45:35 <SyntaxNinja> maybe we can warm him up to writing papers via writing blogs
16:45:45 <dons> mmm
16:46:12 <ricky_clarkson> Why would you encourage someone to write papers?
16:46:21 <dons> he likes games of strategy and thinking. blogging's much the same :)
16:46:42 <MyCatVerbs> SyntaxNinja: unfortunately you have to already have some inkling of what's going on in order to work out /who/ that one sane person in the whole comment section /is/.
16:46:42 <dons> ricky_clarkson: why not? writing down ideas is a good way of forcing their evaluation :)
16:46:45 <SyntaxNinja> ricky_clarkson: well, sometimes a paper is a really good way to articulate a set of complex concepts, get review of them, and get them ou tinto the world.
16:46:55 <SyntaxNinja> MyCatVerbs: too true.
16:47:24 <wy> shachaf: try SQL. It's pure function I guess
16:47:34 <MyCatVerbs> SyntaxNinja: as shown by the fact that none of the clueless hordes actually recognise sense when they see it.
16:47:44 <shachaf> wy: ?
16:47:51 <shachaf> wy: As an OS?
16:48:04 <wy> shachaf: As a package management system
16:48:15 <vincenz> very OT, but anyone know how to burn a iso file from the console
16:48:17 <SyntaxNinja> dons: yeah, we need to get him into the strategy of technology.  it'll get him hooked
16:48:25 <shachaf> vincenz: cdrecord?
16:48:29 <vincenz> shachaf: how tho
16:48:36 <puusorsa> man cdrecord
16:48:43 * vincenz tried going through that
16:48:46 <kuribas> vincenz: or growisofs
16:49:08 <shachaf> vincenz: You should probably ask in #-blah, anyway.
16:49:25 <MyCatVerbs> growisofs, assuming you're on linux or a BSD.
16:49:36 <dons> SyntaxNinja: i wish iavor would blog too -- he's got such great counterpoint intuitions
16:50:06 <MyCatVerbs> cdrecord is buggier than a termite mound, especially in distrubutions where the maintainers were crazy enough to replace it with wodim.
16:50:38 <davidL> vincenz: wodim dev=/dev/cdrw foo.iso (?)
16:51:14 <MyCatVerbs> Noooo, wodim is a command line program for manufacturing drinks coasters.
16:51:48 <ricky_clarkson> SyntaxNinja: Papers tend to be less readable than well-written blog posts.
16:51:55 <MyCatVerbs> growisofs -Z /dev/cdrw=foo.iso
16:52:13 <ddarius> ricky_clarkson: Patently false.
16:53:16 <dons> ricky_clarkson: more interesting, but aimed at a different audience.
16:53:39 <Philippa> ddarius: they're often less immediately accessible. Different audience though
16:53:55 <Philippa> I wouldn't write a paper in quite the same tone I wrote for TMR in, either
16:53:56 <dons> blogs are like prime time news segments, short, to the point, often misleading. papers are like feature films :)
16:54:06 <ricky_clarkson> It's hard to tell whether there's anything worth reading in a paper.
16:54:18 <Philippa> well, possibly if I was directly told enough people wanted me to do so
16:54:25 <MyCatVerbs> TMR?
16:54:29 <ricky_clarkson> ..you might be reading something great or something useless, it takes a few pages to tell sometimes because of all the preamble.
16:54:35 <Philippa> MyCatVerbs: The Monad.Reader
16:54:58 <MyCatVerbs> dons: feature films... long and composed entirely of one gigantic, seamlessly-constructed lie? ;)
16:55:05 <MyCatVerbs> Philippa: ah, yesh. Danke.
16:55:17 <dons> heh
16:55:26 <dons> wait till the twist at the end!
16:55:51 <Philippa> "actually all these other guys had almost the same idea first and we just told you this variant doesn't work too well"?
16:56:21 <dons> something like that :)
16:56:23 <ddarius> ricky_clarkson: It's easy to tell for blog posts; they're just uniformly not very useful (or downright useless)
16:56:59 <ddarius> ricky_clarkson: How do you decide to get some music you haven't heard before?
16:57:16 <ricky_clarkson> I listen to some of it.
16:57:29 <mdmkolbe|work> @pl \f m1 m2 -> catchError m1 (\e -> if (f e) then m2 else throwError e)
16:57:29 <lambdabot> flip ((.) . catchError) . flip flip throwError . (ap .) . flip . (if' .)
16:57:45 <mdmkolbe|work> =-|
16:58:20 <sclv> ?ty throwError
16:58:22 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
16:58:34 <sclv> ?ty flip flip throwError
16:58:35 <mdmkolbe|work> @pl \f m1 m2 -> catchError m1 (\e -> if (f e) then m2 e else throwError e)
16:58:35 <lambdabot> forall a c e (m :: * -> *) a1. (MonadError e m) => (a -> (e -> m a1) -> c) -> a -> c
16:58:35 <lambdabot> flip ((.) . catchError) . flip flip throwError . (ap .) . liftM2 if'
17:00:01 <sclv> @pl \e -> if (f e) then m2 e else throwError e
17:00:02 <lambdabot> ap (liftM2 if' f m2) throwError
17:00:58 <sclv> === (lf' <$> f <*> m2) <*> throwError
17:02:17 <sclv> @pl \m1 m2 -> catchError m1 ((lf' <$> f <*> m2) <*> throwError)
17:02:17 <lambdabot> (. ((<*> throwError) . ((lf' <$> f) <*>))) . catchError
17:02:41 <SyntaxNinja> dons: Iavor has great counterpoint intuitions!  That's an awesome way to put it ;)
17:02:59 <EvilTerran> is that a polite way of saying "argumentative"? ;)
17:03:18 <SyntaxNinja> ricky_clarkson: depends on the paper, I think.  I want to "publish" a whitepaper soon, and I am thinking of just pasting it into a blog. I don't think there has to be a big difference
17:03:40 <sclv> @unpl (. foo) . bar
17:03:40 <lambdabot> (\ d g -> bar d (foo g))
17:03:45 <ricky_clarkson> SyntaxNinja: Fair enough.
17:04:19 <ricky_clarkson> I find with many papers, the 3rd page is where the Greek symbols start.  Is there some space restriction that makes it impossible to explain those in the same paper they're used?
17:04:43 <SyntaxNinja> ricky_clarkson: well, who is going to feel superior if it turns out that all the theory can be explained in a paragraph!
17:05:01 <SyntaxNinja> ricky_clarkson: actually, read Types and Programming Languages.  I found that the greek _is_ actually way easier than it looks.
17:05:16 <ricky_clarkson> I'd like to, but it said "insert coin here".
17:05:18 <mdmkolbe|work> ricky_clarkson: you mean like the 10pg limit most converences impose?
17:05:42 <wy> Yeah! successfully combined position and states together
17:05:45 <ddarius> ricky_clarkson: There is almost always some kind of page limit.
17:06:19 <ricky_clarkson> Well, that's not true for blog posts, as evidenced by Steve Yegge.
17:06:30 <wy> crazily obfusticated code
17:06:54 <ricky_clarkson> Is the limit to make it more readable or more printable?
17:06:55 <ddarius> That said, the Greek symbols are just names with only somewhat conventional meaning, i.e. it is quite common to use Γ as a variable name representing the context (environment).
17:07:17 <Philippa> but then when you see a system in the abstract you don't necessarily know WTF it's doing
17:07:17 <ddarius> ricky_clarkson: It costs money to print more.
17:07:26 <ddarius> ricky_clarkson: It also costs money to review more.
17:09:32 <mdmkolbe|work> ricky_clarkson: also, for people already "in the know", the greek makes the paper easier to read as it forms a sort of short hand (e.g. after a while many papers only take 5-10min to read).  Of course the mark of a good author is that they can reach both the expert and the novice (not too many of those though).
17:09:37 <sclv> what's a phi, usually?
17:09:54 <wy> ddarius: Can you give me a lower cased one?
17:09:59 <ricky_clarkson> mdmkolbe|work: Sure.
17:10:00 <ddarius> γ
17:10:33 <ddarius> mdmkolbe|work: Wadler is one, in most of his papers.
17:11:02 * mdmkolbe|work agrees (Cf. his paper on the dual calculus)
17:11:05 <wy> ddarius: It works
17:11:25 <ddarius> sclv: Depends on the context.
17:11:50 <mdmkolbe|work> sciv: depends on context.  could mean an evaluation function, or a catamorphism function.
17:12:02 <EvilTerran> ricky_clarkson, if you look at, say, abebooks.com, you should be able to get a copy of TaPL for ~$40 (inc postage), and I'd say it's worth it
17:12:11 <wy> ddarius: I like the upper case better, but they can't be used in haskell since upper cases are types
17:12:15 <monochrom> Usually phi stands for a number->number function in math papers or a syntactic term in logic and language papers.
17:12:23 <sclv> hmm... probably I'm seeing it as an evaluation function then. I come across it in compiler papers and my eyes glaze
17:12:40 <EvilTerran> i know *i* wouldn't trust some random recommending a book across the internet without reading it first, but, meh.
17:12:42 <EvilTerran> ;)
17:13:07 <monochrom> Examples. "Let phi be an eigenfunction" in a PDE exposition. (An eigenfunction is usually a nice solution to a PDE.)
17:13:17 <ddarius> In papers that use (some) category theory, oftentimes lowercase Greek letters are used for natural transformations.  Many times such conventions will be stated.
17:13:31 <mdmkolbe|work> TaPL is the first book that I ever felt like I *had* to own after reading it
17:13:34 <monochrom> "Let phi be a FOL formula" in a logic exposition.
17:13:40 <ddarius> monochrom: An eigenfunction is a "fixed" function (up to scaling)
17:13:56 <EvilTerran> be grateful we're not doing physics. the whole subject's littered with arbitrary choices of variable name
17:14:33 <mdmkolbe|work> Hmm, in all those example uses of phi, it is always a function.  Coincidence?
17:14:33 <EvilTerran> "hm... current... well, C's taken, let's use... I!"
17:14:34 <ricky_clarkson> EvilTerran: Thanks.  Perhaps I can find parts of it on Google Books or something.  Not to get around paying, just to have a glance.
17:14:35 <wy> mdmkolbe|work: I don't like to own any books since they are so heavy
17:14:42 <ddarius> EvilTerran: Nothing beats the lambda calculus.
17:14:58 <wy> ddarius: pi-calculus?
17:15:02 <monochrom> No, an FOL formula is not a function.
17:15:07 <sclv> @unpl (. foo) . bar
17:15:08 <lambdabot> (\ d g -> bar d (foo g))
17:15:17 <sclv> er, rather: http://books.google.com/books?id=ti6zoAC9Ph8C&dq=book+types+and+progamming+languages&pg=PP1&ots=EyNhvIk-YG&sig=qj77vL_A9gvwC_T5lTR69OS1XaA&hl=en&prev=http://www.google.com/search?q=book+types+and+progamming+languages&sourceid=navclient-ff&ie=UTF-8&rlz=1B3GGGL_en___US226&sa=X&oi=print&ct=title&cad=one-book-with-thumbnail#PPR7,M1
17:15:19 <lambdabot> Title: Types and Programming Languages - Google Book Search, http://tinyurl.com/36n6up
17:15:36 <monochrom> an FOL formula is a syntactic term. The next thing you usually do is structural recursion over the syntax.
17:15:42 <ddarius> wy: pi calculus makes sense it a) is related to "process" and b) is following the footsteps of the lambda calculus.  The reason the lambda calculus is named the way it is has nothing to do with anything.
17:15:53 <wy> Is Ben Pierce doing FP?
17:16:27 <scook0> what's the origin of lambda? (I think I read it once somewhere, but I've forgotten)
17:16:47 <wy> scook0: Church?
17:16:50 <ddarius> wy: That question makes little sense.  Even saying Simon Peyton Jones "is doing FP" is meaningless.
17:17:15 <scook0> no, I mean the use of the lambda symbol to mean anonymous function abstraction
17:17:25 <wy> scook0: I've read a few pages of that yellow lambda calculus book from North Holland, but that didn't make sense to me at that time
17:17:29 <EvilTerran> that's one arbitrary symbol, tho, not the dozens that haunted me thru all of high-school physics
17:17:32 <scook0> i.e. why that symbol was chosen over others
17:17:42 <ddarius> scook0: Church used a hat over variables to represent them being abstracted, a typographer who couldn't lay it out used ^x, and then a typographer who read that thought that that was an abbreviation of λx
17:17:43 <wy> ddarius: Why?
17:18:01 <scook0> ddarius: ah, that sounds familiar
17:18:18 <EvilTerran> ah, the coincidences of life :D
17:18:28 <Botje> I'd like lambda calculus even more if it was called "hat calculus" :)
17:18:38 <wy> ddarius: Interesting. so the typesetting invented the name
17:18:46 <ddarius> wy: That's the story
17:18:49 <scook0> it seems strangely appropriate, given the origin of x
17:18:59 <scook0> (which I believe was also a typesetting issue)
17:19:10 <ricky_clarkson> Botje: The Y combinator is an elaborate hat stand that does not touch the ground.
17:19:20 <Botje> :)
17:19:23 <mdmkolbe|work> I don't know that has the smell of an urban legend
17:20:07 <EvilTerran> monads as anachronistic furniture!
17:20:30 <ricky_clarkson> "Lambdas are hats, monads are not elephants after all"
17:20:47 * EvilTerran pulls an elephant out of his hat
17:20:55 <wy> Is is a rule that things to be passed into scopes is on the left side of "->" and things passed out is on the right?
17:21:00 <ricky_clarkson> Damn you people and your abstractions.
17:21:49 <ricky_clarkson> It's quite clear that monads are inferior forms of the Tardis from Dr. Who.
17:22:46 <wy> ricky_clarkson: why?
17:23:04 <ricky_clarkson> If you have to ask, you shouldn't be asking.
17:23:24 <ricky_clarkson> (sorry, that was faxathisia's response when I asked a question yesterday)
17:24:40 <ddarius> Should I comment on this "Continuation passing style [in C#]" blog post?
17:25:09 <wy> where?
17:26:52 <ddarius> http://blogs.msdn.com/wesdyer/archive/2007/12/22/continuation-passing-style.aspx
17:26:53 <lambdabot> Title: Yet Another Language Geek : Continuation-Passing Style, http://tinyurl.com/ypfmka
17:32:08 <wy> ddarius: Haven't learn any C# yet. I'll contentrate on Haskell currently, and map the things back when needed.
17:32:26 <ddarius> wy: Why do you care to learn C#?
17:32:53 <wy> ddarius: If you boss requires you to use it...
17:33:10 <ddarius> wy: Does your boss require you to use it?
17:33:13 <wy> It seems not as bad as Java ;-)
17:33:33 <dons> SyntaxNinja: "Hackage and cabal are very promising already and may be what finally makes ghc
17:33:36 <dons> real-world useful for more people, because most people are not interested in
17:33:39 <dons> working with raw source packages and fiddling with compiler flags and weird
17:33:41 <dons> error messages"
17:34:14 <ddarius> wy: It's definitely better than Java, but that didn't answer my question at all.
17:34:35 <wy> ddarius: I have no boss yet ;-)
17:34:52 <SyntaxNinja> dons: what's that from?
17:34:59 <wy> ddarius: I just hope my boss is somebody who doesn't program at all ;-)
17:35:20 <SyntaxNinja> wy: dons is lucky like that ;)
17:35:31 <dons> the long series of emails tonight, "SBM: Simple Bytestring Microbenchmarks"
17:35:37 <dons> posted by 'firefly' on -cafe@
17:36:15 <wy> dons: What's your boss doing?
17:36:23 <dons> talking on #haskell, it seems :)
17:36:33 <wy> I finished the code. Hope to get some suggestions. http://hpaste.org/4634
17:36:46 <wy> dons: Your boss is here?
17:37:02 <dons> yep! right now! oh noes!
17:37:07 <dons> quick. everyone look busy.
17:37:09 <ikegami--> :D
17:37:33 <wy> lol
17:38:09 <wy> dons: It seems you are a student
17:38:10 <ikegami--> To boss: we realize that dons is really great
17:38:24 * EvilTerran tries, and fails, to come up with a joke involving "look busy" and "busy wait"
17:38:37 <dons> wy, nope.
17:39:03 <wy> dons: How is Yi going? I saw you handed it over to other people
17:39:22 <dons> yeah, jyp has been working on that for the last couple of years
17:39:28 * Japsu also tries and only manages to scrape up something lolcat-esque like "busy wait is busy. lazy wait is lazy"
17:40:14 <wy> dons: Is it good for everyday use?
17:40:37 <wy> finshed compiling ghc 6.8.2...
17:40:52 <dons> wy, i don't use yi. its very much researchy atm
17:40:53 <wy> Not sure if everything will go to /usr/local yet
17:41:38 <wy> dons: Does it understand the layout, types etc?
17:42:16 <skew> wy: Nix *is* a functional language for describing package dependencies
17:42:18 <dons> not sure. it did do type error highlighing last i played with it
17:43:05 <SyntaxNinja> dons: posted by firefly 'eh?  suspicious. that's the name of my computer...
17:43:09 <SyntaxNinja> but it wasn't me!
17:43:14 <dons> heh.
17:43:14 <SyntaxNinja> maybe I'm not too creative
17:43:48 <wy> What's cafe@ ?
17:45:04 <SyntaxNinja> wy: the Haskell Cafe: http://www.haskell.org/mailman/listinfo/haskell-cafe
17:45:05 <lambdabot> Title: Haskell-Cafe Info Page
17:45:29 <scook0> wy: the Haskell community's chief mailing list
17:45:53 <wy> scook0: Is it very different from irc ?
17:46:15 <SyntaxNinja> irc is to the mailing list as blog postings are to a paper ;)
17:46:25 <ddarius> SyntaxNinja: Not really.
17:46:32 <wy> ... what's more than a paper?
17:46:36 <ikegami--> Cafe is comfortable.
17:46:53 <skew> ddarius: Oleg cites cafe posts
17:47:01 <pmatos> Hello all, I'm trying to use Parsec for the first time to do a simple parsing exercise. I want to parse a list of integers (not 0) separated by '0'. Which means from 1 -2 0 3 -1 0 I would get [[1, -2], [3, -1]]. Is there any simple way do use parsec for this?
17:47:03 <ddarius> ikegami--: The entire Haskell community is comfortable.
17:47:25 <SyntaxNinja> ddarius: I think they compare similarly on several dimensions.  IRC is less formal, more off-the-cuff, people put more care into mailing list postings than what they say on IRC.
17:47:27 <ddarius> pmatos: Yes, but then it would be even easier to just throw words at it.
17:47:27 <ikegami--> ddarius: you are right
17:47:43 <pmatos> ddarius: what do you mean, throw words at it?
17:47:48 <ddarius> :t words
17:47:50 <lambdabot> String -> [String]
17:48:18 <pmatos> so, you mean, words and then split the list on the 0's?
17:48:24 <ddarius> pmatos: More or less
17:48:42 <ddarius> SyntaxNinja: IRC leads to a totally different feeling of "community" than either of the other three.
17:48:54 <wy> scook0: Is it better to receive digests?
17:48:57 <mdmkolbe|work> ddarius: if this is a school excersize then words probably isn't solution the teacher expects
17:49:10 <pmatos> ddarius: interesting. thx.
17:49:40 <ddarius> mdmkolbe|work: That's not my problem.
17:49:45 <scook0> wy: I don't
17:49:48 <EvilTerran> IRC is the process of throwing words at problems ;)
17:50:02 <scook0> since I skim the message headers in my inbox anyway
17:50:24 <ikegami--> here is not a cafe but a bar
17:50:28 <wy> scook0: don't you use gmail?
17:50:34 <scook0> yeah
17:50:55 <SyntaxNinja> ddarius: they each contribute different things to the community, IMO
17:51:01 <EvilTerran> ikegami--, if so, they must go through a lot of napkins with all the doodling we get up to
17:51:47 <ikegami--> sometimes, we need good manners
17:51:52 * EvilTerran plans to, if/when he ever gets his own house, have a room where the walls are covered in whiteboard for such purposes :D
17:51:53 <scook0> EvilTerran: fortunately hpaste has an infinite supply of napkins
17:51:58 <ddarius> SyntaxNinja: I certainly agree.  My point was just that IRC doesn't fit that analogy in a rather significant way (though it does fit in many other ways)
17:52:18 <ddarius> Silly EvilTerran, just make the walls whiteboards.
17:52:35 <EvilTerran> where's the fun in that?
17:52:38 <wy> I want to set up a blog to write down my learning process :-)
17:53:32 <ndm> @seen kosmikus
17:53:33 <lambdabot> kosmikus is in #haskell, #darcs, #xmonad, #ghc and #gentoo-haskell. I last heard kosmikus speak 4h 3m 12s ago.
17:53:47 <EvilTerran> the idea of being able to just draw all over the walls appeals to me more than mounting conventional whiteboards, for whatever reason
17:54:08 <ndm> i'm looking to define something like: \foo{a}{b} in Lhs2tex which causes a and b to be tex processed
17:54:29 <ndm> i don't think its possbile - but if it was that would be cool
17:54:40 <MyCatVerbs> ikegami--: that explains the urge to down tequila whene'er I hit IRC.
17:54:50 <MyCatVerbs> Or maybe I just feel like that anyway.
17:55:09 <wy> I'm wondering what does SPJ do for microsoft.
17:55:35 <ndm> wy: he gets paid by them, but i think he does what he wants - i.e. hacks GHC and does research
17:56:03 <wy> ndm: and does research means ...?
17:56:49 <wy> That's so good. Why do you think microsoft pay him?
17:57:01 <ndm> wy: http://research.microsoft.com/~simonpj/#current
17:57:08 <ndm> wy: beacuse he's so good :-)
17:57:29 <wy> hehe. Microsoft has too much money
17:57:32 <ikegami--> MyCatVerbs: I'm a non-drinker who loves Haskell :)
17:57:38 <ndm> wy: they have a research lab, its good publicity to have clever people working for them, and they can have some influence on where stuff goes, and some of the things produced may be of use to them
17:57:53 <ndm> i.e. F# became an offiical .NET product
17:58:02 <skew> and C# gets stuff like lambdas
17:58:14 * EvilTerran loves drink *and* haskell
17:58:25 <MyCatVerbs> ikegami--: so, what, you're logging in and sipping lemonade?
17:58:29 <puusorsa> cocaine - the dear thing
17:58:40 <EvilTerran> the type system makes drunk programming a lot easier
17:58:49 <ndm> EvilTerran: plus version control
17:59:10 <MyCatVerbs> EvilTerran: heheh, really? Most of the time I use the type system mainly as a way of figuring out what the Hell any random function is meant to do.
17:59:10 <EvilTerran> yyyyeah. i should get me some of that.
17:59:11 <skew> EvilTerran: You think Haskell works once it typechecks? you should try Coq
17:59:30 <EvilTerran> skew, i've thought about it. it's installed... not that i've done anything with it =/
17:59:35 <MyCatVerbs> ndm: oh GODS yes, darcs saves me from myself pretty much constantly. :)
17:59:43 <MyCatVerbs> skew: I couldn't use Coq myself.
17:59:45 <ikegami--> where is a lazy and strongly typed drink?
18:00:01 <skew> MyCatVerbs: exactly - knowing the type mostly tells you what a function does
18:00:02 <puusorsa> laphroaig <3
18:00:03 <MyCatVerbs> skew: it sounds too much like something to be taken out and waved at policemen.
18:00:20 <puusorsa> http://www.laphroaig.com/
18:00:21 <lambdabot> Title: Laphroaig - the maker of the World's favourite Islay single malt scotch whisky.
18:00:36 <skew> MyCatVerbs: so you have to get the type right, and then you can be pretty sure that if your function body typechecks it does something reasonable
18:00:44 <mattam> Man you will _have_ to try it when you see typeclasses in Coq in the next release :)
18:00:54 <skew> typeclasses?
18:01:03 <MyCatVerbs> skew: indeed, this is why I go weak at the knees when I see scary types ((->) a, for example, broke my brain) - because I can't get to grips with how you apply that, I can't get to grips with what it might do. :)
18:01:11 <skew> typeclasses that come with axioms?
18:01:14 <mattam> Yep, I'm currently adding them to Coq
18:01:17 <wy> Has any of you read "On Lisp" before ?
18:01:23 <MyCatVerbs> wy: yesh.
18:01:30 <mattam> Nope, ad-hoc overloading
18:01:45 <shachaf> MyCatVerbs: (r ->) should be no scarier than Reader.
18:01:46 <wy> MyCatVerbs: I learned CPS there, but I didn't like it at that time
18:01:49 <MyCatVerbs> skew: well, either it should do _something_ sensible... or just return _|_.
18:01:50 <skew> mattam: but a required member of the class could be an axiom, right?
18:01:56 <mattam> Only better, as you can do instance search with values
18:02:00 <MyCatVerbs> shachaf: yes, and Reader broke my neurons. :)
18:02:04 <mattam> skew: If you like
18:02:11 <MyCatVerbs> wy: what, from "On Lisp"?
18:02:21 <wy> MyCatVerbs: yes
18:02:21 <MyCatVerbs> wy: wait, perhaps I'm thinking of the wrong thing. Short article?
18:02:33 <eric-lavigne> On Lisp is a book.
18:02:36 <dons> ?bug
18:02:37 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:02:38 <wy> MyCatVerbs: No. It's a book by paul graham
18:02:42 <shachaf> MyCatVerbs: Reader? It's just an extra argument.
18:02:47 <MyCatVerbs> Ah, my bad. No, I haven't read that.
18:03:01 <eric-lavigne> http://paulgraham.com/onlisp.html
18:03:01 <lambdabot> Title: On Lisp
18:03:04 <puusorsa> maybe
18:03:22 <MyCatVerbs> shachaf: that and a headache and a half to understand why. ;)
18:03:23 <skew> mattam: Monad m where return :: a -> m a; bind :: m a -> (a -> m b) -> m b; law1 :: forall x f, (return x) >>= f = f x; law2 :: forall m, m >>= return = m; law3 :: forall m f g, (m >>= f) >>= g = m >>= (
18:03:29 <skew> \x -> f x >>= g)
18:03:35 <skew> mattam: can you do that?
18:03:38 <mattam> skew: type classes become inductive types, instances are just values of this type.
18:03:43 <mattam> sure
18:03:46 <wy> Is interesting that monads are actually nice ways to use CPS
18:03:50 <puusorsa> i think a friend has that, read parts of it, lisp still has too many ((((()))))))
18:03:54 <mattam> let me past it somewhere
18:03:54 * skew excited
18:04:30 <roger`> puusorsa: a well formed lisp program has exactly the eright amount of ( and )
18:04:35 <wy> puusorsa: I didn't find anything wrong with (((())))), you have emacs any way
18:04:45 <puusorsa> true
18:04:47 <puusorsa> and slime
18:04:51 * ddarius was reading #haskell and drinking lemonade, but he's now out of lemonade.
18:05:01 <wy> slime is so nice
18:05:01 <puusorsa> which is way better than emacs' haskell mode
18:05:11 <puusorsa> and yi .. well i won't go into that
18:05:11 <dons> but you'll never be out of #haskell!
18:05:20 <SyntaxNinja> I'm outta.
18:05:21 <SyntaxNinja> later all
18:05:25 <dons> ciao SyntaxNinja
18:05:42 <MyCatVerbs> wy: emacs? Bah!
18:05:46 * dons has read almost all of the peter lund bytestring benchmark mails now.
18:05:47 <dons> phew.
18:05:49 <MyCatVerbs> wy: I like to mash on the % key in vim instead. ;)
18:05:53 <dons> even the analysis of the analysis tools
18:05:57 <mattam> skew: http://hpaste.org/4635
18:06:22 <MyCatVerbs> wy: you can tell when I play with Scheme, the keycaps of the 5 and shift keys on my keyboard get worn down. ;)
18:06:40 <skew> mattam: nice!
18:06:50 <skew> mattam: do you know of ynot?
18:06:55 * EvilTerran finds Coq's natural-language-like appearance rather disconcerting
18:07:03 <Cale> @protontorpedo
18:07:03 <lambdabot> why is haskell bette than java? java has a shitload of frameworks. its xrazy
18:07:04 <mattam> of course
18:07:27 <mattam> I'm going to do a seminar at Harvard at the end of january.
18:07:55 <ddarius> Coq has a natural language like appearance?
18:07:59 <mattam> I've seen a talk by Nanevsky on it a week ago, it looks great
18:08:26 <pastorn> mattam: what is that?
18:08:29 <mattam> EvilTerran: It is interactive. That's why it makes sense.
18:08:35 <MyCatVerbs> EvilTerran: natural-language-likes should be shot and then burned and then shot again. x_x
18:08:37 <puusorsa> java is the most braindeadly verbose language i've seen
18:08:45 * MyCatVerbs haet teh ambiguity involved.
18:08:54 <mattam> pastorn: what's what ?
18:09:02 <pastorn> that paste you made
18:09:06 <wy> Coq didn't have type classes?
18:09:08 <mattam> skew: are you somehow related to ynot.
18:09:14 <puusorsa> not including brainfuck malbolge etc, but of the languages people seriously think are usable
18:09:24 <skew> puusorsa: COBOL?
18:09:24 <mattam> nope. Only records, i.e. no overloading
18:09:34 <wy> I borrowed a Coq'art from the library but I haven't started yet
18:10:06 <puusorsa> skew, thank god i've been spared from learning cobol
18:10:09 <wy> I wonder why is coq so popular
18:10:19 <skew> mattam: just watching. I've applied to grad school, I think I might like to work on dependently typed programming for concurrent/distributed systems
18:10:26 <puusorsa> i know why i like haskell: i'm lazy
18:10:30 <puusorsa> and so is haskell!
18:10:47 <puusorsa> most stuff done with least amount of typing
18:11:00 <mattam> pastorn: It's a definition of a typeclass Monad, where you can tell what are the laws your operations should verify, and then a few functions on monads. Finally there are instance definitions for functor and applicative which are two other classes.
18:11:13 <wy> puusorsa: You put a bang there and you can't be lazy any more
18:11:34 <puusorsa> i don't mind strictness if she's h0t!
18:11:45 <mattam> wy: because you can do much interesting stuff with it.
18:11:49 <pastorn> mattam: do you follow some specified language?
18:11:59 <ddarius> skew: Seen CLF?
18:12:01 <skew> mattam: I like programs to be able to include their own reasoning. Seems like dependent types almost do that for pure languages
18:12:02 <pastorn> or is it all meta-code/proof-ish?
18:12:04 <wy> mattam: I'll read that book
18:12:26 <wy> mattam: What about HOL, Nuprl, etc etc... ?
18:12:37 <skew> ddarius: is that the same thing as Lollimon?
18:13:00 <ddarius> skew: It's the stuff behind lollimon.  Lollimon itself isn't dependently typed, but the CLF is.
18:13:11 <puusorsa> one thing that makes lisp seem really nice to me: genetic programming
18:13:16 <mattam> The language is Coq's language, only the typing includes some subtyping, overloading and an implicit arguments mechanism to make it possible to write relatively short terms.
18:13:27 <puusorsa> seems like lisp is made for that
18:14:02 <mattam> wy: HOL is in a different category, no dependent types, at first not very Curry-Howard-ish, without a term language
18:14:22 <MyCatVerbs> puusorsa: ...genetic? oO
18:14:39 <puusorsa> look it up on wikipedia or something
18:14:50 <puusorsa> http://en.wikipedia.org/wiki/Genetic_programming
18:14:51 <lambdabot> Title: Genetic programming - Wikipedia, the free encyclopedia
18:14:58 <mattam> NuPRL is similar, but there are some philosophical and pratical differences (NuPRL has undecidable type-checking for example).
18:15:21 <wy> undecidable?
18:15:32 <wy> then how does it work?
18:15:43 <skew> usually it terminates
18:15:47 <ddarius> wy: The same way your programs do.
18:15:52 <mattam> Mostly you don't hit it.
18:16:06 <skew> probably a cuttoff somewhere...
18:16:24 <skew> but this OTT stuff looks quite interesting
18:16:26 <MyCatVerbs> puusorsa: the o_O is that I can't see what on earth GAs have to do with Lisp.
18:16:44 <mattam> yeah OTT kind of bridges the gap between Coq and NuPRL
18:16:45 <wy> ddarius: Isn't haskell using let polymorphism?
18:18:03 <wy> I've seen people using Nuprl here. I like its user interface better than coq
18:18:18 <ddarius> wy: I meant that the halting problem is undecidable, you you manage to write programs that terminate (most of the time...)
18:18:31 <puusorsa> MyCatVerbs, maybe that code is processed into list/tree structures
18:18:34 <MyCatVerbs> puusorsa: they're relatively easy to hack up in practically any language on Earth. Personally, I'd usually just write them in C, since the main difficult parts involved in writing genetic algorithms are usually the fitness evaluation functions, which're always some horrible piece of numerical analysis from physics - for which the choice of programming language is mostly irrelevant, anyway!
18:19:03 <ddarius> wy: That said, type inference in Haskell is exponentially complex, and yet programs get type checked before the end of time.
18:19:30 <MyCatVerbs> (In that you won't have a significantly easier time transcribing pages of equations from your notebook to your machine in Lisp or Haskell or Java or whatever else the flavour of the month is than you would've had in FORTRAN.)
18:19:35 <wy> ddarius: exponetial is the worst case. What's the average case?
18:20:01 <ddarius> wy: Average case is irrelevant.  People don't randomly select programs.
18:20:17 <puusorsa> well i'm too drunk to explain what i think i mean
18:20:50 <wy> ddarius: Are there examples of the worst case programs?
18:21:12 <mattam> There was one for caml that should work just the same
18:21:16 <MyCatVerbs> puusorsa: unless you're talking about using GAs to design programs then running them with eval - which strikes me as crazy, since the damn computer is Turing complete, you'd be more or less guaranteed to get the thing wedged into an infinite loop somewhere or other down the line. :)
18:21:27 <ddarius> > let d x = (x,x); a = d (); b = d a; c = d b; e = d c; f = d e in f
18:21:28 <lambdabot>  ((((((),()),((),())),(((),()),((),()))),((((),()),((),())),(((),()),((),()))...
18:21:34 <mattam> Look for a paper at ICFP or POPL explaining that HM is exp-time :)
18:21:36 <puusorsa> MyCatVerbs, something like that
18:22:17 <wy> ddarius: It terminated
18:22:33 <skew> Also that HM is linear-time as long as you limit the size of your types and don't nest lets leftward
18:22:42 <wy> mattam: That's robinsons algorithm?
18:22:48 <mattam> skew: are you somehow related to ynot ?
18:23:22 <MyCatVerbs> puusorsa: oh, I'm sorry, I have you half backwards there. I should've read that article more thoroughly, rather than just skimming the top few sentences.
18:23:28 <skew> mattam: not working on it or anything like that
18:23:28 <ddarius> wy: Of course it did.  Haskell's type system always terminates.  However, that was only 5 levels and lambdabot truncated the output.  I can write one line of code with a type that takes pages.  Add another line and it won't fit in an encyclopedia set.
18:24:08 <mattam> wy: don't know
18:24:15 <puusorsa> so thinking that lisp is good for gp doesn't seem 101% retarded?
18:24:17 <scook0> in practical terms, undecidability is no worse than exponential time/space
18:24:29 <ddarius> wy: My particular example had 2^5 = 32 nested tuples, just continue the pattern on 5 more times would be 1024, another 10 1000000+, 32 times 4,000,000,000.
18:24:37 <MyCatVerbs> puusorsa: no, but not for the reasons you're thinking. ;)
18:24:40 <scook0> because if either of them happens to programs you care about, you're hosed anyway
18:24:55 <puusorsa> MyCatVerbs, STOP READING MY THOUGHTS GODDAMIT
18:25:03 <Japsu> bhahaha
18:25:04 <puusorsa> i'll have to get my afdb
18:25:05 <Japsu> gn
18:25:22 <monochrom> eh?! exponential time/space is *fast*
18:25:28 <puusorsa> http://zapatopi.net/afdb/
18:25:29 <lambdabot> Title: Aluminum Foil Deflector Beanie
18:25:30 <MyCatVerbs> puusorsa: any language where you have a compiler available at run time would be handy for that iff you happened to be testing each generated function on a few hojillion inputs, howevar...#
18:25:48 <monochrom> doubly exponential is "fair"
18:26:27 <MyCatVerbs> puusorsa: the only *really8 handy thing I see about that for lisp is that that would normally involve scadloads of horrible pointer manipulation... which lisp, like *all* functional languages, allows you to express succintly and with the minimum of fuss.
18:26:36 <MyCatVerbs> monochrom: what's half-exponential, slick?
18:26:48 <wy> ddarius: The example seems to be exponential itself
18:27:23 <ddarius> wy: Obviously not.  I don't need to write 4 billion lines of code.
18:27:44 <puusorsa> MyCatVerbs, could be, can't say i'm a lisp expert
18:27:48 <puusorsa> or GP expert
18:27:49 <wy> ddarius: You can't give me an exponential running time program and say the type checking is exponential.
18:27:51 <monochrom> 4 billion lines of code will probably overflow the line counter in most compilers. :)
18:28:05 <ddarius> wy: It doesn't take exponential time to run.
18:28:20 <ddarius> wy: And the running time is irrelevant any way.
18:28:23 <mattam> scook0:  if it is undecidable because you have general recursion it can be more dangerous than because you just don't have a decision procedure. Finding where it loops could be difficult.
18:28:25 <MyCatVerbs> puusorsa: I mean it doesn't sound significantly more useful than, say, Haskell is for the same task.
18:28:45 <wy> ddarius: I believe it's exponential.
18:28:51 <ddarius> wy: You are wrong.
18:29:01 <ddarius> And as I said, it is irrelevant.
18:29:15 <puusorsa> MyCatVerbs, "The individuals of genetic programming are usually LISP programs represented as parse trees" ...
18:29:29 <puusorsa> from http://www.gene-expression-programming.com/GepBook/Chapter1/Section5.htm
18:29:30 <lambdabot> Title: Genetic programming, http://tinyurl.com/2wew2b
18:29:43 <MyCatVerbs> puusorsa: yes, but that's just *their* implementation.
18:30:05 <wy> ddarius: It's relevant because if the program is itself exponential, the exponential type checking is irrelevant
18:30:10 <MyCatVerbs> Isn't Haskell's type checker bounded above by something like n^3?
18:30:27 <ddarius> MyCatVerbs: ?  (No...)
18:30:51 <MyCatVerbs> ddarius: huh. I thought it was supposed to have a polynomial upper bound.
18:31:05 <monochrom> I think you want to type-check before running?
18:31:28 <skew> What is the complexity if you use a DAG representation of types with sharing?
18:31:44 <ddarius> wy: Run-time is completely irrelevant to the type checking time.  The type checker doesn't run the program to do it's job.  Type checking can take arbitrarily longer or shorter than the run-time.  Anyway, assuming sharing, the code runs in linear time (at least as far as building the term is concerned)
18:32:26 <monochrom> Perhaps sharing saves. But the real money is at type inference to begin with. Programmer didn't annotate, compiler has to infer, that's the expensive part.
18:34:10 <wy> ddarius: right. I see
18:35:02 <wy> monochrom: Maybe there are better ways to write the type checker?
18:36:11 <monochrom> Did you see the proofs concerning the complexity of type checking and type inference? They don't take a slow algorithm and prove it slow. They prove there is no faster algorithm.
18:39:35 <wy> Most of the NP-complete proofs are overestimating the chances of the worst case
18:40:26 <skew> monochrom: it is also linear if the size of types are bounded, and you do not have lets in the definitions of let-bound variables
18:40:48 <skew> have a bound on the depth of nesting of lets, at least
18:41:19 <sebas_> Where can I find some help with using Haskell as the backend of a webpage?
18:42:03 <eric-lavigne> I'm trying to install the latest ghc release on Debian. There's a binary distribution for Linux at http://www.haskell.org/ghc/download_ghc_682.html#x86linux but it requires an old version of libreadline. The page recommends using an RPM that it provides, but that is for Red Hat. How can I satisfy this dependency on Debian?
18:42:04 <lambdabot> Title: GHC: Download version 6.8.2
18:42:31 <monochrom> None of NP-completeness concerns overestimation or chances. I refuse to continue with this totally misinformed discussion of ill-perceived notions.
18:43:25 <roger`> eric-lavigne: just use the binary, symlink or copy the readline library to the one it expects
18:43:46 <skew> eric-lavigne: use alien to install the readline RPM
18:43:47 <roger`> eric-lavigne: eg cd /lib;ln -s libreadline.so.5 libreadline.so.4
18:43:52 <skew> eric-lavigne: worked for me
18:44:02 <roger`> no point redownloading it if you already have the binary
18:44:21 <sclv> @remember monochrom I refuse to continue with this totally misinformed discussion of ill-perceived notions.
18:44:22 <lambdabot> It is stored.
18:44:25 <eric-lavigne> It can use libreadline 5? wow, that's much easier than expected
18:44:31 <skew> roger`: does readline promes that kind of backwards compatibility?
18:44:54 <roger`> skew: it works for me, it seems to be the recommended work around mentioned here
18:46:46 <eric-lavigne> Seems to be working so far. Wow!
18:47:39 <eric-lavigne> Thanks.
18:49:11 <icarroll> @quote type-directed
18:49:12 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
18:50:41 <icarroll> can anyone point me at a succint definition of "type-directed"?
18:51:18 <skew> icarroll: directed by types?
18:51:40 <sclv> @all-dicts type-directed
18:51:40 <lambdabot> No match for "type-directed".
18:51:42 <skew> icarroll: perhaps defined by structural recursion on a type?
18:51:59 <icarroll> skew: I was thinking it might be something like that.
18:52:03 <sjanssen> eric-lavigne, roger`: sorear always recommends that you use a hex editor to change the '4' to a '5' :P
18:53:15 <monochrom> I do that. It's great. :)
18:53:48 <eric-lavigne> I did the symbolic link, as roger suggested. Seems to work so far.
18:54:02 <icarroll> so what would be an alternative to "type-directed"?
18:54:18 <monochrom> object-oriented
18:55:00 <eric-lavigne> object-oriented <-- I avoid this word. It is used for way too many things.
18:55:29 <wy> Don't use "oriented". That's the bad part
18:55:52 <sjanssen> icarroll: I think it's when execution of a program is instructed by the type of its input
18:56:05 <icarroll> sjanssen: thanks
18:56:07 <sjanssen> like class based overloading in Haskell
18:56:29 <sjanssen> though I think it's usually applied to more extreme uses
18:56:30 <skew> icarroll: or more interestingly, the type of it's output
18:56:40 <skew> icarroll: like with read
18:56:52 <wy> I guess "type directed" would be more than that
18:57:03 <icarroll> skew: so read could be described as type-directed parsing?
18:57:53 <wy> For example the editor can interact with the user in a type directed way, filling in cases that the programmer must complete...
18:58:04 <pmatos> Is there any function in the prelude like: fand f g x = f x && g x
18:58:11 <skew> icarroll: the choice of parsing function is type-directed, at least
18:58:12 <pmatos> Where: fand :: (a -> Bool) -> (a -> Bool) -> a -> Bool
18:58:13 <pmatos> ?
18:59:07 <icarroll> @hoogle (a -> Bool) -> (a -> Bool) -> a -> Bool
18:59:08 <lambdabot> No matches, try a more general search
18:59:15 <sjanssen> pmatos: liftM2 (&&) will work
18:59:40 <icarroll> @t liftM2 (&&)
18:59:40 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:59:48 <icarroll> :t liftM2 (&&)
18:59:49 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
19:00:31 <pmatos> sjanssen: I'll check it out, thank.
19:00:36 <sjanssen> @type \f g x -> liftM2 (&&) f g x
19:00:37 <lambdabot> forall t. (Monad ((->) t)) => (t -> Bool) -> (t -> Bool) -> t -> Bool
19:00:59 <sjanssen> pmatos: it uses the ((->) a) Monad instance, so you'll need to import Control.Monad.Instances
19:01:09 <wy> I just found C-M-/ is useful in haskell-mode
19:01:50 <monochrom> @thanks
19:01:51 <lambdabot> you are welcome
19:01:57 <monochrom> @thank you
19:01:57 <lambdabot> Maybe you meant: thank you thanks
19:02:07 <monochrom> @you
19:02:08 <lambdabot> And furthermore, my bowling average is unimpeachable!!!
19:02:16 <monochrom> Oh, @you = @yow
19:02:38 * shachaf prefers liftA2 (&&).
19:05:02 <sjanssen> shachaf: does (->) have an Applicative instance?
19:05:15 <sjanssen> I know the entire mtl is missing them
19:06:01 <shachaf> sjanssen: Wasn't (r ->) one of the reasons for Applicative in the first place?
19:06:24 <sjanssen> yeah, I suppose they make a big point about S in the paper
19:08:07 <shachaf> sjanssen: Oh, speaking of Applicative, I see that you updated DList. :-)
19:13:04 <gmh33> anyone have any idea why configure would say "cannot determine current directory"?
19:14:09 <ricky_clarkson> Grr.  http://www.haskell.org/yampa/ is a perfect example of a useless webpage.
19:14:10 <lambdabot> Title: Yampa
19:14:33 <ricky_clarkson> No code samples until you grab a PDF or TGZ.
19:16:29 <wy> Haha. ghc 6.8.2 finally installed!
19:17:45 <gmh33> wy: what platform?
19:17:49 <wy> Is there a way to tell ghc where the libraries installed for 6.6.1 is?
19:17:58 <wy> gmh33: ubuntu 7.10
19:18:01 <gmh33> ah
19:18:35 <Saizan> wy: you need to rebuild them for 6.8.2
19:18:47 <wy> Saizan: ah.... That's crazy
19:19:10 <wy> so I'll just use it to debug programs
19:19:42 <wy> It's so cool that it can display partially inferred types
19:19:58 <wy> And underline the problematic expression
19:20:40 <wy> But I still haven't figured out why the exception occur here: tickS = \(p,c) -> (undefined, (p, c+1))
19:20:58 <wy> If I change undefined to (E undefined), it works.
19:21:43 <pastorn> i wanna code
19:22:00 <pastorn> can someone point me to an intermediate lab assignment involving monads
19:22:01 <pastorn> ?
19:22:07 <Saizan> wy: i think you should move backwards and see where that value is inspected
19:22:13 <pmatos> Is there anything I need to import in order to use read on ByteStrings?
19:22:18 <pastorn> *could* ++ ", please"
19:22:34 <gmh33> nvm
19:22:38 <pmatos> I'm importing  import qualified Data.ByteString.Char8 as BS, however, using read expects String, and using BS.read returns error.
19:23:10 <wy> Saizan: The question is simple without the debugger. Why doesn't undefined match (E something) ?
19:23:38 <Saizan> wy: undefined doesn't match anything
19:23:56 <wy> does it only match itself?
19:24:02 <Valodim> why would it match something. the definition of "something" is that it is defined
19:24:36 <Saizan> wy: it has the most general type but it's the representation of an error or non-termination
19:24:57 <Saizan> in particular undefined = error "undefined" so it's a runtime exception
19:25:25 <Saizan> which is triggered if you try to match that value with anything
19:25:35 <wy> Maybe it's easier to talk about this with the code. http://hpaste.org/4634
19:25:50 <Saizan> why do you use undefined?
19:26:34 <wy> I happened to have a value that's irrelevant
19:27:26 <wy> Wadler's paper is using () for that, I got a type error for match () against Value. So I changed this to undefined
19:27:50 <Saizan> ok, but then you are supposed to not use that value
19:28:16 <skew> pmatos: you can't read general values from bytestrings
19:28:35 <skew> pmatos: there are a few functions  like parseInt
19:28:51 <pmatos> but it says that ByteString implements the Read class, should it read general values?
19:28:56 <Saizan> and Success undefined /= undefined, because the Success constructor is an inspectable values
19:29:08 <skew> pmatos: but now that you mention it, Read internally uses ReadP parsers, and I think somebody made a ByteString version of ReadP recently
19:29:45 <skew> pmatos: that means you can read an ordinary string into a bytestring
19:30:00 <pmatos> skew: oh... ok...
19:31:03 <skew> pmatos: like read "\"asdf\"" :: Data.ByteString.Char8
19:31:50 <Saizan> > show $ Data.ByteString.Char8.pack "asd"
19:31:52 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'
19:33:22 <wy> Saizan: Is (E Value) = (E undefined) ?
19:34:25 <Saizan> wy: why do you think it could?
19:34:47 <Saizan> wy: maybe you're confusing values with types?
19:35:39 <Saizan> undefined can have type Value, since it can have any type, but you can't get an useful value out of it
19:35:53 <wy> Saizan: It seems undefined also is a value
19:36:13 <shachaf> wy: undefined is only a value.
19:36:16 <shachaf> @ty undefined
19:36:18 <lambdabot> forall a. a
19:36:21 <ricky_clarkson> undefined has a type but no value, I thought.
19:36:32 * pastorn wants to play with ByteString... How do i even get started?
19:36:48 <pastorn> is there a function String -> ByteString?
19:36:55 <Saizan> well it as a value as much as an infinite loop has a value..
19:36:56 <shachaf> pastorn: pack, I think.
19:36:56 <mrd> pack
19:37:05 <wy> Do you think it's a valid use of it in my program? http://hpaste.org/4634. In the function add and apply, also tickS
19:37:11 <pmatos> skew: thanks for the explanation.
19:37:13 <pastorn> pack :: [GHC.Word.Word8] -> ByteString
19:37:45 <mrd> i use pack all the time
19:37:46 <wy> shachaf: I don't know if it's OK to use it for some irrelevant value
19:38:08 <Saizan> wy: in add and apply you're just binding the argument of those lambdas to the name undefined, shadowing the previous definition
19:38:27 <shachaf> wy: Yes, you want \_ -> ...
19:38:36 <shachaf> wy: undefined is just a variable.
19:39:22 <wy> oh I see
19:39:27 <ricky_clarkson> > let unsafePerformIO x=x in unsafePerformIO "hello"
19:39:28 <lambdabot>  "hello"
19:39:35 <Saizan> undefined is not a keyword, it's just defined in the Prelude as an exception
19:39:37 <ricky_clarkson> ..same thing
19:39:40 <shachaf> > (\undefined -> undefined) 5
19:39:41 <lambdabot>  5
19:39:49 <ricky_clarkson> > const 5
19:39:49 <lambdabot>  Add a type signature
19:39:52 <wy> emacs fails to reload my file after ghc gets into <exception thrown> state
19:40:02 <ricky_clarkson> > const 5 :: Integer -> Integer
19:40:03 <lambdabot>  <Integer -> Integer>
19:40:34 <ricky_clarkson> wy: You could use const instead of \_ ->
19:41:51 <shachaf> wy: For that matter, you could define a (>>).
19:42:10 <shachaf> Where "a >> b" = "a >>= (\_ -> b)"
19:42:33 <shachaf> wy: (Where (>>=) is bind.)
19:42:53 <shachaf> wy: Also, s/cn/nc/ :-)
19:43:06 <wy> I'm trying not to use type classes and operators in this program only because that could be my tutorial ;-)
19:43:55 <pastorn> s <- BS.getLine
19:43:55 <pastorn> *** Exception: no buffering
19:44:02 <wy> So (>>=) is a method for all types in the class Monad?
19:44:05 <pastorn> what's GHCIs problem?
19:44:07 <shachaf> wy: Because what?
19:44:17 <shachaf> wy: Yes.
19:44:29 <shachaf> wy: And return, which is unit.
19:45:05 <wy> shachaf: Good! I think it's easier to understand it if the tutorial is without overloading.
19:45:33 <shachaf> wy: I think having one name makes things simpler.
19:46:32 <wy> shachaf: Sure. I just want to show how these things can be developed without any help from type classes, and then when we have type classes, things get even nicer :-)
19:49:19 <wy> haskell-mode needs some update for 6.8.2, emacs always hang at reload after exceptions
19:50:31 <wy> What can I use in: tickS = \(p,c) -> (Success undefined, (p, c+1)) ? It seems it doesn't accept _ or anything else
20:02:16 <pastorn> there is no words function for bytestrings, right?
20:02:34 <pastorn> i was thinking of doing a sort'n'count app for BS, as an exercise
20:04:24 <skew> pastorn: are you looking at one of the Char8 modules?
20:04:37 <pastorn> i'm just looking at Data.ByteString
20:04:38 <skew> pastorn: try Data.ByteString.Lazy.Char8
20:04:52 <pastorn> i was thinking of combinig splitAt and elemIndex
20:06:02 <wy> 6.8.2 is really cool! But how can I install those packages?
20:07:14 <skew> wy: how many packages?
20:07:35 <wy> skew: Currently I only have the once came with ghc
20:07:37 <skew> wy: the installer comes with all the standard hierarchial libraries
20:07:49 <wy> I need gtk
20:07:54 <skew> wy: for some reason debian splits a lot of those out into separate little things
20:08:05 <pastorn> wy: what would be a good approach? folding the entire file into a big tree?
20:08:19 <wy> But they have only the ones for 6.6.1
20:08:25 <skew> wy: it's not hard to build
20:08:38 <pastorn> sorry, that was for skew
20:09:35 <wy> Isn't there a way to automatically build the package into a debian package?
20:10:01 <skew> wy: cabal2rpm + alien might work
20:10:55 <roger`> if you have 6.8.2, all you need to do is darcs get the library you want and install it with cabal
20:16:56 <pastorn> i am doing an insert function, ins :: a -> Coll a -> Coll a, but foldl' :: (a -> b -> a) -> a -> [b] -> a, so i'm wondering, should i redefine insert, or how expensive is flip?
20:25:47 <Valodim_> aren't if statements allowed in do blocks?
20:26:40 <wy> roger`: They will depend on another package and yet another ...
20:26:43 <pastorn> Valodim_: probably indentation error
20:26:51 <oerjan> Valodim_: yes, but then and else cannot appear right under the if
20:27:03 <pastorn> Valodim_: use http://hpaste.org and show us :)
20:27:11 <oerjan> also, else is still mandatory
20:27:48 <Valodim_> yeah it says indentation error
20:27:52 <Valodim_> just using regular indentation
20:27:54 <Valodim_> ...pasting...
20:28:27 <oerjan> hpaste bot gone...
20:28:57 <wy> oerjan: Is there a general darcs command for the packages? Are they in the same level of directory?
20:29:24 <oerjan> um ask someone else please :)
20:29:47 <oerjan> guess you intended to :)
20:30:31 <wy> I just guess you know
20:30:49 <pastorn> Valodim_: where's my paste? :p
20:30:54 <Valodim_> yah, yah
20:31:37 <roger`> <wy> roger`: They will depend on another package and yet another ... --- so? it's not an endless loop
20:31:52 <Valodim_> http://hpaste.org/4637
20:32:12 <Valodim_> "return" just puts the Int into an IO wrapper, doesn't it?
20:32:20 <Valodim_> anyways it gives indentation error on the else line
20:32:36 <wy> roger`: It's quite tedious to get all of them and some of them are not in some standard places
20:32:40 <roger`> wy, usually "darcs get --partial http://url.to/repo" is what you use to check them out, if that's what you were asking
20:32:48 <oerjan> yep as i said else must not be right below the if
20:32:51 <roger`> wy, uh... welcome to programming?
20:32:59 <Valodim_> so it must be indented one more?
20:33:02 <pastorn> Valodim_: annoted
20:33:09 <oerjan> right
20:33:14 <Valodim_> oh yeah
20:33:24 <pastorn> Valodim_: reload the paste :)
20:33:26 <Valodim_> works
20:33:52 <Valodim_> yeah that's nicer
20:33:55 <roger`> wy, the latest Haskell Communities and Activities reports mentions improvement to hackage and cabal going on, so perhaps oneday the dependency thing and packages will all be centralized or something.
20:33:55 <pastorn> cool ;)
20:33:57 <Valodim_> kinda reminds me of delphi
20:34:07 <Valodim_> well "works" as in, the error is now not about the indentation anymore
20:34:07 <pastorn> double-space indentation is nice... never fails
20:34:22 <oerjan> Valodim_: i think you want type Int -> IO Int
20:34:46 <oerjan> :t getStdRandom
20:34:47 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
20:34:54 <sk> Valodim_: I think that is annoying to you have to put if then else all on the same line
20:35:10 <ddarius> A year or two ago Hackage and Cabal were just a twinkle in some Haskell programmers' eye.
20:35:42 <pastorn> Valodim_: the int you give to the function doesn't come from a file or from stdin or anything like that, right? then, as oerjan said, it should be :: Int -> IO Int
20:35:47 <oerjan> Valodim_: in most cases, the monad/IO goes only on the final result of a function
20:35:53 <andyjgill> @seen conal
20:35:53 <lambdabot> I saw conal leaving #haskell and #ghc 2h 27m 28s ago, and .
20:35:57 <Valodim_> ok
20:36:31 <oerjan> unless you are writing something higher-order
20:37:21 <oerjan> Valodim_: btw getStdRandom . randomR = randomRIO
20:37:22 <Valodim_> ok if it's int, how do I get the Int out of the IO Int, without using an additional <- assignment?
20:38:13 <oerjan> oh right
20:38:18 <oerjan> just drop the return $
20:38:52 <Valodim_> already did
20:39:04 <oerjan> not the last return though
20:39:23 <Valodim_> aaah
20:39:23 <oerjan> @src randomRIO
20:39:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:39:24 <Valodim_> hah
20:39:25 <Valodim_> ok
20:39:48 <Valodim_> sweet
20:39:48 <oerjan> the first return is not needed because rollEDice a is already in IO
20:39:53 <Valodim_> yeah
20:40:06 <Valodim_> still generally though, do I need to use <- everytime I want to get something out of a monad?
20:40:34 <wy> The debugger is soooo cool
20:40:36 <pastorn> yeah, but design most of your functions for not being monadic
20:40:50 <Valodim_> yep
20:41:11 <Valodim_> just thought there might be some syntactic sugar for that
20:41:40 <sk> isn't <- a syntactic sugar already
20:41:57 <Valodim_> it is
20:42:13 <sk> u want it sweeter :)
20:42:24 <Valodim_> like coffee, the sweeter the better
20:42:40 <sk> oh no... i've been drinking coffee without sugar for years
20:42:44 <oerjan> Valodim_: pointfree lovers use >>= directly :)
20:42:55 <Valodim_> yeah but that looks ugly :P
20:43:27 <oerjan> especially with case and if
20:43:38 <pastorn> mmm... points-free
20:44:03 <pastorn> Valodim_: i wanna show you something... do you know lambda expressions?
20:44:09 <Valodim_> yep
20:44:11 * oerjan takes his coffee black these days
20:44:40 <sk> i was just thinking, could you make a depth-first search tree in an elegant functional way
20:44:55 <pastorn> say that a vector is (Int,Int), could you write me a lambda expression for vector addition?
20:45:17 <Valodim_> (\(a,b) -> a+b)
20:45:20 <oerjan> \(a1,a2) (b1,b2) -> (a1+b1,a2+b2)
20:45:39 <pastorn> @pl ( \(a1,a2) (b1,b2) -> (a1+b1,a2+b2) )
20:45:39 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
20:45:42 <pastorn> yay
20:45:58 <oerjan> um there's an arrow improvement to that
20:46:01 <pastorn> @type ap
20:46:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:46:59 <oerjan> uncurry((+)***(+))
20:47:01 <Valodim_> ah, "addition" as in that way
20:47:01 <Valodim_> k
20:47:20 <sk> question for all... how to construct a depth-first search tree in haskell without IORef? would the result be ugly?
20:47:37 <oerjan> :t uncurry(***).uncurry((+)***(+))
20:47:39 <lambdabot>     Couldn't match expected type `b -> c'
20:47:39 <lambdabot>            against inferred type `(b1 -> b1, b' -> b')'
20:47:39 <lambdabot>     In the first argument of `uncurry', namely `((+) *** (+))'
20:47:42 <oerjan> bah
20:47:57 <qpu> since that's the first line of haskell that's plainly obvious to me, what does the uncurry (flip ... stuff mean? and what's an arrow improvement?
20:48:34 <ddarius> sk: Are you talking about over a graph or just a binary search tree?
20:48:39 <pastorn> sk: i SHOULD now what depth-first means by now, but i forgot... could you explain it real quick?
20:48:48 <sk> ddarius, in a graph
20:48:52 <oerjan> qpu: i mean an improvement to what @pl created
20:49:09 <Valodim_> depth first as in, first file in nth subtree first
20:49:33 <Valodim_> value, I mean
20:49:34 <qpu> oerjan: is @pl how you address lambdabot, or is it an expression?
20:49:40 <oerjan> qpu: the @pl plugin rewrites an expression with no lambdas
20:49:41 <sk> pastorn: in depth-first you search your graph to the deepest first b4 you start constructing
20:49:57 <ddarius> sk: There are a variety of ways of doing it, most don't require IORefs (though perhaps the most "obvious" efficient way uses a slightly impure construct called "observable sharing")
20:50:11 <oerjan> but with more than one argument it is often utterly unreadable.
20:50:35 <sk> ddarius: mind to elaborate? especially with "observable sharing"
20:50:40 <oerjan> sometimes you can do better by hand, using the *** and &&& combinators from Control.Arrow
20:51:34 <qpu> oerjan: thanks, i think i understand :] is a lambda the arrow symbol -> ?
20:51:47 <oerjan> qpu: \ ... -> ...
20:52:01 <ddarius> λ
20:52:04 <oerjan> the \ is ASCII for the greek letter lambda :)
20:52:26 <qpu> oh, i see it now :)
20:53:12 <ddarius> http://www.haskell.org/haskellwiki/Research_papers/Data_structures#Graphs
20:53:13 <lambdabot> Title: Research papers/Data structures - HaskellWiki, http://tinyurl.com/23sskc
20:53:15 <Valodim_> does point-free style have any practical advantage over lambda?
20:53:16 <ddarius> @google "observable sharing"
20:53:18 <lambdabot> http://citeseer.ist.psu.edu/claessen99observable.html
20:53:18 <lambdabot> Title: Observable Sharing for Functional Circuit Description - Claessen, Sands (Researc ...
20:53:44 <sk> thanks =)
20:54:16 <oerjan> :t uncurry(***).((+)***(+)) -- think this is it
20:54:17 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b, b') -> (b, b')
20:54:27 <ddarius> Valodim_: Just blindly getting rid of "points" doesn't, but (the real) point-free style has specific other connotations.
20:54:31 <oerjan> i had an uncurry too many
20:54:37 <pastorn> Valodim_: besides looking utterly stunning?
20:54:50 <wy> It seems that the debugger will not stop if there is no bug...
20:54:51 <Valodim_> yeah but stunning in an unreadable way
20:54:58 <Valodim_> looking at K, there's at least some practical use
20:55:03 <pastorn> Valodim_: not when you get used to it
20:55:21 <ddarius> pastorn: The bilge @pl almost always produces is unreadable period.
20:55:32 <jsnx> Valodim_: just joined -- what's stunning?
20:55:51 <Valodim_> point-free over lambda
20:55:54 <pastorn> ddarius: yes, but it looks kinda cool =)
20:55:58 <allbery_b> @quote flip-stream
20:55:58 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
20:56:00 <jsnx> ddarius: what's @pl?
20:56:09 <oerjan> > (uncurry(***).((+)***(+))) (1,2) (5,10)
20:56:10 <lambdabot>  (6,12)
20:56:20 <ddarius> @pl \x y -> y x x
20:56:21 <lambdabot> flip =<< flip id
20:56:21 <allbery_b> @help pl
20:56:22 <lambdabot> pointless <expr>. Play with pointfree code.
20:57:00 <ricky_clarkson> @pl \x y -> y*10+x
20:57:00 <lambdabot> (. (10 *)) . (+)
20:57:10 <ricky_clarkson> @pl \x y -> x+y*10
20:57:10 <lambdabot> (. (10 *)) . (+)
20:57:16 <ddarius> Valodim_: Point-free style is supposed to support an approach where programs are manipulated algebraically.
20:57:25 <allbery_b>  @pl converts code with "points" (lambda bindings) into code without lambda bindings.  done properly, it facilitiates mathematical reasoning about code.
20:57:28 <jsnx> oh
20:57:31 <ddarius>  @pl has one such example built in to it's "optimizer"
20:57:34 <ricky_clarkson> @pl \x y -> x*10+y
20:57:35 <lambdabot> (+) . (10 *)
20:57:40 <ddarius> @pl \x -> map f (map g x)
20:57:41 <lambdabot> map (f . g)
20:57:51 <Valodim_> ah
20:57:54 <ddarius> This uses the transformation, map f . map g = map (f . g)
20:58:06 <ricky_clarkson> As you can see, sometimes @pl gives good result sometimes hell no.
20:58:26 <ricky_clarkson> results*
20:58:45 <allbery_b> sometimes it's just hard to remove points.  other times there's a clever way to do it but @pl isn't smart enough to find it
20:58:56 <qpu> what does the . mean in pointfree code?
20:59:01 <jcreigh> sometimes it is undesirable to remove points.
20:59:01 <oerjan> @src .
20:59:02 <lambdabot> (.) f g x = f (g x)
20:59:02 <ricky_clarkson> compose
20:59:03 <allbery_b> function composition
20:59:11 <qpu> okay, looked familiar :)
20:59:21 <ricky_clarkson> \x y z -> x*y+y*z
20:59:23 <ddarius> allbery_b: It's always possible (with the right primitives) to remove "points".
20:59:26 <qpu> is that what is called currying?
20:59:26 <oerjan> qpu: ASCII for a small centered circle ;)
20:59:32 <ricky_clarkson> @pl \x y z -> x*y+y*z
20:59:32 <ddarius> qpu: No.
20:59:32 <lambdabot> (`ap` (*)) . (((.) . (+)) .) . (*)
20:59:35 <ddarius> :t curry
20:59:35 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:59:41 <allbery_b> ddarius: I didn't say impossible, just hard
20:59:46 <pastorn> @src curry
20:59:46 <lambdabot> curry f x y = f (x, y)
20:59:48 <ddarius> allbery_b: It's mechanical.
21:00:06 <ricky_clarkson> qpu: In Haskell, currying isn't so much something that happens as something that is.
21:00:27 <ricky_clarkson> qpu: a function on two args is actually a function on one that returns a function on another.
21:00:49 <ddarius> ricky_clarkson: Currying rarely happens at all in Haskell.  What it is is that the functions are already in Curried form.
21:00:54 <qpu> oh, hmm..
21:01:03 <pastorn> i have a primitive BST where i pair (a,Int), how do i do splay operations?
21:01:14 <ricky_clarkson> ddarius: That's what I was trying to say.  How did I say it wrong?
21:01:56 <ddarius> ricky_clarkson: Currying is -turning- a function (a,b) -> c into one a -> b -> c.  Haskell functions are usually not in the former form to begin with.
21:02:08 <jcreigh> qpu: suppose I write a funciton "someFunc a b = a + b". under the hood, it's actually "someFunc = \a -> (\b -> a + b)"
21:02:37 <ddarius> jcreigh: That's what it is "over" the hood too.
21:02:56 <jcreigh> ddarius: well, the syntax could lead you think otherwise.
21:03:05 <jcreigh> s/think/to think/
21:03:11 <ricky_clarkson> Only if your brain had a previous binding for it. ;)
21:03:13 <allbery_b> but (->) groups to the right so that can also be written as someFunc = \a -> \b -> a + b.  note the similarity to how types are written; that's deliberate
21:03:32 <ddarius> allbery_b: That -> doesn't group at all.
21:03:44 <allbery_b> well, it acts as if it does
21:04:12 <qpu> it seems like \a -> \b describes "a becomes b" ?
21:04:29 <jsnx> qpu: well, it's actually invalid
21:04:31 <allbery_b> you're grouping it too tightly
21:04:46 <jsnx> `\ a -> b` takes a to b
21:04:47 <qpu> i can't be right though, or someFunc would be \a -> a + b
21:04:49 <allbery_b> \a "yields" \b -> a + b (a function)
21:05:14 <jsnx> qpu: are you familiar with the lambda calculus?
21:05:17 <qpu> okay, takes sounds familiar again. like a mapping
21:05:26 <jsnx> qpu: the notation is derived from it...
21:05:30 <allbery_b> (it takes the whole thing, not just the next "token")
21:05:54 <qpu> no, i don't think so. i've had linear algebra and a vector calc but i don't imagine there's an overlap
21:05:57 <ddarius> (that would be because -> is syntax not an operator [in this context] and so does not group at all)
21:06:05 <allbery_b> yeh
21:06:49 <jsnx> qpu: (\a -> b) is "a function that takes a to b"
21:07:12 <jsnx> qpu: the backslash is intended to be a λ (lambda)
21:07:13 <qpu> jsnx: that makes sense. but why cant someFunc be defined like \a -> \a + b ?
21:07:18 <qpu> oh, i see
21:07:20 <pastorn> Valodim_: http://haskell.org/haskellwiki/Pointfree <-- this is a good read
21:07:31 <jsnx> qpu: what does some func do?
21:07:36 <jsnx> someFunc
21:07:59 <qpu> jcreigh: suppose I write a funciton "someFunc a b = a + b". under the hood, it's actually "someFunc = \a -> (\b -> a + b)"
21:08:01 <jsnx> so, a lambda has two parts... arguments and a result
21:08:18 <jcreigh> *an* argument
21:08:57 <jsnx> jcreigh: it is normal to write λab.abb and stuff like that
21:09:08 * Valodim read
21:09:33 <jsnx> your puritanism is unhelpful
21:09:51 <dons> what's all this?
21:09:57 <loupgaroublond> can there be more than one library directive in a cabal file, or is that restricted to programs?
21:10:17 <loupgaroublond> s/program/executable/
21:10:21 <dons> loupgaroublond: i've only ever seen it for programs. but try it -- maybe it works!
21:10:30 <jcreigh> currying is how you write functions that appear to take more than one argument in a language where functions only take one argument, so I thought it was relevant.
21:10:41 <loupgaroublond> dons, i actually don't want that behavior :)
21:11:06 <jsnx> jcreigh: yeah, but in haskell, you can write multi-arg lambdas
21:11:20 <jcreigh> jsnx: sure, but it's just shorthand.
21:11:24 <jsnx> yes
21:11:33 <jsnx> so, lambdas have arguments and an expression
21:11:46 <jsnx> in common usage, anyhow
21:11:51 <qpu> right :]
21:11:51 <jcreigh> heh. :)
21:11:53 <jsnx> and, if i may continue
21:12:29 <jsnx> the problem with `\a -> \a + b` is that the second lambda has invalid arguments and does not graduate to an expression ever
21:12:54 <qpu> i think i see that now
21:13:12 <jsnx> good
21:13:20 <Absolt> quick question, is there a builtin that will tell me the first element of a list that matches a predicate?
21:13:29 <jsnx> Absolt: find
21:13:34 <jsnx> :t find
21:13:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:13:44 <Absolt> yay! ty :)
21:13:47 <pastorn> @src find
21:13:47 <lambdabot> find p          = listToMaybe . filter p
21:14:04 <qpu> but why someFunc = \a -> (\b -> a + b) and not someFunc = \a -> a + b ?
21:14:19 <qpu> or was that to illustrate currying?
21:14:22 <jsnx> qpu: where did the b come from in the second one?
21:14:23 <pastorn> @src listToMaybe
21:14:24 <lambdabot> listToMaybe []        =  Nothing
21:14:24 <lambdabot> listToMaybe (a:_)     =  Just a
21:14:58 <jsnx> qpu: you don't include it in the args, and it's not anywhere else in that expression...
21:15:08 <jsnx> > someFunc = \a -> a + b
21:15:08 <lambdabot>  Parse error at "=" (column 10)
21:15:15 <jsnx> > let  someFunc = \a -> a + b
21:15:16 <lambdabot>  Parse error at end of input
21:15:23 <jsnx> eh?
21:15:27 <jsnx> > let  someFunc  b = \a -> a + b
21:15:27 <qpu> jsnx: hmm, right
21:15:28 <lambdabot>  Parse error at end of input
21:15:28 <jcreigh> jsnx: need in expr
21:15:48 <jsnx> > let someFunc b = \a -> a + b  in someFunc
21:15:49 <lambdabot>  <Integer -> Integer -> Integer>
21:15:54 <jsnx> > let someFunc = \a -> a + b  in someFunc
21:15:55 <lambdabot>   Not in scope: `b'
21:16:02 <pastorn> i have a binary search tree and i need a toList-function, and i don't think extensive use of ++ is a good way, so what can i do?
21:16:18 <jsnx> qpu: see, so you have to say where the `b` comes from...
21:16:19 <qpu> okay, i'm starting to catch on
21:16:59 <jsnx> > let someFunc = \a b -> a + b  in someFunc
21:17:00 <lambdabot>  <Integer -> Integer -> Integer>
21:17:06 <ddarius> pastorn: The typical trick is to use ([a] -> [a]) instead of [a].
21:17:21 <qpu> that's how to use multiple arguments?
21:17:35 <jsnx> qpu: that's how to make a lambda of multiple arguments
21:17:43 <jsnx> > let someFunc a b = a + b  in someFunc
21:17:44 <lambdabot>  <Integer -> Integer -> Integer>
21:17:51 <jcreigh> ^^ that's what you'd use in practice.
21:17:58 <jsnx> qpu: aye
21:18:00 <qpu> hehe, you bet!
21:18:03 <jsnx> jcreigh: yes
21:18:14 <ddarius> I.e. toList tree = toList' tree [] where toList' Empty = id; toList' (Branch l x r) = toList' l . (x:) . toList' r
21:18:19 <pastorn> ddarius: do you have an example somewhere? or is it hard to make... i don't think i get it
21:18:43 <qpu> jcreigh, jsnx thanks :]
21:19:17 <pastorn> toList' Empty = id -- nice one :p
21:20:19 <pastorn> ddarius: oh, so you pile up a lot of cons operations on []
21:20:22 <pastorn> nice :)
21:20:50 <oerjan> pastorn: you can use mappend and define a Foldable instance, then you get toList for free
21:21:07 <oerjan> it happens to be defined as toList = foldr (:) []
21:21:17 <oerjan> so it doesn't use (++)
21:21:48 <pastorn> oerjan: "mappend"?
21:21:58 <oerjan> @src Monoid
21:21:59 <lambdabot> class Monoid a where
21:21:59 <lambdabot>     mempty  :: a
21:21:59 <lambdabot>     mappend :: a -> a -> a
21:21:59 <lambdabot>     mconcat :: [a] -> a
21:22:29 <pastorn> yay! category theory :D
21:22:31 <oerjan> pastorn: Foldable is defined using monoids so you can use any associative operator
21:22:39 <ddarius> pastorn: That's just abstract algebra
21:23:08 <oerjan> and then other things are defined via them
21:23:15 <pastorn> i don't know too much about algebra yet... having my Modern Algebra course now after christmas
21:23:16 <ddarius> > take 10 $ (foldr (.) id $ map (:) [1..]) []
21:23:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:23:31 <pastorn> paralell with Advanced Functional Programming :)
21:24:36 <pastorn> map (:) [1..10]
21:24:40 <pastorn> > map (:) [1..10]
21:24:40 <lambdabot>  [<[Integer] -> [Integer]>,<[Integer] -> [Integer]>,<[Integer] -> [Integer]>,...
21:24:58 <pastorn> oh, right
21:25:09 <oerjan> pastorn: in fact the haddock for Data.Foldable contains a binary tree as example
21:25:43 <jsnx> > foldr (.) id $ map (:) [1..10]
21:25:44 <lambdabot>  <[Integer] -> [Integer]>
21:25:55 <jsnx> > foldr (.) id $ map (:) [1..10] []
21:25:55 <lambdabot>  Couldn't match expected type `[a1] -> [a -> a]'
21:26:13 <jsnx> > (foldr (.) id $ map (:) [1..10]) []
21:26:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:26:28 <jsnx> :t foldr (.) id
21:26:28 <lambdabot> forall a. [a -> a] -> a -> a
21:26:39 <pastorn> i think monoids will have to wait just a little while...
21:27:27 <jsnx> yeah, i need to watch some more catsters on youtube...
21:28:12 <ddarius> For data Tree a = Empty | Leaf a | Branch (Tree a) (Tree a) and given foldTree the difference is really cute.  The "bad" version is foldTree [] (:[]) (++) and the "good" version (modulo an apply) is foldTree id (:) (.)
21:29:07 <ddarius> pastorn: Monoids are very simple and you are already familiar with most important cases.
21:30:39 <pastorn> ddarius: "foldTree id (:) (.)" just makes me confused...
21:30:54 <oerjan> pastorn: that's not the monoid version
21:31:12 <oerjan> the haddock example is:
21:31:13 <oerjan>  instance Foldable Tree
21:31:13 <oerjan>     foldMap f Empty = mempty
21:31:13 <oerjan>     foldMap f (Leaf x) = f x
21:31:13 <oerjan>     foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
21:31:28 <oerjan> hm, missing where
21:31:59 <Valodim> so
21:32:04 <Valodim> I use getStdRandom (randomR (1, a))
21:32:09 <Valodim> and it returns 1 everytime
21:32:12 <oerjan> imagine those mappend's being generalized ++'s
21:32:15 <pastorn> oerjan: hey, is that monadic?
21:32:25 <Valodim> isn't getStdRandom supposed to work without seed?
21:32:27 <oerjan> pastorn: not much
21:32:41 <ddarius> By "not much" he means "not at all"
21:32:50 <pastorn> shouldn't "foldMap f (Leaf x) = f x" be " foldMap f (Leaf x) = Leaf (f x)"?
21:32:58 <ddarius> No.
21:33:00 <Valodim> (and yeah a /= 1, it's 20 to be exact)
21:33:02 <ddarius> :t foldMap
21:33:03 <lambdabot> Not in scope: `foldMap'
21:33:09 <oerjan> pastorn: no, Foldables don't generate new trees
21:33:09 <ddarius> @hoogle foldMap
21:33:10 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:33:10 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
21:33:18 <oerjan> you need Traversable for that
21:33:19 <pastorn> right! foldable
21:33:35 * pastorn smacks himself in the head with something heavy
21:34:02 * jsnx tazes pastorn
21:34:21 <jcreigh> don't taze me, bro!
21:35:27 <oerjan> Valodim: hm indeed it should
21:35:30 <jsnx> jcreigh: okay
21:35:47 <oerjan> you're not using setStdRandom anywhere are you?
21:36:20 <Valodim> nope
21:36:23 <Valodim> interpreted mode
21:37:03 <Valodim> http://hpaste.org/4638
21:37:54 <oerjan> Valodim: btw i think i mentioned that   randomRIO range  = getStdRandom (randomR range)
21:38:01 <Valodim> yeah
21:38:21 <Valodim> will stick to getStdRandom for now so I see the generator thing more
21:39:42 <Valodim> it actually returns [1]
21:39:47 <Valodim> where does the list come from...?
21:39:58 <Jomyoot> Does Haskell recursion blowup stack space?
21:40:11 <Jomyoot> let's say i have a function that must recurse 1M times or more
21:40:14 <oerjan> Jomyoot: sometimes
21:40:25 <Valodim> 1M times?
21:40:38 <dons> Jomyoot: tail recursion uses no stack space.
21:40:39 <Jomyoot> it must recurse through 1M roows of data
21:40:40 <oerjan> but it does have tail call optimization
21:40:45 <ricky_clarkson> > length [1..1000000]
21:40:46 <lambdabot>  1000000
21:40:52 <ricky_clarkson> That just recursed 1000000 times.
21:41:03 <oerjan> Valodim: er that's ... impossible?
21:41:06 <Jomyoot> so tail recursion does not blow up stack
21:41:11 <ricky_clarkson> Jomyoot: Right.
21:41:21 <Valodim> what is?
21:41:36 <dons> > let fac 0 = 1;  fac n = n * fac (n-1)  in fac 1000000
21:41:40 <oerjan> returning a list?
21:41:43 <lambdabot> Terminated
21:41:45 <dons> heh
21:42:07 <Valodim> DENG
21:42:15 <Valodim> I ran the wrong file
21:42:19 <oerjan> heh :)
21:42:43 <ricky_clarkson> > let fork x=fork x*fork x in fork 4
21:42:43 <lambdabot>  Exception: <<loop>>
21:43:00 <dons> no blackholes for you today, ricky_clarkson
21:43:13 <ricky_clarkson> @pl fork x=fork x*fork x
21:43:13 <lambdabot> fork = fix (ap =<< ((*) .))
21:43:15 <pastorn> > foldl' (*) 1 [1..10000000]
21:43:21 <lambdabot> Terminated
21:43:24 <pastorn> > foldl' (*) 1 [1..1000000]
21:43:30 <lambdabot> Terminated
21:43:34 <pastorn> aww... common!
21:43:49 <jaredj> > foldl' (*) 1 [1]
21:43:49 <dons> > foldl' (*) 1 [1..10000000] :: Int
21:43:50 <lambdabot>  1
21:43:52 <lambdabot>  0
21:43:54 <jaredj> yay
21:44:17 <oerjan> pastorn: i recall you can get it to go further with a binary splitup
21:44:30 <ricky_clarkson> dons: Haha.
21:44:34 <ddarius> oerjan: Indeed.
21:44:56 <ddarius> Do a tree instead of a sequence of multiplications.
21:45:15 <oerjan> since it is more efficient to multiply things of approximately the same size, i assume
21:45:47 <pastorn> who was it that was working on that haskell book?
21:46:00 <pastorn> (to be published by O'Reilly)
21:46:09 <ddarius> Real World Haskell?
21:46:14 <ddarius> @where realworldhaskell
21:46:15 <lambdabot> http://www.realworldhaskell.org/
21:46:25 <pastorn> heh, thanks ;)
21:47:44 <Valodim> so to apply any function (like +1) to a randomly generated number, I _need_ to use another <- term?
21:48:24 <oerjan> @let bfold op [x] = x; bfold op l = bfold op (pair op l) where pair op (x:y:r) = (op x y):pair op r; pair _ l = l
21:48:26 <lambdabot> Defined.
21:48:35 <Cin> random would imply side-effects and perhaps some kind of IO, so i'd think so, valodim
21:48:39 <pastorn> Valodim: yes, probably
21:48:43 <Valodim> that is annoying
21:48:48 <oerjan> > bfold (*) [1..1000000]
21:48:51 <pastorn> Valodim: unless you use >>=
21:48:55 <lambdabot> Terminated
21:48:58 <oerjan> > bfold (*) [1..100000]
21:48:59 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
21:49:18 <oerjan> > foldl' (*) 1 [1..100000]
21:49:23 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
21:49:27 <pastorn> Valodim: if a :: IO int then you can alwas do > a >>= return . (
21:49:33 <pastorn> Valodim: if a :: IO int then you can alwas do > a >>= return . (+1)
21:49:44 <ricky_clarkson> > length $ bfold (*) [1..1000000]
21:49:45 <lambdabot>   add an instance declaration for (Num [a])
21:49:45 <lambdabot>     In the expression: 1000000
21:49:59 <ricky_clarkson> > length $ show $ bfold (*) [1..1000000]
21:50:07 <lambdabot> Terminated
21:50:15 <pastorn> HA HA HA
21:50:15 <ricky_clarkson> > length $ show $ bfold (*) [1..100000]
21:50:16 <lambdabot>  456574
21:50:19 <pastorn> damn
21:50:21 <Valodim> sweet
21:50:24 <Valodim> that works
21:50:32 <ddarius> @quote foldb
21:50:32 <lambdabot> No quotes match.
21:50:43 <pastorn> Valodim: in ghci/hugs, do :t (>>=)
21:50:56 <oerjan> Valodim: happens to be liftM (+1) a
21:51:01 <pastorn> Valodim: also, :t return
21:51:21 <oerjan> @src liftM
21:51:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:51:39 <Valodim> yeah I used my first monad just today so...
21:51:42 <Valodim> babystep, babystep :)
21:51:51 <oerjan> > foldl' (*) 1 [1..200000]
21:51:58 <lambdabot> Terminated
21:52:08 <oerjan> > bfold (*) [1..200000]
21:52:11 <lambdabot>  1420225345470314404966946333682305976089965356746401622696224744629226778516...
21:52:31 <oerjan> it goes a bit longer but not _that_ much
21:52:48 <dons> cute
21:55:53 <Valodim> ah, I see how return . (+1) looks nicer than (\a -> return (a+1)), sweet
21:56:23 <pastorn> oerjan: ok, i'm looking at bfold now... i don't quite get it yet, but it lookse REALLY cool :D
21:57:33 <ddarius> :t \m -> m >>= return . (+1)
21:57:34 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a -> m a
21:57:41 <ddarius> :t liftM (+1)
21:57:41 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1
21:58:00 <pastorn> @type liftM
21:58:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:58:02 <oerjan> pastorn: it essentially just iterates the pair function until the result list has size 1
21:58:46 <pastorn> pair _ l = l -- why do you call it L and R in the other case?
21:58:47 <ddarius> I wonder...
21:59:04 <pastorn> how am i "supposed to" think/read this?
21:59:10 <oerjan> pastorn: um l for list, r for rest
21:59:17 <pastorn> heh
21:59:40 <oerjan> i suppose the laziness helps the iteration too
21:59:52 <Valodim> what would be the best way of getting a list of 1000 random vars?
21:59:53 <Valodim> (not using possibly available built-in functions for just that purpose)
22:00:13 <pastorn> sequence is good
22:00:14 <ddarius> > let f :: Show a => [a] -> String; f [x] = show x; f xs = f (pairUp xs) where pairUp (x:y:xs) = (x,y):pairUp xs in f [0..7]
22:00:15 <Valodim> replicate num $ rnd
22:00:15 <Valodim> doesn't work obviously
22:00:15 <lambdabot>   Non-exhaustive patterns in function pairUp
22:00:21 <pastorn> @type sequence
22:00:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:00:23 <oerjan> Valodim: replicateM
22:00:33 <Valodim> aah
22:00:39 <ddarius> > let f :: Show a => [a] -> String; f [x] = show x; f xs = f (pairUp xs) where pairUp (x:y:xs) = (x,y):pairUp xs; pairUp xs = xs in f [0..7]
22:00:40 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t)
22:00:40 <lambdabot>       Expec...
22:01:25 <ddarius> > let f :: Show a => [a] -> String; f [x] = show x; f xs = f (pairUp xs) where pairUp (x:y:xs) = (x,y):pairUp xs; pairUp xs = [] in f [0..7]
22:01:25 <lambdabot>  "(((0,1),(2,3)),((4,5),(6,7)))"
22:01:29 <ddarius> Sweet.
22:01:38 <ddarius> Go go polymorphic recursion.
22:02:12 <pastorn> Valodim: pm
22:02:35 <Valodim> hm?
22:02:39 <ddarius> :t randoms
22:02:40 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
22:03:11 <pastorn> Valodim: private message/query opened...
22:03:22 <wy> Do I need to set some environment variable when ghc 6.8.2 is installed in user directory?
22:03:42 <oerjan> pastorn: you're not registered
22:03:51 <Valodim> didn't get anything
22:03:55 <pastorn> oh... stupid freenode
22:03:57 <ddarius> @let mapPairs f (x:y:xs) = f x y : xs; mapPairs f xs = []
22:03:58 <lambdabot> Defined.
22:04:10 <wy> It seems not able to find the gtk2hs I just compiled
22:04:51 <ddarius> > let f :: Show a => [a] -> String; f [x] = show x; f xs = f . mapPairs (,) $ xs in f [0..15]
22:04:52 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
22:04:52 <lambdabot>       Expec...
22:05:17 <ddarius> :t mapPairs
22:05:18 <lambdabot> Not in scope: `mapPairs'
22:05:22 <pastorn> ddarius: what are you cooking?
22:05:40 <oerjan> > [0,mapPairs]
22:05:41 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> [a] -> [a]))
22:05:42 <lambdabot>   ...
22:05:51 <oerjan> > [(),mapPairs]
22:05:52 <lambdabot>  Couldn't match expected type `()'
22:05:52 <ddarius> Oh
22:05:55 <ddarius> @undefine
22:05:56 <lambdabot> Undefined.
22:06:04 <ddarius> @let mapPairs f (x:y:xs) = f x y : mapPairs f xs; mapPairs f xs = []
22:06:05 <lambdabot> Defined.
22:06:19 <Valodim> huh, my nick is actually registered here since almost 2 years
22:06:47 <oerjan> Valodim: if it hasn't been used for 60 days you can snatch it
22:07:19 <Valodim> not been used for 1 year 30 weeks
22:07:26 <Valodim> I wonder what password I could have used back then
22:07:43 <Valodim> name's unique so it's not been taken by someone else... no idea what chan I visited on this network before tho
22:07:57 <oerjan> oh it was yourself
22:08:29 <Valodim> I would be surprised if it wasn't, because in that case someone would have actually stolen my name ;)
22:08:32 <Valodim> *snatch*
22:08:44 <pastorn> there! registered!!
22:09:05 * ddarius hasn't registered for almost five years.
22:09:31 <ddarius> Actually, almost six.
22:09:50 <oerjan> Valodim: i don't know what Valodim means, for all i know it could be a common word in some slavic language
22:09:52 * pastorn DDoses ddarius to do /nick ddarius;msg nickserv REGISTER topsecretpasswordwithlotsofannoyingspecialcharacters
22:10:02 <Valodim> true
22:10:19 <pastorn> Valodim: try to send a private message to me
22:10:24 <Valodim> I did
22:10:31 <Valodim> but I'm not registered :P
22:10:37 <pastorn> epic FAIL
22:10:40 <Valodim> how do I snatch the nick if not used for 60 days?
22:10:50 <Valodim> can't find anything in /ns help
22:10:53 <oerjan> Valodim: find a freenode staff
22:10:56 <pastorn> do /nick valodim
22:11:05 <Valodim> hah
22:11:23 <pastorn> what? is that so horrible?
22:11:31 <wy> oerjan: Do you use Gtk2Hs?
22:11:35 <oerjan> wy: no
22:11:46 <wy> ... whoever use it?
22:11:48 <Valodim> wait, nicks are case sensitive?
22:12:05 <oerjan> Valodim: cannot imagine it
22:12:18 <pastorn> doesn't hurt to try...
22:12:33 <oerjan> Valodim: i think joining #freenode and asking is the simplest way...
22:12:44 <oerjan> to find a staff
22:13:25 <Valodim> yep
22:13:48 <Valodim> my name already is valodim and ns didn't rename me or anything... does my irc client just not show this correctly?
22:13:55 <Valodim> anyways /nick Valodim has no effect (obviously)
22:16:52 <pastorn> do a backup, /nick valodim_ as http://freenode.net/faq.shtml#nicksetup recomends
22:16:53 <lambdabot> Title: 69a freenode: frequently-asked questions
22:17:10 <Valodim> done already
22:17:24 <Valodim> registered
22:18:53 <stacdab> hello all
22:18:55 <stacdab> new here
22:18:59 <Valodim> sup
22:19:18 <stacdab> wide awake in middle of night, thought i'd lurk here.
22:19:42 <stacdab> been trying haskell for a while now, hoped to learn something while i'm not sleeping.
22:19:51 <pastorn> heh
22:20:05 <oerjan> you've been learning haskell in your sleep? :D
22:20:18 <stacdab> ha!  if only.
22:22:33 <pastorn> who was it that was said to absorb the knowledge of his books by using them as pillows?
22:27:22 <oerjan> http://justsomegibberish.blogspot.com/2006/10/of-book-brain-judgmental-transfer-bjt.html
22:27:23 <lambdabot> Title: Currytan: Of Book-Brain Judgmental Transfer (BJT), http://tinyurl.com/2doggm
22:30:33 <pastorn> hahaha
22:30:37 <pastorn> oerjan: great!
22:31:24 * oerjan also recalls something from a Victor Borge show
22:33:20 <oerjan> he had some success learning Japanese from cassette tapes while sleeping.  Unfortunately he could only talk it while fast asleep.
22:40:23 <davidL> @index (#)
22:40:23 <lambdabot> bzzt
22:58:14 <Valodim> 8am - bed time :)
22:58:25 <Valodim> later guys, thanks for your help :)
23:06:08 <sclv> there's the steven wright gag. "I was going on a trip to mexico, but needed to learn the language. So I got one of those learn while you sleep albums. The record had a skip in it. When I woke up I could only stutter in spanish."
23:27:05 <wolverian> hm, is searchpath a kludge until cabal-install works properly?
23:28:12 <wolverian> the happs slides link on the homepage news is a 404
23:29:05 <wolverian> found them via blip.tv
23:42:16 <pastorn> ddarius: you still there?
