00:00:30 <oerjan> for the beginning i found a nice trick the other day
00:00:35 <wy> But my skill of picture-mode is not so good. Haven't figured out how to move a block yet
00:00:53 <oerjan> > groupBy (const (/= "gi")) ["a",".","gi","1qf","1qf1q","111","gi"]
00:00:56 <lambdabot>  [["a","."],["gi","1qf","1qf1q","111"],["gi"]]
00:10:32 <oerjan> > evalStateT (replicateM 3 $ StateT $ map (head &&& tail) . init . tails) "abcdef"
00:10:35 <lambdabot>  ["abc","abd","abe","abf","acd","ace","acf","ade","adf","aef","bcd","bce","bc...
00:13:47 <hpaste>  wy pasted "notes on foldr" at http://hpaste.org/4676
00:14:39 <wy> dufflebunk: I pasted my partial notes written so far
00:15:58 <EvilSporkMan> oerjan: is that k-combinations?
00:16:08 <oerjan> EvilSporkMan: that was the intent
00:16:31 <EvilSporkMan> oerjan: i can't make head or tail of it, but i see you have both in there ;)
00:16:40 <oerjan> :D
00:17:20 <oerjan> state transformed list monad
00:17:37 <hpaste>  EvilSporkMan pasted "recursive k-combinations" at http://hpaste.org/4677
00:18:03 <EvilSporkMan> i don't like the multiple base cases in there
00:19:07 <EvilSporkMan> as per usual, if i had written combinations 0 _ = [[]] it would've worked
00:19:37 <EvilSporkMan> whoops, I stand corrected.
00:20:12 <oerjan> well i say 0 _ -> [[]] is more natural
00:20:49 <oerjan> > evalStateT (replicateM 0 $ StateT $ map (head &&& tail) . init . tails) "abcdef"
00:20:52 <lambdabot>  [""]
00:21:22 <EvilSporkMan> i liked [] better, but then i had to insert a base step for 1 _
00:21:40 <EvilSporkMan> and with [[]] it doesn't work right
00:21:47 <oerjan> why not?
00:22:08 <EvilSporkMan> combinations 1 "abc" is ["a", "b", "c", ""]
00:25:05 <oerjan> you have combinations 1 [] = [[]] for some reason?
00:25:23 <oerjan> (should be [])
00:26:18 <EvilSporkMan> oerjan: as originally written and pasted, combinations 1 [] = []
00:26:59 <EvilSporkMan> and if combinations 0 [] = [[]], why isn't combinations _ [] = [[]]?
00:27:34 <EvilSporkMan> "there are no ways to make a 0-combination" vs. "there is one 0-combination and it is a combination with nothing in it"...i think this is philosophical
00:28:24 <oerjan> there is _one_ way to make a 0-combination.
00:28:26 <oerjan> [[]]
00:28:51 <oerjan> there are however _no_ ways to pick an element out of an empty list, so not > 0 combinations for it
00:29:24 <oerjan> note that all the elements of combinations n l have n elements
00:29:53 <oerjan> so combinations 1 [] = [[]] is not allowed because [] does not have 1 element
00:31:58 <hpaste>  oerjan annotated "recursive k-combinations" with "simplified" at http://hpaste.org/4677#a1
00:32:33 <wy> Is there a way to turn on line wrapping when I split the emacs window horizontally so that haskell inf-mode is on the right of my code?
00:33:53 <cjb> wy: can you take a screenshot showing the problem?  I'm an emacs user, but I'm having trouble working out what you need.
00:34:59 <wy> cjb: C-x 3 will split your window that way and the line-wrapping is turned off by default
00:35:19 <Korollary> wy: truncate-partial-width-windows nil
00:35:51 <cjb> sounds like Korollary has it.  :)
00:37:23 <wy> Korollary: that works! That will make it more fun because I see more portion of my code :-)
00:38:17 <wy> Korollary: Maybe you also know how to use another frame as inf-haskell buffer?
00:38:45 <sclv> @ty if'
00:38:47 <lambdabot> Not in scope: `if''
00:40:59 <oerjan> sclv: if' is just a convention used by @pl because it has no other way of handling if-then-else
00:41:11 <oerjan> if' i t e = if i then t else e
00:41:42 <oerjan> others swear to bool, which is a catamorphism:
00:41:46 <sclv> I thought it was something like that. Better to use the real one in my code though?
00:41:52 <oerjan> bool t e i = if i then t else e
00:42:34 <sclv> i.e. how to prettify this:
00:42:40 <oerjan> well if you insist on being pointfree you have to replace if then else with something
00:42:42 <sclv> @pl (\neg pr -> if neg (isSet pr) then act else const "")
00:42:43 <lambdabot> flip flip (const []) . flip flip act . (if' .) . (. isSet)
00:43:38 <sclv> I should stop insisting on being pointfree in this case -- I just have three functions where "\neg pr -> if neg (isSet pr) then act" is the same and I want to abstract it out.
00:44:09 <EvilSporkMan> oerjan: you win the combinations prize :D
00:44:32 <oerjan> :)
00:45:45 <sclv> some code just... doesn't get better.
00:47:14 <hpaste>  sclv pasted "U.g.l.y. ain't got no alibi" at http://hpaste.org/4678
00:48:11 <snhmib> does haskell have something like the (cond (...)) statement in lisp/scheme?
00:51:53 <oerjan> @pl \neg pr -> bool act (const "") (neg (isSet pr))
00:51:54 <lambdabot> (bool act (const []) .) . (. isSet)
00:53:04 <oerjan> snhmib: you can get something similar with case () of () | cond1 -> ... | cond2 -> ...
00:53:33 <oerjan> the ()'s are just placeholders really, you really are just using the guard part
00:55:53 <oerjan> sclv: anyway, seems you just want a helper function f act orelse = \neg pr -> ...
00:56:04 <skew> also (snd . filter fst) [(cond1,e1),(cond2,e2),...,(True,default)]
00:56:15 <sclv> I'm trying to fold into my isSet function now.
00:59:12 <hpaste>  sclv annotated "U.g.l.y. ain't got no alibi" with "slightly better" at http://hpaste.org/4678#a1
01:00:17 <sclv> It's frustrating to me that it's so hard to get away from do notation when you've got lots of <- assignations going on.
01:01:52 <sclv> I'd like some idiom to turn "a<-foo; b<-bar" into "(a,b) <- CombinatorHere foo bar
01:02:12 <sclv> is it as simple as liftM(,) ?
01:02:19 <oerjan> liftM2
01:04:32 <sclv> nice. thx.
01:14:25 <_roconnor> @type liftM2
01:14:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:14:53 <quicksilver> sclv: if I'm doing that a lot, I sometimes define (<,>) = liftM2 (,)
01:15:04 <quicksilver> sclv: then you can just write (a,b) <- foo <,> bar
01:15:08 <quicksilver> sclv: which is quite pretty
01:15:15 <_roconnor> (a,b) <- (,) <$> foo <*> bar
01:15:21 <_roconnor> not really as nice
01:15:32 <quicksilver> no
01:15:41 <quicksilver> the applicative notation doesn't scale well to infix operators.
01:15:52 <quicksilver> it (ab)uses the infix layer itself.
01:16:13 <sclv> that's a nice idiom
01:16:34 <sclv> some more factoring tomorrow after some zzs should clean that code up more.
01:16:45 <roconnor> sclv: soon you will have 1 line
01:16:46 <sclv> frustrating when the density just drops through the floor in one section.
01:16:53 <quicksilver> as an informal convention I tend to define <~~> for liftM2 (~~), for any operator ~~
01:17:03 <quicksilver> btu I only bother if I'm using it more than a few times
01:17:15 <roconnor> @type liftM2 <*>
01:17:17 <lambdabot> parse error (possibly incorrect indentation)
01:17:23 <roconnor> @type liftM2 (<*>)
01:17:25 <lambdabot> forall (f :: * -> *) a b (m :: * -> *). (Applicative f, Monad m) => m (f (a -> b)) -> m (f a) -> m (f b)
01:17:32 <oerjan> actually <,> is not legal, or is it?
01:18:00 <oerjan> :t let x <,> y = liftM2 (,) x y in (<,>)
01:18:01 <lambdabot> parse error on input `,'
01:18:17 <roconnor> :(
01:18:20 <quicksilver> bah :(
01:18:23 <quicksilver> you're right, of course
01:18:24 <sclv> :t let (<,>) a b = liftM2 a b in (<,>)
01:18:25 <lambdabot> parse error on input `,'
01:18:27 <quicksilver> I wonder what I did use
01:18:30 <quicksilver> <.> probably
01:18:45 <roconnor> :t let x </\> y = liftM2 (,) x y in (</\>)
01:18:46 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => m a1 -> m a2 -> m (a1, a2)
01:19:04 <roconnor>  /\ meaning conjunction
01:19:07 <wy> Is "Introduction to Functional Programming using Haskell (2nd Edition)" much different from the first edition?
01:19:23 <roconnor> </\> kinda looks like some sort of space ship
01:19:28 <sclv> roconnor: I thought it was </\> meaning "alien spaceship"
01:19:38 <roconnor> :D
01:20:03 <quicksilver> <=> is the spaceship operator, traditional
01:20:12 <quicksilver> maybe </\> is a more advanced model
01:20:35 <oerjan> <=> spaceships are _so_ last century
01:20:41 <sclv> <===/\===> -- the imperial battlecruiser operator
01:20:47 <wy> wow! spaceships
01:21:20 <wy> Is >>= time machine operator?
01:21:39 <oerjan> depends whether you are going forward or backward
01:21:43 <roconnor> actually mdo is the time machine operator :)
01:21:48 <sclv> the battlecruiser has precedence infixr 11
01:22:00 <oerjan> =<< for all your backward time travel needs
01:22:12 <roconnor> no seriously
01:22:16 <wy> I'd like to be back to the future
01:22:43 <wy> :t =<<
01:22:45 <lambdabot> parse error on input `=<<'
01:22:50 <wy> :t (=<<)
01:22:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
01:22:52 <sclv> @go haskell "circular programming"
01:22:53 <lambdabot> http://calculist.blogspot.com/2005/07/circular-programming-in-haskell.html
01:22:53 <lambdabot> Title: The Little Calculist: Circular programming in Haskell
01:23:10 <wy> @src (=<<)
01:23:11 <lambdabot> f =<< x = x >>= f
01:23:54 <wy> I've finished my notes on foldr. Do you want to have a look?
01:24:15 <sclv> and that's the "lucy in the mirror" definition.
01:26:15 <roconnor> @src (>>=)
01:26:16 <lambdabot> Source not found. stty: unknown mode: doofus
01:26:45 <oerjan> @src Monad
01:26:46 <lambdabot> class  Monad m  where
01:26:46 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
01:26:46 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
01:26:46 <lambdabot>     return      :: a -> m a
01:26:46 <lambdabot>     fail        :: String -> m a
01:31:54 <wy> sclv: Interesting!
01:37:13 <wy> @src [] (>>=)
01:37:13 <lambdabot> m >>= k     = foldr ((++) . k) [] m
01:38:43 <oerjan> aka flip concatMap
01:39:40 <Leimy> Maybe it's because it's really late and I'm tired but I can't for the life of me figure out how to "show" the contents of a Data.HashTable...
01:40:00 <wy> @src concatMap
01:40:00 <lambdabot> concatMap f = foldr ((++) . f) []
01:40:25 <quicksilver> Leimy: Data.HashTable isn't often recommended, by the way
01:40:26 <oerjan> Leimy: toList perhaps
01:40:45 <wy> makes sense
01:40:47 <Leimy> quicksilver: yeah, I found that out after I used it ... a lot in this one piece of code :-)
01:41:04 <Leimy> oerjan: toList gets me an IO list... which doesn't appear to be easy to show.
01:41:07 <quicksilver> Leimy: it can't be Show-able because it doesn't have access to its own contents without the IO monad.
01:41:14 <quicksilver> you'll have to use IO
01:41:28 <quicksilver> Hashtable is like an opaque pointer to a memory location
01:41:34 <quicksilver> it can't even read itself without the IO monads help
01:41:35 <oerjan> Leimy: toList ht >>= print
01:41:39 <wy> Is there a design of an architecture suitable for FP?
01:42:07 <sclv> x86?
01:42:44 <oerjan> wy: i recall something FPGA mentioned
01:42:53 <wy> Because I often heard people say that the use of mutable arrays and hashtable etc is mainly due to the current architecture
01:43:45 <quicksilver> wy: there has definitely been work on that subject. There were lisp machines, for example.
01:43:57 <quicksilver> However I'm not up to date. I have no idea what has been published recently.
01:43:58 <wy> So I'm wondering what do we implement the fastest algorithms with some architecture that's totally suitable for the alternative data structures
01:46:11 <Leimy> quicksilver: Data.Map is preferred then?
01:46:34 <sclv> as is, on, e.g. the languages shootout, the places where arrays and hashtables are necessary have more to do with the algorithms that the contest mandates using than what would actually make sense for any given task
01:46:39 <oerjan> wy: i recall a discussion about attempts to make specific FP CPUs.  the problem was that by the time the chip reaches the market, the mainstream CPUs have improved so much they aren't even best at FP...
01:46:48 <quicksilver> Leimy: yes
01:47:02 <quicksilver> Leimy: much more pleasant interface, performance is apparently as good or better in practice anyway
01:47:07 <oerjan> i.e. you just cannot compete with the big guys :(
01:47:08 <quicksilver> Leimy: (I haven't tested that claim myself)
01:47:19 <sclv> multicore machines are by definition a huge win for fp though, as i understand it.
01:47:22 <Leimy> quicksilver: Hmmm, interesting.  I'll chcek it out.
01:47:31 <rhz> Is there some way to get a stream of data from an internal microphone into a Haskell program?
01:47:35 <Leimy> sclv: and the other way around
01:47:50 <Leimy> stateless programming in general makes it easier to write concurrent programs
01:48:52 <sclv> but also, for fp, you just want allocation and gc on small structures to be cheap.
01:48:54 <wy> We have time machines ;-)
01:49:28 <sclv> but as lots of other languages move towards generating similar memory profiles this isn't just an fp issue.
01:55:09 <wy> Yeah. I finally understand why concatMap is defined using foldr as so, using the new thing I learned about foldr :-)
01:58:36 <quicksilver> wy: what reason for that do you understand?
01:59:32 <wy> quicksilver: Just by transform the recursion on lists into foldr
01:59:52 <Leimy> oerjan and quicksilver thanks!  I've managed to get HashMap to do what I want.  Got the tricky bits of a markov chain generator done with it... it's not as clean as another one I saw so far, but I think it'll do :-)
02:01:00 <quicksilver> wy: why do you believe transforming recursion into foldr is a good thing?
02:01:40 <wy> quicksilver: I didn't say it's a good thing. But you reminded me :-)
02:01:51 <quicksilver> wy: I am probing you didactically, I hope it doesn't offend :)
02:01:54 <wy> quicksilver: It makes programs easier to understand
02:02:07 <quicksilver> wy: as far as I know, the reason that concatMap is defined using foldr
02:02:12 <wy> @src concatMap
02:02:13 <lambdabot> concatMap f = foldr ((++) . f) []
02:02:14 <quicksilver> is that there are special optimisation rules for foldr
02:02:26 <wy> quicksilver: really?
02:02:27 <quicksilver> and it's important that they kick in
02:02:28 <quicksilver> yup
02:02:42 <quicksilver> I mean, maybe we'd define it that way anyway.
02:02:49 <quicksilver> but build/foldr fusion is very important
02:02:57 <quicksilver> it's what makes list comprehensions efficient.
02:03:05 <Leimy> quicksilver: huh... I always thought one would prefer foldl due to the potential for tail recursion
02:03:10 <quicksilver> nope
02:03:18 <quicksilver> tail recursion is not as important in a lazy language.
02:03:25 <quicksilver> It can even be a bad thing in some cases.
02:03:27 <Leimy> Yeah, I keep forgetting that :-)
02:03:42 <Leimy> The laziness of haskell always gets me by surprise.
02:03:45 <qebab> I'm too used to scheme to ignore tail recursion
02:03:49 <qebab> yeah, me too
02:04:00 <wy> Is it ever possible to define those list operations in terms of foldl?
02:04:20 <Leimy> Like there's some functions that appear to load an entire file's contents but really are lazilly doing so on demand
02:04:30 <Leimy> their cost is difficult to judge up front by just looking.
02:04:39 <qebab> indeed
02:04:53 <Leimy> still, I think that's why I find Haskell intriguing :-)
02:05:19 <wy> I'm still wondering why Haskell makes the denotational semantic I learned long ago becomes alive
02:05:41 <wy> maybe because of laziness?
02:06:28 <quicksilver> wy: for finite lists, foldl is "equivalent" to foldr
02:06:37 <wy> We learned some domain constructions, bottom, CPOs... but those didn't make much sense without a real language supporting them
02:06:38 <quicksilver> wy: in the sense that you can write any function with one in terms of the other
02:07:00 <quicksilver> wy: foldr f = reverse . foldl (flip f) . reverse
02:07:17 <Leimy> flip and (.) are quickly becoming friends of mine :-)
02:07:30 <quicksilver> the interesting point is that infinite list case gives you a guide to efficiency
02:07:45 <quicksilver> a function working on infinite lists is very closely related to it working in constant space on long finite lists
02:08:53 <wy> map2 f = foldr ((:) . f) []
02:09:56 <wy> I see why this definition of map works for infinite lists, because (:) is lazy, so map2 can produce the head of the list before everything is evaluated
02:10:31 <wy> quicksilver: So how do you think about the efficiency of foldr?
02:14:38 <wy> It's interesting to notice that a lazy language can actually produces answers much more earlier than a strict language
02:27:50 <desp> So, bootstrapping GHC 6.8.2 appears to require more than 1 GB of memory...
02:29:43 * desegnis is thankful for having started with a precompiled ghc 6.6 then.
02:31:13 <desp> It bus errored twice.
02:31:27 <desp> Thankfully, someone else compiled it for me.
02:33:16 <wy> @src length
02:33:17 <lambdabot> Source not found. Sorry.
02:33:32 <wy> @src [] length
02:33:32 <lambdabot> Source not found. Where did you learn to type?
02:33:46 <wy> bad bot
02:34:07 <wy> @src [] Prelude.length
02:34:07 <lambdabot> Source not found.
02:34:15 <oerjan> length           :: [a] -> Int
02:34:15 <oerjan> length            = foldl' (\n _ -> n + 1) 0
02:35:00 <oerjan> (sayeth hugs)
02:35:33 <wy> But what I found in the prelude is quite different
02:35:36 <wy> length l                =  len l 0#
02:35:36 <wy>   where
02:35:36 <wy>     len :: [a] -> Int# -> Int
02:35:36 <wy>     len []     a# = I# a#
02:35:36 <wy>     len (_:xs) a# = len xs (a# +# 1#)
02:35:48 <oerjan> the ghc version.
02:36:31 <wy> @src foldl'
02:36:35 <lambdabot> foldl' f a []     = a
02:36:35 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:36:35 <oerjan> length           :: [a] -> Int
02:36:35 <oerjan> length []        =  0
02:36:35 <oerjan> length (_:l)     =  1 + length l
02:36:39 <oerjan> ^^ report version
02:37:41 <wy> What does those # mean?
02:38:00 <oerjan> unboxed types?
02:38:16 <oerjan> i am not sure the a# is necessary
02:38:48 <xerox> It does tail recursion
02:38:53 <oerjan> but the rest are internal ghc unboxed functions
02:39:02 <quicksilver> the a# is just documentation, I think
02:39:10 <quicksilver> i.e. following a convention to put # in the names of unboxed variables.
02:40:07 <wy> quicksilver: Why can't I use # as an operator?
02:40:08 <quicksilver> but yes, that version is just designed to interoperate well with GHC optimisations.
02:40:25 <oerjan> > let a # b = a + b in 1 # 1
02:40:28 <lambdabot>  2
02:40:50 <oerjan> # is completely legal in operators
02:41:17 <oerjan> it's the use in identifiers that ghc modifies
02:41:22 <quicksilver> yes, in fact # is an operator char and as such ILLEGAL in identifiers
02:41:26 <quicksilver> but ghc is a bad bad thing
02:41:30 <quicksilver> and it breaks the law! :)
02:42:52 <wy> I can define a # b = a + b successfully, but typing 1 # 3 into the inf-haskell doens't work
02:43:04 <desegnis> If ghc would be like gcc, then Int# would probably be ___Int___. It's good them breaking the law.
02:43:57 <wy> ah stupid me. I forgot to add ">" to the front of my lhs
02:44:02 <quicksilver> wy: works for me :)
02:44:42 <wy> It seems that hpaste doesn't work very well with lhs files
03:33:16 <fons> hi all
03:33:21 <roconnor> hi
03:35:09 <fons> I have another question regarding GHC extensions
03:35:51 <fons> I'm using ScopedTypevariables
03:36:02 <fons> and this function
03:36:21 <fons> sndSY :: forall a b. (Typeable a, Typeable b) => Signal (a, b) -> Signal b
03:36:42 <fons> without -fglasgow-exts GHC gives this error
03:37:14 <fons> When matching the contexts of the signatures for ...
03:37:19 <fons> The signature contexts in a mutually recursive group should all be identical
03:37:44 <fons> I hve no idea of what extsion is being provided by -fglasgow-exts which "fixes" the error
03:38:52 <hpaste>  fons pasted "signature contexts in a mutually recursive group should all be identical" at http://hpaste.org/4679
03:39:04 <fons> the full error is pasted above
03:39:48 <fons> providing -fglasgow-exts hushes ghc, I'm just wondering what concrete extension is being used
03:41:08 <quicksilver> that's odd
03:41:18 <wolverian> I think I saw that reported earlier too
03:41:23 <quicksilver> can you paste a bit more of the code?
03:41:27 <wolverian> and it was a bug. or something related to ScopedTypeVariables anyway
03:41:30 <quicksilver> at least, all the type sigs in question
03:42:35 <quicksilver> fons: ah. try -XRelaxedPolyRec
03:43:32 <shag> when installing ghc-6.8.2 on debian from a .deb package, shouldn't the parsec library be included?
03:44:40 <fons> quicksilver: ok, it worked, can someone explain me why is the extension needed?
03:45:04 <quicksilver> fons: 8.7.7. Generalised typing of mutually recursive bindings
03:45:11 <fons> thanks quicksilver
03:45:12 <quicksilver> within http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
03:45:14 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
03:48:13 <fons> OK, couldn't understand it that well, but it helped :)
03:48:15 <FunctorSalad> am I missing something or is "instance Monad Maybe where ..." not really the same kind of thing as "instance Num Int where ..." at all? Maybe is a type constructor, but Int is a type?
03:49:17 <desegnis> shag: ghc moved Parsec into an extralibs tarball, maybe there's a related package for debian?
03:49:33 <shag> desegnis: ok, i will check. thanks!
03:50:29 <desegnis> In the debian tradition there may even be several packages for each of the »extralibs« libraries.
03:51:18 <desegnis> FunctorSalad: That's right. Specifically, Int is of kind * while Maybe is of kind * -> *.
03:51:51 <FunctorSalad> desegnis: "kinds" are something like types of types I suppose?
03:52:07 <FunctorSalad> (I was using "kind" in the natural-language sense ;))
03:52:29 <desegnis> Right, those stars just say how many arguments the type constructor takes (one for Maybe)
03:52:31 <desegnis> ;)
03:53:12 <desegnis> And the Monad class actually requires its instances to be of kind * -> *, because it talks about m a (where m is a Monad)
03:53:41 <quicksilver> fons: summary: there isn't a really good reason. It was just a simplistic type inference setup and there is a more complex but better one which allows it.
03:53:53 <FunctorSalad> desegnis: I see, thanks
03:54:04 <scook0> @bot
03:54:04 <lambdabot> :)
03:54:25 <quicksilver> fons: there are problems with correctly type checking mutually recursive functions which are class polymorphic and recursively call each other with less polymorphism.
03:54:37 <FunctorSalad> but this kind system is not a special case of the type system, since types are not first-class, right?
03:54:51 <quicksilver> right
03:54:58 <quicksilver> although informally it's obviously a similar notion
03:55:02 <quicksilver> it's much much simpler though
03:55:13 <quicksilver> in plain haskell98, (->) and * are the only kind-constructors.
03:55:13 <FunctorSalad> quicksilver: yes. this was confusing me a lot
03:56:02 <desegnis> Hm, so we could as well write Int :: 0; Maybe :: 1.
03:56:05 <EvilTerran> isn't there **, *** etc, also?
03:56:12 <EvilTerran> or am i confused?
03:56:27 <quicksilver> EvilTerran: they're not haskell98
03:56:34 <EvilTerran> ?kind StateT
03:56:36 <lambdabot> * -> (* -> *) -> * -> *
03:56:37 <desegnis> (oh wait, that doesn't give us parentheses)
03:56:44 <EvilTerran> desegnis, exactly
03:56:51 <desegnis> yea, thanks
03:56:51 <quicksilver> desegnis: yeah, it's a bit more subtle than that
03:56:58 <quicksilver> desegnis: it's binary trees
03:57:06 <EvilTerran> quicksilver, ahh. k.
03:57:16 <quicksilver> EvilTerran: GHC has two kinds to help understand unboxing
03:57:24 <desegnis> quicksilver, I see
03:57:30 <EvilTerran> # and ?, yeah
03:57:34 <quicksilver> EvilTerran: but they are strictly an implementation thing, they don't make the language any more expressive in the conventional sense
03:58:12 <quicksilver> three, on reflection
03:58:16 <quicksilver> ?? to, isn't it?
03:58:17 <lambdabot> Plugin `compose' failed with: Unknown command: ""
03:58:56 <EvilTerran> yeah, i think so
04:01:50 <FunctorSalad> what is the term for things that have kinds then? (types and type constructors)
04:02:19 <jz87> why does cabal-install ask for cabal 1.3.2 when the latest on the website is 1.2.3
04:02:30 <desegnis> FunctorSalad, I think  type  is the general term.
04:02:40 <FunctorSalad> desegnis: ah, ok
04:03:31 <quicksilver> FunctorSalad: yes, "type" is abused somewhat
04:03:47 <desegnis> The type of a value is never a type constructor, which makes things a little foggy...
04:03:47 <quicksilver> FunctorSalad: sometimes it means "thing of kind *" and sometimes it means "thing of any kind" :)
04:07:53 <fons> thanks for the explanation quicksilver
04:10:18 <FunctorSalad> I suppose a thing of * -> * is a functor from Hask to Hask
04:10:56 <quicksilver> not necessarily
04:11:02 <quicksilver> if it is, you should make it an instance of Functor :)
04:11:16 <quicksilver> but type constructors don't have to be functorial.
04:12:00 * benny99 adds an x-file theme-sound here
04:13:12 <FunctorSalad> quicksilver: silly me, yes they don't even need to have an action on morphisms... but are there any examples where they have an action on morphisms but aren't functorial?
04:13:34 <quicksilver> FunctorSalad: it's not very hard to come up with contravariant ones
04:13:43 <quicksilver> FunctorSalad: (->) is contravariant on one parameter
04:15:00 <FunctorSalad> the hard part is remembering which one ;) (but by now I'm pretty sure it's the left one ;))
04:15:16 <FunctorSalad> (which is of course the right one when composing functions)
04:20:40 <jz87> what is the latest version of cabal?
04:20:57 <FunctorSalad> ok, so Functor is a type class for types of kind * -> *, and if (Functor a), then every type a b needs to have a method fmap of type (b->b) -> ((a b) -> (a b)) ?
04:23:34 <EvilTerran> ?src Functor
04:23:34 <lambdabot> class  Functor f  where
04:23:34 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
04:23:41 <EvilTerran> close
04:23:54 <FunctorSalad> :)
04:24:22 <Saizan> jz87: the one on http://darcs.haskell.org/cabal
04:24:23 <lambdabot> Title: Index of /cabal
04:24:27 <wolverian> isn't that the same thing, if you squint enough? :p
04:24:36 <wolverian> oh, sorry, (a -> b).
04:24:42 <EvilTerran> not quite. (a->b) rather than (b->b), yeah.
04:25:38 <jz87> hmm
04:25:43 <jz87> that's weird
04:25:48 <EvilTerran> and with -XKindAnnotations, that class could be written "class Functor (f :: * -> *) where..." if you so desired
04:25:50 <jz87> cabal-install is asking for cabal 1.3.2
04:26:05 <jz87> I'm pretty sure the latest version is 1.2.3
04:26:09 <FunctorSalad> ok, it is starting to make sense ;)
04:26:37 <FunctorSalad> EvilTerran: yes maybe that would be a bit clearer
04:27:20 <EvilTerran> they're an extension, tho, because the compiler can work out the kinds of everything in most cases (olegian hacks aside)
04:28:36 <EvilTerran> in this case, it looks in the body of the class, and sees "ooh, (f a) is being used as a type proper in there, so (f a :: *); a is also being used as a type proper, so (a :: *), and so (f :: * -> *)
04:30:18 <FunctorSalad> yes
04:30:56 <EvilTerran> it's funny that you say it's clearer, tho. most people see kind annotations and think "OH MY GOD STRING OF RANDOM PUNCTUATION ZOMFG"
04:31:18 <EvilTerran> ;)
04:31:40 <FunctorSalad> hehe
04:32:00 <EvilTerran> 'til they get used to 'em, anyhow
04:32:30 <FunctorSalad> well, I said it is clearer because I had trouble figuring out what the f in "Functor f" *is*
04:32:41 <EvilTerran> it's the functor!
04:33:01 <EvilTerran> er. that doesn't really help from a CT perspective, does it?
04:33:24 <FunctorSalad> yes, the relation to the mathematical sense wasn't obvious to me
04:33:34 <EvilTerran> the type of fmap is the big clue, tho. you can basically work out what properties f has from that
04:33:51 <EvilTerran> ?djinn (a -> b) -> Maybe a -> Maybe b
04:33:51 <lambdabot> f a b =
04:33:51 <lambdabot>     case b of
04:33:51 <lambdabot>     Nothing -> Nothing
04:33:51 <lambdabot>     Just c -> Just (a c)
04:34:08 <EvilTerran> completely automatically, in some cases :D
04:34:52 <EvilTerran> ?src Maybe fmap
04:34:53 <lambdabot> fmap _ Nothing       = Nothing
04:34:53 <lambdabot> fmap f (Just a)      = Just (f a)
04:35:31 <FunctorSalad> that's apparently equivalent of "self-proving theorems" :) (where there is only one way to stick the definitions together)
04:35:55 <Saizan> jz87: uh? if you get Cabal from the darcs repo on darcs.haskell.org/cabal the reported version is 1.3.2
04:36:44 <EvilTerran> yeah, altho ?djinn can also find some programs that aren't isomorphic to a self-proving thing
04:37:45 <EvilTerran> well, i guess they kinda are... nvm.
04:38:39 <quicksilver> djinn only finds valid proofs
04:38:49 <quicksilver> but it does contain some interesting heuristics to choose relevant proofs
04:40:48 <dcoutts> bos: pong
04:41:19 <dcoutts> @seen bos
04:41:20 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 6h 43m 54s ago.
05:03:48 <fons> does anyone have an idea of when haddock 2.0 is going to be released? I tested the darcs version and seems to work fairly well
05:14:38 <pierric> i have a question about the optimizing of ghc
05:14:45 <pierric> main = print . sum . map (\x -> 1) . lines =<< getContents
05:14:50 <shag> is it possible to decalre a data-type as instance of some class in module A and implement the required functions in another module B?
05:14:50 <pierric> which count the lines
05:15:01 <pierric> but it is extremely slow
05:15:14 <pierric> "main = print . sum . map (\x -> 1) . lines =<< getContents" is bit faster
05:15:26 <pierric> and "main = print . length . lines =<< getContents" is fastest
05:15:57 <pierric> so, cann't the ghc make the 1st one slower then the 2nd one ?
05:16:02 <scook0> pierric: are you using -O2?
05:16:05 <pierric> so, cann't the ghc make the 1st one as fast then the 2nd one ?
05:16:16 <pierric> no
05:16:25 <pierric> oh,
05:16:48 <pierric> i see. is   no optimizing by default?
05:16:54 <scook0> there's usually not much point comparing the performance of unoptimized code
05:16:55 <scook0> no
05:17:09 <pierric> ok,i see, thank you.
05:17:11 <scook0> (which means fast compilation by default)
05:17:38 <scook0> pierric: in particular, sum tends to be terrible without optimizations
05:23:51 <pierric> Oh, yes. After using  -O2, the codes run much more faster.
05:31:48 <desp> Is anyone using 6.8.2 on PPC, especially Mac OS X 10.5 PPC?
05:41:26 <fophillips> desp: I’m using it on Linux PPC.
05:44:15 <Lycurgus> i don't think that's what desp had in mind.
05:44:46 <jz87> how do I build happy?
05:44:51 <jz87> when I try to build happy
05:44:54 <jz87> it says it needs happy
05:45:32 <fons> desp: GHC is broken on Leopard/PPC
05:45:45 <fons> (AFAIK at least)
05:47:33 <jz87> I'm running tiger on intel
05:47:48 <jz87> is there anyway for me to get haddock?
05:48:05 <jz87> I need haddock which needs alex which needs happy
05:48:08 <jz87> and happy needs happy
05:48:31 <Saizan> jz87: tried the package on hackage?
05:50:44 <fons> jz87: haddock2 doesn't need parsers as it's embedded in GHC
05:50:53 <fons> jz87: you can give it a try
05:51:12 <fons> http://hackage.haskell.org/trac/ghc/ticket/1958
05:51:13 <lambdabot> Title: #1958 (collect2: ld terminated with signal 10 [Bus error]: Building parsec on a  ...
05:52:05 <fons> that seems to be  the main problem with Leopard and GHC
05:52:18 <fons> apple's linker seems to have a few nasty bugs
05:52:27 <fons> Saizan: http://code.haskell.org/haddock/
05:52:28 <lambdabot> Title: Index of /haddock
05:52:47 <fons> grab it with darcs
05:54:06 <Saizan> fons: was that for jz87 ?
05:54:47 <fons> yep, sorry it was for jz87
06:17:13 <Eelis> xerox: ping
06:34:05 <desp> fons: :/
06:34:14 <desp> fons: got any more information?
06:34:30 <fons> no, not much
06:34:39 <fons> I luckily just bought a macintel
06:34:49 <desp> Blah.
06:34:54 <desp> Still waiting for the 13" MBP.
06:35:08 <fons> until that happened I had to work through a ssh connection with my olg G4
06:35:24 <fons> I'm pretty sure it will be fixed soon
06:35:54 <fons> I bought a wonderful iMac, I'm really happy with it
07:25:38 <sw17ch> i have a quick syntax question if some one is around...
07:29:31 <opqdonut> just ask
07:36:00 <Japsu> good morning
07:36:07 <Japsu> (5:30 PM EET)
07:37:15 <Zao> Japsu: A fellow oversleeping soul, I see.
07:37:33 <Japsu> yeah
07:37:37 <Japsu> curse the holidays
07:37:40 <Zao> I think my alarm clock is not referentially transparent.
07:37:53 <Zao> I tried evaluating it lazily, but it seems to have malfunctioned.
07:38:09 <Japsu> I went to sleep 6 AM and had this great plan that I'd wake up 9 AM and run some errands
07:38:13 <Japsu> ...bah
07:38:24 <durka> an alarm clock with no side effects doesn't work too well...
07:41:16 <Zao> durka: I suspect it misuses unsafePerformIO
07:46:35 * SamB wonders why what sounds like music from heroes is playing on nectarine... maybe it's the other way round...
07:48:45 * SamB also wonders how one could specify precisely that fail and mzero must behave in the same manner...
07:52:58 <ricky_clarkson> > fail
07:53:00 <lambdabot>  Add a type signature
07:53:03 <phobes> Is there a Monad like List that supports priorities?  (Explores highest priority paths first?)
07:53:04 <ricky_clarkson> > fail :: Integer
07:53:05 <lambdabot>  Couldn't match expected type `Integer'
07:53:10 <ricky_clarkson> :t fail
07:53:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
07:53:25 <ricky_clarkson> > fail :: Maybe Integer
07:53:26 <lambdabot>  Couldn't match expected type `Maybe Integer'
07:53:36 * ricky_clarkson fails
07:53:39 <SamB> phobes: that sounds complicated
07:53:44 <ricky_clarkson> > fail "oops" :: Maybe I
07:53:45 <lambdabot>  Nothing
07:53:58 <ricky_clarkson> > fail "oops" :: List Integer
07:53:58 <lambdabot>   Not in scope: type constructor or class `List'
07:54:08 <ricky_clarkson> > fail "oops" :: [Integer]
07:54:08 <lambdabot>  []
07:54:12 <ricky_clarkson> Clever.
07:54:31 <ricky_clarkson> What's the String for?
07:54:42 <phobes> fail message
07:54:52 <phobes> reason
07:55:54 <Liskni_si> @src IO fail
07:55:54 <lambdabot> fail s  = failIO s
07:56:09 <Liskni_si> @src failIO
07:56:10 <lambdabot> failIO s = ioError (userError s)
08:13:55 <araujo> hello
08:17:34 <FunctorSalad> @src ioError
08:17:34 <lambdabot> Source not found. Just try something else.
08:18:02 <FunctorSalad> @type ioError
08:18:03 <lambdabot> forall a. IOError -> IO a
08:18:57 <FunctorSalad> @src IOError
08:18:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:19:32 <quicksilver> IOError is a type, not a function...
08:19:50 <quicksilver> hrm
08:19:50 <FunctorSalad> can't you src types?
08:19:52 <quicksilver> @src []
08:19:53 <lambdabot> data [] a = [] | a : [a]
08:19:56 <quicksilver> yes, you can :)
08:19:57 <quicksilver> sorry
08:20:06 <quicksilver> I'd forgotten that
08:20:15 <FunctorSalad> np
08:20:49 <byorgey> @src Maybe
08:20:49 <lambdabot> data Maybe a = Nothing | Just a
08:20:57 <byorgey> hey, I didn't know that =)
08:21:17 <byorgey> @src StateT
08:21:18 <lambdabot> Source not found. You untyped fool!
08:22:01 <ricky_clarkson> unityped!
08:22:47 <FunctorSalad> how do you tell a bot to STFU? ;) like "until (const False) id 0"? :D
08:23:18 <quicksilver> lambabot's evaluator has a time limit
08:23:22 <quicksilver> so you can't break it that way
08:23:28 <quicksilver> some of its plugins may have bugs though
08:23:28 <idnar> > until (const False) id 0
08:23:32 <lambdabot> Terminated
08:23:43 <FunctorSalad> quicksilver: didn't want to break it, just as a comeback
08:23:50 <quicksilver> ;)
08:23:51 <FunctorSalad> :)
08:24:18 <vincenz> > sum [1..10000000]
08:24:22 <lambdabot> Terminated
08:25:49 <idnar> > let sumn n = (x / 2) * (n + 1) in sumn 10000000
08:25:50 <lambdabot>   Not in scope: `x'
08:25:54 <idnar> > let sumn n = (n / 2) * (n + 1) in sumn 10000000
08:25:55 <lambdabot>  5.0000005e13
08:26:27 <FunctorSalad> > take 5 $ iterate (\x -> x*(1-x)) 0.1
08:26:27 <lambdabot>  [0.1,9.000000000000001e-2,8.190000000000001e-2,7.519239000000001e-2,6.953849...
08:26:29 <idnar> > let sumn n = (n * (n + 1)) `div` 2 in sumn 10000000
08:26:29 <lambdabot>  50000005000000
08:26:32 <FunctorSalad> ;)
08:27:14 <idnar> > [1..10]
08:27:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
08:28:44 <quicksilver> > sum [1..1000000]
08:28:45 <lambdabot>  500000500000
08:28:48 <quicksilver> > sum [1..10000000]
08:28:53 <lambdabot> Terminated
08:28:55 <quicksilver> > sum [1..10000000]
08:29:00 <lambdabot> Terminated
08:29:03 * quicksilver shrugs
08:29:07 <quicksilver> surprised it can't do that
08:29:08 * vincenz pats quicksilver on the back
08:29:11 <vincenz> sometimes it can
08:29:14 <vincenz> cpu must be loaded
08:29:24 <vincenz> oh wait, 10M?
08:29:27 <vincenz> no way
08:29:29 <vincenz> you get 3 seconds
08:29:51 <vincenz> you'd need a 3.3GHz only for the additions
08:30:15 <vincenz> (assuming 1 instruction per addition)
08:30:37 <FunctorSalad> the compiler should simplify it ;))
08:33:43 <roconnor> > take 5 $ iterate (\x -> 3*x*(1-x)) 0.1
08:36:20 <quicksilver> youch
08:36:25 <quicksilver> that was a serious netsplit
08:36:51 <roconnor> 44 left
08:37:38 --- mode: irc.freenode.net set +o ChanServ
08:37:38 --- mode: irc.freenode.net set +o Igloo
08:37:58 <FunctorSalad> thanks conal
08:38:26 <quicksilver> vincenz: you're off by 10^3, by the way
08:38:34 <roconnor> > take 5 $ iterate (\x -> 3*x*(1-x)) 0.1
08:38:35 <lambdabot>  [0.1,0.27,0.5913,0.72499293,0.5981345443500453]
08:38:36 <quicksilver> vincenz: 10M in 3 seconds would only be 3.3Mhz
08:38:46 <quicksilver> erm
08:38:47 <quicksilver> 33Mhz
08:38:54 <quicksilver> if it was 1 instruction per addition
08:39:02 <quicksilver> 3.3Mhz, I was right the first time :)
08:39:09 <quicksilver> of course, haskell doesn't compile that efficiently, sadly.
08:39:56 <vincenz> quicksilver: whoops :)
08:40:18 <sw17ch> quicksilver: it's a good thing nothing is perfect.... we'd get bored pretty quick
08:41:50 <vincenz> > sum [1..10000000]
08:41:55 <lambdabot> Terminated
08:42:06 <vincenz> quicksilver: you familiar with ghc-code-gen?
08:43:05 <quicksilver> no
08:43:17 <quicksilver> I've looked at some assembly output and read some web pages
08:43:18 <quicksilver> but that's all
08:44:03 * vincenz hmms
08:44:07 <vincenz> I just wonder
08:44:18 <vincenz> foo x = ... foo (x-1)
08:44:20 <vincenz> to be efficient
08:44:28 <vincenz> you overwrite x inistead of making a new stack loc, right
08:44:52 <quicksilver> I don't think that ghc has any optimisations capable of doing that
08:44:54 <quicksilver> but I'm not sure
08:45:20 <vincenz> so what happens, new stackframes that are gced?
08:46:08 <FunctorSalad> hmm that looks simple enough... but IANACE
08:46:15 <FunctorSalad> (compiler expert)
08:46:33 <FunctorSalad> at least if the ... is not recursive
08:46:49 <vincenz> reason I ask
08:46:58 <vincenz> I was recently viewing the boehm video on googletechtalk
08:47:04 <vincenz> and g++ compilers -introduces- concurrency bugs
08:47:10 <vincenz> if overwriting is done, this would do the same
08:47:41 <FunctorSalad> you mean overwriting would introduce concurrency bugs?
08:48:13 <vincenz> yes
08:48:19 <vincenz> it might
08:48:55 <FunctorSalad> hmm I have no idea what I'm talking about but if the whole foo calculation is handled by one thread, it should be fine, no?
08:49:02 <sw17ch> we're not talking about tail recursion are we?
08:49:40 <sw17ch> because my understanding of foo x = ... foo (x - 1) is that it would be tail recursive
08:49:42 <vincenz> tail recursion
08:49:44 <vincenz> or let-bound loops
08:50:13 <FunctorSalad> how would the compiler paralellize something like this anyway?
08:50:22 <sw17ch> you really can't...
08:50:47 <vincenz> who's saying it would
08:50:54 <vincenz> what if two pieces of code get started in the same loop
08:50:56 <vincenz> foo x = do
08:51:03 <vincenz>   if x == 1 then start-second-thread (foo 2)
08:51:06 <vincenz>   else ..
08:51:07 <vincenz>  ..
08:51:11 <vincenz>   foo (x+1)
08:51:26 <sw17ch> i believe at that point you have two entirely different stack frames
08:52:04 <ricky_clarkson> > let andThen=flip (.) in map ((+1) `andThen` (*10)) [1..10]
08:52:05 <lambdabot>  [20,30,40,50,60,70,80,90,100,110]
08:52:24 <ricky_clarkson> That seems quite readable, but is there a builtin like andThen?
08:52:26 <byorgey> > ((+1) >>> (*10)) [1..10]
08:52:26 <lambdabot>   add an instance declaration for (Num [t])
08:52:37 <byorgey> > map ((+1) >>> (*10)) [1..10]
08:52:37 <lambdabot>  [20,30,40,50,60,70,80,90,100,110]
08:52:46 <ricky_clarkson> Nice, thanks.
08:52:49 <byorgey> ricky_clarkson: >>> is from Control.Arrow
08:52:52 <FunctorSalad> ricky_clarkson: I like "andThen" :)
08:53:00 <ricky_clarkson> I like 'then' but it's a keyword.
08:53:43 <durka> :t (>>>)
08:53:44 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
08:54:30 <byorgey> In particular, when a is (->), that type is the same as (b -> c) -> (c -> d) -> (a ->d)
08:54:41 <byorgey> which is, of course, the type of flip (.)
09:00:01 <FunctorSalad> is there a way to declare types in the ghci shell?
09:00:18 <FunctorSalad> define new types, I mean
09:00:42 <quicksilver> nope
09:00:53 <quicksilver> I recommend an editor window open at the same time
09:01:04 <quicksilver> I often define types in somethign called 'test.hs' or 'scratch.hs'
09:01:10 <quicksilver> and I have a key bound to 'load this file in ghci'
09:01:42 <ricky_clarkson> :t (->)
09:01:42 <lambdabot> parse error on input `->'
09:01:56 <ricky_clarkson> byorgey: I'm not understanding "when a is (->)".
09:02:15 <ricky_clarkson> Can you show another use for >>> ?
09:02:19 <FunctorSalad> quicksilver: I guess one would do that with emacs haskell mode, but "load interpreter" in emacs haskell mode doesn't work for me :(
09:02:28 <ricky_clarkson> (I suppose I could just read the arrows documentation)
09:02:43 <byorgey> ricky_clarkson: the type of (>>>) says that if 'a' is an instance of Arrow, (that's the (Arrow a) =>) then >>> has type a b c -> a c d -> a b d.
09:02:50 <quicksilver> FunctorSalad: did you load inf-haskell?
09:02:52 <byorgey> ricky_clarkson: one instance of Arrow is (->).
09:02:57 <byorgey> i.e. pure functions.
09:03:03 <byorgey> are Arrows.
09:03:10 <FunctorSalad> quicksilver: no, thought it was automatical. thanks
09:03:33 <byorgey> ricky_clarkson: then substituting (->) for a, we get ((->) b c) -> ((->) c d) -> ((->) a d)
09:03:40 <byorgey> but (->) is usually written infix.
09:04:03 <byorgey> erm, that last one should be ((->) b d).
09:04:10 <ricky_clarkson> Hmm.  I thought -> was just syntax.  Is there a way of writing -> in such a way that :t works with it?
09:04:20 <byorgey> it's a type constructor.
09:04:40 <byorgey> so :t doesn't work on it, just like :t doesn't work on Maybe.
09:05:07 <FunctorSalad> yay it works :D
09:05:16 <FunctorSalad> (load-library inf-haskell)
09:05:22 <byorgey> i.e. think of it as a function at the type level: it takes two types as parameters, and results in a new type.
09:06:00 <hpaste>  quicksilver pasted ".emacs for haskell" at http://hpaste.org/4681
09:06:10 <quicksilver> FunctorSalad: that's how I do it
09:06:22 <quicksilver> FunctorSalad: then inf-haskell is loaded automatically the first time I call 'run-haskell
09:06:27 <roconnor> :k (->)
09:06:28 <lambdabot> ?? -> ? -> *
09:06:35 <roconnor> :k Maybe
09:06:36 <lambdabot> * -> *
09:06:44 <quicksilver> FunctorSalad: (see paste)
09:06:56 <FunctorSalad> quicksilver: nice. that should be default
09:06:59 <phobes> What does ?? -> ? -> * mean?
09:07:20 <quicksilver> phobes: something to do with unboxed types
09:07:29 <phobes> hm
09:07:40 <roconnor> :k ContT
09:07:40 <lambdabot> * -> (* -> *) -> * -> *
09:08:57 <roconnor> :kind ContT
09:09:07 <roconnor> @kind ContT
09:09:08 <lambdabot> * -> (* -> *) -> * -> *
09:14:31 <qebab> pattern matching is really quite cool
09:14:40 <Valodim_> yes.
09:15:40 <LoganCapaldo> pattern matching is just sugar for function application ;)
09:17:39 <fadec> Is pattern matching on lists a primative operation? tail [] raises an exception which are not primative yet h:t in a pattern somehow knows not to evaluate the head or tail of an empty list.
09:18:06 <quicksilver> fadec: no it doesn't. h:t will throw an error on an empty list
09:18:21 <quicksilver> > let f (x:xs) = 1 in f []
09:18:23 <lambdabot>   Non-exhaustive patterns in function f
09:18:54 <LoganCapaldo> barring ~ patterns
09:19:05 <LoganCapaldo> whose name escapes me
09:19:18 <LoganCapaldo> > let f ~(x:xs) = 1 in f []
09:19:18 <lambdabot>  1
09:19:29 <LoganCapaldo> irrefutable
09:19:33 <qebab> what does ~ do to the pattern?
09:19:48 <LoganCapaldo> makes it lazier
09:20:04 <qebab> okay
09:20:10 <desegnis> > let f ~(x:xs) = x in f []
09:20:11 <lambdabot>   Irrefutable pattern failed for pattern (x : xs)
09:20:15 <LoganCapaldo> it will always match but will fail if you actually try to use it and it didn't match
09:20:30 <LoganCapaldo> if that makes sense <g>
09:20:35 <fadec> quicksilver: non-exhaustive means it will try the next pattern but none exists - if there were a mathing pattern it would work - somehow knowing to skip x:xs even though x:xs should be evaluated first.
09:20:35 <quicksilver> fadec: and, to answer your original question, no lists aren't primitive in any way
09:20:51 <quicksilver> fadec: the only thing special about lists is the syntax
09:21:08 <quicksilver> "try the next" is standard behaviour of all patterns
09:21:26 <quicksilver> if data Foo = Bar | Baz and then I write f Bar = 1; f Baz = 2;
09:21:41 <quicksilver> then when I evaluate (f Baz) it "tries the next" as you say, and returns 2
09:21:53 <quicksilver> this is still the same with a more complicated exampel which binds variables :) like x and xs
09:22:16 <fadec> so a list is sort of like data List = x:xs | [] ??
09:22:18 <LoganCapaldo> > let { f ~(x:xs) = x ; f [] = 1 } in f [1,2,3] -- have to be careful w/ the irrefutable ones
09:22:19 <lambdabot>      Warning: Pattern match(es) are overlapped
09:22:20 <lambdabot>              In the definition...
09:22:55 <LoganCapaldo> fadec: yeah, data [] a = a : [a] | []
09:23:18 <phobes> It only warns about overlapped patterns when it can prove that case is unreachable, right?
09:23:18 <LoganCapaldo> (if that was valid syntax)
09:23:22 <desegnis> @src [] -- This is a fake, though, because of the special syntax thing
09:23:22 <lambdabot> Source not found. Where did you learn to type?
09:23:34 <desegnis> Hm, didn't that work once?
09:23:37 <quicksilver> fadec: very much like, yes. The only "special" bit there is the '[]'
09:23:42 <quicksilver> desegnis: it will, without a comment
09:23:52 <quicksilver> fadec: the other 'special' bit is the [a,b,c] syntax
09:23:53 <desegnis> D'oh.
09:24:00 <quicksilver> which is sugar for a:b:c:[]
09:25:36 <LoganCapaldo> data List a = Cons a (List a) | Empty -- same thing less sugar
09:26:28 <fadec> What things about haskell are inconsistent in a math-like sense? Seems every time I doubt the purity of something the elegance remains.
09:26:48 <Valodim_> inconsistent?
09:26:56 <quicksilver> LoganCapaldo: I don't really understand why ':' is special-cased, either.
09:27:08 <quicksilver> LoganCapaldo: I don't see why it isn't just an infix constructor which happens to be bound in the Prelude.
09:27:15 <LoganCapaldo> quicksilver: if I knew I'd tell you :)
09:27:20 <quicksilver> fadec: I think pure haskell98 is pretty consistent.
09:27:28 <quicksilver> fadec: numeric patterns are a bit odd.
09:27:39 <Valodim_> there are (arguably) no inconsistencies, that's the point of haskell...
09:28:29 <fadec> quicksilver - Numeric patterns, as in matching on an integer??
09:28:44 <quicksilver> fadec: yeah
09:28:58 <quicksilver> f 0 = "zero"
09:29:09 <quicksilver> desugars to f x | x == fromInteger 0 = "zero"
09:29:36 <quicksilver> some people find it a bit unaesthetic that what looks like a 'pattern match' is actually a boolean guard in disguise.
09:29:52 <fadec> quicksilver: seems okay to me since 0 is a data constructor for something - Int or Integer, or whatever is inferred I guess.
09:30:33 <quicksilver> fadec: it behaves like a true constructor for Integer, yes
09:30:42 <quicksilver> I think
09:31:08 <fadec> or is a boolean gaurd actually a pattern match in disguise?
09:31:28 <LoganCapaldo> fadec: often == is implemented with pattern matches
09:31:32 <fadec> > 1 :: Int
09:31:33 <lambdabot>  1
09:32:34 <fadec> > 1 :: Float
09:32:34 <lambdabot>  1.0
09:33:10 <LoganCapaldo> eg, data A = A | B ; instance Eq A where A == A = True ; B == B = True ; _ == _ = False
09:35:09 <LoganCapaldo> but it doesn't have to be
09:40:13 <geezusfreeek> does anybody have HDBC working with GHC 6.8? i keep getting stuff about System.Time and old-time and such, but looking around on the web i see nobody else having these issues
09:41:43 <geezusfreeek> just asking in case i am missing some update to HDBC or something. i guess i could just install old-time
09:42:44 <geezusfreeek> alright alright old-time it is
09:42:45 <geezusfreeek> :)
09:45:17 <geezusfreeek> grr, now i get <interactive>: /usr/lib/ghc-6.8.1/lib/Cabal-1.2.2.0/HSCabal-1.2.2.0.o: unknown symbol `oldzmtimezm1zi0zi0zi0_SystemziTime_a97_closure'
09:45:31 <geezusfreeek> when i try to do runhaskell Setup.lhs configure for HDBC
09:50:09 <ertai> does anyone have tried lambdabot with recent a GHC?
09:50:28 <durka> i tried
09:50:32 <durka> and totally failed to install it
09:50:32 <geezusfreeek> *sigh* then i updated Cabal to 1.2.3 and now it complains about old-time again, even after reinstalling old-time after updating cabal
09:50:35 <Heffalump> I imagine hs-plugins would be an issue
09:51:27 <ertai> bytestring is an issue since unsafe functions have moved
09:52:09 <ertai> and I have also a very strange problem about a newtype+deriving that fails
09:54:39 <fadec> ertai: I also failed
09:56:32 <ertai> I think that the code works with an older version of GHC, so it seems like a regression (or a fix) in newtype+deriving.
09:56:38 <fadec> Who's going to write a program to fix old code to work with 6.8?
10:01:06 <geezusfreeek> well, i finally got HDBC to compile... i had to do all sorts of changes to HDBC.cabal, but i guess it wasn't that bad... i'm just not very experienced with cabal
10:02:42 <fadec> Why does GHC use much less memory than SBCL? http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=sbcl
10:02:43 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/27u4hk
10:03:58 <jimstutt> geezusfreeek: what did you do to HDBC.cabal apart from add missing deps?
10:06:22 <fuxxx> if i have an expression of type "(C1 a, C2 a) => a" and this type is unique in my program as in there's only _one_ type (call it D12) which are instances of both C1 and C2.. it gives me 'ambiguous type variable' error, which i suppose is correct since you could define a new data type to make the expression ambiguous, but is there a way (flag/extension, type magic) to force ghc to only consider the universe of known data types and infer 'a
10:08:19 <Philippa> fuxxx: could you change your nick please? I don't think it's appropriate for this chan
10:09:56 <oerjan> hm... exactly how are you getting ambiguous type variable?
10:10:02 <oerjan> when testing in the interpreter?
10:10:10 <LoganCapaldo> @type \x -> (succ x, x + 0)
10:10:11 <lambdabot> forall a. (Enum a, Num a) => a -> (a, a)
10:10:21 <LoganCapaldo> @type \x -> fst (succ x, x + 0)
10:10:21 <lambdabot> forall a. (Enum a, Num a) => a -> a
10:10:34 <nickchange> Philippa, ok...
10:10:38 <LoganCapaldo> I think the error doesn't mean what you think it means
10:10:55 <nickchange> oerjan, yes.
10:11:32 <oerjan> nickchange: if C1 and C2 are 1-parameter classes then you could probably add D12 to the list of default types
10:12:04 <oerjan> oh wait, wasn't there a bug with that.
10:12:32 <sjanssen> oerjan: defaulting is for numeric types only
10:13:07 <oerjan> sjanssen: ghc has an extension
10:13:31 <oerjan> that allows any 1-parameter class, iirc
10:13:46 <nickchange> i'm trying to make haskell infer the type based on what class functions i use.. i.e. C1 has function 'new' which just gives a value of (C1 a) => a.. and C2 has some other function like shift :: (C2 a) => a -> a.. and then (shift $ new) becomes (C2 a, C1 a) => a and there's only one data type which are instansiated for that.
10:14:03 <oerjan> hm it may be that one of the classes still must be builtin
10:14:25 <int-e> oerjan: Haskell 98 only allows numeric classes there
10:14:40 <oerjan> int-e: i already _said_ it was an extension
10:14:56 <int-e> sorry, I missed that.
10:15:19 <phobes> nickchange:  So how are you using that function?
10:15:42 <phobes> (the (C2 a, C1 a) => a value rather
10:16:16 <nickchange> using it? well, let's say i just want to putStrLn (show a) it.. (D12 is also an instance of Show)
10:16:17 <qebab> hrm, if I get a line from a socket and I *maybe* want to reply to it, but not always, the sensible thing would be to handleInput :: Handle -> String -> Maybe IO() ?
10:16:39 <phobes> nickchange:  ah, and it's telling you to add a type signature?
10:16:46 <LoganCapaldo> qebab: does the called need to know if you handled it or not?
10:16:47 <nickchange> phobes, yes
10:16:50 <sjanssen> qebab: no, because that's a type error :)
10:16:59 <LoganCapaldo> you could just return () if you don't want to do anything
10:17:01 <sjanssen> s/type error/kind error/
10:17:15 <qebab> I thought I couldn't return in Haskell :o
10:17:16 <phobes> nickchange:  Yes, you'd need defaulting
10:17:16 * LoganCapaldo assumes he just forgot the parens)
10:17:27 <qebab> LoganCapaldo: yes, the caller needs to know
10:17:53 <LoganCapaldo> so IO Bool might make or sense
10:18:01 <LoganCapaldo> *more
10:18:16 <qebab> hrm
10:18:25 <qebab> these things are still a bit confusing
10:18:44 <sjanssen> Maybe () and Bool are more-or-less the same thing
10:19:15 <FunctorSalad> welll ;)
10:19:39 <nickchange> phobes, ok, i'll read about that then. but do you know if it's something i can do with 6.6 or do i need 6.8?
10:20:01 <desegnis> qebab: You'll probably need IO to inspect the handle anyways (so you may decide whether to reply), so it makes sense to have an IO action in all cases
10:20:03 <phobes> nickchange:  most likely you can't do it at all I think (in any of those versions)
10:20:30 <oerjan> extended default rules are at least as old as 6.6 i think
10:20:59 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
10:21:00 <lambdabot> http://tinyurl.com/2wj9jo
10:21:03 <qebab> okay
10:21:16 <phobes> oerjan:  sorry, I'm really just deferring to you here - I thought you ended up deciding there were limitations that would prevent this from applying to his situation
10:21:31 <oerjan> but i vaguely recall a bug that means you cannot change defaults while using the interpreter...
10:22:10 <oerjan> well there needs to be a numeric or Show, Eq or Ord class involved
10:22:20 <oerjan> but there was in the example
10:22:24 <phobes> ya
10:25:33 <oerjan> http://hackage.haskell.org/trac/ghc/ticket/552 may be the relevant bug
10:25:36 <lambdabot> Title: #552 (GHCi :m doesn't restore default decl) - GHC - Trac
10:25:47 <nickchange> hmm. i wonder why it's not possible to relax the default rules completely or make them programmable?
10:26:37 <oerjan> nickchange: you are aware of the haskell default declaration?  it allows you to change the types chosen, at least
10:27:08 <oerjan> however, the bug i referred means that ghci does not pick it up from the modules
10:27:32 <oerjan> there have been discussions on how to relax them further
10:27:35 <nickchange> i wasn't, but looking into it now
10:28:36 <oerjan> now if this doesn't work, have you tried type annotations?
10:28:53 <oerjan> print (a :: D12)
10:29:28 <nickchange> yeah, that works fine.. but it's what i'm trying to avoid..
10:29:42 <oerjan> i see
10:29:47 <FunctorSalad> how do I make this type constructor work? (Int ->)
10:29:55 <oerjan> FunctorSalad: (->) Int
10:30:57 <LoganCapaldo> type Fun a b = a -> b ; Fun Int might work too, depending on context
10:31:08 <FunctorSalad> oerjan: ah, thanks. out of curiosity, why didn't this work? "type Hom a b = a -> b" and then "instance Monad (Hom Int) where ..."
10:31:09 <oerjan> LoganCapaldo: um no
10:31:16 <FunctorSalad> complains that Hom needs two arguments.
10:31:29 <oerjan> yes, type synonyms must always be fully applied
10:31:37 <conal> FunctorSalad: try instead "type Hom = (->)"
10:31:42 <oerjan> (what i protested to LoganCapaldo about)
10:31:55 <LoganCapaldo> well I said depending on context :)
10:32:27 <conal> FunctorSalad: in other words, eta-contract the definition of Hom.
10:33:00 <conal> FunctorSalad: if you give an eta-expanded type alias, then ghc will want you to use it in saturated form.
10:33:13 <FunctorSalad> conal: hmm ok
10:33:27 <FunctorSalad> ?kind (->)
10:33:29 <lambdabot> ?? -> ? -> *
10:33:43 <FunctorSalad> I guess I need to use these ?? and ? somehow
10:33:44 <oerjan> nickchange: if D12 is very long you might define a synonym for it
10:33:49 <FunctorSalad> can I do that or is it hardcoded?
10:34:11 <FunctorSalad> (not that it's really neccessary, just trying to understand this stuff)
10:34:19 <conal> FunctorSalad: it's a bit of a sad situation.  ghc uses only first-order matching.  i think the "fully applied" restriction has to do with consistency/predictability.
10:35:06 <conal> FunctorSalad: the first-order restriction means you can't define instances for (-> b)
10:35:12 <conal> though you can for (a ->)
10:35:23 <FunctorSalad> yeah, found that odd too
10:35:41 <FunctorSalad> "flip (->)" didn't work ;)
10:36:03 <oerjan> FunctorSalad: it can work as a newtype though
10:36:05 <conal> FunctorSalad: see Flip in TypeCompose
10:36:09 <sjanssen> newtype Flip a b c = Flip (a c b) -- will work
10:36:09 <conal> @wiki TypeCompose
10:36:09 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
10:36:17 <sjanssen> whoa, major stereo :)
10:36:23 <FunctorSalad> ah, good :)
10:36:42 <oerjan> but you need that pesky constructor of course
10:36:56 <conal> yep -- first-order matching. :(
10:37:03 <conal> FunctorSalad: you may like type composition and other goodies in TypeCompose
10:37:55 <nickchange> oerjan, it's not that.. i have a bunch of data types each implementing specific "behaviours", say, but i'm trying to avoid forcing the user to explicitly name the data type he wants like new_D12 and new_D567 etc and instead have him just use 'new' and use the functions he want on it and have haskell infer what kind of data type from the functions he uses on it.. (which should always just result in a single unambiguous data type.)
10:38:49 <oerjan> nickchange: if he uses it in a module, it should work rather better
10:39:08 <FunctorSalad> hmm, what I was trying to do is tell Haskell that for a fixed type B, mapping A to (A -> B) is a monad. but actually now I'm not so sure whether it is :)
10:39:08 <oerjan> since it will usually be disambiguated by context
10:39:38 <FunctorSalad> the unit is the const function and x >>= f = (f . x)
10:40:00 <conal> FunctorSalad: you'd need a "newtype" or "data" wrapper.  again, because of first-order matching.
10:40:17 <oerjan> nickchange: now if you have a _single_ class that has an unambiguous type, you could use functional dependencies i think
10:40:33 <oerjan> class C a | -> a where ...
10:41:30 <FunctorSalad> oh, mixed that up. I wanted to map A to (B -> A). that will work with the usual (->) I think
10:41:51 <LoganCapaldo> almost looks like Cont
10:42:06 <LoganCapaldo> @src Cont return
10:42:07 <lambdabot> return a = Cont ($ a)
10:42:31 <LoganCapaldo> @src Cont (>>=)
10:42:32 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
10:42:52 <LoganCapaldo> @type Cont
10:42:53 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
10:42:56 <oerjan> FunctorSalad: that monad is already defined in Control.Monad.Reader
10:43:06 <FunctorSalad> yeah, I'm sure it has been done. doing it as a monad exercise :)
10:43:23 <oerjan> or wait...
10:43:36 <oerjan> you really mean A to be the final monad parameter?
10:44:00 <oerjan> but the functions you mention are for B the final parameter
10:44:32 <phobes> I wonder if you could get what nickchange wants with associated types?
10:44:44 <oerjan> um wait no, (.) is fmap not >>=
10:44:45 <nickchange> oerjan, what do you mean? let's say i'd want him to say 'show $ shift $ rotate $ new' and it would give string of the data type with support for shifting&rotation or some such.. and if he typed 'show $ skew $ scale $ new' it would give data type with skewing&scaling.. and there's only one data type which supports rotation+shifting, and only one which suppors skewing+scaling.. and maybe a third which supports rotation+scaling (but not
10:44:56 <FunctorSalad> oerjan: I mixed it up the first time. I want B fixed, then M: Hask -> Hask, M(A) := (B -> A) is a monad I think
10:45:18 <FunctorSalad> (and M(f) := postcomposition with f)
10:45:39 <nickchange> shift/scale/rotate just example.. could just as well be drive/run/quack or whatever. pop/append/push/etc. fastget/slowget/etc.. but different aspects still.
10:46:37 <jfoutz> what does $= mean?
10:46:46 <jfoutz> i'm seeing it in HOpenGL stuff...
10:46:59 <oerjan> nickchange: i think it is hard to combine more than one class in that way, but maybe there is some type hackery
10:47:19 <jfoutz> @src ($=)
10:47:20 <lambdabot> Source not found. :(
10:47:28 <jfoutz> @hoogle ($=)
10:47:29 <lambdabot> Did you mean: ($=)
10:47:29 <lambdabot> Prelude.undefined :: a
10:47:29 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
10:47:38 <jfoutz> ahhh.
10:47:46 <oerjan> FunctorSalad: right that is the (->) monad
10:48:37 <dufflebunk> Yay! Darcs is finally building
10:48:38 <FunctorSalad> oerjan: hmm, that would be another layer of abstraction, no? I was considering "(->) B" as a monad
10:48:51 <gbacon> in my main function, I'm plucking the values of several environment variables, but how should I structure the error handling (e.g., if some variables are undefined)?
10:48:54 <oerjan> FunctorSalad: what i meant
10:49:08 <gbacon> all-out ErrorT?
10:49:10 <FunctorSalad> oerjan: (->) is a functor too, think it's the yoneda functor :)
10:49:42 <oerjan> FunctorSalad: well not a Functor (without another parameter)
10:49:48 <FunctorSalad> I mean (->) as a functor from Hask to Hask^Hask
10:50:06 <oerjan> eek
10:50:12 <FunctorSalad> but didn't want to go that far yet :)
10:50:47 <oerjan> ContraFunctors have been mentioned before...
10:50:54 <FunctorSalad> that's what you do in CT to see that any category is isomorphic to a full subcategory of a category of set-valued functors...
10:51:01 <oerjan> -> is contravariant in its first parameter
10:51:05 <FunctorSalad> yes
10:51:40 * oerjan has heard about the Yoneda lemma but doesn't remember if he ever fully understood it
10:52:14 <bos> jeez, cristian baboi is an expert troll.
10:54:44 <FunctorSalad> it says what I just said (that any cat C is isomorphic to a subcategory of the functor cat (C -> Set)), and it also says what nat. transforms from ((->) B) to any Functor F: C -> Set look like
10:55:44 <sjanssen> bos: I thought he was sincere
10:56:14 <FunctorSalad> namely, a natural tranform from ((->) B) to F is uniquely determined by where it maps the identity on B (which is mapped to some element of F(B))
10:56:27 <bos> sjanssen: probably, but still.
10:56:48 <bos> @seen dcoutts
10:56:48 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 5h 27m 32s ago.
10:56:52 <bos> wah.
10:56:53 <FunctorSalad> horribly confusing, but more-or-less self-proving :)
10:59:08 <oerjan> aye
11:03:08 <Cale> I wonder which categories aside from Set will satisfy Yoneda-like conditions.
11:04:55 <FunctorSalad> Cale: I think Set can be replaced by whatever structure you have on the homsets... Haskell homsets are in Hask again, I think?
11:05:28 <FunctorSalad> or if the homsets are abelian groups, Set can be replaced by Ab I think
11:06:00 <gbacon> @src reads
11:06:01 <lambdabot> reads = readsPrec minPrec
11:06:26 <oerjan> @src Read
11:06:26 <lambdabot> class Read a where
11:06:26 <lambdabot>   readsPrec    :: Int -> ReadS a
11:06:26 <lambdabot>   readList     :: ReadS [a]
11:06:26 <lambdabot>   readPrec     :: ReadPrec a
11:06:26 <lambdabot>   readListPrec :: ReadPrec [a]
11:08:03 <loupgaroublond> is there any sort of tab completion for haskell in emacs?
11:10:04 <jfoutz> alt-/ will cycle through known symbols
11:10:22 <jfoutz> but that's as far as i've ever tried.
11:10:40 <shapr> hippie-expand can do a lot more for you.
11:10:41 <loupgaroublond> jfoutz: doesn't seem to work with qualified packages
11:10:59 <FunctorSalad> alt-/ is not easy on german kb ;)
11:11:07 <shapr> You can rebind it.
11:11:20 <Cale> FunctorSalad: hmm, but this is in the case where you have restrictions on the domain of your functors. It would be interesting to know which conditions are necessary for it to work with any functor on any domain category.
11:11:42 <shapr> I've remapped capslock to F14 and then bound my customized hippie-expand to F14
11:11:58 <loupgaroublond> FunctorSalad: everything that doesn't require ä, ö, or ü is hard on a german keyboard ;)
11:16:47 <FunctorSalad> Cale: we'd have to figure out what structure we can define for arbitrary homsets (don't know about domain cats)
11:17:07 <FunctorSalad> but I'd think arbitrary homsets are just sets
11:38:17 <Cale> FunctorSalad: I suppose the question is how close to Set does a category have to be in order to have an analogue of Hom functors.
11:39:10 <Cale> It might be that Set is the only thing that works.
11:39:42 <FunctorSalad> which argument of the hom functor is what now? one your category and one any category?
11:51:18 <Cale> hmm, I suppose you still have the issue that the natural transformations between the functors are being treated as a set, so you'd need an extra mapping there of some sort...
11:52:35 <Cale> You'd have some category S which was a replacement for Set in this. Then for any category C, and each object A of C, there's an associated functor h_A : C -> S, which takes the place of Hom(A,-). You then want some analogue of Nat(h_A, F) ~= F(A), but Nat(h_A, F) is a set.
11:52:54 <Cale> (whereas F(A) is an object in S)
11:55:10 <Cale> (I suppose it would be a bit much to ask for a corresponding object of S for every pair of parallel functors :)
11:57:55 <FunctorSalad> Cale: hmmm I see
11:58:11 <jimstutt>  I've always understood the embedding to be precisely into Set Nat :: Hom(A, _),F) ~ F A where F A is a Set.
11:58:29 <FunctorSalad> Cale: you could apply a forgetful functor S -> Set to F(A) though
11:58:45 <Cale> hmm, perhaps that's an idea :)
11:58:56 <jimstutt> Iiuc the Set is what gives you closed cartesian properties suitable for computation.
11:59:56 <Cale> so just looking at concrete categories S rather than arbitrary ones, that seems reasonable
12:05:01 <faxathisia> hello
12:05:42 <AtnNn> hi
12:06:41 <faxathisia> Any thoughts on this http://cvs.coverproject.org/marcin/cgi/viewcvs/*checkout*/Agda2/src/full/Interaction/Options.hs?rev=1.11 ?
12:06:43 <lambdabot> http://tinyurl.com/3dwxdx
12:06:43 <sw17ch> @src Numeric.fromInteger
12:06:43 <lambdabot> Source not found. Take a stress pill and think things over.
12:06:51 <faxathisia> to parse command line args
12:07:08 <oerjan> @index fromInteger
12:07:09 <lambdabot> Prelude
12:07:17 <oerjan> @src Num
12:07:18 <lambdabot> class  (Eq a, Show a) => Num a  where
12:07:18 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:07:18 <lambdabot>     negate, abs, signum     :: a -> a
12:07:18 <lambdabot>     fromInteger             :: Integer -> a
12:07:39 <gigamonkey> Newbie question: what's a "standard" programming environment for hacking Haskell? (E.g. in Common Lisp I'd say Emacs + SLIME + a Lisp of your choice)
12:08:21 <byorgey> gigamonkey: emacs + emacs haskell-mode + ghc is pretty standard.
12:08:50 <LoganCapaldo> I usually use hpaste + #haskell + lambdabot
12:08:57 <gigamonkey> This one: http://www.haskell.org/haskell-mode/?
12:08:59 <lambdabot> Title: Haskell Mode for Emacs
12:09:09 <ricky_clarkson> LoganCapaldo: heh, me too.
12:09:43 <oerjan> @remember LoganCapaldo [on "standard" Haskell programming environments] I usually use hpaste + #haskell + lambdabot
12:09:43 <lambdabot> Done.
12:10:54 <gigamonkey> byorgey: you say ghc not ghci--does that imply you mostly write .hs files, then compile them, and then run the resulting program?
12:11:23 * faxathisia uses text editor & ghci
12:12:06 <LoganCapaldo> there are things you have to put in a file (ype decls. etc.) even if you live in ghci and never compile a program
12:12:08 <byorgey> gigamonkey: oh, I just meant ghc-the-bundle-of-stuff, which includes ghci
12:12:20 <LoganCapaldo> also, that
12:12:21 <byorgey> most people use ghci a lot.
12:12:35 <byorgey> including me. =)
12:12:51 <LoganCapaldo> (ghci == ghc --interactive)
12:13:02 <faxathisia> well a better question might be.. How would do you parse command line args?
12:13:04 <gigamonkey> do you just run it in an xterm or emacs shell mode or is there something akin to SLIME
12:13:14 <gigamonkey> (if you know what that is)
12:13:16 <faxathisia> cause I did it in a fold and that seems sort of ridiculous/awful
12:13:25 <faxathisia> in an terminal
12:13:49 <gigamonkey> LoganCapaldo: so if you live in ghci do you just use :load to load your .hs files?
12:13:57 <srid> gigamonkey: can we expect Practical Common Haskell? :)
12:13:58 <LoganCapaldo> yeah
12:14:03 <LoganCapaldo> : works too
12:14:14 <LoganCapaldo> (for reloading)
12:14:28 <gigamonkey> srid: heh. I'm just getting ready for my interview with Simon Peyton-Jones.
12:14:50 <oerjan> faxathisia: have you looked at System.Console.GetOpt?
12:15:05 <faxathisia> yeah, I've seen one example of it being used
12:15:09 <faxathisia> (that http://cvs.coverproject.org/marcin/cgi/viewcvs/*checkout*/Agda2/src/full/Interaction/Options.hs?rev=1.11 )
12:15:10 <lambdabot> http://tinyurl.com/3dwxdx
12:15:25 <faxathisia> I'll try that then
12:17:25 <ricky_clarkson> gigamonkey: I thought you were doing that ages ago.
12:17:58 <gigamonkey> ricky_clarkson: well I signed him up ages ago but haven't interviewed him yet.
12:18:01 * ricky_clarkson remembers he needs to glance at gigamonkey's coverage of CL's conditions again.
12:18:28 <gigamonkey> But I've done a first round with almost all the local to the Bay Area folks so now I'm getting ready for the ones farther afield.
12:18:58 <ricky_clarkson> @quote eyes
12:18:58 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
12:19:08 <mauke> ooh, are you the lisp guy?
12:22:59 <FunctorSalad> if I'm instantiating some type class "instance Foo Bar where ...", is there a way to auto-generate the expected method signatures?
12:23:45 <FunctorSalad> since "instance Monad ((->) dom) where ..." apparently doesn't think what I'm thinking :(
12:24:12 <EvilTerran> isn't that already a monad instace?
12:24:30 <EvilTerran> @src (->) (>>=)
12:24:30 <lambdabot> f >>= k = \ r -> k (f r) r
12:24:33 <EvilTerran> @src (->) return
12:24:33 <lambdabot> return = const
12:24:36 <EvilTerran> @src (->) fail
12:24:36 <lambdabot> Source not found. My mind is going. I can feel it.
12:24:37 <FunctorSalad> maybe, but I want to redo it anyway
12:25:12 <oerjan> FunctorSalad: you shouldn't need to use type signatures in an instance declaration
12:25:42 <FunctorSalad> oerjan: yes, I'd like them just to see what the class is expecting, for debugging purposes
12:25:55 <FunctorSalad> EvilTerran: hmm that bind looks slightly different than mine, that's probably the problem
12:26:07 <oerjan> hm...
12:26:24 <EvilTerran> (>>=) f k r = k (f r) r -- if you prefer
12:26:26 <oerjan> :t (>>=).(id.)
12:26:28 <lambdabot> forall b b1 a. (a -> b1) -> (b1 -> a -> b) -> a -> b
12:26:53 <oerjan> :t (id.).return
12:26:54 <lambdabot> forall a a1. a1 -> a -> a1
12:27:07 <EvilTerran> (f >>= k) r = k (f r) r -- should also work, but some haskell compiler or another can't cope with it (nhc, was it?)
12:27:28 <Heffalump> any subscribers to debian-haskell around? Have you been getting mails ok recently? (maybe 5 or 10 this month)
12:27:51 <oerjan> FunctorSalad: ^^ trick to get the types, the id. does nothing but force the right argument to be a function
12:29:53 <EvilTerran> ?type (>>=)
12:29:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:30:15 <FunctorSalad> hmm, f is type dom -> a and k is type a -> (dom -> b). thus I just did f >>= k = (k . f) to get something of type dom -> b. but actually k.f :: dom -> (dom->b), doh
12:30:16 <oerjan> although since lambdabot already has that instance, :t removes the Monad restriction
12:30:44 <EvilTerran> m = (e->), so that's (e->)a -> (a -> (e->)b) -> (e->)b, ie (e -> a) -> (a -> e -> b) -> (e -> b)
12:30:51 <EvilTerran> ?djinn (e -> a) -> (a -> e -> b) -> (e -> b)
12:30:51 <lambdabot> f a b c = b (a c) c
12:31:11 <oerjan> FunctorSalad: yep, as i mentioned a while ago, (.) is the fmap/liftM for that monad, not the (>>=)
12:31:33 <oerjan> oh wait...
12:32:01 <Saizan> k needs both the result of f and the dom
12:32:01 <oerjan> hm no
12:32:02 <gigamonkey> Okay, so what's a good data type in Haskell to represent a Go board? I'm looking at DiffArray or maybe some kind of Map.
12:32:22 <oerjan> gigamonkey: DiffArray is pretty bad, apparently
12:32:49 <Saizan> no one is optimizing it for performance
12:33:01 <Saizan> so plain Array/UArray is faster
12:34:01 <Saizan> a Map nicely represents empty cells though
12:34:37 <faxathisia> @undo do { x <- f ; return $ g x }
12:34:37 <lambdabot> f >>= \ x -> return $ g x
12:35:12 <Saizan> @. pl undo do { x <- f ; return $ g x }
12:35:13 <lambdabot> g `fmap` f
12:38:30 <FunctorSalad> ah, the (.) was almost correct after all. f >>= k = \r -> (k . f) r r. sorry everyone for talking about this the whole day ;)
12:39:11 <FunctorSalad> "plug the element of dom in twice" is the join of this monad...
12:39:28 <oerjan> now if you use the -> monad join trick, that turns into join (k . f)
12:40:02 <oerjan> which happens to be a special case of the general f >>= k = join (k `fmap` f) rule
12:40:34 <faxathisia> @hoogle (a -> Bool) -> [a] -> Bool
12:40:34 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:40:35 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
12:40:35 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
12:43:19 <FunctorSalad> @type k `fmap` f
12:43:19 <lambdabot> Not in scope: `k'
12:43:19 <lambdabot> Not in scope: `f'
12:43:32 <mauke> @type ?k `fmap` ?f
12:43:32 <lambdabot> forall a b (f :: * -> *). (?k::a -> b, ?f::f a, Functor f) => f b
12:44:01 <Saizan> "writing programs by solving equations based on commutative diagrams?"
12:44:43 <cpst> sounds like a frustrating way to program
12:46:13 <FunctorSalad> oerjan: hmm k `fmap` f doesn't have the monad applied twice, why can you join it?
12:46:34 <Saizan> because the result of k is "m b"
12:47:04 <FunctorSalad> yes, but join :: m m b -> m b, no?
12:47:17 <Saizan> yup, but f provides the outer m
12:47:46 <oerjan> Saizan: k :: a -> m b, f :: m a, so k `fmap` f :: m (m b)
12:47:51 <oerjan> er, FunctorSalad
12:48:31 * Tac-Tics is sad that #Haskell has been asleep all day
12:48:45 <Tac-Tics> bah
12:48:52 <Tac-Tics> My client must have frozen or something
12:49:05 <Saizan> Tac-Tics: uh?
12:49:06 <faxathisia> do many people use case inside lambdas a lot?
12:49:09 <oerjan> indeed
12:49:13 <faxathisia> or where instead?
12:49:46 <Tac-Tics> It's too bad you can only have one patter inside Haskell's lambda statements
12:49:47 <FunctorSalad> oerjan: oh, misunderstood the infix `fmap`. sorry, not very concentrated today
12:49:50 <Saizan> you can't use where directly in a lambda
12:49:54 <faxathisia> yeah that's what I keep thinking
12:50:02 <bos> woo! i just got a simple jitted program running through my haskell bindings for LLVM.
12:50:29 <Saizan> there's a proposal for a syntax like \case of .. === \x -> case x of ---
12:50:37 <FunctorSalad> but to my defense, I only started coding haskell yesterday ;)
12:50:50 <FunctorSalad> but read a bit about the concepts earlier already
12:52:10 <EvilTerran> no \, just (case of {...})
12:52:40 <Saizan> but then they are lambdas no more!
12:52:46 <faxathisia> aww
12:52:48 <faxathisia> I actually tried that :p
12:52:53 <faxathisia> Would be cool though, to hav ethat
12:52:58 <Eelis> +1
12:53:33 <dufflebunk> Any Happs people here?
12:54:20 <Saizan> dufflebunk: there's also #happs, do you have a specific question?
12:54:35 <dufflebunk> Yeah, I'll ask in #happs
12:54:44 <dufflebunk> thanks
13:00:03 <gbacon> > e <- getEnvironment
13:00:03 <lambdabot>  Parse error at "<-" (column 3)
13:02:05 <bos> i wish dcoutts was around.
13:03:21 <pafcu> I'm having a strange problem, and I'm wondering if someone here has a solution.
13:04:08 <pafcu> The line sequence_ [(f x),(putStrLn "foo")] works fine, and "foo" is printed to the screen
13:04:42 <pafcu> But sequence_ [(f x),(putStrLn "foo"),(f x)] eats up all my memory, and "foo" is never printed
13:04:51 <faxathisia> @pl (\x -> mapM f x) =<< mapM g x
13:04:52 <lambdabot> mapM f =<< mapM g x
13:05:32 <faxathisia> @pl flip (>>=)
13:05:33 <lambdabot> (=<<)
13:05:34 <faxathisia> :D
13:05:48 <Tac-Tics> @pl flip (=<<)
13:05:48 <lambdabot> (>>=)
13:05:59 <Tac-Tics> It's called pointless for a reason =-P
13:06:16 <guenni> lol
13:06:54 <nickchange> when trying to make install the binary package for 6.8.2 i get this: "c Apply.cmm -o Apply.o \ make[2]: c: Command not found".. is 'c' a command i'm supposed to install? afaik the cmm files are c--, and i don't have a c-- compiler installed, is it necessary?
13:07:09 <pafcu> Any ideas why (f x) works in the first case, but not the second?
13:07:32 <Saizan> pafcu: what are f and x?
13:07:38 <FunctorSalad> @pl flip (>)
13:07:38 <lambdabot> flip (>)
13:07:47 <hpaste>  gigamonkey pasted "my first Haskell code" at http://hpaste.org/4682
13:07:50 <FunctorSalad> :(
13:08:12 <gigamonkey> Okay, anything irredeemably stupid about that code?
13:08:31 <mauke> gigamonkey: yeah, you can just say data Point = Point Int Int deriving (Eq, Show, Ord) :-)
13:08:50 <pafcu> Saizan: x is a Float and f is a function which does some calculations and prints to the screen
13:09:04 <gigamonkey> mauke: sorry, what will that do?
13:09:14 <int-e> pafcu: does f x generate some huge data structure?
13:09:26 <mauke> gigamonkey: 'deriving' tells the compiler to automatically create instance definitions
13:09:28 <pafcu> Not huge, but large, yes
13:09:47 <gigamonkey> Which just coincidentally will happen to be the same as the ones I've written by hand?
13:09:56 <mauke> it will do the "obvious" thing for Eq and Ord but the Show instance will look different
13:10:00 <gbacon> gigamonkey: you'll prolly want to continue using your custom Show implementation
13:10:04 <FunctorSalad> mauke: how do these classes know how to derive themselves?
13:10:04 <pafcu> But it generates the same structure in both cases so the same amount of memory should be used
13:10:15 <mauke> FunctorSalad: it's hardcoded in the compiler
13:10:21 <int-e> pafcu: then this could happen: in sequence [f x, print "..."], f x  generates and consumes the data structure as it goes, so it can be garbage collected; in the second case, the compiler can keep it around for the second case.
13:10:22 <FunctorSalad> ok
13:10:34 <int-e> pafcu: because it is used twice
13:10:56 <int-e> pafcu: eh. keep it around for the second call, not case.
13:11:11 <mauke> hmm
13:11:22 <mauke> > GT `mappend` LT
13:11:24 <lambdabot>  GT
13:11:29 <mauke> > EQ `mappend` LT
13:11:30 <lambdabot>  LT
13:11:35 <pafcu> int-e: So can I force the garbage collector to toss the data between the calls?
13:12:00 <mauke> compare (Point x1 y1) (Point x2 y2) = compare x1 x2 `mappend` compare y1 y2
13:12:11 <pafcu> Because it seems a bit silly that printing the value once uses 6MB, but printing it twice uses 300+MB
13:12:36 <gbacon> http://www.haskell.org/onlinereport/derived.html
13:12:37 <lambdabot> Title: The Haskell 98 Report: Derived Instances
13:13:21 <faxathisia> @hoogle a -> (a,a)
13:13:22 <int-e> pafcu: not really. you have to convince the compiler to break sharing - -fno-cse may help, and/or introducing artificial data dependencies.
13:13:22 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
13:13:22 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
13:13:22 <lambdabot> Control.Monad.RWS.Lazy.execRWS :: RWS r w s a -> r -> s -> (s, w)
13:13:33 <faxathisia> @hoogle a -> (a -> b) -> (a,b)
13:13:33 <lambdabot> No matches, try a more general search
13:13:39 <ricky_clarkson> > (,) 5
13:13:40 <lambdabot>  Add a type signature
13:13:48 <ricky_clarkson> > (,) (5 :: Integer)
13:13:48 <lambdabot>  Add a type signature
13:13:49 <gigamonkey> Where's the best place to look up things such as mappend?
13:13:54 <ricky_clarkson> :t (,)
13:13:54 <lambdabot> forall a b. a -> b -> (a, b)
13:14:03 <faxathisia> @hoogle a -> (a -> a -> a) -> a
13:14:03 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
13:14:03 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
13:14:03 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
13:14:03 <mauke> @index mappend
13:14:04 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
13:14:09 <mauke> @docs Data.Monoid
13:14:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
13:14:10 <gbacon> gigamonkey: Hoogle!
13:14:19 <gigamonkey> @hoogle mappend
13:14:19 <lambdabot> Data.Monoid.mappend :: Monoid a => a -> a -> a
13:14:27 <ricky_clarkson> @src mappend
13:14:27 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:14:30 <faxathisia> :t s
13:14:31 <lambdabot> Not in scope: `s'
13:14:40 <ricky_clarkson> @src Data.Monoid.mappend
13:14:41 <lambdabot> Source not found. You type like i drive.
13:14:42 <gigamonkey> Hmmm. That wasn't quite what I was looking for.
13:14:46 <pafcu> int-e: What do you mean by artifical data dependency?
13:14:51 <nickchange> gigamonkey, go? you're a go player? :)
13:14:54 <mauke> ricky_clarkson: it's a method
13:14:59 <gigamonkey> nickchange: not really.
13:15:04 <faxathisia> @let s x y z = (x z (y z))
13:15:06 <lambdabot> Defined.
13:15:08 <faxathisia> :t s
13:15:09 <lambdabot> Not in scope: `s'
13:15:11 <ricky_clarkson> > (join (,)) 5
13:15:12 <lambdabot>  (5,5)
13:15:18 <gbacon> > z
13:15:18 <lambdabot>   Not in scope: `z'
13:15:31 <ricky_clarkson> faxathisia: Were you looking for join (,) ?
13:15:40 <gbacon> @pl s
13:15:40 <lambdabot> s
13:15:41 <faxathisia> :t let s x y z = (x z (y z)) in s
13:15:42 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
13:15:51 <faxathisia> sort of
13:15:55 <mauke> @pl let s x y z = (x z (y z)) in s
13:15:55 <lambdabot> ap
13:16:03 * EvilTerran is a go player
13:16:07 <faxathisia> :t second.join
13:16:07 <lambdabot> forall (a :: * -> * -> *) b d a1. (Arrow a, Monad (a b)) => a b (a b a1) -> a (d, b) (d, a1)
13:16:24 <Cale> gigamonkey: basically, any editor will do so long as it has two features: syntax colouring, and the ability to convert tabs to spaces.
13:16:35 <nickchange> evilterran, me too, kinda..
13:16:36 <gigamonkey> Cale: i'm there--Emacs seems to be working fine.
13:16:42 <Cale> cool :)
13:16:43 <EvilTerran> (10k KGS, last time i was ranked on there. haven't played there for a while, tho. not that that's even that good...)
13:16:48 <gigamonkey> Now I just need a place I can look up what mappend does
13:17:01 <EvilTerran> that depends on which instance you're using
13:17:06 <EvilTerran> ?type mappend
13:17:06 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:17:09 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html not good enough?
13:17:10 <lambdabot> http://tinyurl.com/y5qk9n
13:17:48 <gbacon> gigamonkey: mappend is a method
13:17:52 <int-e> pafcu: The basic idea is to say f a = [1..] instead of f = [1..] to make the compiler believe that the constant [1..] depends on some other value, a. It's harder to make it actually work though, because ghc is pretty clever at spotting unused function arguments and floating out constants.
13:18:12 <ricky_clarkson> gbacon: A method is resolved to a function at compile time?
13:18:31 <gigamonkey> mauke: I guess I'm not at the point where simply knowing the type of a function is enough to infer what it does
13:18:42 <gbacon> sure, but its behavior depends on the particular implementation
13:18:48 <mauke> mempty :: a    Identity of mappend
13:18:55 <mauke> mappend :: a -> a -> a   An associative operation
13:19:21 <mauke> the real problem is that there's no description of the Ordering instance
13:19:22 <pafcu> int-e: OK. I'll try something like that. Thanks for the help
13:20:12 <gigamonkey> mauke: yes, I'm looking at those docs but it doesn't mean much to me.
13:20:17 <ricky_clarkson> I think what gigamonkey needs is a description of the method that's more than "An associative operation".  What's it supposed to mean?
13:20:34 <int-e> pafcu: {-# NOINLINE f #-} may also help
13:20:39 <gbacon> gigamonkey: http://en.wikibooks.org/wiki/Haskell/MonadPlus#Relationship_with_Monoids
13:20:40 <lambdabot> http://tinyurl.com/ywaoj4
13:20:40 <gigamonkey> ricky_clarkson: yes, that's what I'm looking for.
13:20:43 <mauke> it means x `mappend` (y `mappend` z) == (x `mappend` y) `mappend` z
13:21:02 <mauke> gigamonkey: do you know Perl? :-)
13:22:31 <gigamonkey> mauke: used to.
13:22:40 <Cale> gigamonkey: Monoid is a general interface to associative operations which have identities. The canonical example of such a thing would be strings (or lists) under concatenation, with the empty string being the identity.
13:22:57 <Cale> gigamonkey: Another would be integers under addition, with 0 being the identity.
13:22:57 <FunctorSalad> gigamonkey: ah, now I know why your username seems familiar. /., no?
13:23:25 <mauke> I was thinking of { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } to compare tuples
13:23:33 <mauke> <=> is `compare`
13:24:01 <gigamonkey> What's the etymology of mappend? It's eluding me.
13:24:08 <faxathisia> @src mappend
13:24:08 <lambdabot> Source not found. Are you on drugs?
13:24:10 <faxathisia> :(
13:24:12 <mauke> monoid append
13:24:23 <faxathisia> @src [] mappend
13:24:23 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:24:27 <faxathisia> how do you do thiis?
13:24:35 <Cale> @src [] Monoid
13:24:35 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:24:42 <Cale> eh, I don't know :)
13:24:55 <Cale> It's just mappend = (++), mempty = []
13:25:16 <Cale> > [1,2,3] `mappend` [4,5]
13:25:17 <lambdabot>  [1,2,3,4,5]
13:25:18 <gigamonkey> So why do they call it append?
13:25:34 <faxathisia> > mappend True False
13:25:34 <lambdabot>   add an instance declaration for (Monoid Bool)
13:25:35 <lambdabot>     In the expression: mappen...
13:25:37 <Cale> Because of the intuition that it's something like list appending.
13:25:47 <FunctorSalad> is (++) the monoid operation?
13:25:53 <faxathisia> @instances Monoid
13:25:54 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
13:26:10 <gigamonkey> Hmmm, I'd think 'identity' and 'operation' would be more at the right level abstraction than 'mempty' and 'mappend'.
13:26:16 <gigamonkey> But that's fine. I get it now.
13:26:23 <Cale> Yeah, or something like  zero and (++)
13:26:42 <gigamonkey> Cale: but that also ties it to one particular Monoid.
13:27:03 <Cale> gigamonkey: it's pretty generic sounding to me :)
13:27:04 <faxathisia> > (mappend :: All Bool => Bool -> Bool -> Bool) True False
13:27:05 <FunctorSalad> @src Monoid
13:27:05 <lambdabot>      Type constructor `All' used as a class
13:27:07 <lambdabot> class Monoid a where
13:27:09 <lambdabot>     In the type `(All Bool) => Bo...
13:27:11 <lambdabot>     mempty  :: a
13:27:13 <lambdabot>     mappend :: a -> a -> a
13:27:17 <lambdabot>     mconcat :: [a] -> a
13:27:30 <mauke> @src All
13:27:31 <lambdabot> Source not found. Take a stress pill and think things over.
13:27:42 <faxathisia> > (mappend :: All => Bool -> Bool -> Bool) True False
13:27:42 <mauke> :t All
13:27:42 <lambdabot>      Type constructor `All' used as a class
13:27:42 <lambdabot>     In the type `(All) => Bool ->...
13:27:43 <lambdabot> Bool -> All
13:27:55 <mauke> > All True `mappend` All False
13:27:56 <lambdabot>  All {getAll = False}
13:28:03 <gbacon> gigamonkey: it's an abstract concept.. the behavior of mappend depends on the particular monoid
13:28:05 <faxathisia> ohh
13:28:05 <mauke> > Any True `mappend` Any False
13:28:06 <lambdabot>  Any {getAny = True}
13:28:41 <EvilTerran> (++) could be mappend, just like (.) could be fmap :D
13:28:53 <gigamonkey> gbacon: yeah, I'm there. I'm just whining about the name being less abstract than the abstraction it represents. ;-)
13:29:01 <gbacon> :-)
13:29:09 <mauke> what, like cdr? :-D
13:29:15 <FunctorSalad> omg :o
13:29:19 <gbacon> @type (+1) `mappend` (+3)
13:29:20 <lambdabot> forall a. (Num a, Monoid (a -> a)) => a -> a
13:29:23 <gbacon> mauke: boo-ya!
13:29:31 <gigamonkey> mauke: except CDR isn't abstract at all!
13:29:52 <mauke> why not?
13:30:04 <gigamonkey> Because it only applies to one very specific data type.
13:30:08 <FunctorSalad> gigamonkey: only slightly. any monoid is a quotient of a monoid of lists ;)
13:30:23 <mauke> (cdr (cons a b)) ==> b is pretty much the whole spec
13:30:59 <FunctorSalad> hmm though on second thought quotient monoids are not so nice. was thinking of groups
13:31:15 <gigamonkey> Right. It's not a name for an abstract operation that can be applied to numbers, lists, enumerated values, etc. the way mappend can.
13:31:29 <gigamonkey> Okay. I'm out for a while. Thanks for your help.
13:32:23 <FunctorSalad> btw are there any kind of quotient constructions in haskell or is this just too nasty computationally?
13:32:40 <ricky_clarkson> mauke: I guess you haven't got past the first 2 chapters of SICP. ;)
13:33:25 <mauke> ricky_clarkson: why?
13:34:12 <ricky_clarkson> conses in Scheme are mutable, so there's more contract than (eq? b (cdr (cons a b)))
13:34:16 <Cale> FunctorSalad: There used to be at some point.
13:34:24 <gbacon> > let f = (+1) `mappend` (+3) in f 0
13:34:25 <lambdabot>  Add a type signature
13:35:08 <mauke> pfft, mutability :-)
13:35:09 <Cale> FunctorSalad: In Miranda and early versions of Haskell, there were so-called 'laws' which could be used to normalise terms of some datatype automatically.
13:35:39 <Cale> Unfortunately "Miranda laws" are a little hard to search for ;)
13:36:50 <mapreduce> rickwy_clarksson: Very nice dear.
13:36:51 <FunctorSalad> Cale: hehe. well, I guess for general equivalence relations it's pretty hopeless
13:37:04 <gbacon> > ((+1) `mappend (+3)) 0
13:37:04 <lambdabot>  Parse error at "(+3))" (column 16)
13:37:09 <gbacon> > ((+1) `mappend` (+3)) 0
13:37:09 <lambdabot>  Add a type signature
13:38:39 <gbacon> > let f = (++"a") `mappend` (++"b") in f "123"
13:38:39 <lambdabot>  "123a123b"
13:38:50 <EvilTerran> "Malformed instance header"
13:39:10 <EvilTerran> it seems GHC can't cope with classes being used infix in instance declerations
13:39:35 <faxathisia> > let f = (`mappend` "a") `mappend` (`mappend` "b") in f "123"
13:39:36 <lambdabot>  "123a123b"
13:40:00 <gbacon> what am I doing wrong with the Num -> Num sections?
13:40:55 <gbacon> or am I misunderstanding how functions of type a -> a are monoids?
13:41:17 <allbery_b> > ((+1) `mappend` (+3)) (0::Int)
13:41:18 <lambdabot>   add an instance declaration for (Monoid Int)
13:41:18 <lambdabot>     In the expression: (((+ 1)...
13:41:23 <allbery_b> oh, right
13:41:30 <allbery_b> Int has two different ways to be a monoid
13:41:43 <EvilTerran> the endomorphism monoid is so on composition, i beliefe
13:41:45 <EvilTerran> *ve
13:41:51 <EvilTerran> so mappend should be (.)
13:42:05 <EvilTerran> > mconcat [(1:),(2:),(3:)] []
13:42:06 <lambdabot>  [1,2,3]
13:42:15 <gbacon> @type (+1) `mappend` (+3)
13:42:15 <lambdabot> forall a. (Num a, Monoid (a -> a)) => a -> a
13:42:22 <EvilTerran> > mconcat [(1:),reverse,(2:),(3:)] []
13:42:23 <gbacon> why isn't it just a -> a?
13:42:23 <lambdabot>  [1,2,3]
13:42:41 <EvilTerran> iunno
13:42:46 <gbacon> Haskell is hard... let's go shopping!
13:43:01 <Tac-Tics> hah
13:43:10 <vincenz> mapreduce: conses are going immutable again, plt already did the swithc in 4.0
13:43:11 <EvilTerran> ?instances Monoid
13:43:12 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
13:43:13 <Tac-Tics> Barbie Monad
13:43:22 <mapreduce> vincenz: Seriously?  Nice.
13:43:24 <EvilTerran> (a -> b)?
13:43:41 <php-barbie> Haskell is hard... let's go shopping!
13:44:06 * vincenz smacks gbacon upside the head with a tail-calling trout
13:44:07 <Tac-Tics> what is the MapReduce algorithm? I did a search on it, but nothing useful came up
13:44:14 <Tac-Tics> Just Google's one data report on how powerful it is
13:44:30 <Cale> http://cale.yi.org/autoshare/Laws%20in%20Miranda.pdf
13:44:44 <bos> Tac-Tics: it's not an algorithm, just an approach to programming.
13:45:03 <Tac-Tics> bos: what are the fundamental principles behind it?
13:46:09 <Tac-Tics> I know it has something to do with maximizing ref. transparency so you can parallelize(?) the crap out of large datasets
13:46:23 <Tac-Tics> but that is about all I know
13:46:29 <Heffalump> I think it's just about structuring computations in terms of map operations and reduce operations
13:46:57 <Heffalump> map has the obvious effect, reduce is applying some associative operation across a large number of data points to summarise them into one
13:48:14 <Cale> FunctorSalad: you might be interested in that PDF :)
13:48:46 * EvilTerran notes that he hasn't needed -XOverlappingInstances yet
13:48:47 <vincenz> probability density function?
13:49:03 <vincenz> map :: a -> [(a,b)] for many separate processors doing the map
13:49:12 <vincenz> reduce :: [(a,b)] -> [(a, [b])]
13:49:23 <vincenz> collecting results and bundling by key
13:49:29 <EvilTerran> altho i have used {-# LANGUAGE EmptyDataDecls, FlexibleContexts, FlexibleInstances, MultiParamTypeClasses #-}
13:49:38 <vincenz> but done in an asynch distributed fashion
13:49:40 <vincenz> so many map entities
13:49:45 <vincenz> writing to that list
13:50:06 * vincenz poofs 
13:50:09 <Heffalump> vincenz: huh?
13:50:19 <FunctorSalad> thanks Cale
13:50:43 <Heffalump> surely map would take some kind of list/array as input?
13:53:17 <faxathisia> ohh yeah
13:53:19 <faxathisia> I wanted to ask about this
13:53:44 <hpaste>  faxathisia pasted "drabness" at http://hpaste.org/4683
13:53:54 <faxathisia> do you think that.. there is some way to write this?
13:54:01 <faxathisia> (which doesn't actually involve what I did there)
13:54:10 <faxathisia> SourcePos is from Parsec
13:54:37 <Cale> faxathisia: You could use the record syntax
13:55:04 <Cale> and get extractors for the fields automatically
13:55:18 <faxathisia> oh that's great, so I can get rid of the entire tokenPosition
13:55:26 <gbacon> > let f = (+1) `mappend` (+2) in f 0
13:55:26 <lambdabot>  Add a type signature
13:55:39 <Cale> The matching is trickier though, but with or without record syntax, you could use {} to indicate that you don't care about the parameters.
13:56:25 <Cale> I suppose _ works just as well here, but if you later change the number of fields, you'll find yourself adding _'s.
13:57:42 <Cale> You could also add deriving Data
13:57:56 <faxathisia> I'd have to have SourcePos deriving Data too ?
13:58:00 <faxathisia> but it doesn't right now
13:58:31 <Cale> and then match False x y = toConstr x == toConstr y
13:59:03 <Cale> oh
13:59:08 <Cale> hmm, that's annoying
13:59:24 <Cale> Oh, if you're using 6.8.x, perhaps you can fix that :)
13:59:36 <faxathisia> yeah I am
14:00:08 <Cale> deriving instance Data SourcePos
14:00:52 <Cale> hmm, might not work
14:01:07 <Cale> I don't think the constructor is exported.
14:02:46 <faxathisia> is this possible CompoundOp' { tokenPosition :: SourcePos, affgkljsadff :: CompoundOperator }
14:02:53 <faxathisia> except without naming the affgkljsadff function?
14:05:17 <visof> > (\x.x^2 +1) 3
14:05:17 <lambdabot>  Parse error at ".x^2" (column 4)
14:05:30 <visof> (\x -> x^2) 3
14:05:39 <visof> > (\x -> x^2) 3
14:05:41 <lambdabot>  9
14:06:04 <faxathisia> > (^2) 3
14:06:08 <lambdabot>  9
14:06:09 <visof> what is the error of the first?
14:06:25 <faxathisia> . is function composition
14:06:38 <faxathisia> not syntax for lambda
14:06:43 <visof> oh
14:06:46 <visof> ok
14:06:58 <faxathisia> > (+1) . (^2) 3
14:06:58 <lambdabot>   add an instance declaration for (Num (a -> b))
14:07:01 <faxathisia> > (+1) . (^2) $ 3
14:07:02 <lambdabot>  10
14:07:04 <EvilTerran> faxathisia, don't think so; gotta be all record syntax or all not record syntax, iirc.
14:07:36 <EvilTerran> if you specifically don't want a name for the second one, i think you'll have to plate your boiler manually
14:07:57 <faxathisia> oh I am just calling it get<whatever> now
14:10:38 <faxathisia> oo I want to ask one more thing ? :D
14:11:17 <durka> ask
14:11:19 <durka> someone might answer
14:11:21 <allbery_b> clearly you should name the other accessor yhjulwwiefzojcbxybbruweejw
14:11:28 <faxathisia> lol
14:11:38 <faxathisia> I reserve that name for other purposes
14:12:31 <hpaste>  faxathisia pasted "interpreter comparison" at http://hpaste.org/4684
14:12:45 <faxathisia> yeah, what do you think is better?
14:13:03 <faxathisia> because I rewrite it using the techniques in that paper but I'm not sure if it's an improvement
14:13:06 <Cale> @yhjulwwiefzojcbxybbruweejw
14:13:06 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
14:13:18 <idnar> what the heck
14:13:29 <Cale> Magic :)
14:13:33 <czShadoW> Nice :)
14:13:33 <joed> heh
14:13:49 <mapreduce> That string's probably useful for java regexes.
14:13:50 <Tac-Tics> what command is that Cale?
14:14:08 <joed> mapreduce: It looks like it.
14:14:08 <Cale> @yhjulwwiefzojcbxybbruweejw
14:14:08 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
14:14:10 <Cale> @yhjulwwiefzojcbxybbruweejw
14:14:11 <lambdabot> Just 'J'
14:14:15 <Cale> heh
14:14:16 <idnar> @help yhjulwwiefzojcbxybbruweejw
14:14:17 <lambdabot> V RETURNS!
14:14:47 <idnar> @help yhj
14:14:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:14:53 <idnar> @yhj
14:14:54 <lambdabot> "\""
14:15:09 <Cale> It's crazy fixedpoint stuff which was from back where you could by accident access the string result of evaluating the Haskell code, from within the code you were using.
14:15:17 <allbery_b> back in the early days of lambdabot, it assigned the expression you asked it to @run to a variable "v".  so using "v" in that expressionhad interesting behavior
14:15:33 <allbery_b> the first cut at fixing that renamed it to yhjulwwiefzojcbxybbruweejw
14:15:34 <idnar> ah
14:16:08 <allbery_b> (modern LB  generates a new random variable name each time)
14:16:39 <idnar> > fix show
14:16:42 <EvilTerran> @v should reply with "people should not be afraid of their governments; governments should be afraid of their people" ;)
14:16:42 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
14:16:46 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:16:49 <Cale> oh, interesting, so there's a slight chance that it'll screw up every time?
14:17:09 <EvilTerran> well, produce nonsense rather than a compile error
14:17:44 <Cale> I suppose it's just a String, and there aren't many things in the library which are Strings.
14:18:03 <Cale> (so the chances of the result of a collision typechecking are low)
14:19:27 <gbacon> > (+1) `mappend` (+2) $ 0
14:19:29 <lambdabot>  Add a type signature
14:20:03 <gbacon> > (+1) . (+2) $ 0
14:20:19 <lambdabot>  thread killed
14:20:23 <gbacon> @botsnack
14:20:24 <lambdabot> :)
14:20:36 <gbacon> @type (+1) . (+2)
14:20:38 <lambdabot> forall a. (Num a) => a -> a
14:20:47 <gbacon> > (+1) . (+2) $ 3
14:20:49 <lambdabot>  6
14:20:55 <gbacon> > (+1) . (+2) $ 0
14:20:57 <lambdabot>  3
14:21:16 <gbacon> isn't mappend . for a->a functions?
14:21:36 <allbery_b> @src (->) mappend
14:21:36 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:21:40 <allbery_b> bah
14:21:44 <EvilTerran> it is for Endo
14:21:45 <idnar> @src ((->) r) mappend
14:21:46 <lambdabot> Source not found. You type like i drive.
14:21:58 <EvilTerran> dunno about naked functions
14:22:00 <gbacon> ?instances Monoid
14:22:02 <idnar> @src (-> r) mappend
14:22:05 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
14:22:05 <lambdabot> Source not found. My mind is going. I can feel it.
14:22:23 <conal> for functions, mempty = pure mempty, and mappend = liftA2 mappend
14:22:46 <conal> mempty _ = mempty ; mappend f g x = f x `mappend` g x
14:22:54 <allbery_b>  @src can't handle parenthesized classes or those with spaces, (->) is used for (-> r)
14:23:08 <idnar> ah
14:23:16 <gbacon> @src (->) mappend
14:23:17 <lambdabot> Source not found. There are some things that I just don't know.
14:23:51 <allbery_b> @src (->) fmap
14:23:51 <lambdabot> fmap = (.)
14:24:12 <gbacon> @src Monoid (->) mappend
14:24:12 <lambdabot> Source not found. Are you on drugs?
14:24:46 <gbacon> @type (+1) `mappend` (+2)
14:24:48 <lambdabot> forall a. (Num a, Monoid (a -> a)) => a -> a
14:25:06 <gbacon> > (+1) `mappend` (+2) $ 3
14:25:11 <lambdabot>  Add a type signature
14:27:09 <faxathisia> is there some place to put haskel code?
14:28:10 <idnar> @type (+1) `mappend` (+2) $ 3
14:28:13 <lambdabot> forall a. (Monoid (a -> a), Num a) => a
14:28:28 <idnar> > (+1) `mappend` (+2) $ 3 :: Int
14:28:30 <lambdabot>   add an instance declaration for (Monoid Int)
14:30:32 <durka> faxathisia: you mean hpaste?
14:30:39 <faxathisia> no
14:30:58 <gbacon> > (+1) `mappend` (+2) $ (3::Int)
14:31:00 <lambdabot>   add an instance declaration for (Monoid Int)
14:31:10 <gbacon> :t 3
14:31:13 <lambdabot> forall t. (Num t) => t
14:31:27 <idnar> > (+1) `mappend` (+2) $ ()
14:31:27 <lambdabot>   add an instance declaration for (Num ())
14:31:39 <gbacon> > (+1) `mappend` (+2) $ mempty
14:31:39 <lambdabot>  Add a type signature
14:32:21 <idnar> > (1:) `mappend` (2:) $ [5]
14:32:23 <lambdabot>  [1,5,2,5]
14:32:48 <gbacon> > (+(1::Int)) `mappend` (+2) $ 3
14:32:49 <lambdabot>   add an instance declaration for (Monoid Int)
14:33:20 <idnar> gbacon: you end up with 4 `mappend` 5
14:33:44 <Ben`> how can I turn something like "(b (i (o foo)) bar)" into "[b][i][o]foo[/o][/i]bar[/b]"?
14:34:07 <gbacon> > (+) `mappend` (+) 1 2
14:34:08 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
14:34:35 <Ben`> should I use Parsec?
14:34:42 <faxathisia> yes
14:34:46 <faxathisia> Parsec is fine
14:34:46 <gbacon> :t (+) `mappend` (+)
14:34:49 <lambdabot> forall a. (Num a, Monoid (a -> a -> a)) => a -> a -> a
14:35:08 <idnar> > let b = tag 'b', i = tag 'i', o = tag 'o', tag x s = "[" + x + "]" + s + "[/" + x + "]" in (b (i (o foo)) bar)
14:35:08 <lambdabot>  Parse error at "," (column 16)
14:36:04 <LoganCapaldo> > let { o = ("[o]"++) . (++"[/o]") ; foo = "foo" } in (o foo)
14:36:07 <lambdabot>  "[o]foo[/o]"
14:36:23 <EvilTerran> hm...
14:36:30 <idnar> > let { b = tag 'b'; i = tag 'i'; o = tag 'o'; tag x s = "[" + x + "]" + s + "[/" + x + "]" } in (b (i (o foo)) bar)
14:36:33 <lambdabot>   Not in scope: `bar'
14:36:34 <gbacon> @pl let { o = ("[o]"++) . (++"[/o]") ; foo = "foo" } in (o foo)
14:36:34 <lambdabot> (line 1, column 5):
14:36:34 <lambdabot> unexpected "{"
14:36:34 <lambdabot> expecting natural, identifier or "in"
14:36:53 <idnar> > let { b = tag 'b'; i = tag 'i'; o = tag 'o'; tag x s = "[" + x + "]" + s + "[/" + x + "]" } in (b (i (o "foo")) "bar")
14:36:54 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
14:37:01 <idnar> oops
14:37:03 <faxathisia> this is easier with ["b",["i",["o","foo"]]."bar"]
14:37:12 <faxathisia> actually.
14:37:12 <faxathisia> :t ["b",["i",["o","foo"]],"bar"]
14:37:14 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
14:37:14 <lambdabot>     In the expression: "i"
14:37:14 <lambdabot>     In the expression: ["i", ["o", "foo"]]
14:37:19 <faxathisia> that is not a good idea
14:37:28 <idnar> that's not going to work anyway
14:37:42 * idnar gives up
14:37:48 <faxathisia> data Cons a = Nil | Cons { car :: Cons a ; cdr :: Cons a }
14:37:55 <faxathisia> then write a bunch of list operators..
14:37:59 <Tac-Tics> why are we trying to :t heterogeneous containers?
14:38:36 <LoganCapaldo> { car :: a, cdr :; Cons a } rather
14:38:44 <LoganCapaldo> s/;/:/
14:39:06 <idnar> @src [a]
14:39:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:39:07 <faxathisia> oh..
14:39:07 <faxathisia> data Cons a = Nil | Cons { car :: Either (Cons a) a, cdr :: Either (Cons a) a }
14:39:08 <idnar> @src []
14:39:09 <lambdabot> data [] a = [] | a : [a]
14:39:24 <idnar> aren't those the same thing?
14:39:46 <nanothief> idnar: i'm not sure if this will help: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
14:39:47 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
14:41:20 <gbacon> idnar: so what's a (non-list) example of combining two a->a functions with mappend?
14:41:49 <idnar> gbacon: well, a needs to have a Monoid instance
14:42:48 <idnar> < conal> mempty _ = mempty ; mappend f g x = f x `mappend` g x
14:43:34 <idnar> nanothief: ok, but this is "data Cons a" not "data Cons"; am I missing something?
14:44:13 <monochrom> instance Monoid (Cons a) where ... ?
14:44:21 <Yokisho> is haskell the future ?
14:44:51 <nanothief> idnar: i'm not sure what you want (i joined too late), but what I gave lets you make hetergenious containers
14:44:56 <monochrom> I need to look at Monoid carefully before I can confirm what I just said.
14:44:59 <nanothief> (if thats what you want)
14:45:13 <idnar> nanothief: oh, right; I misunderstood what you were responding to
14:45:26 <monochrom> Ah indeed, instance Monoid (Cons a).
14:46:36 <Red> anyone know of a good resource for looking up random syntax?
14:46:55 <faxathisia> uh do you mean haskell syntax?
14:46:59 <Red> yeah
14:47:07 <Red> *random haskell syntax
14:47:08 <faxathisia> I check here http://www.haskell.org/onlinereport/
14:47:08 <lambdabot> Title: The Haskell 98 Language Report
14:47:14 <faxathisia> and just like search for stuff too
14:48:04 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm is also a good presentation of haskell syntax.
14:48:29 <Red> just looking for odd bits here and there like to find the absolute value of something would it be abs or what?
14:48:40 <faxathisia> :t abs
14:48:43 <lambdabot> forall a. (Num a) => a -> a
14:48:48 <faxathisia> yes
14:49:04 <Red> cool
14:49:05 <Red> hmm
14:49:05 <faxathisia> if you are in ghchi
14:49:06 <faxathisia> :browse
14:49:10 <faxathisia> shows you a bunch of stuff
14:49:11 <monochrom> That goes into the libraries. http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:49:39 <monochrom> Most things are in libraries, not "builtin" core language. Unlike other substandard languages.
14:49:51 <monochrom> This is why Haskell is flexible.
14:50:10 <davidL> I am using type synonyms to make a program more readable, can a lot of type synonyms affect performance?
14:50:47 <monochrom> No performance penalty.
14:51:29 <davidL> thanks
14:51:42 <osfameron> though haskell is so flexible you could probably write a compiler that *did* have such a penalty if you really wanted! ;-)
14:51:46 <Red> now i've got to learn enough haskell to know where abouts to look...
14:53:59 <gbacon> so does the statement about a->a functions in http://www.haskell.org/all_about_monads/html/writermonad.html#definition need a qualification?
14:54:01 <lambdabot> Title: The Writer monad, http://tinyurl.com/2ctzq6
14:54:33 <gbacon> really that it ought to be (Monoid a, Monoid b) => Monoid (a -> b)
14:55:11 <gbacon> no, sorry, Monoid b => Monoid (a -> b)
14:55:19 <monochrom> No, a->a is correct.
14:56:40 <monochrom> Here is how "a->a is a monoid". Need some GHC extensions if you actually get it to compile. But logically correct:
14:57:17 <monochrom> instance Monoid (a -> a) where mempty = id; mappend = (.)
14:57:49 <Red> what was the symbol if you want to just comment something out?
14:58:11 <durka> --
14:58:17 <Red> trying to learn 3 different programming languages at the same time plays merry hell with your minor syntax
14:58:18 <monochrom> Observe that, for example, given f,g,h:a->a, f.id = id.f = id, (f.g).h = f.(g.h). And of course also that id, f.g are of the right type: a->a.
14:58:27 <faxathisia> Red: Which 3?
14:58:34 <durka> Red: -- is one-line comment
14:58:43 <Red> fax: haskell, matlab, fortran
14:58:49 <monochrom> {- block comment -}  like /* in C */
14:58:57 <Red> tanks
14:59:08 <monochrom> But {- -} is even better than C.  {- {- -} -} is valid. :)
14:59:10 <faxathisia> you can nest haskell ones though
14:59:11 <faxathisia> yes
14:59:17 <faxathisia> so stupid in C..
14:59:41 <monochrom> C was specified when it was too much trouble to write a sophisticated parser. Understandable.
15:00:00 * faxathisia wonders how they manage to have ()'s in C then..
15:00:06 <monochrom> But of course this also shows its old age. Not intended for new generations.
15:00:08 <Red> i don't like having to write ; at the end of every line :(
15:00:16 <Red> its the easiest thing to miss
15:00:28 <monochrom> They want to keep the comment-eliminater regex.
15:01:02 <Red> oh yeah what was it to change your name on irc?
15:01:04 <monochrom> It's understandable because you wanted the lexer to get rid of comments in addition to lexing.
15:01:26 <mapreduce> Red: /nick newname
15:01:36 <Big_Red> there we go
15:01:59 <gbacon> monochrom: ghc is complaining about overlapping monoid instances
15:02:11 <monochrom> Yes, that is foretold.
15:02:24 <gbacon> after I enabled glasgow-exts
15:02:31 <basti_> how can i learn more about "characteristic polynomials" of datatypes?
15:04:18 <monochrom> Oh I see. Data.Monoid already defines instance Monoid b => Monoid (a->b) to do something else.
15:04:34 <monochrom> But do look at Endo.
15:09:15 <gbacon> :t (Endo (+1)) `mappend` (Endo (+2))
15:09:17 <lambdabot> forall a. (Num a) => Endo a
15:10:14 <monochrom> If you apply appEndo to that, you get the function that maps n to (n+1)+2.
15:10:52 <gbacon> :t appEndo (Endo (+1)) `mappend` (Endo (+2))
15:10:53 <lambdabot>     Couldn't match expected type `a -> a'
15:10:53 <lambdabot>            against inferred type `Endo a1'
15:10:53 <lambdabot>     In the second argument of `mappend', namely `(Endo ((+ 2)))'
15:11:11 <monochrom> Need parentheses!
15:11:27 <gbacon> :t appEndo $ (Endo (+1)) `mappend` (Endo (+2))
15:11:28 <lambdabot> forall a. (Num a) => a -> a
15:12:00 <gbacon> > appEndo $ (Endo (+1)) `mappend` (Endo (+2)) $ 3
15:12:01 <lambdabot>  Couldn't match expected type `a -> b'
15:12:18 <xerox> > Endo (+1) `mappend` Endo (+2) `appEndo` 1
15:12:18 <lambdabot>  4
15:12:31 <faxathisia> oh yeah
15:12:36 <gbacon> zoiks
15:12:41 <faxathisia> Has anyone understood Agda2 typechecking algorithn?
15:12:42 <idnar> > appEndo ((Endo (+1)) `mappend` (Endo (+2))) $ 3
15:12:42 <lambdabot>  6
15:12:58 <xerox> > (+1) . (+2) $ 1
15:12:58 <lambdabot>  4
15:14:15 <faxathisia> It'\s written in haskell
15:14:19 <faxathisia> but I can't actually read it :/
15:15:13 <gbacon> not so elegant
15:18:03 <Cin> is it possible to express a thunk with lambda notation, and if so, how?
15:18:24 <LoganCapaldo> define thunk
15:18:44 <Cin> a function that takes no arguments but returns something
15:18:51 <Cin> (in this context)
15:18:53 <faxathisia> thunk = (\ __ -> [whatever]) ()
15:18:59 <faxathisia> It's lazy evaluation
15:19:11 <Cin> ah, thanks
15:19:16 <monochrom> In fact [whatever] is already a thunk.
15:19:24 <faxathisia> yeah..
15:19:25 <FunctorSalad> @type const "something"
15:19:25 <lambdabot> forall b. b -> [Char]
15:19:35 <FunctorSalad> oh, no arguments
15:19:37 <LoganCapaldo> "thunk"
15:19:47 <faxathisia> you can use _ instead of __ actually
15:19:50 <monochrom> Everything you type in is a thunk.
15:19:57 <faxathisia> but yeah, this is pointless
15:20:01 <faxathisia> don't use \
15:20:41 <Zao> Out of curiosity, what does __ do? It's a bit hard to google for.
15:20:51 <faxathisia> Zao: same as foobar
15:20:54 <LoganCapaldo> it's just a placeholder
15:21:01 <faxathisia> though I sometimes define __ = __
15:21:02 <monochrom> placeholder for an argument you don't care about.
15:21:05 <faxathisia> then use it instead of undefined
15:30:06 <Big_Red> i'm just reading through some psuedocode that uses cons a lot and i was wondering if this was applicable in haskell - are lists broken down in to cons item (cons item (etc)) or what?
15:30:36 <monochrom> Yes.
15:30:45 <Big_Red> and is it called cons?
15:30:49 <mauke> no, (:)
15:31:03 <mauke> > (:) 1 ((:) 2 ((:) 3 []))
15:31:03 <lambdabot>  [1,2,3]
15:31:14 <Cin> hm. the context has now changed. i have a function `foo' of type `A -> B -> IO Bool', i want to create a closure of type `IO Bool', in which `foo' is called with some values in scope
15:31:19 <Cin> can someone suggest a way to do this?
15:31:27 <mauke> foo a b
15:31:42 <Big_Red> mauke: thanks
15:31:55 <buddapeople> is there a wiki or something for this? my n00b ass needs help
15:34:48 <Big_Red> yes? haskell wiki or the libraries http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
15:34:52 <LoganCapaldo> Cin if by closure you mean function + an environment, something of type IO Bool is not a function...
15:35:00 <Big_Red> or the online report http://www.haskell.org/onlinereport/
15:35:00 <lambdabot> Title: The Haskell 98 Language Report
15:35:34 <buddapeople> I didn't see haskell.org in the info, my b
15:35:57 <Big_Red> http://haskell.org/
15:35:57 <lambdabot> Title: Haskell Community Server
15:36:04 <Big_Red> ah
15:36:05 <Big_Red> :)
15:36:06 <Big_Red> no worries the
15:36:07 <Big_Red> n
15:36:46 <buddapeople> lol
15:37:09 <Cale> Cin: Something like (foo, (a,b)) :: (A -> B -> IO Bool, (A,B))? Or do you just want to apply foo to its parameters? (We wouldn't normally call that a closure, but it might be implemented as a closure internally.)
15:42:38 <Cin> cale: ah. a compile error had mislead me; i thought that i was passing the wrong type of thunk when i was really passing too few arguments. sorry
15:44:53 <Cin> cale: incase you wanted to know, passing something to timeoutAdd (from the Gtk2Hs API), which is of tye `IO Bool -> Int -> IO HandlerId'... i was missing the Int.
15:45:42 <benny99> hm, are "multiple where" allowed?
15:45:47 <Cale> benny99: yeah
15:46:09 <Cale> benny99: Functions defined inside where clauses can themselves have where clauses.
15:46:21 <benny99> like "bla a b = fu; where fu = a + c; where c = b*b" ?
15:46:30 <benny99> thanks :)
15:46:35 <Cin> cale: is that rule limited to functions?
15:46:46 <Cale> no, it applies to pattern bindings as well
15:46:49 <mauke> bla a b = fu where fu = a + c; c = b*b -- also works
15:46:53 <benny99> oh, wait
15:47:10 <faxathisia> a -> b -> c is a different type from b -> c
15:47:24 <faxathisia> (also bear in mind -> is right assoc)
15:47:39 <benny99> "bla a b = foo1 + foo2; where n = a+b; foo1 = n+1;  foo2 = n*n" <-- what about that?
15:47:53 <mauke> no ; before where
15:48:02 <benny99> ok, thanks :)
15:48:05 <mauke> the rest looks ok
15:48:45 <monochrom> case x of { Just y -> z where {z=y*y}; Nothing -> 0 }  is possible.
15:49:40 <monochrom> Note that it is necessary because the scope of y is only so much.
15:50:15 <monochrom> Use indentation to control where is where. :)
15:51:17 <Eelis> xerox: you there?
15:57:41 <benny99> hm.. toInteger (sqrt 20) does not work -- how could I do what I want :-[ ?  -- (I want to truncate that floating point number to an Integral)
15:58:18 <monochrom> truncate
15:59:27 <mauke> > truncate (sqrt 20)
15:59:28 <lambdabot>  4
15:59:43 <benny99> nah, that's too easy :o
15:59:47 <gbacon> is it worth the effort to wrap getEnv with ErrorT?
15:59:48 <faxathisia> :t isqrt
15:59:48 <lambdabot> Not in scope: `isqrt'
15:59:53 <faxathisia> :(
16:00:11 <benny99> ;) no, it's ok
16:00:11 <benny99> thanks :)
16:00:48 <gbacon> I'm trying to avoid scattering `catch` all over the place
16:00:54 <gbacon> @karma- boilerplate
16:00:54 <lambdabot> boilerplate's karma lowered to -1.
16:01:32 <FunctorSalad> @help karma
16:01:32 <lambdabot> karma <polynick>. Return a person's karma value
16:02:04 <FunctorSalad> does that actually do anything?
16:02:13 <Eelis> no, it's complete bogus.
16:02:25 <gbacon> @karma boilerplate
16:02:26 <lambdabot> boilerplate has a karma of -1
16:02:33 <gbacon> @karma- boilerplate
16:02:34 <lambdabot> boilerplate's karma lowered to -2.
16:03:04 <gbacon> it's a big Data.Map String Int
16:03:10 <gbacon> in concept at least
16:04:28 <allbery_b> safeGetEnv e d = getEnv e `mplus` d -- ?
16:05:21 <allbery_b> (well, secretly that *is* `catch`, but why "all over the place"?  just wrap it once)
16:05:43 <allbery_b> hm, make that getenv e `mplus` return d
16:05:49 <gbacon> I have multiple mandatory environment variables plus some optional
16:06:23 <gbacon> it'd be nice to mention all the missing variables in the error output
16:07:25 <conal> does anyone know how to encourage finalizers to run promptly?
16:08:17 <gbacon> I tried wrapping it in ErrorT, but I'm having trouble intercepting the exception
16:09:12 <mauke> fmap Just (getenv x) `catch` const (return Nothing)
16:11:11 <Saizan> liftIO m = fmap Right `catch` Left . show -- or something?
16:11:40 <ctkrohn> hey, anyone here involved with yhc?  just wondering if there were any plans to make it self-hosting?  seems like you need ghc to compile it now
16:11:43 <ctkrohn> still a nifty project though
16:14:21 <gbacon> mauke: thanks.. how do I then cut down on the boilerplate of checking Just versus Nothing?
16:15:37 <benny99> is there a standard-fucntion for solving quadratic equations in the prelude ?
16:15:46 <Cale> nope
16:15:52 <benny99> :o hmpf
16:16:29 <gbacon> been reading http://www.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons -- more like being tantalized by
16:16:31 <lambdabot> Title: Haskell hacking, http://tinyurl.com/2qxb8e
16:16:34 <Cale> O noes! You'll have to remember the quadratic formula!
16:17:45 <FunctorSalad> isn't there some interface to some CAS?
16:23:08 <benny99> I want to calculate "sqrt (a + b/c)" where b and c are Integrals, how could I make that work?
16:23:16 <benny99> sqrt (1/4 + b/c)
16:23:31 <benny99> sqrt (1/4 + (div b c)) does still not work
16:23:57 <Saizan> benny99: fromIntegral is your friend
16:24:15 <benny99> thanks :)
16:24:33 <Saizan> ?type fromIntegral
16:24:33 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:24:51 <mwc> benny99: first you need to decide if you want to perform integer or FP division with 'b/c'
16:25:36 <mwc> (fromIntegral $ div b c ) or (fromIntegral b / fromIntegral c)
16:26:35 <Cale> Most likely what you want to do is convert all three first.
16:27:20 <Cale> So,  sqrt(a' + b'/c'), and then in the where clause, [a',b',c'] = map fromIntegral [a,b,c] or something like that.
16:28:22 <FunctorSalad> maybe you can avoid forcing them to be integrals in the first place?
16:28:36 <FunctorSalad> (just asking in case you did something like a :: Integral)
16:30:41 <Big_Red> does one traditionally start all functions
16:30:46 <Big_Red> with a capital letter?
16:30:52 <Big_Red> or was it variables?
16:30:56 <Big_Red> or neither :S
16:30:56 <mauke> unlikely
16:31:04 <mauke> variables must start with a lowercase letter
16:31:12 <mauke> only constants get uppercase letters
16:31:20 <Big_Red> and functions?
16:31:24 <Big_Red> lower case too?
16:31:30 <mauke> wrong question
16:31:38 <LoganCapaldo> functions are variables :)
16:31:43 <Big_Red> thought so...
16:31:50 <mauke> variables can be bound to functions
16:32:21 <FunctorSalad> exactly what kind of thing is x here? "data List x where Nil :: List x"
16:32:31 <LoganCapaldo> type var
16:32:33 <mauke> type variable
16:32:41 <FunctorSalad> kinda both a type variable and a plain value
16:32:46 <mauke> and I think there are two different x's here
16:32:51 <Saizan> FunctorSalad: well, there it could be anything, but it's assumed * from ghc
16:33:54 <Saizan> "kind of thing" not kind :D
16:34:22 <FunctorSalad> we need some natural-language word equivalent to type that doesn't have some technical meaning
16:34:36 <FunctorSalad> I propose "dude"
16:34:42 <FunctorSalad> :)
16:35:00 <Saizan> yeah, they are two distinct x there, i prefer kindsignatures, and write data List :: * -> * where Nil :: List x
16:35:03 <Cale> Big_Red: Data constructors start with uppercase letters, functions and other values start with lowercase letters. This is important for pattern matching.
16:35:23 <Big_Red> cale: thats what i was looking for - thanks
16:35:34 <FunctorSalad> Saizan: hmm ok
16:36:42 <FunctorSalad> actually this part confused me more  "Cons :: x -> List x -> List x" because x kinda looked like the concrete value you put in, but now I think it means "for any type x, Cons is a function that maps a x and a List x to a List x"
16:37:37 <FunctorSalad> so Cons actually isn't defined anywhere, but we just have some sort of free algebra
16:37:40 <Saizan> x is a type variable
16:38:06 <Big_Red> salad: if you have a list [1,2,3,4] then cons is taking the 1, then taking the [2,3,4] then giving [1,2,3,4] - a number, a list of numbers and a list of numbers
16:38:27 <Big_Red> here x is number
16:38:33 <FunctorSalad> Big_Red: I know what Cons does in principle ;) the confusion was about types and syntax
16:38:36 <Saizan> Cons is defined there, and yes, it's a "term" that you can take apart getting the two fields it contains, one of type x and one of tame List x
16:38:55 <Big_Red> what's the url for putting things for people to see?
16:39:14 <mrd> hpaste.org
16:39:20 <Saizan> s/tame/type/
16:40:54 <FunctorSalad> so our universe is like the term algebra over the signature Nil, Cons with plain haskell values as base elements?
16:41:16 <FunctorSalad> and Cons 1 evaluates to the term Cons 1
16:41:43 <FunctorSalad> (+ some type restrictions)
16:41:44 <benny99> n8 :)
16:42:36 <Saizan> FunctorSalad: Cons 1 :: List x -> List x, and you can't inspect it, but yes
16:43:05 <FunctorSalad> Saizan: oops yes, I meant something like Cons 1 Nil
16:43:29 <hpaste>  Big_Red pasted "argument functions taking arguments" at http://hpaste.org/4685
16:43:40 <Big_Red> quick question there if anyone's got a sec
16:47:04 <Saizan> Big_Red: you're asking if function func a b tol parses as function (func a) b tol ?
16:47:14 <Big_Red> yeah
16:47:18 <Big_Red> which i don't want it to do
16:47:51 <Saizan> no, func is passed as an argument to function as it is
16:48:13 <Big_Red> so do i need to be explicit and say function (func) a b tol or is that implied then
16:48:21 <Saizan> implied
16:48:27 <mauke> (x) is always x
16:48:36 <Saizan> you've to be explicit if you want function (func a) b tol
16:48:37 <Big_Red> cool
16:53:46 <EvilTerran> ?type cast
16:53:47 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
16:53:53 <Cale> what?
16:53:57 <EvilTerran> ?type cast ?x
16:53:58 <lambdabot>     Ambiguous type variable `a' in the constraint:
16:53:58 <lambdabot>       `Typeable a' arising from use of `cast' at <interactive>:1:0-6
16:53:58 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
16:54:07 <Cale> (func a) b tol = func a b tol
16:54:09 <EvilTerran> ?type cast (undefined :: Int)
16:54:10 <lambdabot> forall b. (Typeable b) => Maybe b
16:54:18 <EvilTerran> I thought so
16:54:19 <Cale> application associates to the left
16:54:51 <EvilTerran> ?type fromJust (cast (undefined :: Int))
16:54:52 <lambdabot> forall a. (Typeable a) => a
16:56:15 <Saizan> Cale: "function" was the name of a function, there
16:56:27 <EvilTerran> ?type fromJust (cast (undefined :: Int)) :: Bool
16:56:27 <lambdabot> Bool
16:56:36 <EvilTerran> muhaha
16:57:01 <Saizan> evil!
16:57:19 <EvilTerran> "Couldn't match expected type `forall a. (Typeable a) => a' against inferred type `Bool'"?
16:57:23 <EvilTerran> humbug!
16:57:29 <Cale> Saizan: ah
17:00:38 <koko775> hey
17:00:47 <koko775> i'm just learning haskell and i need some really basic help
17:00:59 <Big_Red> join the club koko ;)
17:01:00 <EvilTerran> these rank N types are hard =/
17:01:00 <koko775> can anyone spare a moment, please?
17:01:07 <EvilTerran> don't ask to ask, ask! :)
17:01:15 <cjb> Do people here use Yi much, or is it really basic still?
17:01:44 <EvilTerran> "Cannot match a monotype with `forall a. (Typeable a) => a'" >.<
17:01:51 <koko775> so exercise 3.6 in yaht asks to write a function that takes a list of pairs of length >= 2 and return the first component of the second element in the list
17:01:51 <faxathisia> koko775: I can, I may not be able to answer you though :p
17:01:59 <koko775> i've given it a few tries
17:02:00 <Saizan> cjb: we mostly use emacs or vim
17:02:03 <koko775> and i just get parsing errors
17:02:16 * EvilTerran uses SciTE
17:02:21 <faxathisia> [(a,b,c),(d,e,f)] -- something like this?
17:02:31 <EvilTerran> list of pairs
17:02:36 <faxathisia> pair of length >= 2 is a strange concept
17:02:38 <cjb> Saizan: but why?
17:02:49 <EvilTerran> faxathisia, [list of pairs] of length >= 2
17:02:50 <koko775> given [(5,'b'),(1,'c'),(6,'a')] it should return 1
17:03:06 <EvilTerran> koko775, what do you have so far?
17:03:29 <koko775> a few tries - let fun list = fst (snd list) is one of them
17:03:51 <EvilTerran> ... is this at the ghci prompt?
17:03:54 <Saizan> cjb: they are good editors and you don't really need a fancy IDE for haskell, just syntax highlighting, for emacs there's haskell-mode that integrates well with ghci
17:03:55 <koko775> see, the thing about the tutorial is it doesn't go over how to define a function at all before the exercises
17:03:56 <koko775> yeah
17:04:07 <EvilTerran> do you know of pattern matching?
17:04:12 <cjb> Saizan: I use emacs -- just wondering why people aren't using Yi, since I was gonna try it out myself.
17:04:19 <faxathisia> > [(5,'b'),(1,'c'),(6,'a')] !! 0
17:04:20 <faxathisia> > [(5,'b'),(1,'c'),(6,'a')] !! 1
17:04:21 <lambdabot>  (5,'b')
17:04:21 <lambdabot>  (1,'c')
17:04:24 <koko775> i've seen code that does it but how to do it doesn't come to mind
17:04:27 <faxathisia> you can extract elements in this way
17:04:28 <EvilTerran> @src fst
17:04:28 <lambdabot> fst (x,_) =  x
17:04:37 <EvilTerran> that's a pattern-match on a tuple
17:04:46 <EvilTerran> ?src head
17:04:47 <lambdabot> head (x:_) = x
17:04:47 <lambdabot> head []    = undefined
17:04:58 <EvilTerran> that's a pattern-match on a list
17:05:26 <koko775> that gives me a parse error :/
17:05:35 <koko775> the head code
17:05:43 <Saizan> cjb: ah, k, well i think you can try and see, but from what i heard is not a mature application
17:05:54 <koko775> and the fst code as well
17:05:56 <EvilTerran> > let f [x] = "one element"; f [x,y] = "two elements"; f [] = "no elements :("; f _ = "lots of elements! :D" in map f ["", "foo", "ab", "c"]
17:05:56 <lambdabot>  ["no elements :(","lots of elements! :D","two elements","one element"]
17:06:19 <EvilTerran> ^^ more pattern-matching on lists
17:06:35 <EvilTerran> okay, well, what hte definition for fst means is
17:07:36 <EvilTerran> "when trying to apply fst to a pair, call the first item in the pair x, throw away the second item (that's what _ means in a pattern; we don't care about this value), and replace the function application (fst <blah>) with the RHS of the =, ie "x")
17:08:28 <koko775> okay, well the tutorial hasn't gone over that yet, so without using pattern matching, how would I do this?
17:08:44 <faxathisia> koko775: what are you doing?
17:08:44 <EvilTerran> has it covered (!!) yet?
17:08:46 <koko775> with map, filter, the folds, fst, and snd
17:08:47 <faxathisia> it doesn't make sense
17:08:52 <faxathisia> you want to compare?
17:08:54 <faxathisia> or just extract
17:08:56 <koko775> going through "yet another haskell tutorial"
17:08:57 <Caelum> hey guys, I'm trying an example from the book and it won't compile in ghci :( http://hpaste.org/4686
17:09:37 <sjanssen> Caelum: you're missing an = in the line above 'where'
17:09:51 <Caelum> doh...thanks!
17:10:36 <EvilTerran> koko775, you've covered the functions head, tail, and fst, right?
17:10:36 <Pieman> koko775, you've covered the functions head, tail, and fst, right? DESU DESU 4CHAN.ORG
17:10:51 <ricosecada> Hi, is haskell not standardized?
17:10:54 <koko775> yeah
17:11:03 <koko775> oops, did I fail to mention that?
17:11:05 <koko775> hmm
17:11:09 <koko775> lemme take another whack at it
17:11:19 <Cale> ricosecada: It's standardised, but there's an ongoing effort to update the standard.
17:11:33 * EvilTerran pokes Igloo, and any other +o's who happen to be about
17:11:38 <ricosecada> Cale, is it an iso standard, and where do I locate it?
17:11:38 <Pieman> Cale, is it an iso standard, and where do I locate it? DESU DESU 4CHAN.ORG
17:11:38 <koko775> my brain's fried, it's taken me a week to even begin to recover from finals
17:11:39 <Pieman> my brain's fried, it's taken me a week to even begin to recover from finals DESU DESU 4CHAN.ORG
17:11:47 --- mode: ChanServ set +o Cale
17:11:59 <faxathisia> @report
17:12:00 <lambdabot> ()
17:12:00 <Pieman> @report DESU DESU 4CHAN.ORG
17:12:00 <Pieman> () DESU DESU 4CHAN.ORG
17:12:00 <lambdabot> DESU DESU 4 CHAN.ORG
17:12:00 <Pieman> DESU DESU 4 CHAN.ORG DESU DESU 4CHAN.ORG
17:12:01 --- mode: Cale set -b *!*@77.54-242-81.adsl-dyn.isp.belgacom.be
17:12:01 <hpaste>  Big_Red pasted "Integration" at http://hpaste.org/4687
17:12:02 <Pieman> Big_Red pasted "Integration" at http://hpaste.org/4687 DESU DESU 4CHAN.ORG
17:12:06 --- mode: Cale set +b *!*@c-76-119-52-236.hsd1.ma.comcast.net
17:12:22 <faxathisia> @where report
17:12:22 <lambdabot> http://www.haskell.org/onlinereport/
17:12:37 <Cale> Why are there limits on the lengths of channel ban lists?
17:12:46 <EvilTerran> Igloo, you've left your +o on
17:12:57 <Cale> (well, why are there such insanely small limits, rather)
17:13:09 <EvilTerran> can't you set up longer lists thru chanserv?
17:14:03 <Big_Red> can anyone think of a reason why this progam wouldn't work?
17:14:05 <koko775> ah hah. this works: let fun x = fst (head (tail thelist))
17:14:21 <Big_Red> trying my hand at actually doing some programming rather than just reading about it
17:14:29 <koko775> though i don't get why I had to use fst and not head on (1,'a')
17:14:33 <EvilTerran> ?type fst
17:14:34 <lambdabot> forall a b. (a, b) -> a
17:14:35 <EvilTerran> ?type head
17:14:36 <lambdabot> forall a. [a] -> a
17:14:44 <Saizan> Big_Red: do you get a compile error or just a wrong result?
17:14:49 <EvilTerran> fst works on pairs; head works on lists.
17:14:50 <Liskni_si> i'd say the reason for those limits is that they're stored in ram which is not infinite
17:14:56 <Big_Red> ooer - haven't tried compiling it...
17:15:02 <koko775> oh
17:15:05 <koko775> pairs aren't lists
17:15:12 <EvilTerran> indeed
17:15:17 <koko775> guess my knowledge of scheme fooled me there
17:15:19 <Saizan> Big_Red: well, or loading it in ghci, it doesn't matter in this case
17:15:36 <EvilTerran> pairs (and tuples in general) can contain values of different types
17:15:43 <EvilTerran> but are of fixed length
17:15:53 <Big_Red> hehe took a couple of bugs out and it loads
17:15:57 <EvilTerran> lists can only contain values of one type, but can be arbitrarily long
17:16:18 <koko775> got it
17:16:19 <koko775> thanks
17:16:22 <Big_Red> but i was asking more along the lines of "is it a good idea to do it that way" "would you have done it completely differently"
17:17:20 <hpaste>  Big_Red pasted "Better integration" at http://hpaste.org/4688
17:17:32 <Big_Red> sorry thats a working one
17:19:48 <Big_Red> thoughts?
17:24:06 <Saizan> in numerics code you usually try to avoid to recompute the same values, like (func a) or (a+b)/2
17:26:48 <koko775|coding> just to clear up a possible misconception - if I write a naive factorial function, does haskell automatically memoize, or does it calculate all the way down?
17:26:50 <koko775|coding> er
17:26:53 <koko775|coding> fibonacci
17:26:55 <koko775|coding> not factorial
17:27:07 <EvilTerran> there is no automatic memoization
17:27:12 <EvilTerran> that would be Hard
17:27:12 <koko775|coding> ah
17:27:25 <koko775|coding> hard with a capital H?
17:27:38 <opqdonut> yep
17:27:46 <opqdonut> hard with capital N and P
17:27:58 <koko775|coding> oh, NP-Hard
17:28:00 <EvilTerran> indeed. it would be very tricky to algorithmically work out what to memoize and how to best do so
17:28:12 <koko775|coding> i haven't learned what NP complexity is, exactly, quite yet
17:28:19 <koko775|coding> I will, eventually
17:28:32 <monochrom> I think NP-hard is an underestimation.
17:28:53 <EvilTerran> i don't think it's even NP-hard; it's just not the sort of thing that lends itself to algorithmic expression
17:29:12 <EvilTerran> there's too many variables
17:30:37 <EvilTerran> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- look, ma, memoization!
17:30:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:31:04 <EvilTerran> but you'd likely want to use a different datatype if, say, you were regularly accessing large values
17:31:08 <koko775|dinner> thanks for your help
17:31:11 <EvilTerran> and not small ones
17:31:15 <koko775|dinner> time for me to eat
17:31:21 <EvilTerran> enjoy.
17:32:04 <faxathisia> would anyone suggest a book or anything about type theory and logic ?
17:32:24 <faxathisia> something is bugging me I need to figure out..
17:32:35 <Saizan> what?
17:32:39 <FunctorSalad> couldn't you just memorize everything?
17:32:51 <FunctorSalad> at least with call-by-value strict evaluation
17:33:03 <faxathisia> I read that Type : Type is inconsistent, and I can't really understand why at this stage
17:33:06 <FunctorSalad> would seem to work for fibonacci
17:33:44 <FunctorSalad> anyway, fib n is best implemented as a certain exponential ;)
17:34:02 <aFlag> will any real world haskell chapters ever be published?
17:34:16 <faxathisia> s/is/leads to/
17:34:16 <Saizan> FunctorSalad: space is expensive :)
17:34:28 <EvilTerran> FunctorSalad, how do you look things up in your memos?
17:34:54 <EvilTerran> sure, lists work okay for these fibs, but you can get much better complexities with different data structure
17:34:55 <EvilTerran> s
17:34:56 <EvilTerran> a
17:35:04 <FunctorSalad> EvilTerran: whenever "fib n" is evaluated, remember it (but as I said, this is for strict evaluation)
17:35:18 <EvilTerran> ... *data structures, and which one you chose depends on how you're using your memo'd function
17:35:27 <FunctorSalad> I mean remember the association of the input integer to the return value
17:35:30 <EvilTerran> "remember it"? in a list? a hashmap? an array?
17:35:36 <FunctorSalad> hashmap
17:35:43 <phobes> faxathisia:  Probably related to Russel's paradox
17:35:49 <opqdonut> well that is great performance-wise
17:35:56 <phobes> or maybe curry's paradox
17:35:56 <opqdonut> but it'll blow the memory usage to hell
17:36:11 <faxathisia> phobes: I keep seeing russels paradox and girard's paradox and stuff
17:36:15 <EvilTerran> what about for functions indexed by something that's very expensive to calculate the hash of?
17:36:26 <opqdonut> and of course, the lookup becomes quite complex ... yes
17:36:26 <phobes> you'll need other assumptions to find the inconsistency
17:36:29 <FunctorSalad> opqdonut: didn't want to do it for every function, you'd have to declare it for functions like fib
17:36:43 <EvilTerran> well, declaring it's pretty straightforward
17:36:43 <opqdonut> FunctorSalad: well that's certainly very easy to do
17:36:55 <faxathisia> phobes: Like proving this is inconsistent in the context of a certain type system ?
17:36:58 <FunctorSalad> sorry, think I mixed up strict evaluation and eager evaluation
17:36:58 <opqdonut> a lazy array of the values is enough
17:37:13 <EvilTerran> altho you'd want some kind of O(log n) lookup structure that worked with infinite structures
17:37:22 <EvilTerran> and Data.Map is strict in the spine, iirc, so isn't suitable
17:37:38 <EvilTerran> probably do a trie or something
17:37:50 <FunctorSalad> I agree that for more complex things than fib it would be another matter
17:38:33 <phobes> faxathisia:  Ya, you probably need simple reasoning about function types too
17:39:22 <EvilTerran> > let evens [] = []; evens [x] = [x]; evens (x:_:xs) = x : evens xs; fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in iterate evens fibs
17:39:23 <lambdabot>  [[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:39:27 <Saizan> FunctorSalad: a problem is that with GC and virtual memory keeping lots of data around can slow your program
17:39:33 <EvilTerran> hm. of course, that doesn't look interesting.
17:39:49 <EvilTerran> but i suspect it'd make O(log n) lookup possible, after the memos've been calculated out that far
17:40:01 <EvilTerran> no, wait, that's rubbish. never mind.
17:40:13 <faxathisia> how do you think I could find out and undersstand why this is leading to an inconsistency?
17:40:33 <EvilTerran> goddamn it, i was going to bed an hour ago. >:[
17:43:28 <FunctorSalad> good point, afk too
17:44:00 <EvilTerran> "No instance for (Typeable (forall a. (Typeable a) => a))"?
17:44:11 <EvilTerran> sod this, i give up for the evening.
17:45:20 <EvilTerran> ... but surely there's an instance for that?
17:45:27 <EvilTerran> it's *right there*!
17:46:12 <Saizan> forall a. (Typeable a) => a ~ Void, no?
17:47:24 <Big_Red> so can anyone suggest any improvements/better ways to do http://hpaste.org/4688
17:47:40 <phobes> faxathisia - ok let me think about it for a sec ... i'm working on something else sorry
17:48:13 <faxathisia> no worries, it's reassuring that what I said at least made some sense
17:48:15 <Big_Red> except for the error in line 5...
17:52:37 <loupgaroublond> anyways, happy friday http://i.somethingawful.com/inserts/articlepics/photoshop/12-21-07-time/Yoozer.jpg
17:52:38 <lambdabot> http://tinyurl.com/yo576z
17:53:25 <faxathisia> Big_Red: Seen the thing with differentiation in types?
17:53:43 <loupgaroublond> oops, wrong window
17:54:10 <Big_Red> differentiation in types?
17:55:31 <faxathisia> check this out http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
17:55:32 <lambdabot> Title: Things that amuse me, http://tinyurl.com/ypvsr2
17:55:39 <faxathisia> I am not sure though.. if you can do integraation the same way
17:56:00 * Big_Red reads
17:57:56 <EvilTerran> Saizan, nah, you know it's Typeable, so you should be able to pass it to cast
17:57:59 <EvilTerran> ?type cast
17:58:00 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
17:59:00 <EvilTerran> hm. or would that be (exists a. Typeable a => a)?
17:59:22 <Saizan> exactly :)
17:59:33 <Big_Red> :\
18:00:03 <Saizan> same reason you can't just have a [forall a. Show a => a] list, but you need a data Showable = ...
18:00:08 <Big_Red> looks somewhat painful/heavy reading for 2am
18:06:59 * EvilTerran has a minor epiphany
18:07:45 <EvilTerran> the reason why moving foralls around is like having an "exists" is because function types are, er, whodjimaflip -- word meaning "backwards" or something -- in their first parameter.
18:07:47 <EvilTerran> amirite?
18:08:19 <Saizan> "contravariant"
18:08:36 <EvilTerran> that's the one! :D
18:08:37 <phobes> faxathisia:  shurg... I'm gonna have to think about this one later - too much thinking for tonight, sorry
18:09:00 <EvilTerran> Saizan++
18:09:01 <phobes> I'm sure someone else is better equipped to answer anyway :)
18:09:06 <faxathisia> phobes, it's cool, thanks though. I've got some stuf which is (probably) related to read
18:09:13 <Saizan> heh :)
18:09:14 <EvilTerran> I'm finally starting to get my head around rank N types; thanks :)
18:10:40 <FunctorSalad> EvilTerran: in predicate calculus, (forall a: P(a)) => Q is equivalent to (exists a: not P(a)) OR Q. but maybe the similarity with logical implication is purely formally :)
18:10:44 <Saizan> np, even if i don't fully understand the theory either
18:11:20 <EvilTerran> it's the contravariance that's the big breakthrough in my mind this evening
18:11:56 <EvilTerran> prior to that realisation, i considered knowing where to put the foralls to get the desired effect to be voodoo
18:12:11 <Saizan> FunctorSalad: don't you lack a not somewhere?
18:12:12 <EvilTerran> but now i have a tactic to work it out :)
18:12:48 <FunctorSalad> Saizan: the not comes from A => B equiv (not A) OR B
18:13:17 * EvilTerran goes back to embedding lambda calculus + typeables in haskell
18:13:35 <Saizan> uh, right, didn't made the "calculation" right :)
18:13:42 <EvilTerran> (data Fn where Fn { (?) :: Fn -> Fn } :: Fn; Val :: Typeable a => a -> Fn, and it's all downhill from there >;])
18:14:14 <EvilTerran> (y = Fn$ \f -> (Fn$ \x -> f ? (x ? x)) ? (Fn$ \x -> f ? (x ? x)))
18:14:36 <faxathisia> oh god that's sick
18:14:46 <FunctorSalad> hehe
18:14:50 <EvilTerran> Fn$ \ is just a weird shaped lambda
18:15:01 <faxathisia> :D
18:15:26 <EvilTerran> i wouldn't've bothered with the Val constructor, but it seems you can't tell values of the Fn constructor apart...
18:15:40 <EvilTerran> s/of/comprised entirely of applications of/
18:15:49 <Valodim_> great, your Val constructor just nickhighlighted and woke me up >_>
18:15:55 * Valodim_ yawns
18:15:59 <EvilTerran> apologies =/
18:16:12 <Valodim_> no prob, didn't intend to sleep anyways
18:16:25 <FunctorSalad> you got a sound upon highlighting, Valodim_?
18:16:32 <Valodim_> yes
18:16:53 <FunctorSalad> these things would annoy me too much...
18:16:58 <EvilTerran> my original plan was to make the type Fn a, and Val :: a -> Fn a
18:16:59 <wy> In which charset can I find the symbol "plus inside circle"?
18:17:14 <FunctorSalad> especially the KDE "broken glass" sound ;)
18:17:21 <EvilTerran> but then adding more than one type on top of functions just gets fiddly
18:17:49 <Valodim> FunctorSalad: not really, this is the first time it caught my attention unrelated
18:17:50 <Cale> ⊕ U+2295
18:18:05 <wy> > let ¬ = not in ¬ False
18:18:06 <lambdabot>  Illegal character ''\172''
18:18:06 <lambdabot>  at "" (column 6)
18:18:07 <EvilTerran> so i briefly experimented with using something HList-esque to make it look nicer
18:18:08 <Cale> In gucharmap it's under "Mathematical Operators"
18:18:51 <wy> Cale: Thanks. I hope we can use those symbols as operators in Haskell. They are nice :-)
18:18:52 <EvilTerran> but then realised that i might as well use Typeable; the only thing i've sacriviced is knowing the full set of types that might get involved
18:19:09 <EvilTerran> i might go back to HList again, as a learning experience, but this one was hard enough ;)
18:19:53 <Japsu> hmm
18:20:06 <Japsu> custom unary operators?
18:20:10 <Japsu> wasn't there some hack...
18:20:31 <mauke> > let (?) = sqrt in (? 42)
18:20:31 <ricky_clarkson> Is that how mathematicians write (+)?
18:20:32 <lambdabot>        add an instance declaration for (Show ((t -> t1) -> t1))
18:20:43 <mauke> > let (?) = sqrt in (42 ?)
18:20:44 <lambdabot>  6.48074069840786
18:21:14 <Japsu> but any way to make it work in prefix?
18:21:31 <jfredett> > let (?) = flip sqrt in (? 42)
18:21:32 <lambdabot>   add an instance declaration for (Floating (b -> c))
18:21:33 <wy> Why can't I use ¬, but I can use ⊕ ?
18:21:41 <jfredett> damn, worth a shot..
18:21:52 <Japsu> I thought of flip, but there's nothing to flip really
18:21:55 <Japsu> :t flip
18:21:55 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:22:08 <jfredett> yeh
18:22:09 <Japsu> a -> b simply won't fit at (a -> b -> c)
18:22:16 <jfredett> unfortunately
18:22:34 <LoganCapaldo> > let (?) = sqrt in (? 42)
18:22:34 <lambdabot>        add an instance declaration for (Show ((t -> t1) -> t1))
18:23:33 <EvilTerran> > let (?) = sqrt in (?) 42  -- here's your prefix
18:23:34 <lambdabot>  6.48074069840786
18:24:00 <LoganCapaldo> no unary sections, bah
18:24:03 <jfredett> ah- that makes sense
18:24:12 <Japsu> but now it has ugly parens
18:24:13 <Japsu> :<
18:24:19 <jfredett> Japsu: better than nothing
18:24:23 <EvilTerran> so does (42 ?)
18:24:37 <Japsu> oh, true
18:25:19 <wy> > let ⊕ a b = (a && not b) || (not a && b) in True ⊕ True
18:25:19 <lambdabot>  Illegal character ''\138''
18:25:19 <lambdabot>  at "" (column 6)
18:26:07 <byorgey>  > let (⊕) a b = (a && not b) || (not a && b) in True ⊕ True
18:26:12 <byorgey> > let (⊕) a b = (a && not b) || (not a && b) in True ⊕ True
18:26:12 <lambdabot>  Illegal character ''\138''
18:26:13 <lambdabot>  at ")" (column 7)
18:26:31 <byorgey> it works in ghci 6.8.2
18:27:05 <wy> byorgey: It works in ghci 6.9 too
18:27:16 <byorgey> wy: well, yes, I expect so =)
18:28:54 <wy> but only in terminal. It seem emacs will translate it into something illegal
18:29:14 <faxathisia> 6.9 is out :o
18:29:44 <wy> Just downloaded from darcs
18:30:26 <wy> I wonder if more powerful parsers can be constructed in a neat way in haskell
18:30:35 <FunctorSalad> suggestions for some fun exercises website?
18:31:00 <ctkrohn> wy: parsec? (apologies if this has been mentioned)
18:33:09 <lQg> what function would take a list and return only it's unique elements?
18:33:12 <wy> ctkrohn: parsec can only parse a small class of grammars. I wonder if it can parse Haskell itself
18:33:45 <ctkrohn> lQg: nub, I think it's called
18:33:46 <Cale> wy: It's actually a pretty big class.
18:33:47 <faxathisia> really? :o..
18:33:51 <faxathisia> Ithought parsec could parse anything
18:33:56 <faxathisia> cause you can do it in stages
18:33:58 <Cale> wy: It includes many context-sensitive grammars.
18:34:08 <lQg> ctkrohn: much better to use standard haskell functions
18:34:40 <lQg> rather than parsec
18:34:42 <wy> Cale: Maybe my tutorial is a little outdated, but it says parsec is a descend recursive parser
18:34:49 * EvilTerran thought parsec could do anything, as you can always try ( read some tokens >>= validate 'em )
18:34:52 <lQg> from experience
18:35:04 <EvilTerran> well, "anything". the recursively enumerable languages.
18:35:31 <EvilTerran> altho there comes a point where you can't honestly say you're really using Parsec any more
18:35:54 <lQg> http://lokiworld.org/skamSELypla/lOgjbang/VALsi.hs  <- standard haskell function logical language parser
18:37:23 <lQg> @hoogle nub
18:37:24 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
18:37:24 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
18:37:35 <lQg> kk
18:39:20 <faxathisia> I really wish you could run parsec backwards though...
18:39:24 <faxathisia> It's quite irritating
18:39:48 <faxathisia> then again, having nice indentation rules for unparsing in a logical relation is not something I've seen done
18:41:26 <EvilTerran> prettyprinting?
18:57:53 <lQg> how do i find out what number an element is in a list?
18:58:13 <mauke> :t findIndex
18:58:15 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
18:58:24 <EvilTerran> :t elemIndex
18:58:25 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
18:59:09 <lQg> > elemIndex "a" ["a","b"]
18:59:09 <lambdabot>  Just 0
18:59:15 <lQg> > elemIndex "a" ["b","a"]
18:59:16 <lambdabot>  Just 1
18:59:23 <lQg> kk
18:59:30 <lQg> > elemIndex "a" ["a","a"]
18:59:30 <lambdabot>  Just 0
18:59:39 <lQg> np
19:08:18 <EvilTerran> :t elemIndices
19:08:18 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
19:11:08 <FunctorSalad> :t minimum [n | n <- Integer, lst!!n == something]
19:11:08 <lambdabot> Not in scope: data constructor `Integer'
19:11:09 <lambdabot> Not in scope: `lst'
19:11:09 <lambdabot> Not in scope: `something'
19:11:56 <FunctorSalad> :t minimum [n | n <- [1 ..], ?lst!!n == ?something]
19:11:57 <lambdabot> (?lst::[Integer], ?something::Integer) => Int
19:12:10 <LoganCapaldo> :t minimum [ n | n <- ?ns , ?lst !! n == ?something ]
19:12:10 <lambdabot> (?ns::[Int], ?lst::[Integer], ?something::Integer) => Int
19:12:26 <LoganCapaldo> me too slow
19:12:39 <FunctorSalad> lazy eval ensures that only one is found, right?
19:13:24 <LoganCapaldo> i think the definition of the function ensurse that
19:13:31 <LoganCapaldo> :t minimum
19:13:32 <lambdabot> forall a. (Ord a) => [a] -> a
19:13:38 <LoganCapaldo> @src minimum
19:13:39 <lambdabot> minimum [] = undefined
19:13:39 <lambdabot> minimum xs = foldl1 min xs
19:13:49 <FunctorSalad> yes, I mean that it "terminates" then
19:14:42 <FunctorSalad> let lst=[4,7,9,3], something=9 in minimum [n | n <- [1 ..], lst!!n == something]
19:14:45 <LoganCapaldo> it terminates the same "time" the strict function would
19:14:46 <FunctorSalad> > let lst=[4,7,9,3], something=9 in minimum [n | n <- [1 ..], lst!!n == something]
19:14:46 <lambdabot>  Parse error at "," (column 18)
19:15:05 <LoganCapaldo> you have to look at every value in the list to find the minimum
19:15:33 <FunctorSalad> > let {lst=[4,7,9,3];  something=9} in minimum [n | n <- [1 ..], lst!!n == something]
19:15:34 <lambdabot>  Exception: Prelude.(!!): index too large
19:15:49 <FunctorSalad> hmm
19:17:00 <FunctorSalad> LoganCapaldo: no, the task was to find the smallest matching index, not the smallest element in lst
19:17:19 <LoganCapaldo> > let { lst = [4,7,9,3] ; something = 9 } in minimum [ n | (n, x) <- zip [0..] lst, x == something ]
19:17:20 <lambdabot>  2
19:17:29 <LoganCapaldo> I know
19:17:30 <EvilTerran> the thing to do wouth be to use head rathe rthan minimum
19:17:38 <EvilTerran> in case lst is infinite
19:17:43 <FunctorSalad> oh. right
19:17:49 <EvilTerran> 'cos it can't tel lthat [1..] is sorted after it's been created
19:17:50 <FunctorSalad> :)
19:18:27 <FunctorSalad> > let {lst=[4,7,9,3];  something=9} in head [n | n <- [0 ..], lst!!n == something]
19:18:28 <lambdabot>  2
19:19:19 <EvilTerran> listToMaybe instead of head if you want Nothing instead of _|_
19:19:24 <EvilTerran> ?src listToMaybe
19:19:25 <lambdabot> listToMaybe []        =  Nothing
19:19:25 <lambdabot> listToMaybe (a:_)     =  Just a
19:19:30 <EvilTerran> ?src head
19:19:30 <lambdabot> head (x:_) = x
19:19:30 <lambdabot> head []    = undefined
19:19:57 <LoganCapaldo> @type findIndex
19:19:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
19:20:15 <Korollary> That should be named headToMaybe or maybeHead.
19:20:40 <LoganCapaldo> > let { lst = [4,7,9,3] ; something = 9 } in elemIndex something lst
19:20:40 <lambdabot>  Just 2
19:20:50 <FunctorSalad> hmm wouldn't the error occur in lst!!n already when n gets too large?
19:21:07 <FunctorSalad> > [0,1] !! 8
19:21:07 <lambdabot>  Exception: Prelude.(!!): index too large
19:21:12 <LoganCapaldo> FunctorSalad: now the laziness kicks in <g>
19:22:25 <FunctorSalad> @type (!!)
19:22:25 <lambdabot> forall a. [a] -> Int -> a
19:22:44 <LoganCapaldo> > let { lst = [4,7,9,3] ; something = 10 } in head [ n | n <- [0..] , lst !! n == something ]
19:22:44 <lambdabot>  Exception: Prelude.(!!): index too large
19:22:59 <LoganCapaldo> when something isn't in the list
19:23:33 <LoganCapaldo> but as long as something is in thelist the index with never get too big
19:23:41 <LoganCapaldo> s/with/will
19:24:01 <LoganCapaldo> because it won't get evaluated there
19:24:31 <FunctorSalad> yeah
19:24:38 <FunctorSalad> but how to deal with the exception?
19:24:49 <LoganCapaldo> don't do it like that
19:25:03 <LoganCapaldo> use my zip like method (or just use elemIndex)
19:25:21 <FunctorSalad> hmm shouldn't !! be something like [a] -> Int -> Maybe Int
19:25:22 <FunctorSalad> ?
19:25:27 <FunctorSalad> err Maybe a
19:25:40 <FunctorSalad> (except that this would probably be too inefficient)
19:26:24 <LoganCapaldo> eh
19:26:28 <EvilTerran> ?hoogle [a] -> Int -> Maybe a
19:26:29 <lambdabot> No matches, try a more general search
19:26:35 <LoganCapaldo> eventually you gotta actually use the value
19:27:23 <sw17ch> offhand, does any one know what purpose the backtick serves in common lisp?
19:27:53 <faxathisia> yes
19:28:00 <Korollary> sw17ch: quasiquote
19:28:10 <EvilTerran> ?type \x xs -> lookup x $ xs `zip` [0::Int ..]
19:28:11 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
19:28:22 <sw17ch> ah, a term to google, thanks
19:28:30 <faxathisia> "its a bit like this #{1+1}"
19:28:37 <faxathisia> where " is quasiquote, and #{ ... } is ,
19:28:39 <Korollary> sw17ch: Read "Quasiquotation in Lisp"
19:28:45 <faxathisia> assuming you know that much ruby..
19:28:57 <sw17ch> mmm
19:28:59 <EvilTerran> `(1 2 ,@(+ 3 4) 5) = '(1 2 7 5)
19:29:14 <LoganCapaldo> > let { [] `at` n = Nothing ; xs `at` n | n < 0 = Nothing ; [x] `at` 0 = x ; (x:xs) `at` n = xs `at` (n - 1)  } in ([1,2,3] `at` 1, [] `at` 3, [2] `at` 1)
19:29:14 <sw17ch> here's what i'm looking at `(reducing ,expr :by #'+ :initial-value 0)
19:29:15 <lambdabot>   add an instance declaration for (Num (Maybe a))
19:29:15 <lambdabot>     In the expression: 2
19:29:18 <EvilTerran> `(1 2 ,(+ 3 4) 5) = '(1 2 (7) 5)
19:29:22 <EvilTerran> or something
19:29:44 <LoganCapaldo> > let { [] `at` n = Nothing ; xs `at` n | n < 0 = Nothing ; [x] `at` 0 = Just x ; (x:xs) `at` n = xs `at` (n - 1)  } in ([1,2,3] `at` 1, [] `at` 3, [2] `at` 1)
19:29:45 <lambdabot>  (Nothing,Nothing,Nothing)
19:29:50 <FunctorSalad> sw17ch: it's like quote except that the things with a comma before them are evaluated
19:29:53 <faxathisia> sw17ch: It expands into a form which has (reducing <whatever the value of expr was> ... etc)
19:30:01 <EvilTerran> ?type \i xs -> lookup i $ [0::Int ..] `zip` xs
19:30:02 <lambdabot> forall b. Int -> [b] -> Maybe b
19:30:02 <sw17ch> mmmm
19:30:14 <sw17ch> alright thanks
19:30:29 <EvilTerran> > let i `at` xs = lookup i $ [0::Int ..] `zip` xs in ([1,2,3] `at` 1, [] `at` 3, [2] `at` 1)
19:30:29 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
19:30:30 <sw17ch> (i keep learning all these fun extras that are in Lisp that I do'nt know while making this interpreter)
19:30:41 <sw17ch> i keep feeding it ASDF libraries and watching when things break
19:30:42 <LoganCapaldo> flip
19:30:45 <sw17ch> and figuring out waht i missed
19:30:58 <EvilTerran> > let { xs `at` i = lookup i $ [0::Int ..] `zip` xs } in ([1,2,3] `at` 1, [] `at` 3, [2] `at` 1)
19:30:59 <lambdabot>  (Just 2,Nothing,Nothing)
19:31:14 <faxathisia> haha
19:31:23 <faxathisia> I don't think that writing an interpreter i sa good way to learn lisp
19:31:33 <faxathisia> but as long asits fun
19:31:39 <sw17ch> hehe, it's not my intention to learn lisp at this point :)
19:31:45 <sw17ch> i needed a language with a simple grammar to parse :)
19:31:46 * EvilTerran would be inclined to call it !!? rather than `at`, but still...
19:32:01 <ricky_clarkson> sw17ch: s-expressions in general.
19:32:16 <LoganCapaldo> what, not !? ?
19:32:20 <EvilTerran> ??, maybe
19:32:21 <sw17ch> ricky_clarkson: exactly :)
19:32:45 * EvilTerran has a MPTC-based nesting version of !! called !!..! lurking somewhere
19:33:44 <EvilTerran> ?pl \xs i -> lookup i $ [0::Int ..] `zip` xs
19:33:44 <lambdabot> flip lookup . ([0 :: Int..] `zip`)
19:34:34 <FunctorSalad> why declare it Int? performance?
19:36:36 <EvilTerran> ?type \xs i -> lookup i $ [0..] `zip` xs
19:36:37 <lambdabot> forall a b. (Num a, Enum a) => [b] -> a -> Maybe b
19:36:41 <sw17ch> i suddenly have a grudge against the quasiquote
19:36:41 <EvilTerran> is ugly :P
19:36:47 <faxathisia> why?
19:37:01 <faxathisia> (try writing complex lisp macros without it)
19:37:09 <EvilTerran> actually, mostly because we were after a parallel to !!
19:37:12 <EvilTerran> ?type (!!)
19:37:13 <FunctorSalad> yeah it's useful for macros
19:37:13 <lambdabot> forall a. [a] -> Int -> a
19:37:26 <faxathisia> I mean don't implement
19:37:28 <faxathisia> it
19:37:28 <sw17ch> faxathisia: i see how nice it is, but it's managed to push my celebration back a few hours
19:37:35 <faxathisia> just skip it...
19:37:54 <sw17ch> hehe, i'm really considering it
19:38:03 <faxathisia> I mean implement it in lisp tommorow :)
19:38:06 <faxathisia> and then add the syntax
19:38:18 <sw17ch> i just feel like i'm so close to being able to parse almost all of common lisp
19:38:18 <faxathisia> (defmacro quasiquote .. etc
19:38:41 <faxathisia> well you are probably a few more attoparsecs away than you think
19:38:52 <faxathisia> cause...you can extend the CL parser with arbitrary code
19:38:55 <sw17ch> yes, this just informed me of that :)
19:39:01 <FunctorSalad> I thought CL was pretty complex
19:39:12 <faxathisia> you can't parse CL without a complete CL implementation
19:39:16 <EvilTerran> why CL? scheme is clearly superior. :P
19:39:41 <FunctorSalad> well, CL is pragmatic (though tbh I have no scheme experience)
19:39:52 <faxathisia> for example, someone might define a reader macro on #\<, and add an XML parser to the language
19:40:18 <EvilTerran> CL does dynamic scoping, right?
19:40:41 <FunctorSalad> I think only under special circumstances though the only thing I remember about it is that it is nasty ;)
19:40:51 <FunctorSalad> I think normally it's lexical
19:40:54 <ricky_clarkson> It's lexical by default, but you can use dynamic (special) variables.
19:41:00 <EvilTerran> ah. makes sense.
19:41:04 <sw17ch> hmm... this is a really REALLY dumb parser though
19:41:05 <FunctorSalad> ricky_clarkson: what was the syntax again?
19:41:19 <sw17ch> I just need an AST for the code and nothing else
19:41:31 <ricky_clarkson> (defspecial *fark* 5) I think.
19:41:37 <FunctorSalad> ah
19:41:39 <loupgaroublond> why? are you implementing lisp macros in haskell?
19:41:44 <loupgaroublond> sw17ch: ^^
19:41:58 <faxathisia> no
19:42:05 <sw17ch> loupgaroublond: no, not at all :)
19:42:13 <faxathisia> (declare (special foo))
19:42:13 <sw17ch> loupgaroublond: my project is far less interesting
19:42:28 <faxathisia> or use defparameter/defvar
19:42:34 <loupgaroublond> sw17ch: what are you doing then?
19:42:54 <faxathisia> defspecial isn't CL
19:43:02 <sw17ch> faxathisia: all my parser sees there is this :: Found value: [LispExpr "(declare (special foo))" (ListValue [LispExpr "declare" (AtomValue "declare"),LispExpr " (special foo)" (ListValue [LispExpr "special" (AtomValue "special"),LispExpr " foo" (AtomValue "foo")])])]
19:43:04 <ricky_clarkson> defspecial seems imaginary.
19:43:21 <faxathisia> sw17ch: seems bizarre
19:43:31 <sw17ch> basic language analysis, i want to see how code relates to itself
19:43:33 <faxathisia> sw17ch: What does (a . b) parse to?
19:43:49 <sw17ch> Found value: [LispExpr "(a . b)" (ListValue [LispExpr "a" (AtomValue "a"),LispExpr " ." (AtomValue "."),LispExpr " b" (AtomValue "b")])]
19:43:57 <ricky_clarkson> (defvar *fark* 5) does what I meant, just tested it.
19:44:05 <faxathisia> well that makes no sense
19:44:22 <mauke> . is not an atom
19:44:23 <faxathisia> sw17ch: (a b) = (a . (b . ()))
19:44:40 <sw17ch> faxathisia: i believe we've had this conversation before
19:44:48 <FunctorSalad> :o
19:44:54 <faxathisia> sw17ch: I forgot.. I think it's a common mistake
19:44:57 <sw17ch> i do'nt care about what the interpreter does with the code, i only care about the syntactic representation :)
19:45:21 <sw17ch> actually last time, you were quite helpful, but i decided to be stubborn
19:45:21 <ricky_clarkson> For CL, the syntactic representation may be altered by the code.
19:45:28 <faxathisia> (I was just saying your representation makes no sense, but that's fine if you want that0
19:45:33 <sw17ch> yes, but i don't care what happens to it after it start
19:45:34 <sw17ch> s
19:45:41 <sw17ch> this is purely what people see, i don't care what the machien sees
19:45:58 <sw17ch> faxathisia: i know, i appreciate the criticism :)
19:46:33 <faxathisia> If you don't care about the semantic meaning though, why are you parsing it?
19:46:33 <EvilTerran> people see a ::String
19:46:41 <faxathisia> instead of using the actual text itself
19:46:54 <EvilTerran> if you mean what they visualise, that's a whole other kettle of kippers
19:47:11 <sw17ch> EvilTerran: that's close to it
19:47:13 <sw17ch> :)
19:47:27 <sw17ch> I want an interactive call graph
19:47:31 <sw17ch> plain and simple :)
19:47:43 <EvilTerran> (because, damnit, alliteration makes turns of phrase more fun)
19:47:48 <faxathisia> yeah.. just ignore me, It's just like nails on a blackboard to me for some reason :)
19:48:02 <sw17ch> where the call graph actually contains all the code of the file
19:48:02 * EvilTerran nails some jello to a blackboard
19:48:48 <glen_quagmire> in do block, num <- getLine;  let n = read num;  putStrLn $ show n    ; error
19:48:56 <sw17ch> does any one think such a thing is unreasonable?
19:49:04 <sw17ch> by "thing" i mean, interactive call graph...
19:49:05 <faxathisia> I think you should use n <- read num
19:49:09 <faxathisia> but I'm not certain..
19:49:30 <sw17ch> :t read
19:49:30 <lambdabot> forall a. (Read a) => String -> a
19:49:47 <glen_quagmire> so, a is ambiguous
19:49:56 <faxathisia> ack.. I very much misinterpreted that
19:50:08 <glen_quagmire> is there haskell FAQ for this kind of questions??   like, "how to read a number from console"..
19:50:16 <faxathisia> :t readLine
19:50:17 <lambdabot> Not in scope: `readLine'
19:50:19 <mauke> num <- readLn; print num  -- shorter :-)
19:50:33 <ricky_clarkson> > [1..10] <$> (*2) `filter` (>9)
19:50:33 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
19:50:34 <Valodim> glen: hoogle
19:50:36 <mauke> num <- readLn; print (num :: Integer) -- actually works
19:50:45 <ricky_clarkson> > [1..10] <$> (*2) $ `filter` (>9)
19:50:45 <lambdabot>  Parse error at "`filt..." (column 20)
19:50:58 <faxathisia> why does haskell use Ln instead of Line?
19:51:07 <Valodim> because it can
19:51:13 <Valodim> I don't think there's any specific reason behind that
19:51:37 <EvilTerran> glen_quagmire, is it a layout thing? if you're putting it all one one line like that, it'll be parsing as  let { n = read num;  putStrLn $ show n }
19:52:23 <mauke> :t do { num <- getLine;  let n = read num;  putStrLn $ show n }
19:52:23 <lambdabot> parse error on input `}'
19:52:43 <glen_quagmire> EvilTerran: no the type thingy. let (n :: Integer) = read num;  didnt' let me go through without some flag
19:52:58 <EvilTerran> oka
19:53:04 <glen_quagmire> but somehow, mauke 's version, print (n :: Integer) goes through with the special flag
19:53:15 <ricky_clarkson> > let flipmap=flip map in [1..10] `flipmap` (+2)
19:53:15 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
19:53:18 <mauke> yes, because n is an expression there
19:53:19 <ricky_clarkson> > [1..10] `flip map` (+2)
19:53:19 <lambdabot>  Parse error at "map`" (column 15)
19:53:24 <EvilTerran> you need an extension to put type annotations in patterns, but not in expressions
19:53:25 <sw17ch> let n = (read num :: Integer) ?
19:53:27 <ricky_clarkson> Why does the latter fail?
19:53:47 <ricky_clarkson> Clearly because the language doesn't work that way, but I wonder why.
19:53:52 <mauke> ricky_clarkson: flip map is not an identifier
19:53:54 <EvilTerran> let { n :: Integer; n = read num } would work
19:54:19 <mauke> ricky_clarkson: because `` sucks if you want to nest it
19:54:26 <ricky_clarkson> ok
19:55:12 <EvilTerran> if you have
19:55:14 <EvilTerran> infixr 2 <|; x <| f = f x; infixl 1 |>; f |> x = f x
19:55:28 <EvilTerran> then you can do stuff like
19:55:39 <EvilTerran> [1,2,3] <| zipWith (+) |> [4,5,6]
19:55:42 <FunctorSalad> :o
19:55:44 <faxathisia> wow :D
19:55:51 <EvilTerran> :)
19:55:58 <faxathisia> that's so cool
19:56:13 <jz87> is there anyway to run haskell packages with unix dependency on win32?
19:56:14 <EvilTerran> ^.^
19:56:22 <faxathisia> damn :|
19:56:37 <faxathisia> my file of cool one-line bits of code is totally haskell dominated
19:57:00 * EvilTerran has a file by the name of bag-o-tricks.hs for stuff like that
19:57:02 <wy> Haha. ⊕ displayed, but emacs really need an overhaul
19:57:22 <glen_quagmire> Choices:       do {num <- getLine; let {n :: Integer; n = read num;}}   or  do { num <- readLn;  print (num :: Integer); }
19:57:38 <EvilTerran> also
19:57:39 <EvilTerran> main = putStr s >> print s where s = "main = putStr s >> print s where s = "
19:57:40 <glen_quagmire> lines of code wise, 2nd one is shorter. but I have to print it
19:57:57 <EvilTerran> zeroAllButDiag = (zipWith.zipWith) ($) (iterate (const 0:) (id:repeat (const 0)))
19:58:00 <EvilTerran> etcetc
19:58:07 <ricky_clarkson> > map (*2) >>> filter (>=10) >>> map (\x -> show x++",") >>> concat $ [1..10]
19:58:07 <lambdabot>  "10,12,14,16,18,20,"
19:58:14 <Saizan> glen_quagmire: just use that n as a number and you're fixed.
19:58:20 <ricky_clarkson> Is there a nice way of writing that without getting the trailing comma?
19:58:43 <mauke> > join (intersperse "," [10, 12 .. 20])
19:58:44 <lambdabot>   add an instance declaration for (Num [Char])
19:58:44 <lambdabot>     In the expression: 20
19:58:45 <Saizan> glen_quagmire: type inference need some context to work properly
19:58:46 <EvilTerran> arrows? O.o
19:58:52 <mauke> > join (intersperse "," . map show $ [10, 12 .. 20])
19:58:53 <lambdabot>  "10,12,14,16,18,20"
19:59:20 <glen_quagmire> Saizan: thansk
19:59:35 <wy> Is it very uncommon to use those unicode symbols in haskell?
19:59:47 <glen_quagmire> I'm trying to solve http://rbandrews.livejournal.com/128578.html
19:59:51 <ricky_clarkson> :t intersperse
19:59:51 <lambdabot> forall a. a -> [a] -> [a]
19:59:55 <faxathisia> It's not common enough
20:00:07 <mauke> > intercalate
20:00:08 <lambdabot>   Not in scope: `intercalate'
20:00:11 <faxathisia> the code in papers using unicode symbols can often look a lot better
20:00:16 <glen_quagmire> i give up for today.
20:00:54 <faxathisia> glen_quagmire, You could easily get that into haskell
20:01:24 <glen_quagmire> faxathisia: i see the pattern in the triangle. i'm not sure whre to begin. maybe create data Triangle
20:01:35 <hpaste>  faxathisia pasted "with some serach and replace" at http://hpaste.org/4689
20:01:40 <faxathisia> um add an [
20:01:42 <faxathisia> but yeah..
20:01:46 <glen_quagmire> or i just return a list
20:02:35 <glen_quagmire> oh, so the function should be  func :: Integer -> [[Integer]]
20:02:45 * glen_quagmire retackles
20:02:58 <faxathisia> what function should be Integer -> [[Integer]] ?
20:03:06 <ricky_clarkson> concat?
20:03:12 <ricky_clarkson> oh, nm
20:03:19 <faxathisia> (asking glen)
20:03:29 <glen_quagmire> faxathisia: the Consul the Educated Monky function
20:03:42 <Japsu> @type (++)
20:03:43 <lambdabot> forall a. [a] -> [a] -> [a]
20:03:45 <glen_quagmire> given an integer like 12, it'll return that list of list of integer
20:03:56 <Japsu> @type mplus
20:03:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
20:04:01 <faxathisia> well that doesn't make any sense at all
20:04:08 <glen_quagmire> then i need to print [[Integer]]  as a triangle
20:04:10 <faxathisia> but you seemto know what you are doing :)
20:04:10 <Japsu> > [1,2,3] `mplus` [3,4,5]
20:04:11 <lambdabot>  [1,2,3,3,4,5]
20:04:15 <faxathisia> I certainly don't
20:04:36 <Japsu> :i MonadPlus
20:04:44 <wy> I really wish we could use ⊕ as mplus
20:04:57 <faxathisia> can't you? :|
20:05:17 <Japsu> > let (⊕) = mplus in [1,2,3] ⊕ [4,5,6]
20:05:17 <lambdabot>  Illegal character ''\138''
20:05:17 <lambdabot>  at ")" (column 7)
20:05:17 <faxathisia> oh we
20:05:21 <Japsu> :<
20:05:29 <faxathisia> I think lambdabot supports unicode less than the acctual implementations?
20:05:34 <faxathisia> but I can't do this in ghci..
20:06:19 <mauke> Prelude Control.Monad> let (⊕) = mplus in [1,2,3] ⊕ [4,5,6]
20:06:20 <mauke> [1,2,3,4,5,6]
20:06:36 <Japsu> Prelude Control.Monad> let (⊕) = mplus in [1,2,3] ⊕ [4,5,6]
20:06:37 <Japsu> <interactive>:1:6: lexical error at character '\138'
20:06:38 <Japsu> :<
20:06:40 <Japsu> (6.6.1)
20:06:51 <mauke> 6.8.2 here
20:07:17 <faxathisia> oh it does work in ghci for me
20:08:48 <wy> Japsu: That works in the terminal
20:09:12 <Japsu> not in my terminal
20:09:17 <wy> I guess it just can't get through irc
20:09:25 <wy> Japsu: try gnome-terminal
20:09:38 <Japsu> using konsole, should support unicode just as well
20:09:55 <wy> yes it should
20:10:50 <wy> I'm still figuring out how to display it in emacs, the editor that refuse to keep up to time
20:13:15 <glen_quagmire> i'm writing combination a b = (fact a) / ((fact b) * (fact (a - b))  . Do you recommend using guards? combination a b | a < b = 0
20:13:36 <faxathisia> what is fact?
20:13:44 <Japsu> faxathisia: factorial
20:13:51 <faxathisia> yeah I kind of assumed that..
20:14:24 <glen_quagmire> yup it's factorial. do I have to implement factorial and combination? or are they builtin? hoogle returned nothing
20:14:33 <faxathisia> should use div I think
20:14:35 <faxathisia> instead of (/)
20:14:49 <mauke> factorial n = product [1 .. n]
20:14:52 <Japsu> yeah, use `div`
20:15:00 <Japsu> integer division
20:15:02 <faxathisia> you know
20:15:05 <Japsu> no need to involve floats
20:15:10 <faxathisia> function application binds tighter than operators
20:15:11 <glen_quagmire> oh i see
20:15:16 <faxathisia> since it is a functional langauge
20:15:23 <faxathisia> fact a / (fact b * fact (a - b)
20:15:33 <faxathisia> is the same as wha you wrote
20:15:45 <Japsu> and using `div` instead of /, combination a b = fact a `div` (fact b * fact (a - b))
20:15:49 <faxathisia> (since you also missed a close paren :p)
20:16:08 <glen_quagmire> oh thank you
20:17:34 <Japsu> glen_quagmire: you could also use "over" as the function name, as that's how I think it's read... combination a b = "a over b", so you could write it a `over` b in Haskell ;)
20:17:54 <faxathisia> D:
20:18:05 <Japsu> no, wait, am I mixing it up with the Finnish way to read it
20:18:08 * EvilTerran would call it c and use it infix
20:18:21 <EvilTerran> likewise p
20:18:25 <Japsu> yeah, c would also be good
20:18:35 <Japsu> gah, wikipedia is slow tonight
20:18:38 <EvilTerran> and d :: Int -> Int -> IO Int for dice-rolling :)
20:19:03 <Japsu> EvilTerran: I've done that ;)
20:19:06 <EvilTerran> > 3`d`6
20:19:06 <lambdabot>   Not in scope: `d'
20:19:08 <Japsu> hey, even better
20:19:14 <Japsu> n `choose` r
20:19:23 <faxathisia> what I like ism
20:19:29 <faxathisia> you can actually define it in that way
20:19:34 <glen_quagmire> > let (-/-) a b = div a b in 1 -/- 2
20:19:35 <lambdabot>  0
20:19:39 <faxathisia> n `choose` r = stuff
20:19:42 <faxathisia> very Prolog like
20:19:47 <faxathisia> It's nice
20:19:49 <Japsu> yeah
20:19:55 <faxathisia> @src on
20:19:56 <lambdabot> (*) `on` f = \x y -> f x * f y
20:20:00 <faxathisia> that too is cool
20:20:12 <Japsu> hmm yeah, definitively not `over` as that's usually used for division, right?
20:20:25 <Japsu> x / y can be read "x over y" in English, right?
20:20:43 <faxathisia> x divided by y
20:20:53 <EvilTerran> i've heard nCr pronounced "r from n"
20:21:02 <EvilTerran> but that lacks a parallel for P
20:21:06 <Japsu> it's just that in Finnish "x yli y:n" (literally "x over y") is used for nCr
20:21:31 <glen_quagmire> let (\\) a b = div a b
20:21:39 <Japsu> but I think choose is best
20:23:10 <faxathisia> > let (\\) a b = div a b in 4 \\ 2
20:23:10 <lambdabot>  2
20:23:11 <glen_quagmire> >let d c d = div c d in 1 `d` 2
20:23:14 <faxathisia> > let a \\ b = div a b in 4 \\ 2
20:23:15 <lambdabot>  2
20:23:20 <faxathisia> ^ nicer
20:23:21 <glen_quagmire> how does that work?   let d c d
20:23:27 <glen_quagmire> shouldn't it be confused?
20:23:29 <faxathisia> it does not work
20:23:37 <faxathisia> you must look at the definitions we gave up
20:23:39 <faxathisia> above
20:23:54 <glen_quagmire> > let d c d = div c d in 1 `d` 2
20:23:54 <lambdabot>  0
20:24:32 <faxathisia> let n `c` r = something in 1 `c` 2
20:30:12 <fadec> > let (_l_) = "ass" in _l_
20:30:12 <lambdabot>  "ass"
20:30:26 <wy> > let (加) = mplus in [1,2,3] 加 [4,5,6]
20:30:26 <lambdabot>  Illegal character ''\138''
20:30:27 <lambdabot>  at ")" (column 7)
20:31:09 <wy> It seems that ghci supports certain unicode symbols, but not all.
20:33:47 <dibblego> can takeWhile/dropWhile be written with a fold easily?
20:34:05 <faxathisia> I can see how to do it as a fst.fold
20:34:08 <ptolomy> hmm.. what do I have to do to make my cabal package be auto-testable? Does hackagedb run them?
20:34:23 <faxathisia> though , only take
20:34:51 <dibblego> yeah I can think of that too
20:35:29 <fadec> will ghci do ansi output - or am I an idiot for asking?
20:36:49 <mauke> you mean colors and stuff?
20:37:49 <aFlag> what's ansi output?
20:39:01 <loupgaroublond> publications of the american noodle slurpers institute
20:39:45 <glen_quagmire> does hackage automatically download dependencies too?
20:40:31 <glen_quagmire> oh i don't think so: First, ensure that all the packages it depends on are installed (by following these instructions recursively).
20:44:40 <wy> > let takeWhile2 p = foldr (\a b -> if p a then a:b else []) [] in takeWhile2 (>3) [4,5,8,6,1,2,6]
20:44:41 <lambdabot>  [4,5,8,6]
20:44:55 <dibblego> yeah got that one
20:46:02 <dibblego> ?check \p xs -> takeWhile p xs == let takeWhile' p = foldr (\x xs -> if p x then x:xs else []) [] in takeWhile' p (xs :: [Int])
20:46:02 <lambdabot>  OK, passed 500 tests.
20:48:27 <bparkis> the execution of a statically typed program can be interpreted as proving theorems about the type of certain data
20:49:01 <bparkis> so if a function returns a value of type string, then when that function is called, it can be viewed as proving the theorem that its return value is of type string
20:49:11 <bparkis> for some specific return value
20:49:12 <Korollary> no, type checking proves that.
20:49:19 <Korollary> execution is proof normalization.
20:49:25 <bparkis> you misinterpret me
20:50:15 <bparkis> if the function returns the string "abcd" then its execution proves that the value "abcd" is of type string
20:51:09 <Korollary> but "abcd" is of type string per the typing rules. you don't need to execute anything.
20:51:36 <bparkis> you don't know that "abcd" is a value that can be returned by the function, until it executes
20:52:06 <Korollary> you do by the language definition
20:52:19 <Tac-Tics> :t "abcd"
20:52:20 <lambdabot> [Char]
20:52:25 <Tac-Tics> That's not a string at all!
20:52:32 <bparkis> well, only if the type is simple enough
20:52:49 <faxathisia> What is proof normalization?
20:53:32 <bparkis> if it's an arbitrarily complicated predicate, such as the type of all carmichael numbers (for instance), then examining values returned by a function that has been guaranteed to return only carmichael numbers, does tell you something interesting
20:54:16 <faxathisia> you can't express something that detailed in haskells type system though
20:54:26 <bparkis> ok
20:54:29 <faxathisia> can youn?
20:54:37 <faxathisia> I thought you were talking about a different type system
20:54:50 <bparkis> i am, not haskell specifically
20:55:05 <bparkis> for some generalized static type system
20:55:12 <faxathisia> dependantlty typed lambda caluclus
20:55:17 <faxathisia> ?
20:57:08 <Saizan> this reminds me on proofs based on generators for a language
20:57:17 <Saizan> *of
20:57:57 <faxathisia> :t let k x y = x ; s x y z = (x z) (y z) in ((s s) (s k) k)
20:57:58 <lambdabot> forall t. t -> t
20:58:23 <faxathisia> like that Saizan?
20:58:39 <faxathisia> generate aribtrary sk terms
20:58:41 <wy> > let dropWhile2 p = foldl (\a b -> if p b then a++[b] else a) [] in dropWhile2 (>3) [4,5,8,6,1,2,6]
20:58:42 <lambdabot>  [4,5,8,6,6]
20:58:55 <wy> no....
20:59:11 <hpaste>  mdmkolbe|work pasted "Is there a lazy IntSet?" at http://hpaste.org/4690
20:59:59 <mdmkolbe|work> Has anyone seen a *really* lazy IntSet implementation or do I have to cook up my own?  (I need it to be lazy enough to implement http://hpaste.org/4690)
21:05:28 <pantsd> so, I have a question. I'm using a module (A) inside a module (B) and I can print stuff if I import (A) but if I only import (B) I can't print stuff from (A). What do I need to export in B for this to work?
21:07:31 <wy> dibblego: dropWhile is a little hard
21:09:33 <AxleLonghorn> hello
21:10:46 <mdmkolbe|work> pantsd: you need "module B (module A) where \n import A"
21:10:54 <mdmkolbe|work> AxleLonghorn: hello
21:11:05 <pantsd> mdmkolbe|work: thanks :)
21:12:00 <AxleLonghorn> I have a question regarding list comprehensions
21:12:28 <Tac-Tics> don't ask to ask, just ask~
21:13:24 <AxleLonghorn> :) Well, just recently I came across some guy's blog about haskell making trivial things trivial.
21:13:52 <AxleLonghorn> and he used the taxicab number story as an example
21:13:52 <Tac-Tics> You know what list comprehensions are, right?
21:14:14 <Tac-Tics> (besides God's gift to computer science!)
21:14:31 <AxleLonghorn> he tried to find the number using haskell, and the program was trivial
21:14:50 <faxathisia> :(
21:14:54 <cjb> think I read that yesterday.
21:14:55 <mdmkolbe|work> AxleLonghorn: I'm not familiar with the taxicab number story
21:14:58 <faxathisia> I never found list comprehensions very useful
21:15:02 <AxleLonghorn> because of list comprehensions, now, I don't know any haskell, so I had to get a friend to tell me what it was
21:15:03 <cjb> That's MJD's blog.
21:15:16 <faxathisia> then again I only write one type of program in haskell :p
21:15:26 <Tac-Tics> faxathisia: in haskell, they aren't so much because you can equivalently write them through the list monad
21:15:30 * mdmkolbe|work just looked up taxicab numbers
21:15:33 <Tac-Tics> but in python, they are godsends
21:15:56 <faxathisia> mm the python spellchecker code by norvig really works well, using comprehensions
21:16:02 <AxleLonghorn> so yeah, I was wondering if anyone knows how hard it is to implement list comprehensions in a language
21:16:04 <Tac-Tics> [line.strip() for line in file if line.lstrip()[0] != '#']
21:16:16 <mdmkolbe|work> AxleLonghorn: it is very easy
21:16:18 <faxathisia> @src [] Monad -- something like this should show how easy?
21:16:18 <lambdabot> Source not found. That's something I cannot allow to happen.
21:16:24 <faxathisia> I cannot use this command though
21:16:30 <dibblego> @src [] (>>=)
21:16:31 <lambdabot> m >>= k     = foldr ((++) . k) [] m
21:16:34 <Tac-Tics> AxleLonghorn: Do you know much about Haskell or monads?
21:16:46 <Tac-Tics> even if you don't, the answer is yes
21:16:46 <mdmkolbe|work> AxleLonghorn: a list comprehension is just sugar for a sequence of maps, zips and filters.
21:17:04 <mdmkolbe|work> @type map
21:17:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:17:10 <mdmkolbe|work> @type zip
21:17:11 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:17:13 <mdmkolbe|work> @type filter
21:17:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:17:17 <AxleLonghorn> to give a little background: I know a bit of scheme, ocaml, prolog. I know about haskell, just never programmed in it
21:17:39 <AxleLonghorn> seriously?
21:17:50 <mdmkolbe|work> AxleLonghorn: haskell's zipWith is schemes multiple argument map
21:18:12 <mdmkolbe|work> [f x | x <- xs] === map f xs
21:18:52 <mdmkolbe|work> [f x | x <- xs, even x] === map f (filter even xs)
21:18:57 <mdmkolbe|work> and so on
21:19:09 <AxleLonghorn> huh
21:19:20 <AxleLonghorn> good to know, thanks
21:20:01 <mdmkolbe|work> (I've left out some of the complexities of variable scope, but from a programming languages theory perspective it's straitforward if a bit tedious)
21:20:53 <AxleLonghorn> man... this is making me want to learn haskell
21:21:08 <Tac-Tics> Does anyone have a mindblowing one-liner for the man?
21:21:18 <pantsd> so if I try module B(A) I get Not in Scope : type constructor or class `A`
21:21:26 <AxleLonghorn> I've been programming in ocaml lately, but the lack of this seemingly useful feature is distressing
21:22:06 <mdmkolbe|work> pantsd: module B (module a)
21:22:13 <pantsd> d'oh
21:22:23 <Tac-Tics> > filterM (const [True, False]) [1,2,3]
21:22:25 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:22:32 <Tac-Tics> that was one that I loved when I started Haskell
21:22:48 <Tac-Tics> @let powerset = filterM (const [False, True])
21:22:51 <lambdabot> Defined.
21:22:55 <mdmkolbe|work> Tac-Tics: seive of erotatheness in one line maybe?
21:22:59 <Tac-Tics> > powerset [1, 2, 3, 4]
21:22:59 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2...
21:23:01 <faxathisia> AxleLonghorn: If it helps, you can just implement prolog, then list comprehensios are e.g. bagof(Y, X^(member(X,List), even(X), Y is X + 1), Y).
21:23:04 <jsnx> :t filterM
21:23:05 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
21:23:16 <faxathisia> AxleLonghorn: also the list monad is really similar to prolog in some ways
21:23:23 <mjo> The hardest part about learning Haskell is that if you think you want a function that turns a string into an int, what you might really want is a function that takes a variable type a and a function that takes a list of bs that returns an ordered pair ([a], [b]) and returns either an a or a b. Try googling that, I dare you.
21:23:53 <faxathisia> @hoogle String -> Int
21:23:53 <lambdabot> No matches, try a more general search
21:23:59 <mjo> haha
21:24:06 <faxathisia> @hoogle a -> Int
21:24:06 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
21:24:07 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
21:24:07 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
21:24:11 <faxathisia> beaten
21:24:13 <faxathisia> :(
21:24:37 <mjo> beatiful: Data.Map.findIndex :: Ord k => k -> Map k a -> Int
21:24:39 <jsnx> :t read
21:24:40 <lambdabot> forall a. (Read a) => String -> a
21:24:57 <jsnx> @hoogle String -> a
21:24:57 <lambdabot> Prelude.error :: String -> a
21:24:57 <lambdabot> Debug.Trace.trace :: String -> a -> a
21:24:57 <lambdabot> Prelude.fail :: Monad m => String -> m a
21:25:15 <mjo> beautiful, even
21:25:15 <jsnx> @hoogle (Read a) => String -> a
21:25:16 <lambdabot> Prelude.read :: Read a => String -> a
21:25:16 <lambdabot> Text.Read.read :: Read a => String -> a
21:25:16 <lambdabot> Prelude.error :: String -> a
21:25:35 <sw17ch> this quasiquotation stuff is still giving me a headache...
21:25:43 <sw17ch> it does not fit nicely in my parser :(*
21:25:44 <jsnx> does lambdabot stop hoogling after three responses?
21:26:34 <mdmkolbe|work> AxleLonghorn: Haskell chagnes the way you think.  It's like learning functional programming for the first time with Scheme (you said you know scheme), only a whole order beyond Scheme.  You really start to program math instead of computers.  Consider this implementation of fibinoccihttp://hpaste.org/4691
21:26:38 <faxathisia> sw17ch: `(x y ,z w ,@uv) = (quasiquote (x y (unquote z) w (unquote-splicing uv))
21:26:43 <dibblego> wy, it appears one needs a paramorphism - an extension to a catamorphism, to write dropWhile
21:27:08 <wy> dibblego: uhh
21:27:20 <sw17ch> faxathisia: oh no... what does @ represent?
21:27:28 <faxathisia> unquote-splicing
21:27:55 <sw17ch> does that show up anywhere else in the language?
21:28:06 <jsnx> AxleLonghorn: indeed, one of the real positives of haskell is allows you to think more rigorously
21:28:06 <sw17ch> and/or do you have a good example of it's use?
21:28:26 <AxleLonghorn> so yeah, this latest discovery coupled with reading a kick-ass version of fibonacci that my prof had on his website makes me want to learn the language
21:28:31 <jsnx> AxleLonghorn: and make that rigour evident in your program
21:28:56 <AxleLonghorn> the fibonacci program being fac n = foldl (*) 1 [1..n]
21:28:58 <Tac-Tics> @let primes = filter (\k -> null [x | x <- [2..k-1], k `mod` x == 0]) [2..]
21:28:59 <lambdabot> Defined.
21:29:04 <Tac-Tics> > take 20 primes
21:29:05 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
21:29:13 <faxathisia> That's notr really Fibonacci
21:29:17 <AxleLonghorn> lol, Tac-Tics, awesome
21:29:18 <faxathisia> since it's factorial
21:29:18 <mdmkolbe|work> fib n = product [1..n]
21:29:21 <Tac-Tics> @pl filter (\k -> null [x | x <- [2..k-1], k `mod` x == 0]) [2..]
21:29:21 <lambdabot> filter (null . ap ((:) . ((x | x) <-) . enumFromTo 2 . subtract 1) (return . (0 ==) . (`mod` x))) [2..]
21:29:23 <faxathisia> uh..
21:29:26 <AxleLonghorn> right
21:29:37 <Tac-Tics> AxleLonghorn: Haskell is king of the one-liners
21:29:38 <faxathisia> factorial and Fibonacci sequence are different
21:29:46 <AxleLonghorn> mistaking my f's again
21:29:52 <Tac-Tics> Haskell in some ways is sorta like the really smart man's perl =-)
21:30:12 <mdmkolbe|work> Tac-Tics: the next perl is even implemented in Haskell ;-J
21:30:13 <jsnx> Tac-Tics: yeah, or maybe there's just no way to keep those perl programmers out...
21:30:19 <faxathisia> dunno
21:30:23 <faxathisia> haskell needs syntax for regex
21:30:31 <faxathisia> if you wanna match perl
21:30:31 <jsnx> faxathisia: yeah!
21:30:35 <Zao> faxathisia: And the regex libraries don't do?
21:30:44 <faxathisia> Zao: I have no idea actually .. never trid one
21:30:51 <jsnx> Zao: they are not cute like /regex/
21:30:55 <mdmkolbe|work> faxathisia: Test.Regex
21:31:29 <mdmkolbe|work> jsnx: bah, /foo/ is just r/foo/ is just r"foo" is just regex "foo"
21:31:46 <jsnx> mdmkolbe|work: no, that is python
21:31:49 <faxathisia> backslashs quotes and etc are a bitch
21:31:52 <jsnx> /foo/ is m/foo/
21:31:56 <faxathisia> if you have to stick a regex inside a string
21:31:57 <jsnx> as in sed
21:32:05 <jsnx> faxathisia: i agree
21:32:21 <cjb> Anyone want to translate http://notes-on-haskell.blogspot.com/2007/12/taxicab-numbers.html into Python?  I'm having trouble understanding it.
21:32:22 <lambdabot> Title: Notes on Haskell: Taxicab Numbers
21:32:39 <mdmkolbe|work> jsnx: I maent qr/foo/
21:32:46 <Tac-Tics> cjb I'll take a whack
21:32:54 <jsnx> mdmkolbe|work: what the heck is that?
21:33:53 <jsnx> mdmkolbe|work: python?
21:34:03 <jsnx> mdmkolbe|work: ruby?
21:34:06 <mdmkolbe|work> jsnx: In Perl, there are special quote forms.  q/foo/ is single quote qq/foo/ is double quote and qr/foo/ is regex quote.
21:34:13 <cjb> Tac-Tics: thanks!
21:34:19 <jsnx> mdmkolbe|work: oh, i see
21:34:48 <jsnx> if i ever felt like spelling it out, i used `m/regex/` -- that still works, right?
21:35:01 <jsnx> i guess i have perl somewhere...
21:35:02 <Tac-Tics> @hpaste
21:35:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:35:08 * jsnx rummages
21:35:38 <mdmkolbe|work> jsnx: yes
21:35:54 <jsnx> mdmkolbe|work: i can not even write perl that runs anymore :(
21:35:55 <mdmkolbe|work> jsnx: qr is just the quoting form for the regex not the execution form
21:36:12 <faxathisia> jsnx: learn Perl 6
21:36:16 <AxleLonghorn> def cube(x): return x * x * x
21:36:18 <AxleLonghorn> def taxicab(n):
21:36:19 <AxleLonghorn>     return [(cube(a) + cube(b), (a, b), (c, d))
21:36:21 <AxleLonghorn>         for a in range(1, n + 1)
21:36:23 <AxleLonghorn>         for b in range(a + 1, n + 1)
21:36:24 <jsnx> faxathisia: well, i could just use Parsec...
21:36:25 <AxleLonghorn>         for c in range(a + 1, n + 1)
21:36:27 <AxleLonghorn>         for d in range(c + 1, n + 1)
21:36:28 <AxleLonghorn>         if cube(a) + cube(b) == cube(c) + cube(d)]
21:36:30 <AxleLonghorn> print taxicab(12)
21:36:32 <jsnx> faxathisia: that's what i do right now
21:36:32 <AxleLonghorn> note: not mine
21:36:32 <faxathisia> for what? :|
21:36:42 <cjb> AxleLonghorn: the indentation's messed up there.
21:36:46 <mdmkolbe|work> AxleLonghorn: don't paste more than 3 lines ust hpaste.org instread
21:36:46 <jsnx> faxathisia: instead of regexen!
21:36:53 <cjb> oh, my.  no it isn't.
21:36:54 <AxleLonghorn> gotcha
21:37:00 <faxathisia> lol
21:37:10 <jsnx> faxathisia: it's kind of nice, actually -- *very* readable
21:37:19 <faxathisia> Parsec?
21:37:25 <jsnx> faxathisia: yes
21:37:26 <hpaste>  Tac-Tics pasted "Taxicab" at http://hpaste.org/4692
21:37:33 <faxathisia> yeah It's fantastic but .. I take longer to write it than regex is all
21:37:39 <Tac-Tics> whoops, one small error
21:37:39 <jsnx> faxathisia: yes
21:37:49 <jsnx> but consider, regexen are not even pure...
21:38:14 <hpaste>  Tac-Tics annotated "Taxicab" with "(no title)" at http://hpaste.org/4692#a1
21:38:19 <jsnx> i suppose they *could* be made so
21:38:25 <faxathisia> what do you mean Pure?
21:38:40 <jsnx> i mean, they are little state machines
21:38:58 * faxathisia does not understand
21:39:10 <jsnx> they have all these 'back references' and 'look ahead' (the good ones)
21:39:29 <mdmkolbe|work> jsnx: technically they are still pure b/c they are a function
21:39:32 <loupgaroublond> can an operator be made up of four characters?
21:39:42 <jsnx> i guess what i mean is, the usual way of working with regexen does not treat them as pure functions
21:39:45 <mdmkolbe|work> loupgaroublond: what do you mean?
21:39:51 <Tac-Tics> jsnx: Using a regular expression as a predicate is a pure function
21:39:57 <jsnx> Tac-Tics: yes
21:39:58 <faxathisia> > let y($$$$) x = y+x in 1 $$$$ 2
21:39:59 <lambdabot>   Not in scope: `$$$$'
21:40:03 <faxathisia> > let y ($$$$) x = y+x in 1 $$$$ 2
21:40:04 <lambdabot>   Not in scope: `$$$$'
21:40:07 <Tac-Tics> I'm pretty sure the majority of regex use is through that
21:40:10 <mdmkolbe|work> jsnx: state machines are pure as long as the state is exlicitly passed around
21:40:16 <faxathisia> > let y ($$$) x = y+x in 1 $$$ 2
21:40:16 <lambdabot>   Not in scope: `$$$'
21:40:24 <jsnx> mdmkolbe|work: true, i got confused
21:40:25 <faxathisia> > let y $$$$ x = y+x in 1 $$$$ 2
21:40:25 <lambdabot>  3
21:40:29 <faxathisia> sorry..
21:40:34 <loupgaroublond> mdmkolbe|work: i want to make an operator -->> and -?>>
21:40:36 <cjb> Tac-Tics: thank you!
21:40:41 <jsnx> mdmkolbe|work: i was talking more about \1, \2, \3...
21:40:41 <cjb> Tac-Tics: the second example appears not to work.
21:40:46 <Tac-Tics> > let operatorAbuse = not . flood this->channel
21:40:46 <lambdabot>  Parse error at "->cha..." (column 37)
21:40:56 <Tac-Tics> I didn't run them, so they probably contain errors
21:41:00 <Tac-Tics> but that's the gist of it
21:41:08 <mdmkolbe|work> > let y -->> x = x + y in 1 -->> 2
21:41:09 <lambdabot>  3
21:41:21 <Tac-Tics> I missed a close paren on the innermost line on the second example
21:41:38 <jsnx> how is the array constructor defined?
21:41:39 <cjb> is the close paren at the end of the line?
21:41:44 <jsnx> or i mean, list
21:41:51 <Tac-Tics> :t (:)
21:41:52 <lambdabot> forall a. a -> [a] -> [a]
21:42:03 <jsnx> how do you make an 'operator' with two parts like '[...]' ?
21:42:11 <cjb>     ret.append(tuple(cube(a) + cube(b)), tuple(a, b), tuple(c, d))
21:42:11 <cjb> TypeError: 'int' object is not iterable
21:42:12 <Tac-Tics> It would look like (:) a b = Cons a b
21:42:13 <jsnx> that's what i mean
21:42:27 <mdmkolbe|work> jsnx: "data [a] = [] | a : [a]" <- not real syntax but that's the idea
21:42:29 <faxathisia> jsnx: what?
21:42:58 <mdmkolbe|work> jsnx: haskell has no curcumfix operators (though some have made tricks to simulate them)
21:42:58 <jsnx> mdmkolbe|work: could you make new operators like that?
21:43:01 <faxathisia> like [ a b ] = a >> b
21:43:03 <Tac-Tics> cjb: whoops. I put those "tuple" function calls in because otherwise it would look a little confusing
21:43:05 <faxathisia> or whatever
21:43:21 <Tac-Tics> remove the three instances of 'tuple' and that will go away
21:43:57 <mdmkolbe|work> jsnx: the usual trick is to make the last part "]" a constructor and the first part "[" a function that eats things up until the constructor.  at best it is a hack
21:43:59 <cjb> Tac-Tics: yup, works
21:44:04 <Tac-Tics> cool
21:44:06 <cjb>                         ret.append([cube(a) + cube(b), (a, b), (c, d)])
21:44:14 <jsnx> mdmkolbe|work: oh, tricky
21:44:40 <mdmkolbe|work> jsnx: realisticly haskell supports infix operators and constructors very well, but nothing beyond that
21:44:51 <jsnx> mdmkolbe|work: so, if i wanted regex syntax, i would have to overload '/' in at least two ways
21:45:57 <mdmkolbe|work> jsnx: you're better of just writting a function that takes a string representation of the regex (at least given what haskell provides)
21:46:25 <jsnx> mdmkolbe|work: i just wanted to know if it was practical, that's all
21:46:40 <faxathisia> jsnx: With a mixfix language like Agda2 you can
21:46:43 <jsnx> mdmkolbe|work: i think we have a difference of taste on the matter
21:47:06 <cjb> Tac-Tics: heh, I don't understand the second one.  :)  How does it encode the a+b == c+d constraint?
21:47:09 <faxathisia> jsnx: Check out http://www.cs.chalmers.se/~ulfn/darcs/Agda2/examples/sinatra/Typed.agda
21:47:11 <lambdabot> http://tinyurl.com/22t6j3
21:47:14 <faxathisia> as one example
21:47:30 <faxathisia> (in particular the def. and usage of ⟦_⟧ )
21:47:51 <cjb> oops, gotta run.  but thanks for taking the time, Tac-Tics!
21:47:59 <Tac-Tics> no proble
21:48:00 <Tac-Tics> m
21:48:14 <jsnx> faxathisia: the use of unicode is funny!
21:48:19 <mdmkolbe|work> jsnx: I agree that more powerful ways to tweak the syntax would be nice for Haskell (in fact I'm on a research project to to just that), but given what Haskell provides, a regex function that just takes a string representation of the regex as argument is the most practical solution (everthing else is britle)
21:48:38 <jsnx> mdmkolbe|work: oh, i see
21:48:48 <jsnx> i will just stick with parsec, i think
21:49:02 <jsnx> everything i want to do can be done that way, and it's quite readable
21:49:05 <loupgaroublond> why is it that the more you learn about monads, the more difficult they become?
21:49:28 <jsnx> mdmkolbe|work: your reasearch project, what is it?
21:49:45 <dibblego> loupgaroublond, because you may be thinking they are more complex than they really are
21:50:32 <loupgaroublond> dibblego: well, i mean there are more levels, alot of it is figuring out how this program works
21:50:53 <mdmkolbe|work> jsnx: it's not funded yet, but if it gets funded it will attempt to add the power of scheme macros to haskell in a typeful maner.  That may sound trivial but it would make things like regex quoting among other things possible
21:51:03 <faxathisia> scheme macros? :/
21:51:18 <faxathisia> why would you want that in haskell
21:51:20 <jsnx> mdmkolbe|work: well, scheme macros are the "hygienic" ones, right?
21:51:22 <mdmkolbe|work> loupgaroublond: there does eventually come a point where monads click and they become second nature
21:51:25 <dibblego> loupgaroublond, it *looks like* there are many levels, until the 'aha!' moment and it all falls away when you observe the smimplicity
21:51:26 <mdmkolbe|work> jsnx: yes
21:51:44 <jsnx> mdmkolbe|work: that means lexically scoped, among other things?
21:51:53 <Korollary> mdmkolbe|work: do you mean syntax-case kind of macros?
21:51:59 <mdmkolbe|work> jsnx: I'm specifically speaking of the syntax-case system (there have been multiple revisions)
21:52:08 <Korollary> ah yes
21:52:09 <faxathisia> what is the use?
21:52:11 <mdmkolbe|work> jsnx: basically, yes lexical
21:52:43 <mdmkolbe|work> jsnx: consider a macro (or a b) => (let ((x a)) (if x x b))
21:53:22 <faxathisia> mdmkolbe|work: What is the point in having scheme-like macros in haskell?
21:53:22 <mdmkolbe|work> if the call (or 1 x) is made we need to be sure the macro's "x" and the caller's "x" are different
21:53:33 <bos> anyone with much type-level programming experience around?
21:53:57 <mdmkolbe|work> faxathisia: the same point as "do" syntax.  In fact "do" syntax would be just a macro if we had them in Haskell.
21:54:16 <DavidLeon> hello, e.g. I get a class has three members, and i get a list of those specific class instances.
21:54:26 <faxathisia> have you got an implementation of do in your macro language??
21:54:33 <DavidLeon> How can I extract first two member and recreate a list of that?
21:54:33 <pantsd> sorry to keep on asking questions, but http://pastebin.ca/836098 doesn't work. When I run it I get an error about now instance of show for the two types.
21:55:00 <DavidLeon> or maybe it's not a class, a struct or something
21:55:07 <DavidLeon> or simply a list of a list
21:55:11 <DavidLeon> *a list of lists
21:55:41 <mdmkolbe|work> faxathisia: this is all future work the project hasn't been yet funded (though working prototypes exist that show promise), so no I haven't implemetned "do" yet but the type theory all checks out
21:55:52 <jsnx> mdmkolbe|work: i don't entirely understand syntax-case...but it would be nice to have richer macro facilities, and scheme has historically been rather innovative in that area
21:56:12 <mdmkolbe|work> DavidLeon: take 2 lst
21:56:17 <mdmkolbe|work> > take 2 [1..]
21:56:18 <lambdabot>  [1,2]
21:56:39 <bos> @users
21:56:39 <lambdabot> Maximum users seen in #haskell: 434, currently: 345 (79.5%), active: 14 (4.1%)
21:57:03 <DavidLeon> but I get a list of [(1,2,3),(2,3,4),(2,3,4),(2,3,4)] I want [(1,2),(2,3),(2,3),(2,3)]
21:57:16 <faxathisia> sigh
21:57:19 <Tac-Tics> > take (length [0..]) [0..]
21:57:21 <faxathisia> typing it is trivial
21:57:22 <lambdabot> Terminated
21:57:26 <Tac-Tics> heh
21:57:26 <mdmkolbe|work> DavidLeon: (1,2,3) is a tuple not a list
21:57:42 <Tac-Tics> Haskell may be lazier than most languages, but it's just about as headstrong
21:57:50 <DavidLeon> err
21:58:05 <DavidLeon> I mean [[1,2,3]
21:58:16 <mdmkolbe|work> Tac-Tics: except Haskell is more often right when it is head strong
21:58:18 <DavidLeon> Tac-Tics: take (length[0..2])[0..]?
21:58:26 <mdmkolbe|work> DavidLeon: map (take 2) list
21:58:51 <DavidLeon> mdmkolbe|work: how do I get the 1st, 3rd element in the sublist?
21:58:59 <Tac-Tics> DavidLeon: It was a lame attempt at a joke. If you take the first infinity of natural numbers from the list of natural numbers, the result should be the natural numbers
21:59:01 <DavidLeon> I need a more general solution
21:59:03 <Tac-Tics> but it doesn't terminate
21:59:09 <jsnx> > take (length [0..2]) [0..]
21:59:10 <lambdabot>  [0,1,2]
21:59:34 <DavidLeon> > take (length[0..])[0..]
21:59:37 <lambdabot> Terminated
21:59:47 <DavidLeon> > take (length[1..3])[0..]
21:59:48 <lambdabot>  [0,1,2]
21:59:51 <jsnx> should be [0..] i gathrer...
22:00:17 <jsnx> > x <- return $ [0..]
22:00:18 <lambdabot>  Parse error at "<-" (column 3)
22:00:27 <jsnx> > do x <- return $ [0..]
22:00:27 <lambdabot>  Parse error at end of input
22:00:38 <DavidLeon> haha
22:00:42 <DavidLeon> lambdabot is smart
22:00:45 <jsnx> > do { x <- return $ [0..]; }
22:00:45 <lambdabot>  Parse error at "}" (column 27)
22:00:49 <jsnx> bah
22:00:54 <jsnx> humbug
22:00:58 <Tac-Tics> > length [\n l -> length l, take, drop]
22:00:59 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
22:00:59 * faxathisia wonders.. why do you need money to code?
22:01:19 <Tac-Tics> money to code?
22:01:23 <jsnx> faxathisia: well, you usually have to code in python
22:01:29 <faxathisia> ..what
22:01:31 <faxathisia> no I don't
22:01:32 <jsnx> faxathisia: or (gasp) C#
22:01:35 <DavidLeon> Tac-Tics: how do I extract 1st,3rd element in my list of lists?
22:01:38 <Tac-Tics> C# is expensive
22:01:41 <faxathisia> I mean in haskell
22:01:41 <Tac-Tics> :t (!!)
22:01:42 <lambdabot> forall a. [a] -> Int -> a
22:01:48 <Tac-Tics> > [0..] !! 55
22:01:48 <lambdabot>  55
22:01:57 <Tac-Tics> > filter even [0..] !! 5
22:01:58 <lambdabot>  10
22:02:08 <Tac-Tics> > primes !! 3
22:02:09 <lambdabot>  7
22:02:36 <jsnx> faxathisia: you a student or something?
22:02:42 <mdmkolbe|work> DavidLeon: these are funny questions, perhaps you could provide a bit more background
22:03:30 <jsnx> DavidLeon: trying to extract the syntax from us piece by piece will be a slow affair
22:03:53 <DavidLeon> mdmkolbe|work: I'm thinking use a FP as a standard DB query language
22:04:22 <jsnx> DavidLeon: before you do that, have you seen Datalog?
22:04:35 <mdmkolbe|work> also LINQ
22:04:56 <DavidLeon> mdmkolbe|work: linq looks like sql?
22:05:18 <DavidLeon> I think FP expressiveness would be good for a set of datas
22:05:29 <jsnx> DavidLeon: a little bit -- it's the "relational DSL" in C#
22:05:32 <mdmkolbe|work> DavidLeon: IIRC, yes sort of, but it has a much better type/FP feel to it
22:05:51 <Tac-Tics> Anything but SQL
22:05:55 <mdmkolbe|work> map (\x -> [x !! 0, x !! 3]) list
22:06:08 <jsnx> both Haskell and Datalog are totally "decalarative"
22:06:26 <jsnx> but Datalog lays emphasis on relations
22:06:27 <DavidLeon> mdmkolbe|work: think about map (\x ->[ x!! field1, x !! field2]) mytable
22:06:35 <faxathisia> I thought that SQL is a really nicelangauge
22:06:40 <faxathisia> and I also though its quite like haskell
22:06:47 <faxathisia> but I think I am maybe wrong about this :p
22:06:48 <DavidLeon> :o
22:06:57 <jsnx> faxathisia: it is somewhat of a disappointment to relational folks
22:06:59 <Tac-Tics> SQL is weird and dumb compared to Haskell
22:07:02 <mdmkolbe|work> DavidLeon: you should also note that list comprehensions are already a sort of DB query langauge and it has conections back to monads (doesn't everything)
22:07:05 <Tac-Tics> but the principles are all there
22:07:24 * faxathisia doesn't know really relational algebra or whatever you'd have to know to be disappointed by SQL
22:07:36 <DavidLeon> mdmkolbe|work: is datalog like a FP?
22:07:46 <DavidLeon> i don't know much about prolog :(
22:07:47 <jsnx> faxathisia: if you look in to Datalog or D4, you'll see what people are talking about
22:07:59 <mdmkolbe|work> faxathisia: queries yes, anything else no.  besides being tied to a very unwildy syntax
22:08:04 <Tac-Tics> SQL works just fine, but it's got some downsides to it
22:08:05 <mdmkolbe|work> DavidLeon: I don't know datalog
22:08:08 <jsnx> DavidLeon: you can try it out at bddbddb.sourceforge.net
22:08:22 <Tac-Tics> But it's annoying there are no real alternatives to SQL for databases
22:08:32 <DavidLeon> jsnx: the name is so lame :p
22:09:38 <DavidLeon> SQL is a crap
22:09:44 <jsnx> DavidLeon: it's a researchh project, at Stanford
22:09:53 <jsnx> DavidLeon: they don't have a marketing team
22:10:02 <jsnx> DavidLeon: but they have an online applet
22:10:24 <jsnx> DavidLeon: so you can see if you like "logical" languages or not
22:10:35 <DavidLeon> jsnx: i like fp
22:10:48 <DavidLeon> err.
22:10:52 <mdmkolbe|work> bddbddb  = datalog??
22:10:52 <jsnx> DavidLeon: FP is LP are closely related, actually
22:10:58 <jsnx> mdmkolbe|work: yes
22:11:08 <jsnx> mdmkolbe|work: go to the applet
22:11:10 <DavidLeon> I mean fp should be good at handling a set of datas
22:11:25 <jsnx> DavidLeon: well, you misunderstand what it is about
22:11:35 <jsnx> FP is for handling *functions*
22:11:44 <jsnx> relations are really secondary in FP
22:11:59 <jsnx> whereas LP really focuses on relations -- making them "first class"
22:12:02 <DavidLeon> jsnx: but everything shows me that FP is the most powerful of handling a set of datas compared to anything else
22:12:04 <mdmkolbe|work> DavidLeon: before you go too far, realize that LP generalizes FP in the same way that math Relations generalize math Functions are needed to do DB programming properly
22:12:29 <jsnx> mdmkolbe|work: that came out a little garbled
22:12:33 <DavidLeon> umm
22:12:49 <loupgaroublond> in data Bool b => Match b a = Match b a, i'm getting an error that Bool is not a class, how can i restrict the type match so that b must be a boolean?
22:13:04 <jsnx> DavidLeon: FP is a good way to *transform* data
22:13:09 <faxathisia> to be honest you are best to just learn Logic Programming
22:13:16 <faxathisia> instead of diffing it against something else
22:13:41 <jsnx> DavidLeon: and it's a good way to manage the transformers
22:13:41 <DavidLeon> jsnx: everything you do with SQL is *transforming* data
22:13:46 <jsnx> DavidLeon: no
22:13:52 <mdmkolbe|work> DavidLeon: no
22:13:54 <DavidLeon> jsnx: show me exception
22:13:59 <jsnx> SELECT * FROM foo ;
22:14:02 <Korollary> select doesnt
22:14:07 <jsnx> DavidLeon: that is *querying* data
22:14:13 <DavidLeon> jsnx: it's a 1 <---> 1 transforming
22:14:17 <mdmkolbe|work> DavidLeon: anything you do with SQL is defining a mathematical relation
22:14:20 <DavidLeon> 1 to 1 mapping
22:14:26 <jsnx> DavidLeon: no, definitely not
22:14:37 <Korollary> loupgaroublond: your syntax is way hosed
22:14:46 <loupgaroublond> Korollary: how's that?
22:14:46 <jsnx> DavidLeon: because of the relations imposed by SELECT
22:14:50 <DavidLeon> jsnx: think generally
22:15:03 <jsnx> DavidLeon: i'm trying to make a specific point :)
22:15:21 <mdmkolbe|work> DavidLeon: learn about the relation algebra and relation calculus which form the internal core of any SQL DB and you will see that there is a difference
22:15:27 <DavidLeon> but in my opinion select * from table is a mapping
22:15:33 <faxathisia> mappingno
22:15:38 <faxathisia> it's might filter out things
22:15:43 <DavidLeon> mapping from already existing data to a set of data in memory
22:16:01 <DavidLeon> faxathisia: if it filers , then the mapping is slightly different, then a transforming is made
22:16:02 <faxathisia> isn't a map always ending up the same size?
22:16:04 <pantsd> how do I handle parse errors?
22:16:12 <Korollary> loupgaroublond: Look at http://haskell.org/onlinereport/decls.html#sect4.2
22:16:18 <jsnx> faxathisia: in general, no
22:16:27 <jsnx> but a functional *map* always does
22:16:30 <mdmkolbe|work> faxathisia: in haskell yes
22:16:55 <faxathisia> the size of the domain and range of a map could be different
22:17:11 <faxathisia> hmm yeah, so it is possible that SELECT is a mapping?
22:17:17 <DavidLeon> datalog is scary :(
22:17:24 <DavidLeon> I can't understand any examples of it :(
22:17:32 <mdmkolbe|work> DavidLeon: in programming anything can be considered a transformation because there is input and there is output.  the diff between non-FP, FP, and LP is in how that transformation is defined
22:17:33 <jsnx> DavidLeon: the special thing about a SELECT is you specify several constraints, and it finds all the things in the "world" that satisfy them
22:17:37 <Korollary> loupgaroublond: You can't restrict b to be boolean as boolean is not a class.
22:17:58 <jsnx> DavidLeon: that is what LP is all about
22:18:22 <mdmkolbe|work> DavidLeon: non-FP does it in terms of side effects, FP in terms of pure math functions, LP in terms of pure math constraints on relations
22:18:40 <DavidLeon> :o
22:18:46 <jsnx> DavidLeon: you won't understand it the first time around
22:18:55 <loupgaroublond> Korollary: i understand that much, but i want the data type Match to contain a Boolean and an anything
22:19:06 <Korollary> loupgaroublond: you want data Match b = Match Bool b
22:19:13 <jsnx> the applet is a nice tool to get started though:  http://bddbddb.sourceforge.net/applet.html
22:19:22 <DavidLeon> mdmkolbe|work: it's though for me to imagine how a LP based query language create a table?
22:19:22 <jsnx> it's line editing sux
22:19:30 <DavidLeon> *tough
22:19:33 <loupgaroublond> Korollary: ah...
22:19:34 <jsnx> DavidLeon: that's actually easy
22:19:53 <jsnx> DavidLeon: because a table is not different than any other relation in LP
22:20:00 <DavidLeon> jsnx: so the description restrict the table meta definition?
22:20:17 <loupgaroublond> Korollary: thanks
22:20:19 <Korollary> tables are just physical manifestations.
22:20:22 <DavidLeon> jsnx: but an insert would be weird , i guess
22:20:27 <jsnx> DavidLeon: you can just substitute "relation" for "table"
22:20:29 <jsnx> DavidLeon: no
22:20:30 <mdmkolbe|work> DavidLeon: in LP a table is just a relation
22:20:58 * Korollary hasn't written in Haskell in a long while...
22:21:09 <jsnx> DavidLeon: here is an insert `food("spaghetti", "wheat").`
22:21:26 <DavidLeon> you call that LP?
22:21:35 <mdmkolbe|work> DavidLeon: just like how some functions can be implemented as a lookup table, data base "tables" are implementing a relation as a table
22:21:44 <jsnx> DavidLeon: now, if i want to see all the food, it's like this: `food(a, b)?`
22:22:11 <mdmkolbe|work> DavidLeon: I think jsnx is using Prolog syntax
22:22:17 <jsnx> DavidLeon: and if i want to see all the stuff made with wheat: `food(a, "wheat")?`
22:22:36 <jsnx> it's Datalog, so yes
22:22:46 <jsnx> all those examples work in the applet
22:22:53 <DavidLeon> jsnx: how to update
22:23:26 <jsnx> DavidLeon: just do another insert
22:23:39 <jsnx> DavidLeon: there are probably other ways, but I don't do much with Datalog in my work...
22:23:59 <DavidLeon> jsnx: or better say how do you remove
22:24:16 <DavidLeon> like remove all food made by wheat
22:24:16 <jsnx> DavidLeon: don't know, never done it :)
22:24:29 <jsnx> DavidLeon: you might use 'negation'
22:24:36 <jsnx> DavidLeon: never done that before
22:24:52 <DavidLeon> huh ^_^
22:24:57 <jsnx> DavidLeon: i have a question for you -- what is a purely functional way to do an update?
22:25:02 <DavidLeon> but thx for the useful information
22:25:14 <jsnx> DavidLeon: the question you ask is actually hard in any declarative language
22:25:20 <jsnx> including Haskell
22:25:21 <mdmkolbe|work> DavidLeon, jsnx: in LP theory, negative information (e.g. deletion) is problematic
22:25:29 <jsnx> mdmkolbe|work: yes, it is
22:26:10 <DavidLeon> jsnx: just add a restriction to the definition of the table, after taking effect remove the restriction
22:26:12 <jsnx> mdmkolbe|work: since bddbddb was intended for static analysis, not interactive use, i don't thing they ever actually needed that
22:26:25 <faxathisia> no it's quite easy to do this
22:26:38 <DavidLeon> jsnx: this is what I would think if i need to remove something in a table in a declarative language
22:26:46 <DavidLeon> *from a table
22:26:48 <mdmkolbe|work> DavidLeon: deletion is an effect, in FP and LP effects are problematic
22:26:56 <jsnx> mdmkolbe|work: yes
22:27:15 <DavidLeon> mdmkolbe|work: but there's no way around, is it?
22:27:22 <jsnx> DavidLeon: you need to make a new table from the old, with the bad stuff removed...
22:27:33 <jsnx> that's the "declarative way"
22:27:45 <mdmkolbe|work> (oddly enough, some forms of insersion aren't effects (but only some))
22:27:52 <jsnx> mdmkolbe|work: really?
22:27:56 <jsnx> mdmkolbe|work: like?
22:29:04 <jsnx> i suppose defining *new* relations is not effectful
22:29:11 <jsnx> and that is an insert, of sorts
22:29:19 <jsnx> but what are the exceptions?
22:29:34 <mdmkolbe|work> jsnx: inserts that are just declarations of more information (rows) aren't considered effects, but if those inserts have a fixed time of occuring they become effectfull
22:29:55 <jsnx> mdmkolbe|work: i don't understand that last bit
22:30:21 <jsnx> mdmkolbe|work: what does that mean, fixed time of occurring?
22:30:49 <mdmkolbe|work> (i.e. if a program that queries then inserts produces the same effects as inserting then querieing, then it is not an effect.  otherwise the "time" ordering of the two matters and it is an effect.)
22:31:09 <jsnx> mdmkolbe|work: oh, i think i understand
22:31:22 <jsnx> mdmkolbe|work: so interactive inserting is 'effectful'
22:32:29 <mdmkolbe|work> jsnx: interactive inserting is certainly effectfull if that style is used inside a batch program
22:32:44 <jsnx> there has been recent work on XSB, a Datalog driven, SQL backed DBMS
22:32:49 <jsnx> mdmkolbe|work: aha
22:32:50 <mdmkolbe|work> jsnx: in general the prompt breaks rules though
22:33:02 <jsnx> mdmkolbe|work: indeed :)
22:34:16 <jsnx> part of the reason i'm so excited about that is that i hate SQL
22:34:24 <jsnx> and would love to get away from it
22:34:44 <jsnx> but in the webosphere, there's really nothing else out there in terms of relational data stores
22:34:45 <DavidLeon> jsnx: XSB?
22:34:47 <mdmkolbe|work> jsnx: agreed
22:34:53 <jsnx> DavidLeon: yes
22:35:04 <Korollary> it'll take a while before you can really get away from sql
22:35:04 <jsnx> DavidLeon: google it, i don't remember where it is
22:35:09 <jsnx> Korollary: i know
22:35:15 <jsnx> Korollary: i'm taking the long view
22:35:17 <Korollary> brace for impact!
22:35:34 <Korollary> oh yeah. Sanity in my fifties eh?
22:35:35 <jsnx> Korollary: yeah, but we are still way, way up in the sky
22:35:43 <jsnx> Korollary: i'm only 26
22:35:50 <jsnx> Korollary: maybe my thirties
22:35:51 <Korollary> I meant when I am 50
22:35:57 <mdmkolbe|work> DavidLeon: I hope we haven't squashed you.  There's just a whole lot of theory about LP that is really essential to understanding DB query languages.
22:36:48 <jsnx> DavidLeon: if i were you, i wouldn't learn FP -- it's too hyped. lots of people going to ICFP and stuff like that...get into LP, while it's still ivory tower
22:36:55 <jsnx> :)
22:37:07 <Korollary> I'm learning Oz
22:37:21 <Tac-Tics> what is LP?
22:37:28 <jsnx> Korollary: what is that language about?
22:37:30 <Korollary> It's a whole bunch of things
22:37:34 <jsnx> Tac-Tics: Logical Programming
22:37:34 <mdmkolbe|work> jsnx: as long as he doesn minikamren instead of Prolog; it's much more well thought out
22:37:37 <Tac-Tics> ah ok
22:37:48 <jsnx> mdmkolbe|work: i'll have to look at that
22:37:52 <Korollary> it's LP and FP and distributed etc etc
22:37:56 <mdmkolbe|work> LP = logical programing = relational programing = programming with relations instead of functions
22:38:11 <Tac-Tics> I know Logic Programming, I just never see that abbrv
22:38:19 <faxathisia> it's improvised :p
22:38:26 <faxathisia> (never seem "LP" used either)
22:38:28 <Tac-Tics> I see FP everywhere
22:38:28 <jsnx> faxathisia: i've seen it around, actually
22:38:39 <jsnx> faxathisia: like ICLP
22:38:46 <Korollary> LP also means linear programming in some circles
22:38:55 <jsnx> Korollary: oh, did not know that
22:39:06 <jsnx> Korollary: my boss is into Oz
22:39:23 <Tac-Tics> I wish I had a boss who was into anything cool
22:39:26 <Tac-Tics> I'm asuming Oz is cool
22:39:40 <Korollary> Oz is cooler than anything my boss is into
22:39:40 <jsnx> Tac-Tics: i think it's cool
22:39:44 <Tac-Tics> I don't know jack about it though.... I hate my job and my boss so much
22:39:50 <mdmkolbe|work> hmm, interesting AI project would be a bot that tries to figure out what improvised abriviations are in effect and can answer such queries.  (e.g. today LP = logical programming, in the next discussion it could be something different)
22:40:00 <jsnx> Tac-Tics: what do you do?
22:40:07 <jsnx> mdmkolbe|work: lolz
22:40:12 <Korollary> mdmkolbe|work: just use wikipedia disambiguation heh. Wisdom of the crowds ftw!
22:40:22 <Tac-Tics> P..... PHP........ I'm a horrible failure of a cs major
22:40:32 <Korollary> group hug
22:40:33 <jsnx> Tac-Tics: oh, rough
22:40:41 * jsnx hugs Tac-Tics 
22:40:41 <Tac-Tics> and it's bad PHP too
22:40:51 <Tac-Tics> I've seen better structured assembly code
22:40:55 <jsnx> Tac-Tics: lolz
22:41:04 <faxathisia> :O are you the guy that writes all those include($_GET) ??
22:41:12 <pantsd> one more question for this evening :P If I have this function that calls a parser and I print the result it works, but if I return what I was printing and print it in another function it fails. Why?
22:41:13 <Korollary> I bet the average assembly program is much better than the average php program
22:41:21 <mdmkolbe|work> Korollary: the key being *improvised* (e.g. something one would never use by itself, but that once a topic of disscusion gets started might be used)
22:41:33 <Tac-Tics> I should reread the LP chapter in SICP
22:41:46 <oerjan> pantsd: paste?
22:41:48 <Tac-Tics> I get the basic ideas, but I'm not sure what you do with logic programming
22:41:52 <jsnx> Korollary: yeah, but that's because there are so many
22:42:02 <jsnx> Tac-Tics: what you do with SQL, actually
22:42:12 <jsnx> make assertions and then answer questions
22:42:14 <oerjan> the way you say it it shouldn't happen.
22:42:29 <mdmkolbe|work> pantsd: could you clarify?
22:42:44 <Tac-Tics> Is LP equivalent in power to the List Monad?
22:42:48 <Tac-Tics> or is it a generalization?
22:42:57 <pantsd> http://pastebin.ca/836126
22:43:00 <faxathisia> Tac-Tics: It might be too advanced if you've not written Prolog before, but this paper is incredibly well written http://www.iis.sinica.edu.tw/~scm/pub/lpse00.ps.gz
22:43:02 <mdmkolbe|work> Tac-Tics: completely different
22:43:12 <jsnx> mdmkolbe|work: where is the web site for minikarmen?
22:43:22 * mdmkolbe|work goes to find it
22:43:27 <Korollary> jsnx: kamren is on sf.net I think
22:43:28 <faxathisia> in Logic Prolog with Prolog you have metalogical predicates
22:43:53 <mdmkolbe|work> http://kanren.sourceforge.net/#mini
22:43:54 <lambdabot> Title: A declarative logic programming system
22:43:55 <faxathisia> kanren is fantastic too
22:44:09 <faxathisia> but I would get the book (The Reasoned Schemer) is
22:44:13 <Tac-Tics> What's a good example of something that LP really excels at that is hard even in FP?
22:44:24 <oerjan> pantsd: what do you do to get an error?
22:44:35 <mdmkolbe|work> it only has like 4 operators, but is a complete logic system (sort of like the lambda calculus is to FP)
22:44:43 <faxathisia> Tac-Tics: check out the link
22:44:44 <faxathisia> if youlike
22:44:49 <pantsd> mdmkolbe|work: I'm using a parser to try and parse an input and if I go "print foo" then it outputs stuff but if I do return foo and then call the function and call print bar then it dies with a type error
22:45:28 <mdmkolbe|work> pantsd: there is no "return" keyword.  that is an unrelated function
22:45:34 <pantsd> "No instance for (Show (t Message))" arising from use of print
22:45:37 <faxathisia> minikanren is a fair bit more than 4 operators
22:45:52 <oerjan> pantsd: "foo"?
22:46:13 <oerjan> i would like the exact error-producing code, thank you
22:46:24 <mdmkolbe|work> faxathisia: ==, fresh, alle, conde, and run (did I miss any?)
22:46:25 <faxathisia> #s #u = fresh all alli conde condi conda condu ife ifa ifi ifu ;; are all primitives
22:46:49 <faxathisia> hmm I didn't count run
22:47:07 <faxathisia> I'm not sure to classify that as kanren or scheme..
22:47:45 <Tac-Tics> ug, I don't know if I can concentrate long enough to learn anything new tonight
22:48:08 <mdmkolbe|work> faxathisia: but alli, condi, conda, and condu are hax, #s and #u are not strictly needed (and never used).  (This is what the authors claim (they are in my department.  I know them personally))
22:48:09 <oerjan> because what you say by itself obviously shouldn't be an error, so there must be some subtle error
22:48:20 <faxathisia> mdmkolbe: hehe
22:48:25 <faxathisia> hax
22:48:34 <pantsd> oerjan: it would appear that my problem was having the return keyword there d'oh :(
22:48:45 <pantsd> if I remove the return keyword everything is happy :)
22:49:31 <mdmkolbe|work> faxathisia: yeah, they're just there to get around divergence problems.  it's an ongoing project to try to eliminate them (the most recent work (unpublished I think) has already gotten rid of several)
22:49:36 <oerjan> pantsd: oh right, that makes sense
22:49:42 <faxathisia> mdmkolbe: Cool :o
22:50:01 <pantsd> sorry everyone :) I suppose I should figure out what return actually does now :P
22:50:03 <mdmkolbe|work> pantsd: FYI, return is the name of a function.  it is not a keyword
22:50:28 <oerjan> pantsd: sorry, once you say it i actually do see the error in your code too :)
22:50:33 <Tac-Tics> > map return [1, 2, 3] :: [[Int]]
22:50:33 <pantsd> I suppose its back to reading the wiki some more before trying to write more code :)
22:50:35 <lambdabot>  [[1],[2],[3]]
22:50:45 <pantsd> thanks everyone for your help :)
22:50:46 <Tac-Tics> > map return [1, 2, 3] :: [Maybe Int]
22:50:46 <lambdabot>  [Just 1,Just 2,Just 3]
22:50:51 <faxathisia> mdmkolbe: is there a way to find out about this when it is released?
22:51:17 <oerjan> pantsd: the thing is once you do the pattern matching on Left/Right, you are _leaving_ the Parsec monad, so you no longer need do/return and stuff
22:52:57 <mdmkolbe|work> faxathisia: heh, I'm not sure.  I only know about this because I regularly talk with the authors.  I don't even know if they have a release schedule.
22:53:10 * faxathisia thinks, you are lucky :0
22:53:12 <faxathisia> :)
22:53:44 <mdmkolbe|work> faxathisia: one of the perks of being in the graduate school at indiana university
22:53:50 <mdmkolbe|work> ;-)
22:55:20 <mdmkolbe|work> faxathisia: there is always e-mail or the next revision of the reasoned schemer may have this stuff in it.  (they're shifting focus though so the next revision may be a while away)
22:56:03 * faxathisia wonders if they'd include a haskell version :D
22:57:10 <mdmkolbe|work> faxathisia: hehe, I wrote one a while back.  it only takes a couple hundred lines (unifier plus non-det monads)
22:57:33 <faxathisia> using LogicT?
22:57:33 <faxathisia> or somehingelse
22:57:58 <mdmkolbe|work> faxathisia: ListT
22:58:04 <mdmkolbe|work> I don't know LogicT
22:58:13 <faxathisia> I wrote a whole parser for prolog in haskell but I lost it :[
22:58:20 <faxathisia> (before coding the evaluator)
22:58:38 <faxathisia> LogicT is amazing
22:58:46 <mdmkolbe|work> what I wrote was a DSL so no parsing needed
22:58:54 <faxathisia> http://okmij.org/ftp/Computation/monads.html#LogicT
22:58:55 <lambdabot> Title: Monads
22:59:45 <faxathisia> I think that the same research spawned this and Reasoned Schemer)
22:59:55 <faxathisia> I could bbe wrong though.,.
23:01:59 <mdmkolbe|work> oleg, check. friedman, check. sabry, check. definately the same research
23:02:24 * faxathisia thinks you are in company of celebrities :p
23:04:07 * faxathisia wishes Amr Sabry had more code online though..
23:05:25 <mdmkolbe|work> faxathisia: they are very down to earth though, you wouldn't know they were celebs to talk to them (first time I was told I was a bit incredulus)
23:06:01 <mdmkolbe|work> Anyone know of a lazy Set implementation that could accomplish the following or do I have to write my own? http://hpaste.org/4690
23:09:50 <loupgaroublond> is there a way to have polymorphic functions without an explicit class being declared?
23:10:07 <jsnx> at times like these, i reflect on how lucky i am to know about this channel
23:10:25 <jsnx> i learn things more 2/3 of the time
23:10:50 <jsnx> and not syntax things -- rather, math things and state-of-programming things
23:11:31 <mdmkolbe|work> loupgaroublond: parametric-polymorphism: yes, ad-hoc polymorphism: no
23:12:30 <faxathisia> jsnx: Hey! Didn't you learn a syntax thing too?
23:12:34 <faxathisia> jsnx: (mixfix :p)
23:13:32 <loupgaroublond> mdmkolbe|work: well, lets say i have an operator defined in one module, i'm redefining it in another module with a different output type, howcome i get a namespace collision instead of just having them as is?
23:16:16 <Korollary> mdmkolbe|work: that kind of sets would be quite inefficient I think.
23:16:16 <mdmkolbe|work> loupgaroublond: that simple answer is that haskell doesn't do the same sort of function overloading that C++ does because it has to infer types and function overloading uses the types to desides on which function to use.  The work around is to either make those functions never imported into the same scope or used the "import qualified Mod_name as prefix" form
23:16:17 <mdmkolbe|work> (or use a class but given the description that isn't what you want)
23:16:59 <loupgaroublond> mdmkolbe|work: i would love to change it, but i'm prototyping an extension idea for something, and i can't change the core myself (yet)
23:17:32 <oerjan> loupgaroublond: you could define a class and make both the special cases instances of it
23:17:38 <mdmkolbe|work> Korollary: maybe, but I think it is what I need
23:18:09 <mdmkolbe|work> loupgaroublond: so the core has one function and your extension has the other function?
23:18:11 <Korollary> mdmkolbe|work: If you don't care about speed, you might as well use a list
23:18:59 <mdmkolbe|work> Korollary: that won't be lazy enough
23:19:19 <mdmkolbe|work> Korollary: try that code, with a list. it will go into a loop
23:19:35 <mdmkolbe|work> s/list/sorted list/
23:20:56 <mdmkolbe|work> Korollary: I'll have to think whether an unsorted list might be lazy enough in the general case (I don't think so because it is the monoid in a Writer monad which uses append which isn't very lazy)
23:20:57 <Korollary> no sorting
23:21:03 <oerjan> mdmkolbe|work: my intuition says that any kind of sorting would ruin laziness, because it means you need to consider other elements to find the resulting structure
23:21:32 <oerjan> only by accessing things strictly in reverse order of inserting do you stand a chanc
23:21:36 <oerjan> *e
23:22:49 <oerjan> mdmkolbe|work: what about a function X -> Bool implementation?
23:22:57 <loupgaroublond> mdmkolbe|work: sorta, i actually came up with an idea that makes the types a bit screwier, so having different operators for now might be a better idea
23:24:01 <hpaste>  (anonymous) annotated "Is there a lazy IntSet?" with "updated to account for list suggestion" at http://hpaste.org/4690#a1
23:24:36 <oerjan> er wait that makes actually listing the elements impossible
23:25:12 <mdmkolbe|work> oerjan: technically I don't need the elements listed
23:26:49 <sjanssen> @keal
23:26:49 <lambdabot> pork steaks taste like dick
23:27:24 <sjanssen> mdmkolbe|work: I've got a lazy Int trie somewhere around here
23:27:28 * sjanssen looks for it
23:27:42 <mdmkolbe|work> oerjan: off the top of my head, I don't see any problem with X -> Bool.  though I'll have to think through the computational complexity
23:27:52 <oerjan> oh, tries could work
23:28:16 <hpaste>  sjanssen annotated "Is there a lazy IntSet?" with "more than you really want, but meh" at http://hpaste.org/4690#a2
23:28:21 <oerjan> since everything is in a fixed spot you again don't need to look at other elements
23:29:12 <mdmkolbe|work> tries could work, but in order to work they would have to be infinite (not a problem) and recopy every constructor on each union (there will be a lot of unions (it's a writer monad)) so the complexity could get bad (a problem)
23:29:51 <sjanssen> is it absolutely necessary to generate the set iteratively?
23:30:17 <mdmkolbe|work> sjanssen: ?
23:30:49 <sjanssen> mdmkolbe|work: I'm curious whether the problem is necessarily stateful, or whether you can express it as a simple recursive function
23:33:30 <mdmkolbe|work> sjanssen: the problem is inlining a scheme program.  information has to be collected about whether variables get refed or assigned in the resulting optimized program (I'm using a Writer), and that information is used to determine how to do the inlining (I'm using a Reader that takes input from the Writer).  If a var is assigned ref's to it can't be copy-propagated, but an assignment only needs to be there if it's var is actually refed somewh
23:34:10 <mdmkolbe|work> the sets I'm dealing with have to do with the set of vars refed and the set of vars assigned.
23:34:21 <sjanssen> mdmkolbe|work: sounds like "stateful" to me :)
23:35:35 <mdmkolbe|work> sjanssen: well it's definately not simple.  :-) It's one of the crazyest uses of lazyness I've done in a while.
23:36:01 <sjanssen> perhaps you just use lists and forget about complexity?
23:36:45 <mdmkolbe|work> well... the point of the inlining algorithm is that it is linear
23:39:19 <hpaste>  (anonymous) annotated "Is there a lazy IntSet?" with "fix annotation 1" at http://hpaste.org/4690#a3
23:39:34 <mdmkolbe|work> There I think that shows why lists won't work
23:40:12 <mdmkolbe|work> the union comes due to the bind operator for Writer
23:42:54 <mdmkolbe|work> @hoogle a -> [a] -> Bool
23:42:54 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
23:42:54 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
23:42:54 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
23:44:04 <mdmkolbe|work> nm, that works even for lists.  ah, the hazards of thinking at 3AM
23:44:33 <Korollary> #haskell should drink more
23:45:19 <mdmkolbe|work> @hoogle a -> [a] -> [a]
23:45:19 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
23:45:20 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:45:20 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
23:45:25 <mdmkolbe|work> @more
23:45:32 <Korollary> are you at work at 3am?
23:45:49 <Korollary> I wanna hire you
23:46:20 <sjanssen> yes, #haskell, let's all have a drink
23:46:26 <ivanm> mdmkolbe|work: is that one of the hazards of thinking at 3AM, or of just thinking in the first place? :p
23:46:52 <ivanm> sjanssen: what, drink during the afternoon? :o
23:46:58 <mdmkolbe|work> Korollary: I'm working at 3am, just not at work, but from my work machine.  local network blocks port 6667 so I have to SSH in to my work machine to use IRC
23:47:08 <ivanm> you _that_ desperate to get wasted? :p
23:47:25 <sjanssen> ivanm: it's a reasonable time for me :)
23:48:01 <ivanm> yes, but you did say _all_!
23:48:49 <Korollary> nobody said all. I said more.
23:49:07 <ivanm> sjanssen sad all
23:49:11 <ivanm> *said
23:49:19 <ivanm> <sjanssen> yes, #haskell, let's all have a drink
23:49:41 <Korollary> sjanssen was so wrong
23:49:53 * jsnx toasts
23:50:18 * jsnx in munchner stadt im haufbrau haus
23:50:26 <sjanssen> ivanm: okay, I'll have your drink
23:50:36 <sjanssen> @useres
23:50:36 <lambdabot> Maximum users seen in #haskell: 434, currently: 347 (80.0%), active: 7 (2.0%)
23:50:51 <ivanm> sjanssen: go ahead, I don't imbibe anyway ;-)
23:50:51 <sjanssen> I assume someone is picking up the excess 345?
23:51:05 * ivanm passes sjanssen some noxious looking bubbling brew
23:51:15 <ivanm> they can get their own
23:51:19 <jsnx> (it is poison, don't drink it)
23:51:28 <ivanm> jsnx: ssshhhhh!!!
23:52:02 <jsnx> okay guys, come, on, this is getting to be like that server they get all the bash.org quotes from
23:52:12 <Korollary> This is that server.
23:52:21 <Korollary> @keal
23:52:27 <lambdabot> are there full body recognition files for sorting art?
23:52:40 <Korollary> That is impressive.
23:52:46 <sjanssen> @protontorpedo
23:52:46 <Korollary> I hadn't heard that before.
23:52:47 <lambdabot> so if I learn haskell i can make cool interactive websites and get rich right?
23:52:53 <hpaste>  mdmkolbe|work annotated "Is there a lazy IntSet?" with "another try at the problem with lists" at http://hpaste.org/4690#a4
23:54:52 <mdmkolbe|work> I think lists based and (X -> Bool) based implementats of sets will fail that case though a careful Trie implementation should still work
23:55:15 <jsnx> @bash
23:55:15 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
23:56:15 <davidL> @help bash
23:56:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:56:28 <jsnx> @bash.org
23:56:28 <lambdabot> Unknown command, try @list
23:56:34 <jsnx> foo!
23:56:43 <ivanm> bar!
23:56:50 <oerjan> @bas
23:56:50 <Korollary> how is bash anywhere near tell?
23:56:50 <lambdabot> Maybe you meant: ask b52s bf bug faq map
23:56:51 <jsnx> @foo
23:56:51 <lambdabot> Maybe you meant: faq ft todo yow
23:57:10 * oerjan suspects @bash -> @ask
23:57:18 <jsnx> @ask
23:57:19 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
23:57:24 <jsnx> lolz
23:57:40 <ivanm> @help ask
23:57:41 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
23:57:55 <ivanm> duh, links to @tell
23:58:12 <jsnx> @ask ivanm helloz
23:58:12 <lambdabot> Consider it noted.
23:58:26 <ivanm> @messages
23:58:26 <lambdabot> jsnx asked 14s ago: helloz
23:58:27 <oerjan> not exactly, but it's the same plugin
23:58:31 <oerjan> @list tell
23:58:31 <lambdabot> tell provides: tell ask messages messages? clear-messages
23:58:44 <ivanm> though I thought lambdabot said "ask <person> yourself" if they were online...
23:58:45 <jsnx> i've always wanted to know how that worked
23:59:10 <ivanm> well, now you know!
23:59:24 <jsnx> moo hoo ha ha ha
23:59:34 <jsnx> and knowing is half the battle!
23:59:41 <jsnx> GI Joe!
23:59:43 <ivanm> is that a song?
23:59:43 <ivanm> :p
23:59:55 <jsnx> it is an american cartoon
